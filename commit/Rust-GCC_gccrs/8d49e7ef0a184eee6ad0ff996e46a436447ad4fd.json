{"sha": "8d49e7ef0a184eee6ad0ff996e46a436447ad4fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ0OWU3ZWYwYTE4NGVlZTZhZDBmZjk5NmU0NmE0MzY0NDdhZDRmZA==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2013-11-28T21:45:21Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2013-11-28T21:45:21Z"}, "message": "re PR target/57293 (not needed frame pointers on IA-32 (performance regression?))\n\n2013-11-28  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR target/57293\n\t* ira.h (ira_setup_eliminable_regset): Remove parameter.\n\t* ira.c (ira_setup_eliminable_regset): Ditto.  Add\n\tSUPPORTS_STACK_ALIGNMENT for crtl->stack_realign_needed.\n\tDon't call lra_init_elimination.\n\t(ira): Call ira_setup_eliminable_regset without arguments.\n\t* loop-invariant.c (calculate_loop_reg_pressure): Remove argument\n\tfrom ira_setup_eliminable_regset call.\n\t* gcse.c (calculate_bb_reg_pressure): Ditto.\n\t* haifa-sched.c (sched_init): Ditto.\n\t* lra.h (lra_init_elimination): Remove the prototype.\n\t* lra-int.h (lra_insn_recog_data): New member sp_offset.  Move\n\tused_insn_alternative upper.\n\t(lra_eliminate_regs_1): Add one more parameter.\n\t(lra-eliminate): Ditto.\n\t* lra.c (lra_invalidate_insn_data): Set sp_offset.\n\t(setup_sp_offset): New.\n\t(lra_process_new_insns): Call setup_sp_offset.\n\t(lra): Add argument to lra_eliminate calls.\n\t* lra-constraints.c (get_equiv_substitution): Rename to get_equiv.\n\t(get_equiv_with_elimination): New.\n\t(process_addr_reg): Call get_equiv_with_elimination instead of\n\tget_equiv_substitution.\n\t(equiv_address_substitution): Ditto.\n\t(loc_equivalence_change_p): Ditto.\n\t(loc_equivalence_callback, lra_constraints): Ditto.\n\t(curr_insn_transform): Ditto.  Print the sp offset\n\t(process_alt_operands): Prevent stack pointer reloads.\n\t(lra_constraints): Remove one argument from lra_eliminate call.\n\tMove it up.  Mark used hard regs bfore it.  Use\n\tget_equiv_with_elimination instead of get_equiv_substitution.\n\t* lra-eliminations.c (lra_eliminate_regs_1): Add parameter and\n\tassert for param values combination.  Use sp offset.  Add argument\n\tto lra_eliminate_regs_1 calls.\n\t(lra_eliminate_regs): Add argument to lra_eliminate_regs_1 call.\n\t(curr_sp_change): New static var.\n\t(mark_not_eliminable): Add parameter.  Update curr_sp_change.\n\tDon't prevent elimination to sp if we can calculate its change.\n\tPass the argument to mark_not_eliminable calls.\n\t(eliminate_regs_in_insn): Add a parameter.  Use sp offset.  Add\n\targument to lra_eliminate_regs_1 call.\n\t(update_reg_eliminate): Move calculation of hard regs for spill\n\tlower.  Switch off lra_in_progress temporarily to generate regs\n\tinvolved into elimination.\n\t(lra_init_elimination): Rename to init_elimination.  Make it\n\tstatic.  Set up insn sp offset, check the offsets at the end of\n\tBBs.\n\t(process_insn_for_elimination): Add parameter.  Pass its value to\n\teliminate_regs_in_insn.\n\t(lra_eliminate): : Add parameter.  Pass its value to\n\tprocess_insn_for_elimination.  Add assert for param values\n\tcombination.  Call init_elimination.  Don't update offsets in\n\tequivalence substitutions.\n\t* lra-spills.c (assign_mem_slot): Don't call lra_eliminate_regs_1\n\tfor created stack slot.\n\t(remove_pseudos): Call lra_eliminate_regs_1 before changing memory\n\tonto stack slot.\n\n2013-11-28  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR target/57293\n\t* gcc.target/i386/pr57293.c: New.\n\nFrom-SVN: r205498", "tree": {"sha": "8e53b691642d91d3aad508011d5a8ecd9ce386c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e53b691642d91d3aad508011d5a8ecd9ce386c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d49e7ef0a184eee6ad0ff996e46a436447ad4fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d49e7ef0a184eee6ad0ff996e46a436447ad4fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d49e7ef0a184eee6ad0ff996e46a436447ad4fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d49e7ef0a184eee6ad0ff996e46a436447ad4fd/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fca0efebc4b18ef0ca57c900e85a4762287bfc93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fca0efebc4b18ef0ca57c900e85a4762287bfc93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fca0efebc4b18ef0ca57c900e85a4762287bfc93"}], "stats": {"total": 545, "additions": 382, "deletions": 163}, "files": [{"sha": "ce7720414e9dd5d46504485bfd07ea974480d14d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d49e7ef0a184eee6ad0ff996e46a436447ad4fd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d49e7ef0a184eee6ad0ff996e46a436447ad4fd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8d49e7ef0a184eee6ad0ff996e46a436447ad4fd", "patch": "@@ -1,3 +1,63 @@\n+2013-11-28  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR target/57293\n+\t* ira.h (ira_setup_eliminable_regset): Remove parameter.\n+\t* ira.c (ira_setup_eliminable_regset): Ditto.  Add\n+\tSUPPORTS_STACK_ALIGNMENT for crtl->stack_realign_needed.\n+\tDon't call lra_init_elimination.\n+\t(ira): Call ira_setup_eliminable_regset without arguments.\n+\t* loop-invariant.c (calculate_loop_reg_pressure): Remove argument\n+\tfrom ira_setup_eliminable_regset call.\n+\t* gcse.c (calculate_bb_reg_pressure): Ditto.\n+\t* haifa-sched.c (sched_init): Ditto.\n+\t* lra.h (lra_init_elimination): Remove the prototype.\n+\t* lra-int.h (lra_insn_recog_data): New member sp_offset.  Move\n+\tused_insn_alternative upper.\n+\t(lra_eliminate_regs_1): Add one more parameter.\n+\t(lra-eliminate): Ditto.\n+\t* lra.c (lra_invalidate_insn_data): Set sp_offset.\n+\t(setup_sp_offset): New.\n+\t(lra_process_new_insns): Call setup_sp_offset.\n+\t(lra): Add argument to lra_eliminate calls.\n+\t* lra-constraints.c (get_equiv_substitution): Rename to get_equiv.\n+\t(get_equiv_with_elimination): New.\n+\t(process_addr_reg): Call get_equiv_with_elimination instead of\n+\tget_equiv_substitution.\n+\t(equiv_address_substitution): Ditto.\n+\t(loc_equivalence_change_p): Ditto.\n+\t(loc_equivalence_callback, lra_constraints): Ditto.\n+\t(curr_insn_transform): Ditto.  Print the sp offset\n+\t(process_alt_operands): Prevent stack pointer reloads.\n+\t(lra_constraints): Remove one argument from lra_eliminate call.\n+\tMove it up.  Mark used hard regs bfore it.  Use\n+\tget_equiv_with_elimination instead of get_equiv_substitution.\n+\t* lra-eliminations.c (lra_eliminate_regs_1): Add parameter and\n+\tassert for param values combination.  Use sp offset.  Add argument\n+\tto lra_eliminate_regs_1 calls.\n+\t(lra_eliminate_regs): Add argument to lra_eliminate_regs_1 call.\n+\t(curr_sp_change): New static var.\n+\t(mark_not_eliminable): Add parameter.  Update curr_sp_change.\n+\tDon't prevent elimination to sp if we can calculate its change.\n+\tPass the argument to mark_not_eliminable calls.\n+\t(eliminate_regs_in_insn): Add a parameter.  Use sp offset.  Add\n+\targument to lra_eliminate_regs_1 call.\n+\t(update_reg_eliminate): Move calculation of hard regs for spill\n+\tlower.  Switch off lra_in_progress temporarily to generate regs\n+\tinvolved into elimination.\n+\t(lra_init_elimination): Rename to init_elimination.  Make it\n+\tstatic.  Set up insn sp offset, check the offsets at the end of\n+\tBBs.\n+\t(process_insn_for_elimination): Add parameter.  Pass its value to\n+\teliminate_regs_in_insn.\n+\t(lra_eliminate): : Add parameter.  Pass its value to\n+\tprocess_insn_for_elimination.  Add assert for param values\n+\tcombination.  Call init_elimination.  Don't update offsets in\n+\tequivalence substitutions.\n+\t* lra-spills.c (assign_mem_slot): Don't call lra_eliminate_regs_1\n+\tfor created stack slot.\n+\t(remove_pseudos): Call lra_eliminate_regs_1 before changing memory\n+\tonto stack slot.\n+\n 2013-11-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/arm/iterators.md (vrint_conds): New int attribute."}, {"sha": "2c1ca21586e225196b7b4dc23d52522fe3beb842", "filename": "gcc/gcse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d49e7ef0a184eee6ad0ff996e46a436447ad4fd/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d49e7ef0a184eee6ad0ff996e46a436447ad4fd/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=8d49e7ef0a184eee6ad0ff996e46a436447ad4fd", "patch": "@@ -3509,7 +3509,7 @@ calculate_bb_reg_pressure (void)\n   bitmap_iterator bi;\n \n \n-  ira_setup_eliminable_regset (false);\n+  ira_setup_eliminable_regset ();\n   curr_regs_live = BITMAP_ALLOC (&reg_obstack);\n   FOR_EACH_BB (bb)\n     {"}, {"sha": "d96d16cff4d110ba91e53006cd6c2c3421f5de22", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d49e7ef0a184eee6ad0ff996e46a436447ad4fd/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d49e7ef0a184eee6ad0ff996e46a436447ad4fd/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=8d49e7ef0a184eee6ad0ff996e46a436447ad4fd", "patch": "@@ -6623,7 +6623,7 @@ sched_init (void)\n     sched_pressure = SCHED_PRESSURE_NONE;\n \n   if (sched_pressure != SCHED_PRESSURE_NONE)\n-    ira_setup_eliminable_regset (false);\n+    ira_setup_eliminable_regset ();\n \n   /* Initialize SPEC_INFO.  */\n   if (targetm.sched.set_sched_flags)"}, {"sha": "b3477ae9162b96821e13d6ec92e294c12f9919de", "filename": "gcc/ira.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d49e7ef0a184eee6ad0ff996e46a436447ad4fd/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d49e7ef0a184eee6ad0ff996e46a436447ad4fd/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=8d49e7ef0a184eee6ad0ff996e46a436447ad4fd", "patch": "@@ -2380,11 +2380,10 @@ compute_regs_asm_clobbered (void)\n }\n \n \n-/* Set up ELIMINABLE_REGSET, IRA_NO_ALLOC_REGS, and REGS_EVER_LIVE.\n-   If the function is called from IRA (not from the insn scheduler or\n-   RTL loop invariant motion), FROM_IRA_P is true.  */\n+/* Set up ELIMINABLE_REGSET, IRA_NO_ALLOC_REGS, and\n+   REGS_EVER_LIVE.  */\n void\n-ira_setup_eliminable_regset (bool from_ira_p)\n+ira_setup_eliminable_regset (void)\n {\n #ifdef ELIMINABLE_REGS\n   int i;\n@@ -2401,16 +2400,16 @@ ira_setup_eliminable_regset (bool from_ira_p)\n \t  if the stack pointer is moving.  */\n        || (flag_stack_check && STACK_CHECK_MOVING_SP)\n        || crtl->accesses_prior_frames\n-       || crtl->stack_realign_needed\n+       || (SUPPORTS_STACK_ALIGNMENT && crtl->stack_realign_needed)\n        /* We need a frame pointer for all Cilk Plus functions that use\n \t  Cilk keywords.  */\n        || (flag_enable_cilkplus && cfun->is_cilk_function)\n        || targetm.frame_pointer_required ());\n \n-  if (from_ira_p && ira_use_lra_p)\n-    /* It can change FRAME_POINTER_NEEDED.  We call it only from IRA\n-       because it is expensive.  */\n-    lra_init_elimination ();\n+    /* The chance that FRAME_POINTER_NEEDED is changed from inspecting\n+       RTL is very small.  So if we use frame pointer for RA and RTL\n+       actually prevents this, we will spill pseudos assigned to the\n+       frame pointer in LRA.  */\n \n   if (frame_pointer_needed)\n     df_set_regs_ever_live (HARD_FRAME_POINTER_REGNUM, true);\n@@ -5291,7 +5290,7 @@ ira (FILE *f)\n     find_moveable_pseudos ();\n \n   max_regno_before_ira = max_reg_num ();\n-  ira_setup_eliminable_regset (true);\n+  ira_setup_eliminable_regset ();\n \n   ira_overall_cost = ira_reg_cost = ira_mem_cost = 0;\n   ira_load_cost = ira_store_cost = ira_shuffle_cost = 0;"}, {"sha": "3a1824b3369144d2a8709199625161a70a6f0225", "filename": "gcc/ira.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d49e7ef0a184eee6ad0ff996e46a436447ad4fd/gcc%2Fira.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d49e7ef0a184eee6ad0ff996e46a436447ad4fd/gcc%2Fira.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.h?ref=8d49e7ef0a184eee6ad0ff996e46a436447ad4fd", "patch": "@@ -178,7 +178,7 @@ extern struct ira_reg_equiv *ira_reg_equiv;\n extern void ira_init_once (void);\n extern void ira_init (void);\n extern void ira_finish_once (void);\n-extern void ira_setup_eliminable_regset (bool);\n+extern void ira_setup_eliminable_regset (void);\n extern rtx ira_eliminate_regs (rtx, enum machine_mode);\n extern void ira_set_pseudo_classes (bool, FILE *);\n extern void ira_implicitly_set_insn_hard_regs (HARD_REG_SET *);"}, {"sha": "9f1fc07900cf87dec8f09a01990d1e5687efd8dc", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d49e7ef0a184eee6ad0ff996e46a436447ad4fd/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d49e7ef0a184eee6ad0ff996e46a436447ad4fd/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=8d49e7ef0a184eee6ad0ff996e46a436447ad4fd", "patch": "@@ -1823,7 +1823,7 @@ calculate_loop_reg_pressure (void)\n \tbitmap_initialize (&LOOP_DATA (loop)->regs_ref, &reg_obstack);\n \tbitmap_initialize (&LOOP_DATA (loop)->regs_live, &reg_obstack);\n       }\n-  ira_setup_eliminable_regset (false);\n+  ira_setup_eliminable_regset ();\n   bitmap_initialize (&curr_regs_live, &reg_obstack);\n   FOR_EACH_BB (bb)\n     {"}, {"sha": "bb5242a962a1397b4602de22a106220d1ad1cbc3", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 49, "deletions": 22, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d49e7ef0a184eee6ad0ff996e46a436447ad4fd/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d49e7ef0a184eee6ad0ff996e46a436447ad4fd/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=8d49e7ef0a184eee6ad0ff996e46a436447ad4fd", "patch": "@@ -318,7 +318,7 @@ in_mem_p (int regno)\n /* If we have decided to substitute X with another value, return that\n    value, otherwise return X.  */\n static rtx\n-get_equiv_substitution (rtx x)\n+get_equiv (rtx x)\n {\n   int regno;\n   rtx res;\n@@ -337,6 +337,19 @@ get_equiv_substitution (rtx x)\n   gcc_unreachable ();\n }\n \n+/* If we have decided to substitute X with the equivalent value,\n+   return that value after elimination for INSN, otherwise return\n+   X.  */\n+static rtx\n+get_equiv_with_elimination (rtx x, rtx insn)\n+{\n+  rtx res = get_equiv (x);\n+\n+  if (x == res || CONSTANT_P (res))\n+    return res;\n+  return lra_eliminate_regs_1 (insn, res, GET_MODE (res), false, false, true);\n+}\n+\n /* Set up curr_operand_mode.  */\n static void\n init_curr_operand_mode (void)\n@@ -1101,7 +1114,7 @@ process_addr_reg (rtx *loc, rtx *before, rtx *after, enum reg_class cl)\n     {\n       regno = REGNO (reg);\n       rclass = get_reg_class (regno);\n-      if ((*loc = get_equiv_substitution (reg)) != reg)\n+      if ((*loc = get_equiv_with_elimination (reg, curr_insn)) != reg)\n \t{\n \t  if (lra_dump_file != NULL)\n \t    {\n@@ -2007,6 +2020,13 @@ process_alt_operands (int only_alternative)\n \t      int const_to_mem = 0;\n \t      bool no_regs_p;\n \n+\t      /* Never do output reload of stack pointer.  It makes\n+\t\t impossible to do elimination when SP is changed in\n+\t\t RTL.  */\n+\t      if (op == stack_pointer_rtx && ! frame_pointer_needed\n+\t\t  && curr_static_id->operand[nop].type != OP_IN)\n+\t\tgoto fail;\n+\n \t      /* If this alternative asks for a specific reg class, see if there\n \t\t is at least one allocatable register in that class.  */\n \t      no_regs_p\n@@ -2517,15 +2537,15 @@ equiv_address_substitution (struct address_info *ad)\n   else\n     {\n       base_reg = *base_term;\n-      new_base_reg = get_equiv_substitution (base_reg);\n+      new_base_reg = get_equiv_with_elimination (base_reg, curr_insn);\n     }\n   index_term = strip_subreg (ad->index_term);\n   if (index_term == NULL)\n     index_reg = new_index_reg = NULL_RTX;\n   else\n     {\n       index_reg = *index_term;\n-      new_index_reg = get_equiv_substitution (index_reg);\n+      new_index_reg = get_equiv_with_elimination (index_reg, curr_insn);\n     }\n   if (base_reg == new_base_reg && index_reg == new_index_reg)\n     return false;\n@@ -3055,7 +3075,7 @@ curr_insn_transform (void)\n \n       if (GET_CODE (old) == SUBREG)\n \told = SUBREG_REG (old);\n-      subst = get_equiv_substitution (old);\n+      subst = get_equiv_with_elimination (old, curr_insn);\n       if (subst != old)\n \t{\n \t  subst = copy_rtx (subst);\n@@ -3260,6 +3280,9 @@ curr_insn_transform (void)\n       if (INSN_CODE (curr_insn) >= 0\n           && (p = get_insn_name (INSN_CODE (curr_insn))) != NULL)\n         fprintf (lra_dump_file, \" {%s}\", p);\n+      if (curr_id->sp_offset != 0)\n+        fprintf (lra_dump_file, \" (sp_off=%\" HOST_WIDE_INT_PRINT \"d)\",\n+\t\t curr_id->sp_offset);\n        fprintf (lra_dump_file, \"\\n\");\n     }\n \n@@ -3638,7 +3661,7 @@ loc_equivalence_change_p (rtx *loc)\n   if (code == SUBREG)\n     {\n       reg = SUBREG_REG (x);\n-      if ((subst = get_equiv_substitution (reg)) != reg\n+      if ((subst = get_equiv_with_elimination (reg, curr_insn)) != reg\n \t  && GET_MODE (subst) == VOIDmode)\n \t{\n \t  /* We cannot reload debug location.  Simplify subreg here\n@@ -3648,7 +3671,7 @@ loc_equivalence_change_p (rtx *loc)\n \t  return true;\n \t}\n     }\n-  if (code == REG && (subst = get_equiv_substitution (x)) != x)\n+  if (code == REG && (subst = get_equiv_with_elimination (x, curr_insn)) != x)\n     {\n       *loc = subst;\n       return true;\n@@ -3676,7 +3699,7 @@ loc_equivalence_callback (rtx loc, const_rtx, void *)\n   if (!REG_P (loc))\n     return NULL_RTX;\n \n-  rtx subst = get_equiv_substitution (loc);\n+  rtx subst = get_equiv_with_elimination (loc, curr_insn);\n   if (subst != loc)\n     return subst;\n \n@@ -3848,21 +3871,27 @@ lra_constraints (bool first_p)\n   lra_risky_transformations_p = false;\n   new_insn_uid_start = get_max_uid ();\n   new_regno_start = first_p ? lra_constraint_new_regno_start : max_reg_num ();\n+  /* Mark used hard regs for target stack size calulations.  */\n+  for (i = FIRST_PSEUDO_REGISTER; i < new_regno_start; i++)\n+    if (lra_reg_info[i].nrefs != 0\n+\t&& (hard_regno = lra_get_regno_hard_regno (i)) >= 0)\n+      {\n+\tint j, nregs;\n+\n+\tnregs = hard_regno_nregs[hard_regno][lra_reg_info[i].biggest_mode];\n+\tfor (j = 0; j < nregs; j++)\n+\t  df_set_regs_ever_live (hard_regno + j, true);\n+      }\n+  /* Do elimination before the equivalence processing as we can spill\n+     some pseudos during elimination.  */\n+  lra_eliminate (false, first_p);\n   bitmap_initialize (&equiv_insn_bitmap, &reg_obstack);\n   for (i = FIRST_PSEUDO_REGISTER; i < new_regno_start; i++)\n     if (lra_reg_info[i].nrefs != 0)\n       {\n \tira_reg_equiv[i].profitable_p = true;\n \treg = regno_reg_rtx[i];\n-\tif ((hard_regno = lra_get_regno_hard_regno (i)) >= 0)\n-\t  {\n-\t    int j, nregs;\n-\n-\t    nregs = hard_regno_nregs[hard_regno][lra_reg_info[i].biggest_mode];\n-\t    for (j = 0; j < nregs; j++)\n-\t      df_set_regs_ever_live (hard_regno + j, true);\n-\t  }\n-\telse if ((x = get_equiv_substitution (reg)) != reg)\n+\tif (lra_get_regno_hard_regno (i) < 0 && (x = get_equiv (reg)) != reg)\n \t  {\n \t    bool pseudo_p = contains_reg_p (x, false, false);\n \n@@ -3911,15 +3940,14 @@ lra_constraints (bool first_p)\n \t      ira_reg_equiv[i].defined_p = false;\n \t    if (contains_reg_p (x, false, true))\n \t      ira_reg_equiv[i].profitable_p = false;\n-\t    if (get_equiv_substitution (reg) != reg)\n+\t    if (get_equiv (reg) != reg)\n \t      bitmap_ior_into (&equiv_insn_bitmap, &lra_reg_info[i].insn_bitmap);\n \t  }\n       }\n   /* We should add all insns containing pseudos which should be\n      substituted by their equivalences.  */\n   EXECUTE_IF_SET_IN_BITMAP (&equiv_insn_bitmap, 0, uid, bi)\n     lra_push_insn_by_uid (uid);\n-  lra_eliminate (false);\n   min_len = lra_insn_stack_length ();\n   new_insns_num = 0;\n   last_bb = NULL;\n@@ -3973,7 +4001,7 @@ lra_constraints (bool first_p)\n \t      if (GET_CODE (dest_reg) == SUBREG)\n \t\tdest_reg = SUBREG_REG (dest_reg);\n \t      if ((REG_P (dest_reg)\n-\t\t   && (x = get_equiv_substitution (dest_reg)) != dest_reg\n+\t\t   && (x = get_equiv (dest_reg)) != dest_reg\n \t\t   /* Remove insns which set up a pseudo whose value\n \t\t      can not be changed.  Such insns might be not in\n \t\t      init_insns because we don't update equiv data\n@@ -3993,8 +4021,7 @@ lra_constraints (bool first_p)\n \t\t       || in_list_p (curr_insn,\n \t\t\t\t     ira_reg_equiv\n \t\t\t\t     [REGNO (dest_reg)].init_insns)))\n-\t\t  || (((x = get_equiv_substitution (SET_SRC (set)))\n-\t\t       != SET_SRC (set))\n+\t\t  || (((x = get_equiv (SET_SRC (set))) != SET_SRC (set))\n \t\t      && in_list_p (curr_insn,\n \t\t\t\t    ira_reg_equiv\n \t\t\t\t    [REGNO (SET_SRC (set))].init_insns)))"}, {"sha": "915e3a0677ffeb041df88e9f6a05fbd34179de1a", "filename": "gcc/lra-eliminations.c", "status": "modified", "additions": 186, "deletions": 111, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d49e7ef0a184eee6ad0ff996e46a436447ad4fd/gcc%2Flra-eliminations.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d49e7ef0a184eee6ad0ff996e46a436447ad4fd/gcc%2Flra-eliminations.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-eliminations.c?ref=8d49e7ef0a184eee6ad0ff996e46a436447ad4fd", "patch": "@@ -286,10 +286,11 @@ get_elimination (rtx reg)\n }\n \n /* Scan X and replace any eliminable registers (such as fp) with a\n-   replacement (such as sp) if SUBST_P, plus an offset.\t The offset is\n+   replacement (such as sp) if SUBST_P, plus an offset.  The offset is\n    a change in the offset between the eliminable register and its\n    substitution if UPDATE_P, or the full offset if FULL_P, or\n-   otherwise zero.\n+   otherwise zero.  If FULL_P, we also use the SP offsets for\n+   elimination to SP.\n \n    MEM_MODE is the mode of an enclosing MEM.  We need this to know how\n    much to adjust a register for, e.g., PRE_DEC.  Also, if we are\n@@ -298,10 +299,10 @@ get_elimination (rtx reg)\n    outside a MEM.  In addition, we need to record the fact that a\n    hard register is referenced outside a MEM.\n \n-   Alternatively, INSN may be a note (an EXPR_LIST or INSN_LIST).\n-   That's used when we eliminate in expressions stored in notes.  */\n+   If we make full substitution to SP for non-null INSN, add the insn\n+   sp offset.  */\n rtx\n-lra_eliminate_regs_1 (rtx x, enum machine_mode mem_mode,\n+lra_eliminate_regs_1 (rtx insn, rtx x, enum machine_mode mem_mode,\n \t\t      bool subst_p, bool update_p, bool full_p)\n {\n   enum rtx_code code = GET_CODE (x);\n@@ -311,6 +312,7 @@ lra_eliminate_regs_1 (rtx x, enum machine_mode mem_mode,\n   const char *fmt;\n   int copied = 0;\n \n+  gcc_assert (!update_p || !full_p);\n   if (! current_function_decl)\n     return x;\n \n@@ -338,7 +340,12 @@ lra_eliminate_regs_1 (rtx x, enum machine_mode mem_mode,\n \t  if (update_p)\n \t    return plus_constant (Pmode, to, ep->offset - ep->previous_offset);\n \t  else if (full_p)\n-\t    return plus_constant (Pmode, to, ep->offset);\n+\t    return plus_constant (Pmode, to,\n+\t\t\t\t  ep->offset\n+\t\t\t\t  - (insn != NULL_RTX\n+\t\t\t\t     && ep->to_rtx == stack_pointer_rtx\n+\t\t\t\t     ? lra_get_insn_recog_data (insn)->sp_offset\n+\t\t\t\t     : 0));\n \t  else\n \t    return to;\n \t}\n@@ -359,6 +366,8 @@ lra_eliminate_regs_1 (rtx x, enum machine_mode mem_mode,\n \n \t      offset = (update_p\n \t\t\t? ep->offset - ep->previous_offset : ep->offset);\n+\t      if (full_p && insn != NULL_RTX && ep->to_rtx == stack_pointer_rtx)\n+\t\toffset -= lra_get_insn_recog_data (insn)->sp_offset;\n \t      if (CONST_INT_P (XEXP (x, 1))\n \t\t  && INTVAL (XEXP (x, 1)) == -offset)\n \t\treturn to;\n@@ -384,9 +393,9 @@ lra_eliminate_regs_1 (rtx x, enum machine_mode mem_mode,\n \t an address operand of a load-address insn.  */\n \n       {\n-\trtx new0 = lra_eliminate_regs_1 (XEXP (x, 0), mem_mode,\n+\trtx new0 = lra_eliminate_regs_1 (insn, XEXP (x, 0), mem_mode,\n \t\t\t\t\t subst_p, update_p, full_p);\n-\trtx new1 = lra_eliminate_regs_1 (XEXP (x, 1), mem_mode,\n+\trtx new1 = lra_eliminate_regs_1 (insn, XEXP (x, 1), mem_mode,\n \t\t\t\t\t subst_p, update_p, full_p);\n \n \tif (new0 != XEXP (x, 0) || new1 != XEXP (x, 1))\n@@ -412,10 +421,16 @@ lra_eliminate_regs_1 (rtx x, enum machine_mode mem_mode,\n \t\t\t     (ep->offset - ep->previous_offset)\n \t\t\t     * INTVAL (XEXP (x, 1)));\n \t  else if (full_p)\n-\t    return\n-\t      plus_constant (Pmode,\n-\t\t\t     gen_rtx_MULT (Pmode, to, XEXP (x, 1)),\n-\t\t\t     ep->offset * INTVAL (XEXP (x, 1)));\n+\t    {\n+\t      HOST_WIDE_INT offset = ep->offset;\n+\n+\t      if (insn != NULL_RTX && ep->to_rtx == stack_pointer_rtx)\n+\t\toffset -= lra_get_insn_recog_data (insn)->sp_offset;\n+\t      return\n+\t\tplus_constant (Pmode,\n+\t\t\t       gen_rtx_MULT (Pmode, to, XEXP (x, 1)),\n+\t\t\t       offset * INTVAL (XEXP (x, 1)));\n+\t    }\n \t  else\n \t    return gen_rtx_MULT (Pmode, to, XEXP (x, 1));\n \t}\n@@ -435,10 +450,10 @@ lra_eliminate_regs_1 (rtx x, enum machine_mode mem_mode,\n     case GE:\t   case GT:\t  case GEU:    case GTU:\n     case LE:\t   case LT:\t  case LEU:    case LTU:\n       {\n-\trtx new0 = lra_eliminate_regs_1 (XEXP (x, 0), mem_mode,\n+\trtx new0 = lra_eliminate_regs_1 (insn, XEXP (x, 0), mem_mode,\n \t\t\t\t\t subst_p, update_p, full_p);\n \trtx new1 = XEXP (x, 1)\n-\t\t   ? lra_eliminate_regs_1 (XEXP (x, 1), mem_mode,\n+\t\t   ? lra_eliminate_regs_1 (insn, XEXP (x, 1), mem_mode,\n \t\t\t\t\t   subst_p, update_p, full_p) : 0;\n \n \tif (new0 != XEXP (x, 0) || new1 != XEXP (x, 1))\n@@ -451,7 +466,7 @@ lra_eliminate_regs_1 (rtx x, enum machine_mode mem_mode,\n \t eliminate it.\t*/\n       if (XEXP (x, 0))\n \t{\n-\t  new_rtx = lra_eliminate_regs_1 (XEXP (x, 0), mem_mode,\n+\t  new_rtx = lra_eliminate_regs_1 (insn, XEXP (x, 0), mem_mode,\n \t\t\t\t\t  subst_p, update_p, full_p);\n \t  if (new_rtx != XEXP (x, 0))\n \t    {\n@@ -460,7 +475,7 @@ lra_eliminate_regs_1 (rtx x, enum machine_mode mem_mode,\n \t\t REG_DEAD note for the stack or frame pointer.\t*/\n \t      if (REG_NOTE_KIND (x) == REG_DEAD)\n \t\treturn (XEXP (x, 1)\n-\t\t\t? lra_eliminate_regs_1 (XEXP (x, 1), mem_mode,\n+\t\t\t? lra_eliminate_regs_1 (insn, XEXP (x, 1), mem_mode,\n \t\t\t\t\t\tsubst_p, update_p, full_p)\n \t\t\t: NULL_RTX);\n \n@@ -477,7 +492,7 @@ lra_eliminate_regs_1 (rtx x, enum machine_mode mem_mode,\n \t strictly needed, but it simplifies the code.  */\n       if (XEXP (x, 1))\n \t{\n-\t  new_rtx = lra_eliminate_regs_1 (XEXP (x, 1), mem_mode,\n+\t  new_rtx = lra_eliminate_regs_1 (insn, XEXP (x, 1), mem_mode,\n \t\t\t\t\t  subst_p, update_p, full_p);\n \t  if (new_rtx != XEXP (x, 1))\n \t    return\n@@ -504,7 +519,8 @@ lra_eliminate_regs_1 (rtx x, enum machine_mode mem_mode,\n       if (GET_CODE (XEXP (x, 1)) == PLUS\n \t  && XEXP (XEXP (x, 1), 0) == XEXP (x, 0))\n \t{\n-\t  rtx new_rtx = lra_eliminate_regs_1 (XEXP (XEXP (x, 1), 1), mem_mode,\n+\t  rtx new_rtx = lra_eliminate_regs_1 (insn, XEXP (XEXP (x, 1), 1),\n+\t\t\t\t\t      mem_mode,\n \t\t\t\t\t      subst_p, update_p, full_p);\n \n \t  if (new_rtx != XEXP (XEXP (x, 1), 1))\n@@ -528,14 +544,14 @@ lra_eliminate_regs_1 (rtx x, enum machine_mode mem_mode,\n     case POPCOUNT:\n     case PARITY:\n     case BSWAP:\n-      new_rtx = lra_eliminate_regs_1 (XEXP (x, 0), mem_mode,\n+      new_rtx = lra_eliminate_regs_1 (insn, XEXP (x, 0), mem_mode,\n \t\t\t\t      subst_p, update_p, full_p);\n       if (new_rtx != XEXP (x, 0))\n \treturn gen_rtx_fmt_e (code, GET_MODE (x), new_rtx);\n       return x;\n \n     case SUBREG:\n-      new_rtx = lra_eliminate_regs_1 (SUBREG_REG (x), mem_mode,\n+      new_rtx = lra_eliminate_regs_1 (insn, SUBREG_REG (x), mem_mode,\n \t\t\t\t      subst_p, update_p, full_p);\n \n       if (new_rtx != SUBREG_REG (x))\n@@ -563,12 +579,12 @@ lra_eliminate_regs_1 (rtx x, enum machine_mode mem_mode,\n       return\n \treplace_equiv_address_nv\n \t(x,\n-\t lra_eliminate_regs_1 (XEXP (x, 0), GET_MODE (x),\n+\t lra_eliminate_regs_1 (insn, XEXP (x, 0), GET_MODE (x),\n \t\t\t       subst_p, update_p, full_p));\n \n     case USE:\n       /* Handle insn_list USE that a call to a pure function may generate.  */\n-      new_rtx = lra_eliminate_regs_1 (XEXP (x, 0), VOIDmode,\n+      new_rtx = lra_eliminate_regs_1 (insn, XEXP (x, 0), VOIDmode,\n \t\t\t\t      subst_p, update_p, full_p);\n       if (new_rtx != XEXP (x, 0))\n \treturn gen_rtx_USE (GET_MODE (x), new_rtx);\n@@ -589,7 +605,7 @@ lra_eliminate_regs_1 (rtx x, enum machine_mode mem_mode,\n     {\n       if (*fmt == 'e')\n \t{\n-\t  new_rtx = lra_eliminate_regs_1 (XEXP (x, i), mem_mode,\n+\t  new_rtx = lra_eliminate_regs_1 (insn, XEXP (x, i), mem_mode,\n \t\t\t\t\t  subst_p, update_p, full_p);\n \t  if (new_rtx != XEXP (x, i) && ! copied)\n \t    {\n@@ -603,7 +619,7 @@ lra_eliminate_regs_1 (rtx x, enum machine_mode mem_mode,\n \t  int copied_vec = 0;\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    {\n-\t      new_rtx = lra_eliminate_regs_1 (XVECEXP (x, i, j), mem_mode,\n+\t      new_rtx = lra_eliminate_regs_1 (insn, XVECEXP (x, i, j), mem_mode,\n \t\t\t\t\t      subst_p, update_p, full_p);\n \t      if (new_rtx != XVECEXP (x, i, j) && ! copied_vec)\n \t\t{\n@@ -631,16 +647,21 @@ rtx\n lra_eliminate_regs (rtx x, enum machine_mode mem_mode,\n \t\t    rtx insn ATTRIBUTE_UNUSED)\n {\n-  return lra_eliminate_regs_1 (x, mem_mode, true, false, true);\n+  return lra_eliminate_regs_1 (NULL_RTX, x, mem_mode, true, false, true);\n }\n \n+/* Stack pointer offset before the current insn relative to one at the\n+   func start.  RTL insns can change SP explicitly.  We keep the\n+   changes from one insn to another through this variable.  */\n+static HOST_WIDE_INT curr_sp_change;\n+\n /* Scan rtx X for references to elimination source or target registers\n    in contexts that would prevent the elimination from happening.\n    Update the table of eliminables to reflect the changed state.\n    MEM_MODE is the mode of an enclosing MEM rtx, or VOIDmode if not\n    within a MEM.  */\n static void\n-mark_not_eliminable (rtx x)\n+mark_not_eliminable (rtx x, enum machine_mode mem_mode)\n {\n   enum rtx_code code = GET_CODE (x);\n   struct elim_table *ep;\n@@ -655,17 +676,40 @@ mark_not_eliminable (rtx x)\n     case POST_DEC:\n     case POST_MODIFY:\n     case PRE_MODIFY:\n-      if (REG_P (XEXP (x, 0)) && REGNO (XEXP (x, 0)) < FIRST_PSEUDO_REGISTER)\n-\t/* If we modify the source of an elimination rule, disable\n-\t   it.  Do the same if it is the source and not the hard frame\n-\t   register.  */\n-\tfor (ep = reg_eliminate;\n-\t     ep < &reg_eliminate[NUM_ELIMINABLE_REGS];\n+      if (XEXP (x, 0) == stack_pointer_rtx\n+\t  && ((code != PRE_MODIFY && code != POST_MODIFY)\n+\t      || (GET_CODE (XEXP (x, 1)) == PLUS\n+\t\t  && XEXP (x, 0) == XEXP (XEXP (x, 1), 0)\n+\t\t  && CONST_INT_P (XEXP (XEXP (x, 1), 1)))))\n+\t{\n+\t  int size = GET_MODE_SIZE (mem_mode);\n+\t  \n+#ifdef PUSH_ROUNDING\n+\t  /* If more bytes than MEM_MODE are pushed, account for\n+\t     them.  */\n+\t  size = PUSH_ROUNDING (size);\n+#endif\n+\t  if (code == PRE_DEC || code == POST_DEC)\n+\t    curr_sp_change -= size;\n+\t  else if (code == PRE_INC || code == POST_INC)\n+\t    curr_sp_change += size;\n+\t  else if (code == PRE_MODIFY || code == POST_MODIFY)\n+\t    curr_sp_change += INTVAL (XEXP (XEXP (x, 1), 1));\n+\t}\n+      else if (REG_P (XEXP (x, 0))\n+\t       && REGNO (XEXP (x, 0)) >= FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  /* If we modify the source of an elimination rule, disable\n+\t     it.  Do the same if it is the destination and not the\n+\t     hard frame register.  */\n+\t  for (ep = reg_eliminate;\n+\t       ep < &reg_eliminate[NUM_ELIMINABLE_REGS];\n \t       ep++)\n-\t  if (ep->from_rtx == XEXP (x, 0)\n-\t      || (ep->to_rtx == XEXP (x, 0)\n-\t\t  && ep->to_rtx != hard_frame_pointer_rtx))\n-\t    setup_can_eliminate (ep, false);\n+\t    if (ep->from_rtx == XEXP (x, 0)\n+\t\t|| (ep->to_rtx == XEXP (x, 0)\n+\t\t    && ep->to_rtx != hard_frame_pointer_rtx))\n+\t      setup_can_eliminate (ep, false);\n+\t}\n       return;\n \n     case USE:\n@@ -697,12 +741,22 @@ mark_not_eliminable (rtx x)\n       return;\n \n     case SET:\n-      /* Check for setting a hard register that we know about.\t*/\n-      if (REG_P (SET_DEST (x)) && REGNO (SET_DEST (x)) < FIRST_PSEUDO_REGISTER)\n+      if (SET_DEST (x) == stack_pointer_rtx\n+\t  && GET_CODE (SET_SRC (x)) == PLUS\n+\t  && XEXP (SET_SRC (x), 0) == SET_DEST (x)\n+\t  && CONST_INT_P (XEXP (SET_SRC (x), 1)))\n+\t{\n+\t  curr_sp_change += INTVAL (XEXP (SET_SRC (x), 1));\n+\t  return;\n+\t}\n+      if (! REG_P (SET_DEST (x))\n+\t  || REGNO (SET_DEST (x)) >= FIRST_PSEUDO_REGISTER)\n+\tmark_not_eliminable (SET_DEST (x), mem_mode);\n+      else\n \t{\n \t  /* See if this is setting the replacement hard register for\n \t     an elimination.\n-\n+\t     \n \t     If DEST is the hard frame pointer, we do nothing because\n \t     we assume that all assignments to the frame pointer are\n \t     for non-local gotos and are being done at a time when\n@@ -711,22 +765,21 @@ mark_not_eliminable (rtx x)\n \t     even a fake frame pointer) with either the real frame\n \t     pointer or the stack pointer.  Assignments to the hard\n \t     frame pointer must not prevent this elimination.  */\n-\n \t  for (ep = reg_eliminate;\n \t       ep < &reg_eliminate[NUM_ELIMINABLE_REGS];\n \t       ep++)\n \t    if (ep->to_rtx == SET_DEST (x)\n-\t\t&& SET_DEST (x) != hard_frame_pointer_rtx\n-\t\t&& (! (SUPPORTS_STACK_ALIGNMENT && stack_realign_fp\n-\t\t       && REGNO (ep->to_rtx) == STACK_POINTER_REGNUM)\n-\t\t    || GET_CODE (SET_SRC (x)) != PLUS\n-\t\t    || XEXP (SET_SRC (x), 0) != SET_DEST (x)\n-\t\t    || ! CONST_INT_P (XEXP (SET_SRC (x), 1))))\n+\t\t&& SET_DEST (x) != hard_frame_pointer_rtx)\n \t      setup_can_eliminate (ep, false);\n \t}\n+      \n+      mark_not_eliminable (SET_SRC (x), mem_mode);\n+      return;\n \n-      mark_not_eliminable (SET_DEST (x));\n-      mark_not_eliminable (SET_SRC (x));\n+    case MEM:\n+      /* Our only special processing is to pass the mode of the MEM to\n+\t our recursive call.  */\n+      mark_not_eliminable (XEXP (x, 0), GET_MODE (x));\n       return;\n \n     default:\n@@ -737,10 +790,10 @@ mark_not_eliminable (rtx x)\n   for (i = 0; i < GET_RTX_LENGTH (code); i++, fmt++)\n     {\n       if (*fmt == 'e')\n-\tmark_not_eliminable (XEXP (x, i));\n+\tmark_not_eliminable (XEXP (x, i), mem_mode);\n       else if (*fmt == 'E')\n \tfor (j = 0; j < XVECLEN (x, i); j++)\n-\t  mark_not_eliminable (XVECEXP (x, i, j));\n+\t  mark_not_eliminable (XVECEXP (x, i, j), mem_mode);\n     }\n }\n \n@@ -778,13 +831,14 @@ remove_reg_equal_offset_note (rtx insn, rtx what)\n    delete the insn as dead it if it is setting an eliminable register.\n \n    If REPLACE_P is false, just update the offsets while keeping the\n-   base register the same.  Attach the note about used elimination for\n+   base register the same.  If FIRST_P, use the sp offset for\n+   elimination to sp.  Attach the note about used elimination for\n    insns setting frame pointer to update elimination easy (without\n    parsing already generated elimination insns to find offset\n    previously used) in future.  */\n \n static void\n-eliminate_regs_in_insn (rtx insn, bool replace_p)\n+eliminate_regs_in_insn (rtx insn, bool replace_p, bool first_p)\n {\n   int icode = recog_memoized (insn);\n   rtx old_set = single_set (insn);\n@@ -914,6 +968,8 @@ eliminate_regs_in_insn (rtx insn, bool replace_p)\n \t  if (! replace_p)\n \t    {\n \t      offset += (ep->offset - ep->previous_offset);\n+\t      if (first_p && ep->to_rtx == stack_pointer_rtx)\n+\t\toffset -= lra_get_insn_recog_data (insn)->sp_offset;\n \t      offset = trunc_int_for_mode (offset, GET_MODE (plus_cst_src));\n \t    }\n \n@@ -985,8 +1041,9 @@ eliminate_regs_in_insn (rtx insn, bool replace_p)\n \t  /* Companion to the above plus substitution, we can allow\n \t     invariants as the source of a plain move.\t*/\n \t  substed_operand[i]\n-\t    = lra_eliminate_regs_1 (*id->operand_loc[i], VOIDmode,\n-\t\t\t\t    replace_p, ! replace_p, false);\n+\t    = lra_eliminate_regs_1 (insn, *id->operand_loc[i], VOIDmode,\n+\t\t\t\t    replace_p, ! replace_p && ! first_p,\n+\t\t\t\t    first_p);\n \t  if (substed_operand[i] != orig_operand[i])\n \t    validate_p = true;\n \t}\n@@ -1054,7 +1111,7 @@ spill_pseudos (HARD_REG_SET set)\n }\n \n /* Update all offsets and possibility for elimination on eliminable\n-   registers.  Spill pseudos assigned to registers which became\n+   registers.  Spill pseudos assigned to registers which are\n    uneliminable, update LRA_NO_ALLOC_REGS and ELIMINABLE_REG_SET.  Add\n    insns to INSNS_WITH_CHANGED_OFFSETS containing eliminable hard\n    registers whose offsets should be changed.  Return true if any\n@@ -1069,7 +1126,6 @@ update_reg_eliminate (bitmap insns_with_changed_offsets)\n   /* Clear self elimination offsets.  */\n   for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n     self_elim_offsets[ep->from] = 0;\n-  CLEAR_HARD_REG_SET (temp_hard_reg_set);\n   for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n     {\n       /* If it is a currently used elimination: update the previous\n@@ -1096,6 +1152,9 @@ update_reg_eliminate (bitmap insns_with_changed_offsets)\n \t    fprintf (lra_dump_file,\n \t\t     \"\tElimination %d to %d is not possible anymore\\n\",\n \t\t     ep->from, ep->to);\n+\t  /* If after processing RTL we decides that SP can be used as\n+\t     a result of elimination, it can not be changed.  */\n+\t  gcc_assert (ep->to_rtx != stack_pointer_rtx);\n \t  /* Mark that is not eliminable anymore.  */\n \t  elimination_map[ep->from] = NULL;\n \t  for (ep1 = ep + 1; ep1 < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep1++)\n@@ -1106,9 +1165,6 @@ update_reg_eliminate (bitmap insns_with_changed_offsets)\n \t      if (lra_dump_file != NULL)\n \t\tfprintf (lra_dump_file, \"    Using elimination %d to %d now\\n\",\n \t\t\t ep1->from, ep1->to);\n-\t      /* Prevent the hard register into which we eliminate now\n-\t\t from the usage for pseudos.  */\n-\t      SET_HARD_REG_BIT (temp_hard_reg_set, ep1->to);\n \t      lra_assert (ep1->previous_offset == 0);\n \t      ep1->previous_offset = ep->offset;\n \t    }\n@@ -1121,7 +1177,6 @@ update_reg_eliminate (bitmap insns_with_changed_offsets)\n \t\tfprintf (lra_dump_file, \"    %d is not eliminable at all\\n\",\n \t\t\t ep->from);\n \t      self_elim_offsets[ep->from] = -ep->offset;\n-\t      SET_HARD_REG_BIT (temp_hard_reg_set, ep->from);\n \t      if (ep->offset != 0)\n \t\tbitmap_ior_into (insns_with_changed_offsets,\n \t\t\t\t &lra_reg_info[ep->from].insn_bitmap);\n@@ -1134,23 +1189,33 @@ update_reg_eliminate (bitmap insns_with_changed_offsets)\n       INITIAL_FRAME_POINTER_OFFSET (ep->offset);\n #endif\n     }\n-  IOR_HARD_REG_SET (lra_no_alloc_regs, temp_hard_reg_set);\n-  AND_COMPL_HARD_REG_SET (eliminable_regset, temp_hard_reg_set);\n-  spill_pseudos (temp_hard_reg_set);\n   setup_elimination_map ();\n   result = false;\n+  CLEAR_HARD_REG_SET (temp_hard_reg_set);\n   for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n-    if (elimination_map[ep->from] == ep && ep->previous_offset != ep->offset)\n+    if (elimination_map[ep->from] == NULL)\n+      SET_HARD_REG_BIT (temp_hard_reg_set, ep->from);\n+    else if (elimination_map[ep->from] == ep)\n       {\n-\tbitmap_ior_into (insns_with_changed_offsets,\n-\t\t\t &lra_reg_info[ep->from].insn_bitmap);\n-\n-\t/* Update offset when the eliminate offset have been\n-\t   changed.  */\n-\tlra_update_reg_val_offset (lra_reg_info[ep->from].val,\n-\t\t\t\t   ep->offset - ep->previous_offset);\n-\tresult = true;\n+\t/* Prevent the hard register into which we eliminate from\n+\t   the usage for pseudos.  */\n+        if (ep->from != ep->to)\n+\t  SET_HARD_REG_BIT (temp_hard_reg_set, ep->to);\n+\tif (ep->previous_offset != ep->offset)\n+\t  {\n+\t    bitmap_ior_into (insns_with_changed_offsets,\n+\t\t\t     &lra_reg_info[ep->from].insn_bitmap);\n+\n+\t    /* Update offset when the eliminate offset have been\n+\t       changed.  */\n+\t    lra_update_reg_val_offset (lra_reg_info[ep->from].val,\n+\t\t\t\t       ep->offset - ep->previous_offset);\n+\t    result = true;\n+\t  }\n       }\n+  IOR_HARD_REG_SET (lra_no_alloc_regs, temp_hard_reg_set);\n+  AND_COMPL_HARD_REG_SET (eliminable_regset, temp_hard_reg_set);\n+  spill_pseudos (temp_hard_reg_set);\n   return result;\n }\n \n@@ -1194,31 +1259,54 @@ init_elim_table (void)\n   setup_can_eliminate (&reg_eliminate[0], ! frame_pointer_needed);\n #endif\n \n-  /* Count the number of eliminable registers and build the FROM and TO\n-     REG rtx's.\t Note that code in gen_rtx_REG will cause, e.g.,\n-     gen_rtx_REG (Pmode, STACK_POINTER_REGNUM) to equal stack_pointer_rtx.\n-     We depend on this.\t */\n+  /* Build the FROM and TO REG rtx's.  Note that code in gen_rtx_REG\n+     will cause, e.g., gen_rtx_REG (Pmode, STACK_POINTER_REGNUM) to\n+     equal stack_pointer_rtx.  We depend on this. Threfore we switch\n+     off that we are in LRA temporarily.  */\n+  lra_in_progress = 0;\n   for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n     {\n       ep->from_rtx = gen_rtx_REG (Pmode, ep->from);\n       ep->to_rtx = gen_rtx_REG (Pmode, ep->to);\n       eliminable_reg_rtx[ep->from] = ep->from_rtx;\n     }\n+  lra_in_progress = 1;\n }\n \n-/* Entry function for initialization of elimination once per\n-   function.  */\n-void\n-lra_init_elimination (void)\n+/* Function for initialization of elimination once per function.  It\n+   sets up sp offset for each insn.  */\n+static void\n+init_elimination (void)\n {\n+  bool stop_to_sp_elimination_p;\n   basic_block bb;\n   rtx insn;\n+  struct elim_table *ep;\n \n   init_elim_table ();\n   FOR_EACH_BB (bb)\n-    FOR_BB_INSNS (bb, insn)\n-    if (NONDEBUG_INSN_P (insn))\n-      mark_not_eliminable (PATTERN (insn));\n+    {\n+      curr_sp_change = 0;\n+      stop_to_sp_elimination_p = false;\n+      FOR_BB_INSNS (bb, insn)\n+\tif (INSN_P (insn))\n+\t  {\n+\t    lra_get_insn_recog_data (insn)->sp_offset = curr_sp_change;\n+\t    if (NONDEBUG_INSN_P (insn))\n+\t      {\n+\t\tmark_not_eliminable (PATTERN (insn), VOIDmode);\n+\t\tif (curr_sp_change != 0\n+\t\t    && find_reg_note (insn, REG_LABEL_OPERAND, NULL_RTX))\n+\t\t  stop_to_sp_elimination_p = true;\n+\t      }\n+\t  }\n+      if (! frame_pointer_needed\n+\t  && (curr_sp_change != 0 || stop_to_sp_elimination_p)\n+\t  && bb->succs && bb->succs->length () != 0)\n+\tfor (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n+\t  if (ep->to == STACK_POINTER_REGNUM)\n+\t    setup_can_eliminate (ep, false);\n+    }\n   setup_elimination_map ();\n }\n \n@@ -1237,12 +1325,13 @@ lra_eliminate_reg_if_possible (rtx *loc)\n     *loc = ep->to_rtx;\n }\n \n-/* Do (final if FINAL_P) elimination in INSN.  Add the insn for\n-   subsequent processing in the constraint pass, update the insn info.\t*/\n+/* Do (final if FINAL_P or first if FIRST_P) elimination in INSN.  Add\n+   the insn for subsequent processing in the constraint pass, update\n+   the insn info.  */\n static void\n-process_insn_for_elimination (rtx insn, bool final_p)\n+process_insn_for_elimination (rtx insn, bool final_p, bool first_p)\n {\n-  eliminate_regs_in_insn (insn, final_p);\n+  eliminate_regs_in_insn (insn, final_p, first_p);\n   if (! final_p)\n     {\n       /* Check that insn changed its code.  This is a case when a move\n@@ -1262,20 +1351,23 @@ process_insn_for_elimination (rtx insn, bool final_p)\n }\n \n /* Entry function to do final elimination if FINAL_P or to update\n-   elimination register offsets.  */\n+   elimination register offsets (FIRST_P if we are doing it the first\n+   time).  */\n void\n-lra_eliminate (bool final_p)\n+lra_eliminate (bool final_p, bool first_p)\n {\n-  int i;\n   unsigned int uid;\n-  rtx mem_loc, invariant;\n   bitmap_head insns_with_changed_offsets;\n   bitmap_iterator bi;\n   struct elim_table *ep;\n-  int regs_num = max_reg_num ();\n+\n+  gcc_assert (! final_p || ! first_p);\n \n   timevar_push (TV_LRA_ELIMINATE);\n \n+  if (first_p)\n+    init_elimination ();\n+\n   bitmap_initialize (&insns_with_changed_offsets, &reg_obstack);\n   if (final_p)\n     {\n@@ -1299,28 +1391,11 @@ lra_eliminate (bool final_p)\n       fprintf (lra_dump_file, \"New elimination table:\\n\");\n       print_elim_table (lra_dump_file);\n     }\n-  for (i = FIRST_PSEUDO_REGISTER; i < regs_num; i++)\n-    if (lra_reg_info[i].nrefs != 0)\n-      {\n-\tmem_loc = ira_reg_equiv[i].memory;\n-\tif (mem_loc != NULL_RTX)\n-\t  mem_loc = lra_eliminate_regs_1 (mem_loc, VOIDmode,\n-\t\t\t\t\t  final_p, ! final_p, false);\n-\tira_reg_equiv[i].memory = mem_loc;\n-\tinvariant = ira_reg_equiv[i].invariant;\n-\tif (invariant != NULL_RTX)\n-\t  invariant = lra_eliminate_regs_1 (invariant, VOIDmode,\n-\t\t\t\t\t    final_p, ! final_p, false);\n-\tira_reg_equiv[i].invariant = invariant;\n-\tif (lra_dump_file != NULL\n-\t    && (mem_loc != NULL_RTX || invariant != NULL))\n-\t  fprintf (lra_dump_file,\n-\t\t   \"Updating elimination of equiv for reg %d\\n\", i);\n-      }\n   EXECUTE_IF_SET_IN_BITMAP (&insns_with_changed_offsets, 0, uid, bi)\n     /* A dead insn can be deleted in process_insn_for_elimination.  */\n     if (lra_insn_recog_data[uid] != NULL)\n-      process_insn_for_elimination (lra_insn_recog_data[uid]->insn, final_p);\n+      process_insn_for_elimination (lra_insn_recog_data[uid]->insn,\n+\t\t\t\t    final_p, first_p);\n   bitmap_clear (&insns_with_changed_offsets);\n \n lra_eliminate_done:"}, {"sha": "6d8d80fc592f00ea2bd90ec1550d74d4b80939a0", "filename": "gcc/lra-int.h", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d49e7ef0a184eee6ad0ff996e46a436447ad4fd/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d49e7ef0a184eee6ad0ff996e46a436447ad4fd/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=8d49e7ef0a184eee6ad0ff996e46a436447ad4fd", "patch": "@@ -207,6 +207,12 @@ struct lra_insn_recog_data\n {\n   /* The insn code.  */\n   int icode;\n+  /* The alternative should be used for the insn, -1 if invalid, or we\n+     should try to use any alternative, or the insn is a debug\n+     insn.  */\n+  int used_insn_alternative;\n+  /* SP offset before the insn relative to one at the func start.  */\n+  HOST_WIDE_INT sp_offset;\n   /* The insn itself.  */\n   rtx insn;\n   /* Common data for insns with the same ICODE.  Asm insns (their\n@@ -222,10 +228,6 @@ struct lra_insn_recog_data\n   int *arg_hard_regs;\n   /* Alternative enabled for the insn.\tNULL for debug insns.  */\n   bool *alternative_enabled_p;\n-  /* The alternative should be used for the insn, -1 if invalid, or we\n-     should try to use any alternative, or the insn is a debug\n-     insn.  */\n-  int used_insn_alternative;\n   /* The following member value is always NULL for a debug insn.  */\n   struct lra_insn_reg *regs;\n };\n@@ -377,8 +379,8 @@ extern void lra_final_code_change (void);\n \n extern void lra_debug_elim_table (void);\n extern int lra_get_elimination_hard_regno (int);\n-extern rtx lra_eliminate_regs_1 (rtx, enum machine_mode, bool, bool, bool);\n-extern void lra_eliminate (bool);\n+extern rtx lra_eliminate_regs_1 (rtx, rtx, enum machine_mode, bool, bool, bool);\n+extern void lra_eliminate (bool, bool);\n \n extern void lra_eliminate_reg_if_possible (rtx *);\n "}, {"sha": "6bebb92fd8386a9b055c8533f489a9bd41d6d4b7", "filename": "gcc/lra-spills.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d49e7ef0a184eee6ad0ff996e46a436447ad4fd/gcc%2Flra-spills.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d49e7ef0a184eee6ad0ff996e46a436447ad4fd/gcc%2Flra-spills.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-spills.c?ref=8d49e7ef0a184eee6ad0ff996e46a436447ad4fd", "patch": "@@ -163,7 +163,6 @@ assign_mem_slot (int i)\n       x = assign_stack_local (mode, total_size,\n \t\t\t      min_align > inherent_align\n \t\t\t      || total_size > inherent_size ? -1 : 0);\n-      x = lra_eliminate_regs_1 (x, GET_MODE (x), false, false, true);\n       stack_slot = x;\n       /* Cancel the big-endian correction done in assign_stack_local.\n \t Get the address of the beginning of the slot.\tThis is so we\n@@ -430,8 +429,15 @@ remove_pseudos (rtx *loc, rtx insn)\n \t into scratches back.  */\n       && ! lra_former_scratch_p (i))\n     {\n-      hard_reg = spill_hard_reg[i];\n-      *loc = copy_rtx (hard_reg != NULL_RTX ? hard_reg : pseudo_slots[i].mem);\n+      if ((hard_reg = spill_hard_reg[i]) != NULL_RTX)\n+\t*loc = copy_rtx (hard_reg);\n+      else\n+\t{\n+\t  rtx x = lra_eliminate_regs_1 (insn, pseudo_slots[i].mem,\n+\t\t\t\t\tGET_MODE (pseudo_slots[i].mem),\n+\t\t\t\t\tfalse, false, true);\n+\t  *loc = x != pseudo_slots[i].mem ? x : copy_rtx (x);\n+\t}\n       return;\n     }\n "}, {"sha": "d0d9bcbc7e395c4aee2cbb81f5addef6e0e46924", "filename": "gcc/lra.c", "status": "modified", "additions": 32, "deletions": 6, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d49e7ef0a184eee6ad0ff996e46a436447ad4fd/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d49e7ef0a184eee6ad0ff996e46a436447ad4fd/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=8d49e7ef0a184eee6ad0ff996e46a436447ad4fd", "patch": "@@ -207,7 +207,8 @@ lra_set_regno_unique_value (int regno)\n   lra_reg_info[regno].val = get_new_reg_value ();\n }\n \n-/* Invalidate INSN related info used by LRA.  */\n+/* Invalidate INSN related info used by LRA.  The info should never be\n+   used after that.  */\n void\n lra_invalidate_insn_data (rtx insn)\n {\n@@ -1273,17 +1274,24 @@ lra_update_insn_recog_data (rtx insn)\n   int n;\n   unsigned int uid = INSN_UID (insn);\n   struct lra_static_insn_data *insn_static_data;\n+  HOST_WIDE_INT sp_offset = 0;\n \n   check_and_expand_insn_recog_data (uid);\n   if ((data = lra_insn_recog_data[uid]) != NULL\n       && data->icode != INSN_CODE (insn))\n     {\n+      sp_offset = data->sp_offset;\n       invalidate_insn_data_regno_info (data, insn, get_insn_freq (insn));\n       invalidate_insn_recog_data (uid);\n       data = NULL;\n     }\n   if (data == NULL)\n-    return lra_get_insn_recog_data (insn);\n+    {\n+      data = lra_get_insn_recog_data (insn);\n+      /* Initiate or restore SP offset.  */\n+      data->sp_offset = sp_offset;\n+      return data;\n+    }\n   insn_static_data = data->insn_static_data;\n   data->used_insn_alternative = -1;\n   if (DEBUG_INSN_P (insn))\n@@ -1837,6 +1845,20 @@ push_insns (rtx from, rtx to)\n       lra_push_insn (insn);\n }\n \n+/* Set up sp offset for insn in range [FROM, LAST].  The offset is\n+   taken from the next BB insn after LAST or zero if there in such\n+   insn.  */\n+static void\n+setup_sp_offset (rtx from, rtx last)\n+{\n+  rtx before = next_nonnote_insn_bb (last);\n+  HOST_WIDE_INT offset = (before == NULL_RTX || ! INSN_P (before)\n+\t\t\t  ? 0 : lra_get_insn_recog_data (before)->sp_offset);\n+\n+  for (rtx insn = from; insn != NEXT_INSN (last); insn = NEXT_INSN (insn))\n+    lra_get_insn_recog_data (insn)->sp_offset = offset;\n+}\n+\n /* Emit insns BEFORE before INSN and insns AFTER after INSN.  Put the\n    insns onto the stack.  Print about emitting the insns with\n    TITLE.  */\n@@ -1845,7 +1867,9 @@ lra_process_new_insns (rtx insn, rtx before, rtx after, const char *title)\n {\n   rtx last;\n \n-  if (lra_dump_file != NULL && (before != NULL_RTX || after != NULL_RTX))\n+  if (before == NULL_RTX && after == NULL_RTX)\n+    return;\n+  if (lra_dump_file != NULL)\n     {\n       dump_insn_slim (lra_dump_file, insn);\n       if (before != NULL_RTX)\n@@ -1864,13 +1888,15 @@ lra_process_new_insns (rtx insn, rtx before, rtx after, const char *title)\n     {\n       emit_insn_before (before, insn);\n       push_insns (PREV_INSN (insn), PREV_INSN (before));\n+      setup_sp_offset (before, PREV_INSN (insn));\n     }\n   if (after != NULL_RTX)\n     {\n       for (last = after; NEXT_INSN (last) != NULL_RTX; last = NEXT_INSN (last))\n \t;\n       emit_insn_after (after, insn);\n       push_insns (last, insn);\n+      setup_sp_offset (after, last);\n     }\n }\n \n@@ -2314,7 +2340,7 @@ lra (FILE *f)\n \t     For example, rs6000 can make\n \t     RS6000_PIC_OFFSET_TABLE_REGNUM uneliminable if we started\n \t     to use a constant pool.  */\n-\t  lra_eliminate (false);\n+\t  lra_eliminate (false, false);\n \t  /* Do inheritance only for regular algorithms.  */\n \t  if (! lra_simple_p)\n \t    lra_inheritance ();\n@@ -2368,13 +2394,13 @@ lra (FILE *f)\n       lra_spill ();\n       /* Assignment of stack slots changes elimination offsets for\n \t some eliminations.  So update the offsets here.  */\n-      lra_eliminate (false);\n+      lra_eliminate (false, false);\n       lra_constraint_new_regno_start = max_reg_num ();\n       lra_constraint_new_insn_uid_start = get_max_uid ();\n       lra_constraint_iter_after_spill = 0;\n     }\n   restore_scratches ();\n-  lra_eliminate (true);\n+  lra_eliminate (true, false);\n   lra_final_code_change ();\n   lra_in_progress = 0;\n   if (live_p)"}, {"sha": "31388694586ecd3f57548a4693fdf2f5d9796d01", "filename": "gcc/lra.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d49e7ef0a184eee6ad0ff996e46a436447ad4fd/gcc%2Flra.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d49e7ef0a184eee6ad0ff996e46a436447ad4fd/gcc%2Flra.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.h?ref=8d49e7ef0a184eee6ad0ff996e46a436447ad4fd", "patch": "@@ -33,7 +33,6 @@ lra_get_allocno_class (int regno)\n \n extern rtx lra_create_new_reg (enum machine_mode, rtx, enum reg_class,\n \t\t\t       const char *);\n-extern void lra_init_elimination (void);\n extern rtx lra_eliminate_regs (rtx, enum machine_mode, rtx);\n extern void lra (FILE *);\n extern void lra_init_once (void);"}, {"sha": "da72b91559d8a0d932d5755ac2cec7c1718f2b1b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d49e7ef0a184eee6ad0ff996e46a436447ad4fd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d49e7ef0a184eee6ad0ff996e46a436447ad4fd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8d49e7ef0a184eee6ad0ff996e46a436447ad4fd", "patch": "@@ -1,3 +1,8 @@\n+2013-11-28  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR target/57293\n+\t* gcc.target/i386/pr57293.c: New.\n+\n 2013-11-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* gcc.target/arm/vrinta-ce.c: New testcase."}, {"sha": "fa016d55f258d4b20e73c3de58742e4314600ea1", "filename": "gcc/testsuite/gcc.target/i386/pr57293.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d49e7ef0a184eee6ad0ff996e46a436447ad4fd/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr57293.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d49e7ef0a184eee6ad0ff996e46a436447ad4fd/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr57293.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr57293.c?ref=8d49e7ef0a184eee6ad0ff996e46a436447ad4fd", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile  { target { ia32 } } } */\n+/* { dg-options \"-O2 -fomit-frame-pointer\" } */\n+/* { dg-final { scan-assembler-not \"%ebp\" } } */\n+\n+__attribute__((__noinline__, __noclone__, __stdcall__)) void g(int a)\n+{\n+  __builtin_printf(\"in g(): %d\\n\", a);\n+}\n+\n+__attribute__((__noinline__, __noclone__, __thiscall__)) void h(int a, int b)\n+{\n+  __builtin_printf(\"in h(): %d %d\\n\", a, b);\n+}\n+\n+void f()\n+{\n+  g(0);\n+  h(0, 1);\n+  __builtin_puts(\"in f()\");\n+}"}]}