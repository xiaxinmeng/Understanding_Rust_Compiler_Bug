{"sha": "18f0873d1e595dc2e5db738550e6e2b0e2953d84", "node_id": "C_kwDOANBUbNoAKDE4ZjA4NzNkMWU1OTVkYzJlNWRiNzM4NTUwZTZlMmIwZTI5NTNkODQ", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2021-11-02T21:08:56Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2021-11-02T21:08:56Z"}, "message": "ipa-modref cleanup\n\nA small refactoring of ipa-modref to make it bit more\nC++y by moving logic analyzing ssa name flags to a class\nand I also moved the anonymous namespace markers so we do not\nexport unnecessary stuff.  There are no functional changes.\n\nBootstrapped/regtested x86_64-linux, will commit it shortly.\n\ngcc/ChangeLog:\n\n\t* ipa-modref.c: Fix anonymous namespace placement.\n\t(class modref_eaf_analysis): New class.\n\t(analyze_ssa_name_flags): Turn to ...\n\t(modref_eaf_analysis::analyze_ssa_name): ... this one.\n\t(merge_call_lhs_flags): Turn to ...\n\t(modref_eaf_analysis::merge_call_lhs_flags): .. this one\n\t(modref_eaf_analysis::merge_with_ssa_name): New member function.\n\t(record_escape_points): Turn to ...\n\t(modref_eaf_analysis::record_escape_points): ... this one.\n\t(analyze_parms): Updat\n\t(ipa_merge_modref_summary_after_inlining): Move to the end of file.", "tree": {"sha": "c12b7cd19aae656bcb239de7b31fe4ad6d7469ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c12b7cd19aae656bcb239de7b31fe4ad6d7469ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18f0873d1e595dc2e5db738550e6e2b0e2953d84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18f0873d1e595dc2e5db738550e6e2b0e2953d84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18f0873d1e595dc2e5db738550e6e2b0e2953d84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18f0873d1e595dc2e5db738550e6e2b0e2953d84/comments", "author": null, "committer": null, "parents": [{"sha": "a70c05120ae6f15f204a04a7df7d19941ab33ef1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a70c05120ae6f15f204a04a7df7d19941ab33ef1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a70c05120ae6f15f204a04a7df7d19941ab33ef1"}], "stats": {"total": 607, "additions": 333, "deletions": 274}, "files": [{"sha": "c9f3dcbe4c972b12a397d0f2f792b32e58ca8f4a", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 333, "deletions": 274, "changes": 607, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18f0873d1e595dc2e5db738550e6e2b0e2953d84/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18f0873d1e595dc2e5db738550e6e2b0e2953d84/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=18f0873d1e595dc2e5db738550e6e2b0e2953d84", "patch": "@@ -693,6 +693,8 @@ get_modref_function_summary (cgraph_node *func)\n   return r;\n }\n \n+namespace {\n+\n /* Construct modref_access_node from REF.  */\n static modref_access_node\n get_access (ao_ref *ref)\n@@ -1427,7 +1429,6 @@ deref_flags (int flags, bool ignore_stores)\n   return ret;\n }\n \n-namespace {\n \n /* Description of an escape point.  */\n \n@@ -1645,22 +1646,62 @@ modref_lattice::merge_direct_store ()\n   return merge (~(EAF_UNUSED | EAF_NOCLOBBER));\n }\n \n-}  /* ANON namespace.  */\n+/* Analyzer of EAF flags.  */\n+\n+class modref_eaf_analysis\n+{\n+public:\n+  /* Compute flags for NAME.  */\n+  void analyze_ssa_name (tree name);\n+  /* Return flags computed earlier for NAME.  */\n+  int get_ssa_name_flags (tree name)\n+  {\n+    int version = SSA_NAME_VERSION (name);\n+    gcc_checking_assert (m_lattice[version].known);\n+    return m_lattice[version].flags;\n+  }\n+  /* In IPA mode this will record all escape points\n+     determined for NAME to PARM_IDNEX.  Flags are minimal\n+     flags known.  */\n+  void record_escape_points (tree name, int parm_index, int flags);\n+  modref_eaf_analysis (bool ipa)\n+  {\n+    m_ipa = ipa;\n+    m_depth = 0;\n+    m_lattice.safe_grow_cleared (num_ssa_names, true);\n+  }\n+  ~modref_eaf_analysis ()\n+  {\n+    gcc_checking_assert (!m_depth);\n+    if (m_ipa)\n+      for (unsigned int i = 0; i < num_ssa_names; i++)\n+\tm_lattice[i].release ();\n+  }\n+private:\n+  /* If true, we produce analysis for IPA mode.  In this case escape points ar\n+     collected.  */\n+  bool m_ipa;\n+  /* Depth of recursion of analyze_ssa_name.  */\n+  int m_depth;\n+  /* Propagation lattice for individual ssa names.  */\n+  auto_vec<modref_lattice> m_lattice;\n+\n+  void merge_with_ssa_name (tree dest, tree src, bool deref);\n+  void merge_call_lhs_flags (gcall *call, int arg, tree name, bool deref);\n+};\n \n-static void analyze_ssa_name_flags (tree name,\n-\t\t\t\t    vec<modref_lattice> &lattice,\n-\t\t\t\t    int depth, bool ipa);\n \n /* Call statements may return their parameters.  Consider argument number\n    ARG of USE_STMT and determine flags that can needs to be cleared\n    in case pointer possibly indirectly references from ARG I is returned.\n-   LATTICE, DEPTH and ipa are same as in analyze_ssa_name_flags.  */\n+   LATTICE, DEPTH and ipa are same as in analyze_ssa_name.  */\n \n-static void\n-merge_call_lhs_flags (gcall *call, int arg, int index, bool deref,\n-\t\t      vec<modref_lattice> &lattice,\n-\t\t      int depth, bool ipa)\n+void\n+modref_eaf_analysis::merge_call_lhs_flags (gcall *call, int arg,\n+\t\t\t\t\t   tree name, bool deref)\n {\n+  int index = SSA_NAME_VERSION (name);\n+\n   /* If there is no return value, no flags are affected.  */\n   if (!gimple_call_lhs (call))\n     return;\n@@ -1681,17 +1722,14 @@ merge_call_lhs_flags (gcall *call, int arg, int index, bool deref,\n   if (TREE_CODE (gimple_call_lhs (call)) == SSA_NAME)\n     {\n       tree lhs = gimple_call_lhs (call);\n-      analyze_ssa_name_flags (lhs, lattice, depth + 1, ipa);\n-      if (deref || (eaf_flags & EAF_NOT_RETURNED_DIRECTLY))\n-\tlattice[index].merge_deref (lattice[SSA_NAME_VERSION (lhs)], false);\n-      else\n-\tlattice[index].merge (lattice[SSA_NAME_VERSION (lhs)]);\n+      merge_with_ssa_name (name, lhs,\n+\t\t\t   (deref || (eaf_flags & EAF_NOT_RETURNED_DIRECTLY)));\n     }\n   /* In the case of memory store we can do nothing.  */\n   else if (eaf_flags & EAF_NOT_RETURNED_DIRECTLY)\n-    lattice[index].merge (deref_flags (0, false));\n+    m_lattice[index].merge (deref_flags (0, false));\n   else\n-    lattice[index].merge (0);\n+    m_lattice[index].merge (0);\n }\n \n /* Analyze EAF flags for SSA name NAME and store result to LATTICE.\n@@ -1700,56 +1738,57 @@ merge_call_lhs_flags (gcall *call, int arg, int index, bool deref,\n    If IPA is true we analyze for IPA propagation (and thus call escape points\n    are processed later)  */\n \n-static void\n-analyze_ssa_name_flags (tree name, vec<modref_lattice> &lattice, int depth,\n-\t\t\tbool ipa)\n+void\n+modref_eaf_analysis::analyze_ssa_name (tree name)\n {\n   imm_use_iterator ui;\n   gimple *use_stmt;\n   int index = SSA_NAME_VERSION (name);\n \n   /* See if value is already computed.  */\n-  if (lattice[index].known)\n+  if (m_lattice[index].known)\n    return;\n-  if (lattice[index].open)\n+  if (m_lattice[index].open)\n     {\n       if (dump_file)\n \tfprintf (dump_file,\n-\t\t \"%*sGiving up on a cycle in SSA graph\\n\", depth * 4, \"\");\n+\t\t \"%*sGiving up on a cycle in SSA graph\\n\",\n+\t\t m_depth * 4, \"\");\n       return;\n     }\n-  if (depth == param_modref_max_depth)\n+  if (m_depth == param_modref_max_depth)\n     {\n       if (dump_file)\n \tfprintf (dump_file,\n-\t\t \"%*sGiving up on max depth\\n\", depth * 4, \"\");\n+\t\t \"%*sGiving up on max depth\\n\",\n+\t\t m_depth * 4, \"\");\n       return;\n     }\n   /* Recursion guard.  */\n-  lattice[index].init ();\n+  m_lattice[index].init ();\n \n   if (dump_file)\n     {\n       fprintf (dump_file,\n-\t       \"%*sAnalyzing flags of ssa name: \", depth * 4, \"\");\n+\t       \"%*sAnalyzing flags of ssa name: \", m_depth * 4, \"\");\n       print_generic_expr (dump_file, name);\n       fprintf (dump_file, \"\\n\");\n     }\n \n   FOR_EACH_IMM_USE_STMT (use_stmt, ui, name)\n     {\n-      if (lattice[index].flags == 0)\n+      if (m_lattice[index].flags == 0)\n \tbreak;\n       if (is_gimple_debug (use_stmt))\n \tcontinue;\n       if (dump_file)\n \t{\n-\t  fprintf (dump_file, \"%*s  Analyzing stmt: \", depth * 4, \"\");\n+\t  fprintf (dump_file, \"%*s  Analyzing stmt: \", m_depth * 4, \"\");\n \t  print_gimple_stmt (dump_file, use_stmt, 0);\n \t}\n       /* If we see a direct non-debug use, clear unused bit.\n \t All dereferneces should be accounted below using deref_flags.  */\n-      lattice[index].merge (~EAF_UNUSED);\n+      m_lattice[index].merge (~EAF_UNUSED);\n \n       /* Gimple return may load the return value.\n \t Returning name counts as an use by tree-ssa-structalias.c  */\n@@ -1760,13 +1799,13 @@ analyze_ssa_name_flags (tree name, vec<modref_lattice> &lattice, int depth,\n \t      && DECL_BY_REFERENCE (DECL_RESULT (current_function_decl)))\n \t    ;\n \t  else if (gimple_return_retval (ret) == name)\n-\t    lattice[index].merge (~(EAF_UNUSED | EAF_NOT_RETURNED\n-\t\t\t\t    | EAF_NOT_RETURNED_DIRECTLY));\n+\t    m_lattice[index].merge (~(EAF_UNUSED | EAF_NOT_RETURNED\n+\t\t\t\t      | EAF_NOT_RETURNED_DIRECTLY));\n \t  else if (memory_access_to (gimple_return_retval (ret), name))\n \t    {\n-\t      lattice[index].merge_direct_load ();\n-\t      lattice[index].merge (~(EAF_UNUSED | EAF_NOT_RETURNED\n-\t\t\t\t      | EAF_NOT_RETURNED_DIRECTLY));\n+\t      m_lattice[index].merge_direct_load ();\n+\t      m_lattice[index].merge (~(EAF_UNUSED | EAF_NOT_RETURNED\n+\t\t\t\t\t| EAF_NOT_RETURNED_DIRECTLY));\n \t    }\n \t}\n       /* Account for LHS store, arg loads and flags from callee function.  */\n@@ -1780,43 +1819,45 @@ analyze_ssa_name_flags (tree name, vec<modref_lattice> &lattice, int depth,\n \t     is on since that would allow propagation of this from -fno-ipa-pta\n \t     to -fipa-pta functions.  */\n \t  if (gimple_call_fn (use_stmt) == name)\n-\t    lattice[index].merge (~(EAF_NOCLOBBER | EAF_UNUSED));\n+\t    m_lattice[index].merge (~(EAF_NOCLOBBER | EAF_UNUSED));\n \n \t  /* Recursion would require bit of propagation; give up for now.  */\n-\t  if (callee && !ipa && recursive_call_p (current_function_decl,\n+\t  if (callee && !m_ipa && recursive_call_p (current_function_decl,\n \t\t\t\t\t\t  callee))\n-\t    lattice[index].merge (0);\n+\t    m_lattice[index].merge (0);\n \t  else\n \t    {\n \t      int ecf_flags = gimple_call_flags (call);\n \t      bool ignore_stores = ignore_stores_p (current_function_decl,\n \t\t\t\t\t\t    ecf_flags);\n \t      bool ignore_retval = ignore_retval_p (current_function_decl,\n \t\t\t\t\t\t    ecf_flags);\n+\t      bool deref_retval = false;\n \n \t      /* Handle *name = func (...).  */\n \t      if (gimple_call_lhs (call)\n \t\t  && memory_access_to (gimple_call_lhs (call), name))\n \t\t{\n-\t\t  lattice[index].merge_direct_store ();\n+\t\t  m_lattice[index].merge_direct_store ();\n \t\t  /* Return slot optimization passes address of\n \t\t     LHS to callee via hidden parameter and this\n \t\t     may make LHS to escape.  See PR 98499.  */\n \t\t  if (gimple_call_return_slot_opt_p (call)\n \t\t      && TREE_ADDRESSABLE (TREE_TYPE (gimple_call_lhs (call))))\n-\t\t    lattice[index].merge (gimple_call_retslot_flags (call));\n+\t\t    m_lattice[index].merge (gimple_call_retslot_flags (call));\n \t\t}\n \n \t      if (gimple_call_chain (call)\n \t\t  && (gimple_call_chain (call) == name))\n-\t\tlattice[index].merge (gimple_call_static_chain_flags (call));\n+\t\tm_lattice[index].merge (gimple_call_static_chain_flags (call));\n \n \t      /* Process internal functions and right away.  */\n-\t      bool record_ipa = ipa && !gimple_call_internal_p (call);\n+\t      bool record_ipa = m_ipa && !gimple_call_internal_p (call);\n \n \t      /* Handle all function parameters.  */\n \t      for (unsigned i = 0;\n-\t\t   i < gimple_call_num_args (call) && lattice[index].flags; i++)\n+\t\t   i < gimple_call_num_args (call)\n+\t\t   && m_lattice[index].flags; i++)\n \t\t/* Name is directly passed to the callee.  */\n \t\tif (gimple_call_arg (call, i) == name)\n \t\t  {\n@@ -1829,35 +1870,33 @@ analyze_ssa_name_flags (tree name, vec<modref_lattice> &lattice, int depth,\n \t\t\t  call_flags |= ignore_stores_eaf_flags;\n \n \t\t\tif (!record_ipa)\n-\t\t\t  lattice[index].merge (call_flags);\n+\t\t\t  m_lattice[index].merge (call_flags);\n \t\t\telse\n-\t\t\t  lattice[index].add_escape_point (call, i,\n+\t\t\t  m_lattice[index].add_escape_point (call, i,\n \t\t\t\t\t\t\t   call_flags, true);\n \t\t      }\n \t\t    if (!ignore_retval)\n-\t\t      merge_call_lhs_flags (call, i, index, false,\n-\t\t\t\t\t    lattice, depth, ipa);\n+\t\t      merge_call_lhs_flags (call, i, name, false);\n \t\t  }\n \t\t/* Name is dereferenced and passed to a callee.  */\n \t\telse if (memory_access_to (gimple_call_arg (call, i), name))\n \t\t  {\n \t\t    if (ecf_flags & (ECF_CONST | ECF_NOVOPS))\n-\t\t      lattice[index].merge_direct_load ();\n+\t\t      m_lattice[index].merge_direct_load ();\n \t\t    else\n \t\t      {\n \t\t\tint call_flags = deref_flags\n \t\t\t   (gimple_call_arg_flags (call, i)\n \t\t\t    | EAF_NOT_RETURNED\n \t\t\t    | EAF_NOT_RETURNED_DIRECTLY, ignore_stores);\n \t\t\tif (!record_ipa)\n-\t\t\t  lattice[index].merge (call_flags);\n+\t\t\t  m_lattice[index].merge (call_flags);\n \t\t\telse\n-\t\t\t  lattice[index].add_escape_point (call, i,\n+\t\t\t  m_lattice[index].add_escape_point (call, i,\n \t\t\t\t\t\t\t   call_flags, false);\n \t\t      }\n \t\t    if (!ignore_retval)\n-\t\t      merge_call_lhs_flags (call, i, index, true,\n-\t\t\t\t\t    lattice, depth, ipa);\n+\t\t      merge_call_lhs_flags (call, i, name, true);\n \t\t  }\n \t    }\n \t}\n@@ -1872,18 +1911,16 @@ analyze_ssa_name_flags (tree name, vec<modref_lattice> &lattice, int depth,\n \t\t We do not track memory locations, so assume that value\n \t\t is used arbitrarily.  */\n \t      if (memory_access_to (gimple_assign_rhs1 (assign), name))\n-\t\tlattice[index].merge (deref_flags (0, false));\n+\t\tm_lattice[index].merge (deref_flags (0, false));\n \t      /* Handle *name = *exp.  */\n \t      else if (memory_access_to (gimple_assign_lhs (assign), name))\n-\t\tlattice[index].merge_direct_store ();\n+\t\tm_lattice[index].merge_direct_store ();\n \t    }\n \t  /* Handle lhs = *name.  */\n \t  else if (memory_access_to (gimple_assign_rhs1 (assign), name))\n \t    {\n \t      tree lhs = gimple_assign_lhs (assign);\n-\t      analyze_ssa_name_flags (lhs, lattice, depth + 1, ipa);\n-\t      lattice[index].merge_deref (lattice[SSA_NAME_VERSION (lhs)],\n-\t\t\t\t\t  false);\n+\t      merge_with_ssa_name (name, lhs, true);\n \t    }\n \t}\n       else if (gimple_store_p (use_stmt))\n@@ -1895,8 +1932,8 @@ analyze_ssa_name_flags (tree name, vec<modref_lattice> &lattice, int depth,\n \t    {\n \t      if (dump_file)\n \t\tfprintf (dump_file, \"%*s  ssa name saved to memory\\n\",\n-\t\t\t depth * 4, \"\");\n-\t      lattice[index].merge (0);\n+\t\t\t m_depth * 4, \"\");\n+\t      m_lattice[index].merge (0);\n \t    }\n \t  /* Handle *name = exp.  */\n \t  else if (assign\n@@ -1905,17 +1942,17 @@ analyze_ssa_name_flags (tree name, vec<modref_lattice> &lattice, int depth,\n \t      /* In general we can not ignore clobbers because they are\n \t\t barriers for code motion, however after inlining it is safe to\n \t\t do because local optimization passes do not consider clobbers\n-\t\t from other functions.  Similar logic is in ipa-pure-const.c.  */\n+\t\t from other functions.\n+\t\t Similar logic is in ipa-pure-const.c.  */\n \t      if (!cfun->after_inlining || !gimple_clobber_p (assign))\n-\t\tlattice[index].merge_direct_store ();\n+\t\tm_lattice[index].merge_direct_store ();\n \t    }\n \t  /* ASM statements etc.  */\n \t  else if (!assign)\n \t    {\n \t      if (dump_file)\n-\t\tfprintf (dump_file, \"%*s  Unhandled store\\n\",\n-\t\t\t depth * 4, \"\");\n-\t      lattice[index].merge (0);\n+\t\tfprintf (dump_file, \"%*s  Unhandled store\\n\", m_depth * 4, \"\");\n+\t      m_lattice[index].merge (0);\n \t    }\n \t}\n       else if (gassign *assign = dyn_cast <gassign *> (use_stmt))\n@@ -1930,15 +1967,13 @@ analyze_ssa_name_flags (tree name, vec<modref_lattice> &lattice, int depth,\n \t\t  || gimple_assign_rhs1 (assign) == name))\n \t    {\n \t      tree lhs = gimple_assign_lhs (assign);\n-\t      analyze_ssa_name_flags (lhs, lattice, depth + 1, ipa);\n-\t      lattice[index].merge (lattice[SSA_NAME_VERSION (lhs)]);\n+\t      merge_with_ssa_name (name, lhs, false);\n \t    }\n \t}\n       else if (gphi *phi = dyn_cast <gphi *> (use_stmt))\n \t{\n \t  tree result = gimple_phi_result (phi);\n-\t  analyze_ssa_name_flags (result, lattice, depth + 1, ipa);\n-\t  lattice[index].merge (lattice[SSA_NAME_VERSION (result)]);\n+\t  merge_with_ssa_name (name, result, false);\n \t}\n       /* Conditions are not considered escape points\n \t by tree-ssa-structalias.  */\n@@ -1947,38 +1982,59 @@ analyze_ssa_name_flags (tree name, vec<modref_lattice> &lattice, int depth,\n       else\n \t{\n \t  if (dump_file)\n-\t    fprintf (dump_file, \"%*s  Unhandled stmt\\n\", depth * 4, \"\");\n-\t  lattice[index].merge (0);\n+\t    fprintf (dump_file, \"%*s  Unhandled stmt\\n\", m_depth * 4, \"\");\n+\t  m_lattice[index].merge (0);\n \t}\n \n       if (dump_file)\n \t{\n-\t  fprintf (dump_file, \"%*s  current flags of \", depth * 4, \"\");\n+\t  fprintf (dump_file, \"%*s  current flags of \", m_depth * 4, \"\");\n \t  print_generic_expr (dump_file, name);\n-\t  lattice[index].dump (dump_file, depth * 4 + 4);\n+\t  m_lattice[index].dump (dump_file, m_depth * 4 + 4);\n \t}\n     }\n   if (dump_file)\n     {\n-      fprintf (dump_file, \"%*sflags of ssa name \", depth * 4, \"\");\n+      fprintf (dump_file, \"%*sflags of ssa name \", m_depth * 4, \"\");\n       print_generic_expr (dump_file, name);\n-      lattice[index].dump (dump_file, depth * 4 + 2);\n+      m_lattice[index].dump (dump_file, m_depth * 4 + 2);\n     }\n-  lattice[index].open = false;\n-  lattice[index].known = true;\n+  m_lattice[index].open = false;\n+  m_lattice[index].known = true;\n+}\n+\n+/* Propagate info from SRC to DEST.  If DEREF it true, assume that SRC\n+   is dereferenced.  */\n+\n+void\n+modref_eaf_analysis::merge_with_ssa_name (tree dest, tree src, bool deref)\n+{\n+  int index = SSA_NAME_VERSION (dest);\n+  int src_index = SSA_NAME_VERSION (src);\n+\n+  m_depth++;\n+  analyze_ssa_name (src);\n+  m_depth--;\n+  if (deref)\n+    m_lattice[index].merge_deref (m_lattice[src_index], false);\n+  else\n+    m_lattice[index].merge (m_lattice[src_index]);\n }\n \n /* Record escape points of PARM_INDEX according to LATTICE.  */\n \n-static void\n-record_escape_points (modref_lattice &lattice, int parm_index, int flags)\n+void\n+modref_eaf_analysis::record_escape_points (tree name, int parm_index, int flags)\n {\n+  modref_lattice &lattice = m_lattice[SSA_NAME_VERSION (name)];\n+\n   if (lattice.escape_points.length ())\n     {\n       escape_point *ep;\n       unsigned int ip;\n       cgraph_node *node = cgraph_node::get (current_function_decl);\n \n+      gcc_assert (m_ipa);\n       FOR_EACH_VEC_ELT (lattice.escape_points, ip, ep)\n \tif ((ep->min_flags & flags) != flags)\n \t  {\n@@ -2021,8 +2077,7 @@ analyze_parms (modref_summary *summary, modref_summary_lto *summary_lto,\n   if (!count && !retslot && !static_chain)\n     return;\n \n-  auto_vec<modref_lattice> lattice;\n-  lattice.safe_grow_cleared (num_ssa_names, true);\n+  modref_eaf_analysis eaf_analysis (ipa);\n \n   for (tree parm = DECL_ARGUMENTS (current_function_decl); parm; parm_index++,\n        parm = TREE_CHAIN (parm))\n@@ -2048,8 +2103,8 @@ analyze_parms (modref_summary *summary, modref_summary_lto *summary_lto,\n \t    }\n \t  continue;\n \t}\n-      analyze_ssa_name_flags (name, lattice, 0, ipa);\n-      int flags = lattice[SSA_NAME_VERSION (name)].flags;\n+      eaf_analysis.analyze_ssa_name (name);\n+      int flags = eaf_analysis.get_ssa_name_flags (name);\n \n       /* Eliminate useless flags so we do not end up storing unnecessary\n \t summaries.  */\n@@ -2072,14 +2127,13 @@ analyze_parms (modref_summary *summary, modref_summary_lto *summary_lto,\n \t\tsummary_lto->arg_flags.safe_grow_cleared (count, true);\n \t      summary_lto->arg_flags[parm_index] = flags;\n \t    }\n-\t  record_escape_points (lattice[SSA_NAME_VERSION (name)],\n-\t\t\t\tparm_index, flags);\n+\t  eaf_analysis.record_escape_points (name, parm_index, flags);\n \t}\n     }\n   if (retslot)\n     {\n-      analyze_ssa_name_flags (retslot, lattice, 0, ipa);\n-      int flags = lattice[SSA_NAME_VERSION (retslot)].flags;\n+      eaf_analysis.analyze_ssa_name (retslot);\n+      int flags = eaf_analysis.get_ssa_name_flags (retslot);\n \n       flags = remove_useless_eaf_flags (flags, ecf_flags, false);\n       if (flags)\n@@ -2088,14 +2142,14 @@ analyze_parms (modref_summary *summary, modref_summary_lto *summary_lto,\n \t    summary->retslot_flags = flags;\n \t  if (summary_lto)\n \t    summary_lto->retslot_flags = flags;\n-\t  record_escape_points (lattice[SSA_NAME_VERSION (retslot)],\n-\t\t\t\tescape_point::retslot_arg, flags);\n+\t  eaf_analysis.record_escape_points (retslot,\n+\t\t\t\t\t     escape_point::retslot_arg, flags);\n \t}\n     }\n   if (static_chain)\n     {\n-      analyze_ssa_name_flags (static_chain, lattice, 0, ipa);\n-      int flags = lattice[SSA_NAME_VERSION (static_chain)].flags;\n+      eaf_analysis.analyze_ssa_name (static_chain);\n+      int flags = eaf_analysis.get_ssa_name_flags (static_chain);\n \n       flags = remove_useless_eaf_flags (flags, ecf_flags, false);\n       if (flags)\n@@ -2104,13 +2158,11 @@ analyze_parms (modref_summary *summary, modref_summary_lto *summary_lto,\n \t    summary->static_chain_flags = flags;\n \t  if (summary_lto)\n \t    summary_lto->static_chain_flags = flags;\n-\t  record_escape_points (lattice[SSA_NAME_VERSION (static_chain)],\n-\t\t\t\tescape_point::static_chain_arg, flags);\n+\t  eaf_analysis.record_escape_points (static_chain,\n+\t\t\t\t\t     escape_point::static_chain_arg,\n+\t\t\t\t\t     flags);\n \t}\n     }\n-  if (ipa)\n-    for (unsigned int i = 0; i < num_ssa_names; i++)\n-      lattice[i].release ();\n }\n \n /* Analyze function F.  IPA indicates whether we're running in local mode\n@@ -2322,6 +2374,8 @@ modref_generate (void)\n     }\n }\n \n+}  /* ANON namespace.  */\n+\n /* Called when a new function is inserted to callgraph late.  */\n \n void\n@@ -2509,7 +2563,7 @@ write_modref_records (modref_records_lto *tt, struct output_block *ob)\n    Either nolto_ret or lto_ret is initialized by the tree depending whether\n    LTO streaming is expected or not.  */\n \n-void\n+static void\n read_modref_records (lto_input_block *ib, struct data_in *data_in,\n \t\t     modref_records **nolto_ret,\n \t\t     modref_records_lto **lto_ret)\n@@ -3100,6 +3154,8 @@ make_pass_ipa_modref (gcc::context *ctxt)\n   return new pass_ipa_modref (ctxt);\n }\n \n+namespace {\n+\n /* Skip edges from and to nodes without ipa_pure_const enabled.\n    Ignore not available symbols.  */\n \n@@ -3279,184 +3335,6 @@ update_escape_summary (cgraph_node *node,\n     }\n }\n \n-/* Call EDGE was inlined; merge summary from callee to the caller.  */\n-\n-void\n-ipa_merge_modref_summary_after_inlining (cgraph_edge *edge)\n-{\n-  if (!summaries && !summaries_lto)\n-    return;\n-\n-  struct cgraph_node *to = (edge->caller->inlined_to\n-\t\t\t    ? edge->caller->inlined_to : edge->caller);\n-  class modref_summary *to_info = summaries ? summaries->get (to) : NULL;\n-  class modref_summary_lto *to_info_lto = summaries_lto\n-\t\t\t\t\t  ? summaries_lto->get (to) : NULL;\n-\n-  if (!to_info && !to_info_lto)\n-    {\n-      if (summaries)\n-\tsummaries->remove (edge->callee);\n-      if (summaries_lto)\n-\tsummaries_lto->remove (edge->callee);\n-      remove_modref_edge_summaries (edge->callee);\n-      return;\n-    }\n-\n-  class modref_summary *callee_info = summaries ? summaries->get (edge->callee)\n-\t\t\t\t      : NULL;\n-  class modref_summary_lto *callee_info_lto\n-\t\t = summaries_lto ? summaries_lto->get (edge->callee) : NULL;\n-  int flags = flags_from_decl_or_type (edge->callee->decl);\n-  bool ignore_stores = ignore_stores_p (edge->caller->decl, flags);\n-\n-  if (!callee_info && to_info)\n-    {\n-      if (!(flags & (ECF_CONST | ECF_NOVOPS)))\n-\tto_info->loads->collapse ();\n-      if (!ignore_stores)\n-\tto_info->stores->collapse ();\n-    }\n-  if (!callee_info_lto && to_info_lto)\n-    {\n-      if (!(flags & (ECF_CONST | ECF_NOVOPS)))\n-\tto_info_lto->loads->collapse ();\n-      if (!ignore_stores)\n-\tto_info_lto->stores->collapse ();\n-    }\n-  if (callee_info || callee_info_lto)\n-    {\n-      auto_vec <modref_parm_map, 32> parm_map;\n-\n-      compute_parm_map (edge, &parm_map);\n-\n-      if (!ignore_stores)\n-\t{\n-\t  if (to_info && callee_info)\n-\t    to_info->stores->merge (callee_info->stores, &parm_map, false);\n-\t  if (to_info_lto && callee_info_lto)\n-\t    to_info_lto->stores->merge (callee_info_lto->stores, &parm_map,\n-\t\t\t\t\tfalse);\n-\t}\n-      if (!(flags & (ECF_CONST | ECF_NOVOPS)))\n-\t{\n-\t  if (to_info && callee_info)\n-\t    to_info->loads->merge (callee_info->loads, &parm_map, false);\n-\t  if (to_info_lto && callee_info_lto)\n-\t    to_info_lto->loads->merge (callee_info_lto->loads, &parm_map,\n-\t\t\t\t       false);\n-\t}\n-    }\n-\n-  /* Now merge escape summaries.\n-     For every escape to the callee we need to merge calle flags\n-     and remap calees escapes.  */\n-  class escape_summary *sum = escape_summaries->get (edge);\n-  int max_escape = -1;\n-  escape_entry *ee;\n-  unsigned int i;\n-\n-  if (sum && !(flags & (ECF_CONST | ECF_NOVOPS)))\n-    FOR_EACH_VEC_ELT (sum->esc, i, ee)\n-      if ((int)ee->arg > max_escape)\n-\tmax_escape = ee->arg;\n-\n-  auto_vec <vec <struct escape_map>, 32> emap (max_escape + 1);\n-  emap.safe_grow (max_escape + 1, true);\n-  for (i = 0; (int)i < max_escape + 1; i++)\n-    emap[i] = vNULL;\n-\n-  if (sum && !(flags & (ECF_CONST | ECF_NOVOPS)))\n-    FOR_EACH_VEC_ELT (sum->esc, i, ee)\n-      {\n-\tbool needed = false;\n-\t/* TODO: We do not have jump functions for return slots, so we\n-\t   never propagate them to outer function.  */\n-\tif (ee->parm_index < 0)\n-\t  continue;\n-\tif (to_info && (int)to_info->arg_flags.length () > ee->parm_index)\n-\t  {\n-\t    int flags = callee_info\n-\t\t\t&& callee_info->arg_flags.length () > ee->arg\n-\t\t\t? callee_info->arg_flags[ee->arg] : 0;\n-\t    if (!ee->direct)\n-\t      flags = deref_flags (flags, ignore_stores);\n-\t    else if (ignore_stores)\n-\t      flags |= ignore_stores_eaf_flags;\n-\t    flags |= ee->min_flags;\n-\t    to_info->arg_flags[ee->parm_index] &= flags;\n-\t    if (to_info->arg_flags[ee->parm_index])\n-\t      needed = true;\n-\t  }\n-\tif (to_info_lto && (int)to_info_lto->arg_flags.length () > ee->parm_index)\n-\t  {\n-\t    int flags = callee_info_lto\n-\t\t\t&& callee_info_lto->arg_flags.length () > ee->arg\n-\t\t\t? callee_info_lto->arg_flags[ee->arg] : 0;\n-\t    if (!ee->direct)\n-\t      flags = deref_flags (flags, ignore_stores);\n-\t    else if (ignore_stores)\n-\t      flags |= ignore_stores_eaf_flags;\n-\t    flags |= ee->min_flags;\n-\t    to_info_lto->arg_flags[ee->parm_index] &= flags;\n-\t    if (to_info_lto->arg_flags[ee->parm_index])\n-\t      needed = true;\n-\t  }\n-\tstruct escape_map entry = {ee->parm_index, ee->direct};\n-\tif (needed)\n-\t  emap[ee->arg].safe_push (entry);\n-      }\n-  update_escape_summary (edge->callee, emap, ignore_stores);\n-  for (i = 0; (int)i < max_escape + 1; i++)\n-    emap[i].release ();\n-  if (sum)\n-    escape_summaries->remove (edge);\n-\n-  if (summaries)\n-    {\n-      if (to_info && !to_info->useful_p (flags))\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"Removed mod-ref summary for %s\\n\",\n-\t\t     to->dump_name ());\n-\t  summaries->remove (to);\n-\t  to_info = NULL;\n-\t}\n-      else if (to_info && dump_file)\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"Updated mod-ref summary for %s\\n\",\n-\t\t     to->dump_name ());\n-\t  to_info->dump (dump_file);\n-\t}\n-      if (callee_info)\n-\tsummaries->remove (edge->callee);\n-    }\n-  if (summaries_lto)\n-    {\n-      if (to_info_lto && !to_info_lto->useful_p (flags))\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"Removed mod-ref summary for %s\\n\",\n-\t\t     to->dump_name ());\n-\t  summaries_lto->remove (to);\n-\t}\n-      else if (to_info_lto && dump_file)\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"Updated mod-ref summary for %s\\n\",\n-\t\t     to->dump_name ());\n-\t  to_info_lto->dump (dump_file);\n-\t  to_info_lto = NULL;\n-\t}\n-      if (callee_info_lto)\n-\tsummaries_lto->remove (edge->callee);\n-    }\n-  if (!to_info && !to_info_lto)\n-    remove_modref_edge_summaries (to);\n-  return;\n-}\n-\n /* Get parameter type from DECL.  This is only safe for special cases\n    like builtins we create fnspec for because the type match is checked\n    at fnspec creation time.  */\n@@ -4079,6 +3957,187 @@ modref_propagate_flags_in_scc (cgraph_node *component_node)\n \t     \"Propagation of flags finished in %i iterations\\n\", iteration);\n }\n \n+}  /* ANON namespace.  */\n+\n+/* Call EDGE was inlined; merge summary from callee to the caller.  */\n+\n+void\n+ipa_merge_modref_summary_after_inlining (cgraph_edge *edge)\n+{\n+  if (!summaries && !summaries_lto)\n+    return;\n+\n+  struct cgraph_node *to = (edge->caller->inlined_to\n+\t\t\t    ? edge->caller->inlined_to : edge->caller);\n+  class modref_summary *to_info = summaries ? summaries->get (to) : NULL;\n+  class modref_summary_lto *to_info_lto = summaries_lto\n+\t\t\t\t\t  ? summaries_lto->get (to) : NULL;\n+\n+  if (!to_info && !to_info_lto)\n+    {\n+      if (summaries)\n+\tsummaries->remove (edge->callee);\n+      if (summaries_lto)\n+\tsummaries_lto->remove (edge->callee);\n+      remove_modref_edge_summaries (edge->callee);\n+      return;\n+    }\n+\n+  class modref_summary *callee_info = summaries ? summaries->get (edge->callee)\n+\t\t\t\t      : NULL;\n+  class modref_summary_lto *callee_info_lto\n+\t\t = summaries_lto ? summaries_lto->get (edge->callee) : NULL;\n+  int flags = flags_from_decl_or_type (edge->callee->decl);\n+  bool ignore_stores = ignore_stores_p (edge->caller->decl, flags);\n+\n+  if (!callee_info && to_info)\n+    {\n+      if (!(flags & (ECF_CONST | ECF_NOVOPS)))\n+\tto_info->loads->collapse ();\n+      if (!ignore_stores)\n+\tto_info->stores->collapse ();\n+    }\n+  if (!callee_info_lto && to_info_lto)\n+    {\n+      if (!(flags & (ECF_CONST | ECF_NOVOPS)))\n+\tto_info_lto->loads->collapse ();\n+      if (!ignore_stores)\n+\tto_info_lto->stores->collapse ();\n+    }\n+  if (callee_info || callee_info_lto)\n+    {\n+      auto_vec <modref_parm_map, 32> parm_map;\n+\n+      compute_parm_map (edge, &parm_map);\n+\n+      if (!ignore_stores)\n+\t{\n+\t  if (to_info && callee_info)\n+\t    to_info->stores->merge (callee_info->stores, &parm_map, false);\n+\t  if (to_info_lto && callee_info_lto)\n+\t    to_info_lto->stores->merge (callee_info_lto->stores, &parm_map,\n+\t\t\t\t\tfalse);\n+\t}\n+      if (!(flags & (ECF_CONST | ECF_NOVOPS)))\n+\t{\n+\t  if (to_info && callee_info)\n+\t    to_info->loads->merge (callee_info->loads, &parm_map, false);\n+\t  if (to_info_lto && callee_info_lto)\n+\t    to_info_lto->loads->merge (callee_info_lto->loads, &parm_map,\n+\t\t\t\t       false);\n+\t}\n+    }\n+\n+  /* Now merge escape summaries.\n+     For every escape to the callee we need to merge calle flags\n+     and remap calees escapes.  */\n+  class escape_summary *sum = escape_summaries->get (edge);\n+  int max_escape = -1;\n+  escape_entry *ee;\n+  unsigned int i;\n+\n+  if (sum && !(flags & (ECF_CONST | ECF_NOVOPS)))\n+    FOR_EACH_VEC_ELT (sum->esc, i, ee)\n+      if ((int)ee->arg > max_escape)\n+\tmax_escape = ee->arg;\n+\n+  auto_vec <vec <struct escape_map>, 32> emap (max_escape + 1);\n+  emap.safe_grow (max_escape + 1, true);\n+  for (i = 0; (int)i < max_escape + 1; i++)\n+    emap[i] = vNULL;\n+\n+  if (sum && !(flags & (ECF_CONST | ECF_NOVOPS)))\n+    FOR_EACH_VEC_ELT (sum->esc, i, ee)\n+      {\n+\tbool needed = false;\n+\t/* TODO: We do not have jump functions for return slots, so we\n+\t   never propagate them to outer function.  */\n+\tif (ee->parm_index < 0)\n+\t  continue;\n+\tif (to_info && (int)to_info->arg_flags.length () > ee->parm_index)\n+\t  {\n+\t    int flags = callee_info\n+\t\t\t&& callee_info->arg_flags.length () > ee->arg\n+\t\t\t? callee_info->arg_flags[ee->arg] : 0;\n+\t    if (!ee->direct)\n+\t      flags = deref_flags (flags, ignore_stores);\n+\t    else if (ignore_stores)\n+\t      flags |= ignore_stores_eaf_flags;\n+\t    flags |= ee->min_flags;\n+\t    to_info->arg_flags[ee->parm_index] &= flags;\n+\t    if (to_info->arg_flags[ee->parm_index])\n+\t      needed = true;\n+\t  }\n+\tif (to_info_lto\n+     \t    && (int)to_info_lto->arg_flags.length () > ee->parm_index)\n+\t  {\n+\t    int flags = callee_info_lto\n+\t\t\t&& callee_info_lto->arg_flags.length () > ee->arg\n+\t\t\t? callee_info_lto->arg_flags[ee->arg] : 0;\n+\t    if (!ee->direct)\n+\t      flags = deref_flags (flags, ignore_stores);\n+\t    else if (ignore_stores)\n+\t      flags |= ignore_stores_eaf_flags;\n+\t    flags |= ee->min_flags;\n+\t    to_info_lto->arg_flags[ee->parm_index] &= flags;\n+\t    if (to_info_lto->arg_flags[ee->parm_index])\n+\t      needed = true;\n+\t  }\n+\tstruct escape_map entry = {ee->parm_index, ee->direct};\n+\tif (needed)\n+\t  emap[ee->arg].safe_push (entry);\n+      }\n+  update_escape_summary (edge->callee, emap, ignore_stores);\n+  for (i = 0; (int)i < max_escape + 1; i++)\n+    emap[i].release ();\n+  if (sum)\n+    escape_summaries->remove (edge);\n+\n+  if (summaries)\n+    {\n+      if (to_info && !to_info->useful_p (flags))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Removed mod-ref summary for %s\\n\",\n+\t\t     to->dump_name ());\n+\t  summaries->remove (to);\n+\t  to_info = NULL;\n+\t}\n+      else if (to_info && dump_file)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Updated mod-ref summary for %s\\n\",\n+\t\t     to->dump_name ());\n+\t  to_info->dump (dump_file);\n+\t}\n+      if (callee_info)\n+\tsummaries->remove (edge->callee);\n+    }\n+  if (summaries_lto)\n+    {\n+      if (to_info_lto && !to_info_lto->useful_p (flags))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Removed mod-ref summary for %s\\n\",\n+\t\t     to->dump_name ());\n+\t  summaries_lto->remove (to);\n+\t}\n+      else if (to_info_lto && dump_file)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Updated mod-ref summary for %s\\n\",\n+\t\t     to->dump_name ());\n+\t  to_info_lto->dump (dump_file);\n+\t  to_info_lto = NULL;\n+\t}\n+      if (callee_info_lto)\n+\tsummaries_lto->remove (edge->callee);\n+    }\n+  if (!to_info && !to_info_lto)\n+    remove_modref_edge_summaries (to);\n+  return;\n+}\n+\n /* Run the IPA pass.  This will take a function's summaries and calls and\n    construct new summaries which represent a transitive closure.  So that\n    summary of an analyzed function contains information about the loads and"}]}