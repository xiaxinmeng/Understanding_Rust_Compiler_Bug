{"sha": "61d9c5274e07eb4dd43c4878b93438452e8074b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFkOWM1Mjc0ZTA3ZWI0ZGQ0M2M0ODc4YjkzNDM4NDUyZTgwNzRiMQ==", "commit": {"author": {"name": "Tom de Vries", "email": "tom@codesourcery.com", "date": "2016-01-18T12:52:32Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2016-01-18T12:52:32Z"}, "message": "Add oacc_kernels_p argument to pass_parallelize_loops\n\n2016-01-18  Tom de Vries  <tom@codesourcery.com>\n\n\t* omp-low.c (set_oacc_fn_attrib): Make extern.\n\t* omp-low.h (set_oacc_fn_attrib): Declare.\n\t* tree-parloops.c (struct reduction_info): Add reduc_addr field.\n\t(create_call_for_reduction_1): Handle case that reduc_addr is non-NULL.\n\t(create_parallel_loop, gen_parallel_loop, try_create_reduction_list):\n\tAdd and handle function parameter oacc_kernels_p.\n\t(find_reduc_addr, get_omp_data_i_param): New function.\n\t(ref_conflicts_with_region, oacc_entry_exit_ok_1)\n\t(oacc_entry_exit_single_gang, oacc_entry_exit_ok): New function.\n\t(parallelize_loops): Add and handle function parameter oacc_kernels_p.\n\tCalculate dominance info.  Skip loops that are not in a kernels region\n\tin oacc_kernels_p mode.  Skip inner loops of parallelized loops.\n\t(pass_parallelize_loops::execute): Call parallelize_loops with\n\toacc_kernels_p argument.\n\t(pass_parallelize_loops::clone, pass_parallelize_loops::set_pass_param):\n\tNew member function.\n\t(pass_parallelize_loops::bool oacc_kernels_p): New member var.\n\t* passes.def: Add argument to pass_parallelize_loops instantation.\n\nFrom-SVN: r232512", "tree": {"sha": "139f5264c912aebb738b36613946a5f9c12f9595", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/139f5264c912aebb738b36613946a5f9c12f9595"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61d9c5274e07eb4dd43c4878b93438452e8074b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61d9c5274e07eb4dd43c4878b93438452e8074b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61d9c5274e07eb4dd43c4878b93438452e8074b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61d9c5274e07eb4dd43c4878b93438452e8074b1/comments", "author": null, "committer": null, "parents": [{"sha": "12db0814023fa0f6a772e6e6cf0b256c2ab46b95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12db0814023fa0f6a772e6e6cf0b256c2ab46b95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12db0814023fa0f6a772e6e6cf0b256c2ab46b95"}], "stats": {"total": 770, "additions": 662, "deletions": 108}, "files": [{"sha": "ea8645dccaffcf82043910584f0ce15b3de54796", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d9c5274e07eb4dd43c4878b93438452e8074b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d9c5274e07eb4dd43c4878b93438452e8074b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=61d9c5274e07eb4dd43c4878b93438452e8074b1", "patch": "@@ -1,3 +1,24 @@\n+2016-01-18  Tom de Vries  <tom@codesourcery.com>\n+\n+\t* omp-low.c (set_oacc_fn_attrib): Make extern.\n+\t* omp-low.h (set_oacc_fn_attrib): Declare.\n+\t* tree-parloops.c (struct reduction_info): Add reduc_addr field.\n+\t(create_call_for_reduction_1): Handle case that reduc_addr is non-NULL.\n+\t(create_parallel_loop, gen_parallel_loop, try_create_reduction_list):\n+\tAdd and handle function parameter oacc_kernels_p.\n+\t(find_reduc_addr, get_omp_data_i_param): New function.\n+\t(ref_conflicts_with_region, oacc_entry_exit_ok_1)\n+\t(oacc_entry_exit_single_gang, oacc_entry_exit_ok): New function.\n+\t(parallelize_loops): Add and handle function parameter oacc_kernels_p.\n+\tCalculate dominance info.  Skip loops that are not in a kernels region\n+\tin oacc_kernels_p mode.  Skip inner loops of parallelized loops.\n+\t(pass_parallelize_loops::execute): Call parallelize_loops with\n+\toacc_kernels_p argument.\n+\t(pass_parallelize_loops::clone, pass_parallelize_loops::set_pass_param):\n+\tNew member function.\n+\t(pass_parallelize_loops::bool oacc_kernels_p): New member var.\n+\t* passes.def: Add argument to pass_parallelize_loops instantation.\n+\n 2016-01-18  Tom de Vries  <tom@codesourcery.com>\n \n \t* tree-parloops.c (pass_parallelize_loops::execute): Allow"}, {"sha": "d7df3dbfc63ff695d4089aae616eff414617953c", "filename": "gcc/omp-low.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d9c5274e07eb4dd43c4878b93438452e8074b1/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d9c5274e07eb4dd43c4878b93438452e8074b1/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=61d9c5274e07eb4dd43c4878b93438452e8074b1", "patch": "@@ -12401,7 +12401,7 @@ replace_oacc_fn_attrib (tree fn, tree dims)\n    function attribute.  Push any that are non-constant onto the ARGS\n    list, along with an appropriate GOMP_LAUNCH_DIM tag.  */\n \n-static void\n+void\n set_oacc_fn_attrib (tree fn, tree clauses, vec<tree> *args)\n {\n   /* Must match GOMP_DIM ordering.  */"}, {"sha": "64caef8db69daad65832682a8133119dd4c6f708", "filename": "gcc/omp-low.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d9c5274e07eb4dd43c4878b93438452e8074b1/gcc%2Fomp-low.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d9c5274e07eb4dd43c4878b93438452e8074b1/gcc%2Fomp-low.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.h?ref=61d9c5274e07eb4dd43c4878b93438452e8074b1", "patch": "@@ -33,6 +33,7 @@ extern tree omp_member_access_dummy_var (tree);\n extern void replace_oacc_fn_attrib (tree, tree);\n extern tree build_oacc_routine_dims (tree);\n extern tree get_oacc_fn_attrib (tree);\n+extern void set_oacc_fn_attrib (tree, tree, vec<tree> *);\n extern int get_oacc_ifn_dim_arg (const gimple *);\n extern int get_oacc_fn_dim_size (tree, int);\n "}, {"sha": "d9a8c4e9cf7eac7005b960be4a8d77966c3cf218", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d9c5274e07eb4dd43c4878b93438452e8074b1/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d9c5274e07eb4dd43c4878b93438452e8074b1/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=61d9c5274e07eb4dd43c4878b93438452e8074b1", "patch": "@@ -272,7 +272,7 @@ along with GCC; see the file COPYING3.  If not see\n \t      NEXT_PASS (pass_dce);\n \t  POP_INSERT_PASSES ()\n \t  NEXT_PASS (pass_iv_canon);\n-\t  NEXT_PASS (pass_parallelize_loops);\n+\t  NEXT_PASS (pass_parallelize_loops, false /* oacc_kernels_p */);\n \t  NEXT_PASS (pass_expand_omp_ssa);\n \t  NEXT_PASS (pass_ch_vect);\n \t  NEXT_PASS (pass_if_conversion);"}, {"sha": "7749d34fab32accf248a49d921b3cf417a5521fa", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 638, "deletions": 106, "changes": 744, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61d9c5274e07eb4dd43c4878b93438452e8074b1/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61d9c5274e07eb4dd43c4878b93438452e8074b1/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=61d9c5274e07eb4dd43c4878b93438452e8074b1", "patch": "@@ -53,6 +53,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa.h\"\n #include \"params.h\"\n #include \"params-enum.h\"\n+#include \"tree-ssa-alias.h\"\n+#include \"tree-eh.h\"\n+#include \"gomp-constants.h\"\n+#include \"tree-dfa.h\"\n \n /* This pass tries to distribute iterations of loops into several threads.\n    The implementation is straightforward -- for each loop we test whether its\n@@ -192,6 +196,8 @@ struct reduction_info\n \t\t\t\t   of the reduction variable when existing the loop. */\n   tree initial_value;\t\t/* The initial value of the reduction var before entering the loop.  */\n   tree field;\t\t\t/*  the name of the field in the parloop data structure intended for reduction.  */\n+  tree reduc_addr;\t\t/* The address of the reduction variable for\n+\t\t\t\t   openacc reductions.  */\n   tree init;\t\t\t/* reduction initialization value.  */\n   gphi *new_phi;\t\t/* (helper field) Newly created phi node whose result\n \t\t\t\t   will be passed to the atomic operation.  Represents\n@@ -1085,10 +1091,29 @@ create_call_for_reduction_1 (reduction_info **slot, struct clsn_data *clsn_data)\n   tree tmp_load, name;\n   gimple *load;\n \n-  load_struct = build_simple_mem_ref (clsn_data->load);\n-  t = build3 (COMPONENT_REF, type, load_struct, reduc->field, NULL_TREE);\n+  if (reduc->reduc_addr == NULL_TREE)\n+    {\n+      load_struct = build_simple_mem_ref (clsn_data->load);\n+      t = build3 (COMPONENT_REF, type, load_struct, reduc->field, NULL_TREE);\n \n-  addr = build_addr (t);\n+      addr = build_addr (t);\n+    }\n+  else\n+    {\n+      /* Set the address for the atomic store.  */\n+      addr = reduc->reduc_addr;\n+\n+      /* Remove the non-atomic store '*addr = sum'.  */\n+      tree res = PHI_RESULT (reduc->keep_res);\n+      use_operand_p use_p;\n+      gimple *stmt;\n+      bool single_use_p = single_imm_use (res, &use_p, &stmt);\n+      gcc_assert (single_use_p);\n+      replace_uses_by (gimple_vdef (stmt),\n+\t\t       gimple_vuse (stmt));\n+      gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+      gsi_remove (&gsi, true);\n+    }\n \n   /* Create phi node.  */\n   bb = clsn_data->load_bb;\n@@ -1994,10 +2019,11 @@ transform_to_exit_first_loop (struct loop *loop,\n \n static void\n create_parallel_loop (struct loop *loop, tree loop_fn, tree data,\n-\t\t      tree new_data, unsigned n_threads, location_t loc)\n+\t\t      tree new_data, unsigned n_threads, location_t loc,\n+\t\t      bool oacc_kernels_p)\n {\n   gimple_stmt_iterator gsi;\n-  basic_block bb, paral_bb, for_bb, ex_bb, continue_bb;\n+  basic_block for_bb, ex_bb, continue_bb;\n   tree t, param;\n   gomp_parallel *omp_par_stmt;\n   gimple *omp_return_stmt1, *omp_return_stmt2;\n@@ -2009,40 +2035,50 @@ create_parallel_loop (struct loop *loop, tree loop_fn, tree data,\n   edge exit, nexit, guard, end, e;\n \n   /* Prepare the GIMPLE_OMP_PARALLEL statement.  */\n-  bb = loop_preheader_edge (loop)->src;\n-  paral_bb = single_pred (bb);\n-  gsi = gsi_last_bb (paral_bb);\n+  if (oacc_kernels_p)\n+    {\n+      tree clause = build_omp_clause (loc, OMP_CLAUSE_NUM_GANGS);\n+      OMP_CLAUSE_NUM_GANGS_EXPR (clause)\n+\t= build_int_cst (integer_type_node, n_threads);\n+      set_oacc_fn_attrib (cfun->decl, clause, NULL);\n+    }\n+  else\n+    {\n+      basic_block bb = loop_preheader_edge (loop)->src;\n+      basic_block paral_bb = single_pred (bb);\n+      gsi = gsi_last_bb (paral_bb);\n \n-  t = build_omp_clause (loc, OMP_CLAUSE_NUM_THREADS);\n-  OMP_CLAUSE_NUM_THREADS_EXPR (t)\n-    = build_int_cst (integer_type_node, n_threads);\n-  omp_par_stmt = gimple_build_omp_parallel (NULL, t, loop_fn, data);\n-  gimple_set_location (omp_par_stmt, loc);\n+      t = build_omp_clause (loc, OMP_CLAUSE_NUM_THREADS);\n+      OMP_CLAUSE_NUM_THREADS_EXPR (t)\n+\t= build_int_cst (integer_type_node, n_threads);\n+      omp_par_stmt = gimple_build_omp_parallel (NULL, t, loop_fn, data);\n+      gimple_set_location (omp_par_stmt, loc);\n \n-  gsi_insert_after (&gsi, omp_par_stmt, GSI_NEW_STMT);\n+      gsi_insert_after (&gsi, omp_par_stmt, GSI_NEW_STMT);\n \n-  /* Initialize NEW_DATA.  */\n-  if (data)\n-    {\n-      gassign *assign_stmt;\n+      /* Initialize NEW_DATA.  */\n+      if (data)\n+\t{\n+\t  gassign *assign_stmt;\n \n-      gsi = gsi_after_labels (bb);\n+\t  gsi = gsi_after_labels (bb);\n \n-      param = make_ssa_name (DECL_ARGUMENTS (loop_fn));\n-      assign_stmt = gimple_build_assign (param, build_fold_addr_expr (data));\n-      gsi_insert_before (&gsi, assign_stmt, GSI_SAME_STMT);\n+\t  param = make_ssa_name (DECL_ARGUMENTS (loop_fn));\n+\t  assign_stmt = gimple_build_assign (param, build_fold_addr_expr (data));\n+\t  gsi_insert_before (&gsi, assign_stmt, GSI_SAME_STMT);\n \n-      assign_stmt = gimple_build_assign (new_data,\n-\t\t\t\t  fold_convert (TREE_TYPE (new_data), param));\n-      gsi_insert_before (&gsi, assign_stmt, GSI_SAME_STMT);\n-    }\n+\t  assign_stmt = gimple_build_assign (new_data,\n+\t\t\t\t\t     fold_convert (TREE_TYPE (new_data), param));\n+\t  gsi_insert_before (&gsi, assign_stmt, GSI_SAME_STMT);\n+\t}\n \n-  /* Emit GIMPLE_OMP_RETURN for GIMPLE_OMP_PARALLEL.  */\n-  bb = split_loop_exit_edge (single_dom_exit (loop));\n-  gsi = gsi_last_bb (bb);\n-  omp_return_stmt1 = gimple_build_omp_return (false);\n-  gimple_set_location (omp_return_stmt1, loc);\n-  gsi_insert_after (&gsi, omp_return_stmt1, GSI_NEW_STMT);\n+      /* Emit GIMPLE_OMP_RETURN for GIMPLE_OMP_PARALLEL.  */\n+      bb = split_loop_exit_edge (single_dom_exit (loop));\n+      gsi = gsi_last_bb (bb);\n+      omp_return_stmt1 = gimple_build_omp_return (false);\n+      gimple_set_location (omp_return_stmt1, loc);\n+      gsi_insert_after (&gsi, omp_return_stmt1, GSI_NEW_STMT);\n+    }\n \n   /* Extract data for GIMPLE_OMP_FOR.  */\n   gcc_assert (loop->header == single_dom_exit (loop)->src);\n@@ -2107,39 +2143,50 @@ create_parallel_loop (struct loop *loop, tree loop_fn, tree data,\n   PENDING_STMT (e) = NULL;\n \n   /* Emit GIMPLE_OMP_FOR.  */\n-  gimple_cond_set_lhs (cond_stmt, cvar_base);\n-  type = TREE_TYPE (cvar);\n-  t = build_omp_clause (loc, OMP_CLAUSE_SCHEDULE);\n-  int chunk_size = PARAM_VALUE (PARAM_PARLOOPS_CHUNK_SIZE);\n-  enum PARAM_PARLOOPS_SCHEDULE_KIND schedule_type \\\n-    = (enum PARAM_PARLOOPS_SCHEDULE_KIND) PARAM_VALUE (PARAM_PARLOOPS_SCHEDULE);\n-  switch (schedule_type)\n+  if (oacc_kernels_p)\n+    /* In combination with the NUM_GANGS on the parallel.  */\n+    t = build_omp_clause (loc, OMP_CLAUSE_GANG);\n+  else\n     {\n-    case PARAM_PARLOOPS_SCHEDULE_KIND_static:\n-      OMP_CLAUSE_SCHEDULE_KIND (t) = OMP_CLAUSE_SCHEDULE_STATIC;\n-      break;\n-    case PARAM_PARLOOPS_SCHEDULE_KIND_dynamic:\n-      OMP_CLAUSE_SCHEDULE_KIND (t) = OMP_CLAUSE_SCHEDULE_DYNAMIC;\n-      break;\n-    case PARAM_PARLOOPS_SCHEDULE_KIND_guided:\n-      OMP_CLAUSE_SCHEDULE_KIND (t) = OMP_CLAUSE_SCHEDULE_GUIDED;\n-      break;\n-    case PARAM_PARLOOPS_SCHEDULE_KIND_auto:\n-      OMP_CLAUSE_SCHEDULE_KIND (t) = OMP_CLAUSE_SCHEDULE_AUTO;\n-      chunk_size = 0;\n-      break;\n-    case PARAM_PARLOOPS_SCHEDULE_KIND_runtime:\n-      OMP_CLAUSE_SCHEDULE_KIND (t) = OMP_CLAUSE_SCHEDULE_RUNTIME;\n-      chunk_size = 0;\n-      break;\n-    default:\n-      gcc_unreachable ();\n+      t = build_omp_clause (loc, OMP_CLAUSE_SCHEDULE);\n+      int chunk_size = PARAM_VALUE (PARAM_PARLOOPS_CHUNK_SIZE);\n+      enum PARAM_PARLOOPS_SCHEDULE_KIND schedule_type \\\n+\t= (enum PARAM_PARLOOPS_SCHEDULE_KIND) PARAM_VALUE (PARAM_PARLOOPS_SCHEDULE);\n+      switch (schedule_type)\n+\t{\n+\tcase PARAM_PARLOOPS_SCHEDULE_KIND_static:\n+\t  OMP_CLAUSE_SCHEDULE_KIND (t) = OMP_CLAUSE_SCHEDULE_STATIC;\n+\t  break;\n+\tcase PARAM_PARLOOPS_SCHEDULE_KIND_dynamic:\n+\t  OMP_CLAUSE_SCHEDULE_KIND (t) = OMP_CLAUSE_SCHEDULE_DYNAMIC;\n+\t  break;\n+\tcase PARAM_PARLOOPS_SCHEDULE_KIND_guided:\n+\t  OMP_CLAUSE_SCHEDULE_KIND (t) = OMP_CLAUSE_SCHEDULE_GUIDED;\n+\t  break;\n+\tcase PARAM_PARLOOPS_SCHEDULE_KIND_auto:\n+\t  OMP_CLAUSE_SCHEDULE_KIND (t) = OMP_CLAUSE_SCHEDULE_AUTO;\n+\t  chunk_size = 0;\n+\t  break;\n+\tcase PARAM_PARLOOPS_SCHEDULE_KIND_runtime:\n+\t  OMP_CLAUSE_SCHEDULE_KIND (t) = OMP_CLAUSE_SCHEDULE_RUNTIME;\n+\t  chunk_size = 0;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      if (chunk_size != 0)\n+\tOMP_CLAUSE_SCHEDULE_CHUNK_EXPR (t)\n+\t  = build_int_cst (integer_type_node, chunk_size);\n     }\n-  if (chunk_size != 0)\n-    OMP_CLAUSE_SCHEDULE_CHUNK_EXPR (t)\n-      = build_int_cst (integer_type_node, chunk_size);\n \n-  for_stmt = gimple_build_omp_for (NULL, GF_OMP_FOR_KIND_FOR, t, 1, NULL);\n+  for_stmt = gimple_build_omp_for (NULL,\n+\t\t\t\t   (oacc_kernels_p\n+\t\t\t\t    ? GF_OMP_FOR_KIND_OACC_LOOP\n+\t\t\t\t    : GF_OMP_FOR_KIND_FOR),\n+\t\t\t\t   t, 1, NULL);\n+\n+  gimple_cond_set_lhs (cond_stmt, cvar_base);\n+  type = TREE_TYPE (cvar);\n   gimple_set_location (for_stmt, loc);\n   gimple_omp_for_set_index (for_stmt, 0, initvar);\n   gimple_omp_for_set_initial (for_stmt, 0, cvar_init);\n@@ -2181,7 +2228,8 @@ create_parallel_loop (struct loop *loop, tree loop_fn, tree data,\n static void\n gen_parallel_loop (struct loop *loop,\n \t\t   reduction_info_table_type *reduction_list,\n-\t\t   unsigned n_threads, struct tree_niter_desc *niter)\n+\t\t   unsigned n_threads, struct tree_niter_desc *niter,\n+\t\t   bool oacc_kernels_p)\n {\n   tree many_iterations_cond, type, nit;\n   tree arg_struct, new_arg_struct;\n@@ -2262,40 +2310,44 @@ gen_parallel_loop (struct loop *loop,\n   if (stmts)\n     gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);\n \n-  if (loop->inner)\n-    m_p_thread=2;\n-  else\n-    m_p_thread=MIN_PER_THREAD;\n-\n-   many_iterations_cond =\n-     fold_build2 (GE_EXPR, boolean_type_node,\n-                nit, build_int_cst (type, m_p_thread * n_threads));\n-\n-  many_iterations_cond\n-    = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t   invert_truthvalue (unshare_expr (niter->may_be_zero)),\n-\t\t   many_iterations_cond);\n-  many_iterations_cond\n-    = force_gimple_operand (many_iterations_cond, &stmts, false, NULL_TREE);\n-  if (stmts)\n-    gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);\n-  if (!is_gimple_condexpr (many_iterations_cond))\n+  if (!oacc_kernels_p)\n     {\n+      if (loop->inner)\n+\tm_p_thread=2;\n+      else\n+\tm_p_thread=MIN_PER_THREAD;\n+\n+      many_iterations_cond =\n+\tfold_build2 (GE_EXPR, boolean_type_node,\n+\t\t     nit, build_int_cst (type, m_p_thread * n_threads));\n+\n       many_iterations_cond\n-\t= force_gimple_operand (many_iterations_cond, &stmts,\n-\t\t\t\ttrue, NULL_TREE);\n+\t= fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t       invert_truthvalue (unshare_expr (niter->may_be_zero)),\n+\t\t       many_iterations_cond);\n+      many_iterations_cond\n+\t= force_gimple_operand (many_iterations_cond, &stmts, false, NULL_TREE);\n       if (stmts)\n \tgsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);\n-    }\n+      if (!is_gimple_condexpr (many_iterations_cond))\n+\t{\n+\t  many_iterations_cond\n+\t    = force_gimple_operand (many_iterations_cond, &stmts,\n+\t\t\t\t    true, NULL_TREE);\n+\t  if (stmts)\n+\t    gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop),\n+\t\t\t\t\t      stmts);\n+\t}\n \n-  initialize_original_copy_tables ();\n+      initialize_original_copy_tables ();\n \n-  /* We assume that the loop usually iterates a lot.  */\n-  prob = 4 * REG_BR_PROB_BASE / 5;\n-  loop_version (loop, many_iterations_cond, NULL,\n-\t\tprob, prob, REG_BR_PROB_BASE - prob, true);\n-  update_ssa (TODO_update_ssa);\n-  free_original_copy_tables ();\n+      /* We assume that the loop usually iterates a lot.  */\n+      prob = 4 * REG_BR_PROB_BASE / 5;\n+      loop_version (loop, many_iterations_cond, NULL,\n+\t\t    prob, prob, REG_BR_PROB_BASE - prob, true);\n+      update_ssa (TODO_update_ssa);\n+      free_original_copy_tables ();\n+    }\n \n   /* Base all the induction variables in LOOP on a single control one.  */\n   canonicalize_loop_ivs (loop, &nit, true);\n@@ -2315,6 +2367,9 @@ gen_parallel_loop (struct loop *loop,\n     }\n   else\n     {\n+      if (oacc_kernels_p)\n+\tn_threads = 1;\n+\n       /* Fall back on the method that handles more cases, but duplicates the\n \t loop body: move the exit condition of LOOP to the beginning of its\n \t header, and duplicate the part of the last iteration that gets disabled\n@@ -2331,19 +2386,34 @@ gen_parallel_loop (struct loop *loop,\n   entry = loop_preheader_edge (loop);\n   exit = single_dom_exit (loop);\n \n-  eliminate_local_variables (entry, exit);\n-  /* In the old loop, move all variables non-local to the loop to a structure\n-     and back, and create separate decls for the variables used in loop.  */\n-  separate_decls_in_region (entry, exit, reduction_list, &arg_struct,\n-\t\t\t    &new_arg_struct, &clsn_data);\n+  /* This rewrites the body in terms of new variables.  This has already\n+     been done for oacc_kernels_p in pass_lower_omp/lower_omp ().  */\n+  if (!oacc_kernels_p)\n+    {\n+      eliminate_local_variables (entry, exit);\n+      /* In the old loop, move all variables non-local to the loop to a\n+\t structure and back, and create separate decls for the variables used in\n+\t loop.  */\n+      separate_decls_in_region (entry, exit, reduction_list, &arg_struct,\n+\t\t\t\t&new_arg_struct, &clsn_data);\n+    }\n+  else\n+    {\n+      arg_struct = NULL_TREE;\n+      new_arg_struct = NULL_TREE;\n+      clsn_data.load = NULL_TREE;\n+      clsn_data.load_bb = exit->dest;\n+      clsn_data.store = NULL_TREE;\n+      clsn_data.store_bb = NULL;\n+    }\n \n   /* Create the parallel constructs.  */\n   loc = UNKNOWN_LOCATION;\n   cond_stmt = last_stmt (loop->header);\n   if (cond_stmt)\n     loc = gimple_location (cond_stmt);\n-  create_parallel_loop (loop, create_loop_fn (loc), arg_struct,\n-\t\t\tnew_arg_struct, n_threads, loc);\n+  create_parallel_loop (loop, create_loop_fn (loc), arg_struct, new_arg_struct,\n+\t\t\tn_threads, loc, oacc_kernels_p);\n   if (reduction_list->elements () > 0)\n     create_call_for_reduction (loop, reduction_list, &clsn_data);\n \n@@ -2542,12 +2612,65 @@ try_get_loop_niter (loop_p loop, struct tree_niter_desc *niter)\n   return true;\n }\n \n+/* Return the default def of the first function argument.  */\n+\n+static tree\n+get_omp_data_i_param (void)\n+{\n+  tree decl = DECL_ARGUMENTS (cfun->decl);\n+  gcc_assert (DECL_CHAIN (decl) == NULL_TREE);\n+  return ssa_default_def (cfun, decl);\n+}\n+\n+/* For PHI in loop header of LOOP, look for pattern:\n+\n+   <bb preheader>\n+   .omp_data_i = &.omp_data_arr;\n+   addr = .omp_data_i->sum;\n+   sum_a = *addr;\n+\n+   <bb header>:\n+   sum_b = PHI <sum_a (preheader), sum_c (latch)>\n+\n+   and return addr.  Otherwise, return NULL_TREE.  */\n+\n+static tree\n+find_reduc_addr (struct loop *loop, gphi *phi)\n+{\n+  edge e = loop_preheader_edge (loop);\n+  tree arg = PHI_ARG_DEF_FROM_EDGE (phi, e);\n+  gimple *stmt = SSA_NAME_DEF_STMT (arg);\n+  if (!gimple_assign_single_p (stmt))\n+    return NULL_TREE;\n+  tree memref = gimple_assign_rhs1 (stmt);\n+  if (TREE_CODE (memref) != MEM_REF)\n+    return NULL_TREE;\n+  tree addr = TREE_OPERAND (memref, 0);\n+\n+  gimple *stmt2 = SSA_NAME_DEF_STMT (addr);\n+  if (!gimple_assign_single_p (stmt2))\n+    return NULL_TREE;\n+  tree compref = gimple_assign_rhs1 (stmt2);\n+  if (TREE_CODE (compref) != COMPONENT_REF)\n+    return NULL_TREE;\n+  tree addr2 = TREE_OPERAND (compref, 0);\n+  if (TREE_CODE (addr2) != MEM_REF)\n+    return NULL_TREE;\n+  addr2 = TREE_OPERAND (addr2, 0);\n+  if (TREE_CODE (addr2) != SSA_NAME\n+      || addr2 != get_omp_data_i_param ())\n+    return NULL_TREE;\n+\n+  return addr;\n+}\n+\n /* Try to initialize REDUCTION_LIST for code generation part.\n    REDUCTION_LIST describes the reductions.  */\n \n static bool\n try_create_reduction_list (loop_p loop,\n-\t\t\t   reduction_info_table_type *reduction_list)\n+\t\t\t   reduction_info_table_type *reduction_list,\n+\t\t\t   bool oacc_kernels_p)\n {\n   edge exit = single_dom_exit (loop);\n   gphi_iterator gsi;\n@@ -2647,6 +2770,26 @@ try_create_reduction_list (loop_p loop,\n \t}\n     }\n \n+  if (oacc_kernels_p)\n+    {\n+      for (gsi = gsi_start_phis (loop->header); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n+\t{\n+\t  gphi *phi = gsi.phi ();\n+\t  tree def = PHI_RESULT (phi);\n+\t  affine_iv iv;\n+\n+\t  if (!virtual_operand_p (def)\n+\t      && !simple_iv (loop, loop, def, &iv, true))\n+\t    {\n+\t      tree addr = find_reduc_addr (loop, phi);\n+\t      if (addr == NULL_TREE)\n+\t\treturn false;\n+\t      struct reduction_info *red = reduction_phi (reduction_list, phi);\n+\t      red->reduc_addr = addr;\n+\t    }\n+\t}\n+    }\n \n   return true;\n }\n@@ -2679,6 +2822,350 @@ loop_has_phi_with_address_arg (struct loop *loop)\n       }\n  end:\n   free (bbs);\n+\n+  return res;\n+}\n+\n+/* Return true if memory ref REF (corresponding to the stmt at GSI in\n+   REGIONS_BB[I]) conflicts with the statements in REGIONS_BB[I] after gsi,\n+   or the statements in REGIONS_BB[I + n].  REF_IS_STORE indicates if REF is a\n+   store.  Ignore conflicts with SKIP_STMT.  */\n+\n+static bool\n+ref_conflicts_with_region (gimple_stmt_iterator gsi, ao_ref *ref,\n+\t\t\t   bool ref_is_store, vec<basic_block> region_bbs,\n+\t\t\t   unsigned int i, gimple *skip_stmt)\n+{\n+  basic_block bb = region_bbs[i];\n+  gsi_next (&gsi);\n+\n+  while (true)\n+    {\n+      for (; !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n+\t{\n+\t  gimple *stmt = gsi_stmt (gsi);\n+\t  if (stmt == skip_stmt)\n+\t    {\n+\t      if (dump_file)\n+\t\t{\n+\t\t  fprintf (dump_file, \"skipping reduction store: \");\n+\t\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t\t}\n+\t      continue;\n+\t    }\n+\n+\t  if (!gimple_vdef (stmt)\n+\t      && !gimple_vuse (stmt))\n+\t    continue;\n+\n+\t  if (gimple_code (stmt) == GIMPLE_RETURN)\n+\t    continue;\n+\n+\t  if (ref_is_store)\n+\t    {\n+\t      if (ref_maybe_used_by_stmt_p (stmt, ref))\n+\t\t{\n+\t\t  if (dump_file)\n+\t\t    {\n+\t\t      fprintf (dump_file, \"Stmt \");\n+\t\t      print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t\t    }\n+\t\t  return true;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      if (stmt_may_clobber_ref_p_1 (stmt, ref))\n+\t\t{\n+\t\t  if (dump_file)\n+\t\t    {\n+\t\t      fprintf (dump_file, \"Stmt \");\n+\t\t      print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t\t    }\n+\t\t  return true;\n+\t\t}\n+\t    }\n+\t}\n+      i++;\n+      if (i == region_bbs.length ())\n+\tbreak;\n+      bb = region_bbs[i];\n+      gsi = gsi_start_bb (bb);\n+    }\n+\n+  return false;\n+}\n+\n+/* Return true if the bbs in REGION_BBS but not in in_loop_bbs can be executed\n+   in parallel with REGION_BBS containing the loop.  Return the stores of\n+   reduction results in REDUCTION_STORES.  */\n+\n+static bool\n+oacc_entry_exit_ok_1 (bitmap in_loop_bbs, vec<basic_block> region_bbs,\n+\t\t      reduction_info_table_type *reduction_list,\n+\t\t      bitmap reduction_stores)\n+{\n+  tree omp_data_i = get_omp_data_i_param ();\n+\n+  unsigned i;\n+  basic_block bb;\n+  FOR_EACH_VEC_ELT (region_bbs, i, bb)\n+    {\n+      if (bitmap_bit_p (in_loop_bbs, bb->index))\n+\tcontinue;\n+\n+      gimple_stmt_iterator gsi;\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n+\t{\n+\t  gimple *stmt = gsi_stmt (gsi);\n+\t  gimple *skip_stmt = NULL;\n+\n+\t  if (is_gimple_debug (stmt)\n+\t      || gimple_code (stmt) == GIMPLE_COND)\n+\t    continue;\n+\n+\t  ao_ref ref;\n+\t  bool ref_is_store = false;\n+\t  if (gimple_assign_load_p (stmt))\n+\t    {\n+\t      tree rhs = gimple_assign_rhs1 (stmt);\n+\t      tree base = get_base_address (rhs);\n+\t      if (TREE_CODE (base) == MEM_REF\n+\t\t  && operand_equal_p (TREE_OPERAND (base, 0), omp_data_i, 0))\n+\t\tcontinue;\n+\n+\t      tree lhs = gimple_assign_lhs (stmt);\n+\t      if (TREE_CODE (lhs) == SSA_NAME\n+\t\t  && has_single_use (lhs))\n+\t\t{\n+\t\t  use_operand_p use_p;\n+\t\t  gimple *use_stmt;\n+\t\t  single_imm_use (lhs, &use_p, &use_stmt);\n+\t\t  if (gimple_code (use_stmt) == GIMPLE_PHI)\n+\t\t    {\n+\t\t      struct reduction_info *red;\n+\t\t      red = reduction_phi (reduction_list, use_stmt);\n+\t\t      tree val = PHI_RESULT (red->keep_res);\n+\t\t      if (has_single_use (val))\n+\t\t\t{\n+\t\t\t  single_imm_use (val, &use_p, &use_stmt);\n+\t\t\t  if (gimple_store_p (use_stmt))\n+\t\t\t    {\n+\t\t\t      unsigned int id\n+\t\t\t\t= SSA_NAME_VERSION (gimple_vdef (use_stmt));\n+\t\t\t      bitmap_set_bit (reduction_stores, id);\n+\t\t\t      skip_stmt = use_stmt;\n+\t\t\t      if (dump_file)\n+\t\t\t\t{\n+\t\t\t\t  fprintf (dump_file, \"found reduction load: \");\n+\t\t\t\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t\t\t\t}\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\n+\t      ao_ref_init (&ref, rhs);\n+\t    }\n+\t  else if (gimple_store_p (stmt))\n+\t    {\n+\t      ao_ref_init (&ref, gimple_assign_lhs (stmt));\n+\t      ref_is_store = true;\n+\t    }\n+\t  else if (gimple_code (stmt) == GIMPLE_OMP_RETURN)\n+\t    continue;\n+\t  else if (!gimple_has_side_effects (stmt)\n+\t\t   && !gimple_could_trap_p (stmt)\n+\t\t   && !stmt_could_throw_p (stmt)\n+\t\t   && !gimple_vdef (stmt)\n+\t\t   && !gimple_vuse (stmt))\n+\t    continue;\n+\t  else if (is_gimple_call (stmt)\n+\t\t   && gimple_call_internal_p (stmt)\n+\t\t   && gimple_call_internal_fn (stmt) == IFN_GOACC_DIM_POS)\n+\t    continue;\n+\t  else if (gimple_code (stmt) == GIMPLE_RETURN)\n+\t    continue;\n+\t  else\n+\t    {\n+\t      if (dump_file)\n+\t\t{\n+\t\t  fprintf (dump_file, \"Unhandled stmt in entry/exit: \");\n+\t\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t\t}\n+\t      return false;\n+\t    }\n+\n+\t  if (ref_conflicts_with_region (gsi, &ref, ref_is_store, region_bbs,\n+\t\t\t\t\t i, skip_stmt))\n+\t    {\n+\t      if (dump_file)\n+\t\t{\n+\t\t  fprintf (dump_file, \"conflicts with entry/exit stmt: \");\n+\t\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t\t}\n+\t      return false;\n+\t    }\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+/* Find stores inside REGION_BBS and outside IN_LOOP_BBS, and guard them with\n+   gang_pos == 0, except when the stores are REDUCTION_STORES.  Return true\n+   if any changes were made.  */\n+\n+static bool\n+oacc_entry_exit_single_gang (bitmap in_loop_bbs, vec<basic_block> region_bbs,\n+\t\t\t     bitmap reduction_stores)\n+{\n+  tree gang_pos = NULL_TREE;\n+  bool changed = false;\n+\n+  unsigned i;\n+  basic_block bb;\n+  FOR_EACH_VEC_ELT (region_bbs, i, bb)\n+    {\n+      if (bitmap_bit_p (in_loop_bbs, bb->index))\n+\tcontinue;\n+\n+      gimple_stmt_iterator gsi;\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi);)\n+\t{\n+\t  gimple *stmt = gsi_stmt (gsi);\n+\n+\t  if (!gimple_store_p (stmt))\n+\t    {\n+\t      /* Update gsi to point to next stmt.  */\n+\t      gsi_next (&gsi);\n+\t      continue;\n+\t    }\n+\n+\t  if (bitmap_bit_p (reduction_stores,\n+\t\t\t    SSA_NAME_VERSION (gimple_vdef (stmt))))\n+\t    {\n+\t      if (dump_file)\n+\t\t{\n+\t\t  fprintf (dump_file,\n+\t\t\t   \"skipped reduction store for single-gang\"\n+\t\t\t   \" neutering: \");\n+\t\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t\t}\n+\n+\t      /* Update gsi to point to next stmt.  */\n+\t      gsi_next (&gsi);\n+\t      continue;\n+\t    }\n+\n+\t  changed = true;\n+\n+\t  if (gang_pos == NULL_TREE)\n+\t    {\n+\t      tree arg = build_int_cst (integer_type_node, GOMP_DIM_GANG);\n+\t      gcall *gang_single\n+\t\t= gimple_build_call_internal (IFN_GOACC_DIM_POS, 1, arg);\n+\t      gang_pos = make_ssa_name (integer_type_node);\n+\t      gimple_call_set_lhs (gang_single, gang_pos);\n+\t      gimple_stmt_iterator start\n+\t\t= gsi_start_bb (single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n+\t      tree vuse = ssa_default_def (cfun, gimple_vop (cfun));\n+\t      gimple_set_vuse (gang_single, vuse);\n+\t      gsi_insert_before (&start, gang_single, GSI_SAME_STMT);\n+\t    }\n+\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file,\n+\t\t       \"found store that needs single-gang neutering: \");\n+\t      print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t    }\n+\n+\t  {\n+\t    /* Split block before store.  */\n+\t    gimple_stmt_iterator gsi2 = gsi;\n+\t    gsi_prev (&gsi2);\n+\t    edge e;\n+\t    if (gsi_end_p (gsi2))\n+\t      {\n+\t\te = split_block_after_labels (bb);\n+\t\tgsi2 = gsi_last_bb (bb);\n+\t      }\n+\t    else\n+\t      e = split_block (bb, gsi_stmt (gsi2));\n+\t    basic_block bb2 = e->dest;\n+\n+\t    /* Split block after store.  */\n+\t    gimple_stmt_iterator gsi3 = gsi_start_bb (bb2);\n+\t    edge e2 = split_block (bb2, gsi_stmt (gsi3));\n+\t    basic_block bb3 = e2->dest;\n+\n+\t    gimple *cond\n+\t      = gimple_build_cond (EQ_EXPR, gang_pos, integer_zero_node,\n+\t\t\t\t   NULL_TREE, NULL_TREE);\n+\t    gsi_insert_after (&gsi2, cond, GSI_NEW_STMT);\n+\n+\t    edge e3 = make_edge (bb, bb3, EDGE_FALSE_VALUE);\n+\t    e->flags = EDGE_TRUE_VALUE;\n+\n+\t    tree vdef = gimple_vdef (stmt);\n+\t    tree vuse = gimple_vuse (stmt);\n+\n+\t    tree phi_res = copy_ssa_name (vdef);\n+\t    gphi *new_phi = create_phi_node (phi_res, bb3);\n+\t    replace_uses_by (vdef, phi_res);\n+\t    add_phi_arg (new_phi, vuse, e3, UNKNOWN_LOCATION);\n+\t    add_phi_arg (new_phi, vdef, e2, UNKNOWN_LOCATION);\n+\n+\t    /* Update gsi to point to next stmt.  */\n+\t    bb = bb3;\n+\t    gsi = gsi_start_bb (bb);\n+\t  }\n+\t}\n+    }\n+\n+  return changed;\n+}\n+\n+/* Return true if the statements before and after the LOOP can be executed in\n+   parallel with the function containing the loop.  Resolve conflicting stores\n+   outside LOOP by guarding them such that only a single gang executes them.  */\n+\n+static bool\n+oacc_entry_exit_ok (struct loop *loop,\n+\t\t    reduction_info_table_type *reduction_list)\n+{\n+  basic_block *loop_bbs = get_loop_body_in_dom_order (loop);\n+  vec<basic_block> region_bbs\n+    = get_all_dominated_blocks (CDI_DOMINATORS, ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+\n+  bitmap in_loop_bbs = BITMAP_ALLOC (NULL);\n+  bitmap_clear (in_loop_bbs);\n+  for (unsigned int i = 0; i < loop->num_nodes; i++)\n+    bitmap_set_bit (in_loop_bbs, loop_bbs[i]->index);\n+\n+  bitmap reduction_stores = BITMAP_ALLOC (NULL);\n+  bool res = oacc_entry_exit_ok_1 (in_loop_bbs, region_bbs, reduction_list,\n+\t\t\t\t   reduction_stores);\n+\n+  if (res)\n+    {\n+      bool changed = oacc_entry_exit_single_gang (in_loop_bbs, region_bbs,\n+\t\t\t\t\t\t  reduction_stores);\n+      if (changed)\n+\t{\n+\t  free_dominance_info (CDI_DOMINATORS);\n+\t  calculate_dominance_info (CDI_DOMINATORS);\n+\t}\n+    }\n+\n+  free (loop_bbs);\n+\n+  BITMAP_FREE (in_loop_bbs);\n+  BITMAP_FREE (reduction_stores);\n+\n   return res;\n }\n \n@@ -2687,7 +3174,7 @@ loop_has_phi_with_address_arg (struct loop *loop)\n    otherwise.  */\n \n static bool\n-parallelize_loops (void)\n+parallelize_loops (bool oacc_kernels_p)\n {\n   unsigned n_threads = flag_tree_parallelize_loops;\n   bool changed = false;\n@@ -2699,19 +3186,29 @@ parallelize_loops (void)\n   source_location loop_loc;\n \n   /* Do not parallelize loops in the functions created by parallelization.  */\n-  if (parallelized_function_p (cfun->decl))\n+  if (!oacc_kernels_p\n+      && parallelized_function_p (cfun->decl))\n     return false;\n+\n+  /* Do not parallelize loops in offloaded functions.  */\n+  if (!oacc_kernels_p\n+      && get_oacc_fn_attrib (cfun->decl) != NULL)\n+     return false;\n+\n   if (cfun->has_nonlocal_label)\n     return false;\n \n   gcc_obstack_init (&parloop_obstack);\n   reduction_info_table_type reduction_list (10);\n \n+  calculate_dominance_info (CDI_DOMINATORS);\n+\n   FOR_EACH_LOOP (loop, 0)\n     {\n       if (loop == skip_loop)\n \t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t  if (!loop->in_oacc_kernels_region\n+\t      && dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file,\n \t\t     \"Skipping loop %d as inner loop of parallelized loop\\n\",\n \t\t     loop->num);\n@@ -2723,6 +3220,22 @@ parallelize_loops (void)\n \tskip_loop = NULL;\n \n       reduction_list.empty ();\n+\n+      if (oacc_kernels_p)\n+\t{\n+\t  if (!loop->in_oacc_kernels_region)\n+\t    continue;\n+\n+\t  /* Don't try to parallelize inner loops in an oacc kernels region.  */\n+\t  if (loop->inner)\n+\t    skip_loop = loop->inner;\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file,\n+\t\t     \"Trying loop %d with header bb %d in oacc kernels\"\n+\t\t     \" region\\n\", loop->num, loop->header->index);\n+\t}\n+\n       if (dump_file && (dump_flags & TDF_DETAILS))\n       {\n         fprintf (dump_file, \"Trying loop %d as candidate\\n\",loop->num);\n@@ -2764,6 +3277,7 @@ parallelize_loops (void)\n       /* FIXME: Bypass this check as graphite doesn't update the\n \t count and frequency correctly now.  */\n       if (!flag_loop_parallelize_all\n+\t  && !oacc_kernels_p\n \t  && ((estimated != -1\n \t       && estimated <= (HOST_WIDE_INT) n_threads * MIN_PER_THREAD)\n \t      /* Do not bother with loops in cold areas.  */\n@@ -2773,7 +3287,7 @@ parallelize_loops (void)\n       if (!try_get_loop_niter (loop, &niter_desc))\n \tcontinue;\n \n-      if (!try_create_reduction_list (loop, &reduction_list))\n+      if (!try_create_reduction_list (loop, &reduction_list, oacc_kernels_p))\n \tcontinue;\n \n       if (loop_has_phi_with_address_arg (loop))\n@@ -2783,6 +3297,14 @@ parallelize_loops (void)\n \t  && !loop_parallel_p (loop, &parloop_obstack))\n \tcontinue;\n \n+      if (oacc_kernels_p\n+\t&& !oacc_entry_exit_ok (loop, &reduction_list))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"entry/exit not ok: FAILED\\n\");\n+\t  continue;\n+\t}\n+\n       changed = true;\n       skip_loop = loop->inner;\n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -2796,8 +3318,9 @@ parallelize_loops (void)\n \t  fprintf (dump_file, \"\\nloop at %s:%d: \",\n \t\t   LOCATION_FILE (loop_loc), LOCATION_LINE (loop_loc));\n       }\n+\n       gen_parallel_loop (loop, &reduction_list,\n-\t\t\t n_threads, &niter_desc);\n+\t\t\t n_threads, &niter_desc, oacc_kernels_p);\n     }\n \n   obstack_free (&parloop_obstack, NULL);\n@@ -2832,13 +3355,22 @@ class pass_parallelize_loops : public gimple_opt_pass\n {\n public:\n   pass_parallelize_loops (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_parallelize_loops, ctxt)\n+    : gimple_opt_pass (pass_data_parallelize_loops, ctxt),\n+      oacc_kernels_p (false)\n   {}\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return flag_tree_parallelize_loops > 1; }\n   virtual unsigned int execute (function *);\n+  opt_pass * clone () { return new pass_parallelize_loops (m_ctxt); }\n+  void set_pass_param (unsigned int n, bool param)\n+    {\n+      gcc_assert (n == 0);\n+      oacc_kernels_p = param;\n+    }\n \n+ private:\n+  bool oacc_kernels_p;\n }; // class pass_parallelize_loops\n \n unsigned\n@@ -2863,7 +3395,7 @@ pass_parallelize_loops::execute (function *fun)\n     }\n \n   unsigned int todo = 0;\n-  if (parallelize_loops ())\n+  if (parallelize_loops (oacc_kernels_p))\n     {\n       fun->curr_properties &= ~(PROP_gimple_eomp);\n "}]}