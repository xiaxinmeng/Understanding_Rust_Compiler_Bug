{"sha": "b60a8416357bb6e8166547bef7bc67c56f104557", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjYwYTg0MTYzNTdiYjZlODE2NjU0N2JlZjdiYzY3YzU2ZjEwNDU1Nw==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1998-05-01T17:40:53Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1998-05-01T17:40:53Z"}, "message": "reload.c (find_reloads): Emit USEs to mark where a pseudo is reloaced with the MEM of its stack slot.\n\n\t* reload.c (find_reloads): Emit USEs to mark where a pseudo\n\tis reloaced with the MEM of its stack slot.\n\t* reload1.c (cannot_omit_stores): Delete.\n\t(reload): Don't initialize it.\n\tDon't apply avoid_return_reg logic to USEs.\n\tWhen done, remove USEs that have a REG_EQUAL note on them.\n\t(emit_reload_insns): Handle case where we have inherited a MEM.\n\t(delete_output_reload): Don't use cannot_omit_stores.\n\nFrom-SVN: r19508", "tree": {"sha": "ffd76e0f0eda23e68b7a122b84484b965f5142b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ffd76e0f0eda23e68b7a122b84484b965f5142b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b60a8416357bb6e8166547bef7bc67c56f104557", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b60a8416357bb6e8166547bef7bc67c56f104557", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b60a8416357bb6e8166547bef7bc67c56f104557", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b60a8416357bb6e8166547bef7bc67c56f104557/comments", "author": null, "committer": null, "parents": [{"sha": "bd64e40c54cbc7a94acf291e2011346caa637b6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd64e40c54cbc7a94acf291e2011346caa637b6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd64e40c54cbc7a94acf291e2011346caa637b6e"}], "stats": {"total": 161, "additions": 120, "deletions": 41}, "files": [{"sha": "21f6017738cc758e05b3b7fc59a0dbf28bf7ebb3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b60a8416357bb6e8166547bef7bc67c56f104557/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b60a8416357bb6e8166547bef7bc67c56f104557/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b60a8416357bb6e8166547bef7bc67c56f104557", "patch": "@@ -1,3 +1,14 @@\n+Sat May  2 01:37:29 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* reload.c (find_reloads): Emit USEs to mark where a pseudo\n+\tis reloaced with the MEM of its stack slot.\n+\t* reload1.c (cannot_omit_stores): Delete.\n+\t(reload): Don't initialize it.\n+\tDon't apply avoid_return_reg logic to USEs.\n+\tWhen done, remove USEs that have a REG_EQUAL note on them.\n+\t(emit_reload_insns): Handle case where we have inherited a MEM.\n+\t(delete_output_reload): Don't use cannot_omit_stores.\n+\n Thu Apr 30 18:59:03 1998  Jim Wilson  <wilson@cygnus.com>\n \n \t* Makefile.in (cpp.info, gcc.info): Put -o option before input file."}, {"sha": "5f02f2cd3e6137dfced6fee1c1ded93969992e19", "filename": "gcc/reload.c", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b60a8416357bb6e8166547bef7bc67c56f104557/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b60a8416357bb6e8166547bef7bc67c56f104557/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=b60a8416357bb6e8166547bef7bc67c56f104557", "patch": "@@ -2577,11 +2577,29 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t  substed_operand[i] = recog_operand[i] = *recog_operand_loc[i];\n \t}\n       else if (code == SUBREG)\n-\tsubsted_operand[i] = recog_operand[i] = *recog_operand_loc[i]\n-\t  = find_reloads_toplev (recog_operand[i], i, address_type[i],\n-\t\t\t\t ind_levels,\n-\t\t\t\t set != 0\n-\t\t\t\t && &SET_DEST (set) == recog_operand_loc[i]);\n+\t{\n+\t  rtx reg = SUBREG_REG (recog_operand[i]);\n+\t  rtx op\n+\t    = find_reloads_toplev (recog_operand[i], i, address_type[i],\n+\t\t\t\t   ind_levels,\n+\t\t\t\t   set != 0\n+\t\t\t\t   && &SET_DEST (set) == recog_operand_loc[i]);\n+\n+\t  /* If we made a MEM to load (a part of) the stackslot of a pseudo\n+\t     that didn't get a hard register, emit a USE with a REG_EQUAL\n+\t     note in front so that we might inherit a previous, possibly\n+\t     wider reload.  */\n+\t     \n+\t  if (GET_CODE (op) == MEM\n+\t      && GET_CODE (reg) == REG\n+\t      && (GET_MODE_SIZE (GET_MODE (reg))\n+\t\t  >= GET_MODE_SIZE (GET_MODE (op))))\n+            REG_NOTES (emit_insn_before (gen_rtx_USE (VOIDmode, reg), insn))\n+              = gen_rtx_EXPR_LIST (REG_EQUAL,\n+\t\t\t\t   reg_equiv_memory_loc[REGNO (reg)], NULL_RTX);\n+\n+\t  substed_operand[i] = recog_operand[i] = *recog_operand_loc[i] = op;\n+\t}\n       else if (code == PLUS || GET_RTX_CLASS (code) == '1')\n \t/* We can get a PLUS as an \"operand\" as a result of register\n \t   elimination.  See eliminate_regs and gen_reload.  We handle\n@@ -2621,16 +2639,13 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      if (rtx_varies_p (address))\n \t\taddress = copy_rtx (address);\n \n-\t      /* If this is an output operand, we must output a CLOBBER\n-\t\t after INSN so find_equiv_reg knows REGNO is being written. \n-\t\t Mark this insn specially, do we can put our output reloads\n-\t\t after it.  */\n-\n-\t      if (modified[i] != RELOAD_READ)\n-\t\tPUT_MODE (emit_insn_after (gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\t\t\t    recog_operand[i]),\n-\t\t\t\t\t   insn),\n-\t\t\t  DImode);\n+\t      /* Emit a USE that shows what register is being used/modified.  */\n+\t      REG_NOTES (emit_insn_before (gen_rtx_USE (VOIDmode,\n+\t\t\t\t\t\t\trecog_operand[i]),\n+\t\t\t\t\t   insn))\n+\t\t= gen_rtx_EXPR_LIST (REG_EQUAL,\n+\t\t\t\t     reg_equiv_memory_loc[regno],\n+\t\t\t\t     NULL_RTX);\n \n \t      *recog_operand_loc[i] = recog_operand[i]\n \t\t= gen_rtx_MEM (GET_MODE (recog_operand[i]), address);"}, {"sha": "c8fb2efbd0f3d25e855ceef22010e6e6057c016d", "filename": "gcc/reload1.c", "status": "modified", "additions": 75, "deletions": 26, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b60a8416357bb6e8166547bef7bc67c56f104557/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b60a8416357bb6e8166547bef7bc67c56f104557/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=b60a8416357bb6e8166547bef7bc67c56f104557", "patch": "@@ -204,12 +204,6 @@ static HARD_REG_SET counted_for_groups;\n    as part of a group, even if it seems to be otherwise ok.  */\n static HARD_REG_SET counted_for_nongroups;\n \n-/* Indexed by pseudo reg number N,\n-   says may not delete stores into the real (memory) home of pseudo N.\n-   This is set if we already substituted a memory equivalent in some uses,\n-   which happens when we have to eliminate the fp from it.  */\n-static char *cannot_omit_stores;\n-\n /* Nonzero if indirect addressing is supported on the machine; this means\n    that spilling (REG n) does not require reloading it into a register in\n    order to do (MEM (REG n)) or (MEM (PLUS (REG n) (CONST_INT c))).  The\n@@ -634,8 +628,6 @@ reload (first, global, dumpfile)\n   bzero ((char *) reg_equiv_address, max_regno * sizeof (rtx));\n   reg_max_ref_width = (int *) alloca (max_regno * sizeof (int));\n   bzero ((char *) reg_max_ref_width, max_regno * sizeof (int));\n-  cannot_omit_stores = (char *) alloca (max_regno);\n-  bzero (cannot_omit_stores, max_regno);\n \n   if (SMALL_REGISTER_CLASSES)\n     CLEAR_HARD_REG_SET (forbidden_regs);\n@@ -1111,7 +1103,8 @@ reload (first, global, dumpfile)\n \t\t}\n \t      else if (SMALL_REGISTER_CLASSES && after_call != 0\n \t\t       && !(GET_CODE (PATTERN (insn)) == SET\n-\t\t\t    && SET_DEST (PATTERN (insn)) == stack_pointer_rtx))\n+\t\t\t    && SET_DEST (PATTERN (insn)) == stack_pointer_rtx)\n+\t\t       && GET_CODE (PATTERN (insn)) != USE)\n \t\t{\n \t\t  if (reg_referenced_p (after_call, PATTERN (insn)))\n \t\t    avoid_return_reg = after_call;\n@@ -2131,16 +2124,26 @@ reload (first, global, dumpfile)\n \t}\n     }\n \n-#ifdef PRESERVE_DEATH_INFO_REGNO_P\n-  /* Make a pass over all the insns and remove death notes for things that\n-     are no longer registers or no longer die in the insn (e.g., an input\n-     and output pseudo being tied).  */\n+  /* Make a pass over all the insns and delete all USEs which we inserted\n+     only to tag a REG_EQUAL note on them; if PRESERVE_DEATH_INFO_REGNO_P\n+     is defined, also remove death notes for things that are no longer\n+     registers or no longer die in the insn (e.g., an input and output\n+     pseudo being tied).  */\n \n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n       {\n \trtx note, next;\n \n+\tif (GET_CODE (insn) == USE\n+\t    && find_reg_note (insn, REG_EQUAL, NULL_RTX))\n+\t  {\n+\t    PUT_CODE (insn, NOTE);\n+\t    NOTE_SOURCE_FILE (insn) = 0;\n+\t    NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\t    continue;\n+\t  }\n+#ifdef PRESERVE_DEATH_INFO_REGNO_P\n \tfor (note = REG_NOTES (insn); note; note = next)\n \t  {\n \t    next = XEXP (note, 1);\n@@ -2149,8 +2152,8 @@ reload (first, global, dumpfile)\n \t\t    || reg_set_p (XEXP (note, 0), PATTERN (insn))))\n \t      remove_note (insn, note);\n \t  }\n-      }\n #endif\n+      }\n \n   /* If we are doing stack checking, give a warning if this function's\n      frame size is larger than we expect.  */\n@@ -2884,7 +2887,10 @@ eliminate_regs (x, mem_mode, insn)\n \t  new = eliminate_regs (reg_equiv_memory_loc[regno], mem_mode, insn);\n \t  if (new != reg_equiv_memory_loc[regno])\n \t    {\n-\t      cannot_omit_stores[regno] = 1;\n+\t      if (insn != 0 && GET_CODE (insn) != EXPR_LIST\n+\t\t  && GET_CODE (insn) != INSN_LIST)\n+\t\tREG_NOTES (emit_insn_before (gen_rtx_USE (VOIDmode, x), insn))\n+\t\t  = gen_rtx_EXPR_LIST (REG_EQUAL, new, NULL_RTX);\n \t      return copy_rtx (new);\n \t    }\n \t}\n@@ -3103,16 +3109,17 @@ eliminate_regs (x, mem_mode, insn)\n \t    new = SUBREG_REG (x);\n \t  else\n \t    {\n-\t      /* Otherwise, ensure NEW isn't shared in case we have to reload\n-\t\t it.  */\n-\t      new = copy_rtx (new);\n-\n \t      /* In this case, we must show that the pseudo is used in this\n \t\t insn so that delete_output_reload will do the right thing.  */\n \t      if (insn != 0 && GET_CODE (insn) != EXPR_LIST\n \t\t  && GET_CODE (insn) != INSN_LIST)\n-\t\temit_insn_before (gen_rtx_USE (VOIDmode, SUBREG_REG (x)),\n-\t\t\t\t  insn);\n+\t\tREG_NOTES (emit_insn_before (gen_rtx_USE (VOIDmode,\n+\t\t\t\t\t\t\t  SUBREG_REG (x)),\n+\t\t\t\t\t\t\t  insn))\n+\t\t  = gen_rtx_EXPR_LIST (REG_EQUAL, new, NULL_RTX);\n+\n+\t      /* Ensure NEW isn't shared in case we have to reload it.  */\n+\t      new = copy_rtx (new);\n \t    }\n \t}\n       else\n@@ -4056,7 +4063,8 @@ reload_as_needed (first, live_known)\n \t    }\n \t  else if (SMALL_REGISTER_CLASSES && after_call != 0\n \t\t   && !(GET_CODE (PATTERN (insn)) == SET\n-\t\t\t&& SET_DEST (PATTERN (insn)) == stack_pointer_rtx))\n+\t\t\t&& SET_DEST (PATTERN (insn)) == stack_pointer_rtx)\n+\t\t   && GET_CODE (PATTERN (insn)) != USE)\n \t    {\n \t      if (reg_referenced_p (after_call, PATTERN (insn)))\n \t\tavoid_return_reg = after_call;\n@@ -5465,6 +5473,7 @@ choose_reload_regs (insn, avoid_return_reg)\n \t    {\n \t      register int regno = -1;\n \t      enum machine_mode mode;\n+\t      rtx in, use_insn = 0;\n \n \t      if (reload_in[r] == 0)\n \t\t;\n@@ -5478,6 +5487,34 @@ choose_reload_regs (insn, avoid_return_reg)\n \t\t  regno = REGNO (reload_in_reg[r]);\n \t\t  mode = GET_MODE (reload_in_reg[r]);\n \t\t}\n+\t      else if (GET_CODE (reload_in[r]) == MEM)\n+\t\t{\n+\t\t  rtx prev = prev_nonnote_insn (insn), note;\n+\n+\t\t  if (prev && GET_CODE (prev) == INSN\n+\t\t      && GET_CODE (PATTERN (prev)) == USE\n+\t\t      && GET_CODE (XEXP (PATTERN (prev), 0)) == REG\n+\t\t      && (REGNO (XEXP (PATTERN (prev), 0))\n+\t\t\t  >= FIRST_PSEUDO_REGISTER)\n+\t\t      && (note = find_reg_note (prev, REG_EQUAL, NULL_RTX))\n+\t\t      && GET_CODE (XEXP (note, 0)) == MEM)\n+\t\t    {\n+\t\t      rtx addr = XEXP (XEXP (note, 0), 0);\n+\t\t      int size_diff\n+\t\t\t= (GET_MODE_SIZE (GET_MODE (addr))\n+\t\t\t   - GET_MODE_SIZE (GET_MODE (reload_in[r])));\n+\t\t      if (size_diff >= 0\n+\t\t\t  && rtx_equal_p ((BYTES_BIG_ENDIAN\n+\t\t\t\t\t   ? plus_constant (addr, size_diff)\n+\t\t\t\t\t   : addr),\n+\t\t\t\t\t  XEXP (reload_in[r], 0)))\n+\t\t\t{\n+\t\t\t  regno = REGNO (XEXP (PATTERN (prev), 0));\n+\t\t\t  mode = GET_MODE (reload_in[r]);\n+\t\t\t  use_insn = prev;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n #if 0\n \t      /* This won't work, since REGNO can be a pseudo reg number.\n \t\t Also, it takes much more hair to keep track of all the things\n@@ -5995,6 +6032,7 @@ emit_reload_insns (insn)\n       register rtx old;\n       rtx oldequiv_reg = 0;\n       rtx this_reload_insn = 0;\n+      int expect_occurrences = 1;\n \n       if (reload_spill_index[j] >= 0)\n \tnew_spill_reg_store[reload_spill_index[j]] = 0;\n@@ -6428,6 +6466,19 @@ emit_reload_insns (insn)\n \t  end_sequence ();\n \t}\n \n+      /* When inheriting a wider reload, we have a MEM in reload_in[j],\n+\t e.g. inheriting a SImode output reload for\n+\t (mem:HI (plus:SI (reg:SI 14 fp) (const_int 10)))  */\n+      if (optimize && reload_inherited[j] && reload_in[j]\n+\t  && GET_CODE (reload_in[j]) == MEM\n+\t  && reload_spill_index[j] >= 0\n+\t  && TEST_HARD_REG_BIT (reg_reloaded_valid, reload_spill_index[j]))\n+\t{\n+\t  expect_occurrences\n+\t    = count_occurrences (PATTERN (insn), reload_in[j]) == 1 ? 0 : -1;\n+\t  reload_in[j]\n+\t    = regno_reg_rtx[reg_reloaded_contents[reload_spill_index[j]]];\n+\t}\n       /* Add a note saying the input reload reg\n \t dies in this insn, if anyone cares.  */\n #ifdef PRESERVE_DEATH_INFO_REGNO_P\n@@ -6561,7 +6612,8 @@ emit_reload_insns (insn)\n \t  && dead_or_set_p (insn, reload_in[j])\n \t  /* This is unsafe if operand occurs more than once in current\n \t     insn.  Perhaps some occurrences weren't reloaded.  */\n-\t  && count_occurrences (PATTERN (insn), reload_in[j]) == 1)\n+\t  && (count_occurrences (PATTERN (insn), reload_in[j])\n+\t      == expect_occurrences))\n \tdelete_output_reload (insn, j,\n \t\t\t      spill_reg_store[reload_spill_index[j]]);\n \n@@ -7296,9 +7348,6 @@ delete_output_reload (insn, j, output_reload_insn)\n \treturn;\n     }\n \n-  if (cannot_omit_stores[REGNO (reg)])\n-    return;\n-\n   /* If this insn will store in the pseudo again,\n      the previous store can be removed.  */\n   if (reload_out[j] == reload_in[j])"}, {"sha": "0127fcea456965d66c3bd49ab9daeac1e165cea3", "filename": "gcc/rtl.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b60a8416357bb6e8166547bef7bc67c56f104557/gcc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b60a8416357bb6e8166547bef7bc67c56f104557/gcc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.texi?ref=b60a8416357bb6e8166547bef7bc67c56f104557", "patch": "@@ -1892,6 +1892,10 @@ it may not be apparent why this is so.  Therefore, the compiler will\n not attempt to delete previous instructions whose only effect is to\n store a value in @var{x}.  @var{x} must be a @code{reg} expression.\n \n+During the reload phase, an insn that has a @code{use} as pattern\n+can carry a reg_equal note.  These @code{use} insns will be deleted\n+before the reload phase exits.\n+\n During the delayed branch scheduling phase, @var{x} may be an insn.\n This indicates that @var{x} previously was located at this place in the\n code and its data dependencies need to be taken into account.  These"}]}