{"sha": "f35c297f8d42500060a2ca323af66c3aedea3334", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM1YzI5N2Y4ZDQyNTAwMDYwYTJjYTMyM2FmNjZjM2FlZGVhMzMzNA==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2013-03-25T13:48:06Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2013-03-25T13:48:06Z"}, "message": "re PR target/56720 (ICE when expanding vcond with floating point unordered comparisons)\n\n2013-03-25  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n\tPR target/56720\n\t* config/arm/iterators.md (v_cmp_result): New mode attribute.\n\t* config/arm/neon.md (vcond<mode><mode>): Handle unordered cases.\n\n2013-03-25  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n\tPR target/56720\n\t* gcc.target/arm/neon-vcond-gt.c: New test.\n\t* gcc.target/arm/neon-vcond-ltgt.c: Likewise.\n\t* gcc.target/arm/neon-vcond-unordered.c: Likewise.\n\nFrom-SVN: r197040", "tree": {"sha": "d939d83f3653d0e7298e07e3069cbbae3e932233", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d939d83f3653d0e7298e07e3069cbbae3e932233"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f35c297f8d42500060a2ca323af66c3aedea3334", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f35c297f8d42500060a2ca323af66c3aedea3334", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f35c297f8d42500060a2ca323af66c3aedea3334", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f35c297f8d42500060a2ca323af66c3aedea3334/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "051b94466891c0eedaf808be384fa8696a680380", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/051b94466891c0eedaf808be384fa8696a680380", "html_url": "https://github.com/Rust-GCC/gccrs/commit/051b94466891c0eedaf808be384fa8696a680380"}], "stats": {"total": 167, "additions": 124, "deletions": 43}, "files": [{"sha": "491937cb2480f0cc567f2b8eb2ee2f1090c6bf11", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35c297f8d42500060a2ca323af66c3aedea3334/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35c297f8d42500060a2ca323af66c3aedea3334/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f35c297f8d42500060a2ca323af66c3aedea3334", "patch": "@@ -1,3 +1,8 @@\n+2013-03-25  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\tPR target/56720\n+\t* config/arm/iterators.md (v_cmp_result): New mode attribute.\n+\t* config/arm/neon.md (vcond<mode><mode>): Handle unordered cases.\n+\n 2013-03-25  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/56689"}, {"sha": "b3ad42b376f8a4085c2c8d5844bd14285be1793d", "filename": "gcc/config/arm/iterators.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35c297f8d42500060a2ca323af66c3aedea3334/gcc%2Fconfig%2Farm%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35c297f8d42500060a2ca323af66c3aedea3334/gcc%2Fconfig%2Farm%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fiterators.md?ref=f35c297f8d42500060a2ca323af66c3aedea3334", "patch": "@@ -314,6 +314,12 @@\n                                 (V2SF \"V2SI\") (V4SF  \"V4SI\")\n                                 (DI   \"DI\")   (V2DI  \"V2DI\")])\n \n+(define_mode_attr v_cmp_result [(V8QI \"v8qi\") (V16QI \"v16qi\")\n+\t\t\t\t(V4HI \"v4hi\") (V8HI  \"v8hi\")\n+\t\t\t\t(V2SI \"v2si\") (V4SI  \"v4si\")\n+\t\t\t\t(DI   \"di\")   (V2DI  \"v2di\")\n+\t\t\t\t(V2SF \"v2si\") (V4SF  \"v4si\")])\n+\n ;; Get element type from double-width mode, for operations where we \n ;; don't care about signedness.\n (define_mode_attr V_if_elem [(V8QI \"i8\")  (V16QI \"i8\")"}, {"sha": "d7c2cb3694992df08208c20bcf2e35c6b06de440", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 107, "deletions": 43, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35c297f8d42500060a2ca323af66c3aedea3334/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35c297f8d42500060a2ca323af66c3aedea3334/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=f35c297f8d42500060a2ca323af66c3aedea3334", "patch": "@@ -1721,80 +1721,144 @@\n (define_expand \"vcond<mode><mode>\"\n   [(set (match_operand:VDQW 0 \"s_register_operand\" \"\")\n \t(if_then_else:VDQW\n-\t  (match_operator 3 \"arm_comparison_operator\"\n+\t  (match_operator 3 \"comparison_operator\"\n \t    [(match_operand:VDQW 4 \"s_register_operand\" \"\")\n \t     (match_operand:VDQW 5 \"nonmemory_operand\" \"\")])\n \t  (match_operand:VDQW 1 \"s_register_operand\" \"\")\n \t  (match_operand:VDQW 2 \"s_register_operand\" \"\")))]\n   \"TARGET_NEON && (!<Is_float_mode> || flag_unsafe_math_optimizations)\"\n {\n-  rtx mask;\n-  int inverse = 0, immediate_zero = 0;\n-  /* See the description of \"magic\" bits in the 'T' case of\n-     arm_print_operand.  */\n   HOST_WIDE_INT magic_word = (<MODE>mode == V2SFmode || <MODE>mode == V4SFmode)\n \t\t\t     ? 3 : 1;\n   rtx magic_rtx = GEN_INT (magic_word);\n-  \n-  mask = gen_reg_rtx (<V_cmp_result>mode);\n-  \n-  if (operands[5] == CONST0_RTX (<MODE>mode))\n-    immediate_zero = 1;\n-  else if (!REG_P (operands[5]))\n-    operands[5] = force_reg (<MODE>mode, operands[5]);\n-  \n+  int inverse = 0;\n+  int swap_bsl_operands = 0;\n+  rtx mask = gen_reg_rtx (<V_cmp_result>mode);\n+  rtx tmp = gen_reg_rtx (<V_cmp_result>mode);\n+\n+  rtx (*base_comparison) (rtx, rtx, rtx, rtx);\n+  rtx (*complimentary_comparison) (rtx, rtx, rtx, rtx);\n+\n   switch (GET_CODE (operands[3]))\n     {\n     case GE:\n-      emit_insn (gen_neon_vcge<mode> (mask, operands[4], operands[5],\n-\t\t\t\t      magic_rtx));\n+    case LE:\n+    case EQ:\n+      if (!REG_P (operands[5])\n+\t  && (operands[5] != CONST0_RTX (<MODE>mode)))\n+\toperands[5] = force_reg (<MODE>mode, operands[5]);\n       break;\n-    \n+    default:\n+      if (!REG_P (operands[5]))\n+\toperands[5] = force_reg (<MODE>mode, operands[5]);\n+    }\n+\n+  switch (GET_CODE (operands[3]))\n+    {\n+    case LT:\n+    case UNLT:\n+      inverse = 1;\n+      /* Fall through.  */\n+    case GE:\n+    case UNGE:\n+    case ORDERED:\n+    case UNORDERED:\n+      base_comparison = gen_neon_vcge<mode>;\n+      complimentary_comparison = gen_neon_vcgt<mode>;\n+      break;\n+    case LE:\n+    case UNLE:\n+      inverse = 1;\n+      /* Fall through.  */\n     case GT:\n-      emit_insn (gen_neon_vcgt<mode> (mask, operands[4], operands[5],\n-\t\t\t\t      magic_rtx));\n+    case UNGT:\n+      base_comparison = gen_neon_vcgt<mode>;\n+      complimentary_comparison = gen_neon_vcge<mode>;\n       break;\n-    \n     case EQ:\n-      emit_insn (gen_neon_vceq<mode> (mask, operands[4], operands[5],\n-\t\t\t\t      magic_rtx));\n+    case NE:\n+    case UNEQ:\n+      base_comparison = gen_neon_vceq<mode>;\n+      complimentary_comparison = gen_neon_vceq<mode>;\n       break;\n-    \n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  switch (GET_CODE (operands[3]))\n+    {\n+    case LT:\n     case LE:\n-      if (immediate_zero)\n-\temit_insn (gen_neon_vcle<mode> (mask, operands[4], operands[5],\n-\t\t\t\t\tmagic_rtx));\n+    case GT:\n+    case GE:\n+    case EQ:\n+      /* The easy case.  Here we emit one of vcge, vcgt or vceq.\n+\t As a LT b <=> b GE a && a LE b <=> b GT a.  Our transformations are:\n+\t a GE b -> a GE b\n+\t a GT b -> a GT b\n+\t a LE b -> b GE a\n+\t a LT b -> b GT a\n+\t a EQ b -> a EQ b  */\n+\n+      if (!inverse)\n+\temit_insn (base_comparison (mask, operands[4], operands[5], magic_rtx));\n       else\n-\temit_insn (gen_neon_vcge<mode> (mask, operands[5], operands[4],\n-\t\t\t\t\tmagic_rtx));\n+\temit_insn (complimentary_comparison (mask, operands[5], operands[4], magic_rtx));\n       break;\n-    \n-    case LT:\n-      if (immediate_zero)\n-\temit_insn (gen_neon_vclt<mode> (mask, operands[4], operands[5],\n-\t\t\t\t\tmagic_rtx));\n+    case UNLT:\n+    case UNLE:\n+    case UNGT:\n+    case UNGE:\n+    case NE:\n+      /* Vector compare returns false for lanes which are unordered, so if we use\n+\t the inverse of the comparison we actually want to emit, then\n+\t swap the operands to BSL, we will end up with the correct result.\n+\t Note that a NE NaN and NaN NE b are true for all a, b.\n+\n+\t Our transformations are:\n+\t a GE b -> !(b GT a)\n+\t a GT b -> !(b GE a)\n+\t a LE b -> !(a GT b)\n+\t a LT b -> !(a GE b)\n+\t a NE b -> !(a EQ b)  */\n+\n+      if (inverse)\n+\temit_insn (base_comparison (mask, operands[4], operands[5], magic_rtx));\n       else\n-\temit_insn (gen_neon_vcgt<mode> (mask, operands[5], operands[4],\n-\t\t\t\t\tmagic_rtx));\n+\temit_insn (complimentary_comparison (mask, operands[5], operands[4], magic_rtx));\n+\n+      swap_bsl_operands = 1;\n       break;\n-    \n-    case NE:\n-      emit_insn (gen_neon_vceq<mode> (mask, operands[4], operands[5],\n-\t\t\t\t      magic_rtx));\n-      inverse = 1;\n+    case UNEQ:\n+      /* We check (a > b ||  b > a).  combining these comparisons give us\n+\t true iff !(a != b && a ORDERED b), swapping the operands to BSL\n+\t will then give us (a == b ||  a UNORDERED b) as intended.  */\n+\n+      emit_insn (gen_neon_vcgt<mode> (mask, operands[4], operands[5], magic_rtx));\n+      emit_insn (gen_neon_vcgt<mode> (tmp, operands[5], operands[4], magic_rtx));\n+      emit_insn (gen_ior<v_cmp_result>3 (mask, mask, tmp));\n+      swap_bsl_operands = 1;\n+      break;\n+    case UNORDERED:\n+       /* Operands are ORDERED iff (a > b || b >= a).\n+\t Swapping the operands to BSL will give the UNORDERED case.  */\n+     swap_bsl_operands = 1;\n+     /* Fall through.  */\n+    case ORDERED:\n+      emit_insn (gen_neon_vcgt<mode> (tmp, operands[4], operands[5], magic_rtx));\n+      emit_insn (gen_neon_vcge<mode> (mask, operands[5], operands[4], magic_rtx));\n+      emit_insn (gen_ior<v_cmp_result>3 (mask, mask, tmp));\n       break;\n-    \n     default:\n       gcc_unreachable ();\n     }\n-  \n-  if (inverse)\n+\n+  if (swap_bsl_operands)\n     emit_insn (gen_neon_vbsl<mode> (operands[0], mask, operands[2],\n \t\t\t\t    operands[1]));\n   else\n     emit_insn (gen_neon_vbsl<mode> (operands[0], mask, operands[1],\n \t\t\t\t    operands[2]));\n-\n   DONE;\n })\n "}, {"sha": "7e1cd5b0d8f8ba8df40c393fa72426cbf75f4d4c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35c297f8d42500060a2ca323af66c3aedea3334/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35c297f8d42500060a2ca323af66c3aedea3334/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f35c297f8d42500060a2ca323af66c3aedea3334", "patch": "@@ -1,3 +1,9 @@\n+2013-03-25  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\tPR target/56720\n+\t* gcc.target/arm/neon-vcond-gt.c: New test.\n+\t* gcc.target/arm/neon-vcond-ltgt.c: Likewise.\n+\t* gcc.target/arm/neon-vcond-unordered.c: Likewise.\n+\n 2013-03-25  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/56689"}]}