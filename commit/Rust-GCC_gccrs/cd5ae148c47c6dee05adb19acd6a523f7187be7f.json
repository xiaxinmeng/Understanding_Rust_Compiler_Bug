{"sha": "cd5ae148c47c6dee05adb19acd6a523f7187be7f", "node_id": "C_kwDOANBUbNoAKGNkNWFlMTQ4YzQ3YzZkZWUwNWFkYjE5YWNkNmE1MjNmNzE4N2JlN2Y", "commit": {"author": {"name": "Xionghu Luo", "email": "luoxhu@linux.ibm.com", "date": "2021-12-08T05:17:51Z"}, "committer": {"name": "Xionghu Luo", "email": "luoxhu@linux.ibm.com", "date": "2021-12-21T03:12:05Z"}, "message": "Fix loop split incorrect count and probability\n\nIn tree-ssa-loop-split.c, split_loop and split_loop_on_cond does two\nkind of split. split_loop only works for single loop and insert edge at\nexit when split, while split_loop_on_cond is not limited to single loop\nand insert edge at latch when split.  Both split behavior should consider\nloop count and probability update.  For split_loop, loop split condition\nis moved in front of loop1 and loop2; But split_loop_on_cond moves the\ncondition between loop1 and loop2, this patch does:\n 1) profile count proportion for both original loop and copied loop\nwithout dropping down the true branch's count;\n 2) probability update in the two loops and between the two loops.\n\nRegression tested pass.\n\nChanges diff for split_loop and split_loop_on_cond cases:\n\n1) diff base/loop-split.c.151t.lsplit patched/loop-split.c.152t.lsplit\n...\n   <bb 2> [local count: 118111600]:\n   if (beg_5(D) < end_8(D))\n     goto <bb 14>; [89.00%]\n   else\n     goto <bb 6>; [11.00%]\n\n   <bb 14> [local count: 105119324]:\n   if (beg2_6(D) < c_9(D))\n-    goto <bb 15>; [100.00%]\n+    goto <bb 15>; [33.00%]\n   else\n-    goto <bb 16>; [100.00%]\n+    goto <bb 16>; [67.00%]\n\n-  <bb 15> [local count: 105119324]:\n+  <bb 15> [local count: 34689377]:\n   _25 = beg_5(D) + 1;\n   _26 = end_8(D) - beg_5(D);\n   _27 = beg2_6(D) + _26;\n   _28 = MIN_EXPR <c_9(D), _27>;\n\n-  <bb 3> [local count: 955630225]:\n+  <bb 3> [local count: 315357973]:\n   # i_16 = PHI <i_11(8), beg_5(D)(15)>\n   # j_17 = PHI <j_12(8), beg2_6(D)(15)>\n   printf (\"a: %d %d\\n\", i_16, j_17);\n   i_11 = i_16 + 1;\n   j_12 = j_17 + 1;\n   if (j_12 < _28)\n-    goto <bb 8>; [89.00%]\n+    goto <bb 8>; [29.37%]\n   else\n-    goto <bb 17>; [11.00%]\n+    goto <bb 17>; [70.63%]\n\n-  <bb 8> [local count: 850510901]:\n+  <bb 8> [local count: 280668596]:\n   goto <bb 3>; [100.00%]\n\n-  <bb 16> [local count: 105119324]:\n+  <bb 16> [local count: 70429947]:\n   # i_22 = PHI <beg_5(D)(14), i_29(17)>\n   # j_23 = PHI <beg2_6(D)(14), j_30(17)>\n\n   <bb 10> [local count: 955630225]:\n   # i_2 = PHI <i_22(16), i_20(13)>\n   # j_1 = PHI <j_23(16), j_21(13)>\n   i_20 = i_2 + 1;\n   j_21 = j_1 + 1;\n   if (end_8(D) > i_20)\n-    goto <bb 13>; [89.00%]\n+    goto <bb 13>; [59.63%]\n   else\n-    goto <bb 9>; [11.00%]\n+    goto <bb 9>; [40.37%]\n\n-  <bb 13> [local count: 850510901]:\n+  <bb 13> [local count: 569842305]:\n   goto <bb 10>; [100.00%]\n\n   <bb 17> [local count: 105119324]:\n   # i_29 = PHI <i_11(3)>\n   # j_30 = PHI <j_12(3)>\n   if (end_8(D) > i_29)\n     goto <bb 16>; [80.00%]\n   else\n     goto <bb 9>; [20.00%]\n\n   <bb 9> [local count: 105119324]:\n\n   <bb 6> [local count: 118111600]:\n   return 0;\n\n }\n   <bb 2> [local count: 118111600]:\n-  if (beg_5(D) < end_8(D))\n+  _1 = end_6(D) - beg_7(D);\n+  j_9 = _1 + beg2_8(D);\n+  if (end_6(D) > beg_7(D))\n     goto <bb 14>; [89.00%]\n   else\n     goto <bb 6>; [11.00%]\n\n   <bb 14> [local count: 105119324]:\n-  if (beg2_6(D) < c_9(D))\n-    goto <bb 15>; [100.00%]\n+  if (j_9 >= c_11(D))\n+    goto <bb 15>; [33.00%]\n   else\n-    goto <bb 16>; [100.00%]\n+    goto <bb 16>; [67.00%]\n\n-  <bb 15> [local count: 105119324]:\n-  _25 = beg_5(D) + 1;\n-  _26 = end_8(D) - beg_5(D);\n-  _27 = beg2_6(D) + _26;\n-  _28 = MIN_EXPR <c_9(D), _27>;\n-\n-  <bb 3> [local count: 955630225]:\n-  # i_16 = PHI <i_11(8), beg_5(D)(15)>\n-  # j_17 = PHI <j_12(8), beg2_6(D)(15)>\n-  printf (\"a: %d %d\\n\", i_16, j_17);\n-  i_11 = i_16 + 1;\n-  j_12 = j_17 + 1;\n-  if (j_12 < _28)\n-    goto <bb 8>; [89.00%]\n+  <bb 15> [local count: 34689377]:\n+  _27 = end_6(D) + -1;\n+  _28 = beg_7(D) - end_6(D);\n+  _29 = j_9 + _28;\n+  _30 = _29 + 1;\n+  _31 = MAX_EXPR <c_11(D), _30>;\n+\n+  <bb 3> [local count: 315357973]:\n+  # i_18 = PHI <i_13(8), end_6(D)(15)>\n+  # j_19 = PHI <j_14(8), j_9(15)>\n+  printf (\"a: %d %d\\n\", i_18, j_19);\n+  i_13 = i_18 + -1;\n+  j_14 = j_19 + -1;\n+  if (j_14 >= _31)\n+    goto <bb 8>; [29.37%]\n   else\n-    goto <bb 17>; [11.00%]\n+    goto <bb 17>; [70.63%]\n\n-  <bb 8> [local count: 850510901]:\n+  <bb 8> [local count: 280668596]:\n   goto <bb 3>; [100.00%]\n\n-  <bb 16> [local count: 105119324]:\n-  # i_22 = PHI <beg_5(D)(14), i_29(17)>\n-  # j_23 = PHI <beg2_6(D)(14), j_30(17)>\n+  <bb 16> [local count: 70429947]:\n+  # i_24 = PHI <end_6(D)(14), i_32(17)>\n+  # j_25 = PHI <j_9(14), j_33(17)>\n\n   <bb 10> [local count: 955630225]:\n-  # i_2 = PHI <i_22(16), i_20(13)>\n-  # j_1 = PHI <j_23(16), j_21(13)>\n-  i_20 = i_2 + 1;\n-  j_21 = j_1 + 1;\n-  if (end_8(D) > i_20)\n+  # i_3 = PHI <i_24(16), i_22(13)>\n+  # j_2 = PHI <j_25(16), j_23(13)>\n+  i_22 = i_3 + -1;\n+  j_23 = j_2 + -1;\n+  if (beg_7(D) < i_22)\n     goto <bb 13>; [89.00%]\n   else\n     goto <bb 9>; [11.00%]\n\n-  <bb 13> [local count: 850510901]:\n+  <bb 13> [local count: 569842305]:\n   goto <bb 10>; [100.00%]\n\n   <bb 17> [local count: 105119324]:\n-  # i_29 = PHI <i_11(3)>\n-  # j_30 = PHI <j_12(3)>\n-  if (end_8(D) > i_29)\n+  # i_32 = PHI <i_13(3)>\n+  # j_33 = PHI <j_14(3)>\n+  if (beg_7(D) < i_32)\n     goto <bb 16>; [80.00%]\n   else\n     goto <bb 9>; [20.00%]\n\n   <bb 9> [local count: 105119324]:\n\n   <bb 6> [local count: 118111600]:\n   return 0;\n\n }\n\n2) diff base/loop-cond-split-1.c.151t.lsplit  patched/loop-cond-split-1.c.151t.lsplit:\n...\n   <bb 2> [local count: 118111600]:\n   if (n_7(D) > 0)\n     goto <bb 4>; [89.00%]\n   else\n     goto <bb 3>; [11.00%]\n\n   <bb 3> [local count: 118111600]:\n   return;\n\n   <bb 4> [local count: 105119324]:\n   pretmp_3 = ga;\n\n-  <bb 5> [local count: 955630225]:\n+  <bb 5> [local count: 315357973]:\n   # i_13 = PHI <i_10(20), 0(4)>\n   # prephitmp_12 = PHI <prephitmp_5(20), pretmp_3(4)>\n   if (prephitmp_12 != 0)\n     goto <bb 6>; [33.00%]\n   else\n     goto <bb 7>; [67.00%]\n\n   <bb 6> [local count: 315357972]:\n   _2 = do_something ();\n   ga = _2;\n\n-  <bb 7> [local count: 955630225]:\n+  <bb 7> [local count: 315357973]:\n   # prephitmp_5 = PHI <prephitmp_12(5), _2(6)>\n   i_10 = inc (i_13);\n   if (n_7(D) > i_10)\n     goto <bb 21>; [89.00%]\n   else\n     goto <bb 11>; [11.00%]\n\n   <bb 11> [local count: 105119324]:\n   goto <bb 3>; [100.00%]\n\n-  <bb 21> [local count: 850510901]:\n+  <bb 21> [local count: 280668596]:\n   if (prephitmp_12 != 0)\n-    goto <bb 20>; [100.00%]\n+    goto <bb 20>; [33.00%]\n   else\n-    goto <bb 19>; [INV]\n+    goto <bb 19>; [67.00%]\n\n-  <bb 20> [local count: 850510901]:\n+  <bb 20> [local count: 280668596]:\n   goto <bb 5>; [100.00%]\n\n-  <bb 19> [count: 0]:\n+  <bb 19> [local count: 70429947]:\n   # i_23 = PHI <i_10(21)>\n   # prephitmp_25 = PHI <prephitmp_5(21)>\n\n-  <bb 12> [local count: 955630225]:\n+  <bb 12> [local count: 640272252]:\n   # i_15 = PHI <i_23(19), i_22(16)>\n   # prephitmp_16 = PHI <prephitmp_25(19), prephitmp_16(16)>\n   i_22 = inc (i_15);\n   if (n_7(D) > i_22)\n     goto <bb 16>; [89.00%]\n   else\n     goto <bb 11>; [11.00%]\n\n-  <bb 16> [local count: 850510901]:\n+  <bb 16> [local count: 569842305]:\n   goto <bb 12>; [100.00%]\n\n }\n\ngcc/ChangeLog:\n\n2021-12-21  Xionghu Luo  <luoxhu@linux.ibm.com>\n\n\t* tree-ssa-loop-split.c (split_loop): Fix incorrect\n\tprofile_count and probability.\n\t(do_split_loop_on_cond): Likewise.", "tree": {"sha": "6c559bc8c1d3662ed00a5916f61b7edf2107cf0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c559bc8c1d3662ed00a5916f61b7edf2107cf0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd5ae148c47c6dee05adb19acd6a523f7187be7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd5ae148c47c6dee05adb19acd6a523f7187be7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd5ae148c47c6dee05adb19acd6a523f7187be7f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd5ae148c47c6dee05adb19acd6a523f7187be7f/comments", "author": {"login": "xionghul", "id": 4607154, "node_id": "MDQ6VXNlcjQ2MDcxNTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4607154?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xionghul", "html_url": "https://github.com/xionghul", "followers_url": "https://api.github.com/users/xionghul/followers", "following_url": "https://api.github.com/users/xionghul/following{/other_user}", "gists_url": "https://api.github.com/users/xionghul/gists{/gist_id}", "starred_url": "https://api.github.com/users/xionghul/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xionghul/subscriptions", "organizations_url": "https://api.github.com/users/xionghul/orgs", "repos_url": "https://api.github.com/users/xionghul/repos", "events_url": "https://api.github.com/users/xionghul/events{/privacy}", "received_events_url": "https://api.github.com/users/xionghul/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xionghul", "id": 4607154, "node_id": "MDQ6VXNlcjQ2MDcxNTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4607154?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xionghul", "html_url": "https://github.com/xionghul", "followers_url": "https://api.github.com/users/xionghul/followers", "following_url": "https://api.github.com/users/xionghul/following{/other_user}", "gists_url": "https://api.github.com/users/xionghul/gists{/gist_id}", "starred_url": "https://api.github.com/users/xionghul/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xionghul/subscriptions", "organizations_url": "https://api.github.com/users/xionghul/orgs", "repos_url": "https://api.github.com/users/xionghul/repos", "events_url": "https://api.github.com/users/xionghul/events{/privacy}", "received_events_url": "https://api.github.com/users/xionghul/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46bfe1b0e11c4797c5926e0754fae2848026376c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46bfe1b0e11c4797c5926e0754fae2848026376c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46bfe1b0e11c4797c5926e0754fae2848026376c"}], "stats": {"total": 85, "additions": 77, "deletions": 8}, "files": [{"sha": "33128061aaba3163f094bc0bc766fc4a1e2d6588", "filename": "gcc/tree-ssa-loop-split.c", "status": "modified", "additions": 77, "deletions": 8, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5ae148c47c6dee05adb19acd6a523f7187be7f/gcc%2Ftree-ssa-loop-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5ae148c47c6dee05adb19acd6a523f7187be7f/gcc%2Ftree-ssa-loop-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-split.c?ref=cd5ae148c47c6dee05adb19acd6a523f7187be7f", "patch": "@@ -575,19 +575,22 @@ split_loop (class loop *loop1)\n \t\t\t\t\t    stmts2);\n \ttree cond = build2 (guard_code, boolean_type_node, guard_init, border);\n \tif (!initial_true)\n-\t  cond = fold_build1 (TRUTH_NOT_EXPR, boolean_type_node, cond); \n+\t  cond = fold_build1 (TRUTH_NOT_EXPR, boolean_type_node, cond);\n+\n+\tedge true_edge, false_edge;\n+\textract_true_false_edges_from_block (bbs[i], &true_edge, &false_edge);\n \n \t/* Now version the loop, placing loop2 after loop1 connecting\n \t   them, and fix up SSA form for that.  */\n \tinitialize_original_copy_tables ();\n \tbasic_block cond_bb;\n \n \tclass loop *loop2 = loop_version (loop1, cond, &cond_bb,\n-\t\t\t\t\t   profile_probability::always (),\n-\t\t\t\t\t   profile_probability::always (),\n-\t\t\t\t\t   profile_probability::always (),\n-\t\t\t\t\t   profile_probability::always (),\n-\t\t\t\t\t   true);\n+\t\t\t\t\t  true_edge->probability,\n+\t\t\t\t\t  true_edge->probability.invert (),\n+\t\t\t\t\t  profile_probability::always (),\n+\t\t\t\t\t  profile_probability::always (),\n+\t\t\t\t\t  true);\n \tgcc_assert (loop2);\n \n \tedge new_e = connect_loops (loop1, loop2);\n@@ -607,6 +610,38 @@ split_loop (class loop *loop1)\n \ttree guard_next = PHI_ARG_DEF_FROM_EDGE (phi, loop_latch_edge (loop1));\n \tpatch_loop_exit (loop1, guard_stmt, guard_next, newend, initial_true);\n \n+\tupdate_ssa (TODO_update_ssa);\n+\n+\t/* Proportion first loop's bb counts except those dominated by true\n+\t   branch to avoid drop 1s down.  */\n+\tbasic_block *bbs1, *bbs2;\n+\tbbs1 = get_loop_body (loop1);\n+\tunsigned j;\n+\tfor (j = 0; j < loop1->num_nodes; j++)\n+\t  if (bbs1[j] == loop1->latch\n+\t      || !dominated_by_p (CDI_DOMINATORS, bbs1[j], true_edge->dest))\n+\t    bbs1[j]->count\n+\t      = bbs1[j]->count.apply_probability (true_edge->probability);\n+\tfree (bbs1);\n+\n+\t/* Fix first loop's exit probability after scaling.  */\n+\tedge exit_to_latch1 = single_pred_edge (loop1->latch);\n+\texit_to_latch1->probability = exit_to_latch1->probability.apply_scale (\n+\t  true_edge->probability.to_reg_br_prob_base (), REG_BR_PROB_BASE);\n+\tsingle_exit (loop1)->probability\n+\t  = exit_to_latch1->probability.invert ();\n+\n+\t/* Proportion second loop's bb counts except those dominated by false\n+\t   branch to avoid drop 1s down.  */\n+\tbasic_block bbi_copy = get_bb_copy (false_edge->dest);\n+\tbbs2 = get_loop_body (loop2);\n+\tfor (j = 0; j < loop2->num_nodes; j++)\n+\t  if (bbs2[j] == loop2->latch\n+\t      || !dominated_by_p (CDI_DOMINATORS, bbs2[j], bbi_copy))\n+\t    bbs2[j]->count = bbs2[j]->count.apply_probability (\n+\t      true_edge->probability.invert ());\n+\tfree (bbs2);\n+\n \t/* Finally patch out the two copies of the condition to be always\n \t   true/false (or opposite).  */\n \tgcond *force_true = as_a<gcond *> (last_stmt (bbs[i]));\n@@ -1486,8 +1521,8 @@ do_split_loop_on_cond (struct loop *loop1, edge invar_branch)\n   initialize_original_copy_tables ();\n \n   struct loop *loop2 = loop_version (loop1, boolean_true_node, NULL,\n-\t\t\t\t     profile_probability::always (),\n-\t\t\t\t     profile_probability::never (),\n+\t\t\t\t     invar_branch->probability.invert (),\n+\t\t\t\t     invar_branch->probability,\n \t\t\t\t     profile_probability::always (),\n \t\t\t\t     profile_probability::always (),\n \t\t\t\t     true);\n@@ -1535,6 +1570,40 @@ do_split_loop_on_cond (struct loop *loop1, edge invar_branch)\n      between loop1 and loop2.  */\n   connect_loop_phis (loop1, loop2, to_loop2);\n \n+  update_ssa (TODO_update_ssa);\n+\n+  edge true_edge, false_edge, skip_edge1, skip_edge2;\n+  extract_true_false_edges_from_block (cond_bb, &true_edge, &false_edge);\n+\n+  /* Proportion first loop's bb counts except those dominated by true\n+     branch to avoid drop 1s down.  */\n+  skip_edge1 = true_invar ? false_edge : true_edge;\n+  skip_edge2 = true_invar ? true_edge : false_edge;\n+  basic_block *bbs1, *bbs2;\n+  bbs1 = get_loop_body (loop1);\n+  unsigned j;\n+  for (j = 0; j < loop1->num_nodes; j++)\n+    if (bbs1[j] == loop1->latch\n+\t|| !dominated_by_p (CDI_DOMINATORS, bbs1[j], skip_edge1->dest))\n+      bbs1[j]->count\n+\t= bbs1[j]->count.apply_probability (skip_edge1->probability);\n+  free (bbs1);\n+\n+  /* Fix first loop's exit probability after scaling.  */\n+  to_loop1->probability = invar_branch->probability.invert ();\n+  to_loop2->probability = invar_branch->probability;\n+\n+  /* Proportion second loop's bb counts except those dominated by false\n+     branch to avoid drop 1s down.  */\n+  basic_block bbi_copy = get_bb_copy (skip_edge2->dest);\n+  bbs2 = get_loop_body (loop2);\n+  for (j = 0; j < loop2->num_nodes; j++)\n+    if (bbs2[j] == loop2->latch\n+\t|| !dominated_by_p (CDI_DOMINATORS, bbs2[j], bbi_copy))\n+      bbs2[j]->count\n+\t= bbs2[j]->count.apply_probability (skip_edge2->probability);\n+  free (bbs2);\n+\n   free_original_copy_tables ();\n \n   return true;"}]}