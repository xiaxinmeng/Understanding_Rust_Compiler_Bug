{"sha": "2d4a44001c6b62ef2ae2cc83d37856436588140a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQ0YTQ0MDAxYzZiNjJlZjJhZTJjYzgzZDM3ODU2NDM2NTg4MTQwYQ==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2012-08-14T16:35:09Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2012-08-14T16:35:09Z"}, "message": "trans-expr.c (gfc_trans_scalar_assign): Rename argument, extend comment.\n\nfortran/\n\t* trans-expr.c (gfc_trans_scalar_assign): Rename argument,\n\textend comment.\n\nFrom-SVN: r190392", "tree": {"sha": "8814c3d04fbb4dc85a6279b89cd40ac898a88497", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8814c3d04fbb4dc85a6279b89cd40ac898a88497"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d4a44001c6b62ef2ae2cc83d37856436588140a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d4a44001c6b62ef2ae2cc83d37856436588140a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d4a44001c6b62ef2ae2cc83d37856436588140a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d4a44001c6b62ef2ae2cc83d37856436588140a/comments", "author": null, "committer": null, "parents": [{"sha": "2a573572eb310e73c4a07d2c482b02442205ebf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a573572eb310e73c4a07d2c482b02442205ebf0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a573572eb310e73c4a07d2c482b02442205ebf0"}], "stats": {"total": 40, "additions": 34, "deletions": 6}, "files": [{"sha": "587a010318fbf0174f47f5d7f3464c5b7204f230", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d4a44001c6b62ef2ae2cc83d37856436588140a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d4a44001c6b62ef2ae2cc83d37856436588140a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=2d4a44001c6b62ef2ae2cc83d37856436588140a", "patch": "@@ -1,3 +1,8 @@\n+2012-08-14  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\t* trans-expr.c (gfc_trans_scalar_assign): Rename argument,\n+\textend comment.\n+\n 2012-08-14  Mikael Morin  <mikael@gcc.gnu.org>\n \n \t* gfortran.h (gfc_get_proc_ptr_comp): New prototype."}, {"sha": "53fdf45c400f69f4d338527a0b3509750d674496", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d4a44001c6b62ef2ae2cc83d37856436588140a/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d4a44001c6b62ef2ae2cc83d37856436588140a/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=2d4a44001c6b62ef2ae2cc83d37856436588140a", "patch": "@@ -6307,11 +6307,34 @@ gfc_conv_string_parameter (gfc_se * se)\n \n /* Generate code for assignment of scalar variables.  Includes character\n    strings and derived types with allocatable components.\n-   If you know that the LHS has no allocations, set dealloc to false.  */\n+   If you know that the LHS has no allocations, set dealloc to false.\n+\n+   DEEP_COPY has no effect if the typespec TS is not a derived type with\n+   allocatable components.  Otherwise, if it is set, an explicit copy of each\n+   allocatable component is made.  This is necessary as a simple copy of the\n+   whole object would copy array descriptors as is, so that the lhs's\n+   allocatable components would point to the rhs's after the assignment.\n+   Typically, setting DEEP_COPY is necessary if the rhs is a variable, and not\n+   necessary if the rhs is a non-pointer function, as the allocatable components\n+   are not accessible by other means than the function's result after the\n+   function has returned.  It is even more subtle when temporaries are involved,\n+   as the two following examples show:\n+    1.  When we evaluate an array constructor, a temporary is created.  Thus\n+      there is theoretically no alias possible.  However, no deep copy is\n+      made for this temporary, so that if the constructor is made of one or\n+      more variable with allocatable components, those components still point\n+      to the variable's: DEEP_COPY should be set for the assignment from the\n+      temporary to the lhs in that case.\n+    2.  When assigning a scalar to an array, we evaluate the scalar value out\n+      of the loop, store it into a temporary variable, and assign from that.\n+      In that case, deep copying when assigning to the temporary would be a\n+      waste of resources; however deep copies should happen when assigning from\n+      the temporary to each array element: again DEEP_COPY should be set for\n+      the assignment from the temporary to the lhs.  */\n \n tree\n gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n-\t\t\t bool l_is_temp, bool r_is_var, bool dealloc)\n+\t\t\t bool l_is_temp, bool deep_copy, bool dealloc)\n {\n   stmtblock_t block;\n   tree tmp;\n@@ -6345,9 +6368,9 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n   else if (ts.type == BT_DERIVED && ts.u.derived->attr.alloc_comp)\n     {\n       cond = NULL_TREE;\n-\t\n+\n       /* Are the rhs and the lhs the same?  */\n-      if (r_is_var)\n+      if (deep_copy)\n \t{\n \t  cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n \t\t\t\t  gfc_build_addr_expr (NULL_TREE, lse->expr),\n@@ -6363,7 +6386,7 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n \t{\n \t  tmp = gfc_evaluate_now (lse->expr, &lse->pre);\n \t  tmp = gfc_deallocate_alloc_comp (ts.u.derived, tmp, 0);\n-\t  if (r_is_var)\n+\t  if (deep_copy)\n \t    tmp = build3_v (COND_EXPR, cond, build_empty_stmt (input_location),\n \t\t\t    tmp);\n \t  gfc_add_expr_to_block (&lse->post, tmp);\n@@ -6377,7 +6400,7 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n \n       /* Do a deep copy if the rhs is a variable, if it is not the\n \t same as the lhs.  */\n-      if (r_is_var)\n+      if (deep_copy)\n \t{\n \t  tmp = gfc_copy_alloc_comp (ts.u.derived, rse->expr, lse->expr, 0);\n \t  tmp = build3_v (COND_EXPR, cond, build_empty_stmt (input_location),"}]}