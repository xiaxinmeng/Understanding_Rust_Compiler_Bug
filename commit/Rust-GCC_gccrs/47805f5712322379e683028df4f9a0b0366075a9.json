{"sha": "47805f5712322379e683028df4f9a0b0366075a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc4MDVmNTcxMjMyMjM3OWU2ODMwMjhkZjRmOWEwYjAzNjYwNzVhOQ==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2019-05-15T20:42:52Z"}, "committer": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2019-05-15T20:42:52Z"}, "message": "CWG 2096 - constraints on literal unions.\n\n\t* class.c (check_field_decls): Initialize booleans directly.  A union\n\tis literal if at least one of its non-static data members is of\n\tnon-volatile literal type.\n\n\t* g++.dg/cpp0x/literal-type1.C: New test.\n\nFrom-SVN: r271267", "tree": {"sha": "6628e2308268901e75cec16201608f6f252a44a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6628e2308268901e75cec16201608f6f252a44a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47805f5712322379e683028df4f9a0b0366075a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47805f5712322379e683028df4f9a0b0366075a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47805f5712322379e683028df4f9a0b0366075a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47805f5712322379e683028df4f9a0b0366075a9/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "193f241906489ee3154a69054c0e2e60e0d7d35b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/193f241906489ee3154a69054c0e2e60e0d7d35b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/193f241906489ee3154a69054c0e2e60e0d7d35b"}], "stats": {"total": 98, "additions": 88, "deletions": 10}, "files": [{"sha": "3119c0370df2aa2ce6651b0bcc7b8be21d3b2a85", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47805f5712322379e683028df4f9a0b0366075a9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47805f5712322379e683028df4f9a0b0366075a9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=47805f5712322379e683028df4f9a0b0366075a9", "patch": "@@ -1,3 +1,10 @@\n+2019-05-15  Marek Polacek  <polacek@redhat.com>\n+\n+\tCWG 2096 - constraints on literal unions.\n+\t* class.c (check_field_decls): Initialize booleans directly.  A union\n+\tis literal if at least one of its non-static data members is of\n+\tnon-volatile literal type.\n+\n 2019-05-15  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* cp-tree.h (REFERENCE_VLA_OK): Remove."}, {"sha": "ed885a5a2c18c9f828ddb5880ac81ed0745d3c5d", "filename": "gcc/cp/class.c", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47805f5712322379e683028df4f9a0b0366075a9/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47805f5712322379e683028df4f9a0b0366075a9/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=47805f5712322379e683028df4f9a0b0366075a9", "patch": "@@ -3403,18 +3403,19 @@ check_field_decls (tree t, tree *access_decls,\n {\n   tree *field;\n   tree *next;\n-  bool has_pointers;\n-  bool any_default_members;\n   int cant_pack = 0;\n   int field_access = -1;\n \n   /* Assume there are no access declarations.  */\n   *access_decls = NULL_TREE;\n   /* Assume this class has no pointer members.  */\n-  has_pointers = false;\n+  bool has_pointers = false;\n   /* Assume none of the members of this class have default\n      initializations.  */\n-  any_default_members = false;\n+  bool any_default_members = false;\n+  /* Assume none of the non-static data members are of non-volatile literal\n+     type.  */\n+  bool found_nv_literal_p = false;\n \n   for (field = &TYPE_FIELDS (t); *field; field = next)\n     {\n@@ -3498,13 +3499,19 @@ check_field_decls (tree t, tree *access_decls,\n       if (TREE_PRIVATE (x) || TREE_PROTECTED (x))\n \tCLASSTYPE_NON_AGGREGATE (t) = 1;\n \n-      /* If at least one non-static data member is non-literal, the whole\n-         class becomes non-literal.  Per Core/1453, volatile non-static\n-\t data members and base classes are also not allowed.\n+      /* If it is not a union and at least one non-static data member is\n+\t non-literal, the whole class becomes non-literal.  Per Core/1453,\n+\t volatile non-static data members and base classes are also not allowed.\n+\t If it is a union, we might set CLASSTYPE_LITERAL_P after we've seen all\n+\t members.\n \t Note: if the type is incomplete we will complain later on.  */\n-      if (COMPLETE_TYPE_P (type)\n-\t  && (!literal_type_p (type) || CP_TYPE_VOLATILE_P (type))) \n-        CLASSTYPE_LITERAL_P (t) = false;\n+      if (COMPLETE_TYPE_P (type))\n+\t{\n+\t  if (!literal_type_p (type) || CP_TYPE_VOLATILE_P (type))\n+\t    CLASSTYPE_LITERAL_P (t) = false;\n+\t  else\n+\t    found_nv_literal_p = true;\n+\t}\n \n       /* A standard-layout class is a class that:\n \t ...\n@@ -3677,6 +3684,11 @@ check_field_decls (tree t, tree *access_decls,\n \t\t   \"field %q#D with same name as class\", x);\n     }\n \n+  /* Per CWG 2096, a type is a literal type if it is a union, and at least\n+     one of its non-static data members is of non-volatile literal type.  */\n+  if (TREE_CODE (t) == UNION_TYPE && found_nv_literal_p)\n+    CLASSTYPE_LITERAL_P (t) = true;\n+\n   /* Effective C++ rule 11: if a class has dynamic memory held by pointers,\n      it should also define a copy constructor and an assignment operator to\n      implement the correct copy semantic (deep vs shallow, etc.). As it is"}, {"sha": "8eb8b253a78b4d1a22b730a4b1ed9768e8d1934d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47805f5712322379e683028df4f9a0b0366075a9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47805f5712322379e683028df4f9a0b0366075a9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=47805f5712322379e683028df4f9a0b0366075a9", "patch": "@@ -1,3 +1,8 @@\n+2019-05-15  Marek Polacek  <polacek@redhat.com>\n+\n+\tCWG 2096 - constraints on literal unions.\n+\t* g++.dg/cpp0x/literal-type1.C: New test.\n+\n 2019-05-15  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \tPR fortran/90461"}, {"sha": "7b5d4288923e58e38a22f09a59d61df995edcc5a", "filename": "gcc/testsuite/g++.dg/cpp0x/literal-type1.C", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47805f5712322379e683028df4f9a0b0366075a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fliteral-type1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47805f5712322379e683028df4f9a0b0366075a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fliteral-type1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fliteral-type1.C?ref=47805f5712322379e683028df4f9a0b0366075a9", "patch": "@@ -0,0 +1,54 @@\n+// CWG 2096 - constraints on literal unions.\n+// { dg-do compile { target c++11 } }\n+\n+struct literal { };\n+typedef volatile int nonliteral_v;\n+struct nonliteral {\n+  nonliteral() {}\n+};\n+\n+union U {\n+  literal l;\n+  nonliteral n;\n+\n+  constexpr U() : l{} {}\n+};\n+\n+constexpr U u{};\n+\n+union U2 {\n+  nonliteral n;\n+  literal l;\n+\n+  constexpr U2() : l{} {}\n+};\n+\n+constexpr U2 u2{};\n+\n+union U3 { // { dg-message \"not literal\" }\n+  nonliteral_v n; // { dg-message \"volatile type\" }\n+\n+  constexpr U3() : n{} {}\n+};\n+\n+constexpr U3 u3{}; // { dg-error \"not literal\" }\n+\n+union U4 {\n+  nonliteral n;\n+  nonliteral_v n2;\n+  literal l;\n+  nonliteral n3;\n+\n+  constexpr U4() : l{} {}\n+};\n+\n+constexpr U4 u4{};\n+\n+union U5 {\n+  nonliteral_v n;\n+  literal l;\n+\n+  constexpr U5() : n{} {}\n+};\n+\n+constexpr U5 u5{};"}]}