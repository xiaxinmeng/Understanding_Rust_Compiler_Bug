{"sha": "03bf1c28ac17199533dcab43432f1f0532ecfaaa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNiZjFjMjhhYzE3MTk5NTMzZGNhYjQzNDMyZjFmMDUzMmVjZmFhYQ==", "commit": {"author": {"name": "Mumit Khan", "email": "khan@xraylith.wisc.edu", "date": "2000-04-24T23:35:43Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-04-24T23:35:43Z"}, "message": "gcc.c (lookup_compiler): Make multiple passes for case insensitive filesystems.\n\n        * gcc.c (lookup_compiler): Make multiple passes for case\n        insensitive filesystems.\n\nFrom-SVN: r33393", "tree": {"sha": "5a4d401e9dfc167c6adf9a332aa403de4614e5b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a4d401e9dfc167c6adf9a332aa403de4614e5b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03bf1c28ac17199533dcab43432f1f0532ecfaaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03bf1c28ac17199533dcab43432f1f0532ecfaaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03bf1c28ac17199533dcab43432f1f0532ecfaaa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03bf1c28ac17199533dcab43432f1f0532ecfaaa/comments", "author": null, "committer": null, "parents": [{"sha": "dfb99c83a6df65e2cd23f2f48a5be88ee90803d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfb99c83a6df65e2cd23f2f48a5be88ee90803d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfb99c83a6df65e2cd23f2f48a5be88ee90803d4"}], "stats": {"total": 74, "additions": 47, "deletions": 27}, "files": [{"sha": "71ebba4948a0829b1dfbeaa604dba9b36acfaef3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03bf1c28ac17199533dcab43432f1f0532ecfaaa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03bf1c28ac17199533dcab43432f1f0532ecfaaa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=03bf1c28ac17199533dcab43432f1f0532ecfaaa", "patch": "@@ -1,3 +1,8 @@\n+Mon Apr 24 17:34:18 2000  Mumit Khan  <khan@xraylith.wisc.edu>\n+\n+\t* gcc.c (lookup_compiler): Make multiple passes for case\n+\tinsensitive filesystems.\n+\n 2000-04-24  Neil Booth  <NeilB@earthling.net>\n \n \t* cpphash.c: replace HSPACE_BEFORE with PREV_WHITESPACE."}, {"sha": "d8dd56377291257b71c02356f64a39a5762fd3d2", "filename": "gcc/gcc.c", "status": "modified", "additions": 42, "deletions": 27, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03bf1c28ac17199533dcab43432f1f0532ecfaaa/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03bf1c28ac17199533dcab43432f1f0532ecfaaa/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=03bf1c28ac17199533dcab43432f1f0532ecfaaa", "patch": "@@ -5638,38 +5638,53 @@ lookup_compiler (name, length, language)\n \t  (!strcmp (cp->suffix, \"-\") && !strcmp (name, \"-\"))\n \t  || (strlen (cp->suffix) < length\n \t      /* See if the suffix matches the end of NAME.  */\n-#ifdef OS2\n-\t      && ((!strcmp (cp->suffix,\n-\t\t\t   name + length - strlen (cp->suffix))\n-\t\t   || !strpbrk (cp->suffix, \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"))\n-\t\t  && !strcasecmp (cp->suffix,\n-\t\t\t\t  name + length - strlen (cp->suffix)))\n-#else\n \t      && !strcmp (cp->suffix,\n \t\t\t  name + length - strlen (cp->suffix))\n-#endif\n \t ))\n-\t{\n-\t  if (cp->spec[0][0] == '@')\n-\t    {\n-\t      struct compiler *new;\n-\n-\t      /* An alias entry maps a suffix to a language.\n-\t\t Search for the language; pass 0 for NAME and LENGTH\n-\t\t to avoid infinite recursion if language not found.\n-\t\t Construct the new compiler spec.  */\n-\t      language = cp->spec[0] + 1;\n-\t      new = (struct compiler *) xmalloc (sizeof (struct compiler));\n-\t      new->suffix = cp->suffix;\n-\t      memcpy (new->spec,\n-\t\t      lookup_compiler (NULL_PTR, 0, language)->spec,\n-\t\t      sizeof new->spec);\n-\t      return new;\n-\t    }\n+        break;\n+    }\n \n-\t  /* A non-alias entry: return it.  */\n-\t  return cp;\n+#if defined (OS2) ||defined (HAVE_DOS_BASED_FILE_SYSTEM)\n+  /* look again, but case-insensitively this time.  */\n+  if (cp < compilers)\n+    for (cp = compilers + n_compilers - 1; cp >= compilers; cp--)\n+      {\n+\tif (/* The suffix `-' matches only the file name `-'.  */\n+\t    (!strcmp (cp->suffix, \"-\") && !strcmp (name, \"-\"))\n+\t    || (strlen (cp->suffix) < length\n+\t\t/* See if the suffix matches the end of NAME.  */\n+\t\t&& ((!strcmp (cp->suffix,\n+\t\t\t     name + length - strlen (cp->suffix))\n+\t\t     || !strpbrk (cp->suffix, \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"))\n+\t\t    && !strcasecmp (cp->suffix,\n+\t\t\t\t    name + length - strlen (cp->suffix)))\n+\t   ))\n+\t  break;\n+      }\n+#endif\n+\n+\n+  if (cp >= compilers)\n+    {\n+      if (cp->spec[0][0] == '@')\n+\t{\n+\t  struct compiler *new;\n+\n+\t  /* An alias entry maps a suffix to a language.\n+\t     Search for the language; pass 0 for NAME and LENGTH\n+\t     to avoid infinite recursion if language not found.\n+\t     Construct the new compiler spec.  */\n+\t  language = cp->spec[0] + 1;\n+\t  new = (struct compiler *) xmalloc (sizeof (struct compiler));\n+\t  new->suffix = cp->suffix;\n+\t  memcpy (new->spec,\n+\t\t  lookup_compiler (NULL_PTR, 0, language)->spec,\n+\t\t  sizeof new->spec);\n+\t  return new;\n \t}\n+\n+      /* A non-alias entry: return it.  */\n+      return cp;\n     }\n \n   return 0;"}]}