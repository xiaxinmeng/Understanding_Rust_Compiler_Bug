{"sha": "dd3f0101652432c1da354268600ccde52d834256", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQzZjAxMDE2NTI0MzJjMWRhMzU0MjY4NjAwY2NkZTUyZDgzNDI1Ng==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-05-17T18:07:01Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-05-17T18:07:01Z"}, "message": "final.c: Fix formatting.\n\n\t* final.c: Fix formatting.\n\t* fix-header.c: Likewise.\n\t* flow.c: Likewise.\n\t* fold-const.c: Likewise.\n\t* function.c: Likewise.\n\nFrom-SVN: r53563", "tree": {"sha": "ac2f99f989f1e0a7e29071f30fbda71a9b47deb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac2f99f989f1e0a7e29071f30fbda71a9b47deb7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd3f0101652432c1da354268600ccde52d834256", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd3f0101652432c1da354268600ccde52d834256", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd3f0101652432c1da354268600ccde52d834256", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd3f0101652432c1da354268600ccde52d834256/comments", "author": null, "committer": null, "parents": [{"sha": "5ca9299f10baafa4f376871390638fd5dcf42cde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ca9299f10baafa4f376871390638fd5dcf42cde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ca9299f10baafa4f376871390638fd5dcf42cde"}], "stats": {"total": 214, "additions": 111, "deletions": 103}, "files": [{"sha": "13d793746b66d1ce4ca7b1428641cace74b708de", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd3f0101652432c1da354268600ccde52d834256/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd3f0101652432c1da354268600ccde52d834256/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dd3f0101652432c1da354268600ccde52d834256", "patch": "@@ -1,3 +1,11 @@\n+2002-05-17  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* final.c: Fix formatting.\n+\t* fix-header.c: Likewise.\n+\t* flow.c: Likewise.\n+\t* fold-const.c: Likewise.\n+\t* function.c: Likewise.\n+\n 2002-05-17  David S. Miller  <davem@redhat.com>\n \n \tPR c/6689, PR optimization/6615"}, {"sha": "2eeeb8c39a8c87cb4f0de84d0f4965b89e9643ef", "filename": "gcc/final.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd3f0101652432c1da354268600ccde52d834256/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd3f0101652432c1da354268600ccde52d834256/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=dd3f0101652432c1da354268600ccde52d834256", "patch": "@@ -502,7 +502,7 @@ end_final (filename)\n       ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 0);\n       DECL_NAME (structure_value) = get_identifier (name);\n \n-      /* Size of this structure. */\n+      /* Size of this structure.  */\n       TREE_VALUE (sizeof_field_value)\n \t= convert (long_integer_type_node,\n \t\t   build_int_2 (int_size_in_bytes (structure_decl), 0));\n@@ -668,7 +668,7 @@ get_attr_length (insn)\n \n       case JUMP_INSN:\n \tbody = PATTERN (insn);\n-        if (GET_CODE (body) == ADDR_VEC || GET_CODE (body) == ADDR_DIFF_VEC)\n+\tif (GET_CODE (body) == ADDR_VEC || GET_CODE (body) == ADDR_DIFF_VEC)\n \t  {\n \t    /* Alignment is machine-dependent and should be handled by\n \t       ADDR_VEC_ALIGN.  */\n@@ -1521,7 +1521,7 @@ shorten_branches (first)\n \n \t\t      insn_current_address += insn_lengths[inner_uid];\n \t\t    }\n-                }\n+\t\t}\n \t      else\n \t\tinsn_current_address += insn_lengths[uid];\n \n@@ -1937,7 +1937,7 @@ final (first, file, optimize, prescan)\n       new_item->cfg_checksum = profile_info.current_function_cfg_checksum;\n       new_item->count_edges = profile_info.count_edges_instrumented_now;\n     }\n-  \n+\n   free (line_note_exists);\n   line_note_exists = NULL;\n }\n@@ -2696,13 +2696,13 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \tinsn_code_number = recog_memoized (insn);\n \tcleanup_subreg_operands (insn);\n \n-       /* Dump the insn in the assembly for debugging.  */\n-       if (flag_dump_rtl_in_asm)\n-         {\n-           print_rtx_head = ASM_COMMENT_START;\n-           print_rtl_single (asm_out_file, insn);\n-           print_rtx_head = \"\";\n-         }\n+\t/* Dump the insn in the assembly for debugging.  */\n+\tif (flag_dump_rtl_in_asm)\n+\t  {\n+\t    print_rtx_head = ASM_COMMENT_START;\n+\t    print_rtl_single (asm_out_file, insn);\n+\t    print_rtx_head = \"\";\n+\t  }\n \n \tif (! constrain_operands_cached (1))\n \t  fatal_insn_not_found (insn);\n@@ -3127,7 +3127,7 @@ output_operand_lossage VPARAMS ((const char *msgid, ...))\n   pfx_str = this_is_asm_operands ? _(\"invalid `asm': \") : \"output_operand: \";\n   asprintf (&fmt_string, \"%s%s\", pfx_str, _(msgid));\n   vasprintf (&new_message, fmt_string, ap);\n-  \n+\n   if (this_is_asm_operands)\n     error_for_asm (this_is_asm_operands, \"%s\", new_message);\n   else"}, {"sha": "ba4ba6a6dee569eb5ec6de6d9687943cb0509054", "filename": "gcc/fix-header.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd3f0101652432c1da354268600ccde52d834256/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd3f0101652432c1da354268600ccde52d834256/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=dd3f0101652432c1da354268600ccde52d834256", "patch": "@@ -411,10 +411,10 @@ int lbrac_line, rbrac_line;\n int required_unseen_count = 0;\n int required_other = 0;\n \n-static void \n+static void\n write_lbrac ()\n {\n-  \n+\n #if ADD_MISSING_EXTERN_C\n   if (missing_extern_C_count + required_unseen_count > 0)\n     fprintf (outf, \"#ifdef __cplusplus\\nextern \\\"C\\\" {\\n#endif\\n\");\n@@ -546,7 +546,7 @@ recognized_function (fname, line, kind, have_arg_list)\n   /* If we have a full prototype, we're done.  */\n   if (have_arg_list)\n     return;\n-      \n+\n   if (kind == 'I')  /* don't edit inline function */\n     return;\n \n@@ -619,7 +619,7 @@ read_scan_file (in_fname, argc, argv)\n   int i;\n   struct symbol_list *cur_symbols;\n \n-  obstack_init (&scan_file_obstack); \n+  obstack_init (&scan_file_obstack);\n \n   scan_in = cpp_create_reader (CLK_GNUC89);\n   cb = cpp_get_callbacks (scan_in);\n@@ -701,7 +701,7 @@ read_scan_file (in_fname, argc, argv)\n   if (required_unseen_count + partial_count + required_other\n #if ADD_MISSING_EXTERN_C\n       + missing_extern_C_count\n-#endif      \n+#endif\n       == 0)\n     {\n       if (verbose)\n@@ -1084,8 +1084,8 @@ main (argc, argv)\n \n       progname = 0;\n       for (p = argv[0]; *p; p++)\n-        if (*p == '/')\n-          progname = p;\n+\tif (*p == '/')\n+\t  progname = p;\n       progname = progname ? progname+1 : argv[0];\n     }\n \n@@ -1114,7 +1114,7 @@ main (argc, argv)\n \t      exit (SUCCESS_EXIT_CODE);\n \t    }\n \t}\n-\t  \n+\n     }\n #endif\n \n@@ -1148,7 +1148,7 @@ main (argc, argv)\n   else\n     symbol_table[0].names = NULL;\n \n-  /* Count and mark the prototypes required for this include file.  */ \n+  /* Count and mark the prototypes required for this include file.  */\n   for (cur_symbols = &symbol_table[0]; cur_symbols->names; cur_symbols++)\n     {\n       int name_len;\n@@ -1313,7 +1313,7 @@ v_fatal (str, ap)\n   fprintf (stderr, \"%s: %s: \", progname, inc_filename);\n   vfprintf (stderr, str, ap);\n   fprintf (stderr, \"\\n\");\n-  \n+\n   exit (FATAL_EXIT_CODE);\n }\n "}, {"sha": "31017fb28eb68a16675d49ab668abc42c56c904a", "filename": "gcc/flow.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd3f0101652432c1da354268600ccde52d834256/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd3f0101652432c1da354268600ccde52d834256/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=dd3f0101652432c1da354268600ccde52d834256", "patch": "@@ -592,7 +592,7 @@ verify_local_live_at_start (new_live_at_start, bb)\n \n       EXECUTE_IF_SET_IN_REG_SET (new_live_at_start, 0, i,\n \t{\n-          /* No registers should die.  */\n+\t  /* No registers should die.  */\n \t  if (REGNO_REG_SET_P (bb->global_live_at_start, i))\n \t    {\n \t      if (rtl_dump_file)\n@@ -604,7 +604,7 @@ verify_local_live_at_start (new_live_at_start, bb)\n \t      abort ();\n \t    }\n \n-          /* Verify that the now-live register is wider than word_mode.  */\n+\t  /* Verify that the now-live register is wider than word_mode.  */\n \t  verify_wide_reg (i, bb);\n \t});\n     }\n@@ -989,7 +989,7 @@ mark_regs_live_at_end (set)\n #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n       /* If they are different, also mark the hard frame pointer as live.  */\n       if (! LOCAL_REGNO (HARD_FRAME_POINTER_REGNUM))\n-        SET_REGNO_REG_SET (set, HARD_FRAME_POINTER_REGNUM);\n+\tSET_REGNO_REG_SET (set, HARD_FRAME_POINTER_REGNUM);\n #endif\n     }\n \n@@ -1749,7 +1749,7 @@ propagate_one_insn (pbi, insn)\n \t      free_EXPR_LIST_list (&pbi->mem_set_list);\n \t      pbi->mem_set_list_len = 0;\n \t    }\n-          else\n+\t  else\n \t    invalidate_mems_from_set (pbi, stack_pointer_rtx);\n \n \t  /* There may be extra registers to be clobbered.  */\n@@ -2660,7 +2660,7 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n       if (GET_CODE (reg) == MEM && ! side_effects_p (reg)\n \t  /* ??? With more effort we could track conditional memory life.  */\n \t  && ! cond)\n-        add_to_mem_set_list (pbi, canon_rtx (reg));\n+\tadd_to_mem_set_list (pbi, canon_rtx (reg));\n     }\n \n   if (GET_CODE (reg) == REG\n@@ -3791,7 +3791,7 @@ mark_used_regs (pbi, x, cond, insn)\n \n #ifdef AUTO_INC_DEC\n       if (flags & PROP_AUTOINC)\n-        find_auto_inc (pbi, x, insn);\n+\tfind_auto_inc (pbi, x, insn);\n #endif\n       break;\n "}, {"sha": "686fd41ce0021dbd8c8798d369e92b8592b40a18", "filename": "gcc/fold-const.c", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd3f0101652432c1da354268600ccde52d834256/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd3f0101652432c1da354268600ccde52d834256/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=dd3f0101652432c1da354268600ccde52d834256", "patch": "@@ -103,10 +103,10 @@ static tree strip_compound_expr PARAMS ((tree, tree));\n static int multiple_of_p\tPARAMS ((tree, tree, tree));\n static tree constant_boolean_node PARAMS ((int, tree));\n static int count_cond\t\tPARAMS ((tree, int));\n-static tree fold_binary_op_with_conditional_arg \n+static tree fold_binary_op_with_conditional_arg\n   PARAMS ((enum tree_code, tree, tree, tree, int));\n static bool fold_real_zero_addition_p\tPARAMS ((tree, tree, int));\n-\t\t\t\t\t\t\t \n+\n #if defined(HOST_EBCDIC)\n /* bit 8 is significant in EBCDIC */\n #define CHARMASK 0xff\n@@ -413,7 +413,7 @@ lshift_double (l1, h1, count, prec, lv, hv, arith)\n \n   signmask = -((prec > HOST_BITS_PER_WIDE_INT\n \t\t? ((unsigned HOST_WIDE_INT) *hv\n-                   >> (prec - HOST_BITS_PER_WIDE_INT - 1))\n+\t\t   >> (prec - HOST_BITS_PER_WIDE_INT - 1))\n \t\t: (*lv >> (prec - 1))) & 1);\n \n   if (prec >= 2 * HOST_BITS_PER_WIDE_INT)\n@@ -2189,7 +2189,7 @@ invert_truthvalue (arg)\n     {\n       if (FLOAT_TYPE_P (TREE_TYPE (TREE_OPERAND (arg, 0)))\n \t  && !flag_unsafe_math_optimizations\n-\t  && code != NE_EXPR \n+\t  && code != NE_EXPR\n \t  && code != EQ_EXPR)\n \treturn build1 (TRUTH_NOT_EXPR, type, arg);\n       else\n@@ -3112,11 +3112,11 @@ build_range_check (type, exp, in_p, low, high)\n   if (integer_zerop (low))\n     {\n       if (! TREE_UNSIGNED (etype))\n-        {\n-          etype = (*lang_hooks.types.unsigned_type) (etype);\n-          high = convert (etype, high);\n-          exp = convert (etype, exp);\n-        }\n+\t{\n+\t  etype = (*lang_hooks.types.unsigned_type) (etype);\n+\t  high = convert (etype, high);\n+\t  exp = convert (etype, exp);\n+\t}\n       return build_range_check (type, exp, 1, 0, high);\n     }\n \n@@ -3129,26 +3129,26 @@ build_range_check (type, exp, in_p, low, high)\n \n       prec = TYPE_PRECISION (etype);\n       if (prec <= HOST_BITS_PER_WIDE_INT)\n-        {\n-          hi = 0;\n-          lo = ((unsigned HOST_WIDE_INT) 1 << (prec - 1)) - 1;\n-        }\n+\t{\n+\t  hi = 0;\n+\t  lo = ((unsigned HOST_WIDE_INT) 1 << (prec - 1)) - 1;\n+\t}\n       else\n-        {\n-          hi = ((HOST_WIDE_INT) 1 << (prec - HOST_BITS_PER_WIDE_INT - 1)) - 1;\n-          lo = (unsigned HOST_WIDE_INT) -1;\n-        }\n+\t{\n+\t  hi = ((HOST_WIDE_INT) 1 << (prec - HOST_BITS_PER_WIDE_INT - 1)) - 1;\n+\t  lo = (unsigned HOST_WIDE_INT) -1;\n+\t}\n \n       if (TREE_INT_CST_HIGH (high) == hi && TREE_INT_CST_LOW (high) == lo)\n-        {\n-          if (TREE_UNSIGNED (etype))\n-            {\n-              etype = (*lang_hooks.types.signed_type) (etype);\n-              exp = convert (etype, exp);\n-            }\n-          return fold (build (GT_EXPR, type, exp,\n-                              convert (etype, integer_zero_node)));\n-        }\n+\t{\n+\t  if (TREE_UNSIGNED (etype))\n+\t    {\n+\t      etype = (*lang_hooks.types.signed_type) (etype);\n+\t      exp = convert (etype, exp);\n+\t    }\n+\t  return fold (build (GT_EXPR, type, exp,\n+\t\t\t      convert (etype, integer_zero_node)));\n+\t}\n     }\n \n   if (0 != (value = const_binop (MINUS_EXPR, high, low, 0))\n@@ -3954,7 +3954,7 @@ extract_muldiv (t, c, code, wide_type)\n \t  && ! (TREE_CODE (TREE_TYPE (op0)) == INTEGER_TYPE\n \t\t&& TYPE_IS_SIZETYPE (TREE_TYPE (op0)))\n \t  && (GET_MODE_SIZE (TYPE_MODE (ctype))\n-              > GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (op0)))))\n+\t      > GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (op0)))))\n \tbreak;\n \n       /* Pass the constant down and see if we can make a simplification.  If\n@@ -4074,13 +4074,13 @@ extract_muldiv (t, c, code, wide_type)\n          of our constant, do the operation and verify it doesn't overflow.  */\n       if (code == MULT_EXPR\n \t  || integer_zerop (const_binop (TRUNC_MOD_EXPR, op1, c, 0)))\n-        {\n-          op1 = const_binop (code, convert (ctype, op1), convert (ctype, c), 0);\n-          if (op1 == 0 || TREE_OVERFLOW (op1))\n-            break;\n-        }\n+\t{\n+\t  op1 = const_binop (code, convert (ctype, op1), convert (ctype, c), 0);\n+\t  if (op1 == 0 || TREE_OVERFLOW (op1))\n+\t    break;\n+\t}\n       else\n-        break;\n+\tbreak;\n \n       /* If we have an unsigned type is not a sizetype, we cannot widen\n \t the operation since it will change the result if the original\n@@ -4336,7 +4336,7 @@ fold_binary_op_with_conditional_arg (code, type, cond, arg, cond_first_p)\n       true_value = convert (testtype, integer_one_node);\n       false_value = convert (testtype, integer_zero_node);\n     }\n-  \n+\n   /* If ARG is complex we want to make sure we only evaluate\n      it once.  Though this is only required if it is volatile, it\n      might be more efficient even if it is not.  However, if we\n@@ -4345,12 +4345,12 @@ fold_binary_op_with_conditional_arg (code, type, cond, arg, cond_first_p)\n      primarily to see if we do end up with constant and this\n      SAVE_EXPR interferes with later optimizations, suppressing\n      it when we can is important.\n-     \n+\n      If we are not in a function, we can't make a SAVE_EXPR, so don't\n      try to do so.  Don't try to see if the result is a constant\n      if an arm is a COND_EXPR since we get exponential behavior\n      in that case.  */\n-  \n+\n   if (TREE_CODE (arg) != SAVE_EXPR && ! TREE_CONSTANT (arg)\n       && (*lang_hooks.decls.global_bindings_p) () == 0\n       && ((TREE_CODE (arg) != VAR_DECL\n@@ -4359,22 +4359,22 @@ fold_binary_op_with_conditional_arg (code, type, cond, arg, cond_first_p)\n     {\n       if (TREE_CODE (true_value) != COND_EXPR)\n \tlhs = fold (build (lhs_code, lhs_type, *true_lhs, *true_rhs));\n-      \n+\n       if (TREE_CODE (false_value) != COND_EXPR)\n \trhs = fold (build (rhs_code, rhs_type, *false_lhs, *false_rhs));\n-      \n+\n       if ((lhs == 0 || ! TREE_CONSTANT (lhs))\n \t  && (rhs == 0 || !TREE_CONSTANT (rhs)))\n \targ = save_expr (arg), lhs = rhs = 0;\n     }\n-  \n+\n   if (lhs == 0)\n     lhs = fold (build (lhs_code, lhs_type, *true_lhs, *true_rhs));\n   if (rhs == 0)\n     rhs = fold (build (rhs_code, rhs_type, *false_lhs, *false_rhs));\n-  \n+\n   test = fold (build (COND_EXPR, type, test, lhs, rhs));\n-  \n+\n   if (TREE_CODE (arg) == SAVE_EXPR)\n     return build (COMPOUND_EXPR, type,\n \t\t  convert (void_type_node, arg),\n@@ -4636,7 +4636,7 @@ fold (expr)\n \t       && (! TREE_SIDE_EFFECTS (arg0)\n \t\t   || ((*lang_hooks.decls.global_bindings_p) () == 0\n \t\t       && ! contains_placeholder_p (arg0))))\n-\treturn \n+\treturn\n \t  fold_binary_op_with_conditional_arg (code, type, arg1, arg0,\n \t\t\t\t\t       /*cond_first_p=*/0);\n       else if (TREE_CODE (arg0) == COMPOUND_EXPR)\n@@ -4650,7 +4650,7 @@ fold (expr)\n \t       && (! TREE_SIDE_EFFECTS (arg1)\n \t\t   || ((*lang_hooks.decls.global_bindings_p) () == 0\n \t\t       && ! contains_placeholder_p (arg1))))\n-\treturn \n+\treturn\n \t  fold_binary_op_with_conditional_arg (code, type, arg0, arg1,\n \t\t\t\t\t       /*cond_first_p=*/1);\n     }\n@@ -6044,31 +6044,31 @@ fold (expr)\n \t\t\t      convert (st1, integer_zero_node)));\n \t\t  }\n \t      }\n-            else if (TREE_INT_CST_HIGH (arg1) == 0\n+\t    else if (TREE_INT_CST_HIGH (arg1) == 0\n \t\t     && (TREE_INT_CST_LOW (arg1)\n \t\t\t == ((unsigned HOST_WIDE_INT) 2 << (width - 1)) - 1)\n \t\t     && TREE_UNSIGNED (TREE_TYPE (arg1)))\n-              switch (TREE_CODE (t))\n-                {\n-                case GT_EXPR:\n-                  return omit_one_operand (type,\n-                                           convert (type, integer_zero_node),\n-                                           arg0);\n-                case GE_EXPR:\n-                  TREE_SET_CODE (t, EQ_EXPR);\n-                  break;\n-\n-                case LE_EXPR:\n-                  return omit_one_operand (type,\n-                                           convert (type, integer_one_node),\n-                                           arg0);\n-                case LT_EXPR:\n-                  TREE_SET_CODE (t, NE_EXPR);\n-                  break;\n-\n-                default:\n-                  break;\n-                }\n+\t      switch (TREE_CODE (t))\n+\t\t{\n+\t\tcase GT_EXPR:\n+\t\t  return omit_one_operand (type,\n+\t\t\t\t\t   convert (type, integer_zero_node),\n+\t\t\t\t\t   arg0);\n+\t\tcase GE_EXPR:\n+\t\t  TREE_SET_CODE (t, EQ_EXPR);\n+\t\t  break;\n+\n+\t\tcase LE_EXPR:\n+\t\t  return omit_one_operand (type,\n+\t\t\t\t\t   convert (type, integer_one_node),\n+\t\t\t\t\t   arg0);\n+\t\tcase LT_EXPR:\n+\t\t  TREE_SET_CODE (t, NE_EXPR);\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  break;\n+\t\t}\n \t  }\n       }\n \n@@ -6472,7 +6472,7 @@ fold (expr)\n \t}\n \n       /* Optimize comparisons of strlen vs zero to a compare of the\n-\t first character of the string vs zero.  To wit, \n+\t first character of the string vs zero.  To wit,\n \t \tstrlen(ptr) == 0   =>  *ptr == 0\n \t\tstrlen(ptr) != 0   =>  *ptr != 0\n \t Other cases should reduce to one of these two (or a constant)\n@@ -7123,7 +7123,7 @@ tree_expr_nonnegative_p (t)\n     case FLOOR_DIV_EXPR:\n     case ROUND_DIV_EXPR:\n       return tree_expr_nonnegative_p (TREE_OPERAND (t, 0))\n-        && tree_expr_nonnegative_p (TREE_OPERAND (t, 1));\n+\t&& tree_expr_nonnegative_p (TREE_OPERAND (t, 1));\n     case TRUNC_MOD_EXPR:\n     case CEIL_MOD_EXPR:\n     case FLOOR_MOD_EXPR:\n@@ -7136,10 +7136,10 @@ tree_expr_nonnegative_p (t)\n       return tree_expr_nonnegative_p (TREE_OPERAND (t, 1));\n     case MIN_EXPR:\n       return tree_expr_nonnegative_p (TREE_OPERAND (t, 0))\n-        && tree_expr_nonnegative_p (TREE_OPERAND (t, 1));\n+\t&& tree_expr_nonnegative_p (TREE_OPERAND (t, 1));\n     case MAX_EXPR:\n       return tree_expr_nonnegative_p (TREE_OPERAND (t, 0))\n-        || tree_expr_nonnegative_p (TREE_OPERAND (t, 1));\n+\t|| tree_expr_nonnegative_p (TREE_OPERAND (t, 1));\n     case MODIFY_EXPR:\n       return tree_expr_nonnegative_p (TREE_OPERAND (t, 1));\n     case BIND_EXPR:\n@@ -7150,7 +7150,7 @@ tree_expr_nonnegative_p (t)\n       return tree_expr_nonnegative_p (TREE_OPERAND (t, 0));\n     case RTL_EXPR:\n       return rtl_expr_nonnegative_p (RTL_EXPR_RTL (t));\n-      \n+\n     default:\n       if (truth_value_p (TREE_CODE (t)))\n \t/* Truth values evaluate to 0 or 1, which is nonnegative.  */"}, {"sha": "9a944139ab5d77a862d0daff0e85eb91c1cccf9e", "filename": "gcc/function.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd3f0101652432c1da354268600ccde52d834256/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd3f0101652432c1da354268600ccde52d834256/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=dd3f0101652432c1da354268600ccde52d834256", "patch": "@@ -4609,8 +4609,8 @@ assign_parms (fndecl)\n \t to indicate there is no preallocated stack slot for the parm.  */\n \n       if (entry_parm == stack_parm\n-          || (GET_CODE (entry_parm) == PARALLEL\n-              && XEXP (XVECEXP (entry_parm, 0, 0), 0) == NULL_RTX)\n+\t  || (GET_CODE (entry_parm) == PARALLEL\n+\t      && XEXP (XVECEXP (entry_parm, 0, 0), 0) == NULL_RTX)\n #if defined (REG_PARM_STACK_SPACE) && ! defined (MAYBE_REG_PARM_STACK_SPACE)\n \t  /* On some machines, even if a parm value arrives in a register\n \t     there is still an (uninitialized) stack slot allocated for it.\n@@ -5410,8 +5410,8 @@ pad_to_arg_alignment (offset_ptr, boundary, alignment_pad)\n \t      (ARGS_SIZE_TREE (*offset_ptr),\n \t       boundary / BITS_PER_UNIT);\n \t  offset_ptr->constant = 0; /*?*/\n-          if (boundary > PARM_BOUNDARY && boundary > STACK_BOUNDARY)\n-            alignment_pad->var = size_binop (MINUS_EXPR, offset_ptr->var,\n+\t  if (boundary > PARM_BOUNDARY && boundary > STACK_BOUNDARY)\n+\t    alignment_pad->var = size_binop (MINUS_EXPR, offset_ptr->var,\n \t\t\t\t\t     save_var);\n \t}\n       else\n@@ -5471,7 +5471,7 @@ uninitialized_vars_warning (block)\n   for (decl = BLOCK_VARS (block); decl; decl = TREE_CHAIN (decl))\n     {\n       if (warn_uninitialized\n-          && TREE_CODE (decl) == VAR_DECL\n+\t  && TREE_CODE (decl) == VAR_DECL\n \t  /* These warnings are unreliable for and aggregates\n \t     because assigning the fields one by one can fail to convince\n \t     flow.c that the entire aggregate was initialized."}]}