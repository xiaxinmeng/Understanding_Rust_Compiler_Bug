{"sha": "44e91694bda9e891e1eeac71bd5cda66d6acce25", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDRlOTE2OTRiZGE5ZTg5MWUxZWVhYzcxYmQ1Y2RhNjZkNmFjY2UyNQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-05-08T09:40:45Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-05-08T09:40:45Z"}, "message": "frv.c (frv_default_flags_for_cpu): Use gcc_assert and gcc_unreachable, as appropriate.\n\n\t* config/frv/frv.c (frv_default_flags_for_cpu): Use gcc_assert and\n\tgcc_unreachable, as appropriate.\n\t(frv_function_prologue, frv_alloc_temp_reg,\n\tfrv_initial_elimination_offset, frv_expand_block_move,\n\tfrv_expand_block_clear, frv_print_operand_jump_hint,\n\tfrv_legitimize_tls_address, unspec_got_name, frv_emit_move,\n\tfrv_emit_movsi, frv_split_cond_move, frv_split_minmax,\n\tfrv_ifcvt_modify_insn, frv_ifcvt_modify_final,\n\tfrv_adjust_field_align, frv_insn_unit, frv_cond_flags,\n\tfrv_sort_insn_group, frv_reorder_packet, frv_matching_accg_mode,\n\tfrv_in_small_data_p, frv_asm_out_constructor,\n\tfrv_asm_out_destructor, frv_output_dwarf_dtprel): Likewise.\n\t* config/frv/frv.md (reload_incc_fp, *cond_exec_si_binary1,\n\t*cond_exec_si_binary2, *cond_exec_si_divide, *cond_exec_si_unary1,\n\t*cond_exec_sf_conv, *cond_exec_sf_add, call, sibcall, call_value,\n\tsibcall_value, casesi): Likewise.\n\nFrom-SVN: r99383", "tree": {"sha": "ee4210d274edad8d15de3d04e3e3fa659e5689ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee4210d274edad8d15de3d04e3e3fa659e5689ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44e91694bda9e891e1eeac71bd5cda66d6acce25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44e91694bda9e891e1eeac71bd5cda66d6acce25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44e91694bda9e891e1eeac71bd5cda66d6acce25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44e91694bda9e891e1eeac71bd5cda66d6acce25/comments", "author": null, "committer": null, "parents": [{"sha": "dc759020e81ab9c7083653aef86dfa9fcd5cdec3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc759020e81ab9c7083653aef86dfa9fcd5cdec3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc759020e81ab9c7083653aef86dfa9fcd5cdec3"}], "stats": {"total": 153, "additions": 75, "deletions": 78}, "files": [{"sha": "37d6f2f1c8791fc7d722e67ddbd9b7ea7cd8c7ff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44e91694bda9e891e1eeac71bd5cda66d6acce25/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44e91694bda9e891e1eeac71bd5cda66d6acce25/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=44e91694bda9e891e1eeac71bd5cda66d6acce25", "patch": "@@ -1,5 +1,22 @@\n 2005-05-08  Nathan Sidwell  <nathan@codesourcery.com>\n \n+\t* config/frv/frv.c (frv_default_flags_for_cpu): Use gcc_assert and\n+\tgcc_unreachable, as appropriate.\n+\t(frv_function_prologue, frv_alloc_temp_reg,\n+\tfrv_initial_elimination_offset, frv_expand_block_move,\n+\tfrv_expand_block_clear, frv_print_operand_jump_hint,\n+\tfrv_legitimize_tls_address, unspec_got_name, frv_emit_move,\n+\tfrv_emit_movsi, frv_split_cond_move, frv_split_minmax,\n+\tfrv_ifcvt_modify_insn, frv_ifcvt_modify_final,\n+\tfrv_adjust_field_align, frv_insn_unit, frv_cond_flags,\n+\tfrv_sort_insn_group, frv_reorder_packet, frv_matching_accg_mode,\n+\tfrv_in_small_data_p, frv_asm_out_constructor,\n+\tfrv_asm_out_destructor, frv_output_dwarf_dtprel): Likewise.\n+\t* config/frv/frv.md (reload_incc_fp, *cond_exec_si_binary1,\n+\t*cond_exec_si_binary2, *cond_exec_si_divide, *cond_exec_si_unary1,\n+\t*cond_exec_sf_conv, *cond_exec_sf_add, call, sibcall, call_value,\n+\tsibcall_value, casesi): Likewise.\n+\n \t* config/mn10300/mn10300.c (print_operand): Use gcc_assert and\n \tgcc_unreachable as appropriate.\n \t(print_operand_address, mn10300_print_reg_list, expand_prologue,"}, {"sha": "679b0b433c87d861d8a05168b291fd7ecb63b54e", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 44, "deletions": 56, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44e91694bda9e891e1eeac71bd5cda66d6acce25/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44e91694bda9e891e1eeac71bd5cda66d6acce25/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=44e91694bda9e891e1eeac71bd5cda66d6acce25", "patch": "@@ -571,8 +571,10 @@ frv_default_flags_for_cpu (void)\n     case FRV_CPU_FR300:\n     case FRV_CPU_SIMPLE:\n       return MASK_DEFAULT_SIMPLE;\n+\n+    default:\n+      gcc_unreachable ();\n     }\n-  abort ();\n }\n \n /* Sometimes certain combinations of command options do not make\n@@ -1461,8 +1463,7 @@ frv_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n       rtx insn;\n \n       /* Just to check that the above comment is true.  */\n-      if (regs_ever_live[GPR_FIRST + 3])\n-\tabort ();\n+      gcc_assert (!regs_ever_live[GPR_FIRST + 3]);\n \n       /* Generate the instruction that saves the link register.  */\n       fprintf (file, \"\\tmovsg lr,gr3\\n\");\n@@ -1519,10 +1520,8 @@ frv_alloc_temp_reg (\n \tregno = 0;\n       if (regno == orig_regno)\n \t{\n-\t  if (no_abort)\n-\t    return NULL_RTX;\n-\t  else\n-\t    abort ();\n+\t  gcc_assert (no_abort);\n+\t  return NULL_RTX;\n \t}\n     }\n \n@@ -2109,7 +2108,7 @@ frv_initial_elimination_offset (int from, int to)\n \t   - info->pretend_size);\n \n   else\n-    abort ();\n+    gcc_unreachable ();\n \n   if (TARGET_DEBUG_STACK)\n     fprintf (stderr, \"Eliminate %s to %s by adding %d\\n\",\n@@ -2223,9 +2222,8 @@ frv_expand_block_move (rtx operands[])\n   if (! constp)\n     return FALSE;\n \n-  /* If this is not a fixed size alignment, abort.  */\n-  if (GET_CODE (align_rtx) != CONST_INT)\n-    abort ();\n+  /* This should be a fixed size alignment.  */\n+  gcc_assert (GET_CODE (align_rtx) == CONST_INT);\n \n   align = INTVAL (align_rtx);\n \n@@ -2316,9 +2314,8 @@ frv_expand_block_clear (rtx operands[])\n   if (! constp)\n     return FALSE;\n \n-  /* If this is not a fixed size alignment, abort.  */\n-  if (GET_CODE (align_rtx) != CONST_INT)\n-    abort ();\n+  /* This should be a fixed size alignment.  */\n+  gcc_assert (GET_CODE (align_rtx) == CONST_INT);\n \n   align = INTVAL (align_rtx);\n \n@@ -2623,8 +2620,7 @@ frv_print_operand_jump_hint (rtx insn)\n   HOST_WIDE_INT prob = -1;\n   enum { UNKNOWN, BACKWARD, FORWARD } jump_type = UNKNOWN;\n \n-  if (GET_CODE (insn) != JUMP_INSN)\n-    abort ();\n+  gcc_assert (GET_CODE (insn) == JUMP_INSN);\n \n   /* Assume any non-conditional jump is likely.  */\n   if (! any_condjump_p (insn))\n@@ -3568,7 +3564,7 @@ frv_legitimize_tls_address (rtx addr, enum tls_model model)\n \tbreak;\n       }\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   return dest;\n@@ -3670,7 +3666,7 @@ unspec_got_name (int i)\n     case R_FRV_TLSDESCLO: return \"tlsdesclo\";\n     case R_FRV_GOTTLSDESCHI: return \"gottlsdeschi\";\n     case R_FRV_GOTTLSDESCLO: return \"gottlsdesclo\";\n-    default: abort ();\n+    default: gcc_unreachable ();\n     }\n }\n \n@@ -3919,7 +3915,7 @@ frv_emit_move (enum machine_mode mode, rtx dest, rtx src)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   emit_insn (gen_rtx_SET (VOIDmode, dest, src));\n@@ -4134,8 +4130,7 @@ frv_emit_movsi (rtx dest, rtx src)\n \n       /* Since OUR_FDPIC_REG is a pseudo register, we can't safely introduce\n \t new uses of it once reload has begun.  */\n-      if (reload_in_progress || reload_completed)\n-\tabort ();\n+      gcc_assert (!reload_in_progress && !reload_completed);\n \n       switch (unspec)\n \t{\n@@ -4933,7 +4928,7 @@ frv_split_cond_move (rtx operands[])\n \t}\n \n       else\n-\tabort ();\n+\tgcc_unreachable ();\n     }\n   else\n     {\n@@ -5035,7 +5030,7 @@ frv_split_minmax (rtx operands[])\n   switch (GET_CODE (minmax))\n     {\n     default:\n-      abort ();\n+      gcc_unreachable ();\n \n     case SMIN: test_code = LT;  break;\n     case SMAX: test_code = GT;  break;\n@@ -5061,8 +5056,7 @@ frv_split_minmax (rtx operands[])\n      then do a conditional move of the other value.  */\n   if (GET_CODE (src2) == CONST_INT && INTVAL (src2) != 0)\n     {\n-      if (rtx_equal_p (dest, src1))\n-\tabort ();\n+      gcc_assert (!rtx_equal_p (dest, src1));\n \n       emit_move_insn (dest, src2);\n       emit_insn (gen_rtx_COND_EXEC (VOIDmode,\n@@ -5870,8 +5864,7 @@ frv_ifcvt_modify_insn (ce_if_block_t *ce_info,\n   rtx op1;\n   rtx test;\n \n-  if (GET_CODE (pattern) != COND_EXEC)\n-    abort ();\n+  gcc_assert (GET_CODE (pattern) == COND_EXEC);\n \n   test = COND_EXEC_TEST (pattern);\n   if (GET_CODE (test) == AND)\n@@ -6137,8 +6130,7 @@ frv_ifcvt_modify_final (ce_if_block_t *ce_info ATTRIBUTE_UNUSED)\n \n   /* Loop inserting the check insns.  The last check insn is the first test,\n      and is the appropriate place to insert constants.  */\n-  if (! p)\n-    abort ();\n+  gcc_assert (p);\n \n   do\n     {\n@@ -6486,8 +6478,7 @@ frv_adjust_field_align (tree field, int computed)\n \t  prev = cur;\n \t}\n \n-      if (!cur)\n-\tabort ();\n+      gcc_assert (cur);\n \n       /* If this isn't a :0 field and if the previous element is a bitfield\n \t also, see if the type is different, if so, we will need to align the\n@@ -7007,8 +6998,7 @@ frv_insn_unit (rtx insn)\n \tif (cpu_unit_reservation_p (state, frv_unit_codes[unit]))\n \t  break;\n \n-      if (unit == ARRAY_SIZE (frv_unit_codes))\n-\tabort ();\n+      gcc_assert (unit != ARRAY_SIZE (frv_unit_codes));\n \n       frv_type_to_unit[type] = unit;\n     }\n@@ -7076,15 +7066,14 @@ static struct {\n static int\n frv_cond_flags (rtx cond)\n {\n-  if ((GET_CODE (cond) == EQ || GET_CODE (cond) == NE)\n-      && GET_CODE (XEXP (cond, 0)) == REG\n-      && CR_P (REGNO (XEXP (cond, 0)))\n-      && XEXP (cond, 1) == const0_rtx)\n-    return ((REGNO (XEXP (cond, 0)) - CR_FIRST)\n-\t    | (GET_CODE (cond) == NE\n-\t       ? REGSTATE_IF_TRUE\n-\t       : REGSTATE_IF_FALSE));\n-  abort ();\n+  gcc_assert ((GET_CODE (cond) == EQ || GET_CODE (cond) == NE)\n+\t      && GET_CODE (XEXP (cond, 0)) == REG\n+\t      && CR_P (REGNO (XEXP (cond, 0)))\n+\t      && XEXP (cond, 1) == const0_rtx);\n+  return ((REGNO (XEXP (cond, 0)) - CR_FIRST)\n+\t  | (GET_CODE (cond) == NE\n+\t     ? REGSTATE_IF_TRUE\n+\t     : REGSTATE_IF_FALSE));\n }\n \n \n@@ -7569,7 +7558,7 @@ frv_sort_insn_group (enum frv_insn_group group)\n \t    return;\n \t}\n     }\n-  abort ();\n+  gcc_unreachable ();\n }\n \f\n /* Sort the current packet into assembly-language order.  Set packing\n@@ -7601,14 +7590,13 @@ frv_reorder_packet (void)\n       if (cursor[group] < packet_group->num_insns)\n \t{\n \t  /* frv_reorg should have added nops for us.  */\n-\t  if (packet_group->sorted[cursor[group]] == packet_group->nop)\n-\t    abort ();\n+\t  gcc_assert (packet_group->sorted[cursor[group]]\n+\t\t      != packet_group->nop);\n \t  insns[to++] = packet_group->sorted[cursor[group]++];\n \t}\n     }\n \n-  if (to != frv_packet.num_insns)\n-    abort ();\n+  gcc_assert (to == frv_packet.num_insns);\n \n   /* Clear the last instruction's packing flag, thus marking the end of\n      a packet.  Reorder the other instructions relative to it.  */\n@@ -8258,7 +8246,7 @@ frv_matching_accg_mode (enum machine_mode mode)\n       return QImode;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -8980,8 +8968,7 @@ frv_in_small_data_p (tree decl)\n   section_name = DECL_SECTION_NAME (decl);\n   if (section_name)\n     {\n-      if (TREE_CODE (section_name) != STRING_CST)\n-\tabort ();\n+      gcc_assert (TREE_CODE (section_name) == STRING_CST);\n       if (frv_string_begins_with (section_name, \".sdata\"))\n \treturn true;\n       if (frv_string_begins_with (section_name, \".sbss\"))\n@@ -9077,8 +9064,9 @@ frv_asm_out_constructor (rtx symbol, int priority ATTRIBUTE_UNUSED)\n   assemble_align (POINTER_SIZE);\n   if (TARGET_FDPIC)\n     {\n-      if (!frv_assemble_integer (symbol, POINTER_SIZE / BITS_PER_UNIT, 1))\n-\tabort ();\n+      int ok = frv_assemble_integer (symbol, POINTER_SIZE / BITS_PER_UNIT, 1);\n+\n+      gcc_assert (ok);\n       return;\n     }\n   assemble_integer_with_op (\"\\t.picptr\\t\", symbol);\n@@ -9091,8 +9079,9 @@ frv_asm_out_destructor (rtx symbol, int priority ATTRIBUTE_UNUSED)\n   assemble_align (POINTER_SIZE);\n   if (TARGET_FDPIC)\n     {\n-      if (!frv_assemble_integer (symbol, POINTER_SIZE / BITS_PER_UNIT, 1))\n-\tabort ();\n+      int ok = frv_assemble_integer (symbol, POINTER_SIZE / BITS_PER_UNIT, 1);\n+      \n+      gcc_assert (ok);\n       return;\n     }\n   assemble_integer_with_op (\"\\t.picptr\\t\", symbol);\n@@ -9115,8 +9104,7 @@ frv_struct_value_rtx (tree fntype ATTRIBUTE_UNUSED,\n void\n frv_output_dwarf_dtprel (FILE *file, int size, rtx x)\n {\n-  if (size != 4)\n-    abort ();\n+  gcc_assert (size == 4);\n   fputs (\"\\t.picptr\\ttlsmoff(\", file);\n   /* We want the unbiased TLS offset, so add the bias to the\n      expression, such that the implicit biasing cancels out.  */"}, {"sha": "2feb6c6a7b92b5fc39735e5fcb1bd0d45d707801", "filename": "gcc/config/frv/frv.md", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44e91694bda9e891e1eeac71bd5cda66d6acce25/gcc%2Fconfig%2Ffrv%2Ffrv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44e91694bda9e891e1eeac71bd5cda66d6acce25/gcc%2Fconfig%2Ffrv%2Ffrv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.md?ref=44e91694bda9e891e1eeac71bd5cda66d6acce25", "patch": "@@ -2468,13 +2468,11 @@\n       rtx addr;\n       rtx temp3 = simplify_gen_subreg (SImode, operands[2], TImode, 12);\n \n-      if (GET_CODE (operands[1]) != MEM)\n-        abort ();\n+      gcc_assert (GET_CODE (operands[1]) == MEM);\n \n       addr = XEXP (operands[1], 0);\n \n-      if (GET_CODE (addr) != PLUS)\n-        abort ();\n+      gcc_assert (GET_CODE (addr) == PLUS);\n \n       emit_move_insn (temp3, XEXP (addr, 1));\n \n@@ -4479,7 +4477,7 @@\n       case ASHIFT:   return \\\"csll %4, %z5, %2, %1, %e0\\\";\n       case ASHIFTRT: return \\\"csra %4, %z5, %2, %1, %e0\\\";\n       case LSHIFTRT: return \\\"csrl %4, %z5, %2, %1, %e0\\\";\n-      default:       abort ();\n+      default:       gcc_unreachable ();\n     }\n }\"\n   [(set_attr \"length\" \"4\")\n@@ -4502,7 +4500,7 @@\n       case AND: return \\\"cmand %4, %5, %2, %1, %e0\\\";\n       case IOR: return \\\"cmor %4, %5, %2, %1, %e0\\\";\n       case XOR: return \\\"cmxor %4, %5, %2, %1, %e0\\\";\n-      default:  abort ();\n+      default:  gcc_unreachable ();\n     }\n }\"\n   [(set_attr \"length\" \"4\")\n@@ -4543,7 +4541,7 @@\n     {\n       case DIV:  return \\\"csdiv %4, %z5, %2, %1, %e0\\\";\n       case UDIV: return \\\"cudiv %4, %z5, %2, %1, %e0\\\";\n-      default:   abort ();\n+      default:   gcc_unreachable ();\n     }\n }\"\n   [(set_attr \"length\" \"4\")\n@@ -4564,7 +4562,7 @@\n     {\n       case NOT: return \\\"cnot %4, %2, %1, %e0\\\";\n       case NEG: return \\\"csub %., %4, %2, %1, %e0\\\";\n-      default:  abort ();\n+      default:  gcc_unreachable ();\n     }\n }\"\n   [(set_attr \"length\" \"4\")\n@@ -4639,7 +4637,7 @@\n     {\n       case ABS: return \\\"cfabss %4, %2, %1, %e0\\\";\n       case NEG: return \\\"cfnegs %4, %2, %1, %e0\\\";\n-      default:  abort ();\n+      default:  gcc_unreachable ();\n     }\n }\"\n   [(set_attr \"length\" \"4\")\n@@ -4661,7 +4659,7 @@\n     {\n       case PLUS:  return \\\"cfadds %4, %5, %2, %1, %e0\\\";\n       case MINUS: return \\\"cfsubs %4, %5, %2, %1, %e0\\\";\n-      default:    abort ();\n+      default:    gcc_unreachable ();\n     }\n }\"\n   [(set_attr \"length\" \"4\")\n@@ -5404,8 +5402,7 @@\n   rtx lr = gen_rtx_REG (Pmode, LR_REGNO);\n   rtx addr;\n \n-  if (GET_CODE (operands[0]) != MEM)\n-    abort ();\n+  gcc_assert (GET_CODE (operands[0]) == MEM);\n \n   addr = XEXP (operands[0], 0);\n   if (! call_operand (addr, Pmode))\n@@ -5490,8 +5487,7 @@\n {\n   rtx addr;\n \n-  if (GET_CODE (operands[0]) != MEM)\n-    abort ();\n+  gcc_assert (GET_CODE (operands[0]) == MEM);\n \n   addr = XEXP (operands[0], 0);\n   if (! sibcall_operand (addr, Pmode))\n@@ -5558,8 +5554,7 @@\n   rtx lr = gen_rtx_REG (Pmode, LR_REGNO);\n   rtx addr;\n \n-  if (GET_CODE (operands[1]) != MEM)\n-    abort ();\n+  gcc_assert (GET_CODE (operands[1]) == MEM);\n \n   addr = XEXP (operands[1], 0);\n   if (! call_operand (addr, Pmode))\n@@ -5625,8 +5620,7 @@\n {\n   rtx addr;\n \n-  if (GET_CODE (operands[1]) != MEM)\n-    abort ();\n+  gcc_assert (GET_CODE (operands[1]) == MEM);\n \n   addr = XEXP (operands[1], 0);\n   if (! sibcall_operand (addr, Pmode))\n@@ -5838,11 +5832,9 @@\n   rtx reg2;\n   rtx reg3;\n \n-  if (GET_CODE (operands[1]) != CONST_INT)\n-    abort ();\n+  gcc_assert (GET_CODE (operands[1]) == CONST_INT);\n \n-  if (GET_CODE (operands[2]) != CONST_INT)\n-    abort ();\n+  gcc_assert (GET_CODE (operands[2]) == CONST_INT);\n \n   /* If we can't generate an immediate instruction, promote to register.  */\n   if (! IN_RANGE_P (INTVAL (range), -2048, 2047))"}]}