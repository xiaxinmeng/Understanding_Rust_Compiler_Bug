{"sha": "0e6a0e48eb5ead024d12453cb811bdf0ef5c3377", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU2YTBlNDhlYjVlYWQwMjRkMTI0NTNjYjgxMWJkZjBlZjVjMzM3Nw==", "commit": {"author": {"name": "Marc Glisse", "email": "marc.glisse@inria.fr", "date": "2013-10-08T10:39:49Z"}, "committer": {"name": "Marc Glisse", "email": "glisse@gcc.gnu.org", "date": "2013-10-08T10:39:49Z"}, "message": "re PR tree-optimization/58480 (Use attribute((nonnull)) to optimize callers)\n\n2013-10-08  Marc Glisse  <marc.glisse@inria.fr>\n\n\tPR tree-optimization/58480\ngcc/\n\t* tree-vrp.c (infer_nonnull_range): New function.\n\t(infer_value_range): Call infer_nonnull_range.\n\ngcc/testsuite/\n\t* gcc.dg/tree-ssa/pr58480.c: New file.\n\nFrom-SVN: r203271", "tree": {"sha": "d6b986b5b052a0040274877460393e4e53588b02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6b986b5b052a0040274877460393e4e53588b02"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e6a0e48eb5ead024d12453cb811bdf0ef5c3377", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e6a0e48eb5ead024d12453cb811bdf0ef5c3377", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e6a0e48eb5ead024d12453cb811bdf0ef5c3377", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e6a0e48eb5ead024d12453cb811bdf0ef5c3377/comments", "author": {"login": "mglisse", "id": 10097863, "node_id": "MDQ6VXNlcjEwMDk3ODYz", "avatar_url": "https://avatars.githubusercontent.com/u/10097863?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mglisse", "html_url": "https://github.com/mglisse", "followers_url": "https://api.github.com/users/mglisse/followers", "following_url": "https://api.github.com/users/mglisse/following{/other_user}", "gists_url": "https://api.github.com/users/mglisse/gists{/gist_id}", "starred_url": "https://api.github.com/users/mglisse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mglisse/subscriptions", "organizations_url": "https://api.github.com/users/mglisse/orgs", "repos_url": "https://api.github.com/users/mglisse/repos", "events_url": "https://api.github.com/users/mglisse/events{/privacy}", "received_events_url": "https://api.github.com/users/mglisse/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ef6179d186ee9a2ebe034d328a17764e703273ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef6179d186ee9a2ebe034d328a17764e703273ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef6179d186ee9a2ebe034d328a17764e703273ca"}], "stats": {"total": 100, "additions": 85, "deletions": 15}, "files": [{"sha": "dc1bc7e41b9371e4192594f728988cd2677a7864", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6a0e48eb5ead024d12453cb811bdf0ef5c3377/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6a0e48eb5ead024d12453cb811bdf0ef5c3377/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0e6a0e48eb5ead024d12453cb811bdf0ef5c3377", "patch": "@@ -1,3 +1,9 @@\n+2013-10-08  Marc Glisse  <marc.glisse@inria.fr>\n+\n+\tPR tree-optimization/58480\n+\t* tree-vrp.c (infer_nonnull_range): New function.\n+\t(infer_value_range): Call infer_nonnull_range.\n+\n 2013-10-08  Dehao Chen  <dehao@google.com>\n \n \tPR tree-optimization/58619"}, {"sha": "86fb8eae774da7180fa9b3add64d1a2f07d48f9c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6a0e48eb5ead024d12453cb811bdf0ef5c3377/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6a0e48eb5ead024d12453cb811bdf0ef5c3377/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0e6a0e48eb5ead024d12453cb811bdf0ef5c3377", "patch": "@@ -1,3 +1,8 @@\n+2013-10-08  Marc Glisse  <marc.glisse@inria.fr>\n+\n+\tPR tree-optimization/58480\n+\t* gcc.dg/tree-ssa/pr58480.c: New file.\n+\n 2013-10-07  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \t* gcc.target/powerpc/pr43154.c: Skip for ppc64 little endian."}, {"sha": "a42edf973cb263ea59f75a517b32ee0a1af955ae", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr58480.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6a0e48eb5ead024d12453cb811bdf0ef5c3377/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr58480.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6a0e48eb5ead024d12453cb811bdf0ef5c3377/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr58480.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr58480.c?ref=0e6a0e48eb5ead024d12453cb811bdf0ef5c3377", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile { target { ! keeps_null_pointer_checks } } } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n+\n+extern void eliminate (void);\n+extern void* f1 (void *a, void *b) __attribute__((nonnull));\n+extern void* f2 (void *a, void *b) __attribute__((nonnull(2)));\n+void g1 (void*p, void*q){\n+  f1 (q, p);\n+  if (p == 0)\n+    eliminate ();\n+}\n+void g2 (void*p, void*q){\n+  f2 (q, p);\n+  if (p == 0)\n+    eliminate ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Folding predicate\\[^\\\\n\\]*to 0\" 2 \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "156a58ff5ca1385a864b97520ee54314ff48dcee", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 55, "deletions": 15, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6a0e48eb5ead024d12453cb811bdf0ef5c3377/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6a0e48eb5ead024d12453cb811bdf0ef5c3377/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=0e6a0e48eb5ead024d12453cb811bdf0ef5c3377", "patch": "@@ -4462,6 +4462,56 @@ fp_predicate (gimple stmt)\n }\n \n \n+/* If OP can be inferred to be non-zero after STMT executes, return true.  */\n+\n+static bool\n+infer_nonnull_range (gimple stmt, tree op)\n+{\n+  /* We can only assume that a pointer dereference will yield\n+     non-NULL if -fdelete-null-pointer-checks is enabled.  */\n+  if (!flag_delete_null_pointer_checks\n+      || !POINTER_TYPE_P (TREE_TYPE (op))\n+      || gimple_code (stmt) == GIMPLE_ASM)\n+    return false;\n+\n+  unsigned num_uses, num_loads, num_stores;\n+\n+  count_uses_and_derefs (op, stmt, &num_uses, &num_loads, &num_stores);\n+  if (num_loads + num_stores > 0)\n+    return true;\n+\n+  if (gimple_code (stmt) == GIMPLE_CALL)\n+    {\n+      tree fntype = gimple_call_fntype (stmt);\n+      tree attrs = TYPE_ATTRIBUTES (fntype);\n+      for (; attrs; attrs = TREE_CHAIN (attrs))\n+\t{\n+\t  attrs = lookup_attribute (\"nonnull\", attrs);\n+\n+\t  /* If \"nonnull\" wasn't specified, we know nothing about\n+\t     the argument.  */\n+\t  if (attrs == NULL_TREE)\n+\t    return false;\n+\n+\t  /* If \"nonnull\" applies to all the arguments, then ARG\n+\t     is non-null.  */\n+\t  if (TREE_VALUE (attrs) == NULL_TREE)\n+\t    return true;\n+\n+\t  /* Now see if op appears in the nonnull list.  */\n+\t  for (tree t = TREE_VALUE (attrs); t; t = TREE_CHAIN (t))\n+\t    {\n+\t      int idx = TREE_INT_CST_LOW (TREE_VALUE (t)) - 1;\n+\t      tree arg = gimple_call_arg (stmt, idx);\n+\t      if (op == arg)\n+\t\treturn true;\n+\t    }\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n /* If the range of values taken by OP can be inferred after STMT executes,\n    return the comparison code (COMP_CODE_P) and value (VAL_P) that\n    describes the inferred range.  Return true if a range could be\n@@ -4479,7 +4529,7 @@ infer_value_range (gimple stmt, tree op, enum tree_code *comp_code_p, tree *val_\n     return false;\n \n   /* Similarly, don't infer anything from statements that may throw\n-     exceptions.  */\n+     exceptions. ??? Relax this requirement?  */\n   if (stmt_could_throw_p (stmt))\n     return false;\n \n@@ -4490,21 +4540,11 @@ infer_value_range (gimple stmt, tree op, enum tree_code *comp_code_p, tree *val_\n   if (stmt_ends_bb_p (stmt) && EDGE_COUNT (gimple_bb (stmt)->succs) == 0)\n     return false;\n \n-  /* We can only assume that a pointer dereference will yield\n-     non-NULL if -fdelete-null-pointer-checks is enabled.  */\n-  if (flag_delete_null_pointer_checks\n-      && POINTER_TYPE_P (TREE_TYPE (op))\n-      && gimple_code (stmt) != GIMPLE_ASM)\n+  if (infer_nonnull_range (stmt, op))\n     {\n-      unsigned num_uses, num_loads, num_stores;\n-\n-      count_uses_and_derefs (op, stmt, &num_uses, &num_loads, &num_stores);\n-      if (num_loads + num_stores > 0)\n-\t{\n-\t  *val_p = build_int_cst (TREE_TYPE (op), 0);\n-\t  *comp_code_p = NE_EXPR;\n-\t  return true;\n-\t}\n+      *val_p = build_int_cst (TREE_TYPE (op), 0);\n+      *comp_code_p = NE_EXPR;\n+      return true;\n     }\n \n   return false;"}]}