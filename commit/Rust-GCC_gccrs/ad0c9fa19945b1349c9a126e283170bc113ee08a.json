{"sha": "ad0c9fa19945b1349c9a126e283170bc113ee08a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQwYzlmYTE5OTQ1YjEzNDljOWExMjZlMjgzMTcwYmMxMTNlZTA4YQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-03-16T06:07:43Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-03-16T06:07:43Z"}, "message": "Follow whitespace conventions near parens.\n\nFrom-SVN: r3756", "tree": {"sha": "b3c73108bc85a1cc702c36207442c08ddab50bea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3c73108bc85a1cc702c36207442c08ddab50bea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad0c9fa19945b1349c9a126e283170bc113ee08a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad0c9fa19945b1349c9a126e283170bc113ee08a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad0c9fa19945b1349c9a126e283170bc113ee08a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad0c9fa19945b1349c9a126e283170bc113ee08a/comments", "author": null, "committer": null, "parents": [{"sha": "c6469b460a0cdbf626ea8c961324aabd1e6a40b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6469b460a0cdbf626ea8c961324aabd1e6a40b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6469b460a0cdbf626ea8c961324aabd1e6a40b8"}], "stats": {"total": 60, "additions": 30, "deletions": 30}, "files": [{"sha": "1d48b6276b181903aa5048e0852c5aed65e15172", "filename": "gcc/cccp.c", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad0c9fa19945b1349c9a126e283170bc113ee08a/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad0c9fa19945b1349c9a126e283170bc113ee08a/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=ad0c9fa19945b1349c9a126e283170bc113ee08a", "patch": "@@ -97,12 +97,12 @@ typedef unsigned char U_CHAR;\n #include <descrip.h>\n #define O_RDONLY\t0\t/* Open arg for Read/Only  */\n #define O_WRONLY\t1\t/* Open arg for Write/Only */\n-#define read(fd,buf,size)\tVMS_read(fd,buf,size)\n-#define write(fd,buf,size)\tVMS_write(fd,buf,size)\n-#define open(fname,mode,prot)\tVMS_open(fname,mode,prot)\n-#define fopen(fname,mode)\tVMS_fopen(fname,mode)\n-#define freopen(fname,mode,ofile) VMS_freopen(fname,mode,ofile)\n-#define strncat(dst,src,cnt) VMS_strncat(dst,src,cnt)\n+#define read(fd,buf,size)\tVMS_read (fd,buf,size)\n+#define write(fd,buf,size)\tVMS_write (fd,buf,size)\n+#define open(fname,mode,prot)\tVMS_open (fname,mode,prot)\n+#define fopen(fname,mode)\tVMS_fopen (fname,mode)\n+#define freopen(fname,mode,ofile) VMS_freopen (fname,mode,ofile)\n+#define strncat(dst,src,cnt) VMS_strncat (dst,src,cnt)\n static char * VMS_strncat ();\n static int VMS_read ();\n static int VMS_write ();\n@@ -691,14 +691,14 @@ union hashval {\n /*\n  * special extension string that can be added to the last macro argument to \n  * allow it to absorb the \"rest\" of the arguments when expanded.  Ex:\n- * \t\t#define wow(a, b...)\t\tprocess(b, a, b)\n- *\t\t{ wow(1, 2, 3); }\t->\t{ process( 2, 3, 1,  2, 3); }\n- *\t\t{ wow(one, two); }\t->\t{ process( two, one,  two); }\n+ * \t\t#define wow(a, b...)\t\tprocess (b, a, b)\n+ *\t\t{ wow (1, 2, 3); }\t->\t{ process (2, 3, 1, 2, 3); }\n+ *\t\t{ wow (one, two); }\t->\t{ process (two, one, two); }\n  * if this \"rest_arg\" is used with the concat token '##' and if it is not\n  * supplied then the token attached to with ## will not be outputted.  Ex:\n- * \t\t#define wow(a, b...)\t\tprocess(b ## , a, ## b)\n- *\t\t{ wow(1, 2); }\t\t->\t{ process( 2, 1,2); }\n- *\t\t{ wow(one); }\t\t->\t{ process( one); {\n+ * \t\t#define wow (a, b...)\t\tprocess (b ## , a, ## b)\n+ *\t\t{ wow (1, 2); }\t\t->\t{ process (2, 1, 2); }\n+ *\t\t{ wow (one); }\t\t->\t{ process (one); {\n  */\n static char rest_extension[] = \"...\";\n #define REST_EXTENSION_LENGTH\t(sizeof (rest_extension) - 1)\n@@ -924,9 +924,9 @@ static char *out_fname;\n    -$ stores 0; -traditional may store 1.  Default is 1 for VMS, 0 otherwise.\n    This must be 0 for correct processing of this ANSI C program:\n \t#define foo(a) #a\n-\t#define lose(b) foo(b)\n+\t#define lose(b) foo (b)\n \t#define test$\n-\tlose(test)\t*/\n+\tlose (test)\t*/\n static int dollars_in_ident;\n #ifndef DOLLARS_IN_IDENTIFIERS\n #define DOLLARS_IN_IDENTIFIERS 1\n@@ -2604,7 +2604,7 @@ do { ip = &instack[indepth];\t\t\\\n \t  switch (*ibp++) {\n \t  case '/':\n \t    if (warn_comments && ibp < limit && *ibp == '*')\n-\t      warning(\"`/*' within comment\");\n+\t      warning (\"`/*' within comment\");\n \t    break;\n \t  case '*':\n \t    if (*ibp == '\\\\' && ibp[1] == '\\n')\n@@ -2892,8 +2892,8 @@ do { ip = &instack[indepth];\t\t\\\n \t      if (disabled) {\n #if 0\n \t\t/* This error check caught useful cases such as\n-\t\t   #define foo(x,y) bar(x(y,0), y)\n-\t\t   foo(foo, baz)  */\n+\t\t   #define foo(x,y) bar (x (y,0), y)\n+\t\t   foo (foo, baz)  */\n \t\tif (traditional)\n \t\t  error (\"recursive use of macro `%s'\", hp->name);\n #endif\n@@ -4498,7 +4498,7 @@ check_preconditions (prec)\n       mdef = create_definition (prec, lineend, NULL_PTR);\n \n       if (mdef.defn == 0)\n-\tabort();\n+\tabort ();\n       \n       if ((hp = lookup (mdef.symnam, mdef.symlen, -1)) == NULL\n \t  || (hp->type != T_MACRO && hp->type != T_CONST)\n@@ -4849,11 +4849,11 @@ create_definition (buf, limit, op)\n \n \tfor (otemp = temp->next; otemp != NULL; otemp = otemp->next)\n \t  if (temp->length == otemp->length &&\n-\t    strncmp(temp->name, otemp->name, temp->length) == 0) {\n+\t    strncmp (temp->name, otemp->name, temp->length) == 0) {\n \t      U_CHAR *name;\n \n-\t      name = (U_CHAR *) alloca(temp->length + 1);\n-\t      (void) strncpy(name, temp->name, temp->length);\n+\t      name = (U_CHAR *) alloca (temp->length + 1);\n+\t      (void) strncpy (name, temp->name, temp->length);\n \t      name[temp->length] = '\\0';\n \t      error (\"duplicate argument name `%s' in `#define'\", name);\n \t      goto nope;\n@@ -5955,7 +5955,7 @@ do_undef (buf, limit, op, keyword)\n /*\n  * Report a fatal error detected by the program we are processing.\n  * Use the text of the line in the error message, then terminate.\n- * (We use error() because it prints the filename & line#.)\n+ * (We use error because it prints the filename & line#.)\n  */\n \n static int\n@@ -5978,7 +5978,7 @@ do_error (buf, limit, op, keyword)\n /*\n  * Report a warning detected by the program we are processing.\n  * Use the text of the line in the warning message, then continue.\n- * (We use error() because it prints the filename & line#.)\n+ * (We use error because it prints the filename & line#.)\n  */\n \n static int\n@@ -6277,10 +6277,10 @@ do_xifdef (buf, limit, op, keyword)\n     if (pcp_outfile) {\n       /* Output a precondition for this macro.  */\n       if (hp && hp->value.defn->predefined)\n-\tfprintf(pcp_outfile, \"#define %s\\n\", hp->name);\n+\tfprintf (pcp_outfile, \"#define %s\\n\", hp->name);\n       else {\n \tU_CHAR *cp = buf;\n-\tfprintf(pcp_outfile, \"#undef \");\n+\tfprintf (pcp_outfile, \"#undef \");\n \twhile (is_idchar[*cp]) /* Ick! */\n \t  fputc (*cp++, pcp_outfile);\n \tputc ('\\n', pcp_outfile);\n@@ -7381,8 +7381,8 @@ macroexpand (hp, op)\n     ip2->system_header_p = 0;\n \n     /* Recursive macro use sometimes works traditionally.\n-       #define foo(x,y) bar(x(y,0), y)\n-       foo(foo, baz)  */\n+       #define foo(x,y) bar (x (y,0), y)\n+       foo (foo, baz)  */\n \n     if (!traditional)\n       hp->type = T_DISABLED;\n@@ -8972,7 +8972,7 @@ hack_vms_include_specification (fname)\n      * Then all we need to do is to push a '[' into the output string. Later\n      * processing will fill this in, and close the bracket.\n      */\n-    if(cp[-1] != ':') *cp2++ = ':'; /* dev not in spec.  take first dir */\n+    if (cp[-1] != ':') *cp2++ = ':'; /* dev not in spec.  take first dir */\n     *cp2++ = '[';\t\t/* Open the directory specification */\n   }\n \n@@ -9011,7 +9011,7 @@ hack_vms_include_specification (fname)\n       cp1++;\t\t\t/* Skip the \"/\" */\n     }\n     /* Close the directory specification */\n-    if(cp2[-1] == '.')\t\t/* no trailing periods */\n+    if (cp2[-1] == '.')\t\t/* no trailing periods */\n       cp2--;\n     *cp2++ = ']';\n   }\n@@ -9066,7 +9066,7 @@ read (fd, buf, size)\n     i = read (fd, buf, i);\n     if (i <= 0) {\n       if (i == 0) return (total);\n-      return(i);\n+      return (i);\n     }\n     /* Account for this read */\n     total += i;"}]}