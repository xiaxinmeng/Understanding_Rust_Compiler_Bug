{"sha": "46a4da10f5b00da1091d9641836f0550ce9a5120", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZhNGRhMTBmNWIwMGRhMTA5MWQ5NjQxODM2ZjA1NTBjZTlhNTEyMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-09-24T19:14:51Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-09-24T19:14:51Z"}, "message": "extend.texi: (attribute leaf): Document.\n\n\n\t* doc/extend.texi: (attribute leaf): Document.\n\t* tree.c (local_define_builtin): Handle ECF_LEAF.\n\t(build_common_builtin_nodes): Set ECF_LEAF where needed.\n\t* tree.h (ECF_LEAF): New.\n\t* ipa-reference.c (propagate_bits): For leaf calls propagate ever overwrittable\n\tand unavailable functions.\n\t(ipa_init): Put all_module_statics into optimization_summary_obstack.\n\t(copy_global_bitmap): Do not copy all_module_statics.\n\t(read_write_all_from_decl): Use cgraph_node argument; handle ECF_LEAF.\n\t(propagate): Handle overwritable and unavailable leaf functions;\n\tinitialize global info for overwritable and unavailable leaf functions;\n\tdo not free all module statics.\n\t(ipa_reference_get_not_read_global, ipa_reference_get_not_written_global):\n\tleaf calls don't clobber local statics.\n\t* calls.c (flags_from_decl_or_type): Handle leaf.\n\t* tree-cfg.c (stmt_can_make_abnormal_goto): Leaf functions can't do\n\tabnormal gotos.\n\n\t* c-common.c (handle_leaf_attribute): New function.\n\t(struct attribute_spec c_common_att): Add leaf.\n\n\t* gcc.dg/tree-ssa/leaf.c: New testcase.\n\nFrom-SVN: r164606", "tree": {"sha": "3586ff30f00807c4e59b1bf02ac5e21a1cdad147", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3586ff30f00807c4e59b1bf02ac5e21a1cdad147"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46a4da10f5b00da1091d9641836f0550ce9a5120", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46a4da10f5b00da1091d9641836f0550ce9a5120", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46a4da10f5b00da1091d9641836f0550ce9a5120", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46a4da10f5b00da1091d9641836f0550ce9a5120/comments", "author": null, "committer": null, "parents": [{"sha": "e1b793e7c10393b112937ce3e7de4db903052618", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1b793e7c10393b112937ce3e7de4db903052618", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1b793e7c10393b112937ce3e7de4db903052618"}], "stats": {"total": 189, "additions": 168, "deletions": 21}, "files": [{"sha": "e4660af4973a48bc6e9ac6463f20d6b352f517f3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a4da10f5b00da1091d9641836f0550ce9a5120/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a4da10f5b00da1091d9641836f0550ce9a5120/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=46a4da10f5b00da1091d9641836f0550ce9a5120", "patch": "@@ -1,3 +1,22 @@\n+2010-09-24  Jan Hubicka  <jh@suse.cz>\n+\n+\t* doc/extend.texi: (attribute leaf): Document.\n+\t* tree.c (local_define_builtin): Handle ECF_LEAF.\n+\t(build_common_builtin_nodes): Set ECF_LEAF where needed.\n+\t* tree.h (ECF_LEAF): New.\n+\t* ipa-reference.c (propagate_bits): For leaf calls propagate ever overwrittable\n+\tand unavailable functions.\n+\t(ipa_init): Put all_module_statics into optimization_summary_obstack.\n+\t(copy_global_bitmap): Do not copy all_module_statics.\n+\t(read_write_all_from_decl): Use cgraph_node argument; handle ECF_LEAF.\n+\t(propagate): Handle overwritable and unavailable leaf functions;\n+\tinitialize global info for overwritable and unavailable leaf functions;\n+\tdo not free all module statics.\n+\t(ipa_reference_get_not_read_global, ipa_reference_get_not_written_global):\n+\tleaf calls don't clobber local statics.\n+\t* calls.c (flags_from_decl_or_type): Handle leaf.\n+\t* tree-cfg.c (stmt_can_make_abnormal_goto): Leaf functions can't do\n+\tabnormal gotos.\n \n 2010-09-24  Basile Starynkevitch  <basile@starynkevitch.net>\n "}, {"sha": "7d3e3dddf7cc080ecc3dbc1641c8edacdad9c308", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a4da10f5b00da1091d9641836f0550ce9a5120/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a4da10f5b00da1091d9641836f0550ce9a5120/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=46a4da10f5b00da1091d9641836f0550ce9a5120", "patch": "@@ -1,3 +1,8 @@\n+2010-09-24  Jan Hubicka  <jh@suse.cz>\n+\n+\t* c-common.c (handle_leaf_attribute): New function.\n+\t(struct attribute_spec c_common_att): Add leaf.\n+\n 2010-09-22  Joseph Myers  <joseph@codesourcery.com>\n \n \t* c.opt (-all-warnings, -ansi, -assert, -assert=, -comments,"}, {"sha": "6ef3bf99542bf07cbca4dff5fd4d5eab746cd7d7", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a4da10f5b00da1091d9641836f0550ce9a5120/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a4da10f5b00da1091d9641836f0550ce9a5120/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=46a4da10f5b00da1091d9641836f0550ce9a5120", "patch": "@@ -308,6 +308,7 @@ static tree handle_hot_attribute (tree *, tree, tree, int, bool *);\n static tree handle_cold_attribute (tree *, tree, tree, int, bool *);\n static tree handle_noinline_attribute (tree *, tree, tree, int, bool *);\n static tree handle_noclone_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_leaf_attribute (tree *, tree, tree, int, bool *);\n static tree handle_always_inline_attribute (tree *, tree, tree, int,\n \t\t\t\t\t    bool *);\n static tree handle_gnu_inline_attribute (tree *, tree, tree, int, bool *);\n@@ -570,6 +571,8 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      handle_noinline_attribute },\n   { \"noclone\",                0, 0, true,  false, false,\n \t\t\t      handle_noclone_attribute },\n+  { \"leaf\",                   0, 0, true,  false, false,\n+\t\t\t      handle_leaf_attribute },\n   { \"always_inline\",          0, 0, true,  false, false,\n \t\t\t      handle_always_inline_attribute },\n   { \"gnu_inline\",             0, 0, true,  false, false,\n@@ -5873,6 +5876,28 @@ handle_gnu_inline_attribute (tree *node, tree name,\n   return NULL_TREE;\n }\n \n+/* Handle a \"leaf\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_leaf_attribute (tree *node, tree name,\n+\t\t       tree ARG_UNUSED (args),\n+\t\t       int ARG_UNUSED (flags), bool *no_add_attrs)\n+{\n+  if (TREE_CODE (*node) != FUNCTION_DECL)\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      *no_add_attrs = true;\n+    }\n+  if (!TREE_PUBLIC (*node))\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute has no effect on unit local functions\", name);\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Handle an \"artificial\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n "}, {"sha": "9a4768a32bd228c9dd4314439bfea1c2ffb3d142", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a4da10f5b00da1091d9641836f0550ce9a5120/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a4da10f5b00da1091d9641836f0550ce9a5120/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=46a4da10f5b00da1091d9641836f0550ce9a5120", "patch": "@@ -610,6 +610,8 @@ flags_from_decl_or_type (const_tree exp)\n \n       if (DECL_IS_NOVOPS (exp))\n \tflags |= ECF_NOVOPS;\n+      if (lookup_attribute (\"leaf\", DECL_ATTRIBUTES (exp)))\n+\tflags |= ECF_LEAF;\n \n       if (TREE_NOTHROW (exp))\n \tflags |= ECF_NOTHROW;"}, {"sha": "7073c902abd3a75a0596861b76e439246f1250cd", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a4da10f5b00da1091d9641836f0550ce9a5120/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a4da10f5b00da1091d9641836f0550ce9a5120/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=46a4da10f5b00da1091d9641836f0550ce9a5120", "patch": "@@ -2671,6 +2671,31 @@ SRAM. The function will be put into a specific section named\n @code{.l1.text}. With @option{-mfdpic}, callers of such functions will use\n an inlined PLT.\n \n+@item leaf\n+@cindex @code{leaf} function attribute\n+Calls to external functions with this attribute must return to the current\n+compilation unit only by return or by exception handling. In particular, leaf\n+functions are not allowed to call callback function passed to it from current\n+compilation unit or directly call functions exported by the unit or longjmp\n+into the unit.  Still leaf function might call functions from other complation\n+units and thus they are not neccesarily leaf in the sense that they contains no\n+function calls at all.\n+\n+The attribute is intended for library functions to improve dataflow analysis.\n+Compiler takes the hint that any data not escaping current compilation unit can\n+not be used or modified by the leaf function.  For example, function @code{sin}\n+is leaf, function @code{qsort} is not.\n+\n+Note that the leaf functions might invoke signals and signal handlers might be\n+defined in the current compilation unit and use static variables. Only\n+compliant way to write such a signal handler is to declare such variables\n+@code{volatile}.\n+\n+The attribute has no effect on functions defined within current compilation\n+unit.  This is to allow easy merging of multiple compilation units into one,\n+for example, by using the link time optimization.  For this reason the\n+attribute is not allowed on types to annotate indirect calls.\n+\n @item long_call/short_call\n @cindex indirect calls on ARM\n This attribute specifies how a particular function is called on"}, {"sha": "96482f128263f3e9ccc440da878f6f4f0638af13", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 46, "deletions": 6, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a4da10f5b00da1091d9641836f0550ce9a5120/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a4da10f5b00da1091d9641836f0550ce9a5120/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=46a4da10f5b00da1091d9641836f0550ce9a5120", "patch": "@@ -200,6 +200,8 @@ ipa_reference_get_not_read_global (struct cgraph_node *fn)\n   info = get_reference_optimization_summary (fn);\n   if (info)\n     return info->statics_not_read;\n+  else if (flags_from_decl_or_type (fn->decl) & ECF_LEAF)\n+    return all_module_statics;\n   else\n     return NULL;\n }\n@@ -217,6 +219,8 @@ ipa_reference_get_not_written_global (struct cgraph_node *fn)\n   info = get_reference_optimization_summary (fn);\n   if (info)\n     return info->statics_not_written;\n+  else if (flags_from_decl_or_type (fn->decl) & ECF_LEAF)\n+    return all_module_statics;\n   else\n     return NULL;\n }\n@@ -299,9 +303,13 @@ propagate_bits (ipa_reference_global_vars_info_t x_global, struct cgraph_node *x\n   for (e = x->callees; e; e = e->next_callee)\n     {\n       struct cgraph_node *y = e->callee;\n+      enum availability avail;\n \n+      avail = cgraph_function_body_availability (e->callee);\n       /* Only look into nodes we can propagate something.  */\n-      if (cgraph_function_body_availability (e->callee) > AVAIL_OVERWRITABLE)\n+      if (avail > AVAIL_OVERWRITABLE\n+\t  || (avail == AVAIL_OVERWRITABLE\n+\t      && (flags_from_decl_or_type (e->callee->decl) & ECF_LEAF)))\n \t{\n \t  int flags = flags_from_decl_or_type (e->callee->decl);\n \t  if (get_reference_vars_info (y))\n@@ -573,17 +581,28 @@ read_write_all_from_decl (struct cgraph_node *node, bool * read_all,\n {\n   tree decl = node->decl;\n   int flags = flags_from_decl_or_type (decl);\n-  if (flags & ECF_CONST)\n+  if ((flags & ECF_LEAF)\n+      && cgraph_function_body_availability (node) <= AVAIL_OVERWRITABLE)\n+    ;\n+  else if (flags & ECF_CONST)\n     ;\n   else if ((flags & ECF_PURE)\n \t   || cgraph_node_cannot_return (node))\n-    *read_all = true;\n+    {\n+      *read_all = true;\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+         fprintf (dump_file, \"   %s/%i -> read all\\n\",\n+\t\t  cgraph_node_name (node), node->uid);\n+    }\n   else\n     {\n        /* TODO: To be able to produce sane results, we should also handle\n \t  common builtins, in particular throw.  */\n       *read_all = true;\n       *write_all = true;\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+         fprintf (dump_file, \"   %s/%i -> read all, write all\\n\",\n+\t\t  cgraph_node_name (node), node->uid);\n     }\n }\n \n@@ -629,6 +648,11 @@ propagate (void)\n       node_info = get_reference_vars_info (node);\n       gcc_assert (node_info);\n \n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"Starting cycle with %s/%i\\n\",\n+\t\t  cgraph_node_name (node), node->uid);\n+\n       node_l = &node_info->local;\n       node_g = &node_info->global;\n \n@@ -647,9 +671,15 @@ propagate (void)\n \tif (!(ie->indirect_info->ecf_flags & ECF_CONST))\n \t  {\n \t    read_all = true;\n+\t    if (dump_file && (dump_flags & TDF_DETAILS))\n+\t       fprintf (dump_file, \"   indirect call -> read all\\n\");\n \t    if (!cgraph_edge_cannot_lead_to_return (ie)\n \t\t&& !(ie->indirect_info->ecf_flags & ECF_PURE))\n-\t      write_all = true;\n+\t      {\n+\t\tif (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t   fprintf (dump_file, \"   indirect call -> write all\\n\");\n+\t        write_all = true;\n+\t      }\n \t  }\n \n \n@@ -659,6 +689,9 @@ propagate (void)\n       w = w_info->next_cycle;\n       while (w && (!read_all || !write_all))\n \t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"  Visiting %s/%i\\n\",\n+\t\t      cgraph_node_name (w), w->uid);\n \t  /* When function is overwrittable, we can not assume anything.  */\n \t  if (cgraph_function_body_availability (w) <= AVAIL_OVERWRITABLE)\n \t    read_write_all_from_decl (w, &read_all, &write_all);\n@@ -671,9 +704,15 @@ propagate (void)\n \t    if (!(ie->indirect_info->ecf_flags & ECF_CONST))\n \t      {\n \t\tread_all = true;\n+\t\tif (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t   fprintf (dump_file, \"   indirect call -> read all\\n\");\n \t\tif (!cgraph_edge_cannot_lead_to_return (ie)\n \t\t    && !(ie->indirect_info->ecf_flags & ECF_PURE))\n-\t\t  write_all = true;\n+\t\t  {\n+\t\t    write_all = true;\n+\t\t    if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t       fprintf (dump_file, \"   indirect call -> write all\\n\");\n+\t\t  }\n \t      }\n \n \t  w_info = (struct ipa_dfs_info *) w->aux;\n@@ -841,7 +880,8 @@ propagate (void)\n         continue;\n \n       node_info = get_reference_vars_info (node);\n-      if (cgraph_function_body_availability (node) > AVAIL_OVERWRITABLE)\n+      if (cgraph_function_body_availability (node) > AVAIL_OVERWRITABLE\n+\t  || (flags_from_decl_or_type (node->decl) & ECF_LEAF))\n \t{\n \t  node_g = &node_info->global;\n "}, {"sha": "30ef6fd569088df334188ab62d5ab0f1ab5b73d9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a4da10f5b00da1091d9641836f0550ce9a5120/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a4da10f5b00da1091d9641836f0550ce9a5120/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=46a4da10f5b00da1091d9641836f0550ce9a5120", "patch": "@@ -1,3 +1,7 @@\n+2010-09-24  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/leaf.c: New testcase.\n+\n 2010-09-24  Jan Hubicka  <jh@suse.cz>\n \n \tPR tree-optimization/45738"}, {"sha": "936523a930d5268fb4e1c18d62ac6c302c91a611", "filename": "gcc/testsuite/gcc.dg/tree-ssa/leaf.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a4da10f5b00da1091d9641836f0550ce9a5120/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fleaf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a4da10f5b00da1091d9641836f0550ce9a5120/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fleaf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fleaf.c?ref=46a4da10f5b00da1091d9641836f0550ce9a5120", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+static int local_static;\n+void __attribute__ ((leaf)) leaf_call (void);\n+\n+int\n+clobber_it (void)\n+{\n+  return local_static++;\n+}\n+int\n+test (void)\n+{\n+  local_static = 9;\n+  leaf_call ();\n+  return local_static;\n+}\n+/* { dg-final { scan-tree-dump-times \"return 9\" 1 \"optimized\"} } */\n+ \n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "cf67fb8613efb0bf7820beb638f30388573dbe64", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a4da10f5b00da1091d9641836f0550ce9a5120/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a4da10f5b00da1091d9641836f0550ce9a5120/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=46a4da10f5b00da1091d9641836f0550ce9a5120", "patch": "@@ -2258,7 +2258,8 @@ is_ctrl_altering_stmt (gimple t)\n \n \t/* A non-pure/const call alters flow control if the current\n \t   function has nonlocal labels.  */\n-\tif (!(flags & (ECF_CONST | ECF_PURE)) && cfun->has_nonlocal_label)\n+\tif (!(flags & (ECF_CONST | ECF_PURE | ECF_LEAF))\n+\t    && cfun->has_nonlocal_label)\n \t  return true;\n \n \t/* A call also alters control flow if it does not return.  */\n@@ -2314,7 +2315,8 @@ stmt_can_make_abnormal_goto (gimple t)\n   if (computed_goto_p (t))\n     return true;\n   if (is_gimple_call (t))\n-    return gimple_has_side_effects (t) && cfun->has_nonlocal_label;\n+    return (gimple_has_side_effects (t) && cfun->has_nonlocal_label\n+\t    && !(gimple_call_flags (t) & ECF_LEAF));\n   return false;\n }\n "}, {"sha": "738fa9cdbe83b0cd1af40ef76fcc0ec55f214a9a", "filename": "gcc/tree.c", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a4da10f5b00da1091d9641836f0550ce9a5120/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a4da10f5b00da1091d9641836f0550ce9a5120/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=46a4da10f5b00da1091d9641836f0550ce9a5120", "patch": "@@ -9224,6 +9224,9 @@ local_define_builtin (const char *name, tree type, enum built_in_function code,\n     TREE_NOTHROW (decl) = 1;\n   if (ecf_flags & ECF_MALLOC)\n     DECL_IS_MALLOC (decl) = 1;\n+  if (ecf_flags & ECF_LEAF)\n+    DECL_ATTRIBUTES (decl) = tree_cons (get_identifier (\"leaf\"),\n+\t\t\t\t\tNULL, DECL_ATTRIBUTES (decl));\n \n   built_in_decls[code] = decl;\n   implicit_built_in_decls[code] = decl;\n@@ -9247,10 +9250,10 @@ build_common_builtin_nodes (void)\n \n       if (built_in_decls[BUILT_IN_MEMCPY] == NULL)\n \tlocal_define_builtin (\"__builtin_memcpy\", ftype, BUILT_IN_MEMCPY,\n-\t\t\t      \"memcpy\", ECF_NOTHROW);\n+\t\t\t      \"memcpy\", ECF_NOTHROW | ECF_LEAF);\n       if (built_in_decls[BUILT_IN_MEMMOVE] == NULL)\n \tlocal_define_builtin (\"__builtin_memmove\", ftype, BUILT_IN_MEMMOVE,\n-\t\t\t      \"memmove\", ECF_NOTHROW);\n+\t\t\t      \"memmove\", ECF_NOTHROW | ECF_LEAF);\n     }\n \n   if (built_in_decls[BUILT_IN_MEMCMP] == NULL)\n@@ -9259,7 +9262,7 @@ build_common_builtin_nodes (void)\n \t\t\t\t\tconst_ptr_type_node, size_type_node,\n \t\t\t\t\tNULL_TREE);\n       local_define_builtin (\"__builtin_memcmp\", ftype, BUILT_IN_MEMCMP,\n-\t\t\t    \"memcmp\", ECF_PURE | ECF_NOTHROW);\n+\t\t\t    \"memcmp\", ECF_PURE | ECF_NOTHROW | ECF_LEAF);\n     }\n \n   if (built_in_decls[BUILT_IN_MEMSET] == NULL)\n@@ -9268,15 +9271,15 @@ build_common_builtin_nodes (void)\n \t\t\t\t\tptr_type_node, integer_type_node,\n \t\t\t\t\tsize_type_node, NULL_TREE);\n       local_define_builtin (\"__builtin_memset\", ftype, BUILT_IN_MEMSET,\n-\t\t\t    \"memset\", ECF_NOTHROW);\n+\t\t\t    \"memset\", ECF_NOTHROW | ECF_LEAF);\n     }\n \n   if (built_in_decls[BUILT_IN_ALLOCA] == NULL)\n     {\n       ftype = build_function_type_list (ptr_type_node,\n \t\t\t\t\tsize_type_node, NULL_TREE);\n       local_define_builtin (\"__builtin_alloca\", ftype, BUILT_IN_ALLOCA,\n-\t\t\t    \"alloca\", ECF_MALLOC | ECF_NOTHROW);\n+\t\t\t    \"alloca\", ECF_MALLOC | ECF_NOTHROW | ECF_LEAF);\n     }\n \n   /* If we're checking the stack, `alloca' can throw.  */\n@@ -9288,7 +9291,7 @@ build_common_builtin_nodes (void)\n \t\t\t\t    ptr_type_node, NULL_TREE);\n   local_define_builtin (\"__builtin_init_trampoline\", ftype,\n \t\t\tBUILT_IN_INIT_TRAMPOLINE,\n-\t\t\t\"__builtin_init_trampoline\", ECF_NOTHROW);\n+\t\t\t\"__builtin_init_trampoline\", ECF_NOTHROW | ECF_LEAF);\n \n   ftype = build_function_type_list (ptr_type_node, ptr_type_node, NULL_TREE);\n   local_define_builtin (\"__builtin_adjust_trampoline\", ftype,\n@@ -9322,12 +9325,12 @@ build_common_builtin_nodes (void)\n \n   ftype = build_function_type_list (ptr_type_node, NULL_TREE);\n   local_define_builtin (\"__builtin_stack_save\", ftype, BUILT_IN_STACK_SAVE,\n-\t\t\t\"__builtin_stack_save\", ECF_NOTHROW);\n+\t\t\t\"__builtin_stack_save\", ECF_NOTHROW | ECF_LEAF);\n \n   ftype = build_function_type_list (void_type_node, ptr_type_node, NULL_TREE);\n   local_define_builtin (\"__builtin_stack_restore\", ftype,\n \t\t\tBUILT_IN_STACK_RESTORE,\n-\t\t\t\"__builtin_stack_restore\", ECF_NOTHROW);\n+\t\t\t\"__builtin_stack_restore\", ECF_NOTHROW | ECF_LEAF);\n \n   ftype = build_function_type_list (void_type_node, NULL_TREE);\n   local_define_builtin (\"__builtin_profile_func_enter\", ftype,\n@@ -9342,7 +9345,7 @@ build_common_builtin_nodes (void)\n       ftype = build_function_type_list (void_type_node, NULL_TREE);\n       local_define_builtin (\"__builtin_cxa_end_cleanup\", ftype,\n \t\t\t    BUILT_IN_CXA_END_CLEANUP,\n-\t\t\t    \"__cxa_end_cleanup\", ECF_NORETURN);\n+\t\t\t    \"__cxa_end_cleanup\", ECF_NORETURN | ECF_LEAF);\n     }\n \n   ftype = build_function_type_list (void_type_node, ptr_type_node, NULL_TREE);\n@@ -9361,12 +9364,12 @@ build_common_builtin_nodes (void)\n   ftype = build_function_type_list (ptr_type_node,\n \t\t\t\t    integer_type_node, NULL_TREE);\n   local_define_builtin (\"__builtin_eh_pointer\", ftype, BUILT_IN_EH_POINTER,\n-\t\t\t\"__builtin_eh_pointer\", ECF_PURE | ECF_NOTHROW);\n+\t\t\t\"__builtin_eh_pointer\", ECF_PURE | ECF_NOTHROW | ECF_LEAF);\n \n   tmp = lang_hooks.types.type_for_mode (targetm.eh_return_filter_mode (), 0);\n   ftype = build_function_type_list (tmp, integer_type_node, NULL_TREE);\n   local_define_builtin (\"__builtin_eh_filter\", ftype, BUILT_IN_EH_FILTER,\n-\t\t\t\"__builtin_eh_filter\", ECF_PURE | ECF_NOTHROW);\n+\t\t\t\"__builtin_eh_filter\", ECF_PURE | ECF_NOTHROW | ECF_LEAF);\n \n   ftype = build_function_type_list (void_type_node,\n \t\t\t\t    integer_type_node, integer_type_node,\n@@ -9408,11 +9411,11 @@ build_common_builtin_nodes (void)\n \n \tbuilt_in_names[mcode] = concat (\"__mul\", mode_name_buf, \"3\", NULL);\n         local_define_builtin (built_in_names[mcode], ftype, mcode,\n-\t\t\t      built_in_names[mcode], ECF_CONST | ECF_NOTHROW);\n+\t\t\t      built_in_names[mcode], ECF_CONST | ECF_NOTHROW | ECF_LEAF);\n \n \tbuilt_in_names[dcode] = concat (\"__div\", mode_name_buf, \"3\", NULL);\n         local_define_builtin (built_in_names[dcode], ftype, dcode,\n-\t\t\t      built_in_names[dcode], ECF_CONST | ECF_NOTHROW);\n+\t\t\t      built_in_names[dcode], ECF_CONST | ECF_NOTHROW | ECF_LEAF);\n       }\n   }\n }"}, {"sha": "1b843f869a40ecc34b6222e8758e7d85ecbfea6c", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a4da10f5b00da1091d9641836f0550ce9a5120/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a4da10f5b00da1091d9641836f0550ce9a5120/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=46a4da10f5b00da1091d9641836f0550ce9a5120", "patch": "@@ -5224,6 +5224,8 @@ extern tree build_duplicate_type (tree);\n /* Function does not read or write memory (but may have side effects, so\n    it does not necessarily fit ECF_CONST).  */\n #define ECF_NOVOPS\t\t  (1 << 9)\n+/* The function does not lead to calls within current function unit.  */\n+#define ECF_LEAF\t\t  (1 << 10)\n \n extern int flags_from_decl_or_type (const_tree);\n extern int call_expr_flags (const_tree);"}]}