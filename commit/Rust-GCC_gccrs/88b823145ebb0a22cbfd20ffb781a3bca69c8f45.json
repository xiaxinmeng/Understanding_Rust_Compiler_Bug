{"sha": "88b823145ebb0a22cbfd20ffb781a3bca69c8f45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhiODIzMTQ1ZWJiMGEyMmNiZmQyMGZmYjc4MWEzYmNhNjljOGY0NQ==", "commit": {"author": {"name": "Doug Gregor", "email": "dgregor@gcc.gnu.org", "date": "2007-10-30T13:36:34Z"}, "committer": {"name": "Doug Gregor", "email": "dgregor@gcc.gnu.org", "date": "2007-10-30T13:36:34Z"}, "message": "re PR c++/31993 (ICE with template class in variadic template class)\n\n2007-10-30  Douglas Gregor  <doug.gregor@gmail.com>\n\n\tPR c++/31993\n\tPR c++/32252\n\t* pt.c (find_parameter_packs_r): Fix typo in comment.\n\t(convert_template_argument): Look at the pattern of a pack\n\texpansion to determine what kind of entity we're converting.\n\t(coerce_template_parameter_pack): When we have coerced a non-type\n\ttemplate parameter pack, substitute into the type of that pack.\n\t(tsubst_pack_expansion): When our substitution of a parameter pack\n\tis a \"trivial\" substitution of itself, just substitute into the\n\tpack expansion rather than actually expanding.\n\n2007-10-30  Douglas Gregor  <doug.gregor@gmail.com>\n\n\tPR c++/31993\n\tPR c++/32252\n\t* g++.dg/cpp0x/pr31993.C: New\n\t* g++.dg/cpp0x/pr32252.C: New\n\nFrom-SVN: r129773", "tree": {"sha": "7361b26a0031a395f87ecf7275303a233b1042a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7361b26a0031a395f87ecf7275303a233b1042a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88b823145ebb0a22cbfd20ffb781a3bca69c8f45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88b823145ebb0a22cbfd20ffb781a3bca69c8f45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88b823145ebb0a22cbfd20ffb781a3bca69c8f45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88b823145ebb0a22cbfd20ffb781a3bca69c8f45/comments", "author": null, "committer": null, "parents": [{"sha": "310750d8ec5621e9f4c33db6b18de319cd7bc7f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/310750d8ec5621e9f4c33db6b18de319cd7bc7f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/310750d8ec5621e9f4c33db6b18de319cd7bc7f1"}], "stats": {"total": 126, "additions": 89, "deletions": 37}, "files": [{"sha": "d5b73e797cb85efa2384c7a33241c65a2b91fb2c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b823145ebb0a22cbfd20ffb781a3bca69c8f45/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b823145ebb0a22cbfd20ffb781a3bca69c8f45/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=88b823145ebb0a22cbfd20ffb781a3bca69c8f45", "patch": "@@ -1,3 +1,16 @@\n+2007-10-30  Douglas Gregor  <doug.gregor@gmail.com>\n+\n+\tPR c++/31993\n+\tPR c++/32252\n+\t* pt.c (find_parameter_packs_r): Fix typo in comment.\n+\t(convert_template_argument): Look at the pattern of a pack\n+\texpansion to determine what kind of entity we're converting.\n+\t(coerce_template_parameter_pack): When we have coerced a non-type\n+\ttemplate parameter pack, substitute into the type of that pack.\n+\t(tsubst_pack_expansion): When our substitution of a parameter pack\n+\tis a \"trivial\" substitution of itself, just substitute into the\n+\tpack expansion rather than actually expanding.\n+\n 2007-10-29  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/33841"}, {"sha": "5f6e29690d2cedeb2c6a0780c6aa553571cf8a43", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 50, "deletions": 36, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b823145ebb0a22cbfd20ffb781a3bca69c8f45/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b823145ebb0a22cbfd20ffb781a3bca69c8f45/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=88b823145ebb0a22cbfd20ffb781a3bca69c8f45", "patch": "@@ -2426,9 +2426,9 @@ struct find_parameter_pack_data\n   struct pointer_set_t *visited;\n };\n \n-/* Identifiers all of the argument packs that occur in a template\n+/* Identifies all of the argument packs that occur in a template\n    argument and appends them to the TREE_LIST inside DATA, which is a\n-   find_parameter_pack_Data structure. This is a subroutine of\n+   find_parameter_pack_data structure. This is a subroutine of\n    make_pack_expansion and uses_parameter_packs.  */\n static tree\n find_parameter_packs_r (tree *tp, int *walk_subtrees, void* data)\n@@ -4668,9 +4668,9 @@ convert_template_argument (tree parm,\n \t\t\t   int i,\n \t\t\t   tree in_decl)\n {\n+  tree orig_arg;\n   tree val;\n   int is_type, requires_type, is_tmpl_type, requires_tmpl_type;\n-  tree check_arg = arg;\n \n   if (TREE_CODE (arg) == TREE_LIST\n       && TREE_CODE (TREE_VALUE (arg)) == OFFSET_REF)\n@@ -4680,24 +4680,26 @@ convert_template_argument (tree parm,\n \t invalid, but static members are OK.  In any\n \t case, grab the underlying fields/functions\n \t and issue an error later if required.  */\n-      arg = TREE_VALUE (arg);\n+      orig_arg = TREE_VALUE (arg);\n       TREE_TYPE (arg) = unknown_type_node;\n     }\n \n+  orig_arg = arg;\n+\n   requires_tmpl_type = TREE_CODE (parm) == TEMPLATE_DECL;\n   requires_type = (TREE_CODE (parm) == TYPE_DECL\n \t\t   || requires_tmpl_type);\n \n   /* When determining whether an argument pack expansion is a template,\n      look at the pattern.  */\n-  if (TREE_CODE (check_arg) == TYPE_PACK_EXPANSION)\n-    check_arg = PACK_EXPANSION_PATTERN (check_arg);\n+  if (TREE_CODE (arg) == TYPE_PACK_EXPANSION)\n+    arg = PACK_EXPANSION_PATTERN (arg);\n \n   is_tmpl_type = \n-    ((TREE_CODE (check_arg) == TEMPLATE_DECL\n-      && TREE_CODE (DECL_TEMPLATE_RESULT (check_arg)) == TYPE_DECL)\n-     || TREE_CODE (check_arg) == TEMPLATE_TEMPLATE_PARM\n-     || TREE_CODE (check_arg) == UNBOUND_CLASS_TEMPLATE);\n+    ((TREE_CODE (arg) == TEMPLATE_DECL\n+      && TREE_CODE (DECL_TEMPLATE_RESULT (arg)) == TYPE_DECL)\n+     || TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM\n+     || TREE_CODE (arg) == UNBOUND_CLASS_TEMPLATE);\n \n   if (is_tmpl_type\n       && (TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM\n@@ -4710,12 +4712,13 @@ convert_template_argument (tree parm,\n       && TREE_CODE (TREE_OPERAND (arg, 0)) == TEMPLATE_TYPE_PARM)\n     {\n       pedwarn (\"to refer to a type member of a template parameter, \"\n-\t       \"use %<typename %E%>\", arg);\n+\t       \"use %<typename %E%>\", orig_arg);\n \n-      arg = make_typename_type (TREE_OPERAND (arg, 0),\n-\t\t\t\tTREE_OPERAND (arg, 1),\n-\t\t\t\ttypename_type,\n-\t\t\t\tcomplain & tf_error);\n+      orig_arg = make_typename_type (TREE_OPERAND (arg, 0),\n+\t\t\t\t     TREE_OPERAND (arg, 1),\n+\t\t\t\t     typename_type,\n+\t\t\t\t     complain & tf_error);\n+      arg = orig_arg;\n       is_type = 1;\n     }\n   if (is_type != requires_type)\n@@ -4730,11 +4733,11 @@ convert_template_argument (tree parm,\n \t      if (is_type)\n \t\terror (\"  expected a constant of type %qT, got %qT\",\n \t\t       TREE_TYPE (parm),\n-\t\t       (is_tmpl_type ? DECL_NAME (arg) : arg));\n+\t\t       (is_tmpl_type ? DECL_NAME (arg) : orig_arg));\n \t      else if (requires_tmpl_type)\n-\t\terror (\"  expected a class template, got %qE\", arg);\n+\t\terror (\"  expected a class template, got %qE\", orig_arg);\n \t      else\n-\t\terror (\"  expected a type, got %qE\", arg);\n+\t\terror (\"  expected a type, got %qE\", orig_arg);\n \t    }\n \t}\n       return error_mark_node;\n@@ -4749,7 +4752,7 @@ convert_template_argument (tree parm,\n \t  if (is_tmpl_type)\n \t    error (\"  expected a type, got %qT\", DECL_NAME (arg));\n \t  else\n-\t    error (\"  expected a class template, got %qT\", arg);\n+\t    error (\"  expected a class template, got %qT\", orig_arg);\n \t}\n       return error_mark_node;\n     }\n@@ -4767,19 +4770,13 @@ convert_template_argument (tree parm,\n \t      tree parmparm = DECL_INNERMOST_TEMPLATE_PARMS (parm);\n \t      tree argparm;\n \n-              check_arg = arg;\n-              /* When determining whether a pack expansion is a template,\n-                 look at the pattern.  */\n-              if (TREE_CODE (check_arg) == TYPE_PACK_EXPANSION)\n-                check_arg = PACK_EXPANSION_PATTERN (check_arg);\n-\n-              argparm = DECL_INNERMOST_TEMPLATE_PARMS (check_arg);\n+              argparm = DECL_INNERMOST_TEMPLATE_PARMS (arg);\n \n \t      if (coerce_template_template_parms (parmparm, argparm,\n \t\t\t\t\t\t  complain, in_decl,\n \t\t\t\t\t\t  args))\n \t\t{\n-\t\t  val = arg;\n+\t\t  val = orig_arg;\n \n \t\t  /* TEMPLATE_TEMPLATE_PARM node is preferred over\n \t\t     TEMPLATE_DECL.  */\n@@ -4788,9 +4785,9 @@ convert_template_argument (tree parm,\n                       if (DECL_TEMPLATE_TEMPLATE_PARM_P (val))\n                         val = TREE_TYPE (val);\n                       else if (TREE_CODE (val) == TYPE_PACK_EXPANSION\n-                               && DECL_TEMPLATE_TEMPLATE_PARM_P (check_arg))\n+                               && DECL_TEMPLATE_TEMPLATE_PARM_P (arg))\n                         {\n-                          val = TREE_TYPE (check_arg);\n+                          val = TREE_TYPE (arg);\n                           val = make_pack_expansion (val);\n                         }\n                     }\n@@ -4803,15 +4800,15 @@ convert_template_argument (tree parm,\n \t\t\t     \"template parameter list for %qD\",\n \t\t\t     i + 1, in_decl);\n \t\t      error (\"  expected a template of type %qD, got %qD\",\n-\t\t\t     parm, arg);\n+\t\t\t     parm, orig_arg);\n \t\t    }\n \n \t\t  val = error_mark_node;\n \t\t}\n \t    }\n \t}\n       else\n-\tval = arg;\n+\tval = orig_arg;\n       /* We only form one instance of each template specialization.\n \t Therefore, if we use a non-canonical variant (i.e., a\n \t typedef), any future messages referring to the type will use\n@@ -4827,7 +4824,7 @@ convert_template_argument (tree parm,\n       if (invalid_nontype_parm_type_p (t, complain))\n \treturn error_mark_node;\n \n-      if (!uses_template_parms (arg) && !uses_template_parms (t))\n+      if (!uses_template_parms (orig_arg) && !uses_template_parms (t))\n \t/* We used to call digest_init here.  However, digest_init\n \t   will report errors, which we don't want when complain\n \t   is zero.  More importantly, digest_init will try too\n@@ -4838,14 +4835,14 @@ convert_template_argument (tree parm,\n \t   conversions can occur is part of determining which\n \t   function template to call, or whether a given explicit\n \t   argument specification is valid.  */\n-\tval = convert_nontype_argument (t, arg);\n+\tval = convert_nontype_argument (t, orig_arg);\n       else\n-\tval = arg;\n+\tval = orig_arg;\n \n       if (val == NULL_TREE)\n \tval = error_mark_node;\n       else if (val == error_mark_node && (complain & tf_error))\n-\terror (\"could not convert template argument %qE to %qT\",  arg, t);\n+\terror (\"could not convert template argument %qE to %qT\",  orig_arg, t);\n     }\n \n   return val;\n@@ -4959,7 +4956,8 @@ coerce_template_parameter_pack (tree parms,\n   else\n     {\n       argument_pack = make_node (NONTYPE_ARGUMENT_PACK);\n-      TREE_TYPE (argument_pack) = TREE_TYPE (TREE_VALUE (parm));\n+      TREE_TYPE (argument_pack) \n+        = tsubst (TREE_TYPE (TREE_VALUE (parm)), args, complain, in_decl);\n       TREE_CONSTANT (argument_pack) = 1;\n     }\n \n@@ -7108,6 +7106,22 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n \t  return result;\n \t}\n \n+      if (arg_pack\n+          && TREE_VEC_LENGTH (ARGUMENT_PACK_ARGS (arg_pack)) == 1\n+          && PACK_EXPANSION_P (TREE_VEC_ELT (ARGUMENT_PACK_ARGS (arg_pack), 0)))\n+        {\n+          tree expansion = TREE_VEC_ELT (ARGUMENT_PACK_ARGS (arg_pack), 0);\n+          tree pattern = PACK_EXPANSION_PATTERN (expansion);\n+          if ((TYPE_P (pattern) && same_type_p (pattern, parm_pack))\n+              || (!TYPE_P (pattern) && cp_tree_equal (parm_pack, pattern)))\n+            /* The argument pack that the parameter maps to is just an\n+               expansion of the parameter itself, such as one would\n+               find in the implicit typedef of a class inside the\n+               class itself.  Consider this parameter \"unsubstituted\",\n+               so that we will maintain the outer pack expansion.  */\n+            arg_pack = NULL_TREE;\n+        }\n+          \n       if (arg_pack)\n         {\n           int my_len = "}, {"sha": "0956218a9817d711c61f559e89c24af250b1e182", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b823145ebb0a22cbfd20ffb781a3bca69c8f45/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b823145ebb0a22cbfd20ffb781a3bca69c8f45/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=88b823145ebb0a22cbfd20ffb781a3bca69c8f45", "patch": "@@ -1,3 +1,10 @@\n+2007-10-30  Douglas Gregor  <doug.gregor@gmail.com>\n+\n+\tPR c++/31993\n+\tPR c++/32252\n+\t* g++.dg/cpp0x/pr31993.C: New\n+\t* g++.dg/cpp0x/pr32252.C: New\n+\n 2007-10-30  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/33723\n@@ -8,6 +15,7 @@\n \t* gcc.c-torture/execute/20071030-1.c: New testcase copied from\n \tgcc.target/i386/loop-3.c.\n \n+>>>>>>> .r129772\n 2007-10-30  Revital Eres  <eres@il.ibm.com>\n \n \t* testsuite/gcc.dg/vect/pr33866.c: Require vect_long."}, {"sha": "94fb9ccdab99b13aa9151f70821b76f969015143", "filename": "gcc/testsuite/g++.dg/cpp0x/pr31993.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b823145ebb0a22cbfd20ffb781a3bca69c8f45/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31993.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b823145ebb0a22cbfd20ffb781a3bca69c8f45/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31993.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr31993.C?ref=88b823145ebb0a22cbfd20ffb781a3bca69c8f45", "patch": "@@ -0,0 +1,9 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+template<typename...> struct A;\n+\n+template<template<int> class... T> struct A<T<0>...>\n+{\n+  template<int> struct B {};\n+  B<0> b;\n+};"}, {"sha": "543dc8873908e3052ad72690d117f6d56a7d7208", "filename": "gcc/testsuite/g++.dg/cpp0x/pr32252.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b823145ebb0a22cbfd20ffb781a3bca69c8f45/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr32252.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b823145ebb0a22cbfd20ffb781a3bca69c8f45/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr32252.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr32252.C?ref=88b823145ebb0a22cbfd20ffb781a3bca69c8f45", "patch": "@@ -0,0 +1,8 @@\n+// { dg-options \"-std=c++0x\" }\n+int x[5];\n+\n+template<int M, int N, int (&... p)[N]> struct A;\n+\n+template<int M> struct A<M,5,x> {};\n+\n+A<0,5,x> a;  "}, {"sha": "e73e928350d4f6177eabe3437391886f9304b9ca", "filename": "gcc/testsuite/g++.dg/parse/crash36.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b823145ebb0a22cbfd20ffb781a3bca69c8f45/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash36.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b823145ebb0a22cbfd20ffb781a3bca69c8f45/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash36.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash36.C?ref=88b823145ebb0a22cbfd20ffb781a3bca69c8f45", "patch": "@@ -5,7 +5,7 @@\n template <typename... T> struct A\t// { dg-error \"does not include variadic templates\" }\n {\n   static T &t;\t\t\t\t// { dg-error \"not expanded with|T\" }\n-  static const int i = sizeof (++t);\t// { dg-error \"invalid use of template type parameter\" }\n+  static const int i = sizeof (++t);\n };\n \n int x[A <int>::i];\t// { dg-error \"is not an integral constant-expression\" }"}]}