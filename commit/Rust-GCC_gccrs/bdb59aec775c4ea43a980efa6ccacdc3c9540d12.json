{"sha": "bdb59aec775c4ea43a980efa6ccacdc3c9540d12", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmRiNTlhZWM3NzVjNGVhNDNhOTgwZWZhNmNjYWNkYzNjOTU0MGQxMg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "1999-02-24T13:47:39Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-02-24T13:47:39Z"}, "message": "gjavah.c (struct namelet): New structure.\n\n\t* gjavah.c (struct namelet): New structure.\n\t(add_namelet): New function.\n\t(print_namelet): New function.\n\t(print_class_decls): Use add_namelet and print_namelet to generate\n\tnamespaces and not classes.\n\t(method_printed): New global.\n\t(HANDLE_END_METHOD): Examine method_printed.\n\t(print_method_info): Set method_printed when required.  Print\n\terror if function to be ignored is marked virtual.  Handle $finit$\n\tmethod.\n\t(METHOD_IS_FINAL): New macro.\n\t(print_field_info): Use it.\n\t(HANDLE_METHOD): Clear method_printed.\n\t(method_pass): New global.\n\t(HANDLE_END_FIELD): Call add_class_decl on the first pass.\n\t(process_file): Do two passes over both fields and methods.\n\t(HANDLE_METHOD): Examine method_pass.\n\t(root): New global.\n\t(add_class_decl): New function.\n\t(print_class_decls): Don't scan over entire constant pool.\n\nFrom-SVN: r25403", "tree": {"sha": "d69df26a5c83842fd59c5587dfe4b063f95c6466", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d69df26a5c83842fd59c5587dfe4b063f95c6466"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bdb59aec775c4ea43a980efa6ccacdc3c9540d12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdb59aec775c4ea43a980efa6ccacdc3c9540d12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdb59aec775c4ea43a980efa6ccacdc3c9540d12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdb59aec775c4ea43a980efa6ccacdc3c9540d12/comments", "author": null, "committer": null, "parents": [{"sha": "46f40127a279a44341defa54a2410d7a95738346", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46f40127a279a44341defa54a2410d7a95738346", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46f40127a279a44341defa54a2410d7a95738346"}], "stats": {"total": 335, "additions": 284, "deletions": 51}, "files": [{"sha": "993ca19e69de379496f680a6af0637392cecb4e5", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb59aec775c4ea43a980efa6ccacdc3c9540d12/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb59aec775c4ea43a980efa6ccacdc3c9540d12/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=bdb59aec775c4ea43a980efa6ccacdc3c9540d12", "patch": "@@ -1,3 +1,26 @@\n+1999-02-24  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* gjavah.c (struct namelet): New structure.\n+\t(add_namelet): New function.\n+\t(print_namelet): New function.\n+\t(print_class_decls): Use add_namelet and print_namelet to generate\n+\tnamespaces and not classes.\n+\t(method_printed): New global.\n+\t(HANDLE_END_METHOD): Examine method_printed.\n+\t(print_method_info): Set method_printed when required.  Print\n+\terror if function to be ignored is marked virtual.  Handle $finit$\n+\tmethod.\n+\t(METHOD_IS_FINAL): New macro.\n+\t(print_field_info): Use it.\n+\t(HANDLE_METHOD): Clear method_printed.\n+\t(method_pass): New global.\n+\t(HANDLE_END_FIELD): Call add_class_decl on the first pass.\n+\t(process_file): Do two passes over both fields and methods.\n+\t(HANDLE_METHOD): Examine method_pass.\n+\t(root): New global.\n+\t(add_class_decl): New function.\n+\t(print_class_decls): Don't scan over entire constant pool.\n+\n 1999-02-23  Tom Tromey  <tromey@cygnus.com>\n \n \t* jvspec.c (lang_specific_driver): Recognize -fsyntax-only and"}, {"sha": "986ed1ff92ff61d4ae32d63a9227bee0b9ceb12c", "filename": "gcc/java/gjavah.c", "status": "modified", "additions": 261, "deletions": 51, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb59aec775c4ea43a980efa6ccacdc3c9540d12/gcc%2Fjava%2Fgjavah.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb59aec775c4ea43a980efa6ccacdc3c9540d12/gcc%2Fjava%2Fgjavah.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgjavah.c?ref=bdb59aec775c4ea43a980efa6ccacdc3c9540d12", "patch": "@@ -81,6 +81,11 @@ static JCF_u2 last_access;\n \n #define ACC_VISIBILITY (ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED)\n \n+/* Pass this macro the flags for a class and for a method.  It will\n+   return true if the method should be considered `final'.  */\n+#define METHOD_IS_FINAL(Class, Method) \\\n+   (((Class) & ACC_FINAL) || ((Method) & (ACC_FINAL | ACC_PRIVATE)))\n+\n /* We keep a linked list of all method names we have seen.  This lets\n    us determine if a method name and a field name are in conflict.  */\n struct method_name\n@@ -97,6 +102,7 @@ static void print_field_info PROTO ((FILE *, JCF*, int, int, JCF_u2));\n static void print_method_info PROTO ((FILE *, JCF*, int, int, JCF_u2));\n static void print_c_decl PROTO ((FILE*, JCF*, int, int, JCF_u2, int, const char *));\n static void decompile_method PROTO ((FILE *, JCF *, int));\n+static void add_class_decl PROTO ((FILE *, JCF *, JCF_u2));\n \n JCF_u2 current_field_name;\n JCF_u2 current_field_value;\n@@ -107,31 +113,47 @@ JCF_u2 current_field_flags;\n ( current_field_name = (NAME), current_field_signature = (SIGNATURE), \\\n   current_field_flags = (ACCESS_FLAGS), current_field_value = 0)\n \n-/* We pass over fields twice.  The first time we just note the start\n-   of the methods.  Then we go back and parse the fields for real.\n-   This is ugly.  */\n+/* We pass over fields twice.  The first time we just note the types\n+   of the fields and then the start of the methods.  Then we go back\n+   and parse the fields for real.  This is ugly.  */\n static int field_pass;\n-\n-#define HANDLE_END_FIELD() \\\n-  if (out && field_pass) print_field_info (out, jcf, current_field_name, \\\n-\t\t\t\t\t   current_field_signature, \\\n-\t\t\t\t\t   current_field_flags);\n+/* Likewise we pass over methods twice.  The first time we generate\n+   class decl information; the second time we generate actual method\n+   decls.  */\n+static int method_pass;\n+\n+#define HANDLE_END_FIELD()\t\t\t\t\t\t      \\\n+  if (field_pass)\t\t\t\t\t\t\t      \\\n+    {\t\t\t\t\t\t\t\t\t      \\\n+      if (out)\t\t\t\t\t\t\t\t      \\\n+\tprint_field_info (out, jcf, current_field_name,\t\t\t      \\\n+\t\t\t  current_field_signature,\t\t\t      \\\n+\t\t\t  current_field_flags);\t\t\t\t      \\\n+    }\t\t\t\t\t\t\t\t\t      \\\n+  else\t\t\t\t\t\t\t\t\t      \\\n+    add_class_decl (out, jcf, current_field_signature);\n \n #define HANDLE_CONSTANTVALUE(VALUEINDEX) current_field_value = (VALUEINDEX)\n \n static int method_declared = 0;\n static int method_access = 0;\n-#define HANDLE_METHOD(ACCESS_FLAGS, NAME, SIGNATURE, ATTRIBUTE_COUNT) \\\n-  if (out) { decompiled = 0; \\\n-      print_method_info (out, jcf, NAME, SIGNATURE, ACCESS_FLAGS); \\\n-  }\n+static int method_printed = 0;\n+#define HANDLE_METHOD(ACCESS_FLAGS, NAME, SIGNATURE, ATTRIBUTE_COUNT)\t      \\\n+  if (method_pass)\t\t\t\t\t\t\t      \\\n+    {\t\t\t\t\t\t\t\t\t      \\\n+      decompiled = 0; method_printed = 0;\t\t\t\t      \\\n+      if (out)\t\t\t\t\t\t\t\t      \\\n+        print_method_info (out, jcf, NAME, SIGNATURE, ACCESS_FLAGS);\t      \\\n+    }\t\t\t\t\t\t\t\t\t      \\\n+  else\t\t\t\t\t\t\t\t\t      \\\n+    add_class_decl (out, jcf, SIGNATURE);\n \n #define HANDLE_CODE_ATTRIBUTE(MAX_STACK, MAX_LOCALS, CODE_LENGTH) \\\n   if (out && method_declared) decompile_method (out, jcf, CODE_LENGTH);\n \n static int decompiled = 0;\n #define HANDLE_END_METHOD() \\\n-  if (out) fputs (decompiled ? \"\\n\" : \";\\n\", out);\n+  if (out && method_printed) fputs (decompiled ? \"\\n\" : \";\\n\", out);\n \n #include \"jcf-reader.c\"\n \n@@ -426,13 +448,24 @@ DEFUN(print_method_info, (stream, jcf, name_index, sig_index, flags),\n     fprintf (stream, \"<not a UTF8 constant>\");\n   str = JPOOL_UTF_DATA (jcf, name_index);\n   length = JPOOL_UTF_LENGTH (jcf, name_index);\n-  if (str[0] == '<')\n+  if (str[0] == '<' || str[0] == '$')\n     {\n-      /* Ignore internally generated methods like <clinit>.  However,\n-\t treat <init> as a constructor.  */\n+      /* Ignore internally generated methods like <clinit> and\n+\t $finit$.  However, treat <init> as a constructor.  */\n       if (! utf8_cmp (str, length, \"<init>\"))\n \tis_init = 1;\n-      else  \n+      else if (! METHOD_IS_FINAL (jcf->access_flags, flags)\n+\t       && ! (flags & ACC_STATIC))\n+\t{\n+\t  /* FIXME: i18n bug here.  Order of prints should not be\n+\t     fixed.  */\n+\t  fprintf (stderr, \"ignored method `\");\n+\t  jcf_print_utf8 (stderr, str, length);\n+\t  fprintf (stderr, \"' marked virtual\\n\");\n+\t  found_error = 1;\n+\t  return;\n+\t}\n+      else\n \treturn;\n     }\n   else\n@@ -455,20 +488,22 @@ DEFUN(print_method_info, (stream, jcf, name_index, sig_index, flags),\n      after it in the vtbl).  So we give it a dummy name instead.  */\n   if (! utf8_cmp (str, length, \"delete\"))\n     {\n-      /* If the method is static, we can safely skip it.  If we don't\n-\t skip it then we'll have problems since the mangling will be\n-\t wrong.  FIXME.  */\n-      if ((flags & ACC_STATIC))\n+      /* If the method is static or final, we can safely skip it.  If\n+\t we don't skip it then we'll have problems since the mangling\n+\t will be wrong.  FIXME.  */\n+      if (METHOD_IS_FINAL (jcf->access_flags, flags)\n+\t  || (flags & ACC_STATIC))\n \treturn;\n       override = \"__dummy_delete\";\n     }\n \n+  method_printed = 1;\n   generate_access (stream, flags);\n \n   fputs (\"  \", out);\n   if ((flags & ACC_STATIC))\n     fputs (\"static \", out);\n-  else if (! (flags & ACC_FINAL) && ! (jcf->access_flags & ACC_FINAL))\n+  else if (! METHOD_IS_FINAL (jcf->access_flags, flags))\n     {\n       /* Don't print `virtual' if we have a constructor.  */\n       if (! is_init)\n@@ -795,39 +830,210 @@ super_class_name (derived_jcf, len)\n   return supername;\n }\n \n-/* Print declarations for all classes required by this class.  FIXME:\n-   the current implementation just prints every class name from the\n-   constant pool.  This is too much.  We really only need to print a\n-   declaration for each class which is the type of a return value, a\n-   field, or an argument.  */\n+\f\n+\n+/* This is used to represent part of a package or class name.  */\n+struct namelet\n+{\n+  /* The text of this part of the name.  */\n+  char *name;\n+  /* True if this represents a class.  */\n+  int is_class;\n+  /* Linked list of all classes and packages inside this one.  */\n+  struct namelet *subnamelets;\n+  /* Pointer to next sibling.  */\n+  struct namelet *next;\n+};\n+\n+/* The special root namelet.  */\n+static struct namelet root =\n+{\n+  NULL,\n+  0,\n+  NULL,\n+  NULL\n+};\n+\n+/* This extracts the next name segment from the full UTF-8 encoded\n+   package or class name and links it into the tree.  It does this\n+   recursively.  */\n static void\n-print_class_decls (out, jcf)\n+add_namelet (name, name_limit, parent)\n+     unsigned char *name, *name_limit;\n+     struct namelet *parent;\n+{\n+  unsigned char *p;\n+  struct namelet *n = NULL, *np;\n+\n+  for (p = name; p < name_limit && *p != '/' && *p != '$'; ++p)\n+    ;\n+\n+  /* Search for this name beneath the PARENT node.  */\n+  for (np = parent->subnamelets; np != NULL; np = np->next)\n+    {\n+      if (! strncmp (name, np->name, p - name))\n+\t{\n+\t  n = np;\n+\t  break;\n+\t}\n+    }\n+\n+  if (n == NULL)\n+    {\n+      n = (struct namelet *) malloc (sizeof (struct namelet));\n+      n->name = malloc (p - name + 1);\n+      strncpy (n->name, name, p - name);\n+      n->name[p - name] = '\\0';\n+      n->is_class = (p == name_limit || *p == '$');\n+      n->subnamelets = NULL;\n+      n->next = parent->subnamelets;\n+      parent->subnamelets = n;\n+    }\n+\n+  /* We recurse if there is more text, and if the trailing piece does\n+     not represent an inner class. */\n+  if (p < name_limit && *p != '$')\n+    add_namelet (p + 1, name_limit, n);\n+}\n+\n+/* Print a single namelet.  Destroys namelets while printing.  */\n+static void\n+print_namelet (out, name, depth)\n+     FILE *out;\n+     struct namelet *name;\n+     int depth;\n+{\n+  int i, term = 0;\n+  struct namelet *c;\n+\n+  if (name->name)\n+    {\n+      for (i = 0; i < depth; ++i)\n+\tfputc (' ', out);\n+      fprintf (out, \"%s %s\", name->is_class ? \"class\" : \"namespace\",\n+\t       name->name);\n+      if (name->is_class && name->subnamelets == NULL)\n+\tfputs (\";\\n\", out);\n+      else\n+\t{\n+\t  term = 1;\n+\t  fputs (\"\\n\", out);\n+\t  for (i = 0; i < depth; ++i)\n+\t    fputc (' ', out);\n+\t  fputs (\"{\\n\", out);\n+\t}\n+    }\n+\n+  c = name->subnamelets;\n+  while (c != NULL)\n+    {\n+      struct namelet *next = c->next;\n+      print_namelet (out, c, depth + 2);\n+      c = next;\n+    }\n+\n+  if (name->name)\n+    {\n+      if (term)\n+\t{\n+\t  for (i = 0; i < depth; ++i)\n+\t    fputc (' ', out);\n+\t  fputs (\"};\\n\", out);\n+\t}\n+\n+      free (name->name);\n+      free (name);\n+    }\n+}\n+\n+/* This is called to add some classes to the list of classes for which\n+   we need decls.  The signature argument can be a function\n+   signature.  */\n+static void\n+add_class_decl (out, jcf, signature)\n      FILE *out;\n      JCF *jcf;\n+     JCF_u2 signature;\n {\n-  int i, seen_one = 0;\n+  unsigned char *s = JPOOL_UTF_DATA (jcf, signature);\n+  int len = JPOOL_UTF_LENGTH (jcf, signature);\n+  int i;\n \n-  for (i = 1; i < JPOOL_SIZE (jcf); ++i)\n+  for (i = 0; i < len; ++i)\n     {\n-      int kind = JPOOL_TAG (jcf, i);\n-      if (kind == CONSTANT_Class)\n+      int start;\n+      /* We're looking for `L<stuff>;' -- everything else is\n+\t ignorable.  */\n+      if (s[i] != 'L')\n+\tcontinue;\n+      for (start = ++i; i < len && s[i] != ';'; ++i)\n+\t{\n+\t  if (s[i] == '$' && out)\n+\t    {\n+\t      /* If this class represents an inner class, then\n+\t\t generate a `#include' for the outer class.  */\n+\t      fputs (\"#include <\", out);\n+\t      jcf_print_utf8 (out, &s[start], i - start);\n+\t      fputs (\">\\n\", out);\n+\t    }\n+\t}\n+\n+#define JAVALANG \"java/lang/\"\n+#define JAVAIO \"java/io/\"\n+#define JAVAUTIL \"java/util/\"\n+      if ((i - start >= sizeof (JAVALANG) - 1\n+\t   && ! strncmp (&s[start], JAVALANG, sizeof (JAVALANG) - 1))\n+\t  || (i - start >= sizeof (JAVAUTIL) - 1\n+\t      && ! strncmp (&s[start], JAVAUTIL, sizeof (JAVAUTIL) - 1))\n+\t  || (i - start >= sizeof (JAVAIO) - 1\n+\t      && ! strncmp (&s[start], JAVAIO, sizeof (JAVAIO) - 1)))\n \t{\n-\t  if (print_cxx_classname (out, \"class \", jcf, i))\n-\t    fputs (\";\\n\", out);\n-\t  seen_one = 1;\n+\t  /* Skip all the standard `java.' classes.  */\n+\t  continue;\n \t}\n+\n+      add_namelet (&s[start], &s[i], &root);\n     }\n+}\n+\n+/* Print declarations for all classes required by this class.  Any\n+   class or package in the `java' package is assumed to be handled\n+   statically in libjava; we don't generate declarations for these.\n+   This makes the generated headers a bit easier to read.  */\n+static void\n+print_class_decls (out, jcf, self)\n+     FILE *out;\n+     JCF *jcf;\n+     int self;\n+{\n+  /* Make sure to always add the current class to the list of things\n+     that should be declared.  */\n+  int name_index = JPOOL_USHORT1 (jcf, self);\n+  int len;\n+  unsigned char *s;\n+\n+  s = JPOOL_UTF_DATA (jcf, name_index);\n+  len = JPOOL_UTF_LENGTH (jcf, name_index);\n+  add_namelet (s, s + len, &root);\n \n-  if (seen_one)\n-    fputs (\"\\n\", out);\n+  if (root.subnamelets)\n+    {\n+      fputs (\"extern \\\"Java\\\"\\n{\\n\", out);\n+      /* We use an initial offset of 0 because the root namelet\n+\t doesn't cause anything to print.  */\n+      print_namelet (out, &root, 0);\n+      fputs (\"};\\n\\n\", out);\n+    }\n }\n \n+\f\n+\n static void\n DEFUN(process_file, (jcf, out),\n       JCF *jcf AND FILE *out)\n {\n   int code, i;\n-  uint32 field_start, method_end;\n+  uint32 field_start, method_end, method_start;\n \n   current_jcf = main_jcf = jcf;\n \n@@ -895,9 +1101,22 @@ DEFUN(process_file, (jcf, out),\n       fputs (\"\\n\", out);\n     }\n \n+  /* We want to parse the methods first.  But we need to find where\n+     they start.  So first we skip the fields, then parse the methods.\n+     Then we parse the fields and skip the methods.  This is ugly, but\n+     not too bad since we need two full passes to get class decl\n+     information anyway.  */\n+  field_pass = 0;\n+  field_start = JCF_TELL (jcf);\n+  jcf_parse_fields (jcf);\n+\n+  method_start = JCF_TELL (jcf);\n+  method_pass = 0;\n+  jcf_parse_methods (jcf);\n+\n   if (out)\n     {\n-      print_class_decls (out, jcf);\n+      print_class_decls (out, jcf, jcf->this_class);\n \n       for (i = 0; i < prepend_count; ++i)\n \tfprintf (out, \"%s\\n\", prepend_specs[i]);\n@@ -923,18 +1142,9 @@ DEFUN(process_file, (jcf, out),\n   if (out)\n     fputs (\"\\n{\\n\", out);\n \n-  /* We make a single pass over the file, printing methods and fields\n-     as we see them.  We have to list the methods in the same order\n-     that they appear in the class file, so that the Java and C++\n-     vtables have the same layout.  */\n-  /* We want to parse the methods first.  But we need to find where\n-     they start.  So first we skip the fields, then parse the\n-     methods.  Then we parse the fields and skip the methods.  FIXME:\n-     this is ugly.  */\n-  field_pass = 0;\n-  field_start = JCF_TELL (jcf);\n-  jcf_parse_fields (jcf);\n-\n+  /* Now go back for second pass over methods and fields.  */\n+  JCF_SEEK (jcf, method_start);\n+  method_pass = 1;\n   jcf_parse_methods (jcf);\n   method_end = JCF_TELL (jcf);\n "}]}