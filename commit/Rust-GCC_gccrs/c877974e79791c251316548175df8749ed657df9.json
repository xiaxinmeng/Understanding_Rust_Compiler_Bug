{"sha": "c877974e79791c251316548175df8749ed657df9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzg3Nzk3NGU3OTc5MWMyNTEzMTY1NDgxNzVkZjg3NDllZDY1N2RmOQ==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "1998-11-19T01:54:44Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "1998-11-19T01:54:44Z"}, "message": "class.c (unmangle_classname): Set QUALIFIED_P when appropriate.\n\nWed Nov 18 23:54:53 1998  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\t* class.c (unmangle_classname): Set QUALIFIED_P when appropriate.\n\t(layout_class): Cope with methods featuring WFL in decl names.\n\t* decl.c (unqualified_object_id_node): New global variable,\n \tinitialized.\n\t(build_decl_no_layout): Removed.\n\t* expr.c (build_primtype_type_ref): Handle Double.\n\t(java_lang_expand_expr): Fixed indentations.\n\t* java-tree.h (CLASS_METHOD_CHECKED_P): Flag deleted.\n\t(flag_wall, flag_redundant, flag_not_overriding,\n \tflag_static_local_jdk1_1, unqualified_object_id_node): Global\n \tvariable declarations.\n\t(build_decl_no_layout): Removed prototype.\n\t(java_get_real_method_name): Added prototype.\n\t(IS_UNCHECKED_EXPRESSION_P): Renamed IS_UNCHECKED_EXCEPTION_P.\n\t(java_parse_abort_on_error): Macro now just returns.\n\t* jcf-parse.c (jcf_parse_source): Check fclose returned\n \tvalue. Call emit_register_classes if java_report_errors returns\n \tzero.\n\t* lanc.c (flag_wall, flag_redundant, flag_not_overriding,\n \tflag_static_local_jdk1_1): New integer flags.\n\t(lang_decode_option): New flags set here.\n\t* parse.h (GET_REAL_TYPE, GET_METHOD_NAME): New macros.\n\t(OBSOLETE_MODIFIER_WARNING): Issue error message conditionally to\n \tthe flag_redundant variable.\n\t(SET_TYPE_FOR_RESOLUTION): Consider Object being java.lang.Object\n \twhen parsing java.lang.Object class.\n\t(BUILD_MONITOR_ENTER, BUILD_MONITOR_EXIT): Added terminal\n \tNULL_TREE to build.\n\t(resolve_qualified_expression_name): Fixed indentation.\n\t(patch_array_ref): Changed prototype.\n\t(not_initialized_as_it_should_p): Prototype removed.\n\t(java_report_errors): Added function prototype.\n\t* parse.y (formal_parameter:): Changed error message for not yet\n \tsupported final parameters.\n\t(class_type_list:): Set both PURPOSE and VALUE of created\n \tTREE_LIST to be class_type.\n\t(primary_no_new_array:): Handle class literals on primitive types.\n\t(parse_warning_context): Reinstalled correct force_error and\n \tdo_warning flags setups.\n\t(java_report_errors): Changed prototype. Return java_error_count\n \tvalue.\n\t(variable_redefinition_error): Consider treating variable type as\n \ta fake pointer.\n\t(create_interface): Warn about redundant abstract modifier if\n \tflag_redundant is set. Changed error message.\n\t(lookup_field_wrapper): Save/restore globals before/after looking\n \tup field.\n\t(duplicate_declaration_error_p): Consider treating declaration\n \ttype as a fake pointer.\n\t(register_fields): Extract real type from dependency node. Check\n \tfor duplicate field declaration after type adjustment. Use\n \tDECL_INITIAL to store static final initialized values.\n\t(method_header): Extract real function type from dependency node.\n\t(check_abstract_method_header): Use GET_METHOD_NAME.\n\t(obtain_incomplete_type): Layout fake pointer type.\n\t(safe_layout_class): Don't try to check for methods before layout.\n\t(java_complete_class): Don't check for correct throws clause\n \telements inheritance here.\n\t(resolve_and_layout): Broadened name parameter meaning.\n\t(reset_method_name): Use GET_METHOD_NAME.\n\t(java_get_real_method_name): New function.\n\t(java_check_regular_methods): Don't check methods in\n \tjava.lang.Object.  Verify lineage of throws clause elements. Use\n \tflag_no_overriding in warning report.\n\t(check_throws_clauses): Don't check if class was from\n \tbytecode. Use IS_UNCHECKED_EXCEPTION_P macro.\n\t(java_check_methods): Don't set CLASS_METHOD_CHECKED_P flag.\n\t(declare_local_variables): Use flag_static_local_jdk1_1 to report\n \twarning on unsupported final local variables. Use build_decl\n \tinstead of build_decl_no_layout. Get real local variable type from\n \tdependency node.\n\t(source_start_java_method): Get real parameter type from\n \tdependency node. Call build_decl instead of build_decl_no_layout.\n\t(java_layout_classes): Reverse tree and layout type and class as\n \trequired. Mark class as loaded when done.\n\t(resolve_field_access): Fixed indentation. Restricted condition\n \tleading to static field access code generation. Set field_type\n \tdecl's TREE_TYPE if QUAL_DECL_TYPE not available.\n\t(resolve_qualified_expression_name): Initialize type_found to\n \tnull. Handle static field resolved during qualification. Fixed\n \tlayout on non primitive field decl types.\n\t(not_accessible_p): Fixed typo in comment.\n\t(patch_method_invocation): Resolve and layout class to search from\n \ttype.\n\t(lookup_method_invoke): Keep integer constant 0 as is. Resolve and\n \tlayout non primitive type, if necessary. Make method node only to\n \treport errors.\n\t(find_applicable_accessible_methods_list): Consider WFL'ed method\n \tdecl names. Fixed indentation.\n\t(argument_types_convertible): Resolve and layout target type if\n \tnecessary.\n\t(java_complete_tree): Fixed indentation problems. Rewrote\n \tCALL_EXPR thrown exceptions check. Re-installed further processing\n \tof the assignment in certain cases.\n\t(patch_assignment): Call maybe_build_primttype_type_ref to perform\n \tinlining on class literals.\n\t(valid_builtin_assignconv_identity_widening_p): Cope with constant\n \t0 literal.\n\t(valid_method_invocation_conversion_p): Likewise.\n\t(patch_string): Temporary disable forbidden use of `this' in\n \texplicit constructor invocations when doing string concatenation\n \twithin their scope.\n\t(patch_unaryop): Added comment. Reinstalled code to disable\n \tfurther check on assignment operation with cast expression RHS.\n\t(patch_switch_statement): Fixed indentation.\n\t(build_try_statement): Call build_decl instead of\n \tbuild_decl_no_layout.\n\t(patch_synchronized_statement): Likewise.\n\t(patch_throw_statement): Use IS_UNCHECKED_EXCEPTION_P instead of\n \tIS_UNCHECKED_EXPRESSION_P.\n\t(check_thrown_exceptions_do): Changed leading comment. Resolve and\n \tlayout argument exception type.\n\t(purge_unchecked_exceptions): Use IS_UNCHECKED_EXCEPTION_P instead\n \tof IS_UNCHECKED_EXPRESSION_P.\nFixed problems found when compiling a mixture of .class and .java\nfiles in the same package. Some support for the compilation of libjava.\n\nFrom-SVN: r23704", "tree": {"sha": "865a2a98275258f86565ef8f672d4b7845d11d54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/865a2a98275258f86565ef8f672d4b7845d11d54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c877974e79791c251316548175df8749ed657df9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c877974e79791c251316548175df8749ed657df9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c877974e79791c251316548175df8749ed657df9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c877974e79791c251316548175df8749ed657df9/comments", "author": null, "committer": null, "parents": [{"sha": "423165659be7520d02a498334fab715718b4fab8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/423165659be7520d02a498334fab715718b4fab8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/423165659be7520d02a498334fab715718b4fab8"}], "stats": {"total": 1563, "additions": 952, "deletions": 611}, "files": [{"sha": "6c8456c2612801e1ec517be5dde2f8a3be46f35b", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c877974e79791c251316548175df8749ed657df9/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c877974e79791c251316548175df8749ed657df9/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=c877974e79791c251316548175df8749ed657df9", "patch": "@@ -1,3 +1,120 @@\n+Wed Nov 18 23:54:53 1998  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* class.c (unmangle_classname): Set QUALIFIED_P when appropriate.\n+\t(layout_class): Cope with methods featuring WFL in decl names.\n+\t* decl.c (unqualified_object_id_node): New global variable,\n+ \tinitialized.\n+\t(build_decl_no_layout): Removed.\n+\t* expr.c (build_primtype_type_ref): Handle Double.\n+\t(java_lang_expand_expr): Fixed indentations.\n+\t* java-tree.h (CLASS_METHOD_CHECKED_P): Flag deleted.\n+\t(flag_wall, flag_redundant, flag_not_overriding,\n+ \tflag_static_local_jdk1_1, unqualified_object_id_node): Global\n+ \tvariable declarations.\n+\t(build_decl_no_layout): Removed prototype.\n+\t(java_get_real_method_name): Added prototype.\n+\t(IS_UNCHECKED_EXPRESSION_P): Renamed IS_UNCHECKED_EXCEPTION_P.\n+\t(java_parse_abort_on_error): Macro now just returns.\n+\t* jcf-parse.c (jcf_parse_source): Check fclose returned\n+ \tvalue. Call emit_register_classes if java_report_errors returns\n+ \tzero.\n+\t* lanc.c (flag_wall, flag_redundant, flag_not_overriding,\n+ \tflag_static_local_jdk1_1): New integer flags.\n+\t(lang_decode_option): New flags set here.\n+\t* parse.h (GET_REAL_TYPE, GET_METHOD_NAME): New macros.\n+\t(OBSOLETE_MODIFIER_WARNING): Issue error message conditionally to\n+ \tthe flag_redundant variable.\n+\t(SET_TYPE_FOR_RESOLUTION): Consider Object being java.lang.Object\n+ \twhen parsing java.lang.Object class.\n+\t(BUILD_MONITOR_ENTER, BUILD_MONITOR_EXIT): Added terminal\n+ \tNULL_TREE to build.\n+\t(resolve_qualified_expression_name): Fixed indentation.\n+\t(patch_array_ref): Changed prototype.\n+\t(not_initialized_as_it_should_p): Prototype removed.\n+\t(java_report_errors): Added function prototype.\n+\t* parse.y (formal_parameter:): Changed error message for not yet\n+ \tsupported final parameters.\n+\t(class_type_list:): Set both PURPOSE and VALUE of created\n+ \tTREE_LIST to be class_type.\n+\t(primary_no_new_array:): Handle class literals on primitive types.\n+\t(parse_warning_context): Reinstalled correct force_error and\n+ \tdo_warning flags setups.\n+\t(java_report_errors): Changed prototype. Return java_error_count\n+ \tvalue.\n+\t(variable_redefinition_error): Consider treating variable type as\n+ \ta fake pointer.\n+\t(create_interface): Warn about redundant abstract modifier if\n+ \tflag_redundant is set. Changed error message.\n+\t(lookup_field_wrapper): Save/restore globals before/after looking\n+ \tup field.\n+\t(duplicate_declaration_error_p): Consider treating declaration\n+ \ttype as a fake pointer.\n+\t(register_fields): Extract real type from dependency node. Check\n+ \tfor duplicate field declaration after type adjustment. Use\n+ \tDECL_INITIAL to store static final initialized values.\n+\t(method_header): Extract real function type from dependency node.\n+\t(check_abstract_method_header): Use GET_METHOD_NAME.\n+\t(obtain_incomplete_type): Layout fake pointer type.\n+\t(safe_layout_class): Don't try to check for methods before layout.\n+\t(java_complete_class): Don't check for correct throws clause\n+ \telements inheritance here.\n+\t(resolve_and_layout): Broadened name parameter meaning.\n+\t(reset_method_name): Use GET_METHOD_NAME.\n+\t(java_get_real_method_name): New function.\n+\t(java_check_regular_methods): Don't check methods in\n+ \tjava.lang.Object.  Verify lineage of throws clause elements. Use\n+ \tflag_no_overriding in warning report.\n+\t(check_throws_clauses): Don't check if class was from\n+ \tbytecode. Use IS_UNCHECKED_EXCEPTION_P macro.\n+\t(java_check_methods): Don't set CLASS_METHOD_CHECKED_P flag.\n+\t(declare_local_variables): Use flag_static_local_jdk1_1 to report\n+ \twarning on unsupported final local variables. Use build_decl\n+ \tinstead of build_decl_no_layout. Get real local variable type from\n+ \tdependency node.\n+\t(source_start_java_method): Get real parameter type from\n+ \tdependency node. Call build_decl instead of build_decl_no_layout.\n+\t(java_layout_classes): Reverse tree and layout type and class as\n+ \trequired. Mark class as loaded when done.\n+\t(resolve_field_access): Fixed indentation. Restricted condition\n+ \tleading to static field access code generation. Set field_type\n+ \tdecl's TREE_TYPE if QUAL_DECL_TYPE not available.\n+\t(resolve_qualified_expression_name): Initialize type_found to\n+ \tnull. Handle static field resolved during qualification. Fixed\n+ \tlayout on non primitive field decl types.\n+\t(not_accessible_p): Fixed typo in comment.\n+\t(patch_method_invocation): Resolve and layout class to search from\n+ \ttype.\n+\t(lookup_method_invoke): Keep integer constant 0 as is. Resolve and\n+ \tlayout non primitive type, if necessary. Make method node only to\n+ \treport errors.\n+\t(find_applicable_accessible_methods_list): Consider WFL'ed method\n+ \tdecl names. Fixed indentation.\n+\t(argument_types_convertible): Resolve and layout target type if\n+ \tnecessary.\n+\t(java_complete_tree): Fixed indentation problems. Rewrote\n+ \tCALL_EXPR thrown exceptions check. Re-installed further processing\n+ \tof the assignment in certain cases.\n+\t(patch_assignment): Call maybe_build_primttype_type_ref to perform\n+ \tinlining on class literals.\n+\t(valid_builtin_assignconv_identity_widening_p): Cope with constant\n+ \t0 literal.\n+\t(valid_method_invocation_conversion_p): Likewise.\n+\t(patch_string): Temporary disable forbidden use of `this' in\n+ \texplicit constructor invocations when doing string concatenation\n+ \twithin their scope.\n+\t(patch_unaryop): Added comment. Reinstalled code to disable\n+ \tfurther check on assignment operation with cast expression RHS.\n+\t(patch_switch_statement): Fixed indentation.\n+\t(build_try_statement): Call build_decl instead of\n+ \tbuild_decl_no_layout.\n+\t(patch_synchronized_statement): Likewise.\n+\t(patch_throw_statement): Use IS_UNCHECKED_EXCEPTION_P instead of\n+ \tIS_UNCHECKED_EXPRESSION_P.\n+\t(check_thrown_exceptions_do): Changed leading comment. Resolve and\n+ \tlayout argument exception type.\n+\t(purge_unchecked_exceptions): Use IS_UNCHECKED_EXCEPTION_P instead\n+ \tof IS_UNCHECKED_EXPRESSION_P.\n+\t\n Sun Nov 15 17:14:17 1998  Per Bothner  <bothner@cygnus.com>\n \n \t* jvgenmain.c:  Need to #include \"gansidecl.h\" (to get PROTO)."}, {"sha": "0f8d488d1db8f0937da8a48805607b1a30ade400", "filename": "gcc/java/class.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c877974e79791c251316548175df8749ed657df9/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c877974e79791c251316548175df8749ed657df9/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=c877974e79791c251316548175df8749ed657df9", "patch": "@@ -138,7 +138,10 @@ tree\n unmangle_classname (name, name_length)\n      const char *name;  int name_length;\n {\n-  return ident_subst (name, name_length, \"\", '/', '.', \"\");\n+  tree to_return = ident_subst (name, name_length, \"\", '/', '.', \"\");\n+  if (to_return != get_identifier ((char *)name))\n+    QUALIFIED_P (to_return) = 1;\n+  return to_return;\n }\n \n tree\n@@ -1375,6 +1378,10 @@ layout_class (this_class)\n       char buf[8];\n       char *asm_name;\n       tree method_name = DECL_NAME (method_decl);\n+      int method_name_is_wfl = \n+\t(TREE_CODE (method_name) == EXPR_WITH_FILE_LOCATION);\n+      if (method_name_is_wfl)\n+\tmethod_name = java_get_real_method_name (method_decl);\n #if 1\n       /* Remove this once we no longer need old (Kaffe / JDK 1.0)  mangling. */\n       if (! flag_assume_compiled && METHOD_NATIVE (method_decl))\n@@ -1492,7 +1499,10 @@ layout_class (this_class)\n \t      if (*ptr++ == '.')\n \t\tp = ptr;\n \t    }\n-\t  DECL_NAME (method_decl) = get_identifier (p);\n+\t  if (method_name_is_wfl)\n+\t    EXPR_WFL_NODE (DECL_NAME (method_decl)) = get_identifier (p);\n+\t  else\n+\t    DECL_NAME (method_decl) = get_identifier (p);\n \t  DECL_CONSTRUCTOR_P (method_decl) = 1;\n \t}\n       else if (! METHOD_STATIC (method_decl) && !DECL_ARTIFICIAL (method_decl))"}, {"sha": "d6e631e63f628a69fadf012231e6f8e9e1a6cd61", "filename": "gcc/java/decl.c", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c877974e79791c251316548175df8749ed657df9/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c877974e79791c251316548175df8749ed657df9/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=c877974e79791c251316548175df8749ed657df9", "patch": "@@ -247,6 +247,7 @@ tree current_function_decl;\n tree char_type_node;\n \n tree object_type_node;\n+tree unqualified_object_id_node;\n tree object_ptr_type_node;\n tree string_type_node;\n tree throwable_type_node;\n@@ -520,6 +521,7 @@ init_decl_processing ()\n                         double_type_node));\n   layout_type (double_type_node);\n \n+  unqualified_object_id_node = get_identifier (\"Object\");\n   object_type_node = lookup_class (get_identifier (\"java.lang.Object\"));\n   object_ptr_type_node = promote_type (object_type_node);\n   string_type_node = lookup_class (get_identifier (\"java.lang.String\"));\n@@ -1596,13 +1598,3 @@ end_java_method ()\n   current_function_decl = NULL_TREE;\n   permanent_allocation (1);\n }\n-\n-tree \n-build_decl_no_layout (code, name, type)\n-     enum tree_code code;\n-     tree name, type;\n-{\n-  tree decl = build_decl (TYPE_DECL, name, type);\n-  TREE_SET_CODE (decl, code);\n-  return decl;\n-}"}, {"sha": "fd81d2ca14e7a07de14ff8d79bf3ee7b08a935a0", "filename": "gcc/java/expr.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c877974e79791c251316548175df8749ed657df9/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c877974e79791c251316548175df8749ed657df9/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=c877974e79791c251316548175df8749ed657df9", "patch": "@@ -1674,6 +1674,8 @@ build_primtype_type_ref (self_name)\n     typ = long_type_node;\n   else if (strncmp(class_name, \"Float\", 5) == 0)\n     typ = float_type_node;\n+  else if (strncmp(class_name, \"Double\", 6) == 0)\n+    typ = double_type_node;\n   else if (strncmp(class_name, \"Boolean\", 7) == 0)\n     typ = boolean_type_node;\n   else if (strncmp(class_name, \"Char\", 4) == 0)\n@@ -1761,7 +1763,8 @@ java_lang_expand_expr (exp, target, tmode, modifier)\n       {\n \ttree duplicate;\n \tif (pushcase (TREE_OPERAND (exp, 0), case_identity,\n-\t\t      build_decl (LABEL_DECL, NULL_TREE, NULL_TREE), &duplicate) == 2)\n+\t\t      build_decl (LABEL_DECL, NULL_TREE, NULL_TREE), \n+\t\t      &duplicate) == 2)\n \t  {\n \t    EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (exp);\n \t    parse_error_context\n@@ -1772,7 +1775,8 @@ java_lang_expand_expr (exp, target, tmode, modifier)\n       }\n \n     case DEFAULT_EXPR:\n-      pushcase (NULL_TREE, 0, build_decl (LABEL_DECL, NULL_TREE, NULL_TREE), NULL);\n+      pushcase (NULL_TREE, 0, \n+\t\tbuild_decl (LABEL_DECL, NULL_TREE, NULL_TREE), NULL);\n       return const0_rtx;\n \n     case SWITCH_EXPR:"}, {"sha": "72bc0263b25d801337cad821b02b97ececd0f3f2", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c877974e79791c251316548175df8749ed657df9/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c877974e79791c251316548175df8749ed657df9/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=c877974e79791c251316548175df8749ed657df9", "patch": "@@ -58,7 +58,6 @@ struct JCF;\n    6: CAN_COMPLETE_NORMALLY (in statement nodes).\n \n    Usage of TYPE_LANG_FLAG_?:\n-   0: CLASS_METHOD_CHECKED_P (in RECORD_TYPE)\n    1: TYPE_ARRAY_P (in RECORD_TYPE).\n    2: CLASS_LOADED_P (in RECORD_TYPE).\n    3: CLASS_FROM_SOURCE_P (in RECORD_TYPE).\n@@ -125,6 +124,12 @@ extern int flag_assume_compiled;\n \n extern int flag_emit_class_files;\n \n+/* Turned to 1 if -Wall was encountered. See lang.c for their meanings.  */\n+extern int flag_wall;\n+extern int flag_redundant;\n+extern int flag_not_overriding;\n+extern int flag_static_local_jdk1_1;\n+\n /* The Java .class file that provides main_class;  the main input file. */\n extern struct JCF main_jcf[1], *current_jcf;\n \n@@ -182,6 +187,7 @@ extern tree float_type_node;\n extern tree double_type_node;\n \n extern tree object_type_node;\n+extern tree unqualified_object_id_node;\n extern tree object_ptr_type_node;\n extern tree string_type_node;\n extern tree throwable_type_node;\n@@ -518,7 +524,6 @@ extern tree build_field_ref PROTO ((tree, tree, tree));\n extern void pushdecl_force_head PROTO ((tree));\n extern tree build_java_binop PROTO ((enum tree_code, tree, tree, tree));\n extern tree binary_numeric_promotion PROTO ((tree, tree, tree *, tree *));\n-extern tree build_decl_no_layout PROTO ((enum tree_code, tree, tree));\n extern tree build_java_arrayaccess PROTO ((tree, tree, tree));\n extern tree build_newarray PROTO ((int, tree));\n extern tree build_anewarray PROTO ((tree, tree));\n@@ -548,6 +553,7 @@ extern void write_classfile PROTO ((tree));\n extern char *print_int_node PROTO ((tree));\n extern void parse_error_context VPROTO ((tree cl, char *msg, ...));\n extern tree build_primtype_type_ref PROTO ((char *));\n+extern tree java_get_real_method_name PROTO ((tree));\n \n /* Access flags etc for a method (a FUNCTION_DECL): */\n \n@@ -679,9 +685,6 @@ extern tree *type_map;\n /* FIXME this use of TREE_TYPE conflicts with something or other. */\n #define TYPE_ARRAY_ELEMENT(ATYPE) TREE_TYPE(ATYPE)\n \n-/* True if methods in class TYPE have been checked.  */\n-#define CLASS_METHOD_CHECKED_P(TYPE) TYPE_LANG_FLAG_0 (TYPE)\n-\n /* True if class TYPE has been loaded. */\n #define CLASS_LOADED_P(TYPE) TYPE_LANG_FLAG_2 (TYPE)\n \n@@ -819,8 +822,8 @@ extern tree *type_map;\n /* Using a CATCH_EXPR node */\n #define CATCH_EXPR_GET_EXPR(NODE, V) (V ? LABELED_BLOCK_BODY (NODE) : (NODE))\n \n-/* Non zero if TYPE is an unchecked expression */\n-#define IS_UNCHECKED_EXPRESSION_P(TYPE)\t\t\t\t\\\n+/* Non zero if TYPE is an unchecked exception */\n+#define IS_UNCHECKED_EXCEPTION_P(TYPE)\t\t\t\t\\\n   (inherits_from_p ((TYPE), runtime_exception_type_node)\t\\\n    || inherits_from_p ((TYPE), error_exception_type_node))\n \n@@ -830,8 +833,5 @@ extern tree *type_map;\n   {\t\t\t\t\t\t\t\t\t\\\n      extern int java_error_count;\t\t\t\t\t\\\n      if (java_error_count)\t\t\t\t\t\t\\\n-       {\t\t\t\t\t\t\t\t\\\n-         java_report_errors ();\t\t\t\t\t\t\\\n-\t return;\t\t\t\t\t\t\t\\\n-       }\t\t\t\t\t\t\t\t\\\n+       return;\t\t\t\t\t\t\t\t\\\n    }"}, {"sha": "8b7e29cfca1448a026cc3e7c0324c4fc860c43f5", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c877974e79791c251316548175df8749ed657df9/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c877974e79791c251316548175df8749ed657df9/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=c877974e79791c251316548175df8749ed657df9", "patch": "@@ -271,12 +271,10 @@ get_constant (jcf, index)\n #ifdef REAL_ARITHMETIC\n \td = REAL_VALUE_FROM_TARGET_DOUBLE (num);\n #else\n-\t{\n-\t  union { double d;  jint i[2]; } u;\n-\t  u.i[0] = (jint) num[0];\n-\t  u.i[1] = (jint) num[1];\n-\t  d = u.d;\n-\t}\n+\tunion { double d;  jint i[2]; } u;\n+\tu.i[0] = (jint) num[0];\n+\tu.i[1] = (jint) num[1];\n+\td = u.d;\n #endif\n \tvalue = build_real (double_type_node, d);\n \tbreak;\n@@ -529,6 +527,9 @@ jcf_parse_source (jcf)\n     fatal (\"input file `%s' just disappeared - jcf_parse_source\",\n \t   input_filename);\n   parse_source_file (file);\n+  if (fclose (finput))\n+    fatal (\"can't close input file `%s' stream - jcf_parse_source\",\n+\t   input_filename);\n   java_pop_parser_context (IS_A_COMMAND_LINE_FILENAME_P (file));\n   java_parser_context_restore_global ();\n }\n@@ -782,8 +783,13 @@ yyparse ()\n \t  break;\n \t}\n     }\n+\n+  if (main_jcf->read_state && fclose (main_jcf->read_state))\n+    fatal (\"failed to close input file `%s' - yyparse\",\n+\t   (main_jcf->filename ? main_jcf->filename : \"<unknown>\"));\n+\n   java_expand_classes ();\n-  if (! flag_emit_class_files)\n+  if (!java_report_errors () && !flag_emit_class_files)\n     emit_register_classes ();\n   return 0;\n }"}, {"sha": "d560550283ee1ba4996c29abe86a4ca55e4254cd", "filename": "gcc/java/lang.c", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c877974e79791c251316548175df8749ed657df9/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c877974e79791c251316548175df8749ed657df9/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=c877974e79791c251316548175df8749ed657df9", "patch": "@@ -87,7 +87,19 @@ int flag_assume_compiled = 1;\n \n int flag_emit_class_files = 0;\n \n-/* From gcc/flags.h, and idicates if exceptions are turned on or not. */\n+/* When non zero, -Wall was turned on.  */\n+int flag_wall = 0;\n+\n+/* When non zero,  check for redundant modifier uses.  */\n+int flag_redundant = 0;\n+\n+/* When non zero, warns about overridings that don't occur.  */\n+int flag_not_overriding = 0;\n+\n+/* When non zero, warns that final local are treated as non final.  */\n+int flag_static_local_jdk1_1 = 0;\n+\n+/* From gcc/flags.h, and indicates if exceptions are turned on or not.  */\n \n extern int flag_new_exceptions;\n extern int flag_exceptions;\n@@ -187,6 +199,14 @@ lang_decode_option (argc, argv)\n       return found;\n     }\n \n+  if (strcmp (p, \"-Wall\") == 0)\n+    {\n+      flag_wall = 1;\n+      flag_redundant = 1;\n+      flag_not_overriding = 1;\n+      flag_static_local_jdk1_1 = 1;\n+    }\n+\n   if (strcmp (p, \"-MD\") == 0)\n     {\n       jcf_dependency_init (1);"}, {"sha": "5bee4f3b931d3b66ad5791e72021f1592e77fa8c", "filename": "gcc/java/parse.c", "status": "modified", "additions": 462, "deletions": 396, "changes": 858, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c877974e79791c251316548175df8749ed657df9/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c877974e79791c251316548175df8749ed657df9/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=c877974e79791c251316548175df8749ed657df9", "patch": "@@ -525,24 +525,24 @@ static const short yyrline[] = { 0,\n   1324,  1326,  1332,  1338,  1342,  1344,  1348,  1351,  1353,  1357,\n   1360,  1362,  1364,  1368,  1371,  1373,  1375,  1379,  1382,  1384,\n   1386,  1390,  1396,  1398,  1402,  1409,  1411,  1413,  1415,  1419,\n-  1427,  1430,  1432,  1434,  1438,  1440,  1447,  1455,  1473,  1475,\n-  1477,  1481,  1487,  1492,  1494,  1497,  1499,  1501,  1503,  1504,\n-  1505,  1506,  1510,  1512,  1514,  1519,  1521,  1523,  1525,  1527,\n-  1531,  1534,  1539,  1541,  1546,  1547,  1548,  1549,  1550,  1552,\n-  1554,  1556,  1558,  1560,  1564,  1566,  1569,  1575,  1580,  1584,\n-  1587,  1589,  1591,  1595,  1597,  1599,  1601,  1605,  1608,  1612,\n-  1618,  1620,  1628,  1631,  1633,  1637,  1640,  1648,  1652,  1655,\n-  1657,  1668,  1679,  1684,  1693,  1695,  1699,  1702,  1704,  1709,\n-  1714,  1719,  1726,  1728,  1729,  1730,  1733,  1738,  1743,  1745,\n-  1746,  1748,  1750,  1751,  1753,  1757,  1760,  1764,  1767,  1771,\n-  1773,  1775,  1777,  1778,  1780,  1784,  1792,  1794,  1796,  1808,\n-  1810,  1816,  1818,  1820,  1824,  1826,  1831,  1836,  1841,  1843,\n-  1845,  1849,  1851,  1856,  1861,  1863,  1867,  1869,  1874,  1879,\n-  1884,  1886,  1888,  1892,  1894,  1899,  1904,  1909,  1914,  1916,\n-  1918,  1920,  1922,  1924,  1928,  1930,  1935,  1940,  1942,  1946,\n-  1948,  1953,  1957,  1959,  1964,  1968,  1970,  1975,  1979,  1981,\n-  1986,  1990,  1992,  1997,  2001,  2003,  2008,  2014,  2016,  2020,\n-  2022,  2025,  2028,  2036,  2038,  2039,  2042,  2044,  2047,  2051\n+  1427,  1430,  1432,  1434,  1438,  1440,  1447,  1455,  1472,  1474,\n+  1476,  1480,  1486,  1491,  1493,  1496,  1498,  1500,  1502,  1503,\n+  1504,  1505,  1509,  1511,  1513,  1518,  1520,  1522,  1524,  1526,\n+  1530,  1533,  1538,  1540,  1545,  1546,  1547,  1548,  1549,  1551,\n+  1553,  1555,  1557,  1559,  1563,  1565,  1568,  1574,  1579,  1583,\n+  1586,  1588,  1590,  1594,  1596,  1598,  1600,  1604,  1607,  1611,\n+  1617,  1619,  1627,  1630,  1632,  1636,  1641,  1649,  1653,  1656,\n+  1658,  1669,  1680,  1685,  1694,  1696,  1700,  1703,  1705,  1710,\n+  1715,  1720,  1727,  1729,  1730,  1731,  1734,  1739,  1744,  1746,\n+  1747,  1749,  1751,  1752,  1754,  1758,  1761,  1765,  1768,  1772,\n+  1774,  1776,  1778,  1779,  1781,  1785,  1793,  1795,  1797,  1809,\n+  1811,  1817,  1819,  1821,  1825,  1827,  1832,  1837,  1842,  1844,\n+  1846,  1850,  1852,  1857,  1862,  1864,  1868,  1870,  1875,  1880,\n+  1885,  1887,  1889,  1893,  1895,  1900,  1905,  1910,  1915,  1917,\n+  1919,  1921,  1923,  1925,  1929,  1931,  1936,  1941,  1943,  1947,\n+  1949,  1954,  1958,  1960,  1965,  1969,  1971,  1976,  1980,  1982,\n+  1987,  1991,  1993,  1998,  2002,  2004,  2009,  2015,  2017,  2021,\n+  2023,  2026,  2029,  2037,  2039,  2040,  2043,  2045,  2048,  2052\n };\n #endif\n \n@@ -2985,7 +2985,7 @@ case 123:\n     break;}\n case 124:\n #line 705 \"./parse.y\"\n-{ yyval.node = parse_jdk1_1_error (\"final local\"); ;\n+{ yyval.node = parse_jdk1_1_error (\"final parameters\"); ;\n     break;}\n case 125:\n #line 707 \"./parse.y\"\n@@ -3012,11 +3012,11 @@ case 129:\n     break;}\n case 130:\n #line 725 \"./parse.y\"\n-{ yyval.node = build_tree_list (NULL_TREE, yyvsp[0].node); ;\n+{ yyval.node = build_tree_list (yyvsp[0].node, yyvsp[0].node); ;\n     break;}\n case 131:\n #line 727 \"./parse.y\"\n-{ yyval.node = tree_cons (NULL_TREE, yyvsp[0].node, yyvsp[-2].node); ;\n+{ yyval.node = tree_cons (yyvsp[0].node, yyvsp[0].node, yyvsp[-2].node); ;\n     break;}\n case 132:\n #line 729 \"./parse.y\"\n@@ -3074,7 +3074,7 @@ case 144:\n case 145:\n #line 788 \"./parse.y\"\n { \n-\t\t  BLOCK_EXPR_BODY (yyvsp[0].node) = size_zero_node;\n+\t\t  BLOCK_EXPR_BODY (yyvsp[0].node) = empty_stmt_node;\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n@@ -3259,7 +3259,7 @@ case 186:\n     break;}\n case 187:\n #line 954 \"./parse.y\"\n-{ yyval.node = size_zero_node; ;\n+{ yyval.node = empty_stmt_node; ;\n     break;}\n case 188:\n #line 956 \"./parse.y\"\n@@ -3304,7 +3304,7 @@ case 204:\n     break;}\n case 221:\n #line 1036 \"./parse.y\"\n-{ yyval.node = size_zero_node; ;\n+{ yyval.node = empty_stmt_node; ;\n     break;}\n case 222:\n #line 1041 \"./parse.y\"\n@@ -3550,7 +3550,7 @@ case 281:\n \t\t  yyval.node = complete_for_loop (0, NULL_TREE, yyvsp[-2].node, yyvsp[0].node);\n \t\t  /* We have not condition, so we get rid of the EXIT_EXPR */\n \t\t  LOOP_EXPR_BODY_CONDITION_EXPR (LOOP_EXPR_BODY (yyval.node), 0) = \n-\t\t    size_zero_node;\n+\t\t    empty_stmt_node;\n \t\t;\n     break;}\n case 282:\n@@ -3575,7 +3575,7 @@ case 286:\n \t\t  yyval.node = complete_for_loop (0, NULL_TREE, yyvsp[-2].node, yyvsp[0].node);\n \t\t  /* We have not condition, so we get rid of the EXIT_EXPR */\n \t\t  LOOP_EXPR_BODY_CONDITION_EXPR (LOOP_EXPR_BODY (yyval.node), 0) = \n-\t\t    size_zero_node;\n+\t\t    empty_stmt_node;\n \t\t;\n     break;}\n case 287:\n@@ -3609,7 +3609,7 @@ case 290:\n     break;}\n case 291:\n #line 1325 \"./parse.y\"\n-{ yyval.node = size_zero_node; ;\n+{ yyval.node = empty_stmt_node; ;\n     break;}\n case 292:\n #line 1327 \"./parse.y\"\n@@ -3633,7 +3633,7 @@ case 294:\n     break;}\n case 295:\n #line 1343 \"./parse.y\"\n-{yyval.node = size_zero_node;;\n+{yyval.node = empty_stmt_node;;\n     break;}\n case 296:\n #line 1345 \"./parse.y\"\n@@ -3784,10 +3784,9 @@ case 328:\n \t\t     declared initialized by the appropriate function\n \t\t     call */\n \t\t  tree ccpb = enter_block ();\n-\t\t  tree init = /* flag_emit_class_files ? NULL_TREE\n-\t\t\t\t : */ build_assignment (ASSIGN_TK, yyvsp[-2].operator.location,\n-\t\t\t\t\tTREE_PURPOSE (yyvsp[-1].node), \n-\t\t\t\t\tsoft_exceptioninfo_call_node);\n+\t\t  tree init = build_assignment (ASSIGN_TK, yyvsp[-2].operator.location, \n+\t\t\t\t\t\tTREE_PURPOSE (yyvsp[-1].node), \n+\t\t\t\t\t\tsoft_exceptioninfo_call_node);\n \t\t  declare_local_variables (0, TREE_VALUE (yyvsp[-1].node),\n \t\t\t\t\t   build_tree_list (TREE_PURPOSE (yyvsp[-1].node),\n \t\t\t\t\t\t\t    init));\n@@ -3796,203 +3795,203 @@ case 328:\n \t\t;\n     break;}\n case 329:\n-#line 1474 \"./parse.y\"\n+#line 1473 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 330:\n-#line 1476 \"./parse.y\"\n+#line 1475 \"./parse.y\"\n {yyerror (\"Missing term or ')' expected\"); DRECOVER (2);;\n     break;}\n case 331:\n-#line 1478 \"./parse.y\"\n+#line 1477 \"./parse.y\"\n {yyerror (\"')' expected\"); DRECOVER (1);;\n     break;}\n case 332:\n-#line 1483 \"./parse.y\"\n+#line 1482 \"./parse.y\"\n { \n \t\t  yyval.node = build (FINALLY_EXPR, NULL_TREE,\n \t\t\t      create_label_decl (generate_name ()), yyvsp[0].node);\n \t\t;\n     break;}\n case 333:\n-#line 1488 \"./parse.y\"\n+#line 1487 \"./parse.y\"\n {yyerror (\"'{' expected\"); RECOVER; ;\n     break;}\n case 337:\n-#line 1500 \"./parse.y\"\n+#line 1499 \"./parse.y\"\n { yyval.node = build_this (yyvsp[0].operator.location); ;\n     break;}\n case 338:\n-#line 1502 \"./parse.y\"\n+#line 1501 \"./parse.y\"\n {yyval.node = yyvsp[-1].node;;\n     break;}\n case 343:\n-#line 1511 \"./parse.y\"\n-{ yyval.node = parse_jdk1_1_error (\"class literals\"); ;\n+#line 1510 \"./parse.y\"\n+{ yyval.node = parse_jdk1_1_error (\"named class literals\"); ;\n     break;}\n case 344:\n-#line 1513 \"./parse.y\"\n-{ yyval.node = parse_jdk1_1_error (\"class literals\"); ;\n+#line 1512 \"./parse.y\"\n+{ yyval.node = build_class_ref (yyvsp[-2].node); ;\n     break;}\n case 345:\n-#line 1515 \"./parse.y\"\n-{ yyval.node = parse_jdk1_1_error (\"class literals\"); ;\n+#line 1514 \"./parse.y\"\n+{ yyval.node = build_class_ref (void_type_node); ;\n     break;}\n case 346:\n-#line 1520 \"./parse.y\"\n+#line 1519 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"class literals\"); ;\n     break;}\n case 347:\n-#line 1522 \"./parse.y\"\n+#line 1521 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 348:\n-#line 1524 \"./parse.y\"\n+#line 1523 \"./parse.y\"\n {yyerror (\"'class' or 'this' expected\" ); RECOVER;;\n     break;}\n case 349:\n-#line 1526 \"./parse.y\"\n+#line 1525 \"./parse.y\"\n {yyerror (\"'class' expected\" ); RECOVER;;\n     break;}\n case 350:\n-#line 1528 \"./parse.y\"\n+#line 1527 \"./parse.y\"\n {yyerror (\"'class' expected\" ); RECOVER;;\n     break;}\n case 351:\n-#line 1533 \"./parse.y\"\n+#line 1532 \"./parse.y\"\n { yyval.node = build_new_invocation (yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 352:\n-#line 1535 \"./parse.y\"\n+#line 1534 \"./parse.y\"\n { yyval.node = build_new_invocation (yyvsp[-2].node, NULL_TREE); ;\n     break;}\n case 353:\n-#line 1540 \"./parse.y\"\n+#line 1539 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner class instance creation\"); ;\n     break;}\n case 354:\n-#line 1542 \"./parse.y\"\n+#line 1541 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner class instance creation\"); ;\n     break;}\n case 359:\n-#line 1551 \"./parse.y\"\n+#line 1550 \"./parse.y\"\n {yyerror (\"'(' expected\"); DRECOVER(new_1);;\n     break;}\n case 360:\n-#line 1553 \"./parse.y\"\n+#line 1552 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 361:\n-#line 1555 \"./parse.y\"\n+#line 1554 \"./parse.y\"\n {yyerror (\"')' or term expected\"); RECOVER;;\n     break;}\n case 362:\n-#line 1557 \"./parse.y\"\n+#line 1556 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 363:\n-#line 1559 \"./parse.y\"\n+#line 1558 \"./parse.y\"\n {YYERROR_NOW; yyerror (\"Identifier expected\"); RECOVER;;\n     break;}\n case 364:\n-#line 1561 \"./parse.y\"\n+#line 1560 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 367:\n-#line 1571 \"./parse.y\"\n+#line 1570 \"./parse.y\"\n { \n \t\t  yyval.node = tree_cons (NULL_TREE, yyvsp[0].node, NULL_TREE);\n \t\t  ctxp->formal_parameter_number = 1; \n \t\t;\n     break;}\n case 368:\n-#line 1576 \"./parse.y\"\n+#line 1575 \"./parse.y\"\n {\n \t\t  ctxp->formal_parameter_number += 1;\n \t\t  yyval.node = tree_cons (NULL_TREE, yyvsp[0].node, yyvsp[-2].node);\n \t\t;\n     break;}\n case 369:\n-#line 1581 \"./parse.y\"\n+#line 1580 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 370:\n-#line 1586 \"./parse.y\"\n+#line 1585 \"./parse.y\"\n { yyval.node = build_newarray_node (yyvsp[-1].node, yyvsp[0].node, 0); ;\n     break;}\n case 371:\n-#line 1588 \"./parse.y\"\n+#line 1587 \"./parse.y\"\n { yyval.node = build_newarray_node (yyvsp[-1].node, yyvsp[0].node, 0); ;\n     break;}\n case 372:\n-#line 1590 \"./parse.y\"\n+#line 1589 \"./parse.y\"\n { yyval.node = build_newarray_node (yyvsp[-2].node, yyvsp[-1].node, ctxp->osb_number); ;\n     break;}\n case 373:\n-#line 1592 \"./parse.y\"\n+#line 1591 \"./parse.y\"\n { yyval.node = build_newarray_node (yyvsp[-2].node, yyvsp[-1].node, ctxp->osb_number); ;\n     break;}\n case 374:\n-#line 1596 \"./parse.y\"\n+#line 1595 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"anonymous array\"); ;\n     break;}\n case 375:\n-#line 1598 \"./parse.y\"\n+#line 1597 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"anonymous array\"); ;\n     break;}\n case 376:\n-#line 1600 \"./parse.y\"\n+#line 1599 \"./parse.y\"\n {yyerror (\"'[' expected\"); DRECOVER (\"]\");;\n     break;}\n case 377:\n-#line 1602 \"./parse.y\"\n+#line 1601 \"./parse.y\"\n {yyerror (\"']' expected\"); RECOVER;;\n     break;}\n case 378:\n-#line 1607 \"./parse.y\"\n+#line 1606 \"./parse.y\"\n { yyval.node = build_tree_list (NULL_TREE, yyvsp[0].node); ;\n     break;}\n case 379:\n-#line 1609 \"./parse.y\"\n+#line 1608 \"./parse.y\"\n { yyval.node = tree_cons (NULL_TREE, yyvsp[0].node, yyval.node); ;\n     break;}\n case 380:\n-#line 1614 \"./parse.y\"\n+#line 1613 \"./parse.y\"\n { \n \t\t  EXPR_WFL_LINECOL (yyvsp[-1].node) = yyvsp[-2].operator.location;\n \t\t  yyval.node = yyvsp[-1].node;\n \t\t;\n     break;}\n case 381:\n-#line 1619 \"./parse.y\"\n+#line 1618 \"./parse.y\"\n {yyerror (\"']' expected\"); RECOVER;;\n     break;}\n case 382:\n-#line 1621 \"./parse.y\"\n+#line 1620 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing term\");\n \t\t  yyerror (\"']' expected\");\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 383:\n-#line 1630 \"./parse.y\"\n+#line 1629 \"./parse.y\"\n { ctxp->osb_number = 1; ;\n     break;}\n case 384:\n-#line 1632 \"./parse.y\"\n+#line 1631 \"./parse.y\"\n { ctxp->osb_number++; ;\n     break;}\n case 385:\n-#line 1634 \"./parse.y\"\n+#line 1633 \"./parse.y\"\n { yyerror (\"']' expected\"); RECOVER;;\n     break;}\n case 386:\n-#line 1639 \"./parse.y\"\n+#line 1638 \"./parse.y\"\n { yyval.node = make_qualified_primary (yyvsp[-2].node, yyvsp[0].node, yyvsp[-1].operator.location); ;\n     break;}\n case 387:\n-#line 1641 \"./parse.y\"\n+#line 1642 \"./parse.y\"\n {\n \t\t  tree super_wfl = \n \t\t    build_wfl_node (super_identifier_node, \n@@ -4002,19 +4001,19 @@ case 387:\n \t\t;\n     break;}\n case 388:\n-#line 1649 \"./parse.y\"\n+#line 1650 \"./parse.y\"\n {yyerror (\"Field expected\"); DRECOVER (super_field_acces);;\n     break;}\n case 389:\n-#line 1654 \"./parse.y\"\n+#line 1655 \"./parse.y\"\n { yyval.node = build_method_invocation (yyvsp[-2].node, NULL_TREE); ;\n     break;}\n case 390:\n-#line 1656 \"./parse.y\"\n+#line 1657 \"./parse.y\"\n { yyval.node = build_method_invocation (yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 391:\n-#line 1658 \"./parse.y\"\n+#line 1659 \"./parse.y\"\n { \n \t\t  if (TREE_CODE (yyvsp[-4].node) == THIS_EXPR)\n \t\t    yyval.node = build_this_super_qualified_invocation \n@@ -4027,7 +4026,7 @@ case 391:\n \t\t;\n     break;}\n case 392:\n-#line 1669 \"./parse.y\"\n+#line 1670 \"./parse.y\"\n { \n \t\t  if (TREE_CODE (yyvsp[-5].node) == THIS_EXPR)\n \t\t    yyval.node = build_this_super_qualified_invocation \n@@ -4040,121 +4039,121 @@ case 392:\n \t\t;\n     break;}\n case 393:\n-#line 1680 \"./parse.y\"\n+#line 1681 \"./parse.y\"\n { \n \t\t  yyval.node = build_this_super_qualified_invocation \n \t\t    (0, yyvsp[-2].node, NULL_TREE, yyvsp[-4].operator.location, yyvsp[-3].operator.location);\n \t\t;\n     break;}\n case 394:\n-#line 1685 \"./parse.y\"\n+#line 1686 \"./parse.y\"\n {\n \t\t  yyval.node = build_this_super_qualified_invocation \n \t\t    (0, yyvsp[-3].node, yyvsp[-1].node, yyvsp[-5].operator.location, yyvsp[-4].operator.location);\n \t\t;\n     break;}\n case 395:\n-#line 1694 \"./parse.y\"\n+#line 1695 \"./parse.y\"\n { yyerror (\"'(' expected\"); DRECOVER (method_invocation); ;\n     break;}\n case 396:\n-#line 1696 \"./parse.y\"\n+#line 1697 \"./parse.y\"\n { yyerror (\"'(' expected\"); DRECOVER (method_invocation); ;\n     break;}\n case 397:\n-#line 1701 \"./parse.y\"\n+#line 1702 \"./parse.y\"\n { yyval.node = build_array_ref (yyvsp[-2].operator.location, yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 398:\n-#line 1703 \"./parse.y\"\n+#line 1704 \"./parse.y\"\n { yyval.node = build_array_ref (yyvsp[-2].operator.location, yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 399:\n-#line 1705 \"./parse.y\"\n+#line 1706 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing term and ']' expected\");\n \t\t  DRECOVER(array_access);\n \t\t;\n     break;}\n case 400:\n-#line 1710 \"./parse.y\"\n+#line 1711 \"./parse.y\"\n {\n \t\t  yyerror (\"']' expected\");\n \t\t  DRECOVER(array_access);\n \t\t;\n     break;}\n case 401:\n-#line 1715 \"./parse.y\"\n+#line 1716 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing term and ']' expected\");\n \t\t  DRECOVER(array_access);\n \t\t;\n     break;}\n case 402:\n-#line 1720 \"./parse.y\"\n+#line 1721 \"./parse.y\"\n {\n \t\t  yyerror (\"']' expected\");\n \t\t  DRECOVER(array_access);\n \t\t;\n     break;}\n case 407:\n-#line 1735 \"./parse.y\"\n+#line 1736 \"./parse.y\"\n { yyval.node = build_incdec (yyvsp[0].operator.token, yyvsp[0].operator.location, yyvsp[-1].node, 1); ;\n     break;}\n case 408:\n-#line 1740 \"./parse.y\"\n+#line 1741 \"./parse.y\"\n { yyval.node = build_incdec (yyvsp[0].operator.token, yyvsp[0].operator.location, yyvsp[-1].node, 1); ;\n     break;}\n case 411:\n-#line 1747 \"./parse.y\"\n+#line 1748 \"./parse.y\"\n {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;\n     break;}\n case 412:\n-#line 1749 \"./parse.y\"\n+#line 1750 \"./parse.y\"\n {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;\n     break;}\n case 414:\n-#line 1752 \"./parse.y\"\n+#line 1753 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 415:\n-#line 1754 \"./parse.y\"\n+#line 1755 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 416:\n-#line 1759 \"./parse.y\"\n+#line 1760 \"./parse.y\"\n {yyval.node = build_incdec (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node, 0); ;\n     break;}\n case 417:\n-#line 1761 \"./parse.y\"\n+#line 1762 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 418:\n-#line 1766 \"./parse.y\"\n+#line 1767 \"./parse.y\"\n {yyval.node = build_incdec (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node, 0); ;\n     break;}\n case 419:\n-#line 1768 \"./parse.y\"\n+#line 1769 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 421:\n-#line 1774 \"./parse.y\"\n+#line 1775 \"./parse.y\"\n {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;\n     break;}\n case 422:\n-#line 1776 \"./parse.y\"\n+#line 1777 \"./parse.y\"\n {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;\n     break;}\n case 424:\n-#line 1779 \"./parse.y\"\n+#line 1780 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 425:\n-#line 1781 \"./parse.y\"\n+#line 1782 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 426:\n-#line 1786 \"./parse.y\"\n+#line 1787 \"./parse.y\"\n { \n \t\t  tree type = yyvsp[-3].node;\n \t\t  while (ctxp->osb_number--)\n@@ -4163,15 +4162,15 @@ case 426:\n \t\t;\n     break;}\n case 427:\n-#line 1793 \"./parse.y\"\n+#line 1794 \"./parse.y\"\n { yyval.node = build_cast (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 428:\n-#line 1795 \"./parse.y\"\n+#line 1796 \"./parse.y\"\n { yyval.node = build_cast (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 429:\n-#line 1797 \"./parse.y\"\n+#line 1798 \"./parse.y\"\n { \n \t\t  char *ptr;\n \t\t  while (ctxp->osb_number--)\n@@ -4185,275 +4184,275 @@ case 429:\n \t\t;\n     break;}\n case 430:\n-#line 1809 \"./parse.y\"\n+#line 1810 \"./parse.y\"\n {yyerror (\"']' expected, invalid type expression\");;\n     break;}\n case 431:\n-#line 1811 \"./parse.y\"\n+#line 1812 \"./parse.y\"\n {\n \t          if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Invalid type expression\"); RECOVER;\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 432:\n-#line 1817 \"./parse.y\"\n+#line 1818 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 433:\n-#line 1819 \"./parse.y\"\n+#line 1820 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 434:\n-#line 1821 \"./parse.y\"\n+#line 1822 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 436:\n-#line 1827 \"./parse.y\"\n+#line 1828 \"./parse.y\"\n { \n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), \n \t\t\t\t    yyvsp[-1].operator.location, yyvsp[-2].node, yyvsp[0].node);\n \t\t;\n     break;}\n case 437:\n-#line 1832 \"./parse.y\"\n+#line 1833 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 438:\n-#line 1837 \"./parse.y\"\n+#line 1838 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 439:\n-#line 1842 \"./parse.y\"\n+#line 1843 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 440:\n-#line 1844 \"./parse.y\"\n+#line 1845 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 441:\n-#line 1846 \"./parse.y\"\n+#line 1847 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 443:\n-#line 1852 \"./parse.y\"\n+#line 1853 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 444:\n-#line 1857 \"./parse.y\"\n+#line 1858 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 445:\n-#line 1862 \"./parse.y\"\n+#line 1863 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 446:\n-#line 1864 \"./parse.y\"\n+#line 1865 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 448:\n-#line 1870 \"./parse.y\"\n+#line 1871 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 449:\n-#line 1875 \"./parse.y\"\n+#line 1876 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 450:\n-#line 1880 \"./parse.y\"\n+#line 1881 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 451:\n-#line 1885 \"./parse.y\"\n+#line 1886 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 452:\n-#line 1887 \"./parse.y\"\n+#line 1888 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 453:\n-#line 1889 \"./parse.y\"\n+#line 1890 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 455:\n-#line 1895 \"./parse.y\"\n+#line 1896 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 456:\n-#line 1900 \"./parse.y\"\n+#line 1901 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 457:\n-#line 1905 \"./parse.y\"\n+#line 1906 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 458:\n-#line 1910 \"./parse.y\"\n+#line 1911 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 459:\n-#line 1915 \"./parse.y\"\n+#line 1916 \"./parse.y\"\n { yyval.node = build_binop (INSTANCEOF_EXPR, yyvsp[-1].operator.location, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 460:\n-#line 1917 \"./parse.y\"\n+#line 1918 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 461:\n-#line 1919 \"./parse.y\"\n+#line 1920 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 462:\n-#line 1921 \"./parse.y\"\n+#line 1922 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 463:\n-#line 1923 \"./parse.y\"\n+#line 1924 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 464:\n-#line 1925 \"./parse.y\"\n+#line 1926 \"./parse.y\"\n {yyerror (\"Invalid reference type\"); RECOVER;;\n     break;}\n case 466:\n-#line 1931 \"./parse.y\"\n+#line 1932 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 467:\n-#line 1936 \"./parse.y\"\n+#line 1937 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 468:\n-#line 1941 \"./parse.y\"\n+#line 1942 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 469:\n-#line 1943 \"./parse.y\"\n+#line 1944 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 471:\n-#line 1949 \"./parse.y\"\n+#line 1950 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 472:\n-#line 1954 \"./parse.y\"\n+#line 1955 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 474:\n-#line 1960 \"./parse.y\"\n+#line 1961 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 475:\n-#line 1965 \"./parse.y\"\n+#line 1966 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 477:\n-#line 1971 \"./parse.y\"\n+#line 1972 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 478:\n-#line 1976 \"./parse.y\"\n+#line 1977 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 480:\n-#line 1982 \"./parse.y\"\n+#line 1983 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 481:\n-#line 1987 \"./parse.y\"\n+#line 1988 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 483:\n-#line 1993 \"./parse.y\"\n+#line 1994 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 484:\n-#line 1998 \"./parse.y\"\n+#line 1999 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 486:\n-#line 2004 \"./parse.y\"\n+#line 2005 \"./parse.y\"\n {\n \t\t  yyval.node = build (CONDITIONAL_EXPR, NULL_TREE, yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node);\n \t\t  EXPR_WFL_LINECOL (yyval.node) = yyvsp[-3].operator.location;\n \t\t;\n     break;}\n case 487:\n-#line 2009 \"./parse.y\"\n+#line 2010 \"./parse.y\"\n {\n \t\t  YYERROR_NOW;\n \t\t  yyerror (\"Missing term\");\n \t\t  DRECOVER (1);\n \t\t;\n     break;}\n case 488:\n-#line 2015 \"./parse.y\"\n+#line 2016 \"./parse.y\"\n {yyerror (\"Missing term\"); DRECOVER (2);;\n     break;}\n case 489:\n-#line 2017 \"./parse.y\"\n+#line 2018 \"./parse.y\"\n {yyerror (\"Missing term\"); DRECOVER (3);;\n     break;}\n case 492:\n-#line 2027 \"./parse.y\"\n+#line 2028 \"./parse.y\"\n { yyval.node = build_assignment (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 493:\n-#line 2029 \"./parse.y\"\n+#line 2030 \"./parse.y\"\n {\n \t\t  if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Missing term\");\n@@ -4658,7 +4657,7 @@ case 493:\n   yystate = yyn;\n   goto yynewstate;\n }\n-#line 2055 \"./parse.y\"\n+#line 2056 \"./parse.y\"\n \n \f\n \n@@ -4772,7 +4771,7 @@ parse_jdk1_1_error (msg)\n {\n   sorry (\": `%s' JDK1.1(TM) feature\", msg);\n   java_error_count++;\n-  return size_zero_node;\n+  return empty_stmt_node;\n }\n \n static int do_warning = 0;\n@@ -4904,13 +4903,13 @@ parse_warning_context VPROTO ((tree cl, char *msg, ...))\n   msg = va_arg (ap, char *);\n #endif\n \n-  do_warning = 1;\n+  force_error = do_warning = 1;\n   issue_warning_error_from_context (cl, msg, ap);\n-  force_error = 0;\n+  do_warning = force_error = 0;\n   va_end (ap);\n }\n \n-void\n+int\n java_report_errors ()\n {\n   if (java_error_count)\n@@ -4921,6 +4920,7 @@ java_report_errors ()\n \t     java_warning_count, (java_warning_count == 1 ? \"\" : \"s\"));\n   if (java_error_count || java_warning_count)\n     putc ('\\n', stderr);\n+  return java_error_count;\n }\n \n static char *\n@@ -4971,8 +4971,8 @@ variable_redefinition_error (context, name, type, line)\n   char *type_name;\n \n   /* Figure a proper name for type. We might haven't resolved it */\n-  if (TREE_CODE (type) == TREE_LIST)\n-    type_name = IDENTIFIER_POINTER (TYPE_NAME (TREE_PURPOSE (type)));\n+  if (TREE_CODE (type) == POINTER_TYPE && !TREE_TYPE (type))\n+    type_name = IDENTIFIER_POINTER (TYPE_NAME (type));\n   else\n     type_name = lang_printable_name (type, 0);\n \n@@ -5235,10 +5235,10 @@ create_interface (flags, id, super)\n        - public/abstract allowed (already done at that point)\n        - abstract is obsolete (comes first, it's a warning, or should be)\n        - Can't use twice the same (checked in the modifier rule) */\n-  if (flags & ACC_ABSTRACT)\n+  if ((flags & ACC_ABSTRACT) && flag_redundant)\n     parse_warning_context \n       (MODIFIER_WFL (ABSTRACT_TK),\n-       \"Obsolete use of `abstract' modifier. Interface `%s' is implicitely \"\n+       \"Redundant use of `abstract' modifier. Interface `%s' is implicitely \"\n        \"abstract\", IDENTIFIER_POINTER (raw_name));\n   if (flags & ACC_PUBLIC && flags & ACC_ABSTRACT)\n     parse_error_context \n@@ -5357,7 +5357,9 @@ lookup_field_wrapper (class, name)\n      tree class, name;\n {\n   tree type = class;\n+  java_parser_context_save_global ();\n   return lookup_field (&type, name);\n+  java_parser_context_restore_global ();\n }\n \n /* Find duplicate field within the same class declarations and report\n@@ -5374,11 +5376,12 @@ duplicate_declaration_error_p (new_field_name, new_type, cl)\n   if (decl)\n     {\n       char *t1 = strdup (lang_printable_name (new_type, 1));\n-      char *t2 = \n-\tstrdup ((TREE_CODE (TREE_TYPE (decl)) == TREE_LIST ?\n-\t\t IDENTIFIER_POINTER (TYPE_NAME \n-\t\t\t\t     (TREE_PURPOSE (TREE_TYPE (decl)))) :\n-\t\t lang_printable_name (TREE_TYPE (decl), 1)));\n+      /* The type may not have been completed by the time we report\n+\t the error */\n+      char *t2 = strdup (((TREE_CODE (TREE_TYPE (decl)) == POINTER_TYPE \n+\t\t\t   && TREE_TYPE (TREE_TYPE (decl)) == NULL_TREE) ?\n+\t\t\t  IDENTIFIER_POINTER (TYPE_NAME (TREE_TYPE (decl))) :\n+\t\t\t  lang_printable_name (TREE_TYPE (decl), 1)));\n       parse_error_context \n \t(cl , \"Duplicate variable declaration: `%s %s' was `%s %s' (%s:%d)\", \n \t t1, IDENTIFIER_POINTER (new_field_name),\n@@ -5433,6 +5436,7 @@ register_fields (flags, type, variable_list)\n   for (current = variable_list, saved_type = type; current; \n        current = TREE_CHAIN (current), type = saved_type)\n     {\n+      tree real_type;\n       tree field_decl;\n       tree cl = TREE_PURPOSE (current);\n       tree init = TREE_VALUE (current);\n@@ -5441,10 +5445,6 @@ register_fields (flags, type, variable_list)\n       /* Process NAME, as it may specify extra dimension(s) for it */\n       type = build_array_from_name (type, wfl, current_name, &current_name);\n \n-      /* Check for redeclarations */\n-      if (duplicate_declaration_error_p (current_name, type, cl))\n-\tcontinue;\n-\n       /* Type adjustment. We may have just readjusted TYPE because\n \t the variable specified more dimensions. Make sure we have\n \t a reference if we can and don't have one already. Also\n@@ -5457,10 +5457,15 @@ register_fields (flags, type, variable_list)\n \t    EXPR_WFL_NODE (TREE_OPERAND (init, 0)) = current_name;\n \t}\n \n+      real_type = GET_REAL_TYPE (type);\n+      /* Check for redeclarations */\n+      if (duplicate_declaration_error_p (current_name, real_type, cl))\n+\tcontinue;\n+\n       /* Set lineno to the line the field was found and create a\n          declaration for it. Eventually sets the @deprecated tag flag. */\n       lineno = EXPR_WFL_LINENO (cl);\n-      field_decl = add_field (class_type, current_name, type, flags);\n+      field_decl = add_field (class_type, current_name, real_type, flags);\n       CHECK_DEPRECATED (field_decl);\n       \n       /* Check if we must chain. */\n@@ -5485,6 +5490,8 @@ register_fields (flags, type, variable_list)\n \t\t      permalloc (sizeof (struct lang_decl_var));\n \t\t  DECL_LOCAL_STATIC_VALUE (field_decl) = \n \t\t    TREE_OPERAND (init, 1);\n+\t\t  if (TREE_CONSTANT (TREE_OPERAND (init, 1)))\n+\t\t    DECL_INITIAL (field_decl) = TREE_OPERAND (init, 1);\n \t\t}\n \t      /* Otherwise, the field should be initialized in <clinit>. \n \t\t This field is remembered so we can generate <clinit> later */\n@@ -5679,9 +5686,11 @@ method_header (flags, type, mdecl, throws)\n \tTREE_TYPE (meth) = returned_type;\n       else \n \t{\n+\t  tree itype;\n \t  patch_stage = JDEP_METHOD_RETURN;\n-\t  TREE_TYPE (meth) = \n-\t    register_incomplete_type (patch_stage, type, id, NULL_TREE);\n+\t  itype = register_incomplete_type (patch_stage, type, id, NULL_TREE);\n+\t  TREE_TYPE (meth) = (TREE_CODE (itype) == TREE_LIST ? \n+\t\t\t      TREE_PURPOSE (itype) : itype);\n \t}\n     }\n   else\n@@ -5883,8 +5892,7 @@ check_abstract_method_header (meth)\n {\n   int flags = get_access_flags_from_decl (meth);\n   /* DECL_NAME might still be a WFL node */\n-  tree name = (TREE_CODE (DECL_NAME (meth)) == EXPR_WITH_FILE_LOCATION ?\n-\t       EXPR_WFL_NODE (DECL_NAME (meth)) : DECL_NAME (meth));\n+  tree name = GET_METHOD_NAME (meth);\n \n   OBSOLETE_MODIFIER_WARNING (MODIFIER_WFL (ABSTRACT_TK), flags,\n \t\t\t     ACC_ABSTRACT, \"abstract method `%s'\",\n@@ -6115,6 +6123,7 @@ obtain_incomplete_type (wfl)\n       tree core;\n       push_obstacks (&permanent_obstack, &permanent_obstack);\n       BUILD_PTR_FROM_NAME (core, name);\n+      layout_type (core);\n       ptr = build_tree_list (core, NULL_TREE);\n       pop_obstacks ();\n       TREE_CHAIN (ptr) = ctxp->incomplete_class;\n@@ -6196,10 +6205,6 @@ safe_layout_class (class)\n \n   push_obstacks (&permanent_obstack, &permanent_obstack);\n \n-  if (!CLASS_METHOD_CHECKED_P (class))\n-    CHECK_METHODS (TYPE_NAME (class));\n-  CLASS_METHOD_CHECKED_P (class) = 1;\n-\n   layout_class (class);\n   pop_obstacks ();\n \n@@ -6252,7 +6257,7 @@ java_complete_class ()\n   /* Rever things so we have the right order */\n   ctxp->class_list = nreverse (ctxp->class_list);\n   ctxp->classd_list = reverse_jdep_list (ctxp);\n-    \n+\n   for (cclassd = ctxp->classd_list, cclass = ctxp->class_list; \n        cclass && cclassd; \n        cclass = TREE_CHAIN (cclass), cclassd = CLASSD_CHAIN (cclassd))\n@@ -6261,7 +6266,6 @@ java_complete_class ()\n       for (dep = CLASSD_FIRST (cclassd); dep; dep = JDEP_CHAIN (dep))\n \t{\n \t  tree decl;\n-\n \t  if (!(decl = jdep_resolve_class (dep)))\n \t    continue;\n \n@@ -6357,21 +6361,10 @@ java_complete_class ()\n \t      break;\n \n \t    case JDEP_EXCEPTION:\n-\t      /* Check for righteous inheritance here */\n-\t      if (!inherits_from_p (TREE_TYPE (decl), throwable_type_node))\n-\t\t {\n-\t\t   parse_error_context \n-\t\t     (JDEP_WFL (dep), \"Class `%s' in `throws' clause must be \"\n-\t\t      \"a subclass of class `java.lang.Throwable'\",\n-\t\t      IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_WFL (dep))));\n-\t\t }\n-\t      else \n-\t\t{\n-\t\t  JDEP_APPLY_PATCH (dep, TREE_TYPE (decl));\n-\t\t  SOURCE_FRONTEND_DEBUG \n-\t\t    ((\"Completing `%s' `throws' argument node\",\n-\t\t      IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_WFL (dep)))));\n-\t\t}\n+\t      JDEP_APPLY_PATCH (dep, TREE_TYPE (decl));\n+\t      SOURCE_FRONTEND_DEBUG \n+\t\t((\"Completing `%s' `throws' argument node\",\n+\t\t  IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_WFL (dep)))));\n \t      break;\n \n \t    default:\n@@ -6496,11 +6489,23 @@ do_resolve_class (class_type, decl, cl)\n    parsed class). Return a decl node.  */\n \n static tree\n-resolve_and_layout (name, cl)\n-     tree name;\n+resolve_and_layout (something, cl)\n+     tree something;\n      tree cl;\n {\n-  tree decl = resolve_no_layout (name, cl);\n+  tree decl;\n+\n+  if (TREE_CODE (something) == POINTER_TYPE)\n+    something = TREE_TYPE (something);\n+\n+  if (JPRIMITIVE_TYPE_P (something) || something == void_type_node)\n+    return NULL_TREE;\n+\n+  if (TREE_CODE (something) != IDENTIFIER_NODE)\n+    something = (TREE_CODE (TYPE_NAME (something)) == TYPE_DECL ?\n+\t    DECL_NAME (TYPE_NAME (something)) : TYPE_NAME (something));\n+\n+  decl = resolve_no_layout (something, cl);\n   if (decl && TREE_TYPE (decl) != current_class \n       && !CLASS_LOADED_P (TREE_TYPE (decl)))\n     safe_layout_class (TREE_TYPE (decl));\n@@ -6640,16 +6645,30 @@ reset_method_name (method)\n     {\n       /* NAME is just the plain name when Object is being defined */\n       if (DECL_CONTEXT (method) != object_type_node)\n-\tDECL_NAME (method) = \n-\t  (DECL_CONSTRUCTOR_P (method) ? init_identifier_node :\n-\t   (TREE_CODE (DECL_NAME (method)) == EXPR_WITH_FILE_LOCATION ? \n-\t    EXPR_WFL_NODE (DECL_NAME (method)) : DECL_NAME (method)));\n+\tDECL_NAME (method) = (DECL_CONSTRUCTOR_P (method) ? \n+\t\t\t      init_identifier_node : GET_METHOD_NAME (method));\n       return 0;\n     }\n   else \n     return 1;\n }\n \n+/* Return the name of METHOD_DECL, when DECL_NAME is a WFL */\n+\n+tree\n+java_get_real_method_name (method_decl)\n+     tree method_decl;\n+{\n+  tree method_name = DECL_NAME (method_decl);\n+  if (DECL_CONSTRUCTOR_P (method_decl))\n+    return init_identifier_node;\n+  else if (ctxp \n+\t   && ctxp->current_parsed_class_un == EXPR_WFL_NODE (method_name))\n+    return init_identifier_node;\n+  else\n+    return EXPR_WFL_NODE (method_name);\n+}\n+\n /* Track method being redefined inside the same class. As a side\n    effect, set DECL_NAME to an IDENTIFIER (prior entering this\n    function it's a FWL, so we can track errors more accurately */\n@@ -6703,6 +6722,11 @@ java_check_regular_methods (class_decl)\n   tree class = CLASS_TO_HANDLE_TYPE (TREE_TYPE (class_decl));\n   tree super_class = CLASSTYPE_SUPER (class);\n   tree saved_found_wfl = NULL_TREE, found = NULL_TREE;\n+  tree mthrows;\n+\n+  /* It is not necessary to check methods defined in java.lang.Object */\n+  if (class == object_type_node)\n+    return;\n \n   TYPE_METHODS (class) = nreverse (TYPE_METHODS (class));\n \n@@ -6731,6 +6755,19 @@ java_check_regular_methods (class_decl)\n \t continue;\n        }\n \n+      /* We verify things thrown by the method. They must inherits from\n+\t java.lang.Throwable */\n+      for (mthrows = DECL_FUNCTION_THROWS (method);\n+\t   mthrows; mthrows = TREE_CHAIN (mthrows))\n+\t{\n+\t  if (!inherits_from_p (TREE_VALUE (mthrows), throwable_type_node))\n+\t    parse_error_context \n+\t      (TREE_PURPOSE (mthrows), \"Class `%s' in `throws' clause must be \"\n+\t       \"a subclass of class `java.lang.Throwable'\",\n+\t       IDENTIFIER_POINTER \n+\t         (DECL_NAME (TYPE_NAME (TREE_VALUE (mthrows)))));\n+\t}\n+\n       sig = build_java_argument_signature (TREE_TYPE (method));\n       found = lookup_argument_method (super_class, DECL_NAME (method), sig);\n \n@@ -6820,7 +6857,8 @@ java_check_regular_methods (class_decl)\n \t the match was found in java.lang.Object.  */\n       if (DECL_CONTEXT (found) != object_type_node \n \t  && (!aflags || (aflags > ACC_PROTECTED))\n-\t  && !class_in_current_package (DECL_CONTEXT (found)))\n+\t  && !class_in_current_package (DECL_CONTEXT (found))\n+\t  && flag_not_overriding)\n \tparse_warning_context \n \t  (method_wfl, \"Method `%s' in class `%s' does not \"\n \t   \"override the corresponding method in class `%s', which is \"\n@@ -6867,11 +6905,15 @@ check_throws_clauses (method, method_wfl, found)\n {\n   tree mthrows, fthrows;\n \n+  /* Can't check these things with class loaded from bytecode. FIXME */\n+  if (!CLASS_FROM_SOURCE_P (DECL_CONTEXT (found)))\n+    return;\n+\n   for (mthrows = DECL_FUNCTION_THROWS (method);\n        mthrows; mthrows = TREE_CHAIN (mthrows))\n     {\n       /* We don't verify unchecked expressions */\n-      if (IS_UNCHECKED_EXPRESSION_P (TREE_VALUE (mthrows)))\n+      if (IS_UNCHECKED_EXCEPTION_P (TREE_VALUE (mthrows)))\n \tcontinue;\n       /* Checked expression must be compatible */\n       for (fthrows = DECL_FUNCTION_THROWS (found); \n@@ -6980,10 +7022,7 @@ java_check_methods ()\n   tree current;\n   for (current = ctxp->gclass_list; current; current = TREE_CHAIN (current))\n     if (CLASS_FROM_SOURCE_P (TREE_TYPE (TREE_VALUE (current))))\n-      {\n-\tCHECK_METHODS (TREE_VALUE (current));\n-\tCLASS_METHOD_CHECKED_P (TREE_TYPE (TREE_VALUE (current))) = 1;\n-      }\n+      CHECK_METHODS (TREE_VALUE (current));\n }\n \n /* Lookup methods in interfaces using their name and partial\n@@ -7454,12 +7493,20 @@ declare_local_variables (modifier, type, vlist)\n     {\n       int i;\n       for (i = 0; i <= 10; i++) if (1 << i & modifier) break;\n-      parse_error_context \n-\t(ctxp->modifier_ctx [i],\n-\t (modifier == ACC_FINAL ?\n-\t  \"Unsupported JDK1.1 `final' locals\" :\n-\t  \"Only `final' is allowed as a local variables modifier\"));\n-      return;\n+      if (modifier == ACC_FINAL)\n+\t{\n+\t  if (flag_static_local_jdk1_1)\n+\t    parse_warning_context (ctxp->modifier_ctx [i], \n+\t\t\t\t   \"Unsupported JDK1.1 `final' local variable \"\n+\t\t\t\t   \"(treated as non final)\");\n+\t}\n+      else \n+\t{\n+\t  parse_error_context \n+\t    (ctxp->modifier_ctx [i], \n+\t     \"Only `final' is allowed as a local variables modifier\");\n+\t  return;\n+\t}\n     }\n \n   /* Obtain an incomplete type if TYPE is not complete. TYPE_WFL will\n@@ -7475,7 +7522,7 @@ declare_local_variables (modifier, type, vlist)\n   for (current = vlist, saved_type = type; current;\n        current = TREE_CHAIN (current), type = saved_type)\n     {\n-      tree other;\n+      tree other, real_type;\n       tree wfl  = TREE_PURPOSE (current);\n       tree name = EXPR_WFL_NODE (wfl);\n       tree init = TREE_VALUE (current);\n@@ -7497,10 +7544,11 @@ declare_local_variables (modifier, type, vlist)\n       if (type != saved_type && !must_chain \n \t  && (TREE_CODE (type) == RECORD_TYPE))\n \ttype = promote_type (type);\n-      \n+\n+      real_type = GET_REAL_TYPE (type);\n       /* Never layout this decl. This will be done when its scope\n \t will be entered */\n-      decl = build_decl_no_layout (VAR_DECL, name, type);\n+      decl = build_decl (VAR_DECL, name, real_type);\n       BLOCK_CHAIN_DECL (decl);\n       \n       /* Don't try to use an INIT statement when an error was found */\n@@ -7556,8 +7604,8 @@ source_start_java_method (fndecl)\n       if (INCOMPLETE_TYPE_P (type))\n \t{\n \t  jdep *jdep;\n-\t  parm_decl = build_decl_no_layout (PARM_DECL, name, type);\n-\t  \n+\t  tree real_type = GET_REAL_TYPE (type);\n+\t  parm_decl = build_decl (PARM_DECL, name, real_type);\n \t  register_incomplete_type (JDEP_PARM, NULL_TREE, NULL_TREE, type);\n \t  jdep = CLASSD_LAST (ctxp->classd_list);\n \t  JDEP_MISC (jdep) = name;\n@@ -7752,17 +7800,39 @@ java_layout_classes ()\n     {\n       current_class = TREE_TYPE (TREE_VALUE (current));\n \n-      /* Reverse the fields if it's necessary (they've already\n-         reversed if the dummy field has been inserted at the\n-         beginning of the list */\n-      if (TYPE_FIELDS (current_class)\n-\t  && !DECL_IGNORED_P (TYPE_FIELDS (current_class)))\n-\tTYPE_FIELDS (current_class) = nreverse (TYPE_FIELDS (current_class));\n+      /* Reverse the fields, but leave the dummy field in front.\n+\t Fields are already ordered for Object and Class */\n+      if (TYPE_FIELDS (current_class) && current_class != object_type_node\n+\t  && current_class != class_type_node)\n+      {\n+\t/* Always leave the dummy field in front if its already there,\n+\t   and layout the class for proper field offets. */\n+\tif (!DECL_NAME (TYPE_FIELDS (current_class)))\n+\t  {\n+\t    tree fields = TYPE_FIELDS (current_class);\n+\t    TREE_CHAIN (fields) = nreverse (TREE_CHAIN (fields));\n+\t    TYPE_SIZE (current_class) = NULL_TREE;\n+\t    layout_type (current_class);\n+\t  }\n+\t/* It's time to layout the class */\n+\telse\n+\t  {\n+\t    TYPE_FIELDS (current_class) = \n+\t      nreverse (TYPE_FIELDS (current_class));\n+\t    TYPE_SIZE (current_class) = NULL_TREE;\n+\t    layout_class (current_class);\n+\t  }\n+      }\n       \n       /* Do a layout if necessary */\n-      if (!TYPE_SIZE (current_class) || (current_class == object_type_node))\n+      if (!TYPE_SIZE (current_class) \n+\t  || (current_class == object_type_node)\n+\t  || current_class == class_type_node)\n \tsafe_layout_class (current_class);\n \n+      /* From now on, the class is considered completely loaded */\n+      CLASS_LOADED_P (current_class) = 1;\n+\n       /* Error reported by the caller */\n       if (java_error_count)\n \treturn;\n@@ -7847,6 +7917,8 @@ java_complete_expand_method (mdecl)\n   /* Expand functions that have a body */\n   if (DECL_FUNCTION_BODY (mdecl))\n     {\n+      tree fbody = DECL_FUNCTION_BODY (mdecl);\n+      tree block_body = BLOCK_EXPR_BODY (fbody);\n       expand_start_java_method (mdecl);\n \n       current_this \n@@ -7859,9 +7931,16 @@ java_complete_expand_method (mdecl)\n       /* Install exceptions thrown with `throws' */\n       PUSH_EXCEPTIONS (DECL_FUNCTION_THROWS (mdecl));\n \n-      if (BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (mdecl)))\n-\tjava_complete_tree (BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (mdecl)));\n+      if (block_body != NULL_TREE)\n+\tblock_body = java_complete_tree (block_body);\n+      BLOCK_EXPR_BODY (fbody) = block_body;\n \n+      if ((block_body == NULL_TREE || CAN_COMPLETE_NORMALLY (block_body))\n+\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (mdecl))) != VOID_TYPE)\n+\t{\n+\t  parse_error_context (fbody, \"Missing return statement\");\n+\t}\n+      \n       /* Don't go any further if we've found error(s) during the\n          expansion */\n       if (!java_error_count)\n@@ -8289,15 +8368,15 @@ resolve_field_access (qual_wfl, field_decl, field_type)\n \t\t\t\t     type_found, DECL_NAME (decl));\n       if (field_ref == error_mark_node)\n \treturn error_mark_node;\n-      if (is_static && !static_final_found\n-\t  && ! flag_emit_class_files)\n+      if (is_static && !static_final_found && !flag_emit_class_files)\n \t{\n \t  field_ref = build_class_init (type_found, field_ref);\n \t  /* If the static field was identified by an expression that\n \t     needs to be generated, make the field access a compound\n \t     expression whose first part of the evaluation of the\n \t     field selector part. */\n-\t  if (where_found && TREE_CODE (where_found) != TYPE_DECL)\n+\t  if (where_found && TREE_CODE (where_found) != TYPE_DECL \n+\t      && TREE_CODE (where_found) != RECORD_TYPE)\n \t    {\n \t      tree type = QUAL_DECL_TYPE (field_ref);\n \t      field_ref = build (COMPOUND_EXPR, type, where_found, field_ref);\n@@ -8310,7 +8389,8 @@ resolve_field_access (qual_wfl, field_decl, field_type)\n   if (field_decl)\n     *field_decl = decl;\n   if (field_type)\n-    *field_type = QUAL_DECL_TYPE (decl);\n+    *field_type = (QUAL_DECL_TYPE (decl) ? \n+\t\t   QUAL_DECL_TYPE (decl) : TREE_TYPE (decl));\n   return field_ref;\n }\n \n@@ -8326,7 +8406,7 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n   int previous_call_static = 0;\n   int is_static;\n   tree decl = NULL_TREE, type = NULL_TREE, q;\n-  *where_found = NULL_TREE;\n+  *type_found = *where_found = NULL_TREE;\n \n   for (q = EXPR_WFL_QUALIFICATION (wfl); q; q = TREE_CHAIN (q))\n     {\n@@ -8517,10 +8597,16 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t  if (!from_super && QUAL_RESOLUTION (q))\n \t    {\n \t      decl = QUAL_RESOLUTION (q);\n-\t      if (!type && !FIELD_STATIC (decl))\n+\t      if (!type)\n \t\t{\n-\t\t  *where_found = current_this;\n-\t\t  *type_found = type;\n+\t\t  if (!FIELD_STATIC (decl))\n+\t\t    *where_found = current_this;\n+\t\t  else\n+\t\t    {\n+\t\t      *where_found = TREE_TYPE (decl);\n+\t\t      if (TREE_CODE (*where_found) == POINTER_TYPE)\n+\t\t\t*where_found = TREE_TYPE (*where_found);\n+\t\t    }\n \t\t}\n \t    }\n \n@@ -8556,15 +8642,19 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t\t}\n \n \t      /* Layout the type of field_decl, since we may need\n-                 it. Don't do primitive types or loaded classes */\n+                 it. Don't do primitive types or loaded classes. The\n+                 situation of non primitive arrays may not handled\n+                 properly here. FIXME */\n \t      if (TREE_CODE (TREE_TYPE (field_decl)) == POINTER_TYPE)\n \t\tfield_decl_type = TREE_TYPE (TREE_TYPE (field_decl));\n \t      else\n \t\tfield_decl_type = TREE_TYPE (field_decl);\n \t      if (!JPRIMITIVE_TYPE_P (field_decl_type) \n-\t\t  && !CLASS_LOADED_P (field_decl_type))\n-\t\tresolve_and_layout (DECL_NAME (TYPE_NAME (field_decl_type)),\n-\t\t\t\t    NULL_TREE);\n+\t\t  && !CLASS_LOADED_P (field_decl_type)\n+\t\t  && !TYPE_ARRAY_P (field_decl_type))\n+\t\tresolve_and_layout (field_decl_type, NULL_TREE);\n+\t      if (TYPE_ARRAY_P (field_decl_type))\n+\t\tCLASS_LOADED_P (field_decl_type) = 1;\n \t      \n \t      /* Check on accessibility here */\n \t      if (not_accessible_p (type, field_decl, from_super))\n@@ -8648,32 +8738,19 @@ int not_accessible_p (reference, member, from_super)\n       if (class_in_current_package (DECL_CONTEXT (member)))\n \treturn 0;\n \n-      if (TREE_CODE (member) == FUNCTION_DECL && DECL_CONSTRUCTOR_P (member))\n-\t{\n-\t  /* Access from SUPER is granted */\n-\t  if (from_super)\n-\t    return 0;\n-\t  /* Otherwise, access isn't granted */\n-\t  return 1;\n-\t}\n-      else\n-\t{\n-\t  /* If accessed with the form `super.member', then access is\n-             granted */\n-\t  if (from_super)\n-\t    return 0;\n+      /* If accessed with the form `super.member', then access is granted */\n+      if (from_super)\n+\treturn 0;\n \n-\t  /* Otherwise, access is granted if occuring from the class where\n-\t     member is declared or a subclass of it */\n-\t  if (inherits_from_p (reference, current_class))\n-\t    return 0;\n-\t}\n+      /* Otherwise, access is granted if occuring from the class where\n+\t member is declared or a subclass of it */\n+      if (inherits_from_p (reference, current_class))\n+\treturn 0;\n       return 1;\n     }\n \n   /* Check access on private members. Access is granted only if it\n-     occurs from within the class in witch it is declared*/\n-\n+     occurs from within the class in witch it is declared */\n   if (access_flag & ACC_PRIVATE)\n     return (current_class == DECL_CONTEXT (member) ? 0 : 1);\n \n@@ -8872,9 +8949,9 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl, super)\n \t  \n \t  /* 2- Do the layout of the class where the last field\n \t     was found, so we can search it. */\n-\t  class_decl = \n-\t    resolve_and_layout (DECL_NAME (TYPE_NAME (type)), NULL_TREE);\n-\t  \n+\t  class_decl = resolve_and_layout (type, NULL_TREE);\n+\t  type = TREE_TYPE (class_decl);\n+\n \t  /* 3- Retrieve a filtered list of method matches, Refine\n \t     if necessary. In any cases, point out errors.  */\n \t  list = lookup_method_invoke (0, identifier_wfl, type, \n@@ -8956,6 +9033,7 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl, super)\n       /* NAME is a simple identifier or comes from a primary. Search\n \t in the class whose declaration contain the method being\n \t invoked. */\n+      resolve_and_layout (class_to_search, NULL_TREE);\n       list = lookup_method_invoke (lc, wfl, class_to_search, name, args);\n \n       /* Don't continue if no method were found, as the next statement\n@@ -8984,7 +9062,7 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl, super)\n \n   /* Check accessibility, position the is_static flag, build and\n      return the call */\n-  if (not_accessible_p (DECL_CONTEXT (list), list, 0))\n+  if (not_accessible_p (DECL_CONTEXT (current_function_decl), list, 0))\n     {\n       char *fct_name = strdup (lang_printable_name (list, 0));\n       parse_error_context \n@@ -9170,20 +9248,26 @@ lookup_method_invoke (lc, cl, class, name, arg_list)\n      tree cl;\n      tree class, name, arg_list;\n {\n-  tree method = make_node (FUNCTION_TYPE);\n   tree atl = NULL_TREE;\t\t/* Arg Type List */\n-  tree signature, list, node;\n+  tree method, signature, list, node;\n   char *candidates;\t\t/* Used for error report */\n \n   /* Fix the arguments */\n   for (node = arg_list; node; node = TREE_CHAIN (node))\n     {\n-      tree current_arg = TREE_TYPE (TREE_VALUE (node));\n+      tree current_arg = TREE_VALUE (node);\n+      /* Integer constant 0 passed as itself, not as a type */\n+      if (current_arg != integer_zero_node)\n+\tcurrent_arg = TREE_TYPE (TREE_VALUE (node));\n+      /* Non primitive type may have to be resolved */\n+      if (current_arg != integer_zero_node \n+\t  && !JPRIMITIVE_TYPE_P (current_arg))\n+\tresolve_and_layout (current_arg, NULL_TREE);\n+      /* And promoted */\n       if (TREE_CODE (current_arg) == RECORD_TYPE)\n-\tcurrent_arg = promote_type (current_arg);\n+        current_arg = promote_type (current_arg);\n       atl = tree_cons (NULL_TREE, current_arg, atl);\n     }\n-  TYPE_ARG_TYPES (method) = atl;\n \n   /* Find all candidates and then refine the list, searching for the\n      most specific method. */\n@@ -9217,6 +9301,11 @@ lookup_method_invoke (lc, cl, class, name, arg_list)\n       candidates = obstack_finish (&temporary_obstack);\n     }\n   /* Issue the error message */\n+  for (node = atl; node; node = TREE_CHAIN (node))\n+    if (TREE_VALUE (node) == integer_zero_node)\n+      TREE_VALUE (node) = long_type_node;\n+  method = make_node (FUNCTION_TYPE);\n+  TYPE_ARG_TYPES (method) = atl;\n   signature = build_java_argument_signature (method);\n   parse_error_context (cl, \"Can't find %s `%s(%s)' in class `%s'%s\",\n \t\t       (lc ? \"constructor\" : \"method\"),\n@@ -9248,13 +9337,14 @@ find_applicable_accessible_methods_list (lc, class, name, arglist)\n \t  if (lc && !DECL_CONSTRUCTOR_P (method))\n \t    continue;\n \t  else if (!lc && (DECL_CONSTRUCTOR_P (method)\n-\t\t\t   || DECL_NAME (method) != name))\n+\t\t\t   || (GET_METHOD_NAME (method) != name)))\n \t    continue;\n \t  \n \t  if (argument_types_convertible (method, arglist))\n \t    {\n \t      /* Retain accessible methods only */\n-\t      if (!not_accessible_p (class, method, 0))\n+\t      if (!not_accessible_p (DECL_CONTEXT (current_function_decl), \n+\t\t\t\t     method, 0))\n \t\tlist = tree_cons (NULL_TREE, method, list);\n \t      else\n \t      /* Also retain all selected method here */\n@@ -9361,6 +9451,7 @@ argument_types_convertible (m1, m2_or_arglist)\n \n   while (m1_arg && m2_arg)\n     {\n+      resolve_and_layout (TREE_VALUE (m1_arg), NULL_TREE);\n       if (!valid_method_invocation_conversion_p (TREE_VALUE (m1_arg),\n \t\t\t\t\t\t TREE_VALUE (m2_arg)))\n \tbreak;\n@@ -9492,7 +9583,8 @@ qualify_ambiguous_name (id)\n     }\n \n   /* Method call are expression name */\n-  else if (TREE_CODE (QUAL_WFL (qual)) == CALL_EXPR)\n+  else if (TREE_CODE (QUAL_WFL (qual)) == CALL_EXPR\n+\t   || TREE_CODE (QUAL_WFL (qual)) == ARRAY_REF)\n     RESOLVE_EXPRESSION_NAME_P (qual_wfl) = 1;\n \n   /* Check here that NAME isn't declared by more than one\n@@ -9553,22 +9645,6 @@ breakdown_qualified (left, right, source)\n   return 0;\n }\n \n-static int\n-not_initialized_as_it_should_p (decl)\n-     tree decl;\n-{\n-  if (DECL_P (decl))\n-    {\n-      if (FIELD_FINAL (decl))\n-\treturn 0;\n-      if (TREE_CODE (decl) == FIELD_DECL \n-\t  && (METHOD_STATIC (current_function_decl)))\n-\treturn 0;\n-      return DECL_P (decl) && !INITIALIZED_P (decl);\n-    }\n-  return 0;\n-}\n-\n /* Patch tree nodes in a function body. When a BLOCK is found, push\n    local variable decls if present.  */\n \n@@ -9610,7 +9686,8 @@ java_complete_tree (node)\n \t  int error_seen = 0;\n \t  if (TREE_CODE (stmt) == COMPOUND_EXPR)\n \t    {\n-\t      /* Re-order from (((A; B); C); ...; Z) to (A; (B; (C ; (...; Z)))).\n+\t      /* Re-order from (((A; B); C); ...; Z) to \n+\t\t (A; (B; (C ; (...; Z)))).\n \t\t This makes it easier to scan the statements left-to-right\n \t\t without using recursion (which might overflow the stack\n \t\t if the block has many statements. */\n@@ -9626,7 +9703,8 @@ java_complete_tree (node)\n \t      BLOCK_EXPR_BODY (node) = stmt;\n \t    }\n \n-\t  /* Now do the actual complete, without deep recursion for long blocks. */\n+\t  /* Now do the actual complete, without deep recursion for\n+             long blocks. */\n \t  ptr = &BLOCK_EXPR_BODY (node);\n \t  while (TREE_CODE (*ptr) == COMPOUND_EXPR)\n \t    {\n@@ -9651,7 +9729,8 @@ java_complete_tree (node)\n \t\t      && TREE_CODE (wfl_op2) != DEFAULT_EXPR)\n \t\t    {\n \t\t      SET_WFL_OPERATOR (wfl_operator, *ptr, wfl_op2);\n-\t\t      parse_error_context (wfl_operator, \"Unreachable statement\");\n+\t\t      parse_error_context (wfl_operator, \n+\t\t\t\t\t   \"Unreachable statement\");\n \t\t    }\n \t\t}\n \t      ptr = next;\n@@ -9719,7 +9798,8 @@ java_complete_tree (node)\n       nn = ctxp->current_loop;\n \n       /* It must be assignable to the type of the switch expression. */\n-      if (!try_builtin_assignconv (NULL_TREE, TREE_TYPE (TREE_OPERAND (nn, 0)), cn))\n+      if (!try_builtin_assignconv (NULL_TREE, \n+\t\t\t\t   TREE_TYPE (TREE_OPERAND (nn, 0)), cn))\n \t{\n \t  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);\n \t  parse_error_context \n@@ -9735,6 +9815,7 @@ java_complete_tree (node)\n \t value is checked during code generation. The case\n \t expression is allright so far. */\n       TREE_OPERAND (node, 0) = cn;\n+      TREE_TYPE (node) = void_type_node;\n       CAN_COMPLETE_NORMALLY (node) = 1;\n       break;\n \n@@ -9750,6 +9831,7 @@ java_complete_tree (node)\n \t}\n       else\n \tSWITCH_HAS_DEFAULT (nn) = 1;\n+      TREE_TYPE (node) = void_type_node;\n       CAN_COMPLETE_NORMALLY (node) = 1;\n       break;\n \n@@ -9896,18 +9978,17 @@ java_complete_tree (node)\n \t  tree decl, wfl = TREE_OPERAND (node, 0);\n \t  int in_this = CALL_THIS_CONSTRUCTOR_P (node);\n \n-\t  node = patch_method_invocation (node, NULL_TREE,\n+\t  node = patch_method_invocation (node, NULL_TREE, \n \t\t\t\t\t  NULL_TREE, 0, &decl, 0);\n-\t  if (node != error_mark_node)\n-\t    {\n-\t      check_thrown_exceptions (EXPR_WFL_LINECOL (node), decl);\n-\t      /* If we call this(...), register signature and positions */\n-\t      if (in_this)\n-\t\tDECL_CONSTRUCTOR_CALLS (current_function_decl) = \n-\t\t  tree_cons (wfl, decl,\n-\t\t\t     DECL_CONSTRUCTOR_CALLS (current_function_decl));\n-\t\t\n-\t    }\n+\t  if (node == error_mark_node)\n+\t    return error_mark_node;\n+\n+\t  check_thrown_exceptions (EXPR_WFL_LINECOL (node), decl);\n+\t  /* If we call this(...), register signature and positions */\n+\t  if (in_this)\n+\t    DECL_CONSTRUCTOR_CALLS (current_function_decl) = \n+\t      tree_cons (wfl, decl, \n+\t\t\t DECL_CONSTRUCTOR_CALLS (current_function_decl));\n \t  return node;\n \t}\n \n@@ -9937,6 +10018,13 @@ java_complete_tree (node)\n       nn = java_complete_tree (TREE_OPERAND (node, 1));\n       if (nn == error_mark_node)\n \t{\n+\t  /* It's hopeless, but we can further things on to discover\n+\t     an error during the assignment. In any cases, the\n+\t     assignment operation fails. */\n+\t  if (TREE_CODE (TREE_OPERAND (node, 1)) != EXPR_WITH_FILE_LOCATION\n+\t      && TREE_TYPE (TREE_OPERAND (node, 1)) != error_mark_node)\n+\t    patch_assignment (node, wfl_op1, wfl_op2);\n+\n \t  /* Now, we still mark the lhs as initialized */\n \t  if (DECL_P (TREE_OPERAND (node, 0)))\n \t    INITIALIZED_P (TREE_OPERAND (node, 0)) = 1;\n@@ -10033,7 +10121,14 @@ java_complete_tree (node)\n \treturn error_mark_node;\n       if (!flag_emit_class_files)\n \tTREE_OPERAND (node, 1) = save_expr (TREE_OPERAND (node, 1));\n-      return patch_array_ref (node, wfl_op1, wfl_op2);\n+      return patch_array_ref (node);\n+\n+#if 0 \n+    COMPONENT_REF:\n+      /* Planned re-write FIXME */\n+      TREE_OPERAND (node, 0) = java_complete_tree (TREE_OPERAND (node, 0));\n+      break;\n+#endif\n \n     case THIS_EXPR:\n       /* Can't use THIS in a static environment */\n@@ -10098,11 +10193,6 @@ complete_function_arguments (node)\n       parm = maybe_build_primttype_type_ref (parm, wfl);\n \n       TREE_VALUE (cn) = parm;\n-      if (not_initialized_as_it_should_p (parm))\n-\t{\n-\t  ERROR_VARIABLE_NOT_INITIALIZED (wfl, EXPR_WFL_NODE (wfl));\n-\t  INITIALIZED_P (parm) = 1;\n-\t}\n     }\n   ctxp->explicit_constructor_p -= (CALL_THIS_CONSTRUCTOR_P (node) ? 1 : 0);\n   return flag;\n@@ -10230,14 +10320,14 @@ maybe_absorb_scoping_blocks ()\n    are building incomplete tree nodes and the patch_* functions that\n    are completing them.  */\n \n-/* Build a super() constructor invocation. Returns size_zero_node if\n+/* Build a super() constructor invocation. Returns empty_stmt_node if\n    we're currently dealing with the class java.lang.Object. */\n \n static tree\n build_super_invocation ()\n {\n   if (current_class == object_type_node)\n-    return size_zero_node;\n+    return empty_stmt_node;\n   else\n     {\n       tree super_wfl = build_wfl_node (super_identifier_node, \n@@ -10488,29 +10578,12 @@ patch_assignment (node, wfl_op1, wfl_op2)\n       error_found = 1;\n     }\n \n-  /* Before reporting type incompatibility errors, check that the rhs\n-     is initialized, if a variable */\n-  if (not_initialized_as_it_should_p (rhs))\n-    {\n-      ERROR_VARIABLE_NOT_INITIALIZED (wfl_op2, DECL_NAME (rhs));\n-      INITIALIZED_P (rhs) = 1;\n-    }\n-\n   /* Inline read access to java.lang.PRIMTYPE.TYPE */\n   rhs = maybe_build_primttype_type_ref (rhs, wfl_op2);\n \n-  if (TREE_CODE (rhs) == COMPOUND_EXPR)\n-    {\n-      tree n = TREE_OPERAND (rhs, 1);\n-      if (TREE_CODE (n) == VAR_DECL \n-\t  && DECL_NAME (n) == TYPE_identifier_node\n-\t  && rhs_type == class_ptr_type)\n-\t{\n-\t  char *self_name = IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl_op2));\n-\t  if (!strncmp (self_name, \"java.lang.\", 10))\n-\t    rhs = build_primtype_type_ref (self_name);\n-\t}\n-    }\n+  /* Inline read access to java.lang.PRIMTYPE.TYPE */\n+  if (new_rhs)\n+    new_rhs = maybe_build_primttype_type_ref (new_rhs, wfl_op2);\n \n   if (error_found)\n     return error_mark_node;\n@@ -10613,6 +10686,11 @@ valid_builtin_assignconv_identity_widening_p (lhs_type, rhs_type)\n   if (lhs_type == rhs_type)\n     return 1;\n \n+  /* Sometimes, instead of passing a type, we pass integer_zero_node\n+     so we know that an integral type can accomodate it */\n+  if (JINTEGRAL_TYPE_P (lhs_type) && (rhs_type == integer_zero_node))\n+    return 1;\n+\n   all_primitive = \n     JPRIMITIVE_TYPE_P (lhs_type) && JPRIMITIVE_TYPE_P (rhs_type);\n \n@@ -10793,7 +10871,7 @@ static int\n valid_method_invocation_conversion_p (dest, source)\n      tree dest, source;\n {\n-  return ((JPRIMITIVE_TYPE_P (source) \n+  return (((JPRIMITIVE_TYPE_P (source) || (source == integer_zero_node))\n \t    && JPRIMITIVE_TYPE_P (dest)\n \t    && valid_builtin_assignconv_identity_widening_p (dest, source))\n \t   || ((JREFERENCE_TYPE_P (source) || JNULLP_TYPE_P (source))\n@@ -10894,24 +10972,8 @@ patch_binop (node, wfl_op1, wfl_op2)\n      after checking for the initialization of the RHS */\n   int error_found = 0;\n \n-  /* Figure what is going to be checked first for initialization prior\n-     its use. If NODE is part of a compound assignment, we check the\n-     second operand first, otherwise the first one first. We also\n-     initialize the matching WFL for the error report. `cfi' stands\n-     for Check For Initialization */\n-  tree cfi = (COMPOUND_ASSIGN_P (node) ? op2 : op1);\n-  tree cfi_wfl = (COMPOUND_ASSIGN_P (node) ? wfl_op2 : wfl_op1);\n-\n   EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);\n \n-  /* Check initialization of LHS first. We then silence further error\n-     message if the variable wasn't initialized */\n-  if (not_initialized_as_it_should_p (cfi))\n-    {\n-      ERROR_VARIABLE_NOT_INITIALIZED (cfi_wfl, DECL_NAME (cfi));\n-      INITIALIZED_P (op1) = 1;\n-    }\n-\n   switch (code)\n     {\n     /* 15.16 Multiplicative operators */\n@@ -11189,16 +11251,6 @@ patch_binop (node, wfl_op1, wfl_op2)\n       break;\n     }\n \n-  /* Then check the initialization of the RHS. We don't do that if\n-     we're dealing with a node that is part of a compound\n-     assignment. We then silence further error message if the variable\n-     wasn't initialized */\n-  if (not_initialized_as_it_should_p (op2) && !COMPOUND_ASSIGN_P (node))\n-    {\n-      ERROR_VARIABLE_NOT_INITIALIZED (wfl_op2, DECL_NAME (op2));\n-      INITIALIZED_P (op2) = 1;\n-    }\n-\n   if (error_found)\n     return error_mark_node;\n \n@@ -11374,8 +11426,15 @@ patch_string (node)\n     return patch_string_cst (node);\n   else if (IS_CRAFTED_STRING_BUFFER_P (node))\n     {\n+      int saved = ctxp->explicit_constructor_p;\n       tree invoke = build_method_invocation (wfl_to_string, NULL_TREE);\n-      return java_complete_tree (make_qualified_primary (node, invoke, 0));\n+      tree ret;\n+      /* Temporary disable forbid the use of `this'. */\n+      ctxp->explicit_constructor_p = 0;\n+      ret = java_complete_tree (make_qualified_primary (node, invoke, 0));\n+      /* Restore it at its previous value */\n+      ctxp->explicit_constructor_p = saved;\n+      return ret;\n     }\n   return NULL_TREE;\n }\n@@ -11573,6 +11632,8 @@ patch_unaryop (node, wfl_op)\n       if (TREE_CODE (op_type) != BOOLEAN_TYPE)\n \t{\n \t  ERROR_CANT_CONVERT_TO_BOOLEAN (wfl_operator, node, op_type);\n+\t  /* But the type is known. We will report an error if further\n+\t     attempt of a assignment is made with this rhs */\n \t  TREE_TYPE (node) = boolean_type_node;\n \t  error_found = 1;\n \t}\n@@ -11584,8 +11645,15 @@ patch_unaryop (node, wfl_op)\n     case CONVERT_EXPR:\n       value = patch_cast (node, wfl_operator);\n       if (value == error_mark_node)\n-\treturn value;\n-      node = value;\n+\t{\n+\t  /* If this cast is part of an assignment, we tell the code\n+\t     that deals with it not to complain about a mismatch,\n+\t     because things have been cast, anyways */\n+\t  TREE_TYPE (node) = error_mark_node;\n+\t  error_found = 1;\n+\t}\n+      else\n+\tnode = value;\n       break;\n     }\n   \n@@ -11725,8 +11793,8 @@ build_array_ref (location, array, index)\n /* 15.12 Array Access Expression */\n \n static tree\n-patch_array_ref (node, wfl_array, wfl_index)\n-     tree node, wfl_array, wfl_index;\n+patch_array_ref (node)\n+     tree node;\n {\n   tree array = TREE_OPERAND (node, 0);\n   tree array_type  = TREE_TYPE (array);\n@@ -12032,10 +12100,8 @@ build_if_else_statement (location, expression, if_body, else_body)\n      tree expression, if_body, else_body;\n {\n   tree node;\n-  /* FIXME: make else body be a void node, where this function is\n-     called */\n   if (!else_body)\n-    else_body = build (COMPOUND_EXPR, void_type_node, NULL_TREE, NULL_TREE);\n+    else_body = empty_stmt_node;\n   node = build (COND_EXPR, NULL_TREE, expression, if_body, else_body);\n   EXPR_WFL_LINECOL (node) = location;\n   node = build_debugable_stmt (location, node);\n@@ -12065,8 +12131,8 @@ patch_if_else_statement (node)\n   TREE_TYPE (node) = void_type_node;\n   TREE_SIDE_EFFECTS (node) = 1;\n   CAN_COMPLETE_NORMALLY (node)\n-    = CAN_COMPLETE_NORMALLY (TREE_OPERAND (node, 0))\n-    | CAN_COMPLETE_NORMALLY (TREE_OPERAND (node, 1));\n+    = CAN_COMPLETE_NORMALLY (TREE_OPERAND (node, 1))\n+    | CAN_COMPLETE_NORMALLY (TREE_OPERAND (node, 2));\n   return node;\n }\n \n@@ -12192,7 +12258,7 @@ build_loop_body (location, condition, reversed)\n   second = (reversed ? condition : body);\n   return \n     build (COMPOUND_EXPR, NULL_TREE, \n-\t   build (COMPOUND_EXPR, NULL_TREE, first, second), size_zero_node);\n+\t   build (COMPOUND_EXPR, NULL_TREE, first, second), empty_stmt_node);\n }\n \n /* Install CONDITION (if any) and loop BODY (using REVERSED to tell\n@@ -12439,7 +12505,7 @@ static tree\n patch_switch_statement (node)\n      tree node;\n {\n-  tree se = TREE_OPERAND (node, 0), se_type, sb;\n+  tree se = TREE_OPERAND (node, 0), se_type;\n \n   /* Complete the switch expression */\n   se = TREE_OPERAND (node, 0) = java_complete_tree (se);\n@@ -12468,7 +12534,8 @@ patch_switch_statement (node)\n   TREE_TYPE (node) = void_type_node;\n   TREE_SIDE_EFFECTS (node) = 1;\n   CAN_COMPLETE_NORMALLY (node)\n-    = CAN_COMPLETE_NORMALLY (TREE_OPERAND (node, 1)) ||\t! SWITCH_HAS_DEFAULT (node);\n+    = CAN_COMPLETE_NORMALLY (TREE_OPERAND (node, 1)) \n+      || ! SWITCH_HAS_DEFAULT (node);\n   return node;\n }\n \n@@ -12516,8 +12583,7 @@ build_try_statement (location, try_block, catches, finally)\n \t sequence. It hold a local variable used to return from the\n \t finally using a computed goto. We call it\n \t return_from_finally (RFF). */\n-      rff = build_decl_no_layout (VAR_DECL, generate_name (),\n-\t\t\t\t   return_address_type_node);\n+      rff = build_decl (VAR_DECL, generate_name (), return_address_type_node);\n \n       /* Modification of the try block. */\n       try_block = build_jump_to_finally (try_block, rff, \n@@ -12552,8 +12618,7 @@ build_try_statement (location, try_block, catches, finally)\n \t\t CALL_EXPR\n \t\t   Jv_ReThrow\n \t\t   exception_parameter */\n-\t  catch_decl = build_decl_no_layout (VAR_DECL, generate_name (),\n-\t\t\t\t\t     ptr_type_node);\n+\t  catch_decl = build_decl (VAR_DECL, generate_name (), ptr_type_node);\n \t  BUILD_ASSIGN_EXCEPTION_INFO (stmt, catch_decl);\n \t  catch_block = build_expr_block (stmt, NULL_TREE);\n \t  catch_block = build_jump_to_finally (catch_block, rff, \n@@ -12685,7 +12750,6 @@ patch_try_statement (node)\n \t      break;\n \t    }\n \t}\n-\n       /* Complete the catch clause block */\n       catch_block = java_complete_tree (TREE_OPERAND (current, 0));\n       if (catch_block == error_mark_node)\n@@ -12704,7 +12768,6 @@ patch_try_statement (node)\n \n       /* Link this type to the caught type list */\n       caught_type_list = tree_cons (NULL_TREE, carg_type, caught_type_list);\n-\n     }\n \n   PUSH_EXCEPTIONS (caught_type_list);\n@@ -12782,7 +12845,7 @@ patch_synchronized_statement (node, wfl_op1)\n   try_block = build_expr_block (compound, NULL_TREE);\n \n   /* CATCH_ALL block */\n-  decl = build_decl_no_layout (VAR_DECL, generate_name (), ptr_type_node);\n+  decl = build_decl (VAR_DECL, generate_name (), ptr_type_node);\n   BUILD_ASSIGN_EXCEPTION_INFO (stmt, decl);\n   compound = add_stmt_to_compound (NULL_TREE, void_type_node, stmt);\n   BUILD_MONITOR_EXIT (stmt, expr);\n@@ -12824,7 +12887,7 @@ patch_throw_statement (node, wfl_op1)\n \n   /* The type of the throw expression is a not checked exception,\n      i.e. is a unchecked expression. */\n-  unchecked_ok = IS_UNCHECKED_EXPRESSION_P (TREE_TYPE (type));\n+  unchecked_ok = IS_UNCHECKED_EXCEPTION_P (TREE_TYPE (type));\n \n   /* Throw is contained in a try statement and at least one catch\n      clause can receive the thrown expression or the current method is\n@@ -12897,7 +12960,7 @@ check_thrown_exceptions (location, decl)\n       }\n }\n \n-/* Return 1 if EXCEPTION is caught at the current nesting level of\n+/* Return 1 if checked EXCEPTION is caught at the current nesting level of\n    try-catch blocks, OR is listed in the `throws' clause of the\n    current method.  */\n \n@@ -12906,8 +12969,11 @@ check_thrown_exceptions_do (exception)\n      tree exception;\n {\n   tree list = currently_caught_type_list;\n+  resolve_and_layout (exception, NULL_TREE);\n   /* First, all the nested try-catch-finally at that stage. The\n      last element contains `throws' clause exceptions, if any. */\n+  if (IS_UNCHECKED_EXCEPTION_P (exception))\n+    return 1;\n   while (list)\n     {\n       tree caught;\n@@ -12929,7 +12995,7 @@ purge_unchecked_exceptions (mdecl)\n   while (throws)\n     {\n       tree next = TREE_CHAIN (throws);\n-      if (!IS_UNCHECKED_EXPRESSION_P (TREE_VALUE (throws)))\n+      if (!IS_UNCHECKED_EXCEPTION_P (TREE_VALUE (throws)))\n \t{\n \t  TREE_CHAIN (throws) = new;\n \t  new = throws;"}, {"sha": "b2b064457893200fecb150733b54141233190f3b", "filename": "gcc/java/parse.h", "status": "modified", "additions": 41, "deletions": 22, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c877974e79791c251316548175df8749ed657df9/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c877974e79791c251316548175df8749ed657df9/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=c877974e79791c251316548175df8749ed657df9", "patch": "@@ -122,11 +122,18 @@ extern tree stabilize_reference PROTO ((tree));\n \t\t (s1 [0]=='S' ? \"Supertype\" : \"supertype\") :\t\\\n \t\t (s1 [0] > 'A' ? \"Type\" : \"type\")))\n \n+#define GET_REAL_TYPE(TYPE) \t\t\t\t\t\\\n+  (TREE_CODE (TYPE) == TREE_LIST ? TREE_PURPOSE (TYPE) : TYPE)\n+\n+#define GET_METHOD_NAME(METHOD)\t\t\t\t\t\\\n+  (TREE_CODE (DECL_NAME (METHOD)) == EXPR_WITH_FILE_LOCATION ?\t\\\n+   EXPR_WFL_NODE (DECL_NAME (METHOD)) : DECL_NAME (METHOD))\n+\n /* Pedantic warning on obsolete modifiers. Note: when cl is NULL,\n    flags was set artificially, such as for a interface method */\n #define OBSOLETE_MODIFIER_WARNING(cl, flags, modifier, format, arg)          \\\n   {                                                                          \\\n-    if ((cl) && ((flags) & (modifier)))\t\t\t\t\t     \\\n+    if (flag_redundant && (cl) && ((flags) & (modifier)))\t\t     \\\n       parse_warning_context (cl,                                             \\\n \t\t\t     \"Discouraged redundant use of `%s' modifier \"   \\\n \t\t\t     \"in declaration of \" format,                    \\\n@@ -411,22 +418,31 @@ static jdeplist *reverse_jdep_list ();\n /* if TYPE can't be resolved, obtain something suitable for its\n    resolution (TYPE is saved in SAVE before being changed). and set\n    CHAIN to 1. Otherwise, type is set to something usable. CHAIN is\n-   usually used to determine that a new DEP must be installed on TYPE.  */\n-#define SET_TYPE_FOR_RESOLUTION(TYPE, SAVE, CHAIN)\t\\\n-  {\t\t\t\t\t\t\t\\\n-    tree returned_type;\t\t\t\t\t\\\n-    (CHAIN) = 0;\t\t\t\t\t\\\n-    if (unresolved_type_p (type, &returned_type))\t\\\n-      {\t\t\t\t\t\t\t\\\n-\tif (returned_type)\t\t\t\t\\\n-\t  (TYPE) = returned_type;\t\t\t\\\n-\telse\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\\\n-\t    (SAVE) = (TYPE);\t\t\t\t\\\n-\t    (TYPE) = obtain_incomplete_type (TYPE);\t\\\n-\t    CHAIN = 1;\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\\\n+   usually used to determine that a new DEP must be installed on TYPE.\n+   Note that when compiling java.lang.Object, references to Object are\n+   java.lang.Object.  */\n+#define SET_TYPE_FOR_RESOLUTION(TYPE, SAVE, CHAIN)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    tree returned_type;\t\t\t\t\t\t\t\\\n+    (CHAIN) = 0;\t\t\t\t\t\t\t\\\n+    if (TREE_TYPE (ctxp->current_parsed_class) == object_type_node\t\\\n+\t&& TREE_CODE (TYPE) == EXPR_WITH_FILE_LOCATION \t\t\t\\\n+\t&& EXPR_WFL_NODE (TYPE) == unqualified_object_id_node)\t\t\\\n+      (TYPE) = object_type_node;\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tif (unresolved_type_p (type, &returned_type))\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    if (returned_type)\t\t\t\t\t\t\\\n+\t      (TYPE) = returned_type;\t\t\t\t\t\\\n+\t    else\t\t\t\t\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\t(SAVE) = (TYPE);\t\t\t\t\t\\\n+\t\t(TYPE) = obtain_incomplete_type (TYPE);\t\t\t\\\n+\t\tCHAIN = 1;\t\t\t\t\t\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n   }\n \n /* Insert a DECL in the current block */\n@@ -489,15 +505,17 @@ static jdeplist *reverse_jdep_list ();\n   {\t\t\t\t\t\t\t\t\\\n     (WHERE) = build (CALL_EXPR, int_type_node,\t\t\t\\\n \t\t     build_address_of (soft_monitorenter_node),\t\\\n-\t\t     build_tree_list (NULL_TREE, (ARG)));\t\\\n+\t\t     build_tree_list (NULL_TREE, (ARG)), \t\\\n+\t\t     NULL_TREE);\t\t\t\t\\\n     TREE_SIDE_EFFECTS (WHERE) = 1;\t\t\t\t\\\n   }\n \n #define BUILD_MONITOR_EXIT(WHERE, ARG)\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\\\n     (WHERE) = build (CALL_EXPR, int_type_node,\t\t\t\\\n \t\t     build_address_of (soft_monitorexit_node),\t\\\n-\t\t     build_tree_list (NULL_TREE, (ARG)));\t\\\n+\t\t     build_tree_list (NULL_TREE, (ARG)),\t\\\n+\t\t     NULL_TREE);\t\t\t\t\\\n     TREE_SIDE_EFFECTS (WHERE) = 1;\t\t\t\t\\\n   }\n \n@@ -709,18 +727,18 @@ static tree try_reference_assignconv PROTO ((tree, tree));\n static tree build_unresolved_array_type PROTO ((tree));\n static tree build_array_from_name PROTO ((tree, tree, tree, tree *));\n static tree build_array_ref PROTO ((int, tree, tree));\n-static tree patch_array_ref PROTO ((tree, tree, tree));\n+static tree patch_array_ref PROTO ((tree));\n static tree make_qualified_name PROTO ((tree, tree, int));\n static tree merge_qualified_name PROTO ((tree, tree));\n static tree make_qualified_primary PROTO ((tree, tree, int));\n-static int resolve_qualified_expression_name PROTO ((tree, tree *, tree *, tree *));\n+static int resolve_qualified_expression_name PROTO ((tree, tree *, \n+\t\t\t\t\t\t     tree *, tree *));\n static void qualify_ambiguous_name PROTO ((tree));\n static void maybe_generate_clinit PROTO ((void));\n static tree resolve_field_access PROTO ((tree, tree *, tree *));\n static tree build_newarray_node PROTO ((tree, tree, int));\n static tree patch_newarray PROTO ((tree));\n static tree resolve_type_during_patch PROTO ((tree));\n-static int not_initialized_as_it_should_p PROTO ((tree));\n static tree build_this PROTO ((int));\n static tree build_return PROTO ((int, tree));\n static tree patch_return PROTO ((tree));\n@@ -791,6 +809,7 @@ tree java_method_add_stmt PROTO ((tree, tree));\n char *java_get_line_col PROTO ((char *, int, int));\n void java_expand_switch PROTO ((tree));\n tree java_get_catch_block PROTO ((tree, int));\n+int java_report_errors PROTO (());\n #endif /* JC1_LITE */\n \n /* Always in use, no matter what you compile */"}, {"sha": "6832228c6a7cd0835015ac239ee764dbdccd70ad", "filename": "gcc/java/parse.y", "status": "modified", "additions": 267, "deletions": 160, "changes": 427, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c877974e79791c251316548175df8749ed657df9/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c877974e79791c251316548175df8749ed657df9/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=c877974e79791c251316548175df8749ed657df9", "patch": "@@ -701,8 +701,8 @@ formal_parameter:\n \t\t{\n \t\t  $$ = build_tree_list ($2, $1);\n \t\t}\n-|\tmodifiers type variable_declarator_id /* Added, JDK1.1 final locals */\n-\t\t{ $$ = parse_jdk1_1_error (\"final local\"); }\n+|\tmodifiers type variable_declarator_id /* Added, JDK1.1 final parms */\n+\t\t{ $$ = parse_jdk1_1_error (\"final parameters\"); }\n |\ttype error\n \t\t{yyerror (\"Missing identifier\"); RECOVER;}\n |\tmodifiers type error\n@@ -722,9 +722,9 @@ throws:\n \n class_type_list:\n \tclass_type\n-\t\t{ $$ = build_tree_list (NULL_TREE, $1); }\n+\t\t{ $$ = build_tree_list ($1, $1); }\n |\tclass_type_list C_TK class_type\n-\t\t{ $$ = tree_cons (NULL_TREE, $3, $1); }\n+\t\t{ $$ = tree_cons ($3, $3, $1); }\n |\tclass_type_list C_TK error\n \t\t{yyerror (\"Missing class type term\"); RECOVER;}\n ;\n@@ -1507,11 +1507,11 @@ primary_no_new_array:\n \t   'type' into its components. Missing is something for array,\n \t   which will complete the reference_type part. FIXME */\n |\tname DOT_TK CLASS_TK\t       /* Added, JDK1.1 class literals */\n-\t\t{ $$ = parse_jdk1_1_error (\"class literals\"); }\n+\t\t{ $$ = parse_jdk1_1_error (\"named class literals\"); }\n |\tprimitive_type DOT_TK CLASS_TK /* Added, JDK1.1 class literals */\n-\t\t{ $$ = parse_jdk1_1_error (\"class literals\"); }\n+\t\t{ $$ = build_class_ref ($1); }\n |\tVOID_TK DOT_TK CLASS_TK\t       /* Added, JDK1.1 class literals */\n-\t\t{ $$ = parse_jdk1_1_error (\"class literals\"); }\n+\t\t{ $$ = build_class_ref (void_type_node); }\n         /* Added, JDK1.1 inner classes. Documentation is wrong\n            refering to a 'ClassName' (class_name) rule that doesn't\n            exist. Used name instead.  */\n@@ -2298,13 +2298,13 @@ parse_warning_context VPROTO ((tree cl, char *msg, ...))\n   msg = va_arg (ap, char *);\n #endif\n \n-  do_warning = 1;\n+  force_error = do_warning = 1;\n   issue_warning_error_from_context (cl, msg, ap);\n-  force_error = 0;\n+  do_warning = force_error = 0;\n   va_end (ap);\n }\n \n-void\n+int\n java_report_errors ()\n {\n   if (java_error_count)\n@@ -2315,6 +2315,7 @@ java_report_errors ()\n \t     java_warning_count, (java_warning_count == 1 ? \"\" : \"s\"));\n   if (java_error_count || java_warning_count)\n     putc ('\\n', stderr);\n+  return java_error_count;\n }\n \n static char *\n@@ -2365,8 +2366,8 @@ variable_redefinition_error (context, name, type, line)\n   char *type_name;\n \n   /* Figure a proper name for type. We might haven't resolved it */\n-  if (TREE_CODE (type) == TREE_LIST)\n-    type_name = IDENTIFIER_POINTER (TYPE_NAME (TREE_PURPOSE (type)));\n+  if (TREE_CODE (type) == POINTER_TYPE && !TREE_TYPE (type))\n+    type_name = IDENTIFIER_POINTER (TYPE_NAME (type));\n   else\n     type_name = lang_printable_name (type, 0);\n \n@@ -2629,10 +2630,10 @@ create_interface (flags, id, super)\n        - public/abstract allowed (already done at that point)\n        - abstract is obsolete (comes first, it's a warning, or should be)\n        - Can't use twice the same (checked in the modifier rule) */\n-  if (flags & ACC_ABSTRACT)\n+  if ((flags & ACC_ABSTRACT) && flag_redundant)\n     parse_warning_context \n       (MODIFIER_WFL (ABSTRACT_TK),\n-       \"Obsolete use of `abstract' modifier. Interface `%s' is implicitely \"\n+       \"Redundant use of `abstract' modifier. Interface `%s' is implicitely \"\n        \"abstract\", IDENTIFIER_POINTER (raw_name));\n   if (flags & ACC_PUBLIC && flags & ACC_ABSTRACT)\n     parse_error_context \n@@ -2751,7 +2752,9 @@ lookup_field_wrapper (class, name)\n      tree class, name;\n {\n   tree type = class;\n+  java_parser_context_save_global ();\n   return lookup_field (&type, name);\n+  java_parser_context_restore_global ();\n }\n \n /* Find duplicate field within the same class declarations and report\n@@ -2768,11 +2771,12 @@ duplicate_declaration_error_p (new_field_name, new_type, cl)\n   if (decl)\n     {\n       char *t1 = strdup (lang_printable_name (new_type, 1));\n-      char *t2 = \n-\tstrdup ((TREE_CODE (TREE_TYPE (decl)) == TREE_LIST ?\n-\t\t IDENTIFIER_POINTER (TYPE_NAME \n-\t\t\t\t     (TREE_PURPOSE (TREE_TYPE (decl)))) :\n-\t\t lang_printable_name (TREE_TYPE (decl), 1)));\n+      /* The type may not have been completed by the time we report\n+\t the error */\n+      char *t2 = strdup (((TREE_CODE (TREE_TYPE (decl)) == POINTER_TYPE \n+\t\t\t   && TREE_TYPE (TREE_TYPE (decl)) == NULL_TREE) ?\n+\t\t\t  IDENTIFIER_POINTER (TYPE_NAME (TREE_TYPE (decl))) :\n+\t\t\t  lang_printable_name (TREE_TYPE (decl), 1)));\n       parse_error_context \n \t(cl , \"Duplicate variable declaration: `%s %s' was `%s %s' (%s:%d)\", \n \t t1, IDENTIFIER_POINTER (new_field_name),\n@@ -2827,6 +2831,7 @@ register_fields (flags, type, variable_list)\n   for (current = variable_list, saved_type = type; current; \n        current = TREE_CHAIN (current), type = saved_type)\n     {\n+      tree real_type;\n       tree field_decl;\n       tree cl = TREE_PURPOSE (current);\n       tree init = TREE_VALUE (current);\n@@ -2835,10 +2840,6 @@ register_fields (flags, type, variable_list)\n       /* Process NAME, as it may specify extra dimension(s) for it */\n       type = build_array_from_name (type, wfl, current_name, &current_name);\n \n-      /* Check for redeclarations */\n-      if (duplicate_declaration_error_p (current_name, type, cl))\n-\tcontinue;\n-\n       /* Type adjustment. We may have just readjusted TYPE because\n \t the variable specified more dimensions. Make sure we have\n \t a reference if we can and don't have one already. Also\n@@ -2851,10 +2852,15 @@ register_fields (flags, type, variable_list)\n \t    EXPR_WFL_NODE (TREE_OPERAND (init, 0)) = current_name;\n \t}\n \n+      real_type = GET_REAL_TYPE (type);\n+      /* Check for redeclarations */\n+      if (duplicate_declaration_error_p (current_name, real_type, cl))\n+\tcontinue;\n+\n       /* Set lineno to the line the field was found and create a\n          declaration for it. Eventually sets the @deprecated tag flag. */\n       lineno = EXPR_WFL_LINENO (cl);\n-      field_decl = add_field (class_type, current_name, type, flags);\n+      field_decl = add_field (class_type, current_name, real_type, flags);\n       CHECK_DEPRECATED (field_decl);\n       \n       /* Check if we must chain. */\n@@ -2879,6 +2885,8 @@ register_fields (flags, type, variable_list)\n \t\t      permalloc (sizeof (struct lang_decl_var));\n \t\t  DECL_LOCAL_STATIC_VALUE (field_decl) = \n \t\t    TREE_OPERAND (init, 1);\n+\t\t  if (TREE_CONSTANT (TREE_OPERAND (init, 1)))\n+\t\t    DECL_INITIAL (field_decl) = TREE_OPERAND (init, 1);\n \t\t}\n \t      /* Otherwise, the field should be initialized in <clinit>. \n \t\t This field is remembered so we can generate <clinit> later */\n@@ -3073,9 +3081,11 @@ method_header (flags, type, mdecl, throws)\n \tTREE_TYPE (meth) = returned_type;\n       else \n \t{\n+\t  tree itype;\n \t  patch_stage = JDEP_METHOD_RETURN;\n-\t  TREE_TYPE (meth) = \n-\t    register_incomplete_type (patch_stage, type, id, NULL_TREE);\n+\t  itype = register_incomplete_type (patch_stage, type, id, NULL_TREE);\n+\t  TREE_TYPE (meth) = (TREE_CODE (itype) == TREE_LIST ? \n+\t\t\t      TREE_PURPOSE (itype) : itype);\n \t}\n     }\n   else\n@@ -3277,8 +3287,7 @@ check_abstract_method_header (meth)\n {\n   int flags = get_access_flags_from_decl (meth);\n   /* DECL_NAME might still be a WFL node */\n-  tree name = (TREE_CODE (DECL_NAME (meth)) == EXPR_WITH_FILE_LOCATION ?\n-\t       EXPR_WFL_NODE (DECL_NAME (meth)) : DECL_NAME (meth));\n+  tree name = GET_METHOD_NAME (meth);\n \n   OBSOLETE_MODIFIER_WARNING (MODIFIER_WFL (ABSTRACT_TK), flags,\n \t\t\t     ACC_ABSTRACT, \"abstract method `%s'\",\n@@ -3509,6 +3518,7 @@ obtain_incomplete_type (wfl)\n       tree core;\n       push_obstacks (&permanent_obstack, &permanent_obstack);\n       BUILD_PTR_FROM_NAME (core, name);\n+      layout_type (core);\n       ptr = build_tree_list (core, NULL_TREE);\n       pop_obstacks ();\n       TREE_CHAIN (ptr) = ctxp->incomplete_class;\n@@ -3590,10 +3600,6 @@ safe_layout_class (class)\n \n   push_obstacks (&permanent_obstack, &permanent_obstack);\n \n-  if (!CLASS_METHOD_CHECKED_P (class))\n-    CHECK_METHODS (TYPE_NAME (class));\n-  CLASS_METHOD_CHECKED_P (class) = 1;\n-\n   layout_class (class);\n   pop_obstacks ();\n \n@@ -3646,7 +3652,7 @@ java_complete_class ()\n   /* Rever things so we have the right order */\n   ctxp->class_list = nreverse (ctxp->class_list);\n   ctxp->classd_list = reverse_jdep_list (ctxp);\n-    \n+\n   for (cclassd = ctxp->classd_list, cclass = ctxp->class_list; \n        cclass && cclassd; \n        cclass = TREE_CHAIN (cclass), cclassd = CLASSD_CHAIN (cclassd))\n@@ -3655,7 +3661,6 @@ java_complete_class ()\n       for (dep = CLASSD_FIRST (cclassd); dep; dep = JDEP_CHAIN (dep))\n \t{\n \t  tree decl;\n-\n \t  if (!(decl = jdep_resolve_class (dep)))\n \t    continue;\n \n@@ -3751,21 +3756,10 @@ java_complete_class ()\n \t      break;\n \n \t    case JDEP_EXCEPTION:\n-\t      /* Check for righteous inheritance here */\n-\t      if (!inherits_from_p (TREE_TYPE (decl), throwable_type_node))\n-\t\t {\n-\t\t   parse_error_context \n-\t\t     (JDEP_WFL (dep), \"Class `%s' in `throws' clause must be \"\n-\t\t      \"a subclass of class `java.lang.Throwable'\",\n-\t\t      IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_WFL (dep))));\n-\t\t }\n-\t      else \n-\t\t{\n-\t\t  JDEP_APPLY_PATCH (dep, TREE_TYPE (decl));\n-\t\t  SOURCE_FRONTEND_DEBUG \n-\t\t    ((\"Completing `%s' `throws' argument node\",\n-\t\t      IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_WFL (dep)))));\n-\t\t}\n+\t      JDEP_APPLY_PATCH (dep, TREE_TYPE (decl));\n+\t      SOURCE_FRONTEND_DEBUG \n+\t\t((\"Completing `%s' `throws' argument node\",\n+\t\t  IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_WFL (dep)))));\n \t      break;\n \n \t    default:\n@@ -3890,11 +3884,23 @@ do_resolve_class (class_type, decl, cl)\n    parsed class). Return a decl node.  */\n \n static tree\n-resolve_and_layout (name, cl)\n-     tree name;\n+resolve_and_layout (something, cl)\n+     tree something;\n      tree cl;\n {\n-  tree decl = resolve_no_layout (name, cl);\n+  tree decl;\n+\n+  if (TREE_CODE (something) == POINTER_TYPE)\n+    something = TREE_TYPE (something);\n+\n+  if (JPRIMITIVE_TYPE_P (something) || something == void_type_node)\n+    return NULL_TREE;\n+\n+  if (TREE_CODE (something) != IDENTIFIER_NODE)\n+    something = (TREE_CODE (TYPE_NAME (something)) == TYPE_DECL ?\n+\t    DECL_NAME (TYPE_NAME (something)) : TYPE_NAME (something));\n+\n+  decl = resolve_no_layout (something, cl);\n   if (decl && TREE_TYPE (decl) != current_class \n       && !CLASS_LOADED_P (TREE_TYPE (decl)))\n     safe_layout_class (TREE_TYPE (decl));\n@@ -4034,16 +4040,30 @@ reset_method_name (method)\n     {\n       /* NAME is just the plain name when Object is being defined */\n       if (DECL_CONTEXT (method) != object_type_node)\n-\tDECL_NAME (method) = \n-\t  (DECL_CONSTRUCTOR_P (method) ? init_identifier_node :\n-\t   (TREE_CODE (DECL_NAME (method)) == EXPR_WITH_FILE_LOCATION ? \n-\t    EXPR_WFL_NODE (DECL_NAME (method)) : DECL_NAME (method)));\n+\tDECL_NAME (method) = (DECL_CONSTRUCTOR_P (method) ? \n+\t\t\t      init_identifier_node : GET_METHOD_NAME (method));\n       return 0;\n     }\n   else \n     return 1;\n }\n \n+/* Return the name of METHOD_DECL, when DECL_NAME is a WFL */\n+\n+tree\n+java_get_real_method_name (method_decl)\n+     tree method_decl;\n+{\n+  tree method_name = DECL_NAME (method_decl);\n+  if (DECL_CONSTRUCTOR_P (method_decl))\n+    return init_identifier_node;\n+  else if (ctxp \n+\t   && ctxp->current_parsed_class_un == EXPR_WFL_NODE (method_name))\n+    return init_identifier_node;\n+  else\n+    return EXPR_WFL_NODE (method_name);\n+}\n+\n /* Track method being redefined inside the same class. As a side\n    effect, set DECL_NAME to an IDENTIFIER (prior entering this\n    function it's a FWL, so we can track errors more accurately */\n@@ -4097,6 +4117,11 @@ java_check_regular_methods (class_decl)\n   tree class = CLASS_TO_HANDLE_TYPE (TREE_TYPE (class_decl));\n   tree super_class = CLASSTYPE_SUPER (class);\n   tree saved_found_wfl = NULL_TREE, found = NULL_TREE;\n+  tree mthrows;\n+\n+  /* It is not necessary to check methods defined in java.lang.Object */\n+  if (class == object_type_node)\n+    return;\n \n   TYPE_METHODS (class) = nreverse (TYPE_METHODS (class));\n \n@@ -4125,6 +4150,19 @@ java_check_regular_methods (class_decl)\n \t continue;\n        }\n \n+      /* We verify things thrown by the method. They must inherits from\n+\t java.lang.Throwable */\n+      for (mthrows = DECL_FUNCTION_THROWS (method);\n+\t   mthrows; mthrows = TREE_CHAIN (mthrows))\n+\t{\n+\t  if (!inherits_from_p (TREE_VALUE (mthrows), throwable_type_node))\n+\t    parse_error_context \n+\t      (TREE_PURPOSE (mthrows), \"Class `%s' in `throws' clause must be \"\n+\t       \"a subclass of class `java.lang.Throwable'\",\n+\t       IDENTIFIER_POINTER \n+\t         (DECL_NAME (TYPE_NAME (TREE_VALUE (mthrows)))));\n+\t}\n+\n       sig = build_java_argument_signature (TREE_TYPE (method));\n       found = lookup_argument_method (super_class, DECL_NAME (method), sig);\n \n@@ -4208,22 +4246,21 @@ java_check_regular_methods (class_decl)\n \t exceptions, if any */\n       check_throws_clauses (method, method_wfl, found);\n \n-#if 0\n       /* If the method has default access in an other package, then\n \t issue a warning that the current method doesn't override the\n \t one that was found elsewhere. Do not issue this warning when\n \t the match was found in java.lang.Object.  */\n       if (DECL_CONTEXT (found) != object_type_node \n \t  && (!aflags || (aflags > ACC_PROTECTED))\n-\t  && !class_in_current_package (DECL_CONTEXT (found)))\n+\t  && !class_in_current_package (DECL_CONTEXT (found))\n+\t  && flag_not_overriding)\n \tparse_warning_context \n \t  (method_wfl, \"Method `%s' in class `%s' does not \"\n \t   \"override the corresponding method in class `%s', which is \"\n \t   \"private to a different package\",\n \t   lang_printable_name (found, 0),\n \t   IDENTIFIER_POINTER (DECL_NAME (class_decl)),\n \t   IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n-#endif\n \n       /* Inheriting multiple methods with the same signature. FIXME */\n     }\n@@ -4263,11 +4300,15 @@ check_throws_clauses (method, method_wfl, found)\n {\n   tree mthrows, fthrows;\n \n+  /* Can't check these things with class loaded from bytecode. FIXME */\n+  if (!CLASS_FROM_SOURCE_P (DECL_CONTEXT (found)))\n+    return;\n+\n   for (mthrows = DECL_FUNCTION_THROWS (method);\n        mthrows; mthrows = TREE_CHAIN (mthrows))\n     {\n       /* We don't verify unchecked expressions */\n-      if (IS_UNCHECKED_EXPRESSION_P (TREE_VALUE (mthrows)))\n+      if (IS_UNCHECKED_EXCEPTION_P (TREE_VALUE (mthrows)))\n \tcontinue;\n       /* Checked expression must be compatible */\n       for (fthrows = DECL_FUNCTION_THROWS (found); \n@@ -4376,10 +4417,7 @@ java_check_methods ()\n   tree current;\n   for (current = ctxp->gclass_list; current; current = TREE_CHAIN (current))\n     if (CLASS_FROM_SOURCE_P (TREE_TYPE (TREE_VALUE (current))))\n-      {\n-\tCHECK_METHODS (TREE_VALUE (current));\n-\tCLASS_METHOD_CHECKED_P (TREE_TYPE (TREE_VALUE (current))) = 1;\n-      }\n+      CHECK_METHODS (TREE_VALUE (current));\n }\n \n /* Lookup methods in interfaces using their name and partial\n@@ -4850,12 +4888,20 @@ declare_local_variables (modifier, type, vlist)\n     {\n       int i;\n       for (i = 0; i <= 10; i++) if (1 << i & modifier) break;\n-      parse_error_context \n-\t(ctxp->modifier_ctx [i],\n-\t (modifier == ACC_FINAL ?\n-\t  \"Unsupported JDK1.1 `final' locals\" :\n-\t  \"Only `final' is allowed as a local variables modifier\"));\n-      return;\n+      if (modifier == ACC_FINAL)\n+\t{\n+\t  if (flag_static_local_jdk1_1)\n+\t    parse_warning_context (ctxp->modifier_ctx [i], \n+\t\t\t\t   \"Unsupported JDK1.1 `final' local variable \"\n+\t\t\t\t   \"(treated as non final)\");\n+\t}\n+      else \n+\t{\n+\t  parse_error_context \n+\t    (ctxp->modifier_ctx [i], \n+\t     \"Only `final' is allowed as a local variables modifier\");\n+\t  return;\n+\t}\n     }\n \n   /* Obtain an incomplete type if TYPE is not complete. TYPE_WFL will\n@@ -4871,7 +4917,7 @@ declare_local_variables (modifier, type, vlist)\n   for (current = vlist, saved_type = type; current;\n        current = TREE_CHAIN (current), type = saved_type)\n     {\n-      tree other;\n+      tree other, real_type;\n       tree wfl  = TREE_PURPOSE (current);\n       tree name = EXPR_WFL_NODE (wfl);\n       tree init = TREE_VALUE (current);\n@@ -4893,10 +4939,11 @@ declare_local_variables (modifier, type, vlist)\n       if (type != saved_type && !must_chain \n \t  && (TREE_CODE (type) == RECORD_TYPE))\n \ttype = promote_type (type);\n-      \n+\n+      real_type = GET_REAL_TYPE (type);\n       /* Never layout this decl. This will be done when its scope\n \t will be entered */\n-      decl = build_decl_no_layout (VAR_DECL, name, type);\n+      decl = build_decl (VAR_DECL, name, real_type);\n       BLOCK_CHAIN_DECL (decl);\n       \n       /* Don't try to use an INIT statement when an error was found */\n@@ -4952,8 +4999,8 @@ source_start_java_method (fndecl)\n       if (INCOMPLETE_TYPE_P (type))\n \t{\n \t  jdep *jdep;\n-\t  parm_decl = build_decl_no_layout (PARM_DECL, name, type);\n-\t  \n+\t  tree real_type = GET_REAL_TYPE (type);\n+\t  parm_decl = build_decl (PARM_DECL, name, real_type);\n \t  register_incomplete_type (JDEP_PARM, NULL_TREE, NULL_TREE, type);\n \t  jdep = CLASSD_LAST (ctxp->classd_list);\n \t  JDEP_MISC (jdep) = name;\n@@ -5148,17 +5195,39 @@ java_layout_classes ()\n     {\n       current_class = TREE_TYPE (TREE_VALUE (current));\n \n-      /* Reverse the fields if it's necessary (they've already\n-         reversed if the dummy field has been inserted at the\n-         beginning of the list */\n-      if (TYPE_FIELDS (current_class)\n-\t  && !DECL_IGNORED_P (TYPE_FIELDS (current_class)))\n-\tTYPE_FIELDS (current_class) = nreverse (TYPE_FIELDS (current_class));\n+      /* Reverse the fields, but leave the dummy field in front.\n+\t Fields are already ordered for Object and Class */\n+      if (TYPE_FIELDS (current_class) && current_class != object_type_node\n+\t  && current_class != class_type_node)\n+      {\n+\t/* Always leave the dummy field in front if its already there,\n+\t   and layout the class for proper field offets. */\n+\tif (!DECL_NAME (TYPE_FIELDS (current_class)))\n+\t  {\n+\t    tree fields = TYPE_FIELDS (current_class);\n+\t    TREE_CHAIN (fields) = nreverse (TREE_CHAIN (fields));\n+\t    TYPE_SIZE (current_class) = NULL_TREE;\n+\t    layout_type (current_class);\n+\t  }\n+\t/* It's time to layout the class */\n+\telse\n+\t  {\n+\t    TYPE_FIELDS (current_class) = \n+\t      nreverse (TYPE_FIELDS (current_class));\n+\t    TYPE_SIZE (current_class) = NULL_TREE;\n+\t    layout_class (current_class);\n+\t  }\n+      }\n       \n       /* Do a layout if necessary */\n-      if (!TYPE_SIZE (current_class) || (current_class == object_type_node))\n+      if (!TYPE_SIZE (current_class) \n+\t  || (current_class == object_type_node)\n+\t  || current_class == class_type_node)\n \tsafe_layout_class (current_class);\n \n+      /* From now on, the class is considered completely loaded */\n+      CLASS_LOADED_P (current_class) = 1;\n+\n       /* Error reported by the caller */\n       if (java_error_count)\n \treturn;\n@@ -5694,15 +5763,15 @@ resolve_field_access (qual_wfl, field_decl, field_type)\n \t\t\t\t     type_found, DECL_NAME (decl));\n       if (field_ref == error_mark_node)\n \treturn error_mark_node;\n-      if (is_static && !static_final_found\n-\t  && ! flag_emit_class_files)\n+      if (is_static && !static_final_found && !flag_emit_class_files)\n \t{\n \t  field_ref = build_class_init (type_found, field_ref);\n \t  /* If the static field was identified by an expression that\n \t     needs to be generated, make the field access a compound\n \t     expression whose first part of the evaluation of the\n \t     field selector part. */\n-\t  if (where_found && TREE_CODE (where_found) != TYPE_DECL)\n+\t  if (where_found && TREE_CODE (where_found) != TYPE_DECL \n+\t      && TREE_CODE (where_found) != RECORD_TYPE)\n \t    {\n \t      tree type = QUAL_DECL_TYPE (field_ref);\n \t      field_ref = build (COMPOUND_EXPR, type, where_found, field_ref);\n@@ -5715,7 +5784,8 @@ resolve_field_access (qual_wfl, field_decl, field_type)\n   if (field_decl)\n     *field_decl = decl;\n   if (field_type)\n-    *field_type = QUAL_DECL_TYPE (decl);\n+    *field_type = (QUAL_DECL_TYPE (decl) ? \n+\t\t   QUAL_DECL_TYPE (decl) : TREE_TYPE (decl));\n   return field_ref;\n }\n \n@@ -5731,7 +5801,7 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n   int previous_call_static = 0;\n   int is_static;\n   tree decl = NULL_TREE, type = NULL_TREE, q;\n-  *where_found = NULL_TREE;\n+  *type_found = *where_found = NULL_TREE;\n \n   for (q = EXPR_WFL_QUALIFICATION (wfl); q; q = TREE_CHAIN (q))\n     {\n@@ -5922,10 +5992,16 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t  if (!from_super && QUAL_RESOLUTION (q))\n \t    {\n \t      decl = QUAL_RESOLUTION (q);\n-\t      if (!type && !FIELD_STATIC (decl))\n+\t      if (!type)\n \t\t{\n-\t\t  *where_found = current_this;\n-\t\t  *type_found = type;\n+\t\t  if (!FIELD_STATIC (decl))\n+\t\t    *where_found = current_this;\n+\t\t  else\n+\t\t    {\n+\t\t      *where_found = TREE_TYPE (decl);\n+\t\t      if (TREE_CODE (*where_found) == POINTER_TYPE)\n+\t\t\t*where_found = TREE_TYPE (*where_found);\n+\t\t    }\n \t\t}\n \t    }\n \n@@ -5961,15 +6037,19 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t\t}\n \n \t      /* Layout the type of field_decl, since we may need\n-                 it. Don't do primitive types or loaded classes */\n+                 it. Don't do primitive types or loaded classes. The\n+                 situation of non primitive arrays may not handled\n+                 properly here. FIXME */\n \t      if (TREE_CODE (TREE_TYPE (field_decl)) == POINTER_TYPE)\n \t\tfield_decl_type = TREE_TYPE (TREE_TYPE (field_decl));\n \t      else\n \t\tfield_decl_type = TREE_TYPE (field_decl);\n \t      if (!JPRIMITIVE_TYPE_P (field_decl_type) \n-\t\t  && !CLASS_LOADED_P (field_decl_type))\n-\t\tresolve_and_layout (DECL_NAME (TYPE_NAME (field_decl_type)),\n-\t\t\t\t    NULL_TREE);\n+\t\t  && !CLASS_LOADED_P (field_decl_type)\n+\t\t  && !TYPE_ARRAY_P (field_decl_type))\n+\t\tresolve_and_layout (field_decl_type, NULL_TREE);\n+\t      if (TYPE_ARRAY_P (field_decl_type))\n+\t\tCLASS_LOADED_P (field_decl_type) = 1;\n \t      \n \t      /* Check on accessibility here */\n \t      if (not_accessible_p (type, field_decl, from_super))\n@@ -6065,8 +6145,7 @@ int not_accessible_p (reference, member, from_super)\n     }\n \n   /* Check access on private members. Access is granted only if it\n-     occurs from within the class in witch it is declared*/\n-\n+     occurs from within the class in witch it is declared */\n   if (access_flag & ACC_PRIVATE)\n     return (current_class == DECL_CONTEXT (member) ? 0 : 1);\n \n@@ -6265,9 +6344,9 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl, super)\n \t  \n \t  /* 2- Do the layout of the class where the last field\n \t     was found, so we can search it. */\n-\t  class_decl = \n-\t    resolve_and_layout (DECL_NAME (TYPE_NAME (type)), NULL_TREE);\n-\t  \n+\t  class_decl = resolve_and_layout (type, NULL_TREE);\n+\t  type = TREE_TYPE (class_decl);\n+\n \t  /* 3- Retrieve a filtered list of method matches, Refine\n \t     if necessary. In any cases, point out errors.  */\n \t  list = lookup_method_invoke (0, identifier_wfl, type, \n@@ -6349,6 +6428,7 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl, super)\n       /* NAME is a simple identifier or comes from a primary. Search\n \t in the class whose declaration contain the method being\n \t invoked. */\n+      resolve_and_layout (class_to_search, NULL_TREE);\n       list = lookup_method_invoke (lc, wfl, class_to_search, name, args);\n \n       /* Don't continue if no method were found, as the next statement\n@@ -6563,20 +6643,26 @@ lookup_method_invoke (lc, cl, class, name, arg_list)\n      tree cl;\n      tree class, name, arg_list;\n {\n-  tree method = make_node (FUNCTION_TYPE);\n   tree atl = NULL_TREE;\t\t/* Arg Type List */\n-  tree signature, list, node;\n+  tree method, signature, list, node;\n   char *candidates;\t\t/* Used for error report */\n \n   /* Fix the arguments */\n   for (node = arg_list; node; node = TREE_CHAIN (node))\n     {\n-      tree current_arg = TREE_TYPE (TREE_VALUE (node));\n+      tree current_arg = TREE_VALUE (node);\n+      /* Integer constant 0 passed as itself, not as a type */\n+      if (current_arg != integer_zero_node)\n+\tcurrent_arg = TREE_TYPE (TREE_VALUE (node));\n+      /* Non primitive type may have to be resolved */\n+      if (current_arg != integer_zero_node \n+\t  && !JPRIMITIVE_TYPE_P (current_arg))\n+\tresolve_and_layout (current_arg, NULL_TREE);\n+      /* And promoted */\n       if (TREE_CODE (current_arg) == RECORD_TYPE)\n-\tcurrent_arg = promote_type (current_arg);\n+        current_arg = promote_type (current_arg);\n       atl = tree_cons (NULL_TREE, current_arg, atl);\n     }\n-  TYPE_ARG_TYPES (method) = atl;\n \n   /* Find all candidates and then refine the list, searching for the\n      most specific method. */\n@@ -6610,6 +6696,11 @@ lookup_method_invoke (lc, cl, class, name, arg_list)\n       candidates = obstack_finish (&temporary_obstack);\n     }\n   /* Issue the error message */\n+  for (node = atl; node; node = TREE_CHAIN (node))\n+    if (TREE_VALUE (node) == integer_zero_node)\n+      TREE_VALUE (node) = long_type_node;\n+  method = make_node (FUNCTION_TYPE);\n+  TYPE_ARG_TYPES (method) = atl;\n   signature = build_java_argument_signature (method);\n   parse_error_context (cl, \"Can't find %s `%s(%s)' in class `%s'%s\",\n \t\t       (lc ? \"constructor\" : \"method\"),\n@@ -6641,13 +6732,14 @@ find_applicable_accessible_methods_list (lc, class, name, arglist)\n \t  if (lc && !DECL_CONSTRUCTOR_P (method))\n \t    continue;\n \t  else if (!lc && (DECL_CONSTRUCTOR_P (method)\n-\t\t\t   || DECL_NAME (method) != name))\n+\t\t\t   || (GET_METHOD_NAME (method) != name)))\n \t    continue;\n \t  \n \t  if (argument_types_convertible (method, arglist))\n \t    {\n \t      /* Retain accessible methods only */\n-\t      if (!not_accessible_p (DECL_CONTEXT (current_function_decl), method, 0))\n+\t      if (!not_accessible_p (DECL_CONTEXT (current_function_decl), \n+\t\t\t\t     method, 0))\n \t\tlist = tree_cons (NULL_TREE, method, list);\n \t      else\n \t      /* Also retain all selected method here */\n@@ -6754,6 +6846,7 @@ argument_types_convertible (m1, m2_or_arglist)\n \n   while (m1_arg && m2_arg)\n     {\n+      resolve_and_layout (TREE_VALUE (m1_arg), NULL_TREE);\n       if (!valid_method_invocation_conversion_p (TREE_VALUE (m1_arg),\n \t\t\t\t\t\t TREE_VALUE (m2_arg)))\n \tbreak;\n@@ -6988,7 +7081,8 @@ java_complete_tree (node)\n \t  int error_seen = 0;\n \t  if (TREE_CODE (stmt) == COMPOUND_EXPR)\n \t    {\n-\t      /* Re-order from (((A; B); C); ...; Z) to (A; (B; (C ; (...; Z)))).\n+\t      /* Re-order from (((A; B); C); ...; Z) to \n+\t\t (A; (B; (C ; (...; Z)))).\n \t\t This makes it easier to scan the statements left-to-right\n \t\t without using recursion (which might overflow the stack\n \t\t if the block has many statements. */\n@@ -7004,7 +7098,8 @@ java_complete_tree (node)\n \t      BLOCK_EXPR_BODY (node) = stmt;\n \t    }\n \n-\t  /* Now do the actual complete, without deep recursion for long blocks. */\n+\t  /* Now do the actual complete, without deep recursion for\n+             long blocks. */\n \t  ptr = &BLOCK_EXPR_BODY (node);\n \t  while (TREE_CODE (*ptr) == COMPOUND_EXPR)\n \t    {\n@@ -7029,7 +7124,8 @@ java_complete_tree (node)\n \t\t      && TREE_CODE (wfl_op2) != DEFAULT_EXPR)\n \t\t    {\n \t\t      SET_WFL_OPERATOR (wfl_operator, *ptr, wfl_op2);\n-\t\t      parse_error_context (wfl_operator, \"Unreachable statement\");\n+\t\t      parse_error_context (wfl_operator, \n+\t\t\t\t\t   \"Unreachable statement\");\n \t\t    }\n \t\t}\n \t      ptr = next;\n@@ -7097,7 +7193,8 @@ java_complete_tree (node)\n       nn = ctxp->current_loop;\n \n       /* It must be assignable to the type of the switch expression. */\n-      if (!try_builtin_assignconv (NULL_TREE, TREE_TYPE (TREE_OPERAND (nn, 0)), cn))\n+      if (!try_builtin_assignconv (NULL_TREE, \n+\t\t\t\t   TREE_TYPE (TREE_OPERAND (nn, 0)), cn))\n \t{\n \t  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);\n \t  parse_error_context \n@@ -7276,18 +7373,17 @@ java_complete_tree (node)\n \t  tree decl, wfl = TREE_OPERAND (node, 0);\n \t  int in_this = CALL_THIS_CONSTRUCTOR_P (node);\n \n-\t  node = patch_method_invocation (node, NULL_TREE,\n+\t  node = patch_method_invocation (node, NULL_TREE, \n \t\t\t\t\t  NULL_TREE, 0, &decl, 0);\n-\t  if (node != error_mark_node)\n-\t    {\n-\t      check_thrown_exceptions (EXPR_WFL_LINECOL (node), decl);\n-\t      /* If we call this(...), register signature and positions */\n-\t      if (in_this)\n-\t\tDECL_CONSTRUCTOR_CALLS (current_function_decl) = \n-\t\t  tree_cons (wfl, decl,\n-\t\t\t     DECL_CONSTRUCTOR_CALLS (current_function_decl));\n-\t\t\n-\t    }\n+\t  if (node == error_mark_node)\n+\t    return error_mark_node;\n+\n+\t  check_thrown_exceptions (EXPR_WFL_LINECOL (node), decl);\n+\t  /* If we call this(...), register signature and positions */\n+\t  if (in_this)\n+\t    DECL_CONSTRUCTOR_CALLS (current_function_decl) = \n+\t      tree_cons (wfl, decl, \n+\t\t\t DECL_CONSTRUCTOR_CALLS (current_function_decl));\n \t  return node;\n \t}\n \n@@ -7317,6 +7413,13 @@ java_complete_tree (node)\n       nn = java_complete_tree (TREE_OPERAND (node, 1));\n       if (nn == error_mark_node)\n \t{\n+\t  /* It's hopeless, but we can further things on to discover\n+\t     an error during the assignment. In any cases, the\n+\t     assignment operation fails. */\n+\t  if (TREE_CODE (TREE_OPERAND (node, 1)) != EXPR_WITH_FILE_LOCATION\n+\t      && TREE_TYPE (TREE_OPERAND (node, 1)) != error_mark_node)\n+\t    patch_assignment (node, wfl_op1, wfl_op2);\n+\n \t  /* Now, we still mark the lhs as initialized */\n \t  if (DECL_P (TREE_OPERAND (node, 0)))\n \t    INITIALIZED_P (TREE_OPERAND (node, 0)) = 1;\n@@ -7413,7 +7516,7 @@ java_complete_tree (node)\n \treturn error_mark_node;\n       if (!flag_emit_class_files)\n \tTREE_OPERAND (node, 1) = save_expr (TREE_OPERAND (node, 1));\n-      return patch_array_ref (node, wfl_op1, wfl_op2);\n+      return patch_array_ref (node);\n \n #if 0 \n     COMPONENT_REF:\n@@ -7873,18 +7976,9 @@ patch_assignment (node, wfl_op1, wfl_op2)\n   /* Inline read access to java.lang.PRIMTYPE.TYPE */\n   rhs = maybe_build_primttype_type_ref (rhs, wfl_op2);\n \n-  if (TREE_CODE (rhs) == COMPOUND_EXPR)\n-    {\n-      tree n = TREE_OPERAND (rhs, 1);\n-      if (TREE_CODE (n) == VAR_DECL \n-\t  && DECL_NAME (n) == TYPE_identifier_node\n-\t  && rhs_type == class_ptr_type)\n-\t{\n-\t  char *self_name = IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl_op2));\n-\t  if (!strncmp (self_name, \"java.lang.\", 10))\n-\t    rhs = build_primtype_type_ref (self_name);\n-\t}\n-    }\n+  /* Inline read access to java.lang.PRIMTYPE.TYPE */\n+  if (new_rhs)\n+    new_rhs = maybe_build_primttype_type_ref (new_rhs, wfl_op2);\n \n   if (error_found)\n     return error_mark_node;\n@@ -7987,6 +8081,11 @@ valid_builtin_assignconv_identity_widening_p (lhs_type, rhs_type)\n   if (lhs_type == rhs_type)\n     return 1;\n \n+  /* Sometimes, instead of passing a type, we pass integer_zero_node\n+     so we know that an integral type can accomodate it */\n+  if (JINTEGRAL_TYPE_P (lhs_type) && (rhs_type == integer_zero_node))\n+    return 1;\n+\n   all_primitive = \n     JPRIMITIVE_TYPE_P (lhs_type) && JPRIMITIVE_TYPE_P (rhs_type);\n \n@@ -8167,7 +8266,7 @@ static int\n valid_method_invocation_conversion_p (dest, source)\n      tree dest, source;\n {\n-  return ((JPRIMITIVE_TYPE_P (source) \n+  return (((JPRIMITIVE_TYPE_P (source) || (source == integer_zero_node))\n \t    && JPRIMITIVE_TYPE_P (dest)\n \t    && valid_builtin_assignconv_identity_widening_p (dest, source))\n \t   || ((JREFERENCE_TYPE_P (source) || JNULLP_TYPE_P (source))\n@@ -8268,14 +8367,6 @@ patch_binop (node, wfl_op1, wfl_op2)\n      after checking for the initialization of the RHS */\n   int error_found = 0;\n \n-  /* Figure what is going to be checked first for initialization prior\n-     its use. If NODE is part of a compound assignment, we check the\n-     second operand first, otherwise the first one first. We also\n-     initialize the matching WFL for the error report. `cfi' stands\n-     for Check For Initialization */\n-  tree cfi = (COMPOUND_ASSIGN_P (node) ? op2 : op1);\n-  tree cfi_wfl = (COMPOUND_ASSIGN_P (node) ? wfl_op2 : wfl_op1);\n-\n   EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);\n \n   switch (code)\n@@ -8730,8 +8821,15 @@ patch_string (node)\n     return patch_string_cst (node);\n   else if (IS_CRAFTED_STRING_BUFFER_P (node))\n     {\n+      int saved = ctxp->explicit_constructor_p;\n       tree invoke = build_method_invocation (wfl_to_string, NULL_TREE);\n-      return java_complete_tree (make_qualified_primary (node, invoke, 0));\n+      tree ret;\n+      /* Temporary disable forbid the use of `this'. */\n+      ctxp->explicit_constructor_p = 0;\n+      ret = java_complete_tree (make_qualified_primary (node, invoke, 0));\n+      /* Restore it at its previous value */\n+      ctxp->explicit_constructor_p = saved;\n+      return ret;\n     }\n   return NULL_TREE;\n }\n@@ -8929,6 +9027,8 @@ patch_unaryop (node, wfl_op)\n       if (TREE_CODE (op_type) != BOOLEAN_TYPE)\n \t{\n \t  ERROR_CANT_CONVERT_TO_BOOLEAN (wfl_operator, node, op_type);\n+\t  /* But the type is known. We will report an error if further\n+\t     attempt of a assignment is made with this rhs */\n \t  TREE_TYPE (node) = boolean_type_node;\n \t  error_found = 1;\n \t}\n@@ -8940,8 +9040,15 @@ patch_unaryop (node, wfl_op)\n     case CONVERT_EXPR:\n       value = patch_cast (node, wfl_operator);\n       if (value == error_mark_node)\n-\treturn value;\n-      node = value;\n+\t{\n+\t  /* If this cast is part of an assignment, we tell the code\n+\t     that deals with it not to complain about a mismatch,\n+\t     because things have been cast, anyways */\n+\t  TREE_TYPE (node) = error_mark_node;\n+\t  error_found = 1;\n+\t}\n+      else\n+\tnode = value;\n       break;\n     }\n   \n@@ -9081,8 +9188,8 @@ build_array_ref (location, array, index)\n /* 15.12 Array Access Expression */\n \n static tree\n-patch_array_ref (node, wfl_array, wfl_index)\n-     tree node, wfl_array, wfl_index;\n+patch_array_ref (node)\n+     tree node;\n {\n   tree array = TREE_OPERAND (node, 0);\n   tree array_type  = TREE_TYPE (array);\n@@ -9793,7 +9900,7 @@ static tree\n patch_switch_statement (node)\n      tree node;\n {\n-  tree se = TREE_OPERAND (node, 0), se_type, sb;\n+  tree se = TREE_OPERAND (node, 0), se_type;\n \n   /* Complete the switch expression */\n   se = TREE_OPERAND (node, 0) = java_complete_tree (se);\n@@ -9822,7 +9929,8 @@ patch_switch_statement (node)\n   TREE_TYPE (node) = void_type_node;\n   TREE_SIDE_EFFECTS (node) = 1;\n   CAN_COMPLETE_NORMALLY (node)\n-    = CAN_COMPLETE_NORMALLY (TREE_OPERAND (node, 1)) ||\t! SWITCH_HAS_DEFAULT (node);\n+    = CAN_COMPLETE_NORMALLY (TREE_OPERAND (node, 1)) \n+      || ! SWITCH_HAS_DEFAULT (node);\n   return node;\n }\n \n@@ -9870,8 +9978,7 @@ build_try_statement (location, try_block, catches, finally)\n \t sequence. It hold a local variable used to return from the\n \t finally using a computed goto. We call it\n \t return_from_finally (RFF). */\n-      rff = build_decl_no_layout (VAR_DECL, generate_name (),\n-\t\t\t\t   return_address_type_node);\n+      rff = build_decl (VAR_DECL, generate_name (), return_address_type_node);\n \n       /* Modification of the try block. */\n       try_block = build_jump_to_finally (try_block, rff, \n@@ -9906,8 +10013,7 @@ build_try_statement (location, try_block, catches, finally)\n \t\t CALL_EXPR\n \t\t   Jv_ReThrow\n \t\t   exception_parameter */\n-\t  catch_decl = build_decl_no_layout (VAR_DECL, generate_name (),\n-\t\t\t\t\t     ptr_type_node);\n+\t  catch_decl = build_decl (VAR_DECL, generate_name (), ptr_type_node);\n \t  BUILD_ASSIGN_EXCEPTION_INFO (stmt, catch_decl);\n \t  catch_block = build_expr_block (stmt, NULL_TREE);\n \t  catch_block = build_jump_to_finally (catch_block, rff, \n@@ -10039,7 +10145,6 @@ patch_try_statement (node)\n \t      break;\n \t    }\n \t}\n-\n       /* Complete the catch clause block */\n       catch_block = java_complete_tree (TREE_OPERAND (current, 0));\n       if (catch_block == error_mark_node)\n@@ -10058,7 +10163,6 @@ patch_try_statement (node)\n \n       /* Link this type to the caught type list */\n       caught_type_list = tree_cons (NULL_TREE, carg_type, caught_type_list);\n-\n     }\n \n   PUSH_EXCEPTIONS (caught_type_list);\n@@ -10136,7 +10240,7 @@ patch_synchronized_statement (node, wfl_op1)\n   try_block = build_expr_block (compound, NULL_TREE);\n \n   /* CATCH_ALL block */\n-  decl = build_decl_no_layout (VAR_DECL, generate_name (), ptr_type_node);\n+  decl = build_decl (VAR_DECL, generate_name (), ptr_type_node);\n   BUILD_ASSIGN_EXCEPTION_INFO (stmt, decl);\n   compound = add_stmt_to_compound (NULL_TREE, void_type_node, stmt);\n   BUILD_MONITOR_EXIT (stmt, expr);\n@@ -10178,7 +10282,7 @@ patch_throw_statement (node, wfl_op1)\n \n   /* The type of the throw expression is a not checked exception,\n      i.e. is a unchecked expression. */\n-  unchecked_ok = IS_UNCHECKED_EXPRESSION_P (TREE_TYPE (type));\n+  unchecked_ok = IS_UNCHECKED_EXCEPTION_P (TREE_TYPE (type));\n \n   /* Throw is contained in a try statement and at least one catch\n      clause can receive the thrown expression or the current method is\n@@ -10251,7 +10355,7 @@ check_thrown_exceptions (location, decl)\n       }\n }\n \n-/* Return 1 if EXCEPTION is caught at the current nesting level of\n+/* Return 1 if checked EXCEPTION is caught at the current nesting level of\n    try-catch blocks, OR is listed in the `throws' clause of the\n    current method.  */\n \n@@ -10260,8 +10364,11 @@ check_thrown_exceptions_do (exception)\n      tree exception;\n {\n   tree list = currently_caught_type_list;\n+  resolve_and_layout (exception, NULL_TREE);\n   /* First, all the nested try-catch-finally at that stage. The\n      last element contains `throws' clause exceptions, if any. */\n+  if (IS_UNCHECKED_EXCEPTION_P (exception))\n+    return 1;\n   while (list)\n     {\n       tree caught;\n@@ -10283,7 +10390,7 @@ purge_unchecked_exceptions (mdecl)\n   while (throws)\n     {\n       tree next = TREE_CHAIN (throws);\n-      if (!IS_UNCHECKED_EXPRESSION_P (TREE_VALUE (throws)))\n+      if (!IS_UNCHECKED_EXCEPTION_P (TREE_VALUE (throws)))\n \t{\n \t  TREE_CHAIN (throws) = new;\n \t  new = throws;"}]}