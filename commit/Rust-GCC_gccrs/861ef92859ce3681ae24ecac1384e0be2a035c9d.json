{"sha": "861ef92859ce3681ae24ecac1384e0be2a035c9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODYxZWY5Mjg1OWNlMzY4MWFlMjRlY2FjMTM4NGUwYmUyYTAzNWM5ZA==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@waitaki.otago.ac.nz", "date": "2001-12-15T08:31:49Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2001-12-15T08:31:49Z"}, "message": "java-tree.h (otable_methods, [...]): New field/global tree definitions.\n\ngcc/java:\n\n\t* java-tree.h (otable_methods, otable_decl, otable_syms_decl,\n\totable_type, otable_ptr_type, method_symbol_type,\n\tmethod_symbols_array_type, method_symbols_array_ptr_type): New\n\tfield/global tree definitions.\n\t(flag_indirect_dispatch): New flag.\n\t* decl.c (java_init_decl_processing): Initialize new otable and\n\totable_syms type nodes and decls. Add new field \"index\" to\n\tmethod_type_node.\n\t* class.c (build_method_symbols_entry): New function.\n\t(make_method_value): Set \"index\" to to method's vtable index for\n\tvirtual methods when indirect-dispatch is not used.\n\t(make_class_data): For indirect-dispatch, dont emit the dtable_decl,\n\tand set vtable_method_count to -1. Set otable and otable_syms field\n\tif indirect-dispatch is used and there was something to put in them.\n\t(build_method_symbols_entry): New function.\n\t(emit_offset_symbol_table): New function.\n\t* expr.c (get_offset_table_index): New function.\n\t(build_invokevirtual): Build array reference to otable at the index\n\treturned by get_offset_table_index, and use the result as the vtable\n\toffset.\n\t(build_invokeinterface): Similar.\n\t* jcf-parse.c (yyparse): If indirect-dispatch, call\n\temit_offset_symbol_table at the end of compilation, after all classes\n\thave been generated.\n\t* jvspec.c: Don't pass findirect-dispatch to jvgenmain.\n\t* lang.c (flag_indirect_dispatch): Define.\n\t(lang_f_options): Add indirect-dispatch flag.\n\nlibjava:\n\n\t* include/jvm.h (_Jv_VTable::idx_to_offset): New method.\n\t* java/lang/natClassLoader.cc (_Jv_PrepareCompiledClass): Call\n\t_Jv_MakeVTable and _Jv_LinkOffsetTable if needed.\n\t* java/lang/Class.h (_Jv_Method): Add \"index\" field.\n\t(_Jv_MethodSymbol): New struct type.\n\t(_Jv_LinkOffsetTable, _Jv_LayoutVTableMethods, _Jv_SetVTableEntries,\n\t_Jv_MakeVTable): Friends.\n\t(otable, otable_syms): New Class fields.\n\t* java/lang/natClass.cc (_Jv_LinkOffsetTable): New function.\n\t(isVirtualMethod): New static function.\n\t(_Jv_LayoutVTableMethods): New function.\n\t(_Jv_SetVTableEntries): New function.\n\t(_Jv_MakeVTable): New function.\n\nFrom-SVN: r48038", "tree": {"sha": "a15d17366ad109cb78a0bc4f4aaf8e142550387d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a15d17366ad109cb78a0bc4f4aaf8e142550387d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/861ef92859ce3681ae24ecac1384e0be2a035c9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/861ef92859ce3681ae24ecac1384e0be2a035c9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/861ef92859ce3681ae24ecac1384e0be2a035c9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/861ef92859ce3681ae24ecac1384e0be2a035c9d/comments", "author": null, "committer": null, "parents": [{"sha": "ed86a83d510ad44be77328cf80b1e6198f992c7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed86a83d510ad44be77328cf80b1e6198f992c7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed86a83d510ad44be77328cf80b1e6198f992c7c"}], "stats": {"total": 579, "additions": 550, "deletions": 29}, "files": [{"sha": "46e3e57db6c7d732285c528e5381b92825cbfcd3", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861ef92859ce3681ae24ecac1384e0be2a035c9d/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861ef92859ce3681ae24ecac1384e0be2a035c9d/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=861ef92859ce3681ae24ecac1384e0be2a035c9d", "patch": "@@ -1,3 +1,33 @@\n+2001-12-15  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n+\n+\t* java-tree.h (otable_methods, otable_decl, otable_syms_decl,\n+\totable_type, otable_ptr_type, method_symbol_type, \n+\tmethod_symbols_array_type, method_symbols_array_ptr_type): New\n+\tfield/global tree definitions.\n+\t(flag_indirect_dispatch): New flag.\n+\t* decl.c (java_init_decl_processing): Initialize new otable and \n+\totable_syms type nodes and decls. Add new field \"index\" to\n+\tmethod_type_node.\n+\t* class.c (build_method_symbols_entry): New function.\n+\t(make_method_value): Set \"index\" to to method's vtable index for\n+\tvirtual methods when indirect-dispatch is not used.\n+\t(make_class_data): For indirect-dispatch, dont emit the dtable_decl,\n+\tand set vtable_method_count to -1. Set otable and otable_syms field\n+\tif indirect-dispatch is used and there was something to put in them.\n+\t(build_method_symbols_entry): New function.\n+\t(emit_offset_symbol_table): New function.\n+\t* expr.c (get_offset_table_index): New function.\n+\t(build_invokevirtual): Build array reference to otable at the index \n+\treturned by get_offset_table_index, and use the result as the vtable\n+\toffset.\n+\t(build_invokeinterface): Similar.\n+\t* jcf-parse.c (yyparse): If indirect-dispatch, call \n+\temit_offset_symbol_table at the end of compilation, after all classes \n+\thave been generated.\n+\t* jvspec.c: Don't pass findirect-dispatch to jvgenmain.\n+\t* lang.c (flag_indirect_dispatch): Define.\n+\t(lang_f_options): Add indirect-dispatch flag.\n+\n 2001-12-14  Matthias Klose  <doko@debian.org>\n \n \t* gcj.texi: Markup for man page generation. Document missing"}, {"sha": "6b05435c11e2d84388cee5bf21bfdb4a71dca8fe", "filename": "gcc/java/class.c", "status": "modified", "additions": 119, "deletions": 5, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861ef92859ce3681ae24ecac1384e0be2a035c9d/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861ef92859ce3681ae24ecac1384e0be2a035c9d/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=861ef92859ce3681ae24ecac1384e0be2a035c9d", "patch": "@@ -58,6 +58,8 @@ static int assume_compiled PARAMS ((const char *));\n static struct hash_entry *init_test_hash_newfunc PARAMS ((struct hash_entry *,\n \t\t\t\t\t\t\t  struct hash_table *,\n \t\t\t\t\t\t\t  hash_table_key));\n+static tree build_method_symbols_entry PARAMS ((tree));\n+\n static rtx registerClass_libfunc;\n static rtx registerResource_libfunc;\n \n@@ -1276,9 +1278,16 @@ make_method_value (mdecl)\n {\n   static int method_name_count = 0;\n   tree minit;\n+  tree index;\n   tree code;\n #define ACC_TRANSLATED          0x4000\n   int accflags = get_access_flags_from_decl (mdecl) | ACC_TRANSLATED;\n+\n+  if (!flag_indirect_dispatch && DECL_VINDEX (mdecl) != NULL_TREE)\n+    index = DECL_VINDEX (mdecl);\n+  else\n+    index = integer_minus_one_node;\n+\n   code = null_pointer_node;\n   if (DECL_RTL_SET_P (mdecl))\n     code = build1 (ADDR_EXPR, nativecode_ptr_type_node, mdecl);\n@@ -1296,6 +1305,7 @@ make_method_value (mdecl)\n \t\t\t IDENTIFIER_LENGTH(signature)))));\n   }\n   PUSH_FIELD_VALUE (minit, \"accflags\", build_int_2 (accflags, 0));\n+  PUSH_FIELD_VALUE (minit, \"index\", index);\n   PUSH_FIELD_VALUE (minit, \"ncode\", code);\n \n   {\n@@ -1541,7 +1551,7 @@ make_class_data (type)\n   rest_of_decl_compilation (methods_decl, (char*) 0, 1, 0);\n \n   if (assume_compiled (IDENTIFIER_POINTER (DECL_NAME (type_decl)))\n-      && ! CLASS_INTERFACE (type_decl))\n+      && ! CLASS_INTERFACE (type_decl) && !flag_indirect_dispatch)\n     {\n       tree dtable = get_dispatch_table (type, this_class_addr);\n       dtable_decl = build_dtable_decl (type);\n@@ -1635,17 +1645,40 @@ make_class_data (type)\n   PUSH_FIELD_VALUE (cons, \"methods\",\n \t\t    build1 (ADDR_EXPR, method_ptr_type_node, methods_decl));\n   PUSH_FIELD_VALUE (cons, \"method_count\",  build_int_2 (method_count, 0));\n-  PUSH_FIELD_VALUE (cons, \"vtable_method_count\", TYPE_NVIRTUALS (type));\n+\n+  if (flag_indirect_dispatch)\n+    PUSH_FIELD_VALUE (cons, \"vtable_method_count\", integer_minus_one_node)\n+  else\n+    PUSH_FIELD_VALUE (cons, \"vtable_method_count\", TYPE_NVIRTUALS (type));\n+    \n   PUSH_FIELD_VALUE (cons, \"fields\",\n \t\t    fields_decl == NULL_TREE ? null_pointer_node\n \t\t    : build1 (ADDR_EXPR, field_ptr_type_node, fields_decl));\n   PUSH_FIELD_VALUE (cons, \"size_in_bytes\", size_in_bytes (type));\n   PUSH_FIELD_VALUE (cons, \"field_count\", build_int_2 (field_count, 0));\n   PUSH_FIELD_VALUE (cons, \"static_field_count\",\n \t\t    build_int_2 (static_field_count, 0));\n-  PUSH_FIELD_VALUE (cons, \"vtable\",\n-\t\t    dtable_decl == NULL_TREE ? null_pointer_node\n-\t\t    : build1 (ADDR_EXPR, dtable_ptr_type, dtable_decl));\n+\n+  if (flag_indirect_dispatch)\n+    PUSH_FIELD_VALUE (cons, \"vtable\", null_pointer_node)\n+  else\n+    PUSH_FIELD_VALUE (cons, \"vtable\",\n+\t\t      dtable_decl == NULL_TREE ? null_pointer_node\n+\t\t      : build1 (ADDR_EXPR, dtable_ptr_type, dtable_decl));\n+  \n+  if (otable_methods == NULL_TREE)\n+    {\n+      PUSH_FIELD_VALUE (cons, \"otable\", null_pointer_node);\n+      PUSH_FIELD_VALUE (cons, \"otable_syms\", null_pointer_node);\n+    }\n+  else\n+    {\n+      PUSH_FIELD_VALUE (cons, \"otable\",\n+\t\t\tbuild1 (ADDR_EXPR, otable_ptr_type, otable_decl));\n+      PUSH_FIELD_VALUE (cons, \"otable_syms\",\n+\t\t\tbuild1 (ADDR_EXPR, method_symbols_array_ptr_type,\n+\t\t\t\totable_syms_decl));\n+    }\n   PUSH_FIELD_VALUE (cons, \"interfaces\", interfaces);\n   PUSH_FIELD_VALUE (cons, \"loader\", null_pointer_node);\n   PUSH_FIELD_VALUE (cons, \"interface_count\", build_int_2 (interface_len, 0));\n@@ -2160,6 +2193,87 @@ emit_register_classes ()\n     }\n }\n \n+/* Make a method_symbol_type (_Jv_MethodSymbol) node for METHOD. */\n+\n+tree\n+build_method_symbols_entry (tree method)\n+{\n+  tree clname, name, signature, method_symbol;\n+  \n+  clname = build_utf8_ref (DECL_NAME (TYPE_NAME (DECL_CONTEXT (method))));\n+  name = build_utf8_ref (DECL_NAME (method));\n+  signature = build_java_signature (TREE_TYPE (method));\n+  signature = build_utf8_ref (unmangle_classname \n+\t\t\t      (IDENTIFIER_POINTER (signature),\n+\t\t\t       IDENTIFIER_LENGTH (signature)));\n+\n+  START_RECORD_CONSTRUCTOR (method_symbol, method_symbol_type);\n+  PUSH_FIELD_VALUE (method_symbol, \"clname\", clname);\n+  PUSH_FIELD_VALUE (method_symbol, \"name\", name);\n+  PUSH_FIELD_VALUE (method_symbol, \"signature\", signature);\n+  FINISH_RECORD_CONSTRUCTOR (method_symbol);\n+  TREE_CONSTANT (method_symbol) = 1;\n+\n+  return method_symbol;\n+} \n+\n+/* Emit the offset symbols table for indirect virtual dispatch. */\n+\n+void\n+emit_offset_symbol_table ()\n+{\n+  tree method_list, method, table, list, null_symbol;\n+  tree otable_bound, otable_array_type;\n+  int index;\n+  \n+  /* Only emit an offset table if this translation unit actually made virtual \n+     calls. */\n+  if (otable_methods == NULL_TREE)\n+    return;\n+\n+  /* Build a list of _Jv_MethodSymbols for each entry in otable_methods. */\n+  index = 0;\n+  method_list = otable_methods;\n+  list = NULL_TREE;  \n+  while (method_list != NULL_TREE)\n+    {\n+      method = TREE_VALUE (method_list);\n+      list = tree_cons (NULL_TREE, build_method_symbols_entry (method), list);\n+      method_list = TREE_CHAIN (method_list);\n+      index++;\n+    }\n+\n+  /* Terminate the list with a \"null\" entry. */\n+  START_RECORD_CONSTRUCTOR (null_symbol, method_symbol_type);\n+  PUSH_FIELD_VALUE (null_symbol, \"clname\", null_pointer_node);\n+  PUSH_FIELD_VALUE (null_symbol, \"name\", null_pointer_node);\n+  PUSH_FIELD_VALUE (null_symbol, \"signature\", null_pointer_node);\n+  FINISH_RECORD_CONSTRUCTOR (null_symbol);\n+  TREE_CONSTANT (null_symbol) = 1;  \n+  list = tree_cons (NULL_TREE, null_symbol, list);\n+\n+  /* Put the list in the right order and make it a constructor. */\n+  list = nreverse (list);\n+  table = build (CONSTRUCTOR, method_symbols_array_type, NULL_TREE, list);  \n+\n+  /* Make it the initial value for otable_syms and emit the decl. */\n+  DECL_INITIAL (otable_syms_decl) = table;\n+  DECL_ARTIFICIAL (otable_syms_decl) = 1;\n+  DECL_IGNORED_P (otable_syms_decl) = 1;\n+  rest_of_decl_compilation (otable_syms_decl, NULL, 1, 0);\n+  \n+  /* Now that its size is known, redefine otable as an uninitialized static \n+     array of INDEX + 1 integers. The extra entry is used by the runtime \n+     to track whether the otable has been initialized. */\n+  otable_bound = build_index_type (build_int_2 (index, 0));\n+  otable_array_type = build_array_type (integer_type_node, otable_bound);\n+  otable_decl = build_decl (VAR_DECL, get_identifier (\"otable\"), \n+\t\t\t    otable_array_type);\n+  TREE_STATIC (otable_decl) = 1;\n+  TREE_READONLY (otable_decl) = 1;  \n+  rest_of_decl_compilation (otable_decl, NULL, 1, 0);\n+}\n+\n void\n init_class_processing ()\n {"}, {"sha": "4cfa9ba7ee0795d0dec2451ce686188c690fecd8", "filename": "gcc/java/decl.c", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861ef92859ce3681ae24ecac1384e0be2a035c9d/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861ef92859ce3681ae24ecac1384e0be2a035c9d/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=861ef92859ce3681ae24ecac1384e0be2a035c9d", "patch": "@@ -614,6 +614,35 @@ java_init_decl_processing ()\n   dtable_type = make_node (RECORD_TYPE);\n   dtable_ptr_type = build_pointer_type (dtable_type);\n \n+  otable_type = make_node (RECORD_TYPE);\n+  otable_ptr_type = build_pointer_type (otable_type);\n+\n+  method_symbol_type = make_node (RECORD_TYPE);\n+  PUSH_FIELD (method_symbol_type, field, \"clname\", utf8const_ptr_type);\n+  PUSH_FIELD (method_symbol_type, field, \"name\", utf8const_ptr_type);\n+  PUSH_FIELD (method_symbol_type, field, \"signature\", utf8const_ptr_type);\n+  FINISH_RECORD (method_symbol_type);\n+\n+  one_elt_array_domain_type = build_index_type (integer_one_node);\n+  method_symbols_array_type = build_array_type (method_symbol_type, \n+\t\t\t\t\t\tone_elt_array_domain_type);\n+  method_symbols_array_ptr_type = build_pointer_type \n+\t\t\t\t  (method_symbols_array_type);\n+\n+  otable_decl = build_decl (VAR_DECL, get_identifier (\"otable\"), \n+\t\t\t    build_array_type (integer_type_node, \n+\t\t\t    one_elt_array_domain_type));\n+  DECL_EXTERNAL (otable_decl) = 1;\n+  TREE_STATIC (otable_decl) = 1;\n+  TREE_READONLY (otable_decl) = 1;\n+  pushdecl (otable_decl);\n+  \n+  otable_syms_decl = build_decl (VAR_DECL, get_identifier (\"otable_syms\"), \n+    method_symbols_array_type);\n+  TREE_STATIC (otable_syms_decl) = 1;\n+  TREE_CONSTANT (otable_syms_decl) = 1;\n+  pushdecl (otable_syms_decl);\n+  \n   PUSH_FIELD (object_type_node, field, \"vtable\", dtable_ptr_type);\n   /* This isn't exactly true, but it is what we have in the source.\n      There is an unresolved issue here, which is whether the vtable\n@@ -647,6 +676,9 @@ java_init_decl_processing ()\n   PUSH_FIELD (class_type_node, field, \"field_count\", short_type_node);\n   PUSH_FIELD (class_type_node, field, \"static_field_count\", short_type_node);\n   PUSH_FIELD (class_type_node, field, \"vtable\", dtable_ptr_type);\n+  PUSH_FIELD (class_type_node, field, \"otable\", otable_ptr_type);\n+  PUSH_FIELD (class_type_node, field, \"otable_syms\", \n+  \t      method_symbols_array_ptr_type);\n   PUSH_FIELD (class_type_node, field, \"interfaces\",\n \t      build_pointer_type (class_ptr_type));\n   PUSH_FIELD (class_type_node, field, \"loader\", ptr_type_node);\n@@ -661,6 +693,7 @@ java_init_decl_processing ()\n   for (t = TYPE_FIELDS (class_type_node);  t != NULL_TREE;  t = TREE_CHAIN (t))\n     FIELD_PRIVATE (t) = 1;\n   push_super_field (class_type_node, object_type_node);\n+\n   FINISH_RECORD (class_type_node);\n   build_decl (TYPE_DECL, get_identifier (\"Class\"), class_type_node);\n \n@@ -680,7 +713,6 @@ java_init_decl_processing ()\n   FINISH_RECORD (field_type_node);\n   build_decl (TYPE_DECL, get_identifier (\"Field\"), field_type_node);\n \n-  one_elt_array_domain_type = build_index_type (integer_one_node);\n   nativecode_ptr_array_type_node\n     = build_array_type (nativecode_ptr_type_node, one_elt_array_domain_type);\n \n@@ -717,6 +749,7 @@ java_init_decl_processing ()\n   PUSH_FIELD (method_type_node, field, \"name\", utf8const_ptr_type);\n   PUSH_FIELD (method_type_node, field, \"signature\", utf8const_ptr_type);\n   PUSH_FIELD (method_type_node, field, \"accflags\", access_flags_type_node);\n+  PUSH_FIELD (method_type_node, field, \"index\", unsigned_short_type_node);\n   PUSH_FIELD (method_type_node, field, \"ncode\", nativecode_ptr_type_node);\n   PUSH_FIELD (method_type_node, field, \"throws\", ptr_type_node);\n   FINISH_RECORD (method_type_node);"}, {"sha": "e5d141ea5e4273472a17766cefa4d8dcd9a90bc5", "filename": "gcc/java/expr.c", "status": "modified", "additions": 76, "deletions": 19, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861ef92859ce3681ae24ecac1384e0be2a035c9d/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861ef92859ce3681ae24ecac1384e0be2a035c9d/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=861ef92859ce3681ae24ecac1384e0be2a035c9d", "patch": "@@ -84,6 +84,7 @@ static tree case_identity PARAMS ((tree, tree));\n static unsigned char peek_opcode_at_pc PARAMS ((struct JCF *, int, int));\n static bool emit_init_test_initialization PARAMS ((struct hash_entry *,\n \t\t\t\t\t\t   PTR ptr));\n+static int get_offset_table_index PARAMS ((tree));\n \n static tree operand_type[59];\n extern struct obstack permanent_obstack;\n@@ -1856,27 +1857,74 @@ invoke_build_dtable (is_invoke_interface, arg_list)\n   return dtable;\n }\n \n+/* Determine the index in the virtual offset table (otable) for a call to\n+   METHOD. If this method has not been seen before, it will be added to the \n+   otable_methods. If it has, the existing otable slot will be reused. */\n+\n+int\n+get_offset_table_index (method)\n+     tree method;\n+{\n+  int i = 1;\n+  tree method_list;\n+  \n+  if (otable_methods == NULL_TREE)\n+    {\n+      otable_methods = build_tree_list (method, method);\n+      return 1;\n+    }\n+  \n+  method_list = otable_methods;\n+  \n+  while (1)\n+    {\n+      if (TREE_VALUE (method_list) == method)\n+        return i;\n+      i++;\n+      if (TREE_CHAIN (method_list) == NULL_TREE)\n+        break;\n+      else\n+        method_list = TREE_CHAIN (method_list);\n+    }\n+\n+  TREE_CHAIN (method_list) = build_tree_list (method, method);\n+  return i;\n+}\n+\n tree \n build_invokevirtual (dtable, method)\n      tree dtable, method;\n {\n   tree func;\n   tree nativecode_ptr_ptr_type_node\n     = build_pointer_type (nativecode_ptr_type_node);\n-  tree method_index = convert (sizetype, DECL_VINDEX (method));\n+  tree method_index;\n+  tree otable_index;\n \n-  if (TARGET_VTABLE_USES_DESCRIPTORS)\n-    /* Add one to skip bogus descriptor for class and GC descriptor. */\n-    method_index = size_binop (PLUS_EXPR, method_index, size_int (1));\n+  if (flag_indirect_dispatch)\n+    {\n+      otable_index = build_int_2 (get_offset_table_index (method), 0);\n+      method_index = build (ARRAY_REF, integer_type_node, otable_decl, \n+\t\t\t    otable_index);\n+    }\n   else\n-    /* Add 1 to skip \"class\" field of dtable, and 1 to skip GC descriptor.  */\n-    method_index = size_binop (PLUS_EXPR, method_index, size_int (2));\n-  method_index = size_binop (MULT_EXPR, method_index,\n-\t\t\t     TYPE_SIZE_UNIT (nativecode_ptr_ptr_type_node));\n+    {\n+      method_index = convert (sizetype, DECL_VINDEX (method));\n \n-  if (TARGET_VTABLE_USES_DESCRIPTORS)\n-    method_index = size_binop (MULT_EXPR, method_index,\n-\t\t\t       size_int (TARGET_VTABLE_USES_DESCRIPTORS));\n+      if (TARGET_VTABLE_USES_DESCRIPTORS)\n+\t/* Add one to skip bogus descriptor for class and GC descriptor. */\n+\tmethod_index = size_binop (PLUS_EXPR, method_index, size_int (1));\n+      else\n+\t/* Add 1 to skip \"class\" field of dtable, and 1 to skip GC descriptor.  */\n+\tmethod_index = size_binop (PLUS_EXPR, method_index, size_int (2));\n+\n+      method_index = size_binop (MULT_EXPR, method_index,\n+\t\t\t\t TYPE_SIZE_UNIT (nativecode_ptr_ptr_type_node));\n+\n+      if (TARGET_VTABLE_USES_DESCRIPTORS)\n+\tmethod_index = size_binop (MULT_EXPR, method_index,\n+\t\t\t\t   size_int (TARGET_VTABLE_USES_DESCRIPTORS));\n+    }\n \n   func = fold (build (PLUS_EXPR, nativecode_ptr_ptr_type_node, dtable,\n \t\t      convert (nativecode_ptr_ptr_type_node, method_index)));\n@@ -1898,6 +1946,7 @@ build_invokeinterface (dtable, method)\n   tree interface;\n   tree idx;\n   tree meth;\n+  tree otable_index;\n   int i;\n \n   /* We expand invokeinterface here.  _Jv_LookupInterfaceMethod() will\n@@ -1917,16 +1966,24 @@ build_invokeinterface (dtable, method)\n   interface = DECL_CONTEXT (method);\n   layout_class_methods (interface);\n   \n-  i = 1;\n-  for (meth = TYPE_METHODS (interface); ; meth = TREE_CHAIN (meth), i++)\n+  if (flag_indirect_dispatch)\n     {\n-      if (meth == method)\n-        {\n-\t  idx = build_int_2 (i, 0);\n-\t  break;\n+      otable_index = build_int_2 (get_offset_table_index (method), 0);\n+      idx = build (ARRAY_REF, integer_type_node, otable_decl, otable_index);\n+    }\n+  else\n+    {\n+      i = 1;\n+      for (meth = TYPE_METHODS (interface); ; meth = TREE_CHAIN (meth), i++)\n+\t{\n+\t  if (meth == method)\n+            {\n+\t      idx = build_int_2 (i, 0);\n+\t      break;\n+\t    }\n+\t  if (meth == NULL_TREE)\n+\t    abort ();\n \t}\n-      if (meth == NULL_TREE)\n-\tabort ();\n     }\n \n   lookup_arg = tree_cons (NULL_TREE, dtable,"}, {"sha": "17a06382815dfc4b3d283d0d30b3161d19687d3d", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861ef92859ce3681ae24ecac1384e0be2a035c9d/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861ef92859ce3681ae24ecac1384e0be2a035c9d/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=861ef92859ce3681ae24ecac1384e0be2a035c9d", "patch": "@@ -141,6 +141,18 @@ extern int compiling_from_source;\n /* List of all class filenames seen so far.  */\n #define all_class_filename java_global_trees [JTI_ALL_CLASS_FILENAME]\n \n+/* List of virtual method decls called in this translation unit, used to \n+   generate virtual method offset symbol table. */\n+#define otable_methods java_global_trees [JTI_OTABLE_METHODS]\n+\n+/* The virtual method offset table. This is emitted as uninitialized data of \n+   the required length, and filled out at run time during class linking. */\n+#define otable_decl java_global_trees [JTI_OTABLE_DECL]\n+\n+/* The virtual method offset symbol table. Used by the runtime to fill out the\n+   otable. */\n+#define otable_syms_decl java_global_trees [JTI_OTABLE_SYMS_DECL]\n+\n extern int flag_emit_class_files;\n \n extern int flag_filelist_file;\n@@ -196,6 +208,10 @@ extern int flag_check_references;\n    initialization optimization should be performed.  */\n extern int flag_optimize_sci;\n \n+/* When non zero, use offset tables for virtual method calls\n+   in order to improve binary compatibility. */\n+extern int flag_indirect_dispatch;\n+\n /* Encoding used for source files.  */\n extern const char *current_encoding;\n \n@@ -331,6 +347,11 @@ enum java_tree_index\n   JTI_LINENUMBERS_TYPE,\n   JTI_METHOD_TYPE_NODE,\n   JTI_METHOD_PTR_TYPE_NODE,\n+  JTI_OTABLE_TYPE,\n+  JTI_OTABLE_PTR_TYPE,\n+  JTI_METHOD_SYMBOL_TYPE,\n+  JTI_METHOD_SYMBOLS_ARRAY_TYPE,\n+  JTI_METHOD_SYMBOLS_ARRAY_PTR_TYPE,\n \n   JTI_END_PARAMS_NODE,\n \n@@ -370,6 +391,10 @@ enum java_tree_index\n   JTI_ALL_CLASS_LIST,\n   JTI_ALL_CLASS_FILENAME,\n \n+  JTI_OTABLE_METHODS,\n+  JTI_OTABLE_DECL,\n+  JTI_OTABLE_SYMS_DECL,\n+\n   JTI_MAX\n };\n \n@@ -565,6 +590,16 @@ extern tree java_global_trees[JTI_MAX];\n   java_global_trees[JTI_METHOD_TYPE_NODE]\n #define method_ptr_type_node \\\n   java_global_trees[JTI_METHOD_PTR_TYPE_NODE]\n+#define otable_type \\\n+  java_global_trees[JTI_OTABLE_TYPE]\n+#define otable_ptr_type \\\n+  java_global_trees[JTI_OTABLE_PTR_TYPE]\n+#define method_symbol_type \\\n+  java_global_trees[JTI_METHOD_SYMBOL_TYPE]\n+#define method_symbols_array_type \\\n+  java_global_trees[JTI_METHOD_SYMBOLS_ARRAY_TYPE]\n+#define method_symbols_array_ptr_type \\\n+  java_global_trees[JTI_METHOD_SYMBOLS_ARRAY_PTR_TYPE]\n \n #define end_params_node \\\n   java_global_trees[JTI_END_PARAMS_NODE]\n@@ -1098,6 +1133,7 @@ extern void make_class_data PARAMS ((tree));\n extern void register_class PARAMS ((void));\n extern int alloc_name_constant PARAMS ((int, tree));\n extern void emit_register_classes PARAMS ((void));\n+extern void emit_offset_symbol_table PARAMS ((void));\n extern void lang_init_source PARAMS ((int));\n extern void write_classfile PARAMS ((tree));\n extern char *print_int_node PARAMS ((tree));"}, {"sha": "61d097297274907597cb17df3409c83aeccd11e8", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861ef92859ce3681ae24ecac1384e0be2a035c9d/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861ef92859ce3681ae24ecac1384e0be2a035c9d/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=861ef92859ce3681ae24ecac1384e0be2a035c9d", "patch": "@@ -1188,7 +1188,11 @@ yyparse ()\n \n   java_expand_classes ();\n   if (!java_report_errors () && !flag_syntax_only)\n-    emit_register_classes ();\n+    {\n+      emit_register_classes ();\n+      if (flag_indirect_dispatch)\n+\temit_offset_symbol_table ();\n+    }\n   return 0;\n }\n "}, {"sha": "1fd4f4cc87a089785776e934766f55865241c2f9", "filename": "gcc/java/jvspec.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861ef92859ce3681ae24ecac1384e0be2a035c9d/gcc%2Fjava%2Fjvspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861ef92859ce3681ae24ecac1384e0be2a035c9d/gcc%2Fjava%2Fjvspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjvspec.c?ref=861ef92859ce3681ae24ecac1384e0be2a035c9d", "patch": "@@ -64,6 +64,7 @@ const char jvgenmain_spec[] =\n                    %{<fcompile-resource*}\\\n \t\t   %{<femit-class-file} %{<femit-class-files} %{<fencoding*}\\\n \t\t   %{<fuse-boehm-gc} %{<fhash-synchronization} %{<fjni}\\\n+\t\t   %{<findirect-dispatch} \\\n \t\t   %{<fclasspath*} %{<fCLASSPATH*} %{<foutput-class-dir}\\\n \t\t   %{<fuse-divide-subroutine} %{<fno-use-divide-subroutine}\\\n \t\t   %{<fcheck-references} %{<fno-check-references}\\"}, {"sha": "11e036ca38a7603b1f748b9de1aed148d0685a66", "filename": "gcc/java/lang.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861ef92859ce3681ae24ecac1384e0be2a035c9d/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861ef92859ce3681ae24ecac1384e0be2a035c9d/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=861ef92859ce3681ae24ecac1384e0be2a035c9d", "patch": "@@ -153,6 +153,10 @@ int flag_force_classes_archive_check;\n    be tested alone, use STATIC_CLASS_INITIALIZATION_OPTIMIZATION_P instead.  */\n int flag_optimize_sci = 1;\n \n+/* When non zero, use offset tables for virtual method calls\n+   in order to improve binary compatibility. */\n+int flag_indirect_dispatch = 0;\n+\n /* When non zero, print extra version information.  */\n static int version_flag = 0;\n \n@@ -174,7 +178,8 @@ lang_f_options[] =\n   {\"jni\", &flag_jni, 1},\n   {\"check-references\", &flag_check_references, 1},\n   {\"force-classes-archive-check\", &flag_force_classes_archive_check, 1},\n-  {\"optimize-static-class-initialization\", &flag_optimize_sci, 1 }\n+  {\"optimize-static-class-initialization\", &flag_optimize_sci, 1 },\n+  {\"indirect-dispatch\", &flag_indirect_dispatch, 1}\n };\n \n static struct string_option"}, {"sha": "39375cf8612ea82ade4e023b3bd69e566df74820", "filename": "libjava/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861ef92859ce3681ae24ecac1384e0be2a035c9d/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861ef92859ce3681ae24ecac1384e0be2a035c9d/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=861ef92859ce3681ae24ecac1384e0be2a035c9d", "patch": "@@ -1,3 +1,19 @@\n+2001-12-15  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n+\n+\t* include/jvm.h (_Jv_VTable::idx_to_offset): New method.\n+\t* java/lang/natClassLoader.cc (_Jv_PrepareCompiledClass): Call\n+\t_Jv_MakeVTable and _Jv_LinkOffsetTable if needed.\n+\t* java/lang/Class.h (_Jv_Method): Add \"index\" field.\n+\t(_Jv_MethodSymbol): New struct type.\n+\t(_Jv_LinkOffsetTable, _Jv_LayoutVTableMethods, _Jv_SetVTableEntries,\n+\t_Jv_MakeVTable): Friends.\n+\t(otable, otable_syms): New Class fields.\n+\t* java/lang/natClass.cc (_Jv_LinkOffsetTable): New function.\n+\t(isVirtualMethod): New static function.\n+\t(_Jv_LayoutVTableMethods): New function.\n+\t(_Jv_SetVTableEntries): New function.\n+\t(_Jv_MakeVTable): New function.\n+\n 2001-12-15  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n \n \t* java/util/BitSet.java (and): Fix off-by-one bug, don't skip part of"}, {"sha": "ada8e11a2e1bced0f40696cb6246a29af7c9cd3b", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861ef92859ce3681ae24ecac1384e0be2a035c9d/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861ef92859ce3681ae24ecac1384e0be2a035c9d/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=861ef92859ce3681ae24ecac1384e0be2a035c9d", "patch": "@@ -57,6 +57,12 @@ struct _Jv_VTable\n #endif\n \n   static size_t vtable_elt_size() { return sizeof(vtable_elt); }\n+\n+  // Given a method index, return byte offset from the vtable pointer.\n+  static jint idx_to_offset (int index)\n+  {\n+    return (2 * sizeof (void *)) + (index * vtable_elt_size ());\n+  }\n   static _Jv_VTable *new_vtable (int count);\n };\n "}, {"sha": "20523912e583554b5b27cbbd33e4f43711a86d56", "filename": "libjava/java/lang/Class.h", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861ef92859ce3681ae24ecac1384e0be2a035c9d/libjava%2Fjava%2Flang%2FClass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861ef92859ce3681ae24ecac1384e0be2a035c9d/libjava%2Fjava%2Flang%2FClass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.h?ref=861ef92859ce3681ae24ecac1384e0be2a035c9d", "patch": "@@ -70,6 +70,8 @@ struct _Jv_Method\n   _Jv_Utf8Const *signature;\n   // Access flags.\n   _Jv_ushort accflags;\n+  // Method's index in the vtable.\n+  _Jv_ushort index;\n   // Pointer to underlying function.\n   void *ncode;\n   // NULL-terminated list of exception class names; can be NULL if\n@@ -114,6 +116,19 @@ union _Jv_Self\n   jclass self;\n };\n \n+struct _Jv_MethodSymbol\n+{\n+  _Jv_Utf8Const *class_name;\n+  _Jv_Utf8Const *name;\n+  _Jv_Utf8Const *signature;\n+};\n+\n+struct _Jv_OffsetTable\n+{\n+  jint state;\n+  jint offsets[];\n+};\n+\n #define JV_PRIMITIVE_VTABLE ((_Jv_VTable *) -1)\n \n #define JV_CLASS(Obj) ((jclass) (*(_Jv_VTable **) Obj)->clas)\n@@ -303,6 +318,10 @@ class java::lang::Class : public java::lang::Object\n   friend jstring _Jv_GetMethodString(jclass, _Jv_Utf8Const *);\n   friend jshort _Jv_AppendPartialITable (jclass, jclass, void **, jshort);\n   friend jshort _Jv_FindIIndex (jclass *, jshort *, jshort);\n+  friend void _Jv_LinkOffsetTable (jclass);\n+  friend void _Jv_LayoutVTableMethods (jclass klass);\n+  friend void _Jv_SetVTableEntries (jclass, _Jv_VTable *);\n+  friend void _Jv_MakeVTable (jclass);\n \n   // Return array class corresponding to element type KLASS, creating it if\n   // necessary.\n@@ -367,6 +386,10 @@ class java::lang::Class : public java::lang::Object\n   jshort static_field_count;\n   // The vtbl for all objects of this class.\n   _Jv_VTable *vtable;\n+  // Virtual method offset table.\n+  _Jv_OffsetTable *otable;\n+  // Offset table symbols.\n+  _Jv_MethodSymbol *otable_syms;\n   // Interfaces implemented by this class.\n   jclass *interfaces;\n   // The class loader for this class."}, {"sha": "6dfe14bab717360140cb69b44dbb0eb8d75a3a4d", "filename": "libjava/java/lang/natClass.cc", "status": "modified", "additions": 192, "deletions": 1, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861ef92859ce3681ae24ecac1384e0be2a035c9d/libjava%2Fjava%2Flang%2FnatClass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861ef92859ce3681ae24ecac1384e0be2a035c9d/libjava%2Fjava%2Flang%2FnatClass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClass.cc?ref=861ef92859ce3681ae24ecac1384e0be2a035c9d", "patch": "@@ -692,7 +692,7 @@ java::lang::Class::initializeClass (void)\n \t  _Jv_PrepareCompiledClass (this);\n \t}\n     }\n-  \n+\n   if (state <= JV_STATE_LINKED)\n     _Jv_PrepareConstantTimeTables (this);\n \n@@ -1422,3 +1422,194 @@ java::lang::Class::getProtectionDomain0 ()\n {\n   return protectionDomain;\n }\n+\n+// Functions for indirect dispatch (symbolic virtual method binding) support.\n+\n+// Resolve entries in the virtual method offset symbol table \n+// (klass->otable_syms). The vtable offset (in bytes) for each resolved method \n+// is placed at the corresponding position in the virtual method offset table \n+// (klass->otable). A single otable and otable_syms pair may be shared by many \n+// classes.\n+void\n+_Jv_LinkOffsetTable(jclass klass)\n+{\n+  //// FIXME: Need to lock the otable ////\n+  \n+  if (klass->otable == NULL\n+      || klass->otable->state != 0)\n+    return;\n+  \n+  klass->otable->state = 1;\n+\n+  int index = 0;\n+  _Jv_MethodSymbol sym = klass->otable_syms[0];\n+\n+  while (sym.name != NULL)\n+    {\n+      jclass target_class = _Jv_FindClass (sym.class_name, NULL);\n+      _Jv_Method *meth = NULL;            \n+      \n+      if (target_class != NULL)\n+\tif (target_class->isInterface())\n+\t  {\n+\t    // FIXME: This does not yet fully conform to binary compatibility\n+\t    // rules. It will break if a declaration is moved into a \n+\t    // superinterface.\n+\t    for (int i=0; i < target_class->method_count; i++)\n+\t      {\n+\t\tmeth = &target_class->methods[i];\n+\t\tif (_Jv_equalUtf8Consts (sym.name, meth->name)\n+\t\t    && _Jv_equalUtf8Consts (sym.signature, meth->signature))\n+\t\t  {\n+\t\t    klass->otable->offsets[index] = i + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    // If the target class does not have a vtable_method_count yet, \n+\t    // then we can't tell the offsets for its methods, so we must lay \n+\t    // it out now.\n+\t    if (target_class->vtable_method_count == -1)\n+\t      {\n+\t\tJvSynchronize sync (target_class);\n+\t\t_Jv_LayoutVTableMethods (target_class);\n+\t      }\n+\n+            meth = _Jv_LookupDeclaredMethod(target_class, sym.name, \n+\t\t\t\t\t    sym.signature);\n+\n+\t    if (meth != NULL)\n+\t      {\n+\t\tklass->otable->offsets[index] = \n+\t\t  _Jv_VTable::idx_to_offset (meth->index);\n+\t      }\n+\t  }\n+\n+      if (meth == NULL)\n+\t// FIXME: This should be special index for ThrowNoSuchMethod().\n+\tklass->otable->offsets[index] = -1;\n+\n+      sym = klass->otable_syms[++index];\n+    }\n+}\n+\n+// Returns true if METH should get an entry in a VTable.\n+static bool\n+isVirtualMethod (_Jv_Method *meth)\n+{\n+  using namespace java::lang::reflect;\n+  return (((meth->accflags & (Modifier::STATIC | Modifier::PRIVATE)) == 0)\n+          && meth->name->data[0] != '<');\n+}\n+\n+// Prepare virtual method declarations in KLASS, and any superclasses as \n+// required, by determining their vtable index, setting method->index, and\n+// finally setting the class's vtable_method_count. Must be called with the\n+// lock for KLASS held.\n+void\n+_Jv_LayoutVTableMethods (jclass klass)\n+{\n+  if (klass->vtable != NULL || klass->isInterface() \n+      || klass->vtable_method_count != -1)\n+    return;\n+    \n+  jclass superclass = klass->superclass;\n+\n+  if (superclass != NULL && superclass->vtable_method_count == -1)\n+    {\n+      JvSynchronize sync (superclass);\n+      _Jv_LayoutVTableMethods (superclass);\n+    }\n+    \n+  int index = (superclass == NULL ? 0 : superclass->vtable_method_count);\n+\n+  for (int i = 0; i < klass->method_count; ++i)\n+    {\n+      _Jv_Method *meth = &klass->methods[i];\n+      _Jv_Method *super_meth = NULL;\n+    \n+      if (!isVirtualMethod(meth))\n+        continue;\n+\t      \n+      if (superclass != NULL)\n+        super_meth = _Jv_LookupDeclaredMethod (superclass, meth->name, \n+\t\t\t\t\t       meth->signature);\n+      \n+      if (super_meth)\n+        meth->index = super_meth->index;\n+      else\n+        meth->index = index++;\n+    }\n+  \n+  klass->vtable_method_count = index;\n+}\n+\n+// Set entries in VTABLE for virtual methods declared in KLASS. If KLASS has\n+// an immediate abstract parent, recursivly do its methods first.\n+void\n+_Jv_SetVTableEntries (jclass klass, _Jv_VTable *vtable)\n+{\n+  using namespace java::lang::reflect;\n+\n+  jclass superclass = klass->getSuperclass();\n+\n+  if (superclass != NULL && (superclass->getModifiers() & Modifier::ABSTRACT))\n+    _Jv_SetVTableEntries (superclass, vtable);\n+    \n+  for (int i = klass->method_count - 1; i >= 0; i--)\n+    {\n+      _Jv_Method *meth = &klass->methods[i];\n+      if (!isVirtualMethod(meth))\n+\tcontinue;\n+      vtable->set_method(meth->index, meth->ncode);\n+    }\n+}\n+\n+// Allocate and lay out the virtual method table for KLASS. This will also\n+// cause vtables to be generated for any non-abstract superclasses, and\n+// virtual method layout to occur for any abstract superclasses. Must be\n+// called with monitor lock for KLASS held.\n+void\n+_Jv_MakeVTable (jclass klass)\n+{\n+  using namespace java::lang::reflect;  \n+\n+  if (klass->vtable != NULL || klass->isInterface() \n+      || (klass->accflags & Modifier::ABSTRACT))\n+    return;\n+  \n+  //  out before we can create a vtable. \n+  if (klass->vtable_method_count == -1)\n+    _Jv_LayoutVTableMethods (klass);\n+\n+  // Allocate the new vtable.\n+  _Jv_VTable *vtable = _Jv_VTable::new_vtable (klass->vtable_method_count);\n+  klass->vtable = vtable;\n+  \n+  // Copy the vtable of the closest non-abstract superclass.\n+  jclass superclass = klass->superclass;\n+  if (superclass != NULL)\n+    {\n+      while ((superclass->accflags & Modifier::ABSTRACT) != 0)\n+\tsuperclass = superclass->superclass;\n+\n+      if (superclass->vtable == NULL)\n+\t{\n+\t  JvSynchronize sync (superclass);\n+\t  _Jv_MakeVTable (superclass);\n+\t}\n+\n+      for (int i = 0; i < superclass->vtable_method_count; ++i)\n+\tvtable->set_method (i, superclass->vtable->get_method (i));\n+    }\n+\n+  // Set the class pointer and GC descriptor.\n+  vtable->clas = klass;\n+  vtable->gc_descr = _Jv_BuildGCDescr (klass);\n+\n+  // For each virtual declared in klass and any immediate abstract \n+  // superclasses, set new vtable entry or override an old one.\n+  _Jv_SetVTableEntries (klass, vtable);\n+}"}, {"sha": "ffe5b18fbe04f10689b8957ce063a0b2259f7126", "filename": "libjava/java/lang/natClassLoader.cc", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861ef92859ce3681ae24ecac1384e0be2a035c9d/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861ef92859ce3681ae24ecac1384e0be2a035c9d/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClassLoader.cc?ref=861ef92859ce3681ae24ecac1384e0be2a035c9d", "patch": "@@ -234,7 +234,6 @@ java::lang::ClassLoader::findLoadedClass (jstring name)\n   return _Jv_FindClassInCache (_Jv_makeUtf8Const (name), this);\n }\n \n-\n /** This function does class-preparation for compiled classes.  \n     NOTE: It contains replicated functionality from\n     _Jv_ResolvePoolEntry, and this is intentional, since that function\n@@ -309,6 +308,12 @@ _Jv_PrepareCompiledClass (jclass klass)\n     }\n #endif /* INTERPRETER */\n \n+  if (klass->vtable == NULL)\n+    _Jv_MakeVTable(klass);\n+\n+  if (klass->otable != NULL && klass->otable->state == 0)\n+    _Jv_LinkOffsetTable(klass);\n+\n   klass->notifyAll ();\n }\n "}]}