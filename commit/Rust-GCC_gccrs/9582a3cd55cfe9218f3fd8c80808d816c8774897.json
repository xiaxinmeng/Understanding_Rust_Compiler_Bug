{"sha": "9582a3cd55cfe9218f3fd8c80808d816c8774897", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTU4MmEzY2Q1NWNmZTkyMThmM2ZkOGM4MDgwOGQ4MTZjODc3NDg5Nw==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@adacore.com", "date": "2005-12-09T17:16:11Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-12-09T17:16:11Z"}, "message": "decl.c (gnat_to_gnu_entity, [...]): Don't early expand pointer initialization values.\n\n2005-12-05  Olivier Hainque  <hainque@adacore.com>\n\n\t* decl.c (gnat_to_gnu_entity, renaming object case): Don't early expand\n\tpointer initialization values. Make a SAVE_EXPR instead. Add comments\n\tabout the use and expansion of SAVE_EXPRs in the various possible\n\trenaming handling cases.\n\t(components_to_record, compare_field_bitpos): Sort by DECL_UID, not by\n\tabusing DECL_FCONTEXT.\n\nFrom-SVN: r108286", "tree": {"sha": "99bdb93c71e216bfc70be023ed85dfe6d64e32e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99bdb93c71e216bfc70be023ed85dfe6d64e32e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9582a3cd55cfe9218f3fd8c80808d816c8774897", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9582a3cd55cfe9218f3fd8c80808d816c8774897", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9582a3cd55cfe9218f3fd8c80808d816c8774897", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9582a3cd55cfe9218f3fd8c80808d816c8774897/comments", "author": {"login": "hainque", "id": 18735142, "node_id": "MDQ6VXNlcjE4NzM1MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/18735142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hainque", "html_url": "https://github.com/hainque", "followers_url": "https://api.github.com/users/hainque/followers", "following_url": "https://api.github.com/users/hainque/following{/other_user}", "gists_url": "https://api.github.com/users/hainque/gists{/gist_id}", "starred_url": "https://api.github.com/users/hainque/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hainque/subscriptions", "organizations_url": "https://api.github.com/users/hainque/orgs", "repos_url": "https://api.github.com/users/hainque/repos", "events_url": "https://api.github.com/users/hainque/events{/privacy}", "received_events_url": "https://api.github.com/users/hainque/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bb4daba3460df28e1228e04f7d2a63712c709a7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb4daba3460df28e1228e04f7d2a63712c709a7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb4daba3460df28e1228e04f7d2a63712c709a7e"}], "stats": {"total": 93, "additions": 50, "deletions": 43}, "files": [{"sha": "b64463a53b619fcaa28b1887ea1549ad6ce7ae11", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 50, "deletions": 43, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9582a3cd55cfe9218f3fd8c80808d816c8774897/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9582a3cd55cfe9218f3fd8c80808d816c8774897/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=9582a3cd55cfe9218f3fd8c80808d816c8774897", "patch": "@@ -765,14 +765,16 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t       the renamed entity or if we need to make a pointer.  */\n \t    else\n \t      {\n-\t\tbool stabilized;\n+\t\tbool stabilized = false;\n \t\ttree maybe_stable_expr = NULL_TREE;\n \n \t\t/* Case 2: If the renaming entity need not be materialized and\n \t\t   the renamed expression is something we can stabilize, use\n-\t\t   that for the renaming after forcing the evaluation of any\n-\t\t   SAVE_EXPR.  At the global level, we can only do this if we\n-\t\t   know no SAVE_EXPRs will be made.  */\n+\t\t   that for the renaming.  At the global level, we can only do\n+\t\t   this if we know no SAVE_EXPRs need be made, because the\n+\t\t   expression we return might be used in arbitrary conditional\n+\t\t   branches so we must force the SAVE_EXPRs evaluation\n+\t\t   immediately and this requires a function context.  */\n \t\tif (!Materialize_Entity (gnat_entity)\n \t\t    && (!global_bindings_p ()\n \t\t\t|| (staticp (gnu_expr)\n@@ -812,21 +814,35 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t   object, we just make a \"bare\" pointer, and the renamed\n \t\t   entity is always accessed indirectly through it.  */\n \t\t{\n-\t\t  bool has_side_effects = TREE_SIDE_EFFECTS (gnu_expr);\n+\t\t  bool expr_has_side_effects = TREE_SIDE_EFFECTS (gnu_expr);\n+\n \t\t  inner_const_flag = TREE_READONLY (gnu_expr);\n \t\t  const_flag = true;\n \t\t  gnu_type = build_reference_type (gnu_type);\n \n-\t\t  /* If a previous attempt at unrestricted\n-\t\t     stabilization failed, there is no point trying\n-\t\t     again and we can reuse the result without\n-\t\t     attaching it to the pointer.  */\n+\t\t  /* If a previous attempt at unrestricted stabilization\n+\t\t     failed, there is no point trying again and we can reuse\n+\t\t     the result without attaching it to the pointer.  */\n \t\t  if (maybe_stable_expr)\n \t\t    ;\n \n \t\t  /* Otherwise, try to stabilize now, restricting to\n \t\t     lvalues only, and attach the expression to the pointer\n-\t\t     if the stabilization succeeds.  */\n+\t\t     if the stabilization succeeds.\n+\n+\t\t     Note that this might introduce SAVE_EXPRs and we don't\n+\t\t     check whether we're at the global level or not.  This is\n+\t\t     fine since we are building a pointer initializer and\n+\t\t     neither the pointer nor the initializing expression can\n+\t\t     be accessed before the pointer elaboration has taken\n+\t\t     place in a correct program.\n+\n+\t\t     SAVE_EXPRs will be evaluated at the right spots by either\n+\t\t     create_var_decl->expand_decl_init for the non-global case\n+\t\t     or build_unit_elab for the global case, and will be\n+\t\t     attached to the elaboration procedure by the RTL expander\n+\t\t     in the latter case.  We have no need to force an early\n+\t\t     evaluation here.  */\n \t\t  else\n \t\t    {\n \t\t      maybe_stable_expr\n@@ -842,15 +858,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t  gnu_expr\n \t\t    = build_unary_op (ADDR_EXPR, gnu_type, maybe_stable_expr);\n \n-\t\t  if (!global_bindings_p ())\n-\t\t    {\n-\t\t      /* If the original expression had side effects, put a\n-\t\t\t SAVE_EXPR around this whole thing.  */\n-\t\t      if (has_side_effects)\n-\t\t\tgnu_expr = save_expr (gnu_expr);\n-\n-\t\t      add_stmt (gnu_expr);\n-\t\t    }\n+\t\t  /* If the initial expression has side effects, we might\n+\t\t     still have an unstabilized version at this point (for\n+\t\t     instance if it involves a function call).  Wrap the\n+\t\t     result into a SAVE_EXPR now, in case it happens to be\n+\t\t     referenced several times.  */\n+\t\t  if (expr_has_side_effects && ! stabilized)\n+\t\t    gnu_expr = save_expr (gnu_expr);\n \n \t\t  gnu_size = NULL_TREE;\n \t\t  used_by_ref = true;\n@@ -1001,16 +1015,16 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t    gnu_alloc_type\n \t\t      = TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (gnu_alloc_type)));\n \n-\t\t    if (TREE_CODE (gnu_expr) == CONSTRUCTOR\n-\t\t\t&& VEC_length (constructor_elt,\n-\t\t\t\t       CONSTRUCTOR_ELTS (gnu_expr)) == 1)\n-\t\t      gnu_expr = 0;\n-\t\t    else\n-\t\t      gnu_expr\n-\t\t\t= build_component_ref\n-\t\t\t  (gnu_expr, NULL_TREE,\n-\t\t\t  TREE_CHAIN (TYPE_FIELDS (TREE_TYPE (gnu_expr))),\n-\t\t\t      false);\n+                   if (TREE_CODE (gnu_expr) == CONSTRUCTOR\n+\t\t       && 1 == VEC_length (constructor_elt,\n+\t\t\t\t\t    CONSTRUCTOR_ELTS (gnu_expr)))\n+                     gnu_expr = 0;\n+                   else\n+                     gnu_expr\n+                       = build_component_ref\n+                         (gnu_expr, NULL_TREE,\n+                          TREE_CHAIN (TYPE_FIELDS (TREE_TYPE (gnu_expr))),\n+\t\t\t  false);\n \t\t  }\n \n \t\tif (TREE_CODE (TYPE_SIZE_UNIT (gnu_alloc_type)) == INTEGER_CST\n@@ -5676,27 +5690,22 @@ components_to_record (tree gnu_record_type, Node_Id component_list,\n \n   /* If we have any items in our rep'ed field list, it is not the case that all\n      the fields in the record have rep clauses, and P_REP_LIST is nonzero,\n-     set it and ignore the items.  Otherwise, sort the fields by bit position\n-     and put them into their own record if we have any fields without\n-     rep clauses. */\n+     set it and ignore the items.  */\n   if (gnu_our_rep_list && p_gnu_rep_list && !all_rep)\n     *p_gnu_rep_list = chainon (*p_gnu_rep_list, gnu_our_rep_list);\n   else if (gnu_our_rep_list)\n     {\n+      /* Otherwise, sort the fields by bit position and put them into their\n+\t own record if we have any fields without rep clauses. */\n       tree gnu_rep_type\n \t= (gnu_field_list ? make_node (RECORD_TYPE) : gnu_record_type);\n       int len = list_length (gnu_our_rep_list);\n       tree *gnu_arr = (tree *) alloca (sizeof (tree) * len);\n       int i;\n \n-      /* Set/abuse DECL_FCONTEXT to increasing integers so we have a\n-\t stable sort.  */\n       for (i = 0, gnu_field = gnu_our_rep_list; gnu_field;\n \t   gnu_field = TREE_CHAIN (gnu_field), i++)\n-\t{\n-\t  gnu_arr[i] = gnu_field;\n-\t  DECL_FCONTEXT (gnu_field) = size_int (i);\n-\t}\n+\tgnu_arr[i] = gnu_field;\n \n       qsort (gnu_arr, len, sizeof (tree), compare_field_bitpos);\n \n@@ -5708,7 +5717,6 @@ components_to_record (tree gnu_record_type, Node_Id component_list,\n \t  TREE_CHAIN (gnu_arr[i]) = gnu_our_rep_list;\n \t  gnu_our_rep_list = gnu_arr[i];\n \t  DECL_CONTEXT (gnu_arr[i]) = gnu_rep_type;\n-\t  DECL_FCONTEXT (gnu_arr[i]) = NULL_TREE;\n \t}\n \n       if (gnu_field_list)\n@@ -5734,7 +5742,8 @@ components_to_record (tree gnu_record_type, Node_Id component_list,\n }\n \f\n /* Called via qsort from the above.  Returns -1, 1, depending on the\n-   bit positions and ordinals of the two fields.  */\n+   bit positions and ordinals of the two fields.  Use DECL_UID to ensure\n+   a stable sort.  */\n \n static int\n compare_field_bitpos (const PTR rt1, const PTR rt2)\n@@ -5743,9 +5752,7 @@ compare_field_bitpos (const PTR rt1, const PTR rt2)\n   tree *t2 = (tree *) rt2;\n \n   if (tree_int_cst_equal (bit_position (*t1), bit_position (*t2)))\n-    return\n-      (tree_int_cst_lt (DECL_FCONTEXT (*t1), DECL_FCONTEXT (*t2))\n-       ? -1 : 1);\n+    return DECL_UID (*t1) < DECL_UID (*t2) ? -1 : 1;\n   else if (tree_int_cst_lt (bit_position (*t1), bit_position (*t2)))\n     return -1;\n   else"}]}