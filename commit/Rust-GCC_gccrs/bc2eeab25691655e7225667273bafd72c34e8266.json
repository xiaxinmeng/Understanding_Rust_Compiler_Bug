{"sha": "bc2eeab25691655e7225667273bafd72c34e8266", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmMyZWVhYjI1NjkxNjU1ZTcyMjU2NjcyNzNiYWZkNzJjMzRlODI2Ng==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-11-05T06:57:43Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-11-05T06:57:43Z"}, "message": "(expand_inline_function): Handle CONCAT as rtl for parm.\n\n(copy_rtx_and_substitute): For subreg, handle case where the reg\ninside turns into a CONCAT.\n\nFrom-SVN: r6006", "tree": {"sha": "278f9b0531ff1880e0fb41f6d8d5cee811054b46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/278f9b0531ff1880e0fb41f6d8d5cee811054b46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc2eeab25691655e7225667273bafd72c34e8266", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc2eeab25691655e7225667273bafd72c34e8266", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc2eeab25691655e7225667273bafd72c34e8266", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc2eeab25691655e7225667273bafd72c34e8266/comments", "author": null, "committer": null, "parents": [{"sha": "4badc528d3c8d255b585660d58282ccbebb8b3ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4badc528d3c8d255b585660d58282ccbebb8b3ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4badc528d3c8d255b585660d58282ccbebb8b3ec"}], "stats": {"total": 53, "additions": 53, "deletions": 0}, "files": [{"sha": "b21bd260f01d30f4d31a790fbecbaca0c0f17963", "filename": "gcc/integrate.c", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc2eeab25691655e7225667273bafd72c34e8266/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc2eeab25691655e7225667273bafd72c34e8266/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=bc2eeab25691655e7225667273bafd72c34e8266", "patch": "@@ -1422,6 +1422,57 @@ expand_inline_function (fndecl, parms, target, ignore, type, structure_value_add\n \t    }\n \t  map->reg_map[REGNO (loc)] = copy;\n \t}\n+      else if (GET_CODE (loc) == CONCAT)\n+\t{\n+\t  /* This is the good case where the parameter is in a\n+\t     pair of separate pseudos.\n+\t     If it is read-only and our argument is a constant, set up the\n+\t     constant equivalence.\n+\n+\t     If LOC is REG_USERVAR_P, the usual case, COPY must also have\n+\t     that flag set if it is a register.\n+\n+\t     Also, don't allow hard registers here; they might not be valid\n+\t     when substituted into insns. */\n+\t  rtx locreal = gen_realpart (GET_MODE (XEXP (loc, 0)), loc);\n+\t  rtx locimag = gen_imagpart (GET_MODE (XEXP (loc, 0)), loc);\n+\t  rtx copyreal = gen_realpart (GET_MODE (locreal), copy);\n+\t  rtx copyimag = gen_imagpart (GET_MODE (locimag), copy);\n+\n+\t  if ((GET_CODE (copyreal) != REG && GET_CODE (copyreal) != SUBREG)\n+\t      || (GET_CODE (copyreal) == REG && REG_USERVAR_P (locreal)\n+\t\t  && ! REG_USERVAR_P (copyreal))\n+\t      || (GET_CODE (copyreal) == REG\n+\t\t  && REGNO (copyreal) < FIRST_PSEUDO_REGISTER))\n+\t    {\n+\t      temp = copy_to_mode_reg (GET_MODE (locreal), copyreal);\n+\t      REG_USERVAR_P (temp) = REG_USERVAR_P (locreal);\n+\t      if (CONSTANT_P (copyreal) || FIXED_BASE_PLUS_P (copyreal))\n+\t\t{\n+\t\t  map->const_equiv_map[REGNO (temp)] = copyreal;\n+\t\t  map->const_age_map[REGNO (temp)] = CONST_AGE_PARM;\n+\t\t}\n+\t      copyreal = temp;\n+\t    }\n+\t  map->reg_map[REGNO (locreal)] = copyreal;\n+\n+\t  if ((GET_CODE (copyimag) != REG && GET_CODE (copyimag) != SUBREG)\n+\t      || (GET_CODE (copyimag) == REG && REG_USERVAR_P (locimag)\n+\t\t  && ! REG_USERVAR_P (copyimag))\n+\t      || (GET_CODE (copyimag) == REG\n+\t\t  && REGNO (copyimag) < FIRST_PSEUDO_REGISTER))\n+\t    {\n+\t      temp = copy_to_mode_reg (GET_MODE (locimag), copyimag);\n+\t      REG_USERVAR_P (temp) = REG_USERVAR_P (locimag);\n+\t      if (CONSTANT_P (copyimag) || FIXED_BASE_PLUS_P (copyimag))\n+\t\t{\n+\t\t  map->const_equiv_map[REGNO (temp)] = copyimag;\n+\t\t  map->const_age_map[REGNO (temp)] = CONST_AGE_PARM;\n+\t\t}\n+\t      copyimag = temp;\n+\t    }\n+\t  map->reg_map[REGNO (locimag)] = copyimag;\n+\t}\n       else\n \tabort ();\n     }\n@@ -2028,6 +2079,8 @@ copy_rtx_and_substitute (orig, map)\n       if (GET_CODE (copy) == SUBREG)\n \treturn gen_rtx (SUBREG, GET_MODE (orig), SUBREG_REG (copy),\n \t\t\tSUBREG_WORD (orig) + SUBREG_WORD (copy));\n+      else if (GET_CODE (copy) == CONCAT)\n+\treturn (subreg_lowpart_p (orig) ? XEXP (copy, 0) : XEXP (copy, 1));\n       else\n \treturn gen_rtx (SUBREG, GET_MODE (orig), copy,\n \t\t\tSUBREG_WORD (orig));"}]}