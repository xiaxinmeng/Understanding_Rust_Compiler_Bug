{"sha": "8de73453a42758af02bb23ed58f4b1e78ad11bc7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRlNzM0NTNhNDI3NThhZjAyYmIyM2VkNThmNGIxZTc4YWQxMWJjNw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2016-05-02T09:39:38Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2016-05-02T09:39:38Z"}, "message": "Support << and >> for offset_int and widest_int\n\nFollowing on from the comparison patch, I think it makes sense to\nsupport << and >> for offset_int (int128_t) and widest_int (intNNN_t),\nwith >> being arithmetic shift.  It doesn't make sense to use\nlogical right shift on a potentially negative offset_int, since\nthe precision of 128 bits has no meaning on the target.\n\nTested on x86_64-linux-gnu and aarch64-linux-gnu.\n\ngcc/\n\t* wide-int.h: Update offset_int and widest_int documentation.\n\t(WI_SIGNED_SHIFT_RESULT): New macro.\n\t(wi::binary_shift): Define signed_shift_result_type for\n\tshifts on offset_int- and widest_int-like types.\n\t(generic_wide_int): Support <<= and >>= if << and >> are supported.\n\t* tree.h (int_bit_position): Use shift operators instead of wi::\n\t shifts.\n\t* alias.c (adjust_offset_for_component_ref): Likewise.\n\t* expr.c (get_inner_reference): Likewise.\n\t* fold-const.c (fold_comparison): Likewise.\n\t* gimple-fold.c (fold_nonarray_ctor_reference): Likewise.\n\t* gimple-ssa-strength-reduction.c (restructure_reference): Likewise.\n\t* tree-dfa.c (get_ref_base_and_extent): Likewise.\n\t* tree-ssa-alias.c (indirect_ref_may_alias_decl_p): Likewise.\n\t(stmt_kills_ref_p): Likewise.\n\t* tree-ssa-ccp.c (bit_value_binop_1): Likewise.\n\t* tree-ssa-math-opts.c (find_bswap_or_nop_load): Likewise.\n\t* tree-ssa-sccvn.c (copy_reference_ops_from_ref): Likewise.\n\t(ao_ref_init_from_vn_reference): Likewise.\n\ngcc/cp/\n\t* init.c (build_new_1): Use shift operators instead of wi:: shifts.\n\nFrom-SVN: r235720", "tree": {"sha": "ea2f8d60c73117cebcd97dfbc56bb80d7c4ee632", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea2f8d60c73117cebcd97dfbc56bb80d7c4ee632"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8de73453a42758af02bb23ed58f4b1e78ad11bc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8de73453a42758af02bb23ed58f4b1e78ad11bc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8de73453a42758af02bb23ed58f4b1e78ad11bc7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8de73453a42758af02bb23ed58f4b1e78ad11bc7/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "032c80e999eac4288ff1b0f752e15c8e7c5cdf51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/032c80e999eac4288ff1b0f752e15c8e7c5cdf51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/032c80e999eac4288ff1b0f752e15c8e7c5cdf51"}], "stats": {"total": 134, "additions": 93, "deletions": 41}, "files": [{"sha": "d83a16a97ea6be3db166b9795b0f4dd022878771", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8de73453a42758af02bb23ed58f4b1e78ad11bc7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8de73453a42758af02bb23ed58f4b1e78ad11bc7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8de73453a42758af02bb23ed58f4b1e78ad11bc7", "patch": "@@ -1,3 +1,25 @@\n+2016-05-02  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* wide-int.h: Update offset_int and widest_int documentation.\n+\t(WI_SIGNED_SHIFT_RESULT): New macro.\n+\t(wi::binary_shift): Define signed_shift_result_type for\n+\tshifts on offset_int- and widest_int-like types.\n+\t(generic_wide_int): Support <<= and >>= if << and >> are supported.\n+\t* tree.h (int_bit_position): Use shift operators instead of wi::\n+\t shifts.\n+\t* alias.c (adjust_offset_for_component_ref): Likewise.\n+\t* expr.c (get_inner_reference): Likewise.\n+\t* fold-const.c (fold_comparison): Likewise.\n+\t* gimple-fold.c (fold_nonarray_ctor_reference): Likewise.\n+\t* gimple-ssa-strength-reduction.c (restructure_reference): Likewise.\n+\t* tree-dfa.c (get_ref_base_and_extent): Likewise.\n+\t* tree-ssa-alias.c (indirect_ref_may_alias_decl_p): Likewise.\n+\t(stmt_kills_ref_p): Likewise.\n+\t* tree-ssa-ccp.c (bit_value_binop_1): Likewise.\n+\t* tree-ssa-math-opts.c (find_bswap_or_nop_load): Likewise.\n+\t* tree-ssa-sccvn.c (copy_reference_ops_from_ref): Likewise.\n+\t(ao_ref_init_from_vn_reference): Likewise.\n+\n 2016-05-02  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* wide-int.h: Update offset_int and widest_int documentation."}, {"sha": "451f8f3dee58b1e5ad896ff6261280ede0688d5a", "filename": "gcc/alias.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8de73453a42758af02bb23ed58f4b1e78ad11bc7/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8de73453a42758af02bb23ed58f4b1e78ad11bc7/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=8de73453a42758af02bb23ed58f4b1e78ad11bc7", "patch": "@@ -2651,8 +2651,8 @@ adjust_offset_for_component_ref (tree x, bool *known_p,\n \n       offset_int woffset\n \t= (wi::to_offset (xoffset)\n-\t   + wi::lrshift (wi::to_offset (DECL_FIELD_BIT_OFFSET (field)),\n-\t\t\t  LOG2_BITS_PER_UNIT));\n+\t   + (wi::to_offset (DECL_FIELD_BIT_OFFSET (field))\n+\t      >> LOG2_BITS_PER_UNIT));\n       if (!wi::fits_uhwi_p (woffset))\n \t{\n \t  *known_p = false;"}, {"sha": "c40efcfc2cf9da57eb790bc70119ec7b3a56461d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8de73453a42758af02bb23ed58f4b1e78ad11bc7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8de73453a42758af02bb23ed58f4b1e78ad11bc7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8de73453a42758af02bb23ed58f4b1e78ad11bc7", "patch": "@@ -1,3 +1,7 @@\n+2016-05-02  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* init.c (build_new_1): Use shift operators instead of wi:: shifts.\n+\n 2016-05-02  Richard Biener  <rguenther@suse.de>\n \n \t* decl.c (grokdeclarator): Properly insert a DECL_EXPR for"}, {"sha": "681ca12c62ababf198346c92a6cee6ede851a550", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8de73453a42758af02bb23ed58f4b1e78ad11bc7/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8de73453a42758af02bb23ed58f4b1e78ad11bc7/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=8de73453a42758af02bb23ed58f4b1e78ad11bc7", "patch": "@@ -2812,8 +2812,7 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n \n \t  unsigned shift = (max_outer_nelts.get_precision ()) - 7\n \t    - wi::clz (max_outer_nelts);\n-\t  max_outer_nelts = wi::lshift (wi::lrshift (max_outer_nelts, shift),\n-\t\t\t\t        shift);\n+\t  max_outer_nelts = (max_outer_nelts >> shift) << shift;\n \n           outer_nelts_check = fold_build2 (LE_EXPR, boolean_type_node,\n \t\t\t\t\t   outer_nelts,"}, {"sha": "8870a0c9872747888fa5639c369e81ffc9b89cb5", "filename": "gcc/expr.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8de73453a42758af02bb23ed58f4b1e78ad11bc7/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8de73453a42758af02bb23ed58f4b1e78ad11bc7/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=8de73453a42758af02bb23ed58f4b1e78ad11bc7", "patch": "@@ -6989,7 +6989,7 @@ get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n \t      if (!integer_zerop (off))\n \t\t{\n \t\t  offset_int boff, coff = mem_ref_offset (exp);\n-\t\t  boff = wi::lshift (coff, LOG2_BITS_PER_UNIT);\n+\t\t  boff = coff << LOG2_BITS_PER_UNIT;\n \t\t  bit_offset += boff;\n \t\t}\n \t      exp = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n@@ -7015,7 +7015,7 @@ get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n     {\n       offset_int tem = wi::sext (wi::to_offset (offset),\n \t\t\t\t TYPE_PRECISION (sizetype));\n-      tem = wi::lshift (tem, LOG2_BITS_PER_UNIT);\n+      tem <<= LOG2_BITS_PER_UNIT;\n       tem += bit_offset;\n       if (wi::fits_shwi_p (tem))\n \t{\n@@ -7035,7 +7035,7 @@ get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n \t  /* TEM is the bitpos rounded to BITS_PER_UNIT towards -Inf.\n \t     Subtract it to BIT_OFFSET and add it (scaled) to OFFSET.  */\n \t  bit_offset -= tem;\n-\t  tem = wi::arshift (tem, LOG2_BITS_PER_UNIT);\n+\t  tem >>= LOG2_BITS_PER_UNIT;\n \t  offset = size_binop (PLUS_EXPR, offset,\n \t\t\t       wide_int_to_tree (sizetype, tem));\n \t}"}, {"sha": "8ece0f80306ffd69ab7cc98e5b4179aa92efe1b2", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8de73453a42758af02bb23ed58f4b1e78ad11bc7/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8de73453a42758af02bb23ed58f4b1e78ad11bc7/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=8de73453a42758af02bb23ed58f4b1e78ad11bc7", "patch": "@@ -8521,7 +8521,7 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \t    {\n \t      offset_int tem = wi::sext (wi::to_offset (offset0),\n \t\t\t\t\t TYPE_PRECISION (sizetype));\n-\t      tem = wi::lshift (tem, LOG2_BITS_PER_UNIT);\n+\t      tem <<= LOG2_BITS_PER_UNIT;\n \t      tem += bitpos0;\n \t      if (wi::fits_shwi_p (tem))\n \t\t{\n@@ -8568,7 +8568,7 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \t    {\n \t      offset_int tem = wi::sext (wi::to_offset (offset1),\n \t\t\t\t\t TYPE_PRECISION (sizetype));\n-\t      tem = wi::lshift (tem, LOG2_BITS_PER_UNIT);\n+\t      tem <<= LOG2_BITS_PER_UNIT;\n \t      tem += bitpos1;\n \t      if (wi::fits_shwi_p (tem))\n \t\t{"}, {"sha": "5607598210b15197b49f48a1e3624560f1c33dac", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8de73453a42758af02bb23ed58f4b1e78ad11bc7/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8de73453a42758af02bb23ed58f4b1e78ad11bc7/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=8de73453a42758af02bb23ed58f4b1e78ad11bc7", "patch": "@@ -5435,8 +5435,7 @@ fold_nonarray_ctor_reference (tree type, tree ctor,\n \n       /* Compute bit offset of the field.  */\n       bitoffset = (wi::to_offset (field_offset)\n-\t\t   + wi::lshift (wi::to_offset (byte_offset),\n-\t\t\t\t LOG2_BITS_PER_UNIT));\n+\t\t   + (wi::to_offset (byte_offset) << LOG2_BITS_PER_UNIT));\n       /* Compute bit offset where the field ends.  */\n       if (field_size != NULL_TREE)\n \tbitoffset_end = bitoffset + wi::to_offset (field_size);"}, {"sha": "0824f17eb00788d14aae0ac7979621e1e1e96675", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8de73453a42758af02bb23ed58f4b1e78ad11bc7/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8de73453a42758af02bb23ed58f4b1e78ad11bc7/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=8de73453a42758af02bb23ed58f4b1e78ad11bc7", "patch": "@@ -951,7 +951,7 @@ restructure_reference (tree *pbase, tree *poffset, widest_int *pindex,\n       c2 = 0;\n     }\n \n-  c4 = wi::lrshift (index, LOG2_BITS_PER_UNIT);\n+  c4 = index >> LOG2_BITS_PER_UNIT;\n   c5 = backtrace_base_for_ref (&t2);\n \n   *pbase = t1;"}, {"sha": "f6986c1f0ca7849f3e4d61d63ba204af01e6b83d", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8de73453a42758af02bb23ed58f4b1e78ad11bc7/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8de73453a42758af02bb23ed58f4b1e78ad11bc7/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=8de73453a42758af02bb23ed58f4b1e78ad11bc7", "patch": "@@ -424,8 +424,8 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \n \t    if (this_offset && TREE_CODE (this_offset) == INTEGER_CST)\n \t      {\n-\t\toffset_int woffset = wi::lshift (wi::to_offset (this_offset),\n-\t\t\t\t\t\t LOG2_BITS_PER_UNIT);\n+\t\toffset_int woffset = (wi::to_offset (this_offset)\n+\t\t\t\t      << LOG2_BITS_PER_UNIT);\n \t\twoffset += wi::to_offset (DECL_FIELD_BIT_OFFSET (field));\n \t\tbit_offset += woffset;\n \n@@ -453,7 +453,7 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t\t\t  {\n \t\t\t    offset_int tem = (wi::to_offset (ssize)\n \t\t\t\t\t      - wi::to_offset (fsize));\n-\t\t\t    tem = wi::lshift (tem, LOG2_BITS_PER_UNIT);\n+\t\t\t    tem <<= LOG2_BITS_PER_UNIT;\n \t\t\t    tem -= woffset;\n \t\t\t    maxsize += tem;\n \t\t\t  }\n@@ -493,7 +493,7 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t\t  = wi::sext (wi::to_offset (index) - wi::to_offset (low_bound),\n \t\t\t      TYPE_PRECISION (TREE_TYPE (index)));\n \t\twoffset *= wi::to_offset (unit_size);\n-\t\twoffset = wi::lshift (woffset, LOG2_BITS_PER_UNIT);\n+\t\twoffset <<= LOG2_BITS_PER_UNIT;\n \t\tbit_offset += woffset;\n \n \t\t/* An array ref with a constant index up in the structure\n@@ -570,7 +570,7 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t      else\n \t\t{\n \t\t  offset_int off = mem_ref_offset (exp);\n-\t\t  off = wi::lshift (off, LOG2_BITS_PER_UNIT);\n+\t\t  off <<= LOG2_BITS_PER_UNIT;\n \t\t  off += bit_offset;\n \t\t  if (wi::fits_shwi_p (off))\n \t\t    {"}, {"sha": "58920e0d5b4d113133094cbac22bd2767ef4b30b", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8de73453a42758af02bb23ed58f4b1e78ad11bc7/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8de73453a42758af02bb23ed58f4b1e78ad11bc7/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=8de73453a42758af02bb23ed58f4b1e78ad11bc7", "patch": "@@ -1101,7 +1101,7 @@ indirect_ref_may_alias_decl_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n   /* The offset embedded in MEM_REFs can be negative.  Bias them\n      so that the resulting offset adjustment is positive.  */\n   offset_int moff = mem_ref_offset (base1);\n-  moff = wi::lshift (moff, LOG2_BITS_PER_UNIT);\n+  moff <<= LOG2_BITS_PER_UNIT;\n   if (wi::neg_p (moff))\n     offset2p += (-moff).to_short_addr ();\n   else\n@@ -1173,7 +1173,7 @@ indirect_ref_may_alias_decl_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n       || TREE_CODE (dbase2) == TARGET_MEM_REF)\n     {\n       offset_int moff = mem_ref_offset (dbase2);\n-      moff = wi::lshift (moff, LOG2_BITS_PER_UNIT);\n+      moff <<= LOG2_BITS_PER_UNIT;\n       if (wi::neg_p (moff))\n \tdoffset1 -= (-moff).to_short_addr ();\n       else\n@@ -1271,13 +1271,13 @@ indirect_refs_may_alias_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n       /* The offset embedded in MEM_REFs can be negative.  Bias them\n \t so that the resulting offset adjustment is positive.  */\n       moff = mem_ref_offset (base1);\n-      moff = wi::lshift (moff, LOG2_BITS_PER_UNIT);\n+      moff <<= LOG2_BITS_PER_UNIT;\n       if (wi::neg_p (moff))\n \toffset2 += (-moff).to_short_addr ();\n       else\n \toffset1 += moff.to_shwi ();\n       moff = mem_ref_offset (base2);\n-      moff = wi::lshift (moff, LOG2_BITS_PER_UNIT);\n+      moff <<= LOG2_BITS_PER_UNIT;\n       if (wi::neg_p (moff))\n \toffset1 += (-moff).to_short_addr ();\n       else\n@@ -2358,10 +2358,10 @@ stmt_kills_ref_p (gimple *stmt, ao_ref *ref)\n \t\t\t\t       TREE_OPERAND (ref->base, 1)))\n \t\t{\n \t\t  offset_int off1 = mem_ref_offset (base);\n-\t\t  off1 = wi::lshift (off1, LOG2_BITS_PER_UNIT);\n+\t\t  off1 <<= LOG2_BITS_PER_UNIT;\n \t\t  off1 += offset;\n \t\t  offset_int off2 = mem_ref_offset (ref->base);\n-\t\t  off2 = wi::lshift (off2, LOG2_BITS_PER_UNIT);\n+\t\t  off2 <<= LOG2_BITS_PER_UNIT;\n \t\t  off2 += ref_offset;\n \t\t  if (wi::fits_shwi_p (off1) && wi::fits_shwi_p (off2))\n \t\t    {\n@@ -2432,18 +2432,15 @@ stmt_kills_ref_p (gimple *stmt, ao_ref *ref)\n \t\t  if (TREE_CODE (rbase) != MEM_REF)\n \t\t    return false;\n \t\t  // Compare pointers.\n-\t\t  offset += wi::lshift (mem_ref_offset (base),\n-\t\t\t\t\tLOG2_BITS_PER_UNIT);\n-\t\t  roffset += wi::lshift (mem_ref_offset (rbase),\n-\t\t\t\t\t LOG2_BITS_PER_UNIT);\n+\t\t  offset += mem_ref_offset (base) << LOG2_BITS_PER_UNIT;\n+\t\t  roffset += mem_ref_offset (rbase) << LOG2_BITS_PER_UNIT;\n \t\t  base = TREE_OPERAND (base, 0);\n \t\t  rbase = TREE_OPERAND (rbase, 0);\n \t\t}\n \t      if (base == rbase\n \t\t  && offset <= roffset\n \t\t  && (roffset + ref->max_size\n-\t\t      <= offset + wi::lshift (wi::to_offset (len),\n-\t\t\t\t\t      LOG2_BITS_PER_UNIT)))\n+\t\t      <= offset + (wi::to_offset (len) << LOG2_BITS_PER_UNIT)))\n \t\treturn true;\n \t      break;\n \t    }"}, {"sha": "baae03f80425bcecc7b19ad33077a0644feb5194", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8de73453a42758af02bb23ed58f4b1e78ad11bc7/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8de73453a42758af02bb23ed58f4b1e78ad11bc7/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=8de73453a42758af02bb23ed58f4b1e78ad11bc7", "patch": "@@ -1372,8 +1372,8 @@ bit_value_binop_1 (enum tree_code code, tree type,\n \t\t}\n \t      else\n \t\t{\n-\t\t  *mask = wi::ext (wi::lshift (r1mask, shift), width, sgn);\n-\t\t  *val = wi::ext (wi::lshift (r1val, shift), width, sgn);\n+\t\t  *mask = wi::ext (r1mask << shift, width, sgn);\n+\t\t  *val = wi::ext (r1val << shift, width, sgn);\n \t\t}\n \t    }\n \t}"}, {"sha": "3fcf24c4f9c20878c739cc4c92b63ccc1d4bc320", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8de73453a42758af02bb23ed58f4b1e78ad11bc7/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8de73453a42758af02bb23ed58f4b1e78ad11bc7/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=8de73453a42758af02bb23ed58f4b1e78ad11bc7", "patch": "@@ -2104,7 +2104,7 @@ find_bswap_or_nop_load (gimple *stmt, tree ref, struct symbolic_number *n)\n       if (!integer_zerop (off))\n \t{\n \t  offset_int boff, coff = mem_ref_offset (base_addr);\n-\t  boff = wi::lshift (coff, LOG2_BITS_PER_UNIT);\n+\t  boff = coff << LOG2_BITS_PER_UNIT;\n \t  bit_offset += boff;\n \t}\n \n@@ -2118,7 +2118,7 @@ find_bswap_or_nop_load (gimple *stmt, tree ref, struct symbolic_number *n)\n \t  /* TEM is the bitpos rounded to BITS_PER_UNIT towards -Inf.\n \t     Subtract it to BIT_OFFSET and add it (scaled) to OFFSET.  */\n \t  bit_offset -= tem;\n-\t  tem = wi::arshift (tem, LOG2_BITS_PER_UNIT);\n+\t  tem >>= LOG2_BITS_PER_UNIT;\n \t  if (offset)\n \t    offset = size_binop (PLUS_EXPR, offset,\n \t\t\t\t    wide_int_to_tree (sizetype, tem));"}, {"sha": "2dbe4084420f153eafefde6048c61f612e17dfde", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8de73453a42758af02bb23ed58f4b1e78ad11bc7/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8de73453a42758af02bb23ed58f4b1e78ad11bc7/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=8de73453a42758af02bb23ed58f4b1e78ad11bc7", "patch": "@@ -788,8 +788,7 @@ copy_reference_ops_from_ref (tree ref, vec<vn_reference_op_s> *result)\n \t\t  {\n \t\t    offset_int off\n \t\t      = (wi::to_offset (this_offset)\n-\t\t\t + wi::lrshift (wi::to_offset (bit_offset),\n-\t\t\t\t\tLOG2_BITS_PER_UNIT));\n+\t\t\t + (wi::to_offset (bit_offset) >> LOG2_BITS_PER_UNIT));\n \t\t    if (wi::fits_shwi_p (off)\n \t\t\t/* Probibit value-numbering zero offset components\n \t\t\t   of addresses the same before the pass folding\n@@ -999,8 +998,8 @@ ao_ref_init_from_vn_reference (ao_ref *ref,\n \t      max_size = -1;\n \t    else\n \t      {\n-\t\toffset_int woffset = wi::lshift (wi::to_offset (this_offset),\n-\t\t\t\t\t\t LOG2_BITS_PER_UNIT);\n+\t\toffset_int woffset = (wi::to_offset (this_offset)\n+\t\t\t\t      << LOG2_BITS_PER_UNIT);\n \t\twoffset += wi::to_offset (DECL_FIELD_BIT_OFFSET (field));\n \t\toffset += woffset;\n \t      }\n@@ -1020,7 +1019,7 @@ ao_ref_init_from_vn_reference (ao_ref *ref,\n \t\t= wi::sext (wi::to_offset (op->op0) - wi::to_offset (op->op1),\n \t\t\t    TYPE_PRECISION (TREE_TYPE (op->op0)));\n \t      woffset *= wi::to_offset (op->op2);\n-\t      woffset = wi::lshift (woffset, LOG2_BITS_PER_UNIT);\n+\t      woffset <<= LOG2_BITS_PER_UNIT;\n \t      offset += woffset;\n \t    }\n \t  break;"}, {"sha": "024cf3d0a5399ad018271d0db3eebf14bba39fda", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8de73453a42758af02bb23ed58f4b1e78ad11bc7/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8de73453a42758af02bb23ed58f4b1e78ad11bc7/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=8de73453a42758af02bb23ed58f4b1e78ad11bc7", "patch": "@@ -5375,7 +5375,7 @@ extern GTY(()) struct int_n_trees_t int_n_trees[NUM_INT_N_ENTS];\n inline HOST_WIDE_INT\n int_bit_position (const_tree field)\n { \n-  return (wi::lshift (wi::to_offset (DECL_FIELD_OFFSET (field)), BITS_PER_UNIT_LOG)\n+  return ((wi::to_offset (DECL_FIELD_OFFSET (field)) << BITS_PER_UNIT_LOG)\n \t  + wi::to_offset (DECL_FIELD_BIT_OFFSET (field))).to_shwi ();\n }\n "}, {"sha": "7dde74f532f6e9dd5d6e18993cc5c6a9e840a026", "filename": "gcc/wide-int.h", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8de73453a42758af02bb23ed58f4b1e78ad11bc7/gcc%2Fwide-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8de73453a42758af02bb23ed58f4b1e78ad11bc7/gcc%2Fwide-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int.h?ref=8de73453a42758af02bb23ed58f4b1e78ad11bc7", "patch": "@@ -68,6 +68,8 @@ along with GCC; see the file COPYING3.  If not see\n      Since the values are logically signed, there is no need to\n      distinguish between signed and unsigned operations.  Sign-sensitive\n      comparison operators <, <=, > and >= are therefore supported.\n+     Shift operators << and >> are also supported, with >> being\n+     an _arithmetic_ right shift.\n \n      [ Note that, even though offset_int is effectively int128_t,\n        it can still be useful to use unsigned comparisons like\n@@ -82,7 +84,8 @@ along with GCC; see the file COPYING3.  If not see\n \n      Like offset_int, widest_int is wider than all the values that\n      it needs to represent, so the integers are logically signed.\n-     Sign-sensitive comparison operators <, <=, > and >= are supported.\n+     Sign-sensitive comparison operators <, <=, > and >= are supported,\n+     as are << and >>.\n \n      There are several places in the GCC where this should/must be used:\n \n@@ -259,6 +262,11 @@ along with GCC; see the file COPYING3.  If not see\n #define WI_BINARY_RESULT(T1, T2) \\\n   typename wi::binary_traits <T1, T2>::result_type\n \n+/* The type of result produced by T1 << T2.  Leads to substitution failure\n+   if the operation isn't supported.  Defined purely for brevity.  */\n+#define WI_SIGNED_SHIFT_RESULT(T1, T2) \\\n+  typename wi::binary_traits <T1, T2>::signed_shift_result_type\n+\n /* The type of result produced by a signed binary predicate on types T1 and T2.\n    This is bool if signed comparisons make sense for T1 and T2 and leads to\n    substitution failure otherwise.  */\n@@ -405,6 +413,7 @@ namespace wi\n        so as not to confuse gengtype.  */\n     typedef generic_wide_int < fixed_wide_int_storage\n \t\t\t       <int_traits <T1>::precision> > result_type;\n+    typedef result_type signed_shift_result_type;\n     typedef bool signed_predicate_result;\n   };\n \n@@ -416,6 +425,7 @@ namespace wi\n     STATIC_ASSERT (int_traits <T1>::precision == int_traits <T2>::precision);\n     typedef generic_wide_int < fixed_wide_int_storage\n \t\t\t       <int_traits <T1>::precision> > result_type;\n+    typedef result_type signed_shift_result_type;\n     typedef bool signed_predicate_result;\n   };\n \n@@ -681,6 +691,11 @@ class GTY(()) generic_wide_int : public storage\n   template <typename T> \\\n     generic_wide_int &OP (const T &c) { return (*this = wi::F (*this, c)); }\n \n+/* Restrict these to cases where the shift operator is defined.  */\n+#define SHIFT_ASSIGNMENT_OPERATOR(OP, OP2) \\\n+  template <typename T> \\\n+    generic_wide_int &OP (const T &c) { return (*this = *this OP2 c); }\n+\n #define INCDEC_OPERATOR(OP, DELTA) \\\n   generic_wide_int &OP () { *this += DELTA; return *this; }\n \n@@ -702,12 +717,15 @@ class GTY(()) generic_wide_int : public storage\n   ASSIGNMENT_OPERATOR (operator +=, add)\n   ASSIGNMENT_OPERATOR (operator -=, sub)\n   ASSIGNMENT_OPERATOR (operator *=, mul)\n+  SHIFT_ASSIGNMENT_OPERATOR (operator <<=, <<)\n+  SHIFT_ASSIGNMENT_OPERATOR (operator >>=, >>)\n   INCDEC_OPERATOR (operator ++, 1)\n   INCDEC_OPERATOR (operator --, -1)\n \n #undef BINARY_PREDICATE\n #undef UNARY_OPERATOR\n #undef BINARY_OPERATOR\n+#undef SHIFT_ASSIGNMENT_OPERATOR\n #undef ASSIGNMENT_OPERATOR\n #undef INCDEC_OPERATOR\n \n@@ -857,7 +875,7 @@ generic_wide_int <storage>::elt (unsigned int i) const\n \n template <typename storage>\n template <typename T>\n-generic_wide_int <storage> &\n+inline generic_wide_int <storage> &\n generic_wide_int <storage>::operator = (const T &x)\n {\n   storage::operator = (x);\n@@ -3078,6 +3096,20 @@ SIGNED_BINARY_PREDICATE (operator >=, ges_p)\n \n #undef SIGNED_BINARY_PREDICATE\n \n+template <typename T1, typename T2>\n+inline WI_SIGNED_SHIFT_RESULT (T1, T2)\n+operator << (const T1 &x, const T2 &y)\n+{\n+  return wi::lshift (x, y);\n+}\n+\n+template <typename T1, typename T2>\n+inline WI_SIGNED_SHIFT_RESULT (T1, T2)\n+operator >> (const T1 &x, const T2 &y)\n+{\n+  return wi::arshift (x, y);\n+}\n+\n template<typename T>\n void\n gt_ggc_mx (generic_wide_int <T> *)"}]}