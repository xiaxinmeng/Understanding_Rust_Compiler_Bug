{"sha": "7798db981511d7cf676820843223dec460045d29", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc5OGRiOTgxNTExZDdjZjY3NjgyMDg0MzIyM2RlYzQ2MDA0NWQyOQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-01-07T04:34:30Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-01-07T04:34:30Z"}, "message": "h8300.c (final_prescan_insn): Constify uid.\n\n\t* config/h8300/h8300.c (final_prescan_insn): Constify uid.\n\t(output_logical_op): Constify intval and det.\n\t(compute_logical_length): Likewise.\n\t(compute_logical_cc): Likewise.\n\t(output_a_shift): Constify mask.\n\t(h8300_encode_label): Constify len.\n\nFrom-SVN: r60979", "tree": {"sha": "e239e5d66afe32263a1236e1be22445570cab3e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e239e5d66afe32263a1236e1be22445570cab3e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7798db981511d7cf676820843223dec460045d29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7798db981511d7cf676820843223dec460045d29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7798db981511d7cf676820843223dec460045d29", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7798db981511d7cf676820843223dec460045d29/comments", "author": null, "committer": null, "parents": [{"sha": "4705d102814701567cc9551b3fb17e3dd0cf9620", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4705d102814701567cc9551b3fb17e3dd0cf9620", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4705d102814701567cc9551b3fb17e3dd0cf9620"}], "stats": {"total": 31, "additions": 20, "deletions": 11}, "files": [{"sha": "6b0f9fb48b10ccb96ae8d0473a9718a87c925031", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7798db981511d7cf676820843223dec460045d29/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7798db981511d7cf676820843223dec460045d29/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7798db981511d7cf676820843223dec460045d29", "patch": "@@ -1,3 +1,12 @@\n+2003-01-06  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/h8300/h8300.c (final_prescan_insn): Constify uid.\n+\t(output_logical_op): Constify intval and det.\n+\t(compute_logical_length): Likewise.\n+\t(compute_logical_cc): Likewise.\n+\t(output_a_shift): Constify mask.\n+\t(h8300_encode_label): Constify len.\n+\n 2003-01-06  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/h8300.c (h8300_expand_prologue): Remove fsize."}, {"sha": "3f2a358a35b90a1aa37c7f02ae5d39f3d88ee30c", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7798db981511d7cf676820843223dec460045d29/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7798db981511d7cf676820843223dec460045d29/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=7798db981511d7cf676820843223dec460045d29", "patch": "@@ -1609,7 +1609,7 @@ final_prescan_insn (insn, operand, num_operands)\n   /* This holds the last insn address.  */\n   static int last_insn_address = 0;\n \n-  int uid = INSN_UID (insn);\n+  const int uid = INSN_UID (insn);\n \n   if (TARGET_RTL_DUMP)\n     {\n@@ -2055,12 +2055,12 @@ output_logical_op (mode, operands)\n   /* Figure out the logical op that we need to perform.  */\n   enum rtx_code code = GET_CODE (operands[3]);\n   /* Pretend that every byte is affected if both operands are registers.  */\n-  unsigned HOST_WIDE_INT intval =\n+  const unsigned HOST_WIDE_INT intval =\n     (unsigned HOST_WIDE_INT) ((GET_CODE (operands[2]) == CONST_INT)\n \t\t\t      ? INTVAL (operands[2]) : 0x55555555);\n   /* The determinant of the algorithm.  If we perform an AND, 0\n      affects a bit.  Otherwise, 1 affects a bit.  */\n-  unsigned HOST_WIDE_INT det = (code != AND) ? intval : ~intval;\n+  const unsigned HOST_WIDE_INT det = (code != AND) ? intval : ~intval;\n   /* The name of an insn.  */\n   const char *opname;\n   char insn_buf[100];\n@@ -2208,12 +2208,12 @@ compute_logical_op_length (mode, operands)\n   /* Figure out the logical op that we need to perform.  */\n   enum rtx_code code = GET_CODE (operands[3]);\n   /* Pretend that every byte is affected if both operands are registers.  */\n-  unsigned HOST_WIDE_INT intval =\n+  const unsigned HOST_WIDE_INT intval =\n     (unsigned HOST_WIDE_INT) ((GET_CODE (operands[2]) == CONST_INT)\n \t\t\t      ? INTVAL (operands[2]) : 0x55555555);\n   /* The determinant of the algorithm.  If we perform an AND, 0\n      affects a bit.  Otherwise, 1 affects a bit.  */\n-  unsigned HOST_WIDE_INT det = (code != AND) ? intval : ~intval;\n+  const unsigned HOST_WIDE_INT det = (code != AND) ? intval : ~intval;\n   /* Insn length.  */\n   unsigned int length = 0;\n \n@@ -2330,12 +2330,12 @@ compute_logical_op_cc (mode, operands)\n   /* Figure out the logical op that we need to perform.  */\n   enum rtx_code code = GET_CODE (operands[3]);\n   /* Pretend that every byte is affected if both operands are registers.  */\n-  unsigned HOST_WIDE_INT intval =\n+  const unsigned HOST_WIDE_INT intval =\n     (unsigned HOST_WIDE_INT) ((GET_CODE (operands[2]) == CONST_INT)\n \t\t\t      ? INTVAL (operands[2]) : 0x55555555);\n   /* The determinant of the algorithm.  If we perform an AND, 0\n      affects a bit.  Otherwise, 1 affects a bit.  */\n-  unsigned HOST_WIDE_INT det = (code != AND) ? intval : ~intval;\n+  const unsigned HOST_WIDE_INT det = (code != AND) ? intval : ~intval;\n   /* Condition code.  */\n   enum attr_cc cc = CC_CLOBBER;\n \n@@ -3245,9 +3245,9 @@ output_a_shift (operands)\n \tcase SHIFT_ROT_AND:\n \t  {\n \t    int m = GET_MODE_BITSIZE (mode) - n;\n-\t    int mask = (shift_type == SHIFT_ASHIFT\n-\t\t\t? ((1 << m) - 1) << n\n-\t\t\t: (1 << m) - 1);\n+\t    const int mask = (shift_type == SHIFT_ASHIFT\n+\t\t\t      ? ((1 << m) - 1) << n\n+\t\t\t      : (1 << m) - 1);\n \t    char insn_buf[200];\n \n \t    /* Not all possibilities of rotate are supported.  They shouldn't\n@@ -3912,7 +3912,7 @@ h8300_encode_label (decl)\n      tree decl;\n {\n   const char *str = XSTR (XEXP (DECL_RTL (decl), 0), 0);\n-  int len = strlen (str);\n+  const int len = strlen (str);\n   char *newstr = alloca (len + 2);\n \n   newstr[0] = '&';"}]}