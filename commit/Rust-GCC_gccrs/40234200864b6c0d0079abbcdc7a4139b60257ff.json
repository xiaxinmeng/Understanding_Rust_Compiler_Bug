{"sha": "40234200864b6c0d0079abbcdc7a4139b60257ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDAyMzQyMDA4NjRiNmMwZDAwNzlhYmJjZGM3YTQxMzliNjAyNTdmZg==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-12-05T18:44:20Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-12-05T18:47:40Z"}, "message": "c++: Normalize nested-requirements twice at parse time [PR97093]\n\nThe re-normalization performed from diagnose_nested_requirement doesn't\nalways work because we may have already lost the necessary template\ncontext that determines the set of in-scope template parameters used by\nthe nested-requirement.  This leads to normalization producing atoms\nthat have incomplete/bogus parameter mappings, which breaks satisfaction.\n\nTo fix this, we could just use the normal form that we previously\ncomputed at parse time, but this normal form lacks the diagnostic\ninformation that leads to good error messages.\n\nInstead, this patch makes diagnose_nested_requirement normalize twice at\nparse time -- once without diagnostic information and once with -- so\nthat routines can use the \"regular\" normal form when performing\nsatisfaction quietly and the \"diagnostic\" normal form when performing\nsatisfaction noisily.  Moreover, this patch makes tsubst_nested_requirement\nalways first perform satisfaction quietly so that the satisfaction cache\ncan get consistently utilized.\n\nThis patch also adds some sanity checks to build_parameter_mapping that\nwould have caught the underlying bug sooner (and deterministically).\n\ngcc/cp/ChangeLog:\n\n\tPR c++/97093\n\t* constraint.cc (parameter_mapping_equivalent_p): Add some\n\tsanity checks.  Clarify comment.\n\t(tsubst_nested_requirement): Always perform satisfaction\n\tquietly first.  If that yields an erroneous result, emit a\n\tcontext message and replay satisfaction noisily with the\n\tdiagnostic normal form.\n\t(finish_nested_requirement): Normalize the constraint-expression\n\ttwice, once with diagnostic information and once without.  Store\n\tthem in a TREE_LIST within the TREE_TYPE.\n\t(diagnose_nested_requirement): When replaying satisfaction, use\n\tthe diagnostic normal form instead of renormalizing on the spot.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/97093\n\t* g++.dg/cpp2a/concepts-requires22.C: New test.", "tree": {"sha": "f5803bb5c25ed4dbd1f6bdf5b89dd49e5a6f2f90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5803bb5c25ed4dbd1f6bdf5b89dd49e5a6f2f90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40234200864b6c0d0079abbcdc7a4139b60257ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40234200864b6c0d0079abbcdc7a4139b60257ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40234200864b6c0d0079abbcdc7a4139b60257ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40234200864b6c0d0079abbcdc7a4139b60257ff/comments", "author": null, "committer": null, "parents": [{"sha": "904ac8577521b8152b97e9b549c1a1ca569a3d1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/904ac8577521b8152b97e9b549c1a1ca569a3d1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/904ac8577521b8152b97e9b549c1a1ca569a3d1f"}], "stats": {"total": 59, "additions": 44, "deletions": 15}, "files": [{"sha": "b4c501b8f717acfeb0583c03305bbda4c0371f95", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40234200864b6c0d0079abbcdc7a4139b60257ff/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40234200864b6c0d0079abbcdc7a4139b60257ff/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=40234200864b6c0d0079abbcdc7a4139b60257ff", "patch": "@@ -619,7 +619,8 @@ build_parameter_mapping (tree expr, tree args, tree decl)\n   return map;\n }\n \n-/* True if the parameter mappings of two atomic constraints are equivalent.  */\n+/* True if the parameter mappings of two atomic constraints formed\n+   from the same expression are equivalent.  */\n \n static bool\n parameter_mapping_equivalent_p (tree t1, tree t2)\n@@ -628,13 +629,15 @@ parameter_mapping_equivalent_p (tree t1, tree t2)\n   tree map2 = ATOMIC_CONSTR_MAP (t2);\n   while (map1 && map2)\n     {\n+      gcc_checking_assert (TREE_VALUE (map1) == TREE_VALUE (map2));\n       tree arg1 = TREE_PURPOSE (map1);\n       tree arg2 = TREE_PURPOSE (map2);\n       if (!template_args_equal (arg1, arg2))\n         return false;\n       map1 = TREE_CHAIN (map1);\n       map2 = TREE_CHAIN (map2);\n     }\n+  gcc_checking_assert (!map1 && !map2);\n   return true;\n }\n \n@@ -2092,14 +2095,16 @@ tsubst_compound_requirement (tree t, tree args, subst_info info)\n static tree\n tsubst_nested_requirement (tree t, tree args, subst_info info)\n {\n-  /* Ensure that we're in an evaluation context prior to satisfaction.  */\n-  tree norm = TREE_TYPE (t);\n-  tree result = satisfy_constraint (norm, args,\n-\t\t\t\t    sat_info (info.complain, info.in_decl));\n-  if (result == error_mark_node && info.quiet ())\n+  /* Perform satisfaction quietly with the regular normal form.  */\n+  sat_info quiet (tf_none, info.in_decl);\n+  tree norm = TREE_VALUE (TREE_TYPE (t));\n+  tree diag_norm = TREE_PURPOSE (TREE_TYPE (t));\n+  tree result = satisfy_constraint (norm, args, quiet);\n+  if (result == error_mark_node)\n     {\n+      /* Replay the error using the diagnostic normal form.  */\n       sat_info noisy (tf_warning_or_error, info.in_decl);\n-      satisfy_constraint (norm, args, noisy);\n+      satisfy_constraint (diag_norm, args, noisy);\n     }\n   if (result != boolean_true_node)\n     return error_mark_node;\n@@ -3137,10 +3142,15 @@ finish_compound_requirement (location_t loc, tree expr, tree type, bool noexcept\n tree\n finish_nested_requirement (location_t loc, tree expr)\n {\n-  tree norm = normalize_constraint_expression (expr, false);\n+  /* We need to normalize the constraints now, at parse time, while\n+     we have the necessary template context.  We normalize twice,\n+     once without diagnostic information and once with, which we'll\n+     later use for quiet and noisy satisfaction respectively.  */\n+  tree norm = normalize_constraint_expression (expr, /*diag=*/false);\n+  tree diag_norm = normalize_constraint_expression (expr, /*diag=*/true);\n \n-  /* Build the constraint, saving its normalization as its type.  */\n-  tree r = build1 (NESTED_REQ, norm, expr);\n+  /* Build the constraint, saving its two normalizations as its type.  */\n+  tree r = build1 (NESTED_REQ, build_tree_list (diag_norm, norm), expr);\n   SET_EXPR_LOCATION (r, loc);\n   return r;\n }\n@@ -3541,9 +3551,10 @@ diagnose_type_requirement (tree req, tree args, tree in_decl)\n static void\n diagnose_nested_requirement (tree req, tree args)\n {\n-  /* Quietly check for satisfaction first. We can elaborate details\n-     later if needed.  */\n-  tree norm = TREE_TYPE (req);\n+  /* Quietly check for satisfaction first using the regular normal form.\n+     We can elaborate details later if needed.  */\n+  tree norm = TREE_VALUE (TREE_TYPE (req));\n+  tree diag_norm = TREE_PURPOSE (TREE_TYPE (req));\n   sat_info info (tf_none, NULL_TREE);\n   tree result = satisfy_constraint (norm, args, info);\n   if (result == boolean_true_node)\n@@ -3553,10 +3564,10 @@ diagnose_nested_requirement (tree req, tree args)\n   location_t loc = cp_expr_location (expr);\n   if (diagnosing_failed_constraint::replay_errors_p ())\n     {\n-      /* Replay the substitution error.  */\n+      /* Replay the substitution error using the diagnostic normal form.  */\n       inform (loc, \"nested requirement %qE is not satisfied, because\", expr);\n       sat_info noisy (tf_warning_or_error, NULL_TREE, /*diag_unsat=*/true);\n-      satisfy_constraint_expression (expr, args, noisy);\n+      satisfy_constraint (diag_norm, args, noisy);\n     }\n   else\n     inform (loc, \"nested requirement %qE is not satisfied\", expr);"}, {"sha": "5afcbbecbd5a9af0dafb5786bb3e5a91d9f4e21a", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-requires22.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40234200864b6c0d0079abbcdc7a4139b60257ff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires22.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40234200864b6c0d0079abbcdc7a4139b60257ff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires22.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires22.C?ref=40234200864b6c0d0079abbcdc7a4139b60257ff", "patch": "@@ -0,0 +1,18 @@\n+// PR c++/97093\n+// { dg-do compile { target c++20 } }\n+// { dg-additional-options \"-fconcepts-diagnostics-depth=3\" }\n+\n+template<class X, X x>\n+concept C = requires {\n+    requires (X)x;                     // { dg-message \"false\" }\n+  };\n+\n+template<class X, X x>\n+concept D = requires {\n+    requires false || (X)x;                    // { dg-message \"false\" }\n+  };\n+\n+int main() {\n+  static_assert(C<bool, 0>); // { dg-error \"failed\" }\n+  static_assert(D<bool, 0>); // { dg-error \"failed\" }\n+}"}]}