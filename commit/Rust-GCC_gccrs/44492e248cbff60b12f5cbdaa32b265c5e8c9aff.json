{"sha": "44492e248cbff60b12f5cbdaa32b265c5e8c9aff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQ0OTJlMjQ4Y2JmZjYwYjEyZjVjYmRhYTMyYjI2NWM1ZThjOWFmZg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-06-15T21:11:38Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-06-17T19:08:42Z"}, "message": "c++: implicit operator== adjustments from P2002.\n\nP2002R1, adopted at the February C++ meeting, made several refinements to\nthe wording for operator<=>.  This implements clarifications in how the\nimplicit operator== is declared: as a duplicate of the operator<=>, with\nonly the return type and name changed.  To that end I factored out the\ndeclaration copying from build_clone.\n\ngcc/cp/ChangeLog:\n\n\t* cp-tree.h (copy_fndecl_with_name): Declare.\n\t* class.c (copy_fndecl_with_name): Split out from...\n\t(build_clone): ...here.\n\t(add_implicitly_declared_members): Add op== to TYPE_FIELDS.\n\t* method.c (implicitly_declare_fn): Use copy_fndecl_with_name.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp2a/spaceship-synth9.C: New test.", "tree": {"sha": "4be0a18736a2e007ab79abef27ef49154840f581", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4be0a18736a2e007ab79abef27ef49154840f581"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44492e248cbff60b12f5cbdaa32b265c5e8c9aff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44492e248cbff60b12f5cbdaa32b265c5e8c9aff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44492e248cbff60b12f5cbdaa32b265c5e8c9aff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44492e248cbff60b12f5cbdaa32b265c5e8c9aff/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68df8e8c3438dda209c3ad9843933da640c9a71c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68df8e8c3438dda209c3ad9843933da640c9a71c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68df8e8c3438dda209c3ad9843933da640c9a71c"}], "stats": {"total": 231, "additions": 128, "deletions": 103}, "files": [{"sha": "629d27da89494b99215efd719b1f24ee1c935827", "filename": "gcc/cp/class.c", "status": "modified", "additions": 57, "deletions": 29, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44492e248cbff60b12f5cbdaa32b265c5e8c9aff/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44492e248cbff60b12f5cbdaa32b265c5e8c9aff/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=44492e248cbff60b12f5cbdaa32b265c5e8c9aff", "patch": "@@ -3266,7 +3266,12 @@ add_implicitly_declared_members (tree t, tree* access_decls,\n \t  do_friend (NULL_TREE, DECL_NAME (eq), eq,\n \t\t     NULL_TREE, NO_SPECIAL, true);\n \telse\n-\t  add_method (t, eq, false);\n+\t  {\n+\t    add_method (t, eq, false);\n+\t    DECL_CHAIN (eq) = TYPE_FIELDS (t);\n+\t    TYPE_FIELDS (t) = eq;\n+\t  }\n+\tmaybe_add_class_template_decl_list (t, eq, DECL_FRIEND_P (space));\n       }\n \n   while (*access_decls)\n@@ -4687,45 +4692,20 @@ check_methods (tree t)\n     }\n }\n \n-/* FN is a constructor or destructor.  Clone the declaration to create\n-   a specialized in-charge or not-in-charge version, as indicated by\n-   NAME.  */\n-\n-static tree\n-build_clone (tree fn, tree name)\n+tree\n+copy_fndecl_with_name (tree fn, tree name)\n {\n   /* Copy the function.  */\n   tree clone = copy_decl (fn);\n   /* Reset the function name.  */\n   DECL_NAME (clone) = name;\n-  /* Remember where this function came from.  */\n-  DECL_ABSTRACT_ORIGIN (clone) = fn;\n-\n-  /* Make it easy to find the CLONE given the FN.  Note the\n-     template_result of a template will be chained this way too.  */\n-  DECL_CHAIN (clone) = DECL_CHAIN (fn);\n-  DECL_CHAIN (fn) = clone;\n-\n-  /* If this is a template, do the rest on the DECL_TEMPLATE_RESULT.  */\n-  if (TREE_CODE (clone) == TEMPLATE_DECL)\n-    {\n-      tree result = build_clone (DECL_TEMPLATE_RESULT (clone), name);\n-      DECL_TEMPLATE_RESULT (clone) = result;\n-\n-      DECL_TEMPLATE_INFO (result) = copy_node (DECL_TEMPLATE_INFO (result));\n-      DECL_TI_TEMPLATE (result) = clone;\n-\n-      TREE_TYPE (clone) = TREE_TYPE (result);\n-      return clone;\n-    }\n \n   if (flag_concepts)\n     /* Clone constraints.  */\n     if (tree ci = get_constraints (fn))\n       set_constraints (clone, copy_node (ci));\n \n   SET_DECL_ASSEMBLER_NAME (clone, NULL_TREE);\n-  DECL_CLONED_FUNCTION (clone) = fn;\n   /* There's no pending inline data for this function.  */\n   DECL_PENDING_INLINE_INFO (clone) = NULL;\n   DECL_PENDING_INLINE_P (clone) = 0;\n@@ -4736,6 +4716,14 @@ build_clone (tree fn, tree name)\n       DECL_VIRTUAL_P (clone) = 0;\n       DECL_VINDEX (clone) = NULL_TREE;\n     }\n+  else if (IDENTIFIER_OVL_OP_P (name))\n+    {\n+      const ovl_op_info_t *ovl_op = IDENTIFIER_OVL_OP_INFO (name);\n+      DECL_OVERLOADED_OPERATOR_CODE_RAW (clone) = ovl_op->ovl_op_code;\n+    }\n+\n+  if (DECL_VIRTUAL_P (clone))\n+    IDENTIFIER_VIRTUAL_P (name) = true;\n \n   bool ctor_omit_inherited_parms_p = ctor_omit_inherited_parms (clone);\n   if (ctor_omit_inherited_parms_p)\n@@ -4807,7 +4795,47 @@ build_clone (tree fn, tree name)\n \n   /* Create the RTL for this function.  */\n   SET_DECL_RTL (clone, NULL);\n-  rest_of_decl_compilation (clone, /*top_level=*/1, at_eof);\n+  rest_of_decl_compilation (clone, namespace_bindings_p (), at_eof);\n+\n+  return clone;\n+}\n+\n+/* FN is a constructor or destructor.  Clone the declaration to create\n+   a specialized in-charge or not-in-charge version, as indicated by\n+   NAME.  */\n+\n+static tree\n+build_clone (tree fn, tree name)\n+{\n+  tree clone;\n+\n+  /* If this is a template, do the rest on the DECL_TEMPLATE_RESULT.  */\n+  if (TREE_CODE (fn) == TEMPLATE_DECL)\n+    {\n+      clone = copy_decl (fn);\n+      DECL_NAME (clone) = name;\n+\n+      tree result = build_clone (DECL_TEMPLATE_RESULT (clone), name);\n+      DECL_TEMPLATE_RESULT (clone) = result;\n+\n+      DECL_TEMPLATE_INFO (result) = copy_node (DECL_TEMPLATE_INFO (result));\n+      DECL_TI_TEMPLATE (result) = clone;\n+\n+      TREE_TYPE (clone) = TREE_TYPE (result);\n+    }\n+  else\n+    {\n+      clone = copy_fndecl_with_name (fn, name);\n+      DECL_CLONED_FUNCTION (clone) = fn;\n+    }\n+\n+  /* Remember where this function came from.  */\n+  DECL_ABSTRACT_ORIGIN (clone) = fn;\n+\n+  /* Make it easy to find the CLONE given the FN.  Note the\n+     template_result of a template will be chained this way too.  */\n+  DECL_CHAIN (clone) = DECL_CHAIN (fn);\n+  DECL_CHAIN (fn) = clone;\n \n   return clone;\n }"}, {"sha": "c139668696818a6a50b698df1dcb32c1a972c9da", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44492e248cbff60b12f5cbdaa32b265c5e8c9aff/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44492e248cbff60b12f5cbdaa32b265c5e8c9aff/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=44492e248cbff60b12f5cbdaa32b265c5e8c9aff", "patch": "@@ -6448,6 +6448,7 @@ extern void check_abi_tags\t\t\t(tree);\n extern tree missing_abi_tags\t\t\t(tree);\n extern void fixup_type_variants\t\t\t(tree);\n extern void fixup_attribute_variants\t\t(tree);\n+extern tree copy_fndecl_with_name\t\t(tree, tree);\n extern void clone_function_decl\t\t\t(tree, bool);\n extern void adjust_clone_args\t\t\t(tree);\n extern void deduce_noexcept_on_destructor       (tree);"}, {"sha": "1a819b291738f5f1d1ddbe6f539046c70f94a794", "filename": "gcc/cp/method.c", "status": "modified", "additions": 43, "deletions": 74, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44492e248cbff60b12f5cbdaa32b265c5e8c9aff/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44492e248cbff60b12f5cbdaa32b265c5e8c9aff/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=44492e248cbff60b12f5cbdaa32b265c5e8c9aff", "patch": "@@ -2632,19 +2632,46 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n   HOST_WIDE_INT saved_processing_template_decl;\n   bool deleted_p = false;\n   bool constexpr_p = false;\n-  bool friend_p = (kind == sfk_comparison && DECL_FRIEND_P (pattern_fn));\n   tree inherited_ctor = (kind == sfk_inheriting_constructor\n \t\t\t ? pattern_fn : NULL_TREE);\n \n   /* Because we create declarations for implicitly declared functions\n      lazily, we may be creating the declaration for a member of TYPE\n      while in some completely different context.  However, TYPE will\n      never be a dependent class (because we never want to do lookups\n-     for implicitly defined functions in a dependent class).\n-     Furthermore, we must set PROCESSING_TEMPLATE_DECL to zero here\n+     for implicitly defined functions in a dependent class).  */\n+  gcc_assert (!dependent_type_p (type));\n+\n+  /* If the member-specification does not explicitly declare any member or\n+     friend named operator==, an == operator function is declared\n+     implicitly for each three-way comparison operator function defined as\n+     defaulted in the member-specification, with the same access and\n+     function-definition and in the same class scope as the respective\n+     three-way comparison operator function, except that the return type is\n+     replaced with bool and the declarator-id is replaced with\n+     operator==.\n+\n+     [Note: Such an implicitly-declared == operator for a class X is\n+     defined as defaulted in the definition of X and has the same\n+     parameter-declaration-clause and trailing requires-clause as the\n+     respective three-way comparison operator. It is declared with friend,\n+     virtual, constexpr, or consteval if the three-way comparison operator\n+     function is so declared. If the three-way comparison operator function\n+     has no noexcept-specifier, the implicitly-declared == operator\n+     function has an implicit exception specification (14.5) that may\n+     differ from the implicit exception specification of the three-way\n+     comparison operator function. --end note]  */\n+  if (kind == sfk_comparison)\n+    {\n+      fn = copy_fndecl_with_name (pattern_fn, ovl_op_identifier (EQ_EXPR));\n+      DECL_ARTIFICIAL (fn) = 1;\n+      TREE_TYPE (fn) = change_return_type (boolean_type_node, TREE_TYPE (fn));\n+      return fn;\n+    }\n+\n+  /* Furthermore, we must set PROCESSING_TEMPLATE_DECL to zero here\n      because we only create clones for constructors and destructors\n      when not in a template.  */\n-  gcc_assert (!dependent_type_p (type));\n   saved_processing_template_decl = processing_template_decl;\n   processing_template_decl = 0;\n \n@@ -2706,35 +2733,6 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n       break;\n     }\n \n-    case sfk_comparison:\n-      /* If the class definition does not explicitly declare an == operator\n-\t function, but declares a defaulted three-way comparison operator\n-\t function, an == operator function is declared implicitly with the same\n-\t access as the three-way comparison operator function.\n-\n-\t The implicitly-declared == operator for a class X is an inline member\n-\t and is defined as defaulted in the definition of X.\n-\n-\t If the three-way comparison operator function is declared as a\n-\t non-static const member, the implicitly-declared == operator function\n-\t is a member of the form\n-\n-\t   bool X::operator==(const X&) const;\n-\n-\t Otherwise, the implicitly-declared == operator function is of the form\n-\n-\t   friend bool operator==(const X&, const X&); */\n-      /* No other comparison operator is implicitly declared.  */\n-      name = ovl_op_identifier (false, EQ_EXPR);\n-      return_type = boolean_type_node;\n-      rhs_parm_type = cp_build_qualified_type (type, TYPE_QUAL_CONST);\n-      rhs_parm_type = cp_build_reference_type (rhs_parm_type, false);\n-      parameter_types = tree_cons (NULL_TREE, rhs_parm_type, parameter_types);\n-      if (friend_p)\n-\tparameter_types = tree_cons (NULL_TREE, rhs_parm_type, parameter_types);\n-      this_quals = TYPE_QUAL_CONST;\n-      break;\n-\n     default:\n       gcc_unreachable ();\n     }\n@@ -2752,10 +2750,9 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n   else if (cxx_dialect >= cxx11)\n     {\n       raises = noexcept_deferred_spec;\n-      if (kind != sfk_comparison)\n-\tsynthesized_method_walk (type, kind, const_p, NULL, &trivial_p,\n-\t\t\t\t &deleted_p, &constexpr_p, false,\n-\t\t\t\t &inherited_ctor, inherited_parms);\n+      synthesized_method_walk (type, kind, const_p, NULL, &trivial_p,\n+\t\t\t       &deleted_p, &constexpr_p, false,\n+\t\t\t       &inherited_ctor, inherited_parms);\n     }\n   else\n     synthesized_method_walk (type, kind, const_p, &raises, &trivial_p,\n@@ -2777,14 +2774,9 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n     type_set_nontrivial_flag (type, kind);\n \n   /* Create the function.  */\n-  if (friend_p)\n-    fn_type = build_function_type (return_type, parameter_types);\n-  else\n-    {\n-      tree this_type = cp_build_qualified_type (type, this_quals);\n-      fn_type = build_method_type_directly (this_type, return_type,\n-\t\t\t\t\t    parameter_types);\n-    }\n+  tree this_type = cp_build_qualified_type (type, this_quals);\n+  fn_type = build_method_type_directly (this_type, return_type,\n+\t\t\t\t\tparameter_types);\n \n   if (raises)\n     {\n@@ -2796,12 +2788,7 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n \tgcc_assert (seen_error ());\n     }\n   fn = build_lang_decl (FUNCTION_DECL, name, fn_type);\n-  if (kind == sfk_comparison)\n-    {\n-      DECL_SOURCE_LOCATION (fn) = DECL_SOURCE_LOCATION (pattern_fn);\n-      DECL_MAYBE_DELETED (fn) = true;\n-    }\n-  else if (kind != sfk_inheriting_constructor)\n+  if (kind != sfk_inheriting_constructor)\n     DECL_SOURCE_LOCATION (fn) = DECL_SOURCE_LOCATION (TYPE_NAME (type));\n \n   if (IDENTIFIER_OVL_OP_P (name))\n@@ -2829,13 +2816,6 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n       retrofit_lang_decl (decl);\n       DECL_PARM_INDEX (decl) = DECL_PARM_LEVEL (decl) = 1;\n       DECL_ARGUMENTS (fn) = decl;\n-      if (friend_p)\n-\t{\n-\t  /* The second parm of friend op==.  */\n-\t  tree decl2 = copy_decl (decl);\n-\t  DECL_CHAIN (decl) = decl2;\n-\t  DECL_PARM_INDEX (decl2) = 2;\n-\t}\n     }\n   else if (kind == sfk_inheriting_constructor)\n     {\n@@ -2861,17 +2841,12 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n       constexpr_p = DECL_DECLARED_CONSTEXPR_P (inherited_ctor);\n     }\n \n-  if (friend_p)\n-    DECL_CONTEXT (fn) = DECL_CONTEXT (pattern_fn);\n-  else\n-    {\n-      /* Add the \"this\" parameter.  */\n-      this_parm = build_this_parm (fn, fn_type, this_quals);\n-      DECL_CHAIN (this_parm) = DECL_ARGUMENTS (fn);\n-      DECL_ARGUMENTS (fn) = this_parm;\n+  /* Add the \"this\" parameter.  */\n+  this_parm = build_this_parm (fn, fn_type, this_quals);\n+  DECL_CHAIN (this_parm) = DECL_ARGUMENTS (fn);\n+  DECL_ARGUMENTS (fn) = this_parm;\n \n-      grokclassfn (type, fn, kind == sfk_destructor ? DTOR_FLAG : NO_SPECIAL);\n-    }\n+  grokclassfn (type, fn, kind == sfk_destructor ? DTOR_FLAG : NO_SPECIAL);\n \n   DECL_IN_AGGR_P (fn) = 1;\n   DECL_ARTIFICIAL (fn) = 1;\n@@ -2887,12 +2862,6 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n   set_linkage_according_to_type (type, fn);\n   if (TREE_PUBLIC (fn))\n     DECL_COMDAT (fn) = 1;\n-  if (kind == sfk_comparison && !friend_p)\n-    {\n-      /* The implicit op== has the same access as the op<=>.  */\n-      TREE_PRIVATE (fn) = TREE_PRIVATE (pattern_fn);\n-      TREE_PROTECTED (fn) = TREE_PROTECTED (pattern_fn);\n-    }\n   rest_of_decl_compilation (fn, namespace_bindings_p (), at_eof);\n   gcc_assert (!TREE_USED (fn));\n "}, {"sha": "33b547d2b5053f3ea86701f0dd41f2b14fd49aea", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-synth9.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44492e248cbff60b12f5cbdaa32b265c5e8c9aff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44492e248cbff60b12f5cbdaa32b265c5e8c9aff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth9.C?ref=44492e248cbff60b12f5cbdaa32b265c5e8c9aff", "patch": "@@ -0,0 +1,27 @@\n+// Test that most properties of <=> are copied to ==.\n+// { dg-do compile { target c++20 } }\n+\n+#include <compare>\n+\n+template<typename T> struct X {\n+  T t;\n+  friend consteval std::partial_ordering operator<=>(X, X) requires (sizeof(T) != 1) = default;\n+  // implicitly declares: friend constexpr bool operator==(X, X) requires (sizeof(T) != 1) = default;\n+};\n+\n+template<typename T> struct Y {\n+  [[nodiscard]] virtual std::strong_ordering operator<=>(const Y&) const = default;\n+  // implicitly declares: [[nodiscard]] virtual bool operator==(const Y&) const = default;\n+};\n+\n+struct Z: Y<int>\n+{\n+  bool operator==(const Y&) const noexcept override;\n+};\n+\n+int main()\n+{\n+  X<char>() == X<char>();\t// { dg-error \"no match\" }\n+  X<int> x; x == x;\t\t// { dg-error \"x' is not usable in a constant expression\" }\n+  Y<int>()  == Y<int>();\t// { dg-warning \"nodiscard\" }\n+}"}]}