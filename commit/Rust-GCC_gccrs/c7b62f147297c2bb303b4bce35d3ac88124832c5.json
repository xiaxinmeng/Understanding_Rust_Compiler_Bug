{"sha": "c7b62f147297c2bb303b4bce35d3ac88124832c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdiNjJmMTQ3Mjk3YzJiYjMwM2I0YmNlMzVkM2FjODgxMjQ4MzJjNQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-07-25T16:52:47Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-07-25T16:52:47Z"}, "message": "cp-tree.h (build_compound_expr): Take LHS & RHS args.\n\n\t* cp-tree.h (build_compound_expr): Take LHS & RHS args.\n\t(build_x_compound_expr_from_list): Declare.\n\t* typeck.c (build_x_compound_expr_from_list): New.\n\t(build_x_compound_expr): Adjust.\n\t(build_compound_expr): Remove unreachable code. Take two\n\tparameters, adjust.\n\t* decl.c (grok_reference_init): Use\n\tbuild_x_compound_expr_from_list.\n\t(expand_static_init): Adjust build_compound_expr call.\n\t(cxx_maybe_build_cleanup): Likewise.\n\t* init.c (perform_member_init): Use\n\tbuild_x_compound_expr_from_list.\n\t(build_new_1): Likewise.\n\t(build_vec_delete): Adjust build_compound_expr calls.\n\t(build_vbase_delete): Likewise.\n\t* typeck2.c (store_init_value): Use\n\tbuild_x_compound_expr_from_list.\n\t(build_functional_cast): Likewise.\n\nFrom-SVN: r69794", "tree": {"sha": "dc0c0e9ab0bb147892d110a05424f33755c89968", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc0c0e9ab0bb147892d110a05424f33755c89968"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7b62f147297c2bb303b4bce35d3ac88124832c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7b62f147297c2bb303b4bce35d3ac88124832c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7b62f147297c2bb303b4bce35d3ac88124832c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7b62f147297c2bb303b4bce35d3ac88124832c5/comments", "author": null, "committer": null, "parents": [{"sha": "42eaed4985c166c90a52b9b24a7d53193cb8b933", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42eaed4985c166c90a52b9b24a7d53193cb8b933", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42eaed4985c166c90a52b9b24a7d53193cb8b933"}], "stats": {"total": 231, "additions": 96, "deletions": 135}, "files": [{"sha": "935260480098e42eca0e1441ad66317b3bfe60b4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7b62f147297c2bb303b4bce35d3ac88124832c5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7b62f147297c2bb303b4bce35d3ac88124832c5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c7b62f147297c2bb303b4bce35d3ac88124832c5", "patch": "@@ -1,3 +1,24 @@\n+2003-07-25  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* cp-tree.h (build_compound_expr): Take LHS & RHS args.\n+\t(build_x_compound_expr_from_list): Declare.\n+\t* typeck.c (build_x_compound_expr_from_list): New.\n+\t(build_x_compound_expr): Adjust.\n+\t(build_compound_expr): Remove unreachable code. Take two\n+\tparameters, adjust.\n+\t* decl.c (grok_reference_init): Use\n+\tbuild_x_compound_expr_from_list.\n+\t(expand_static_init): Adjust build_compound_expr call.\n+\t(cxx_maybe_build_cleanup): Likewise.\n+\t* init.c (perform_member_init): Use\n+\tbuild_x_compound_expr_from_list.\n+\t(build_new_1): Likewise.\n+\t(build_vec_delete): Adjust build_compound_expr calls.\n+\t(build_vbase_delete): Likewise.\n+\t* typeck2.c (store_init_value): Use\n+\tbuild_x_compound_expr_from_list.\n+\t(build_functional_cast): Likewise.\n+\n 2003-07-25  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* cp-tree.h (enum tsubst_flags_t): Add tf_user."}, {"sha": "2ef286e34a9ea7f97312bc6dbd292b73874d79da", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7b62f147297c2bb303b4bce35d3ac88124832c5/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7b62f147297c2bb303b4bce35d3ac88124832c5/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c7b62f147297c2bb303b4bce35d3ac88124832c5", "patch": "@@ -4299,8 +4299,9 @@ extern tree build_x_binary_op\t\t\t(enum tree_code, tree, tree);\n extern tree build_x_unary_op\t\t\t(enum tree_code, tree);\n extern tree unary_complex_lvalue\t\t(enum tree_code, tree);\n extern tree build_x_conditional_expr\t\t(tree, tree, tree);\n+extern tree build_x_compound_expr_from_list \t(tree, const char *);\n extern tree build_x_compound_expr\t\t(tree, tree);\n-extern tree build_compound_expr\t\t\t(tree);\n+extern tree build_compound_expr\t\t\t(tree, tree);\n extern tree build_static_cast\t\t\t(tree, tree);\n extern tree build_reinterpret_cast\t\t(tree, tree);\n extern tree build_const_cast\t\t\t(tree, tree);"}, {"sha": "2b0f0c685ba636812d263f068fd77669eab00a33", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7b62f147297c2bb303b4bce35d3ac88124832c5/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7b62f147297c2bb303b4bce35d3ac88124832c5/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=c7b62f147297c2bb303b4bce35d3ac88124832c5", "patch": "@@ -7199,7 +7199,7 @@ grok_reference_init (tree decl, tree type, tree init)\n     }\n \n   if (TREE_CODE (init) == TREE_LIST)\n-    init = build_compound_expr (init);\n+    init = build_x_compound_expr_from_list (init, \"initializer\");\n \n   if (TREE_CODE (TREE_TYPE (init)) == REFERENCE_TYPE)\n     init = convert_from_reference (init);\n@@ -8577,12 +8577,7 @@ expand_static_init (tree decl, tree init)\n \t run until after TEMP is set to 1.  */\n       guard_init = set_guard (guard);\n       if (assignment)\n-\t{\n-\t  assignment = tree_cons (NULL_TREE, assignment,\n-\t\t\t\t  build_tree_list (NULL_TREE,\n-\t\t\t\t\t\t   guard_init));\n-\t  assignment = build_compound_expr (assignment);\n-\t}\n+\tassignment = build_compound_expr (assignment, guard_init);\n       else\n \tassignment = guard_init;\n       finish_expr_stmt (assignment);\n@@ -14389,8 +14384,7 @@ cxx_maybe_build_cleanup (tree decl)\n \n       if (TYPE_USES_VIRTUAL_BASECLASSES (type)\n \t  && ! TYPE_HAS_DESTRUCTOR (type))\n-\trval = build_compound_expr (tree_cons (NULL_TREE, rval,\n-\t\t\t\t\t       build_tree_list (NULL_TREE, build_vbase_delete (type, decl))));\n+\trval = build_compound_expr (rval, build_vbase_delete (type, decl));\n \n       return rval;\n     }"}, {"sha": "53f0d621b83a8b9802c54e7ec905956ee38feef4", "filename": "gcc/cp/init.c", "status": "modified", "additions": 38, "deletions": 63, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7b62f147297c2bb303b4bce35d3ac88124832c5/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7b62f147297c2bb303b4bce35d3ac88124832c5/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=c7b62f147297c2bb303b4bce35d3ac88124832c5", "patch": "@@ -379,17 +379,9 @@ perform_member_init (tree member, tree init)\n \t    pedwarn (\"uninitialized reference member `%D'\", member);\n \t}\n       else if (TREE_CODE (init) == TREE_LIST)\n-\t{\n-\t  /* There was an explicit member initialization.  Do some\n-\t     work in that case.  */\n-\t  if (TREE_CHAIN (init))\n-\t    {\n-\t      warning (\"initializer list treated as compound expression\");\n-\t      init = build_compound_expr (init);\n-\t    }\n-\t  else\n-\t    init = TREE_VALUE (init);\n-\t}\n+\t/* There was an explicit member initialization.  Do some work\n+\t   in that case.  */\n+\tinit = build_x_compound_expr_from_list (init, \"member initializer\");\n \n       if (init)\n \tfinish_expr_stmt (build_modify_expr (decl, INIT_EXPR, init));\n@@ -2110,12 +2102,8 @@ build_new_1 (tree exp)\n \t     means allocate an int, and initialize it with 10.  */\n \n \t  if (TREE_CODE (init) == TREE_LIST)\n-\t    {\n-\t      if (TREE_CHAIN (init) != NULL_TREE)\n-\t\tpedwarn\n-\t\t  (\"initializer list being treated as compound expression\");\n-\t      init = build_compound_expr (init);\n-\t    }\n+\t    init = build_x_compound_expr_from_list (init, \"new initializer\");\n+\t  \n \t  else if (TREE_CODE (init) == CONSTRUCTOR\n \t\t   && TREE_TYPE (init) == NULL_TREE)\n \t    {\n@@ -2250,7 +2238,7 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n   tree body;\n \n   /* This is the LOOP_EXPR that governs the deletion of the elements.  */\n-  tree loop;\n+  tree loop = 0;\n \n   /* This is the thing that governs what to do after the loop has run.  */\n   tree deallocate_expr = 0;\n@@ -2266,10 +2254,7 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n     abort ();\n \n   if (! IS_AGGR_TYPE (type) || TYPE_HAS_TRIVIAL_DESTRUCTOR (type))\n-    {\n-      loop = integer_zero_node;\n-      goto no_destructor;\n-    }\n+    goto no_destructor;\n \n   /* The below is short by the cookie size.  */\n   virtual_size = size_binop (MULT_EXPR, size_exp,\n@@ -2284,32 +2269,21 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n   controller = build (BIND_EXPR, void_type_node, tbase, NULL_TREE, NULL_TREE);\n   TREE_SIDE_EFFECTS (controller) = 1;\n \n-  body = NULL_TREE;\n-\n-  body = tree_cons (NULL_TREE,\n-\t\t    build_delete (ptype, tbase, sfk_complete_destructor,\n-\t\t\t\t  LOOKUP_NORMAL|LOOKUP_DESTRUCTOR, 1),\n-\t\t    body);\n+  body = build (EXIT_EXPR, void_type_node,\n+\t\tbuild (EQ_EXPR, boolean_type_node, base, tbase));\n+  body = build_compound_expr\n+    (body, build_modify_expr (tbase, NOP_EXPR,\n+\t\t\t      build (MINUS_EXPR, ptype, tbase, size_exp)));\n+  body = build_compound_expr\n+    (body, build_delete (ptype, tbase, sfk_complete_destructor,\n+\t\t\t LOOKUP_NORMAL|LOOKUP_DESTRUCTOR, 1));\n \n-  body = tree_cons (NULL_TREE,\n-\t\t    build_modify_expr (tbase, NOP_EXPR, build (MINUS_EXPR, ptype, tbase, size_exp)),\n-\t\t    body);\n-\n-  body = tree_cons (NULL_TREE,\n-\t\t    build (EXIT_EXPR, void_type_node,\n-\t\t\t   build (EQ_EXPR, boolean_type_node, base, tbase)),\n-\t\t    body);\n-\n-  loop = build (LOOP_EXPR, void_type_node, build_compound_expr (body));\n-\n-  loop = tree_cons (NULL_TREE, tbase_init,\n-\t\t    tree_cons (NULL_TREE, loop, NULL_TREE));\n-  loop = build_compound_expr (loop);\n+  loop = build (LOOP_EXPR, void_type_node, body);\n+  loop = build_compound_expr (tbase_init, loop);\n \n  no_destructor:\n   /* If the delete flag is one, or anything else with the low bit set,\n      delete the storage.  */\n-  deallocate_expr = integer_zero_node;\n   if (auto_delete_vec != sfk_base_destructor)\n     {\n       tree base_tbd;\n@@ -2342,15 +2316,17 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n \t\t\t\t\t  virtual_size);\n     }\n \n-  if (loop && deallocate_expr != integer_zero_node)\n-    {\n-      body = tree_cons (NULL_TREE, loop,\n-\t\t\ttree_cons (NULL_TREE, deallocate_expr, NULL_TREE));\n-      body = build_compound_expr (body);\n-    }\n+  body = loop;\n+  if (!deallocate_expr)\n+    ;\n+  else if (!body)\n+    body = deallocate_expr;\n   else\n-    body = loop;\n-\n+    body = build_compound_expr (body, deallocate_expr);\n+  \n+  if (!body)\n+    body = integer_zero_node;\n+  \n   /* Outermost wrapper: If pointer is null, punt.  */\n   body = fold (build (COND_EXPR, void_type_node,\n \t\t      fold (build (NE_EXPR, boolean_type_node, base,\n@@ -3005,24 +2981,23 @@ tree\n build_vbase_delete (tree type, tree decl)\n {\n   tree vbases = CLASSTYPE_VBASECLASSES (type);\n-  tree result = NULL_TREE;\n+  tree result;\n   tree addr = build_unary_op (ADDR_EXPR, decl, 0);\n \n   my_friendly_assert (addr != error_mark_node, 222);\n \n-  while (vbases)\n+  for (result = convert_to_void (integer_zero_node, NULL);\n+       vbases; vbases = TREE_CHAIN (vbases))\n     {\n-      tree this_addr \n-\t= convert_force (build_pointer_type (BINFO_TYPE (TREE_VALUE (vbases))),\n-\t\t\t addr, 0);\n-      result = tree_cons (NULL_TREE,\n-\t\t\t  build_delete (TREE_TYPE (this_addr), this_addr,\n-\t\t\t\t\tsfk_base_destructor,\n-\t\t\t\t\tLOOKUP_NORMAL|LOOKUP_DESTRUCTOR, 0),\n-\t\t\t  result);\n-      vbases = TREE_CHAIN (vbases);\n+      tree base_addr = convert_force\n+\t(build_pointer_type (BINFO_TYPE (TREE_VALUE (vbases))), addr, 0);\n+      tree base_delete = build_delete\n+\t(TREE_TYPE (base_addr), base_addr, sfk_base_destructor,\n+\t LOOKUP_NORMAL|LOOKUP_DESTRUCTOR, 0);\n+      \n+      result = build_compound_expr (result, base_delete);\n     }\n-  return build_compound_expr (nreverse (result));\n+  return result;\n }\n \n /* Build a C++ vector delete expression."}, {"sha": "faa71975f5a4c9087c0c1dbffcf9964fe2297e88", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 27, "deletions": 37, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7b62f147297c2bb303b4bce35d3ac88124832c5/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7b62f147297c2bb303b4bce35d3ac88124832c5/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=c7b62f147297c2bb303b4bce35d3ac88124832c5", "patch": "@@ -4264,8 +4264,26 @@ build_x_conditional_expr (tree ifexp, tree op1, tree op2)\n   return expr;\n }\n \f\n-/* Handle overloading of the ',' operator when needed.  Otherwise,\n-   this function just builds an expression list.  */\n+/* Given a list of expressions, return a compound expression\n+   that performs them all and returns the value of the last of them. */\n+\n+tree build_x_compound_expr_from_list (tree list, const char *msg)\n+{\n+  tree expr = TREE_VALUE (list);\n+  \n+  if (TREE_CHAIN (list))\n+    {\n+      if (msg)\n+\tpedwarn (\"%s expression list treated as compound expression\", msg);\n+\n+      for (list = TREE_CHAIN (list); list; list = TREE_CHAIN (list))\n+\texpr = build_x_compound_expr (expr, TREE_VALUE (list));\n+    }\n+  \n+  return expr;\n+}\n+\n+/* Handle overloading of the ',' operator when needed.  */\n \n tree\n build_x_compound_expr (tree op1, tree op2)\n@@ -4298,10 +4316,7 @@ build_x_compound_expr (tree op1, tree op2)\n \t\t   && VOID_TYPE_P (TREE_TYPE (op1))))\n \t    warning(\"left-hand operand of comma expression has no effect\");\n \t}\n-      result = build_compound_expr (tree_cons (NULL_TREE,\n-\t\t\t\t\t       op1,\n-\t\t\t\t\t       build_tree_list (NULL_TREE,\n-\t\t\t\t\t\t\t\top2)));\n+      result = build_compound_expr (op1, op2);\n     }\n \n   if (processing_template_decl && result != error_mark_node)\n@@ -4310,42 +4325,17 @@ build_x_compound_expr (tree op1, tree op2)\n   return result;\n }\n \n-/* Given a list of expressions, return a compound expression\n-   that performs them all and returns the value of the last of them.  */\n+/* Build a compound expression. */\n \n tree\n-build_compound_expr (tree list)\n+build_compound_expr (tree lhs, tree rhs)\n {\n-  register tree rest;\n-  tree first;\n-\n-  TREE_VALUE (list) = decl_constant_value (TREE_VALUE (list));\n-\n-  if (TREE_CHAIN (list) == 0)\n-    {\n-      /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n-\t Strip such NOP_EXPRs, since LIST is used in non-lvalue context.  */\n-      if (TREE_CODE (list) == NOP_EXPR\n-\t  && TREE_TYPE (list) == TREE_TYPE (TREE_OPERAND (list, 0)))\n-\tlist = TREE_OPERAND (list, 0);\n-\t\n-      return TREE_VALUE (list);\n-    }\n-\n-  first = TREE_VALUE (list);\n-  first = convert_to_void (first, \"left-hand operand of comma\");\n-  if (first == error_mark_node)\n+  lhs = decl_constant_value (lhs);\n+  lhs = convert_to_void (lhs, \"left-hand operand of comma\");\n+  if (lhs == error_mark_node || rhs == error_mark_node)\n     return error_mark_node;\n   \n-  rest = build_compound_expr (TREE_CHAIN (list));\n-  if (rest == error_mark_node)\n-    return error_mark_node;\n-\n-  /* When pedantic, a compound expression cannot be a constant expression.  */\n-  if (! TREE_SIDE_EFFECTS (first) && ! pedantic)\n-    return rest;\n-\n-  return build (COMPOUND_EXPR, TREE_TYPE (rest), first, rest);\n+  return build (COMPOUND_EXPR, TREE_TYPE (rhs), lhs, rhs);\n }\n \n /* Issue an error message if casting from SRC_TYPE to DEST_TYPE casts"}, {"sha": "a27df4fdf82f189c5ca9de65770257028f3f7018", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 5, "deletions": 25, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7b62f147297c2bb303b4bce35d3ac88124832c5/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7b62f147297c2bb303b4bce35d3ac88124832c5/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=c7b62f147297c2bb303b4bce35d3ac88124832c5", "patch": "@@ -330,33 +330,17 @@ store_init_value (tree decl, tree init)\n \t   && TREE_TYPE (init) != unknown_type_node)\n     {\n       if (TREE_CODE (decl) == RESULT_DECL)\n-\t{\n-\t  if (TREE_CHAIN (init))\n-\t    {\n-\t      warning (\"comma expression used to initialize return value\");\n-\t      init = build_compound_expr (init);\n-\t    }\n-\t  else\n-\t    init = TREE_VALUE (init);\n-\t}\n+\tinit = build_x_compound_expr_from_list (init,\n+\t\t\t\t\t\t\"return value initializer\");\n       else if (TREE_CODE (init) == TREE_LIST\n \t       && TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n \t{\n \t  error (\"cannot initialize arrays using this syntax\");\n \t  return NULL_TREE;\n \t}\n       else\n-\t{\n-\t  /* We get here with code like `int a (2);' */\n-\t     \n-\t  if (TREE_CHAIN (init) != NULL_TREE)\n-\t    {\n-\t      pedwarn (\"initializer list being treated as compound expression\");\n-\t      init = build_compound_expr (init);\n-\t    }\n-\t  else\n-\t    init = TREE_VALUE (init);\n-\t}\n+\t/* We get here with code like `int a (2);' */\n+\tinit = build_x_compound_expr_from_list (init, \"initializer\");\n     }\n \n   /* End of special C++ code.  */\n@@ -1160,11 +1144,7 @@ build_functional_cast (tree exp, tree parms)\n       if (parms == NULL_TREE)\n \tparms = integer_zero_node;\n       else\n-\t{\n-\t  if (TREE_CHAIN (parms) != NULL_TREE)\n-\t    pedwarn (\"initializer list being treated as compound expression\");\n-\t  parms = build_compound_expr (parms);\n-\t}\n+\tparms = build_x_compound_expr_from_list (parms, \"functional cast\");\n \n       return build_c_cast (type, parms);\n     }"}]}