{"sha": "6aa62cff4e62f91945a7b47715ad0679b690188d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmFhNjJjZmY0ZTYyZjkxOTQ1YTdiNDc3MTVhZDA2NzliNjkwMTg4ZA==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-04-15T17:59:56Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-04-15T17:59:56Z"}, "message": "gcc.c: #include \"gansidecl.h\".\n\n\t* gcc.c: #include \"gansidecl.h\".\n\t(PROTO,VPROTO,PVPROTO,VPROTO,VA_START,NULL): Delete.\n\t(GENERIC_PTR,NULL_PTR,P_tmpdir): Delete.\n\t(choose_temp_base): Declare as extern, delete internal copy.\n\t(concat): Rewrite to take a variable number of arguments.\n\t(choose_temp_base_try,concat[346]): Delete.\n\t(translate_options,set_spec,process_command,do_spec_1,\n\tis_directory,main): Always use concat, not concat[346].  Pass\n\tNULL_PTR as trailing arg to concat.\n\nFrom-SVN: r11794", "tree": {"sha": "e055240e8e91536d890be9f9b6ee76b52d376a32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e055240e8e91536d890be9f9b6ee76b52d376a32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6aa62cff4e62f91945a7b47715ad0679b690188d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6aa62cff4e62f91945a7b47715ad0679b690188d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6aa62cff4e62f91945a7b47715ad0679b690188d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6aa62cff4e62f91945a7b47715ad0679b690188d/comments", "author": null, "committer": null, "parents": [{"sha": "0afdf565966faee5a376e5366420a0c08df84b74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0afdf565966faee5a376e5366420a0c08df84b74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0afdf565966faee5a376e5366420a0c08df84b74"}], "stats": {"total": 267, "additions": 90, "deletions": 177}, "files": [{"sha": "9e9304b79a4fe77c98a6e3bdac1ac0a3c9b4bdf3", "filename": "gcc/gcc.c", "status": "modified", "additions": 90, "deletions": 177, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6aa62cff4e62f91945a7b47715ad0679b690188d/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6aa62cff4e62f91945a7b47715ad0679b690188d/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=6aa62cff4e62f91945a7b47715ad0679b690188d", "patch": "@@ -47,6 +47,8 @@ int __spawnvp ();\n \n #include \"config.h\"\n #include \"obstack.h\"\n+#include \"gansidecl.h\"\n+\n #ifdef __STDC__\n #include <stdarg.h>\n #else\n@@ -76,62 +78,15 @@ int __spawnvp ();\n #define WEXITSTATUS(S) (((S) & 0xff00) >> 8)\n #endif\n \n-/* Add prototype support.  */\n-#ifndef PROTO\n-#if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)\n-#define PROTO(ARGS) ARGS\n-#else\n-#define PROTO(ARGS) ()\n-#endif\n-#endif\n-\n-#ifndef VPROTO\n-#ifdef __STDC__\n-#define PVPROTO(ARGS)\t\tARGS\n-#define VPROTO(ARGS)\t\tARGS\n-#define VA_START(va_list,var)\tva_start(va_list,var)\n-#else\n-#define PVPROTO(ARGS)\t\t()\n-#define VPROTO(ARGS)\t\t(va_alist) va_dcl\n-#define VA_START(va_list,var)\tva_start(va_list)\n-#endif\n-#endif\n-\n-/* Define a generic NULL if one hasn't already been defined.  */\n-\n-#ifndef NULL\n-#define NULL 0\n-#endif\n-\n /* Define O_RDONLY if the system hasn't defined it for us. */\n #ifndef O_RDONLY\n #define O_RDONLY 0\n #endif\n \n-#ifndef GENERIC_PTR\n-#if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)\n-#define GENERIC_PTR void *\n-#else\n-#define GENERIC_PTR char *\n-#endif\n-#endif\n-\n-#ifndef NULL_PTR\n-#define NULL_PTR ((GENERIC_PTR)0)\n-#endif\n-\n #ifdef USG\n #define vfork fork\n #endif /* USG */\n \n-/* On MSDOS, write temp files in current dir\n-   because there's no place else we can expect to use.  */\n-#ifdef __MSDOS__\n-#ifndef P_tmpdir\n-#define P_tmpdir \".\"\n-#endif\n-#endif\n-\n /* Test if something is a normal file.  */\n #ifndef S_ISREG\n #define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)\n@@ -171,6 +126,8 @@ static char dir_separator_str[] = {DIR_SEPARATOR, 0};\n extern void free ();\n extern char *getenv ();\n \n+extern char *choose_temp_base PROTO((void));\n+\n #ifndef errno\n extern int errno;\n #endif\n@@ -279,16 +236,10 @@ static void delete_if_ordinary\tPROTO((char *));\n static void delete_temp_files\tPROTO((void));\n static void delete_failure_queue PROTO((void));\n static void clear_failure_queue PROTO((void));\n-static char *choose_temp_base_try PROTO((char *, char *));\n-static void choose_temp_base\tPROTO((void));\n static int check_live_switch\tPROTO((int, int));\n static char *handle_braces\tPROTO((char *));\n static char *save_string\tPROTO((char *, int));\n-static char *concat\t\tPROTO((char *, char *));\n-static char *concat3\t\tPROTO((char *, char *, char *));\n-static char *concat4\t\tPROTO((char *, char *, char *, char *));\n-static char *concat6\t\tPROTO((char *, char *, char *, char *, char *, \\\n-                                       char *));\n+static char *concat\t\tPVPROTO((char *, ...));\n static int do_spec\t\tPROTO((char *));\n static int do_spec_1\t\tPROTO((char *, int, char *));\n static char *find_file\t\tPROTO((char *));\n@@ -961,7 +912,8 @@ translate_options (argcp, argvp)\n \n \t\t  /* Store the translation as one argv elt or as two.  */\n \t\t  if (arg != 0 && index (arginfo, 'j') != 0)\n-\t\t    newv[newindex++] = concat (option_map[j].equivalent, arg);\n+\t\t    newv[newindex++] = concat (option_map[j].equivalent, arg,\n+\t\t\t\t\t       NULL_PTR);\n \t\t  else if (arg != 0)\n \t\t    {\n \t\t      newv[newindex++] = option_map[j].equivalent;\n@@ -1226,7 +1178,7 @@ set_spec (name, spec)\n \n   old_spec = sl->spec;\n   if (name && spec[0] == '+' && isspace (spec[1]))\n-    sl->spec = concat (old_spec, spec + 1);\n+    sl->spec = concat (old_spec, spec + 1, NULL_PTR);\n   else\n     sl->spec = save_string (spec, strlen (spec));\n \n@@ -1448,7 +1400,8 @@ store_arg (arg, delete_always, delete_failure)\n \n    This prefix comes from the envvar TMPDIR if it is defined;\n    otherwise, from the P_tmpdir macro if that is defined;\n-   otherwise, in /usr/tmp or /tmp.  */\n+   otherwise, in /usr/tmp or /tmp;\n+   or finally the current directory if all else fails.  */\n \n static char *temp_filename;\n \n@@ -1561,65 +1514,7 @@ clear_failure_queue ()\n {\n   failure_delete_queue = 0;\n }\n-\n-/* Compute a string to use as the base of all temporary file names.\n-   It is substituted for %g.  */\n-\n-static char *\n-choose_temp_base_try (try, base)\n-     char *try;\n-     char *base;\n-{\n-  char *rv;\n-  if (base)\n-    rv = base;\n-  else if (try == (char *)0)\n-    rv = 0;\n-  else if (access (try, R_OK | W_OK) != 0)\n-    rv = 0;\n-  else\n-    rv = try;\n-  return rv;\n-}\n-\n-static void\n-choose_temp_base ()\n-{\n-  char *base = 0;\n-  int len;\n-\n-  base = choose_temp_base_try (getenv (\"TMPDIR\"), base);\n-  base = choose_temp_base_try (getenv (\"TMP\"), base);\n-  base = choose_temp_base_try (getenv (\"TEMP\"), base);\n-\n-#ifdef P_tmpdir\n-  base = choose_temp_base_try (P_tmpdir, base);\n-#endif\n-\n-  base = choose_temp_base_try (concat4 (dir_separator_str, \"usr\", \n-                                        dir_separator_str, \"tmp\"), \n-                                base);\n-  base = choose_temp_base_try (concat (dir_separator_str, \"tmp\"), base);\n- \n-  /* If all else fails, use the current directory! */  \n-  if (base == (char *)0) base = concat(\".\", dir_separator_str);\n-\n-  len = strlen (base);\n-  temp_filename = xmalloc (len + strlen (concat (dir_separator_str, \n-                                                 \"ccXXXXXX\")) + 1);\n-  strcpy (temp_filename, base);\n-  if (len > 0 && temp_filename[len-1] != '/'\n-      && temp_filename[len-1] != DIR_SEPARATOR)\n-    temp_filename[len++] = DIR_SEPARATOR;\n-  strcpy (temp_filename + len, \"ccXXXXXX\");\n-\n-  mktemp (temp_filename);\n-  temp_filename_length = strlen (temp_filename);\n-  if (temp_filename_length == 0)\n-    abort ();\n-}\n \f\n-\n /* Routine to add variables to the environment.  We do this to pass\n    the pathname of the gcc driver, and the directories search to the\n    collect2 program, which is being run as ld.  This way, we can be\n@@ -2425,7 +2320,7 @@ process_command (argc, argv)\n \t    {\n \t      strncpy (nstore, startp, endp-startp);\n \t      if (endp == startp)\n-\t\tstrcpy (nstore, concat (\".\", dir_separator_str));\n+\t\tstrcpy (nstore, concat (\".\", dir_separator_str, NULL_PTR));\n \t      else if (endp[-1] != '/' && endp[-1] != DIR_SEPARATOR)\n \t\t{\n \t\t  nstore[endp-startp] = DIR_SEPARATOR;\n@@ -2456,7 +2351,7 @@ process_command (argc, argv)\n \t    {\n \t      strncpy (nstore, startp, endp-startp);\n \t      if (endp == startp)\n-\t\tstrcpy (nstore, concat (\".\", dir_separator_str));\n+\t\tstrcpy (nstore, concat (\".\", dir_separator_str, NULL_PTR));\n \t      else if (endp[-1] != '/' && endp[-1] != DIR_SEPARATOR)\n \t\t{\n \t\t  nstore[endp-startp] = DIR_SEPARATOR;\n@@ -2488,7 +2383,7 @@ process_command (argc, argv)\n \t    {\n \t      strncpy (nstore, startp, endp-startp);\n \t      if (endp == startp)\n-\t\tstrcpy (nstore, concat (\".\", dir_separator_str));\n+\t\tstrcpy (nstore, concat (\".\", dir_separator_str, NULL_PTR));\n \t      else if (endp[-1] != '/' && endp[-1] != DIR_SEPARATOR)\n \t\t{\n \t\t  nstore[endp-startp] = DIR_SEPARATOR;\n@@ -2680,7 +2575,7 @@ process_command (argc, argv)\n \t\t  value = p + 1;\n \t\tadd_prefix (&exec_prefixes, value, 1, 0, &warn_B);\n \t\tadd_prefix (&startfile_prefixes, value, 1, 0, &warn_B);\n-\t\tadd_prefix (&include_prefixes, concat (value, \"include\"),\n+\t\tadd_prefix (&include_prefixes, concat (value, \"include\", NULL_PTR),\n \t\t\t    1, 0, NULL_PTR);\n \n \t\t/* As a kludge, if the arg is \"[foo/]stageN/\", just add\n@@ -2779,8 +2674,8 @@ process_command (argc, argv)\n   add_prefix (&startfile_prefixes, standard_exec_prefix, 0, 1, warn_std_ptr);\n   add_prefix (&startfile_prefixes, standard_exec_prefix_1, 0, 1, warn_std_ptr);\n \n-  tooldir_prefix = concat3 (tooldir_base_prefix, spec_machine, \n-                            dir_separator_str);\n+  tooldir_prefix = concat (tooldir_base_prefix, spec_machine, \n+\t\t\t   dir_separator_str, NULL_PTR);\n \n   /* If tooldir is relative, base it on exec_prefixes.  A relative\n      tooldir lets us move the installed tree as a unit.\n@@ -2794,29 +2689,29 @@ process_command (argc, argv)\n       if (gcc_exec_prefix)\n \t{\n \t  char *gcc_exec_tooldir_prefix\n-\t    = concat6 (gcc_exec_prefix, spec_machine, dir_separator_str,\n-\t\t      spec_version, dir_separator_str, tooldir_prefix);\n+\t    = concat (gcc_exec_prefix, spec_machine, dir_separator_str,\n+\t\t      spec_version, dir_separator_str, tooldir_prefix, NULL_PTR);\n \n \t  add_prefix (&exec_prefixes,\n-\t\t      concat3 (gcc_exec_tooldir_prefix, \"bin\", \n-                               dir_separator_str),\n+\t\t      concat (gcc_exec_tooldir_prefix, \"bin\", \n+\t\t\t      dir_separator_str, NULL_PTR),\n \t\t      0, 0, NULL_PTR);\n \t  add_prefix (&startfile_prefixes,\n-\t\t      concat3 (gcc_exec_tooldir_prefix, \"lib\", \n-                               dir_separator_str),\n+\t\t      concat (gcc_exec_tooldir_prefix, \"lib\", \n+\t\t\t      dir_separator_str, NULL_PTR),\n \t\t      0, 0, NULL_PTR);\n \t}\n \n-      tooldir_prefix = concat6 (standard_exec_prefix, spec_machine,\n-\t\t\t        dir_separator_str, spec_version, \n-                                dir_separator_str, tooldir_prefix);\n+      tooldir_prefix = concat (standard_exec_prefix, spec_machine,\n+\t\t\t       dir_separator_str, spec_version, \n+\t\t\t       dir_separator_str, tooldir_prefix, NULL_PTR);\n     }\n \n   add_prefix (&exec_prefixes, \n-              concat3 (tooldir_prefix, \"bin\", dir_separator_str),\n+              concat (tooldir_prefix, \"bin\", dir_separator_str, NULL_PTR),\n \t      0, 0, NULL_PTR);\n   add_prefix (&startfile_prefixes,\n-\t      concat3 (tooldir_prefix, \"lib\", dir_separator_str),\n+\t      concat (tooldir_prefix, \"lib\", dir_separator_str, NULL_PTR),\n \t      0, 0, NULL_PTR);\n \n   /* More prefixes are enabled in main, after we read the specs file\n@@ -3376,7 +3271,8 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t    t->length = p - suffix;\n \t\t    t->suffix = save_string (suffix, p - suffix);\n \t\t    t->unique = (c != 'g');\n-\t\t    choose_temp_base ();\n+\t\t    temp_filename = choose_temp_base ();\n+\t\t    temp_filename_length = strlen (temp_filename);\n \t\t    t->filename = temp_filename;\n \t\t    t->filename_length = temp_filename_length;\n \t\t  }\n@@ -4245,12 +4141,12 @@ is_directory (path1, path2, linker)\n   /* Exclude directories that the linker is known to search.  */\n   if (linker\n       && ((cp - path == 6\n-\t   && strcmp (path, concat4 (dir_separator_str, \"lib\", \n-                                     dir_separator_str, \".\")) == 0)\n+\t   && strcmp (path, concat (dir_separator_str, \"lib\", \n+\t\t\t\t    dir_separator_str, \".\", NULL_PTR)) == 0)\n \t  || (cp - path == 10\n-\t      && strcmp (path, concat6 (dir_separator_str, \"usr\", \n-                                        dir_separator_str, \"lib\", \n-                                        dir_separator_str, \".\")) == 0)))\n+\t      && strcmp (path, concat (dir_separator_str, \"usr\", \n+\t\t\t\t       dir_separator_str, \"lib\", \n+\t\t\t\t       dir_separator_str, \".\", NULL_PTR)) == 0)))\n     return 0;\n \n   return (stat (path, &st) >= 0 && S_ISDIR (st.st_mode));\n@@ -4320,7 +4216,8 @@ main (argc, argv)\n \n   /* Choose directory for temp files.  */\n \n-  choose_temp_base ();\n+  temp_filename = choose_temp_base ();\n+  temp_filename_length = strlen (temp_filename);\n \n   /* Make a table of what switches there are (switches, n_switches).\n      Make a table of specified input files (infiles, n_infiles).\n@@ -4338,9 +4235,9 @@ main (argc, argv)\n \n   /* Read specs from a file if there is one.  */\n \n-  machine_suffix = concat4 (spec_machine, dir_separator_str,\n-                            spec_version, dir_separator_str);\n-  just_machine_suffix = concat (spec_machine, dir_separator_str);\n+  machine_suffix = concat (spec_machine, dir_separator_str,\n+\t\t\t   spec_version, dir_separator_str, NULL_PTR);\n+  just_machine_suffix = concat (spec_machine, dir_separator_str, NULL_PTR);\n \n   specs_file = find_a_file (&startfile_prefixes, \"specs\", R_OK);\n   /* Read the specs file unless it is a default one.  */\n@@ -4387,13 +4284,13 @@ main (argc, argv)\n \t{\n \t  if (gcc_exec_prefix)\n \t    add_prefix (&startfile_prefixes,\n-\t\t\tconcat3 (gcc_exec_prefix, machine_suffix,\n-\t\t\t\t standard_startfile_prefix),\n+\t\t\tconcat (gcc_exec_prefix, machine_suffix,\n+\t\t\t\tstandard_startfile_prefix, NULL_PTR),\n \t\t\t0, 0, NULL_PTR);\n \t  add_prefix (&startfile_prefixes,\n-\t\t      concat3 (standard_exec_prefix,\n-\t\t\t       machine_suffix,\n-\t\t\t       standard_startfile_prefix),\n+\t\t      concat (standard_exec_prefix,\n+\t\t\t      machine_suffix,\n+\t\t\t      standard_startfile_prefix, NULL_PTR),\n \t\t      0, 0, NULL_PTR);\n \t}\t\t       \n \n@@ -4409,8 +4306,8 @@ main (argc, argv)\n     {\n       if (*standard_startfile_prefix != DIR_SEPARATOR && gcc_exec_prefix)\n \tadd_prefix (&startfile_prefixes,\n-\t\t    concat3 (gcc_exec_prefix, machine_suffix,\n-\t\t\t     standard_startfile_prefix),\n+\t\t    concat (gcc_exec_prefix, machine_suffix,\n+\t\t\t    standard_startfile_prefix, NULL_PTR),\n \t\t    0, 0, NULL_PTR);\n     }\n \n@@ -4749,42 +4646,58 @@ xrealloc (ptr, size)\n   return value;\n }\n \n-/* Return a newly-allocated string whose contents concatenate those of s1, s2 */\n+/* This function is based on the one in libiberty.  */\n \n static char *\n-concat (s1, s2)\n-     char *s1, *s2;\n+concat VPROTO((char *first, ...))\n {\n-  int len1 = strlen (s1);\n-  int len2 = strlen (s2);\n-  char *result = xmalloc (len1 + len2 + 1);\n+  register int length;\n+  register char *newstr;\n+  register char *end;\n+  register char *arg;\n+  va_list args;\n+#ifndef __STDC__\n+  char *first;\n+#endif\n \n-  strcpy (result, s1);\n-  strcpy (result + len1, s2);\n-  *(result + len1 + len2) = 0;\n+  /* First compute the size of the result and get sufficient memory. */\n \n-  return result;\n-}\n+  VA_START (args, first);\n+#ifndef __STDC__\n+  first = va_arg (args, char *);\n+#endif\n \n-static char *\n-concat3 (s1, s2, s3)\n-     char *s1, *s2, *s3;\n-{\n-  return concat (concat (s1, s2), s3);\n-}\n+  arg = first;\n+  length = 0;\n \n-static char *\n-concat4 (s1, s2, s3, s4)\n-     char *s1, *s2, *s3, *s4;\n-{\n-  return concat (concat (s1, s2), concat (s3, s4));\n-}\n+  while (arg != 0)\n+    {\n+      length += strlen (arg);\n+      arg = va_arg (args, char *);\n+    }\n \n-static char *\n-concat6 (s1, s2, s3, s4, s5, s6)\n-     char *s1, *s2, *s3, *s4, *s5, *s6;\n-{\n-  return concat3 (concat (s1, s2), concat (s3, s4), concat (s5, s6));\n+  newstr = (char *) xmalloc (length + 1);\n+  va_end (args);\n+\n+  /* Now copy the individual pieces to the result string. */\n+\n+  VA_START (args, first);\n+#ifndef __STDC__\n+  first = va_arg (args, char *);\n+#endif\n+\n+  end = newstr;\n+  arg = first;\n+  while (arg != 0)\n+    {\n+      while (*arg)\n+\t*end++ = *arg++;\n+      arg = va_arg (args, char *);\n+    }\n+  *end = '\\000';\n+  va_end (args);\n+\n+  return (newstr);\n }\n \n static char *"}]}