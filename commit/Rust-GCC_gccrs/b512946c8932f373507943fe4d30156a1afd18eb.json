{"sha": "b512946c8932f373507943fe4d30156a1afd18eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjUxMjk0NmM4OTMyZjM3MzUwNzk0M2ZlNGQzMDE1NmExYWZkMThlYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2014-06-15T07:39:30Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2014-06-15T07:39:30Z"}, "message": "df.h (df_mw_hardreg, [...]): Add a link pointer.\n\ngcc/\n\t* df.h (df_mw_hardreg, df_base_ref): Add a link pointer.\n\t(df_insn_info): Turn defs, uses, eq_uses and mw_hardregs into linked\n\tlists.\n\t(df_scan_bb_info): Likewise artificial_defs and artificial_uses.\n\t(DF_REF_NEXT_LOC, DF_MWS_NEXT): New macros.\n\t(FOR_EACH_INSN_INFO_DEF, FOR_EACH_INSN_INFO_USE)\n\t(FOR_EACH_INSN_INFO_EQ_USE, FOR_EACH_INSN_INFO_MW)\n\t(FOR_EACH_ARTIFICIAL_USE, FOR_EACH_ARTIFICIAL_DEF)\n\t(df_get_artificial_defs, df_get_artificial_uses)\n\t(df_single_def, df_single_use): Update accordingly.\n\t(df_refs_chain_dump): Take the first element in a linked list as\n\tparameter, rather than a pointer to an array of pointers.\n\t* df-core.c (df_refs_chain_dump, df_mws_dump): Likewise.\n\t* df-problems.c (df_rd_bb_local_compute_process_def): Likewise.\n\t(df_chain_create_bb_process_use): Likewise.\n\t(df_md_bb_local_compute_process_def): Likewise.\n\t* fwprop.c (process_defs, process_uses): Likewise.\n\t(register_active_defs, update_uses): Likewise.\n\t(forward_propagate_asm): Update for new df_ref linking.\n\t* df-scan.c (df_scan_free_ref_vec, df_scan_free_mws_vec): Delete.\n\t(df_null_ref_rec, df_null_mw_rec): Likewise.\n\t(df_scan_free_internal): Don't free df_ref and df_mw_hardreg lists\n\texplicitly.\n\t(df_scan_free_bb_info): Remove check for null artificial_defs.\n\t(df_install_ref_incremental): Adjust for new df_ref linking.\n\tUse a single-element insertion rather than a full sort.\n\t(df_ref_chain_delete_du_chain): Take the first element\n\tin a linked list as parameter, rather than a pointer to an array of\n\tpointers.\n\t(df_ref_chain_delete, df_mw_hardreg_chain_delete): Likewise.\n\t(df_add_refs_to_table, df_refs_verify, df_mws_verify): Likewise.\n\t(df_insn_info_delete): Remove check for null defs and call to\n\tdf_scan_free_mws_vec.\n\t(df_insn_rescan): Initialize df_ref and df_mw_hardreg lists to\n\tnull rather than df_null_*_rec.\n\t(df_insn_rescan_debug_internal): Likewise, and update null\n\tchecks in the same way.  Remove check for null defs.\n\t(df_ref_change_reg_with_loc_1): Fix choice of list for defs.\n\tMove a single element rather doing a full sort.\n\t(df_mw_hardreg_chain_delete_eq_uses): Adjust for new df_mw_hardreg\n\tlinking.\n\t(df_notes_rescan): Likewise.  Use a merge rather than a full sort.\n\tInitialize df_ref and df_mw_hardreg lists to null rather than\n\tdf_null_*_rec.\n\t(df_ref_compare): Take df_refs as parameter, transferring the\n\told interface to...\n\t(df_ref_ptr_compare): ...this new function.\n\t(df_sort_and_compress_refs): Update accordingly.\n\t(df_mw_compare): Take df_mw_hardregs as parameter, transferring the\n\told interface to...\n\t(df_mw_ptr_compare): ...this new function.\n\t(df_sort_and_compress_mws): Update accordingly.\n\t(df_install_refs, df_install_mws): Return a linked list rather than\n\tan array of pointers.\n\t(df_refs_add_to_chains): Assert that old lists are empty rather\n\tthan freeing them.\n\t(df_insn_refs_verify): Don't handle null defs speciailly.\n\t* web.c (union_match_dups): Update for new df_ref linking.\n\nFrom-SVN: r211683", "tree": {"sha": "c9cc0c7a93ee539a01637eb16e85ac19667e3c9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9cc0c7a93ee539a01637eb16e85ac19667e3c9b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b512946c8932f373507943fe4d30156a1afd18eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b512946c8932f373507943fe4d30156a1afd18eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b512946c8932f373507943fe4d30156a1afd18eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b512946c8932f373507943fe4d30156a1afd18eb/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5a474220d931fa67d58c5a1ce0e797b6834ac8f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a474220d931fa67d58c5a1ce0e797b6834ac8f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a474220d931fa67d58c5a1ce0e797b6834ac8f0"}], "stats": {"total": 725, "additions": 313, "deletions": 412}, "files": [{"sha": "eeda7d65504dcfc4a11239ac2fbf2ed37a568d28", "filename": "gcc/ChangeLog", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b512946c8932f373507943fe4d30156a1afd18eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b512946c8932f373507943fe4d30156a1afd18eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b512946c8932f373507943fe4d30156a1afd18eb", "patch": "@@ -1,3 +1,64 @@\n+2014-06-15  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* df.h (df_mw_hardreg, df_base_ref): Add a link pointer.\n+\t(df_insn_info): Turn defs, uses, eq_uses and mw_hardregs into linked\n+\tlists.\n+\t(df_scan_bb_info): Likewise artificial_defs and artificial_uses.\n+\t(DF_REF_NEXT_LOC, DF_MWS_NEXT): New macros.\n+\t(FOR_EACH_INSN_INFO_DEF, FOR_EACH_INSN_INFO_USE)\n+\t(FOR_EACH_INSN_INFO_EQ_USE, FOR_EACH_INSN_INFO_MW)\n+\t(FOR_EACH_ARTIFICIAL_USE, FOR_EACH_ARTIFICIAL_DEF)\n+\t(df_get_artificial_defs, df_get_artificial_uses)\n+\t(df_single_def, df_single_use): Update accordingly.\n+\t(df_refs_chain_dump): Take the first element in a linked list as\n+\tparameter, rather than a pointer to an array of pointers.\n+\t* df-core.c (df_refs_chain_dump, df_mws_dump): Likewise.\n+\t* df-problems.c (df_rd_bb_local_compute_process_def): Likewise.\n+\t(df_chain_create_bb_process_use): Likewise.\n+\t(df_md_bb_local_compute_process_def): Likewise.\n+\t* fwprop.c (process_defs, process_uses): Likewise.\n+\t(register_active_defs, update_uses): Likewise.\n+\t(forward_propagate_asm): Update for new df_ref linking.\n+\t* df-scan.c (df_scan_free_ref_vec, df_scan_free_mws_vec): Delete.\n+\t(df_null_ref_rec, df_null_mw_rec): Likewise.\n+\t(df_scan_free_internal): Don't free df_ref and df_mw_hardreg lists\n+\texplicitly.\n+\t(df_scan_free_bb_info): Remove check for null artificial_defs.\n+\t(df_install_ref_incremental): Adjust for new df_ref linking.\n+\tUse a single-element insertion rather than a full sort.\n+\t(df_ref_chain_delete_du_chain): Take the first element\n+\tin a linked list as parameter, rather than a pointer to an array of\n+\tpointers.\n+\t(df_ref_chain_delete, df_mw_hardreg_chain_delete): Likewise.\n+\t(df_add_refs_to_table, df_refs_verify, df_mws_verify): Likewise.\n+\t(df_insn_info_delete): Remove check for null defs and call to\n+\tdf_scan_free_mws_vec.\n+\t(df_insn_rescan): Initialize df_ref and df_mw_hardreg lists to\n+\tnull rather than df_null_*_rec.\n+\t(df_insn_rescan_debug_internal): Likewise, and update null\n+\tchecks in the same way.  Remove check for null defs.\n+\t(df_ref_change_reg_with_loc_1): Fix choice of list for defs.\n+\tMove a single element rather doing a full sort.\n+\t(df_mw_hardreg_chain_delete_eq_uses): Adjust for new df_mw_hardreg\n+\tlinking.\n+\t(df_notes_rescan): Likewise.  Use a merge rather than a full sort.\n+\tInitialize df_ref and df_mw_hardreg lists to null rather than\n+\tdf_null_*_rec.\n+\t(df_ref_compare): Take df_refs as parameter, transferring the\n+\told interface to...\n+\t(df_ref_ptr_compare): ...this new function.\n+\t(df_sort_and_compress_refs): Update accordingly.\n+\t(df_mw_compare): Take df_mw_hardregs as parameter, transferring the\n+\told interface to...\n+\t(df_mw_ptr_compare): ...this new function.\n+\t(df_sort_and_compress_mws): Update accordingly.\n+\t(df_install_refs, df_install_mws): Return a linked list rather than\n+\tan array of pointers.\n+\t(df_refs_add_to_chains): Assert that old lists are empty rather\n+\tthan freeing them.\n+\t(df_insn_refs_verify): Don't handle null defs speciailly.\n+\t* web.c (union_match_dups): Update for new df_ref linking.\n+\n 2014-06-15  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* df.h (df_ref_create, df_ref_remove): Delete."}, {"sha": "074b320b399bf34297bcc3f0248b7521edaf8b49", "filename": "gcc/df-core.c", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b512946c8932f373507943fe4d30156a1afd18eb/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b512946c8932f373507943fe4d30156a1afd18eb/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=b512946c8932f373507943fe4d30156a1afd18eb", "patch": "@@ -2319,16 +2319,14 @@ df_ref_dump (df_ref ref, FILE *file)\n }\n \n void\n-df_refs_chain_dump (df_ref *ref_rec, bool follow_chain, FILE *file)\n+df_refs_chain_dump (df_ref ref, bool follow_chain, FILE *file)\n {\n   fprintf (file, \"{ \");\n-  while (*ref_rec)\n+  for (; ref; ref = DF_REF_NEXT_LOC (ref))\n     {\n-      df_ref ref = *ref_rec;\n       df_ref_dump (ref, file);\n       if (follow_chain)\n \tdf_chain_dump (DF_REF_CHAIN (ref), file);\n-      ref_rec++;\n     }\n   fprintf (file, \"}\");\n }\n@@ -2350,15 +2348,12 @@ df_regs_chain_dump (df_ref ref,  FILE *file)\n \n \n static void\n-df_mws_dump (struct df_mw_hardreg **mws, FILE *file)\n+df_mws_dump (struct df_mw_hardreg *mws, FILE *file)\n {\n-  while (*mws)\n-    {\n-      fprintf (file, \"mw %c r[%d..%d]\\n\",\n-\t       (DF_MWS_REG_DEF_P (*mws)) ? 'd' : 'u',\n-\t       (*mws)->start_regno, (*mws)->end_regno);\n-      mws++;\n-    }\n+  for (; mws; mws = DF_MWS_NEXT (mws))\n+    fprintf (file, \"mw %c r[%d..%d]\\n\",\n+\t     DF_MWS_REG_DEF_P (mws) ? 'd' : 'u',\n+\t     mws->start_regno, mws->end_regno);\n }\n \n "}, {"sha": "e8248659a776d5281c1226e306c124c6e3f9457c", "filename": "gcc/df-problems.c", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b512946c8932f373507943fe4d30156a1afd18eb/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b512946c8932f373507943fe4d30156a1afd18eb/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=b512946c8932f373507943fe4d30156a1afd18eb", "patch": "@@ -291,12 +291,11 @@ df_rd_simulate_one_insn (basic_block bb ATTRIBUTE_UNUSED, rtx insn,\n \n static void\n df_rd_bb_local_compute_process_def (struct df_rd_bb_info *bb_info,\n-\t\t\t\t    df_ref *def_rec,\n+\t\t\t\t    df_ref def,\n \t\t\t\t    int top_flag)\n {\n-  while (*def_rec)\n+  for (; def; def = DF_REF_NEXT_LOC (def))\n     {\n-      df_ref def = *def_rec;\n       if (top_flag == (DF_REF_FLAGS (def) & DF_REF_AT_TOP))\n \t{\n \t  unsigned int regno = DF_REF_REGNO (def);\n@@ -339,7 +338,6 @@ df_rd_bb_local_compute_process_def (struct df_rd_bb_info *bb_info,\n \t\t}\n \t    }\n \t}\n-      def_rec++;\n     }\n }\n \n@@ -2022,15 +2020,14 @@ df_chain_reset (bitmap blocks_to_clear ATTRIBUTE_UNUSED)\n \n static void\n df_chain_create_bb_process_use (bitmap local_rd,\n-\t\t\t\tdf_ref *use_rec,\n+\t\t\t\tdf_ref use,\n \t\t\t\tint top_flag)\n {\n   bitmap_iterator bi;\n   unsigned int def_index;\n \n-  while (*use_rec)\n+  for (; use; use = DF_REF_NEXT_LOC (use))\n     {\n-      df_ref use = *use_rec;\n       unsigned int uregno = DF_REF_REGNO (use);\n       if ((!(df->changeable_flags & DF_NO_HARD_REGS))\n \t  || (uregno >= FIRST_PSEUDO_REGISTER))\n@@ -2059,8 +2056,6 @@ df_chain_create_bb_process_use (bitmap local_rd,\n \t\t}\n \t    }\n \t}\n-\n-      use_rec++;\n     }\n }\n \n@@ -4077,13 +4072,12 @@ df_md_simulate_one_insn (basic_block bb ATTRIBUTE_UNUSED, rtx insn,\n \n static void\n df_md_bb_local_compute_process_def (struct df_md_bb_info *bb_info,\n-                                    df_ref *def_rec,\n+                                    df_ref def,\n                                     int top_flag)\n {\n-  df_ref def;\n   bitmap_clear (&seen_in_insn);\n \n-  while ((def = *def_rec++) != NULL)\n+  for (; def; def = DF_REF_NEXT_LOC (def))\n     {\n       unsigned int dregno = DF_REF_REGNO (def);\n       if (((!(df->changeable_flags & DF_NO_HARD_REGS))"}, {"sha": "f1ba808c258688dc40fea2a2d9bea63ed88906da", "filename": "gcc/df-scan.c", "status": "modified", "additions": 181, "deletions": 328, "changes": 509, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b512946c8932f373507943fe4d30156a1afd18eb/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b512946c8932f373507943fe4d30156a1afd18eb/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=b512946c8932f373507943fe4d30156a1afd18eb", "patch": "@@ -62,21 +62,6 @@ typedef struct df_mw_hardreg *df_mw_hardreg_ptr;\n #define EPILOGUE_USES(REGNO)  0\n #endif\n \n-/* The following two macros free the vecs that hold either the refs or\n-   the mw refs.  They are a little tricky because the vec has 0\n-   elements is special and is not to be freed.  */\n-#define df_scan_free_ref_vec(V) \\\n-  do { \\\n-    if (V && *V) \\\n-      free (V);  \\\n-  } while (0)\n-\n-#define df_scan_free_mws_vec(V) \\\n-  do { \\\n-    if (V && *V) \\\n-      free (V);  \\\n-  } while (0)\n-\n /* The set of hard registers in eliminables[i].from. */\n \n static HARD_REG_SET elim_reg_set;\n@@ -92,9 +77,6 @@ struct df_collection_rec\n   auto_vec<df_mw_hardreg_ptr, 32> mw_vec;\n };\n \n-static df_ref df_null_ref_rec[1];\n-static struct df_mw_hardreg * df_null_mw_rec[1];\n-\n static void df_ref_record (enum df_ref_class, struct df_collection_rec *,\n \t\t\t   rtx, rtx *,\n \t\t\t   basic_block, struct df_insn_info *,\n@@ -123,8 +105,8 @@ static void df_record_exit_block_uses (bitmap);\n static void df_get_exit_block_use_set (bitmap);\n static void df_get_entry_block_def_set (bitmap);\n static void df_grow_ref_info (struct df_ref_info *, unsigned int);\n-static void df_ref_chain_delete_du_chain (df_ref *);\n-static void df_ref_chain_delete (df_ref *);\n+static void df_ref_chain_delete_du_chain (df_ref);\n+static void df_ref_chain_delete (df_ref);\n \n static void df_refs_add_to_chains (struct df_collection_rec *,\n \t\t\t\t   basic_block, rtx, unsigned int);\n@@ -135,8 +117,10 @@ static void df_exit_block_uses_collect (struct df_collection_rec *, bitmap);\n static void df_install_ref (df_ref, struct df_reg_info *,\n \t\t\t    struct df_ref_info *, bool);\n \n-static int df_ref_compare (const void *, const void *);\n-static int df_mw_compare (const void *, const void *);\n+static int df_ref_compare (df_ref, df_ref);\n+static int df_ref_ptr_compare (const void *, const void *);\n+static int df_mw_compare (const df_mw_hardreg *, const df_mw_hardreg *);\n+static int df_mw_ptr_compare (const void *, const void *);\n \n static void df_insn_info_delete (unsigned int);\n \n@@ -189,36 +173,6 @@ df_scan_free_internal (void)\n {\n   struct df_scan_problem_data *problem_data\n     = (struct df_scan_problem_data *) df_scan->problem_data;\n-  unsigned int i;\n-  basic_block bb;\n-\n-  /* The vectors that hold the refs are not pool allocated because\n-     they come in many sizes.  This makes them impossible to delete\n-     all at once.  */\n-  for (i = 0; i < DF_INSN_SIZE (); i++)\n-    {\n-      struct df_insn_info *insn_info = DF_INSN_UID_GET (i);\n-      /* Skip the insns that have no insn_info or have been\n-\t deleted.  */\n-      if (insn_info)\n-\t{\n-\t  df_scan_free_ref_vec (insn_info->defs);\n-\t  df_scan_free_ref_vec (insn_info->uses);\n-\t  df_scan_free_ref_vec (insn_info->eq_uses);\n-\t  df_scan_free_mws_vec (insn_info->mw_hardregs);\n-\t}\n-    }\n-\n-  FOR_ALL_BB_FN (bb, cfun)\n-    {\n-      unsigned int bb_index = bb->index;\n-      struct df_scan_bb_info *bb_info = df_scan_get_bb_info (bb_index);\n-      if (bb_info)\n-\t{\n-\t  df_scan_free_ref_vec (bb_info->artificial_defs);\n-\t  df_scan_free_ref_vec (bb_info->artificial_uses);\n-\t}\n-    }\n \n   free (df->def_info.refs);\n   free (df->def_info.begin);\n@@ -275,31 +229,22 @@ df_scan_free_bb_info (basic_block bb, void *vbb_info)\n {\n   struct df_scan_bb_info *bb_info = (struct df_scan_bb_info *) vbb_info;\n   unsigned int bb_index = bb->index;\n+  rtx insn;\n \n-  /* See if bb_info is initialized.  */\n-  if (bb_info->artificial_defs)\n-    {\n-      rtx insn;\n-      FOR_BB_INSNS (bb, insn)\n-\t{\n-\t  if (INSN_P (insn))\n-\t    df_insn_info_delete (INSN_UID (insn));\n-\t}\n-\n-      if (bb_index < df_scan->block_info_size)\n-\tbb_info = df_scan_get_bb_info (bb_index);\n-\n-      /* Get rid of any artificial uses or defs.  */\n-      if (bb_info->artificial_defs)\n-\t{\n-\t  df_ref_chain_delete_du_chain (bb_info->artificial_defs);\n-\t  df_ref_chain_delete_du_chain (bb_info->artificial_uses);\n-\t  df_ref_chain_delete (bb_info->artificial_defs);\n-\t  df_ref_chain_delete (bb_info->artificial_uses);\n-\t  bb_info->artificial_defs = NULL;\n-\t  bb_info->artificial_uses = NULL;\n-\t}\n-    }\n+  FOR_BB_INSNS (bb, insn)\n+    if (INSN_P (insn))\n+      df_insn_info_delete (INSN_UID (insn));\n+\n+  if (bb_index < df_scan->block_info_size)\n+    bb_info = df_scan_get_bb_info (bb_index);\n+\n+  /* Get rid of any artificial uses or defs.  */\n+  df_ref_chain_delete_du_chain (bb_info->artificial_defs);\n+  df_ref_chain_delete_du_chain (bb_info->artificial_uses);\n+  df_ref_chain_delete (bb_info->artificial_defs);\n+  df_ref_chain_delete (bb_info->artificial_uses);\n+  bb_info->artificial_defs = NULL;\n+  bb_info->artificial_uses = NULL;\n }\n \n \n@@ -695,9 +640,7 @@ df_install_ref_incremental (df_ref ref)\n {\n   struct df_reg_info **reg_info;\n   struct df_ref_info *ref_info;\n-  df_ref *ref_rec;\n-  df_ref **ref_rec_ptr;\n-  unsigned int count = 0;\n+  df_ref *ref_ptr;\n   bool add_to_table;\n \n   rtx insn = DF_REF_INSN (ref);\n@@ -707,14 +650,14 @@ df_install_ref_incremental (df_ref ref)\n     {\n       reg_info = df->def_regs;\n       ref_info = &df->def_info;\n-      ref_rec_ptr = &DF_INSN_DEFS (insn);\n+      ref_ptr = &DF_INSN_DEFS (insn);\n       add_to_table = ref_info->ref_order != DF_REF_ORDER_NO_TABLE;\n     }\n   else if (DF_REF_FLAGS (ref) & DF_REF_IN_NOTE)\n     {\n       reg_info = df->eq_use_regs;\n       ref_info = &df->use_info;\n-      ref_rec_ptr = &DF_INSN_EQ_USES (insn);\n+      ref_ptr = &DF_INSN_EQ_USES (insn);\n       switch (ref_info->ref_order)\n \t{\n \tcase DF_REF_ORDER_UNORDERED_WITH_NOTES:\n@@ -731,7 +674,7 @@ df_install_ref_incremental (df_ref ref)\n     {\n       reg_info = df->use_regs;\n       ref_info = &df->use_info;\n-      ref_rec_ptr = &DF_INSN_USES (insn);\n+      ref_ptr = &DF_INSN_USES (insn);\n       add_to_table = ref_info->ref_order != DF_REF_ORDER_NO_TABLE;\n     }\n \n@@ -754,29 +697,11 @@ df_install_ref_incremental (df_ref ref)\n \tbreak;\n       }\n \n-  ref_rec = *ref_rec_ptr;\n-  while (*ref_rec)\n-    {\n-      count++;\n-      ref_rec++;\n-    }\n+  while (*ref_ptr && df_ref_compare (*ref_ptr, ref) < 0)\n+    ref_ptr = &DF_REF_NEXT_LOC (*ref_ptr);\n \n-  ref_rec = *ref_rec_ptr;\n-  if (count)\n-    {\n-      ref_rec = XRESIZEVEC (df_ref, ref_rec, count+2);\n-      *ref_rec_ptr = ref_rec;\n-      ref_rec[count] = ref;\n-      ref_rec[count+1] = NULL;\n-      qsort (ref_rec, count + 1, sizeof (df_ref), df_ref_compare);\n-    }\n-  else\n-    {\n-      df_ref *ref_rec = XNEWVEC (df_ref, 2);\n-      ref_rec[0] = ref;\n-      ref_rec[1] = NULL;\n-      *ref_rec_ptr = ref_rec;\n-    }\n+  DF_REF_NEXT_LOC (ref) = *ref_ptr;\n+  *ref_ptr = ref;\n \n #if 0\n   if (dump_file)\n@@ -930,55 +855,43 @@ df_insn_create_insn_record (rtx insn)\n /* Delete all du chain (DF_REF_CHAIN()) of all refs in the ref chain.  */\n \n static void\n-df_ref_chain_delete_du_chain (df_ref *ref_rec)\n+df_ref_chain_delete_du_chain (df_ref ref)\n {\n-  while (*ref_rec)\n-    {\n-      df_ref ref = *ref_rec;\n-      /* CHAIN is allocated by DF_CHAIN. So make sure to\n-         pass df_scan instance for the problem.  */\n-      if (DF_REF_CHAIN (ref))\n-        df_chain_unlink (ref);\n-      ref_rec++;\n-    }\n+  for (; ref; ref = DF_REF_NEXT_LOC (ref))\n+    /* CHAIN is allocated by DF_CHAIN. So make sure to\n+       pass df_scan instance for the problem.  */\n+    if (DF_REF_CHAIN (ref))\n+      df_chain_unlink (ref);\n }\n \n \n /* Delete all refs in the ref chain.  */\n \n static void\n-df_ref_chain_delete (df_ref *ref_rec)\n+df_ref_chain_delete (df_ref ref)\n {\n-  df_ref *start = ref_rec;\n-  while (*ref_rec)\n+  df_ref next;\n+  for (; ref; ref = next)\n     {\n-      df_reg_chain_unlink (*ref_rec);\n-      ref_rec++;\n+      next = DF_REF_NEXT_LOC (ref);\n+      df_reg_chain_unlink (ref);\n     }\n-\n-  /* If the list is empty, it has a special shared element that is not\n-     to be deleted.  */\n-  if (*start)\n-    free (start);\n }\n \n \n /* Delete the hardreg chain.  */\n \n static void\n-df_mw_hardreg_chain_delete (struct df_mw_hardreg **hardregs)\n+df_mw_hardreg_chain_delete (struct df_mw_hardreg *hardregs)\n {\n-  struct df_scan_problem_data *problem_data;\n-\n-  if (!hardregs)\n-    return;\n-\n-  problem_data = (struct df_scan_problem_data *) df_scan->problem_data;\n+  struct df_scan_problem_data *problem_data\n+    = (struct df_scan_problem_data *) df_scan->problem_data;\n+  df_mw_hardreg *next;\n \n-  while (*hardregs)\n+  for (; hardregs; hardregs = next)\n     {\n-      pool_free (problem_data->mw_reg_pool, *hardregs);\n-      hardregs++;\n+      next = DF_MWS_NEXT (hardregs);\n+      pool_free (problem_data->mw_reg_pool, hardregs);\n     }\n }\n \n@@ -1006,22 +919,19 @@ df_insn_info_delete (unsigned int uid)\n \t to notes.  How clever.  So we cannot just check if it is a\n \t valid insn before short circuiting this code, we need to see\n \t if we actually initialized it.  */\n-      if (insn_info->defs)\n+      df_mw_hardreg_chain_delete (insn_info->mw_hardregs);\n+\n+      if (df_chain)\n \t{\n-\t  df_mw_hardreg_chain_delete (insn_info->mw_hardregs);\n+\t  df_ref_chain_delete_du_chain (insn_info->defs);\n+\t  df_ref_chain_delete_du_chain (insn_info->uses);\n+\t  df_ref_chain_delete_du_chain (insn_info->eq_uses);\n+\t}\n \n-\t  if (df_chain)\n-\t    {\n-\t      df_ref_chain_delete_du_chain (insn_info->defs);\n-\t      df_ref_chain_delete_du_chain (insn_info->uses);\n-\t      df_ref_chain_delete_du_chain (insn_info->eq_uses);\n-\t    }\n+      df_ref_chain_delete (insn_info->defs);\n+      df_ref_chain_delete (insn_info->uses);\n+      df_ref_chain_delete (insn_info->eq_uses);\n \n-\t  df_ref_chain_delete (insn_info->defs);\n-\t  df_ref_chain_delete (insn_info->uses);\n-\t  df_ref_chain_delete (insn_info->eq_uses);\n-\t  df_scan_free_mws_vec (insn_info->mw_hardregs);\n-\t}\n       pool_free (problem_data->insn_pool, insn_info);\n       DF_INSN_UID_SET (uid, NULL);\n     }\n@@ -1149,10 +1059,10 @@ df_insn_rescan (rtx insn)\n       if (!insn_info)\n \t{\n \t  insn_info = df_insn_create_insn_record (insn);\n-\t  insn_info->defs = df_null_ref_rec;\n-\t  insn_info->uses = df_null_ref_rec;\n-\t  insn_info->eq_uses = df_null_ref_rec;\n-\t  insn_info->mw_hardregs = df_null_mw_rec;\n+\t  insn_info->defs = 0;\n+\t  insn_info->uses = 0;\n+\t  insn_info->eq_uses = 0;\n+\t  insn_info->mw_hardregs = 0;\n \t}\n       if (dump_file)\n \tfprintf (dump_file, \"deferring rescan insn with uid = %d.\\n\", uid);\n@@ -1229,13 +1139,10 @@ df_insn_rescan_debug_internal (rtx insn)\n   bitmap_clear_bit (&df->insns_to_rescan, uid);\n   bitmap_clear_bit (&df->insns_to_notes_rescan, uid);\n \n-  if (!insn_info->defs)\n-    return false;\n-\n-  if (insn_info->defs == df_null_ref_rec\n-      && insn_info->uses == df_null_ref_rec\n-      && insn_info->eq_uses == df_null_ref_rec\n-      && insn_info->mw_hardregs == df_null_mw_rec)\n+  if (insn_info->defs == 0\n+      && insn_info->uses == 0\n+      && insn_info->eq_uses == 0\n+      && insn_info->mw_hardregs == 0)\n     return false;\n \n   df_mw_hardreg_chain_delete (insn_info->mw_hardregs);\n@@ -1250,12 +1157,11 @@ df_insn_rescan_debug_internal (rtx insn)\n   df_ref_chain_delete (insn_info->defs);\n   df_ref_chain_delete (insn_info->uses);\n   df_ref_chain_delete (insn_info->eq_uses);\n-  df_scan_free_mws_vec (insn_info->mw_hardregs);\n \n-  insn_info->defs = df_null_ref_rec;\n-  insn_info->uses = df_null_ref_rec;\n-  insn_info->eq_uses = df_null_ref_rec;\n-  insn_info->mw_hardregs = df_null_mw_rec;\n+  insn_info->defs = 0;\n+  insn_info->uses = 0;\n+  insn_info->eq_uses = 0;\n+  insn_info->mw_hardregs = 0;\n \n   return true;\n }\n@@ -1682,19 +1588,15 @@ df_reorganize_refs_by_reg (struct df_ref_info *ref_info,\n static unsigned int\n df_add_refs_to_table (unsigned int offset,\n \t\t      struct df_ref_info *ref_info,\n-\t\t      df_ref *ref_vec)\n+\t\t      df_ref ref)\n {\n-  while (*ref_vec)\n-    {\n-      df_ref ref = *ref_vec;\n-      if ((!(df->changeable_flags & DF_NO_HARD_REGS))\n-\t  || (DF_REF_REGNO (ref) >= FIRST_PSEUDO_REGISTER))\n-\t{\n-\t  ref_info->refs[offset] = ref;\n-\t  DF_REF_ID (*ref_vec) = offset++;\n-\t}\n-      ref_vec++;\n-    }\n+  for (; ref; ref = DF_REF_NEXT_LOC (ref))\n+    if (!(df->changeable_flags & DF_NO_HARD_REGS)\n+\t|| (DF_REF_REGNO (ref) >= FIRST_PSEUDO_REGISTER))\n+      {\n+\tref_info->refs[offset] = ref;\n+\tDF_REF_ID (ref) = offset++;\n+      }\n   return offset;\n }\n \n@@ -1921,9 +1823,8 @@ df_ref_change_reg_with_loc_1 (struct df_reg_info *old_df,\n \t{\n \t  df_ref next_ref = DF_REF_NEXT_REG (the_ref);\n \t  df_ref prev_ref = DF_REF_PREV_REG (the_ref);\n-\t  df_ref *ref_vec, *ref_vec_t;\n+\t  df_ref *ref_ptr;\n \t  struct df_insn_info *insn_info = DF_REF_INSN_INFO (the_ref);\n-\t  unsigned int count = 0;\n \n \t  DF_REF_REGNO (the_ref) = new_regno;\n \t  DF_REF_REG (the_ref) = regno_reg_rtx[new_regno];\n@@ -1950,23 +1851,42 @@ df_ref_change_reg_with_loc_1 (struct df_reg_info *old_df,\n \t  /* Need to sort the record again that the ref was in because\n \t     the regno is a sorting key.  First, find the right\n \t     record.  */\n-\t  if (DF_REF_FLAGS (the_ref) & DF_REF_IN_NOTE)\n-\t    ref_vec = insn_info->eq_uses;\n+\t  if (DF_REF_REG_DEF_P (the_ref))\n+\t    ref_ptr = &insn_info->defs;\n+\t  else if (DF_REF_FLAGS (the_ref) & DF_REF_IN_NOTE)\n+\t    ref_ptr = &insn_info->eq_uses;\n \t  else\n-\t    ref_vec = insn_info->uses;\n+\t    ref_ptr = &insn_info->uses;\n \t  if (dump_file)\n \t    fprintf (dump_file, \"changing reg in insn %d\\n\",\n \t\t     DF_REF_INSN_UID (the_ref));\n \n-\t  ref_vec_t = ref_vec;\n-\n-\t  /* Find the length.  */\n-\t  while (*ref_vec_t)\n+\t  /* Stop if we find the current reference or where the reference\n+\t     needs to be.  */\n+\t  while (*ref_ptr != the_ref && df_ref_compare (*ref_ptr, the_ref) < 0)\n+\t    ref_ptr = &DF_REF_NEXT_LOC (*ref_ptr);\n+\t  if (*ref_ptr != the_ref)\n \t    {\n-\t      count++;\n-\t      ref_vec_t++;\n+\t      /* The reference needs to be promoted up the list.  */\n+\t      df_ref next = DF_REF_NEXT_LOC (the_ref);\n+\t      DF_REF_NEXT_LOC (the_ref) = *ref_ptr;\n+\t      *ref_ptr = the_ref;\n+\t      do\n+\t\tref_ptr = &DF_REF_NEXT_LOC (*ref_ptr);\n+\t      while (*ref_ptr != the_ref);\n+\t      *ref_ptr = next;\n+\t    }\n+\t  else if (DF_REF_NEXT_LOC (the_ref)\n+\t\t   && df_ref_compare (the_ref, DF_REF_NEXT_LOC (the_ref)) > 0)\n+\t    {\n+\t      /* The reference needs to be demoted down the list.  */\n+\t      *ref_ptr = DF_REF_NEXT_LOC (the_ref);\n+\t      do\n+\t\tref_ptr = &DF_REF_NEXT_LOC (*ref_ptr);\n+\t      while (*ref_ptr && df_ref_compare (the_ref, *ref_ptr) > 0);\n+\t      DF_REF_NEXT_LOC (the_ref) = *ref_ptr;\n+\t      *ref_ptr = the_ref;\n \t    }\n-\t  qsort (ref_vec, count, sizeof (df_ref ), df_ref_compare);\n \n \t  the_ref = next_ref;\n \t}\n@@ -2000,51 +1920,24 @@ df_ref_change_reg_with_loc (int old_regno, int new_regno, rtx loc)\n \n /* Delete the mw_hardregs that point into the eq_notes.  */\n \n-static unsigned int\n+static void\n df_mw_hardreg_chain_delete_eq_uses (struct df_insn_info *insn_info)\n {\n-  struct df_mw_hardreg **mw_vec = insn_info->mw_hardregs;\n-  unsigned int deleted = 0;\n-  unsigned int count = 0;\n+  struct df_mw_hardreg **mw_ptr = &insn_info->mw_hardregs;\n   struct df_scan_problem_data *problem_data\n     = (struct df_scan_problem_data *) df_scan->problem_data;\n \n-  if (!*mw_vec)\n-    return 0;\n-\n-  while (*mw_vec)\n+  while (*mw_ptr)\n     {\n-      if ((*mw_vec)->flags & DF_REF_IN_NOTE)\n+      df_mw_hardreg *mw = *mw_ptr;\n+      if (mw->flags & DF_REF_IN_NOTE)\n \t{\n-\t  struct df_mw_hardreg **temp_vec = mw_vec;\n-\n-\t  pool_free (problem_data->mw_reg_pool, *mw_vec);\n-\t  temp_vec = mw_vec;\n-\t  /* Shove the remaining ones down one to fill the gap.  While\n-\t     this looks n**2, it is highly unusual to have any mw regs\n-\t     in eq_notes and the chances of more than one are almost\n-\t     non existent.  */\n-\t  while (*temp_vec)\n-\t    {\n-\t      *temp_vec = *(temp_vec + 1);\n-\t      temp_vec++;\n-\t    }\n-\t  deleted++;\n+\t  *mw_ptr = DF_MWS_NEXT (mw);\n+\t  pool_free (problem_data->mw_reg_pool, mw);\n \t}\n       else\n-\t{\n-\t  mw_vec++;\n-\t  count++;\n-\t}\n+\tmw_ptr = &DF_MWS_NEXT (mw);\n     }\n-\n-  if (count == 0)\n-    {\n-      df_scan_free_mws_vec (insn_info->mw_hardregs);\n-      insn_info->mw_hardregs = df_null_mw_rec;\n-      return 0;\n-    }\n-  return deleted;\n }\n \n \n@@ -2078,10 +1971,10 @@ df_notes_rescan (rtx insn)\n       if (!insn_info)\n \t{\n \t  insn_info = df_insn_create_insn_record (insn);\n-\t  insn_info->defs = df_null_ref_rec;\n-\t  insn_info->uses = df_null_ref_rec;\n-\t  insn_info->eq_uses = df_null_ref_rec;\n-\t  insn_info->mw_hardregs = df_null_mw_rec;\n+\t  insn_info->defs = 0;\n+\t  insn_info->uses = 0;\n+\t  insn_info->eq_uses = 0;\n+\t  insn_info->mw_hardregs = 0;\n \t}\n \n       bitmap_clear_bit (&df->insns_to_delete, uid);\n@@ -2100,10 +1993,9 @@ df_notes_rescan (rtx insn)\n       basic_block bb = BLOCK_FOR_INSN (insn);\n       rtx note;\n       struct df_collection_rec collection_rec;\n-      unsigned int num_deleted;\n-      unsigned int mw_len;\n+      unsigned int i;\n \n-      num_deleted = df_mw_hardreg_chain_delete_eq_uses (insn_info);\n+      df_mw_hardreg_chain_delete_eq_uses (insn_info);\n       df_ref_chain_delete (insn_info->eq_uses);\n       insn_info->eq_uses = NULL;\n \n@@ -2125,45 +2017,14 @@ df_notes_rescan (rtx insn)\n \n       /* Find some place to put any new mw_hardregs.  */\n       df_canonize_collection_rec (&collection_rec);\n-      mw_len = collection_rec.mw_vec.length ();\n-      if (mw_len)\n+      struct df_mw_hardreg **mw_ptr = &insn_info->mw_hardregs, *mw;\n+      FOR_EACH_VEC_ELT (collection_rec.mw_vec, i, mw)\n \t{\n-\t  unsigned int count = 0;\n-\t  struct df_mw_hardreg **mw_rec = insn_info->mw_hardregs;\n-\t  while (*mw_rec)\n-\t    {\n-\t      count++;\n-\t      mw_rec++;\n-\t    }\n-\n-\t  if (count)\n-\t    {\n-\t      /* Append to the end of the existing record after\n-\t\t expanding it if necessary.  */\n-\t      if (mw_len > num_deleted)\n-\t\t{\n-\t\t  insn_info->mw_hardregs =\n-\t\t    XRESIZEVEC (struct df_mw_hardreg *,\n-\t\t\t\tinsn_info->mw_hardregs,\n-\t\t\t\tcount + 1 + mw_len);\n-\t\t}\n-\t      memcpy (&insn_info->mw_hardregs[count],\n-\t\t      collection_rec.mw_vec.address (),\n-\t\t      mw_len * sizeof (struct df_mw_hardreg *));\n-\t      insn_info->mw_hardregs[count + mw_len] = NULL;\n-\t      qsort (insn_info->mw_hardregs, count + mw_len,\n-\t\t     sizeof (struct df_mw_hardreg *), df_mw_compare);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* No vector there. */\n-\t      insn_info->mw_hardregs\n-\t\t= XNEWVEC (struct df_mw_hardreg*, 1 + mw_len);\n-\t      memcpy (insn_info->mw_hardregs,\n-\t\t      collection_rec.mw_vec.address (),\n-\t\t      mw_len * sizeof (struct df_mw_hardreg *));\n-\t      insn_info->mw_hardregs[mw_len] = NULL;\n-\t    }\n+\t  while (*mw_ptr && df_mw_compare (*mw_ptr, mw) < 0)\n+\t    mw_ptr = &DF_MWS_NEXT (*mw_ptr);\n+\t  DF_MWS_NEXT (mw) = *mw_ptr;\n+\t  *mw_ptr = mw;\n+\t  mw_ptr = &DF_MWS_NEXT (mw);\n \t}\n       df_refs_add_to_chains (&collection_rec, bb, insn, copy_eq_uses);\n     }\n@@ -2222,14 +2083,8 @@ df_ref_equal_p (df_ref ref1, df_ref ref2)\n    have the same bb.  So these fields are not checked.  */\n \n static int\n-df_ref_compare (const void *r1, const void *r2)\n+df_ref_compare (df_ref ref1, df_ref ref2)\n {\n-  const df_ref ref1 = *(const df_ref *)r1;\n-  const df_ref ref2 = *(const df_ref *)r2;\n-\n-  if (ref1 == ref2)\n-    return 0;\n-\n   if (DF_REF_CLASS (ref1) != DF_REF_CLASS (ref2))\n     return (int)DF_REF_CLASS (ref1) - (int)DF_REF_CLASS (ref2);\n \n@@ -2264,6 +2119,14 @@ df_ref_compare (const void *r1, const void *r2)\n   return (int)DF_REF_ORDER (ref1) - (int)DF_REF_ORDER (ref2);\n }\n \n+/* Like df_ref_compare, but compare two df_ref* pointers R1 and R2.  */\n+\n+static int\n+df_ref_ptr_compare (const void *r1, const void *r2)\n+{\n+  return df_ref_compare (*(const df_ref *) r1, *(const df_ref *) r2);\n+}\n+\n static void\n df_swap_refs (vec<df_ref, va_heap> *ref_vec, int i, int j)\n {\n@@ -2290,7 +2153,7 @@ df_sort_and_compress_refs (vec<df_ref, va_heap> *ref_vec)\n     {\n       df_ref r0 = (*ref_vec)[0];\n       df_ref r1 = (*ref_vec)[1];\n-      if (df_ref_compare (&r0, &r1) > 0)\n+      if (df_ref_compare (r0, r1) > 0)\n         df_swap_refs (ref_vec, 0, 1);\n     }\n   else\n@@ -2299,7 +2162,7 @@ df_sort_and_compress_refs (vec<df_ref, va_heap> *ref_vec)\n \t{\n \t  df_ref r0 = (*ref_vec)[i];\n \t  df_ref r1 = (*ref_vec)[i + 1];\n-\t  if (df_ref_compare (&r0, &r1) >= 0)\n+\t  if (df_ref_compare (r0, r1) >= 0)\n \t    break;\n \t}\n       /* If the array is already strictly ordered,\n@@ -2311,7 +2174,7 @@ df_sort_and_compress_refs (vec<df_ref, va_heap> *ref_vec)\n          of DF_REF_COMPARE.  */\n       if (i == count - 1)\n         return;\n-      ref_vec->qsort (df_ref_compare);\n+      ref_vec->qsort (df_ref_ptr_compare);\n     }\n \n   for (i=0; i<count-dist; i++)\n@@ -2354,14 +2217,8 @@ df_mw_equal_p (struct df_mw_hardreg *mw1, struct df_mw_hardreg *mw2)\n /* Compare MW1 and MW2 for sorting.  */\n \n static int\n-df_mw_compare (const void *m1, const void *m2)\n+df_mw_compare (const df_mw_hardreg *mw1, const df_mw_hardreg *mw2)\n {\n-  const struct df_mw_hardreg *const mw1 = *(const struct df_mw_hardreg *const*)m1;\n-  const struct df_mw_hardreg *const mw2 = *(const struct df_mw_hardreg *const*)m2;\n-\n-  if (mw1 == mw2)\n-    return 0;\n-\n   if (mw1->type != mw2->type)\n     return mw1->type - mw2->type;\n \n@@ -2380,6 +2237,14 @@ df_mw_compare (const void *m1, const void *m2)\n   return 0;\n }\n \n+/* Like df_mw_compare, but compare two df_mw_hardreg** pointers R1 and R2.  */\n+\n+static int\n+df_mw_ptr_compare (const void *m1, const void *m2)\n+{\n+  return df_mw_compare (*(const df_mw_hardreg *const *) m1,\n+\t\t\t*(const df_mw_hardreg *const *) m2);\n+}\n \n /* Sort and compress a set of refs.  */\n \n@@ -2399,15 +2264,15 @@ df_sort_and_compress_mws (vec<df_mw_hardreg_ptr, va_heap> *mw_vec)\n     {\n       struct df_mw_hardreg *m0 = (*mw_vec)[0];\n       struct df_mw_hardreg *m1 = (*mw_vec)[1];\n-      if (df_mw_compare (&m0, &m1) > 0)\n+      if (df_mw_compare (m0, m1) > 0)\n         {\n           struct df_mw_hardreg *tmp = (*mw_vec)[0];\n \t  (*mw_vec)[0] = (*mw_vec)[1];\n \t  (*mw_vec)[1] = tmp;\n         }\n     }\n   else\n-    mw_vec->qsort (df_mw_compare);\n+    mw_vec->qsort (df_mw_ptr_compare);\n \n   for (i=0; i<count-dist; i++)\n     {\n@@ -2493,7 +2358,7 @@ df_install_ref (df_ref this_ref,\n    eq_uses) and installs the entire group into the insn.  It also adds\n    each of these refs into the appropriate chains.  */\n \n-static df_ref *\n+static df_ref\n df_install_refs (basic_block bb,\n \t\t const vec<df_ref, va_heap> *old_vec,\n \t\t struct df_reg_info **reg_info,\n@@ -2503,7 +2368,6 @@ df_install_refs (basic_block bb,\n   unsigned int count = old_vec->length ();\n   if (count)\n     {\n-      df_ref *new_vec = XNEWVEC (df_ref, count + 1);\n       bool add_to_table;\n       df_ref this_ref;\n       unsigned int ix;\n@@ -2533,37 +2397,35 @@ df_install_refs (basic_block bb,\n \n       FOR_EACH_VEC_ELT (*old_vec, ix, this_ref)\n \t{\n-\t  new_vec[ix] = this_ref;\n+\t  DF_REF_NEXT_LOC (this_ref) = (ix + 1 < old_vec->length ()\n+\t\t\t\t\t? (*old_vec)[ix + 1]\n+\t\t\t\t\t: NULL);\n \t  df_install_ref (this_ref, reg_info[DF_REF_REGNO (this_ref)],\n \t\t\t  ref_info, add_to_table);\n \t}\n-\n-      new_vec[count] = NULL;\n-      return new_vec;\n+      return (*old_vec)[0];\n     }\n   else\n-    return df_null_ref_rec;\n+    return 0;\n }\n \n \n /* This function takes the mws installs the entire group into the\n    insn.  */\n \n-static struct df_mw_hardreg **\n+static struct df_mw_hardreg *\n df_install_mws (const vec<df_mw_hardreg_ptr, va_heap> *old_vec)\n {\n   unsigned int count = old_vec->length ();\n   if (count)\n     {\n-      struct df_mw_hardreg **new_vec\n-\t= XNEWVEC (struct df_mw_hardreg*, count + 1);\n-      memcpy (new_vec, old_vec->address (),\n-\t      sizeof (struct df_mw_hardreg*) * count);\n-      new_vec[count] = NULL;\n-      return new_vec;\n+      for (unsigned int i = 0; i < count - 1; i++)\n+\tDF_MWS_NEXT ((*old_vec)[i]) = (*old_vec)[i + 1];\n+      DF_MWS_NEXT ((*old_vec)[count - 1]) = 0;\n+      return (*old_vec)[0];\n     }\n   else\n-    return df_null_mw_rec;\n+    return 0;\n }\n \n \n@@ -2582,31 +2444,31 @@ df_refs_add_to_chains (struct df_collection_rec *collection_rec,\n \t chain specially.  */\n       if (flags & copy_defs)\n \t{\n-\t  df_scan_free_ref_vec (insn_rec->defs);\n+\t  gcc_checking_assert (!insn_rec->defs);\n \t  insn_rec->defs\n \t    = df_install_refs (bb, &collection_rec->def_vec,\n \t\t\t       df->def_regs,\n \t\t\t       &df->def_info, false);\n \t}\n       if (flags & copy_uses)\n \t{\n-\t  df_scan_free_ref_vec (insn_rec->uses);\n+\t  gcc_checking_assert (!insn_rec->uses);\n \t  insn_rec->uses\n \t    = df_install_refs (bb, &collection_rec->use_vec,\n \t\t\t       df->use_regs,\n \t\t\t       &df->use_info, false);\n \t}\n       if (flags & copy_eq_uses)\n \t{\n-\t  df_scan_free_ref_vec (insn_rec->eq_uses);\n+\t  gcc_checking_assert (!insn_rec->eq_uses);\n \t  insn_rec->eq_uses\n \t    = df_install_refs (bb, &collection_rec->eq_use_vec,\n \t\t\t       df->eq_use_regs,\n \t\t\t       &df->use_info, true);\n \t}\n       if (flags & copy_mw)\n \t{\n-\t  df_scan_free_mws_vec (insn_rec->mw_hardregs);\n+\t  gcc_checking_assert (!insn_rec->mw_hardregs);\n \t  insn_rec->mw_hardregs\n \t    = df_install_mws (&collection_rec->mw_vec);\n \t}\n@@ -2615,12 +2477,12 @@ df_refs_add_to_chains (struct df_collection_rec *collection_rec,\n     {\n       struct df_scan_bb_info *bb_info = df_scan_get_bb_info (bb->index);\n \n-      df_scan_free_ref_vec (bb_info->artificial_defs);\n+      gcc_checking_assert (!bb_info->artificial_defs);\n       bb_info->artificial_defs\n \t= df_install_refs (bb, &collection_rec->def_vec,\n \t\t\t   df->def_regs,\n \t\t\t   &df->def_info, false);\n-      df_scan_free_ref_vec (bb_info->artificial_uses);\n+      gcc_checking_assert (!bb_info->artificial_uses);\n       bb_info->artificial_uses\n \t= df_install_refs (bb, &collection_rec->use_vec,\n \t\t\t   df->use_regs,\n@@ -4194,15 +4056,15 @@ df_reg_chain_verify_unmarked (df_ref refs)\n /* Verify that NEW_REC and OLD_REC have exactly the same members. */\n \n static bool\n-df_refs_verify (const vec<df_ref, va_heap> *new_rec, df_ref *old_rec,\n+df_refs_verify (const vec<df_ref, va_heap> *new_rec, df_ref old_rec,\n \t\tbool abort_if_fail)\n {\n   unsigned int ix;\n   df_ref new_ref;\n \n   FOR_EACH_VEC_ELT (*new_rec, ix, new_ref)\n     {\n-      if (*old_rec == NULL || !df_ref_equal_p (new_ref, *old_rec))\n+      if (old_rec == NULL || !df_ref_equal_p (new_ref, old_rec))\n \t{\n \t  if (abort_if_fail)\n \t    gcc_assert (0);\n@@ -4214,17 +4076,17 @@ df_refs_verify (const vec<df_ref, va_heap> *new_rec, df_ref *old_rec,\n \t that is the context, mark this reg as being seem.  */\n       if (abort_if_fail)\n \t{\n-\t  gcc_assert (DF_REF_IS_REG_MARKED (*old_rec));\n-\t  DF_REF_REG_UNMARK (*old_rec);\n+\t  gcc_assert (DF_REF_IS_REG_MARKED (old_rec));\n+\t  DF_REF_REG_UNMARK (old_rec);\n \t}\n \n-      old_rec++;\n+      old_rec = DF_REF_NEXT_LOC (old_rec);\n     }\n \n   if (abort_if_fail)\n-    gcc_assert (*old_rec == NULL);\n+    gcc_assert (old_rec == NULL);\n   else\n-    return *old_rec == NULL;\n+    return old_rec == NULL;\n   return false;\n }\n \n@@ -4233,28 +4095,28 @@ df_refs_verify (const vec<df_ref, va_heap> *new_rec, df_ref *old_rec,\n \n static bool\n df_mws_verify (const vec<df_mw_hardreg_ptr, va_heap> *new_rec,\n-\t       struct df_mw_hardreg **old_rec,\n+\t       struct df_mw_hardreg *old_rec,\n \t       bool abort_if_fail)\n {\n   unsigned int ix;\n   struct df_mw_hardreg *new_reg;\n \n   FOR_EACH_VEC_ELT (*new_rec, ix, new_reg)\n     {\n-      if (*old_rec == NULL || !df_mw_equal_p (new_reg, *old_rec))\n+      if (old_rec == NULL || !df_mw_equal_p (new_reg, old_rec))\n \t{\n \t  if (abort_if_fail)\n \t    gcc_assert (0);\n \t  else\n \t    return false;\n \t}\n-      old_rec++;\n+      old_rec = DF_MWS_NEXT (old_rec);\n     }\n \n   if (abort_if_fail)\n-    gcc_assert (*old_rec == NULL);\n+    gcc_assert (old_rec == NULL);\n   else\n-    return *old_rec == NULL;\n+    return old_rec == NULL;\n   return false;\n }\n \n@@ -4282,15 +4144,6 @@ df_insn_refs_verify (struct df_collection_rec *collection_rec,\n \n   df_insn_refs_collect (collection_rec, bb, insn_info);\n \n-  if (!DF_INSN_UID_DEFS (uid))\n-    {\n-      /* The insn_rec was created but it was never filled out.  */\n-      if (abort_if_fail)\n-\tgcc_assert (0);\n-      else\n-\treturn false;\n-    }\n-\n   /* Unfortunately we cannot opt out early if one of these is not\n      right because the marks will not get cleared.  */\n   ret1 = df_refs_verify (&collection_rec->def_vec, DF_INSN_UID_DEFS (uid),"}, {"sha": "1533949829b7c2db6b43c44ea6c219cd9ff2401e", "filename": "gcc/df.h", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b512946c8932f373507943fe4d30156a1afd18eb/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b512946c8932f373507943fe4d30156a1afd18eb/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=b512946c8932f373507943fe4d30156a1afd18eb", "patch": "@@ -339,6 +339,7 @@ struct dataflow\n    REG_UNUSED notes.  */\n struct df_mw_hardreg\n {\n+  df_mw_hardreg *next;\t\t/* Next entry for this instruction.  */\n   rtx mw_reg;                   /* The multiword hardreg.  */\n   /* These two bitfields are intentionally oversized, in the hope that\n      accesses to 16-bit fields will usually be quicker.  */\n@@ -365,6 +366,7 @@ struct df_base_ref\n   int flags : 16;\t\t/* Various df_ref_flags.  */\n   unsigned int regno;\t\t/* The register number referenced.  */\n   rtx reg;\t\t\t/* The register referenced.  */\n+  union df_ref_d *next_loc;\t/* Next ref for same insn or bb.  */\n   struct df_link *chain;\t/* Head of def-use, use-def.  */\n   /* Pointer to the insn info of the containing instruction.  FIXME!\n      Currently this is NULL for artificial refs but this will be used\n@@ -420,11 +422,11 @@ typedef union df_ref_d *df_ref;\n struct df_insn_info\n {\n   rtx insn;                     /* The insn this info comes from.  */\n-  df_ref *defs;\t                /* Head of insn-def chain.  */\n-  df_ref *uses;\t                /* Head of insn-use chain.  */\n+  df_ref defs;\t                /* Head of insn-def chain.  */\n+  df_ref uses;\t                /* Head of insn-use chain.  */\n   /* Head of insn-use chain for uses in REG_EQUAL/EQUIV notes.  */\n-  df_ref *eq_uses;\n-  struct df_mw_hardreg **mw_hardregs;\n+  df_ref eq_uses;\n+  struct df_mw_hardreg *mw_hardregs;\n   /* The logical uid of the insn in the basic block.  This is valid\n      after any call to df_analyze but may rot after insns are added,\n      deleted or moved. */\n@@ -665,6 +667,7 @@ struct df_d\n #define DF_REF_REG_MARK(REF) (DF_REF_FLAGS_SET ((REF),DF_REF_REG_MARKER))\n #define DF_REF_REG_UNMARK(REF) (DF_REF_FLAGS_CLEAR ((REF),DF_REF_REG_MARKER))\n #define DF_REF_IS_REG_MARKED(REF) (DF_REF_FLAGS_IS_SET ((REF),DF_REF_REG_MARKER))\n+#define DF_REF_NEXT_LOC(REF) ((REF)->base.next_loc)\n #define DF_REF_NEXT_REG(REF) ((REF)->base.next_reg)\n #define DF_REF_PREV_REG(REF) ((REF)->base.prev_reg)\n /* The following two macros may only be applied if one of\n@@ -683,6 +686,7 @@ struct df_d\n \n #define DF_MWS_REG_DEF_P(MREF) (DF_MWS_TYPE (MREF) == DF_REF_REG_DEF)\n #define DF_MWS_REG_USE_P(MREF) ((MREF) && !DF_MWS_REG_DEF_P (MREF))\n+#define DF_MWS_NEXT(MREF) ((MREF)->next)\n #define DF_MWS_TYPE(MREF) ((MREF)->type)\n \n /* Macros to get the refs out of def_info or use_info refs table.  If\n@@ -755,20 +759,16 @@ struct df_d\n #define DF_INSN_UID_MWS(INSN) (DF_INSN_UID_GET (INSN)->mw_hardregs)\n \n #define FOR_EACH_INSN_INFO_DEF(ITER, INSN) \\\n-  for (df_ref *ITER##_ = DF_INSN_INFO_DEFS (INSN); (ITER = *ITER##_); \\\n-       ++ITER##_)\n+  for (ITER = DF_INSN_INFO_DEFS (INSN); ITER; ITER = DF_REF_NEXT_LOC (ITER))\n \n #define FOR_EACH_INSN_INFO_USE(ITER, INSN) \\\n-  for (df_ref *ITER##_ = DF_INSN_INFO_USES (INSN); (ITER = *ITER##_); \\\n-       ++ITER##_)\n+  for (ITER = DF_INSN_INFO_USES (INSN); ITER; ITER = DF_REF_NEXT_LOC (ITER))\n \n #define FOR_EACH_INSN_INFO_EQ_USE(ITER, INSN) \\\n-  for (df_ref *ITER##_ = DF_INSN_INFO_EQ_USES (INSN); (ITER = *ITER##_); \\\n-       ++ITER##_)\n+  for (ITER = DF_INSN_INFO_EQ_USES (INSN); ITER; ITER = DF_REF_NEXT_LOC (ITER))\n \n #define FOR_EACH_INSN_INFO_MW(ITER, INSN) \\\n-  for (df_mw_hardreg **ITER##_ = DF_INSN_INFO_MWS (INSN); (ITER = *ITER##_); \\\n-       ++ITER##_)\n+  for (ITER = DF_INSN_INFO_MWS (INSN); ITER; ITER = DF_MWS_NEXT (ITER))\n \n #define FOR_EACH_INSN_DEF(ITER, INSN) \\\n   FOR_EACH_INSN_INFO_DEF(ITER, DF_INSN_INFO_GET (INSN))\n@@ -780,12 +780,12 @@ struct df_d\n   FOR_EACH_INSN_INFO_EQ_USE(ITER, DF_INSN_INFO_GET (INSN))\n \n #define FOR_EACH_ARTIFICIAL_USE(ITER, BB_INDEX) \\\n-  for (df_ref *ITER##_ = df_get_artificial_uses (BB_INDEX); \\\n-       (ITER = *ITER##_); ++ITER##_)\n+  for (ITER = df_get_artificial_uses (BB_INDEX); ITER; \\\n+       ITER = DF_REF_NEXT_LOC (ITER))\n \n #define FOR_EACH_ARTIFICIAL_DEF(ITER, BB_INDEX) \\\n-  for (df_ref *ITER##_ = df_get_artificial_defs (BB_INDEX); \\\n-       (ITER = *ITER##_); ++ITER##_)\n+  for (ITER = df_get_artificial_defs (BB_INDEX); ITER; \\\n+       ITER = DF_REF_NEXT_LOC (ITER))\n \n /* An obstack for bitmap not related to specific dataflow problems.\n    This obstack should e.g. be used for bitmaps with a short life time\n@@ -806,13 +806,13 @@ struct df_scan_bb_info\n \n      Blocks that are the targets of non-local goto's have the hard\n      frame pointer defined at the top of the block.  */\n-  df_ref *artificial_defs;\n+  df_ref artificial_defs;\n \n   /* Blocks that are targets of exception edges may have some\n      artificial uses.  These are logically at the top of the block.\n \n      Most blocks have artificial uses at the bottom of the block.  */\n-  df_ref *artificial_uses;\n+  df_ref artificial_uses;\n };\n \n \n@@ -967,7 +967,7 @@ extern void df_dump_top (basic_block, FILE *);\n extern void df_dump_bottom (basic_block, FILE *);\n extern void df_dump_insn_top (const_rtx, FILE *);\n extern void df_dump_insn_bottom (const_rtx, FILE *);\n-extern void df_refs_chain_dump (df_ref *, bool, FILE *);\n+extern void df_refs_chain_dump (df_ref, bool, FILE *);\n extern void df_regs_chain_dump (df_ref,  FILE *);\n extern void df_insn_debug (rtx, bool, FILE *);\n extern void df_insn_debug_regno (rtx, FILE *);\n@@ -1147,7 +1147,7 @@ df_get_live_in (basic_block bb)\n /* Get basic block info.  */\n /* Get the artificial defs for a basic block.  */\n \n-static inline df_ref *\n+static inline df_ref\n df_get_artificial_defs (unsigned int bb_index)\n {\n   return df_scan_get_bb_info (bb_index)->artificial_defs;\n@@ -1156,7 +1156,7 @@ df_get_artificial_defs (unsigned int bb_index)\n \n /* Get the artificial uses for a basic block.  */\n \n-static inline df_ref *\n+static inline df_ref\n df_get_artificial_uses (unsigned int bb_index)\n {\n   return df_scan_get_bb_info (bb_index)->artificial_uses;\n@@ -1168,8 +1168,8 @@ df_get_artificial_uses (unsigned int bb_index)\n static inline df_ref\n df_single_def (const df_insn_info *info)\n {\n-  df_ref *defs = DF_INSN_INFO_DEFS (info);\n-  return defs[0] && !defs[1] ? defs[0] : NULL;\n+  df_ref defs = DF_INSN_INFO_DEFS (info);\n+  return defs && !DF_REF_NEXT_LOC (defs) ? defs : NULL;\n }\n \n /* If INSN uses exactly one register, return the associated reference,\n@@ -1178,8 +1178,8 @@ df_single_def (const df_insn_info *info)\n static inline df_ref\n df_single_use (const df_insn_info *info)\n {\n-  df_ref *uses = DF_INSN_INFO_USES (info);\n-  return uses[0] && !uses[1] ? uses[0] : NULL;\n+  df_ref uses = DF_INSN_INFO_USES (info);\n+  return uses && !DF_REF_NEXT_LOC (uses) ? uses : NULL;\n }\n \n /* web */"}, {"sha": "a0b9c8b02cafadda790d476a28c8a728847df1cf", "filename": "gcc/fwprop.c", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b512946c8932f373507943fe4d30156a1afd18eb/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b512946c8932f373507943fe4d30156a1afd18eb/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=b512946c8932f373507943fe4d30156a1afd18eb", "patch": "@@ -146,10 +146,9 @@ get_def_for_use (df_ref use)\n \t(DF_REF_PARTIAL | DF_REF_CONDITIONAL | DF_REF_MAY_CLOBBER)\n \n static void\n-process_defs (df_ref *def_rec, int top_flag)\n+process_defs (df_ref def, int top_flag)\n {\n-  df_ref def;\n-  while ((def = *def_rec++) != NULL)\n+  for (; def; def = DF_REF_NEXT_LOC (def))\n     {\n       df_ref curr_def = reg_defs[DF_REF_REGNO (def)];\n       unsigned int dregno;\n@@ -191,10 +190,9 @@ process_defs (df_ref *def_rec, int top_flag)\n    is an artificial use vector.  */\n \n static void\n-process_uses (df_ref *use_rec, int top_flag)\n+process_uses (df_ref use, int top_flag)\n {\n-  df_ref use;\n-  while ((use = *use_rec++) != NULL)\n+  for (; use; use = DF_REF_NEXT_LOC (use))\n     if ((DF_REF_FLAGS (use) & DF_REF_AT_TOP) == top_flag)\n       {\n         unsigned int uregno = DF_REF_REGNO (use);\n@@ -849,11 +847,10 @@ static sparseset active_defs_check;\n    too, for checking purposes.  */\n \n static void\n-register_active_defs (df_ref *use_rec)\n+register_active_defs (df_ref use)\n {\n-  while (*use_rec)\n+  for (; use; use = DF_REF_NEXT_LOC (use))\n     {\n-      df_ref use = *use_rec++;\n       df_ref def = get_def_for_use (use);\n       int regno = DF_REF_REGNO (use);\n \n@@ -887,11 +884,10 @@ update_df_init (rtx def_insn, rtx insn)\n    in the ACTIVE_DEFS array to match pseudos to their def. */\n \n static inline void\n-update_uses (df_ref *use_rec)\n+update_uses (df_ref use)\n {\n-  while (*use_rec)\n+  for (; use; use = DF_REF_NEXT_LOC (use))\n     {\n-      df_ref use = *use_rec++;\n       int regno = DF_REF_REGNO (use);\n \n       /* Set up the use-def chain.  */\n@@ -1135,7 +1131,7 @@ forward_propagate_asm (df_ref use, rtx def_insn, rtx def_set, rtx reg)\n {\n   rtx use_insn = DF_REF_INSN (use), src, use_pat, asm_operands, new_rtx, *loc;\n   int speed_p, i;\n-  df_ref *use_vec;\n+  df_ref uses;\n \n   gcc_assert ((DF_REF_FLAGS (use) & DF_REF_IN_NOTE) == 0);\n \n@@ -1144,8 +1140,8 @@ forward_propagate_asm (df_ref use, rtx def_insn, rtx def_set, rtx reg)\n \n   /* In __asm don't replace if src might need more registers than\n      reg, as that could increase register pressure on the __asm.  */\n-  use_vec = DF_INSN_USES (def_insn);\n-  if (use_vec[0] && use_vec[1])\n+  uses = DF_INSN_USES (def_insn);\n+  if (uses && DF_REF_NEXT_LOC (uses))\n     return false;\n \n   update_df_init (def_insn, use_insn);"}, {"sha": "0e9f5da5db5e8ea6a4548fc7282c942805879395", "filename": "gcc/web.c", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b512946c8932f373507943fe4d30156a1afd18eb/gcc%2Fweb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b512946c8932f373507943fe4d30156a1afd18eb/gcc%2Fweb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fweb.c?ref=b512946c8932f373507943fe4d30156a1afd18eb", "patch": "@@ -93,8 +93,8 @@ union_match_dups (rtx insn, struct web_entry *def_entry,\n \t\t  bool (*fun) (struct web_entry *, struct web_entry *))\n {\n   struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n-  df_ref *use_link = DF_INSN_INFO_USES (insn_info);\n-  df_ref *def_link = DF_INSN_INFO_DEFS (insn_info);\n+  df_ref use_link = DF_INSN_INFO_USES (insn_info);\n+  df_ref def_link = DF_INSN_INFO_DEFS (insn_info);\n   struct web_entry *dup_entry;\n   int i;\n \n@@ -104,18 +104,19 @@ union_match_dups (rtx insn, struct web_entry *def_entry,\n     {\n       int op = recog_data.dup_num[i];\n       enum op_type type = recog_data.operand_type[op];\n-      df_ref *ref, *dupref;\n+      df_ref ref, dupref;\n       struct web_entry *entry;\n \n-      for (dup_entry = use_entry, dupref = use_link; *dupref; dupref++)\n-\tif (DF_REF_LOC (*dupref) == recog_data.dup_loc[i])\n+      dup_entry = use_entry;\n+      for (dupref = use_link; dupref; dupref = DF_REF_NEXT_LOC (dupref))\n+\tif (DF_REF_LOC (dupref) == recog_data.dup_loc[i])\n \t  break;\n \n-      if (*dupref == NULL && type == OP_INOUT)\n+      if (dupref == NULL && type == OP_INOUT)\n \t{\n-\n-\t  for (dup_entry = def_entry, dupref = def_link; *dupref; dupref++)\n-\t    if (DF_REF_LOC (*dupref) == recog_data.dup_loc[i])\n+\t  dup_entry = def_entry;\n+\t  for (dupref = def_link; dupref; dupref = DF_REF_NEXT_LOC (dupref))\n+\t    if (DF_REF_LOC (dupref) == recog_data.dup_loc[i])\n \t      break;\n \t}\n       /* ??? *DUPREF can still be zero, because when an operand matches\n@@ -125,35 +126,36 @@ union_match_dups (rtx insn, struct web_entry *def_entry,\n          even though it is there.\n          Example: i686-pc-linux-gnu gcc.c-torture/compile/950607-1.c\n \t\t  -O3 -fomit-frame-pointer -funroll-loops  */\n-      if (*dupref == NULL\n-\t  || DF_REF_REGNO (*dupref) < FIRST_PSEUDO_REGISTER)\n+      if (dupref == NULL\n+\t  || DF_REF_REGNO (dupref) < FIRST_PSEUDO_REGISTER)\n \tcontinue;\n \n       ref = type == OP_IN ? use_link : def_link;\n       entry = type == OP_IN ? use_entry : def_entry;\n-      for (; *ref; ref++)\n+      for (; ref; ref = DF_REF_NEXT_LOC (ref))\n \t{\n-\t  rtx *l = DF_REF_LOC (*ref);\n+\t  rtx *l = DF_REF_LOC (ref);\n \t  if (l == recog_data.operand_loc[op])\n \t    break;\n-\t  if (l && DF_REF_REAL_LOC (*ref) == recog_data.operand_loc[op])\n+\t  if (l && DF_REF_REAL_LOC (ref) == recog_data.operand_loc[op])\n \t    break;\n \t}\n \n-      if (!*ref && type == OP_INOUT)\n+      if (!ref && type == OP_INOUT)\n \t{\n-\t  for (ref = use_link, entry = use_entry; *ref; ref++)\n+\t  entry = use_entry;\n+\t  for (ref = use_link; ref; ref = DF_REF_NEXT_LOC (ref))\n \t    {\n-\t      rtx *l = DF_REF_LOC (*ref);\n+\t      rtx *l = DF_REF_LOC (ref);\n \t      if (l == recog_data.operand_loc[op])\n \t\tbreak;\n-\t      if (l && DF_REF_REAL_LOC (*ref) == recog_data.operand_loc[op])\n+\t      if (l && DF_REF_REAL_LOC (ref) == recog_data.operand_loc[op])\n \t\tbreak;\n \t    }\n \t}\n \n-      gcc_assert (*ref);\n-      (*fun) (dup_entry + DF_REF_ID (*dupref), entry + DF_REF_ID (*ref));\n+      gcc_assert (ref);\n+      (*fun) (dup_entry + DF_REF_ID (dupref), entry + DF_REF_ID (ref));\n     }\n }\n "}]}