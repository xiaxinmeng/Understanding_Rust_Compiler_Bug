{"sha": "a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTU2MGQ0ZDRkOWYwZmM2NmZkNzYzNGRhYzNiMTNkNzJlZTA3OTBkMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-01-24T22:45:58Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-01-24T22:45:58Z"}, "message": "emit-rtl.c (reg_attrs_htab): New static variable.\n\n\t* emit-rtl.c (reg_attrs_htab): New static variable.\n\t(reg_attrs_htab_hash, reg_attrs_htab_eq, get_reg_attrs): New static\n\tfunctions.\n\t(reg_rtx): Do not maintain regno_decl.\n\t(gen_rtx_REG_offset, set_reg_attrs_from_mem, set_delc_rtx,\n\tset_mem_attrs_from_reg): New global function.\n\t(init_emit): Do not initialize regno_decl.\n\t(init_emit_once): initialize reg_attrs_htab.\n\t* final.c (alter_subreg): Do not replace REG by SUBREG.\n\t(gen_mem_expr_from_op): Improve output.\n\t(output_asm_operands): Likewise.\n\t* function.c (assign_params): Do not set REGNO_DECL.\n\t* function.h (struct function): Kill regno_decl.\n\t(REGNO_DECL): Kill.\n\t* gengtype.c (adjust_field_rtx_def): Handle new field of reg.\n\t* print_rtl.c (print_rtx): Output REG information.\n\t* regclass.c (reg_scan_mark_refs): Update attrs.\n\t* reload1.c (alter_reg): Likewise.\n\t* simplify_rtx.c (simplify_subreg): Likewise.\n\t* stmt.c (expand_decl): Likewise.\n\t* rtl.def (REG): Add new field.\n\t* rtl.h (struct reg_attrs): New.\n\t(rtunion_def): At rtreg.\n\t(X0MEMATTR): Add checking.\n\t(X0REGATTR, REG_ATTRS, REG_EXPR, REG_OFFSET): New macro.\n\t(set_reg_attrs_from_mem, set_mem_attrs_from_reg, gen_rtx_REG_offset):\n\tDeclare.\n\t* tree.h (SET_DECL_RTL): Call set_decl_rtl.\n\nFrom-SVN: r61741", "tree": {"sha": "1090cf96c575f2f136a1b44c8d8d83d0bc0b04d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1090cf96c575f2f136a1b44c8d8d83d0bc0b04d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3/comments", "author": null, "committer": null, "parents": [{"sha": "1d0ea52e2dc53ed8ecc7f3e95047a2a921b7cb3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d0ea52e2dc53ed8ecc7f3e95047a2a921b7cb3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d0ea52e2dc53ed8ecc7f3e95047a2a921b7cb3a"}], "stats": {"total": 317, "additions": 249, "deletions": 68}, "files": [{"sha": "a445828562432ced0cc74b7a243d9519f836467a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3", "patch": "@@ -1,3 +1,34 @@\n+Fri Jan 24 23:44:12 CET 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* emit-rtl.c (reg_attrs_htab): New static variable.\n+\t(reg_attrs_htab_hash, reg_attrs_htab_eq, get_reg_attrs): New static\n+\tfunctions.\n+\t(reg_rtx): Do not maintain regno_decl.\n+\t(gen_rtx_REG_offset, set_reg_attrs_from_mem, set_delc_rtx,\n+\tset_mem_attrs_from_reg): New global function.\n+\t(init_emit): Do not initialize regno_decl.\n+\t(init_emit_once): initialize reg_attrs_htab.\n+\t* final.c (alter_subreg): Do not replace REG by SUBREG.\n+\t(gen_mem_expr_from_op): Improve output.\n+\t(output_asm_operands): Likewise.\n+\t* function.c (assign_params): Do not set REGNO_DECL.\n+\t* function.h (struct function): Kill regno_decl.\n+\t(REGNO_DECL): Kill.\n+\t* gengtype.c (adjust_field_rtx_def): Handle new field of reg.\n+\t* print_rtl.c (print_rtx): Output REG information.\n+\t* regclass.c (reg_scan_mark_refs): Update attrs.\n+\t* reload1.c (alter_reg): Likewise.\n+\t* simplify_rtx.c (simplify_subreg): Likewise.\n+\t* stmt.c (expand_decl): Likewise.\n+\t* rtl.def (REG): Add new field.\n+\t* rtl.h (struct reg_attrs): New.\n+\t(rtunion_def): At rtreg.\n+\t(X0MEMATTR): Add checking.\n+\t(X0REGATTR, REG_ATTRS, REG_EXPR, REG_OFFSET): New macro.\n+\t(set_reg_attrs_from_mem, set_mem_attrs_from_reg, gen_rtx_REG_offset):\n+\tDeclare.\n+\t* tree.h (SET_DECL_RTL): Call set_decl_rtl.\n+\n 2003-01-24  Bob Wilson  <bob.wilson@acm.org>\n \n \t* config/xtensa/xtensa.c: Remove unused include of machmode.h."}, {"sha": "5e719ae2ac1fd0b02fb565866d6bde746d036c55", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 142, "deletions": 11, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3", "patch": "@@ -157,6 +157,10 @@ static GTY ((if_marked (\"ggc_marked_p\"), param_is (struct rtx_def)))\n static GTY ((if_marked (\"ggc_marked_p\"), param_is (struct mem_attrs)))\n      htab_t mem_attrs_htab;\n \n+/* A hash table storing register attribute structures.  */\n+static GTY ((if_marked (\"ggc_marked_p\"), param_is (struct reg_attrs)))\n+     htab_t reg_attrs_htab;\n+\n /* A hash table storing all CONST_DOUBLEs.  */\n static GTY ((if_marked (\"ggc_marked_p\"), param_is (struct rtx_def)))\n      htab_t const_double_htab;\n@@ -190,6 +194,10 @@ static int mem_attrs_htab_eq            PARAMS ((const void *,\n static mem_attrs *get_mem_attrs\t\tPARAMS ((HOST_WIDE_INT, tree, rtx,\n \t\t\t\t\t\t rtx, unsigned int,\n \t\t\t\t\t\t enum machine_mode));\n+static hashval_t reg_attrs_htab_hash    PARAMS ((const void *));\n+static int reg_attrs_htab_eq            PARAMS ((const void *,\n+\t\t\t\t\t\t const void *));\n+static reg_attrs *get_reg_attrs\t\tPARAMS ((tree, int));\n static tree component_ref_for_mem_expr\tPARAMS ((tree));\n static rtx gen_const_vector_0\t\tPARAMS ((enum machine_mode));\n \n@@ -323,6 +331,60 @@ get_mem_attrs (alias, expr, offset, size, align, mode)\n   return *slot;\n }\n \n+/* Returns a hash code for X (which is a really a reg_attrs *).  */\n+\n+static hashval_t\n+reg_attrs_htab_hash (x)\n+     const void *x;\n+{\n+  reg_attrs *p = (reg_attrs *) x;\n+\n+  return ((p->offset * 1000) ^ (long) p->decl);\n+}\n+\n+/* Returns non-zero if the value represented by X (which is really a\n+   reg_attrs *) is the same as that given by Y (which is also really a\n+   reg_attrs *).  */\n+\n+static int\n+reg_attrs_htab_eq (x, y)\n+     const void *x;\n+     const void *y;\n+{\n+  reg_attrs *p = (reg_attrs *) x;\n+  reg_attrs *q = (reg_attrs *) y;\n+\n+  return (p->decl == q->decl && p->offset == q->offset);\n+}\n+/* Allocate a new reg_attrs structure and insert it into the hash table if\n+   one identical to it is not already in the table.  We are doing this for\n+   MEM of mode MODE.  */\n+\n+static reg_attrs *\n+get_reg_attrs (decl, offset)\n+     tree decl;\n+     int offset;\n+{\n+  reg_attrs attrs;\n+  void **slot;\n+\n+  /* If everything is the default, we can just return zero.  */\n+  if (decl == 0 && offset == 0)\n+    return 0;\n+\n+  attrs.decl = decl;\n+  attrs.offset = offset;\n+\n+  slot = htab_find_slot (reg_attrs_htab, &attrs, INSERT);\n+  if (*slot == 0)\n+    {\n+      *slot = ggc_alloc (sizeof (reg_attrs));\n+      memcpy (*slot, &attrs, sizeof (reg_attrs));\n+    }\n+\n+  return *slot;\n+}\n+\n /* Generate a new REG rtx.  Make sure ORIGINAL_REGNO is set properly, and\n    don't attempt to share with the various global pieces of rtl (such as\n    frame_pointer_rtx).  */\n@@ -811,15 +873,14 @@ gen_reg_rtx (mode)\n       return gen_rtx_CONCAT (mode, realpart, imagpart);\n     }\n \n-  /* Make sure regno_pointer_align, regno_decl, and regno_reg_rtx are large\n+  /* Make sure regno_pointer_align, and regno_reg_rtx are large\n      enough to have an element for this pseudo reg number.  */\n \n   if (reg_rtx_no == f->emit->regno_pointer_align_length)\n     {\n       int old_size = f->emit->regno_pointer_align_length;\n       char *new;\n       rtx *new1;\n-      tree *new2;\n \n       new = ggc_realloc (f->emit->regno_pointer_align, old_size * 2);\n       memset (new + old_size, 0, old_size);\n@@ -830,11 +891,6 @@ gen_reg_rtx (mode)\n       memset (new1 + old_size, 0, old_size * sizeof (rtx));\n       regno_reg_rtx = new1;\n \n-      new2 = (tree *) ggc_realloc (f->emit->regno_decl,\n-\t\t\t\t   old_size * 2 * sizeof (tree));\n-      memset (new2 + old_size, 0, old_size * sizeof (tree));\n-      f->emit->regno_decl = new2;\n-\n       f->emit->regno_pointer_align_length = old_size * 2;\n     }\n \n@@ -843,6 +899,70 @@ gen_reg_rtx (mode)\n   return val;\n }\n \n+/* Generate an register with same attributes as REG,\n+   but offsetted by OFFSET.  */\n+\n+rtx\n+gen_rtx_REG_offset (reg, mode, regno, offset)\n+     enum machine_mode mode;\n+     unsigned int regno;\n+     int offset;\n+     rtx reg;\n+{\n+  rtx new = gen_rtx_REG (mode, regno);\n+  REG_ATTRS (new) = get_reg_attrs (REG_EXPR (reg),\n+\t\t \t\t   REG_OFFSET (reg) + offset);\n+  return new;\n+}\n+\n+/* Set the decl for MEM to DECL.  */\n+\n+void\n+set_reg_attrs_from_mem (reg, mem)\n+     rtx reg;\n+     rtx mem;\n+{\n+  if (MEM_OFFSET (mem) && GET_CODE (MEM_OFFSET (mem)) == CONST_INT)\n+    REG_ATTRS (reg)\n+      = get_reg_attrs (MEM_EXPR (mem), INTVAL (MEM_OFFSET (mem)));\n+}\n+\n+/* Assign the RTX X to declaration T.  */\n+void\n+set_decl_rtl (t, x)\n+     tree t;\n+     rtx x;\n+{\n+  DECL_CHECK (t)->decl.rtl = x;\n+\n+  if (!x)\n+    return;\n+  /* For register, we maitain the reverse information too.  */\n+  if (GET_CODE (x) == REG)\n+    REG_ATTRS (x) = get_reg_attrs (t, 0);\n+  else if (GET_CODE (x) == SUBREG)\n+    REG_ATTRS (SUBREG_REG (x))\n+      = get_reg_attrs (t, -SUBREG_BYTE (x));\n+  if (GET_CODE (x) == CONCAT)\n+    {\n+      if (REG_P (XEXP (x, 0)))\n+        REG_ATTRS (XEXP (x, 0)) = get_reg_attrs (t, 0);\n+      if (REG_P (XEXP (x, 1)))\n+\tREG_ATTRS (XEXP (x, 1))\n+\t  = get_reg_attrs (t, GET_MODE_UNIT_SIZE (GET_MODE (XEXP (x, 0))));\n+    }\n+  if (GET_CODE (x) == PARALLEL)\n+    {\n+      int i;\n+      for (i = 0; i < XVECLEN (x, 0); i++)\n+\t{\n+\t  rtx y = XVECEXP (x, 0, i);\n+\t  if (REG_P (XEXP (y, 0)))\n+\t    REG_ATTRS (XEXP (y, 0)) = get_reg_attrs (t, INTVAL (XEXP (y, 1)));\n+\t}\n+    }\n+}\n+\n /* Identify REG (which may be a CONCAT) as a user register.  */\n \n void\n@@ -1921,6 +2041,19 @@ set_mem_attributes (ref, t, objectp)\n   set_mem_attributes_minus_bitpos (ref, t, objectp, 0);\n }\n \n+/* Set the decl for MEM to DECL.  */\n+\n+void\n+set_mem_attrs_from_reg (mem, reg)\n+     rtx mem;\n+     rtx reg;\n+{\n+  MEM_ATTRS (mem)\n+    = get_mem_attrs (MEM_ALIAS_SET (mem), REG_EXPR (reg),\n+\t\t     GEN_INT (REG_OFFSET (reg)),\n+\t\t     MEM_SIZE (mem), MEM_ALIGN (mem), GET_MODE (mem));\n+}\n+\n /* Set the alias set of MEM to SET.  */\n \n void\n@@ -5216,10 +5349,6 @@ init_emit ()\n     = (rtx *) ggc_alloc_cleared (f->emit->regno_pointer_align_length\n \t\t\t\t * sizeof (rtx));\n \n-  f->emit->regno_decl\n-    = (tree *) ggc_alloc_cleared (f->emit->regno_pointer_align_length\n-\t\t\t\t  * sizeof (tree));\n-\n   /* Put copies of all the hard registers into regno_reg_rtx.  */\n   memcpy (regno_reg_rtx,\n \t  static_regno_reg_rtx,\n@@ -5323,6 +5452,8 @@ init_emit_once (line_numbers)\n \n   mem_attrs_htab = htab_create_ggc (37, mem_attrs_htab_hash,\n \t\t\t\t    mem_attrs_htab_eq, NULL);\n+  reg_attrs_htab = htab_create_ggc (37, reg_attrs_htab_hash,\n+\t\t\t\t    reg_attrs_htab_eq, NULL);\n \n   no_line_numbers = ! line_numbers;\n "}, {"sha": "103f65d7a1f0b5ff0b94bb6651cf2092427ad145", "filename": "gcc/final.c", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3", "patch": "@@ -2622,12 +2622,7 @@ alter_subreg (xp)\n       else if (GET_CODE (y) == REG)\n \t{\n \t  unsigned int regno = subreg_hard_regno (x, 1);\n-\t  PUT_CODE (x, REG);\n-\t  REGNO (x) = regno;\n-\t  ORIGINAL_REGNO (x) = ORIGINAL_REGNO (y);\n-\t  /* This field has a different meaning for REGs and SUBREGs.  Make\n-\t     sure to clear it!  */\n-\t  RTX_FLAG (x, used) = 0;\n+\t  *xp = gen_rtx_REG_offset (y, GET_MODE (x), regno, SUBREG_BYTE (x));\n \t}\n       else\n \tabort ();\n@@ -2893,11 +2888,8 @@ get_mem_expr_from_op (op, paddressp)\n \n   *paddressp = 0;\n \n-  if (op == NULL)\n-    return 0;\n-\n-  if (GET_CODE (op) == REG && ORIGINAL_REGNO (op) >= FIRST_PSEUDO_REGISTER)\n-    return REGNO_DECL (ORIGINAL_REGNO (op));\n+  if (GET_CODE (op) == REG)\n+    return REG_EXPR (op);\n   else if (GET_CODE (op) != MEM)\n     return 0;\n \n@@ -2941,16 +2933,22 @@ output_asm_operand_names (operands, oporder, nops)\n   for (i = 0; i < nops; i++)\n     {\n       int addressp;\n-      tree expr = get_mem_expr_from_op (operands[oporder[i]], &addressp);\n+      rtx op = operands[oporder[i]];\n+      tree expr = get_mem_expr_from_op (op, &addressp);\n \n+      fprintf (asm_out_file, \"%c%s\",\n+\t       wrote ? ',' : '\\t', wrote ? \"\" : ASM_COMMENT_START);\n+      wrote = 1;\n       if (expr)\n \t{\n-\t  fprintf (asm_out_file, \"%c%s %s\",\n-\t\t   wrote ? ',' : '\\t', wrote ? \"\" : ASM_COMMENT_START,\n+\t  fprintf (asm_out_file, \"%s\",\n \t\t   addressp ? \"*\" : \"\");\n \t  print_mem_expr (asm_out_file, expr);\n \t  wrote = 1;\n \t}\n+      else if (REG_P (op) && ORIGINAL_REGNO (op)\n+\t       && ORIGINAL_REGNO (op) != REGNO (op))\n+\tfprintf (asm_out_file, \" tmp%i\", ORIGINAL_REGNO (op));\n     }\n }\n "}, {"sha": "78347c9599d0189a67d19e0ee4ec00bac010792c", "filename": "gcc/function.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3", "patch": "@@ -5005,15 +5005,6 @@ assign_parms (fndecl)\n \t  set_mem_attributes (x, result, 1);\n \t  SET_DECL_RTL (result, x);\n \t}\n-\n-      if (GET_CODE (DECL_RTL (parm)) == REG)\n-\tREGNO_DECL (REGNO (DECL_RTL (parm))) = parm;\n-      else if (GET_CODE (DECL_RTL (parm)) == CONCAT)\n-\t{\n-\t  REGNO_DECL (REGNO (XEXP (DECL_RTL (parm), 0))) = parm;\n-\t  REGNO_DECL (REGNO (XEXP (DECL_RTL (parm), 1))) = parm;\n-\t}\n-\n     }\n \n   /* Output all parameter conversion instructions (possibly including calls)"}, {"sha": "63e48f7db2996902a37b0147aa8f54ed35036ae0", "filename": "gcc/function.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3", "patch": "@@ -100,10 +100,6 @@ struct emit_status GTY(())\n   unsigned char * GTY ((length (\"%h.regno_pointer_align_length\"))) \n     regno_pointer_align;\n \n-  /* Indexed by pseudo register number, if nonzero gives the decl\n-     corresponding to that register.  */\n-  tree * GTY ((length (\"%h.regno_pointer_align_length\"))) regno_decl;\n-\n   /* Indexed by pseudo register number, gives the rtx for that pseudo.\n      Allocated in parallel with regno_pointer_align. \n \n@@ -119,7 +115,6 @@ struct emit_status GTY(())\n #define seq_stack (cfun->emit->sequence_stack)\n \n #define REGNO_POINTER_ALIGN(REGNO) (cfun->emit->regno_pointer_align[REGNO])\n-#define REGNO_DECL(REGNO) (cfun->emit->regno_decl[REGNO])\n \n struct expr_status GTY(())\n {"}, {"sha": "422214137ec2f1cfbf39edaf06f8c8e4b121a425", "filename": "gcc/gengtype.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3", "patch": "@@ -419,7 +419,7 @@ adjust_field_rtx_def (t, opt)\n   options_p nodot;\n   int i;\n   type_p rtx_tp, rtvec_tp, tree_tp, mem_attrs_tp, note_union_tp, scalar_tp;\n-  type_p bitmap_tp, basic_block_tp;\n+  type_p bitmap_tp, basic_block_tp, reg_attrs_tp;\n \n   static const char * const rtx_name[NUM_RTX_CODE] = {\n #define DEF_RTL_EXPR(ENUM, NAME, FORMAT, CLASS)   NAME ,\n@@ -443,6 +443,7 @@ adjust_field_rtx_def (t, opt)\n   rtvec_tp = create_pointer (find_structure (\"rtvec_def\", 0));\n   tree_tp = create_pointer (find_structure (\"tree_node\", 1));\n   mem_attrs_tp = create_pointer (find_structure (\"mem_attrs\", 0));\n+  reg_attrs_tp = create_pointer (find_structure (\"reg_attrs\", 0));\n   bitmap_tp = create_pointer (find_structure (\"bitmap_element_def\", 0));\n   basic_block_tp = create_pointer (find_structure (\"basic_block_def\", 0));\n   scalar_tp = create_scalar_type (\"rtunion scalar\", 14);\n@@ -523,6 +524,8 @@ adjust_field_rtx_def (t, opt)\n \t\tt = scalar_tp, subname = \"rtint\";\n \t      else if (i == REG && aindex == 1)\n \t\tt = scalar_tp, subname = \"rtint\";\n+\t      else if (i == REG && aindex == 2)\n+\t\tt = reg_attrs_tp, subname = \"rtreg\";\n \t      else if (i == SCRATCH && aindex == 0)\n \t\tt = scalar_tp, subname = \"rtint\";\n \t      else if (i == BARRIER && aindex >= 3)"}, {"sha": "6eef65038fc3402a6fc7202ca26b4008ba576955", "filename": "gcc/integrate.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3", "patch": "@@ -1838,14 +1838,6 @@ integrate_decl_tree (let, map)\n \t  subst_constants (&r, NULL_RTX, map, 1);\n \t  SET_DECL_RTL (d, r);\n \n-\t  if (GET_CODE (r) == REG)\n-\t    REGNO_DECL (REGNO (r)) = d;\n-\t  else if (GET_CODE (r) == CONCAT)\n-\t    {\n-\t      REGNO_DECL (REGNO (XEXP (r, 0))) = d;\n-\t      REGNO_DECL (REGNO (XEXP (r, 1))) = d;\n-\t    }\n-\n \t  apply_change_group ();\n \t}\n "}, {"sha": "6930e76c5aae26f1414dad4e7391fb3ea73d393f", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3", "patch": "@@ -409,6 +409,23 @@ print_rtx (in_rtx)\n \t    else\n \t      fprintf (outfile, \" %d\", value);\n \n+\t    if (GET_CODE (in_rtx) == REG && REG_ATTRS (in_rtx))\n+\t      {\n+\t\tfputs (\" [\", outfile);\n+\t\tif (ORIGINAL_REGNO (in_rtx) != REGNO (in_rtx))\n+\t\t  fprintf (outfile, \"orig:%i\", ORIGINAL_REGNO (in_rtx));\n+\t\tif (REG_EXPR (in_rtx))\n+\t\t  print_mem_expr (outfile, REG_EXPR (in_rtx));\n+\n+\t\tif (REG_OFFSET (in_rtx))\n+\t\t  {\n+\t\t    fputc ('+', outfile);\n+\t\t    fprintf (outfile, HOST_WIDE_INT_PRINT_DEC,\n+\t\t\t     REG_OFFSET (in_rtx));\n+\t\t  }\n+\t\tfputs (\" ]\", outfile);\n+\t      }\n+\n \t    if (is_insn && &INSN_CODE (in_rtx) == &XINT (in_rtx, i)\n \t\t&& XINT (in_rtx, i) >= 0\n \t\t&& (name = get_insn_name (XINT (in_rtx, i))) != NULL)"}, {"sha": "21cb6ead80f2be0961d2fff0f2de149855b0e043", "filename": "gcc/regclass.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3", "patch": "@@ -2520,7 +2520,7 @@ reg_scan_mark_refs (x, insn, note_flag, min_regno)\n \tREG_POINTER (SET_DEST (x)) = 1;\n \n       /* If this is setting a register from a register or from a simple\n-\t conversion of a register, propagate REG_DECL.  */\n+\t conversion of a register, propagate REG_EXPR.  */\n       if (GET_CODE (dest) == REG)\n \t{\n \t  rtx src = SET_SRC (x);\n@@ -2531,10 +2531,10 @@ reg_scan_mark_refs (x, insn, note_flag, min_regno)\n \t\t || (GET_CODE (src) == SUBREG && subreg_lowpart_p (src)))\n \t    src = XEXP (src, 0);\n \n-\t  if (GET_CODE (src) == REG && REGNO_DECL (REGNO (src)) == 0)\n-\t    REGNO_DECL (REGNO (src)) = REGNO_DECL (REGNO (dest));\n-\t  else if (GET_CODE (src) == REG && REGNO_DECL (REGNO (dest)) == 0)\n-\t    REGNO_DECL (REGNO (dest)) = REGNO_DECL (REGNO (src));\n+\t  if (!REG_ATTRS (dest) && REG_P (src))\n+\t    REG_ATTRS (dest) = REG_ATTRS (src);\n+\t  if (!REG_ATTRS (dest) && GET_CODE (src) == MEM)\n+\t    set_reg_attrs_from_mem (dest, src);\n \t}\n \n       /* ... fall through ...  */"}, {"sha": "90625dbee671c627a2d6ff01e6063799e4c8bace", "filename": "gcc/reload1.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3", "patch": "@@ -2081,9 +2081,10 @@ alter_reg (i, from_reg)\n \n       /* If we have a decl for the original register, set it for the\n \t memory.  If this is a shared MEM, make a copy.  */\n-      if (REGNO_DECL (i))\n+      if (REG_EXPR (regno_reg_rtx[i])\n+\t  && TREE_CODE_CLASS (TREE_CODE (REG_EXPR (regno_reg_rtx[i]))) == 'd')\n \t{\n-\t  rtx decl = DECL_RTL_IF_SET (REGNO_DECL (i));\n+\t  rtx decl = DECL_RTL_IF_SET (REG_EXPR (regno_reg_rtx[i]));\n \n \t  /* We can do this only for the DECLs home pseudo, not for\n \t     any copies of it, since otherwise when the stack slot\n@@ -2094,7 +2095,7 @@ alter_reg (i, from_reg)\n \t      if (from_reg != -1 && spill_stack_slot[from_reg] == x)\n \t\tx = copy_rtx (x);\n \n-\t      set_mem_expr (x, REGNO_DECL (i));\n+\t      set_mem_attrs_from_reg (x, regno_reg_rtx[i]);\n \t    }\n \t}\n "}, {"sha": "e3be833e15f0ae6f6f32e0c0bd9a24ccf2a4bafe", "filename": "gcc/rtl.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3", "patch": "@@ -811,7 +811,7 @@ DEF_RTL_EXPR(VALUE, \"value\", \"0\", 'o')\n    pseudo register that got turned into a hard register.\n    This rtx needs to have as many (or more) fields as a MEM, since we\n    can change REG rtx's into MEMs during reload.  */\n-DEF_RTL_EXPR(REG, \"reg\", \"i0\", 'o')\n+DEF_RTL_EXPR(REG, \"reg\", \"i00\", 'o')\n \n /* A scratch register.  This represents a register used only within a\n    single insn.  It will be turned into a REG during register allocation"}, {"sha": "7531d8a1cfa10ecab25d64313e08489564837947", "filename": "gcc/rtl.h", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3", "patch": "@@ -103,6 +103,15 @@ typedef struct mem_attrs GTY(())\n   unsigned int align;\t\t/* Alignment of MEM in bits.  */\n } mem_attrs;\n \n+/* Structure used to describe the attributes of a REG in similar way as\n+   mem_attrs does for MEM above.  */\n+\n+typedef struct reg_attrs GTY(())\n+{\n+  tree decl;\t\t\t/* decl corresponding to REG.  */\n+  HOST_WIDE_INT offset;\t\t/* Offset from start of DECL.  */\n+} reg_attrs;\n+\n /* Common union for an element of an rtx.  */\n \n union rtunion_def\n@@ -120,6 +129,7 @@ union rtunion_def\n   tree rttree;\n   struct basic_block_def *bb;\n   mem_attrs *rtmem;\n+  reg_attrs *rtreg;\n };\n typedef union rtunion_def rtunion;\n \n@@ -499,7 +509,8 @@ do {\t\t\t\t\\\n #define X0BBDEF(RTX, N)\t   (RTL_CHECK1 (RTX, N, '0').bb)\n #define X0ADVFLAGS(RTX, N) (RTL_CHECK1 (RTX, N, '0').rt_addr_diff_vec_flags)\n #define X0CSELIB(RTX, N)   (RTL_CHECK1 (RTX, N, '0').rt_cselib)\n-#define X0MEMATTR(RTX, N)  (RTL_CHECK1 (RTX, N, '0').rtmem)\n+#define X0MEMATTR(RTX, N)  (RTL_CHECKC1 (RTX, N, MEM).rtmem)\n+#define X0REGATTR(RTX, N)  (RTL_CHECKC1 (RTX, N, REG).rtreg)\n \n #define XCWINT(RTX, N, C)     (RTL_CHECKC1 (RTX, N, C).rtwint)\n #define XCINT(RTX, N, C)      (RTL_CHECKC1 (RTX, N, C).rtint)\n@@ -1128,6 +1139,10 @@ do {\t\t\t\t\t\t\\\n    in the block and provide defaults if none specified.  */\n #define MEM_ATTRS(RTX) X0MEMATTR (RTX, 1)\n \n+/* The register attribute block.  We provide access macros for each value\n+   in the block and provide defaults if none specified.  */\n+#define REG_ATTRS(RTX) X0REGATTR (RTX, 2)\n+\n /* For a MEM rtx, the alias set.  If 0, this MEM is not in any alias\n    set, and may alias anything.  Otherwise, the MEM can only alias\n    MEMs in the same alias set.  This value is set in a\n@@ -1161,6 +1176,14 @@ do {\t\t\t\t\t\t\\\n  : (STRICT_ALIGNMENT && GET_MODE (RTX) != BLKmode\t\t\t\\\n     ? GET_MODE_ALIGNMENT (GET_MODE (RTX)) : BITS_PER_UNIT))\n \n+/* For a REG rtx, the decl it is known to refer to, if it is known to\n+   refer to part of a DECL.  */\n+#define REG_EXPR(RTX) (REG_ATTRS (RTX) == 0 ? 0 : REG_ATTRS (RTX)->decl)\n+\n+/* For a MEM rtx, the offset from the start of MEM_DECL, if known, as a\n+   RTX that is always a CONST_INT.  */\n+#define REG_OFFSET(RTX) (REG_ATTRS (RTX) == 0 ? 0 : REG_ATTRS (RTX)->offset)\n+\n /* Copy the attributes that apply to memory locations from RHS to LHS.  */\n #define MEM_COPY_ATTRIBUTES(LHS, RHS)\t\t\t\t\\\n   (MEM_VOLATILE_P (LHS) = MEM_VOLATILE_P (RHS),\t\t\t\\\n@@ -1365,6 +1388,8 @@ extern rtx copy_insn\t\t\tPARAMS ((rtx));\n extern rtx gen_int_mode\t\t\tPARAMS ((HOST_WIDE_INT,\n \t\t\t\t\t\t enum machine_mode));\n extern rtx emit_copy_of_insn_after\tPARAMS ((rtx, rtx));\n+extern void set_reg_attrs_from_mem\tPARAMS ((rtx, rtx));\n+extern void set_mem_attrs_from_reg\tPARAMS ((rtx, rtx));\n \n /* In rtl.c */\n extern rtx rtx_alloc\t\t\tPARAMS ((RTX_CODE));\n@@ -1382,6 +1407,8 @@ extern int rtx_equal_p                  PARAMS ((rtx, rtx));\n /* In emit-rtl.c */\n extern rtvec gen_rtvec_v\t\tPARAMS ((int, rtx *));\n extern rtx gen_reg_rtx\t\t\tPARAMS ((enum machine_mode));\n+extern rtx gen_rtx_REG_offset\t\tPARAMS ((rtx, enum machine_mode,\n+\t\t\t\t\t\t unsigned int, int));\n extern rtx gen_label_rtx\t\tPARAMS ((void));\n extern int subreg_hard_regno\t\tPARAMS ((rtx, int));\n extern rtx gen_lowpart_common\t\tPARAMS ((enum machine_mode, rtx));"}, {"sha": "1cef92a211fa3183f51ae8a7f6c609f0ef6f8ce8", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3", "patch": "@@ -2568,7 +2568,7 @@ simplify_subreg (outermode, op, innermode, byte)\n       if (HARD_REGNO_MODE_OK (final_regno, outermode)\n \t  || ! HARD_REGNO_MODE_OK (REGNO (op), innermode))\n \t{\n-\t  rtx x = gen_rtx_REG (outermode, final_regno);\n+\t  rtx x = gen_rtx_REG_offset (op, outermode, final_regno, byte);\n \n \t  /* Propagate original regno.  We don't have any way to specify\n \t     the offset inside original regno, so do so only for lowpart."}, {"sha": "8d7d1435def382d35003fcf0637d2acbaf59aad7", "filename": "gcc/stmt.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3", "patch": "@@ -3908,14 +3908,6 @@ expand_decl (decl)\n \n       SET_DECL_RTL (decl, gen_reg_rtx (reg_mode));\n \n-      if (GET_CODE (DECL_RTL (decl)) == REG)\n-\tREGNO_DECL (REGNO (DECL_RTL (decl))) = decl;\n-      else if (GET_CODE (DECL_RTL (decl)) == CONCAT)\n-\t{\n-\t  REGNO_DECL (REGNO (XEXP (DECL_RTL (decl), 0))) = decl;\n-\t  REGNO_DECL (REGNO (XEXP (DECL_RTL (decl), 1))) = decl;\n-\t}\n-\n       mark_user_reg (DECL_RTL (decl));\n \n       if (POINTER_TYPE_P (type))"}, {"sha": "0b6b4e0fea2f0dc1294e0e8e99d65ebce5ab04c4", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=a560d4d4d9f0fc66fd7634dac3b13d72ee0790d3", "patch": "@@ -1517,7 +1517,7 @@ struct tree_type GTY(())\n    ? (NODE)->decl.rtl\t\t\t\t\t\\\n    : (make_decl_rtl (NODE, NULL), (NODE)->decl.rtl))\n /* Set the DECL_RTL for NODE to RTL.  */\n-#define SET_DECL_RTL(NODE, RTL) (DECL_CHECK (NODE)->decl.rtl = (RTL))\n+#define SET_DECL_RTL(NODE, RTL) set_decl_rtl (NODE, RTL)\n /* Returns nonzero if the DECL_RTL for NODE has already been set.  */\n #define DECL_RTL_SET_P(NODE)  (DECL_CHECK (NODE)->decl.rtl != NULL)\n /* Copy the RTL from NODE1 to NODE2.  If the RTL was not set for\n@@ -3173,6 +3173,9 @@ extern void dump_end\t\t\tPARAMS ((enum tree_dump_index, FILE *));\n extern void dump_node\t\t\tPARAMS ((tree, int, FILE *));\n extern int dump_switch_p                PARAMS ((const char *));\n extern const char *dump_flag_name\tPARAMS ((enum tree_dump_index));\n+/* Assign the RTX to declaration.  */\n+\n+extern void set_decl_rtl\t\tPARAMS ((tree, rtx));\n \n \f\n /* Redefine abort to report an internal error w/o coredump, and"}]}