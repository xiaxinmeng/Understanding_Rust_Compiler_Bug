{"sha": "8480102e8bb71f7cd13c736faebac952fc4164db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ4MDEwMmU4YmI3MWY3Y2QxM2M3MzZmYWViYWM5NTJmYzQxNjRkYg==", "commit": {"author": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1991-06-09T15:18:43Z"}, "committer": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1991-06-09T15:18:43Z"}, "message": "entered into RCS\n\nFrom-SVN: r28", "tree": {"sha": "f0456237bf6dbb76b4c016c51cff56c50b609daa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0456237bf6dbb76b4c016c51cff56c50b609daa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8480102e8bb71f7cd13c736faebac952fc4164db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8480102e8bb71f7cd13c736faebac952fc4164db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8480102e8bb71f7cd13c736faebac952fc4164db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8480102e8bb71f7cd13c736faebac952fc4164db/comments", "author": null, "committer": null, "parents": [{"sha": "acde64ae54d3a8d743cd1fd69f6da3df2e0f21a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acde64ae54d3a8d743cd1fd69f6da3df2e0f21a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acde64ae54d3a8d743cd1fd69f6da3df2e0f21a6"}], "stats": {"total": 299, "additions": 299, "deletions": 0}, "files": [{"sha": "aa71c14905f14c75401ee267767773c98e62cee0", "filename": "gcc/config/fx80/fx80.c", "status": "added", "additions": 299, "deletions": 0, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8480102e8bb71f7cd13c736faebac952fc4164db/gcc%2Fconfig%2Ffx80%2Ffx80.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8480102e8bb71f7cd13c736faebac952fc4164db/gcc%2Fconfig%2Ffx80%2Ffx80.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffx80%2Ffx80.c?ref=8480102e8bb71f7cd13c736faebac952fc4164db", "patch": "@@ -0,0 +1,299 @@\n+/* Subroutines for insn-output.c for Alliant FX computers.\n+   Copyright (C) 1989,1991 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* Some output-actions in alliant.md need these.  */\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+\n+/* Index into this array by (register number >> 3) to find the\n+   smallest class which contains that register.  */\n+enum reg_class regno_reg_class[]\n+  = { DATA_REGS, ADDR_REGS, FP_REGS };\n+\n+static rtx find_addr_reg ();\n+\n+char *\n+output_btst (operands, countop, dataop, insn, signpos)\n+     rtx *operands;\n+     rtx countop, dataop;\n+     rtx insn;\n+     int signpos;\n+{\n+  operands[0] = countop;\n+  operands[1] = dataop;\n+\n+  if (GET_CODE (countop) == CONST_INT)\n+    {\n+      register int count = INTVAL (countop);\n+      /* If COUNT is bigger than size of storage unit in use,\n+\t advance to the containing unit of same size.  */\n+      if (count > signpos)\n+\t{\n+\t  int offset = (count & ~signpos) / 8;\n+\t  count = count & signpos;\n+\t  operands[1] = dataop = adj_offsettable_operand (dataop, offset);\n+\t}\n+      if (count == signpos)\n+\tcc_status.flags = CC_NOT_POSITIVE | CC_Z_IN_NOT_N;\n+      else\n+\tcc_status.flags = CC_NOT_NEGATIVE | CC_Z_IN_NOT_N;\n+\n+      /* These three statements used to use next_insns_test_no...\n+\t but it appears that this should do the same job.  */\n+      if (count == 31\n+\t  && next_insn_tests_no_inequality (insn))\n+\treturn \"tst%.l %1\";\n+      if (count == 15\n+\t  && next_insn_tests_no_inequality (insn))\n+\treturn \"tst%.w %1\";\n+      if (count == 7\n+\t  && next_insn_tests_no_inequality (insn))\n+\treturn \"tst%.b %1\";\n+\n+      cc_status.flags = CC_NOT_NEGATIVE;\n+    }\n+  return \"btst %0,%1\";\n+}\n+\f\n+/* Return the best assembler insn template\n+   for moving operands[1] into operands[0] as a fullword.  */\n+\n+static char *\n+singlemove_string (operands)\n+     rtx *operands;\n+{\n+  if (operands[1] != const0_rtx)\n+    return \"mov%.l %1,%0\";\n+  if (! ADDRESS_REG_P (operands[0]))\n+    return \"clr%.l %0\";\n+  return \"sub%.l %0,%0\";\n+}\n+\n+/* Output assembler code to perform a doubleword move insn\n+   with operands OPERANDS.  */\n+\n+char *\n+output_move_double (operands)\n+     rtx *operands;\n+{\n+  enum { REGOP, OFFSOP, MEMOP, PUSHOP, POPOP, CNSTOP, RNDOP } optype0, optype1;\n+  rtx latehalf[2];\n+  rtx addreg0 = 0, addreg1 = 0;\n+\n+  /* First classify both operands.  */\n+\n+  if (REG_P (operands[0]))\n+    optype0 = REGOP;\n+  else if (offsettable_memref_p (operands[0]))\n+    optype0 = OFFSOP;\n+  else if (GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n+    optype0 = POPOP;\n+  else if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n+    optype0 = PUSHOP;\n+  else if (GET_CODE (operands[0]) == MEM)\n+    optype0 = MEMOP;\n+  else\n+    optype0 = RNDOP;\n+\n+  if (REG_P (operands[1]))\n+    optype1 = REGOP;\n+  else if (CONSTANT_P (operands[1]))\n+    optype1 = CNSTOP;\n+  else if (offsettable_memref_p (operands[1]))\n+    optype1 = OFFSOP;\n+  else if (GET_CODE (XEXP (operands[1], 0)) == POST_INC)\n+    optype1 = POPOP;\n+  else if (GET_CODE (XEXP (operands[1], 0)) == PRE_DEC)\n+    optype1 = PUSHOP;\n+  else if (GET_CODE (operands[1]) == MEM)\n+    optype1 = MEMOP;\n+  else\n+    optype1 = RNDOP;\n+\n+  /* Check for the cases that the operand constraints are not\n+     supposed to allow to happen.  Abort if we get one,\n+     because generating code for these cases is painful.  */\n+\n+  if (optype0 == RNDOP || optype1 == RNDOP)\n+    abort ();\n+\n+  /* If one operand is decrementing and one is incrementing\n+     decrement the former register explicitly\n+     and change that operand into ordinary indexing.  */\n+\n+  if (optype0 == PUSHOP && optype1 == POPOP)\n+    {\n+      operands[0] = XEXP (XEXP (operands[0], 0), 0);\n+      output_asm_insn (\"subq%.l %#8,%0\", operands);\n+      operands[0] = gen_rtx (MEM, DImode, operands[0]);\n+      optype0 = OFFSOP;\n+    }\n+  if (optype0 == POPOP && optype1 == PUSHOP)\n+    {\n+      operands[1] = XEXP (XEXP (operands[1], 0), 0);\n+      output_asm_insn (\"subq%.l %#8,%1\", operands);\n+      operands[1] = gen_rtx (MEM, DImode, operands[1]);\n+      optype1 = OFFSOP;\n+    }\n+\n+  /* If an operand is an unoffsettable memory ref, find a register\n+     we can increment temporarily to make it refer to the second word.  */\n+\n+  if (optype0 == MEMOP)\n+    addreg0 = find_addr_reg (XEXP (operands[0], 0));\n+\n+  if (optype1 == MEMOP)\n+    addreg1 = find_addr_reg (XEXP (operands[1], 0));\n+\n+  /* Ok, we can do one word at a time.\n+     Normally we do the low-numbered word first,\n+     but if either operand is autodecrementing then we\n+     do the high-numbered word first.\n+\n+     In either case, set up in LATEHALF the operands to use\n+     for the high-numbered word and in some cases alter the\n+     operands in OPERANDS to be suitable for the low-numbered word.  */\n+\n+  if (optype0 == REGOP)\n+    latehalf[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  else if (optype0 == OFFSOP)\n+    latehalf[0] = adj_offsettable_operand (operands[0], 4);\n+  else\n+    latehalf[0] = operands[0];\n+\n+  if (optype1 == REGOP)\n+    latehalf[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+  else if (optype1 == OFFSOP)\n+    latehalf[1] = adj_offsettable_operand (operands[1], 4);\n+  else if (optype1 == CNSTOP)\n+    {\n+      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\tsplit_double (operands[1], &operands[1], &latehalf[1]);\n+      else if (CONSTANT_P (operands[1]))\n+\t{\n+\t  latehalf[1] = operands[1];\n+\t  operands[1] = const0_rtx;\n+\t}\n+    }\n+  else\n+    latehalf[1] = operands[1];\n+\n+  /* If insn is effectively movd N(sp),-(sp) then we will do the\n+     high word first.  We should use the adjusted operand 1 (which is N+4(sp))\n+     for the low word as well, to compensate for the first decrement of sp.  */\n+  if (optype0 == PUSHOP\n+      && REGNO (XEXP (XEXP (operands[0], 0), 0)) == STACK_POINTER_REGNUM\n+      && reg_overlap_mentioned_p (stack_pointer_rtx, operands[1]))\n+    operands[1] = latehalf[1];\n+\n+  /* If one or both operands autodecrementing,\n+     do the two words, high-numbered first.  */\n+\n+  /* Likewise,  the first move would clobber the source of the second one,\n+     do them in the other order.  This happens only for registers;\n+     such overlap can't happen in memory unless the user explicitly\n+     sets it up, and that is an undefined circumstance.  */\n+\n+  if (optype0 == PUSHOP || optype1 == PUSHOP\n+      || (optype0 == REGOP && optype1 == REGOP\n+\t  && REGNO (operands[0]) == REGNO (latehalf[1])))\n+    {\n+      /* Make any unoffsettable addresses point at high-numbered word.  */\n+      if (addreg0)\n+\toutput_asm_insn (\"addql %#4,%0\", &addreg0);\n+      if (addreg1)\n+\toutput_asm_insn (\"addql %#4,%0\", &addreg1);\n+\n+      /* Do that word.  */\n+      output_asm_insn (singlemove_string (latehalf), latehalf);\n+\n+      /* Undo the adds we just did.  */\n+      if (addreg0)\n+\toutput_asm_insn (\"subql %#4,%0\", &addreg0);\n+      if (addreg1)\n+\toutput_asm_insn (\"subql %#4,%0\", &addreg1);\n+\n+      /* Do low-numbered word.  */\n+      return singlemove_string (operands);\n+    }\n+\n+  /* Normal case: do the two words, low-numbered first.  */\n+\n+  output_asm_insn (singlemove_string (operands), operands);\n+\n+  /* Make any unoffsettable addresses point at high-numbered word.  */\n+  if (addreg0)\n+    output_asm_insn (\"addql %#4,%0\", &addreg0);\n+  if (addreg1)\n+    output_asm_insn (\"addql %#4,%0\", &addreg1);\n+\n+  /* Do that word.  */\n+  output_asm_insn (singlemove_string (latehalf), latehalf);\n+\n+  /* Undo the adds we just did.  */\n+  if (addreg0)\n+    output_asm_insn (\"subql %#4,%0\", &addreg0);\n+  if (addreg1)\n+    output_asm_insn (\"subql %#4,%0\", &addreg1);\n+\n+  return \"\";\n+}\n+\n+/* Return a REG that occurs in ADDR with coefficient 1.\n+   ADDR can be effectively incremented by incrementing REG.  */\n+\n+static rtx\n+find_addr_reg (addr)\n+     rtx addr;\n+{\n+  while (GET_CODE (addr) == PLUS)\n+    {\n+      if (GET_CODE (XEXP (addr, 0)) == REG)\n+\taddr = XEXP (addr, 0);\n+      else if (GET_CODE (XEXP (addr, 1)) == REG)\n+\taddr = XEXP (addr, 1);\n+      else if (CONSTANT_P (XEXP (addr, 0)))\n+\taddr = XEXP (addr, 1);\n+      else if (CONSTANT_P (XEXP (addr, 1)))\n+\taddr = XEXP (addr, 0);\n+      else\n+\tabort ();\n+    }\n+  if (GET_CODE (addr) == REG)\n+    return addr;\n+  abort ();\n+}\n+\n+int\n+standard_SunFPA_constant_p (x)\n+     rtx x;\n+{\n+  return( 0 );\n+}\n+"}]}