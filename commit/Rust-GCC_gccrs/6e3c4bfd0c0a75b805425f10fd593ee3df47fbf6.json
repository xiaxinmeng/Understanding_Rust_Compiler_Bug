{"sha": "6e3c4bfd0c0a75b805425f10fd593ee3df47fbf6", "node_id": "C_kwDOANBUbNoAKDZlM2M0YmZkMGMwYTc1YjgwNTQyNWYxMGZkNTkzZWUzZGY0N2ZiZjY", "commit": {"author": {"name": "Stefan Schulze Frielinghaus", "email": "stefansf@linux.ibm.com", "date": "2021-10-11T07:59:32Z"}, "committer": {"name": "Stefan Schulze Frielinghaus", "email": "stefansf@linux.ibm.com", "date": "2021-10-11T07:59:32Z"}, "message": "IBM Z: Provide rawmemchr{qi,hi,si} expander\n\ngcc/ChangeLog:\n\n\t* config/s390/s390-protos.h (s390_rawmemchr): Add prototype.\n\t* config/s390/s390.c (s390_rawmemchr): New function.\n\t* config/s390/s390.md (rawmemchr<SINT:mode>): New expander.\n\t* config/s390/vector.md (@vec_vfees<mode>): Basically a copy of\n\tthe pattern vfees<mode> from vx-builtins.md.\n\t* config/s390/vx-builtins.md (*vfees<mode>): Remove.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/s390/rawmemchr-1.c: New test.", "tree": {"sha": "51484c5cd99a89bbcd08f321b72c7fa823dbea97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51484c5cd99a89bbcd08f321b72c7fa823dbea97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e3c4bfd0c0a75b805425f10fd593ee3df47fbf6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e3c4bfd0c0a75b805425f10fd593ee3df47fbf6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e3c4bfd0c0a75b805425f10fd593ee3df47fbf6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e3c4bfd0c0a75b805425f10fd593ee3df47fbf6/comments", "author": {"login": "stefan-sf-ibm", "id": 73470131, "node_id": "MDQ6VXNlcjczNDcwMTMx", "avatar_url": "https://avatars.githubusercontent.com/u/73470131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stefan-sf-ibm", "html_url": "https://github.com/stefan-sf-ibm", "followers_url": "https://api.github.com/users/stefan-sf-ibm/followers", "following_url": "https://api.github.com/users/stefan-sf-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/stefan-sf-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/stefan-sf-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stefan-sf-ibm/subscriptions", "organizations_url": "https://api.github.com/users/stefan-sf-ibm/orgs", "repos_url": "https://api.github.com/users/stefan-sf-ibm/repos", "events_url": "https://api.github.com/users/stefan-sf-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/stefan-sf-ibm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "stefan-sf-ibm", "id": 73470131, "node_id": "MDQ6VXNlcjczNDcwMTMx", "avatar_url": "https://avatars.githubusercontent.com/u/73470131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stefan-sf-ibm", "html_url": "https://github.com/stefan-sf-ibm", "followers_url": "https://api.github.com/users/stefan-sf-ibm/followers", "following_url": "https://api.github.com/users/stefan-sf-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/stefan-sf-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/stefan-sf-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stefan-sf-ibm/subscriptions", "organizations_url": "https://api.github.com/users/stefan-sf-ibm/orgs", "repos_url": "https://api.github.com/users/stefan-sf-ibm/repos", "events_url": "https://api.github.com/users/stefan-sf-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/stefan-sf-ibm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f966f06146be7689af471d152e18ff50c609d99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f966f06146be7689af471d152e18ff50c609d99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f966f06146be7689af471d152e18ff50c609d99"}], "stats": {"total": 229, "additions": 203, "deletions": 26}, "files": [{"sha": "c1616357b8c8233a25377b107d098c0792e44f06", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e3c4bfd0c0a75b805425f10fd593ee3df47fbf6/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e3c4bfd0c0a75b805425f10fd593ee3df47fbf6/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=6e3c4bfd0c0a75b805425f10fd593ee3df47fbf6", "patch": "@@ -66,6 +66,8 @@ s390_asm_declare_function_size (FILE *asm_out_file,\n \t\t\t\tconst char *fnname ATTRIBUTE_UNUSED, tree decl);\n #endif\n \n+extern void s390_rawmemchr (machine_mode elt_mode, rtx dst, rtx src, rtx pat);\n+\n #ifdef RTX_CODE\n extern int s390_extra_constraint_str (rtx, int, const char *);\n extern int s390_const_ok_for_constraint_p (HOST_WIDE_INT, int, const char *);"}, {"sha": "85dd78c341806c258722457654c7d13c7aee3a89", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e3c4bfd0c0a75b805425f10fd593ee3df47fbf6/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e3c4bfd0c0a75b805425f10fd593ee3df47fbf6/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=6e3c4bfd0c0a75b805425f10fd593ee3df47fbf6", "patch": "@@ -16569,6 +16569,75 @@ s390_excess_precision (enum excess_precision_type type)\n }\n #endif\n \n+void\n+s390_rawmemchr (machine_mode elt_mode, rtx dst, rtx src, rtx pat)\n+{\n+  machine_mode vec_mode = mode_for_vector (as_a <scalar_int_mode> (elt_mode),\n+\t\t\t\t\t   16 / GET_MODE_SIZE (elt_mode)).require();\n+  rtx lens = gen_reg_rtx (V16QImode);\n+  rtx pattern = gen_reg_rtx (vec_mode);\n+  rtx loop_start = gen_label_rtx ();\n+  rtx loop_end = gen_label_rtx ();\n+  rtx addr = gen_reg_rtx (Pmode);\n+  rtx offset = gen_reg_rtx (Pmode);\n+  rtx loadlen = gen_reg_rtx (SImode);\n+  rtx matchlen = gen_reg_rtx (SImode);\n+  rtx mem;\n+\n+  pat = GEN_INT (trunc_int_for_mode (INTVAL (pat), elt_mode));\n+  emit_insn (gen_rtx_SET (pattern, gen_rtx_VEC_DUPLICATE (vec_mode, pat)));\n+\n+  emit_move_insn (addr, XEXP (src, 0));\n+\n+  // alignment\n+  emit_insn (gen_vlbb (lens, gen_rtx_MEM (BLKmode, addr), GEN_INT (6)));\n+  emit_insn (gen_lcbb (loadlen, addr, GEN_INT (6)));\n+  lens = convert_to_mode (vec_mode, lens, 1);\n+  emit_insn (gen_vec_vfees (vec_mode, lens, lens, pattern, GEN_INT (0)));\n+  lens = convert_to_mode (V4SImode, lens, 1);\n+  emit_insn (gen_vec_extractv4sisi (matchlen, lens, GEN_INT (1)));\n+  lens = convert_to_mode (vec_mode, lens, 1);\n+  emit_cmp_and_jump_insns (matchlen, loadlen, LT, NULL_RTX, SImode, 1, loop_end);\n+  force_expand_binop (Pmode, add_optab, addr, GEN_INT(16), addr, 1, OPTAB_DIRECT);\n+  force_expand_binop (Pmode, and_optab, addr, GEN_INT(~HOST_WIDE_INT_UC(0xf)), addr, 1, OPTAB_DIRECT);\n+  // now, addr is 16-byte aligned\n+\n+  mem = gen_rtx_MEM (vec_mode, addr);\n+  set_mem_align (mem, 128);\n+  emit_move_insn (lens, mem);\n+  emit_insn (gen_vec_vfees (vec_mode, lens, lens, pattern, GEN_INT (VSTRING_FLAG_CS)));\n+  add_int_reg_note (s390_emit_ccraw_jump (4, EQ, loop_end),\n+\t\t    REG_BR_PROB,\n+\t\t    profile_probability::very_unlikely ().to_reg_br_prob_note ());\n+\n+  emit_label (loop_start);\n+  LABEL_NUSES (loop_start) = 1;\n+\n+  force_expand_binop (Pmode, add_optab, addr, GEN_INT (16), addr, 1, OPTAB_DIRECT);\n+  mem = gen_rtx_MEM (vec_mode, addr);\n+  set_mem_align (mem, 128);\n+  emit_move_insn (lens, mem);\n+  emit_insn (gen_vec_vfees (vec_mode, lens, lens, pattern, GEN_INT (VSTRING_FLAG_CS)));\n+  add_int_reg_note (s390_emit_ccraw_jump (4, NE, loop_start),\n+\t\t    REG_BR_PROB,\n+\t\t    profile_probability::very_likely ().to_reg_br_prob_note ());\n+\n+  emit_label (loop_end);\n+  LABEL_NUSES (loop_end) = 1;\n+\n+  if (TARGET_64BIT)\n+    {\n+      lens = convert_to_mode (V2DImode, lens, 1);\n+      emit_insn (gen_vec_extractv2didi (offset, lens, GEN_INT (0)));\n+    }\n+  else\n+    {\n+      lens = convert_to_mode (V4SImode, lens, 1);\n+      emit_insn (gen_vec_extractv4sisi (offset, lens, GEN_INT (1)));\n+    }\n+  force_expand_binop (Pmode, add_optab, addr, offset, dst, 1, OPTAB_DIRECT);\n+}\n+\n /* Implement the TARGET_ASAN_SHADOW_OFFSET hook.  */\n \n static unsigned HOST_WIDE_INT"}, {"sha": "b8bdbaec4685c92bd089a2150cc1b33395efa00a", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e3c4bfd0c0a75b805425f10fd593ee3df47fbf6/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e3c4bfd0c0a75b805425f10fd593ee3df47fbf6/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=6e3c4bfd0c0a75b805425f10fd593ee3df47fbf6", "patch": "@@ -12258,3 +12258,10 @@\n \t\t    UNSPECV_PPA)]\n   \"TARGET_ZEC12\"\n   \"\")\n+\n+(define_expand \"rawmemchr<SINT:mode>\"\n+  [(match_operand      0 \"register_operand\")\n+   (match_operand      1 \"memory_operand\")\n+   (match_operand:SINT 2 \"const_int_operand\")]\n+  \"TARGET_VX\"\n+  \"s390_rawmemchr(<SINT:MODE>mode, operands[0], operands[1], operands[2]); DONE;\")"}, {"sha": "1ed1d0665d499190a91f74d4851aea6c491e0a20", "filename": "gcc/config/s390/vector.md", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e3c4bfd0c0a75b805425f10fd593ee3df47fbf6/gcc%2Fconfig%2Fs390%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e3c4bfd0c0a75b805425f10fd593ee3df47fbf6/gcc%2Fconfig%2Fs390%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fvector.md?ref=6e3c4bfd0c0a75b805425f10fd593ee3df47fbf6", "patch": "@@ -1988,6 +1988,32 @@\n   \"vll\\t%v0,%1,%2\"\n   [(set_attr \"op_type\" \"VRS\")])\n \n+; vfeebs, vfeehs, vfeefs\n+; vfeezbs, vfeezhs, vfeezfs\n+(define_insn \"@vec_vfees<mode>\"\n+  [(set (match_operand:VI_HW_QHS 0 \"register_operand\" \"=v\")\n+\t(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 \"register_operand\" \"v\")\n+\t\t\t   (match_operand:VI_HW_QHS 2 \"register_operand\" \"v\")\n+\t\t\t   (match_operand:QI 3 \"const_mask_operand\" \"C\")]\n+\t\t\t  UNSPEC_VEC_VFEE))\n+   (set (reg:CCRAW CC_REGNUM)\n+\t(unspec:CCRAW [(match_dup 1)\n+\t\t       (match_dup 2)\n+\t\t       (match_dup 3)]\n+\t\t      UNSPEC_VEC_VFEECC))]\n+  \"TARGET_VX\"\n+{\n+  unsigned HOST_WIDE_INT flags = UINTVAL (operands[3]);\n+\n+  gcc_assert (!(flags & ~(VSTRING_FLAG_ZS | VSTRING_FLAG_CS)));\n+  flags &= ~VSTRING_FLAG_CS;\n+\n+  if (flags == VSTRING_FLAG_ZS)\n+    return \"vfeez<bhfgq>s\\t%v0,%v1,%v2\";\n+  return \"vfee<bhfgq>s\\t%v0,%v1,%v2\";\n+}\n+  [(set_attr \"op_type\" \"VRR\")])\n+\n ; vfenebs, vfenehs, vfenefs\n ; vfenezbs, vfenezhs, vfenezfs\n (define_insn \"vec_vfenes<mode>\""}, {"sha": "efa77992f31aae3c4277776930182fb5d78773e7", "filename": "gcc/config/s390/vx-builtins.md", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e3c4bfd0c0a75b805425f10fd593ee3df47fbf6/gcc%2Fconfig%2Fs390%2Fvx-builtins.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e3c4bfd0c0a75b805425f10fd593ee3df47fbf6/gcc%2Fconfig%2Fs390%2Fvx-builtins.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fvx-builtins.md?ref=6e3c4bfd0c0a75b805425f10fd593ee3df47fbf6", "patch": "@@ -1366,32 +1366,6 @@\n \n ; Vector find element equal\n \n-; vfeebs, vfeehs, vfeefs\n-; vfeezbs, vfeezhs, vfeezfs\n-(define_insn \"*vfees<mode>\"\n-  [(set (match_operand:VI_HW_QHS 0 \"register_operand\" \"=v\")\n-\t(unspec:VI_HW_QHS [(match_operand:VI_HW_QHS 1 \"register_operand\" \"v\")\n-\t\t\t   (match_operand:VI_HW_QHS 2 \"register_operand\" \"v\")\n-\t\t\t   (match_operand:QI 3 \"const_mask_operand\" \"C\")]\n-\t\t\t  UNSPEC_VEC_VFEE))\n-   (set (reg:CCRAW CC_REGNUM)\n-\t(unspec:CCRAW [(match_dup 1)\n-\t\t       (match_dup 2)\n-\t\t       (match_dup 3)]\n-\t\t      UNSPEC_VEC_VFEECC))]\n-  \"TARGET_VX\"\n-{\n-  unsigned HOST_WIDE_INT flags = UINTVAL (operands[3]);\n-\n-  gcc_assert (!(flags & ~(VSTRING_FLAG_ZS | VSTRING_FLAG_CS)));\n-  flags &= ~VSTRING_FLAG_CS;\n-\n-  if (flags == VSTRING_FLAG_ZS)\n-    return \"vfeez<bhfgq>s\\t%v0,%v1,%v2\";\n-  return \"vfee<bhfgq>s\\t%v0,%v1,%v2,%b3\";\n-}\n-  [(set_attr \"op_type\" \"VRR\")])\n-\n ; vfeeb, vfeeh, vfeef\n (define_insn \"vfee<mode>\"\n   [(set (match_operand:VI_HW_QHS                    0 \"register_operand\" \"=v\")"}, {"sha": "a5125702315653613eb8b14c6318e2b2f7656ff6", "filename": "gcc/testsuite/gcc.target/s390/rawmemchr-1.c", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e3c4bfd0c0a75b805425f10fd593ee3df47fbf6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Frawmemchr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e3c4bfd0c0a75b805425f10fd593ee3df47fbf6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Frawmemchr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Frawmemchr-1.c?ref=6e3c4bfd0c0a75b805425f10fd593ee3df47fbf6", "patch": "@@ -0,0 +1,99 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -ftree-loop-distribution -fdump-tree-ldist-details -mzarch -march=z13\" } */\n+/* { dg-final { scan-tree-dump-times \"generated rawmemchrQI\" 2 \"ldist\" } } */\n+/* { dg-final { scan-tree-dump-times \"generated rawmemchrHI\" 2 \"ldist\" } } */\n+/* { dg-final { scan-tree-dump-times \"generated rawmemchrSI\" 2 \"ldist\" } } */\n+\n+#include <string.h>\n+#include <assert.h>\n+#include <stdint.h>\n+#include <stdlib.h>\n+\n+#define rawmemchrT(T, pattern)     \\\n+__attribute__((noinline,noclone))  \\\n+T* rawmemchr_##T (T *s)            \\\n+{                                  \\\n+  while (*s != pattern)            \\\n+    ++s;                           \\\n+  return s;                        \\\n+}\n+\n+rawmemchrT(int8_t, (int8_t)0xde)\n+rawmemchrT(uint8_t, 0xde)\n+rawmemchrT(int16_t, (int16_t)0xdead)\n+rawmemchrT(uint16_t, 0xdead)\n+rawmemchrT(int32_t, (int32_t)0xdeadbeef)\n+rawmemchrT(uint32_t, 0xdeadbeef)\n+\n+#define runT(T, pattern)                           \\\n+void run_##T ()                                    \\\n+{                                                  \\\n+  T *buf = malloc (4096 * 2 * sizeof(T));          \\\n+  assert (buf != NULL);                            \\\n+  memset (buf, 0xa, 4096 * 2 * sizeof(T));         \\\n+  /* ensure q is 4096-byte aligned */              \\\n+  T *q = (T*)((unsigned char *)buf                 \\\n+              + (4096 - ((uintptr_t)buf & 4095))); \\\n+  T *p;                                            \\\n+  /* unaligned + block boundary + 1st load */      \\\n+  p = (T *) ((uintptr_t)q - 8);                    \\\n+  p[2] = pattern;                                  \\\n+  assert ((rawmemchr_##T (&p[0]) == &p[2]));       \\\n+  p[2] = (T) 0xaaaaaaaa;                           \\\n+  /* unaligned + block boundary + 2nd load */      \\\n+  p = (T *) ((uintptr_t)q - 8);                    \\\n+  p[6] = pattern;                                  \\\n+  assert ((rawmemchr_##T (&p[0]) == &p[6]));       \\\n+  p[6] = (T) 0xaaaaaaaa;                           \\\n+  /* unaligned + 1st load */                       \\\n+  q[5] = pattern;                                  \\\n+  assert ((rawmemchr_##T (&q[2]) == &q[5]));       \\\n+  q[5] = (T) 0xaaaaaaaa;                           \\\n+  /* unaligned + 2nd load */                       \\\n+  q[14] = pattern;                                 \\\n+  assert ((rawmemchr_##T (&q[2]) == &q[14]));      \\\n+  q[14] = (T) 0xaaaaaaaa;                          \\\n+  /* unaligned + 3rd load */                       \\\n+  q[19] = pattern;                                 \\\n+  assert ((rawmemchr_##T (&q[2]) == &q[19]));      \\\n+  q[19] = (T) 0xaaaaaaaa;                          \\\n+  /* unaligned + 4th load */                       \\\n+  q[25] = pattern;                                 \\\n+  assert ((rawmemchr_##T (&q[2]) == &q[25]));      \\\n+  q[25] = (T) 0xaaaaaaaa;                          \\\n+  /* aligned + 1st load */                         \\\n+  q[5] = pattern;                                  \\\n+  assert ((rawmemchr_##T (&q[0]) == &q[5]));       \\\n+  q[5] = (T) 0xaaaaaaaa;                           \\\n+  /* aligned + 2nd load */                         \\\n+  q[14] = pattern;                                 \\\n+  assert ((rawmemchr_##T (&q[0]) == &q[14]));      \\\n+  q[14] = (T) 0xaaaaaaaa;                          \\\n+  /* aligned + 3rd load */                         \\\n+  q[19] = pattern;                                 \\\n+  assert ((rawmemchr_##T (&q[0]) == &q[19]));      \\\n+  q[19] = (T) 0xaaaaaaaa;                          \\\n+  /* aligned + 4th load */                         \\\n+  q[25] = pattern;                                 \\\n+  assert ((rawmemchr_##T (&q[0]) == &q[25]));      \\\n+  q[25] = (T) 0xaaaaaaaa;                          \\\n+  free (buf);                                      \\\n+}\n+\n+runT(int8_t, (int8_t)0xde)\n+runT(uint8_t, 0xde)\n+runT(int16_t, (int16_t)0xdead)\n+runT(uint16_t, 0xdead)\n+runT(int32_t, (int32_t)0xdeadbeef)\n+runT(uint32_t, 0xdeadbeef)\n+\n+int main (void)\n+{\n+  run_uint8_t ();\n+  run_int8_t ();\n+  run_uint16_t ();\n+  run_int16_t ();\n+  run_uint32_t ();\n+  run_int32_t ();\n+  return 0;\n+}"}]}