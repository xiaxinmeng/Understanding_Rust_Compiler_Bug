{"sha": "a68ad5bdee43a9796ae1f0f324508a5bff4f7cb0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTY4YWQ1YmRlZTQzYTk3OTZhZTFmMGYzMjQ1MDhhNWJmZjRmN2NiMA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-01-17T22:54:23Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-01-17T22:54:23Z"}, "message": "cp-tree.h (build_shared_int_cst): New function.\n\n\t* cp-tree.h (build_shared_int_cst): New function.\n\t* call.c (build_over_call): Use DECL_VIRTUAL_CONTEXT, for clarity.\n\t* class.c (modify_vtable_entry): Likewise.\n\t(add_virtual_function): Split out code to generated shared\n\tINTEGER_CSTs to build_share_int_cst.\n\t(modify_all_vtables): Handle all the overridden functions here.\n\tAdd overridden functions from non-primary virtual bases to the\n\tprimary vtable.\n\t(finish_struct_1): Adjust call to modify_all_vtables.  Add\n\toverridden functions from non-primary bases to the vtable.\n\t* tree.c (build_shared_int_cst): New function.\n\nFrom-SVN: r31476", "tree": {"sha": "e1f075186f74de41949ee32a597ec75cc91eb112", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e1f075186f74de41949ee32a597ec75cc91eb112"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a68ad5bdee43a9796ae1f0f324508a5bff4f7cb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a68ad5bdee43a9796ae1f0f324508a5bff4f7cb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a68ad5bdee43a9796ae1f0f324508a5bff4f7cb0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a68ad5bdee43a9796ae1f0f324508a5bff4f7cb0/comments", "author": null, "committer": null, "parents": [{"sha": "e41e26be41ba7e39df1dff5ef47f9a06a55281cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e41e26be41ba7e39df1dff5ef47f9a06a55281cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e41e26be41ba7e39df1dff5ef47f9a06a55281cc"}], "stats": {"total": 165, "additions": 122, "deletions": 43}, "files": [{"sha": "8fe890e329222a06300c428309f2cbce9efc7b44", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ad5bdee43a9796ae1f0f324508a5bff4f7cb0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ad5bdee43a9796ae1f0f324508a5bff4f7cb0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a68ad5bdee43a9796ae1f0f324508a5bff4f7cb0", "patch": "@@ -1,5 +1,17 @@\n 2000-01-17  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* cp-tree.h (build_shared_int_cst): New function.\n+\t* call.c (build_over_call): Use DECL_VIRTUAL_CONTEXT, for clarity.\n+\t* class.c (modify_vtable_entry): Likewise.\n+\t(add_virtual_function): Split out code to generated shared\n+\tINTEGER_CSTs to build_share_int_cst.\n+\t(modify_all_vtables): Handle all the overridden functions here.\n+\tAdd overridden functions from non-primary virtual bases to the\n+\tprimary vtable.\n+\t(finish_struct_1): Adjust call to modify_all_vtables.  Add\n+\toverridden functions from non-primary bases to the vtable.\n+\t* tree.c (build_shared_int_cst): New function.\n+\t\n \t* cp-tree.h (scratchalloc): Remove.\n \t(build_scratch_list): Likewise.\n \t* call.c (convert_class_to_reference): Replace build_scratch_list"}, {"sha": "f526abfa4fec5daa7e876d810345aaadc3daf1f1", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ad5bdee43a9796ae1f0f324508a5bff4f7cb0/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ad5bdee43a9796ae1f0f324508a5bff4f7cb0/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=a68ad5bdee43a9796ae1f0f324508a5bff4f7cb0", "patch": "@@ -4126,7 +4126,7 @@ build_over_call (cand, args, flags)\n     {\n       tree t, *p = &TREE_VALUE (converted_args);\n       tree binfo = get_binfo\n-\t(DECL_CONTEXT (fn), TREE_TYPE (TREE_TYPE (*p)), 0);\n+\t(DECL_VIRTUAL_CONTEXT (fn), TREE_TYPE (TREE_TYPE (*p)), 0);\n       *p = convert_pointer_to_real (binfo, *p);\n       if (TREE_SIDE_EFFECTS (*p))\n \t*p = save_expr (*p);"}, {"sha": "5539176a1dcd70f1e004b671af390a73981f5259", "filename": "gcc/cp/class.c", "status": "modified", "additions": 87, "deletions": 41, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ad5bdee43a9796ae1f0f324508a5bff4f7cb0/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ad5bdee43a9796ae1f0f324508a5bff4f7cb0/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=a68ad5bdee43a9796ae1f0f324508a5bff4f7cb0", "patch": "@@ -103,7 +103,7 @@ static tree dfs_get_class_offset PROTO((tree, void *));\n static tree get_class_offset PROTO((tree, tree, tree, tree));\n static void modify_one_vtable PROTO((tree, tree, tree));\n static tree dfs_modify_vtables PROTO((tree, void *));\n-static void modify_all_vtables PROTO((tree, tree));\n+static tree modify_all_vtables PROTO((tree, int *, tree));\n static void determine_primary_base PROTO((tree, int *));\n static void finish_struct_methods PROTO((tree));\n static void maybe_warn_about_overly_private_class PROTO ((tree));\n@@ -1107,7 +1107,7 @@ modify_vtable_entry (old_entry_in_list, new_offset, fndecl)\n   if (TREE_CODE (DECL_VINDEX (fndecl)) != INTEGER_CST)\n     {\n       DECL_VINDEX (fndecl) = DECL_VINDEX (base_fndecl);\n-      DECL_CONTEXT (fndecl) = DECL_CONTEXT (base_fndecl);\n+      DECL_VIRTUAL_CONTEXT (fndecl) = DECL_VIRTUAL_CONTEXT (base_fndecl);\n     }\n }\n \n@@ -1166,8 +1166,6 @@ add_virtual_function (new_virtuals_p, overridden_virtuals_p,\n      tree fndecl;\n      tree t; /* Structure type.  */\n {\n-  my_friendly_assert (DECL_CONTEXT (fndecl) == t, 20000116);\n-\n   /* If this function doesn't override anything from a base class, we\n      can just assign it a new DECL_VINDEX now.  Otherwise, if it does\n      override something, we keep it around and assign its DECL_VINDEX\n@@ -1185,25 +1183,10 @@ add_virtual_function (new_virtuals_p, overridden_virtuals_p,\n \n       start_vtable (t, has_virtual);\n \n-      /* Build a new INT_CST for this DECL_VINDEX.  */\n-      {\n-\tstatic tree index_table[256];\n-\ttree idx;\n-\t/* We skip a slot for the offset/tdesc entry.  */\n-\tint i = (*has_virtual)++;\n-\n-\tif (i >= 256 || index_table[i] == 0)\n-\t  {\n-\t    idx = build_int_2 (i, 0);\n-\t    if (i < 256)\n-\t      index_table[i] = idx;\n-\t  }\n-\telse\n-\t  idx = index_table[i];\n+      /* Now assign virtual dispatch information.  */\n+      DECL_VINDEX (fndecl) = build_shared_int_cst ((*has_virtual)++);\n+      DECL_VIRTUAL_CONTEXT (fndecl) = t;\n \n-\t/* Now assign virtual dispatch information.  */\n-\tDECL_VINDEX (fndecl) = idx;\n-      }\n       /* Save the state we've computed on the NEW_VIRTUALS list.  */\n       *new_virtuals_p = tree_cons (integer_zero_node,\n \t\t\t\t   fndecl,\n@@ -2752,17 +2735,81 @@ dfs_modify_vtables (binfo, data)\n   return NULL_TREE;\n }\n \n-static void\n-modify_all_vtables (t, fndecl)\n+/* Update all of the primary and secondary vtables for T.  Create new\n+   vtables as required, and initialize their RTTI information.  Each\n+   of the functions in OVERRIDDEN_VIRTUALS overrides a virtual\n+   function from a base class; find and modify the appropriate entries\n+   to point to the overriding functions.  Returns a list, in\n+   declaration order, of the functions that are overridden in this\n+   class, but do not appear in the primary base class vtable, and\n+   which should therefore be appended to the end of the vtable for T.  */\n+\n+static tree\n+modify_all_vtables (t, has_virtual_p, overridden_virtuals)\n      tree t;\n-     tree fndecl;\n+     int *has_virtual_p;\n+     tree overridden_virtuals;\n {\n-  tree list;\n+  tree fns;\n+  tree binfo;\n \n-  list = build_tree_list (t, fndecl);\n-  dfs_walk (TYPE_BINFO (t), dfs_modify_vtables, \n-\t    dfs_unmarked_real_bases_queue_p, list);\n-  dfs_walk (TYPE_BINFO (t), dfs_unmark, dfs_marked_real_bases_queue_p, t);\n+  binfo = TYPE_BINFO (t);\n+\n+  /* Even if there are no overridden virtuals, we want to go through\n+     the hierarchy updating RTTI information.  */\n+  if (!overridden_virtuals && TYPE_CONTAINS_VPTR_P (t) && flag_rtti)\n+    overridden_virtuals = build_tree_list (NULL_TREE, NULL_TREE);\n+\n+  /* Iterate through each of the overriding functions, updating the\n+     base vtables.  */\n+  for (fns = overridden_virtuals; fns; fns = TREE_CHAIN (fns))\n+    {\n+      tree list;\n+      list = build_tree_list (t, TREE_VALUE (fns));\n+      dfs_walk (binfo, dfs_modify_vtables, \n+\t\tdfs_unmarked_real_bases_queue_p, list);\n+      dfs_walk (binfo, dfs_unmark, dfs_marked_real_bases_queue_p, t);\n+    }\n+\n+  /* If we should include overriding functions for secondary vtables\n+     in our primary vtable, add them now.  */\n+  if (all_overridden_vfuns_in_vtables_p ())\n+    {\n+      tree *fnsp = &overridden_virtuals;\n+\n+      while (*fnsp)\n+\t{\n+\t  tree fn = TREE_VALUE (*fnsp);\n+\n+\t  if (BINFO_VIRTUALS (binfo)\n+\t      && !value_member (fn, BINFO_VIRTUALS (binfo)))\n+\t    {\n+\t      /* We know we need a vtable for this class now.  */\n+\t      start_vtable (t, has_virtual_p);\n+\t      /* Set the vtable index.  */\n+\t      DECL_VINDEX (fn) \n+\t\t= build_shared_int_cst ((*has_virtual_p)++);\n+\t      /* We don't need to convert to a base class when calling\n+\t\t this function.  */\n+\t      DECL_VIRTUAL_CONTEXT (fn) = t;\n+\t      /* We don't need to adjust the `this' pointer when\n+\t\t calling this function.  */\n+\t      TREE_PURPOSE (*fnsp) = integer_zero_node;\n+\n+\t      /* This is an overridden function not already in our\n+\t\t vtable.  Keep it.  */\n+\t      fnsp = &TREE_CHAIN (*fnsp);\n+\t    }\n+\t  else\n+\t    /* We've already got an entry for this function.  Skip\n+\t       it.  */\n+\t    *fnsp = TREE_CHAIN (*fnsp);\n+\t}\n+    }\n+  else\n+    overridden_virtuals = NULL_TREE;\n+\n+  return overridden_virtuals;\n }\n \n /* Fixup all the delta entries in this one vtable that need updating.  */\n@@ -4818,22 +4865,15 @@ finish_struct_1 (t)\n       TYPE_VFIELD (t) = vfield;\n     }\n \n-  if (flag_rtti && TYPE_CONTAINS_VPTR_P (t) && !overridden_virtuals)\n-    modify_all_vtables (t, NULL_TREE);\n+  overridden_virtuals \n+    = modify_all_vtables (t, &has_virtual, nreverse (overridden_virtuals));\n \n-  for (overridden_virtuals = nreverse (overridden_virtuals);\n-       overridden_virtuals;\n-       overridden_virtuals = TREE_CHAIN (overridden_virtuals))\n-    modify_all_vtables (t, TREE_VALUE (overridden_virtuals));\n-  \n   if (TYPE_USES_VIRTUAL_BASECLASSES (t))\n     {\n       tree vbases;\n       /* Now fixup any virtual function entries from virtual bases\n \t that have different deltas.  This has to come after we do the\n-\t pending hard virtuals, as we might have a function that comes\n-\t from multiple virtual base instances that is only overridden\n-\t by a hard virtual above.  */\n+\t overridden virtuals.  */\n       vbases = CLASSTYPE_VBASECLASSES (t);\n       while (vbases)\n \t{\n@@ -4851,6 +4891,7 @@ finish_struct_1 (t)\n \n   /* If necessary, create the vtable for this class.  */\n   if (new_virtuals\n+      || overridden_virtuals\n       || (TYPE_CONTAINS_VPTR_P (t) && vptrs_present_everywhere_p ()))\n     {\n       new_virtuals = nreverse (new_virtuals);\n@@ -4859,7 +4900,8 @@ finish_struct_1 (t)\n \t{\n \t  if (! CLASSTYPE_COM_INTERFACE (t))\n \t    {\n-\t      /* The second slot is for the tdesc pointer when thunks are used.  */\n+\t      /* The second slot is for the tdesc pointer when thunks\n+\t\t are used.  */\n \t      if (flag_vtable_thunks)\n \t\tnew_virtuals = tree_cons (NULL_TREE, NULL_TREE, new_virtuals);\n \n@@ -4918,6 +4960,10 @@ finish_struct_1 (t)\n \t followed by entries for new functions unique to this class.  */\n       TYPE_BINFO_VIRTUALS (t) \n \t= chainon (TYPE_BINFO_VIRTUALS (t), new_virtuals);\n+      /* Finally, add entries for functions that override virtuals\n+\t from non-primary bases.  */\n+      TYPE_BINFO_VIRTUALS (t) \n+\t= chainon (TYPE_BINFO_VIRTUALS (t), overridden_virtuals);\n     }\n \n   /* Now lay out the virtual function table.  */"}, {"sha": "e0e29481830d5f7cb6544d565cb9917536f21357", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ad5bdee43a9796ae1f0f324508a5bff4f7cb0/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ad5bdee43a9796ae1f0f324508a5bff4f7cb0/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a68ad5bdee43a9796ae1f0f324508a5bff4f7cb0", "patch": "@@ -4199,6 +4199,7 @@ extern tree cp_build_qualified_type_real        PROTO((tree, int, int));\n extern void remap_save_expr                     PROTO((tree *, splay_tree, tree, int *));\n #define cp_build_qualified_type(TYPE, QUALS) \\\n   cp_build_qualified_type_real ((TYPE), (QUALS), /*complain=*/1)\n+extern tree build_shared_int_cst                PROTO((int));\n \n /* in typeck.c */\n extern int string_conv_p\t\t\tPROTO((tree, tree, int));"}, {"sha": "3bf874a8351878c5c1850118102525fa26da056b", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ad5bdee43a9796ae1f0f324508a5bff4f7cb0/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ad5bdee43a9796ae1f0f324508a5bff4f7cb0/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=a68ad5bdee43a9796ae1f0f324508a5bff4f7cb0", "patch": "@@ -1,5 +1,5 @@\n /* Language-dependent node constructors for parse phase of GNU compiler.\n-   Copyright (C) 1987, 88, 92-98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 92-98, 1999, 2000 Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n@@ -1710,6 +1710,26 @@ build_min VPROTO((enum tree_code code, tree tt, ...))\n   return t;\n }\n \n+/* Returns an INTEGER_CST (of type `int') corresponding to I.\n+   Multiple calls with the same value of I may or may not yield the\n+   same node; therefore, callers should never modify the node\n+   returned.  */\n+\n+tree\n+build_shared_int_cst (i)\n+     int i;\n+{\n+  static tree cache[256];\n+\n+  if (i >= 256)\n+    return build_int_2 (i, 0);\n+  \n+  if (!cache[i])\n+    cache[i] = build_int_2 (i, 0);\n+  \n+  return cache[i];\n+}\n+\n tree\n get_type_decl (t)\n      tree t;"}]}