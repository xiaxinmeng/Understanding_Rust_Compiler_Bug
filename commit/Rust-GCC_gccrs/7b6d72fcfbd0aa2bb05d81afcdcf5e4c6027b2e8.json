{"sha": "7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2I2ZDcyZmNmYmQwYWEyYmIwNWQ4MWFmY2RjZjVlNGM2MDI3YjJlOA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-07-29T01:14:24Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-07-29T01:14:24Z"}, "message": "re PR c++/11667 (wider-than-int enums never compare equal to 0)\n\n\tPR c++/11667\n\t* c-common.c (shorten_compare): Take into account differences\n\tbetween C and C++ representation for enumeration types.\n\t* tree.h (set_min_and_max_values_for_integral_type): Declare.\n\t* stor-layout.c (set_min_and_max_values_for_integral_type): New\n\tfunction, broken out from ...\n\t(fixup_signed_type): ... here and ...\n\t(fixup_unsigned_type): ... here.\n\n\tPR c++/11667\n\t* call.c (standard_conversion): Allow all integral->enumeral\n\tconversions, after marking them as bad.\n\t* decl.c (finish_enum): Make sure that all enumerators are\n\tproperly converted to the underlying type.\n\t(build_enumerator): Set DECL_CONTEXT for namespace-scope\n\tenumeration types.\n\t* pt.c (tsubst_copy): Adjust handling of CONST_DECLs accordingly.\n\t(tsubst_enum): Tidy.\n\n\t* Make-lang.in (typeck.o): Depend on convert.h.\n\t(class.o): Likewise.\n\t(rtti.o): Likewise.\n\t* call.c: Include convert.h.\n\t(convert_arg_to_ellipsis): Use convert_to_real.\n\t* class.c: Include convert.h.\n\t(build_base_path): Use convert_to_integer.\n\t* rtti.c: Include convert.h.\n\t(build_headof): Use convert_to_integer.\n\t* typeck.c: Include convert.h.\n\t(decay_conversion): Use convert_to_integer.\n\t(build_unary_op): Use build_nop.\n\t(get_delta_difference): Use convert_to_integer.\n\t(build_ptrmemfunc): Avoid unncessary conversions.\n\nFrom-SVN: r69909", "tree": {"sha": "aa422656fa001e4c76605059943c273de869706a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa422656fa001e4c76605059943c273de869706a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8/comments", "author": null, "committer": null, "parents": [{"sha": "92a6fb2cf25c126727e85b8d90718ec4cf136cfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92a6fb2cf25c126727e85b8d90718ec4cf136cfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92a6fb2cf25c126727e85b8d90718ec4cf136cfa"}], "stats": {"total": 383, "additions": 254, "deletions": 129}, "files": [{"sha": "c3059e557af1c74d1204ed7a9b78698791fca10c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8", "patch": "@@ -1,3 +1,14 @@\n+2003-07-28  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/11667\n+\t* c-common.c (shorten_compare): Take into account differences\n+\tbetween C and C++ representation for enumeration types.\n+\t* tree.h (set_min_and_max_values_for_integral_type): Declare.\n+\t* stor-layout.c (set_min_and_max_values_for_integral_type): New\n+\tfunction, broken out from ...\n+\t(fixup_signed_type): ... here and ...\n+\t(fixup_unsigned_type): ... here.\n+\n 2003-07-28  Zack Weinberg  <zack@codesourcery.com>\n \n \t* c-decl.c: Update commentary, adjust blank lines throughout."}, {"sha": "8dea43bb028a0cc3bf81381c31bc95b04fbba270", "filename": "gcc/c-common.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8", "patch": "@@ -2214,10 +2214,12 @@ shorten_compare (tree *op0_ptr, tree *op1_ptr, tree *restype_ptr,\n       type = c_common_signed_or_unsigned_type (unsignedp0,\n \t\t\t\t\t       TREE_TYPE (primop0));\n \n-      /* If TYPE is an enumeration, then we need to get its min/max\n-\t values from it's underlying integral type, not the enumerated\n-\t type itself.  */\n-      if (TREE_CODE (type) == ENUMERAL_TYPE)\n+      /* In C, if TYPE is an enumeration, then we need to get its\n+\t min/max values from it's underlying integral type, not the\n+\t enumerated type itself.  In C++, TYPE_MAX_VALUE and\n+\t TYPE_MIN_VALUE have already been set correctly on the\n+\t enumeration type.  */\n+      if (!c_dialect_cxx() && TREE_CODE (type) == ENUMERAL_TYPE)\n \ttype = c_common_type_for_size (TYPE_PRECISION (type), unsignedp0);\n \n       maxval = TYPE_MAX_VALUE (type);"}, {"sha": "64068a2cab5ae210f242e579a0c7ff608d7c678f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8", "patch": "@@ -1,3 +1,30 @@\n+2003-07-28  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/11667\n+\t* call.c (standard_conversion): Allow all integral->enumeral\n+\tconversions, after marking them as bad.\n+\t* decl.c (finish_enum): Make sure that all enumerators are\n+\tproperly converted to the underlying type.\n+\t(build_enumerator): Set DECL_CONTEXT for namespace-scope\n+\tenumeration types.\n+\t* pt.c (tsubst_copy): Adjust handling of CONST_DECLs accordingly.\n+\t(tsubst_enum): Tidy.\n+\n+\t* Make-lang.in (typeck.o): Depend on convert.h.\n+\t(class.o): Likewise.\n+\t(rtti.o): Likewise.\n+\t* call.c: Include convert.h.\n+\t(convert_arg_to_ellipsis): Use convert_to_real.\n+\t* class.c: Include convert.h.\n+\t(build_base_path): Use convert_to_integer.\n+\t* rtti.c: Include convert.h.\n+\t(build_headof): Use convert_to_integer.\n+\t* typeck.c: Include convert.h.\n+\t(decay_conversion): Use convert_to_integer.\n+\t(build_unary_op): Use build_nop.\n+\t(get_delta_difference): Use convert_to_integer.\n+\t(build_ptrmemfunc): Avoid unncessary conversions.\n+\n Mon Jul 28 23:55:10 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* decl2.c (mark_member_pointers): Verify that member pointer points to"}, {"sha": "05a3a8c4b4429a623271699b9f35009a8d4c2d4b", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8", "patch": "@@ -244,10 +244,10 @@ cp/decl2.o: cp/decl2.c $(CXX_TREE_H) $(TM_H) flags.h cp/lex.h cp/decl.h $(EXPR_H\n cp/typeck2.o: cp/typeck2.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h output.h $(TM_P_H) \\\n    diagnostic.h\n cp/typeck.o: cp/typeck.c $(CXX_TREE_H) $(TM_H) flags.h $(RTL_H) $(EXPR_H) toplev.h \\\n-   diagnostic.h\n-cp/class.o: cp/class.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h $(RTL_H) $(TARGET_H)\n+   diagnostic.h convert.h\n+cp/class.o: cp/class.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h $(RTL_H) $(TARGET_H) convert.h\n cp/call.o: cp/call.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h $(RTL_H) $(EXPR_H) \\\n-     diagnostic.h intl.h gt-cp-call.h\n+     diagnostic.h intl.h gt-cp-call.h convert.h\n cp/friend.o: cp/friend.c $(CXX_TREE_H) $(TM_H) flags.h $(RTL_H) toplev.h $(EXPR_H)\n cp/init.o: cp/init.c $(CXX_TREE_H) $(TM_H) flags.h $(RTL_H) $(EXPR_H) toplev.h \\\n   except.h\n@@ -258,7 +258,7 @@ cp/search.o: cp/search.c $(CXX_TREE_H) $(TM_H) stack.h flags.h toplev.h $(RTL_H)\n cp/tree.o: cp/tree.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h $(RTL_H) \\\n   insn-config.h integrate.h tree-inline.h real.h gt-cp-tree.h $(TARGET_H)\n cp/ptree.o: cp/ptree.c $(CXX_TREE_H) $(TM_H)\n-cp/rtti.o: cp/rtti.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h\n+cp/rtti.o: cp/rtti.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h convert.h\n cp/except.o: cp/except.c $(CXX_TREE_H) $(TM_H) flags.h $(RTL_H) except.h toplev.h \\\n   cp/cfns.h $(EXPR_H) libfuncs.h tree-inline.h\n cp/expr.o: cp/expr.c $(CXX_TREE_H) $(TM_H) $(RTL_H) flags.h $(EXPR_H) toplev.h \\"}, {"sha": "e8b2902738780f4a565c1ce0728e9f3eede10eac", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8", "patch": "@@ -37,6 +37,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"expr.h\"\n #include \"diagnostic.h\"\n #include \"intl.h\"\n+#include \"convert.h\"\n \n static tree build_field_call (tree, tree, tree);\n static struct z_candidate * tourney (struct z_candidate *);\n@@ -653,8 +654,7 @@ standard_conversion (tree to, tree from, tree expr)\n       conv = build_conv (STD_CONV, to, conv);\n       ICS_BAD_FLAG (conv) = 1;\n     }\n-  else if (tcode == ENUMERAL_TYPE && fcode == INTEGER_TYPE\n-\t   && TYPE_PRECISION (to) == TYPE_PRECISION (from))\n+  else if (tcode == ENUMERAL_TYPE && fcode == INTEGER_TYPE)\n     {\n       /* For backwards brain damage compatibility, allow interconversion of\n \t enums and integers with a pedwarn.  */\n@@ -4201,7 +4201,7 @@ convert_arg_to_ellipsis (tree arg)\n   if (TREE_CODE (TREE_TYPE (arg)) == REAL_TYPE\n       && (TYPE_PRECISION (TREE_TYPE (arg))\n \t  < TYPE_PRECISION (double_type_node)))\n-    arg = cp_convert (double_type_node, arg);\n+    arg = convert_to_real (double_type_node, arg);\n   else if (INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (arg)))\n     arg = perform_integral_promotions (arg);\n "}, {"sha": "b447f7013ee067775604499deba53f8580d280ed", "filename": "gcc/cp/class.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8", "patch": "@@ -35,6 +35,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"lex.h\"\n #include \"target.h\"\n+#include \"convert.h\"\n \n /* The number of nested classes being processed.  If we are not in the\n    scope of any class, this is zero.  */\n@@ -328,8 +329,9 @@ build_base_path (enum tree_code code,\n       v_offset = build_indirect_ref (v_offset, NULL);\n       TREE_CONSTANT (v_offset) = 1;\n \n-      offset = cp_convert (ptrdiff_type_node,\n-\t\t\t   size_diffop (offset, BINFO_OFFSET (v_binfo)));\n+      offset = convert_to_integer (ptrdiff_type_node,\n+\t\t\t\t   size_diffop (offset, \n+\t\t\t\t\t\tBINFO_OFFSET (v_binfo)));\n \n       if (!integer_zerop (offset))\n \tv_offset = build (code, ptrdiff_type_node, v_offset, offset);"}, {"sha": "583b87417443c45b0a52e98b237254fbba320e4a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 86, "deletions": 34, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8", "patch": "@@ -13028,14 +13028,18 @@ start_enum (tree name)\n void\n finish_enum (tree enumtype)\n {\n-  tree pair;\n+  tree values;\n+  tree decl;\n+  tree value;\n   tree minnode;\n   tree maxnode;\n   tree t;\n   bool unsignedp;\n   int lowprec;\n   int highprec; \n   int precision;\n+  integer_type_kind itk;\n+  tree underlying_type;\n \n   /* We built up the VALUES in reverse order.  */\n   TYPE_VALUES (enumtype) = nreverse (TYPE_VALUES (enumtype));\n@@ -13046,28 +13050,34 @@ finish_enum (tree enumtype)\n      works.  */\n   if (processing_template_decl)\n     {\n-      for (pair = TYPE_VALUES (enumtype); pair; pair = TREE_CHAIN (pair))\n-\tTREE_TYPE (TREE_VALUE (pair)) = enumtype;\n+      for (values = TYPE_VALUES (enumtype); \n+\t   values; \n+\t   values = TREE_CHAIN (values))\n+\tTREE_TYPE (TREE_VALUE (values)) = enumtype;\n       if (at_function_scope_p ())\n \tadd_stmt (build_min (TAG_DEFN, enumtype));\n       return;\n     }\n \n+  /* Determine the minimum and maximum values of the enumerators.  */\n   if (TYPE_VALUES (enumtype))\n     {\n       minnode = maxnode = NULL_TREE;\n \n-      for (pair = TYPE_VALUES (enumtype); pair; pair = TREE_CHAIN (pair))\n+      for (values = TYPE_VALUES (enumtype); \n+\t   values; \n+\t   values = TREE_CHAIN (values))\n \t{\n-\t  tree decl = TREE_VALUE (pair);\n-\t  tree value = DECL_INITIAL (decl);\n+\t  decl = TREE_VALUE (values);\n \n \t  /* [dcl.enum]: Following the closing brace of an enum-specifier,\n \t     each enumerator has the type of its enumeration.  Prior to the\n \t     closing brace, the type of each enumerator is the type of its\n \t     initializing value.  */\n \t  TREE_TYPE (decl) = enumtype;\n \n+\t  /* Update the minimum and maximum values, if appropriate.  */\n+\t  value = DECL_INITIAL (decl);\n \t  /* Figure out what the minimum and maximum values of the\n \t     enumerators are.  */\n \t  if (!minnode)\n@@ -13086,13 +13096,13 @@ finish_enum (tree enumtype)\n \t      value = DECL_INITIAL (decl) = copy_node (value);\n \t      TREE_TYPE (value) = enumtype;\n \t    }\n-\n-\t  /* In addition, transform the TYPE_VALUES list to contain the\n-\t     values, rather than the CONST_DECLs for them.  */\n-\t  TREE_VALUE (pair) = value;\n \t}\n     }\n   else\n+    /* [dcl.enum]\n+\n+       If the enumerator-list is empty, the underlying type is as if\n+       the enumeration had a single enumerator with value 0.  */\n     minnode = maxnode = integer_zero_node;\n \n   /* Compute the number of bits require to represent all values of the\n@@ -13104,35 +13114,75 @@ finish_enum (tree enumtype)\n   highprec = min_precision (maxnode, unsignedp);\n   precision = MAX (lowprec, highprec);\n \n-  /* DR 377\n-       \n-     IF no integral type can represent all the enumerator values, the\n-     enumeration is ill-formed.  */\n-  if (precision > TYPE_PRECISION (long_long_integer_type_node))\n+  /* Determine the underlying type of the enumeration.\n+\n+       [dcl.enum]\n+\n+       The underlying type of an enumeration is an integral type that\n+       can represent all the enumerator values defined in the\n+       enumeration.  It is implementation-defined which integral type is\n+       used as the underlying type for an enumeration except that the\n+       underlying type shall not be larger than int unless the value of\n+       an enumerator cannot fit in an int or unsigned int.  \n+\n+     We use \"int\" or an \"unsigned int\" as the underlying type, even if\n+     a smaller integral type would work, unless the user has\n+     explicitly requested that we use the smallest possible type.  */\n+  for (itk = (flag_short_enums ? itk_char : itk_int); \n+       itk != itk_none; \n+       itk++)\n     {\n+      underlying_type = integer_types[itk];\n+      if (TYPE_PRECISION (underlying_type) >= precision\n+\t  && TREE_UNSIGNED (underlying_type) == unsignedp)\n+\tbreak;\n+    }\n+  if (itk == itk_none)\n+    {\n+      /* DR 377\n+\n+\t IF no integral type can represent all the enumerator values, the\n+\t enumeration is ill-formed.  */\n       error (\"no integral type can represent all of the enumerator values \"\n \t     \"for `%T'\", enumtype);\n       precision = TYPE_PRECISION (long_long_integer_type_node);\n+      underlying_type = integer_types[itk_unsigned_long_long];\n     }\n \n-  /* Compute the minium and maximum values for the type, the size of\n-     the type, and so forth.  */\n-  TYPE_PRECISION (enumtype) = precision;\n-  TYPE_SIZE (enumtype) = NULL_TREE;\n-  if (unsignedp)\n-    fixup_unsigned_type (enumtype);\n-  else\n-    fixup_signed_type (enumtype);\n+  /* Compute the minium and maximum values for the type.  \n \n-  /* We use \"int\" or \"unsigned int\" as the underlying type, unless all\n-     the values will not fit or the user has requested that we try to\n-     use shorter types where possible.  */\n-  if (precision < TYPE_PRECISION (integer_type_node)\n-      && !flag_short_enums)\n-    {\n-      TYPE_PRECISION (enumtype) = TYPE_PRECISION (integer_type_node);\n-      TYPE_SIZE (enumtype) = NULL_TREE;\n-      layout_type (enumtype);\n+     [dcl.enum]\n+\n+     For an enumeration where emin is the smallest enumerator and emax\n+     is the largest, the values of the enumeration are the values of the\n+     underlying type in the range bmin to bmax, where bmin and bmax are,\n+     respectively, the smallest and largest values of the smallest bit-\n+     field that can store emin and emax.  */\n+  TYPE_PRECISION (enumtype) = precision;\n+  set_min_and_max_values_for_integral_type (enumtype, precision, unsignedp);\n+\n+  /* [dcl.enum]\n+     \n+     The value of sizeof() applied to an enumeration type, an object\n+     of an enumeration type, or an enumerator, is the value of sizeof()\n+     applied to the underlying type.  */\n+  TYPE_SIZE (enumtype) = TYPE_SIZE (underlying_type);\n+  TYPE_SIZE_UNIT (enumtype) = TYPE_SIZE_UNIT (underlying_type);\n+  TYPE_MODE (enumtype) = TYPE_MODE (underlying_type);\n+  TYPE_ALIGN (enumtype) = TYPE_ALIGN (underlying_type);\n+  TYPE_USER_ALIGN (enumtype) = TYPE_USER_ALIGN (underlying_type);\n+  TREE_UNSIGNED (enumtype) = TREE_UNSIGNED (underlying_type);\n+\n+  /* Convert each of the enumerators to the type of the underlying\n+     type of the enumeration.  */\n+  for (values = TYPE_VALUES (enumtype); values; values = TREE_CHAIN (values))\n+    {\n+      decl = TREE_VALUE (values);\n+      value = perform_implicit_conversion (underlying_type,\n+\t\t\t\t\t   DECL_INITIAL (decl));\n+      TREE_TYPE (value) = enumtype;\n+      DECL_INITIAL (decl) = value;\n+      TREE_VALUE (values) = value;\n     }\n \n   /* Fix up all variant types of this enum type.  */\n@@ -13215,6 +13265,8 @@ build_enumerator (tree name, tree value, tree enumtype)\n \n   /* C++ associates enums with global, function, or class declarations.  */\n   context = current_scope ();\n+  if (!context)\n+    context = current_namespace;\n \n   /* Build the actual enumeration constant.  Note that the enumeration\n     constants have the type of their initializers until the\n@@ -13246,8 +13298,8 @@ build_enumerator (tree name, tree value, tree enumtype)\n \n   if (context && context == current_class_type)\n     /* In something like `struct S { enum E { i = 7 }; };' we put `i'\n-      on the TYPE_FIELDS list for `S'.  (That's so that you can say\n-      things like `S::i' later.)  */\n+       on the TYPE_FIELDS list for `S'.  (That's so that you can say\n+       things like `S::i' later.)  */\n     finish_member_declaration (decl);\n   else\n     pushdecl (decl);"}, {"sha": "8f10de49065d5775737794714509c205fb5dc9a9", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8", "patch": "@@ -7214,8 +7214,9 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \n \tif (DECL_TEMPLATE_PARM_P (t))\n \t  return tsubst_copy (DECL_INITIAL (t), args, complain, in_decl);\n-\tif (!DECL_CONTEXT (t))\n-\t  /* This is a global enumeration constant.  */\n+\t/* There is no need to substitute into namespace-scope\n+\t   enumerators.  */\n+\tif (DECL_NAMESPACE_SCOPE_P (t))\n \t  return t;\n \n \t/* Unfortunately, we cannot just call lookup_name here.\n@@ -11151,18 +11152,20 @@ tsubst_enum (tree tag, tree newtag, tree args)\n   for (e = TYPE_VALUES (tag); e; e = TREE_CHAIN (e))\n     {\n       tree value;\n-      \n+      tree decl;\n+\n+      decl = TREE_VALUE (e);\n       /* Note that in a template enum, the TREE_VALUE is the\n \t CONST_DECL, not the corresponding INTEGER_CST.  */\n-      value = tsubst_expr (DECL_INITIAL (TREE_VALUE (e)), \n+      value = tsubst_expr (DECL_INITIAL (decl), \n \t\t\t   args, tf_error | tf_warning,\n \t\t\t   NULL_TREE);\n \n       /* Give this enumeration constant the correct access.  */\n-      set_current_access_from_decl (TREE_VALUE (e));\n+      set_current_access_from_decl (decl);\n \n       /* Actually build the enumerator itself.  */\n-      build_enumerator (TREE_PURPOSE (e), value, newtag); \n+      build_enumerator (DECL_NAME (decl), value, newtag); \n     }\n \n   finish_enum (newtag);"}, {"sha": "baaff74d68b11df5f9844fcfc1b243d9fe59371f", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8", "patch": "@@ -31,6 +31,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"assert.h\"\n #include \"toplev.h\"\n+#include \"convert.h\"\n \n /* C++ returns type information to the user in struct type_info\n    objects. We also use type information to implement dynamic_cast and\n@@ -159,8 +160,8 @@ build_headof (tree exp)\n \n   type = build_qualified_type (ptr_type_node, \n \t\t\t       cp_type_quals (TREE_TYPE (exp)));\n-  return build (PLUS_EXPR, type, exp,\n-\t\tcp_convert (ptrdiff_type_node, offset));\n+  return build (PLUS_EXPR, type, exp, \n+\t\tconvert_to_integer (ptrdiff_type_node, offset));\n }\n \n /* Get a bad_cast node for the program to throw..."}, {"sha": "00fa013b69a0e34d6a3f8ceddcc69dd655e6d7fc", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 28, "deletions": 46, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8", "patch": "@@ -44,6 +44,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"diagnostic.h\"\n #include \"target.h\"\n+#include \"convert.h\"\n \n static tree convert_for_assignment (tree, tree, const char *, tree, int);\n static tree cp_pointer_int_sum (enum tree_code, tree, tree);\n@@ -1291,20 +1292,8 @@ decay_conversion (tree exp)\n       tree ptrtype;\n \n       if (TREE_CODE (exp) == INDIRECT_REF)\n-\t{\n-\t  /* Stripping away the INDIRECT_REF is not the right\n-\t     thing to do for references...  */\n-\t  tree inner = TREE_OPERAND (exp, 0);\n-\t  if (TREE_CODE (TREE_TYPE (inner)) == REFERENCE_TYPE)\n-\t    {\n-\t      inner = build1 (CONVERT_EXPR,\n-\t\t\t      build_pointer_type (TREE_TYPE\n-\t\t\t\t\t\t  (TREE_TYPE (inner))),\n-\t\t\t      inner);\n-\t      TREE_CONSTANT (inner) = TREE_CONSTANT (TREE_OPERAND (inner, 0));\n-\t    }\n-\t  return cp_convert (build_pointer_type (TREE_TYPE (type)), inner);\n-\t}\n+\treturn build_nop (build_pointer_type (TREE_TYPE (type)), \n+\t\t\t  TREE_OPERAND (exp, 0));\n \n       if (TREE_CODE (exp) == COMPOUND_EXPR)\n \t{\n@@ -4007,8 +3996,7 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t\t\t\t      ba_check, NULL);\n \t    \n \t    rval = build_base_path (PLUS_EXPR, rval, binfo, 1);\n-\t    rval = build1 (NOP_EXPR, argtype, rval);\n-\t    TREE_CONSTANT (rval) = TREE_CONSTANT (TREE_OPERAND (rval, 0));\n+\t    rval = build_nop (argtype, rval);\n \t    addr = fold (build (PLUS_EXPR, argtype, rval,\n \t\t\t\tcp_convert (argtype, byte_position (field))));\n \t  }\n@@ -5192,8 +5180,9 @@ build_x_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \n \f\n /* Get difference in deltas for different pointer to member function\n-   types.  Return integer_zero_node, if FROM cannot be converted to a\n-   TO type.  If FORCE is true, then allow reverse conversions as well.\n+   types.  Returns an integer constant of type PTRDIFF_TYPE_NODE.  If\n+   the conversion is invalid, the constant is zero.  If FORCE is true,\n+   then allow reverse conversions as well.\n \n    Note that the naming of FROM and TO is kind of backwards; the return\n    value is what we add to a TO in order to get a FROM.  They are named\n@@ -5203,7 +5192,6 @@ build_x_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n static tree\n get_delta_difference (tree from, tree to, int force)\n {\n-  tree delta = integer_zero_node;\n   tree binfo;\n   tree virt_binfo;\n   base_kind kind;\n@@ -5212,52 +5200,46 @@ get_delta_difference (tree from, tree to, int force)\n   if (kind == bk_inaccessible || kind == bk_ambig)\n     {\n       error (\"   in pointer to member function conversion\");\n-      return delta;\n+      goto error;\n     }\n   if (!binfo)\n     {\n       if (!force)\n \t{\n \t  error_not_base_type (from, to);\n \t  error (\"   in pointer to member conversion\");\n-\t  return delta;\n+\t  goto error;\n \t}\n       binfo = lookup_base (from, to, ba_check, &kind);\n-      if (binfo == 0)\n-\treturn delta;\n+      if (!binfo)\n+\tgoto error;\n       virt_binfo = binfo_from_vbase (binfo);\n-      \n       if (virt_binfo)\n         {\n           /* This is a reinterpret cast, we choose to do nothing.  */\n           warning (\"pointer to member cast via virtual base `%T'\",\n \t\t   BINFO_TYPE (virt_binfo));\n-          return delta;\n+\t  goto error;\n         }\n-      delta = BINFO_OFFSET (binfo);\n-      delta = cp_convert (ptrdiff_type_node, delta);\n-      delta = cp_build_binary_op (MINUS_EXPR,\n-\t\t\t\t integer_zero_node,\n-\t\t\t\t delta);\n-\n-      return delta;\n+      return convert_to_integer (ptrdiff_type_node, \n+\t\t\t\t size_diffop (size_zero_node,\n+\t\t\t\t\t      BINFO_OFFSET (binfo)));\n     }\n \n   virt_binfo = binfo_from_vbase (binfo);\n-  if (virt_binfo)\n-    {\n-      /* This is a reinterpret cast, we choose to do nothing.  */\n-      if (force)\n-        warning (\"pointer to member cast via virtual base `%T'\",\n-\t\t BINFO_TYPE (virt_binfo));\n-      else\n-\terror (\"pointer to member conversion via virtual base `%T'\",\n-\t       BINFO_TYPE (virt_binfo));\n-      return delta;\n-    }\n-  delta = BINFO_OFFSET (binfo);\n+  if (!virt_binfo)\n+    return convert_to_integer (ptrdiff_type_node, BINFO_OFFSET (binfo));\n+\n+  /* This is a reinterpret cast, we choose to do nothing.  */\n+  if (force)\n+    warning (\"pointer to member cast via virtual base `%T'\",\n+\t     BINFO_TYPE (virt_binfo));\n+  else\n+    error (\"pointer to member conversion via virtual base `%T'\",\n+\t   BINFO_TYPE (virt_binfo));\n \n-  return cp_convert (ptrdiff_type_node, delta);\n+ error:\n+  return convert_to_integer(ptrdiff_type_node, integer_zero_node);\n }\n \n /* Return a constructor for the pointer-to-member-function TYPE using\n@@ -5355,7 +5337,7 @@ build_ptrmemfunc (tree type, tree pfn, int force)\n \t}\n \n       /* Just adjust the DELTA field.  */\n-      delta = cp_convert (ptrdiff_type_node, delta);\n+      my_friendly_assert (TREE_TYPE (delta) == ptrdiff_type_node, 20030727);\n       if (TARGET_PTRMEMFUNC_VBIT_LOCATION == ptrmemfunc_vbit_in_delta)\n \tn = cp_build_binary_op (LSHIFT_EXPR, n, integer_one_node);\n       delta = cp_build_binary_op (PLUS_EXPR, delta, n);"}, {"sha": "54e6a56de9904c3bae5643b89d5eb6621173c7a7", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 56, "deletions": 28, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8", "patch": "@@ -1957,6 +1957,58 @@ set_sizetype (tree type)\n   sizetype_set = 1;\n }\n \f\n+/* TYPE is an integral type, i.e., an INTEGRAL_TYPE, ENUMERAL_TYPE,\n+   BOOLEAN_TYPE, or CHAR_TYPE.  Set TYPE_MIN_VALUE and TYPE_MAX_VALUE\n+   for TYPE, based on the PRECISION and whether or not the TYPE\n+   IS_UNSIGNED.  PRECISION need not correspond to a width supported\n+   natively by the hardware; for example, on a machine with 8-bit,\n+   16-bit, and 32-bit register modes, PRECISION might be 7, 23, or\n+   61.  */\n+\n+void\n+set_min_and_max_values_for_integral_type (tree type,\n+\t\t\t\t\t  int precision,\n+\t\t\t\t\t  bool is_unsigned)\n+{\n+  tree min_value;\n+  tree max_value;\n+\n+  if (is_unsigned)\n+    {\n+      min_value = build_int_2 (0, 0);\n+      max_value \n+\t= build_int_2 (precision - HOST_BITS_PER_WIDE_INT >= 0\n+\t\t       ? -1 : ((HOST_WIDE_INT) 1 << precision) - 1,\n+\t\t       precision - HOST_BITS_PER_WIDE_INT > 0\n+\t\t       ? ((unsigned HOST_WIDE_INT) ~0\n+\t\t\t  >> (HOST_BITS_PER_WIDE_INT\n+\t\t\t      - (precision - HOST_BITS_PER_WIDE_INT)))\n+\t\t       : 0);\n+    }\n+  else\n+    {\n+      min_value \n+\t= build_int_2 ((precision - HOST_BITS_PER_WIDE_INT > 0\n+\t\t\t? 0 : (HOST_WIDE_INT) (-1) << (precision - 1)),\n+\t\t       (((HOST_WIDE_INT) (-1)\n+\t\t\t << (precision - HOST_BITS_PER_WIDE_INT - 1 > 0\n+\t\t\t     ? precision - HOST_BITS_PER_WIDE_INT - 1\n+\t\t\t     : 0))));    \n+      max_value\n+\t= build_int_2 ((precision - HOST_BITS_PER_WIDE_INT > 0\n+\t\t\t? -1 : ((HOST_WIDE_INT) 1 << (precision - 1)) - 1),\n+\t\t       (precision - HOST_BITS_PER_WIDE_INT - 1 > 0\n+\t\t\t? (((HOST_WIDE_INT) 1\n+\t\t\t    << (precision - HOST_BITS_PER_WIDE_INT - 1))) - 1\n+\t\t\t: 0));\n+    }\n+\n+  TREE_TYPE (min_value) = type;\n+  TREE_TYPE (max_value) = type;\n+  TYPE_MIN_VALUE (type) = min_value;\n+  TYPE_MAX_VALUE (type) = max_value;\n+}\n+\n /* Set the extreme values of TYPE based on its precision in bits,\n    then lay it out.  Used when make_signed_type won't do\n    because the tree code is not INTEGER_TYPE.\n@@ -1973,23 +2025,8 @@ fixup_signed_type (tree type)\n   if (precision > HOST_BITS_PER_WIDE_INT * 2)\n     precision = HOST_BITS_PER_WIDE_INT * 2;\n \n-  TYPE_MIN_VALUE (type)\n-    = build_int_2 ((precision - HOST_BITS_PER_WIDE_INT > 0\n-\t\t    ? 0 : (HOST_WIDE_INT) (-1) << (precision - 1)),\n-\t\t   (((HOST_WIDE_INT) (-1)\n-\t\t     << (precision - HOST_BITS_PER_WIDE_INT - 1 > 0\n-\t\t\t ? precision - HOST_BITS_PER_WIDE_INT - 1\n-\t\t\t : 0))));\n-  TYPE_MAX_VALUE (type)\n-    = build_int_2 ((precision - HOST_BITS_PER_WIDE_INT > 0\n-\t\t    ? -1 : ((HOST_WIDE_INT) 1 << (precision - 1)) - 1),\n-\t\t   (precision - HOST_BITS_PER_WIDE_INT - 1 > 0\n-\t\t    ? (((HOST_WIDE_INT) 1\n-\t\t\t<< (precision - HOST_BITS_PER_WIDE_INT - 1))) - 1\n-\t\t    : 0));\n-\n-  TREE_TYPE (TYPE_MIN_VALUE (type)) = type;\n-  TREE_TYPE (TYPE_MAX_VALUE (type)) = type;\n+  set_min_and_max_values_for_integral_type (type, precision, \n+\t\t\t\t\t    /*is_unsigned=*/false);\n \n   /* Lay out the type: set its alignment, size, etc.  */\n   layout_type (type);\n@@ -2010,17 +2047,8 @@ fixup_unsigned_type (tree type)\n   if (precision > HOST_BITS_PER_WIDE_INT * 2)\n     precision = HOST_BITS_PER_WIDE_INT * 2;\n \n-  TYPE_MIN_VALUE (type) = build_int_2 (0, 0);\n-  TYPE_MAX_VALUE (type)\n-    = build_int_2 (precision - HOST_BITS_PER_WIDE_INT >= 0\n-\t\t   ? -1 : ((HOST_WIDE_INT) 1 << precision) - 1,\n-\t\t   precision - HOST_BITS_PER_WIDE_INT > 0\n-\t\t   ? ((unsigned HOST_WIDE_INT) ~0\n-\t\t      >> (HOST_BITS_PER_WIDE_INT\n-\t\t\t  - (precision - HOST_BITS_PER_WIDE_INT)))\n-\t\t   : 0);\n-  TREE_TYPE (TYPE_MIN_VALUE (type)) = type;\n-  TREE_TYPE (TYPE_MAX_VALUE (type)) = type;\n+  set_min_and_max_values_for_integral_type (type, precision, \n+\t\t\t\t\t    /*is_unsigned=*/true);\n \n   /* Lay out the type: set its alignment, size, etc.  */\n   layout_type (type);"}, {"sha": "f0171688fcbc55b358e7edd7df790b33185744bc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8", "patch": "@@ -1,3 +1,9 @@\n+2003-07-28  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR c++/11667\n+\t* g++.dg/init/enum2.C: New test.\n+\t* g++.dg/template/overload1.C: Add \"-w\" option.\n+\t\n 2003-07-28    <hp@bitrange.com>\n \n \t* gcc.dg/Wdeclaration-after-statement-1.c,"}, {"sha": "dea7dc17be053aaab7008621d2cab40609bfe523", "filename": "gcc/testsuite/g++.dg/init/enum2.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fenum2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fenum2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fenum2.C?ref=7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8", "patch": "@@ -0,0 +1,9 @@\n+#include <limits.h>\n+enum test {\n+  z = 0,\n+  c = UINT_MAX + 1LL\n+} x = z;\n+\n+int main() {\n+  return x != z;\n+}"}, {"sha": "2225fecf730284e8e81e660ace8671f1897ccb4b", "filename": "gcc/testsuite/g++.dg/template/overload1.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Foverload1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Foverload1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Foverload1.C?ref=7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8", "patch": "@@ -1,3 +1,4 @@\n+// { dg-options \"-w\" }\n // PR c++/9420\n // Bug: We were instantiating B<int> during overload resolution for E<0.\n // This is wrong; the contents of B<int> are not relevant, since we can't"}, {"sha": "e44af15a877e371bf3cd94aa27c2d3d84b4f7f96", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8", "patch": "@@ -2909,6 +2909,7 @@ extern void output_inline_function (tree);\n extern void set_decl_origin_self (tree);\n \n /* In stor-layout.c */\n+extern void set_min_and_max_values_for_integral_type (tree, int, bool);\n extern void fixup_signed_type (tree);\n extern void internal_reference_types (void);\n "}]}