{"sha": "c8a0c6eb4b9ea3779f01418cfc97a6761ca4a957", "node_id": "C_kwDOANBUbNoAKGM4YTBjNmViNGI5ZWEzNzc5ZjAxNDE4Y2ZjOTdhNjc2MWNhNGE5NTc", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-01-24T18:38:58Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-01-24T18:42:24Z"}, "message": "Remove hack to handle forward declared items\n\nWe used to use a compile_fns flag as a method to handle the case of code\nsuch as:\n\n```rust\nfn foo() {\n  bar()\n}\n\nfn bar() { }\n```\n\nThe compile_fns flag when set to false would allow us to do a toplevel\nscan to compile the initial fndecl prototype of the functions as a method\nof handling the case of the call to bar() within the body of foo.\n\nThe backend is setup now that we can 'query_compile' by compiling the\nitem as required with a cache if we have already done so.", "tree": {"sha": "5c10c91f085cbe16316fd5dff0a611bbd40a0610", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c10c91f085cbe16316fd5dff0a611bbd40a0610"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c8a0c6eb4b9ea3779f01418cfc97a6761ca4a957", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8a0c6eb4b9ea3779f01418cfc97a6761ca4a957", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8a0c6eb4b9ea3779f01418cfc97a6761ca4a957", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8a0c6eb4b9ea3779f01418cfc97a6761ca4a957/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3de87e620f8714278c273ec91dc6ec22347c188c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3de87e620f8714278c273ec91dc6ec22347c188c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3de87e620f8714278c273ec91dc6ec22347c188c"}], "stats": {"total": 321, "additions": 163, "deletions": 158}, "files": [{"sha": "1048027dc9fd2c7450e6fc5a059550410d2cc949", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 126, "deletions": 9, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a0c6eb4b9ea3779f01418cfc97a6761ca4a957/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a0c6eb4b9ea3779f01418cfc97a6761ca4a957/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=c8a0c6eb4b9ea3779f01418cfc97a6761ca4a957", "patch": "@@ -720,10 +720,9 @@ CompileExpr::resolve_method_address (TyTy::FnType *fntype, HirId ref,\n   if (resolved_item != nullptr)\n     {\n       if (!fntype->has_subsititions_defined ())\n-\treturn CompileInherentImplItem::Compile (resolved_item, ctx, true);\n+\treturn CompileInherentImplItem::Compile (resolved_item, ctx);\n \n-      return CompileInherentImplItem::Compile (resolved_item, ctx, true,\n-\t\t\t\t\t       fntype);\n+      return CompileInherentImplItem::Compile (resolved_item, ctx, fntype);\n     }\n \n   // it might be resolved to a trait item\n@@ -778,9 +777,9 @@ CompileExpr::resolve_method_address (TyTy::FnType *fntype, HirId ref,\n \n       HIR::ImplItem *impl_item = candidate.item.impl.impl_item;\n       if (!fntype->has_subsititions_defined ())\n-\treturn CompileInherentImplItem::Compile (impl_item, ctx, true);\n+\treturn CompileInherentImplItem::Compile (impl_item, ctx);\n \n-      return CompileInherentImplItem::Compile (impl_item, ctx, true, fntype);\n+      return CompileInherentImplItem::Compile (impl_item, ctx, fntype);\n     }\n }\n \n@@ -1226,11 +1225,11 @@ HIRCompileBase::resolve_deref_adjustment (Resolver::Adjustment &adjustment,\n \n   tree fn_address = error_mark_node;\n   if (!lookup->has_subsititions_defined ())\n-    fn_address = CompileInherentImplItem::Compile (resolved_item, ctx, true,\n-\t\t\t\t\t\t   nullptr, true, locus);\n+    fn_address = CompileInherentImplItem::Compile (resolved_item, ctx, nullptr,\n+\t\t\t\t\t\t   true, locus);\n   else\n-    fn_address = CompileInherentImplItem::Compile (resolved_item, ctx, true,\n-\t\t\t\t\t\t   lookup, true, locus);\n+    fn_address = CompileInherentImplItem::Compile (resolved_item, ctx, lookup,\n+\t\t\t\t\t\t   true, locus);\n \n   // does it need a reference to call\n   tree adjusted_argument = expression;\n@@ -1255,5 +1254,123 @@ HIRCompileBase::resolve_deref_adjustment (Resolver::Adjustment &adjustment,\n \t\t\t\t\t\t   locus);\n }\n \n+void\n+CompileExpr::visit (HIR::IdentifierExpr &expr)\n+{\n+  NodeId ast_node_id = expr.get_mappings ().get_nodeid ();\n+\n+  bool is_value = false;\n+  NodeId ref_node_id = UNKNOWN_NODEID;\n+  if (ctx->get_resolver ()->lookup_resolved_name (ast_node_id, &ref_node_id))\n+    {\n+      // these ref_node_ids will resolve to a pattern declaration but we are\n+      // interested in the definition that this refers to get the parent id\n+      Resolver::Definition def;\n+      if (!ctx->get_resolver ()->lookup_definition (ref_node_id, &def))\n+\t{\n+\t  rust_error_at (expr.get_locus (),\n+\t\t\t \"unknown reference for resolved name\");\n+\t  return;\n+\t}\n+      ref_node_id = def.parent;\n+      is_value = true;\n+    }\n+  else if (!ctx->get_resolver ()->lookup_resolved_type (ast_node_id,\n+\t\t\t\t\t\t\t&ref_node_id))\n+    {\n+      rust_error_at (expr.get_locus (),\n+\t\t     \"Failed to lookup type reference for node: %s\",\n+\t\t     expr.as_string ().c_str ());\n+      return;\n+    }\n+\n+  if (ref_node_id == UNKNOWN_NODEID)\n+    {\n+      rust_fatal_error (expr.get_locus (), \"unresolved IdentifierExpr: %s\",\n+\t\t\texpr.as_string ().c_str ());\n+      return;\n+    }\n+\n+  // node back to HIR\n+  HirId ref;\n+  if (!ctx->get_mappings ()->lookup_node_to_hir (\n+\texpr.get_mappings ().get_crate_num (), ref_node_id, &ref))\n+    {\n+      rust_error_at (expr.get_locus (), \"reverse lookup failure\");\n+      return;\n+    }\n+\n+  TyTy::BaseType *lookup = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (ref, &lookup))\n+    {\n+      rust_fatal_error (expr.get_locus (),\n+\t\t\t\"failed to find type relevant to this context: %s\",\n+\t\t\texpr.get_mappings ().as_string ().c_str ());\n+      return;\n+    }\n+\n+  bool is_type_ref = !is_value;\n+  if (is_type_ref)\n+    {\n+      // this might be a case for\n+      //\n+      // struct S;\n+      //\n+      // fn main() {\n+      //    let s = S;\n+      // }\n+\n+      if (lookup->is_unit ())\n+\t{\n+\t  translated = ctx->get_backend ()->unit_expression ();\n+\t  return;\n+\t}\n+\n+      // rust actually treats like this an fn call or structs with fields but\n+      // unit structs are just the struct name lets catch it with an is-unit\n+      // check\n+      gcc_unreachable ();\n+    }\n+\n+  tree fn = NULL_TREE;\n+  Bvariable *var = nullptr;\n+  if (ctx->lookup_const_decl (ref, &translated))\n+    {\n+      return;\n+    }\n+  else if (ctx->lookup_function_decl (ref, &fn))\n+    {\n+      translated\n+\t= ctx->get_backend ()->function_code_expression (fn, expr.get_locus ());\n+    }\n+  else if (ctx->lookup_var_decl (ref, &var))\n+    {\n+      translated = ctx->get_backend ()->var_expression (var, expr.get_locus ());\n+    }\n+  else if (ctx->lookup_pattern_binding (ref, &translated))\n+    {\n+      return;\n+    }\n+  else\n+    {\n+      // lets try and query compile it to an item/impl item\n+      HIR::Item *resolved_item = ctx->get_mappings ()->lookup_hir_item (\n+\texpr.get_mappings ().get_crate_num (), ref);\n+      bool is_hir_item = resolved_item != nullptr;\n+      if (!is_hir_item)\n+\t{\n+\t  translated = error_mark_node;\n+\t  return;\n+\t}\n+\n+      if (!lookup->has_subsititions_defined ())\n+\ttranslated = CompileItem::compile (resolved_item, ctx, nullptr, true,\n+\t\t\t\t\t   expr.get_locus ());\n+      else\n+\ttranslated = CompileItem::compile (resolved_item, ctx, lookup, true,\n+\t\t\t\t\t   expr.get_locus ());\n+    }\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "4cc4dfc1197abf0858814a59b4068666aeaa63b9", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 1, "deletions": 104, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a0c6eb4b9ea3779f01418cfc97a6761ca4a957/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a0c6eb4b9ea3779f01418cfc97a6761ca4a957/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=c8a0c6eb4b9ea3779f01418cfc97a6761ca4a957", "patch": "@@ -127,110 +127,7 @@ class CompileExpr : public HIRCompileBase\n \n   void visit (HIR::MethodCallExpr &expr) override;\n \n-  void visit (HIR::IdentifierExpr &expr) override\n-  {\n-    NodeId ast_node_id = expr.get_mappings ().get_nodeid ();\n-\n-    bool is_value = false;\n-    NodeId ref_node_id = UNKNOWN_NODEID;\n-    if (ctx->get_resolver ()->lookup_resolved_name (ast_node_id, &ref_node_id))\n-      {\n-\t// these ref_node_ids will resolve to a pattern declaration but we are\n-\t// interested in the definition that this refers to get the parent id\n-\tResolver::Definition def;\n-\tif (!ctx->get_resolver ()->lookup_definition (ref_node_id, &def))\n-\t  {\n-\t    rust_error_at (expr.get_locus (),\n-\t\t\t   \"unknown reference for resolved name\");\n-\t    return;\n-\t  }\n-\tref_node_id = def.parent;\n-\tis_value = true;\n-      }\n-    else if (!ctx->get_resolver ()->lookup_resolved_type (ast_node_id,\n-\t\t\t\t\t\t\t  &ref_node_id))\n-      {\n-\trust_error_at (expr.get_locus (),\n-\t\t       \"Failed to lookup type reference for node: %s\",\n-\t\t       expr.as_string ().c_str ());\n-\treturn;\n-      }\n-\n-    if (ref_node_id == UNKNOWN_NODEID)\n-      {\n-\trust_fatal_error (expr.get_locus (), \"unresolved IdentifierExpr: %s\",\n-\t\t\t  expr.as_string ().c_str ());\n-\treturn;\n-      }\n-\n-    // node back to HIR\n-    HirId ref;\n-    if (!ctx->get_mappings ()->lookup_node_to_hir (\n-\t  expr.get_mappings ().get_crate_num (), ref_node_id, &ref))\n-      {\n-\trust_error_at (expr.get_locus (), \"reverse lookup failure\");\n-\treturn;\n-      }\n-\n-    TyTy::BaseType *lookup = nullptr;\n-    if (!ctx->get_tyctx ()->lookup_type (ref, &lookup))\n-      {\n-\trust_fatal_error (expr.get_locus (),\n-\t\t\t  \"failed to find type relevant to this context: %s\",\n-\t\t\t  expr.get_mappings ().as_string ().c_str ());\n-\treturn;\n-      }\n-\n-    bool is_type_ref = !is_value;\n-    if (is_type_ref)\n-      {\n-\t// this might be a case for\n-\t//\n-\t// struct S;\n-\t//\n-\t// fn main() {\n-\t//    let s = S;\n-\t// }\n-\n-\tif (lookup->is_unit ())\n-\t  {\n-\t    translated = ctx->get_backend ()->unit_expression ();\n-\t    return;\n-\t  }\n-\n-\t// rust actually treats like this an fn call or structs with fields but\n-\t// unit structs are just the struct name lets catch it with an is-unit\n-\t// check\n-\tgcc_unreachable ();\n-      }\n-\n-    tree fn = NULL_TREE;\n-    Bvariable *var = nullptr;\n-    if (ctx->lookup_const_decl (ref, &translated))\n-      {\n-\treturn;\n-      }\n-    else if (ctx->lookup_function_decl (ref, &fn))\n-      {\n-\ttranslated\n-\t  = ctx->get_backend ()->function_code_expression (fn,\n-\t\t\t\t\t\t\t   expr.get_locus ());\n-      }\n-    else if (ctx->lookup_var_decl (ref, &var))\n-      {\n-\ttranslated\n-\t  = ctx->get_backend ()->var_expression (var, expr.get_locus ());\n-      }\n-    else if (ctx->lookup_pattern_binding (ref, &translated))\n-      {\n-\treturn;\n-      }\n-    else\n-      {\n-\trust_fatal_error (expr.get_locus (),\n-\t\t\t  \"failed to lookup compiled reference\");\n-      }\n-  }\n+  void visit (HIR::IdentifierExpr &expr) override;\n \n   void visit (HIR::LiteralExpr &expr) override\n   {"}, {"sha": "507865a85bda8a1d5370ea62f93976daf92a5447", "filename": "gcc/rust/backend/rust-compile-extern.h", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a0c6eb4b9ea3779f01418cfc97a6761ca4a957/gcc%2Frust%2Fbackend%2Frust-compile-extern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a0c6eb4b9ea3779f01418cfc97a6761ca4a957/gcc%2Frust%2Fbackend%2Frust-compile-extern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-extern.h?ref=c8a0c6eb4b9ea3779f01418cfc97a6761ca4a957", "patch": "@@ -37,10 +37,9 @@ class CompileExternItem : public HIRCompileBase\n \n public:\n   static void compile (HIR::ExternalItem *item, Context *ctx,\n-\t\t       bool compile_fns = true,\n \t\t       TyTy::BaseType *concrete = nullptr)\n   {\n-    CompileExternItem compiler (ctx, compile_fns, concrete);\n+    CompileExternItem compiler (ctx, concrete);\n     item->accept_vis (compiler);\n   }\n \n@@ -70,9 +69,6 @@ class CompileExternItem : public HIRCompileBase\n \n   void visit (HIR::ExternalFunctionItem &function) override\n   {\n-    if (!compile_fns)\n-      return;\n-\n     TyTy::BaseType *fntype_tyty;\n     if (!ctx->get_tyctx ()->lookup_type (function.get_mappings ().get_hirid (),\n \t\t\t\t\t &fntype_tyty))\n@@ -146,11 +142,10 @@ class CompileExternItem : public HIRCompileBase\n   }\n \n private:\n-  CompileExternItem (Context *ctx, bool compile_fns, TyTy::BaseType *concrete)\n-    : HIRCompileBase (ctx), compile_fns (compile_fns), concrete (concrete)\n+  CompileExternItem (Context *ctx, TyTy::BaseType *concrete)\n+    : HIRCompileBase (ctx), concrete (concrete)\n   {}\n \n-  bool compile_fns;\n   TyTy::BaseType *concrete;\n };\n "}, {"sha": "d646c8391f6cbeffafea90d4f72c99f76c38dd66", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a0c6eb4b9ea3779f01418cfc97a6761ca4a957/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a0c6eb4b9ea3779f01418cfc97a6761ca4a957/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=c8a0c6eb4b9ea3779f01418cfc97a6761ca4a957", "patch": "@@ -34,12 +34,12 @@ class CompileInherentImplItem : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static tree Compile (HIR::ImplItem *item, Context *ctx, bool compile_fns,\n+  static tree Compile (HIR::ImplItem *item, Context *ctx,\n \t\t       TyTy::BaseType *concrete = nullptr,\n \t\t       bool is_query_mode = false,\n \t\t       Location ref_locus = Location ())\n   {\n-    CompileInherentImplItem compiler (ctx, compile_fns, concrete, ref_locus);\n+    CompileInherentImplItem compiler (ctx, concrete, ref_locus);\n     item->accept_vis (compiler);\n \n     if (is_query_mode\n@@ -79,9 +79,6 @@ class CompileInherentImplItem : public HIRCompileBase\n \n   void visit (HIR::Function &function) override\n   {\n-    if (!compile_fns)\n-      return;\n-\n     TyTy::BaseType *fntype_tyty;\n     if (!ctx->get_tyctx ()->lookup_type (function.get_mappings ().get_hirid (),\n \t\t\t\t\t &fntype_tyty))\n@@ -305,14 +302,13 @@ class CompileInherentImplItem : public HIRCompileBase\n   }\n \n private:\n-  CompileInherentImplItem (Context *ctx, bool compile_fns,\n-\t\t\t   TyTy::BaseType *concrete, Location ref_locus)\n-    : HIRCompileBase (ctx), compile_fns (compile_fns), concrete (concrete),\n+  CompileInherentImplItem (Context *ctx, TyTy::BaseType *concrete,\n+\t\t\t   Location ref_locus)\n+    : HIRCompileBase (ctx), concrete (concrete),\n       reference (ctx->get_backend ()->error_expression ()),\n       ref_locus (ref_locus)\n   {}\n \n-  bool compile_fns;\n   TyTy::BaseType *concrete;\n   tree reference;\n   Location ref_locus;"}, {"sha": "73f6967b27218afab215ddc88381c6e80f9862f9", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a0c6eb4b9ea3779f01418cfc97a6761ca4a957/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a0c6eb4b9ea3779f01418cfc97a6761ca4a957/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=c8a0c6eb4b9ea3779f01418cfc97a6761ca4a957", "patch": "@@ -38,12 +38,12 @@ class CompileItem : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static tree compile (HIR::Item *item, Context *ctx, bool compile_fns = true,\n+  static tree compile (HIR::Item *item, Context *ctx,\n \t\t       TyTy::BaseType *concrete = nullptr,\n \t\t       bool is_query_mode = false,\n \t\t       Location ref_locus = Location ())\n   {\n-    CompileItem compiler (ctx, compile_fns, concrete, ref_locus);\n+    CompileItem compiler (ctx, concrete, ref_locus);\n     item->accept_vis (compiler);\n \n     if (is_query_mode\n@@ -56,6 +56,16 @@ class CompileItem : public HIRCompileBase\n \n   void visit (HIR::StaticItem &var) override\n   {\n+    // have we already compiled this?\n+    Bvariable *static_decl_ref = nullptr;\n+    if (ctx->lookup_var_decl (var.get_mappings ().get_hirid (),\n+\t\t\t      &static_decl_ref))\n+      {\n+\treference\n+\t  = ctx->get_backend ()->var_expression (static_decl_ref, ref_locus);\n+\treturn;\n+      }\n+\n     TyTy::BaseType *resolved_type = nullptr;\n     bool ok = ctx->get_tyctx ()->lookup_type (var.get_mappings ().get_hirid (),\n \t\t\t\t\t      &resolved_type);\n@@ -191,9 +201,6 @@ class CompileItem : public HIRCompileBase\n \n   void visit (HIR::Function &function) override\n   {\n-    if (!compile_fns)\n-      return;\n-\n     TyTy::BaseType *fntype_tyty;\n     if (!ctx->get_tyctx ()->lookup_type (function.get_mappings ().get_hirid (),\n \t\t\t\t\t &fntype_tyty))\n@@ -395,32 +402,29 @@ class CompileItem : public HIRCompileBase\n       }\n \n     for (auto &impl_item : impl_block.get_impl_items ())\n-      CompileInherentImplItem::Compile (impl_item.get (), ctx, compile_fns);\n+      CompileInherentImplItem::Compile (impl_item.get (), ctx);\n   }\n \n   void visit (HIR::ExternBlock &extern_block) override\n   {\n     for (auto &item : extern_block.get_extern_items ())\n       {\n-\tCompileExternItem::compile (item.get (), ctx, compile_fns, concrete);\n+\tCompileExternItem::compile (item.get (), ctx, concrete);\n       }\n   }\n \n   void visit (HIR::Module &module) override\n   {\n     for (auto &item : module.get_items ())\n-      CompileItem::compile (item.get (), ctx, compile_fns);\n+      CompileItem::compile (item.get (), ctx);\n   }\n \n protected:\n-  CompileItem (Context *ctx, bool compile_fns, TyTy::BaseType *concrete,\n-\t       Location ref_locus)\n-    : HIRCompileBase (ctx), compile_fns (compile_fns), concrete (concrete),\n-      reference (ctx->get_backend ()->error_expression ()),\n+  CompileItem (Context *ctx, TyTy::BaseType *concrete, Location ref_locus)\n+    : HIRCompileBase (ctx), concrete (concrete), reference (error_mark_node),\n       ref_locus (ref_locus)\n   {}\n \n-  bool compile_fns;\n   TyTy::BaseType *concrete;\n   tree reference;\n   Location ref_locus;"}, {"sha": "ddb6c914d18206822e7c1f4e3db60d1d1af23896", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a0c6eb4b9ea3779f01418cfc97a6761ca4a957/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a0c6eb4b9ea3779f01418cfc97a6761ca4a957/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=c8a0c6eb4b9ea3779f01418cfc97a6761ca4a957", "patch": "@@ -166,10 +166,10 @@ HIRCompileBase::query_compile (HirId ref, TyTy::BaseType *lookup,\n   if (is_hir_item)\n     {\n       if (!lookup->has_subsititions_defined ())\n-\treturn CompileItem::compile (resolved_item, ctx, true, nullptr, true,\n+\treturn CompileItem::compile (resolved_item, ctx, nullptr, true,\n \t\t\t\t     expr_locus);\n       else\n-\treturn CompileItem::compile (resolved_item, ctx, true, lookup, true,\n+\treturn CompileItem::compile (resolved_item, ctx, lookup, true,\n \t\t\t\t     expr_locus);\n     }\n   else\n@@ -194,11 +194,11 @@ HIRCompileBase::query_compile (HirId ref, TyTy::BaseType *lookup,\n \t  rust_assert (ok);\n \n \t  if (!lookup->has_subsititions_defined ())\n-\t    return CompileInherentImplItem::Compile (resolved_item, ctx, true,\n+\t    return CompileInherentImplItem::Compile (resolved_item, ctx,\n \t\t\t\t\t\t     nullptr, true, expr_locus);\n \t  else\n-\t    return CompileInherentImplItem::Compile (resolved_item, ctx, true,\n-\t\t\t\t\t\t     lookup, true, expr_locus);\n+\t    return CompileInherentImplItem::Compile (resolved_item, ctx, lookup,\n+\t\t\t\t\t\t     true, expr_locus);\n \t}\n       else\n \t{\n@@ -276,13 +276,12 @@ HIRCompileBase::query_compile (HirId ref, TyTy::BaseType *lookup,\n \t      rust_assert (ok);\n \n \t      if (!lookup->has_subsititions_defined ())\n-\t\treturn CompileInherentImplItem::Compile (impl_item, ctx, true,\n+\t\treturn CompileInherentImplItem::Compile (impl_item, ctx,\n \t\t\t\t\t\t\t nullptr, true,\n \t\t\t\t\t\t\t expr_locus);\n \t      else\n-\t\treturn CompileInherentImplItem::Compile (impl_item, ctx, true,\n-\t\t\t\t\t\t\t lookup, true,\n-\t\t\t\t\t\t\t expr_locus);\n+\t\treturn CompileInherentImplItem::Compile (impl_item, ctx, lookup,\n+\t\t\t\t\t\t\t true, expr_locus);\n \n \t      lookup->set_ty_ref (impl_item->get_impl_mappings ().get_hirid ());\n \t    }"}, {"sha": "b0447af75053147a905bd27f958d8dfedb0610bb", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a0c6eb4b9ea3779f01418cfc97a6761ca4a957/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a0c6eb4b9ea3779f01418cfc97a6761ca4a957/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=c8a0c6eb4b9ea3779f01418cfc97a6761ca4a957", "patch": "@@ -46,10 +46,7 @@ void\n CompileCrate::go ()\n {\n   for (auto &item : crate.items)\n-    CompileItem::compile (item.get (), ctx, false);\n-\n-  for (auto &item : crate.items)\n-    CompileItem::compile (item.get (), ctx, true);\n+    CompileItem::compile (item.get (), ctx);\n }\n \n // rust-compile-block.h\n@@ -274,7 +271,7 @@ HIRCompileBase::compile_locals_for_block (Resolver::Rib &rib, tree fndecl,\n     if (is_item)\n       {\n \tHIR::Item *item = static_cast<HIR::Item *> (decl);\n-\tCompileItem::compile (item, ctx, true);\n+\tCompileItem::compile (item, ctx);\n \treturn true;\n       }\n \n@@ -528,7 +525,7 @@ HIRCompileBase::compute_address_for_trait_item (\n \t  lookup_fntype = lookup_fntype->handle_substitions (mappings);\n \t}\n \n-      return CompileInherentImplItem::Compile (associated_function, ctx, true,\n+      return CompileInherentImplItem::Compile (associated_function, ctx,\n \t\t\t\t\t       lookup_fntype, true, locus);\n     }\n "}]}