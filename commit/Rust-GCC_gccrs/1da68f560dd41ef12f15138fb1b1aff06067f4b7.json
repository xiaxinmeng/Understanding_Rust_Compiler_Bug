{"sha": "1da68f560dd41ef12f15138fb1b1aff06067f4b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWRhNjhmNTYwZGQ0MWVmMTJmMTUxMzhmYjFiMWFmZjA2MDY3ZjRiNw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-12-30T13:10:51Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-12-30T13:10:51Z"}, "message": "alias.c (alias_sets_conflict_p): New function.\n\n\t* alias.c (alias_sets_conflict_p): New function.\n\t(mems_in_disjoint_alias_sets_p): Use it.\n\t(readonly_fields_p): Moved from expr.c; check for record type.\n\t(objects_must_conflict_p): New function.\n\t* calls.c (expand_call): Use assign_temp as much as possible, use\n\treadonly variant if assigned once, and don't set memory attributes.\n\t(emit_library_call_value_1, store_one_arg): Likewise.\n\t* integrate.c (expand_inline_function): Likewise.\n\t* stmt.c (expand_asm_operands, expand_return): Likewise.\n\t* expr.c (copy_blkmode_from_reg, store_constructor): Likewise.\n\t(store_field, save_noncopied_parts, expand_expr): Likewise.\n\t(expand_expr_unaligned): Likewise.\n\t(readonly_fields_p): Moved to alias.c.\n\t(safe_from_p): Rework handling of SAVE_EXPR.\n\tMEMs ony conflict if alias sets conflict; likewise for INDIRECT_REF.\n\t* function.c (struct temp_slot): Delete field ALIAS_SET; add TYPE.\n\t(assign_stack_for_temp): Use objects_must_confict_p.\n\tSet all memory attributes from type, if specified.\n\t(mark_temp_slot): Mark TYPE field.\n\t* tree.h (alias_sets_conflict_p, readonly_fields_p): New decls.\n\t(objects_must_conflict_p): Likewise.\n\n\t* stmt.c (expand_decl): Don't use assign_stack_temp in error case.\n\t(add_case_node): No need to copy nodes anymore.\n\nFrom-SVN: r38559", "tree": {"sha": "23f23dc6bdc5d0a2afd4675766fb43eb2ef34bc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23f23dc6bdc5d0a2afd4675766fb43eb2ef34bc3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1da68f560dd41ef12f15138fb1b1aff06067f4b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1da68f560dd41ef12f15138fb1b1aff06067f4b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1da68f560dd41ef12f15138fb1b1aff06067f4b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1da68f560dd41ef12f15138fb1b1aff06067f4b7/comments", "author": null, "committer": null, "parents": [{"sha": "2e9ab75de463a34abe8d5d0749999195d6e62942", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e9ab75de463a34abe8d5d0749999195d6e62942", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e9ab75de463a34abe8d5d0749999195d6e62942"}], "stats": {"total": 504, "additions": 279, "deletions": 225}, "files": [{"sha": "4256da7fab70ec2cd97440044177475b1f9f833f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1da68f560dd41ef12f15138fb1b1aff06067f4b7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1da68f560dd41ef12f15138fb1b1aff06067f4b7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1da68f560dd41ef12f15138fb1b1aff06067f4b7", "patch": "@@ -1,9 +1,35 @@\n+2000-12-30  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* alias.c (alias_sets_conflict_p): New function.\n+\t(mems_in_disjoint_alias_sets_p): Use it.\n+\t(readonly_fields_p): Moved from expr.c; check for record type.\n+\t(objects_must_conflict_p): New function.\n+\t* calls.c (expand_call): Use assign_temp as much as possible, use\n+\treadonly variant if assigned once, and don't set memory attributes.\n+\t(emit_library_call_value_1, store_one_arg): Likewise.\n+\t* integrate.c (expand_inline_function): Likewise.\n+\t* stmt.c (expand_asm_operands, expand_return): Likewise.\n+\t* expr.c (copy_blkmode_from_reg, store_constructor): Likewise.\n+\t(store_field, save_noncopied_parts, expand_expr): Likewise.\n+\t(expand_expr_unaligned): Likewise.\n+\t(readonly_fields_p): Moved to alias.c.\n+\t(safe_from_p): Rework handling of SAVE_EXPR.\n+\tMEMs ony conflict if alias sets conflict; likewise for INDIRECT_REF.\n+\t* function.c (struct temp_slot): Delete field ALIAS_SET; add TYPE.\n+\t(assign_stack_for_temp): Use objects_must_confict_p.\n+\tSet all memory attributes from type, if specified.\n+\t(mark_temp_slot): Mark TYPE field.\n+\t* tree.h (alias_sets_conflict_p, readonly_fields_p): New decls.\n+\t(objects_must_conflict_p): Likewise.\n+\n+\t* stmt.c (expand_decl): Don't use assign_stack_temp in error case.\n+\t(add_case_node): No need to copy nodes anymore.\n+\t\n 2000-12-30  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* config/sh/sh.c (split_branches): Don't dereference re-computed\n \t`beyond' before checking it's non-NULL.\n \n-\n 2000-12-29  Robert Lipe <robertl@sco.com>\n \n \tRemove COFF support from i?86-pc-sco3.2v5."}, {"sha": "41cf596cd4115be1513c635960514b2df1c62f79", "filename": "gcc/alias.c", "status": "modified", "additions": 86, "deletions": 25, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1da68f560dd41ef12f15138fb1b1aff06067f4b7/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1da68f560dd41ef12f15138fb1b1aff06067f4b7/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=1da68f560dd41ef12f15138fb1b1aff06067f4b7", "patch": "@@ -211,8 +211,6 @@ mems_in_disjoint_alias_sets_p (mem1, mem2)\n      rtx mem1;\n      rtx mem2;\n {\n-  alias_set_entry ase;\n-\n #ifdef ENABLE_CHECKING\t\n /* Perform a basic sanity check.  Namely, that there are no alias sets\n    if we're not using strict aliasing.  This helps to catch bugs\n@@ -226,49 +224,112 @@ mems_in_disjoint_alias_sets_p (mem1, mem2)\n     abort ();\n #endif\n \n-  /* If have no alias set information for one of the MEMs, we have to assume\n-     it can alias anything.  */\n-  if (MEM_ALIAS_SET (mem1) == 0 || MEM_ALIAS_SET (mem2) == 0)\n-    return 0;\n+  return ! alias_sets_conflict_p (MEM_ALIAS_SET (mem1), MEM_ALIAS_SET (mem2));\n+}\n \n-  /* If the two alias sets are the same, they may alias.  */\n-  if (MEM_ALIAS_SET (mem1) == MEM_ALIAS_SET (mem2))\n-    return 0;\n+/* Insert the NODE into the splay tree given by DATA.  Used by\n+   record_alias_subset via splay_tree_foreach.  */\n+\n+static int\n+insert_subset_children (node, data)\n+     splay_tree_node node;\n+     void *data;\n+{\n+  splay_tree_insert ((splay_tree) data, node->key, node->value);\n+\n+  return 0;\n+}\n+\n+/* Return 1 if the two specified alias sets may conflict.  */\n+\n+int\n+alias_sets_conflict_p (set1, set2)\n+     HOST_WIDE_INT set1, set2;\n+{\n+  alias_set_entry ase;\n+\n+  /* If have no alias set information for one of the operands, we have\n+     to assume it can alias anything.  */\n+  if (set1 == 0 || set2 == 0\n+      /* If the two alias sets are the same, they may alias.  */\n+      || set1 == set2)\n+    return 1;\n \n   /* See if the first alias set is a subset of the second.  */\n-  ase = get_alias_set_entry (MEM_ALIAS_SET (mem1));\n+  ase = get_alias_set_entry (set1);\n   if (ase != 0\n       && (ase->has_zero_child\n \t  || splay_tree_lookup (ase->children,\n-\t\t\t\t(splay_tree_key) MEM_ALIAS_SET (mem2))))\n-    return  0;\n+\t\t\t\t(splay_tree_key) set2)))\n+    return 1;\n \n   /* Now do the same, but with the alias sets reversed.  */\n-  ase = get_alias_set_entry (MEM_ALIAS_SET (mem2));\n+  ase = get_alias_set_entry (set2);\n   if (ase != 0\n       && (ase->has_zero_child\n \t  || splay_tree_lookup (ase->children,\n-\t\t\t\t(splay_tree_key) MEM_ALIAS_SET (mem1))))\n-    return  0;\n+\t\t\t\t(splay_tree_key) set1)))\n+    return 1;\n \n-  /* The two MEMs are in distinct alias sets, and neither one is the\n+  /* The two alias sets are distinct and neither one is the\n      child of the other.  Therefore, they cannot alias.  */\n-  return 1;\n+  return 0;\n }\n+\f\n+/* Return 1 if TYPE is a RECORD_TYPE, UNION_TYPE, or QUAL_UNION_TYPE and has\n+   has any readonly fields.  If any of the fields have types that\n+   contain readonly fields, return true as well.  */\n \n-/* Insert the NODE into the splay tree given by DATA.  Used by\n-   record_alias_subset via splay_tree_foreach.  */\n-\n-static int\n-insert_subset_children (node, data)\n-     splay_tree_node node;\n-     void *data;\n+int\n+readonly_fields_p (type)\n+     tree type;\n {\n-  splay_tree_insert ((splay_tree) data, node->key, node->value);\n+  tree field;\n+\n+  if (TREE_CODE (type) != RECORD_TYPE && TREE_CODE (type) != UNION_TYPE\n+      && TREE_CODE (type) != QUAL_UNION_TYPE)\n+    return 0;\n+\n+  for (field = TYPE_FIELDS (type); field != 0; field = TREE_CHAIN (field))\n+    if (TREE_CODE (field) == FIELD_DECL\n+\t&& (TREE_READONLY (field)\n+\t    || readonly_fields_p (TREE_TYPE (field))))\n+      return 1;\n \n   return 0;\n }\n \f\n+/* Return 1 if any MEM object of type T1 will always conflict (using the\n+   dependency routines in this file) with any MEM object of type T2.\n+   This is used when allocating temporary storage.  If T1 and/or T2 are\n+   NULL_TREE, it means we know nothing about the storage.  */\n+\n+int\n+objects_must_conflict_p (t1, t2)\n+     tree t1, t2;\n+{\n+  /* If they are the same type, they must conflict.  */\n+  if (t1 == t2\n+      /* Likewise if both are volatile.  */\n+      || (t1 != 0 && TYPE_VOLATILE (t1) && t2 != 0 && TYPE_VOLATILE (t2)))\n+    return 1;\n+\n+  /* We now know they are different types.  If one or both has readonly fields\n+     or if one is readonly and the other not, they may not conflict.\n+     Likewise if one is aggregate and the other is scalar.  */\n+  if ((t1 != 0 && readonly_fields_p (t1))\n+      || (t2 != 0 && readonly_fields_p (t2))\n+      || ((t1 != 0 && TYPE_READONLY (t1))\n+\t  != (t2 != 0 && TYPE_READONLY (t2)))\n+      || ((t1 != 0 && AGGREGATE_TYPE_P (t1))\n+\t  != (t2 != 0 && AGGREGATE_TYPE_P (t2))))\n+    return 0;\n+\n+  /* Otherwise they conflict only if the alias sets conflict. */\n+  return alias_sets_conflict_p (t1 ? get_alias_set (t1) : 0,\n+\t\t\t\tt2 ? get_alias_set (t2) : 0);\n+}\n+\f\n /* T is an expression with pointer type.  Find the DECL on which this\n    expression is based.  (For example, in `a[i]' this would be `a'.)\n    If there is no such DECL, or a unique decl cannot be determined,"}, {"sha": "89706bcc6bf1d8b2d7335d69d373cf27aba8297e", "filename": "gcc/calls.c", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1da68f560dd41ef12f15138fb1b1aff06067f4b7/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1da68f560dd41ef12f15138fb1b1aff06067f4b7/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=1da68f560dd41ef12f15138fb1b1aff06067f4b7", "patch": "@@ -2260,16 +2260,11 @@ expand_call (exp, target, ignore)\n \t  structure_value_addr = XEXP (target, 0);\n \telse\n \t  {\n-\t    rtx d;\n-\n \t    /* For variable-sized objects, we must be called with a target\n \t       specified.  If we were to allocate space on the stack here,\n \t       we would have no way of knowing when to free it.  */\n+\t    rtx d = assign_temp (TREE_TYPE (exp), 1, 1, 1);\n \n-\t    if (struct_value_size < 0)\n-\t      abort ();\n-\n-\t    d = assign_temp (TREE_TYPE (exp), 1, 1, 1);\n \t    mark_temp_addr_taken (d);\n \t    structure_value_addr = XEXP (d, 0);\n \t    target = 0;\n@@ -3230,18 +3225,20 @@ expand_call (exp, target, ignore)\n \t The Irix 6 ABI has examples of this.  */\n       else if (GET_CODE (valreg) == PARALLEL)\n \t{\n-\t  int bytes = int_size_in_bytes (TREE_TYPE (exp));\n-\n \t  if (target == 0)\n \t    {\n-\t      target = assign_stack_temp (TYPE_MODE (TREE_TYPE (exp)),\n-\t\t\t\t\t  bytes, 0);\n-\t      MEM_SET_IN_STRUCT_P (target, AGGREGATE_TYPE_P (TREE_TYPE (exp)));\n+\t      /* This will only be assigned once, so it can be readonly.  */\n+\t      tree nt = build_qualified_type (TREE_TYPE (exp),\n+\t\t\t\t\t      (TYPE_QUALS (TREE_TYPE (exp))\n+\t\t\t\t\t       | TYPE_QUAL_CONST));\n+\n+\t      target = assign_temp (nt, 0, 1, 1);\n \t      preserve_temp_slots (target);\n \t    }\n \n \t  if (! rtx_equal_p (target, valreg))\n-\t    emit_group_store (target, valreg, bytes,\n+\t    emit_group_store (target, valreg,\n+\t\t\t      int_size_in_bytes (TREE_TYPE (exp)),\n \t\t\t      TYPE_ALIGN (TREE_TYPE (exp)));\n \n \t  /* We can not support sibling calls for this case.  */\n@@ -3562,7 +3559,7 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n       if (value != 0 && GET_CODE (value) == MEM)\n \tmem_value = value;\n       else\n-\tmem_value = assign_stack_temp (outmode, GET_MODE_SIZE (outmode), 0);\n+\tmem_value = assign_temp (type_for_mode (outmode, 0), 0, 1, 1);\n #endif\n \n       /* This call returns a big structure.  */\n@@ -3666,7 +3663,8 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n \t{\n \t  /* We do not support FUNCTION_ARG_CALLEE_COPIES here since it can\n \t     be viewed as just an efficiency improvement.  */\n-\t  rtx slot = assign_stack_temp (mode, GET_MODE_SIZE (mode), 0);\n+\t  rtx slot = assign_temp (type_for_mode (mode, 0), 0, 1, 1);\n+\n \t  call_fusage = gen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t\t\t   gen_rtx_USE (VOIDmode, slot),\n \t\t\t\t\t   call_fusage);\n@@ -4339,15 +4337,15 @@ store_one_arg (arg, argblock, flags, variable_size, reg_parm_stack_space)\n \n \t      if (save_mode == BLKmode)\n \t\t{\n-\t\t  arg->save_area = assign_stack_temp (BLKmode,\n-\t\t\t\t\t\t      arg->size.constant, 0);\n-\t\t  MEM_SET_IN_STRUCT_P (arg->save_area,\n-\t\t\t\t       AGGREGATE_TYPE_P (TREE_TYPE\n-\t\t\t\t\t\t\t (arg->tree_value)));\n+\t\t  tree ot = TREE_TYPE (arg->tree_value);\n+\t\t  tree nt = build_qualified_type (ot, (TYPE_QUALS (ot)\n+\t\t\t\t\t\t       | TYPE_QUAL_CONST));\n+\n+\t\t  arg->save_area = assign_temp (nt, 0, 1, 1);\n \t\t  preserve_temp_slots (arg->save_area);\n \t\t  emit_block_move (validize_mem (arg->save_area), stack_area,\n-\t\t\t\t   GEN_INT (arg->size.constant),\n-\t\t\t\t   PARM_BOUNDARY);\n+\t\t\t\t   expr_size (arg->tree_value),\n+\t\t\t\t   MIN (PARM_BOUNDARY, TYPE_ALIGN (nt)));\n \t\t}\n \t      else\n \t\t{"}, {"sha": "c4160d99d97ee4c992e4c555c7858108bbdaae77", "filename": "gcc/expr.c", "status": "modified", "additions": 104, "deletions": 137, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1da68f560dd41ef12f15138fb1b1aff06067f4b7/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1da68f560dd41ef12f15138fb1b1aff06067f4b7/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=1da68f560dd41ef12f15138fb1b1aff06067f4b7", "patch": "@@ -181,7 +181,6 @@ static tree save_noncopied_parts PARAMS ((tree, tree));\n static tree init_noncopied_parts PARAMS ((tree, tree));\n static int fixed_type_p\t\tPARAMS ((tree));\n static rtx var_rtx\t\tPARAMS ((tree));\n-static int readonly_fields_p\tPARAMS ((tree));\n static rtx expand_expr_unaligned PARAMS ((tree, unsigned int *));\n static rtx expand_increment\tPARAMS ((tree, int, int));\n static void do_jump_by_parts_greater PARAMS ((tree, int, rtx, rtx));\n@@ -2145,8 +2144,10 @@ copy_blkmode_from_reg (tgtblk, srcreg, type)\n \n   if (tgtblk == 0)\n     {\n-      tgtblk = assign_stack_temp (BLKmode, bytes, 0);\n-      MEM_SET_IN_STRUCT_P (tgtblk, AGGREGATE_TYPE_P (type));\n+      tgtblk = assign_temp (build_qualified_type (type,\n+\t\t\t\t\t\t  (TYPE_QUALS (type)\n+\t\t\t\t\t\t   | TYPE_QUAL_CONST)),\n+\t\t\t    0, 1, 1);\n       preserve_temp_slots (tgtblk);\n     }\n \n@@ -2822,17 +2823,17 @@ emit_move_insn_1 (x, y)\n \t\t  enum mode_class reg_class = ((class == MODE_COMPLEX_FLOAT)\n \t\t\t\t\t       ? MODE_FLOAT : MODE_INT);\n \n-\t\t  enum machine_mode reg_mode =\n-\t\t    mode_for_size (GET_MODE_BITSIZE (mode), reg_class, 1);\n+\t\t  enum machine_mode reg_mode\n+\t\t    = mode_for_size (GET_MODE_BITSIZE (mode), reg_class, 1);\n \n \t\t  if (reg_mode != BLKmode)\n \t\t    {\n \t\t      rtx mem = assign_stack_temp (reg_mode,\n \t\t\t\t\t\t   GET_MODE_SIZE (mode), 0);\n-\n \t\t      rtx cmem = change_address (mem, mode, NULL_RTX);\n \n-\t\t      cfun->cannot_inline = N_(\"function using short complex types cannot be inline\");\n+\t\t      cfun->cannot_inline\n+\t\t\t= N_(\"function using short complex types cannot be inline\");\n \n \t\t      if (packed_dest_p)\n \t\t\t{\n@@ -4921,9 +4922,11 @@ store_constructor (exp, target, align, cleared, size)\n \n \t  if (REG_P (target))\n \t    {\n-\t      targetx = assign_stack_temp (GET_MODE (target),\n-\t\t\t\t\t   GET_MODE_SIZE (GET_MODE (target)),\n-\t\t\t\t\t   0);\n+\t      targetx\n+\t\t= assign_temp\n+\t\t  ((build_qualified_type (type_for_mode (GET_MODE (target), 0),\n+\t\t\t\t\t  TYPE_QUAL_CONST)),\n+\t\t   0, 1, 1);\n \t      emit_move_insn (targetx, target);\n \t    }\n \n@@ -5022,12 +5025,13 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n   if (mode == BLKmode\n       && (GET_CODE (target) == REG || GET_CODE (target) == SUBREG))\n     {\n-      rtx object = assign_stack_temp (GET_MODE (target),\n-\t\t\t\t      GET_MODE_SIZE (GET_MODE (target)), 0);\n+      rtx object\n+\t= assign_temp\n+\t  (build_qualified_type (type_for_mode (GET_MODE (target), 0),\n+\t\t\t\t TYPE_QUAL_CONST),\n+\t   0, 1, 1);\n       rtx blk_object = copy_rtx (object);\n \n-      MEM_SET_IN_STRUCT_P (object, 1);\n-      MEM_SET_IN_STRUCT_P (blk_object, 1);\n       PUT_MODE (blk_object, BLKmode);\n \n       if (bitsize != GET_MODE_BITSIZE (GET_MODE (target)))\n@@ -5506,7 +5510,12 @@ save_noncopied_parts (lhs, list)\n \ttree part = TREE_VALUE (tail);\n \ttree part_type = TREE_TYPE (part);\n \ttree to_be_saved = build (COMPONENT_REF, part_type, lhs, part);\n-\trtx target = assign_temp (part_type, 0, 1, 1);\n+\trtx target\n+\t  = assign_temp (build_qualified_type (part_type,\n+\t\t\t\t\t       (TYPE_QUALS (part_type)\n+\t\t\t\t\t\t| TYPE_QUAL_CONST)),\n+\t\t\t 0, 1, 1);\n+\n \tif (! memory_address_p (TYPE_MODE (part_type), XEXP (target, 0)))\n \t  target = change_address (target, TYPE_MODE (part_type), NULL_RTX);\n \tparts = tree_cons (to_be_saved,\n@@ -5559,10 +5568,7 @@ safe_from_p (x, exp, top_p)\n {\n   rtx exp_rtl = 0;\n   int i, nops;\n-  static int save_expr_count;\n-  static int save_expr_size = 0;\n-  static tree *save_expr_rewritten;\n-  static tree save_expr_trees[256];\n+  static tree save_expr_list;\n \n   if (x == 0\n       /* If EXP has varying size, we MUST use a target since we currently\n@@ -5577,31 +5583,14 @@ safe_from_p (x, exp, top_p)\n \t      || TYPE_ARRAY_MAX_SIZE (TREE_TYPE (exp)) == NULL_TREE\n \t      || TREE_CODE (TYPE_ARRAY_MAX_SIZE (TREE_TYPE (exp)))\n \t      != INTEGER_CST)\n-\t  && GET_MODE (x) == BLKmode))\n+\t  && GET_MODE (x) == BLKmode)\n+      /* If X is in the outgoing argument area, it is always safe.  */\n+      || (GET_CODE (x) == MEM\n+\t  && (XEXP (x, 0) == virtual_outgoing_args_rtx\n+\t      || (GET_CODE (XEXP (x, 0)) == PLUS\n+\t\t  && XEXP (XEXP (x, 0), 0) == virtual_outgoing_args_rtx))))\n     return 1;\n \n-  if (top_p && save_expr_size == 0)\n-    {\n-      int rtn;\n-\n-      save_expr_count = 0;\n-      save_expr_size = ARRAY_SIZE (save_expr_trees);\n-      save_expr_rewritten = &save_expr_trees[0];\n-\n-      rtn = safe_from_p (x, exp, 1);\n-\n-      for (i = 0; i < save_expr_count; ++i)\n-\t{\n-\t  if (TREE_CODE (save_expr_trees[i]) != ERROR_MARK)\n-\t    abort ();\n-\t  TREE_SET_CODE (save_expr_trees[i], SAVE_EXPR);\n-\t}\n-\n-      save_expr_size = 0;\n-\n-      return rtn;\n-    }\n-\n   /* If this is a subreg of a hard register, declare it unsafe, otherwise,\n      find the underlying pseudo.  */\n   if (GET_CODE (x) == SUBREG)\n@@ -5611,13 +5600,31 @@ safe_from_p (x, exp, top_p)\n \treturn 0;\n     }\n \n-  /* If X is a location in the outgoing argument area, it is always safe.  */\n-  if (GET_CODE (x) == MEM\n-      && (XEXP (x, 0) == virtual_outgoing_args_rtx\n-\t  || (GET_CODE (XEXP (x, 0)) == PLUS\n-\t      && XEXP (XEXP (x, 0), 0) == virtual_outgoing_args_rtx)))\n-    return 1;\n+  /* A SAVE_EXPR might appear many times in the expression passed to the\n+     top-level safe_from_p call, and if it has a complex subexpression,\n+     examining it multiple times could result in a combinatorial explosion.\n+     E.g. on an Alpha running at least 200MHz, a Fortran test case compiled\n+     with optimization took about 28 minutes to compile -- even though it was\n+     only a few lines long.  So we mark each SAVE_EXPR we see with TREE_PRIVATE\n+     and turn that off when we are done.  We keep a list of the SAVE_EXPRs\n+     we have processed.  Note that the only test of top_p was above.  */\n+\n+  if (top_p)\n+    {\n+      int rtn;\n+      tree t;\n+\n+      save_expr_list = 0;\n+\n+      rtn = safe_from_p (x, exp, 0);\n+\n+      for (t = save_expr_list; t != 0; t = TREE_CHAIN (t))\n+\tTREE_PRIVATE (TREE_PURPOSE (t)) = 0;\n+\n+      return rtn;\n+    }\n \n+  /* Now look at our tree code and possibly recurse.  */\n   switch (TREE_CODE_CLASS (TREE_CODE (exp)))\n     {\n     case 'd':\n@@ -5657,11 +5664,13 @@ safe_from_p (x, exp, top_p)\n \t{\n \tcase ADDR_EXPR:\n \t  return (staticp (TREE_OPERAND (exp, 0))\n-\t\t  || safe_from_p (x, TREE_OPERAND (exp, 0), 0)\n-\t\t  || TREE_STATIC (exp));\n+\t\t  || TREE_STATIC (exp)\n+\t\t  || safe_from_p (x, TREE_OPERAND (exp, 0), 0));\n \n \tcase INDIRECT_REF:\n-\t  if (GET_CODE (x) == MEM)\n+\t  if (GET_CODE (x) == MEM\n+\t      && alias_sets_conflict_p (MEM_ALIAS_SET (x),\n+\t\t\t\t\tget_alias_set (exp)))\n \t    return 0;\n \t  break;\n \n@@ -5695,37 +5704,20 @@ safe_from_p (x, exp, top_p)\n \t  if (exp_rtl)\n \t    break;\n \n-\t  /* This SAVE_EXPR might appear many times in the top-level\n-\t     safe_from_p() expression, and if it has a complex\n-\t     subexpression, examining it multiple times could result\n-\t     in a combinatorial explosion.  E.g. on an Alpha\n-\t     running at least 200MHz, a Fortran test case compiled with\n-\t     optimization took about 28 minutes to compile -- even though\n-\t     it was only a few lines long, and the complicated line causing\n-\t     so much time to be spent in the earlier version of safe_from_p()\n-\t     had only 293 or so unique nodes.\n-\n-\t     So, turn this SAVE_EXPR into an ERROR_MARK for now, but remember\n-\t     where it is so we can turn it back in the top-level safe_from_p()\n-\t     when we're done.  */\n-\n-\t  /* For now, don't bother re-sizing the array.  */\n-\t  if (save_expr_count >= save_expr_size)\n-\t    return 0;\n-\t  save_expr_rewritten[save_expr_count++] = exp;\n+\t  /* If we've already scanned this, don't do it again.  Otherwise,\n+\t     show we've scanned it and record for clearing the flag if we're\n+\t     going on.  */\n+\t  if (TREE_PRIVATE (exp))\n+\t    return 1;\n \n-\t  nops = TREE_CODE_LENGTH (SAVE_EXPR);\n-\t  for (i = 0; i < nops; i++)\n+\t  TREE_PRIVATE (exp) = 1;\n+\t  if (! safe_from_p (x, TREE_OPERAND (exp, 0), 0))\n \t    {\n-\t      tree operand = TREE_OPERAND (exp, i);\n-\t      if (operand == NULL_TREE)\n-\t\tcontinue;\n-\t      TREE_SET_CODE (exp, ERROR_MARK);\n-\t      if (!safe_from_p (x, operand, 0))\n-\t\treturn 0;\n-\t      TREE_SET_CODE (exp, SAVE_EXPR);\n+\t      TREE_PRIVATE (exp) = 0;\n+\t      return 0;\n \t    }\n-\t  TREE_SET_CODE (exp, ERROR_MARK);\n+\n+\t  save_expr_list = tree_cons (exp, NULL_TREE, save_expr_list);\n \t  return 1;\n \n \tcase BIND_EXPR:\n@@ -5772,10 +5764,11 @@ safe_from_p (x, exp, top_p)\n \t}\n \n       /* If the rtl is X, then it is not safe.  Otherwise, it is unless both\n-\t are memory and EXP is not readonly.  */\n+\t are memory and they conflict.  */\n       return ! (rtx_equal_p (x, exp_rtl)\n \t\t|| (GET_CODE (x) == MEM && GET_CODE (exp_rtl) == MEM\n-\t\t    && ! TREE_READONLY (exp)));\n+\t\t    && true_dependence (exp_rtl, GET_MODE (x), x,\n+\t\t\t\t\trtx_addr_varies_p)));\n     }\n \n   /* If we reach here, it is safe.  */\n@@ -5870,26 +5863,6 @@ check_max_integer_computation_mode (exp)\n }\n #endif\n \f\n-/* Utility function used by expand_expr to see if TYPE, a RECORD_TYPE,\n-   has any readonly fields.  If any of the fields have types that\n-   contain readonly fields, return true as well.  */\n-\n-static int\n-readonly_fields_p (type)\n-     tree type;\n-{\n-  tree field;\n-\n-  for (field = TYPE_FIELDS (type); field != 0; field = TREE_CHAIN (field))\n-    if (TREE_CODE (field) == FIELD_DECL\n-\t&& (TREE_READONLY (field)\n-\t    || (TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE\n-\t\t&& readonly_fields_p (TREE_TYPE (field)))))\n-      return 1;\n-\n-  return 0;\n-}\n-\f\n /* expand_expr: generate code for computing expression EXP.\n    An rtx for the computed value is returned.  The value is never null.\n    In the case of a void EXP, const0_rtx is returned.\n@@ -6350,11 +6323,10 @@ expand_expr (exp, target, tmode, modifier)\n \t  if (mode == VOIDmode)\n \t    temp = const0_rtx;\n \t  else\n-\t    {\n-\t      temp = assign_temp (type, 3, 0, 0);\n-\t      if (GET_CODE (temp) == MEM)\n-\t\tRTX_UNCHANGING_P (temp) = 1;\n-\t    }\n+\t    temp = assign_temp (build_qualified_type (type,\n+\t\t\t\t\t\t      (TYPE_QUALS (type)\n+\t\t\t\t\t\t       | TYPE_QUAL_CONST)),\n+\t\t\t\t3, 0, 0);\n \n \t  SAVE_EXPR_RTL (exp) = temp;\n \t  if (!optimize && GET_CODE (temp) == REG)\n@@ -6606,27 +6578,18 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\t\t  XEXP (constructor, 0));\n \t  return constructor;\n \t}\n-\n       else\n \t{\n \t  /* Handle calls that pass values in multiple non-contiguous\n \t     locations.  The Irix 6 ABI has examples of this.  */\n \t  if (target == 0 || ! safe_from_p (target, exp, 1)\n \t      || GET_CODE (target) == PARALLEL)\n-\t    {\n-\t      if (mode != BLKmode && ! TREE_ADDRESSABLE (exp))\n-\t\ttarget = gen_reg_rtx (tmode != VOIDmode ? tmode : mode);\n-\t      else\n-\t\ttarget = assign_temp (type, 0, 1, 1);\n-\t    }\n-\n-\t  if (TREE_READONLY (exp))\n-\t    {\n-\t      if (GET_CODE (target) == MEM)\n-\t\ttarget = copy_rtx (target);\n-\n-\t      RTX_UNCHANGING_P (target) = 1;\n-\t    }\n+\t    target\n+\t      = assign_temp (build_qualified_type (type,\n+\t\t\t\t\t\t   (TYPE_QUALS (type)\n+\t\t\t\t\t\t    | (TREE_READONLY (exp)\n+\t\t\t\t\t\t       * TYPE_QUAL_CONST))),\n+\t\t\t     TREE_ADDRESSABLE (exp), 1, 1);\n \n \t  store_constructor (exp, target, TYPE_ALIGN (TREE_TYPE (exp)), 0,\n \t\t\t     int_size_in_bytes (TREE_TYPE (exp)));\n@@ -6685,8 +6648,7 @@ expand_expr (exp, target, tmode, modifier)\n \t/* If we are writing to this object and its type is a record with\n \t   readonly fields, we must mark it as readonly so it will\n \t   conflict with readonly references to those fields.  */\n-\tif (modifier == EXPAND_MEMORY_USE_WO\n-\t    && TREE_CODE (type) == RECORD_TYPE && readonly_fields_p (type))\n+\tif (modifier == EXPAND_MEMORY_USE_WO && readonly_fields_p (type))\n \t  RTX_UNCHANGING_P (temp) = 1;\n \n \treturn temp;\n@@ -6902,7 +6864,10 @@ expand_expr (exp, target, tmode, modifier)\n \t    if (GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG\n \t\t|| GET_CODE (op0) == CONCAT || GET_CODE (op0) == ADDRESSOF)\n \t      {\n-\t\trtx memloc = assign_temp (TREE_TYPE (tem), 1, 1, 1);\n+\t\ttree nt = build_qualified_type (TREE_TYPE (tem),\n+\t\t\t\t\t\t(TYPE_QUALS (TREE_TYPE (tem))\n+\t\t\t\t\t\t | TYPE_QUAL_CONST));\n+\t\trtx memloc = assign_temp (nt, 1, 1, 1);\n \n \t\tmark_temp_addr_taken (memloc);\n \t\temit_move_insn (memloc, op0);\n@@ -7077,13 +7042,13 @@ expand_expr (exp, target, tmode, modifier)\n \n \t    if (mode == BLKmode)\n \t      {\n-\t\trtx new = assign_stack_temp (ext_mode,\n-\t\t\t\t\t     bitsize / BITS_PER_UNIT, 0);\n+\t\ttree nt = build_qualified_type (type_for_size (ext_mode, 0),\n+\t\t\t\t\t\tTYPE_QUAL_CONST);\n+\t\trtx new = assign_temp (nt, 0, 1, 1);\n \n \t\temit_move_insn (new, op0);\n \t\top0 = copy_rtx (new);\n \t\tPUT_MODE (op0, BLKmode);\n-\t\tMEM_SET_IN_STRUCT_P (op0, 1);\n \t      }\n \n \t    return op0;\n@@ -7303,12 +7268,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\tmodifier);\n \n \t  if (target == 0)\n-\t    {\n-\t      if (mode != BLKmode)\n-\t\ttarget = gen_reg_rtx (tmode != VOIDmode ? tmode : mode);\n-\t      else\n-\t\ttarget = assign_temp (type, 0, 1, 1);\n-\t    }\n+\t    target = assign_temp (type, 0, 1, 1);\n \n \t  if (GET_CODE (target) == MEM)\n \t    /* Store data into beginning of memory target.  */\n@@ -8514,7 +8474,10 @@ expand_expr (exp, target, tmode, modifier)\n \t      /* If this object is in a register, it must be not\n \t\t be BLKmode.  */\n \t      tree inner_type = TREE_TYPE (TREE_OPERAND (exp, 0));\n-\t      rtx memloc = assign_temp (inner_type, 1, 1, 1);\n+\t      tree nt = build_qualified_type (inner_type,\n+\t\t\t\t\t      (TYPE_QUALS (inner_type)\n+\t\t\t\t\t       | TYPE_QUAL_CONST));\n+\t      rtx memloc = assign_temp (nt, 1, 1, 1);\n \n \t      mark_temp_addr_taken (memloc);\n \t      if (GET_CODE (op0) == PARALLEL)\n@@ -8914,7 +8877,10 @@ expand_expr_unaligned (exp, palign)\n \t    if (GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG\n \t\t|| GET_CODE (op0) == CONCAT || GET_CODE (op0) == ADDRESSOF)\n \t      {\n-\t\trtx memloc = assign_temp (TREE_TYPE (tem), 1, 1, 1);\n+\t\ttree nt = build_qualified_type (TREE_TYPE (tem),\n+\t\t\t\t\t\t(TYPE_QUALS (TREE_TYPE (tem))\n+\t\t\t\t\t\t | TYPE_QUAL_CONST));\n+\t\trtx memloc = assign_temp (nt, 1, 1, 1);\n \n \t\tmark_temp_addr_taken (memloc);\n \t\temit_move_insn (memloc, op0);\n@@ -8996,8 +8962,9 @@ expand_expr_unaligned (exp, palign)\n \t      }\n \t    else\n \t      {\n-\t\trtx new = assign_stack_temp (ext_mode,\n-\t\t\t\t\t     bitsize / BITS_PER_UNIT, 0);\n+\t\ttree nt = build_qualified_type (type_for_mode (ext_mode, 0),\n+\t\t\t\t\t\tTYPE_QUAL_CONST);\n+\t\trtx new = assign_temp (nt, 0, 1, 1);\n \n \t\top0 = extract_bit_field (validize_mem (op0), bitsize, bitpos,\n \t\t\t\t\t unsignedp, NULL_RTX, ext_mode,"}, {"sha": "586ef7ea92e481dfc1678d842fee772b54f3d26d", "filename": "gcc/function.c", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1da68f560dd41ef12f15138fb1b1aff06067f4b7/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1da68f560dd41ef12f15138fb1b1aff06067f4b7/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=1da68f560dd41ef12f15138fb1b1aff06067f4b7", "patch": "@@ -193,17 +193,11 @@ struct temp_slot\n   int align;\n   /* The size, in units, of the slot.  */\n   HOST_WIDE_INT size;\n-  /* The alias set for the slot.  If the alias set is zero, we don't\n-     know anything about the alias set of the slot.  We must only\n-     reuse a slot if it is assigned an object of the same alias set.\n-     Otherwise, the rest of the compiler may assume that the new use\n-     of the slot cannot alias the old use of the slot, which is\n-     false.  If the slot has alias set zero, then we can't reuse the\n-     slot at all, since we have no idea what alias set may have been\n-     imposed on the memory.  For example, if the stack slot is the\n-     call frame for an inline functioned, we have no idea what alias\n-     sets will be assigned to various pieces of the call frame.  */\n-  HOST_WIDE_INT alias_set;\n+  /* The type of the object in the slot, or zero if it doesn't correspond\n+     to a type.  We use this to determine whether a slot can be reused.\n+     It can be reused if objects of the type of the new slot will always\n+     conflict with objects of the type of the old slot.  */\n+  tree type;\n   /* The value of `sequence_rtl_expr' when this temporary is allocated.  */\n   tree rtl_expr;\n   /* Non-zero if this temporary is currently in use.  */\n@@ -658,22 +652,13 @@ assign_stack_temp_for_type (mode, size, keep, type)\n      tree type;\n {\n   int align;\n-  HOST_WIDE_INT alias_set;\n   struct temp_slot *p, *best_p = 0;\n \n   /* If SIZE is -1 it means that somebody tried to allocate a temporary\n      of a variable size.  */\n   if (size == -1)\n     abort ();\n \n-  /* If we know the alias set for the memory that will be used, use\n-     it.  If there's no TYPE, then we don't know anything about the\n-     alias set for the memory.  */\n-  if (type)\n-    alias_set = get_alias_set (type);\n-  else\n-    alias_set = 0;\n-\n   if (mode == BLKmode)\n     align = BIGGEST_ALIGNMENT;\n   else\n@@ -691,8 +676,7 @@ assign_stack_temp_for_type (mode, size, keep, type)\n   for (p = temp_slots; p; p = p->next)\n     if (p->align >= align && p->size >= size && GET_MODE (p->slot) == mode\n \t&& ! p->in_use\n-\t&& (! flag_strict_aliasing\n-\t    || (alias_set && p->alias_set == alias_set))\n+\t&& objects_must_conflict_p (p->type, type)\n \t&& (best_p == 0 || best_p->size > p->size\n \t    || (best_p->size == p->size && best_p->align > p->align)))\n       {\n@@ -728,7 +712,7 @@ assign_stack_temp_for_type (mode, size, keep, type)\n \t      p->align = best_p->align;\n \t      p->address = 0;\n \t      p->rtl_expr = 0;\n-\t      p->alias_set = best_p->alias_set;\n+\t      p->type = best_p->type;\n \t      p->next = temp_slots;\n \t      temp_slots = p;\n \n@@ -766,7 +750,6 @@ assign_stack_temp_for_type (mode, size, keep, type)\n \t\t\t\t    align);\n \n       p->align = align;\n-      p->alias_set = alias_set;\n \n       /* The following slot size computation is necessary because we don't\n \t know the actual size of the temporary slot until assign_stack_local\n@@ -797,6 +780,7 @@ assign_stack_temp_for_type (mode, size, keep, type)\n   p->in_use = 1;\n   p->addr_taken = 0;\n   p->rtl_expr = seq_rtl_expr;\n+  p->type = type;\n \n   if (keep == 2)\n     {\n@@ -819,10 +803,23 @@ assign_stack_temp_for_type (mode, size, keep, type)\n   RTX_UNCHANGING_P (p->slot) = 0;\n   MEM_IN_STRUCT_P (p->slot) = 0;\n   MEM_SCALAR_P (p->slot) = 0;\n-  MEM_ALIAS_SET (p->slot) = alias_set;\n+  MEM_VOLATILE_P (p->slot) = 0;\n \n+  /* If we know the alias set for the memory that will be used, use\n+     it.  If there's no TYPE, then we don't know anything about the\n+     alias set for the memory.  */\n+  if (type)\n+    MEM_ALIAS_SET (p->slot) = get_alias_set (type);\n+  else\n+    MEM_ALIAS_SET (p->slot) = 0;\n+\n+  /* If a type is specified, set the relevant flags. */\n   if (type != 0)\n-    MEM_SET_IN_STRUCT_P (p->slot, AGGREGATE_TYPE_P (type));\n+    {\n+      RTX_UNCHANGING_P (p->slot) = TYPE_READONLY (type);\n+      MEM_VOLATILE_P (p->slot) = TYPE_VOLATILE (type);\n+      MEM_SET_IN_STRUCT_P (p->slot, AGGREGATE_TYPE_P (type));\n+    }\n \n   return p->slot;\n }\n@@ -1509,6 +1506,7 @@ put_reg_into_stack (function, reg, type, promoted_mode, decl_mode, volatile_p,\n /* Make sure that all refs to the variable, previously made\n    when it was a register, are fixed up to be valid again.\n    See function above for meaning of arguments.  */\n+\n static void\n schedule_fixup_var_refs (function, reg, type, promoted_mode, ht)\n      struct function *function;\n@@ -7453,6 +7451,7 @@ mark_temp_slot (t)\n       ggc_mark_rtx (t->slot);\n       ggc_mark_rtx (t->address);\n       ggc_mark_tree (t->rtl_expr);\n+      ggc_mark_tree (t->type);\n \n       t = t->next;\n     }"}, {"sha": "30e13408ec0910f7cca3a64507c0f616114845ab", "filename": "gcc/integrate.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1da68f560dd41ef12f15138fb1b1aff06067f4b7/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1da68f560dd41ef12f15138fb1b1aff06067f4b7/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=1da68f560dd41ef12f15138fb1b1aff06067f4b7", "patch": "@@ -716,14 +716,9 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n       if (GET_CODE (loc) == MEM && GET_CODE (XEXP (loc, 0)) == REG\n \t  && REGNO (XEXP (loc, 0)) > LAST_VIRTUAL_REGISTER)\n \t{\n-\t  rtx stack_slot\n-\t    = assign_stack_temp (TYPE_MODE (TREE_TYPE (arg)),\n-\t\t\t\t int_size_in_bytes (TREE_TYPE (arg)), 1);\n-\t  MEM_SET_IN_STRUCT_P (stack_slot,\n-\t\t\t       AGGREGATE_TYPE_P (TREE_TYPE (arg)));\n+\t  rtx stack_slot = assign_temp (TREE_TYPE (arg), 1, 1, 1);\n \n \t  store_expr (arg, stack_slot, 0);\n-\n \t  arg_vals[i] = XEXP (stack_slot, 0);\n \t  invisiref = 1;\n \t}"}, {"sha": "450b0da7c1af256b0f4a8f80ec94ac4f92f32f24", "filename": "gcc/stmt.c", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1da68f560dd41ef12f15138fb1b1aff06067f4b7/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1da68f560dd41ef12f15138fb1b1aff06067f4b7/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=1da68f560dd41ef12f15138fb1b1aff06067f4b7", "patch": "@@ -1757,7 +1757,10 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t\t   || GET_CODE (op) == CONCAT)\n \t    {\n \t      tree type = TREE_TYPE (TREE_VALUE (tail));\n-\t      rtx memloc = assign_temp (type, 1, 1, 1);\n+\t      tree qual_type = build_qualified_type (type,\n+\t\t\t\t\t\t     (TYPE_QUALS (type)\n+\t\t\t\t\t\t      | TYPE_QUAL_CONST));\n+\t      rtx memloc = assign_temp (qual_type, 1, 1, 1);\n \n \t      emit_move_insn (memloc, op);\n \t      op = memloc;\n@@ -3100,8 +3103,10 @@ expand_return (retval)\n     {\n       /* Calculate the return value into a temporary (usually a pseudo\n          reg).  */\n-      val = assign_temp (TREE_TYPE (DECL_RESULT (current_function_decl)),\n-\t\t\t 0, 0, 1);\n+      tree ot = TREE_TYPE (DECL_RESULT (current_function_decl));\n+      tree nt = build_qualified_type (ot, TYPE_QUALS (ot) | TYPE_QUAL_CONST);\n+\n+      val = assign_temp (nt, 0, 0, 1);\n       val = expand_expr (retval_rhs, val, GET_MODE (val), 0);\n       val = force_not_mem (val);\n       emit_queue ();\n@@ -3822,12 +3827,13 @@ expand_decl (decl)\n \n   if (type == error_mark_node)\n     DECL_RTL (decl) = gen_rtx_MEM (BLKmode, const0_rtx);\n+\n   else if (DECL_SIZE (decl) == 0)\n     /* Variable with incomplete type.  */\n     {\n       if (DECL_INITIAL (decl) == 0)\n \t/* Error message was already done; now avoid a crash.  */\n-\tDECL_RTL (decl) = assign_stack_temp (DECL_MODE (decl), 0, 1);\n+\tDECL_RTL (decl) = gen_rtx_MEM (BLKmode, const0_rtx);\n       else\n \t/* An initializer is going to decide the size of this array.\n \t   Until we know the size, represent its address with a reg.  */\n@@ -4735,18 +4741,16 @@ add_case_node (low, high, label, duplicate)\n \t}\n     }\n \n-  /* Add this label to the chain, and succeed.\n-     Copy LOW, HIGH so they are on temporary rather than momentary\n-     obstack and will thus survive till the end of the case statement.  */\n+  /* Add this label to the chain, and succeed.  */\n \n   r = (struct case_node *) xmalloc (sizeof (struct case_node));\n-  r->low = copy_node (low);\n+  r->low = low;\n \n   /* If the bounds are equal, turn this into the one-value case.  */\n   if (tree_int_cst_equal (low, high))\n     r->high = r->low;\n   else\n-    r->high = copy_node (high);\n+    r->high = high;\n \n   r->code_label = label;\n   expand_label (label);"}, {"sha": "33e921207e15058a73a1addf496dc7d21b0d86ff", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1da68f560dd41ef12f15138fb1b1aff06067f4b7/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1da68f560dd41ef12f15138fb1b1aff06067f4b7/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=1da68f560dd41ef12f15138fb1b1aff06067f4b7", "patch": "@@ -2623,6 +2623,10 @@ extern void rest_of_type_compilation PARAMS ((tree, int));\n /* In alias.c */\n extern void record_component_aliases\t\tPARAMS ((tree));\n extern HOST_WIDE_INT get_alias_set\t\tPARAMS ((tree));\n+extern int alias_sets_conflict_p\t\tPARAMS ((HOST_WIDE_INT,\n+\t\t\t\t\t\t\t HOST_WIDE_INT));\n+extern int readonly_fields_p\t\t\tPARAMS ((tree));\n+extern int objects_must_conflict_p\t\tPARAMS ((tree, tree));\n \n /* In c-common.c */\n extern HOST_WIDE_INT lang_get_alias_set\t\tPARAMS ((tree));"}]}