{"sha": "c8d8ed65a5366c075cce9ee64e871d815fd1f33d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzhkOGVkNjVhNTM2NmMwNzVjY2U5ZWU2NGU4NzFkODE1ZmQxZjMzZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-02-19T01:27:00Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-02-19T01:27:00Z"}, "message": "bitmap.c (bitmap_operation): Avoid using -1 for index since unsigned.\n\n\t* bitmap.c (bitmap_operation): Avoid using -1 for index since unsigned.\n\t* cppinit.c (new_pending_define): Add cast to avoid warning.\n\t* expmed.c (extract_bit_field): Likewise.\n\t* flow.c (enum reorder_skip_type): New type.\n\t(skip_insns_between_blcok): New it.\n\tRework to avoid warning about possibly undefined variable.\n\t* function.c (assign_parms): Make thisparm_boundary unsigned.\n\t* genrecog.c (write_switch): Cast XWINT result to int.\n\t* lcm.c: Many static fcns and vars now #ifdef OPTIMIZE_MODE_SWITCHING.\n\t* mips-tfile.c (init_file): Make two versions of FDR intializer:\n\tone for MIPS and one for Alpha.\n\t(get_tag, copy_object): Add casts to avoid warnings.\n\t* optabs.c (init_one_libfunc): Cast NAME to (char *).\n\t* reload.c (find_reloads): Make TYPE enum reload_type.\n\t* sbitmap.c (dump_sbitmap): J is unsigned; don't use \"1L\".\n\t* unroll.c (unroll_loop): Initialize UNROLL_NUMBER.\n\t* varasm.c (compare_constant_1): Add cast to avoid warning.\n\t* config/alpha/alpha.c (alpha_emit_xfloating_libcall): Cast FUNC\n\tto (char *).\n\t(alpha_expand_unaligned_load, alpha_expand_unaligned_store):\n \tCast switch operand of size to int.\n\t(alpha_expand_epilogue): Always initialize fp_offset and sa_reg.\n\t* config/alpha/alpha.h (INITIAL_ELIMINATION_OFFSET): Add abort\n\tin unhandled case.\n\nFrom-SVN: r32060", "tree": {"sha": "4e76f0295c3501797dbd329a63105f6a7c70f1e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e76f0295c3501797dbd329a63105f6a7c70f1e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c8d8ed65a5366c075cce9ee64e871d815fd1f33d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8d8ed65a5366c075cce9ee64e871d815fd1f33d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8d8ed65a5366c075cce9ee64e871d815fd1f33d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/comments", "author": null, "committer": null, "parents": [{"sha": "1f51a99218e6eb4214e6a40e9937a7cc419f1e95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f51a99218e6eb4214e6a40e9937a7cc419f1e95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f51a99218e6eb4214e6a40e9937a7cc419f1e95"}], "stats": {"total": 210, "additions": 152, "deletions": 58}, "files": [{"sha": "0be42ce45c88d3097f9ca20ca587ee365f2c475c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c8d8ed65a5366c075cce9ee64e871d815fd1f33d", "patch": "@@ -1,3 +1,30 @@\n+Fri Feb 18 20:08:57 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* bitmap.c (bitmap_operation): Avoid using -1 for index since unsigned.\n+\t* cppinit.c (new_pending_define): Add cast to avoid warning.\n+\t* expmed.c (extract_bit_field): Likewise.\n+\t* flow.c (enum reorder_skip_type): New type.\n+\t(skip_insns_between_blcok): New it.\n+\tRework to avoid warning about possibly undefined variable.\n+\t* function.c (assign_parms): Make thisparm_boundary unsigned.\n+\t* genrecog.c (write_switch): Cast XWINT result to int.\n+\t* lcm.c: Many static fcns and vars now #ifdef OPTIMIZE_MODE_SWITCHING.\n+\t* mips-tfile.c (init_file): Make two versions of FDR intializer:\n+\tone for MIPS and one for Alpha.\n+\t(get_tag, copy_object): Add casts to avoid warnings.\n+\t* optabs.c (init_one_libfunc): Cast NAME to (char *).\n+\t* reload.c (find_reloads): Make TYPE enum reload_type.\n+\t* sbitmap.c (dump_sbitmap): J is unsigned; don't use \"1L\".\n+\t* unroll.c (unroll_loop): Initialize UNROLL_NUMBER.\n+\t* varasm.c (compare_constant_1): Add cast to avoid warning.\n+\t* config/alpha/alpha.c (alpha_emit_xfloating_libcall): Cast FUNC\n+\tto (char *).\n+\t(alpha_expand_unaligned_load, alpha_expand_unaligned_store):\n+ \tCast switch operand of size to int.\n+\t(alpha_expand_epilogue): Always initialize fp_offset and sa_reg.\n+\t* config/alpha/alpha.h (INITIAL_ELIMINATION_OFFSET): Add abort\n+\tin unhandled case.\n+\n 2000-02-18  Nick Clifton  <nickc@cygnus.com>\n \n \t* config/arm/elf.h (ASM_OUTPUT_ALIGN): Do not generate"}, {"sha": "99b5f5a4e0e2c5cfc5f00d621d4bd8d45731bf02", "filename": "gcc/bitmap.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=c8d8ed65a5366c075cce9ee64e871d815fd1f33d", "patch": "@@ -395,10 +395,12 @@ bitmap_operation (to, from1, from2, operation)\n      bitmap from2;\n      enum bitmap_bits operation;\n {\n+#define HIGHEST_INDEX (unsigned int) ~0\n+\n   bitmap_element *from1_ptr = from1->first;\n   bitmap_element *from2_ptr = from2->first;\n-  unsigned int indx1 = (from1_ptr) ? from1_ptr->indx : -1;\n-  unsigned int indx2 = (from2_ptr) ? from2_ptr->indx : -1;\n+  unsigned int indx1 = (from1_ptr) ? from1_ptr->indx : HIGHEST_INDEX;\n+  unsigned int indx2 = (from2_ptr) ? from2_ptr->indx : HIGHEST_INDEX;\n   bitmap_element *to_ptr = to->first;\n   bitmap_element *from1_tmp;\n   bitmap_element *from2_tmp;\n@@ -449,25 +451,25 @@ bitmap_operation (to, from1, from2, operation)\n \t  from1_tmp = from1_ptr;\n \t  from2_tmp = from2_ptr;\n \t  from1_ptr = from1_ptr->next;\n-\t  indx1 = (from1_ptr) ? from1_ptr->indx : -1;\n+\t  indx1 = (from1_ptr) ? from1_ptr->indx : HIGHEST_INDEX;\n \t  from2_ptr = from2_ptr->next;\n-\t  indx2 = (from2_ptr) ? from2_ptr->indx : -1;\n+\t  indx2 = (from2_ptr) ? from2_ptr->indx : HIGHEST_INDEX;\n \t}\n       else if (indx1 < indx2)\n \t{\n \t  indx = indx1;\n \t  from1_tmp = from1_ptr;\n \t  from2_tmp = &bitmap_zero;\n \t  from1_ptr = from1_ptr->next;\n-\t  indx1 = (from1_ptr) ? from1_ptr->indx : -1;\n+\t  indx1 = (from1_ptr) ? from1_ptr->indx : HIGHEST_INDEX;\n \t}\n       else\n \t{\n \t  indx = indx2;\n \t  from1_tmp = &bitmap_zero;\n \t  from2_tmp = from2_ptr;\n \t  from2_ptr = from2_ptr->next;\n-\t  indx2 = (from2_ptr) ? from2_ptr->indx : -1;\n+\t  indx2 = (from2_ptr) ? from2_ptr->indx : HIGHEST_INDEX;\n \t}\n \n       /* Find the appropriate element from TO.  Begin by discarding"}, {"sha": "8ef62c8d8ce046dc09d074a081e9d496c153e285", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=c8d8ed65a5366c075cce9ee64e871d815fd1f33d", "patch": "@@ -1997,7 +1997,7 @@ alpha_emit_xfloating_libcall (func, target, operands, noperands, equiv)\n       abort ();\n     }\n \n-  tmp = gen_rtx_MEM (QImode, gen_rtx_SYMBOL_REF (Pmode, func));\n+  tmp = gen_rtx_MEM (QImode, gen_rtx_SYMBOL_REF (Pmode, (char *) func));\n   tmp = emit_call_insn (gen_call_value (reg, tmp, const0_rtx,\n \t\t\t\t\tconst0_rtx, const0_rtx));\n   CALL_INSN_FUNCTION_USAGE (tmp) = usage;\n@@ -2199,7 +2199,7 @@ alpha_expand_unaligned_load (tgt, mem, size, ofs, sign)\n     {\n       emit_move_insn (addr, plus_constant (XEXP (mem, 0), ofs));\n       emit_insn (gen_extxl (extl, meml, GEN_INT (size*8), addr));\n-      switch (size)\n+      switch ((int) size)\n \t{\n \tcase 2:\n \t  emit_insn (gen_extwh (exth, memh, addr));\n@@ -2262,7 +2262,7 @@ alpha_expand_unaligned_store (dst, src, size, ofs)\n       emit_insn (gen_insxh (insh, gen_lowpart (DImode, src),\n \t\t\t    GEN_INT (size*8), addr));\n \n-      switch (size)\n+      switch ((int) size)\n \t{\n \tcase 2:\n \t  emit_insn (gen_inswl (insl, gen_lowpart (HImode, src), addr));\n@@ -2278,7 +2278,7 @@ alpha_expand_unaligned_store (dst, src, size, ofs)\n \n   emit_insn (gen_mskxh (dsth, dsth, GEN_INT (size*8), addr));\n \n-  switch (size)\n+  switch ((int) size)\n     {\n     case 2:\n       emit_insn (gen_mskxl (dstl, dstl, GEN_INT (0xffff), addr));\n@@ -4579,6 +4579,8 @@ alpha_expand_epilogue ()\n \n   fp_is_frame_pointer = ((TARGET_OPEN_VMS && vms_is_stack_procedure)\n \t\t\t || (!TARGET_OPEN_VMS && frame_pointer_needed));\n+  fp_offset = 0;\n+  sa_reg = stack_pointer_rtx;\n \n   eh_ofs = cfun->machine->eh_epilogue_sp_ofs;\n   if (sa_size)\n@@ -4592,7 +4594,6 @@ alpha_expand_epilogue ()\n \t}\n \n       /* Cope with very large offsets to the register save area.  */\n-      sa_reg = stack_pointer_rtx;\n       if (reg_offset + sa_size > 0x8000)\n \t{\n \t  int low = ((reg_offset & 0xffff) ^ 0x8000) - 0x8000;"}, {"sha": "b1c25c091d1495de92e1e42e24bdaa39138c3a3f", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=c8d8ed65a5366c075cce9ee64e871d815fd1f33d", "patch": "@@ -965,6 +965,8 @@ extern int alpha_memory_latency;\n \t\t+ (ALPHA_ROUND (get_frame_size ()\t\t\t\\\n \t\t\t       + current_function_pretend_args_size)\t\\\n \t\t   - current_function_pretend_args_size));\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    abort ();\t\t\t\t\t\t\t\t\\\n }\n \n /* Define this if stack space is still allocated for a parameter passed"}, {"sha": "5e05511f0c43d692d962bd1da981819fadec216e", "filename": "gcc/cppinit.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=c8d8ed65a5366c075cce9ee64e871d815fd1f33d", "patch": "@@ -1058,7 +1058,7 @@ new_pending_define (opts, text)\n   struct pending_option *o = (struct pending_option *)\n     xmalloc (sizeof (struct pending_option));\n \n-  o->arg = text;\n+  o->arg = (char *) text;\n   o->next = NULL;\n   o->undef = 0;\n   APPEND (opts->pending, define, o);\n@@ -1067,6 +1067,7 @@ new_pending_define (opts, text)\n /* Handle one command-line option in (argc, argv).\n    Can be called multiple times, to handle multiple sets of options.\n    Returns number of strings consumed.  */\n+\n int\n cpp_handle_option (pfile, argc, argv)\n      cpp_reader *pfile;"}, {"sha": "736a7f2bdf77f133aad95c8e1b97be628449af7b", "filename": "gcc/expmed.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=c8d8ed65a5366c075cce9ee64e871d815fd1f33d", "patch": "@@ -1257,7 +1257,7 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \n \t\t  if (bestmode == VOIDmode\n \t\t      || (SLOW_UNALIGNED_ACCESS (bestmode, align)\n-\t\t\t  && GET_MODE_SIZE (bestmode) > align))\n+\t\t\t  && GET_MODE_SIZE (bestmode) > (int) align))\n \t\t    goto extzv_loses;\n \n \t\t  /* Compute offset as multiple of this unit,"}, {"sha": "c1ec515d8babfaf5b17363b42dd2bc9931ff2d06", "filename": "gcc/flow.c", "status": "modified", "additions": 35, "deletions": 27, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=c8d8ed65a5366c075cce9ee64e871d815fd1f33d", "patch": "@@ -7072,31 +7072,32 @@ typedef struct reorder_block_def {\n static int reorder_index;\n static basic_block reorder_last_visited;\n \n-#define REORDER_SKIP_BEFORE 0x1\n-#define REORDER_SKIP_AFTER 0x2\n-#define REORDER_SKIP_BLOCK_END 0x3\n+enum reorder_skip_type {REORDER_SKIP_BEFORE, REORDER_SKIP_AFTER,\n+\t\t\tREORDER_SKIP_BLOCK_END};\n \n /* Skip over insns BEFORE or AFTER BB which are typically associated with\n    basic block BB.  */\n \n static rtx\n skip_insns_between_block (bb, skip_type)\n      basic_block bb;\n-     int skip_type;\n+     enum reorder_skip_type skip_type;\n {\n   rtx insn, last_insn;\n \n   if (skip_type == REORDER_SKIP_BEFORE)\n     {\n       if (bb == ENTRY_BLOCK_PTR)\n \treturn 0;\n+\n       last_insn = bb->head;\n       for (insn = PREV_INSN (bb->head);\n \t   insn && insn != BASIC_BLOCK (bb->index - 1)->end;\n \t   last_insn = insn, insn = PREV_INSN (insn))\n \t{\n \t  if (NEXT_INSN (insn) != last_insn)\n \t    break;\n+\n \t  if (GET_CODE (insn) == NOTE\n \t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_END\n \t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK\n@@ -7106,8 +7107,8 @@ skip_insns_between_block (bb, skip_type)\n \t  break;\n \t}\n     }\n-  else if (skip_type == REORDER_SKIP_AFTER\n-\t   || skip_type == REORDER_SKIP_BLOCK_END)\n+\n+  else\n     {\n       last_insn = bb->end;\n \n@@ -7128,6 +7129,7 @@ skip_insns_between_block (bb, skip_type)\n \t\t  && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END\n \t\t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)))\n \t    continue;\n+\n \t  if (GET_CODE (insn) == CODE_LABEL\n \t      && GET_CODE (NEXT_INSN (insn)) == JUMP_INSN\n \t      && (GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_VEC\n@@ -7139,34 +7141,40 @@ skip_insns_between_block (bb, skip_type)\n \t    }\n \t  break;\n \t}\n-    }\n-  if (skip_type == REORDER_SKIP_BLOCK_END)\n-    {\n-      int found_block_end = 0;\n \n-      for (; insn; last_insn = insn, insn = NEXT_INSN (insn))\n+      if (skip_type == REORDER_SKIP_BLOCK_END)\n \t{\n-\t  if (bb->index + 1 != n_basic_blocks\n-\t      && insn == BASIC_BLOCK (bb->index + 1)->head)\n-\t    break;\n+\t  int found_block_end = 0;\n \n-\t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)\n+\t  for (; insn; last_insn = insn, insn = NEXT_INSN (insn))\n \t    {\n-\t      found_block_end = 1;\n-\t      continue;\n+\t      if (bb->index + 1 != n_basic_blocks\n+\t\t  && insn == BASIC_BLOCK (bb->index + 1)->head)\n+\t\tbreak;\n+\n+\t      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)\n+\t\t{\n+\t\t  found_block_end = 1;\n+\t\t  continue;\n+\t\t}\n+\n+\t      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_DELETED)\n+\t\tcontinue;\n+\n+\t      if (GET_CODE (insn) == NOTE\n+\t\t  && NOTE_LINE_NUMBER (insn) >= 0\n+\t\t  && NEXT_INSN (insn)\n+\t\t  && (NOTE_LINE_NUMBER (NEXT_INSN (insn))\n+\t\t      == NOTE_INSN_BLOCK_END))\n+\t\tcontinue;\n+\t      break;\n \t    }\n-\t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_DELETED)\n-\t    continue;\n-\t  if (GET_CODE (insn) == NOTE\n-\t      && NOTE_LINE_NUMBER (insn) >= 0\n-\t      && NEXT_INSN (insn)\n-\t      && NOTE_LINE_NUMBER (NEXT_INSN (insn)) == NOTE_INSN_BLOCK_END)\n-\t    continue;\n-\t  break;\n+\n+\t  if (! found_block_end)\n+\t    last_insn = 0;\n \t}\n-      if (! found_block_end)\n-\tlast_insn = 0;\n     }\n+\n   return last_insn;\n }\n "}, {"sha": "ad9e868e48eda9013c248be38dcf561852ce216c", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=c8d8ed65a5366c075cce9ee64e871d815fd1f33d", "patch": "@@ -4348,7 +4348,7 @@ assign_parms (fndecl)\n \t for its ultimate type, don't use that slot after entry.\n \t We'll make another stack slot, if we need one.  */\n       {\n-\tint thisparm_boundary\n+\tunsigned int thisparm_boundary\n \t  = FUNCTION_ARG_BOUNDARY (promoted_mode, passed_type);\n \n \tif (GET_MODE_ALIGNMENT (nominal_mode) > thisparm_boundary)"}, {"sha": "540a84a19b6fb58120bca2d24174ac0eafcf60ab", "filename": "gcc/genrecog.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=c8d8ed65a5366c075cce9ee64e871d815fd1f33d", "patch": "@@ -1785,19 +1785,21 @@ write_switch (start, depth)\n       switch (type)\n \t{\n \tcase DT_mode:\n-\t  printf(\"GET_MODE (x%d)\", depth);\n+\t  printf (\"GET_MODE (x%d)\", depth);\n \t  break;\n \tcase DT_veclen:\n-\t  printf(\"XVECLEN (x%d, 0)\", depth);\n+\t  printf (\"XVECLEN (x%d, 0)\", depth);\n \t  break;\n \tcase DT_elt_zero_int:\n-\t  printf(\"XINT (x%d, 0)\", depth);\n+\t  printf (\"XINT (x%d, 0)\", depth);\n \t  break;\n \tcase DT_elt_one_int:\n-\t  printf(\"XINT (x%d, 1)\", depth);\n+\t  printf (\"XINT (x%d, 1)\", depth);\n \t  break;\n \tcase DT_elt_zero_wide:\n-\t  printf(\"XWINT (x%d, 0)\", depth);\n+\t  /* Convert result of XWINT to int for portability since some C\n+\t     compilers won't do it and some will.  */\n+\t  printf (\"(int) XWINT (x%d, 0)\", depth);\n \t  break;\n \tdefault:\n \t  abort ();"}, {"sha": "b850984b2f04f84a079ccfc9e5ef604a112fd584", "filename": "gcc/lcm.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=c8d8ed65a5366c075cce9ee64e871d815fd1f33d", "patch": "@@ -842,6 +842,7 @@ struct bb_info\n \n /* These bitmaps are used for the LCM algorithm.  */\n \n+#ifdef OPTIMIZE_MODE_SWITCHING\n static sbitmap *antic;\n static sbitmap *transp;\n static sbitmap *comp;\n@@ -850,12 +851,16 @@ static sbitmap *insert;\n \n static struct seginfo * new_seginfo PARAMS ((int, rtx, int, HARD_REG_SET));;\n static void add_seginfo PARAMS ((struct bb_info *, struct seginfo *));\n-static void make_preds_opaque PARAMS ((basic_block, int));\n static void reg_dies PARAMS ((rtx, HARD_REG_SET));\n static void reg_becomes_live PARAMS ((rtx, rtx, void *));\n+static void make_preds_opaque PARAMS ((basic_block, int));\n+#endif\n+\f\n+#ifdef OPTIMIZE_MODE_SWITCHING\n \n /* This function will allocate a new BBINFO structure, initialized\n    with the FP_MODE, INSN, and basic block BB parameters.  */\n+\n static struct seginfo *\n new_seginfo (mode, insn, bb, regs_live)\n      int mode;\n@@ -876,6 +881,7 @@ new_seginfo (mode, insn, bb, regs_live)\n /* Add a seginfo element to the end of a list.  \n    HEAD is a pointer to the list beginning.\n    INFO is the structure to be linked in.  */\n+\n static void\n add_seginfo (head, info)\n      struct bb_info *head;\n@@ -899,6 +905,7 @@ add_seginfo (head, info)\n    denotes that a mode set is to be done on that edge.\n    J is the bit number in the bitmaps that corresponds to the entity that\n    we are currently handling mode-switching for.  */\n+\n static void\n make_preds_opaque (b, j)\n      basic_block b;\n@@ -917,6 +924,7 @@ make_preds_opaque (b, j)\n }\n \n /* Record in LIVE that register REG died.  */\n+\n static void\n reg_dies (reg, live)\n      rtx reg;\n@@ -938,6 +946,7 @@ reg_dies (reg, live)\n \n /* Record in LIVE that register REG became live.\n    This is called via note_stores.  */\n+\n static void\n reg_becomes_live (reg, setter, live)\n      rtx reg;\n@@ -961,6 +970,7 @@ reg_becomes_live (reg, setter, live)\n \tSET_HARD_REG_BIT (* (HARD_REG_SET *) live, regno);\n     }\n }\n+#endif\n \n /* Find all insns that need a particular mode\n    setting, and insert the necessary mode switches.  */"}, {"sha": "aaea9f4f425a3c0a8088885b383f779dca9cbe45", "filename": "gcc/mips-tfile.c", "status": "modified", "additions": 41, "deletions": 5, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2Fmips-tfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2Fmips-tfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmips-tfile.c?ref=c8d8ed65a5366c075cce9ee64e871d815fd1f33d", "patch": "@@ -1078,6 +1078,37 @@ typedef struct efdr {\n static efdr_t init_file = \n {\n   {\t\t\t/* FDR structure */\n+#ifdef __alpha\n+    0,\t\t\t/* adr:\t\tmemory address of beginning of file */\n+    0,\t\t\t/* cbLineOffset: byte offset from header for this file ln's */\n+    0,\t\t\t/* cbLine:\tsize of lines for this file */\n+    0,\t\t\t/* cbSs:\tnumber of bytes in the ss */\n+    0,\t\t\t/* rss:\t\tfile name (of source, if known) */\n+    0,\t\t\t/* issBase:\tfile's string space */\n+    0,\t\t\t/* isymBase:\tbeginning of symbols */\n+    0,\t\t\t/* csym:\tcount file's of symbols */\n+    0,\t\t\t/* ilineBase:\tfile's line symbols */\n+    0,\t\t\t/* cline:\tcount of file's line symbols */\n+    0,\t\t\t/* ioptBase:\tfile's optimization entries */\n+    0,\t\t\t/* copt:\tcount of file's optimization entries */\n+    0,\t\t\t/* ipdFirst:\tstart of procedures for this file */\n+    0,\t\t\t/* cpd:\t\tcount of procedures for this file */\n+    0,\t\t\t/* iauxBase:\tfile's auxiliary entries */\n+    0,\t\t\t/* caux:\tcount of file's auxiliary entries */\n+    0,\t\t\t/* rfdBase:\tindex into the file indirect table */\n+    0,\t\t\t/* crfd:\tcount file indirect entries */\n+    langC,\t\t/* lang:\tlanguage for this file */\n+    1,\t\t\t/* fMerge:\twhether this file can be merged */\n+    0,\t\t\t/* fReadin:\ttrue if read in (not just created) */\n+#ifdef HOST_WORDS_BIG_ENDIAN\n+    1,\t\t\t/* fBigendian:\tif 1, compiled on big endian machine */\n+#else\n+    0,\t\t\t/* fBigendian:\tif 1, compiled on big endian machine */\n+#endif\n+    0,\t\t\t/* fTrim:\twhether the symbol table was trimmed */\n+    GLEVEL_2,\t\t/* glevel:\tlevel this file was compiled with */\n+    0,\t\t\t/* reserved:\treserved for future use */\n+#else\n     0,\t\t\t/* adr:\t\tmemory address of beginning of file */\n     0,\t\t\t/* rss:\t\tfile name (of source, if known) */\n     0,\t\t\t/* issBase:\tfile's string space */\n@@ -1106,6 +1137,7 @@ static efdr_t init_file =\n     0,\t\t\t/* reserved:\treserved for future use */\n     0,\t\t\t/* cbLineOffset: byte offset from header for this file ln's */\n     0,\t\t\t/* cbLine:\tsize of lines for this file */\n+#endif\n   },\n \n   (FDR *) 0,\t\t/* orig_fdr:\toriginal file header pointer */\n@@ -2327,7 +2359,8 @@ get_tag (tag_start, tag_end_p1, indx, basic_type)\n   tag_ptr->same_name\t= hash_ptr->tag_ptr;\n   tag_ptr->basic_type\t= basic_type;\n   tag_ptr->indx\t\t= indx;\n-  tag_ptr->ifd\t\t= (indx == indexNil) ? -1 : cur_file_ptr->file_index;\n+  tag_ptr->ifd\t\t= (indx == indexNil\n+\t\t\t   ? (symint_t) -1 : cur_file_ptr->file_index);\n   tag_ptr->same_block\t= cur_tag_head->first_tag;\n \n   cur_tag_head->first_tag = tag_ptr;\n@@ -4621,8 +4654,10 @@ copy_object __proto((void))\n \t\t\t     (st_t) eptr->asym.st,\n \t\t\t     (sc_t) eptr->asym.sc,\n \t\t\t     eptr->asym.value,\n-\t\t\t     (symint_t) ((eptr->asym.index == indexNil) ? indexNil : 0),\n-\t\t\t     ((long) ifd < orig_sym_hdr.ifdMax) ? remap_file_number[ ifd ] : ifd);\n+\t\t\t     (eptr->asym.index == indexNil\n+\t\t\t      ? (symint_t) indexNil : 0),\n+\t\t\t     ((long) ifd < orig_sym_hdr.ifdMax\n+\t\t\t      ? remap_file_number[ifd] : (int) ifd));\n     }\n \n \n@@ -4774,8 +4809,9 @@ copy_object __proto((void))\n        remaining > 0;\n        remaining -= num_write)\n     {\n-      num_write =\n-\t(remaining <= (int) sizeof (buffer)) ? remaining : sizeof (buffer);\n+      num_write\n+\t= (remaining <= (int) sizeof (buffer))\n+\t  ? remaining : (int) sizeof (buffer);\n       sys_read = fread ((PTR_T) buffer, 1, num_write, obj_in_stream);\n       if (sys_read <= 0)\n \tpfatal_with_name (obj_in_name);"}, {"sha": "2898b49c870d1e8abc2c02ad33dfd7e3f30d8ba7", "filename": "gcc/optabs.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=c8d8ed65a5366c075cce9ee64e871d815fd1f33d", "patch": "@@ -4430,7 +4430,8 @@ init_one_libfunc (name)\n {\n   if (ggc_p)\n     name = ggc_alloc_string (name, -1);\n-  return gen_rtx_SYMBOL_REF (Pmode, name);\n+\n+  return gen_rtx_SYMBOL_REF (Pmode, (char *) name);\n }\n \n /* Mark ARG (which is really an OPTAB *) for GC.  */"}, {"sha": "0a51a28f8825a72dd1f1d3114ae906289c6b0a32", "filename": "gcc/reload.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=c8d8ed65a5366c075cce9ee64e871d815fd1f33d", "patch": "@@ -4037,7 +4037,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n       {\n \tfor (i = 0; i < n_reloads; i++)\n \t  {\n-\t    int first_num, type;\n+\t    int first_num;\n+\t    enum reload_type type;\n \n \t    switch (rld[i].when_needed)\n \t      {"}, {"sha": "9b0b4d12ac0536f466f4c4739f2aec7497f10e86", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=c8d8ed65a5366c075cce9ee64e871d815fd1f33d", "patch": "@@ -3173,6 +3173,7 @@ mark_not_eliminable (dest, x, data)\n    last call to set_initial_elim_offsets.  This is used to catch cases\n    where something illegal happened during reload_as_needed that could\n    cause incorrect code to be generated if we did not check for it.  */\n+\n static void\n verify_initial_elim_offsets ()\n {"}, {"sha": "335659d9b357514f6a66c66e8d210cc8ec2ce576", "filename": "gcc/sbitmap.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2Fsbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2Fsbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.c?ref=c8d8ed65a5366c075cce9ee64e871d815fd1f33d", "patch": "@@ -540,7 +540,8 @@ dump_sbitmap (file, bmap)\n      FILE *file;\n      sbitmap bmap;\n {\n-  int i,j,n;\n+  int i, n;\n+  unsigned int j;\n   int set_size = bmap->size;\n   int total_bits = bmap->n_bits;\n \n@@ -551,7 +552,8 @@ dump_sbitmap (file, bmap)\n \t{\n \t  if (n != 0 && n % 10 == 0)\n \t    fprintf (file, \" \");\n-\t  fprintf (file, \"%d\", (bmap->elms[i] & (1L << j)) != 0);\n+\t  fprintf (file, \"%d\",\n+\t\t   (bmap->elms[i] & ((SBITMAP_ELT_TYPE) 1 << j)) != 0);\n \t}\n     }\n   fprintf (file, \"\\n\");"}, {"sha": "115b92c8d7bd584539ede1e1fa3fe77333735db8", "filename": "gcc/unroll.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=c8d8ed65a5366c075cce9ee64e871d815fd1f33d", "patch": "@@ -234,7 +234,7 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n {\n   int i, j;\n   unsigned HOST_WIDE_INT temp;\n-  int unroll_number;\n+  int unroll_number = 1;\n   rtx copy_start, copy_end;\n   rtx insn, sequence, pattern, tem;\n   int max_labelno, max_insnno;"}, {"sha": "bfce0d8fef3e67782b0cb717f9d034efef0a8040", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8d8ed65a5366c075cce9ee64e871d815fd1f33d/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=c8d8ed65a5366c075cce9ee64e871d815fd1f33d", "patch": "@@ -2539,7 +2539,7 @@ compare_constant_1 (exp, p)\n       if (flag_writable_strings)\n \treturn 0;\n \n-      if (*p++ != TYPE_MODE (TREE_TYPE (exp)))\n+      if ((enum machine_mode) *p++ != TYPE_MODE (TREE_TYPE (exp)))\n \treturn 0;\n \n       strp = TREE_STRING_POINTER (exp);"}]}