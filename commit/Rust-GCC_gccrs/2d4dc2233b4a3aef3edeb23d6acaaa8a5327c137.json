{"sha": "2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQ0ZGMyMjMzYjRhM2FlZjNlZGViMjNkNmFjYWFhOGE1MzI3YzEzNw==", "commit": {"author": {"name": "Yuri Rumyantsev", "email": "ysrumyan@gmail.com", "date": "2016-02-02T09:46:26Z"}, "committer": {"name": "Ilya Enkovich", "email": "ienkovich@gcc.gnu.org", "date": "2016-02-02T09:46:26Z"}, "message": "re PR middle-end/68542 (10% 481.wrf performance regression)\n\ngcc/\n\n2016-02-02  Yuri Rumyantsev  <ysrumyan@gmail.com>\n\n\tPR middle-end/68542\n\t* config/i386/i386.c (ix86_expand_branch): Add support for conditional\n\tbranch with vector comparison.\n\t* config/i386/sse.md (VI48_AVX): New mode iterator.\n\t(define_expand \"cbranch<mode>4): Add support for conditional branch\n\twith vector comparison.\n\t* tree-vect-loop.c (optimize_mask_stores): New function.\n\t* tree-vect-stmts.c (vectorizable_mask_load_store): Initialize\n\thas_mask_store field of vect_info.\n\t* tree-vectorizer.c (vectorize_loops): Invoke optimaze_mask_stores for\n\tvectorized loops having masked stores after vec_info destroy.\n\t* tree-vectorizer.h (loop_vec_info): Add new has_mask_store field and\n\tcorrespondent macros.\n\t(optimize_mask_stores): Add prototype.\n\ngcc/testsuite\n\n2016-02-02  Yuri Rumyantsev  <ysrumyan@gmail.com>\n\n\tPR middle-end/68542\n\t* gcc.dg/vect/vect-mask-store-move-1.c: New test.\n\t* gcc.target/i386/avx2-vect-mask-store-move1.c: New test.\n\nFrom-SVN: r233068", "tree": {"sha": "406eb48f3246bc92d314640f0b58301e7c2c6257", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/406eb48f3246bc92d314640f0b58301e7c2c6257"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137/comments", "author": {"login": "ysrumyan", "id": 44425612, "node_id": "MDQ6VXNlcjQ0NDI1NjEy", "avatar_url": "https://avatars.githubusercontent.com/u/44425612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ysrumyan", "html_url": "https://github.com/ysrumyan", "followers_url": "https://api.github.com/users/ysrumyan/followers", "following_url": "https://api.github.com/users/ysrumyan/following{/other_user}", "gists_url": "https://api.github.com/users/ysrumyan/gists{/gist_id}", "starred_url": "https://api.github.com/users/ysrumyan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ysrumyan/subscriptions", "organizations_url": "https://api.github.com/users/ysrumyan/orgs", "repos_url": "https://api.github.com/users/ysrumyan/repos", "events_url": "https://api.github.com/users/ysrumyan/events{/privacy}", "received_events_url": "https://api.github.com/users/ysrumyan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "65c98fdec722720ae9b2a6765232fe4535e06d4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65c98fdec722720ae9b2a6765232fe4535e06d4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65c98fdec722720ae9b2a6765232fe4535e06d4e"}], "stats": {"total": 370, "additions": 370, "deletions": 0}, "files": [{"sha": "be546dcdba1826d35d0d244032c49b52a6a0aeb5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137", "patch": "@@ -1,3 +1,20 @@\n+2016-02-02  Yuri Rumyantsev  <ysrumyan@gmail.com>\n+\n+\tPR middle-end/68542\n+\t* config/i386/i386.c (ix86_expand_branch): Add support for conditional\n+\tbranch with vector comparison.\n+\t* config/i386/sse.md (VI48_AVX): New mode iterator.\n+\t(define_expand \"cbranch<mode>4): Add support for conditional branch\n+\twith vector comparison.\n+\t* tree-vect-loop.c (optimize_mask_stores): New function.\n+\t* tree-vect-stmts.c (vectorizable_mask_load_store): Initialize\n+\thas_mask_store field of vect_info.\n+\t* tree-vectorizer.c (vectorize_loops): Invoke optimaze_mask_stores for\n+\tvectorized loops having masked stores after vec_info destroy.\n+\t* tree-vectorizer.h (loop_vec_info): Add new has_mask_store field and\n+\tcorrespondent macros.\n+\t(optimize_mask_stores): Add prototype.\n+\n 2016-02-02  Alan Modra  <amodra@gmail.com>\n \n \tPR target/69548"}, {"sha": "af5cf5a8463693141b7211966cde379c01dece33", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137", "patch": "@@ -21684,6 +21684,30 @@ ix86_expand_branch (enum rtx_code code, rtx op0, rtx op1, rtx label)\n   machine_mode mode = GET_MODE (op0);\n   rtx tmp;\n \n+  /* Handle special case - vector comparsion with boolean result, transform\n+     it using ptest instruction.  */\n+  if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)\n+    {\n+      rtx flag = gen_rtx_REG (CCZmode, FLAGS_REG);\n+      machine_mode p_mode = GET_MODE_SIZE (mode) == 32 ? V4DImode : V2DImode;\n+\n+      gcc_assert (code == EQ || code == NE);\n+      /* Generate XOR since we can't check that one operand is zero vector.  */\n+      tmp = gen_reg_rtx (mode);\n+      emit_insn (gen_rtx_SET (tmp, gen_rtx_XOR (mode, op0, op1)));\n+      tmp = gen_lowpart (p_mode, tmp);\n+      emit_insn (gen_rtx_SET (gen_rtx_REG (CCmode, FLAGS_REG),\n+\t\t\t      gen_rtx_UNSPEC (CCmode,\n+\t\t\t\t\t      gen_rtvec (2, tmp, tmp),\n+\t\t\t\t\t      UNSPEC_PTEST)));\n+      tmp = gen_rtx_fmt_ee (code, VOIDmode, flag, const0_rtx);\n+      tmp = gen_rtx_IF_THEN_ELSE (VOIDmode, tmp,\n+\t\t\t\t  gen_rtx_LABEL_REF (VOIDmode, label),\n+\t\t\t\t  pc_rtx);\n+      emit_jump_insn (gen_rtx_SET (pc_rtx, tmp));\n+      return;\n+    }\n+\n   switch (mode)\n     {\n     case SFmode:"}, {"sha": "7f89679331c9e04f731384d92d65589a2c37613d", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137", "patch": "@@ -305,6 +305,10 @@\n    (V8SI \"TARGET_AVX\") (V4DI \"TARGET_AVX\")\n    (V8SF \"TARGET_AVX\") (V4DF\"TARGET_AVX\")])\n \n+(define_mode_iterator VI48_AVX\n+ [V4SI V2DI\n+  (V8SI \"TARGET_AVX\") (V4DI \"TARGET_AVX\")])\n+\n (define_mode_iterator VI8\n   [(V8DI \"TARGET_AVX512F\") (V4DI \"TARGET_AVX\") V2DI])\n \n@@ -18225,6 +18229,23 @@\n \t  (match_operand:<avx512fmaskmode> 2 \"register_operand\")))]\n   \"TARGET_AVX512BW\")\n \n+(define_expand \"cbranch<mode>4\"\n+  [(set (reg:CC FLAGS_REG)\n+\t(compare:CC (match_operand:VI48_AVX 1 \"register_operand\")\n+\t\t    (match_operand:VI48_AVX 2 \"nonimmediate_operand\")))\n+   (set (pc) (if_then_else\n+\t       (match_operator 0 \"bt_comparison_operator\"\n+\t\t[(reg:CC FLAGS_REG) (const_int 0)])\n+\t       (label_ref (match_operand 3))\n+\t       (pc)))]\n+  \"TARGET_SSE4_1\"\n+{\n+  ix86_expand_branch (GET_CODE (operands[0]),\n+\t\t      operands[1], operands[2], operands[3]);\n+  DONE;\n+})\n+\n+\n (define_insn_and_split \"avx_<castmode><avxsizesuffix>_<castmode>\"\n   [(set (match_operand:AVX256MODE2P 0 \"nonimmediate_operand\" \"=x,m\")\n \t(unspec:AVX256MODE2P"}, {"sha": "7f348ae05fcb1ade5a389efd72e08f97e44dbab4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137", "patch": "@@ -1,3 +1,9 @@\n+2016-02-02  Yuri Rumyantsev  <ysrumyan@gmail.com>\n+\n+\tPR middle-end/68542\n+\t* gcc.dg/vect/vect-mask-store-move-1.c: New test.\n+\t* gcc.target/i386/avx2-vect-mask-store-move1.c: New test.\n+\n 2016-02-02  Alan Modra  <amodra@gmail.com>\n \n \tPR target/69548"}, {"sha": "e575f6dd6ccc458104ff0069c460ae790bcc794e", "filename": "gcc/testsuite/gcc.dg/vect/vect-mask-store-move-1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-mask-store-move-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-mask-store-move-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-mask-store-move-1.c?ref=2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3\" } */\n+/* { dg-additional-options \"-mavx2\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+#define N 256\n+int p1[N], p2[N], p3[N];\n+int c[N];\n+void foo (int n)\n+{\n+  int i;\n+  for (i=0; i<n; i++)\n+    if (c[i])\n+      {\n+\tp1[i] += 1;\n+\tp2[i] = p3[i] +2;\n+      }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Move stmt to created bb\" 6 \"vect\" } } */"}, {"sha": "2a105601c7107f4411a6466082c11d9286396d9b", "filename": "gcc/testsuite/gcc.target/i386/avx2-vect-mask-store-move1.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vect-mask-store-move1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vect-mask-store-move1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vect-mask-store-move1.c?ref=2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137", "patch": "@@ -0,0 +1,79 @@\n+/* { dg-options \"-O3 -mavx2 -fdump-tree-vect-details\" } */\n+/* { dg-require-effective-target avx2 } */\n+\n+#include \"avx2-check.h\"\n+#define N 32\n+int *p1, *p2, *p3;\n+int c[N];\n+int p1ref[N], p2ref[N];\n+\n+__attribute__((noinline, noclone)) void foo (int n)\n+{\n+  int i;\n+  for (i=0; i<n; i++)\n+    if (c[i])\n+      {\n+\tp1[i] += 1;\n+\tp2[i] = p3[i] +2;\n+      }\n+}\n+\n+void init ()\n+{\n+  p1ref[0]=1; p2ref[0]=2;\n+  p1ref[1]=3; p2ref[1]=5;\n+  p1ref[2]=5; p2ref[2]=8;\n+  p1ref[3]=7; p2ref[3]=11;\n+  p1ref[4]=9; p2ref[4]=14;\n+  p1ref[5]=11; p2ref[5]=17;\n+  p1ref[6]=13; p2ref[6]=20;\n+  p1ref[7]=15; p2ref[7]=23;\n+  p1ref[8]=16; p2ref[8]=8;\n+  p1ref[9]=18; p2ref[9]=9;\n+  p1ref[10]=20; p2ref[10]=10;\n+  p1ref[11]=22; p2ref[11]=11;\n+  p1ref[12]=24; p2ref[12]=12;\n+  p1ref[13]=26; p2ref[13]=13;\n+  p1ref[14]=28; p2ref[14]=14;\n+  p1ref[15]=30; p2ref[15]=15;\n+  p1ref[16]=33; p2ref[16]=50;\n+  p1ref[17]=35; p2ref[17]=53;\n+  p1ref[18]=37; p2ref[18]=56;\n+  p1ref[19]=39; p2ref[19]=59;\n+  p1ref[20]=41; p2ref[20]=62;\n+  p1ref[21]=43; p2ref[21]=65;\n+  p1ref[22]=45; p2ref[22]=68;\n+  p1ref[23]=47; p2ref[23]=71;\n+  p1ref[24]=48; p2ref[24]=24;\n+  p1ref[25]=50; p2ref[25]=25;\n+  p1ref[26]=52; p2ref[26]=26;\n+  p1ref[27]=54; p2ref[27]=27;\n+  p1ref[28]=56; p2ref[28]=28;\n+  p1ref[29]=58; p2ref[29]=29;\n+  p1ref[30]=60; p2ref[30]=30;\n+  p1ref[31]=62; p2ref[31]=31;\n+}\n+\n+static void\n+avx2_test (void)\n+{\n+  int * P = malloc (N * 3 * sizeof (int));\n+  int i;\n+\n+  p1 = &P[0];\n+  p2 = &P[N];\n+  p3 = &P[2 * N];\n+  for (i=0; i<N; i++) {\n+    p1[i] = i + i;\n+    p3[i] = i * 3;\n+    p2[i] = i;\n+    c[i] = (i >> 3) & 1? 0: 1;\n+  }\n+  init ();\n+  foo (N);\n+  for (i=0; i<N;i++)\n+    if (p1[i] != p1ref[i] || p2[i] != p2ref[i])\n+      abort ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Move stmt to created bb\" 6 \"vect\" } } */"}, {"sha": "976e1923a4ce38af6161dc9742b2115a8580939d", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137", "patch": "@@ -6938,3 +6938,195 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n     vect_free_slp_instance (instance);\n   LOOP_VINFO_SLP_INSTANCES (loop_vinfo).release ();\n }\n+\n+/* The code below is trying to perform simple optimization - revert\n+   if-conversion for masked stores, i.e. if the mask of a store is zero\n+   do not perform it and all stored value producers also if possible.\n+   For example,\n+     for (i=0; i<n; i++)\n+       if (c[i])\n+\t{\n+\t  p1[i] += 1;\n+\t  p2[i] = p3[i] +2;\n+\t}\n+   this transformation will produce the following semi-hammock:\n+\n+   if (!mask__ifc__42.18_165 == { 0, 0, 0, 0, 0, 0, 0, 0 })\n+     {\n+       vect__11.19_170 = MASK_LOAD (vectp_p1.20_168, 0B, mask__ifc__42.18_165);\n+       vect__12.22_172 = vect__11.19_170 + vect_cst__171;\n+       MASK_STORE (vectp_p1.23_175, 0B, mask__ifc__42.18_165, vect__12.22_172);\n+       vect__18.25_182 = MASK_LOAD (vectp_p3.26_180, 0B, mask__ifc__42.18_165);\n+       vect__19.28_184 = vect__18.25_182 + vect_cst__183;\n+       MASK_STORE (vectp_p2.29_187, 0B, mask__ifc__42.18_165, vect__19.28_184);\n+     }\n+*/\n+\n+void\n+optimize_mask_stores (struct loop *loop)\n+{\n+  basic_block *bbs = get_loop_body (loop);\n+  unsigned nbbs = loop->num_nodes;\n+  unsigned i;\n+  basic_block bb;\n+  gimple_stmt_iterator gsi;\n+  gimple *stmt, *stmt1 = NULL;\n+  auto_vec<gimple *> worklist;\n+\n+  vect_location = find_loop_location (loop);\n+  /* Pick up all masked stores in loop if any.  */\n+  for (i = 0; i < nbbs; i++)\n+    {\n+      bb = bbs[i];\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n+\t{\n+\t  stmt = gsi_stmt (gsi);\n+\t  if (is_gimple_call (stmt)\n+\t      && gimple_call_internal_p (stmt)\n+\t      && gimple_call_internal_fn (stmt) == IFN_MASK_STORE)\n+\t    worklist.safe_push (stmt);\n+\t}\n+    }\n+\n+  free (bbs);\n+  if (worklist.is_empty ())\n+    return;\n+\n+  /* Loop has masked stores.  */\n+  while (!worklist.is_empty ())\n+    {\n+      gimple *last, *last_store;\n+      edge e, efalse;\n+      tree mask;\n+      basic_block store_bb, join_bb;\n+      gimple_stmt_iterator gsi_to;\n+      tree vdef, new_vdef;\n+      gphi *phi;\n+      tree vectype;\n+      tree zero;\n+\n+      last = worklist.pop ();\n+      mask = gimple_call_arg (last, 2);\n+      bb = gimple_bb (last);\n+      /* Create new bb.  */\n+      e = split_block (bb, last);\n+      join_bb = e->dest;\n+      store_bb = create_empty_bb (bb);\n+      add_bb_to_loop (store_bb, loop);\n+      e->flags = EDGE_TRUE_VALUE;\n+      efalse = make_edge (bb, store_bb, EDGE_FALSE_VALUE);\n+      /* Put STORE_BB to likely part.  */\n+      efalse->probability = PROB_UNLIKELY;\n+      store_bb->frequency = PROB_ALWAYS - EDGE_FREQUENCY (efalse);\n+      make_edge (store_bb, join_bb, EDGE_FALLTHRU);\n+      if (dom_info_available_p (CDI_DOMINATORS))\n+\tset_immediate_dominator (CDI_DOMINATORS, store_bb, bb);\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"Create new block %d to sink mask stores.\",\n+\t\t\t store_bb->index);\n+      /* Create vector comparison with boolean result.  */\n+      vectype = TREE_TYPE (mask);\n+      zero = build_zero_cst (vectype);\n+      stmt = gimple_build_cond (EQ_EXPR, mask, zero, NULL_TREE, NULL_TREE);\n+      gsi = gsi_last_bb (bb);\n+      gsi_insert_after (&gsi, stmt, GSI_SAME_STMT);\n+      /* Create new PHI node for vdef of the last masked store:\n+\t .MEM_2 = VDEF <.MEM_1>\n+\t will be converted to\n+\t .MEM.3 = VDEF <.MEM_1>\n+\t and new PHI node will be created in join bb\n+\t .MEM_2 = PHI <.MEM_1, .MEM_3>\n+      */\n+      vdef = gimple_vdef (last);\n+      new_vdef = make_ssa_name (gimple_vop (cfun), last);\n+      gimple_set_vdef (last, new_vdef);\n+      phi = create_phi_node (vdef, join_bb);\n+      add_phi_arg (phi, new_vdef, EDGE_SUCC (store_bb, 0), UNKNOWN_LOCATION);\n+\n+      /* Put all masked stores with the same mask to STORE_BB if possible.  */\n+      while (true)\n+\t{\n+\t  gimple_stmt_iterator gsi_from;\n+\t  /* Move masked store to STORE_BB.  */\n+\t  last_store = last;\n+\t  gsi = gsi_for_stmt (last);\n+\t  gsi_from = gsi;\n+\t  /* Shift GSI to the previous stmt for further traversal.  */\n+\t  gsi_prev (&gsi);\n+\t  gsi_to = gsi_start_bb (store_bb);\n+\t  gsi_move_before (&gsi_from, &gsi_to);\n+\t  /* Setup GSI_TO to the non-empty block start.  */\n+\t  gsi_to = gsi_start_bb (store_bb);\n+\t  if (dump_enabled_p ())\n+\t    {\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t       \"Move stmt to created bb\\n\");\n+\t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, last, 0);\n+\t    }\n+\t    /* Move all stored value producers if possible.  */\n+\t    while (!gsi_end_p (gsi))\n+\t      {\n+\t\ttree lhs;\n+\t\timm_use_iterator imm_iter;\n+\t\tuse_operand_p use_p;\n+\t\tbool res;\n+\t\tstmt1 = gsi_stmt (gsi);\n+\t\t/* Do not consider statements writing to memory.  */\n+\t\tif (gimple_vdef (stmt1))\n+\t\t  break;\n+\t\tgsi_from = gsi;\n+\t\tgsi_prev (&gsi);\n+\t\tlhs = gimple_get_lhs (stmt1);\n+\t\tif (!lhs)\n+\t\t  break;\n+\n+\t\t/* LHS of vectorized stmt must be SSA_NAME.  */\n+\t\tif (TREE_CODE (lhs) != SSA_NAME)\n+\t\t  break;\n+\n+\t\t/* Skip scalar statements.  */\n+\t\tif (!VECTOR_TYPE_P (TREE_TYPE (lhs)))\n+\t\t  continue;\n+\n+\t\t/* Check that LHS does not have uses outside of STORE_BB.  */\n+\t\tres = true;\n+\t\tFOR_EACH_IMM_USE_FAST (use_p, imm_iter, lhs)\n+\t\t  {\n+\t\t    gimple *use_stmt;\n+\t\t    use_stmt = USE_STMT (use_p);\n+\t\t    if (gimple_bb (use_stmt) != store_bb)\n+\t\t      {\n+\t\t\tres = false;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t\tif (!res)\n+\t\t  break;\n+\n+\t\tif (gimple_vuse (stmt1)\n+\t\t    && gimple_vuse (stmt1) != gimple_vuse (last_store))\n+\t\t  break;\n+\n+\t\t/* Can move STMT1 to STORE_BB.  */\n+\t\tif (dump_enabled_p ())\n+\t\t  {\n+\t\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t     \"Move stmt to created bb\\n\");\n+\t\t    dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt1, 0);\n+\t\t  }\n+\t\tgsi_move_before (&gsi_from, &gsi_to);\n+\t\t/* Shift GSI_TO for further insertion.  */\n+\t\tgsi_prev (&gsi_to);\n+\t      }\n+\t    /* Put other masked stores with the same mask to STORE_BB.  */\n+\t    if (worklist.is_empty ()\n+\t\t|| gimple_call_arg (worklist.last (), 2) != mask\n+\t\t|| worklist.last () != stmt1)\n+\t      break;\n+\t    last = worklist.pop ();\n+\t}\n+      add_phi_arg (phi, gimple_vuse (last_store), e, UNKNOWN_LOCATION);\n+    }\n+}"}, {"sha": "1aade9e650c45a12a78724b931befd2f155b3e6d", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137", "patch": "@@ -2023,6 +2023,7 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n     {\n       tree vec_rhs = NULL_TREE, vec_mask = NULL_TREE;\n       prev_stmt_info = NULL;\n+      LOOP_VINFO_HAS_MASK_STORE (loop_vinfo) = true;\n       for (i = 0; i < ncopies; i++)\n \t{\n \t  unsigned align, misalign;"}, {"sha": "2b25b4503ac3323f360b3245645b0e0b4ba38e17", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137", "patch": "@@ -604,12 +604,18 @@ vectorize_loops (void)\n   for (i = 1; i < vect_loops_num; i++)\n     {\n       loop_vec_info loop_vinfo;\n+      bool has_mask_store;\n \n       loop = get_loop (cfun, i);\n       if (!loop)\n \tcontinue;\n       loop_vinfo = (loop_vec_info) loop->aux;\n+      has_mask_store = false;\n+      if (loop_vinfo)\n+\thas_mask_store = LOOP_VINFO_HAS_MASK_STORE (loop_vinfo);\n       destroy_loop_vec_info (loop_vinfo, true);\n+      if (has_mask_store)\n+\toptimize_mask_stores (loop);\n       loop->aux = NULL;\n     }\n "}, {"sha": "bd1d55a7fbed7298cae008ede531c8e786cbe5e3", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=2d4dc2233b4a3aef3edeb23d6acaaa8a5327c137", "patch": "@@ -333,6 +333,9 @@ typedef struct _loop_vec_info : public vec_info {\n      loop version without if-conversion.  */\n   struct loop *scalar_loop;\n \n+  /* Mark loops having masked stores.  */\n+  bool has_mask_store;\n+\n } *loop_vec_info;\n \n /* Access Functions.  */\n@@ -368,6 +371,7 @@ typedef struct _loop_vec_info : public vec_info {\n #define LOOP_VINFO_PEELING_FOR_NITER(L)    (L)->peeling_for_niter\n #define LOOP_VINFO_NO_DATA_DEPENDENCIES(L) (L)->no_data_dependencies\n #define LOOP_VINFO_SCALAR_LOOP(L)\t   (L)->scalar_loop\n+#define LOOP_VINFO_HAS_MASK_STORE(L)       (L)->has_mask_store\n #define LOOP_VINFO_SCALAR_ITERATION_COST(L) (L)->scalar_cost_vec\n #define LOOP_VINFO_SINGLE_SCALAR_ITERATION_COST(L) (L)->single_scalar_iteration_cost\n \n@@ -1013,6 +1017,7 @@ extern void vect_get_vec_defs (tree, tree, gimple *, vec<tree> *,\n \t\t\t       vec<tree> *, slp_tree, int);\n extern tree vect_gen_perm_mask_any (tree, const unsigned char *);\n extern tree vect_gen_perm_mask_checked (tree, const unsigned char *);\n+extern void optimize_mask_stores (struct loop*);\n \n /* In tree-vect-data-refs.c.  */\n extern bool vect_can_force_dr_alignment_p (const_tree, unsigned int);"}]}