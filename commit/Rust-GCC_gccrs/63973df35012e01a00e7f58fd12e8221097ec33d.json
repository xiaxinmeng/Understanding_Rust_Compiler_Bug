{"sha": "63973df35012e01a00e7f58fd12e8221097ec33d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM5NzNkZjM1MDEyZTAxYTAwZTdmNThmZDEyZTgyMjEwOTdlYzMzZA==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.co.uk", "date": "2003-03-04T07:00:39Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2003-03-04T07:00:39Z"}, "message": "Makefile.in: Update.\n\n\t* Makefile.in: Update.\n\t* c-common.c (flag_no_line_commands, flag_no_output,\n\tflag_dump_macros, flag_dump_includes): New.\n\t* c-common.h (flag_no_line_commands, flag_no_output,\n\tflag_dump_macros, flag_dump_includes, preprocess_file): New.\n\t(init_c_lex): Update prototype.\n\t* c-lex.c (init_c_lex): Update prototype; move some code to\n\tc_common_init.\n\t* c-opts.c (preprocess_file): Subsume into c_common_init.\n\t(c_common_decode_option): Update flags.\n\t(c_common_init): Move code from preprocess_file and init_c_lex.\n\t(sanitize_cpp_opts): Update.\n\t* c-ppoutput.c: New, cppmain.c almost verbatim.\n\t* cpphash.h (struct printer): Remove.\n\t(struct cpp_reader): Remove print.\n\t* cpplib.h (dump_none, dump_only, dump_names, dump_definitions,\n\tcpp_preprocess_file): Remove.\n\t(struct cpp_options): Remove no_output, no_line_commands, dump_macros\n\tand dump_includes.\n\t* cppmain.c: Remove.\n\t* doc/passes.texi: Update.\n\nFrom-SVN: r63773", "tree": {"sha": "6d2189352e8a28a8545db3e74436f2c90de22536", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d2189352e8a28a8545db3e74436f2c90de22536"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63973df35012e01a00e7f58fd12e8221097ec33d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63973df35012e01a00e7f58fd12e8221097ec33d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63973df35012e01a00e7f58fd12e8221097ec33d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63973df35012e01a00e7f58fd12e8221097ec33d/comments", "author": {"login": "neilb-xx", "id": 160762, "node_id": "MDQ6VXNlcjE2MDc2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/160762?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neilb-xx", "html_url": "https://github.com/neilb-xx", "followers_url": "https://api.github.com/users/neilb-xx/followers", "following_url": "https://api.github.com/users/neilb-xx/following{/other_user}", "gists_url": "https://api.github.com/users/neilb-xx/gists{/gist_id}", "starred_url": "https://api.github.com/users/neilb-xx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neilb-xx/subscriptions", "organizations_url": "https://api.github.com/users/neilb-xx/orgs", "repos_url": "https://api.github.com/users/neilb-xx/repos", "events_url": "https://api.github.com/users/neilb-xx/events{/privacy}", "received_events_url": "https://api.github.com/users/neilb-xx/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "95f3f59efde3d3138d216aca9d00913cb4c1a002", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95f3f59efde3d3138d216aca9d00913cb4c1a002", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95f3f59efde3d3138d216aca9d00913cb4c1a002"}], "stats": {"total": 445, "additions": 229, "deletions": 216}, "files": [{"sha": "a5570d9cc3554950d877bcd337c49ce1900ab0d4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63973df35012e01a00e7f58fd12e8221097ec33d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63973df35012e01a00e7f58fd12e8221097ec33d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=63973df35012e01a00e7f58fd12e8221097ec33d", "patch": "@@ -1,3 +1,27 @@\n+2003-03-04  Neil Booth  <neil@daikokuya.co.uk>\n+\n+\t* Makefile.in: Update.\n+\t* c-common.c (flag_no_line_commands, flag_no_output,\n+\tflag_dump_macros, flag_dump_includes): New.\n+\t* c-common.h (flag_no_line_commands, flag_no_output,\n+\tflag_dump_macros, flag_dump_includes, preprocess_file): New.\n+\t(init_c_lex): Update prototype.\n+\t* c-lex.c (init_c_lex): Update prototype; move some code to\n+\tc_common_init.\n+\t* c-opts.c (preprocess_file): Subsume into c_common_init.\n+\t(c_common_decode_option): Update flags.\n+\t(c_common_init): Move code from preprocess_file and init_c_lex.\n+\t(sanitize_cpp_opts): Update.\n+\t* c-ppoutput.c: New, cppmain.c almost verbatim.\n+\t* cpphash.h (struct printer): Remove.\n+\t(struct cpp_reader): Remove print.\n+\t* cpplib.h (dump_none, dump_only, dump_names, dump_definitions,\n+\tcpp_preprocess_file): Remove.\n+\t(struct cpp_options): Remove no_output, no_line_commands, dump_macros\n+\tand dump_includes.\n+\t* cppmain.c: Remove.\n+\t* doc/passes.texi: Update.\n+\n 2003-03-04  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \t* function.c (STACK_ALIGNMENT_NEEDED): New macro.  Default to 1."}, {"sha": "c48d619077cd2ffd86dc2cdbd1ae34c0a634251b", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63973df35012e01a00e7f58fd12e8221097ec33d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63973df35012e01a00e7f58fd12e8221097ec33d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=63973df35012e01a00e7f58fd12e8221097ec33d", "patch": "@@ -759,7 +759,7 @@ CXX_TARGET_OBJS=@cxx_target_objs@\n # Language-specific object files for C and Objective C.\n C_AND_OBJC_OBJS = attribs.o c-errors.o c-lex.o c-pragma.o c-decl.o c-typeck.o \\\n   c-convert.o c-aux-info.o c-common.o c-opts.o c-format.o c-semantics.o \\\n-  c-incpath.o cppdefault.o \\\n+  c-incpath.o cppdefault.o c-ppoutput.o \\\n   c-objc-common.o c-dump.o c-pch.o libcpp.a $(C_TARGET_OBJS)\n \n # Language-specific object files for C.\n@@ -1234,6 +1234,8 @@ c-lex.o : c-lex.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n     $(RTL_H) debug.h $(C_TREE_H) c-common.h real.h c-incpath.h cppdefault.h \\\n     c-pragma.h input.h intl.h flags.h toplev.h output.h \\\n     mbchar.h $(CPPLIB_H) $(EXPR_H) $(TM_P_H)\n+c-ppoutput.o : c-ppoutput.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+    c-common.h $(TREE_H) $(CPPLIB_H) cpphash.h $(TM_P_H)\n c-objc-common.o : c-objc-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n     $(C_TREE_H) $(RTL_H) insn-config.h integrate.h $(EXPR_H) $(C_TREE_H) \\\n     flags.h toplev.h tree-inline.h diagnostic.h integrate.h $(VARRAY_H) \\\n@@ -2275,7 +2277,7 @@ PREPROCESSOR_DEFINES = \\\n   @TARGET_SYSTEM_ROOT_DEFINE@\n \n LIBCPP_OBJS =\tcpplib.o cpplex.o cppmacro.o cppexp.o cppfiles.o cpptrad.o \\\n-\t\tcpphash.o cpperror.o cppinit.o cppmain.o \\\n+\t\tcpphash.o cpperror.o cppinit.o \\\n \t\thashtable.o line-map.o mkdeps.o prefix.o mbchar.o cpppch.o\n \n LIBCPP_DEPS =\t$(CPPLIB_H) cpphash.h line-map.h hashtable.h intl.h \\\n@@ -2288,8 +2290,6 @@ libcpp.a: $(LIBCPP_OBJS)\n \t$(AR) $(AR_FLAGS) libcpp.a $(LIBCPP_OBJS)\n \t-$(RANLIB) libcpp.a\n \n-cppmain.o:  cppmain.c  $(LIBCPP_DEPS)\n-\n cpperror.o: cpperror.c $(LIBCPP_DEPS)\n cppexp.o:   cppexp.c   $(LIBCPP_DEPS)\n cpplex.o:   cpplex.c   $(LIBCPP_DEPS) mbchar.h"}, {"sha": "65f97992fc855b24c84b6073b140371de9481651", "filename": "gcc/c-common.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63973df35012e01a00e7f58fd12e8221097ec33d/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63973df35012e01a00e7f58fd12e8221097ec33d/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=63973df35012e01a00e7f58fd12e8221097ec33d", "patch": "@@ -198,8 +198,26 @@ int allow_pch = 1;\n /* Switches common to the C front ends.  */\n \n /* Nonzero if prepreprocessing only.  */\n+\n int flag_preprocess_only;\n \n+/* Nonzero means don't output line number information.  */\n+\n+char flag_no_line_commands;\n+\n+/* Nonzero causes -E output not to be done, but directives such as\n+   #define that have side effects are still obeyed.  */\n+\n+char flag_no_output;\n+\n+/* Nonzero means dump macros in some fashion.  */\n+\n+char flag_dump_macros;\n+\n+/* Nonzero means pass #include lines through to the output.  */\n+\n+char flag_dump_includes;\n+\n /* The file name to which we should write a precompiled header, or\n    NULL if no header will be written in this compile.  */\n "}, {"sha": "fb0b6c7364d27a0c4fbca711bdbaa6f26c99caeb", "filename": "gcc/c-common.h", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63973df35012e01a00e7f58fd12e8221097ec33d/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63973df35012e01a00e7f58fd12e8221097ec33d/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=63973df35012e01a00e7f58fd12e8221097ec33d", "patch": "@@ -370,6 +370,24 @@ extern int allow_pch;\n \n extern int flag_preprocess_only;\n \n+/* Nonzero means don't output line number information.  */\n+\n+extern char flag_no_line_commands;\n+\n+/* Nonzero causes -E output not to be done, but directives such as\n+   #define that have side effects are still obeyed.  */\n+\n+extern char flag_no_output;\n+\n+/* Nonzero means dump macros in some fashion; contains the 'D', 'M' or\n+   'N' of the command line switch.  */\n+\n+extern char flag_dump_macros;\n+\n+/* Nonzero means pass #include lines through to the output.  */\n+\n+extern char flag_dump_includes;\n+\n /* The file name to which we should write a precompiled header, or\n    NULL if no header will be written in this compile.  */\n \n@@ -1243,7 +1261,7 @@ extern int c_staticp                            PARAMS ((tree));\n \n extern int c_common_unsafe_for_reeval\t\tPARAMS ((tree));\n \n-extern const char *init_c_lex\t\t\tPARAMS ((const char *));\n+extern void init_c_lex\t\t\t\tPARAMS ((void));\n \n extern void cb_register_builtins\t\tPARAMS ((cpp_reader *));\n \n@@ -1274,5 +1292,8 @@ extern void c_common_read_pch\t\t\tPARAMS ((cpp_reader *pfile,\n \t\t\t\t\t\t\t int fd,\n \t\t\t\t\t\t\t const char *orig));\n extern void c_common_write_pch\t\t\tPARAMS ((void));\n+extern void preprocess_file\t\t\tPARAMS ((cpp_reader *,\n+\t\t\t\t\t\t\t const char *,\n+\t\t\t\t\t\t\t FILE *));\n \n #endif /* ! GCC_C_COMMON_H */"}, {"sha": "452056a3c936ed6ef741590a2330a67c51024331", "filename": "gcc/c-lex.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63973df35012e01a00e7f58fd12e8221097ec33d/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63973df35012e01a00e7f58fd12e8221097ec33d/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=63973df35012e01a00e7f58fd12e8221097ec33d", "patch": "@@ -93,9 +93,8 @@ static void cb_define\t\tPARAMS ((cpp_reader *, unsigned int,\n static void cb_undef\t\tPARAMS ((cpp_reader *, unsigned int,\n \t\t\t\t\t cpp_hashnode *));\n \f\n-const char *\n-init_c_lex (filename)\n-     const char *filename;\n+void\n+init_c_lex ()\n {\n   struct cpp_callbacks *cb;\n   struct c_fileinfo *toplevel;\n@@ -135,11 +134,6 @@ init_c_lex (filename)\n       cb->define = cb_define;\n       cb->undef = cb_undef;\n     }\n-\n-  /* Start it at 0.  */\n-  lineno = 0;\n-\n-  return cpp_read_main_file (parse_in, filename, ident_hash);\n }\n \n /* A thin wrapper around the real parser that initializes the "}, {"sha": "97ba6cc5b92993101a394d95068242099ac89002", "filename": "gcc/c-opts.c", "status": "modified", "additions": 36, "deletions": 44, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63973df35012e01a00e7f58fd12e8221097ec33d/gcc%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63973df35012e01a00e7f58fd12e8221097ec33d/gcc%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-opts.c?ref=63973df35012e01a00e7f58fd12e8221097ec33d", "patch": "@@ -90,7 +90,6 @@ static void set_std_cxx98 PARAMS ((int));\n static void set_std_c89 PARAMS ((int, int));\n static void set_std_c99 PARAMS ((int));\n static void check_deps_environment_vars PARAMS ((void));\n-static void preprocess_file PARAMS ((void));\n static void handle_deferred_opts PARAMS ((void));\n static void sanitize_cpp_opts PARAMS ((void));\n static void add_prefixed_path PARAMS ((const char *, size_t));\n@@ -715,7 +714,7 @@ c_common_decode_option (argc, argv)\n \t depends on this.  Preprocessed output does occur if -MD, -MMD\n \t or environment var dependency generation is used.  */\n       cpp_opts->deps.style = (code == OPT_M ? DEPS_SYSTEM: DEPS_USER);\n-      cpp_opts->no_output = 1;\n+      flag_no_output = 1;\n       cpp_opts->inhibit_warnings = 1;\n       break;\n \n@@ -747,7 +746,7 @@ c_common_decode_option (argc, argv)\n       break;\n \n     case OPT_P:\n-      cpp_opts->no_line_commands = 1;\n+      flag_no_line_commands = 1;\n       break;\n \n     case OPT_Wabi:\n@@ -1500,24 +1499,6 @@ c_common_post_options ()\n   return flag_preprocess_only;\n }\n \n-/* Preprocess the input file to out_stream.  */\n-static void\n-preprocess_file ()\n-{\n-  /* Open the output now.  We must do so even if no_output is on,\n-     because there may be other output than from the actual\n-     preprocessing (e.g. from -dM).  */\n-  if (out_fname[0] == '\\0')\n-    out_stream = stdout;\n-  else\n-    out_stream = fopen (out_fname, \"w\");\n-\n-  if (out_stream == NULL)\n-    fatal_io_error (\"opening output file %s\", out_fname);\n-  else\n-    cpp_preprocess_file (parse_in, in_fname, out_stream);\n-}\n-\n /* Front end initialization common to C, ObjC and C++.  */\n const char *\n c_common_init (filename)\n@@ -1535,18 +1516,35 @@ c_common_init (filename)\n      cpp_main_file.  */\n   cpp_get_callbacks (parse_in)->register_builtins = cb_register_builtins;\n \n-  /* NULL is passed up to toplev.c and we exit quickly.  */\n   if (flag_preprocess_only)\n     {\n-      preprocess_file ();\n+      /* Open the output now.  We must do so even if flag_no_output is\n+\t on, because there may be other output than from the actual\n+\t preprocessing (e.g. from -dM).  */\n+      if (out_fname[0] == '\\0')\n+\tout_stream = stdout;\n+      else\n+\tout_stream = fopen (out_fname, \"w\");\n+\n+      if (out_stream == NULL)\n+\tfatal_io_error (\"opening output file %s\", out_fname);\n+      else\n+\t/* Preprocess the input file to out_stream.  */\n+\tpreprocess_file (parse_in, in_fname, out_stream);\n+\n+      /* Exit quickly in toplev.c.  */\n       return NULL;\n     }\n \n-  /* Do this before initializing pragmas, as then cpplib's hash table\n-     has been set up.  NOTE: we are using our own file name here, not\n-     the one supplied.  */\n-  filename = init_c_lex (in_fname);\n+  init_c_lex ();\n+\n+  /* Start it at 0.  */\n+  lineno = 0;\n+\n+  /* NOTE: we use in_fname here, not the one supplied.  */\n+  filename = cpp_read_main_file (parse_in, in_fname, ident_hash);\n \n+  /* Has to wait until now so that cpplib has its hash table.  */\n   init_pragma ();\n \n   return filename;\n@@ -1665,16 +1663,16 @@ sanitize_cpp_opts ()\n \n   /* -dM and dependencies suppress normal output; do it here so that\n      the last -d[MDN] switch overrides earlier ones.  */\n-  if (cpp_opts->dump_macros == dump_only)\n-    cpp_opts->no_output = 1;\n+  if (flag_dump_macros == 'M')\n+    flag_no_output = 1;\n \n   /* Disable -dD, -dN and -dI if normal output is suppressed.  Allow\n      -dM since at least glibc relies on -M -dM to work.  */\n-  if (cpp_opts->no_output)\n+  if (flag_no_output)\n     {\n-      if (cpp_opts->dump_macros != dump_only)\n-\tcpp_opts->dump_macros = dump_none;\n-      cpp_opts->dump_includes = 0;\n+      if (flag_dump_macros != 'M')\n+\tflag_dump_macros = 0;\n+      flag_dump_includes = 0;\n     }\n \n   cpp_opts->unsigned_char = !flag_signed_char;\n@@ -1769,20 +1767,14 @@ handle_OPT_d (arg)\n   while ((c = *arg++) != '\\0')\n     switch (c)\n       {\n-      case 'M':\n-\tcpp_opts->dump_macros = dump_only;\n-\tbreak;\n-\n-      case 'N':\n-\tcpp_opts->dump_macros = dump_names;\n-\tbreak;\n-\n-      case 'D':\n-\tcpp_opts->dump_macros = dump_definitions;\n+      case 'M':\t\t\t/* Dump macros only.  */\n+      case 'N':\t\t\t/* Dump names.  */\n+      case 'D':\t\t\t/* Dump definitions.  */\n+\tflag_dump_macros = c;\n \tbreak;\n \n       case 'I':\n-\tcpp_opts->dump_includes = 1;\n+\tflag_dump_includes = 1;\n \tbreak;\n       }\n }"}, {"sha": "16e2dc174bc40ac4158138746dc2d3702a1b9b63", "filename": "gcc/c-ppoutput.c", "status": "renamed", "additions": 121, "deletions": 118, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63973df35012e01a00e7f58fd12e8221097ec33d/gcc%2Fc-ppoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63973df35012e01a00e7f58fd12e8221097ec33d/gcc%2Fc-ppoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-ppoutput.c?ref=63973df35012e01a00e7f58fd12e8221097ec33d", "patch": "@@ -1,5 +1,5 @@\n /* Preprocess only, using cpplib.\n-   Copyright (C) 1995, 1997, 1998, 1999, 2000, 2001, 2002\n+   Copyright (C) 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003\n    Free Software Foundation, Inc.\n    Written by Per Bothner, 1994-95.\n \n@@ -15,32 +15,40 @@ GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n along with this program; if not, write to the Free Software\n-Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n-\n- In other words, you are welcome to use, share and improve this program.\n- You are forbidden to forbid anyone else to use, share and improve\n- what you give them.   Help stamp out software-hoarding!  */\n+Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n+#include \"tree.h\"\n+#include \"c-common.h\"\n+\n+/* Encapsulates state used to convert a stream of tokens into a text\n+   file.  */\n+static struct\n+{\n+  FILE *outf;\t\t\t/* Stream to write to.  */\n+  const struct line_map *map;\t/* Logical to physical line mappings.  */\n+  const cpp_token *prev;\t/* Previous token.  */\n+  const cpp_token *source;\t/* Source token for spacing.  */\n+  unsigned int line;\t\t/* Line currently being written.  */\n+  unsigned char printed;\t/* Nonzero if something output at line.  */\n+} print;\n \n static void setup_callbacks PARAMS ((cpp_reader *));\n \n /* General output routines.  */\n static void scan_translation_unit PARAMS ((cpp_reader *));\n static void scan_translation_unit_trad PARAMS ((cpp_reader *));\n-static void account_for_newlines PARAMS ((cpp_reader *, const uchar *,\n-\t\t\t\t\t  size_t));\n+static void account_for_newlines PARAMS ((const uchar *, size_t));\n static int dump_macro PARAMS ((cpp_reader *, cpp_hashnode *, void *));\n \n-static void print_line PARAMS ((cpp_reader *, const struct line_map *,\n-\t\t\t\tunsigned int, const char *));\n-static void maybe_print_line PARAMS ((cpp_reader *, const struct line_map *,\n-\t\t\t\t      unsigned int));\n+static void print_line PARAMS ((const struct line_map *, unsigned int,\n+\t\t\t\tconst char *));\n+static void maybe_print_line PARAMS ((const struct line_map *, unsigned int));\n \n /* Callback routines for the parser.   Most of these are active only\n    in specific modes.  */\n@@ -56,49 +64,48 @@ static void cb_def_pragma PARAMS ((cpp_reader *, unsigned int));\n \n /* Preprocess and output.  */\n void\n-cpp_preprocess_file (pfile, in_fname, out_stream)\n+preprocess_file (pfile, in_fname, out_stream)\n      cpp_reader *pfile;\n      const char *in_fname;\n      FILE *out_stream;\n {\n-  /* Initialize the printer structure.  Setting print.line to -1 here\n-     is a trick to guarantee that the first token of the file will\n-     cause a linemarker to be output by maybe_print_line.  */\n-  pfile->print.line = (unsigned int) -1;\n-  pfile->print.printed = 0;\n-  pfile->print.prev = 0;\n-  pfile->print.map = 0;\n-  pfile->print.outf = out_stream;\n+  /* Initialize the print structure.  Setting print.line to -1 here is\n+     a trick to guarantee that the first token of the file will cause\n+     a linemarker to be output by maybe_print_line.  */\n+  print.line = (unsigned int) -1;\n+  print.printed = 0;\n+  print.prev = 0;\n+  print.map = 0;\n+  print.outf = out_stream;\n \n   setup_callbacks (pfile);\n \n   if (cpp_read_main_file (pfile, in_fname, NULL))\n     {\n-      cpp_options *options = &pfile->opts;\n       cpp_finish_options (pfile);\n \n       /* A successful cpp_read_main_file guarantees that we can call\n \t cpp_scan_nooutput or cpp_get_token next.  */\n-      if (options->no_output)\n+      if (flag_no_output)\n \t{\n \t  /* Scan -included buffers, then the main file.  */\n \t  while (pfile->buffer->prev)\n \t    cpp_scan_nooutput (pfile);\n \t  cpp_scan_nooutput (pfile);\n \t}\n-      else if (options->traditional)\n+      else if (cpp_get_options (pfile)->traditional)\n \tscan_translation_unit_trad (pfile);\n       else\n \tscan_translation_unit (pfile);\n \n-      /* -dM command line option.  Should this be in cpp_finish?  */\n-      if (options->dump_macros == dump_only)\n+      /* -dM command line option.  Should this be elsewhere?  */\n+      if (flag_dump_macros == 'M')\n \tcpp_forall_identifiers (pfile, dump_macro, NULL);\n     }\n \n   /* Flush any pending output.  */\n-  if (pfile->print.printed)\n-    putc ('\\n', pfile->print.outf);\n+  if (print.printed)\n+    putc ('\\n', print.outf);\n }\n \n /* Set up the callbacks as appropriate.  */\n@@ -109,7 +116,7 @@ setup_callbacks (pfile)\n   cpp_options *options = &pfile->opts;\n   cpp_callbacks *cb = cpp_get_callbacks (pfile);\n \n-  if (! options->no_output)\n+  if (!flag_no_output)\n     {\n       cb->line_change = cb_line_change;\n       /* Don't emit #pragma or #ident directives if we are processing\n@@ -119,15 +126,14 @@ setup_callbacks (pfile)\n \t  cb->ident      = cb_ident;\n \t  cb->def_pragma = cb_def_pragma;\n \t}\n-      if (! options->no_line_commands)\n+      if (!flag_no_line_commands)\n \tcb->file_change = cb_file_change;\n     }\n \n-  if (options->dump_includes)\n+  if (flag_dump_includes)\n     cb->include  = cb_include;\n \n-  if (options->dump_macros == dump_names\n-      || options->dump_macros == dump_definitions)\n+  if (flag_dump_macros == 'N' || flag_dump_macros == 'D')\n     {\n       cb->define = cb_define;\n       cb->undef  = cb_undef;\n@@ -142,18 +148,18 @@ scan_translation_unit (pfile)\n {\n   bool avoid_paste = false;\n \n-  pfile->print.source = NULL;\n+  print.source = NULL;\n   for (;;)\n     {\n       const cpp_token *token = cpp_get_token (pfile);\n \n       if (token->type == CPP_PADDING)\n \t{\n \t  avoid_paste = true;\n-\t  if (pfile->print.source == NULL\n-\t      || (!(pfile->print.source->flags & PREV_WHITE)\n+\t  if (print.source == NULL\n+\t      || (!(print.source->flags & PREV_WHITE)\n \t\t  && token->val.source == NULL))\n-\t    pfile->print.source = token->val.source;\n+\t    print.source = token->val.source;\n \t  continue;\n \t}\n \n@@ -163,37 +169,36 @@ scan_translation_unit (pfile)\n       /* Subtle logic to output a space if and only if necessary.  */\n       if (avoid_paste)\n \t{\n-\t  if (pfile->print.source == NULL)\n-\t    pfile->print.source = token;\n-\t  if (pfile->print.source->flags & PREV_WHITE\n-\t      || (pfile->print.prev\n-\t\t  && cpp_avoid_paste (pfile, pfile->print.prev, token))\n-\t      || (pfile->print.prev == NULL && token->type == CPP_HASH))\n-\t    putc (' ', pfile->print.outf);\n+\t  if (print.source == NULL)\n+\t    print.source = token;\n+\t  if (print.source->flags & PREV_WHITE\n+\t      || (print.prev\n+\t\t  && cpp_avoid_paste (pfile, print.prev, token))\n+\t      || (print.prev == NULL && token->type == CPP_HASH))\n+\t    putc (' ', print.outf);\n \t}\n       else if (token->flags & PREV_WHITE)\n-\tputc (' ', pfile->print.outf);\n+\tputc (' ', print.outf);\n \n       avoid_paste = false;\n-      pfile->print.source = NULL;\n-      pfile->print.prev = token;\n-      cpp_output_token (token, pfile->print.outf);\n+      print.source = NULL;\n+      print.prev = token;\n+      cpp_output_token (token, print.outf);\n \n       if (token->type == CPP_COMMENT)\n-\taccount_for_newlines (pfile, token->val.str.text, token->val.str.len);\n+\taccount_for_newlines (token->val.str.text, token->val.str.len);\n     }\n }\n \n-/* Adjust pfile->print.line for newlines embedded in output.  */\n+/* Adjust print.line for newlines embedded in output.  */\n static void\n-account_for_newlines (pfile, str, len)\n-     cpp_reader *pfile;\n+account_for_newlines (str, len)\n      const uchar *str;\n      size_t len;\n {\n   while (len--)\n     if (*str++ == '\\n')\n-      pfile->print.line++;\n+      print.line++;\n }\n \n /* Writes out a traditionally preprocessed file.  */\n@@ -204,59 +209,57 @@ scan_translation_unit_trad (pfile)\n   while (_cpp_read_logical_line_trad (pfile))\n     {\n       size_t len = pfile->out.cur - pfile->out.base;\n-      maybe_print_line (pfile, pfile->print.map, pfile->out.first_line);\n-      fwrite (pfile->out.base, 1, len, pfile->print.outf);\n-      pfile->print.printed = 1;\n+      maybe_print_line (print.map, pfile->out.first_line);\n+      fwrite (pfile->out.base, 1, len, print.outf);\n+      print.printed = 1;\n       if (!CPP_OPTION (pfile, discard_comments))\n-\taccount_for_newlines (pfile, pfile->out.base, len);\n+\taccount_for_newlines (pfile->out.base, len);\n     }\n }\n \n /* If the token read on logical line LINE needs to be output on a\n    different line to the current one, output the required newlines or\n    a line marker, and return 1.  Otherwise return 0.  */\n static void\n-maybe_print_line (pfile, map, line)\n-     cpp_reader *pfile;\n+maybe_print_line (map, line)\n      const struct line_map *map;\n      unsigned int line;\n {\n   /* End the previous line of text.  */\n-  if (pfile->print.printed)\n+  if (print.printed)\n     {\n-      putc ('\\n', pfile->print.outf);\n-      pfile->print.line++;\n-      pfile->print.printed = 0;\n+      putc ('\\n', print.outf);\n+      print.line++;\n+      print.printed = 0;\n     }\n \n-  if (line >= pfile->print.line && line < pfile->print.line + 8)\n+  if (line >= print.line && line < print.line + 8)\n     {\n-      while (line > pfile->print.line)\n+      while (line > print.line)\n \t{\n-\t  putc ('\\n', pfile->print.outf);\n-\t  pfile->print.line++;\n+\t  putc ('\\n', print.outf);\n+\t  print.line++;\n \t}\n     }\n   else\n-    print_line (pfile, map, line, \"\");\n+    print_line (map, line, \"\");\n }\n \n /* Output a line marker for logical line LINE.  Special flags are \"1\"\n    or \"2\" indicating entering or leaving a file.  */\n static void\n-print_line (pfile, map, line, special_flags)\n-     cpp_reader *pfile;\n+print_line (map, line, special_flags)\n      const struct line_map *map;\n      unsigned int line;\n      const char *special_flags;\n {\n   /* End any previous line of text.  */\n-  if (pfile->print.printed)\n-    putc ('\\n', pfile->print.outf);\n-  pfile->print.printed = 0;\n+  if (print.printed)\n+    putc ('\\n', print.outf);\n+  print.printed = 0;\n \n-  pfile->print.line = line;\n-  if (! CPP_OPTION (pfile, no_line_commands))\n+  print.line = line;\n+  if (!flag_no_line_commands)\n     {\n       size_t to_file_len = strlen (map->to_file);\n       unsigned char *to_file_quoted = alloca (to_file_len * 4 + 1);\n@@ -267,16 +270,16 @@ print_line (pfile, map, line, special_flags)\n       p = cpp_quote_string (to_file_quoted,\n \t\t\t    (unsigned char *)map->to_file, to_file_len);\n       *p = '\\0';\n-      fprintf (pfile->print.outf, \"# %u \\\"%s\\\"%s\",\n-\t       SOURCE_LINE (map, pfile->print.line),\n+      fprintf (print.outf, \"# %u \\\"%s\\\"%s\",\n+\t       SOURCE_LINE (map, print.line),\n \t       to_file_quoted, special_flags);\n \n       if (map->sysp == 2)\n-\tfputs (\" 3 4\", pfile->print.outf);\n+\tfputs (\" 3 4\", print.outf);\n       else if (map->sysp == 1)\n-\tfputs (\" 3\", pfile->print.outf);\n+\tfputs (\" 3\", print.outf);\n \n-      putc ('\\n', pfile->print.outf);\n+      putc ('\\n', print.outf);\n     }\n }\n \n@@ -291,9 +294,9 @@ cb_line_change (pfile, token, parsing_args)\n   if (token->type == CPP_EOF || parsing_args)\n     return;\n \n-  maybe_print_line (pfile, pfile->print.map, token->line);\n-  pfile->print.prev = 0;\n-  pfile->print.source = 0;\n+  maybe_print_line (print.map, token->line);\n+  print.prev = 0;\n+  print.source = 0;\n \n   /* Supply enough spaces to put this token in its original column,\n      one space per column greater than 2, since scan_translation_unit\n@@ -302,26 +305,26 @@ cb_line_change (pfile, token, parsing_args)\n      ought to care.  Some things do care; the fault lies with them.  */\n   if (!CPP_OPTION (pfile, traditional))\n     {\n-      pfile->print.printed = 1;\n+      print.printed = 1;\n       if (token->col > 2)\n \t{\n \t  unsigned int spaces = token->col - 2;\n \n \t  while (spaces--)\n-\t    putc (' ', pfile->print.outf);\n+\t    putc (' ', print.outf);\n \t}\n     }\n }\n \n static void\n cb_ident (pfile, line, str)\n-     cpp_reader *pfile;\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n      unsigned int line;\n      const cpp_string * str;\n {\n-  maybe_print_line (pfile, pfile->print.map, line);\n-  fprintf (pfile->print.outf, \"#ident \\\"%s\\\"\\n\", str->text);\n-  pfile->print.line++;\n+  maybe_print_line (print.map, line);\n+  fprintf (print.outf, \"#ident \\\"%s\\\"\\n\", str->text);\n+  print.line++;\n }\n \n static void\n@@ -330,29 +333,29 @@ cb_define (pfile, line, node)\n      unsigned int line;\n      cpp_hashnode *node;\n {\n-  maybe_print_line (pfile, pfile->print.map, line);\n-  fputs (\"#define \", pfile->print.outf);\n+  maybe_print_line (print.map, line);\n+  fputs (\"#define \", print.outf);\n \n-  /* -dD command line option.  */\n-  if (CPP_OPTION (pfile, dump_macros) == dump_definitions)\n+  /* 'D' is whole definition; 'N' is name only.  */\n+  if (flag_dump_macros == 'D')\n     fputs ((const char *) cpp_macro_definition (pfile, node),\n-\t   pfile->print.outf);\n+\t   print.outf);\n   else\n-    fputs ((const char *) NODE_NAME (node), pfile->print.outf);\n+    fputs ((const char *) NODE_NAME (node), print.outf);\n \n-  putc ('\\n', pfile->print.outf);\n-  pfile->print.line++;\n+  putc ('\\n', print.outf);\n+  print.line++;\n }\n \n static void\n cb_undef (pfile, line, node)\n-     cpp_reader *pfile;\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n      unsigned int line;\n      cpp_hashnode *node;\n {\n-  maybe_print_line (pfile, pfile->print.map, line);\n-  fprintf (pfile->print.outf, \"#undef %s\\n\", NODE_NAME (node));\n-  pfile->print.line++;\n+  maybe_print_line (print.map, line);\n+  fprintf (print.outf, \"#undef %s\\n\", NODE_NAME (node));\n+  print.line++;\n }\n \n static void\n@@ -362,14 +365,14 @@ cb_include (pfile, line, dir, header)\n      const unsigned char *dir;\n      const cpp_token *header;\n {\n-  maybe_print_line (pfile, pfile->print.map, line);\n-  fprintf (pfile->print.outf, \"#%s %s\\n\", dir,\n+  maybe_print_line (print.map, line);\n+  fprintf (print.outf, \"#%s %s\\n\", dir,\n \t   cpp_token_as_text (pfile, header));\n-  pfile->print.line++;\n+  print.line++;\n }\n \n /* The file name, line number or system header flags have changed, as\n-   described in MAP.  From this point on, the old pfile->print.map might be\n+   described in MAP.  From this point on, the old print.map might be\n    pointing to freed memory, and so must not be dereferenced.  */\n \n static void\n@@ -380,26 +383,26 @@ cb_file_change (pfile, map)\n   const char *flags = \"\";\n \n   /* First time?  */\n-  if (pfile->print.map == NULL)\n+  if (print.map == NULL)\n     {\n       /* Avoid printing foo.i when the main file is foo.c.  */\n       if (!CPP_OPTION (pfile, preprocessed))\n-\tprint_line (pfile, map, map->from_line, flags);\n+\tprint_line (map, map->from_line, flags);\n     }\n   else\n     {\n       /* Bring current file to correct line when entering a new file.  */\n       if (map->reason == LC_ENTER)\n-\tmaybe_print_line (pfile, map - 1, map->from_line - 1);\n+\tmaybe_print_line (map - 1, map->from_line - 1);\n \n       if (map->reason == LC_ENTER)\n \tflags = \" 1\";\n       else if (map->reason == LC_LEAVE)\n \tflags = \" 2\";\n-      print_line (pfile, map, map->from_line, flags);\n+      print_line (map, map->from_line, flags);\n     }\n \n-  pfile->print.map = map;\n+  print.map = map;\n }\n \n /* Copy a #pragma directive to the preprocessed output.  */\n@@ -408,10 +411,10 @@ cb_def_pragma (pfile, line)\n      cpp_reader *pfile;\n      unsigned int line;\n {\n-  maybe_print_line (pfile, pfile->print.map, line);\n-  fputs (\"#pragma \", pfile->print.outf);\n-  cpp_output_line (pfile, pfile->print.outf);\n-  pfile->print.line++;\n+  maybe_print_line (print.map, line);\n+  fputs (\"#pragma \", print.outf);\n+  cpp_output_line (pfile, print.outf);\n+  print.line++;\n }\n \n /* Dump out the hash table.  */\n@@ -423,11 +426,11 @@ dump_macro (pfile, node, v)\n {\n   if (node->type == NT_MACRO && !(node->flags & NODE_BUILTIN))\n     {\n-      fputs (\"#define \", pfile->print.outf);\n+      fputs (\"#define \", print.outf);\n       fputs ((const char *) cpp_macro_definition (pfile, node),\n-\t     pfile->print.outf);\n-      putc ('\\n', pfile->print.outf);\n-      pfile->print.line++;\n+\t     print.outf);\n+      putc ('\\n', print.outf);\n+      print.line++;\n     }\n \n   return 1;", "previous_filename": "gcc/cppmain.c"}, {"sha": "3eac96c7d74e806129c0505927d07b6049f98802", "filename": "gcc/cpphash.h", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63973df35012e01a00e7f58fd12e8221097ec33d/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63973df35012e01a00e7f58fd12e8221097ec33d/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=63973df35012e01a00e7f58fd12e8221097ec33d", "patch": "@@ -240,18 +240,6 @@ struct spec_nodes\n   cpp_hashnode *n__VA_ARGS__;\t\t/* C99 vararg macros */\n };\n \n-/* Encapsulates state used to convert a stream of tokens into a text\n-   file.  */\n-struct printer\n-{\n-  FILE *outf;\t\t\t/* Stream to write to.  */\n-  const struct line_map *map;\t/* Logical to physical line mappings.  */\n-  const cpp_token *prev;\t/* Previous token.  */\n-  const cpp_token *source;\t/* Source token for spacing.  */\n-  unsigned int line;\t\t/* Line currently being written.  */\n-  unsigned char printed;\t/* Nonzero if something output at line.  */\n-};\n-\n /* Represents the contents of a file cpplib has read in.  */\n struct cpp_buffer\n {\n@@ -422,9 +410,6 @@ struct cpp_reader\n      preprocessor.  */\n   struct spec_nodes spec_nodes;\n \n-  /* Used when doing preprocessed output.  */\n-  struct printer print;\n-\n   /* Nonzero means don't look for #include \"foo\" the source-file\n      directory.  */\n   unsigned char quote_ignores_source_dir;"}, {"sha": "ebb276660703c5b2b57c965373b11c3acef36ab7", "filename": "gcc/cpplib.h", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63973df35012e01a00e7f58fd12e8221097ec33d/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63973df35012e01a00e7f58fd12e8221097ec33d/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=63973df35012e01a00e7f58fd12e8221097ec33d", "patch": "@@ -206,15 +206,6 @@ struct cpp_token\n typedef unsigned CPPCHAR_SIGNED_T cppchar_t;\n typedef CPPCHAR_SIGNED_T cppchar_signed_t;\n \n-/* Values for opts.dump_macros.\n-  dump_only means inhibit output of the preprocessed text\n-             and instead output the definitions of all user-defined\n-             macros in a form suitable for use as input to cpp.\n-   dump_names means pass #define and the macro name through to output.\n-   dump_definitions means pass the whole definition (plus #define) through\n-*/\n-enum { dump_none = 0, dump_only, dump_names, dump_definitions };\n-\n /* This structure is nested inside struct cpp_reader, and\n    carries all the options visible to the command line.  */\n struct cpp_options\n@@ -306,17 +297,10 @@ struct cpp_options\n   /* Nonzero means turn warnings into errors.  */\n   unsigned char warnings_are_errors;\n \n-  /* Nonzero causes output not to be done, but directives such as\n-     #define that have side effects are still obeyed.  */\n-  unsigned char no_output;\n-\n   /* Nonzero means we should look for header.gcc files that remap file\n      names.  */\n   unsigned char remap;\n \n-  /* Nonzero means don't output line number information.  */\n-  unsigned char no_line_commands;\n-\n   /* Zero means dollar signs are punctuation.  */\n   unsigned char dollars_in_ident;\n \n@@ -339,12 +323,6 @@ struct cpp_options\n      bother trying to do macro expansion and whatnot.  */\n   unsigned char preprocessed;\n \n-  /* Nonzero means dump macros in some fashion - see above.  */\n-  unsigned char dump_macros;\n-\n-  /* Nonzero means pass #include lines through to the output.  */\n-  unsigned char dump_includes;\n-\n   /* Print column number in error messages.  */\n   unsigned char show_column;\n \n@@ -753,9 +731,6 @@ extern void cpp_prepare_state PARAMS ((cpp_reader *,\n extern int cpp_read_state PARAMS ((cpp_reader *, const char *, FILE *,\n \t\t\t\t   struct save_macro_data *));\n \n-/* In cppmain.c */\n-extern void cpp_preprocess_file PARAMS ((cpp_reader *, const char *, FILE *));\n-\n #ifdef __cplusplus\n }\n #endif"}, {"sha": "298fda17dab7e6376a165c489600f783580bba4c", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63973df35012e01a00e7f58fd12e8221097ec33d/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63973df35012e01a00e7f58fd12e8221097ec33d/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=63973df35012e01a00e7f58fd12e8221097ec33d", "patch": "@@ -82,7 +82,8 @@ the other C-like languages: @file{c-common.c},\n @file{c-pragma.c},\n @file{c-semantics.c},\n @file{c-lex.c},\n-@file{c-incpath.c}\n+@file{c-incpath.c},\n+@file{c-ppoutput.c},\n @file{c-common.h},\n @file{c-dump.h},\n @file{c-incpath.h}"}]}