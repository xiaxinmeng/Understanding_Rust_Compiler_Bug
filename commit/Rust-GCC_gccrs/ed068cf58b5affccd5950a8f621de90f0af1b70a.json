{"sha": "ed068cf58b5affccd5950a8f621de90f0af1b70a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQwNjhjZjU4YjVhZmZjY2Q1OTUwYThmNjIxZGU5MGYwYWYxYjcwYQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-12-30T12:58:18Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-12-30T12:58:18Z"}, "message": "Add decls of functions in varasm.c.\n\nAllow to be included when rtl.h is not.\n\nFrom-SVN: r8710", "tree": {"sha": "34053a7d379a38bb3fdc4709155aefce6008c210", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34053a7d379a38bb3fdc4709155aefce6008c210"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed068cf58b5affccd5950a8f621de90f0af1b70a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed068cf58b5affccd5950a8f621de90f0af1b70a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed068cf58b5affccd5950a8f621de90f0af1b70a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed068cf58b5affccd5950a8f621de90f0af1b70a/comments", "author": null, "committer": null, "parents": [{"sha": "5a13eaa46a3c90ed92cf02c5fcc0098e301ea715", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a13eaa46a3c90ed92cf02c5fcc0098e301ea715", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a13eaa46a3c90ed92cf02c5fcc0098e301ea715"}], "stats": {"total": 182, "additions": 180, "deletions": 2}, "files": [{"sha": "7922d64ef3f0f746bf08787870980036929dbd2e", "filename": "gcc/output.h", "status": "modified", "additions": 180, "deletions": 2, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed068cf58b5affccd5950a8f621de90f0af1b70a/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed068cf58b5affccd5950a8f621de90f0af1b70a/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=ed068cf58b5affccd5950a8f621de90f0af1b70a", "patch": "@@ -41,6 +41,7 @@ extern int dbr_sequence_length\tPROTO((void));\n /* Indicate that branch shortening hasn't yet been done.  */\n extern void init_insn_lengths\tPROTO((void));\n \n+#ifdef RTX_CODE\n /* Obtain the current length of an insn.  If branch shortening has been done,\n    get its actual length.  Otherwise, get its maximum length.  */\n extern int get_attr_length\tPROTO((rtx));\n@@ -112,21 +113,196 @@ extern int only_leaf_regs_used\tPROTO((void));\n /* Scan IN_RTX and its subexpressions, and renumber all regs into those\n    available in leaf functions.  */\n extern void leaf_renumber_regs_insn PROTO((rtx));\n+#endif\n+\n+/* Functions in varasm.c.  */\n+\n+/* Tell assembler to switch to text section.  */\n+extern void text_section\t\tPROTO((void));\n+\n+/* Tell assembler to switch to data section.  */\n+extern void data_section\t\tPROTO((void));\n+\n+/* Tell assembler to switch to read-only data section.  This is normally\n+   the text section.  */\n+extern void readonly_data_section\tPROTO((void));\n+\n+/* Determine if we're in the text section. */\n+extern int in_text_section\t\tPROTO((void));\n+\n+#ifdef TREE_CODE\n+/* Tell assembler to change to section NAME for DECL.\n+   If DECL is NULL, just switch to section NAME.\n+   If NAME is NULL, get the name from DECL.  */\n+extern void named_section\t\tPROTO((tree, char *));\n+\n+/* Create the rtl to represent a function, for a function definition.\n+   DECL is a FUNCTION_DECL node which describes which function.\n+   The rtl is stored into DECL.  */\n+extern void make_function_rtl\t\tPROTO((tree));\n+\n+/* Decode an `asm' spec for a declaration as a register name.\n+   Return the register number, or -1 if nothing specified,\n+   or -2 if the ASMSPEC is not `cc' or `memory' and is not recognized,\n+   or -3 if ASMSPEC is `cc' and is not recognized,\n+   or -4 if ASMSPEC is `memory' and is not recognized.\n+   Accept an exact spelling or a decimal number.\n+   Prefixes such as % are optional.  */\n+extern int decode_reg_name\t\tPROTO((char *));\n+\n+/* Create the DECL_RTL for a declaration for a static or external variable\n+   or static or external function.\n+   ASMSPEC, if not 0, is the string which the user specified\n+   as the assembler symbol name.\n+   TOP_LEVEL is nonzero if this is a file-scope variable.\n+\n+   This is never called for PARM_DECL nodes.  */\n+extern void make_decl_rtl\t\tPROTO((tree, char *, int));\n+\n+/* Make the rtl for variable VAR be volatile.\n+   Use this only for static variables.  */\n+extern void make_var_volatile\t\tPROTO((tree));\n+\n+/* Output alignment directive to align for constant expression EXP.  */\n+extern void assemble_constant_align\tPROTO((tree));\n+\n+/* Output a string of literal assembler code\n+   for an `asm' keyword used between functions.  */\n+extern void assemble_asm\t\tPROTO((tree));\n+\n+/* Record an element in the table of global destructors.\n+   How this is done depends on what sort of assembler and linker\n+   are in use.\n+\n+   NAME should be the name of a global function to be called\n+   at exit time.  This name is output using assemble_name.  */\n+extern void assemble_destructor\t\tPROTO((char *));\n+\n+/* Likewise for global constructors.  */\n+extern void assemble_constructor\tPROTO((char *));\n+\n+/* Likewise for entries we want to record for garbage collection.\n+   Garbage collection is still under development.  */\n+extern void assemble_gc_entry\t\tPROTO((char *));\n+\n+/* Output assembler code for the constant pool of a function and associated\n+   with defining the name of the function.  DECL describes the function.\n+   NAME is the function's name.  For the constant pool, we use the current\n+   constant pool data.  */\n+extern void assemble_start_function\tPROTO((tree, char *));\n+\n+/* Output assembler code associated with defining the size of the\n+   function.  DECL describes the function.  NAME is the function's name.  */\n+extern void assemble_end_function\tPROTO((tree, char *));\n+\n+/* Assemble code to leave SIZE bytes of zeros.  */\n+extern void assemble_zeros\t\tPROTO((int));\n+\n+/* Assemble an alignment pseudo op for an ALIGN-bit boundary.  */\n+extern void assemble_align\t\tPROTO((int));\n+\n+/* Assemble a string constant with the specified C string as contents.  */\n+extern void assemble_string\t\tPROTO((char *, int));\n+/* Assemble everything that is needed for a variable or function declaration.\n+   Not used for automatic variables, and not used for function definitions.\n+   Should not be called for variables of incomplete structure type.\n+\n+   TOP_LEVEL is nonzero if this variable has file scope.\n+   AT_END is nonzero if this is the special handling, at end of compilation,\n+   to define things that have had only tentative definitions.\n+   DONT_OUTPUT_DATA if nonzero means don't actually output the\n+   initial value (that will be done by the caller).  */\n+extern void assemble_variable\t\tPROTO((tree, int, int, int));\n+\n+/* Output text storage for constructor CONSTR. */\n+extern void bc_output_constructor\tPROTO((tree, int));\n+\n+/* Create storage for constructor CONSTR. */\n+extern void bc_output_data_constructor\tPROTO((tree));\n+\n+/* Output something to declare an external symbol to the assembler.\n+   (Most assemblers don't need this, so we normally output nothing.)\n+   Do nothing if DECL is not external.  */\n+extern void assemble_external\t\tPROTO((tree));\n+#endif\n+\n+#ifdef RTX_CODE\n+/* Similar, for calling a library function FUN.  */\n+extern void assemble_external_libcall\tPROTO((rtx));\n+#endif\n \n-/* Output a name (as found inside a symbol_ref) in assembler syntax.  */\n-extern void assemble_name STDIO_PROTO((FILE *, char *));\n+/* Declare the label NAME global.  */\n+extern void assemble_global\t\tPROTO((char *));\n+\n+/* Assemble a label named NAME.  */\n+extern void assemble_label\t\tPROTO((char *));\n+\n+/* Output to FILE a reference to the assembler name of a C-level name NAME.\n+   If NAME starts with a *, the rest of NAME is output verbatim.\n+   Otherwise NAME is transformed in an implementation-defined way\n+   (usually by the addition of an underscore).\n+   Many macros in the tm file are defined to call this function.  */\n+extern void assemble_name\t\tSTDIO_PROTO((FILE *, char *));\n+\n+#ifdef RTX_CODE\n+/* Assemble the integer constant X into an object of SIZE bytes.\n+   X must be either a CONST_INT or CONST_DOUBLE.\n+\n+   Return 1 if we were able to output the constant, otherwise 0.  If FORCE is\n+   non-zero, abort if we can't output the constant.  */\n+extern int assemble_integer\t\tPROTO((rtx, int, int));\n+\n+#ifdef EMUSHORT\n+/* Assemble the floating-point constant D into an object of size MODE.  */\n+extern void assemble_real\t\tPROTO((REAL_VALUE_TYPE,\n+\t\t\t\t\t       enum machine_mode));\n+#endif\n+#endif\n+\n+/* At the end of a function, forget the memory-constants\n+   previously made for CONST_DOUBLEs.  Mark them as not on real_constant_chain.\n+   Also clear out real_constant_chain and clear out all the chain-pointers.  */\n+extern void clear_const_double_mem\tPROTO((void));\n+\n+/* Start deferring output of subconstants.  */\n+extern void defer_addressed_constants\tPROTO((void));\n+\n+/* Stop deferring output of subconstants,\n+   and output now all those that have been deferred.  */\n+extern void output_deferred_addressed_constants PROTO((void));\n+\n+/* Initialize constant pool hashing for next function.  */\n+extern void init_const_rtx_hash_table\tPROTO((void));\n+\n+/* Return the size of the constant pool.  */\n+extern int get_pool_size\t\tPROTO((void));\n+\n+#ifdef TREE_CODE\n+/* Write all the constants in the constant pool.  */\n+extern void output_constant_pool\tPROTO((char *, tree));\n+\n+/* Output assembler code for constant EXP to FILE, with no label.\n+   This includes the pseudo-op such as \".int\" or \".byte\", and a newline.\n+   Assumes output_addressed_constants has been done on EXP already.\n+\n+   Generate exactly SIZE bytes of assembler data, padding at the end\n+   with zeros if necessary.  SIZE must always be specified.  */\n+extern void output_constant\t\tPROTO((tree, int));\n+#endif\n \n /* When outputting assembler code, indicates which alternative\n    of the constraints was actually satisfied.  */\n extern int which_alternative;\n \n+#ifdef RTX_CODE\n /* When outputting delayed branch sequences, this rtx holds the\n    sequence being output.  It is null when no delayed branch\n    sequence is being output, so it can be used as a test in the\n    insn output code.\n \n    This variable is defined  in final.c.  */\n extern rtx final_sequence;\n+#endif\n \n /* Number of bytes of args popped by function being compiled on its return.\n    Zero if no bytes are to be popped.\n@@ -205,6 +381,7 @@ extern CUMULATIVE_ARGS current_function_args_info;\n \n extern char *current_function_name;\n \n+#ifdef RTX_CODE\n /* If non-zero, an RTL expression for that location at which the current\n    function returns its result.  Usually equal to\n    DECL_RTL (DECL_RESULT (current_function_decl)).  */\n@@ -215,6 +392,7 @@ extern rtx current_function_return_rtx;\n    delay list for them is recorded here.  */\n \n extern rtx current_function_epilogue_delay_list;\n+#endif\n \n /* Nonzero means generate position-independent code.\n    This is not fully implemented yet.  */"}]}