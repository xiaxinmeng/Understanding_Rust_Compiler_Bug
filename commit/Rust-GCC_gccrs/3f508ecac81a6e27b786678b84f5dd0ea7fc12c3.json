{"sha": "3f508ecac81a6e27b786678b84f5dd0ea7fc12c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Y1MDhlY2FjODFhNmUyN2I3ODY2NzhiODRmNWRkMGVhN2ZjMTJjMw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-05-30T11:09:16Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-05-30T11:09:16Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1128", "tree": {"sha": "9dfed3dd379d73027c0150d10fc190ed73690456", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9dfed3dd379d73027c0150d10fc190ed73690456"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f508ecac81a6e27b786678b84f5dd0ea7fc12c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f508ecac81a6e27b786678b84f5dd0ea7fc12c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f508ecac81a6e27b786678b84f5dd0ea7fc12c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f508ecac81a6e27b786678b84f5dd0ea7fc12c3/comments", "author": null, "committer": null, "parents": [{"sha": "cb9186f97f4fc5c4204bdcc25dbc620b425cbc67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb9186f97f4fc5c4204bdcc25dbc620b425cbc67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb9186f97f4fc5c4204bdcc25dbc620b425cbc67"}], "stats": {"total": 53, "additions": 45, "deletions": 8}, "files": [{"sha": "492987f708de1c407c7ba4a3647f43e4d4abb88c", "filename": "gcc/combine.c", "status": "modified", "additions": 45, "deletions": 8, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f508ecac81a6e27b786678b84f5dd0ea7fc12c3/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f508ecac81a6e27b786678b84f5dd0ea7fc12c3/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=3f508ecac81a6e27b786678b84f5dd0ea7fc12c3", "patch": "@@ -907,10 +907,14 @@ combinable_i3pat (i3, loc, i2dest, i1dest, i1_not_in_src, pi3dest_killed)\n       if ((inner_dest != dest\n \t   && (reg_overlap_mentioned_p (i2dest, inner_dest)\n \t       || (i1dest && reg_overlap_mentioned_p (i1dest, inner_dest))))\n-\t  /* This is the same test done in can_combine_p.  */\n+\t  /* This is the same test done in can_combine_p except that we\n+\t     allow a hard register with SMALL_REGISTER_CLASSES if SRC is a\n+\t     CALL operation.  */\n \t  || (GET_CODE (inner_dest) == REG\n \t      && REGNO (inner_dest) < FIRST_PSEUDO_REGISTER\n-#ifndef SMALL_REGISTER_CLASSES\n+#ifdef SMALL_REGISTER_CLASSES\n+\t      && GET_CODE (src) != CALL\n+#else\n \t      && ! HARD_REGNO_MODE_OK (REGNO (inner_dest),\n \t\t\t\t       GET_MODE (inner_dest))\n #endif\n@@ -1478,7 +1482,10 @@ try_combine (i3, i2, i1)\n \t\t\t       i3);\n \n       if (m_split && GET_CODE (m_split) == SEQUENCE\n-\t  && XVECLEN (m_split, 0) == 2)\n+\t  && XVECLEN (m_split, 0) == 2\n+\t  && (next_real_insn (i2) == i3\n+\t      || ! use_crosses_set_p (PATTERN (XVECEXP (m_split, 0, 0)),\n+\t\t\t\t      INSN_CUID (i2))))\n \t{\n \t  newi2pat = PATTERN (XVECEXP (m_split, 0, 0));\n \t  newpat = PATTERN (XVECEXP (m_split, 0, 1));\n@@ -3016,11 +3023,11 @@ subst (x, from, to, in_dest, unique_copy)\n \t     if only the low-order bit is significant in X (such as when\n \t     X is a ZERO_EXTRACT of one bit.  Similarly, we can convert\n \t     EQ to (xor X 1).  */\n-\t  if (new_code == NE && mode != VOIDmode\n+\t  if (new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n \t      && op1 == const0_rtx\n \t      && significant_bits (op0, GET_MODE (op0)) == 1)\n \t    return gen_lowpart_for_combine (mode, op0);\n-\t  else if (new_code == EQ && mode != VOIDmode\n+\t  else if (new_code == EQ && GET_MODE_CLASS (mode) == MODE_INT\n \t\t   && op1 == const0_rtx\n \t\t   && significant_bits (op0, GET_MODE (op0)) == 1)\n \t    return gen_rtx_combine (XOR, mode,\n@@ -3033,7 +3040,7 @@ subst (x, from, to, in_dest, unique_copy)\n \t     to (neg x) if only the low-order bit of X is significant.\n \t     This converts (ne (zero_extract X 1 Y) 0) to\n \t     (sign_extract X 1 Y).  */\n-\t  if (new_code == NE && mode != VOIDmode\n+\t  if (new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n \t      && op1 == const0_rtx\n \t      && significant_bits (op0, GET_MODE (op0)) == 1)\n \t    {\n@@ -3048,7 +3055,7 @@ subst (x, from, to, in_dest, unique_copy)\n \t     where C puts the bit in the sign bit.  Remove any AND with\n \t     STORE_FLAG_VALUE when we are done, since we are only going to\n \t     test the sign bit.  */\n-\t  if (new_code == NE && mode != VOIDmode\n+\t  if (new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n \t      && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_INT\n \t      && STORE_FLAG_VALUE == 1 << (GET_MODE_BITSIZE (mode) - 1)\n \t      && op1 == const0_rtx\n@@ -5140,7 +5147,9 @@ significant_bits (x, mode)\n     case LT:  case LTU:\n     case GE:  case GEU:\n     case LE:  case LEU:\n-      significant = 1;\n+\n+      if (GET_MODE_CLASS (mode) == MODE_INT)\n+\tsignificant = 1;\n \n       /* A comparison operation only sets the bits given by its mode.  The\n \t rest are set undefined.  */\n@@ -6010,6 +6019,33 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t      continue;\n \t    }\n \n+\t  /* If we have (xshiftrt (plus FOO BAR) C), and the only bits\n+\t     significant in BAR are those being shifted out and those\n+\t     bits are known zero in FOO, we can replace the PLUS with FOO.\n+\t     Similarly in the other operand order.  This code occurs when\n+\t     we are computing the size of a variable-size array.  */\n+\n+\t  if ((code == ASHIFTRT || code == LSHIFTRT)\n+\t      && count < HOST_BITS_PER_INT\n+\t      && significant_bits (XEXP (varop, 1), result_mode) >> count == 0\n+\t      && (significant_bits (XEXP (varop, 1), result_mode)\n+\t\t  & significant_bits (XEXP (varop, 0), result_mode)) == 0)\n+\t    {\n+\t      varop = XEXP (varop, 0);\n+\t      continue;\n+\t    }\n+\t  else if ((code == ASHIFTRT || code == LSHIFTRT)\n+\t\t   && count < HOST_BITS_PER_INT\n+\t\t   && 0 == (significant_bits (XEXP (varop, 0), result_mode)\n+\t\t\t    >> count)\n+\t\t   && 0 == (significant_bits (XEXP (varop, 0), result_mode)\n+\t\t\t    & significant_bits (XEXP (varop, 1),\n+\t\t\t\t\t\t result_mode)))\n+\t    {\n+\t      varop = XEXP (varop, 1);\n+\t      continue;\n+\t    }\n+\n \t  /* (ashift (plus foo C) N) is (plus (ashift foo N) C').  */\n \t  if (code == ASHIFT\n \t      && GET_CODE (XEXP (varop, 1)) == CONST_INT\n@@ -6970,6 +7006,7 @@ simplify_comparison (code, pop0, pop1)\n \t  if (code == NE\n \t      || (code == EQ && reversible_comparison_p (op0))\n \t      || (GET_MODE_BITSIZE (GET_MODE (op0)) <= HOST_BITS_PER_INT\n+\t\t  && GET_MODE_CLASS (GET_MODE (op0)) == MODE_INT\n \t\t  && (STORE_FLAG_VALUE\n \t\t      & (1 << (GET_MODE_BITSIZE (GET_MODE (op0)) - 1)))\n \t\t  && (code == LT"}]}