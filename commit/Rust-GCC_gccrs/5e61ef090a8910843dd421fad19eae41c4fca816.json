{"sha": "5e61ef090a8910843dd421fad19eae41c4fca816", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU2MWVmMDkwYTg5MTA4NDNkZDQyMWZhZDE5ZWFlNDFjNGZjYTgxNg==", "commit": {"author": {"name": "Thomas Quinot", "email": "quinot@adacore.com", "date": "2005-11-15T13:53:22Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-11-15T13:53:22Z"}, "message": "decl.c: Factor common code to build a storage type for an unconstrained object from a...\n\n2005-11-14  Thomas Quinot  <quinot@adacore.com>\n\t    Olivier Hainque  <hainque@adacore.com>\n\t    Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* decl.c:\n\tFactor common code to build a storage type for an unconstrained object\n\tfrom a fat or thin pointer type and a constrained object type.\n\t(annotate_value): Handle BIT_AND_EXPR.\n\t(annotate_rep): Don't restrict the back annotation of inherited\n\tcomponents to the type_annotate_only case.\n\t(gnat_to_gnu_entity) <E_Array_Type>: Do not invoke create_type_decl if\n\twe are not defining the type.\n\t<E_Record_Type>: Likewise.\n\t(gnat_to_gnu_entity) <object, renaming>: Adjust comments and structure\n\tto get advantage of the new maybe_stabilize_reference interface, to\n\tensure that what we reference is indeed stabilized instead of relying\n\ton assumptions on what the stabilizer does.\n\t(gnat_to_gnu_entity) <E_Incomplete_Type>: If the entity is an incomplete\n\ttype imported through a limited_with clause, use its non-limited view.\n\t(Has_Stdcall_Convention): New macro, to centralize the Windows vs others\n\tdifferentiation.\n\t(gnat_to_gnu_entity): Use Has_Stdcall_Convention instead of a spread mix\n\tof #if sections + explicit comparisons of convention identifiers.\n\t(gnat_to_gnu_entity) <E_Variable>: Decrement force_global if necessary\n\tbefore early-returning for certain types when code generation is\n\tdisabled.\n\t(gnat_to_gnu_entity) <object>: Adjust comment attached to the\n\tnullification of gnu_expr we do for objects with address clause and\n\tthat we are not defining.\n\t(elaborate_expression_1): Do not create constants when creating\n\tvariables needed by the debug info: the dwarf2 writer considers that\n\tCONST_DECLs is used only to represent enumeration constants, and emits\n\tnothing for them.\n\t(gnat_to_gnu_entity) <object>: When turning a non-definition of an\n\tobject with an address clause into an indirect reference, drop the\n\tinitializing expression.\n\tInclude \"expr.h\".\n\t(STACK_CHECK_BUILTIN): Delete.\n\t(STACK_CHECK_PROBE_INTERVAL): Likewise.\n\t(STACK_CHECK_MAX_FRAME_SIZE): Likewise.\n\t(STACK_CHECK_MAX_VAR_SIZE): Likewise.\n\t(gnat_to_gnu_entity): If gnat_entity is a renaming, do not mark the tree\n\tcorresponding to the renamed object as ignored for debugging purposes.\n\n\t* trans.c (tree_transform, case N_Attribute_Reference, case Attr_Size &\n\trelated): For a prefix that is a dereference of a fat or thin pointer,\n\tif there is an actual subtype provided by the front-end, use that\n\tsubtype to build an actual type with bounds template.\n\t(tree_transform, case N_Free_Statement): If an Actual_Designated_Subtype\n\tis provided by the front-end, use that subtype to compute the size of\n\tthe deallocated object.\n\t(gnat_to_gnu): When adding a statement into an elaboration procedure,\n\tcheck for a potential violation of a No_Elaboration_Code restriction.\n\t(maybe_stabilize_reference): New function, like gnat_stabilize_reference\n\twith extra arguments to control whether to recurse through non-values\n\tand to let the caller know if the stabilization has succeeded.\n\t(gnat_stabilize_reference): Now a simple wrapper around\n\tmaybe_stabilize, for common uses without restriction on lvalues and\n\twithout need to check for the success indication.\n\t(gnat_to_gnu, call_to_gnu): Adjust calls to gnat_stabilize_reference, to\n\tpass false instead of 0 as the FORCE argument which is a bool.\n\t(Identifier_to_gnu): Remove checks ensuring that an renamed object\n\tattached to a renaming pointer has been properly stabilized, as no such\n\tobject is attached otherwise.\n\t(call_to_gnu): Invoke create_var_decl to create the temporary when the\n\tfunction uses the \"target pointer\" return mechanism.\n\tReinstate conversion of the actual to the type of the formal\n\tparameter before any other specific treatment based on the passing\n\tmechanism. This turns out to be necessary in order for PLACEHOLDER\n\tsubstitution to work properly when the latter type is unconstrained.\n\n\t* gigi.h (build_unc_object_type_from_ptr): New subprogram, factoring a\n\tcommon pattern.\n\t(maybe_stabilize_reference): New function, like gnat_stabilize_reference\n\twith extra arguments to control whether to recurse through non-values\n\tand to let the caller know if the stabilization has succeeded.\n\n\t* utils2.c (gnat_build_constructor): Only sort the fields for possible\n\tstatic output of record constructor if all the components are constant.\n\t(gnat_build_constructor): For a record type, sort the list of field\n\tinitializers in increasing bit position order.\n\tFactor common code to build a storage type for an unconstrained object\n\tfrom a fat or thin pointer type and a constrained object type.\n\t(build_unary_op) <ADDR_EXPR>: Always recurse down conversions between\n\ttypes variants, and process special cases of VIEW_CONVERT expressions\n\tas their NOP_EXPR counterpart to ensure we get to the\n\tCORRESPONDING_VARs associated with CONST_DECls.\n\t(build_binary_op) <MODIFY_EXPR>: Do not strip VIEW_CONVERT_EXPRs\n\ton the right-hand side.\n\n\t* utils.c (build_unc_object_type_from_ptr): New subprogram, factoring\n\ta common pattern.\n\t(convert) <VIEW_CONVERT_EXPR>: Return the inner operand directly if we\n\tare converting back to its original type.\n\t(convert) <JM input>: Fallthrough regular conversion code instead of\n\textracting the object if converting to a type variant.\n\t(create_var_decl): When a variable has an initializer requiring code\n\tgeneration and we are at the top level, check for a potential violation\n\tof a No_Elaboration_Code restriction.\n\t(create_var_decl): call expand_decl for CONST_DECLs, to set MODE, ALIGN\n\tSIZE and SIZE_UNIT which we need for later back-annotations.\n\t* utils.c: (convert) <STRING_CST>: Remove obsolete code.\n\t<VIEW_CONVERT_EXPR>: Do not lift the conversion if the target type\n\tis an unchecked union.\n\t(pushdecl): Set DECL_NO_STATIC_CHAIN on imported nested functions.\n\t(convert) <VIEW_CONVERT_EXPR>: When the types have the same\n\tmain variant, just replace the VIEW_CONVERT_EXPR.\n\t<UNION_TYPE>: Revert 2005-03-02 change.\n\n\t* repinfo.h, repinfo.ads: Add tcode for BIT_AND_EXPR.\n\n\t* repinfo.adb (Print_Expr, Rep_Value): Handle Bit_And_Expressions.\n\nFrom-SVN: r106961", "tree": {"sha": "539f60872b22a416a9e54b3d9d16de22a8182921", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/539f60872b22a416a9e54b3d9d16de22a8182921"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e61ef090a8910843dd421fad19eae41c4fca816", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e61ef090a8910843dd421fad19eae41c4fca816", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e61ef090a8910843dd421fad19eae41c4fca816", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e61ef090a8910843dd421fad19eae41c4fca816/comments", "author": null, "committer": null, "parents": [{"sha": "fda5d6d4ff7de017167de98a20ffc4110f766795", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fda5d6d4ff7de017167de98a20ffc4110f766795", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fda5d6d4ff7de017167de98a20ffc4110f766795"}], "stats": {"total": 866, "additions": 551, "deletions": 315}, "files": [{"sha": "bbbb471a3ae9a6592a82601da0728c25198c9c49", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 159, "deletions": 118, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e61ef090a8910843dd421fad19eae41c4fca816/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e61ef090a8910843dd421fad19eae41c4fca816/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=5e61ef090a8910843dd421fad19eae41c4fca816", "patch": "@@ -35,6 +35,7 @@\n #include \"ggc.h\"\n #include \"obstack.h\"\n #include \"target.h\"\n+#include \"expr.h\"\n \n #include \"ada.h\"\n #include \"types.h\"\n@@ -52,21 +53,14 @@\n #include \"ada-tree.h\"\n #include \"gigi.h\"\n \n-/* Provide default values for the macros controlling stack checking.\n-   This is copied from GCC's expr.h.  */\n+/* Convention_Stdcall should be processed in a specific way on Windows targets\n+   only.  The macro below is a helper to avoid having to check for a Windows\n+   specific attribute throughout this unit.  */\n \n-#ifndef STACK_CHECK_BUILTIN\n-#define STACK_CHECK_BUILTIN 0\n-#endif\n-#ifndef STACK_CHECK_PROBE_INTERVAL\n-#define STACK_CHECK_PROBE_INTERVAL 4096\n-#endif\n-#ifndef STACK_CHECK_MAX_FRAME_SIZE\n-#define STACK_CHECK_MAX_FRAME_SIZE \\\n-  (STACK_CHECK_PROBE_INTERVAL - UNITS_PER_WORD)\n-#endif\n-#ifndef STACK_CHECK_MAX_VAR_SIZE\n-#define STACK_CHECK_MAX_VAR_SIZE (STACK_CHECK_MAX_FRAME_SIZE / 100)\n+#if TARGET_DLLIMPORT_DECL_ATTRIBUTES\n+#define Has_Stdcall_Convention(E) (Convention (E) == Convention_Stdcall)\n+#else\n+#define Has_Stdcall_Convention(E) (0)\n #endif\n \n /* These two variables are used to defer recursively expanding incomplete\n@@ -531,6 +525,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    || TREE_CODE (gnu_type) == VOID_TYPE)\n \t  {\n \t    gcc_assert (type_annotate_only);\n+\t    if (this_global)\n+\t      force_global--;\n \t    return error_mark_node;\n \t  }\n \n@@ -670,11 +666,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t{\n \t  tree gnu_fat\n \t    = TREE_TYPE (gnat_to_gnu_type (Base_Type (Etype (gnat_entity))));\n-\t  tree gnu_temp_type\n-\t    = TREE_TYPE (TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (gnu_fat))));\n \n \t  gnu_type\n-\t    = build_unc_object_type (gnu_temp_type, gnu_type,\n+\t    = build_unc_object_type_from_ptr (gnu_fat, gnu_type,\n \t\t\t\t     concat_id_with_name (gnu_entity_id,\n \t\t\t\t\t\t\t  \"UNC\"));\n \t}\n@@ -729,18 +723,18 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t     (TYPE_SIZE (TREE_TYPE (TYPE_FIELDS (gnu_type)))))))\n \t  gnu_expr = convert (gnu_type, gnu_expr);\n \n-\t/* See if this is a renaming.  If this is a constant renaming, treat\n-\t   it as a normal variable whose initial value is what is being\n-\t   renamed.  We cannot do this if the type is unconstrained or\n-\t   class-wide.\n+\t/* See if this is a renaming, and handle appropriately depending on\n+\t   what is renamed and in which context.  There are three major\n+\t   cases:\n+\n+\t   1/ This is a constant renaming and we can just make an object\n+\t      with what is renamed as its initial value,\n \n-\t   Otherwise, if what we are renaming is a reference, we can simply\n-\t   return a stabilized version of that reference, after forcing any\n-\t   SAVE_EXPRs to be evaluated.  But, if this is at global level, we\n-\t   can only do this if we know no SAVE_EXPRs will be made.\n+\t   2/ We can reuse a stabilized version of what is renamed in place\n+              of the renaming,\n \n-\t   Otherwise, make this into a constant pointer to the object we are\n-\t   to rename.  */\n+\t   3/ If neither 1 or 2 applies, we make the renaming entity a constant\n+              pointer to what is being renamed.  */\n \n \tif (Present (Renamed_Object (gnat_entity)))\n \t  {\n@@ -756,6 +750,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\tgnu_type = TREE_TYPE (gnu_expr);\n \t      }\n \n+\t    /* Case 1: If this is a constant renaming, treat it as a normal\n+\t       object whose initial value is what is being renamed.  We cannot\n+\t       do this if the type is unconstrained or class-wide.  */\n \t    if (const_flag\n \t\t&& !TREE_SIDE_EFFECTS (gnu_expr)\n \t\t&& TREE_CODE (gnu_type) != UNCONSTRAINED_ARRAY_TYPE\n@@ -764,49 +761,100 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n                 && !Is_Array_Type (Etype (gnat_entity)))\n \t      ;\n \n-\t    /* If this is a declaration or reference that we can stabilize,\n-\t       just use that declaration or reference as this entity unless\n-\t       the latter has to be materialized.  */\n-\t    else if ((DECL_P (gnu_expr) || REFERENCE_CLASS_P (gnu_expr))\n-\t\t     && !Materialize_Entity (gnat_entity)\n-\t\t     && (!global_bindings_p ()\n-\t\t\t || (staticp (gnu_expr)\n-\t\t\t     && !TREE_SIDE_EFFECTS (gnu_expr))))\n-\t      {\n-\t\tgnu_decl = gnat_stabilize_reference (gnu_expr, true);\n-\t\tsave_gnu_tree (gnat_entity, gnu_decl, true);\n-\t\tsaved = true;\n-\t\tbreak;\n-\t      }\n-\n-\t    /* Otherwise, make this into a constant pointer to the object we\n-\t       are to rename and attach the object to the pointer.  We need\n-\t       to stabilize too since the renaming evaluation may directly\n-\t       reference the renamed object instead of the pointer we will\n-\t       attach it to.  We don't want variables in the expression to\n-\t       be evaluated every time the renaming is used, since their\n-\t       value may change in between.  */\n+\t    /* Otherwise, see if we can proceed with a stabilized version of\n+\t       the renamed entity or if we need to make a pointer.  */\n \t    else\n \t      {\n-\t\tbool has_side_effects = TREE_SIDE_EFFECTS (gnu_expr);\n-\t\tinner_const_flag = TREE_READONLY (gnu_expr);\n-\t\tconst_flag = true;\n-\t\tgnu_type = build_reference_type (gnu_type);\n-\t\trenamed_obj = gnat_stabilize_reference (gnu_expr, true);\n-\t\tgnu_expr = build_unary_op (ADDR_EXPR, gnu_type, renamed_obj);\n-\n-\t\tif (!global_bindings_p ())\n+\t\tbool stabilized;\n+\t\ttree maybe_stable_expr = NULL_TREE;\n+\n+\t\t/* Case 2: If the renaming entity need not be materialized and\n+\t\t   the renamed expression is something we can stabilize, use\n+\t\t   that for the renaming after forcing the evaluation of any\n+\t\t   SAVE_EXPR.  At the global level, we can only do this if we\n+\t\t   know no SAVE_EXPRs will be made.  */\n+\t\tif (!Materialize_Entity (gnat_entity)\n+\t\t    && (!global_bindings_p ()\n+\t\t\t|| (staticp (gnu_expr)\n+\t\t\t    && !TREE_SIDE_EFFECTS (gnu_expr))))\n \t\t  {\n-\t\t    /* If the original expression had side effects, put a\n-\t\t       SAVE_EXPR around this whole thing.  */\n-\t\t    if (has_side_effects)\n-\t\t      gnu_expr = save_expr (gnu_expr);\n+\t\t    maybe_stable_expr\n+\t\t      = maybe_stabilize_reference (gnu_expr, true, false,\n+\t\t\t\t\t\t   &stabilized);\n+\n+\t\t    if (stabilized)\n+\t\t      {\n+\t\t\tgnu_decl = maybe_stable_expr;\n+\t\t\tsave_gnu_tree (gnat_entity, gnu_decl, true);\n+\t\t\tsaved = true;\n+\t\t\tbreak;\n+\t\t      }\n \n-\t\t    add_stmt (gnu_expr);\n+\t\t    /* The stabilization failed.  Keep maybe_stable_expr\n+\t\t       untouched here to let the pointer case below know\n+\t\t       about that failure.  */\n \t\t  }\n \n-\t\tgnu_size = NULL_TREE;\n-\t\tused_by_ref = true;\n+\t\t/* Case 3: Make this into a constant pointer to the object we\n+\t\t   are to rename and attach the object to the pointer if it is\n+\t\t   an lvalue that can be stabilized.\n+\n+\t\t   From the proper scope, attached objects will be referenced\n+\t\t   directly instead of indirectly via the pointer to avoid\n+\t\t   subtle aliasing problems with non addressable entities.\n+\t\t   They have to be stable because we must not evaluate the\n+\t\t   variables in the expression every time the renaming is used.\n+\t\t   They also have to be lvalues because the context in which\n+\t\t   they are reused sometimes requires so.  We call pointers\n+\t\t   with an attached object \"renaming\" pointers.\n+\n+\t\t   In the rare cases where we cannot stabilize the renamed\n+\t\t   object, we just make a \"bare\" pointer, and the renamed\n+\t\t   entity is always accessed indirectly through it.  */\n+\t\t{\n+\t\t  bool has_side_effects = TREE_SIDE_EFFECTS (gnu_expr);\n+\t\t  inner_const_flag = TREE_READONLY (gnu_expr);\n+\t\t  const_flag = true;\n+\t\t  gnu_type = build_reference_type (gnu_type);\n+\n+\t\t  /* If a previous attempt at unrestricted\n+\t\t     stabilization failed, there is no point trying\n+\t\t     again and we can reuse the result without\n+\t\t     attaching it to the pointer.  */\n+\t\t  if (maybe_stable_expr)\n+\t\t    ;\n+\n+\t\t  /* Otherwise, try to stabilize now, restricting to\n+\t\t     lvalues only, and attach the expression to the pointer\n+\t\t     if the stabilization succeeds.  */\n+\t\t  else\n+\t\t    {\n+\t\t      maybe_stable_expr\n+\t\t\t= maybe_stabilize_reference (gnu_expr, true, true,\n+\t\t\t\t\t\t     &stabilized);\n+\n+\t\t      if (stabilized)\n+\t\t\trenamed_obj = maybe_stable_expr;\n+\t\t      /* Attaching is actually performed downstream, as soon\n+\t\t\t as we have a DECL for the pointer we make.  */\n+\t\t    }\n+\n+\t\t  gnu_expr\n+\t\t    = build_unary_op (ADDR_EXPR, gnu_type, maybe_stable_expr);\n+\n+\t\t  if (!global_bindings_p ())\n+\t\t    {\n+\t\t      /* If the original expression had side effects, put a\n+\t\t\t SAVE_EXPR around this whole thing.  */\n+\t\t      if (has_side_effects)\n+\t\t\tgnu_expr = save_expr (gnu_expr);\n+\n+\t\t      add_stmt (gnu_expr);\n+\t\t    }\n+\n+\t\t  gnu_size = NULL_TREE;\n+\t\t  used_by_ref = true;\n+\t\t}\n \t      }\n \t  }\n \n@@ -894,10 +942,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   imported.  */\n \tif ((!definition && Present (Address_Clause (gnat_entity)))\n \t    || (Is_Imported (gnat_entity)\n-\t\t&& Convention (gnat_entity) == Convention_Stdcall))\n+\t\t&& Has_Stdcall_Convention (gnat_entity)))\n \t  {\n \t    gnu_type = build_reference_type (gnu_type);\n \t    gnu_size = NULL_TREE;\n+\n+\t    gnu_expr = NULL_TREE;\n+\t    /* No point in taking the address of an initializing expression\n+\t       that isn't going to be used.  */\n+\n \t    used_by_ref = true;\n \t  }\n \n@@ -1495,19 +1548,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tTYPE_READONLY (gnu_template_type) = 1;\n \n \t/* Make a node for the array.  If we are not defining the array\n-\t   suppress expanding incomplete types and save the node as the type\n-\t   for GNAT_ENTITY.  */\n+\t   suppress expanding incomplete types.  */\n \tgnu_type = make_node (UNCONSTRAINED_ARRAY_TYPE);\n+\n \tif (!definition)\n-\t  {\n-\t    defer_incomplete_level++;\n-\t    this_deferred = this_made_decl = true;\n-\t    gnu_decl = create_type_decl (gnu_entity_id, gnu_type, attr_list,\n-\t\t\t\t\t !Comes_From_Source (gnat_entity),\n-\t\t\t\t\t debug_info_p, gnat_entity);\n-\t    save_gnu_tree (gnat_entity, gnu_decl, false);\n-\t    saved = true;\n-\t  }\n+\t  defer_incomplete_level++, this_deferred = true;\n \n \t/* Build the fat pointer type.  Use a \"void *\" object instead of\n \t   a pointer to the array type since we don't have the array type\n@@ -2310,9 +2355,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  }\n \n \t/* Make a node for the record.  If we are not defining the record,\n-\t   suppress expanding incomplete types and save the node as the type\n-\t   for GNAT_ENTITY.  We use the same RECORD_TYPE as for a dummy type\n-\t   and reset TYPE_DUMMY_P to show it's no longer a dummy.\n+\t   suppress expanding incomplete types.  We use the same RECORD_TYPE\n+\t   as for a dummy type and reset TYPE_DUMMY_P to show it's no longer\n+\t   a dummy.\n \n \t   It is very tempting to delay resetting this bit until we are done\n \t   with completing the type, e.g. to let possible intermediate\n@@ -2335,15 +2380,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tTYPE_PACKED (gnu_type) = packed || has_rep;\n \n \tif (!definition)\n-\t  {\n-\t    defer_incomplete_level++;\n-\t    this_deferred = true;\n-\t    gnu_decl = create_type_decl (gnu_entity_id, gnu_type, attr_list,\n-\t\t\t\t\t !Comes_From_Source (gnat_entity),\n-\t\t\t\t\t debug_info_p, gnat_entity);\n-\t    save_gnu_tree (gnat_entity, gnu_decl, false);\n-\t    this_made_decl = saved = true;\n-\t  }\n+\t  defer_incomplete_level++, this_deferred = true;\n \n \t/* If both a size and rep clause was specified, put the size in\n \t   the record type now so that it can get the proper mode.  */\n@@ -3642,8 +3679,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tif (list_length (gnu_return_list) == 1)\n \t  gnu_return_type = TREE_TYPE (TREE_PURPOSE (gnu_return_list));\n \n-#ifdef TARGET_DLLIMPORT_DECL_ATTRIBUTES\n-\tif (Convention (gnat_entity) == Convention_Stdcall)\n+\tif (Has_Stdcall_Convention (gnat_entity))\n \t  {\n \t    struct attrib *attr\n \t      = (struct attrib *) xmalloc (sizeof (struct attrib));\n@@ -3655,7 +3691,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    attr->error_point = gnat_entity;\n \t    attr_list = attr;\n \t  }\n-#endif\n \n \t/* Both lists ware built in reverse.  */\n \tgnu_param_list = nreverse (gnu_param_list);\n@@ -3766,14 +3801,23 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t compiling, then just get the type from its Etype.  */\n       if (No (Full_View (gnat_entity)))\n \t{\n-\t  /* If this is an incomplete type with no full view, it must\n-\t     be a Taft Amendement type, so just return a dummy type.  */\n+\t  /* If this is an incomplete type with no full view, it must be\n+\t     either a limited view brought in by a limited_with clause, in\n+\t     which case we use the non-limited view, or a Taft Amendement\n+\t     type, in which case we just return a dummy type.  */\n \t  if (kind == E_Incomplete_Type)\n-\t    gnu_type = make_dummy_type (gnat_entity);\n+\t    {\n+\t      if (From_With_Type (gnat_entity)\n+\t\t  && Present (Non_Limited_View (gnat_entity)))\n+\t\tgnu_decl = gnat_to_gnu_entity (Non_Limited_View (gnat_entity),\n+\t\t\t\t\t       NULL_TREE, 0);\n+\t      else\n+\t\tgnu_type = make_dummy_type (gnat_entity);\n+\t    }\n \n-          else if (Present (Underlying_Full_View (gnat_entity)))\n-             gnu_decl = gnat_to_gnu_entity (Underlying_Full_View (gnat_entity),\n-\t\t\t\t\t    NULL_TREE, 0);\n+\t  else if (Present (Underlying_Full_View (gnat_entity)))\n+\t    gnu_decl = gnat_to_gnu_entity (Underlying_Full_View (gnat_entity),\n+\t\t\t\t\t   NULL_TREE, 0);\n \t  else\n \t    {\n \t      gnu_decl = gnat_to_gnu_entity (Etype (gnat_entity),\n@@ -4087,7 +4131,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n     DECL_ARTIFICIAL (gnu_decl) = 1;\n \n   if (!debug_info_p && DECL_P (gnu_decl)\n-      && TREE_CODE (gnu_decl) != FUNCTION_DECL)\n+      && TREE_CODE (gnu_decl) != FUNCTION_DECL\n+      && No (Renamed_Object (gnat_entity)))\n     DECL_IGNORED_P (gnu_decl) = 1;\n \n   /* If we haven't already, associate the ..._DECL node that we just made with\n@@ -4703,9 +4748,9 @@ elaborate_expression_1 (Node_Id gnat_expr, Entity_Id gnat_entity,\n     gnu_decl\n       = create_var_decl (create_concat_name (gnat_entity,\n \t\t\t\t\t     IDENTIFIER_POINTER (gnu_name)),\n-\t\t\t NULL_TREE, TREE_TYPE (gnu_expr), gnu_expr, true,\n-\t\t\t Is_Public (gnat_entity), !definition, false, NULL,\n-\t\t\t gnat_entity);\n+\t\t\t NULL_TREE, TREE_TYPE (gnu_expr), gnu_expr,\n+\t\t\t !need_debug, Is_Public (gnat_entity),\n+\t\t\t !definition, false, NULL, gnat_entity);\n \n   /* We only need to use this variable if we are in global context since GCC\n      can do the right thing in the local case.  */\n@@ -5812,6 +5857,7 @@ annotate_value (tree gnu_size)\n     case TRUTH_OR_EXPR:\t\ttcode = Truth_Or_Expr; break;\n     case TRUTH_XOR_EXPR:\ttcode = Truth_Xor_Expr; break;\n     case TRUTH_NOT_EXPR:\ttcode = Truth_Not_Expr; break;\n+    case BIT_AND_EXPR:\t\ttcode = Bit_And_Expr; break;\n     case LT_EXPR:\t\ttcode = Lt_Expr; break;\n     case LE_EXPR:\t\ttcode = Le_Expr; break;\n     case GT_EXPR:\t\ttcode = Gt_Expr; break;\n@@ -5898,8 +5944,7 @@ annotate_rep (Entity_Id gnat_entity, tree gnu_type)\n \t    Set_Esize (gnat_field,\n \t\t       annotate_value (DECL_SIZE (TREE_PURPOSE (gnu_entry))));\n \t  }\n-\telse if (type_annotate_only\n-\t\t && Is_Tagged_Type (gnat_entity)\n+\telse if (Is_Tagged_Type (gnat_entity)\n \t\t && Is_Derived_Type (gnat_entity))\n \t  {\n \t    /* If there is no gnu_entry, this is an inherited component whose\n@@ -6638,32 +6683,28 @@ rm_size (tree gnu_type)\n tree\n create_concat_name (Entity_Id gnat_entity, const char *suffix)\n {\n+  Entity_Kind kind = Ekind (gnat_entity);\n+\n   const char *str = (!suffix ? \"\" : suffix);\n   String_Template temp = {1, strlen (str)};\n   Fat_Pointer fp = {str, &temp};\n \n   Get_External_Name_With_Suffix (gnat_entity, fp);\n \n-#ifdef TARGET_DLLIMPORT_DECL_ATTRIBUTES\n   /* A variable using the Stdcall convention (meaning we are running\n      on a Windows box) live in a DLL. Here we adjust its name to use\n      the jump-table, the _imp__NAME contains the address for the NAME\n      variable. */\n-  {\n-    Entity_Kind kind = Ekind (gnat_entity);\n-    const char *prefix = \"_imp__\";\n-    int plen = strlen (prefix);\n+  if ((kind == E_Variable || kind == E_Constant)\n+      && Has_Stdcall_Convention (gnat_entity))\n+    {\n+      const char *prefix = \"_imp__\";\n+      int k, plen = strlen (prefix);\n \n-    if ((kind == E_Variable || kind == E_Constant)\n-\t&& Convention (gnat_entity) == Convention_Stdcall)\n-      {\n-\tint k;\n-\tfor (k = 0; k <= Name_Len; k++)\n-\t  Name_Buffer [Name_Len - k + plen] = Name_Buffer [Name_Len - k];\n-\tstrncpy (Name_Buffer, prefix, plen);\n-      }\n-  }\n-#endif\n+      for (k = 0; k <= Name_Len; k++)\n+\tName_Buffer [Name_Len - k + plen] = Name_Buffer [Name_Len - k];\n+      strncpy (Name_Buffer, prefix, plen);\n+    }\n \n   return get_identifier (Name_Buffer);\n }"}, {"sha": "6dd10ff821007ff73cd0da5e3d7b1b88cb16b9b2", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e61ef090a8910843dd421fad19eae41c4fca816/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e61ef090a8910843dd421fad19eae41c4fca816/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=5e61ef090a8910843dd421fad19eae41c4fca816", "patch": "@@ -248,9 +248,21 @@ extern void init_code_table (void);\n    called.  */\n extern Node_Id error_gnat_node;\n \n-/* This is equivalent to stabilize_reference in GCC's tree.c, but we know\n-   how to handle our new nodes and we take an extra argument that says\n-   whether to force evaluation of everything.  */\n+/* This is equivalent to stabilize_reference in GCC's tree.c, but we know how\n+   to handle our new nodes and we take extra arguments.\n+\n+   FORCE says whether to force evaluation of everything,\n+\n+   SUCCESS we set to true unless we walk through something we don't\n+   know how to stabilize, or through something which is not an lvalue\n+   and LVALUES_ONLY is true, in which cases we set to false.  */\n+extern tree maybe_stabilize_reference (tree ref, bool force, bool lvalues_only,\n+\t\t\t\t       bool *success);\n+\n+/* Wrapper around maybe_stabilize_reference, for common uses without\n+   lvalue restrictions and without need to examine the success\n+   indication.  */\n+\n extern tree gnat_stabilize_reference (tree ref, bool force);\n \n /* Highest number in the front-end node table.  */\n@@ -612,6 +624,11 @@ extern tree build_vms_descriptor (tree type, Mechanism_Type mech,\n extern tree build_unc_object_type (tree template_type, tree object_type,\n                                    tree name);\n \n+/* Same as build_unc_object_type, but taking a thin or fat pointer type\n+   instead of the template type. */\n+extern tree build_unc_object_type_from_ptr (tree thin_fat_ptr_type,\n+\t\t\t\t\t    tree object_type, tree name);\n+\n /* Update anything previously pointing to OLD_TYPE to point to NEW_TYPE.  In\n    the normal case this is just two adjustments, but we have more to do\n    if NEW is an UNCONSTRAINED_ARRAY_TYPE.  */"}, {"sha": "ba1646bfad9108aac2b68203fdec395e16e5665c", "filename": "gcc/ada/repinfo.adb", "status": "modified", "additions": 87, "deletions": 56, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e61ef090a8910843dd421fad19eae41c4fca816/gcc%2Fada%2Frepinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e61ef090a8910843dd421fad19eae41c4fca816/gcc%2Fada%2Frepinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frepinfo.adb?ref=5e61ef090a8910843dd421fad19eae41c4fca816", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1999-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1999-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -48,6 +48,8 @@ with Table;  use Table;\n with Uname;  use Uname;\n with Urealp; use Urealp;\n \n+with Ada.Unchecked_Conversion;\n+\n package body Repinfo is\n \n    SSU : constant := 8;\n@@ -61,17 +63,16 @@ package body Repinfo is\n    -- Representation of gcc Expressions --\n    ---------------------------------------\n \n-   --    This table is used only if Frontend_Layout_On_Target is False,\n-   --    so that gigi lays out dynamic size/offset fields using encoded\n-   --    gcc expressions.\n+   --    This table is used only if Frontend_Layout_On_Target is False, so that\n+   --    gigi lays out dynamic size/offset fields using encoded gcc\n+   --    expressions.\n \n-   --    A table internal to this unit is used to hold the values of\n-   --    back annotated expressions. This table is written out by -gnatt\n-   --    and read back in for ASIS processing.\n+   --    A table internal to this unit is used to hold the values of back\n+   --    annotated expressions. This table is written out by -gnatt and read\n+   --    back in for ASIS processing.\n \n-   --    Node values are stored as Uint values which are the negative of\n-   --    the node index in this table. Constants appear as non-negative\n-   --    Uint values.\n+   --    Node values are stored as Uint values using the negative of the node\n+   --    index in this table. Constants appear as non-negative Uint values.\n \n    type Exp_Node is record\n       Expr : TCode;\n@@ -104,28 +105,27 @@ package body Repinfo is\n    --  Identifier casing for current unit\n \n    Need_Blank_Line : Boolean;\n-   --  Set True if a blank line is needed before outputting any\n-   --  information for the current entity. Set True when a new\n-   --  entity is processed, and false when the blank line is output.\n+   --  Set True if a blank line is needed before outputting any information for\n+   --  the current entity. Set True when a new entity is processed, and false\n+   --  when the blank line is output.\n \n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n \n    function Back_End_Layout return Boolean;\n-   --  Test for layout mode, True = back end, False = front end. This\n-   --  function is used rather than checking the configuration parameter\n-   --  because we do not want Repinfo to depend on Targparm (for ASIS)\n+   --  Test for layout mode, True = back end, False = front end. This function\n+   --  is used rather than checking the configuration parameter because we do\n+   --  not want Repinfo to depend on Targparm (for ASIS)\n \n    procedure Blank_Line;\n    --  Called before outputting anything for an entity. Ensures that\n    --  a blank line precedes the output for a particular entity.\n \n    procedure List_Entities (Ent : Entity_Id);\n-   --  This procedure lists the entities associated with the entity E,\n-   --  starting with the First_Entity and using the Next_Entity link.\n-   --  If a nested package is found, entities within the package are\n-   --  recursively processed.\n+   --  This procedure lists the entities associated with the entity E, starting\n+   --  with the First_Entity and using the Next_Entity link. If a nested\n+   --  package is found, entities within the package are recursively processed.\n \n    procedure List_Name (Ent : Entity_Id);\n    --  List name of entity Ent in appropriate case. The name is listed with\n@@ -135,8 +135,8 @@ package body Repinfo is\n    --  List representation info for array type Ent\n \n    procedure List_Mechanisms (Ent : Entity_Id);\n-   --  List mechanism information for parameters of Ent, which is a\n-   --  subprogram, subprogram type, or an entry or entry family.\n+   --  List mechanism information for parameters of Ent, which is subprogram,\n+   --  subprogram type, or an entry or entry family.\n \n    procedure List_Object_Info (Ent : Entity_Id);\n    --  List representation info for object Ent\n@@ -155,30 +155,29 @@ package body Repinfo is\n    --  Output given number of spaces\n \n    procedure Write_Info_Line (S : String);\n-   --  Routine to write a line to Repinfo output file. This routine is\n-   --  passed as a special output procedure to Output.Set_Special_Output.\n-   --  Note that Write_Info_Line is called with an EOL character at the\n-   --  end of each line, as per the Output spec, but the internal call\n-   --  to the appropriate routine in Osint requires that the end of line\n-   --  sequence be stripped off.\n+   --  Routine to write a line to Repinfo output file. This routine is passed\n+   --  as a special output procedure to Output.Set_Special_Output. Note that\n+   --  Write_Info_Line is called with an EOL character at the end of each line,\n+   --  as per the Output spec, but the internal call to the appropriate routine\n+   --  in Osint requires that the end of line sequence be stripped off.\n \n    procedure Write_Mechanism (M : Mechanism_Type);\n    --  Writes symbolic string for mechanism represented by M\n \n    procedure Write_Val (Val : Node_Ref_Or_Val; Paren : Boolean := False);\n    --  Given a representation value, write it out. No_Uint values or values\n    --  dependent on discriminants are written as two question marks. If the\n-   --  flag Paren is set, then the output is surrounded in parentheses if\n-   --  it is other than a simple value.\n+   --  flag Paren is set, then the output is surrounded in parentheses if it is\n+   --  other than a simple value.\n \n    ---------------------\n    -- Back_End_Layout --\n    ---------------------\n \n    function Back_End_Layout return Boolean is\n    begin\n-      --  We have back end layout if the back end has made any entries in\n-      --  the table of GCC expressions, otherwise we have front end layout.\n+      --  We have back end layout if the back end has made any entries in the\n+      --  table of GCC expressions, otherwise we have front end layout.\n \n       return Rep_Table.Last > 0;\n    end Back_End_Layout;\n@@ -350,10 +349,10 @@ package body Repinfo is\n          while Present (E) loop\n             Need_Blank_Line := True;\n \n-            --  We list entities that come from source (excluding private\n-            --  or incomplete types or deferred constants, where we will\n-            --  list the info for the full view). If debug flag A is set,\n-            --  then all entities are listed\n+            --  We list entities that come from source (excluding private or\n+            --  incomplete types or deferred constants, where we will list the\n+            --  info for the full view). If debug flag A is set, then all\n+            --  entities are listed\n \n             if (Comes_From_Source (E)\n               and then not Is_Incomplete_Or_Private_Type (E)\n@@ -402,10 +401,9 @@ package body Repinfo is\n \n                end if;\n \n-               --  Recurse into nested package, but not if they are\n-               --  package renamings (in particular renamings of the\n-               --  enclosing package, as for some Java bindings and\n-               --  for generic instances).\n+               --  Recurse into nested package, but not if they are package\n+               --  renamings (in particular renamings of the enclosing package,\n+               --  as for some Java bindings and for generic instances).\n \n                if Ekind (E) = E_Package then\n                   if No (Renamed_Object (E)) then\n@@ -438,10 +436,10 @@ package body Repinfo is\n             E := Next_Entity (E);\n          end loop;\n \n-         --  For a package body, the entities of the visible subprograms\n-         --  are declared in the corresponding spec. Iterate over its\n-         --  entities in order to handle properly the subprogram bodies.\n-         --  Skip bodies in subunits, which are listed independently.\n+         --  For a package body, the entities of the visible subprograms are\n+         --  declared in the corresponding spec. Iterate over its entities in\n+         --  order to handle properly the subprogram bodies. Skip bodies in\n+         --  subunits, which are listed independently.\n \n          if Ekind (Ent) = E_Package_Body\n            and then Present (Corresponding_Spec (Find_Declaration (Ent)))\n@@ -583,6 +581,9 @@ package body Repinfo is\n                      Write_Str (\"not \");\n                      Print_Expr (Node.Op1);\n \n+                  when Bit_And_Expr =>\n+                     Binop (\" & \");\n+\n                   when Lt_Expr =>\n                      Binop (\" < \");\n \n@@ -801,9 +802,9 @@ package body Repinfo is\n                UI_Image (Sunit);\n             end if;\n \n-            --  If the record is not packed, then we know that all\n-            --  fields whose position is not specified have a starting\n-            --  normalized bit position of zero\n+            --  If the record is not packed, then we know that all fields whose\n+            --  position is not specified have a starting normalized bit\n+            --  position of zero\n \n             if Unknown_Normalized_First_Bit (Comp)\n               and then not Is_Packed (Ent)\n@@ -885,11 +886,11 @@ package body Repinfo is\n                UI_Write (Fbit);\n                Write_Str (\" .. \");\n \n-               --  Allowing Uint_0 here is a kludge, really this should be\n-               --  a fine Esize value but currently it means unknown, except\n-               --  that we know after gigi has back annotated that a size of\n-               --  zero is real, since otherwise gigi back annotates using\n-               --  No_Uint as the value to indicate unknown).\n+               --  Allowing Uint_0 here is a kludge, really this should be a\n+               --  fine Esize value but currently it means unknown, except that\n+               --  we know after gigi has back annotated that a size of zero is\n+               --  real, since otherwise gigi back annotates using No_Uint as\n+               --  the value to indicate unknown).\n \n                if (Esize (Comp) = Uint_0 or else Known_Static_Esize (Comp))\n                  and then Known_Static_Normalized_First_Bit (Comp)\n@@ -916,8 +917,8 @@ package body Repinfo is\n \n                   Write_Val (Esiz, Paren => True);\n \n-                  --  If in front end layout mode, then dynamic size is\n-                  --  stored in storage units, so renormalize for output\n+                  --  If in front end layout mode, then dynamic size is stored\n+                  --  in storage units, so renormalize for output\n \n                   if not Back_End_Layout then\n                      Write_Str (\" * \");\n@@ -1019,8 +1020,8 @@ package body Repinfo is\n             Write_Line (\";\");\n \n          --  For now, temporary case, to be removed when gigi properly back\n-         --  annotates RM_Size, if RM_Size is not set, then list Esize as\n-         --  Size. This avoids odd Object_Size output till we fix things???\n+         --  annotates RM_Size, if RM_Size is not set, then list Esize as Size.\n+         --  This avoids odd Object_Size output till we fix things???\n \n          elsif Unknown_RM_Size (Ent) then\n             Write_Str (\"for \");\n@@ -1086,6 +1087,14 @@ package body Repinfo is\n       function V (Val : Node_Ref_Or_Val) return Uint;\n       --  Internal recursive routine to evaluate tree\n \n+      function W (Val : Uint) return Word;\n+      --  Convert Val to Word, assuming Val is always in the Int range. This is\n+      --  a helper function for the evaluation of bitwise expressions like\n+      --  Bit_And_Expr, for which there is no direct support in uintp. Uint\n+      --  values out of the Int range are expected to be seen in such\n+      --  expressions only with overflowing byte sizes around, introducing\n+      --  inherent unreliabilties in computations anyway.\n+\n       -------\n       -- B --\n       -------\n@@ -1112,6 +1121,23 @@ package body Repinfo is\n          end if;\n       end T;\n \n+      -------\n+      -- W --\n+      -------\n+\n+      --  We use an unchecked conversion to map Int values to their Word\n+      --  bitwise equivalent, which we could not achieve with a normal type\n+      --  conversion for negative Ints. We want bitwise equivalents because W\n+      --  is used as a helper for bit operators like Bit_And_Expr, and can be\n+      --  called for negative Ints in the context of aligning expressions like\n+      --  X+Align & -Align.\n+\n+      function W (Val : Uint) return Word is\n+         function To_Word is new Ada.Unchecked_Conversion (Int, Word);\n+      begin\n+         return To_Word (UI_To_Int (Val));\n+      end W;\n+\n       -------\n       -- V --\n       -------\n@@ -1203,6 +1229,11 @@ package body Repinfo is\n                   when Truth_Not_Expr =>\n                      return B (not T (Node.Op1));\n \n+                  when Bit_And_Expr =>\n+                     L := V (Node.Op1);\n+                     R := V (Node.Op2);\n+                     return UI_From_Int (Int (W (L) and W (R)));\n+\n                   when Lt_Expr =>\n                      return B (V (Node.Op1) < V (Node.Op2));\n "}, {"sha": "9fc16c2c5810b330a4b00de306a6907134df46c7", "filename": "gcc/ada/repinfo.ads", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e61ef090a8910843dd421fad19eae41c4fca816/gcc%2Fada%2Frepinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e61ef090a8910843dd421fad19eae41c4fca816/gcc%2Fada%2Frepinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frepinfo.ads?ref=5e61ef090a8910843dd421fad19eae41c4fca816", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1999-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1999-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,7 +35,7 @@\n --  tree to fill in representation information, and also the routine used\n --  by -gnatR to print this information. This unit is used both in the\n --  compiler and in ASIS (it is used in ASIS as part of the implementation\n---  of the data decomposition annex.\n+--  of the data decomposition annex).\n \n with Types; use Types;\n with Uintp; use Uintp;\n@@ -128,7 +128,7 @@ package Repinfo is\n    --  Subtype used for values that can either be a Node_Ref (negative)\n    --  or a value (non-negative)\n \n-   type TCode is range 0 .. 27;\n+   type TCode is range 0 .. 28;\n    --  Type used on Ada side to represent DEFTREECODE values defined in\n    --  tree.def. Only a subset of these tree codes can actually appear.\n    --  The names are the names from tree.def in Ada casing.\n@@ -162,6 +162,7 @@ package Repinfo is\n    Ge_Expr          : constant TCode := 25; -- comparision >=           2\n    Eq_Expr          : constant TCode := 26; -- comparision =            2\n    Ne_Expr          : constant TCode := 27; -- comparision /=           2\n+   Bit_And_Expr     : constant TCode := 28; -- Binary and               2\n \n    --  The following entry is used to represent a discriminant value in\n    --  the tree. It has a special tree code that does not correspond"}, {"sha": "ec5452dafb6b707cae192b88e558769e1bcf1f7e", "filename": "gcc/ada/repinfo.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e61ef090a8910843dd421fad19eae41c4fca816/gcc%2Fada%2Frepinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e61ef090a8910843dd421fad19eae41c4fca816/gcc%2Fada%2Frepinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frepinfo.h?ref=5e61ef090a8910843dd421fad19eae41c4fca816", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1999-2002 Free Software Foundation, Inc.          *\n+ *          Copyright (C) 1999-2005 Free Software Foundation, Inc.          *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -67,6 +67,7 @@ typedef char TCode;\n #define Ge_Expr          25\n #define Eq_Expr          26\n #define Ne_Expr          27\n+#define Bit_And_Expr     28\n \n /* Creates a node using the tree code defined by Expr and from 1-3\n    operands as required (unused operands set as shown to No_Uint) Note"}, {"sha": "918f374b5daaf5b04cbfc1961fc3ffb2455ce08d", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 136, "deletions": 50, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e61ef090a8910843dd421fad19eae41c4fca816/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e61ef090a8910843dd421fad19eae41c4fca816/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=5e61ef090a8910843dd421fad19eae41c4fca816", "patch": "@@ -408,13 +408,7 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n       else if (TREE_CODE (gnu_result) == VAR_DECL\n \t       && (renamed_obj = DECL_RENAMED_OBJECT (gnu_result)) != 0\n \t       && (! DECL_RENAMING_GLOBAL_P (gnu_result)\n-\t\t   || global_bindings_p ())\n-\t       /* Make sure it's an lvalue like INDIRECT_REF.  */\n-\t       && (DECL_P (renamed_obj)\n-\t\t   || REFERENCE_CLASS_P (renamed_obj)\n-\t\t   || (TREE_CODE (renamed_obj) == VIEW_CONVERT_EXPR\n-\t\t       && (DECL_P (TREE_OPERAND (renamed_obj, 0))\n-\t\t\t   || REFERENCE_CLASS_P (TREE_OPERAND (renamed_obj,0))))))\n+\t\t   || global_bindings_p ()))\n \tgnu_result = renamed_obj;\n       else\n \tgnu_result = build_unary_op (INDIRECT_REF, NULL_TREE,\n@@ -719,6 +713,21 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t\t  = size_binop (MAX_EXPR, gnu_result,\n \t\t\t\tDECL_SIZE (TREE_OPERAND (gnu_expr, 1)));\n \t    }\n+\t  else if (Nkind (Prefix (gnat_node)) == N_Explicit_Dereference)\n+\t    {\n+\t      Node_Id gnat_deref = Prefix (gnat_node);\n+\t      Node_Id gnat_actual_subtype = Actual_Designated_Subtype (gnat_deref);\n+\t      tree gnu_ptr_type = TREE_TYPE (gnat_to_gnu (Prefix (gnat_deref)));\n+\t      if (TYPE_FAT_OR_THIN_POINTER_P (gnu_ptr_type)\n+\t  \t&& Present (gnat_actual_subtype))\n+\t        {\n+\t\t  tree gnu_actual_obj_type = gnat_to_gnu_type (gnat_actual_subtype);\n+\t\t  gnu_type = build_unc_object_type_from_ptr (gnu_ptr_type,\n+\t\t\t       gnu_actual_obj_type, get_identifier (\"SIZE\"));\n+\t        }\n+\n+\t      gnu_result = TYPE_SIZE (gnu_type);\n+\t    }\n \t  else\n \t    gnu_result = TYPE_SIZE (gnu_type);\n \t}\n@@ -1564,8 +1573,15 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t\t\t      0, Etype (Name (gnat_node)), \"PAD\", false,\n \t\t\t      false, false);\n \n-\t  gnu_target = create_tmp_var_raw (gnu_obj_type, \"LR\");\n-\t  gnat_pushdecl (gnu_target, gnat_node);\n+\t  /* ??? We may be about to create a static temporary if we happen to\n+\t     be at the global binding level.  That's a regression from what\n+\t     the 3.x back-end would generate in the same situation, but we\n+\t     don't have a mechanism in Gigi for creating automatic variables\n+\t     in the elaboration routines.  */\n+\t  gnu_target\n+\t    = create_var_decl (create_tmp_var_name (\"LR\"), NULL, gnu_obj_type,\n+\t\t\t       NULL, false, false, false, false, NULL,\n+\t\t\t       gnat_node);\n \t}\n \n       gnu_actual_list\n@@ -1602,6 +1618,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n       tree gnu_formal\n \t= (present_gnu_tree (gnat_formal)\n \t   ? get_gnu_tree (gnat_formal) : NULL_TREE);\n+      tree gnu_formal_type = gnat_to_gnu_type (Etype (gnat_formal));\n       /* We treat a conversion between aggregate types as if it is an\n \t unchecked conversion.  */\n       bool unchecked_convert_p\n@@ -1613,7 +1630,6 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n       tree gnu_name = gnat_to_gnu (gnat_name);\n       tree gnu_name_type = gnat_to_gnu_type (Etype (gnat_name));\n       tree gnu_actual;\n-      tree gnu_formal_type;\n \n       /* If it's possible we may need to use this expression twice, make sure\n \t than any side-effects are handled via SAVE_EXPRs. Likewise if we need\n@@ -1626,6 +1642,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n       if (Ekind (gnat_formal) != E_In_Parameter)\n \t{\n \t  gnu_name = gnat_stabilize_reference (gnu_name, true);\n+\n \t  if (!addressable_p (gnu_name)\n \t      && gnu_formal\n \t      && (DECL_BY_REF_P (gnu_formal)\n@@ -1741,6 +1758,9 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \tgnu_actual = convert (gnat_to_gnu_type (Etype (gnat_actual)),\n \t\t\t      gnu_actual);\n \n+      if (TREE_CODE (gnu_actual) != SAVE_EXPR)\n+\tgnu_actual = convert (gnu_formal_type, gnu_actual);\n+\n       /* If we have not saved a GCC object for the formal, it means it is an\n \t OUT parameter not passed by reference and that does not need to be\n \t copied in. Otherwise, look at the PARM_DECL to see if it is passed by\n@@ -1989,7 +2009,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t\t      && TREE_CONSTANT (TYPE_SIZE (TREE_TYPE (gnu_result)))))\n \t\t  gnu_result = convert (TREE_TYPE (gnu_actual), gnu_result);\n \t      }\n-\t\t\n+\n \t    gnu_result = build_binary_op (MODIFY_EXPR, NULL_TREE,\n \t\t\t\t\t  gnu_actual, gnu_result);\n \t    annotate_with_node (gnu_result, gnat_actual);\n@@ -2497,25 +2517,40 @@ gnat_to_gnu (Node_Id gnat_node)\n     return build1 (NULL_EXPR, get_unpadded_type (Etype (gnat_node)),\n \t\t   build_call_raise (CE_Range_Check_Failed));\n \n-  /* If this is a Statement and we are at top level, it must be part of\n-     the elaboration procedure, so mark us as being in that procedure\n-     and push our context.  */\n-  if (!current_function_decl\n-      && ((IN (Nkind (gnat_node), N_Statement_Other_Than_Procedure_Call)\n-\t   && Nkind (gnat_node) != N_Null_Statement)\n-\t  || Nkind (gnat_node) == N_Procedure_Call_Statement\n-\t  || Nkind (gnat_node) == N_Label\n-\t  || Nkind (gnat_node) == N_Implicit_Label_Declaration\n-\t  || Nkind (gnat_node) == N_Handled_Sequence_Of_Statements\n-\t  || ((Nkind (gnat_node) == N_Raise_Constraint_Error\n-\t       || Nkind (gnat_node) == N_Raise_Storage_Error\n-\t       || Nkind (gnat_node) == N_Raise_Program_Error)\n-\t      && (Ekind (Etype (gnat_node)) == E_Void))))\n+  /* If this is a Statement and we are at top level, it must be part of the\n+     elaboration procedure, so mark us as being in that procedure and push our\n+     context.\n+\n+     If we are in the elaboration procedure, check if we are violating a a\n+     No_Elaboration_Code restriction by having a statement there.  */\n+  if ((IN (Nkind (gnat_node), N_Statement_Other_Than_Procedure_Call)\n+       && Nkind (gnat_node) != N_Null_Statement)\n+      || Nkind (gnat_node) == N_Procedure_Call_Statement\n+      || Nkind (gnat_node) == N_Label\n+      || Nkind (gnat_node) == N_Implicit_Label_Declaration\n+      || Nkind (gnat_node) == N_Handled_Sequence_Of_Statements\n+      || ((Nkind (gnat_node) == N_Raise_Constraint_Error\n+\t   || Nkind (gnat_node) == N_Raise_Storage_Error\n+\t   || Nkind (gnat_node) == N_Raise_Program_Error)\n+\t  && (Ekind (Etype (gnat_node)) == E_Void)))\n     {\n-      current_function_decl = TREE_VALUE (gnu_elab_proc_stack);\n-      start_stmt_group ();\n-      gnat_pushlevel ();\n-      went_into_elab_proc = true;\n+      if (!current_function_decl)\n+\t{\n+\t  current_function_decl = TREE_VALUE (gnu_elab_proc_stack);\n+\t  start_stmt_group ();\n+\t  gnat_pushlevel ();\n+\t  went_into_elab_proc = true;\n+\t}\n+\n+      /* Don't check for a possible No_Elaboration_Code restriction violation\n+\t on N_Handled_Sequence_Of_Statements, as we want to signal an error on\n+\t every nested real statement instead.  This also avoids triggering\n+\t spurious errors on dummy (empty) sequences created by the front-end\n+\t for package bodies in some cases.  */\n+\n+      if (current_function_decl == TREE_VALUE (gnu_elab_proc_stack)\n+\t  && Nkind (gnat_node) != N_Handled_Sequence_Of_Statements)\n+\tCheck_Elaboration_Code_Allowed (gnat_node);\n     }\n \n   switch (Nkind (gnat_node))\n@@ -2982,7 +3017,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t\t   ? Designated_Type (Etype\n \t\t\t\t\t\t      (Prefix (gnat_node)))\n \t\t\t\t   : Etype (Prefix (gnat_node))))\n-\t      gnu_prefix = gnat_stabilize_reference (gnu_prefix, 0);\n+\t      gnu_prefix = gnat_stabilize_reference (gnu_prefix, false);\n \n \t    gnu_result\n \t      = build_component_ref (gnu_prefix, NULL_TREE, gnu_field,\n@@ -3427,7 +3462,7 @@ gnat_to_gnu (Node_Id gnat_node)\n       /* If the type has a size that overflows, convert this into raise of\n \t Storage_Error: execution shouldn't have gotten here anyway.  */\n       if (TREE_CODE (TYPE_SIZE_UNIT (TREE_TYPE (gnu_lhs))) == INTEGER_CST\n-\t  && TREE_OVERFLOW (TYPE_SIZE_UNIT (TREE_TYPE (gnu_lhs))))\n+\t   && TREE_OVERFLOW (TYPE_SIZE_UNIT (TREE_TYPE (gnu_lhs))))\n \tgnu_result = build_call_raise (SE_Object_Too_Large);\n       else if (Nkind (Expression (gnat_node)) == N_Function_Call\n \t       && !Do_Range_Check (Expression (gnat_node)))\n@@ -3927,7 +3962,9 @@ gnat_to_gnu (Node_Id gnat_node)\n       if (!type_annotate_only)\n \t{\n \t  tree gnu_ptr = gnat_to_gnu (Expression (gnat_node));\n+\t  tree gnu_ptr_type = TREE_TYPE (gnu_ptr);\n \t  tree gnu_obj_type;\n+\t  tree gnu_actual_obj_type = 0;\n \t  tree gnu_obj_size;\n \t  int align;\n \n@@ -3952,7 +3989,21 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t gnu_ptr);\n \n \t  gnu_obj_type = TREE_TYPE (TREE_TYPE (gnu_ptr));\n-\t  gnu_obj_size = TYPE_SIZE_UNIT (gnu_obj_type);\n+\n+\t  if (Present (Actual_Designated_Subtype (gnat_node)))\n+\t    {\n+\t      gnu_actual_obj_type = gnat_to_gnu_type (Actual_Designated_Subtype (gnat_node));\n+\n+\t      if (TYPE_FAT_OR_THIN_POINTER_P (gnu_ptr_type))\n+\t        gnu_actual_obj_type\n+\t          = build_unc_object_type_from_ptr (gnu_ptr_type,\n+\t\t      gnu_actual_obj_type,\n+\t\t      get_identifier (\"DEALLOC\"));\n+\t    }\n+\t  else\n+\t    gnu_actual_obj_type = gnu_obj_type;\n+\n+\t  gnu_obj_size = TYPE_SIZE_UNIT (gnu_actual_obj_type);\n \t  align = TYPE_ALIGN (gnu_obj_type);\n \n \t  if (TREE_CODE (gnu_obj_type) == RECORD_TYPE\n@@ -4106,7 +4157,7 @@ gnat_to_gnu (Node_Id gnat_node)\n   if (TREE_SIDE_EFFECTS (gnu_result)\n       && (TREE_CODE (gnu_result_type) == UNCONSTRAINED_ARRAY_TYPE\n \t  || CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_result_type))))\n-    gnu_result = gnat_stabilize_reference (gnu_result, 0);\n+    gnu_result = gnat_stabilize_reference (gnu_result, false);\n \n   /* Now convert the result to the proper type.  If the type is void or if\n      we have no result, return error_mark_node to show we have no result.\n@@ -5709,17 +5760,26 @@ protect_multiple_eval (tree exp)\n \t\t\t\t\t\t exp)));\n }\n \f\n-/* This is equivalent to stabilize_reference in GCC's tree.c, but we know\n-   how to handle our new nodes and we take an extra argument that says\n-   whether to force evaluation of everything.  */\n+/* This is equivalent to stabilize_reference in GCC's tree.c, but we know how\n+   to handle our new nodes and we take extra arguments:\n+\n+   FORCE says whether to force evaluation of everything,\n+\n+   SUCCESS we set to true unless we walk through something we don't know how\n+   to stabilize, or through something which is not an lvalue and LVALUES_ONLY\n+   is true, in which cases we set to false.  */\n \n tree\n-gnat_stabilize_reference (tree ref, bool force)\n+maybe_stabilize_reference (tree ref, bool force, bool lvalues_only,\n+\t\t\t   bool *success)\n {\n   tree type = TREE_TYPE (ref);\n   enum tree_code code = TREE_CODE (ref);\n   tree result;\n \n+  /* Assume we'll success unless proven otherwise.  */\n+  *success = true;\n+\n   switch (code)\n     {\n     case VAR_DECL:\n@@ -5728,6 +5788,15 @@ gnat_stabilize_reference (tree ref, bool force)\n       /* No action is needed in this case.  */\n       return ref;\n \n+    case ADDR_EXPR:\n+      /*  A standalone ADDR_EXPR is never an lvalue, and this one can't\n+\t  be nested inside an outer INDIRECT_REF, since INDIREC_REF goes\n+\t  straight to stabilize_1.  */\n+      if (lvalues_only)\n+\tgoto failure;\n+\n+      /* ... Fallthru ... */\n+\n     case NOP_EXPR:\n     case CONVERT_EXPR:\n     case FLOAT_EXPR:\n@@ -5736,10 +5805,10 @@ gnat_stabilize_reference (tree ref, bool force)\n     case FIX_ROUND_EXPR:\n     case FIX_CEIL_EXPR:\n     case VIEW_CONVERT_EXPR:\n-    case ADDR_EXPR:\n       result\n \t= build1 (code, type,\n-\t\t  gnat_stabilize_reference (TREE_OPERAND (ref, 0), force));\n+\t\t  maybe_stabilize_reference (TREE_OPERAND (ref, 0), force,\n+\t\t\t\t\t     lvalues_only, success));\n       break;\n \n     case INDIRECT_REF:\n@@ -5750,15 +5819,16 @@ gnat_stabilize_reference (tree ref, bool force)\n       break;\n \n     case COMPONENT_REF:\n-      result = build3 (COMPONENT_REF, type,\n-\t\t       gnat_stabilize_reference (TREE_OPERAND (ref, 0),\n-\t\t\t\t\t\t force),\n-\t\t       TREE_OPERAND (ref, 1), NULL_TREE);\n+     result = build3 (COMPONENT_REF, type,\n+\t\t      maybe_stabilize_reference (TREE_OPERAND (ref, 0), force,\n+\t\t\t\t\t\t lvalues_only, success),\n+\t\t      TREE_OPERAND (ref, 1), NULL_TREE);\n       break;\n \n     case BIT_FIELD_REF:\n       result = build3 (BIT_FIELD_REF, type,\n-\t\t       gnat_stabilize_reference (TREE_OPERAND (ref, 0), force),\n+\t\t       maybe_stabilize_reference (TREE_OPERAND (ref, 0), force,\n+\t\t\t\t\t\t  lvalues_only, success),\n \t\t       gnat_stabilize_reference_1 (TREE_OPERAND (ref, 1),\n \t\t\t\t\t\t   force),\n \t\t       gnat_stabilize_reference_1 (TREE_OPERAND (ref, 2),\n@@ -5768,7 +5838,8 @@ gnat_stabilize_reference (tree ref, bool force)\n     case ARRAY_REF:\n     case ARRAY_RANGE_REF:\n       result = build4 (code, type,\n-\t\t       gnat_stabilize_reference (TREE_OPERAND (ref, 0), force),\n+\t\t       maybe_stabilize_reference (TREE_OPERAND (ref, 0), force,\n+\t\t\t\t\t\t  lvalues_only, success),\n \t\t       gnat_stabilize_reference_1 (TREE_OPERAND (ref, 1),\n \t\t\t\t\t\t   force),\n \t\t       NULL_TREE, NULL_TREE);\n@@ -5778,17 +5849,21 @@ gnat_stabilize_reference (tree ref, bool force)\n       result = build2 (COMPOUND_EXPR, type,\n \t\t       gnat_stabilize_reference_1 (TREE_OPERAND (ref, 0),\n \t\t\t\t\t\t   force),\n-\t\t       gnat_stabilize_reference (TREE_OPERAND (ref, 1),\n-\t\t\t\t\t\t force));\n+\t\t       maybe_stabilize_reference (TREE_OPERAND (ref, 1), force,\n+\t\t\t\t\t\t  lvalues_only, success));\n       break;\n \n+    case ERROR_MARK:\n+      ref = error_mark_node;\n+\n+      /* ...  Fallthru to failure ... */\n+\n       /* If arg isn't a kind of lvalue we recognize, make no change.\n \t Caller should recognize the error for an invalid lvalue.  */\n     default:\n+    failure:\n+      *success = false;\n       return ref;\n-\n-    case ERROR_MARK:\n-      return error_mark_node;\n     }\n \n   TREE_READONLY (result) = TREE_READONLY (ref);\n@@ -5808,6 +5883,17 @@ gnat_stabilize_reference (tree ref, bool force)\n   return result;\n }\n \n+/* Wrapper around maybe_stabilize_reference, for common uses without\n+   lvalue restrictions and without need to examine the success\n+   indication.  */\n+\n+tree\n+gnat_stabilize_reference (tree ref, bool force)\n+{\n+  bool stabilized;\n+  return maybe_stabilize_reference (ref, force, false, &stabilized);\n+}\n+\n /* Similar to stabilize_reference_1 in tree.c, but supports an extra\n    arg to force a SAVE_EXPR for everything.  */\n "}, {"sha": "2bfafce9b51fbff556bc23c3e5152b242b746dcc", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 81, "deletions": 19, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e61ef090a8910843dd421fad19eae41c4fca816/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e61ef090a8910843dd421fad19eae41c4fca816/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=5e61ef090a8910843dd421fad19eae41c4fca816", "patch": "@@ -324,7 +324,13 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n   if (global_bindings_p () && TREE_CODE (decl) != PARM_DECL)\n     DECL_CONTEXT (decl) = 0;\n   else\n-    DECL_CONTEXT (decl) = current_function_decl;\n+    {\n+      DECL_CONTEXT (decl) = current_function_decl;\n+\n+      /* Functions imported in another function are not really nested.  */\n+      if (TREE_CODE (decl) == FUNCTION_DECL && TREE_PUBLIC (decl))\n+\tDECL_NO_STATIC_CHAIN (decl) = 1;\n+    }\n \n   TREE_NO_WARNING (decl) = (gnat_node == Empty || Warnings_Off (gnat_node));\n \n@@ -1277,6 +1283,12 @@ create_var_decl (tree var_name, tree asm_name, tree type, tree var_init,\n       || (type_annotate_only && var_init && !TREE_CONSTANT (var_init)))\n     var_init = NULL_TREE;\n \n+  /* At the global level, an initializer requiring code to be generated\n+     produces elaboration statements.  Check that such statements are allowed,\n+     that is, not violating a No_Elaboration_Code restriction.  */\n+  if (global_bindings_p () && var_init != 0 && ! init_const)\n+    Check_Elaboration_Code_Allowed (gnat_node);\n+\n   /* Ada doesn't feature Fortran-like COMMON variables so we shouldn't\n      try to fiddle with DECL_COMMON.  However, on platforms that don't\n      support global BSS sections, uninitialized global variables would\n@@ -1313,6 +1325,10 @@ create_var_decl (tree var_name, tree asm_name, tree type, tree var_init,\n \n   if (TREE_CODE (var_decl) != CONST_DECL)\n     rest_of_decl_compilation (var_decl, global_bindings_p (), 0);\n+  else\n+    /* expand CONST_DECLs to set their MODE, ALIGN, SIZE and SIZE_UNIT,\n+       which we need for later back-annotations.  */\n+    expand_decl (var_decl);\n \n   return var_decl;\n }\n@@ -1607,7 +1623,7 @@ potential_alignment_gap (tree prev_field, tree curr_field, tree offset)\n \t    % DECL_ALIGN (curr_field) != 0);\n \n   /* If both the position and size of the previous field are multiples\n-     of the current field alignment, there can not be any gap. */\n+     of the current field alignment, there cannot be any gap. */\n   if (value_factor_p (bit_position (prev_field), DECL_ALIGN (curr_field))\n       && value_factor_p (DECL_SIZE (prev_field), DECL_ALIGN (curr_field)))\n     return false;\n@@ -2444,6 +2460,22 @@ build_unc_object_type (tree template_type, tree object_type, tree name)\n \n   return type;\n }\n+\n+/* Same, taking a thin or fat pointer type instead of a template type. */\n+\n+tree\n+build_unc_object_type_from_ptr (tree thin_fat_ptr_type, tree object_type, tree name)\n+{\n+  tree template_type;\n+\n+  gcc_assert (TYPE_FAT_OR_THIN_POINTER_P (thin_fat_ptr_type));\n+\n+  template_type\n+    = (TYPE_FAT_POINTER_P (thin_fat_ptr_type)\n+       ? TREE_TYPE (TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (thin_fat_ptr_type))))\n+       : TREE_TYPE (TYPE_FIELDS (TREE_TYPE (thin_fat_ptr_type))));\n+  return build_unc_object_type (template_type, object_type, name);\n+}\n \f\n /* Update anything previously pointing to OLD_TYPE to point to NEW_TYPE.  In\n    the normal case this is just two adjustments, but we have more to do\n@@ -2755,11 +2787,15 @@ convert (tree type, tree expr)\n \t\t\t\t\t\t      expr)),\n \t\t\t\t\tTYPE_MIN_VALUE (etype))));\n \n-  /* If the input is a justified modular type, we need to extract\n-     the actual object before converting it to any other type with the\n-     exception of an unconstrained array.  */\n+  /* If the input is a justified modular type, we need to extract the actual\n+     object before converting it to any other type with the exceptions of an\n+     unconstrained array or of a mere type variant.  It is useful to avoid the\n+     extraction and conversion in the type variant case because it could end\n+     up replacing a VAR_DECL expr by a constructor and we might be about the\n+     take the address of the result.  */\n   if (ecode == RECORD_TYPE && TYPE_JUSTIFIED_MODULAR_P (etype)\n-      && code != UNCONSTRAINED_ARRAY_TYPE)\n+      && code != UNCONSTRAINED_ARRAY_TYPE\n+      && TYPE_MAIN_VARIANT (type) != TYPE_MAIN_VARIANT (etype))\n     return convert (type, build_component_ref (expr, NULL_TREE,\n \t\t\t\t\t       TYPE_FIELDS (etype), false));\n \n@@ -2804,9 +2840,7 @@ convert (tree type, tree expr)\n \t just make a new one in the proper type.  */\n       if (code == ecode && AGGREGATE_TYPE_P (etype)\n \t  && !(TREE_CODE (TYPE_SIZE (etype)) == INTEGER_CST\n-\t       && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n-\t  && (TREE_CODE (expr) == STRING_CST\n-\t      || get_alias_set (etype) == get_alias_set (type)))\n+\t       && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST))\n \t{\n \t  expr = copy_node (expr);\n \t  TREE_TYPE (expr) = type;\n@@ -2826,9 +2860,40 @@ convert (tree type, tree expr)\n       break;\n \n     case VIEW_CONVERT_EXPR:\n-      if (AGGREGATE_TYPE_P (type) && AGGREGATE_TYPE_P (etype)\n-\t  && !TYPE_FAT_POINTER_P (type) && !TYPE_FAT_POINTER_P (etype))\n-\treturn convert (type, TREE_OPERAND (expr, 0));\n+      {\n+\t/* GCC 4.x is very sensitive to type consistency overall, and view\n+\t   conversions thus are very frequent.  Eventhough just \"convert\"ing\n+\t   the inner operand to the output type is fine in most cases, it\n+\t   might expose unexpected input/output type mismatches in special\n+\t   circumstances so we avoid such recursive calls when we can.  */\n+\n+\ttree op0 = TREE_OPERAND (expr, 0);\n+\n+\t/* If we are converting back to the original type, we can just\n+\t   lift the input conversion.  This is a common occurence with\n+\t   switches back-and-forth amongst type variants.  */\n+\tif (type == TREE_TYPE (op0))\n+\t  return op0;\n+\n+\t/* Otherwise, if we're converting between two aggregate types, we\n+\t   might be allowed to substitute the VIEW_CONVERT target type in\n+\t   place or to just convert the inner expression.  */\n+\tif (AGGREGATE_TYPE_P (type) && AGGREGATE_TYPE_P (etype))\n+\t  {\n+\t    /* If we are converting between type variants, we can just\n+\t       substitute the VIEW_CONVERT in place.  */\n+\t    if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (etype))\n+\t      return build1 (VIEW_CONVERT_EXPR, type, op0);\n+\n+\t    /* Otherwise, we may just bypass the input view conversion unless\n+\t       one of the types is a fat pointer, or we're converting to an\n+\t       unchecked union type.  Both are handled by specialized code\n+\t       below and the latter relies on exact type matching.  */\n+\t    else if (!TYPE_FAT_POINTER_P (type) && !TYPE_FAT_POINTER_P (etype)\n+\t\t     && !(code == UNION_TYPE && TYPE_UNCHECKED_UNION_P (type)))\n+\t      return convert (type, op0);\n+\t  }\n+      }\n       break;\n \n     case INDIRECT_REF:\n@@ -2957,13 +3022,10 @@ convert (tree type, tree expr)\n \t    {\n \t      if (TREE_TYPE (tem) == etype)\n \t\treturn build1 (CONVERT_EXPR, type, expr);\n-\n-\t      /* Accept slight type variations.  */\n-\t      if (TREE_TYPE (tem) == TYPE_MAIN_VARIANT (etype)\n-\t\t  || (TREE_CODE (TREE_TYPE (tem)) == RECORD_TYPE\n-\t\t      && (TYPE_JUSTIFIED_MODULAR_P (TREE_TYPE (tem))\n-\t\t\t  || TYPE_IS_PADDING_P (TREE_TYPE (tem)))\n-\t\t      && TREE_TYPE (TYPE_FIELDS (TREE_TYPE (tem))) == etype))\n+\t      else if (TREE_CODE (TREE_TYPE (tem)) == RECORD_TYPE\n+\t\t       && (TYPE_JUSTIFIED_MODULAR_P (TREE_TYPE (tem))\n+\t\t\t   || TYPE_IS_PADDING_P (TREE_TYPE (tem)))\n+\t\t       && TREE_TYPE (TYPE_FIELDS (TREE_TYPE (tem))) == etype)\n \t\treturn build1 (CONVERT_EXPR, type,\n \t\t\t       convert (TREE_TYPE (tem), expr));\n \t    }"}, {"sha": "24937449cc164a0705dcb84bf6ec43aed2168486", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 62, "deletions": 65, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e61ef090a8910843dd421fad19eae41c4fca816/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e61ef090a8910843dd421fad19eae41c4fca816/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=5e61ef090a8910843dd421fad19eae41c4fca816", "patch": "@@ -170,7 +170,7 @@ known_alignment (tree exp)\n     case NON_LVALUE_EXPR:\n       /* Conversions between pointers and integers don't change the alignment\n \t of the underlying object.  */\n-      this_alignment = known_alignment (TREE_OPERAND (exp, 0));\t\n+      this_alignment = known_alignment (TREE_OPERAND (exp, 0));\n       break;\n \n     case PLUS_EXPR:\n@@ -656,40 +656,6 @@ build_binary_op (enum tree_code op_code, tree result_type,\n       if (!operation_type)\n \toperation_type = left_type;\n \n-      /* If the RHS has a conversion between record and array types and\n-\t an inner type is no worse, use it.  Note we cannot do this for\n-\t modular types or types with TYPE_ALIGN_OK, since the latter\n-\t might indicate a conversion between a root type and a class-wide\n-\t type, which we must not remove.  */\n-      while (TREE_CODE (right_operand) == VIEW_CONVERT_EXPR\n-\t     && (((TREE_CODE (right_type) == RECORD_TYPE\n-\t\t   || TREE_CODE (right_type) == UNION_TYPE)\n-\t\t  && !TYPE_JUSTIFIED_MODULAR_P (right_type)\n-\t\t  && !TYPE_ALIGN_OK (right_type)\n-\t\t  && !TYPE_IS_FAT_POINTER_P (right_type))\n-\t\t || TREE_CODE (right_type) == ARRAY_TYPE)\n-\t     && ((((TREE_CODE (TREE_TYPE (TREE_OPERAND (right_operand, 0)))\n-\t\t    == RECORD_TYPE)\n-\t\t   || (TREE_CODE (TREE_TYPE (TREE_OPERAND (right_operand, 0)))\n-\t\t       == UNION_TYPE))\n-\t\t  && !(TYPE_JUSTIFIED_MODULAR_P\n-\t\t       (TREE_TYPE (TREE_OPERAND (right_operand, 0))))\n-\t\t  && !(TYPE_ALIGN_OK\n-\t\t       (TREE_TYPE (TREE_OPERAND (right_operand, 0))))\n-\t\t  && !(TYPE_IS_FAT_POINTER_P\n-\t\t       (TREE_TYPE (TREE_OPERAND (right_operand, 0)))))\n-\t\t || (TREE_CODE (TREE_TYPE (TREE_OPERAND (right_operand, 0)))\n-\t\t     == ARRAY_TYPE))\n-\t     && (0 == (best_type\n-\t\t       = find_common_type (right_type,\n-\t\t\t\t\t   TREE_TYPE (TREE_OPERAND\n-\t\t\t\t\t   (right_operand, 0))))\n-\t\t || right_type != best_type))\n-\t{\n-\t  right_operand = TREE_OPERAND (right_operand, 0);\n-\t  right_type = TREE_TYPE (right_operand);\n-\t}\n-\n       /* If we are copying one array or record to another, find the best type\n \t to use.  */\n       if (((TREE_CODE (left_type) == ARRAY_TYPE\n@@ -1159,12 +1125,18 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t    return build_unary_op (ADDR_EXPR, result_type,\n \t\t\t\t   TREE_OPERAND (operand, 0));\n \n-\t  /* If this NOP_EXPR doesn't change the mode, get the result type\n-\t     from this type and go down.  We need to do this in case\n-\t     this is a conversion of a CONST_DECL.  */\n-\t  if (TYPE_MODE (type) != BLKmode\n-\t      && (TYPE_MODE (type)\n-\t\t  == TYPE_MODE (TREE_TYPE (TREE_OPERAND (operand, 0)))))\n+\t  /* ... fallthru ... */\n+\n+\tcase VIEW_CONVERT_EXPR:\n+\t  /* If this just a variant conversion or if the conversion doesn't\n+\t     change the mode, get the result type from this type and go down.\n+\t     This is needed for conversions of CONST_DECLs, to eventually get\n+\t     to the address of their CORRESPONDING_VARs.  */\n+\t  if ((TYPE_MAIN_VARIANT (type)\n+\t       == TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (operand, 0))))\n+\t      || (TYPE_MODE (type) != BLKmode\n+\t\t  && (TYPE_MODE (type)\n+\t\t      == TYPE_MODE (TREE_TYPE (TREE_OPERAND (operand, 0))))))\n \t    return build_unary_op (ADDR_EXPR,\n \t\t\t\t   (result_type ? result_type\n \t\t\t\t    : build_pointer_type (type)),\n@@ -1409,7 +1381,7 @@ build_return_expr (tree result_decl, tree ret_val)\n          build_binary_op with the additional guarantee that the type\n          cannot involve a placeholder, since otherwise the function\n          would use the \"target pointer\" return mechanism.  */\n-       \n+\n       if (operation_type != TREE_TYPE (ret_val))\n \tret_val = convert (operation_type, ret_val);\n \n@@ -1493,17 +1465,41 @@ build_call_raise (int msg)\n \t\t       build_int_cst (NULL_TREE, input_line));\n }\n \f\n+/* qsort comparer for the bit positions of two constructor elements\n+   for record components.  */\n+\n+static int\n+compare_elmt_bitpos (const PTR rt1, const PTR rt2)\n+{\n+  tree elmt1 = * (tree *) rt1;\n+  tree elmt2 = * (tree *) rt2;\n+\n+  tree pos_field1 = bit_position (TREE_PURPOSE (elmt1));\n+  tree pos_field2 = bit_position (TREE_PURPOSE (elmt2));\n+\n+  if (tree_int_cst_equal (pos_field1, pos_field2))\n+    return 0;\n+  else if (tree_int_cst_lt (pos_field1, pos_field2))\n+    return -1;\n+  else\n+    return 1;\n+}\n+\n /* Return a CONSTRUCTOR of TYPE whose list is LIST.  */\n \n tree\n gnat_build_constructor (tree type, tree list)\n {\n   tree elmt;\n+  int n_elmts;\n   bool allconstant = (TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST);\n   bool side_effects = false;\n   tree result;\n \n-  for (elmt = list; elmt; elmt = TREE_CHAIN (elmt))\n+  /* Scan the elements to see if they are all constant or if any has side\n+     effects, to let us set global flags on the resulting constructor.  Count\n+     the elements along the way for possible sorting purposes below.  */\n+  for (n_elmts = 0, elmt = list; elmt; elmt = TREE_CHAIN (elmt), n_elmts ++)\n     {\n       if (!TREE_CONSTANT (TREE_VALUE (elmt))\n \t  || (TREE_CODE (type) == RECORD_TYPE\n@@ -1525,26 +1521,30 @@ gnat_build_constructor (tree type, tree list)\n \treturn build1 (NULL_EXPR, type, TREE_OPERAND (result, 0));\n     }\n \n-  /* If TYPE is a RECORD_TYPE and the fields are not in the\n-     same order as their bit position, don't treat this as constant\n-     since varasm.c can't handle it.  */\n-  if (allconstant && TREE_CODE (type) == RECORD_TYPE)\n+  /* For record types with constant components only, sort field list\n+     by increasing bit position.  This is necessary to ensure the\n+     constructor can be output as static data, which the gimplifier\n+     might force in various circumstances. */\n+  if (allconstant && TREE_CODE (type) == RECORD_TYPE && n_elmts > 1)\n     {\n-      tree last_pos = bitsize_zero_node;\n-      tree field;\n+      /* Fill an array with an element tree per index, and ask qsort to order\n+\t them according to what a bitpos comparison function says.  */\n \n-      for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n-\t{\n-\t  tree this_pos = bit_position (field);\n+      tree *gnu_arr = (tree *) alloca (sizeof (tree) * n_elmts);\n+      int i;\n \n-\t  if (TREE_CODE (this_pos) != INTEGER_CST\n-\t      || tree_int_cst_lt (this_pos, last_pos))\n-\t    {\n-\t      allconstant = false;\n-\t      break;\n-\t    }\n+      for (i = 0, elmt = list; elmt; elmt = TREE_CHAIN (elmt), i++)\n+\tgnu_arr[i] = elmt;\n+\n+      qsort (gnu_arr, n_elmts, sizeof (tree), compare_elmt_bitpos);\n \n-\t  last_pos = this_pos;\n+      /* Then reconstruct the list from the sorted array contents.  */\n+\n+      list = NULL_TREE;\n+      for (i = n_elmts - 1; i >= 0; i--)\n+\t{\n+\t  TREE_CHAIN (gnu_arr[i]) = list;\n+\t  list = gnu_arr[i];\n \t}\n     }\n \n@@ -1821,13 +1821,10 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n      fill in the parts that are known.  */\n   else if (TYPE_FAT_OR_THIN_POINTER_P (result_type))\n     {\n-      tree template_type\n-\t= (TYPE_FAT_POINTER_P (result_type)\n-\t   ? TREE_TYPE (TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (result_type))))\n-\t   : TREE_TYPE (TYPE_FIELDS (TREE_TYPE (result_type))));\n       tree storage_type\n-\t= build_unc_object_type (template_type, type,\n-\t\t\t\t get_identifier (\"ALLOC\"));\n+\t= build_unc_object_type_from_ptr (result_type, type,\n+\t\t\t\t\t  get_identifier (\"ALLOC\"));\n+      tree template_type = TREE_TYPE (TYPE_FIELDS (storage_type));\n       tree storage_ptr_type = build_pointer_type (storage_type);\n       tree storage;\n       tree template_cons = NULL_TREE;"}]}