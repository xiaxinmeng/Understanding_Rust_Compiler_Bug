{"sha": "7525cc04a83c94483e196df4d658a2daa7d8b55e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzUyNWNjMDRhODNjOTQ0ODNlMTk2ZGY0ZDY1OGEyZGFhN2Q4YjU1ZQ==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@sendai.cygnus.com", "date": "1998-12-12T20:04:35Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-12-12T20:04:35Z"}, "message": "parse.y (<type_declaration>): Do maybe_generate_clinit last.\n\n\ufffd\n\t* parse.y (<type_declaration>):  Do maybe_generate_clinit last.\n\t(register_fields):  If a static fields has an initializer, just\n\tchain it on ctxp->static_initialized, and handle later.\n\t(java_complete_expand_methods):  Force <clinit> first.\n\t(resolve_expression_name, resolve_field_access):  Just get DECL_INITIAL\n\t- it's already been completed.\n\t(patch_initialized_static_field):  New function.\n\t(java_complete_field):  Call it.\n\nFrom-SVN: r24274", "tree": {"sha": "739256108330209193739d347cc2db46955cda29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/739256108330209193739d347cc2db46955cda29"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7525cc04a83c94483e196df4d658a2daa7d8b55e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7525cc04a83c94483e196df4d658a2daa7d8b55e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7525cc04a83c94483e196df4d658a2daa7d8b55e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7525cc04a83c94483e196df4d658a2daa7d8b55e/comments", "author": null, "committer": null, "parents": [{"sha": "fdec99c620f7f3eed47df81498b303cfc2e58f49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdec99c620f7f3eed47df81498b303cfc2e58f49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdec99c620f7f3eed47df81498b303cfc2e58f49"}], "stats": {"total": 91, "additions": 63, "deletions": 28}, "files": [{"sha": "5bc2b6e1ec65c9b2a311758286fd975300258cdb", "filename": "gcc/java/parse.y", "status": "modified", "additions": 63, "deletions": 28, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7525cc04a83c94483e196df4d658a2daa7d8b55e/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7525cc04a83c94483e196df4d658a2daa7d8b55e/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=7525cc04a83c94483e196df4d658a2daa7d8b55e", "patch": "@@ -237,6 +237,7 @@ static tree patch_new_array_init PROTO ((tree, tree));\n static tree maybe_build_array_element_wfl PROTO ((tree));\n static int array_constructor_check_entry PROTO ((tree, tree));\n static char *purify_type_name PROTO ((char *));\n+static tree patch_initialized_static_field PROTO ((tree));\n \n /* Number of error found so far. */\n int java_error_count; \n@@ -609,8 +610,8 @@ type_import_on_demand_declaration:\n type_declaration:\n \tclass_declaration\n \t\t{\n-\t\t  maybe_generate_clinit ();\n \t\t  maybe_generate_finit ();\n+\t\t  maybe_generate_clinit ();\n \t\t  $$ = $1;\n \t\t}\n |\tinterface_declaration\n@@ -3133,34 +3134,24 @@ register_fields (flags, type, variable_list)\n \t  /* The field is declared static */\n \t  if (flags & ACC_STATIC)\n \t    {\n-\t      if (flags & ACC_FINAL)\n-\t\t{\n-\t\t  if (DECL_LANG_SPECIFIC (field_decl) == NULL)\n-\t\t    DECL_LANG_SPECIFIC (field_decl) = (struct lang_decl *)\n-\t\t      permalloc (sizeof (struct lang_decl_var));\n-\t\t  DECL_LOCAL_STATIC_VALUE (field_decl) = \n-\t\t    TREE_OPERAND (init, 1);\n-\t\t  if (TREE_CONSTANT (TREE_OPERAND (init, 1)))\n-\t\t    DECL_INITIAL (field_decl) = TREE_OPERAND (init, 1);\n-\t\t}\n-\t      /* Otherwise, the field should be initialized in <clinit>. \n-\t\t This field is remembered so we can generate <clinit> later */\n-\t      else\n-\t\t{\n-\t\t  INITIALIZED_P (field_decl) = 1;\n-\t\t  TREE_CHAIN (init) = ctxp->static_initialized;\n-\t\t  ctxp->static_initialized = init;\n-\t\t}\n+\t      /* We include the field and its initialization part into\n+\t\t a list used to generate <clinit>. After <clinit> is\n+\t\t walked, fields initialization will be processed and\n+\t\t fields initialized with know constants will be taken\n+\t\t out of <clinit> and have ther DECL_INITIAL set\n+\t\t appropriately. */\n+\t      TREE_CHAIN (init) = ctxp->static_initialized;\n+\t      ctxp->static_initialized = init;\n \t    }\n \t  /* A non-static field declared with an immediate initialization is\n \t     to be initialized in <init>, if any.  This field is remembered\n \t     to be processed at the time of the generation of <init>. */\n \t  else\n \t    {\n-\t      INITIALIZED_P (field_decl) = 1;\n \t      TREE_CHAIN (init) = ctxp->non_static_initialized;\n \t      ctxp->non_static_initialized = init;\n \t    }\n+\t  INITIALIZED_P (field_decl) = 1;\n \t}\n     }\n   lineno = saved_lineno;\n@@ -5582,6 +5573,16 @@ java_complete_expand_methods ()\n       /* Initialize a new constant pool */\n       init_outgoing_cpool ();\n \n+      /* We want <clinit> (if any) to be processed first. */\n+      decl = tree_last (TYPE_METHODS (class_type));\n+      if (decl && DECL_NAME (decl) == clinit_identifier_node)\n+\t{\n+\t  tree list = nreverse (TYPE_METHODS (class_type));\n+\t  list = TREE_CHAIN (list);\n+\t  TREE_CHAIN (decl) = NULL_TREE;\n+\t  TYPE_METHODS (class_type) = chainon (decl, nreverse (list));\n+\t}\n+\n       /* Don't process function bodies in interfaces */\n       if (!CLASS_INTERFACE (TYPE_NAME (current_class)))\n \tfor (decl = TYPE_METHODS (class_type); decl; decl = TREE_CHAIN (decl))\n@@ -5659,7 +5660,7 @@ java_complete_expand_method (mdecl)\n       if ((block_body == NULL_TREE || CAN_COMPLETE_NORMALLY (block_body))\n \t  && TREE_CODE (TREE_TYPE (TREE_TYPE (mdecl))) != VOID_TYPE)\n \tmissing_return_error (current_function_decl);\n-      \n+\n       /* Don't go any further if we've found error(s) during the\n          expansion */\n       if (!java_error_count)\n@@ -5975,8 +5976,8 @@ resolve_expression_name (id, orig)\n \t\t  return error_mark_node;\n \t\t}\n \t      /* The field is final. We may use its value instead */\n-\t      if (fs && FIELD_FINAL (decl))\n-\t\tvalue = java_complete_tree (DECL_LOCAL_STATIC_VALUE (decl));\n+\t      if (fs && FIELD_FINAL (decl) && DECL_INITIAL (decl))\n+\t\tvalue = DECL_INITIAL (decl);\n \n \t      /* Otherwise build what it takes to access the field */\n \t      decl = build_field_ref ((fs ? NULL_TREE : current_this),\n@@ -6049,9 +6050,9 @@ resolve_field_access (qual_wfl, field_decl, field_type)\n       if (FIELD_FINAL (decl) \n \t  && JPRIMITIVE_TYPE_P (TREE_TYPE (decl))\n \t  && DECL_LANG_SPECIFIC (decl)\n-\t  && DECL_LOCAL_STATIC_VALUE (decl))\n+\t  && DECL_INITIAL (decl))\n \t{\n-\t  field_ref = java_complete_tree (DECL_LOCAL_STATIC_VALUE (decl));\n+\t  field_ref = DECL_INITIAL (decl);\n \t  static_final_found = 1;\n \t}\n       else\n@@ -7765,6 +7766,15 @@ java_complete_tree (node)\n \tTREE_OPERAND (node, 1) = nn;\n       node = patch_assignment (node, wfl_op1, wfl_op2);\n       CAN_COMPLETE_NORMALLY (node) = 1;\n+\n+      /* Before returning the node, in the context of a static field\n+         assignment in <clinit>, we may want to carray further\n+         optimizations. (VAR_DECL means it's a static field. See\n+         add_field. */\n+      if (DECL_NAME (current_function_decl) == clinit_identifier_node\n+\t  && TREE_CODE (TREE_OPERAND (node, 0)) == VAR_DECL)\n+\tnode = patch_initialized_static_field (node);\n+\n       return node;\n \n     case MULT_EXPR:\n@@ -8161,7 +8171,8 @@ static int\n check_final_assignment (lvalue, wfl)\n      tree lvalue, wfl;\n {\n-  if (DECL_P (lvalue) && FIELD_FINAL (lvalue))\n+  if (DECL_P (lvalue) && FIELD_FINAL (lvalue) &&\n+      DECL_NAME (current_function_decl) != clinit_identifier_node)\n     {\n       parse_error_context \n         (wfl, \"Can't assign a value to the final variable `%s'\",\n@@ -8323,6 +8334,30 @@ patch_assignment (node, wfl_op1, wfl_op2)\n   return node;\n }\n \n+/* Optimize static (final) field initialized upon declaration.\n+     - If the field is static final and is assigned to a primitive\n+       constant type, then set its DECL_INITIAL to the value.\n+     - More to come.  */\n+\n+static tree\n+patch_initialized_static_field (node)\n+     tree node;\n+{\n+  tree field = TREE_OPERAND (node, 0);\n+  tree value = TREE_OPERAND (node, 1);\n+\n+  if (FIELD_FINAL (field) && TREE_CONSTANT (value)\n+      && JPRIMITIVE_TYPE_P (TREE_TYPE (value)))\n+    {\n+      if (DECL_LANG_SPECIFIC (field) == NULL)\n+\tDECL_LANG_SPECIFIC (field) = (struct lang_decl *)\n+\t  permalloc (sizeof (struct lang_decl_var));\n+      DECL_INITIAL (field) = value;\n+      return empty_stmt_node;\n+    }\n+  return node;\n+}\n+\n /* Check that type SOURCE can be cast into type DEST. If the cast\n    can't occur at all, return 0 otherwise 1. This function is used to\n    produce accurate error messages on the reasons why an assignment\n@@ -9392,7 +9427,7 @@ patch_unaryop (node, wfl_op)\n   /* There are cases where node has been replaced by something else\n      and we don't end up returning here: UNARY_PLUS_EXPR,\n      CONVERT_EXPR, {POST,PRE}{INCR,DECR}EMENT_EXPR. */\n-  TREE_OPERAND (node, 0) = op;\n+  TREE_OPERAND (node, 0) = fold (op);\n   TREE_TYPE (node) = prom_type;\n   return fold (node);\n }\n@@ -10547,7 +10582,7 @@ patch_try_statement (node)\n \t   CATCH_EXPR\t\t(catch node)\n \t     BLOCK\t        (with the decl of the parameter)\n                COMPOUND_EXPR\n-                 MODIFIY_EXPR   (assignemnt of the catch parameter)\n+                 MODIFY_EXPR   (assignment of the catch parameter)\n \t\t BLOCK\t        (catch clause block)\n            LABEL_DECL\t\t(where to return after finally (if any))\n "}]}