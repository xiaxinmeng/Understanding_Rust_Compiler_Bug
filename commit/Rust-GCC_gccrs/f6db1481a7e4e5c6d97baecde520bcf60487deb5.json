{"sha": "f6db1481a7e4e5c6d97baecde520bcf60487deb5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjZkYjE0ODFhN2U0ZTVjNmQ5N2JhZWNkZTUyMGJjZjYwNDg3ZGViNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-02-27T08:54:31Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-02-27T08:54:31Z"}, "message": "passes.c: New file.\n\n        * passes.c: New file.\n        * Makefile.in (OBJS-common): Add it.\n        * diagnostic.c (rtl_dump_and_exit): Move decl ...\n        * flags.h (rtl_dump_and_exit): ... here.\n        * output.h (size_directive_output, last_assemble_variable_decl):\n        Move from toplev.c.\n        * rtl.h (reg_alloc): Move from toplev.c.\n        * toplev.c (HAVE_conditional_execution, DUMPFILE_FORMAT,\n        struct dump_file_info, enum dump_file_index, dump_file_tbl,\n        open_dump_file, close_dump_file, rest_of_decl_compilation,\n        rest_of_type_compilation, rest_of_handle_final,\n        rest_of_handle_delay_slots, rest_of_handle_stack_regs,\n        rest_of_handle_variable_tracking, rest_of_handle_machine_reorg,\n        rest_of_handle_new_regalloc, rest_of_handle_old_regalloc,\n        rest_of_handle_regrename, rest_of_handle_reorder_blocks,\n        rest_of_handle_sched, rest_of_handle_sched2, rest_of_handle_regmove,\n        rest_of_handle_tracer, rest_of_handle_if_conversion,\n        rest_of_handle_if_after_combine, rest_of_handle_web,\n        rest_of_handle_branch_prob,\n        rest_of_handle_value_profile_transformations, rest_of_handle_cfg,\n        rest_of_handle_addressof, rest_of_handle_sibling_calls,\n        rest_of_handle_jump_bypass, rest_of_handle_inlining,\n        rest_of_handle_null_pointer, rest_of_handle_combine,\n        rest_of_handle_life, rest_of_handle_cse, rest_of_handle_cse2,\n        rest_of_handle_gcse, rest_of_handle_loop_optimize,\n        rest_of_handle_loop2, rest_of_compilation): Move to passes.c.\n        (decode_d_option): Use enable_rtl_dump_file.\n        (compile_file, finalize, do_compile): Move profile+combine+graph\n        cleanup to finish_optimization_passes.\n        * toplev.h (init_optimization_passes, finish_optimization_passes,\n        enable_rtl_dump_file): Declare.\n\nFrom-SVN: r78561", "tree": {"sha": "f404cfb28fb7f34eab07157ad76acbaa562772ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f404cfb28fb7f34eab07157ad76acbaa562772ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6db1481a7e4e5c6d97baecde520bcf60487deb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6db1481a7e4e5c6d97baecde520bcf60487deb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6db1481a7e4e5c6d97baecde520bcf60487deb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6db1481a7e4e5c6d97baecde520bcf60487deb5/comments", "author": null, "committer": null, "parents": [{"sha": "d0d48b174759e35af67e1b26b515cdb64912b3df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0d48b174759e35af67e1b26b515cdb64912b3df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0d48b174759e35af67e1b26b515cdb64912b3df"}], "stats": {"total": 4642, "additions": 2384, "deletions": 2258}, "files": [{"sha": "75a5453bb95b4d9f05c62d4e67fd186a2fc1e368", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6db1481a7e4e5c6d97baecde520bcf60487deb5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6db1481a7e4e5c6d97baecde520bcf60487deb5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f6db1481a7e4e5c6d97baecde520bcf60487deb5", "patch": "@@ -1,3 +1,37 @@\n+2004-02-27  Richard Henderson  <rth@redhat.com>\n+\n+\t* passes.c: New file.\n+\t* Makefile.in (OBJS-common): Add it.\n+\t* diagnostic.c (rtl_dump_and_exit): Move decl ...\n+\t* flags.h (rtl_dump_and_exit): ... here.\n+\t* output.h (size_directive_output, last_assemble_variable_decl): \n+\tMove from toplev.c.\n+\t* rtl.h (reg_alloc): Move from toplev.c.\n+\t* toplev.c (HAVE_conditional_execution, DUMPFILE_FORMAT,\n+\tstruct dump_file_info, enum dump_file_index, dump_file_tbl,\n+\topen_dump_file, close_dump_file, rest_of_decl_compilation,\n+\trest_of_type_compilation, rest_of_handle_final,\n+\trest_of_handle_delay_slots, rest_of_handle_stack_regs, \n+\trest_of_handle_variable_tracking, rest_of_handle_machine_reorg,\n+\trest_of_handle_new_regalloc, rest_of_handle_old_regalloc,\n+\trest_of_handle_regrename, rest_of_handle_reorder_blocks,\n+\trest_of_handle_sched, rest_of_handle_sched2, rest_of_handle_regmove,\n+\trest_of_handle_tracer, rest_of_handle_if_conversion, \n+\trest_of_handle_if_after_combine, rest_of_handle_web,\n+\trest_of_handle_branch_prob,\n+\trest_of_handle_value_profile_transformations, rest_of_handle_cfg,\n+\trest_of_handle_addressof, rest_of_handle_sibling_calls, \n+\trest_of_handle_jump_bypass, rest_of_handle_inlining,\n+\trest_of_handle_null_pointer, rest_of_handle_combine,\n+\trest_of_handle_life, rest_of_handle_cse, rest_of_handle_cse2,\n+\trest_of_handle_gcse, rest_of_handle_loop_optimize, \n+\trest_of_handle_loop2, rest_of_compilation): Move to passes.c.\n+\t(decode_d_option): Use enable_rtl_dump_file.\n+\t(compile_file, finalize, do_compile): Move profile+combine+graph\n+\tcleanup to finish_optimization_passes.\n+\t* toplev.h (init_optimization_passes, finish_optimization_passes,\n+\tenable_rtl_dump_file): Declare.\n+\n 2004-02-27  Eric Botcazou  <ebotcazou@act-europe.fr>\n             Roger Sayle  <roger@eyesopen.com>\n "}, {"sha": "c811d7d3c9753a098f06c54db2de62284740e2fc", "filename": "gcc/Makefile.in", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6db1481a7e4e5c6d97baecde520bcf60487deb5/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6db1481a7e4e5c6d97baecde520bcf60487deb5/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f6db1481a7e4e5c6d97baecde520bcf60487deb5", "patch": "@@ -865,7 +865,7 @@ OBJS-common = \\\n  sibcall.o simplify-rtx.o sreal.o stmt.o stor-layout.o stringpool.o \t   \\\n  targhooks.o timevar.o toplev.o tracer.o tree.o tree-dump.o unroll.o\t   \\\n  varasm.o varray.o version.o vmsdbgout.o xcoffout.o alloc-pool.o\t   \\\n- et-forest.o cfghooks.o bt-load.o pretty-print.o $(GGC) web.o\n+ et-forest.o cfghooks.o bt-load.o pretty-print.o $(GGC) web.o passes.o\n \n OBJS-md = $(out_object_file)\n OBJS-archive = $(EXTRA_OBJS) $(host_hook_obj) hashtable.o tree-inline.o\t   \\\n@@ -1540,6 +1540,16 @@ toplev.o : toplev.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t  -DTARGET_NAME=\\\"$(target_noncanonical)\\\" \\\n \t  -c $(srcdir)/toplev.c $(OUTPUT_OPTION)\n+\n+passes.o : passes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n+   $(RTL_H) function.h flags.h xcoffout.h input.h $(INSN_ATTR_H) output.h \\\n+   $(DIAGNOSTIC_H) debug.h insn-config.h intl.h $(RECOG_H) toplev.h \\\n+   dwarf2out.h sdbout.h dbxout.h $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) \\\n+   graph.h $(LOOP_H) except.h $(REGS_H) $(TIMEVAR_H) value-prof.h \\\n+   $(PARAMS_H) $(TM_P_H) reload.h dwarf2asm.h $(TARGET_H) \\\n+   langhooks.h insn-flags.h cfglayout.h real.h cfgloop.h \\\n+   hosthooks.h $(LANGHOOKS_DEF_H) cgraph.h $(COVERAGE_H) alloc-pool.h\n+\n main.o : main.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h\n \n host-default.o : host-default.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\"}, {"sha": "81f1026679d3aa093192ea686b48a0ecf9110be2", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6db1481a7e4e5c6d97baecde520bcf60487deb5/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6db1481a7e4e5c6d97baecde520bcf60487deb5/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=f6db1481a7e4e5c6d97baecde520bcf60487deb5", "patch": "@@ -56,8 +56,6 @@ static void diagnostic_action_after_output (diagnostic_context *,\n \t\t\t\t\t    diagnostic_info *);\n static void real_abort (void) ATTRIBUTE_NORETURN;\n \n-extern int rtl_dump_and_exit;\n-\n /* A diagnostic_context surrogate for stderr.  */\n static diagnostic_context global_diagnostic_context;\n diagnostic_context *global_dc = &global_diagnostic_context;"}, {"sha": "b986479c4b5a8b2109aa8e7f30376290f51778ef", "filename": "gcc/flags.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6db1481a7e4e5c6d97baecde520bcf60487deb5/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6db1481a7e4e5c6d97baecde520bcf60487deb5/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=f6db1481a7e4e5c6d97baecde520bcf60487deb5", "patch": "@@ -400,6 +400,7 @@ extern int flag_really_no_inline;\n /* Nonzero if we are only using compiler to check syntax errors.  */\n \n extern int flag_syntax_only;\n+extern int rtl_dump_and_exit;\n \n /* Nonzero means we should save auxiliary info into a .X file.  */\n "}, {"sha": "ee5668b4fee45d73bdd0f3a12d085c6fe9e7256c", "filename": "gcc/output.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6db1481a7e4e5c6d97baecde520bcf60487deb5/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6db1481a7e4e5c6d97baecde520bcf60487deb5/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=f6db1481a7e4e5c6d97baecde520bcf60487deb5", "patch": "@@ -432,6 +432,11 @@ extern rtx current_output_insn;\n    The precise value is the insn being output, to pass to error_for_asm.  */\n extern rtx this_is_asm_operands;\n \n+/* Carry information from ASM_DECLARE_OBJECT_NAME\n+   to ASM_FINISH_DECLARE_OBJECT.  */\n+extern int size_directive_output;\n+extern tree last_assemble_variable_decl;\n+\n /* Decide whether DECL needs to be in a writable section.\n    RELOC is the same as for SELECT_SECTION.  */\n extern bool decl_readonly_section (tree, int);"}, {"sha": "59de3af40e7e594db737494841c574e7c15d7c2b", "filename": "gcc/passes.c", "status": "added", "additions": 2177, "deletions": 0, "changes": 2177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6db1481a7e4e5c6d97baecde520bcf60487deb5/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6db1481a7e4e5c6d97baecde520bcf60487deb5/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=f6db1481a7e4e5c6d97baecde520bcf60487deb5", "patch": "@@ -0,0 +1,2177 @@\n+/* Top level of GCC compilers (cc1, cc1plus, etc.)\n+   Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n+   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+/* This is the top level of cc1/c++.\n+   It parses command args, opens files, invokes the various passes\n+   in the proper order, and counts the time used by each.\n+   Error messages and low-level interface to malloc also handled here.  */\n+\n+#include \"config.h\"\n+#undef FLOAT /* This is for hpux. They should change hpux.  */\n+#undef FFS  /* Some systems define this in param.h.  */\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include <signal.h>\n+\n+#ifdef HAVE_SYS_RESOURCE_H\n+# include <sys/resource.h>\n+#endif\n+\n+#ifdef HAVE_SYS_TIMES_H\n+# include <sys/times.h>\n+#endif\n+\n+#include \"line-map.h\"\n+#include \"input.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"flags.h\"\n+#include \"insn-attr.h\"\n+#include \"insn-config.h\"\n+#include \"insn-flags.h\"\n+#include \"hard-reg-set.h\"\n+#include \"recog.h\"\n+#include \"output.h\"\n+#include \"except.h\"\n+#include \"function.h\"\n+#include \"toplev.h\"\n+#include \"expr.h\"\n+#include \"basic-block.h\"\n+#include \"intl.h\"\n+#include \"ggc.h\"\n+#include \"graph.h\"\n+#include \"loop.h\"\n+#include \"regs.h\"\n+#include \"timevar.h\"\n+#include \"diagnostic.h\"\n+#include \"params.h\"\n+#include \"reload.h\"\n+#include \"dwarf2asm.h\"\n+#include \"integrate.h\"\n+#include \"real.h\"\n+#include \"debug.h\"\n+#include \"target.h\"\n+#include \"langhooks.h\"\n+#include \"cfglayout.h\"\n+#include \"cfgloop.h\"\n+#include \"hosthooks.h\"\n+#include \"cgraph.h\"\n+#include \"opts.h\"\n+#include \"coverage.h\"\n+#include \"value-prof.h\"\n+#include \"alloc-pool.h\"\n+\n+#if defined (DWARF2_UNWIND_INFO) || defined (DWARF2_DEBUGGING_INFO)\n+#include \"dwarf2out.h\"\n+#endif\n+\n+#if defined(DBX_DEBUGGING_INFO) || defined(XCOFF_DEBUGGING_INFO)\n+#include \"dbxout.h\"\n+#endif\n+\n+#ifdef SDB_DEBUGGING_INFO\n+#include \"sdbout.h\"\n+#endif\n+\n+#ifdef XCOFF_DEBUGGING_INFO\n+#include \"xcoffout.h\"\t\t/* Needed for external data\n+\t\t\t\t   declarations for e.g. AIX 4.x.  */\n+#endif\n+\n+#ifndef HAVE_conditional_execution\n+#define HAVE_conditional_execution 0\n+#endif\n+\n+/* Format to use to print dumpfile index value */\n+#ifndef DUMPFILE_FORMAT\n+#define DUMPFILE_FORMAT \".%02d.\"\n+#endif\n+\n+/* Describes a dump file.  */\n+\n+struct dump_file_info\n+{\n+  /* The unique extension to apply, e.g. \".jump\".  */\n+  const char *const extension;\n+\n+  /* The -d<c> character that enables this dump file.  */\n+  char const debug_switch;\n+\n+  /* True if there is a corresponding graph dump file.  */\n+  char const graph_dump_p;\n+\n+  /* True if the user selected this dump.  */\n+  char enabled;\n+\n+  /* True if the files have been initialized (ie truncated).  */\n+  char initialized;\n+};\n+\n+/* Enumerate the extant dump files.  */\n+\n+enum dump_file_index\n+{\n+  DFI_cgraph,\n+  DFI_rtl,\n+  DFI_sibling,\n+  DFI_eh,\n+  DFI_jump,\n+  DFI_null,\n+  DFI_cse,\n+  DFI_addressof,\n+  DFI_gcse,\n+  DFI_loop,\n+  DFI_bypass,\n+  DFI_cfg,\n+  DFI_bp,\n+  DFI_vpt,\n+  DFI_ce1,\n+  DFI_tracer,\n+  DFI_loop2,\n+  DFI_web,\n+  DFI_cse2,\n+  DFI_life,\n+  DFI_combine,\n+  DFI_ce2,\n+  DFI_regmove,\n+  DFI_sched,\n+  DFI_lreg,\n+  DFI_greg,\n+  DFI_postreload,\n+  DFI_flow2,\n+  DFI_peephole2,\n+  DFI_ce3,\n+  DFI_rnreg,\n+  DFI_bbro,\n+  DFI_branch_target_load,\n+  DFI_sched2,\n+  DFI_stack,\n+  DFI_vartrack,\n+  DFI_mach,\n+  DFI_dbr,\n+  DFI_MAX\n+};\n+\n+/* Describes all the dump files.  Should be kept in order of the\n+   pass and in sync with dump_file_index above.\n+\n+   Remaining -d letters:\n+\n+\t\"   e        m   q         \"\n+\t\"         JK   O Q     WXY \"\n+*/\n+\n+static struct dump_file_info dump_file_tbl[DFI_MAX] =\n+{\n+  { \"cgraph\",\t'U', 0, 0, 0 },\n+  { \"rtl\",\t'r', 0, 0, 0 },\n+  { \"sibling\",  'i', 0, 0, 0 },\n+  { \"eh\",\t'h', 0, 0, 0 },\n+  { \"jump\",\t'j', 0, 0, 0 },\n+  { \"null\",\t'u', 0, 0, 0 },\n+  { \"cse\",\t's', 0, 0, 0 },\n+  { \"addressof\", 'F', 0, 0, 0 },\n+  { \"gcse\",\t'G', 1, 0, 0 },\n+  { \"loop\",\t'L', 1, 0, 0 },\n+  { \"bypass\",   'G', 1, 0, 0 }, /* Yes, duplicate enable switch.  */\n+  { \"cfg\",\t'f', 1, 0, 0 },\n+  { \"bp\",\t'b', 1, 0, 0 },\n+  { \"vpt\",\t'V', 1, 0, 0 },\n+  { \"ce1\",\t'C', 1, 0, 0 },\n+  { \"tracer\",\t'T', 1, 0, 0 },\n+  { \"loop2\",\t'L', 1, 0, 0 },\n+  { \"web\",      'Z', 0, 0, 0 },\n+  { \"cse2\",\t't', 1, 0, 0 },\n+  { \"life\",\t'f', 1, 0, 0 },\t/* Yes, duplicate enable switch.  */\n+  { \"combine\",\t'c', 1, 0, 0 },\n+  { \"ce2\",\t'C', 1, 0, 0 },\n+  { \"regmove\",\t'N', 1, 0, 0 },\n+  { \"sched\",\t'S', 1, 0, 0 },\n+  { \"lreg\",\t'l', 1, 0, 0 },\n+  { \"greg\",\t'g', 1, 0, 0 },\n+  { \"postreload\", 'o', 1, 0, 0 },\n+  { \"flow2\",\t'w', 1, 0, 0 },\n+  { \"peephole2\", 'z', 1, 0, 0 },\n+  { \"ce3\",\t'E', 1, 0, 0 },\n+  { \"rnreg\",\t'n', 1, 0, 0 },\n+  { \"bbro\",\t'B', 1, 0, 0 },\n+  { \"btl\",\t'd', 1, 0, 0 }, /* Yes, duplicate enable switch.  */\n+  { \"sched2\",\t'R', 1, 0, 0 },\n+  { \"stack\",\t'k', 1, 0, 0 },\n+  { \"vartrack\",\t'V', 1, 0, 0 }, /* Yes, duplicate enable switch.  */\n+  { \"mach\",\t'M', 1, 0, 0 },\n+  { \"dbr\",\t'd', 0, 0, 0 },\n+};\n+\n+/* Routine to open a dump file.  Return true if the dump file is enabled.  */\n+\n+static int\n+open_dump_file (enum dump_file_index index, tree decl)\n+{\n+  char *dump_name;\n+  const char *open_arg;\n+  char seq[16];\n+\n+  if (! dump_file_tbl[index].enabled)\n+    return 0;\n+\n+  timevar_push (TV_DUMP);\n+  if (dump_file != NULL)\n+    fclose (dump_file);\n+\n+  sprintf (seq, DUMPFILE_FORMAT, index);\n+\n+  if (! dump_file_tbl[index].initialized)\n+    {\n+      /* If we've not initialized the files, do so now.  */\n+      if (graph_dump_format != no_graph\n+\t  && dump_file_tbl[index].graph_dump_p)\n+\t{\n+\t  dump_name = concat (seq, dump_file_tbl[index].extension, NULL);\n+\t  clean_graph_dump_file (dump_base_name, dump_name);\n+\t  free (dump_name);\n+\t}\n+      dump_file_tbl[index].initialized = 1;\n+      open_arg = \"w\";\n+    }\n+  else\n+    open_arg = \"a\";\n+\n+  dump_name = concat (dump_base_name, seq,\n+\t\t      dump_file_tbl[index].extension, NULL);\n+\n+  dump_file = fopen (dump_name, open_arg);\n+  if (dump_file == NULL)\n+    fatal_error (\"can't open %s: %m\", dump_name);\n+\n+  free (dump_name);\n+\n+  if (decl)\n+    fprintf (dump_file, \"\\n;; Function %s%s\\n\\n\",\n+\t     (*lang_hooks.decl_printable_name) (decl, 2),\n+\t     cfun->function_frequency == FUNCTION_FREQUENCY_HOT\n+\t     ? \" (hot)\"\n+\t     : cfun->function_frequency == FUNCTION_FREQUENCY_UNLIKELY_EXECUTED\n+\t     ? \" (unlikely executed)\"\n+\t     : \"\");\n+\n+  timevar_pop (TV_DUMP);\n+  return 1;\n+}\n+\n+/* Routine to close a dump file.  */\n+\n+static void\n+close_dump_file (enum dump_file_index index,\n+\t\t void (*func) (FILE *, rtx),\n+\t\t rtx insns)\n+{\n+  if (! dump_file)\n+    return;\n+\n+  timevar_push (TV_DUMP);\n+  if (insns\n+      && graph_dump_format != no_graph\n+      && dump_file_tbl[index].graph_dump_p)\n+    {\n+      char seq[16];\n+      char *suffix;\n+\n+      sprintf (seq, DUMPFILE_FORMAT, index);\n+      suffix = concat (seq, dump_file_tbl[index].extension, NULL);\n+      print_rtl_graph_with_bb (dump_base_name, suffix, insns);\n+      free (suffix);\n+    }\n+\n+  if (func && insns)\n+    func (dump_file, insns);\n+\n+  fflush (dump_file);\n+  fclose (dump_file);\n+\n+  dump_file = NULL;\n+  timevar_pop (TV_DUMP);\n+}\n+\n+/* This is called from various places for FUNCTION_DECL, VAR_DECL,\n+   and TYPE_DECL nodes.\n+\n+   This does nothing for local (non-static) variables, unless the\n+   variable is a register variable with an ASMSPEC.  In that case, or\n+   if the variable is not an automatic, it sets up the RTL and\n+   outputs any assembler code (label definition, storage allocation\n+   and initialization).\n+\n+   DECL is the declaration.  If ASMSPEC is nonzero, it specifies\n+   the assembler symbol name to be used.  TOP_LEVEL is nonzero\n+   if this declaration is not within a function.  */\n+\n+void\n+rest_of_decl_compilation (tree decl,\n+\t\t\t  const char *asmspec,\n+\t\t\t  int top_level,\n+\t\t\t  int at_end)\n+{\n+  /* We deferred calling assemble_alias so that we could collect\n+     other attributes such as visibility.  Emit the alias now.  */\n+  {\n+    tree alias;\n+    alias = lookup_attribute (\"alias\", DECL_ATTRIBUTES (decl));\n+    if (alias)\n+      {\n+\talias = TREE_VALUE (TREE_VALUE (alias));\n+\talias = get_identifier (TREE_STRING_POINTER (alias));\n+\tassemble_alias (decl, alias);\n+      }\n+  }\n+\n+  /* Forward declarations for nested functions are not \"external\",\n+     but we need to treat them as if they were.  */\n+  if (TREE_STATIC (decl) || DECL_EXTERNAL (decl)\n+      || TREE_CODE (decl) == FUNCTION_DECL)\n+    {\n+      timevar_push (TV_VARCONST);\n+\n+      if (asmspec)\n+\tmake_decl_rtl (decl, asmspec);\n+\n+      /* Don't output anything when a tentative file-scope definition\n+\t is seen.  But at end of compilation, do output code for them.\n+\n+\t We do output all variables when unit-at-a-time is active and rely on\n+\t callgraph code to defer them except for forward declarations\n+\t (see gcc.c-torture/compile/920624-1.c) */\n+      if ((at_end\n+\t   || !DECL_DEFER_OUTPUT (decl)\n+\t   || (flag_unit_at_a_time && DECL_INITIAL (decl)))\n+\t  && !DECL_EXTERNAL (decl))\n+\t{\n+\t  if (flag_unit_at_a_time && !cgraph_global_info_ready\n+\t      && TREE_CODE (decl) != FUNCTION_DECL && top_level)\n+\t    cgraph_varpool_finalize_decl (decl);\n+\t  else\n+\t    assemble_variable (decl, top_level, at_end, 0);\n+\t}\n+\n+#ifdef ASM_FINISH_DECLARE_OBJECT\n+      if (decl == last_assemble_variable_decl)\n+\t{\n+\t  ASM_FINISH_DECLARE_OBJECT (asm_out_file, decl,\n+\t\t\t\t     top_level, at_end);\n+\t}\n+#endif\n+\n+      timevar_pop (TV_VARCONST);\n+    }\n+  else if (DECL_REGISTER (decl) && asmspec != 0)\n+    {\n+      if (decode_reg_name (asmspec) >= 0)\n+\t{\n+\t  SET_DECL_RTL (decl, NULL_RTX);\n+\t  make_decl_rtl (decl, asmspec);\n+\t}\n+      else\n+\t{\n+\t  error (\"invalid register name `%s' for register variable\", asmspec);\n+\t  DECL_REGISTER (decl) = 0;\n+\t  if (!top_level)\n+\t    expand_decl (decl);\n+\t}\n+    }\n+  else if (TREE_CODE (decl) == TYPE_DECL)\n+    {\n+      timevar_push (TV_SYMOUT);\n+      debug_hooks->type_decl (decl, !top_level);\n+      timevar_pop (TV_SYMOUT);\n+    }\n+}\n+\n+/* Called after finishing a record, union or enumeral type.  */\n+\n+void\n+rest_of_type_compilation (tree type, int toplev)\n+{\n+  /* Avoid confusing the debug information machinery when there are\n+     errors.  */\n+  if (errorcount != 0 || sorrycount != 0)\n+    return;\n+\n+  timevar_push (TV_SYMOUT);\n+  debug_hooks->type_decl (TYPE_STUB_DECL (type), !toplev);\n+  timevar_pop (TV_SYMOUT);\n+}\n+\n+/* Turn the RTL into assembly.  */\n+static void\n+rest_of_handle_final (tree decl, rtx insns)\n+{\n+  timevar_push (TV_FINAL);\n+  {\n+    rtx x;\n+    const char *fnname;\n+\n+    /* Get the function's name, as described by its RTL.  This may be\n+       different from the DECL_NAME name used in the source file.  */\n+\n+    x = DECL_RTL (decl);\n+    if (GET_CODE (x) != MEM)\n+      abort ();\n+    x = XEXP (x, 0);\n+    if (GET_CODE (x) != SYMBOL_REF)\n+      abort ();\n+    fnname = XSTR (x, 0);\n+\n+    assemble_start_function (decl, fnname);\n+    final_start_function (insns, asm_out_file, optimize);\n+    final (insns, asm_out_file, optimize, 0);\n+    final_end_function ();\n+\n+#ifdef IA64_UNWIND_INFO\n+    /* ??? The IA-64 \".handlerdata\" directive must be issued before\n+       the \".endp\" directive that closes the procedure descriptor.  */\n+    output_function_exception_table ();\n+#endif\n+\n+    assemble_end_function (decl, fnname);\n+\n+#ifndef IA64_UNWIND_INFO\n+    /* Otherwise, it feels unclean to switch sections in the middle.  */\n+    output_function_exception_table ();\n+#endif\n+\n+    if (! quiet_flag)\n+      fflush (asm_out_file);\n+\n+    /* Release all memory allocated by flow.  */\n+    free_basic_block_vars (0);\n+\n+    /* Release all memory held by regsets now.  */\n+    regset_release_memory ();\n+  }\n+  timevar_pop (TV_FINAL);\n+\n+  ggc_collect ();\n+}\n+\n+#ifdef DELAY_SLOTS\n+/* Run delay slot optimization.  */\n+static void\n+rest_of_handle_delay_slots (tree decl, rtx insns)\n+{\n+  timevar_push (TV_DBR_SCHED);\n+  open_dump_file (DFI_dbr, decl);\n+\n+  dbr_schedule (insns, dump_file);\n+\n+  close_dump_file (DFI_dbr, print_rtl, insns);\n+  timevar_pop (TV_DBR_SCHED);\n+\n+  ggc_collect ();\n+}\n+#endif\n+\n+#ifdef STACK_REGS\n+/* Convert register usage from flat register file usage to a stack\n+   register file.  */\n+static void\n+rest_of_handle_stack_regs (tree decl, rtx insns)\n+{\n+#if defined (HAVE_ATTR_length)\n+  /* If flow2 creates new instructions which need splitting\n+     and scheduling after reload is not done, they might not be\n+     split until final which doesn't allow splitting\n+     if HAVE_ATTR_length.  */\n+#ifdef INSN_SCHEDULING\n+  if (optimize && !flag_schedule_insns_after_reload)\n+#else\n+  if (optimize)\n+#endif\n+    {\n+      timevar_push (TV_SHORTEN_BRANCH);\n+      split_all_insns (1);\n+      timevar_pop (TV_SHORTEN_BRANCH);\n+    }\n+#endif\n+\n+  timevar_push (TV_REG_STACK);\n+  open_dump_file (DFI_stack, decl);\n+\n+  if (reg_to_stack (insns, dump_file) && optimize)\n+    {\n+      if (cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK\n+\t\t       | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0))\n+\t  && flag_reorder_blocks)\n+\t{\n+\t  reorder_basic_blocks ();\n+\t  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK);\n+\t}\n+    }\n+\n+  close_dump_file (DFI_stack, print_rtl_with_bb, insns);\n+  timevar_pop (TV_REG_STACK);\n+\n+  ggc_collect ();\n+}\n+#endif\n+\n+/* Track the variables, ie. compute where the variable is stored at each position in function.  */\n+static void\n+rest_of_handle_variable_tracking (tree decl, rtx insns)\n+{\n+  timevar_push (TV_VAR_TRACKING);\n+  open_dump_file (DFI_vartrack, decl);\n+\n+  variable_tracking_main ();\n+\n+  close_dump_file (DFI_vartrack, print_rtl_with_bb, insns);\n+  timevar_pop (TV_VAR_TRACKING);\n+}\n+\n+/* Machine independent reorg pass.  */\n+static void\n+rest_of_handle_machine_reorg (tree decl, rtx insns)\n+{\n+  timevar_push (TV_MACH_DEP);\n+  open_dump_file (DFI_mach, decl);\n+\n+  (*targetm.machine_dependent_reorg) ();\n+\n+  close_dump_file (DFI_mach, print_rtl, insns);\n+  timevar_pop (TV_MACH_DEP);\n+\n+  ggc_collect ();\n+}\n+\n+\n+/* Run new register allocator.  Return TRUE if we must exit\n+   rest_of_compilation upon return.  */\n+static bool\n+rest_of_handle_new_regalloc (tree decl, rtx insns)\n+{\n+  int failure;\n+\n+  delete_trivially_dead_insns (insns, max_reg_num ());\n+  reg_alloc ();\n+\n+  timevar_pop (TV_LOCAL_ALLOC);\n+  if (dump_file_tbl[DFI_lreg].enabled)\n+    {\n+      timevar_push (TV_DUMP);\n+\n+      close_dump_file (DFI_lreg, NULL, NULL);\n+      timevar_pop (TV_DUMP);\n+    }\n+\n+  /* XXX clean up the whole mess to bring live info in shape again.  */\n+  timevar_push (TV_GLOBAL_ALLOC);\n+  open_dump_file (DFI_greg, decl);\n+\n+  build_insn_chain (insns);\n+  failure = reload (insns, 0);\n+\n+  timevar_pop (TV_GLOBAL_ALLOC);\n+\n+  if (dump_file_tbl[DFI_greg].enabled)\n+    {\n+      timevar_push (TV_DUMP);\n+\n+      dump_global_regs (dump_file);\n+\n+      close_dump_file (DFI_greg, print_rtl_with_bb, insns);\n+      timevar_pop (TV_DUMP);\n+    }\n+\n+  if (failure)\n+    return true;\n+\n+  reload_completed = 1;\n+\n+  return false;\n+}\n+\n+/* Run old register allocator.  Return TRUE if we must exit\n+   rest_of_compilation upon return.  */\n+static bool\n+rest_of_handle_old_regalloc (tree decl, rtx insns)\n+{\n+  int failure;\n+  int rebuild_notes;\n+\n+  /* Allocate the reg_renumber array.  */\n+  allocate_reg_info (max_regno, FALSE, TRUE);\n+\n+  /* And the reg_equiv_memory_loc array.  */\n+  reg_equiv_memory_loc = xcalloc (max_regno, sizeof (rtx));\n+\n+  allocate_initial_values (reg_equiv_memory_loc);\n+\n+  regclass (insns, max_reg_num (), dump_file);\n+  rebuild_notes = local_alloc ();\n+\n+  timevar_pop (TV_LOCAL_ALLOC);\n+\n+  /* Local allocation may have turned an indirect jump into a direct\n+     jump.  If so, we must rebuild the JUMP_LABEL fields of jumping\n+     instructions.  */\n+  if (rebuild_notes)\n+    {\n+      timevar_push (TV_JUMP);\n+\n+      rebuild_jump_labels (insns);\n+      purge_all_dead_edges (0);\n+\n+      timevar_pop (TV_JUMP);\n+    }\n+\n+  if (dump_file_tbl[DFI_lreg].enabled)\n+    {\n+      timevar_push (TV_DUMP);\n+\n+      dump_flow_info (dump_file);\n+      dump_local_alloc (dump_file);\n+\n+      close_dump_file (DFI_lreg, print_rtl_with_bb, insns);\n+      timevar_pop (TV_DUMP);\n+    }\n+\n+  ggc_collect ();\n+\n+  timevar_push (TV_GLOBAL_ALLOC);\n+  open_dump_file (DFI_greg, decl);\n+\n+  /* If optimizing, allocate remaining pseudo-regs.  Do the reload\n+     pass fixing up any insns that are invalid.  */\n+\n+  if (optimize)\n+    failure = global_alloc (dump_file);\n+  else\n+    {\n+      build_insn_chain (insns);\n+      failure = reload (insns, 0);\n+    }\n+\n+  timevar_pop (TV_GLOBAL_ALLOC);\n+\n+  if (dump_file_tbl[DFI_greg].enabled)\n+    {\n+      timevar_push (TV_DUMP);\n+\n+      dump_global_regs (dump_file);\n+\n+      close_dump_file (DFI_greg, print_rtl_with_bb, insns);\n+      timevar_pop (TV_DUMP);\n+    }\n+\n+  return failure;\n+}\n+\n+/* Run the regrename and cprop passes.  */\n+static void\n+rest_of_handle_regrename (tree decl, rtx insns)\n+{\n+  timevar_push (TV_RENAME_REGISTERS);\n+  open_dump_file (DFI_rnreg, decl);\n+\n+  if (flag_rename_registers)\n+    regrename_optimize ();\n+  if (flag_cprop_registers)\n+    copyprop_hardreg_forward ();\n+\n+  close_dump_file (DFI_rnreg, print_rtl_with_bb, insns);\n+  timevar_pop (TV_RENAME_REGISTERS);\n+}\n+\n+/* Reorder basic blocks.  */\n+static void\n+rest_of_handle_reorder_blocks (tree decl, rtx insns)\n+{\n+  bool changed;\n+  open_dump_file (DFI_bbro, decl);\n+\n+  /* Last attempt to optimize CFG, as scheduling, peepholing and insn\n+     splitting possibly introduced more crossjumping opportunities.  */\n+  changed = cleanup_cfg (CLEANUP_EXPENSIVE\n+\t\t\t | (!HAVE_conditional_execution\n+\t\t\t    ? CLEANUP_UPDATE_LIFE : 0));\n+\n+  if (flag_sched2_use_traces && flag_schedule_insns_after_reload)\n+    tracer ();\n+  if (flag_reorder_blocks)\n+    reorder_basic_blocks ();\n+  if (flag_reorder_blocks\n+      || (flag_sched2_use_traces && flag_schedule_insns_after_reload))\n+    changed |= cleanup_cfg (CLEANUP_EXPENSIVE\n+\t\t\t    | (!HAVE_conditional_execution\n+\t\t\t       ? CLEANUP_UPDATE_LIFE : 0));\n+\n+  /* On conditional execution targets we can not update the life cheaply, so\n+     we deffer the updating to after both cleanups.  This may lose some cases\n+     but should not be terribly bad.  */\n+  if (changed && HAVE_conditional_execution)\n+    update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES,\n+\t\t      PROP_DEATH_NOTES);\n+  close_dump_file (DFI_bbro, print_rtl_with_bb, insns);\n+}\n+\n+#ifdef INSN_SCHEDULING\n+/* Run instruction scheduler.  */\n+static void\n+rest_of_handle_sched (tree decl, rtx insns)\n+{\n+  timevar_push (TV_SCHED);\n+\n+  /* Print function header into sched dump now\n+     because doing the sched analysis makes some of the dump.  */\n+  if (optimize > 0 && flag_schedule_insns)\n+    {\n+      open_dump_file (DFI_sched, decl);\n+\n+      /* Do control and data sched analysis,\n+\t and write some of the results to dump file.  */\n+\n+      schedule_insns (dump_file);\n+\n+      close_dump_file (DFI_sched, print_rtl_with_bb, insns);\n+    }\n+  timevar_pop (TV_SCHED);\n+\n+  ggc_collect ();\n+}\n+\n+/* Run second scheduling pass after reload.  */\n+static void\n+rest_of_handle_sched2 (tree decl, rtx insns)\n+{\n+  timevar_push (TV_SCHED2);\n+  open_dump_file (DFI_sched2, decl);\n+\n+  /* Do control and data sched analysis again,\n+     and write some more of the results to dump file.  */\n+\n+  split_all_insns (1);\n+\n+  if (flag_sched2_use_superblocks || flag_sched2_use_traces)\n+    {\n+      schedule_ebbs (dump_file);\n+      /* No liveness updating code yet, but it should be easy to do.\n+\t reg-stack recompute the liveness when needed for now.  */\n+      count_or_remove_death_notes (NULL, 1);\n+      cleanup_cfg (CLEANUP_EXPENSIVE);\n+    }\n+  else\n+    schedule_insns (dump_file);\n+\n+  close_dump_file (DFI_sched2, print_rtl_with_bb, insns);\n+  timevar_pop (TV_SCHED2);\n+\n+  ggc_collect ();\n+}\n+#endif\n+\n+/* Register allocation pre-pass, to reduce number of moves necessary\n+   for two-address machines.  */\n+static void\n+rest_of_handle_regmove (tree decl, rtx insns)\n+{\n+  timevar_push (TV_REGMOVE);\n+  open_dump_file (DFI_regmove, decl);\n+\n+  regmove_optimize (insns, max_reg_num (), dump_file);\n+\n+  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE);\n+  close_dump_file (DFI_regmove, print_rtl_with_bb, insns);\n+  timevar_pop (TV_REGMOVE);\n+\n+  ggc_collect ();\n+}\n+\n+/* Run tracer.  */\n+static void\n+rest_of_handle_tracer (tree decl, rtx insns)\n+{\n+  open_dump_file (DFI_tracer, decl);\n+  if (dump_file)\n+    dump_flow_info (dump_file);\n+  tracer ();\n+  cleanup_cfg (CLEANUP_EXPENSIVE);\n+  reg_scan (insns, max_reg_num (), 0);\n+  close_dump_file (DFI_tracer, print_rtl_with_bb, get_insns ());\n+}\n+\n+/* If-conversion and CFG cleanup.  */\n+static void\n+rest_of_handle_if_conversion (tree decl, rtx insns)\n+{\n+  open_dump_file (DFI_ce1, decl);\n+  if (flag_if_conversion)\n+    {\n+      timevar_push (TV_IFCVT);\n+      if (dump_file)\n+\tdump_flow_info (dump_file);\n+      cleanup_cfg (CLEANUP_EXPENSIVE);\n+      reg_scan (insns, max_reg_num (), 0);\n+      if_convert (0);\n+      timevar_pop (TV_IFCVT);\n+    }\n+  timevar_push (TV_JUMP);\n+  cleanup_cfg (CLEANUP_EXPENSIVE);\n+  reg_scan (insns, max_reg_num (), 0);\n+  timevar_pop (TV_JUMP);\n+  close_dump_file (DFI_ce1, print_rtl_with_bb, get_insns ());\n+}\n+\n+/* Rerun if-conversion, as combine may have simplified things enough\n+   to now meet sequence length restrictions.  */\n+static void\n+rest_of_handle_if_after_combine (tree decl, rtx insns)\n+{\n+  timevar_push (TV_IFCVT);\n+  open_dump_file (DFI_ce2, decl);\n+\n+  no_new_pseudos = 0;\n+  if_convert (1);\n+  no_new_pseudos = 1;\n+\n+  close_dump_file (DFI_ce2, print_rtl_with_bb, insns);\n+  timevar_pop (TV_IFCVT);\n+}\n+\n+static void\n+rest_of_handle_web (tree decl, rtx insns)\n+{\n+  open_dump_file (DFI_web, decl);\n+  timevar_push (TV_WEB);\n+  web_main ();\n+  delete_trivially_dead_insns (insns, max_reg_num ());\n+  cleanup_cfg (CLEANUP_EXPENSIVE);\n+\n+  timevar_pop (TV_WEB);\n+  close_dump_file (DFI_web, print_rtl_with_bb, insns);\n+  reg_scan (get_insns (), max_reg_num (), 0);\n+}\n+\n+/* Do branch profiling and static profile estimation passes.  */\n+static void\n+rest_of_handle_branch_prob (tree decl, rtx insns)\n+{\n+  struct loops loops;\n+\n+  timevar_push (TV_BRANCH_PROB);\n+  open_dump_file (DFI_bp, decl);\n+\n+  if (profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n+    branch_prob ();\n+\n+  /* Discover and record the loop depth at the head of each basic\n+     block.  The loop infrastructure does the real job for us.  */\n+  flow_loops_find (&loops, LOOP_TREE);\n+\n+  if (dump_file)\n+    flow_loops_dump (&loops, dump_file, NULL, 0);\n+\n+  /* Estimate using heuristics if no profiling info is available.  */\n+  if (flag_guess_branch_prob)\n+    estimate_probability (&loops);\n+\n+  flow_loops_free (&loops);\n+  free_dominance_info (CDI_DOMINATORS);\n+  close_dump_file (DFI_bp, print_rtl_with_bb, insns);\n+  timevar_pop (TV_BRANCH_PROB);\n+}\n+\n+/* Do optimizations based on expression value profiles.  */\n+static void\n+rest_of_handle_value_profile_transformations (tree decl, rtx insns)\n+{\n+  open_dump_file (DFI_vpt, decl);\n+  timevar_push (TV_VPT);\n+\n+  if (value_profile_transformations ())\n+    cleanup_cfg (CLEANUP_EXPENSIVE);\n+\n+  timevar_pop (TV_VPT);\n+  close_dump_file (DFI_vpt, print_rtl_with_bb, insns);\n+}\n+\n+/* Do control and data flow analysis; write some of the results to the\n+   dump file.  */\n+static void\n+rest_of_handle_cfg (tree decl, rtx insns)\n+{\n+  open_dump_file (DFI_cfg, decl);\n+  if (dump_file)\n+    dump_flow_info (dump_file);\n+  if (optimize)\n+    cleanup_cfg (CLEANUP_EXPENSIVE\n+\t\t | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n+\n+  /* It may make more sense to mark constant functions after dead code is\n+     eliminated by life_analysis, but we need to do it early, as -fprofile-arcs\n+     may insert code making function non-constant, but we still must consider\n+     it as constant, otherwise -fbranch-probabilities will not read data back.\n+\n+     life_analysis rarely eliminates modification of external memory.\n+   */\n+  if (optimize)\n+    {\n+      /* Alias analysis depends on this information and mark_constant_function\n+       depends on alias analysis.  */\n+      reg_scan (insns, max_reg_num (), 1);\n+      mark_constant_function ();\n+    }\n+\n+  close_dump_file (DFI_cfg, print_rtl_with_bb, insns);\n+}\n+\n+/* Purge addressofs.  */\n+static void\n+rest_of_handle_addressof (tree decl, rtx insns)\n+{\n+  open_dump_file (DFI_addressof, decl);\n+\n+  purge_addressof (insns);\n+  if (optimize && purge_all_dead_edges (0))\n+    delete_unreachable_blocks ();\n+  reg_scan (insns, max_reg_num (), 1);\n+\n+  close_dump_file (DFI_addressof, print_rtl, insns);\n+}\n+\n+/* We may have potential sibling or tail recursion sites.  Select one\n+   (of possibly multiple) methods of performing the call.  */\n+static void\n+rest_of_handle_sibling_calls (rtx insns)\n+{\n+  rtx insn;\n+  optimize_sibling_and_tail_recursive_calls ();\n+\n+  /* Recompute the CFG as sibling optimization clobbers it randomly.  */\n+  free_bb_for_insn ();\n+  find_exception_handler_labels ();\n+  rebuild_jump_labels (insns);\n+  find_basic_blocks (insns, max_reg_num (), dump_file);\n+\n+  /* There is pass ordering problem - we must lower NOTE_INSN_PREDICTION\n+     notes before simplifying cfg and we must do lowering after sibcall\n+     that unhides parts of RTL chain and cleans up the CFG.\n+\n+     Until sibcall is replaced by tree-level optimizer, lets just\n+     sweep away the NOTE_INSN_PREDICTION notes that leaked out.  */\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    if (GET_CODE (insn) == NOTE\n+\t&& NOTE_LINE_NUMBER (insn) == NOTE_INSN_PREDICTION)\n+      delete_insn (insn);\n+\n+  close_dump_file (DFI_sibling, print_rtl, get_insns ());\n+}\n+\n+/* Perform jump bypassing and control flow optimizations.  */\n+static void\n+rest_of_handle_jump_bypass (tree decl, rtx insns)\n+{\n+  timevar_push (TV_BYPASS);\n+  open_dump_file (DFI_bypass, decl);\n+\n+  cleanup_cfg (CLEANUP_EXPENSIVE);\n+  reg_scan (insns, max_reg_num (), 1);\n+\n+  if (bypass_jumps (dump_file))\n+    {\n+      rebuild_jump_labels (insns);\n+      cleanup_cfg (CLEANUP_EXPENSIVE);\n+      delete_trivially_dead_insns (insns, max_reg_num ());\n+    }\n+\n+  close_dump_file (DFI_bypass, print_rtl_with_bb, insns);\n+  timevar_pop (TV_BYPASS);\n+\n+  ggc_collect ();\n+\n+#ifdef ENABLE_CHECKING\n+  verify_flow_info ();\n+#endif\n+}\n+\n+/* Handle inlining of functions in rest_of_compilation.  Return TRUE\n+   if we must exit rest_of_compilation upon return.  */\n+static bool\n+rest_of_handle_inlining (tree decl)\n+{\n+  rtx insns;\n+  int inlinable = 0;\n+  tree parent;\n+  const char *lose;\n+\n+  /* If we are reconsidering an inline function at the end of\n+     compilation, skip the stuff for making it inline.  */\n+  if (cfun->rtl_inline_init)\n+    return 0;\n+  cfun->rtl_inline_init = 1;\n+\n+  /* If this is nested inside an inlined external function, pretend\n+     it was only declared.  Since we cannot inline such functions,\n+     generating code for this one is not only not necessary but will\n+     confuse some debugging output writers.  */\n+  for (parent = DECL_CONTEXT (current_function_decl);\n+       parent != NULL_TREE;\n+       parent = get_containing_scope (parent))\n+    if (TREE_CODE (parent) == FUNCTION_DECL\n+\t&& DECL_INLINE (parent) && DECL_EXTERNAL (parent))\n+      {\n+\tDECL_INITIAL (decl) = 0;\n+\treturn true;\n+      }\n+    else if (TYPE_P (parent))\n+      /* A function in a local class should be treated normally.  */\n+      break;\n+\n+  /* If requested, consider whether to make this function inline.  */\n+  if ((DECL_INLINE (decl) && !flag_no_inline)\n+      || flag_inline_functions)\n+    {\n+      timevar_push (TV_INTEGRATION);\n+      lose = function_cannot_inline_p (decl);\n+      timevar_pop (TV_INTEGRATION);\n+      if (lose || ! optimize)\n+\t{\n+\t  if (warn_inline && lose && DECL_INLINE (decl))\n+            {\n+              char *msg = concat (\"%J\", lose, NULL);\n+              warning (msg, decl);\n+              free (msg);\n+            }\n+\t  DECL_ABSTRACT_ORIGIN (decl) = 0;\n+\t  /* Don't really compile an extern inline function.\n+\t     If we can't make it inline, pretend\n+\t     it was only declared.  */\n+\t  if (DECL_EXTERNAL (decl))\n+\t    {\n+\t      DECL_INITIAL (decl) = 0;\n+\t      return true;\n+\t    }\n+\t}\n+      else\n+\tinlinable = DECL_INLINE (decl) = 1;\n+    }\n+\n+  insns = get_insns ();\n+\n+  /* Dump the rtl code if we are dumping rtl.  */\n+\n+  if (open_dump_file (DFI_rtl, decl))\n+    {\n+      if (DECL_STRUCT_FUNCTION (decl)\n+\t  && DECL_STRUCT_FUNCTION (decl)->saved_for_inline)\n+\tfprintf (dump_file, \";; (integrable)\\n\\n\");\n+      close_dump_file (DFI_rtl, print_rtl, insns);\n+    }\n+\n+  /* Convert from NOTE_INSN_EH_REGION style notes, and do other\n+     sorts of eh initialization.  Delay this until after the\n+     initial rtl dump so that we can see the original nesting.  */\n+  convert_from_eh_region_ranges ();\n+\n+  /* If function is inline, and we don't yet know whether to\n+     compile it by itself, defer decision till end of compilation.\n+     wrapup_global_declarations will (indirectly) call\n+     rest_of_compilation again for those functions that need to\n+     be output.  Also defer those functions that we are supposed\n+     to defer.  */\n+\n+  if (inlinable\n+      || (DECL_INLINE (decl)\n+\t  /* Egad.  This RTL deferral test conflicts with Fortran assumptions\n+\t     for unreferenced symbols.  See g77.f-torture/execute/980520-1.f.\n+\t     But removing this line from the check breaks all languages that\n+\t     use the call graph to output symbols.  This hard-coded check is\n+\t     the least invasive work-around.  */\n+\t  && (flag_inline_functions\n+\t      || strcmp (lang_hooks.name, \"GNU F77\") == 0)\n+\t  && ((! TREE_PUBLIC (decl) && ! TREE_ADDRESSABLE (decl)\n+\t       && ! TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))\n+\t       && ! flag_keep_inline_functions)\n+\t      || DECL_EXTERNAL (decl))))\n+    DECL_DEFER_OUTPUT (decl) = 1;\n+\n+  if (DECL_INLINE (decl))\n+    /* DWARF wants separate debugging info for abstract and\n+       concrete instances of all inline functions, including those\n+       declared inline but not inlined, and those inlined even\n+       though they weren't declared inline.  Conveniently, that's\n+       what DECL_INLINE means at this point.  */\n+    (*debug_hooks->deferred_inline_function) (decl);\n+\n+  if (DECL_DEFER_OUTPUT (decl))\n+    {\n+      /* If -Wreturn-type, we have to do a bit of compilation.  We just\n+\t want to call cleanup the cfg to figure out whether or not we can\n+\t fall off the end of the function; we do the minimum amount of\n+\t work necessary to make that safe.  */\n+      if (warn_return_type)\n+\t{\n+\t  int saved_optimize = optimize;\n+\n+\t  optimize = 0;\n+\t  rebuild_jump_labels (insns);\n+\t  find_exception_handler_labels ();\n+\t  find_basic_blocks (insns, max_reg_num (), dump_file);\n+\t  cleanup_cfg (CLEANUP_PRE_SIBCALL | CLEANUP_PRE_LOOP);\n+\t  optimize = saved_optimize;\n+\n+\t  /* CFG is no longer maintained up-to-date.  */\n+\t  free_bb_for_insn ();\n+\t}\n+\n+      set_nothrow_function_flags ();\n+      if (current_function_nothrow)\n+\t/* Now we know that this can't throw; set the flag for the benefit\n+\t   of other functions later in this translation unit.  */\n+\tTREE_NOTHROW (current_function_decl) = 1;\n+\n+      timevar_push (TV_INTEGRATION);\n+      save_for_inline (decl);\n+      timevar_pop (TV_INTEGRATION);\n+      DECL_STRUCT_FUNCTION (decl)->inlinable = inlinable;\n+      return true;\n+    }\n+\n+  /* If specified extern inline but we aren't inlining it, we are\n+     done.  This goes for anything that gets here with DECL_EXTERNAL\n+     set, not just things with DECL_INLINE.  */\n+  return (bool) DECL_EXTERNAL (decl);\n+}\n+\n+/* Try to identify useless null pointer tests and delete them.  */\n+static void\n+rest_of_handle_null_pointer (tree decl, rtx insns)\n+{\n+  open_dump_file (DFI_null, decl);\n+  if (dump_file)\n+    dump_flow_info (dump_file);\n+\n+  if (delete_null_pointer_checks (insns))\n+    cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n+\n+  close_dump_file (DFI_null, print_rtl_with_bb, insns);\n+}\n+\n+/* Try combining insns through substitution.  */\n+static void\n+rest_of_handle_combine (tree decl, rtx insns)\n+{\n+  int rebuild_jump_labels_after_combine = 0;\n+\n+  timevar_push (TV_COMBINE);\n+  open_dump_file (DFI_combine, decl);\n+\n+  rebuild_jump_labels_after_combine\n+    = combine_instructions (insns, max_reg_num ());\n+\n+  /* Combining insns may have turned an indirect jump into a\n+     direct jump.  Rebuild the JUMP_LABEL fields of jumping\n+     instructions.  */\n+  if (rebuild_jump_labels_after_combine)\n+    {\n+      timevar_push (TV_JUMP);\n+      rebuild_jump_labels (insns);\n+      timevar_pop (TV_JUMP);\n+\n+      cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE);\n+    }\n+\n+  close_dump_file (DFI_combine, print_rtl_with_bb, insns);\n+  timevar_pop (TV_COMBINE);\n+\n+  ggc_collect ();\n+}\n+\n+/* Perform life analysis.  */\n+static void\n+rest_of_handle_life (tree decl, rtx insns)\n+{\n+  open_dump_file (DFI_life, decl);\n+  regclass_init ();\n+\n+#ifdef ENABLE_CHECKING\n+  verify_flow_info ();\n+#endif\n+  life_analysis (insns, dump_file, PROP_FINAL);\n+  if (optimize)\n+    cleanup_cfg ((optimize ? CLEANUP_EXPENSIVE : 0) | CLEANUP_UPDATE_LIFE\n+\t\t | CLEANUP_LOG_LINKS\n+\t\t | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n+  timevar_pop (TV_FLOW);\n+\n+  if (warn_uninitialized)\n+    {\n+      uninitialized_vars_warning (DECL_INITIAL (decl));\n+      if (extra_warnings)\n+\tsetjmp_args_warning ();\n+    }\n+\n+  if (optimize)\n+    {\n+      if (!flag_new_regalloc && initialize_uninitialized_subregs ())\n+\t{\n+\t  /* Insns were inserted, and possibly pseudos created, so\n+\t     things might look a bit different.  */\n+\t  insns = get_insns ();\n+\t  allocate_reg_life_data ();\n+\t  update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES,\n+\t\t\t    PROP_LOG_LINKS | PROP_REG_INFO | PROP_DEATH_NOTES);\n+\t}\n+    }\n+\n+  no_new_pseudos = 1;\n+\n+  close_dump_file (DFI_life, print_rtl_with_bb, insns);\n+\n+  ggc_collect ();\n+}\n+\n+/* Perform common subexpression elimination.  Nonzero value from\n+   `cse_main' means that jumps were simplified and some code may now\n+   be unreachable, so do jump optimization again.  */\n+static void\n+rest_of_handle_cse (tree decl, rtx insns)\n+{\n+  int tem;\n+\n+  open_dump_file (DFI_cse, decl);\n+  if (dump_file)\n+    dump_flow_info (dump_file);\n+  timevar_push (TV_CSE);\n+\n+  reg_scan (insns, max_reg_num (), 1);\n+\n+  tem = cse_main (insns, max_reg_num (), 0, dump_file);\n+  if (tem)\n+    rebuild_jump_labels (insns);\n+  if (purge_all_dead_edges (0))\n+    delete_unreachable_blocks ();\n+\n+  delete_trivially_dead_insns (insns, max_reg_num ());\n+\n+  /* If we are not running more CSE passes, then we are no longer\n+     expecting CSE to be run.  But always rerun it in a cheap mode.  */\n+  cse_not_expected = !flag_rerun_cse_after_loop && !flag_gcse;\n+\n+  if (tem || optimize > 1)\n+    cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n+  /* Try to identify useless null pointer tests and delete them.  */\n+  if (flag_delete_null_pointer_checks)\n+    {\n+      timevar_push (TV_JUMP);\n+\n+      if (delete_null_pointer_checks (insns))\n+\tcleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n+      timevar_pop (TV_JUMP);\n+    }\n+\n+  /* The second pass of jump optimization is likely to have\n+     removed a bunch more instructions.  */\n+  renumber_insns (dump_file);\n+\n+  timevar_pop (TV_CSE);\n+  close_dump_file (DFI_cse, print_rtl_with_bb, insns);\n+}\n+\n+/* Run second CSE pass after loop optimizations.  */\n+static void\n+rest_of_handle_cse2 (tree decl, rtx insns)\n+{\n+  int tem;\n+\n+  timevar_push (TV_CSE2);\n+  open_dump_file (DFI_cse2, decl);\n+  if (dump_file)\n+    dump_flow_info (dump_file);\n+  /* CFG is no longer maintained up-to-date.  */\n+  tem = cse_main (insns, max_reg_num (), 1, dump_file);\n+\n+  /* Run a pass to eliminate duplicated assignments to condition code\n+     registers.  We have to run this after bypass_jumps, because it\n+     makes it harder for that pass to determine whether a jump can be\n+     bypassed safely.  */\n+  cse_condition_code_reg ();\n+\n+  purge_all_dead_edges (0);\n+  delete_trivially_dead_insns (insns, max_reg_num ());\n+\n+  if (tem)\n+    {\n+      timevar_push (TV_JUMP);\n+      rebuild_jump_labels (insns);\n+      cleanup_cfg (CLEANUP_EXPENSIVE);\n+      timevar_pop (TV_JUMP);\n+    }\n+  reg_scan (insns, max_reg_num (), 0);\n+  close_dump_file (DFI_cse2, print_rtl_with_bb, insns);\n+  ggc_collect ();\n+  timevar_pop (TV_CSE2);\n+}\n+\n+/* Perform global cse.  */\n+static void\n+rest_of_handle_gcse (tree decl, rtx insns)\n+{\n+  int save_csb, save_cfj;\n+  int tem2 = 0, tem;\n+\n+  timevar_push (TV_GCSE);\n+  open_dump_file (DFI_gcse, decl);\n+\n+  tem = gcse_main (insns, dump_file);\n+  rebuild_jump_labels (insns);\n+  delete_trivially_dead_insns (insns, max_reg_num ());\n+\n+  save_csb = flag_cse_skip_blocks;\n+  save_cfj = flag_cse_follow_jumps;\n+  flag_cse_skip_blocks = flag_cse_follow_jumps = 0;\n+\n+  /* Instantiate any remaining CONSTANT_P_RTX nodes.  */\n+  if (current_function_calls_constant_p)\n+    purge_builtin_constant_p ();\n+\n+  /* If -fexpensive-optimizations, re-run CSE to clean up things done\n+     by gcse.  */\n+  if (flag_expensive_optimizations)\n+    {\n+      timevar_push (TV_CSE);\n+      reg_scan (insns, max_reg_num (), 1);\n+      tem2 = cse_main (insns, max_reg_num (), 0, dump_file);\n+      purge_all_dead_edges (0);\n+      delete_trivially_dead_insns (insns, max_reg_num ());\n+      timevar_pop (TV_CSE);\n+      cse_not_expected = !flag_rerun_cse_after_loop;\n+    }\n+\n+  /* If gcse or cse altered any jumps, rerun jump optimizations to clean\n+     things up.  Then possibly re-run CSE again.  */\n+  while (tem || tem2)\n+    {\n+      tem = tem2 = 0;\n+      timevar_push (TV_JUMP);\n+      rebuild_jump_labels (insns);\n+      cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n+      timevar_pop (TV_JUMP);\n+\n+      if (flag_expensive_optimizations)\n+\t{\n+\t  timevar_push (TV_CSE);\n+\t  reg_scan (insns, max_reg_num (), 1);\n+\t  tem2 = cse_main (insns, max_reg_num (), 0, dump_file);\n+\t  purge_all_dead_edges (0);\n+\t  delete_trivially_dead_insns (insns, max_reg_num ());\n+\t  timevar_pop (TV_CSE);\n+\t}\n+    }\n+\n+  close_dump_file (DFI_gcse, print_rtl_with_bb, insns);\n+  timevar_pop (TV_GCSE);\n+\n+  ggc_collect ();\n+  flag_cse_skip_blocks = save_csb;\n+  flag_cse_follow_jumps = save_cfj;\n+#ifdef ENABLE_CHECKING\n+  verify_flow_info ();\n+#endif\n+}\n+\n+/* Move constant computations out of loops.  */\n+static void\n+rest_of_handle_loop_optimize (tree decl, rtx insns)\n+{\n+  int do_unroll, do_prefetch;\n+\n+  timevar_push (TV_LOOP);\n+  delete_dead_jumptables ();\n+  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n+  open_dump_file (DFI_loop, decl);\n+\n+  /* CFG is no longer maintained up-to-date.  */\n+  free_bb_for_insn ();\n+\n+  if (flag_unroll_loops)\n+    do_unroll = LOOP_AUTO_UNROLL;\t/* Having two unrollers is useless.  */\n+  else\n+    do_unroll = flag_old_unroll_loops ? LOOP_UNROLL : LOOP_AUTO_UNROLL;\n+  do_prefetch = flag_prefetch_loop_arrays ? LOOP_PREFETCH : 0;\n+\n+  if (flag_rerun_loop_opt)\n+    {\n+      cleanup_barriers ();\n+\n+      /* We only want to perform unrolling once.  */\n+      loop_optimize (insns, dump_file, do_unroll);\n+      do_unroll = 0;\n+\n+      /* The first call to loop_optimize makes some instructions\n+\t trivially dead.  We delete those instructions now in the\n+\t hope that doing so will make the heuristics in loop work\n+\t better and possibly speed up compilation.  */\n+      delete_trivially_dead_insns (insns, max_reg_num ());\n+\n+      /* The regscan pass is currently necessary as the alias\n+\t analysis code depends on this information.  */\n+      reg_scan (insns, max_reg_num (), 1);\n+    }\n+  cleanup_barriers ();\n+  loop_optimize (insns, dump_file, do_unroll | LOOP_BCT | do_prefetch);\n+\n+  /* Loop can create trivially dead instructions.  */\n+  delete_trivially_dead_insns (insns, max_reg_num ());\n+  close_dump_file (DFI_loop, print_rtl, insns);\n+  timevar_pop (TV_LOOP);\n+  find_basic_blocks (insns, max_reg_num (), dump_file);\n+\n+  ggc_collect ();\n+}\n+\n+/* Perform loop optimizations.  It might be better to do them a bit\n+   sooner, but we want the profile feedback to work more\n+   efficiently.  */\n+static void\n+rest_of_handle_loop2 (tree decl, rtx insns)\n+{\n+  struct loops *loops;\n+  basic_block bb;\n+\n+  timevar_push (TV_LOOP);\n+  open_dump_file (DFI_loop2, decl);\n+  if (dump_file)\n+    dump_flow_info (dump_file);\n+\n+  /* Initialize structures for layout changes.  */\n+  cfg_layout_initialize ();\n+\n+  loops = loop_optimizer_init (dump_file);\n+\n+  if (loops)\n+    {\n+      /* The optimizations:  */\n+      if (flag_unswitch_loops)\n+\tunswitch_loops (loops);\n+\n+      if (flag_peel_loops || flag_unroll_loops)\n+\tunroll_and_peel_loops (loops,\n+\t\t\t       (flag_peel_loops ? UAP_PEEL : 0) |\n+\t\t\t       (flag_unroll_loops ? UAP_UNROLL : 0) |\n+\t\t\t       (flag_unroll_all_loops ? UAP_UNROLL_ALL : 0));\n+\n+      loop_optimizer_finalize (loops, dump_file);\n+    }\n+\n+  /* Finalize layout changes.  */\n+  FOR_EACH_BB (bb)\n+    if (bb->next_bb != EXIT_BLOCK_PTR)\n+      bb->rbi->next = bb->next_bb;\n+  cfg_layout_finalize ();\n+\n+  cleanup_cfg (CLEANUP_EXPENSIVE);\n+  delete_trivially_dead_insns (insns, max_reg_num ());\n+  reg_scan (insns, max_reg_num (), 0);\n+  if (dump_file)\n+    dump_flow_info (dump_file);\n+  close_dump_file (DFI_loop2, print_rtl_with_bb, get_insns ());\n+  timevar_pop (TV_LOOP);\n+  ggc_collect ();\n+}\n+\n+/* This is called from finish_function (within langhooks.parse_file)\n+   after each top-level definition is parsed.\n+   It is supposed to compile that function or variable\n+   and output the assembler code for it.\n+   After we return, the tree storage is freed.  */\n+\n+void\n+rest_of_compilation (tree decl)\n+{\n+  rtx insns;\n+\n+  timevar_push (TV_REST_OF_COMPILATION);\n+\n+  /* Register rtl specific functions for cfg.  */\n+  rtl_register_cfg_hooks ();\n+\n+  /* Now that we're out of the frontend, we shouldn't have any more\n+     CONCATs anywhere.  */\n+  generating_concat_p = 0;\n+\n+  /* When processing delayed functions, prepare_function_start() won't\n+     have been run to re-initialize it.  */\n+  cse_not_expected = ! optimize;\n+\n+  /* First, make sure that NOTE_BLOCK is set correctly for each\n+     NOTE_INSN_BLOCK_BEG/NOTE_INSN_BLOCK_END note.  */\n+  if (!cfun->x_whole_function_mode_p)\n+    identify_blocks ();\n+\n+  /* In function-at-a-time mode, we do not attempt to keep the BLOCK\n+     tree in sensible shape.  So, we just recalculate it here.  */\n+  if (cfun->x_whole_function_mode_p)\n+    reorder_blocks ();\n+\n+  init_flow ();\n+\n+  if (rest_of_handle_inlining (decl))\n+    goto exit_rest_of_compilation;\n+\n+  /* If we're emitting a nested function, make sure its parent gets\n+     emitted as well.  Doing otherwise confuses debug info.  */\n+  {\n+    tree parent;\n+    for (parent = DECL_CONTEXT (current_function_decl);\n+\t parent != NULL_TREE;\n+\t parent = get_containing_scope (parent))\n+      if (TREE_CODE (parent) == FUNCTION_DECL)\n+\tTREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (parent)) = 1;\n+  }\n+\n+  /* We are now committed to emitting code for this function.  Do any\n+     preparation, such as emitting abstract debug info for the inline\n+     before it gets mangled by optimization.  */\n+  if (cgraph_function_possibly_inlined_p (decl))\n+    (*debug_hooks->outlining_inline_function) (decl);\n+\n+  /* Remove any notes we don't need.  That will make iterating\n+     over the instruction sequence faster, and allow the garbage\n+     collector to reclaim the memory used by the notes.  */\n+  remove_unnecessary_notes ();\n+  reorder_blocks ();\n+\n+  ggc_collect ();\n+\n+  /* Initialize some variables used by the optimizers.  */\n+  init_function_for_compilation ();\n+\n+  if (! DECL_DEFER_OUTPUT (decl))\n+    TREE_ASM_WRITTEN (decl) = 1;\n+\n+  /* Now that integrate will no longer see our rtl, we need not\n+     distinguish between the return value of this function and the\n+     return value of called functions.  Also, we can remove all SETs\n+     of subregs of hard registers; they are only here because of\n+     integrate.  Also, we can now initialize pseudos intended to\n+     carry magic hard reg data throughout the function.  */\n+  rtx_equal_function_value_matters = 0;\n+  purge_hard_subreg_sets (get_insns ());\n+\n+  /* Early return if there were errors.  We can run afoul of our\n+     consistency checks, and there's not really much point in fixing them.\n+     Don't return yet if -Wreturn-type; we need to do cleanup_cfg.  */\n+  if (((rtl_dump_and_exit || flag_syntax_only) && !warn_return_type)\n+      || errorcount || sorrycount)\n+    goto exit_rest_of_compilation;\n+\n+  timevar_push (TV_JUMP);\n+  open_dump_file (DFI_sibling, decl);\n+  insns = get_insns ();\n+  rebuild_jump_labels (insns);\n+  find_exception_handler_labels ();\n+  find_basic_blocks (insns, max_reg_num (), dump_file);\n+\n+  delete_unreachable_blocks ();\n+\n+  /* Turn NOTE_INSN_PREDICTIONs into branch predictions.  */\n+  if (flag_guess_branch_prob)\n+    {\n+      timevar_push (TV_BRANCH_PROB);\n+      note_prediction_to_br_prob ();\n+      timevar_pop (TV_BRANCH_PROB);\n+    }\n+\n+  if (flag_optimize_sibling_calls)\n+    rest_of_handle_sibling_calls (insns);\n+\n+  /* We have to issue these warnings now already, because CFG cleanups\n+     further down may destroy the required information.  However, this\n+     must be done after the sibcall optimization pass because the barrier\n+     emitted for noreturn calls that are candidate for the optimization\n+     is folded into the CALL_PLACEHOLDER until after this pass, so the\n+     CFG is inaccurate.  */\n+  check_function_return_warnings ();\n+\n+  timevar_pop (TV_JUMP);\n+\n+  insn_locators_initialize ();\n+  /* Complete generation of exception handling code.  */\n+  if (doing_eh (0))\n+    {\n+      timevar_push (TV_JUMP);\n+      open_dump_file (DFI_eh, decl);\n+\n+      finish_eh_generation ();\n+\n+      close_dump_file (DFI_eh, print_rtl, get_insns ());\n+      timevar_pop (TV_JUMP);\n+    }\n+\n+  /* Delay emitting hard_reg_initial_value sets until after EH landing pad\n+     generation, which might create new sets.  */\n+  emit_initial_value_sets ();\n+\n+#ifdef FINALIZE_PIC\n+  /* If we are doing position-independent code generation, now\n+     is the time to output special prologues and epilogues.\n+     We do not want to do this earlier, because it just clutters\n+     up inline functions with meaningless insns.  */\n+  if (flag_pic)\n+    FINALIZE_PIC;\n+#endif\n+\n+  insns = get_insns ();\n+\n+  /* Copy any shared structure that should not be shared.  */\n+  unshare_all_rtl (current_function_decl, insns);\n+\n+#ifdef SETJMP_VIA_SAVE_AREA\n+  /* This must be performed before virtual register instantiation.\n+     Please be aware the everything in the compiler that can look\n+     at the RTL up to this point must understand that REG_SAVE_AREA\n+     is just like a use of the REG contained inside.  */\n+  if (current_function_calls_alloca)\n+    optimize_save_area_alloca (insns);\n+#endif\n+\n+  /* Instantiate all virtual registers.  */\n+  instantiate_virtual_regs (current_function_decl, insns);\n+\n+  open_dump_file (DFI_jump, decl);\n+\n+  /* Always do one jump optimization pass to ensure that JUMP_LABEL fields\n+     are initialized and to compute whether control can drop off the end\n+     of the function.  */\n+\n+  timevar_push (TV_JUMP);\n+  /* Turn NOTE_INSN_EXPECTED_VALUE into REG_BR_PROB.  Do this\n+     before jump optimization switches branch directions.  */\n+  if (flag_guess_branch_prob)\n+    expected_value_to_br_prob ();\n+\n+  reg_scan (insns, max_reg_num (), 0);\n+  rebuild_jump_labels (insns);\n+  find_basic_blocks (insns, max_reg_num (), dump_file);\n+  delete_trivially_dead_insns (insns, max_reg_num ());\n+  if (dump_file)\n+    dump_flow_info (dump_file);\n+  cleanup_cfg ((optimize ? CLEANUP_EXPENSIVE : 0) | CLEANUP_PRE_LOOP\n+\t       | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n+\n+  if (optimize)\n+    {\n+      free_bb_for_insn ();\n+      copy_loop_headers (insns);\n+      find_basic_blocks (insns, max_reg_num (), dump_file);\n+    }\n+  purge_line_number_notes (insns);\n+\n+  timevar_pop (TV_JUMP);\n+  close_dump_file (DFI_jump, print_rtl, insns);\n+\n+  /* Now is when we stop if -fsyntax-only and -Wreturn-type.  */\n+  if (rtl_dump_and_exit || flag_syntax_only || DECL_DEFER_OUTPUT (decl))\n+    goto exit_rest_of_compilation;\n+\n+  timevar_push (TV_JUMP);\n+\n+  if (optimize)\n+    cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n+\n+  if (flag_delete_null_pointer_checks)\n+    rest_of_handle_null_pointer (decl, insns);\n+\n+  /* Jump optimization, and the removal of NULL pointer checks, may\n+     have reduced the number of instructions substantially.  CSE, and\n+     future passes, allocate arrays whose dimensions involve the\n+     maximum instruction UID, so if we can reduce the maximum UID\n+     we'll save big on memory.  */\n+  renumber_insns (dump_file);\n+  timevar_pop (TV_JUMP);\n+\n+  close_dump_file (DFI_jump, print_rtl_with_bb, insns);\n+\n+  ggc_collect ();\n+\n+  if (optimize > 0)\n+    rest_of_handle_cse (decl, insns);\n+\n+  rest_of_handle_addressof (decl, insns);\n+\n+  ggc_collect ();\n+\n+  if (optimize > 0)\n+    {\n+      if (flag_gcse)\n+\trest_of_handle_gcse (decl, insns);\n+\n+      if (flag_loop_optimize)\n+\trest_of_handle_loop_optimize (decl, insns);\n+\n+      if (flag_gcse)\n+\trest_of_handle_jump_bypass (decl, insns);\n+    }\n+\n+  timevar_push (TV_FLOW);\n+\n+  rest_of_handle_cfg (decl, insns);\n+\n+  if (optimize > 0\n+      || profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n+    {\n+      rest_of_handle_branch_prob (decl, insns);\n+\n+      if (flag_branch_probabilities\n+\t  && flag_profile_values\n+\t  && flag_value_profile_transformations)\n+\trest_of_handle_value_profile_transformations (decl, insns);\n+\n+      /* Remove the death notes created for vpt.  */\n+      if (flag_profile_values)\n+\tcount_or_remove_death_notes (NULL, 1);\n+    }\n+\n+  if (optimize > 0)\n+    rest_of_handle_if_conversion (decl, insns);\n+\n+  if (flag_tracer)\n+    rest_of_handle_tracer (decl, insns);\n+\n+  if (optimize > 0\n+      && (flag_unswitch_loops\n+\t  || flag_peel_loops\n+\t  || flag_unroll_loops))\n+    rest_of_handle_loop2 (decl, insns);\n+\n+  if (flag_web)\n+    rest_of_handle_web (decl, insns);\n+\n+  if (flag_rerun_cse_after_loop)\n+    rest_of_handle_cse2 (decl, insns);\n+\n+  cse_not_expected = 1;\n+\n+  rest_of_handle_life (decl, insns);\n+\n+  if (optimize > 0)\n+    rest_of_handle_combine (decl, insns);\n+\n+  if (flag_if_conversion)\n+    rest_of_handle_if_after_combine (decl, insns);\n+\n+  if (optimize > 0 && (flag_regmove || flag_expensive_optimizations))\n+    rest_of_handle_regmove (decl, insns);\n+\n+  /* Do unconditional splitting before register allocation to allow machine\n+     description to add extra information not needed previously.  */\n+  split_all_insns (1);\n+\n+#ifdef OPTIMIZE_MODE_SWITCHING\n+  timevar_push (TV_MODE_SWITCH);\n+\n+  no_new_pseudos = 0;\n+  optimize_mode_switching (NULL);\n+  no_new_pseudos = 1;\n+\n+  timevar_pop (TV_MODE_SWITCH);\n+#endif\n+\n+  /* Any of the several passes since flow1 will have munged register\n+     lifetime data a bit.  We need it to be up to date for scheduling\n+     (see handling of reg_known_equiv in init_alias_analysis).  */\n+  recompute_reg_usage (insns, !optimize_size);\n+\n+#ifdef INSN_SCHEDULING\n+  rest_of_handle_sched (decl, insns);\n+#endif\n+\n+  /* Determine if the current function is a leaf before running reload\n+     since this can impact optimizations done by the prologue and\n+     epilogue thus changing register elimination offsets.  */\n+  current_function_is_leaf = leaf_function_p ();\n+\n+  timevar_push (TV_LOCAL_ALLOC);\n+  open_dump_file (DFI_lreg, decl);\n+\n+  if (flag_new_regalloc)\n+    {\n+      if (rest_of_handle_new_regalloc (decl, insns))\n+\tgoto exit_rest_of_compilation;\n+    }\n+  else\n+    {\n+      if (rest_of_handle_old_regalloc (decl, insns))\n+\tgoto exit_rest_of_compilation;\n+    }\n+\n+  ggc_collect ();\n+\n+  open_dump_file (DFI_postreload, decl);\n+\n+  /* Do a very simple CSE pass over just the hard registers.  */\n+  if (optimize > 0)\n+    {\n+      timevar_push (TV_RELOAD_CSE_REGS);\n+      reload_cse_regs (insns);\n+      /* reload_cse_regs can eliminate potentially-trapping MEMs.\n+\t Remove any EH edges associated with them.  */\n+      if (flag_non_call_exceptions)\n+\tpurge_all_dead_edges (0);\n+      timevar_pop (TV_RELOAD_CSE_REGS);\n+    }\n+\n+  close_dump_file (DFI_postreload, print_rtl_with_bb, insns);\n+\n+  /* Re-create the death notes which were deleted during reload.  */\n+  timevar_push (TV_FLOW2);\n+  open_dump_file (DFI_flow2, decl);\n+\n+#ifdef ENABLE_CHECKING\n+  verify_flow_info ();\n+#endif\n+\n+  /* If optimizing, then go ahead and split insns now.  */\n+#ifndef STACK_REGS\n+  if (optimize > 0)\n+#endif\n+    split_all_insns (0);\n+\n+    if (flag_branch_target_load_optimize)\n+      {\n+\topen_dump_file (DFI_branch_target_load, decl);\n+\n+\tbranch_target_load_optimize (insns, false);\n+\n+\tclose_dump_file (DFI_branch_target_load, print_rtl_with_bb, insns);\n+\n+\tggc_collect ();\n+      }\n+\n+  if (optimize)\n+    cleanup_cfg (CLEANUP_EXPENSIVE);\n+\n+  /* On some machines, the prologue and epilogue code, or parts thereof,\n+     can be represented as RTL.  Doing so lets us schedule insns between\n+     it and the rest of the code and also allows delayed branch\n+     scheduling to operate in the epilogue.  */\n+  thread_prologue_and_epilogue_insns (insns);\n+  epilogue_completed = 1;\n+\n+  if (optimize)\n+    {\n+      life_analysis (insns, dump_file, PROP_POSTRELOAD);\n+      cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE\n+\t\t   | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0));\n+\n+      /* This is kind of a heuristic.  We need to run combine_stack_adjustments\n+         even for machines with possibly nonzero RETURN_POPS_ARGS\n+         and ACCUMULATE_OUTGOING_ARGS.  We expect that only ports having\n+         push instructions will have popping returns.  */\n+#ifndef PUSH_ROUNDING\n+      if (!ACCUMULATE_OUTGOING_ARGS)\n+#endif\n+\tcombine_stack_adjustments ();\n+\n+      ggc_collect ();\n+    }\n+\n+  flow2_completed = 1;\n+\n+  close_dump_file (DFI_flow2, print_rtl_with_bb, insns);\n+  timevar_pop (TV_FLOW2);\n+\n+#ifdef HAVE_peephole2\n+  if (optimize > 0 && flag_peephole2)\n+    {\n+      timevar_push (TV_PEEPHOLE2);\n+      open_dump_file (DFI_peephole2, decl);\n+\n+      peephole2_optimize (dump_file);\n+\n+      close_dump_file (DFI_peephole2, print_rtl_with_bb, insns);\n+      timevar_pop (TV_PEEPHOLE2);\n+    }\n+#endif\n+\n+  open_dump_file (DFI_ce3, decl);\n+  if (optimize)\n+    /* Last attempt to optimize CFG, as scheduling, peepholing and insn\n+       splitting possibly introduced more crossjumping opportunities.  */\n+    cleanup_cfg (CLEANUP_EXPENSIVE\n+\t\t | CLEANUP_UPDATE_LIFE \n+\t\t | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0));\n+  if (flag_if_conversion2)\n+    {\n+      timevar_push (TV_IFCVT2);\n+\n+      if_convert (1);\n+\n+      timevar_pop (TV_IFCVT2);\n+    }\n+  close_dump_file (DFI_ce3, print_rtl_with_bb, insns);\n+\n+  if (optimize > 0)\n+    {\n+      if (flag_rename_registers || flag_cprop_registers)\n+\trest_of_handle_regrename (decl, insns);\n+\n+      rest_of_handle_reorder_blocks (decl, insns);\n+    }\n+\n+  if (flag_branch_target_load_optimize2)\n+    {\n+      /* Leave this a warning for now so that it is possible to experiment\n+\t with running this pass twice.  In 3.6, we should either make this\n+\t an error, or use separate dump files.  */\n+      if (flag_branch_target_load_optimize)\n+\twarning (\"branch target register load optimization is not intended \"\n+\t\t \"to be run twice\");\n+\n+      open_dump_file (DFI_branch_target_load, decl);\n+\n+      branch_target_load_optimize (insns, true);\n+\n+      close_dump_file (DFI_branch_target_load, print_rtl_with_bb, insns);\n+\n+      ggc_collect ();\n+    }\n+\n+#ifdef INSN_SCHEDULING\n+  if (optimize > 0 && flag_schedule_insns_after_reload)\n+    rest_of_handle_sched2 (decl, insns);\n+#endif\n+\n+#ifdef LEAF_REGISTERS\n+  current_function_uses_only_leaf_regs\n+    = optimize > 0 && only_leaf_regs_used () && leaf_function_p ();\n+#endif\n+\n+#ifdef STACK_REGS\n+  rest_of_handle_stack_regs (decl, insns);\n+#endif\n+\n+  compute_alignments ();\n+\n+  if (flag_var_tracking)\n+    rest_of_handle_variable_tracking (decl, insns);\n+\n+  /* CFG is no longer maintained up-to-date.  */\n+  free_bb_for_insn ();\n+\n+  if (targetm.machine_dependent_reorg != 0)\n+    rest_of_handle_machine_reorg (decl, insns);\n+\n+  purge_line_number_notes (insns);\n+  cleanup_barriers ();\n+\n+#ifdef DELAY_SLOTS\n+  if (optimize > 0 && flag_delayed_branch)\n+    rest_of_handle_delay_slots (decl, insns);\n+#endif\n+\n+#if defined (HAVE_ATTR_length) && !defined (STACK_REGS)\n+  timevar_push (TV_SHORTEN_BRANCH);\n+  split_all_insns_noflow ();\n+  timevar_pop (TV_SHORTEN_BRANCH);\n+#endif\n+\n+  convert_to_eh_region_ranges ();\n+\n+  /* Shorten branches.  */\n+  timevar_push (TV_SHORTEN_BRANCH);\n+  shorten_branches (get_insns ());\n+  timevar_pop (TV_SHORTEN_BRANCH);\n+\n+  set_nothrow_function_flags ();\n+  if (current_function_nothrow)\n+    /* Now we know that this can't throw; set the flag for the benefit\n+       of other functions later in this translation unit.  */\n+    TREE_NOTHROW (current_function_decl) = 1;\n+\n+  rest_of_handle_final (decl, insns);\n+\n+  /* Write DBX symbols if requested.  */\n+\n+  /* Note that for those inline functions where we don't initially\n+     know for certain that we will be generating an out-of-line copy,\n+     the first invocation of this routine (rest_of_compilation) will\n+     skip over this code by doing a `goto exit_rest_of_compilation;'.\n+     Later on, wrapup_global_declarations will (indirectly) call\n+     rest_of_compilation again for those inline functions that need\n+     to have out-of-line copies generated.  During that call, we\n+     *will* be routed past here.  */\n+\n+  timevar_push (TV_SYMOUT);\n+  (*debug_hooks->function_decl) (decl);\n+  timevar_pop (TV_SYMOUT);\n+\n+ exit_rest_of_compilation:\n+\n+  coverage_end_function ();\n+\n+  /* In case the function was not output,\n+     don't leave any temporary anonymous types\n+     queued up for sdb output.  */\n+#ifdef SDB_DEBUGGING_INFO\n+  if (write_symbols == SDB_DEBUG)\n+    sdbout_types (NULL_TREE);\n+#endif\n+\n+  reload_completed = 0;\n+  epilogue_completed = 0;\n+  flow2_completed = 0;\n+  no_new_pseudos = 0;\n+\n+  timevar_push (TV_FINAL);\n+\n+  /* Clear out the insn_length contents now that they are no\n+     longer valid.  */\n+  init_insn_lengths ();\n+\n+  /* Show no temporary slots allocated.  */\n+  init_temp_slots ();\n+\n+  free_basic_block_vars (0);\n+  free_bb_for_insn ();\n+\n+  timevar_pop (TV_FINAL);\n+\n+  if ((*targetm.binds_local_p) (current_function_decl))\n+    {\n+      int pref = cfun->preferred_stack_boundary;\n+      if (cfun->recursive_call_emit\n+          && cfun->stack_alignment_needed > cfun->preferred_stack_boundary)\n+\tpref = cfun->stack_alignment_needed;\n+      cgraph_rtl_info (current_function_decl)->preferred_incoming_stack_boundary\n+        = pref;\n+    }\n+\n+  /* Make sure volatile mem refs aren't considered valid operands for\n+     arithmetic insns.  We must call this here if this is a nested inline\n+     function, since the above code leaves us in the init_recog state\n+     (from final.c), and the function context push/pop code does not\n+     save/restore volatile_ok.\n+\n+     ??? Maybe it isn't necessary for expand_start_function to call this\n+     anymore if we do it here?  */\n+\n+  init_recog_no_volatile ();\n+\n+  /* We're done with this function.  Free up memory if we can.  */\n+  free_after_parsing (cfun);\n+  if (! DECL_DEFER_OUTPUT (decl))\n+    {\n+      free_after_compilation (cfun);\n+      DECL_STRUCT_FUNCTION (decl) = 0;\n+    }\n+  cfun = 0;\n+\n+  ggc_collect ();\n+\n+  timevar_pop (TV_REST_OF_COMPILATION);\n+}\n+\n+void\n+init_optimization_passes (void)\n+{\n+  if (flag_unit_at_a_time)\n+    {\n+      open_dump_file (DFI_cgraph, NULL);\n+      cgraph_dump_file = dump_file;\n+      dump_file = NULL;\n+    }\n+}\n+\n+void\n+finish_optimization_passes (void)\n+{\n+  if (profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n+    {\n+      timevar_push (TV_DUMP);\n+      open_dump_file (DFI_bp, NULL);\n+\n+      end_branch_prob ();\n+\n+      close_dump_file (DFI_bp, NULL, NULL_RTX);\n+      timevar_pop (TV_DUMP);\n+    }\n+\n+  if (optimize > 0 && open_dump_file (DFI_combine, NULL))\n+    {\n+      timevar_push (TV_DUMP);\n+      dump_combine_total_stats (dump_file);\n+      close_dump_file (DFI_combine, NULL, NULL_RTX);\n+      timevar_pop (TV_DUMP);\n+    }\n+\n+  if (flag_unit_at_a_time)\n+    {\n+      dump_file = cgraph_dump_file;\n+      cgraph_dump_file = NULL;\n+      close_dump_file (DFI_cgraph, NULL, NULL_RTX);\n+    }\n+\n+  /* Do whatever is necessary to finish printing the graphs.  */\n+  if (graph_dump_format != no_graph)\n+    {\n+      int i;\n+\n+      for (i = 0; i < (int) DFI_MAX; ++i)\n+\tif (dump_file_tbl[i].initialized && dump_file_tbl[i].graph_dump_p)\n+\t  {\n+\t    char seq[16];\n+\t    char *suffix;\n+\n+\t    sprintf (seq, DUMPFILE_FORMAT, i);\n+\t    suffix = concat (seq, dump_file_tbl[i].extension, NULL);\n+\t    finish_graph_dump_file (dump_base_name, suffix);\n+\t    free (suffix);\n+\t  }\n+    }\n+\n+}\n+\n+bool\n+enable_rtl_dump_file (int letter)\n+{\n+  bool matched = false;\n+  int i;\n+\n+  if (letter == 'a')\n+    {\n+      for (i = 0; i < (int) DFI_MAX; ++i)\n+\tdump_file_tbl[i].enabled = 1;\n+      matched = true;\n+    }\n+  else\n+    {\n+      for (i = 0; i < (int) DFI_MAX; ++i)\n+\tif (letter == dump_file_tbl[i].debug_switch)\n+\t  {\n+\t    dump_file_tbl[i].enabled = 1;\n+\t    matched = true;\n+\t  }\n+    }\n+\n+  return matched;\n+}"}, {"sha": "c2384fd93b2fc48a72702a5890c1da0533a05136", "filename": "gcc/rtl.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6db1481a7e4e5c6d97baecde520bcf60487deb5/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6db1481a7e4e5c6d97baecde520bcf60487deb5/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=f6db1481a7e4e5c6d97baecde520bcf60487deb5", "patch": "@@ -2369,4 +2369,7 @@ extern rtx compare_and_jump_seq (rtx, rtx, enum rtx_code, rtx, int, rtx);\n extern rtx canon_condition (rtx);\n extern void simplify_using_condition (rtx, rtx *, struct bitmap_head_def *);\n \n+/* In ra.c.  */\n+extern void reg_alloc (void);\n+\n #endif /* ! GCC_RTL_H */"}, {"sha": "dd57caefc8394c0ef621bd3ee5ae9584739a5a46", "filename": "gcc/toplev.c", "status": "modified", "additions": 150, "deletions": 2255, "changes": 2405, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6db1481a7e4e5c6d97baecde520bcf60487deb5/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6db1481a7e4e5c6d97baecde520bcf60487deb5/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=f6db1481a7e4e5c6d97baecde520bcf60487deb5", "patch": "@@ -98,18 +98,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \t\t\t\t   declarations for e.g. AIX 4.x.  */\n #endif\n \n-#ifndef HAVE_conditional_execution\n-#define HAVE_conditional_execution 0\n-#endif\n-\n-/* Carry information from ASM_DECLARE_OBJECT_NAME\n-   to ASM_FINISH_DECLARE_OBJECT.  */\n-\n-extern int size_directive_output;\n-extern tree last_assemble_variable_decl;\n-\n-extern void reg_alloc (void);\n-\n static void general_init (const char *);\n static void do_compile (void);\n static void process_options (void);\n@@ -128,44 +116,6 @@ static int print_single_switch (FILE *, int, int, const char *,\n static void print_switch_values (FILE *, int, int, const char *,\n \t\t\t\t const char *, const char *);\n \n-/* Rest of compilation helper functions.  */\n-static bool rest_of_handle_inlining (tree);\n-static void rest_of_handle_cse (tree, rtx);\n-static void rest_of_handle_cse2 (tree, rtx);\n-static void rest_of_handle_gcse (tree, rtx);\n-static void rest_of_handle_life (tree, rtx);\n-static void rest_of_handle_loop_optimize (tree, rtx);\n-static void rest_of_handle_loop2 (tree, rtx);\n-static void rest_of_handle_jump_bypass (tree, rtx);\n-static void rest_of_handle_sibling_calls (rtx);\n-static void rest_of_handle_null_pointer (tree, rtx);\n-static void rest_of_handle_addressof (tree, rtx);\n-static void rest_of_handle_cfg (tree, rtx);\n-static void rest_of_handle_branch_prob (tree, rtx);\n-static void rest_of_handle_value_profile_transformations (tree, rtx);\n-static void rest_of_handle_if_conversion (tree, rtx);\n-static void rest_of_handle_if_after_combine (tree, rtx);\n-static void rest_of_handle_tracer (tree, rtx);\n-static void rest_of_handle_combine (tree, rtx);\n-static void rest_of_handle_regmove (tree, rtx);\n-#ifdef INSN_SCHEDULING\n-static void rest_of_handle_sched (tree, rtx);\n-static void rest_of_handle_sched2 (tree, rtx);\n-#endif\n-static bool rest_of_handle_new_regalloc (tree, rtx);\n-static bool rest_of_handle_old_regalloc (tree, rtx);\n-static void rest_of_handle_regrename (tree, rtx);\n-static void rest_of_handle_reorder_blocks (tree, rtx);\n-#ifdef STACK_REGS\n-static void rest_of_handle_stack_regs (tree, rtx);\n-#endif\n-static void rest_of_handle_variable_tracking (tree, rtx);\n-static void rest_of_handle_machine_reorg (tree, rtx);\n-#ifdef DELAY_SLOTS\n-static void rest_of_handle_delay_slots (tree, rtx);\n-#endif\n-static void rest_of_handle_final (tree, rtx);\n-\n /* Nonzero to dump debug info whilst parsing (-dy option).  */\n static int set_yydebug;\n \n@@ -212,11 +162,6 @@ const char *dump_base_name;\n \n const char *aux_base_name;\n \n-/* Format to use to print dumpfile index value */\n-#ifndef DUMPFILE_FORMAT\n-#define DUMPFILE_FORMAT \".%02d.\"\n-#endif\n-\n /* Bit flags that specify the machine subtype we are compiling for.\n    Bits are tested using macros TARGET_... defined in the tm.h file\n    and set by `-m...' switches.  Must be defined in rtlanal.c.  */\n@@ -232,126 +177,6 @@ int target_flags_explicit;\n \n const struct gcc_debug_hooks *debug_hooks;\n \n-/* Describes a dump file.  */\n-\n-struct dump_file_info\n-{\n-  /* The unique extension to apply, e.g. \".jump\".  */\n-  const char *const extension;\n-\n-  /* The -d<c> character that enables this dump file.  */\n-  char const debug_switch;\n-\n-  /* True if there is a corresponding graph dump file.  */\n-  char const graph_dump_p;\n-\n-  /* True if the user selected this dump.  */\n-  char enabled;\n-\n-  /* True if the files have been initialized (ie truncated).  */\n-  char initialized;\n-};\n-\n-/* Enumerate the extant dump files.  */\n-\n-enum dump_file_index\n-{\n-  DFI_cgraph,\n-  DFI_rtl,\n-  DFI_sibling,\n-  DFI_eh,\n-  DFI_jump,\n-  DFI_null,\n-  DFI_cse,\n-  DFI_addressof,\n-  DFI_gcse,\n-  DFI_loop,\n-  DFI_bypass,\n-  DFI_cfg,\n-  DFI_bp,\n-  DFI_vpt,\n-  DFI_ce1,\n-  DFI_tracer,\n-  DFI_loop2,\n-  DFI_web,\n-  DFI_cse2,\n-  DFI_life,\n-  DFI_combine,\n-  DFI_ce2,\n-  DFI_regmove,\n-  DFI_sched,\n-  DFI_lreg,\n-  DFI_greg,\n-  DFI_postreload,\n-  DFI_flow2,\n-  DFI_peephole2,\n-  DFI_ce3,\n-  DFI_rnreg,\n-  DFI_bbro,\n-  DFI_branch_target_load,\n-  DFI_sched2,\n-  DFI_stack,\n-  DFI_vartrack,\n-  DFI_mach,\n-  DFI_dbr,\n-  DFI_MAX\n-};\n-\n-/* Describes all the dump files.  Should be kept in order of the\n-   pass and in sync with dump_file_index above.\n-\n-   Remaining -d letters:\n-\n-\t\"   e        m   q         \"\n-\t\"         JK   O Q     WXY \"\n-*/\n-\n-static struct dump_file_info dump_file_tbl[DFI_MAX] =\n-{\n-  { \"cgraph\",\t'U', 0, 0, 0 },\n-  { \"rtl\",\t'r', 0, 0, 0 },\n-  { \"sibling\",  'i', 0, 0, 0 },\n-  { \"eh\",\t'h', 0, 0, 0 },\n-  { \"jump\",\t'j', 0, 0, 0 },\n-  { \"null\",\t'u', 0, 0, 0 },\n-  { \"cse\",\t's', 0, 0, 0 },\n-  { \"addressof\", 'F', 0, 0, 0 },\n-  { \"gcse\",\t'G', 1, 0, 0 },\n-  { \"loop\",\t'L', 1, 0, 0 },\n-  { \"bypass\",   'G', 1, 0, 0 }, /* Yes, duplicate enable switch.  */\n-  { \"cfg\",\t'f', 1, 0, 0 },\n-  { \"bp\",\t'b', 1, 0, 0 },\n-  { \"vpt\",\t'V', 1, 0, 0 },\n-  { \"ce1\",\t'C', 1, 0, 0 },\n-  { \"tracer\",\t'T', 1, 0, 0 },\n-  { \"loop2\",\t'L', 1, 0, 0 },\n-  { \"web\",      'Z', 0, 0, 0 },\n-  { \"cse2\",\t't', 1, 0, 0 },\n-  { \"life\",\t'f', 1, 0, 0 },\t/* Yes, duplicate enable switch.  */\n-  { \"combine\",\t'c', 1, 0, 0 },\n-  { \"ce2\",\t'C', 1, 0, 0 },\n-  { \"regmove\",\t'N', 1, 0, 0 },\n-  { \"sched\",\t'S', 1, 0, 0 },\n-  { \"lreg\",\t'l', 1, 0, 0 },\n-  { \"greg\",\t'g', 1, 0, 0 },\n-  { \"postreload\", 'o', 1, 0, 0 },\n-  { \"flow2\",\t'w', 1, 0, 0 },\n-  { \"peephole2\", 'z', 1, 0, 0 },\n-  { \"ce3\",\t'E', 1, 0, 0 },\n-  { \"rnreg\",\t'n', 1, 0, 0 },\n-  { \"bbro\",\t'B', 1, 0, 0 },\n-  { \"btl\",\t'd', 1, 0, 0 }, /* Yes, duplicate enable switch.  */\n-  { \"sched2\",\t'R', 1, 0, 0 },\n-  { \"stack\",\t'k', 1, 0, 0 },\n-  { \"vartrack\",\t'V', 1, 0, 0 }, /* Yes, duplicate enable switch.  */\n-  { \"mach\",\t'M', 1, 0, 0 },\n-  { \"dbr\",\t'd', 0, 0, 0 },\n-};\n-\n-static int open_dump_file (enum dump_file_index, tree);\n-static void close_dump_file (enum dump_file_index,\n-\t\t\t     void (*) (FILE *, rtx), rtx);\n-\n /* Other flags saying which kinds of debugging dump have been requested.  */\n \n int rtl_dump_and_exit;\n@@ -1470,96 +1295,6 @@ output_file_directive (FILE *asm_file, const char *input_name)\n #endif\n }\n \n-/* Routine to open a dump file.  Return true if the dump file is enabled.  */\n-\n-static int\n-open_dump_file (enum dump_file_index index, tree decl)\n-{\n-  char *dump_name;\n-  const char *open_arg;\n-  char seq[16];\n-\n-  if (! dump_file_tbl[index].enabled)\n-    return 0;\n-\n-  timevar_push (TV_DUMP);\n-  if (dump_file != NULL)\n-    fclose (dump_file);\n-\n-  sprintf (seq, DUMPFILE_FORMAT, index);\n-\n-  if (! dump_file_tbl[index].initialized)\n-    {\n-      /* If we've not initialized the files, do so now.  */\n-      if (graph_dump_format != no_graph\n-\t  && dump_file_tbl[index].graph_dump_p)\n-\t{\n-\t  dump_name = concat (seq, dump_file_tbl[index].extension, NULL);\n-\t  clean_graph_dump_file (dump_base_name, dump_name);\n-\t  free (dump_name);\n-\t}\n-      dump_file_tbl[index].initialized = 1;\n-      open_arg = \"w\";\n-    }\n-  else\n-    open_arg = \"a\";\n-\n-  dump_name = concat (dump_base_name, seq,\n-\t\t      dump_file_tbl[index].extension, NULL);\n-\n-  dump_file = fopen (dump_name, open_arg);\n-  if (dump_file == NULL)\n-    fatal_error (\"can't open %s: %m\", dump_name);\n-\n-  free (dump_name);\n-\n-  if (decl)\n-    fprintf (dump_file, \"\\n;; Function %s%s\\n\\n\",\n-\t     (*lang_hooks.decl_printable_name) (decl, 2),\n-\t     cfun->function_frequency == FUNCTION_FREQUENCY_HOT\n-\t     ? \" (hot)\"\n-\t     : cfun->function_frequency == FUNCTION_FREQUENCY_UNLIKELY_EXECUTED\n-\t     ? \" (unlikely executed)\"\n-\t     : \"\");\n-\n-  timevar_pop (TV_DUMP);\n-  return 1;\n-}\n-\n-/* Routine to close a dump file.  */\n-\n-static void\n-close_dump_file (enum dump_file_index index,\n-\t\t void (*func) (FILE *, rtx),\n-\t\t rtx insns)\n-{\n-  if (! dump_file)\n-    return;\n-\n-  timevar_push (TV_DUMP);\n-  if (insns\n-      && graph_dump_format != no_graph\n-      && dump_file_tbl[index].graph_dump_p)\n-    {\n-      char seq[16];\n-      char *suffix;\n-\n-      sprintf (seq, DUMPFILE_FORMAT, index);\n-      suffix = concat (seq, dump_file_tbl[index].extension, NULL);\n-      print_rtl_graph_with_bb (dump_base_name, suffix, insns);\n-      free (suffix);\n-    }\n-\n-  if (func && insns)\n-    func (dump_file, insns);\n-\n-  fflush (dump_file);\n-  fclose (dump_file);\n-\n-  dump_file = NULL;\n-  timevar_pop (TV_DUMP);\n-}\n-\n /* Do any final processing required for the declarations in VEC, of\n    which there are LEN.  We write out inline functions and variables\n    that have been deferred until this point, but which are required.\n@@ -1874,17 +1609,6 @@ compile_file (void)\n \n   dw2_output_indirect_constants ();\n \n-  if (profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n-    {\n-      timevar_push (TV_DUMP);\n-      open_dump_file (DFI_bp, NULL);\n-\n-      end_branch_prob ();\n-\n-      close_dump_file (DFI_bp, NULL, NULL_RTX);\n-      timevar_pop (TV_DUMP);\n-    }\n-\n   targetm.asm_out.file_end ();\n \n   /* Attach a special .ident directive to the end of the file to identify\n@@ -1895,1987 +1619,190 @@ compile_file (void)\n     fprintf (asm_out_file, \"%s\\\"GCC: (GNU) %s\\\"\\n\",\n \t     IDENT_ASM_OP, version_string);\n #endif\n-\n-  if (optimize > 0 && open_dump_file (DFI_combine, NULL))\n-    {\n-      timevar_push (TV_DUMP);\n-      dump_combine_total_stats (dump_file);\n-      close_dump_file (DFI_combine, NULL, NULL_RTX);\n-      timevar_pop (TV_DUMP);\n-    }\n }\n \n-/* This is called from various places for FUNCTION_DECL, VAR_DECL,\n-   and TYPE_DECL nodes.\n-\n-   This does nothing for local (non-static) variables, unless the\n-   variable is a register variable with an ASMSPEC.  In that case, or\n-   if the variable is not an automatic, it sets up the RTL and\n-   outputs any assembler code (label definition, storage allocation\n-   and initialization).\n-\n-   DECL is the declaration.  If ASMSPEC is nonzero, it specifies\n-   the assembler symbol name to be used.  TOP_LEVEL is nonzero\n-   if this declaration is not within a function.  */\n-\n+/* Display help for target options.  */\n void\n-rest_of_decl_compilation (tree decl,\n-\t\t\t  const char *asmspec,\n-\t\t\t  int top_level,\n-\t\t\t  int at_end)\n+display_target_options (void)\n {\n-  /* We deferred calling assemble_alias so that we could collect\n-     other attributes such as visibility.  Emit the alias now.  */\n-  {\n-    tree alias;\n-    alias = lookup_attribute (\"alias\", DECL_ATTRIBUTES (decl));\n-    if (alias)\n-      {\n-\talias = TREE_VALUE (TREE_VALUE (alias));\n-\talias = get_identifier (TREE_STRING_POINTER (alias));\n-\tassemble_alias (decl, alias);\n-      }\n-  }\n+  int undoc, i;\n+  static bool displayed = false;\n+\n+  /* Avoid double printing for --help --target-help.  */\n+  if (displayed)\n+    return;\n+\n+  displayed = true;\n \n-  /* Forward declarations for nested functions are not \"external\",\n-     but we need to treat them as if they were.  */\n-  if (TREE_STATIC (decl) || DECL_EXTERNAL (decl)\n-      || TREE_CODE (decl) == FUNCTION_DECL)\n+  if (ARRAY_SIZE (target_switches) > 1\n+#ifdef TARGET_OPTIONS\n+      || ARRAY_SIZE (target_options) > 1\n+#endif\n+      )\n     {\n-      timevar_push (TV_VARCONST);\n+      int doc = 0;\n \n-      if (asmspec)\n-\tmake_decl_rtl (decl, asmspec);\n+      undoc = 0;\n \n-      /* Don't output anything when a tentative file-scope definition\n-\t is seen.  But at end of compilation, do output code for them.\n+      printf (_(\"\\nTarget specific options:\\n\"));\n \n-\t We do output all variables when unit-at-a-time is active and rely on\n-\t callgraph code to defer them except for forward declarations\n-\t (see gcc.c-torture/compile/920624-1.c) */\n-      if ((at_end\n-\t   || !DECL_DEFER_OUTPUT (decl)\n-\t   || (flag_unit_at_a_time && DECL_INITIAL (decl)))\n-\t  && !DECL_EXTERNAL (decl))\n+      for (i = ARRAY_SIZE (target_switches); i--;)\n \t{\n-\t  if (flag_unit_at_a_time && !cgraph_global_info_ready\n-\t      && TREE_CODE (decl) != FUNCTION_DECL && top_level)\n-\t    cgraph_varpool_finalize_decl (decl);\n-\t  else\n-\t    assemble_variable (decl, top_level, at_end, 0);\n-\t}\n+\t  const char *option      = target_switches[i].name;\n+\t  const char *description = target_switches[i].description;\n \n-#ifdef ASM_FINISH_DECLARE_OBJECT\n-      if (decl == last_assemble_variable_decl)\n-\t{\n-\t  ASM_FINISH_DECLARE_OBJECT (asm_out_file, decl,\n-\t\t\t\t     top_level, at_end);\n+\t  if (option == NULL || *option == 0)\n+\t    continue;\n+\t  else if (description == NULL)\n+\t    {\n+\t      undoc = 1;\n+\n+\t      if (extra_warnings)\n+\t\tprintf (_(\"  -m%-23s [undocumented]\\n\"), option);\n+\t    }\n+\t  else if (*description != 0)\n+\t    doc += printf (\"  -m%-23s %s\\n\", option, _(description));\n \t}\n-#endif\n \n-      timevar_pop (TV_VARCONST);\n-    }\n-  else if (DECL_REGISTER (decl) && asmspec != 0)\n-    {\n-      if (decode_reg_name (asmspec) >= 0)\n+#ifdef TARGET_OPTIONS\n+      for (i = ARRAY_SIZE (target_options); i--;)\n \t{\n-\t  SET_DECL_RTL (decl, NULL_RTX);\n-\t  make_decl_rtl (decl, asmspec);\n+\t  const char *option      = target_options[i].prefix;\n+\t  const char *description = target_options[i].description;\n+\n+\t  if (option == NULL || *option == 0)\n+\t    continue;\n+\t  else if (description == NULL)\n+\t    {\n+\t      undoc = 1;\n+\n+\t      if (extra_warnings)\n+\t\tprintf (_(\"  -m%-23s [undocumented]\\n\"), option);\n+\t    }\n+\t  else if (*description != 0)\n+\t    doc += printf (\"  -m%-23s %s\\n\", option, _(description));\n \t}\n-      else\n+#endif\n+      if (undoc)\n \t{\n-\t  error (\"invalid register name `%s' for register variable\", asmspec);\n-\t  DECL_REGISTER (decl) = 0;\n-\t  if (!top_level)\n-\t    expand_decl (decl);\n+\t  if (doc)\n+\t    printf (_(\"\\nThere are undocumented target specific options as well.\\n\"));\n+\t  else\n+\t    printf (_(\"  They exist, but they are not documented.\\n\"));\n \t}\n     }\n-  else if (TREE_CODE (decl) == TYPE_DECL)\n-    {\n-      timevar_push (TV_SYMOUT);\n-      debug_hooks->type_decl (decl, !top_level);\n-      timevar_pop (TV_SYMOUT);\n-    }\n }\n \n-/* Called after finishing a record, union or enumeral type.  */\n+/* Parse a -d... command line switch.  */\n \n void\n-rest_of_type_compilation (tree type, int toplev)\n+decode_d_option (const char *arg)\n {\n-  /* Avoid confusing the debug information machinery when there are\n-     errors.  */\n-  if (errorcount != 0 || sorrycount != 0)\n-    return;\n+  int c;\n \n-  timevar_push (TV_SYMOUT);\n-  debug_hooks->type_decl (TYPE_STUB_DECL (type), !toplev);\n-  timevar_pop (TV_SYMOUT);\n+  while (*arg)\n+    switch (c = *arg++)\n+      {\n+      case 'A':\n+\tflag_debug_asm = 1;\n+\tbreak;\n+      case 'p':\n+\tflag_print_asm_name = 1;\n+\tbreak;\n+      case 'P':\n+\tflag_dump_rtl_in_asm = 1;\n+\tflag_print_asm_name = 1;\n+\tbreak;\n+      case 'v':\n+\tgraph_dump_format = vcg;\n+\tbreak;\n+      case 'x':\n+\trtl_dump_and_exit = 1;\n+\tbreak;\n+      case 'y':\n+\tset_yydebug = 1;\n+\tbreak;\n+      case 'D':\t/* These are handled by the preprocessor.  */\n+      case 'I':\n+\tbreak;\n+      case 'H':\n+\tsetup_core_dumping();\n+\tbreak;\n+\n+      case 'a':\n+      default:\n+\tif (!enable_rtl_dump_file (c))\n+\t  warning (\"unrecognized gcc debugging option: %c\", c);\n+\tbreak;\n+      }\n }\n \n-/* Turn the RTL into assembly.  */\n-static void\n-rest_of_handle_final (tree decl, rtx insns)\n+/* Indexed by enum debug_info_type.  */\n+const char *const debug_type_names[] =\n {\n-  timevar_push (TV_FINAL);\n-  {\n-    rtx x;\n-    const char *fnname;\n-\n-    /* Get the function's name, as described by its RTL.  This may be\n-       different from the DECL_NAME name used in the source file.  */\n-\n-    x = DECL_RTL (decl);\n-    if (GET_CODE (x) != MEM)\n-      abort ();\n-    x = XEXP (x, 0);\n-    if (GET_CODE (x) != SYMBOL_REF)\n-      abort ();\n-    fnname = XSTR (x, 0);\n+  \"none\", \"stabs\", \"coff\", \"dwarf-1\", \"dwarf-2\", \"xcoff\", \"vms\"\n+};\n \n-    assemble_start_function (decl, fnname);\n-    final_start_function (insns, asm_out_file, optimize);\n-    final (insns, asm_out_file, optimize, 0);\n-    final_end_function ();\n+/* Decode -m switches.  */\n+/* Decode the switch -mNAME.  */\n \n-#ifdef IA64_UNWIND_INFO\n-    /* ??? The IA-64 \".handlerdata\" directive must be issued before\n-       the \".endp\" directive that closes the procedure descriptor.  */\n-    output_function_exception_table ();\n-#endif\n+void\n+set_target_switch (const char *name)\n+{\n+  size_t j;\n+  int valid_target_option = 0;\n \n-    assemble_end_function (decl, fnname);\n+  for (j = 0; j < ARRAY_SIZE (target_switches); j++)\n+    if (!strcmp (target_switches[j].name, name))\n+      {\n+\tif (target_switches[j].value < 0)\n+\t  target_flags &= ~-target_switches[j].value;\n+\telse\n+\t  target_flags |= target_switches[j].value;\n+\tif (name[0] != 0)\n+\t  {\n+\t    if (target_switches[j].value < 0)\n+\t      target_flags_explicit |= -target_switches[j].value;\n+\t    else\n+\t      target_flags_explicit |= target_switches[j].value;\n+\t  }\n+\tvalid_target_option = 1;\n+      }\n \n-#ifndef IA64_UNWIND_INFO\n-    /* Otherwise, it feels unclean to switch sections in the middle.  */\n-    output_function_exception_table ();\n+#ifdef TARGET_OPTIONS\n+  if (!valid_target_option)\n+    for (j = 0; j < ARRAY_SIZE (target_options); j++)\n+      {\n+\tint len = strlen (target_options[j].prefix);\n+\tif (target_options[j].value)\n+\t  {\n+\t    if (!strcmp (target_options[j].prefix, name))\n+\t      {\n+\t\t*target_options[j].variable = target_options[j].value;\n+\t\tvalid_target_option = 1;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    if (!strncmp (target_options[j].prefix, name, len))\n+\t      {\n+\t\t*target_options[j].variable = name + len;\n+\t\tvalid_target_option = 1;\n+\t      }\n+\t  }\n+      }\n #endif\n \n-    if (! quiet_flag)\n-      fflush (asm_out_file);\n-\n-    /* Release all memory allocated by flow.  */\n-    free_basic_block_vars (0);\n-\n-    /* Release all memory held by regsets now.  */\n-    regset_release_memory ();\n-  }\n-  timevar_pop (TV_FINAL);\n-\n-  ggc_collect ();\n+  if (!valid_target_option)\n+    error (\"invalid option `%s'\", name);\n }\n \n-#ifdef DELAY_SLOTS\n-/* Run delay slot optimization.  */\n-static void\n-rest_of_handle_delay_slots (tree decl, rtx insns)\n-{\n-  timevar_push (TV_DBR_SCHED);\n-  open_dump_file (DFI_dbr, decl);\n-\n-  dbr_schedule (insns, dump_file);\n-\n-  close_dump_file (DFI_dbr, print_rtl, insns);\n-  timevar_pop (TV_DBR_SCHED);\n-\n-  ggc_collect ();\n-}\n-#endif\n+/* Print version information to FILE.\n+   Each line begins with INDENT (for the case where FILE is the\n+   assembler output file).  */\n \n-#ifdef STACK_REGS\n-/* Convert register usage from flat register file usage to a stack\n-   register file.  */\n-static void\n-rest_of_handle_stack_regs (tree decl, rtx insns)\n-{\n-#if defined (HAVE_ATTR_length)\n-  /* If flow2 creates new instructions which need splitting\n-     and scheduling after reload is not done, they might not be\n-     split until final which doesn't allow splitting\n-     if HAVE_ATTR_length.  */\n-#ifdef INSN_SCHEDULING\n-  if (optimize && !flag_schedule_insns_after_reload)\n-#else\n-  if (optimize)\n-#endif\n-    {\n-      timevar_push (TV_SHORTEN_BRANCH);\n-      split_all_insns (1);\n-      timevar_pop (TV_SHORTEN_BRANCH);\n-    }\n-#endif\n-\n-  timevar_push (TV_REG_STACK);\n-  open_dump_file (DFI_stack, decl);\n-\n-  if (reg_to_stack (insns, dump_file) && optimize)\n-    {\n-      if (cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK\n-\t\t       | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0))\n-\t  && flag_reorder_blocks)\n-\t{\n-\t  reorder_basic_blocks ();\n-\t  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK);\n-\t}\n-    }\n-\n-  close_dump_file (DFI_stack, print_rtl_with_bb, insns);\n-  timevar_pop (TV_REG_STACK);\n-\n-  ggc_collect ();\n-}\n-#endif\n-\n-/* Track the variables, ie. compute where the variable is stored at each position in function.  */\n-static void\n-rest_of_handle_variable_tracking (tree decl, rtx insns)\n-{\n-  timevar_push (TV_VAR_TRACKING);\n-  open_dump_file (DFI_vartrack, decl);\n-\n-  variable_tracking_main ();\n-\n-  close_dump_file (DFI_vartrack, print_rtl_with_bb, insns);\n-  timevar_pop (TV_VAR_TRACKING);\n-}\n-\n-/* Machine independent reorg pass.  */\n-static void\n-rest_of_handle_machine_reorg (tree decl, rtx insns)\n-{\n-  timevar_push (TV_MACH_DEP);\n-  open_dump_file (DFI_mach, decl);\n-\n-  (*targetm.machine_dependent_reorg) ();\n-\n-  close_dump_file (DFI_mach, print_rtl, insns);\n-  timevar_pop (TV_MACH_DEP);\n-\n-  ggc_collect ();\n-}\n-\n-\n-/* Run new register allocator.  Return TRUE if we must exit\n-   rest_of_compilation upon return.  */\n-static bool\n-rest_of_handle_new_regalloc (tree decl, rtx insns)\n-{\n-  int failure;\n-\n-  delete_trivially_dead_insns (insns, max_reg_num ());\n-  reg_alloc ();\n-\n-  timevar_pop (TV_LOCAL_ALLOC);\n-  if (dump_file_tbl[DFI_lreg].enabled)\n-    {\n-      timevar_push (TV_DUMP);\n-\n-      close_dump_file (DFI_lreg, NULL, NULL);\n-      timevar_pop (TV_DUMP);\n-    }\n-\n-  /* XXX clean up the whole mess to bring live info in shape again.  */\n-  timevar_push (TV_GLOBAL_ALLOC);\n-  open_dump_file (DFI_greg, decl);\n-\n-  build_insn_chain (insns);\n-  failure = reload (insns, 0);\n-\n-  timevar_pop (TV_GLOBAL_ALLOC);\n-\n-  if (dump_file_tbl[DFI_greg].enabled)\n-    {\n-      timevar_push (TV_DUMP);\n-\n-      dump_global_regs (dump_file);\n-\n-      close_dump_file (DFI_greg, print_rtl_with_bb, insns);\n-      timevar_pop (TV_DUMP);\n-    }\n-\n-  if (failure)\n-    return true;\n-\n-  reload_completed = 1;\n-\n-  return false;\n-}\n-\n-/* Run old register allocator.  Return TRUE if we must exit\n-   rest_of_compilation upon return.  */\n-static bool\n-rest_of_handle_old_regalloc (tree decl, rtx insns)\n-{\n-  int failure;\n-  int rebuild_notes;\n-\n-  /* Allocate the reg_renumber array.  */\n-  allocate_reg_info (max_regno, FALSE, TRUE);\n-\n-  /* And the reg_equiv_memory_loc array.  */\n-  reg_equiv_memory_loc = xcalloc (max_regno, sizeof (rtx));\n-\n-  allocate_initial_values (reg_equiv_memory_loc);\n-\n-  regclass (insns, max_reg_num (), dump_file);\n-  rebuild_notes = local_alloc ();\n-\n-  timevar_pop (TV_LOCAL_ALLOC);\n-\n-  /* Local allocation may have turned an indirect jump into a direct\n-     jump.  If so, we must rebuild the JUMP_LABEL fields of jumping\n-     instructions.  */\n-  if (rebuild_notes)\n-    {\n-      timevar_push (TV_JUMP);\n-\n-      rebuild_jump_labels (insns);\n-      purge_all_dead_edges (0);\n-\n-      timevar_pop (TV_JUMP);\n-    }\n-\n-  if (dump_file_tbl[DFI_lreg].enabled)\n-    {\n-      timevar_push (TV_DUMP);\n-\n-      dump_flow_info (dump_file);\n-      dump_local_alloc (dump_file);\n-\n-      close_dump_file (DFI_lreg, print_rtl_with_bb, insns);\n-      timevar_pop (TV_DUMP);\n-    }\n-\n-  ggc_collect ();\n-\n-  timevar_push (TV_GLOBAL_ALLOC);\n-  open_dump_file (DFI_greg, decl);\n-\n-  /* If optimizing, allocate remaining pseudo-regs.  Do the reload\n-     pass fixing up any insns that are invalid.  */\n-\n-  if (optimize)\n-    failure = global_alloc (dump_file);\n-  else\n-    {\n-      build_insn_chain (insns);\n-      failure = reload (insns, 0);\n-    }\n-\n-  timevar_pop (TV_GLOBAL_ALLOC);\n-\n-  if (dump_file_tbl[DFI_greg].enabled)\n-    {\n-      timevar_push (TV_DUMP);\n-\n-      dump_global_regs (dump_file);\n-\n-      close_dump_file (DFI_greg, print_rtl_with_bb, insns);\n-      timevar_pop (TV_DUMP);\n-    }\n-\n-  return failure;\n-}\n-\n-/* Run the regrename and cprop passes.  */\n-static void\n-rest_of_handle_regrename (tree decl, rtx insns)\n-{\n-  timevar_push (TV_RENAME_REGISTERS);\n-  open_dump_file (DFI_rnreg, decl);\n-\n-  if (flag_rename_registers)\n-    regrename_optimize ();\n-  if (flag_cprop_registers)\n-    copyprop_hardreg_forward ();\n-\n-  close_dump_file (DFI_rnreg, print_rtl_with_bb, insns);\n-  timevar_pop (TV_RENAME_REGISTERS);\n-}\n-\n-/* Reorder basic blocks.  */\n-static void\n-rest_of_handle_reorder_blocks (tree decl, rtx insns)\n-{\n-  bool changed;\n-  open_dump_file (DFI_bbro, decl);\n-\n-  /* Last attempt to optimize CFG, as scheduling, peepholing and insn\n-     splitting possibly introduced more crossjumping opportunities.  */\n-  changed = cleanup_cfg (CLEANUP_EXPENSIVE\n-\t\t\t | (!HAVE_conditional_execution\n-\t\t\t    ? CLEANUP_UPDATE_LIFE : 0));\n-\n-  if (flag_sched2_use_traces && flag_schedule_insns_after_reload)\n-    tracer ();\n-  if (flag_reorder_blocks)\n-    reorder_basic_blocks ();\n-  if (flag_reorder_blocks\n-      || (flag_sched2_use_traces && flag_schedule_insns_after_reload))\n-    changed |= cleanup_cfg (CLEANUP_EXPENSIVE\n-\t\t\t    | (!HAVE_conditional_execution\n-\t\t\t       ? CLEANUP_UPDATE_LIFE : 0));\n-\n-  /* On conditional execution targets we can not update the life cheaply, so\n-     we deffer the updating to after both cleanups.  This may lose some cases\n-     but should not be terribly bad.  */\n-  if (changed && HAVE_conditional_execution)\n-    update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES,\n-\t\t      PROP_DEATH_NOTES);\n-  close_dump_file (DFI_bbro, print_rtl_with_bb, insns);\n-}\n-\n-#ifdef INSN_SCHEDULING\n-/* Run instruction scheduler.  */\n-static void\n-rest_of_handle_sched (tree decl, rtx insns)\n-{\n-  timevar_push (TV_SCHED);\n-\n-  /* Print function header into sched dump now\n-     because doing the sched analysis makes some of the dump.  */\n-  if (optimize > 0 && flag_schedule_insns)\n-    {\n-      open_dump_file (DFI_sched, decl);\n-\n-      /* Do control and data sched analysis,\n-\t and write some of the results to dump file.  */\n-\n-      schedule_insns (dump_file);\n-\n-      close_dump_file (DFI_sched, print_rtl_with_bb, insns);\n-    }\n-  timevar_pop (TV_SCHED);\n-\n-  ggc_collect ();\n-}\n-\n-/* Run second scheduling pass after reload.  */\n-static void\n-rest_of_handle_sched2 (tree decl, rtx insns)\n-{\n-  timevar_push (TV_SCHED2);\n-  open_dump_file (DFI_sched2, decl);\n-\n-  /* Do control and data sched analysis again,\n-     and write some more of the results to dump file.  */\n-\n-  split_all_insns (1);\n-\n-  if (flag_sched2_use_superblocks || flag_sched2_use_traces)\n-    {\n-      schedule_ebbs (dump_file);\n-      /* No liveness updating code yet, but it should be easy to do.\n-\t reg-stack recompute the liveness when needed for now.  */\n-      count_or_remove_death_notes (NULL, 1);\n-      cleanup_cfg (CLEANUP_EXPENSIVE);\n-    }\n-  else\n-    schedule_insns (dump_file);\n-\n-  close_dump_file (DFI_sched2, print_rtl_with_bb, insns);\n-  timevar_pop (TV_SCHED2);\n-\n-  ggc_collect ();\n-}\n-#endif\n-\n-/* Register allocation pre-pass, to reduce number of moves necessary\n-   for two-address machines.  */\n-static void\n-rest_of_handle_regmove (tree decl, rtx insns)\n-{\n-  timevar_push (TV_REGMOVE);\n-  open_dump_file (DFI_regmove, decl);\n-\n-  regmove_optimize (insns, max_reg_num (), dump_file);\n-\n-  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE);\n-  close_dump_file (DFI_regmove, print_rtl_with_bb, insns);\n-  timevar_pop (TV_REGMOVE);\n-\n-  ggc_collect ();\n-}\n-\n-/* Run tracer.  */\n-static void\n-rest_of_handle_tracer (tree decl, rtx insns)\n-{\n-  open_dump_file (DFI_tracer, decl);\n-  if (dump_file)\n-    dump_flow_info (dump_file);\n-  tracer ();\n-  cleanup_cfg (CLEANUP_EXPENSIVE);\n-  reg_scan (insns, max_reg_num (), 0);\n-  close_dump_file (DFI_tracer, print_rtl_with_bb, get_insns ());\n-}\n-\n-/* If-conversion and CFG cleanup.  */\n-static void\n-rest_of_handle_if_conversion (tree decl, rtx insns)\n-{\n-  open_dump_file (DFI_ce1, decl);\n-  if (flag_if_conversion)\n-    {\n-      timevar_push (TV_IFCVT);\n-      if (dump_file)\n-\tdump_flow_info (dump_file);\n-      cleanup_cfg (CLEANUP_EXPENSIVE);\n-      reg_scan (insns, max_reg_num (), 0);\n-      if_convert (0);\n-      timevar_pop (TV_IFCVT);\n-    }\n-  timevar_push (TV_JUMP);\n-  cleanup_cfg (CLEANUP_EXPENSIVE);\n-  reg_scan (insns, max_reg_num (), 0);\n-  timevar_pop (TV_JUMP);\n-  close_dump_file (DFI_ce1, print_rtl_with_bb, get_insns ());\n-}\n-\n-/* Rerun if-conversion, as combine may have simplified things enough\n-   to now meet sequence length restrictions.  */\n-static void\n-rest_of_handle_if_after_combine (tree decl, rtx insns)\n-{\n-  timevar_push (TV_IFCVT);\n-  open_dump_file (DFI_ce2, decl);\n-\n-  no_new_pseudos = 0;\n-  if_convert (1);\n-  no_new_pseudos = 1;\n-\n-  close_dump_file (DFI_ce2, print_rtl_with_bb, insns);\n-  timevar_pop (TV_IFCVT);\n-}\n-\n-static void\n-rest_of_handle_web (tree decl, rtx insns)\n-{\n-  open_dump_file (DFI_web, decl);\n-  timevar_push (TV_WEB);\n-  web_main ();\n-  delete_trivially_dead_insns (insns, max_reg_num ());\n-  cleanup_cfg (CLEANUP_EXPENSIVE);\n-\n-  timevar_pop (TV_WEB);\n-  close_dump_file (DFI_web, print_rtl_with_bb, insns);\n-  reg_scan (get_insns (), max_reg_num (), 0);\n-}\n-\n-/* Do branch profiling and static profile estimation passes.  */\n-static void\n-rest_of_handle_branch_prob (tree decl, rtx insns)\n-{\n-  struct loops loops;\n-\n-  timevar_push (TV_BRANCH_PROB);\n-  open_dump_file (DFI_bp, decl);\n-\n-  if (profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n-    branch_prob ();\n-\n-  /* Discover and record the loop depth at the head of each basic\n-     block.  The loop infrastructure does the real job for us.  */\n-  flow_loops_find (&loops, LOOP_TREE);\n-\n-  if (dump_file)\n-    flow_loops_dump (&loops, dump_file, NULL, 0);\n-\n-  /* Estimate using heuristics if no profiling info is available.  */\n-  if (flag_guess_branch_prob)\n-    estimate_probability (&loops);\n-\n-  flow_loops_free (&loops);\n-  free_dominance_info (CDI_DOMINATORS);\n-  close_dump_file (DFI_bp, print_rtl_with_bb, insns);\n-  timevar_pop (TV_BRANCH_PROB);\n-}\n-\n-/* Do optimizations based on expression value profiles.  */\n-static void\n-rest_of_handle_value_profile_transformations (tree decl, rtx insns)\n-{\n-  open_dump_file (DFI_vpt, decl);\n-  timevar_push (TV_VPT);\n-\n-  if (value_profile_transformations ())\n-    cleanup_cfg (CLEANUP_EXPENSIVE);\n-\n-  timevar_pop (TV_VPT);\n-  close_dump_file (DFI_vpt, print_rtl_with_bb, insns);\n-}\n-\n-/* Do control and data flow analysis; write some of the results to the\n-   dump file.  */\n-static void\n-rest_of_handle_cfg (tree decl, rtx insns)\n-{\n-  open_dump_file (DFI_cfg, decl);\n-  if (dump_file)\n-    dump_flow_info (dump_file);\n-  if (optimize)\n-    cleanup_cfg (CLEANUP_EXPENSIVE\n-\t\t | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n-\n-  /* It may make more sense to mark constant functions after dead code is\n-     eliminated by life_analysis, but we need to do it early, as -fprofile-arcs\n-     may insert code making function non-constant, but we still must consider\n-     it as constant, otherwise -fbranch-probabilities will not read data back.\n-\n-     life_analysis rarely eliminates modification of external memory.\n-   */\n-  if (optimize)\n-    {\n-      /* Alias analysis depends on this information and mark_constant_function\n-       depends on alias analysis.  */\n-      reg_scan (insns, max_reg_num (), 1);\n-      mark_constant_function ();\n-    }\n-\n-  close_dump_file (DFI_cfg, print_rtl_with_bb, insns);\n-}\n-\n-/* Purge addressofs.  */\n-static void\n-rest_of_handle_addressof (tree decl, rtx insns)\n-{\n-  open_dump_file (DFI_addressof, decl);\n-\n-  purge_addressof (insns);\n-  if (optimize && purge_all_dead_edges (0))\n-    delete_unreachable_blocks ();\n-  reg_scan (insns, max_reg_num (), 1);\n-\n-  close_dump_file (DFI_addressof, print_rtl, insns);\n-}\n-\n-/* We may have potential sibling or tail recursion sites.  Select one\n-   (of possibly multiple) methods of performing the call.  */\n-static void\n-rest_of_handle_sibling_calls (rtx insns)\n-{\n-  rtx insn;\n-  optimize_sibling_and_tail_recursive_calls ();\n-\n-  /* Recompute the CFG as sibling optimization clobbers it randomly.  */\n-  free_bb_for_insn ();\n-  find_exception_handler_labels ();\n-  rebuild_jump_labels (insns);\n-  find_basic_blocks (insns, max_reg_num (), dump_file);\n-\n-  /* There is pass ordering problem - we must lower NOTE_INSN_PREDICTION\n-     notes before simplifying cfg and we must do lowering after sibcall\n-     that unhides parts of RTL chain and cleans up the CFG.\n-\n-     Until sibcall is replaced by tree-level optimizer, lets just\n-     sweep away the NOTE_INSN_PREDICTION notes that leaked out.  */\n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    if (GET_CODE (insn) == NOTE\n-\t&& NOTE_LINE_NUMBER (insn) == NOTE_INSN_PREDICTION)\n-      delete_insn (insn);\n-\n-  close_dump_file (DFI_sibling, print_rtl, get_insns ());\n-}\n-\n-/* Perform jump bypassing and control flow optimizations.  */\n-static void\n-rest_of_handle_jump_bypass (tree decl, rtx insns)\n-{\n-  timevar_push (TV_BYPASS);\n-  open_dump_file (DFI_bypass, decl);\n-\n-  cleanup_cfg (CLEANUP_EXPENSIVE);\n-  reg_scan (insns, max_reg_num (), 1);\n-\n-  if (bypass_jumps (dump_file))\n-    {\n-      rebuild_jump_labels (insns);\n-      cleanup_cfg (CLEANUP_EXPENSIVE);\n-      delete_trivially_dead_insns (insns, max_reg_num ());\n-    }\n-\n-  close_dump_file (DFI_bypass, print_rtl_with_bb, insns);\n-  timevar_pop (TV_BYPASS);\n-\n-  ggc_collect ();\n-\n-#ifdef ENABLE_CHECKING\n-  verify_flow_info ();\n-#endif\n-}\n-\n-/* Handle inlining of functions in rest_of_compilation.  Return TRUE\n-   if we must exit rest_of_compilation upon return.  */\n-static bool\n-rest_of_handle_inlining (tree decl)\n-{\n-  rtx insns;\n-  int inlinable = 0;\n-  tree parent;\n-  const char *lose;\n-\n-  /* If we are reconsidering an inline function at the end of\n-     compilation, skip the stuff for making it inline.  */\n-  if (cfun->rtl_inline_init)\n-    return 0;\n-  cfun->rtl_inline_init = 1;\n-\n-  /* If this is nested inside an inlined external function, pretend\n-     it was only declared.  Since we cannot inline such functions,\n-     generating code for this one is not only not necessary but will\n-     confuse some debugging output writers.  */\n-  for (parent = DECL_CONTEXT (current_function_decl);\n-       parent != NULL_TREE;\n-       parent = get_containing_scope (parent))\n-    if (TREE_CODE (parent) == FUNCTION_DECL\n-\t&& DECL_INLINE (parent) && DECL_EXTERNAL (parent))\n-      {\n-\tDECL_INITIAL (decl) = 0;\n-\treturn true;\n-      }\n-    else if (TYPE_P (parent))\n-      /* A function in a local class should be treated normally.  */\n-      break;\n-\n-  /* If requested, consider whether to make this function inline.  */\n-  if ((DECL_INLINE (decl) && !flag_no_inline)\n-      || flag_inline_functions)\n-    {\n-      timevar_push (TV_INTEGRATION);\n-      lose = function_cannot_inline_p (decl);\n-      timevar_pop (TV_INTEGRATION);\n-      if (lose || ! optimize)\n-\t{\n-\t  if (warn_inline && lose && DECL_INLINE (decl))\n-            {\n-              char *msg = concat (\"%J\", lose, NULL);\n-              warning (msg, decl);\n-              free (msg);\n-            }\n-\t  DECL_ABSTRACT_ORIGIN (decl) = 0;\n-\t  /* Don't really compile an extern inline function.\n-\t     If we can't make it inline, pretend\n-\t     it was only declared.  */\n-\t  if (DECL_EXTERNAL (decl))\n-\t    {\n-\t      DECL_INITIAL (decl) = 0;\n-\t      return true;\n-\t    }\n-\t}\n-      else\n-\tinlinable = DECL_INLINE (decl) = 1;\n-    }\n-\n-  insns = get_insns ();\n-\n-  /* Dump the rtl code if we are dumping rtl.  */\n-\n-  if (open_dump_file (DFI_rtl, decl))\n-    {\n-      if (DECL_STRUCT_FUNCTION (decl)\n-\t  && DECL_STRUCT_FUNCTION (decl)->saved_for_inline)\n-\tfprintf (dump_file, \";; (integrable)\\n\\n\");\n-      close_dump_file (DFI_rtl, print_rtl, insns);\n-    }\n-\n-  /* Convert from NOTE_INSN_EH_REGION style notes, and do other\n-     sorts of eh initialization.  Delay this until after the\n-     initial rtl dump so that we can see the original nesting.  */\n-  convert_from_eh_region_ranges ();\n-\n-  /* If function is inline, and we don't yet know whether to\n-     compile it by itself, defer decision till end of compilation.\n-     wrapup_global_declarations will (indirectly) call\n-     rest_of_compilation again for those functions that need to\n-     be output.  Also defer those functions that we are supposed\n-     to defer.  */\n-\n-  if (inlinable\n-      || (DECL_INLINE (decl)\n-\t  /* Egad.  This RTL deferral test conflicts with Fortran assumptions\n-\t     for unreferenced symbols.  See g77.f-torture/execute/980520-1.f.\n-\t     But removing this line from the check breaks all languages that\n-\t     use the call graph to output symbols.  This hard-coded check is\n-\t     the least invasive work-around.  */\n-\t  && (flag_inline_functions\n-\t      || strcmp (lang_hooks.name, \"GNU F77\") == 0)\n-\t  && ((! TREE_PUBLIC (decl) && ! TREE_ADDRESSABLE (decl)\n-\t       && ! TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))\n-\t       && ! flag_keep_inline_functions)\n-\t      || DECL_EXTERNAL (decl))))\n-    DECL_DEFER_OUTPUT (decl) = 1;\n-\n-  if (DECL_INLINE (decl))\n-    /* DWARF wants separate debugging info for abstract and\n-       concrete instances of all inline functions, including those\n-       declared inline but not inlined, and those inlined even\n-       though they weren't declared inline.  Conveniently, that's\n-       what DECL_INLINE means at this point.  */\n-    (*debug_hooks->deferred_inline_function) (decl);\n-\n-  if (DECL_DEFER_OUTPUT (decl))\n-    {\n-      /* If -Wreturn-type, we have to do a bit of compilation.  We just\n-\t want to call cleanup the cfg to figure out whether or not we can\n-\t fall off the end of the function; we do the minimum amount of\n-\t work necessary to make that safe.  */\n-      if (warn_return_type)\n-\t{\n-\t  int saved_optimize = optimize;\n-\n-\t  optimize = 0;\n-\t  rebuild_jump_labels (insns);\n-\t  find_exception_handler_labels ();\n-\t  find_basic_blocks (insns, max_reg_num (), dump_file);\n-\t  cleanup_cfg (CLEANUP_PRE_SIBCALL | CLEANUP_PRE_LOOP);\n-\t  optimize = saved_optimize;\n-\n-\t  /* CFG is no longer maintained up-to-date.  */\n-\t  free_bb_for_insn ();\n-\t}\n-\n-      set_nothrow_function_flags ();\n-      if (current_function_nothrow)\n-\t/* Now we know that this can't throw; set the flag for the benefit\n-\t   of other functions later in this translation unit.  */\n-\tTREE_NOTHROW (current_function_decl) = 1;\n-\n-      timevar_push (TV_INTEGRATION);\n-      save_for_inline (decl);\n-      timevar_pop (TV_INTEGRATION);\n-      DECL_STRUCT_FUNCTION (decl)->inlinable = inlinable;\n-      return true;\n-    }\n-\n-  /* If specified extern inline but we aren't inlining it, we are\n-     done.  This goes for anything that gets here with DECL_EXTERNAL\n-     set, not just things with DECL_INLINE.  */\n-  return (bool) DECL_EXTERNAL (decl);\n-}\n-\n-/* Try to identify useless null pointer tests and delete them.  */\n-static void\n-rest_of_handle_null_pointer (tree decl, rtx insns)\n-{\n-  open_dump_file (DFI_null, decl);\n-  if (dump_file)\n-    dump_flow_info (dump_file);\n-\n-  if (delete_null_pointer_checks (insns))\n-    cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n-\n-  close_dump_file (DFI_null, print_rtl_with_bb, insns);\n-}\n-\n-/* Try combining insns through substitution.  */\n-static void\n-rest_of_handle_combine (tree decl, rtx insns)\n-{\n-  int rebuild_jump_labels_after_combine = 0;\n-\n-  timevar_push (TV_COMBINE);\n-  open_dump_file (DFI_combine, decl);\n-\n-  rebuild_jump_labels_after_combine\n-    = combine_instructions (insns, max_reg_num ());\n-\n-  /* Combining insns may have turned an indirect jump into a\n-     direct jump.  Rebuild the JUMP_LABEL fields of jumping\n-     instructions.  */\n-  if (rebuild_jump_labels_after_combine)\n-    {\n-      timevar_push (TV_JUMP);\n-      rebuild_jump_labels (insns);\n-      timevar_pop (TV_JUMP);\n-\n-      cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE);\n-    }\n-\n-  close_dump_file (DFI_combine, print_rtl_with_bb, insns);\n-  timevar_pop (TV_COMBINE);\n-\n-  ggc_collect ();\n-}\n-\n-/* Perform life analysis.  */\n-static void\n-rest_of_handle_life (tree decl, rtx insns)\n-{\n-  open_dump_file (DFI_life, decl);\n-  regclass_init ();\n-\n-#ifdef ENABLE_CHECKING\n-  verify_flow_info ();\n-#endif\n-  life_analysis (insns, dump_file, PROP_FINAL);\n-  if (optimize)\n-    cleanup_cfg ((optimize ? CLEANUP_EXPENSIVE : 0) | CLEANUP_UPDATE_LIFE\n-\t\t | CLEANUP_LOG_LINKS\n-\t\t | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n-  timevar_pop (TV_FLOW);\n-\n-  if (warn_uninitialized)\n-    {\n-      uninitialized_vars_warning (DECL_INITIAL (decl));\n-      if (extra_warnings)\n-\tsetjmp_args_warning ();\n-    }\n-\n-  if (optimize)\n-    {\n-      if (!flag_new_regalloc && initialize_uninitialized_subregs ())\n-\t{\n-\t  /* Insns were inserted, and possibly pseudos created, so\n-\t     things might look a bit different.  */\n-\t  insns = get_insns ();\n-\t  allocate_reg_life_data ();\n-\t  update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES,\n-\t\t\t    PROP_LOG_LINKS | PROP_REG_INFO | PROP_DEATH_NOTES);\n-\t}\n-    }\n-\n-  no_new_pseudos = 1;\n-\n-  close_dump_file (DFI_life, print_rtl_with_bb, insns);\n-\n-  ggc_collect ();\n-}\n-\n-/* Perform common subexpression elimination.  Nonzero value from\n-   `cse_main' means that jumps were simplified and some code may now\n-   be unreachable, so do jump optimization again.  */\n-static void\n-rest_of_handle_cse (tree decl, rtx insns)\n-{\n-  int tem;\n-\n-  open_dump_file (DFI_cse, decl);\n-  if (dump_file)\n-    dump_flow_info (dump_file);\n-  timevar_push (TV_CSE);\n-\n-  reg_scan (insns, max_reg_num (), 1);\n-\n-  tem = cse_main (insns, max_reg_num (), 0, dump_file);\n-  if (tem)\n-    rebuild_jump_labels (insns);\n-  if (purge_all_dead_edges (0))\n-    delete_unreachable_blocks ();\n-\n-  delete_trivially_dead_insns (insns, max_reg_num ());\n-\n-  /* If we are not running more CSE passes, then we are no longer\n-     expecting CSE to be run.  But always rerun it in a cheap mode.  */\n-  cse_not_expected = !flag_rerun_cse_after_loop && !flag_gcse;\n-\n-  if (tem || optimize > 1)\n-    cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n-  /* Try to identify useless null pointer tests and delete them.  */\n-  if (flag_delete_null_pointer_checks)\n-    {\n-      timevar_push (TV_JUMP);\n-\n-      if (delete_null_pointer_checks (insns))\n-\tcleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n-      timevar_pop (TV_JUMP);\n-    }\n-\n-  /* The second pass of jump optimization is likely to have\n-     removed a bunch more instructions.  */\n-  renumber_insns (dump_file);\n-\n-  timevar_pop (TV_CSE);\n-  close_dump_file (DFI_cse, print_rtl_with_bb, insns);\n-}\n-\n-/* Run second CSE pass after loop optimizations.  */\n-static void\n-rest_of_handle_cse2 (tree decl, rtx insns)\n-{\n-  int tem;\n-\n-  timevar_push (TV_CSE2);\n-  open_dump_file (DFI_cse2, decl);\n-  if (dump_file)\n-    dump_flow_info (dump_file);\n-  /* CFG is no longer maintained up-to-date.  */\n-  tem = cse_main (insns, max_reg_num (), 1, dump_file);\n-\n-  /* Run a pass to eliminate duplicated assignments to condition code\n-     registers.  We have to run this after bypass_jumps, because it\n-     makes it harder for that pass to determine whether a jump can be\n-     bypassed safely.  */\n-  cse_condition_code_reg ();\n-\n-  purge_all_dead_edges (0);\n-  delete_trivially_dead_insns (insns, max_reg_num ());\n-\n-  if (tem)\n-    {\n-      timevar_push (TV_JUMP);\n-      rebuild_jump_labels (insns);\n-      cleanup_cfg (CLEANUP_EXPENSIVE);\n-      timevar_pop (TV_JUMP);\n-    }\n-  reg_scan (insns, max_reg_num (), 0);\n-  close_dump_file (DFI_cse2, print_rtl_with_bb, insns);\n-  ggc_collect ();\n-  timevar_pop (TV_CSE2);\n-}\n-\n-/* Perform global cse.  */\n-static void\n-rest_of_handle_gcse (tree decl, rtx insns)\n-{\n-  int save_csb, save_cfj;\n-  int tem2 = 0, tem;\n-\n-  timevar_push (TV_GCSE);\n-  open_dump_file (DFI_gcse, decl);\n-\n-  tem = gcse_main (insns, dump_file);\n-  rebuild_jump_labels (insns);\n-  delete_trivially_dead_insns (insns, max_reg_num ());\n-\n-  save_csb = flag_cse_skip_blocks;\n-  save_cfj = flag_cse_follow_jumps;\n-  flag_cse_skip_blocks = flag_cse_follow_jumps = 0;\n-\n-  /* Instantiate any remaining CONSTANT_P_RTX nodes.  */\n-  if (current_function_calls_constant_p)\n-    purge_builtin_constant_p ();\n-\n-  /* If -fexpensive-optimizations, re-run CSE to clean up things done\n-     by gcse.  */\n-  if (flag_expensive_optimizations)\n-    {\n-      timevar_push (TV_CSE);\n-      reg_scan (insns, max_reg_num (), 1);\n-      tem2 = cse_main (insns, max_reg_num (), 0, dump_file);\n-      purge_all_dead_edges (0);\n-      delete_trivially_dead_insns (insns, max_reg_num ());\n-      timevar_pop (TV_CSE);\n-      cse_not_expected = !flag_rerun_cse_after_loop;\n-    }\n-\n-  /* If gcse or cse altered any jumps, rerun jump optimizations to clean\n-     things up.  Then possibly re-run CSE again.  */\n-  while (tem || tem2)\n-    {\n-      tem = tem2 = 0;\n-      timevar_push (TV_JUMP);\n-      rebuild_jump_labels (insns);\n-      cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n-      timevar_pop (TV_JUMP);\n-\n-      if (flag_expensive_optimizations)\n-\t{\n-\t  timevar_push (TV_CSE);\n-\t  reg_scan (insns, max_reg_num (), 1);\n-\t  tem2 = cse_main (insns, max_reg_num (), 0, dump_file);\n-\t  purge_all_dead_edges (0);\n-\t  delete_trivially_dead_insns (insns, max_reg_num ());\n-\t  timevar_pop (TV_CSE);\n-\t}\n-    }\n-\n-  close_dump_file (DFI_gcse, print_rtl_with_bb, insns);\n-  timevar_pop (TV_GCSE);\n-\n-  ggc_collect ();\n-  flag_cse_skip_blocks = save_csb;\n-  flag_cse_follow_jumps = save_cfj;\n-#ifdef ENABLE_CHECKING\n-  verify_flow_info ();\n-#endif\n-}\n-\n-/* Move constant computations out of loops.  */\n-static void\n-rest_of_handle_loop_optimize (tree decl, rtx insns)\n-{\n-  int do_unroll, do_prefetch;\n-\n-  timevar_push (TV_LOOP);\n-  delete_dead_jumptables ();\n-  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n-  open_dump_file (DFI_loop, decl);\n-\n-  /* CFG is no longer maintained up-to-date.  */\n-  free_bb_for_insn ();\n-\n-  if (flag_unroll_loops)\n-    do_unroll = LOOP_AUTO_UNROLL;\t/* Having two unrollers is useless.  */\n-  else\n-    do_unroll = flag_old_unroll_loops ? LOOP_UNROLL : LOOP_AUTO_UNROLL;\n-  do_prefetch = flag_prefetch_loop_arrays ? LOOP_PREFETCH : 0;\n-\n-  if (flag_rerun_loop_opt)\n-    {\n-      cleanup_barriers ();\n-\n-      /* We only want to perform unrolling once.  */\n-      loop_optimize (insns, dump_file, do_unroll);\n-      do_unroll = 0;\n-\n-      /* The first call to loop_optimize makes some instructions\n-\t trivially dead.  We delete those instructions now in the\n-\t hope that doing so will make the heuristics in loop work\n-\t better and possibly speed up compilation.  */\n-      delete_trivially_dead_insns (insns, max_reg_num ());\n-\n-      /* The regscan pass is currently necessary as the alias\n-\t analysis code depends on this information.  */\n-      reg_scan (insns, max_reg_num (), 1);\n-    }\n-  cleanup_barriers ();\n-  loop_optimize (insns, dump_file, do_unroll | LOOP_BCT | do_prefetch);\n-\n-  /* Loop can create trivially dead instructions.  */\n-  delete_trivially_dead_insns (insns, max_reg_num ());\n-  close_dump_file (DFI_loop, print_rtl, insns);\n-  timevar_pop (TV_LOOP);\n-  find_basic_blocks (insns, max_reg_num (), dump_file);\n-\n-  ggc_collect ();\n-}\n-\n-/* Perform loop optimizations.  It might be better to do them a bit\n-   sooner, but we want the profile feedback to work more\n-   efficiently.  */\n-static void\n-rest_of_handle_loop2 (tree decl, rtx insns)\n-{\n-  struct loops *loops;\n-  basic_block bb;\n-\n-  timevar_push (TV_LOOP);\n-  open_dump_file (DFI_loop2, decl);\n-  if (dump_file)\n-    dump_flow_info (dump_file);\n-\n-  /* Initialize structures for layout changes.  */\n-  cfg_layout_initialize ();\n-\n-  loops = loop_optimizer_init (dump_file);\n-\n-  if (loops)\n-    {\n-      /* The optimizations:  */\n-      if (flag_unswitch_loops)\n-\tunswitch_loops (loops);\n-\n-      if (flag_peel_loops || flag_unroll_loops)\n-\tunroll_and_peel_loops (loops,\n-\t\t\t       (flag_peel_loops ? UAP_PEEL : 0) |\n-\t\t\t       (flag_unroll_loops ? UAP_UNROLL : 0) |\n-\t\t\t       (flag_unroll_all_loops ? UAP_UNROLL_ALL : 0));\n-\n-      loop_optimizer_finalize (loops, dump_file);\n-    }\n-\n-  /* Finalize layout changes.  */\n-  FOR_EACH_BB (bb)\n-    if (bb->next_bb != EXIT_BLOCK_PTR)\n-      bb->rbi->next = bb->next_bb;\n-  cfg_layout_finalize ();\n-\n-  cleanup_cfg (CLEANUP_EXPENSIVE);\n-  delete_trivially_dead_insns (insns, max_reg_num ());\n-  reg_scan (insns, max_reg_num (), 0);\n-  if (dump_file)\n-    dump_flow_info (dump_file);\n-  close_dump_file (DFI_loop2, print_rtl_with_bb, get_insns ());\n-  timevar_pop (TV_LOOP);\n-  ggc_collect ();\n-}\n-\n-/* This is called from finish_function (within langhooks.parse_file)\n-   after each top-level definition is parsed.\n-   It is supposed to compile that function or variable\n-   and output the assembler code for it.\n-   After we return, the tree storage is freed.  */\n-\n-void\n-rest_of_compilation (tree decl)\n-{\n-  rtx insns;\n-\n-  timevar_push (TV_REST_OF_COMPILATION);\n-\n-  /* Register rtl specific functions for cfg.  */\n-  rtl_register_cfg_hooks ();\n-\n-  /* Now that we're out of the frontend, we shouldn't have any more\n-     CONCATs anywhere.  */\n-  generating_concat_p = 0;\n-\n-  /* When processing delayed functions, prepare_function_start() won't\n-     have been run to re-initialize it.  */\n-  cse_not_expected = ! optimize;\n-\n-  /* First, make sure that NOTE_BLOCK is set correctly for each\n-     NOTE_INSN_BLOCK_BEG/NOTE_INSN_BLOCK_END note.  */\n-  if (!cfun->x_whole_function_mode_p)\n-    identify_blocks ();\n-\n-  /* In function-at-a-time mode, we do not attempt to keep the BLOCK\n-     tree in sensible shape.  So, we just recalculate it here.  */\n-  if (cfun->x_whole_function_mode_p)\n-    reorder_blocks ();\n-\n-  init_flow ();\n-\n-  if (rest_of_handle_inlining (decl))\n-    goto exit_rest_of_compilation;\n-\n-  /* If we're emitting a nested function, make sure its parent gets\n-     emitted as well.  Doing otherwise confuses debug info.  */\n-  {\n-    tree parent;\n-    for (parent = DECL_CONTEXT (current_function_decl);\n-\t parent != NULL_TREE;\n-\t parent = get_containing_scope (parent))\n-      if (TREE_CODE (parent) == FUNCTION_DECL)\n-\tTREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (parent)) = 1;\n-  }\n-\n-  /* We are now committed to emitting code for this function.  Do any\n-     preparation, such as emitting abstract debug info for the inline\n-     before it gets mangled by optimization.  */\n-  if (cgraph_function_possibly_inlined_p (decl))\n-    (*debug_hooks->outlining_inline_function) (decl);\n-\n-  /* Remove any notes we don't need.  That will make iterating\n-     over the instruction sequence faster, and allow the garbage\n-     collector to reclaim the memory used by the notes.  */\n-  remove_unnecessary_notes ();\n-  reorder_blocks ();\n-\n-  ggc_collect ();\n-\n-  /* Initialize some variables used by the optimizers.  */\n-  init_function_for_compilation ();\n-\n-  if (! DECL_DEFER_OUTPUT (decl))\n-    TREE_ASM_WRITTEN (decl) = 1;\n-\n-  /* Now that integrate will no longer see our rtl, we need not\n-     distinguish between the return value of this function and the\n-     return value of called functions.  Also, we can remove all SETs\n-     of subregs of hard registers; they are only here because of\n-     integrate.  Also, we can now initialize pseudos intended to\n-     carry magic hard reg data throughout the function.  */\n-  rtx_equal_function_value_matters = 0;\n-  purge_hard_subreg_sets (get_insns ());\n-\n-  /* Early return if there were errors.  We can run afoul of our\n-     consistency checks, and there's not really much point in fixing them.\n-     Don't return yet if -Wreturn-type; we need to do cleanup_cfg.  */\n-  if (((rtl_dump_and_exit || flag_syntax_only) && !warn_return_type)\n-      || errorcount || sorrycount)\n-    goto exit_rest_of_compilation;\n-\n-  timevar_push (TV_JUMP);\n-  open_dump_file (DFI_sibling, decl);\n-  insns = get_insns ();\n-  rebuild_jump_labels (insns);\n-  find_exception_handler_labels ();\n-  find_basic_blocks (insns, max_reg_num (), dump_file);\n-\n-  delete_unreachable_blocks ();\n-\n-  /* Turn NOTE_INSN_PREDICTIONs into branch predictions.  */\n-  if (flag_guess_branch_prob)\n-    {\n-      timevar_push (TV_BRANCH_PROB);\n-      note_prediction_to_br_prob ();\n-      timevar_pop (TV_BRANCH_PROB);\n-    }\n-\n-  if (flag_optimize_sibling_calls)\n-    rest_of_handle_sibling_calls (insns);\n-\n-  /* We have to issue these warnings now already, because CFG cleanups\n-     further down may destroy the required information.  However, this\n-     must be done after the sibcall optimization pass because the barrier\n-     emitted for noreturn calls that are candidate for the optimization\n-     is folded into the CALL_PLACEHOLDER until after this pass, so the\n-     CFG is inaccurate.  */\n-  check_function_return_warnings ();\n-\n-  timevar_pop (TV_JUMP);\n-\n-  insn_locators_initialize ();\n-  /* Complete generation of exception handling code.  */\n-  if (doing_eh (0))\n-    {\n-      timevar_push (TV_JUMP);\n-      open_dump_file (DFI_eh, decl);\n-\n-      finish_eh_generation ();\n-\n-      close_dump_file (DFI_eh, print_rtl, get_insns ());\n-      timevar_pop (TV_JUMP);\n-    }\n-\n-  /* Delay emitting hard_reg_initial_value sets until after EH landing pad\n-     generation, which might create new sets.  */\n-  emit_initial_value_sets ();\n-\n-#ifdef FINALIZE_PIC\n-  /* If we are doing position-independent code generation, now\n-     is the time to output special prologues and epilogues.\n-     We do not want to do this earlier, because it just clutters\n-     up inline functions with meaningless insns.  */\n-  if (flag_pic)\n-    FINALIZE_PIC;\n-#endif\n-\n-  insns = get_insns ();\n-\n-  /* Copy any shared structure that should not be shared.  */\n-  unshare_all_rtl (current_function_decl, insns);\n-\n-#ifdef SETJMP_VIA_SAVE_AREA\n-  /* This must be performed before virtual register instantiation.\n-     Please be aware the everything in the compiler that can look\n-     at the RTL up to this point must understand that REG_SAVE_AREA\n-     is just like a use of the REG contained inside.  */\n-  if (current_function_calls_alloca)\n-    optimize_save_area_alloca (insns);\n-#endif\n-\n-  /* Instantiate all virtual registers.  */\n-  instantiate_virtual_regs (current_function_decl, insns);\n-\n-  open_dump_file (DFI_jump, decl);\n-\n-  /* Always do one jump optimization pass to ensure that JUMP_LABEL fields\n-     are initialized and to compute whether control can drop off the end\n-     of the function.  */\n-\n-  timevar_push (TV_JUMP);\n-  /* Turn NOTE_INSN_EXPECTED_VALUE into REG_BR_PROB.  Do this\n-     before jump optimization switches branch directions.  */\n-  if (flag_guess_branch_prob)\n-    expected_value_to_br_prob ();\n-\n-  reg_scan (insns, max_reg_num (), 0);\n-  rebuild_jump_labels (insns);\n-  find_basic_blocks (insns, max_reg_num (), dump_file);\n-  delete_trivially_dead_insns (insns, max_reg_num ());\n-  if (dump_file)\n-    dump_flow_info (dump_file);\n-  cleanup_cfg ((optimize ? CLEANUP_EXPENSIVE : 0) | CLEANUP_PRE_LOOP\n-\t       | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n-\n-  if (optimize)\n-    {\n-      free_bb_for_insn ();\n-      copy_loop_headers (insns);\n-      find_basic_blocks (insns, max_reg_num (), dump_file);\n-    }\n-  purge_line_number_notes (insns);\n-\n-  timevar_pop (TV_JUMP);\n-  close_dump_file (DFI_jump, print_rtl, insns);\n-\n-  /* Now is when we stop if -fsyntax-only and -Wreturn-type.  */\n-  if (rtl_dump_and_exit || flag_syntax_only || DECL_DEFER_OUTPUT (decl))\n-    goto exit_rest_of_compilation;\n-\n-  timevar_push (TV_JUMP);\n-\n-  if (optimize)\n-    cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n-\n-  if (flag_delete_null_pointer_checks)\n-    rest_of_handle_null_pointer (decl, insns);\n-\n-  /* Jump optimization, and the removal of NULL pointer checks, may\n-     have reduced the number of instructions substantially.  CSE, and\n-     future passes, allocate arrays whose dimensions involve the\n-     maximum instruction UID, so if we can reduce the maximum UID\n-     we'll save big on memory.  */\n-  renumber_insns (dump_file);\n-  timevar_pop (TV_JUMP);\n-\n-  close_dump_file (DFI_jump, print_rtl_with_bb, insns);\n-\n-  ggc_collect ();\n-\n-  if (optimize > 0)\n-    rest_of_handle_cse (decl, insns);\n-\n-  rest_of_handle_addressof (decl, insns);\n-\n-  ggc_collect ();\n-\n-  if (optimize > 0)\n-    {\n-      if (flag_gcse)\n-\trest_of_handle_gcse (decl, insns);\n-\n-      if (flag_loop_optimize)\n-\trest_of_handle_loop_optimize (decl, insns);\n-\n-      if (flag_gcse)\n-\trest_of_handle_jump_bypass (decl, insns);\n-    }\n-\n-  timevar_push (TV_FLOW);\n-\n-  rest_of_handle_cfg (decl, insns);\n-\n-  if (optimize > 0\n-      || profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n-    {\n-      rest_of_handle_branch_prob (decl, insns);\n-\n-      if (flag_branch_probabilities\n-\t  && flag_profile_values\n-\t  && flag_value_profile_transformations)\n-\trest_of_handle_value_profile_transformations (decl, insns);\n-\n-      /* Remove the death notes created for vpt.  */\n-      if (flag_profile_values)\n-\tcount_or_remove_death_notes (NULL, 1);\n-    }\n-\n-  if (optimize > 0)\n-    rest_of_handle_if_conversion (decl, insns);\n-\n-  if (flag_tracer)\n-    rest_of_handle_tracer (decl, insns);\n-\n-  if (optimize > 0\n-      && (flag_unswitch_loops\n-\t  || flag_peel_loops\n-\t  || flag_unroll_loops))\n-    rest_of_handle_loop2 (decl, insns);\n-\n-  if (flag_web)\n-    rest_of_handle_web (decl, insns);\n-\n-  if (flag_rerun_cse_after_loop)\n-    rest_of_handle_cse2 (decl, insns);\n-\n-  cse_not_expected = 1;\n-\n-  rest_of_handle_life (decl, insns);\n-\n-  if (optimize > 0)\n-    rest_of_handle_combine (decl, insns);\n-\n-  if (flag_if_conversion)\n-    rest_of_handle_if_after_combine (decl, insns);\n-\n-  if (optimize > 0 && (flag_regmove || flag_expensive_optimizations))\n-    rest_of_handle_regmove (decl, insns);\n-\n-  /* Do unconditional splitting before register allocation to allow machine\n-     description to add extra information not needed previously.  */\n-  split_all_insns (1);\n-\n-#ifdef OPTIMIZE_MODE_SWITCHING\n-  timevar_push (TV_MODE_SWITCH);\n-\n-  no_new_pseudos = 0;\n-  optimize_mode_switching (NULL);\n-  no_new_pseudos = 1;\n-\n-  timevar_pop (TV_MODE_SWITCH);\n-#endif\n-\n-  /* Any of the several passes since flow1 will have munged register\n-     lifetime data a bit.  We need it to be up to date for scheduling\n-     (see handling of reg_known_equiv in init_alias_analysis).  */\n-  recompute_reg_usage (insns, !optimize_size);\n-\n-#ifdef INSN_SCHEDULING\n-  rest_of_handle_sched (decl, insns);\n-#endif\n-\n-  /* Determine if the current function is a leaf before running reload\n-     since this can impact optimizations done by the prologue and\n-     epilogue thus changing register elimination offsets.  */\n-  current_function_is_leaf = leaf_function_p ();\n-\n-  timevar_push (TV_LOCAL_ALLOC);\n-  open_dump_file (DFI_lreg, decl);\n-\n-  if (flag_new_regalloc)\n-    {\n-      if (rest_of_handle_new_regalloc (decl, insns))\n-\tgoto exit_rest_of_compilation;\n-    }\n-  else\n-    {\n-      if (rest_of_handle_old_regalloc (decl, insns))\n-\tgoto exit_rest_of_compilation;\n-    }\n-\n-  ggc_collect ();\n-\n-  open_dump_file (DFI_postreload, decl);\n-\n-  /* Do a very simple CSE pass over just the hard registers.  */\n-  if (optimize > 0)\n-    {\n-      timevar_push (TV_RELOAD_CSE_REGS);\n-      reload_cse_regs (insns);\n-      /* reload_cse_regs can eliminate potentially-trapping MEMs.\n-\t Remove any EH edges associated with them.  */\n-      if (flag_non_call_exceptions)\n-\tpurge_all_dead_edges (0);\n-      timevar_pop (TV_RELOAD_CSE_REGS);\n-    }\n-\n-  close_dump_file (DFI_postreload, print_rtl_with_bb, insns);\n-\n-  /* Re-create the death notes which were deleted during reload.  */\n-  timevar_push (TV_FLOW2);\n-  open_dump_file (DFI_flow2, decl);\n-\n-#ifdef ENABLE_CHECKING\n-  verify_flow_info ();\n-#endif\n-\n-  /* If optimizing, then go ahead and split insns now.  */\n-#ifndef STACK_REGS\n-  if (optimize > 0)\n-#endif\n-    split_all_insns (0);\n-\n-    if (flag_branch_target_load_optimize)\n-      {\n-\topen_dump_file (DFI_branch_target_load, decl);\n-\n-\tbranch_target_load_optimize (insns, false);\n-\n-\tclose_dump_file (DFI_branch_target_load, print_rtl_with_bb, insns);\n-\n-\tggc_collect ();\n-      }\n-\n-  if (optimize)\n-    cleanup_cfg (CLEANUP_EXPENSIVE);\n-\n-  /* On some machines, the prologue and epilogue code, or parts thereof,\n-     can be represented as RTL.  Doing so lets us schedule insns between\n-     it and the rest of the code and also allows delayed branch\n-     scheduling to operate in the epilogue.  */\n-  thread_prologue_and_epilogue_insns (insns);\n-  epilogue_completed = 1;\n-\n-  if (optimize)\n-    {\n-      life_analysis (insns, dump_file, PROP_POSTRELOAD);\n-      cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE\n-\t\t   | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0));\n-\n-      /* This is kind of a heuristic.  We need to run combine_stack_adjustments\n-         even for machines with possibly nonzero RETURN_POPS_ARGS\n-         and ACCUMULATE_OUTGOING_ARGS.  We expect that only ports having\n-         push instructions will have popping returns.  */\n-#ifndef PUSH_ROUNDING\n-      if (!ACCUMULATE_OUTGOING_ARGS)\n-#endif\n-\tcombine_stack_adjustments ();\n-\n-      ggc_collect ();\n-    }\n-\n-  flow2_completed = 1;\n-\n-  close_dump_file (DFI_flow2, print_rtl_with_bb, insns);\n-  timevar_pop (TV_FLOW2);\n-\n-#ifdef HAVE_peephole2\n-  if (optimize > 0 && flag_peephole2)\n-    {\n-      timevar_push (TV_PEEPHOLE2);\n-      open_dump_file (DFI_peephole2, decl);\n-\n-      peephole2_optimize (dump_file);\n-\n-      close_dump_file (DFI_peephole2, print_rtl_with_bb, insns);\n-      timevar_pop (TV_PEEPHOLE2);\n-    }\n-#endif\n-\n-  open_dump_file (DFI_ce3, decl);\n-  if (optimize)\n-    /* Last attempt to optimize CFG, as scheduling, peepholing and insn\n-       splitting possibly introduced more crossjumping opportunities.  */\n-    cleanup_cfg (CLEANUP_EXPENSIVE\n-\t\t | CLEANUP_UPDATE_LIFE \n-\t\t | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0));\n-  if (flag_if_conversion2)\n-    {\n-      timevar_push (TV_IFCVT2);\n-\n-      if_convert (1);\n-\n-      timevar_pop (TV_IFCVT2);\n-    }\n-  close_dump_file (DFI_ce3, print_rtl_with_bb, insns);\n-\n-  if (optimize > 0)\n-    {\n-      if (flag_rename_registers || flag_cprop_registers)\n-\trest_of_handle_regrename (decl, insns);\n-\n-      rest_of_handle_reorder_blocks (decl, insns);\n-    }\n-\n-  if (flag_branch_target_load_optimize2)\n-    {\n-      /* Leave this a warning for now so that it is possible to experiment\n-\t with running this pass twice.  In 3.6, we should either make this\n-\t an error, or use separate dump files.  */\n-      if (flag_branch_target_load_optimize)\n-\twarning (\"branch target register load optimization is not intended \"\n-\t\t \"to be run twice\");\n-\n-      open_dump_file (DFI_branch_target_load, decl);\n-\n-      branch_target_load_optimize (insns, true);\n-\n-      close_dump_file (DFI_branch_target_load, print_rtl_with_bb, insns);\n-\n-      ggc_collect ();\n-    }\n-\n-#ifdef INSN_SCHEDULING\n-  if (optimize > 0 && flag_schedule_insns_after_reload)\n-    rest_of_handle_sched2 (decl, insns);\n-#endif\n-\n-#ifdef LEAF_REGISTERS\n-  current_function_uses_only_leaf_regs\n-    = optimize > 0 && only_leaf_regs_used () && leaf_function_p ();\n-#endif\n-\n-#ifdef STACK_REGS\n-  rest_of_handle_stack_regs (decl, insns);\n-#endif\n-\n-  compute_alignments ();\n-\n-  if (flag_var_tracking)\n-    rest_of_handle_variable_tracking (decl, insns);\n-\n-  /* CFG is no longer maintained up-to-date.  */\n-  free_bb_for_insn ();\n-\n-  if (targetm.machine_dependent_reorg != 0)\n-    rest_of_handle_machine_reorg (decl, insns);\n-\n-  purge_line_number_notes (insns);\n-  cleanup_barriers ();\n-\n-#ifdef DELAY_SLOTS\n-  if (optimize > 0 && flag_delayed_branch)\n-    rest_of_handle_delay_slots (decl, insns);\n-#endif\n-\n-#if defined (HAVE_ATTR_length) && !defined (STACK_REGS)\n-  timevar_push (TV_SHORTEN_BRANCH);\n-  split_all_insns_noflow ();\n-  timevar_pop (TV_SHORTEN_BRANCH);\n-#endif\n-\n-  convert_to_eh_region_ranges ();\n-\n-  /* Shorten branches.  */\n-  timevar_push (TV_SHORTEN_BRANCH);\n-  shorten_branches (get_insns ());\n-  timevar_pop (TV_SHORTEN_BRANCH);\n-\n-  set_nothrow_function_flags ();\n-  if (current_function_nothrow)\n-    /* Now we know that this can't throw; set the flag for the benefit\n-       of other functions later in this translation unit.  */\n-    TREE_NOTHROW (current_function_decl) = 1;\n-\n-  rest_of_handle_final (decl, insns);\n-\n-  /* Write DBX symbols if requested.  */\n-\n-  /* Note that for those inline functions where we don't initially\n-     know for certain that we will be generating an out-of-line copy,\n-     the first invocation of this routine (rest_of_compilation) will\n-     skip over this code by doing a `goto exit_rest_of_compilation;'.\n-     Later on, wrapup_global_declarations will (indirectly) call\n-     rest_of_compilation again for those inline functions that need\n-     to have out-of-line copies generated.  During that call, we\n-     *will* be routed past here.  */\n-\n-  timevar_push (TV_SYMOUT);\n-  (*debug_hooks->function_decl) (decl);\n-  timevar_pop (TV_SYMOUT);\n-\n- exit_rest_of_compilation:\n-\n-  coverage_end_function ();\n-\n-  /* In case the function was not output,\n-     don't leave any temporary anonymous types\n-     queued up for sdb output.  */\n-#ifdef SDB_DEBUGGING_INFO\n-  if (write_symbols == SDB_DEBUG)\n-    sdbout_types (NULL_TREE);\n-#endif\n-\n-  reload_completed = 0;\n-  epilogue_completed = 0;\n-  flow2_completed = 0;\n-  no_new_pseudos = 0;\n-\n-  timevar_push (TV_FINAL);\n-\n-  /* Clear out the insn_length contents now that they are no\n-     longer valid.  */\n-  init_insn_lengths ();\n-\n-  /* Show no temporary slots allocated.  */\n-  init_temp_slots ();\n-\n-  free_basic_block_vars (0);\n-  free_bb_for_insn ();\n-\n-  timevar_pop (TV_FINAL);\n-\n-  if ((*targetm.binds_local_p) (current_function_decl))\n-    {\n-      int pref = cfun->preferred_stack_boundary;\n-      if (cfun->recursive_call_emit\n-          && cfun->stack_alignment_needed > cfun->preferred_stack_boundary)\n-\tpref = cfun->stack_alignment_needed;\n-      cgraph_rtl_info (current_function_decl)->preferred_incoming_stack_boundary\n-        = pref;\n-    }\n-\n-  /* Make sure volatile mem refs aren't considered valid operands for\n-     arithmetic insns.  We must call this here if this is a nested inline\n-     function, since the above code leaves us in the init_recog state\n-     (from final.c), and the function context push/pop code does not\n-     save/restore volatile_ok.\n-\n-     ??? Maybe it isn't necessary for expand_start_function to call this\n-     anymore if we do it here?  */\n-\n-  init_recog_no_volatile ();\n-\n-  /* We're done with this function.  Free up memory if we can.  */\n-  free_after_parsing (cfun);\n-  if (! DECL_DEFER_OUTPUT (decl))\n-    {\n-      free_after_compilation (cfun);\n-      DECL_STRUCT_FUNCTION (decl) = 0;\n-    }\n-  cfun = 0;\n-\n-  ggc_collect ();\n-\n-  timevar_pop (TV_REST_OF_COMPILATION);\n-}\n-\n-/* Display help for target options.  */\n-void\n-display_target_options (void)\n-{\n-  int undoc, i;\n-  static bool displayed = false;\n-\n-  /* Avoid double printing for --help --target-help.  */\n-  if (displayed)\n-    return;\n-\n-  displayed = true;\n-\n-  if (ARRAY_SIZE (target_switches) > 1\n-#ifdef TARGET_OPTIONS\n-      || ARRAY_SIZE (target_options) > 1\n-#endif\n-      )\n-    {\n-      int doc = 0;\n-\n-      undoc = 0;\n-\n-      printf (_(\"\\nTarget specific options:\\n\"));\n-\n-      for (i = ARRAY_SIZE (target_switches); i--;)\n-\t{\n-\t  const char *option      = target_switches[i].name;\n-\t  const char *description = target_switches[i].description;\n-\n-\t  if (option == NULL || *option == 0)\n-\t    continue;\n-\t  else if (description == NULL)\n-\t    {\n-\t      undoc = 1;\n-\n-\t      if (extra_warnings)\n-\t\tprintf (_(\"  -m%-23s [undocumented]\\n\"), option);\n-\t    }\n-\t  else if (*description != 0)\n-\t    doc += printf (\"  -m%-23s %s\\n\", option, _(description));\n-\t}\n-\n-#ifdef TARGET_OPTIONS\n-      for (i = ARRAY_SIZE (target_options); i--;)\n-\t{\n-\t  const char *option      = target_options[i].prefix;\n-\t  const char *description = target_options[i].description;\n-\n-\t  if (option == NULL || *option == 0)\n-\t    continue;\n-\t  else if (description == NULL)\n-\t    {\n-\t      undoc = 1;\n-\n-\t      if (extra_warnings)\n-\t\tprintf (_(\"  -m%-23s [undocumented]\\n\"), option);\n-\t    }\n-\t  else if (*description != 0)\n-\t    doc += printf (\"  -m%-23s %s\\n\", option, _(description));\n-\t}\n-#endif\n-      if (undoc)\n-\t{\n-\t  if (doc)\n-\t    printf (_(\"\\nThere are undocumented target specific options as well.\\n\"));\n-\t  else\n-\t    printf (_(\"  They exist, but they are not documented.\\n\"));\n-\t}\n-    }\n-}\n-\n-/* Parse a -d... command line switch.  */\n-\n-void\n-decode_d_option (const char *arg)\n-{\n-  int i, c, matched;\n-\n-  while (*arg)\n-    switch (c = *arg++)\n-      {\n-      case 'a':\n-\tfor (i = 0; i < (int) DFI_MAX; ++i)\n-\t  dump_file_tbl[i].enabled = 1;\n-\tbreak;\n-      case 'A':\n-\tflag_debug_asm = 1;\n-\tbreak;\n-      case 'p':\n-\tflag_print_asm_name = 1;\n-\tbreak;\n-      case 'P':\n-\tflag_dump_rtl_in_asm = 1;\n-\tflag_print_asm_name = 1;\n-\tbreak;\n-      case 'v':\n-\tgraph_dump_format = vcg;\n-\tbreak;\n-      case 'x':\n-\trtl_dump_and_exit = 1;\n-\tbreak;\n-      case 'y':\n-\tset_yydebug = 1;\n-\tbreak;\n-      case 'D':\t/* These are handled by the preprocessor.  */\n-      case 'I':\n-\tbreak;\n-      case 'H':\n-\tsetup_core_dumping();\n-\tbreak;\n-\n-      default:\n-\tmatched = 0;\n-\tfor (i = 0; i < (int) DFI_MAX; ++i)\n-\t  if (c == dump_file_tbl[i].debug_switch)\n-\t    {\n-\t      dump_file_tbl[i].enabled = 1;\n-\t      matched = 1;\n-\t    }\n-\n-\tif (! matched)\n-\t  warning (\"unrecognized gcc debugging option: %c\", c);\n-\tbreak;\n-      }\n-}\n-\n-/* Indexed by enum debug_info_type.  */\n-const char *const debug_type_names[] =\n-{\n-  \"none\", \"stabs\", \"coff\", \"dwarf-1\", \"dwarf-2\", \"xcoff\", \"vms\"\n-};\n-\n-/* Decode -m switches.  */\n-/* Decode the switch -mNAME.  */\n-\n-void\n-set_target_switch (const char *name)\n-{\n-  size_t j;\n-  int valid_target_option = 0;\n-\n-  for (j = 0; j < ARRAY_SIZE (target_switches); j++)\n-    if (!strcmp (target_switches[j].name, name))\n-      {\n-\tif (target_switches[j].value < 0)\n-\t  target_flags &= ~-target_switches[j].value;\n-\telse\n-\t  target_flags |= target_switches[j].value;\n-\tif (name[0] != 0)\n-\t  {\n-\t    if (target_switches[j].value < 0)\n-\t      target_flags_explicit |= -target_switches[j].value;\n-\t    else\n-\t      target_flags_explicit |= target_switches[j].value;\n-\t  }\n-\tvalid_target_option = 1;\n-      }\n-\n-#ifdef TARGET_OPTIONS\n-  if (!valid_target_option)\n-    for (j = 0; j < ARRAY_SIZE (target_options); j++)\n-      {\n-\tint len = strlen (target_options[j].prefix);\n-\tif (target_options[j].value)\n-\t  {\n-\t    if (!strcmp (target_options[j].prefix, name))\n-\t      {\n-\t\t*target_options[j].variable = target_options[j].value;\n-\t\tvalid_target_option = 1;\n-\t      }\n-\t  }\n-\telse\n-\t  {\n-\t    if (!strncmp (target_options[j].prefix, name, len))\n-\t      {\n-\t\t*target_options[j].variable = name + len;\n-\t\tvalid_target_option = 1;\n-\t      }\n-\t  }\n-      }\n-#endif\n-\n-  if (!valid_target_option)\n-    error (\"invalid option `%s'\", name);\n-}\n-\n-/* Print version information to FILE.\n-   Each line begins with INDENT (for the case where FILE is the\n-   assembler output file).  */\n-\n-void\n-print_version (FILE *file, const char *indent)\n+void\n+print_version (FILE *file, const char *indent)\n {\n #ifndef __VERSION__\n #define __VERSION__ \"[?]\"\n@@ -4590,23 +2517,7 @@ finalize (void)\n \tfatal_error (\"error closing %s: %m\", asm_file_name);\n     }\n \n-  /* Do whatever is necessary to finish printing the graphs.  */\n-  if (graph_dump_format != no_graph)\n-    {\n-      int i;\n-\n-      for (i = 0; i < (int) DFI_MAX; ++i)\n-\tif (dump_file_tbl[i].initialized && dump_file_tbl[i].graph_dump_p)\n-\t  {\n-\t    char seq[16];\n-\t    char *suffix;\n-\n-\t    sprintf (seq, DUMPFILE_FORMAT, i);\n-\t    suffix = concat (seq, dump_file_tbl[i].extension, NULL);\n-\t    finish_graph_dump_file (dump_base_name, suffix);\n-\t    free (suffix);\n-\t  }\n-    }\n+  finish_optimization_passes ();\n \n   if (mem_report)\n     {\n@@ -4646,23 +2557,7 @@ do_compile (void)\n \n       /* Language-dependent initialization.  Returns true on success.  */\n       if (lang_dependent_init (main_input_filename))\n-\t{\n-\t  if (flag_unit_at_a_time)\n-\t    {\n-\t      open_dump_file (DFI_cgraph, NULL);\n-\t      cgraph_dump_file = dump_file;\n-\t      dump_file = NULL;\n-\t    }\n-\n-\t  compile_file ();\n-\n-\t  if (flag_unit_at_a_time)\n-\t    {\n-\t      dump_file = cgraph_dump_file;\n-\t      cgraph_dump_file = NULL;\n-              close_dump_file (DFI_cgraph, NULL, NULL_RTX);\n-\t    }\n-\t}\n+\tcompile_file ();\n \n       finalize ();\n     }"}, {"sha": "91fea9e253c236a197b13723a245f561255077dc", "filename": "gcc/toplev.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6db1481a7e4e5c6d97baecde520bcf60487deb5/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6db1481a7e4e5c6d97baecde520bcf60487deb5/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=f6db1481a7e4e5c6d97baecde520bcf60487deb5", "patch": "@@ -68,6 +68,9 @@ extern void rest_of_decl_compilation (tree, const char *, int, int);\n extern void rest_of_type_compilation (tree, int);\n extern void rest_of_compilation (tree);\n extern void tree_rest_of_compilation (tree, bool);\n+extern void init_optimization_passes (void);\n+extern void finish_optimization_passes (void);\n+extern bool enable_rtl_dump_file (int);\n \n extern void announce_function (tree);\n "}]}