{"sha": "115a82d3f11547152be8579f1302b2fd544e736f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTE1YTgyZDNmMTE1NDcxNTJiZTg1NzlmMTMwMmIyZmQ1NDRlNzM2Zg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2005-11-17T21:03:50Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2005-11-17T21:03:50Z"}, "message": "re PR ada/22333 (ACATS FAIL c34007p c34007r c45282b spurious discriminant CONSTRAINT_ERROR)\n\n\tPR ada/22333\n\t* trans.c (gnat_gimplify_expr, case ADDR_EXPR): Always make\n\ta temporary if taking the address of something that is neither\n\treference, declaration, or constant, since the gimplifier\n\tcan't handle that case.\n\nFrom-SVN: r107134", "tree": {"sha": "95f067923cc5dea4fd2ea68e19043c449187374c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95f067923cc5dea4fd2ea68e19043c449187374c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/115a82d3f11547152be8579f1302b2fd544e736f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/115a82d3f11547152be8579f1302b2fd544e736f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/115a82d3f11547152be8579f1302b2fd544e736f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/115a82d3f11547152be8579f1302b2fd544e736f/comments", "author": null, "committer": null, "parents": [{"sha": "f4e1433a02a9bd5e2ddecd0d346d57876ad53307", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4e1433a02a9bd5e2ddecd0d346d57876ad53307", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4e1433a02a9bd5e2ddecd0d346d57876ad53307"}], "stats": {"total": 46, "additions": 40, "deletions": 6}, "files": [{"sha": "78aaba7a9a626257137ce2c60f486cc5461ff58f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/115a82d3f11547152be8579f1302b2fd544e736f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/115a82d3f11547152be8579f1302b2fd544e736f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=115a82d3f11547152be8579f1302b2fd544e736f", "patch": "@@ -1,3 +1,11 @@\n+2005-11-17  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\tPR ada/22333\n+\t* trans.c (gnat_gimplify_expr, case ADDR_EXPR): Always make\n+\ta temporary if taking the address of something that is neither\n+\treference, declaration, or constant, since the gimplifier\n+\tcan't handle that case.\n+\n 2005-11-17  Laurent GUERBY  <laurent@guerby.net>\n \n \tPR ada/24857"}, {"sha": "c71267200030ae48b80ff6d5448d1b66cb6dabb5", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 32, "deletions": 6, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/115a82d3f11547152be8579f1302b2fd544e736f/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/115a82d3f11547152be8579f1302b2fd544e736f/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=115a82d3f11547152be8579f1302b2fd544e736f", "patch": "@@ -4570,6 +4570,7 @@ int\n gnat_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p ATTRIBUTE_UNUSED)\n {\n   tree expr = *expr_p;\n+  tree op;\n \n   if (IS_ADA_STMT (expr))\n     return gnat_gimplify_stmt (expr_p);\n@@ -4600,25 +4601,50 @@ gnat_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p ATTRIBUTE_UNUSED)\n       return GS_OK;\n \n     case ADDR_EXPR:\n+      op = TREE_OPERAND (expr, 0);\n+\n       /* If we're taking the address of a constant CONSTRUCTOR, force it to\n \t be put into static memory.  We know it's going to be readonly given\n \t the semantics we have and it's required to be static memory in\n-\t the case when the reference is in an elaboration procedure.  */\n-      if (TREE_CODE (TREE_OPERAND (expr, 0)) == CONSTRUCTOR\n-\t  && TREE_CONSTANT (TREE_OPERAND (expr, 0)))\n+\t the case when the reference is in an elaboration procedure.   */\n+      if (TREE_CODE (op) == CONSTRUCTOR && TREE_CONSTANT (op))\n \t{\n-\t  tree new_var\n-\t    = create_tmp_var (TREE_TYPE (TREE_OPERAND (expr, 0)), \"C\");\n+\t  tree new_var = create_tmp_var (TREE_TYPE (op), \"C\");\n \n \t  TREE_READONLY (new_var) = 1;\n \t  TREE_STATIC (new_var) = 1;\n \t  TREE_ADDRESSABLE (new_var) = 1;\n-\t  DECL_INITIAL (new_var) = TREE_OPERAND (expr, 0);\n+\t  DECL_INITIAL (new_var) = op;\n+\n+\t  TREE_OPERAND (expr, 0) = new_var;\n+\t  recompute_tree_invarant_for_addr_expr (expr);\n+\t  return GS_ALL_DONE;\n+\t}\n+\n+      /* Otherwise, if we are taking the address of something that is neither\n+\t reference, declaration, or constant, make a variable for the operand\n+\t here and then take its address.  If we don't do it this way, we may\n+\t confuse the gimplifier because it needs to know the variable is\n+\t addressable at this point.  This duplicates code in\n+\t internal_get_tmp_var, which is unfortunate.  */\n+      else if (TREE_CODE_CLASS (TREE_CODE (op)) != tcc_reference\n+\t       && TREE_CODE_CLASS (TREE_CODE (op)) != tcc_declaration\n+\t       && TREE_CODE_CLASS (TREE_CODE (op)) != tcc_constant)\n+\t{\n+\t  tree new_var = create_tmp_var (TREE_TYPE (op), \"A\");\n+\t  tree mod = build (MODIFY_EXPR, TREE_TYPE (op), new_var, op);\n+\n+\t  TREE_ADDRESSABLE (new_var) = 1;\n+\n+\t  if (EXPR_HAS_LOCATION (op))\n+\t    SET_EXPR_LOCUS (mod, EXPR_LOCUS (op));\n \n+\t  gimplify_and_add (mod, pre_p);\n \t  TREE_OPERAND (expr, 0) = new_var;\n \t  recompute_tree_invarant_for_addr_expr (expr);\n \t  return GS_ALL_DONE;\n \t}\n+\n       return GS_UNHANDLED;\n \n     case COMPONENT_REF:"}]}