{"sha": "49e25d3e29aa1b56e6e82654de1a452a6cedc265", "node_id": "C_kwDOANBUbNoAKDQ5ZTI1ZDNlMjlhYTFiNTZlNmU4MjY1NGRlMWE0NTJhNmNlZGMyNjU", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-08-24T23:17:27Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-08-24T23:17:27Z"}, "message": "libstdc++: Implement ranges::zip_view from P2321R2\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/ranges_algo.h (__min_fn, min): Move to ...\n\t* include/bits/ranges_util.h: ... here, in order to avoid\n\tincluding all of ranges_algo.h from <ranges>.\n\t* include/std/ranges (__detail::__zip_is_common): Define for\n\tC++23 as per P2321R2.\n\t(__detail::__tuple_or_pair): Likewise.\n\t(__detail::__tuple_or_pair_t): Likewise.\n\t(__detail::__tuple_transform): Likewise.\n\t(__detail::__tuple_for_each): Likewise.\n\t(zip_view): Likewise.\n\t(enable_borrowed_range<zip_view>): Likewise.\n\t(__detail::__all_random_access): Likewise.\n\t(__detail::__all_bidirectional): Likewise.\n\t(__detail::__all_forward): Likewise.\n\t(__detail::__zip_view_iter_cat): Likewise.\n\t(zip_view::_Iterator): Likewise.\n\t(zip_view::_Sentinel): Likewise.\n\t* testsuite/std/ranges/zip/1.cc: New test.", "tree": {"sha": "4c13c1fbfeed2a59a2b21b65c7522832d050da4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c13c1fbfeed2a59a2b21b65c7522832d050da4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49e25d3e29aa1b56e6e82654de1a452a6cedc265", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49e25d3e29aa1b56e6e82654de1a452a6cedc265", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49e25d3e29aa1b56e6e82654de1a452a6cedc265", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49e25d3e29aa1b56e6e82654de1a452a6cedc265/comments", "author": null, "committer": null, "parents": [{"sha": "e5428086c2c8daf69e5916dd5016d1e7b85d3f0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5428086c2c8daf69e5916dd5016d1e7b85d3f0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5428086c2c8daf69e5916dd5016d1e7b85d3f0d"}], "stats": {"total": 662, "additions": 609, "deletions": 53}, "files": [{"sha": "2a116361a674012309589fe9a9952dba4c32b699", "filename": "libstdc++-v3/include/bits/ranges_algo.h", "status": "modified", "additions": 1, "deletions": 53, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49e25d3e29aa1b56e6e82654de1a452a6cedc265/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49e25d3e29aa1b56e6e82654de1a452a6cedc265/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h?ref=49e25d3e29aa1b56e6e82654de1a452a6cedc265", "patch": "@@ -2902,59 +2902,7 @@ namespace ranges\n \n   inline constexpr __set_symmetric_difference_fn set_symmetric_difference{};\n \n-  struct __min_fn\n-  {\n-    template<typename _Tp, typename _Proj = identity,\n-\t     indirect_strict_weak_order<projected<const _Tp*, _Proj>>\n-\t       _Comp = ranges::less>\n-      constexpr const _Tp&\n-      operator()(const _Tp& __a, const _Tp& __b,\n-\t\t _Comp __comp = {}, _Proj __proj = {}) const\n-      {\n-\tif (std::__invoke(__comp,\n-\t\t\t  std::__invoke(__proj, __b),\n-\t\t\t  std::__invoke(__proj, __a)))\n-\t  return __b;\n-\telse\n-\t  return __a;\n-      }\n-\n-    template<input_range _Range, typename _Proj = identity,\n-\t     indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>>\n-\t       _Comp = ranges::less>\n-      requires indirectly_copyable_storable<iterator_t<_Range>,\n-\t\t\t\t\t    range_value_t<_Range>*>\n-      constexpr range_value_t<_Range>\n-      operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const\n-      {\n-\tauto __first = ranges::begin(__r);\n-\tauto __last = ranges::end(__r);\n-\t__glibcxx_assert(__first != __last);\n-\tauto __result = *__first;\n-\twhile (++__first != __last)\n-\t  {\n-\t    auto __tmp = *__first;\n-\t    if (std::__invoke(__comp,\n-\t\t\t      std::__invoke(__proj, __tmp),\n-\t\t\t      std::__invoke(__proj, __result)))\n-\t      __result = std::move(__tmp);\n-\t  }\n-\treturn __result;\n-      }\n-\n-    template<copyable _Tp, typename _Proj = identity,\n-\t     indirect_strict_weak_order<projected<const _Tp*, _Proj>>\n-\t       _Comp = ranges::less>\n-      constexpr _Tp\n-      operator()(initializer_list<_Tp> __r,\n-\t\t _Comp __comp = {}, _Proj __proj = {}) const\n-      {\n-\treturn (*this)(ranges::subrange(__r),\n-\t\t       std::move(__comp), std::move(__proj));\n-      }\n-  };\n-\n-  inline constexpr __min_fn min{};\n+  // min is defined in <bits/ranges_util.h>.\n \n   struct __max_fn\n   {"}, {"sha": "bb56deee01b62302f694c959df9bab5a21b35ddc", "filename": "libstdc++-v3/include/bits/ranges_util.h", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49e25d3e29aa1b56e6e82654de1a452a6cedc265/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49e25d3e29aa1b56e6e82654de1a452a6cedc265/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_util.h?ref=49e25d3e29aa1b56e6e82654de1a452a6cedc265", "patch": "@@ -649,6 +649,61 @@ namespace ranges\n   };\n \n   inline constexpr __search_fn search{};\n+\n+  struct __min_fn\n+  {\n+    template<typename _Tp, typename _Proj = identity,\n+\t     indirect_strict_weak_order<projected<const _Tp*, _Proj>>\n+\t       _Comp = ranges::less>\n+      constexpr const _Tp&\n+      operator()(const _Tp& __a, const _Tp& __b,\n+\t\t _Comp __comp = {}, _Proj __proj = {}) const\n+      {\n+\tif (std::__invoke(__comp,\n+\t\t\t  std::__invoke(__proj, __b),\n+\t\t\t  std::__invoke(__proj, __a)))\n+\t  return __b;\n+\telse\n+\t  return __a;\n+      }\n+\n+    template<input_range _Range, typename _Proj = identity,\n+\t     indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>>\n+\t       _Comp = ranges::less>\n+      requires indirectly_copyable_storable<iterator_t<_Range>,\n+\t\t\t\t\t    range_value_t<_Range>*>\n+      constexpr range_value_t<_Range>\n+      operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const\n+      {\n+\tauto __first = ranges::begin(__r);\n+\tauto __last = ranges::end(__r);\n+\t__glibcxx_assert(__first != __last);\n+\tauto __result = *__first;\n+\twhile (++__first != __last)\n+\t  {\n+\t    auto __tmp = *__first;\n+\t    if (std::__invoke(__comp,\n+\t\t\t      std::__invoke(__proj, __tmp),\n+\t\t\t      std::__invoke(__proj, __result)))\n+\t      __result = std::move(__tmp);\n+\t  }\n+\treturn __result;\n+      }\n+\n+    template<copyable _Tp, typename _Proj = identity,\n+\t     indirect_strict_weak_order<projected<const _Tp*, _Proj>>\n+\t       _Comp = ranges::less>\n+      constexpr _Tp\n+      operator()(initializer_list<_Tp> __r,\n+\t\t _Comp __comp = {}, _Proj __proj = {}) const\n+      {\n+\treturn (*this)(ranges::subrange(__r),\n+\t\t       std::move(__comp), std::move(__proj));\n+      }\n+  };\n+\n+  inline constexpr __min_fn min{};\n+\n } // namespace ranges\n \n   using ranges::get;"}, {"sha": "c600bad62835cb7a713191b6093aad8909f1af9a", "filename": "libstdc++-v3/include/std/ranges", "status": "modified", "additions": 442, "deletions": 0, "changes": 442, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49e25d3e29aa1b56e6e82654de1a452a6cedc265/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49e25d3e29aa1b56e6e82654de1a452a6cedc265/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges?ref=49e25d3e29aa1b56e6e82654de1a452a6cedc265", "patch": "@@ -4352,6 +4352,448 @@ namespace views::__adaptor\n     inline constexpr auto values = elements<1>;\n   } // namespace views\n \n+#if __cplusplus > 202002L\n+  namespace __detail\n+  {\n+    template<typename... _Rs>\n+      concept __zip_is_common = (sizeof...(_Rs) == 1 && (common_range<_Rs> && ...))\n+\t|| (!(bidirectional_range<_Rs> && ...) && (common_range<_Rs> && ...))\n+\t|| ((random_access_range<_Rs> && ...) && (sized_range<_Rs> && ...));\n+\n+    template<typename... _Ts>\n+      struct __tuple_or_pair\n+      { using type = std::tuple<_Ts...>; };\n+\n+    template<typename _Tp, typename _Up>\n+      struct __tuple_or_pair<_Tp, _Up>\n+      { using type = pair<_Tp, _Up>; };\n+\n+    template<typename... _Ts>\n+      using __tuple_or_pair_t = typename __tuple_or_pair<_Ts...>::type;\n+\n+    template<typename _Fp, typename _Tuple>\n+      constexpr auto\n+      __tuple_transform(_Fp&& __f, _Tuple&& __tuple)\n+      {\n+\treturn std::apply([&]<typename... _Ts>(_Ts&&... __elts) {\n+\t  return __tuple_or_pair_t<invoke_result_t<_Fp&, _Ts>...>\n+\t    (std::__invoke(__f, std::forward<_Ts>(__elts))...);\n+\t}, std::forward<_Tuple>(__tuple));\n+      }\n+\n+    template<typename _Fp, typename _Tuple>\n+      constexpr void\n+      __tuple_for_each(_Fp&& __f, _Tuple&& __tuple)\n+      {\n+\tstd::apply([&]<typename... _Ts>(_Ts&&... __elts) {\n+\t  (std::__invoke(__f, std::forward<_Ts>(__elts)), ...);\n+\t}, std::forward<_Tuple>(__tuple));\n+      }\n+  } // namespace __detail\n+\n+  template<input_range... _Vs>\n+    requires (view<_Vs> && ...) && (sizeof...(_Vs) > 0)\n+  class zip_view : public view_interface<zip_view<_Vs...>>\n+  {\n+    tuple<_Vs...> _M_views;\n+\n+    template<bool> class _Iterator;\n+    template<bool> class _Sentinel;\n+\n+  public:\n+    zip_view() = default;\n+\n+    constexpr explicit\n+    zip_view(_Vs... __views)\n+      : _M_views(std::move(__views)...)\n+    { }\n+\n+    constexpr auto\n+    begin() requires (!(__detail::__simple_view<_Vs> && ...))\n+    { return _Iterator<false>(__detail::__tuple_transform(ranges::begin, _M_views)); }\n+\n+    constexpr auto\n+    begin() const requires (range<const _Vs> && ...)\n+    { return _Iterator<true>(__detail::__tuple_transform(ranges::begin, _M_views)); }\n+\n+    constexpr auto\n+    end() requires (!(__detail::__simple_view<_Vs> && ...))\n+    {\n+      if constexpr (!__detail::__zip_is_common<_Vs...>)\n+        return _Sentinel<false>(__detail::__tuple_transform(ranges::end, _M_views));\n+      else if constexpr ((random_access_range<_Vs> && ...))\n+        return begin() + iter_difference_t<_Iterator<false>>(size());\n+      else\n+        return _Iterator<false>(__detail::__tuple_transform(ranges::end, _M_views));\n+    }\n+\n+    constexpr auto\n+    end() const requires (range<const _Vs> && ...)\n+    {\n+      if constexpr (!__detail::__zip_is_common<const _Vs...>)\n+        return _Sentinel<true>(__detail::__tuple_transform(ranges::end, _M_views));\n+      else if constexpr ((random_access_range<const _Vs> && ...))\n+        return begin() + iter_difference_t<_Iterator<true>>(size());\n+      else\n+        return _Iterator<true>(__detail::__tuple_transform(ranges::end, _M_views));\n+    }\n+\n+    constexpr auto\n+    size() requires (sized_range<_Vs> && ...)\n+    {\n+      return std::apply([](auto... sizes) {\n+\tusing _CT = __detail::__make_unsigned_like_t<common_type_t<decltype(sizes)...>>;\n+\treturn ranges::min({_CT(sizes)...});\n+      }, __detail::__tuple_transform(ranges::size, _M_views));\n+    }\n+\n+    constexpr auto\n+    size() const requires (sized_range<const _Vs> && ...)\n+    {\n+      return std::apply([](auto... sizes) {\n+\tusing _CT = __detail::__make_unsigned_like_t<common_type_t<decltype(sizes)...>>;\n+\treturn ranges::min({_CT(sizes)...});\n+      }, __detail::__tuple_transform(ranges::size, _M_views));\n+    }\n+  };\n+\n+  template<typename... _Rs>\n+    zip_view(_Rs&&...) -> zip_view<views::all_t<_Rs>...>;\n+\n+  template<typename... _Views>\n+    inline constexpr bool enable_borrowed_range<zip_view<_Views...>>\n+      = (enable_borrowed_range<_Views> && ...);\n+\n+  namespace __detail\n+  {\n+    template<bool _Const, typename... _Vs>\n+      concept __all_random_access\n+\t= (random_access_range<__maybe_const_t<_Const, _Vs>> && ...);\n+\n+    template<bool _Const, typename... _Vs>\n+      concept __all_bidirectional\n+\t= (bidirectional_range<__maybe_const_t<_Const, _Vs>> && ...);\n+\n+    template<bool _Const, typename... _Vs>\n+      concept __all_forward\n+\t= (forward_range<__maybe_const_t<_Const, _Vs>> && ...);\n+\n+    template<bool _Const, typename... _Views>\n+      struct __zip_view_iter_cat\n+      { };\n+\n+    template<bool _Const, typename... _Views>\n+      requires __all_forward<_Const, _Views...>\n+      struct __zip_view_iter_cat<_Const, _Views...>\n+      { using iterator_category = input_iterator_tag; };\n+  } // namespace __detail\n+\n+  template<input_range... _Vs>\n+    requires (view<_Vs> && ...) && (sizeof...(_Vs) > 0)\n+  template<bool _Const>\n+  class zip_view<_Vs...>::_Iterator\n+    : public __detail::__zip_view_iter_cat<_Const, _Vs...>\n+  {\n+    __detail::__tuple_or_pair_t<iterator_t<__detail::__maybe_const_t<_Const, _Vs>>...> _M_current;\n+\n+    constexpr explicit\n+    _Iterator(decltype(_M_current) __current)\n+      : _M_current(std::move(__current))\n+    { }\n+\n+    static auto\n+    _S_iter_concept()\n+    {\n+      if constexpr (__detail::__all_random_access<_Const, _Vs...>)\n+\treturn random_access_iterator_tag{};\n+      else if constexpr (__detail::__all_bidirectional<_Const, _Vs...>)\n+\treturn bidirectional_iterator_tag{};\n+      else if constexpr (__detail::__all_forward<_Const, _Vs...>)\n+\treturn forward_iterator_tag{};\n+      else\n+\treturn input_iterator_tag{};\n+    }\n+\n+  public:\n+    // iterator_category defined in __zip_view_iter_cat\n+    using iterator_concept = decltype(_S_iter_concept());\n+    using value_type\n+      = __detail::__tuple_or_pair_t<range_value_t<__detail::__maybe_const_t<_Const, _Vs>>...>;\n+    using difference_type\n+      = common_type_t<range_difference_t<__detail::__maybe_const_t<_Const, _Vs>>...>;\n+\n+    _Iterator() = default;\n+\n+    constexpr\n+    _Iterator(_Iterator<!_Const> __i)\n+      requires _Const\n+\t&& (convertible_to<iterator_t<_Vs>,\n+\t\t\t   iterator_t<__detail::__maybe_const_t<_Const, _Vs>>> && ...)\n+      : _M_current(std::move(__i._M_current))\n+    { }\n+\n+    constexpr auto\n+    operator*() const\n+    {\n+      auto __f = [](auto& __i) -> decltype(auto) {\n+\treturn *__i;\n+      };\n+      return __detail::__tuple_transform(__f, _M_current);\n+    }\n+\n+    constexpr _Iterator&\n+    operator++()\n+    {\n+      __detail::__tuple_for_each([](auto& __i) { ++__i; }, _M_current);\n+      return *this;\n+    }\n+\n+    constexpr void\n+    operator++(int)\n+    { ++*this; }\n+\n+    constexpr _Iterator\n+    operator++(int)\n+      requires __detail::__all_forward<_Const, _Vs...>\n+    {\n+      auto __tmp = *this;\n+      ++*this;\n+      return __tmp;\n+    }\n+\n+    constexpr _Iterator&\n+    operator--()\n+      requires __detail::__all_bidirectional<_Const, _Vs...>\n+    {\n+      __detail::__tuple_for_each([](auto& __i) { --__i; }, _M_current);\n+      return *this;\n+    }\n+\n+    constexpr _Iterator\n+    operator--(int)\n+      requires __detail::__all_bidirectional<_Const, _Vs...>\n+    {\n+      auto __tmp = *this;\n+      --*this;\n+      return __tmp;\n+    }\n+\n+    constexpr _Iterator&\n+    operator+=(difference_type __x)\n+      requires __detail::__all_random_access<_Const, _Vs...>\n+    {\n+      auto __f = [&]<typename _It>(_It& __i) {\n+\t__i += iter_difference_t<_It>(__x);\n+      };\n+      __detail::__tuple_for_each(__f, _M_current);\n+      return *this;\n+    }\n+\n+    constexpr _Iterator&\n+    operator-=(difference_type __x)\n+      requires __detail::__all_random_access<_Const, _Vs...>\n+    {\n+      auto __f = [&]<typename _It>(_It& __i) {\n+\t__i -= iter_difference_t<_It>(__x);\n+      };\n+      __detail::__tuple_for_each(__f, _M_current);\n+      return *this;\n+    }\n+\n+    constexpr auto\n+    operator[](difference_type __n) const\n+      requires __detail::__all_random_access<_Const, _Vs...>\n+    {\n+      auto __f = [&]<typename _It>(_It& __i) -> decltype(auto) {\n+\treturn __i[iter_difference_t<_It>(__n)];\n+      };\n+      return __detail::__tuple_transform(__f, _M_current);\n+    }\n+\n+    friend constexpr bool\n+    operator==(const _Iterator& __x, const _Iterator& __y)\n+      requires (equality_comparable<iterator_t<__detail::__maybe_const_t<_Const, _Vs>>> && ...)\n+    {\n+      if constexpr (__detail::__all_bidirectional<_Const, _Vs...>)\n+\treturn __x._M_current == __y._M_current;\n+      else\n+\treturn [&]<size_t... _Is>(index_sequence<_Is...>) {\n+\t  return ((std::get<_Is>(__x._M_current) == std::get<_Is>(__y._M_current)) || ...);\n+\t}(make_index_sequence<sizeof...(_Vs)>{});\n+    }\n+\n+    friend constexpr bool\n+    operator<(const _Iterator& __x, const _Iterator& __y)\n+      requires __detail::__all_random_access<_Const, _Vs...>\n+    { return __x._M_current < __y._M_current; }\n+\n+    friend constexpr bool\n+    operator>(const _Iterator& __x, const _Iterator& __y)\n+      requires __detail::__all_random_access<_Const, _Vs...>\n+    { return __y < __x; }\n+\n+    friend constexpr bool\n+    operator<=(const _Iterator& __x, const _Iterator& __y)\n+      requires __detail::__all_random_access<_Const, _Vs...>\n+    { return !(__y < __x); }\n+\n+    friend constexpr bool\n+    operator>=(const _Iterator& __x, const _Iterator& __y)\n+      requires __detail::__all_random_access<_Const, _Vs...>\n+    { return !(__x < __y); }\n+\n+    friend constexpr auto\n+    operator<=>(const _Iterator& __x, const _Iterator& __y)\n+      requires __detail::__all_random_access<_Const, _Vs...>\n+\t&& (three_way_comparable<iterator_t<__detail::__maybe_const_t<_Const, _Vs>>> && ...)\n+    { return __x._M_current <=> __y._M_current; }\n+\n+    friend constexpr _Iterator\n+    operator+(const _Iterator& __i, difference_type __n)\n+      requires __detail::__all_random_access<_Const, _Vs...>\n+    {\n+      auto __r = __i;\n+      __r += __n;\n+      return __r;\n+    }\n+\n+    friend constexpr _Iterator\n+    operator+(difference_type __n, const _Iterator& __i)\n+      requires __detail::__all_random_access<_Const, _Vs...>\n+    {\n+      auto __r = __i;\n+      __r += __n;\n+      return __r;\n+    }\n+\n+    friend constexpr _Iterator\n+    operator-(const _Iterator& __i, difference_type __n)\n+      requires __detail::__all_random_access<_Const, _Vs...>\n+    {\n+      auto __r = __i;\n+      __r -= __n;\n+      return __r;\n+    }\n+\n+    friend constexpr difference_type\n+    operator-(const _Iterator& __x, const _Iterator& __y)\n+      requires (sized_sentinel_for<iterator_t<__detail::__maybe_const_t<_Const, _Vs>>,\n+\t\t\t\t   iterator_t<__detail::__maybe_const_t<_Const, _Vs>>> && ...)\n+    {\n+      return [&]<size_t... _Is>(index_sequence<_Is...>) {\n+\treturn ranges::min({difference_type(std::get<_Is>(__x._M_current)\n+\t\t\t\t\t    - std::get<_Is>(__y._M_current))...},\n+\t\t\t   ranges::less{},\n+\t\t\t   [](difference_type __i) -> make_unsigned_t<difference_type> {\n+\t\t\t     return __i < 0 ? -__i : __i;\n+\t\t\t   });\n+      }(make_index_sequence<sizeof...(_Vs)>{});\n+    }\n+\n+    friend constexpr auto\n+    iter_move(const _Iterator& __i)\n+    { return __detail::__tuple_transform(ranges::iter_move, __i._M_current); }\n+\n+    friend constexpr void\n+    iter_swap(const _Iterator& __l, const _Iterator& __r)\n+      requires (indirectly_swappable<iterator_t<__detail::__maybe_const_t<_Const, _Vs>>> && ...)\n+    {\n+      [&]<size_t... _Is>(index_sequence<_Is...>) {\n+\t(ranges::iter_swap(std::get<_Is>(__l._M_current), std::get<_Is>(__r._M_current)), ...);\n+      }(make_index_sequence<sizeof...(_Vs)>{});\n+    }\n+\n+    friend class zip_view;\n+  };\n+\n+  template<input_range... _Vs>\n+    requires (view<_Vs> && ...) && (sizeof...(_Vs) > 0)\n+  template<bool _Const>\n+  class zip_view<_Vs...>::_Sentinel\n+  {\n+    __detail::__tuple_or_pair_t<sentinel_t<__detail::__maybe_const_t<_Const, _Vs>>...> _M_end;\n+\n+    constexpr explicit\n+    _Sentinel(decltype(_M_end) __end)\n+      : _M_end(__end)\n+    { }\n+\n+    friend class zip_view;\n+\n+  public:\n+    _Sentinel() = default;\n+\n+    constexpr\n+    _Sentinel(_Sentinel<!_Const> __i)\n+      requires _Const\n+\t&& (convertible_to<sentinel_t<_Vs>,\n+\t\t\t   sentinel_t<__detail::__maybe_const_t<_Const, _Vs>>> && ...)\n+      : _M_end(std::move(__i._M_end))\n+    { }\n+\n+    template<bool _OtherConst>\n+      requires (sentinel_for<sentinel_t<__detail::__maybe_const_t<_Const, _Vs>>,\n+\t\t\t     iterator_t<__detail::__maybe_const_t<_OtherConst, _Vs>>> && ...)\n+    friend constexpr bool\n+    operator==(const _Iterator<_OtherConst>& __x, const _Sentinel& __y)\n+    {\n+      return [&]<size_t... _Is>(index_sequence<_Is...>) {\n+\treturn ((std::get<_Is>(__x._M_current) == std::get<_Is>(__y._M_end)) || ...);\n+      }(make_index_sequence<sizeof...(_Vs)>{});\n+    }\n+\n+    template<bool _OtherConst>\n+      requires (sized_sentinel_for<sentinel_t<__detail::__maybe_const_t<_Const, _Vs>>,\n+\t\t\t\t   iterator_t<__detail::__maybe_const_t<_OtherConst, _Vs>>> && ...)\n+    friend constexpr auto\n+    operator-(const _Iterator<_OtherConst>& __x, const _Sentinel& __y)\n+    {\n+      using _Ret\n+\t= common_type_t<range_difference_t<__detail::__maybe_const_t<_OtherConst, _Vs>>...>;\n+      return [&]<size_t... _Is>(index_sequence<_Is...>) {\n+\treturn ranges::min({_Ret(std::get<_Is>(__x._M_current) - std::get<_Is>(__y._M_end))...},\n+\t\t\t   ranges::less{},\n+\t\t\t   [](_Ret __i) -> make_unsigned_t<_Ret> {\n+\t\t\t     return __i < 0 ? -__i : __i;\n+\t\t\t   });\n+      }(make_index_sequence<sizeof...(_Vs)>{});\n+    }\n+\n+    template<bool _OtherConst>\n+      requires (sized_sentinel_for<sentinel_t<__detail::__maybe_const_t<_Const, _Vs>>,\n+\t\t\t\t   iterator_t<__detail::__maybe_const_t<_OtherConst, _Vs>>> && ...)\n+    friend constexpr auto\n+    operator-(const _Sentinel& __y, const _Iterator<_OtherConst>& __x)\n+    { return -(__x - __y); }\n+  };\n+\n+  namespace views\n+  {\n+    namespace __detail\n+    {\n+      template<typename... _Ts>\n+\tconcept __can_zip_view\n+\t  = requires { zip_view<all_t<_Ts>...>(std::declval<_Ts>()...); };\n+    }\n+\n+    struct _Zip\n+    {\n+      template<typename... _Ts>\n+\trequires (sizeof...(_Ts) == 0 || __detail::__can_zip_view<_Ts...>)\n+\t[[nodiscard]]\n+\tconstexpr auto\n+\toperator()(_Ts&&... __ts) const\n+\t{\n+\t  if constexpr (sizeof...(_Ts) == 0)\n+\t    return views::empty<tuple<>>;\n+\t  else\n+\t    return zip_view<all_t<_Ts>...>(std::forward<_Ts>(__ts)...);\n+\t}\n+    };\n+\n+    inline constexpr _Zip zip;\n+  }\n+#endif // C++23\n } // namespace ranges\n \n   namespace views = ranges::views;"}, {"sha": "0113efdb537ca4b4a47d73e3111c6bafbb62bb84", "filename": "libstdc++-v3/testsuite/std/ranges/zip/1.cc", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49e25d3e29aa1b56e6e82654de1a452a6cedc265/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fzip%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49e25d3e29aa1b56e6e82654de1a452a6cedc265/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fzip%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fzip%2F1.cc?ref=49e25d3e29aa1b56e6e82654de1a452a6cedc265", "patch": "@@ -0,0 +1,111 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do run { target c++23 } }\n+\n+#include <ranges>\n+#include <algorithm>\n+#include <utility>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+namespace ranges = std::ranges;\n+namespace views = std::views;\n+\n+constexpr bool\n+test01()\n+{\n+  static_assert(ranges::empty(views::zip()));\n+  static_assert(ranges::empty(views::empty<int>));\n+\n+  auto z1 = views::zip(std::array{1, 2});\n+  const auto i0 = z1.begin(), i1 = z1.begin() + 1;\n+  VERIFY( i0 + 1 - 1 == i0 );\n+  VERIFY( i0 < i1 );\n+  VERIFY( i1 < z1.end() );\n+  VERIFY( i1 - i0 == 1 );\n+  VERIFY( i0 - i1 == -1 );\n+  VERIFY( z1.end() - i1 == 1 );\n+  VERIFY( i1 - z1.end() == -1 );\n+  ranges::iter_swap(i0, i1);\n+  VERIFY( ranges::equal(std::move(z1) | views::keys, (int[]){2, 1}) );\n+\n+  auto z2 = views::zip(std::array{1, 2}, std::array{3, 4, 5});\n+  auto i2 = z2.begin();\n+  i2 += 1;\n+  i2 -= -1;\n+  VERIFY( i2 == z2.end() );\n+  VERIFY( ranges::size(z2) == 2 );\n+  VERIFY( ranges::size(std::as_const(z2)) == 2 );\n+  VERIFY( z2[0].first == 1 && z2[0].second == 3 );\n+  VERIFY( z2[1].first == 2 && z2[1].second == 4 );\n+  for (const auto [x, y] : z2)\n+    {\n+      VERIFY( y - x == 2 );\n+      std::swap(x, y);\n+    }\n+\n+  int x[2] = {1, 2}, y[2] = {3, 4}, z[2] = {5, 6};\n+  const auto z3 = views::zip(x, y, z);\n+  VERIFY( ranges::size(z3) == 2 );\n+  for (int i = 0; i < ranges::size(x); i++)\n+    {\n+      VERIFY( &std::get<0>(z3[i]) == &x[i] );\n+      VERIFY( &std::get<1>(z3[i]) == &y[i] );\n+      VERIFY( &std::get<2>(z3[i]) == &z[i] );\n+    }\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  using __gnu_test::test_input_range;\n+  using __gnu_test::test_forward_range;\n+  using __gnu_test::test_random_access_range;\n+\n+  using ty1 = ranges::zip_view<views::all_t<test_forward_range<int>>,\n+\t\t\t       views::all_t<test_random_access_range<int>>>;\n+  static_assert(ranges::forward_range<ty1>);\n+  static_assert(!ranges::random_access_range<ty1>);\n+  static_assert(!ranges::sized_range<ty1>);\n+\n+  using ty2 = ranges::zip_view<views::all_t<test_forward_range<int>>,\n+\t\t\t       views::all_t<test_input_range<int>>,\n+\t\t\t       views::all_t<test_forward_range<int>>>;\n+  static_assert(ranges::input_range<ty2>);\n+  static_assert(!ranges::forward_range<ty2>);\n+  static_assert(!ranges::sized_range<ty2>);\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test03()\n+{\n+  int u[] = {1, 2, 3, 4}, v[] = {4, 5, 6}, w[] = {7, 8, 9, 10};\n+  auto z = views::zip(u | views::filter([](auto) { return true; }), v, w);\n+  using ty = decltype(z);\n+  static_assert(ranges::forward_range<ty>);\n+  static_assert(!ranges::common_range<ty>);\n+  static_assert(!ranges::sized_range<ty>);\n+  VERIFY( z.begin() == z.begin() );\n+  VERIFY( z.begin() != z.end() );\n+  VERIFY( ranges::next(z.begin(), 3) == z.end() );\n+  auto it = z.begin();\n+  ++it;\n+  it++;\n+  it--;\n+  --it;\n+  VERIFY( it == z.begin() );\n+\n+  return true;\n+}\n+\n+int\n+main()\n+{\n+  static_assert(test01());\n+  static_assert(test02());\n+  static_assert(test03());\n+}"}]}