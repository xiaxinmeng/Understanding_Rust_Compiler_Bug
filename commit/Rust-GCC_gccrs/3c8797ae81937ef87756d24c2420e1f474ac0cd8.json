{"sha": "3c8797ae81937ef87756d24c2420e1f474ac0cd8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2M4Nzk3YWU4MTkzN2VmODc3NTZkMjRjMjQyMGUxZjQ3NGFjMGNkOA==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2003-11-24T21:13:38Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2003-11-24T21:13:38Z"}, "message": "codecvt_members.cc (codecvt::do_in): Rewrite, using both mbsnrtowcs and mbrtowc in a loop...\n\n2003-11-24  Paolo Carlini  <pcarlini@suse.de>\n\n\t* config/locale/gnu/codecvt_members.cc (codecvt::do_in):\n\tRewrite, using both mbsnrtowcs and mbrtowc in a loop: the\n\tformer is very fast, but stops if encounters a NUL.\n\t(codecvt::do_out): Tweak.\n\t* testsuite/performance/wchar_t_in.cc: New.\n\n2003-11-24  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/locale_facets.h\n\t(__numpunct_cache<>::_M_cache): Set _M_allocated at the beginning\n\tin order to avoid memory leaks; simplify a bit.\n\nFrom-SVN: r73893", "tree": {"sha": "791bfd27224a08bac1cf8abd7aa941c454e59645", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/791bfd27224a08bac1cf8abd7aa941c454e59645"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c8797ae81937ef87756d24c2420e1f474ac0cd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c8797ae81937ef87756d24c2420e1f474ac0cd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c8797ae81937ef87756d24c2420e1f474ac0cd8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c8797ae81937ef87756d24c2420e1f474ac0cd8/comments", "author": null, "committer": null, "parents": [{"sha": "e0ec69c929263d757b83289e79a4236d4951351a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0ec69c929263d757b83289e79a4236d4951351a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0ec69c929263d757b83289e79a4236d4951351a"}], "stats": {"total": 214, "additions": 164, "deletions": 50}, "files": [{"sha": "9826ee4d23c6092ebb4244c146d94fbb48b63adb", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8797ae81937ef87756d24c2420e1f474ac0cd8/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8797ae81937ef87756d24c2420e1f474ac0cd8/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=3c8797ae81937ef87756d24c2420e1f474ac0cd8", "patch": "@@ -1,3 +1,17 @@\n+2003-11-24  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* config/locale/gnu/codecvt_members.cc (codecvt::do_in):\n+\tRewrite, using both mbsnrtowcs and mbrtowc in a loop: the\n+\tformer is very fast, but stops if encounters a NUL.\n+\t(codecvt::do_out): Tweak.\n+\t* testsuite/performance/wchar_t_in.cc: New.\n+\n+2003-11-24  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/locale_facets.h\n+\t(__numpunct_cache<>::_M_cache): Set _M_allocated at the beginning\n+\tin order to avoid memory leaks; simplify a bit.\n+\n 2003-11-24  Benjamin Kosnik  <bkoz@redhat.com>\n \t\n \t* include/bits/streambuf_iterator.h (ostreambuf_iterator): Remove"}, {"sha": "daadc3158f4ea9f0306d994a7808b3aab40054a2", "filename": "libstdc++-v3/config/locale/gnu/codecvt_members.cc", "status": "modified", "additions": 44, "deletions": 29, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8797ae81937ef87756d24c2420e1f474ac0cd8/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fgnu%2Fcodecvt_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8797ae81937ef87756d24c2420e1f474ac0cd8/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fgnu%2Fcodecvt_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fgnu%2Fcodecvt_members.cc?ref=3c8797ae81937ef87756d24c2420e1f474ac0cd8", "patch": "@@ -97,9 +97,7 @@ namespace std\n \t    extern_type __buf[MB_LEN_MAX];\n \t    __tmp_state = __state;\n \t    const size_t __conv = wcrtomb(__buf, *__from_next, &__tmp_state);\n-\t    if (__conv == static_cast<size_t>(-1))\n-\t      __ret = error;\n-\t    else if (__conv > static_cast<size_t>(__to_end - __to_next))\n+\t    if (__conv > static_cast<size_t>(__to_end - __to_next))\n \t      __ret = partial;\n \t    else\n \t      {\n@@ -126,54 +124,71 @@ namespace std\n \tintern_type*& __to_next) const\n   {\n     result __ret = ok;\n-    // This temporary state object is neccessary so __state won't be modified\n-    // if [__from, __from_end) is a partial multibyte character.\n     state_type __tmp_state(__state);\n+\n #if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2)\n     __c_locale __old = __uselocale(_M_c_locale_codecvt);\n #endif\n \n-    // Conversion must be done by calling mbrtowc in a loop rather than\n-    // by calling mbsrtowcs because mbsrtowcs assumes that the input\n-    // sequence is zero-terminated.\n-    while (__from < __from_end && __to < __to_end)\n+    // mbsnrtowcs is *very* fast but stops if encounters NUL characters:\n+    // in case we store a L'\\0' and then continue, in a loop.\n+    // NB: mbsnrtowcs is a GNU extension\n+    __from_next = __from;\n+    __to_next = __to;\n+    while (__from_next < __from_end && __to_next < __to_end\n+\t   && __ret == ok)\n       {\n-\tsize_t __conv = mbrtowc(__to, __from, __from_end - __from,\n-\t\t\t\t&__tmp_state);\n+\tconst extern_type* __from_chunk_end;\n+\t__from_chunk_end = static_cast<const extern_type*>(memchr(__from_next, '\\0',\n+\t\t\t\t\t\t\t\t  __from_end\n+\t\t\t\t\t\t\t\t  - __from_next));\n+\tif (!__from_chunk_end)\n+\t  __from_chunk_end = __from_end;\n+\n+\tconst extern_type* __tmp_from = __from_next;\n+\tconst size_t __conv = mbsnrtowcs(__to_next, &__from_next,\n+\t\t\t\t\t __from_chunk_end - __from_next,\n+\t\t\t\t\t __to_end - __to_next, &__state);\n \tif (__conv == static_cast<size_t>(-1))\n \t  {\n+\t    // In case of error, in order to stop at the exact place we\n+\t    // have to start again from the beginning with a series of\n+\t    // mbrtowc.\n+\t    while (__tmp_from < __from_next)\n+\t      __tmp_from += mbrtowc(__to_next++, __tmp_from,\n+\t\t\t\t    __from_next - __tmp_from, &__tmp_state);\n+\t    __state = __tmp_state;\t    \n \t    __ret = error;\n-\t    break;\n \t  }\n-\telse if (__conv == static_cast<size_t>(-2))\n+\telse if (__from_next && __from_next < __from_chunk_end)\n \t  {\n-\t    // It is unclear what to return in this case (see DR 382).\n+\t    // It is unclear what to return in this case (see DR 382). \n+\t    __to_next += __conv;\n \t    __ret = partial;\n-\t    break;\n \t  }\n-\telse if (__conv == 0)\n+\telse\n \t  {\n-\t    // XXX Probably wrong for stateful encodings\n-\t    __conv = 1;\n-\t    *__to = L'\\0';\n+\t    __from_next = __from_chunk_end;\n+\t    __to_next += __conv;\n \t  }\n \n-\t__state = __tmp_state;\n-\t__to++;\n-\t__from += __conv;\n+\tif (__from_next < __from_end && __ret == ok)\n+\t  {\n+\t    if (__to_next < __to_end)\n+\t      {\n+\t\t// XXX Probably wrong for stateful encodings\n+\t\t++__from_next;\n+\t\t*__to_next++ = L'\\0';\n+\t      }\n+\t    else\n+\t      __ret = partial;\n+\t  }\n       }\n \n #if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2)\n     __uselocale(__old);\n #endif\n \n-    // It is not clear that __from < __from_end implies __ret != ok\n-    // (see DR 382).\n-    if (__ret == ok && __from < __from_end)\n-      __ret = partial;\n-\n-    __from_next = __from;\n-    __to_next = __to;\n     return __ret; \n   }\n "}, {"sha": "e6ad5ebc26a2fee1b0473cc21d94449dc27d6f8b", "filename": "libstdc++-v3/include/bits/locale_facets.h", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8797ae81937ef87756d24c2420e1f474ac0cd8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8797ae81937ef87756d24c2420e1f474ac0cd8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h?ref=3c8797ae81937ef87756d24c2420e1f474ac0cd8", "patch": "@@ -647,41 +647,42 @@ namespace std\n     void\n     __numpunct_cache<_CharT>::_M_cache(const locale& __loc)\n     {\n+      _M_allocated = true;\n+      _M_grouping = NULL;\n+      _M_truename = _M_falsename = NULL;\n+\n       const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n-      string __grouping = __np.grouping();\n-      char* __group = new char[__grouping.length() + 1];\n-      __grouping.copy(__group, __grouping.length());\n-      __group[__grouping.length()] = char();\n-      _M_grouping = __group;\n-      \n-      _M_use_grouping = __grouping.length() != 0 && __grouping.data()[0] != 0;\n \n-      typedef basic_string<_CharT> __string_type;\n+      const string::size_type __len = __np.grouping().size();\n+      char* __grouping = new char[__len + 1];\n+      __np.grouping().copy(__grouping, __len);\n+      __grouping[__len] = char();\n+      _M_grouping = __grouping;\n+      _M_use_grouping = __len && __np.grouping()[0] != 0;\n \n-      __string_type __true = __np.truename();\n-      _CharT* __truename = new _CharT[__true.length() + 1];\n-      __true.copy(__truename, __true.length());\n-      __truename[__true.length()] = _CharT(); \n+      typedef basic_string<_CharT> __string_type;\n+      typename __string_type::size_type __lentf = __np.truename().size();\n+      _CharT* __truename = new _CharT[__lentf + 1];\n+      __np.truename().copy(__truename, __lentf);\n+      __truename[__lentf] = _CharT();\n       _M_truename = __truename;\n-\n-      __string_type __false = __np.falsename();\n-      _CharT* __falsename = new _CharT[__false.length() + 1];\n-      __false.copy(__falsename, __false.length());\n-      __falsename[__false.length()] = _CharT(); \n+      \n+      __lentf = __np.falsename().size();\n+      _CharT* __falsename = new _CharT[__lentf + 1];\n+      __np.falsename().copy(__falsename, __lentf);\n+      __falsename[__lentf] = _CharT();\n       _M_falsename = __falsename;\n-            \n+          \n       _M_decimal_point = __np.decimal_point();\n       _M_thousands_sep = __np.thousands_sep();\n-\n+      \n       const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);\n       __ct.widen(__num_base::_S_atoms_out, \n \t\t __num_base::_S_atoms_out + __num_base::_S_oend, _M_atoms_out);\n       _M_atoms_out[__num_base::_S_oend] = _CharT();\n       __ct.widen(__num_base::_S_atoms_in, \n \t\t __num_base::_S_atoms_in + __num_base::_S_iend, _M_atoms_in);\n       _M_atoms_in[__num_base::_S_iend] = _CharT();\n-\n-      _M_allocated = true;\n     }\n \n   template<typename _CharT>"}, {"sha": "43e09e39a781da46b5ff431a759206973c0c015a", "filename": "libstdc++-v3/testsuite/performance/wchar_t_in.cc", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8797ae81937ef87756d24c2420e1f474ac0cd8/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fwchar_t_in.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8797ae81937ef87756d24c2420e1f474ac0cd8/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fwchar_t_in.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2Fwchar_t_in.cc?ref=3c8797ae81937ef87756d24c2420e1f474ac0cd8", "patch": "@@ -0,0 +1,84 @@\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <cstdio>\n+#include <cstring>\n+#include <fstream>\n+#include <langinfo.h>\n+#include <iconv.h>\n+#include <testsuite_performance.h>\n+\n+// libstdc++/11602 (do_in)\n+int main(int argc, char** argv)\n+{\n+  using namespace std;\n+  using namespace __gnu_test;\n+\n+  time_counter time;\n+  resource_counter resource;\n+  const int iters = 400000;\n+\n+  wchar_t wbuf[1024];\n+  char cbuf[1024];\n+  \n+  memset(cbuf, 'a', 1024);\n+\n+  // C (iconv)\n+  iconv_t cd = iconv_open(\"WCHAR_T\", nl_langinfo(CODESET));\n+  start_counters(time, resource);\n+  for (int i = 0; i < iters; ++i)\n+    {\n+      size_t inbytesleft = 1024;\n+      size_t outbytesleft = 1024 * sizeof(wchar_t);\n+      char* in = cbuf;\n+      char* out = reinterpret_cast<char*>(wbuf);\n+      iconv(cd, &in, &inbytesleft, &out, &outbytesleft);\n+    }\n+  stop_counters(time, resource);\n+  iconv_close(cd);\n+  report_performance(__FILE__, \"C (iconv)\", time, resource);\n+  clear_counters(time, resource);\n+\n+  // C++ (codecvt)\n+  locale loc;\n+  const codecvt<wchar_t, char, mbstate_t>& cvt =\n+    use_facet<codecvt<wchar_t, char, mbstate_t> >(loc);\n+  mbstate_t state;\n+  memset(&state, 0, sizeof(state));\n+  start_counters(time, resource);\n+  for (int i = 0; i < iters; ++i)\n+    {\n+      const char* from_next;\n+      wchar_t* to_next;\n+      cvt.in(state, cbuf, cbuf + 1024, from_next,\n+\t     wbuf, wbuf + 1024, to_next);\n+    }\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"C++ (codecvt)\", time, resource);\n+\n+  return 0;\n+}"}]}