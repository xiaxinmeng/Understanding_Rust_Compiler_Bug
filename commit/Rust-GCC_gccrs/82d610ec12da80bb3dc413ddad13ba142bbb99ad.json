{"sha": "82d610ec12da80bb3dc413ddad13ba142bbb99ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODJkNjEwZWMxMmRhODBiYjNkYzQxM2RkYWQxM2JhMTQyYmJiOTlhZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2003-07-07T07:25:36Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2003-07-07T07:25:36Z"}, "message": "re PR rtl-optimization/11198 (-O2 -frename-registers generates wrong code)\n\n\tPR optimization/11198\n\t* alias.c (objects_must_conflict_p): Return 1 if the types have\n\tthe same alias set, not if the alias sets only conflict.\n\nCo-Authored-By: Eric Botcazou <ebotcazou@libertysurf.fr>\n\nFrom-SVN: r69034", "tree": {"sha": "5fff45cca9b698baed174e43aec9e69d95e5845a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5fff45cca9b698baed174e43aec9e69d95e5845a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82d610ec12da80bb3dc413ddad13ba142bbb99ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82d610ec12da80bb3dc413ddad13ba142bbb99ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82d610ec12da80bb3dc413ddad13ba142bbb99ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82d610ec12da80bb3dc413ddad13ba142bbb99ad/comments", "author": null, "committer": null, "parents": [{"sha": "5fc521ac46f693a6322389f7e24927e59e947ab6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fc521ac46f693a6322389f7e24927e59e947ab6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fc521ac46f693a6322389f7e24927e59e947ab6"}], "stats": {"total": 165, "additions": 157, "deletions": 8}, "files": [{"sha": "5ba3038c068d6909cfb70a6fdf863febaed2ca9e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d610ec12da80bb3dc413ddad13ba142bbb99ad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d610ec12da80bb3dc413ddad13ba142bbb99ad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=82d610ec12da80bb3dc413ddad13ba142bbb99ad", "patch": "@@ -1,3 +1,10 @@\n+2003-07-07  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+            Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\tPR optimization/11198\n+\t* alias.c (objects_must_conflict_p): Return 1 if the types have\n+\tthe same alias set, not if the alias sets only conflict.\n+\n 2003-07-07  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \t* cppcharset.c (ICONV_CONST): Define iff !HAVE_ICONV."}, {"sha": "2617c8b5e710beb57f53c352f4f5061575c13a04", "filename": "gcc/alias.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d610ec12da80bb3dc413ddad13ba142bbb99ad/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d610ec12da80bb3dc413ddad13ba142bbb99ad/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=82d610ec12da80bb3dc413ddad13ba142bbb99ad", "patch": "@@ -317,6 +317,8 @@ readonly_fields_p (tree type)\n int\n objects_must_conflict_p (tree t1, tree t2)\n {\n+  HOST_WIDE_INT set1, set2;\n+\n   /* If neither has a type specified, we don't know if they'll conflict\n      because we may be using them to store objects of various types, for\n      example the argument and local variables areas of inlined functions.  */\n@@ -337,15 +339,15 @@ objects_must_conflict_p (tree t1, tree t2)\n       || (t1 != 0 && TYPE_VOLATILE (t1) && t2 != 0 && TYPE_VOLATILE (t2)))\n     return 1;\n \n-  /* If one is aggregate and the other is scalar then they may not\n-     conflict.  */\n-  if ((t1 != 0 && AGGREGATE_TYPE_P (t1))\n-      != (t2 != 0 && AGGREGATE_TYPE_P (t2)))\n-    return 0;\n+  set1 = t1 ? get_alias_set (t1) : 0;\n+  set2 = t2 ? get_alias_set (t2) : 0;\n \n-  /* Otherwise they conflict only if the alias sets conflict.  */\n-  return alias_sets_conflict_p (t1 ? get_alias_set (t1) : 0,\n-\t\t\t\tt2 ? get_alias_set (t2) : 0);\n+  /* Otherwise they conflict if they have no alias set or the same. We\n+     can't simply use alias_sets_conflict_p here, because we must make\n+     sure that every subtype of t1 will conflict with every subtype of\n+     t2 for which a pair of subobjects of these respective subtypes\n+     overlaps on the stack.  */\n+  return set1 == 0 || set2 == 0 || set1 == set2;\n }\n \f\n /* T is an expression with pointer type.  Find the DECL on which this"}, {"sha": "683cb294952b3167fe4b279c523eb54638d35f5c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d610ec12da80bb3dc413ddad13ba142bbb99ad/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d610ec12da80bb3dc413ddad13ba142bbb99ad/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=82d610ec12da80bb3dc413ddad13ba142bbb99ad", "patch": "@@ -1,3 +1,8 @@\n+2003-07-07  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+            Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\t* g++.dg/opt/stack1.C: New test.\n+\n 2003-07-05  Mark Mitchell  <mark@codesourcery.com>\n \n \t* g++.old-deja/g++.jason/typeid1.C: Make it a compile test, not a"}, {"sha": "bb6159c568e992da387c45c955ee2b60d78d613c", "filename": "gcc/testsuite/g++.dg/opt/stack1.C", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d610ec12da80bb3dc413ddad13ba142bbb99ad/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fstack1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d610ec12da80bb3dc413ddad13ba142bbb99ad/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fstack1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fstack1.C?ref=82d610ec12da80bb3dc413ddad13ba142bbb99ad", "patch": "@@ -0,0 +1,135 @@\n+// PR optimization/11198\n+// Origin: Joerg Walter <jhr.walter@t-online.de>\n+// Reduced testcase by: Volker Reichelt <reichelt@igpm.rwth-aachen.de>\n+//                      Wolfgang Bangerth <bangerth@ticam.utexas.edu>\n+\n+// The compiler used to allocate the same stack slot for two aggregates,\n+// overlooking that assignments to members given the same address on the\n+// stack may not alias and thus may be reordered by the scheduling passes.\n+\n+// { dg-do run }\n+// { dg-options \"-O2 -frename-registers\" }\n+\n+\n+double zero_;\n+\n+inline const int&\n+min(const int& a, const int& b) {\n+  if (b < a) return b; return a;\n+}\n+\n+struct barrier { barrier () {} };\n+\n+template <typename=void> struct unbounded_array {\n+    inline unbounded_array (): data_ (new double [9]) {}\n+    inline double& operator [] (int i) { return data_ [i]; }\n+    double* data_;\n+};\n+\n+inline int element (int i, int j) {\n+  return i + j;\n+}\n+\n+template <typename=void>\n+struct matrix {\n+    inline matrix () : size2_ (3) {}\n+\n+    inline unbounded_array<> &data () { return data_; }\n+\n+    inline double& el (int i, int j) {\n+      int dead1 = j;\n+      int dead2 = 1 + i - j;\n+      if (j < size2_ && i-j < 2)\n+\treturn data () [element (j,i-j+1)];\n+      barrier ();\n+      return zero_;\n+    }\n+\n+    struct iterator2;\n+\n+    inline iterator2 find () {\n+      return iterator2 (*this);\n+    }\n+\n+    struct iterator1 {\n+        inline iterator1 (matrix *m):\n+\t\t\tdead1 (m), i (0) {}\n+\tvoid *dead1;\n+        int i;\n+        int dead2;\n+    };\n+\n+    const int size2_;\n+    unbounded_array<> data_;\n+};\n+\n+\n+template<typename=void>\n+struct adaptor {\n+    adaptor (matrix<> &m) : m(&m), upper_ (1) {}\n+\n+    int size1 () const     { return m->size1 (); }\n+    int size2 () const     { return 3; }\n+    int lower () const     { return 1; }\n+    int upper () const     { return upper_; }\n+    matrix<> &data () { return *m; }\n+\n+    double& el (int i, int j) {\n+      int dead1, dead2;\n+      if (j < size2 () && i-j < 1)\n+\treturn data ().el (i, j);\n+\n+      barrier ();\n+      return zero_;\n+    }\n+\n+    struct a_iterator2;\n+\n+    struct a_iterator1 {\n+        a_iterator1 (adaptor &a, const matrix<>::iterator1 &it1):\n+\t\t\ta (&a), dead1 (it1) {}\n+\n+        a_iterator2 begin () const {\n+\t  return a_iterator2(*a);\n+        }\n+\tadaptor *a;\t\n+        matrix<>::iterator1 dead1;\n+    };\n+\n+    struct a_iterator2 {\n+        a_iterator2 (adaptor &a) : a (&a) {}\n+\n+        double& f () const {\n+\t  int i = 0;\n+\t  int l = a->upper () + i;\n+\t  int q = a->size2 ();\n+\t  if (0 < q &&\n+\t      l < a->lower () + 1 + a->upper ())\n+\t    return a->m->el(0,0);\n+\n+\t  return a->el (i, 0);\n+        }\n+\n+\tadaptor *a;\n+    };\n+\n+    matrix<> *m;\n+    int upper_;\n+};\n+\n+void matrix_swap (adaptor<> &bam1, adaptor<> &bam2)\n+{\n+  adaptor<>::a_iterator1 it1 (bam1,matrix<>::iterator1(bam1.m)),\n+                         it2 (bam2,matrix<>::iterator1(bam2.m));\n+  int dead;\n+  double x = it1.begin().f();\n+  it2.begin().f() = x;\n+}\n+\n+int main ()\n+{\n+  matrix<> m1,m2;\n+  adaptor<> bam1 (m1), bam2 (m2);\n+  matrix_swap (bam1, bam2);\n+  return 0;\n+}"}]}