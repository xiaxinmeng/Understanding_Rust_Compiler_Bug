{"sha": "b1c2b51b6662adebbc37c6590d697e9fe3439076", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjFjMmI1MWI2NjYyYWRlYmJjMzdjNjU5MGQ2OTdlOWZlMzQzOTA3Ng==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2012-11-28T01:42:25Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2012-11-28T01:42:25Z"}, "message": "functional (_Mem_fn): Constrain function call operators to avoid ambiguities.\n\n\t* include/std/functional (_Mem_fn): Constrain function call operators\n\tto avoid ambiguities. Use perfect forwarding.\n\t* testsuite/20_util/function_objects/mem_fn/55463.cc: Additional\n\ttests.\n\t* testsuite/20_util/function_objects/mem_fn/forward.cc: New.\n\t* testsuite/20_util/bind/ref_neg.cc: Adjust dg-error line numbers.\n\nFrom-SVN: r193879", "tree": {"sha": "85df2595035418bf7e5213ee9c7120e2805366ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85df2595035418bf7e5213ee9c7120e2805366ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1c2b51b6662adebbc37c6590d697e9fe3439076", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1c2b51b6662adebbc37c6590d697e9fe3439076", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1c2b51b6662adebbc37c6590d697e9fe3439076", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1c2b51b6662adebbc37c6590d697e9fe3439076/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69bccd4a3354d05b834a15b6069c7c522620baec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69bccd4a3354d05b834a15b6069c7c522620baec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69bccd4a3354d05b834a15b6069c7c522620baec"}], "stats": {"total": 398, "additions": 312, "deletions": 86}, "files": [{"sha": "ac1e7cbd602bd7301469f459d6b14f4d7aa385c3", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1c2b51b6662adebbc37c6590d697e9fe3439076/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1c2b51b6662adebbc37c6590d697e9fe3439076/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b1c2b51b6662adebbc37c6590d697e9fe3439076", "patch": "@@ -1,3 +1,12 @@\n+2012-11-28  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\t* include/std/functional (_Mem_fn): Constrain function call operators\n+\tto avoid ambiguities. Use perfect forwarding.\n+\t* testsuite/20_util/function_objects/mem_fn/55463.cc: Additional\n+\ttests.\n+\t* testsuite/20_util/function_objects/mem_fn/forward.cc: New.\n+\t* testsuite/20_util/bind/ref_neg.cc: Adjust dg-error line numbers.\n+\n 2012-11-27  Ollie Wild  <aaw@google.com>\n \n \t* include/bits/stl_tree.h (@headername): Fix incorrect Doxygen macro"}, {"sha": "604481b20c429a561d4fad8f8d389aee90a69c76", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 201, "deletions": 76, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1c2b51b6662adebbc37c6590d697e9fe3439076/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1c2b51b6662adebbc37c6590d697e9fe3439076/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=b1c2b51b6662adebbc37c6590d697e9fe3439076", "patch": "@@ -501,6 +501,26 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \n   // @} group functors\n \n+  template<typename... _Cond>\n+    using _Require = typename enable_if<__and_<_Cond...>::value>::type;\n+\n+  template<typename... _Types>\n+    struct _Pack : integral_constant<size_t, sizeof...(_Types)>\n+    { };\n+\n+  template<typename _From, typename _To, bool = _From::value == _To::value>\n+    struct _AllConvertible : false_type\n+    { };\n+\n+  template<typename... _From, typename... _To>\n+    struct _AllConvertible<_Pack<_From...>, _Pack<_To...>, true>\n+    : __and_<is_convertible<_From, _To>...>\n+    { };\n+\n+  template<typename _Tp1, typename _Tp2>\n+    using _NotSame = __not_<is_same<typename std::decay<_Tp1>::type,\n+\t\t\t\t    typename std::decay<_Tp2>::type>>;\n+\n   /**\n    * Derives from @c unary_function or @c binary_function, or perhaps\n    * nothing, depending on the number of arguments provided. The\n@@ -526,48 +546,78 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     {\n       typedef _Res (_Class::*_Functor)(_ArgTypes...);\n \n-      template<typename _Tp>\n+      template<typename _Tp, typename... _Args>\n \t_Res\n \t_M_call(_Tp&& __object, const volatile _Class *,\n-\t\t_ArgTypes... __args) const\n+\t\t_Args&&... __args) const\n \t{\n \t  return (std::forward<_Tp>(__object).*__pmf)\n-\t    (std::forward<_ArgTypes>(__args)...);\n+\t    (std::forward<_Args>(__args)...);\n \t}\n \n-      template<typename _Tp>\n+      template<typename _Tp, typename... _Args>\n \t_Res\n-\t_M_call(_Tp&& __ptr, const volatile void *, _ArgTypes... __args) const\n-\t{ return ((*__ptr).*__pmf)(std::forward<_ArgTypes>(__args)...); }\n+\t_M_call(_Tp&& __ptr, const volatile void *, _Args&&... __args) const\n+\t{ return ((*__ptr).*__pmf)(std::forward<_Args>(__args)...); }\n+\n+      // Require each _Args to be convertible to corresponding _ArgTypes\n+      template<typename... _Args>\n+\tusing _RequireValidArgs\n+\t  = _Require<_AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;\n+\n+      // Require each _Args to be convertible to corresponding _ArgTypes\n+      // and require _Tp is not _Class, _Class& or _Class*\n+      template<typename _Tp, typename... _Args>\n+\tusing _RequireValidArgs2\n+\t  = _Require<_NotSame<_Class, _Tp>, _NotSame<_Class*, _Tp>,\n+\t\t     _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;\n+\n+      // Require each _Args to be convertible to corresponding _ArgTypes\n+      // and require _Tp is _Class or derived from _Class\n+      template<typename _Tp, typename... _Args>\n+\tusing _RequireValidArgs3\n+\t  = _Require<is_base_of<_Class, _Tp>,\n+\t\t     _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;\n \n     public:\n       typedef _Res result_type;\n \n       explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n \n       // Handle objects\n-      _Res\n-      operator()(_Class& __object, _ArgTypes... __args) const\n-      { return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }\n+      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>\n+\t_Res\n+\toperator()(_Class& __object, _Args&&... __args) const\n+\t{ return (__object.*__pmf)(std::forward<_Args>(__args)...); }\n+\n+      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>\n+\t_Res\n+\toperator()(_Class&& __object, _Args&&... __args) const\n+\t{\n+\t  return (std::move(__object).*__pmf)(std::forward<_Args>(__args)...);\n+\t}\n \n       // Handle pointers\n-      _Res\n-      operator()(_Class* __object, _ArgTypes... __args) const\n-      { return (__object->*__pmf)(std::forward<_ArgTypes>(__args)...); }\n+      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>\n+\t_Res\n+\toperator()(_Class* __object, _Args&&... __args) const\n+\t{ return (__object->*__pmf)(std::forward<_Args>(__args)...); }\n \n       // Handle smart pointers, references and pointers to derived\n-      template<typename _Tp>\n+      template<typename _Tp, typename... _Args,\n+\t       typename _Req = _RequireValidArgs2<_Tp, _Args...>>\n \t_Res\n-\toperator()(_Tp&& __object, _ArgTypes... __args) const\n+\toperator()(_Tp&& __object, _Args&&... __args) const\n \t{\n \t  return _M_call(std::forward<_Tp>(__object), &__object,\n-\t      std::forward<_ArgTypes>(__args)...);\n+\t      std::forward<_Args>(__args)...);\n \t}\n \n-      template<typename _Tp>\n+      template<typename _Tp, typename... _Args,\n+\t       typename _Req = _RequireValidArgs3<_Tp, _Args...>>\n \t_Res\n-\toperator()(reference_wrapper<_Tp> __ref, _ArgTypes... __args) const\n-\t{ return operator()(__ref.get(), std::forward<_ArgTypes>(__args)...); }\n+\toperator()(reference_wrapper<_Tp> __ref, _Args&&... __args) const\n+\t{ return operator()(__ref.get(), std::forward<_Args>(__args)...); }\n \n     private:\n       _Functor __pmf;\n@@ -581,47 +631,72 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     {\n       typedef _Res (_Class::*_Functor)(_ArgTypes...) const;\n \n-      template<typename _Tp>\n+      template<typename _Tp, typename... _Args>\n \t_Res\n \t_M_call(_Tp&& __object, const volatile _Class *,\n-\t\t_ArgTypes... __args) const\n+\t\t_Args&&... __args) const\n \t{\n \t  return (std::forward<_Tp>(__object).*__pmf)\n-\t    (std::forward<_ArgTypes>(__args)...);\n+\t    (std::forward<_Args>(__args)...);\n \t}\n \n-      template<typename _Tp>\n+      template<typename _Tp, typename... _Args>\n \t_Res\n-\t_M_call(_Tp&& __ptr, const volatile void *, _ArgTypes... __args) const\n-\t{ return ((*__ptr).*__pmf)(std::forward<_ArgTypes>(__args)...); }\n+\t_M_call(_Tp&& __ptr, const volatile void *, _Args&&... __args) const\n+\t{ return ((*__ptr).*__pmf)(std::forward<_Args>(__args)...); }\n+\n+      template<typename... _Args>\n+\tusing _RequireValidArgs\n+\t  = _Require<_AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;\n+\n+      template<typename _Tp, typename... _Args>\n+\tusing _RequireValidArgs2\n+\t  = _Require<_NotSame<_Class, _Tp>, _NotSame<_Class*, _Tp>,\n+\t\t     _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;\n+\n+      template<typename _Tp, typename... _Args>\n+\tusing _RequireValidArgs3\n+\t  = _Require<is_base_of<_Class, _Tp>,\n+\t\t     _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;\n \n     public:\n       typedef _Res result_type;\n \n       explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n \n       // Handle objects\n-      _Res\n-      operator()(const _Class& __object, _ArgTypes... __args) const\n-      { return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }\n+      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>\n+\t_Res\n+\toperator()(const _Class& __object, _Args&&... __args) const\n+\t{ return (__object.*__pmf)(std::forward<_Args>(__args)...); }\n+\n+      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>\n+\t_Res\n+\toperator()(const _Class&& __object, _Args&&... __args) const\n+\t{\n+\t  return (std::move(__object).*__pmf)(std::forward<_Args>(__args)...);\n+\t}\n \n       // Handle pointers\n-      _Res\n-      operator()(const _Class* __object, _ArgTypes... __args) const\n-      { return (__object->*__pmf)(std::forward<_ArgTypes>(__args)...); }\n+      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>\n+\t_Res\n+\toperator()(const _Class* __object, _Args&&... __args) const\n+\t{ return (__object->*__pmf)(std::forward<_Args>(__args)...); }\n \n       // Handle smart pointers, references and pointers to derived\n-      template<typename _Tp>\n-\t_Res operator()(_Tp&& __object, _ArgTypes... __args) const\n+      template<typename _Tp, typename... _Args,\n+\t       typename _Req = _RequireValidArgs2<_Tp, _Args...>>\n+\t_Res operator()(_Tp&& __object, _Args&&... __args) const\n \t{\n \t  return _M_call(std::forward<_Tp>(__object), &__object,\n-\t      std::forward<_ArgTypes>(__args)...);\n+\t      std::forward<_Args>(__args)...);\n \t}\n \n-      template<typename _Tp>\n+      template<typename _Tp, typename... _Args,\n+\t       typename _Req = _RequireValidArgs3<_Tp, _Args...>>\n \t_Res\n-\toperator()(reference_wrapper<_Tp> __ref, _ArgTypes... __args) const\n-\t{ return operator()(__ref.get(), std::forward<_ArgTypes>(__args)...); }\n+\toperator()(reference_wrapper<_Tp> __ref, _Args&&... __args) const\n+\t{ return operator()(__ref.get(), std::forward<_Args>(__args)...); }\n \n     private:\n       _Functor __pmf;\n@@ -635,48 +710,73 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     {\n       typedef _Res (_Class::*_Functor)(_ArgTypes...) volatile;\n \n-      template<typename _Tp>\n+      template<typename _Tp, typename... _Args>\n \t_Res\n \t_M_call(_Tp&& __object, const volatile _Class *,\n-\t\t_ArgTypes... __args) const\n+\t\t_Args&&... __args) const\n \t{\n \t  return (std::forward<_Tp>(__object).*__pmf)\n-\t    (std::forward<_ArgTypes>(__args)...);\n+\t    (std::forward<_Args>(__args)...);\n \t}\n \n-      template<typename _Tp>\n+      template<typename _Tp, typename... _Args>\n \t_Res\n-\t_M_call(_Tp&& __ptr, const volatile void *, _ArgTypes... __args) const\n-\t{ return ((*__ptr).*__pmf)(std::forward<_ArgTypes>(__args)...); }\n+\t_M_call(_Tp&& __ptr, const volatile void *, _Args&&... __args) const\n+\t{ return ((*__ptr).*__pmf)(std::forward<_Args>(__args)...); }\n+\n+      template<typename... _Args>\n+\tusing _RequireValidArgs\n+\t  = _Require<_AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;\n+\n+      template<typename _Tp, typename... _Args>\n+\tusing _RequireValidArgs2\n+\t  = _Require<_NotSame<_Class, _Tp>, _NotSame<_Class*, _Tp>,\n+\t\t     _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;\n+\n+      template<typename _Tp, typename... _Args>\n+\tusing _RequireValidArgs3\n+\t  = _Require<is_base_of<_Class, _Tp>,\n+\t\t     _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;\n \n     public:\n       typedef _Res result_type;\n \n       explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n \n       // Handle objects\n-      _Res\n-      operator()(volatile _Class& __object, _ArgTypes... __args) const\n-      { return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }\n+      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>\n+\t_Res\n+\toperator()(volatile _Class& __object, _Args&&... __args) const\n+\t{ return (__object.*__pmf)(std::forward<_Args>(__args)...); }\n+\n+      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>\n+\t_Res\n+\toperator()(volatile _Class&& __object, _Args&&... __args) const\n+\t{\n+\t  return (std::move(__object).*__pmf)(std::forward<_Args>(__args)...);\n+\t}\n \n       // Handle pointers\n-      _Res\n-      operator()(volatile _Class* __object, _ArgTypes... __args) const\n-      { return (__object->*__pmf)(std::forward<_ArgTypes>(__args)...); }\n+      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>\n+\t_Res\n+\toperator()(volatile _Class* __object, _Args&&... __args) const\n+\t{ return (__object->*__pmf)(std::forward<_Args>(__args)...); }\n \n       // Handle smart pointers, references and pointers to derived\n-      template<typename _Tp>\n+      template<typename _Tp, typename... _Args,\n+\t       typename _Req = _RequireValidArgs2<_Tp, _Args...>>\n \t_Res\n-\toperator()(_Tp&& __object, _ArgTypes... __args) const\n+\toperator()(_Tp&& __object, _Args&&... __args) const\n \t{\n \t  return _M_call(std::forward<_Tp>(__object), &__object,\n-\t      std::forward<_ArgTypes>(__args)...);\n+\t      std::forward<_Args>(__args)...);\n \t}\n \n-      template<typename _Tp>\n+      template<typename _Tp, typename... _Args,\n+\t       typename _Req = _RequireValidArgs3<_Tp, _Args...>>\n \t_Res\n-\toperator()(reference_wrapper<_Tp> __ref, _ArgTypes... __args) const\n-\t{ return operator()(__ref.get(), std::forward<_ArgTypes>(__args)...); }\n+\toperator()(reference_wrapper<_Tp> __ref, _Args&&... __args) const\n+\t{ return operator()(__ref.get(), std::forward<_Args>(__args)...); }\n \n     private:\n       _Functor __pmf;\n@@ -690,47 +790,72 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     {\n       typedef _Res (_Class::*_Functor)(_ArgTypes...) const volatile;\n \n-      template<typename _Tp>\n+      template<typename _Tp, typename... _Args>\n \t_Res\n \t_M_call(_Tp&& __object, const volatile _Class *,\n-\t\t_ArgTypes... __args) const\n+\t\t_Args&&... __args) const\n \t{\n \t  return (std::forward<_Tp>(__object).*__pmf)\n-\t    (std::forward<_ArgTypes>(__args)...);\n+\t    (std::forward<_Args>(__args)...);\n \t}\n \n-      template<typename _Tp>\n+      template<typename _Tp, typename... _Args>\n \t_Res\n-\t_M_call(_Tp&& __ptr, const volatile void *, _ArgTypes... __args) const\n-\t{ return ((*__ptr).*__pmf)(std::forward<_ArgTypes>(__args)...); }\n+\t_M_call(_Tp&& __ptr, const volatile void *, _Args&&... __args) const\n+\t{ return ((*__ptr).*__pmf)(std::forward<_Args>(__args)...); }\n+\n+      template<typename... _Args>\n+\tusing _RequireValidArgs\n+\t  = _Require<_AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;\n+\n+      template<typename _Tp, typename... _Args>\n+\tusing _RequireValidArgs2\n+\t  = _Require<_NotSame<_Class, _Tp>, _NotSame<_Class*, _Tp>,\n+\t\t     _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;\n+\n+      template<typename _Tp, typename... _Args>\n+\tusing _RequireValidArgs3\n+\t  = _Require<is_base_of<_Class, _Tp>,\n+\t\t     _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;\n \n     public:\n       typedef _Res result_type;\n \n       explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n \n       // Handle objects\n-      _Res\n-      operator()(const volatile _Class& __object, _ArgTypes... __args) const\n-      { return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }\n+      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>\n+\t_Res\n+\toperator()(const volatile _Class& __object, _Args&&... __args) const\n+\t{ return (__object.*__pmf)(std::forward<_Args>(__args)...); }\n+\n+      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>\n+\t_Res\n+\toperator()(const volatile _Class&& __object, _Args&&... __args) const\n+\t{\n+\t  return (std::move(__object).*__pmf)(std::forward<_Args>(__args)...);\n+\t}\n \n       // Handle pointers\n-      _Res\n-      operator()(const volatile _Class* __object, _ArgTypes... __args) const\n-      { return (__object->*__pmf)(std::forward<_ArgTypes>(__args)...); }\n+      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>\n+\t_Res\n+\toperator()(const volatile _Class* __object, _Args&&... __args) const\n+\t{ return (__object->*__pmf)(std::forward<_Args>(__args)...); }\n \n       // Handle smart pointers, references and pointers to derived\n-      template<typename _Tp>\n-\t_Res operator()(_Tp&& __object, _ArgTypes... __args) const\n+      template<typename _Tp, typename... _Args,\n+\t       typename _Req = _RequireValidArgs2<_Tp, _Args...>>\n+\t_Res operator()(_Tp&& __object, _Args&&... __args) const\n \t{\n \t  return _M_call(std::forward<_Tp>(__object), &__object,\n-\t      std::forward<_ArgTypes>(__args)...);\n+\t      std::forward<_Args>(__args)...);\n \t}\n \n-      template<typename _Tp>\n+      template<typename _Tp, typename... _Args,\n+\t       typename _Req = _RequireValidArgs3<_Tp, _Args...>>\n \t_Res\n-\toperator()(reference_wrapper<_Tp> __ref, _ArgTypes... __args) const\n-\t{ return operator()(__ref.get(), std::forward<_ArgTypes>(__args)...); }\n+\toperator()(reference_wrapper<_Tp> __ref, _Args&&... __args) const\n+\t{ return operator()(__ref.get(), std::forward<_Args>(__args)...); }\n \n     private:\n       _Functor __pmf;\n@@ -756,7 +881,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \n       // This bit of genius is due to Peter Dimov, improved slightly by\n       // Douglas Gregor.\n-      // Made less elegant by Jonathan Wakely to support perfect forwarding.\n+      // Made less elegant to support perfect forwarding and noexcept.\n       template<typename _Tp>\n \tauto\n \t_M_call(_Tp&& __object, const _Class *) const noexcept\n@@ -807,20 +932,20 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n       { return __object->*__pm; }\n \n       // Handle smart pointers and derived\n-      template<typename _Tp>\n+      template<typename _Tp, typename _Req = _Require<_NotSame<_Class*, _Tp>>>\n \tauto\n \toperator()(_Tp&& __unknown) const\n \tnoexcept(noexcept(std::declval<_Mem_fn*>()->_M_call\n \t\t\t  (std::forward<_Tp>(__unknown), &__unknown)))\n \t-> decltype(this->_M_call(std::forward<_Tp>(__unknown), &__unknown))\n \t{ return _M_call(std::forward<_Tp>(__unknown), &__unknown); }\n \n-      template<typename _Tp>\n+      template<typename _Tp, typename _Req = _Require<is_base_of<_Class, _Tp>>>\n \tauto\n \toperator()(reference_wrapper<_Tp> __ref) const\n \tnoexcept(noexcept(std::declval<_Mem_fn&>()(__ref.get())))\n \t-> decltype((*this)(__ref.get()))\n-\t{ return operator()(__ref.get()); }\n+\t{ return (*this)(__ref.get()); }\n \n     private:\n       _Res _Class::*__pm;"}, {"sha": "bae0a861d219f1f3c6d34de9b65deb9302ec9eb5", "filename": "libstdc++-v3/testsuite/20_util/bind/ref_neg.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1c2b51b6662adebbc37c6590d697e9fe3439076/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fref_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1c2b51b6662adebbc37c6590d697e9fe3439076/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fref_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fref_neg.cc?ref=b1c2b51b6662adebbc37c6590d697e9fe3439076", "patch": "@@ -30,10 +30,10 @@ void test01()\n {\n   const int dummy = 0;\n   std::bind(&inc, _1)(0);               // { dg-error  \"no match\" }\n-  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1224 }\n-  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1238 }\n-  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1252 }\n-  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1266 }\n+  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1349 }\n+  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1363 }\n+  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1377 }\n+  // { dg-error \"rvalue|const\" \"\" { target *-*-* } 1391 }\n   std::bind(&inc, std::ref(dummy))();\t// { dg-error  \"no match\" }\n }\n "}, {"sha": "ac11852bc0bd15d64ff2847a310af1ba1cb2a1f5", "filename": "libstdc++-v3/testsuite/20_util/function_objects/mem_fn/55463.cc", "status": "modified", "additions": 36, "deletions": 6, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1c2b51b6662adebbc37c6590d697e9fe3439076/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Fmem_fn%2F55463.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1c2b51b6662adebbc37c6590d697e9fe3439076/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Fmem_fn%2F55463.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Fmem_fn%2F55463.cc?ref=b1c2b51b6662adebbc37c6590d697e9fe3439076", "patch": "@@ -32,7 +32,12 @@ struct X\n   int data;\n };\n \n+struct Y : X { };\n+\n using CX = const X;\n+using CY = const Y;\n+\n+using X_ptr = X*;\n \n struct smart_ptr\n {\n@@ -41,38 +46,63 @@ struct smart_ptr\n \n std::reference_wrapper<X> ref();\n std::reference_wrapper<const X> cref();\n+std::reference_wrapper<Y> yref();\n \n void test01()\n {\n   int& i1 = std::mem_fn( &X::func )( X() );\n-  int& i2 = std::mem_fn( &X::func )( smart_ptr() );\n+  int& i2 = std::mem_fn( &X::func )( Y() );\n   int& i3 = std::mem_fn( &X::func )( ref() );\n+  int& i4 = std::mem_fn( &X::func )( yref() );\n+  int& i5 = std::mem_fn( &X::func )( X_ptr() );\n+  int& i6 = std::mem_fn( &X::func )( smart_ptr() );\n \n   char& c1 = std::mem_fn( &X::func_c )( X() );\n   char& c2 = std::mem_fn( &X::func_c )( CX() );\n-  char& c3 = std::mem_fn( &X::func_c )( smart_ptr() );\n+  char& c3 = std::mem_fn( &X::func_c )( Y() );\n   char& c4 = std::mem_fn( &X::func_c )( ref() );\n   char& c5 = std::mem_fn( &X::func_c )( cref() );\n+  char& c6 = std::mem_fn( &X::func_c )( yref() );\n+  char& c7 = std::mem_fn( &X::func_c )( X_ptr() );\n+  char& c8 = std::mem_fn( &X::func_c )( smart_ptr() );\n \n   short& s1 = std::mem_fn( &X::func_v )( X() );\n-  short& s2 = std::mem_fn( &X::func_v )( smart_ptr() );\n+  short& s2 = std::mem_fn( &X::func_v )( Y() );\n   short& s3 = std::mem_fn( &X::func_v )( ref() );\n+  short& s4 = std::mem_fn( &X::func_v )( yref() );\n+  short& s5 = std::mem_fn( &X::func_v )( X_ptr() );\n+  short& s6 = std::mem_fn( &X::func_v )( smart_ptr() );\n \n   double& d1 = std::mem_fn( &X::func_cv )( X() );\n   double& d2 = std::mem_fn( &X::func_cv )( CX() );\n-  double& d3 = std::mem_fn( &X::func_cv )( smart_ptr() );\n+  double& d3 = std::mem_fn( &X::func_cv )( Y() );\n   double& d4 = std::mem_fn( &X::func_cv )( ref() );\n   double& d5 = std::mem_fn( &X::func_cv )( cref() );\n+  double& d6 = std::mem_fn( &X::func_cv )( yref() );\n+  double& d7 = std::mem_fn( &X::func_cv )( X_ptr() );\n+  double& d8 = std::mem_fn( &X::func_cv )( smart_ptr() );\n \n   // [expr.mptr.oper]\n   // The result of a .* expression whose second operand is a pointer to a\n   // data member is of the same value category (3.10) as its first operand.\n   int&& rval = std::mem_fn( &X::data )( X() );\n   const int&& crval = std::mem_fn( &X::data )( CX() );\n-\n-  int& sval = std::mem_fn( &X::data )( smart_ptr() );\n+  int&& yrval = std::mem_fn( &X::data )( Y() );\n+  const int&& ycrval = std::mem_fn( &X::data )( CY() );\n \n   int& val = std::mem_fn( &X::data )( ref() );\n   const int& cval = std::mem_fn( &X::data )( cref() );\n+  int& yval = std::mem_fn( &X::data )( yref() );\n+\n+  int& pval = std::mem_fn( &X::data )( X_ptr() );\n+  int& sval = std::mem_fn( &X::data )( smart_ptr() );\n }\n \n+void test02()\n+{\n+  std::reference_wrapper<X> r = ref();\n+  X& x1 = std::mem_fn( &std::reference_wrapper<X>::get )( r );\n+  const std::reference_wrapper<X> cr = ref();\n+  const X& x3 = std::mem_fn( &std::reference_wrapper<X>::get )( cr );\n+  X& x2 = std::mem_fn( &std::reference_wrapper<X>::get )( ref() );\n+}"}, {"sha": "a231bf6858cc4f10b49cf142ab493d8b76176d50", "filename": "libstdc++-v3/testsuite/20_util/function_objects/mem_fn/forward.cc", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1c2b51b6662adebbc37c6590d697e9fe3439076/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Fmem_fn%2Fforward.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1c2b51b6662adebbc37c6590d697e9fe3439076/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Fmem_fn%2Fforward.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Fmem_fn%2Fforward.cc?ref=b1c2b51b6662adebbc37c6590d697e9fe3439076", "patch": "@@ -0,0 +1,62 @@\n+// { dg-options \"-std=gnu++11\" }\n+\n+// Copyright (C) 2012 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <functional>\n+#include <testsuite_hooks.h>\n+\n+struct Counter\n+{\n+  Counter() = default;\n+  Counter(const Counter&) { ++count; }\n+\n+  static int count;\n+};\n+\n+int Counter::count = 0;\n+\n+struct X\n+{\n+  int func(Counter, int i) { return i; }\n+  char func_c(Counter, char c) const { return c; }\n+  short func_v(Counter, short s) volatile { return s; }\n+  double func_cv(Counter, double d) const volatile { return d; }\n+};\n+\n+void test01()\n+{\n+  Counter c;\n+  X x;\n+\n+  std::mem_fn( &X::func )( x, c, 0 );\n+  VERIFY( Counter::count == 1 );\n+\n+  std::mem_fn( &X::func_c )( x, c, 0 );\n+  VERIFY( Counter::count == 2 );\n+\n+  std::mem_fn( &X::func_v )( x, c, 0 );\n+  VERIFY( Counter::count == 3 );\n+\n+  std::mem_fn( &X::func_cv )( x, c, 0 );\n+  VERIFY( Counter::count == 4 );\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}]}