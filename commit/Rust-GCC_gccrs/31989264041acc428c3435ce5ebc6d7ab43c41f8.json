{"sha": "31989264041acc428c3435ce5ebc6d7ab43c41f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE5ODkyNjQwNDFhY2M0MjhjMzQzNWNlNWViYzZkN2FiNDNjNDFmOA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-08-16T16:53:02Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-08-16T16:53:02Z"}, "message": "reload.c (push_secondary_reload): Revert last change.\n\n        * reload.c (push_secondary_reload): Revert last change.\n        If we use a reload_in/out pattern, make the when the same\n        as the primary reload.\n        (find_reloads): Likewise.\n\nFrom-SVN: r35746", "tree": {"sha": "d745e8d8d7254206f78963765b0b0cc49d82a1b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d745e8d8d7254206f78963765b0b0cc49d82a1b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31989264041acc428c3435ce5ebc6d7ab43c41f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31989264041acc428c3435ce5ebc6d7ab43c41f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31989264041acc428c3435ce5ebc6d7ab43c41f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31989264041acc428c3435ce5ebc6d7ab43c41f8/comments", "author": null, "committer": null, "parents": [{"sha": "d84c56344235ed958a3f4db7b3b5cfb2f4697ee9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d84c56344235ed958a3f4db7b3b5cfb2f4697ee9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d84c56344235ed958a3f4db7b3b5cfb2f4697ee9"}], "stats": {"total": 71, "additions": 47, "deletions": 24}, "files": [{"sha": "b255dbb6ee355fdf4218df686c78e8aa9bfba4de", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31989264041acc428c3435ce5ebc6d7ab43c41f8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31989264041acc428c3435ce5ebc6d7ab43c41f8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=31989264041acc428c3435ce5ebc6d7ab43c41f8", "patch": "@@ -1,3 +1,10 @@\n+2000-08-16  Richard Henderson  <rth@cygnus.com>\n+\n+\t* reload.c (push_secondary_reload): Revert last change.\n+\tIf we use a reload_in/out pattern, make the when the same\n+\tas the primary reload.\n+\t(find_reloads): Likewise.\n+\n 2000-08-16  Manfred Hollstein  <manfredh@redhat.com>\n \n \t* configure.in (libstdcxx-v3): Fix test."}, {"sha": "5593406db9a089fa6e156a9e6832d1e2ef2ea3f5", "filename": "gcc/reload.c", "status": "modified", "additions": 40, "deletions": 24, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31989264041acc428c3435ce5ebc6d7ab43c41f8/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31989264041acc428c3435ce5ebc6d7ab43c41f8/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=31989264041acc428c3435ce5ebc6d7ab43c41f8", "patch": "@@ -375,26 +375,34 @@ push_secondary_reload (in_p, x, opnum, optional, reload_class, reload_mode,\n \t in operand 1.  Outputs should have an initial \"=\", which we must\n \t skip.  */\n \n-      char insn_letter, t_letter;\n+      char insn_letter\n+\t= insn_data[(int) icode].operand[!in_p].constraint[in_p];\n+      enum reg_class insn_class\n+\t= (insn_letter == 'r' ? GENERAL_REGS\n+\t   : REG_CLASS_FROM_LETTER ((unsigned char) insn_letter));\n \n-      insn_letter = insn_data[(int) icode].operand[!in_p].constraint[in_p];\n-      class = (insn_letter == 'r' ? GENERAL_REGS\n-\t       : REG_CLASS_FROM_LETTER ((unsigned char) insn_letter));\n-\n-      if (class == NO_REGS\n+      if (insn_class == NO_REGS\n \t  || (in_p\n \t      && insn_data[(int) icode].operand[!in_p].constraint[0] != '=')\n \t  /* The scratch register's constraint must start with \"=&\".  */\n \t  || insn_data[(int) icode].operand[2].constraint[0] != '='\n \t  || insn_data[(int) icode].operand[2].constraint[1] != '&')\n \tabort ();\n \n-      t_letter = insn_data[(int) icode].operand[2].constraint[2];\n-      t_mode = insn_data[(int) icode].operand[2].mode;\n-      t_class = (t_letter == 'r' ? GENERAL_REGS\n-\t\t : REG_CLASS_FROM_LETTER ((unsigned char) t_letter));\n-      t_icode = icode;\n-      icode = CODE_FOR_nothing;\n+      if (reg_class_subset_p (reload_class, insn_class))\n+\tmode = insn_data[(int) icode].operand[2].mode;\n+      else\n+\t{\n+\t  char t_letter = insn_data[(int) icode].operand[2].constraint[2];\n+\t  class = insn_class;\n+\t  t_mode = insn_data[(int) icode].operand[2].mode;\n+\t  t_class = (t_letter == 'r' ? GENERAL_REGS\n+\t\t     : REG_CLASS_FROM_LETTER ((unsigned char) t_letter));\n+\t  t_icode = icode;\n+\t  icode = CODE_FOR_nothing;\n+\t}\n+\n+      secondary_type = in_p ? RELOAD_FOR_INPUT : RELOAD_FOR_OUTPUT;\n     }\n \n   /* This case isn't valid, so fail.  Reload is allowed to use the same\n@@ -404,14 +412,15 @@ push_secondary_reload (in_p, x, opnum, optional, reload_class, reload_mode,\n      silently generating incorrect code later.\n \n      The convention is that secondary input reloads are valid only if the\n-     secondary class is different from the reload class.  If you have such\n-     a case, you can not use secondary reloads, you must work around the\n-     problem some other way.\n+     secondary_class is different from class.  If you have such a case, you\n+     can not use secondary reloads, you must work around the problem some\n+     other way.\n \n-     Allow this when a tertiary reload is used; i.e. assume that the\n-     generated code handles this case.  */\n+     Allow this when MODE is not reload_mode and assume that the generated\n+     code handles this case (it does on the Alpha, which is the only place\n+     this currently happens).  */\n \n-  if (in_p && class == reload_class && t_class == NO_REGS)\n+  if (in_p && class == reload_class && mode == reload_mode)\n     abort ();\n \n   /* If we need a tertiary reload, see if we have one we can reuse or else\n@@ -3909,8 +3918,11 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n   for (i = 0; i < n_reloads; i++)\n     {\n       if (rld[i].secondary_p\n-\t  && rld[i].when_needed == operand_type[rld[i].opnum])\n-\trld[i].when_needed = address_type[rld[i].opnum];\n+\t  && rld[i].when_needed == operand_type[rld[i].opnum]\n+          && (operand_reloadnum[rld[i].opnum] < 0\n+\t      || (rld[operand_reloadnum[rld[i].opnum]].secondary_in_icode == -1\n+\t\t  && rld[operand_reloadnum[rld[i].opnum]].secondary_out_icode == -1)))\n+\t  rld[i].when_needed = address_type[rld[i].opnum];\n \n       if ((rld[i].when_needed == RELOAD_FOR_INPUT_ADDRESS\n \t   || rld[i].when_needed == RELOAD_FOR_OUTPUT_ADDRESS\n@@ -3929,13 +3941,15 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      int secondary_in_reload = rld[i].secondary_in_reload;\n \n \t      rld[secondary_in_reload].when_needed\n-\t\t= RELOAD_FOR_OPADDR_ADDR;\n+\t\t= (rld[i].secondary_in_icode == -1\n+\t\t   ? RELOAD_FOR_OPADDR_ADDR\n+\t\t   : RELOAD_FOR_OPERAND_ADDRESS);\n \n \t      /* If there's a tertiary reload we have to change it also.  */\n \t      if (secondary_in_reload > 0\n \t\t  && rld[secondary_in_reload].secondary_in_reload != -1)\n \t\trld[rld[secondary_in_reload].secondary_in_reload].when_needed\n-\t\t  = RELOAD_FOR_OPADDR_ADDR;\n+\t\t  = rld[secondary_in_reload].when_needed;\n \t    }\n \n \t  if ((rld[i].when_needed == RELOAD_FOR_OUTPUT_ADDRESS\n@@ -3945,13 +3959,15 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      int secondary_out_reload = rld[i].secondary_out_reload;\n \n \t      rld[secondary_out_reload].when_needed\n-\t\t= RELOAD_FOR_OPADDR_ADDR;\n+\t\t= (rld[i].secondary_out_icode == -1\n+\t\t   ? RELOAD_FOR_OPADDR_ADDR\n+\t\t   : RELOAD_FOR_OPERAND_ADDRESS);\n \n \t      /* If there's a tertiary reload we have to change it also.  */\n \t      if (secondary_out_reload\n \t\t  && rld[secondary_out_reload].secondary_out_reload != -1)\n \t\trld[rld[secondary_out_reload].secondary_out_reload].when_needed\n-\t\t  = RELOAD_FOR_OPADDR_ADDR;\n+\t\t  = rld[secondary_out_reload].when_needed;\n \t    }\n \n \t  if (rld[i].when_needed == RELOAD_FOR_INPADDR_ADDRESS"}]}