{"sha": "38a734350fd787da1b4bcf9b4e0a99ed2adb5eae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhhNzM0MzUwZmQ3ODdkYTFiNGJjZjliNGUwYTk5ZWQyYWRiNWVhZQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2019-10-03T08:08:50Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2019-10-03T08:08:50Z"}, "message": "Makefile.in (OBJS): Add range.o and range-op.o.\n\n\t* Makefile.in (OBJS): Add range.o and range-op.o.\n\tRemove wide-int-range.o.\n\t* function-tests.c (test_ranges): New.\n\t(function_tests_c_tests): Call test_ranges.\n\t* ipa-cp.c (ipa_vr_operation_and_type_effects): Call\n\trange_fold_unary_expr instead of extract_range_from_unary_expr.\n\t* ipa-prop.c (ipa_compute_jump_functions_for_edge): Same.\n\t* range-op.cc: New file.\n\t* range-op.h: New file.\n\t* range.cc: New file.\n\t* range.h: New file.\n\t* selftest.h (range_tests): New prototype.\n\t* ssa.h: Include range.h.\n\t* tree-vrp.c (value_range_base::value_range_base): New\n\tconstructors.\n\t(value_range_base::singleton_p): Do not call\n\tranges_from_anti_range until sure we will need to.\n\t(value_range_base::type): Rename gcc_assert to\n\tgcc_checking_assert.\n\t(vrp_val_is_max): New argument.\n\t(vrp_val_is_min): Same.\n\t(wide_int_range_set_zero_nonzero_bits): Move from\n\twide-int-range.cc.\n\t(extract_range_into_wide_ints): Remove.\n\t(extract_range_from_multiplicative_op): Remove.\n\t(extract_range_from_pointer_plus_expr): Abstract POINTER_PLUS code\n\tfrom extract_range_from_binary_expr.\n\t(extract_range_from_plus_minus_expr): Abstract PLUS/MINUS code\n\tfrom extract_range_from_binary_expr.\n\t(extract_range_from_binary_expr): Remove.\n\t(normalize_for_range_ops): New.\n\t(range_fold_binary_expr): New.\n\t(range_fold_unary_expr): New.\n\t(value_range_base::num_pairs): New.\n\t(value_range_base::lower_bound): New.\n\t(value_range_base::upper_bound): New.\n\t(value_range_base::upper_bound): New.\n\t(value_range_base::contains_p): New.\n\t(value_range_base::invert): New.\n\t(value_range_base::union_): New.\n\t(value_range_base::intersect): New.\n\t(range_compatible_p): New.\n\t(value_range_base::operator==): New.\n\t(determine_value_range_1): Call range_fold_*expr instead of\n\textract_range_from_*expr.\n\t* tree-vrp.h (class value_range_base): Add new constructors.\n\tAdd methods for union_, intersect, operator==, contains_p,\n\tnum_pairs, lower_bound, upper_bound, invert.\n\t(vrp_val_is_min): Add handle_pointers argument.\n\t(vrp_val_is_max): Same.\n\t(extract_range_from_unary_expr): Remove.\n\t(extract_range_from_binary_expr): Remove.\n\t(range_fold_unary_expr): New.\n\t(range_fold_binary_expr): New.\n\t* vr-values.c (vr_values::extract_range_from_binary_expr): Call\n\trange_fold_binary_expr instead of extract_range_from_binary_expr.\n\t(vr_values::extract_range_basic): Same.\n\t(vr_values::extract_range_from_unary_expr): Call\n\trange_fold_unary_expr instead of extract_range_from_unary_expr.\n\t* wide-int-range.cc: Remove.\n\t* wide-int-range.h: Remove.\n\nFrom-SVN: r276504", "tree": {"sha": "4f5d0ec3eca5f40efce5cb8725875e0f0d1cf2d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f5d0ec3eca5f40efce5cb8725875e0f0d1cf2d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38a734350fd787da1b4bcf9b4e0a99ed2adb5eae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38a734350fd787da1b4bcf9b4e0a99ed2adb5eae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38a734350fd787da1b4bcf9b4e0a99ed2adb5eae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38a734350fd787da1b4bcf9b4e0a99ed2adb5eae/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0a8c8f4d6578fac21adc0e156861c4b47bed4418", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a8c8f4d6578fac21adc0e156861c4b47bed4418", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a8c8f4d6578fac21adc0e156861c4b47bed4418"}], "stats": {"total": 5892, "additions": 4116, "deletions": 1776}, "files": [{"sha": "991949b3c1badb6dc5d57fc91bfad5b2da4ba479", "filename": "gcc/ChangeLog", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a734350fd787da1b4bcf9b4e0a99ed2adb5eae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a734350fd787da1b4bcf9b4e0a99ed2adb5eae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=38a734350fd787da1b4bcf9b4e0a99ed2adb5eae", "patch": "@@ -1,3 +1,67 @@\n+2019-10-03  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* Makefile.in (OBJS): Add range.o and range-op.o.\n+\tRemove wide-int-range.o.\n+\t* function-tests.c (test_ranges): New.\n+\t(function_tests_c_tests): Call test_ranges.\n+\t* ipa-cp.c (ipa_vr_operation_and_type_effects): Call\n+\trange_fold_unary_expr instead of extract_range_from_unary_expr.\n+\t* ipa-prop.c (ipa_compute_jump_functions_for_edge): Same.\n+\t* range-op.cc: New file.\n+\t* range-op.h: New file.\n+\t* range.cc: New file.\n+\t* range.h: New file.\n+\t* selftest.h (range_tests): New prototype.\n+\t* ssa.h: Include range.h.\n+\t* tree-vrp.c (value_range_base::value_range_base): New\n+\tconstructors.\n+\t(value_range_base::singleton_p): Do not call\n+\tranges_from_anti_range until sure we will need to.\n+\t(value_range_base::type): Rename gcc_assert to\n+\tgcc_checking_assert.\n+\t(vrp_val_is_max): New argument.\n+\t(vrp_val_is_min): Same.\n+\t(wide_int_range_set_zero_nonzero_bits): Move from\n+\twide-int-range.cc.\n+\t(extract_range_into_wide_ints): Remove.\n+\t(extract_range_from_multiplicative_op): Remove.\n+\t(extract_range_from_pointer_plus_expr): Abstract POINTER_PLUS code\n+\tfrom extract_range_from_binary_expr.\n+\t(extract_range_from_plus_minus_expr): Abstract PLUS/MINUS code\n+\tfrom extract_range_from_binary_expr.\n+\t(extract_range_from_binary_expr): Remove.\n+\t(normalize_for_range_ops): New.\n+\t(range_fold_binary_expr): New.\n+\t(range_fold_unary_expr): New.\n+\t(value_range_base::num_pairs): New.\n+\t(value_range_base::lower_bound): New.\n+\t(value_range_base::upper_bound): New.\n+\t(value_range_base::upper_bound): New.\n+\t(value_range_base::contains_p): New.\n+\t(value_range_base::invert): New.\n+\t(value_range_base::union_): New.\n+\t(value_range_base::intersect): New.\n+\t(range_compatible_p): New.\n+\t(value_range_base::operator==): New.\n+\t(determine_value_range_1): Call range_fold_*expr instead of\n+\textract_range_from_*expr.\n+\t* tree-vrp.h (class value_range_base): Add new constructors.\n+\tAdd methods for union_, intersect, operator==, contains_p,\n+\tnum_pairs, lower_bound, upper_bound, invert.\n+\t(vrp_val_is_min): Add handle_pointers argument.\n+\t(vrp_val_is_max): Same.\n+\t(extract_range_from_unary_expr): Remove.\n+\t(extract_range_from_binary_expr): Remove.\n+\t(range_fold_unary_expr): New.\n+\t(range_fold_binary_expr): New.\n+\t* vr-values.c (vr_values::extract_range_from_binary_expr): Call\n+\trange_fold_binary_expr instead of extract_range_from_binary_expr.\n+\t(vr_values::extract_range_basic): Same.\n+\t(vr_values::extract_range_from_unary_expr): Call\n+\trange_fold_unary_expr instead of extract_range_from_unary_expr.\n+\t* wide-int-range.cc: Remove.\n+\t* wide-int-range.h: Remove.\n+\n 2019-10-02   Michael Meissner  <meissner@linux.ibm.com>\n \n \t* config/rs6000/rs6000.c (mem_operand_gpr): Use"}, {"sha": "59adfaa38622ff639371dab526fee0988ca5d68d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a734350fd787da1b4bcf9b4e0a99ed2adb5eae/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a734350fd787da1b4bcf9b4e0a99ed2adb5eae/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=38a734350fd787da1b4bcf9b4e0a99ed2adb5eae", "patch": "@@ -1453,6 +1453,8 @@ OBJS = \\\n \tprint-tree.o \\\n \tprofile.o \\\n \tprofile-count.o \\\n+\trange.o \\\n+\trange-op.o \\\n \tread-md.o \\\n \tread-rtl.o \\\n \tread-rtl-function.o \\\n@@ -1611,7 +1613,6 @@ OBJS = \\\n \tweb.o \\\n \twide-int.o \\\n \twide-int-print.o \\\n-\twide-int-range.o \\\n \txcoffout.o \\\n \t$(out_object_file) \\\n \t$(EXTRA_OBJS) \\"}, {"sha": "2440dd6820b4d310290ca8514baa070dd28fed2f", "filename": "gcc/function-tests.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a734350fd787da1b4bcf9b4e0a99ed2adb5eae/gcc%2Ffunction-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a734350fd787da1b4bcf9b4e0a99ed2adb5eae/gcc%2Ffunction-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction-tests.c?ref=38a734350fd787da1b4bcf9b4e0a99ed2adb5eae", "patch": "@@ -570,6 +570,19 @@ test_conversion_to_ssa ()\n   ASSERT_EQ (SSA_NAME, TREE_CODE (gimple_return_retval (return_stmt)));\n }\n \n+/* Test range folding.  We must start this here because we need cfun\n+   set.  */\n+\n+static void\n+test_ranges ()\n+{\n+  tree fndecl = build_trivial_high_gimple_function ();\n+  function *fun = DECL_STRUCT_FUNCTION (fndecl);\n+  push_cfun (fun);\n+  range_tests ();\n+  pop_cfun ();\n+}\n+\n /* Test of expansion from gimple-ssa to RTL.  */\n \n static void\n@@ -674,6 +687,7 @@ function_tests_c_tests ()\n   test_gimplification ();\n   test_building_cfg ();\n   test_conversion_to_ssa ();\n+  test_ranges ();\n   test_expansion_to_rtl ();\n }\n "}, {"sha": "67664ec8c0747bc634e5930bf15fc045247f8e67", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a734350fd787da1b4bcf9b4e0a99ed2adb5eae/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a734350fd787da1b4bcf9b4e0a99ed2adb5eae/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=38a734350fd787da1b4bcf9b4e0a99ed2adb5eae", "patch": "@@ -1944,8 +1944,7 @@ ipa_vr_operation_and_type_effects (value_range_base *dst_vr,\n \t\t\t\t   enum tree_code operation,\n \t\t\t\t   tree dst_type, tree src_type)\n {\n-  extract_range_from_unary_expr (dst_vr, operation, dst_type,\n-\t\t\t\t src_vr, src_type);\n+  range_fold_unary_expr (dst_vr, operation, dst_type, src_vr, src_type);\n   if (dst_vr->varying_p () || dst_vr->undefined_p ())\n     return false;\n   return true;"}, {"sha": "25a108d5824ec40147ecfa32f50c6ccfb4f9a239", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a734350fd787da1b4bcf9b4e0a99ed2adb5eae/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a734350fd787da1b4bcf9b4e0a99ed2adb5eae/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=38a734350fd787da1b4bcf9b4e0a99ed2adb5eae", "patch": "@@ -1921,8 +1921,8 @@ ipa_compute_jump_functions_for_edge (struct ipa_func_body_info *fbi,\n \t      value_range_base tmpvr (type,\n \t\t\t\t      wide_int_to_tree (TREE_TYPE (arg), min),\n \t\t\t\t      wide_int_to_tree (TREE_TYPE (arg), max));\n-\t      extract_range_from_unary_expr (&resvr, NOP_EXPR, param_type,\n-\t\t\t\t\t     &tmpvr, TREE_TYPE (arg));\n+\t      range_fold_unary_expr (&resvr, NOP_EXPR, param_type,\n+\t\t\t\t     &tmpvr, TREE_TYPE (arg));\n \t      if (!resvr.undefined_p () && !resvr.varying_p ())\n \t\tipa_set_jfunc_vr (jfunc, &resvr);\n \t      else"}, {"sha": "b538b00459a52ccde9d8458bfffacd947da758d8", "filename": "gcc/range-op.cc", "status": "added", "additions": 3260, "deletions": 0, "changes": 3260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a734350fd787da1b4bcf9b4e0a99ed2adb5eae/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a734350fd787da1b4bcf9b4e0a99ed2adb5eae/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=38a734350fd787da1b4bcf9b4e0a99ed2adb5eae"}, {"sha": "f651075816376b667bc3c2bed37e2c2c85115356", "filename": "gcc/range-op.h", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a734350fd787da1b4bcf9b4e0a99ed2adb5eae/gcc%2Frange-op.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a734350fd787da1b4bcf9b4e0a99ed2adb5eae/gcc%2Frange-op.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.h?ref=38a734350fd787da1b4bcf9b4e0a99ed2adb5eae", "patch": "@@ -0,0 +1,88 @@\n+/* Header file for range operator class.\n+   Copyright (C) 2017-2019 Free Software Foundation, Inc.\n+   Contributed by Andrew MacLeod <amacleod@redhat.com>\n+   and Aldy Hernandez <aldyh@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_RANGE_OP_H\n+#define GCC_RANGE_OP_H\n+\n+// This class is implemented for each kind of operator supported by\n+// the range generator.  It serves various purposes.\n+//\n+// 1 - Generates range information for the specific operation between\n+//     two ranges.  This provides the ability to fold ranges for an\n+//     expression.\n+//\n+// 2 - Performs range algebra on the expression such that a range can be\n+//     adjusted in terms of one of the operands:\n+//\n+//       def = op1 + op2\n+//\n+//     Given a range for def, we can adjust the range so that it is in\n+//     terms of either operand.\n+//\n+//     op1_range (def_range, op2) will adjust the range in place so it\n+//     is in terms of op1.  Since op1 = def - op2, it will subtract\n+//     op2 from each element of the range.\n+//\n+// 3 - Creates a range for an operand based on whether the result is 0 or\n+//     non-zero.  This is mostly for logical true false, but can serve other\n+//     purposes.\n+//       ie   0 = op1 - op2 implies op2 has the same range as op1.\n+\n+class range_operator\n+{\n+public:\n+  // Perform an operation between 2 ranges and return it.\n+  virtual value_range_base fold_range (tree type,\n+\t\t\t\t       const value_range_base &lh,\n+\t\t\t\t       const value_range_base &rh) const;\n+\n+  // Return the range for op[12] in the general case.  LHS is the range for\n+  // the LHS of the expression, OP[12]is the range for the other\n+  //\n+  // The operand and the result is returned in R.\n+  //\n+  // TYPE is the expected type of the range.\n+  //\n+  // Return TRUE if the operation is performed and a valid range is available.\n+  //\n+  // i.e.  [LHS] = ??? + OP2\n+  // is re-formed as R = [LHS] - OP2.\n+  virtual bool op1_range (value_range_base &r, tree type,\n+\t\t\t  const value_range_base &lhs,\n+\t\t\t  const value_range_base &op2) const;\n+  virtual bool op2_range (value_range_base &r, tree type,\n+\t\t\t  const value_range_base &lhs,\n+\t\t\t  const value_range_base &op1) const;\n+\n+protected:\n+  // Perform an operation between 2 sub-ranges and return it.\n+  virtual value_range_base wi_fold (tree type,\n+\t\t\t\t    const wide_int &lh_lb,\n+\t\t\t\t    const wide_int &lh_ub,\n+\t\t\t\t    const wide_int &rh_lb,\n+\t\t\t\t    const wide_int &rh_ub) const;\n+};\n+\n+extern range_operator *range_op_handler (enum tree_code code, tree type);\n+\n+extern void range_cast (value_range_base &, tree type);\n+\n+#endif // GCC_RANGE_OP_H"}, {"sha": "5e4d90436f27049f8193cf01f7d85a5458fa6810", "filename": "gcc/range.cc", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a734350fd787da1b4bcf9b4e0a99ed2adb5eae/gcc%2Frange.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a734350fd787da1b4bcf9b4e0a99ed2adb5eae/gcc%2Frange.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange.cc?ref=38a734350fd787da1b4bcf9b4e0a99ed2adb5eae", "patch": "@@ -0,0 +1,89 @@\n+/* Misc range functions.\n+   Copyright (C) 2017-2019 Free Software Foundation, Inc.\n+   Contributed by Aldy Hernandez <aldyh@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"fold-const.h\"\n+#include \"ssa.h\"\n+#include \"range.h\"\n+\n+value_range_base\n+range_intersect (const value_range_base &r1, const value_range_base &r2)\n+{\n+  value_range_base tmp (r1);\n+  tmp.intersect (r2);\n+  return tmp;\n+}\n+\n+value_range_base\n+range_invert (const value_range_base &r1)\n+{\n+  value_range_base tmp (r1);\n+  tmp.invert ();\n+  return tmp;\n+}\n+\n+value_range_base\n+range_union (const value_range_base &r1, const value_range_base &r2)\n+{\n+  value_range_base tmp (r1);\n+  tmp.union_ (r2);\n+  return tmp;\n+}\n+\n+value_range_base\n+range_zero (tree type)\n+{\n+  return value_range_base (build_zero_cst (type), build_zero_cst (type));\n+}\n+\n+value_range_base\n+range_nonzero (tree type)\n+{\n+  return value_range_base (VR_ANTI_RANGE,\n+\t\t\t   build_zero_cst (type), build_zero_cst (type));\n+}\n+\n+value_range_base\n+range_positives (tree type)\n+{\n+  unsigned prec = TYPE_PRECISION (type);\n+  signop sign = TYPE_SIGN (type);\n+  return value_range_base (type, wi::zero (prec), wi::max_value (prec, sign));\n+}\n+\n+value_range_base\n+range_negatives (tree type)\n+{\n+  unsigned prec = TYPE_PRECISION (type);\n+  signop sign = TYPE_SIGN (type);\n+  value_range_base r;\n+  if (sign == UNSIGNED)\n+    r.set_undefined ();\n+  else\n+    r = value_range_base (type, wi::min_value (prec, sign),\n+\t\t\t  wi::minus_one (prec));\n+  return r;\n+}"}, {"sha": "3983171f51d3be3d4567288497c7528b6756fe2d", "filename": "gcc/range.h", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a734350fd787da1b4bcf9b4e0a99ed2adb5eae/gcc%2Frange.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a734350fd787da1b4bcf9b4e0a99ed2adb5eae/gcc%2Frange.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange.h?ref=38a734350fd787da1b4bcf9b4e0a99ed2adb5eae", "patch": "@@ -0,0 +1,33 @@\n+/* Header file for misc range functions. -*- C++ -*-\n+   Copyright (C) 2017-2019 Free Software Foundation, Inc.\n+   Contributed by Aldy Hernandez <aldyh@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_RANGE_H\n+#define GCC_RANGE_H\n+\n+value_range_base range_zero (tree type);\n+value_range_base range_nonzero (tree type);\n+value_range_base range_intersect (const value_range_base &,\n+\t\t\t\t  const value_range_base &);\n+value_range_base range_union (const value_range_base &,\n+\t\t\t      const value_range_base &);\n+value_range_base range_invert (const value_range_base &);\n+value_range_base range_positives (tree type);\n+value_range_base range_negatives (tree type);\n+#endif // GCC_RANGE_H"}, {"sha": "6f2c2afde9d152beeb57527dd973fee8ba0ab3ab", "filename": "gcc/selftest.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a734350fd787da1b4bcf9b4e0a99ed2adb5eae/gcc%2Fselftest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a734350fd787da1b4bcf9b4e0a99ed2adb5eae/gcc%2Fselftest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.h?ref=38a734350fd787da1b4bcf9b4e0a99ed2adb5eae", "patch": "@@ -259,6 +259,10 @@ extern int num_passes;\n \n } /* end of namespace selftest.  */\n \n+/* This is outside of the selftest namespace because it's a friend of\n+   value_range_base.  */\n+extern void range_tests ();\n+\n /* Macros for writing tests.  */\n \n /* Evaluate EXPR and coerce to bool, calling"}, {"sha": "2fe4addedf2a90759a486d914e8be0f9a6990322", "filename": "gcc/ssa.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a734350fd787da1b4bcf9b4e0a99ed2adb5eae/gcc%2Fssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a734350fd787da1b4bcf9b4e0a99ed2adb5eae/gcc%2Fssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa.h?ref=38a734350fd787da1b4bcf9b4e0a99ed2adb5eae", "patch": "@@ -26,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"gimple-ssa.h\"\n #include \"tree-vrp.h\"\n+#include \"range.h\"\n #include \"tree-ssanames.h\"\n #include \"tree-phinodes.h\"\n #include \"ssa-iterators.h\" "}, {"sha": "a2ab4a219256c4395b0543a0f168fb67812641b9", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 527, "deletions": 699, "changes": 1226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a734350fd787da1b4bcf9b4e0a99ed2adb5eae/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a734350fd787da1b4bcf9b4e0a99ed2adb5eae/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=38a734350fd787da1b4bcf9b4e0a99ed2adb5eae", "patch": "@@ -67,7 +67,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"attribs.h\"\n #include \"vr-values.h\"\n #include \"builtins.h\"\n-#include \"wide-int-range.h\"\n+#include \"range-op.h\"\n \n static bool\n ranges_from_anti_range (const value_range_base *ar,\n@@ -131,6 +131,36 @@ value_range::value_range (const value_range_base &other)\n   set (other.kind (), other.min(), other.max (), NULL);\n }\n \n+value_range_base::value_range_base (tree type)\n+{\n+  set_varying (type);\n+}\n+\n+value_range_base::value_range_base (enum value_range_kind kind,\n+\t\t\t\t    tree type,\n+\t\t\t\t    const wide_int &wmin,\n+\t\t\t\t    const wide_int &wmax)\n+{\n+  tree min = wide_int_to_tree (type, wmin);\n+  tree max = wide_int_to_tree (type, wmax);\n+  gcc_checking_assert (kind == VR_RANGE || kind == VR_ANTI_RANGE);\n+  set (kind, min, max);\n+}\n+\n+value_range_base::value_range_base (tree type,\n+\t\t\t\t    const wide_int &wmin,\n+\t\t\t\t    const wide_int &wmax)\n+{\n+  tree min = wide_int_to_tree (type, wmin);\n+  tree max = wide_int_to_tree (type, wmax);\n+  set (VR_RANGE, min, max);\n+}\n+\n+value_range_base::value_range_base (tree min, tree max)\n+{\n+  set (VR_RANGE, min, max);\n+}\n+\n /* Like set, but keep the equivalences in place.  */\n \n void\n@@ -350,10 +380,14 @@ value_range_base::singleton_p (tree *result) const\n \t  return false;\n \t}\n \n-      value_range_base vr0, vr1;\n-      return (ranges_from_anti_range (this, &vr0, &vr1, true)\n-\t      && vr1.undefined_p ()\n-\t      && vr0.singleton_p (result));\n+      /* An anti-range that includes an extreme, is just a range with\n+\t one sub-range.  Use the one sub-range.  */\n+      if (vrp_val_is_min (m_min, true) || vrp_val_is_max (m_max, true))\n+\t{\n+\t  value_range_base vr0, vr1;\n+\t  ranges_from_anti_range (this, &vr0, &vr1, true);\n+\t  return vr0.singleton_p (result);\n+\t}\n     }\n   if (m_kind == VR_RANGE\n       && vrp_operand_equal_p (min (), max ())\n@@ -369,7 +403,7 @@ value_range_base::singleton_p (tree *result) const\n tree\n value_range_base::type () const\n {\n-  gcc_assert (m_min);\n+  gcc_checking_assert (m_min);\n   return TREE_TYPE (min ());\n }\n \n@@ -573,9 +607,9 @@ vrp_val_min (const_tree type, bool handle_pointers)\n    is not == to the integer constant with the same value in the type.  */\n \n bool\n-vrp_val_is_max (const_tree val)\n+vrp_val_is_max (const_tree val, bool handle_pointers)\n {\n-  tree type_max = vrp_val_max (TREE_TYPE (val));\n+  tree type_max = vrp_val_max (TREE_TYPE (val), handle_pointers);\n   return (val == type_max\n \t  || (type_max != NULL_TREE\n \t      && operand_equal_p (val, type_max, 0)));\n@@ -584,9 +618,9 @@ vrp_val_is_max (const_tree val)\n /* Return whether VAL is equal to the minimum value of its type.  */\n \n bool\n-vrp_val_is_min (const_tree val)\n+vrp_val_is_min (const_tree val, bool handle_pointers)\n {\n-  tree type_min = vrp_val_min (TREE_TYPE (val));\n+  tree type_min = vrp_val_min (TREE_TYPE (val), handle_pointers);\n   return (val == type_min\n \t  || (type_min != NULL_TREE\n \t      && operand_equal_p (val, type_min, 0)));\n@@ -1220,9 +1254,46 @@ value_range_base::value_inside_range (tree val) const\n     return !!cmp2;\n }\n \n-/* Value range wrapper for wide_int_range_set_zero_nonzero_bits.\n+/* For range [LB, UB] compute two wide_int bit masks.\n+\n+   In the MAY_BE_NONZERO bit mask, if some bit is unset, it means that\n+   for all numbers in the range the bit is 0, otherwise it might be 0\n+   or 1.\n+\n+   In the MUST_BE_NONZERO bit mask, if some bit is set, it means that\n+   for all numbers in the range the bit is 1, otherwise it might be 0\n+   or 1.  */\n+\n+static inline void\n+wide_int_range_set_zero_nonzero_bits (signop sign,\n+\t\t\t\t      const wide_int &lb, const wide_int &ub,\n+\t\t\t\t      wide_int &may_be_nonzero,\n+\t\t\t\t      wide_int &must_be_nonzero)\n+{\n+  may_be_nonzero = wi::minus_one (lb.get_precision ());\n+  must_be_nonzero = wi::zero (lb.get_precision ());\n+\n+  if (wi::eq_p (lb, ub))\n+    {\n+      may_be_nonzero = lb;\n+      must_be_nonzero = may_be_nonzero;\n+    }\n+  else if (wi::ge_p (lb, 0, sign) || wi::lt_p (ub, 0, sign))\n+    {\n+      wide_int xor_mask = lb ^ ub;\n+      may_be_nonzero = lb | ub;\n+      must_be_nonzero = lb & ub;\n+      if (xor_mask != 0)\n+\t{\n+\t  wide_int mask = wi::mask (wi::floor_log2 (xor_mask), false,\n+\t\t\t\t    may_be_nonzero.get_precision ());\n+\t  may_be_nonzero = may_be_nonzero | mask;\n+\t  must_be_nonzero = wi::bit_and_not (must_be_nonzero, mask);\n+\t}\n+    }\n+}\n \n-   Compute MAY_BE_NONZERO and MUST_BE_NONZERO bit masks for range in VR.\n+/* value_range wrapper for wide_int_range_set_zero_nonzero_bits above.\n \n    Return TRUE if VR was a constant range and we were able to compute\n    the bit masks.  */\n@@ -1288,87 +1359,6 @@ ranges_from_anti_range (const value_range_base *ar,\n   return !vr0->undefined_p ();\n }\n \n-/* Extract the components of a value range into a pair of wide ints in\n-   [WMIN, WMAX], after having normalized any symbolics from the input.  */\n-\n-static void inline\n-extract_range_into_wide_ints (const value_range_base *vr_,\n-\t\t\t      tree type, wide_int &wmin, wide_int &wmax)\n-{\n-  signop sign = TYPE_SIGN (type);\n-  unsigned int prec = TYPE_PRECISION (type);\n-  gcc_assert (vr_->kind () != VR_ANTI_RANGE || vr_->symbolic_p ());\n-  value_range vr = vr_->normalize_symbolics ();\n-  if (range_int_cst_p (&vr))\n-    {\n-      wmin = wi::to_wide (vr.min ());\n-      wmax = wi::to_wide (vr.max ());\n-    }\n-  else\n-    {\n-      wmin = wi::min_value (prec, sign);\n-      wmax = wi::max_value (prec, sign);\n-    }\n-}\n-\n-/* Value range wrapper for wide_int_range_multiplicative_op:\n-\n-     *VR = *VR0 .CODE. *VR1.  */\n-\n-static void\n-extract_range_from_multiplicative_op (value_range_base *vr,\n-\t\t\t\t      enum tree_code code, tree type,\n-\t\t\t\t      const value_range_base *vr0,\n-\t\t\t\t      const value_range_base *vr1)\n-{\n-  gcc_assert (code == MULT_EXPR\n-\t      || code == TRUNC_DIV_EXPR\n-\t      || code == FLOOR_DIV_EXPR\n-\t      || code == CEIL_DIV_EXPR\n-\t      || code == EXACT_DIV_EXPR\n-\t      || code == ROUND_DIV_EXPR\n-\t      || code == RSHIFT_EXPR\n-\t      || code == LSHIFT_EXPR);\n-  if (!range_int_cst_p (vr1))\n-    {\n-      vr->set_varying (type);\n-      return;\n-    }\n-\n-  /* Even if vr0 is VARYING or otherwise not usable, we can derive\n-     useful ranges just from the shift count.  E.g.\n-     x >> 63 for signed 64-bit x is always [-1, 0].  */\n-  value_range_base tem = vr0->normalize_symbolics ();\n-  tree vr0_min, vr0_max;\n-  if (tem.kind () == VR_RANGE)\n-    {\n-      vr0_min = tem.min ();\n-      vr0_max = tem.max ();\n-    }\n-  else\n-    {\n-      vr0_min = vrp_val_min (type);\n-      vr0_max = vrp_val_max (type);\n-    }\n-\n-  wide_int res_lb, res_ub;\n-  wide_int vr0_lb = wi::to_wide (vr0_min);\n-  wide_int vr0_ub = wi::to_wide (vr0_max);\n-  wide_int vr1_lb = wi::to_wide (vr1->min ());\n-  wide_int vr1_ub = wi::to_wide (vr1->max ());\n-  bool overflow_undefined = TYPE_OVERFLOW_UNDEFINED (type);\n-  unsigned prec = TYPE_PRECISION (type);\n-\n-  if (wide_int_range_multiplicative_op (res_lb, res_ub,\n-\t\t\t\t\tcode, TYPE_SIGN (type), prec,\n-\t\t\t\t\tvr0_lb, vr0_ub, vr1_lb, vr1_ub,\n-\t\t\t\t\toverflow_undefined))\n-    vr->set (VR_RANGE, wide_int_to_tree (type, res_lb),\n-\t     wide_int_to_tree (type, res_ub));\n-  else\n-    vr->set_varying (type);\n-}\n-\n /* If BOUND will include a symbolic bound, adjust it accordingly,\n    otherwise leave it as is.\n \n@@ -1484,8 +1474,7 @@ set_value_range_with_overflow (value_range_kind &kind, tree &min, tree &max,\n       if ((min_ovf != wi::OVF_NONE) == (max_ovf != wi::OVF_NONE))\n \t{\n \t  /* If the limits are swapped, we wrapped around and cover\n-\t     the entire range.  We have a similar check at the end of\n-\t     extract_range_from_binary_expr.  */\n+\t     the entire range.  */\n \t  if (wi::gt_p (tmin, tmax, sgn))\n \t    kind = VR_VARYING;\n \t  else\n@@ -1554,91 +1543,71 @@ set_value_range_with_overflow (value_range_kind &kind, tree &min, tree &max,\n     }\n }\n \n-/* Extract range information from a binary operation CODE based on\n-   the ranges of each of its operands *VR0 and *VR1 with resulting\n-   type EXPR_TYPE.  The resulting range is stored in *VR.  */\n+/* Fold two value range's of a POINTER_PLUS_EXPR into VR.  */\n \n-void\n-extract_range_from_binary_expr (value_range_base *vr,\n-\t\t\t\tenum tree_code code, tree expr_type,\n-\t\t\t\tconst value_range_base *vr0_,\n-\t\t\t\tconst value_range_base *vr1_)\n+static void\n+extract_range_from_pointer_plus_expr (value_range_base *vr,\n+\t\t\t\t      enum tree_code code,\n+\t\t\t\t      tree expr_type,\n+\t\t\t\t      const value_range_base *vr0,\n+\t\t\t\t      const value_range_base *vr1)\n {\n-  signop sign = TYPE_SIGN (expr_type);\n-  unsigned int prec = TYPE_PRECISION (expr_type);\n-  value_range_base vr0 = *vr0_, vr1 = *vr1_;\n-  value_range_base vrtem0, vrtem1;\n-  enum value_range_kind type;\n-  tree min = NULL_TREE, max = NULL_TREE;\n-  int cmp;\n-\n-  if (!INTEGRAL_TYPE_P (expr_type)\n-      && !POINTER_TYPE_P (expr_type))\n-    {\n-      vr->set_varying (expr_type);\n-      return;\n-    }\n+  gcc_checking_assert (POINTER_TYPE_P (expr_type)\n+\t\t       && code == POINTER_PLUS_EXPR);\n+  /* For pointer types, we are really only interested in asserting\n+     whether the expression evaluates to non-NULL.\n+     With -fno-delete-null-pointer-checks we need to be more\n+     conservative.  As some object might reside at address 0,\n+     then some offset could be added to it and the same offset\n+     subtracted again and the result would be NULL.\n+     E.g.\n+     static int a[12]; where &a[0] is NULL and\n+     ptr = &a[6];\n+     ptr -= 6;\n+     ptr will be NULL here, even when there is POINTER_PLUS_EXPR\n+     where the first range doesn't include zero and the second one\n+     doesn't either.  As the second operand is sizetype (unsigned),\n+     consider all ranges where the MSB could be set as possible\n+     subtractions where the result might be NULL.  */\n+  if ((!range_includes_zero_p (vr0)\n+       || !range_includes_zero_p (vr1))\n+      && !TYPE_OVERFLOW_WRAPS (expr_type)\n+      && (flag_delete_null_pointer_checks\n+\t  || (range_int_cst_p (vr1)\n+\t      && !tree_int_cst_sign_bit (vr1->max ()))))\n+    vr->set_nonzero (expr_type);\n+  else if (vr0->zero_p () && vr1->zero_p ())\n+    vr->set_zero (expr_type);\n+  else\n+    vr->set_varying (expr_type);\n+}\n \n-  /* Not all binary expressions can be applied to ranges in a\n-     meaningful way.  Handle only arithmetic operations.  */\n-  if (code != PLUS_EXPR\n-      && code != MINUS_EXPR\n-      && code != POINTER_PLUS_EXPR\n-      && code != MULT_EXPR\n-      && code != TRUNC_DIV_EXPR\n-      && code != FLOOR_DIV_EXPR\n-      && code != CEIL_DIV_EXPR\n-      && code != EXACT_DIV_EXPR\n-      && code != ROUND_DIV_EXPR\n-      && code != TRUNC_MOD_EXPR\n-      && code != RSHIFT_EXPR\n-      && code != LSHIFT_EXPR\n-      && code != MIN_EXPR\n-      && code != MAX_EXPR\n-      && code != BIT_AND_EXPR\n-      && code != BIT_IOR_EXPR\n-      && code != BIT_XOR_EXPR)\n-    {\n-      vr->set_varying (expr_type);\n-      return;\n-    }\n+/* Extract range information from a PLUS/MINUS_EXPR and store the\n+   result in *VR.  */\n \n-  /* If both ranges are UNDEFINED, so is the result.  */\n-  if (vr0.undefined_p () && vr1.undefined_p ())\n-    {\n-      vr->set_undefined ();\n-      return;\n-    }\n-  /* If one of the ranges is UNDEFINED drop it to VARYING for the following\n-     code.  At some point we may want to special-case operations that\n-     have UNDEFINED result for all or some value-ranges of the not UNDEFINED\n-     operand.  */\n-  else if (vr0.undefined_p ())\n-    vr0.set_varying (expr_type);\n-  else if (vr1.undefined_p ())\n-    vr1.set_varying (expr_type);\n+static void\n+extract_range_from_plus_minus_expr (value_range_base *vr,\n+\t\t\t\t    enum tree_code code,\n+\t\t\t\t    tree expr_type,\n+\t\t\t\t    const value_range_base *vr0_,\n+\t\t\t\t    const value_range_base *vr1_)\n+{\n+  gcc_checking_assert (code == PLUS_EXPR || code == MINUS_EXPR);\n \n-  /* We get imprecise results from ranges_from_anti_range when\n-     code is EXACT_DIV_EXPR.  We could mask out bits in the resulting\n-     range, but then we also need to hack up vrp_union.  It's just\n-     easier to special case when vr0 is ~[0,0] for EXACT_DIV_EXPR.  */\n-  if (code == EXACT_DIV_EXPR && vr0.nonzero_p ())\n-    {\n-      vr->set_nonzero (expr_type);\n-      return;\n-    }\n+  value_range_base vr0 = *vr0_, vr1 = *vr1_;\n+  value_range_base vrtem0, vrtem1;\n \n   /* Now canonicalize anti-ranges to ranges when they are not symbolic\n      and express ~[] op X as ([]' op X) U ([]'' op X).  */\n   if (vr0.kind () == VR_ANTI_RANGE\n       && ranges_from_anti_range (&vr0, &vrtem0, &vrtem1))\n     {\n-      extract_range_from_binary_expr (vr, code, expr_type, &vrtem0, vr1_);\n+      extract_range_from_plus_minus_expr (vr, code, expr_type, &vrtem0, vr1_);\n       if (!vrtem1.undefined_p ())\n \t{\n \t  value_range_base vrres;\n-\t  extract_range_from_binary_expr (&vrres, code, expr_type,\n-\t\t\t\t\t  &vrtem1, vr1_);\n+\t  extract_range_from_plus_minus_expr (&vrres, code, expr_type,\n+\t\t\t\t\t      &vrtem1, vr1_);\n \t  vr->union_ (&vrres);\n \t}\n       return;\n@@ -1647,422 +1616,129 @@ extract_range_from_binary_expr (value_range_base *vr,\n   if (vr1.kind () == VR_ANTI_RANGE\n       && ranges_from_anti_range (&vr1, &vrtem0, &vrtem1))\n     {\n-      extract_range_from_binary_expr (vr, code, expr_type, vr0_, &vrtem0);\n+      extract_range_from_plus_minus_expr (vr, code, expr_type, vr0_, &vrtem0);\n       if (!vrtem1.undefined_p ())\n \t{\n \t  value_range_base vrres;\n-\t  extract_range_from_binary_expr (&vrres, code, expr_type,\n-\t\t\t\t\t  vr0_, &vrtem1);\n+\t  extract_range_from_plus_minus_expr (&vrres, code, expr_type,\n+\t\t\t\t\t      vr0_, &vrtem1);\n \t  vr->union_ (&vrres);\n \t}\n       return;\n     }\n \n-  /* The type of the resulting value range defaults to VR0.TYPE.  */\n-  type = vr0.kind ();\n-\n-  /* Refuse to operate on VARYING ranges, ranges of different kinds\n-     and symbolic ranges.  As an exception, we allow BIT_{AND,IOR}\n-     because we may be able to derive a useful range even if one of\n-     the operands is VR_VARYING or symbolic range.  Similarly for\n-     divisions, MIN/MAX and PLUS/MINUS.\n-\n-     TODO, we may be able to derive anti-ranges in some cases.  */\n-  if (code != BIT_AND_EXPR\n-      && code != BIT_IOR_EXPR\n-      && code != TRUNC_DIV_EXPR\n-      && code != FLOOR_DIV_EXPR\n-      && code != CEIL_DIV_EXPR\n-      && code != EXACT_DIV_EXPR\n-      && code != ROUND_DIV_EXPR\n-      && code != TRUNC_MOD_EXPR\n-      && code != MIN_EXPR\n-      && code != MAX_EXPR\n-      && code != PLUS_EXPR\n-      && code != MINUS_EXPR\n-      && code != RSHIFT_EXPR\n-      && code != POINTER_PLUS_EXPR\n-      && (vr0.varying_p ()\n-\t  || vr1.varying_p ()\n-\t  || vr0.kind () != vr1.kind ()\n-\t  || vr0.symbolic_p ()\n-\t  || vr1.symbolic_p ()))\n-    {\n-      vr->set_varying (expr_type);\n-      return;\n-    }\n-\n-  /* Now evaluate the expression to determine the new range.  */\n-  if (POINTER_TYPE_P (expr_type))\n+  value_range_kind kind;\n+  value_range_kind vr0_kind = vr0.kind (), vr1_kind = vr1.kind ();\n+  tree vr0_min = vr0.min (), vr0_max = vr0.max ();\n+  tree vr1_min = vr1.min (), vr1_max = vr1.max ();\n+  tree min = NULL, max = NULL;\n+\n+  /* This will normalize things such that calculating\n+     [0,0] - VR_VARYING is not dropped to varying, but is\n+     calculated as [MIN+1, MAX].  */\n+  if (vr0.varying_p ())\n+    {\n+      vr0_kind = VR_RANGE;\n+      vr0_min = vrp_val_min (expr_type);\n+      vr0_max = vrp_val_max (expr_type);\n+    }\n+  if (vr1.varying_p ())\n+    {\n+      vr1_kind = VR_RANGE;\n+      vr1_min = vrp_val_min (expr_type);\n+      vr1_max = vrp_val_max (expr_type);\n+    }\n+\n+  const bool minus_p = (code == MINUS_EXPR);\n+  tree min_op0 = vr0_min;\n+  tree min_op1 = minus_p ? vr1_max : vr1_min;\n+  tree max_op0 = vr0_max;\n+  tree max_op1 = minus_p ? vr1_min : vr1_max;\n+  tree sym_min_op0 = NULL_TREE;\n+  tree sym_min_op1 = NULL_TREE;\n+  tree sym_max_op0 = NULL_TREE;\n+  tree sym_max_op1 = NULL_TREE;\n+  bool neg_min_op0, neg_min_op1, neg_max_op0, neg_max_op1;\n+\n+  neg_min_op0 = neg_min_op1 = neg_max_op0 = neg_max_op1 = false;\n+\n+  /* If we have a PLUS or MINUS with two VR_RANGEs, either constant or\n+     single-symbolic ranges, try to compute the precise resulting range,\n+     but only if we know that this resulting range will also be constant\n+     or single-symbolic.  */\n+  if (vr0_kind == VR_RANGE && vr1_kind == VR_RANGE\n+      && (TREE_CODE (min_op0) == INTEGER_CST\n+\t  || (sym_min_op0\n+\t      = get_single_symbol (min_op0, &neg_min_op0, &min_op0)))\n+      && (TREE_CODE (min_op1) == INTEGER_CST\n+\t  || (sym_min_op1\n+\t      = get_single_symbol (min_op1, &neg_min_op1, &min_op1)))\n+      && (!(sym_min_op0 && sym_min_op1)\n+\t  || (sym_min_op0 == sym_min_op1\n+\t      && neg_min_op0 == (minus_p ? neg_min_op1 : !neg_min_op1)))\n+      && (TREE_CODE (max_op0) == INTEGER_CST\n+\t  || (sym_max_op0\n+\t      = get_single_symbol (max_op0, &neg_max_op0, &max_op0)))\n+      && (TREE_CODE (max_op1) == INTEGER_CST\n+\t  || (sym_max_op1\n+\t      = get_single_symbol (max_op1, &neg_max_op1, &max_op1)))\n+      && (!(sym_max_op0 && sym_max_op1)\n+\t  || (sym_max_op0 == sym_max_op1\n+\t      && neg_max_op0 == (minus_p ? neg_max_op1 : !neg_max_op1))))\n     {\n-      if (code == MIN_EXPR || code == MAX_EXPR)\n-\t{\n-\t  /* For MIN/MAX expressions with pointers, we only care about\n-\t     nullness, if both are non null, then the result is nonnull.\n-\t     If both are null, then the result is null. Otherwise they\n-\t     are varying.  */\n-\t  if (!range_includes_zero_p (&vr0) && !range_includes_zero_p (&vr1))\n-\t    vr->set_nonzero (expr_type);\n-\t  else if (vr0.zero_p () && vr1.zero_p ())\n-\t    vr->set_zero (expr_type);\n-\t  else\n-\t    vr->set_varying (expr_type);\n-\t}\n-      else if (code == POINTER_PLUS_EXPR)\n-\t{\n-\t  /* For pointer types, we are really only interested in asserting\n-\t     whether the expression evaluates to non-NULL.\n-\t     With -fno-delete-null-pointer-checks we need to be more\n-\t     conservative.  As some object might reside at address 0,\n-\t     then some offset could be added to it and the same offset\n-\t     subtracted again and the result would be NULL.\n-\t     E.g.\n-\t     static int a[12]; where &a[0] is NULL and\n-\t     ptr = &a[6];\n-\t     ptr -= 6;\n-\t     ptr will be NULL here, even when there is POINTER_PLUS_EXPR\n-\t     where the first range doesn't include zero and the second one\n-\t     doesn't either.  As the second operand is sizetype (unsigned),\n-\t     consider all ranges where the MSB could be set as possible\n-\t     subtractions where the result might be NULL.  */\n-\t  if ((!range_includes_zero_p (&vr0)\n-\t       || !range_includes_zero_p (&vr1))\n-\t      && !TYPE_OVERFLOW_WRAPS (expr_type)\n-\t      && (flag_delete_null_pointer_checks\n-\t\t  || (range_int_cst_p (&vr1)\n-\t\t      && !tree_int_cst_sign_bit (vr1.max ()))))\n-\t    vr->set_nonzero (expr_type);\n-\t  else if (vr0.zero_p () && vr1.zero_p ())\n-\t    vr->set_zero (expr_type);\n-\t  else\n-\t    vr->set_varying (expr_type);\n-\t}\n-      else if (code == BIT_AND_EXPR)\n-\t{\n-\t  /* For pointer types, we are really only interested in asserting\n-\t     whether the expression evaluates to non-NULL.  */\n-\t  if (vr0.zero_p () || vr1.zero_p ())\n-\t    vr->set_zero (expr_type);\n-\t  else\n-\t    vr->set_varying (expr_type);\n-\t}\n-      else\n-\tvr->set_varying (expr_type);\n-\n-      return;\n-    }\n-\n-  /* For integer ranges, apply the operation to each end of the\n-     range and see what we end up with.  */\n-  if (code == PLUS_EXPR || code == MINUS_EXPR)\n-    {\n-      value_range_kind vr0_kind = vr0.kind (), vr1_kind = vr1.kind ();\n-      tree vr0_min = vr0.min (), vr0_max = vr0.max ();\n-      tree vr1_min = vr1.min (), vr1_max = vr1.max ();\n-      /* This will normalize things such that calculating\n-\t [0,0] - VR_VARYING is not dropped to varying, but is\n-\t calculated as [MIN+1, MAX].  */\n-      if (vr0.varying_p ())\n-\t{\n-\t  vr0_kind = VR_RANGE;\n-\t  vr0_min = vrp_val_min (expr_type);\n-\t  vr0_max = vrp_val_max (expr_type);\n-\t}\n-      if (vr1.varying_p ())\n-\t{\n-\t  vr1_kind = VR_RANGE;\n-\t  vr1_min = vrp_val_min (expr_type);\n-\t  vr1_max = vrp_val_max (expr_type);\n-\t}\n-\n-      const bool minus_p = (code == MINUS_EXPR);\n-      tree min_op0 = vr0_min;\n-      tree min_op1 = minus_p ? vr1_max : vr1_min;\n-      tree max_op0 = vr0_max;\n-      tree max_op1 = minus_p ? vr1_min : vr1_max;\n-      tree sym_min_op0 = NULL_TREE;\n-      tree sym_min_op1 = NULL_TREE;\n-      tree sym_max_op0 = NULL_TREE;\n-      tree sym_max_op1 = NULL_TREE;\n-      bool neg_min_op0, neg_min_op1, neg_max_op0, neg_max_op1;\n-\n-      neg_min_op0 = neg_min_op1 = neg_max_op0 = neg_max_op1 = false;\n-\n-      /* If we have a PLUS or MINUS with two VR_RANGEs, either constant or\n-\t single-symbolic ranges, try to compute the precise resulting range,\n-\t but only if we know that this resulting range will also be constant\n-\t or single-symbolic.  */\n-      if (vr0_kind == VR_RANGE && vr1_kind == VR_RANGE\n-\t  && (TREE_CODE (min_op0) == INTEGER_CST\n-\t      || (sym_min_op0\n-\t\t  = get_single_symbol (min_op0, &neg_min_op0, &min_op0)))\n-\t  && (TREE_CODE (min_op1) == INTEGER_CST\n-\t      || (sym_min_op1\n-\t\t  = get_single_symbol (min_op1, &neg_min_op1, &min_op1)))\n-\t  && (!(sym_min_op0 && sym_min_op1)\n-\t      || (sym_min_op0 == sym_min_op1\n-\t\t  && neg_min_op0 == (minus_p ? neg_min_op1 : !neg_min_op1)))\n-\t  && (TREE_CODE (max_op0) == INTEGER_CST\n-\t      || (sym_max_op0\n-\t\t  = get_single_symbol (max_op0, &neg_max_op0, &max_op0)))\n-\t  && (TREE_CODE (max_op1) == INTEGER_CST\n-\t      || (sym_max_op1\n-\t\t  = get_single_symbol (max_op1, &neg_max_op1, &max_op1)))\n-\t  && (!(sym_max_op0 && sym_max_op1)\n-\t      || (sym_max_op0 == sym_max_op1\n-\t\t  && neg_max_op0 == (minus_p ? neg_max_op1 : !neg_max_op1))))\n-\t{\n-\t  wide_int wmin, wmax;\n-\t  wi::overflow_type min_ovf = wi::OVF_NONE;\n-\t  wi::overflow_type max_ovf = wi::OVF_NONE;\n-\n-\t  /* Build the bounds.  */\n-\t  combine_bound (code, wmin, min_ovf, expr_type, min_op0, min_op1);\n-\t  combine_bound (code, wmax, max_ovf, expr_type, max_op0, max_op1);\n-\n-\t  /* If we have overflow for the constant part and the resulting\n-\t     range will be symbolic, drop to VR_VARYING.  */\n-\t  if (((bool)min_ovf && sym_min_op0 != sym_min_op1)\n-\t      || ((bool)max_ovf && sym_max_op0 != sym_max_op1))\n-\t    {\n-\t      vr->set_varying (expr_type);\n-\t      return;\n-\t    }\n+      wide_int wmin, wmax;\n+      wi::overflow_type min_ovf = wi::OVF_NONE;\n+      wi::overflow_type max_ovf = wi::OVF_NONE;\n \n-\t  /* Adjust the range for possible overflow.  */\n-\t  min = NULL_TREE;\n-\t  max = NULL_TREE;\n-\t  set_value_range_with_overflow (type, min, max, expr_type,\n-\t\t\t\t\t wmin, wmax, min_ovf, max_ovf);\n-\t  if (type == VR_VARYING)\n-\t    {\n-\t      vr->set_varying (expr_type);\n-\t      return;\n-\t    }\n+      /* Build the bounds.  */\n+      combine_bound (code, wmin, min_ovf, expr_type, min_op0, min_op1);\n+      combine_bound (code, wmax, max_ovf, expr_type, max_op0, max_op1);\n \n-\t  /* Build the symbolic bounds if needed.  */\n-\t  adjust_symbolic_bound (min, code, expr_type,\n-\t\t\t\t sym_min_op0, sym_min_op1,\n-\t\t\t\t neg_min_op0, neg_min_op1);\n-\t  adjust_symbolic_bound (max, code, expr_type,\n-\t\t\t\t sym_max_op0, sym_max_op1,\n-\t\t\t\t neg_max_op0, neg_max_op1);\n-\t}\n-      else\n+      /* If we have overflow for the constant part and the resulting\n+\t range will be symbolic, drop to VR_VARYING.  */\n+      if (((bool)min_ovf && sym_min_op0 != sym_min_op1)\n+\t  || ((bool)max_ovf && sym_max_op0 != sym_max_op1))\n \t{\n-\t  /* For other cases, for example if we have a PLUS_EXPR with two\n-\t     VR_ANTI_RANGEs, drop to VR_VARYING.  It would take more effort\n-\t     to compute a precise range for such a case.\n-\t     ???  General even mixed range kind operations can be expressed\n-\t     by for example transforming ~[3, 5] + [1, 2] to range-only\n-\t     operations and a union primitive:\n-\t       [-INF, 2] + [1, 2]  U  [5, +INF] + [1, 2]\n-\t           [-INF+1, 4]     U    [6, +INF(OVF)]\n-\t     though usually the union is not exactly representable with\n-\t     a single range or anti-range as the above is\n-\t\t [-INF+1, +INF(OVF)] intersected with ~[5, 5]\n-\t     but one could use a scheme similar to equivalences for this. */\n \t  vr->set_varying (expr_type);\n \t  return;\n \t}\n-    }\n-  else if (code == MIN_EXPR\n-\t   || code == MAX_EXPR)\n-    {\n-      wide_int wmin, wmax;\n-      wide_int vr0_min, vr0_max;\n-      wide_int vr1_min, vr1_max;\n-      extract_range_into_wide_ints (&vr0, expr_type, vr0_min, vr0_max);\n-      extract_range_into_wide_ints (&vr1, expr_type, vr1_min, vr1_max);\n-      if (wide_int_range_min_max (wmin, wmax, code, sign, prec,\n-\t\t\t\t  vr0_min, vr0_max, vr1_min, vr1_max))\n-\tvr->set (VR_RANGE, wide_int_to_tree (expr_type, wmin),\n-\t\t wide_int_to_tree (expr_type, wmax));\n-      else\n-\tvr->set_varying (expr_type);\n-      return;\n-    }\n-  else if (code == MULT_EXPR)\n-    {\n-      if (!range_int_cst_p (&vr0)\n-\t  || !range_int_cst_p (&vr1))\n-\t{\n-\t  vr->set_varying (expr_type);\n-\t  return;\n-\t}\n-      extract_range_from_multiplicative_op (vr, code, expr_type, &vr0, &vr1);\n-      return;\n-    }\n-  else if (code == RSHIFT_EXPR\n-\t   || code == LSHIFT_EXPR)\n-    {\n-      if (range_int_cst_p (&vr1)\n-\t  && !wide_int_range_shift_undefined_p\n-\t\t(TYPE_SIGN (TREE_TYPE (vr1.min ())),\n-\t\t prec,\n-\t\t wi::to_wide (vr1.min ()),\n-\t\t wi::to_wide (vr1.max ())))\n-\t{\n-\t  if (code == RSHIFT_EXPR)\n-\t    {\n-\t      extract_range_from_multiplicative_op (vr, code, expr_type,\n-\t\t\t\t\t\t    &vr0, &vr1);\n-\t      return;\n-\t    }\n-\t  else if (code == LSHIFT_EXPR\n-\t\t   && range_int_cst_p (&vr0))\n-\t    {\n-\t      wide_int res_lb, res_ub;\n-\t      if (wide_int_range_lshift (res_lb, res_ub, sign, prec,\n-\t\t\t\t\t wi::to_wide (vr0.min ()),\n-\t\t\t\t\t wi::to_wide (vr0.max ()),\n-\t\t\t\t\t wi::to_wide (vr1.min ()),\n-\t\t\t\t\t wi::to_wide (vr1.max ()),\n-\t\t\t\t\t TYPE_OVERFLOW_UNDEFINED (expr_type)))\n-\t\t{\n-\t\t  min = wide_int_to_tree (expr_type, res_lb);\n-\t\t  max = wide_int_to_tree (expr_type, res_ub);\n-\t\t  vr->set (VR_RANGE, min, max);\n-\t\t  return;\n-\t\t}\n-\t    }\n-\t}\n-      vr->set_varying (expr_type);\n-      return;\n-    }\n-  else if (code == TRUNC_DIV_EXPR\n-\t   || code == FLOOR_DIV_EXPR\n-\t   || code == CEIL_DIV_EXPR\n-\t   || code == EXACT_DIV_EXPR\n-\t   || code == ROUND_DIV_EXPR)\n-    {\n-      wide_int dividend_min, dividend_max, divisor_min, divisor_max;\n-      wide_int wmin, wmax, extra_min, extra_max;\n-      bool extra_range_p;\n-\n-      /* Special case explicit division by zero as undefined.  */\n-      if (vr1.zero_p ())\n-\t{\n-\t  vr->set_undefined ();\n-\t  return;\n-\t}\n \n-      /* First, normalize ranges into constants we can handle.  Note\n-\t that VR_ANTI_RANGE's of constants were already normalized\n-\t before arriving here.\n-\n-\t NOTE: As a future improvement, we may be able to do better\n-\t with mixed symbolic (anti-)ranges like [0, A].  See note in\n-\t ranges_from_anti_range.  */\n-      extract_range_into_wide_ints (&vr0, expr_type,\n-\t\t\t\t    dividend_min, dividend_max);\n-      extract_range_into_wide_ints (&vr1, expr_type,\n-\t\t\t\t    divisor_min, divisor_max);\n-      if (!wide_int_range_div (wmin, wmax, code, sign, prec,\n-\t\t\t       dividend_min, dividend_max,\n-\t\t\t       divisor_min, divisor_max,\n-\t\t\t       TYPE_OVERFLOW_UNDEFINED (expr_type),\n-\t\t\t       extra_range_p, extra_min, extra_max))\n+      /* Adjust the range for possible overflow.  */\n+      min = NULL_TREE;\n+      max = NULL_TREE;\n+      set_value_range_with_overflow (kind, min, max, expr_type,\n+\t\t\t\t     wmin, wmax, min_ovf, max_ovf);\n+      if (kind == VR_VARYING)\n \t{\n \t  vr->set_varying (expr_type);\n \t  return;\n \t}\n-      vr->set (VR_RANGE, wide_int_to_tree (expr_type, wmin),\n-\t       wide_int_to_tree (expr_type, wmax));\n-      if (extra_range_p)\n-\t{\n-\t  value_range_base\n-\t    extra_range (VR_RANGE, wide_int_to_tree (expr_type, extra_min),\n-\t\t\t wide_int_to_tree (expr_type, extra_max));\n-\t  vr->union_ (&extra_range);\n-\t}\n-      return;\n+\n+      /* Build the symbolic bounds if needed.  */\n+      adjust_symbolic_bound (min, code, expr_type,\n+\t\t\t     sym_min_op0, sym_min_op1,\n+\t\t\t     neg_min_op0, neg_min_op1);\n+      adjust_symbolic_bound (max, code, expr_type,\n+\t\t\t     sym_max_op0, sym_max_op1,\n+\t\t\t     neg_max_op0, neg_max_op1);\n     }\n-  else if (code == TRUNC_MOD_EXPR)\n+  else\n     {\n-      if (vr1.zero_p ())\n-\t{\n-\t  vr->set_undefined ();\n-\t  return;\n-\t}\n-      wide_int wmin, wmax, tmp;\n-      wide_int vr0_min, vr0_max, vr1_min, vr1_max;\n-      extract_range_into_wide_ints (&vr0, expr_type, vr0_min, vr0_max);\n-      extract_range_into_wide_ints (&vr1, expr_type, vr1_min, vr1_max);\n-      wide_int_range_trunc_mod (wmin, wmax, sign, prec,\n-\t\t\t\tvr0_min, vr0_max, vr1_min, vr1_max);\n-      min = wide_int_to_tree (expr_type, wmin);\n-      max = wide_int_to_tree (expr_type, wmax);\n-      vr->set (VR_RANGE, min, max);\n+      /* For other cases, for example if we have a PLUS_EXPR with two\n+\t VR_ANTI_RANGEs, drop to VR_VARYING.  It would take more effort\n+\t to compute a precise range for such a case.\n+\t ???  General even mixed range kind operations can be expressed\n+\t by for example transforming ~[3, 5] + [1, 2] to range-only\n+\t operations and a union primitive:\n+\t [-INF, 2] + [1, 2]  U  [5, +INF] + [1, 2]\n+\t [-INF+1, 4]     U    [6, +INF(OVF)]\n+\t though usually the union is not exactly representable with\n+\t a single range or anti-range as the above is\n+\t [-INF+1, +INF(OVF)] intersected with ~[5, 5]\n+\t but one could use a scheme similar to equivalences for this. */\n+      vr->set_varying (expr_type);\n       return;\n     }\n-  else if (code == BIT_AND_EXPR || code == BIT_IOR_EXPR || code == BIT_XOR_EXPR)\n-    {\n-      wide_int may_be_nonzero0, may_be_nonzero1;\n-      wide_int must_be_nonzero0, must_be_nonzero1;\n-      wide_int wmin, wmax;\n-      wide_int vr0_min, vr0_max, vr1_min, vr1_max;\n-      vrp_set_zero_nonzero_bits (expr_type, &vr0,\n-\t\t\t\t &may_be_nonzero0, &must_be_nonzero0);\n-      vrp_set_zero_nonzero_bits (expr_type, &vr1,\n-\t\t\t\t &may_be_nonzero1, &must_be_nonzero1);\n-      extract_range_into_wide_ints (&vr0, expr_type, vr0_min, vr0_max);\n-      extract_range_into_wide_ints (&vr1, expr_type, vr1_min, vr1_max);\n-      if (code == BIT_AND_EXPR)\n-\t{\n-\t  if (wide_int_range_bit_and (wmin, wmax, sign, prec,\n-\t\t\t\t      vr0_min, vr0_max,\n-\t\t\t\t      vr1_min, vr1_max,\n-\t\t\t\t      must_be_nonzero0,\n-\t\t\t\t      may_be_nonzero0,\n-\t\t\t\t      must_be_nonzero1,\n-\t\t\t\t      may_be_nonzero1))\n-\t    {\n-\t      min = wide_int_to_tree (expr_type, wmin);\n-\t      max = wide_int_to_tree (expr_type, wmax);\n-\t      vr->set (VR_RANGE, min, max);\n-\t    }\n-\t  else\n-\t    vr->set_varying (expr_type);\n-\t  return;\n-\t}\n-      else if (code == BIT_IOR_EXPR)\n-\t{\n-\t  if (wide_int_range_bit_ior (wmin, wmax, sign,\n-\t\t\t\t      vr0_min, vr0_max,\n-\t\t\t\t      vr1_min, vr1_max,\n-\t\t\t\t      must_be_nonzero0,\n-\t\t\t\t      may_be_nonzero0,\n-\t\t\t\t      must_be_nonzero1,\n-\t\t\t\t      may_be_nonzero1))\n-\t    {\n-\t      min = wide_int_to_tree (expr_type, wmin);\n-\t      max = wide_int_to_tree (expr_type, wmax);\n-\t      vr->set (VR_RANGE, min, max);\n-\t    }\n-\t  else\n-\t    vr->set_varying (expr_type);\n-\t  return;\n-\t}\n-      else if (code == BIT_XOR_EXPR)\n-\t{\n-\t  if (wide_int_range_bit_xor (wmin, wmax, sign, prec,\n-\t\t\t\t      must_be_nonzero0,\n-\t\t\t\t      may_be_nonzero0,\n-\t\t\t\t      must_be_nonzero1,\n-\t\t\t\t      may_be_nonzero1))\n-\t    {\n-\t      min = wide_int_to_tree (expr_type, wmin);\n-\t      max = wide_int_to_tree (expr_type, wmax);\n-\t      vr->set (VR_RANGE, min, max);\n-\t    }\n-\t  else\n-\t    vr->set_varying (expr_type);\n-\t  return;\n-\t}\n-    }\n-  else\n-    gcc_unreachable ();\n \n   /* If either MIN or MAX overflowed, then set the resulting range to\n      VARYING.  */\n@@ -2075,16 +1751,7 @@ extract_range_from_binary_expr (value_range_base *vr,\n       return;\n     }\n \n-  /* We punt for [-INF, +INF].\n-     We learn nothing when we have INF on both sides.\n-     Note that we do accept [-INF, -INF] and [+INF, +INF].  */\n-  if (vrp_val_is_min (min) && vrp_val_is_max (max))\n-    {\n-      vr->set_varying (expr_type);\n-      return;\n-    }\n-\n-  cmp = compare_values (min, max);\n+  int cmp = compare_values (min, max);\n   if (cmp == -2 || cmp == 1)\n     {\n       /* If the new range has its limits swapped around (MIN > MAX),\n@@ -2093,166 +1760,162 @@ extract_range_from_binary_expr (value_range_base *vr,\n       vr->set_varying (expr_type);\n     }\n   else\n-    vr->set (type, min, max);\n+    vr->set (kind, min, max);\n }\n \n-/* Extract range information from a unary operation CODE based on\n-   the range of its operand *VR0 with type OP0_TYPE with resulting type TYPE.\n-   The resulting range is stored in *VR.  */\n+/* Normalize a value_range for use in range_ops and return it.  */\n \n-void\n-extract_range_from_unary_expr (value_range_base *vr,\n-\t\t\t       enum tree_code code, tree type,\n-\t\t\t       const value_range_base *vr0_, tree op0_type)\n+static value_range_base\n+normalize_for_range_ops (const value_range_base &vr)\n {\n-  signop sign = TYPE_SIGN (type);\n-  unsigned int prec = TYPE_PRECISION (type);\n-  value_range_base vr0 = *vr0_;\n-  value_range_base vrtem0, vrtem1;\n+  tree type = vr.type ();\n \n-  /* VRP only operates on integral and pointer types.  */\n-  if (!(INTEGRAL_TYPE_P (op0_type)\n-\t|| POINTER_TYPE_P (op0_type))\n-      || !(INTEGRAL_TYPE_P (type)\n-\t   || POINTER_TYPE_P (type)))\n+  /* This will return ~[0,0] for [&var, &var].  */\n+  if (POINTER_TYPE_P (type) && !range_includes_zero_p (&vr))\n     {\n-      vr->set_varying (type);\n-      return;\n+      value_range_base temp;\n+      temp.set_nonzero (type);\n+      return temp;\n     }\n+  if (vr.symbolic_p ())\n+    return normalize_for_range_ops (vr.normalize_symbolics ());\n+  if (TREE_CODE (vr.min ()) == INTEGER_CST\n+      && TREE_CODE (vr.max ()) == INTEGER_CST)\n+    return vr;\n+  /* Anything not strictly numeric at this point becomes varying.  */\n+  return value_range_base (vr.type ());\n+}\n \n-  /* If VR0 is UNDEFINED, so is the result.  */\n-  if (vr0.undefined_p ())\n-    {\n-      vr->set_undefined ();\n-      return;\n-    }\n+/* Fold a binary expression of two value_range's with range-ops.  */\n \n-  /* Handle operations that we express in terms of others.  */\n-  if (code == PAREN_EXPR)\n+void\n+range_fold_binary_expr (value_range_base *vr,\n+\t\t\tenum tree_code code,\n+\t\t\ttree expr_type,\n+\t\t\tconst value_range_base *vr0_,\n+\t\t\tconst value_range_base *vr1_)\n+{\n+  if (!value_range_base::supports_type_p (expr_type)\n+      || (!vr0_->undefined_p ()\n+\t  && !value_range_base::supports_type_p (vr0_->type ()))\n+      || (!vr1_->undefined_p ()\n+\t  && !value_range_base::supports_type_p (vr1_->type ())))\n     {\n-      /* PAREN_EXPR and OBJ_TYPE_REF are simple copies.  */\n-      *vr = vr0;\n+      vr->set_varying (expr_type);\n       return;\n     }\n-  else if (code == NEGATE_EXPR)\n+  if (vr0_->undefined_p () && vr1_->undefined_p ())\n     {\n-      /* -X is simply 0 - X, so re-use existing code that also handles\n-         anti-ranges fine.  */\n-      value_range_base zero;\n-      zero.set (build_int_cst (type, 0));\n-      extract_range_from_binary_expr (vr, MINUS_EXPR, type, &zero, &vr0);\n+      vr->set_undefined ();\n       return;\n     }\n-  else if (code == BIT_NOT_EXPR)\n+  range_operator *op = range_op_handler (code, expr_type);\n+  if (!op)\n     {\n-      /* ~X is simply -1 - X, so re-use existing code that also handles\n-         anti-ranges fine.  */\n-      value_range_base minusone;\n-      minusone.set (build_int_cst (type, -1));\n-      extract_range_from_binary_expr (vr, MINUS_EXPR, type, &minusone, &vr0);\n+      vr->set_varying (expr_type);\n       return;\n     }\n \n-  /* Now canonicalize anti-ranges to ranges when they are not symbolic\n-     and express op ~[]  as (op []') U (op []'').  */\n-  if (vr0.kind () == VR_ANTI_RANGE\n-      && ranges_from_anti_range (&vr0, &vrtem0, &vrtem1))\n+  /* Mimic any behavior users of extract_range_from_binary_expr may\n+     expect.  */\n+  value_range_base vr0 = *vr0_, vr1 = *vr1_;\n+  if (vr0.undefined_p ())\n+    vr0.set_varying (expr_type);\n+  else if (vr1.undefined_p ())\n+    vr1.set_varying (expr_type);\n+\n+  /* Handle symbolics.  */\n+  if (vr0.symbolic_p () || vr1.symbolic_p ())\n     {\n-      extract_range_from_unary_expr (vr, code, type, &vrtem0, op0_type);\n-      if (!vrtem1.undefined_p ())\n+      if ((code == PLUS_EXPR || code == MINUS_EXPR))\n \t{\n-\t  value_range_base vrres;\n-\t  extract_range_from_unary_expr (&vrres, code, type,\n-\t\t\t\t\t &vrtem1, op0_type);\n-\t  vr->union_ (&vrres);\n+\t  extract_range_from_plus_minus_expr (vr, code, expr_type,\n+\t\t\t\t\t      &vr0, &vr1);\n+\t  return;\n+\t}\n+      if (POINTER_TYPE_P (expr_type) && code == POINTER_PLUS_EXPR)\n+\t{\n+\t  extract_range_from_pointer_plus_expr (vr, code, expr_type,\n+\t\t\t\t\t\t&vr0, &vr1);\n+\t  return;\n \t}\n-      return;\n     }\n \n-  if (CONVERT_EXPR_CODE_P (code))\n-    {\n-      tree inner_type = op0_type;\n-      tree outer_type = type;\n+  /* Do the range-ops dance.  */\n+  value_range_base n0 = normalize_for_range_ops (vr0);\n+  value_range_base n1 = normalize_for_range_ops (vr1);\n+  *vr = op->fold_range (expr_type, n0, n1);\n+}\n \n-      /* If the expression involves a pointer, we are only interested in\n-\t determining if it evaluates to NULL [0, 0] or non-NULL (~[0, 0]).\n+/* Fold a unary expression of a value_range with range-ops.  */\n \n-\t This may lose precision when converting (char *)~[0,2] to\n-\t int, because we'll forget that the pointer can also not be 1\n-\t or 2.  In practice we don't care, as this is some idiot\n-\t storing a magic constant to a pointer.  */\n-      if (POINTER_TYPE_P (type) || POINTER_TYPE_P (op0_type))\n+void\n+range_fold_unary_expr (value_range_base *vr,\n+\t\t       enum tree_code code, tree expr_type,\n+\t\t       const value_range_base *vr0,\n+\t\t       tree vr0_type)\n+{\n+  /* Mimic any behavior users of extract_range_from_unary_expr may\n+     expect.  */\n+  if (!value_range_base::supports_type_p (expr_type)\n+      || !value_range_base::supports_type_p (vr0_type))\n+    {\n+      vr->set_varying (expr_type);\n+      return;\n+    }\n+  if (vr0->undefined_p ())\n+    {\n+      vr->set_undefined ();\n+      return;\n+    }\n+  range_operator *op = range_op_handler (code, expr_type);\n+  if (!op)\n+    {\n+      vr->set_varying (expr_type);\n+      return;\n+    }\n+\n+  /* Handle symbolics.  */\n+  if (vr0->symbolic_p ())\n+    {\n+      if (code == NEGATE_EXPR)\n \t{\n-\t  if (!range_includes_zero_p (&vr0))\n-\t    vr->set_nonzero (type);\n-\t  else if (vr0.zero_p ())\n-\t    vr->set_zero (type);\n-\t  else\n-\t    vr->set_varying (type);\n+\t  /* -X is simply 0 - X.  */\n+\t  value_range_base zero;\n+\t  zero.set_zero (vr0->type ());\n+\t  range_fold_binary_expr (vr, MINUS_EXPR, expr_type, &zero, vr0);\n \t  return;\n \t}\n-\n-      /* The POINTER_TYPE_P code above will have dealt with all\n-\t pointer anti-ranges.  Any remaining anti-ranges at this point\n-\t will be integer conversions from SSA names that will be\n-\t normalized into VARYING.  For instance: ~[x_55, x_55].  */\n-      gcc_assert (vr0.kind () != VR_ANTI_RANGE\n-\t\t  || TREE_CODE (vr0.min ()) != INTEGER_CST);\n-\n-      /* NOTES: Previously we were returning VARYING for all symbolics, but\n-\t we can do better by treating them as [-MIN, +MAX].  For\n-\t example, converting [SYM, SYM] from INT to LONG UNSIGNED,\n-\t we can return: ~[0x8000000, 0xffffffff7fffffff].\n-\n-\t We were also failing to convert ~[0,0] from char* to unsigned,\n-\t instead choosing to return VR_VARYING.  Now we return ~[0,0].  */\n-      wide_int vr0_min, vr0_max, wmin, wmax;\n-      signop inner_sign = TYPE_SIGN (inner_type);\n-      signop outer_sign = TYPE_SIGN (outer_type);\n-      unsigned inner_prec = TYPE_PRECISION (inner_type);\n-      unsigned outer_prec = TYPE_PRECISION (outer_type);\n-      extract_range_into_wide_ints (&vr0, inner_type, vr0_min, vr0_max);\n-      if (wide_int_range_convert (wmin, wmax,\n-\t\t\t\t  inner_sign, inner_prec,\n-\t\t\t\t  outer_sign, outer_prec,\n-\t\t\t\t  vr0_min, vr0_max))\n+      if (code == BIT_NOT_EXPR)\n \t{\n-\t  tree min = wide_int_to_tree (outer_type, wmin);\n-\t  tree max = wide_int_to_tree (outer_type, wmax);\n-\t  vr->set (VR_RANGE, min, max);\n+\t  /* ~X is simply -1 - X.  */\n+\t  value_range_base minusone;\n+\t  minusone.set (build_int_cst (vr0->type (), -1));\n+\t  range_fold_binary_expr (vr, MINUS_EXPR, expr_type, &minusone, vr0);\n+\t  return;\n \t}\n-      else\n-\tvr->set_varying (outer_type);\n+      *vr = op->fold_range (expr_type,\n+\t\t\t    normalize_for_range_ops (*vr0),\n+\t\t\t    value_range_base (expr_type));\n       return;\n     }\n-  else if (code == ABS_EXPR)\n+  if (CONVERT_EXPR_CODE_P (code) && (POINTER_TYPE_P (expr_type)\n+\t\t\t\t     || POINTER_TYPE_P (vr0->type ())))\n     {\n-      wide_int wmin, wmax;\n-      wide_int vr0_min, vr0_max;\n-      extract_range_into_wide_ints (&vr0, type, vr0_min, vr0_max);\n-      if (wide_int_range_abs (wmin, wmax, sign, prec, vr0_min, vr0_max,\n-\t\t\t      TYPE_OVERFLOW_UNDEFINED (type)))\n-\tvr->set (VR_RANGE, wide_int_to_tree (type, wmin),\n-\t\t wide_int_to_tree (type, wmax));\n+      /* This handles symbolic conversions such such as [25, x_4].  */\n+      if (!range_includes_zero_p (vr0))\n+\tvr->set_nonzero (expr_type);\n+      else if (vr0->zero_p ())\n+\tvr->set_zero (expr_type);\n       else\n-\tvr->set_varying (type);\n-      return;\n-    }\n-  else if (code == ABSU_EXPR)\n-    {\n-      wide_int wmin, wmax;\n-      wide_int vr0_min, vr0_max;\n-      tree signed_type = make_signed_type (TYPE_PRECISION (type));\n-      extract_range_into_wide_ints (&vr0, signed_type, vr0_min, vr0_max);\n-      wide_int_range_absu (wmin, wmax, prec, vr0_min, vr0_max);\n-      vr->set (VR_RANGE, wide_int_to_tree (type, wmin),\n-\t       wide_int_to_tree (type, wmax));\n+\tvr->set_varying (expr_type);\n       return;\n     }\n \n-  /* For unhandled operations fall back to varying.  */\n-  vr->set_varying (type);\n-  return;\n+  /* Do the range-ops dance.  */\n+  value_range_base n0 = normalize_for_range_ops (*vr0);\n+  value_range_base n1 (expr_type);\n+  *vr = op->fold_range (expr_type, n0, n1);\n }\n \n /* Given a COND_EXPR COND of the form 'V OP W', and an SSA name V,\n@@ -6361,18 +6024,18 @@ value_range_base::normalize_symbolics () const\n     {\n       // [SYM, NUM] -> [-MIN, NUM]\n       if (min_symbolic)\n-\treturn value_range_base (VR_RANGE, vrp_val_min (ttype), max ());\n+\treturn value_range_base (VR_RANGE, vrp_val_min (ttype, true), max ());\n       // [NUM, SYM] -> [NUM, +MAX]\n-      return value_range_base (VR_RANGE, min (), vrp_val_max (ttype));\n+      return value_range_base (VR_RANGE, min (), vrp_val_max (ttype, true));\n     }\n-  gcc_assert (kind () == VR_ANTI_RANGE);\n+  gcc_checking_assert (kind () == VR_ANTI_RANGE);\n   // ~[SYM, NUM] -> [NUM + 1, +MAX]\n   if (min_symbolic)\n     {\n       if (!vrp_val_is_max (max ()))\n \t{\n \t  tree n = wide_int_to_tree (ttype, wi::to_wide (max ()) + 1);\n-\t  return value_range_base (VR_RANGE, n, vrp_val_max (ttype));\n+\t  return value_range_base (VR_RANGE, n, vrp_val_max (ttype, true));\n \t}\n       value_range_base var;\n       var.set_varying (ttype);\n@@ -6382,13 +6045,178 @@ value_range_base::normalize_symbolics () const\n   if (!vrp_val_is_min (min ()))\n     {\n       tree n = wide_int_to_tree (ttype, wi::to_wide (min ()) - 1);\n-      return value_range_base (VR_RANGE, vrp_val_min (ttype), n);\n+      return value_range_base (VR_RANGE, vrp_val_min (ttype, true), n);\n     }\n   value_range_base var;\n   var.set_varying (ttype);\n   return var;\n }\n \n+/* Return the number of sub-ranges in a range.  */\n+\n+unsigned\n+value_range_base::num_pairs () const\n+{\n+  if (undefined_p ())\n+    return 0;\n+  if (varying_p ())\n+    return 1;\n+  if (symbolic_p ())\n+    return normalize_symbolics ().num_pairs ();\n+  if (m_kind == VR_ANTI_RANGE)\n+    {\n+      // ~[MIN, X] has one sub-range of [X+1, MAX], and\n+      // ~[X, MAX] has one sub-range of [MIN, X-1].\n+      if (vrp_val_is_min (m_min, true) || vrp_val_is_max (m_max, true))\n+\treturn 1;\n+      return 2;\n+    }\n+  return 1;\n+}\n+\n+/* Return the lower bound for a sub-range.  PAIR is the sub-range in\n+   question.  */\n+\n+wide_int\n+value_range_base::lower_bound (unsigned pair) const\n+{\n+  if (symbolic_p ())\n+    return normalize_symbolics ().lower_bound (pair);\n+\n+  gcc_checking_assert (!undefined_p ());\n+  gcc_checking_assert (pair + 1 <= num_pairs ());\n+  tree t = NULL;\n+  if (m_kind == VR_ANTI_RANGE)\n+    {\n+      tree typ = type ();\n+      if (pair == 1 || vrp_val_is_min (m_min, true))\n+\tt = wide_int_to_tree (typ, wi::to_wide (m_max) + 1);\n+      else\n+\tt = vrp_val_min (typ, true);\n+    }\n+  else\n+    t = m_min;\n+  return wi::to_wide (t);\n+}\n+\n+/* Return the upper bound for a sub-range.  PAIR is the sub-range in\n+   question.  */\n+\n+wide_int\n+value_range_base::upper_bound (unsigned pair) const\n+{\n+  if (symbolic_p ())\n+    return normalize_symbolics ().upper_bound (pair);\n+\n+  gcc_checking_assert (!undefined_p ());\n+  gcc_checking_assert (pair + 1 <= num_pairs ());\n+  tree t = NULL;\n+  if (m_kind == VR_ANTI_RANGE)\n+    {\n+      tree typ = type ();\n+      if (pair == 1 || vrp_val_is_min (m_min, true))\n+\tt = vrp_val_max (typ, true);\n+      else\n+\tt = wide_int_to_tree (typ, wi::to_wide (m_min) - 1);\n+    }\n+  else\n+    t = m_max;\n+  return wi::to_wide (t);\n+}\n+\n+/* Return the highest bound in a range.  */\n+\n+wide_int\n+value_range_base::upper_bound () const\n+{\n+  unsigned pairs = num_pairs ();\n+  gcc_checking_assert (pairs > 0);\n+  return upper_bound (pairs - 1);\n+}\n+\n+/* Return TRUE if range contains INTEGER_CST.  */\n+\n+bool\n+value_range_base::contains_p (tree cst) const\n+{\n+  gcc_checking_assert (TREE_CODE (cst) == INTEGER_CST);\n+  if (symbolic_p ())\n+    return normalize_symbolics ().contains_p (cst);\n+  return value_inside_range (cst) == 1;\n+}\n+\n+/* Return the inverse of a range.  */\n+\n+void\n+value_range_base::invert ()\n+{\n+  if (m_kind == VR_RANGE)\n+    m_kind = VR_ANTI_RANGE;\n+  else if (m_kind == VR_ANTI_RANGE)\n+    m_kind = VR_RANGE;\n+  else\n+    gcc_unreachable ();\n+}\n+\n+/* Range union, but for references.  */\n+\n+void\n+value_range_base::union_ (const value_range_base &r)\n+{\n+  /* Disable details for now, because it makes the ranger dump\n+     unnecessarily verbose.  */\n+  bool details = dump_flags & TDF_DETAILS;\n+  if (details)\n+    dump_flags &= ~TDF_DETAILS;\n+  union_ (&r);\n+  if (details)\n+    dump_flags |= TDF_DETAILS;\n+}\n+\n+/* Range intersect, but for references.  */\n+\n+void\n+value_range_base::intersect (const value_range_base &r)\n+{\n+  /* Disable details for now, because it makes the ranger dump\n+     unnecessarily verbose.  */\n+  bool details = dump_flags & TDF_DETAILS;\n+  if (details)\n+    dump_flags &= ~TDF_DETAILS;\n+  intersect (&r);\n+  if (details)\n+    dump_flags |= TDF_DETAILS;\n+}\n+\n+/* Return TRUE if two types are compatible for range operations.  */\n+\n+static bool\n+range_compatible_p (tree t1, tree t2)\n+{\n+  if (POINTER_TYPE_P (t1) && POINTER_TYPE_P (t2))\n+    return true;\n+\n+  return types_compatible_p (t1, t2);\n+}\n+\n+bool\n+value_range_base::operator== (const value_range_base &r) const\n+{\n+  if (undefined_p ())\n+    return r.undefined_p ();\n+\n+  if (num_pairs () != r.num_pairs ()\n+      || !range_compatible_p (type (), r.type ()))\n+    return false;\n+\n+  for (unsigned p = 0; p < num_pairs (); p++)\n+    if (wi::ne_p (lower_bound (p), r.lower_bound (p))\n+\t|| wi::ne_p (upper_bound (p), r.upper_bound (p)))\n+      return false;\n+\n+  return true;\n+}\n+\n /* Visit all arguments for PHI node PHI that flow through executable\n    edges.  If a valid value range can be derived from all the incoming\n    value ranges, set a new range for the LHS of PHI.  */\n@@ -7039,15 +6867,15 @@ determine_value_range_1 (value_range_base *vr, tree expr)\n       value_range_base vr0, vr1;\n       determine_value_range_1 (&vr0, TREE_OPERAND (expr, 0));\n       determine_value_range_1 (&vr1, TREE_OPERAND (expr, 1));\n-      extract_range_from_binary_expr (vr, TREE_CODE (expr), TREE_TYPE (expr),\n-\t\t\t\t      &vr0, &vr1);\n+      range_fold_binary_expr (vr, TREE_CODE (expr), TREE_TYPE (expr),\n+\t\t\t      &vr0, &vr1);\n     }\n   else if (UNARY_CLASS_P (expr))\n     {\n       value_range_base vr0;\n       determine_value_range_1 (&vr0, TREE_OPERAND (expr, 0));\n-      extract_range_from_unary_expr (vr, TREE_CODE (expr), TREE_TYPE (expr),\n-\t\t\t\t     &vr0, TREE_TYPE (TREE_OPERAND (expr, 0)));\n+      range_fold_unary_expr (vr, TREE_CODE (expr), TREE_TYPE (expr),\n+\t\t\t     &vr0, TREE_TYPE (TREE_OPERAND (expr, 0)));\n     }\n   else if (TREE_CODE (expr) == INTEGER_CST)\n     vr->set (expr);"}, {"sha": "d20d0043ba3b01026afda2df7a064822ed6bcd13", "filename": "gcc/tree-vrp.h", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a734350fd787da1b4bcf9b4e0a99ed2adb5eae/gcc%2Ftree-vrp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a734350fd787da1b4bcf9b4e0a99ed2adb5eae/gcc%2Ftree-vrp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.h?ref=38a734350fd787da1b4bcf9b4e0a99ed2adb5eae", "patch": "@@ -35,14 +35,19 @@ enum value_range_kind\n   VR_LAST\n };\n \n-\n /* Range of values that can be associated with an SSA_NAME after VRP\n    has executed.  */\n class GTY((for_user)) value_range_base\n {\n+  friend void range_tests ();\n public:\n   value_range_base ();\n   value_range_base (value_range_kind, tree, tree);\n+  value_range_base (tree, tree);\n+  value_range_base (value_range_kind,\n+\t\t    tree type, const wide_int &, const wide_int &);\n+  value_range_base (tree type, const wide_int &, const wide_int &);\n+  value_range_base (tree type);\n \n   void set (value_range_kind, tree, tree);\n   void set (tree);\n@@ -63,8 +68,10 @@ class GTY((for_user)) value_range_base\n \n   void union_ (const value_range_base *);\n   void intersect (const value_range_base *);\n+  void union_ (const value_range_base &);\n+  void intersect (const value_range_base &);\n \n-  bool operator== (const value_range_base &) const /* = delete */;\n+  bool operator== (const value_range_base &) const;\n   bool operator!= (const value_range_base &) const /* = delete */;\n   bool equal_p (const value_range_base &) const;\n \n@@ -80,6 +87,14 @@ class GTY((for_user)) value_range_base\n   static bool supports_type_p (tree);\n   value_range_base normalize_symbolics () const;\n \n+  static const unsigned int m_max_pairs = 2;\n+  bool contains_p (tree) const;\n+  unsigned num_pairs () const;\n+  wide_int lower_bound (unsigned = 0) const;\n+  wide_int upper_bound (unsigned) const;\n+  wide_int upper_bound () const;\n+  void invert ();\n+\n protected:\n   void check ();\n   static value_range_base union_helper (const value_range_base *,\n@@ -281,21 +296,17 @@ extern bool range_int_cst_singleton_p (const value_range_base *);\n extern int compare_values (tree, tree);\n extern int compare_values_warnv (tree, tree, bool *);\n extern int operand_less_p (tree, tree);\n-extern bool vrp_val_is_min (const_tree);\n-extern bool vrp_val_is_max (const_tree);\n+extern bool vrp_val_is_min (const_tree, bool handle_pointers = false);\n+extern bool vrp_val_is_max (const_tree, bool handle_pointers = false);\n \n extern tree vrp_val_min (const_tree, bool handle_pointers = false);\n extern tree vrp_val_max (const_tree, bool handle_pointers = false);\n \n-extern void extract_range_from_unary_expr (value_range_base *vr,\n-\t\t\t\t\t   enum tree_code code,\n-\t\t\t\t\t   tree type,\n-\t\t\t\t\t   const value_range_base *vr0_,\n-\t\t\t\t\t   tree op0_type);\n-extern void extract_range_from_binary_expr (value_range_base *,\n-\t\t\t\t\t    enum tree_code,\n-\t\t\t\t\t    tree, const value_range_base *,\n-\t\t\t\t\t    const value_range_base *);\n+void range_fold_unary_expr (value_range_base *, enum tree_code, tree type,\n+\t\t\t    const value_range_base *, tree op0_type);\n+void range_fold_binary_expr (value_range_base *, enum tree_code, tree type,\n+\t\t\t     const value_range_base *,\n+\t\t\t     const value_range_base *);\n \n extern bool vrp_operand_equal_p (const_tree, const_tree);\n extern enum value_range_kind intersect_range_with_nonzero_bits"}, {"sha": "3acbfc607975c0a44b15fac723f7217669d352b4", "filename": "gcc/vr-values.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a734350fd787da1b4bcf9b4e0a99ed2adb5eae/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a734350fd787da1b4bcf9b4e0a99ed2adb5eae/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=38a734350fd787da1b4bcf9b4e0a99ed2adb5eae", "patch": "@@ -46,8 +46,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"case-cfn-macros.h\"\n #include \"alloc-pool.h\"\n #include \"attribs.h\"\n+#include \"range.h\"\n #include \"vr-values.h\"\n #include \"cfghooks.h\"\n+#include \"range-op.h\"\n \n /* Set value range VR to a non-negative range of type TYPE.  */\n \n@@ -803,7 +805,7 @@ vr_values::extract_range_from_binary_expr (value_range *vr,\n \t\t\t   vrp_val_max (expr_type));\n     }\n \n-  ::extract_range_from_binary_expr (vr, code, expr_type, &vr0, &vr1);\n+  range_fold_binary_expr (vr, code, expr_type, &vr0, &vr1);\n \n   /* Set value_range for n in following sequence:\n      def = __builtin_memchr (arg, 0, sz)\n@@ -864,7 +866,7 @@ vr_values::extract_range_from_binary_expr (value_range *vr,\n       else\n \tn_vr1.set (VR_RANGE, op1, op1);\n \n-      ::extract_range_from_binary_expr (vr, code, expr_type, &vr0, &n_vr1);\n+      range_fold_binary_expr (vr, code, expr_type, &vr0, &n_vr1);\n     }\n \n   if (vr->varying_p ()\n@@ -888,7 +890,7 @@ vr_values::extract_range_from_binary_expr (value_range *vr,\n       else\n \tn_vr0.set (op0);\n \n-      ::extract_range_from_binary_expr (vr, code, expr_type, &n_vr0, &vr1);\n+      range_fold_binary_expr (vr, code, expr_type, &n_vr0, &vr1);\n     }\n \n   /* If we didn't derive a range for MINUS_EXPR, and\n@@ -929,7 +931,7 @@ vr_values::extract_range_from_unary_expr (value_range *vr, enum tree_code code,\n   else\n     vr0.set_varying (type);\n \n-  ::extract_range_from_unary_expr (vr, code, type, &vr0, TREE_TYPE (op0));\n+  range_fold_unary_expr (vr, code, type, &vr0, TREE_TYPE (op0));\n }\n \n \n@@ -1427,8 +1429,7 @@ vr_values::extract_range_basic (value_range *vr, gimple *stmt)\n \t\t\t\t\t\t     type, op0);\n \t\t      extract_range_from_unary_expr (&vr1, NOP_EXPR,\n \t\t\t\t\t\t     type, op1);\n-\t\t      ::extract_range_from_binary_expr (vr, subcode, type,\n-\t\t\t\t\t\t\t&vr0, &vr1);\n+\t\t      range_fold_binary_expr (vr, subcode, type, &vr0, &vr1);\n \t\t      flag_wrapv = saved_flag_wrapv;\n \t\t    }\n \t\t  return;"}, {"sha": "90c58f6bb6ecda09a7d86b103d53b1ef62be6d84", "filename": "gcc/wide-int-range.cc", "status": "removed", "additions": 0, "deletions": 865, "changes": 865, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a8c8f4d6578fac21adc0e156861c4b47bed4418/gcc%2Fwide-int-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a8c8f4d6578fac21adc0e156861c4b47bed4418/gcc%2Fwide-int-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int-range.cc?ref=0a8c8f4d6578fac21adc0e156861c4b47bed4418", "patch": "@@ -1,865 +0,0 @@\n-/* Support routines for range operations on wide ints.\n-   Copyright (C) 2018-2019 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tree.h\"\n-#include \"function.h\"\n-#include \"fold-const.h\"\n-#include \"wide-int-range.h\"\n-\n-/* Wrapper around wide_int_binop that adjusts for overflow.\n-\n-   Return true if we can compute the result; i.e. if the operation\n-   doesn't overflow or if the overflow is undefined.  In the latter\n-   case (if the operation overflows and overflow is undefined), then\n-   adjust the result to be -INF or +INF depending on CODE, VAL1 and\n-   VAL2.  Return the value in *RES.\n-\n-   Return false for division by zero, for which the result is\n-   indeterminate.  */\n-\n-static bool\n-wide_int_binop_overflow (wide_int &res,\n-\t\t\t enum tree_code code,\n-\t\t\t const wide_int &w0, const wide_int &w1,\n-\t\t\t signop sign, bool overflow_undefined)\n-{\n-  wi::overflow_type overflow;\n-  if (!wide_int_binop (res, code, w0, w1, sign, &overflow))\n-    return false;\n-\n-  /* If the operation overflowed return -INF or +INF depending on the\n-     operation and the combination of signs of the operands.  */\n-  if (overflow && overflow_undefined)\n-    {\n-      switch (code)\n-\t{\n-\tcase MULT_EXPR:\n-\t  /* For multiplication, the sign of the overflow is given\n-\t     by the comparison of the signs of the operands.  */\n-\t  if (sign == UNSIGNED || w0.sign_mask () == w1.sign_mask ())\n-\t    res = wi::max_value (w0.get_precision (), sign);\n-\t  else\n-\t    res = wi::min_value (w0.get_precision (), sign);\n-\t  return true;\n-\n-\tcase TRUNC_DIV_EXPR:\n-\tcase FLOOR_DIV_EXPR:\n-\tcase CEIL_DIV_EXPR:\n-\tcase EXACT_DIV_EXPR:\n-\tcase ROUND_DIV_EXPR:\n-\t  /* For division, the only case is -INF / -1 = +INF.  */\n-\t  res = wi::max_value (w0.get_precision (), sign);\n-\t  return true;\n-\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n-  return !overflow;\n-}\n-\n-/* For range [LB, UB] compute two wide_int bit masks.\n-\n-   In the MAY_BE_NONZERO bit mask, if some bit is unset, it means that\n-   for all numbers in the range the bit is 0, otherwise it might be 0\n-   or 1.\n-\n-   In the MUST_BE_NONZERO bit mask, if some bit is set, it means that\n-   for all numbers in the range the bit is 1, otherwise it might be 0\n-   or 1.  */\n-\n-void\n-wide_int_range_set_zero_nonzero_bits (signop sign,\n-\t\t\t\t      const wide_int &lb, const wide_int &ub,\n-\t\t\t\t      wide_int &may_be_nonzero,\n-\t\t\t\t      wide_int &must_be_nonzero)\n-{\n-  may_be_nonzero = wi::minus_one (lb.get_precision ());\n-  must_be_nonzero = wi::zero (lb.get_precision ());\n-\n-  if (wi::eq_p (lb, ub))\n-    {\n-      may_be_nonzero = lb;\n-      must_be_nonzero = may_be_nonzero;\n-    }\n-  else if (wi::ge_p (lb, 0, sign) || wi::lt_p (ub, 0, sign))\n-    {\n-      wide_int xor_mask = lb ^ ub;\n-      may_be_nonzero = lb | ub;\n-      must_be_nonzero = lb & ub;\n-      if (xor_mask != 0)\n-\t{\n-\t  wide_int mask = wi::mask (wi::floor_log2 (xor_mask), false,\n-\t\t\t\t    may_be_nonzero.get_precision ());\n-\t  may_be_nonzero = may_be_nonzero | mask;\n-\t  must_be_nonzero = wi::bit_and_not (must_be_nonzero, mask);\n-\t}\n-    }\n-}\n-\n-/* Order 2 sets of wide int ranges (w0/w1, w2/w3) and set MIN/MAX\n-   accordingly.  */\n-\n-static void\n-wide_int_range_order_set (wide_int &min, wide_int &max,\n-\t\t\t  wide_int &w0, wide_int &w1,\n-\t\t\t  wide_int &w2, wide_int &w3,\n-\t\t\t  signop sign)\n-{\n-  /* Order pairs w0,w1 and w2,w3.  */\n-  if (wi::gt_p (w0, w1, sign))\n-    std::swap (w0, w1);\n-  if (wi::gt_p (w2, w3, sign))\n-    std::swap (w2, w3);\n-\n-  /* Choose min and max from the ordered pairs.  */\n-  min = wi::min (w0, w2, sign);\n-  max = wi::max (w1, w3, sign);\n-}\n-\n-/* Calculate the cross product of two sets of ranges (VR0 and VR1) and\n-   store the result in [RES_LB, RES_UB].\n-\n-   CODE is the operation to perform with sign SIGN.\n-\n-   OVERFLOW_UNDEFINED is set if overflow is undefined for the operation type.\n-\n-   Return TRUE if we were able to calculate the cross product.  */\n-\n-bool\n-wide_int_range_cross_product (wide_int &res_lb, wide_int &res_ub,\n-\t\t\t      enum tree_code code, signop sign,\n-\t\t\t      const wide_int &vr0_lb, const wide_int &vr0_ub,\n-\t\t\t      const wide_int &vr1_lb, const wide_int &vr1_ub,\n-\t\t\t      bool overflow_undefined)\n-{\n-  wide_int cp1, cp2, cp3, cp4;\n-\n-  /* Compute the 4 cross operations, bailing if we get an overflow we\n-     can't handle.  */\n-\n-  if (!wide_int_binop_overflow (cp1, code, vr0_lb, vr1_lb, sign,\n-\t\t\t\toverflow_undefined))\n-    return false;\n-\n-  if (wi::eq_p (vr0_lb, vr0_ub))\n-    cp3 = cp1;\n-  else if (!wide_int_binop_overflow (cp3, code, vr0_ub, vr1_lb, sign,\n-\t\t\t\t     overflow_undefined))\n-    return false;\n-\n-  if (wi::eq_p (vr1_lb, vr1_ub))\n-    cp2 = cp1;\n-  else if (!wide_int_binop_overflow (cp2, code, vr0_lb, vr1_ub, sign,\n-\t\t\t\t     overflow_undefined))\n-    return false;\n-\n-  if (wi::eq_p (vr0_lb, vr0_ub))\n-    cp4 = cp2;\n-  else if (!wide_int_binop_overflow (cp4, code, vr0_ub, vr1_ub, sign,\n-\t\t\t\t     overflow_undefined))\n-    return false;\n-\n-  wide_int_range_order_set (res_lb, res_ub, cp1, cp2, cp3, cp4, sign);\n-  return true;\n-}\n-\n-/* Multiply two ranges when TYPE_OVERFLOW_WRAPS:\n-\n-     [RES_LB, RES_UB] = [MIN0, MAX0] * [MIN1, MAX1]\n-\n-   This is basically fancy code so we don't drop to varying with an\n-   unsigned [-3,-1]*[-3,-1].\n-\n-   Return TRUE if we were able to perform the operation.  */\n-\n-bool\n-wide_int_range_mult_wrapping (wide_int &res_lb,\n-\t\t\t      wide_int &res_ub,\n-\t\t\t      signop sign,\n-\t\t\t      unsigned prec,\n-\t\t\t      const wide_int &min0_,\n-\t\t\t      const wide_int &max0_,\n-\t\t\t      const wide_int &min1_,\n-\t\t\t      const wide_int &max1_)\n-{\n-  /* This test requires 2*prec bits if both operands are signed and\n-     2*prec + 2 bits if either is not.  Therefore, extend the values\n-     using the sign of the result to PREC2.  From here on out,\n-     everthing is just signed math no matter what the input types\n-     were.  */\n-  widest2_int min0 = widest2_int::from (min0_, sign);\n-  widest2_int max0 = widest2_int::from (max0_, sign);\n-  widest2_int min1 = widest2_int::from (min1_, sign);\n-  widest2_int max1 = widest2_int::from (max1_, sign);\n-  widest2_int sizem1 = wi::mask <widest2_int> (prec, false);\n-  widest2_int size = sizem1 + 1;\n-\n-  /* Canonicalize the intervals.  */\n-  if (sign == UNSIGNED)\n-    {\n-      if (wi::ltu_p (size, min0 + max0))\n-\t{\n-\t  min0 -= size;\n-\t  max0 -= size;\n-\t}\n-\n-      if (wi::ltu_p (size, min1 + max1))\n-\t{\n-\t  min1 -= size;\n-\t  max1 -= size;\n-\t}\n-    }\n-\n-  widest2_int prod0 = min0 * min1;\n-  widest2_int prod1 = min0 * max1;\n-  widest2_int prod2 = max0 * min1;\n-  widest2_int prod3 = max0 * max1;\n-\n-  /* Sort the 4 products so that min is in prod0 and max is in\n-     prod3.  */\n-  /* min0min1 > max0max1 */\n-  if (prod0 > prod3)\n-    std::swap (prod0, prod3);\n-\n-  /* min0max1 > max0min1 */\n-  if (prod1 > prod2)\n-    std::swap (prod1, prod2);\n-\n-  if (prod0 > prod1)\n-    std::swap (prod0, prod1);\n-\n-  if (prod2 > prod3)\n-    std::swap (prod2, prod3);\n-\n-  /* diff = max - min.  */\n-  prod2 = prod3 - prod0;\n-  if (wi::geu_p (prod2, sizem1))\n-    /* The range covers all values.  */\n-    return false;\n-\n-  res_lb = wide_int::from (prod0, prec, sign);\n-  res_ub = wide_int::from (prod3, prec, sign);\n-  return true;\n-}\n-\n-/* Perform multiplicative operation CODE on two ranges:\n-\n-     [RES_LB, RES_UB] = [VR0_LB, VR0_UB] .CODE. [VR1_LB, VR1_LB]\n-\n-   Return TRUE if we were able to perform the operation.\n-\n-   NOTE: If code is MULT_EXPR and !TYPE_OVERFLOW_UNDEFINED, the resulting\n-   range must be canonicalized by the caller because its components\n-   may be swapped.  */\n-\n-bool\n-wide_int_range_multiplicative_op (wide_int &res_lb, wide_int &res_ub,\n-\t\t\t\t  enum tree_code code,\n-\t\t\t\t  signop sign,\n-\t\t\t\t  unsigned prec,\n-\t\t\t\t  const wide_int &vr0_lb,\n-\t\t\t\t  const wide_int &vr0_ub,\n-\t\t\t\t  const wide_int &vr1_lb,\n-\t\t\t\t  const wide_int &vr1_ub,\n-\t\t\t\t  bool overflow_undefined)\n-{\n-  /* Multiplications, divisions and shifts are a bit tricky to handle,\n-     depending on the mix of signs we have in the two ranges, we\n-     need to operate on different values to get the minimum and\n-     maximum values for the new range.  One approach is to figure\n-     out all the variations of range combinations and do the\n-     operations.\n-\n-     However, this involves several calls to compare_values and it\n-     is pretty convoluted.  It's simpler to do the 4 operations\n-     (MIN0 OP MIN1, MIN0 OP MAX1, MAX0 OP MIN1 and MAX0 OP MAX0 OP\n-     MAX1) and then figure the smallest and largest values to form\n-     the new range.  */\n-  if (code == MULT_EXPR && !overflow_undefined)\n-    return wide_int_range_mult_wrapping (res_lb, res_ub,\n-\t\t\t\t\t sign, prec,\n-\t\t\t\t\t vr0_lb, vr0_ub, vr1_lb, vr1_ub);\n-  return wide_int_range_cross_product (res_lb, res_ub,\n-\t\t\t\t       code, sign,\n-\t\t\t\t       vr0_lb, vr0_ub, vr1_lb, vr1_ub,\n-\t\t\t\t       overflow_undefined);\n-}\n-\n-/* Perform a left shift operation on two ranges:\n-\n-     [RES_LB, RES_UB] = [VR0_LB, VR0_UB] << [VR1_LB, VR1_LB]\n-\n-   Return TRUE if we were able to perform the operation.\n-\n-   NOTE: The resulting range must be canonicalized by the caller\n-   because its contents components may be swapped.  */\n-\n-bool\n-wide_int_range_lshift (wide_int &res_lb, wide_int &res_ub,\n-\t\t       signop sign, unsigned prec,\n-\t\t       const wide_int &vr0_lb, const wide_int &vr0_ub,\n-\t\t       const wide_int &vr1_lb, const wide_int &vr1_ub,\n-\t\t       bool overflow_undefined)\n-{\n-  /* Transform left shifts by constants into multiplies.  */\n-  if (wi::eq_p (vr1_lb, vr1_ub))\n-    {\n-      unsigned shift = vr1_ub.to_uhwi ();\n-      wide_int tmp = wi::set_bit_in_zero (shift, prec);\n-      return wide_int_range_multiplicative_op (res_lb, res_ub,\n-\t\t\t\t\t       MULT_EXPR, sign, prec,\n-\t\t\t\t\t       vr0_lb, vr0_ub, tmp, tmp,\n-\t\t\t\t\t       /*overflow_undefined=*/false);\n-    }\n-\n-  int overflow_pos = prec;\n-  if (sign == SIGNED)\n-    overflow_pos -= 1;\n-  int bound_shift = overflow_pos - vr1_ub.to_shwi ();\n-  /* If bound_shift == HOST_BITS_PER_WIDE_INT, the llshift can\n-     overflow.  However, for that to happen, vr1.max needs to be\n-     zero, which means vr1 is a singleton range of zero, which\n-     means it should be handled by the previous LSHIFT_EXPR\n-     if-clause.  */\n-  wide_int bound = wi::set_bit_in_zero (bound_shift, prec);\n-  wide_int complement = ~(bound - 1);\n-  wide_int low_bound, high_bound;\n-  bool in_bounds = false;\n-  if (sign == UNSIGNED)\n-    {\n-      low_bound = bound;\n-      high_bound = complement;\n-      if (wi::ltu_p (vr0_ub, low_bound))\n-\t{\n-\t  /* [5, 6] << [1, 2] == [10, 24].  */\n-\t  /* We're shifting out only zeroes, the value increases\n-\t     monotonically.  */\n-\t  in_bounds = true;\n-\t}\n-      else if (wi::ltu_p (high_bound, vr0_lb))\n-\t{\n-\t  /* [0xffffff00, 0xffffffff] << [1, 2]\n-\t     == [0xfffffc00, 0xfffffffe].  */\n-\t  /* We're shifting out only ones, the value decreases\n-\t     monotonically.  */\n-\t  in_bounds = true;\n-\t}\n-    }\n-  else\n-    {\n-      /* [-1, 1] << [1, 2] == [-4, 4].  */\n-      low_bound = complement;\n-      high_bound = bound;\n-      if (wi::lts_p (vr0_ub, high_bound)\n-\t  && wi::lts_p (low_bound, vr0_lb))\n-\t{\n-\t  /* For non-negative numbers, we're shifting out only\n-\t     zeroes, the value increases monotonically.\n-\t     For negative numbers, we're shifting out only ones, the\n-\t     value decreases monotomically.  */\n-\t  in_bounds = true;\n-\t}\n-    }\n-  if (in_bounds)\n-    return wide_int_range_multiplicative_op (res_lb, res_ub,\n-\t\t\t\t\t     LSHIFT_EXPR, sign, prec,\n-\t\t\t\t\t     vr0_lb, vr0_ub,\n-\t\t\t\t\t     vr1_lb, vr1_ub,\n-\t\t\t\t\t     overflow_undefined);\n-  return false;\n-}\n-\n-/* Return TRUE if a bit operation on two ranges can be easily\n-   optimized in terms of a mask.\n-\n-   Basically, for BIT_AND_EXPR or BIT_IOR_EXPR see if we can optimize:\n-\n-\t[LB, UB] op Z\n-   into:\n-\t[LB op Z, UB op Z]\n-\n-   It is up to the caller to perform the actual folding above.  */\n-\n-static bool\n-wide_int_range_can_optimize_bit_op (tree_code code,\n-\t\t\t\t    const wide_int &lb, const wide_int &ub,\n-\t\t\t\t    const wide_int &mask)\n-\n-{\n-  if (code != BIT_AND_EXPR && code != BIT_IOR_EXPR)\n-    return false;\n-  /* If Z is a constant which (for op | its bitwise not) has n\n-     consecutive least significant bits cleared followed by m 1\n-     consecutive bits set immediately above it and either\n-     m + n == precision, or (x >> (m + n)) == (y >> (m + n)).\n-\n-     The least significant n bits of all the values in the range are\n-     cleared or set, the m bits above it are preserved and any bits\n-     above these are required to be the same for all values in the\n-     range.  */\n-\n-  wide_int w = mask;\n-  int m = 0, n = 0;\n-  if (code == BIT_IOR_EXPR)\n-    w = ~w;\n-  if (wi::eq_p (w, 0))\n-    n = w.get_precision ();\n-  else\n-    {\n-      n = wi::ctz (w);\n-      w = ~(w | wi::mask (n, false, w.get_precision ()));\n-      if (wi::eq_p (w, 0))\n-\tm = w.get_precision () - n;\n-      else\n-\tm = wi::ctz (w) - n;\n-    }\n-  wide_int new_mask = wi::mask (m + n, true, w.get_precision ());\n-  if ((new_mask & lb) == (new_mask & ub))\n-    return true;\n-\n-  return false;\n-}\n-\n-/* Helper function for wide_int_range_optimize_bit_op.\n-\n-   Calculates bounds and mask for a pair of ranges.  The mask is the\n-   singleton range among the ranges, if any.  The bounds are the\n-   bounds for the remaining range.  */\n-\n-bool\n-wide_int_range_get_mask_and_bounds (wide_int &mask,\n-\t\t\t\t    wide_int &lower_bound,\n-\t\t\t\t    wide_int &upper_bound,\n-\t\t\t\t    const wide_int &vr0_min,\n-\t\t\t\t    const wide_int &vr0_max,\n-\t\t\t\t    const wide_int &vr1_min,\n-\t\t\t\t    const wide_int &vr1_max)\n-{\n-  if (wi::eq_p (vr1_min, vr1_max))\n-    {\n-      mask = vr1_min;\n-      lower_bound = vr0_min;\n-      upper_bound = vr0_max;\n-      return true;\n-    }\n-  else if (wi::eq_p (vr0_min, vr0_max))\n-    {\n-      mask = vr0_min;\n-      lower_bound = vr1_min;\n-      upper_bound = vr1_max;\n-      return true;\n-    }\n-  return false;\n-}\n-\n-/* Optimize a bit operation (BIT_AND_EXPR or BIT_IOR_EXPR) if\n-   possible.  If so, return TRUE and store the result in\n-   [RES_LB, RES_UB].  */\n-\n-bool\n-wide_int_range_optimize_bit_op (wide_int &res_lb, wide_int &res_ub,\n-\t\t\t\tenum tree_code code,\n-\t\t\t\tsignop sign,\n-\t\t\t\tconst wide_int &vr0_min,\n-\t\t\t\tconst wide_int &vr0_max,\n-\t\t\t\tconst wide_int &vr1_min,\n-\t\t\t\tconst wide_int &vr1_max)\n-{\n-  gcc_assert (code == BIT_AND_EXPR || code == BIT_IOR_EXPR);\n-\n-  wide_int lower_bound, upper_bound, mask;\n-  if (!wide_int_range_get_mask_and_bounds (mask, lower_bound, upper_bound,\n-\t\t\t\t\t   vr0_min, vr0_max, vr1_min, vr1_max))\n-    return false;\n-  if (wide_int_range_can_optimize_bit_op (code,\n-\t\t\t\t\t  lower_bound, upper_bound, mask))\n-    {\n-      wi::overflow_type ovf;\n-      wide_int_binop (res_lb, code, lower_bound, mask, sign, &ovf);\n-      wide_int_binop (res_ub, code, upper_bound, mask, sign, &ovf);\n-      return true;\n-    }\n-  return false;\n-}\n-\n-/* Calculate the XOR of two ranges and store the result in [WMIN,WMAX].\n-   The two input ranges are described by their MUST_BE_NONZERO and\n-   MAY_BE_NONZERO bit masks.\n-\n-   Return TRUE if we were able to successfully calculate the new range.  */\n-\n-bool\n-wide_int_range_bit_xor (wide_int &wmin, wide_int &wmax,\n-\t\t\tsignop sign,\n-\t\t\tunsigned prec,\n-\t\t\tconst wide_int &must_be_nonzero0,\n-\t\t\tconst wide_int &may_be_nonzero0,\n-\t\t\tconst wide_int &must_be_nonzero1,\n-\t\t\tconst wide_int &may_be_nonzero1)\n-{\n-  wide_int result_zero_bits = ((must_be_nonzero0 & must_be_nonzero1)\n-\t\t\t       | ~(may_be_nonzero0 | may_be_nonzero1));\n-  wide_int result_one_bits\n-    = (wi::bit_and_not (must_be_nonzero0, may_be_nonzero1)\n-       | wi::bit_and_not (must_be_nonzero1, may_be_nonzero0));\n-  wmax = ~result_zero_bits;\n-  wmin = result_one_bits;\n-  /* If the range has all positive or all negative values, the result\n-     is better than VARYING.  */\n-  if (wi::lt_p (wmin, 0, sign) || wi::ge_p (wmax, 0, sign))\n-    return true;\n-  wmin = wi::min_value (prec, sign);\n-  wmax = wi::max_value (prec, sign);\n-  return false;\n-}\n-\n-/* Calculate the IOR of two ranges and store the result in [WMIN,WMAX].\n-   Return TRUE if we were able to successfully calculate the new range.  */\n-\n-bool\n-wide_int_range_bit_ior (wide_int &wmin, wide_int &wmax,\n-\t\t\tsignop sign,\n-\t\t\tconst wide_int &vr0_min,\n-\t\t\tconst wide_int &vr0_max,\n-\t\t\tconst wide_int &vr1_min,\n-\t\t\tconst wide_int &vr1_max,\n-\t\t\tconst wide_int &must_be_nonzero0,\n-\t\t\tconst wide_int &may_be_nonzero0,\n-\t\t\tconst wide_int &must_be_nonzero1,\n-\t\t\tconst wide_int &may_be_nonzero1)\n-{\n-  if (wide_int_range_optimize_bit_op (wmin, wmax, BIT_IOR_EXPR, sign,\n-\t\t\t\t      vr0_min, vr0_max,\n-\t\t\t\t      vr1_min, vr1_max))\n-    return true;\n-  wmin = must_be_nonzero0 | must_be_nonzero1;\n-  wmax = may_be_nonzero0 | may_be_nonzero1;\n-  /* If the input ranges contain only positive values we can\n-     truncate the minimum of the result range to the maximum\n-     of the input range minima.  */\n-  if (wi::ge_p (vr0_min, 0, sign)\n-      && wi::ge_p (vr1_min, 0, sign))\n-    {\n-      wmin = wi::max (wmin, vr0_min, sign);\n-      wmin = wi::max (wmin, vr1_min, sign);\n-    }\n-  /* If either input range contains only negative values\n-     we can truncate the minimum of the result range to the\n-     respective minimum range.  */\n-  if (wi::lt_p (vr0_max, 0, sign))\n-    wmin = wi::max (wmin, vr0_min, sign);\n-  if (wi::lt_p (vr1_max, 0, sign))\n-    wmin = wi::max (wmin, vr1_min, sign);\n-  /* If the limits got swapped around, indicate error so we can adjust\n-     the range to VARYING.  */\n-  if (wi::gt_p (wmin, wmax,sign))\n-    return false;\n-  return true;\n-}\n-\n-/* Calculate the bitwise AND of two ranges and store the result in [WMIN,WMAX].\n-   Return TRUE if we were able to successfully calculate the new range.  */\n-\n-bool\n-wide_int_range_bit_and (wide_int &wmin, wide_int &wmax,\n-\t\t\tsignop sign,\n-\t\t\tunsigned prec,\n-\t\t\tconst wide_int &vr0_min,\n-\t\t\tconst wide_int &vr0_max,\n-\t\t\tconst wide_int &vr1_min,\n-\t\t\tconst wide_int &vr1_max,\n-\t\t\tconst wide_int &must_be_nonzero0,\n-\t\t\tconst wide_int &may_be_nonzero0,\n-\t\t\tconst wide_int &must_be_nonzero1,\n-\t\t\tconst wide_int &may_be_nonzero1)\n-{\n-  if (wide_int_range_optimize_bit_op (wmin, wmax, BIT_AND_EXPR, sign,\n-\t\t\t\t      vr0_min, vr0_max,\n-\t\t\t\t      vr1_min, vr1_max))\n-    return true;\n-  wmin = must_be_nonzero0 & must_be_nonzero1;\n-  wmax = may_be_nonzero0 & may_be_nonzero1;\n-  /* If both input ranges contain only negative values we can\n-     truncate the result range maximum to the minimum of the\n-     input range maxima.  */\n-  if (wi::lt_p (vr0_max, 0, sign) && wi::lt_p (vr1_max, 0, sign))\n-    {\n-      wmax = wi::min (wmax, vr0_max, sign);\n-      wmax = wi::min (wmax, vr1_max, sign);\n-    }\n-  /* If either input range contains only non-negative values\n-     we can truncate the result range maximum to the respective\n-     maximum of the input range.  */\n-  if (wi::ge_p (vr0_min, 0, sign))\n-    wmax = wi::min (wmax, vr0_max, sign);\n-  if (wi::ge_p (vr1_min, 0, sign))\n-    wmax = wi::min (wmax, vr1_max, sign);\n-  /* PR68217: In case of signed & sign-bit-CST should\n-     result in [-INF, 0] instead of [-INF, INF].  */\n-  if (wi::gt_p (wmin, wmax, sign))\n-    {\n-      wide_int sign_bit = wi::set_bit_in_zero (prec - 1, prec);\n-      if (sign == SIGNED\n-\t  && ((wi::eq_p (vr0_min, vr0_max)\n-\t       && !wi::cmps (vr0_min, sign_bit))\n-\t      || (wi::eq_p (vr1_min, vr1_max)\n-\t\t  && !wi::cmps (vr1_min, sign_bit))))\n-\t{\n-\t  wmin = wi::min_value (prec, sign);\n-\t  wmax = wi::zero (prec);\n-\t}\n-    }\n-  /* If the limits got swapped around, indicate error so we can adjust\n-     the range to VARYING.  */\n-  if (wi::gt_p (wmin, wmax,sign))\n-    return false;\n-  return true;\n-}\n-\n-/* Calculate TRUNC_MOD_EXPR on two ranges and store the result in\n-   [WMIN,WMAX].  */\n-\n-void\n-wide_int_range_trunc_mod (wide_int &wmin, wide_int &wmax,\n-\t\t\t  signop sign,\n-\t\t\t  unsigned prec,\n-\t\t\t  const wide_int &vr0_min,\n-\t\t\t  const wide_int &vr0_max,\n-\t\t\t  const wide_int &vr1_min,\n-\t\t\t  const wide_int &vr1_max)\n-{\n-  wide_int tmp;\n-\n-  /* ABS (A % B) < ABS (B) and either\n-     0 <= A % B <= A or A <= A % B <= 0.  */\n-  wmax = vr1_max - 1;\n-  if (sign == SIGNED)\n-    {\n-      tmp = -1 - vr1_min;\n-      wmax = wi::smax (wmax, tmp);\n-    }\n-\n-  if (sign == UNSIGNED)\n-    wmin = wi::zero (prec);\n-  else\n-    {\n-      wmin = -wmax;\n-      tmp = vr0_min;\n-      if (wi::gts_p (tmp, 0))\n-\ttmp = wi::zero (prec);\n-      wmin = wi::smax (wmin, tmp);\n-    }\n-  tmp = vr0_max;\n-  if (sign == SIGNED && wi::neg_p (tmp))\n-    tmp = wi::zero (prec);\n-  wmax = wi::min (wmax, tmp, sign);\n-}\n-\n-/* Calculate ABS_EXPR on a range and store the result in [MIN, MAX].  */\n-\n-bool\n-wide_int_range_abs (wide_int &min, wide_int &max,\n-\t\t    signop sign, unsigned prec,\n-\t\t    const wide_int &vr0_min, const wide_int &vr0_max,\n-\t\t    bool overflow_undefined)\n-{\n-  /* Pass through VR0 the easy cases.  */\n-  if (sign == UNSIGNED || wi::ge_p (vr0_min, 0, sign))\n-    {\n-      min = vr0_min;\n-      max = vr0_max;\n-      return true;\n-    }\n-\n-  /* -TYPE_MIN_VALUE = TYPE_MIN_VALUE with flag_wrapv so we can't get a\n-     useful range.  */\n-  wide_int min_value = wi::min_value (prec, sign);\n-  wide_int max_value = wi::max_value (prec, sign);\n-  if (!overflow_undefined && wi::eq_p (vr0_min, min_value))\n-    return false;\n-\n-  /* ABS_EXPR may flip the range around, if the original range\n-     included negative values.  */\n-  if (wi::eq_p (vr0_min, min_value))\n-    min = max_value;\n-  else\n-    min = wi::abs (vr0_min);\n-  if (wi::eq_p (vr0_max, min_value))\n-    max = max_value;\n-  else\n-    max = wi::abs (vr0_max);\n-\n-  /* If the range contains zero then we know that the minimum value in the\n-     range will be zero.  */\n-  if (wi::le_p (vr0_min, 0, sign) && wi::ge_p (vr0_max, 0, sign))\n-    {\n-      if (wi::gt_p (min, max, sign))\n-\tmax = min;\n-      min = wi::zero (prec);\n-    }\n-  else\n-    {\n-      /* If the range was reversed, swap MIN and MAX.  */\n-      if (wi::gt_p (min, max, sign))\n-\tstd::swap (min, max);\n-    }\n-\n-  /* If the new range has its limits swapped around (MIN > MAX), then\n-     the operation caused one of them to wrap around.  The only thing\n-     we know is that the result is positive.  */\n-  if (wi::gt_p (min, max, sign))\n-    {\n-      min = wi::zero (prec);\n-      max = max_value;\n-    }\n-  return true;\n-}\n-\n-/* Calculate ABSU_EXPR on a range and store the result in [MIN, MAX].  */\n-\n-void\n-wide_int_range_absu (wide_int &min, wide_int &max,\n-\t\t     unsigned prec, const wide_int &vr0_min,\n-\t\t     const wide_int &vr0_max)\n-{\n-  /* Pass through VR0 the easy cases.  */\n-  if (wi::ges_p (vr0_min, 0))\n-    {\n-      min = vr0_min;\n-      max = vr0_max;\n-      return;\n-    }\n-\n-  min = wi::abs (vr0_min);\n-  max = wi::abs (vr0_max);\n-\n-  /* If the range contains zero then we know that the minimum value in the\n-     range will be zero.  */\n-  if (wi::ges_p (vr0_max, 0))\n-    {\n-      if (wi::gtu_p (min, max))\n-\tmax = min;\n-      min = wi::zero (prec);\n-    }\n-  else\n-    /* Otherwise, swap MIN and MAX.  */\n-    std::swap (min, max);\n-}\n-\n-/* Convert range in [VR0_MIN, VR0_MAX] with INNER_SIGN and INNER_PREC,\n-   to a range in [MIN, MAX] with OUTER_SIGN and OUTER_PREC.\n-\n-   Return TRUE if we were able to successfully calculate the new range.\n-\n-   Caller is responsible for canonicalizing the resulting range.  */\n-\n-bool\n-wide_int_range_convert (wide_int &min, wide_int &max,\n-\t\t\tsignop inner_sign,\n-\t\t\tunsigned inner_prec,\n-\t\t\tsignop outer_sign,\n-\t\t\tunsigned outer_prec,\n-\t\t\tconst wide_int &vr0_min,\n-\t\t\tconst wide_int &vr0_max)\n-{\n-  /* If the conversion is not truncating we can convert the min and\n-     max values and canonicalize the resulting range.  Otherwise we\n-     can do the conversion if the size of the range is less than what\n-     the precision of the target type can represent.  */\n-  if (outer_prec >= inner_prec\n-      || wi::rshift (wi::sub (vr0_max, vr0_min),\n-\t\t     wi::uhwi (outer_prec, inner_prec),\n-\t\t     inner_sign) == 0)\n-    {\n-      min = wide_int::from (vr0_min, outer_prec, inner_sign);\n-      max = wide_int::from (vr0_max, outer_prec, inner_sign);\n-      return (!wi::eq_p (min, wi::min_value (outer_prec, outer_sign))\n-\t      || !wi::eq_p (max, wi::max_value (outer_prec, outer_sign)));\n-    }\n-  return false;\n-}\n-\n-/* Calculate a division operation on two ranges and store the result in\n-   [WMIN, WMAX] U [EXTRA_MIN, EXTRA_MAX].\n-\n-   If EXTRA_RANGE_P is set upon return, EXTRA_MIN/EXTRA_MAX hold\n-   meaningful information, otherwise they should be ignored.\n-\n-   Return TRUE if we were able to successfully calculate the new range.  */\n-\n-bool\n-wide_int_range_div (wide_int &wmin, wide_int &wmax,\n-\t\t    tree_code code, signop sign, unsigned prec,\n-\t\t    const wide_int &dividend_min, const wide_int &dividend_max,\n-\t\t    const wide_int &divisor_min, const wide_int &divisor_max,\n-\t\t    bool overflow_undefined,\n-\t\t    bool &extra_range_p,\n-\t\t    wide_int &extra_min, wide_int &extra_max)\n-{\n-  extra_range_p = false;\n-\n-  /* If we know we won't divide by zero, just do the division.  */\n-  if (!wide_int_range_includes_zero_p (divisor_min, divisor_max, sign))\n-    return wide_int_range_multiplicative_op (wmin, wmax, code, sign, prec,\n-\t\t\t\t\t     dividend_min, dividend_max,\n-\t\t\t\t\t     divisor_min, divisor_max,\n-\t\t\t\t\t     overflow_undefined);\n-\n-  /* If flag_non_call_exceptions, we must not eliminate a division\n-     by zero.  */\n-  if (cfun->can_throw_non_call_exceptions)\n-    return false;\n-\n-  /* If we're definitely dividing by zero, there's nothing to do.  */\n-  if (wide_int_range_zero_p (divisor_min, divisor_max, prec))\n-    return false;\n-\n-  /* Perform the division in 2 parts, [LB, -1] and [1, UB],\n-     which will skip any division by zero.\n-\n-     First divide by the negative numbers, if any.  */\n-  if (wi::neg_p (divisor_min, sign))\n-    {\n-      if (!wide_int_range_multiplicative_op (wmin, wmax,\n-\t\t\t\t\t     code, sign, prec,\n-\t\t\t\t\t     dividend_min, dividend_max,\n-\t\t\t\t\t     divisor_min, wi::minus_one (prec),\n-\t\t\t\t\t     overflow_undefined))\n-\treturn false;\n-      extra_range_p = true;\n-    }\n-  /* Then divide by the non-zero positive numbers, if any.  */\n-  if (wi::gt_p (divisor_max, wi::zero (prec), sign))\n-    {\n-      if (!wide_int_range_multiplicative_op (extra_range_p ? extra_min : wmin,\n-\t\t\t\t\t     extra_range_p ? extra_max : wmax,\n-\t\t\t\t\t     code, sign, prec,\n-\t\t\t\t\t     dividend_min, dividend_max,\n-\t\t\t\t\t     wi::one (prec), divisor_max,\n-\t\t\t\t\t     overflow_undefined))\n-\treturn false;\n-    }\n-  else\n-    extra_range_p = false;\n-  return true;\n-}"}, {"sha": "fc9af72b12732432ef4fd46b993c061f567704d7", "filename": "gcc/wide-int-range.h", "status": "removed", "additions": 0, "deletions": 188, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a8c8f4d6578fac21adc0e156861c4b47bed4418/gcc%2Fwide-int-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a8c8f4d6578fac21adc0e156861c4b47bed4418/gcc%2Fwide-int-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int-range.h?ref=0a8c8f4d6578fac21adc0e156861c4b47bed4418", "patch": "@@ -1,188 +0,0 @@\n-/* Support routines for range operations on wide ints.\n-   Copyright (C) 2018-2019 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_WIDE_INT_RANGE_H\n-#define GCC_WIDE_INT_RANGE_H\n-\n-extern bool wide_int_range_cross_product (wide_int &res_lb, wide_int &res_ub,\n-\t\t\t\t\t  enum tree_code code, signop sign,\n-\t\t\t\t\t  const wide_int &, const wide_int &,\n-\t\t\t\t\t  const wide_int &, const wide_int &,\n-\t\t\t\t\t  bool overflow_undefined);\n-extern bool wide_int_range_mult_wrapping (wide_int &res_lb,\n-\t\t\t\t\t  wide_int &res_ub,\n-\t\t\t\t\t  signop sign,\n-\t\t\t\t\t  unsigned prec,\n-\t\t\t\t\t  const wide_int &min0_,\n-\t\t\t\t\t  const wide_int &max0_,\n-\t\t\t\t\t  const wide_int &min1_,\n-\t\t\t\t\t  const wide_int &max1_);\n-extern bool wide_int_range_multiplicative_op (wide_int &res_lb,\n-\t\t\t\t\t      wide_int &res_ub,\n-\t\t\t\t\t      enum tree_code code,\n-\t\t\t\t\t      signop sign,\n-\t\t\t\t\t      unsigned prec,\n-\t\t\t\t\t      const wide_int &vr0_lb,\n-\t\t\t\t\t      const wide_int &vr0_ub,\n-\t\t\t\t\t      const wide_int &vr1_lb,\n-\t\t\t\t\t      const wide_int &vr1_ub,\n-\t\t\t\t\t      bool overflow_undefined);\n-extern bool wide_int_range_lshift (wide_int &res_lb, wide_int &res_ub,\n-\t\t\t\t   signop sign, unsigned prec,\n-\t\t\t\t   const wide_int &, const wide_int &,\n-\t\t\t\t   const wide_int &, const wide_int &,\n-\t\t\t\t   bool overflow_undefined);\n-extern void wide_int_range_set_zero_nonzero_bits (signop,\n-\t\t\t\t\t\t  const wide_int &lb,\n-\t\t\t\t\t\t  const wide_int &ub,\n-\t\t\t\t\t\t  wide_int &may_be_nonzero,\n-\t\t\t\t\t\t  wide_int &must_be_nonzero);\n-extern bool wide_int_range_optimize_bit_op (wide_int &res_lb, wide_int &res_ub,\n-\t\t\t\t\t    enum tree_code code,\n-\t\t\t\t\t    signop sign,\n-\t\t\t\t\t    const wide_int &vr0_lb,\n-\t\t\t\t\t    const wide_int &vr0_ub,\n-\t\t\t\t\t    const wide_int &vr1_lb,\n-\t\t\t\t\t    const wide_int &vr1_ub);\n-extern bool wide_int_range_get_mask_and_bounds (wide_int &mask,\n-\t\t\t\t\t\twide_int &lower_bound,\n-\t\t\t\t\t\twide_int &upper_bound,\n-\t\t\t\t\t\tconst wide_int &vr0_min,\n-\t\t\t\t\t\tconst wide_int &vr0_max,\n-\t\t\t\t\t\tconst wide_int &vr1_min,\n-\t\t\t\t\t\tconst wide_int &vr1_max);\n-extern bool wide_int_range_bit_xor (wide_int &wmin, wide_int &wmax,\n-\t\t\t\t    signop sign,\n-\t\t\t\t    unsigned prec,\n-\t\t\t\t    const wide_int &must_be_nonzero0,\n-\t\t\t\t    const wide_int &may_be_nonzero0,\n-\t\t\t\t    const wide_int &must_be_nonzero1,\n-\t\t\t\t    const wide_int &may_be_nonzero1);\n-extern bool wide_int_range_bit_ior (wide_int &wmin, wide_int &wmax,\n-\t\t\t\t    signop sign,\n-\t\t\t\t    const wide_int &vr0_min,\n-\t\t\t\t    const wide_int &vr0_max,\n-\t\t\t\t    const wide_int &vr1_min,\n-\t\t\t\t    const wide_int &vr1_max,\n-\t\t\t\t    const wide_int &must_be_nonzero0,\n-\t\t\t\t    const wide_int &may_be_nonzero0,\n-\t\t\t\t    const wide_int &must_be_nonzero1,\n-\t\t\t\t    const wide_int &may_be_nonzero1);\n-extern bool wide_int_range_bit_and (wide_int &wmin, wide_int &wmax,\n-\t\t\t\t    signop sign,\n-\t\t\t\t    unsigned prec,\n-\t\t\t\t    const wide_int &vr0_min,\n-\t\t\t\t    const wide_int &vr0_max,\n-\t\t\t\t    const wide_int &vr1_min,\n-\t\t\t\t    const wide_int &vr1_max,\n-\t\t\t\t    const wide_int &must_be_nonzero0,\n-\t\t\t\t    const wide_int &may_be_nonzero0,\n-\t\t\t\t    const wide_int &must_be_nonzero1,\n-\t\t\t\t    const wide_int &may_be_nonzero1);\n-extern void wide_int_range_trunc_mod (wide_int &wmin, wide_int &wmax,\n-\t\t\t\t      signop sign,\n-\t\t\t\t      unsigned prec,\n-\t\t\t\t      const wide_int &vr0_min,\n-\t\t\t\t      const wide_int &vr0_max,\n-\t\t\t\t      const wide_int &vr1_min,\n-\t\t\t\t      const wide_int &vr1_max);\n-extern bool wide_int_range_abs (wide_int &min, wide_int &max,\n-\t\t\t\tsignop sign, unsigned prec,\n-\t\t\t\tconst wide_int &vr0_min,\n-\t\t\t\tconst wide_int &vr0_max,\n-\t\t\t\tbool overflow_undefined);\n-extern void wide_int_range_absu (wide_int &min, wide_int &max,\n-\t\t\t\t unsigned prec,\n-\t\t\t\t const wide_int &vr0_min,\n-\t\t\t\t const wide_int &vr0_max);\n-extern bool wide_int_range_convert (wide_int &min, wide_int &max,\n-\t\t\t\t    signop inner_sign,\n-\t\t\t\t    unsigned inner_prec,\n-\t\t\t\t    signop outer_sign,\n-\t\t\t\t    unsigned outer_prec,\n-\t\t\t\t    const wide_int &vr0_min,\n-\t\t\t\t    const wide_int &vr0_max);\n-extern bool wide_int_range_div (wide_int &wmin, wide_int &wmax,\n-\t\t\t\tenum tree_code code,\n-\t\t\t\tsignop sign, unsigned prec,\n-\t\t\t\tconst wide_int &dividend_min,\n-\t\t\t\tconst wide_int &dividend_max,\n-\t\t\t\tconst wide_int &divisor_min,\n-\t\t\t\tconst wide_int &divisor_max,\n-\t\t\t\tbool overflow_undefined,\n-\t\t\t\tbool &extra_range_p,\n-\t\t\t\twide_int &extra_min, wide_int &extra_max);\n-\n-/* Return TRUE if shifting by range [MIN, MAX] is undefined behavior,\n-   interpreting MIN and MAX according to SIGN.  */\n-\n-inline bool\n-wide_int_range_shift_undefined_p (signop sign, unsigned prec,\n-\t\t\t\t  const wide_int &min, const wide_int &max)\n-{\n-  /* ?? Note: The original comment said this only applied to\n-     RSHIFT_EXPR, but it was being applied to both left and right\n-     shifts.  */\n-\n-  /* Shifting by any values outside [0..prec-1], gets undefined\n-     behavior from the shift operation.  We cannot even trust\n-     SHIFT_COUNT_TRUNCATED at this stage, because that applies to rtl\n-     shifts, and the operation at the tree level may be widened.  */\n-  return wi::lt_p (min, 0, sign) || wi::ge_p (max, prec, sign);\n-}\n-\n-/* Calculate MIN/MAX_EXPR of two ranges and store the result in [MIN, MAX].  */\n-\n-inline bool\n-wide_int_range_min_max (wide_int &min, wide_int &max,\n-\t\t\ttree_code code,\n-\t\t\tsignop sign, unsigned prec,\n-\t\t\tconst wide_int &vr0_min, const wide_int &vr0_max,\n-\t\t\tconst wide_int &vr1_min, const wide_int &vr1_max)\n-{\n-  wi::overflow_type overflow;\n-  wide_int_binop (min, code, vr0_min, vr1_min, sign, &overflow);\n-  wide_int_binop (max, code, vr0_max, vr1_max, sign, &overflow);\n-  /* If the new range covers the entire domain, that's really no range\n-     at all.  */\n-  if (min == wi::min_value (prec, sign)\n-      && max == wi::max_value (prec, sign))\n-    return false;\n-  return true;\n-}\n-\n-/* Return TRUE if 0 is within [WMIN, WMAX].  */\n-\n-inline bool\n-wide_int_range_includes_zero_p (const wide_int &wmin, const wide_int &wmax,\n-\t\t\t\tsignop sign)\n-{\n-  return wi::le_p (wmin, 0, sign) && wi::ge_p (wmax, 0, sign);\n-}\n-\n-/* Return TRUE if [WMIN, WMAX] is the singleton 0.  */\n-\n-inline bool\n-wide_int_range_zero_p (const wide_int &wmin, const wide_int &wmax,\n-\t\t       unsigned prec)\n-{\n-  return wmin == wmax && wi::eq_p (wmin, wi::zero (prec));\n-}\n-\n-#endif /* GCC_WIDE_INT_RANGE_H */"}]}