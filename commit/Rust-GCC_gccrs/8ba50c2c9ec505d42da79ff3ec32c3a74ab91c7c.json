{"sha": "8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGJhNTBjMmM5ZWM1MDVkNDJkYTc5ZmYzZWMzMmMzYTc0YWI5MWM3Yw==", "commit": {"author": {"name": "Le-Chun Wu", "email": "lcwu@google.com", "date": "2009-05-06T16:22:19Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2009-05-06T16:22:19Z"}, "message": "plugin-support.exp: New file containing support procs for plugin testcases.\n\n2009-05-06  Le-Chun Wu  <lcwu@google.com>\n\n\t* lib/plugin-support.exp: New file containing support procs for\n\tplugin testcases.\n\t* lib/target-supports.exp (check_plugin_available): New proc.\n\t* gcc.dg/plugin/plugin.exp: New driver script for gcc testcases.\n\t* gcc.dg/plugin/selfassign.c: New plugin source file.\n\t* gcc.dg/plugin/self-assign-test-1.c: New test.\n\t* gcc.dg/plugin/self-assign-test-2.c: Likewise.\n\t* g++.dg/README: Add description for plugin test.\n\t* g++.dg/dg.exp: Exclude plugin tests from the general test list.\n\t* g++.dg/plugin/plugin.exp: New driver script for g++ testcases.\n\t* g++.dg/plugin/selfassign.c: New plugin source file.\n\t* g++.dg/plugin/self-assign-test-1.C: New test.\n\t* g++.dg/plugin/self-assign-test-2.C: Likewise.\n\t* g++.dg/plugin/self-assign-test-3.C: Likewise.\n\t* g++.dg/plugin/dumb_plugin.c: New plugin source file.\n\t* g++.dg/plugin/dumb-plugin-test-1.C: New test.\n\nFrom-SVN: r147185", "tree": {"sha": "a5087003f4b4bf7007cadc9c35cb1c45997e3102", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5087003f4b4bf7007cadc9c35cb1c45997e3102"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/comments", "author": null, "committer": null, "parents": [{"sha": "b050b2dec68289dc363907df52e0b558f5443251", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b050b2dec68289dc363907df52e0b558f5443251", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b050b2dec68289dc363907df52e0b558f5443251"}], "stats": {"total": 1370, "additions": 1369, "deletions": 1}, "files": [{"sha": "dec336d70b7f2fbd2179acd5fc909477f207ef8a", "filename": "gcc/plugin.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/gcc%2Fplugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/gcc%2Fplugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fplugin.c?ref=8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c", "patch": "@@ -816,7 +816,6 @@ bool\n plugin_default_version_check (struct plugin_gcc_version *gcc_version,\n \t\t\t      struct plugin_gcc_version *plugin_version)\n {\n-  /* version is NULL if the plugin was not linked with plugin-version.o */\n   if (!gcc_version || !plugin_version)\n     return false;\n "}, {"sha": "2a770f25f1641e835b2228f7d7a3e046d6444819", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c", "patch": "@@ -1,3 +1,22 @@\n+2009-05-06  Le-Chun Wu  <lcwu@google.com>\n+\n+\t* lib/plugin-support.exp: New file containing support procs for\n+\tplugin testcases.\n+\t* lib/target-supports.exp (check_plugin_available): New proc.\n+\t* gcc.dg/plugin/plugin.exp: New driver script for gcc testcases.\n+\t* gcc.dg/plugin/selfassign.c: New plugin source file.\n+\t* gcc.dg/plugin/self-assign-test-1.c: New test.\n+\t* gcc.dg/plugin/self-assign-test-2.c: Likewise.\n+\t* g++.dg/README: Add description for plugin test.\n+\t* g++.dg/dg.exp: Exclude plugin tests from the general test list.\n+\t* g++.dg/plugin/plugin.exp: New driver script for g++ testcases.\n+\t* g++.dg/plugin/selfassign.c: New plugin source file.\n+\t* g++.dg/plugin/self-assign-test-1.C: New test.\n+\t* g++.dg/plugin/self-assign-test-2.C: Likewise.\n+\t* g++.dg/plugin/self-assign-test-3.C: Likewise.\n+\t* g++.dg/plugin/dumb_plugin.c: New plugin source file.\n+\t* g++.dg/plugin/dumb-plugin-test-1.C: New test.\n+\n 2009-05-06  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/40041"}, {"sha": "cdf6b14aee6fb7c477ce9da669fd5a354d3421bc", "filename": "gcc/testsuite/g++.dg/README", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FREADME?ref=8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c", "patch": "@@ -18,6 +18,7 @@ opt\t Tests for fixes of bugs with particular optimizations.\n overload Tests for overload resolution and conversions.\n parse\t Tests for parsing.\n pch\t Tests for precompiled headers.\n+plugin   Tests for plugin support.\n rtti\t Tests for run-time type identification (typeid, dynamic_cast, etc.)\n template Tests for templates.\n tc1\t Tests for Technical Corrigendum 1 conformance."}, {"sha": "a19bc2c2b60573cd30ed99e066c25849d2f6dd7e", "filename": "gcc/testsuite/g++.dg/dg.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdg.exp?ref=8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c", "patch": "@@ -37,6 +37,7 @@ set tests [prune $tests $srcdir/$subdir/compat/*]\n set tests [prune $tests $srcdir/$subdir/debug/*]\n set tests [prune $tests $srcdir/$subdir/gcov/*]\n set tests [prune $tests $srcdir/$subdir/pch/*]\n+set tests [prune $tests $srcdir/$subdir/plugin/*]\n set tests [prune $tests $srcdir/$subdir/special/*]\n set tests [prune $tests $srcdir/$subdir/tls/*]\n set tests [prune $tests $srcdir/$subdir/vect/*]"}, {"sha": "70101c86826e198d49c2417dbb563c476967a2ac", "filename": "gcc/testsuite/g++.dg/plugin/dumb-plugin-test-1.C", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fdumb-plugin-test-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fdumb-plugin-test-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fdumb-plugin-test-1.C?ref=8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c", "patch": "@@ -0,0 +1,53 @@\n+// Test case for the dumb plugin.\n+// { dg-do compile }\n+// { dg-options \"-O -fplugin-arg-dumb_plugin-ref-pass-name=ccp -fplugin-arg-dumb_plugin-ref-pass-instance-num=1\" }\n+\n+class Foo {\n+ private:\n+  int a_;\n+\n+ public:\n+  Foo() : a_(a_) {} // { dg-warning \"Before genericizing function\" }\n+\n+  void setA(int a) {\n+    a_ = a_;\n+  } // { dg-warning \"Before genericizing function\" }\n+\n+  void operator=(Foo& rhs) {\n+    this->a_ = rhs.a_;\n+  } // { dg-warning \"Before genericizing function\" }\n+}; // { dg-warning \"Process struct Foo\" }\n+\n+struct Bar {\n+  int b_;\n+  int c_;\n+}; // { dg-warning \"Process struct Bar\" }\n+\n+int g = g;\n+Foo foo = foo;\n+\n+int func()\n+{\n+  Bar *bar1, bar2;\n+  Foo local_foo;\n+  int x = x;\n+  static int y = y;\n+  float *f;\n+  Bar bar_array[5];\n+  char n;\n+  int overflow;\n+\n+  *f = *f;\n+  bar1->b_ = bar1->b_;\n+  bar2.c_ = bar2.c_;\n+  local_foo = local_foo;\n+  foo = foo;\n+  foo.setA(5);\n+  bar_array[3].c_ = bar_array[3].c_;\n+  bar_array[x+g].b_ = bar_array[x+g].b_;\n+  y = x;\n+  x = y;\n+} // { dg-warning \"Before genericizing function\" }\n+\n+// { dg-warning \"Analyze function\" \"\" { target *-*-* } 50 }\n+// { dg-warning \"End of compilation unit\" \"\" { target *-*-* } 50 }"}, {"sha": "0c62f89e109b6600b2e5d864af5f95ff2675925f", "filename": "gcc/testsuite/g++.dg/plugin/dumb_plugin.c", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fdumb_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fdumb_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fdumb_plugin.c?ref=8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c", "patch": "@@ -0,0 +1,136 @@\n+/* A trivial (dumb) plugin example that shows how to use the GCC plugin\n+   mechanism.  */\n+\n+#include <stdlib.h>\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"tree-pass.h\"\n+#include \"intl.h\"\n+#include \"gcc-plugin.h\"\n+\n+\n+/* Callback function to invoke after GCC finishes parsing a struct.  */\n+\n+void\n+handle_struct (void *event_data, void *data)\n+{\n+  tree type = (tree) event_data;\n+  warning (0, G_(\"Process struct %s\"),\n+           IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))));\n+}\n+\n+/* Callback function to invoke before the program is genericized.  */ \n+\n+void\n+handle_pre_generic (void *event_data, void *data)\n+{\n+  tree fndecl = (tree) event_data;\n+  warning (0, G_(\"Before genericizing function %s\"),\n+           IDENTIFIER_POINTER (DECL_NAME (fndecl)));\n+}\n+\n+/* Callback function to invoke after GCC finishes the compilation unit.  */\n+\n+void\n+handle_end_of_compilation_unit (void *event_data, void *data)\n+{\n+  warning (0, G_(\"End of compilation unit\"));\n+}\n+\n+\n+static unsigned int\n+execute_dumb_plugin_example (void)\n+{\n+  warning (0, G_(\"Analyze function %s\"),\n+           IDENTIFIER_POINTER (DECL_NAME (current_function_decl)));\n+  return 0;\n+}\n+\n+static bool\n+gate_dumb_plugin_example (void)\n+{\n+  return true;\n+}\n+\n+static struct gimple_opt_pass pass_dumb_plugin_example =\n+{\n+  {\n+    GIMPLE_PASS,\n+    \"dumb_plugin_example\",                /* name */\n+    gate_dumb_plugin_example,             /* gate */\n+    execute_dumb_plugin_example,          /* execute */\n+    NULL,                                 /* sub */\n+    NULL,                                 /* next */\n+    0,                                    /* static_pass_number */\n+    0,                                    /* tv_id */\n+    PROP_cfg,                             /* properties_required */\n+    0,                                    /* properties_provided */\n+    0,                                    /* properties_destroyed */\n+    0,                                    /* todo_flags_start */\n+    TODO_dump_func                        /* todo_flags_finish */\n+  }\n+};\n+\n+/* Initialization function that GCC calls. This plugin takes an argument\n+   that specifies the name of the reference pass and an instance number,\n+   both of which determine where the plugin pass should be inserted.  */\n+\n+int\n+plugin_init (const char *plugin_name,\n+             struct plugin_gcc_version *version __attribute__((unused)),\n+             int argc, struct plugin_argument *argv)\n+{\n+  struct plugin_pass pass_info;\n+  char *ref_pass_name = NULL;\n+  int ref_instance_number = 0;\n+  int i;\n+\n+  /* Process the plugin arguments. This plugin takes the following arguments:\n+     ref-pass-name=<PASS_NAME> and ref-pass-instance-num=<NUM>.  */\n+  for (i = 0; i < argc; ++i)\n+    {\n+      if (!strcmp (argv[i].key, \"ref-pass-name\"))\n+        {\n+          if (argv[i].value)\n+            ref_pass_name = argv[i].value;\n+          else\n+            warning (0, G_(\"option '-fplugin-arg-%s-ref-pass-name'\"\n+                           \" requires a pass name\"), plugin_name);\n+        }\n+      else if (!strcmp (argv[i].key, \"ref-pass-instance-num\"))\n+        {\n+          if (argv[i].value)\n+            ref_instance_number = strtol (argv[i].value, NULL, 0);\n+          else\n+            warning (0, G_(\"option '-fplugin-arg-%s-ref-pass-instance-num'\"\n+                           \" requires an integer value\"), plugin_name);\n+        }\n+      else\n+        warning (0, G_(\"plugin %qs: unrecognized argument %qs ignored\"),\n+                 plugin_name, argv[i].key);\n+    }\n+\n+  if (!ref_pass_name)\n+    {\n+      error (G_(\"plugin %qs requires a reference pass name\"), plugin_name);\n+      return 1;\n+    }\n+\n+  pass_info.pass = &pass_dumb_plugin_example.pass;\n+  pass_info.reference_pass_name = ref_pass_name;\n+  pass_info.ref_pass_instance_number = ref_instance_number;\n+  pass_info.pos_op = PASS_POS_INSERT_AFTER;\n+\n+  register_callback (plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL, &pass_info);\n+\n+  register_callback (plugin_name, PLUGIN_FINISH_TYPE, handle_struct, NULL);\n+\n+  register_callback (plugin_name, PLUGIN_CXX_CP_PRE_GENERICIZE,\n+                     handle_pre_generic, NULL);\n+\n+  register_callback (plugin_name, PLUGIN_FINISH_UNIT,\n+                     handle_end_of_compilation_unit, NULL);\n+  return 0;\n+}"}, {"sha": "e1f6d89ae284b127727f18710d1fe81396ab3479", "filename": "gcc/testsuite/g++.dg/plugin/plugin.exp", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fplugin.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fplugin.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fplugin.exp?ref=8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c", "patch": "@@ -0,0 +1,66 @@\n+#   Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Test the functionality of the GCC plugin support\n+\n+load_lib target-supports.exp\n+load_lib g++-dg.exp\n+\n+global TESTING_IN_BUILD_TREE\n+global ENABLE_PLUGIN\n+\n+# The plugin testcases currently only work when the build tree is available.\n+# Also check whether the host supports plugins.\n+if { ![info exists TESTING_IN_BUILD_TREE] || ![info exists ENABLE_PLUGIN] } {\n+    return\n+}\n+\n+# If a testcase doesn't have special options, use these.\n+global DEFAULT_CXXFLAGS\n+if ![info exists DEFAULT_CXXFLAGS] then {\n+    set DEFAULT_CXXFLAGS \" -ansi -pedantic-errors -Wno-long-long\"\n+}\n+\n+# The procedures in plugin-support.exp need these parameters.\n+set default_flags $DEFAULT_CXXFLAGS\n+\n+if $tracelevel then {\n+    strace $tracelevel\n+}\n+\n+# Load support procs.\n+load_lib plugin-support.exp\n+\n+# Specify the plugin source file and the associated test files in a list.\n+# plugin_test_list={ {plugin1 test1 test2 ...} {plugin2 test1 ...} ... }\n+set plugin_test_list [list \\\n+    { selfassign.c self-assign-test-1.C self-assign-test-2.C self-assign-test-3.C } \\\n+    { dumb_plugin.c dumb-plugin-test-1.C } ]\n+\n+foreach plugin_test $plugin_test_list {\n+    # Replace each source file with its full-path name\n+    for {set i 0} {$i < [llength $plugin_test]} {incr i} {\n+\tset basename [lindex $plugin_test $i]\n+\tset plugin_test [lreplace $plugin_test $i $i $srcdir/$subdir/$basename]\n+    }\n+    set plugin_src [lindex $plugin_test 0]\n+    # If we're only testing specific files and this isn't one of them, skip it.\n+    if ![runtest_file_p $runtests $plugin_src] then {\n+        continue\n+    }\n+    set plugin_input_tests [lreplace $plugin_test 0 0]\n+    plugin-test-execute $plugin_src $plugin_input_tests\n+}"}, {"sha": "607381fb403ccfefeaa146b69ae752f7b0b66e48", "filename": "gcc/testsuite/g++.dg/plugin/self-assign-test-1.C", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fself-assign-test-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fself-assign-test-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fself-assign-test-1.C?ref=8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c", "patch": "@@ -0,0 +1,50 @@\n+// Test the self-assignemnt detection plugin.\n+// { dg-do compile }\n+// { dg-options \"-O\" }\n+\n+class Foo {\n+ private:\n+  int a_;\n+\n+ public:\n+  Foo() : a_(a_) {} // { dg-warning \"assigned to itself\" }\n+\n+  void setA(int a) {\n+    a_ = a_; // { dg-warning \"assigned to itself\" }\n+  }\n+\n+  void operator=(Foo& rhs) {\n+    this->a_ = rhs.a_;\n+  }\n+};\n+\n+struct Bar {\n+  int b_;\n+  int c_;\n+};\n+\n+int g = g; // { dg-warning \"assigned to itself\" }\n+Foo foo = foo; // { dg-warning \"assigned to itself\" }\n+\n+int func()\n+{\n+  Bar *bar1, bar2;\n+  Foo local_foo;\n+  int x = x; // { dg-warning \"assigned to itself\" }\n+  static int y = y; // { dg-warning \"assigned to itself\" }\n+  float *f;\n+  Bar bar_array[5];\n+  char n;\n+  int overflow;\n+\n+  *f = *f; // { dg-warning \"assigned to itself\" }\n+  bar1->b_ = bar1->b_; // { dg-warning \"assigned to itself\" }\n+  bar2.c_ = bar2.c_; // { dg-warning \"assigned to itself\" }\n+  local_foo = local_foo; // { dg-warning \"assigned to itself\" }\n+  foo = foo; // { dg-warning \"assigned to itself\" }\n+  foo.setA(5);\n+  bar_array[3].c_ = bar_array[3].c_; // { dg-warning \"assigned to itself\" }\n+  bar_array[x+g].b_ = bar_array[x+g].b_; // { dg-warning \"self-assignment detected\" }\n+  y = x;\n+  x = y;\n+}"}, {"sha": "35e1fb8f8938c2dde4cd2b940ae1f47e9cb0a6ca", "filename": "gcc/testsuite/g++.dg/plugin/self-assign-test-2.C", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fself-assign-test-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fself-assign-test-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fself-assign-test-2.C?ref=8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c", "patch": "@@ -0,0 +1,50 @@\n+// Test the self-assignemnt detection plugin without checking of operator-eq.\n+// { dg-do compile }\n+// { dg-options \"-O -fplugin-arg-selfassign-no-check-operator-eq\" }\n+\n+class Foo {\n+ private:\n+  int a_;\n+\n+ public:\n+  Foo() : a_(a_) {} // { dg-warning \"assigned to itself\" }\n+\n+  void setA(int a) {\n+    a_ = a_; // { dg-warning \"assigned to itself\" }\n+  }\n+\n+  void operator=(Foo& rhs) {\n+    this->a_ = rhs.a_;\n+  }\n+};\n+\n+struct Bar {\n+  int b_;\n+  int c_;\n+};\n+\n+int g = g; // { dg-warning \"assigned to itself\" }\n+Foo foo = foo; // { dg-warning \"assigned to itself\" }\n+\n+int func()\n+{\n+  Bar *bar1, bar2;\n+  Foo local_foo;\n+  int x = x; // { dg-warning \"assigned to itself\" }\n+  static int y = y; // { dg-warning \"assigned to itself\" }\n+  float *f;\n+  Bar bar_array[5];\n+  char n;\n+  int overflow;\n+\n+  *f = *f; // { dg-warning \"assigned to itself\" }\n+  bar1->b_ = bar1->b_; // { dg-warning \"assigned to itself\" }\n+  bar2.c_ = bar2.c_; // { dg-warning \"assigned to itself\" }\n+  local_foo = local_foo; // { dg-bogus \"assigned to itself\" }\n+  foo = foo; // { dg-bogus \"assigned to itself\" }\n+  foo.setA(5);\n+  bar_array[3].c_ = bar_array[3].c_; // { dg-warning \"assigned to itself\" }\n+  bar_array[x+g].b_ = bar_array[x+g].b_; // { dg-warning \"self-assignment detected\" }\n+  y = x;\n+  x = y;\n+}"}, {"sha": "e5b354baff225c43b4b909adc9c9e54f49495220", "filename": "gcc/testsuite/g++.dg/plugin/self-assign-test-3.C", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fself-assign-test-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fself-assign-test-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fself-assign-test-3.C?ref=8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c", "patch": "@@ -0,0 +1,50 @@\n+// Test the self-assignemnt detection plugin with the 'disable' argument.\n+// { dg-do compile }\n+// { dg-options \"-O -fplugin-arg-selfassign-disable\" }\n+\n+class Foo {\n+ private:\n+  int a_;\n+\n+ public:\n+  Foo() : a_(a_) {} // { dg-bogus \"assigned to itself\" }\n+\n+  void setA(int a) {\n+    a_ = a_; // { dg-bogus \"assigned to itself\" }\n+  }\n+\n+  void operator=(Foo& rhs) {\n+    this->a_ = rhs.a_;\n+  }\n+};\n+\n+struct Bar {\n+  int b_;\n+  int c_;\n+};\n+\n+int g = g; // { dg-bogus \"assigned to itself\" }\n+Foo foo = foo; // { dg-bogus \"assigned to itself\" }\n+\n+int func()\n+{\n+  Bar *bar1, bar2;\n+  Foo local_foo;\n+  int x = x; // { dg-bogus \"assigned to itself\" }\n+  static int y = y; // { dg-bogus \"assigned to itself\" }\n+  float *f;\n+  Bar bar_array[5];\n+  char n;\n+  int overflow;\n+\n+  *f = *f; // { dg-bogus \"assigned to itself\" }\n+  bar1->b_ = bar1->b_; // { dg-bogus \"assigned to itself\" }\n+  bar2.c_ = bar2.c_; // { dg-bogus \"assigned to itself\" }\n+  local_foo = local_foo; // { dg-bogus \"assigned to itself\" }\n+  foo = foo; // { dg-bogus \"assigned to itself\" }\n+  foo.setA(5);\n+  bar_array[3].c_ = bar_array[3].c_; // { dg-bogus \"assigned to itself\" }\n+  bar_array[x+g].b_ = bar_array[x+g].b_; // { dg-bogus \"self-assignment detected\" }\n+  y = x;\n+  x = y;\n+}"}, {"sha": "6fbce83c01d5139fcb6191fe27e15ba124e5deda", "filename": "gcc/testsuite/g++.dg/plugin/selfassign.c", "status": "added", "additions": 365, "deletions": 0, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fselfassign.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fselfassign.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fselfassign.c?ref=8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c", "patch": "@@ -0,0 +1,365 @@\n+/* This plugin contains an analysis pass that detects and warns about\n+   self-assignment statements.  */\n+/* { dg-options \"-O\" } */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"toplev.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"tree.h\"\n+#include \"tree-pass.h\"\n+#include \"intl.h\"\n+#include \"gcc-plugin.h\"\n+\n+\n+/* Indicate whether to check overloaded operator '=', which is performed by\n+   default. To disable it, use -fplugin-arg-NAME-no-check-operator-eq.  */\n+bool check_operator_eq = true;\n+\n+/* Given a rhs EXPR of a gimple assign statement, if it is\n+   - SSA_NAME : returns its var decl, or, if it is a temp variable,\n+                returns the rhs of its SSA def statement.\n+   - VAR_DECL, PARM_DECL, FIELD_DECL, or a reference expression :\n+                returns EXPR itself.\n+   - any other expression : returns NULL_TREE.  */\n+\n+static tree\n+get_real_ref_rhs (tree expr)\n+{\n+  switch (TREE_CODE (expr))\n+    {\n+      case SSA_NAME:\n+        {\n+          /* Given a self-assign statement, say foo.x = foo.x,\n+             the IR (after SSA) looks like:\n+\n+             D.1797_14 = foo.x;\n+             foo.x ={v} D.1797_14;\n+\n+             So if the rhs EXPR is an SSA_NAME of a temp variable,\n+             e.g. D.1797_14, we need to grab the rhs of its SSA def\n+             statement (i.e. foo.x).  */\n+          tree vdecl = SSA_NAME_VAR (expr);\n+          if (DECL_ARTIFICIAL (vdecl)\n+              && !gimple_nop_p (SSA_NAME_DEF_STMT (expr)))\n+            {\n+              gimple def_stmt = SSA_NAME_DEF_STMT (expr);\n+              /* We are only interested in an assignment with a single\n+                 rhs operand because if it is not, the original assignment\n+                 will not possibly be a self-assignment.  */\n+              if (is_gimple_assign (def_stmt)\n+                  && (get_gimple_rhs_class (gimple_assign_rhs_code (def_stmt))\n+                      == GIMPLE_SINGLE_RHS))\n+                return get_real_ref_rhs (gimple_assign_rhs1 (def_stmt));\n+              else\n+                return NULL_TREE;\n+            }\n+          else\n+            return vdecl;\n+        }\n+      case VAR_DECL:\n+      case PARM_DECL:\n+      case FIELD_DECL:\n+      case COMPONENT_REF:\n+      case INDIRECT_REF:\n+      case ARRAY_REF:\n+        return expr;\n+      default:\n+        return NULL_TREE;\n+    }\n+}\n+\n+/* Given an expression tree, EXPR, that may contains SSA names, returns an\n+   equivalent tree with the SSA names converted to var/parm/field decls\n+   so that it can be used with '%E' format modifier when emitting warning\n+   messages.\n+\n+   This function currently only supports VAR/PARM/FIELD_DECL, reference\n+   expressions (COMPONENT_REF, INDIRECT_REF, ARRAY_REF), integer constant,\n+   and SSA_NAME. If EXPR contains any other tree nodes (e.g. an arithmetic\n+   expression appears in array index), NULL_TREE is returned.  */\n+\n+static tree\n+get_non_ssa_expr (tree expr)\n+{\n+  switch (TREE_CODE (expr))\n+    {\n+      case VAR_DECL:\n+      case PARM_DECL:\n+      case FIELD_DECL:\n+        {\n+          if (DECL_NAME (expr))\n+            return expr;\n+          else\n+            return NULL_TREE;\n+        }\n+      case COMPONENT_REF:\n+        {\n+          tree base, orig_base = TREE_OPERAND (expr, 0);\n+          tree component, orig_component = TREE_OPERAND (expr, 1);\n+          base = get_non_ssa_expr (orig_base);\n+          if (!base)\n+            return NULL_TREE;\n+          component = get_non_ssa_expr (orig_component);\n+          if (!component)\n+            return NULL_TREE;\n+          /* If either BASE or COMPONENT is converted, build a new\n+             component reference tree.  */\n+          if (base != orig_base || component != orig_component)\n+            return build3 (COMPONENT_REF, TREE_TYPE (component),\n+                           base, component, NULL_TREE);\n+          else\n+            return expr;\n+        }\n+      case INDIRECT_REF:\n+        {\n+          tree orig_base = TREE_OPERAND (expr, 0);\n+          tree base = get_non_ssa_expr (orig_base);\n+          if (!base)\n+            return NULL_TREE;\n+          /* If BASE is converted, build a new indirect reference tree.  */\n+          if (base != orig_base)\n+            return build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (base)), base);\n+          else\n+            return expr;\n+        }\n+      case ARRAY_REF:\n+        {\n+          tree array, orig_array = TREE_OPERAND (expr, 0);\n+          tree index, orig_index = TREE_OPERAND (expr, 1);\n+          array = get_non_ssa_expr (orig_array);\n+          if (!array)\n+            return NULL_TREE;\n+          index = get_non_ssa_expr (orig_index);\n+          if (!index)\n+            return NULL_TREE;\n+          /* If either ARRAY or INDEX is converted, build a new array\n+             reference tree.  */\n+          if (array != orig_array || index != orig_index)\n+            return build4 (ARRAY_REF, TREE_TYPE (expr), array, index,\n+                           TREE_OPERAND (expr, 2), TREE_OPERAND (expr, 3));\n+          else\n+            return expr;\n+        }\n+      case SSA_NAME:\n+        {\n+          tree vdecl = SSA_NAME_VAR (expr);\n+          if (DECL_ARTIFICIAL (vdecl)\n+              && !gimple_nop_p (SSA_NAME_DEF_STMT (expr)))\n+            {\n+              gimple def_stmt = SSA_NAME_DEF_STMT (expr);\n+              if (is_gimple_assign (def_stmt)\n+                  && (get_gimple_rhs_class (gimple_assign_rhs_code (def_stmt))\n+                      == GIMPLE_SINGLE_RHS))\n+                vdecl = gimple_assign_rhs1 (def_stmt);\n+            }\n+          return get_non_ssa_expr (vdecl);\n+        }\n+      case INTEGER_CST:\n+        return expr;\n+      default:\n+        /* Return NULL_TREE for any other kind of tree nodes.  */\n+        return NULL_TREE;\n+    }\n+}\n+\n+/* Given the LHS and (real) RHS of a gimple assign statement, STMT, check if\n+   they are the same. If so, print a warning message about self-assignment.  */\n+\n+static void\n+compare_and_warn (gimple stmt, tree lhs, tree rhs)\n+{\n+  if (operand_equal_p (lhs, rhs, OEP_PURE_SAME))\n+    {\n+      location_t location;\n+      location = (gimple_has_location (stmt)\n+                  ? gimple_location (stmt)\n+                  : (DECL_P (lhs)\n+                     ? DECL_SOURCE_LOCATION (lhs)\n+                     : input_location));\n+      /* If LHS contains any tree node not currently supported by\n+         get_non_ssa_expr, simply emit a generic warning without\n+         specifying LHS in the message.  */\n+      lhs = get_non_ssa_expr (lhs);\n+      if (lhs)\n+        warning (0, G_(\"%H%qE is assigned to itself\"), &location, lhs);\n+      else\n+        warning (0, G_(\"%Hself-assignment detected\"), &location);\n+    }\n+}\n+\n+/* Check and warn if STMT is a self-assign statement.  */\n+\n+static void\n+warn_self_assign (gimple stmt)\n+{\n+  tree rhs, lhs;\n+\n+  /* Check assigment statement.  */\n+  if (is_gimple_assign (stmt)\n+      && (get_gimple_rhs_class (gimple_assign_rhs_code (stmt))\n+          == GIMPLE_SINGLE_RHS))\n+    {\n+      rhs = get_real_ref_rhs (gimple_assign_rhs1 (stmt));\n+      if (!rhs)\n+        return;\n+\n+      lhs = gimple_assign_lhs (stmt);\n+      if (TREE_CODE (lhs) == SSA_NAME)\n+        {\n+          lhs = SSA_NAME_VAR (lhs);\n+          if (DECL_ARTIFICIAL (lhs))\n+            return;\n+        }\n+\n+      compare_and_warn (stmt, lhs, rhs);\n+    }\n+  /* Check overloaded operator '=' (if enabled).  */\n+  else if (check_operator_eq && is_gimple_call (stmt))\n+    {\n+      tree fdecl = gimple_call_fndecl (stmt);\n+      if (fdecl && (DECL_NAME (fdecl) == maybe_get_identifier (\"operator=\")))\n+        {\n+          /* If 'operator=' takes reference operands, the arguments will be \n+             ADDR_EXPR trees. In this case, just remove the address-taken\n+             operator before we compare the lhs and rhs.  */\n+          lhs = gimple_call_arg (stmt, 0);\n+          if (TREE_CODE (lhs) == ADDR_EXPR)\n+            lhs = TREE_OPERAND (lhs, 0);\n+          rhs = gimple_call_arg (stmt, 1);\n+          if (TREE_CODE (rhs) == ADDR_EXPR)\n+            rhs = TREE_OPERAND (rhs, 0);\n+\n+          compare_and_warn (stmt, lhs, rhs);\n+        }\n+    }\n+}\n+\n+/* Entry point for the self-assignment detection pass.  */\n+\n+static unsigned int\n+execute_warn_self_assign (void)\n+{\n+  gimple_stmt_iterator gsi;\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+        warn_self_assign (gsi_stmt (gsi));\n+    }\n+\n+  return 0;\n+}\n+\n+/* Pass gate function. Currently always returns true.  */\n+\n+static bool\n+gate_warn_self_assign (void)\n+{\n+  return true;\n+}\n+\n+static struct gimple_opt_pass pass_warn_self_assign =\n+{\n+  {\n+    GIMPLE_PASS,\n+    \"warn_self_assign\",                   /* name */\n+    gate_warn_self_assign,                /* gate */\n+    execute_warn_self_assign,             /* execute */\n+    NULL,                                 /* sub */\n+    NULL,                                 /* next */\n+    0,                                    /* static_pass_number */\n+    0,                                    /* tv_id */\n+    PROP_ssa,                             /* properties_required */\n+    0,                                    /* properties_provided */\n+    0,                                    /* properties_destroyed */\n+    0,                                    /* todo_flags_start */\n+    TODO_dump_func                        /* todo_flags_finish */\n+  }\n+};\n+\n+/* The initialization routine exposed to and called by GCC. The spec of this\n+   function is defined in gcc/gcc-plugin.h.\n+\n+   PLUGIN_NAME - name of the plugin (useful for error reporting)\n+   ARGC        - the size of the ARGV array\n+   ARGV        - an array of key-value argument pair\n+\n+   Returns 0 if initialization finishes successfully.\n+\n+   Note that this function needs to be named exactly \"plugin_init\".  */\n+\n+int\n+plugin_init (const char *plugin_name, struct plugin_gcc_version *version,\n+\t     int argc, struct plugin_argument *argv)\n+{\n+  struct plugin_pass pass_info;\n+  bool enabled = true;\n+  int i;\n+\n+  if (!plugin_default_version_check (version, version))\n+    return 1;\n+\n+  /* Self-assign detection should happen after SSA is constructed.  */\n+  pass_info.pass = &pass_warn_self_assign.pass;\n+  pass_info.reference_pass_name = \"ssa\";\n+  pass_info.ref_pass_instance_number = 1;\n+  pass_info.pos_op = PASS_POS_INSERT_AFTER;\n+\n+  /* Process the plugin arguments. This plugin takes the following arguments:\n+     check-operator-eq, no-check-operator-eq, enable, and disable.\n+     By default, the analysis is enabled with 'operator=' checked.  */\n+  for (i = 0; i < argc; ++i)\n+    {\n+      if (!strcmp (argv[i].key, \"check-operator-eq\"))\n+        {\n+          if (argv[i].value)\n+            warning (0, G_(\"option '-fplugin-arg-%s-check-operator-eq=%s'\"\n+                           \" ignored (superfluous '=%s')\"),\n+                     plugin_name, argv[i].value, argv[i].value);\n+          else\n+            check_operator_eq = true;\n+        }\n+      else if (!strcmp (argv[i].key, \"no-check-operator-eq\"))\n+        {\n+          if (argv[i].value)\n+            warning (0, G_(\"option '-fplugin-arg-%s-no-check-operator-eq=%s'\"\n+                           \" ignored (superfluous '=%s')\"),\n+                     plugin_name, argv[i].value, argv[i].value);\n+          else\n+            check_operator_eq = false;\n+        }\n+      else if (!strcmp (argv[i].key, \"enable\"))\n+        {\n+          if (argv[i].value)\n+            warning (0, G_(\"option '-fplugin-arg-%s-enable=%s' ignored\"\n+                           \" (superfluous '=%s')\"),\n+                     plugin_name, argv[i].value, argv[i].value);\n+          else\n+            enabled = true;\n+        }\n+      else if (!strcmp (argv[i].key, \"disable\"))\n+        {\n+          if (argv[i].value)\n+            warning (0, G_(\"option '-fplugin-arg-%s-disable=%s' ignored\"\n+                           \" (superfluous '=%s')\"),\n+                     plugin_name, argv[i].value, argv[i].value);\n+          else\n+            enabled = false;\n+        }\n+      else\n+        warning (0, G_(\"plugin %qs: unrecognized argument %qs ignored\"),\n+                 plugin_name, argv[i].key);\n+    }\n+\n+  /* Register this new pass with GCC if the analysis is enabled.  */\n+  if (enabled)\n+    register_callback (plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL,\n+                       &pass_info);\n+\n+  return 0;\n+}"}, {"sha": "93c0c5cb848ee7f5b240f595e867ae4808c29f0f", "filename": "gcc/testsuite/gcc.dg/plugin/plugin.exp", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp?ref=8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c", "patch": "@@ -0,0 +1,65 @@\n+#   Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Test the functionality of the GCC plugin support\n+\n+load_lib target-supports.exp\n+load_lib gcc-dg.exp\n+\n+global TESTING_IN_BUILD_TREE\n+global ENABLE_PLUGIN\n+\n+# The plugin testcases currently only work when the build tree is available.\n+# Also check whether the host supports plugins.\n+if { ![info exists TESTING_IN_BUILD_TREE] || ![info exists ENABLE_PLUGIN] } {\n+    return\n+}\n+\n+# If a testcase doesn't have special options, use these.\n+global DEFAULT_CFLAGS\n+if ![info exists DEFAULT_CFLAGS] then {\n+    set DEFAULT_CFLAGS \" -ansi -pedantic-errors\"\n+}\n+\n+# The procedures in plugin-support.exp need these parameters.\n+set default_flags $DEFAULT_CFLAGS\n+\n+if $tracelevel then {\n+    strace $tracelevel\n+}\n+\n+# Load support procs.\n+load_lib plugin-support.exp\n+\n+# Specify the plugin source file and the associated test files in a list.\n+# plugin_test_list={ {plugin1 test1 test2 ...} {plugin2 test1 ...} ... }\n+set plugin_test_list [list \\\n+    { selfassign.c self-assign-test-1.c self-assign-test-2.c } ]\n+\n+foreach plugin_test $plugin_test_list {\n+    # Replace each source file with its full-path name\n+    for {set i 0} {$i < [llength $plugin_test]} {incr i} {\n+\tset basename [lindex $plugin_test $i]\n+\tset plugin_test [lreplace $plugin_test $i $i $srcdir/$subdir/$basename]\n+    }\n+    set plugin_src [lindex $plugin_test 0]\n+    # If we're only testing specific files and this isn't one of them, skip it.\n+    if ![runtest_file_p $runtests $plugin_src] then {\n+        continue\n+    }\n+    set plugin_input_tests [lreplace $plugin_test 0 0]\n+    plugin-test-execute $plugin_src $plugin_input_tests\n+}"}, {"sha": "f6dc5240f1eea4b692c55777244cbef617f9f425", "filename": "gcc/testsuite/gcc.dg/plugin/self-assign-test-1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fself-assign-test-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fself-assign-test-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fself-assign-test-1.c?ref=8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c", "patch": "@@ -0,0 +1,23 @@\n+/* Test the self-assignemnt detection plugin.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O\" } */\n+\n+struct Bar {\n+  int b_;\n+  int c_;\n+};\n+\n+int g;\n+\n+int main()\n+{\n+  struct Bar *bar;\n+  int x = x; /* { dg-warning \"assigned to itself\" } */\n+  static int y;\n+  struct Bar b_array[5];\n+\n+  b_array[x+g].b_ = b_array[x+g].b_; /* { dg-warning \"self-assignment detected\" } */\n+  g = g; /* { dg-warning \"assigned to itself\" } */\n+  y = y; /* { dg-warning \"assigned to itself\" } */\n+  bar->b_ = bar->b_; /* { dg-warning \"assigned to itself\" } */\n+}"}, {"sha": "2ede371a69aa885a68208868c7102ec07a3f7fc2", "filename": "gcc/testsuite/gcc.dg/plugin/self-assign-test-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fself-assign-test-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fself-assign-test-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fself-assign-test-2.c?ref=8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c", "patch": "@@ -0,0 +1,23 @@\n+/* Test the self-assignemnt detection plugin with the 'disable' argument.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fplugin-arg-selfassign-disable\" } */\n+\n+struct Bar {\n+  int b_;\n+  int c_;\n+};\n+\n+int g;\n+\n+int main()\n+{\n+  struct Bar *bar;\n+  int x = x; /* { dg-bogus \"assigned to itself\" } */\n+  static int y;\n+  struct Bar b_array[5];\n+\n+  b_array[x+g].b_ = b_array[x+g].b_; /* { dg-bogus \"self-assignment detected\" } */\n+  g = g; /* { dg-bogus \"assigned to itself\" } */\n+  y = y; /* { dg-bogus \"assigned to itself\" } */\n+  bar->b_ = bar->b_; /* { dg-bogus \"assigned to itself\" } */\n+}"}, {"sha": "6fbce83c01d5139fcb6191fe27e15ba124e5deda", "filename": "gcc/testsuite/gcc.dg/plugin/selfassign.c", "status": "added", "additions": 365, "deletions": 0, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fselfassign.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fselfassign.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fselfassign.c?ref=8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c", "patch": "@@ -0,0 +1,365 @@\n+/* This plugin contains an analysis pass that detects and warns about\n+   self-assignment statements.  */\n+/* { dg-options \"-O\" } */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"toplev.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"tree.h\"\n+#include \"tree-pass.h\"\n+#include \"intl.h\"\n+#include \"gcc-plugin.h\"\n+\n+\n+/* Indicate whether to check overloaded operator '=', which is performed by\n+   default. To disable it, use -fplugin-arg-NAME-no-check-operator-eq.  */\n+bool check_operator_eq = true;\n+\n+/* Given a rhs EXPR of a gimple assign statement, if it is\n+   - SSA_NAME : returns its var decl, or, if it is a temp variable,\n+                returns the rhs of its SSA def statement.\n+   - VAR_DECL, PARM_DECL, FIELD_DECL, or a reference expression :\n+                returns EXPR itself.\n+   - any other expression : returns NULL_TREE.  */\n+\n+static tree\n+get_real_ref_rhs (tree expr)\n+{\n+  switch (TREE_CODE (expr))\n+    {\n+      case SSA_NAME:\n+        {\n+          /* Given a self-assign statement, say foo.x = foo.x,\n+             the IR (after SSA) looks like:\n+\n+             D.1797_14 = foo.x;\n+             foo.x ={v} D.1797_14;\n+\n+             So if the rhs EXPR is an SSA_NAME of a temp variable,\n+             e.g. D.1797_14, we need to grab the rhs of its SSA def\n+             statement (i.e. foo.x).  */\n+          tree vdecl = SSA_NAME_VAR (expr);\n+          if (DECL_ARTIFICIAL (vdecl)\n+              && !gimple_nop_p (SSA_NAME_DEF_STMT (expr)))\n+            {\n+              gimple def_stmt = SSA_NAME_DEF_STMT (expr);\n+              /* We are only interested in an assignment with a single\n+                 rhs operand because if it is not, the original assignment\n+                 will not possibly be a self-assignment.  */\n+              if (is_gimple_assign (def_stmt)\n+                  && (get_gimple_rhs_class (gimple_assign_rhs_code (def_stmt))\n+                      == GIMPLE_SINGLE_RHS))\n+                return get_real_ref_rhs (gimple_assign_rhs1 (def_stmt));\n+              else\n+                return NULL_TREE;\n+            }\n+          else\n+            return vdecl;\n+        }\n+      case VAR_DECL:\n+      case PARM_DECL:\n+      case FIELD_DECL:\n+      case COMPONENT_REF:\n+      case INDIRECT_REF:\n+      case ARRAY_REF:\n+        return expr;\n+      default:\n+        return NULL_TREE;\n+    }\n+}\n+\n+/* Given an expression tree, EXPR, that may contains SSA names, returns an\n+   equivalent tree with the SSA names converted to var/parm/field decls\n+   so that it can be used with '%E' format modifier when emitting warning\n+   messages.\n+\n+   This function currently only supports VAR/PARM/FIELD_DECL, reference\n+   expressions (COMPONENT_REF, INDIRECT_REF, ARRAY_REF), integer constant,\n+   and SSA_NAME. If EXPR contains any other tree nodes (e.g. an arithmetic\n+   expression appears in array index), NULL_TREE is returned.  */\n+\n+static tree\n+get_non_ssa_expr (tree expr)\n+{\n+  switch (TREE_CODE (expr))\n+    {\n+      case VAR_DECL:\n+      case PARM_DECL:\n+      case FIELD_DECL:\n+        {\n+          if (DECL_NAME (expr))\n+            return expr;\n+          else\n+            return NULL_TREE;\n+        }\n+      case COMPONENT_REF:\n+        {\n+          tree base, orig_base = TREE_OPERAND (expr, 0);\n+          tree component, orig_component = TREE_OPERAND (expr, 1);\n+          base = get_non_ssa_expr (orig_base);\n+          if (!base)\n+            return NULL_TREE;\n+          component = get_non_ssa_expr (orig_component);\n+          if (!component)\n+            return NULL_TREE;\n+          /* If either BASE or COMPONENT is converted, build a new\n+             component reference tree.  */\n+          if (base != orig_base || component != orig_component)\n+            return build3 (COMPONENT_REF, TREE_TYPE (component),\n+                           base, component, NULL_TREE);\n+          else\n+            return expr;\n+        }\n+      case INDIRECT_REF:\n+        {\n+          tree orig_base = TREE_OPERAND (expr, 0);\n+          tree base = get_non_ssa_expr (orig_base);\n+          if (!base)\n+            return NULL_TREE;\n+          /* If BASE is converted, build a new indirect reference tree.  */\n+          if (base != orig_base)\n+            return build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (base)), base);\n+          else\n+            return expr;\n+        }\n+      case ARRAY_REF:\n+        {\n+          tree array, orig_array = TREE_OPERAND (expr, 0);\n+          tree index, orig_index = TREE_OPERAND (expr, 1);\n+          array = get_non_ssa_expr (orig_array);\n+          if (!array)\n+            return NULL_TREE;\n+          index = get_non_ssa_expr (orig_index);\n+          if (!index)\n+            return NULL_TREE;\n+          /* If either ARRAY or INDEX is converted, build a new array\n+             reference tree.  */\n+          if (array != orig_array || index != orig_index)\n+            return build4 (ARRAY_REF, TREE_TYPE (expr), array, index,\n+                           TREE_OPERAND (expr, 2), TREE_OPERAND (expr, 3));\n+          else\n+            return expr;\n+        }\n+      case SSA_NAME:\n+        {\n+          tree vdecl = SSA_NAME_VAR (expr);\n+          if (DECL_ARTIFICIAL (vdecl)\n+              && !gimple_nop_p (SSA_NAME_DEF_STMT (expr)))\n+            {\n+              gimple def_stmt = SSA_NAME_DEF_STMT (expr);\n+              if (is_gimple_assign (def_stmt)\n+                  && (get_gimple_rhs_class (gimple_assign_rhs_code (def_stmt))\n+                      == GIMPLE_SINGLE_RHS))\n+                vdecl = gimple_assign_rhs1 (def_stmt);\n+            }\n+          return get_non_ssa_expr (vdecl);\n+        }\n+      case INTEGER_CST:\n+        return expr;\n+      default:\n+        /* Return NULL_TREE for any other kind of tree nodes.  */\n+        return NULL_TREE;\n+    }\n+}\n+\n+/* Given the LHS and (real) RHS of a gimple assign statement, STMT, check if\n+   they are the same. If so, print a warning message about self-assignment.  */\n+\n+static void\n+compare_and_warn (gimple stmt, tree lhs, tree rhs)\n+{\n+  if (operand_equal_p (lhs, rhs, OEP_PURE_SAME))\n+    {\n+      location_t location;\n+      location = (gimple_has_location (stmt)\n+                  ? gimple_location (stmt)\n+                  : (DECL_P (lhs)\n+                     ? DECL_SOURCE_LOCATION (lhs)\n+                     : input_location));\n+      /* If LHS contains any tree node not currently supported by\n+         get_non_ssa_expr, simply emit a generic warning without\n+         specifying LHS in the message.  */\n+      lhs = get_non_ssa_expr (lhs);\n+      if (lhs)\n+        warning (0, G_(\"%H%qE is assigned to itself\"), &location, lhs);\n+      else\n+        warning (0, G_(\"%Hself-assignment detected\"), &location);\n+    }\n+}\n+\n+/* Check and warn if STMT is a self-assign statement.  */\n+\n+static void\n+warn_self_assign (gimple stmt)\n+{\n+  tree rhs, lhs;\n+\n+  /* Check assigment statement.  */\n+  if (is_gimple_assign (stmt)\n+      && (get_gimple_rhs_class (gimple_assign_rhs_code (stmt))\n+          == GIMPLE_SINGLE_RHS))\n+    {\n+      rhs = get_real_ref_rhs (gimple_assign_rhs1 (stmt));\n+      if (!rhs)\n+        return;\n+\n+      lhs = gimple_assign_lhs (stmt);\n+      if (TREE_CODE (lhs) == SSA_NAME)\n+        {\n+          lhs = SSA_NAME_VAR (lhs);\n+          if (DECL_ARTIFICIAL (lhs))\n+            return;\n+        }\n+\n+      compare_and_warn (stmt, lhs, rhs);\n+    }\n+  /* Check overloaded operator '=' (if enabled).  */\n+  else if (check_operator_eq && is_gimple_call (stmt))\n+    {\n+      tree fdecl = gimple_call_fndecl (stmt);\n+      if (fdecl && (DECL_NAME (fdecl) == maybe_get_identifier (\"operator=\")))\n+        {\n+          /* If 'operator=' takes reference operands, the arguments will be \n+             ADDR_EXPR trees. In this case, just remove the address-taken\n+             operator before we compare the lhs and rhs.  */\n+          lhs = gimple_call_arg (stmt, 0);\n+          if (TREE_CODE (lhs) == ADDR_EXPR)\n+            lhs = TREE_OPERAND (lhs, 0);\n+          rhs = gimple_call_arg (stmt, 1);\n+          if (TREE_CODE (rhs) == ADDR_EXPR)\n+            rhs = TREE_OPERAND (rhs, 0);\n+\n+          compare_and_warn (stmt, lhs, rhs);\n+        }\n+    }\n+}\n+\n+/* Entry point for the self-assignment detection pass.  */\n+\n+static unsigned int\n+execute_warn_self_assign (void)\n+{\n+  gimple_stmt_iterator gsi;\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+        warn_self_assign (gsi_stmt (gsi));\n+    }\n+\n+  return 0;\n+}\n+\n+/* Pass gate function. Currently always returns true.  */\n+\n+static bool\n+gate_warn_self_assign (void)\n+{\n+  return true;\n+}\n+\n+static struct gimple_opt_pass pass_warn_self_assign =\n+{\n+  {\n+    GIMPLE_PASS,\n+    \"warn_self_assign\",                   /* name */\n+    gate_warn_self_assign,                /* gate */\n+    execute_warn_self_assign,             /* execute */\n+    NULL,                                 /* sub */\n+    NULL,                                 /* next */\n+    0,                                    /* static_pass_number */\n+    0,                                    /* tv_id */\n+    PROP_ssa,                             /* properties_required */\n+    0,                                    /* properties_provided */\n+    0,                                    /* properties_destroyed */\n+    0,                                    /* todo_flags_start */\n+    TODO_dump_func                        /* todo_flags_finish */\n+  }\n+};\n+\n+/* The initialization routine exposed to and called by GCC. The spec of this\n+   function is defined in gcc/gcc-plugin.h.\n+\n+   PLUGIN_NAME - name of the plugin (useful for error reporting)\n+   ARGC        - the size of the ARGV array\n+   ARGV        - an array of key-value argument pair\n+\n+   Returns 0 if initialization finishes successfully.\n+\n+   Note that this function needs to be named exactly \"plugin_init\".  */\n+\n+int\n+plugin_init (const char *plugin_name, struct plugin_gcc_version *version,\n+\t     int argc, struct plugin_argument *argv)\n+{\n+  struct plugin_pass pass_info;\n+  bool enabled = true;\n+  int i;\n+\n+  if (!plugin_default_version_check (version, version))\n+    return 1;\n+\n+  /* Self-assign detection should happen after SSA is constructed.  */\n+  pass_info.pass = &pass_warn_self_assign.pass;\n+  pass_info.reference_pass_name = \"ssa\";\n+  pass_info.ref_pass_instance_number = 1;\n+  pass_info.pos_op = PASS_POS_INSERT_AFTER;\n+\n+  /* Process the plugin arguments. This plugin takes the following arguments:\n+     check-operator-eq, no-check-operator-eq, enable, and disable.\n+     By default, the analysis is enabled with 'operator=' checked.  */\n+  for (i = 0; i < argc; ++i)\n+    {\n+      if (!strcmp (argv[i].key, \"check-operator-eq\"))\n+        {\n+          if (argv[i].value)\n+            warning (0, G_(\"option '-fplugin-arg-%s-check-operator-eq=%s'\"\n+                           \" ignored (superfluous '=%s')\"),\n+                     plugin_name, argv[i].value, argv[i].value);\n+          else\n+            check_operator_eq = true;\n+        }\n+      else if (!strcmp (argv[i].key, \"no-check-operator-eq\"))\n+        {\n+          if (argv[i].value)\n+            warning (0, G_(\"option '-fplugin-arg-%s-no-check-operator-eq=%s'\"\n+                           \" ignored (superfluous '=%s')\"),\n+                     plugin_name, argv[i].value, argv[i].value);\n+          else\n+            check_operator_eq = false;\n+        }\n+      else if (!strcmp (argv[i].key, \"enable\"))\n+        {\n+          if (argv[i].value)\n+            warning (0, G_(\"option '-fplugin-arg-%s-enable=%s' ignored\"\n+                           \" (superfluous '=%s')\"),\n+                     plugin_name, argv[i].value, argv[i].value);\n+          else\n+            enabled = true;\n+        }\n+      else if (!strcmp (argv[i].key, \"disable\"))\n+        {\n+          if (argv[i].value)\n+            warning (0, G_(\"option '-fplugin-arg-%s-disable=%s' ignored\"\n+                           \" (superfluous '=%s')\"),\n+                     plugin_name, argv[i].value, argv[i].value);\n+          else\n+            enabled = false;\n+        }\n+      else\n+        warning (0, G_(\"plugin %qs: unrecognized argument %qs ignored\"),\n+                 plugin_name, argv[i].key);\n+    }\n+\n+  /* Register this new pass with GCC if the analysis is enabled.  */\n+  if (enabled)\n+    register_callback (plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL,\n+                       &pass_info);\n+\n+  return 0;\n+}"}, {"sha": "f9017bb732d0961a2b2f6fc47ca4bd77512a1022", "filename": "gcc/testsuite/lib/plugin-support.exp", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/gcc%2Ftestsuite%2Flib%2Fplugin-support.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c/gcc%2Ftestsuite%2Flib%2Fplugin-support.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fplugin-support.exp?ref=8ba50c2c9ec505d42da79ff3ec32c3a74ab91c7c", "patch": "@@ -0,0 +1,102 @@\n+#   Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+#\n+\n+# This file contains the support procedures for testing the plugin mechanism.\n+\n+load_lib dg.exp\n+load_lib gcc.exp\n+\n+#\n+# plugin-get-options -- process test directives\n+#\n+# SRC is the full pathname of the plugin source file.\n+#\n+proc plugin-get-options { src } {\n+    # dg-options sets a variable called dg-extra-tool-flags.\n+    set dg-extra-tool-flags \"\"\n+\n+    # dg-require-* sets dg-do-what.\n+    upvar dg-do-what dg-do-what \n+\n+    set tmp [dg-get-options $src]\n+    foreach op $tmp {\n+\tset cmd [lindex $op 0]\n+\tif { ![string compare \"dg-options\" $cmd] } {\n+\t    set status [catch \"$op\" errmsg]\n+\t    if { $status != 0 } {\n+\t\tperror \"src: $errmsg for \\\"$op\\\"\\n\"\n+\t\tunresolved \"$src: $errmsg for \\\"$op\\\"\"\n+\t\treturn\n+\t    }\n+\t} else {\n+\t    # Ignore unrecognized dg- commands, but warn about them.\n+\t    warning \"plugin.exp does not support $cmd\"\n+\t}\n+   }\n+\n+    # Return flags to use for compiling the plugin source file\n+    return ${dg-extra-tool-flags}\n+}\n+\n+#\n+# plugin-test-execute -- build the plugin first and then compile the\n+# test files with the plugin.\n+#\n+# PLUGIN_SRC is the full pathname of the plugin source file.\n+# PLUGIN_TESTS is a list of input test source files.\n+#\n+proc plugin-test-execute { plugin_src plugin_tests } {\n+    global srcdir objdir\n+    global verbose\n+    global GMPINC\n+\n+    set basename [file tail $plugin_src]\n+    set base [file rootname $basename]\n+    set plugin_lib $base.so\n+\n+    verbose \"Test the plugin $basename\" 1\n+\n+    # Build the plugin itself\n+    set extra_flags [plugin-get-options $plugin_src]\n+\n+    # Note that the plugin test support currently only works when the GCC\n+    # build tree is available. (We make sure that is the case in plugin.exp.)\n+    # Once we have figured out how/where to package/install GCC header files\n+    # for general plugin support, we should modify the following include paths\n+    # accordingly.\n+    set gcc_srcdir \"$srcdir/../..\"\n+    set gcc_objdir \"$objdir/../../..\"\n+    set includes \"-I. -I${srcdir} -I${gcc_srcdir}/gcc -I${gcc_objdir}/gcc \\\n+                  -I${gcc_srcdir}/include -I${gcc_srcdir}/libcpp/include \\\n+                  -I$GMPINC\"\n+\n+    set optstr \"$includes $extra_flags -DIN_GCC -fPIC -shared\"\n+\n+    set status [target_compile \"$optstr $plugin_src\" \"$plugin_lib\" executable \"\"]\n+    if { \"$status\" != \"\" } {\n+ \tunresolved \"$basename compilation, $optstr\"\n+ \treturn\n+    }\n+\n+    # Compile the input source files with the plugin\n+    global default_flags\n+    set plugin_enabling_flags \"-fplugin=./$plugin_lib\"\n+    dg-runtest $plugin_tests $plugin_enabling_flags $default_flags\n+\n+    # Clean up\n+    remote_file build delete $plugin_lib\n+}"}]}