{"sha": "42b85a5532069a7e2bfdca00fb0d11a7cdbbe61d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJiODVhNTUzMjA2OWE3ZTJiZmRjYTAwZmIwZDExYTdjZGJiZTYxZA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-02-02T04:26:15Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-02-02T04:26:15Z"}, "message": "(expand_builtin): Report overflow if __builtin_args_info arg exceeds one word.\n\n(expand_builtin): Report overflow if __builtin_args_info\narg exceeds one word.\nFix punctuation of error messages.\n\nFrom-SVN: r3400", "tree": {"sha": "d1cfaa8cacef24a47b2b71baaba10bd631ddc656", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1cfaa8cacef24a47b2b71baaba10bd631ddc656"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42b85a5532069a7e2bfdca00fb0d11a7cdbbe61d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42b85a5532069a7e2bfdca00fb0d11a7cdbbe61d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42b85a5532069a7e2bfdca00fb0d11a7cdbbe61d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42b85a5532069a7e2bfdca00fb0d11a7cdbbe61d/comments", "author": null, "committer": null, "parents": [{"sha": "e05d6270945dba101ac083cad46c022ab34871e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e05d6270945dba101ac083cad46c022ab34871e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e05d6270945dba101ac083cad46c022ab34871e9"}], "stats": {"total": 265, "additions": 258, "deletions": 7}, "files": [{"sha": "b1ce3ca66fb29aa0b0fb91529eec667131611345", "filename": "gcc/expr.c", "status": "modified", "additions": 258, "deletions": 7, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42b85a5532069a7e2bfdca00fb0d11a7cdbbe61d/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42b85a5532069a7e2bfdca00fb0d11a7cdbbe61d/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=42b85a5532069a7e2bfdca00fb0d11a7cdbbe61d", "patch": "@@ -2293,6 +2293,257 @@ emit_library_call (va_alist)\n   OK_DEFER_POP;\n }\n \f\n+/* Like emit_library_call except that an extra argument, VALUE,\n+   comes second and says where to store the result.  */\n+\n+void\n+emit_library_call_value (va_alist)\n+     va_dcl\n+{\n+  va_list p;\n+  struct args_size args_size;\n+  register int argnum;\n+  enum machine_mode outmode;\n+  int nargs;\n+  rtx fun;\n+  rtx orgfun;\n+  int inc;\n+  int count;\n+  rtx argblock = 0;\n+  CUMULATIVE_ARGS args_so_far;\n+  struct arg { rtx value; enum machine_mode mode; rtx reg; int partial;\n+\t       struct args_size offset; struct args_size size; };\n+  struct arg *argvec;\n+  int old_inhibit_defer_pop = inhibit_defer_pop;\n+  int no_queue = 0;\n+  rtx use_insns;\n+  rtx value;\n+  rtx mem_value = 0;\n+\n+  va_start (p);\n+  orgfun = fun = va_arg (p, rtx);\n+  value = va_arg (p, rtx);\n+  no_queue = va_arg (p, int);\n+  outmode = va_arg (p, enum machine_mode);\n+  nargs = va_arg (p, int);\n+\n+  /* If this kind of value comes back in memory,\n+     decide where in memory it should come back.  */\n+  if (RETURN_IN_MEMORY (type_for_mode (outmode, 0)))\n+    {\n+      if (GET_CODE (value) == MEM)\n+\tmem_value = value;\n+      else\n+\tmem_value = assign_stack_temp (outmode, GET_MODE_SIZE (outmode), 0);\n+    }\n+\n+  /* ??? Unfinished: must pass the memory address as an argument.  */\n+\n+  /* Copy all the libcall-arguments out of the varargs data\n+     and into a vector ARGVEC.\n+\n+     Compute how to pass each argument.  We only support a very small subset\n+     of the full argument passing conventions to limit complexity here since\n+     library functions shouldn't have many args.  */\n+\n+  argvec = (struct arg *) alloca (nargs * sizeof (struct arg));\n+\n+  INIT_CUMULATIVE_ARGS (args_so_far, NULL_TREE, fun);\n+\n+  args_size.constant = 0;\n+  args_size.var = 0;\n+\n+  for (count = 0; count < nargs; count++)\n+    {\n+      rtx val = va_arg (p, rtx);\n+      enum machine_mode mode = va_arg (p, enum machine_mode);\n+\n+      /* We cannot convert the arg value to the mode the library wants here;\n+\t must do it earlier where we know the signedness of the arg.  */\n+      if (mode == BLKmode\n+\t  || (GET_MODE (val) != mode && GET_MODE (val) != VOIDmode))\n+\tabort ();\n+\n+      /* On some machines, there's no way to pass a float to a library fcn.\n+\t Pass it as a double instead.  */\n+#ifdef LIBGCC_NEEDS_DOUBLE\n+      if (LIBGCC_NEEDS_DOUBLE && mode == SFmode)\n+\tval = convert_to_mode (DFmode, val, 0), mode = DFmode;\n+#endif\n+\n+      /* There's no need to call protect_from_queue, because\n+\t either emit_move_insn or emit_push_insn will do that.  */\n+\n+      /* Make sure it is a reasonable operand for a move or push insn.  */\n+      if (GET_CODE (val) != REG && GET_CODE (val) != MEM\n+\t  && ! (CONSTANT_P (val) && LEGITIMATE_CONSTANT_P (val)))\n+\tval = force_operand (val, NULL_RTX);\n+\n+      argvec[count].value = val;\n+      argvec[count].mode = mode;\n+\n+#ifdef FUNCTION_ARG_PASS_BY_REFERENCE\n+      if (FUNCTION_ARG_PASS_BY_REFERENCE (args_so_far, mode, NULL_TREE, 1))\n+\tabort ();\n+#endif\n+\n+      argvec[count].reg = FUNCTION_ARG (args_so_far, mode, NULL_TREE, 1);\n+      if (argvec[count].reg && GET_CODE (argvec[count].reg) == EXPR_LIST)\n+\tabort ();\n+#ifdef FUNCTION_ARG_PARTIAL_NREGS\n+      argvec[count].partial\n+\t= FUNCTION_ARG_PARTIAL_NREGS (args_so_far, mode, NULL_TREE, 1);\n+#else\n+      argvec[count].partial = 0;\n+#endif\n+\n+      locate_and_pad_parm (mode, NULL_TREE,\n+\t\t\t   argvec[count].reg && argvec[count].partial == 0,\n+\t\t\t   NULL_TREE, &args_size, &argvec[count].offset,\n+\t\t\t   &argvec[count].size);\n+\n+      if (argvec[count].size.var)\n+\tabort ();\n+\n+#ifndef REG_PARM_STACK_SPACE\n+      if (argvec[count].partial)\n+\targvec[count].size.constant -= argvec[count].partial * UNITS_PER_WORD;\n+#endif\n+\n+      if (argvec[count].reg == 0 || argvec[count].partial != 0\n+#ifdef REG_PARM_STACK_SPACE\n+\t  || 1\n+#endif\n+\t  )\n+\targs_size.constant += argvec[count].size.constant;\n+\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n+      /* If this arg is actually passed on the stack, it might be\n+\t clobbering something we already put there (this library call might\n+\t be inside the evaluation of an argument to a function whose call\n+\t requires the stack).  This will only occur when the library call\n+\t has sufficient args to run out of argument registers.  Abort in\n+\t this case; if this ever occurs, code must be added to save and\n+\t restore the arg slot.  */\n+\n+      if (argvec[count].reg == 0 || argvec[count].partial != 0)\n+\tabort ();\n+#endif\n+\n+      FUNCTION_ARG_ADVANCE (args_so_far, mode, (tree)0, 1);\n+    }\n+  va_end (p);\n+\n+  /* If this machine requires an external definition for library\n+     functions, write one out.  */\n+  assemble_external_libcall (fun);\n+\n+#ifdef STACK_BOUNDARY\n+  args_size.constant = (((args_size.constant + (STACK_BYTES - 1))\n+\t\t\t / STACK_BYTES) * STACK_BYTES);\n+#endif\n+\n+#ifdef REG_PARM_STACK_SPACE\n+  args_size.constant = MAX (args_size.constant,\n+\t\t\t    REG_PARM_STACK_SPACE (NULL_TREE));\n+#ifndef OUTGOING_REG_PARM_STACK_SPACE\n+  args_size.constant -= REG_PARM_STACK_SPACE (NULL_TREE);\n+#endif\n+#endif\n+\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n+  if (args_size.constant > current_function_outgoing_args_size)\n+    current_function_outgoing_args_size = args_size.constant;\n+  args_size.constant = 0;\n+#endif\n+\n+#ifndef PUSH_ROUNDING\n+  argblock = push_block (GEN_INT (args_size.constant), 0, 0);\n+#endif\n+\n+#ifdef PUSH_ARGS_REVERSED\n+  inc = -1;\n+  argnum = nargs - 1;\n+#else\n+  inc = 1;\n+  argnum = 0;\n+#endif\n+\n+  /* Push the args that need to be pushed.  */\n+\n+  for (count = 0; count < nargs; count++, argnum += inc)\n+    {\n+      register enum machine_mode mode = argvec[argnum].mode;\n+      register rtx val = argvec[argnum].value;\n+      rtx reg = argvec[argnum].reg;\n+      int partial = argvec[argnum].partial;\n+\n+      if (! (reg != 0 && partial == 0))\n+\temit_push_insn (val, mode, NULL_TREE, NULL_RTX, 0, partial, reg, 0,\n+\t\t\targblock, GEN_INT (argvec[count].offset.constant));\n+      NO_DEFER_POP;\n+    }\n+\n+#ifdef PUSH_ARGS_REVERSED\n+  argnum = nargs - 1;\n+#else\n+  argnum = 0;\n+#endif\n+\n+  /* Now load any reg parms into their regs.  */\n+\n+  for (count = 0; count < nargs; count++, argnum += inc)\n+    {\n+      register enum machine_mode mode = argvec[argnum].mode;\n+      register rtx val = argvec[argnum].value;\n+      rtx reg = argvec[argnum].reg;\n+      int partial = argvec[argnum].partial;\n+\n+      if (reg != 0 && partial == 0)\n+\temit_move_insn (reg, val);\n+      NO_DEFER_POP;\n+    }\n+\n+  /* For version 1.37, try deleting this entirely.  */\n+  if (! no_queue)\n+    emit_queue ();\n+\n+  /* Any regs containing parms remain in use through the call.  */\n+  start_sequence ();\n+  for (count = 0; count < nargs; count++)\n+    if (argvec[count].reg != 0)\n+      emit_insn (gen_rtx (USE, VOIDmode, argvec[count].reg));\n+\n+  use_insns = get_insns ();\n+  end_sequence ();\n+\n+  fun = prepare_call_address (fun, NULL_TREE, &use_insns);\n+\n+  /* Don't allow popping to be deferred, since then\n+     cse'ing of library calls could delete a call and leave the pop.  */\n+  NO_DEFER_POP;\n+\n+  /* We pass the old value of inhibit_defer_pop + 1 to emit_call_1, which\n+     will set inhibit_defer_pop to that value.  */\n+\n+  emit_call_1 (fun, get_identifier (XSTR (orgfun, 0)), args_size.constant, 0,\n+\t       FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1),\n+\t       outmode != VOIDmode ? hard_libcall_value (outmode) : NULL_RTX,\n+\t       old_inhibit_defer_pop + 1, use_insns, no_queue);\n+\n+  /* Now restore inhibit_defer_pop to its actual original value.  */\n+  OK_DEFER_POP;\n+\n+  /* Copy the value to the right place.  */\n+  if (mem_value)\n+    {\n+      if (value != mem_value)\n+\temit_move_insn (value, mem_value);\n+    }\n+  else\n+    emit_move_insn (value, hard_libcall_value (outmode));\n+}\n+\f\n /* Expand an assignment that stores the value of FROM into TO.\n    If WANT_VALUE is nonzero, return an rtx for the value of TO.\n    (This may contain a QUEUED rtx.)\n@@ -5795,19 +6046,19 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t  {\n \t    tree arg = TREE_VALUE (arglist);\n \t    if (TREE_CODE (arg) != INTEGER_CST)\n-\t      error (\"argument of __builtin_args_info must be constant\");\n+\t      error (\"argument of `__builtin_args_info' must be constant\");\n \t    else\n \t      {\n \t\tint wordnum = TREE_INT_CST_LOW (arg);\n \n-\t\tif (wordnum < 0 || wordnum >= nwords)\n-\t\t  error (\"argument of __builtin_args_info out of range\");\n+\t\tif (wordnum < 0 || wordnum >= nwords || TREE_INT_CST_HIGH (arg))\n+\t\t  error (\"argument of `__builtin_args_info' out of range\");\n \t\telse\n \t\t  return GEN_INT (word_ptr[wordnum]);\n \t      }\n \t  }\n \telse\n-\t  error (\"missing argument in __builtin_args_info\");\n+\t  error (\"missing argument in `__builtin_args_info'\");\n \n \treturn const0_rtx;\n \n@@ -5910,12 +6161,12 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \treturn const0_rtx;\n       else if (TREE_CODE (TREE_VALUE (arglist)) != INTEGER_CST)\n \t{\n-\t  error (\"invalid arg to __builtin_return_address\");\n+\t  error (\"invalid arg to `__builtin_return_address'\");\n \t  return const0_rtx;\n \t}\n       else if (tree_int_cst_lt (TREE_VALUE (arglist), integer_zero_node))\n \t{\n-\t  error (\"invalid arg to __builtin_return_address\");\n+\t  error (\"invalid arg to `__builtin_return_address'\");\n \t  return const0_rtx;\n \t}\n       else\n@@ -6272,7 +6523,7 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n #endif\n \n     default:\t\t\t/* just do library call, if unknown builtin */\n-      error (\"built-in function %s not currently supported\",\n+      error (\"built-in function `%s' not currently supported\",\n \t     IDENTIFIER_POINTER (DECL_NAME (fndecl)));\n     }\n "}]}