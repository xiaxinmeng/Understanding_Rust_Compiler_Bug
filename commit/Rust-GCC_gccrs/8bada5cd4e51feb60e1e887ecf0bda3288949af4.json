{"sha": "8bada5cd4e51feb60e1e887ecf0bda3288949af4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGJhZGE1Y2Q0ZTUxZmViNjBlMWU4ODdlY2YwYmRhMzI4ODk0OWFmNA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2016-07-30T22:36:56Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2016-07-30T22:36:56Z"}, "message": "PR c++/60760 - arithmetic on null pointers should not be allowed in constant\n\nPR c++/60760 - arithmetic on null pointers should not be allowed in constant\nPR c++/71091 - constexpr reference bound to a null pointer dereference\n\ngcc/cp/ChangeLog:\n\n\tPR c++/60760\n\tPR c++/71091\n        * constexpr.c (cxx_eval_binary_expression): Reject invalid expressions\n        involving null pointers.\n        (cxx_eval_component_reference): Reject null pointer dereferences.\n        (cxx_eval_indirect_ref): Reject indirecting through null pointers.\n        (cxx_eval_constant_expression): Reject invalid expressions involving\n        null pointers.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/60760\n\tPR c++/71091\n\t* g++.dg/cpp0x/constexpr-cast.C: New test.\n        * g++.dg/cpp0x/constexpr-nullptr-2.C: New test.\n        * g++.dg/cpp1y/constexpr-sfinae.C: Correct.\n        * g++.dg/ubsan/pr63956.C: Correct.\n\nFrom-SVN: r238909", "tree": {"sha": "550fac33b2921668ad6de96d6b6f2290e64f48de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/550fac33b2921668ad6de96d6b6f2290e64f48de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8bada5cd4e51feb60e1e887ecf0bda3288949af4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bada5cd4e51feb60e1e887ecf0bda3288949af4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bada5cd4e51feb60e1e887ecf0bda3288949af4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bada5cd4e51feb60e1e887ecf0bda3288949af4/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d0047a2538bc3381a7cf94e714f05b4b96799f6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0047a2538bc3381a7cf94e714f05b4b96799f6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0047a2538bc3381a7cf94e714f05b4b96799f6d"}], "stats": {"total": 453, "additions": 435, "deletions": 18}, "files": [{"sha": "1037208d5bd2f4fe2a7ebde8602b9dcdb3553f9d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bada5cd4e51feb60e1e887ecf0bda3288949af4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bada5cd4e51feb60e1e887ecf0bda3288949af4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8bada5cd4e51feb60e1e887ecf0bda3288949af4", "patch": "@@ -1,3 +1,14 @@\n+2016-07-30 Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/60760\n+\tPR c++/71091\n+\t* constexpr.c (cxx_eval_binary_expression): Reject invalid expressions\n+\tinvolving null pointers.\n+\t(cxx_eval_component_reference): Reject null pointer dereferences.\n+\t(cxx_eval_indirect_ref): Reject indirecting through null pointers.\n+\t(cxx_eval_constant_expression): Reject invalid expressions involving\n+\tnull pointers.\n+\n 2016-07-29  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/71926"}, {"sha": "8bda97373b1e712cf62dfc83d69c5126aabea36e", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 74, "deletions": 10, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bada5cd4e51feb60e1e887ecf0bda3288949af4/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bada5cd4e51feb60e1e887ecf0bda3288949af4/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=8bada5cd4e51feb60e1e887ecf0bda3288949af4", "patch": "@@ -1848,6 +1848,13 @@ cxx_eval_binary_expression (const constexpr_ctx *ctx, tree t,\n       else if (TREE_CODE (rhs) == PTRMEM_CST)\n \trhs = cplus_expand_constant (rhs);\n     }\n+  if (code == POINTER_PLUS_EXPR && !*non_constant_p\n+      && integer_zerop (lhs) && !integer_zerop (rhs))\n+    {\n+      if (!ctx->quiet)\n+\terror (\"arithmetic involving a null pointer in %qE\", lhs);\n+      return t;\n+    }\n \n   if (r == NULL_TREE)\n     r = fold_binary_loc (loc, code, type, lhs, rhs);\n@@ -2195,6 +2202,11 @@ cxx_eval_component_reference (const constexpr_ctx *ctx, tree t,\n   tree whole = cxx_eval_constant_expression (ctx, orig_whole,\n \t\t\t\t\t     lval,\n \t\t\t\t\t     non_constant_p, overflow_p);\n+  if (TREE_CODE (whole) == INDIRECT_REF\n+      && integer_zerop (TREE_OPERAND (whole, 0))\n+      && !ctx->quiet)\n+    error (\"dereferencing a null pointer in %qE\", orig_whole);\n+\n   if (TREE_CODE (whole) == PTRMEM_CST)\n     whole = cplus_expand_constant (whole);\n   if (whole == orig_whole)\n@@ -2955,6 +2967,14 @@ cxx_eval_indirect_ref (const constexpr_ctx *ctx, tree t,\n       if (*non_constant_p)\n \treturn t;\n \n+      if (!lval && integer_zerop (op0))\n+\t{\n+\t  if (!ctx->quiet)\n+\t    error (\"dereferencing a null pointer\");\n+\t  *non_constant_p = true;\n+\t  return t;\n+\t}\n+\n       r = cxx_fold_indirect_ref (EXPR_LOCATION (t), TREE_TYPE (t), op0,\n \t\t\t\t &empty_base);\n       if (r == NULL_TREE)\n@@ -3614,10 +3634,22 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t  if (!flag_permissive || ctx->quiet)\n \t    *overflow_p = true;\n \t}\n+\n+      if (TREE_CODE (t) == INTEGER_CST\n+\t  && TREE_CODE (TREE_TYPE (t)) == POINTER_TYPE\n+\t  && !integer_zerop (t))\n+\t{\n+\t  if (!ctx->quiet)\n+\t    error (\"value %qE of type %qT is not a constant expression\",\n+\t\t   t, TREE_TYPE (t));\n+\t  *non_constant_p = true;\n+\t}\n+\n       return t;\n     }\n \n-  switch (TREE_CODE (t))\n+  tree_code tcode = TREE_CODE (t);\n+  switch (tcode)\n     {\n     case RESULT_DECL:\n       if (lval)\n@@ -4041,7 +4073,6 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n     case NOP_EXPR:\n     case UNARY_PLUS_EXPR:\n       {\n-\tenum tree_code tcode = TREE_CODE (t);\n \ttree oldop = TREE_OPERAND (t, 0);\n \n \ttree op = cxx_eval_constant_expression (ctx, oldop,\n@@ -4067,15 +4098,48 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t\treturn t;\n \t      }\n \t  }\n-\tif (POINTER_TYPE_P (type)\n-\t    && TREE_CODE (op) == INTEGER_CST\n-\t    && !integer_zerop (op))\n+\n+\tif (POINTER_TYPE_P (type) && TREE_CODE (op) == INTEGER_CST)\n \t  {\n-\t    if (!ctx->quiet)\n-\t      error_at (EXPR_LOC_OR_LOC (t, input_location),\n-\t\t\t\"reinterpret_cast from integer to pointer\");\n-\t    *non_constant_p = true;\n-\t    return t;\n+\t    if (integer_zerop (op))\n+\t      {\n+\t\tif (TREE_CODE (type) == REFERENCE_TYPE)\n+\t\t  {\n+\t\t    if (!ctx->quiet)\n+\t\t      error_at (EXPR_LOC_OR_LOC (t, input_location),\n+\t\t\t\t\"dereferencing a null pointer\");\n+\t\t    *non_constant_p = true;\n+\t\t    return t;\n+\t\t  }\n+\t\telse if (TREE_CODE (TREE_TYPE (op)) == POINTER_TYPE)\n+\t\t  {\n+\t\t    tree from = TREE_TYPE (op);\n+\n+\t\t    if (!can_convert (type, from, tf_none))\n+\t\t      {\n+\t\t\tif (!ctx->quiet)\n+\t\t\t  error_at (EXPR_LOC_OR_LOC (t, input_location),\n+\t\t\t\t    \"conversion of %qT null pointer to %qT \"\n+\t\t\t\t    \"is not a constant expression\",\n+\t\t\t\t    from, type);\n+\t\t\t*non_constant_p = true;\n+\t\t\treturn t;\n+\t\t      }\n+\t\t  }\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* This detects for example:\n+\t\t     reinterpret_cast<void*>(sizeof 0)\n+\t\t*/\n+\t\tif (!ctx->quiet)\n+\t\t  error_at (EXPR_LOC_OR_LOC (t, input_location),\n+\t\t\t    \"%<reinterpret_cast<%T>(%E)%> is not \"\n+\t\t\t    \"a constant-expression\",\n+\t\t\t    type, op);\n+\t\t*non_constant_p = true;\n+\t\treturn t;\n+\t      }\n \t  }\n \tif (op == oldop && tcode != UNARY_PLUS_EXPR)\n \t  /* We didn't fold at the top so we could check for ptr-int"}, {"sha": "a73a39defc69bb45642b07ee9d61f5233815d78c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bada5cd4e51feb60e1e887ecf0bda3288949af4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bada5cd4e51feb60e1e887ecf0bda3288949af4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8bada5cd4e51feb60e1e887ecf0bda3288949af4", "patch": "@@ -1,3 +1,12 @@\n+2016-07-30 Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/60760\n+\tPR c++/71091\n+\t* g++.dg/cpp0x/constexpr-cast.C: New test.\n+\t* g++.dg/cpp0x/constexpr-nullptr-2.C: New test.\n+\t* g++.dg/cpp1y/constexpr-sfinae.C: Correct.\n+\t* g++.dg/ubsan/pr63956.C: Correct.\n+\n 2016-07-30  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \t* gcc.target/powerpc/vec-extract-2.c: New tests for vec_extract of"}, {"sha": "8e11193be53bfcb7f7c153fc8eacdbb49c74d360", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-cast.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bada5cd4e51feb60e1e887ecf0bda3288949af4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-cast.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bada5cd4e51feb60e1e887ecf0bda3288949af4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-cast.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-cast.C?ref=8bada5cd4e51feb60e1e887ecf0bda3288949af4", "patch": "@@ -0,0 +1,24 @@\n+// Test to verify that evaluating reinterpret_cast is diagnosed in\n+// constant expressions.\n+// { dg-do compile { target c++11 } }\n+\n+int i;\n+\n+// The following is accepted due to bug 49171.\n+constexpr void *q = reinterpret_cast<void*>(&i);    // { dg-error \"\" \"bug c++/49171\" { xfail *-*-*-* } }\n+\n+constexpr void *r0 = reinterpret_cast<void*>(1);    // { dg-error \"not a constant expression\" }\n+constexpr void *r1 = reinterpret_cast<void*>(sizeof 'x');  // { dg-error \".reinterpret_cast<void\\\\*>\\\\(1ul\\\\). is not a constant-expression\" }\n+\n+template <class T>\n+constexpr bool f ()\n+{\n+#if __cplusplus > 201103L\n+  T *p = reinterpret_cast<T*>(sizeof (T));\n+  return p;\n+#else\n+  return *reinterpret_cast<T*>(sizeof (T));\n+#endif\n+}\n+\n+constexpr bool b = f<int>();   // { dg-error \"not a constant expression\" }"}, {"sha": "aeea87c2ae7edd0f71dda2f1b3819926e696397b", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-2.C", "status": "added", "additions": 303, "deletions": 0, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bada5cd4e51feb60e1e887ecf0bda3288949af4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-nullptr-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bada5cd4e51feb60e1e887ecf0bda3288949af4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-nullptr-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-nullptr-2.C?ref=8bada5cd4e51feb60e1e887ecf0bda3288949af4", "patch": "@@ -0,0 +1,303 @@\n+// PR c++/60760 - arithmetic on null pointers should not be allowed\n+//     in constant expressions\n+// PR c++/71091 - constexpr reference bound to a null pointer dereference\n+//     accepted\n+// { dg-do compile { target c++11 } }\n+// { dg-additional-options \"-Wno-pointer-arith\" }\n+\n+// Generate a null poiinter.\n+constexpr int* null () { return 0; }\n+\n+// Test case from comment #0 in c++/60760.\n+namespace PR_60760_comment_0 {\n+\n+constexpr int* ptr = nullptr;\n+constexpr int* ptr2 = ptr + 1;   // { dg-error \"null pointer|not a constant\" }\n+\n+}\n+\n+// Test case from comment #1 in c++/60760.\n+namespace PR_60760_comment_1 {\n+\n+constexpr int* ptr = nullptr;\n+\n+constexpr int zero = 0;\n+constexpr int* ptr2 = ptr + zero;   // Adding zero is valid.\n+constexpr int* ptr3 = ptr - zero;   // As is subtracting zero.\n+\n+}\n+\n+// Test case from c++/71091.\n+namespace PR_71091 {\n+\n+constexpr int *p = 0;\n+constexpr const int &r = *p;   // { dg-error \"dereferencing a null pointer\" }\n+\n+}\n+\n+// Other test cases.\n+namespace C {\n+\n+struct S { int a, b[1]; } s;\n+\n+constexpr S *p0 = &s;\n+constexpr S *p1 = nullptr;\n+constexpr int *r0 = p1->b;   // { dg-error \"null pointer|constant expression\" }\n+\n+// Adding and subtracting zero from and to a null pointer is valid.\n+constexpr S* r1 = p1 + 0;\n+constexpr S* r2 = r1 - 0;\n+\n+constexpr int zero = 0;\n+\n+constexpr S* r3 = r2 + zero;\n+constexpr S* r4 = r3 - zero;\n+\n+static_assert (r4 == nullptr, \"r4 == nullptr\");\n+\n+constexpr const S *pcs = p0;\n+constexpr int d1 = pcs - p0;\n+constexpr int d2 = p0 - pcs;\n+\n+constexpr bool b = !p1 && !pcs;\n+}\n+\n+namespace D {\n+\n+struct A { int i; const A *pa1; const A *pa0; };\n+\n+constexpr A a1 = { 0, 0, 0  };\n+constexpr A a2 = { 1, &a1, 0 };\n+\n+constexpr const A *pa2 = &a2;\n+constexpr int i0 = pa2->i;\n+constexpr int i1 = pa2->pa1->i;\n+constexpr int i2 = pa2->pa1->pa0->i;\t    // { dg-error \"null pointer|not a constant\" }\n+\n+constexpr const A *pa3 = &*pa2->pa1->pa0;\n+constexpr const A *pa4 = pa2->pa1->pa0 + 1;     // { dg-error \"null pointer|not a constant\" }\n+\n+constexpr const int *pi0 = &pa2->pa1->pa0->i;   // { dg-error \"null pointer|not a constant\" }\n+\n+constexpr const A *pa5 = 0;\n+constexpr const int *pi1 = &pa5->i;\t     // { dg-error \"null pointer|not a constant\" }\n+\n+}\n+\n+\n+namespace SimpleTests {\n+\n+constexpr int* p0 = nullptr;\n+constexpr int* q0 = p0;\n+constexpr int* r0 = null ();\n+\n+// Conversion to cv-qualified void* is valid.\n+constexpr void* pv0 = p0;\n+constexpr const void* pv1 = p0;\n+constexpr volatile void* pv2 = p0;\n+constexpr const volatile void* pv3 = p0;\n+constexpr void* pv4 = static_cast<void*>(p0);\n+constexpr const void* pv5 = static_cast<const void*>(p0);\n+\n+// The following should be rejected but isn't because of bug c++/49171\n+// - [C++0x][constexpr] Constant expressions support reinterpret_cast\n+constexpr void* pv6 = reinterpret_cast<void*>(p0);   // { dg-error \"\" \"bug c++/49171\" { xfail *-*-* } }\n+\n+// Adding or subtracting zero from a null pointer is valid in C++.\n+constexpr int* p1 = p0 + 0;\n+constexpr int* p2 = p0 - 0;\n+constexpr int* p3 = 0 + p0;\n+\n+// While the text of the C++ standard still doesn't allow it, CWG\n+// issue 232 implies that dererencing a null pointer is intended\n+// to be permitted in contexts where the result isn't evaluated.\n+// For compatibility with C that should at a minimum include\n+// expressions like &*p that are valid there.\n+constexpr int* p4 = &*p0;\n+constexpr int* p5 = p0 + 1;       // { dg-error \"null pointer|not a constant\" }\n+constexpr int* p6 = 1 + p0;       // { dg-error \"null pointer|not a constant\" }\n+constexpr int* p7 = p0 - 1;       // { dg-error \"null pointer|not a constant\" }\n+constexpr int* p8 = &p0 [0];\n+constexpr int* p9 = &0 [p0];\n+\n+constexpr int* p10 = null () + 2; // { dg-error \"null pointer|not a constant\" }\n+constexpr int* p11 = 3 + null (); // { dg-error \"null pointer|not a constant\" }\n+constexpr int* p12 = null () - 4; // { dg-error \"null pointer|not a constant\" }\n+constexpr int* p13 = &null ()[4]; // { dg-error \"null pointer|not a constant\" }\n+constexpr int* p14 = &3[null ()]; // { dg-error \"null pointer|not a constant\" }\n+\n+constexpr int* q1 = q0 + 0;\n+constexpr int* q2 = q0 - 0;\n+constexpr int* q3 = q0 + 1;       // { dg-error \"null pointer|not a constant\" }\n+constexpr int* q4 = q0 + 2;       // { dg-error \"null pointer|not a constant\" }\n+constexpr int* q5 = &q0 [0];\n+\n+// Subtracting null pointers from one another is valid.\n+constexpr int i0 = p0 - (int*)0;\n+constexpr int i1 = p0 - static_cast<int*>(0);\n+constexpr int i2 = p0 - (int*)nullptr;\n+constexpr int i3 = p0 - static_cast<int*>(nullptr);\n+constexpr int i4 = p0 - p0;\n+constexpr int i5 = p0 - q0;\n+constexpr int i6 = p0 - r0;\n+constexpr int i7 = (int*)0 - p0;\n+constexpr int i8 = static_cast<int*>(0) - p0;\n+constexpr int i9 = (int*)nullptr - p0;\n+constexpr int i10 = static_cast<int*>(nullptr) - p0;\n+constexpr int i11 = q0 - p0;\n+constexpr int i12 = r0 - p0;\n+\n+}\n+\n+namespace IncompleteTypeTests {\n+\n+// The type must be complete.\n+struct X;\n+constexpr X *px0 = nullptr;\n+constexpr X *px1 = px0 + 0;     // { dg-error \"invalid use of incomplete type\"  }\n+constexpr X *px2 = px0 - 0;     // { dg-error \"invalid use of incomplete type\"  }\n+constexpr X *px3 = px0 - px0;   // { dg-error \"invalid use of incomplete type\"  }\n+\n+constexpr void *pv0 = px0;\n+constexpr void *pv1 = pv0;\n+constexpr const void *pv2 = pv0;\n+constexpr void *pv3 = pv2;      // { dg-error \"invalid conversion|not a constant expression\" }\n+constexpr const void *pv4 = pv2;\n+\n+constexpr X *px4 = pv0;\t // { dg-error \"invalid conversion|not a constant expression\" }\n+\n+}\n+\n+namespace IndirectTests {\n+\n+struct S { int i, j; struct SA { struct SB { int *pi; } sb; } sa; };\n+\n+constexpr S* ps = (S*)0;\n+\n+// Comparing null pointers is valid.\n+constexpr bool b0 = ps == ps;\n+constexpr bool b1 = ps != ps;\n+constexpr bool b2 = ps <  ps;\n+constexpr bool b3 = ps <= ps;\n+constexpr bool b4 = ps >  ps;\n+constexpr bool b5 = ps >= ps;\n+\n+constexpr bool b6 = ps == (S*)0;\n+constexpr bool b7 = ps != (S*)0;\n+constexpr bool b8 = ps <  (S*)0;\n+constexpr bool b9 = ps <= (S*)0;\n+constexpr bool b10 = ps >  (S*)0;\n+constexpr bool b11 = ps >= (S*)0;\n+\n+constexpr S* ps1 = ps;\n+constexpr S* ps2 = ps1;\n+\n+// The following aren't diagnosed due to a bug.\n+// constexpr int* pi0 = &((S*)0)->i;\n+// constexpr int* pi1 = &((S*)nullptr)->i;\n+\n+constexpr int* pj0 = &((S*)0)->j;\t// { dg-error \"not a constant expression\" }\n+constexpr int* pj1 = &((S*)nullptr)->j;  // { dg-error \"not a constant expression\" }\n+\n+constexpr int* psi = &ps->i;\t    // { dg-error \"null pointer|not a constant\" }\n+constexpr int* psj = &ps->j;\t    // { dg-error \"null pointer|not a constant\" }\n+\n+constexpr int* ps1i = &ps1->i;\t  // { dg-error \"null pointer|not a constant\" }\n+constexpr int* ps2i = &ps1->i;\t  // { dg-error \"null pointer|not a constant\" }\n+\n+constexpr int* ps1j = &ps1->j;\t  // { dg-error \"null pointer|not a constant\" }\n+constexpr int* ps2j = &ps1->j;\t  // { dg-error \"null pointer|not a constant\" }\n+\n+}\n+\n+namespace BaseAndDerivedTests {\n+\n+struct A { };\n+struct B: A { };\n+struct C: B { };\n+struct D: B, C { };\t\t     // { dg-warning \"inaccessible\" }\n+\n+constexpr D *pd0 = 0;\n+constexpr C *pc0 = 0;\n+constexpr B *pb0 = 0;\n+\n+constexpr A *pa0 = pb0;\n+constexpr A *pa1 = static_cast<A*>(pb0);\n+constexpr A *pa2 = pc0;\n+constexpr A *pa3 = pd0;\t\t   // { dg-error \"ambiguous base\" }\n+constexpr A *pa4 = static_cast<A*>(pd0);  // { dg-error \"ambiguous base\" }\n+\n+constexpr B *pb1 = pa0;\t\t   // { dg-error \"invalid conversion|not a constant expression\" }\n+constexpr B *pb2 = static_cast<B*>(pa0);  // { dg-error \"not a constant expression\" }\n+\n+constexpr C *pc1 = pa0;\t\t   // { dg-error \"invalid conversion|not a constant expression\" }\n+constexpr D *pd1 = pa0;\t\t   // { dg-error \"ambiguous base|invalid conversion\" }\n+\n+struct E: private A { };\n+\n+constexpr E *pe0 = 0;\n+constexpr A *pa5 = pe0;\t\t // { dg-error \"inaccessible base of\" }\n+\n+struct VA { virtual ~VA (); };\n+struct VB: virtual VA { };\n+struct VC: virtual VA { };\n+struct VD: VB, VC { };\n+\n+constexpr VD *pvd0 = 0;\n+constexpr VC *pvc0 = 0;\n+constexpr VB *pvb0 = 0;\n+\n+constexpr VA *pva0 = pvb0;\n+constexpr VA *pva1 = pvc0;\n+constexpr VA *pva2 = pvd0;\n+\n+constexpr VB *pvb1 = pva0;\t      // { dg-error \"invalid conversion|cannot convert from pointer to base class\" }\n+\n+}\n+\n+namespace FunctionTests {\n+\n+typedef void Func ();\n+\n+// Arithmetic on member function pointers is diagnosed with -Wpointer-arith.\n+// With constexpr, only zero may be added or subtracted.\n+constexpr Func *pf0 = 0;\n+constexpr Func *pf1 = pf0 + 0;  // triggers -Wpointer-arith\n+constexpr Func *pf2 = pf0 - 0;  // triggers -Wpointer-arith\n+constexpr Func *pf3 = 0 + pf0;  // triggers -Wpointer-arith\n+constexpr Func *pf4 = pf0 + 1;  // { dg-error \"null pointer|not a constant\" }\n+constexpr Func *pf5 = 2 + pf0;  // { dg-error \"null pointer|not a constant\" }\n+constexpr Func *pf6 = pf0 - 3;  // { dg-error \"null pointer|not a constant\" }\n+\n+struct S;\n+typedef void (S::*MemFuncPtr)();\n+\n+// Arithmetic on member function pointers is rejected with a hard error.\n+constexpr MemFuncPtr pmf0 = nullptr;\n+constexpr MemFuncPtr pmf1 = pmf0 + 0;   // { dg-error \"invalid operands\" }\n+constexpr MemFuncPtr pmf2 = 0 + pmf0;   // { dg-error \"invalid operands\" }\n+constexpr MemFuncPtr pmf3 = pmf0 + 1;   // { dg-error \"invalid operands\" }\n+constexpr MemFuncPtr pmf4 = 1 + pmf0;   // { dg-error \"invalid operands\" }\n+constexpr MemFuncPtr pmf5 = pmf0 - 1;   // { dg-error \"invalid operands\" }\n+\n+}\n+\n+namespace ConversionTest {\n+\n+struct A {\n+  int *p;\n+};\n+\n+constexpr const int* f (const int *p) { return p; }\n+\n+void f ()\n+{\n+  static_assert (!f (0), \"f (a.p)\");\n+  static_assert (!f (nullptr), \"f (a.p)\");\n+\n+  constexpr A a = A ();\n+\n+  static_assert (!f (a.p), \"f (a.p)\");\n+}\n+\n+}"}, {"sha": "4a7deb8e8269c9d7237f95b6036c880079f5fc6d", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-sfinae.C", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bada5cd4e51feb60e1e887ecf0bda3288949af4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-sfinae.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bada5cd4e51feb60e1e887ecf0bda3288949af4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-sfinae.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-sfinae.C?ref=8bada5cd4e51feb60e1e887ecf0bda3288949af4", "patch": "@@ -90,22 +90,28 @@ namespace NullPointerArithmetic {\n constexpr int i = 0;\n constexpr const int* a[] = { 0, &i };\n \n-// Well-defined core constant expressoons involving null pointers.\n+// Well-defined core constant expressions involving null pointers.\n constexpr __PTRDIFF_TYPE__ d00 = a [0] - a [0];\n constexpr __PTRDIFF_TYPE__ d11 = a [1] - a [1];\n \n-// Undefined core constant expressoons involving null pointers.\n+// Undefined core constant expressions involving null pointers.\n // constexpr __PTRDIFF_TYPE__ d01 = a [0] - a [1];\n // constexpr __PTRDIFF_TYPE__ d10 = a [1] - a [0];\n \n-constexpr bool nullptr_sub_0 (int i, int j) { return 1 + a [i != 0] - a [j]; }\n+// Valid when i == j.\n+constexpr bool\n+nullptr_sub_0 (bool i, bool j) { return 1 + a [!i] - a [!j]; }\n \n-constexpr bool nullptr_sub_1 (int i, int j) { return 1 + a [i == 0] - a [j]; }\n+// Valid when i != j.\n+constexpr bool\n+nullptr_sub_1 (bool i, bool j) { return 1 + a [i] - a [!j]; }\n \n-template <int I>\n+// Selected when I == 0.\n+template <bool I>\n constexpr int f (int (*)[nullptr_sub_0 (I, 0)] = 0) { return 0; }\n \n-template <int I>\n+// Selected when I != 0.\n+template <bool I>\n constexpr int f (int (*)[nullptr_sub_1 (I, 0)] = 0) { return 1; }\n \n constexpr int n0 = f<0>();"}, {"sha": "ac01fa4fdd24fa66f18829d9dc3f8a7d9c1ec213", "filename": "gcc/testsuite/g++.dg/ubsan/pr63956.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bada5cd4e51feb60e1e887ecf0bda3288949af4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fpr63956.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bada5cd4e51feb60e1e887ecf0bda3288949af4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fpr63956.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fpr63956.C?ref=8bada5cd4e51feb60e1e887ecf0bda3288949af4", "patch": "@@ -92,7 +92,7 @@ constexpr int\n fn6 (const int &a, int b)\n {\n   if (b != 2)\n-    b = a;  // { dg-error \"is not a constant expression\" }\n+    b = a;\n   return b;\n }\n \n@@ -106,7 +106,7 @@ fn7 (const int *a, int b)\n \n constexpr int n1 = 7;\n constexpr int n2 = fn7 (&n1, 5);\n-constexpr int n3 = fn7 ((const int *) 0, 8);\n+constexpr int n3 = fn7 ((const int *) 0, 8);  // { dg-error \"null pointer\" }\n \n constexpr int\n fn8 (int i)"}]}