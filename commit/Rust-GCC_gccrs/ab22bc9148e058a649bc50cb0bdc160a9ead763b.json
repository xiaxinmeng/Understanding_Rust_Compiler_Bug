{"sha": "ab22bc9148e058a649bc50cb0bdc160a9ead763b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWIyMmJjOTE0OGUwNThhNjQ5YmM1MGNiMGJkYzE2MGE5ZWFkNzYzYg==", "commit": {"author": {"name": "Sascha Brawer", "email": "brawer@dandelis.ch", "date": "2004-01-05T19:19:29Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2004-01-05T19:19:29Z"}, "message": "Thanks to Brian Gough <bjg@network-theory.com>\n\n2004-01-05  Sascha Brawer  <brawer@dandelis.ch>\n\n\tThanks to Brian Gough <bjg@network-theory.com>\n\t* java/awt/geom/CubicCurve2D.java (solveCubic): Implemented.\n\t* java/awt/geom/QuadCurve2D.java (solveQuadratic): Re-written.\n\nFrom-SVN: r75437", "tree": {"sha": "8383df7e144c69b16c9ccfb5c030244096639ecc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8383df7e144c69b16c9ccfb5c030244096639ecc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab22bc9148e058a649bc50cb0bdc160a9ead763b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab22bc9148e058a649bc50cb0bdc160a9ead763b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab22bc9148e058a649bc50cb0bdc160a9ead763b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab22bc9148e058a649bc50cb0bdc160a9ead763b/comments", "author": null, "committer": null, "parents": [{"sha": "60b799fd29a61f2970062f08cdb58e6b0956994a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60b799fd29a61f2970062f08cdb58e6b0956994a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60b799fd29a61f2970062f08cdb58e6b0956994a"}], "stats": {"total": 316, "additions": 300, "deletions": 16}, "files": [{"sha": "f8eadf9256447d64730352fa7b2f9677fa93449b", "filename": "libjava/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab22bc9148e058a649bc50cb0bdc160a9ead763b/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab22bc9148e058a649bc50cb0bdc160a9ead763b/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=ab22bc9148e058a649bc50cb0bdc160a9ead763b", "patch": "@@ -1,3 +1,9 @@\n+2004-01-05  Sascha Brawer  <brawer@dandelis.ch>\n+\n+\tThanks to Brian Gough <bjg@network-theory.com>\n+\t* java/awt/geom/CubicCurve2D.java (solveCubic): Implemented.\n+\t* java/awt/geom/QuadCurve2D.java (solveQuadratic): Re-written.\n+\n 2004-01-04  Matthias Klose  <doko@debian.org>\n \n \t* aclocal.m4: Rebuilt using \"aclocal -I .\"."}, {"sha": "096e7ad977226b62bce0d53413bed9030b1ce843", "filename": "libjava/java/awt/geom/CubicCurve2D.java", "status": "modified", "additions": 163, "deletions": 3, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab22bc9148e058a649bc50cb0bdc160a9ead763b/libjava%2Fjava%2Fawt%2Fgeom%2FCubicCurve2D.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab22bc9148e058a649bc50cb0bdc160a9ead763b/libjava%2Fjava%2Fawt%2Fgeom%2FCubicCurve2D.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fgeom%2FCubicCurve2D.java?ref=ab22bc9148e058a649bc50cb0bdc160a9ead763b", "patch": "@@ -624,17 +624,115 @@ public static void subdivide(double[] src, int srcOff,\n   }\n \n \n+  /**\n+   * Finds the non-complex roots of a cubic equation, placing the\n+   * results into the same array as the equation coefficients. The\n+   * following equation is being solved:\n+   *\n+   * <blockquote><code>eqn[3]</code> &#xb7; <i>x</i><sup>3</sup>\n+   * + <code>eqn[2]</code> &#xb7; <i>x</i><sup>2</sup>\n+   * + <code>eqn[1]</code> &#xb7; <i>x</i>\n+   * + <code>eqn[0]</code>\n+   * = 0\n+   * </blockquote>\n+   *\n+   * <p>For some background about solving cubic equations, see the\n+   * article <a\n+   * href=\"http://planetmath.org/encyclopedia/CubicFormula.html\"\n+   * >&#x201c;Cubic Formula&#x201d;</a> in <a\n+   * href=\"http://planetmath.org/\" >PlanetMath</a>.  For an extensive\n+   * library of numerical algorithms written in the C programming\n+   * language, see the <a href= \"http://www.gnu.org/software/gsl/\">GNU\n+   * Scientific Library</a>, from which this implementation was\n+   * adapted.\n+   *\n+   * @param eqn an array with the coefficients of the equation. When\n+   * this procedure has returned, <code>eqn</code> will contain the\n+   * non-complex solutions of the equation, in no particular order.\n+   *\n+   * @return the number of non-complex solutions. A result of 0\n+   * indicates that the equation has no non-complex solutions. A\n+   * result of -1 indicates that the equation is constant (i.e.,\n+   * always or never zero).\n+   *\n+   * @see #solveCubic(double[], double[])\n+   * @see QuadCurve2D#solveQuadratic(double[],double[])\n+   *\n+   * @author <a href=\"mailto:bjg@network-theory.com\">Brian Gough</a>\n+   * (original C implementation in the <a href=\n+   * \"http://www.gnu.org/software/gsl/\">GNU Scientific Library</a>)\n+   *\n+   * @author <a href=\"mailto:brawer@dandelis.ch\">Sascha Brawer</a>\n+   * (adaptation to Java)\n+   */\n   public static int solveCubic(double[] eqn)\n   {\n     return solveCubic(eqn, eqn);\n   }\n \n \n+  /**\n+   * Finds the non-complex roots of a cubic equation. The following\n+   * equation is being solved:\n+   *\n+   * <blockquote><code>eqn[3]</code> &#xb7; <i>x</i><sup>3</sup>\n+   * + <code>eqn[2]</code> &#xb7; <i>x</i><sup>2</sup>\n+   * + <code>eqn[1]</code> &#xb7; <i>x</i>\n+   * + <code>eqn[0]</code>\n+   * = 0\n+   * </blockquote>\n+   *\n+   * <p>For some background about solving cubic equations, see the\n+   * article <a\n+   * href=\"http://planetmath.org/encyclopedia/CubicFormula.html\"\n+   * >&#x201c;Cubic Formula&#x201d;</a> in <a\n+   * href=\"http://planetmath.org/\" >PlanetMath</a>.  For an extensive\n+   * library of numerical algorithms written in the C programming\n+   * language, see the <a href= \"http://www.gnu.org/software/gsl/\">GNU\n+   * Scientific Library</a>, from which this implementation was\n+   * adapted.\n+   *\n+   * @see QuadCurve2D#solveQuadratic(double[],double[])\n+   *\n+   * @param eqn an array with the coefficients of the equation.\n+   *\n+   * @param res an array into which the non-complex roots will be\n+   * stored.  The results may be in an arbitrary order. It is safe to\n+   * pass the same array object reference for both <code>eqn</code>\n+   * and <code>res</code>.\n+   *\n+   * @return the number of non-complex solutions. A result of 0\n+   * indicates that the equation has no non-complex solutions. A\n+   * result of -1 indicates that the equation is constant (i.e.,\n+   * always or never zero).\n+   *\n+   * @author <a href=\"mailto:bjg@network-theory.com\">Brian Gough</a>\n+   * (original C implementation in the <a href=\n+   * \"http://www.gnu.org/software/gsl/\">GNU Scientific Library</a>)\n+   *\n+   * @author <a href=\"mailto:brawer@dandelis.ch\">Sascha Brawer</a>\n+   * (adaptation to Java)\n+   */\n   public static int solveCubic(double[] eqn, double[] res)\n   {\n+    // Adapted from poly/solve_cubic.c in the GNU Scientific Library\n+    // (GSL), revision 1.7 of 2003-07-26. For the original source, see\n+    // http://www.gnu.org/software/gsl/\n+    //\n+    // Brian Gough, the author of that code, has granted the\n+    // permission to use it in GNU Classpath under the GNU Classpath\n+    // license, and has assigned the copyright to the Free Software\n+    // Foundation.\n+    //\n+    // The Java implementation is very similar to the GSL code, but\n+    // not a strict one-to-one copy. For example, GSL would sort the\n+    // result.\n+\n     double a, b, c, q, r, Q, R;\n-    \n-    double c3 = eqn[3];\n+    double c3, Q3, R2, CR2, CQ3;\n+\n+    // If the cubic coefficient is zero, we have a quadratic equation.\n+    c3 = eqn[3];\n     if (c3 == 0)\n       return QuadCurve2D.solveQuadratic(eqn, res);\n \n@@ -644,7 +742,69 @@ public static int solveCubic(double[] eqn, double[] res)\n     a = eqn[2] / c3;\n \n     // We now need to solve x^3 + ax^2 + bx + c = 0.\n-    throw new Error(\"not implemented\"); // FIXME\n+    q = a * a - 3 * b;\n+    r = 2 * a * a * a - 9 * a * b + 27 * c;\n+\n+    Q = q / 9;\n+    R = r / 54;\n+\n+    Q3 = Q * Q * Q;\n+    R2 = R * R;\n+\n+    CR2 = 729 * r * r;\n+    CQ3 = 2916 * q * q * q;\n+\n+    if (R == 0 && Q == 0)\n+    {\n+      // The GNU Scientific Library would return three identical\n+      // solutions in this case.\n+      res[0] = -a/3;\n+      return 1;\n+    }\n+\n+    if (CR2 == CQ3) \n+    {\n+      /* this test is actually R2 == Q3, written in a form suitable\n+         for exact computation with integers */\n+\n+      /* Due to finite precision some double roots may be missed, and\n+         considered to be a pair of complex roots z = x +/- epsilon i\n+         close to the real axis. */\n+\n+      double sqrtQ = Math.sqrt(Q);\n+\n+      if (R > 0)\n+      {\n+        res[0] = -2 * sqrtQ - a/3;\n+        res[1] = sqrtQ - a/3;\n+      }\n+      else\n+      {\n+        res[0] = -sqrtQ - a/3;\n+        res[1] = 2 * sqrtQ - a/3;\n+      }\n+      return 2;\n+    }\n+\n+    if (CR2 < CQ3) /* equivalent to R2 < Q3 */\n+    {\n+      double sqrtQ = Math.sqrt(Q);\n+      double sqrtQ3 = sqrtQ * sqrtQ * sqrtQ;\n+      double theta = Math.acos(R / sqrtQ3);\n+      double norm = -2 * sqrtQ;\n+      res[0] = norm * Math.cos(theta / 3) - a / 3;\n+      res[1] = norm * Math.cos((theta + 2.0 * Math.PI) / 3) - a/3;\n+      res[2] = norm * Math.cos((theta - 2.0 * Math.PI) / 3) - a/3;\n+\n+      // The GNU Scientific Library sorts the results. We don't.\n+      return 3;\n+    }\n+\n+    double sgnR = (R >= 0 ? 1 : -1);\n+    double A = -sgnR * Math.pow(Math.abs(R) + Math.sqrt(R2 - Q3), 1.0/3.0);\n+    double B = Q / A ;\n+    res[0] = A + B - a/3;\n+    return 1;\n   }\n \n "}, {"sha": "409c4841e1587efa37a495e54a4e0554aa3413c5", "filename": "libjava/java/awt/geom/QuadCurve2D.java", "status": "modified", "additions": 131, "deletions": 13, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab22bc9148e058a649bc50cb0bdc160a9ead763b/libjava%2Fjava%2Fawt%2Fgeom%2FQuadCurve2D.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab22bc9148e058a649bc50cb0bdc160a9ead763b/libjava%2Fjava%2Fawt%2Fgeom%2FQuadCurve2D.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fgeom%2FQuadCurve2D.java?ref=ab22bc9148e058a649bc50cb0bdc160a9ead763b", "patch": "@@ -550,39 +550,157 @@ public static void subdivide(double[] src, int srcOff,\n   }\n \n \n+  /**\n+   * Finds the non-complex roots of a quadratic equation, placing the\n+   * results into the same array as the equation coefficients. The\n+   * following equation is being solved:\n+   *\n+   * <blockquote><code>eqn[2]</code> &#xb7; <i>x</i><sup>2</sup>\n+   * + <code>eqn[1]</code> &#xb7; <i>x</i>\n+   * + <code>eqn[0]</code>\n+   * = 0\n+   * </blockquote>\n+   *\n+   * <p>For some background about solving quadratic equations, see the\n+   * article <a href=\n+   * \"http://planetmath.org/encyclopedia/QuadraticFormula.html\"\n+   * >&#x201c;Quadratic Formula&#x201d;</a> in <a href=\n+   * \"http://planetmath.org/\">PlanetMath</a>. For an extensive library\n+   * of numerical algorithms written in the C programming language,\n+   * see the <a href=\"http://www.gnu.org/software/gsl/\">GNU Scientific\n+   * Library</a>.\n+   *\n+   * @see #solveQuadratic(double[], double[])\n+   * @see CubicCurve2D#solveCubic(double[], double[])\n+   *\n+   * @param eqn an array with the coefficients of the equation. When\n+   * this procedure has returned, <code>eqn</code> will contain the\n+   * non-complex solutions of the equation, in no particular order.\n+   *\n+   * @return the number of non-complex solutions. A result of 0\n+   * indicates that the equation has no non-complex solutions. A\n+   * result of -1 indicates that the equation is constant (i.e.,\n+   * always or never zero).\n+   *\n+   * @author <a href=\"mailto:bjg@network-theory.com\">Brian Gough</a>\n+   * (original C implementation in the <a href=\n+   * \"http://www.gnu.org/software/gsl/\">GNU Scientific Library</a>)\n+   *\n+   * @author <a href=\"mailto:brawer@dandelis.ch\">Sascha Brawer</a>\n+   * (adaptation to Java)\n+   */\n   public static int solveQuadratic(double[] eqn)\n   {\n     return solveQuadratic(eqn, eqn);\n   }\n \n \n+  /**\n+   * Finds the non-complex roots of a quadratic equation. The\n+   * following equation is being solved:\n+   *\n+   * <blockquote><code>eqn[2]</code> &#xb7; <i>x</i><sup>2</sup>\n+   * + <code>eqn[1]</code> &#xb7; <i>x</i>\n+   * + <code>eqn[0]</code>\n+   * = 0\n+   * </blockquote>\n+   *\n+   * <p>For some background about solving quadratic equations, see the\n+   * article <a href=\n+   * \"http://planetmath.org/encyclopedia/QuadraticFormula.html\"\n+   * >&#x201c;Quadratic Formula&#x201d;</a> in <a href=\n+   * \"http://planetmath.org/\">PlanetMath</a>. For an extensive library\n+   * of numerical algorithms written in the C programming language,\n+   * see the <a href=\"http://www.gnu.org/software/gsl/\">GNU Scientific\n+   * Library</a>.\n+   *\n+   * @see CubicCurve2D#solveCubic(double[],double[])\n+   *\n+   * @param eqn an array with the coefficients of the equation.\n+   *\n+   * @param res an array into which the non-complex roots will be\n+   * stored.  The results may be in an arbitrary order. It is safe to\n+   * pass the same array object reference for both <code>eqn</code>\n+   * and <code>res</code>.\n+   *\n+   * @return the number of non-complex solutions. A result of 0\n+   * indicates that the equation has no non-complex solutions. A\n+   * result of -1 indicates that the equation is constant (i.e.,\n+   * always or never zero).\n+   *\n+   * @author <a href=\"mailto:bjg@network-theory.com\">Brian Gough</a>\n+   * (original C implementation in the <a href=\n+   * \"http://www.gnu.org/software/gsl/\">GNU Scientific Library</a>)\n+   *\n+   * @author <a href=\"mailto:brawer@dandelis.ch\">Sascha Brawer</a>\n+   * (adaptation to Java)\n+   */\n   public static int solveQuadratic(double[] eqn, double[] res)\n   {\n-    double c = eqn[0];\n-    double b = eqn[1];\n-    double a = eqn[2];\n+    // Taken from poly/solve_quadratic.c in the GNU Scientific Library\n+    // (GSL), cvs revision 1.7 of 2003-07-26. For the original source,\n+    // see http://www.gnu.org/software/gsl/\n+    //\n+    // Brian Gough, the author of that code, has granted the\n+    // permission to use it in GNU Classpath under the GNU Classpath\n+    // license, and has assigned the copyright to the Free Software\n+    // Foundation.\n+    //\n+    // The Java implementation is very similar to the GSL code, but\n+    // not a strict one-to-one copy. For example, GSL would sort the\n+    // result.\n+\n+    double a, b, c, disc;\n+\n+    c = eqn[0];\n+    b = eqn[1];\n+    a = eqn[2];\n+\n+    // Check for linear or constant functions. This is not done by the\n+    // GNU Scientific Library.  Without this special check, we\n+    // wouldn't return -1 for constant functions, and 2 instead of 1\n+    // for linear functions.\n     if (a == 0)\n     {\n       if (b == 0)\n         return -1;\n+      \n       res[0] = -c / b;\n       return 1;\n     }\n-    c /= a;\n-    b /= a * 2;\n-    double det = Math.sqrt(b * b - c);\n-    if (det != det)\n+\n+    disc = b * b - 4 * a * c;\n+\n+    if (disc < 0)\n       return 0;\n-    // For fewer rounding errors, we calculate the two roots differently.\n-    if (b > 0)\n+\n+    if (disc == 0)\n+    {\n+      // The GNU Scientific Library returns two identical results here.\n+      // We just return one.\n+      res[0] = -0.5 * b / a ;\n+      return 1;\n+    }\n+\n+    // disc > 0\n+    if (b == 0)\n     {\n-      res[0] = -b - det;\n-      res[1] = -c / (b + det);\n+      double r;\n+\n+      r = Math.abs(0.5 * Math.sqrt(disc) / a);\n+      res[0] = -r;\n+      res[1] = r;\n     }\n     else\n     {\n-      res[0] = -c / (b - det);\n-      res[1] = -b + det;\n+      double sgnb, temp;\n+      \n+      sgnb = (b > 0 ? 1 : -1);\n+      temp = -0.5 * (b + sgnb * Math.sqrt(disc));\n+\n+      // The GNU Scientific Library sorts the result here. We don't.\n+      res[0] = temp / a;\n+      res[1] = c / temp;\n     }\n     return 2;\n   }"}]}