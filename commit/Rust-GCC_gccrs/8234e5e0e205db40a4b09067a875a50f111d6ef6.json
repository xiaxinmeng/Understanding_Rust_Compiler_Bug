{"sha": "8234e5e0e205db40a4b09067a875a50f111d6ef6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODIzNGU1ZTBlMjA1ZGI0MGE0YjA5MDY3YTg3NWE1MGYxMTFkNmVmNg==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2009-08-23T03:19:55Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2009-08-23T03:19:55Z"}, "message": "allocate_alloc_opt_4.f90: New test.\n\n2009-08-22 Steven K. kargl  <kargl@gcc.gnu.org>\n\n\t* gfortran.dg/allocate_alloc_opt_4.f90: New test.\n\t* gfortran.dg/allocate_alloc_opt_5.f90: New test.\n\t* gfortran.dg/allocate_alloc_opt_6.f90: New test.\n\n2009-08-22 Steven K. kargl  <kargl@gcc.gnu.org>\n\n\t* fortran/decl.c (match_char_spec): Rename to gfc_match_char_spec,\n\tand remove static.\n\t* fortran/gfortran.h: Add *expr3 entity to gfc_code.  Add prototype\n\tfor gfc_match_char_spec.\n\t* fortran/trans-stmt.c (gfc_trans_allocate): Translate the SOURCE=\n\ttag.\n\t* fortran/match.c (match_intrinsic_typespec): New function to match\n\tF2003 intrinsic-type-spec.\n\t(conformable_arrays): New function. Check SOURCE= and\n\tallocation-object are conformable.\n\t(gfc_match_allocate): Use new functions.  Match SOURCE= tag.\n\nFrom-SVN: r151023", "tree": {"sha": "ddb726a4bc9d6858868e01db05219108c423d6b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ddb726a4bc9d6858868e01db05219108c423d6b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8234e5e0e205db40a4b09067a875a50f111d6ef6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8234e5e0e205db40a4b09067a875a50f111d6ef6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8234e5e0e205db40a4b09067a875a50f111d6ef6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8234e5e0e205db40a4b09067a875a50f111d6ef6/comments", "author": null, "committer": null, "parents": [{"sha": "e25b7843ec7184bf740693005ab35619ab9ed561", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e25b7843ec7184bf740693005ab35619ab9ed561", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e25b7843ec7184bf740693005ab35619ab9ed561"}], "stats": {"total": 436, "additions": 418, "deletions": 18}, "files": [{"sha": "4869fe82fb99ca1e70f737e8244a737c6aee8f32", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8234e5e0e205db40a4b09067a875a50f111d6ef6/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8234e5e0e205db40a4b09067a875a50f111d6ef6/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8234e5e0e205db40a4b09067a875a50f111d6ef6", "patch": "@@ -1,3 +1,17 @@\n+2009-08-22 Steven K. kargl  <kargl@gcc.gnu.org>\n+\n+\t* fortran/decl.c (match_char_spec): Rename to gfc_match_char_spec,\n+\tand remove static.\n+\t* fortran/gfortran.h: Add *expr3 entity to gfc_code.  Add prototype\n+\tfor gfc_match_char_spec.\n+\t* fortran/trans-stmt.c (gfc_trans_allocate): Translate the SOURCE=\n+\ttag.\n+\t* fortran/match.c (match_intrinsic_typespec): New function to match\n+\tF2003 intrinsic-type-spec.\n+\t(conformable_arrays): New function. Check SOURCE= and\n+\tallocation-object are conformable.\n+\t(gfc_match_allocate): Use new functions.  Match SOURCE= tag.\n+\n 2009-08-22\tBud Davis <bdavis9659@sbcglobal.net>\n \n \tPR fortran/28093"}, {"sha": "1533af54eaa85e77267a5dc35ea686ac60fcd559", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8234e5e0e205db40a4b09067a875a50f111d6ef6/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8234e5e0e205db40a4b09067a875a50f111d6ef6/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=8234e5e0e205db40a4b09067a875a50f111d6ef6", "patch": "@@ -2104,11 +2104,12 @@ match_char_kind (int * kind, int * is_iso_c)\n   return m;\n }\n \n+\n /* Match the various kind/length specifications in a CHARACTER\n    declaration.  We don't return MATCH_NO.  */\n \n-static match\n-match_char_spec (gfc_typespec *ts)\n+match\n+gfc_match_char_spec (gfc_typespec *ts)\n {\n   int kind, seen_length, is_iso_c;\n   gfc_charlen *cl;\n@@ -2324,7 +2325,7 @@ gfc_match_type_spec (gfc_typespec *ts, int implicit_flag)\n     {\n       ts->type = BT_CHARACTER;\n       if (implicit_flag == 0)\n-\treturn match_char_spec (ts);\n+\treturn gfc_match_char_spec (ts);\n       else\n \treturn MATCH_YES;\n     }\n@@ -2636,7 +2637,7 @@ gfc_match_implicit (void)\n \n       /* Last chance -- check <TYPE> <SELECTOR> (<RANGE>).  */\n       if (ts.type == BT_CHARACTER)\n-\tm = match_char_spec (&ts);\n+\tm = gfc_match_char_spec (&ts);\n       else\n \t{\n \t  m = gfc_match_kind_spec (&ts, false);"}, {"sha": "cbab000ad6eeaeeea20ec8225b183b5fdf50ddea", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8234e5e0e205db40a4b09067a875a50f111d6ef6/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8234e5e0e205db40a4b09067a875a50f111d6ef6/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=8234e5e0e205db40a4b09067a875a50f111d6ef6", "patch": "@@ -1977,7 +1977,7 @@ typedef struct gfc_code\n \n   gfc_st_label *here, *label1, *label2, *label3;\n   gfc_symtree *symtree;\n-  gfc_expr *expr1, *expr2;\n+  gfc_expr *expr1, *expr2, *expr3;\n   /* A name isn't sufficient to identify a subroutine, we need the actual\n      symbol for the interface definition.\n   const char *sub_name;  */\n@@ -2184,6 +2184,7 @@ gfc_finalizer;\n \n /* decl.c */\n bool gfc_in_match_data (void);\n+match gfc_match_char_spec (gfc_typespec *);\n \n /* scanner.c */\n void gfc_scanner_done_1 (void);"}, {"sha": "9ba3e09b85f30526ea2a6bd5e21ee2c15eca2dd3", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 268, "deletions": 13, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8234e5e0e205db40a4b09067a875a50f111d6ef6/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8234e5e0e205db40a4b09067a875a50f111d6ef6/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=8234e5e0e205db40a4b09067a875a50f111d6ef6", "patch": "@@ -2221,23 +2221,186 @@ gfc_free_alloc_list (gfc_alloc *p)\n }\n \n \n+/* Match a Fortran 2003 intrinsic-type-spec.  This is a stripped\n+   down version of gfc_match_type_spec() from decl.c.  It only includes\n+   the intrinsic types from the Fortran 2003 standard.  Thus, neither\n+   BYTE nor forms like REAL*4 are allowed.  Additionally, the implicit_flag\n+   is not needed, so it was removed.  The handling of derived types has\n+   been removed and no notion of the gfc_matching_function state\n+   is needed.  In short, this functions matches only standard conforming\n+   intrinsic-type-spec (R403).  */\n+\n+static match\n+match_intrinsic_typespec (gfc_typespec *ts)\n+{\n+  match m;\n+\n+  gfc_clear_ts (ts);\n+\n+  if (gfc_match (\"integer\") == MATCH_YES)\n+    {\n+      ts->type = BT_INTEGER;\n+      ts->kind = gfc_default_integer_kind;\n+      goto kind_selector;\n+    }\n+\n+  if (gfc_match (\"real\") == MATCH_YES)\n+    {\n+      ts->type = BT_REAL;\n+      ts->kind = gfc_default_real_kind;\n+      goto kind_selector;\n+    }\n+\n+  if (gfc_match (\"double precision\") == MATCH_YES)\n+    {\n+      ts->type = BT_REAL;\n+      ts->kind = gfc_default_double_kind;\n+      return MATCH_YES;\n+    }\n+\n+  if (gfc_match (\"complex\") == MATCH_YES)\n+    {\n+      ts->type = BT_COMPLEX;\n+      ts->kind = gfc_default_complex_kind;\n+      goto kind_selector;\n+    }\n+\n+  if (gfc_match (\"character\") == MATCH_YES)\n+    {\n+      ts->type = BT_CHARACTER;\n+      goto char_selector;\n+    }\n+\n+  if (gfc_match (\"logical\") == MATCH_YES)\n+    {\n+      ts->type = BT_LOGICAL;\n+      ts->kind = gfc_default_logical_kind;\n+      goto kind_selector;\n+    }\n+\n+  /* If an intrinsic type is not matched, simply return MATCH_NO.  */ \n+  return MATCH_NO;\n+\n+kind_selector:\n+\n+  gfc_gobble_whitespace ();\n+  if (gfc_peek_ascii_char () == '*')\n+    {\n+      gfc_error (\"Invalid type-spec at %C\");\n+      return MATCH_ERROR;\n+    }\n+\n+  m = gfc_match_kind_spec (ts, false);\n+\n+  if (m == MATCH_NO)\n+    m = MATCH_YES;\t\t/* No kind specifier found.  */\n+\n+  return m;\n+\n+char_selector:\n+\n+  m = gfc_match_char_spec (ts);\n+\n+  if (m == MATCH_NO)\n+    m = MATCH_YES;\t\t/* No kind specifier found.  */\n+\n+  return m;\n+}\n+\n+\n+/* Used in gfc_match_allocate to check that a allocation-object and\n+   a source-expr are conformable.  This does not catch all possible \n+   cases; in particular a runtime checking is needed.  */\n+\n+static gfc_try\n+conformable_arrays (gfc_expr *e1, gfc_expr *e2)\n+{\n+  /* First compare rank.  */\n+  if (e2->ref && e1->rank != e2->ref->u.ar.as->rank)\n+    {\n+      gfc_error (\"Source-expr at %L must be scalar or have the \"\n+\t\t \"same rank as the allocate-object at %L\",\n+\t\t &e1->where, &e2->where);\n+      return FAILURE;\n+    }\n+\n+  if (e1->shape)\n+    {\n+      int i;\n+      mpz_t s;\n+\n+      mpz_init (s);\n+\n+      for (i = 0; i < e1->rank; i++)\n+\t{\n+\t  if (e2->ref->u.ar.end[i])\n+\t    {\n+\t      mpz_set (s, e2->ref->u.ar.end[i]->value.integer);\n+\t      mpz_sub (s, s, e2->ref->u.ar.start[i]->value.integer);\n+\t      mpz_add_ui (s, s, 1);\n+\t    }\n+\t  else\n+\t    {\n+\t      mpz_set (s, e2->ref->u.ar.start[i]->value.integer);\n+\t    }\n+\n+\t  if (mpz_cmp (e1->shape[i], s) != 0)\n+\t    {\n+\t      gfc_error (\"Source-expr at %L and allocate-object at %L must \"\n+\t\t\t \"have the same shape\", &e1->where, &e2->where);\n+\t      mpz_clear (s);\n+   \t      return FAILURE;\n+\t    }\n+\t}\n+\n+      mpz_clear (s);\n+    }\n+\n+  return SUCCESS;\n+}\n+\n+\n /* Match an ALLOCATE statement.  */\n \n match\n gfc_match_allocate (void)\n {\n   gfc_alloc *head, *tail;\n-  gfc_expr *stat, *errmsg, *tmp;\n+  gfc_expr *stat, *errmsg, *tmp, *source;\n+  gfc_typespec ts;\n   match m;\n-  bool saw_stat, saw_errmsg;\n+  locus old_locus;\n+  bool saw_stat, saw_errmsg, saw_source, b1, b2, b3;\n \n   head = tail = NULL;\n-  stat = errmsg = tmp = NULL;\n-  saw_stat = saw_errmsg = false;\n+  stat = errmsg = source = tmp = NULL;\n+  saw_stat = saw_errmsg = saw_source = false;\n \n   if (gfc_match_char ('(') != MATCH_YES)\n     goto syntax;\n \n+  /* Match an optional intrinsic-type-spec.  */\n+  old_locus = gfc_current_locus;\n+  m = match_intrinsic_typespec (&ts);\n+  if (m == MATCH_ERROR)\n+    goto cleanup;\n+  else if (m == MATCH_NO)\n+    ts.type = BT_UNKNOWN;\n+  else\n+    {\n+      if (gfc_match (\" :: \") == MATCH_YES)\n+\t{\n+\t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: typespec in \"\n+\t\t\t      \"ALLOCATE at %L\", &old_locus) == FAILURE)\n+\t    goto cleanup;\n+\t}\n+      else\n+\t{\n+\t  ts.type = BT_UNKNOWN;\n+\t  gfc_current_locus = old_locus;\n+\t}\n+    }\n+\n   for (;;)\n     {\n       if (head == NULL)\n@@ -2263,17 +2426,46 @@ gfc_match_allocate (void)\n \t  goto cleanup;\n \t}\n \n+      /* The ALLOCATE statement had an optional typespec.  Check the\n+\t constraints.  */\n+      if (ts.type != BT_UNKNOWN)\n+\t{\n+\t  /* Enforce C626.  */\n+\t  if (ts.type != tail->expr->ts.type)\n+\t    {\n+\t      gfc_error (\"Type of entity at %L is type incompatible with \"\n+\t\t\t \"typespec\", &tail->expr->where);\n+\t      goto cleanup;\n+\t    }\n+\n+\t  /* Enforce C627.  */\n+\t  if (ts.kind != tail->expr->ts.kind)\n+\t    {\n+\t      gfc_error (\"Kind type parameter for entity at %L differs from \"\n+\t\t\t \"the kind type parameter of the typespec\",\n+\t\t\t &tail->expr->where);\n+\t      goto cleanup;\n+\t    }\n+\t}\n+\n       if (tail->expr->ts.type == BT_DERIVED)\n \ttail->expr->ts.u.derived = gfc_use_derived (tail->expr->ts.u.derived);\n \n       /* FIXME: disable the checking on derived types and arrays.  */\n-      if (!(tail->expr->ref\n+      b1 = !(tail->expr->ref\n \t   && (tail->expr->ref->type == REF_COMPONENT\n-\t       || tail->expr->ref->type == REF_ARRAY)) \n-\t  && tail->expr->symtree->n.sym\n-\t  && !(tail->expr->symtree->n.sym->attr.allocatable\n-\t       || tail->expr->symtree->n.sym->attr.pointer\n-\t       || tail->expr->symtree->n.sym->attr.proc_pointer))\n+\t\t|| tail->expr->ref->type == REF_ARRAY));\n+      b2 = tail->expr->symtree->n.sym\n+\t   && !(tail->expr->symtree->n.sym->attr.allocatable\n+\t\t|| tail->expr->symtree->n.sym->attr.pointer\n+\t\t|| tail->expr->symtree->n.sym->attr.proc_pointer);\n+      b3 = tail->expr->symtree->n.sym\n+\t   && tail->expr->symtree->n.sym->ns\n+\t   && tail->expr->symtree->n.sym->ns->proc_name\n+\t   && (tail->expr->symtree->n.sym->ns->proc_name->attr.allocatable\n+\t\t|| tail->expr->symtree->n.sym->ns->proc_name->attr.pointer\n+\t\t|| tail->expr->symtree->n.sym->ns->proc_name->attr.proc_pointer);\n+      if (b1 && b2 && !b3)\n \t{\n \t  gfc_error (\"Allocate-object at %C is not a nonprocedure pointer \"\n \t\t     \"or an allocatable variable\");\n@@ -2290,10 +2482,10 @@ gfc_match_allocate (void)\n \tgoto cleanup;\n       if (m == MATCH_YES)\n \t{\n+\t  /* Enforce C630.  */\n \t  if (saw_stat)\n \t    {\n \t      gfc_error (\"Redundant STAT tag found at %L \", &tmp->where);\n-\t      gfc_free_expr (tmp);\n \t      goto cleanup;\n \t    }\n \n@@ -2312,14 +2504,14 @@ gfc_match_allocate (void)\n \tgoto cleanup;\n       if (m == MATCH_YES)\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: ERRMSG at %L\",\n+\t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: ERRMSG tag at %L\",\n \t\t\t      &tmp->where) == FAILURE)\n \t    goto cleanup;\n \n+\t  /* Enforce C630.  */\n \t  if (saw_errmsg)\n \t    {\n \t      gfc_error (\"Redundant ERRMSG tag found at %L \", &tmp->where);\n-\t      gfc_free_expr (tmp);\n \t      goto cleanup;\n \t    }\n \n@@ -2330,6 +2522,66 @@ gfc_match_allocate (void)\n \t    goto alloc_opt_list;\n \t}\n \n+      m = gfc_match (\" source = %e\", &tmp);\n+      if (m == MATCH_ERROR)\n+\tgoto cleanup;\n+      if (m == MATCH_YES)\n+\t{\n+\t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: SOURCE tag at %L\",\n+\t\t\t      &tmp->where) == FAILURE)\n+\t    goto cleanup;\n+\n+\t  /* Enforce C630.  */\n+\t  if (saw_source)\n+\t    {\n+\t      gfc_error (\"Redundant SOURCE tag found at %L \", &tmp->where);\n+\t      goto cleanup;\n+\t    }\n+\n+\t  /* The next 3 conditionals check C631.  */\n+\t  if (ts.type != BT_UNKNOWN)\n+\t    {\n+\t      gfc_error (\"SOURCE tag at %L conflicts with the typespec at %L\",\n+\t\t\t &tmp->where, &old_locus);\n+\t      goto cleanup;\n+\t    }\n+\n+\t  if (head->next)\n+\t    {\n+ \t      gfc_error (\"SOURCE tag at %L requires only a single entity in \"\n+\t\t\t \"the allocation-list\", &tmp->where);\n+\t      goto cleanup;\n+            }\n+\n+\t  gfc_resolve_expr (tmp);\n+\n+\t  if (head->expr->ts.type != tmp->ts.type)\n+\t    {\n+\t      gfc_error (\"Type of entity at %L is type incompatible with \"\n+\t\t\t \"source-expr at %L\", &head->expr->where, &tmp->where);\n+\t      goto cleanup;\n+\t    }\n+\n+\t  /* Check C633.  */\n+\t  if (tmp->ts.kind != head->expr->ts.kind)\n+\t    {\n+\t      gfc_error (\"The allocate-object at %L and the source-expr at %L \"\n+\t\t\t \"shall have the same kind type parameter\",\n+\t\t\t &head->expr->where, &tmp->where);\n+\t      goto cleanup;\n+\t    }\n+\n+\t  /* Check C632 and restriction following Note 6.18.  */\n+\t  if (tmp->rank > 0 && conformable_arrays (tmp, head->expr) == FAILURE)\n+\t    goto cleanup;\n+\n+\t  source = tmp;\n+\t  saw_source = true;\n+\n+\t  if (gfc_match_char (',') == MATCH_YES)\n+\t    goto alloc_opt_list;\n+\t}\n+\n \tgfc_gobble_whitespace ();\n \n \tif (gfc_peek_char () == ')')\n@@ -2343,6 +2595,7 @@ gfc_match_allocate (void)\n   new_st.op = EXEC_ALLOCATE;\n   new_st.expr1 = stat;\n   new_st.expr2 = errmsg;\n+  new_st.expr3 = source;\n   new_st.ext.alloc_list = head;\n \n   return MATCH_YES;\n@@ -2352,7 +2605,9 @@ gfc_match_allocate (void)\n \n cleanup:\n   gfc_free_expr (errmsg);\n+  gfc_free_expr (source);\n   gfc_free_expr (stat);\n+  gfc_free_expr (tmp);\n   gfc_free_alloc_list (head);\n   return MATCH_ERROR;\n }"}, {"sha": "6aed99b287c43d5bc4f0737c3fb6b3a82e8a71be", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8234e5e0e205db40a4b09067a875a50f111d6ef6/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8234e5e0e205db40a4b09067a875a50f111d6ef6/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=8234e5e0e205db40a4b09067a875a50f111d6ef6", "patch": "@@ -4081,6 +4081,44 @@ gfc_trans_allocate (gfc_code * code)\n       gfc_add_expr_to_block (&block, tmp);\n     }\n \n+  /* SOURCE block.  Note, by C631, we know that code->ext.alloc_list\n+     has a single entity.  */\n+  if (code->expr3)\n+    {\n+      gfc_ref *ref;\n+      gfc_array_ref *ar;\n+      int n;\n+\n+      /* If there is a terminating array reference, this is converted\n+\t to a full array, so that gfc_trans_assignment can scalarize the\n+\t expression for the source.  */\n+      for (ref = code->ext.alloc_list->expr->ref; ref; ref = ref->next)\n+\t{\n+\t  if (ref->next == NULL)\n+\t    {\n+\t      if (ref->type != REF_ARRAY)\n+\t\tbreak;\n+\n+\t      ref->u.ar.type = AR_FULL;\n+\t      ar = &ref->u.ar;\n+\t      ar->dimen = ar->as->rank;\n+\t      for (n = 0; n < ar->dimen; n++)\n+\t\t{\n+\t\t  ar->dimen_type[n] = DIMEN_RANGE;\n+\t\t  gfc_free_expr (ar->start[n]);\n+\t\t  gfc_free_expr (ar->end[n]);\n+\t\t  gfc_free_expr (ar->stride[n]);\n+\t\t  ar->start[n] = NULL;\n+\t\t  ar->end[n] = NULL;\n+\t\t  ar->stride[n] = NULL;\n+\t\t}\n+\t    }\n+\t}\n+\n+      tmp = gfc_trans_assignment (code->ext.alloc_list->expr, code->expr3, false);\n+      gfc_add_expr_to_block (&block, tmp);\n+    }\n+\n   return gfc_finish_block (&block);\n }\n "}, {"sha": "2c8997d15ce0906d88bdcd7d599d53aafc94784f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8234e5e0e205db40a4b09067a875a50f111d6ef6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8234e5e0e205db40a4b09067a875a50f111d6ef6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8234e5e0e205db40a4b09067a875a50f111d6ef6", "patch": "@@ -1,7 +1,14 @@\n+2009-08-22 Steven K. kargl  <kargl@gcc.gnu.org>\n+\n+\t* gfortran.dg/allocate_alloc_opt_4.f90: New test.\n+\t* gfortran.dg/allocate_alloc_opt_5.f90: New test.\n+\t* gfortran.dg/allocate_alloc_opt_6.f90: New test.\n+\n 2009-08-22  Bud Davis  <bdavis9659@sbcglobal.net>\n \n \tPR fortran/28039\n \t* gfortran.dg/fmt_with_extra.f: new file.\n+\n 2009-08-21  Maciej W. Rozycki  <macro@codesourcery.com>\n \n \t* lib/target-supports.exp"}, {"sha": "89052ef16b9aa7a64863a7dc5907c4d0f207d43b", "filename": "gcc/testsuite/gfortran.dg/allocate_alloc_opt_4.f90", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8234e5e0e205db40a4b09067a875a50f111d6ef6/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_alloc_opt_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8234e5e0e205db40a4b09067a875a50f111d6ef6/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_alloc_opt_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_alloc_opt_4.f90?ref=8234e5e0e205db40a4b09067a875a50f111d6ef6", "patch": "@@ -0,0 +1,27 @@\n+! { dg-do compile }\n+program a\n+\n+  implicit none\n+\n+  integer n, m(3,3)\n+  integer(kind=8) k\n+  integer, allocatable :: i(:), j(:)\n+  real, allocatable :: x(:)\n+\n+  n = 42\n+  m = n\n+  k = 1_8\n+\n+  allocate(i(4), source=42, source=n) ! { dg-error \"Redundant SOURCE tag found\" }\n+\n+  allocate(integer(4) :: i(4), source=n) ! { dg-error \"conflicts with the typespec\" }\n+\n+  allocate(i(4), j(n), source=n) ! { dg-error \"requires only a single entity\" }\n+\n+  allocate(x(4), source=n) ! { dg-error \"type incompatible with\" }\n+\n+  allocate(i(4), source=m) ! { dg-error \"must be scalar or have the same rank\" }\n+\n+  allocate(i(4), source=k) ! { dg-error \"shall have the same kind type\" }\n+\n+end program a"}, {"sha": "d7e3ea93f1bebc351278690d19dd9928b61d82b2", "filename": "gcc/testsuite/gfortran.dg/allocate_alloc_opt_5.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8234e5e0e205db40a4b09067a875a50f111d6ef6/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_alloc_opt_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8234e5e0e205db40a4b09067a875a50f111d6ef6/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_alloc_opt_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_alloc_opt_5.f90?ref=8234e5e0e205db40a4b09067a875a50f111d6ef6", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f95\" }\n+program a\n+\n+  implicit none\n+\n+  integer n\n+  character(len=70) str\n+  integer, allocatable :: i(:)\n+\n+  n = 42\n+  allocate(i(4), source=n) ! { dg-error \"Fortran 2003: SOURCE tag\" }\n+  allocate(i(4), stat=n, errmsg=str) ! { dg-error \"Fortran 2003: ERRMSG tag\" }\n+\n+end program a"}, {"sha": "d470b424a1ce41bfe9f66f850d12d79e4bef52a4", "filename": "gcc/testsuite/gfortran.dg/allocate_alloc_opt_6.f90", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8234e5e0e205db40a4b09067a875a50f111d6ef6/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_alloc_opt_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8234e5e0e205db40a4b09067a875a50f111d6ef6/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_alloc_opt_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_alloc_opt_6.f90?ref=8234e5e0e205db40a4b09067a875a50f111d6ef6", "patch": "@@ -0,0 +1,42 @@\n+! { dg-do run }\n+program a\n+\n+  implicit none\n+\n+  type :: mytype\n+    real ::  r\n+    integer :: i\n+  end type mytype\n+  \n+  integer n\n+  integer, allocatable :: i(:)\n+  real z\n+  real, allocatable :: x(:)\n+  type(mytype), pointer :: t\n+\n+  n = 42\n+  z = 99.\n+\n+  allocate(i(4), source=n)\n+  if (any(i /= 42)) call abort\n+\n+  allocate(x(4), source=z)\n+  if (any(x /= 99.)) call abort\n+\n+  allocate(t, source=mytype(1.0,2))\n+  if (t%r /= 1. .or. t%i /= 2) call abort\n+\n+  deallocate(i)\n+  allocate(i(3), source=(/1, 2, 3/))\n+  if (i(1) /= 1 .or. i(2) /= 2 .or. i(3) /= 3) call abort\n+\n+  call sub1(i)\n+\n+end program a\n+\n+subroutine sub1(j)\n+   integer, intent(in) :: j(*)\n+   integer, allocatable :: k(:)\n+   allocate(k(2), source=j(1:2))\n+   if (k(1) /= 1 .or. k(2) /= 2) call abort\n+end subroutine sub1"}]}