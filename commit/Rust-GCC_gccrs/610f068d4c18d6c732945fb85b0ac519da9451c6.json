{"sha": "610f068d4c18d6c732945fb85b0ac519da9451c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjEwZjA2OGQ0YzE4ZDZjNzMyOTQ1ZmI4NWIwYWM1MTlkYTk0NTFjNg==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2011-11-04T00:09:27Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2011-11-04T00:09:27Z"}, "message": "trans-intrinsic.c (gfc_conv_intrinsic_minmaxloc): Set loop's temporary rank to the loop rank.\n\n\t* trans-intrinsic.c (gfc_conv_intrinsic_minmaxloc): Set loop's\n\ttemporary rank to the loop rank. Mark ss chains for multiple loop\n\tif necessary.  Use gfc_trans_scalarized_loop_boundary to end one loop\n\tand start another.\n\nFrom-SVN: r180908", "tree": {"sha": "a0df7969146da71b5d634c51ad8b3f16eba47408", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0df7969146da71b5d634c51ad8b3f16eba47408"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/610f068d4c18d6c732945fb85b0ac519da9451c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/610f068d4c18d6c732945fb85b0ac519da9451c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/610f068d4c18d6c732945fb85b0ac519da9451c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/610f068d4c18d6c732945fb85b0ac519da9451c6/comments", "author": null, "committer": null, "parents": [{"sha": "89d65e2d2f2d5d2aa3e2e4c02f4ad5b80e241c46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89d65e2d2f2d5d2aa3e2e4c02f4ad5b80e241c46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89d65e2d2f2d5d2aa3e2e4c02f4ad5b80e241c46"}], "stats": {"total": 31, "additions": 27, "deletions": 4}, "files": [{"sha": "9b518595fbdd86458e1a9b0f220db05c81f25b65", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610f068d4c18d6c732945fb85b0ac519da9451c6/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610f068d4c18d6c732945fb85b0ac519da9451c6/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=610f068d4c18d6c732945fb85b0ac519da9451c6", "patch": "@@ -1,3 +1,10 @@\n+2011-11-04  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_minmaxloc): Set loop's\n+\ttemporary rank to the loop rank. Mark ss chains for multiple loop\n+\tif necessary.  Use gfc_trans_scalarized_loop_boundary to end one loop\n+\tand start another.\n+\n 2011-11-04  Mikael Morin  <mikael@gcc.gnu.org>\n \n \t* trans-intrinsic.c (gfc_conv_intrinsic_minmaxloc): Don't calculate"}, {"sha": "506cdf22b8005af3615199472c8afebb4362804b", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610f068d4c18d6c732945fb85b0ac519da9451c6/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610f068d4c18d6c732945fb85b0ac519da9451c6/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=610f068d4c18d6c732945fb85b0ac519da9451c6", "patch": "@@ -3061,6 +3061,23 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \n   /* Initialize the loop.  */\n   gfc_conv_ss_startstride (&loop);\n+\n+  /* The code generated can have more than one loop in sequence (see the\n+     comment at the function header).  This doesn't work well with the\n+     scalarizer, which changes arrays' offset when the scalarization loops\n+     are generated (see gfc_trans_preloop_setup).  Fortunately, {min,max}loc\n+     are  currently inlined in the scalar case only (for which loop is of rank\n+     one).  As there is no dependency to care about in that case, there is no\n+     temporary, so that we can use the scalarizer temporary code to handle\n+     multiple loops.  Thus, we set temp_dim here, we call gfc_mark_ss_chain_used\n+     with flag=3 later, and we use gfc_trans_scalarized_loop_boundary even later\n+     to restore offset.\n+     TODO: this prevents inlining of rank > 0 minmaxloc calls, so this\n+     should eventually go away.  We could either create two loops properly,\n+     or find another way to save/restore the array offsets between the two\n+     loops (without conflicting with temporary management), or use a single\n+     loop minmaxloc implementation.  See PR 31067.  */\n+  loop.temp_dim = loop.dimen;\n   gfc_conv_loop_setup (&loop, &expr->where);\n \n   gcc_assert (loop.dimen == 1);\n@@ -3098,9 +3115,9 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \t\t\t gfc_index_one_node, loop.from[0]);\n   gfc_add_modify (&loop.pre, offset, tmp);\n \n-  gfc_mark_ss_chain_used (arrayss, 1);\n+  gfc_mark_ss_chain_used (arrayss, lab1 ? 3 : 1);\n   if (maskss)\n-    gfc_mark_ss_chain_used (maskss, 1);\n+    gfc_mark_ss_chain_used (maskss, lab1 ? 3 : 1);\n   /* Generate the loop body.  */\n   gfc_start_scalarized_body (&loop, &body);\n \n@@ -3186,7 +3203,7 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \n   if (lab1)\n     {\n-      gfc_trans_scalarized_loop_end (&loop, 0, &body);\n+      gfc_trans_scalarized_loop_boundary (&loop, &body);\n \n       if (HONOR_NANS (DECL_MODE (limit)))\n \t{\n@@ -3201,7 +3218,6 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \n       gfc_add_expr_to_block (&loop.code[0], build1_v (GOTO_EXPR, lab2));\n       gfc_add_expr_to_block (&loop.code[0], build1_v (LABEL_EXPR, lab1));\n-      gfc_start_block (&body);\n \n       /* If we have a mask, only check this element if the mask is set.  */\n       if (maskss)"}]}