{"sha": "641c2f8b69f799a00d0fda696d480e10505257c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQxYzJmOGI2OWY3OTlhMDBkMGZkYTY5NmQ0ODBlMTA1MDUyNTdjMw==", "commit": {"author": {"name": "Matthew Wahab", "email": "matthew.wahab@arm.com", "date": "2015-09-22T09:35:17Z"}, "committer": {"name": "Matthew Wahab", "email": "mwahab@gcc.gnu.org", "date": "2015-09-22T09:35:17Z"}, "message": "[AArch64] Use atomic load-operate instructions for fetch-update patterns.\n\ngcc/\n2015-09-22  Matthew Wahab  <matthew.wahab@arm.com>\n\n\t* config/aarch64/aarch64-protos.h\n\t(aarch64_atomic_ldop_supported_p): Declare.\n\t* config/aarch64/aarch64.c (aarch64_atomic_ldop_supported_p): New.\n\t(enum aarch64_atomic_load_op_code): New.\n\t(aarch64_emit_atomic_load_op): New.\n\t(aarch64_gen_atomic_ldop): Update to support load-operate\n\tpatterns.\n\t* config/aarch64/atomics.md (atomic_<atomic_optab><mode>): Change\n\tto an expander.\n\t(aarch64_atomic_<atomic_optab><mode>): New.\n\t(aarch64_atomic_<atomic_optab><mode>_lse): New.\n\t(atomic_fetch_<atomic_optab><mode>): Change to an expander.\n\t(aarch64_atomic_fetch_<atomic_optab><mode>): New.\n\t(aarch64_atomic_fetch_<atomic_optab><mode>_lse): New.\n\ngcc/testsuite/\n2015-09-22  Matthew Wahab  <matthew.wahab@arm.com>\n\n\t* gcc.target/aarch64/atomic-inst-ldadd.c: New.\n\t* gcc.target/aarch64/atomic-inst-ldlogic.c: New.\n\nFrom-SVN: r228001", "tree": {"sha": "2220bcca76e385fc63c24283ae19a9119a3f587b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2220bcca76e385fc63c24283ae19a9119a3f587b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/641c2f8b69f799a00d0fda696d480e10505257c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/641c2f8b69f799a00d0fda696d480e10505257c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/641c2f8b69f799a00d0fda696d480e10505257c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/641c2f8b69f799a00d0fda696d480e10505257c3/comments", "author": null, "committer": null, "parents": [{"sha": "6380d2bc38237e00e3d460882b4b0938bbb068b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6380d2bc38237e00e3d460882b4b0938bbb068b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6380d2bc38237e00e3d460882b4b0938bbb068b9"}], "stats": {"total": 467, "additions": 455, "deletions": 12}, "files": [{"sha": "ad6ec7f03535a53bfb98512ecd10bd3e731667e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641c2f8b69f799a00d0fda696d480e10505257c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641c2f8b69f799a00d0fda696d480e10505257c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=641c2f8b69f799a00d0fda696d480e10505257c3", "patch": "@@ -1,3 +1,20 @@\n+2015-09-22  Matthew Wahab  <matthew.wahab@arm.com>\n+\n+\t* config/aarch64/aarch64-protos.h\n+\t(aarch64_atomic_ldop_supported_p): Declare.\n+\t* config/aarch64/aarch64.c (aarch64_atomic_ldop_supported_p): New.\n+\t(enum aarch64_atomic_load_op_code): New.\n+\t(aarch64_emit_atomic_load_op): New.\n+\t(aarch64_gen_atomic_ldop): Update to support load-operate\n+\tpatterns.\n+\t* config/aarch64/atomics.md (atomic_<atomic_optab><mode>): Change\n+\tto an expander.\n+\t(aarch64_atomic_<atomic_optab><mode>): New.\n+\t(aarch64_atomic_<atomic_optab><mode>_lse): New.\n+\t(atomic_fetch_<atomic_optab><mode>): Change to an expander.\n+\t(aarch64_atomic_fetch_<atomic_optab><mode>): New.\n+\t(aarch64_atomic_fetch_<atomic_optab><mode>_lse): New.\n+\n 2015-09-22  Matthew Wahab  <matthew.wahab@arm.com>\n \n \t* config/aarch64/aarch64/atomics.md (UNSPECV_ATOMIC_LDOP): New."}, {"sha": "76ebd6f37b75477f75356fd424c74ad42e126c19", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641c2f8b69f799a00d0fda696d480e10505257c3/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641c2f8b69f799a00d0fda696d480e10505257c3/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=641c2f8b69f799a00d0fda696d480e10505257c3", "patch": "@@ -378,6 +378,8 @@ rtx aarch64_load_tp (rtx);\n void aarch64_expand_compare_and_swap (rtx op[]);\n void aarch64_split_compare_and_swap (rtx op[]);\n void aarch64_gen_atomic_cas (rtx, rtx, rtx, rtx, rtx);\n+\n+bool aarch64_atomic_ldop_supported_p (enum rtx_code);\n void aarch64_gen_atomic_ldop (enum rtx_code, rtx, rtx, rtx, rtx);\n void aarch64_split_atomic_op (enum rtx_code, rtx, rtx, rtx, rtx, rtx, rtx);\n "}, {"sha": "93e36b76a29807bf84e8985d494b54d28a01531d", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 172, "deletions": 3, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641c2f8b69f799a00d0fda696d480e10505257c3/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641c2f8b69f799a00d0fda696d480e10505257c3/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=641c2f8b69f799a00d0fda696d480e10505257c3", "patch": "@@ -10871,6 +10871,32 @@ aarch64_expand_compare_and_swap (rtx operands[])\n   emit_insn (gen_rtx_SET (bval, x));\n }\n \n+/* Test whether the target supports using a atomic load-operate instruction.\n+   CODE is the operation and AFTER is TRUE if the data in memory after the\n+   operation should be returned and FALSE if the data before the operation\n+   should be returned.  Returns FALSE if the operation isn't supported by the\n+   architecture.  */\n+\n+bool\n+aarch64_atomic_ldop_supported_p (enum rtx_code code)\n+{\n+  if (!TARGET_LSE)\n+    return false;\n+\n+  switch (code)\n+    {\n+    case SET:\n+    case AND:\n+    case IOR:\n+    case XOR:\n+    case MINUS:\n+    case PLUS:\n+      return true;\n+    default:\n+      return false;\n+    }\n+}\n+\n /* Emit a barrier, that is appropriate for memory model MODEL, at the end of a\n    sequence implementing an atomic operation.  */\n \n@@ -11013,26 +11039,169 @@ aarch64_emit_atomic_swap (machine_mode mode, rtx dst, rtx value,\n   emit_insn (gen (dst, mem, value, model));\n }\n \n-/* Emit an atomic operation where the architecture supports it.  */\n+/* Operations supported by aarch64_emit_atomic_load_op.  */\n+\n+enum aarch64_atomic_load_op_code\n+{\n+  AARCH64_LDOP_PLUS,\t/* A + B  */\n+  AARCH64_LDOP_XOR,\t/* A ^ B  */\n+  AARCH64_LDOP_OR,\t/* A | B  */\n+  AARCH64_LDOP_BIC\t/* A & ~B  */\n+};\n+\n+/* Emit an atomic load-operate.  */\n+\n+static void\n+aarch64_emit_atomic_load_op (enum aarch64_atomic_load_op_code code,\n+\t\t\t     machine_mode mode, rtx dst, rtx src,\n+\t\t\t     rtx mem, rtx model)\n+{\n+  typedef rtx (*aarch64_atomic_load_op_fn) (rtx, rtx, rtx, rtx);\n+  const aarch64_atomic_load_op_fn plus[] =\n+  {\n+    gen_aarch64_atomic_loadaddqi,\n+    gen_aarch64_atomic_loadaddhi,\n+    gen_aarch64_atomic_loadaddsi,\n+    gen_aarch64_atomic_loadadddi\n+  };\n+  const aarch64_atomic_load_op_fn eor[] =\n+  {\n+    gen_aarch64_atomic_loadeorqi,\n+    gen_aarch64_atomic_loadeorhi,\n+    gen_aarch64_atomic_loadeorsi,\n+    gen_aarch64_atomic_loadeordi\n+  };\n+  const aarch64_atomic_load_op_fn ior[] =\n+  {\n+    gen_aarch64_atomic_loadsetqi,\n+    gen_aarch64_atomic_loadsethi,\n+    gen_aarch64_atomic_loadsetsi,\n+    gen_aarch64_atomic_loadsetdi\n+  };\n+  const aarch64_atomic_load_op_fn bic[] =\n+  {\n+    gen_aarch64_atomic_loadclrqi,\n+    gen_aarch64_atomic_loadclrhi,\n+    gen_aarch64_atomic_loadclrsi,\n+    gen_aarch64_atomic_loadclrdi\n+  };\n+  aarch64_atomic_load_op_fn gen;\n+  int idx = 0;\n+\n+  switch (mode)\n+    {\n+    case QImode: idx = 0; break;\n+    case HImode: idx = 1; break;\n+    case SImode: idx = 2; break;\n+    case DImode: idx = 3; break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  switch (code)\n+    {\n+    case AARCH64_LDOP_PLUS: gen = plus[idx]; break;\n+    case AARCH64_LDOP_XOR: gen = eor[idx]; break;\n+    case AARCH64_LDOP_OR: gen = ior[idx]; break;\n+    case AARCH64_LDOP_BIC: gen = bic[idx]; break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  emit_insn (gen (dst, mem, src, model));\n+}\n+\n+/* Emit an atomic load+operate.  CODE is the operation.  OUT_DATA is the\n+   location to store the data read from memory.  MEM is the memory location to\n+   read and modify.  MODEL_RTX is the memory ordering to use.  VALUE is the\n+   second operand for the operation.  Either OUT_DATA or OUT_RESULT, but not\n+   both, can be NULL.  */\n \n void\n aarch64_gen_atomic_ldop (enum rtx_code code, rtx out_data,\n \t\t\t rtx mem, rtx value, rtx model_rtx)\n {\n   machine_mode mode = GET_MODE (mem);\n+  machine_mode wmode = (mode == DImode ? DImode : SImode);\n+  const bool short_mode = (mode < SImode);\n+  aarch64_atomic_load_op_code ldop_code;\n+  rtx src;\n+  rtx x;\n+\n+  if (out_data)\n+    out_data = gen_lowpart (mode, out_data);\n \n-  out_data = gen_lowpart (mode, out_data);\n+  /* Make sure the value is in a register, putting it into a destination\n+     register if it needs to be manipulated.  */\n+  if (!register_operand (value, mode)\n+      || code == AND || code == MINUS)\n+    {\n+      src = out_data;\n+      emit_move_insn (src, gen_lowpart (mode, value));\n+    }\n+  else\n+    src = value;\n+  gcc_assert (register_operand (src, mode));\n \n+  /* Preprocess the data for the operation as necessary.  If the operation is\n+     a SET then emit a swap instruction and finish.  */\n   switch (code)\n     {\n     case SET:\n-      aarch64_emit_atomic_swap (mode, out_data, value, mem, model_rtx);\n+      aarch64_emit_atomic_swap (mode, out_data, src, mem, model_rtx);\n       return;\n \n+    case MINUS:\n+      /* Negate the value and treat it as a PLUS.  */\n+      {\n+\trtx neg_src;\n+\n+\t/* Resize the value if necessary.  */\n+\tif (short_mode)\n+\t  src = gen_lowpart (wmode, src);\n+\n+\tneg_src = gen_rtx_NEG (wmode, src);\n+\temit_insn (gen_rtx_SET (src, neg_src));\n+\n+\tif (short_mode)\n+\t  src = gen_lowpart (mode, src);\n+      }\n+      /* Fall-through.  */\n+    case PLUS:\n+      ldop_code = AARCH64_LDOP_PLUS;\n+      break;\n+\n+    case IOR:\n+      ldop_code = AARCH64_LDOP_OR;\n+      break;\n+\n+    case XOR:\n+      ldop_code = AARCH64_LDOP_XOR;\n+      break;\n+\n+    case AND:\n+      {\n+\trtx not_src;\n+\n+\t/* Resize the value if necessary.  */\n+\tif (short_mode)\n+\t  src = gen_lowpart (wmode, src);\n+\n+\tnot_src = gen_rtx_NOT (wmode, src);\n+\temit_insn (gen_rtx_SET (src, not_src));\n+\n+\tif (short_mode)\n+\t  src = gen_lowpart (mode, src);\n+      }\n+      ldop_code = AARCH64_LDOP_BIC;\n+      break;\n+\n     default:\n       /* The operation can't be done with atomic instructions.  */\n       gcc_unreachable ();\n     }\n+\n+  aarch64_emit_atomic_load_op (ldop_code, mode, out_data, src, mem, model_rtx);\n }\n \n /* Split an atomic operation.  */"}, {"sha": "e0d885668f117e870763c8fa1583bbe5fb52e13d", "filename": "gcc/config/aarch64/atomics.md", "status": "modified", "additions": 92, "deletions": 9, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641c2f8b69f799a00d0fda696d480e10505257c3/gcc%2Fconfig%2Faarch64%2Fatomics.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641c2f8b69f799a00d0fda696d480e10505257c3/gcc%2Fconfig%2Faarch64%2Fatomics.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fatomics.md?ref=641c2f8b69f799a00d0fda696d480e10505257c3", "patch": "@@ -225,23 +225,63 @@\n   }\n )\n \n-(define_insn_and_split \"atomic_<atomic_optab><mode>\"\n+(define_expand \"atomic_<atomic_optab><mode>\"\n+ [(match_operand:ALLI 0 \"aarch64_sync_memory_operand\" \"\")\n+  (atomic_op:ALLI\n+   (match_operand:ALLI 1 \"<atomic_op_operand>\" \"\")\n+   (match_operand:SI 2 \"const_int_operand\"))]\n+  \"\"\n+  {\n+    rtx (*gen) (rtx, rtx, rtx);\n+\n+    /* Use an atomic load-operate instruction when possible.  */\n+    if (aarch64_atomic_ldop_supported_p (<CODE>))\n+      gen = gen_aarch64_atomic_<atomic_optab><mode>_lse;\n+    else\n+      gen = gen_aarch64_atomic_<atomic_optab><mode>;\n+\n+    emit_insn (gen (operands[0], operands[1], operands[2]));\n+\n+    DONE;\n+  }\n+)\n+\n+(define_insn_and_split \"aarch64_atomic_<atomic_optab><mode>\"\n+ [(set (match_operand:ALLI 0 \"aarch64_sync_memory_operand\" \"+Q\")\n+   (unspec_volatile:ALLI\n+    [(atomic_op:ALLI (match_dup 0)\n+      (match_operand:ALLI 1 \"<atomic_op_operand>\" \"r<const_atomic>\"))\n+     (match_operand:SI 2 \"const_int_operand\")]\n+    UNSPECV_ATOMIC_OP))\n+  (clobber (reg:CC CC_REGNUM))\n+  (clobber (match_scratch:ALLI 3 \"=&r\"))\n+  (clobber (match_scratch:SI 4 \"=&r\"))]\n+  \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  {\n+    aarch64_split_atomic_op (<CODE>, NULL, operands[3], operands[0],\n+\t\t\t     operands[1], operands[2], operands[4]);\n+    DONE;\n+  }\n+)\n+\n+(define_insn_and_split \"aarch64_atomic_<atomic_optab><mode>_lse\"\n   [(set (match_operand:ALLI 0 \"aarch64_sync_memory_operand\" \"+Q\")\n     (unspec_volatile:ALLI\n       [(atomic_op:ALLI (match_dup 0)\n \t(match_operand:ALLI 1 \"<atomic_op_operand>\" \"r<const_atomic>\"))\n-       (match_operand:SI 2 \"const_int_operand\")]\t\t;; model\n+       (match_operand:SI 2 \"const_int_operand\")]\n       UNSPECV_ATOMIC_OP))\n-       (clobber (reg:CC CC_REGNUM))\n-   (clobber (match_scratch:ALLI 3 \"=&r\"))\n-   (clobber (match_scratch:SI 4 \"=&r\"))]\n-  \"\"\n+   (clobber (match_scratch:ALLI 3 \"=&r\"))]\n+  \"TARGET_LSE\"\n   \"#\"\n   \"&& reload_completed\"\n   [(const_int 0)]\n   {\n-    aarch64_split_atomic_op (<CODE>, NULL, operands[3], operands[0],\n-\t\t\t     operands[1], operands[2], operands[4]);\n+    aarch64_gen_atomic_ldop (<CODE>, operands[3], operands[0],\n+\t\t\t     operands[1], operands[2]);\n     DONE;\n   }\n )\n@@ -268,7 +308,30 @@\n   }\n )\n \n-(define_insn_and_split \"atomic_fetch_<atomic_optab><mode>\"\n+;; Load-operate-store, returning the updated memory data.\n+\n+(define_expand \"atomic_fetch_<atomic_optab><mode>\"\n+ [(match_operand:ALLI 0 \"register_operand\" \"\")\n+  (match_operand:ALLI 1 \"aarch64_sync_memory_operand\" \"\")\n+  (atomic_op:ALLI\n+   (match_operand:ALLI 2 \"<atomic_op_operand>\" \"\")\n+   (match_operand:SI 3 \"const_int_operand\"))]\n+ \"\"\n+{\n+  rtx (*gen) (rtx, rtx, rtx, rtx);\n+\n+  /* Use an atomic load-operate instruction when possible.  */\n+  if (aarch64_atomic_ldop_supported_p (<CODE>))\n+    gen = gen_aarch64_atomic_fetch_<atomic_optab><mode>_lse;\n+  else\n+    gen = gen_aarch64_atomic_fetch_<atomic_optab><mode>;\n+\n+  emit_insn (gen (operands[0], operands[1], operands[2], operands[3]));\n+\n+  DONE;\n+})\n+\n+(define_insn_and_split \"aarch64_atomic_fetch_<atomic_optab><mode>\"\n   [(set (match_operand:ALLI 0 \"register_operand\" \"=&r\")\n     (match_operand:ALLI 1 \"aarch64_sync_memory_operand\" \"+Q\"))\n    (set (match_dup 1)\n@@ -291,6 +354,26 @@\n   }\n )\n \n+(define_insn_and_split \"aarch64_atomic_fetch_<atomic_optab><mode>_lse\"\n+  [(set (match_operand:ALLI 0 \"register_operand\" \"=&r\")\n+    (match_operand:ALLI 1 \"aarch64_sync_memory_operand\" \"+Q\"))\n+   (set (match_dup 1)\n+    (unspec_volatile:ALLI\n+      [(atomic_op:ALLI (match_dup 1)\n+\t(match_operand:ALLI 2 \"<atomic_op_operand>\" \"r<const_atomic>\"))\n+       (match_operand:SI 3 \"const_int_operand\")]\n+      UNSPECV_ATOMIC_LDOP))]\n+  \"TARGET_LSE\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  {\n+    aarch64_gen_atomic_ldop (<CODE>, operands[0], operands[1],\n+\t\t\t     operands[2], operands[3]);\n+    DONE;\n+  }\n+)\n+\n (define_insn_and_split \"atomic_fetch_nand<mode>\"\n   [(set (match_operand:ALLI 0 \"register_operand\" \"=&r\")\n     (match_operand:ALLI 1 \"aarch64_sync_memory_operand\" \"+Q\"))"}, {"sha": "4c5364a3900e7d84b1b9365c0c37d84949fb47a7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641c2f8b69f799a00d0fda696d480e10505257c3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641c2f8b69f799a00d0fda696d480e10505257c3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=641c2f8b69f799a00d0fda696d480e10505257c3", "patch": "@@ -1,3 +1,8 @@\n+2015-09-22  Matthew Wahab  <matthew.wahab@arm.com>\n+\n+\t* gcc.target/aarch64/atomic-inst-ldadd.c: New.\n+\t* gcc.target/aarch64/atomic-inst-ldlogic.c: New.\n+\n 2015-09-22  Matthew Wahab  <matthew.wahab@arm.com>\n \n \t* gcc.target/aarch64/atomic-inst-ops.inc: (TEST_MODEL): New."}, {"sha": "c21d2eda6c0b5b236e7db27c1496fa98365c5b8a", "filename": "gcc/testsuite/gcc.target/aarch64/atomic-inst-ldadd.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641c2f8b69f799a00d0fda696d480e10505257c3/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fatomic-inst-ldadd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641c2f8b69f799a00d0fda696d480e10505257c3/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fatomic-inst-ldadd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fatomic-inst-ldadd.c?ref=641c2f8b69f799a00d0fda696d480e10505257c3", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=armv8-a+lse\" } */\n+\n+/* Test ARMv8.1-A Load-ADD instruction.  */\n+\n+#include \"atomic-inst-ops.inc\"\n+\n+#define TEST TEST_ONE\n+\n+#define LOAD_ADD(FN, TY, MODEL)\t\t\t\t\t\t\\\n+  TY FNNAME (FN, TY) (TY* val, TY* foo)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    return __atomic_fetch_add (val, foo, MODEL);\t\t\t\\\n+  }\n+\n+#define LOAD_ADD_NORETURN(FN, TY, MODEL)\t\t\t\t\\\n+  void FNNAME (FN, TY) (TY* val, TY* foo)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    __atomic_fetch_add (val, foo, MODEL);\t\t\t\t\\\n+  }\n+\n+#define LOAD_SUB(FN, TY, MODEL)\t\t\t\t\t\t\\\n+  TY FNNAME (FN, TY) (TY* val, TY* foo)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    return __atomic_fetch_sub (val, foo, MODEL);\t\t\t\\\n+  }\n+\n+#define LOAD_SUB_NORETURN(FN, TY, MODEL)\t\t\t\t\\\n+  void FNNAME (FN, TY) (TY* val, TY* foo)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    __atomic_fetch_sub (val, foo, MODEL);\t\t\t\t\\\n+  }\n+\n+\n+TEST (load_add, LOAD_ADD)\n+TEST (load_add_notreturn, LOAD_ADD_NORETURN)\n+\n+TEST (load_sub, LOAD_SUB)\n+TEST (load_sub_notreturn, LOAD_SUB_NORETURN)\n+\n+/* { dg-final { scan-assembler-times \"ldaddb\\t\" 8} } */\n+/* { dg-final { scan-assembler-times \"ldaddab\\t\" 16} } */\n+/* { dg-final { scan-assembler-times \"ldaddlb\\t\" 8} } */\n+/* { dg-final { scan-assembler-times \"ldaddalb\\t\" 16} } */\n+\n+/* { dg-final { scan-assembler-times \"ldaddh\\t\" 8} } */\n+/* { dg-final { scan-assembler-times \"ldaddah\\t\" 16} } */\n+/* { dg-final { scan-assembler-times \"ldaddlh\\t\" 8} } */\n+/* { dg-final { scan-assembler-times \"ldaddalh\\t\" 16} } */\n+\n+/* { dg-final { scan-assembler-times \"ldadd\\t\" 16} } */\n+/* { dg-final { scan-assembler-times \"ldadda\\t\" 32} } */\n+/* { dg-final { scan-assembler-times \"ldaddl\\t\" 16} } */\n+/* { dg-final { scan-assembler-times \"ldaddal\\t\" 32} } */\n+\n+/* { dg-final { scan-assembler-not \"ldaxr\\t\" } } */\n+/* { dg-final { scan-assembler-not \"stlxr\\t\" } } */\n+/* { dg-final { scan-assembler-not \"dmb\" } } */"}, {"sha": "fd0f484cdabd4db0d9afa1b185a3c098e72fe4ca", "filename": "gcc/testsuite/gcc.target/aarch64/atomic-inst-ldlogic.c", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/641c2f8b69f799a00d0fda696d480e10505257c3/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fatomic-inst-ldlogic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/641c2f8b69f799a00d0fda696d480e10505257c3/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fatomic-inst-ldlogic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fatomic-inst-ldlogic.c?ref=641c2f8b69f799a00d0fda696d480e10505257c3", "patch": "@@ -0,0 +1,109 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=armv8-a+lse\" } */\n+\n+/* Test ARMv8.1-A LD<logic-op> instruction.  */\n+\n+#include \"atomic-inst-ops.inc\"\n+\n+#define TEST TEST_ONE\n+\n+#define LOAD_OR(FN, TY, MODEL)\t\t\t\t\t\t\\\n+  TY FNNAME (FN, TY) (TY* val, TY* foo)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    return __atomic_fetch_or (val, foo, MODEL);\t\t\t\t\\\n+  }\n+\n+#define LOAD_OR_NORETURN(FN, TY, MODEL)\t\t\t\t\t\\\n+  void FNNAME (FN, TY) (TY* val, TY* foo)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    __atomic_fetch_or (val, foo, MODEL);\t\t\t\t\\\n+  }\n+\n+#define LOAD_AND(FN, TY, MODEL)\t\t\t\t\t\t\\\n+  TY FNNAME (FN, TY) (TY* val, TY* foo)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    return __atomic_fetch_and (val, foo, MODEL);\t\t\t\\\n+  }\n+\n+#define LOAD_AND_NORETURN(FN, TY, MODEL)\t\t\t\t\\\n+  void FNNAME (FN, TY) (TY* val, TY* foo)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    __atomic_fetch_and (val, foo, MODEL);\t\t\t\t\\\n+  }\n+\n+#define LOAD_XOR(FN, TY, MODEL)\t\t\t\t\t\t\\\n+  TY FNNAME (FN, TY) (TY* val, TY* foo)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    return __atomic_fetch_xor (val, foo, MODEL);\t\t\t\\\n+  }\n+\n+#define LOAD_XOR_NORETURN(FN, TY, MODEL)\t\t\t\t\\\n+  void FNNAME (FN, TY) (TY* val, TY* foo)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    __atomic_fetch_xor (val, foo, MODEL);\t\t\t\t\\\n+  }\n+\n+\n+TEST (load_or, LOAD_OR)\n+TEST (load_or_notreturn, LOAD_OR_NORETURN)\n+\n+TEST (load_and, LOAD_AND)\n+TEST (load_and_notreturn, LOAD_AND_NORETURN)\n+\n+TEST (load_xor, LOAD_XOR)\n+TEST (load_xor_notreturn, LOAD_XOR_NORETURN)\n+\n+/* Load-OR.  */\n+\n+/* { dg-final { scan-assembler-times \"ldsetb\\t\" 4} } */\n+/* { dg-final { scan-assembler-times \"ldsetab\\t\" 8} } */\n+/* { dg-final { scan-assembler-times \"ldsetlb\\t\" 4} } */\n+/* { dg-final { scan-assembler-times \"ldsetalb\\t\" 8} } */\n+\n+/* { dg-final { scan-assembler-times \"ldseth\\t\" 4} } */\n+/* { dg-final { scan-assembler-times \"ldsetah\\t\" 8} } */\n+/* { dg-final { scan-assembler-times \"ldsetlh\\t\" 4} } */\n+/* { dg-final { scan-assembler-times \"ldsetalh\\t\" 8} } */\n+\n+/* { dg-final { scan-assembler-times \"ldset\\t\" 8} } */\n+/* { dg-final { scan-assembler-times \"ldseta\\t\" 16} } */\n+/* { dg-final { scan-assembler-times \"ldsetl\\t\" 8} } */\n+/* { dg-final { scan-assembler-times \"ldsetal\\t\" 16} } */\n+\n+/* Load-AND.  */\n+\n+/* { dg-final { scan-assembler-times \"ldclrb\\t\" 4} } */\n+/* { dg-final { scan-assembler-times \"ldclrab\\t\" 8} } */\n+/* { dg-final { scan-assembler-times \"ldclrlb\\t\" 4} } */\n+/* { dg-final { scan-assembler-times \"ldclralb\\t\" 8} } */\n+\n+/* { dg-final { scan-assembler-times \"ldclrh\\t\" 4} } */\n+/* { dg-final { scan-assembler-times \"ldclrah\\t\" 8} } */\n+/* { dg-final { scan-assembler-times \"ldclrlh\\t\" 4} } */\n+/* { dg-final { scan-assembler-times \"ldclralh\\t\" 8} } */\n+\n+/* { dg-final { scan-assembler-times \"ldclr\\t\" 8} */\n+/* { dg-final { scan-assembler-times \"ldclra\\t\" 16} } */\n+/* { dg-final { scan-assembler-times \"ldclrl\\t\" 8} } */\n+/* { dg-final { scan-assembler-times \"ldclral\\t\" 16} } */\n+\n+/* Load-XOR.  */\n+\n+/* { dg-final { scan-assembler-times \"ldeorb\\t\" 4} } */\n+/* { dg-final { scan-assembler-times \"ldeorab\\t\" 8} } */\n+/* { dg-final { scan-assembler-times \"ldeorlb\\t\" 4} } */\n+/* { dg-final { scan-assembler-times \"ldeoralb\\t\" 8} } */\n+\n+/* { dg-final { scan-assembler-times \"ldeorh\\t\" 4} } */\n+/* { dg-final { scan-assembler-times \"ldeorah\\t\" 8} } */\n+/* { dg-final { scan-assembler-times \"ldeorlh\\t\" 4} } */\n+/* { dg-final { scan-assembler-times \"ldeoralh\\t\" 8} } */\n+\n+/* { dg-final { scan-assembler-times \"ldeor\\t\" 8} */\n+/* { dg-final { scan-assembler-times \"ldeora\\t\" 16} } */\n+/* { dg-final { scan-assembler-times \"ldeorl\\t\" 8} } */\n+/* { dg-final { scan-assembler-times \"ldeoral\\t\" 16} } */\n+\n+/* { dg-final { scan-assembler-not \"ldaxr\\t\" } } */\n+/* { dg-final { scan-assembler-not \"stlxr\\t\" } } */\n+/* { dg-final { scan-assembler-not \"dmb\" } } */"}]}