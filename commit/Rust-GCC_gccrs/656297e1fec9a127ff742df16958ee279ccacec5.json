{"sha": "656297e1fec9a127ff742df16958ee279ccacec5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjU2Mjk3ZTFmZWM5YTEyN2ZmNzQyZGYxNjk1OGVlMjc5Y2NhY2VjNQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-09-12T23:22:53Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-09-12T23:22:53Z"}, "message": "libgo: update to Go1.13\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/194698\n\nFrom-SVN: r275691", "tree": {"sha": "24347a35dacea36ce742c32c17420f3e31f17e3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24347a35dacea36ce742c32c17420f3e31f17e3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/656297e1fec9a127ff742df16958ee279ccacec5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/656297e1fec9a127ff742df16958ee279ccacec5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/656297e1fec9a127ff742df16958ee279ccacec5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/656297e1fec9a127ff742df16958ee279ccacec5/comments", "author": null, "committer": null, "parents": [{"sha": "d6ecb707cc5a58816d27908a7aa324c4b0bc67bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6ecb707cc5a58816d27908a7aa324c4b0bc67bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6ecb707cc5a58816d27908a7aa324c4b0bc67bb"}], "stats": {"total": 5238, "additions": 3544, "deletions": 1694}, "files": [{"sha": "f950ecdb0e32505b05a96b0c8982f569573d93b4", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -1,4 +1,4 @@\n-0950e905939f88c1421f8667ac4dc9e14528471c\n+ceb1e4f5614b4772eed44f9cf57780e52f44753e\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "0be22963bb808acf31bc8e6036f07baa7b546740", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -1,4 +1,4 @@\n-60f14fddfee107dedd76c0be6b422a3d8ccc841a\n+cc8838d645b2b7026c1f3aaceb011775c5ca3a08\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "1192b4497819c6b814922741132c921cf5a330ab", "filename": "libgo/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -401,6 +401,7 @@ toolexeclibgounicode_DATA = \\\n # Force them to be built.\n noinst_DATA = \\\n \tgolang.org/x/net/nettest.gox \\\n+\tinternal/cfg.gox \\\n \tinternal/testenv.gox \\\n \tinternal/trace.gox \\\n \tnet/internal/socktest.gox \\"}, {"sha": "89cccaccdf9762b1b8d324d6fdefb1d303f64435", "filename": "libgo/Makefile.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -856,10 +856,10 @@ toolexeclibgounicode_DATA = \\\n # Some packages are only needed for tests, so unlike the other\n # internal packages nothing will explicitly depend on them.\n # Force them to be built.\n-noinst_DATA = golang.org/x/net/nettest.gox internal/testenv.gox \\\n-\tinternal/trace.gox net/internal/socktest.gox \\\n-\tos/signal/internal/pty.gox runtime/pprof/internal/profile.gox \\\n-\tzdefaultcc.go\n+noinst_DATA = golang.org/x/net/nettest.gox internal/cfg.gox \\\n+\tinternal/testenv.gox internal/trace.gox \\\n+\tnet/internal/socktest.gox os/signal/internal/pty.gox \\\n+\truntime/pprof/internal/profile.gox zdefaultcc.go\n @LIBGO_IS_RTEMS_FALSE@rtems_task_variable_add_file = \n @LIBGO_IS_RTEMS_TRUE@rtems_task_variable_add_file = runtime/rtems-task-variable-add.c\n runtime_files = \\"}, {"sha": "e0f726521a465416f368e95eb7bc9436e04ce382", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -1 +1 @@\n-go1.13beta1\n+go1.13"}, {"sha": "156a2bd4593243d6934d9a0d89b488da09652aec", "filename": "libgo/check-packages.txt", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fcheck-packages.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fcheck-packages.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fcheck-packages.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -106,7 +106,6 @@ image/png\n index/suffixarray\n internal/cpu\n internal/fmtsort\n-internal/oserror\n internal/poll\n internal/reflectlite\n internal/singleflight"}, {"sha": "526d4c2bddfb8e75f85da1161b32846915ab07d5", "filename": "libgo/go/cmd/cgo/gcc.go", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -811,10 +811,10 @@ func (p *Package) rewriteCall(f *File, call *Call) (string, bool) {\n \tparams := name.FuncType.Params\n \targs := call.Call.Args\n \n-\t// Avoid a crash if the number of arguments is\n-\t// less than the number of parameters.\n+\t// Avoid a crash if the number of arguments doesn't match\n+\t// the number of parameters.\n \t// This will be caught when the generated file is compiled.\n-\tif len(args) < len(params) {\n+\tif len(args) != len(params) {\n \t\treturn \"\", false\n \t}\n \n@@ -1257,6 +1257,8 @@ func (p *Package) isType(t ast.Expr) bool {\n \t\tif strings.HasPrefix(t.Name, \"_Ctype_\") {\n \t\t\treturn true\n \t\t}\n+\tcase *ast.ParenExpr:\n+\t\treturn p.isType(t.X)\n \tcase *ast.StarExpr:\n \t\treturn p.isType(t.X)\n \tcase *ast.ArrayType, *ast.StructType, *ast.FuncType, *ast.InterfaceType,"}, {"sha": "7282933e3c5be8da3d0d67cc1ed629546e6986ca", "filename": "libgo/go/cmd/cgo/out.go", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -273,6 +273,35 @@ func (p *Package) writeDefs() {\n \t}\n }\n \n+// elfImportedSymbols is like elf.File.ImportedSymbols, but it\n+// includes weak symbols.\n+//\n+// A bug in some versions of LLD (at least LLD 8) cause it to emit\n+// several pthreads symbols as weak, but we need to import those. See\n+// issue #31912 or https://bugs.llvm.org/show_bug.cgi?id=42442.\n+//\n+// When doing external linking, we hand everything off to the external\n+// linker, which will create its own dynamic symbol tables. For\n+// internal linking, this may turn weak imports into strong imports,\n+// which could cause dynamic linking to fail if a symbol really isn't\n+// defined. However, the standard library depends on everything it\n+// imports, and this is the primary use of dynamic symbol tables with\n+// internal linking.\n+func elfImportedSymbols(f *elf.File) []elf.ImportedSymbol {\n+\tsyms, _ := f.DynamicSymbols()\n+\tvar imports []elf.ImportedSymbol\n+\tfor _, s := range syms {\n+\t\tif (elf.ST_BIND(s.Info) == elf.STB_GLOBAL || elf.ST_BIND(s.Info) == elf.STB_WEAK) && s.Section == elf.SHN_UNDEF {\n+\t\t\timports = append(imports, elf.ImportedSymbol{\n+\t\t\t\tName:    s.Name,\n+\t\t\t\tLibrary: s.Library,\n+\t\t\t\tVersion: s.Version,\n+\t\t\t})\n+\t\t}\n+\t}\n+\treturn imports\n+}\n+\n func dynimport(obj string) {\n \tstdout := os.Stdout\n \tif *dynout != \"\" {\n@@ -295,7 +324,7 @@ func dynimport(obj string) {\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tsym, _ := f.ImportedSymbols()\n+\t\tsym := elfImportedSymbols(f)\n \t\tfor _, s := range sym {\n \t\t\ttarg := s.Name\n \t\t\tif s.Version != \"\" {"}, {"sha": "ebbead5d3169a53fe97df56cfaa096c0a7d31abd", "filename": "libgo/go/cmd/go/alldocs.go", "status": "modified", "additions": 53, "deletions": 22, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -78,6 +78,8 @@\n // If the arguments to build are a list of .go files from a single directory,\n // build treats them as a list of source files specifying a single package.\n //\n+// When compiling packages, build ignores files that end in '_test.go'.\n+//\n // When compiling a single main package, build writes\n // the resulting executable to an output file named after\n // the first source file ('go build ed.go rx.go' writes 'ed' or 'ed.exe')\n@@ -88,8 +90,6 @@\n // build compiles the packages but discards the resulting object,\n // serving only as a check that the packages can be built.\n //\n-// When compiling packages, build ignores files that end in '_test.go'.\n-//\n // The -o flag forces build to write the resulting executable or object\n // to the named output file or directory, instead of the default behavior described\n // in the last two paragraphs. If the named output is a directory that exists,\n@@ -566,17 +566,27 @@\n // The first step is to resolve which dependencies to add.\n //\n // For each named package or package pattern, get must decide which version of\n-// the corresponding module to use. By default, get chooses the latest tagged\n+// the corresponding module to use. By default, get looks up the latest tagged\n // release version, such as v0.4.5 or v1.2.3. If there are no tagged release\n-// versions, get chooses the latest tagged pre-release version, such as\n-// v0.0.1-pre1. If there are no tagged versions at all, get chooses the latest\n-// known commit.\n+// versions, get looks up the latest tagged pre-release version, such as\n+// v0.0.1-pre1. If there are no tagged versions at all, get looks up the latest\n+// known commit. If the module is not already required at a later version\n+// (for example, a pre-release newer than the latest release), get will use\n+// the version it looked up. Otherwise, get will use the currently\n+// required version.\n //\n // This default version selection can be overridden by adding an @version\n // suffix to the package argument, as in 'go get golang.org/x/text@v0.3.0'.\n+// The version may be a prefix: @v1 denotes the latest available version starting\n+// with v1. See 'go help modules' under the heading 'Module queries' for the\n+// full query syntax.\n+//\n // For modules stored in source control repositories, the version suffix can\n // also be a commit hash, branch identifier, or other syntax known to the\n-// source control system, as in 'go get golang.org/x/text@master'.\n+// source control system, as in 'go get golang.org/x/text@master'. Note that\n+// branches with names that overlap with other module query syntax cannot be\n+// selected explicitly. For example, the suffix @v2 means the latest version\n+// starting with v2, not the branch named v2.\n //\n // If a module under consideration is already a dependency of the current\n // development module, then get will update the required version.\n@@ -586,12 +596,14 @@\n // depending on it as needed.\n //\n // The version suffix @latest explicitly requests the latest minor release of the\n-// given path. The suffix @patch requests the latest patch release: if the path\n-// is already in the build list, the selected version will have the same minor\n-// version. If the path is not already in the build list, @patch is equivalent\n-// to @latest. Neither @latest nor @patch will cause 'go get' to downgrade a module\n-// in the build list if it is required at a newer pre-release version that is\n-// newer than the latest released version.\n+// module named by the given path. The suffix @upgrade is like @latest but\n+// will not downgrade a module if it is already required at a revision or\n+// pre-release version newer than the latest released version. The suffix\n+// @patch requests the latest patch release: the latest released version\n+// with the same major and minor version numbers as the currently required\n+// version. Like @upgrade, @patch will not downgrade a module already required\n+// at a newer version. If the path is not already required, @upgrade and @patch\n+// are equivalent to @latest.\n //\n // Although get defaults to using the latest version of the module containing\n // a named package, it does not use the latest version of that module's\n@@ -1006,6 +1018,7 @@\n //         Dir      string // absolute path to cached source root directory\n //         Sum      string // checksum for path, version (as in go.sum)\n //         GoModSum string // checksum for go.mod (as in go.sum)\n+//         Latest   bool   // would @latest resolve to this version?\n //     }\n //\n // See 'go help modules' for more about module queries.\n@@ -1562,6 +1575,9 @@\n // \tGOCACHE\n // \t\tThe directory where the go command will store cached\n // \t\tinformation for reuse in future builds.\n+// \tGODEBUG\n+// \t\tEnable various debugging facilities. See 'go doc runtime'\n+// \t\tfor details.\n // \tGOENV\n // \t\tThe location of the Go environment configuration file.\n // \t\tCannot be set using 'go env -w'.\n@@ -2496,12 +2512,25 @@\n // The string \"latest\" matches the latest available tagged version,\n // or else the underlying source repository's latest untagged revision.\n //\n-// A revision identifier for the underlying source repository,\n-// such as a commit hash prefix, revision tag, or branch name,\n-// selects that specific code revision. If the revision is\n-// also tagged with a semantic version, the query evaluates to\n-// that semantic version. Otherwise the query evaluates to a\n-// pseudo-version for the commit.\n+// The string \"upgrade\" is like \"latest\", but if the module is\n+// currently required at a later version than the version \"latest\"\n+// would select (for example, a newer pre-release version), \"upgrade\"\n+// will select the later version instead.\n+//\n+// The string \"patch\" matches the latest available tagged version\n+// of a module with the same major and minor version numbers as the\n+// currently required version. If no version is currently required,\n+// \"patch\" is equivalent to \"latest\".\n+//\n+// A revision identifier for the underlying source repository, such as\n+// a commit hash prefix, revision tag, or branch name, selects that\n+// specific code revision. If the revision is also tagged with a\n+// semantic version, the query evaluates to that semantic version.\n+// Otherwise the query evaluates to a pseudo-version for the commit.\n+// Note that branches and tags with names that are matched by other\n+// query syntax cannot be selected this way. For example, the query\n+// \"v2\" means the latest version starting with \"v2\", not the branch\n+// named \"v2\".\n //\n // All queries prefer release versions to pre-release versions.\n // For example, \"<v1.2.3\" will prefer to return \"v1.2.2\"\n@@ -2714,9 +2743,11 @@\n // \tGOSUMDB=\"sum.golang.org+<publickey>\"\n // \tGOSUMDB=\"sum.golang.org+<publickey> https://sum.golang.org\"\n //\n-// The go command knows the public key of sum.golang.org; use of any other\n-// database requires giving the public key explicitly. The URL defaults to\n-// \"https://\" followed by the database name.\n+// The go command knows the public key of sum.golang.org, and also that the name\n+// sum.golang.google.cn (available inside mainland China) connects to the\n+// sum.golang.org checksum database; use of any other database requires giving\n+// the public key explicitly.\n+// The URL defaults to \"https://\" followed by the database name.\n //\n // GOSUMDB defaults to \"sum.golang.org\", the Go checksum database run by Google.\n // See https://sum.golang.org/privacy for the service's privacy policy."}, {"sha": "f936d703c078a8ce2929252b910159c78e4f78b9", "filename": "libgo/go/cmd/go/go_test.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -3177,6 +3177,12 @@ func TestGoTestFooTestWorks(t *testing.T) {\n \ttg.run(\"test\", \"testdata/standalone_test.go\")\n }\n \n+func TestGoTestTestMainSeesTestingFlags(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.run(\"test\", \"testdata/standalone_testmain_flag_test.go\")\n+}\n+\n // Issue 22388\n func TestGoTestMainWithWrongSignature(t *testing.T) {\n \ttg := testgo(t)"}, {"sha": "a05a08f75fcc3f0627f6a3357b929a30700a13f4", "filename": "libgo/go/cmd/go/internal/cache/cache.go", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -173,7 +173,7 @@ func (c *Cache) get(id ActionID) (Entry, error) {\n \t\ti++\n \t}\n \ttm, err := strconv.ParseInt(string(etime[i:]), 10, 64)\n-\tif err != nil || size < 0 {\n+\tif err != nil || tm < 0 {\n \t\treturn missing()\n \t}\n \n@@ -322,7 +322,7 @@ func (c *Cache) putIndexEntry(id ActionID, out OutputID, size int64, allowVerify\n \t// in verify mode we are double-checking that the cache entries\n \t// are entirely reproducible. As just noted, this may be unrealistic\n \t// in some cases but the check is also useful for shaking out real bugs.\n-\tentry := []byte(fmt.Sprintf(\"v1 %x %x %20d %20d\\n\", id, out, size, time.Now().UnixNano()))\n+\tentry := fmt.Sprintf(\"v1 %x %x %20d %20d\\n\", id, out, size, time.Now().UnixNano())\n \tif verify && allowVerify {\n \t\told, err := c.get(id)\n \t\tif err == nil && (old.OutputID != out || old.Size != size) {\n@@ -332,7 +332,28 @@ func (c *Cache) putIndexEntry(id ActionID, out OutputID, size int64, allowVerify\n \t\t}\n \t}\n \tfile := c.fileName(id, \"a\")\n-\tif err := ioutil.WriteFile(file, entry, 0666); err != nil {\n+\n+\t// Copy file to cache directory.\n+\tmode := os.O_WRONLY | os.O_CREATE\n+\tf, err := os.OpenFile(file, mode, 0666)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\t_, err = f.WriteString(entry)\n+\tif err == nil {\n+\t\t// Truncate the file only *after* writing it.\n+\t\t// (This should be a no-op, but truncate just in case of previous corruption.)\n+\t\t//\n+\t\t// This differs from ioutil.WriteFile, which truncates to 0 *before* writing\n+\t\t// via os.O_TRUNC. Truncating only after writing ensures that a second write\n+\t\t// of the same content to the same file is idempotent, and does not \u2014 even\n+\t\t// temporarily! \u2014 undo the effect of the first write.\n+\t\terr = f.Truncate(int64(len(entry)))\n+\t}\n+\tif closeErr := f.Close(); err == nil {\n+\t\terr = closeErr\n+\t}\n+\tif err != nil {\n \t\t// TODO(bcmills): This Remove potentially races with another go command writing to file.\n \t\t// Can we eliminate it?\n \t\tos.Remove(file)"}, {"sha": "a3277a6c3f0ac12019ba8139d0ce89f4e3994547", "filename": "libgo/go/cmd/go/internal/cfg/cfg.go", "status": "modified", "additions": 2, "deletions": 53, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -10,6 +10,7 @@ import (\n \t\"bytes\"\n \t\"fmt\"\n \t\"go/build\"\n+\t\"internal/cfg\"\n \t\"io/ioutil\"\n \t\"os\"\n \t\"path/filepath\"\n@@ -221,61 +222,9 @@ func Getenv(key string) string {\n \n // CanGetenv reports whether key is a valid go/env configuration key.\n func CanGetenv(key string) bool {\n-\treturn strings.Contains(knownEnv, \"\\t\"+key+\"\\n\")\n+\treturn strings.Contains(cfg.KnownEnv, \"\\t\"+key+\"\\n\")\n }\n \n-var knownEnv = `\n-\tAR\n-\tCC\n-\tCGO_CFLAGS\n-\tCGO_CFLAGS_ALLOW\n-\tCGO_CFLAGS_DISALLOW\n-\tCGO_CPPFLAGS\n-\tCGO_CPPFLAGS_ALLOW\n-\tCGO_CPPFLAGS_DISALLOW\n-\tCGO_CXXFLAGS\n-\tCGO_CXXFLAGS_ALLOW\n-\tCGO_CXXFLAGS_DISALLOW\n-\tCGO_ENABLED\n-\tCGO_FFLAGS\n-\tCGO_FFLAGS_ALLOW\n-\tCGO_FFLAGS_DISALLOW\n-\tCGO_LDFLAGS\n-\tCGO_LDFLAGS_ALLOW\n-\tCGO_LDFLAGS_DISALLOW\n-\tCXX\n-\tFC\n-\tGCCGO\n-\tGO111MODULE\n-\tGO386\n-\tGOARCH\n-\tGOARM\n-\tGOBIN\n-\tGOCACHE\n-\tGOENV\n-\tGOEXE\n-\tGOFLAGS\n-\tGOGCCFLAGS\n-\tGOHOSTARCH\n-\tGOHOSTOS\n-\tGOMIPS\n-\tGOMIPS64\n-\tGONOPROXY\n-\tGONOSUMDB\n-\tGOOS\n-\tGOPATH\n-\tGOPPC64\n-\tGOPRIVATE\n-\tGOPROXY\n-\tGOROOT\n-\tGOSUMDB\n-\tGOTMPDIR\n-\tGOTOOLDIR\n-\tGOWASM\n-\tGO_EXTLINK_ENABLED\n-\tPKG_CONFIG\n-`\n-\n var (\n \tGOROOT       = BuildContext.GOROOT\n \tGOBIN        = Getenv(\"GOBIN\")"}, {"sha": "705bb66dbe2142ce95d9608cc3281478a66f557e", "filename": "libgo/go/cmd/go/internal/get/vcs.go", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -164,8 +164,14 @@ var vcsGit = &vcsCmd{\n \t// See golang.org/issue/9032.\n \ttagSyncDefault: []string{\"submodule update --init --recursive\"},\n \n-\tscheme:     []string{\"git\", \"https\", \"http\", \"git+ssh\", \"ssh\"},\n-\tpingCmd:    \"ls-remote -- {scheme}://{repo}\",\n+\tscheme: []string{\"git\", \"https\", \"http\", \"git+ssh\", \"ssh\"},\n+\n+\t// Leave out the '--' separator in the ls-remote command: git 2.7.4 does not\n+\t// support such a separator for that command, and this use should be safe\n+\t// without it because the {scheme} value comes from the predefined list above.\n+\t// See golang.org/issue/33836.\n+\tpingCmd: \"ls-remote {scheme}://{repo}\",\n+\n \tremoteRepo: gitRemoteRepo,\n }\n "}, {"sha": "edb4a2a23caa838d4320dbc2ddf541776ca2cc5b", "filename": "libgo/go/cmd/go/internal/help/help.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelp.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -63,7 +63,7 @@ Args:\n \t\t// helpSuccess is the help command using as many args as possible that would succeed.\n \t\thelpSuccess := \"go help\"\n \t\tif i > 0 {\n-\t\t\thelpSuccess = \" \" + strings.Join(args[:i], \" \")\n+\t\t\thelpSuccess += \" \" + strings.Join(args[:i], \" \")\n \t\t}\n \t\tfmt.Fprintf(os.Stderr, \"go help %s: unknown help topic. Run '%s'.\\n\", strings.Join(args, \" \"), helpSuccess)\n \t\tbase.SetExitStatus(2) // failed at 'go help cmd'"}, {"sha": "dfb89d4910bf7c8dc3ee2eff9bd6e1705c627f32", "filename": "libgo/go/cmd/go/internal/help/helpdoc.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -493,6 +493,9 @@ General-purpose environment variables:\n \tGOCACHE\n \t\tThe directory where the go command will store cached\n \t\tinformation for reuse in future builds.\n+\tGODEBUG\n+\t\tEnable various debugging facilities. See 'go doc runtime'\n+\t\tfor details.\n \tGOENV\n \t\tThe location of the Go environment configuration file.\n \t\tCannot be set using 'go env -w'."}, {"sha": "a5f1abe64ae643a25918c6ba783069e7fd803e53", "filename": "libgo/go/cmd/go/internal/list/list.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -390,7 +390,7 @@ func runList(cmd *base.Command, args []string) {\n \t\tif !*listE {\n \t\t\tfor _, m := range mods {\n \t\t\t\tif m.Error != nil {\n-\t\t\t\t\tbase.Errorf(\"go list -m %s: %v\", m.Path, m.Error.Err)\n+\t\t\t\t\tbase.Errorf(\"go list -m: %v\", m.Error.Err)\n \t\t\t\t}\n \t\t\t}\n \t\t\tbase.ExitIfErrors()\n@@ -459,7 +459,7 @@ func runList(cmd *base.Command, args []string) {\n \t\t\t\t}\n \t\t\t\tif pmain != nil {\n \t\t\t\t\tpkgs = append(pkgs, pmain)\n-\t\t\t\t\tdata := pmain.Internal.TestmainGo\n+\t\t\t\t\tdata := *pmain.Internal.TestmainGo\n \t\t\t\t\th := cache.NewHash(\"testmain\")\n \t\t\t\t\th.Write([]byte(\"testmain\\n\"))\n \t\t\t\t\th.Write(data)"}, {"sha": "a50450ee0546653aa7e9f872b1c66595ee349ca7", "filename": "libgo/go/cmd/go/internal/load/pkg.go", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -64,7 +64,7 @@ type PackagePublic struct {\n \tDoc           string                `json:\",omitempty\"` // package documentation string\n \tTarget        string                `json:\",omitempty\"` // installed target for this package (may be executable)\n \tShlib         string                `json:\",omitempty\"` // the shared library that contains this package (only set when -linkshared)\n-\tRoot          string                `json:\",omitempty\"` // Go root or Go path dir containing this package\n+\tRoot          string                `json:\",omitempty\"` // Go root, Go path dir, or module root dir containing this package\n \tConflictDir   string                `json:\",omitempty\"` // Dir is hidden by this other directory\n \tForTest       string                `json:\",omitempty\"` // package is only for use in named test\n \tExport        string                `json:\",omitempty\"` // file containing export data (set by go list -export)\n@@ -177,8 +177,7 @@ type PackageInternal struct {\n \tOmitDebug         bool                 // tell linker not to write debug information\n \tGobinSubdir       bool                 // install target would be subdir of GOBIN\n \tBuildInfo         string               // add this info to package main\n-\tTestinginitGo     []byte               // content for _testinginit.go\n-\tTestmainGo        []byte               // content for _testmain.go\n+\tTestmainGo        *[]byte              // content for _testmain.go\n \n \tAsmflags   []string // -asmflags for this package\n \tGcflags    []string // -gcflags for this package\n@@ -647,9 +646,14 @@ func loadPackageData(path, parentPath, parentDir, parentRoot string, parentIsStd\n \t\t\t\tbuildMode = build.ImportComment\n \t\t\t}\n \t\t\tdata.p, data.err = cfg.BuildContext.ImportDir(r.dir, buildMode)\n+\t\t\tif data.p.Root == \"\" && cfg.ModulesEnabled {\n+\t\t\t\tif info := ModPackageModuleInfo(path); info != nil {\n+\t\t\t\t\tdata.p.Root = info.Dir\n+\t\t\t\t}\n+\t\t\t}\n \t\t} else if r.err != nil {\n \t\t\tdata.p = new(build.Package)\n-\t\t\tdata.err = fmt.Errorf(\"unknown import path %q: %v\", r.path, r.err)\n+\t\t\tdata.err = r.err\n \t\t} else if cfg.ModulesEnabled && path != \"unsafe\" {\n \t\t\tdata.p = new(build.Package)\n \t\t\tdata.err = fmt.Errorf(\"unknown import path %q: internal error: module loader did not resolve import\", r.path)"}, {"sha": "afff5deaaa905c616308f909f010493fce280675", "filename": "libgo/go/cmd/go/internal/load/test.go", "status": "modified", "additions": 3, "deletions": 40, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -102,7 +102,6 @@ func TestPackagesAndErrors(p *Package, cover *TestCover) (pmain, ptest, pxtest *\n \tvar stk ImportStack\n \tstk.Push(p.ImportPath + \" (test)\")\n \trawTestImports := str.StringList(p.TestImports)\n-\tvar ptestImportsTesting, pxtestImportsTesting bool\n \tfor i, path := range p.TestImports {\n \t\tp1 := loadImport(pre, path, p.Dir, p, &stk, p.Internal.Build.TestImportPos[path], ResolveImport)\n \t\tif str.Contains(p1.Deps, p.ImportPath) || p1.ImportPath == p.ImportPath {\n@@ -117,9 +116,6 @@ func TestPackagesAndErrors(p *Package, cover *TestCover) (pmain, ptest, pxtest *\n \t\t}\n \t\tp.TestImports[i] = p1.ImportPath\n \t\timports = append(imports, p1)\n-\t\tif path == \"testing\" {\n-\t\t\tptestImportsTesting = true\n-\t\t}\n \t}\n \tstk.Pop()\n \tstk.Push(p.ImportPath + \"_test\")\n@@ -133,9 +129,6 @@ func TestPackagesAndErrors(p *Package, cover *TestCover) (pmain, ptest, pxtest *\n \t\t\tximports = append(ximports, p1)\n \t\t}\n \t\tp.XTestImports[i] = p1.ImportPath\n-\t\tif path == \"testing\" {\n-\t\t\tpxtestImportsTesting = true\n-\t\t}\n \t}\n \tstk.Pop()\n \n@@ -145,9 +138,6 @@ func TestPackagesAndErrors(p *Package, cover *TestCover) (pmain, ptest, pxtest *\n \t\t*ptest = *p\n \t\tptest.Error = ptestErr\n \t\tptest.ForTest = p.ImportPath\n-\t\tif ptestImportsTesting {\n-\t\t\tptest.Internal.TestinginitGo = formatTestinginit(p)\n-\t\t}\n \t\tptest.GoFiles = nil\n \t\tptest.GoFiles = append(ptest.GoFiles, p.GoFiles...)\n \t\tptest.GoFiles = append(ptest.GoFiles, p.TestGoFiles...)\n@@ -212,9 +202,6 @@ func TestPackagesAndErrors(p *Package, cover *TestCover) (pmain, ptest, pxtest *\n \t\t\t\tGccgoflags: p.Internal.Gccgoflags,\n \t\t\t},\n \t\t}\n-\t\tif pxtestImportsTesting {\n-\t\t\tpxtest.Internal.TestinginitGo = formatTestinginit(pxtest)\n-\t\t}\n \t\tif pxtestNeedsPtest {\n \t\t\tpxtest.Internal.Imports = append(pxtest.Internal.Imports, ptest)\n \t\t}\n@@ -337,7 +324,9 @@ func TestPackagesAndErrors(p *Package, cover *TestCover) (pmain, ptest, pxtest *\n \tif err != nil && pmain.Error == nil {\n \t\tpmain.Error = &PackageError{Err: err.Error()}\n \t}\n-\tpmain.Internal.TestmainGo = data\n+\tif data != nil {\n+\t\tpmain.Internal.TestmainGo = &data\n+\t}\n \n \treturn pmain, ptest, pxtest\n }\n@@ -485,15 +474,6 @@ func loadTestFuncs(ptest *Package) (*testFuncs, error) {\n \treturn t, err\n }\n \n-// formatTestinginit returns the content of the _testinginit.go file for p.\n-func formatTestinginit(p *Package) []byte {\n-\tvar buf bytes.Buffer\n-\tif err := testinginitTmpl.Execute(&buf, p); err != nil {\n-\t\tpanic(\"testinginit template execution failed\") // shouldn't be possible\n-\t}\n-\treturn buf.Bytes()\n-}\n-\n // formatTestmain returns the content of the _testmain.go file for t.\n func formatTestmain(t *testFuncs) ([]byte, error) {\n \tvar buf bytes.Buffer\n@@ -623,23 +603,6 @@ func checkTestFunc(fn *ast.FuncDecl, arg string) error {\n \treturn nil\n }\n \n-var testinginitTmpl = lazytemplate.New(\"init\", `\n-package {{.Name}}\n-\n-import _go_testing \"testing\"\n-\n-{{/*\n-Call testing.Init before any other user initialization code runs.\n-(This file is passed to the compiler first.)\n-This provides the illusion of the old behavior where testing flags\n-were registered as part of the testing package's initialization.\n-*/}}\n-var _ = func() bool {\n-\t_go_testing.Init()\n-\treturn true\n-}()\n-`)\n-\n var testmainTmpl = lazytemplate.New(\"main\", `\n // Code generated by 'go test'. DO NOT EDIT.\n "}, {"sha": "60d0d5b6e2b4fb362d2b62b829ba9a18353bfed8", "filename": "libgo/go/cmd/go/internal/modcmd/download.go", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -43,6 +43,7 @@ corresponding to this Go struct:\n         Dir      string // absolute path to cached source root directory\n         Sum      string // checksum for path, version (as in go.sum)\n         GoModSum string // checksum for go.mod (as in go.sum)\n+        Latest   bool   // would @latest resolve to this version?\n     }\n \n See 'go help modules' for more about module queries.\n@@ -65,6 +66,7 @@ type moduleJSON struct {\n \tDir      string `json:\",omitempty\"`\n \tSum      string `json:\",omitempty\"`\n \tGoModSum string `json:\",omitempty\"`\n+\tLatest   bool   `json:\",omitempty\"`\n }\n \n func runDownload(cmd *base.Command, args []string) {\n@@ -87,17 +89,47 @@ func runDownload(cmd *base.Command, args []string) {\n \t\tif info.Replace != nil {\n \t\t\tinfo = info.Replace\n \t\t}\n-\t\tif info.Version == \"\" {\n+\t\tif info.Version == \"\" && info.Error == nil {\n+\t\t\t// main module\n \t\t\tcontinue\n \t\t}\n \t\tm := &moduleJSON{\n \t\t\tPath:    info.Path,\n \t\t\tVersion: info.Version,\n \t\t}\n \t\tmods = append(mods, m)\n+\t\tif info.Error != nil {\n+\t\t\tm.Error = info.Error.Err\n+\t\t\tcontinue\n+\t\t}\n \t\twork.Add(m)\n \t}\n \n+\tlatest := map[string]string{} // path \u2192 version\n+\tif *downloadJSON {\n+\t\t// We need to populate the Latest field, but if the main module depends on a\n+\t\t// version newer than latest \u2014 or if the version requested on the command\n+\t\t// line is itself newer than latest \u2014 that's not trivial to determine from\n+\t\t// the info returned by ListModules. Instead, we issue a separate\n+\t\t// ListModules request for \"latest\", which should be inexpensive relative to\n+\t\t// downloading the modules.\n+\t\tvar latestArgs []string\n+\t\tfor _, m := range mods {\n+\t\t\tif m.Error != \"\" {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tlatestArgs = append(latestArgs, m.Path+\"@latest\")\n+\t\t}\n+\n+\t\tif len(latestArgs) > 0 {\n+\t\t\tfor _, info := range modload.ListModules(latestArgs, listU, listVersions) {\n+\t\t\t\tif info.Version != \"\" {\n+\t\t\t\t\tlatest[info.Path] = info.Version\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \twork.Do(10, func(item interface{}) {\n \t\tm := item.(*moduleJSON)\n \t\tvar err error\n@@ -128,6 +160,9 @@ func runDownload(cmd *base.Command, args []string) {\n \t\t\tm.Error = err.Error()\n \t\t\treturn\n \t\t}\n+\t\tif latest[m.Path] == m.Version {\n+\t\t\tm.Latest = true\n+\t\t}\n \t})\n \n \tif *downloadJSON {\n@@ -144,7 +179,7 @@ func runDownload(cmd *base.Command, args []string) {\n \t} else {\n \t\tfor _, m := range mods {\n \t\t\tif m.Error != \"\" {\n-\t\t\t\tbase.Errorf(\"%s@%s: %s\\n\", m.Path, m.Version, m.Error)\n+\t\t\t\tbase.Errorf(\"%s\", m.Error)\n \t\t\t}\n \t\t}\n \t\tbase.ExitIfErrors()"}, {"sha": "48238f176c6dae63b0f09c1d76e966df2c9feee2", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/vcs.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fvcs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fvcs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fvcs.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -341,7 +341,9 @@ func (r *vcsRepo) Stat(rev string) (*RevInfo, error) {\n }\n \n func (r *vcsRepo) fetch() {\n-\t_, r.fetchErr = Run(r.dir, r.cmd.fetch)\n+\tif len(r.cmd.fetch) > 0 {\n+\t\t_, r.fetchErr = Run(r.dir, r.cmd.fetch)\n+\t}\n }\n \n func (r *vcsRepo) statLocal(rev string) (*RevInfo, error) {"}, {"sha": "f15ce67d46012a1b434f5006528083762731d83e", "filename": "libgo/go/cmd/go/internal/modfetch/coderepo.go", "status": "modified", "additions": 55, "deletions": 20, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -31,7 +31,7 @@ type codeRepo struct {\n \tcodeRoot string\n \t// codeDir is the directory (relative to root) at which we expect to find the module.\n \t// If pathMajor is non-empty and codeRoot is not the full modPath,\n-\t// then we look in both codeDir and codeDir+modPath\n+\t// then we look in both codeDir and codeDir/pathMajor[1:].\n \tcodeDir string\n \n \t// pathMajor is the suffix of modPath that indicates its major version,\n@@ -192,7 +192,13 @@ func (r *codeRepo) Stat(rev string) (*RevInfo, error) {\n \tcodeRev := r.revToRev(rev)\n \tinfo, err := r.code.Stat(codeRev)\n \tif err != nil {\n-\t\treturn nil, err\n+\t\treturn nil, &module.ModuleError{\n+\t\t\tPath: r.modPath,\n+\t\t\tErr: &module.InvalidVersionError{\n+\t\t\t\tVersion: rev,\n+\t\t\t\tErr:     err,\n+\t\t\t},\n+\t\t}\n \t}\n \treturn r.convert(info, rev)\n }\n@@ -248,20 +254,25 @@ func (r *codeRepo) convert(info *codehost.RevInfo, statVers string) (*RevInfo, e\n \t// exist as required by info2.Version and the module path represented by r.\n \tcheckGoMod := func() (*RevInfo, error) {\n \t\t// If r.codeDir is non-empty, then the go.mod file must exist: the module\n-\t\t// author, not the module consumer, gets to decide how to carve up the repo\n+\t\t// author \u2014 not the module consumer, \u2014 gets to decide how to carve up the repo\n \t\t// into modules.\n-\t\tif r.codeDir != \"\" {\n-\t\t\t_, _, _, err := r.findDir(info2.Version)\n-\t\t\tif err != nil {\n-\t\t\t\t// TODO: It would be nice to return an error like \"not a module\".\n-\t\t\t\t// Right now we return \"missing go.mod\", which is a little confusing.\n-\t\t\t\treturn nil, &module.ModuleError{\n-\t\t\t\t\tPath: r.modPath,\n-\t\t\t\t\tErr: &module.InvalidVersionError{\n-\t\t\t\t\t\tVersion: info2.Version,\n-\t\t\t\t\t\tErr:     notExistError(err.Error()),\n-\t\t\t\t\t},\n-\t\t\t\t}\n+\t\t//\n+\t\t// Conversely, if the go.mod file exists, the module author \u2014 not the module\n+\t\t// consumer \u2014 gets to determine the module's path\n+\t\t//\n+\t\t// r.findDir verifies both of these conditions. Execute it now so that\n+\t\t// r.Stat will correctly return a notExistError if the go.mod location or\n+\t\t// declared module path doesn't match.\n+\t\t_, _, _, err := r.findDir(info2.Version)\n+\t\tif err != nil {\n+\t\t\t// TODO: It would be nice to return an error like \"not a module\".\n+\t\t\t// Right now we return \"missing go.mod\", which is a little confusing.\n+\t\t\treturn nil, &module.ModuleError{\n+\t\t\t\tPath: r.modPath,\n+\t\t\t\tErr: &module.InvalidVersionError{\n+\t\t\t\t\tVersion: info2.Version,\n+\t\t\t\t\tErr:     notExistError(err.Error()),\n+\t\t\t\t},\n \t\t\t}\n \t\t}\n \n@@ -474,6 +485,11 @@ func (r *codeRepo) validatePseudoVersion(info *codehost.RevInfo, version string)\n \t\treturn fmt.Errorf(\"does not match version-control timestamp (%s)\", info.Time.UTC().Format(time.RFC3339))\n \t}\n \n+\ttagPrefix := \"\"\n+\tif r.codeDir != \"\" {\n+\t\ttagPrefix = r.codeDir + \"/\"\n+\t}\n+\n \t// A pseudo-version should have a precedence just above its parent revisions,\n \t// and no higher. Otherwise, it would be possible for library authors to \"pin\"\n \t// dependency versions (and bypass the usual minimum version selection) by\n@@ -499,11 +515,26 @@ func (r *codeRepo) validatePseudoVersion(info *codehost.RevInfo, version string)\n \t\t\treturn fmt.Errorf(\"major version without preceding tag must be v0, not v1\")\n \t\t}\n \t\treturn nil\n-\t}\n-\n-\ttagPrefix := \"\"\n-\tif r.codeDir != \"\" {\n-\t\ttagPrefix = r.codeDir + \"/\"\n+\t} else {\n+\t\tfor _, tag := range info.Tags {\n+\t\t\tversionOnly := strings.TrimPrefix(tag, tagPrefix)\n+\t\t\tif versionOnly == base {\n+\t\t\t\t// The base version is canonical, so if the version from the tag is\n+\t\t\t\t// literally equal (not just equivalent), then the tag is canonical too.\n+\t\t\t\t//\n+\t\t\t\t// We allow pseudo-versions to be derived from non-canonical tags on the\n+\t\t\t\t// same commit, so that tags like \"v1.1.0+some-metadata\" resolve as\n+\t\t\t\t// close as possible to the canonical version (\"v1.1.0\") while still\n+\t\t\t\t// enforcing a total ordering (\"v1.1.1-0.[\u2026]\" with a unique suffix).\n+\t\t\t\t//\n+\t\t\t\t// However, canonical tags already have a total ordering, so there is no\n+\t\t\t\t// reason not to use the canonical tag directly, and we know that the\n+\t\t\t\t// canonical tag must already exist because the pseudo-version is\n+\t\t\t\t// derived from it. In that case, referring to the revision by a\n+\t\t\t\t// pseudo-version derived from its own canonical tag is just confusing.\n+\t\t\t\treturn fmt.Errorf(\"tag (%s) found on revision %s is already canonical, so should not be replaced with a pseudo-version derived from that tag\", tag, rev)\n+\t\t\t}\n+\t\t}\n \t}\n \n \ttags, err := r.code.Tags(tagPrefix + base)\n@@ -571,6 +602,10 @@ func (r *codeRepo) versionToRev(version string) (rev string, err error) {\n \treturn r.revToRev(version), nil\n }\n \n+// findDir locates the directory within the repo containing the module.\n+//\n+// If r.pathMajor is non-empty, this can be either r.codeDir or \u2014 if a go.mod\n+// file exists \u2014 r.codeDir/r.pathMajor[1:].\n func (r *codeRepo) findDir(version string) (rev, dir string, gomod []byte, err error) {\n \trev, err = r.versionToRev(version)\n \tif err != nil {"}, {"sha": "1f2b95bd2384efe6008000c0925c8e28bed4d1ba", "filename": "libgo/go/cmd/go/internal/modfetch/coderepo_test.go", "status": "modified", "additions": 66, "deletions": 31, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -83,6 +83,26 @@ var codeRepoTests = []codeRepoTest{\n \t\t\t\"pkg/p.go\",\n \t\t},\n \t},\n+\t{\n+\t\tvcs:     \"git\",\n+\t\tpath:    \"github.com/rsc/vgotest1\",\n+\t\trev:     \"v0.0.0-20180219231006-80d85c5d4d17\",\n+\t\tversion: \"v0.0.0-20180219231006-80d85c5d4d17\",\n+\t\tname:    \"80d85c5d4d17598a0e9055e7c175a32b415d6128\",\n+\t\tshort:   \"80d85c5d4d17\",\n+\t\ttime:    time.Date(2018, 2, 19, 23, 10, 6, 0, time.UTC),\n+\t\tzip: []string{\n+\t\t\t\"LICENSE\",\n+\t\t\t\"README.md\",\n+\t\t\t\"pkg/p.go\",\n+\t\t},\n+\t},\n+\t{\n+\t\tvcs:  \"git\",\n+\t\tpath: \"github.com/rsc/vgotest1\",\n+\t\trev:  \"v0.0.1-0.20180219231006-80d85c5d4d17\",\n+\t\terr:  `github.com/rsc/vgotest1@v0.0.1-0.20180219231006-80d85c5d4d17: invalid pseudo-version: tag (v0.0.0) found on revision 80d85c5d4d17 is already canonical, so should not be replaced with a pseudo-version derived from that tag`,\n+\t},\n \t{\n \t\tvcs:     \"git\",\n \t\tpath:    \"github.com/rsc/vgotest1\",\n@@ -105,7 +125,7 @@ var codeRepoTests = []codeRepoTest{\n \t\tname:    \"45f53230a74ad275c7127e117ac46914c8126160\",\n \t\tshort:   \"45f53230a74a\",\n \t\ttime:    time.Date(2018, 7, 19, 1, 21, 27, 0, time.UTC),\n-\t\tziperr:  \"missing github.com/rsc/vgotest1/go.mod and .../v2/go.mod at revision v2.0.0\",\n+\t\terr:     \"missing github.com/rsc/vgotest1/go.mod and .../v2/go.mod at revision v2.0.0\",\n \t},\n \t{\n \t\tvcs:     \"git\",\n@@ -136,15 +156,14 @@ var codeRepoTests = []codeRepoTest{\n \t\t},\n \t},\n \t{\n-\t\tvcs:      \"git\",\n-\t\tpath:     \"github.com/rsc/vgotest1/v2\",\n-\t\trev:      \"45f53230a\",\n-\t\tversion:  \"v2.0.0\",\n-\t\tname:     \"45f53230a74ad275c7127e117ac46914c8126160\",\n-\t\tshort:    \"45f53230a74a\",\n-\t\ttime:     time.Date(2018, 7, 19, 1, 21, 27, 0, time.UTC),\n-\t\tgomoderr: \"missing github.com/rsc/vgotest1/go.mod and .../v2/go.mod at revision v2.0.0\",\n-\t\tziperr:   \"missing github.com/rsc/vgotest1/go.mod and .../v2/go.mod at revision v2.0.0\",\n+\t\tvcs:     \"git\",\n+\t\tpath:    \"github.com/rsc/vgotest1/v2\",\n+\t\trev:     \"45f53230a\",\n+\t\tversion: \"v2.0.0\",\n+\t\tname:    \"45f53230a74ad275c7127e117ac46914c8126160\",\n+\t\tshort:   \"45f53230a74a\",\n+\t\ttime:    time.Date(2018, 7, 19, 1, 21, 27, 0, time.UTC),\n+\t\terr:     \"missing github.com/rsc/vgotest1/go.mod and .../v2/go.mod at revision v2.0.0\",\n \t},\n \t{\n \t\tvcs:     \"git\",\n@@ -154,7 +173,7 @@ var codeRepoTests = []codeRepoTest{\n \t\tname:    \"80d85c5d4d17598a0e9055e7c175a32b415d6128\",\n \t\tshort:   \"80d85c5d4d17\",\n \t\ttime:    time.Date(2018, 2, 19, 23, 10, 6, 0, time.UTC),\n-\t\tziperr:  \"missing github.com/rsc/vgotest1/go.mod and .../v54321/go.mod at revision 80d85c5d4d17\",\n+\t\terr:     \"missing github.com/rsc/vgotest1/go.mod and .../v54321/go.mod at revision 80d85c5d4d17\",\n \t},\n \t{\n \t\tvcs:  \"git\",\n@@ -210,24 +229,24 @@ var codeRepoTests = []codeRepoTest{\n \t\tgomod:   \"module \\\"github.com/rsc/vgotest1/v2\\\" // root go.mod\\n\",\n \t},\n \t{\n-\t\tvcs:      \"git\",\n-\t\tpath:     \"github.com/rsc/vgotest1/v2\",\n-\t\trev:      \"v2.0.3\",\n-\t\tversion:  \"v2.0.3\",\n-\t\tname:     \"f18795870fb14388a21ef3ebc1d75911c8694f31\",\n-\t\tshort:    \"f18795870fb1\",\n-\t\ttime:     time.Date(2018, 2, 19, 23, 16, 4, 0, time.UTC),\n-\t\tgomoderr: \"github.com/rsc/vgotest1/v2/go.mod has non-.../v2 module path \\\"github.com/rsc/vgotest\\\" at revision v2.0.3\",\n+\t\tvcs:     \"git\",\n+\t\tpath:    \"github.com/rsc/vgotest1/v2\",\n+\t\trev:     \"v2.0.3\",\n+\t\tversion: \"v2.0.3\",\n+\t\tname:    \"f18795870fb14388a21ef3ebc1d75911c8694f31\",\n+\t\tshort:   \"f18795870fb1\",\n+\t\ttime:    time.Date(2018, 2, 19, 23, 16, 4, 0, time.UTC),\n+\t\terr:     \"github.com/rsc/vgotest1/v2/go.mod has non-.../v2 module path \\\"github.com/rsc/vgotest\\\" at revision v2.0.3\",\n \t},\n \t{\n-\t\tvcs:      \"git\",\n-\t\tpath:     \"github.com/rsc/vgotest1/v2\",\n-\t\trev:      \"v2.0.4\",\n-\t\tversion:  \"v2.0.4\",\n-\t\tname:     \"1f863feb76bc7029b78b21c5375644838962f88d\",\n-\t\tshort:    \"1f863feb76bc\",\n-\t\ttime:     time.Date(2018, 2, 20, 0, 3, 38, 0, time.UTC),\n-\t\tgomoderr: \"github.com/rsc/vgotest1/go.mod and .../v2/go.mod both have .../v2 module paths at revision v2.0.4\",\n+\t\tvcs:     \"git\",\n+\t\tpath:    \"github.com/rsc/vgotest1/v2\",\n+\t\trev:     \"v2.0.4\",\n+\t\tversion: \"v2.0.4\",\n+\t\tname:    \"1f863feb76bc7029b78b21c5375644838962f88d\",\n+\t\tshort:   \"1f863feb76bc\",\n+\t\ttime:    time.Date(2018, 2, 20, 0, 3, 38, 0, time.UTC),\n+\t\terr:     \"github.com/rsc/vgotest1/go.mod and .../v2/go.mod both have .../v2 module paths at revision v2.0.4\",\n \t},\n \t{\n \t\tvcs:     \"git\",\n@@ -504,6 +523,7 @@ func TestCodeRepo(t *testing.T) {\n \t\t\t\t\ttt.name = remap(tt.name, m)\n \t\t\t\t\ttt.short = remap(tt.short, m)\n \t\t\t\t\ttt.rev = remap(tt.rev, m)\n+\t\t\t\t\ttt.err = remap(tt.err, m)\n \t\t\t\t\ttt.gomoderr = remap(tt.gomoderr, m)\n \t\t\t\t\ttt.ziperr = remap(tt.ziperr, m)\n \t\t\t\t\tt.Run(strings.ReplaceAll(tt.path, \"/\", \"_\")+\"/\"+tt.rev, f(tt))\n@@ -515,7 +535,7 @@ func TestCodeRepo(t *testing.T) {\n }\n \n var hgmap = map[string]string{\n-\t\"github.com/rsc/vgotest1/\":                 \"vcs-test.golang.org/hg/vgotest1.hg/\",\n+\t\"github.com/rsc/vgotest1\":                  \"vcs-test.golang.org/hg/vgotest1.hg\",\n \t\"f18795870fb14388a21ef3ebc1d75911c8694f31\": \"a9ad6d1d14eb544f459f446210c7eb3b009807c6\",\n \t\"ea65f87c8f52c15ea68f3bdd9925ef17e20d91e9\": \"f1fc0f22021b638d073d31c752847e7bf385def7\",\n \t\"b769f2de407a4db81af9c5de0a06016d60d2ea09\": \"92c7eb888b4fac17f1c6bd2e1060a1b881a3b832\",\n@@ -631,15 +651,30 @@ var latestTests = []struct {\n \t\terr:  \"no commits\",\n \t},\n \t{\n-\t\tvcs:     \"git\",\n-\t\tpath:    \"github.com/rsc/vgotest1\",\n-\t\tversion: \"v0.0.0-20180219223237-a08abb797a67\",\n+\t\tvcs:  \"git\",\n+\t\tpath: \"github.com/rsc/vgotest1\",\n+\t\terr:  `github.com/rsc/vgotest1@v0.0.0-20180219223237-a08abb797a67: invalid version: go.mod has post-v0 module path \"github.com/vgotest1/v2\" at revision a08abb797a67`,\n+\t},\n+\t{\n+\t\tvcs:  \"git\",\n+\t\tpath: \"github.com/rsc/vgotest1/v2\",\n+\t\terr:  `github.com/rsc/vgotest1/v2@v2.0.0-20180219223237-a08abb797a67: invalid version: github.com/rsc/vgotest1/go.mod and .../v2/go.mod both have .../v2 module paths at revision a08abb797a67`,\n \t},\n \t{\n \t\tvcs:  \"git\",\n \t\tpath: \"github.com/rsc/vgotest1/subdir\",\n \t\terr:  \"github.com/rsc/vgotest1/subdir@v0.0.0-20180219223237-a08abb797a67: invalid version: missing github.com/rsc/vgotest1/subdir/go.mod at revision a08abb797a67\",\n \t},\n+\t{\n+\t\tvcs:     \"git\",\n+\t\tpath:    \"vcs-test.golang.org/git/commit-after-tag.git\",\n+\t\tversion: \"v1.0.1-0.20190715211727-b325d8217783\",\n+\t},\n+\t{\n+\t\tvcs:     \"git\",\n+\t\tpath:    \"vcs-test.golang.org/git/no-tags.git\",\n+\t\tversion: \"v0.0.0-20190715212047-e706ba1d9f6d\",\n+\t},\n \t{\n \t\tvcs:     \"mod\",\n \t\tpath:    \"swtch.com/testmod\","}, {"sha": "51a56028c4acbeab3d3c8b2130916b408a3e6921", "filename": "libgo/go/cmd/go/internal/modfetch/fetch.go", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -701,9 +701,11 @@ to use and optionally its public key and URL, as in:\n \tGOSUMDB=\"sum.golang.org+<publickey>\"\n \tGOSUMDB=\"sum.golang.org+<publickey> https://sum.golang.org\"\n \n-The go command knows the public key of sum.golang.org; use of any other\n-database requires giving the public key explicitly. The URL defaults to\n-\"https://\" followed by the database name.\n+The go command knows the public key of sum.golang.org, and also that the name\n+sum.golang.google.cn (available inside mainland China) connects to the\n+sum.golang.org checksum database; use of any other database requires giving\n+the public key explicitly.\n+The URL defaults to \"https://\" followed by the database name.\n \n GOSUMDB defaults to \"sum.golang.org\", the Go checksum database run by Google.\n See https://sum.golang.org/privacy for the service's privacy policy."}, {"sha": "569ef3a57a60a39682d00c8a38b0c54113307cca", "filename": "libgo/go/cmd/go/internal/modfetch/proxy.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fproxy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fproxy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fproxy.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -345,7 +345,9 @@ func (p *proxyRepo) Stat(rev string) (*RevInfo, error) {\n func (p *proxyRepo) Latest() (*RevInfo, error) {\n \tdata, err := p.getBytes(\"@latest\")\n \tif err != nil {\n-\t\t// TODO return err if not 404\n+\t\tif !errors.Is(err, os.ErrNotExist) {\n+\t\t\treturn nil, p.versionError(\"\", err)\n+\t\t}\n \t\treturn p.latest()\n \t}\n \tinfo := new(RevInfo)"}, {"sha": "be52a8dc11f977fe357b04bfe4cb2b3a84aadb8c", "filename": "libgo/go/cmd/go/internal/modfetch/repo.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Frepo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Frepo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Frepo.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -240,7 +240,7 @@ func lookup(proxy, path string) (r Repo, err error) {\n \n var (\n \terrModVendor       = errors.New(\"module lookup disabled by -mod=vendor\")\n-\terrProxyOff        = errors.New(\"module lookup disabled by GOPROXY=off\")\n+\terrProxyOff        = notExistError(\"module lookup disabled by GOPROXY=off\")\n \terrNoproxy   error = notExistError(\"disabled by GOPRIVATE/GONOPROXY\")\n \terrUseProxy  error = notExistError(\"path does not match GOPRIVATE/GONOPROXY\")\n )"}, {"sha": "1c24ec273b57b4391e213f1199a04964144316d5", "filename": "libgo/go/cmd/go/internal/modfetch/sumdb.go", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fsumdb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fsumdb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fsumdb.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -60,7 +60,17 @@ func dbDial() (dbName string, db *sumweb.Conn, err error) {\n \t// $GOSUMDB can be \"key\" or \"key url\",\n \t// and the key can be a full verifier key\n \t// or a host on our list of known keys.\n-\tkey := strings.Fields(cfg.GOSUMDB)\n+\n+\t// Special case: sum.golang.google.cn\n+\t// is an alias, reachable inside mainland China,\n+\t// for sum.golang.org. If there are more\n+\t// of these we should add a map like knownGOSUMDB.\n+\tgosumdb := cfg.GOSUMDB\n+\tif gosumdb == \"sum.golang.google.cn\" {\n+\t\tgosumdb = \"sum.golang.org https://sum.golang.google.cn\"\n+\t}\n+\n+\tkey := strings.Fields(gosumdb)\n \tif len(key) >= 1 {\n \t\tif k := knownGOSUMDB[key[0]]; k != \"\" {\n \t\t\tkey[0] = k\n@@ -232,10 +242,10 @@ func (*dbClient) WriteConfig(file string, old, new []byte) error {\n }\n \n // ReadCache reads cached lookups or tiles from\n-// GOPATH/pkg/mod/download/cache/sumdb,\n+// GOPATH/pkg/mod/cache/download/sumdb,\n // which will be deleted by \"go clean -modcache\".\n func (*dbClient) ReadCache(file string) ([]byte, error) {\n-\ttarg := filepath.Join(PkgMod, \"download/cache/sumdb\", file)\n+\ttarg := filepath.Join(PkgMod, \"cache/download/sumdb\", file)\n \tdata, err := lockedfile.Read(targ)\n \t// lockedfile.Write does not atomically create the file with contents.\n \t// There is a moment between file creation and locking the file for writing,\n@@ -249,7 +259,7 @@ func (*dbClient) ReadCache(file string) ([]byte, error) {\n \n // WriteCache updates cached lookups or tiles.\n func (*dbClient) WriteCache(file string, data []byte) {\n-\ttarg := filepath.Join(PkgMod, \"download/cache/sumdb\", file)\n+\ttarg := filepath.Join(PkgMod, \"cache/download/sumdb\", file)\n \tos.MkdirAll(filepath.Dir(targ), 0777)\n \tlockedfile.Write(targ, bytes.NewReader(data), 0666)\n }"}, {"sha": "1cae311c4c157b825164f2fe36fbd559fe2ebeeb", "filename": "libgo/go/cmd/go/internal/modget/get.go", "status": "modified", "additions": 82, "deletions": 38, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fget.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fget.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fget.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -39,17 +39,27 @@ and then builds and installs them.\n The first step is to resolve which dependencies to add.\n \n For each named package or package pattern, get must decide which version of\n-the corresponding module to use. By default, get chooses the latest tagged\n+the corresponding module to use. By default, get looks up the latest tagged\n release version, such as v0.4.5 or v1.2.3. If there are no tagged release\n-versions, get chooses the latest tagged pre-release version, such as\n-v0.0.1-pre1. If there are no tagged versions at all, get chooses the latest\n-known commit.\n+versions, get looks up the latest tagged pre-release version, such as\n+v0.0.1-pre1. If there are no tagged versions at all, get looks up the latest\n+known commit. If the module is not already required at a later version\n+(for example, a pre-release newer than the latest release), get will use\n+the version it looked up. Otherwise, get will use the currently\n+required version.\n \n This default version selection can be overridden by adding an @version\n suffix to the package argument, as in 'go get golang.org/x/text@v0.3.0'.\n+The version may be a prefix: @v1 denotes the latest available version starting\n+with v1. See 'go help modules' under the heading 'Module queries' for the\n+full query syntax.\n+\n For modules stored in source control repositories, the version suffix can\n also be a commit hash, branch identifier, or other syntax known to the\n-source control system, as in 'go get golang.org/x/text@master'.\n+source control system, as in 'go get golang.org/x/text@master'. Note that\n+branches with names that overlap with other module query syntax cannot be\n+selected explicitly. For example, the suffix @v2 means the latest version\n+starting with v2, not the branch named v2.\n \n If a module under consideration is already a dependency of the current\n development module, then get will update the required version.\n@@ -59,12 +69,14 @@ dependency should be removed entirely, downgrading or removing modules\n depending on it as needed.\n \n The version suffix @latest explicitly requests the latest minor release of the\n-given path. The suffix @patch requests the latest patch release: if the path\n-is already in the build list, the selected version will have the same minor\n-version. If the path is not already in the build list, @patch is equivalent\n-to @latest. Neither @latest nor @patch will cause 'go get' to downgrade a module\n-in the build list if it is required at a newer pre-release version that is\n-newer than the latest released version.\n+module named by the given path. The suffix @upgrade is like @latest but\n+will not downgrade a module if it is already required at a revision or\n+pre-release version newer than the latest released version. The suffix\n+@patch requests the latest patch release: the latest released version\n+with the same major and minor version numbers as the currently required\n+version. Like @upgrade, @patch will not downgrade a module already required\n+at a newer version. If the path is not already required, @upgrade and @patch\n+are equivalent to @latest.\n \n Although get defaults to using the latest version of the module containing\n a named package, it does not use the latest version of that module's\n@@ -178,7 +190,7 @@ func (v *upgradeFlag) Set(s string) error {\n \t\ts = \"\"\n \t}\n \tif s == \"true\" {\n-\t\ts = \"latest\"\n+\t\ts = \"upgrade\"\n \t}\n \t*v = upgradeFlag(s)\n \treturn nil\n@@ -202,8 +214,9 @@ type getArg struct {\n \t// if there is no \"@\"). path specifies the modules or packages to get.\n \tpath string\n \n-\t// vers is the part of the argument after \"@\" (or \"\" if there is no \"@\").\n-\t// vers specifies the module version to get.\n+\t// vers is the part of the argument after \"@\" or an implied\n+\t// \"upgrade\" or \"patch\" if there is no \"@\". vers specifies the\n+\t// module version to get.\n \tvers string\n }\n \n@@ -249,7 +262,7 @@ func runGet(cmd *base.Command, args []string) {\n \t}\n \n \tswitch getU {\n-\tcase \"\", \"latest\", \"patch\":\n+\tcase \"\", \"upgrade\", \"patch\":\n \t\t// ok\n \tdefault:\n \t\tbase.Fatalf(\"go get: unknown upgrade flag -u=%s\", getU)\n@@ -283,11 +296,11 @@ func runGet(cmd *base.Command, args []string) {\n \n \t// Parse command-line arguments and report errors. The command-line\n \t// arguments are of the form path@version or simply path, with implicit\n-\t// @latest. path@none is \"downgrade away\".\n+\t// @upgrade. path@none is \"downgrade away\".\n \tvar gets []getArg\n \tvar queries []*query\n \tfor _, arg := range search.CleanPatterns(args) {\n-\t\t// Argument is module query path@vers, or else path with implicit @latest.\n+\t\t// Argument is path or path@vers.\n \t\tpath := arg\n \t\tvers := \"\"\n \t\tif i := strings.Index(arg, \"@\"); i >= 0 {\n@@ -298,10 +311,14 @@ func runGet(cmd *base.Command, args []string) {\n \t\t\tcontinue\n \t\t}\n \n-\t\t// If the user runs 'go get -u=patch some/module', update some/module to a\n-\t\t// patch release, not a minor version.\n-\t\tif vers == \"\" && getU != \"\" {\n-\t\t\tvers = string(getU)\n+\t\t// If no version suffix is specified, assume @upgrade.\n+\t\t// If -u=patch was specified, assume @patch instead.\n+\t\tif vers == \"\" {\n+\t\t\tif getU != \"\" {\n+\t\t\t\tvers = string(getU)\n+\t\t\t} else {\n+\t\t\t\tvers = \"upgrade\"\n+\t\t\t}\n \t\t}\n \n \t\tgets = append(gets, getArg{raw: arg, path: path, vers: vers})\n@@ -358,7 +375,7 @@ func runGet(cmd *base.Command, args []string) {\n \t\t\t// The argument is a package path.\n \t\t\tif pkgs := modload.TargetPackages(path); len(pkgs) != 0 {\n \t\t\t\t// The path is in the main module. Nothing to query.\n-\t\t\t\tif vers != \"\" && vers != \"latest\" && vers != \"patch\" {\n+\t\t\t\tif vers != \"upgrade\" && vers != \"patch\" {\n \t\t\t\t\tbase.Errorf(\"go get %s: can't request explicit version of path in main module\", arg)\n \t\t\t\t}\n \t\t\t\tcontinue\n@@ -376,8 +393,8 @@ func runGet(cmd *base.Command, args []string) {\n \t\t\t\tcontinue\n \t\t\t}\n \n-\t\t\t// If we're querying \"latest\" or \"patch\", we need to know the current\n-\t\t\t// version of the module. For \"latest\", we want to avoid accidentally\n+\t\t\t// If we're querying \"upgrade\" or \"patch\", we need to know the current\n+\t\t\t// version of the module. For \"upgrade\", we want to avoid accidentally\n \t\t\t// downgrading from a newer prerelease. For \"patch\", we need to query\n \t\t\t// the correct minor version.\n \t\t\t// Here, we check if \"path\" is the name of a module in the build list\n@@ -718,7 +735,7 @@ func runQueries(cache map[querySpec]*query, queries []*query, modOnly map[string\n \treturn byPath\n }\n \n-// getQuery evaluates the given package path, version pair\n+// getQuery evaluates the given (package or module) path and version\n // to determine the underlying module version being requested.\n // If forceModulePath is set, getQuery must interpret path\n // as a module path.\n@@ -736,34 +753,51 @@ func getQuery(path, vers string, prevM module.Version, forceModulePath bool) (mo\n \t\tbase.Fatalf(\"go get: internal error: prevM may be set if and only if forceModulePath is set\")\n \t}\n \n-\tif vers == \"\" || vers == \"patch\" && prevM.Version == \"\" {\n-\t\tvers = \"latest\"\n-\t}\n-\n-\tif forceModulePath || !strings.Contains(path, \"...\") {\n+\t// If the query must be a module path, try only that module path.\n+\tif forceModulePath {\n \t\tif path == modload.Target.Path {\n \t\t\tif vers != \"latest\" {\n \t\t\t\treturn module.Version{}, fmt.Errorf(\"can't get a specific version of the main module\")\n \t\t\t}\n \t\t}\n \n-\t\t// If the path doesn't contain a wildcard, try interpreting it as a module path.\n \t\tinfo, err := modload.Query(path, vers, prevM.Version, modload.Allowed)\n \t\tif err == nil {\n \t\t\treturn module.Version{Path: path, Version: info.Version}, nil\n \t\t}\n \n-\t\t// If the query fails, and the path must be a real module, report the query error.\n-\t\tif forceModulePath {\n-\t\t\treturn module.Version{}, err\n+\t\t// If the query was \"upgrade\" or \"patch\" and the current version has been\n+\t\t// replaced, check to see whether the error was for that same version:\n+\t\t// if so, the version was probably replaced because it is invalid,\n+\t\t// and we should keep that replacement without complaining.\n+\t\tif vers == \"upgrade\" || vers == \"patch\" {\n+\t\t\tvar vErr *module.InvalidVersionError\n+\t\t\tif errors.As(err, &vErr) && vErr.Version == prevM.Version && modload.Replacement(prevM).Path != \"\" {\n+\t\t\t\treturn prevM, nil\n+\t\t\t}\n \t\t}\n+\n+\t\treturn module.Version{}, err\n \t}\n \n-\t// Otherwise, try a package path or pattern.\n+\t// If the query may be either a package or a module, try it as a package path.\n+\t// If it turns out to only exist as a module, we can detect the resulting\n+\t// PackageNotInModuleError and avoid a second round-trip through (potentially)\n+\t// all of the configured proxies.\n \tresults, err := modload.QueryPattern(path, vers, modload.Allowed)\n \tif err != nil {\n+\t\t// If the path doesn't contain a wildcard, check whether it was actually a\n+\t\t// module path instead. If so, return that.\n+\t\tif !strings.Contains(path, \"...\") {\n+\t\t\tvar modErr *modload.PackageNotInModuleError\n+\t\t\tif errors.As(err, &modErr) && modErr.Mod.Path == path {\n+\t\t\t\treturn modErr.Mod, nil\n+\t\t\t}\n+\t\t}\n+\n \t\treturn module.Version{}, err\n \t}\n+\n \treturn results[0].Mod, nil\n }\n \n@@ -893,13 +927,23 @@ func (u *upgrader) Upgrade(m module.Version) (module.Version, error) {\n \t// which may return a pseudoversion for the latest commit.\n \t// Query \"latest\" returns the newest tagged version or the newest\n \t// prerelease version if there are no non-prereleases, or repo.Latest\n-\t// if there aren't any tagged versions. Since we're providing the previous\n-\t// version, Query will confirm the latest version is actually newer\n-\t// and will return the current version if not.\n+\t// if there aren't any tagged versions.\n+\t// If we're querying \"upgrade\" or \"patch\", Query will compare the current\n+\t// version against the chosen version and will return the current version\n+\t// if it is newer.\n \tinfo, err := modload.Query(m.Path, string(getU), m.Version, modload.Allowed)\n \tif err != nil {\n \t\t// Report error but return m, to let version selection continue.\n \t\t// (Reporting the error will fail the command at the next base.ExitIfErrors.)\n+\n+\t\t// Special case: if the error is for m.Version itself and m.Version has a\n+\t\t// replacement, then keep it and don't report the error: the fact that the\n+\t\t// version is invalid is likely the reason it was replaced to begin with.\n+\t\tvar vErr *module.InvalidVersionError\n+\t\tif errors.As(err, &vErr) && vErr.Version == m.Version && modload.Replacement(m).Path != \"\" {\n+\t\t\treturn m, nil\n+\t\t}\n+\n \t\t// Special case: if the error is \"no matching versions\" then don't\n \t\t// even report the error. Because Query does not consider pseudo-versions,\n \t\t// it may happen that we have a pseudo-version but during -u=patch"}, {"sha": "7cbdef1c36c721c4a714765d0ec60fc4632b0518", "filename": "libgo/go/cmd/go/internal/modload/build.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -79,7 +79,7 @@ func addUpdate(m *modinfo.ModulePublic) {\n \t\treturn\n \t}\n \n-\tif info, err := Query(m.Path, \"latest\", m.Version, Allowed); err == nil && semver.Compare(info.Version, m.Version) > 0 {\n+\tif info, err := Query(m.Path, \"upgrade\", m.Version, Allowed); err == nil && semver.Compare(info.Version, m.Version) > 0 {\n \t\tm.Update = &modinfo.ModulePublic{\n \t\t\tPath:    m.Path,\n \t\t\tVersion: info.Version,"}, {"sha": "1927c1cff7363b639ca1bb9f68dbf39c67e67ecc", "filename": "libgo/go/cmd/go/internal/modload/help.go", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -231,12 +231,25 @@ evaluates to the available tagged version nearest to the comparison target\n The string \"latest\" matches the latest available tagged version,\n or else the underlying source repository's latest untagged revision.\n \n-A revision identifier for the underlying source repository,\n-such as a commit hash prefix, revision tag, or branch name,\n-selects that specific code revision. If the revision is\n-also tagged with a semantic version, the query evaluates to\n-that semantic version. Otherwise the query evaluates to a\n-pseudo-version for the commit.\n+The string \"upgrade\" is like \"latest\", but if the module is\n+currently required at a later version than the version \"latest\"\n+would select (for example, a newer pre-release version), \"upgrade\"\n+will select the later version instead.\n+\n+The string \"patch\" matches the latest available tagged version\n+of a module with the same major and minor version numbers as the\n+currently required version. If no version is currently required,\n+\"patch\" is equivalent to \"latest\".\n+\n+A revision identifier for the underlying source repository, such as\n+a commit hash prefix, revision tag, or branch name, selects that\n+specific code revision. If the revision is also tagged with a\n+semantic version, the query evaluates to that semantic version.\n+Otherwise the query evaluates to a pseudo-version for the commit.\n+Note that branches and tags with names that are matched by other\n+query syntax cannot be selected this way. For example, the query\n+\"v2\" means the latest version starting with \"v2\", not the branch\n+named \"v2\".\n \n All queries prefer release versions to pre-release versions.\n For example, \"<v1.2.3\" will prefer to return \"v1.2.2\""}, {"sha": "70add3507a20b08e478140e8b11b607a9b3ab416", "filename": "libgo/go/cmd/go/internal/modload/import.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -22,6 +22,7 @@ import (\n \t\"cmd/go/internal/par\"\n \t\"cmd/go/internal/search\"\n \t\"cmd/go/internal/semver\"\n+\t\"cmd/go/internal/str\"\n )\n \n type ImportMissingError struct {\n@@ -35,6 +36,9 @@ type ImportMissingError struct {\n \n func (e *ImportMissingError) Error() string {\n \tif e.Module.Path == \"\" {\n+\t\tif str.HasPathPrefix(e.ImportPath, \"cmd\") {\n+\t\t\treturn fmt.Sprintf(\"package %s is not in GOROOT (%s)\", e.ImportPath, filepath.Join(cfg.GOROOT, \"src\", e.ImportPath))\n+\t\t}\n \t\treturn \"cannot find module providing package \" + e.ImportPath\n \t}\n \treturn \"missing module for import: \" + e.Module.Path + \"@\" + e.Module.Version + \" provides \" + e.ImportPath\n@@ -74,6 +78,9 @@ func Import(path string) (m module.Version, dir string, err error) {\n \t\tdir := filepath.Join(cfg.GOROOT, \"src\", path)\n \t\treturn module.Version{}, dir, nil\n \t}\n+\tif str.HasPathPrefix(path, \"cmd\") {\n+\t\treturn module.Version{}, \"\", &ImportMissingError{ImportPath: path}\n+\t}\n \n \t// -mod=vendor is special.\n \t// Everything must be in the main module or the main module's vendor directory."}, {"sha": "35d0c28cde10b943f880d449531783c58cf0f27f", "filename": "libgo/go/cmd/go/internal/modload/list.go", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Flist.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -5,6 +5,7 @@\n package modload\n \n import (\n+\t\"errors\"\n \t\"fmt\"\n \t\"os\"\n \t\"strings\"\n@@ -70,9 +71,7 @@ func listModules(args []string, listVersions bool) []*modinfo.ModulePublic {\n \t\t\t\tmods = append(mods, &modinfo.ModulePublic{\n \t\t\t\t\tPath:    path,\n \t\t\t\t\tVersion: vers,\n-\t\t\t\t\tError: &modinfo.ModuleError{\n-\t\t\t\t\t\tErr: err.Error(),\n-\t\t\t\t\t},\n+\t\t\t\t\tError:   modinfoError(path, vers, err),\n \t\t\t\t})\n \t\t\t\tcontinue\n \t\t\t}\n@@ -116,19 +115,15 @@ func listModules(args []string, listVersions bool) []*modinfo.ModulePublic {\n \t\t\t\t\t\tmods = append(mods, moduleInfo(module.Version{Path: arg, Version: info.Version}, false))\n \t\t\t\t\t} else {\n \t\t\t\t\t\tmods = append(mods, &modinfo.ModulePublic{\n-\t\t\t\t\t\t\tPath: arg,\n-\t\t\t\t\t\t\tError: &modinfo.ModuleError{\n-\t\t\t\t\t\t\t\tErr: err.Error(),\n-\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\tPath:  arg,\n+\t\t\t\t\t\t\tError: modinfoError(arg, \"\", err),\n \t\t\t\t\t\t})\n \t\t\t\t\t}\n \t\t\t\t\tcontinue\n \t\t\t\t}\n \t\t\t\tmods = append(mods, &modinfo.ModulePublic{\n-\t\t\t\t\tPath: arg,\n-\t\t\t\t\tError: &modinfo.ModuleError{\n-\t\t\t\t\t\tErr: fmt.Sprintf(\"module %q is not a known dependency\", arg),\n-\t\t\t\t\t},\n+\t\t\t\t\tPath:  arg,\n+\t\t\t\t\tError: modinfoError(arg, \"\", errors.New(\"not a known dependency\")),\n \t\t\t\t})\n \t\t\t} else {\n \t\t\t\tfmt.Fprintf(os.Stderr, \"warning: pattern %q matched no module dependencies\\n\", arg)\n@@ -138,3 +133,21 @@ func listModules(args []string, listVersions bool) []*modinfo.ModulePublic {\n \n \treturn mods\n }\n+\n+// modinfoError wraps an error to create an error message in\n+// modinfo.ModuleError with minimal redundancy.\n+func modinfoError(path, vers string, err error) *modinfo.ModuleError {\n+\tvar nerr *NoMatchingVersionError\n+\tvar merr *module.ModuleError\n+\tif errors.As(err, &nerr) {\n+\t\t// NoMatchingVersionError contains the query, so we don't mention the\n+\t\t// query again in ModuleError.\n+\t\terr = &module.ModuleError{Path: path, Err: err}\n+\t} else if !errors.As(err, &merr) {\n+\t\t// If the error does not contain path and version, wrap it in a\n+\t\t// module.ModuleError.\n+\t\terr = &module.ModuleError{Path: path, Version: vers, Err: err}\n+\t}\n+\n+\treturn &modinfo.ModuleError{Err: err.Error()}\n+}"}, {"sha": "d18723e7dcd339a39e259be9e892b58e0d9af867", "filename": "libgo/go/cmd/go/internal/modload/load.go", "status": "modified", "additions": 58, "deletions": 22, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -100,11 +100,31 @@ func ImportPathsQuiet(patterns []string, tags map[string]bool) []*search.Match {\n \t\t\t\t\t\tdir = filepath.Clean(dir)\n \t\t\t\t\t}\n \n+\t\t\t\t\t// golang.org/issue/32917: We should resolve a relative path to a\n+\t\t\t\t\t// package path only if the relative path actually contains the code\n+\t\t\t\t\t// for that package.\n+\t\t\t\t\tif !dirContainsPackage(dir) {\n+\t\t\t\t\t\t// If we're outside of a module, ensure that the failure mode\n+\t\t\t\t\t\t// indicates that.\n+\t\t\t\t\t\tModRoot()\n+\n+\t\t\t\t\t\t// If the directory is local but does not exist, don't return it\n+\t\t\t\t\t\t// while loader is iterating, since this might trigger a fetch.\n+\t\t\t\t\t\t// After loader is done iterating, we still need to return the\n+\t\t\t\t\t\t// path, so that \"go list -e\" produces valid output.\n+\t\t\t\t\t\tif !iterating {\n+\t\t\t\t\t\t\t// We don't have a valid path to resolve to, so report the\n+\t\t\t\t\t\t\t// unresolved path.\n+\t\t\t\t\t\t\tm.Pkgs = append(m.Pkgs, pkg)\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tcontinue\n+\t\t\t\t\t}\n+\n \t\t\t\t\t// Note: The checks for @ here are just to avoid misinterpreting\n \t\t\t\t\t// the module cache directories (formerly GOPATH/src/mod/foo@v1.5.2/bar).\n \t\t\t\t\t// It's not strictly necessary but helpful to keep the checks.\n \t\t\t\t\tif modRoot != \"\" && dir == modRoot {\n-\t\t\t\t\t\tpkg = Target.Path\n+\t\t\t\t\t\tpkg = targetPrefix\n \t\t\t\t\t} else if modRoot != \"\" && strings.HasPrefix(dir, modRoot+string(filepath.Separator)) && !strings.Contains(dir[len(modRoot):], \"@\") {\n \t\t\t\t\t\tsuffix := filepath.ToSlash(dir[len(modRoot):])\n \t\t\t\t\t\tif strings.HasPrefix(suffix, \"/vendor/\") {\n@@ -121,7 +141,13 @@ func ImportPathsQuiet(patterns []string, tags map[string]bool) []*search.Match {\n \t\t\t\t\t\t\t\tcontinue\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tpkg = Target.Path + suffix\n+\t\t\t\t\t\t\tmodPkg := targetPrefix + suffix\n+\t\t\t\t\t\t\tif _, ok := dirInModule(modPkg, targetPrefix, modRoot, true); ok {\n+\t\t\t\t\t\t\t\tpkg = modPkg\n+\t\t\t\t\t\t\t} else if !iterating {\n+\t\t\t\t\t\t\t\tModRoot()\n+\t\t\t\t\t\t\t\tbase.Errorf(\"go: directory %s is outside main module\", base.ShortPath(dir))\n+\t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t} else if sub := search.InDir(dir, cfg.GOROOTsrc); sub != \"\" && sub != \".\" && !strings.Contains(sub, \"@\") {\n \t\t\t\t\t\tpkg = filepath.ToSlash(sub)\n@@ -134,16 +160,6 @@ func ImportPathsQuiet(patterns []string, tags map[string]bool) []*search.Match {\n \t\t\t\t\t\t\tbase.Errorf(\"go: directory %s outside available modules\", base.ShortPath(dir))\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n-\t\t\t\t\tinfo, err := os.Stat(dir)\n-\t\t\t\t\tif err != nil || !info.IsDir() {\n-\t\t\t\t\t\t// If the directory is local but does not exist, don't return it\n-\t\t\t\t\t\t// while loader is iterating, since this would trigger a fetch.\n-\t\t\t\t\t\t// After loader is done iterating, we still need to return the\n-\t\t\t\t\t\t// path, so that \"go list -e\" produces valid output.\n-\t\t\t\t\t\tif iterating {\n-\t\t\t\t\t\t\tcontinue\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n \t\t\t\t\tm.Pkgs = append(m.Pkgs, pkg)\n \t\t\t\t}\n \n@@ -247,14 +263,30 @@ func pathInModuleCache(dir string) string {\n \treturn \"\"\n }\n \n-// warnPattern returns list, the result of matching pattern,\n-// but if list is empty then first it prints a warning about\n-// the pattern not matching any packages.\n-func warnPattern(pattern string, list []string) []string {\n-\tif len(list) == 0 {\n-\t\tfmt.Fprintf(os.Stderr, \"warning: %q matched no packages\\n\", pattern)\n+var dirContainsPackageCache sync.Map // absolute dir \u2192 bool\n+\n+func dirContainsPackage(dir string) bool {\n+\tisPkg, ok := dirContainsPackageCache.Load(dir)\n+\tif !ok {\n+\t\t_, err := cfg.BuildContext.ImportDir(dir, 0)\n+\t\tif err == nil {\n+\t\t\tisPkg = true\n+\t\t} else {\n+\t\t\tif fi, statErr := os.Stat(dir); statErr != nil || !fi.IsDir() {\n+\t\t\t\t// A non-directory or inaccessible directory is not a Go package.\n+\t\t\t\tisPkg = false\n+\t\t\t} else if _, noGo := err.(*build.NoGoError); noGo {\n+\t\t\t\t// A directory containing no Go source files is not a Go package.\n+\t\t\t\tisPkg = false\n+\t\t\t} else {\n+\t\t\t\t// An error other than *build.NoGoError indicates that the package exists\n+\t\t\t\t// but has some other problem (such as a syntax error).\n+\t\t\t\tisPkg = true\n+\t\t\t}\n+\t\t}\n+\t\tisPkg, _ = dirContainsPackageCache.LoadOrStore(dir, isPkg)\n \t}\n-\treturn list\n+\treturn isPkg.(bool)\n }\n \n // ImportFromFiles adds modules to the build list as needed\n@@ -355,11 +387,13 @@ func loadAll(testAll bool) []string {\n \n \tvar paths []string\n \tfor _, pkg := range loaded.pkgs {\n-\t\tif e, ok := pkg.err.(*ImportMissingError); ok && e.Module.Path == \"\" {\n-\t\t\tcontinue // Package doesn't actually exist.\n+\t\tif pkg.err != nil {\n+\t\t\tbase.Errorf(\"%s: %v\", pkg.stackText(), pkg.err)\n+\t\t\tcontinue\n \t\t}\n \t\tpaths = append(paths, pkg.path)\n \t}\n+\tbase.ExitIfErrors()\n \treturn paths\n }\n \n@@ -1108,7 +1142,9 @@ func (r *mvsReqs) required(mod module.Version) ([]module.Version, error) {\n \t\treturn nil, module.VersionError(mod, errors.New(\"parsing go.mod: missing module line\"))\n \t}\n \tif mpath := f.Module.Mod.Path; mpath != origPath && mpath != mod.Path {\n-\t\treturn nil, module.VersionError(mod, fmt.Errorf(\"parsing go.mod: unexpected module path %q\", mpath))\n+\t\treturn nil, module.VersionError(mod, fmt.Errorf(`parsing go.mod:\n+\tmodule declares its path as: %s\n+\t        but was required as: %s`, mpath, mod.Path))\n \t}\n \tif f.Go != nil {\n \t\tr.versions.LoadOrStore(mod, f.Go.Version)"}, {"sha": "602bf47275db8bb7af45f682ef20c601d60888a8", "filename": "libgo/go/cmd/go/internal/modload/query.go", "status": "modified", "additions": 40, "deletions": 33, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -28,9 +28,10 @@ import (\n //   tagged version, with non-prereleases preferred over prereleases.\n //   If there are no tagged versions in the repo, latest returns the most\n //   recent commit.\n+// - the literal string \"upgrade\", equivalent to \"latest\" except that if\n+//   current is a newer version, current will be returned (see below).\n // - the literal string \"patch\", denoting the latest available tagged version\n-//   with the same major and minor number as current. If current is \"\",\n-//   \"patch\" is equivalent to \"latest\".\n+//   with the same major and minor number as current (see below).\n // - v1, denoting the latest available tagged version v1.x.x.\n // - v1.2, denoting the latest available tagged version v1.2.x.\n // - v1.2.3, a semantic version string denoting that tagged version.\n@@ -39,11 +40,12 @@ import (\n //   with non-prereleases preferred over prereleases.\n // - a repository commit identifier or tag, denoting that commit.\n //\n-// current is optional, denoting the current version of the module.\n-// If query is \"latest\" or \"patch\", current will be returned if it is a newer\n-// semantic version or if it is a chronologically later pseudoversion. This\n-// prevents accidental downgrades from newer prerelease or development\n-// versions.\n+// current denotes the current version of the module; it may be \"\" if the\n+// current version is unknown or should not be considered. If query is\n+// \"upgrade\" or \"patch\", current will be returned if it is a newer\n+// semantic version or a chronologically later pseudo-version than the\n+// version that would otherwise be chosen. This prevents accidental downgrades\n+// from newer pre-release or development versions.\n //\n // If the allowed function is non-nil, Query excludes any versions for which\n // allowed returns false.\n@@ -81,6 +83,10 @@ func queryProxy(proxy, path, query, current string, allowed func(module.Version)\n \t\tok = allowed\n \t\tmayUseLatest = true\n \n+\tcase query == \"upgrade\":\n+\t\tok = allowed\n+\t\tmayUseLatest = true\n+\n \tcase query == \"patch\":\n \t\tif current == \"\" {\n \t\t\tok = allowed\n@@ -202,9 +208,9 @@ func queryProxy(proxy, path, query, current string, allowed func(module.Version)\n \t\t\treturn nil, err\n \t\t}\n \n-\t\t// For \"latest\" and \"patch\", make sure we don't accidentally downgrade\n+\t\t// For \"upgrade\" and \"patch\", make sure we don't accidentally downgrade\n \t\t// from a newer prerelease or from a chronologically newer pseudoversion.\n-\t\tif current != \"\" && (query == \"latest\" || query == \"patch\") {\n+\t\tif current != \"\" && (query == \"upgrade\" || query == \"patch\") {\n \t\t\tcurrentTime, err := modfetch.PseudoVersionTime(current)\n \t\t\tif semver.Compare(rev.Version, current) < 0 || (err == nil && rev.Time.Before(currentTime)) {\n \t\t\t\treturn repo.Stat(current)\n@@ -374,10 +380,10 @@ func QueryPattern(pattern, query string, allowed func(module.Version) bool) ([]Q\n \t\t\t}\n \t\t\tr.Packages = match(r.Mod, root, isLocal)\n \t\t\tif len(r.Packages) == 0 {\n-\t\t\t\treturn r, &packageNotInModuleError{\n-\t\t\t\t\tmod:     r.Mod,\n-\t\t\t\t\tquery:   query,\n-\t\t\t\t\tpattern: pattern,\n+\t\t\t\treturn r, &PackageNotInModuleError{\n+\t\t\t\t\tMod:     r.Mod,\n+\t\t\t\t\tQuery:   query,\n+\t\t\t\t\tPattern: pattern,\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn r, nil\n@@ -440,30 +446,31 @@ func queryPrefixModules(candidateModules []string, queryModule func(path string)\n \twg.Wait()\n \n \t// Classify the results. In case of failure, identify the error that the user\n-\t// is most likely to find helpful.\n+\t// is most likely to find helpful: the most useful class of error at the\n+\t// longest matching path.\n \tvar (\n+\t\tnoPackage   *PackageNotInModuleError\n \t\tnoVersion   *NoMatchingVersionError\n-\t\tnoPackage   *packageNotInModuleError\n \t\tnotExistErr error\n \t)\n \tfor _, r := range results {\n \t\tswitch rErr := r.err.(type) {\n \t\tcase nil:\n \t\t\tfound = append(found, r.QueryResult)\n+\t\tcase *PackageNotInModuleError:\n+\t\t\tif noPackage == nil {\n+\t\t\t\tnoPackage = rErr\n+\t\t\t}\n \t\tcase *NoMatchingVersionError:\n \t\t\tif noVersion == nil {\n \t\t\t\tnoVersion = rErr\n \t\t\t}\n-\t\tcase *packageNotInModuleError:\n-\t\t\tif noPackage == nil {\n-\t\t\t\tnoPackage = rErr\n-\t\t\t}\n \t\tdefault:\n \t\t\tif errors.Is(rErr, os.ErrNotExist) {\n \t\t\t\tif notExistErr == nil {\n \t\t\t\t\tnotExistErr = rErr\n \t\t\t\t}\n-\t\t\t} else {\n+\t\t\t} else if err == nil {\n \t\t\t\terr = r.err\n \t\t\t}\n \t\t}\n@@ -503,37 +510,37 @@ type NoMatchingVersionError struct {\n \n func (e *NoMatchingVersionError) Error() string {\n \tcurrentSuffix := \"\"\n-\tif (e.query == \"latest\" || e.query == \"patch\") && e.current != \"\" {\n+\tif (e.query == \"upgrade\" || e.query == \"patch\") && e.current != \"\" {\n \t\tcurrentSuffix = fmt.Sprintf(\" (current version is %s)\", e.current)\n \t}\n \treturn fmt.Sprintf(\"no matching versions for query %q\", e.query) + currentSuffix\n }\n \n-// A packageNotInModuleError indicates that QueryPattern found a candidate\n+// A PackageNotInModuleError indicates that QueryPattern found a candidate\n // module at the requested version, but that module did not contain any packages\n // matching the requested pattern.\n //\n-// NOTE: packageNotInModuleError MUST NOT implement Is(os.ErrNotExist).\n+// NOTE: PackageNotInModuleError MUST NOT implement Is(os.ErrNotExist).\n //\n // If the module came from a proxy, that proxy had to return a successful status\n // code for the versions it knows about, and thus did not have the opportunity\n // to return a non-400 status code to suppress fallback.\n-type packageNotInModuleError struct {\n-\tmod     module.Version\n-\tquery   string\n-\tpattern string\n+type PackageNotInModuleError struct {\n+\tMod     module.Version\n+\tQuery   string\n+\tPattern string\n }\n \n-func (e *packageNotInModuleError) Error() string {\n+func (e *PackageNotInModuleError) Error() string {\n \tfound := \"\"\n-\tif e.query != e.mod.Version {\n-\t\tfound = fmt.Sprintf(\" (%s)\", e.mod.Version)\n+\tif e.Query != e.Mod.Version {\n+\t\tfound = fmt.Sprintf(\" (%s)\", e.Mod.Version)\n \t}\n \n-\tif strings.Contains(e.pattern, \"...\") {\n-\t\treturn fmt.Sprintf(\"module %s@%s%s found, but does not contain packages matching %s\", e.mod.Path, e.query, found, e.pattern)\n+\tif strings.Contains(e.Pattern, \"...\") {\n+\t\treturn fmt.Sprintf(\"module %s@%s%s found, but does not contain packages matching %s\", e.Mod.Path, e.Query, found, e.Pattern)\n \t}\n-\treturn fmt.Sprintf(\"module %s@%s%s found, but does not contain package %s\", e.mod.Path, e.query, found, e.pattern)\n+\treturn fmt.Sprintf(\"module %s@%s%s found, but does not contain package %s\", e.Mod.Path, e.Query, found, e.Pattern)\n }\n \n // ModuleHasRootPackage returns whether module m contains a package m.Path."}, {"sha": "b91cbb5a700df8eb62e18f425630530726f03695", "filename": "libgo/go/cmd/go/internal/modload/query_test.go", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -100,7 +100,7 @@ var queryTests = []struct {\n \t{path: queryRepo, query: \">=v0.0.0\", vers: \"v0.0.0\"},\n \t{path: queryRepo, query: \"v0.0.1\", vers: \"v0.0.1\"},\n \t{path: queryRepo, query: \"v0.0.1+foo\", vers: \"v0.0.1\"},\n-\t{path: queryRepo, query: \"v0.0.99\", err: `unknown revision v0.0.99`},\n+\t{path: queryRepo, query: \"v0.0.99\", err: `vcs-test.golang.org/git/querytest.git@v0.0.99: invalid version: unknown revision v0.0.99`},\n \t{path: queryRepo, query: \"v0\", vers: \"v0.3.0\"},\n \t{path: queryRepo, query: \"v0.1\", vers: \"v0.1.2\"},\n \t{path: queryRepo, query: \"v0.2\", err: `no matching versions for query \"v0.2\"`},\n@@ -112,15 +112,17 @@ var queryTests = []struct {\n \t// unconditionally).\n \t{path: queryRepo, query: \"42abcb6df8ee\", vers: \"v1.9.10-pre2.0.20190513201126-42abcb6df8ee\"},\n \n-\t{path: queryRepo, query: \"v1.9.10-pre2+wrongmetadata\", err: `unknown revision v1.9.10-pre2+wrongmetadata`},\n-\t{path: queryRepo, query: \"v1.9.10-pre2\", err: `unknown revision v1.9.10-pre2`},\n+\t{path: queryRepo, query: \"v1.9.10-pre2+wrongmetadata\", err: `vcs-test.golang.org/git/querytest.git@v1.9.10-pre2+wrongmetadata: invalid version: unknown revision v1.9.10-pre2+wrongmetadata`},\n+\t{path: queryRepo, query: \"v1.9.10-pre2\", err: `vcs-test.golang.org/git/querytest.git@v1.9.10-pre2: invalid version: unknown revision v1.9.10-pre2`},\n \t{path: queryRepo, query: \"latest\", vers: \"v1.9.9\"},\n-\t{path: queryRepo, query: \"latest\", current: \"v1.9.10-pre1\", vers: \"v1.9.10-pre1\"},\n-\t{path: queryRepo, query: \"latest\", current: \"v1.9.10-pre2+metadata\", vers: \"v1.9.10-pre2.0.20190513201126-42abcb6df8ee\"},\n-\t{path: queryRepo, query: \"latest\", current: \"v0.0.0-20190513201126-42abcb6df8ee\", vers: \"v0.0.0-20190513201126-42abcb6df8ee\"},\n-\t{path: queryRepo, query: \"latest\", allow: \"NOMATCH\", err: `no matching versions for query \"latest\"`},\n-\t{path: queryRepo, query: \"latest\", current: \"v1.9.9\", allow: \"NOMATCH\", err: `no matching versions for query \"latest\" (current version is v1.9.9)`},\n-\t{path: queryRepo, query: \"latest\", current: \"v1.99.99\", err: `unknown revision v1.99.99`},\n+\t{path: queryRepo, query: \"latest\", current: \"v1.9.10-pre1\", vers: \"v1.9.9\"},\n+\t{path: queryRepo, query: \"upgrade\", vers: \"v1.9.9\"},\n+\t{path: queryRepo, query: \"upgrade\", current: \"v1.9.10-pre1\", vers: \"v1.9.10-pre1\"},\n+\t{path: queryRepo, query: \"upgrade\", current: \"v1.9.10-pre2+metadata\", vers: \"v1.9.10-pre2.0.20190513201126-42abcb6df8ee\"},\n+\t{path: queryRepo, query: \"upgrade\", current: \"v0.0.0-20190513201126-42abcb6df8ee\", vers: \"v0.0.0-20190513201126-42abcb6df8ee\"},\n+\t{path: queryRepo, query: \"upgrade\", allow: \"NOMATCH\", err: `no matching versions for query \"upgrade\"`},\n+\t{path: queryRepo, query: \"upgrade\", current: \"v1.9.9\", allow: \"NOMATCH\", err: `no matching versions for query \"upgrade\" (current version is v1.9.9)`},\n+\t{path: queryRepo, query: \"upgrade\", current: \"v1.99.99\", err: `vcs-test.golang.org/git/querytest.git@v1.99.99: invalid version: unknown revision v1.99.99`},\n \t{path: queryRepo, query: \"patch\", current: \"\", vers: \"v1.9.9\"},\n \t{path: queryRepo, query: \"patch\", current: \"v0.1.0\", vers: \"v0.1.2\"},\n \t{path: queryRepo, query: \"patch\", current: \"v1.9.0\", vers: \"v1.9.9\"},\n@@ -159,8 +161,11 @@ var queryTests = []struct {\n \t{path: queryRepoV2, query: \"v2.6.0-pre1\", vers: \"v2.6.0-pre1\"},\n \t{path: queryRepoV2, query: \"latest\", vers: \"v2.5.5\"},\n \n-\t{path: queryRepoV3, query: \"e0cf3de987e6\", vers: \"v3.0.0-20180704024501-e0cf3de987e6\"},\n-\t{path: queryRepoV3, query: \"latest\", vers: \"v3.0.0-20180704024501-e0cf3de987e6\"},\n+\t// e0cf3de987e6 is the latest commit on the master branch, and it's actually\n+\t// v1.19.10-pre1, not anything resembling v3: attempting to query it as such\n+\t// should fail.\n+\t{path: queryRepoV3, query: \"e0cf3de987e6\", err: `vcs-test.golang.org/git/querytest.git/v3@v3.0.0-20180704024501-e0cf3de987e6: invalid version: go.mod has non-.../v3 module path \"vcs-test.golang.org/git/querytest.git\" (and .../v3/go.mod does not exist) at revision e0cf3de987e6`},\n+\t{path: queryRepoV3, query: \"latest\", err: `no matching versions for query \"latest\"`},\n \n \t{path: emptyRepo, query: \"latest\", vers: \"v0.0.0-20180704023549-7bb914627242\"},\n \t{path: emptyRepo, query: \">v0.0.0\", err: `no matching versions for query \">v0.0.0\"`},\n@@ -180,7 +185,10 @@ func TestQuery(t *testing.T) {\n \t\t\tok, _ := path.Match(allow, m.Version)\n \t\t\treturn ok\n \t\t}\n+\t\ttt := tt\n \t\tt.Run(strings.ReplaceAll(tt.path, \"/\", \"_\")+\"/\"+tt.query+\"/\"+tt.current+\"/\"+allow, func(t *testing.T) {\n+\t\t\tt.Parallel()\n+\n \t\t\tinfo, err := Query(tt.path, tt.query, tt.current, allowed)\n \t\t\tif tt.err != \"\" {\n \t\t\t\tif err == nil {"}, {"sha": "4e7a828c24f10515b9503325f8c80ab0f9ec5ff7", "filename": "libgo/go/cmd/go/internal/mvs/mvs.go", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -216,8 +216,8 @@ func buildList(target module.Version, reqs Reqs, upgrade func(module.Version) (m\n \t\t}\n \t}\n \n-\t// Construct the list by traversing the graph again, replacing older\n-\t// modules with required minimum versions.\n+\t// The final list is the minimum version of each module found in the graph.\n+\n \tif v := min[target.Path]; v != target.Version {\n \t\t// TODO(jayconrod): there is a special case in modload.mvsReqs.Max\n \t\t// that prevents us from selecting a newer version of a module\n@@ -228,19 +228,18 @@ func buildList(target module.Version, reqs Reqs, upgrade func(module.Version) (m\n \t}\n \n \tlist := []module.Version{target}\n-\tlisted := map[string]bool{target.Path: true}\n-\tfor i := 0; i < len(list); i++ {\n-\t\tn := modGraph[list[i]]\n+\tfor path, vers := range min {\n+\t\tif path != target.Path {\n+\t\t\tlist = append(list, module.Version{Path: path, Version: vers})\n+\t\t}\n+\n+\t\tn := modGraph[module.Version{Path: path, Version: vers}]\n \t\trequired := n.required\n \t\tfor _, r := range required {\n \t\t\tv := min[r.Path]\n \t\t\tif r.Path != target.Path && reqs.Max(v, r.Version) != v {\n \t\t\t\tpanic(fmt.Sprintf(\"mistake: version %q does not satisfy requirement %+v\", v, r)) // TODO: Don't panic.\n \t\t\t}\n-\t\t\tif !listed[r.Path] {\n-\t\t\t\tlist = append(list, module.Version{Path: r.Path, Version: v})\n-\t\t\t\tlisted[r.Path] = true\n-\t\t\t}\n \t\t}\n \t}\n \n@@ -289,12 +288,12 @@ func Req(target module.Version, list []module.Version, base []string, reqs Reqs)\n \t}\n \n \t// Walk modules in reverse post-order, only adding those not implied already.\n-\thave := map[string]string{}\n+\thave := map[module.Version]bool{}\n \twalk = func(m module.Version) error {\n-\t\tif v, ok := have[m.Path]; ok && reqs.Max(m.Version, v) == v {\n+\t\tif have[m] {\n \t\t\treturn nil\n \t\t}\n-\t\thave[m.Path] = m.Version\n+\t\thave[m] = true\n \t\tfor _, m1 := range reqCache[m] {\n \t\t\twalk(m1)\n \t\t}\n@@ -322,7 +321,7 @@ func Req(target module.Version, list []module.Version, base []string, reqs Reqs)\n \t\t\t// Older version.\n \t\t\tcontinue\n \t\t}\n-\t\tif have[m.Path] != m.Version {\n+\t\tif !have[m] {\n \t\t\tmin = append(min, m)\n \t\t\twalk(m)\n \t\t}"}, {"sha": "72d3ea95b7964f12e1a0eb45e99bf84b835fe111", "filename": "libgo/go/cmd/go/internal/mvs/mvs_test.go", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -29,7 +29,7 @@ D5: E2\n G1: C4\n A2: B1 C4 D4\n build A: A B1 C2 D4 E2 F1\n-upgrade* A: A B1 C4 D5 E2 G1\n+upgrade* A: A B1 C4 D5 E2 F1 G1\n upgrade A C4: A B1 C4 D4 E2 F1 G1\n downgrade A2 D2: A2 C4 D2\n \n@@ -38,7 +38,7 @@ A: B1 C2\n B1: D3\n C2: B2\n B2:\n-build A: A B2 C2\n+build A: A B2 C2 D3\n \n # Cross-dependency between D and E.\n # No matter how it arises, should get result of merging all build lists via max,\n@@ -157,22 +157,33 @@ D1: E2\n E1: D2\n build A: A B C D2 E2\n \n-# Upgrade from B1 to B2 should drop the transitive dep on D.\n+# golang.org/issue/31248:\n+# Even though we select X2, the requirement on I1\n+# via X1 should be preserved.\n+name: cross8\n+M: A1 B1\n+A1: X1\n+B1: X2\n+X1: I1\n+X2: \n+build M: M A1 B1 I1 X2\n+\n+# Upgrade from B1 to B2 should not drop the transitive dep on D.\n name: drop\n A: B1 C1\n B1: D1\n B2:\n C2:\n D2:\n build A: A B1 C1 D1\n-upgrade* A: A B2 C2\n+upgrade* A: A B2 C2 D2\n \n name: simplify\n A: B1 C1\n B1: C2\n C1: D1\n C2:\n-build A: A B1 C2\n+build A: A B1 C2 D1\n \n name: up1\n A: B1 C1\n@@ -254,8 +265,9 @@ build A: A B1\n upgrade A B2: A B2\n upgrade* A: A B3\n \n+# golang.org/issue/29773:\n # Requirements of older versions of the target\n-# must not be carried over.\n+# must be carried over.\n name: cycle2\n A: B1\n A1: C1\n@@ -265,8 +277,8 @@ B2: A2\n C1: A2\n C2:\n D2:\n-build A: A B1\n-upgrade* A: A B2\n+build A: A B1 C1 D1\n+upgrade* A: A B2 C2 D2\n \n # Requirement minimization.\n \n@@ -283,6 +295,14 @@ H1: G1\n req A: G1\n req A G: G1\n req A H: H1\n+\n+name: req3\n+M: A1 B1\n+A1: X1\n+B1: X2\n+X1: I1\n+X2: \n+req M: A1 B1\n `\n \n func Test(t *testing.T) {"}, {"sha": "95000011d83b48791350bd7316c782841576f6ca", "filename": "libgo/go/cmd/go/internal/test/test.go", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -843,7 +843,7 @@ func builderTest(b *work.Builder, p *load.Package) (buildAction, runAction, prin\n \tif !cfg.BuildN {\n \t\t// writeTestmain writes _testmain.go,\n \t\t// using the test description gathered in t.\n-\t\tif err := ioutil.WriteFile(testDir+\"_testmain.go\", pmain.Internal.TestmainGo, 0666); err != nil {\n+\t\tif err := ioutil.WriteFile(testDir+\"_testmain.go\", *pmain.Internal.TestmainGo, 0666); err != nil {\n \t\t\treturn nil, nil, nil, err\n \t\t}\n \t}\n@@ -1250,6 +1250,15 @@ func (c *runCache) tryCacheWithID(b *work.Builder, a *work.Action, id string) bo\n \t\treturn false\n \t}\n \n+\tif a.Package.Root == \"\" {\n+\t\t// Caching does not apply to tests outside of any module, GOPATH, or GOROOT.\n+\t\tif cache.DebugTest {\n+\t\t\tfmt.Fprintf(os.Stderr, \"testcache: caching disabled for package outside of module root, GOPATH, or GOROOT: %s\\n\", a.Package.ImportPath)\n+\t\t}\n+\t\tc.disableCache = true\n+\t\treturn false\n+\t}\n+\n \tvar cacheArgs []string\n \tfor _, arg := range testArgs {\n \t\ti := strings.Index(arg, \"=\")\n@@ -1437,17 +1446,17 @@ func computeTestInputsID(a *work.Action, testlog []byte) (cache.ActionID, error)\n \t\t\tif !filepath.IsAbs(name) {\n \t\t\t\tname = filepath.Join(pwd, name)\n \t\t\t}\n-\t\t\tif !inDir(name, a.Package.Root) {\n-\t\t\t\t// Do not recheck files outside the GOPATH or GOROOT root.\n+\t\t\tif a.Package.Root == \"\" || !inDir(name, a.Package.Root) {\n+\t\t\t\t// Do not recheck files outside the module, GOPATH, or GOROOT root.\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tfmt.Fprintf(h, \"stat %s %x\\n\", name, hashStat(name))\n \t\tcase \"open\":\n \t\t\tif !filepath.IsAbs(name) {\n \t\t\t\tname = filepath.Join(pwd, name)\n \t\t\t}\n-\t\t\tif !inDir(name, a.Package.Root) {\n-\t\t\t\t// Do not recheck files outside the GOPATH or GOROOT root.\n+\t\t\tif a.Package.Root == \"\" || !inDir(name, a.Package.Root) {\n+\t\t\t\t// Do not recheck files outside the module, GOPATH, or GOROOT root.\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tfh, err := hashOpen(name)"}, {"sha": "0e7deef1491a9c4d022ff0ff6b86341d4a7b0cb4", "filename": "libgo/go/cmd/go/internal/version/exe.go", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fexe.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fexe.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fexe.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -103,6 +103,11 @@ func (x *elfExe) ReadData(addr, size uint64) ([]byte, error) {\n }\n \n func (x *elfExe) DataStart() uint64 {\n+\tfor _, s := range x.f.Sections {\n+\t\tif s.Name == \".go.buildinfo\" {\n+\t\t\treturn s.Addr\n+\t\t}\n+\t}\n \tfor _, p := range x.f.Progs {\n \t\tif p.Type == elf.PT_LOAD && p.Flags&(elf.PF_X|elf.PF_W) == elf.PF_W {\n \t\t\treturn p.Vaddr\n@@ -208,7 +213,13 @@ func (x *machoExe) ReadData(addr, size uint64) ([]byte, error) {\n }\n \n func (x *machoExe) DataStart() uint64 {\n-\t// Assume data is first non-empty writable segment.\n+\t// Look for section named \"__go_buildinfo\".\n+\tfor _, sec := range x.f.Sections {\n+\t\tif sec.Name == \"__go_buildinfo\" {\n+\t\t\treturn sec.Addr\n+\t\t}\n+\t}\n+\t// Try the first non-empty writable segment.\n \tconst RW = 3\n \tfor _, load := range x.f.Loads {\n \t\tseg, ok := load.(*macho.Segment)"}, {"sha": "9305b2d859c549356f1e0739aeb2d9e7e29bc4e3", "filename": "libgo/go/cmd/go/internal/work/build.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -30,6 +30,8 @@ along with their dependencies, but it does not install the results.\n If the arguments to build are a list of .go files from a single directory,\n build treats them as a list of source files specifying a single package.\n \n+When compiling packages, build ignores files that end in '_test.go'.\n+\n When compiling a single main package, build writes\n the resulting executable to an output file named after\n the first source file ('go build ed.go rx.go' writes 'ed' or 'ed.exe')\n@@ -40,8 +42,6 @@ When compiling multiple packages or a single non-main package,\n build compiles the packages but discards the resulting object,\n serving only as a check that the packages can be built.\n \n-When compiling packages, build ignores files that end in '_test.go'.\n-\n The -o flag forces build to write the resulting executable or object\n to the named output file or directory, instead of the default behavior described\n in the last two paragraphs. If the named output is a directory that exists,"}, {"sha": "27bde8c6151e4a8df31173563ccfe1d2c8d42a53", "filename": "libgo/go/cmd/go/internal/work/buildid.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -203,8 +203,9 @@ func (b *Builder) toolID(name string) string {\n \t\t// On the development branch, use the content ID part of the build ID.\n \t\tid = contentID(f[len(f)-1])\n \t} else {\n-\t\t// For a release, the output is like: \"compile version go1.9.1\". Use the whole line.\n-\t\tid = f[2]\n+\t\t// For a release, the output is like: \"compile version go1.9.1 X:framepointer\".\n+\t\t// Use the whole line.\n+\t\tid = strings.TrimSpace(line)\n \t}\n \n \tb.id.Lock()"}, {"sha": "c666026213bf1a1a119655e9507783f70c870316", "filename": "libgo/go/cmd/go/internal/work/exec.go", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -542,15 +542,6 @@ func (b *Builder) build(a *Action) (err error) {\n \t\t}\n \t}\n \n-\t// Write out the _testinginit.go file for any test packages that import \"testing\".\n-\tif a.Package.Internal.TestinginitGo != nil {\n-\t\tinitfile := objdir + \"_testinginit.go\"\n-\t\tif err := b.writeFile(initfile, a.Package.Internal.TestinginitGo); err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tgofiles = append([]string{initfile}, gofiles...)\n-\t}\n-\n \t// Run cgo.\n \tif a.Package.UsesCgo() || a.Package.UsesSwig() {\n \t\t// In a package using cgo, cgo compiles the C, C++ and assembly files with gcc."}, {"sha": "ddf613d870126ca62b6402718b2f1e466c77e4af", "filename": "libgo/go/cmd/go/testdata/flag_test.go", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fflag_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fflag_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fflag_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -1,19 +1,16 @@\n-// Copyright 2019 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n package flag_test\n \n import (\n \t\"flag\"\n+\t\"log\"\n \t\"testing\"\n )\n \n var v = flag.Int(\"v\", 0, \"v flag\")\n \n-// Run this as go test pkg -args -v=7\n+// Run this as go test pkg -v=7\n func TestVFlagIsSet(t *testing.T) {\n \tif *v != 7 {\n-\t\tt.Fatal(\"v flag not set\")\n+\t\tlog.Fatal(\"v flag not set\")\n \t}\n }"}, {"sha": "36bc2c67266e0c7906e9fd4e7ba5964b3b1a328b", "filename": "libgo/go/cmd/go/testdata/mod/example.com_badchain_c_v1.1.0.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_badchain_c_v1.1.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_badchain_c_v1.1.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_badchain_c_v1.1.0.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -1,7 +1,7 @@\n example.com/badchain/c v1.1.0\n \n -- .mod --\n-module example.com/badchain/wrong\n+module badchain.example.com/c\n -- .info --\n {\"Version\":\"v1.1.0\"}\n -- c.go --"}, {"sha": "0d94bf61a9a3a772c27553de2cfa22bb16def539", "filename": "libgo/go/cmd/go/testdata/script/build_cache_output.txt", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_output.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_output.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_output.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -1,4 +1,5 @@\n env GO111MODULE=off\n+env GODEBUG=gocachetest=1\n \n [!gc] skip\n [short] skip # clears cache, rebuilds too much\n@@ -32,7 +33,7 @@ stderr 'main.go:2.* can inline main' # from compiler\n stderr '\\d+ symbols' # from linker\n \n # Running a test should run the compiler, linker, and the test the first time.\n-go test -v -x -gcflags=-m -ldflags=-v p_test.go\n+go test -v -x -gcflags=-m -ldflags=-v p\n stderr 'compile( |\\.exe\"?)'\n stderr 'p_test.go:.*can inline Test' # from compile of p_test\n stderr 'testmain\\.go:.*inlin' # from compile of testmain\n@@ -42,7 +43,7 @@ stderr 'p\\.test( |\\.exe\"?)'\n stdout 'TEST' # from test\n \n # ... but not the second, even though it still prints the compiler, linker, and test output.\n-go test -v -x -gcflags=-m -ldflags=-v p_test.go\n+go test -v -x -gcflags=-m -ldflags=-v p\n ! stderr 'compile( |\\.exe\"?)'\n stderr 'p_test.go:.*can inline Test' # from compile of p_test\n stderr 'testmain\\.go:.*inlin' # from compile of testmain\n@@ -60,7 +61,7 @@ func f(x *int) *int { return x }\n package main\n func main() {}\n \n--- p_test.go --\n+-- p/p_test.go --\n package p\n import \"testing\"\n func Test(t *testing.T) {println(\"TEST\")}"}, {"sha": "ba94f9bd3eb25cdf4cf59fd542d0b620dc73ce7a", "filename": "libgo/go/cmd/go/testdata/script/cmd_import_error.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcmd_import_error.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcmd_import_error.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcmd_import_error.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -0,0 +1,16 @@\n+env GO111MODULE=on\n+\n+# Regression test for golang.org/issue/31031:\n+# Importing or loading a non-existent package in cmd/ should print\n+# a clear error in module mode.\n+\n+! go list cmd/unknown\n+stderr '^can''t load package: package cmd/unknown: package cmd/unknown is not in GOROOT \\('$GOROOT'[/\\\\]src[/\\\\]cmd[/\\\\]unknown\\)$'\n+\n+go list -f '{{range .DepsErrors}}{{.Err}}{{end}}' x.go\n+stdout '^package cmd/unknown is not in GOROOT \\('$GOROOT'[/\\\\]src[/\\\\]cmd[/\\\\]unknown\\)$'\n+\n+-- x.go --\n+package x\n+\n+import _ \"cmd/unknown\""}, {"sha": "d7aa553c1d3ba16428c0190d8f5d8251142573bf", "filename": "libgo/go/cmd/go/testdata/script/mod_doc.txt", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_doc.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_doc.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_doc.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -3,6 +3,7 @@\n env GO111MODULE=on\n [short] skip\n \n+# Check when module x is inside GOPATH/src.\n go doc y\n stdout 'Package y is.*alphabet'\n stdout 'import \"x/y\"'\n@@ -16,13 +17,25 @@ stdout 'Hello returns a greeting'\n go doc quote\n stdout 'Package quote collects pithy sayings.'\n \n-# Double-check go doc y when y is not in GOPATH/src.\n-env GOPATH=$WORK/altgopath\n+# Double-check when module x is outside GOPATH/src.\n+env GOPATH=$WORK/emptygopath\n go doc x/y\n stdout 'Package y is.*alphabet'\n go doc y\n stdout 'Package y is.*alphabet'\n \n+# Triple-check when module x is outside GOPATH/src,\n+# but other packages with same import paths are in GOPATH/src.\n+# Since go doc is running in module mode here, packages in active module\n+# should be preferred over packages in GOPATH. See golang.org/issue/28992.\n+env GOPATH=$WORK/gopath2\n+go doc x/y\n+! stdout 'Package y is.*GOPATH'\n+stdout 'Package y is.*alphabet'\n+go doc rsc.io/quote\n+! stdout 'Package quote is located in a GOPATH workspace.'\n+stdout 'Package quote collects pithy sayings.'\n+\n -- go.mod --\n module x\n require rsc.io/quote v1.5.2\n@@ -33,3 +46,13 @@ package y\n \n -- x.go --\n package x\n+\n+-- $WORK/gopath2/src/x/y/y.go --\n+// Package y is located in a GOPATH workspace.\n+package y\n+-- $WORK/gopath2/src/rsc.io/quote/quote.go --\n+// Package quote is located in a GOPATH workspace.\n+package quote\n+\n+// Hello is located in a GOPATH workspace.\n+func Hello() string { return \"\" }"}, {"sha": "c90074d0a6b4e23133191287a0877dc020b22dac", "filename": "libgo/go/cmd/go/testdata/script/mod_dot.txt", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_dot.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_dot.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_dot.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -0,0 +1,36 @@\n+env GO111MODULE=on\n+\n+# golang.org/issue/32917 and golang.org/issue/28459: 'go build' and 'go test'\n+# in an empty directory should refer to the path '.' and should not attempt\n+# to resolve an external module.\n+cd dir\n+! go get .\n+stderr 'go get \\.: path .* is not a package in module rooted at .*[/\\\\]dir$'\n+! go list\n+! stderr 'cannot find module providing package'\n+stderr '^can.t load package: package \\.: no Go files in '$WORK'[/\\\\]gopath[/\\\\]src[/\\\\]dir$'\n+\n+cd subdir\n+! go list\n+! stderr 'cannot find module providing package'\n+stderr '^can.t load package: package \\.: no Go files in '$WORK'[/\\\\]gopath[/\\\\]src[/\\\\]dir[/\\\\]subdir$'\n+cd ..\n+\n+# golang.org/issue/30590: if a package is found in the filesystem\n+# but is not in the main module, the error message should not say\n+# \"cannot find module providing package\", and we shouldn't try\n+# to find a module providing the package.\n+! go list ./othermodule\n+! stderr 'cannot find module providing package'\n+stderr 'go: directory othermodule is outside main module'\n+\n+-- dir/go.mod --\n+module example.com\n+go 1.13\n+-- dir/subdir/README --\n+There are no Go source files in this directory.\n+-- dir/othermodule/go.mod --\n+module example.com/othermodule\n+go 1.13\n+-- dir/othermodule/om.go --\n+package othermodule"}, {"sha": "9eb3140c3328a00b0ac87732ad264059044fd6c3", "filename": "libgo/go/cmd/go/testdata/script/mod_download.txt", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -17,6 +17,7 @@ stderr 'this.domain.is.invalid'\n stdout '\"Error\": \".*this.domain.is.invalid.*\"'\n \n # download -json with version should print JSON\n+# and download the .info file for the 'latest' version.\n go mod download -json 'rsc.io/quote@<=v1.5.0'\n stdout '^\\t\"Path\": \"rsc.io/quote\"'\n stdout '^\\t\"Version\": \"v1.5.0\"'\n@@ -27,13 +28,14 @@ stdout '^\\t\"Sum\": \"h1:6fJa6E\\+wGadANKkUMlZ0DhXFpoKlslOQDCo259XtdIE=\"'  # hash of\n stdout '^\\t\"GoModSum\": \"h1:LzX7hefJvL54yjefDEDHNONDjII0t9xZLPXsUe\\+TKr0=\"'\n ! stdout '\"Error\"'\n \n+exists $GOPATH/pkg/mod/cache/download/rsc.io/quote/@v/v1.5.2.info\n+\n # download queries above should not have added to go.mod.\n go list -m all\n ! stdout rsc.io\n \n # add to go.mod so we can test non-query downloads\n go mod edit -require rsc.io/quote@v1.5.2\n-! exists $GOPATH/pkg/mod/cache/download/rsc.io/quote/@v/v1.5.2.info\n ! exists $GOPATH/pkg/mod/cache/download/rsc.io/quote/@v/v1.5.2.mod\n ! exists $GOPATH/pkg/mod/cache/download/rsc.io/quote/@v/v1.5.2.zip\n \n@@ -83,6 +85,16 @@ exists $GOPATH/pkg/mod/cache/download/rsc.io/quote/@v/v1.5.3-pre1.zip\n go mod download -json rsc.io/quote@v1.5.1\n exists $GOPATH/pkg/mod/cache/download/rsc.io/quote/@v/v1.5.1.zip\n \n+# download reports errors encountered when locating modules\n+! go mod download bad/path\n+stderr '^module bad/path: not a known dependency$'\n+! go mod download bad/path@latest\n+stderr '^bad/path@latest: malformed module path \"bad/path\": missing dot in first path element$'\n+! go mod download rsc.io/quote@v1.999.999\n+stderr '^rsc.io/quote@v1.999.999: reading .*/v1.999.999.info: 404 Not Found$'\n+! go mod download -json bad/path\n+stdout '^\\t\"Error\": \"module bad/path: not a known dependency\"'\n+\n # allow go mod download without go.mod\n env GO111MODULE=auto\n rm go.mod"}, {"sha": "60d860e4da49708d979ae9c41d7fb13f0ea26f12", "filename": "libgo/go/cmd/go/testdata/script/mod_download_latest.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_latest.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_latest.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_latest.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -0,0 +1,20 @@\n+env GO111MODULE=on\n+\n+# If the module is the latest version of itself,\n+# the Latest field should be set.\n+go mod download -json rsc.io/quote@v1.5.2\n+stdout '\"Latest\":\\s*true'\n+\n+# If the module is older than latest, the field should be unset.\n+go mod download -json rsc.io/quote@v1.5.1\n+! stdout '\"Latest\":'\n+\n+# If the module is newer than \"latest\", the field should be unset...\n+go mod download -json rsc.io/quote@v1.5.3-pre1\n+! stdout '\"Latest\":'\n+\n+# ...even if that version is also what is required by the main module.\n+go mod init example.com\n+go mod edit -require rsc.io/quote@v1.5.3-pre1\n+go mod download -json rsc.io/quote@v1.5.3-pre1\n+! stdout '\"Latest\":'"}, {"sha": "fd7de13002410325e21975c4cc3e32051309709b", "filename": "libgo/go/cmd/go/testdata/script/mod_fs_patterns.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_fs_patterns.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_fs_patterns.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_fs_patterns.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -34,11 +34,11 @@ stderr 'import lookup disabled'\n \n ! go build -mod=readonly ./nonexist\n ! stderr 'import lookup disabled'\n-stderr 'unknown import path \"m/nonexist\": cannot find package'\n+stderr '^can.t load package: package ./nonexist: cannot find package \".\" in:\\n\\t'$WORK'[/\\\\]gopath[/\\\\]src[/\\\\]x[/\\\\]nonexist$'\n \n ! go build -mod=readonly ./go.mod\n ! stderr 'import lookup disabled'\n-stderr 'unknown import path \"m/go.mod\": cannot find package'\n+stderr 'can.t load package: package ./go.mod: cannot find package'\n \n -- x/go.mod --\n module m"}, {"sha": "a9834a324e249ae8ad19b37cfb4c55b28d657e26", "filename": "libgo/go/cmd/go/testdata/script/mod_get_fallback.txt", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_fallback.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_fallback.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_fallback.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -0,0 +1,10 @@\n+env GO111MODULE=on\n+\n+[!net] skip\n+\n+env GOPROXY=https://proxy.golang.org,direct\n+env GOSUMDB=off\n+\n+go get -x -v -d golang.org/x/tools/cmd/goimports\n+stderr '# get https://proxy.golang.org/golang.org/x/tools/@latest'\n+! stderr '# get https://golang.org'"}, {"sha": "403abcd28ba454cd03658f9572c95562fad87629", "filename": "libgo/go/cmd/go/testdata/script/mod_get_main.txt", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_main.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_main.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_main.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -4,13 +4,19 @@ env GO111MODULE=on\n # @patch and @latest within the main module refer to the current version.\n # The main module won't be upgraded, but missing dependencies will be added.\n cp go.mod.orig go.mod\n-go get -d rsc.io/x@latest\n+go get -d rsc.io/x\n+grep 'rsc.io/quote v1.5.2' go.mod\n+go get -d rsc.io/x@upgrade\n grep 'rsc.io/quote v1.5.2' go.mod\n cp go.mod.orig go.mod\n go get -d rsc.io/x@patch\n grep 'rsc.io/quote v1.5.2' go.mod\n cp go.mod.orig go.mod\n \n+# The main module cannot be updated to @latest, which is a specific version.\n+! go get -d rsc.io/x@latest\n+stderr '^go get rsc.io/x@latest: can.t request explicit version of path in main module$'\n+\n # The main module cannot be updated to a specific version.\n ! go get rsc.io/x@v0.1.0\n stderr '^go get rsc.io/x@v0.1.0: can.t request explicit version of path in main module$'"}, {"sha": "b1838f824a6353aa3e6f0c89cd2c614bf8a71c5c", "filename": "libgo/go/cmd/go/testdata/script/mod_get_newcycle.txt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_newcycle.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_newcycle.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_newcycle.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -1,6 +1,7 @@\n env GO111MODULE=on\n \n # Download modules to avoid stderr chatter\n+go mod download example.com@v1.0.0\n go mod download example.com/newcycle/a@v1.0.0\n go mod download example.com/newcycle/a@v1.0.1\n go mod download example.com/newcycle/b@v1.0.0\n@@ -10,5 +11,6 @@ go mod init m\n cmp stderr stderr-expected\n \n -- stderr-expected --\n+go: finding example.com/newcycle v1.0.0\n go get: inconsistent versions:\n \texample.com/newcycle/a@v1.0.0 requires example.com/newcycle/a@v1.0.1 (not example.com/newcycle/a@v1.0.0)"}, {"sha": "bfab70090cfaaa661bbb29f9f4535ff58d6d7997", "filename": "libgo/go/cmd/go/testdata/script/mod_get_patterns.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_patterns.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_patterns.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_patterns.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -10,11 +10,11 @@ grep 'require rsc.io/quote' go.mod\n \n cp go.mod.orig go.mod\n ! go get -d rsc.io/quote/x...\n-stderr 'go get rsc.io/quote/x...: module rsc.io/quote@latest \\(v1.5.2\\) found, but does not contain packages matching rsc.io/quote/x...'\n+stderr 'go get rsc.io/quote/x...: module rsc.io/quote@upgrade \\(v1.5.2\\) found, but does not contain packages matching rsc.io/quote/x...'\n ! grep 'require rsc.io/quote' go.mod\n \n ! go get -d rsc.io/quote/x/...\n-stderr 'go get rsc.io/quote/x/...: module rsc.io/quote@latest \\(v1.5.2\\) found, but does not contain packages matching rsc.io/quote/x/...'\n+stderr 'go get rsc.io/quote/x/...: module rsc.io/quote@upgrade \\(v1.5.2\\) found, but does not contain packages matching rsc.io/quote/x/...'\n ! grep 'require rsc.io/quote' go.mod\n \n # If a pattern matches no packages within a module, the module should not"}, {"sha": "cd19d99dbccbbf27076af73c02b417118291ebc2", "filename": "libgo/go/cmd/go/testdata/script/mod_get_svn.txt", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_svn.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_svn.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_svn.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -2,19 +2,26 @@\n [!exec:svn] skip\n \n env GO111MODULE=on\n-env GOPROXY=direct # obtain llvm.org directory, not via svn.\n+env GOPROXY=direct\n+env GOSUMDB=off\n \n # Attempting to get a module zip using svn should fail with a reasonable\n # message instead of a panic.\n # TODO(golang.org/issue/26092): Really, it shouldn't fail at all.\n-! go get -d llvm.org/llvm/bindings/go/llvm\n+! go get -d vcs-test.golang.org/svn/hello.svn\n stderr 'ReadZip not implemented for svn'\n ! go install .\n stderr 'ReadZip not implemented for svn'\n \n+# Attempting to get a nonexistent module using svn should fail with a\n+# reasonable message instead of a panic.\n+! go get -d vcs-test.golang.org/svn/nonexistent.svn\n+! stderr panic\n+stderr 'go get vcs-test.golang.org/svn/nonexistent.svn: no matching versions for query \"upgrade\"'\n+\n -- go.mod --\n module golang/go/issues/28943/main\n -- main.go --\n package main\n-import _ \"llvm.org/llvm/bindings/go/llvm\"\n+import _ \"vcs-test.golang.org/svn/hello.svn\"\n func main() {}"}, {"sha": "f5f415aa3fae25e66ec10e62a04469c14c115157", "filename": "libgo/go/cmd/go/testdata/script/mod_get_upgrade_pseudo.txt", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_upgrade_pseudo.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_upgrade_pseudo.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_upgrade_pseudo.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -9,18 +9,33 @@ env GO111MODULE=on\n # The v0.1.1 pseudo-version is semantically higher than the latest tag.\n # The v0.0.0 pseudo-version is chronologically newer.\n \n-# 'get -u' should not downgrade to the (lower) tagged version.\n+# Start at v0.1.1-0.20190429073117-b5426c86b553\n go get -d example.com/pseudoupgrade@b5426c8\n+go list -m -u all\n+stdout '^example.com/pseudoupgrade v0.1.1-0.20190429073117-b5426c86b553$'\n+\n+# 'get -u' should not downgrade to the (lower) tagged version.\n go get -d -u\n go list -m -u all\n stdout '^example.com/pseudoupgrade v0.1.1-0.20190429073117-b5426c86b553$'\n \n-# 'get example.com/pseudoupgrade@latest' should not downgrade to\n-# the (lower) tagged version.\n-go get -d example.com/pseudoupgrade@latest\n+# 'get example.com/pseudoupgrade@upgrade' should not downgrade.\n+go get -d example.com/pseudoupgrade@upgrade\n go list -m all\n stdout '^example.com/pseudoupgrade v0.1.1-0.20190429073117-b5426c86b553$'\n \n+# 'get example.com/pseudoupgrade' should not downgrade.\n+# This is equivalent to 'get example.com/pseudoupgrade@upgrade'.\n+go get -d example.com/pseudoupgrade\n+go list -m all\n+stdout '^example.com/pseudoupgrade v0.1.1-0.20190429073117-b5426c86b553$'\n+\n+# 'get example.com/pseudoupgrade@latest' should downgrade.\n+# @latest should not consider the current version.\n+go get -d example.com/pseudoupgrade@latest\n+go list -m all\n+stdout '^example.com/pseudoupgrade v0.1.0$'\n+\n # We should observe the same behavior with the newer pseudo-version.\n go get -d example.com/pseudoupgrade@v0.0.0-20190430073000-30950c05d534\n \n@@ -29,12 +44,21 @@ go get -d -u\n go list -m -u all\n stdout '^example.com/pseudoupgrade v0.0.0-20190430073000-30950c05d534$'\n \n-# 'get example.com/pseudoupgrade@latest' should not downgrade to the\n-# chronologically older tagged version.\n-go get -d example.com/pseudoupgrade@latest\n+# 'get example.com/pseudoupgrade@upgrade should not downgrade.\n+go get -d example.com/pseudoupgrade@upgrade\n go list -m -u all\n stdout '^example.com/pseudoupgrade v0.0.0-20190430073000-30950c05d534$'\n \n+# 'get example.com/pseudoupgrade' should not downgrade.\n+go get -d example.com/pseudoupgrade\n+go list -m -u all\n+stdout '^example.com/pseudoupgrade v0.0.0-20190430073000-30950c05d534$'\n+\n+# 'get example.com/pseudoupgrade@latest' should downgrade.\n+go get -d example.com/pseudoupgrade@latest\n+go list -m -u all\n+stdout '^example.com/pseudoupgrade v0.1.0$'\n+\n -- go.mod --\n module x\n "}, {"sha": "ae05250c5f695bfe80e914d0994cf319ad6dacc4", "filename": "libgo/go/cmd/go/testdata/script/mod_gobuild_import.txt", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_gobuild_import.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_gobuild_import.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_gobuild_import.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -62,15 +62,31 @@ import (\n \t\"go/build\"\n \t\"log\"\n \t\"os\"\n+\t\"path/filepath\"\n \t\"strings\"\n )\n \n func main() {\n-\tp, err := build.Import(os.Args[1], os.Args[2], 0)\n+\t// build.Import should support relative and absolute source dir paths.\n+\tpath := os.Args[1]\n+\tsrcDir := os.Args[2]\n+\tp1, err := build.Import(path, srcDir, 0)\n \tif err != nil {\n \t\tlog.Fatal(err)\n \t}\n-\tfmt.Printf(\"%s\\n%s\\n\", p.Dir, strings.Join(p.GoFiles, \" \"))\n+\tabsSrcDir, err := filepath.Abs(srcDir)\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\tp2, err := build.Import(path, absSrcDir, 0)\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\tif p1.Dir != p2.Dir {\n+\t\tlog.Fatalf(\"different packages loaded with relative and absolute paths:\\n\\t%s\\n\\t%s\", p1.Dir, p2.Dir)\n+\t}\n+\n+\tfmt.Printf(\"%s\\n%s\\n\", p1.Dir, strings.Join(p1.GoFiles, \" \"))\n }\n \n -- $GOPATH/other/go.mod --"}, {"sha": "87a3f0b10f741136499a64e1e0913e33d346364a", "filename": "libgo/go/cmd/go/testdata/script/mod_indirect.txt", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_indirect.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_indirect.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_indirect.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -0,0 +1,81 @@\n+env GO111MODULE=on\n+\n+# golang.org/issue/31248: module requirements imposed by dependency versions\n+# older than the selected version must still be taken into account.\n+\n+env GOFLAGS=-mod=readonly\n+\n+# Indirect dependencies required via older-than-selected versions must exist in\n+# the module graph, but do not need to be listed explicitly in the go.mod file\n+# (since they are implied).\n+go mod graph\n+stdout i@v0.1.0\n+\n+# The modules must also appear in the build list, not just the graph.\n+go list -m all\n+stdout '^i v0.1.0'\n+\n+# The packages provided by those dependencies must resolve.\n+go list all\n+stdout '^i$'\n+\n+-- go.mod --\n+module main\n+\n+go 1.13\n+\n+require (\n+\ta v0.0.0\n+\tb v0.0.0\n+\tc v0.0.0\n+)\n+\n+// Apply replacements so that the test can be self-contained.\n+// (It's easier to see all of the modules here than to go\n+// rooting around in testdata/mod.)\n+replace (\n+\ta => ./a\n+\tb => ./b\n+\tc => ./c\n+\tx v0.1.0 => ./x1\n+\tx v0.2.0 => ./x2\n+\ti => ./i\n+)\n+-- main.go --\n+package main\n+\n+import (\n+\t_ \"a\"\n+\t_ \"b\"\n+\t_ \"c\"\n+)\n+\n+func main() {}\n+-- a/go.mod --\n+module a\n+go 1.13\n+require x v0.1.0\n+-- a/a.go --\n+package a\n+-- b/go.mod --\n+module b\n+go 1.13\n+require x v0.2.0\n+-- b/b.go --\n+package b\n+-- c/go.mod --\n+module c\n+go 1.13\n+-- c/c.go --\n+package c\n+import _ \"i\"\n+-- x1/go.mod --\n+module x\n+go1.13\n+require i v0.1.0\n+-- x2/go.mod --\n+module x\n+go1.13\n+-- i/go.mod --\n+-- i/i.go --\n+package i"}, {"sha": "eeb93f19136753283c2e3bc05fc17d0b13f178ee", "filename": "libgo/go/cmd/go/testdata/script/mod_indirect_main.txt", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_indirect_main.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_indirect_main.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_indirect_main.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -0,0 +1,65 @@\n+env GO111MODULE=on\n+\n+# Regression test for golang.org/issue/29773: 'go list -m' was not following\n+# dependencies through older versions of the main module.\n+\n+go list -f '{{with .Module}}{{.Path}}{{with .Version}} {{.}}{{end}}{{end}}' all\n+cmp stdout pkgmods.txt\n+\n+go list -m all\n+cmp stdout mods.txt\n+\n+go mod graph\n+cmp stdout graph.txt\n+\n+-- go.mod --\n+module golang.org/issue/root\n+\n+go 1.12\n+\n+replace (\n+\tgolang.org/issue/mirror v0.1.0 => ./mirror-v0.1.0\n+\tgolang.org/issue/pkg v0.1.0 => ./pkg-v0.1.0\n+\tgolang.org/issue/root v0.1.0 => ./root-v0.1.0\n+)\n+\n+require golang.org/issue/mirror v0.1.0\n+\n+-- root.go --\n+package root\n+\n+import _ \"golang.org/issue/mirror\"\n+\n+-- mirror-v0.1.0/go.mod --\n+module golang.org/issue/mirror\n+\n+require golang.org/issue/root v0.1.0\n+\n+-- mirror-v0.1.0/mirror.go --\n+package mirror\n+\n+import _ \"golang.org/issue/pkg\"\n+\n+-- pkg-v0.1.0/go.mod --\n+module golang.org/issue/pkg\n+\n+-- pkg-v0.1.0/pkg.go --\n+package pkg\n+\n+-- root-v0.1.0/go.mod --\n+module golang.org/issue/root\n+\n+require golang.org/issue/pkg v0.1.0\n+\n+-- pkgmods.txt --\n+golang.org/issue/mirror v0.1.0\n+golang.org/issue/pkg v0.1.0\n+golang.org/issue/root\n+-- mods.txt --\n+golang.org/issue/root\n+golang.org/issue/mirror v0.1.0 => ./mirror-v0.1.0\n+golang.org/issue/pkg v0.1.0 => ./pkg-v0.1.0\n+-- graph.txt --\n+golang.org/issue/root golang.org/issue/mirror@v0.1.0\n+golang.org/issue/mirror@v0.1.0 golang.org/issue/root@v0.1.0\n+golang.org/issue/root@v0.1.0 golang.org/issue/pkg@v0.1.0"}, {"sha": "a12b35c72b1824e3a9f8251f71399b04a7d067a8", "filename": "libgo/go/cmd/go/testdata/script/mod_indirect_tidy.txt", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_indirect_tidy.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_indirect_tidy.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_indirect_tidy.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -0,0 +1,60 @@\n+env GO111MODULE=on\n+\n+# golang.org/issue/31248: loading the build list must not add explicit entries\n+# for indirect dependencies already implied by older-than-selected versions\n+# already in the build list.\n+\n+cp go.mod.orig go.mod\n+go mod tidy\n+cmp go.mod go.mod.orig\n+\n+cp go.mod.orig go.mod\n+go list -m all\n+cmp go.mod go.mod.orig\n+\n+-- go.mod.orig --\n+module main\n+\n+go 1.13\n+\n+require a v0.0.0\n+\n+replace (\n+\ta v0.0.0 => ./a\n+\tb v0.0.0 => ./b\n+\ti v0.0.0 => ./i\n+\tx v0.1.0 => ./x1\n+\tx v0.2.0 => ./x2\n+)\n+-- main.go --\n+package main\n+\n+import _ \"a\"\n+\n+func main() {}\n+-- a/go.mod --\n+module a\n+go 1.13\n+require (\n+\tx v0.2.0\n+\tb v0.0.0\n+)\n+-- a/a.go --\n+package a\n+-- b/go.mod --\n+module b\n+go 1.13\n+require x v0.1.0\n+-- x1/go.mod --\n+module x\n+go 1.13\n+require (\n+\tb v0.0.0\n+\ti v0.0.0\n+)\n+-- x2/go.mod --\n+module x\n+go 1.13\n+-- i/go.mod --\n+module i\n+go 1.13"}, {"sha": "76e0b43a735e47ffd6411771660c2fd6841538ae", "filename": "libgo/go/cmd/go/testdata/script/mod_invalid_version.txt", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_invalid_version.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_invalid_version.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_invalid_version.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -134,6 +134,19 @@ cd ..\n go list -m golang.org/x/text\n stdout 'golang.org/x/text v0.0.0-0.20170915032832-14c0d48ead0c => golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c'\n \n+# A 'replace' directive can replace an invalid 'latest' version, and\n+# should suppress errors for that version in 'go get -u'\n+cp go.mod.orig go.mod\n+go mod edit -require golang.org/x/text@v1.999999.0\n+go mod edit -replace golang.org/x/text@v1.999999.0=golang.org/x/text@v0.0.0-20170915032832-14c0d48ead0c\n+cd outside\n+! go get -d golang.org/x/text@upgrade\n+stderr 'go: example.com@v0.0.0 requires\\n\\tgolang.org/x/text@v1.999999.0: reading golang.org/x/text/go.mod at revision v1.999999.0: unknown revision v1.999999.0'\n+cd ..\n+go get -d golang.org/x/text@upgrade\n+go list -m golang.org/x/text\n+stdout 'golang.org/x/text v1.999999.0 => golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c'\n+\n # A pseudo-version derived from a non-ancestor tag is invalid.\n cp go.mod.orig go.mod\n go mod edit -require golang.org/x/text@v0.2.1-0.20170915032832-14c0d48ead0c\n@@ -144,6 +157,16 @@ cd ..\n ! go list -m golang.org/x/text\n stderr 'golang.org/x/text@v0.2.1-0.20170915032832-14c0d48ead0c: invalid pseudo-version: revision 14c0d48ead0c is not a descendent of preceding tag \\(v0.2.0\\)'\n \n+# A pseudo-version derived from a canonical tag on the same revision is invalid.\n+cp go.mod.orig go.mod\n+go mod edit -require golang.org/x/text@v0.2.1-0.20171213102548-c4d099d611ac\n+cd outside\n+! go list -m golang.org/x/text\n+stderr 'go: example.com@v0.0.0 requires\\n\\tgolang.org/x/text@v0.2.1-0.20171213102548-c4d099d611ac: invalid pseudo-version: tag \\(v0.2.0\\) found on revision c4d099d611ac is already canonical, so should not be replaced with a pseudo-version derived from that tag'\n+cd ..\n+! go list -m golang.org/x/text\n+stderr 'golang.org/x/text@v0.2.1-0.20171213102548-c4d099d611ac: invalid pseudo-version: tag \\(v0.2.0\\) found on revision c4d099d611ac is already canonical, so should not be replaced with a pseudo-version derived from that tag'\n+\n # A +incompatible suffix is not allowed on a version that is actually compatible.\n cp go.mod.orig go.mod\n go mod edit -require golang.org/x/text@v0.1.1-0.20170915032832-14c0d48ead0c+incompatible\n@@ -165,15 +188,15 @@ go list -m github.com/pierrec/lz4\n stdout 'github.com/pierrec/lz4 v1.0.2-0.20190131084431-473cd7ce01a1'\n cd ..\n \n-# A +incompatible version for a module that has an explicit go.mod file is invalid.\n+# A +incompatible pseudo-version for a module that has an explicit go.mod file is invalid.\n cp go.mod.orig go.mod\n-go mod edit -require github.com/pierrec/lz4@v2.0.9-0.20190131084431-473cd7ce01a1+incompatible\n+go mod edit -require github.com/pierrec/lz4@v2.0.9-0.20190209155647-9a39efadad3d+incompatible\n cd outside\n ! go list -m github.com/pierrec/lz4\n-stderr 'go: example.com@v0.0.0 requires\\n\\tgithub.com/pierrec/lz4@v2.0.9-0.20190131084431-473cd7ce01a1\\+incompatible: invalid version: \\+incompatible suffix not allowed: module contains a go.mod file, so semantic import versioning is required'\n+stderr 'go: example.com@v0.0.0 requires\\n\\tgithub.com/pierrec/lz4@v2.0.9-0.20190209155647-9a39efadad3d\\+incompatible: invalid version: \\+incompatible suffix not allowed: module contains a go.mod file, so semantic import versioning is required'\n cd ..\n ! go list -m github.com/pierrec/lz4\n-stderr 'github.com/pierrec/lz4@v2.0.9-0.20190131084431-473cd7ce01a1\\+incompatible: invalid version: \\+incompatible suffix not allowed: module contains a go.mod file, so semantic import versioning is required'\n+stderr 'github.com/pierrec/lz4@v2.0.9-0.20190209155647-9a39efadad3d\\+incompatible: invalid version: \\+incompatible suffix not allowed: module contains a go.mod file, so semantic import versioning is required'\n \n # A +incompatible pseudo-version is valid for a revision of the module\n # that lacks a go.mod file."}, {"sha": "17b33fcc7bf36d22c2cb0ce40868269a9a1675eb", "filename": "libgo/go/cmd/go/testdata/script/mod_list.txt", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -34,12 +34,12 @@ go list rsc.io/quote/buggy\n \n # rsc.io/quote/buggy should not be listable as a module\n go list -m -e -f '{{.Error.Err}}' nonexist rsc.io/quote/buggy\n-stdout '^module \"nonexist\" is not a known dependency'\n-stdout '^module \"rsc.io/quote/buggy\" is not a known dependency'\n+stdout '^module nonexist: not a known dependency$'\n+stdout '^module rsc.io/quote/buggy: not a known dependency$'\n \n ! go list -m nonexist rsc.io/quote/buggy\n-stderr '^go list -m nonexist: module \"nonexist\" is not a known dependency'\n-stderr '^go list -m rsc.io/quote/buggy: module \"rsc.io/quote/buggy\" is not a known dependency'\n+stderr '^go list -m: module nonexist: not a known dependency'\n+stderr '^go list -m: module rsc.io/quote/buggy: not a known dependency'\n \n # Module loader does not interfere with list -e (golang.org/issue/24149).\n go list -e -f '{{.Error.Err}}' database"}, {"sha": "b08713dcfd793fc9523f58b1caa2aefe846555a5", "filename": "libgo/go/cmd/go/testdata/script/mod_list_compiled_concurrent.txt", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_compiled_concurrent.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_compiled_concurrent.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_compiled_concurrent.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -0,0 +1,41 @@\n+env GO111MODULE=on\n+\n+[short] skip\n+\n+# Regression test for golang.org/issue/29667:\n+# spurious 'failed to cache compiled Go files' errors.\n+# This test failed reliably when run with -count=10\n+# on a Linux workstation.\n+\n+env GOCACHE=$WORK/gocache\n+mkdir $GOCACHE\n+\n+go list -json -compiled -test=false -export=false -deps=true -- . &\n+go list -json -compiled -test=false -export=false -deps=true -- . &\n+go list -json -compiled -test=false -export=false -deps=true -- . &\n+go list -json -compiled -test=false -export=false -deps=true -- . &\n+go list -json -compiled -test=false -export=false -deps=true -- . &\n+go list -json -compiled -test=false -export=false -deps=true -- . &\n+go list -json -compiled -test=false -export=false -deps=true -- . &\n+go list -json -compiled -test=false -export=false -deps=true -- . &\n+go list -json -compiled -test=false -export=false -deps=true -- . &\n+go list -json -compiled -test=false -export=false -deps=true -- . &\n+go list -json -compiled -test=false -export=false -deps=true -- . &\n+go list -json -compiled -test=false -export=false -deps=true -- . &\n+go list -json -compiled -test=false -export=false -deps=true -- . &\n+go list -json -compiled -test=false -export=false -deps=true -- . &\n+go list -json -compiled -test=false -export=false -deps=true -- . &\n+go list -json -compiled -test=false -export=false -deps=true -- . &\n+go list -json -compiled -test=false -export=false -deps=true -- . &\n+go list -json -compiled -test=false -export=false -deps=true -- . &\n+go list -json -compiled -test=false -export=false -deps=true -- . &\n+go list -json -compiled -test=false -export=false -deps=true -- . &\n+\n+wait\n+\n+-- go.mod --\n+module sandbox/bar\n+-- bar.go --\n+package bar\n+\n+import \"C\""}, {"sha": "a8023cce9c5b787c20e5e3b6501c82c3d09f52bb", "filename": "libgo/go/cmd/go/testdata/script/mod_list_dir.txt", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_dir.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_dir.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_dir.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -12,9 +12,10 @@ stdout ^math$\n go list -f '{{.ImportPath}}' .\n stdout ^x$\n ! go list -f '{{.ImportPath}}' $GOPATH/pkg/mod/rsc.io/quote@v1.5.2\n-stderr 'unknown import path \"rsc.io/quote\": cannot find package'\n+stderr '^can.t load package: package '$WORK'[/\\\\]gopath/pkg/mod/rsc.io/quote@v1.5.2: can only use path@version syntax with .go get.'\n+\n go list -e -f '{{with .Error}}{{.}}{{end}}' $GOPATH/pkg/mod/rsc.io/quote@v1.5.2\n-stdout 'unknown import path \"rsc.io/quote\": cannot find package'\n+stdout '^package '$WORK'[/\\\\]gopath/pkg/mod/rsc.io/quote@v1.5.2: can only use path@version syntax with .go get.'\n go mod download rsc.io/quote@v1.5.2\n go list -f '{{.ImportPath}}' $GOPATH/pkg/mod/rsc.io/quote@v1.5.2\n stdout '^rsc.io/quote$'"}, {"sha": "8f858711897031db58c08c194c6db37bd1d9e50c", "filename": "libgo/go/cmd/go/testdata/script/mod_list_direct.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_direct.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_direct.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_direct.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -0,0 +1,24 @@\n+env GO111MODULE=on\n+env GOPROXY=direct\n+env GOSUMDB=off\n+\n+[!net] skip\n+[!exec:git] skip\n+\n+# golang.org/issue/33099: if an import path ends in a major-version suffix,\n+# ensure that 'direct' mode can resolve the package to the module.\n+# For a while, (*modfetch.codeRepo).Stat was not checking for a go.mod file,\n+# which would produce a hard error at the subsequent call to GoMod.\n+\n+go list all\n+\n+-- go.mod --\n+module example.com\n+go 1.13\n+\n+-- main.go --\n+package main\n+\n+import _ \"vcs-test.golang.org/git/v3pkg.git/v3\"\n+\n+func main() {}"}, {"sha": "d43bbe7f2bcf19abb8dfce2fd3651ba7792e9a1c", "filename": "libgo/go/cmd/go/testdata/script/mod_list_replace_dir.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_replace_dir.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_replace_dir.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_replace_dir.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -6,7 +6,7 @@ env GO111MODULE=on\n go mod download\n \n ! go list $GOPATH/pkg/mod/rsc.io/quote@v1.5.2\n-stderr 'outside available modules'\n+stderr 'can only use path@version syntax with .go get.'\n \n go list $GOPATH/pkg/mod/rsc.io/quote@v1.5.1\n stdout 'rsc.io/quote'"}, {"sha": "f2d06490920151e090821eae5ca8e267ba834ccb", "filename": "libgo/go/cmd/go/testdata/script/mod_list_upgrade.txt", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_upgrade.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_upgrade.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_upgrade.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -1,8 +1,28 @@\n env GO111MODULE=on\n \n+# If the current version is not latest, 'go list -u' should include its upgrade.\n go list -m -u all\n stdout 'rsc.io/quote v1.2.0 \\[v1\\.5\\.2\\]'\n \n+# If the current version is latest, 'go list -u' should omit the upgrade.\n+go get -d rsc.io/quote@v1.5.2\n+go list -m -u all\n+stdout 'rsc.io/quote v1.5.2$'\n+\n+# If the current version is newer than latest, 'go list -u' should\n+# omit the upgrade.\n+go get -d rsc.io/quote@v1.5.3-pre1\n+go list -m -u all\n+stdout 'rsc.io/quote v1.5.3-pre1$'\n+\n+# If the current build list has a higher version and the user asks about\n+# a lower one, -u should report the upgrade for the lower one\n+# but leave the build list unchanged.\n+go list -m -u rsc.io/quote@v1.5.1\n+stdout 'rsc.io/quote v1.5.1 \\[v1.5.2\\]$'\n+go list -m -u rsc.io/quote\n+stdout 'rsc.io/quote v1.5.3-pre1$'\n+\n -- go.mod --\n module x\n require rsc.io/quote v1.2.0"}, {"sha": "b97a2e6eaba2c5bad0202919d5948c9b8b9a5256", "filename": "libgo/go/cmd/go/testdata/script/mod_load_badchain.txt", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_load_badchain.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_load_badchain.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_load_badchain.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -57,19 +57,29 @@ import (\n func Test(t *testing.T) {}\n -- update-main-expected --\n go get: example.com/badchain/c@v1.0.0 updating to\n-\texample.com/badchain/c@v1.1.0: parsing go.mod: unexpected module path \"example.com/badchain/wrong\"\n+\texample.com/badchain/c@v1.1.0: parsing go.mod:\n+\tmodule declares its path as: badchain.example.com/c\n+\t        but was required as: example.com/badchain/c\n -- update-a-expected --\n go get: example.com/badchain/a@v1.1.0 requires\n \texample.com/badchain/b@v1.1.0 requires\n-\texample.com/badchain/c@v1.1.0: parsing go.mod: unexpected module path \"example.com/badchain/wrong\"\n+\texample.com/badchain/c@v1.1.0: parsing go.mod:\n+\tmodule declares its path as: badchain.example.com/c\n+\t        but was required as: example.com/badchain/c\n -- list-expected --\n go: example.com/badchain/a@v1.1.0 requires\n \texample.com/badchain/b@v1.1.0 requires\n-\texample.com/badchain/c@v1.1.0: parsing go.mod: unexpected module path \"example.com/badchain/wrong\"\n+\texample.com/badchain/c@v1.1.0: parsing go.mod:\n+\tmodule declares its path as: badchain.example.com/c\n+\t        but was required as: example.com/badchain/c\n -- list-missing-expected --\n go: m/use imports\n-\texample.com/badchain/c: example.com/badchain/c@v1.1.0: parsing go.mod: unexpected module path \"example.com/badchain/wrong\"\n+\texample.com/badchain/c: example.com/badchain/c@v1.1.0: parsing go.mod:\n+\tmodule declares its path as: badchain.example.com/c\n+\t        but was required as: example.com/badchain/c\n -- list-missing-test-expected --\n go: m/testuse tested by\n \tm/testuse.test imports\n-\texample.com/badchain/c: example.com/badchain/c@v1.1.0: parsing go.mod: unexpected module path \"example.com/badchain/wrong\"\n+\texample.com/badchain/c: example.com/badchain/c@v1.1.0: parsing go.mod:\n+\tmodule declares its path as: badchain.example.com/c\n+\t        but was required as: example.com/badchain/c"}, {"sha": "e87ca302f0ca9fb9eed00d8c030f300cc6202355", "filename": "libgo/go/cmd/go/testdata/script/mod_query.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_query.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_query.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_query.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -22,7 +22,7 @@ go list -m rsc.io/quote@<v1.5.4\n stdout 'rsc.io/quote v1.5.2$'\n \n ! go list -m rsc.io/quote@>v1.5.3\n-stderr 'go list -m rsc.io/quote: no matching versions for query \">v1.5.3\"'\n+stderr 'go list -m: module rsc.io/quote: no matching versions for query \">v1.5.3\"'\n \n go list -m -e -f '{{.Error.Err}}' rsc.io/quote@>v1.5.3\n stdout 'no matching versions for query \">v1.5.3\"'"}, {"sha": "4d8259b40f1a4be6efe05ab0fca35008be71b77d", "filename": "libgo/go/cmd/go/testdata/script/mod_query_empty.txt", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_query_empty.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_query_empty.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_query_empty.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -28,6 +28,20 @@ go list -m example.com/join/...\n ! stdout 'example.com/join/subpkg'\n stdout 'example.com/join v1.1.0'\n \n+# If the proxy provides an empty @v/list but rejects @latest with\n+# some other explicit error (for example, a \"permission denied\" error),\n+# that error should be reported to the user (and override a successful\n+# result for other possible module paths).\n+#\n+# Depending on how the specific platform enforces permissions, the 'go get' may\n+# fail either due to the intended permission error or due to a parse error.\n+# We accept either failure message.\n+env GOPROXY=file:///$WORK/gatekeeper\n+chmod 0000 $WORK/gatekeeper/example.com/join/subpkg/@latest\n+cp go.mod.orig go.mod\n+! go get -d example.com/join/subpkg\n+stderr 'go get example.com/join/subpkg: module example.com/join/subpkg: (invalid character .+|reading file://.*/gatekeeper/example.com/join/subpkg/@latest: .+)'\n+\n -- go.mod.orig --\n module example.com/othermodule\n go 1.13\n@@ -50,3 +64,10 @@ v1.0.0-does-not-exist\n v1.1.0\n -- $WORK/notfound/example.com/join/@v/v1.1.0.info --\n {\"Version\": \"v1.1.0\"}\n+-- $WORK/gatekeeper/example.com/join/subpkg/@v/list --\n+-- $WORK/gatekeeper/example.com/join/subpkg/@latest --\n+ERROR: Latest version is forbidden.\n+-- $WORK/gatekeeper/example.com/join/@v/list --\n+v1.1.0\n+-- $WORK/gatekeeper/example.com/join/@v/v1.1.0.info --\n+{\"Version\": \"v1.1.0\"}"}, {"sha": "641b9e73bcc67f565c9945f5d0359bc6a9ceae9e", "filename": "libgo/go/cmd/go/testdata/script/mod_sumdb.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -9,8 +9,8 @@ env dbname=localhost.localdev/sumdb\n cp go.mod.orig go.mod\n env GOSUMDB=$sumdb' '$proxy/sumdb-wrong\n ! go get -d rsc.io/quote\n-stderr 'verifying rsc.io/quote@v1.5.2/go.mod: checksum mismatch'\n-stderr 'downloaded: h1:LzX7'\n+stderr 'verifying rsc.io/quote@v1.5.2: checksum mismatch'\n+stderr 'downloaded: h1:3fEy'\n stderr 'localhost.localdev/sumdb: h1:wrong'\n stderr 'SECURITY ERROR\\nThis download does NOT match the one reported by the checksum server.'\n ! go get -d rsc.io/sampler"}, {"sha": "486bdf5ecf6c6da4453cf8fa7014104abbe64f29", "filename": "libgo/go/cmd/go/testdata/script/mod_sumdb_cache.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb_cache.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb_cache.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb_cache.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -28,7 +28,7 @@ cp go.mod.orig go.mod\n rm go.sum\n env GOPROXY=off\n go get -d rsc.io/quote@v1.5.2 # using cache\n-rm $GOPATH/pkg/mod/download/cache/sumdb/localhost.localdev/sumdb/lookup/rsc.io/quote@v1.5.2\n+rm $GOPATH/pkg/mod/cache/download/sumdb/localhost.localdev/sumdb/lookup/rsc.io/quote@v1.5.2\n go get -d rsc.io/quote@v1.5.2 # using go.sum\n \n # fetch fails once we lose access to both cache and go.sum"}, {"sha": "47c8a3a0f3cf654ee63375c8a88b1565a3ae073e", "filename": "libgo/go/cmd/go/testdata/script/mod_sumdb_file_path.txt", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb_file_path.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb_file_path.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb_file_path.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -2,6 +2,7 @@\n \n env GO111MODULE=on\n env GOSUMDB=\n+env GOPATH=$WORK/gopath1\n \n # With a file-based proxy with an empty checksum directory,\n # downloading a new module should fail, even if a subsequent\n@@ -18,18 +19,29 @@ stderr '^verifying golang.org/x/text.*: Not Found'\n [!windows] env GOPROXY=file://$WORK/emptyproxy,https://proxy.golang.org\n go get -d golang.org/x/text@v0.3.2\n \n+# After a successful sumdb lookup, the lookup can be repeated\n+# using the download cache as a proxy.\n+cp supported $GOPATH/pkg/mod/cache/download/sumdb/sum.golang.org/supported\n+[windows] env GOPROXY=file:///$WORK/gopath1/pkg/mod/cache/download,file:///$WORK/sumproxy\n+[!windows] env GOPROXY=file://$WORK/gopath1/pkg/mod/cache/download,file://$WORK/sumproxy\n+env GOPATH=$WORK/gopath2\n+rm go.sum\n+go get -d -x -v golang.org/x/text@v0.3.2\n+\n # Once the checksum is present in the go.sum file,\n # an empty file-based sumdb can be used in conjunction with\n # a fallback module mirror.\n grep golang.org/x/text go.sum\n-go clean -modcache\n+env GOPATH=$WORK/gopath3\n [windows] env GOPROXY=file:///$WORK/sumproxy\n [!windows] env GOPROXY=file://$WORK/sumproxy\n ! go get -d golang.org/x/text@v0.3.2\n [windows] env GOPROXY=file:///$WORK/sumproxy,https://proxy.golang.org\n [!windows] env GOPROXY=file://$WORK/sumproxy,https://proxy.golang.org\n go get -d golang.org/x/text@v0.3.2\n \n+-- supported --\n+\n -- go.mod --\n module example.com\n go 1.13"}, {"sha": "40a07fc7e9fe702094f0d3a46cb2e7595b22d6d3", "filename": "libgo/go/cmd/go/testdata/script/mod_sumdb_golang.txt", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb_golang.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb_golang.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb_golang.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -14,31 +14,39 @@ stdout '^sum.golang.org$'\n [!exec:git] skip\n env GOSUMDB=sum.golang.org\n env GOPROXY=direct\n-go get -d rsc.io/quote\n+go get -d rsc.io/quote@v1.5.2\n+cp go.sum saved.sum\n \n # download from proxy.golang.org with go.sum entry already\n go clean -modcache\n env GOSUMDB=\n env GOPROXY=\n-go get -x -d rsc.io/quote\n+go get -x -d rsc.io/quote@v1.5.2\n ! stderr github\n stderr proxy.golang.org/rsc.io/quote\n ! stderr sum.golang.org/tile\n ! stderr sum.golang.org/lookup/rsc.io/quote\n+cmp go.sum saved.sum\n \n-# download again, using checksum database to validate new go.sum lines\n+# Download again.\n+# Should use the checksum database to validate new go.sum lines,\n+# but not need to fetch any new data from the proxy.\n rm go.sum\n-go get -x -d rsc.io/quote\n+go get -x -d rsc.io/quote@v1.5.2\n ! stderr github\n-stderr proxy.golang.org/rsc.io/quote\n+! stderr proxy.golang.org/rsc.io/quote\n stderr sum.golang.org/tile\n stderr sum.golang.org/lookup/rsc.io/quote\n+cmp go.sum saved.sum\n \n # test fallback to direct\n env TESTGOPROXY404=1\n-go get -x -d rsc.io/quote\n+go clean -modcache\n+rm go.sum\n+go get -x -d rsc.io/quote@v1.5.2\n stderr 'proxy.golang.org.*404 testing'\n stderr github.com/rsc\n+cmp go.sum saved.sum\n \n -- go.mod --\n module m"}, {"sha": "28166913fd57189a6f0c16e4d74370ba916a1483", "filename": "libgo/go/cmd/go/testdata/script/mod_sumdb_proxy.txt", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb_proxy.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb_proxy.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb_proxy.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -6,14 +6,14 @@ env GOPROXY GONOPROXY GOSUMDB GONOSUMDB\n # basic fetch (through proxy) works\n cp go.mod.orig go.mod\n go get -d rsc.io/fortune@v1.0.0 # note: must use test proxy, does not exist in real world\n-rm $GOPATH/pkg/mod/download/cache/sumdb # rm sumdb cache but NOT package download cache\n+rm $GOPATH/pkg/mod/cache/download/sumdb # rm sumdb cache but NOT package download cache\n rm go.sum\n \n # can fetch by explicit URL\n cp go.mod.orig go.mod\n env GOSUMDB=$sumdb' '$proxy/sumdb-direct\n go get -d rsc.io/fortune@v1.0.0\n-rm $GOPATH/pkg/mod/download/cache/sumdb\n+rm $GOPATH/pkg/mod/cache/download/sumdb\n rm go.sum\n \n # direct access fails (because localhost.localdev does not exist)\n@@ -25,7 +25,7 @@ env GOSUMDB=$sumdb\n env GOPROXY=direct\n ! go get -d rsc.io/fortune@v1.0.0\n stderr 'verifying.*localhost.localdev'\n-rm $GOPATH/pkg/mod/download/cache/sumdb\n+rm $GOPATH/pkg/mod/cache/download/sumdb\n rm go.sum\n \n # proxy 404 falls back to direct access (which fails)\n@@ -34,7 +34,7 @@ env GOSUMDB=$sumdb\n env GOPROXY=$proxy/sumdb-404\n ! go get -d rsc.io/fortune@v1.0.0\n stderr 'verifying.*localhost.localdev'\n-rm $GOPATH/pkg/mod/download/cache/sumdb\n+rm $GOPATH/pkg/mod/cache/download/sumdb\n rm go.sum\n \n # proxy non-200/404/410 stops direct access\n@@ -43,7 +43,7 @@ env GOSUMDB=$sumdb\n env GOPROXY=$proxy/sumdb-503\n ! go get -d rsc.io/fortune@v1.0.0\n stderr '503 Service Unavailable'\n-rm $GOPATH/pkg/mod/download/cache/sumdb\n+rm $GOPATH/pkg/mod/cache/download/sumdb\n rm go.sum\n \n -- go.mod.orig --"}, {"sha": "ffd573c02a9661a759375b0f0ff48fa415bcfcf7", "filename": "libgo/go/cmd/go/testdata/script/mod_test_cached.txt", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_test_cached.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_test_cached.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_test_cached.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -0,0 +1,77 @@\n+[short] skip\n+\n+env GO111MODULE=on\n+env GOCACHE=$WORK/gocache\n+env GODEBUG=gocachetest=1\n+\n+# The first run of a test should not be cached.\n+# The second run should be.\n+go test -run=WriteTmp .\n+! stdout '(cached)'\n+go test -run=WriteTmp .\n+stdout '(cached)'\n+\n+# 'go test' without arguments should never be cached.\n+go test -run=WriteTmp\n+! stdout '(cached)'\n+go test -run=WriteTmp\n+! stdout '(cached)'\n+\n+# We should never cache a test run from command-line files.\n+go test -run=WriteTmp ./foo_test.go\n+! stdout '(cached)'\n+go test -run=WriteTmp ./foo_test.go\n+! stdout '(cached)'\n+\n+[!exec:sleep] stop\n+# The go command refuses to cache access to files younger than 2s, so sleep that long.\n+exec sleep 2\n+\n+# Touching a file that the test reads from within its testdata should invalidate the cache.\n+go test -run=ReadTestdata .\n+! stdout '(cached)'\n+go test -run=ReadTestdata .\n+stdout '(cached)'\n+cp testdata/bar.txt testdata/foo.txt\n+go test -run=ReadTestdata .\n+! stdout '(cached)'\n+\n+-- go.mod --\n+module golang.org/issue/29111/foo\n+\n+-- foo.go --\n+package foo\n+\n+-- testdata/foo.txt --\n+foo\n+-- testdata/bar.txt --\n+bar\n+\n+-- foo_test.go --\n+package foo_test\n+\n+import (\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"testing\"\n+)\n+\n+func TestWriteTmp(t *testing.T) {\n+\tdir, err := ioutil.TempDir(\"\", \"\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer os.RemoveAll(dir)\n+\terr = ioutil.WriteFile(filepath.Join(dir, \"x\"), nil, 0666)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+}\n+\n+func TestReadTestdata(t *testing.T) {\n+\t_, err := ioutil.ReadFile(\"testdata/foo.txt\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+}"}, {"sha": "9bb8528cb0be62e549019f15b4115c6a0a416127", "filename": "libgo/go/cmd/go/testdata/script/mod_tidy_error.txt", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_tidy_error.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_tidy_error.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_tidy_error.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -0,0 +1,39 @@\n+env GO111MODULE=on\n+\n+# Regression test for golang.org/issue/27063:\n+# 'go mod tidy' and 'go mod vendor' should not hide loading errors.\n+\n+! go mod tidy\n+stderr '^issue27063 imports\\n\\tnonexist: malformed module path \"nonexist\": missing dot in first path element'\n+stderr '^issue27063 imports\\n\\tnonexist.example.com: cannot find module providing package nonexist.example.com'\n+stderr '^issue27063 imports\\n\\tissue27063/other imports\\n\\tother.example.com/nonexist: cannot find module providing package other.example.com/nonexist'\n+\n+! go mod vendor\n+stderr '^issue27063 imports\\n\\tnonexist: malformed module path \"nonexist\": missing dot in first path element'\n+stderr '^issue27063 imports\\n\\tnonexist.example.com: cannot find module providing package nonexist.example.com'\n+stderr '^issue27063 imports\\n\\tissue27063/other imports\\n\\tother.example.com/nonexist: cannot find module providing package other.example.com/nonexist'\n+\n+-- go.mod --\n+module issue27063\n+\n+go 1.13\n+\n+require issue27063/other v0.0.0\n+replace issue27063/other => ./other\n+-- x.go --\n+package main\n+\n+import (\n+\t\"nonexist\"\n+\n+\t\"nonexist.example.com\"\n+\t\"issue27063/other\"\n+)\n+\n+func main() {}\n+-- other/go.mod --\n+module issue27063/other\n+-- other/other.go --\n+package other\n+\n+import \"other.example.com/nonexist\""}, {"sha": "5d872c3c80ef73956146ca95a67c22850f254e79", "filename": "libgo/go/cmd/go/testdata/script/mod_vendor.txt", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -171,12 +171,6 @@ package m\n \n import _ \"appengine\"\n import _ \"appengine/datastore\"\n--- nonexistent.go --\n-// +build alternatereality\n-\n-package m\n-\n-import _ \"nonexistent.rsc.io\"\n -- mypkg/go.mod --\n module me\n -- mypkg/mydir/d.go --"}, {"sha": "ca1de43a2b5dddbcb6d8fb3cf5cc0e95e6e358f8", "filename": "libgo/go/cmd/go/testdata/script/test_go111module_cache.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_go111module_cache.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_go111module_cache.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_go111module_cache.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -0,0 +1,15 @@\n+env GO111MODULE=on\n+go mod init foo\n+go test\n+stdout ^ok\\s+foo\n+env GO111MODULE=off\n+go test\n+stdout ^ok\\s+\n+! stdout ^ok\\s+(cache)$\n+\n+-- main_test.go --\n+package main\n+\n+import \"testing\"\n+\n+func TestF(t *testing.T) {}"}, {"sha": "73b4f3c7686f9de64ed86d9c7ee9174a67351e72", "filename": "libgo/go/cmd/go/testdata/script/test_init.txt", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ecb707cc5a58816d27908a7aa324c4b0bc67bb/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_init.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ecb707cc5a58816d27908a7aa324c4b0bc67bb/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_init.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_init.txt?ref=d6ecb707cc5a58816d27908a7aa324c4b0bc67bb", "patch": "@@ -1,86 +0,0 @@\n-# Tests for automatic testing.Init calls when using 'go test'.\n-\n-env GO111MODULE=on\n-\n-# A TestMain should be able to access testing flags if it calls flag.Parse\n-# without needing to use testing.Init.\n-# Test code can use the name 'testing' without colliding with generated\n-# testinginit code.\n-# Tests running under 'go test' should observe that testing.Init is called\n-# before any user package initialization code runs.\n-go test\n-stdout TestMain\n-stdout TestInit\n-stdout TestExt\n-\n--- go.mod --\n-module m\n-\n--- init_test.go --\n-package testinitflag\n-\n-import (\n-\t\"flag\"\n-\t\"fmt\"\n-\t\"os\"\n-\tTesting \"testing\"\n-)\n-\n-func testFlagsInitialized() bool {\n-\tfound := false\n-\tflag.VisitAll(func(f *flag.Flag) {\n-\t\tif f.Name == \"test.count\" {\n-\t\t\tfound = true\n-\t\t}\n-\t})\n-\treturn found\n-}\n-\n-var testing int\n-var testingInitAtInitialization = testFlagsInitialized()\n-\n-func TestInit(t *Testing.T) {\n-\tif !testingInitAtInitialization {\n-\t\tt.Fatal(\"testing.Init not called before package initialization\")\n-\t}\n-\tfmt.Printf(\"TestInit\\n\")\n-}\n-\n-func TestMain(m *Testing.M) {\n-\tfmt.Printf(\"TestMain\\n\")\n-\tflag.Parse()\n-\tif !testFlagsInitialized() {\n-\t\tfmt.Println(\"testing flags not registered\")\n-\t\tos.Exit(1)\n-\t}\n-\tos.Exit(m.Run())\n-}\n-\n--- external_test.go --\n-package testinitflag_test\n-\n-import (\n-\t\"flag\"\n-\t\"fmt\"\n-\tTesting \"testing\"\n-)\n-\n-func testFlagsInitialized() bool {\n-\tfound := false\n-\tflag.VisitAll(func(f *flag.Flag) {\n-\t\tif f.Name == \"test.count\" {\n-\t\t\tfound = true\n-\t\t}\n-\t})\n-\treturn found\n-}\n-\n-var testing int\n-var testingInitAtInitialization = testFlagsInitialized()\n-\n-func TestExt(t *Testing.T) {\n-\tfmt.Printf(\"TestExt\\n\")\n-\tif !testingInitAtInitialization {\n-\t\tt.Fatal(\"testing.Init not called before package initialization\")\n-\t}\n-}"}, {"sha": "9086f047e4bbfbb9eae239df9f298348127edeb7", "filename": "libgo/go/cmd/go/testdata/script/version.txt", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fversion.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fversion.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fversion.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -8,5 +8,12 @@ go version -m fortune.exe\n stdout '^\\tpath\\trsc.io/fortune'\n stdout '^\\tmod\\trsc.io/fortune\\tv1.0.0'\n \n+go build -buildmode=pie -o external.exe rsc.io/fortune\n+go version external.exe\n+stdout '^external.exe: .+'\n+go version -m external.exe\n+stdout '^\\tpath\\trsc.io/fortune'\n+stdout '^\\tmod\\trsc.io/fortune\\tv1.0.0'\n+\n -- go.mod --\n module m"}, {"sha": "a59555bb61d277062aa76546210b8bfed7e26aea", "filename": "libgo/go/cmd/go/testdata/standalone_testmain_flag_test.go", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_testmain_flag_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_testmain_flag_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_testmain_flag_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package standalone_testmain_flag_test\n+\n+import (\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"testing\"\n+)\n+\n+func TestMain(m *testing.M) {\n+\t// A TestMain should be able to access testing flags if it calls\n+\t// flag.Parse without needing to use testing.Init.\n+\tflag.Parse()\n+\tfound := false\n+\tflag.VisitAll(func(f *flag.Flag) {\n+\t\tif f.Name == \"test.count\" {\n+\t\t\tfound = true\n+\t\t}\n+\t})\n+\tif !found {\n+\t\tfmt.Println(\"testing flags not registered\")\n+\t\tos.Exit(1)\n+\t}\n+\tos.Exit(m.Run())\n+}"}, {"sha": "0184aaa6ced8fb4125f5d9f3576c4004d4b7a5dd", "filename": "libgo/go/cmd/gofmt/testdata/go2numbers.golden", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fgo2numbers.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fgo2numbers.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fgo2numbers.golden?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -0,0 +1,186 @@\n+package p\n+\n+const (\n+\t// 0-octals\n+\t_ = 0\n+\t_ = 0123\n+\t_ = 0123456\n+\n+\t_ = 0_123\n+\t_ = 0123_456\n+\n+\t// decimals\n+\t_ = 1\n+\t_ = 1234\n+\t_ = 1234567\n+\n+\t_ = 1_234\n+\t_ = 1_234_567\n+\n+\t// hexadecimals\n+\t_ = 0x0\n+\t_ = 0x1234\n+\t_ = 0xcafef00d\n+\n+\t_ = 0x0\n+\t_ = 0x1234\n+\t_ = 0xCAFEf00d\n+\n+\t_ = 0x_0\n+\t_ = 0x_1234\n+\t_ = 0x_CAFE_f00d\n+\n+\t// octals\n+\t_ = 0o0\n+\t_ = 0o1234\n+\t_ = 0o01234567\n+\n+\t_ = 0o0\n+\t_ = 0o1234\n+\t_ = 0o01234567\n+\n+\t_ = 0o_0\n+\t_ = 0o_1234\n+\t_ = 0o0123_4567\n+\n+\t_ = 0o_0\n+\t_ = 0o_1234\n+\t_ = 0o0123_4567\n+\n+\t// binaries\n+\t_ = 0b0\n+\t_ = 0b1011\n+\t_ = 0b00101101\n+\n+\t_ = 0b0\n+\t_ = 0b1011\n+\t_ = 0b00101101\n+\n+\t_ = 0b_0\n+\t_ = 0b10_11\n+\t_ = 0b_0010_1101\n+\n+\t// decimal floats\n+\t_ = 0.\n+\t_ = 123.\n+\t_ = 0123.\n+\n+\t_ = .0\n+\t_ = .123\n+\t_ = .0123\n+\n+\t_ = 0e0\n+\t_ = 123e+0\n+\t_ = 0123e-1\n+\n+\t_ = 0e-0\n+\t_ = 123e+0\n+\t_ = 0123e123\n+\n+\t_ = 0.e+1\n+\t_ = 123.e-10\n+\t_ = 0123.e123\n+\n+\t_ = .0e-1\n+\t_ = .123e+10\n+\t_ = .0123e123\n+\n+\t_ = 0.0\n+\t_ = 123.123\n+\t_ = 0123.0123\n+\n+\t_ = 0.0e1\n+\t_ = 123.123e-10\n+\t_ = 0123.0123e+456\n+\n+\t_ = 1_2_3.\n+\t_ = 0_123.\n+\n+\t_ = 0_0e0\n+\t_ = 1_2_3e0\n+\t_ = 0_123e0\n+\n+\t_ = 0e-0_0\n+\t_ = 1_2_3e+0\n+\t_ = 0123e1_2_3\n+\n+\t_ = 0.e+1\n+\t_ = 123.e-1_0\n+\t_ = 01_23.e123\n+\n+\t_ = .0e-1\n+\t_ = .123e+10\n+\t_ = .0123e123\n+\n+\t_ = 1_2_3.123\n+\t_ = 0123.01_23\n+\n+\t// hexadecimal floats\n+\t_ = 0x0.p+0\n+\t_ = 0xdeadcafe.p-10\n+\t_ = 0x1234.p123\n+\n+\t_ = 0x.1p-0\n+\t_ = 0x.deadcafep2\n+\t_ = 0x.1234p+10\n+\n+\t_ = 0x0p0\n+\t_ = 0xdeadcafep+1\n+\t_ = 0x1234p-10\n+\n+\t_ = 0x0.0p0\n+\t_ = 0xdead.cafep+1\n+\t_ = 0x12.34p-10\n+\n+\t_ = 0xdead_cafep+1\n+\t_ = 0x_1234p-10\n+\n+\t_ = 0x_dead_cafe.p-10\n+\t_ = 0x12_34.p1_2_3\n+\t_ = 0x1_2_3_4.p-1_2_3\n+\n+\t// imaginaries\n+\t_ = 0i\n+\t_ = 0i\n+\t_ = 8i\n+\t_ = 0i\n+\t_ = 123i\n+\t_ = 123i\n+\t_ = 56789i\n+\t_ = 1234i\n+\t_ = 1234567i\n+\n+\t_ = 0i\n+\t_ = 0i\n+\t_ = 8i\n+\t_ = 0i\n+\t_ = 123i\n+\t_ = 123i\n+\t_ = 56_789i\n+\t_ = 1_234i\n+\t_ = 1_234_567i\n+\n+\t_ = 0.i\n+\t_ = 123.i\n+\t_ = 0123.i\n+\t_ = 000123.i\n+\n+\t_ = 0e0i\n+\t_ = 123e0i\n+\t_ = 0123e0i\n+\t_ = 000123e0i\n+\n+\t_ = 0.e+1i\n+\t_ = 123.e-1_0i\n+\t_ = 01_23.e123i\n+\t_ = 00_01_23.e123i\n+\n+\t_ = 0b1010i\n+\t_ = 0b1010i\n+\t_ = 0o660i\n+\t_ = 0o660i\n+\t_ = 0xabcDEFi\n+\t_ = 0xabcDEFi\n+\t_ = 0xabcDEFp0i\n+\t_ = 0xabcDEFp0i\n+)"}, {"sha": "f3e7828d948496582951ee196069864d83ef2737", "filename": "libgo/go/cmd/gofmt/testdata/go2numbers.input", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fgo2numbers.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fgo2numbers.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fgo2numbers.input?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -0,0 +1,186 @@\n+package p\n+\n+const (\n+\t// 0-octals\n+\t_ = 0\n+\t_ = 0123\n+\t_ = 0123456\n+\n+\t_ = 0_123\n+\t_ = 0123_456\n+\n+\t// decimals\n+\t_ = 1\n+\t_ = 1234\n+\t_ = 1234567\n+\n+\t_ = 1_234\n+\t_ = 1_234_567\n+\n+\t// hexadecimals\n+\t_ = 0x0\n+\t_ = 0x1234\n+\t_ = 0xcafef00d\n+\n+\t_ = 0X0\n+\t_ = 0X1234\n+\t_ = 0XCAFEf00d\n+\n+\t_ = 0X_0\n+\t_ = 0X_1234\n+\t_ = 0X_CAFE_f00d\n+\n+\t// octals\n+\t_ = 0o0\n+\t_ = 0o1234\n+\t_ = 0o01234567\n+\n+\t_ = 0O0\n+\t_ = 0O1234\n+\t_ = 0O01234567\n+\n+\t_ = 0o_0\n+\t_ = 0o_1234\n+\t_ = 0o0123_4567\n+\n+\t_ = 0O_0\n+\t_ = 0O_1234\n+\t_ = 0O0123_4567\n+\n+\t// binaries\n+\t_ = 0b0\n+\t_ = 0b1011\n+\t_ = 0b00101101\n+\n+\t_ = 0B0\n+\t_ = 0B1011\n+\t_ = 0B00101101\n+\n+\t_ = 0b_0\n+\t_ = 0b10_11\n+\t_ = 0b_0010_1101\n+\n+\t// decimal floats\n+\t_ = 0.\n+\t_ = 123.\n+\t_ = 0123.\n+\n+\t_ = .0\n+\t_ = .123\n+\t_ = .0123\n+\n+\t_ = 0e0\n+\t_ = 123e+0\n+\t_ = 0123E-1\n+\n+\t_ = 0e-0\n+\t_ = 123E+0\n+\t_ = 0123E123\n+\n+\t_ = 0.e+1\n+\t_ = 123.E-10\n+\t_ = 0123.e123\n+\n+\t_ = .0e-1\n+\t_ = .123E+10\n+\t_ = .0123E123\n+\n+\t_ = 0.0\n+\t_ = 123.123\n+\t_ = 0123.0123\n+\n+\t_ = 0.0e1\n+\t_ = 123.123E-10\n+\t_ = 0123.0123e+456\n+\n+\t_ = 1_2_3.\n+\t_ = 0_123.\n+\n+\t_ = 0_0e0\n+\t_ = 1_2_3e0\n+\t_ = 0_123e0\n+\n+\t_ = 0e-0_0\n+\t_ = 1_2_3E+0\n+\t_ = 0123E1_2_3\n+\n+\t_ = 0.e+1\n+\t_ = 123.E-1_0\n+\t_ = 01_23.e123\n+\n+\t_ = .0e-1\n+\t_ = .123E+10\n+\t_ = .0123E123\n+\n+\t_ = 1_2_3.123\n+\t_ = 0123.01_23\n+\n+\t// hexadecimal floats\n+\t_ = 0x0.p+0\n+\t_ = 0Xdeadcafe.p-10\n+\t_ = 0x1234.P123\n+\n+\t_ = 0x.1p-0\n+\t_ = 0X.deadcafep2\n+\t_ = 0x.1234P+10\n+\n+\t_ = 0x0p0\n+\t_ = 0Xdeadcafep+1\n+\t_ = 0x1234P-10\n+\n+\t_ = 0x0.0p0\n+\t_ = 0Xdead.cafep+1\n+\t_ = 0x12.34P-10\n+\n+\t_ = 0Xdead_cafep+1\n+\t_ = 0x_1234P-10\n+\n+\t_ = 0X_dead_cafe.p-10\n+\t_ = 0x12_34.P1_2_3\n+\t_ = 0X1_2_3_4.P-1_2_3\n+\n+\t// imaginaries\n+\t_ = 0i\n+\t_ = 00i\n+\t_ = 08i\n+\t_ = 0000000000i\n+\t_ = 0123i\n+\t_ = 0000000123i\n+\t_ = 0000056789i\n+\t_ = 1234i\n+\t_ = 1234567i\n+\n+\t_ = 0i\n+\t_ = 0_0i\n+\t_ = 0_8i\n+\t_ = 0_000_000_000i\n+\t_ = 0_123i\n+\t_ = 0_000_000_123i\n+\t_ = 0_000_056_789i\n+\t_ = 1_234i\n+\t_ = 1_234_567i\n+\n+\t_ = 0.i\n+\t_ = 123.i\n+\t_ = 0123.i\n+\t_ = 000123.i\n+\n+\t_ = 0e0i\n+\t_ = 123e0i\n+\t_ = 0123E0i\n+\t_ = 000123E0i\n+\n+\t_ = 0.e+1i\n+\t_ = 123.E-1_0i\n+\t_ = 01_23.e123i\n+\t_ = 00_01_23.e123i\n+\n+\t_ = 0b1010i\n+\t_ = 0B1010i\n+\t_ = 0o660i\n+\t_ = 0O660i\n+\t_ = 0xabcDEFi\n+\t_ = 0XabcDEFi\n+\t_ = 0xabcDEFP0i\n+\t_ = 0XabcDEFp0i\n+)"}, {"sha": "29bdc9baf4a637763fc75e30086dca99acd500f2", "filename": "libgo/go/cmd/gofmt/testdata/import.golden", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fimport.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fimport.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fimport.golden?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -8,6 +8,11 @@ import (\n \t\"math\"\n )\n \n+import (\n+\t\"fmt\"\n+\t\"math\"\n+)\n+\n import (\n \t\"fmt\"\n "}, {"sha": "78ab4f654434a7e6e5d74eb958e647dce5e506fb", "filename": "libgo/go/cmd/gofmt/testdata/import.input", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fimport.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fimport.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fimport.input?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -8,6 +8,9 @@ import (\n \t\"io\"\n )\n \n+import(\"fmt\"\n+\"math\")\n+\n import (\n \t\"fmt\"\n "}, {"sha": "fffbd3d05ba3df5272edc4141103bb7a4461b8fb", "filename": "libgo/go/cmd/gofmt/testdata/rewrite9.golden", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite9.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite9.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite9.golden?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -0,0 +1,11 @@\n+//gofmt -r=a&&b!=2->a\n+\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 18987.\n+\n+package p\n+\n+const _ = x != 1"}, {"sha": "106ad94bc52bf3a125180df8835ecfce697ae3d2", "filename": "libgo/go/cmd/gofmt/testdata/rewrite9.input", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite9.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite9.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite9.input?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -0,0 +1,11 @@\n+//gofmt -r=a&&b!=2->a\n+\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 18987.\n+\n+package p\n+\n+const _ = x != 1 && x != 2"}, {"sha": "bbbbf321214bde1845a238bc0c54db6075ef01b3", "filename": "libgo/go/cmd/gofmt/testdata/typealias.golden", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Ftypealias.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Ftypealias.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Ftypealias.golden?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -0,0 +1,24 @@\n+package q\n+\n+import \"p\"\n+\n+type _ = int\n+type a = struct{ x int }\n+type b = p.B\n+\n+type (\n+\t_  = chan<- int\n+\taa = interface{}\n+\tbb = p.BB\n+)\n+\n+// TODO(gri) We may want to put the '=' into a separate column if\n+// we have mixed (regular and alias) type declarations in a group.\n+type (\n+\t_   chan<- int\n+\t_   = chan<- int\n+\taa0 interface{}\n+\taaa = interface{}\n+\tbb0 p.BB\n+\tbbb = p.BB\n+)"}, {"sha": "6e49328e34668d13bb746ed08c5c616b74f18046", "filename": "libgo/go/cmd/gofmt/testdata/typealias.input", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Ftypealias.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Ftypealias.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Ftypealias.input?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -0,0 +1,24 @@\n+package q\n+\n+import \"p\"\n+\n+type _ = int\n+type a = struct{ x int }\n+type b = p.B\n+\n+type (\n+\t_ = chan<- int\n+\taa = interface{}\n+\tbb = p.BB\n+)\n+\n+// TODO(gri) We may want to put the '=' into a separate column if\n+// we have mixed (regular and alias) type declarations in a group.\n+type (\n+\t_ chan<- int\n+\t_ = chan<- int\n+\taa0 interface{}\n+\taaa = interface{}\n+\tbb0 p.BB\n+\tbbb = p.BB\n+)"}, {"sha": "79ad2ccf748036af2ee04473f66d687133bb43f0", "filename": "libgo/go/cmd/internal/objabi/flag.go", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fflag.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -86,6 +86,10 @@ func (versionFlag) Set(s string) error {\n \tname = name[strings.LastIndex(name, `/`)+1:]\n \tname = name[strings.LastIndex(name, `\\`)+1:]\n \tname = strings.TrimSuffix(name, \".exe\")\n+\n+\t// If there's an active experiment, include that,\n+\t// to distinguish go1.10.2 with an experiment\n+\t// from go1.10.2 without an experiment.\n \tp := Expstring()\n \tif p == DefaultExpstring() {\n \t\tp = \"\"\n@@ -101,12 +105,6 @@ func (versionFlag) Set(s string) error {\n \t// build ID of the binary, so that if the compiler is changed and\n \t// rebuilt, we notice and rebuild all packages.\n \tif s == \"full\" {\n-\t\t// If there's an active experiment, include that,\n-\t\t// to distinguish go1.10.2 with an experiment\n-\t\t// from go1.10.2 without an experiment.\n-\t\tif x := Expstring(); x != \"\" {\n-\t\t\tp += \" \" + x\n-\t\t}\n \t\tif strings.HasPrefix(Version, \"devel\") {\n \t\t\tp += \" buildID=\" + buildID\n \t\t}"}, {"sha": "62590850a66220027342acbfdcd64218aa11f6b8", "filename": "libgo/go/context/context.go", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcontext%2Fcontext.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcontext%2Fcontext.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontext%2Fcontext.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -49,7 +49,6 @@ package context\n \n import (\n \t\"errors\"\n-\t\"internal/oserror\"\n \t\"internal/reflectlite\"\n \t\"sync\"\n \t\"time\"\n@@ -163,9 +162,6 @@ type deadlineExceededError struct{}\n func (deadlineExceededError) Error() string   { return \"context deadline exceeded\" }\n func (deadlineExceededError) Timeout() bool   { return true }\n func (deadlineExceededError) Temporary() bool { return true }\n-func (deadlineExceededError) Is(target error) bool {\n-\treturn target == oserror.ErrTimeout || target == oserror.ErrTemporary\n-}\n \n // An emptyCtx is never canceled, has no values, and has no deadline. It is not\n // struct{}, since vars of this type must have distinct addresses."}, {"sha": "b07a5cfce6422d2c71db2567d97e03f9731ccc12", "filename": "libgo/go/context/context_test.go", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcontext%2Fcontext_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcontext%2Fcontext_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontext%2Fcontext_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -5,10 +5,8 @@\n package context\n \n import (\n-\t\"errors\"\n \t\"fmt\"\n \t\"math/rand\"\n-\t\"os\"\n \t\"runtime\"\n \t\"strings\"\n \t\"sync\"\n@@ -649,7 +647,4 @@ func XTestDeadlineExceededSupportsTimeout(t testingT) {\n \tif !i.Timeout() {\n \t\tt.Fatal(\"wrong value for timeout\")\n \t}\n-\tif !errors.Is(DeadlineExceeded, os.ErrTimeout) {\n-\t\tt.Fatal(\"errors.Is(DeadlineExceeded, os.ErrTimeout) = false, want true\")\n-\t}\n }"}, {"sha": "d058949242d034fb89db0ed833ec479eb8c5c1a8", "filename": "libgo/go/crypto/rsa/rsa.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -555,7 +555,7 @@ func decryptAndCheck(random io.Reader, priv *PrivateKey, c *big.Int) (m *big.Int\n }\n \n // DecryptOAEP decrypts ciphertext using RSA-OAEP.\n-\n+//\n // OAEP is parameterised by a hash function that is used as a random oracle.\n // Encryption and decryption of a given message must use the same hash function\n // and sha256.New() is a reasonable choice."}, {"sha": "ef0b38584876c6b91ce445296959e893a8406268", "filename": "libgo/go/crypto/tls/common.go", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -23,11 +23,14 @@ import (\n )\n \n const (\n-\tVersionSSL30 = 0x0300\n \tVersionTLS10 = 0x0301\n \tVersionTLS11 = 0x0302\n \tVersionTLS12 = 0x0303\n \tVersionTLS13 = 0x0304\n+\n+\t// Deprecated: SSLv3 is cryptographically broken, and will be\n+\t// removed in Go 1.14. See golang.org/issue/32716.\n+\tVersionSSL30 = 0x0300\n )\n \n const (\n@@ -791,6 +794,10 @@ var supportedVersions = []uint16{\n func (c *Config) supportedVersions(isClient bool) []uint16 {\n \tversions := make([]uint16, 0, len(supportedVersions))\n \tfor _, v := range supportedVersions {\n+\t\t// TLS 1.0 is the default minimum version.\n+\t\tif (c == nil || c.MinVersion == 0) && v < VersionTLS10 {\n+\t\t\tcontinue\n+\t\t}\n \t\tif c != nil && c.MinVersion != 0 && v < c.MinVersion {\n \t\t\tcontinue\n \t\t}"}, {"sha": "a9c1c08cbc429ed3eba18a4e9d14d4222293265a", "filename": "libgo/go/crypto/tls/handshake_server_test.go", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -77,6 +77,20 @@ func TestRejectBadProtocolVersion(t *testing.T) {\n \t}, \"unsupported versions\")\n }\n \n+func TestSSLv3OptIn(t *testing.T) {\n+\tconfig := testConfig.Clone()\n+\tconfig.MinVersion = 0\n+\ttestClientHelloFailure(t, config, &clientHelloMsg{\n+\t\tvers:   VersionSSL30,\n+\t\trandom: make([]byte, 32),\n+\t}, \"unsupported versions\")\n+\ttestClientHelloFailure(t, config, &clientHelloMsg{\n+\t\tvers:              VersionTLS12,\n+\t\tsupportedVersions: []uint16{VersionSSL30},\n+\t\trandom:            make([]byte, 32),\n+\t}, \"unsupported versions\")\n+}\n+\n func TestNoSuiteOverlap(t *testing.T) {\n \tclientHello := &clientHelloMsg{\n \t\tvers:               VersionTLS10,"}, {"sha": "cfd92908a962dabd12cb3918b70ca579d03eca11", "filename": "libgo/go/crypto/tls/handshake_test.go", "status": "modified", "additions": 57, "deletions": 18, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -222,28 +222,65 @@ func tempFile(contents string) string {\n // localListener is set up by TestMain and used by localPipe to create Conn\n // pairs like net.Pipe, but connected by an actual buffered TCP connection.\n var localListener struct {\n-\tsync.Mutex\n-\tnet.Listener\n+\tmu   sync.Mutex\n+\taddr net.Addr\n+\tch   chan net.Conn\n+}\n+\n+const localFlakes = 0 // change to 1 or 2 to exercise localServer/localPipe handling of mismatches\n+\n+func localServer(l net.Listener) {\n+\tfor n := 0; ; n++ {\n+\t\tc, err := l.Accept()\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif localFlakes == 1 && n%2 == 0 {\n+\t\t\tc.Close()\n+\t\t\tcontinue\n+\t\t}\n+\t\tlocalListener.ch <- c\n+\t}\n }\n \n func localPipe(t testing.TB) (net.Conn, net.Conn) {\n-\tlocalListener.Lock()\n-\tdefer localListener.Unlock()\n-\tc := make(chan net.Conn)\n-\tgo func() {\n-\t\tconn, err := localListener.Accept()\n+\tlocalListener.mu.Lock()\n+\tdefer localListener.mu.Unlock()\n+\n+\taddr := localListener.addr\n+\n+Dialing:\n+\t// We expect a rare mismatch, but probably not 5 in a row.\n+\tfor i := 0; i < 5; i++ {\n+\t\ttooSlow := time.NewTimer(1 * time.Second)\n+\t\tdefer tooSlow.Stop()\n+\t\tc1, err := net.Dial(addr.Network(), addr.String())\n \t\tif err != nil {\n-\t\t\tt.Errorf(\"Failed to accept local connection: %v\", err)\n+\t\t\tt.Fatalf(\"localPipe: %v\", err)\n+\t\t}\n+\t\tif localFlakes == 2 && i == 0 {\n+\t\t\tc1.Close()\n+\t\t\tcontinue\n+\t\t}\n+\t\tfor {\n+\t\t\tselect {\n+\t\t\tcase <-tooSlow.C:\n+\t\t\t\tt.Logf(\"localPipe: timeout waiting for %v\", c1.LocalAddr())\n+\t\t\t\tc1.Close()\n+\t\t\t\tcontinue Dialing\n+\n+\t\t\tcase c2 := <-localListener.ch:\n+\t\t\t\tif c2.RemoteAddr().String() == c1.LocalAddr().String() {\n+\t\t\t\t\treturn c1, c2\n+\t\t\t\t}\n+\t\t\t\tt.Logf(\"localPipe: unexpected connection: %v != %v\", c2.RemoteAddr(), c1.LocalAddr())\n+\t\t\t\tc2.Close()\n+\t\t\t}\n \t\t}\n-\t\tc <- conn\n-\t}()\n-\taddr := localListener.Addr()\n-\tc1, err := net.Dial(addr.Network(), addr.String())\n-\tif err != nil {\n-\t\tt.Fatalf(\"Failed to dial local connection: %v\", err)\n \t}\n-\tc2 := <-c\n-\treturn c1, c2\n+\n+\tt.Fatalf(\"localPipe: failed to connect\")\n+\tpanic(\"unreachable\")\n }\n \n // zeroSource is an io.Reader that returns an unlimited number of zero bytes.\n@@ -293,8 +330,10 @@ func runMain(m *testing.M) int {\n \t\tfmt.Fprintf(os.Stderr, \"Failed to open local listener: %v\", err)\n \t\tos.Exit(1)\n \t}\n-\tlocalListener.Listener = l\n-\tdefer localListener.Close()\n+\tlocalListener.ch = make(chan net.Conn)\n+\tlocalListener.addr = l.Addr()\n+\tdefer l.Close()\n+\tgo localServer(l)\n \n \tif err := checkOpenSSLVersion(); err != nil {\n \t\tfmt.Fprintf(os.Stderr, \"Error: %v\", err)"}, {"sha": "b68c074855f81ef448f4bc9f0b2077742ed07861", "filename": "libgo/go/crypto/tls/tls_test.go", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -359,50 +359,6 @@ func TestVerifyHostname(t *testing.T) {\n \t}\n }\n \n-func TestVerifyHostnameResumed(t *testing.T) {\n-\tt.Run(\"TLSv12\", func(t *testing.T) { testVerifyHostnameResumed(t, VersionTLS12) })\n-\tt.Run(\"TLSv13\", func(t *testing.T) { testVerifyHostnameResumed(t, VersionTLS13) })\n-}\n-\n-func testVerifyHostnameResumed(t *testing.T, version uint16) {\n-\ttestenv.MustHaveExternalNetwork(t)\n-\n-\tconfig := &Config{\n-\t\tMaxVersion:         version,\n-\t\tClientSessionCache: NewLRUClientSessionCache(32),\n-\t}\n-\tfor i := 0; i < 2; i++ {\n-\t\tc, err := DialWithDialer(&net.Dialer{\n-\t\t\tTimeout: 10 * time.Second,\n-\t\t}, \"tcp\", \"mail.google.com:https\", config)\n-\t\tif err != nil {\n-\t\t\tt.Fatalf(\"Dial #%d: %v\", i, err)\n-\t\t}\n-\t\tcs := c.ConnectionState()\n-\t\tif i > 0 && !cs.DidResume {\n-\t\t\tt.Fatalf(\"Subsequent connection unexpectedly didn't resume\")\n-\t\t}\n-\t\tif cs.Version != version {\n-\t\t\tt.Fatalf(\"Unexpectedly negotiated version %x\", cs.Version)\n-\t\t}\n-\t\tif cs.VerifiedChains == nil {\n-\t\t\tt.Fatalf(\"Dial #%d: cs.VerifiedChains == nil\", i)\n-\t\t}\n-\t\tif err := c.VerifyHostname(\"mail.google.com\"); err != nil {\n-\t\t\tt.Fatalf(\"verify mail.google.com #%d: %v\", i, err)\n-\t\t}\n-\t\t// Have the server send some data so session tickets are delivered.\n-\t\tc.SetDeadline(time.Now().Add(5 * time.Second))\n-\t\tif _, err := io.WriteString(c, \"HEAD / HTTP/1.0\\n\\n\"); err != nil {\n-\t\t\tt.Fatal(err)\n-\t\t}\n-\t\tif _, err := c.Read(make([]byte, 1)); err != nil {\n-\t\t\tt.Fatal(err)\n-\t\t}\n-\t\tc.Close()\n-\t}\n-}\n-\n func TestConnCloseBreakingWrite(t *testing.T) {\n \tln := newLocalListener(t)\n \tdefer ln.Close()"}, {"sha": "e2a58203d9d9e805257179a80321bc23baeeae4e", "filename": "libgo/go/debug/elf/file.go", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -171,6 +171,11 @@ type Symbol struct {\n \tInfo, Other byte\n \tSection     SectionIndex\n \tValue, Size uint64\n+\n+\t// Version and Library are present only for the dynamic symbol\n+\t// table.\n+\tVersion string\n+\tLibrary string\n }\n \n /*\n@@ -1321,12 +1326,23 @@ func (f *File) Symbols() ([]Symbol, error) {\n // DynamicSymbols returns the dynamic symbol table for f. The symbols\n // will be listed in the order they appear in f.\n //\n+// If f has a symbol version table, the returned Symbols will have\n+// initialized Version and Library fields.\n+//\n // For compatibility with Symbols, DynamicSymbols omits the null symbol at index 0.\n // After retrieving the symbols as symtab, an externally supplied index x\n // corresponds to symtab[x-1], not symtab[x].\n func (f *File) DynamicSymbols() ([]Symbol, error) {\n-\tsym, _, err := f.getSymbols(SHT_DYNSYM)\n-\treturn sym, err\n+\tsym, str, err := f.getSymbols(SHT_DYNSYM)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif f.gnuVersionInit(str) {\n+\t\tfor i := range sym {\n+\t\t\tsym[i].Library, sym[i].Version = f.gnuVersion(i)\n+\t\t}\n+\t}\n+\treturn sym, nil\n }\n \n type ImportedSymbol struct {\n@@ -1349,7 +1365,8 @@ func (f *File) ImportedSymbols() ([]ImportedSymbol, error) {\n \tfor i, s := range sym {\n \t\tif ST_BIND(s.Info) == STB_GLOBAL && s.Section == SHN_UNDEF {\n \t\t\tall = append(all, ImportedSymbol{Name: s.Name})\n-\t\t\tf.gnuVersion(i, &all[len(all)-1])\n+\t\t\tsym := &all[len(all)-1]\n+\t\t\tsym.Library, sym.Version = f.gnuVersion(i)\n \t\t}\n \t}\n \treturn all, nil\n@@ -1362,11 +1379,16 @@ type verneed struct {\n \n // gnuVersionInit parses the GNU version tables\n // for use by calls to gnuVersion.\n-func (f *File) gnuVersionInit(str []byte) {\n+func (f *File) gnuVersionInit(str []byte) bool {\n+\tif f.gnuNeed != nil {\n+\t\t// Already initialized\n+\t\treturn true\n+\t}\n+\n \t// Accumulate verneed information.\n \tvn := f.SectionByType(SHT_GNU_VERNEED)\n \tif vn == nil {\n-\t\treturn\n+\t\treturn false\n \t}\n \td, _ := vn.Data()\n \n@@ -1421,17 +1443,18 @@ func (f *File) gnuVersionInit(str []byte) {\n \t// Versym parallels symbol table, indexing into verneed.\n \tvs := f.SectionByType(SHT_GNU_VERSYM)\n \tif vs == nil {\n-\t\treturn\n+\t\treturn false\n \t}\n \td, _ = vs.Data()\n \n \tf.gnuNeed = need\n \tf.gnuVersym = d\n+\treturn true\n }\n \n // gnuVersion adds Library and Version information to sym,\n // which came from offset i of the symbol table.\n-func (f *File) gnuVersion(i int, sym *ImportedSymbol) {\n+func (f *File) gnuVersion(i int) (library string, version string) {\n \t// Each entry is two bytes.\n \ti = (i + 1) * 2\n \tif i >= len(f.gnuVersym) {\n@@ -1442,8 +1465,7 @@ func (f *File) gnuVersion(i int, sym *ImportedSymbol) {\n \t\treturn\n \t}\n \tn := &f.gnuNeed[j]\n-\tsym.Library = n.File\n-\tsym.Version = n.Name\n+\treturn n.File, n.Name\n }\n \n // ImportedLibraries returns the names of all libraries"}, {"sha": "42f02312e871dda91417d861480631f5ef2e22e5", "filename": "libgo/go/debug/elf/symbols_test.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fdebug%2Felf%2Fsymbols_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fdebug%2Felf%2Fsymbols_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Fsymbols_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -819,6 +819,8 @@ var dynamicSymbolsGolden = map[string][]Symbol{\n \t\t\tSection: 0x0,\n \t\t\tValue:   0x0,\n \t\t\tSize:    0x18C,\n+\t\t\tVersion: \"GLIBC_2.2.5\",\n+\t\t\tLibrary: \"libc.so.6\",\n \t\t},\n \t\tSymbol{\n \t\t\tName:    \"__libc_start_main\",\n@@ -827,6 +829,8 @@ var dynamicSymbolsGolden = map[string][]Symbol{\n \t\t\tSection: 0x0,\n \t\t\tValue:   0x0,\n \t\t\tSize:    0x1C2,\n+\t\t\tVersion: \"GLIBC_2.2.5\",\n+\t\t\tLibrary: \"libc.so.6\",\n \t\t},\n \t},\n \t\"testdata/go-relocation-test-clang-x86.obj\": {},"}, {"sha": "3f34bc51dbfc0ddb705771b75436a17203175337", "filename": "libgo/go/encoding/csv/writer.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fencoding%2Fcsv%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fencoding%2Fcsv%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fcsv%2Fwriter.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -41,7 +41,7 @@ func NewWriter(w io.Writer) *Writer {\n \t}\n }\n \n-// Writer writes a single CSV record to w along with any necessary quoting.\n+// Write writes a single CSV record to w along with any necessary quoting.\n // A record is a slice of strings with each string being one field.\n // Writes are buffered, so Flush must eventually be called to ensure\n // that the record is written to the underlying io.Writer."}, {"sha": "cbd71acfc6c38f7827dd4290fcf6ca7bfbb68d47", "filename": "libgo/go/encoding/json/decode.go", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -272,9 +272,6 @@ type decodeState struct {\n \tsavedError            error\n \tuseNumber             bool\n \tdisallowUnknownFields bool\n-\t// safeUnquote is the number of current string literal bytes that don't\n-\t// need to be unquoted. When negative, no bytes need unquoting.\n-\tsafeUnquote int\n }\n \n // readIndex returns the position of the last byte read.\n@@ -376,27 +373,13 @@ func (d *decodeState) rescanLiteral() {\n Switch:\n \tswitch data[i-1] {\n \tcase '\"': // string\n-\t\t// safeUnquote is initialized at -1, which means that all bytes\n-\t\t// checked so far can be unquoted at a later time with no work\n-\t\t// at all. When reaching the closing '\"', if safeUnquote is\n-\t\t// still -1, all bytes can be unquoted with no work. Otherwise,\n-\t\t// only those bytes up until the first '\\\\' or non-ascii rune\n-\t\t// can be safely unquoted.\n-\t\tsafeUnquote := -1\n \t\tfor ; i < len(data); i++ {\n-\t\t\tif c := data[i]; c == '\\\\' {\n-\t\t\t\tif safeUnquote < 0 { // first unsafe byte\n-\t\t\t\t\tsafeUnquote = int(i - d.off)\n-\t\t\t\t}\n+\t\t\tswitch data[i] {\n+\t\t\tcase '\\\\':\n \t\t\t\ti++ // escaped char\n-\t\t\t} else if c == '\"' {\n-\t\t\t\td.safeUnquote = safeUnquote\n+\t\t\tcase '\"':\n \t\t\t\ti++ // tokenize the closing quote too\n \t\t\t\tbreak Switch\n-\t\t\t} else if c >= utf8.RuneSelf {\n-\t\t\t\tif safeUnquote < 0 { // first unsafe byte\n-\t\t\t\t\tsafeUnquote = int(i - d.off)\n-\t\t\t\t}\n \t\t\t}\n \t\t}\n \tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-': // number\n@@ -749,7 +732,7 @@ func (d *decodeState) object(v reflect.Value) error {\n \t\tstart := d.readIndex()\n \t\td.rescanLiteral()\n \t\titem := d.data[start:d.readIndex()]\n-\t\tkey, ok := d.unquoteBytes(item)\n+\t\tkey, ok := unquoteBytes(item)\n \t\tif !ok {\n \t\t\tpanic(phasePanicMsg)\n \t\t}\n@@ -950,7 +933,7 @@ func (d *decodeState) literalStore(item []byte, v reflect.Value, fromQuoted bool\n \t\t\td.saveError(&UnmarshalTypeError{Value: val, Type: v.Type(), Offset: int64(d.readIndex())})\n \t\t\treturn nil\n \t\t}\n-\t\ts, ok := d.unquoteBytes(item)\n+\t\ts, ok := unquoteBytes(item)\n \t\tif !ok {\n \t\t\tif fromQuoted {\n \t\t\t\treturn fmt.Errorf(\"json: invalid use of ,string struct tag, trying to unmarshal %q into %v\", item, v.Type())\n@@ -1001,7 +984,7 @@ func (d *decodeState) literalStore(item []byte, v reflect.Value, fromQuoted bool\n \t\t}\n \n \tcase '\"': // string\n-\t\ts, ok := d.unquoteBytes(item)\n+\t\ts, ok := unquoteBytes(item)\n \t\tif !ok {\n \t\t\tif fromQuoted {\n \t\t\t\treturn fmt.Errorf(\"json: invalid use of ,string struct tag, trying to unmarshal %q into %v\", item, v.Type())\n@@ -1159,7 +1142,7 @@ func (d *decodeState) objectInterface() map[string]interface{} {\n \t\tstart := d.readIndex()\n \t\td.rescanLiteral()\n \t\titem := d.data[start:d.readIndex()]\n-\t\tkey, ok := d.unquote(item)\n+\t\tkey, ok := unquote(item)\n \t\tif !ok {\n \t\t\tpanic(phasePanicMsg)\n \t\t}\n@@ -1208,7 +1191,7 @@ func (d *decodeState) literalInterface() interface{} {\n \t\treturn c == 't'\n \n \tcase '\"': // string\n-\t\ts, ok := d.unquote(item)\n+\t\ts, ok := unquote(item)\n \t\tif !ok {\n \t\t\tpanic(phasePanicMsg)\n \t\t}\n@@ -1251,21 +1234,38 @@ func getu4(s []byte) rune {\n \n // unquote converts a quoted JSON string literal s into an actual string t.\n // The rules are different than for Go, so cannot use strconv.Unquote.\n-func (d *decodeState) unquote(s []byte) (t string, ok bool) {\n-\ts, ok = d.unquoteBytes(s)\n+func unquote(s []byte) (t string, ok bool) {\n+\ts, ok = unquoteBytes(s)\n \tt = string(s)\n \treturn\n }\n \n-func (d *decodeState) unquoteBytes(s []byte) (t []byte, ok bool) {\n-\tr := d.safeUnquote\n-\t// The bytes have been scanned, so we know that the first and last bytes\n-\t// are double quotes.\n+func unquoteBytes(s []byte) (t []byte, ok bool) {\n+\tif len(s) < 2 || s[0] != '\"' || s[len(s)-1] != '\"' {\n+\t\treturn\n+\t}\n \ts = s[1 : len(s)-1]\n \n-\t// If there are no unusual characters, no unquoting is needed, so return\n-\t// a slice of the original bytes.\n-\tif r == -1 {\n+\t// Check for unusual characters. If there are none,\n+\t// then no unquoting is needed, so return a slice of the\n+\t// original bytes.\n+\tr := 0\n+\tfor r < len(s) {\n+\t\tc := s[r]\n+\t\tif c == '\\\\' || c == '\"' || c < ' ' {\n+\t\t\tbreak\n+\t\t}\n+\t\tif c < utf8.RuneSelf {\n+\t\t\tr++\n+\t\t\tcontinue\n+\t\t}\n+\t\trr, size := utf8.DecodeRune(s[r:])\n+\t\tif rr == utf8.RuneError && size == 1 {\n+\t\t\tbreak\n+\t\t}\n+\t\tr += size\n+\t}\n+\tif r == len(s) {\n \t\treturn s, true\n \t}\n "}, {"sha": "3f25893b419a43f00149cd56965589f4ce8cd648", "filename": "libgo/go/encoding/json/decode_test.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -1250,6 +1250,8 @@ var wrongStringTests = []wrongStringTest{\n \t{`{\"result\":\"foo\"}`, `json: invalid use of ,string struct tag, trying to unmarshal \"foo\" into string`},\n \t{`{\"result\":\"123\"}`, `json: invalid use of ,string struct tag, trying to unmarshal \"123\" into string`},\n \t{`{\"result\":123}`, `json: invalid use of ,string struct tag, trying to unmarshal unquoted value into string`},\n+\t{`{\"result\":\"\\\"\"}`, `json: invalid use of ,string struct tag, trying to unmarshal \"\\\"\" into string`},\n+\t{`{\"result\":\"\\\"foo\"}`, `json: invalid use of ,string struct tag, trying to unmarshal \"\\\"foo\" into string`},\n }\n \n // If people misuse the ,string modifier, the error message should be"}, {"sha": "67412763d64009d47ba3b51b110819b1474f3317", "filename": "libgo/go/encoding/json/encode.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -137,7 +137,7 @@ import (\n // string, an integer type, or implement encoding.TextMarshaler. The map keys\n // are sorted and used as JSON object keys by applying the following rules,\n // subject to the UTF-8 coercion described for string values above:\n-//   - string keys are used directly\n+//   - keys of any string type are used directly\n //   - encoding.TextMarshalers are marshaled\n //   - integer keys are converted to strings\n //\n@@ -460,7 +460,7 @@ func marshalerEncoder(e *encodeState, v reflect.Value, opts encOpts) {\n \t}\n }\n \n-func addrMarshalerEncoder(e *encodeState, v reflect.Value, _ encOpts) {\n+func addrMarshalerEncoder(e *encodeState, v reflect.Value, opts encOpts) {\n \tva := v.Addr()\n \tif va.IsNil() {\n \t\te.WriteString(\"null\")\n@@ -470,7 +470,7 @@ func addrMarshalerEncoder(e *encodeState, v reflect.Value, _ encOpts) {\n \tb, err := m.MarshalJSON()\n \tif err == nil {\n \t\t// copy JSON into buffer, checking validity.\n-\t\terr = compact(&e.Buffer, b, true)\n+\t\terr = compact(&e.Buffer, b, opts.escapeHTML)\n \t}\n \tif err != nil {\n \t\te.error(&MarshalerError{v.Type(), err})"}, {"sha": "be03f0d7ffc55510da9dcb41937709c959b6d9f9", "filename": "libgo/go/encoding/json/fuzz.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fencoding%2Fjson%2Ffuzz.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fencoding%2Fjson%2Ffuzz.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Ffuzz.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -33,7 +33,7 @@ func Fuzz(data []byte) (score int) {\n \t\terr = Unmarshal(m, u)\n \t\tif err != nil {\n \t\t\tfmt.Printf(\"v=%#v\\n\", v)\n-\t\t\tfmt.Println(\"m=%s\\n\", string(m))\n+\t\t\tfmt.Printf(\"m=%s\\n\", m)\n \t\t\tpanic(err)\n \t\t}\n \t}"}, {"sha": "fba19548c92721d2f2fb0c63dd3accaa8a3077d3", "filename": "libgo/go/encoding/json/indent.go", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fencoding%2Fjson%2Findent.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fencoding%2Fjson%2Findent.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Findent.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -8,9 +8,6 @@ import \"bytes\"\n \n // Compact appends to dst the JSON-encoded src with\n // insignificant space characters elided.\n-// Like Marshal, Compact applies HTMLEscape to any\n-// string literals so that the JSON will be safe to embed\n-// inside HTML <script> tags.\n func Compact(dst *bytes.Buffer, src []byte) error {\n \treturn compact(dst, src, false)\n }"}, {"sha": "e3317ddeb0b5d38eb41ab451a9bbe8af3ea7a896", "filename": "libgo/go/encoding/json/stream_test.go", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fencoding%2Fjson%2Fstream_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fencoding%2Fjson%2Fstream_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fstream_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -90,13 +90,34 @@ func TestEncoderIndent(t *testing.T) {\n \t}\n }\n \n+type strMarshaler string\n+\n+func (s strMarshaler) MarshalJSON() ([]byte, error) {\n+\treturn []byte(s), nil\n+}\n+\n+type strPtrMarshaler string\n+\n+func (s *strPtrMarshaler) MarshalJSON() ([]byte, error) {\n+\treturn []byte(*s), nil\n+}\n+\n func TestEncoderSetEscapeHTML(t *testing.T) {\n \tvar c C\n \tvar ct CText\n \tvar tagStruct struct {\n \t\tValid   int `json:\"<>&#! \"`\n \t\tInvalid int `json:\"\\\\\"`\n \t}\n+\n+\t// This case is particularly interesting, as we force the encoder to\n+\t// take the address of the Ptr field to use its MarshalJSON method. This\n+\t// is why the '&' is important.\n+\tmarshalerStruct := &struct {\n+\t\tNonPtr strMarshaler\n+\t\tPtr    strPtrMarshaler\n+\t}{`\"<str>\"`, `\"<str>\"`}\n+\n \tfor _, tt := range []struct {\n \t\tname       string\n \t\tv          interface{}\n@@ -111,6 +132,11 @@ func TestEncoderSetEscapeHTML(t *testing.T) {\n \t\t\t`{\"\\u003c\\u003e\\u0026#! \":0,\"Invalid\":0}`,\n \t\t\t`{\"<>&#! \":0,\"Invalid\":0}`,\n \t\t},\n+\t\t{\n+\t\t\t`\"<str>\"`, marshalerStruct,\n+\t\t\t`{\"NonPtr\":\"\\u003cstr\\u003e\",\"Ptr\":\"\\u003cstr\\u003e\"}`,\n+\t\t\t`{\"NonPtr\":\"<str>\",\"Ptr\":\"<str>\"}`,\n+\t\t},\n \t} {\n \t\tvar buf bytes.Buffer\n \t\tenc := NewEncoder(&buf)"}, {"sha": "85d4260762e275ec56fd858f9bd676480f6b65eb", "filename": "libgo/go/errors/errors.go", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Ferrors%2Ferrors.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Ferrors%2Ferrors.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ferrors%2Ferrors.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -3,9 +3,58 @@\n // license that can be found in the LICENSE file.\n \n // Package errors implements functions to manipulate errors.\n+//\n+// The New function creates errors whose only content is a text message.\n+//\n+// The Unwrap, Is and As functions work on errors that may wrap other errors.\n+// An error wraps another error if its type has the method\n+//\n+//\tUnwrap() error\n+//\n+// If e.Unwrap() returns a non-nil error w, then we say that e wraps w.\n+//\n+// A simple way to create wrapped errors is to call fmt.Errorf and apply the %w verb\n+// to the error argument:\n+//\n+//\tfmt.Errorf(\"... %w ...\", ..., err, ...).Unwrap()\n+//\n+// returns err.\n+//\n+// Unwrap unpacks wrapped errors. If its argument's type has an\n+// Unwrap method, it calls the method once. Otherwise, it returns nil.\n+//\n+// Is unwraps its first argument sequentially looking for an error that matches the\n+// second. It reports whether it finds a match. It should be used in preference to\n+// simple equality checks:\n+//\n+//\tif errors.Is(err, os.ErrExist)\n+//\n+// is preferable to\n+//\n+//\tif err == os.ErrExist\n+//\n+// because the former will succeed if err wraps os.ErrExist.\n+//\n+// As unwraps its first argument sequentially looking for an error that can be\n+// assigned to its second argument, which must be a pointer. If it succeeds, it\n+// performs the assignment and returns true. Otherwise, it returns false. The form\n+//\n+//\tvar perr *os.PathError\n+//\tif errors.As(err, &perr) {\n+//\t\tfmt.Println(perr.Path)\n+//\t}\n+//\n+// is preferable to\n+//\n+//\tif perr, ok := err.(*os.PathError); ok {\n+//\t\tfmt.Println(perr.Path)\n+//\t}\n+//\n+// because the former will succeed if err wraps an *os.PathError.\n package errors\n \n // New returns an error that formats as the given text.\n+// Each call to New returns a distinct error value even if the text is identical.\n func New(text string) error {\n \treturn &errorString{text}\n }"}, {"sha": "240da37c2952eb6589b6d4156c022b918497e4ed", "filename": "libgo/go/errors/wrap.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Ferrors%2Fwrap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Ferrors%2Fwrap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ferrors%2Fwrap.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -23,6 +23,9 @@ func Unwrap(err error) error {\n \n // Is reports whether any error in err's chain matches target.\n //\n+// The chain consists of err itself followed by the sequence of errors obtained by\n+// repeatedly calling Unwrap.\n+//\n // An error is considered to match a target if it is equal to that target or if\n // it implements a method Is(error) bool such that Is(target) returns true.\n func Is(err, target error) bool {\n@@ -50,6 +53,9 @@ func Is(err, target error) bool {\n // As finds the first error in err's chain that matches target, and if so, sets\n // target to that error value and returns true.\n //\n+// The chain consists of err itself followed by the sequence of errors obtained by\n+// repeatedly calling Unwrap.\n+//\n // An error matches target if the error's concrete value is assignable to the value\n // pointed to by target, or if the error has a method As(interface{}) bool such that\n // As(target) returns true. In the latter case, the As method is responsible for"}, {"sha": "13b5c99b6e536fef7c6c978e5322519243e85c44", "filename": "libgo/go/expvar/expvar.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fexpvar%2Fexpvar.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fexpvar%2Fexpvar.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexpvar%2Fexpvar.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -205,7 +205,7 @@ func (v *Map) AddFloat(key string, delta float64) {\n \t}\n }\n \n-// Deletes the given key from the map.\n+// Delete deletes the given key from the map.\n func (v *Map) Delete(key string) {\n \tv.keysMu.Lock()\n \tdefer v.keysMu.Unlock()"}, {"sha": "466a620353310b6d6322c60783aae143f5727a59", "filename": "libgo/go/fmt/errors.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Ffmt%2Ferrors.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Ffmt%2Ferrors.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Ferrors.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -12,7 +12,7 @@ import \"errors\"\n // If the format specifier includes a %w verb with an error operand,\n // the returned error will implement an Unwrap method returning the operand. It is\n // invalid to include more than one %w verb or to supply it with an operand\n-// that does not implement the error innterface. The %w verb is otherwise\n+// that does not implement the error interface. The %w verb is otherwise\n // a synonym for %v.\n func Errorf(format string, a ...interface{}) error {\n \tp := newPrinter()"}, {"sha": "0dab2c98f75ee72666bd829ac2f4d07d5ff923bd", "filename": "libgo/go/fmt/scan.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Ffmt%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Ffmt%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -609,7 +609,7 @@ func (s *ss) scanRune(bitSize int) int64 {\n \treturn r\n }\n \n-// scanBasePrefix reports whether the integer begins with a bas prefix\n+// scanBasePrefix reports whether the integer begins with a base prefix\n // and returns the base, digit string, and whether a zero was found.\n // It is called only if the verb is %v.\n func (s *ss) scanBasePrefix() (base int, digits string, zeroFound bool) {"}, {"sha": "be23c7fc43207f87af33626b9b676a6450736a66", "filename": "libgo/go/go/ast/import.go", "status": "modified", "additions": 23, "deletions": 58, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fgo%2Fast%2Fimport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fgo%2Fast%2Fimport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fimport.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -30,7 +30,7 @@ func SortImports(fset *token.FileSet, f *File) {\n \t\ti := 0\n \t\tspecs := d.Specs[:0]\n \t\tfor j, s := range d.Specs {\n-\t\t\tif j > i && lineAt(fset, s.Pos()) > 1+lineAt(fset, d.Specs[j-1].End()) {\n+\t\t\tif j > i && fset.Position(s.Pos()).Line > 1+fset.Position(d.Specs[j-1].End()).Line {\n \t\t\t\t// j begins a new run. End this one.\n \t\t\t\tspecs = append(specs, sortSpecs(fset, f, d.Specs[i:j])...)\n \t\t\t\ti = j\n@@ -42,8 +42,8 @@ func SortImports(fset *token.FileSet, f *File) {\n \t\t// Deduping can leave a blank line before the rparen; clean that up.\n \t\tif len(d.Specs) > 0 {\n \t\t\tlastSpec := d.Specs[len(d.Specs)-1]\n-\t\t\tlastLine := lineAt(fset, lastSpec.Pos())\n-\t\t\trParenLine := lineAt(fset, d.Rparen)\n+\t\t\tlastLine := fset.Position(lastSpec.Pos()).Line\n+\t\t\trParenLine := fset.Position(d.Rparen).Line\n \t\t\tfor rParenLine > lastLine+1 {\n \t\t\t\trParenLine--\n \t\t\t\tfset.File(d.Rparen).MergeLine(rParenLine)\n@@ -52,10 +52,6 @@ func SortImports(fset *token.FileSet, f *File) {\n \t}\n }\n \n-func lineAt(fset *token.FileSet, pos token.Pos) int {\n-\treturn fset.PositionFor(pos, false).Line\n-}\n-\n func importPath(s Spec) string {\n \tt, err := strconv.Unquote(s.(*ImportSpec).Path.Value)\n \tif err == nil {\n@@ -93,11 +89,6 @@ type posSpan struct {\n \tEnd   token.Pos\n }\n \n-type cgPos struct {\n-\tleft bool // true if comment is to the left of the spec, false otherwise.\n-\tcg   *CommentGroup\n-}\n-\n func sortSpecs(fset *token.FileSet, f *File, specs []Spec) []Spec {\n \t// Can't short-circuit here even if specs are already sorted,\n \t// since they might yet need deduplication.\n@@ -113,57 +104,39 @@ func sortSpecs(fset *token.FileSet, f *File, specs []Spec) []Spec {\n \t}\n \n \t// Identify comments in this range.\n-\tbegSpecs := pos[0].Start\n-\tendSpecs := pos[len(pos)-1].End\n-\tbeg := fset.File(begSpecs).LineStart(lineAt(fset, begSpecs))\n-\tend := fset.File(endSpecs).LineStart(lineAt(fset, endSpecs) + 1) // beginning of next line\n-\tfirst := len(f.Comments)\n-\tlast := -1\n+\t// Any comment from pos[0].Start to the final line counts.\n+\tlastLine := fset.Position(pos[len(pos)-1].End).Line\n+\tcstart := len(f.Comments)\n+\tcend := len(f.Comments)\n \tfor i, g := range f.Comments {\n-\t\tif g.End() >= end {\n-\t\t\tbreak\n+\t\tif g.Pos() < pos[0].Start {\n+\t\t\tcontinue\n \t\t}\n-\t\t// g.End() < end\n-\t\tif beg <= g.Pos() {\n-\t\t\t// comment is within the range [beg, end[ of import declarations\n-\t\t\tif i < first {\n-\t\t\t\tfirst = i\n-\t\t\t}\n-\t\t\tif i > last {\n-\t\t\t\tlast = i\n-\t\t\t}\n+\t\tif i < cstart {\n+\t\t\tcstart = i\n+\t\t}\n+\t\tif fset.Position(g.End()).Line > lastLine {\n+\t\t\tcend = i\n+\t\t\tbreak\n \t\t}\n \t}\n+\tcomments := f.Comments[cstart:cend]\n \n-\tvar comments []*CommentGroup\n-\tif last >= 0 {\n-\t\tcomments = f.Comments[first : last+1]\n-\t}\n-\n-\t// Assign each comment to the import spec on the same line.\n-\timportComments := map[*ImportSpec][]cgPos{}\n+\t// Assign each comment to the import spec preceding it.\n+\timportComments := map[*ImportSpec][]*CommentGroup{}\n \tspecIndex := 0\n \tfor _, g := range comments {\n \t\tfor specIndex+1 < len(specs) && pos[specIndex+1].Start <= g.Pos() {\n \t\t\tspecIndex++\n \t\t}\n-\t\tvar left bool\n-\t\t// A block comment can appear before the first import spec.\n-\t\tif specIndex == 0 && pos[specIndex].Start > g.Pos() {\n-\t\t\tleft = true\n-\t\t} else if specIndex+1 < len(specs) && // Or it can appear on the left of an import spec.\n-\t\t\tlineAt(fset, pos[specIndex].Start)+1 == lineAt(fset, g.Pos()) {\n-\t\t\tspecIndex++\n-\t\t\tleft = true\n-\t\t}\n \t\ts := specs[specIndex].(*ImportSpec)\n-\t\timportComments[s] = append(importComments[s], cgPos{left: left, cg: g})\n+\t\timportComments[s] = append(importComments[s], g)\n \t}\n \n \t// Sort the import specs by import path.\n \t// Remove duplicates, when possible without data loss.\n \t// Reassign the import paths to have the same position sequence.\n-\t// Reassign each comment to the spec on the same line.\n+\t// Reassign each comment to abut the end of its spec.\n \t// Sort the comments by new position.\n \tsort.Slice(specs, func(i, j int) bool {\n \t\tipath := importPath(specs[i])\n@@ -187,7 +160,7 @@ func sortSpecs(fset *token.FileSet, f *File, specs []Spec) []Spec {\n \t\t\tdeduped = append(deduped, s)\n \t\t} else {\n \t\t\tp := s.Pos()\n-\t\t\tfset.File(p).MergeLine(lineAt(fset, p))\n+\t\t\tfset.File(p).MergeLine(fset.Position(p).Line)\n \t\t}\n \t}\n \tspecs = deduped\n@@ -201,16 +174,8 @@ func sortSpecs(fset *token.FileSet, f *File, specs []Spec) []Spec {\n \t\ts.Path.ValuePos = pos[i].Start\n \t\ts.EndPos = pos[i].End\n \t\tfor _, g := range importComments[s] {\n-\t\t\tfor _, c := range g.cg.List {\n-\t\t\t\tif g.left {\n-\t\t\t\t\tc.Slash = pos[i].Start - 1\n-\t\t\t\t} else {\n-\t\t\t\t\t// An import spec can have both block comment and a line comment\n-\t\t\t\t\t// to its right. In that case, both of them will have the same pos.\n-\t\t\t\t\t// But while formatting the AST, the line comment gets moved to\n-\t\t\t\t\t// after the block comment.\n-\t\t\t\t\tc.Slash = pos[i].End\n-\t\t\t\t}\n+\t\t\tfor _, c := range g.List {\n+\t\t\t\tc.Slash = pos[i].End\n \t\t\t}\n \t\t}\n \t}"}, {"sha": "021c6eca22f558f244b3ca4d9176c5d405b4dd5d", "filename": "libgo/go/go/build/build.go", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -1003,27 +1003,25 @@ func (ctxt *Context) importGo(p *Package, path, srcDir string, mode ImportMode,\n \t\treturn errNoModules\n \t}\n \n+\t// Find the absolute source directory. hasSubdir does not handle\n+\t// relative paths (and can't because the callbacks don't support this).\n+\tabsSrcDir, err := filepath.Abs(srcDir)\n+\tif err != nil {\n+\t\treturn errNoModules\n+\t}\n+\n \t// If modules are not enabled, then the in-process code works fine and we should keep using it.\n-\t// TODO(bcmills): This assumes that the default is \"auto\" instead of \"on\".\n \tswitch os.Getenv(\"GO111MODULE\") {\n \tcase \"off\":\n \t\treturn errNoModules\n-\tcase \"on\":\n-\t\t// ok\n-\tdefault: // \"\", \"auto\", anything else\n-\t\t// Automatic mode: no module use in $GOPATH/src.\n-\t\tfor _, root := range gopath {\n-\t\t\tsub, ok := ctxt.hasSubdir(root, srcDir)\n-\t\t\tif ok && strings.HasPrefix(sub, \"src/\") {\n-\t\t\t\treturn errNoModules\n-\t\t\t}\n-\t\t}\n+\tdefault: // \"\", \"on\", \"auto\", anything else\n+\t\t// Maybe use modules.\n \t}\n \n \t// If the source directory is in GOROOT, then the in-process code works fine\n \t// and we should keep using it. Moreover, the 'go list' approach below doesn't\n \t// take standard-library vendoring into account and will fail.\n-\tif _, ok := ctxt.hasSubdir(filepath.Join(ctxt.GOROOT, \"src\"), srcDir); ok {\n+\tif _, ok := ctxt.hasSubdir(filepath.Join(ctxt.GOROOT, \"src\"), absSrcDir); ok {\n \t\treturn errNoModules\n \t}\n \n@@ -1036,20 +1034,18 @@ func (ctxt *Context) importGo(p *Package, path, srcDir string, mode ImportMode,\n \t}\n \n \t// Look to see if there is a go.mod.\n-\tabs, err := filepath.Abs(srcDir)\n-\tif err != nil {\n-\t\treturn errNoModules\n-\t}\n+\t// Since go1.13, it doesn't matter if we're inside GOPATH.\n+\tparent := absSrcDir\n \tfor {\n-\t\tinfo, err := os.Stat(filepath.Join(abs, \"go.mod\"))\n+\t\tinfo, err := os.Stat(filepath.Join(parent, \"go.mod\"))\n \t\tif err == nil && !info.IsDir() {\n \t\t\tbreak\n \t\t}\n-\t\td := filepath.Dir(abs)\n-\t\tif len(d) >= len(abs) {\n+\t\td := filepath.Dir(parent)\n+\t\tif len(d) >= len(parent) {\n \t\t\treturn errNoModules // reached top of file system, no go.mod\n \t\t}\n-\t\tabs = d\n+\t\tparent = d\n \t}\n \n \tcmd := exec.Command(\"go\", \"list\", \"-compiler=\"+ctxt.Compiler, \"-tags=\"+strings.Join(ctxt.BuildTags, \",\"), \"-installsuffix=\"+ctxt.InstallSuffix, \"-f={{.Dir}}\\n{{.ImportPath}}\\n{{.Root}}\\n{{.Goroot}}\\n\", path)"}, {"sha": "fb862459c8a3eab4c39a7d60e774dd7dc6885f7c", "filename": "libgo/go/go/build/deps_test.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -166,6 +166,7 @@ var pkgDeps = map[string][]string{\n \t\t\"syscall/js\",\n \t},\n \n+\t\"internal/cfg\":     {\"L0\"},\n \t\"internal/poll\":    {\"L0\", \"internal/oserror\", \"internal/race\", \"syscall\", \"time\", \"unicode/utf16\", \"unicode/utf8\", \"internal/syscall/windows\"},\n \t\"internal/testlog\": {\"L0\"},\n \t\"os\":               {\"L1\", \"os\", \"syscall\", \"time\", \"internal/oserror\", \"internal/poll\", \"internal/syscall/windows\", \"internal/syscall/unix\", \"internal/testlog\"},\n@@ -199,7 +200,7 @@ var pkgDeps = map[string][]string{\n \t\"testing\":               {\"L2\", \"flag\", \"fmt\", \"internal/race\", \"os\", \"runtime/debug\", \"runtime/pprof\", \"runtime/trace\", \"time\"},\n \t\"testing/iotest\":        {\"L2\", \"log\"},\n \t\"testing/quick\":         {\"L2\", \"flag\", \"fmt\", \"reflect\", \"time\"},\n-\t\"internal/testenv\":      {\"L2\", \"OS\", \"flag\", \"testing\", \"syscall\"},\n+\t\"internal/testenv\":      {\"L2\", \"OS\", \"flag\", \"testing\", \"syscall\", \"internal/cfg\"},\n \t\"internal/lazyregexp\":   {\"L2\", \"OS\", \"regexp\"},\n \t\"internal/lazytemplate\": {\"L2\", \"OS\", \"text/template\"},\n \n@@ -249,7 +250,7 @@ var pkgDeps = map[string][]string{\n \t\"compress/gzip\":                  {\"L4\", \"compress/flate\"},\n \t\"compress/lzw\":                   {\"L4\"},\n \t\"compress/zlib\":                  {\"L4\", \"compress/flate\"},\n-\t\"context\":                        {\"errors\", \"internal/oserror\", \"internal/reflectlite\", \"sync\", \"time\"},\n+\t\"context\":                        {\"errors\", \"internal/reflectlite\", \"sync\", \"time\"},\n \t\"database/sql\":                   {\"L4\", \"container/list\", \"context\", \"database/sql/driver\", \"database/sql/internal\"},\n \t\"database/sql/driver\":            {\"L4\", \"context\", \"time\", \"database/sql/internal\"},\n \t\"debug/dwarf\":                    {\"L4\"},"}, {"sha": "de793efa873f7a16f954f23886983c645c978956", "filename": "libgo/go/go/build/doc.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fgo%2Fbuild%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fgo%2Fbuild%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdoc.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -70,10 +70,11 @@\n // To distinguish build constraints from package documentation, a series of\n // build constraints must be followed by a blank line.\n //\n-// A build constraint is evaluated as the OR of space-separated options;\n-// each option evaluates as the AND of its comma-separated terms;\n-// and each term is an alphanumeric word or, preceded by !, its negation.\n-// That is, the build constraint:\n+// A build constraint is evaluated as the OR of space-separated options.\n+// Each option evaluates as the AND of its comma-separated terms.\n+// Each term consists of letters, digits, underscores, and dots.\n+// A term may be negated with a preceding !.\n+// For example, the build constraint:\n //\n //\t// +build linux,386 darwin,!cgo\n //"}, {"sha": "aebea506515515b78b6fb84ce7a3bc4d904b6f9e", "filename": "libgo/go/go/doc/testdata/issue10858.go", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ecb707cc5a58816d27908a7aa324c4b0bc67bb/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fissue10858.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ecb707cc5a58816d27908a7aa324c4b0bc67bb/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fissue10858.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fissue10858.go?ref=d6ecb707cc5a58816d27908a7aa324c4b0bc67bb", "patch": "@@ -1,102 +0,0 @@\n-package issue10858\n-\n-import \"unsafe\"\n-\n-// Should be ignored\n-\n-// First line\n-//\n-// Second line\n-type Type interface {\n-\t// Should be present\n-\n-\t// Align returns the alignment in bytes of a value of\n-\t// this type when allocated in memory.\n-\tAlign() int\n-\n-\t// FieldAlign returns the alignment in bytes of a value of\n-\t// this type when used as a field in a struct.\n-\tFieldAlign() int // adjacent comment\n-\n-\t//\tPtr: Elem\n-\t//\tSlice: Elem\n-\n-\t// Bits returns the size of the type in bits.\n-\n-\t//\n-\t// It panics if the type's Kind is not one of the\n-\t// sized or unsized Int, Uint, Float, or Complex kinds.\n-\tBits() int\n-\n-\t// Should be ignored\n-}\n-\n-// Should be ignored\n-\n-// NewType is a comment\n-//\n-// ending with this line.\n-func NewType() Type {}\n-\n-// Ignore\n-\n-// First line\n-//\n-// Second line\n-const (\n-\t// Should be ignored\n-\n-\t// C1 comment\n-\tC1 int = 1 << 0\n-\n-\t// Should\n-\t//\n-\t// be ignored\n-\n-\tC2 int = 1 << 1\n-\n-\t// C3 comment\n-\t//\n-\t// with a line gap\n-\tC3 int = 1 << 2\n-\n-\t// Should be ignored\n-)\n-\n-// Should be ignored\n-\n-// Should be ignored\n-\n-// TypeAlg is a\n-// copy of runtime.typeAlg\n-type TypeAlg struct {\n-\t// function for hashing objects of this type\n-\t//\n-\t//\n-\t// (ptr to object, seed) -> hash\n-\tHash func(unsafe.Pointer, uintptr) uintptr\n-\n-\t// include\n-\t// include\n-\n-\t// include\n-\n-\t// function for comparing objects of this type\n-\t// (ptr to object A, ptr to object B) -> ==?\n-\tEqual func(unsafe.Pointer, unsafe.Pointer) bool\n-\t// Should be ignored\n-}\n-\n-// Should be ignored\n-\n-// StructTag is a comment\n-//\n-//\n-// with 2 connecting lines\n-type StructTag string // adjacent comment\n-\n-// Should be ignored\n-\n-// Get returns the value associated with key in the tag string.\n-func (tag StructTag) Get(key string) string {\n-}"}, {"sha": "fa7d8484f12e528f19ea92c1ac8ea13b6ffe4f6e", "filename": "libgo/go/go/importer/importer.go", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fgo%2Fimporter%2Fimporter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fgo%2Fimporter%2Fimporter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fimporter%2Fimporter.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -29,17 +29,15 @@ type Lookup func(path string) (io.ReadCloser, error)\n // (if the package API depends on cgo-defined entities, the type\n // checker won't have access to those).\n //\n-// If lookup is nil, the default package lookup mechanism for the\n-// given compiler is used, and the resulting importer attempts\n-// to resolve relative and absolute import paths to canonical\n-// import path IDs before finding the imported file.\n+// The lookup function is called each time the resulting importer needs\n+// to resolve an import path. In this mode the importer can only be\n+// invoked with canonical import paths (not relative or absolute ones);\n+// it is assumed that the translation to canonical import paths is being\n+// done by the client of the importer.\n //\n-// If lookup is non-nil, then the returned importer calls lookup\n-// each time it needs to resolve an import path. In this mode\n-// the importer can only be invoked with canonical import paths\n-// (not relative or absolute ones); it is assumed that the translation\n-// to canonical import paths is being done by the client of the\n-// importer.\n+// A lookup function must be provided for correct module-aware operation.\n+// Deprecated: If lookup is nil, for backwards-compatibility, the importer\n+// will attempt to resolve imports in the $GOPATH workspace.\n func ForCompiler(fset *token.FileSet, compiler string, lookup Lookup) types.Importer {\n \tswitch compiler {\n \tcase \"gc\":"}, {"sha": "ba16b652246f11bcae4c99e21ca29420fb830f53", "filename": "libgo/go/go/parser/parser.go", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -63,7 +63,6 @@ type parser struct {\n \ttopScope   *ast.Scope        // top-most scope; may be pkgScope\n \tunresolved []*ast.Ident      // unresolved identifiers\n \timports    []*ast.ImportSpec // list of imports\n-\tinStruct   bool              // if set, parser is parsing a struct or interface (for comment collection)\n \n \t// Label scopes\n \t// (maintained by open/close LabelScope)\n@@ -338,15 +337,7 @@ func (p *parser) next() {\n \t\t// consume successor comments, if any\n \t\tendline = -1\n \t\tfor p.tok == token.COMMENT {\n-\t\t\tn := 1\n-\t\t\t// When inside a struct (or interface), we don't want to lose comments\n-\t\t\t// separated from individual field (or method) documentation by empty\n-\t\t\t// lines. Allow for some white space in this case and collect those\n-\t\t\t// comments as a group. See issue #10858 for details.\n-\t\t\tif p.inStruct {\n-\t\t\t\tn = 2\n-\t\t\t}\n-\t\t\tcomment, endline = p.consumeCommentGroup(n)\n+\t\t\tcomment, endline = p.consumeCommentGroup(1)\n \t\t}\n \n \t\tif endline+1 == p.file.Line(p.pos) {\n@@ -757,7 +748,6 @@ func (p *parser) parseStructType() *ast.StructType {\n \t}\n \n \tpos := p.expect(token.STRUCT)\n-\tp.inStruct = true\n \tlbrace := p.expect(token.LBRACE)\n \tscope := ast.NewScope(nil) // struct scope\n \tvar list []*ast.Field\n@@ -768,7 +758,6 @@ func (p *parser) parseStructType() *ast.StructType {\n \t\tlist = append(list, p.parseFieldDecl(scope))\n \t}\n \trbrace := p.expect(token.RBRACE)\n-\tp.inStruct = false\n \n \treturn &ast.StructType{\n \t\tStruct: pos,\n@@ -970,15 +959,13 @@ func (p *parser) parseInterfaceType() *ast.InterfaceType {\n \t}\n \n \tpos := p.expect(token.INTERFACE)\n-\tp.inStruct = true\n \tlbrace := p.expect(token.LBRACE)\n \tscope := ast.NewScope(nil) // interface scope\n \tvar list []*ast.Field\n \tfor p.tok == token.IDENT {\n \t\tlist = append(list, p.parseMethodSpec(scope))\n \t}\n \trbrace := p.expect(token.RBRACE)\n-\tp.inStruct = false\n \n \treturn &ast.InterfaceType{\n \t\tInterface: pos,"}, {"sha": "409b468f20a311c43e0e5db5a12e5f518d3399a7", "filename": "libgo/go/go/types/scope.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fgo%2Ftypes%2Fscope.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fgo%2Ftypes%2Fscope.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fscope.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -42,7 +42,7 @@ func NewScope(parent *Scope, pos, end token.Pos, comment string) *Scope {\n // Parent returns the scope's containing (parent) scope.\n func (s *Scope) Parent() *Scope { return s.parent }\n \n-// Len() returns the number of scope elements.\n+// Len returns the number of scope elements.\n func (s *Scope) Len() int { return len(s.elems) }\n \n // Names returns the scope's element names in sorted order.\n@@ -57,7 +57,7 @@ func (s *Scope) Names() []string {\n \treturn names\n }\n \n-// NumChildren() returns the number of scopes nested in s.\n+// NumChildren returns the number of scopes nested in s.\n func (s *Scope) NumChildren() int { return len(s.children) }\n \n // Child returns the i'th child scope for 0 <= i < NumChildren()."}, {"sha": "31c572f83b1234f8c48ad83a8d26513bce8343f0", "filename": "libgo/go/go/types/typestring.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fgo%2Ftypes%2Ftypestring.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fgo%2Ftypes%2Ftypestring.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftypestring.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -24,7 +24,7 @@ import (\n //\n type Qualifier func(*Package) string\n \n-// RelativeTo(pkg) returns a Qualifier that fully qualifies members of\n+// RelativeTo returns a Qualifier that fully qualifies members of\n // all packages other than pkg.\n func RelativeTo(pkg *Package) Qualifier {\n \tif pkg == nil {"}, {"sha": "19e4133f7d1911378f281412a3046e32d4be9da0", "filename": "libgo/go/golang.org/x/net/route/zsys_darwin.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fgolang.org%2Fx%2Fnet%2Froute%2Fzsys_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fgolang.org%2Fx%2Fnet%2Froute%2Fzsys_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgolang.org%2Fx%2Fnet%2Froute%2Fzsys_darwin.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -1,4 +1,4 @@\n-// Created by cgo -godefs - DO NOT EDIT\n+// Code generated by cmd/cgo -godefs; DO NOT EDIT.\n // cgo -godefs defs_darwin.go\n \n package route"}, {"sha": "8ed2d4d550c15b58210eed0e4c301a9712d591e4", "filename": "libgo/go/golang.org/x/net/route/zsys_dragonfly.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fgolang.org%2Fx%2Fnet%2Froute%2Fzsys_dragonfly.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fgolang.org%2Fx%2Fnet%2Froute%2Fzsys_dragonfly.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgolang.org%2Fx%2Fnet%2Froute%2Fzsys_dragonfly.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -1,4 +1,4 @@\n-// Created by cgo -godefs - DO NOT EDIT\n+// Code generated by cmd/cgo -godefs; DO NOT EDIT.\n // cgo -godefs defs_dragonfly.go\n \n package route"}, {"sha": "f36aaadb59f71a310c904993991911373ab05b03", "filename": "libgo/go/golang.org/x/net/route/zsys_freebsd_386.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fgolang.org%2Fx%2Fnet%2Froute%2Fzsys_freebsd_386.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fgolang.org%2Fx%2Fnet%2Froute%2Fzsys_freebsd_386.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgolang.org%2Fx%2Fnet%2Froute%2Fzsys_freebsd_386.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -1,4 +1,4 @@\n-// Created by cgo -godefs - DO NOT EDIT\n+// Code generated by cmd/cgo -godefs; DO NOT EDIT.\n // cgo -godefs defs_freebsd.go\n \n package route"}, {"sha": "4c639b82e4b3a3ed514648006fd5e001651c335e", "filename": "libgo/go/golang.org/x/net/route/zsys_freebsd_amd64.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fgolang.org%2Fx%2Fnet%2Froute%2Fzsys_freebsd_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fgolang.org%2Fx%2Fnet%2Froute%2Fzsys_freebsd_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgolang.org%2Fx%2Fnet%2Froute%2Fzsys_freebsd_amd64.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -1,4 +1,4 @@\n-// Created by cgo -godefs - DO NOT EDIT\n+// Code generated by cmd/cgo -godefs; DO NOT EDIT.\n // cgo -godefs defs_freebsd.go\n \n package route"}, {"sha": "710c1472b64397610228c94363315a20e799e60b", "filename": "libgo/go/golang.org/x/net/route/zsys_freebsd_arm.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fgolang.org%2Fx%2Fnet%2Froute%2Fzsys_freebsd_arm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fgolang.org%2Fx%2Fnet%2Froute%2Fzsys_freebsd_arm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgolang.org%2Fx%2Fnet%2Froute%2Fzsys_freebsd_arm.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -1,4 +1,4 @@\n-// Created by cgo -godefs - DO NOT EDIT\n+// Code generated by cmd/cgo -godefs; DO NOT EDIT.\n // cgo -godefs defs_freebsd.go\n \n package route"}, {"sha": "b4f66ca6cbc818ebfc1637e90afea30988e523ea", "filename": "libgo/go/golang.org/x/net/route/zsys_netbsd.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fgolang.org%2Fx%2Fnet%2Froute%2Fzsys_netbsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fgolang.org%2Fx%2Fnet%2Froute%2Fzsys_netbsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgolang.org%2Fx%2Fnet%2Froute%2Fzsys_netbsd.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -1,4 +1,4 @@\n-// Created by cgo -godefs - DO NOT EDIT\n+// Code generated by cmd/cgo -godefs; DO NOT EDIT.\n // cgo -godefs defs_netbsd.go\n \n package route"}, {"sha": "1021b4cea4f3dd1751fa772b14767b77ec7db157", "filename": "libgo/go/golang.org/x/net/route/zsys_openbsd.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fgolang.org%2Fx%2Fnet%2Froute%2Fzsys_openbsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fgolang.org%2Fx%2Fnet%2Froute%2Fzsys_openbsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgolang.org%2Fx%2Fnet%2Froute%2Fzsys_openbsd.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -1,4 +1,4 @@\n-// Created by cgo -godefs - DO NOT EDIT\n+// Code generated by cmd/cgo -godefs; DO NOT EDIT.\n // cgo -godefs defs_openbsd.go\n \n package route"}, {"sha": "4c2cf8ee8b6ee380fa4858c2cfd5dea664871afd", "filename": "libgo/go/internal/cfg/cfg.go", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Finternal%2Fcfg%2Fcfg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Finternal%2Fcfg%2Fcfg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fcfg%2Fcfg.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package cfg holds configuration shared by the Go command and internal/testenv.\n+// Definitions that don't need to be exposed outside of cmd/go should be in\n+// cmd/go/internal/cfg instead of this package.\n+package cfg\n+\n+// KnownEnv is a list of environment variables that affect the operation\n+// of the Go command.\n+const KnownEnv = `\n+\tAR\n+\tCC\n+\tCGO_CFLAGS\n+\tCGO_CFLAGS_ALLOW\n+\tCGO_CFLAGS_DISALLOW\n+\tCGO_CPPFLAGS\n+\tCGO_CPPFLAGS_ALLOW\n+\tCGO_CPPFLAGS_DISALLOW\n+\tCGO_CXXFLAGS\n+\tCGO_CXXFLAGS_ALLOW\n+\tCGO_CXXFLAGS_DISALLOW\n+\tCGO_ENABLED\n+\tCGO_FFLAGS\n+\tCGO_FFLAGS_ALLOW\n+\tCGO_FFLAGS_DISALLOW\n+\tCGO_LDFLAGS\n+\tCGO_LDFLAGS_ALLOW\n+\tCGO_LDFLAGS_DISALLOW\n+\tCXX\n+\tFC\n+\tGCCGO\n+\tGO111MODULE\n+\tGO386\n+\tGOARCH\n+\tGOARM\n+\tGOBIN\n+\tGOCACHE\n+\tGOENV\n+\tGOEXE\n+\tGOFLAGS\n+\tGOGCCFLAGS\n+\tGOHOSTARCH\n+\tGOHOSTOS\n+\tGOMIPS\n+\tGOMIPS64\n+\tGONOPROXY\n+\tGONOSUMDB\n+\tGOOS\n+\tGOPATH\n+\tGOPPC64\n+\tGOPRIVATE\n+\tGOPROXY\n+\tGOROOT\n+\tGOSUMDB\n+\tGOTMPDIR\n+\tGOTOOLDIR\n+\tGOWASM\n+\tGO_EXTLINK_ENABLED\n+\tPKG_CONFIG\n+`"}, {"sha": "28a1ab32d32c5fc03b9dfaf8587f77e9090ab4a0", "filename": "libgo/go/internal/oserror/errors.go", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Finternal%2Foserror%2Ferrors.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Finternal%2Foserror%2Ferrors.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Foserror%2Ferrors.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -15,50 +15,4 @@ var (\n \tErrExist      = errors.New(\"file already exists\")\n \tErrNotExist   = errors.New(\"file does not exist\")\n \tErrClosed     = errors.New(\"file already closed\")\n-\tErrTemporary  = temporaryError{}\n-\tErrTimeout    = timeoutError{}\n )\n-\n-type timeoutError struct{}\n-\n-func (timeoutError) Error() string { return \"deadline exceeded\" }\n-func (timeoutError) Timeout() bool { return true }\n-\n-type temporaryError struct{}\n-\n-func (temporaryError) Error() string   { return \"temporary error\" }\n-func (temporaryError) Temporary() bool { return true }\n-\n-// IsTimeout reports whether err indicates a timeout.\n-func IsTimeout(err error) bool {\n-\tfor err != nil {\n-\t\tif err == ErrTimeout {\n-\t\t\treturn true\n-\t\t}\n-\t\tif x, ok := err.(interface{ Timeout() bool }); ok {\n-\t\t\treturn x.Timeout()\n-\t\t}\n-\t\tif x, ok := err.(interface{ Is(error) bool }); ok && x.Is(ErrTimeout) {\n-\t\t\treturn true\n-\t\t}\n-\t\terr = errors.Unwrap(err)\n-\t}\n-\treturn false\n-}\n-\n-// IsTemporary reports whether err indicates a temporary condition.\n-func IsTemporary(err error) bool {\n-\tfor err != nil {\n-\t\tif err == ErrTemporary {\n-\t\t\treturn true\n-\t\t}\n-\t\tif x, ok := err.(interface{ Temporary() bool }); ok {\n-\t\t\treturn x.Temporary()\n-\t\t}\n-\t\tif x, ok := err.(interface{ Is(error) bool }); ok && x.Is(ErrTemporary) {\n-\t\t\treturn true\n-\t\t}\n-\t\terr = errors.Unwrap(err)\n-\t}\n-\treturn false\n-}"}, {"sha": "6d6a56a0c74719f63fe4ce192db9c9942bb63b17", "filename": "libgo/go/internal/oserror/errors_test.go", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ecb707cc5a58816d27908a7aa324c4b0bc67bb/libgo%2Fgo%2Finternal%2Foserror%2Ferrors_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ecb707cc5a58816d27908a7aa324c4b0bc67bb/libgo%2Fgo%2Finternal%2Foserror%2Ferrors_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Foserror%2Ferrors_test.go?ref=d6ecb707cc5a58816d27908a7aa324c4b0bc67bb", "patch": "@@ -1,63 +0,0 @@\n-package oserror_test\n-\n-import (\n-\t\"errors\"\n-\t\"fmt\"\n-\t\"internal/oserror\"\n-\t\"os\"\n-\t\"testing\"\n-)\n-\n-type ttError struct {\n-\ttimeout   bool\n-\ttemporary bool\n-}\n-\n-func (e ttError) Error() string {\n-\treturn fmt.Sprintf(\"ttError{timeout:%v temporary:%v}\", e.timeout, e.temporary)\n-}\n-func (e ttError) Timeout() bool   { return e.timeout }\n-func (e ttError) Temporary() bool { return e.temporary }\n-\n-type isError struct {\n-\terr error\n-}\n-\n-func (e isError) Error() string        { return fmt.Sprintf(\"isError(%v)\", e.err) }\n-func (e isError) Is(target error) bool { return e.err == target }\n-\n-func TestIsTimeout(t *testing.T) {\n-\tfor _, test := range []struct {\n-\t\twant bool\n-\t\terr  error\n-\t}{\n-\t\t{true, ttError{timeout: true}},\n-\t\t{true, isError{os.ErrTimeout}},\n-\t\t{true, os.ErrTimeout},\n-\t\t{true, fmt.Errorf(\"wrap: %w\", os.ErrTimeout)},\n-\t\t{false, ttError{timeout: false}},\n-\t\t{false, errors.New(\"error\")},\n-\t} {\n-\t\tif got, want := oserror.IsTimeout(test.err), test.want; got != want {\n-\t\t\tt.Errorf(\"IsTimeout(err) = %v, want %v\\n%+v\", got, want, test.err)\n-\t\t}\n-\t}\n-}\n-\n-func TestIsTemporary(t *testing.T) {\n-\tfor _, test := range []struct {\n-\t\twant bool\n-\t\terr  error\n-\t}{\n-\t\t{true, ttError{temporary: true}},\n-\t\t{true, isError{os.ErrTemporary}},\n-\t\t{true, os.ErrTemporary},\n-\t\t{true, fmt.Errorf(\"wrap: %w\", os.ErrTemporary)},\n-\t\t{false, ttError{temporary: false}},\n-\t\t{false, errors.New(\"error\")},\n-\t} {\n-\t\tif got, want := oserror.IsTemporary(test.err), test.want; got != want {\n-\t\t\tt.Errorf(\"IsTemporary(err) = %v, want %v\\n%+v\", got, want, test.err)\n-\t\t}\n-\t}\n-}"}, {"sha": "c0de50c1b46e55ba6c658dfa352ac1a2b67d17fb", "filename": "libgo/go/internal/poll/fd.go", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Finternal%2Fpoll%2Ffd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Finternal%2Fpoll%2Ffd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fpoll%2Ffd.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -11,7 +11,6 @@ package poll\n \n import (\n \t\"errors\"\n-\t\"internal/oserror\"\n )\n \n // ErrNetClosing is returned when a network descriptor is used after\n@@ -47,10 +46,6 @@ func (e *TimeoutError) Error() string   { return \"i/o timeout\" }\n func (e *TimeoutError) Timeout() bool   { return true }\n func (e *TimeoutError) Temporary() bool { return true }\n \n-func (e *TimeoutError) Is(target error) bool {\n-\treturn target == oserror.ErrTimeout || target == oserror.ErrTemporary\n-}\n-\n // ErrNotPollable is returned when the file or socket is not suitable\n // for event notification.\n var ErrNotPollable = errors.New(\"not pollable\")"}, {"sha": "3460054a676420547a7d63a00e4e3b6b30099ef7", "filename": "libgo/go/internal/testenv/testenv.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Finternal%2Ftestenv%2Ftestenv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Finternal%2Ftestenv%2Ftestenv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Ftestenv%2Ftestenv.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -13,6 +13,7 @@ package testenv\n import (\n \t\"errors\"\n \t\"flag\"\n+\t\"internal/cfg\"\n \t\"os\"\n \t\"os/exec\"\n \t\"path/filepath\"\n@@ -102,6 +103,12 @@ func GoToolPath(t testing.TB) string {\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n+\t// Add all environment variables that affect the Go command to test metadata.\n+\t// Cached test results will be invalidate when these variables change.\n+\t// See golang.org/issue/32285.\n+\tfor _, envVar := range strings.Fields(cfg.KnownEnv) {\n+\t\tos.Getenv(envVar)\n+\t}\n \treturn path\n }\n "}, {"sha": "0c9a488811b47531d29ecc9b86f38c3c2e25c0ba", "filename": "libgo/go/net/cgo_unix.go", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fcgo_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fcgo_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fcgo_unix.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -23,7 +23,6 @@ package net\n \n import (\n \t\"context\"\n-\t\"os\"\n \t\"syscall\"\n \t\"unsafe\"\n )\n@@ -57,16 +56,6 @@ func (eai addrinfoErrno) Error() string   { return bytePtrToString(libc_gai_stre\n func (eai addrinfoErrno) Temporary() bool { return eai == syscall.EAI_AGAIN }\n func (eai addrinfoErrno) Timeout() bool   { return false }\n \n-func (eai addrinfoErrno) Is(target error) bool {\n-\tswitch target {\n-\tcase os.ErrTemporary:\n-\t\treturn eai.Temporary()\n-\tcase os.ErrTimeout:\n-\t\treturn eai.Timeout()\n-\t}\n-\treturn false\n-}\n-\n type portLookupResult struct {\n \tport int\n \terr  error"}, {"sha": "a783b4661856287f9e7f606b5d99cc71b86bb9a2", "filename": "libgo/go/net/http/example_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fhttp%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fhttp%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fexample_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -132,7 +132,7 @@ func ExampleServer_Shutdown() {\n \n \tif err := srv.ListenAndServe(); err != http.ErrServerClosed {\n \t\t// Error starting or closing listener:\n-\t\tlog.Printf(\"HTTP server ListenAndServe: %v\", err)\n+\t\tlog.Fatalf(\"HTTP server ListenAndServe: %v\", err)\n \t}\n \n \t<-idleConnsClosed"}, {"sha": "d265cd3f726f1675b2816016a64e295ff9951e91", "filename": "libgo/go/net/http/export_test.go", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fhttp%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fhttp%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fexport_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -166,30 +166,40 @@ func (t *Transport) IdleConnCountForTesting(scheme, addr string) int {\n \treturn 0\n }\n \n-func (t *Transport) IdleConnChMapSizeForTesting() int {\n+func (t *Transport) IdleConnWaitMapSizeForTesting() int {\n \tt.idleMu.Lock()\n \tdefer t.idleMu.Unlock()\n-\treturn len(t.idleConnCh)\n+\treturn len(t.idleConnWait)\n }\n \n func (t *Transport) IsIdleForTesting() bool {\n \tt.idleMu.Lock()\n \tdefer t.idleMu.Unlock()\n-\treturn t.wantIdle\n+\treturn t.closeIdle\n }\n \n-func (t *Transport) RequestIdleConnChForTesting() {\n-\tt.getIdleConnCh(connectMethod{nil, \"http\", \"example.com\", false})\n+func (t *Transport) QueueForIdleConnForTesting() {\n+\tt.queueForIdleConn(nil)\n }\n \n+// PutIdleTestConn reports whether it was able to insert a fresh\n+// persistConn for scheme, addr into the idle connection pool.\n func (t *Transport) PutIdleTestConn(scheme, addr string) bool {\n \tc, _ := net.Pipe()\n \tkey := connectMethodKey{\"\", scheme, addr, false}\n-\tselect {\n-\tcase <-t.incHostConnCount(key):\n-\tdefault:\n-\t\treturn false\n+\n+\tif t.MaxConnsPerHost > 0 {\n+\t\t// Transport is tracking conns-per-host.\n+\t\t// Increment connection count to account\n+\t\t// for new persistConn created below.\n+\t\tt.connsPerHostMu.Lock()\n+\t\tif t.connsPerHost == nil {\n+\t\t\tt.connsPerHost = make(map[connectMethodKey]int)\n+\t\t}\n+\t\tt.connsPerHost[key]++\n+\t\tt.connsPerHostMu.Unlock()\n \t}\n+\n \treturn t.tryPutIdleConn(&persistConn{\n \t\tt:        t,\n \t\tconn:     c,                   // dummy"}, {"sha": "21921aba5fdd01e92e7aa6a1b5b299015034dcec", "filename": "libgo/go/net/http/h2_bundle.go", "status": "modified", "additions": 46, "deletions": 10, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fhttp%2Fh2_bundle.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fhttp%2Fh2_bundle.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fh2_bundle.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -3611,10 +3611,11 @@ func (p *http2pipe) Done() <-chan struct{} {\n }\n \n const (\n-\thttp2prefaceTimeout        = 10 * time.Second\n-\thttp2firstSettingsTimeout  = 2 * time.Second // should be in-flight with preface anyway\n-\thttp2handlerChunkWriteSize = 4 << 10\n-\thttp2defaultMaxStreams     = 250 // TODO: make this 100 as the GFE seems to?\n+\thttp2prefaceTimeout         = 10 * time.Second\n+\thttp2firstSettingsTimeout   = 2 * time.Second // should be in-flight with preface anyway\n+\thttp2handlerChunkWriteSize  = 4 << 10\n+\thttp2defaultMaxStreams      = 250 // TODO: make this 100 as the GFE seems to?\n+\thttp2maxQueuedControlFrames = 10000\n )\n \n var (\n@@ -3722,6 +3723,15 @@ func (s *http2Server) maxConcurrentStreams() uint32 {\n \treturn http2defaultMaxStreams\n }\n \n+// maxQueuedControlFrames is the maximum number of control frames like\n+// SETTINGS, PING and RST_STREAM that will be queued for writing before\n+// the connection is closed to prevent memory exhaustion attacks.\n+func (s *http2Server) maxQueuedControlFrames() int {\n+\t// TODO: if anybody asks, add a Server field, and remember to define the\n+\t// behavior of negative values.\n+\treturn http2maxQueuedControlFrames\n+}\n+\n type http2serverInternalState struct {\n \tmu          sync.Mutex\n \tactiveConns map[*http2serverConn]struct{}\n@@ -4065,6 +4075,7 @@ type http2serverConn struct {\n \tsawFirstSettings            bool // got the initial SETTINGS frame after the preface\n \tneedToSendSettingsAck       bool\n \tunackedSettings             int    // how many SETTINGS have we sent without ACKs?\n+\tqueuedControlFrames         int    // control frames in the writeSched queue\n \tclientMaxStreams            uint32 // SETTINGS_MAX_CONCURRENT_STREAMS from client (our PUSH_PROMISE limit)\n \tadvMaxStreams               uint32 // our SETTINGS_MAX_CONCURRENT_STREAMS advertised the client\n \tcurClientStreams            uint32 // number of open streams initiated by the client\n@@ -4456,6 +4467,14 @@ func (sc *http2serverConn) serve() {\n \t\t\t}\n \t\t}\n \n+\t\t// If the peer is causing us to generate a lot of control frames,\n+\t\t// but not reading them from us, assume they are trying to make us\n+\t\t// run out of memory.\n+\t\tif sc.queuedControlFrames > sc.srv.maxQueuedControlFrames() {\n+\t\t\tsc.vlogf(\"http2: too many control frames in send queue, closing connection\")\n+\t\t\treturn\n+\t\t}\n+\n \t\t// Start the shutdown timer after sending a GOAWAY. When sending GOAWAY\n \t\t// with no error code (graceful shutdown), don't start the timer until\n \t\t// all open streams have been completed.\n@@ -4657,6 +4676,14 @@ func (sc *http2serverConn) writeFrame(wr http2FrameWriteRequest) {\n \t}\n \n \tif !ignoreWrite {\n+\t\tif wr.isControl() {\n+\t\t\tsc.queuedControlFrames++\n+\t\t\t// For extra safety, detect wraparounds, which should not happen,\n+\t\t\t// and pull the plug.\n+\t\t\tif sc.queuedControlFrames < 0 {\n+\t\t\t\tsc.conn.Close()\n+\t\t\t}\n+\t\t}\n \t\tsc.writeSched.Push(wr)\n \t}\n \tsc.scheduleFrameWrite()\n@@ -4774,10 +4801,8 @@ func (sc *http2serverConn) wroteFrame(res http2frameWriteResult) {\n // If a frame is already being written, nothing happens. This will be called again\n // when the frame is done being written.\n //\n-// If a frame isn't being written we need to send one, the best frame\n-// to send is selected, preferring first things that aren't\n-// stream-specific (e.g. ACKing settings), and then finding the\n-// highest priority stream.\n+// If a frame isn't being written and we need to send one, the best frame\n+// to send is selected by writeSched.\n //\n // If a frame isn't being written and there's nothing else to send, we\n // flush the write buffer.\n@@ -4805,6 +4830,9 @@ func (sc *http2serverConn) scheduleFrameWrite() {\n \t\t}\n \t\tif !sc.inGoAway || sc.goAwayCode == http2ErrCodeNo {\n \t\t\tif wr, ok := sc.writeSched.Pop(); ok {\n+\t\t\t\tif wr.isControl() {\n+\t\t\t\t\tsc.queuedControlFrames--\n+\t\t\t\t}\n \t\t\t\tsc.startFrameWrite(wr)\n \t\t\t\tcontinue\n \t\t\t}\n@@ -5097,6 +5125,8 @@ func (sc *http2serverConn) processSettings(f *http2SettingsFrame) error {\n \tif err := f.ForeachSetting(sc.processSetting); err != nil {\n \t\treturn err\n \t}\n+\t// TODO: judging by RFC 7540, Section 6.5.3 each SETTINGS frame should be\n+\t// acknowledged individually, even if multiple are received before the ACK.\n \tsc.needToSendSettingsAck = true\n \tsc.scheduleFrameWrite()\n \treturn nil\n@@ -7451,7 +7481,7 @@ func (cc *http2ClientConn) roundTrip(req *Request) (res *Response, gotErrAfterRe\n \t\treq.Method != \"HEAD\" {\n \t\t// Request gzip only, not deflate. Deflate is ambiguous and\n \t\t// not as universally supported anyway.\n-\t\t// See: http://www.gzip.org/zlib/zlib_faq.html#faq38\n+\t\t// See: https://zlib.net/zlib_faq.html#faq39\n \t\t//\n \t\t// Note that we don't request this for HEAD requests,\n \t\t// due to a bug in nginx:\n@@ -9460,7 +9490,7 @@ type http2WriteScheduler interface {\n \n \t// Pop dequeues the next frame to write. Returns false if no frames can\n \t// be written. Frames with a given wr.StreamID() are Pop'd in the same\n-\t// order they are Push'd.\n+\t// order they are Push'd. No frames should be discarded except by CloseStream.\n \tPop() (wr http2FrameWriteRequest, ok bool)\n }\n \n@@ -9504,6 +9534,12 @@ func (wr http2FrameWriteRequest) StreamID() uint32 {\n \treturn wr.stream.id\n }\n \n+// isControl reports whether wr is a control frame for MaxQueuedControlFrames\n+// purposes. That includes non-stream frames and RST_STREAM frames.\n+func (wr http2FrameWriteRequest) isControl() bool {\n+\treturn wr.stream == nil\n+}\n+\n // DataSize returns the number of flow control bytes that must be consumed\n // to write this entire frame. This is 0 for non-DATA frames.\n func (wr http2FrameWriteRequest) DataSize() int {"}, {"sha": "230ca03d4f052d0f60d7c543c086171513fb947a", "filename": "libgo/go/net/http/header.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fhttp%2Fheader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fhttp%2Fheader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fheader.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -78,8 +78,12 @@ func (h Header) write(w io.Writer, trace *httptrace.ClientTrace) error {\n \treturn h.writeSubset(w, nil, trace)\n }\n \n-// Clone returns a copy of h.\n+// Clone returns a copy of h or nil if h is nil.\n func (h Header) Clone() Header {\n+\tif h == nil {\n+\t\treturn nil\n+\t}\n+\n \t// Find total number of values.\n \tnv := 0\n \tfor _, vv := range h {"}, {"sha": "a82504afe329e82a5a773ccab9d41b2d27201e4a", "filename": "libgo/go/net/http/header_test.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fhttp%2Fheader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fhttp%2Fheader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fheader_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -176,6 +176,14 @@ func TestHasToken(t *testing.T) {\n \t}\n }\n \n+func TestNilHeaderClone(t *testing.T) {\n+\tt1 := Header(nil)\n+\tt2 := t1.Clone()\n+\tif t2 != nil {\n+\t\tt.Errorf(\"cloned header does not match original: got: %+v; want: %+v\", t2, nil)\n+\t}\n+}\n+\n var testHeader = Header{\n \t\"Content-Length\": {\"123\"},\n \t\"Content-Type\":   {\"text/plain\"},"}, {"sha": "e8f7df29a14d41da098361f71105ae66a56c063c", "filename": "libgo/go/net/http/httputil/reverseproxy.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -199,6 +199,9 @@ func (p *ReverseProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n \tif req.ContentLength == 0 {\n \t\toutreq.Body = nil // Issue 16036: nil Body for http.Transport retries\n \t}\n+\tif outreq.Header == nil {\n+\t\toutreq.Header = make(http.Header) // Issue 33142: historical behavior was to always allocate\n+\t}\n \n \tp.Director(outreq)\n \toutreq.Close = false"}, {"sha": "7f9dc0800f8d91e62be983ae45ee5bfbf5c134e7", "filename": "libgo/go/net/http/httputil/reverseproxy_test.go", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -659,6 +659,26 @@ func TestReverseProxy_NilBody(t *testing.T) {\n \t}\n }\n \n+// Issue 33142: always allocate the request headers\n+func TestReverseProxy_AllocatedHeader(t *testing.T) {\n+\tproxyHandler := new(ReverseProxy)\n+\tproxyHandler.ErrorLog = log.New(ioutil.Discard, \"\", 0) // quiet for tests\n+\tproxyHandler.Director = func(*http.Request) {}         // noop\n+\tproxyHandler.Transport = RoundTripperFunc(func(req *http.Request) (*http.Response, error) {\n+\t\tif req.Header == nil {\n+\t\t\tt.Error(\"Header == nil; want a non-nil Header\")\n+\t\t}\n+\t\treturn nil, errors.New(\"done testing the interesting part; so force a 502 Gateway error\")\n+\t})\n+\n+\tproxyHandler.ServeHTTP(httptest.NewRecorder(), &http.Request{\n+\t\tMethod:     \"GET\",\n+\t\tURL:        &url.URL{Scheme: \"http\", Host: \"fake.tld\", Path: \"/\"},\n+\t\tProto:      \"HTTP/1.0\",\n+\t\tProtoMajor: 1,\n+\t})\n+}\n+\n // Issue 14237. Test ModifyResponse and that an error from it\n // causes the proxy to return StatusBadGateway, or StatusOK otherwise.\n func TestReverseProxyModifyResponse(t *testing.T) {"}, {"sha": "31d62083cb0ee3287a2f968735a325163d477693", "filename": "libgo/go/net/http/request.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -237,12 +237,12 @@ type Request struct {\n \tHost string\n \n \t// Form contains the parsed form data, including both the URL\n-\t// field's query parameters and the POST or PUT form data.\n+\t// field's query parameters and the PATCH, POST, or PUT form data.\n \t// This field is only available after ParseForm is called.\n \t// The HTTP client ignores Form and uses Body instead.\n \tForm url.Values\n \n-\t// PostForm contains the parsed form data from POST, PATCH,\n+\t// PostForm contains the parsed form data from PATCH, POST\n \t// or PUT body parameters.\n \t//\n \t// This field is only available after ParseForm is called.\n@@ -450,7 +450,7 @@ func (r *Request) Referer() string {\n \n // multipartByReader is a sentinel value.\n // Its presence in Request.MultipartForm indicates that parsing of the request\n-// body has been handed off to a MultipartReader instead of ParseMultipartFrom.\n+// body has been handed off to a MultipartReader instead of ParseMultipartForm.\n var multipartByReader = &multipart.Form{\n \tValue: make(map[string][]string),\n \tFile:  make(map[string][]*multipart.FileHeader),"}, {"sha": "cd9d796c2641494041cb0273700b973e49e8a609", "filename": "libgo/go/net/http/response.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fhttp%2Fresponse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fhttp%2Fresponse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fresponse.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -66,7 +66,7 @@ type Response struct {\n \t// The Body is automatically dechunked if the server replied\n \t// with a \"chunked\" Transfer-Encoding.\n \t//\n-\t// As of Go 1.12, the Body will be also implement io.Writer\n+\t// As of Go 1.12, the Body will also implement io.Writer\n \t// on a successful \"101 Switching Protocols\" response,\n \t// as used by WebSockets and HTTP/2's \"h2c\" mode.\n \tBody io.ReadCloser"}, {"sha": "61adda2604c89979c4e170912ab5abf615be6808", "filename": "libgo/go/net/http/serve_test.go", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -2407,6 +2407,7 @@ func TestTimeoutHandlerRace(t *testing.T) {\n }\n \n // See issues 8209 and 8414.\n+// Both issues involved panics in the implementation of TimeoutHandler.\n func TestTimeoutHandlerRaceHeader(t *testing.T) {\n \tsetParallel(t)\n \tdefer afterTest(t)\n@@ -2434,7 +2435,9 @@ func TestTimeoutHandlerRaceHeader(t *testing.T) {\n \t\t\tdefer func() { <-gate }()\n \t\t\tres, err := c.Get(ts.URL)\n \t\t\tif err != nil {\n-\t\t\t\tt.Error(err)\n+\t\t\t\t// We see ECONNRESET from the connection occasionally,\n+\t\t\t\t// and that's OK: this test is checking that the server does not panic.\n+\t\t\t\tt.Log(err)\n \t\t\t\treturn\n \t\t\t}\n \t\t\tdefer res.Body.Close()\n@@ -5507,19 +5510,23 @@ func TestServerSetKeepAlivesEnabledClosesConns(t *testing.T) {\n \tif a1 != a2 {\n \t\tt.Fatal(\"expected first two requests on same connection\")\n \t}\n-\tvar idle0 int\n-\tif !waitCondition(2*time.Second, 10*time.Millisecond, func() bool {\n-\t\tidle0 = tr.IdleConnKeyCountForTesting()\n-\t\treturn idle0 == 1\n-\t}) {\n-\t\tt.Fatalf(\"idle count before SetKeepAlivesEnabled called = %v; want 1\", idle0)\n+\taddr := strings.TrimPrefix(ts.URL, \"http://\")\n+\n+\t// The two requests should have used the same connection,\n+\t// and there should not have been a second connection that\n+\t// was created by racing dial against reuse.\n+\t// (The first get was completed when the second get started.)\n+\tn := tr.IdleConnCountForTesting(\"http\", addr)\n+\tif n != 1 {\n+\t\tt.Fatalf(\"idle count for %q after 2 gets = %d, want 1\", addr, n)\n \t}\n \n+\t// SetKeepAlivesEnabled should discard idle conns.\n \tts.Config.SetKeepAlivesEnabled(false)\n \n \tvar idle1 int\n \tif !waitCondition(2*time.Second, 10*time.Millisecond, func() bool {\n-\t\tidle1 = tr.IdleConnKeyCountForTesting()\n+\t\tidle1 = tr.IdleConnCountForTesting(\"http\", addr)\n \t\treturn idle1 == 0\n \t}) {\n \t\tt.Fatalf(\"idle count after SetKeepAlivesEnabled called = %v; want 0\", idle1)"}, {"sha": "aaf7b68eaff9404cde65a3b36f8531f335a3eef5", "filename": "libgo/go/net/http/server.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -231,13 +231,13 @@ type CloseNotifier interface {\n \n var (\n \t// ServerContextKey is a context key. It can be used in HTTP\n-\t// handlers with context.WithValue to access the server that\n+\t// handlers with Context.Value to access the server that\n \t// started the handler. The associated value will be of\n \t// type *Server.\n \tServerContextKey = &contextKey{\"http-server\"}\n \n \t// LocalAddrContextKey is a context key. It can be used in\n-\t// HTTP handlers with context.WithValue to access the local\n+\t// HTTP handlers with Context.Value to access the local\n \t// address the connection arrived on.\n \t// The associated value will be of type net.Addr.\n \tLocalAddrContextKey = &contextKey{\"local-addr\"}\n@@ -3182,8 +3182,8 @@ func (srv *Server) onceSetNextProtoDefaults() {\n // After such a timeout, writes by h to its ResponseWriter will return\n // ErrHandlerTimeout.\n //\n-// TimeoutHandler buffers all Handler writes to memory and does not\n-// support the Hijacker or Flusher interfaces.\n+// TimeoutHandler supports the Flusher and Pusher interfaces but does not\n+// support the Hijacker interface.\n func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler {\n \treturn &timeoutHandler{\n \t\thandler: h,"}, {"sha": "d22d6363815fbc050aee9d0ea917ee5c1b44871c", "filename": "libgo/go/net/http/socks_bundle.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fhttp%2Fsocks_bundle.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fhttp%2Fsocks_bundle.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fsocks_bundle.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -1,5 +1,5 @@\n // Code generated by golang.org/x/tools/cmd/bundle. DO NOT EDIT.\n-//go:generate bundle -o socks_bundle.go -dst net/http -prefix socks -underscore golang.org/x/net/internal/socks\n+//go:generate bundle -o socks_bundle.go -prefix socks golang.org/x/net/internal/socks\n \n // Package socks provides a SOCKS version 5 client implementation.\n //"}, {"sha": "ee279877e02e2cede7ed3e2016ce518642f89966", "filename": "libgo/go/net/http/transport.go", "status": "modified", "additions": 389, "deletions": 267, "changes": 656, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -57,15 +57,6 @@ var DefaultTransport RoundTripper = &Transport{\n // MaxIdleConnsPerHost.\n const DefaultMaxIdleConnsPerHost = 2\n \n-// connsPerHostClosedCh is a closed channel used by MaxConnsPerHost\n-// for the property that receives from a closed channel return the\n-// zero value.\n-var connsPerHostClosedCh = make(chan struct{})\n-\n-func init() {\n-\tclose(connsPerHostClosedCh)\n-}\n-\n // Transport is an implementation of RoundTripper that supports HTTP,\n // HTTPS, and HTTP proxies (for either HTTP or HTTPS with CONNECT).\n //\n@@ -102,21 +93,21 @@ func init() {\n // request is treated as idempotent but the header is not sent on the\n // wire.\n type Transport struct {\n-\tidleMu     sync.Mutex\n-\twantIdle   bool                                // user has requested to close all idle conns\n-\tidleConn   map[connectMethodKey][]*persistConn // most recently used at end\n-\tidleConnCh map[connectMethodKey]chan *persistConn\n-\tidleLRU    connLRU\n+\tidleMu       sync.Mutex\n+\tcloseIdle    bool                                // user has requested to close all idle conns\n+\tidleConn     map[connectMethodKey][]*persistConn // most recently used at end\n+\tidleConnWait map[connectMethodKey]wantConnQueue  // waiting getConns\n+\tidleLRU      connLRU\n \n \treqMu       sync.Mutex\n \treqCanceler map[*Request]func(error)\n \n \taltMu    sync.Mutex   // guards changing altProto only\n \taltProto atomic.Value // of nil or map[string]RoundTripper, key is URI scheme\n \n-\tconnCountMu          sync.Mutex\n-\tconnPerHostCount     map[connectMethodKey]int\n-\tconnPerHostAvailable map[connectMethodKey]chan struct{}\n+\tconnsPerHostMu   sync.Mutex\n+\tconnsPerHost     map[connectMethodKey]int\n+\tconnsPerHostWait map[connectMethodKey]wantConnQueue // waiting getConns\n \n \t// Proxy specifies a function to return a proxy for a given\n \t// Request. If the function returns a non-nil error, the\n@@ -203,11 +194,6 @@ type Transport struct {\n \t// active, and idle states. On limit violation, dials will block.\n \t//\n \t// Zero means no limit.\n-\t//\n-\t// For HTTP/2, this currently only controls the number of new\n-\t// connections being created at a time, instead of the total\n-\t// number. In practice, hosts using HTTP/2 only have about one\n-\t// idle connection, though.\n \tMaxConnsPerHost int\n \n \t// IdleConnTimeout is the maximum amount of time an idle\n@@ -543,7 +529,6 @@ func (t *Transport) roundTrip(req *Request) (*Response, error) {\n \t\tvar resp *Response\n \t\tif pconn.alt != nil {\n \t\t\t// HTTP/2 path.\n-\t\t\tt.putOrCloseIdleConn(pconn)\n \t\t\tt.setReqCanceler(req, nil) // not cancelable with CancelRequest\n \t\t\tresp, err = pconn.alt.RoundTrip(req)\n \t\t} else {\n@@ -554,7 +539,6 @@ func (t *Transport) roundTrip(req *Request) (*Response, error) {\n \t\t}\n \t\tif http2isNoCachedConnError(err) {\n \t\t\tt.removeIdleConn(pconn)\n-\t\t\tt.decHostConnCount(cm.key()) // clean up the persistent connection\n \t\t} else if !pconn.shouldRetryRequest(req, err) {\n \t\t\t// Issue 16465: return underlying net.Conn.Read error from peek,\n \t\t\t// as we've historically done.\n@@ -665,8 +649,7 @@ func (t *Transport) CloseIdleConnections() {\n \tt.idleMu.Lock()\n \tm := t.idleConn\n \tt.idleConn = nil\n-\tt.idleConnCh = nil\n-\tt.wantIdle = true\n+\tt.closeIdle = true // close newly idle connections\n \tt.idleLRU = connLRU{}\n \tt.idleMu.Unlock()\n \tfor _, conns := range m {\n@@ -727,6 +710,8 @@ func resetProxyConfig() {\n }\n \n func (t *Transport) connectMethodForRequest(treq *transportRequest) (cm connectMethod, err error) {\n+\t// TODO: the validPort check is redundant after CL 189258, as url.URL.Port\n+\t// only returns valid ports now. golang.org/issue/33600\n \tif port := treq.URL.Port(); !validPort(port) {\n \t\treturn cm, fmt.Errorf(\"invalid URL port %q\", port)\n \t}\n@@ -762,7 +747,7 @@ func (cm *connectMethod) proxyAuth() string {\n var (\n \terrKeepAlivesDisabled = errors.New(\"http: putIdleConn: keep alives disabled\")\n \terrConnBroken         = errors.New(\"http: putIdleConn: connection is in bad state\")\n-\terrWantIdle           = errors.New(\"http: putIdleConn: CloseIdleConnections was called\")\n+\terrCloseIdle          = errors.New(\"http: putIdleConn: CloseIdleConnections was called\")\n \terrTooManyIdle        = errors.New(\"http: putIdleConn: too many idle connections\")\n \terrTooManyIdleHost    = errors.New(\"http: putIdleConn: too many idle connections for host\")\n \terrCloseIdleConns     = errors.New(\"http: CloseIdleConnections called\")\n@@ -821,29 +806,56 @@ func (t *Transport) tryPutIdleConn(pconn *persistConn) error {\n \t\treturn errConnBroken\n \t}\n \tpconn.markReused()\n-\tkey := pconn.cacheKey\n \n \tt.idleMu.Lock()\n \tdefer t.idleMu.Unlock()\n \n-\twaitingDialer := t.idleConnCh[key]\n-\tselect {\n-\tcase waitingDialer <- pconn:\n-\t\t// We're done with this pconn and somebody else is\n-\t\t// currently waiting for a conn of this type (they're\n-\t\t// actively dialing, but this conn is ready\n-\t\t// first). Chrome calls this socket late binding. See\n-\t\t// https://insouciant.org/tech/connection-management-in-chromium/\n+\t// HTTP/2 (pconn.alt != nil) connections do not come out of the idle list,\n+\t// because multiple goroutines can use them simultaneously.\n+\t// If this is an HTTP/2 connection being \u201creturned,\u201d we're done.\n+\tif pconn.alt != nil && t.idleLRU.m[pconn] != nil {\n \t\treturn nil\n-\tdefault:\n-\t\tif waitingDialer != nil {\n-\t\t\t// They had populated this, but their dial won\n-\t\t\t// first, so we can clean up this map entry.\n-\t\t\tdelete(t.idleConnCh, key)\n+\t}\n+\n+\t// Deliver pconn to goroutine waiting for idle connection, if any.\n+\t// (They may be actively dialing, but this conn is ready first.\n+\t// Chrome calls this socket late binding.\n+\t// See https://insouciant.org/tech/connection-management-in-chromium/.)\n+\tkey := pconn.cacheKey\n+\tif q, ok := t.idleConnWait[key]; ok {\n+\t\tdone := false\n+\t\tif pconn.alt == nil {\n+\t\t\t// HTTP/1.\n+\t\t\t// Loop over the waiting list until we find a w that isn't done already, and hand it pconn.\n+\t\t\tfor q.len() > 0 {\n+\t\t\t\tw := q.popFront()\n+\t\t\t\tif w.tryDeliver(pconn, nil) {\n+\t\t\t\t\tdone = true\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// HTTP/2.\n+\t\t\t// Can hand the same pconn to everyone in the waiting list,\n+\t\t\t// and we still won't be done: we want to put it in the idle\n+\t\t\t// list unconditionally, for any future clients too.\n+\t\t\tfor q.len() > 0 {\n+\t\t\t\tw := q.popFront()\n+\t\t\t\tw.tryDeliver(pconn, nil)\n+\t\t\t}\n+\t\t}\n+\t\tif q.len() == 0 {\n+\t\t\tdelete(t.idleConnWait, key)\n+\t\t} else {\n+\t\t\tt.idleConnWait[key] = q\n+\t\t}\n+\t\tif done {\n+\t\t\treturn nil\n \t\t}\n \t}\n-\tif t.wantIdle {\n-\t\treturn errWantIdle\n+\n+\tif t.closeIdle {\n+\t\treturn errCloseIdle\n \t}\n \tif t.idleConn == nil {\n \t\tt.idleConn = make(map[connectMethodKey][]*persistConn)\n@@ -864,71 +876,87 @@ func (t *Transport) tryPutIdleConn(pconn *persistConn) error {\n \t\toldest.close(errTooManyIdle)\n \t\tt.removeIdleConnLocked(oldest)\n \t}\n-\tif t.IdleConnTimeout > 0 {\n+\n+\t// Set idle timer, but only for HTTP/1 (pconn.alt == nil).\n+\t// The HTTP/2 implementation manages the idle timer itself\n+\t// (see idleConnTimeout in h2_bundle.go).\n+\tif t.IdleConnTimeout > 0 && pconn.alt == nil {\n \t\tif pconn.idleTimer != nil {\n \t\t\tpconn.idleTimer.Reset(t.IdleConnTimeout)\n \t\t} else {\n-\t\t\t// idleTimer does not apply to HTTP/2\n-\t\t\tif pconn.alt == nil {\n-\t\t\t\tpconn.idleTimer = time.AfterFunc(t.IdleConnTimeout, pconn.closeConnIfStillIdle)\n-\t\t\t}\n+\t\t\tpconn.idleTimer = time.AfterFunc(t.IdleConnTimeout, pconn.closeConnIfStillIdle)\n \t\t}\n \t}\n \tpconn.idleAt = time.Now()\n \treturn nil\n }\n \n-// getIdleConnCh returns a channel to receive and return idle\n-// persistent connection for the given connectMethod.\n-// It may return nil, if persistent connections are not being used.\n-func (t *Transport) getIdleConnCh(cm connectMethod) chan *persistConn {\n+// queueForIdleConn queues w to receive the next idle connection for w.cm.\n+// As an optimization hint to the caller, queueForIdleConn reports whether\n+// it successfully delivered an already-idle connection.\n+func (t *Transport) queueForIdleConn(w *wantConn) (delivered bool) {\n \tif t.DisableKeepAlives {\n-\t\treturn nil\n+\t\treturn false\n \t}\n-\tkey := cm.key()\n+\n \tt.idleMu.Lock()\n \tdefer t.idleMu.Unlock()\n-\tt.wantIdle = false\n-\tif t.idleConnCh == nil {\n-\t\tt.idleConnCh = make(map[connectMethodKey]chan *persistConn)\n-\t}\n-\tch, ok := t.idleConnCh[key]\n-\tif !ok {\n-\t\tch = make(chan *persistConn)\n-\t\tt.idleConnCh[key] = ch\n+\n+\t// Stop closing connections that become idle - we might want one.\n+\t// (That is, undo the effect of t.CloseIdleConnections.)\n+\tt.closeIdle = false\n+\n+\tif w == nil {\n+\t\t// Happens in test hook.\n+\t\treturn false\n \t}\n-\treturn ch\n-}\n \n-func (t *Transport) getIdleConn(cm connectMethod) (pconn *persistConn, idleSince time.Time) {\n-\tkey := cm.key()\n-\tt.idleMu.Lock()\n-\tdefer t.idleMu.Unlock()\n-\tfor {\n-\t\tpconns, ok := t.idleConn[key]\n-\t\tif !ok {\n-\t\t\treturn nil, time.Time{}\n+\t// Look for most recently-used idle connection.\n+\tif list, ok := t.idleConn[w.key]; ok {\n+\t\tstop := false\n+\t\tdelivered := false\n+\t\tfor len(list) > 0 && !stop {\n+\t\t\tpconn := list[len(list)-1]\n+\t\t\tif pconn.isBroken() {\n+\t\t\t\t// persistConn.readLoop has marked the connection broken,\n+\t\t\t\t// but Transport.removeIdleConn has not yet removed it from the idle list.\n+\t\t\t\t// Drop on floor on behalf of Transport.removeIdleConn.\n+\t\t\t\tlist = list[:len(list)-1]\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tdelivered = w.tryDeliver(pconn, nil)\n+\t\t\tif delivered {\n+\t\t\t\tif pconn.alt != nil {\n+\t\t\t\t\t// HTTP/2: multiple clients can share pconn.\n+\t\t\t\t\t// Leave it in the list.\n+\t\t\t\t} else {\n+\t\t\t\t\t// HTTP/1: only one client can use pconn.\n+\t\t\t\t\t// Remove it from the list.\n+\t\t\t\t\tt.idleLRU.remove(pconn)\n+\t\t\t\t\tlist = list[:len(list)-1]\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tstop = true\n \t\t}\n-\t\tif len(pconns) == 1 {\n-\t\t\tpconn = pconns[0]\n-\t\t\tdelete(t.idleConn, key)\n+\t\tif len(list) > 0 {\n+\t\t\tt.idleConn[w.key] = list\n \t\t} else {\n-\t\t\t// 2 or more cached connections; use the most\n-\t\t\t// recently used one at the end.\n-\t\t\tpconn = pconns[len(pconns)-1]\n-\t\t\tt.idleConn[key] = pconns[:len(pconns)-1]\n+\t\t\tdelete(t.idleConn, w.key)\n \t\t}\n-\t\tt.idleLRU.remove(pconn)\n-\t\tif pconn.isBroken() {\n-\t\t\t// There is a tiny window where this is\n-\t\t\t// possible, between the connecting dying and\n-\t\t\t// the persistConn readLoop calling\n-\t\t\t// Transport.removeIdleConn. Just skip it and\n-\t\t\t// carry on.\n-\t\t\tcontinue\n+\t\tif stop {\n+\t\t\treturn delivered\n \t\t}\n-\t\treturn pconn, pconn.idleAt\n \t}\n+\n+\t// Register to receive next connection that becomes idle.\n+\tif t.idleConnWait == nil {\n+\t\tt.idleConnWait = make(map[connectMethodKey]wantConnQueue)\n+\t}\n+\tq := t.idleConnWait[w.key]\n+\tq.cleanFront()\n+\tq.pushBack(w)\n+\tt.idleConnWait[w.key] = q\n+\treturn false\n }\n \n // removeIdleConn marks pconn as dead.\n@@ -1015,20 +1043,171 @@ func (t *Transport) dial(ctx context.Context, network, addr string) (net.Conn, e\n \treturn zeroDialer.DialContext(ctx, network, addr)\n }\n \n+// A wantConn records state about a wanted connection\n+// (that is, an active call to getConn).\n+// The conn may be gotten by dialing or by finding an idle connection,\n+// or a cancellation may make the conn no longer wanted.\n+// These three options are racing against each other and use\n+// wantConn to coordinate and agree about the winning outcome.\n+type wantConn struct {\n+\tcm    connectMethod\n+\tkey   connectMethodKey // cm.key()\n+\tctx   context.Context  // context for dial\n+\tready chan struct{}    // closed when pc, err pair is delivered\n+\n+\t// hooks for testing to know when dials are done\n+\t// beforeDial is called in the getConn goroutine when the dial is queued.\n+\t// afterDial is called when the dial is completed or cancelled.\n+\tbeforeDial func()\n+\tafterDial  func()\n+\n+\tmu  sync.Mutex // protects pc, err, close(ready)\n+\tpc  *persistConn\n+\terr error\n+}\n+\n+// waiting reports whether w is still waiting for an answer (connection or error).\n+func (w *wantConn) waiting() bool {\n+\tselect {\n+\tcase <-w.ready:\n+\t\treturn false\n+\tdefault:\n+\t\treturn true\n+\t}\n+}\n+\n+// tryDeliver attempts to deliver pc, err to w and reports whether it succeeded.\n+func (w *wantConn) tryDeliver(pc *persistConn, err error) bool {\n+\tw.mu.Lock()\n+\tdefer w.mu.Unlock()\n+\n+\tif w.pc != nil || w.err != nil {\n+\t\treturn false\n+\t}\n+\n+\tw.pc = pc\n+\tw.err = err\n+\tif w.pc == nil && w.err == nil {\n+\t\tpanic(\"net/http: internal error: misuse of tryDeliver\")\n+\t}\n+\tclose(w.ready)\n+\treturn true\n+}\n+\n+// cancel marks w as no longer wanting a result (for example, due to cancellation).\n+// If a connection has been delivered already, cancel returns it with t.putOrCloseIdleConn.\n+func (w *wantConn) cancel(t *Transport, err error) {\n+\tw.mu.Lock()\n+\tif w.pc == nil && w.err == nil {\n+\t\tclose(w.ready) // catch misbehavior in future delivery\n+\t}\n+\tpc := w.pc\n+\tw.pc = nil\n+\tw.err = err\n+\tw.mu.Unlock()\n+\n+\tif pc != nil {\n+\t\tt.putOrCloseIdleConn(pc)\n+\t}\n+}\n+\n+// A wantConnQueue is a queue of wantConns.\n+type wantConnQueue struct {\n+\t// This is a queue, not a deque.\n+\t// It is split into two stages - head[headPos:] and tail.\n+\t// popFront is trivial (headPos++) on the first stage, and\n+\t// pushBack is trivial (append) on the second stage.\n+\t// If the first stage is empty, popFront can swap the\n+\t// first and second stages to remedy the situation.\n+\t//\n+\t// This two-stage split is analogous to the use of two lists\n+\t// in Okasaki's purely functional queue but without the\n+\t// overhead of reversing the list when swapping stages.\n+\thead    []*wantConn\n+\theadPos int\n+\ttail    []*wantConn\n+}\n+\n+// len returns the number of items in the queue.\n+func (q *wantConnQueue) len() int {\n+\treturn len(q.head) - q.headPos + len(q.tail)\n+}\n+\n+// pushBack adds w to the back of the queue.\n+func (q *wantConnQueue) pushBack(w *wantConn) {\n+\tq.tail = append(q.tail, w)\n+}\n+\n+// popFront removes and returns the wantConn at the front of the queue.\n+func (q *wantConnQueue) popFront() *wantConn {\n+\tif q.headPos >= len(q.head) {\n+\t\tif len(q.tail) == 0 {\n+\t\t\treturn nil\n+\t\t}\n+\t\t// Pick up tail as new head, clear tail.\n+\t\tq.head, q.headPos, q.tail = q.tail, 0, q.head[:0]\n+\t}\n+\tw := q.head[q.headPos]\n+\tq.head[q.headPos] = nil\n+\tq.headPos++\n+\treturn w\n+}\n+\n+// peekFront returns the wantConn at the front of the queue without removing it.\n+func (q *wantConnQueue) peekFront() *wantConn {\n+\tif q.headPos < len(q.head) {\n+\t\treturn q.head[q.headPos]\n+\t}\n+\tif len(q.tail) > 0 {\n+\t\treturn q.tail[0]\n+\t}\n+\treturn nil\n+}\n+\n+// cleanFront pops any wantConns that are no longer waiting from the head of the\n+// queue, reporting whether any were popped.\n+func (q *wantConnQueue) cleanFront() (cleaned bool) {\n+\tfor {\n+\t\tw := q.peekFront()\n+\t\tif w == nil || w.waiting() {\n+\t\t\treturn cleaned\n+\t\t}\n+\t\tq.popFront()\n+\t\tcleaned = true\n+\t}\n+}\n+\n // getConn dials and creates a new persistConn to the target as\n // specified in the connectMethod. This includes doing a proxy CONNECT\n // and/or setting up TLS.  If this doesn't return an error, the persistConn\n // is ready to write requests to.\n-func (t *Transport) getConn(treq *transportRequest, cm connectMethod) (*persistConn, error) {\n+func (t *Transport) getConn(treq *transportRequest, cm connectMethod) (pc *persistConn, err error) {\n \treq := treq.Request\n \ttrace := treq.trace\n \tctx := req.Context()\n \tif trace != nil && trace.GetConn != nil {\n \t\ttrace.GetConn(cm.addr())\n \t}\n-\tif pc, idleSince := t.getIdleConn(cm); pc != nil {\n+\n+\tw := &wantConn{\n+\t\tcm:         cm,\n+\t\tkey:        cm.key(),\n+\t\tctx:        ctx,\n+\t\tready:      make(chan struct{}, 1),\n+\t\tbeforeDial: testHookPrePendingDial,\n+\t\tafterDial:  testHookPostPendingDial,\n+\t}\n+\tdefer func() {\n+\t\tif err != nil {\n+\t\t\tw.cancel(t, err)\n+\t\t}\n+\t}()\n+\n+\t// Queue for idle connection.\n+\tif delivered := t.queueForIdleConn(w); delivered {\n+\t\tpc := w.pc\n \t\tif trace != nil && trace.GotConn != nil {\n-\t\t\ttrace.GotConn(pc.gotIdleConnTrace(idleSince))\n+\t\t\ttrace.GotConn(pc.gotIdleConnTrace(pc.idleAt))\n \t\t}\n \t\t// set request canceler to some non-nil function so we\n \t\t// can detect whether it was cleared between now and when\n@@ -1037,190 +1216,148 @@ func (t *Transport) getConn(treq *transportRequest, cm connectMethod) (*persistC\n \t\treturn pc, nil\n \t}\n \n-\ttype dialRes struct {\n-\t\tpc  *persistConn\n-\t\terr error\n-\t}\n-\tdialc := make(chan dialRes)\n-\tcmKey := cm.key()\n-\n-\t// Copy these hooks so we don't race on the postPendingDial in\n-\t// the goroutine we launch. Issue 11136.\n-\ttestHookPrePendingDial := testHookPrePendingDial\n-\ttestHookPostPendingDial := testHookPostPendingDial\n-\n-\thandlePendingDial := func() {\n-\t\ttestHookPrePendingDial()\n-\t\tgo func() {\n-\t\t\tif v := <-dialc; v.err == nil {\n-\t\t\t\tt.putOrCloseIdleConn(v.pc)\n-\t\t\t} else {\n-\t\t\t\tt.decHostConnCount(cmKey)\n-\t\t\t}\n-\t\t\ttestHookPostPendingDial()\n-\t\t}()\n-\t}\n-\n \tcancelc := make(chan error, 1)\n \tt.setReqCanceler(req, func(err error) { cancelc <- err })\n \n-\tif t.MaxConnsPerHost > 0 {\n-\t\tselect {\n-\t\tcase <-t.incHostConnCount(cmKey):\n-\t\t\t// count below conn per host limit; proceed\n-\t\tcase pc := <-t.getIdleConnCh(cm):\n-\t\t\tif trace != nil && trace.GotConn != nil {\n-\t\t\t\ttrace.GotConn(httptrace.GotConnInfo{Conn: pc.conn, Reused: pc.isReused()})\n-\t\t\t}\n-\t\t\treturn pc, nil\n-\t\tcase <-req.Cancel:\n-\t\t\treturn nil, errRequestCanceledConn\n-\t\tcase <-req.Context().Done():\n-\t\t\treturn nil, req.Context().Err()\n-\t\tcase err := <-cancelc:\n-\t\t\tif err == errRequestCanceled {\n-\t\t\t\terr = errRequestCanceledConn\n-\t\t\t}\n-\t\t\treturn nil, err\n-\t\t}\n-\t}\n+\t// Queue for permission to dial.\n+\tt.queueForDial(w)\n \n-\tgo func() {\n-\t\tpc, err := t.dialConn(ctx, cm)\n-\t\tdialc <- dialRes{pc, err}\n-\t}()\n-\n-\tidleConnCh := t.getIdleConnCh(cm)\n+\t// Wait for completion or cancellation.\n \tselect {\n-\tcase v := <-dialc:\n-\t\t// Our dial finished.\n-\t\tif v.pc != nil {\n-\t\t\tif trace != nil && trace.GotConn != nil && v.pc.alt == nil {\n-\t\t\t\ttrace.GotConn(httptrace.GotConnInfo{Conn: v.pc.conn})\n+\tcase <-w.ready:\n+\t\t// Trace success but only for HTTP/1.\n+\t\t// HTTP/2 calls trace.GotConn itself.\n+\t\tif w.pc != nil && w.pc.alt == nil && trace != nil && trace.GotConn != nil {\n+\t\t\ttrace.GotConn(httptrace.GotConnInfo{Conn: w.pc.conn, Reused: w.pc.isReused()})\n+\t\t}\n+\t\tif w.err != nil {\n+\t\t\t// If the request has been cancelled, that's probably\n+\t\t\t// what caused w.err; if so, prefer to return the\n+\t\t\t// cancellation error (see golang.org/issue/16049).\n+\t\t\tselect {\n+\t\t\tcase <-req.Cancel:\n+\t\t\t\treturn nil, errRequestCanceledConn\n+\t\t\tcase <-req.Context().Done():\n+\t\t\t\treturn nil, req.Context().Err()\n+\t\t\tcase err := <-cancelc:\n+\t\t\t\tif err == errRequestCanceled {\n+\t\t\t\t\terr = errRequestCanceledConn\n+\t\t\t\t}\n+\t\t\t\treturn nil, err\n+\t\t\tdefault:\n+\t\t\t\t// return below\n \t\t\t}\n-\t\t\treturn v.pc, nil\n \t\t}\n-\t\t// Our dial failed. See why to return a nicer error\n-\t\t// value.\n-\t\tt.decHostConnCount(cmKey)\n-\t\tselect {\n-\t\tcase <-req.Cancel:\n-\t\t\t// It was an error due to cancellation, so prioritize that\n-\t\t\t// error value. (Issue 16049)\n-\t\t\treturn nil, errRequestCanceledConn\n-\t\tcase <-req.Context().Done():\n-\t\t\treturn nil, req.Context().Err()\n-\t\tcase err := <-cancelc:\n-\t\t\tif err == errRequestCanceled {\n-\t\t\t\terr = errRequestCanceledConn\n-\t\t\t}\n-\t\t\treturn nil, err\n-\t\tdefault:\n-\t\t\t// It wasn't an error due to cancellation, so\n-\t\t\t// return the original error message:\n-\t\t\treturn nil, v.err\n-\t\t}\n-\tcase pc := <-idleConnCh:\n-\t\t// Another request finished first and its net.Conn\n-\t\t// became available before our dial. Or somebody\n-\t\t// else's dial that they didn't use.\n-\t\t// But our dial is still going, so give it away\n-\t\t// when it finishes:\n-\t\thandlePendingDial()\n-\t\tif trace != nil && trace.GotConn != nil {\n-\t\t\ttrace.GotConn(httptrace.GotConnInfo{Conn: pc.conn, Reused: pc.isReused()})\n-\t\t}\n-\t\treturn pc, nil\n+\t\treturn w.pc, w.err\n \tcase <-req.Cancel:\n-\t\thandlePendingDial()\n \t\treturn nil, errRequestCanceledConn\n \tcase <-req.Context().Done():\n-\t\thandlePendingDial()\n \t\treturn nil, req.Context().Err()\n \tcase err := <-cancelc:\n-\t\thandlePendingDial()\n \t\tif err == errRequestCanceled {\n \t\t\terr = errRequestCanceledConn\n \t\t}\n \t\treturn nil, err\n \t}\n }\n \n-// incHostConnCount increments the count of connections for a\n-// given host. It returns an already-closed channel if the count\n-// is not at its limit; otherwise it returns a channel which is\n-// notified when the count is below the limit.\n-func (t *Transport) incHostConnCount(cmKey connectMethodKey) <-chan struct{} {\n+// queueForDial queues w to wait for permission to begin dialing.\n+// Once w receives permission to dial, it will do so in a separate goroutine.\n+func (t *Transport) queueForDial(w *wantConn) {\n+\tw.beforeDial()\n \tif t.MaxConnsPerHost <= 0 {\n-\t\treturn connsPerHostClosedCh\n+\t\tgo t.dialConnFor(w)\n+\t\treturn\n \t}\n-\tt.connCountMu.Lock()\n-\tdefer t.connCountMu.Unlock()\n-\tif t.connPerHostCount[cmKey] == t.MaxConnsPerHost {\n-\t\tif t.connPerHostAvailable == nil {\n-\t\t\tt.connPerHostAvailable = make(map[connectMethodKey]chan struct{})\n-\t\t}\n-\t\tch, ok := t.connPerHostAvailable[cmKey]\n-\t\tif !ok {\n-\t\t\tch = make(chan struct{})\n-\t\t\tt.connPerHostAvailable[cmKey] = ch\n+\n+\tt.connsPerHostMu.Lock()\n+\tdefer t.connsPerHostMu.Unlock()\n+\n+\tif n := t.connsPerHost[w.key]; n < t.MaxConnsPerHost {\n+\t\tif t.connsPerHost == nil {\n+\t\t\tt.connsPerHost = make(map[connectMethodKey]int)\n \t\t}\n-\t\treturn ch\n+\t\tt.connsPerHost[w.key] = n + 1\n+\t\tgo t.dialConnFor(w)\n+\t\treturn\n \t}\n-\tif t.connPerHostCount == nil {\n-\t\tt.connPerHostCount = make(map[connectMethodKey]int)\n+\n+\tif t.connsPerHostWait == nil {\n+\t\tt.connsPerHostWait = make(map[connectMethodKey]wantConnQueue)\n \t}\n-\tt.connPerHostCount[cmKey]++\n-\t// return a closed channel to avoid race: if decHostConnCount is called\n-\t// after incHostConnCount and during the nil check, decHostConnCount\n-\t// will delete the channel since it's not being listened on yet.\n-\treturn connsPerHostClosedCh\n+\tq := t.connsPerHostWait[w.key]\n+\tq.cleanFront()\n+\tq.pushBack(w)\n+\tt.connsPerHostWait[w.key] = q\n }\n \n-// decHostConnCount decrements the count of connections\n-// for a given host.\n-// See Transport.MaxConnsPerHost.\n-func (t *Transport) decHostConnCount(cmKey connectMethodKey) {\n+// dialConnFor dials on behalf of w and delivers the result to w.\n+// dialConnFor has received permission to dial w.cm and is counted in t.connCount[w.cm.key()].\n+// If the dial is cancelled or unsuccessful, dialConnFor decrements t.connCount[w.cm.key()].\n+func (t *Transport) dialConnFor(w *wantConn) {\n+\tdefer w.afterDial()\n+\n+\tpc, err := t.dialConn(w.ctx, w.cm)\n+\tdelivered := w.tryDeliver(pc, err)\n+\tif err == nil && (!delivered || pc.alt != nil) {\n+\t\t// pconn was not passed to w,\n+\t\t// or it is HTTP/2 and can be shared.\n+\t\t// Add to the idle connection pool.\n+\t\tt.putOrCloseIdleConn(pc)\n+\t}\n+\tif err != nil {\n+\t\tt.decConnsPerHost(w.key)\n+\t}\n+}\n+\n+// decConnsPerHost decrements the per-host connection count for key,\n+// which may in turn give a different waiting goroutine permission to dial.\n+func (t *Transport) decConnsPerHost(key connectMethodKey) {\n \tif t.MaxConnsPerHost <= 0 {\n \t\treturn\n \t}\n-\tt.connCountMu.Lock()\n-\tdefer t.connCountMu.Unlock()\n-\tt.connPerHostCount[cmKey]--\n-\tselect {\n-\tcase t.connPerHostAvailable[cmKey] <- struct{}{}:\n-\tdefault:\n-\t\t// close channel before deleting avoids getConn waiting forever in\n-\t\t// case getConn has reference to channel but hasn't started waiting.\n-\t\t// This could lead to more than MaxConnsPerHost in the unlikely case\n-\t\t// that > 1 go routine has fetched the channel but none started waiting.\n-\t\tif t.connPerHostAvailable[cmKey] != nil {\n-\t\t\tclose(t.connPerHostAvailable[cmKey])\n+\n+\tt.connsPerHostMu.Lock()\n+\tdefer t.connsPerHostMu.Unlock()\n+\tn := t.connsPerHost[key]\n+\tif n == 0 {\n+\t\t// Shouldn't happen, but if it does, the counting is buggy and could\n+\t\t// easily lead to a silent deadlock, so report the problem loudly.\n+\t\tpanic(\"net/http: internal error: connCount underflow\")\n+\t}\n+\n+\t// Can we hand this count to a goroutine still waiting to dial?\n+\t// (Some goroutines on the wait list may have timed out or\n+\t// gotten a connection another way. If they're all gone,\n+\t// we don't want to kick off any spurious dial operations.)\n+\tif q := t.connsPerHostWait[key]; q.len() > 0 {\n+\t\tdone := false\n+\t\tfor q.len() > 0 {\n+\t\t\tw := q.popFront()\n+\t\t\tif w.waiting() {\n+\t\t\t\tgo t.dialConnFor(w)\n+\t\t\t\tdone = true\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\tif q.len() == 0 {\n+\t\t\tdelete(t.connsPerHostWait, key)\n+\t\t} else {\n+\t\t\t// q is a value (like a slice), so we have to store\n+\t\t\t// the updated q back into the map.\n+\t\t\tt.connsPerHostWait[key] = q\n+\t\t}\n+\t\tif done {\n+\t\t\treturn\n \t\t}\n-\t\tdelete(t.connPerHostAvailable, cmKey)\n-\t}\n-\tif t.connPerHostCount[cmKey] == 0 {\n-\t\tdelete(t.connPerHostCount, cmKey)\n \t}\n-}\n \n-// connCloseListener wraps a connection, the transport that dialed it\n-// and the connected-to host key so the host connection count can be\n-// transparently decremented by whatever closes the embedded connection.\n-type connCloseListener struct {\n-\tnet.Conn\n-\tt        *Transport\n-\tcmKey    connectMethodKey\n-\tdidClose int32\n-}\n-\n-func (c *connCloseListener) Close() error {\n-\tif atomic.AddInt32(&c.didClose, 1) != 1 {\n-\t\treturn nil\n+\t// Otherwise, decrement the recorded count.\n+\tif n--; n == 0 {\n+\t\tdelete(t.connsPerHost, key)\n+\t} else {\n+\t\tt.connsPerHost[key] = n\n \t}\n-\terr := c.Conn.Close()\n-\tc.t.decHostConnCount(c.cmKey)\n-\treturn err\n }\n \n // The connect method and the transport can both specify a TLS\n@@ -1283,8 +1420,8 @@ func (pconn *persistConn) addTLS(name string, trace *httptrace.ClientTrace) erro\n \treturn nil\n }\n \n-func (t *Transport) dialConn(ctx context.Context, cm connectMethod) (*persistConn, error) {\n-\tpconn := &persistConn{\n+func (t *Transport) dialConn(ctx context.Context, cm connectMethod) (pconn *persistConn, err error) {\n+\tpconn = &persistConn{\n \t\tt:             t,\n \t\tcacheKey:      cm.key(),\n \t\treqch:         make(chan requestAndChan, 1),\n@@ -1423,9 +1560,6 @@ func (t *Transport) dialConn(ctx context.Context, cm connectMethod) (*persistCon\n \t\t}\n \t}\n \n-\tif t.MaxConnsPerHost > 0 {\n-\t\tpconn.conn = &connCloseListener{Conn: pconn.conn, t: t, cmKey: pconn.cacheKey}\n-\t}\n \tpconn.br = bufio.NewReaderSize(pconn, t.readBufferSize())\n \tpconn.bw = bufio.NewWriterSize(persistConnWriter{pconn}, t.writeBufferSize())\n \n@@ -1631,7 +1765,7 @@ func (pc *persistConn) canceled() error {\n \treturn pc.canceledErr\n }\n \n-// isReused reports whether this connection is in a known broken state.\n+// isReused reports whether this connection has been used before.\n func (pc *persistConn) isReused() bool {\n \tpc.mu.Lock()\n \tr := pc.reused\n@@ -2119,10 +2253,12 @@ func (pc *persistConn) wroteRequest() bool {\n \t\t// but the server has already replied. In this case, we don't\n \t\t// want to wait too long, and we want to return false so this\n \t\t// connection isn't re-used.\n+\t\tt := time.NewTimer(maxWriteWaitBeforeConnReuse)\n+\t\tdefer t.Stop()\n \t\tselect {\n \t\tcase err := <-pc.writeErrCh:\n \t\t\treturn err == nil\n-\t\tcase <-time.After(maxWriteWaitBeforeConnReuse):\n+\t\tcase <-t.C:\n \t\t\treturn false\n \t\t}\n \t}\n@@ -2176,16 +2312,6 @@ func (e *httpError) Error() string   { return e.err }\n func (e *httpError) Timeout() bool   { return e.timeout }\n func (e *httpError) Temporary() bool { return true }\n \n-func (e *httpError) Is(target error) bool {\n-\tswitch target {\n-\tcase os.ErrTimeout:\n-\t\treturn e.timeout\n-\tcase os.ErrTemporary:\n-\t\treturn true\n-\t}\n-\treturn false\n-}\n-\n var errTimeout error = &httpError{err: \"net/http: timeout awaiting response headers\", timeout: true}\n \n // errRequestCanceled is set to be identical to the one from h2 to facilitate\n@@ -2374,10 +2500,10 @@ func (pc *persistConn) closeLocked(err error) {\n \tpc.broken = true\n \tif pc.closed == nil {\n \t\tpc.closed = err\n-\t\tif pc.alt != nil {\n-\t\t\t// Clean up any host connection counting.\n-\t\t\tpc.t.decHostConnCount(pc.cacheKey)\n-\t\t} else {\n+\t\tpc.t.decConnsPerHost(pc.cacheKey)\n+\t\t// Close HTTP/1 (pc.alt == nil) connection.\n+\t\t// HTTP/2 closes its connection itself.\n+\t\tif pc.alt == nil {\n \t\t\tif err != errCallerOwnsConn {\n \t\t\t\tpc.conn.Close()\n \t\t\t}\n@@ -2520,10 +2646,6 @@ func (tlsHandshakeTimeoutError) Timeout() bool   { return true }\n func (tlsHandshakeTimeoutError) Temporary() bool { return true }\n func (tlsHandshakeTimeoutError) Error() string   { return \"net/http: TLS handshake timeout\" }\n \n-func (tlsHandshakeTimeoutError) Is(target error) bool {\n-\treturn target == os.ErrTimeout || target == os.ErrTemporary\n-}\n-\n // fakeLocker is a sync.Locker which does nothing. It's used to guard\n // test-only fields when not under test, to avoid runtime atomic\n // overhead."}, {"sha": "f304a7bc0e4d0d93629f62c916ceea51613c443d", "filename": "libgo/go/net/http/transport_test.go", "status": "modified", "additions": 192, "deletions": 14, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -655,13 +655,17 @@ func TestTransportMaxConnsPerHost(t *testing.T) {\n \n \t\texpected := int32(tr.MaxConnsPerHost)\n \t\tif dialCnt != expected {\n-\t\t\tt.Errorf(\"Too many dials (%s): %d\", scheme, dialCnt)\n+\t\t\tt.Errorf(\"round 1: too many dials (%s): %d != %d\", scheme, dialCnt, expected)\n \t\t}\n \t\tif gotConnCnt != expected {\n-\t\t\tt.Errorf(\"Too many get connections (%s): %d\", scheme, gotConnCnt)\n+\t\t\tt.Errorf(\"round 1: too many get connections (%s): %d != %d\", scheme, gotConnCnt, expected)\n \t\t}\n \t\tif ts.TLS != nil && tlsHandshakeCnt != expected {\n-\t\t\tt.Errorf(\"Too many tls handshakes (%s): %d\", scheme, tlsHandshakeCnt)\n+\t\t\tt.Errorf(\"round 1: too many tls handshakes (%s): %d != %d\", scheme, tlsHandshakeCnt, expected)\n+\t\t}\n+\n+\t\tif t.Failed() {\n+\t\t\tt.FailNow()\n \t\t}\n \n \t\t(<-connCh).Close()\n@@ -670,13 +674,13 @@ func TestTransportMaxConnsPerHost(t *testing.T) {\n \t\tdoReq()\n \t\texpected++\n \t\tif dialCnt != expected {\n-\t\t\tt.Errorf(\"Too many dials (%s): %d\", scheme, dialCnt)\n+\t\t\tt.Errorf(\"round 2: too many dials (%s): %d\", scheme, dialCnt)\n \t\t}\n \t\tif gotConnCnt != expected {\n-\t\t\tt.Errorf(\"Too many get connections (%s): %d\", scheme, gotConnCnt)\n+\t\t\tt.Errorf(\"round 2: too many get connections (%s): %d != %d\", scheme, gotConnCnt, expected)\n \t\t}\n \t\tif ts.TLS != nil && tlsHandshakeCnt != expected {\n-\t\t\tt.Errorf(\"Too many tls handshakes (%s): %d\", scheme, tlsHandshakeCnt)\n+\t\t\tt.Errorf(\"round 2: too many tls handshakes (%s): %d != %d\", scheme, tlsHandshakeCnt, expected)\n \t\t}\n \t}\n \n@@ -1654,6 +1658,180 @@ func TestTransportPersistConnLeakShortBody(t *testing.T) {\n \t}\n }\n \n+// A countedConn is a net.Conn that decrements an atomic counter when finalized.\n+type countedConn struct {\n+\tnet.Conn\n+}\n+\n+// A countingDialer dials connections and counts the number that remain reachable.\n+type countingDialer struct {\n+\tdialer      net.Dialer\n+\tmu          sync.Mutex\n+\ttotal, live int64\n+}\n+\n+func (d *countingDialer) DialContext(ctx context.Context, network, address string) (net.Conn, error) {\n+\tconn, err := d.dialer.DialContext(ctx, network, address)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tcounted := new(countedConn)\n+\tcounted.Conn = conn\n+\n+\td.mu.Lock()\n+\tdefer d.mu.Unlock()\n+\td.total++\n+\td.live++\n+\n+\truntime.SetFinalizer(counted, d.decrement)\n+\treturn counted, nil\n+}\n+\n+func (d *countingDialer) decrement(*countedConn) {\n+\td.mu.Lock()\n+\tdefer d.mu.Unlock()\n+\td.live--\n+}\n+\n+func (d *countingDialer) Read() (total, live int64) {\n+\td.mu.Lock()\n+\tdefer d.mu.Unlock()\n+\treturn d.total, d.live\n+}\n+\n+func TestTransportPersistConnLeakNeverIdle(t *testing.T) {\n+\tdefer afterTest(t)\n+\n+\tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\t// Close every connection so that it cannot be kept alive.\n+\t\tconn, _, err := w.(Hijacker).Hijack()\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"Hijack failed unexpectedly: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\t\tconn.Close()\n+\t}))\n+\tdefer ts.Close()\n+\n+\tvar d countingDialer\n+\tc := ts.Client()\n+\tc.Transport.(*Transport).DialContext = d.DialContext\n+\n+\tbody := []byte(\"Hello\")\n+\tfor i := 0; ; i++ {\n+\t\ttotal, live := d.Read()\n+\t\tif live < total {\n+\t\t\tbreak\n+\t\t}\n+\t\tif i >= 1<<12 {\n+\t\t\tt.Fatalf(\"Count of live client net.Conns (%d) not lower than total (%d) after %d Do / GC iterations.\", live, total, i)\n+\t\t}\n+\n+\t\treq, err := NewRequest(\"POST\", ts.URL, bytes.NewReader(body))\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\t_, err = c.Do(req)\n+\t\tif err == nil {\n+\t\t\tt.Fatal(\"expected broken connection\")\n+\t\t}\n+\n+\t\truntime.GC()\n+\t}\n+}\n+\n+type countedContext struct {\n+\tcontext.Context\n+}\n+\n+type contextCounter struct {\n+\tmu   sync.Mutex\n+\tlive int64\n+}\n+\n+func (cc *contextCounter) Track(ctx context.Context) context.Context {\n+\tcounted := new(countedContext)\n+\tcounted.Context = ctx\n+\tcc.mu.Lock()\n+\tdefer cc.mu.Unlock()\n+\tcc.live++\n+\truntime.SetFinalizer(counted, cc.decrement)\n+\treturn counted\n+}\n+\n+func (cc *contextCounter) decrement(*countedContext) {\n+\tcc.mu.Lock()\n+\tdefer cc.mu.Unlock()\n+\tcc.live--\n+}\n+\n+func (cc *contextCounter) Read() (live int64) {\n+\tcc.mu.Lock()\n+\tdefer cc.mu.Unlock()\n+\treturn cc.live\n+}\n+\n+func TestTransportPersistConnContextLeakMaxConnsPerHost(t *testing.T) {\n+\tif runtime.Compiler == \"gccgo\" {\n+\t\tt.Skip(\"fails with conservative stack GC\")\n+\t}\n+\n+\tdefer afterTest(t)\n+\n+\tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\truntime.Gosched()\n+\t\tw.WriteHeader(StatusOK)\n+\t}))\n+\tdefer ts.Close()\n+\n+\tc := ts.Client()\n+\tc.Transport.(*Transport).MaxConnsPerHost = 1\n+\n+\tctx := context.Background()\n+\tbody := []byte(\"Hello\")\n+\tdoPosts := func(cc *contextCounter) {\n+\t\tvar wg sync.WaitGroup\n+\t\tfor n := 64; n > 0; n-- {\n+\t\t\twg.Add(1)\n+\t\t\tgo func() {\n+\t\t\t\tdefer wg.Done()\n+\n+\t\t\t\tctx := cc.Track(ctx)\n+\t\t\t\treq, err := NewRequest(\"POST\", ts.URL, bytes.NewReader(body))\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Error(err)\n+\t\t\t\t}\n+\n+\t\t\t\t_, err = c.Do(req.WithContext(ctx))\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"Do failed with error: %v\", err)\n+\t\t\t\t}\n+\t\t\t}()\n+\t\t}\n+\t\twg.Wait()\n+\t}\n+\n+\tvar initialCC contextCounter\n+\tdoPosts(&initialCC)\n+\n+\t// flushCC exists only to put pressure on the GC to finalize the initialCC\n+\t// contexts: the flushCC allocations should eventually displace the initialCC\n+\t// allocations.\n+\tvar flushCC contextCounter\n+\tfor i := 0; ; i++ {\n+\t\tlive := initialCC.Read()\n+\t\tif live == 0 {\n+\t\t\tbreak\n+\t\t}\n+\t\tif i >= 100 {\n+\t\t\tt.Fatalf(\"%d Contexts still not finalized after %d GC cycles.\", live, i)\n+\t\t}\n+\t\tdoPosts(&flushCC)\n+\t\truntime.GC()\n+\t}\n+}\n+\n // This used to crash; https://golang.org/issue/3266\n func TestTransportIdleConnCrash(t *testing.T) {\n \tdefer afterTest(t)\n@@ -2795,8 +2973,8 @@ func TestIdleConnChannelLeak(t *testing.T) {\n \t\t\t<-didRead\n \t\t}\n \n-\t\tif got := tr.IdleConnChMapSizeForTesting(); got != 0 {\n-\t\t\tt.Fatalf(\"ForDisableKeepAlives = %v, map size = %d; want 0\", disableKeep, got)\n+\t\tif got := tr.IdleConnWaitMapSizeForTesting(); got != 0 {\n+\t\t\tt.Fatalf(\"for DisableKeepAlives = %v, map size = %d; want 0\", disableKeep, got)\n \t\t}\n \t}\n }\n@@ -3378,9 +3556,9 @@ func TestTransportCloseIdleConnsThenReturn(t *testing.T) {\n \t}\n \twantIdle(\"after second put\", 0)\n \n-\ttr.RequestIdleConnChForTesting() // should toggle the transport out of idle mode\n+\ttr.QueueForIdleConnForTesting() // should toggle the transport out of idle mode\n \tif tr.IsIdleForTesting() {\n-\t\tt.Error(\"shouldn't be idle after RequestIdleConnChForTesting\")\n+\t\tt.Error(\"shouldn't be idle after QueueForIdleConnForTesting\")\n \t}\n \tif !tr.PutIdleTestConn(\"http\", \"example.com\") {\n \t\tt.Fatal(\"after re-activation\")\n@@ -3802,8 +3980,8 @@ func TestNoCrashReturningTransportAltConn(t *testing.T) {\n \tln := newLocalListener(t)\n \tdefer ln.Close()\n \n-\thandledPendingDial := make(chan bool, 1)\n-\tSetPendingDialHooks(nil, func() { handledPendingDial <- true })\n+\tvar wg sync.WaitGroup\n+\tSetPendingDialHooks(func() { wg.Add(1) }, wg.Done)\n \tdefer SetPendingDialHooks(nil, nil)\n \n \ttestDone := make(chan struct{})\n@@ -3873,7 +4051,7 @@ func TestNoCrashReturningTransportAltConn(t *testing.T) {\n \n \tdoReturned <- true\n \t<-madeRoundTripper\n-\t<-handledPendingDial\n+\twg.Wait()\n }\n \n func TestTransportReuseConnection_Gzip_Chunked(t *testing.T) {\n@@ -4285,7 +4463,7 @@ func TestTransportRejectsAlphaPort(t *testing.T) {\n \t\tt.Fatalf(\"got %#v; want *url.Error\", err)\n \t}\n \tgot := ue.Err.Error()\n-\twant := `invalid URL port \"123foo\"`\n+\twant := `invalid port \":123foo\" after host`\n \tif got != want {\n \t\tt.Errorf(\"got error %q; want %q\", got, want)\n \t}"}, {"sha": "1a1d0e7dba471e528e15da67158474e54d8f6b7a", "filename": "libgo/go/net/ip.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fip.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -513,12 +513,12 @@ func (n *IPNet) Contains(ip IP) bool {\n // Network returns the address's network name, \"ip+net\".\n func (n *IPNet) Network() string { return \"ip+net\" }\n \n-// String returns the CIDR notation of n like \"192.0.2.1/24\"\n+// String returns the CIDR notation of n like \"192.0.2.0/24\"\n // or \"2001:db8::/48\" as defined in RFC 4632 and RFC 4291.\n // If the mask is not in the canonical form, it returns the\n // string which consists of an IP address, followed by a slash\n // character and a mask expressed as hexadecimal form with no\n-// punctuation like \"198.51.100.1/c000ff00\".\n+// punctuation like \"198.51.100.0/c000ff00\".\n func (n *IPNet) String() string {\n \tnn, m := networkNumberAndMask(n)\n \tif nn == nil || m == nil {"}, {"sha": "75207db4342cbe64a2a43b66ba1717695da8c337", "filename": "libgo/go/net/mail/message.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fmail%2Fmessage.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fmail%2Fmessage.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fmail%2Fmessage.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -148,7 +148,7 @@ type Address struct {\n \tAddress string // user@domain\n }\n \n-// Parses a single RFC 5322 address, e.g. \"Barry Gibbs <bg@example.com>\"\n+// ParseAddress parses a single RFC 5322 address, e.g. \"Barry Gibbs <bg@example.com>\"\n func ParseAddress(address string) (*Address, error) {\n \treturn (&addrParser{s: address}).parseSingleAddress()\n }"}, {"sha": "38c6b9963747a5bb81293252d11b70643824a542", "filename": "libgo/go/net/net.go", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fnet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fnet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnet.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -146,6 +146,13 @@ type Conn interface {\n \t// the deadline after successful Read or Write calls.\n \t//\n \t// A zero value for t means I/O operations will not time out.\n+\t//\n+\t// Note that if a TCP connection has keep-alive turned on,\n+\t// which is the default unless overridden by Dialer.KeepAlive\n+\t// or ListenConfig.KeepAlive, then a keep-alive failure may\n+\t// also return a timeout error. On Unix systems a keep-alive\n+\t// failure on I/O can be detected using\n+\t// errors.Is(err, syscall.ETIMEDOUT).\n \tSetDeadline(t time.Time) error\n \n \t// SetReadDeadline sets the deadline for future Read calls\n@@ -516,16 +523,6 @@ func (e *OpError) Temporary() bool {\n \treturn ok && t.Temporary()\n }\n \n-func (e *OpError) Is(target error) bool {\n-\tswitch target {\n-\tcase os.ErrTemporary:\n-\t\treturn e.Temporary()\n-\tcase os.ErrTimeout:\n-\t\treturn e.Timeout()\n-\t}\n-\treturn false\n-}\n-\n // A ParseError is the error type of literal network address parsers.\n type ParseError struct {\n \t// Type is the type of string that was expected, such as\n@@ -617,16 +614,6 @@ func (e *DNSError) Timeout() bool { return e.IsTimeout }\n // error and return a DNSError for which Temporary returns false.\n func (e *DNSError) Temporary() bool { return e.IsTimeout || e.IsTemporary }\n \n-func (e *DNSError) Is(target error) bool {\n-\tswitch target {\n-\tcase os.ErrTemporary:\n-\t\treturn e.Temporary()\n-\tcase os.ErrTimeout:\n-\t\treturn e.Timeout()\n-\t}\n-\treturn false\n-}\n-\n type writerOnly struct {\n \tio.Writer\n }"}, {"sha": "463ae8856d2c57b274fb390a99de4ebb425518d6", "filename": "libgo/go/net/net_test.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fnet_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fnet_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnet_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -525,6 +525,9 @@ func TestNotTemporaryRead(t *testing.T) {\n \tif runtime.GOOS == \"freebsd\" {\n \t\ttestenv.SkipFlaky(t, 25289)\n \t}\n+\tif runtime.GOOS == \"aix\" {\n+\t\ttestenv.SkipFlaky(t, 29685)\n+\t}\n \tt.Parallel()\n \tserver := func(cs *TCPConn) error {\n \t\tcs.SetLinger(0)"}, {"sha": "9177fc403643e3b9de936811a9c1873efa5a34cf", "filename": "libgo/go/net/pipe.go", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fpipe.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Fpipe.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fpipe.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -6,7 +6,6 @@ package net\n \n import (\n \t\"io\"\n-\t\"os\"\n \t\"sync\"\n \t\"time\"\n )\n@@ -85,10 +84,6 @@ func (timeoutError) Error() string   { return \"deadline exceeded\" }\n func (timeoutError) Timeout() bool   { return true }\n func (timeoutError) Temporary() bool { return true }\n \n-func (timeoutError) Is(target error) bool {\n-\treturn target == os.ErrTemporary || target == os.ErrTimeout\n-}\n-\n type pipeAddr struct{}\n \n func (pipeAddr) Network() string { return \"pipe\" }"}, {"sha": "b4fc2c0198169e58bf0d55ff5a387416f804fe44", "filename": "libgo/go/net/timeout_test.go", "status": "modified", "additions": 14, "deletions": 38, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Ftimeout_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Ftimeout_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftimeout_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -7,9 +7,7 @@\n package net\n \n import (\n-\t\"errors\"\n \t\"fmt\"\n-\t\"internal/oserror\"\n \t\"internal/poll\"\n \t\"internal/testenv\"\n \t\"io\"\n@@ -90,9 +88,6 @@ func TestDialTimeout(t *testing.T) {\n \t\t\tif nerr, ok := err.(Error); !ok || !nerr.Timeout() {\n \t\t\t\tt.Fatalf(\"#%d: %v\", i, err)\n \t\t\t}\n-\t\t\tif !errors.Is(err, oserror.ErrTimeout) {\n-\t\t\t\tt.Fatalf(\"#%d: Dial error is not os.ErrTimeout: %v\", i, err)\n-\t\t\t}\n \t\t}\n \t}\n }\n@@ -826,24 +821,14 @@ func testVariousDeadlines(t *testing.T) {\n \t\td   time.Duration\n \t}\n \n-\tch := make(chan error, 1)\n-\tpasvch := make(chan result)\n \thandler := func(ls *localServer, ln Listener) {\n \t\tfor {\n \t\t\tc, err := ln.Accept()\n \t\t\tif err != nil {\n-\t\t\t\tch <- err\n-\t\t\t\treturn\n+\t\t\t\tbreak\n \t\t\t}\n-\t\t\t// The server, with no timeouts of its own,\n-\t\t\t// sending bytes to clients as fast as it can.\n-\t\t\tgo func() {\n-\t\t\t\tt0 := time.Now()\n-\t\t\t\tn, err := io.Copy(c, neverEnding('a'))\n-\t\t\t\tdt := time.Since(t0)\n-\t\t\t\tc.Close()\n-\t\t\t\tpasvch <- result{n, err, dt}\n-\t\t\t}()\n+\t\t\tc.Read(make([]byte, 1)) // wait for client to close connection\n+\t\t\tc.Close()\n \t\t}\n \t}\n \tls, err := newLocalServer(\"tcp\")\n@@ -884,18 +869,18 @@ func testVariousDeadlines(t *testing.T) {\n \t\t\t}\n \t\t}\n \t\tfor run := 0; run < numRuns; run++ {\n-\t\t\tname := fmt.Sprintf(\"%v run %d/%d\", timeout, run+1, numRuns)\n+\t\t\tname := fmt.Sprintf(\"%v %d/%d\", timeout, run, numRuns)\n \t\t\tt.Log(name)\n \n+\t\t\ttooSlow := time.NewTimer(5 * time.Second)\n+\t\t\tdefer tooSlow.Stop()\n+\n \t\t\tc, err := Dial(ls.Listener.Addr().Network(), ls.Listener.Addr().String())\n \t\t\tif err != nil {\n \t\t\t\tt.Fatal(err)\n \t\t\t}\n \n-\t\t\ttooLong := 5 * time.Second\n-\t\t\tmax := time.NewTimer(tooLong)\n-\t\t\tdefer max.Stop()\n-\t\t\tactvch := make(chan result)\n+\t\t\tch := make(chan result, 1)\n \t\t\tgo func() {\n \t\t\t\tt0 := time.Now()\n \t\t\t\tif err := c.SetDeadline(t0.Add(timeout)); err != nil {\n@@ -904,27 +889,18 @@ func testVariousDeadlines(t *testing.T) {\n \t\t\t\tn, err := io.Copy(ioutil.Discard, c)\n \t\t\t\tdt := time.Since(t0)\n \t\t\t\tc.Close()\n-\t\t\t\tactvch <- result{n, err, dt}\n+\t\t\t\tch <- result{n, err, dt}\n \t\t\t}()\n \n \t\t\tselect {\n-\t\t\tcase res := <-actvch:\n+\t\t\tcase res := <-ch:\n \t\t\t\tif nerr, ok := res.err.(Error); ok && nerr.Timeout() {\n-\t\t\t\t\tt.Logf(\"for %v, good client timeout after %v, reading %d bytes\", name, res.d, res.n)\n+\t\t\t\t\tt.Logf(\"%v: good timeout after %v; %d bytes\", name, res.d, res.n)\n \t\t\t\t} else {\n-\t\t\t\t\tt.Fatalf(\"for %v, client Copy = %d, %v; want timeout\", name, res.n, res.err)\n+\t\t\t\t\tt.Fatalf(\"%v: Copy = %d, %v; want timeout\", name, res.n, res.err)\n \t\t\t\t}\n-\t\t\tcase <-max.C:\n-\t\t\t\tt.Fatalf(\"for %v, timeout (%v) waiting for client to timeout (%v) reading\", name, tooLong, timeout)\n-\t\t\t}\n-\n-\t\t\tselect {\n-\t\t\tcase res := <-pasvch:\n-\t\t\t\tt.Logf(\"for %v, server in %v wrote %d: %v\", name, res.d, res.n, res.err)\n-\t\t\tcase err := <-ch:\n-\t\t\t\tt.Fatalf(\"for %v, Accept = %v\", name, err)\n-\t\t\tcase <-max.C:\n-\t\t\t\tt.Fatalf(\"for %v, timeout waiting for server to finish writing\", name)\n+\t\t\tcase <-tooSlow.C:\n+\t\t\t\tt.Fatalf(\"%v: client stuck in Dial+Copy\", name)\n \t\t\t}\n \t\t}\n \t}"}, {"sha": "12ea35f0f9e02c96689084b58a0c695e208f7e9c", "filename": "libgo/go/net/url/url.go", "status": "modified", "additions": 43, "deletions": 32, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Furl%2Furl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Furl%2Furl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Furl%2Furl.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -13,7 +13,6 @@ package url\n import (\n \t\"errors\"\n \t\"fmt\"\n-\t\"internal/oserror\"\n \t\"sort\"\n \t\"strconv\"\n \t\"strings\"\n@@ -26,10 +25,22 @@ type Error struct {\n \tErr error\n }\n \n-func (e *Error) Unwrap() error   { return e.Err }\n-func (e *Error) Error() string   { return e.Op + \" \" + e.URL + \": \" + e.Err.Error() }\n-func (e *Error) Timeout() bool   { return oserror.IsTimeout(e.Err) }\n-func (e *Error) Temporary() bool { return oserror.IsTemporary(e.Err) }\n+func (e *Error) Unwrap() error { return e.Err }\n+func (e *Error) Error() string { return e.Op + \" \" + e.URL + \": \" + e.Err.Error() }\n+\n+func (e *Error) Timeout() bool {\n+\tt, ok := e.Err.(interface {\n+\t\tTimeout() bool\n+\t})\n+\treturn ok && t.Timeout()\n+}\n+\n+func (e *Error) Temporary() bool {\n+\tt, ok := e.Err.(interface {\n+\t\tTemporary() bool\n+\t})\n+\treturn ok && t.Temporary()\n+}\n \n func ishex(c byte) bool {\n \tswitch {\n@@ -637,6 +648,11 @@ func parseHost(host string) (string, error) {\n \t\t\t}\n \t\t\treturn host1 + host2 + host3, nil\n \t\t}\n+\t} else if i := strings.LastIndex(host, \":\"); i != -1 {\n+\t\tcolonPort := host[i:]\n+\t\tif !validOptionalPort(colonPort) {\n+\t\t\treturn \"\", fmt.Errorf(\"invalid port %q after host\", colonPort)\n+\t\t}\n \t}\n \n \tvar err error\n@@ -1035,44 +1051,39 @@ func (u *URL) RequestURI() string {\n \treturn result\n }\n \n-// Hostname returns u.Host, without any port number.\n+// Hostname returns u.Host, stripping any valid port number if present.\n //\n-// If Host is an IPv6 literal with a port number, Hostname returns the\n-// IPv6 literal without the square brackets. IPv6 literals may include\n-// a zone identifier.\n+// If the result is enclosed in square brackets, as literal IPv6 addresses are,\n+// the square brackets are removed from the result.\n func (u *URL) Hostname() string {\n-\treturn stripPort(u.Host)\n+\thost, _ := splitHostPort(u.Host)\n+\treturn host\n }\n \n // Port returns the port part of u.Host, without the leading colon.\n-// If u.Host doesn't contain a port, Port returns an empty string.\n+//\n+// If u.Host doesn't contain a valid numeric port, Port returns an empty string.\n func (u *URL) Port() string {\n-\treturn portOnly(u.Host)\n+\t_, port := splitHostPort(u.Host)\n+\treturn port\n }\n \n-func stripPort(hostport string) string {\n-\tcolon := strings.IndexByte(hostport, ':')\n-\tif colon == -1 {\n-\t\treturn hostport\n-\t}\n-\tif i := strings.IndexByte(hostport, ']'); i != -1 {\n-\t\treturn strings.TrimPrefix(hostport[:i], \"[\")\n-\t}\n-\treturn hostport[:colon]\n-}\n+// splitHostPort separates host and port. If the port is not valid, it returns\n+// the entire input as host, and it doesn't check the validity of the host.\n+// Unlike net.SplitHostPort, but per RFC 3986, it requires ports to be numeric.\n+func splitHostPort(hostport string) (host, port string) {\n+\thost = hostport\n \n-func portOnly(hostport string) string {\n-\tcolon := strings.IndexByte(hostport, ':')\n-\tif colon == -1 {\n-\t\treturn \"\"\n+\tcolon := strings.LastIndexByte(host, ':')\n+\tif colon != -1 && validOptionalPort(host[colon:]) {\n+\t\thost, port = host[:colon], host[colon+1:]\n \t}\n-\tif i := strings.Index(hostport, \"]:\"); i != -1 {\n-\t\treturn hostport[i+len(\"]:\"):]\n-\t}\n-\tif strings.Contains(hostport, \"]\") {\n-\t\treturn \"\"\n+\n+\tif strings.HasPrefix(host, \"[\") && strings.HasSuffix(host, \"]\") {\n+\t\thost = host[1 : len(host)-1]\n \t}\n-\treturn hostport[colon+len(\":\"):]\n+\n+\treturn\n }\n \n // Marshaling interface implementations."}, {"sha": "e83c86c424324e7b77b9598cc9bc6ff0709ba527", "filename": "libgo/go/net/url/url_test.go", "status": "modified", "additions": 39, "deletions": 43, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Furl%2Furl_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fnet%2Furl%2Furl_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Furl%2Furl_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -422,10 +422,10 @@ var urltests = []URLTest{\n \t},\n \t// worst case host, still round trips\n \t{\n-\t\t\"scheme://!$&'()*+,;=hello!:port/path\",\n+\t\t\"scheme://!$&'()*+,;=hello!:1/path\",\n \t\t&URL{\n \t\t\tScheme: \"scheme\",\n-\t\t\tHost:   \"!$&'()*+,;=hello!:port\",\n+\t\t\tHost:   \"!$&'()*+,;=hello!:1\",\n \t\t\tPath:   \"/path\",\n \t\t},\n \t\t\"\",\n@@ -1425,11 +1425,13 @@ func TestParseErrors(t *testing.T) {\n \t\t{\"http://[::1]\", false},\n \t\t{\"http://[::1]:80\", false},\n \t\t{\"http://[::1]:namedport\", true}, // rfc3986 3.2.3\n+\t\t{\"http://x:namedport\", true},     // rfc3986 3.2.3\n \t\t{\"http://[::1]/\", false},\n \t\t{\"http://[::1]a\", true},\n \t\t{\"http://[::1]%23\", true},\n \t\t{\"http://[::1%25en0]\", false},     // valid zone id\n \t\t{\"http://[::1]:\", false},          // colon, but no port OK\n+\t\t{\"http://x:\", false},              // colon, but no port OK\n \t\t{\"http://[::1]:%38%30\", true},     // not allowed: % encoding only for non-ASCII\n \t\t{\"http://[::1%25%41]\", false},     // RFC 6874 allows over-escaping in zone\n \t\t{\"http://[%10::1]\", true},         // no %xx escapes in IP address\n@@ -1621,52 +1623,46 @@ func TestURLErrorImplementsNetError(t *testing.T) {\n \t}\n }\n \n-func TestURLHostname(t *testing.T) {\n+func TestURLHostnameAndPort(t *testing.T) {\n \ttests := []struct {\n-\t\thost string // URL.Host field\n-\t\twant string\n+\t\tin   string // URL.Host field\n+\t\thost string\n+\t\tport string\n \t}{\n-\t\t{\"foo.com:80\", \"foo.com\"},\n-\t\t{\"foo.com\", \"foo.com\"},\n-\t\t{\"FOO.COM\", \"FOO.COM\"}, // no canonicalization (yet?)\n-\t\t{\"1.2.3.4\", \"1.2.3.4\"},\n-\t\t{\"1.2.3.4:80\", \"1.2.3.4\"},\n-\t\t{\"[1:2:3:4]\", \"1:2:3:4\"},\n-\t\t{\"[1:2:3:4]:80\", \"1:2:3:4\"},\n-\t\t{\"[::1]:80\", \"::1\"},\n-\t\t{\"[::1]\", \"::1\"},\n-\t\t{\"localhost\", \"localhost\"},\n-\t\t{\"localhost:443\", \"localhost\"},\n-\t\t{\"some.super.long.domain.example.org:8080\", \"some.super.long.domain.example.org\"},\n-\t\t{\"[2001:0db8:85a3:0000:0000:8a2e:0370:7334]:17000\", \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\"},\n-\t\t{\"[2001:0db8:85a3:0000:0000:8a2e:0370:7334]\", \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\"},\n+\t\t{\"foo.com:80\", \"foo.com\", \"80\"},\n+\t\t{\"foo.com\", \"foo.com\", \"\"},\n+\t\t{\"foo.com:\", \"foo.com\", \"\"},\n+\t\t{\"FOO.COM\", \"FOO.COM\", \"\"}, // no canonicalization\n+\t\t{\"1.2.3.4\", \"1.2.3.4\", \"\"},\n+\t\t{\"1.2.3.4:80\", \"1.2.3.4\", \"80\"},\n+\t\t{\"[1:2:3:4]\", \"1:2:3:4\", \"\"},\n+\t\t{\"[1:2:3:4]:80\", \"1:2:3:4\", \"80\"},\n+\t\t{\"[::1]:80\", \"::1\", \"80\"},\n+\t\t{\"[::1]\", \"::1\", \"\"},\n+\t\t{\"[::1]:\", \"::1\", \"\"},\n+\t\t{\"localhost\", \"localhost\", \"\"},\n+\t\t{\"localhost:443\", \"localhost\", \"443\"},\n+\t\t{\"some.super.long.domain.example.org:8080\", \"some.super.long.domain.example.org\", \"8080\"},\n+\t\t{\"[2001:0db8:85a3:0000:0000:8a2e:0370:7334]:17000\", \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\", \"17000\"},\n+\t\t{\"[2001:0db8:85a3:0000:0000:8a2e:0370:7334]\", \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\", \"\"},\n+\n+\t\t// Ensure that even when not valid, Host is one of \"Hostname\",\n+\t\t// \"Hostname:Port\", \"[Hostname]\" or \"[Hostname]:Port\".\n+\t\t// See https://golang.org/issue/29098.\n+\t\t{\"[google.com]:80\", \"google.com\", \"80\"},\n+\t\t{\"google.com]:80\", \"google.com]\", \"80\"},\n+\t\t{\"google.com:80_invalid_port\", \"google.com:80_invalid_port\", \"\"},\n+\t\t{\"[::1]extra]:80\", \"::1]extra\", \"80\"},\n+\t\t{\"google.com]extra:extra\", \"google.com]extra:extra\", \"\"},\n \t}\n \tfor _, tt := range tests {\n-\t\tu := &URL{Host: tt.host}\n-\t\tgot := u.Hostname()\n-\t\tif got != tt.want {\n-\t\t\tt.Errorf(\"Hostname for Host %q = %q; want %q\", tt.host, got, tt.want)\n+\t\tu := &URL{Host: tt.in}\n+\t\thost, port := u.Hostname(), u.Port()\n+\t\tif host != tt.host {\n+\t\t\tt.Errorf(\"Hostname for Host %q = %q; want %q\", tt.in, host, tt.host)\n \t\t}\n-\t}\n-}\n-\n-func TestURLPort(t *testing.T) {\n-\ttests := []struct {\n-\t\thost string // URL.Host field\n-\t\twant string\n-\t}{\n-\t\t{\"foo.com\", \"\"},\n-\t\t{\"foo.com:80\", \"80\"},\n-\t\t{\"1.2.3.4\", \"\"},\n-\t\t{\"1.2.3.4:80\", \"80\"},\n-\t\t{\"[1:2:3:4]\", \"\"},\n-\t\t{\"[1:2:3:4]:80\", \"80\"},\n-\t}\n-\tfor _, tt := range tests {\n-\t\tu := &URL{Host: tt.host}\n-\t\tgot := u.Port()\n-\t\tif got != tt.want {\n-\t\t\tt.Errorf(\"Port for Host %q = %q; want %q\", tt.host, got, tt.want)\n+\t\tif port != tt.port {\n+\t\t\tt.Errorf(\"Port for Host %q = %q; want %q\", tt.in, port, tt.port)\n \t\t}\n \t}\n }"}, {"sha": "1d7ced8061c5d76223076c85f757284a7dd94728", "filename": "libgo/go/os/dir.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fos%2Fdir.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fos%2Fdir.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fdir.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -26,7 +26,10 @@ func (f *File) Readdir(n int) ([]FileInfo, error) {\n \treturn f.readdir(n)\n }\n \n-// Readdirnames reads and returns a slice of names from the directory f.\n+// Readdirnames reads the contents of the directory associated with file\n+// and returns a slice of up to n names of files in the directory,\n+// in directory order. Subsequent calls on the same file will yield\n+// further names.\n //\n // If n > 0, Readdirnames returns at most n names. In this case, if\n // Readdirnames returns an empty slice, it will return a non-nil error"}, {"sha": "0e8e2d47f8fa380dbcddfa43564fcd3748c9ac4a", "filename": "libgo/go/os/error.go", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fos%2Ferror.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fos%2Ferror.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -22,8 +22,6 @@ var (\n \tErrExist      = errExist()      // \"file already exists\"\n \tErrNotExist   = errNotExist()   // \"file does not exist\"\n \tErrClosed     = errClosed()     // \"file already closed\"\n-\tErrTimeout    = errTimeout()    // \"deadline exceeded\"\n-\tErrTemporary  = errTemporary()  // \"temporary error\"\n \tErrNoDeadline = errNoDeadline() // \"file type does not support deadline\"\n )\n \n@@ -32,8 +30,6 @@ func errPermission() error { return oserror.ErrPermission }\n func errExist() error      { return oserror.ErrExist }\n func errNotExist() error   { return oserror.ErrNotExist }\n func errClosed() error     { return oserror.ErrClosed }\n-func errTimeout() error    { return oserror.ErrTimeout }\n-func errTemporary() error  { return oserror.ErrTemporary }\n func errNoDeadline() error { return poll.ErrNoDeadline }\n \n type timeout interface {\n@@ -119,7 +115,8 @@ func underlyingErrorIs(err, target error) bool {\n \tif err == target {\n \t\treturn true\n \t}\n-\te, ok := err.(interface{ Is(error) bool })\n+\t// To preserve prior behavior, only examine syscall errors.\n+\te, ok := err.(syscallErrorType)\n \treturn ok && e.Is(target)\n }\n "}, {"sha": "31ae05a21e8dce4b7d7fdac5bb520c730b717f10", "filename": "libgo/go/os/error_errno.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fos%2Ferror_errno.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fos%2Ferror_errno.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror_errno.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !plan9\n+\n+package os\n+\n+import \"syscall\"\n+\n+type syscallErrorType = syscall.Errno"}, {"sha": "af6065db568edc3c94cf882a6ac93db7e6b1fd90", "filename": "libgo/go/os/error_plan9.go", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fos%2Ferror_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fos%2Ferror_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror_plan9.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -0,0 +1,9 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package os\n+\n+import \"syscall\"\n+\n+type syscallErrorType = syscall.ErrorString"}, {"sha": "3d921578fd294fb3db45821687d921620591c624", "filename": "libgo/go/os/error_test.go", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fos%2Ferror_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fos%2Ferror_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -175,3 +175,13 @@ func TestPathErrorUnwrap(t *testing.T) {\n \t\tt.Error(\"errors.Is failed, wanted success\")\n \t}\n }\n+\n+type myErrorIs struct{ error }\n+\n+func (e myErrorIs) Is(target error) bool { return target == e.error }\n+\n+func TestErrorIsMethods(t *testing.T) {\n+\tif os.IsPermission(myErrorIs{os.ErrPermission}) {\n+\t\tt.Error(\"os.IsPermission(err) = true when err.Is(os.ErrPermission), wanted false\")\n+\t}\n+}"}, {"sha": "c13babe5f7fad8ee418dc1783fc8e7e7413aea4e", "filename": "libgo/go/os/file.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fos%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fos%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -34,6 +34,10 @@\n //\t}\n //\tfmt.Printf(\"read %d bytes: %q\\n\", count, data[:count])\n //\n+// Note: The maximum number of concurrent operations on a File may be limited by\n+// the OS or the system. The number should be high, but exceeding it may degrade\n+// performance or cause other issues.\n+//\n package os\n \n import ("}, {"sha": "c27432f9ab4d2f09ece5ead8709ae039578c4a1d", "filename": "libgo/go/os/os_test.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fos%2Fos_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fos%2Fos_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fos_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -2253,6 +2253,8 @@ func TestPipeThreads(t *testing.T) {\n \t\tt.Skip(\"skipping on Plan 9; does not support runtime poller\")\n \tcase \"js\":\n \t\tt.Skip(\"skipping on js; no support for os.Pipe\")\n+\tcase \"darwin\":\n+\t\tt.Skip(\"skipping on Darwin; issue 33953\")\n \t}\n \n \tthreads := 100"}, {"sha": "377aa49c91e366973aa51eb2e18781a2283905d1", "filename": "libgo/go/os/removeall_at.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fos%2Fremoveall_at.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fos%2Fremoveall_at.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fremoveall_at.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -173,7 +173,7 @@ func openFdAt(dirfd int, name string) (*File, error) {\n \tvar r int\n \tfor {\n \t\tvar e error\n-\t\tr, e = unix.Openat(dirfd, name, O_RDONLY, 0)\n+\t\tr, e = unix.Openat(dirfd, name, O_RDONLY|syscall.O_CLOEXEC, 0)\n \t\tif e == nil {\n \t\t\tbreak\n \t\t}"}, {"sha": "3c23090489f953dd89260208eccf12a864a1e9cc", "filename": "libgo/go/os/signal/signal_cgo_test.go", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fos%2Fsignal%2Fsignal_cgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fos%2Fsignal%2Fsignal_cgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fsignal%2Fsignal_cgo_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -101,17 +101,6 @@ func TestTerminalSignal(t *testing.T) {\n \t\tCtty:    int(slave.Fd()),\n \t}\n \n-\t// Test ctty management by sending enough child fd to overlap the\n-\t// parent's fd intended for child's ctty.\n-\tfor 2+len(cmd.ExtraFiles) < cmd.SysProcAttr.Ctty {\n-\t\tdummy, err := os.Open(os.DevNull)\n-\t\tif err != nil {\n-\t\t\tt.Fatal(err)\n-\t\t}\n-\t\tdefer dummy.Close()\n-\t\tcmd.ExtraFiles = append(cmd.ExtraFiles, dummy)\n-\t}\n-\n \tif err := cmd.Start(); err != nil {\n \t\tt.Fatal(err)\n \t}"}, {"sha": "0c570f141351a3874805bf1df714990894d9fb93", "filename": "libgo/go/path/path_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fpath%2Fpath_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fpath%2Fpath_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Fpath_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -141,7 +141,7 @@ var jointests = []JoinTest{\n func TestJoin(t *testing.T) {\n \tfor _, test := range jointests {\n \t\tif p := Join(test.elem...); p != test.path {\n-\t\t\tt.Errorf(\"join(%q) = %q, want %q\", test.elem, p, test.path)\n+\t\t\tt.Errorf(\"Join(%q) = %q, want %q\", test.elem, p, test.path)\n \t\t}\n \t}\n }"}, {"sha": "6e06485f0180b1b84f5f2b5d52d82064c233e2c1", "filename": "libgo/go/reflect/all_test.go", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Freflect%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Freflect%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fall_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -2060,6 +2060,16 @@ func (p Point) TotalDist(points ...Point) int {\n \treturn tot\n }\n \n+// This will be index 5.\n+func (p *Point) Int64Method(x int64) int64 {\n+\treturn x\n+}\n+\n+// This will be index 6.\n+func (p *Point) Int32Method(x int32) int32 {\n+\treturn x\n+}\n+\n func TestMethod(t *testing.T) {\n \t// Non-curried method of type.\n \tp := Point{3, 4}\n@@ -2268,6 +2278,17 @@ func TestMethodValue(t *testing.T) {\n \tif i != 425 {\n \t\tt.Errorf(\"Interface MethodByName returned %d; want 425\", i)\n \t}\n+\n+\t// For issue #33628: method args are not stored at the right offset\n+\t// on amd64p32.\n+\tm64 := ValueOf(&p).MethodByName(\"Int64Method\").Interface().(func(int64) int64)\n+\tif x := m64(123); x != 123 {\n+\t\tt.Errorf(\"Int64Method returned %d; want 123\", x)\n+\t}\n+\tm32 := ValueOf(&p).MethodByName(\"Int32Method\").Interface().(func(int32) int32)\n+\tif x := m32(456); x != 456 {\n+\t\tt.Errorf(\"Int32Method returned %d; want 456\", x)\n+\t}\n }\n \n func TestVariadicMethodValue(t *testing.T) {"}, {"sha": "d39521094ec608e4bea43facc0303b64b9811a61", "filename": "libgo/go/runtime/cpuprof.go", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fruntime%2Fcpuprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fruntime%2Fcpuprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcpuprof.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -36,9 +36,10 @@ type cpuProfile struct {\n \t// 300 words per second.\n \t// Hopefully a normal Go thread will get the profiling\n \t// signal at least once every few seconds.\n-\textra     [1000]uintptr\n-\tnumExtra  int\n-\tlostExtra uint64 // count of frames lost because extra is full\n+\textra      [1000]uintptr\n+\tnumExtra   int\n+\tlostExtra  uint64 // count of frames lost because extra is full\n+\tlostAtomic uint64 // count of frames lost because of being in atomic64 on mips/arm; updated racily\n }\n \n var cpuprof cpuProfile\n@@ -94,7 +95,7 @@ func (p *cpuProfile) add(gp *g, stk []uintptr) {\n \t}\n \n \tif prof.hz != 0 { // implies cpuprof.log != nil\n-\t\tif p.numExtra > 0 || p.lostExtra > 0 {\n+\t\tif p.numExtra > 0 || p.lostExtra > 0 || p.lostAtomic > 0 {\n \t\t\tp.addExtra()\n \t\t}\n \t\thdr := [1]uint64{1}\n@@ -159,18 +160,20 @@ func (p *cpuProfile) addExtra() {\n \t\t\t_LostExternalCodePC + sys.PCQuantum,\n \t\t\t_ExternalCodePC + sys.PCQuantum,\n \t\t}\n-\t\tcpuprof.log.write(nil, 0, hdr[:], lostStk[:])\n+\t\tp.log.write(nil, 0, hdr[:], lostStk[:])\n \t\tp.lostExtra = 0\n \t}\n-}\n \n-func (p *cpuProfile) addLostAtomic64(count uint64) {\n-\thdr := [1]uint64{count}\n-\tlostStk := [2]uintptr{\n-\t\t_LostSIGPROFDuringAtomic64PC + sys.PCQuantum,\n-\t\t_SystemPC + sys.PCQuantum,\n+\tif p.lostAtomic > 0 {\n+\t\thdr := [1]uint64{p.lostAtomic}\n+\t\tlostStk := [2]uintptr{\n+\t\t\t_LostSIGPROFDuringAtomic64PC + sys.PCQuantum,\n+\t\t\t_SystemPC + sys.PCQuantum,\n+\t\t}\n+\t\tp.log.write(nil, 0, hdr[:], lostStk[:])\n+\t\tp.lostAtomic = 0\n \t}\n-\tcpuprof.log.write(nil, 0, hdr[:], lostStk[:])\n+\n }\n \n // CPUProfile panics."}, {"sha": "10890d35a6583211de8f7f375b1076f0cca041e7", "filename": "libgo/go/runtime/export_test.go", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fruntime%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fruntime%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fexport_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -675,3 +675,37 @@ func (t *Treap) CheckInvariants() {\n \tt.mTreap.treap.walkTreap(checkTreapNode)\n \tt.mTreap.treap.validateInvariants()\n }\n+\n+func RunGetgThreadSwitchTest() {\n+\t// Test that getg works correctly with thread switch.\n+\t// With gccgo, if we generate getg inlined, the backend\n+\t// may cache the address of the TLS variable, which\n+\t// will become invalid after a thread switch. This test\n+\t// checks that the bad caching doesn't happen.\n+\n+\tch := make(chan int)\n+\tgo func(ch chan int) {\n+\t\tch <- 5\n+\t\tLockOSThread()\n+\t}(ch)\n+\n+\tg1 := getg()\n+\n+\t// Block on a receive. This is likely to get us a thread\n+\t// switch. If we yield to the sender goroutine, it will\n+\t// lock the thread, forcing us to resume on a different\n+\t// thread.\n+\t<-ch\n+\n+\tg2 := getg()\n+\tif g1 != g2 {\n+\t\tpanic(\"g1 != g2\")\n+\t}\n+\n+\t// Also test getg after some control flow, as the\n+\t// backend is sensitive to control flow.\n+\tg3 := getg()\n+\tif g1 != g3 {\n+\t\tpanic(\"g1 != g3\")\n+\t}\n+}"}, {"sha": "0eee55ef97ecfda4df88829b66b8c06386c2b2a3", "filename": "libgo/go/runtime/malloc.go", "status": "modified", "additions": 44, "deletions": 9, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fruntime%2Fmalloc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fruntime%2Fmalloc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmalloc.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -335,12 +335,21 @@ const (\n var physPageSize uintptr\n \n // physHugePageSize is the size in bytes of the OS's default physical huge\n-// page size whose allocation is opaque to the application.\n+// page size whose allocation is opaque to the application. It is assumed\n+// and verified to be a power of two.\n //\n // If set, this must be set by the OS init code (typically in osinit) before\n // mallocinit. However, setting it at all is optional, and leaving the default\n // value is always safe (though potentially less efficient).\n-var physHugePageSize uintptr\n+//\n+// Since physHugePageSize is always assumed to be a power of two,\n+// physHugePageShift is defined as physHugePageSize == 1 << physHugePageShift.\n+// The purpose of physHugePageShift is to avoid doing divisions in\n+// performance critical functions.\n+var (\n+\tphysHugePageSize  uintptr\n+\tphysHugePageShift uint\n+)\n \n // OS memory management abstraction layer\n //\n@@ -443,6 +452,17 @@ func mallocinit() {\n \t\tprint(\"system page size (\", physPageSize, \") must be a power of 2\\n\")\n \t\tthrow(\"bad system page size\")\n \t}\n+\tif physHugePageSize&(physHugePageSize-1) != 0 {\n+\t\tprint(\"system huge page size (\", physHugePageSize, \") must be a power of 2\\n\")\n+\t\tthrow(\"bad system huge page size\")\n+\t}\n+\tif physHugePageSize != 0 {\n+\t\t// Since physHugePageSize is a power of 2, it suffices to increase\n+\t\t// physHugePageShift until 1<<physHugePageShift == physHugePageSize.\n+\t\tfor 1<<physHugePageShift != physHugePageSize {\n+\t\t\tphysHugePageShift++\n+\t\t}\n+\t}\n \n \t// Initialize the heap.\n \tmheap_.init()\n@@ -877,7 +897,22 @@ func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \tif debug.sbrk != 0 {\n \t\talign := uintptr(16)\n \t\tif typ != nil {\n-\t\t\talign = uintptr(typ.align)\n+\t\t\t// TODO(austin): This should be just\n+\t\t\t//   align = uintptr(typ.align)\n+\t\t\t// but that's only 4 on 32-bit platforms,\n+\t\t\t// even if there's a uint64 field in typ (see #599).\n+\t\t\t// This causes 64-bit atomic accesses to panic.\n+\t\t\t// Hence, we use stricter alignment that matches\n+\t\t\t// the normal allocator better.\n+\t\t\tif size&7 == 0 {\n+\t\t\t\talign = 8\n+\t\t\t} else if size&3 == 0 {\n+\t\t\t\talign = 4\n+\t\t\t} else if size&1 == 0 {\n+\t\t\t\talign = 2\n+\t\t\t} else {\n+\t\t\t\talign = 1\n+\t\t\t}\n \t\t}\n \t\treturn persistentalloc(size, align, &memstats.other_sys)\n \t}\n@@ -1076,8 +1111,8 @@ func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \t}\n \n \tif rate := MemProfileRate; rate > 0 {\n-\t\tif rate != 1 && int32(size) < c.next_sample {\n-\t\t\tc.next_sample -= int32(size)\n+\t\tif rate != 1 && size < c.next_sample {\n+\t\t\tc.next_sample -= size\n \t\t} else {\n \t\t\tmp := acquirem()\n \t\t\tprofilealloc(mp, x, size)\n@@ -1180,15 +1215,15 @@ func profilealloc(mp *m, x unsafe.Pointer, size uintptr) {\n // processes, the distance between two samples follows the exponential\n // distribution (exp(MemProfileRate)), so the best return value is a random\n // number taken from an exponential distribution whose mean is MemProfileRate.\n-func nextSample() int32 {\n+func nextSample() uintptr {\n \tif GOOS == \"plan9\" {\n \t\t// Plan 9 doesn't support floating point in note handler.\n \t\tif g := getg(); g == g.m.gsignal {\n \t\t\treturn nextSampleNoFP()\n \t\t}\n \t}\n \n-\treturn fastexprand(MemProfileRate)\n+\treturn uintptr(fastexprand(MemProfileRate))\n }\n \n // fastexprand returns a random number from an exponential distribution with\n@@ -1223,14 +1258,14 @@ func fastexprand(mean int) int32 {\n \n // nextSampleNoFP is similar to nextSample, but uses older,\n // simpler code to avoid floating point.\n-func nextSampleNoFP() int32 {\n+func nextSampleNoFP() uintptr {\n \t// Set first allocation sample size.\n \trate := MemProfileRate\n \tif rate > 0x3fffffff { // make 2*rate not overflow\n \t\trate = 0x3fffffff\n \t}\n \tif rate != 0 {\n-\t\treturn int32(fastrand() % uint32(2*rate))\n+\t\treturn uintptr(fastrand() % uint32(2*rate))\n \t}\n \treturn 0\n }"}, {"sha": "27328e1e31e5db955e0a601b1d54bceada113f4d", "filename": "libgo/go/runtime/mcache.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fruntime%2Fmcache.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fruntime%2Fmcache.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmcache.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -19,7 +19,7 @@ import (\n type mcache struct {\n \t// The following members are accessed on every malloc,\n \t// so they are grouped here for better caching.\n-\tnext_sample int32   // trigger heap sample after allocating this many bytes\n+\tnext_sample uintptr // trigger heap sample after allocating this many bytes\n \tlocal_scan  uintptr // bytes of scannable heap allocated\n \n \t// Allocator cache for tiny objects w/o pointers."}, {"sha": "9f8c4725f0881aaf6edb446304d0832997089b10", "filename": "libgo/go/runtime/mgcscavenge.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fruntime%2Fmgcscavenge.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fruntime%2Fmgcscavenge.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmgcscavenge.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -130,22 +130,22 @@ func gcPaceScavenger() {\n \tif physHugePageSize != 0 {\n \t\t// Start by computing the amount of free memory we have in huge pages\n \t\t// in total. Trivially, this is all the huge page work we need to do.\n-\t\thugeWork := uint64(mheap_.free.unscavHugePages * physHugePageSize)\n+\t\thugeWork := uint64(mheap_.free.unscavHugePages) << physHugePageShift\n \n \t\t// ...but it could turn out that there's more huge work to do than\n \t\t// total work, so cap it at total work. This might happen for very large\n \t\t// heaps where the additional factor of retainExtraPercent can make it so\n \t\t// that there are free chunks of memory larger than a huge page that we don't want\n \t\t// to scavenge.\n \t\tif hugeWork >= totalWork {\n-\t\t\thugePages := totalWork / uint64(physHugePageSize)\n-\t\t\thugeWork = hugePages * uint64(physHugePageSize)\n+\t\t\thugePages := totalWork >> physHugePageShift\n+\t\t\thugeWork = hugePages << physHugePageShift\n \t\t}\n \t\t// Everything that's not huge work is regular work. At this point we\n \t\t// know huge work so we can calculate how much time that will take\n \t\t// based on scavengePageRate (which applies to pages of any size).\n \t\tregularWork = totalWork - hugeWork\n-\t\thugeTime = hugeWork / uint64(physHugePageSize) * scavengeHugePagePeriod\n+\t\thugeTime = (hugeWork >> physHugePageShift) * scavengeHugePagePeriod\n \t}\n \t// Finally, we can compute how much time it'll take to do the regular work\n \t// and the total time to do all the work."}, {"sha": "cd01b3f757014ee7ff4bc49f58d585690aa5e171", "filename": "libgo/go/runtime/mheap.go", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fruntime%2Fmheap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fruntime%2Fmheap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmheap.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -514,35 +514,43 @@ func (h *mheap) coalesce(s *mspan) {\n \t\th.free.insert(other)\n \t}\n \n-\thpBefore := s.hugePages()\n+\thpMiddle := s.hugePages()\n \n \t// Coalesce with earlier, later spans.\n+\tvar hpBefore uintptr\n \tif before := spanOf(s.base() - 1); before != nil && before.state == mSpanFree {\n \t\tif s.scavenged == before.scavenged {\n+\t\t\thpBefore = before.hugePages()\n \t\t\tmerge(before, s, before)\n \t\t} else {\n \t\t\trealign(before, s, before)\n \t\t}\n \t}\n \n \t// Now check to see if next (greater addresses) span is free and can be coalesced.\n+\tvar hpAfter uintptr\n \tif after := spanOf(s.base() + s.npages*pageSize); after != nil && after.state == mSpanFree {\n \t\tif s.scavenged == after.scavenged {\n+\t\t\thpAfter = after.hugePages()\n \t\t\tmerge(s, after, after)\n \t\t} else {\n \t\t\trealign(s, after, after)\n \t\t}\n \t}\n-\n-\tif !s.scavenged && s.hugePages() > hpBefore {\n+\tif !s.scavenged && s.hugePages() > hpBefore+hpMiddle+hpAfter {\n \t\t// If s has grown such that it now may contain more huge pages than it\n-\t\t// did before, then mark the whole region as huge-page-backable.\n+\t\t// and its now-coalesced neighbors did before, then mark the whole region\n+\t\t// as huge-page-backable.\n \t\t//\n \t\t// Otherwise, on systems where we break up huge pages (like Linux)\n \t\t// s may not be backed by huge pages because it could be made up of\n \t\t// pieces which are broken up in the underlying VMA. The primary issue\n \t\t// with this is that it can lead to a poor estimate of the amount of\n \t\t// free memory backed by huge pages for determining the scavenging rate.\n+\t\t//\n+\t\t// TODO(mknyszek): Measure the performance characteristics of sysHugePage\n+\t\t// and determine whether it makes sense to only sysHugePage on the pages\n+\t\t// that matter, or if it's better to just mark the whole region.\n \t\tsysHugePage(unsafe.Pointer(s.base()), s.npages*pageSize)\n \t}\n }\n@@ -561,7 +569,7 @@ func (s *mspan) hugePages() uintptr {\n \t\tend &^= physHugePageSize - 1\n \t}\n \tif start < end {\n-\t\treturn (end - start) / physHugePageSize\n+\t\treturn (end - start) >> physHugePageShift\n \t}\n \treturn 0\n }"}, {"sha": "2a11f9329bcff41c2e2bb57d1c82887432f5718c", "filename": "libgo/go/runtime/panic.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fruntime%2Fpanic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fruntime%2Fpanic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpanic.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -61,13 +61,24 @@ func panicCheck1(pc uintptr, msg string) {\n }\n \n // Same as above, but calling from the runtime is allowed.\n+//\n+// Using this function is necessary for any panic that may be\n+// generated by runtime.sigpanic, since those are always called by the\n+// runtime.\n func panicCheck2(err string) {\n+\t// panic allocates, so to avoid recursive malloc, turn panics\n+\t// during malloc into throws.\n \tgp := getg()\n \tif gp != nil && gp.m != nil && gp.m.mallocing != 0 {\n \t\tthrow(err)\n \t}\n }\n \n+// Many of the following panic entry-points turn into throws when they\n+// happen in various runtime contexts. These should never happen in\n+// the runtime, and if they do, they indicate a serious issue and\n+// should not be caught by user code.\n+//\n // The panic{Index,Slice,divide,shift} functions are called by\n // code generated by the compiler for out of bounds index expressions,\n // out of bounds slice expressions, division by zero, and shift by negative."}, {"sha": "b71bbad9a69d176f3f721c6a26367759104caf9f", "filename": "libgo/go/runtime/pprof/runtime.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fruntime%2Fpprof%2Fruntime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fruntime%2Fpprof%2Fruntime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fruntime.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -16,6 +16,7 @@ func runtime_setProfLabel(labels unsafe.Pointer)\n func runtime_getProfLabel() unsafe.Pointer\n \n // SetGoroutineLabels sets the current goroutine's labels to match ctx.\n+// A new goroutine inherits the labels of the goroutine that created it.\n // This is a lower-level API than Do, which should be used instead when possible.\n func SetGoroutineLabels(ctx context.Context) {\n \tctxLabels, _ := ctx.Value(labelContextKey{}).(*labelMap)\n@@ -24,6 +25,7 @@ func SetGoroutineLabels(ctx context.Context) {\n \n // Do calls f with a copy of the parent context with the\n // given labels added to the parent's label map.\n+// Goroutines spawned while executing f will inherit the augmented label-set.\n // Each key/value pair in labels is inserted into the label map in the\n // order provided, overriding any previous value for the same key.\n // The augmented label map will be set for the duration of the call to f"}, {"sha": "a0147cf954de97c10a4ef3dd1e26fcfc32033b83", "filename": "libgo/go/runtime/proc.go", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fruntime%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fruntime%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -3505,9 +3505,6 @@ func _GC()                        { _GC() }\n func _LostSIGPROFDuringAtomic64() { _LostSIGPROFDuringAtomic64() }\n func _VDSO()                      { _VDSO() }\n \n-// Counts SIGPROFs received while in atomic64 critical section, on mips{,le}\n-var lostAtomic64Count uint64\n-\n var _SystemPC = funcPC(_System)\n var _ExternalCodePC = funcPC(_ExternalCode)\n var _LostExternalCodePC = funcPC(_LostExternalCode)\n@@ -3598,10 +3595,6 @@ func sigprof(pc uintptr, gp *g, mp *m) {\n \t}\n \n \tif prof.hz != 0 {\n-\t\tif (GOARCH == \"mips\" || GOARCH == \"mipsle\" || GOARCH == \"arm\") && lostAtomic64Count > 0 {\n-\t\t\tcpuprof.addLostAtomic64(lostAtomic64Count)\n-\t\t\tlostAtomic64Count = 0\n-\t\t}\n \t\tcpuprof.add(gp, stk[:n])\n \t}\n \tgetg().m.mallocing--"}, {"sha": "fee03be6e58cf7bcaf10d5980196820e69045529", "filename": "libgo/go/runtime/proc_test.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fruntime%2Fproc_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fruntime%2Fproc_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -984,3 +984,7 @@ func TestPreemptionAfterSyscall(t *testing.T) {\n \t\t})\n \t}\n }\n+\n+func TestGetgThreadSwitch(t *testing.T) {\n+\truntime.RunGetgThreadSwitchTest()\n+}"}, {"sha": "20704642f8ddcb9f47a1f3878cc17eb645da6fc0", "filename": "libgo/go/runtime/sigqueue.go", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fruntime%2Fsigqueue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fruntime%2Fsigqueue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsigqueue.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -105,6 +105,10 @@ Send:\n \t\t\tbreak Send\n \t\tcase sigReceiving:\n \t\t\tif atomic.Cas(&sig.state, sigReceiving, sigIdle) {\n+\t\t\t\tif GOOS == \"darwin\" {\n+\t\t\t\t\tsigNoteWakeup(&sig.note)\n+\t\t\t\t\tbreak Send\n+\t\t\t\t}\n \t\t\t\tnotewakeup(&sig.note)\n \t\t\t\tbreak Send\n \t\t\t}\n@@ -136,6 +140,10 @@ func signal_recv() uint32 {\n \t\t\t\tthrow(\"signal_recv: inconsistent state\")\n \t\t\tcase sigIdle:\n \t\t\t\tif atomic.Cas(&sig.state, sigIdle, sigReceiving) {\n+\t\t\t\t\tif GOOS == \"darwin\" {\n+\t\t\t\t\t\tsigNoteSleep(&sig.note)\n+\t\t\t\t\t\tbreak Receive\n+\t\t\t\t\t}\n \t\t\t\t\tnotetsleepg(&sig.note, -1)\n \t\t\t\t\tnoteclear(&sig.note)\n \t\t\t\t\tbreak Receive\n@@ -188,6 +196,10 @@ func signal_enable(s uint32) {\n \t\t// to use for initialization. It does not pass\n \t\t// signal information in m.\n \t\tsig.inuse = true // enable reception of signals; cannot disable\n+\t\tif GOOS == \"darwin\" {\n+\t\t\tsigNoteSetup(&sig.note)\n+\t\t\treturn\n+\t\t}\n \t\tnoteclear(&sig.note)\n \t\treturn\n \t}"}, {"sha": "16aeeb2ef0b41a5e4e60f897eabbab678121ff46", "filename": "libgo/go/runtime/sigqueue_note.go", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fruntime%2Fsigqueue_note.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fruntime%2Fsigqueue_note.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsigqueue_note.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// The current implementation of notes on Darwin is not async-signal-safe,\n+// so on Darwin the sigqueue code uses different functions to wake up the\n+// signal_recv thread. This file holds the non-Darwin implementations of\n+// those functions. These functions will never be called.\n+\n+// +build !darwin\n+// +build !plan9\n+\n+package runtime\n+\n+func sigNoteSetup(*note) {\n+\tthrow(\"sigNoteSetup\")\n+}\n+\n+func sigNoteSleep(*note) {\n+\tthrow(\"sigNoteSleep\")\n+}\n+\n+func sigNoteWakeup(*note) {\n+\tthrow(\"sigNoteWakeup\")\n+}"}, {"sha": "d531bda33febda1d102a46e108d076f0b9ef79af", "filename": "libgo/go/strconv/atof.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fstrconv%2Fatof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fstrconv%2Fatof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fatof.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -649,7 +649,7 @@ func atof64(s string) (f float64, err error) {\n // ParseFloat returns the nearest floating-point number rounded\n // using IEEE754 unbiased rounding.\n // (Parsing a hexadecimal floating-point value only rounds when\n-// there are more bits in the hexadecimal representatiton than\n+// there are more bits in the hexadecimal representation than\n // will fit in the mantissa.)\n //\n // The errors that ParseFloat returns have concrete type *NumError"}, {"sha": "0233f14b406e4fc56dd40d8d334f81ca091dd398", "filename": "libgo/go/strconv/atoi.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fstrconv%2Fatoi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fstrconv%2Fatoi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fatoi.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -154,7 +154,8 @@ func ParseUint(s string, base int, bitSize int) (uint64, error) {\n //\n // If base == 0, the base is implied by the string's prefix:\n // base 2 for \"0b\", base 8 for \"0\" or \"0o\", base 16 for \"0x\",\n-// and base 10 otherwise.\n+// and base 10 otherwise. Also, for base == 0 only, underscore\n+// characters are permitted per the Go integer literal syntax.\n // If base is below 0, is 1, or is above 36, an error is returned.\n //\n // The bitSize argument specifies the integer type"}, {"sha": "375f9cac6502e89a0124315a04c1700b8cbd13ae", "filename": "libgo/go/strings/example_test.go", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fstrings%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fstrings%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Fexample_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -247,14 +247,23 @@ func ExampleSplitAfterN() {\n }\n \n func ExampleTitle() {\n+\t// Compare this example to the ToTitle example.\n \tfmt.Println(strings.Title(\"her royal highness\"))\n-\t// Output: Her Royal Highness\n+\tfmt.Println(strings.Title(\"loud noises\"))\n+\tfmt.Println(strings.Title(\"\u0445\u043b\u0435\u0431\"))\n+\t// Output:\n+\t// Her Royal Highness\n+\t// Loud Noises\n+\t// \u0425\u043b\u0435\u0431\n }\n \n func ExampleToTitle() {\n+\t// Compare this example to the Title example.\n+\tfmt.Println(strings.ToTitle(\"her royal highness\"))\n \tfmt.Println(strings.ToTitle(\"loud noises\"))\n \tfmt.Println(strings.ToTitle(\"\u0445\u043b\u0435\u0431\"))\n \t// Output:\n+\t// HER ROYAL HIGHNESS\n \t// LOUD NOISES\n \t// \u0425\u041b\u0415\u0411\n }"}, {"sha": "e28d42887930b9d852bdd2129c28f4ebf3bd8c8b", "filename": "libgo/go/strings/replace.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fstrings%2Freplace.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fstrings%2Freplace.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Freplace.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -25,7 +25,8 @@ type replacer interface {\n \n // NewReplacer returns a new Replacer from a list of old, new string\n // pairs. Replacements are performed in the order they appear in the\n-// target string, without overlapping matches.\n+// target string, without overlapping matches. The old string\n+// comparisons are done in argument order.\n //\n // NewReplacer panics if given an odd number of arguments.\n func NewReplacer(oldnew ...string) *Replacer {"}, {"sha": "cee315ce9e4027b9647a0b1f550f91b3b92c277a", "filename": "libgo/go/strings/strings.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fstrings%2Fstrings.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fstrings%2Fstrings.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Fstrings.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -610,7 +610,8 @@ func ToLower(s string) string {\n \treturn Map(unicode.ToLower, s)\n }\n \n-// ToTitle returns a copy of the string s with all Unicode letters mapped to their title case.\n+// ToTitle returns a copy of the string s with all Unicode letters mapped to\n+// their Unicode title case.\n func ToTitle(s string) string { return Map(unicode.ToTitle, s) }\n \n // ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their\n@@ -626,7 +627,7 @@ func ToLowerSpecial(c unicode.SpecialCase, s string) string {\n }\n \n // ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their\n-// title case, giving priority to the special casing rules.\n+// Unicode title case, giving priority to the special casing rules.\n func ToTitleSpecial(c unicode.SpecialCase, s string) string {\n \treturn Map(c.ToTitle, s)\n }\n@@ -707,7 +708,7 @@ func isSeparator(r rune) bool {\n }\n \n // Title returns a copy of the string s with all Unicode letters that begin words\n-// mapped to their title case.\n+// mapped to their Unicode title case.\n //\n // BUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly.\n func Title(s string) string {"}, {"sha": "ffbe56746406288ae48cda2173346ed0b7f25d2d", "filename": "libgo/go/sync/export_test.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fsync%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fsync%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fexport_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -18,9 +18,13 @@ type PoolDequeue interface {\n }\n \n func NewPoolDequeue(n int) PoolDequeue {\n-\treturn &poolDequeue{\n+\td := &poolDequeue{\n \t\tvals: make([]eface, n),\n \t}\n+\t// For testing purposes, set the head and tail indexes close\n+\t// to wrapping around.\n+\td.headTail = d.pack(1<<dequeueBits-500, 1<<dequeueBits-500)\n+\treturn d\n }\n \n func (d *poolDequeue) PushHead(val interface{}) bool {"}, {"sha": "ca044082241232ec7ed7fe2a850a9e10d0978633", "filename": "libgo/go/sync/once.go", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fsync%2Fonce.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fsync%2Fonce.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fonce.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -38,6 +38,20 @@ type Once struct {\n // without calling f.\n //\n func (o *Once) Do(f func()) {\n+\t// Note: Here is an incorrect implementation of Do:\n+\t//\n+\t//\tif atomic.CompareAndSwapUint32(&o.done, 0, 1) {\n+\t//\t\tf()\n+\t//\t}\n+\t//\n+\t// Do guarantees that when it returns, f has finished.\n+\t// This implementation would not implement that guarantee:\n+\t// given two simultaneous calls, the winner of the cas would\n+\t// call f, and the second would return immediately, without\n+\t// waiting for the first's call to f to complete.\n+\t// This is why the slow path falls back to a mutex, and why\n+\t// the atomic.StoreUint32 must be delayed until after f returns.\n+\n \tif atomic.LoadUint32(&o.done) == 0 {\n \t\t// Outlined slow-path to allow inlining of the fast-path.\n \t\to.doSlow(f)"}, {"sha": "c67bd8c4e8c314733507ffcfe598983abeff9aed", "filename": "libgo/go/sync/pool_test.go", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fsync%2Fpool_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fsync%2Fpool_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fpool_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -174,15 +174,19 @@ func TestPoolChain(t *testing.T) {\n \n func testPoolDequeue(t *testing.T, d PoolDequeue) {\n \tconst P = 10\n-\t// In long mode, do enough pushes to wrap around the 21-bit\n-\t// indexes.\n-\tN := 1<<21 + 1000\n+\tvar N int = 2e6\n \tif testing.Short() {\n \t\tN = 1e3\n \t}\n \thave := make([]int32, N)\n \tvar stop int32\n \tvar wg WaitGroup\n+\trecord := func(val int) {\n+\t\tatomic.AddInt32(&have[val], 1)\n+\t\tif val == N-1 {\n+\t\t\tatomic.StoreInt32(&stop, 1)\n+\t\t}\n+\t}\n \n \t// Start P-1 consumers.\n \tfor i := 1; i < P; i++ {\n@@ -193,10 +197,7 @@ func testPoolDequeue(t *testing.T, d PoolDequeue) {\n \t\t\t\tval, ok := d.PopTail()\n \t\t\t\tif ok {\n \t\t\t\t\tfail = 0\n-\t\t\t\t\tatomic.AddInt32(&have[val.(int)], 1)\n-\t\t\t\t\tif val.(int) == N-1 {\n-\t\t\t\t\t\tatomic.StoreInt32(&stop, 1)\n-\t\t\t\t\t}\n+\t\t\t\t\trecord(val.(int))\n \t\t\t\t} else {\n \t\t\t\t\t// Speed up the test by\n \t\t\t\t\t// allowing the pusher to run.\n@@ -222,7 +223,7 @@ func testPoolDequeue(t *testing.T, d PoolDequeue) {\n \t\t\t\tval, ok := d.PopHead()\n \t\t\t\tif ok {\n \t\t\t\t\tnPopHead++\n-\t\t\t\t\tatomic.AddInt32(&have[val.(int)], 1)\n+\t\t\t\t\trecord(val.(int))\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -236,10 +237,12 @@ func testPoolDequeue(t *testing.T, d PoolDequeue) {\n \t\t\tt.Errorf(\"expected have[%d] = 1, got %d\", i, count)\n \t\t}\n \t}\n-\tif nPopHead == 0 {\n-\t\t// In theory it's possible in a valid schedule for\n-\t\t// popHead to never succeed, but in practice it almost\n-\t\t// always succeeds, so this is unlikely to flake.\n+\t// Check that at least some PopHeads succeeded. We skip this\n+\t// check in short mode because it's common enough that the\n+\t// queue will stay nearly empty all the time and a PopTail\n+\t// will happen during the window between every PushHead and\n+\t// PopHead.\n+\tif !testing.Short() && nPopHead == 0 {\n \t\tt.Errorf(\"popHead never succeeded\")\n \t}\n }"}, {"sha": "a241e2101f4521b932adc2e9647ff16ef54ea811", "filename": "libgo/go/syscall/exec_bsd.go", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fsyscall%2Fexec_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fsyscall%2Fexec_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_bsd.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -168,26 +168,6 @@ func forkAndExecInChild(argv0 *byte, argv, envv []*byte, chroot, dir *byte, attr\n \t\t}\n \t}\n \n-\t// Detach fd 0 from tty\n-\tif sys.Noctty {\n-\t\t_, err1 = raw_ioctl(0, TIOCNOTTY, 0)\n-\t\tif err1 != 0 {\n-\t\t\tgoto childerror\n-\t\t}\n-\t}\n-\n-\t// Set the controlling TTY to Ctty\n-\tif sys.Setctty {\n-\t\tif TIOCSCTTY == 0 {\n-\t\t\terr1 = ENOSYS\n-\t\t\tgoto childerror\n-\t\t}\n-\t\t_, err1 = raw_ioctl(sys.Ctty, TIOCSCTTY, 0)\n-\t\tif err1 != 0 {\n-\t\t\tgoto childerror\n-\t\t}\n-\t}\n-\n \t// Pass 1: look for fd[i] < i and move those up above len(fd)\n \t// so that pass 2 won't stomp on an fd it needs later.\n \tif pipe < nextfd {\n@@ -245,6 +225,26 @@ func forkAndExecInChild(argv0 *byte, argv, envv []*byte, chroot, dir *byte, attr\n \t\traw_close(i)\n \t}\n \n+\t// Detach fd 0 from tty\n+\tif sys.Noctty {\n+\t\t_, err1 = raw_ioctl(0, TIOCNOTTY, 0)\n+\t\tif err1 != 0 {\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n+\t// Set the controlling TTY to Ctty\n+\tif sys.Setctty {\n+\t\tif TIOCSCTTY == 0 {\n+\t\t\terr1 = ENOSYS\n+\t\t\tgoto childerror\n+\t\t}\n+\t\t_, err1 = raw_ioctl(sys.Ctty, TIOCSCTTY, 0)\n+\t\tif err1 != 0 {\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n \t// Time to exec.\n \terr1 = raw_execve(argv0, &argv[0], &envv[0])\n "}, {"sha": "ac1ead3a2b3339930e352341b183dd6ac7374ccf", "filename": "libgo/go/syscall/exec_darwin.go", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fsyscall%2Fexec_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fsyscall%2Fexec_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_darwin.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -160,22 +160,6 @@ func forkAndExecInChild(argv0 *byte, argv, envv []*byte, chroot, dir *byte, attr\n \t\t}\n \t}\n \n-\t// Detach fd 0 from tty\n-\tif sys.Noctty {\n-\t\t_, _, err1 = rawSyscall(funcPC(libc_ioctl_trampoline), 0, uintptr(TIOCNOTTY), 0)\n-\t\tif err1 != 0 {\n-\t\t\tgoto childerror\n-\t\t}\n-\t}\n-\n-\t// Set the controlling TTY to Ctty\n-\tif sys.Setctty {\n-\t\t_, _, err1 = rawSyscall(funcPC(libc_ioctl_trampoline), uintptr(sys.Ctty), uintptr(TIOCSCTTY), 0)\n-\t\tif err1 != 0 {\n-\t\t\tgoto childerror\n-\t\t}\n-\t}\n-\n \t// Pass 1: look for fd[i] < i and move those up above len(fd)\n \t// so that pass 2 won't stomp on an fd it needs later.\n \tif pipe < nextfd {\n@@ -233,6 +217,22 @@ func forkAndExecInChild(argv0 *byte, argv, envv []*byte, chroot, dir *byte, attr\n \t\trawSyscall(funcPC(libc_close_trampoline), uintptr(i), 0, 0)\n \t}\n \n+\t// Detach fd 0 from tty\n+\tif sys.Noctty {\n+\t\t_, _, err1 = rawSyscall(funcPC(libc_ioctl_trampoline), 0, uintptr(TIOCNOTTY), 0)\n+\t\tif err1 != 0 {\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n+\t// Set the controlling TTY to Ctty\n+\tif sys.Setctty {\n+\t\t_, _, err1 = rawSyscall(funcPC(libc_ioctl_trampoline), uintptr(sys.Ctty), uintptr(TIOCSCTTY), 0)\n+\t\tif err1 != 0 {\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n \t// Time to exec.\n \t_, _, err1 = rawSyscall(funcPC(libc_execve_trampoline),\n \t\tuintptr(unsafe.Pointer(argv0)),"}, {"sha": "f842cdc85bf42218febac79e0822b47cb815bf09", "filename": "libgo/go/syscall/exec_linux.go", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fsyscall%2Fexec_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fsyscall%2Fexec_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_linux.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -440,22 +440,6 @@ func forkAndExecInChild1(argv0 *byte, argv, envv []*byte, chroot, dir *byte, att\n \t\t}\n \t}\n \n-\t// Detach fd 0 from tty\n-\tif sys.Noctty {\n-\t\t_, err1 = raw_ioctl(0, TIOCNOTTY, 0)\n-\t\tif err1 != 0 {\n-\t\t\tgoto childerror\n-\t\t}\n-\t}\n-\n-\t// Set the controlling TTY to Ctty\n-\tif sys.Setctty {\n-\t\t_, err1 = raw_ioctl(sys.Ctty, TIOCSCTTY, 1)\n-\t\tif err1 != 0 {\n-\t\t\tgoto childerror\n-\t\t}\n-\t}\n-\n \t// Pass 1: look for fd[i] < i and move those up above len(fd)\n \t// so that pass 2 won't stomp on an fd it needs later.\n \tif pipe < nextfd {\n@@ -513,6 +497,22 @@ func forkAndExecInChild1(argv0 *byte, argv, envv []*byte, chroot, dir *byte, att\n \t\traw_close(i)\n \t}\n \n+\t// Detach fd 0 from tty\n+\tif sys.Noctty {\n+\t\t_, err1 = raw_ioctl(0, TIOCNOTTY, 0)\n+\t\tif err1 != 0 {\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n+\t// Set the controlling TTY to Ctty\n+\tif sys.Setctty {\n+\t\t_, err1 = raw_ioctl(sys.Ctty, TIOCSCTTY, 1)\n+\t\tif err1 != 0 {\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n \t// Enable tracing if requested.\n \t// Do this right before exec so that we don't unnecessarily trace the runtime\n \t// setting up after the fork. See issue #21428."}, {"sha": "a339ae82588ff72efdb6a94ee0a932b57a160d29", "filename": "libgo/go/syscall/syscall_errno.go", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fsyscall%2Fsyscall_errno.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fsyscall%2Fsyscall_errno.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsyscall_errno.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -21,10 +21,6 @@ func (e Errno) Error() string {\n \n func (e Errno) Is(target error) bool {\n \tswitch target {\n-\tcase oserror.ErrTemporary:\n-\t\treturn e.Temporary()\n-\tcase oserror.ErrTimeout:\n-\t\treturn e.Timeout()\n \tcase oserror.ErrPermission:\n \t\treturn e == EACCES || e == EPERM\n \tcase oserror.ErrExist:"}, {"sha": "a9e4560e9666c720b6e7c6405ac5bfa2ecf42bb2", "filename": "libgo/go/syscall/syscall_freebsd.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fsyscall%2Fsyscall_freebsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fsyscall%2Fsyscall_freebsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsyscall_freebsd.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -11,12 +11,12 @@ import (\n \n const (\n \t_SYS_FSTAT_FREEBSD12         = 551 // { int fstat(int fd, _Out_ struct stat *sb); }\n-\t_SYS_FSTATAT_FREEBSD12       = 552 // { int fstatat(int fd, _In_z_ char *path, \\\n-\t_SYS_GETDIRENTRIES_FREEBSD12 = 554 // { ssize_t getdirentries(int fd, \\\n-\t_SYS_STATFS_FREEBSD12        = 555 // { int statfs(_In_z_ char *path, \\\n-\t_SYS_FSTATFS_FREEBSD12       = 556 // { int fstatfs(int fd, \\\n-\t_SYS_GETFSSTAT_FREEBSD12     = 557 // { int getfsstat( \\\n-\t_SYS_MKNODAT_FREEBSD12       = 559 // { int mknodat(int fd, _In_z_ char *path, \\\n+\t_SYS_FSTATAT_FREEBSD12       = 552 // { int fstatat(int fd, _In_z_ char *path, _Out_ struct stat *buf, int flag); }\n+\t_SYS_GETDIRENTRIES_FREEBSD12 = 554 // { ssize_t getdirentries(int fd, _Out_writes_bytes_(count) char *buf, size_t count, _Out_ off_t *basep); }\n+\t_SYS_STATFS_FREEBSD12        = 555 // { int statfs(_In_z_ char *path, _Out_ struct statfs *buf); }\n+\t_SYS_FSTATFS_FREEBSD12       = 556 // { int fstatfs(int fd, _Out_ struct statfs *buf); }\n+\t_SYS_GETFSSTAT_FREEBSD12     = 557 // { int getfsstat(_Out_writes_bytes_opt_(bufsize) struct statfs *buf, long bufsize, int mode); }\n+\t_SYS_MKNODAT_FREEBSD12       = 559 // { int mknodat(int fd, _In_z_ char *path, mode_t mode, dev_t dev); }\n )\n \n // See https://www.freebsd.org/doc/en_US.ISO8859-1/books/porters-handbook/versions.html."}, {"sha": "175fe47fcaa0d3c76a545d4cfe61dda68d0bf865", "filename": "libgo/go/syscall/syscall_js.go", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fsyscall%2Fsyscall_js.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Fsyscall%2Fsyscall_js.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsyscall_js.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -58,10 +58,6 @@ func (e Errno) Error() string {\n \n func (e Errno) Is(target error) bool {\n \tswitch target {\n-\tcase oserror.ErrTemporary:\n-\t\treturn e.Temporary()\n-\tcase oserror.ErrTimeout:\n-\t\treturn e.Timeout()\n \tcase oserror.ErrPermission:\n \t\treturn e == EACCES || e == EPERM\n \tcase oserror.ErrExist:"}, {"sha": "6ab9b7919615bb2621b2331f2cf6887a82a433b2", "filename": "libgo/go/testing/testing.go", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Ftesting%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Ftesting%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Ftesting.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -1075,11 +1075,6 @@ type testDeps interface {\n // It is not meant to be called directly and is not subject to the Go 1 compatibility document.\n // It may change signature from release to release.\n func MainStart(deps testDeps, tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample) *M {\n-\t// In most cases, Init has already been called by the testinginit code\n-\t// that 'go test' injects into test packages.\n-\t// Call it again here to handle cases such as:\n-\t// - test packages that don't import \"testing\" (such as example-only packages)\n-\t// - direct use of MainStart (though that isn't well-supported)\n \tInit()\n \treturn &M{\n \t\tdeps:       deps,"}, {"sha": "e0847a7239680c286a4805834be680ff2104a754", "filename": "libgo/go/text/scanner/scanner.go", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Ftext%2Fscanner%2Fscanner.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Ftext%2Fscanner%2Fscanner.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Fscanner%2Fscanner.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -58,17 +58,19 @@ func (pos Position) String() string {\n // For instance, if the mode is ScanIdents (not ScanStrings), the string\n // \"foo\" is scanned as the token sequence '\"' Ident '\"'.\n //\n+// Use GoTokens to configure the Scanner such that it accepts all Go\n+// literal tokens including Go identifiers. Comments will be skipped.\n+//\n const (\n-\tScanIdents           = 1 << -Ident\n-\tScanInts             = 1 << -Int\n-\tScanFloats           = 1 << -Float // includes Ints and hexadecimal floats\n-\tScanChars            = 1 << -Char\n-\tScanStrings          = 1 << -String\n-\tScanRawStrings       = 1 << -RawString\n-\tScanComments         = 1 << -Comment\n-\tSkipComments         = 1 << -skipComment          // if set with ScanComments, comments become white space\n-\tAllowDigitSeparators = 1 << -allowDigitSeparators // if set, number literals may contain underscores as digit separators\n-\tGoTokens             = ScanIdents | ScanFloats | ScanChars | ScanStrings | ScanRawStrings | ScanComments | SkipComments | AllowDigitSeparators\n+\tScanIdents     = 1 << -Ident\n+\tScanInts       = 1 << -Int\n+\tScanFloats     = 1 << -Float // includes Ints and hexadecimal floats\n+\tScanChars      = 1 << -Char\n+\tScanStrings    = 1 << -String\n+\tScanRawStrings = 1 << -RawString\n+\tScanComments   = 1 << -Comment\n+\tSkipComments   = 1 << -skipComment // if set with ScanComments, comments become white space\n+\tGoTokens       = ScanIdents | ScanFloats | ScanChars | ScanStrings | ScanRawStrings | ScanComments | SkipComments\n )\n \n // The result of Scan is one of these tokens or a Unicode character.\n@@ -84,7 +86,6 @@ const (\n \n \t// internal use only\n \tskipComment\n-\tallowDigitSeparators\n )\n \n var tokenString = map[rune]string{\n@@ -363,8 +364,7 @@ func lower(ch rune) rune     { return ('a' - 'A') | ch } // returns lower-case c\n func isDecimal(ch rune) bool { return '0' <= ch && ch <= '9' }\n func isHex(ch rune) bool     { return '0' <= ch && ch <= '9' || 'a' <= lower(ch) && lower(ch) <= 'f' }\n \n-// digits accepts the sequence { digit } (if AllowDigitSeparators is not set)\n-// or { digit | '_' } (if AllowDigitSeparators is set), starting with ch0.\n+// digits accepts the sequence { digit | '_' } starting with ch0.\n // If base <= 10, digits accepts any decimal digit but records\n // the first invalid digit >= base in *invalid if *invalid == 0.\n // digits returns the first rune that is not part of the sequence\n@@ -374,7 +374,7 @@ func (s *Scanner) digits(ch0 rune, base int, invalid *rune) (ch rune, digsep int\n \tch = ch0\n \tif base <= 10 {\n \t\tmax := rune('0' + base)\n-\t\tfor isDecimal(ch) || ch == '_' && s.Mode&AllowDigitSeparators != 0 {\n+\t\tfor isDecimal(ch) || ch == '_' {\n \t\t\tds := 1\n \t\t\tif ch == '_' {\n \t\t\t\tds = 2\n@@ -385,7 +385,7 @@ func (s *Scanner) digits(ch0 rune, base int, invalid *rune) (ch rune, digsep int\n \t\t\tch = s.next()\n \t\t}\n \t} else {\n-\t\tfor isHex(ch) || ch == '_' && s.Mode&AllowDigitSeparators != 0 {\n+\t\tfor isHex(ch) || ch == '_' {\n \t\t\tds := 1\n \t\t\tif ch == '_' {\n \t\t\t\tds = 2"}, {"sha": "fe39d3060bf185a171aacc5ee527c7d4879582db", "filename": "libgo/go/text/scanner/scanner_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Ftext%2Fscanner%2Fscanner_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Ftext%2Fscanner%2Fscanner_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Fscanner%2Fscanner_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -886,8 +886,7 @@ func TestIssue30320(t *testing.T) {\n \t\t{\"foo01.bar31.xx-0-1-1-0\", \"01 31 0 1 1 0\", ScanInts},\n \t\t{\"foo0/12/0/5.67\", \"0 12 0 5 67\", ScanInts},\n \t\t{\"xxx1e0yyy\", \"1 0\", ScanInts},\n-\t\t{\"1_2\", \"1 2\", ScanInts}, // don't consume _ as part of a number if not explicitly enabled\n-\t\t{\"1_2\", \"1_2\", ScanInts | AllowDigitSeparators},\n+\t\t{\"1_2\", \"1_2\", ScanInts},\n \t\t{\"xxx1.0yyy2e3ee\", \"1 0 2 3\", ScanInts},\n \t\t{\"xxx1.0yyy2e3ee\", \"1.0 2e3\", ScanFloats},\n \t} {"}, {"sha": "2cc908da55e4fa767e37be542a857207ee4fcdbe", "filename": "libgo/go/time/sleep.go", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Ftime%2Fsleep.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Ftime%2Fsleep.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fsleep.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -54,8 +54,8 @@ type Timer struct {\n // Stop does not close the channel, to prevent a read from the channel succeeding\n // incorrectly.\n //\n-// To prevent a timer created with NewTimer from firing after a call to Stop,\n-// check the return value and drain the channel.\n+// To ensure the channel is empty after a call to Stop, check the\n+// return value and drain the channel.\n // For example, assuming the program has not received from t.C already:\n //\n // \tif !t.Stop() {\n@@ -97,10 +97,9 @@ func NewTimer(d Duration) *Timer {\n // It returns true if the timer had been active, false if the timer had\n // expired or been stopped.\n //\n-// Resetting a timer must take care not to race with the send into t.C\n-// that happens when the current timer expires.\n+// Reset should be invoked only on stopped or expired timers with drained channels.\n // If a program has already received a value from t.C, the timer is known\n-// to have expired, and t.Reset can be used directly.\n+// to have expired and the channel drained, so t.Reset can be used directly.\n // If a program has not yet received a value from t.C, however,\n // the timer must be stopped and\u2014if Stop reports that the timer expired\n // before being stopped\u2014the channel explicitly drained:"}, {"sha": "0d1cb9e5a153cda1dd3e71ee0ae11736dbe185f9", "filename": "libgo/go/time/time.go", "status": "modified", "additions": 8, "deletions": 25, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Ftime%2Ftime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Ftime%2Ftime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftime.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -906,33 +906,16 @@ func (t Time) Sub(u Time) Duration {\n \t\t}\n \t\treturn d\n \t}\n-\n-\tts, us := t.sec(), u.sec()\n-\n-\tvar sec, nsec, d int64\n-\n-\tssub := ts - us\n-\tif (ssub < ts) != (us > 0) {\n-\t\tgoto overflow\n-\t}\n-\n-\tif ssub < int64(minDuration/Second) || ssub > int64(maxDuration/Second) {\n-\t\tgoto overflow\n-\t}\n-\tsec = ssub * int64(Second)\n-\n-\tnsec = int64(t.nsec() - u.nsec())\n-\td = sec + nsec\n-\tif (d > sec) != (nsec > 0) {\n-\t\tgoto overflow\n-\t}\n-\treturn Duration(d)\n-\n-overflow:\n-\tif t.Before(u) {\n+\td := Duration(t.sec()-u.sec())*Second + Duration(t.nsec()-u.nsec())\n+\t// Check for overflow or underflow.\n+\tswitch {\n+\tcase u.Add(d).Equal(t):\n+\t\treturn d // d is correct\n+\tcase t.Before(u):\n \t\treturn minDuration // t - u is negative out of range\n+\tdefault:\n+\t\treturn maxDuration // t - u is positive out of range\n \t}\n-\treturn maxDuration // t - u is positive out of range\n }\n \n // Since returns the time elapsed since t."}, {"sha": "95998c362f09f97ef0c34e0c3808cebedefb53a9", "filename": "libgo/go/time/time_test.go", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Ftime%2Ftime_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fgo%2Ftime%2Ftime_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftime_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -995,6 +995,7 @@ var subTests = []struct {\n \t{Date(2300, 1, 1, 0, 0, 0, 0, UTC), Date(2000, 1, 1, 0, 0, 0, 0, UTC), Duration(maxDuration)},\n \t{Date(2000, 1, 1, 0, 0, 0, 0, UTC), Date(2290, 1, 1, 0, 0, 0, 0, UTC), -290*365*24*Hour - 71*24*Hour},\n \t{Date(2000, 1, 1, 0, 0, 0, 0, UTC), Date(2300, 1, 1, 0, 0, 0, 0, UTC), Duration(minDuration)},\n+\t{Date(2311, 11, 26, 02, 16, 47, 63535996, UTC), Date(2019, 8, 16, 2, 29, 30, 268436582, UTC), 9223372036795099414},\n \t{MinMonoTime, MaxMonoTime, minDuration},\n \t{MaxMonoTime, MinMonoTime, maxDuration},\n }\n@@ -1008,14 +1009,6 @@ func TestSub(t *testing.T) {\n \t}\n }\n \n-func BenchmarkSub(b *testing.B) {\n-\tfor i := 0; i < b.N; i++ {\n-\t\tfor _, st := range subTests {\n-\t\t\tst.t.Sub(st.u)\n-\t\t}\n-\t}\n-}\n-\n var nsDurationTests = []struct {\n \td    Duration\n \twant int64"}, {"sha": "b19747a05b96a96a4cfb22262fe2015d8d321aa2", "filename": "libgo/libgo-packages.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Flibgo-packages.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Flibgo-packages.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Flibgo-packages.txt?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -108,6 +108,7 @@ image/jpeg\n image/png\n index/suffixarray\n internal/bytealg\n+internal/cfg\n internal/cpu\n internal/fmtsort\n internal/goroot"}, {"sha": "1bdf843451d366b693857abe92a11d31ede08d6f", "filename": "libgo/misc/cgo/errors/errors_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fmisc%2Fcgo%2Ferrors%2Ferrors_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fmisc%2Fcgo%2Ferrors%2Ferrors_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ferrors%2Ferrors_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -112,6 +112,7 @@ func TestReportsTypeErrors(t *testing.T) {\n \t\t\"issue18452.go\",\n \t\t\"issue18889.go\",\n \t\t\"issue28721.go\",\n+\t\t\"issue33061.go\",\n \t} {\n \t\tcheck(t, file)\n \t}"}, {"sha": "4a46b6023bb510ab70e146c80358b7f56bee5f52", "filename": "libgo/misc/cgo/errors/ptr_test.go", "status": "modified", "additions": 47, "deletions": 35, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fmisc%2Fcgo%2Ferrors%2Fptr_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fmisc%2Fcgo%2Ferrors%2Fptr_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ferrors%2Fptr_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -156,8 +156,8 @@ var ptrTests = []ptrTest{\n \t\t// Storing a Go pointer into C memory should fail.\n \t\tname: \"barrier\",\n \t\tc: `#include <stdlib.h>\n-                    char **f14a() { return malloc(sizeof(char*)); }\n-                    void f14b(char **p) {}`,\n+\t\t    char **f14a() { return malloc(sizeof(char*)); }\n+\t\t    void f14b(char **p) {}`,\n \t\tbody:      `p := C.f14a(); *p = new(C.char); C.f14b(p)`,\n \t\tfail:      true,\n \t\texpensive: true,\n@@ -167,9 +167,9 @@ var ptrTests = []ptrTest{\n \t\t// large value should fail.\n \t\tname: \"barrierstruct\",\n \t\tc: `#include <stdlib.h>\n-                    struct s15 { char *a[10]; };\n-                    struct s15 *f15() { return malloc(sizeof(struct s15)); }\n-                    void f15b(struct s15 *p) {}`,\n+\t\t    struct s15 { char *a[10]; };\n+\t\t    struct s15 *f15() { return malloc(sizeof(struct s15)); }\n+\t\t    void f15b(struct s15 *p) {}`,\n \t\tbody:      `p := C.f15(); p.a = [10]*C.char{new(C.char)}; C.f15b(p)`,\n \t\tfail:      true,\n \t\texpensive: true,\n@@ -179,9 +179,9 @@ var ptrTests = []ptrTest{\n \t\t// copy should fail.\n \t\tname: \"barrierslice\",\n \t\tc: `#include <stdlib.h>\n-                    struct s16 { char *a[10]; };\n-                    struct s16 *f16() { return malloc(sizeof(struct s16)); }\n-                    void f16b(struct s16 *p) {}`,\n+\t\t    struct s16 { char *a[10]; };\n+\t\t    struct s16 *f16() { return malloc(sizeof(struct s16)); }\n+\t\t    void f16b(struct s16 *p) {}`,\n \t\tbody:      `p := C.f16(); copy(p.a[:], []*C.char{new(C.char)}); C.f16b(p)`,\n \t\tfail:      true,\n \t\texpensive: true,\n@@ -191,9 +191,9 @@ var ptrTests = []ptrTest{\n \t\t// different code path.\n \t\tname: \"barriergcprogarray\",\n \t\tc: `#include <stdlib.h>\n-                    struct s17 { char *a[32769]; };\n-                    struct s17 *f17() { return malloc(sizeof(struct s17)); }\n-                    void f17b(struct s17 *p) {}`,\n+\t\t    struct s17 { char *a[32769]; };\n+\t\t    struct s17 *f17() { return malloc(sizeof(struct s17)); }\n+\t\t    void f17b(struct s17 *p) {}`,\n \t\tbody:      `p := C.f17(); p.a = [32769]*C.char{new(C.char)}; C.f17b(p)`,\n \t\tfail:      true,\n \t\texpensive: true,\n@@ -202,10 +202,10 @@ var ptrTests = []ptrTest{\n \t\t// Similar case, with a source on the heap.\n \t\tname: \"barriergcprogarrayheap\",\n \t\tc: `#include <stdlib.h>\n-                    struct s18 { char *a[32769]; };\n-                    struct s18 *f18() { return malloc(sizeof(struct s18)); }\n-                    void f18b(struct s18 *p) {}\n-                    void f18c(void *p) {}`,\n+\t\t    struct s18 { char *a[32769]; };\n+\t\t    struct s18 *f18() { return malloc(sizeof(struct s18)); }\n+\t\t    void f18b(struct s18 *p) {}\n+\t\t    void f18c(void *p) {}`,\n \t\timports:   []string{\"unsafe\"},\n \t\tbody:      `p := C.f18(); n := &[32769]*C.char{new(C.char)}; p.a = *n; C.f18b(p); n[0] = nil; C.f18c(unsafe.Pointer(n))`,\n \t\tfail:      true,\n@@ -215,10 +215,10 @@ var ptrTests = []ptrTest{\n \t\t// A GC program with a struct.\n \t\tname: \"barriergcprogstruct\",\n \t\tc: `#include <stdlib.h>\n-                    struct s19a { char *a[32769]; };\n-                    struct s19b { struct s19a f; };\n-                    struct s19b *f19() { return malloc(sizeof(struct s19b)); }\n-                    void f19b(struct s19b *p) {}`,\n+\t\t    struct s19a { char *a[32769]; };\n+\t\t    struct s19b { struct s19a f; };\n+\t\t    struct s19b *f19() { return malloc(sizeof(struct s19b)); }\n+\t\t    void f19b(struct s19b *p) {}`,\n \t\tbody:      `p := C.f19(); p.f = C.struct_s19a{[32769]*C.char{new(C.char)}}; C.f19b(p)`,\n \t\tfail:      true,\n \t\texpensive: true,\n@@ -227,11 +227,11 @@ var ptrTests = []ptrTest{\n \t\t// Similar case, with a source on the heap.\n \t\tname: \"barriergcprogstructheap\",\n \t\tc: `#include <stdlib.h>\n-                    struct s20a { char *a[32769]; };\n-                    struct s20b { struct s20a f; };\n-                    struct s20b *f20() { return malloc(sizeof(struct s20b)); }\n-                    void f20b(struct s20b *p) {}\n-                    void f20c(void *p) {}`,\n+\t\t    struct s20a { char *a[32769]; };\n+\t\t    struct s20b { struct s20a f; };\n+\t\t    struct s20b *f20() { return malloc(sizeof(struct s20b)); }\n+\t\t    void f20b(struct s20b *p) {}\n+\t\t    void f20c(void *p) {}`,\n \t\timports:   []string{\"unsafe\"},\n \t\tbody:      `p := C.f20(); n := &C.struct_s20a{[32769]*C.char{new(C.char)}}; p.f = *n; C.f20b(p); n.a[0] = nil; C.f20c(unsafe.Pointer(n))`,\n \t\tfail:      true,\n@@ -242,25 +242,25 @@ var ptrTests = []ptrTest{\n \t\tname: \"export1\",\n \t\tc:    `extern unsigned char *GoFn21();`,\n \t\tsupport: `//export GoFn21\n-                          func GoFn21() *byte { return new(byte) }`,\n+\t\t          func GoFn21() *byte { return new(byte) }`,\n \t\tbody: `C.GoFn21()`,\n \t\tfail: true,\n \t},\n \t{\n \t\t// Returning a C pointer is fine.\n \t\tname: \"exportok\",\n \t\tc: `#include <stdlib.h>\n-                    extern unsigned char *GoFn22();`,\n+\t\t    extern unsigned char *GoFn22();`,\n \t\tsupport: `//export GoFn22\n-                          func GoFn22() *byte { return (*byte)(C.malloc(1)) }`,\n+\t\t          func GoFn22() *byte { return (*byte)(C.malloc(1)) }`,\n \t\tbody: `C.GoFn22()`,\n \t},\n \t{\n \t\t// Passing a Go string is fine.\n \t\tname: \"passstring\",\n \t\tc: `#include <stddef.h>\n-                    typedef struct { const char *p; ptrdiff_t n; } gostring23;\n-                    gostring23 f23(gostring23 s) { return s; }`,\n+\t\t    typedef struct { const char *p; ptrdiff_t n; } gostring23;\n+\t\t    gostring23 f23(gostring23 s) { return s; }`,\n \t\timports: []string{\"unsafe\"},\n \t\tbody:    `s := \"a\"; r := C.f23(*(*C.gostring23)(unsafe.Pointer(&s))); if *(*string)(unsafe.Pointer(&r)) != s { panic(r) }`,\n \t},\n@@ -279,12 +279,12 @@ var ptrTests = []ptrTest{\n \t\tc:       `extern void f25();`,\n \t\timports: []string{\"strings\"},\n \t\tsupport: `//export GoStr25\n-                          func GoStr25() string { return strings.Repeat(\"a\", 2) }`,\n+\t\t          func GoStr25() string { return strings.Repeat(\"a\", 2) }`,\n \t\tbody: `C.f25()`,\n \t\tc1: `#include <stddef.h>\n-                                 typedef struct { const char *p; ptrdiff_t n; } gostring25;\n-                                 extern gostring25 GoStr25();\n-                                 void f25() { GoStr25(); }`,\n+\t\t     typedef struct { const char *p; ptrdiff_t n; } gostring25;\n+\t\t     extern gostring25 GoStr25();\n+\t\t     void f25() { GoStr25(); }`,\n \t\tfail: true,\n \t},\n \t{\n@@ -295,7 +295,7 @@ var ptrTests = []ptrTest{\n \t\t// that is, we are testing something that is not unsafe.\n \t\tname: \"ptrdata1\",\n \t\tc: `#include <stdlib.h>\n-                    void f26(void* p) {}`,\n+\t\t    void f26(void* p) {}`,\n \t\timports: []string{\"unsafe\"},\n \t\tsupport: `type S26 struct { p *int; a [8*8]byte; u uintptr }`,\n \t\tbody:    `i := 0; p := &S26{u:uintptr(unsafe.Pointer(&i))}; q := (*S26)(C.malloc(C.size_t(unsafe.Sizeof(*p)))); *q = *p; C.f26(unsafe.Pointer(q))`,\n@@ -305,7 +305,7 @@ var ptrTests = []ptrTest{\n \t\t// Like ptrdata1, but with a type that uses a GC program.\n \t\tname: \"ptrdata2\",\n \t\tc: `#include <stdlib.h>\n-                    void f27(void* p) {}`,\n+\t\t    void f27(void* p) {}`,\n \t\timports: []string{\"unsafe\"},\n \t\tsupport: `type S27 struct { p *int; a [32769*8]byte; q *int; u uintptr }`,\n \t\tbody:    `i := 0; p := S27{u:uintptr(unsafe.Pointer(&i))}; q := (*S27)(C.malloc(C.size_t(unsafe.Sizeof(p)))); *q = p; C.f27(unsafe.Pointer(q))`,\n@@ -423,6 +423,15 @@ var ptrTests = []ptrTest{\n \t\tbody:    `t := reflect.StructOf([]reflect.StructField{{Name: \"MyInt38\", Type: reflect.TypeOf(MyInt38(0)), Anonymous: true}}); v := reflect.New(t).Elem(); v.Interface().(Getter38).Get()`,\n \t\tfail:    false,\n \t},\n+\t{\n+\t\t// Test that a converted address of a struct field results\n+\t\t// in a check for just that field and not the whole struct.\n+\t\tname:    \"structfieldcast\",\n+\t\tc:       `struct S40i { int i; int* p; }; void f40(struct S40i* p) {}`,\n+\t\tsupport: `type S40 struct { p *int; a C.struct_S40i }`,\n+\t\tbody:    `s := &S40{p: new(int)}; C.f40((*C.struct_S40i)(&s.a))`,\n+\t\tfail:    false,\n+\t},\n }\n \n func TestPointerChecks(t *testing.T) {\n@@ -466,6 +475,9 @@ func buildPtrTests(t *testing.T) (dir, exe string) {\n \tif err := os.MkdirAll(src, 0777); err != nil {\n \t\tt.Fatal(err)\n \t}\n+\tif err := ioutil.WriteFile(filepath.Join(src, \"go.mod\"), []byte(\"module ptrtest\"), 0666); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n \n \t// Prepare two cgo inputs: one for standard cgo and one for //export cgo.\n \t// (The latter cannot have C definitions, only declarations.)"}, {"sha": "77d5f7a7c9189ba02a5eacdba3deade4acb44315", "filename": "libgo/misc/cgo/errors/testdata/issue33061.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fmisc%2Fcgo%2Ferrors%2Ftestdata%2Fissue33061.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fmisc%2Fcgo%2Ferrors%2Ftestdata%2Fissue33061.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ferrors%2Ftestdata%2Fissue33061.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// cgo shouldn't crash if there is an extra argument with a C reference.\n+\n+package main\n+\n+// void F(void* p) {};\n+import \"C\"\n+\n+import \"unsafe\"\n+\n+func F() {\n+\tvar i int\n+\tC.F(unsafe.Pointer(&i), C.int(0)) // ERROR HERE\n+}"}, {"sha": "9d16338c0f6342fc4375f76ff04f556f799a5bac", "filename": "libgo/misc/cgo/testshared/shared_test.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fshared_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fshared_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fshared_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -941,3 +941,10 @@ func TestTestInstalledShared(t *testing.T) {\n func TestGeneratedMethod(t *testing.T) {\n \tgoCmd(t, \"install\", \"-buildmode=shared\", \"-linkshared\", \"./issue25065\")\n }\n+\n+// Test use of shared library struct with generated hash function.\n+// Issue 30768.\n+func TestGeneratedHash(t *testing.T) {\n+\tgoCmd(nil, \"install\", \"-buildmode=shared\", \"-linkshared\", \"./issue30768/issue30768lib\")\n+\tgoCmd(nil, \"test\", \"-linkshared\", \"./issue30768\")\n+}"}, {"sha": "9e45ebe683552153573a1c603d0e3cc981a0d036", "filename": "libgo/misc/cgo/testshared/testdata/issue30768/issue30768lib/lib.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fmisc%2Fcgo%2Ftestshared%2Ftestdata%2Fissue30768%2Fissue30768lib%2Flib.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fmisc%2Fcgo%2Ftestshared%2Ftestdata%2Fissue30768%2Fissue30768lib%2Flib.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestshared%2Ftestdata%2Fissue30768%2Fissue30768lib%2Flib.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package issue30768lib\n+\n+// S is a struct that requires a generated hash function.\n+type S struct {\n+\tA string\n+\tB int\n+}"}, {"sha": "1bbd139d3ebcde4e52426b1ff061b8a3dedfa00a", "filename": "libgo/misc/cgo/testshared/testdata/issue30768/x_test.go", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fmisc%2Fcgo%2Ftestshared%2Ftestdata%2Fissue30768%2Fx_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656297e1fec9a127ff742df16958ee279ccacec5/libgo%2Fmisc%2Fcgo%2Ftestshared%2Ftestdata%2Fissue30768%2Fx_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestshared%2Ftestdata%2Fissue30768%2Fx_test.go?ref=656297e1fec9a127ff742df16958ee279ccacec5", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package issue30768_test\n+\n+import (\n+\t\"testing\"\n+\n+\t\"testshared/issue30768/issue30768lib\"\n+)\n+\n+type s struct {\n+\ts issue30768lib.S\n+}\n+\n+func Test30768(t *testing.T) {\n+\t// Calling t.Log will convert S to an empty interface,\n+\t// which will force a reference to the generated hash function,\n+\t// defined in the shared library.\n+\tt.Log(s{})\n+}"}]}