{"sha": "b66906a8ff79931bc3d23b9362833b1567c5ac56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY2OTA2YThmZjc5OTMxYmMzZDIzYjkzNjI4MzNiMTU2N2M1YWM1Ng==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-12-29T16:16:39Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-12-29T16:16:39Z"}, "message": "re PR fortran/12632 ([g77 only] -fbounds-check ICE)\n\n\n\tPR fortran/12632\n\t* fold-const.c (fold) <COND_EXPR>: Don't fold a constant condition,\n\tif the type of the selected branch doesn't match its' parent.\n\n\t* com.c (ffecom_subscript_check_): Take as an extra argument the\n\t(possibly NULL) decl of the array.  Don't create unnecessary tree\n\tnodes if the array index is known to be safe at compile-time.\n\tIf the array index is unsafe, force the array decl into memory to\n\tavoid RTL expansion problems.\n\t(ffecom_array_ref_): Update calls to ffecom_subscript_check_.\n\t(ffecom_char_args_x_): Likewise.\n\n\t* g77.dg/12632.f: New test case.\n\nFrom-SVN: r75203", "tree": {"sha": "8cc330d809fbbe70f50065f881b684ae3503d29c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8cc330d809fbbe70f50065f881b684ae3503d29c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b66906a8ff79931bc3d23b9362833b1567c5ac56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b66906a8ff79931bc3d23b9362833b1567c5ac56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b66906a8ff79931bc3d23b9362833b1567c5ac56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b66906a8ff79931bc3d23b9362833b1567c5ac56/comments", "author": null, "committer": null, "parents": [{"sha": "68deab91f26e8a5266a8bd9086bbf5129c619c03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68deab91f26e8a5266a8bd9086bbf5129c619c03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68deab91f26e8a5266a8bd9086bbf5129c619c03"}], "stats": {"total": 69, "additions": 53, "deletions": 16}, "files": [{"sha": "486b98145a8c28e89d800e3761ccaebcf2b2b6cf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66906a8ff79931bc3d23b9362833b1567c5ac56/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66906a8ff79931bc3d23b9362833b1567c5ac56/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b66906a8ff79931bc3d23b9362833b1567c5ac56", "patch": "@@ -1,3 +1,9 @@\n+2003-12-29  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR fortran/12632\n+\t* fold-const.c (fold) <COND_EXPR>: Don't fold a constant condition,\n+\tif the type of the selected branch doesn't match its' parent.\n+\n 2003-12-29  Jan Hubicka  <jh@suse.cz>\n \n \t* coverage.c (read_counts_file): Better error messages; cause corrupted"}, {"sha": "3dcc5628f70b537b855bd3e04967361335134cf4", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66906a8ff79931bc3d23b9362833b1567c5ac56/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66906a8ff79931bc3d23b9362833b1567c5ac56/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=b66906a8ff79931bc3d23b9362833b1567c5ac56", "patch": "@@ -1,3 +1,14 @@\n+2003-12-29  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR fortran/12632\n+\t* com.c (ffecom_subscript_check_): Take as an extra argument the\n+\t(possibly NULL) decl of the array.  Don't create unnecessary tree\n+\tnodes if the array index is known to be safe at compile-time.\n+\tIf the array index is unsafe, force the array decl into memory to\n+\tavoid RTL expansion problems.\n+\t(ffecom_array_ref_): Update calls to ffecom_subscript_check_.\n+\t(ffecom_char_args_x_): Likewise.\n+\n 2003-12-06  Kelley Cook  <kcook@gcc.gnu.org>\n \n \t* Make-lang.in (G77_CROSS_NAME): Delete."}, {"sha": "a64ef86b17240a57b9e498957a6f9dde7518c3b8", "filename": "gcc/f/com.c", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66906a8ff79931bc3d23b9362833b1567c5ac56/gcc%2Ff%2Fcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66906a8ff79931bc3d23b9362833b1567c5ac56/gcc%2Ff%2Fcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.c?ref=b66906a8ff79931bc3d23b9362833b1567c5ac56", "patch": "@@ -638,15 +638,16 @@ static GTY(()) tree shadowed_labels;\n \f\n /* Return the subscript expression, modified to do range-checking.\n \n-   `array' is the array to be checked against.\n+   `array' is the array type to be checked against.\n    `element' is the subscript expression to check.\n    `dim' is the dimension number (starting at 0).\n    `total_dims' is the total number of dimensions (0 for CHARACTER substring).\n+   `item' is the array decl or NULL_TREE.\n */\n \n static tree\n ffecom_subscript_check_ (tree array, tree element, int dim, int total_dims,\n-\t\t\t const char *array_name)\n+\t\t\t const char *array_name, tree item)\n {\n   tree low = TYPE_MIN_VALUE (TYPE_DOMAIN (array));\n   tree high = TYPE_MAX_VALUE (TYPE_DOMAIN (array));\n@@ -713,6 +714,10 @@ ffecom_subscript_check_ (tree array, tree element, int dim, int total_dims,\n         }\n     }\n \n+  /* If the array index is safe at compile-time, return element.  */\n+  if (integer_nonzerop (cond))\n+    return element;\n+\n   {\n     int len;\n     char *proc;\n@@ -807,13 +812,10 @@ ffecom_subscript_check_ (tree array, tree element, int dim, int total_dims,\n   TREE_SIDE_EFFECTS (die) = 1;\n   die = convert (void_type_node, die);\n \n-  element = ffecom_3 (COND_EXPR,\n-\t\t      TREE_TYPE (element),\n-\t\t      cond,\n-\t\t      element,\n-\t\t      die);\n+  if (integer_zerop (cond) && item)\n+    ffe_mark_addressable (item);\n \n-  return element;\n+  return ffecom_3 (COND_EXPR, TREE_TYPE (element), cond, element, die);\n }\n \n /* Return the computed element of an array reference.\n@@ -899,7 +901,7 @@ ffecom_arrayref_ (tree item, ffebld expr, int want_ptr)\n \t  element = ffecom_expr_ (dims[i], NULL, NULL, NULL, FALSE, TRUE);\n \t  if (flag_bounds_check)\n \t    element = ffecom_subscript_check_ (array, element, i, total_dims,\n-\t\t\t\t\t       array_name);\n+\t\t\t\t\t       array_name, item);\n \t  if (element == error_mark_node)\n \t    return element;\n \n@@ -945,7 +947,7 @@ ffecom_arrayref_ (tree item, ffebld expr, int want_ptr)\n \t  element = ffecom_expr_ (dims[i], NULL, NULL, NULL, FALSE, TRUE);\n \t  if (flag_bounds_check)\n \t    element = ffecom_subscript_check_ (array, element, i, total_dims,\n-\t\t\t\t\t       array_name);\n+\t\t\t\t\t       array_name, item);\n \t  if (element == error_mark_node)\n \t    return element;\n \n@@ -2037,7 +2039,7 @@ ffecom_char_args_x_ (tree *xitem, tree *length, ffebld expr, bool with_null)\n \t\tend_tree = ffecom_expr (end);\n \t\tif (flag_bounds_check)\n \t\t  end_tree = ffecom_subscript_check_ (array, end_tree, 1, 0,\n-\t\t\t\t\t\t      char_name);\n+\t\t\t\t\t\t      char_name, NULL_TREE);\n \t\tend_tree = convert (ffecom_f2c_ftnlen_type_node,\n \t\t\t\t    end_tree);\n \n@@ -2055,7 +2057,7 @@ ffecom_char_args_x_ (tree *xitem, tree *length, ffebld expr, bool with_null)\n \t    start_tree = ffecom_expr (start);\n \t    if (flag_bounds_check)\n \t      start_tree = ffecom_subscript_check_ (array, start_tree, 0, 0,\n-\t\t\t\t\t\t    char_name);\n+\t\t\t\t\t\t    char_name, NULL_TREE);\n \t    start_tree = convert (ffecom_f2c_ftnlen_type_node,\n \t\t\t\t  start_tree);\n \n@@ -2088,7 +2090,7 @@ ffecom_char_args_x_ (tree *xitem, tree *length, ffebld expr, bool with_null)\n \t\tend_tree = ffecom_expr (end);\n \t\tif (flag_bounds_check)\n \t\t  end_tree = ffecom_subscript_check_ (array, end_tree, 1, 0,\n-\t\t\t\t\t\t      char_name);\n+\t\t\t\t\t\t      char_name, NULL_TREE);\n \t\tend_tree = convert (ffecom_f2c_ftnlen_type_node,\n \t\t\t\t    end_tree);\n "}, {"sha": "556593243ac335609593fb8f0f95b95cd45e4d94", "filename": "gcc/fold-const.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66906a8ff79931bc3d23b9362833b1567c5ac56/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66906a8ff79931bc3d23b9362833b1567c5ac56/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=b66906a8ff79931bc3d23b9362833b1567c5ac56", "patch": "@@ -7864,9 +7864,16 @@ fold (tree expr)\n       /* Pedantic ANSI C says that a conditional expression is never an lvalue,\n \t so all simple results must be passed through pedantic_non_lvalue.  */\n       if (TREE_CODE (arg0) == INTEGER_CST)\n-\treturn pedantic_non_lvalue\n-\t  (TREE_OPERAND (t, (integer_zerop (arg0) ? 2 : 1)));\n-      else if (operand_equal_p (arg1, TREE_OPERAND (expr, 2), 0))\n+\t{\n+\t  tem = TREE_OPERAND (t, (integer_zerop (arg0) ? 2 : 1));\n+\t  /* Only optimize constant conditions when the selected branch\n+\t     has the same type as the COND_EXPR.  This avoids optimizing\n+\t     away \"c ? x : throw\", where the throw has a void type.  */\n+\t  if (TREE_TYPE (tem) == TREE_TYPE (t))\n+\t    return pedantic_non_lvalue (tem);\n+\t  return t;\n+\t}\n+      if (operand_equal_p (arg1, TREE_OPERAND (expr, 2), 0))\n \treturn pedantic_omit_one_operand (type, arg1, arg0);\n \n       /* If we have A op B ? A : C, we may be able to convert this to a"}, {"sha": "9f575579a120bc9a9d1e885dc857bcde74613800", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66906a8ff79931bc3d23b9362833b1567c5ac56/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66906a8ff79931bc3d23b9362833b1567c5ac56/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b66906a8ff79931bc3d23b9362833b1567c5ac56", "patch": "@@ -1,3 +1,8 @@\n+2003-12-29  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR fortran/12632\n+\t* g77.dg/12632.f: New test case.\n+\n 2003-12-29  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tPR c++/13289"}, {"sha": "6801229eace0cf1145da6d23ef0fbc6a1802c9ae", "filename": "gcc/testsuite/g77.dg/12632.f", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66906a8ff79931bc3d23b9362833b1567c5ac56/gcc%2Ftestsuite%2Fg77.dg%2F12632.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66906a8ff79931bc3d23b9362833b1567c5ac56/gcc%2Ftestsuite%2Fg77.dg%2F12632.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.dg%2F12632.f?ref=b66906a8ff79931bc3d23b9362833b1567c5ac56", "patch": "@@ -0,0 +1,6 @@\n+C { dg-do compile }\n+C { dg-options \"-fbounds-check\" }\n+       INTEGER I(1)\n+       I(2) = 0  ! { dg-error \"out of defined range\" \"out of defined range\" }\n+       END\n+"}]}