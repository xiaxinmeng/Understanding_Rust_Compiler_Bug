{"sha": "20efdf741052c58908254aea0aba26ba2d4d3646", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBlZmRmNzQxMDUyYzU4OTA4MjU0YWVhMGFiYTI2YmEyZDRkMzY0Ng==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-01-06T15:15:11Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-01-06T15:15:11Z"}, "message": "calls.c (special_function_p): New function broken out of expand_call.\n\n        * calls.c (special_function_p): New function broken out of\n        expand_call.\n        (precompute_register_parameters): Likewise.\n        (store_one_arg): Likewise.\n        (store_unaligned_argumetns_into_pseudos): Likewise.\n        (save_fixed_argument_area): Likewise.\n        (restore_fixed_argument_area): Likewise.\n        (expand_call): Corresponding changes.\n\nFrom-SVN: r24516", "tree": {"sha": "57bd1899dc9b0a65f4b2a47818bb48f6f3cda47d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57bd1899dc9b0a65f4b2a47818bb48f6f3cda47d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20efdf741052c58908254aea0aba26ba2d4d3646", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20efdf741052c58908254aea0aba26ba2d4d3646", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20efdf741052c58908254aea0aba26ba2d4d3646", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20efdf741052c58908254aea0aba26ba2d4d3646/comments", "author": null, "committer": null, "parents": [{"sha": "4a8832ee247040be633ad13e326c2d959ab9f0ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a8832ee247040be633ad13e326c2d959ab9f0ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a8832ee247040be633ad13e326c2d959ab9f0ae"}], "stats": {"total": 642, "additions": 371, "deletions": 271}, "files": [{"sha": "359dea29197da1b75fbf72d708c0c37615051ede", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20efdf741052c58908254aea0aba26ba2d4d3646/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20efdf741052c58908254aea0aba26ba2d4d3646/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=20efdf741052c58908254aea0aba26ba2d4d3646", "patch": "@@ -1,3 +1,14 @@\n+Wed Jan  6 16:08:54 1999  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* calls.c (special_function_p): New function broken out of\n+\texpand_call.\n+\t(precompute_register_parameters): Likewise.\n+\t(store_one_arg): Likewise.\n+\t(store_unaligned_argumetns_into_pseudos): Likewise.\n+\t(save_fixed_argument_area): Likewise.\n+\t(restore_fixed_argument_area): Likewise.\n+\t(expand_call): Corresponding changes.\n+\t\n Wed Jan  6 10:43:29 1999  Andreas Schwab  <schwab@issan.cs.uni-dortmund.de>\n \n \t* config/m68k/m68k.c (const_uint32_operand): Remove CONSTANT_P_RTX"}, {"sha": "2d2b4f40a11a7e6b0d5175e7e26c13fa595530d4", "filename": "gcc/calls.c", "status": "modified", "additions": 360, "deletions": 271, "changes": 631, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20efdf741052c58908254aea0aba26ba2d4d3646/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20efdf741052c58908254aea0aba26ba2d4d3646/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=20efdf741052c58908254aea0aba26ba2d4d3646", "patch": "@@ -124,13 +124,24 @@ static int highest_outgoing_arg_in_use;\n int stack_arg_under_construction;\n #endif\n \n-static int calls_function\tPROTO((tree, int));\n-static int calls_function_1\tPROTO((tree, int));\n-static void emit_call_1\t\tPROTO((rtx, tree, tree, HOST_WIDE_INT,\n-\t\t\t\t       HOST_WIDE_INT, rtx, rtx,\n-\t\t\t\t       int, rtx, int));\n+static int calls_function\tPROTO ((tree, int));\n+static int calls_function_1\tPROTO ((tree, int));\n+static void emit_call_1\t\tPROTO ((rtx, tree, tree, HOST_WIDE_INT,\n+\t\t\t\t        HOST_WIDE_INT, rtx, rtx,\n+\t\t\t\t        int, rtx, int));\n+static void special_function_p\tPROTO ((char *, tree, int *, int *,\n+\t\t\t\t\tint *, int *));\n+static void precompute_register_parameters\tPROTO ((int, struct arg_data *,\n+\t\t\t\t\t\t\tint *));\n static void store_one_arg\tPROTO ((struct arg_data *, rtx, int, int,\n \t\t\t\t\tint));\n+static void store_unaligned_arguments_into_pseudos PROTO ((struct arg_data *,\n+\t\t\t\t\t\t\t   int));\n+\n+#if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)\n+static rtx save_fixed_argument_area\tPROTO ((int, rtx, int *, int *));\n+static void restore_fixed_argument_area\tPROTO ((rtx, rtx, int, int));\n+#endif\n \f\n /* If WHICH is 1, return 1 if EXP contains a call to the built-in function\n    `alloca'.\n@@ -475,6 +486,338 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, struct_value_size,\n #endif\n }\n \n+/* Determine if the function identified by NAME and FNDECL is one with\n+   special properties we wish to know about.\n+\n+   For example, if the function might return more than one time (setjmp), then\n+   set RETURNS_TWICE to a nonzero value.\n+\n+   Similarly set IS_LONGJMP for if the function is in the longjmp family.\n+\n+   Set IS_MALLOC for any of the standard memory allocation functions which\n+   allocate from the heap.\n+\n+   Set MAY_BE_ALLOCA for any memory allocation function that might allocate\n+   space from the stack such as alloca.  */\n+\n+static void\n+special_function_p (name, fndecl, returns_twice, is_longjmp,\n+\t\t    is_malloc, may_be_alloca)\n+     char *name;\n+     tree fndecl;\n+     int *returns_twice;\n+     int *is_longjmp;\n+     int *is_malloc;\n+     int *may_be_alloca;\n+{\n+  *returns_twice = 0;\n+  *is_longjmp = 0;\n+  *is_malloc = 0;\n+  *may_be_alloca = 0;\n+\n+  /* We assume that alloca will always be called by name.  It\n+     makes no sense to pass it as a pointer-to-function to\n+     anything that does not understand its behavior.  */\n+  *may_be_alloca\n+    = (name && ((IDENTIFIER_LENGTH (DECL_NAME (fndecl)) == 6\n+\t\t && name[0] == 'a'\n+\t\t && ! strcmp (name, \"alloca\"))\n+\t\t|| (IDENTIFIER_LENGTH (DECL_NAME (fndecl)) == 16\n+\t\t    && name[0] == '_'\n+\t\t    && ! strcmp (name, \"__builtin_alloca\"))));\n+\n+  if (name != 0 && IDENTIFIER_LENGTH (DECL_NAME (fndecl)) <= 17\n+      /* Exclude functions not at the file scope, or not `extern',\n+\t since they are not the magic functions we would otherwise\n+\t think they are.  */\n+      && DECL_CONTEXT (fndecl) == NULL_TREE && TREE_PUBLIC (fndecl))\n+    {\n+      char *tname = name;\n+\n+      /* Disregard prefix _, __ or __x.  */\n+      if (name[0] == '_')\n+\t{\n+\t  if (name[1] == '_' && name[2] == 'x')\n+\t    tname += 3;\n+\t  else if (name[1] == '_')\n+\t    tname += 2;\n+\t  else\n+\t    tname += 1;\n+\t}\n+\n+      if (tname[0] == 's')\n+\t{\n+\t  *returns_twice\n+\t     = ((tname[1] == 'e'\n+\t\t && (! strcmp (tname, \"setjmp\")\n+\t\t     || ! strcmp (tname, \"setjmp_syscall\")))\n+\t        || (tname[1] == 'i'\n+\t\t    && ! strcmp (tname, \"sigsetjmp\"))\n+\t        || (tname[1] == 'a'\n+\t\t    && ! strcmp (tname, \"savectx\")));\n+\t  if (tname[1] == 'i'\n+\t      && ! strcmp (tname, \"siglongjmp\"))\n+\t    *is_longjmp = 1;\n+\t}\n+      else if ((tname[0] == 'q' && tname[1] == 's'\n+\t\t&& ! strcmp (tname, \"qsetjmp\"))\n+\t       || (tname[0] == 'v' && tname[1] == 'f'\n+\t\t   && ! strcmp (tname, \"vfork\")))\n+\t*returns_twice = 1;\n+\n+      else if (tname[0] == 'l' && tname[1] == 'o'\n+\t       && ! strcmp (tname, \"longjmp\"))\n+\t*is_longjmp = 1;\n+      /* XXX should have \"malloc\" attribute on functions instead\n+\t of recognizing them by name.  */\n+      else if (! strcmp (tname, \"malloc\")\n+\t       || ! strcmp (tname, \"calloc\")\n+\t       || ! strcmp (tname, \"realloc\")\n+\t       /* Note use of NAME rather than TNAME here.  These functions\n+\t\t  are only reserved when preceded with __.  */\n+\t       || ! strcmp (name, \"__vn\")\t/* mangled __builtin_vec_new */\n+\t       || ! strcmp (name, \"__nw\")\t/* mangled __builtin_new */\n+\t       || ! strcmp (name, \"__builtin_new\")\n+\t       || ! strcmp (name, \"__builtin_vec_new\"))\n+\t*is_malloc = 1;\n+    }\n+}\n+\n+/* Precompute all register parameters as described by ARGS, storing values\n+   into fields within the ARGS array.\n+\n+   NUM_ACTUALS indicates the total number elements in the ARGS array.\n+\n+   Set REG_PARM_SEEN if we encounter a register parameter.  */\n+\n+static void\n+precompute_register_parameters (num_actuals, args, reg_parm_seen)\n+     int num_actuals;\n+     struct arg_data *args;\n+     int *reg_parm_seen;\n+{\n+  int i;\n+\n+  *reg_parm_seen = 0;\n+\n+  for (i = 0; i < num_actuals; i++)\n+    if (args[i].reg != 0 && ! args[i].pass_on_stack)\n+      {\n+\t*reg_parm_seen = 1;\n+\n+\tif (args[i].value == 0)\n+\t  {\n+\t    push_temp_slots ();\n+\t    args[i].value = expand_expr (args[i].tree_value, NULL_RTX,\n+\t\t\t\t\t VOIDmode, 0);\n+\t    preserve_temp_slots (args[i].value);\n+\t    pop_temp_slots ();\n+\n+\t    /* ANSI doesn't require a sequence point here,\n+\t       but PCC has one, so this will avoid some problems.  */\n+\t    emit_queue ();\n+\t  }\n+\n+\t/* If we are to promote the function arg to a wider mode,\n+\t   do it now.  */\n+\n+\tif (args[i].mode != TYPE_MODE (TREE_TYPE (args[i].tree_value)))\n+\t  args[i].value\n+\t    = convert_modes (args[i].mode,\n+\t\t\t     TYPE_MODE (TREE_TYPE (args[i].tree_value)),\n+\t\t\t     args[i].value, args[i].unsignedp);\n+\n+\t/* If the value is expensive, and we are inside an appropriately \n+\t   short loop, put the value into a pseudo and then put the pseudo\n+\t   into the hard reg.\n+\n+\t   For small register classes, also do this if this call uses\n+\t   register parameters.  This is to avoid reload conflicts while\n+\t   loading the parameters registers.  */\n+\n+\tif ((! (GET_CODE (args[i].value) == REG\n+\t\t|| (GET_CODE (args[i].value) == SUBREG\n+\t\t    && GET_CODE (SUBREG_REG (args[i].value)) == REG)))\n+\t    && args[i].mode != BLKmode\n+\t    && rtx_cost (args[i].value, SET) > 2\n+\t    && ((SMALL_REGISTER_CLASSES && *reg_parm_seen)\n+\t\t|| preserve_subexpressions_p ()))\n+\t  args[i].value = copy_to_mode_reg (args[i].mode, args[i].value);\n+      }\n+}\n+\n+#if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)\n+\n+  /* The argument list is the property of the called routine and it\n+     may clobber it.  If the fixed area has been used for previous\n+     parameters, we must save and restore it.  */\n+static rtx\n+save_fixed_argument_area (reg_parm_stack_space, argblock,\n+\t\t\t  low_to_save, high_to_save)\n+     int reg_parm_stack_space;\n+     rtx argblock;\n+     int *low_to_save;\n+     int *high_to_save;\n+{\n+  int i;\n+  rtx save_area = NULL_RTX;\n+\n+  /* Compute the boundary of the that needs to be saved, if any.  */\n+#ifdef ARGS_GROW_DOWNWARD\n+  for (i = 0; i < reg_parm_stack_space + 1; i++)\n+#else\n+  for (i = 0; i < reg_parm_stack_space; i++)\n+#endif\n+    {\n+      if (i >= highest_outgoing_arg_in_use\n+\t  || stack_usage_map[i] == 0)\n+\tcontinue;\n+\n+      if (*low_to_save == -1)\n+\t*low_to_save = i;\n+\n+      *high_to_save = i;\n+    }\n+\n+  if (*low_to_save >= 0)\n+    {\n+      int num_to_save = *high_to_save - *low_to_save + 1;\n+      enum machine_mode save_mode\n+\t= mode_for_size (num_to_save * BITS_PER_UNIT, MODE_INT, 1);\n+      rtx stack_area;\n+\n+      /* If we don't have the required alignment, must do this in BLKmode.  */\n+      if ((*low_to_save & (MIN (GET_MODE_SIZE (save_mode),\n+\t\t\t        BIGGEST_ALIGNMENT / UNITS_PER_WORD) - 1)))\n+\tsave_mode = BLKmode;\n+\n+#ifdef ARGS_GROW_DOWNWARD\n+      stack_area = gen_rtx_MEM (save_mode,\n+\t\t\t\tmemory_address (save_mode,\n+\t\t\t\t\t\tplus_constant (argblock,\n+\t\t\t\t\t\t\t       - *high_to_save)));\n+#else\n+      stack_area = gen_rtx_MEM (save_mode,\n+\t\t\t\tmemory_address (save_mode,\n+\t\t\t\t\t\tplus_constant (argblock,\n+\t\t\t\t\t\t\t       *low_to_save)));\n+#endif\n+      if (save_mode == BLKmode)\n+\t{\n+\t  save_area = assign_stack_temp (BLKmode, num_to_save, 0);\n+\t  MEM_IN_STRUCT_P (save_area) = 0;\n+\t  emit_block_move (validize_mem (save_area), stack_area,\n+\t\t\t   GEN_INT (num_to_save),\n+\t\t\t   PARM_BOUNDARY / BITS_PER_UNIT);\n+\t}\n+      else\n+\t{\n+\t  save_area = gen_reg_rtx (save_mode);\n+\t  emit_move_insn (save_area, stack_area);\n+\t}\n+    }\n+  return save_area;\n+}\n+\n+static void\n+restore_fixed_argument_area (save_area, argblock, high_to_save, low_to_save)\n+     rtx save_area;\n+     rtx argblock;\n+     int high_to_save;\n+     int low_to_save;\n+{\n+  enum machine_mode save_mode = GET_MODE (save_area);\n+#ifdef ARGS_GROW_DOWNWARD\n+  rtx stack_area\n+    = gen_rtx_MEM (save_mode,\n+\t\t   memory_address (save_mode,\n+\t\t\t\t   plus_constant (argblock,\n+\t\t\t\t\t\t  - high_to_save)));\n+#else\n+  rtx stack_area\n+    = gen_rtx_MEM (save_mode,\n+\t\t   memory_address (save_mode,\n+\t\t\t\t   plus_constant (argblock,\n+\t\t\t\t\t\t  low_to_save)));\n+#endif\n+\n+  if (save_mode != BLKmode)\n+    emit_move_insn (stack_area, save_area);\n+  else\n+    emit_block_move (stack_area, validize_mem (save_area),\n+\t\t     GEN_INT (high_to_save - low_to_save + 1),\n+\t\t     PARM_BOUNDARY / BITS_PER_UNIT);\n+}\n+#endif\n+\t  \n+/* If any elements in ARGS refer to parameters that are to be passed in\n+   registers, but not in memory, and whose alignment does not permit a\n+   direct copy into registers.  Copy the values into a group of pseudos\n+   which we will later copy into the appropriate hard registers.  */\n+static void\n+store_unaligned_arguments_into_pseudos (args, num_actuals)\n+     struct arg_data *args;\n+     int num_actuals;\n+{\n+  int i, j;\n+     \n+  for (i = 0; i < num_actuals; i++)\n+    if (args[i].reg != 0 && ! args[i].pass_on_stack\n+\t&& args[i].mode == BLKmode\n+\t&& (TYPE_ALIGN (TREE_TYPE (args[i].tree_value))\n+\t    < (unsigned int) MIN (BIGGEST_ALIGNMENT, BITS_PER_WORD)))\n+      {\n+\tint bytes = int_size_in_bytes (TREE_TYPE (args[i].tree_value));\n+\tint big_endian_correction = 0;\n+\n+\targs[i].n_aligned_regs\n+\t  = args[i].partial ? args[i].partial\n+\t    : (bytes + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD;\n+\n+\targs[i].aligned_regs = (rtx *) alloca (sizeof (rtx)\n+\t\t\t\t\t       * args[i].n_aligned_regs);\n+\n+\t/* Structures smaller than a word are aligned to the least\n+\t   significant byte (to the right).  On a BYTES_BIG_ENDIAN machine,\n+\t   this means we must skip the empty high order bytes when\n+\t   calculating the bit offset.  */\n+\tif (BYTES_BIG_ENDIAN && bytes < UNITS_PER_WORD)\n+\t  big_endian_correction = (BITS_PER_WORD  - (bytes * BITS_PER_UNIT));\n+\n+\tfor (j = 0; j < args[i].n_aligned_regs; j++)\n+\t  {\n+\t    rtx reg = gen_reg_rtx (word_mode);\n+\t    rtx word = operand_subword_force (args[i].value, j, BLKmode);\n+\t    int bitsize = MIN (bytes * BITS_PER_UNIT, BITS_PER_WORD);\n+\t    int bitalign = TYPE_ALIGN (TREE_TYPE (args[i].tree_value));\n+\n+\t    args[i].aligned_regs[j] = reg;\n+\n+\t    /* There is no need to restrict this code to loading items\n+\t       in TYPE_ALIGN sized hunks.  The bitfield instructions can\n+\t       load up entire word sized registers efficiently.\n+\n+\t       ??? This may not be needed anymore.\n+\t       We use to emit a clobber here but that doesn't let later\n+\t       passes optimize the instructions we emit.  By storing 0 into\n+\t       the register later passes know the first AND to zero out the\n+\t       bitfield being set in the register is unnecessary.  The store\n+\t       of 0 will be deleted as will at least the first AND.  */\n+\n+\t    emit_move_insn (reg, const0_rtx);\n+\n+\t    bytes -= bitsize / BITS_PER_UNIT;\n+\t    store_bit_field (reg, bitsize, big_endian_correction, word_mode,\n+\t\t\t     extract_bit_field (word, bitsize, 0, 1,\n+\t\t\t\t\t\tNULL_RTX, word_mode,\n+\t\t\t\t\t\tword_mode,\n+\t\t\t\t\t\tbitalign / BITS_PER_UNIT,\n+\t\t\t\t\t\tBITS_PER_WORD),\n+\t\t\t     bitalign / BITS_PER_UNIT, BITS_PER_WORD);\n+\t  }\n+      }\n+}\n+\n /* Generate all the code for a function call\n    and return an rtx for its value.\n    Store the value in TARGET (specified as an rtx) if convenient.\n@@ -827,89 +1170,10 @@ expand_call (exp, target, ignore)\n   if (fndecl && DECL_NAME (fndecl))\n     name = IDENTIFIER_POINTER (DECL_NAME (fndecl));\n \n-#if 0\n-  /* Unless it's a call to a specific function that isn't alloca,\n-     if it has one argument, we must assume it might be alloca.  */\n-\n-  may_be_alloca\n-    = (!(fndecl != 0 && strcmp (name, \"alloca\"))\n-       && actparms != 0\n-       && TREE_CHAIN (actparms) == 0);\n-#else\n-  /* We assume that alloca will always be called by name.  It\n-     makes no sense to pass it as a pointer-to-function to\n-     anything that does not understand its behavior.  */\n-  may_be_alloca\n-    = (name && ((IDENTIFIER_LENGTH (DECL_NAME (fndecl)) == 6\n-\t\t && name[0] == 'a'\n-\t\t && ! strcmp (name, \"alloca\"))\n-\t\t|| (IDENTIFIER_LENGTH (DECL_NAME (fndecl)) == 16\n-\t\t    && name[0] == '_'\n-\t\t    && ! strcmp (name, \"__builtin_alloca\"))));\n-#endif\n-\n   /* See if this is a call to a function that can return more than once\n-     or a call to longjmp.  */\n-\n-  returns_twice = 0;\n-  is_longjmp = 0;\n-  is_malloc = 0;\n-\n-  if (name != 0 && IDENTIFIER_LENGTH (DECL_NAME (fndecl)) <= 17\n-      /* Exclude functions not at the file scope, or not `extern',\n-\t since they are not the magic functions we would otherwise\n-\t think they are.  */\n-      && DECL_CONTEXT (fndecl) == NULL_TREE && TREE_PUBLIC (fndecl))\n-    {\n-      char *tname = name;\n-\n-      /* Disregard prefix _, __ or __x.  */\n-      if (name[0] == '_')\n-\t{\n-\t  if (name[1] == '_' && name[2] == 'x')\n-\t    tname += 3;\n-\t  else if (name[1] == '_')\n-\t    tname += 2;\n-\t  else\n-\t    tname += 1;\n-\t}\n-\n-      if (tname[0] == 's')\n-\t{\n-\t  returns_twice\n-\t    = ((tname[1] == 'e'\n-\t\t&& (! strcmp (tname, \"setjmp\")\n-\t\t    || ! strcmp (tname, \"setjmp_syscall\")))\n-\t       || (tname[1] == 'i'\n-\t\t   && ! strcmp (tname, \"sigsetjmp\"))\n-\t       || (tname[1] == 'a'\n-\t\t   && ! strcmp (tname, \"savectx\")));\n-\t  if (tname[1] == 'i'\n-\t      && ! strcmp (tname, \"siglongjmp\"))\n-\t    is_longjmp = 1;\n-\t}\n-      else if ((tname[0] == 'q' && tname[1] == 's'\n-\t\t&& ! strcmp (tname, \"qsetjmp\"))\n-\t       || (tname[0] == 'v' && tname[1] == 'f'\n-\t\t   && ! strcmp (tname, \"vfork\")))\n-\treturns_twice = 1;\n-\n-      else if (tname[0] == 'l' && tname[1] == 'o'\n-\t       && ! strcmp (tname, \"longjmp\"))\n-\tis_longjmp = 1;\n-      /* XXX should have \"malloc\" attribute on functions instead\n-\t of recognizing them by name.  */\n-      else if (! strcmp (tname, \"malloc\")\n-\t       || ! strcmp (tname, \"calloc\")\n-\t       || ! strcmp (tname, \"realloc\")\n-\t       /* Note use of NAME rather than TNAME here.  These functions\n-\t\t  are only reserved when preceded with __.  */\n-\t       || ! strcmp (name, \"__vn\")\t/* mangled __builtin_vec_new */\n-\t       || ! strcmp (name, \"__nw\")\t/* mangled __builtin_new */\n-\t       || ! strcmp (name, \"__builtin_new\")\n-\t       || ! strcmp (name, \"__builtin_vec_new\"))\n-\tis_malloc = 1;\n-    }\n+     or a call to longjmp or malloc.  */\n+  special_function_p (name, fndecl, &returns_twice, &is_longjmp,\n+\t\t      &is_malloc, &may_be_alloca);\n \n   if (may_be_alloca)\n     current_function_calls_alloca = 1;\n@@ -1650,115 +1914,16 @@ expand_call (exp, target, ignore)\n \n   /* Precompute all register parameters.  It isn't safe to compute anything\n      once we have started filling any specific hard regs.  */\n-  reg_parm_seen = 0;\n-  for (i = 0; i < num_actuals; i++)\n-    if (args[i].reg != 0 && ! args[i].pass_on_stack)\n-      {\n-\treg_parm_seen = 1;\n-\n-\tif (args[i].value == 0)\n-\t  {\n-\t    push_temp_slots ();\n-\t    args[i].value = expand_expr (args[i].tree_value, NULL_RTX,\n-\t\t\t\t\t VOIDmode, 0);\n-\t    preserve_temp_slots (args[i].value);\n-\t    pop_temp_slots ();\n-\n-\t    /* ANSI doesn't require a sequence point here,\n-\t       but PCC has one, so this will avoid some problems.  */\n-\t    emit_queue ();\n-\t  }\n-\n-\t/* If we are to promote the function arg to a wider mode,\n-\t   do it now.  */\n-\n-\tif (args[i].mode != TYPE_MODE (TREE_TYPE (args[i].tree_value)))\n-\t  args[i].value\n-\t    = convert_modes (args[i].mode,\n-\t\t\t     TYPE_MODE (TREE_TYPE (args[i].tree_value)),\n-\t\t\t     args[i].value, args[i].unsignedp);\n-\n-\t/* If the value is expensive, and we are inside an appropriately \n-\t   short loop, put the value into a pseudo and then put the pseudo\n-\t   into the hard reg.\n-\n-\t   For small register classes, also do this if this call uses\n-\t   register parameters.  This is to avoid reload conflicts while\n-\t   loading the parameters registers.  */\n-\n-\tif ((! (GET_CODE (args[i].value) == REG\n-\t\t|| (GET_CODE (args[i].value) == SUBREG\n-\t\t    && GET_CODE (SUBREG_REG (args[i].value)) == REG)))\n-\t    && args[i].mode != BLKmode\n-\t    && rtx_cost (args[i].value, SET) > 2\n-\t    && ((SMALL_REGISTER_CLASSES && reg_parm_seen)\n-\t\t|| preserve_subexpressions_p ()))\n-\t  args[i].value = copy_to_mode_reg (args[i].mode, args[i].value);\n-      }\n+  precompute_register_parameters (num_actuals, args, &reg_parm_seen);\n \n #if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)\n \n-  /* The argument list is the property of the called routine and it\n-     may clobber it.  If the fixed area has been used for previous\n-     parameters, we must save and restore it.\n-\n-     Here we compute the boundary of the that needs to be saved, if any.  */\n-\n-#ifdef ARGS_GROW_DOWNWARD\n-  for (i = 0; i < reg_parm_stack_space + 1; i++)\n-#else\n-  for (i = 0; i < reg_parm_stack_space; i++)\n+  /* Save the fixed argument area if it's part of the caller's frame and\n+     is clobbered by argument setup for this call.  */\n+  save_area = save_fixed_argument_area (reg_parm_stack_space, argblock,\n+\t\t\t\t\t&low_to_save, &high_to_save);\n #endif\n-    {\n-      if (i >=  highest_outgoing_arg_in_use\n-\t  || stack_usage_map[i] == 0)\n-\tcontinue;\n-\n-      if (low_to_save == -1)\n-\tlow_to_save = i;\n-\n-      high_to_save = i;\n-    }\n-\n-  if (low_to_save >= 0)\n-    {\n-      int num_to_save = high_to_save - low_to_save + 1;\n-      enum machine_mode save_mode\n-\t= mode_for_size (num_to_save * BITS_PER_UNIT, MODE_INT, 1);\n-      rtx stack_area;\n-\n-      /* If we don't have the required alignment, must do this in BLKmode.  */\n-      if ((low_to_save & (MIN (GET_MODE_SIZE (save_mode),\n-\t\t\t       BIGGEST_ALIGNMENT / UNITS_PER_WORD) - 1)))\n-\tsave_mode = BLKmode;\n-\n-#ifdef ARGS_GROW_DOWNWARD\n-      stack_area = gen_rtx_MEM (save_mode,\n-\t\t\t\tmemory_address (save_mode,\n-\t\t\t\t\t\tplus_constant (argblock,\n-\t\t\t\t\t\t\t       - high_to_save)));\n-#else\n-      stack_area = gen_rtx_MEM (save_mode,\n-\t\t\t\tmemory_address (save_mode,\n-\t\t\t\t\t\tplus_constant (argblock,\n-\t\t\t\t\t\t\t       low_to_save)));\n-#endif\n-      if (save_mode == BLKmode)\n-\t{\n-\t  save_area = assign_stack_temp (BLKmode, num_to_save, 0);\n-\t  MEM_IN_STRUCT_P (save_area) = 0;\n-\t  emit_block_move (validize_mem (save_area), stack_area,\n-\t\t\t   GEN_INT (num_to_save),\n-\t\t\t   PARM_BOUNDARY / BITS_PER_UNIT);\n-\t}\n-      else\n-\t{\n-\t  save_area = gen_reg_rtx (save_mode);\n-\t  emit_move_insn (save_area, stack_area);\n-\t}\n-    }\n-#endif\n-\t  \n+\t\t\t\n \n   /* Now store (and compute if necessary) all non-register parms.\n      These come before register parms, since they can require block-moves,\n@@ -1775,63 +1940,8 @@ expand_call (exp, target, ignore)\n      and whose alignment does not permit a direct copy into registers,\n      make a group of pseudos that correspond to each register that we\n      will later fill.  */\n-\n   if (STRICT_ALIGNMENT)\n-    for (i = 0; i < num_actuals; i++)\n-      if (args[i].reg != 0 && ! args[i].pass_on_stack\n-\t&& args[i].mode == BLKmode\n-\t  && (TYPE_ALIGN (TREE_TYPE (args[i].tree_value))\n-\t      < (unsigned int) MIN (BIGGEST_ALIGNMENT, BITS_PER_WORD)))\n-\t{\n-\t  int bytes = int_size_in_bytes (TREE_TYPE (args[i].tree_value));\n-\t  int big_endian_correction = 0;\n-\n-\t  args[i].n_aligned_regs\n-\t    = args[i].partial ? args[i].partial\n-\t      : (bytes + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD;\n-\n-\t  args[i].aligned_regs = (rtx *) alloca (sizeof (rtx)\n-\t\t\t\t\t\t * args[i].n_aligned_regs);\n-\n-\t  /* Structures smaller than a word are aligned to the least\n-\t     significant byte (to the right).  On a BYTES_BIG_ENDIAN machine,\n-\t     this means we must skip the empty high order bytes when\n-\t     calculating the bit offset.  */\n-\t  if (BYTES_BIG_ENDIAN && bytes < UNITS_PER_WORD)\n-\t    big_endian_correction = (BITS_PER_WORD  - (bytes * BITS_PER_UNIT));\n-\n-\t  for (j = 0; j < args[i].n_aligned_regs; j++)\n-\t    {\n-\t      rtx reg = gen_reg_rtx (word_mode);\n-\t      rtx word = operand_subword_force (args[i].value, j, BLKmode);\n-\t      int bitsize = MIN (bytes * BITS_PER_UNIT, BITS_PER_WORD);\n-\t      int bitalign = TYPE_ALIGN (TREE_TYPE (args[i].tree_value));\n-\n-\t      args[i].aligned_regs[j] = reg;\n-\n-\t      /* There is no need to restrict this code to loading items\n-\t\t in TYPE_ALIGN sized hunks.  The bitfield instructions can\n-\t\t load up entire word sized registers efficiently.\n-\n-\t\t ??? This may not be needed anymore.\n-\t\t We use to emit a clobber here but that doesn't let later\n-\t\t passes optimize the instructions we emit.  By storing 0 into\n-\t\t the register later passes know the first AND to zero out the\n-\t\t bitfield being set in the register is unnecessary.  The store\n-\t\t of 0 will be deleted as will at least the first AND.  */\n-\n-\t      emit_move_insn (reg, const0_rtx);\n-\n-\t      bytes -= bitsize / BITS_PER_UNIT;\n-\t      store_bit_field (reg, bitsize, big_endian_correction, word_mode,\n-\t\t\t       extract_bit_field (word, bitsize, 0, 1,\n-\t\t\t\t\t\t  NULL_RTX, word_mode,\n-\t\t\t\t\t\t  word_mode,\n-\t\t\t\t\t\t  bitalign / BITS_PER_UNIT,\n-\t\t\t\t\t\t  BITS_PER_WORD),\n-\t\t\t       bitalign / BITS_PER_UNIT, BITS_PER_WORD);\n-\t    }\n-\t}\n+    store_unaligned_arguments_into_pseudos (args, num_actuals);\n \n   /* Now store any partially-in-registers parm.\n      This is the last place a block-move can happen.  */\n@@ -2152,31 +2262,10 @@ expand_call (exp, target, ignore)\n     {\n #ifdef REG_PARM_STACK_SPACE\n       if (save_area)\n-\t{\n-\t  enum machine_mode save_mode = GET_MODE (save_area);\n-#ifdef ARGS_GROW_DOWNWARD\n-\t  rtx stack_area\n-\t    = gen_rtx_MEM (save_mode,\n-\t\t\t   memory_address (save_mode,\n-\t\t\t\t\t   plus_constant (argblock,\n-\t\t\t\t\t\t\t  - high_to_save)));\n-#else\n-\t  rtx stack_area\n-\t    = gen_rtx_MEM (save_mode,\n-\t\t\t   memory_address (save_mode,\n-\t\t\t\t\t   plus_constant (argblock,\n-\t\t\t\t\t\t\t  low_to_save)));\n+\trestore_fixed_argument_area (save_area, argblock,\n+\t\t\t\t     high_to_save, low_to_save);\n #endif\n \n-\t  if (save_mode != BLKmode)\n-\t    emit_move_insn (stack_area, save_area);\n-\t  else\n-\t    emit_block_move (stack_area, validize_mem (save_area),\n-\t\t\t     GEN_INT (high_to_save - low_to_save + 1),\n-\t\t\t     PARM_BOUNDARY / BITS_PER_UNIT);\n-\t}\n-#endif\n-\t  \n       /* If we saved any argument areas, restore them.  */\n       for (i = 0; i < num_actuals; i++)\n \tif (args[i].save_area)"}]}