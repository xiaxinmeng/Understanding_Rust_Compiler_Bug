{"sha": "47ea02bb862d6be9a200ebccbd5d64b31a003ec2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdlYTAyYmI4NjJkNmJlOWEyMDBlYmNjYmQ1ZDY0YjMxYTAwM2VjMg==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-05-31T20:00:16Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-06-01T00:49:39Z"}, "message": "Move Ranger cache to range-query and fur_source model.\n\nFlatten and simplify gori-computes. Tweak debug output.\nrange-cache now provides range_of_expr and range_on_edge in the\nstandard formats, but in a \"query what you have\" mode rather than\n\"go figure out anything that is missing\" mode.\n\n\t* gimple-range-cache.cc (ranger_cache::ranger_cache): Adjust for\n\tgori_compute being a member rather than base class.\n\tdervied call to member call.\n\t(ranger_cache::dump): No longer dump gori_map.\n\t(ranger_cache::dump_bb): New.\n\t(ranger_cache::get_non_stale_global_range): Adjust for gori_compute\n\tbeing a member rather than base class.\n\t(ranger_cache::set_global_range): Ditto.\n\t(ranger_cache::ssa_range_in_bb): Ditto.\n\t(ranger_cache::range_of_expr): New.\n\t(ranger_cache::range_on_edge): New.\n\t(ranger_cache::block_range): Adjust for gori_computes.  Debug changes.\n\t(ranger_cache::propagate_cache):  Adjust debugging output.\n\t(ranger_cache::fill_block_cache): Adjust for gori_computes.  Debug\n\toutput changes.\n\t* gimple-range-cache.h (class ranger_cache): Make gori_compute a\n\tmember, and inherit from range_query instead.\n\t(ranger_cache::dump_bb): New. split from dump.\n\t* gimple-range-gori.cc (gori_compute::ssa_range_in_bb): Delete.\n\t(gori_compute::expr_range_at_stmt): Delete.\n\t(gori_compute::compute_name_range_op): Delete.\n\t(gori_compute::compute_operand_range_switch): Add fur_source.\n\t(gori_compute::compute_operand_range): Add fur_source param, inline\n\told compute_name_range_op and optimize_logical_operands.\n\t(struct tf_range): Delete.\n\t(gori_compute::logical_combine): Adjust\n\t(gori_compute::optimize_logical_operands): Delete.\n\t(gori_compute::compute_logical_operands_in_chain): Delete.\n\t(gori_compute::compute_logical_operands): Adjust.\n\t(gori_compute::compute_operand1_range): Adjust to fur_source.\n\t(gori_compute::compute_operand2_range): Ditto.\n\t(gori_compute::compute_operand1_and_operand2_range): Ditto.\n\t(gori_compute::outgoing_edge_range_p): Add range_query parameter,\n\tand adjust to fur_source.\n\t* gimple-range-gori.h (class gori_compute): Simplify and adjust to\n\trange_query and fur_source.\n\t* gimple-range.cc (gimple_ranger::range_on_edge): Query range_on_edge\n\tfrom the ranger_cache..\n\t(gimple_ranger::fold_range_internal): Adjust to base class change of\n\tranger_cache.\n\t(gimple_ranger::dump_bb): Adjust dump.\n\t* gimple-range.h (gimple_ranger):export gori computes object.", "tree": {"sha": "543e1681315c54ab8e488655243b4bb94e5a9a7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/543e1681315c54ab8e488655243b4bb94e5a9a7b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47ea02bb862d6be9a200ebccbd5d64b31a003ec2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47ea02bb862d6be9a200ebccbd5d64b31a003ec2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47ea02bb862d6be9a200ebccbd5d64b31a003ec2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47ea02bb862d6be9a200ebccbd5d64b31a003ec2/comments", "author": null, "committer": null, "parents": [{"sha": "1ffbfc2659e7e8fa5c5d633869870af8fca5e8ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ffbfc2659e7e8fa5c5d633869870af8fca5e8ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ffbfc2659e7e8fa5c5d633869870af8fca5e8ee"}], "stats": {"total": 521, "additions": 223, "deletions": 298}, "files": [{"sha": "e776bed139b5754f52794e17881c8a4ae17e9c84", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 51, "deletions": 28, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47ea02bb862d6be9a200ebccbd5d64b31a003ec2/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47ea02bb862d6be9a200ebccbd5d64b31a003ec2/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=47ea02bb862d6be9a200ebccbd5d64b31a003ec2", "patch": "@@ -583,7 +583,7 @@ ranger_cache::ranger_cache (gimple_ranger &q) : query (q)\n     {\n       basic_block bb = BASIC_BLOCK_FOR_FN (cfun, x);\n       if (bb)\n-\texports (bb);\n+\tm_gori.exports (bb);\n     }\n }\n \n@@ -599,22 +599,18 @@ ranger_cache::~ranger_cache ()\n // gori map as well.\n \n void\n-ranger_cache::dump (FILE *f, bool gori_dump)\n+ranger_cache::dump (FILE *f)\n {\n   m_globals.dump (f);\n-  if (gori_dump)\n-    {\n-      fprintf (f, \"\\nDUMPING GORI MAP\\n\");\n-      gori_compute::dump (f);\n-    }\n   fprintf (f, \"\\n\");\n }\n \n // Dump the caches for basic block BB to file F.\n \n void\n-ranger_cache::dump (FILE *f, basic_block bb)\n+ranger_cache::dump_bb (FILE *f, basic_block bb)\n {\n+  m_gori.gori_map::dump (f, bb, false);\n   m_on_entry.dump (f, bb);\n }\n \n@@ -641,7 +637,8 @@ ranger_cache::get_non_stale_global_range (irange &r, tree name)\n     {\n       // Use this value if the range is constant or current.\n       if (r.singleton_p ()\n-\t  || m_temporal->current_p (name, depend1 (name), depend2 (name)))\n+\t  || m_temporal->current_p (name, m_gori.depend1 (name),\n+\t\t\t\t    m_gori.depend2 (name)))\n \treturn true;\n     }\n   else\n@@ -681,7 +678,7 @@ ranger_cache::set_global_range (tree name, const irange &r)\n \n   if (r.singleton_p ()\n       || (POINTER_TYPE_P (TREE_TYPE (name)) && r.nonzero_p ()))\n-    set_range_invariant (name);\n+    m_gori.set_range_invariant (name);\n   m_temporal->set_timestamp (name);\n }\n \n@@ -745,7 +742,7 @@ ranger_cache::ssa_range_in_bb (irange &r, tree name, basic_block bb)\n       // If it has no entry but should, then mark this as a poor value.\n       // Its not a poor value if it does not have *any* edge ranges,\n       // Then global range is as good as it gets.\n-      if (has_edge_range_p (name) && push_poor_value (bb, name))\n+      if (m_gori.has_edge_range_p (name) && push_poor_value (bb, name))\n \t{\n \t  if (DEBUG_RANGE_CACHE)\n \t    {\n@@ -759,7 +756,6 @@ ranger_cache::ssa_range_in_bb (irange &r, tree name, basic_block bb)\n       if (!m_globals.get_global_range (r, name))\n \tr = gimple_range_global (name);\n     }\n-\n   // Check if pointers have any non-null dereferences.  Non-call\n   // exceptions mean we could throw in the middle of the block, so just\n   // punt for now on those.\n@@ -768,6 +764,29 @@ ranger_cache::ssa_range_in_bb (irange &r, tree name, basic_block bb)\n     r = range_nonzero (TREE_TYPE (name));\n }\n \n+// Implement range_of_expr.\n+\n+bool\n+ranger_cache::range_of_expr (irange &r, tree expr, gimple *stmt)\n+{\n+  if (gimple_range_ssa_p (expr))\n+    ssa_range_in_bb (r, expr, gimple_bb (stmt));\n+  else\n+    get_tree_range (r, expr);\n+  return true;\n+}\n+\n+// Implement range_on_edge which returns true ONLY if there is a range\n+// calculated.\n+\n+bool\n+ranger_cache::range_on_edge (irange &r, edge e, tree expr)\n+{\n+  if (gimple_range_ssa_p (expr))\n+    return m_gori.outgoing_edge_range_p (r, e, expr, *this);\n+  return false;\n+}\n+\n // Return a static range for NAME on entry to basic block BB in R.  If\n // calc is true, fill any cache entries required between BB and the\n // def block for NAME.  Otherwise, return false if the cache is empty.\n@@ -779,7 +798,7 @@ ranger_cache::block_range (irange &r, basic_block bb, tree name, bool calc)\n \n   // If there are no range calculations anywhere in the IL, global range\n   // applies everywhere, so don't bother caching it.\n-  if (!has_edge_range_p (name))\n+  if (!m_gori.has_edge_range_p (name))\n     return false;\n \n   if (calc)\n@@ -842,20 +861,29 @@ ranger_cache::propagate_cache (tree name)\n       gcc_checking_assert (m_on_entry.bb_range_p (name, bb));\n       m_on_entry.get_bb_range (current_range, name, bb);\n \n+      if (DEBUG_RANGE_CACHE)\n+\t{\n+\t  fprintf (dump_file, \"FWD visiting block %d for \", bb->index);\n+\t  print_generic_expr (dump_file, name, TDF_SLIM);\n+\t  fprintf (dump_file, \"  starting range : \");\n+\t  current_range.dump (dump_file);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+\n       // Calculate the \"new\" range on entry by unioning the pred edges.\n       new_range.set_undefined ();\n       FOR_EACH_EDGE (e, ei, bb->preds)\n \t{\n \t  if (DEBUG_RANGE_CACHE)\n \t    fprintf (dump_file, \"   edge %d->%d :\", e->src->index, bb->index);\n \t  // Get whatever range we can for this edge.\n-\t  if (!outgoing_edge_range_p (e_range, e, name))\n+\t  if (!m_gori.outgoing_edge_range_p (e_range, e, name, *this))\n \t    {\n \t      ssa_range_in_bb (e_range, name, e->src);\n \t      if (DEBUG_RANGE_CACHE)\n \t\t{\n \t\t  fprintf (dump_file, \"No outgoing edge range, picked up \");\n-\t\t  e_range.dump(dump_file);\n+\t\t  e_range.dump (dump_file);\n \t\t  fprintf (dump_file, \"\\n\");\n \t\t}\n \t    }\n@@ -864,7 +892,7 @@ ranger_cache::propagate_cache (tree name)\n \t      if (DEBUG_RANGE_CACHE)\n \t\t{\n \t\t  fprintf (dump_file, \"outgoing range :\");\n-\t\t  e_range.dump(dump_file);\n+\t\t  e_range.dump (dump_file);\n \t\t  fprintf (dump_file, \"\\n\");\n \t\t}\n \t    }\n@@ -873,15 +901,6 @@ ranger_cache::propagate_cache (tree name)\n \t    break;\n \t}\n \n-      if (DEBUG_RANGE_CACHE)\n-\t{\n-\t  fprintf (dump_file, \"FWD visiting block %d for \", bb->index);\n-\t  print_generic_expr (dump_file, name, TDF_SLIM);\n-\t  fprintf (dump_file, \"  starting range : \");\n-\t  current_range.dump (dump_file);\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n-\n       // If the range on entry has changed, update it.\n       if (new_range != current_range)\n \t{\n@@ -1042,8 +1061,12 @@ ranger_cache::fill_block_cache (tree name, basic_block bb, basic_block def_bb)\n \t  if (m_on_entry.get_bb_range (r, name, pred))\n \t    {\n \t      if (DEBUG_RANGE_CACHE)\n-\t\tfprintf (dump_file, \"has cache, \");\n-\t      if (!r.undefined_p () || has_edge_range_p (name, e))\n+\t\t{\n+\t\t  fprintf (dump_file, \"has cache, \");\n+\t\t  r.dump (dump_file);\n+\t\t  fprintf (dump_file, \", \");\n+\t\t}\n+\t      if (!r.undefined_p () || m_gori.has_edge_range_p (name, e))\n \t\t{\n \t\t  add_to_update (node);\n \t\t  if (DEBUG_RANGE_CACHE)\n@@ -1053,7 +1076,7 @@ ranger_cache::fill_block_cache (tree name, basic_block bb, basic_block def_bb)\n \t    }\n \n \t  if (DEBUG_RANGE_CACHE)\n-\t    fprintf (dump_file, \"pushing undefined pred block. \");\n+\t    fprintf (dump_file, \"pushing undefined pred block.\\n\");\n \t  // If the pred hasn't been visited (has no range), add it to\n \t  // the list.\n \t  gcc_checking_assert (!m_on_entry.bb_range_p (name, pred));"}, {"sha": "ac50219d1ddd493446b65f09c60c7c26b6dda114", "filename": "gcc/gimple-range-cache.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47ea02bb862d6be9a200ebccbd5d64b31a003ec2/gcc%2Fgimple-range-cache.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47ea02bb862d6be9a200ebccbd5d64b31a003ec2/gcc%2Fgimple-range-cache.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.h?ref=47ea02bb862d6be9a200ebccbd5d64b31a003ec2", "patch": "@@ -86,23 +86,26 @@ class ssa_global_cache\n // them available for gori-computes to query so outgoing edges can be\n // properly calculated.\n \n-class ranger_cache : public gori_compute\n+class ranger_cache : public range_query\n {\n public:\n   ranger_cache (class gimple_ranger &q);\n   ~ranger_cache ();\n \n-  virtual void ssa_range_in_bb (irange &r, tree name, basic_block bb);\n+  virtual bool range_of_expr (irange &r, tree expr, gimple *stmt);\n+  virtual bool range_on_edge (irange &r, edge e, tree expr);\n+  void ssa_range_in_bb (irange &r, tree name, basic_block bb);\n   bool block_range (irange &r, basic_block bb, tree name, bool calc = true);\n \n   bool get_global_range (irange &r, tree name) const;\n   bool get_non_stale_global_range (irange &r, tree name);\n   void set_global_range (tree name, const irange &r);\n \n   non_null_ref m_non_null;\n+  gori_compute m_gori;\n \n-  void dump (FILE *f, bool dump_gori = true);\n-  void dump (FILE *f, basic_block bb);\n+  void dump_bb (FILE *f, basic_block bb);\n+  virtual void dump (FILE *f) OVERRIDE;\n private:\n   ssa_global_cache m_globals;\n   block_range_cache m_on_entry;"}, {"sha": "2c5360690db6c4527d02aa65713a546b04c48b28", "filename": "gcc/gimple-range-gori.cc", "status": "modified", "additions": 140, "deletions": 231, "changes": 371, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47ea02bb862d6be9a200ebccbd5d64b31a003ec2/gcc%2Fgimple-range-gori.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47ea02bb862d6be9a200ebccbd5d64b31a003ec2/gcc%2Fgimple-range-gori.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.cc?ref=47ea02bb862d6be9a200ebccbd5d64b31a003ec2", "patch": "@@ -575,76 +575,14 @@ gori_compute::gori_compute ()\n   m_bool_one = int_range<2> (boolean_true_node, boolean_true_node);\n }\n \n-// Provide a default of VARYING for all incoming SSA names.\n-\n-void\n-gori_compute::ssa_range_in_bb (irange &r, tree name, basic_block)\n-{\n-  r.set_varying (TREE_TYPE (name));\n-}\n-\n-void\n-gori_compute::expr_range_at_stmt (irange &r, tree expr, gimple *s)\n-{\n-  if (gimple_range_ssa_p (expr))\n-    ssa_range_in_bb (r, expr, gimple_bb (s));\n-  else\n-    get_tree_range (r, expr);\n-}\n-\n-// Calculate the range for NAME if the lhs of statement S has the\n-// range LHS.  Return the result in R.  Return false if no range can be\n-// calculated.\n-\n-bool\n-gori_compute::compute_name_range_op (irange &r, gimple *stmt,\n-\t\t\t\t     const irange &lhs, tree name)\n-{\n-  int_range_max op1_range, op2_range;\n-\n-  tree op1 = gimple_range_operand1 (stmt);\n-  tree op2 = gimple_range_operand2 (stmt);\n-\n-  // Operand 1 is the name being looked for, evaluate it.\n-  if (op1 == name)\n-    {\n-      expr_range_at_stmt (op1_range, op1, stmt);\n-      if (!op2)\n-\t{\n-\t  // The second parameter to a unary operation is the range\n-\t  // for the type of operand1, but if it can be reduced\n-\t  // further, the results will be better.  Start with what we\n-\t  // know of the range of OP1 instead of the full type.\n-\t  return gimple_range_calc_op1 (r, stmt, lhs, op1_range);\n-\t}\n-      // If we need the second operand, get a value and evaluate.\n-      expr_range_at_stmt (op2_range, op2, stmt);\n-      if (gimple_range_calc_op1 (r, stmt, lhs, op2_range))\n-\tr.intersect (op1_range);\n-      else\n-        r = op1_range;\n-      return true;\n-    }\n-\n-  if (op2 == name)\n-    {\n-      expr_range_at_stmt (op1_range, op1, stmt);\n-      expr_range_at_stmt (r, op2, stmt);\n-      if (gimple_range_calc_op2 (op2_range, stmt, lhs, op1_range))\n-        r.intersect (op2_range);\n-      return true;\n-    }\n-  return false;\n-}\n-\n // Given the switch S, return an evaluation in R for NAME when the lhs\n // evaluates to LHS.  Returning false means the name being looked for\n // was not resolvable.\n \n bool\n gori_compute::compute_operand_range_switch (irange &r, gswitch *s,\n \t\t\t\t\t    const irange &lhs,\n-\t\t\t\t\t    tree name)\n+\t\t\t\t\t    tree name, fur_source &src)\n {\n   tree op1 = gimple_switch_index (s);\n \n@@ -659,7 +597,7 @@ gori_compute::compute_operand_range_switch (irange &r, gswitch *s,\n \n   // If op1 is in the defintion chain, pass lhs back.\n   if (gimple_range_ssa_p (op1) && in_chain_p (name, op1))\n-    return compute_operand_range (r, SSA_NAME_DEF_STMT (op1), lhs, name);\n+    return compute_operand_range (r, SSA_NAME_DEF_STMT (op1), lhs, name, src);\n \n   return false;\n }\n@@ -671,44 +609,69 @@ gori_compute::compute_operand_range_switch (irange &r, gswitch *s,\n \n bool\n gori_compute::compute_operand_range (irange &r, gimple *stmt,\n-\t\t\t\t     const irange &lhs, tree name)\n+\t\t\t\t     const irange &lhs, tree name,\n+\t\t\t\t     fur_source &src)\n {\n+  // If the lhs doesn't tell us anything, neither will unwinding further.\n+  if (lhs.varying_p ())\n+    return false;\n+\n   // Empty ranges are viral as they are on an unexecutable path.\n   if (lhs.undefined_p ())\n     {\n       r.set_undefined ();\n       return true;\n     }\n   if (is_a<gswitch *> (stmt))\n-    return compute_operand_range_switch (r, as_a<gswitch *> (stmt), lhs, name);\n+    return compute_operand_range_switch (r, as_a<gswitch *> (stmt), lhs, name,\n+\t\t\t\t\t src);\n   if (!gimple_range_handler (stmt))\n     return false;\n \n   tree op1 = gimple_range_ssa_p (gimple_range_operand1 (stmt));\n   tree op2 = gimple_range_ssa_p (gimple_range_operand2 (stmt));\n \n-  // The base ranger handles NAME on this statement.\n-  if (op1 == name || op2 == name)\n-    return compute_name_range_op (r, stmt, lhs, name);\n-\n-  if (is_gimple_logical_p (stmt))\n-    return compute_logical_operands (r, stmt, lhs, name);\n+  // Handle end of lookup first.\n+  if (op1 == name)\n+    return compute_operand1_range (r, stmt, lhs, name, src);\n+  if (op2 == name)\n+    return compute_operand2_range (r, stmt, lhs, name, src);\n \n   // NAME is not in this stmt, but one of the names in it ought to be\n   // derived from it.\n   bool op1_in_chain = op1 && in_chain_p (name, op1);\n   bool op2_in_chain = op2 && in_chain_p (name, op2);\n+\n+  // If neither operand is derived, then this stmt tells us nothing.\n+  if (!op1_in_chain && !op2_in_chain)\n+    return false;\n+\n+  // Process logicals as they have special handling.\n+  if (is_gimple_logical_p (stmt))\n+    {\n+      int_range_max op1_trange, op1_frange;\n+      int_range_max op2_trange, op2_frange;\n+      compute_logical_operands (op1_trange, op1_frange, stmt, lhs,\n+\t\t\t\tname, src, op1, op1_in_chain);\n+      compute_logical_operands (op2_trange, op2_frange, stmt, lhs,\n+\t\t\t\tname, src, op2, op2_in_chain);\n+      return logical_combine (r, gimple_expr_code (stmt), lhs,\n+\t\t\t      op1_trange, op1_frange, op2_trange, op2_frange);\n+    }\n+\n+  // Follow the appropriate operands now.\n   if (op1_in_chain && op2_in_chain)\n-    return compute_operand1_and_operand2_range (r, stmt, lhs, name);\n+    return compute_operand1_and_operand2_range (r, stmt, lhs, name, src);\n   if (op1_in_chain)\n-    return compute_operand1_range (r, stmt, lhs, name);\n+    return compute_operand1_range (r, stmt, lhs, name, src);\n   if (op2_in_chain)\n-    return compute_operand2_range (r, stmt, lhs, name);\n+    return compute_operand2_range (r, stmt, lhs, name, src);\n \n   // If neither operand is derived, this statement tells us nothing.\n   return false;\n }\n \n+\n // Return TRUE if range R is either a true or false compatible range.\n \n static bool\n@@ -724,32 +687,18 @@ range_is_either_true_or_false (const irange &r)\n   return (r.singleton_p () || !r.contains_p (build_zero_cst (type)));\n }\n \n-// A pair of ranges for true/false paths.\n-\n-struct tf_range\n-{\n-  tf_range () { }\n-  tf_range (const irange &t_range, const irange &f_range)\n-  {\n-    true_range = t_range;\n-    false_range = f_range;\n-  }\n-  int_range_max true_range, false_range;\n-};\n-\n // Evaluate a binary logical expression by combining the true and\n // false ranges for each of the operands based on the result value in\n // the LHS.\n \n bool\n gori_compute::logical_combine (irange &r, enum tree_code code,\n \t\t\t       const irange &lhs,\n-\t\t\t       const tf_range &op1, const tf_range &op2)\n+\t\t\t       const irange &op1_true, const irange &op1_false,\n+\t\t\t       const irange &op2_true, const irange &op2_false)\n {\n-  if (op1.true_range.varying_p ()\n-      && op1.false_range.varying_p ()\n-      && op2.true_range.varying_p ()\n-      && op2.false_range.varying_p ())\n+  if (op1_true.varying_p () && op1_false.varying_p ()\n+      && op2_true.varying_p () && op2_false.varying_p ())\n     return false;\n \n   // This is not a simple fold of a logical expression, rather it\n@@ -790,8 +739,10 @@ gori_compute::logical_combine (irange &r, enum tree_code code,\n   if (!range_is_either_true_or_false (lhs))\n     {\n       int_range_max r1;\n-      if (logical_combine (r1, code, m_bool_zero, op1, op2)\n-\t  && logical_combine (r, code, m_bool_one, op1, op2))\n+      if (logical_combine (r1, code, m_bool_zero, op1_true, op1_false,\n+\t\t\t   op2_true, op2_false)\n+\t  && logical_combine (r, code, m_bool_one, op1_true, op1_false,\n+\t\t\t      op2_true, op2_false))\n \t{\n \t  r.union_ (r1);\n \t  return true;\n@@ -808,18 +759,18 @@ gori_compute::logical_combine (irange &r, enum tree_code code,\n         if (!lhs.zero_p ())\n \t  {\n \t    // The TRUE side is the intersection of the the 2 true ranges.\n-\t    r = op1.true_range;\n-\t    r.intersect (op2.true_range);\n+\t    r = op1_true;\n+\t    r.intersect (op2_true);\n \t  }\n \telse\n \t  {\n \t    // The FALSE side is the union of the other 3 cases.\n-\t    int_range_max ff (op1.false_range);\n-\t    ff.intersect (op2.false_range);\n-\t    int_range_max tf (op1.true_range);\n-\t    tf.intersect (op2.false_range);\n-\t    int_range_max ft (op1.false_range);\n-\t    ft.intersect (op2.true_range);\n+\t    int_range_max ff (op1_false);\n+\t    ff.intersect (op2_false);\n+\t    int_range_max tf (op1_true);\n+\t    tf.intersect (op2_false);\n+\t    int_range_max ft (op1_false);\n+\t    ft.intersect (op2_true);\n \t    r = ff;\n \t    r.union_ (tf);\n \t    r.union_ (ft);\n@@ -834,19 +785,19 @@ gori_compute::logical_combine (irange &r, enum tree_code code,\n \t    // An OR operation will only take the FALSE path if both\n \t    // operands are false simlulateously, which means they should\n \t    // be intersected.  !(x || y) == !x && !y\n-\t    r = op1.false_range;\n-\t    r.intersect (op2.false_range);\n+\t    r = op1_false;\n+\t    r.intersect (op2_false);\n \t  }\n \telse\n \t  {\n \t    // The TRUE side of an OR operation will be the union of\n \t    // the other three combinations.\n-\t    int_range_max tt (op1.true_range);\n-\t    tt.intersect (op2.true_range);\n-\t    int_range_max tf (op1.true_range);\n-\t    tf.intersect (op2.false_range);\n-\t    int_range_max ft (op1.false_range);\n-\t    ft.intersect (op2.true_range);\n+\t    int_range_max tt (op1_true);\n+\t    tt.intersect (op2_true);\n+\t    int_range_max tf (op1_true);\n+\t    tf.intersect (op2_false);\n+\t    int_range_max ft (op1_false);\n+\t    ft.intersect (op2_true);\n \t    r = tt;\n \t    r.union_ (tf);\n \t    r.union_ (ft);\n@@ -859,103 +810,54 @@ gori_compute::logical_combine (irange &r, enum tree_code code,\n   return true;\n }\n \n-// Helper function for compute_logical_operands_in_chain that computes\n-// the range of logical statements that can be computed without\n-// chasing down operands.  These are things like [0 = x | y] where we\n-// know neither operand can be non-zero, or [1 = x & y] where we know\n-// neither operand can be zero.\n-\n-bool\n-gori_compute::optimize_logical_operands (tf_range &range,\n-\t\t\t\t\t gimple *stmt,\n-\t\t\t\t\t const irange &lhs,\n-\t\t\t\t\t tree name,\n-\t\t\t\t\t tree op)\n-{\n-  enum tree_code code = gimple_expr_code (stmt);\n-\n-  // Optimize [0 = x | y], since neither operand can ever be non-zero.\n-  if ((code == BIT_IOR_EXPR || code == TRUTH_OR_EXPR) && lhs.zero_p ())\n-    {\n-      if (!compute_operand_range (range.false_range, SSA_NAME_DEF_STMT (op),\n-\t\t\t\t  m_bool_zero, name))\n-\texpr_range_at_stmt (range.false_range, name, stmt);\n-      range.true_range = range.false_range;\n-      return true;\n-    }\n-  // Optimize [1 = x & y], since neither operand can ever be zero.\n-  if ((code == BIT_AND_EXPR || code == TRUTH_AND_EXPR) && lhs == m_bool_one)\n-    {\n-      if (!compute_operand_range (range.true_range, SSA_NAME_DEF_STMT (op),\n-\t\t\t\t  m_bool_one, name))\n-\texpr_range_at_stmt (range.true_range, name, stmt);\n-      range.false_range = range.true_range;\n-      return true;\n-    }\n-  return false;\n-}\n \n // Given a logical STMT, calculate true and false ranges for each\n // potential path of NAME, assuming NAME came through the OP chain if\n // OP_IN_CHAIN is true.\n \n void\n-gori_compute::compute_logical_operands_in_chain (tf_range &range,\n-\t\t\t\t\t\t gimple *stmt,\n-\t\t\t\t\t\t const irange &lhs,\n-\t\t\t\t\t\t tree name,\n-\t\t\t\t\t\t tree op, bool op_in_chain)\n+gori_compute::compute_logical_operands (irange &true_range, irange &false_range,\n+\t\t\t\t\tgimple *stmt,\n+\t\t\t\t\tconst irange &lhs,\n+\t\t\t\t\ttree name, fur_source &src,\n+\t\t\t\t\ttree op, bool op_in_chain)\n {\n   gimple *src_stmt = gimple_range_ssa_p (op) ? SSA_NAME_DEF_STMT (op) : NULL;\n-  if (!op_in_chain || (src_stmt != NULL\n-      && gimple_bb (stmt) != gimple_bb (src_stmt)))\n+  if (!op_in_chain || !src_stmt || chain_import_p (gimple_get_lhs (stmt), op))\n     {\n       // If op is not in the def chain, or defined in this block,\n       // use its known value on entry to the block.\n-      expr_range_at_stmt (range.true_range, name, stmt);\n-      range.false_range = range.true_range;\n+      src.get_operand (true_range, name);\n+      false_range = true_range;\n       return;\n     }\n-  if (optimize_logical_operands (range, stmt, lhs, name, op))\n-    return;\n \n-  // Calculate ranges for true and false on both sides, since the false\n-  // path is not always a simple inversion of the true side.\n-  if (!compute_operand_range (range.true_range, src_stmt, m_bool_one, name))\n-    expr_range_at_stmt (range.true_range, name, stmt);\n-  if (!compute_operand_range (range.false_range, src_stmt, m_bool_zero, name))\n-    expr_range_at_stmt (range.false_range, name, stmt);\n-}\n-\n-// Given a logical STMT, calculate true and false for each potential\n-// path using NAME, and resolve the outcome based on the logical\n-// operator.\n-\n-bool\n-gori_compute::compute_logical_operands (irange &r, gimple *stmt,\n-\t\t\t\t\tconst irange &lhs,\n-\t\t\t\t\ttree name)\n-{\n-  // Reaching this point means NAME is not in this stmt, but one of\n-  // the names in it ought to be derived from it.\n-  tree op1 = gimple_range_operand1 (stmt);\n-  tree op2 = gimple_range_operand2 (stmt);\n-  gcc_checking_assert (op1 != name && op2 != name);\n-\n-  bool op1_in_chain = (gimple_range_ssa_p (op1) && in_chain_p (name, op1));\n-  bool op2_in_chain = (gimple_range_ssa_p (op2) && in_chain_p (name, op2));\n+  enum tree_code code = gimple_expr_code (stmt);\n+  // Optimize [0 = x | y], since neither operand can ever be non-zero.\n+  if ((code == BIT_IOR_EXPR || code == TRUTH_OR_EXPR) && lhs.zero_p ())\n+    {\n+      if (!compute_operand_range (false_range, src_stmt, m_bool_zero, name,\n+\t\t\t\t  src))\n+\tsrc.get_operand (false_range, name);\n+      true_range = false_range;\n+      return;\n+    }\n \n-  // If neither operand is derived, then this stmt tells us nothing.\n-  if (!op1_in_chain && !op2_in_chain)\n-    return false;\n+  // Optimize [1 = x & y], since neither operand can ever be zero.\n+  if ((code == BIT_AND_EXPR || code == TRUTH_AND_EXPR) && lhs == m_bool_one)\n+    {\n+      if (!compute_operand_range (true_range, src_stmt, m_bool_one, name, src))\n+\tsrc.get_operand (true_range, name);\n+      false_range = true_range;\n+      return;\n+    }\n \n-  tf_range op1_range, op2_range;\n-  compute_logical_operands_in_chain (op1_range, stmt, lhs,\n-\t\t\t\t     name, op1, op1_in_chain);\n-  compute_logical_operands_in_chain (op2_range, stmt, lhs,\n-\t\t\t\t     name, op2, op2_in_chain);\n-  return logical_combine (r, gimple_expr_code (stmt), lhs,\n-\t\t\t  op1_range, op2_range);\n+  // Calculate ranges for true and false on both sides, since the false\n+  // path is not always a simple inversion of the true side.\n+  if (!compute_operand_range (true_range, src_stmt, m_bool_one, name, src))\n+    src.get_operand (true_range, name);\n+  if (!compute_operand_range (false_range, src_stmt, m_bool_zero, name, src))\n+    src.get_operand (false_range, name);\n }\n \n // Calculate a range for NAME from the operand 1 position of STMT\n@@ -964,18 +866,20 @@ gori_compute::compute_logical_operands (irange &r, gimple *stmt,\n \n bool\n gori_compute::compute_operand1_range (irange &r, gimple *stmt,\n-\t\t\t\t      const irange &lhs, tree name)\n+\t\t\t\t      const irange &lhs, tree name,\n+\t\t\t\t      fur_source &src)\n {\n   int_range_max op1_range, op2_range;\n   tree op1 = gimple_range_operand1 (stmt);\n   tree op2 = gimple_range_operand2 (stmt);\n \n-  expr_range_at_stmt (op1_range, op1, stmt);\n+  // Fetch the known range for op1 in this block.\n+  src.get_operand (op1_range, op1);\n \n-  // Now calcuated the operand and put that result in r.\n+  // Now range-op calcuate and put that result in r.\n   if (op2)\n     {\n-      expr_range_at_stmt (op2_range, op2, stmt);\n+      src.get_operand (op2_range, op2);\n       if (!gimple_range_calc_op1 (r, stmt, lhs, op2_range))\n \treturn false;\n     }\n@@ -988,20 +892,20 @@ gori_compute::compute_operand1_range (irange &r, gimple *stmt,\n \treturn false;\n     }\n \n-  // Intersect the calculated result with the known result.\n+  // Intersect the calculated result with the known result and return if done.\n+  if (op1 == name)\n+    {\n+      r.intersect (op1_range);\n+      return true;\n+    }\n+  // If the calculation continues, we're using op1_range as the new LHS.\n   op1_range.intersect (r);\n \n   gimple *src_stmt = SSA_NAME_DEF_STMT (op1);\n-  // If def stmt is outside of this BB, then name must be an import.\n-  if (!src_stmt || (gimple_bb (src_stmt) != gimple_bb (stmt)))\n-    {\n-      // If this isn't the right import statement, then abort calculation.\n-      if (!src_stmt || gimple_get_lhs (src_stmt) != name)\n-        return false;\n-      return compute_name_range_op (r, src_stmt, op1_range, name);\n-    }\n+  gcc_checking_assert (src_stmt);\n+\n   // Then feed this range back as the LHS of the defining statement.\n-  return compute_operand_range (r, src_stmt, op1_range, name);\n+  return compute_operand_range (r, src_stmt, op1_range, name, src);\n }\n \n \n@@ -1011,61 +915,63 @@ gori_compute::compute_operand1_range (irange &r, gimple *stmt,\n \n bool\n gori_compute::compute_operand2_range (irange &r, gimple *stmt,\n-\t\t\t\t      const irange &lhs, tree name)\n+\t\t\t\t      const irange &lhs, tree name,\n+\t\t\t\t      fur_source &src)\n {\n   int_range_max op1_range, op2_range;\n   tree op1 = gimple_range_operand1 (stmt);\n   tree op2 = gimple_range_operand2 (stmt);\n \n-  expr_range_at_stmt (op1_range, op1, stmt);\n-  expr_range_at_stmt (op2_range, op2, stmt);\n+  src.get_operand (op1_range, op1);\n+  src.get_operand (op2_range, op2);\n \n   // Intersect with range for op2 based on lhs and op1.\n   if (!gimple_range_calc_op2 (r, stmt, lhs, op1_range))\n     return false;\n-  op2_range.intersect (r);\n \n-  gimple *src_stmt = SSA_NAME_DEF_STMT (op2);\n-  // If def stmt is outside of this BB, then name must be an import.\n-  if (!src_stmt || (gimple_bb (src_stmt) != gimple_bb (stmt)))\n+  // Intersect the calculated result with the known result and return if done.\n+  if (op2 == name)\n     {\n-      // If  this isn't the right src statement, then abort calculation.\n-      if (!src_stmt || gimple_get_lhs (src_stmt) != name)\n-        return false;\n-      return compute_name_range_op (r, src_stmt, op2_range, name);\n+      r.intersect (op2_range);\n+      return true;\n     }\n+  // If the calculation continues, we're using op2_range as the new LHS.\n+  op2_range.intersect (r);\n+\n+  gimple *src_stmt = SSA_NAME_DEF_STMT (op2);\n+  gcc_checking_assert (src_stmt);\n+//  gcc_checking_assert (!is_import_p (op2, find.bb));\n+\n   // Then feed this range back as the LHS of the defining statement.\n-  return compute_operand_range (r, src_stmt, op2_range, name);\n+  return compute_operand_range (r, src_stmt, op2_range, name, src);\n }\n \n // Calculate a range for NAME from both operand positions of S\n // assuming the result of the statement is LHS.  Return the range in\n // R, or false if no range could be calculated.\n \n bool\n-gori_compute::compute_operand1_and_operand2_range\n-\t\t\t\t\t(irange &r,\n-\t\t\t\t\t gimple *stmt,\n-\t\t\t\t\t const irange &lhs,\n-\t\t\t\t\t tree name)\n+gori_compute::compute_operand1_and_operand2_range (irange &r,\n+\t\t\t\t\t\t   gimple *stmt,\n+\t\t\t\t\t\t   const irange &lhs,\n+\t\t\t\t\t\t   tree name,\n+\t\t\t\t\t\t   fur_source &src)\n {\n   int_range_max op_range;\n \n   // Calculate a good a range for op2.  Since op1 == op2, this will\n   // have already included whatever the actual range of name is.\n-  if (!compute_operand2_range (op_range, stmt, lhs, name))\n+  if (!compute_operand2_range (op_range, stmt, lhs, name, src))\n     return false;\n \n   // Now get the range thru op1.\n-  if (!compute_operand1_range (r, stmt, lhs, name))\n+  if (!compute_operand1_range (r, stmt, lhs, name, src))\n     return false;\n \n-  // Whichever range is the most permissive is the one we need to\n-  // use. (?)  OR is that true?  Maybe this should be intersection?\n-  r.union_ (op_range);\n+  // Both operands have to be simultaneously true, so perform an intersection.\n+  r.intersect (op_range);\n   return true;\n }\n-\n // Return TRUE if a range can be calcalated for NAME on edge E.\n \n bool\n@@ -1091,7 +997,8 @@ gori_compute::dump (FILE *f)\n // control edge or NAME is not defined by this edge.\n \n bool\n-gori_compute::outgoing_edge_range_p (irange &r, edge e, tree name)\n+gori_compute::outgoing_edge_range_p (irange &r, edge e, tree name,\n+\t\t\t\t     range_query &q)\n {\n   int_range_max lhs;\n \n@@ -1101,10 +1008,12 @@ gori_compute::outgoing_edge_range_p (irange &r, edge e, tree name)\n   if (!stmt)\n     return false;\n \n+  fur_source src (&q, NULL, e, stmt);\n+\n   // If NAME can be calculated on the edge, use that.\n   if (is_export_p (name, e->src))\n     {\n-      if (compute_operand_range (r, stmt, lhs, name))\n+      if (compute_operand_range (r, stmt, lhs, name, src))\n \t{\n \t  // Sometimes compatible types get interchanged. See PR97360.\n \t  // Make sure we are returning the type of the thing we asked for."}, {"sha": "06f3b791359baefbb4141594e89bed8dd94696d3", "filename": "gcc/gimple-range-gori.h", "status": "modified", "additions": 18, "deletions": 29, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47ea02bb862d6be9a200ebccbd5d64b31a003ec2/gcc%2Fgimple-range-gori.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47ea02bb862d6be9a200ebccbd5d64b31a003ec2/gcc%2Fgimple-range-gori.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.h?ref=47ea02bb862d6be9a200ebccbd5d64b31a003ec2", "patch": "@@ -153,41 +153,30 @@ class gori_compute : public gori_map\n {\n public:\n   gori_compute ();\n-  bool outgoing_edge_range_p (irange &r, edge e, tree name);\n+  bool outgoing_edge_range_p (irange &r, edge e, tree name, range_query &q);\n   bool has_edge_range_p (tree name, edge e = NULL);\n   void dump (FILE *f);\n-protected:\n-  virtual void ssa_range_in_bb (irange &r, tree name, basic_block bb);\n-  bool compute_operand_range (irange &r, gimple *stmt,\n-\t\t\t      const irange &lhs, tree name);\n-\n-  void expr_range_at_stmt (irange &r, tree expr, gimple *s);\n-  bool compute_logical_operands (irange &r, gimple *stmt,\n-\t\t\t\t const irange &lhs,\n-\t\t\t\t tree name);\n-  void compute_logical_operands_in_chain (class tf_range &range,\n-\t\t\t\t\t  gimple *stmt, const irange &lhs,\n-\t\t\t\t\t  tree name, tree op,\n-\t\t\t\t\t  bool op_in_chain);\n-  bool optimize_logical_operands (tf_range &range, gimple *stmt,\n-\t\t\t\t  const irange &lhs, tree name, tree op);\n-  bool logical_combine (irange &r, enum tree_code code, const irange &lhs,\n-\t\t\tconst class tf_range &op1_range,\n-\t\t\tconst class tf_range &op2_range);\n-  int_range<2> m_bool_zero;           // Boolean false cached.\n-  int_range<2> m_bool_one;            // Boolean true cached.\n-\n private:\n-  bool compute_operand_range_switch (irange &r, gswitch *stmt,\n-\t\t\t\t     const irange &lhs, tree name);\n-  bool compute_name_range_op (irange &r, gimple *stmt, const irange &lhs,\n-\t\t\t      tree name);\n+  bool compute_operand_range (irange &r, gimple *stmt, const irange &lhs,\n+\t\t\t      tree name, class fur_source &src);\n+  bool compute_operand_range_switch (irange &r, gswitch *s, const irange &lhs,\n+\t\t\t\t     tree name, fur_source &src);\n   bool compute_operand1_range (irange &r, gimple *stmt, const irange &lhs,\n-\t\t\t       tree name);\n+\t\t\t       tree name, fur_source &src);\n   bool compute_operand2_range (irange &r, gimple *stmt, const irange &lhs,\n-\t\t\t       tree name);\n+\t\t\t       tree name, fur_source &src);\n   bool compute_operand1_and_operand2_range (irange &r, gimple *stmt,\n-\t\t\t\t\t    const irange &lhs, tree name);\n+\t\t\t\t\t    const irange &lhs, tree name,\n+\t\t\t\t\t    fur_source &src);\n+  void compute_logical_operands (irange &true_range, irange &false_range,\n+\t\t\t\t gimple *stmt, const irange &lhs,\n+\t\t\t\t tree name, fur_source &src, tree op,\n+\t\t\t\t bool op_in_chain);\n+  bool logical_combine (irange &r, enum tree_code code, const irange &lhs,\n+\t\t\tconst irange &op1_true, const irange &op1_false,\n+\t\t\tconst irange &op2_true, const irange &op2_false);\n+  int_range<2> m_bool_zero;\t// Boolean false cached.\n+  int_range<2> m_bool_one;\t// Boolean true cached.\n \n   gimple_outgoing_range outgoing;\t// Edge values for COND_EXPR & SWITCH_EXPR.\n };"}, {"sha": "d58e151eb4edbeef4c9cbec3156e22396d84116a", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47ea02bb862d6be9a200ebccbd5d64b31a003ec2/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47ea02bb862d6be9a200ebccbd5d64b31a003ec2/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=47ea02bb862d6be9a200ebccbd5d64b31a003ec2", "patch": "@@ -1051,7 +1051,7 @@ gimple_ranger::range_on_edge (irange &r, edge e, tree name)\n \t\t\t|| range_compatible_p (r.type(), TREE_TYPE (name)));\n \n   // Check to see if NAME is defined on edge e.\n-  if (m_cache.outgoing_edge_range_p (edge_range, e, name))\n+  if (m_cache.range_on_edge (edge_range, e, name))\n     r.intersect (edge_range);\n \n   return true;\n@@ -1063,7 +1063,7 @@ bool\n gimple_ranger::fold_range_internal (irange &r, gimple *s, tree name)\n {\n   fold_using_range f;\n-  fur_source src (this, &m_cache, NULL, s);\n+  fur_source src (this, &(gori ()), NULL, s);\n   return f.fold_stmt (r, s, src, name);\n }\n \n@@ -1164,7 +1164,7 @@ gimple_ranger::dump_bb (FILE *f, basic_block bb)\n   edge e;\n   int_range_max range;\n   fprintf (f, \"\\n=========== BB %d ============\\n\", bb->index);\n-  m_cache.dump (f, bb);\n+  m_cache.dump_bb (f, bb);\n \n   ::dump_bb (f, bb, 4, TDF_NONE);\n \n@@ -1193,7 +1193,7 @@ gimple_ranger::dump_bb (FILE *f, basic_block bb)\n       for (x = 1; x < num_ssa_names; x++)\n \t{\n \t  tree name = gimple_range_ssa_p (ssa_name (x));\n-\t  if (name && m_cache.outgoing_edge_range_p (range, e, name))\n+\t  if (name && m_cache.range_on_edge (range, e, name))\n \t    {\n \t      gimple *s = SSA_NAME_DEF_STMT (name);\n \t      // Only print the range if this is the def block, or\n@@ -1236,7 +1236,7 @@ gimple_ranger::dump (FILE *f)\n   FOR_EACH_BB_FN (bb, cfun)\n     dump_bb (f, bb);\n \n-  m_cache.dump (f, false);\n+  m_cache.dump (f);\n }\n \n // If SCEV has any information about phi node NAME, return it as a range in R."}, {"sha": "65f62e4ba9b2b1fcd28e912200290e6ca0933f08", "filename": "gcc/gimple-range.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47ea02bb862d6be9a200ebccbd5d64b31a003ec2/gcc%2Fgimple-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47ea02bb862d6be9a200ebccbd5d64b31a003ec2/gcc%2Fgimple-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.h?ref=47ea02bb862d6be9a200ebccbd5d64b31a003ec2", "patch": "@@ -25,10 +25,10 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"range.h\"\n #include \"range-op.h\"\n+#include \"value-query.h\"\n #include \"gimple-range-edge.h\"\n #include \"gimple-range-gori.h\"\n #include \"gimple-range-cache.h\"\n-#include \"value-query.h\"\n \n // This file is the main include point for gimple ranges.\n // There are two fold_range routines of interest:\n@@ -65,6 +65,7 @@ class gimple_ranger : public range_query\n   virtual void range_on_entry (irange &r, basic_block bb, tree name);\n   virtual void range_on_exit (irange &r, basic_block bb, tree name);\n   void export_global_ranges ();\n+  inline gori_compute &gori ()  { return m_cache.m_gori; }\n   virtual void dump (FILE *f) OVERRIDE;\n   void dump_bb (FILE *f, basic_block bb);\n protected:"}]}