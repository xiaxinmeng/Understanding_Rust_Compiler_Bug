{"sha": "7052f54e6286b1e9e87e0f2eaf827dec15f3f2c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzA1MmY1NGU2Mjg2YjFlOWU4N2UwZjJlYWY4MjdkZWMxNWYzZjJjMg==", "commit": {"author": {"name": "Kevin Pouget", "email": "pouget@adacore.com", "date": "2008-05-20T12:46:42Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-05-20T12:46:42Z"}, "message": "exp_smem.ads, [...]: Construction of access and assign routines has been replaced by an...\n\n2008-05-20  Kevin Pouget  <pouget@adacore.com>\n\n\t* exp_smem.ads, exp_smem.adb: Construction of access and assign\n\troutines has been replaced by an instantiation of\n\tSystem.Shared_Storage.Shared_Var_Procs generic package, while expanding\n\tshared variable declaration.\n\tCalls to access and assign routines have been replaced by calls to\n\tRead/Write routines of System.Shared_Storage.Shared_Var_Procs\n\tinstantiated package.\n\t\n\t* rtsfind.ads: RE_Shared_Var_Procs entry has been added in RE_Unit_Table\n\tIt identifies the new generic package added in s-shasto.\n\n\t* s-shasto.adb, s-shasto.ads: A new generic package has been added, it\n\tis instantiated for each shared passive variable. It provides\n\tsupporting procedures called upon each read or write access by the\n\texpanded code.\n\n\t* sem_attr.adb:\n\tFor this runtime unit (always compiled in GNAT mode), we allow\n\tstream attributes references for limited types for the case where\n\tshared passive objects are implemented using stream attributes,\n\twhich is the default in GNAT's persistent storage implementation.\n\nFrom-SVN: r135627", "tree": {"sha": "71c7f44038b908a0d6c4e52f839a9fa3e3c2ed25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71c7f44038b908a0d6c4e52f839a9fa3e3c2ed25"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7052f54e6286b1e9e87e0f2eaf827dec15f3f2c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7052f54e6286b1e9e87e0f2eaf827dec15f3f2c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7052f54e6286b1e9e87e0f2eaf827dec15f3f2c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7052f54e6286b1e9e87e0f2eaf827dec15f3f2c2/comments", "author": null, "committer": null, "parents": [{"sha": "25e9b6fe27d7665b70f22067411328f07e8ae9ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25e9b6fe27d7665b70f22067411328f07e8ae9ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25e9b6fe27d7665b70f22067411328f07e8ae9ff"}], "stats": {"total": 374, "additions": 165, "deletions": 209}, "files": [{"sha": "0e3fc2379a4c551896bf5950f9c8f9613bcc40f4", "filename": "gcc/ada/exp_smem.adb", "status": "modified", "additions": 60, "deletions": 166, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7052f54e6286b1e9e87e0f2eaf827dec15f3f2c2/gcc%2Fada%2Fexp_smem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7052f54e6286b1e9e87e0f2eaf827dec15f3f2c2/gcc%2Fada%2Fexp_smem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_smem.adb?ref=7052f54e6286b1e9e87e0f2eaf827dec15f3f2c2", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1998-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1998-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -71,21 +71,39 @@ package body Exp_Smem is\n    --  OUT or IN OUT parameter to a procedure call. If the result is\n    --  True, then Insert_Node is set to point to the call.\n \n+   function Build_Shared_Var_Proc_Call\n+     (Loc : Source_Ptr;\n+      E   : Node_Id;\n+      N   : Name_Id) return Node_Id;\n+   --  Build a call to support procedure N for shared object E (provided by\n+   --  the instance of System.Shared_Storage.Shared_Var_Procs associated to E).\n+\n+   --------------------------------\n+   -- Build_Shared_Var_Proc_Call --\n+   --------------------------------\n+\n+   function Build_Shared_Var_Proc_Call\n+     (Loc : Source_Ptr;\n+      E   : Entity_Id;\n+      N   : Name_Id) return Node_Id is\n+   begin\n+      return Make_Procedure_Call_Statement (Loc,\n+        Name => Make_Selected_Component (Loc,\n+          Prefix        =>\n+            New_Occurrence_Of (Shared_Var_Procs_Instance (E), Loc),\n+          Selector_Name => Make_Identifier (Loc, Chars => N)));\n+   end Build_Shared_Var_Proc_Call;\n+\n    ---------------------\n    -- Add_Read_Before --\n    ---------------------\n \n    procedure Add_Read_Before (N : Node_Id) is\n       Loc : constant Source_Ptr := Sloc (N);\n       Ent : constant Node_Id    := Entity (N);\n-\n    begin\n-      if Present (Shared_Var_Read_Proc (Ent)) then\n-         Insert_Action (N,\n-           Make_Procedure_Call_Statement (Loc,\n-             Name =>\n-               New_Occurrence_Of (Shared_Var_Read_Proc (Ent), Loc),\n-             Parameter_Associations => Empty_List));\n+      if Present (Shared_Var_Procs_Instance (Ent)) then\n+         Insert_Action (N, Build_Shared_Var_Proc_Call (Loc, Ent, Name_Read));\n       end if;\n    end Add_Read_Before;\n \n@@ -134,8 +152,7 @@ package body Exp_Smem is\n       --  Now, right after the Lock, insert a call to read the object\n \n       Insert_Before_And_Analyze (Inode,\n-        Make_Procedure_Call_Statement (Loc,\n-          Name => New_Occurrence_Of (Shared_Var_Read_Proc (Obj), Loc)));\n+        Build_Shared_Var_Proc_Call (Loc, Obj, Name_Read));\n \n       --  Now insert the Unlock call after\n \n@@ -150,8 +167,7 @@ package body Exp_Smem is\n \n       if Nkind (N) = N_Procedure_Call_Statement then\n          Insert_After_And_Analyze (Inode,\n-           Make_Procedure_Call_Statement (Loc,\n-             Name => New_Occurrence_Of (Shared_Var_Assign_Proc (Obj), Loc)));\n+           Build_Shared_Var_Proc_Call (Loc, Obj, Name_Write));\n       end if;\n \n    end Add_Shared_Var_Lock_Procs;\n@@ -165,12 +181,9 @@ package body Exp_Smem is\n       Ent : constant Node_Id    := Entity (N);\n \n    begin\n-      if Present (Shared_Var_Assign_Proc (Ent)) then\n+      if Present (Shared_Var_Procs_Instance (Ent)) then\n          Insert_After_And_Analyze (Insert_Node,\n-           Make_Procedure_Call_Statement (Loc,\n-             Name =>\n-               New_Occurrence_Of (Shared_Var_Assign_Proc (Ent), Loc),\n-             Parameter_Associations => Empty_List));\n+           Build_Shared_Var_Proc_Call (Loc, Ent, Name_Write));\n       end if;\n    end Add_Write_After;\n \n@@ -276,171 +289,52 @@ package body Exp_Smem is\n       Ent : constant Entity_Id  := Defining_Identifier (N);\n       Typ : constant Entity_Id  := Etype (Ent);\n       Vnm : String_Id;\n-      Atr : Node_Id;\n \n       After : constant Node_Id := Next (N);\n       --  Node located right after N originally (after insertion of the SV\n       --  procs this node is right after the last inserted node).\n \n-      Assign_Proc : constant Entity_Id :=\n-                      Make_Defining_Identifier (Loc,\n-                        Chars => New_External_Name (Chars (Ent), 'A'));\n-\n-      Read_Proc : constant Entity_Id :=\n-                    Make_Defining_Identifier (Loc,\n-                      Chars => New_External_Name (Chars (Ent), 'R'));\n+      SVP_Instance : constant Entity_Id := Make_Defining_Identifier (Loc,\n+                       Chars => New_External_Name (Chars (Ent), 'G'));\n+      --  Instance of System.Shared_Storage.Shared_Var_Procs associated\n+      --  with Ent.\n \n-      S : Entity_Id;\n+      Instantiation : Node_Id;\n+      --  Package instanciation node for SVP_Instance\n \n    --  Start of processing for Make_Shared_Var_Procs\n \n    begin\n       Build_Full_Name (Ent, Vnm);\n \n       --  We turn off Shared_Passive during construction and analysis of\n-      --  the assign and read routines, to avoid improper attempts to\n-      --  process the variable references within these procedures.\n+      --  the generic package instantition, to avoid improper attempts to\n+      --  process the variable references within these instantiation.\n \n       Set_Is_Shared_Passive (Ent, False);\n \n-      --  Construct assignment routine\n-\n-      --    procedure VarA is\n-      --       S : Ada.Streams.Stream_IO.Stream_Access;\n-      --    begin\n-      --       S := Shared_Var_WOpen (\"pkg.var\");\n-      --       typ'Write (S, var);\n-      --       Shared_Var_Close (S);\n-      --    end VarA;\n-\n-      S   := Make_Defining_Identifier (Loc, Name_uS);\n-\n-      Atr :=\n-        Make_Attribute_Reference (Loc,\n-          Prefix => New_Occurrence_Of (Typ, Loc),\n-          Attribute_Name => Name_Write,\n-          Expressions => New_List (\n-            New_Reference_To (S, Loc),\n-            New_Occurrence_Of (Ent, Loc)));\n-\n-      Insert_After_And_Analyze (N,\n-        Make_Subprogram_Body (Loc,\n-          Specification =>\n-            Make_Procedure_Specification (Loc,\n-              Defining_Unit_Name => Assign_Proc),\n-\n-         --  S : Ada.Streams.Stream_IO.Stream_Access;\n-\n-          Declarations => New_List (\n-            Make_Object_Declaration (Loc,\n-              Defining_Identifier => S,\n-              Object_Definition =>\n-                New_Occurrence_Of (RTE (RE_Stream_Access), Loc))),\n-\n-          Handled_Statement_Sequence =>\n-            Make_Handled_Sequence_Of_Statements (Loc,\n-              Statements => New_List (\n-\n-               --  S := Shared_Var_WOpen (\"pkg.var\");\n-\n-                Make_Assignment_Statement (Loc,\n-                  Name => New_Reference_To (S, Loc),\n-                  Expression =>\n-                    Make_Function_Call (Loc,\n-                      Name =>\n-                        New_Occurrence_Of\n-                          (RTE (RE_Shared_Var_WOpen), Loc),\n-                      Parameter_Associations => New_List (\n-                        Make_String_Literal (Loc, Vnm)))),\n-\n-                Atr,\n-\n-               --  Shared_Var_Close (S);\n-\n-                Make_Procedure_Call_Statement (Loc,\n-                  Name =>\n-                    New_Occurrence_Of (RTE (RE_Shared_Var_Close), Loc),\n-                  Parameter_Associations =>\n-                    New_List (New_Reference_To (S, Loc)))))));\n-\n-      --  Construct read routine\n-\n-      --    procedure varR is\n-      --       S : Ada.Streams.Stream_IO.Stream_Access;\n-      --    begin\n-      --       S := Shared_Var_ROpen (\"pkg.var\");\n-      --       if S /= null then\n-      --          typ'Read (S, Var);\n-      --          Shared_Var_Close (S);\n-      --       end if;\n-      --    end varR;\n-\n-      S   := Make_Defining_Identifier (Loc, Name_uS);\n-\n-      Atr :=\n-        Make_Attribute_Reference (Loc,\n-          Prefix => New_Occurrence_Of (Typ, Loc),\n-          Attribute_Name => Name_Read,\n-          Expressions => New_List (\n-            New_Reference_To (S, Loc),\n-            New_Occurrence_Of (Ent, Loc)));\n-\n-      Insert_After_And_Analyze (N,\n-        Make_Subprogram_Body (Loc,\n-          Specification =>\n-            Make_Procedure_Specification (Loc,\n-              Defining_Unit_Name => Read_Proc),\n-\n-         --  S : Ada.Streams.Stream_IO.Stream_Access;\n-\n-          Declarations => New_List (\n-            Make_Object_Declaration (Loc,\n-              Defining_Identifier => S,\n-              Object_Definition =>\n-                New_Occurrence_Of (RTE (RE_Stream_Access), Loc))),\n-\n-          Handled_Statement_Sequence =>\n-            Make_Handled_Sequence_Of_Statements (Loc,\n-              Statements => New_List (\n-\n-               --  S := Shared_Var_ROpen (\"pkg.var\");\n-\n-                Make_Assignment_Statement (Loc,\n-                  Name => New_Reference_To (S, Loc),\n-                  Expression =>\n-                    Make_Function_Call (Loc,\n-                      Name =>\n-                        New_Occurrence_Of\n-                          (RTE (RE_Shared_Var_ROpen), Loc),\n-                      Parameter_Associations => New_List (\n-                        Make_String_Literal (Loc, Vnm)))),\n-\n-               --  if S /= null then\n-\n-                Make_Implicit_If_Statement (N,\n-                  Condition =>\n-                    Make_Op_Ne (Loc,\n-                      Left_Opnd  => New_Reference_To (S, Loc),\n-                      Right_Opnd => Make_Null (Loc)),\n-\n-                   Then_Statements => New_List (\n-\n-                     --  typ'Read (S, Var);\n-\n-                     Atr,\n-\n-                     --  Shared_Var_Close (S);\n-\n-                     Make_Procedure_Call_Statement (Loc,\n-                       Name =>\n-                         New_Occurrence_Of\n-                           (RTE (RE_Shared_Var_Close), Loc),\n-                       Parameter_Associations =>\n-                         New_List (New_Reference_To (S, Loc)))))))));\n-\n-      Set_Is_Shared_Passive      (Ent, True);\n-      Set_Shared_Var_Assign_Proc (Ent, Assign_Proc);\n-      Set_Shared_Var_Read_Proc   (Ent, Read_Proc);\n+      --  Construct generic package instantiation\n+\n+      --  package varG is new Shared_Var_Procs (Typ, var, \"pkg.var\");\n+\n+      Instantiation :=\n+        Make_Package_Instantiation (Loc,\n+          Defining_Unit_Name   => SVP_Instance,\n+          Name                 =>\n+            New_Occurrence_Of (RTE (RE_Shared_Var_Procs), Loc),\n+          Generic_Associations => New_List (\n+            Make_Generic_Association (Loc, Explicit_Generic_Actual_Parameter =>\n+              New_Occurrence_Of (Typ, Loc)),\n+            Make_Generic_Association (Loc, Explicit_Generic_Actual_Parameter =>\n+              New_Occurrence_Of (Ent, Loc)),\n+            Make_Generic_Association (Loc, Explicit_Generic_Actual_Parameter =>\n+              Make_String_Literal (Loc, Vnm))));\n+\n+      Insert_After_And_Analyze (N, Instantiation);\n+\n+      Set_Is_Shared_Passive (Ent, True);\n+      Set_Shared_Var_Procs_Instance\n+        (Ent, Defining_Entity (Instance_Spec (Instantiation)));\n \n       --  Return last node before After\n "}, {"sha": "d1738255187e66f042ad38d81d054e48c2f768c0", "filename": "gcc/ada/exp_smem.ads", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7052f54e6286b1e9e87e0f2eaf827dec15f3f2c2/gcc%2Fada%2Fexp_smem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7052f54e6286b1e9e87e0f2eaf827dec15f3f2c2/gcc%2Fada%2Fexp_smem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_smem.ads?ref=7052f54e6286b1e9e87e0f2eaf827dec15f3f2c2", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1998-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1998-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -49,10 +49,11 @@ package Exp_Smem is\n    --  read/write calls for the protected object within the lock region.\n \n    function Make_Shared_Var_Procs (N : Node_Id) return Node_Id;\n-   --  N is the node for the declaration of a shared passive variable. This\n-   --  procedure constructs and inserts the read and assignment procedures\n-   --  for the shared memory variable. See System.Shared_Storage for a full\n-   --  description of these procedures and how they are used. The last inserted\n-   --  node is returned.\n+   --  N is the node for the declaration of a shared passive variable.\n+   --  This procedure constructs an instantiation of\n+   --  System.Shared_Storage.Shared_Var_Procs that contains the read and\n+   --  assignment procedures for the shared memory variable.\n+   --  See System.Shared_Storage for a full description of these procedures\n+   --  and how they are used. The last inserted node is returned.\n \n end Exp_Smem;"}, {"sha": "83f745499e252d4c6063dc3680c7db08a4055f42", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7052f54e6286b1e9e87e0f2eaf827dec15f3f2c2/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7052f54e6286b1e9e87e0f2eaf827dec15f3f2c2/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=7052f54e6286b1e9e87e0f2eaf827dec15f3f2c2", "patch": "@@ -83,7 +83,7 @@ package Rtsfind is\n \n    --    Names of the form System_Tasking_xxx are second level children of the\n    --    package System.Tasking. For example, System_Tasking_Stages refers to\n-   --    refers to the package System.Tasking.Stages.\n+   --    the package System.Tasking.Stages.\n \n    --    Other names stand for themselves (e.g. System for package System)\n \n@@ -1255,6 +1255,7 @@ package Rtsfind is\n      RE_Shared_Var_ROpen,                -- System.Shared_Storage\n      RE_Shared_Var_Unlock,               -- System.Shared_Storage\n      RE_Shared_Var_WOpen,                -- System.Shared_Storage\n+     RE_Shared_Var_Procs,                -- System.Shared_Storage\n \n      RE_Abort_Undefer_Direct,            -- System.Standard_Library\n      RE_Exception_Code,                  -- System.Standard_Library\n@@ -2382,6 +2383,7 @@ package Rtsfind is\n      RE_Shared_Var_ROpen                 => System_Shared_Storage,\n      RE_Shared_Var_Unlock                => System_Shared_Storage,\n      RE_Shared_Var_WOpen                 => System_Shared_Storage,\n+     RE_Shared_Var_Procs                 => System_Shared_Storage,\n \n      RE_Abort_Undefer_Direct             => System_Standard_Library,\n      RE_Exception_Code                   => System_Standard_Library,"}, {"sha": "c4ef8628c0b6a6e00c2eb5bb5ec21c791caf9214", "filename": "gcc/ada/s-shasto.adb", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7052f54e6286b1e9e87e0f2eaf827dec15f3f2c2/gcc%2Fada%2Fs-shasto.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7052f54e6286b1e9e87e0f2eaf827dec15f3f2c2/gcc%2Fada%2Fs-shasto.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-shasto.adb?ref=7052f54e6286b1e9e87e0f2eaf827dec15f3f2c2", "patch": "@@ -6,8 +6,8 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1998-2007, Free Software Foundation, Inc.         --\n---                                                                          --\n+--          Copyright (C) 1998-2008, Free Software Foundation, Inc.         --\n+--                                                                         --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n -- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n@@ -363,6 +363,43 @@ package body System.Shared_Storage is\n          raise;\n    end Shared_Var_Lock;\n \n+   ----------------------\n+   -- Shared_Var_Procs --\n+   ----------------------\n+\n+   package body Shared_Var_Procs is\n+\n+      use type SIO.Stream_Access;\n+\n+      ----------\n+      -- Read --\n+      ----------\n+\n+      procedure Read is\n+         S : SIO.Stream_Access := null;\n+      begin\n+         S := Shared_Var_ROpen (Full_Name);\n+         if S /= null then\n+            Typ'Read (S, V);\n+            Shared_Var_Close (S);\n+         end if;\n+      end Read;\n+\n+      ------------\n+      -- Write --\n+      ------------\n+\n+      procedure Write is\n+         S : SIO.Stream_Access := null;\n+      begin\n+         S := Shared_Var_WOpen (Full_Name);\n+         Typ'Write (S, V);\n+         Shared_Var_Close (S);\n+         return;\n+      end Write;\n+\n+   end Shared_Var_Procs;\n+\n    ----------------------\n    -- Shared_Var_ROpen --\n    ----------------------"}, {"sha": "8046fd5b2f601f780c7eb9e207733098b8afa49f", "filename": "gcc/ada/s-shasto.ads", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7052f54e6286b1e9e87e0f2eaf827dec15f3f2c2/gcc%2Fada%2Fs-shasto.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7052f54e6286b1e9e87e0f2eaf827dec15f3f2c2/gcc%2Fada%2Fs-shasto.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-shasto.ads?ref=7052f54e6286b1e9e87e0f2eaf827dec15f3f2c2", "patch": "@@ -79,48 +79,18 @@\n \n --  The approach is as follows:\n \n---    For each shared variable, var, an access routine varR is created whose\n---    body has the following form (this example is for Pkg.Var):\n-\n---      procedure varR is\n---         S : Ada.Streams.Stream_IO.Stream_Access;\n---      begin\n---         S := Shared_Var_ROpen (\"pkg.var\");\n---         if S /= null then\n---            typ'Read (S);\n---            Shared_Var_Close (S);\n---         end if;\n---      end varR;\n+--    For each shared variable, var, an instanciation of the below generic\n+--    package is created which provides Read and Write supporting procedures.\n \n --    The routine Shared_Var_ROpen in package System.Shared_Storage\n --    either returns null if the storage does not exist, or otherwise a\n --    Stream_Access value that references the corresponding shared\n --    storage, ready to read the current value.\n \n---    Each reference to the shared variable, var, is preceded by a\n---    call to the corresponding varR procedure, which either leaves the\n---    initial value unchanged if the storage does not exist, or reads\n---    the current value from the shared storage.\n-\n---    In addition, for each shared variable, var, an assignment routine\n---    is created whose body has the following form (again for Pkg.Var)\n-\n---      procedure VarA is\n---         S : Ada.Streams.Stream_IO.Stream_Access;\n---      begin\n---         S := Shared_Var_WOpen (\"pkg.var\");\n---         typ'Write (S, var);\n---         Shared_Var_Close (S);\n---      end VarA;\n-\n --    The routine Shared_Var_WOpen in package System.Shared_Storage\n --    returns a Stream_Access value that references the corresponding\n --    shared storage, ready to write the new value.\n \n---    Each assignment to the shared variable, var, is followed by a call\n---    to the corresponding varA procedure, which writes the new value to\n---    the shared storage.\n-\n --    Note that there is no general synchronization for these storage\n --    read and write operations, since it is assumed that a correctly\n --    operating programs will provide appropriate synchronization. In\n@@ -219,4 +189,35 @@ package System.Shared_Storage is\n    --  generated as the last operation in the body of a protected\n    --  subprogram.\n \n+   --  This generic package is instantiated for each shared passive\n+   --  variable. It provides supporting procedures called upon each\n+   --  read or write access by the expanded code.\n+\n+   generic\n+\n+      type Typ is limited private;\n+      --  Shared passive variable type\n+\n+      V : in out Typ;\n+      --  Shared passive variable\n+\n+      Full_Name : String;\n+      --  Shared passive variable storage name\n+\n+   package Shared_Var_Procs is\n+\n+      procedure Read;\n+      --  Shared passive variable access routine. Each reference to the\n+      --  shared variable, V, is preceded by a call to the corresponding\n+      --  Read procedure, which either leaves the initial value unchanged\n+      --  if the storage does not exist, or reads the current value from\n+      --  the shared storage.\n+\n+      procedure Write;\n+      --  Shared passive variable assignement routine. Each assignment to\n+      --  the shared variable, V, is followed by a call to the corresponding\n+      --  Write procedure, which writes the new value to the shared storage.\n+\n+   end Shared_Var_Procs;\n+\n end System.Shared_Storage;"}, {"sha": "c2536dfc70c08e5069806363d2cac31b7a65cb4e", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7052f54e6286b1e9e87e0f2eaf827dec15f3f2c2/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7052f54e6286b1e9e87e0f2eaf827dec15f3f2c2/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=7052f54e6286b1e9e87e0f2eaf827dec15f3f2c2", "patch": "@@ -1278,7 +1278,8 @@ package body Sem_Attr is\n            and then Convention (Etype (P)) = Convention_CPP\n            and then Is_CPP_Class (Root_Type (Etype (P)))\n          then\n-            Error_Attr_P (\"invalid use of % attribute with CPP tagged type\");\n+            Error_Attr_P\n+              (\"invalid use of % attribute with 'C'P'P tagged type\");\n          end if;\n       end Check_Not_CPP_Type;\n \n@@ -1459,6 +1460,14 @@ package body Sem_Attr is\n          Etyp : Entity_Id;\n          Btyp : Entity_Id;\n \n+         In_Shared_Var_Procs : Boolean;\n+         --  True when compiling the body of System.Shared_Storage.\n+         --  Shared_Var_Procs. For this runtime package (always compiled in\n+         --  GNAT mode), we allow stream attributes references for limited\n+         --  types for the case where shared passive objects are implemented\n+         --  using stream attributes, which is the default in GNAT's persistent\n+         --  storage implementation.\n+\n       begin\n          Validate_Non_Static_Attribute_Function_Call;\n \n@@ -1492,7 +1501,19 @@ package body Sem_Attr is\n          --  in Ada 2005 mode), or a pragma Stream_Convert applies to Btyp\n          --  (with no visibility restriction).\n \n-         if Comes_From_Source (N)\n+         declare\n+            Gen_Body : constant Node_Id := Enclosing_Generic_Body (N);\n+         begin\n+            if Present (Gen_Body) then\n+               In_Shared_Var_Procs :=\n+                 Is_RTE (Corresponding_Spec (Gen_Body), RE_Shared_Var_Procs);\n+            else\n+               In_Shared_Var_Procs := False;\n+            end if;\n+         end;\n+\n+         if (Comes_From_Source (N)\n+              and then not (In_Shared_Var_Procs or In_Instance))\n            and then not Stream_Attribute_Available (P_Type, Nam)\n            and then not Has_Rep_Pragma (Btyp, Name_Stream_Convert)\n          then"}]}