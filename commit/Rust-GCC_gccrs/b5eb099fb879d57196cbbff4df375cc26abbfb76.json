{"sha": "b5eb099fb879d57196cbbff4df375cc26abbfb76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjVlYjA5OWZiODc5ZDU3MTk2Y2JiZmY0ZGYzNzVjYzI2YWJiZmI3Ng==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2010-02-06T17:41:34Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2010-02-06T17:41:34Z"}, "message": "Correct the lexicographical function, add debug_pddr.\n\n2010-02-03  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* graphite-dependences.c (new_poly_ddr): Initialize PDDR_KIND and\n\tPDDR_ORIGINAL_SCATTERING_P.\n\t(pddr_is_empty): Rewritten.\n\t(print_dependence_polyhedron_layout): New.\n\t(print_pddr): New.\n\t(debug_pddr): New.\n\t(build_alias_set_powerset): Moved up.\n\t(poly_drs_may_alias_p): Moved up.\n\t(lexicographically_gt_p): Removed.\n\t(build_lexicographically_gt_constraint): Renamed\n\tbuild_lexicographical_constraint, reimplemented.\n\t(dependence_polyhedron_1): Simplified parameters.\n\t(dependence_polyhedron): Same.  Keep along empty PDDRs\n\tto make efficient use of the cache.\n\t(reduction_dr_p): Compute the PBBs don't pass them as parameters.\n\t(graphite_legal_transform_dr): Rewritten.\n\t(graphite_legal_transform_bb): Pass fewer arguments to\n\tgraphite_legal_transform_dr.\n\t(graphite_carried_dependence_level_k): Simplified implementation.\n\t(dot_original_deps_stmt_1): Call dependence_polyhedron.\n\t(dot_transformed_deps_stmt_1): Same.\n\t(dot_original_deps): Same.\n\t(dot_transformed_deps): Same.\n\t* graphite-dependences.h (struct poly_ddr): Added a new field\n\toriginal_scattering_p.\n\t(PDDR_ORIGINAL_SCATTERING_P): New.\n\t(print_pddr): Declared.\n\t(debug_pddr): Declared.\n\t* graphite-ppl.c: Clarify comment.\n\t* sese.h (print_gimple_bb): Removed unused declaration.\n\t(debug_gbb): Same.\n\nFrom-SVN: r156549", "tree": {"sha": "c75100a7875f857044054981af1c320e82143a23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c75100a7875f857044054981af1c320e82143a23"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5eb099fb879d57196cbbff4df375cc26abbfb76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5eb099fb879d57196cbbff4df375cc26abbfb76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5eb099fb879d57196cbbff4df375cc26abbfb76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5eb099fb879d57196cbbff4df375cc26abbfb76/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64630e61332a2a9e9638668c41b79fba87c9f016", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64630e61332a2a9e9638668c41b79fba87c9f016", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64630e61332a2a9e9638668c41b79fba87c9f016"}], "stats": {"total": 627, "additions": 347, "deletions": 280}, "files": [{"sha": "c5d0efeb5aff38a27a5713099a7a3dd267f7532a", "filename": "gcc/ChangeLog.graphite", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5eb099fb879d57196cbbff4df375cc26abbfb76/gcc%2FChangeLog.graphite", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5eb099fb879d57196cbbff4df375cc26abbfb76/gcc%2FChangeLog.graphite", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.graphite?ref=b5eb099fb879d57196cbbff4df375cc26abbfb76", "patch": "@@ -1,3 +1,37 @@\n+2010-02-03  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* graphite-dependences.c (new_poly_ddr): Initialize PDDR_KIND and\n+\tPDDR_ORIGINAL_SCATTERING_P.\n+\t(pddr_is_empty): Rewritten.\n+\t(print_dependence_polyhedron_layout): New.\n+\t(print_pddr): New.\n+\t(debug_pddr): New.\n+\t(build_alias_set_powerset): Moved up.\n+\t(poly_drs_may_alias_p): Moved up.\n+\t(lexicographically_gt_p): Removed.\n+\t(build_lexicographically_gt_constraint): Renamed\n+\tbuild_lexicographical_constraint, reimplemented.\n+\t(dependence_polyhedron_1): Simplified parameters.\n+\t(dependence_polyhedron): Same.  Keep along empty PDDRs\n+\tto make efficient use of the cache.\n+\t(reduction_dr_p): Compute the PBBs don't pass them as parameters.\n+\t(graphite_legal_transform_dr): Rewritten.\n+\t(graphite_legal_transform_bb): Pass fewer arguments to\n+\tgraphite_legal_transform_dr.\n+\t(graphite_carried_dependence_level_k): Simplified implementation.\n+\t(dot_original_deps_stmt_1): Call dependence_polyhedron.\n+\t(dot_transformed_deps_stmt_1): Same.\n+\t(dot_original_deps): Same.\n+\t(dot_transformed_deps): Same.\n+\t* graphite-dependences.h (struct poly_ddr): Added a new field\n+\toriginal_scattering_p.\n+\t(PDDR_ORIGINAL_SCATTERING_P): New.\n+\t(print_pddr): Declared.\n+\t(debug_pddr): Declared.\n+\t* graphite-ppl.c: Clarify comment.\n+\t* sese.h (print_gimple_bb): Removed unused declaration.\n+\t(debug_gbb): Same.\n+\n 2010-02-03  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* testsuite/g++.dg/graphite/graphite.exp: Rewritten."}, {"sha": "a6a7e57596da5e6f43f59890467ee7927abd740c", "filename": "gcc/graphite-dependences.c", "status": "modified", "additions": 304, "deletions": 276, "changes": 580, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5eb099fb879d57196cbbff4df375cc26abbfb76/gcc%2Fgraphite-dependences.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5eb099fb879d57196cbbff4df375cc26abbfb76/gcc%2Fgraphite-dependences.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-dependences.c?ref=b5eb099fb879d57196cbbff4df375cc26abbfb76", "patch": "@@ -51,20 +51,26 @@ along with GCC; see the file COPYING3.  If not see\n #include \"graphite-dependences.h\"\n \n /* Returns a new polyhedral Data Dependence Relation (DDR).  SOURCE is\n-   the source data reference, SINK is the sink data reference.  SOURCE\n-   and SINK define an edge in the Data Dependence Graph (DDG).  */\n+   the source data reference, SINK is the sink data reference.  When\n+   the Data Dependence Polyhedron DDP is not NULL or not empty, SOURCE\n+   and SINK are in dependence as described by DDP.  */\n \n static poly_ddr_p\n new_poly_ddr (poly_dr_p source, poly_dr_p sink,\n-\t      ppl_Pointset_Powerset_C_Polyhedron_t ddp)\n+\t      ppl_Pointset_Powerset_C_Polyhedron_t ddp,\n+\t      bool original_scattering_p)\n {\n-  poly_ddr_p pddr;\n+  poly_ddr_p pddr = XNEW (struct poly_ddr);\n \n-  pddr = XNEW (struct poly_ddr);\n   PDDR_SOURCE (pddr) = source;\n   PDDR_SINK (pddr) = sink;\n   PDDR_DDP (pddr) = ddp;\n-  PDDR_KIND (pddr) = unknown_dependence;\n+  PDDR_ORIGINAL_SCATTERING_P (pddr) = original_scattering_p;\n+\n+  if (!ddp || ppl_Pointset_Powerset_C_Polyhedron_is_empty (ddp))\n+    PDDR_KIND (pddr) = no_dependence;\n+  else\n+    PDDR_KIND (pddr) = has_dependence;\n \n   return pddr;\n }\n@@ -106,17 +112,161 @@ hash_poly_ddr_p (const void *pddr)\n static bool\n pddr_is_empty (poly_ddr_p pddr)\n {\n-  if (PDDR_KIND (pddr) != unknown_dependence)\n-    return PDDR_KIND (pddr) == no_dependence ? true : false;\n+  if (!pddr)\n+    return true;\n+\n+  gcc_assert (PDDR_KIND (pddr) != unknown_dependence);\n+\n+  return PDDR_KIND (pddr) == no_dependence ? true : false;\n+}\n+\n+/* Prints to FILE the layout of the dependence polyhedron of PDDR:\n+\n+   T1|I1|T2|I2|S1|S2|G\n+\n+   with\n+   | T1 and T2 the scattering dimensions for PDDR_SOURCE and PDDR_SINK\n+   | I1 and I2 the iteration domains\n+   | S1 and S2 the subscripts\n+   | G the global parameters.  */\n+\n+static void\n+print_dependence_polyhedron_layout (FILE *file, poly_ddr_p pddr)\n+{\n+  poly_dr_p pdr1 = PDDR_SOURCE (pddr);\n+  poly_dr_p pdr2 = PDDR_SINK (pddr);\n+  poly_bb_p pbb1 = PDR_PBB (pdr1);\n+  poly_bb_p pbb2 = PDR_PBB (pdr2);\n+\n+  graphite_dim_t i;\n+  graphite_dim_t tdim1 = PDDR_ORIGINAL_SCATTERING_P (pddr) ?\n+    pbb_nb_scattering_orig (pbb1) : pbb_nb_scattering_transform (pbb1);\n+  graphite_dim_t tdim2 = PDDR_ORIGINAL_SCATTERING_P (pddr) ?\n+    pbb_nb_scattering_orig (pbb2) : pbb_nb_scattering_transform (pbb2);\n+  graphite_dim_t idim1 = pbb_dim_iter_domain (pbb1);\n+  graphite_dim_t idim2 = pbb_dim_iter_domain (pbb2);\n+  graphite_dim_t sdim1 = PDR_NB_SUBSCRIPTS (pdr1) + 1;\n+  graphite_dim_t sdim2 = PDR_NB_SUBSCRIPTS (pdr2) + 1;\n+  graphite_dim_t gdim = scop_nb_params (PBB_SCOP (pbb1));\n+\n+  fprintf (file, \"#  eq\");\n+\n+  for (i = 0; i < tdim1; i++)\n+    fprintf (file, \"   t1_%d\", (int) i);\n+  for (i = 0; i < idim1; i++)\n+    fprintf (file, \"   i1_%d\", (int) i);\n+  for (i = 0; i < tdim2; i++)\n+    fprintf (file, \"   t2_%d\", (int) i);\n+  for (i = 0; i < idim2; i++)\n+    fprintf (file, \"   i2_%d\", (int) i);\n+  for (i = 0; i < sdim1; i++)\n+    fprintf (file, \"   s1_%d\", (int) i);\n+  for (i = 0; i < sdim2; i++)\n+    fprintf (file, \"   s2_%d\", (int) i);\n+  for (i = 0; i < gdim; i++)\n+    fprintf (file, \"    g_%d\", (int) i);\n+\n+  fprintf (file, \"    cst\\n\");\n+}\n+\n+/* Prints to FILE the poly_ddr_p PDDR.  */\n+\n+void\n+print_pddr (FILE *file, poly_ddr_p pddr)\n+{\n+  fprintf (file, \"pddr (kind: \");\n+\n+  if (PDDR_KIND (pddr) == unknown_dependence)\n+    fprintf (file, \"unknown_dependence\");\n+  else if (PDDR_KIND (pddr) == no_dependence)\n+    fprintf (file, \"no_dependence\");\n+  else if (PDDR_KIND (pddr) == has_dependence)\n+    fprintf (file, \"has_dependence\");\n \n-  if (ppl_Pointset_Powerset_C_Polyhedron_is_empty (PDDR_DDP (pddr)))\n+  fprintf (file, \"\\n  source \");\n+  print_pdr (file, PDDR_SOURCE (pddr));\n+\n+  fprintf (file, \"\\n  sink \");\n+  print_pdr (file, PDDR_SINK (pddr));\n+\n+  if (PDDR_KIND (pddr) == has_dependence)\n     {\n-      PDDR_KIND (pddr) = no_dependence;\n-      return true;\n+      fprintf (file, \"\\n  dependence polyhedron (\\n\");\n+      print_dependence_polyhedron_layout (file, pddr);\n+      ppl_print_powerset_matrix (file, PDDR_DDP (pddr));\n+      fprintf (file, \")\\n\");\n     }\n \n-  PDDR_KIND (pddr) = has_dependence;\n-  return false;\n+  fprintf (file, \")\\n\");\n+}\n+\n+/* Prints to STDERR the poly_ddr_p PDDR.  */\n+\n+void\n+debug_pddr (poly_ddr_p pddr)\n+{\n+  print_pddr (stderr, pddr);\n+}\n+\n+\n+/* Remove all the dimensions except alias information at dimension\n+   ALIAS_DIM.  */\n+\n+static void\n+build_alias_set_powerset (ppl_Pointset_Powerset_C_Polyhedron_t alias_powerset,\n+\t\t\t  ppl_dimension_type alias_dim)\n+{\n+  ppl_dimension_type *ds;\n+  ppl_dimension_type access_dim;\n+  unsigned i, pos = 0;\n+\n+  ppl_Pointset_Powerset_C_Polyhedron_space_dimension (alias_powerset,\n+\t\t\t\t\t\t      &access_dim);\n+  ds = XNEWVEC (ppl_dimension_type, access_dim-1);\n+  for (i = 0; i < access_dim; i++)\n+    {\n+      if (i == alias_dim)\n+\tcontinue;\n+\n+      ds[pos] = i;\n+      pos++;\n+    }\n+\n+  ppl_Pointset_Powerset_C_Polyhedron_remove_space_dimensions (alias_powerset,\n+\t\t\t\t\t\t\t      ds,\n+\t\t\t\t\t\t\t      access_dim - 1);\n+  free (ds);\n+}\n+\n+/* Return true when PDR1 and PDR2 may alias.  */\n+\n+static bool\n+poly_drs_may_alias_p (poly_dr_p pdr1, poly_dr_p pdr2)\n+{\n+  ppl_Pointset_Powerset_C_Polyhedron_t alias_powerset1, alias_powerset2;\n+  ppl_Pointset_Powerset_C_Polyhedron_t accesses1 = PDR_ACCESSES (pdr1);\n+  ppl_Pointset_Powerset_C_Polyhedron_t accesses2 = PDR_ACCESSES (pdr2);\n+  ppl_dimension_type alias_dim1 = pdr_alias_set_dim (pdr1);\n+  ppl_dimension_type alias_dim2 = pdr_alias_set_dim (pdr2);\n+  int empty_p;\n+\n+  ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron\n+    (&alias_powerset1, accesses1);\n+  ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron\n+    (&alias_powerset2, accesses2);\n+\n+  build_alias_set_powerset (alias_powerset1, alias_dim1);\n+  build_alias_set_powerset (alias_powerset2, alias_dim2);\n+\n+  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign\n+    (alias_powerset1, alias_powerset2);\n+\n+  empty_p = ppl_Pointset_Powerset_C_Polyhedron_is_empty (alias_powerset1);\n+\n+  ppl_delete_Pointset_Powerset_C_Polyhedron (alias_powerset1);\n+  ppl_delete_Pointset_Powerset_C_Polyhedron (alias_powerset2);\n+\n+  return !empty_p;\n }\n \n /* Returns a polyhedron of dimension DIM.\n@@ -262,33 +412,6 @@ build_pairwise_scheduling (graphite_dim_t dim,\n   return res;\n }\n \n-/* Returns true when adding to the RES dependence polyhedron the\n-   lexicographical constraint: \"DIM compared to DIM + OFFSET\" returns\n-   an empty polyhedron.  The comparison depends on DIRECTION as: if\n-   DIRECTION is equal to -1, the first dimension DIM to be compared\n-   comes before the second dimension DIM + OFFSET, equal to 0 when DIM\n-   and DIM + OFFSET are equal, and DIRECTION is set to 1 when DIM\n-   comes after DIM + OFFSET.  */\n-\n-static bool\n-lexicographically_gt_p (ppl_Pointset_Powerset_C_Polyhedron_t res,\n-\t\t\tgraphite_dim_t dim,\n-\t\t\tgraphite_dim_t offset,\n-\t\t\tint direction, graphite_dim_t i)\n-{\n-  ppl_Pointset_Powerset_C_Polyhedron_t ineq;\n-  bool empty_p;\n-\n-  ineq = build_pairwise_scheduling (dim, i, offset, direction);\n-  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (ineq, res);\n-  empty_p = ppl_Pointset_Powerset_C_Polyhedron_is_empty (ineq);\n-  if (!empty_p)\n-    ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (res, ineq);\n-  ppl_delete_Pointset_Powerset_C_Polyhedron (ineq);\n-\n-  return !empty_p;\n-}\n-\n /* Add to a non empty polyhedron RES the precedence constraints for\n    the lexicographical comparison of time vectors in RES following the\n    lexicographical order.  DIM is the dimension of the polyhedron RES.\n@@ -302,36 +425,45 @@ lexicographically_gt_p (ppl_Pointset_Powerset_C_Polyhedron_t res,\n    PDR2 to PDR1.  */\n \n static void\n-build_lexicographically_gt_constraint (ppl_Pointset_Powerset_C_Polyhedron_t *res,\n-\t\t\t\t       graphite_dim_t dim,\n-\t\t\t\t       graphite_dim_t tdim,\n-\t\t\t\t       graphite_dim_t offset,\n-\t\t\t\t       int direction)\n+build_lexicographical_constraint (ppl_Pointset_Powerset_C_Polyhedron_t *res,\n+\t\t\t\t  graphite_dim_t dim,\n+\t\t\t\t  graphite_dim_t tdim,\n+\t\t\t\t  graphite_dim_t offset,\n+\t\t\t\t  int direction)\n {\n   graphite_dim_t i;\n \n-  if (lexicographically_gt_p (*res, dim, offset, direction, 0))\n-    return;\n-\n-  for (i = 0; i < tdim - 1; i++)\n+  for (i = 0; i < tdim - 1; i+=2)\n     {\n-      ppl_Pointset_Powerset_C_Polyhedron_t sceq;\n+      ppl_Pointset_Powerset_C_Polyhedron_t ineq;\n+      bool empty_p;\n \n-      /* All the dimensions up to I are equal, ...  */\n-      sceq = build_pairwise_scheduling (dim, i, offset, 0);\n-      ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (*res, sceq);\n-      ppl_delete_Pointset_Powerset_C_Polyhedron (sceq);\n+      /* Identify the static schedule dimensions.  */\n+      ineq = build_pairwise_scheduling (dim, i, offset, 0);\n+      ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (ineq, *res);\n+      empty_p = ppl_Pointset_Powerset_C_Polyhedron_is_empty (ineq);\n \n-      /* ... and at depth I+1 they are not equal anymore.  */\n-      if (lexicographically_gt_p (*res, dim, offset, direction, i + 1))\n-\treturn;\n-    }\n+      if (empty_p)\n+\t{\n+\t  /* Add the lexicographical dynamic schedule dimension.  */\n+\t  if (i > 0)\n+\t    ineq = build_pairwise_scheduling (dim, i - 1, offset, direction);\n \n-  if (i == tdim - 1)\n-    {\n-      ppl_delete_Pointset_Powerset_C_Polyhedron (*res);\n-      ppl_new_Pointset_Powerset_C_Polyhedron_from_space_dimension (res, dim, 1);\n+\t  return;\n+\t}\n+\n+      ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (*res, ineq);\n+      ppl_delete_Pointset_Powerset_C_Polyhedron (ineq);\n+\n+      /* Identify the dynamic schedule dimensions.  */\n+      ineq = build_pairwise_scheduling (dim, i + 1, offset, 0);\n+      ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (*res, ineq);\n+      ppl_delete_Pointset_Powerset_C_Polyhedron (ineq);\n     }\n+\n+  /* There is no dependence.  */\n+  ppl_delete_Pointset_Powerset_C_Polyhedron (*res);\n+  ppl_new_Pointset_Powerset_C_Polyhedron_from_space_dimension (res, dim, 1);\n }\n \n /* Build the dependence polyhedron for data references PDR1 and PDR2.\n@@ -345,31 +477,27 @@ build_lexicographically_gt_constraint (ppl_Pointset_Powerset_C_Polyhedron_t *res\n    | S1 and S2 the subscripts\n    | G the global parameters.\n \n-   D1 and D2 are the iteration domains of PDR1 and PDR2.\n-\n-   SCAT1 and SCAT2 are the scattering polyhedra for PDR1 and PDR2.\n-   When ORIGINAL_SCATTERING_P is true, then the scattering polyhedra\n-   SCAT1 and SCAT2 correspond to the original scattering of the\n-   program, otherwise they correspond to the transformed scattering.\n-\n    When DIRECTION is set to 1, compute the direct dependence from PDR1\n    to PDR2, and when DIRECTION is -1, compute the reversed dependence\n    relation, from PDR2 to PDR1.  */\n \n-static poly_ddr_p\n-dependence_polyhedron_1 (poly_bb_p pbb1, poly_bb_p pbb2,\n-\t\t         ppl_Pointset_Powerset_C_Polyhedron_t d1,\n-\t\t         ppl_Pointset_Powerset_C_Polyhedron_t d2,\n-\t\t         poly_dr_p pdr1, poly_dr_p pdr2,\n-\t                 ppl_Polyhedron_t scat1, ppl_Polyhedron_t scat2,\n-\t\t         int direction,\n-\t\t         bool original_scattering_p)\n+static ppl_Pointset_Powerset_C_Polyhedron_t\n+dependence_polyhedron_1 (poly_dr_p pdr1, poly_dr_p pdr2,\n+\t\t         int direction, bool original_scattering_p)\n {\n+  poly_bb_p pbb1 = PDR_PBB (pdr1);\n+  poly_bb_p pbb2 = PDR_PBB (pdr2);\n   scop_p scop = PBB_SCOP (pbb1);\n+  ppl_Pointset_Powerset_C_Polyhedron_t d1 = PBB_DOMAIN (pbb1);\n+  ppl_Pointset_Powerset_C_Polyhedron_t d2 = PBB_DOMAIN (pbb2);\n   graphite_dim_t tdim1 = original_scattering_p ?\n     pbb_nb_scattering_orig (pbb1) : pbb_nb_scattering_transform (pbb1);\n   graphite_dim_t tdim2 = original_scattering_p ?\n     pbb_nb_scattering_orig (pbb2) : pbb_nb_scattering_transform (pbb2);\n+  ppl_Polyhedron_t scat1 = original_scattering_p ?\n+    PBB_ORIGINAL_SCATTERING (pbb1) : PBB_TRANSFORMED_SCATTERING (pbb1);\n+  ppl_Polyhedron_t scat2 = original_scattering_p ?\n+    PBB_ORIGINAL_SCATTERING (pbb2) : PBB_TRANSFORMED_SCATTERING (pbb2);\n   graphite_dim_t ddim1 = pbb_dim_iter_domain (pbb1);\n   graphite_dim_t ddim2 = pbb_dim_iter_domain (pbb2);\n   graphite_dim_t sdim1 = PDR_NB_SUBSCRIPTS (pdr1) + 1;\n@@ -425,94 +553,59 @@ dependence_polyhedron_1 (poly_bb_p pbb1, poly_bb_p pbb2,\n   ppl_delete_Pointset_Powerset_C_Polyhedron (dreq);\n \n   if (!ppl_Pointset_Powerset_C_Polyhedron_is_empty (res))\n-    build_lexicographically_gt_constraint (&res, dim, MIN (tdim1, tdim2),\n-\t\t\t\t\t   tdim1 + ddim1, direction);\n+    build_lexicographical_constraint (&res, dim, MIN (tdim1, tdim2),\n+\t\t\t\t      tdim1 + ddim1, direction);\n \n-  return new_poly_ddr (pdr1, pdr2, res);\n+  return res;\n }\n \n /* Build the dependence polyhedron for data references PDR1 and PDR2.\n    If possible use already cached information.\n \n-   D1 and D2 are the iteration domains of PDR1 and PDR2.\n-\n-   SCAT1 and SCAT2 are the scattering polyhedra for PDR1 and PDR2.\n-   When ORIGINAL_SCATTERING_P is true, then the scattering polyhedra\n-   SCAT1 and SCAT2 correspond to the original scattering of the\n-   program, otherwise they correspond to the transformed scattering.\n-\n    When DIRECTION is set to 1, compute the direct dependence from PDR1\n    to PDR2, and when DIRECTION is -1, compute the reversed dependence\n    relation, from PDR2 to PDR1.  */\n \n static poly_ddr_p\n-dependence_polyhedron (poly_bb_p pbb1, poly_bb_p pbb2,\n-\t\t       ppl_Pointset_Powerset_C_Polyhedron_t d1,\n-\t\t       ppl_Pointset_Powerset_C_Polyhedron_t d2,\n-\t\t       poly_dr_p pdr1, poly_dr_p pdr2,\n-\t               ppl_Polyhedron_t scat1, ppl_Polyhedron_t scat2,\n-\t\t       int direction,\n-\t\t       bool original_scattering_p)\n+dependence_polyhedron (poly_dr_p pdr1, poly_dr_p pdr2,\n+\t\t       int direction, bool original_scattering_p)\n {\n   PTR *x = NULL;\n   poly_ddr_p res;\n+  ppl_Pointset_Powerset_C_Polyhedron_t ddp;\n \n+  /* Return the PDDR from the cache if it already has been computed.  */\n   if (original_scattering_p)\n     {\n       struct poly_ddr tmp;\n+      scop_p scop = PBB_SCOP (PDR_PBB (pdr1));\n \n       tmp.source = pdr1;\n       tmp.sink = pdr2;\n-      x = htab_find_slot (SCOP_ORIGINAL_PDDRS (PBB_SCOP (pbb1)),\n+      x = htab_find_slot (SCOP_ORIGINAL_PDDRS (scop),\n                           &tmp, INSERT);\n \n       if (x && *x)\n \treturn (poly_ddr_p) *x;\n     }\n \n-  res = dependence_polyhedron_1 (pbb1, pbb2, d1, d2, pdr1, pdr2,\n-                                 scat1, scat2, direction, original_scattering_p);\n+  if ((pdr_read_p (pdr1) && pdr_read_p (pdr2))\n+      || PDR_BASE_OBJECT_SET (pdr1) != PDR_BASE_OBJECT_SET (pdr2)\n+      || PDR_NB_SUBSCRIPTS (pdr1) != PDR_NB_SUBSCRIPTS (pdr2)\n+      || !poly_drs_may_alias_p (pdr1, pdr2))\n+    ddp = NULL;\n+  else\n+    ddp = dependence_polyhedron_1 (pdr1, pdr2, direction,\n+\t\t\t\t   original_scattering_p);\n+\n+  res = new_poly_ddr (pdr1, pdr2, ddp, original_scattering_p);\n \n   if (original_scattering_p)\n     *x = res;\n \n   return res;\n }\n \n-/* Returns the Polyhedral Data Dependence Relation (PDDR) between PDR1\n-   contained in PBB1 and PDR2 contained in PBB2.  When\n-   ORIGINAL_SCATTERING_P is true, return the PDDR corresponding to the\n-   original scattering, or NULL if the dependence relation is empty.\n-   When ORIGINAL_SCATTERING_P is false, return the PDDR corresponding\n-   to the transformed scattering.  When DIRECTION is set to 1, compute\n-   the direct dependence from PDR1 to PDR2, and when DIRECTION is -1,\n-   compute the reversed dependence relation, from PDR2 to PDR1.  */\n-\n-static poly_ddr_p\n-build_pddr (poly_bb_p pbb1, poly_bb_p pbb2, poly_dr_p pdr1, poly_dr_p pdr2,\n-\t    int direction, bool original_scattering_p)\n-{\n-  poly_ddr_p pddr;\n-  ppl_Pointset_Powerset_C_Polyhedron_t d1 = PBB_DOMAIN (pbb1);\n-  ppl_Pointset_Powerset_C_Polyhedron_t d2 = PBB_DOMAIN (pbb2);\n-  ppl_Polyhedron_t scat1 = original_scattering_p ?\n-    PBB_ORIGINAL_SCATTERING (pbb1) : PBB_TRANSFORMED_SCATTERING (pbb1);\n-  ppl_Polyhedron_t scat2 = original_scattering_p ?\n-    PBB_ORIGINAL_SCATTERING (pbb2) : PBB_TRANSFORMED_SCATTERING (pbb2);\n-\n-  if ((pdr_read_p (pdr1) && pdr_read_p (pdr2))\n-      || PDR_BASE_OBJECT_SET (pdr1) != PDR_BASE_OBJECT_SET (pdr2)\n-      || PDR_NB_SUBSCRIPTS (pdr1) != PDR_NB_SUBSCRIPTS (pdr2))\n-    return NULL;\n-\n-  pddr = dependence_polyhedron (pbb1, pbb2, d1, d2, pdr1, pdr2, scat1, scat2,\n-\t\t\t\tdirection, original_scattering_p);\n-  if (pddr_is_empty (pddr))\n-    return NULL;\n-\n-  return pddr;\n-}\n-\n /* Return true when the data dependence relation between the data\n    references PDR1 belonging to PBB1 and PDR2 is part of a\n    reduction.  */\n@@ -535,9 +628,11 @@ reduction_dr_1 (poly_bb_p pbb1, poly_dr_p pdr1, poly_dr_p pdr2)\n    part of a reduction.  */\n \n static inline bool\n-reduction_dr_p (poly_bb_p pbb1, poly_bb_p pbb2,\n-\t\tpoly_dr_p pdr1, poly_dr_p pdr2)\n+reduction_dr_p (poly_dr_p pdr1, poly_dr_p pdr2)\n {\n+  poly_bb_p pbb1 = PDR_PBB (pdr1);\n+  poly_bb_p pbb2 = PDR_PBB (pdr2);\n+\n   if (PBB_IS_REDUCTION (pbb1))\n     return reduction_dr_1 (pbb1, pdr1, pdr2);\n \n@@ -552,70 +647,71 @@ reduction_dr_p (poly_bb_p pbb1, poly_bb_p pbb2,\n    functions.  */\n \n static bool\n-graphite_legal_transform_dr (poly_bb_p pbb1, poly_bb_p pbb2,\n-\t\t\t     poly_dr_p pdr1, poly_dr_p pdr2)\n+graphite_legal_transform_dr (poly_dr_p pdr1, poly_dr_p pdr2)\n {\n-  ppl_Polyhedron_t st1, st2;\n   ppl_Pointset_Powerset_C_Polyhedron_t po, pt;\n   graphite_dim_t ddim1, otdim1, otdim2, ttdim1, ttdim2;\n-  ppl_Pointset_Powerset_C_Polyhedron_t temp;\n+  ppl_Pointset_Powerset_C_Polyhedron_t po_temp;\n   ppl_dimension_type pdim;\n   bool is_empty_p;\n-  poly_ddr_p pddr;\n+  poly_ddr_p opddr, tpddr;\n+  poly_bb_p pbb1, pbb2;\n \n-  if (reduction_dr_p (pbb1, pbb2, pdr1, pdr2))\n+  if (reduction_dr_p (pdr1, pdr2))\n     return true;\n \n-  pddr = build_pddr (pbb1, pbb2, pdr1, pdr2, 1, true);\n-  if (!pddr)\n+  /* We build the reverse dependence relation for the transformed\n+     scattering, such that when we intersect it with the original PO,\n+     we get an empty intersection when the transform is legal:\n+     i.e. the transform should reverse no dependences, and so PT, the\n+     reversed transformed PDDR, should have no constraint from PO.  */\n+  opddr = dependence_polyhedron (pdr1, pdr2, 1, true);\n+  tpddr = dependence_polyhedron (pdr1, pdr2, -1, false);\n+\n     /* There are no dependences between PDR1 and PDR2 in the original\n-       version of the program, so the transform is legal.  */\n+       version of the program, or after the transform, so the\n+       transform is legal.  */\n+  if (pddr_is_empty (opddr))\n     return true;\n \n-  po = PDDR_DDP (pddr);\n+  if (pddr_is_empty (tpddr))\n+    {\n+      free_poly_ddr (tpddr);\n+      return true;\n+    }\n \n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"\\nloop carries dependency.\\n\");\n+  po = PDDR_DDP (opddr);\n+  pt = PDDR_DDP (tpddr);\n \n-  st1 = PBB_TRANSFORMED_SCATTERING (pbb1);\n-  st2 = PBB_TRANSFORMED_SCATTERING (pbb2);\n+  /* Copy PO into PO_TEMP, such that PO is not destroyed.  PO is\n+     stored in a cache and should not be modified or freed.  */\n+  ppl_Pointset_Powerset_C_Polyhedron_space_dimension (po, &pdim);\n+  ppl_new_Pointset_Powerset_C_Polyhedron_from_space_dimension (&po_temp,\n+\t\t\t\t\t\t\t       pdim, 0);\n+  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (po_temp, po);\n+\n+  /* Extend PO and PT to have the same dimensions.  */\n+  pbb1 = PDR_PBB (pdr1);\n+  pbb2 = PDR_PBB (pdr2);\n   ddim1 = pbb_dim_iter_domain (pbb1);\n   otdim1 = pbb_nb_scattering_orig (pbb1);\n   otdim2 = pbb_nb_scattering_orig (pbb2);\n   ttdim1 = pbb_nb_scattering_transform (pbb1);\n   ttdim2 = pbb_nb_scattering_transform (pbb2);\n-\n-  /* Copy the PO polyhedron into the TEMP, so it is not destroyed.\n-     Keep in mind, that PO polyhedron might be restored from the cache\n-     and should not be modified!  */\n-  ppl_Pointset_Powerset_C_Polyhedron_space_dimension (po, &pdim);\n-  ppl_new_Pointset_Powerset_C_Polyhedron_from_space_dimension (&temp, pdim, 0);\n-  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (temp, po);\n-\n-  /* We build the reverse dependence relation for the transformed\n-     scattering, such that when we intersect it with the original PO,\n-     we get an empty intersection when the transform is legal:\n-     i.e. the transform should reverse no dependences, and so PT, the\n-     reversed transformed PDDR, should have no constraint from PO.  */\n-  pddr = build_pddr (pbb1, pbb2, pdr1, pdr2, -1, false);\n-  if (!pddr)\n-    /* There are no dependences after the transform, so the transform\n-       is legal.  */\n-    return true;\n-\n-  pt = PDDR_DDP (pddr);\n-\n-  /* Extend PO and PT to have the same dimensions.  */\n-  ppl_insert_dimensions_pointset (temp, otdim1, ttdim1);\n-  ppl_insert_dimensions_pointset (temp, otdim1 + ttdim1 + ddim1 + otdim2, ttdim2);\n+  ppl_insert_dimensions_pointset (po_temp, otdim1, ttdim1);\n+  ppl_insert_dimensions_pointset (po_temp, otdim1 + ttdim1 + ddim1 + otdim2,\n+\t\t\t\t  ttdim2);\n   ppl_insert_dimensions_pointset (pt, 0, otdim1);\n   ppl_insert_dimensions_pointset (pt, otdim1 + ttdim1 + ddim1, otdim2);\n \n-  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (temp, pt);\n-  is_empty_p = ppl_Pointset_Powerset_C_Polyhedron_is_empty (temp);\n+  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (po_temp, pt);\n+  is_empty_p = ppl_Pointset_Powerset_C_Polyhedron_is_empty (po_temp);\n \n-  ppl_delete_Pointset_Powerset_C_Polyhedron (temp);\n-  free_poly_ddr (pddr);\n+  ppl_delete_Pointset_Powerset_C_Polyhedron (po_temp);\n+  free_poly_ddr (tpddr);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"\\nloop carries dependency.\\n\");\n \n   return is_empty_p;\n }\n@@ -649,7 +745,7 @@ graphite_legal_transform_bb (poly_bb_p pbb1, poly_bb_p pbb2)\n \n   for (i = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb1), i, pdr1); i++)\n     for (j = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb2), j, pdr2); j++)\n-      if (!graphite_legal_transform_dr (pbb1, pbb2, pdr1, pdr2))\n+      if (!graphite_legal_transform_dr (pdr1, pdr2))\n \treturn false;\n \n   return true;\n@@ -678,104 +774,26 @@ graphite_legal_transform (scop_p scop)\n   return true;\n }\n \n-/* Remove all the dimensions except alias information at dimension\n-   ALIAS_DIM.  */\n-\n-static void\n-build_alias_set_powerset (ppl_Pointset_Powerset_C_Polyhedron_t alias_powerset,\n-\t\t\t  ppl_dimension_type alias_dim)\n-{\n-  ppl_dimension_type *ds;\n-  ppl_dimension_type access_dim;\n-  unsigned i, pos = 0;\n-\n-  ppl_Pointset_Powerset_C_Polyhedron_space_dimension (alias_powerset,\n-\t\t\t\t\t\t      &access_dim);\n-  ds = XNEWVEC (ppl_dimension_type, access_dim-1);\n-  for (i = 0; i < access_dim; i++)\n-    {\n-      if (i == alias_dim)\n-\tcontinue;\n-\n-      ds[pos] = i;\n-      pos++;\n-    }\n-\n-  ppl_Pointset_Powerset_C_Polyhedron_remove_space_dimensions (alias_powerset,\n-\t\t\t\t\t\t\t      ds,\n-\t\t\t\t\t\t\t      access_dim - 1);\n-  free (ds);\n-}\n-\n-/* Return true when PDR1 and PDR2 may alias.  */\n-\n-static bool\n-poly_drs_may_alias_p (poly_dr_p pdr1, poly_dr_p pdr2)\n-{\n-  ppl_Pointset_Powerset_C_Polyhedron_t alias_powerset1, alias_powerset2;\n-  ppl_Pointset_Powerset_C_Polyhedron_t accesses1 = PDR_ACCESSES (pdr1);\n-  ppl_Pointset_Powerset_C_Polyhedron_t accesses2 = PDR_ACCESSES (pdr2);\n-  ppl_dimension_type alias_dim1 = pdr_alias_set_dim (pdr1);\n-  ppl_dimension_type alias_dim2 = pdr_alias_set_dim (pdr2);\n-  int empty_p;\n-\n-  ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron\n-    (&alias_powerset1, accesses1);\n-  ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron\n-    (&alias_powerset2, accesses2);\n-\n-  build_alias_set_powerset (alias_powerset1, alias_dim1);\n-  build_alias_set_powerset (alias_powerset2, alias_dim2);\n-\n-  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign\n-    (alias_powerset1, alias_powerset2);\n-\n-  empty_p = ppl_Pointset_Powerset_C_Polyhedron_is_empty (alias_powerset1);\n-\n-  ppl_delete_Pointset_Powerset_C_Polyhedron (alias_powerset1);\n-  ppl_delete_Pointset_Powerset_C_Polyhedron (alias_powerset2);\n-\n-  return !empty_p;\n-}\n-\n /* Returns TRUE when the dependence polyhedron between PDR1 and\n    PDR2 represents a loop carried dependence at level LEVEL.  */\n \n static bool\n graphite_carried_dependence_level_k (poly_dr_p pdr1, poly_dr_p pdr2,\n \t\t\t\t     int level)\n {\n-  poly_bb_p pbb1 = PDR_PBB (pdr1);\n-  poly_bb_p pbb2 = PDR_PBB (pdr2);\n-  ppl_Pointset_Powerset_C_Polyhedron_t d1 = PBB_DOMAIN (pbb1);\n-  ppl_Pointset_Powerset_C_Polyhedron_t d2 = PBB_DOMAIN (pbb2);\n-  ppl_Polyhedron_t so1 = PBB_TRANSFORMED_SCATTERING (pbb1);\n-  ppl_Polyhedron_t so2 = PBB_TRANSFORMED_SCATTERING (pbb2);\n   ppl_Pointset_Powerset_C_Polyhedron_t po;\n   ppl_Pointset_Powerset_C_Polyhedron_t eqpp;\n-  graphite_dim_t tdim1 = pbb_nb_scattering_transform (pbb1);\n-  graphite_dim_t ddim1 = pbb_dim_iter_domain (pbb1);\n+  graphite_dim_t tdim1 = pbb_nb_scattering_transform (PDR_PBB (pdr1));\n+  graphite_dim_t ddim1 = pbb_dim_iter_domain (PDR_PBB (pdr1));\n   ppl_dimension_type dim;\n   bool empty_p;\n-  poly_ddr_p pddr;\n-  int obj_base_set1 = PDR_BASE_OBJECT_SET (pdr1);\n-  int obj_base_set2 = PDR_BASE_OBJECT_SET (pdr2);\n-\n-  if ((pdr_read_p (pdr1) && pdr_read_p (pdr2))\n-      || !poly_drs_may_alias_p (pdr1, pdr2))\n-    return false;\n-\n-  if (obj_base_set1 != obj_base_set2)\n-    return true;\n-\n-  if (PDR_NB_SUBSCRIPTS (pdr1) != PDR_NB_SUBSCRIPTS (pdr2))\n-    return false;\n-\n-  pddr = dependence_polyhedron (pbb1, pbb2, d1, d2, pdr1, pdr2, so1, so2,\n-\t\t\t\t1, false);\n+  poly_ddr_p pddr = dependence_polyhedron (pdr1, pdr2, 1, false);\n \n   if (pddr_is_empty (pddr))\n-    return false;\n+    {\n+      free_poly_ddr (pddr);\n+      return false;\n+    }\n \n   po = PDDR_DDP (pddr);\n   ppl_Pointset_Powerset_C_Polyhedron_space_dimension (po, &dim);\n@@ -785,6 +803,8 @@ graphite_carried_dependence_level_k (poly_dr_p pdr1, poly_dr_p pdr2,\n   empty_p = ppl_Pointset_Powerset_C_Polyhedron_is_empty (eqpp);\n \n   ppl_delete_Pointset_Powerset_C_Polyhedron (eqpp);\n+  free_poly_ddr (pddr);\n+\n   return !empty_p;\n }\n \n@@ -825,7 +845,7 @@ dot_original_deps_stmt_1 (FILE *file, scop_p scop)\n       {\n \tfor (k = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb1), k, pdr1); k++)\n \t  for (l = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb2), l, pdr2); l++)\n-\t    if (build_pddr (pbb1, pbb2, pdr1, pdr2, 1, true))\n+\t    if (!pddr_is_empty (dependence_polyhedron (pdr1, pdr2, 1, true)))\n \t      {\n \t\tfprintf (file, \"OS%d -> OS%d\\n\",\n \t\t\t pbb_index (pbb1), pbb_index (pbb2));\n@@ -844,20 +864,26 @@ dot_transformed_deps_stmt_1 (FILE *file, scop_p scop)\n   int i, j, k, l;\n   poly_bb_p pbb1, pbb2;\n   poly_dr_p pdr1, pdr2;\n-  poly_ddr_p pddr;\n \n   for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb1); i++)\n     for (j = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), j, pbb2); j++)\n       {\n \tfor (k = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb1), k, pdr1); k++)\n \t  for (l = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb2), l, pdr2); l++)\n-\t    if ((pddr = build_pddr (pbb1, pbb2, pdr1, pdr2, 1, false)))\n-\t      {\n-\t\tfprintf (file, \"TS%d -> TS%d\\n\",\n-\t\t\t pbb_index (pbb1), pbb_index (pbb2));\n-\t\tfree_poly_ddr (pddr);\n-\t\tgoto done;\n-\t      }\n+\t    {\n+\t      poly_ddr_p pddr = dependence_polyhedron (pdr1, pdr2, 1, false);\n+\n+\t      if (!pddr_is_empty (pddr))\n+\t\t{\n+\t\t  fprintf (file, \"TS%d -> TS%d\\n\",\n+\t\t\t   pbb_index (pbb1), pbb_index (pbb2));\n+\n+\t\t  free_poly_ddr (pddr);\n+\t\t  goto done;\n+\t\t}\n+\n+\t      free_poly_ddr (pddr);\n+\t    }\n       done:;\n       }\n }\n@@ -891,7 +917,7 @@ dot_original_deps (FILE *file, scop_p scop)\n     for (j = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), j, pbb2); j++)\n       for (k = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb1), k, pdr1); k++)\n \tfor (l = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb2), l, pdr2); l++)\n-\t  if (build_pddr (pbb1, pbb2, pdr1, pdr2, 1, true))\n+\t  if (!pddr_is_empty (dependence_polyhedron (pdr1, pdr2, 1, true)))\n \t    fprintf (file, \"OS%d_D%d -> OS%d_D%d\\n\",\n \t\t     pbb_index (pbb1), PDR_ID (pdr1),\n \t\t     pbb_index (pbb2), PDR_ID (pdr2));\n@@ -906,19 +932,21 @@ dot_transformed_deps (FILE *file, scop_p scop)\n   int i, j, k, l;\n   poly_bb_p pbb1, pbb2;\n   poly_dr_p pdr1, pdr2;\n-  poly_ddr_p pddr;\n \n   for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb1); i++)\n     for (j = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), j, pbb2); j++)\n       for (k = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb1), k, pdr1); k++)\n \tfor (l = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb2), l, pdr2); l++)\n-\t  if ((pddr = build_pddr (pbb1, pbb2, pdr1, pdr2, 1, false)))\n-\t    {\n+\t  {\n+\t    poly_ddr_p pddr = dependence_polyhedron (pdr1, pdr2, 1, false);\n+\n+\t    if (!pddr_is_empty (pddr))\n \t      fprintf (file, \"TS%d_D%d -> TS%d_D%d\\n\",\n \t\t       pbb_index (pbb1), PDR_ID (pdr1),\n \t\t       pbb_index (pbb2), PDR_ID (pdr2));\n-\t      free_poly_ddr (pddr);\n-\t    }\n+\n+\t    free_poly_ddr (pddr);\n+\t  }\n }\n \n /* Pretty print to FILE all the data dependences of SCoP in DOT"}, {"sha": "f6f4fea95d25526237f68363e6e16bab24d86f14", "filename": "gcc/graphite-dependences.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5eb099fb879d57196cbbff4df375cc26abbfb76/gcc%2Fgraphite-dependences.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5eb099fb879d57196cbbff4df375cc26abbfb76/gcc%2Fgraphite-dependences.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-dependences.h?ref=b5eb099fb879d57196cbbff4df375cc26abbfb76", "patch": "@@ -30,6 +30,8 @@ enum poly_dependence_kind {\n   has_dependence\n };\n \n+/* Represents a Polyhedral Data Dependence Relation.  */\n+\n typedef struct poly_ddr\n {\n   /* Source and sink data references of the dependence.  */\n@@ -40,17 +42,23 @@ typedef struct poly_ddr\n \n   enum poly_dependence_kind kind;\n \n+  /* True when the dependence relation is for the original scattering.  */\n+  bool original_scattering_p;\n+\n } *poly_ddr_p;\n \n #define PDDR_SOURCE(PDDR) (PDDR->source)\n #define PDDR_SINK(PDDR) (PDDR->sink)\n #define PDDR_DDP(PDDR) (PDDR->ddp)\n #define PDDR_KIND(PDDR) (PDDR->kind)\n+#define PDDR_ORIGINAL_SCATTERING_P(PDDR) (PDDR->original_scattering_p)\n \n extern int eq_poly_ddr_p (const void *, const void *);\n extern hashval_t hash_poly_ddr_p (const void *);\n extern void free_poly_ddr (void *);\n extern void dot_deps (scop_p);\n extern void dot_deps_stmt (scop_p);\n+extern void print_pddr (FILE *, poly_ddr_p);\n+extern void debug_pddr (poly_ddr_p);\n \n #endif"}, {"sha": "0b7633514ef21dd37e86dcdc655086dacf8ff9b8", "filename": "gcc/graphite-ppl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5eb099fb879d57196cbbff4df375cc26abbfb76/gcc%2Fgraphite-ppl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5eb099fb879d57196cbbff4df375cc26abbfb76/gcc%2Fgraphite-ppl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-ppl.c?ref=b5eb099fb879d57196cbbff4df375cc26abbfb76", "patch": "@@ -701,7 +701,7 @@ ppl_min_for_le_polyhedron (ppl_Polyhedron_t pol,\n }\n \n /* Builds a constraint in dimension DIM relating dimensions POS1 to\n-   POS2 as \"POS1 - POS2 CSTR_TYPE C\" */\n+   POS2 as \"POS1 - POS2 + C CSTR_TYPE 0\" */\n \n ppl_Constraint_t\n ppl_build_relation (int dim, int pos1, int pos2, int c,"}, {"sha": "20dd1b023da35acdb4e90d2543d288c805bd7fc5", "filename": "gcc/sese.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5eb099fb879d57196cbbff4df375cc26abbfb76/gcc%2Fsese.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5eb099fb879d57196cbbff4df375cc26abbfb76/gcc%2Fsese.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.h?ref=b5eb099fb879d57196cbbff4df375cc26abbfb76", "patch": "@@ -390,7 +390,4 @@ nb_common_loops (sese region, gimple_bb_p gbb1, gimple_bb_p gbb2)\n   return sese_loop_depth (region, common);\n }\n \n-extern void print_gimple_bb (FILE *, gimple_bb_p, int, int);\n-extern void debug_gbb (gimple_bb_p, int);\n-\n #endif"}]}