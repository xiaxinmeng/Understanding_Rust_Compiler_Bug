{"sha": "9e654916b911c5d99d570682d32d164dc3a8a090", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU2NTQ5MTZiOTExYzVkOTlkNTcwNjgyZDMyZDE2NGRjM2E4YTA5MA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-12-02T23:13:28Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-12-02T23:13:28Z"}, "message": "(MASK_64BIT, TARGET_64BIT, SHORT_TYPE_SIZE): Define.\n\n(INT_TYPE_SIZE, MAX_INT_TYPE_SIZE, LONG_TYPE_SIZE): Define.\n(MAX_LONG_TYPE_SIZE, LONG_LONG_TYPE_SIZE, CHAR_TYPE_SIZE): Define.\n(FLOAT_TYPE_SIZE, DOUBLE_TYPE_SIZE, LONG_DOUBLE_TYPE_SIZE): Define.\n(POINTER_SIZE, PARM_BOUNDARY): Depend on TARGET_64BIT.\n(BIGGEST_ALIGNMENT, STARTING_FRAME_OFFSET): Likewise.\n(FIRST_PARM_OFFSET, REG_PARM_STACK_SPACE): Likewise.\n(STACK_POINTER_OFFSET, Pmode, FUNCTION_MODE): TARGET_64BIT dependent.\n\nFrom-SVN: r8602", "tree": {"sha": "63aac62e6c93028947a350f1ece38f266665f0cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63aac62e6c93028947a350f1ece38f266665f0cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e654916b911c5d99d570682d32d164dc3a8a090", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e654916b911c5d99d570682d32d164dc3a8a090", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e654916b911c5d99d570682d32d164dc3a8a090", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e654916b911c5d99d570682d32d164dc3a8a090/comments", "author": null, "committer": null, "parents": [{"sha": "2132517db072e7c3d48c8594d6116e1a743ebf14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2132517db072e7c3d48c8594d6116e1a743ebf14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2132517db072e7c3d48c8594d6116e1a743ebf14"}], "stats": {"total": 67, "additions": 58, "deletions": 9}, "files": [{"sha": "362699a092092a96598b86cea1bac4a55e64cdab", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 58, "deletions": 9, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e654916b911c5d99d570682d32d164dc3a8a090/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e654916b911c5d99d570682d32d164dc3a8a090/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=9e654916b911c5d99d570682d32d164dc3a8a090", "patch": "@@ -134,6 +134,9 @@ extern int target_flags;\n    function, and one less allocatable register.  */\n #define MASK_MINIMAL_TOC\t0x200\n \n+/* Nonzero for the 64bit model: ints, longs, and pointers are 64 bits.  */\n+#define MASK_64BIT\t\t0x400\n+\n #define TARGET_POWER\t\t\t(target_flags & MASK_POWER)\n #define TARGET_POWER2\t\t\t(target_flags & MASK_POWER2)\n #define TARGET_POWERPC\t\t\t(target_flags & MASK_POWERPC)\n@@ -144,6 +147,7 @@ extern int target_flags;\n #define TARGET_NO_FP_IN_TOC\t\t(target_flags & MASK_NO_FP_IN_TOC)\n #define TARGET_NO_SUM_IN_TOC\t\t(target_flags & MASK_NO_SUM_IN_TOC)\n #define TARGET_MINIMAL_TOC\t\t(target_flags & MASK_MINIMAL_TOC)\n+#define TARGET_64BIT\t\t\t(target_flags & MASK_64BIT)\n \n /* Run-time compilation parameters selecting different hardware subsets.\n \n@@ -294,12 +298,56 @@ extern char *rs6000_cpu_string;\n /* Width of wchar_t in bits.  */\n #define WCHAR_TYPE_SIZE 16\n \n+/* A C expression for the size in bits of the type `short' on the\n+   target machine.  If you don't define this, the default is half a\n+   word.  (If this would be less than one storage unit, it is\n+   rounded up to one unit.)  */\n+#define SHORT_TYPE_SIZE 16\n+\n+/* A C expression for the size in bits of the type `int' on the\n+   target machine.  If you don't define this, the default is one\n+   word.  */\n+#define INT_TYPE_SIZE (TARGET_64BIT ? 64 : 32)\n+#define MAX_INT_TYPE_SIZE 64\n+\n+/* A C expression for the size in bits of the type `long' on the\n+   target machine.  If you don't define this, the default is one\n+   word.  */\n+#define LONG_TYPE_SIZE (TARGET_64BIT ? 64 : 32)\n+#define MAX_LONG_TYPE_SIZE 64\n+\n+/* A C expression for the size in bits of the type `long long' on the\n+   target machine.  If you don't define this, the default is two\n+   words.  */\n+#define LONG_LONG_TYPE_SIZE 64\n+\n+/* A C expression for the size in bits of the type `char' on the\n+   target machine.  If you don't define this, the default is one\n+   quarter of a word.  (If this would be less than one storage unit,\n+   it is rounded up to one unit.)  */\n+#define CHAR_TYPE_SIZE BITS_PER_UNIT\n+\n+/* A C expression for the size in bits of the type `float' on the\n+   target machine.  If you don't define this, the default is one\n+   word.  */\n+#define FLOAT_TYPE_SIZE 32\n+\n+/* A C expression for the size in bits of the type `double' on the\n+   target machine.  If you don't define this, the default is two\n+   words.  */\n+#define DOUBLE_TYPE_SIZE 64\n+\n+/* A C expression for the size in bits of the type `long double' on\n+   the target machine.  If you don't define this, the default is two\n+   words.  */\n+#define LONG_DOUBLE_TYPE_SIZE 64\n+\n /* Width in bits of a pointer.\n    See also the macro `Pmode' defined below.  */\n-#define POINTER_SIZE 32\n+#define POINTER_SIZE (TARGET_64BIT ? 64 : 32)\n \n /* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-#define PARM_BOUNDARY 32\n+#define PARM_BOUNDARY (TARGET_64BIT ? 64 : 32)\n \n /* Boundary (in *bits*) on which stack pointer should be aligned.  */\n #define STACK_BOUNDARY 64\n@@ -308,7 +356,7 @@ extern char *rs6000_cpu_string;\n #define FUNCTION_BOUNDARY 32\n \n /* No data type wants to be aligned rounder than this.  */\n-#define BIGGEST_ALIGNMENT 32\n+#define BIGGEST_ALIGNMENT (TARGET_64BIT ? 64 : 32)\n \n /* Alignment of field after `int : 0' in a structure.  */\n #define EMPTY_FIELD_BOUNDARY 32\n@@ -754,7 +802,8 @@ enum reg_class { NO_REGS, BASE_REGS, GENERAL_REGS, FLOAT_REGS,\n    except for dynamic allocations.  So we start after the fixed area and\n    outgoing parameter area.  */\n \n-#define STARTING_FRAME_OFFSET (current_function_outgoing_args_size + 24)\n+#define STARTING_FRAME_OFFSET (current_function_outgoing_args_size \\\n+\t\t\t       + (TARGET_64BIT ? 48 : 24))\n \n /* If we generate an insn to push BYTES bytes,\n    this says how many the stack pointer really advances by.\n@@ -764,12 +813,12 @@ enum reg_class { NO_REGS, BASE_REGS, GENERAL_REGS, FLOAT_REGS,\n /* Offset of first parameter from the argument pointer register value.\n    On the RS/6000, we define the argument pointer to the start of the fixed\n    area.  */\n-#define FIRST_PARM_OFFSET(FNDECL) 24\n+#define FIRST_PARM_OFFSET(FNDECL) (TARGET_64BIT ? 48 : 24)\n \n /* Define this if stack space is still allocated for a parameter passed\n    in a register.  The value is the number of bytes allocated to this\n    area.  */\n-#define REG_PARM_STACK_SPACE(FNDECL)\t32\n+#define REG_PARM_STACK_SPACE(FNDECL)\t(TARGET_64BIT ? 64 : 32)\n \n /* Define this if the above stack space is to be considered part of the\n    space allocated by the caller.  */\n@@ -778,7 +827,7 @@ enum reg_class { NO_REGS, BASE_REGS, GENERAL_REGS, FLOAT_REGS,\n /* This is the difference between the logical top of stack and the actual sp.\n \n    For the RS/6000, sp points past the fixed area. */\n-#define STACK_POINTER_OFFSET 24\n+#define STACK_POINTER_OFFSET (TARGET_64BIT ? 48 : 24)\n \n /* Define this if the maximum size of all the outgoing args is to be\n    accumulated and pushed during the prologue.  The amount can be\n@@ -1416,12 +1465,12 @@ struct rs6000_args {int words, fregno, nargs_prototype; };\n /* Specify the machine mode that pointers have.\n    After generation of rtl, the compiler makes no further distinction\n    between pointers and any other objects of this machine mode.  */\n-#define Pmode SImode\n+#define Pmode (TARGET_64BIT ? DImode : SImode)\n \n /* Mode of a function address in a call instruction (for indexing purposes).\n \n    Doesn't matter on RS/6000.  */\n-#define FUNCTION_MODE SImode\n+#define FUNCTION_MODE (TARGET_64BIT ? DImode : SImode)\n \n /* Define this if addresses of constant functions\n    shouldn't be put through pseudo regs where they can be cse'd."}]}