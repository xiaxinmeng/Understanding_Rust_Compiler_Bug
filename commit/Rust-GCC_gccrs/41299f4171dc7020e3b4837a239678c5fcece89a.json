{"sha": "41299f4171dc7020e3b4837a239678c5fcece89a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDEyOTlmNDE3MWRjNzAyMGUzYjQ4MzdhMjM5Njc4YzVmY2VjZTg5YQ==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1991-10-24T17:21:48Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1991-10-24T17:21:48Z"}, "message": "Initial revision\n\nFrom-SVN: r47", "tree": {"sha": "4ccd04a31b7e4f62f6b380131c0a10396ac10bd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ccd04a31b7e4f62f6b380131c0a10396ac10bd5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41299f4171dc7020e3b4837a239678c5fcece89a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41299f4171dc7020e3b4837a239678c5fcece89a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41299f4171dc7020e3b4837a239678c5fcece89a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41299f4171dc7020e3b4837a239678c5fcece89a/comments", "author": null, "committer": null, "parents": [{"sha": "4217c4568b6eb6c50946a9482df1e13389e0dc09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4217c4568b6eb6c50946a9482df1e13389e0dc09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4217c4568b6eb6c50946a9482df1e13389e0dc09"}], "stats": {"total": 4579, "additions": 4579, "deletions": 0}, "files": [{"sha": "47ff2ccb66f50b7ee8cd27aad18dbb67e6414f61", "filename": "gcc/genattr.c", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41299f4171dc7020e3b4837a239678c5fcece89a/gcc%2Fgenattr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41299f4171dc7020e3b4837a239678c5fcece89a/gcc%2Fgenattr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattr.c?ref=41299f4171dc7020e3b4837a239678c5fcece89a", "patch": "@@ -0,0 +1,251 @@\n+/* Generate attribute information (insn-attr.h) from machine description.\n+   Copyright (C) 1989 Free Software Foundation, Inc.\n+   Contributed by Richard Kenner (kenner@nyu.edu)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"obstack.h\"\n+\n+static struct obstack obstack;\n+struct obstack *rtl_obstack = &obstack;\n+\n+#define obstack_chunk_alloc xmalloc\n+#define obstack_chunk_free free\n+\n+extern void free ();\n+extern int atoi ();\n+\n+char *xmalloc ();\n+static void fatal ();\n+void fancy_abort ();\n+\n+static void\n+write_upcase (str)\n+    char *str;\n+{\n+  for (; *str; str++)\n+    if (*str >= 'a' && *str <= 'z')\n+      printf (\"%c\", *str - 'a' + 'A');\n+    else\n+      printf (\"%c\", *str);\n+}\n+\n+static void\n+gen_attr (attr)\n+     rtx attr;\n+{\n+  char *p;\n+\n+  printf (\"#define HAVE_ATTR_%s\\n\", XSTR (attr, 0));\n+\n+  /* If numeric attribute, don't need to write an enum.  */\n+  if (*XSTR (attr, 1) == '\\0')\n+    printf (\"extern int get_attr_%s ();\\n\", XSTR (attr, 0));\n+  else\n+    {\n+      printf (\"enum attr_%s {\", XSTR (attr, 0));\n+      write_upcase (XSTR (attr, 0));\n+      printf (\"_\");\n+\n+      for (p = XSTR (attr, 1); *p != '\\0'; p++)\n+\t{\n+\t  if (*p == ',')\n+\t    {\n+\t      printf (\", \");\n+\t      write_upcase (XSTR (attr, 0));\n+\t      printf (\"_\");\n+\t    }\n+\t  else if (*p >= 'a' && *p <= 'z')\n+\t    printf (\"%c\", *p - 'a' + 'A');\n+\t  else\n+\t    printf (\"%c\", *p);\n+\t}\n+\n+      printf (\"};\\n\");\n+      printf (\"extern enum attr_%s get_attr_%s ();\\n\\n\",\n+\t      XSTR (attr, 0), XSTR (attr, 0));\n+    }\n+\n+  /* If `length' attribute, write additional function definitions and define\n+     variables used by `insn_current_length'.  */\n+  if (! strcmp (XSTR (attr, 0), \"length\"))\n+    {\n+      printf (\"extern void init_lengths ();\\n\");\n+      printf (\"extern void shorten_branches ();\\n\");\n+      printf (\"extern int insn_default_length ();\\n\");\n+      printf (\"extern int insn_variable_length_p ();\\n\");\n+      printf (\"extern int insn_current_length ();\\n\\n\");\n+      printf (\"extern int *insn_addresses;\\n\");\n+      printf (\"extern int insn_current_address;\\n\\n\");\n+    }\n+}\n+\n+static void\n+write_units ()\n+{\n+  printf (\"#define INSN_SCHEDULING\\n\\n\");\n+  printf (\"extern int result_ready_cost ();\\n\");\n+  printf (\"extern int function_units_used ();\\n\\n\");\n+  printf (\"extern struct function_unit_desc\\n\");\n+  printf (\"{\\n\");\n+  printf (\"  char *name;\\n\");\n+  printf (\"  int bitmask;\\n\");\n+  printf (\"  int multiplicity;\\n\");\n+  printf (\"  int simultaneity;\\n\");\n+  printf (\"  int default_cost;\\n\");\n+  printf (\"  int (*ready_cost_function) ();\\n\");\n+  printf (\"  int (*conflict_cost_function) ();\\n\");\n+  printf (\"} function_units[];\\n\\n\");\n+}\n+\n+char *\n+xmalloc (size)\n+     unsigned size;\n+{\n+  register char *val = (char *) malloc (size);\n+\n+  if (val == 0)\n+    fatal (\"virtual memory exhausted\");\n+  return val;\n+}\n+\n+char *\n+xrealloc (ptr, size)\n+     char *ptr;\n+     unsigned size;\n+{\n+  char * result = (char *) realloc (ptr, size);\n+  if (!result)\n+    fatal (\"virtual memory exhausted\");\n+  return result;\n+}\n+\n+static void\n+fatal (s, a1, a2)\n+     char *s;\n+{\n+  fprintf (stderr, \"genattr: \");\n+  fprintf (stderr, s, a1, a2);\n+  fprintf (stderr, \"\\n\");\n+  exit (FATAL_EXIT_CODE);\n+}\n+\n+/* More 'friendly' abort that prints the line and file.\n+   config.h can #define abort fancy_abort if you like that sort of thing.  */\n+\n+void\n+fancy_abort ()\n+{\n+  fatal (\"Internal gcc abort.\");\n+}\n+\f\n+int\n+main (argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+  rtx desc;\n+  FILE *infile;\n+  extern rtx read_rtx ();\n+  register int c;\n+  int have_delay = 0;\n+  int have_annul_true = 0;\n+  int have_annul_false = 0;\n+  int have_units = 0;\n+  int i;\n+\n+  obstack_init (rtl_obstack);\n+\n+  if (argc <= 1)\n+    fatal (\"No input file name.\");\n+\n+  infile = fopen (argv[1], \"r\");\n+  if (infile == 0)\n+    {\n+      perror (argv[1]);\n+      exit (FATAL_EXIT_CODE);\n+    }\n+\n+  init_rtl ();\n+\n+  printf (\"/* Generated automatically by the program `genattr'\\n\\\n+from the machine description file `md'.  */\\n\\n\");\n+\n+  /* For compatibility, define the attribute `alternative', which is just\n+     a reference to the variable `which_alternative'.  */\n+\n+  printf (\"#define HAVE_ATTR_alternative\\n\");\n+  printf (\"#define get_attr_alternative(insn) which_alternative\\n\");\n+     \n+  /* Read the machine description.  */\n+\n+  while (1)\n+    {\n+      c = read_skip_spaces (infile);\n+      if (c == EOF)\n+\tbreak;\n+      ungetc (c, infile);\n+\n+      desc = read_rtx (infile);\n+      if (GET_CODE (desc) == DEFINE_ATTR)\n+\tgen_attr (desc);\n+\n+      else if (GET_CODE (desc) == DEFINE_DELAY)\n+        {\n+\t  if (! have_delay)\n+\t    {\n+\t      printf (\"#define DELAY_SLOTS\\n\");\n+\t      printf (\"extern int num_delay_slots ();\\n\");\n+\t      printf (\"extern int eligible_for_delay ();\\n\\n\");\n+\t      have_delay = 1;\n+\t    }\n+\n+\t  for (i = 0; i < XVECLEN (desc, 1); i += 3)\n+\t    {\n+\t      if (XVECEXP (desc, 1, i + 1) && ! have_annul_true)\n+\t\t{\n+\t\t  printf (\"#define ANNUL_IFTRUE_SLOTS\\n\");\n+\t\t  printf (\"extern int eligible_for_annul_true ();\\n\");\n+\t\t  have_annul_true = 1;\n+\t\t}\n+\n+\t      if (XVECEXP (desc, 1, i + 2) && ! have_annul_false)\n+\t\t{\n+\t\t  printf (\"#define ANNUL_IFFALSE_SLOTS\\n\");\n+\t\t  printf (\"extern int eligible_for_annul_false ();\\n\");\n+\t\t  have_annul_false = 1;\n+\t\t}\n+\t    }\n+        }\n+\n+      else if (GET_CODE (desc) == DEFINE_FUNCTION_UNIT && ! have_units)\n+\t{\n+\t  have_units = 1;\n+\t  write_units ();\n+\t}\n+    }\n+\n+  fflush (stdout);\n+  exit (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);\n+  /* NOTREACHED */\n+  return 0;\n+}\n+"}, {"sha": "1fbdc5db53a7b86ec848a3644b9b33b25bfb0ad1", "filename": "gcc/genattrtab.c", "status": "added", "additions": 3604, "deletions": 0, "changes": 3604, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41299f4171dc7020e3b4837a239678c5fcece89a/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41299f4171dc7020e3b4837a239678c5fcece89a/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=41299f4171dc7020e3b4837a239678c5fcece89a"}, {"sha": "4d06b80dbdf7ccd2d5237e0e885994fd78dab9eb", "filename": "gcc/gencodes.c", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41299f4171dc7020e3b4837a239678c5fcece89a/gcc%2Fgencodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41299f4171dc7020e3b4837a239678c5fcece89a/gcc%2Fgencodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgencodes.c?ref=41299f4171dc7020e3b4837a239678c5fcece89a", "patch": "@@ -0,0 +1,159 @@\n+/* Generate from machine description:\n+\n+   - some macros CODE_FOR_... giving the insn_code_number value\n+   for each of the defined standard insn names.\n+   Copyright (C) 1987 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"obstack.h\"\n+\n+static struct obstack obstack;\n+struct obstack *rtl_obstack = &obstack;\n+\n+#define obstack_chunk_alloc xmalloc\n+#define obstack_chunk_free free\n+\n+extern void free ();\n+\n+char *xmalloc ();\n+static void fatal ();\n+void fancy_abort ();\n+\n+static int insn_code_number;\n+\n+static void\n+gen_insn (insn)\n+     rtx insn;\n+{\n+  /* Don't mention instructions whose names are the null string.\n+     They are in the machine description just to be recognized.  */\n+  if (strlen (XSTR (insn, 0)) != 0)\n+    printf (\"  CODE_FOR_%s = %d,\\n\", XSTR (insn, 0),\n+\t    insn_code_number);\n+}\n+\n+char *\n+xmalloc (size)\n+     unsigned size;\n+{\n+  register char *val = (char *) malloc (size);\n+\n+  if (val == 0)\n+    fatal (\"virtual memory exhausted\");\n+  return val;\n+}\n+\n+char *\n+xrealloc (ptr, size)\n+     char *ptr;\n+     unsigned size;\n+{\n+  char *result = (char *) realloc (ptr, size);\n+  if (!result)\n+    fatal (\"virtual memory exhausted\");\n+  return result;\n+}\n+\n+static void\n+fatal (s, a1, a2)\n+     char *s;\n+{\n+  fprintf (stderr, \"gencodes: \");\n+  fprintf (stderr, s, a1, a2);\n+  fprintf (stderr, \"\\n\");\n+  exit (FATAL_EXIT_CODE);\n+}\n+\n+/* More 'friendly' abort that prints the line and file.\n+   config.h can #define abort fancy_abort if you like that sort of thing.  */\n+\n+void\n+fancy_abort ()\n+{\n+  fatal (\"Internal gcc abort.\");\n+}\n+\f\n+int\n+main (argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+  rtx desc;\n+  FILE *infile;\n+  extern rtx read_rtx ();\n+  register int c;\n+\n+  obstack_init (rtl_obstack);\n+\n+  if (argc <= 1)\n+    fatal (\"No input file name.\");\n+\n+  infile = fopen (argv[1], \"r\");\n+  if (infile == 0)\n+    {\n+      perror (argv[1]);\n+      exit (FATAL_EXIT_CODE);\n+    }\n+\n+  init_rtl ();\n+\n+  printf (\"/* Generated automatically by the program `gencodes'\\n\\\n+from the machine description file `md'.  */\\n\\n\");\n+\n+  printf (\"#ifndef MAX_INSN_CODE\\n\\n\");\n+\n+  /* Read the machine description.  */\n+\n+  insn_code_number = 0;\n+  printf (\"enum insn_code {\\n\");\n+\n+  while (1)\n+    {\n+      c = read_skip_spaces (infile);\n+      if (c == EOF)\n+\tbreak;\n+      ungetc (c, infile);\n+\n+      desc = read_rtx (infile);\n+      if (GET_CODE (desc) == DEFINE_INSN || GET_CODE (desc) == DEFINE_EXPAND)\n+\t{\n+\t  gen_insn (desc);\n+\t  insn_code_number++;\n+\t}\n+      if (GET_CODE (desc) == DEFINE_PEEPHOLE\n+\t  || GET_CODE (desc) == DEFINE_SPLIT)\n+\t{\n+\t  insn_code_number++;\n+\t}\n+    }\n+\n+  printf (\"  CODE_FOR_nothing };\\n\");\n+\n+  printf (\"\\n#define MAX_INSN_CODE ((int) CODE_FOR_nothing)\\n\");\n+\n+  printf (\"#endif /* MAX_INSN_CODE */\\n\");\n+\n+  fflush (stdout);\n+  exit (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);\n+  /* NOTREACHED */\n+  return 0;\n+}"}, {"sha": "11538d99ba38e62c4bc26b7ced958dcb784792a9", "filename": "gcc/genextract.c", "status": "added", "additions": 405, "deletions": 0, "changes": 405, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41299f4171dc7020e3b4837a239678c5fcece89a/gcc%2Fgenextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41299f4171dc7020e3b4837a239678c5fcece89a/gcc%2Fgenextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenextract.c?ref=41299f4171dc7020e3b4837a239678c5fcece89a", "patch": "@@ -0,0 +1,405 @@\n+/* Generate code from machine description to extract operands from insn as rtl.\n+   Copyright (C) 1987 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"obstack.h\"\n+\n+static struct obstack obstack;\n+struct obstack *rtl_obstack = &obstack;\n+\n+#define obstack_chunk_alloc xmalloc\n+#define obstack_chunk_free free\n+\n+extern void free ();\n+\n+/* Number instruction patterns handled, starting at 0 for first one.  */\n+\n+static int insn_code_number;\n+\n+/* Number the occurrences of MATCH_DUP in each instruction,\n+   starting at 0 for the first occurrence.  */\n+\n+static int dup_count;\n+\n+/* Record which operand numbers have been seen in the current pattern.\n+   This table is made longer as needed.  */\n+\n+static char *operand_seen;\n+\n+/* Current allocated length of operand_seen.  */\n+\n+static int operand_seen_length;\n+\n+/* Have we got any peephole patterns yet?  */\n+\n+static int peephole_seen;\n+\n+/* While tree-walking an instruction pattern, we keep a chain\n+   of these `struct link's to record how to get down to the\n+   current position.  In each one, POS is the operand number,\n+   and if the operand is a vector VEC is the element number.\n+   VEC is -1 if the operand is not a vector.  */\n+\n+struct link\n+{\n+  struct link *next;\n+  int pos;\n+  int vecelt;\n+};\n+\n+static void walk_rtx ();\n+static void print_path ();\n+char *xmalloc ();\n+char *xrealloc ();\n+static void fatal ();\n+void fancy_abort ();\n+\f\n+static void\n+gen_insn (insn)\n+     rtx insn;\n+{\n+  register int i;\n+\n+  dup_count = 0;\n+\n+  /* No operands seen so far in this pattern.  */\n+  bzero (operand_seen, operand_seen_length);\n+\n+  printf (\"    case %d:\\n\", insn_code_number);\n+\n+  /* Walk the insn's pattern, remembering at all times the path\n+     down to the walking point.  */\n+\n+  if (XVECLEN (insn, 1) == 1)\n+    walk_rtx (XVECEXP (insn, 1, 0), 0);\n+  else\n+    for (i = XVECLEN (insn, 1) - 1; i >= 0; i--)\n+      {\n+\tstruct link link;\n+\tlink.next = 0;\n+\tlink.pos = 0;\n+\tlink.vecelt = i;\n+\twalk_rtx (XVECEXP (insn, 1, i), &link);\n+      }\n+\n+  /* If the operand numbers used in the pattern are not consecutive,\n+     don't leave an operand uninitialized.  */\n+  for (i = operand_seen_length - 1; i >= 0; i--)\n+    if (operand_seen[i])\n+      break;\n+  for (; i >= 0; i--)\n+    if (!operand_seen[i])\n+      {\n+\tprintf (\"      recog_operand[%d] = const0_rtx;\\n\", i);\n+\tprintf (\"      recog_operand_loc[%d] = &junk;\\n\", i);\n+      }\n+  printf (\"      break;\\n\");\n+}\n+\f\n+/* Record that we have seen an operand with number OPNO in this pattern.  */\n+\n+static void\n+mark_operand_seen (opno)\n+     int opno;\n+{\n+  if (opno >= operand_seen_length)\n+    {\n+      operand_seen_length *= 2;\n+      operand_seen = (char *) xrealloc (operand_seen_length);\n+    }\n+\n+  operand_seen[opno] = 1;\n+}\n+\n+static void\n+walk_rtx (x, path)\n+     rtx x;\n+     struct link *path;\n+{\n+  register RTX_CODE code;\n+  register int i;\n+  register int len;\n+  register char *fmt;\n+  struct link link;\n+\n+  if (x == 0)\n+    return;\n+\n+  code = GET_CODE (x);\n+\n+  switch (code)\n+    {\n+    case PC:\n+    case CC0:\n+    case CONST_INT:\n+    case SYMBOL_REF:\n+      return;\n+\n+    case MATCH_OPERAND:\n+    case MATCH_SCRATCH:\n+      mark_operand_seen (XINT (x, 0));\n+      printf (\"      recog_operand[%d] = *(recog_operand_loc[%d]\\n        = &\",\n+\t      XINT (x, 0), XINT (x, 0));\n+      print_path (path);\n+      printf (\");\\n\");\n+      break;\n+\n+    case MATCH_DUP:\n+    case MATCH_OP_DUP:\n+      printf (\"      recog_dup_loc[%d] = &\", dup_count);\n+      print_path (path);\n+      printf (\";\\n\");\n+      printf (\"      recog_dup_num[%d] = %d;\\n\", dup_count, XINT (x, 0));\n+      dup_count++;\n+      break;\n+\n+    case MATCH_OPERATOR:\n+      mark_operand_seen (XINT (x, 0));\n+      printf (\"      recog_operand[%d] = *(recog_operand_loc[%d]\\n        = &\",\n+\t      XINT (x, 0), XINT (x, 0));\n+      print_path (path);\n+      printf (\");\\n\");\n+      link.next = path;\n+      link.vecelt = -1;\n+      for (i = XVECLEN (x, 2) - 1; i >= 0; i--)\n+\t{\n+\t  link.pos = i;\n+\t  walk_rtx (XVECEXP (x, 2, i), &link);\n+\t}\n+      return;\n+\n+    case MATCH_PARALLEL:\n+      mark_operand_seen (XINT (x, 0));\n+      printf (\"      recog_operand[%d] = *(recog_operand_loc[%d]\\n        = &\",\n+\t      XINT (x, 0), XINT (x, 0));\n+      print_path (path);\n+      printf (\");\\n\");\n+      link.next = path;\n+      link.pos = 0;\n+      for (i = XVECLEN (x, 2) - 1; i >= 0; i--)\n+\t{\n+\t  link.vecelt = i;\n+\t  walk_rtx (XVECEXP (x, 2, i), &link);\n+\t}\n+      return;\n+\n+    case ADDRESS:\n+      walk_rtx (XEXP (x, 0), path);\n+      return;\n+    }\n+\n+  link.next = path;\n+  link.vecelt = -1;\n+  fmt = GET_RTX_FORMAT (code);\n+  len = GET_RTX_LENGTH (code);\n+  for (i = 0; i < len; i++)\n+    {\n+      link.pos = i;\n+      if (fmt[i] == 'e' || fmt[i] == 'u')\n+\t{\n+\t  walk_rtx (XEXP (x, i), &link);\n+\t}\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  int j;\n+\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t    {\n+\t      link.vecelt = j;\n+\t      walk_rtx (XVECEXP (x, i, j), &link);\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Given a PATH, representing a path down the instruction's\n+   pattern from the root to a certain point, output code to\n+   evaluate to the rtx at that point.  */\n+\n+static void\n+print_path (path)\n+     struct link *path;\n+{\n+  if (path == 0)\n+    printf (\"insn\");\n+  else if (path->vecelt >= 0)\n+    {\n+      printf (\"XVECEXP (\");\n+      print_path (path->next);\n+      printf (\", %d, %d)\", path->pos, path->vecelt);\n+    }\n+  else\n+    {\n+      printf (\"XEXP (\");\n+      print_path (path->next);\n+      printf (\", %d)\", path->pos);\n+    }\n+}\n+\f\n+char *\n+xmalloc (size)\n+     unsigned size;\n+{\n+  register char *val = (char *) malloc (size);\n+\n+  if (val == 0)\n+    fatal (\"virtual memory exhausted\");\n+  return val;\n+}\n+\n+char *\n+xrealloc (ptr, size)\n+     char *ptr;\n+     unsigned size;\n+{\n+  char *result = (char *) realloc (ptr, size);\n+  if (!result)\n+    fatal (\"virtual memory exhausted\");\n+  return result;\n+}\n+\n+static void\n+fatal (s, a1, a2)\n+     char *s;\n+{\n+  fprintf (stderr, \"genextract: \");\n+  fprintf (stderr, s, a1, a2);\n+  fprintf (stderr, \"\\n\");\n+  exit (FATAL_EXIT_CODE);\n+}\n+\n+/* More 'friendly' abort that prints the line and file.\n+   config.h can #define abort fancy_abort if you like that sort of thing.  */\n+\n+void\n+fancy_abort ()\n+{\n+  fatal (\"Internal gcc abort.\");\n+}\n+\f\n+int\n+main (argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+  rtx desc;\n+  FILE *infile;\n+  extern rtx read_rtx ();\n+  register int c, i;\n+\n+  obstack_init (rtl_obstack);\n+\n+  if (argc <= 1)\n+    fatal (\"No input file name.\");\n+\n+  infile = fopen (argv[1], \"r\");\n+  if (infile == 0)\n+    {\n+      perror (argv[1]);\n+      exit (FATAL_EXIT_CODE);\n+    }\n+\n+  init_rtl ();\n+\n+  /* Assign sequential codes to all entries in the machine description\n+     in parallel with the tables in insn-output.c.  */\n+\n+  insn_code_number = 0;\n+\n+  operand_seen_length = 40;\n+  operand_seen = (char *) xmalloc (40);\n+\n+  printf (\"/* Generated automatically by the program `genextract'\\n\\\n+from the machine description file `md'.  */\\n\\n\");\n+\n+  printf (\"#include \\\"config.h\\\"\\n\");\n+  printf (\"#include \\\"rtl.h\\\"\\n\\n\");\n+\n+  /* This variable exists only so it can be the \"location\"\n+     of any missing operand whose numbers are skipped by a given pattern.  */\n+  printf (\"static rtx junk;\\n\");\n+  printf (\"extern rtx recog_operand[];\\n\");\n+  printf (\"extern rtx *recog_operand_loc[];\\n\");\n+  printf (\"extern rtx *recog_dup_loc[];\\n\");\n+  printf (\"extern char recog_dup_num[];\\n\");\n+  printf (\"extern void fatal_insn_not_found ();\\n\\n\");\n+\n+  printf (\"void\\ninsn_extract (insn)\\n\");\n+  printf (\"     rtx insn;\\n\");\n+  printf (\"{\\n\");\n+  printf (\"  int insn_code = INSN_CODE (insn);\\n\");\n+  printf (\"  if (insn_code == -1) fatal_insn_not_found (insn);\\n\");\n+  printf (\"  insn = PATTERN (insn);\\n\");\n+  printf (\"  switch (insn_code)\\n\");\n+  printf (\"    {\\n\");\n+\n+  /* Read the machine description.  */\n+\n+  while (1)\n+    {\n+      c = read_skip_spaces (infile);\n+      if (c == EOF)\n+\tbreak;\n+      ungetc (c, infile);\n+\n+      desc = read_rtx (infile);\n+      if (GET_CODE (desc) == DEFINE_INSN)\n+\t{\n+\t  gen_insn (desc);\n+\t  ++insn_code_number;\n+\t}\n+      if (GET_CODE (desc) == DEFINE_PEEPHOLE)\n+\t{\n+\t  printf (\"    case %d: goto peephole;\\n\", insn_code_number);\n+\t  ++insn_code_number;\n+\t  ++peephole_seen;\n+\t}\n+      if (GET_CODE (desc) == DEFINE_EXPAND || GET_CODE (desc) == DEFINE_SPLIT)\n+\t{\n+\t  printf (\"    case %d: break;\\n\", insn_code_number);\n+\t  ++insn_code_number;\n+\t}\n+    }\n+\n+  /* This should never be reached.  */\n+  printf (\"\\n    default:\\n      abort ();\\n\");\n+\n+  if (peephole_seen)\n+    {\n+      /* The vector in the insn says how many operands it has.\n+\t And all it contains are operands.  In fact, the vector was\n+\t created just for the sake of this function.  */\n+      printf (\"    peephole:\\n\");\n+      printf (\"#if __GNUC__ > 1 && !defined (bcopy)\\n\");\n+      printf (\"#define bcopy(FROM,TO,COUNT) __builtin_memcpy(TO,FROM,COUNT)\\n\");\n+      printf (\"#endif\\n\");\n+      printf (\"      bcopy (&XVECEXP (insn, 0, 0), recog_operand,\\n\");\n+      printf (\"             sizeof (rtx) * XVECLEN (insn, 0));\\n\");\n+      printf (\"      break;\\n\");\n+    }\n+\n+  printf (\"    }\\n}\\n\");\n+\n+  fflush (stdout);\n+  exit (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);\n+  /* NOTREACHED */\n+  return 0;\n+}"}, {"sha": "3d87b59fc41e217818c4bbaab73eaa971a5c2940", "filename": "gcc/genflags.c", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41299f4171dc7020e3b4837a239678c5fcece89a/gcc%2Fgenflags.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41299f4171dc7020e3b4837a239678c5fcece89a/gcc%2Fgenflags.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenflags.c?ref=41299f4171dc7020e3b4837a239678c5fcece89a", "patch": "@@ -0,0 +1,160 @@\n+/* Generate from machine description:\n+\n+   - some flags HAVE_... saying which simple standard instructions are\n+   available for this machine.\n+   Copyright (C) 1987 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"obstack.h\"\n+\n+static struct obstack obstack;\n+struct obstack *rtl_obstack = &obstack;\n+\n+#define obstack_chunk_alloc xmalloc\n+#define obstack_chunk_free free\n+\n+extern void free ();\n+\n+char *xmalloc ();\n+static void fatal ();\n+void fancy_abort ();\n+\n+static void\n+gen_insn (insn)\n+     rtx insn;\n+{\n+  char *p;\n+\n+  /* Don't mention instructions whose names are the null string.\n+     They are in the machine description just to be recognized.  */\n+  if (strlen (XSTR (insn, 0)) == 0)\n+    return;\n+\n+  printf (\"#define HAVE_%s \", XSTR (insn, 0));\n+  if (strlen (XSTR (insn, 2)) == 0)\n+    printf (\"1\\n\");\n+  else\n+    {\n+      /* Write the macro definition, putting \\'s at the end of each line,\n+\t if more than one.  */\n+      printf (\"(\");\n+      for (p = XSTR (insn, 2); *p; p++)\n+\t{\n+\t  if (*p == '\\n')\n+\t    printf (\" \\\\\\n\");\n+\t  else\n+\t    printf (\"%c\", *p);\n+\t}\n+      printf (\")\\n\");\n+    }\n+      \n+  printf (\"extern rtx gen_%s ();\\n\", XSTR (insn, 0));\n+}\n+\f\n+char *\n+xmalloc (size)\n+     unsigned size;\n+{\n+  register char *val = (char *) malloc (size);\n+\n+  if (val == 0)\n+    fatal (\"virtual memory exhausted\");\n+\n+  return val;\n+}\n+\n+char *\n+xrealloc (ptr, size)\n+     char *ptr;\n+     unsigned size;\n+{\n+  char *result = (char *) realloc (ptr, size);\n+  if (!result)\n+    fatal (\"virtual memory exhausted\");\n+  return result;\n+}\n+\n+static void\n+fatal (s, a1, a2)\n+     char *s;\n+{\n+  fprintf (stderr, \"genflags: \");\n+  fprintf (stderr, s, a1, a2);\n+  fprintf (stderr, \"\\n\");\n+  exit (FATAL_EXIT_CODE);\n+}\n+\n+/* More 'friendly' abort that prints the line and file.\n+   config.h can #define abort fancy_abort if you like that sort of thing.  */\n+\n+void\n+fancy_abort ()\n+{\n+  fatal (\"Internal gcc abort.\");\n+}\n+\f\n+int\n+main (argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+  rtx desc;\n+  FILE *infile;\n+  extern rtx read_rtx ();\n+  register int c;\n+\n+  obstack_init (rtl_obstack);\n+\n+  if (argc <= 1)\n+    fatal (\"No input file name.\");\n+\n+  infile = fopen (argv[1], \"r\");\n+  if (infile == 0)\n+    {\n+      perror (argv[1]);\n+      exit (FATAL_EXIT_CODE);\n+    }\n+\n+  init_rtl ();\n+\n+  printf (\"/* Generated automatically by the program `genflags'\\n\\\n+from the machine description file `md'.  */\\n\\n\");\n+\n+  /* Read the machine description.  */\n+\n+  while (1)\n+    {\n+      c = read_skip_spaces (infile);\n+      if (c == EOF)\n+\tbreak;\n+      ungetc (c, infile);\n+\n+      desc = read_rtx (infile);\n+      if (GET_CODE (desc) == DEFINE_INSN || GET_CODE (desc) == DEFINE_EXPAND)\n+\tgen_insn (desc);\n+    }\n+\n+  fflush (stdout);\n+  exit (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);\n+  /* NOTREACHED */\n+  return 0;\n+}"}]}