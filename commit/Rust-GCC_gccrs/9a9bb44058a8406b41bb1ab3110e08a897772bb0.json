{"sha": "9a9bb44058a8406b41bb1ab3110e08a897772bb0", "node_id": "C_kwDOANBUbNoAKDlhOWJiNDQwNThhODQwNmI0MWJiMWFiMzExMGUwOGE4OTc3NzJiYjA", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-04-27T13:38:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-27T13:38:41Z"}, "message": "Merge #1184\n\n1184: Fix bad name resolution on path with generic segments r=philberty a=philberty\n\nThis fix breaks down into two commits the first commit fixes the issue directly\r\nthen the second one fixes the regression that was introduced in the first.\r\n\r\nThe TLDR for this patch set is that when we resolve the path here:\r\n\r\n  module::transmute\r\n\r\nThe name-resolver wronly added the specified generic arguments into the canonical\r\npath meaning that the root segment could not be name-resolved such that during\r\ntype resolution we iterate and apply the generic arguments appropriately to the root\r\nsegment.\r\n\r\nIn fixing this it introduced a regression exposing a few more complex issues with\r\ninference variables but for a more complete explanation about that please read the\r\ncommit message from ea38a59ee8329bb7b309400a7de57d53ad7bde31\r\n\r\nFixes #1173 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "99751b78d4ca97cde368351b4aa28aeb23569c84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99751b78d4ca97cde368351b4aa28aeb23569c84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a9bb44058a8406b41bb1ab3110e08a897772bb0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiaUdhCRBK7hj4Ov3rIwAA0P0IAJ/UAnaYqW7vgiJ8XCjBHcBN\nqRmWu8YtTCPZZNUGbqTVHvF31cj468Rkt8kIoVshgVbLC5c27AntKE9d5qerfrX0\n98fq9lpz6r8tvSkjnGzQPaBHaEQGQPkfeaaxBDEd/+lRa8cvT/m0H3nKlI5t6cvb\nKMSPukurACu26gtURy50Fsmw3lA/oC7UrieKWWIZ5hWD+w5srWcF+y4AERPVgtLJ\nDcK60d07BgBNOnrEYSPxrg1GioufjOvBGLT5zJn0OeNR9g+kztAL/MJMFGM89IAi\nnLnNQDXLCEtvBY7nYRgaohONJUQ0qEd3bz6D4XEab4gYRo1cGO09wNcH1+LDrA8=\n=9EZj\n-----END PGP SIGNATURE-----\n", "payload": "tree 99751b78d4ca97cde368351b4aa28aeb23569c84\nparent 60f7f998a2128aeaca1d00e8329bce22491f6f5e\nparent ea38a59ee8329bb7b309400a7de57d53ad7bde31\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1651066721 +0000\ncommitter GitHub <noreply@github.com> 1651066721 +0000\n\nMerge #1184\n\n1184: Fix bad name resolution on path with generic segments r=philberty a=philberty\n\nThis fix breaks down into two commits the first commit fixes the issue directly\r\nthen the second one fixes the regression that was introduced in the first.\r\n\r\nThe TLDR for this patch set is that when we resolve the path here:\r\n\r\n  module::transmute\r\n\r\nThe name-resolver wronly added the specified generic arguments into the canonical\r\npath meaning that the root segment could not be name-resolved such that during\r\ntype resolution we iterate and apply the generic arguments appropriately to the root\r\nsegment.\r\n\r\nIn fixing this it introduced a regression exposing a few more complex issues with\r\ninference variables but for a more complete explanation about that please read the\r\ncommit message from ea38a59ee8329bb7b309400a7de57d53ad7bde31\r\n\r\nFixes #1173 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a9bb44058a8406b41bb1ab3110e08a897772bb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a9bb44058a8406b41bb1ab3110e08a897772bb0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a9bb44058a8406b41bb1ab3110e08a897772bb0/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60f7f998a2128aeaca1d00e8329bce22491f6f5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60f7f998a2128aeaca1d00e8329bce22491f6f5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60f7f998a2128aeaca1d00e8329bce22491f6f5e"}, {"sha": "ea38a59ee8329bb7b309400a7de57d53ad7bde31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea38a59ee8329bb7b309400a7de57d53ad7bde31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea38a59ee8329bb7b309400a7de57d53ad7bde31"}], "stats": {"total": 203, "additions": 96, "deletions": 107}, "files": [{"sha": "aa3e29a99c02106660b270f2ee149dc45fc7d068", "filename": "gcc/rust/hir/tree/rust-hir-path.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a9bb44058a8406b41bb1ab3110e08a897772bb0/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a9bb44058a8406b41bb1ab3110e08a897772bb0/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h?ref=9a9bb44058a8406b41bb1ab3110e08a897772bb0", "patch": "@@ -262,6 +262,8 @@ class PathPattern : public Pattern\n \n   std::vector<PathExprSegment> &get_segments () { return segments; }\n \n+  const std::vector<PathExprSegment> &get_segments () const { return segments; }\n+\n   PathExprSegment &get_root_seg () { return segments.at (0); }\n \n   PathExprSegment get_final_segment () const { return segments.back (); }"}, {"sha": "72846336d23ca9154bf5d9651e8cb94ab8eafa91", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a9bb44058a8406b41bb1ab3110e08a897772bb0/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a9bb44058a8406b41bb1ab3110e08a897772bb0/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=9a9bb44058a8406b41bb1ab3110e08a897772bb0", "patch": "@@ -169,13 +169,8 @@ class ResolvePathSegmentToCanonicalPath\n \treturn CanonicalPath::create_empty ();\n       }\n \n-    std::string generics\n-      = ResolveTypeToCanonicalPath::canonicalize_generic_args (\n-\tseg.get_generic_args ());\n-\n     return CanonicalPath::new_seg (seg.get_node_id (),\n-\t\t\t\t   seg.get_ident_segment ().as_string ()\n-\t\t\t\t     + \"::\" + generics);\n+\t\t\t\t   seg.get_ident_segment ().as_string ());\n   }\n };\n "}, {"sha": "5633751c5a033195ad5a64468c92f8895aab5faa", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a9bb44058a8406b41bb1ab3110e08a897772bb0/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a9bb44058a8406b41bb1ab3110e08a897772bb0/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=9a9bb44058a8406b41bb1ab3110e08a897772bb0", "patch": "@@ -221,13 +221,6 @@ class TypeCheckExpr : public TypeCheckBase\n \n     infered\n       = TyTy::TypeCheckCallExpr::go (function_tyty, expr, variant, context);\n-    if (infered == nullptr)\n-      {\n-\trust_error_at (expr.get_locus (), \"failed to lookup type to CallExpr\");\n-\treturn;\n-      }\n-\n-    infered->set_ref (expr.get_mappings ().get_hirid ());\n   }\n \n   void visit (HIR::MethodCallExpr &expr) override\n@@ -1076,7 +1069,6 @@ class TypeCheckExpr : public TypeCheckBase\n     : TypeCheckBase (), infered (nullptr), inside_loop (inside_loop)\n   {}\n \n-  // Beware: currently returns Tyty::ErrorType or nullptr in case of error.\n   TyTy::BaseType *resolve_root_path (HIR::PathInExpression &expr,\n \t\t\t\t     size_t *offset,\n \t\t\t\t     NodeId *root_resolved_node_id);"}, {"sha": "9960e76dccbf0e382a26f08a84c162f20444b94c", "filename": "gcc/rust/typecheck/rust-hir-type-check-path.cc", "status": "modified", "additions": 25, "deletions": 81, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a9bb44058a8406b41bb1ab3110e08a897772bb0/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a9bb44058a8406b41bb1ab3110e08a897772bb0/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc?ref=9a9bb44058a8406b41bb1ab3110e08a897772bb0", "patch": "@@ -138,27 +138,17 @@ void\n TypeCheckExpr::visit (HIR::PathInExpression &expr)\n {\n   NodeId resolved_node_id = UNKNOWN_NODEID;\n-\n   size_t offset = -1;\n   TyTy::BaseType *tyseg = resolve_root_path (expr, &offset, &resolved_node_id);\n-  rust_assert (tyseg != nullptr);\n-\n   if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n     return;\n \n-  if (expr.get_num_segments () == 1)\n-    {\n-      Location locus = expr.get_segments ().back ().get_locus ();\n-\n-      bool is_big_self\n-\t= expr.get_segments ().front ().get_segment ().as_string ().compare (\n-\t    \"Self\")\n-\t  == 0;\n-      if (!is_big_self && tyseg->needs_generic_substitutions ())\n-\t{\n-\t  tyseg = SubstMapper::InferSubst (tyseg, locus);\n-\t}\n+  if (tyseg->needs_generic_substitutions ())\n+    tyseg = SubstMapper::InferSubst (tyseg, expr.get_locus ());\n \n+  bool fully_resolved = offset == expr.get_segments ().size ();\n+  if (fully_resolved)\n+    {\n       infered = tyseg;\n       return;\n     }\n@@ -171,14 +161,11 @@ TyTy::BaseType *\n TypeCheckExpr::resolve_root_path (HIR::PathInExpression &expr, size_t *offset,\n \t\t\t\t  NodeId *root_resolved_node_id)\n {\n-  TyTy::BaseType *root_tyty = nullptr;\n   *offset = 0;\n   for (size_t i = 0; i < expr.get_num_segments (); i++)\n     {\n       HIR::PathExprSegment &seg = expr.get_segments ().at (i);\n-\n       bool have_more_segments = (expr.get_num_segments () - 1 != i);\n-      bool is_root = *offset == 0 || root_tyty == nullptr;\n       NodeId ast_node_id = seg.get_mappings ().get_nodeid ();\n \n       // then lookup the reference_node_id\n@@ -205,40 +192,30 @@ TypeCheckExpr::resolve_root_path (HIR::PathInExpression &expr, size_t *offset,\n       // ref_node_id is the NodeId that the segments refers to.\n       if (ref_node_id == UNKNOWN_NODEID)\n \t{\n-\t  if (is_root)\n-\t    {\n-\t      rust_error_at (seg.get_locus (),\n-\t\t\t     \"failed to type resolve root segment\");\n-\t      return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n-\t    }\n-\t  return root_tyty;\n+\t  rust_error_at (seg.get_locus (),\n+\t\t\t \"failed to type resolve root segment\");\n+\t  return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n \t}\n \n       // node back to HIR\n       HirId ref;\n       if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n \t\t\t\t\t ref_node_id, &ref))\n \t{\n-\t  if (is_root)\n-\t    {\n-\t      rust_error_at (seg.get_locus (), \"456 reverse lookup failure\");\n-\t      rust_debug_loc (\n-\t\tseg.get_locus (),\n-\t\t\"failure with [%s] mappings [%s] ref_node_id [%u]\",\n-\t\tseg.as_string ().c_str (),\n-\t\tseg.get_mappings ().as_string ().c_str (), ref_node_id);\n+\t  rust_error_at (seg.get_locus (), \"456 reverse lookup failure\");\n+\t  rust_debug_loc (seg.get_locus (),\n+\t\t\t  \"failure with [%s] mappings [%s] ref_node_id [%u]\",\n+\t\t\t  seg.as_string ().c_str (),\n+\t\t\t  seg.get_mappings ().as_string ().c_str (),\n+\t\t\t  ref_node_id);\n \n-\t      return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n-\t    }\n-\n-\t  return root_tyty;\n+\t  return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n \t}\n \n       auto seg_is_module\n \t= (nullptr\n \t   != mappings->lookup_module (expr.get_mappings ().get_crate_num (),\n \t\t\t\t       ref));\n-\n       if (seg_is_module)\n \t{\n \t  // A::B::C::this_is_a_module::D::E::F\n@@ -261,33 +238,8 @@ TypeCheckExpr::resolve_root_path (HIR::PathInExpression &expr, size_t *offset,\n       TyTy::BaseType *lookup = nullptr;\n       if (!context->lookup_type (ref, &lookup))\n \t{\n-\t  if (is_root)\n-\t    {\n-\t      rust_error_at (seg.get_locus (),\n-\t\t\t     \"failed to resolve root segment\");\n-\t      return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n-\t    }\n-\t  return root_tyty;\n-\t}\n-\n-      // if we have a previous segment type\n-      if (root_tyty != nullptr)\n-\t{\n-\t  // if this next segment needs substitution we must apply the\n-\t  // previous type arguments\n-\t  //\n-\t  // such as: GenericStruct::<_>::new(123, 456)\n-\t  if (lookup->needs_generic_substitutions ())\n-\t    {\n-\t      if (!root_tyty->needs_generic_substitutions ())\n-\t\t{\n-\t\t  auto used_args_in_prev_segment\n-\t\t    = GetUsedSubstArgs::From (root_tyty);\n-\t\t  lookup\n-\t\t    = SubstMapperInternal::Resolve (lookup,\n-\t\t\t\t\t\t    used_args_in_prev_segment);\n-\t\t}\n-\t    }\n+\t  rust_error_at (seg.get_locus (), \"failed to resolve root segment\");\n+\t  return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n \t}\n \n       // turbo-fish segment path::<ty>\n@@ -300,16 +252,16 @@ TypeCheckExpr::resolve_root_path (HIR::PathInExpression &expr, size_t *offset,\n \t\t\t     lookup->as_string ().c_str ());\n \t      return new TyTy::ErrorType (lookup->get_ref ());\n \t    }\n-\t  lookup = SubstMapper::Resolve (lookup, expr.get_locus (),\n+\t  lookup = SubstMapper::Resolve (lookup, seg.get_locus (),\n \t\t\t\t\t &seg.get_generic_args ());\n \t}\n \n       *root_resolved_node_id = ref_node_id;\n       *offset = *offset + 1;\n-      root_tyty = lookup;\n+      return lookup;\n     }\n \n-  return root_tyty;\n+  return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n }\n \n void\n@@ -424,19 +376,11 @@ TypeCheckExpr::resolve_segments (NodeId root_resolved_node_id,\n \t  bool ok = context->lookup_type (impl_ty_id, &impl_block_ty);\n \t  rust_assert (ok);\n \n-\t  if (prev_segment->needs_generic_substitutions ())\n-\t    {\n-\t      if (!impl_block_ty->needs_generic_substitutions ())\n-\t\t{\n-\t\t  prev_segment = impl_block_ty;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  HIR::PathExprSegment &pseg = segments.at (i - 1);\n-\t\t  Location locus = pseg.get_locus ();\n-\t\t  prev_segment = SubstMapper::InferSubst (prev_segment, locus);\n-\t\t}\n-\t    }\n+\t  if (impl_block_ty->needs_generic_substitutions ())\n+\t    impl_block_ty\n+\t      = SubstMapper::InferSubst (impl_block_ty, seg.get_locus ());\n+\n+\t  prev_segment = prev_segment->unify (impl_block_ty);\n \t}\n \n       if (tyseg->needs_generic_substitutions ())"}, {"sha": "ee6663877a5b95e40f801ad98b85d5967bc32f80", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a9bb44058a8406b41bb1ab3110e08a897772bb0/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a9bb44058a8406b41bb1ab3110e08a897772bb0/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=9a9bb44058a8406b41bb1ab3110e08a897772bb0", "patch": "@@ -54,18 +54,11 @@ TypeResolution::Resolve (HIR::Crate &crate)\n \n   // default inference variables if possible\n   context->iterate ([&] (HirId id, TyTy::BaseType *ty) mutable -> bool {\n-    if (ty->get_kind () == TyTy::TypeKind::ERROR)\n-      {\n-\trust_error_at (mappings->lookup_location (id),\n-\t\t       \"failure in type resolution for %u\", id);\n-\treturn false;\n-      }\n-\n     // nothing to do\n     if (ty->get_kind () != TyTy::TypeKind::INFER)\n       return true;\n \n-    TyTy::InferType *infer_var = (TyTy::InferType *) ty;\n+    TyTy::InferType *infer_var = static_cast<TyTy::InferType *> (ty);\n     TyTy::BaseType *default_type;\n     bool ok = infer_var->default_type (&default_type);\n     if (!ok)"}, {"sha": "1dd011229c20dd2b1e3d91422589e0f38669e224", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a9bb44058a8406b41bb1ab3110e08a897772bb0/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a9bb44058a8406b41bb1ab3110e08a897772bb0/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=9a9bb44058a8406b41bb1ab3110e08a897772bb0", "patch": "@@ -89,6 +89,11 @@ class BaseRules : public TyVisitor\n     for (auto ref : other->get_combined_refs ())\n       resolved->append_reference (ref);\n \n+    other->append_reference (resolved->get_ref ());\n+    other->append_reference (get_base ()->get_ref ());\n+    get_base ()->append_reference (resolved->get_ref ());\n+    get_base ()->append_reference (other->get_ref ());\n+\n     bool result_resolved = resolved->get_kind () != TyTy::TypeKind::INFER;\n     bool result_is_infer_var = resolved->get_kind () == TyTy::TypeKind::INFER;\n     bool results_is_non_general_infer_var"}, {"sha": "847ca88900f178cd07970b41559c16ab18b82b62", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a9bb44058a8406b41bb1ab3110e08a897772bb0/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a9bb44058a8406b41bb1ab3110e08a897772bb0/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=9a9bb44058a8406b41bb1ab3110e08a897772bb0", "patch": "@@ -263,6 +263,7 @@ TyVar::get_implicit_infer_var (Location locus)\n \t\t\tinfer);\n   mappings->insert_location (mappings->get_current_crate (), infer->get_ref (),\n \t\t\t     locus);\n+\n   return TyVar (infer->get_ref ());\n }\n \n@@ -341,8 +342,34 @@ InferType::cast (BaseType *other)\n BaseType *\n InferType::clone () const\n {\n-  return new InferType (get_ref (), get_ty_ref (), get_infer_kind (),\n-\t\t\tget_ident ().locus, get_combined_refs ());\n+  // clones for inference variables are special in that they _must_ exist within\n+  // the type check context and we must ensure we don't loose the chain\n+  // otherwise we will end up in the missing type annotations case\n+  //\n+  // This means we cannot simply take over the same reference we must generate a\n+  // new ref just like the get_implicit_infer_var code then we can setup the\n+  // chain of references accordingly to ensure we don't loose the ability to\n+  // update the inference variables when we solve the type\n+\n+  auto mappings = Analysis::Mappings::get ();\n+  auto context = Resolver::TypeCheckContext::get ();\n+\n+  InferType *clone\n+    = new InferType (mappings->get_next_hir_id (), get_infer_kind (),\n+\t\t     get_ident ().locus, get_combined_refs ());\n+\n+  context->insert_type (Analysis::NodeMapping (mappings->get_current_crate (),\n+\t\t\t\t\t       UNKNOWN_NODEID,\n+\t\t\t\t\t       clone->get_ref (),\n+\t\t\t\t\t       UNKNOWN_LOCAL_DEFID),\n+\t\t\tclone);\n+  mappings->insert_location (mappings->get_current_crate (), clone->get_ref (),\n+\t\t\t     mappings->lookup_location (get_ref ()));\n+\n+  // setup the chain to reference this\n+  clone->append_reference (get_ref ());\n+\n+  return clone;\n }\n \n bool"}, {"sha": "271ce2c386b6cc5947c10fb3b8a48da59a715d9c", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a9bb44058a8406b41bb1ab3110e08a897772bb0/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a9bb44058a8406b41bb1ab3110e08a897772bb0/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=9a9bb44058a8406b41bb1ab3110e08a897772bb0", "patch": "@@ -955,12 +955,23 @@ class SubstitutionRef\n   BaseType *infer_substitions (Location locus)\n   {\n     std::vector<SubstitutionArg> args;\n+    std::map<std::string, BaseType *> argument_mappings;\n     for (auto &p : get_substs ())\n       {\n \tif (p.needs_substitution ())\n \t  {\n-\t    TyVar infer_var = TyVar::get_implicit_infer_var (locus);\n-\t    args.push_back (SubstitutionArg (&p, infer_var.get_tyty ()));\n+\t    const std::string &symbol = p.get_param_ty ()->get_symbol ();\n+\t    auto it = argument_mappings.find (symbol);\n+\t    if (it == argument_mappings.end ())\n+\t      {\n+\t\tTyVar infer_var = TyVar::get_implicit_infer_var (locus);\n+\t\targs.push_back (SubstitutionArg (&p, infer_var.get_tyty ()));\n+\t\targument_mappings[symbol] = infer_var.get_tyty ();\n+\t      }\n+\t    else\n+\t      {\n+\t\targs.push_back (SubstitutionArg (&p, it->second));\n+\t      }\n \t  }\n \telse\n \t  {"}, {"sha": "b08d7205717fbf86ea565dd723039eaaacfcfced", "filename": "gcc/testsuite/rust/compile/issue-1173.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a9bb44058a8406b41bb1ab3110e08a897772bb0/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1173.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a9bb44058a8406b41bb1ab3110e08a897772bb0/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1173.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1173.rs?ref=9a9bb44058a8406b41bb1ab3110e08a897772bb0", "patch": "@@ -0,0 +1,20 @@\n+// { dg-additional-options \"-w\" }\n+mod mem {\n+    extern \"rust-intrinsic\" {\n+        fn transmute<U, V>(_: U) -> V;\n+    }\n+}\n+\n+pub trait Hasher {\n+    fn write(&mut self, bytes: &[u8]);\n+    fn write_u16(&mut self, i: u16) {\n+        self.write(&mem::transmute::<_, [u8; 2]>(i))\n+    }\n+}\n+\n+pub struct SipHasher;\n+\n+impl Hasher for SipHasher {\n+    #[inline]\n+    fn write(&mut self, msg: &[u8]) {}\n+}"}]}