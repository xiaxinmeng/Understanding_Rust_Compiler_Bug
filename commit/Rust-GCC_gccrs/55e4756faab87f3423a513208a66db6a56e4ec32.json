{"sha": "55e4756faab87f3423a513208a66db6a56e4ec32", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTVlNDc1NmZhYWI4N2YzNDIzYTUxMzIwOGE2NmRiNmE1NmU0ZWMzMg==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2000-12-04T17:23:34Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2000-12-04T17:23:34Z"}, "message": "* md.texi: Add overview, clarify match_dup and define_expand.\n\nFrom-SVN: r38005", "tree": {"sha": "090d4fadab3013db1d7d55cca41cd350895a29a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/090d4fadab3013db1d7d55cca41cd350895a29a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55e4756faab87f3423a513208a66db6a56e4ec32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55e4756faab87f3423a513208a66db6a56e4ec32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55e4756faab87f3423a513208a66db6a56e4ec32", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55e4756faab87f3423a513208a66db6a56e4ec32/comments", "author": null, "committer": null, "parents": [{"sha": "7d4923724f12593d951cbe873d0e6456f7082fc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d4923724f12593d951cbe873d0e6456f7082fc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d4923724f12593d951cbe873d0e6456f7082fc0"}], "stats": {"total": 90, "additions": 90, "deletions": 0}, "files": [{"sha": "f9e7d730b73568c19054d18dc74e545e65baefdd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55e4756faab87f3423a513208a66db6a56e4ec32/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55e4756faab87f3423a513208a66db6a56e4ec32/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=55e4756faab87f3423a513208a66db6a56e4ec32", "patch": "@@ -1,3 +1,7 @@\n+2000-12-04  DJ Delorie  <dj@redhat.com>\n+\n+\t* md.texi: Add overview, clarify match_dup and define_expand.\n+\n 2000-12-04  DJ Delorie  <dj@redhat.com>\n \n \t* print-tree.c (print_node): target-specific builtins print"}, {"sha": "b8c9e378550e5c6c55d3953111f57535073c8b92", "filename": "gcc/md.texi", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55e4756faab87f3423a513208a66db6a56e4ec32/gcc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55e4756faab87f3423a513208a66db6a56e4ec32/gcc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmd.texi?ref=55e4756faab87f3423a513208a66db6a56e4ec32", "patch": "@@ -19,6 +19,7 @@ is inside a quoted string.\n See the next chapter for information on the C header file.\n \n @menu\n+* Overview::            How the machine description is used.\n * Patterns::            How to write instruction patterns.\n * Example::             An explained example of a @code{define_insn} pattern.\n * RTL Template::        The RTL template defines what insns match a pattern.\n@@ -43,6 +44,54 @@ See the next chapter for information on the C header file.\n                         md file.\n @end menu\n \n+@node Overview\n+@section Overview of How the Machine Description is Used\n+\n+There are three main conversions that happen in the compiler:\n+\n+@enumerate\n+\n+@item\n+The front end reads the source code and builds a parse tree.\n+\n+@item\n+The parse tree is used to generate an RTL insn list based on named\n+instruction patterns.\n+\n+@item\n+The insn list is matched against the RTL templates to produce assembler\n+code.\n+\n+@end enumerate\n+\n+For the generate pass, only the names of the insns matter, from either a\n+named @code{define_insn} or a @code{define_expand}.  The compiler will\n+choose the pattern with the right name and apply the operands according\n+to the documentation later in this chapter, without regard for the RTL\n+template or operand constraints.  Note that the names the compiler looks\n+for are hard-coded in the compiler - it will ignore unnamed patterns and\n+patterns with names it doesn't know about, but if you don't provide a\n+named pattern it needs, it will abort.\n+\n+If a @code{define_insn} is used, the template given is inserted into the\n+insn list.  If a @code{define_expand} is used, one of three things\n+happens, based on the condition logic.  The condition logic may manually\n+create new insns for the insn list, say via @code{emit_insn()}, and\n+invoke DONE.  For certain named patterns, it may invoke FAIL to tell the\n+compiler to use an alternate way of performing that task.  If it invokes\n+neither @code{DONE} nor @code{FAIL}, the template given in the pattern\n+is inserted, as if the @code{define_expand} were a @code{define_insn}.\n+\n+Once the insn list is generated, various optimization passes convert,\n+replace, and rearrange the insns in the insn list.  This is where the\n+@code{define_split} and @code{define_peephole} patterns get used, for\n+example.\n+\n+Finally, the insn list's RTL is matched up with the RTL templates in the\n+@code{define_insn} patterns, and those patterns are used to emit the\n+final assembly code.  For this purpose, each named @code{define_insn}\n+acts like it's unnamed, since the names are ignored.\n+\n @node Patterns\n @section Everything about Instruction Patterns\n @cindex patterns\n@@ -267,6 +316,16 @@ number @var{n} has already been determined by a @code{match_operand}\n appearing earlier in the recognition template, and it matches only an\n identical-looking expression.\n \n+Note that @code{match_dup} should not be used to tell the compiler that\n+a particular register is being used for two operands (example:\n+@code{add} that adds one register to another; the second register is\n+both an input operand and the output operand).  Use a matching\n+constraint (@pxref{Simple Constraints}) for those.  @code{match_dup} is for the cases where one\n+operand is used in two places in the template, such as an instruction\n+that computes both a quotient and a remainder, where the opcode takes\n+two input operands but the RTL template has to refer to each of those\n+twice; once for the quotient pattern and once for the remainder pattern.\n+\n @findex match_operator\n @item (match_operator:@var{m} @var{n} @var{predicate} [@var{operands}@dots{}])\n This pattern is a kind of placeholder for a variable RTL expression\n@@ -3235,6 +3294,33 @@ shifting, etc.) and bitfield (@code{extv}, @code{extzv}, and @code{insv})\n operations.\n @end table\n \n+If the preparation falls through (invokes neither @code{DONE} nor\n+@code{FAIL}), then the @code{define_expand} acts like a\n+@code{define_insn} in that the RTL template is used to generate the\n+insn.\n+\n+The RTL template is not used for matching, only for generating the\n+initial insn list.  If the preparation statement always invokes\n+@code{DONE} or @code{FAIL}, the RTL template may be reduced to a simple\n+list of operands, such as this example:\n+\n+@smallexample\n+@group\n+(define_expand \"addsi3\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")\n+   (match_operand:SI 1 \"register_operand\" \"\")\n+   (match_operand:SI 2 \"register_operand\" \"\")]\n+@end group\n+@group\n+  \"\"\n+  \"\n+{\n+  handle_add (operands[0], operands[1], operands[2]);\n+  DONE;\n+}\")\n+@end group\n+@end smallexample\n+\n Here is an example, the definition of left-shift for the SPUR chip:\n \n @smallexample"}]}