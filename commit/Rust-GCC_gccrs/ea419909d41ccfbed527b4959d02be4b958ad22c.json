{"sha": "ea419909d41ccfbed527b4959d02be4b958ad22c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWE0MTk5MDlkNDFjY2ZiZWQ1MjdiNDk1OWQwMmJlNGI5NThhZDIyYw==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-06-01T18:25:35Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-06-01T18:25:35Z"}, "message": "cp-tree.h (TYPE_FOR_JAVA): New macro.\n\na\n\t* cp-tree.h (TYPE_FOR_JAVA):  New macro.\n\t* decl.c, cp-tree.h (java_byte_type_node, java_short_type_node,\n\tjava_int_type_node, java_long_type_node, java_float_type_node,\n\tjava_double_type_node, java_char_type_node, java_boolean_type_node):\n\tNew \"primitive\" types, with predefined names __java_byte etc.\n\t(record_builtin_java_type):  New function.\n\t(init_decl_processing):  Make Java types with record_builtin_java_type.\n\t(pushtag, grokdeclarator):  Set TYPE_FOR_JAVA if in extern \"JAVA\".\n\t(xref_baseypes):  If base class was TYPE_FOR_JAVA, so is this class.\n\t(grokfndecl):  Call check_java_method for Java classes.\n\t* method.c (is_java_type):  Removed.  Replaced with TYPE_FOR_JAVA.\n\t(process_overload_item):  Match types against specific\n\tjava_XX_type_node types, rather than using is_java_type.\n\t* class.c (finish_struct_1):  Don't add default copy constructor\n\tor operator= if TYPE_FOR_JAVA.\n\t(pop_lang_conext):  Restore strict_prototyp proper if Java.\n\t* decl2.c (acceptable_java_type, check_java_method):  New functions.\n\t* pt.c (instantiate_class_template):  Copy TYPE_FOR_JAVA from pattern.\n\t(tsubst):  Move common statement after if statement.\n\t* typeck.c (comptypes):  If strict, TYPE_FOR_JAVA must match.\n\nFrom-SVN: r20175", "tree": {"sha": "2e2c94662fd2d15e43f68afbd4801a03d7e0166e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e2c94662fd2d15e43f68afbd4801a03d7e0166e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea419909d41ccfbed527b4959d02be4b958ad22c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea419909d41ccfbed527b4959d02be4b958ad22c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea419909d41ccfbed527b4959d02be4b958ad22c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea419909d41ccfbed527b4959d02be4b958ad22c/comments", "author": null, "committer": null, "parents": [{"sha": "eff71ab0ab951b6711adf0adac40a0aca6b8e633", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eff71ab0ab951b6711adf0adac40a0aca6b8e633", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eff71ab0ab951b6711adf0adac40a0aca6b8e633"}], "stats": {"total": 89, "additions": 35, "deletions": 54}, "files": [{"sha": "fa423e198159767faf6848cc7580b05acbad5b0d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea419909d41ccfbed527b4959d02be4b958ad22c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea419909d41ccfbed527b4959d02be4b958ad22c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ea419909d41ccfbed527b4959d02be4b958ad22c", "patch": "@@ -60,10 +60,10 @@ Boston, MA 02111-1307, USA.  */\n    0: C_TYPE_FIELDS_READONLY (in RECORD_TYPE or UNION_TYPE).\n    1: TYPE_HAS_CONSTRUCTOR.\n    2: TYPE_HAS_DESTRUCTOR.\n-   3: Not used.\n+   3: TYPE_FOR_JAVA.\n    4: TYPE_NEEDS_DESTRUCTOR.\n    5: IS_AGGR_TYPE.\n-   6: TYPE_BUILT_IN\n+   6: TYPE_BUILT_IN.\n \n    Usage of DECL_LANG_FLAG_?:\n    0: DECL_ERROR_REPORTED (in VAR_DECL).\n@@ -280,6 +280,15 @@ extern tree intSI_type_node, unsigned_intSI_type_node;\n extern tree intDI_type_node, unsigned_intDI_type_node;\n extern tree intTI_type_node, unsigned_intTI_type_node;\n \n+extern tree java_byte_type_node;\n+extern tree java_short_type_node;\n+extern tree java_int_type_node;\n+extern tree java_long_type_node;\n+extern tree java_float_type_node;\n+extern tree java_double_type_node;\n+extern tree java_char_type_node;\n+extern tree java_boolean_type_node;\n+\n extern int current_function_returns_value;\n extern int current_function_returns_null;\n extern tree current_function_return_value;\n@@ -490,6 +499,9 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n /* In a *_TYPE, nonzero means a built-in type.  */\n #define TYPE_BUILT_IN(NODE) TYPE_LANG_FLAG_6(NODE)\n \n+/* True if this a \"Java\" type, defined in 'extern \"Java\"'. */\n+#define TYPE_FOR_JAVA(NODE) TYPE_LANG_FLAG_3(NODE)\n+\n #define DELTA_FROM_VTABLE_ENTRY(ENTRY) \\\n   (!flag_vtable_thunks ? \\\n      TREE_VALUE (CONSTRUCTOR_ELTS (ENTRY)) \\"}, {"sha": "effaf333d8381035389d3e0d57679a01b5c58dd0", "filename": "gcc/cp/method.c", "status": "modified", "additions": 19, "deletions": 52, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea419909d41ccfbed527b4959d02be4b958ad22c/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea419909d41ccfbed527b4959d02be4b958ad22c/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=ea419909d41ccfbed527b4959d02be4b958ad22c", "patch": "@@ -83,7 +83,6 @@ static int issue_ktype PROTO((tree));\n static void build_overload_scope_ref PROTO((tree));\n static void build_mangled_template_parm_index PROTO((char *, tree));\n static int check_btype PROTO((tree));\n-static int is_java_type PROTO((tree));\n \n # define OB_INIT() (scratch_firstobj ? (obstack_free (&scratch_obstack, scratch_firstobj), 0) : 0)\n # define OB_PUTC(C) (obstack_1grow (&scratch_obstack, (C)))\n@@ -1042,7 +1041,7 @@ build_mangled_name (parmtypes, begin, end)\n               typevec[maxtype++] = parmtype;\n \n               if (TREE_USED (parmtype) && parmtype == typevec[maxtype-2]\n-\t\t  && ! is_java_type (parmtype))\n+\t\t  && ! TYPE_FOR_JAVA (parmtype))\n                 {\n                   Nrepeats++;\n                   continue;\n@@ -1068,7 +1067,7 @@ build_mangled_name (parmtypes, begin, end)\n               if ((parmtype != TYPE_MAIN_VARIANT (parmtype)\n \t\t   || (TREE_CODE (parmtype) != INTEGER_TYPE\n \t\t       && TREE_CODE (parmtype) != REAL_TYPE))\n-\t\t  && ! is_java_type (parmtype))\n+\t\t  && ! TYPE_FOR_JAVA (parmtype))\n                 TREE_USED (parmtype) = 1;\n             }\n         if (TYPE_PTRMEMFUNC_P (parmtype))\n@@ -1115,31 +1114,14 @@ process_modifiers (parmtype)\n   if (TREE_CODE (parmtype) == INTEGER_TYPE\n       && (TYPE_MAIN_VARIANT (parmtype)\n \t  == unsigned_type (TYPE_MAIN_VARIANT (parmtype)))\n-      && ! is_java_type (parmtype))\n+      && ! TYPE_FOR_JAVA (parmtype))\n     {\n       OB_PUTC ('U');\n     }\n   if (TYPE_VOLATILE (parmtype))\n     OB_PUTC ('V');\n }\n \n-/* True iff TYPE was declared as a \"Java\" type (inside extern \"Java\"). */\n-\n-static int\n-is_java_type (type)\n-     tree type;\n-{\n-  if (TYPE_NAME (type) != NULL_TREE)\n-    {\n-      tree decl = TYPE_NAME (type);\n-      if (TREE_CODE (decl) == TYPE_DECL\n-\t  && DECL_LANG_SPECIFIC (decl) != NULL\n-\t  && DECL_LANGUAGE (decl) == lang_java)\n-\treturn 1;\n-    }\n-  return 0;\n-}\n-\n /* Check to see if a tree node has been entered into the Bcode typelist \n    if not, add it. Otherwise emit the code and return TRUE */\n static int \n@@ -1311,52 +1293,33 @@ process_overload_item (parmtype, extra_Gcode)\n       }\n \n     case INTEGER_TYPE:\n-      /* \"Java\" integer types should mangle the same on all platforms,\n-\t and only depend on precision, not target 'int' size. */\n-      if (is_java_type (parmtype))\n-\t{\n-\t  if (TREE_UNSIGNED (parmtype))\n-\t    {\n-\t      switch (TYPE_PRECISION (parmtype))\n-\t\t{\n-\t\tcase  8:  OB_PUTC ('b');  return;\n-\t\tcase 16:  OB_PUTC ('w');  return;\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      switch (TYPE_PRECISION (parmtype))\n-\t\t{\n-\t\tcase  8:  OB_PUTC ('c');  return;\n-\t\tcase 16:  OB_PUTC ('s');  return;\n-\t\tcase 32:  OB_PUTC ('i');  return;\n-\t\tcase 64:  OB_PUTC ('x');  return;\n-\t\t}\n-\t    }\n-\t}\n-\n       parmtype = TYPE_MAIN_VARIANT (parmtype);\n       if (parmtype == integer_type_node\n-          || parmtype == unsigned_type_node)\n+          || parmtype == unsigned_type_node\n+\t  || parmtype == java_int_type_node)\n         OB_PUTC ('i');\n       else if (parmtype == long_integer_type_node\n                || parmtype == long_unsigned_type_node)\n         OB_PUTC ('l');\n       else if (parmtype == short_integer_type_node\n-               || parmtype == short_unsigned_type_node)\n+               || parmtype == short_unsigned_type_node\n+\t       || parmtype == java_short_type_node)\n         OB_PUTC ('s');\n       else if (parmtype == signed_char_type_node)\n         {\n           OB_PUTC ('S');\n           OB_PUTC ('c');\n         }\n       else if (parmtype == char_type_node\n-               || parmtype == unsigned_char_type_node)\n+               || parmtype == unsigned_char_type_node\n+\t       || parmtype == java_byte_type_node)\n         OB_PUTC ('c');\n-      else if (parmtype == wchar_type_node)\n+      else if (parmtype == wchar_type_node\n+\t       || parmtype == java_char_type_node)\n         OB_PUTC ('w');\n       else if (parmtype == long_long_integer_type_node\n-          || parmtype == long_long_unsigned_type_node)\n+\t       || parmtype == long_long_unsigned_type_node\n+\t       || parmtype == java_long_type_node)\n         OB_PUTC ('x');\n #if 0\n       /* it would seem there is no way to enter these in source code,\n@@ -1365,6 +1328,8 @@ process_overload_item (parmtype, extra_Gcode)\n           || parmtype == long_long_long_unsigned_type_node)\n         OB_PUTC ('q');\n #endif\n+      else if (parmtype == java_boolean_type_node)\n+\tOB_PUTC ('b');\n       else\n         my_friendly_abort (73);\n       break;\n@@ -1377,9 +1342,11 @@ process_overload_item (parmtype, extra_Gcode)\n       parmtype = TYPE_MAIN_VARIANT (parmtype);\n       if (parmtype == long_double_type_node)\n         OB_PUTC ('r');\n-      else if (parmtype == double_type_node)\n+      else if (parmtype == double_type_node\n+\t       || parmtype == java_double_type_node)\n         OB_PUTC ('d');\n-      else if (parmtype == float_type_node)\n+      else if (parmtype == float_type_node\n+\t       || parmtype == java_float_type_node)\n         OB_PUTC ('f');\n       else my_friendly_abort (74);\n       break;"}, {"sha": "785c33bb5d2bd4f4def8425a8ca45ebf3cd4e367", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea419909d41ccfbed527b4959d02be4b958ad22c/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea419909d41ccfbed527b4959d02be4b958ad22c/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=ea419909d41ccfbed527b4959d02be4b958ad22c", "patch": "@@ -754,6 +754,8 @@ comptypes (type1, type2, strict)\n     return 0;\n   if (TYPE_VOLATILE (t1) != TYPE_VOLATILE (t2))\n     return 0;\n+  if (strict > 0 && TYPE_FOR_JAVA (t1) != TYPE_FOR_JAVA (t2))\n+    return 0;\n \n   /* Allow for two different type nodes which have essentially the same\n      definition.  Note that we already checked for equality of the type"}]}