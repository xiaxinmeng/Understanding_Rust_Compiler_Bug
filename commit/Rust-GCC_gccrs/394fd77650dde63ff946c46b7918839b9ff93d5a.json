{"sha": "394fd77650dde63ff946c46b7918839b9ff93d5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk0ZmQ3NzY1MGRkZTYzZmY5NDZjNDZiNzkxODgzOWI5ZmY5M2Q1YQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2001-02-14T10:49:27Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2001-02-14T10:49:27Z"}, "message": "Kill remnants of this is variable.\n\ncp:\n\tKill remnants of this is variable.\n\t* cp-tree.h (flag_this_is_variable): Remove.\n\t* decl2.c (flag_this_is_variable): Remove.\n\t* class.c (fixed_type_or_null): Add cdtor parm. Adjust.\n\t(build_vbase_path): The path is non-static, even in a cdtor.\n\t(resolves_to_fixed_type_p): Add additional return value.\n\t* search.c (init_vbase_pointers): Adjust.\n\t* tree.c (lvalue_p_1): Adjust.\n\t* typeck.c (mark_addressable): Adjust.\n\nFrom-SVN: r39676", "tree": {"sha": "eeb43419ca40544e35069e461123426d4e99b08f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eeb43419ca40544e35069e461123426d4e99b08f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/394fd77650dde63ff946c46b7918839b9ff93d5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/394fd77650dde63ff946c46b7918839b9ff93d5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/394fd77650dde63ff946c46b7918839b9ff93d5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/394fd77650dde63ff946c46b7918839b9ff93d5a/comments", "author": null, "committer": null, "parents": [{"sha": "c7c0ae3d7fb8d06435a7edf500aa0fa7e4407555", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7c0ae3d7fb8d06435a7edf500aa0fa7e4407555", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7c0ae3d7fb8d06435a7edf500aa0fa7e4407555"}], "stats": {"total": 97, "additions": 55, "deletions": 42}, "files": [{"sha": "8cbbe7ce9d9bea1fea92929a669f95b7d4bed679", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/394fd77650dde63ff946c46b7918839b9ff93d5a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/394fd77650dde63ff946c46b7918839b9ff93d5a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=394fd77650dde63ff946c46b7918839b9ff93d5a", "patch": "@@ -1,3 +1,15 @@\n+2001-02-14  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tKill remnants of this is variable.\n+\t* cp-tree.h (flag_this_is_variable): Remove.\n+\t* decl2.c (flag_this_is_variable): Remove.\n+\t* class.c (fixed_type_or_null): Add cdtor parm. Adjust.\n+\t(build_vbase_path): The path is non-static, even in a cdtor.\n+\t(resolves_to_fixed_type_p): Add additional return value.\n+\t* search.c (init_vbase_pointers): Adjust.\n+\t* tree.c (lvalue_p_1): Adjust.\n+\t* typeck.c (mark_addressable): Adjust.\n+\n 2001-02-14  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* pt.c (unify): Don't check cv quals of array types."}, {"sha": "55bac3711ea0631a7b3699c3166d0b5bf0c5969e", "filename": "gcc/cp/class.c", "status": "modified", "additions": 41, "deletions": 27, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/394fd77650dde63ff946c46b7918839b9ff93d5a/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/394fd77650dde63ff946c46b7918839b9ff93d5a/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=394fd77650dde63ff946c46b7918839b9ff93d5a", "patch": "@@ -131,7 +131,7 @@ static void maybe_warn_about_overly_private_class PARAMS ((tree));\n static int field_decl_cmp PARAMS ((const tree *, const tree *));\n static int method_name_cmp PARAMS ((const tree *, const tree *));\n static tree add_implicitly_declared_members PARAMS ((tree, int, int, int));\n-static tree fixed_type_or_null PARAMS ((tree, int *));\n+static tree fixed_type_or_null PARAMS ((tree, int *, int *));\n static tree resolve_address_of_overloaded_function PARAMS ((tree, tree, int,\n \t\t\t\t\t\t\t  int, int, tree));\n static void build_vtable_entry_ref PARAMS ((tree, tree, tree));\n@@ -381,6 +381,9 @@ build_vbase_path (code, type, expr, path, nonnull)\n      convert back to the type we want.  Until that is done, we only optimize\n      if the complete type is the same type as expr has.  */\n   fixed_type_p = resolves_to_fixed_type_p (expr, &nonnull);\n+  if (fixed_type_p < 0)\n+    /* Virtual base layout is not fixed, even in ctors and dtors. */\n+    fixed_type_p = 0;\n \n   if (!fixed_type_p && TREE_SIDE_EFFECTS (expr))\n     expr = save_expr (expr);\n@@ -5370,9 +5373,10 @@ finish_struct (t, attributes)\n    before this function is called.  */\n \n static tree\n-fixed_type_or_null (instance, nonnull)\n+fixed_type_or_null (instance, nonnull, cdtorp)\n      tree instance;\n      int *nonnull;\n+     int *cdtorp;\n {\n   switch (TREE_CODE (instance))\n     {\n@@ -5400,31 +5404,31 @@ fixed_type_or_null (instance, nonnull)\n \t    *nonnull = 1;\n \t  return TREE_TYPE (instance);\n \t}\n-      return fixed_type_or_null (TREE_OPERAND (instance, 0), nonnull);\n+      return fixed_type_or_null (TREE_OPERAND (instance, 0), nonnull, cdtorp);\n \n     case RTL_EXPR:\n       return NULL_TREE;\n \n     case PLUS_EXPR:\n     case MINUS_EXPR:\n+      if (TREE_CODE (TREE_OPERAND (instance, 0)) == ADDR_EXPR)\n+\treturn fixed_type_or_null (TREE_OPERAND (instance, 0), nonnull, cdtorp);\n       if (TREE_CODE (TREE_OPERAND (instance, 1)) == INTEGER_CST)\n \t/* Propagate nonnull.  */\n-\tfixed_type_or_null (TREE_OPERAND (instance, 0), nonnull);\n-      if (TREE_CODE (TREE_OPERAND (instance, 0)) == ADDR_EXPR)\n-\treturn fixed_type_or_null (TREE_OPERAND (instance, 0), nonnull);\n+\tfixed_type_or_null (TREE_OPERAND (instance, 0), nonnull, cdtorp);\n       return NULL_TREE;\n \n     case NOP_EXPR:\n     case CONVERT_EXPR:\n-      return fixed_type_or_null (TREE_OPERAND (instance, 0), nonnull);\n+      return fixed_type_or_null (TREE_OPERAND (instance, 0), nonnull, cdtorp);\n \n     case ADDR_EXPR:\n       if (nonnull)\n \t*nonnull = 1;\n-      return fixed_type_or_null (TREE_OPERAND (instance, 0), nonnull);\n+      return fixed_type_or_null (TREE_OPERAND (instance, 0), nonnull, cdtorp);\n \n     case COMPONENT_REF:\n-      return fixed_type_or_null (TREE_OPERAND (instance, 1), nonnull);\n+      return fixed_type_or_null (TREE_OPERAND (instance, 1), nonnull, cdtorp);\n \n     case VAR_DECL:\n     case FIELD_DECL:\n@@ -5444,21 +5448,25 @@ fixed_type_or_null (instance, nonnull)\n \t    *nonnull = 1;\n \t  return TREE_TYPE (instance);\n \t}\n-      else if (nonnull)\n-\t{\n-\t  if (instance == current_class_ptr\n-\t      && flag_this_is_variable <= 0)\n-\t    {\n-\t      /* Normally, 'this' must be non-null.  */\n-\t      if (flag_this_is_variable == 0)\n-\t\t*nonnull = 1;\n-\n-\t      /* <0 means we're in a constructor and we know our type.  */\n-\t      if (flag_this_is_variable < 0)\n-\t\treturn TREE_TYPE (TREE_TYPE (instance));\n-\t    }\n-\t  else if (TREE_CODE (TREE_TYPE (instance)) == REFERENCE_TYPE)\n-\t    /* Reference variables should be references to objects.  */\n+      else if (instance == current_class_ptr)\n+        {\n+          if (nonnull)\n+            *nonnull = 1;\n+        \n+          /* if we're in a ctor or dtor, we know our type. */\n+          if (DECL_LANG_SPECIFIC (current_function_decl)\n+              && (DECL_CONSTRUCTOR_P (current_function_decl)\n+                  || DECL_DESTRUCTOR_P (current_function_decl)))\n+            {\n+              if (cdtorp)\n+                *cdtorp = 1;\n+              return TREE_TYPE (TREE_TYPE (instance));\n+            }\n+        }\n+      else if (TREE_CODE (TREE_TYPE (instance)) == REFERENCE_TYPE)\n+        {\n+          /* Reference variables should be references to objects.  */\n+          if (nonnull)\n \t    *nonnull = 1;\n \t}\n       return NULL_TREE;\n@@ -5470,7 +5478,9 @@ fixed_type_or_null (instance, nonnull)\n \n /* Return non-zero if the dynamic type of INSTANCE is known, and equivalent\n    to the static type.  We also handle the case where INSTANCE is really\n-   a pointer.\n+   a pointer. Return negative if this is a ctor/dtor. There the dynamic type\n+   is known, but this might not be the most derived base of the original object,\n+   and hence virtual bases may not be layed out according to this type.\n \n    Used to determine whether the virtual function table is needed\n    or not.\n@@ -5485,12 +5495,16 @@ resolves_to_fixed_type_p (instance, nonnull)\n      int *nonnull;\n {\n   tree t = TREE_TYPE (instance);\n-  tree fixed = fixed_type_or_null (instance, nonnull);\n+  int cdtorp = 0;\n+  \n+  tree fixed = fixed_type_or_null (instance, nonnull, &cdtorp);\n   if (fixed == NULL_TREE)\n     return 0;\n   if (POINTER_TYPE_P (t))\n     t = TREE_TYPE (t);\n-  return same_type_ignoring_top_level_qualifiers_p (t, fixed);\n+  if (!same_type_ignoring_top_level_qualifiers_p (t, fixed))\n+    return 0;\n+  return cdtorp ? -1 : 1;\n }\n \n \f"}, {"sha": "17238730e6f4e5848b2764970c3ddbcba2d6c538", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/394fd77650dde63ff946c46b7918839b9ff93d5a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/394fd77650dde63ff946c46b7918839b9ff93d5a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=394fd77650dde63ff946c46b7918839b9ff93d5a", "patch": "@@ -3420,10 +3420,6 @@ extern varray_type local_classes;\n \f\n /* Things for handling inline functions.  */\n \n-/* Negative values means we know `this' to be of static type.  */\n-\n-extern int flag_this_is_variable;\n-\n /* Nonzero means do emit exported implementations of functions even if\n    they can be inlined.  */\n "}, {"sha": "5c2940c6dd55c14475bd25ee812f854a8e122c4d", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/394fd77650dde63ff946c46b7918839b9ff93d5a/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/394fd77650dde63ff946c46b7918839b9ff93d5a/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=394fd77650dde63ff946c46b7918839b9ff93d5a", "patch": "@@ -346,11 +346,6 @@ int flag_labels_ok;\n int flag_ms_extensions;\n \n /* C++ specific flags.  */   \n-/* Zero means that `this' is a *const.  This gives nice behavior in the\n-   2.0 world.  1 gives 1.2-compatible behavior.  2 gives Spring behavior.\n-   -2 means we're constructing an object and it has fixed type.  */\n-\n-int flag_this_is_variable;\n \n /* Nonzero means we should attempt to elide constructors when possible.  */\n "}, {"sha": "75d33e8e40bcfd936cd965edfa20e5a6ebb3b061", "filename": "gcc/cp/search.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/394fd77650dde63ff946c46b7918839b9ff93d5a/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/394fd77650dde63ff946c46b7918839b9ff93d5a/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=394fd77650dde63ff946c46b7918839b9ff93d5a", "patch": "@@ -2388,9 +2388,7 @@ init_vbase_pointers (type, decl_ptr)\n   if (TYPE_USES_VIRTUAL_BASECLASSES (type))\n     {\n       struct vbase_info vi;\n-      int old_flag = flag_this_is_variable;\n       tree binfo = TYPE_BINFO (type);\n-      flag_this_is_variable = -2;\n \n       /* Find all the virtual base classes, marking them for later\n \t initialization.  */\n@@ -2408,7 +2406,6 @@ init_vbase_pointers (type, decl_ptr)\n \t\tmarked_vtable_pathp,\n \t\tNULL);\n \n-      flag_this_is_variable = old_flag;\n       return vi.inits;\n     }\n "}, {"sha": "608602a555bab9481776177dbaab67631d1c4be2", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/394fd77650dde63ff946c46b7918839b9ff93d5a/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/394fd77650dde63ff946c46b7918839b9ff93d5a/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=394fd77650dde63ff946c46b7918839b9ff93d5a", "patch": "@@ -65,7 +65,7 @@ lvalue_p_1 (ref, treat_class_rvalues_as_lvalues)\n   if (TREE_CODE (TREE_TYPE (ref)) == REFERENCE_TYPE)\n     return clk_ordinary;\n \n-  if (ref == current_class_ptr && flag_this_is_variable <= 0)\n+  if (ref == current_class_ptr)\n     return clk_none;\n \n   switch (TREE_CODE (ref))"}, {"sha": "3fd103f1c0b3bf34e912757dda56eeb6a73e5d5e", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/394fd77650dde63ff946c46b7918839b9ff93d5a/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/394fd77650dde63ff946c46b7918839b9ff93d5a/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=394fd77650dde63ff946c46b7918839b9ff93d5a", "patch": "@@ -4886,8 +4886,7 @@ mark_addressable (exp)\n       case PARM_DECL:\n \tif (x == current_class_ptr)\n \t  {\n-\t    if (! flag_this_is_variable)\n-\t      error (\"cannot take the address of `this', which is an ravlue expression\");\n+            error (\"cannot take the address of `this', which is an rvalue expression\");\n \t    TREE_ADDRESSABLE (x) = 1; /* so compiler doesn't die later */\n \t    return 1;\n \t  }"}]}