{"sha": "070ef6f4c41ea9bf4de0fde93860d7e65d8a186c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDcwZWY2ZjRjNDFlYTliZjRkZTBmZGU5Mzg2MGQ3ZTY1ZDhhMTg2Yw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-05-18T20:53:55Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-05-18T20:53:55Z"}, "message": "genrecog.c (enum decision_type): Add DT_elt_zero-wide_safe.\n\n\t* genrecog.c (enum decision_type): Add DT_elt_zero-wide_safe.\n\t(add_to_sequence): Make that decision type.\n\t(maybe_both_true_2, nodes_identical_1, factor_tests): Use it.\n\t(write_switch, write_cond, debug_decision_2): Likewise.\n\nFrom-SVN: r42285", "tree": {"sha": "627691fcac565077e820d95b520630df11375761", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/627691fcac565077e820d95b520630df11375761"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/070ef6f4c41ea9bf4de0fde93860d7e65d8a186c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/070ef6f4c41ea9bf4de0fde93860d7e65d8a186c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/070ef6f4c41ea9bf4de0fde93860d7e65d8a186c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/070ef6f4c41ea9bf4de0fde93860d7e65d8a186c/comments", "author": null, "committer": null, "parents": [{"sha": "8d81254bc03fbe7eb90d8db3f52be64a168732be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d81254bc03fbe7eb90d8db3f52be64a168732be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d81254bc03fbe7eb90d8db3f52be64a168732be"}], "stats": {"total": 44, "additions": 30, "deletions": 14}, "files": [{"sha": "5ad0e4514e16deaa17c9d42747e813aaf2ee8a35", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/070ef6f4c41ea9bf4de0fde93860d7e65d8a186c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/070ef6f4c41ea9bf4de0fde93860d7e65d8a186c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=070ef6f4c41ea9bf4de0fde93860d7e65d8a186c", "patch": "@@ -1,5 +1,10 @@\n Fri May 18 07:26:34 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* genrecog.c (enum decision_type): Add DT_elt_zero-wide_safe.\n+\t(add_to_sequence): Make that decision type.\n+\t(maybe_both_true_2, nodes_identical_1, factor_tests): Use it.\n+\t(write_switch, write_cond, debug_decision_2): Likewise.\n+\n \t* dbxout.c (dbxout_type): Use host_integerp and fix typo in testing\n \tfor INTEGER_TYPE.\n \t(dbxout_symbol, case TYPE_DECL): Don't generate tag for records of"}, {"sha": "228a5701eb472955e19b6d9207122d7df468993a", "filename": "gcc/genrecog.c", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/070ef6f4c41ea9bf4de0fde93860d7e65d8a186c/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/070ef6f4c41ea9bf4de0fde93860d7e65d8a186c/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=070ef6f4c41ea9bf4de0fde93860d7e65d8a186c", "patch": "@@ -84,12 +84,13 @@ struct decision_test\n   struct decision_test *next;\n \n   /* These types are roughly in the order in which we'd like to test them.  */\n-  enum decision_type {\n-    DT_mode, DT_code, DT_veclen,\n-    DT_elt_zero_int, DT_elt_one_int, DT_elt_zero_wide,\n-    DT_veclen_ge, DT_dup, DT_pred, DT_c_test, \n-    DT_accept_op, DT_accept_insn\n-  } type;\n+  enum decision_type\n+    {\n+      DT_mode, DT_code, DT_veclen,\n+      DT_elt_zero_int, DT_elt_one_int, DT_elt_zero_wide, DT_elt_zero_wide_safe,\n+      DT_veclen_ge, DT_dup, DT_pred, DT_c_test, \n+      DT_accept_op, DT_accept_insn\n+    } type;\n \n   union\n   {\n@@ -956,10 +957,16 @@ add_to_sequence (pattern, last, position, insn_type, top)\n \t}\n       else if (fmt[i] == 'w')\n \t{\n+\t  /* If this value actually fits in an int, we can use a switch\n+\t     statement here, so indicate that.  */\n+\t  enum decision_type type\n+\t    = ((int) XWINT (pattern, i) == XWINT (pattern, i))\n+\t      ? DT_elt_zero_wide_safe : DT_elt_zero_wide;\n+\n \t  if (i != 0)\n \t    abort ();\n \n-\t  test = new_decision_test (DT_elt_zero_wide, &place);\n+\t  test = new_decision_test (type, &place);\n \t  test->u.intval = XWINT (pattern, i);\n \t}\n       else if (fmt[i] == 'E')\n@@ -1055,6 +1062,7 @@ maybe_both_true_2 (d1, d2)\n \tcase DT_elt_zero_int:\n \tcase DT_elt_one_int:\n \tcase DT_elt_zero_wide:\n+\tcase DT_elt_zero_wide_safe:\n \t  return d1->u.intval == d2->u.intval;\n \n \tdefault:\n@@ -1278,6 +1286,7 @@ nodes_identical_1 (d1, d2)\n     case DT_elt_zero_int:\n     case DT_elt_one_int:\n     case DT_elt_zero_wide:\n+    case DT_elt_zero_wide_safe:\n       return d1->u.intval == d2->u.intval;\n \n     case DT_accept_op:\n@@ -1488,7 +1497,7 @@ factor_tests (head)\n \t  && type != DT_veclen\n \t  && type != DT_elt_zero_int\n \t  && type != DT_elt_one_int\n-\t  && type != DT_elt_zero_wide)\n+\t  && type != DT_elt_zero_wide_safe)\n \tcontinue;\n \n       /* If we'd been performing more than one test, create a new node\n@@ -1858,12 +1867,8 @@ write_switch (start, depth)\n \t   || type == DT_veclen\n \t   || type == DT_elt_zero_int\n \t   || type == DT_elt_one_int\n-\t   || type == DT_elt_zero_wide)\n+\t   || type == DT_elt_zero_wide_safe)\n     {\n-      /* The argument is casted to int.  In case HOST_WIDE_INT is more exact,\n-         we can't safely construct switch statement over it.  */\n-      if (type == DT_elt_zero_wide && HOST_BITS_PER_WIDE_INT > sizeof (int) * CHAR_BIT)\n-\t  return p;\n       printf (\"  switch (\");\n       switch (type)\n \t{\n@@ -1879,7 +1884,7 @@ write_switch (start, depth)\n \tcase DT_elt_one_int:\n \t  printf (\"XINT (x%d, 1)\", depth);\n \t  break;\n-\tcase DT_elt_zero_wide:\n+\tcase DT_elt_zero_wide_safe:\n \t  /* Convert result of XWINT to int for portability since some C\n \t     compilers won't do it and some will.  */\n \t  printf (\"(int) XWINT (x%d, 0)\", depth);\n@@ -1914,6 +1919,7 @@ write_switch (start, depth)\n \t    case DT_elt_zero_int:\n \t    case DT_elt_one_int:\n \t    case DT_elt_zero_wide:\n+\t    case DT_elt_zero_wide_safe:\n \t      printf (HOST_WIDE_INT_PRINT_DEC, p->tests->u.intval);\n \t      break;\n \t    default:\n@@ -1970,6 +1976,7 @@ write_cond (p, depth, subroutine_type)\n       break;\n \n     case DT_elt_zero_wide:\n+    case DT_elt_zero_wide_safe:\n       printf (\"XWINT (x%d, 0) == \", depth);\n       printf (HOST_WIDE_INT_PRINT_DEC, p->u.intval);\n       break;\n@@ -2742,6 +2749,10 @@ debug_decision_2 (test)\n       fprintf (stderr, \"elt0_w=\");\n       fprintf (stderr, HOST_WIDE_INT_PRINT_DEC, test->u.intval);\n       break;\n+    case DT_elt_zero_wide_safe:\n+      fprintf (stderr, \"elt0_ws=\");\n+      fprintf (stderr, HOST_WIDE_INT_PRINT_DEC, test->u.intval);\n+      break;\n     case DT_veclen_ge:\n       fprintf (stderr, \"veclen>=%d\", test->u.veclen);\n       break;"}]}