{"sha": "f8398dc6cd234455c19917473b572e9d2c962b7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjgzOThkYzZjZDIzNDQ1NWMxOTkxNzQ3M2I1NzJlOWQyYzk2MmI3ZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-21T14:17:34Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-21T14:17:34Z"}, "message": "[multiple changes]\n\n2010-06-21  Thomas Quinot  <quinot@adacore.com>\n\n\t* bindgen.ads: Update comments.\n\n2010-06-21  Vincent Celier  <celier@adacore.com>\n\n\t* gnatbind.adb: Suppress dupicates when listing the sources in the\n\tclosure (switch -R).\n\n2010-06-21  Emmanuel Briot  <briot@adacore.com>\n\n\t* s-regpat.adb (Link_Tail): Fix error when size of the pattern matcher\n\tis too small.\n\n2010-06-21  Emmanuel Briot  <briot@adacore.com>\n\n\t* g-expect.adb, g-expect.ads (First_Dead_Process, Free, Has_Process):\n\tNew subprograms.\n\t(Expect_Internal): No longer raises an exception, so that it can set\n\tout parameters as well. When a process has died, reset its Input_Fd\n\tto Invalid_Fd, so that when using multiple processes we can find out\n\twhich process has died.\n\nFrom-SVN: r161081", "tree": {"sha": "fcdc07ccbc094a2af953364160e0ab8df6859827", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fcdc07ccbc094a2af953364160e0ab8df6859827"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8398dc6cd234455c19917473b572e9d2c962b7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8398dc6cd234455c19917473b572e9d2c962b7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8398dc6cd234455c19917473b572e9d2c962b7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8398dc6cd234455c19917473b572e9d2c962b7e/comments", "author": null, "committer": null, "parents": [{"sha": "fe4e525c241f01ef04d2405172e337dfb1d63dda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe4e525c241f01ef04d2405172e337dfb1d63dda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe4e525c241f01ef04d2405172e337dfb1d63dda"}], "stats": {"total": 436, "additions": 320, "deletions": 116}, "files": [{"sha": "6c6e09cdfd13e497ddc12c6f540353221c83e340", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8398dc6cd234455c19917473b572e9d2c962b7e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8398dc6cd234455c19917473b572e9d2c962b7e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f8398dc6cd234455c19917473b572e9d2c962b7e", "patch": "@@ -1,3 +1,26 @@\n+2010-06-21  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* bindgen.ads: Update comments.\n+\n+2010-06-21  Vincent Celier  <celier@adacore.com>\n+\n+\t* gnatbind.adb: Suppress dupicates when listing the sources in the\n+\tclosure (switch -R).\n+\n+2010-06-21  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* s-regpat.adb (Link_Tail): Fix error when size of the pattern matcher\n+\tis too small.\n+\n+2010-06-21  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* g-expect.adb, g-expect.ads (First_Dead_Process, Free, Has_Process):\n+\tNew subprograms.\n+\t(Expect_Internal): No longer raises an exception, so that it can set\n+\tout parameters as well. When a process has died, reset its Input_Fd\n+\tto Invalid_Fd, so that when using multiple processes we can find out\n+\twhich process has died.\n+\n 2010-06-21  Robert Dewar  <dewar@adacore.com>\n \n \t* s-regpat.adb, s-tpoben.adb, sem_attr.adb, sem_util.adb, sem_util.ads,"}, {"sha": "96d2e306888b0b1552dd2d140ed41cca756e903c", "filename": "gcc/ada/bindgen.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8398dc6cd234455c19917473b572e9d2c962b7e/gcc%2Fada%2Fbindgen.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8398dc6cd234455c19917473b572e9d2c962b7e/gcc%2Fada%2Fbindgen.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.ads?ref=f8398dc6cd234455c19917473b572e9d2c962b7e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -24,7 +24,7 @@\n ------------------------------------------------------------------------------\n \n --  This package contains the routines to output the binder file. This is\n---  a C program which contains the following:\n+--  an Ada or C program which contains the following:\n \n --     initialization for main program case\n --     sequence of calls to elaboration routines in appropriate order"}, {"sha": "d2872fdd0d93f06003844175d904bd2417283970", "filename": "gcc/ada/g-expect.adb", "status": "modified", "additions": 169, "deletions": 68, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8398dc6cd234455c19917473b572e9d2c962b7e/gcc%2Fada%2Fg-expect.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8398dc6cd234455c19917473b572e9d2c962b7e/gcc%2Fada%2Fg-expect.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-expect.adb?ref=f8398dc6cd234455c19917473b572e9d2c962b7e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 2000-2009, AdaCore                     --\n+--                     Copyright (C) 2000-2010, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -45,18 +45,26 @@ package body GNAT.Expect is\n \n    type Array_Of_Pd is array (Positive range <>) of Process_Descriptor_Access;\n \n+   Expect_Process_Died   : constant Expect_Match := -100;\n+   Expect_Internal_Error : constant Expect_Match := -101;\n+   --  Additional possible outputs of Expect_Internal. These are not visible in\n+   --  the spec because the user will never see them.\n+\n    procedure Expect_Internal\n      (Descriptors : in out Array_Of_Pd;\n       Result      : out Expect_Match;\n       Timeout     : Integer;\n       Full_Buffer : Boolean);\n    --  Internal function used to read from the process Descriptor.\n    --\n-   --  Three outputs are possible:\n+   --  Several outputs are possible:\n    --     Result=Expect_Timeout, if no output was available before the timeout\n    --        expired.\n    --     Result=Expect_Full_Buffer, if Full_Buffer is True and some characters\n    --        had to be discarded from the internal buffer of Descriptor.\n+   --     Result=Express_Process_Died if one of the processes was terminated.\n+   --        That process's Input_Fd is set to Invalid_FD\n+   --     Result=Express_Internal_Error\n    --     Result=<integer>, indicates how many characters were added to the\n    --        internal buffer. These characters are from indexes\n    --        Descriptor.Buffer_Index - Result + 1 .. Descriptor.Buffer_Index\n@@ -211,7 +219,9 @@ package body GNAT.Expect is\n       Next_Filter    : Filter_List;\n \n    begin\n-      Close (Descriptor.Input_Fd);\n+      if Descriptor.Input_Fd /= Invalid_FD then\n+         Close (Descriptor.Input_Fd);\n+      end if;\n \n       if Descriptor.Error_Fd /= Descriptor.Output_Fd then\n          Close (Descriptor.Error_Fd);\n@@ -344,10 +354,17 @@ package body GNAT.Expect is\n \n          Expect_Internal (Descriptors, N, Timeout_Tmp, Full_Buffer);\n \n-         if N = Expect_Timeout or else N = Expect_Full_Buffer then\n-            Result := N;\n-            return;\n-         end if;\n+         case N is\n+            when Expect_Internal_Error | Expect_Process_Died =>\n+               raise Process_Died;\n+\n+            when Expect_Timeout | Expect_Full_Buffer =>\n+               Result := N;\n+               return;\n+\n+            when others =>\n+               null;  --  See below\n+         end case;\n \n          --  Calculate the timeout for the next turn\n \n@@ -493,10 +510,17 @@ package body GNAT.Expect is\n \n          Expect_Internal (Descriptors, N, Timeout, Full_Buffer);\n \n-         if N = Expect_Timeout or else N = Expect_Full_Buffer then\n-            Result := N;\n-            return;\n-         end if;\n+         case N is\n+            when Expect_Internal_Error | Expect_Process_Died =>\n+               raise Process_Died;\n+\n+            when Expect_Timeout | Expect_Full_Buffer =>\n+               Result := N;\n+               return;\n+\n+            when others =>\n+               null;  --  Continue\n+         end case;\n       end loop;\n    end Expect;\n \n@@ -515,7 +539,9 @@ package body GNAT.Expect is\n \n       for J in Descriptors'Range loop\n          Descriptors (J) := Regexps (J).Descriptor;\n-         Reinitialize_Buffer (Regexps (J).Descriptor.all);\n+         if Descriptors (J) /= null then\n+            Reinitialize_Buffer (Regexps (J).Descriptor.all);\n+         end if;\n       end loop;\n \n       loop\n@@ -526,25 +552,36 @@ package body GNAT.Expect is\n          --  checking the regexps).\n \n          for J in Regexps'Range loop\n-            Match (Regexps (J).Regexp.all,\n-                   Regexps (J).Descriptor.Buffer\n-                     (1 .. Regexps (J).Descriptor.Buffer_Index),\n-                   Matched);\n-\n-            if Matched (0) /= No_Match then\n-               Result := Expect_Match (J);\n-               Regexps (J).Descriptor.Last_Match_Start := Matched (0).First;\n-               Regexps (J).Descriptor.Last_Match_End := Matched (0).Last;\n-               return;\n+            if Regexps (J).Regexp /= null\n+               and then Regexps (J).Descriptor /= null\n+            then\n+               Match (Regexps (J).Regexp.all,\n+                      Regexps (J).Descriptor.Buffer\n+                        (1 .. Regexps (J).Descriptor.Buffer_Index),\n+                      Matched);\n+\n+               if Matched (0) /= No_Match then\n+                  Result := Expect_Match (J);\n+                  Regexps (J).Descriptor.Last_Match_Start := Matched (0).First;\n+                  Regexps (J).Descriptor.Last_Match_End := Matched (0).Last;\n+                  return;\n+               end if;\n             end if;\n          end loop;\n \n          Expect_Internal (Descriptors, N, Timeout, Full_Buffer);\n \n-         if N = Expect_Timeout or else N = Expect_Full_Buffer then\n-            Result := N;\n-            return;\n-         end if;\n+         case N is\n+            when Expect_Internal_Error | Expect_Process_Died =>\n+               raise Process_Died;\n+\n+            when Expect_Timeout | Expect_Full_Buffer =>\n+               Result := N;\n+               return;\n+\n+            when others =>\n+               null;  --  Continue\n+         end case;\n       end loop;\n    end Expect;\n \n@@ -564,21 +601,30 @@ package body GNAT.Expect is\n       N : Integer;\n \n       type File_Descriptor_Array is\n-        array (Descriptors'Range) of File_Descriptor;\n+        array (0 .. Descriptors'Length - 1) of File_Descriptor;\n       Fds : aliased File_Descriptor_Array;\n+      Fds_Count : Natural := 0;\n+\n+      Fds_To_Descriptor : array (Fds'Range) of Integer;\n+      --  Maps file descriptor entries from Fds to entries in Descriptors.\n+      --  They do not have the same index when entries in Descriptors are null.\n \n-      type Integer_Array is array (Descriptors'Range) of Integer;\n+      type Integer_Array is array (Fds'Range) of Integer;\n       Is_Set : aliased Integer_Array;\n \n    begin\n       for J in Descriptors'Range loop\n-         Fds (J) := Descriptors (J).Output_Fd;\n+         if Descriptors (J) /= null then\n+            Fds (Fds'First + Fds_Count) := Descriptors (J).Output_Fd;\n+            Fds_To_Descriptor (Fds'First + Fds_Count) := J;\n+            Fds_Count := Fds_Count + 1;\n \n-         if Descriptors (J).Buffer_Size = 0 then\n-            Buffer_Size := Integer'Max (Buffer_Size, 4096);\n-         else\n-            Buffer_Size :=\n-              Integer'Max (Buffer_Size, Descriptors (J).Buffer_Size);\n+            if Descriptors (J).Buffer_Size = 0 then\n+               Buffer_Size := Integer'Max (Buffer_Size, 4096);\n+            else\n+               Buffer_Size :=\n+                 Integer'Max (Buffer_Size, Descriptors (J).Buffer_Size);\n+            end if;\n          end if;\n       end loop;\n \n@@ -587,19 +633,23 @@ package body GNAT.Expect is\n          --  Buffer used for input. This is allocated only once, not for\n          --  every iteration of the loop\n \n+         D : Integer;\n+         --  Index in Descriptors\n+\n       begin\n          --  Loop until we match or we have a timeout\n \n          loop\n             Num_Descriptors :=\n-              Poll (Fds'Address, Fds'Length, Timeout, Is_Set'Address);\n+              Poll (Fds'Address, Fds_Count, Timeout, Is_Set'Address);\n \n             case Num_Descriptors is\n \n                --  Error?\n \n                when -1 =>\n-                  raise Process_Died;\n+                  Result := Expect_Internal_Error;\n+                  return;\n \n                --  Timeout?\n \n@@ -610,59 +660,64 @@ package body GNAT.Expect is\n                --  Some input\n \n                when others =>\n-                  for J in Descriptors'Range loop\n-                     if Is_Set (J) = 1 then\n-                        Buffer_Size := Descriptors (J).Buffer_Size;\n+                  for F in Fds'Range loop\n+                     if Is_Set (F) = 1 then\n+                        D := Fds_To_Descriptor (F);\n+\n+                        Buffer_Size := Descriptors (D).Buffer_Size;\n \n                         if Buffer_Size = 0 then\n                            Buffer_Size := 4096;\n                         end if;\n \n-                        N := Read (Descriptors (J).Output_Fd, Buffer'Address,\n+                        N := Read (Descriptors (D).Output_Fd, Buffer'Address,\n                                    Buffer_Size);\n \n                         --  Error or End of file\n \n                         if N <= 0 then\n                            --  ??? Note that ddd tries again up to three times\n                            --  in that case. See LiterateA.C:174\n-                           raise Process_Died;\n+\n+                           Descriptors (D).Input_Fd := Invalid_FD;\n+                           Result := Expect_Process_Died;\n+                           return;\n \n                         else\n                            --  If there is no limit to the buffer size\n \n-                           if Descriptors (J).Buffer_Size = 0 then\n+                           if Descriptors (D).Buffer_Size = 0 then\n \n                               declare\n-                                 Tmp : String_Access := Descriptors (J).Buffer;\n+                                 Tmp : String_Access := Descriptors (D).Buffer;\n \n                               begin\n                                  if Tmp /= null then\n-                                    Descriptors (J).Buffer :=\n+                                    Descriptors (D).Buffer :=\n                                       new String (1 .. Tmp'Length + N);\n-                                    Descriptors (J).Buffer (1 .. Tmp'Length) :=\n+                                    Descriptors (D).Buffer (1 .. Tmp'Length) :=\n                                       Tmp.all;\n-                                    Descriptors (J).Buffer\n+                                    Descriptors (D).Buffer\n                                       (Tmp'Length + 1 .. Tmp'Length + N) :=\n                                       Buffer (1 .. N);\n                                     Free (Tmp);\n-                                    Descriptors (J).Buffer_Index :=\n-                                      Descriptors (J).Buffer'Last;\n+                                    Descriptors (D).Buffer_Index :=\n+                                      Descriptors (D).Buffer'Last;\n \n                                  else\n-                                    Descriptors (J).Buffer :=\n+                                    Descriptors (D).Buffer :=\n                                       new String (1 .. N);\n-                                    Descriptors (J).Buffer.all :=\n+                                    Descriptors (D).Buffer.all :=\n                                       Buffer (1 .. N);\n-                                    Descriptors (J).Buffer_Index := N;\n+                                    Descriptors (D).Buffer_Index := N;\n                                  end if;\n                               end;\n \n                            else\n                               --  Add what we read to the buffer\n \n-                              if Descriptors (J).Buffer_Index + N >\n-                                Descriptors (J).Buffer_Size\n+                              if Descriptors (D).Buffer_Index + N >\n+                                Descriptors (D).Buffer_Size\n                               then\n                                  --  If the user wants to know when we have\n                                  --  read more than the buffer can contain.\n@@ -675,33 +730,33 @@ package body GNAT.Expect is\n                                  --  Keep as much as possible from the buffer,\n                                  --  and forget old characters.\n \n-                                 Descriptors (J).Buffer\n-                                   (1 .. Descriptors (J).Buffer_Size - N) :=\n-                                  Descriptors (J).Buffer\n-                                   (N - Descriptors (J).Buffer_Size +\n-                                    Descriptors (J).Buffer_Index + 1 ..\n-                                    Descriptors (J).Buffer_Index);\n-                                 Descriptors (J).Buffer_Index :=\n-                                   Descriptors (J).Buffer_Size - N;\n+                                 Descriptors (D).Buffer\n+                                   (1 .. Descriptors (D).Buffer_Size - N) :=\n+                                  Descriptors (D).Buffer\n+                                   (N - Descriptors (D).Buffer_Size +\n+                                    Descriptors (D).Buffer_Index + 1 ..\n+                                    Descriptors (D).Buffer_Index);\n+                                 Descriptors (D).Buffer_Index :=\n+                                   Descriptors (D).Buffer_Size - N;\n                               end if;\n \n                               --  Keep what we read in the buffer\n \n-                              Descriptors (J).Buffer\n-                                (Descriptors (J).Buffer_Index + 1 ..\n-                                 Descriptors (J).Buffer_Index + N) :=\n+                              Descriptors (D).Buffer\n+                                (Descriptors (D).Buffer_Index + 1 ..\n+                                 Descriptors (D).Buffer_Index + N) :=\n                                 Buffer (1 .. N);\n-                              Descriptors (J).Buffer_Index :=\n-                                Descriptors (J).Buffer_Index + N;\n+                              Descriptors (D).Buffer_Index :=\n+                                Descriptors (D).Buffer_Index + N;\n                            end if;\n \n                            --  Call each of the output filter with what we\n                            --  read.\n \n                            Call_Filters\n-                             (Descriptors (J).all, Buffer (1 .. N), Output);\n+                             (Descriptors (D).all, Buffer (1 .. N), Output);\n \n-                           Result := Expect_Match (N);\n+                           Result := Expect_Match (D);\n                            return;\n                         end if;\n                      end if;\n@@ -730,6 +785,24 @@ package body GNAT.Expect is\n         (Descriptor.Last_Match_Start .. Descriptor.Last_Match_End);\n    end Expect_Out_Match;\n \n+   ------------------------\n+   -- First_Dead_Process --\n+   ------------------------\n+\n+   function First_Dead_Process\n+     (Regexp : Multiprocess_Regexp_Array) return Natural is\n+   begin\n+      for R in Regexp'Range loop\n+         if Regexp (R).Descriptor /= null\n+           and then Regexp (R).Descriptor.Input_Fd = GNAT.OS_Lib.Invalid_FD\n+         then\n+            return R;\n+         end if;\n+      end loop;\n+\n+      return 0;\n+   end First_Dead_Process;\n+\n    -----------\n    -- Flush --\n    -----------\n@@ -785,6 +858,18 @@ package body GNAT.Expect is\n       end loop;\n    end Flush;\n \n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free (Regexp : in out Multiprocess_Regexp) is\n+      procedure Unchecked_Free is new Ada.Unchecked_Deallocation\n+        (Process_Descriptor'Class, Process_Descriptor_Access);\n+   begin\n+      Unchecked_Free (Regexp.Descriptor);\n+      Free (Regexp.Regexp);\n+   end Free;\n+\n    ------------------------\n    -- Get_Command_Output --\n    ------------------------\n@@ -915,6 +1000,15 @@ package body GNAT.Expect is\n       return Descriptor.Pid;\n    end Get_Pid;\n \n+   -----------------\n+   -- Has_Process --\n+   -----------------\n+\n+   function Has_Process (Regexp : Multiprocess_Regexp_Array) return Boolean is\n+   begin\n+      return Regexp /= (Regexp'Range => (null, null));\n+   end Has_Process;\n+\n    ---------------\n    -- Interrupt --\n    ---------------\n@@ -1136,6 +1230,13 @@ package body GNAT.Expect is\n \n          Expect_Internal\n            (Descriptors, Result, Timeout => 0, Full_Buffer => False);\n+\n+         if Result = Expect_Internal_Error\n+           or else Result = Expect_Process_Died\n+         then\n+            raise Process_Died;\n+         end if;\n+\n          Descriptor.Last_Match_End := Descriptor.Buffer_Index;\n \n          --  Empty the buffer"}, {"sha": "5c535831e986ccd7bed5725aaa7a8779c4c2b4d2", "filename": "gcc/ada/g-expect.ads", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8398dc6cd234455c19917473b572e9d2c962b7e/gcc%2Fada%2Fg-expect.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8398dc6cd234455c19917473b572e9d2c962b7e/gcc%2Fada%2Fg-expect.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-expect.ads?ref=f8398dc6cd234455c19917473b572e9d2c962b7e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 2000-2009, AdaCore                     --\n+--                     Copyright (C) 2000-2010, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -466,15 +466,51 @@ package GNAT.Expect is\n       Regexp     : Pattern_Matcher_Access;\n    end record;\n    type Multiprocess_Regexp_Array is array (Positive range <>)\n-     of Multiprocess_Regexp;\n+   of Multiprocess_Regexp;\n+\n+   procedure Free (Regexp : in out Multiprocess_Regexp);\n+   --  Free the memory occupied by Regexp\n+\n+   function Has_Process (Regexp : Multiprocess_Regexp_Array) return Boolean;\n+   --  Return True if at least one entry in Regexp is non-null, ie there is\n+   --  still at least one process to monitor\n+\n+   function First_Dead_Process\n+     (Regexp : Multiprocess_Regexp_Array) return Natural;\n+   --  Find the first entry in Regexp that corresponds to a dead process that\n+   --  wasn't Free-d yet.\n+   --  This function is called in general when Expect (below) raises the\n+   --  exception Process_Died.\n+   --  This returns 0 if no process has died yet.\n \n    procedure Expect\n      (Result      : out Expect_Match;\n       Regexps     : Multiprocess_Regexp_Array;\n       Matched     : out GNAT.Regpat.Match_Array;\n       Timeout     : Integer := 10_000;\n       Full_Buffer : Boolean := False);\n-   --  Same as above, but for multi processes\n+   --  Same as above, but for multi processes. Any of the entries in\n+   --  Regexps can have a null Descriptor or Regexp. Such entries will\n+   --  simply be ignored. Therefore when a process terminates, you can\n+   --  simply reset its entry.\n+   --  The expect loop would therefore look like:\n+   --\n+   --     Processes : Multiprocess_Regexp_Array (...) := ...;\n+   --     R         : Natural;\n+   --\n+   --     while Has_Process (Processes) loop\n+   --        begin\n+   --           Expect (Result, Processes, Timeout => -1);\n+   --           ... process output of process Result (output, full buffer,...)\n+   --\n+   --        exception\n+   --           when Process_Died =>\n+   --               --  Free memory\n+   --               R := First_Dead_Process (Processes);\n+   --               Close (Processes (R).Descriptor.all, Status);\n+   --               Free (Processes (R));\n+   --        end;\n+   --     end loop;\n \n    procedure Expect\n      (Result      : out Expect_Match;"}, {"sha": "8b6edbd3aab668f8179b4fde77c7cf1de9f95ff2", "filename": "gcc/ada/gnatbind.adb", "status": "modified", "additions": 84, "deletions": 41, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8398dc6cd234455c19917473b572e9d2c962b7e/gcc%2Fada%2Fgnatbind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8398dc6cd234455c19917473b572e9d2c962b7e/gcc%2Fada%2Fgnatbind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatbind.adb?ref=f8398dc6cd234455c19917473b572e9d2c962b7e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -45,6 +45,7 @@ with Rident;   use Rident;\n with Snames;\n with Switch;   use Switch;\n with Switch.B; use Switch.B;\n+with Table;\n with Targparm; use Targparm;\n with Types;    use Types;\n \n@@ -815,55 +816,97 @@ begin\n             --  sources) if -R was used.\n \n             if List_Closure then\n-               if not Zero_Formatting then\n-                  Write_Eol;\n-                  Write_Str (\"REFERENCED SOURCES\");\n-                  Write_Eol;\n-               end if;\n-\n-               for J in reverse Elab_Order.First .. Elab_Order.Last loop\n-\n-                  --  Do not include the sources of the runtime\n+               declare\n+                  package Sources is new Table.Table\n+                    (Table_Component_Type => File_Name_Type,\n+                     Table_Index_Type     => Natural,\n+                     Table_Low_Bound      => 1,\n+                     Table_Initial        => 10,\n+                     Table_Increment      => 100,\n+                     Table_Name           => \"Gnatbind.Sources\");\n+                  --  Table to record the sources in the closure, to avoid\n+                  --  dupications.\n+\n+                  Source : File_Name_Type;\n+\n+                  function Put_In_Sources (S : File_Name_Type) return Boolean;\n+                  --  Check if S is already in table Sources and put in Sources\n+                  --  if it is not. Return False if the source is already in\n+                  --  Sources, and True if it is added.\n+\n+                  --------------------\n+                  -- Put_In_Sources --\n+                  --------------------\n+\n+                  function Put_In_Sources (S : File_Name_Type)\n+                                           return Boolean\n+                  is\n+                  begin\n+                     for J in 1 .. Sources.Last loop\n+                        if Sources.Table (J) = S then\n+                           return False;\n+                        end if;\n+                     end loop;\n \n-                  if not Is_Internal_File_Name\n-                           (Units.Table (Elab_Order.Table (J)).Sfile)\n-                  then\n-                     if not Zero_Formatting then\n-                        Write_Str (\"   \");\n-                     end if;\n+                     Sources.Append (S);\n+                     return True;\n+                  end Put_In_Sources;\n \n-                     Write_Str\n-                       (Get_Name_String\n-                          (Units.Table (Elab_Order.Table (J)).Sfile));\n+               begin\n+                  if not Zero_Formatting then\n+                     Write_Eol;\n+                     Write_Str (\"REFERENCED SOURCES\");\n                      Write_Eol;\n                   end if;\n-               end loop;\n \n-               --  Subunits do not appear in the elaboration table because they\n-               --  are subsumed by their parent units, but we need to list them\n-               --  for other tools. For now they are listed after other files,\n-               --  rather than right after their parent, since there is no easy\n-               --  link between the elaboration table and the ALIs table ???\n-               --  Note also that subunits may appear repeatedly in the list,\n-               --  if the parent unit appears in the context of several units\n-               --  in the closure.\n-\n-               for J in Sdep.First .. Sdep.Last loop\n-                  if Sdep.Table (J).Subunit_Name /= No_Name\n-                    and then not Is_Internal_File_Name (Sdep.Table (J).Sfile)\n-                  then\n-                     if not Zero_Formatting then\n-                        Write_Str (\"   \");\n+                  for J in reverse Elab_Order.First .. Elab_Order.Last loop\n+\n+                     Source := Units.Table (Elab_Order.Table (J)).Sfile;\n+\n+                     --  Do not include the sources of the runtime and do not\n+                     --  include the same source several times.\n+\n+                     if Put_In_Sources (Source)\n+                       and then not Is_Internal_File_Name (Source)\n+                     then\n+                        if not Zero_Formatting then\n+                           Write_Str (\"   \");\n+                        end if;\n+\n+                        Write_Str (Get_Name_String  (Source));\n+                        Write_Eol;\n                      end if;\n+                  end loop;\n+\n+                  --  Subunits do not appear in the elaboration table because\n+                  --  they are subsumed by their parent units, but we need to\n+                  --  list them for other tools. For now they are listed after\n+                  --  other files, rather than right after their parent, since\n+                  --  there is no easy link between the elaboration table and\n+                  --  the ALIs table ??? As subunits may appear repeatedly in\n+                  --  the list, if the parent unit appears in the context of\n+                  --  several units in the closure, duplicates are suppressed.\n+\n+                  for J in Sdep.First .. Sdep.Last loop\n+                     Source := Sdep.Table (J).Sfile;\n+\n+                     if Sdep.Table (J).Subunit_Name /= No_Name\n+                       and then Put_In_Sources (Source)\n+                       and then not Is_Internal_File_Name (Source)\n+                     then\n+                        if not Zero_Formatting then\n+                           Write_Str (\"   \");\n+                        end if;\n+\n+                        Write_Str (Get_Name_String (Source));\n+                        Write_Eol;\n+                     end if;\n+                  end loop;\n \n-                     Write_Str (Get_Name_String (Sdep.Table (J).Sfile));\n+                  if not Zero_Formatting then\n                      Write_Eol;\n                   end if;\n-               end loop;\n-\n-               if not Zero_Formatting then\n-                  Write_Eol;\n-               end if;\n+               end;\n             end if;\n          end if;\n       end if;"}, {"sha": "27a108c1d588be76779d89a865dfbda28d7d3e45", "filename": "gcc/ada/s-regpat.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8398dc6cd234455c19917473b572e9d2c962b7e/gcc%2Fada%2Fs-regpat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8398dc6cd234455c19917473b572e9d2c962b7e/gcc%2Fada%2Fs-regpat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-regpat.adb?ref=f8398dc6cd234455c19917473b572e9d2c962b7e", "patch": "@@ -802,10 +802,11 @@ package body System.Regpat is\n          Offset : Pointer;\n \n       begin\n-         --  Find last node\n+         --  Find last node (the size of the pattern matcher might be too\n+         --  small, so don't try to read past its end)\n \n          Scan := P;\n-         while Scan <= PM.Size loop\n+         while Scan + 3 <= PM.Size loop\n             Temp := Get_Next (Program, Scan);\n             exit when Temp = Scan;\n             Scan := Temp;"}]}