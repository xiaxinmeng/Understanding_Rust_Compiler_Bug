{"sha": "c7a0240aa55b4f7a2d11d33bd12af7a40f42aa55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdhMDI0MGFhNTViNGY3YTJkMTFkMzNiZDEyYWY3YTQwZjQyYWE1NQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2007-03-30T18:17:31Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2007-03-30T18:17:31Z"}, "message": "regmove.c: Move all of pass_stack_adjustments from here...\n\n\t* regmove.c: Move all of pass_stack_adjustments from here...\n\t* combine-stack-adj.c: ...to this new file.\n\t* Makefile.in: Add rules for combine-stack-adj.o.\n\nFrom-SVN: r123363", "tree": {"sha": "5b08a202336d3cf204fbdef82908681ce8677f13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b08a202336d3cf204fbdef82908681ce8677f13"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7a0240aa55b4f7a2d11d33bd12af7a40f42aa55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7a0240aa55b4f7a2d11d33bd12af7a40f42aa55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7a0240aa55b4f7a2d11d33bd12af7a40f42aa55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7a0240aa55b4f7a2d11d33bd12af7a40f42aa55/comments", "author": null, "committer": null, "parents": [{"sha": "1c917b030e1f7076688278694fbab514cfb6d5e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c917b030e1f7076688278694fbab514cfb6d5e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c917b030e1f7076688278694fbab514cfb6d5e5"}], "stats": {"total": 950, "additions": 506, "deletions": 444}, "files": [{"sha": "f60049ff6abd0a8a62b2a725b93c1721a562e8bc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a0240aa55b4f7a2d11d33bd12af7a40f42aa55/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a0240aa55b4f7a2d11d33bd12af7a40f42aa55/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c7a0240aa55b4f7a2d11d33bd12af7a40f42aa55", "patch": "@@ -1,3 +1,9 @@\n+2007-03-30  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* regmove.c: Move all of pass_stack_adjustments from here...\n+\t* combine-stack-adj.c: ...to this new file.\n+\t* Makefile.in: Add rules for combine-stack-adj.o.\n+\n 2007-03-30  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \tPR tree-optimization/31383"}, {"sha": "05fb4ee0be144b516224fa03d68366cbec216847", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a0240aa55b4f7a2d11d33bd12af7a40f42aa55/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a0240aa55b4f7a2d11d33bd12af7a40f42aa55/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c7a0240aa55b4f7a2d11d33bd12af7a40f42aa55", "patch": "@@ -969,6 +969,7 @@ OBJS-common = \\\n \tcfgloopmanip.o \\\n \tcfgrtl.o \\\n \tcombine.o \\\n+\tcombine-stack-adj.o \\\n \tconvert.o \\\n \tcoverage.o \\\n \tcse.o \\\n@@ -2679,6 +2680,10 @@ regmove.o : regmove.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    insn-config.h $(TIMEVAR_H) tree-pass.h \\\n    $(RECOG_H) output.h $(REGS_H) hard-reg-set.h $(FLAGS_H) $(FUNCTION_H) \\\n    $(EXPR_H) $(BASIC_BLOCK_H) toplev.h $(TM_P_H) except.h reload.h\n+combine-stack-adj.o : combine-stack-adj.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   $(TM_H) $(RTL_H) insn-config.h $(TIMEVAR_H) tree-pass.h \\\n+   $(RECOG_H) output.h $(REGS_H) hard-reg-set.h $(FLAGS_H) $(FUNCTION_H) \\\n+   $(EXPR_H) $(BASIC_BLOCK_H) toplev.h $(TM_P_H) except.h reload.h\n ddg.o : ddg.c $(DDG_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TARGET_H) \\\n    toplev.h $(RTL_H) $(TM_P_H) $(REGS_H) $(FUNCTION_H) \\\n    $(FLAGS_H) insn-config.h $(INSN_ATTR_H) except.h $(RECOG_H) \\"}, {"sha": "fb1480a012d4ce8bcc7f3b368e0d4f59eb9fac51", "filename": "gcc/combine-stack-adj.c", "status": "added", "additions": 489, "deletions": 0, "changes": 489, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a0240aa55b4f7a2d11d33bd12af7a40f42aa55/gcc%2Fcombine-stack-adj.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a0240aa55b4f7a2d11d33bd12af7a40f42aa55/gcc%2Fcombine-stack-adj.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine-stack-adj.c?ref=c7a0240aa55b4f7a2d11d33bd12af7a40f42aa55", "patch": "@@ -0,0 +1,489 @@\n+/* Combine stack adjustments.\n+   Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+/* Track stack adjustments and stack memory references.  Attempt to\n+   reduce the number of stack adjustments by back-propagating across\n+   the memory references.\n+\n+   This is intended primarily for use with targets that do not define\n+   ACCUMULATE_OUTGOING_ARGS.  It is of significantly more value to\n+   targets that define PREFERRED_STACK_BOUNDARY more aligned than\n+   STACK_BOUNDARY (e.g. x86), or if not all registers can be pushed\n+   (e.g. x86 fp regs) which would ordinarily have to be implemented\n+   as a sub/mov pair due to restrictions in calls.c.\n+\n+   Propagation stops when any of the insns that need adjusting are\n+   (a) no longer valid because we've exceeded their range, (b) a\n+   non-trivial push instruction, or (c) a call instruction.\n+\n+   Restriction B is based on the assumption that push instructions\n+   are smaller or faster.  If a port really wants to remove all\n+   pushes, it should have defined ACCUMULATE_OUTGOING_ARGS.  The\n+   one exception that is made is for an add immediately followed\n+   by a push.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"insn-config.h\"\n+#include \"recog.h\"\n+#include \"output.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"flags.h\"\n+#include \"function.h\"\n+#include \"expr.h\"\n+#include \"basic-block.h\"\n+#include \"except.h\"\n+#include \"toplev.h\"\n+#include \"reload.h\"\n+#include \"timevar.h\"\n+#include \"tree-pass.h\"\n+\n+\f\n+/* Turn STACK_GROWS_DOWNWARD into a boolean.  */\n+#ifdef STACK_GROWS_DOWNWARD\n+#undef STACK_GROWS_DOWNWARD\n+#define STACK_GROWS_DOWNWARD 1\n+#else\n+#define STACK_GROWS_DOWNWARD 0\n+#endif\n+\n+/* This structure records stack memory references between stack adjusting\n+   instructions.  */\n+\n+struct csa_memlist\n+{\n+  HOST_WIDE_INT sp_offset;\n+  rtx insn, *mem;\n+  struct csa_memlist *next;\n+};\n+\n+static int stack_memref_p (rtx);\n+static rtx single_set_for_csa (rtx);\n+static void free_csa_memlist (struct csa_memlist *);\n+static struct csa_memlist *record_one_stack_memref (rtx, rtx *,\n+\t\t\t\t\t\t    struct csa_memlist *);\n+static int try_apply_stack_adjustment (rtx, struct csa_memlist *,\n+\t\t\t\t       HOST_WIDE_INT, HOST_WIDE_INT);\n+static void combine_stack_adjustments_for_block (basic_block);\n+static int record_stack_memrefs (rtx *, void *);\n+\n+\n+/* Main entry point for stack adjustment combination.  */\n+\n+static void\n+combine_stack_adjustments (void)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    combine_stack_adjustments_for_block (bb);\n+}\n+\n+/* Recognize a MEM of the form (sp) or (plus sp const).  */\n+\n+static int\n+stack_memref_p (rtx x)\n+{\n+  if (!MEM_P (x))\n+    return 0;\n+  x = XEXP (x, 0);\n+\n+  if (x == stack_pointer_rtx)\n+    return 1;\n+  if (GET_CODE (x) == PLUS\n+      && XEXP (x, 0) == stack_pointer_rtx\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Recognize either normal single_set or the hack in i386.md for\n+   tying fp and sp adjustments.  */\n+\n+static rtx\n+single_set_for_csa (rtx insn)\n+{\n+  int i;\n+  rtx tmp = single_set (insn);\n+  if (tmp)\n+    return tmp;\n+\n+  if (!NONJUMP_INSN_P (insn)\n+      || GET_CODE (PATTERN (insn)) != PARALLEL)\n+    return NULL_RTX;\n+\n+  tmp = PATTERN (insn);\n+  if (GET_CODE (XVECEXP (tmp, 0, 0)) != SET)\n+    return NULL_RTX;\n+\n+  for (i = 1; i < XVECLEN (tmp, 0); ++i)\n+    {\n+      rtx this = XVECEXP (tmp, 0, i);\n+\n+      /* The special case is allowing a no-op set.  */\n+      if (GET_CODE (this) == SET\n+\t  && SET_SRC (this) == SET_DEST (this))\n+\t;\n+      else if (GET_CODE (this) != CLOBBER\n+\t       && GET_CODE (this) != USE)\n+\treturn NULL_RTX;\n+    }\n+\n+  return XVECEXP (tmp, 0, 0);\n+}\n+\n+/* Free the list of csa_memlist nodes.  */\n+\n+static void\n+free_csa_memlist (struct csa_memlist *memlist)\n+{\n+  struct csa_memlist *next;\n+  for (; memlist ; memlist = next)\n+    {\n+      next = memlist->next;\n+      free (memlist);\n+    }\n+}\n+\n+/* Create a new csa_memlist node from the given memory reference.\n+   It is already known that the memory is stack_memref_p.  */\n+\n+static struct csa_memlist *\n+record_one_stack_memref (rtx insn, rtx *mem, struct csa_memlist *next_memlist)\n+{\n+  struct csa_memlist *ml;\n+\n+  ml = XNEW (struct csa_memlist);\n+\n+  if (XEXP (*mem, 0) == stack_pointer_rtx)\n+    ml->sp_offset = 0;\n+  else\n+    ml->sp_offset = INTVAL (XEXP (XEXP (*mem, 0), 1));\n+\n+  ml->insn = insn;\n+  ml->mem = mem;\n+  ml->next = next_memlist;\n+\n+  return ml;\n+}\n+\n+/* Attempt to apply ADJUST to the stack adjusting insn INSN, as well\n+   as each of the memories in MEMLIST.  Return true on success.  */\n+\n+static int\n+try_apply_stack_adjustment (rtx insn, struct csa_memlist *memlist, HOST_WIDE_INT new_adjust,\n+\t\t\t    HOST_WIDE_INT delta)\n+{\n+  struct csa_memlist *ml;\n+  rtx set;\n+\n+  set = single_set_for_csa (insn);\n+  validate_change (insn, &XEXP (SET_SRC (set), 1), GEN_INT (new_adjust), 1);\n+\n+  for (ml = memlist; ml ; ml = ml->next)\n+    validate_change\n+      (ml->insn, ml->mem,\n+       replace_equiv_address_nv (*ml->mem,\n+\t\t\t\t plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\tml->sp_offset - delta)), 1);\n+\n+  if (apply_change_group ())\n+    {\n+      /* Succeeded.  Update our knowledge of the memory references.  */\n+      for (ml = memlist; ml ; ml = ml->next)\n+\tml->sp_offset -= delta;\n+\n+      return 1;\n+    }\n+  else\n+    return 0;\n+}\n+\n+/* Called via for_each_rtx and used to record all stack memory references in\n+   the insn and discard all other stack pointer references.  */\n+struct record_stack_memrefs_data\n+{\n+  rtx insn;\n+  struct csa_memlist *memlist;\n+};\n+\n+static int\n+record_stack_memrefs (rtx *xp, void *data)\n+{\n+  rtx x = *xp;\n+  struct record_stack_memrefs_data *d =\n+    (struct record_stack_memrefs_data *) data;\n+  if (!x)\n+    return 0;\n+  switch (GET_CODE (x))\n+    {\n+    case MEM:\n+      if (!reg_mentioned_p (stack_pointer_rtx, x))\n+\treturn -1;\n+      /* We are not able to handle correctly all possible memrefs containing\n+         stack pointer, so this check is necessary.  */\n+      if (stack_memref_p (x))\n+\t{\n+\t  d->memlist = record_one_stack_memref (d->insn, xp, d->memlist);\n+\t  return -1;\n+\t}\n+      return 1;\n+    case REG:\n+      /* ??? We want be able to handle non-memory stack pointer\n+\t references later.  For now just discard all insns referring to\n+\t stack pointer outside mem expressions.  We would probably\n+\t want to teach validate_replace to simplify expressions first.\n+\n+\t We can't just compare with STACK_POINTER_RTX because the\n+\t reference to the stack pointer might be in some other mode.\n+\t In particular, an explicit clobber in an asm statement will\n+\t result in a QImode clobber.  */\n+      if (REGNO (x) == STACK_POINTER_REGNUM)\n+\treturn 1;\n+      break;\n+    default:\n+      break;\n+    }\n+  return 0;\n+}\n+\n+/* Subroutine of combine_stack_adjustments, called for each basic block.  */\n+\n+static void\n+combine_stack_adjustments_for_block (basic_block bb)\n+{\n+  HOST_WIDE_INT last_sp_adjust = 0;\n+  rtx last_sp_set = NULL_RTX;\n+  struct csa_memlist *memlist = NULL;\n+  rtx insn, next, set;\n+  struct record_stack_memrefs_data data;\n+  bool end_of_block = false;\n+\n+  for (insn = BB_HEAD (bb); !end_of_block ; insn = next)\n+    {\n+      end_of_block = insn == BB_END (bb);\n+      next = NEXT_INSN (insn);\n+\n+      if (! INSN_P (insn))\n+\tcontinue;\n+\n+      set = single_set_for_csa (insn);\n+      if (set)\n+\t{\n+\t  rtx dest = SET_DEST (set);\n+\t  rtx src = SET_SRC (set);\n+\n+\t  /* Find constant additions to the stack pointer.  */\n+\t  if (dest == stack_pointer_rtx\n+\t      && GET_CODE (src) == PLUS\n+\t      && XEXP (src, 0) == stack_pointer_rtx\n+\t      && GET_CODE (XEXP (src, 1)) == CONST_INT)\n+\t    {\n+\t      HOST_WIDE_INT this_adjust = INTVAL (XEXP (src, 1));\n+\n+\t      /* If we've not seen an adjustment previously, record\n+\t\t it now and continue.  */\n+\t      if (! last_sp_set)\n+\t\t{\n+\t\t  last_sp_set = insn;\n+\t\t  last_sp_adjust = this_adjust;\n+\t\t  continue;\n+\t\t}\n+\n+\t      /* If not all recorded memrefs can be adjusted, or the\n+\t\t adjustment is now too large for a constant addition,\n+\t\t we cannot merge the two stack adjustments.\n+\n+\t\t Also we need to be careful to not move stack pointer\n+\t\t such that we create stack accesses outside the allocated\n+\t\t area.  We can combine an allocation into the first insn,\n+\t\t or a deallocation into the second insn.  We can not\n+\t\t combine an allocation followed by a deallocation.\n+\n+\t\t The only somewhat frequent occurrence of the later is when\n+\t\t a function allocates a stack frame but does not use it.\n+\t\t For this case, we would need to analyze rtl stream to be\n+\t\t sure that allocated area is really unused.  This means not\n+\t\t only checking the memory references, but also all registers\n+\t\t or global memory references possibly containing a stack\n+\t\t frame address.\n+\n+\t\t Perhaps the best way to address this problem is to teach\n+\t\t gcc not to allocate stack for objects never used.  */\n+\n+\t      /* Combine an allocation into the first instruction.  */\n+\t      if (STACK_GROWS_DOWNWARD ? this_adjust <= 0 : this_adjust >= 0)\n+\t\t{\n+\t\t  if (try_apply_stack_adjustment (last_sp_set, memlist,\n+\t\t\t\t\t\t  last_sp_adjust + this_adjust,\n+\t\t\t\t\t\t  this_adjust))\n+\t\t    {\n+\t\t      /* It worked!  */\n+\t\t      delete_insn (insn);\n+\t\t      last_sp_adjust += this_adjust;\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\n+\t      /* Otherwise we have a deallocation.  Do not combine with\n+\t\t a previous allocation.  Combine into the second insn.  */\n+\t      else if (STACK_GROWS_DOWNWARD\n+\t\t       ? last_sp_adjust >= 0 : last_sp_adjust <= 0)\n+\t\t{\n+\t\t  if (try_apply_stack_adjustment (insn, memlist,\n+\t\t\t\t\t\t  last_sp_adjust + this_adjust,\n+\t\t\t\t\t\t  -last_sp_adjust))\n+\t\t    {\n+\t\t      /* It worked!  */\n+\t\t      delete_insn (last_sp_set);\n+\t\t      last_sp_set = insn;\n+\t\t      last_sp_adjust += this_adjust;\n+\t\t      free_csa_memlist (memlist);\n+\t\t      memlist = NULL;\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\n+\t      /* Combination failed.  Restart processing from here.  If\n+\t\t deallocation+allocation conspired to cancel, we can\n+\t\t delete the old deallocation insn.  */\n+\t      if (last_sp_set && last_sp_adjust == 0)\n+\t\tdelete_insn (insn);\n+\t      free_csa_memlist (memlist);\n+\t      memlist = NULL;\n+\t      last_sp_set = insn;\n+\t      last_sp_adjust = this_adjust;\n+\t      continue;\n+\t    }\n+\n+\t  /* Find a predecrement of exactly the previous adjustment and\n+\t     turn it into a direct store.  Obviously we can't do this if\n+\t     there were any intervening uses of the stack pointer.  */\n+\t  if (memlist == NULL\n+\t      && MEM_P (dest)\n+\t      && ((GET_CODE (XEXP (dest, 0)) == PRE_DEC\n+\t\t   && (last_sp_adjust\n+\t\t       == (HOST_WIDE_INT) GET_MODE_SIZE (GET_MODE (dest))))\n+\t\t  || (GET_CODE (XEXP (dest, 0)) == PRE_MODIFY\n+\t\t      && GET_CODE (XEXP (XEXP (dest, 0), 1)) == PLUS\n+\t\t      && XEXP (XEXP (XEXP (dest, 0), 1), 0) == stack_pointer_rtx\n+\t\t      && (GET_CODE (XEXP (XEXP (XEXP (dest, 0), 1), 1))\n+\t\t          == CONST_INT)\n+\t\t      && (INTVAL (XEXP (XEXP (XEXP (dest, 0), 1), 1))\n+\t\t          == -last_sp_adjust)))\n+\t      && XEXP (XEXP (dest, 0), 0) == stack_pointer_rtx\n+\t      && ! reg_mentioned_p (stack_pointer_rtx, src)\n+\t      && memory_address_p (GET_MODE (dest), stack_pointer_rtx)\n+\t      && validate_change (insn, &SET_DEST (set),\n+\t\t\t\t  replace_equiv_address (dest,\n+\t\t\t\t\t\t\t stack_pointer_rtx),\n+\t\t\t\t  0))\n+\t    {\n+\t      delete_insn (last_sp_set);\n+\t      free_csa_memlist (memlist);\n+\t      memlist = NULL;\n+\t      last_sp_set = NULL_RTX;\n+\t      last_sp_adjust = 0;\n+\t      continue;\n+\t    }\n+\t}\n+\n+      data.insn = insn;\n+      data.memlist = memlist;\n+      if (!CALL_P (insn) && last_sp_set\n+\t  && !for_each_rtx (&PATTERN (insn), record_stack_memrefs, &data))\n+\t{\n+\t   memlist = data.memlist;\n+\t   continue;\n+\t}\n+      memlist = data.memlist;\n+\n+      /* Otherwise, we were not able to process the instruction.\n+\t Do not continue collecting data across such a one.  */\n+      if (last_sp_set\n+\t  && (CALL_P (insn)\n+\t      || reg_mentioned_p (stack_pointer_rtx, PATTERN (insn))))\n+\t{\n+\t  if (last_sp_set && last_sp_adjust == 0)\n+\t    delete_insn (last_sp_set);\n+\t  free_csa_memlist (memlist);\n+\t  memlist = NULL;\n+\t  last_sp_set = NULL_RTX;\n+\t  last_sp_adjust = 0;\n+\t}\n+    }\n+\n+  if (last_sp_set && last_sp_adjust == 0)\n+    delete_insn (last_sp_set);\n+\n+  if (memlist)\n+    free_csa_memlist (memlist);\n+}\n+\f\n+\n+static bool\n+gate_handle_stack_adjustments (void)\n+{\n+  return (optimize > 0);\n+}\n+\n+static unsigned int\n+rest_of_handle_stack_adjustments (void)\n+{\n+  life_analysis (PROP_POSTRELOAD);\n+  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE\n+               | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0));\n+\n+  /* This is kind of a heuristic.  We need to run combine_stack_adjustments\n+     even for machines with possibly nonzero RETURN_POPS_ARGS\n+     and ACCUMULATE_OUTGOING_ARGS.  We expect that only ports having\n+     push instructions will have popping returns.  */\n+#ifndef PUSH_ROUNDING\n+  if (!ACCUMULATE_OUTGOING_ARGS)\n+#endif\n+    combine_stack_adjustments ();\n+  return 0;\n+}\n+\n+struct tree_opt_pass pass_stack_adjustments =\n+{\n+  \"csa\",                                /* name */\n+  gate_handle_stack_adjustments,        /* gate */\n+  rest_of_handle_stack_adjustments,     /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  0,                                    /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func |\n+  TODO_ggc_collect,                     /* todo_flags_finish */\n+  0                                     /* letter */\n+};\n+"}, {"sha": "d874695b9f44efaeae22a6861f3d93d9d9229c81", "filename": "gcc/regmove.c", "status": "modified", "additions": 6, "deletions": 444, "changes": 450, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a0240aa55b4f7a2d11d33bd12af7a40f42aa55/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a0240aa55b4f7a2d11d33bd12af7a40f42aa55/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=c7a0240aa55b4f7a2d11d33bd12af7a40f42aa55", "patch": "@@ -623,12 +623,11 @@ optimize_reg_copy_2 (rtx insn, rtx dest, rtx src)\n \t\tif (reg_mentioned_p (dest, PATTERN (q)))\n \t\t  PATTERN (q) = replace_rtx (PATTERN (q), dest, src);\n \n-\n-\t      if (CALL_P (q))\n-\t\t{\n-\t\t  REG_N_CALLS_CROSSED (dregno)--;\n-\t\t  REG_N_CALLS_CROSSED (sregno)++;\n-\t\t}\n+\t\tif (CALL_P (q))\n+\t\t  {\n+\t\t    REG_N_CALLS_CROSSED (dregno)--;\n+\t\t    REG_N_CALLS_CROSSED (sregno)++;\n+\t\t  }\n \t      }\n \n \t  remove_note (p, find_reg_note (p, REG_DEAD, dest));\n@@ -644,6 +643,7 @@ optimize_reg_copy_2 (rtx insn, rtx dest, rtx src)\n \tbreak;\n     }\n }\n+\n /* INSN is a ZERO_EXTEND or SIGN_EXTEND of SRC to DEST.\n    Look if SRC dies there, and if it is only set once, by loading\n    it from memory.  If so, try to incorporate the zero/sign extension\n@@ -2083,408 +2083,13 @@ stable_and_no_regs_but_for_p (rtx x, rtx src, rtx dst)\n     }\n }\n \f\n-/* Track stack adjustments and stack memory references.  Attempt to\n-   reduce the number of stack adjustments by back-propagating across\n-   the memory references.\n-\n-   This is intended primarily for use with targets that do not define\n-   ACCUMULATE_OUTGOING_ARGS.  It is of significantly more value to\n-   targets that define PREFERRED_STACK_BOUNDARY more aligned than\n-   STACK_BOUNDARY (e.g. x86), or if not all registers can be pushed\n-   (e.g. x86 fp regs) which would ordinarily have to be implemented\n-   as a sub/mov pair due to restrictions in calls.c.\n-\n-   Propagation stops when any of the insns that need adjusting are\n-   (a) no longer valid because we've exceeded their range, (b) a\n-   non-trivial push instruction, or (c) a call instruction.\n-\n-   Restriction B is based on the assumption that push instructions\n-   are smaller or faster.  If a port really wants to remove all\n-   pushes, it should have defined ACCUMULATE_OUTGOING_ARGS.  The\n-   one exception that is made is for an add immediately followed\n-   by a push.  */\n-\n-/* This structure records stack memory references between stack adjusting\n-   instructions.  */\n-\n-struct csa_memlist\n-{\n-  HOST_WIDE_INT sp_offset;\n-  rtx insn, *mem;\n-  struct csa_memlist *next;\n-};\n-\n-static int stack_memref_p (rtx);\n-static rtx single_set_for_csa (rtx);\n-static void free_csa_memlist (struct csa_memlist *);\n-static struct csa_memlist *record_one_stack_memref (rtx, rtx *,\n-\t\t\t\t\t\t    struct csa_memlist *);\n-static int try_apply_stack_adjustment (rtx, struct csa_memlist *,\n-\t\t\t\t       HOST_WIDE_INT, HOST_WIDE_INT);\n-static void combine_stack_adjustments_for_block (basic_block);\n-static int record_stack_memrefs (rtx *, void *);\n-\n-\n-/* Main entry point for stack adjustment combination.  */\n-\n-static void\n-combine_stack_adjustments (void)\n-{\n-  basic_block bb;\n-\n-  FOR_EACH_BB (bb)\n-    combine_stack_adjustments_for_block (bb);\n-}\n-\n-/* Recognize a MEM of the form (sp) or (plus sp const).  */\n-\n-static int\n-stack_memref_p (rtx x)\n-{\n-  if (!MEM_P (x))\n-    return 0;\n-  x = XEXP (x, 0);\n-\n-  if (x == stack_pointer_rtx)\n-    return 1;\n-  if (GET_CODE (x) == PLUS\n-      && XEXP (x, 0) == stack_pointer_rtx\n-      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Recognize either normal single_set or the hack in i386.md for\n-   tying fp and sp adjustments.  */\n-\n-static rtx\n-single_set_for_csa (rtx insn)\n-{\n-  int i;\n-  rtx tmp = single_set (insn);\n-  if (tmp)\n-    return tmp;\n-\n-  if (!NONJUMP_INSN_P (insn)\n-      || GET_CODE (PATTERN (insn)) != PARALLEL)\n-    return NULL_RTX;\n-\n-  tmp = PATTERN (insn);\n-  if (GET_CODE (XVECEXP (tmp, 0, 0)) != SET)\n-    return NULL_RTX;\n-\n-  for (i = 1; i < XVECLEN (tmp, 0); ++i)\n-    {\n-      rtx this = XVECEXP (tmp, 0, i);\n-\n-      /* The special case is allowing a no-op set.  */\n-      if (GET_CODE (this) == SET\n-\t  && SET_SRC (this) == SET_DEST (this))\n-\t;\n-      else if (GET_CODE (this) != CLOBBER\n-\t       && GET_CODE (this) != USE)\n-\treturn NULL_RTX;\n-    }\n \n-  return XVECEXP (tmp, 0, 0);\n-}\n-\n-/* Free the list of csa_memlist nodes.  */\n-\n-static void\n-free_csa_memlist (struct csa_memlist *memlist)\n-{\n-  struct csa_memlist *next;\n-  for (; memlist ; memlist = next)\n-    {\n-      next = memlist->next;\n-      free (memlist);\n-    }\n-}\n-\n-/* Create a new csa_memlist node from the given memory reference.\n-   It is already known that the memory is stack_memref_p.  */\n-\n-static struct csa_memlist *\n-record_one_stack_memref (rtx insn, rtx *mem, struct csa_memlist *next_memlist)\n-{\n-  struct csa_memlist *ml;\n-\n-  ml = XNEW (struct csa_memlist);\n-\n-  if (XEXP (*mem, 0) == stack_pointer_rtx)\n-    ml->sp_offset = 0;\n-  else\n-    ml->sp_offset = INTVAL (XEXP (XEXP (*mem, 0), 1));\n-\n-  ml->insn = insn;\n-  ml->mem = mem;\n-  ml->next = next_memlist;\n-\n-  return ml;\n-}\n-\n-/* Attempt to apply ADJUST to the stack adjusting insn INSN, as well\n-   as each of the memories in MEMLIST.  Return true on success.  */\n-\n-static int\n-try_apply_stack_adjustment (rtx insn, struct csa_memlist *memlist, HOST_WIDE_INT new_adjust,\n-\t\t\t    HOST_WIDE_INT delta)\n-{\n-  struct csa_memlist *ml;\n-  rtx set;\n-\n-  set = single_set_for_csa (insn);\n-  validate_change (insn, &XEXP (SET_SRC (set), 1), GEN_INT (new_adjust), 1);\n-\n-  for (ml = memlist; ml ; ml = ml->next)\n-    validate_change\n-      (ml->insn, ml->mem,\n-       replace_equiv_address_nv (*ml->mem,\n-\t\t\t\t plus_constant (stack_pointer_rtx,\n-\t\t\t\t\t\tml->sp_offset - delta)), 1);\n-\n-  if (apply_change_group ())\n-    {\n-      /* Succeeded.  Update our knowledge of the memory references.  */\n-      for (ml = memlist; ml ; ml = ml->next)\n-\tml->sp_offset -= delta;\n-\n-      return 1;\n-    }\n-  else\n-    return 0;\n-}\n-\n-/* Called via for_each_rtx and used to record all stack memory references in\n-   the insn and discard all other stack pointer references.  */\n-struct record_stack_memrefs_data\n-{\n-  rtx insn;\n-  struct csa_memlist *memlist;\n-};\n-\n-static int\n-record_stack_memrefs (rtx *xp, void *data)\n-{\n-  rtx x = *xp;\n-  struct record_stack_memrefs_data *d =\n-    (struct record_stack_memrefs_data *) data;\n-  if (!x)\n-    return 0;\n-  switch (GET_CODE (x))\n-    {\n-    case MEM:\n-      if (!reg_mentioned_p (stack_pointer_rtx, x))\n-\treturn -1;\n-      /* We are not able to handle correctly all possible memrefs containing\n-         stack pointer, so this check is necessary.  */\n-      if (stack_memref_p (x))\n-\t{\n-\t  d->memlist = record_one_stack_memref (d->insn, xp, d->memlist);\n-\t  return -1;\n-\t}\n-      return 1;\n-    case REG:\n-      /* ??? We want be able to handle non-memory stack pointer\n-\t references later.  For now just discard all insns referring to\n-\t stack pointer outside mem expressions.  We would probably\n-\t want to teach validate_replace to simplify expressions first.\n-\n-\t We can't just compare with STACK_POINTER_RTX because the\n-\t reference to the stack pointer might be in some other mode.\n-\t In particular, an explicit clobber in an asm statement will\n-\t result in a QImode clobber.  */\n-      if (REGNO (x) == STACK_POINTER_REGNUM)\n-\treturn 1;\n-      break;\n-    default:\n-      break;\n-    }\n-  return 0;\n-}\n-\n-/* Subroutine of combine_stack_adjustments, called for each basic block.  */\n-\n-static void\n-combine_stack_adjustments_for_block (basic_block bb)\n-{\n-  HOST_WIDE_INT last_sp_adjust = 0;\n-  rtx last_sp_set = NULL_RTX;\n-  struct csa_memlist *memlist = NULL;\n-  rtx insn, next, set;\n-  struct record_stack_memrefs_data data;\n-  bool end_of_block = false;\n-\n-  for (insn = BB_HEAD (bb); !end_of_block ; insn = next)\n-    {\n-      end_of_block = insn == BB_END (bb);\n-      next = NEXT_INSN (insn);\n-\n-      if (! INSN_P (insn))\n-\tcontinue;\n-\n-      set = single_set_for_csa (insn);\n-      if (set)\n-\t{\n-\t  rtx dest = SET_DEST (set);\n-\t  rtx src = SET_SRC (set);\n-\n-\t  /* Find constant additions to the stack pointer.  */\n-\t  if (dest == stack_pointer_rtx\n-\t      && GET_CODE (src) == PLUS\n-\t      && XEXP (src, 0) == stack_pointer_rtx\n-\t      && GET_CODE (XEXP (src, 1)) == CONST_INT)\n-\t    {\n-\t      HOST_WIDE_INT this_adjust = INTVAL (XEXP (src, 1));\n-\n-\t      /* If we've not seen an adjustment previously, record\n-\t\t it now and continue.  */\n-\t      if (! last_sp_set)\n-\t\t{\n-\t\t  last_sp_set = insn;\n-\t\t  last_sp_adjust = this_adjust;\n-\t\t  continue;\n-\t\t}\n-\n-\t      /* If not all recorded memrefs can be adjusted, or the\n-\t\t adjustment is now too large for a constant addition,\n-\t\t we cannot merge the two stack adjustments.\n-\n-\t\t Also we need to be careful to not move stack pointer\n-\t\t such that we create stack accesses outside the allocated\n-\t\t area.  We can combine an allocation into the first insn,\n-\t\t or a deallocation into the second insn.  We can not\n-\t\t combine an allocation followed by a deallocation.\n-\n-\t\t The only somewhat frequent occurrence of the later is when\n-\t\t a function allocates a stack frame but does not use it.\n-\t\t For this case, we would need to analyze rtl stream to be\n-\t\t sure that allocated area is really unused.  This means not\n-\t\t only checking the memory references, but also all registers\n-\t\t or global memory references possibly containing a stack\n-\t\t frame address.\n-\n-\t\t Perhaps the best way to address this problem is to teach\n-\t\t gcc not to allocate stack for objects never used.  */\n-\n-\t      /* Combine an allocation into the first instruction.  */\n-\t      if (STACK_GROWS_DOWNWARD ? this_adjust <= 0 : this_adjust >= 0)\n-\t\t{\n-\t\t  if (try_apply_stack_adjustment (last_sp_set, memlist,\n-\t\t\t\t\t\t  last_sp_adjust + this_adjust,\n-\t\t\t\t\t\t  this_adjust))\n-\t\t    {\n-\t\t      /* It worked!  */\n-\t\t      delete_insn (insn);\n-\t\t      last_sp_adjust += this_adjust;\n-\t\t      continue;\n-\t\t    }\n-\t\t}\n-\n-\t      /* Otherwise we have a deallocation.  Do not combine with\n-\t\t a previous allocation.  Combine into the second insn.  */\n-\t      else if (STACK_GROWS_DOWNWARD\n-\t\t       ? last_sp_adjust >= 0 : last_sp_adjust <= 0)\n-\t\t{\n-\t\t  if (try_apply_stack_adjustment (insn, memlist,\n-\t\t\t\t\t\t  last_sp_adjust + this_adjust,\n-\t\t\t\t\t\t  -last_sp_adjust))\n-\t\t    {\n-\t\t      /* It worked!  */\n-\t\t      delete_insn (last_sp_set);\n-\t\t      last_sp_set = insn;\n-\t\t      last_sp_adjust += this_adjust;\n-\t\t      free_csa_memlist (memlist);\n-\t\t      memlist = NULL;\n-\t\t      continue;\n-\t\t    }\n-\t\t}\n-\n-\t      /* Combination failed.  Restart processing from here.  If\n-\t\t deallocation+allocation conspired to cancel, we can\n-\t\t delete the old deallocation insn.  */\n-\t      if (last_sp_set && last_sp_adjust == 0)\n-\t\tdelete_insn (insn);\n-\t      free_csa_memlist (memlist);\n-\t      memlist = NULL;\n-\t      last_sp_set = insn;\n-\t      last_sp_adjust = this_adjust;\n-\t      continue;\n-\t    }\n-\n-\t  /* Find a predecrement of exactly the previous adjustment and\n-\t     turn it into a direct store.  Obviously we can't do this if\n-\t     there were any intervening uses of the stack pointer.  */\n-\t  if (memlist == NULL\n-\t      && MEM_P (dest)\n-\t      && ((GET_CODE (XEXP (dest, 0)) == PRE_DEC\n-\t\t   && (last_sp_adjust\n-\t\t       == (HOST_WIDE_INT) GET_MODE_SIZE (GET_MODE (dest))))\n-\t\t  || (GET_CODE (XEXP (dest, 0)) == PRE_MODIFY\n-\t\t      && GET_CODE (XEXP (XEXP (dest, 0), 1)) == PLUS\n-\t\t      && XEXP (XEXP (XEXP (dest, 0), 1), 0) == stack_pointer_rtx\n-\t\t      && (GET_CODE (XEXP (XEXP (XEXP (dest, 0), 1), 1))\n-\t\t          == CONST_INT)\n-\t\t      && (INTVAL (XEXP (XEXP (XEXP (dest, 0), 1), 1))\n-\t\t          == -last_sp_adjust)))\n-\t      && XEXP (XEXP (dest, 0), 0) == stack_pointer_rtx\n-\t      && ! reg_mentioned_p (stack_pointer_rtx, src)\n-\t      && memory_address_p (GET_MODE (dest), stack_pointer_rtx)\n-\t      && validate_change (insn, &SET_DEST (set),\n-\t\t\t\t  replace_equiv_address (dest,\n-\t\t\t\t\t\t\t stack_pointer_rtx),\n-\t\t\t\t  0))\n-\t    {\n-\t      delete_insn (last_sp_set);\n-\t      free_csa_memlist (memlist);\n-\t      memlist = NULL;\n-\t      last_sp_set = NULL_RTX;\n-\t      last_sp_adjust = 0;\n-\t      continue;\n-\t    }\n-\t}\n-\n-      data.insn = insn;\n-      data.memlist = memlist;\n-      if (!CALL_P (insn) && last_sp_set\n-\t  && !for_each_rtx (&PATTERN (insn), record_stack_memrefs, &data))\n-\t{\n-\t   memlist = data.memlist;\n-\t   continue;\n-\t}\n-      memlist = data.memlist;\n-\n-      /* Otherwise, we were not able to process the instruction.\n-\t Do not continue collecting data across such a one.  */\n-      if (last_sp_set\n-\t  && (CALL_P (insn)\n-\t      || reg_mentioned_p (stack_pointer_rtx, PATTERN (insn))))\n-\t{\n-\t  if (last_sp_set && last_sp_adjust == 0)\n-\t    delete_insn (last_sp_set);\n-\t  free_csa_memlist (memlist);\n-\t  memlist = NULL;\n-\t  last_sp_set = NULL_RTX;\n-\t  last_sp_adjust = 0;\n-\t}\n-    }\n-\n-  if (last_sp_set && last_sp_adjust == 0)\n-    delete_insn (last_sp_set);\n-\n-  if (memlist)\n-    free_csa_memlist (memlist);\n-}\n-\f\n static bool\n gate_handle_regmove (void)\n {\n   return (optimize > 0 && flag_regmove);\n }\n \n-\n /* Register allocation pre-pass, to reduce number of moves necessary\n    for two-address machines.  */\n static unsigned int\n@@ -2513,46 +2118,3 @@ struct tree_opt_pass pass_regmove =\n   'N'                                   /* letter */\n };\n \n-\n-static bool\n-gate_handle_stack_adjustments (void)\n-{\n-  return (optimize > 0);\n-}\n-\n-static unsigned int\n-rest_of_handle_stack_adjustments (void)\n-{\n-  life_analysis (PROP_POSTRELOAD);\n-  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE\n-               | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0));\n-\n-  /* This is kind of a heuristic.  We need to run combine_stack_adjustments\n-     even for machines with possibly nonzero RETURN_POPS_ARGS\n-     and ACCUMULATE_OUTGOING_ARGS.  We expect that only ports having\n-     push instructions will have popping returns.  */\n-#ifndef PUSH_ROUNDING\n-  if (!ACCUMULATE_OUTGOING_ARGS)\n-#endif\n-    combine_stack_adjustments ();\n-  return 0;\n-}\n-\n-struct tree_opt_pass pass_stack_adjustments =\n-{\n-  \"csa\",                                /* name */\n-  gate_handle_stack_adjustments,        /* gate */\n-  rest_of_handle_stack_adjustments,     /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  0,                                    /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_dump_func |\n-  TODO_ggc_collect,                     /* todo_flags_finish */\n-  0                                     /* letter */\n-};\n-"}]}