{"sha": "119cea98f664764cce04963243c39c8f6d797d33", "node_id": "C_kwDOANBUbNoAKDExOWNlYTk4ZjY2NDc2NGNjZTA0OTYzMjQzYzM5YzhmNmQ3OTdkMzM", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-02-02T23:36:41Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-02-05T05:56:05Z"}, "message": "c++: assignment, aggregate, array [PR104300]\n\nThe PR92385 fix meant that we see more VEC_INIT_EXPR outside of INIT_EXPR;\nin such cases, we need to wrap them in TARGET_EXPR.  I previously fixed\nthat in build_array_copy; we also need it in process_init_constructor.\nAfter fixing that, I needed to adjust a few places to recognize the\nVEC_INIT_EXPR even inside a TARGET_EXPR.  And prevent cp_fully_fold_init\nfrom lowering VEC_INIT_EXPR too soon.  And handle COMPOUND_EXPR inside\nTARGET_EXPR better.\n\n\tPR c++/104300\n\tPR c++/92385\n\ngcc/cp/ChangeLog:\n\n\t* cp-tree.h (get_vec_init_expr): New.\n\t(target_expr_needs_replace): New.\n\t* cp-gimplify.cc (cp_gimplify_init_expr): Use it.\n\t(struct cp_fold_data): New.\n\t(cp_fold_r): Only genericize inits at end of fn.\n\t(cp_fold_function): Here.\n\t(cp_fully_fold_init): Not here.\n\t* init.cc (build_vec_init): Use get_vec_init_expr.\n\t* tree.cc (build_vec_init_expr): Likewise.\n\t* typeck2.cc (split_nonconstant_init_1): Likewise.\n\t(process_init_constructor): Wrap VEC_INIT_EXPR in\n\tTARGET_EXPR.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp0x/initlist-array14.C: New test.", "tree": {"sha": "1a19f7038ed4bbbf8733db6bf1d7d977068e6741", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a19f7038ed4bbbf8733db6bf1d7d977068e6741"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/119cea98f664764cce04963243c39c8f6d797d33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/119cea98f664764cce04963243c39c8f6d797d33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/119cea98f664764cce04963243c39c8f6d797d33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/119cea98f664764cce04963243c39c8f6d797d33/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ef416e7edc4c66a06a3c05025720dfc98cf07f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ef416e7edc4c66a06a3c05025720dfc98cf07f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ef416e7edc4c66a06a3c05025720dfc98cf07f5"}], "stats": {"total": 101, "additions": 81, "deletions": 20}, "files": [{"sha": "d7323fb5c09a2d4d08c6626b2c0f96e7cddbba46", "filename": "gcc/cp/cp-gimplify.cc", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/119cea98f664764cce04963243c39c8f6d797d33/gcc%2Fcp%2Fcp-gimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/119cea98f664764cce04963243c39c8f6d797d33/gcc%2Fcp%2Fcp-gimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.cc?ref=119cea98f664764cce04963243c39c8f6d797d33", "patch": "@@ -249,8 +249,7 @@ cp_gimplify_init_expr (tree *expr_p)\n   if (TREE_CODE (from) == TARGET_EXPR)\n     if (tree init = TARGET_EXPR_INITIAL (from))\n       {\n-\tif (VOID_TYPE_P (TREE_TYPE (init))\n-\t    && TREE_CODE (init) != AGGR_INIT_EXPR)\n+\tif (target_expr_needs_replace (from))\n \t  {\n \t    /* If this was changed by cp_genericize_target_expr, we need to\n \t       walk into it to replace uses of the slot.  */\n@@ -950,14 +949,23 @@ struct cp_genericize_data\n \n /* Perform any pre-gimplification folding of C++ front end trees to\n    GENERIC.\n-   Note:  The folding of none-omp cases is something to move into\n+   Note:  The folding of non-omp cases is something to move into\n      the middle-end.  As for now we have most foldings only on GENERIC\n      in fold-const, we need to perform this before transformation to\n      GIMPLE-form.  */\n \n+struct cp_fold_data\n+{\n+  hash_set<tree> pset;\n+  bool genericize; // called from cp_fold_function?\n+\n+  cp_fold_data (bool g): genericize (g) {}\n+};\n+\n static tree\n-cp_fold_r (tree *stmt_p, int *walk_subtrees, void *data)\n+cp_fold_r (tree *stmt_p, int *walk_subtrees, void *data_)\n {\n+  cp_fold_data *data = (cp_fold_data*)data_;\n   tree stmt = *stmt_p;\n   enum tree_code code = TREE_CODE (stmt);\n \n@@ -967,7 +975,7 @@ cp_fold_r (tree *stmt_p, int *walk_subtrees, void *data)\n       if (TREE_CODE (PTRMEM_CST_MEMBER (stmt)) == FUNCTION_DECL\n \t  && DECL_IMMEDIATE_FUNCTION_P (PTRMEM_CST_MEMBER (stmt)))\n \t{\n-\t  if (!((hash_set<tree> *) data)->add (stmt))\n+\t  if (!data->pset.add (stmt))\n \t    error_at (PTRMEM_CST_LOCATION (stmt),\n \t\t      \"taking address of an immediate function %qD\",\n \t\t      PTRMEM_CST_MEMBER (stmt));\n@@ -1001,7 +1009,7 @@ cp_fold_r (tree *stmt_p, int *walk_subtrees, void *data)\n \n   *stmt_p = stmt = cp_fold (*stmt_p);\n \n-  if (((hash_set<tree> *) data)->add (stmt))\n+  if (data->pset.add (stmt))\n     {\n       /* Don't walk subtrees of stmts we've already walked once, otherwise\n \t we can have exponential complexity with e.g. lots of nested\n@@ -1075,12 +1083,17 @@ cp_fold_r (tree *stmt_p, int *walk_subtrees, void *data)\n \t}\n       break;\n \n+      /* These are only for genericize time; they're here rather than in\n+\t cp_genericize to avoid problems with the invisible reference\n+\t transition.  */\n     case INIT_EXPR:\n-      cp_genericize_init_expr (stmt_p);\n+      if (data->genericize)\n+\tcp_genericize_init_expr (stmt_p);\n       break;\n \n     case TARGET_EXPR:\n-      cp_genericize_target_expr (stmt_p);\n+      if (data->genericize)\n+\tcp_genericize_target_expr (stmt_p);\n       break;\n \n     default:\n@@ -1096,8 +1109,8 @@ cp_fold_r (tree *stmt_p, int *walk_subtrees, void *data)\n void\n cp_fold_function (tree fndecl)\n {\n-  hash_set<tree> pset;\n-  cp_walk_tree (&DECL_SAVED_TREE (fndecl), cp_fold_r, &pset, NULL);\n+  cp_fold_data data (/*genericize*/true);\n+  cp_walk_tree (&DECL_SAVED_TREE (fndecl), cp_fold_r, &data, NULL);\n }\n \n /* Turn SPACESHIP_EXPR EXPR into GENERIC.  */\n@@ -2358,8 +2371,8 @@ cp_fully_fold_init (tree x)\n   if (processing_template_decl)\n     return x;\n   x = cp_fully_fold (x);\n-  hash_set<tree> pset;\n-  cp_walk_tree (&x, cp_fold_r, &pset, NULL);\n+  cp_fold_data data (/*genericize*/false);\n+  cp_walk_tree (&x, cp_fold_r, &data, NULL);\n   return x;\n }\n "}, {"sha": "d71be0a5bc7203f84d125f611a073a90c0bd70da", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/119cea98f664764cce04963243c39c8f6d797d33/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/119cea98f664764cce04963243c39c8f6d797d33/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=119cea98f664764cce04963243c39c8f6d797d33", "patch": "@@ -4201,6 +4201,18 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define VEC_INIT_EXPR_VALUE_INIT(NODE) \\\n   TREE_LANG_FLAG_1 (VEC_INIT_EXPR_CHECK (NODE))\n \n+/* If T is a VEC_INIT_EXPR, return it, possibly stripping a TARGET_EXPR\n+   wrapper.  Otherwise, return null.  */\n+inline tree\n+get_vec_init_expr (tree t)\n+{\n+  if (t && TREE_CODE (t) == TARGET_EXPR)\n+    t = TARGET_EXPR_INITIAL (t);\n+  if (t && TREE_CODE (t) == VEC_INIT_EXPR)\n+    return t;\n+  return NULL_TREE;\n+}\n+\n /* The condition under which this MUST_NOT_THROW_EXPR actually blocks\n    exceptions.  NULL_TREE means 'true'.  */\n #define MUST_NOT_THROW_COND(NODE) \\\n@@ -5361,6 +5373,21 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    && TARGET_EXPR_INITIAL (NODE)\t\t\t\t\\\n    && !VOID_TYPE_P (TREE_TYPE (TARGET_EXPR_INITIAL (NODE))))\n \n+/* True if T is a TARGET_EXPR for which we'll need to replace_decl to use it as\n+   an initializer.  */\n+inline bool\n+target_expr_needs_replace (tree t)\n+{\n+  if (!t || TREE_CODE (t) != TARGET_EXPR)\n+    return false;\n+  tree init = TARGET_EXPR_INITIAL (t);\n+  if (!init || !VOID_TYPE_P (TREE_TYPE (init)))\n+    return false;\n+  while (TREE_CODE (init) == COMPOUND_EXPR)\n+    init = TREE_OPERAND (init, 1);\n+  return TREE_CODE (init) != AGGR_INIT_EXPR;\n+}\n+\n /* True if EXPR expresses direct-initialization of a TYPE.  */\n #define DIRECT_INIT_EXPR_P(TYPE,EXPR)\t\t\t\t\t\\\n   (TREE_CODE (EXPR) == TARGET_EXPR && TREE_LANG_FLAG_2 (EXPR)\t\t\\"}, {"sha": "fcb255f1ac7233da8f9358b84ae1f75c3dc63e84", "filename": "gcc/cp/init.cc", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/119cea98f664764cce04963243c39c8f6d797d33/gcc%2Fcp%2Finit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/119cea98f664764cce04963243c39c8f6d797d33/gcc%2Fcp%2Finit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.cc?ref=119cea98f664764cce04963243c39c8f6d797d33", "patch": "@@ -4368,8 +4368,8 @@ build_vec_init (tree base, tree maxindex, tree init,\n       && from_array != 2)\n     init = TARGET_EXPR_INITIAL (init);\n \n-  if (init && TREE_CODE (init) == VEC_INIT_EXPR)\n-    init = VEC_INIT_EXPR_INIT (init);\n+  if (tree vi = get_vec_init_expr (init))\n+    init = VEC_INIT_EXPR_INIT (vi);\n \n   bool direct_init = false;\n   if (from_array && init && BRACE_ENCLOSED_INITIALIZER_P (init)\n@@ -4581,10 +4581,14 @@ build_vec_init (tree base, tree maxindex, tree init,\n \n \t  num_initialized_elts++;\n \n+\t  /* We need to see sub-array TARGET_EXPR before cp_fold_r so we can\n+\t     handle cleanup flags properly.  */\n+\t  gcc_checking_assert (!target_expr_needs_replace (elt));\n+\n \t  if (digested)\n \t    one_init = build2 (INIT_EXPR, type, baseref, elt);\n-\t  else if (TREE_CODE (elt) == VEC_INIT_EXPR)\n-\t    one_init = expand_vec_init_expr (baseref, elt, complain, flags);\n+\t  else if (tree vi = get_vec_init_expr (elt))\n+\t    one_init = expand_vec_init_expr (baseref, vi, complain, flags);\n \t  else if (MAYBE_CLASS_TYPE_P (type) || TREE_CODE (type) == ARRAY_TYPE)\n \t    one_init = build_aggr_init (baseref, elt, 0, complain);\n \t  else"}, {"sha": "6e9be713c51ced1edeafda4c3f7a2b8fa45504a4", "filename": "gcc/cp/tree.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/119cea98f664764cce04963243c39c8f6d797d33/gcc%2Fcp%2Ftree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/119cea98f664764cce04963243c39c8f6d797d33/gcc%2Fcp%2Ftree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.cc?ref=119cea98f664764cce04963243c39c8f6d797d33", "patch": "@@ -785,8 +785,8 @@ build_vec_init_elt (tree type, tree init, tsubst_flags_t complain)\n tree\n build_vec_init_expr (tree type, tree init, tsubst_flags_t complain)\n {\n-  if (init && TREE_CODE (init) == VEC_INIT_EXPR)\n-    return init;\n+  if (tree vi = get_vec_init_expr (init))\n+    return vi;\n \n   tree elt_init;\n   if (init && TREE_CODE (init) == CONSTRUCTOR"}, {"sha": "4015bd53257b8e1ae75b422ad3a7b3a3f7bcc57e", "filename": "gcc/cp/typeck2.cc", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/119cea98f664764cce04963243c39c8f6d797d33/gcc%2Fcp%2Ftypeck2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/119cea98f664764cce04963243c39c8f6d797d33/gcc%2Fcp%2Ftypeck2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.cc?ref=119cea98f664764cce04963243c39c8f6d797d33", "patch": "@@ -548,6 +548,10 @@ split_nonconstant_init_1 (tree dest, tree init, bool last,\n \n \t  bool elt_last = last && idx == CONSTRUCTOR_NELTS (init) - 1;\n \n+\t  /* We need to see sub-array TARGET_EXPR before cp_fold_r so we can\n+\t     handle cleanup flags properly.  */\n+\t  gcc_checking_assert (!target_expr_needs_replace (value));\n+\n \t  if (TREE_CODE (value) == CONSTRUCTOR)\n \t    {\n \t      if (!split_nonconstant_init_1 (sub, value, elt_last, flags)\n@@ -574,9 +578,9 @@ split_nonconstant_init_1 (tree dest, tree init, bool last,\n \t\t  num_split_elts++;\n \t\t}\n \t    }\n-\t  else if (TREE_CODE (value) == VEC_INIT_EXPR)\n+\t  else if (tree vi = get_vec_init_expr (value))\n \t    {\n-\t      add_stmt (expand_vec_init_expr (sub, value, tf_warning_or_error,\n+\t      add_stmt (expand_vec_init_expr (sub, vi, tf_warning_or_error,\n \t\t\t\t\t      flags));\n \n \t      /* Mark element for removal.  */\n@@ -1925,6 +1929,7 @@ process_init_constructor (tree type, tree init, int nested, int flags,\n \t initializer-clause until later so we can use a loop.  */\n       TREE_TYPE (init) = init_list_type_node;\n       init = build_vec_init_expr (type, init, complain);\n+      init = get_target_expr (init);\n     }\n   return init;\n }"}, {"sha": "baa4afc91fd5556117d8008b8ae3a9af5c6d79c3", "filename": "gcc/testsuite/g++.dg/cpp0x/initlist-array14.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/119cea98f664764cce04963243c39c8f6d797d33/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist-array14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/119cea98f664764cce04963243c39c8f6d797d33/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist-array14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist-array14.C?ref=119cea98f664764cce04963243c39c8f6d797d33", "patch": "@@ -0,0 +1,12 @@\n+// PR c++/104300\n+// { dg-do compile { target c++11 } }\n+\n+struct ss {\n+  char r;\n+  ss();\n+};\n+struct a {\n+  ss e[6];\n+};\n+a vv;\n+void ff() { vv = {}; }"}]}