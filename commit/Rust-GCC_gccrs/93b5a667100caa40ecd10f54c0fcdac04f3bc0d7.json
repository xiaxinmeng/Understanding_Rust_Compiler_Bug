{"sha": "93b5a667100caa40ecd10f54c0fcdac04f3bc0d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNiNWE2NjcxMDBjYWE0MGVjZDEwZjU0YzBmY2RhYzA0ZjNiYzBkNw==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-09-16T19:52:42Z"}, "committer": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-09-16T20:36:00Z"}, "message": "rs6000: Handle overloads during program parsing\n\nAlthough this patch looks quite large, the changes are fairly minimal.\nMost of it is duplicating the large function that does the overload\nresolution using the automatically generated data structures instead of\nthe old hand-generated ones.  This doesn't make the patch terribly easy to\nreview, unfortunately.  Just be aware that generally we aren't changing\nthe logic and functionality of overload handling.\n\n2021-09-16  Bill Schmidt  <wschmidt@linux.ibm.com>\n\ngcc/\n\t* config/rs6000/rs6000-c.c (rs6000-builtins.h): New include.\n\t(altivec_resolve_new_overloaded_builtin): New forward decl.\n\t(rs6000_new_builtin_type_compatible): New function.\n\t(altivec_resolve_overloaded_builtin): Call\n\taltivec_resolve_new_overloaded_builtin.\n\t(altivec_build_new_resolved_builtin): New function.\n\t(altivec_resolve_new_overloaded_builtin): Likewise.\n\t* config/rs6000/rs6000-call.c (rs6000_new_builtin_is_supported):\n\tLikewise.\n\t* config/rs6000/rs6000-gen-builtins.c (write_decls): Remove _p from\n\tname of rs6000_new_builtin_is_supported.", "tree": {"sha": "0b28c4e1a58c5901e64a692dee5c323d8f23869a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b28c4e1a58c5901e64a692dee5c323d8f23869a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93b5a667100caa40ecd10f54c0fcdac04f3bc0d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93b5a667100caa40ecd10f54c0fcdac04f3bc0d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93b5a667100caa40ecd10f54c0fcdac04f3bc0d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93b5a667100caa40ecd10f54c0fcdac04f3bc0d7/comments", "author": null, "committer": null, "parents": [{"sha": "2e2e65a46d2674bed53afd211493876ee2b79453", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e2e65a46d2674bed53afd211493876ee2b79453", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e2e65a46d2674bed53afd211493876ee2b79453"}], "stats": {"total": 1133, "additions": 1132, "deletions": 1}, "files": [{"sha": "d08bdfec3aee41a8f7352c8c9f848e22d06a5d63", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 1078, "deletions": 0, "changes": 1078, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93b5a667100caa40ecd10f54c0fcdac04f3bc0d7/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93b5a667100caa40ecd10f54c0fcdac04f3bc0d7/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=93b5a667100caa40ecd10f54c0fcdac04f3bc0d7", "patch": "@@ -35,6 +35,9 @@\n #include \"langhooks.h\"\n #include \"c/c-tree.h\"\n \n+#include \"rs6000-builtins.h\"\n+\n+static tree altivec_resolve_new_overloaded_builtin (location_t, tree, void *);\n \n \n /* Handle the machine specific pragma longcall.  Its syntax is\n@@ -811,6 +814,32 @@ is_float128_p (tree t)\n \t      && t == long_double_type_node));\n }\n   \n+\n+/* Return true iff ARGTYPE can be compatibly passed as PARMTYPE.  */\n+static bool\n+rs6000_new_builtin_type_compatible (tree parmtype, tree argtype)\n+{\n+  if (parmtype == error_mark_node)\n+    return false;\n+\n+  if (INTEGRAL_TYPE_P (parmtype) && INTEGRAL_TYPE_P (argtype))\n+    return true;\n+\n+  if (TARGET_IEEEQUAD && TARGET_LONG_DOUBLE_128\n+      && is_float128_p (parmtype) && is_float128_p (argtype))\n+    return true;\n+\n+  if (POINTER_TYPE_P (parmtype) && POINTER_TYPE_P (argtype))\n+    {\n+      parmtype = TREE_TYPE (parmtype);\n+      argtype = TREE_TYPE (argtype);\n+      if (TYPE_READONLY (argtype))\n+\tparmtype = build_qualified_type (parmtype, TYPE_QUAL_CONST);\n+    }\n+\n+  return lang_hooks.types_compatible_p (parmtype, argtype);\n+}\n+\n static inline bool\n rs6000_builtin_type_compatible (tree t, int id)\n {\n@@ -927,6 +956,10 @@ tree\n altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t\t\t\t    void *passed_arglist)\n {\n+  if (new_builtins_are_live)\n+    return altivec_resolve_new_overloaded_builtin (loc, fndecl,\n+\t\t\t\t\t\t   passed_arglist);\n+\n   vec<tree, va_gc> *arglist = static_cast<vec<tree, va_gc> *> (passed_arglist);\n   unsigned int nargs = vec_safe_length (arglist);\n   enum rs6000_builtins fcode\n@@ -1930,3 +1963,1048 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n     return error_mark_node;\n   }\n }\n+\n+/* Build a tree for a function call to an Altivec non-overloaded builtin.\n+   The overloaded builtin that matched the types and args is described\n+   by DESC.  The N arguments are given in ARGS, respectively.\n+\n+   Actually the only thing it does is calling fold_convert on ARGS, with\n+   a small exception for vec_{all,any}_{ge,le} predicates. */\n+\n+static tree\n+altivec_build_new_resolved_builtin (tree *args, int n, tree fntype,\n+\t\t\t\t    tree ret_type,\n+\t\t\t\t    rs6000_gen_builtins bif_id,\n+\t\t\t\t    rs6000_gen_builtins ovld_id)\n+{\n+  tree argtypes = TYPE_ARG_TYPES (fntype);\n+  tree arg_type[MAX_OVLD_ARGS];\n+  tree fndecl = rs6000_builtin_decls_x[bif_id];\n+\n+  for (int i = 0; i < n; i++)\n+    {\n+      arg_type[i] = TREE_VALUE (argtypes);\n+      argtypes = TREE_CHAIN (argtypes);\n+    }\n+\n+  /* The AltiVec overloading implementation is overall gross, but this\n+     is particularly disgusting.  The vec_{all,any}_{ge,le} builtins\n+     are completely different for floating-point vs. integer vector\n+     types, because the former has vcmpgefp, but the latter should use\n+     vcmpgtXX.\n+\n+     In practice, the second and third arguments are swapped, and the\n+     condition (LT vs. EQ, which is recognizable by bit 1 of the first\n+     argument) is reversed.  Patch the arguments here before building\n+     the resolved CALL_EXPR.  */\n+  if (n == 3\n+      && ovld_id == RS6000_OVLD_VEC_CMPGE_P\n+      && bif_id != RS6000_BIF_VCMPGEFP_P\n+      && bif_id != RS6000_BIF_XVCMPGEDP_P)\n+    {\n+      std::swap (args[1], args[2]);\n+      std::swap (arg_type[1], arg_type[2]);\n+\n+      args[0] = fold_build2 (BIT_XOR_EXPR, TREE_TYPE (args[0]), args[0],\n+\t\t\t     build_int_cst (NULL_TREE, 2));\n+    }\n+\n+  for (int j = 0; j < n; j++)\n+    args[j] = fully_fold_convert (arg_type[j], args[j]);\n+\n+  /* If the number of arguments to an overloaded function increases,\n+     we must expand this switch.  */\n+  gcc_assert (MAX_OVLD_ARGS <= 4);\n+\n+  tree call;\n+  switch (n)\n+    {\n+    case 0:\n+      call = build_call_expr (fndecl, 0);\n+      break;\n+    case 1:\n+      call = build_call_expr (fndecl, 1, args[0]);\n+      break;\n+    case 2:\n+      call = build_call_expr (fndecl, 2, args[0], args[1]);\n+      break;\n+    case 3:\n+      call = build_call_expr (fndecl, 3, args[0], args[1], args[2]);\n+      break;\n+    case 4:\n+      call = build_call_expr (fndecl, 4, args[0], args[1], args[2], args[3]);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  return fold_convert (ret_type, call);\n+}\n+\n+/* Implementation of the resolve_overloaded_builtin target hook, to\n+   support Altivec's overloaded builtins.  FIXME: This code needs\n+   to be brutally factored.  */\n+\n+static tree\n+altivec_resolve_new_overloaded_builtin (location_t loc, tree fndecl,\n+\t\t\t\t\tvoid *passed_arglist)\n+{\n+  vec<tree, va_gc> *arglist = static_cast<vec<tree, va_gc> *> (passed_arglist);\n+  unsigned int nargs = vec_safe_length (arglist);\n+  enum rs6000_gen_builtins fcode\n+    = (enum rs6000_gen_builtins) DECL_MD_FUNCTION_CODE (fndecl);\n+  tree fnargs = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n+  tree types[MAX_OVLD_ARGS];\n+  tree args[MAX_OVLD_ARGS];\n+\n+  /* Return immediately if this isn't an overload.  */\n+  if (fcode <= RS6000_OVLD_NONE)\n+    return NULL_TREE;\n+\n+  unsigned int adj_fcode = fcode - RS6000_OVLD_NONE;\n+\n+  if (TARGET_DEBUG_BUILTIN)\n+    fprintf (stderr, \"altivec_resolve_overloaded_builtin, code = %4d, %s\\n\",\n+\t     (int) fcode, IDENTIFIER_POINTER (DECL_NAME (fndecl)));\n+\n+  /* vec_lvsl and vec_lvsr are deprecated for use with LE element order.  */\n+  if (fcode == RS6000_OVLD_VEC_LVSL && !BYTES_BIG_ENDIAN)\n+    warning (OPT_Wdeprecated,\n+\t     \"%<vec_lvsl%> is deprecated for little endian; use \"\n+\t     \"assignment for unaligned loads and stores\");\n+  else if (fcode == RS6000_OVLD_VEC_LVSR && !BYTES_BIG_ENDIAN)\n+    warning (OPT_Wdeprecated,\n+\t     \"%<vec_lvsr%> is deprecated for little endian; use \"\n+\t     \"assignment for unaligned loads and stores\");\n+\n+  if (fcode == RS6000_OVLD_VEC_MUL)\n+    {\n+      /* vec_mul needs to be special cased because there are no instructions\n+\t for it for the {un}signed char, {un}signed short, and {un}signed int\n+\t types.  */\n+      if (nargs != 2)\n+\t{\n+\t  error (\"builtin %qs only accepts 2 arguments\", \"vec_mul\");\n+\t  return error_mark_node;\n+\t}\n+\n+      tree arg0 = (*arglist)[0];\n+      tree arg0_type = TREE_TYPE (arg0);\n+      tree arg1 = (*arglist)[1];\n+      tree arg1_type = TREE_TYPE (arg1);\n+\n+      /* Both arguments must be vectors and the types must be compatible.  */\n+      if (TREE_CODE (arg0_type) != VECTOR_TYPE)\n+\tgoto bad;\n+      if (!lang_hooks.types_compatible_p (arg0_type, arg1_type))\n+\tgoto bad;\n+\n+      switch (TYPE_MODE (TREE_TYPE (arg0_type)))\n+\t{\n+\t  case E_QImode:\n+\t  case E_HImode:\n+\t  case E_SImode:\n+\t  case E_DImode:\n+\t  case E_TImode:\n+\t    {\n+\t      /* For scalar types just use a multiply expression.  */\n+\t      return fold_build2_loc (loc, MULT_EXPR, TREE_TYPE (arg0), arg0,\n+\t\t\t\t      fold_convert (TREE_TYPE (arg0), arg1));\n+\t    }\n+\t  case E_SFmode:\n+\t    {\n+\t      /* For floats use the xvmulsp instruction directly.  */\n+\t      tree call = rs6000_builtin_decls_x[RS6000_BIF_XVMULSP];\n+\t      return build_call_expr (call, 2, arg0, arg1);\n+\t    }\n+\t  case E_DFmode:\n+\t    {\n+\t      /* For doubles use the xvmuldp instruction directly.  */\n+\t      tree call = rs6000_builtin_decls_x[RS6000_BIF_XVMULDP];\n+\t      return build_call_expr (call, 2, arg0, arg1);\n+\t    }\n+\t  /* Other types are errors.  */\n+\t  default:\n+\t    goto bad;\n+\t}\n+    }\n+\n+  if (fcode == RS6000_OVLD_VEC_CMPNE)\n+    {\n+      /* vec_cmpne needs to be special cased because there are no instructions\n+\t for it (prior to power 9).  */\n+      if (nargs != 2)\n+\t{\n+\t  error (\"builtin %qs only accepts 2 arguments\", \"vec_cmpne\");\n+\t  return error_mark_node;\n+\t}\n+\n+      tree arg0 = (*arglist)[0];\n+      tree arg0_type = TREE_TYPE (arg0);\n+      tree arg1 = (*arglist)[1];\n+      tree arg1_type = TREE_TYPE (arg1);\n+\n+      /* Both arguments must be vectors and the types must be compatible.  */\n+      if (TREE_CODE (arg0_type) != VECTOR_TYPE)\n+\tgoto bad;\n+      if (!lang_hooks.types_compatible_p (arg0_type, arg1_type))\n+\tgoto bad;\n+\n+      /* Power9 instructions provide the most efficient implementation of\n+\t ALTIVEC_BUILTIN_VEC_CMPNE if the mode is not DImode or TImode\n+\t or SFmode or DFmode.  */\n+      if (!TARGET_P9_VECTOR\n+\t  || (TYPE_MODE (TREE_TYPE (arg0_type)) == DImode)\n+\t  || (TYPE_MODE (TREE_TYPE (arg0_type)) == TImode)\n+\t  || (TYPE_MODE (TREE_TYPE (arg0_type)) == SFmode)\n+\t  || (TYPE_MODE (TREE_TYPE (arg0_type)) == DFmode))\n+\t{\n+\t  switch (TYPE_MODE (TREE_TYPE (arg0_type)))\n+\t    {\n+\t      /* vec_cmpneq (va, vb) == vec_nor (vec_cmpeq (va, vb),\n+\t\t vec_cmpeq (va, vb)).  */\n+\t      /* Note:  vec_nand also works but opt changes vec_nand's\n+\t\t to vec_nor's anyway.  */\n+\t    case E_QImode:\n+\t    case E_HImode:\n+\t    case E_SImode:\n+\t    case E_DImode:\n+\t    case E_TImode:\n+\t    case E_SFmode:\n+\t    case E_DFmode:\n+\t      {\n+\t\t/* call = vec_cmpeq (va, vb)\n+\t\t   result = vec_nor (call, call).  */\n+\t\tvec<tree, va_gc> *params = make_tree_vector ();\n+\t\tvec_safe_push (params, arg0);\n+\t\tvec_safe_push (params, arg1);\n+\t\ttree call = altivec_resolve_new_overloaded_builtin\n+\t\t  (loc, rs6000_builtin_decls_x[RS6000_OVLD_VEC_CMPEQ],\n+\t\t   params);\n+\t\t/* Use save_expr to ensure that operands used more than once\n+\t\t   that may have side effects (like calls) are only evaluated\n+\t\t   once.  */\n+\t\tcall = save_expr (call);\n+\t\tparams = make_tree_vector ();\n+\t\tvec_safe_push (params, call);\n+\t\tvec_safe_push (params, call);\n+\t\treturn altivec_resolve_new_overloaded_builtin\n+\t\t  (loc, rs6000_builtin_decls_x[RS6000_OVLD_VEC_NOR], params);\n+\t      }\n+\t      /* Other types are errors.  */\n+\t    default:\n+\t      goto bad;\n+\t    }\n+\t}\n+      /* else, fall through and process the Power9 alternative below */\n+    }\n+\n+  if (fcode == RS6000_OVLD_VEC_ADDE || fcode == RS6000_OVLD_VEC_SUBE)\n+    {\n+      /* vec_adde needs to be special cased because there is no instruction\n+\t  for the {un}signed int version.  */\n+      if (nargs != 3)\n+\t{\n+\t  const char *name;\n+\t  name = fcode == RS6000_OVLD_VEC_ADDE ? \"vec_adde\" : \"vec_sube\";\n+\t  error (\"builtin %qs only accepts 3 arguments\", name);\n+\t  return error_mark_node;\n+\t}\n+\n+      tree arg0 = (*arglist)[0];\n+      tree arg0_type = TREE_TYPE (arg0);\n+      tree arg1 = (*arglist)[1];\n+      tree arg1_type = TREE_TYPE (arg1);\n+      tree arg2 = (*arglist)[2];\n+      tree arg2_type = TREE_TYPE (arg2);\n+\n+      /* All 3 arguments must be vectors of (signed or unsigned) (int or\n+\t __int128) and the types must be compatible.  */\n+      if (TREE_CODE (arg0_type) != VECTOR_TYPE)\n+\tgoto bad;\n+      if (!lang_hooks.types_compatible_p (arg0_type, arg1_type)\n+\t  || !lang_hooks.types_compatible_p (arg1_type, arg2_type))\n+\tgoto bad;\n+\n+      switch (TYPE_MODE (TREE_TYPE (arg0_type)))\n+\t{\n+\t  /* For {un}signed ints,\n+\t     vec_adde (va, vb, carryv) == vec_add (vec_add (va, vb),\n+\t\t\t\t\t\t   vec_and (carryv, 1)).\n+\t     vec_sube (va, vb, carryv) == vec_sub (vec_sub (va, vb),\n+\t\t\t\t\t\t   vec_and (carryv, 1)).  */\n+\t  case E_SImode:\n+\t    {\n+\t      tree add_sub_builtin;\n+\n+\t      vec<tree, va_gc> *params = make_tree_vector ();\n+\t      vec_safe_push (params, arg0);\n+\t      vec_safe_push (params, arg1);\n+\n+\t      if (fcode == RS6000_OVLD_VEC_ADDE)\n+\t\tadd_sub_builtin = rs6000_builtin_decls_x[RS6000_OVLD_VEC_ADD];\n+\t      else\n+\t\tadd_sub_builtin = rs6000_builtin_decls_x[RS6000_OVLD_VEC_SUB];\n+\n+\t      tree call\n+\t\t= altivec_resolve_new_overloaded_builtin (loc,\n+\t\t\t\t\t\t\t  add_sub_builtin,\n+\t\t\t\t\t\t\t  params);\n+\t      tree const1 = build_int_cstu (TREE_TYPE (arg0_type), 1);\n+\t      tree ones_vector = build_vector_from_val (arg0_type, const1);\n+\t      tree and_expr = fold_build2_loc (loc, BIT_AND_EXPR, arg0_type,\n+\t\t\t\t\t       arg2, ones_vector);\n+\t      params = make_tree_vector ();\n+\t      vec_safe_push (params, call);\n+\t      vec_safe_push (params, and_expr);\n+\t      return altivec_resolve_new_overloaded_builtin (loc,\n+\t\t\t\t\t\t\t     add_sub_builtin,\n+\t\t\t\t\t\t\t     params);\n+\t    }\n+\t  /* For {un}signed __int128s use the vaddeuqm/vsubeuqm instruction\n+\t     directly.  */\n+\t  case E_TImode:\n+\t    break;\n+\n+\t  /* Types other than {un}signed int and {un}signed __int128\n+\t\tare errors.  */\n+\t  default:\n+\t    goto bad;\n+\t}\n+    }\n+\n+  if (fcode == RS6000_OVLD_VEC_ADDEC || fcode == RS6000_OVLD_VEC_SUBEC)\n+    {\n+      /* vec_addec and vec_subec needs to be special cased because there is\n+\t no instruction for the {un}signed int version.  */\n+      if (nargs != 3)\n+\t{\n+\t  const char *name;\n+\t  name = fcode == RS6000_OVLD_VEC_ADDEC ? \"vec_addec\" : \"vec_subec\";\n+\t  error (\"builtin %qs only accepts 3 arguments\", name);\n+\t  return error_mark_node;\n+\t}\n+\n+      tree arg0 = (*arglist)[0];\n+      tree arg0_type = TREE_TYPE (arg0);\n+      tree arg1 = (*arglist)[1];\n+      tree arg1_type = TREE_TYPE (arg1);\n+      tree arg2 = (*arglist)[2];\n+      tree arg2_type = TREE_TYPE (arg2);\n+\n+      /* All 3 arguments must be vectors of (signed or unsigned) (int or\n+\t __int128) and the types must be compatible.  */\n+      if (TREE_CODE (arg0_type) != VECTOR_TYPE)\n+\tgoto bad;\n+      if (!lang_hooks.types_compatible_p (arg0_type, arg1_type)\n+\t  || !lang_hooks.types_compatible_p (arg1_type, arg2_type))\n+\tgoto bad;\n+\n+      switch (TYPE_MODE (TREE_TYPE (arg0_type)))\n+\t{\n+\t  /* For {un}signed ints,\n+\t      vec_addec (va, vb, carryv) ==\n+\t\t\t\tvec_or (vec_addc (va, vb),\n+\t\t\t\t\tvec_addc (vec_add (va, vb),\n+\t\t\t\t\t\t  vec_and (carryv, 0x1))).  */\n+\t  case E_SImode:\n+\t    {\n+\t    /* Use save_expr to ensure that operands used more than once\n+\t\tthat may have side effects (like calls) are only evaluated\n+\t\tonce.  */\n+\t    tree as_builtin;\n+\t    tree as_c_builtin;\n+\n+\t    arg0 = save_expr (arg0);\n+\t    arg1 = save_expr (arg1);\n+\t    vec<tree, va_gc> *params = make_tree_vector ();\n+\t    vec_safe_push (params, arg0);\n+\t    vec_safe_push (params, arg1);\n+\n+\t    if (fcode == RS6000_OVLD_VEC_ADDEC)\n+\t      as_c_builtin = rs6000_builtin_decls_x[RS6000_OVLD_VEC_ADDC];\n+\t    else\n+\t      as_c_builtin = rs6000_builtin_decls_x[RS6000_OVLD_VEC_SUBC];\n+\n+\t    tree call1 = altivec_resolve_new_overloaded_builtin (loc,\n+\t\t\t\t\t\t\t\t as_c_builtin,\n+\t\t\t\t\t\t\t\t params);\n+\t    params = make_tree_vector ();\n+\t    vec_safe_push (params, arg0);\n+\t    vec_safe_push (params, arg1);\n+\n+\t    if (fcode == RS6000_OVLD_VEC_ADDEC)\n+\t      as_builtin = rs6000_builtin_decls_x[RS6000_OVLD_VEC_ADD];\n+\t    else\n+\t      as_builtin = rs6000_builtin_decls_x[RS6000_OVLD_VEC_SUB];\n+\n+\t    tree call2 = altivec_resolve_new_overloaded_builtin (loc,\n+\t\t\t\t\t\t\t\t as_builtin,\n+\t\t\t\t\t\t\t\t params);\n+\t    tree const1 = build_int_cstu (TREE_TYPE (arg0_type), 1);\n+\t    tree ones_vector = build_vector_from_val (arg0_type, const1);\n+\t    tree and_expr = fold_build2_loc (loc, BIT_AND_EXPR, arg0_type,\n+\t\t\t\t\t     arg2, ones_vector);\n+\t    params = make_tree_vector ();\n+\t    vec_safe_push (params, call2);\n+\t    vec_safe_push (params, and_expr);\n+\t    call2 = altivec_resolve_new_overloaded_builtin (loc, as_c_builtin,\n+\t\t\t\t\t\t\t    params);\n+\t    params = make_tree_vector ();\n+\t    vec_safe_push (params, call1);\n+\t    vec_safe_push (params, call2);\n+\t    tree or_builtin = rs6000_builtin_decls_x[RS6000_OVLD_VEC_OR];\n+\t    return altivec_resolve_new_overloaded_builtin (loc, or_builtin,\n+\t\t\t\t\t\t\t   params);\n+\t    }\n+\t  /* For {un}signed __int128s use the vaddecuq/vsubbecuq\n+\t     instructions.  This occurs through normal processing.  */\n+\t  case E_TImode:\n+\t    break;\n+\n+\t  /* Types other than {un}signed int and {un}signed __int128\n+\t\tare errors.  */\n+\t  default:\n+\t    goto bad;\n+\t}\n+    }\n+\n+  /* For now treat vec_splats and vec_promote as the same.  */\n+  if (fcode == RS6000_OVLD_VEC_SPLATS || fcode == RS6000_OVLD_VEC_PROMOTE)\n+    {\n+      tree type, arg;\n+      int size;\n+      int i;\n+      bool unsigned_p;\n+      vec<constructor_elt, va_gc> *vec;\n+      const char *name;\n+      name = fcode == RS6000_OVLD_VEC_SPLATS ? \"vec_splats\" : \"vec_promote\";\n+\n+      if (fcode == RS6000_OVLD_VEC_SPLATS && nargs != 1)\n+\t{\n+\t  error (\"builtin %qs only accepts 1 argument\", name);\n+\t  return error_mark_node;\n+\t}\n+      if (fcode == RS6000_OVLD_VEC_PROMOTE && nargs != 2)\n+\t{\n+\t  error (\"builtin %qs only accepts 2 arguments\", name);\n+\t  return error_mark_node;\n+\t}\n+      /* Ignore promote's element argument.  */\n+      if (fcode == RS6000_OVLD_VEC_PROMOTE\n+\t  && !INTEGRAL_TYPE_P (TREE_TYPE ((*arglist)[1])))\n+\tgoto bad;\n+\n+      arg = (*arglist)[0];\n+      type = TREE_TYPE (arg);\n+      if (!SCALAR_FLOAT_TYPE_P (type)\n+\t  && !INTEGRAL_TYPE_P (type))\n+\tgoto bad;\n+      unsigned_p = TYPE_UNSIGNED (type);\n+      switch (TYPE_MODE (type))\n+\t{\n+\t  case E_TImode:\n+\t    type = unsigned_p ? unsigned_V1TI_type_node : V1TI_type_node;\n+\t    size = 1;\n+\t    break;\n+\t  case E_DImode:\n+\t    type = unsigned_p ? unsigned_V2DI_type_node : V2DI_type_node;\n+\t    size = 2;\n+\t    break;\n+\t  case E_SImode:\n+\t    type = unsigned_p ? unsigned_V4SI_type_node : V4SI_type_node;\n+\t    size = 4;\n+\t    break;\n+\t  case E_HImode:\n+\t    type = unsigned_p ? unsigned_V8HI_type_node : V8HI_type_node;\n+\t    size = 8;\n+\t    break;\n+\t  case E_QImode:\n+\t    type = unsigned_p ? unsigned_V16QI_type_node : V16QI_type_node;\n+\t    size = 16;\n+\t    break;\n+\t  case E_SFmode:\n+\t    type = V4SF_type_node;\n+\t    size = 4;\n+\t    break;\n+\t  case E_DFmode:\n+\t    type = V2DF_type_node;\n+\t    size = 2;\n+\t    break;\n+\t  default:\n+\t    goto bad;\n+\t}\n+      arg = save_expr (fold_convert (TREE_TYPE (type), arg));\n+      vec_alloc (vec, size);\n+      for (i = 0; i < size; i++)\n+\t{\n+\t  constructor_elt elt = {NULL_TREE, arg};\n+\t  vec->quick_push (elt);\n+\t}\n+      return build_constructor (type, vec);\n+    }\n+\n+  /* For now use pointer tricks to do the extraction, unless we are on VSX\n+     extracting a double from a constant offset.  */\n+  if (fcode == RS6000_OVLD_VEC_EXTRACT)\n+    {\n+      tree arg1;\n+      tree arg1_type;\n+      tree arg2;\n+      tree arg1_inner_type;\n+      tree decl, stmt;\n+      tree innerptrtype;\n+      machine_mode mode;\n+\n+      /* No second argument. */\n+      if (nargs != 2)\n+\t{\n+\t  error (\"builtin %qs only accepts 2 arguments\", \"vec_extract\");\n+\t  return error_mark_node;\n+\t}\n+\n+      arg2 = (*arglist)[1];\n+      arg1 = (*arglist)[0];\n+      arg1_type = TREE_TYPE (arg1);\n+\n+      if (TREE_CODE (arg1_type) != VECTOR_TYPE)\n+\tgoto bad;\n+      if (!INTEGRAL_TYPE_P (TREE_TYPE (arg2)))\n+\tgoto bad;\n+\n+      /* See if we can optimize vec_extracts with the current VSX instruction\n+\t set.  */\n+      mode = TYPE_MODE (arg1_type);\n+      if (VECTOR_MEM_VSX_P (mode))\n+\n+\t{\n+\t  tree call = NULL_TREE;\n+\t  int nunits = GET_MODE_NUNITS (mode);\n+\n+\t  arg2 = fold_for_warn (arg2);\n+\n+\t  /* If the second argument is an integer constant, generate\n+\t     the built-in code if we can.  We need 64-bit and direct\n+\t     move to extract the small integer vectors.  */\n+\t  if (TREE_CODE (arg2) == INTEGER_CST)\n+\t    {\n+\t      wide_int selector = wi::to_wide (arg2);\n+\t      selector = wi::umod_trunc (selector, nunits);\n+\t      arg2 = wide_int_to_tree (TREE_TYPE (arg2), selector);\n+\t      switch (mode)\n+\t\t{\n+\t\tdefault:\n+\t\t  break;\n+\n+\t\tcase E_V1TImode:\n+\t\t  call = rs6000_builtin_decls_x[RS6000_BIF_VEC_EXT_V1TI];\n+\t\t  break;\n+\n+\t\tcase E_V2DFmode:\n+\t\t  call = rs6000_builtin_decls_x[RS6000_BIF_VEC_EXT_V2DF];\n+\t\t  break;\n+\n+\t\tcase E_V2DImode:\n+\t\t  call = rs6000_builtin_decls_x[RS6000_BIF_VEC_EXT_V2DI];\n+\t\t  break;\n+\n+\t\tcase E_V4SFmode:\n+\t\t  call = rs6000_builtin_decls_x[RS6000_BIF_VEC_EXT_V4SF];\n+\t\t  break;\n+\n+\t\tcase E_V4SImode:\n+\t\t  if (TARGET_DIRECT_MOVE_64BIT)\n+\t\t    call = rs6000_builtin_decls_x[RS6000_BIF_VEC_EXT_V4SI];\n+\t\t  break;\n+\n+\t\tcase E_V8HImode:\n+\t\t  if (TARGET_DIRECT_MOVE_64BIT)\n+\t\t    call = rs6000_builtin_decls_x[RS6000_BIF_VEC_EXT_V8HI];\n+\t\t  break;\n+\n+\t\tcase E_V16QImode:\n+\t\t  if (TARGET_DIRECT_MOVE_64BIT)\n+\t\t    call = rs6000_builtin_decls_x[RS6000_BIF_VEC_EXT_V16QI];\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  /* If the second argument is variable, we can optimize it if we are\n+\t     generating 64-bit code on a machine with direct move.  */\n+\t  else if (TREE_CODE (arg2) != INTEGER_CST && TARGET_DIRECT_MOVE_64BIT)\n+\t    {\n+\t      switch (mode)\n+\t\t{\n+\t\tdefault:\n+\t\t  break;\n+\n+\t\tcase E_V2DFmode:\n+\t\t  call = rs6000_builtin_decls_x[RS6000_BIF_VEC_EXT_V2DF];\n+\t\t  break;\n+\n+\t\tcase E_V2DImode:\n+\t\t  call = rs6000_builtin_decls_x[RS6000_BIF_VEC_EXT_V2DI];\n+\t\t  break;\n+\n+\t\tcase E_V4SFmode:\n+\t\t  call = rs6000_builtin_decls_x[RS6000_BIF_VEC_EXT_V4SF];\n+\t\t  break;\n+\n+\t\tcase E_V4SImode:\n+\t\t  call = rs6000_builtin_decls_x[RS6000_BIF_VEC_EXT_V4SI];\n+\t\t  break;\n+\n+\t\tcase E_V8HImode:\n+\t\t  call = rs6000_builtin_decls_x[RS6000_BIF_VEC_EXT_V8HI];\n+\t\t  break;\n+\n+\t\tcase E_V16QImode:\n+\t\t  call = rs6000_builtin_decls_x[RS6000_BIF_VEC_EXT_V16QI];\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  if (call)\n+\t    {\n+\t      tree result = build_call_expr (call, 2, arg1, arg2);\n+\t      /* Coerce the result to vector element type.  May be no-op.  */\n+\t      arg1_inner_type = TREE_TYPE (arg1_type);\n+\t      result = fold_convert (arg1_inner_type, result);\n+\t      return result;\n+\t    }\n+\t}\n+\n+      /* Build *(((arg1_inner_type*)&(vector type){arg1})+arg2). */\n+      arg1_inner_type = TREE_TYPE (arg1_type);\n+      tree subp = build_int_cst (TREE_TYPE (arg2),\n+\t\t\t\t TYPE_VECTOR_SUBPARTS (arg1_type) - 1);\n+      arg2 = build_binary_op (loc, BIT_AND_EXPR, arg2, subp, 0);\n+      decl = build_decl (loc, VAR_DECL, NULL_TREE, arg1_type);\n+      DECL_EXTERNAL (decl) = 0;\n+      TREE_PUBLIC (decl) = 0;\n+      DECL_CONTEXT (decl) = current_function_decl;\n+      TREE_USED (decl) = 1;\n+      TREE_TYPE (decl) = arg1_type;\n+      TREE_READONLY (decl) = TYPE_READONLY (arg1_type);\n+      if (c_dialect_cxx ())\n+\t{\n+\t  stmt = build4 (TARGET_EXPR, arg1_type, decl, arg1,\n+\t\t\t NULL_TREE, NULL_TREE);\n+\t  SET_EXPR_LOCATION (stmt, loc);\n+\t}\n+      else\n+\t{\n+\t  DECL_INITIAL (decl) = arg1;\n+\t  stmt = build1 (DECL_EXPR, arg1_type, decl);\n+\t  TREE_ADDRESSABLE (decl) = 1;\n+\t  SET_EXPR_LOCATION (stmt, loc);\n+\t  stmt = build1 (COMPOUND_LITERAL_EXPR, arg1_type, stmt);\n+\t}\n+\n+      innerptrtype = build_pointer_type (arg1_inner_type);\n+\n+      stmt = build_unary_op (loc, ADDR_EXPR, stmt, 0);\n+      stmt = convert (innerptrtype, stmt);\n+      stmt = build_binary_op (loc, PLUS_EXPR, stmt, arg2, 1);\n+      stmt = build_indirect_ref (loc, stmt, RO_NULL);\n+\n+      /* PR83660: We mark this as having side effects so that\n+\t downstream in fold_build_cleanup_point_expr () it will get a\n+\t CLEANUP_POINT_EXPR.  If it does not we can run into an ICE\n+\t later in gimplify_cleanup_point_expr ().  Potentially this\n+\t causes missed optimization because there actually is no side\n+\t effect.  */\n+      if (c_dialect_cxx ())\n+\tTREE_SIDE_EFFECTS (stmt) = 1;\n+\n+      return stmt;\n+    }\n+\n+  /* For now use pointer tricks to do the insertion, unless we are on VSX\n+     inserting a double to a constant offset.  */\n+  if (fcode == RS6000_OVLD_VEC_INSERT)\n+    {\n+      tree arg0;\n+      tree arg1;\n+      tree arg2;\n+      tree arg1_type;\n+      tree decl, stmt;\n+      machine_mode mode;\n+\n+      /* No second or third arguments. */\n+      if (nargs != 3)\n+\t{\n+\t  error (\"builtin %qs only accepts 3 arguments\", \"vec_insert\");\n+\t  return error_mark_node;\n+\t}\n+\n+      arg0 = (*arglist)[0];\n+      arg1 = (*arglist)[1];\n+      arg1_type = TREE_TYPE (arg1);\n+      arg2 = fold_for_warn ((*arglist)[2]);\n+\n+      if (TREE_CODE (arg1_type) != VECTOR_TYPE)\n+\tgoto bad;\n+      if (!INTEGRAL_TYPE_P (TREE_TYPE (arg2)))\n+\tgoto bad;\n+\n+      /* If we can use the VSX xxpermdi instruction, use that for insert.  */\n+      mode = TYPE_MODE (arg1_type);\n+      if ((mode == V2DFmode || mode == V2DImode) && VECTOR_UNIT_VSX_P (mode)\n+\t  && TREE_CODE (arg2) == INTEGER_CST)\n+\t{\n+\t  wide_int selector = wi::to_wide (arg2);\n+\t  selector = wi::umod_trunc (selector, 2);\n+\t  tree call = NULL_TREE;\n+\n+\t  arg2 = wide_int_to_tree (TREE_TYPE (arg2), selector);\n+\t  if (mode == V2DFmode)\n+\t    call = rs6000_builtin_decls_x[RS6000_BIF_VEC_SET_V2DF];\n+\t  else if (mode == V2DImode)\n+\t    call = rs6000_builtin_decls_x[RS6000_BIF_VEC_SET_V2DI];\n+\n+\t  /* Note, __builtin_vec_insert_<xxx> has vector and scalar types\n+\t     reversed.  */\n+\t  if (call)\n+\t    return build_call_expr (call, 3, arg1, arg0, arg2);\n+\t}\n+      else if (mode == V1TImode && VECTOR_UNIT_VSX_P (mode)\n+\t       && TREE_CODE (arg2) == INTEGER_CST)\n+\t{\n+\t  tree call = rs6000_builtin_decls_x[RS6000_BIF_VEC_SET_V1TI];\n+\t  wide_int selector = wi::zero(32);\n+\n+\t  arg2 = wide_int_to_tree (TREE_TYPE (arg2), selector);\n+\t  /* Note, __builtin_vec_insert_<xxx> has vector and scalar types\n+\t     reversed.  */\n+\t  return build_call_expr (call, 3, arg1, arg0, arg2);\n+\t}\n+\n+      /* Build *(((arg1_inner_type*)&(vector type){arg1})+arg2) = arg0 with\n+\t VIEW_CONVERT_EXPR.  i.e.:\n+\t D.3192 = v1;\n+\t _1 = n & 3;\n+\t VIEW_CONVERT_EXPR<int[4]>(D.3192)[_1] = i;\n+\t v1 = D.3192;\n+\t D.3194 = v1;  */\n+      if (TYPE_VECTOR_SUBPARTS (arg1_type) == 1)\n+\targ2 = build_int_cst (TREE_TYPE (arg2), 0);\n+      else\n+\targ2 = build_binary_op (loc, BIT_AND_EXPR, arg2,\n+\t\t\t\tbuild_int_cst (TREE_TYPE (arg2),\n+\t\t\t\t\t       TYPE_VECTOR_SUBPARTS (arg1_type)\n+\t\t\t\t\t       - 1), 0);\n+      decl = build_decl (loc, VAR_DECL, NULL_TREE, arg1_type);\n+      DECL_EXTERNAL (decl) = 0;\n+      TREE_PUBLIC (decl) = 0;\n+      DECL_CONTEXT (decl) = current_function_decl;\n+      TREE_USED (decl) = 1;\n+      TREE_TYPE (decl) = arg1_type;\n+      TREE_READONLY (decl) = TYPE_READONLY (arg1_type);\n+      TREE_ADDRESSABLE (decl) = 1;\n+      if (c_dialect_cxx ())\n+\t{\n+\t  stmt = build4 (TARGET_EXPR, arg1_type, decl, arg1,\n+\t\t\t NULL_TREE, NULL_TREE);\n+\t  SET_EXPR_LOCATION (stmt, loc);\n+\t}\n+      else\n+\t{\n+\t  DECL_INITIAL (decl) = arg1;\n+\t  stmt = build1 (DECL_EXPR, arg1_type, decl);\n+\t  SET_EXPR_LOCATION (stmt, loc);\n+\t  stmt = build1 (COMPOUND_LITERAL_EXPR, arg1_type, stmt);\n+\t}\n+\n+      if (TARGET_VSX)\n+\t{\n+\t  stmt = build_array_ref (loc, stmt, arg2);\n+\t  stmt = fold_build2 (MODIFY_EXPR, TREE_TYPE (arg0), stmt,\n+\t\t\t      convert (TREE_TYPE (stmt), arg0));\n+\t  stmt = build2 (COMPOUND_EXPR, arg1_type, stmt, decl);\n+\t}\n+      else\n+\t{\n+\t  tree arg1_inner_type;\n+\t  tree innerptrtype;\n+\t  arg1_inner_type = TREE_TYPE (arg1_type);\n+\t  innerptrtype = build_pointer_type (arg1_inner_type);\n+\n+\t  stmt = build_unary_op (loc, ADDR_EXPR, stmt, 0);\n+\t  stmt = convert (innerptrtype, stmt);\n+\t  stmt = build_binary_op (loc, PLUS_EXPR, stmt, arg2, 1);\n+\t  stmt = build_indirect_ref (loc, stmt, RO_NULL);\n+\t  stmt = build2 (MODIFY_EXPR, TREE_TYPE (stmt), stmt,\n+\t\t\t convert (TREE_TYPE (stmt), arg0));\n+\t  stmt = build2 (COMPOUND_EXPR, arg1_type, stmt, decl);\n+\t}\n+      return stmt;\n+    }\n+\n+  unsigned int n;\n+  for (n = 0;\n+       !VOID_TYPE_P (TREE_VALUE (fnargs)) && n < nargs;\n+       fnargs = TREE_CHAIN (fnargs), n++)\n+    {\n+      tree decl_type = TREE_VALUE (fnargs);\n+      tree arg = (*arglist)[n];\n+      tree type;\n+\n+      if (arg == error_mark_node)\n+\treturn error_mark_node;\n+\n+      if (n >= MAX_OVLD_ARGS)\n+\tabort ();\n+\n+      arg = default_conversion (arg);\n+\n+      /* The C++ front-end converts float * to const void * using\n+\t NOP_EXPR<const void *> (NOP_EXPR<void *> (x)).  */\n+      type = TREE_TYPE (arg);\n+      if (POINTER_TYPE_P (type)\n+\t  && TREE_CODE (arg) == NOP_EXPR\n+\t  && lang_hooks.types_compatible_p (TREE_TYPE (arg),\n+\t\t\t\t\t    const_ptr_type_node)\n+\t  && lang_hooks.types_compatible_p (TREE_TYPE (TREE_OPERAND (arg, 0)),\n+\t\t\t\t\t    ptr_type_node))\n+\t{\n+\t  arg = TREE_OPERAND (arg, 0);\n+\t  type = TREE_TYPE (arg);\n+\t}\n+\n+      /* Remove the const from the pointers to simplify the overload\n+\t matching further down.  */\n+      if (POINTER_TYPE_P (decl_type)\n+\t  && POINTER_TYPE_P (type)\n+\t  && TYPE_QUALS (TREE_TYPE (type)) != 0)\n+\t{\n+\t  if (TYPE_READONLY (TREE_TYPE (type))\n+\t      && !TYPE_READONLY (TREE_TYPE (decl_type)))\n+\t    warning (0, \"passing argument %d of %qE discards const qualifier \"\n+\t\t     \"from pointer target type\", n + 1, fndecl);\n+\t  type = build_qualified_type (TREE_TYPE (type), 0);\n+\t  type = build_pointer_type (type);\n+\t  arg = fold_convert (type, arg);\n+\t}\n+\n+      /* For RS6000_OVLD_VEC_LXVL, convert any const * to its non constant\n+\t equivalent to simplify the overload matching below.  */\n+      if (fcode == RS6000_OVLD_VEC_LXVL)\n+\t{\n+\t  if (POINTER_TYPE_P (type)\n+\t      && TYPE_READONLY (TREE_TYPE (type)))\n+\t    {\n+\t      type = build_qualified_type (TREE_TYPE (type), 0);\n+\t      type = build_pointer_type (type);\n+\t      arg = fold_convert (type, arg);\n+\t    }\n+\t}\n+\n+      args[n] = arg;\n+      types[n] = type;\n+    }\n+\n+  /* If the number of arguments did not match the prototype, return NULL\n+     and the generic code will issue the appropriate error message.  */\n+  if (!VOID_TYPE_P (TREE_VALUE (fnargs)) || n < nargs)\n+    return NULL;\n+\n+  if (fcode == RS6000_OVLD_VEC_STEP)\n+    {\n+      if (TREE_CODE (types[0]) != VECTOR_TYPE)\n+\tgoto bad;\n+\n+      return build_int_cst (NULL_TREE, TYPE_VECTOR_SUBPARTS (types[0]));\n+    }\n+\n+  {\n+    bool unsupported_builtin = false;\n+    enum rs6000_gen_builtins overloaded_code;\n+    bool supported = false;\n+    ovlddata *instance = rs6000_overload_info[adj_fcode].first_instance;\n+    gcc_assert (instance != NULL);\n+\n+    /* Need to special case __builtin_cmpb because the overloaded forms\n+       of this function take (unsigned int, unsigned int) or (unsigned\n+       long long int, unsigned long long int).  Since C conventions\n+       allow the respective argument types to be implicitly coerced into\n+       each other, the default handling does not provide adequate\n+       discrimination between the desired forms of the function.  */\n+    if (fcode == RS6000_OVLD_SCAL_CMPB)\n+      {\n+\tmachine_mode arg1_mode = TYPE_MODE (types[0]);\n+\tmachine_mode arg2_mode = TYPE_MODE (types[1]);\n+\n+\tif (nargs != 2)\n+\t  {\n+\t    error (\"builtin %qs only accepts 2 arguments\", \"__builtin_cmpb\");\n+\t    return error_mark_node;\n+\t  }\n+\n+\t/* If any supplied arguments are wider than 32 bits, resolve to\n+\t   64-bit variant of built-in function.  */\n+\tif (GET_MODE_PRECISION (arg1_mode) > 32\n+\t    || GET_MODE_PRECISION (arg2_mode) > 32)\n+\t  /* Assure all argument and result types are compatible with\n+\t     the built-in function represented by RS6000_BIF_CMPB.  */\n+\t  overloaded_code = RS6000_BIF_CMPB;\n+\telse\n+\t  /* Assure all argument and result types are compatible with\n+\t     the built-in function represented by RS6000_BIF_CMPB_32.  */\n+\t  overloaded_code = RS6000_BIF_CMPB_32;\n+\n+\twhile (instance && instance->bifid != overloaded_code)\n+\t  instance = instance->next;\n+\n+\tgcc_assert (instance != NULL);\n+\ttree fntype = rs6000_builtin_info_x[instance->bifid].fntype;\n+\ttree parmtype0 = TREE_VALUE (TYPE_ARG_TYPES (fntype));\n+\ttree parmtype1 = TREE_VALUE (TREE_CHAIN (TYPE_ARG_TYPES (fntype)));\n+\n+\tif (rs6000_new_builtin_type_compatible (types[0], parmtype0)\n+\t    && rs6000_new_builtin_type_compatible (types[1], parmtype1))\n+\t  {\n+\t    if (rs6000_builtin_decl (instance->bifid, false) != error_mark_node\n+\t\t&& rs6000_new_builtin_is_supported (instance->bifid))\n+\t      {\n+\t\ttree ret_type = TREE_TYPE (instance->fntype);\n+\t\treturn altivec_build_new_resolved_builtin (args, n, fntype,\n+\t\t\t\t\t\t\t   ret_type,\n+\t\t\t\t\t\t\t   instance->bifid,\n+\t\t\t\t\t\t\t   fcode);\n+\t      }\n+\t    else\n+\t      unsupported_builtin = true;\n+\t  }\n+      }\n+    else if (fcode == RS6000_OVLD_VEC_VSIE)\n+      {\n+\tmachine_mode arg1_mode = TYPE_MODE (types[0]);\n+\n+\tif (nargs != 2)\n+\t  {\n+\t    error (\"builtin %qs only accepts 2 arguments\",\n+\t\t   \"scalar_insert_exp\");\n+\t    return error_mark_node;\n+\t  }\n+\n+\t/* If supplied first argument is wider than 64 bits, resolve to\n+\t   128-bit variant of built-in function.  */\n+\tif (GET_MODE_PRECISION (arg1_mode) > 64)\n+\t  {\n+\t    /* If first argument is of float variety, choose variant\n+\t       that expects __ieee128 argument.  Otherwise, expect\n+\t       __int128 argument.  */\n+\t    if (GET_MODE_CLASS (arg1_mode) == MODE_FLOAT)\n+\t      overloaded_code = RS6000_BIF_VSIEQPF;\n+\t    else\n+\t      overloaded_code = RS6000_BIF_VSIEQP;\n+\t  }\n+\telse\n+\t  {\n+\t    /* If first argument is of float variety, choose variant\n+\t       that expects double argument.  Otherwise, expect\n+\t       long long int argument.  */\n+\t    if (GET_MODE_CLASS (arg1_mode) == MODE_FLOAT)\n+\t      overloaded_code = RS6000_BIF_VSIEDPF;\n+\t    else\n+\t      overloaded_code = RS6000_BIF_VSIEDP;\n+\t  }\n+\n+\twhile (instance && instance->bifid != overloaded_code)\n+\t  instance = instance->next;\n+\n+\tgcc_assert (instance != NULL);\n+\ttree fntype = rs6000_builtin_info_x[instance->bifid].fntype;\n+\ttree parmtype0 = TREE_VALUE (TYPE_ARG_TYPES (fntype));\n+\ttree parmtype1 = TREE_VALUE (TREE_CHAIN (TYPE_ARG_TYPES (fntype)));\n+\n+\tif (rs6000_new_builtin_type_compatible (types[0], parmtype0)\n+\t    && rs6000_new_builtin_type_compatible (types[1], parmtype1))\n+\t  {\n+\t    if (rs6000_builtin_decl (instance->bifid, false) != error_mark_node\n+\t\t&& rs6000_new_builtin_is_supported (instance->bifid))\n+\t      {\n+\t\ttree ret_type = TREE_TYPE (instance->fntype);\n+\t\treturn altivec_build_new_resolved_builtin (args, n, fntype,\n+\t\t\t\t\t\t\t   ret_type,\n+\t\t\t\t\t\t\t   instance->bifid,\n+\t\t\t\t\t\t\t   fcode);\n+\t      }\n+\t    else\n+\t      unsupported_builtin = true;\n+\t  }\n+      }\n+    else\n+      {\n+\t/* Functions with no arguments can have only one overloaded\n+\t   instance.  */\n+\tgcc_assert (n > 0 || !instance->next);\n+\n+\tfor (; instance != NULL; instance = instance->next)\n+\t  {\n+\t    bool mismatch = false;\n+\t    tree nextparm = TYPE_ARG_TYPES (instance->fntype);\n+\n+\t    for (unsigned int arg_i = 0;\n+\t\t arg_i < nargs && nextparm != NULL;\n+\t\t arg_i++)\n+\t      {\n+\t\ttree parmtype = TREE_VALUE (nextparm);\n+\t\tif (!rs6000_new_builtin_type_compatible (types[arg_i],\n+\t\t\t\t\t\t\t parmtype))\n+\t\t  {\n+\t\t    mismatch = true;\n+\t\t    break;\n+\t\t  }\n+\t\tnextparm = TREE_CHAIN (nextparm);\n+\t      }\n+\n+\t    if (mismatch)\n+\t      continue;\n+\n+\t    supported = rs6000_new_builtin_is_supported (instance->bifid);\n+\t    if (rs6000_builtin_decl (instance->bifid, false) != error_mark_node\n+\t\t&& supported)\n+\t      {\n+\t\ttree fntype = rs6000_builtin_info_x[instance->bifid].fntype;\n+\t\ttree ret_type = TREE_TYPE (instance->fntype);\n+\t\treturn altivec_build_new_resolved_builtin (args, n, fntype,\n+\t\t\t\t\t\t\t   ret_type,\n+\t\t\t\t\t\t\t   instance->bifid,\n+\t\t\t\t\t\t\t   fcode);\n+\t      }\n+\t    else\n+\t      {\n+\t\tunsupported_builtin = true;\n+\t\tbreak;\n+\t      }\n+\t  }\n+      }\n+\n+    if (unsupported_builtin)\n+      {\n+\tconst char *name = rs6000_overload_info[adj_fcode].ovld_name;\n+\tif (!supported)\n+\t  {\n+\t    const char *internal_name\n+\t      = rs6000_builtin_info_x[instance->bifid].bifname;\n+\t    /* An error message making reference to the name of the\n+\t       non-overloaded function has already been issued.  Add\n+\t       clarification of the previous message.  */\n+\t    rich_location richloc (line_table, input_location);\n+\t    inform (&richloc, \"builtin %qs requires builtin %qs\",\n+\t\t    name, internal_name);\n+\t  }\n+\telse\n+\t  error (\"%qs is not supported in this compiler configuration\", name);\n+\n+\treturn error_mark_node;\n+      }\n+  }\n+ bad:\n+  {\n+    const char *name = rs6000_overload_info[adj_fcode].ovld_name;\n+    error (\"invalid parameter combination for AltiVec intrinsic %qs\", name);\n+    return error_mark_node;\n+  }\n+}"}, {"sha": "a55cb7c0392e911e109e120e4b4c6edcf99ed105", "filename": "gcc/config/rs6000/rs6000-call.c", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93b5a667100caa40ecd10f54c0fcdac04f3bc0d7/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93b5a667100caa40ecd10f54c0fcdac04f3bc0d7/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-call.c?ref=93b5a667100caa40ecd10f54c0fcdac04f3bc0d7", "patch": "@@ -12971,6 +12971,59 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n   return false;\n }\n \n+/* Check whether a builtin function is supported in this target\n+   configuration.  */\n+bool\n+rs6000_new_builtin_is_supported (enum rs6000_gen_builtins fncode)\n+{\n+  switch (rs6000_builtin_info_x[(size_t) fncode].enable)\n+    {\n+    case ENB_ALWAYS:\n+      return true;\n+    case ENB_P5:\n+      return TARGET_POPCNTB;\n+    case ENB_P6:\n+      return TARGET_CMPB;\n+    case ENB_P7:\n+      return TARGET_POPCNTD;\n+    case ENB_P7_64:\n+      return TARGET_POPCNTD && TARGET_POWERPC64;\n+    case ENB_P8:\n+      return TARGET_DIRECT_MOVE;\n+    case ENB_P8V:\n+      return TARGET_P8_VECTOR;\n+    case ENB_P9:\n+      return TARGET_MODULO;\n+    case ENB_P9_64:\n+      return TARGET_MODULO && TARGET_POWERPC64;\n+    case ENB_P9V:\n+      return TARGET_P9_VECTOR;\n+    case ENB_P10:\n+      return TARGET_POWER10;\n+    case ENB_P10_64:\n+      return TARGET_POWER10 && TARGET_POWERPC64;\n+    case ENB_ALTIVEC:\n+      return TARGET_ALTIVEC;\n+    case ENB_VSX:\n+      return TARGET_VSX;\n+    case ENB_CELL:\n+      return TARGET_ALTIVEC && rs6000_cpu == PROCESSOR_CELL;\n+    case ENB_IEEE128_HW:\n+      return TARGET_FLOAT128_HW;\n+    case ENB_DFP:\n+      return TARGET_DFP;\n+    case ENB_CRYPTO:\n+      return TARGET_CRYPTO;\n+    case ENB_HTM:\n+      return TARGET_HTM;\n+    case ENB_MMA:\n+      return TARGET_MMA;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  gcc_unreachable ();\n+}\n+\n /* Expand an expression EXP that calls a built-in function,\n    with result going to TARGET if that's convenient\n    (and in mode MODE if that's convenient)."}, {"sha": "f65932e1cd5ec0840b4bb36b4f76a18650ed6e3d", "filename": "gcc/config/rs6000/rs6000-gen-builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93b5a667100caa40ecd10f54c0fcdac04f3bc0d7/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93b5a667100caa40ecd10f54c0fcdac04f3bc0d7/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c?ref=93b5a667100caa40ecd10f54c0fcdac04f3bc0d7", "patch": "@@ -2314,7 +2314,7 @@ write_decls (void)\n \n   fprintf (header_file, \"extern void rs6000_init_generated_builtins ();\\n\\n\");\n   fprintf (header_file,\n-\t   \"extern bool rs6000_new_builtin_is_supported_p \"\n+\t   \"extern bool rs6000_new_builtin_is_supported \"\n \t   \"(rs6000_gen_builtins);\\n\");\n   fprintf (header_file,\n \t   \"extern tree rs6000_builtin_decl (unsigned, \""}]}