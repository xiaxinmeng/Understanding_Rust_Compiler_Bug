{"sha": "0dd0e980b5c9b23a3749647c69603f8a29eea4c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRkMGU5ODBiNWM5YjIzYTM3NDk2NDdjNjk2MDNmOGEyOWVlYTRjMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-12-13T11:34:11Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-12-13T11:34:11Z"}, "message": "predict.c (estimate_probability): Reorganize opcode heuristics.\n\n\t* predict.c (estimate_probability): Reorganize opcode heuristics.\n\t* predict.def (PRED_OPCODE_POSITIVE, PRED_OPCODE_NONEQUAL,\n\tPRED_FPOPCODE): New.\n\n\t* i386.c (override_options): Recognize various CPU variants and set\n\tSSE/MMX/3dNOW flags accordingly.\n\t* i386.h (MASK_MMX_SET, MASK_SSE_SET, MASK_SSE2_SET, MASK_3DNOW_SET,\n\tMASK_3DNOW_A_SET): New.\n\t(MASK_ACCUMULATE_OUTGOING_ARGS_SET): New.\n\t(MASK_NO_ACCUMULATE_OUTGOING_ARGS): Delete.\n\t(MASK_*): Renumber.\n\t(TARGET_FLAGS): Use new masks.\n\t(CPP_CPU_SPECS): Recognize new CPU variants.\n\t* invoke.texi (-mcpu): Update documentation.\n\n\t* flags.h (flag_prefetch_loop_arrays): Declare.\n\t* loop.h (LOOP_PREFETCH): Define new constant.\n\t* loop.c (strength_reduce): Call emit_prefetch_instructions.\n\t(MAX_PREFETCHES, PREFETCH_BLOCKS_BEFORE_LOOP_MAX,\n\tPREFETCH_BLOCKS_BEFORE_LOOP_MIN, PREFETCH_BLOCKS_IN_LOOP_MIN): New\n\tconstants.\n\t(check_store_data): New structure.\n\t(check_store, emit_prefetch_instructions, rtx_equal_for_prefetch_p):\n\tNew functions.\n\t* toplev.c: Include insn-flags.h.\n\t(flag_prefetch_loop_arrays): New global variable.\n\t(lang_independent_option): Add -fprefetch-loop-arrays.\n\t(rest_of_compilation) Pass LOOP_PREFETCH when flag_prefetch_loop_arrays\n        is set.\n\t* Makefile.in (toplev.c): Depend on insn-flags.h.\n\t* invoke.texi (-fprefetch-loop-arrays): Document.\n\n\t* predict.c (estimate_probability): Distribute the loop exit\n\tprobability according to number of exit edges.\n\n\t* cfgcleanup.c (insns_match_p): Break out from ...;\n\t(flow_find_cross_jump): ... here;\n\t(outgoing_edges_match): Add parameter MODE; attempt to match everything\n\texcept for tablejumps.\n\t(try_crossjump_to_edge): Accept complex edges.\n\t(try_crossjump_bb): Likewise.\n\nFrom-SVN: r47969", "tree": {"sha": "370e6c425d4395a411fdf96a2629203ee94049f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/370e6c425d4395a411fdf96a2629203ee94049f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0dd0e980b5c9b23a3749647c69603f8a29eea4c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dd0e980b5c9b23a3749647c69603f8a29eea4c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dd0e980b5c9b23a3749647c69603f8a29eea4c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dd0e980b5c9b23a3749647c69603f8a29eea4c3/comments", "author": null, "committer": null, "parents": [{"sha": "85230e5255cd8dc23a0d0440992ac24a119b32a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85230e5255cd8dc23a0d0440992ac24a119b32a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85230e5255cd8dc23a0d0440992ac24a119b32a5"}], "stats": {"total": 1269, "additions": 1037, "deletions": 232}, "files": [{"sha": "cb7af2d3670e07e604a6f8fca85c21658021374a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dd0e980b5c9b23a3749647c69603f8a29eea4c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dd0e980b5c9b23a3749647c69603f8a29eea4c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0dd0e980b5c9b23a3749647c69603f8a29eea4c3", "patch": "@@ -1,3 +1,47 @@\n+Thu Dec 13 12:31:07 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* predict.c (estimate_probability): Reorganize opcode heuristics.\n+\t* predict.def (PRED_OPCODE_POSITIVE, PRED_OPCODE_NONEQUAL,\n+\tPRED_FPOPCODE): New.\n+\n+\t* i386.c (override_options): Recognize various CPU variants and set\n+\tSSE/MMX/3dNOW flags accordingly.\n+\t* i386.h (MASK_MMX_SET, MASK_SSE_SET, MASK_SSE2_SET, MASK_3DNOW_SET,\n+\tMASK_3DNOW_A_SET): New.\n+\t(MASK_ACCUMULATE_OUTGOING_ARGS_SET): New.\n+\t(MASK_NO_ACCUMULATE_OUTGOING_ARGS): Delete.\n+\t(MASK_*): Renumber.\n+\t(TARGET_FLAGS): Use new masks.\n+\t(CPP_CPU_SPECS): Recognize new CPU variants.\n+\t* invoke.texi (-mcpu): Update documentation.\n+\n+\t* flags.h (flag_prefetch_loop_arrays): Declare.\n+\t* loop.h (LOOP_PREFETCH): Define new constant.\n+\t* loop.c (strength_reduce): Call emit_prefetch_instructions.\n+\t(MAX_PREFETCHES, PREFETCH_BLOCKS_BEFORE_LOOP_MAX,\n+\tPREFETCH_BLOCKS_BEFORE_LOOP_MIN, PREFETCH_BLOCKS_IN_LOOP_MIN): New\n+\tconstants.\n+\t(check_store_data): New structure.\n+\t(check_store, emit_prefetch_instructions, rtx_equal_for_prefetch_p):\n+\tNew functions.\n+\t* toplev.c: Include insn-flags.h.\n+\t(flag_prefetch_loop_arrays): New global variable.\n+\t(lang_independent_option): Add -fprefetch-loop-arrays.\n+\t(rest_of_compilation) Pass LOOP_PREFETCH when flag_prefetch_loop_arrays\n+        is set.\n+\t* Makefile.in (toplev.c): Depend on insn-flags.h.\n+\t* invoke.texi (-fprefetch-loop-arrays): Document.\n+\n+\t* predict.c (estimate_probability): Distribute the loop exit\n+\tprobability according to number of exit edges.\n+\n+\t* cfgcleanup.c (insns_match_p): Break out from ...;\n+\t(flow_find_cross_jump): ... here;\n+\t(outgoing_edges_match): Add parameter MODE; attempt to match everything\n+\texcept for tablejumps.\n+\t(try_crossjump_to_edge): Accept complex edges.\n+\t(try_crossjump_bb): Likewise.\n+\n 2001-11-29  Corey Minyard <minyard@acm.org>\n \n \t* recog.c (validate_replace_rtx_1): Use simplify_gen_binary"}, {"sha": "adb7281d1b92467859a29375a2d9db56f3df7872", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dd0e980b5c9b23a3749647c69603f8a29eea4c3/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dd0e980b5c9b23a3749647c69603f8a29eea4c3/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0dd0e980b5c9b23a3749647c69603f8a29eea4c3", "patch": "@@ -1321,7 +1321,7 @@ toplev.o : toplev.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) function.h \\\n    dwarf2out.h sdbout.h dbxout.h $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) \\\n    graph.h $(LOOP_H) except.h $(REGS_H) $(TIMEVAR_H) $(lang_options_files) \\\n    ssa.h $(PARAMS_H) $(TM_P_H) reload.h dwarf2asm.h $(TARGET_H) halfpic.h \\\n-   langhooks.h\n+   langhooks.h insn-flags.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t  -DTARGET_NAME=\\\"$(target_alias)\\\" \\\n \t  -c $(srcdir)/toplev.c $(OUTPUT_OPTION)"}, {"sha": "e7e31f94b6cb09738662038a45d133af3870af2a", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 169, "deletions": 115, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dd0e980b5c9b23a3749647c69603f8a29eea4c3/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dd0e980b5c9b23a3749647c69603f8a29eea4c3/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=0dd0e980b5c9b23a3749647c69603f8a29eea4c3", "patch": "@@ -64,9 +64,11 @@ enum bb_flags {\n \n static bool try_crossjump_to_edge\tPARAMS ((int, edge, edge));\n static bool try_crossjump_bb\t\tPARAMS ((int, basic_block));\n-static bool outgoing_edges_match\tPARAMS ((basic_block, basic_block));\n+static bool outgoing_edges_match\tPARAMS ((int,\n+\t\t\t\t\t\t basic_block, basic_block));\n static int flow_find_cross_jump\t\tPARAMS ((int, basic_block, basic_block,\n \t\t\t\t\t\t rtx *, rtx *));\n+static bool insns_match_p\t\tPARAMS ((int, rtx, rtx));\n \n static bool delete_unreachable_blocks\tPARAMS ((void));\n static bool label_is_jump_target_p\tPARAMS ((rtx, rtx));\n@@ -546,6 +548,108 @@ merge_blocks (e, b, c, mode)\n   return false;\n }\n \f\n+\n+/* Return true if I1 and I2 are equivalent and thus can be crossjumped.  */\n+\n+static bool\n+insns_match_p (mode, i1, i2)\n+\tint mode;\n+\trtx i1, i2;\n+{\n+  rtx p1, p2;\n+\n+  /* Verify that I1 and I2 are equivalent.  */\n+  if (GET_CODE (i1) != GET_CODE (i2))\n+    return false;\n+\n+  p1 = PATTERN (i1);\n+  p2 = PATTERN (i2);\n+\n+  if (GET_CODE (p1) != GET_CODE (p2))\n+    return false;\n+\n+  /* If this is a CALL_INSN, compare register usage information.\n+     If we don't check this on stack register machines, the two\n+     CALL_INSNs might be merged leaving reg-stack.c with mismatching\n+     numbers of stack registers in the same basic block.\n+     If we don't check this on machines with delay slots, a delay slot may\n+     be filled that clobbers a parameter expected by the subroutine.\n+\n+     ??? We take the simple route for now and assume that if they're\n+     equal, they were constructed identically.  */\n+\n+  if (GET_CODE (i1) == CALL_INSN\n+      && !rtx_equal_p (CALL_INSN_FUNCTION_USAGE (i1),\n+\t\t       CALL_INSN_FUNCTION_USAGE (i2)))\n+    return false;\n+\n+#ifdef STACK_REGS\n+  /* If cross_jump_death_matters is not 0, the insn's mode\n+     indicates whether or not the insn contains any stack-like\n+     regs.  */\n+\n+  if ((mode & CLEANUP_POST_REGSTACK) && stack_regs_mentioned (i1))\n+    {\n+      /* If register stack conversion has already been done, then\n+         death notes must also be compared before it is certain that\n+         the two instruction streams match.  */\n+\n+      rtx note;\n+      HARD_REG_SET i1_regset, i2_regset;\n+\n+      CLEAR_HARD_REG_SET (i1_regset);\n+      CLEAR_HARD_REG_SET (i2_regset);\n+\n+      for (note = REG_NOTES (i1); note; note = XEXP (note, 1))\n+\tif (REG_NOTE_KIND (note) == REG_DEAD && STACK_REG_P (XEXP (note, 0)))\n+\t  SET_HARD_REG_BIT (i1_regset, REGNO (XEXP (note, 0)));\n+\n+      for (note = REG_NOTES (i2); note; note = XEXP (note, 1))\n+\tif (REG_NOTE_KIND (note) == REG_DEAD && STACK_REG_P (XEXP (note, 0)))\n+\t  SET_HARD_REG_BIT (i2_regset, REGNO (XEXP (note, 0)));\n+\n+      GO_IF_HARD_REG_EQUAL (i1_regset, i2_regset, done);\n+\n+      return false;\n+\n+    done:\n+      ;\n+    }\n+#endif\n+\n+  if (reload_completed\n+      ? ! rtx_renumbered_equal_p (p1, p2) : ! rtx_equal_p (p1, p2))\n+    {\n+      /* The following code helps take care of G++ cleanups.  */\n+      rtx equiv1 = find_reg_equal_equiv_note (i1);\n+      rtx equiv2 = find_reg_equal_equiv_note (i2);\n+\n+      if (equiv1 && equiv2\n+\t  /* If the equivalences are not to a constant, they may\n+\t     reference pseudos that no longer exist, so we can't\n+\t     use them.  */\n+\t  && (! reload_completed\n+\t      || (CONSTANT_P (XEXP (equiv1, 0))\n+\t\t  && rtx_equal_p (XEXP (equiv1, 0), XEXP (equiv2, 0)))))\n+\t{\n+\t  rtx s1 = single_set (i1);\n+\t  rtx s2 = single_set (i2);\n+\t  if (s1 != 0 && s2 != 0\n+\t      && rtx_renumbered_equal_p (SET_DEST (s1), SET_DEST (s2)))\n+\t    {\n+\t      validate_change (i1, &SET_SRC (s1), XEXP (equiv1, 0), 1);\n+\t      validate_change (i2, &SET_SRC (s2), XEXP (equiv2, 0), 1);\n+\t      if (! rtx_renumbered_equal_p (p1, p2))\n+\t\tcancel_changes (0);\n+\t      else if (apply_change_group ())\n+\t\treturn true;\n+\t    }\n+\t}\n+      return false;\n+    }\n+  return true;\n+}\n+\f\n /* Look through the insns at the end of BB1 and BB2 and find the longest\n    sequence that are equivalent.  Store the first insns for that sequence\n    in *F1 and *F2 and return the sequence length.\n@@ -559,7 +663,7 @@ flow_find_cross_jump (mode, bb1, bb2, f1, f2)\n      basic_block bb1, bb2;\n      rtx *f1, *f2;\n {\n-  rtx i1, i2, p1, p2, last1, last2, afterlast1, afterlast2;\n+  rtx i1, i2, last1, last2, afterlast1, afterlast2;\n   int ninsns = 0;\n \n   /* Skip simple jumps at the end of the blocks.  Complex jumps still\n@@ -586,100 +690,11 @@ flow_find_cross_jump (mode, bb1, bb2, f1, f2)\n       if (i1 == bb1->head || i2 == bb2->head)\n \tbreak;\n \n-      /* Verify that I1 and I2 are equivalent.  */\n-\n-      if (GET_CODE (i1) != GET_CODE (i2))\n-\tbreak;\n-\n-      p1 = PATTERN (i1);\n-      p2 = PATTERN (i2);\n-\n-      /* If this is a CALL_INSN, compare register usage information.\n-\t If we don't check this on stack register machines, the two\n-\t CALL_INSNs might be merged leaving reg-stack.c with mismatching\n-\t numbers of stack registers in the same basic block.\n-\t If we don't check this on machines with delay slots, a delay slot may\n-\t be filled that clobbers a parameter expected by the subroutine.\n-\n-\t ??? We take the simple route for now and assume that if they're\n-\t equal, they were constructed identically.  */\n-\n-      if (GET_CODE (i1) == CALL_INSN\n-\t  && ! rtx_equal_p (CALL_INSN_FUNCTION_USAGE (i1),\n-\t\t\t    CALL_INSN_FUNCTION_USAGE (i2)))\n+      if (!insns_match_p (mode, i1, i2))\n \tbreak;\n \n-#ifdef STACK_REGS\n-      /* If cross_jump_death_matters is not 0, the insn's mode\n-\t indicates whether or not the insn contains any stack-like\n-\t regs.  */\n-\n-      if ((mode & CLEANUP_POST_REGSTACK) && stack_regs_mentioned (i1))\n-\t{\n-\t  /* If register stack conversion has already been done, then\n-\t     death notes must also be compared before it is certain that\n-\t     the two instruction streams match.  */\n-\n-\t  rtx note;\n-\t  HARD_REG_SET i1_regset, i2_regset;\n-\n-\t  CLEAR_HARD_REG_SET (i1_regset);\n-\t  CLEAR_HARD_REG_SET (i2_regset);\n-\n-\t  for (note = REG_NOTES (i1); note; note = XEXP (note, 1))\n-\t    if (REG_NOTE_KIND (note) == REG_DEAD\n-\t\t&& STACK_REG_P (XEXP (note, 0)))\n-\t      SET_HARD_REG_BIT (i1_regset, REGNO (XEXP (note, 0)));\n-\n-\t  for (note = REG_NOTES (i2); note; note = XEXP (note, 1))\n-\t    if (REG_NOTE_KIND (note) == REG_DEAD\n-\t\t&& STACK_REG_P (XEXP (note, 0)))\n-\t      SET_HARD_REG_BIT (i2_regset, REGNO (XEXP (note, 0)));\n-\n-\t  GO_IF_HARD_REG_EQUAL (i1_regset, i2_regset, done);\n-\n-\t  break;\n-\n-\tdone:\n-\t  ;\n-\t}\n-#endif\n-\n-      if (GET_CODE (p1) != GET_CODE (p2))\n-\tbreak;\n-\n-      if (! rtx_renumbered_equal_p (p1, p2))\n-\t{\n-\t  /* The following code helps take care of G++ cleanups.  */\n-\t  rtx equiv1 = find_reg_equal_equiv_note (i1);\n-\t  rtx equiv2 = find_reg_equal_equiv_note (i2);\n-\n-\t  if (equiv1 && equiv2\n-\t      /* If the equivalences are not to a constant, they may\n-\t\t reference pseudos that no longer exist, so we can't\n-\t\t use them.  */\n-\t      && CONSTANT_P (XEXP (equiv1, 0))\n-\t      && rtx_equal_p (XEXP (equiv1, 0), XEXP (equiv2, 0)))\n-\t    {\n-\t      rtx s1 = single_set (i1);\n-\t      rtx s2 = single_set (i2);\n-\t      if (s1 != 0 && s2 != 0\n-\t\t  && rtx_renumbered_equal_p (SET_DEST (s1), SET_DEST (s2)))\n-\t\t{\n-\t\t  validate_change (i1, &SET_SRC (s1), XEXP (equiv1, 0), 1);\n-\t\t  validate_change (i2, &SET_SRC (s2), XEXP (equiv2, 0), 1);\n-\t\t  if (! rtx_renumbered_equal_p (p1, p2))\n-\t\t    cancel_changes (0);\n-\t\t  else if (apply_change_group ())\n-\t\t    goto win;\n-\t\t}\n-\t    }\n-\t  break;\n-\t}\n-\n-    win:\n       /* Don't begin a cross-jump with a USE or CLOBBER insn.  */\n-      if (GET_CODE (p1) != USE && GET_CODE (p1) != CLOBBER)\n+      if (active_insn_p (i1))\n \t{\n \t  /* If the merged insns have different REG_EQUAL notes, then\n \t     remove them.  */\n@@ -743,10 +758,15 @@ flow_find_cross_jump (mode, bb1, bb2, f1, f2)\n    We may assume that there exists one edge with a common destination.  */\n \n static bool\n-outgoing_edges_match (bb1, bb2)\n+outgoing_edges_match (mode, bb1, bb2)\n+     int mode;\n      basic_block bb1;\n      basic_block bb2;\n {\n+  int nehedges1 = 0, nehedges2 = 0;\n+  edge fallthru1 = 0, fallthru2 = 0;\n+  edge e1, e2;\n+\n   /* If BB1 has only one successor, we must be looking at an unconditional\n      jump.  Which, by the assumption above, means that we only need to check\n      that BB2 has one successor.  */\n@@ -862,10 +882,60 @@ outgoing_edges_match (bb1, bb2)\n       return match;\n     }\n \n-  /* ??? We can handle computed jumps too.  This may be important for\n-     inlined functions containing switch statements.  Also jumps w/o\n-     fallthru edges can be handled by simply matching whole insn.  */\n-  return false;\n+  /* Generic case - we are seeing an computed jump, table jump or trapping\n+     instruction.  */\n+\n+  /* First ensure that the instructions match.  There may be many outgoing\n+     edges so this test is generally cheaper.\n+     ??? Currently the tablejumps will never match, as they do have\n+     different tables.  */\n+  if (!insns_match_p (mode, bb1->end, bb2->end))\n+    return false;\n+\n+  /* Search the outgoing edges, ensure that the counts do match, find possible\n+     fallthru and exception handling edges since these needs more\n+     validation.  */\n+  for (e1 = bb1->succ, e2 = bb2->succ; e1 && e2;\n+       e1 = e1->succ_next, e2 = e2->succ_next)\n+    {\n+      if (e1->flags & EDGE_EH)\n+\tnehedges1++;\n+      if (e2->flags & EDGE_EH)\n+\tnehedges2++;\n+      if (e1->flags & EDGE_FALLTHRU)\n+\tfallthru1 = e1;\n+      if (e2->flags & EDGE_FALLTHRU)\n+\tfallthru2 = e2;\n+    }\n+  /* If number of edges of various types does not match, fail.  */\n+  if (e1 || e2)\n+    return false;\n+  if (nehedges1 != nehedges2)\n+    return false;\n+  if ((fallthru1 != 0) != (fallthru2 != 0))\n+    return false;\n+\n+  /* fallthru edges must be forwarded to the same destination.  */\n+  if (fallthru1)\n+    {\n+      basic_block d1 = (forwarder_block_p (fallthru1->dest)\n+\t                ? fallthru1->dest->succ->dest: fallthru1->dest);\n+      basic_block d2 = (forwarder_block_p (fallthru2->dest)\n+\t                ? fallthru2->dest->succ->dest: fallthru2->dest);\n+      if (d1 != d2)\n+\treturn false;\n+    }\n+  /* In case we do have EH edges, ensure we are in the same region.  */\n+  if (nehedges1)\n+    {\n+      rtx n1 = find_reg_note (bb1->end, REG_EH_REGION, 0);\n+      rtx n2 = find_reg_note (bb2->end, REG_EH_REGION, 0);\n+      if (XEXP (n1, 0) != XEXP (n2, 0))\n+\treturn false;\n+    }\n+  /* We don't need to match the rest of edges as above checks should be enought\n+     to ensure that they are equivalent.  */\n+  return true;\n }\n \n /* E1 and E2 are edges with the same destination block.  Search their\n@@ -924,14 +994,8 @@ try_crossjump_to_edge (mode, e1, e2)\n   if (!src1->pred || !src2->pred)\n     return false;\n \n-  /* Likewise with complex edges.\n-     ??? We should be able to handle most complex edges later with some\n-     care.  */\n-  if (e1->flags & EDGE_COMPLEX)\n-    return false;\n-\n   /* Look for the common insn sequence, part the first ...  */\n-  if (!outgoing_edges_match (src1, src2))\n+  if (!outgoing_edges_match (mode, src1, src2))\n     return false;\n \n   /* ... and part the second.  */\n@@ -1066,11 +1130,6 @@ try_crossjump_bb (mode, bb)\n     {\n       nexte = e->pred_next;\n \n-      /* Elide complex edges now, as neither try_crossjump_to_edge\n-\t nor outgoing_edges_match can handle them.  */\n-      if (e->flags & EDGE_COMPLEX)\n-\tcontinue;\n-\n       /* As noted above, first try with the fallthru predecessor.  */\n       if (fallthru)\n \t{\n@@ -1113,11 +1172,6 @@ try_crossjump_bb (mode, bb)\n \t  if (e2 == fallthru)\n \t    continue;\n \n-\t  /* Again, neither try_crossjump_to_edge nor outgoing_edges_match\n-\t     can handle complex edges.  */\n-\t  if (e2->flags & EDGE_COMPLEX)\n-\t    continue;\n-\n \t  /* The \"first successor\" check above only prevents multiple\n \t     checks of crossjump(A,B).  In order to prevent redundant\n \t     checks of crossjump(B,A), require that A be the block"}, {"sha": "b9a5f293b091aa6395cf2668531d4c91a1438cc3", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 49, "deletions": 10, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dd0e980b5c9b23a3749647c69603f8a29eea4c3/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dd0e980b5c9b23a3749647c69603f8a29eea4c3/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=0dd0e980b5c9b23a3749647c69603f8a29eea4c3", "patch": "@@ -817,18 +817,42 @@ override_options ()\n     {\n       const char *const name;\t\t/* processor name or nickname.  */\n       const enum processor_type processor;\n+      const enum pta_flags\n+\t{\n+\t  PTA_SSE = 1,\n+\t  PTA_SSE2 = 2,\n+\t  PTA_MMX = 4,\n+\t  PTA_SSEPREFETCH = 8,\n+\t  PTA_3DNOW = 16,\n+\t  PTA_3DNOW_A = 64\n+\t} flags;\n     }\n   const processor_alias_table[] =\n     {\n-      {\"i386\", PROCESSOR_I386},\n-      {\"i486\", PROCESSOR_I486},\n-      {\"i586\", PROCESSOR_PENTIUM},\n-      {\"pentium\", PROCESSOR_PENTIUM},\n-      {\"i686\", PROCESSOR_PENTIUMPRO},\n-      {\"pentiumpro\", PROCESSOR_PENTIUMPRO},\n-      {\"k6\", PROCESSOR_K6},\n-      {\"athlon\", PROCESSOR_ATHLON},\n-      {\"pentium4\", PROCESSOR_PENTIUM4},\n+      {\"i386\", PROCESSOR_I386, 0},\n+      {\"i486\", PROCESSOR_I486, 0},\n+      {\"i586\", PROCESSOR_PENTIUM, 0},\n+      {\"pentium\", PROCESSOR_PENTIUM, 0},\n+      {\"pentium-mmx\", PROCESSOR_PENTIUM, PTA_MMX},\n+      {\"i686\", PROCESSOR_PENTIUMPRO, 0},\n+      {\"pentiumpro\", PROCESSOR_PENTIUMPRO, 0},\n+      {\"pentium2\", PROCESSOR_PENTIUMPRO, PTA_MMX},\n+      {\"pentium3\", PROCESSOR_PENTIUMPRO, PTA_MMX | PTA_SSE | PTA_SSEPREFETCH},\n+      {\"pentium4\", PROCESSOR_PENTIUM4, PTA_SSE | PTA_SSE2 |\n+\t\t\t\t       PTA_MMX | PTA_SSEPREFETCH},\n+      {\"k6\", PROCESSOR_K6, PTA_MMX},\n+      {\"k6-2\", PROCESSOR_K6, PTA_MMX | PTA_3DNOW},\n+      {\"k6-3\", PROCESSOR_K6, PTA_MMX | PTA_3DNOW},\n+      {\"athlon\", PROCESSOR_ATHLON, PTA_MMX | PTA_SSEPREFETCH | PTA_3DNOW\n+\t\t\t\t   | PTA_3DNOW_A},\n+      {\"athlon-tbird\", PROCESSOR_ATHLON, PTA_MMX | PTA_SSEPREFETCH\n+\t\t\t\t\t | PTA_3DNOW | PTA_3DNOW_A},\n+      {\"athlon-4\", PROCESSOR_ATHLON, PTA_MMX | PTA_SSEPREFETCH | PTA_3DNOW\n+\t\t\t\t    | PTA_3DNOW_A | PTA_SSE},\n+      {\"athlon-xp\", PROCESSOR_ATHLON, PTA_MMX | PTA_SSEPREFETCH | PTA_3DNOW\n+\t\t\t\t      | PTA_3DNOW_A | PTA_SSE},\n+      {\"athlon-mp\", PROCESSOR_ATHLON, PTA_MMX | PTA_SSEPREFETCH | PTA_3DNOW\n+\t\t\t\t      | PTA_3DNOW_A | PTA_SSE},\n     };\n \n   int const pta_size = sizeof (processor_alias_table) / sizeof (struct pta);\n@@ -880,6 +904,21 @@ override_options ()\n \t    ix86_arch = processor_alias_table[i].processor;\n \t    /* Default cpu tuning to the architecture.  */\n \t    ix86_cpu = ix86_arch;\n+\t    if (processor_alias_table[i].flags & PTA_MMX\n+\t        && !(target_flags & MASK_MMX_SET))\n+\t      target_flags |= MASK_MMX;\n+\t    if (processor_alias_table[i].flags & PTA_3DNOW\n+\t        && !(target_flags & MASK_3DNOW_SET))\n+\t      target_flags |= MASK_3DNOW;\n+\t    if (processor_alias_table[i].flags & PTA_3DNOW_A\n+\t        && !(target_flags & MASK_3DNOW_A_SET))\n+\t      target_flags |= MASK_3DNOW_A;\n+\t    if (processor_alias_table[i].flags & PTA_SSE\n+\t        && !(target_flags & MASK_SSE_SET))\n+\t      target_flags |= MASK_SSE;\n+\t    if (processor_alias_table[i].flags & PTA_SSE2\n+\t        && !(target_flags & MASK_SSE2_SET))\n+\t      target_flags |= MASK_SSE2;\n \t    break;\n \t  }\n \n@@ -1045,7 +1084,7 @@ override_options ()\n \ttarget_flags |= MASK_3DNOW_A;\n     }\n   if ((x86_accumulate_outgoing_args & CPUMASK)\n-      && !(target_flags & MASK_NO_ACCUMULATE_OUTGOING_ARGS)\n+      && !(target_flags & MASK_ACCUMULATE_OUTGOING_ARGS_SET)\n       && !optimize_size)\n     target_flags |= MASK_ACCUMULATE_OUTGOING_ARGS;\n "}, {"sha": "678e9d1eeca16b1165d80116c9bf77ed8c75cb0a", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 52, "deletions": 30, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dd0e980b5c9b23a3749647c69603f8a29eea4c3/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dd0e980b5c9b23a3749647c69603f8a29eea4c3/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=0dd0e980b5c9b23a3749647c69603f8a29eea4c3", "patch": "@@ -112,25 +112,30 @@ extern int target_flags;\n #define MASK_NO_FANCY_MATH_387\t0x00000040\t/* Disable sin, cos, sqrt */\n #define MASK_OMIT_LEAF_FRAME_POINTER 0x080      /* omit leaf frame pointers */\n #define MASK_STACK_PROBE\t0x00000100\t/* Enable stack probing */\n-#define MASK_NO_ALIGN_STROPS\t0x00001000\t/* Enable aligning of string ops.  */\n-#define MASK_INLINE_ALL_STROPS\t0x00002000\t/* Inline stringops in all cases */\n-#define MASK_NO_PUSH_ARGS\t0x00004000\t/* Use push instructions */\n-#define MASK_ACCUMULATE_OUTGOING_ARGS 0x00008000/* Accumulate outgoing args */\n-#define MASK_NO_ACCUMULATE_OUTGOING_ARGS 0x00010000\n-#define MASK_MMX\t\t0x00020000\t/* Support MMX regs/builtins */\n-#define MASK_SSE\t\t0x00040000\t/* Support SSE regs/builtins */\n-#define MASK_SSE2\t\t0x00080000\t/* Support SSE2 regs/builtins */\n+#define MASK_NO_ALIGN_STROPS\t0x00000200\t/* Enable aligning of string ops.  */\n+#define MASK_INLINE_ALL_STROPS\t0x00000400\t/* Inline stringops in all cases */\n+#define MASK_NO_PUSH_ARGS\t0x00000800\t/* Use push instructions */\n+#define MASK_ACCUMULATE_OUTGOING_ARGS 0x00001000/* Accumulate outgoing args */\n+#define MASK_ACCUMULATE_OUTGOING_ARGS_SET 0x00002000\n+#define MASK_MMX\t\t0x00004000\t/* Support MMX regs/builtins */\n+#define MASK_MMX_SET\t\t0x00008000\n+#define MASK_SSE\t\t0x00010000\t/* Support SSE regs/builtins */\n+#define MASK_SSE_SET\t\t0x00020000\n+#define MASK_SSE2\t\t0x00040000\t/* Support SSE2 regs/builtins */\n+#define MASK_SSE2_SET\t\t0x00080000\n #define MASK_3DNOW\t\t0x00100000\t/* Support 3Dnow builtins */\n-#define MASK_3DNOW_A\t\t0x00200000\t/* Support Athlon 3Dnow builtins */\n-#define MASK_128BIT_LONG_DOUBLE 0x00400000\t/* long double size is 128bit */\n-#define MASK_MIX_SSE_I387\t0x00800000\t/* Mix SSE and i387 instructions */\n-#define MASK_64BIT\t\t0x01000000\t/* Produce 64bit code */\n-#define MASK_NO_RED_ZONE\t0x02000000\t/* Do not use red zone */\n+#define MASK_3DNOW_SET\t\t0x00200000\n+#define MASK_3DNOW_A\t\t0x00400000\t/* Support Athlon 3Dnow builtins */\n+#define MASK_3DNOW_A_SET\t0x00800000\n+#define MASK_128BIT_LONG_DOUBLE 0x01000000\t/* long double size is 128bit */\n+#define MASK_MIX_SSE_I387\t0x02000000\t/* Mix SSE and i387 instructions */\n+#define MASK_64BIT\t\t0x04000000\t/* Produce 64bit code */\n+#define MASK_NO_RED_ZONE\t0x08000000\t/* Do not use red zone */\n \n /* Temporary codegen switches */\n-#define MASK_INTEL_SYNTAX\t0x00000200\n-#define MASK_DEBUG_ARG\t\t0x00000400\t/* function_arg */   \n-#define MASK_DEBUG_ADDR\t\t0x00000800\t/* GO_IF_LEGITIMATE_ADDRESS */\n+#define MASK_INTEL_SYNTAX\t0x10000000\n+#define MASK_DEBUG_ARG\t\t0x20000000\t/* function_arg */   \n+#define MASK_DEBUG_ADDR\t\t0x40000000\t/* GO_IF_LEGITIMATE_ADDRESS */\n \n /* Use the floating point instructions */\n #define TARGET_80387 (target_flags & MASK_80387)\n@@ -335,24 +340,30 @@ extern const int x86_epilogue_using_move, x86_decompose_lea;\n     N_(\"Use push instructions to save outgoing arguments\") },\t\t      \\\n   { \"no-push-args\",\t\tMASK_NO_PUSH_ARGS,\t\t\t      \\\n     N_(\"Do not use push instructions to save outgoing arguments\") },\t      \\\n-  { \"accumulate-outgoing-args\",\tMASK_ACCUMULATE_OUTGOING_ARGS,\t\t      \\\n+  { \"accumulate-outgoing-args\",\t(MASK_ACCUMULATE_OUTGOING_ARGS\t\t      \\\n+\t\t\t\t | MASK_ACCUMULATE_OUTGOING_ARGS_SET),\t      \\\n     N_(\"Use push instructions to save outgoing arguments\") },\t\t      \\\n-  { \"no-accumulate-outgoing-args\",MASK_NO_ACCUMULATE_OUTGOING_ARGS,\t      \\\n+  { \"no-accumulate-outgoing-args\",MASK_ACCUMULATE_OUTGOING_ARGS_SET,\t      \\\n     N_(\"Do not use push instructions to save outgoing arguments\") },\t      \\\n-  { \"mmx\",\t\t\t MASK_MMX, N_(\"Support MMX builtins\") },      \\\n-  { \"no-mmx\",\t\t\t-MASK_MMX,\t\t\t\t      \\\n+  { \"mmx\",\t\t\t MASK_MMX | MASK_MMX_SET,\t\t      \\\n+    N_(\"Support MMX builtins\") },\t\t\t\t\t      \\\n+  { \"no-mmx\",\t\t\t -MASK_MMX,\t\t\t\t      \\\n     N_(\"Do not support MMX builtins\") },\t\t\t\t      \\\n-  { \"3dnow\",                     MASK_3DNOW,\t\t\t\t      \\\n+  { \"no-mmx\",\t\t\t MASK_MMX_SET, N_(\"\") },\t\t      \\\n+  { \"3dnow\",                     MASK_3DNOW | MASK_3DNOW_SET,\t\t      \\\n     N_(\"Support 3DNow! builtins\") },\t\t\t\t\t      \\\n-  { \"no-3dnow\",                 -MASK_3DNOW,\t\t\t\t      \\\n+  { \"no-3dnow\",                  -MASK_3DNOW, N_(\"\") },\t\t\t      \\\n+  { \"no-3dnow\",                  MASK_3DNOW_SET,\t\t\t      \\\n     N_(\"Do not support 3DNow! builtins\") },\t\t\t\t      \\\n-  { \"sse\",\t\t\t MASK_SSE,\t\t\t\t      \\\n+  { \"sse\",\t\t\t MASK_SSE | MASK_SSE_SET,\t\t      \\\n     N_(\"Support MMX and SSE builtins and code generation\") },\t\t      \\\n-  { \"no-sse\",\t\t\t-MASK_SSE,\t\t\t\t      \\\n+  { \"no-sse\",\t\t\t -MASK_SSE, N_(\"\") },\t \t\t      \\\n+  { \"no-sse\",\t\t\t MASK_SSE_SET,\t\t\t\t      \\\n     N_(\"Do not support MMX and SSE builtins and code generation\") },\t      \\\n-  { \"sse2\",\t\t\t MASK_SSE2,\t\t\t\t      \\\n+  { \"sse2\",\t\t\t MASK_SSE2 | MASK_SSE2_SET,\t\t      \\\n     N_(\"Support MMX, SSE and SSE2 builtins and code generation\") },\t      \\\n-  { \"no-sse2\",\t\t\t-MASK_SSE2,\t\t\t\t      \\\n+  { \"no-sse2\",\t\t\t -MASK_SSE2, N_(\"\") },\t\t\t      \\\n+  { \"no-sse2\",\t\t\t MASK_SSE2_SET,\t\t\t\t      \\\n     N_(\"Do not support MMX, SSE and SSE2 builtins and code generation\") },    \\\n   { \"mix-sse-i387\",\t\t MASK_MIX_SSE_I387,\t\t\t      \\\n     N_(\"Use both SSE and i387 instruction sets for floating point arithmetics\") },\\\n@@ -522,11 +533,22 @@ extern int ix86_arch;\n %{march=pentium4:-D__pentium4 -D__pentium4__ %{!mcpu*:-D__tune_pentium4__ }}\\\n %{m386|mcpu=i386:-D__tune_i386__ }\\\n %{m486|mcpu=i486:-D__tune_i486__ }\\\n-%{mpentium|mcpu=pentium|mcpu=i586:-D__tune_i586__ -D__tune_pentium__ }\\\n-%{mpentiumpro|mcpu=pentiumpro|mcpu=i686:-D__tune_i686__ -D__tune_pentiumpro__ }\\\n-%{mcpu=k6:-D__tune_k6__ }\\\n-%{mcpu=athlon:-D__tune_athlon__ }\\\n+%{mpentium|mcpu=pentium|mcpu=i586|mcpu=pentium-mmx:-D__tune_i586__ -D__tune_pentium__ }\\\n+%{mpentiumpro|mcpu=pentiumpro|mcpu=i686|cpu=pentium2|cpu=pentium3:-D__tune_i686__\\\n+-D__tune_pentiumpro__ }\\\n+%{mcpu=k6|mcpu=k6-2|mcpu=k6-3:-D__tune_k6__ }\\\n+%{mcpu=athlon|mcpu=athlon-tbird|mcpu=athlon-4|mcpu=athlon-xp|mcpu=athlon-mp:\\\n+-D__tune_athlon__ }\\\n %{mcpu=pentium4:-D__tune_pentium4__ }\\\n+%{march=march=athlon-tbird|march=athlon-xp|march=athlon-mp|march=pentium3|march=pentium4:\\\n+-D__SSE__ }\\\n+%{march=pentium-mmx|march=k6|march=k6-2|march=k6-3\\\n+march=athlon|march=athlon-tbird|march=athlon-4|march=athlon-xp\\\n+|march=athlon-mp|march=pentium2|march=pentium3|march=pentium4: -D__MMX__ }\\\n+%{march=k6|march=k6-2|march=k6-3\\\n+march=athlon|march=athlon-tbird|march=athlon-4|march=athlon-xp\\\n+|march=athlon-mp: -D__3dNOW__ }\\\n+%{mcpu=mcpu=pentium4: -D__SSE2__ }\\\n %{!march*:%{!mcpu*:%{!m386:%{!m486:%{!mpentium*:%(cpp_cpu_default)}}}}}\"\n \n #ifndef CPP_CPU_SPEC"}, {"sha": "91fe9bc5caba76ed33314694d5d2a62424ae55a9", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dd0e980b5c9b23a3749647c69603f8a29eea4c3/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dd0e980b5c9b23a3749647c69603f8a29eea4c3/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=0dd0e980b5c9b23a3749647c69603f8a29eea4c3", "patch": "@@ -272,7 +272,7 @@ in the following sections.\n -fno-inline  -fno-math-errno  -fno-peephole  -fno-peephole2 @gol\n -funsafe-math-optimizations -fno-trapping-math @gol\n -fomit-frame-pointer  -foptimize-register-move @gol\n--foptimize-sibling-calls  -freduce-all-givs @gol\n+-foptimize-sibling-calls  -fprefetch-loop-arrays  -freduce-all-givs @gol\n -fregmove  -frename-registers @gol\n -frerun-cse-after-loop  -frerun-loop-opt @gol\n -fschedule-insns  -fschedule-insns2 @gol\n@@ -3570,6 +3570,10 @@ the loop is entered.  This usually makes programs run more slowly.\n @option{-funroll-all-loops} implies the same options as\n @option{-funroll-loops},\n \n+@item -fprefetch-loop-arrays\n+@opindex fprefetch-loop-arrays\n+If supported by the target machine, generate instructions to prefetch\n+memory to improve the performance of loops that access large arrays.\n \n @item -fmove-all-movables\n @opindex fmove-all-movables\n@@ -7476,10 +7480,13 @@ computers:\n @table @gcctabopt\n @item -mcpu=@var{cpu-type}\n @opindex mcpu\n-Assume the defaults for the machine type @var{cpu-type} when scheduling\n-instructions.  The choices for @var{cpu-type} are @samp{i386},\n-@samp{i486}, @samp{i586}, @samp{i686}, @samp{pentium},\n-@samp{pentiumpro}, @samp{pentium4}, @samp{k6}, and @samp{athlon}\n+Tune to @var{cpu-type} everything applicable about the generated code, except\n+for the ABI and the set of available instructions.  The choices for\n+@var{cpu-type} are @samp{i386}, @samp{i486}, @samp{i586}, @samp{i686},\n+@samp{pentium}, @samp{pentium-mmx}, @samp{pentiumpro}, @samp{pentium2},\n+@samp{pentium3}, @samp{pentium4}, @samp{k6}, @samp{k6-2}, @samp{k6-3},\n+@samp{athlon}, @samp{athlon-tbird}, @samp{athlon-4}, @samp{athlon-xp}\n+and @samp{athlon-mp}.\n \n While picking a specific @var{cpu-type} will schedule things appropriately\n for that particular chip, the compiler will not generate any code that"}, {"sha": "304736f94b08e211b4b1eb662d9e54eb82db7270", "filename": "gcc/flags.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dd0e980b5c9b23a3749647c69603f8a29eea4c3/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dd0e980b5c9b23a3749647c69603f8a29eea4c3/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=0dd0e980b5c9b23a3749647c69603f8a29eea4c3", "patch": "@@ -269,6 +269,10 @@ extern int flag_unroll_all_loops;\n \n extern int flag_move_all_movables;\n \n+/* Nonzero enables prefetch optimizations for arrays in loops.  */\n+\n+extern int flag_prefetch_loop_arrays;\n+\n /* Nonzero forces all general induction variables in loops to be\n    strength reduced.  */\n "}, {"sha": "41f9f631514de495537e186313817022453377ca", "filename": "gcc/loop.c", "status": "modified", "additions": 593, "deletions": 0, "changes": 593, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dd0e980b5c9b23a3749647c69603f8a29eea4c3/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dd0e980b5c9b23a3749647c69603f8a29eea4c3/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=0dd0e980b5c9b23a3749647c69603f8a29eea4c3", "patch": "@@ -53,6 +53,90 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"except.h\"\n #include \"toplev.h\"\n #include \"predict.h\"\n+#include \"insn-flags.h\"\n+\n+/* Not really meaningful values, but at least something.  */\n+#ifndef SIMULTANEOUS_PREFETCHES\n+#define SIMULTANEOUS_PREFETCHES 3\n+#endif\n+#ifndef PREFETCH_BLOCK\n+#define PREFETCH_BLOCK 32\n+#endif\n+#ifndef HAVE_prefetch\n+#define HAVE_prefetch 0\n+#define gen_prefetch(a,b,c) (abort(), NULL_RTX)\n+#endif\n+\n+/* Give up the prefetch optimizations once we exceed a given threshhold.\n+   It is unlikely that we would be able to optimize something in a loop\n+   with so many detected prefetches.  */\n+#define MAX_PREFETCHES 100\n+/* The number of prefetch blocks that are beneficial to fetch at once before\n+   a loop with a known (and low) iteration count.  */\n+#define PREFETCH_BLOCKS_BEFORE_LOOP_MAX  6\n+/* For very tiny loops it is not worthwhile to prefetch even before the loop,\n+   since it is likely that the data are already in the cache.  */\n+#define PREFETCH_BLOCKS_BEFORE_LOOP_MIN  2\n+/* The minimal number of prefetch blocks that a loop must consume to make\n+   the emitting of prefetch instruction in the body of loop worthwhile.  */\n+#define PREFETCH_BLOCKS_IN_LOOP_MIN  6\n+\n+/* Parameterize some prefetch heuristics so they can be turned on and off\n+   easily for performance testing on new architecures.  These can be\n+   defined in target-dependent files.  */\n+\n+/* Prefetch is worthwhile only when loads/stores are dense.  */\n+#ifndef PREFETCH_ONLY_DENSE_MEM\n+#define PREFETCH_ONLY_DENSE_MEM 1\n+#endif\n+\n+/* Define what we mean by \"dense\" loads and stores; This value divided by 256\n+   is the minimum percentage of memory references that worth prefetching.  */\n+#ifndef PREFETCH_DENSE_MEM\n+#define PREFETCH_DENSE_MEM 220\n+#endif\n+\n+/* Do not prefetch for a loop whose iteration count is known to be low.  */\n+#ifndef PREFETCH_NO_LOW_LOOPCNT\n+#define PREFETCH_NO_LOW_LOOPCNT 1\n+#endif\n+\n+/* Define what we mean by a \"low\" iteration count.  */\n+#ifndef PREFETCH_LOW_LOOPCNT\n+#define PREFETCH_LOW_LOOPCNT 32\n+#endif\n+\n+/* Do not prefetch for a loop that contains a function call; such a loop is\n+   probably not an internal loop.  */\n+#ifndef PREFETCH_NO_CALL\n+#define PREFETCH_NO_CALL 1\n+#endif\n+\n+/* Do not prefetch accesses with an extreme stride.  */\n+#ifndef PREFETCH_NO_EXTREME_STRIDE\n+#define PREFETCH_NO_EXTREME_STRIDE 1\n+#endif\n+\n+/* Define what we mean by an \"extreme\" stride.  */\n+#ifndef PREFETCH_EXTREME_STRIDE\n+#define PREFETCH_EXTREME_STRIDE 4096\n+#endif\n+\n+/* Do not handle reversed order prefetches (negative stride).  */\n+#ifndef PREFETCH_NO_REVERSE_ORDER\n+#define PREFETCH_NO_REVERSE_ORDER 1\n+#endif\n+\n+/* Prefetch even if the GIV is not always executed.  */\n+#ifndef PREFETCH_NOT_ALWAYS\n+#define PREFETCH_NOT_ALWAYS 0\n+#endif\n+\n+/* If the loop requires more prefetches than the target can process in\n+   parallel then don't prefetch anything in that loop.  */\n+#ifndef PREFETCH_LIMIT_TO_SIMULTANEOUS\n+#define PREFETCH_LIMIT_TO_SIMULTANEOUS 1\n+#endif\n \n #define LOOP_REG_LIFETIME(LOOP, REGNO) \\\n ((REGNO_LAST_LUID (REGNO) - REGNO_FIRST_LUID (REGNO)))\n@@ -262,6 +346,7 @@ static rtx loop_insn_sink_or_swim PARAMS((const struct loop *, rtx));\n \n static void loop_dump_aux PARAMS ((const struct loop *, FILE *, int));\n static void loop_delete_insns PARAMS ((rtx, rtx));\n+static int remove_constant_addition PARAMS ((rtx *));\n void debug_ivs PARAMS ((const struct loop *));\n void debug_iv_class PARAMS ((const struct iv_class *));\n void debug_biv PARAMS ((const struct induction *));\n@@ -3412,6 +3497,509 @@ loop_reg_used_before_p (loop, set, insn)\n   return 0;\n }\n \f\n+\n+/* Information we collect about arrays that we might want to prefetch.  */\n+struct prefetch_info\n+{\n+  struct iv_class *class;\t/* Class this prefetch is based on.  */\n+  struct induction *giv;\t/* GIV this prefetch is based on.  */\n+  rtx base_address;\t\t/* Start prefetching from this address plus\n+\t\t\t\t   index.  */\n+  HOST_WIDE_INT index;\n+  HOST_WIDE_INT stride;\t\t/* Prefetch stride in bytes in each\n+\t\t\t\t   iteration.  */\n+  unsigned int bytes_accesed;\t/* Sum of sizes of all acceses to this\n+\t\t\t\t   prefetch area in one iteration.  */\n+  unsigned int total_bytes;\t/* Total bytes loop will access in this block.\n+\t\t\t\t   This is set only for loops with known\n+\t\t\t\t   iteration counts and is 0xffffffff\n+\t\t\t\t   otherwise.  */\n+  unsigned int write : 1;\t/* 1 for read/write prefetches.  */\n+  unsigned int prefetch_in_loop : 1;\n+  \t\t\t\t/* 1 for those chosen for prefetching.  */\n+  unsigned int prefetch_before_loop : 1;\n+  \t\t\t\t/* 1 for those chosen for prefetching.  */\n+};\n+\n+/* Data used by check_store function.  */\n+struct check_store_data\n+{\n+  rtx mem_address;\n+  int mem_write;\n+};\n+\n+static void check_store PARAMS ((rtx, rtx, void *));\n+static void emit_prefetch_instructions PARAMS ((struct loop *));\n+static int rtx_equal_for_prefetch_p PARAMS ((rtx, rtx));\n+\n+/* Set mem_write when mem_address is found.  Used as callback to\n+   note_stores.  */\n+static void\n+check_store (x, pat, data)\n+     rtx x, pat ATTRIBUTE_UNUSED;\n+     void *data;\n+{\n+  struct check_store_data *d = (struct check_store_data *)data;\n+\n+  if ((GET_CODE (x) == MEM) && rtx_equal_p (d->mem_address, XEXP (x, 0)))\n+    d->mem_write = 1;\n+}\n+\f\n+/* Like rtx_equal_p, but attempts to swap commutative operands.  This is\n+   important to get some addresses combined.  Later more sophisticated\n+   transformations can be added when necesary.\n+\n+   ??? Same trick with swapping operand is done at several other places.\n+   It can be nice to develop some common way to handle this.  */\n+\n+static int\n+rtx_equal_for_prefetch_p (x, y)\n+     rtx x, y;\n+{\n+  int i;\n+  int j;\n+  enum rtx_code code = GET_CODE (x);\n+  const char *fmt;\n+\n+  if (x == y)\n+    return 1;\n+  if (code != GET_CODE (y))\n+    return 0;\n+\n+  code = GET_CODE (x);\n+\n+  if (GET_RTX_CLASS (code) == 'c')\n+    {\n+      return ((rtx_equal_for_prefetch_p (XEXP (x, 0), XEXP (y, 0))\n+\t       && rtx_equal_for_prefetch_p (XEXP (x, 1), XEXP (y, 1)))\n+\t      || (rtx_equal_for_prefetch_p (XEXP (x, 0), XEXP (y, 1))\n+\t          && rtx_equal_for_prefetch_p (XEXP (x, 1), XEXP (y, 0))));\n+    }\n+  /* Compare the elements.  If any pair of corresponding elements fails to\n+     match, return 0 for the whole thing.  */\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      switch (fmt[i])\n+\t{\n+\tcase 'w':\n+\t  if (XWINT (x, i) != XWINT (y, i))\n+\t    return 0;\n+\t  break;\n+\n+\tcase 'i':\n+\t  if (XINT (x, i) != XINT (y, i))\n+\t    return 0;\n+\t  break;\n+\n+\tcase 'E':\n+\t  /* Two vectors must have the same length.  */\n+\t  if (XVECLEN (x, i) != XVECLEN (y, i))\n+\t    return 0;\n+\n+\t  /* And the corresponding elements must match.  */\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    if (rtx_equal_for_prefetch_p (XVECEXP (x, i, j),\n+\t\t\t\t\t  XVECEXP (y, i, j)) == 0)\n+\t      return 0;\n+\t  break;\n+\n+\tcase 'e':\n+\t  if (rtx_equal_for_prefetch_p (XEXP (x, i), XEXP (y, i)) == 0)\n+\t    return 0;\n+\t  break;\n+\n+\tcase 's':\n+\t  if (strcmp (XSTR (x, i), XSTR (y, i)))\n+\t    return 0;\n+\t  break;\n+\n+\tcase 'u':\n+\t  /* These are just backpointers, so they don't matter.  */\n+\t  break;\n+\n+\tcase '0':\n+\t  break;\n+\n+\t  /* It is believed that rtx's at this level will never\n+\t     contain anything but integers and other rtx's,\n+\t     except for within LABEL_REFs and SYMBOL_REFs.  */\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+  return 1;\n+}\n+\f\n+/* Remove constant addition value from the expression X (when present)\n+   and return it.  */\n+static HOST_WIDE_INT\n+remove_constant_addition (x)\n+   rtx *x;\n+{\n+  HOST_WIDE_INT addval = 0;\n+  rtx exp=*x;\n+\n+  if (GET_CODE (exp) == CONST)\n+    exp = XEXP (exp, 0);\n+  if (GET_CODE (exp) == CONST_INT)\n+    {\n+      addval = INTVAL (exp);\n+      *x = const0_rtx;\n+    }\n+  /* For plus expression recurse on ourself.  */\n+  else if (GET_CODE (exp) == PLUS)\n+    {\n+      addval += remove_constant_addition (&XEXP (exp, 0));\n+      addval += remove_constant_addition (&XEXP (exp, 1));\n+      /* In case our parameter was constant,  remove extra zero\n+         from the expression.  */\n+      if (XEXP (exp, 0) == const0_rtx)\n+        *x = XEXP (exp, 1);\n+      else if (XEXP (exp, 1) == const0_rtx)\n+        *x = XEXP (exp, 0);\n+    }\n+  return addval;\n+}\n+\n+/* Attempt to identify accesses to arrays that are most likely to cause cache\n+   misses, and emit prefetch instructions a few prefetch blocks forward.\n+\n+   To detect the arrays we use the GIV information that was collected by the\n+   strength reduction pass.\n+\n+   The prefetch instructions are generated after the GIV information is done\n+   and before the strength reduction process. The new GIVs are injected into\n+   the strength reduction tables, so the prefetch addresses are optimized as\n+   well.\n+\n+   GIVs are split into base address, stride, and constant addition values.\n+   GIVs with the same address, stride and close addition values are combined\n+   into a single prefetch.  Also writes to GIVs are detected, so that prefetch\n+   for write instructions can be used for the block we write to, on machines\n+   that support write prefetches.\n+\n+   Several heuristics are used to determine when to prefetch.  They are\n+   controlled by defined symbols that can be overridden for each target.\n+*/\n+static void\n+emit_prefetch_instructions (struct loop *loop)\n+{\n+  int num_prefetches = 0;\n+  int num_real_prefetches = 0;\n+  int num_real_write_prefetches = 0;\n+  int ahead;\n+  int i;\n+  struct iv_class *bl;\n+  struct induction *iv;\n+  struct prefetch_info info[MAX_PREFETCHES];\n+  struct loop_ivs *ivs = LOOP_IVS (loop);\n+\n+  if (!HAVE_prefetch)\n+    return;\n+\n+  /* Consider only loops w/o calls.  When a call is done, the loop is probably\n+     slow enough to read the memory.  */\n+  if (PREFETCH_NO_CALL && LOOP_INFO (loop)->has_call)\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream, \"Prefetch: ignoring loop - has call.\\n\");\n+      return;\n+    }\n+\n+  if (PREFETCH_NO_LOW_LOOPCNT\n+      && LOOP_INFO (loop)->n_iterations\n+      && LOOP_INFO (loop)->n_iterations <= PREFETCH_LOW_LOOPCNT)\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Prefetch: ignoring loop - not enought iterations.\\n\");\n+      return;\n+    }\n+\n+  /* Search all induction variables and pick those interesting for the prefetch\n+     machinery.  */\n+  for (bl = ivs->list; bl; bl = bl->next)\n+    {\n+      struct induction *biv = bl->biv, *biv1;\n+      int basestride = 0;\n+\n+      biv1 = biv;\n+      /* Expect all BIVs to be executed in each iteration.  This makes our\n+\t analysis more conservative.  */\n+      while (biv1)\n+\t{\n+\t  /* Discard non-constant additions that we can't handle well yet, and\n+\t     BIVs that are executed multiple times; such BIVs ought to be\n+\t     handled in the nested loop.  We accept not_every_iteration BIVs,\n+\t     since these only result in larger strides and make our\n+\t     heuristics more conservative.\n+\t     ??? What does the last sentence mean?  */\n+\n+\t  if (GET_CODE (biv->add_val) != CONST_INT)\n+\t    {\n+\t      if (loop_dump_stream)\n+\t\t{\n+\t\t  fprintf (loop_dump_stream, \"Prefetch: biv %i ignored: non-constant addition at insn %i:\",\n+\t\t\t   REGNO (biv->src_reg), INSN_UID (biv->insn));\n+\t\t  print_rtl (loop_dump_stream, biv->add_val);\n+\t\t  fprintf (loop_dump_stream, \"\\n\");\n+\t\t}\n+\t      break;\n+\t    }\n+\t  if (biv->maybe_multiple)\n+\t    {\n+\t      if (loop_dump_stream)\n+\t\t{\n+\t\t  fprintf (loop_dump_stream, \"Prefetch: biv %i ignored: maybe_multiple at insn %i:\",\n+\t\t\t   REGNO (biv->src_reg), INSN_UID (biv->insn));\n+\t\t  print_rtl (loop_dump_stream, biv->add_val);\n+\t\t  fprintf (loop_dump_stream, \"\\n\");\n+\t\t}\n+\t      break;\n+\t    }\n+\t  basestride += INTVAL (biv1->add_val);\n+\t  biv1 = biv1->next_iv;\n+\t}\n+      if (biv1 || !basestride)\n+\tcontinue;\n+      for (iv = bl->giv; iv; iv = iv->next_iv)\n+\t{\n+\t  rtx address;\n+\t  rtx temp;\n+\t  HOST_WIDE_INT index = 0;\n+\t  int add = 1;\n+\t  HOST_WIDE_INT stride;\n+\t  struct check_store_data d;\n+\t  int size = GET_MODE_SIZE (GET_MODE (iv));\n+\n+\t  /* There are several reasons why an induction variable is not\n+\t     interesting to us.  */\n+\t  if (iv->giv_type != DEST_ADDR\n+\t  /* We are interested only in constant stride memory references\n+\t     in order to be able to compute density easily.  */\n+\t      || GET_CODE (iv->mult_val) != CONST_INT\n+\t  /* Don't handle reversed order prefetches, since they are usually\n+\t     ineffective.  Later we may be able to reverse such BIVs.  */\n+\t      || (PREFETCH_NO_REVERSE_ORDER \n+\t\t  && (stride = INTVAL (iv->mult_val) * basestride) < 0)\n+\t  /* Prefetching of accesses with such a extreme stride is probably\n+\t     not worthwhile, either.  */\n+\t      || (PREFETCH_NO_EXTREME_STRIDE\n+\t\t  && stride > PREFETCH_EXTREME_STRIDE)\n+\t  /* Ignore GIVs with varying add values; we can't predict the value\n+\t     for the next iteration.  */\n+\t      || !loop_invariant_p (loop, iv->add_val)\n+\t  /* Ignore GIVs in the nested loops; they ought to have been handled\n+\t     already.  */\n+\t      || iv->maybe_multiple)\n+\t    {\n+\t      if (loop_dump_stream)\n+\t\t{\n+\t\t  fprintf (loop_dump_stream, \"Prefetch: Ignoring giv at %i\\n\",\n+\t\t\t   INSN_UID (iv->insn));\n+\t\t}\n+\t      continue;\n+\t    }\n+\n+\t  /* Determine the pointer to the basic array we are examining.  It is\n+\t     the sum of the BIV's initial value and the GIV's add_val.  */\n+\t  index = 0;\n+\n+\t  address = copy_rtx (iv->add_val);\n+\t  temp = copy_rtx (bl->initial_value);\n+\n+\t  address = simplify_gen_binary (PLUS, Pmode, temp, address);\n+\t  index = remove_constant_addition (&address);\n+\n+\t  index += size;\n+\t  d.mem_write = 0;\n+\t  d.mem_address = *iv->location;\n+\t  /* When the GIV is not always executed, we might be better off by\n+\t     not dirtying the cache pages.  */\n+\t  if (PREFETCH_NOT_ALWAYS || iv->always_executed)\n+\t    note_stores (PATTERN (iv->insn), check_store, &d);\n+\n+\t  /* Attempt to find another prefetch to the same array and see if we\n+\t     can merge this one.  */\n+\t  for (i = 0; i < num_prefetches; i++)\n+\t    if (rtx_equal_for_prefetch_p (address, info[i].base_address)\n+\t\t&& stride == info[i].stride)\n+\t      {\n+\t\t/* In case both access same array (same location\n+\t\t   just with small difference in constant indexes), merge\n+\t\t   the prefetches.  Just do the later and the earlier will\n+\t\t   get prefetched from previous iteration.\n+\t\t   4096 is artificial threshold.  It should not be too small,\n+\t\t   but also not bigger than small portion of memory usually\n+\t\t   traversed by single loop.  */\n+\n+\t\tif (index >= info[i].index && index - info[i].index < 4096)\n+\t\t  {\n+\t\t    info[i].write |= d.mem_write;\n+\t\t    info[i].bytes_accesed += size;\n+\t\t    info[i].index = index;\n+\t\t    info[i].giv = iv;\n+\t\t    info[i].class = bl;\n+\t\t    info[num_prefetches].base_address = address;\n+\t\t    add = 0;\n+\t\t    break;\n+\t\t  }\n+\t\tif (index < info[i].index && info[i].index - index < 4096)\n+\t\t  {\n+\t\t    info[i].write |= d.mem_write;\n+\t\t    info[i].bytes_accesed += size;\n+\t\t    add = 0;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t  /* Merging failed.  */\n+\t  if (add)\n+\t    {\n+\t      info[num_prefetches].giv = iv;\n+\t      info[num_prefetches].class = bl;\n+\t      info[num_prefetches].index = index;\n+\t      info[num_prefetches].stride = stride;\n+\t      info[num_prefetches].base_address = address;\n+\t      info[num_prefetches].write = d.mem_write;\n+\t      info[num_prefetches].bytes_accesed = size;\n+\t      num_prefetches++;\n+\t      if (num_prefetches >= MAX_PREFETCHES)\n+\t\t{\n+\t\t  if (loop_dump_stream)\n+\t\t    fprintf(loop_dump_stream,\"Maximal number of prefetches exceeded.\\n\");\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  for (i = 0; i < num_prefetches; i++)\n+    {\n+      /* Attempt to calculate the number of bytes fetched by the loop.\n+\t Avoid overflow.  */\n+      if (LOOP_INFO (loop)->n_iterations\n+          && (0xffffffff / info[i].stride) >= LOOP_INFO (loop)->n_iterations)\n+\tinfo[i].total_bytes = info[i].stride * LOOP_INFO (loop)->n_iterations;\n+      else\n+\tinfo[i].total_bytes = 0xffffffff;\n+\n+\n+      /* Prefetch is worthwhile only when the loads/stores are dense.  */\n+      if (PREFETCH_ONLY_DENSE_MEM\n+\t  && (info[i].bytes_accesed * 256 / info[i].stride > PREFETCH_DENSE_MEM)\n+\t  && (info[i].total_bytes / PREFETCH_BLOCK >=\n+\t      PREFETCH_BLOCKS_BEFORE_LOOP_MIN))\n+\t{\n+\t  info[i].prefetch_before_loop = 1;\n+\t  if (info[i].total_bytes / PREFETCH_BLOCK <=\n+\t      PREFETCH_BLOCKS_BEFORE_LOOP_MAX)\n+\t    info[i].prefetch_in_loop = 0;\n+\t  else\n+\t    info[i].prefetch_in_loop = 1;\n+\t}\n+      else\n+        info[i].prefetch_in_loop = 0, info[i].prefetch_before_loop = 0;\n+\n+      if (info[i].prefetch_in_loop)\n+\t{\n+\t  num_real_prefetches += ((info[i].stride + PREFETCH_BLOCK - 1)\n+\t\t\t\t  / PREFETCH_BLOCK);\n+\t  if (info[i].write)\n+\t    num_real_write_prefetches +=\n+\t\t((info[i].stride + PREFETCH_BLOCK - 1) / PREFETCH_BLOCK);\n+\t}\n+    }\n+  if (loop_dump_stream)\n+    {\n+      for (i = 0; i < num_prefetches; i++)\n+\t{\n+\t  fprintf (loop_dump_stream, \"Prefetch insn %i address: \",\n+\t\t   INSN_UID (info[i].giv->insn));\n+\t  print_rtl (loop_dump_stream, info[i].base_address);\n+\t  fprintf (loop_dump_stream, \" Index:%i stride:%i density:%i%% total_bytes: %u %s in loop:%s before:%s\\n\",\n+\t\t   info[i].index, info[i].stride,\n+\t\t   info[i].bytes_accesed * 100 / info[i].stride,\n+\t\t   info[i].total_bytes,\n+\t\t   info[i].write ? \"read/write\" : \"read only\",\n+\t\t   info[i].prefetch_in_loop ? \"yes\" : \"no\",\n+\t\t   info[i].prefetch_before_loop ? \"yes\" : \"no\");\n+\t}\n+      fprintf (loop_dump_stream, \"Real prefetches needed:%i (write:%i)\\n\",\n+\t       num_real_prefetches, num_real_write_prefetches);\n+    }\n+\n+  if (!num_real_prefetches)\n+    return;\n+\n+  ahead = (SIMULTANEOUS_PREFETCHES / (num_real_prefetches));\n+\n+  if (!ahead)\n+    return;\n+  for (i = 0; i < num_prefetches; i++)\n+    {\n+      if (info[i].prefetch_in_loop)\n+\t{\n+\t  int y;\n+\t  for (y = 0; y < ((info[i].stride + PREFETCH_BLOCK - 1)\n+\t\t\t   / PREFETCH_BLOCK); y++)\n+\t    {\n+\t      rtx loc = copy_rtx (*info[i].giv->location);\n+\t      rtx insn;\n+\t      int bytes_ahead = PREFETCH_BLOCK * (ahead + y);\n+\t      rtx before_insn = info[i].giv->insn;\n+\t      rtx prev_insn = PREV_INSN (info[i].giv->insn);\n+\n+\t      /* We can save some effort by offsetting the address on\n+\t\t architectures with offsettable memory references.  */\n+\t      if (offsettable_address_p (0, VOIDmode, loc))\n+\t\tloc = plus_constant (loc, bytes_ahead);\n+\t      else\n+\t\t{\n+\t\t  rtx reg = gen_reg_rtx (Pmode);\n+\t\t  loop_iv_add_mult_emit_before (loop, loc, const1_rtx,\n+\t\t      \t\t\t\tGEN_INT (bytes_ahead), reg,\n+\t\t\t\t  \t\t0, before_insn);\n+\t\t  loc = reg;\n+\t\t}\n+\n+\t      emit_insn_before (gen_prefetch (loc, GEN_INT (info[i].write),\n+\t\t                              GEN_INT (3)), before_insn);\n+\n+\t      /* Check all insns emitted and record the new GIV information.  */\n+\t      insn = NEXT_INSN (prev_insn);\n+\t      while (insn != before_insn)\n+\t\t{\n+\t\t  insn = check_insn_for_givs (loop, insn,\n+\t\t\t\t\t      info[i].giv->always_executed,\n+\t\t\t\t\t      info[i].giv->maybe_multiple);\n+\t\t  insn = NEXT_INSN (insn);\n+\t\t}\n+\t    }\n+\t}\n+      if (info[i].prefetch_before_loop)\n+\t{\n+\t  int y;\n+\t  /* Emit INSNs before the loop to fetch the first cache lines.  */\n+\t  for (y = 0; ((!info[i].prefetch_in_loop || y < ahead)\n+\t\t       && y * PREFETCH_BLOCK < (int)info[i].total_bytes); y ++)\n+\t    {\n+\t      rtx reg = gen_reg_rtx (Pmode);\n+\t      rtx loop_start = loop->start;\n+\t      rtx add_val = simplify_gen_binary (PLUS, Pmode,\n+\t\t\t\t\t\t info[i].giv->add_val,\n+\t\t\t\t\t\t GEN_INT (y * PREFETCH_BLOCK));\n+\t      loop_iv_add_mult_emit_before (loop, info[i].class->initial_value,\n+\t\t\t\t\t    info[i].giv->mult_val,\n+\t\t\t\t            add_val, reg, 0, loop_start);\n+\t      emit_insn_before (gen_prefetch (reg, GEN_INT (info[i].write),\n+\t\t\t\t\t      GEN_INT (3)), loop_start);\n+\t    }\n+\t}\n+    }\n+  return;\n+}\n+\f\n /* A \"basic induction variable\" or biv is a pseudo reg that is set\n    (within this loop) only by incrementing or decrementing it.  */\n /* A \"general induction variable\" or giv is a pseudo reg whose\n@@ -4298,6 +4886,11 @@ strength_reduce (loop, flags)\n      fail if the iteration variable is a giv.  */\n   loop_iterations (loop);\n \n+#ifdef HAVE_prefetch\n+  if (flags & LOOP_PREFETCH)\n+    emit_prefetch_instructions (loop);\n+#endif\n+\n   /* Now for each giv for which we still don't know whether or not it is\n      replaceable, check to see if it is replaceable because its final value\n      can be calculated.  This must be done after loop_iterations is called,"}, {"sha": "f376fc0fcd5db40c8de087afda18826967d0d7cf", "filename": "gcc/loop.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dd0e980b5c9b23a3749647c69603f8a29eea4c3/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dd0e980b5c9b23a3749647c69603f8a29eea4c3/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=0dd0e980b5c9b23a3749647c69603f8a29eea4c3", "patch": "@@ -27,6 +27,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* Flags passed to loop_optimize.  */\n #define LOOP_UNROLL 1\n #define LOOP_BCT 2\n+#define LOOP_PREFETCH 4\n \n /* Get the loop info pointer of a loop.  */\n #define LOOP_INFO(LOOP) ((struct loop_info *) (LOOP)->aux)"}, {"sha": "92b956b6cc81489ebd6654cd57a26275b3083383", "filename": "gcc/predict.c", "status": "modified", "additions": 86, "deletions": 69, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dd0e980b5c9b23a3749647c69603f8a29eea4c3/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dd0e980b5c9b23a3749647c69603f8a29eea4c3/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=0dd0e980b5c9b23a3749647c69603f8a29eea4c3", "patch": "@@ -329,21 +329,26 @@ estimate_probability (loops_info)\n   for (i = 0; i < loops_info->num; i++)\n     {\n       int j;\n+      int exits;\n+      struct loop *loop = &loops_info->array[i];\n \n-      for (j = loops_info->array[i].first->index;\n-\t   j <= loops_info->array[i].last->index;\n+      flow_loop_scan (loops_info, loop, LOOP_EXIT_EDGES);\n+      exits = loop->num_exits;\n+\n+      for (j = loop->first->index;\n+\t   j <= loop->last->index;\n \t   ++j)\n \t{\n-\t  if (TEST_BIT (loops_info->array[i].nodes, j))\n+\t  if (TEST_BIT (loop->nodes, j))\n \t    {\n \t      int header_found = 0;\n \t      edge e;\n \n \t      /* Loop branch heuristics - predict as taken an edge back to\n \t         a loop's head.  */\n \t      for (e = BASIC_BLOCK(j)->succ; e; e = e->succ_next)\n-\t\tif (e->dest == loops_info->array[i].header\n-\t\t    && e->src == loops_info->array[i].latch)\n+\t\tif (e->dest == loop->header\n+\t\t    && e->src == loop->latch)\n \t\t  {\n \t\t    header_found = 1;\n \t\t    predict_edge_def (e, PRED_LOOP_BRANCH, TAKEN);\n@@ -354,8 +359,11 @@ estimate_probability (loops_info)\n \t      if (!header_found)\n \t\tfor (e = BASIC_BLOCK(j)->succ; e; e = e->succ_next)\n \t\t  if (e->dest->index <= 0\n-\t\t      || !TEST_BIT (loops_info->array[i].nodes, e->dest->index))\n-\t\t    predict_edge_def (e, PRED_LOOP_EXIT, NOT_TAKEN);\n+\t\t      || !TEST_BIT (loop->nodes, e->dest->index))\n+\t\t    predict_edge (e, PRED_LOOP_EXIT,\n+\t\t\t\t  (REG_BR_PROB_BASE\n+\t\t\t\t   - predictor_info [(int)PRED_LOOP_EXIT].hitrate)\n+\t\t\t\t  / exits);\n \t    }\n \t}\n     }\n@@ -435,74 +443,83 @@ estimate_probability (loops_info)\n       /* Try \"pointer heuristic.\"\n \t A comparison ptr == 0 is predicted as false.\n \t Similarly, a comparison ptr1 == ptr2 is predicted as false.  */\n-      switch (GET_CODE (cond))\n-\t{\n-\tcase EQ:\n-\t  if (GET_CODE (XEXP (cond, 0)) == REG\n-\t      && REG_POINTER (XEXP (cond, 0))\n-\t      && (XEXP (cond, 1) == const0_rtx\n-\t\t  || (GET_CODE (XEXP (cond, 1)) == REG\n-\t\t      && REG_POINTER (XEXP (cond, 1)))))\n-\n+      if (GET_RTX_CLASS (GET_CODE (cond)) == '<'\n+\t  && ((REG_P (XEXP (cond, 0)) && REG_POINTER (XEXP (cond, 0)))\n+\t      || (REG_P (XEXP (cond, 1)) && REG_POINTER (XEXP (cond, 1)))))\n+\tswitch (GET_CODE (cond))\n+\t  {\n+\t  case EQ:\n \t    predict_insn_def (last_insn, PRED_POINTER, NOT_TAKEN);\n-\t  break;\n-\tcase NE:\n-\t  if (GET_CODE (XEXP (cond, 0)) == REG\n-\t      && REG_POINTER (XEXP (cond, 0))\n-\t      && (XEXP (cond, 1) == const0_rtx\n-\t\t  || (GET_CODE (XEXP (cond, 1)) == REG\n-\t\t      && REG_POINTER (XEXP (cond, 1)))))\n+\t    break;\n+\t  case NE:\n \t    predict_insn_def (last_insn, PRED_POINTER, TAKEN);\n-\t  break;\n-\n-\tdefault:\n-\t  break;\n-\t}\n-\n+\t    break;\n+\t  default:\n+\t    break;\n+\t  }\n+      else\n       /* Try \"opcode heuristic.\"\n \t EQ tests are usually false and NE tests are usually true. Also,\n \t most quantities are positive, so we can make the appropriate guesses\n \t about signed comparisons against zero.  */\n-      switch (GET_CODE (cond))\n-\t{\n-\tcase CONST_INT:\n-\t  /* Unconditional branch.  */\n-\t  predict_insn_def (last_insn, PRED_UNCONDITIONAL,\n-\t\t\t    cond == const0_rtx ? NOT_TAKEN : TAKEN);\n-\t  break;\n-\n-\tcase EQ:\n-\tcase UNEQ:\n-\t  predict_insn_def (last_insn, PRED_OPCODE, NOT_TAKEN);\n-\t  break;\n-\tcase NE:\n-\tcase LTGT:\n-\t  predict_insn_def (last_insn, PRED_OPCODE, TAKEN);\n-\t  break;\n-\tcase ORDERED:\n-\t  predict_insn_def (last_insn, PRED_OPCODE, TAKEN);\n-\t  break;\n-\tcase UNORDERED:\n-\t  predict_insn_def (last_insn, PRED_OPCODE, NOT_TAKEN);\n-\t  break;\n-\tcase LE:\n-\tcase LT:\n-\t  if (XEXP (cond, 1) == const0_rtx\n-\t      || (GET_CODE (XEXP (cond, 1)) == CONST_INT\n-\t\t  && INTVAL (XEXP (cond, 1)) == -1))\n-\t    predict_insn_def (last_insn, PRED_OPCODE, NOT_TAKEN);\n-\t  break;\n-\tcase GE:\n-\tcase GT:\n-\t  if (XEXP (cond, 1) == const0_rtx\n-\t      || (GET_CODE (XEXP (cond, 1)) == CONST_INT\n-\t\t  && INTVAL (XEXP (cond, 1)) == -1))\n-\t    predict_insn_def (last_insn, PRED_OPCODE, TAKEN);\n-\t  break;\n-\n-\tdefault:\n-\t  break;\n-\t}\n+\tswitch (GET_CODE (cond))\n+\t  {\n+\t  case CONST_INT:\n+\t    /* Unconditional branch.  */\n+\t    predict_insn_def (last_insn, PRED_UNCONDITIONAL,\n+\t\t\t      cond == const0_rtx ? NOT_TAKEN : TAKEN);\n+\t    break;\n+\n+\t  case EQ:\n+\t  case UNEQ:\n+\t    /* Floating point comparisons appears to behave in a very\n+\t       inpredictable way because of special role of = tests in\n+\t       FP code.  */\n+\t    if (FLOAT_MODE_P (GET_MODE (XEXP (cond, 0))))\n+\t      ;\n+\t    /* Comparisons with 0 are often used for booleans and there is\n+\t       nothing usefull to predict about them.  */\n+\t    else if (XEXP (cond, 1) == const0_rtx || XEXP (cond, 0) == const0_rtx)\n+\t      ;\n+\t    else\n+\t      predict_insn_def (last_insn, PRED_OPCODE_NONEQUAL, NOT_TAKEN);\n+\t    break;\n+\t  case NE:\n+\t  case LTGT:\n+\t    /* Floating point comparisons appears to behave in a very\n+\t       inpredictable way because of special role of = tests in\n+\t       FP code.  */\n+\t    if (FLOAT_MODE_P (GET_MODE (XEXP (cond, 0))))\n+\t      ;\n+\t    /* Comparisons with 0 are often used for booleans and there is\n+\t       nothing usefull to predict about them.  */\n+\t    else if (XEXP (cond, 1) == const0_rtx || XEXP (cond, 0) == const0_rtx)\n+\t      ;\n+\t    else\n+\t      predict_insn_def (last_insn, PRED_OPCODE_NONEQUAL, TAKEN);\n+\t    break;\n+\t  case ORDERED:\n+\t    predict_insn_def (last_insn, PRED_FPOPCODE, TAKEN);\n+\t    break;\n+\t  case UNORDERED:\n+\t    predict_insn_def (last_insn, PRED_FPOPCODE, NOT_TAKEN);\n+\t    break;\n+\t  case LE:\n+\t  case LT:\n+\t    if (XEXP (cond, 1) == const0_rtx || XEXP (cond, 1) == const1_rtx\n+\t\t|| XEXP (cond, 1) == constm1_rtx)\n+\t      predict_insn_def (last_insn, PRED_OPCODE_POSITIVE, NOT_TAKEN);\n+\t    break;\n+\t  case GE:\n+\t  case GT:\n+\t    if (XEXP (cond, 1) == const0_rtx || XEXP (cond, 1) == const1_rtx\n+\t\t|| XEXP (cond, 1) == constm1_rtx)\n+\t      predict_insn_def (last_insn, PRED_OPCODE_POSITIVE, TAKEN);\n+\t    break;\n+\n+\t  default:\n+\t    break;\n+\t  }\n     }\n \n   /* Attach the combined probability to each conditional jump.  */"}, {"sha": "cc6831d82f19436addf0c1046db91261da011ff7", "filename": "gcc/predict.def", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dd0e980b5c9b23a3749647c69603f8a29eea4c3/gcc%2Fpredict.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dd0e980b5c9b23a3749647c69603f8a29eea4c3/gcc%2Fpredict.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.def?ref=0dd0e980b5c9b23a3749647c69603f8a29eea4c3", "patch": "@@ -89,7 +89,9 @@ DEF_PREDICTOR (PRED_LOOP_HEADER, \"loop header\", HITRATE (64), 0)\n DEF_PREDICTOR (PRED_POINTER, \"pointer\", HITRATE (83), 0)\n \n /* NE is probable, EQ not etc...  */\n-DEF_PREDICTOR (PRED_OPCODE, \"opcode\", HITRATE (55), 0)\n+DEF_PREDICTOR (PRED_OPCODE_POSITIVE, \"opcode values positive\", HITRATE (78), 0)\n+DEF_PREDICTOR (PRED_OPCODE_NONEQUAL, \"opcode values nonequal\", HITRATE (70), 0)\n+DEF_PREDICTOR (PRED_FPOPCODE, \"fp_opcode\", HITRATE (90), 0)\n \n /* Branch guarding call is probably taken.  */\n DEF_PREDICTOR (PRED_CALL, \"call\", HITRATE (70), 0)"}, {"sha": "eeac7723307a5c6b570e2c969c8c27c5483e436b", "filename": "gcc/toplev.c", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dd0e980b5c9b23a3749647c69603f8a29eea4c3/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dd0e980b5c9b23a3749647c69603f8a29eea4c3/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=0dd0e980b5c9b23a3749647c69603f8a29eea4c3", "patch": "@@ -46,6 +46,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"flags.h\"\n #include \"insn-attr.h\"\n #include \"insn-config.h\"\n+#include \"insn-flags.h\"\n #include \"hard-reg-set.h\"\n #include \"recog.h\"\n #include \"output.h\"\n@@ -544,6 +545,10 @@ int flag_unroll_loops;\n \n int flag_unroll_all_loops;\n \n+/* Nonzero enables prefetch optimizations for arrays in loops.  */\n+\n+int flag_prefetch_loop_arrays;\n+\n /* Nonzero forces all invariant computations in loops to be moved\n    outside the loop.  */\n \n@@ -1001,6 +1006,8 @@ lang_independent_options f_options[] =\n    N_(\"Perform loop unrolling when iteration count is known\") },\n   {\"unroll-all-loops\", &flag_unroll_all_loops, 1,\n    N_(\"Perform loop unrolling for all loops\") },\n+  {\"prefetch-loop-arrays\", &flag_prefetch_loop_arrays, 1,\n+   N_(\"Generate prefetch instructions, if available, for arrays in loops\") },\n   {\"move-all-movables\", &flag_move_all_movables, 1,\n    N_(\"Force all loop invariant computations out of loops\") },\n   {\"reduce-all-givs\", &flag_reduce_all_givs, 1,\n@@ -2863,7 +2870,8 @@ rest_of_compilation (decl)\n \t}\n       cleanup_barriers ();\n       loop_optimize (insns, rtl_dump_file,\n-\t\t     (flag_unroll_loops ? LOOP_UNROLL : 0) | LOOP_BCT);\n+\t\t     (flag_unroll_loops ? LOOP_UNROLL : 0) | LOOP_BCT\n+\t\t     | (flag_prefetch_loop_arrays ? LOOP_PREFETCH : 0));\n \n       close_dump_file (DFI_loop, print_rtl, insns);\n       timevar_pop (TV_LOOP);\n@@ -4928,6 +4936,20 @@ process_options ()\n       flag_function_sections = 0;\n     }\n \n+#ifndef HAVE_prefetch\n+  if (flag_prefetch_loop_arrays)\n+    {\n+      warning (\"-fprefetch-loop-arrays not supported for this target\");\n+      flag_prefetch_loop_arrays = 0;\n+    }\n+#else\n+  if (flag_prefetch_loop_arrays && !HAVE_prefetch)\n+    {\n+      warning (\"-fprefetch-loop-arrays not supported for this target (try -march switches)\");\n+      flag_prefetch_loop_arrays = 0;\n+    }\n+#endif\n+\n #ifndef OBJECT_FORMAT_ELF\n   if (flag_function_sections && write_symbols != NO_DEBUG)\n     warning (\"-ffunction-sections may affect debugging on some targets\");"}]}