{"sha": "612e6609875599726838087b64e1ec6d6c8ee4e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjEyZTY2MDk4NzU1OTk3MjY4MzgwODdiNjRlMWVjNmQ2YzhlZTRlOQ==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "2004-02-29T19:09:28Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "2004-02-29T19:09:28Z"}, "message": "FileChannelImpl.java: New class, renamed from java/nio/channels.\n\n\t* gnu/java/nio/channels/FileChannelImpl.java:  New class, renamed\n\tfrom java/nio/channels.  Don't depend on FileDescriptor.\n\t(in, out, err):  New static fields.\n\t(mode):  New field.\n\t(SET, CUR, READ, WRITE, APPEND, EXCL, SYNC, DSYNC):  Moved constants\n\tfrom FileDescriptor.\n\t(by):  Removed MappedByteBuffer field.\n\t(map):  New working implementation.\n\t* gnu/java/nio/channels/natFileChannelPosix.cc:  New file, though\n\tsome code \"ported\" from natFileDescriptoPosix.cc.\n\t* gnu/java/nio/channels/natFileChannelEcos.cc:  Likewise.\n\t* gnu/java/nio/channels/natFileChannelWin32.cc  Likewise.\n\nFrom-SVN: r78659", "tree": {"sha": "b807dd37aa1642e417973a55531593d81aa3ef7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b807dd37aa1642e417973a55531593d81aa3ef7f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/612e6609875599726838087b64e1ec6d6c8ee4e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/612e6609875599726838087b64e1ec6d6c8ee4e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/612e6609875599726838087b64e1ec6d6c8ee4e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/612e6609875599726838087b64e1ec6d6c8ee4e9/comments", "author": null, "committer": null, "parents": [{"sha": "2f537af9e7c0463134c31431c60de13ca5729183", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f537af9e7c0463134c31431c60de13ca5729183", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f537af9e7c0463134c31431c60de13ca5729183"}], "stats": {"total": 1533, "additions": 1533, "deletions": 0}, "files": [{"sha": "b5e5ffe6b67560243ac48fae2f0082a7db563da4", "filename": "libjava/gnu/java/nio/channels/FileChannelImpl.java", "status": "added", "additions": 420, "deletions": 0, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/612e6609875599726838087b64e1ec6d6c8ee4e9/libjava%2Fgnu%2Fjava%2Fnio%2Fchannels%2FFileChannelImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/612e6609875599726838087b64e1ec6d6c8ee4e9/libjava%2Fgnu%2Fjava%2Fnio%2Fchannels%2FFileChannelImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2Fchannels%2FFileChannelImpl.java?ref=612e6609875599726838087b64e1ec6d6c8ee4e9", "patch": "@@ -0,0 +1,420 @@\n+/* FileChannelImpl.java -- \n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.nio.channels;\n+\n+import gnu.classpath.Configuration;\n+import gnu.gcj.RawData;\n+import gnu.java.nio.FileLockImpl;\n+import java.io.*;\n+import java.nio.ByteBuffer;\n+import java.nio.MappedByteBuffer;\n+import java.nio.channels.*;\n+\n+/**\n+ * This file is not user visible !\n+ * But alas, Java does not have a concept of friendly packages\n+ * so this class is public. \n+ * Instances of this class are created by invoking getChannel\n+ * Upon a Input/Output/RandomAccessFile object.\n+ */\n+\n+public class FileChannelImpl extends FileChannel\n+{\n+  int mode;\n+  // These are WHENCE values for seek.\n+  static final int SET = 0;\n+  static final int CUR = 1;\n+\n+  // These are mode values for open().\n+  static final int READ   = 1;\n+  static final int WRITE  = 2;\n+  static final int APPEND = 4;\n+\n+  // EXCL is used only when making a temp file.\n+  static final int EXCL   = 8;\n+  static final int SYNC   = 16;\n+  static final int DSYNC  = 32;\n+\n+  /**\n+   * This is the actual native file descriptor value\n+   */\n+  // System's notion of file descriptor.  It might seem redundant to\n+  // initialize this given that it is reassigned in the constructors.\n+  // However, this is necessary because if open() throws an exception\n+  // we want to make sure this has the value -1.  This is the most\n+  // efficient way to accomplish that.\n+  private int fd = -1;\n+\n+  int length;\n+  private long pos;\n+\n+  public FileChannelImpl ()\n+  {\n+  }\n+\n+  /* Open a file.  MODE is a combination of the above mode flags. */\n+  public FileChannelImpl (String path, int mode) throws FileNotFoundException\n+  {\n+    fd = open (path, mode);\n+    this.mode = mode;\n+  }\n+\n+  private static native void init();\n+  static { init (); }\n+\n+  public static FileChannelImpl in;\n+  public static FileChannelImpl out;\n+  public static FileChannelImpl err;\n+\n+  private native int open (String path, int mode) throws FileNotFoundException;\n+\n+  /** Attach to an already-opened file.  */\n+  public FileChannelImpl (int desc, int mode)\n+  {\n+    fd = desc;\n+    this.mode = mode;\n+  }\n+\n+  native int available () throws IOException;\n+  private native long implPosition ();\n+  private native void seek (long newPosition);\n+  private native void implTruncate (long size);\n+  \n+  public native void unlock (long pos, long len);\n+\n+  public native long size () throws IOException;\n+    \n+  protected native void implCloseChannel() throws IOException;\n+\n+  public int read (ByteBuffer dst) throws IOException\n+  {\n+    return implRead (dst);\n+  }\n+\n+  public int read (ByteBuffer dst, long position)\n+    throws IOException\n+  {\n+    if (position < 0)\n+      throw new IllegalArgumentException ();\n+    long oldPosition = implPosition ();\n+    position (position);\n+    int result = implRead (dst);\n+    position (oldPosition);\n+    \n+    return result;\n+  }\n+\n+  private int implRead (ByteBuffer dst) throws IOException\n+  {\n+    int result;\n+    byte[] buffer = new byte [dst.remaining ()];\n+    \n+    result = read (buffer, 0, buffer.length);\n+\n+    if (result > 0)\n+      dst.put (buffer, 0, result);\n+\n+    return result;\n+  }\n+  \n+  public native int read ()\n+    throws IOException;\n+\n+  public native int read (byte[] buffer, int offset, int length)\n+    throws IOException;\n+\n+  public long read (ByteBuffer[] dsts, int offset, int length)\n+    throws IOException\n+  {\n+    long result = 0;\n+\n+    for (int i = offset; i < offset + length; i++)\n+      {\n+        result += read (dsts [i]);\n+      }\n+\n+    return result;\n+  }\n+\n+  public int write (ByteBuffer src) throws IOException\n+  {\n+    return implWrite (src);\n+  }\n+    \n+  public int write (ByteBuffer src, long position)\n+    throws IOException\n+  {\n+    if (position < 0)\n+      throw new IllegalArgumentException ();\n+\n+    if (!isOpen ())\n+      throw new ClosedChannelException ();\n+    \n+    if ((mode & WRITE) == 0)\n+       throw new NonWritableChannelException ();\n+\n+    int result;\n+    long oldPosition;\n+\n+    oldPosition = implPosition ();\n+    seek (position);\n+    result = implWrite (src);\n+    seek (oldPosition);\n+    \n+    return result;\n+  }\n+\n+  private int implWrite (ByteBuffer src) throws IOException\n+  {\n+    int len = src.remaining ();\n+    if (src.hasArray())\n+      {\n+\tbyte[] buffer = src.array();\n+\twrite(buffer, src.arrayOffset() + src.position(), len);\n+      }\n+    else\n+      {\n+\t// Use a more efficient native method! FIXME!\n+\tbyte[] buffer = new byte [len];\n+    \tsrc.get (buffer, 0, len);\n+\twrite (buffer, 0, len);\n+      }\n+    return len;\n+  }\n+  \n+  public native void write (byte[] buffer, int offset, int length)\n+    throws IOException;\n+  \n+  public native void write (int b) throws IOException;\n+\n+  public long write(ByteBuffer[] srcs, int offset, int length)\n+    throws IOException\n+  {\n+    long result = 0;\n+\n+    for (int i = offset;i < offset + length;i++)\n+      {\n+        result += write (srcs[i]);\n+      }\n+    \n+    return result;\n+  }\n+\t\t\t\t   \n+  public native MappedByteBuffer mapImpl (char mode, long position, int size)\n+    throws IOException;\n+\n+  public MappedByteBuffer map (FileChannel.MapMode mode,\n+\t\t\t       long position, long size)\n+    throws IOException\n+  {\n+    char nmode = 0;\n+    if (mode == MapMode.READ_ONLY)\n+      {\n+\tnmode = 'r';\n+\tif ((this.mode & READ) == 0)\n+\t  throw new NonReadableChannelException();\n+      }\n+    else if (mode == MapMode.READ_WRITE || mode == MapMode.PRIVATE)\n+      {\n+\tnmode = mode == MapMode.READ_WRITE ? '+' : 'c';\n+\tif ((this.mode & (READ|WRITE)) != (READ|WRITE))\n+\t  throw new NonWritableChannelException();\n+      }\n+    else\n+      throw new IllegalArgumentException ();\n+    \n+    if (position < 0 || size < 0 || size > Integer.MAX_VALUE)\n+      throw new IllegalArgumentException ();\n+    return mapImpl(nmode, position, (int) size);\n+  }\n+\n+  /**\n+   * msync with the disk\n+   */\n+  public void force (boolean metaData) throws IOException\n+  {\n+    if (!isOpen ())\n+      throw new ClosedChannelException ();\n+  }\n+\n+  public long transferTo (long position, long count, WritableByteChannel target)\n+    throws IOException\n+  {\n+    if (position < 0\n+        || count < 0)\n+      throw new IllegalArgumentException ();\n+\n+    if (!isOpen ())\n+      throw new ClosedChannelException ();\n+\n+    if ((mode & READ) == 0)\n+       throw new NonReadableChannelException ();\n+   \n+    // XXX: count needs to be casted from long to int. Dataloss ?\n+    ByteBuffer buffer = ByteBuffer.allocate ((int) count);\n+    read (buffer, position);\n+    buffer.flip();\n+    return target.write (buffer);\n+  }\n+\n+  public long transferFrom (ReadableByteChannel src, long position, long count)\n+    throws IOException\n+  {\n+    if (position < 0\n+        || count < 0)\n+      throw new IllegalArgumentException ();\n+\n+    if (!isOpen ())\n+      throw new ClosedChannelException ();\n+\n+    if ((mode & WRITE) == 0)\n+       throw new NonWritableChannelException ();\n+\n+    // XXX: count needs to be casted from long to int. Dataloss ?\n+    ByteBuffer buffer = ByteBuffer.allocate ((int) count);\n+    src.read (buffer);\n+    buffer.flip();\n+    return write (buffer, position);\n+  }\n+\n+  public FileLock tryLock (long position, long size, boolean shared)\n+    throws IOException\n+  {\n+    if (position < 0\n+        || size < 0)\n+      throw new IllegalArgumentException ();\n+\n+    if (!isOpen ())\n+      throw new ClosedChannelException ();\n+\n+    if (shared && (mode & READ) == 0)\n+      throw new NonReadableChannelException ();\n+\t\n+    if (!shared && (mode & WRITE) == 0)\n+      throw new NonWritableChannelException ();\n+\t\n+    boolean completed = false;\n+    \n+    try\n+      {\n+\tbegin();\n+        lock(position, size, shared, true);\n+\tcompleted = true;\n+\treturn new FileLockImpl(this, position, size, shared);\n+      }\n+    finally\n+      {\n+\tend(completed);\n+      }\n+  }\n+\n+  /** Try to acquire a lock at the given position and size.\n+   * On success return true.\n+   * If wait as specified, block until we can get it.\n+   * Otherwise return false.\n+   */\n+  private native boolean lock(long position, long size,\n+\t\t\t      boolean shared, boolean wait);\n+  \n+  public FileLock lock (long position, long size, boolean shared)\n+    throws IOException\n+  {\n+    if (position < 0\n+        || size < 0)\n+      throw new IllegalArgumentException ();\n+\n+    if (!isOpen ())\n+      throw new ClosedChannelException ();\n+\n+    boolean completed = false;\n+\n+    try\n+      {\n+\tboolean lockable = lock(position, size, shared, false);\n+\tcompleted = true;\n+\treturn (lockable\n+\t\t? new FileLockImpl(this, position, size, shared)\n+\t\t: null);\n+      }\n+    finally\n+      {\n+\tend(completed);\n+      }\n+  }\n+\n+  public long position ()\n+    throws IOException\n+  {\n+    if (!isOpen ())\n+      throw new ClosedChannelException ();\n+\n+    return implPosition ();\n+  }\n+  \n+  public FileChannel position (long newPosition)\n+    throws IOException\n+  {\n+    if (newPosition < 0)\n+      throw new IllegalArgumentException ();\n+\n+    if (!isOpen ())\n+      throw new ClosedChannelException ();\n+\n+    // FIXME note semantics if seeking beyond eof.\n+    // We should seek lazily - only on a write.\n+    seek (newPosition);\n+    return this;\n+  }\n+  \n+  public FileChannel truncate (long size)\n+    throws IOException\n+  {\n+    if (size < 0)\n+      throw new IllegalArgumentException ();\n+\n+    if (!isOpen ())\n+      throw new ClosedChannelException ();\n+\n+    if ((mode & WRITE) == 0)\n+       throw new NonWritableChannelException ();\n+\n+    implTruncate (size);\n+    return this;\n+  }\n+}"}, {"sha": "66713079a8600d1ea577e27b72764815feb88e52", "filename": "libjava/gnu/java/nio/channels/natFileChannelEcos.cc", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/612e6609875599726838087b64e1ec6d6c8ee4e9/libjava%2Fgnu%2Fjava%2Fnio%2Fchannels%2FnatFileChannelEcos.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/612e6609875599726838087b64e1ec6d6c8ee4e9/libjava%2Fgnu%2Fjava%2Fnio%2Fchannels%2FnatFileChannelEcos.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2Fchannels%2FnatFileChannelEcos.cc?ref=612e6609875599726838087b64e1ec6d6c8ee4e9", "patch": "@@ -0,0 +1,159 @@\n+// natFileDescriptor.cc - Native part of FileDescriptor class.\n+\n+/* Copyright (C) 1998, 1999, 2001, 2002  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <config.h>\n+\n+#include <errno.h>\n+#include <string.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <sys/param.h>\n+\n+#include <gcj/cni.h>\n+#include <jvm.h>\n+#include <java/io/FileDescriptor.h>\n+#include <java/io/SyncFailedException.h>\n+#include <java/io/IOException.h>\n+#include <java/io/EOFException.h>\n+#include <java/lang/ArrayIndexOutOfBoundsException.h>\n+#include <java/lang/NullPointerException.h>\n+#include <java/lang/String.h>\n+#include <java/io/FileNotFoundException.h>\n+\n+extern \"C\" void diag_write_char (char c);\n+\n+static void \n+diag_write (char *data, int len)\n+{\n+  while (len > 0)\n+    {\n+      diag_write_char (*data++);\n+      len--;\n+    }\n+}\n+\n+#define NO_FSYNC_MESSAGE \"sync unsupported\"\n+\n+void\n+java::io::FileDescriptor::init(void)\n+{\n+  in = new java::io::FileDescriptor(0);\n+  out = new java::io::FileDescriptor(1);\n+  err = new java::io::FileDescriptor(2);\n+}\n+\n+jboolean\n+java::io::FileDescriptor::valid (void)\n+{\n+  return true;\n+}\n+\n+void\n+java::io::FileDescriptor::sync (void)\n+{\n+  // Some files don't support fsync.  We don't bother reporting these\n+  // as errors.\n+#ifdef HAVE_FSYNC\n+#else\n+  throw new SyncFailedException (JvNewStringLatin1 (NO_FSYNC_MESSAGE));\n+#endif\n+}\n+\n+jint\n+java::io::FileDescriptor::open (jstring path, jint jflags)\n+{\n+  return fd;\n+}\n+\n+void\n+java::io::FileDescriptor::write (jint b)\n+{\n+  char d = (char) b;\n+  ::diag_write (&d, 1);\n+}\n+\n+void\n+java::io::FileDescriptor::write (jbyteArray b, jint offset, jint len)\n+{\n+  if (! b)\n+    throw new java::lang::NullPointerException;\n+  if (offset < 0 || len < 0 || offset + len > JvGetArrayLength (b))\n+    throw new java::lang::ArrayIndexOutOfBoundsException;\n+  char *bytes = (char *)elements (b) + offset;\n+  ::diag_write (bytes, len);\n+}\n+\n+void\n+java::io::FileDescriptor::close (void)\n+{\n+}\n+\n+void\n+java::io::FileDescriptor::setLength (long)\n+{\n+}\n+\n+jint\n+java::io::FileDescriptor::seek (jlong pos, jint whence, jboolean)\n+{\n+  JvAssert (whence == SET || whence == CUR);\n+  return 0;\n+}\n+\n+jlong\n+java::io::FileDescriptor::getLength (void)\n+{\n+  return 0;\n+}\n+\n+jlong\n+java::io::FileDescriptor::getFilePointer (void)\n+{\n+  return 0;\n+}\n+\n+jint\n+java::io::FileDescriptor::read (void)\n+{\n+  return 0;\n+}\n+\n+jint\n+java::io::FileDescriptor::read (jbyteArray buffer, jint offset, jint count)\n+{\n+  return 0;\n+}\n+\n+jint\n+java::io::FileDescriptor::available (void)\n+{\n+  return 0;\n+}\n+\n+void\n+java::io::FileDescriptor::lock (jlong pos, jint len, jboolean shared)\n+{\n+  throw new IOException (JvNewStringLatin1\n+    (\"java.io.FileDescriptor.lock() not implemented\"));\n+}\n+\n+jboolean\n+java::io::FileDescriptor::tryLock (jlong pos, jint len, jboolean shared)\n+{\n+  throw new IOException (JvNewStringLatin1\n+    (\"java.io.FileDescriptor.tryLock() not implemented\"));\n+}\n+\n+void\n+java::io::FileDescriptor::unlock (jlong pos, jint len)\n+{\n+  throw new IOException (JvNewStringLatin1\n+    (\"java.io.FileDescriptor.unlock() not implemented\"));\n+}"}, {"sha": "865378728211a5a6a706c150bfab2c43266c64c0", "filename": "libjava/gnu/java/nio/channels/natFileChannelPosix.cc", "status": "added", "additions": 522, "deletions": 0, "changes": 522, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/612e6609875599726838087b64e1ec6d6c8ee4e9/libjava%2Fgnu%2Fjava%2Fnio%2Fchannels%2FnatFileChannelPosix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/612e6609875599726838087b64e1ec6d6c8ee4e9/libjava%2Fgnu%2Fjava%2Fnio%2Fchannels%2FnatFileChannelPosix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2Fchannels%2FnatFileChannelPosix.cc?ref=612e6609875599726838087b64e1ec6d6c8ee4e9", "patch": "@@ -0,0 +1,522 @@\n+\n+// natFileChannelImplPosix.cc - Native part of FileChannelImpl class.\n+\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <config.h>\n+#include <platform.h>\n+\n+#include <gcj/cni.h>\n+#include <gcj/javaprims.h>\n+#include <jvm.h>\n+\n+#include \"posix.h\"\n+\n+#include <errno.h>\n+#include <fcntl.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include <sys/stat.h>\n+#include <sys/param.h>\n+\n+#include <gnu/gcj/RawData.h>\n+#include <gnu/java/nio/FileLockImpl.h>\n+#include <gnu/java/nio/channels/FileChannelImpl.h>\n+#include <java/io/FileNotFoundException.h>\n+#include <java/io/IOException.h>\n+#include <java/io/SyncFailedException.h>\n+#include <java/io/InterruptedIOException.h>\n+#include <java/io/EOFException.h>\n+#include <java/lang/ArrayIndexOutOfBoundsException.h>\n+#include <java/lang/NullPointerException.h>\n+#include <java/lang/System.h>\n+#include <java/lang/String.h>\n+#include <java/lang/Thread.h>\n+#include <java/nio/ByteBuffer.h>\n+#include <java/nio/MappedByteBufferImpl.h>\n+#include <java/nio/channels/FileChannel.h>\n+#include <java/nio/channels/FileLock.h>\n+#include <gnu/java/nio/channels/FileChannelImpl.h>\n+\n+#ifdef HAVE_SYS_IOCTL_H\n+#define BSD_COMP /* Get FIONREAD on Solaris2. */\n+#include <sys/ioctl.h>\n+#endif\n+\n+// Pick up FIONREAD on Solaris 2.5.\n+#ifdef HAVE_SYS_FILIO_H\n+#include <sys/filio.h>\n+#endif\n+\n+#ifdef HAVE_MMAP\n+#include <sys/mman.h>\n+#endif\n+\n+using gnu::gcj::RawData;\n+using java::io::IOException;\n+using java::nio::MappedByteBufferImpl;\n+using java::io::InterruptedIOException;\n+using java::io::FileNotFoundException;\n+using java::lang::ArrayIndexOutOfBoundsException;\n+using gnu::java::nio::channels::FileChannelImpl;\n+\n+#define NO_FSYNC_MESSAGE \"sync unsupported\"\n+\n+void\n+FileChannelImpl::init(void)\n+{\n+  in = new FileChannelImpl((jint) 0, FileChannelImpl::READ);\n+  out = new FileChannelImpl((jint) 1, FileChannelImpl::WRITE);\n+  err = new FileChannelImpl((jint) 2, FileChannelImpl::WRITE);\n+}\n+\n+#if 0\n+jboolean\n+FileChannelImpl::valid (void)\n+{\n+  struct stat sb;\n+  return fd >= 0 && ::fstat (fd, &sb) == 0;\n+}\n+\n+void\n+FileChannelImpl::sync (void)\n+{\n+  // Some files don't support fsync.  We don't bother reporting these\n+  // as errors.\n+#ifdef HAVE_FSYNC\n+  if (::fsync (fd) && errno != EROFS && errno != EINVAL)\n+    throw new SyncFailedException (JvNewStringLatin1 (strerror (errno)));\n+#else\n+  throw new SyncFailedException (JvNewStringLatin1 (NO_FSYNC_MESSAGE));\n+#endif\n+}\n+#endif\n+\n+jint\n+FileChannelImpl::open (jstring path, jint jflags)\n+{\n+  fd = -1;\n+  char *buf = (char *) _Jv_AllocBytes (_Jv_GetStringUTFLength (path) + 1);\n+  jsize total = JvGetStringUTFRegion (path, 0, path->length(), buf);\n+  buf[total] = '\\0';\n+  int flags = 0;\n+#ifdef O_BINARY\n+  flags |= O_BINARY;\n+#endif\n+\n+  JvAssert ((jflags & READ) || (jflags & WRITE));\n+  int mode = 0666;\n+  if ((jflags & READ) && (jflags & WRITE))\n+    flags |= O_RDWR | O_CREAT;\n+  else if ((jflags & READ))\n+    flags |= O_RDONLY;\n+  else\n+    {\n+      flags |= O_WRONLY | O_CREAT;\n+      if ((jflags & APPEND))\n+\tflags |= O_APPEND;\n+      else\n+\tflags |= O_TRUNC;\n+\n+      if ((jflags & EXCL))\n+\t{\n+\t  flags |= O_EXCL;\n+\t  // In this case we are making a temp file.\n+\t  mode = 0600;\n+\t}\n+    }\n+\n+  if ((jflags & SYNC))\n+    flags |= O_SYNC;\n+\n+  if ((jflags & DSYNC))\n+    flags |= O_DSYNC;\n+\n+  int fd = ::open (buf, flags, mode);\n+  if (fd == -1 && errno == EMFILE)\n+    {\n+      // Because finalize () calls close () we might be able to continue.\n+      ::java::lang::System::gc ();\n+      ::java::lang::System::runFinalization ();\n+      fd = ::open (buf, flags, mode);\n+    }\n+  if (fd == -1)\n+    {\n+      char msg[MAXPATHLEN + 200];\n+      // We choose the formatting here for JDK compatibility, believe\n+      // it or not.\n+      sprintf (msg, \"%.*s (%.*s)\",\n+\t       MAXPATHLEN + 150, buf,\n+\t       40, strerror (errno));\n+      throw new ::java::io::FileNotFoundException (JvNewStringLatin1 (msg));\n+    }\n+\n+  _Jv_platform_close_on_exec (fd);\n+\n+  return fd;\n+}\n+\n+void\n+FileChannelImpl::write (jint b)\n+{\n+  jbyte d = (jbyte) b;\n+  int r = 0;\n+  while (r != 1)\n+    {\n+      r = ::write (fd, &d, 1);\n+      if (r == -1)\n+        {\n+\t  if (::java::lang::Thread::interrupted())\n+\t    {\n+\t      ::java::io::InterruptedIOException *iioe\n+\t\t= new ::java::io::InterruptedIOException (JvNewStringLatin1 (strerror (errno)));\n+\t      iioe->bytesTransferred = r == -1 ? 0 : r;\n+\t      throw iioe;\n+\t    }\t    \n+\t  if (errno != EINTR)\n+\t    throw new IOException (JvNewStringLatin1 (strerror (errno)));\n+\t}\n+    }\n+  pos++;\n+}\n+\n+void\n+FileChannelImpl::write (jbyteArray b, jint offset, jint len)\n+{\n+  if (! b)\n+    throw new ::java::lang::NullPointerException;\n+  if (offset < 0 || len < 0 || offset + len > JvGetArrayLength (b))\n+    throw new ArrayIndexOutOfBoundsException;\n+  jbyte *bytes = elements (b) + offset;\n+\n+  int written = 0;\n+  while (len > 0)\n+    {\n+      int r = ::write (fd, bytes, len);\n+      if (r == -1)\n+        {\n+\t  if (::java::lang::Thread::interrupted())\n+\t    {\n+\t      InterruptedIOException *iioe\n+\t\t= new InterruptedIOException (JvNewStringLatin1 (strerror (errno)));\n+\t      iioe->bytesTransferred = written;\n+\t      throw iioe;\n+\t    }\n+\t  if (errno != EINTR)\n+\t    throw new IOException (JvNewStringLatin1 (strerror (errno)));\n+\t}\n+\n+      written += r;\n+      len -= r;\n+      bytes += r;\n+      pos += r;\n+    }\n+}\n+\n+void\n+FileChannelImpl::implCloseChannel (void)\n+{\n+  jint save = fd;\n+  fd = -1;\n+  if (::close (save))\n+    throw new IOException (JvNewStringLatin1 (strerror (errno)));\n+}\n+\n+void\n+FileChannelImpl::implTruncate (jlong size)\n+{\n+  struct stat sb;\n+\n+#ifdef HAVE_FTRUNCATE\n+  if (::fstat (fd, &sb))\n+    throw new IOException (JvNewStringLatin1 (strerror (errno)));\n+\n+  if ((jlong) sb.st_size == size) \n+    return;\n+\n+  // If the file is too short, we extend it.  We can't rely on\n+  // ftruncate() extending the file.  So we lseek() to 1 byte less\n+  // than we want, and then we write a single byte at the end.\n+  if ((jlong) sb.st_size < size)\n+    {\n+      if (::lseek (fd, (off_t) (size - 1), SEEK_SET) == -1)\n+\tthrow new IOException (JvNewStringLatin1 (strerror (errno)));\n+      char out = '\\0';\n+      int r = ::write (fd, &out, 1);\n+      if (r <= 0 || ::lseek (fd, pos, SEEK_SET) == -1)\n+\tthrow new IOException (JvNewStringLatin1 (strerror (errno)));\n+    }\n+  else\n+    {\n+      if (::ftruncate (fd, (off_t) pos))\n+\tthrow new IOException (JvNewStringLatin1 (strerror (errno)));\n+      pos = size;\n+    }\n+#else /* HAVE_FTRUNCATE */\n+  throw new IOException (JvNewStringLatin1 (\"FileDescriptor.setLength not implemented\"));\n+#endif /* HAVE_FTRUNCATE */\n+}\n+\n+void\n+FileChannelImpl::seek (jlong newPos)\n+{\n+  off_t r = ::lseek (fd, (off_t) newPos, SEEK_SET);\n+  if (r == -1)\n+    throw new IOException (JvNewStringLatin1 (strerror (errno)));\n+  pos = r;\n+}\n+\n+jlong\n+FileChannelImpl::size (void)\n+{\n+  struct stat sb;\n+  if (::fstat (fd, &sb))\n+    throw new IOException (JvNewStringLatin1 (strerror (errno)));\n+  return sb.st_size;\n+}\n+\n+jlong\n+FileChannelImpl::implPosition (void)\n+{\n+  return pos;\n+}\n+\n+jint\n+FileChannelImpl::read (void)\n+{\n+  jbyte b;\n+  int r;\n+  do\n+    {\n+      r = ::read (fd, &b, 1);\n+      if (r == 0)\n+\treturn -1;\n+      if (r == -1)\n+\t{\n+\t  if (::java::lang::Thread::interrupted())\n+\t    {\n+\t      InterruptedIOException *iioe\n+\t\t= new InterruptedIOException (JvNewStringLatin1 (strerror (errno)));\n+\t      iioe->bytesTransferred = r == -1 ? 0 : r;\n+\t      throw iioe;\n+\t    }\n+\t  if (errno != EINTR)\n+\t    throw new IOException (JvNewStringLatin1 (strerror (errno)));\n+\t}\n+    }\n+  while (r != 1);\n+  pos++;\n+  return b & 0xFF;\n+}\n+\n+jint\n+FileChannelImpl::read (jbyteArray buffer, jint offset, jint count)\n+{\n+  if (! buffer)\n+    throw new ::java::lang::NullPointerException;\n+  jsize bsize = JvGetArrayLength (buffer);\n+  if (offset < 0 || count < 0 || offset + count > bsize)\n+    throw new ::java::lang::ArrayIndexOutOfBoundsException;\n+\n+  // Must return 0 if an attempt is made to read 0 bytes.\n+  if (count == 0)\n+    return 0;\n+\n+  jbyte *bytes = elements (buffer) + offset;\n+  int r;\n+  do\n+    {\n+      r = ::read (fd, bytes, count);\n+      if (r == 0)\n+\treturn -1;\n+      if (r == -1)\n+\t{\n+\t  if (::java::lang::Thread::interrupted())\n+\t    {\n+\t      InterruptedIOException *iioe\n+\t\t= new InterruptedIOException (JvNewStringLatin1 (strerror (errno)));\n+\t      iioe->bytesTransferred = r == -1 ? 0 : r;\n+\t      throw iioe;\n+\t    }\n+\t  if (errno != EINTR)\n+\t    throw new IOException (JvNewStringLatin1 (strerror (errno)));\n+\t}\n+    }\n+  while (r <= 0);\n+  pos += r;\n+  return r;\n+}\n+\n+jint\n+FileChannelImpl::available (void)\n+{\n+#if defined (FIONREAD) || defined (HAVE_SELECT) || defined (HAVE_FSTAT)\n+  long num = 0;\n+  int r = 0;\n+  bool num_set = false;\n+\n+#if defined (FIONREAD)\n+  r = ::ioctl (fd, FIONREAD, &num);\n+  if (r == -1 && errno == ENOTTY)\n+    {\n+      // If the ioctl doesn't work, we don't care.\n+      r = 0;\n+      num = 0;\n+    }\n+  else\n+    num_set = true;\n+#elif defined (HAVE_SELECT)\n+  if (fd < 0)\n+    {\n+      errno = EBADF;\n+      r = -1;\n+    }\n+#endif\n+\n+  if (r == -1)\n+    {\n+    posix_error:\n+      throw new IOException (JvNewStringLatin1 (strerror (errno)));\n+    }\n+\n+  // If we didn't get anything, and we have fstat, then see if see if\n+  // we're reading a regular file.  On many systems, FIONREAD does not\n+  // work on regular files; select() likewise returns a useless\n+  // result.  This is run incorrectly when FIONREAD does work on\n+  // regular files and we are at the end of the file.  However, this\n+  // case probably isn't very important.\n+#if defined (HAVE_FSTAT)\n+  if (! num_set)\n+    {\n+      struct stat sb;\n+      off_t where = 0;\n+      if (fstat (fd, &sb) != -1\n+\t  && S_ISREG (sb.st_mode)\n+\t  && (where = lseek (fd, 0, SEEK_CUR)) != (off_t) -1)\n+\t{\n+\t  num = (long) (sb.st_size - where);\n+\t  num_set = true;\n+\t}\n+    }\n+#endif /* HAVE_FSTAT */\n+\n+#if defined (HAVE_SELECT)\n+  if (! num_set)\n+    {\n+      fd_set rd;\n+      FD_ZERO (&rd);\n+      FD_SET (fd, &rd);\n+      struct timeval tv;\n+      tv.tv_sec = 0;\n+      tv.tv_usec = 0;\n+      r = _Jv_select (fd + 1, &rd, NULL, NULL, &tv);\n+      if (r == -1)\n+\tgoto posix_error;\n+      num = r == 0 ? 0 : 1;\n+    }\n+#endif /* HAVE_SELECT */\n+\n+  return (jint) num;\n+#else\n+  return 0;\n+#endif\n+}\n+\n+jboolean\n+FileChannelImpl::lock\n+(jlong pos, jlong len, jboolean shared, jboolean wait)\n+{\n+  struct flock lockdata;\n+\n+  lockdata.l_type = shared ? F_WRLCK : F_RDLCK;\n+  lockdata.l_whence = SEEK_SET;\n+  lockdata.l_start = pos;\n+  lockdata.l_len = len;\n+\n+  if (::fcntl (fd, wait ? F_SETLKW : F_SETLK, &lockdata) == -1)\n+    {\n+      if (! wait && (errno == EACCES || errno == EAGAIN))\n+\treturn false;\n+      throw new IOException (JvNewStringLatin1 (strerror (errno)));\n+    }\n+  return true;\n+}\n+\n+void\n+FileChannelImpl::unlock (jlong pos, jlong len)\n+{\n+  struct flock lockdata;\n+\n+  lockdata.l_type = F_UNLCK;\n+  lockdata.l_whence = SEEK_SET;\n+  lockdata.l_start = pos;\n+  lockdata.l_len = len;\n+\n+  if (::fcntl (fd, F_SETLK, &lockdata) == -1)\n+    throw new IOException (JvNewStringLatin1 (strerror (errno)));\n+}\n+\n+java::nio::MappedByteBuffer *\n+FileChannelImpl::mapImpl (jchar mmode, jlong position, jint size)\n+{\n+#if defined(HAVE_MMAP)\n+  int prot, flags;\n+  if (mmode == 'r')\n+    {\n+      prot = PROT_READ;\n+      flags = MAP_PRIVATE;\n+    }\n+  else\n+    {\n+      prot = PROT_READ|PROT_WRITE;\n+      flags = mmode == '+' ? MAP_SHARED : MAP_PRIVATE;\n+    }\n+  jint page_size = ::getpagesize();\n+  jint offset = position & ~(page_size-1);\n+  jint align = position - offset;\n+  void* ptr = ::mmap(NULL, size + align, prot, flags, fd, offset);\n+  MappedByteBufferImpl *buf\n+    = new MappedByteBufferImpl ((RawData *) ((char *) ptr + align),\n+\t\t\t\tsize, mmode == 'r');\n+  if (ptr == MAP_FAILED)\n+    throw new IOException (JvNewStringLatin1 (strerror (errno)));\n+  buf->implPtr = reinterpret_cast<RawData*> (ptr);\n+  buf->implLen = size+align;\n+  return buf;\n+#else\n+  throw new IOException (JvNewStringUTF (\"mmap not implemented\"));\n+#endif\n+}\n+\n+void\n+MappedByteBufferImpl::unmapImpl ()\n+{\n+#if defined(HAVE_MMAP)\n+  munmap((void*) implPtr, implLen);\n+#endif\n+}\n+\n+void\n+MappedByteBufferImpl::loadImpl ()\n+{\n+}\n+\n+jboolean\n+MappedByteBufferImpl::isLoadedImpl ()\n+{\n+  return true;\n+}\n+\n+void\n+MappedByteBufferImpl::forceImpl ()\n+{\n+#if defined(HAVE_MMAP)\n+  ::msync((void*) implPtr, implLen, MS_SYNC);\n+#endif\n+}"}, {"sha": "ca6387df0118ea6c881a4028af6eb063911813de", "filename": "libjava/gnu/java/nio/channels/natFileChannelWin32.cc", "status": "added", "additions": 432, "deletions": 0, "changes": 432, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/612e6609875599726838087b64e1ec6d6c8ee4e9/libjava%2Fgnu%2Fjava%2Fnio%2Fchannels%2FnatFileChannelWin32.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/612e6609875599726838087b64e1ec6d6c8ee4e9/libjava%2Fgnu%2Fjava%2Fnio%2Fchannels%2FnatFileChannelWin32.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2Fchannels%2FnatFileChannelWin32.cc?ref=612e6609875599726838087b64e1ec6d6c8ee4e9", "patch": "@@ -0,0 +1,432 @@\n+// natFileChannelImplWin32.cc - Native part of FileChannelImpl class.\n+\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004  Free Software \n+   Foundation, Inc.\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+// FIXME: In order to support interrupting of IO operations, we\n+// need to change to use the windows asynchronous IO functions\n+\n+#include <config.h>\n+#include <platform.h>\n+\n+#include <gcj/cni.h>\n+#include <gcj/javaprims.h>\n+#include <jvm.h>\n+\n+#include <stdio.h>\n+\n+#include <gnu/gcj/RawData.h>\n+#include <gnu/java/nio/FileLockImpl.h>\n+#include <gnu/java/nio/channels/FileChannelImpl.h>\n+#include <java/io/FileNotFoundException.h>\n+#include <java/io/IOException.h>\n+#include <java/io/SyncFailedException.h>\n+#include <java/io/InterruptedIOException.h>\n+#include <java/io/EOFException.h>\n+#include <java/lang/ArrayIndexOutOfBoundsException.h>\n+#include <java/lang/NullPointerException.h>\n+#include <java/lang/System.h>\n+#include <java/lang/String.h>\n+#include <java/lang/Thread.h>\n+#include <java/nio/ByteBuffer.h>\n+#include <java/nio/MappedByteBufferImpl.h>\n+#include <java/nio/channels/FileChannel.h>\n+#include <java/nio/channels/FileLock.h>\n+#include <gnu/java/nio/channels/FileChannelImpl.h>\n+\n+using gnu::gcj::RawData;\n+using java::io::IOException;\n+using java::nio::MappedByteBufferImpl;\n+using java::io::InterruptedIOException;\n+using java::io::FileNotFoundException;\n+using java::lang::ArrayIndexOutOfBoundsException;\n+using gnu::java::nio::channels::FileChannelImpl;\n+\n+#undef STRICT\n+\n+static bool testCanUseGetHandleInfo()\n+{\n+  /* Test to see whether GetHandleInformation can be used\n+     for console input or screen buffers. This is better\n+     a kludgy OS version check. */\n+  DWORD dwFlags;\n+  return GetHandleInformation (GetStdHandle (STD_INPUT_HANDLE),\n+    &dwFlags) != 0;\n+}\n+\n+// FIXME: casting a FILE (pointer) to a jint will not work on Win64 --\n+//        we should be using gnu.gcj.RawData's.\n+\n+void\n+FileChannelImpl::init(void)\n+{\n+  in = new FileChannelImpl((jint)(GetStdHandle (STD_INPUT_HANDLE)),\n+\t\t\t   FileChannelImpl::READ);\n+  out = new FileChannelImpl((jint)(GetStdHandle (STD_OUTPUT_HANDLE)),\n+\t\t\t    FileChannelImpl::WRITE);\n+  err = new FileChannelImpl((jint)(GetStdHandle (STD_ERROR_HANDLE)),\n+\t\t\t    FileChannelImpl::WRITE);\n+}\n+\n+#if 0\n+FileChannelImpl::sync (void) {\n+  if (! FlushFileBuffers ((HANDLE)fd))\n+  {\n+    DWORD dwErrorCode = GetLastError ();\n+    throw new SyncFailedException (_Jv_WinStrError (dwErrorCode));\n+  }\n+}\n+#endif\n+\n+jint\n+FileChannelImpl::open (jstring path, jint jflags) {\n+\n+  HANDLE handle = NULL;\n+  DWORD access = 0;\n+  DWORD create = OPEN_EXISTING;\n+  \n+  JV_TEMP_STRING_WIN32(cpath, path)\n+\n+  JvAssert((jflags & READ) || (jflags & WRITE));\n+\n+  if ((jflags & READ) && (jflags & WRITE))\n+    {\n+      access = GENERIC_READ | GENERIC_WRITE;\n+      if (jflags & EXCL)\n+        create = CREATE_NEW; // this will raise error if file exists.\n+      else\n+        create = OPEN_ALWAYS; // equivalent to O_CREAT\n+    }\n+  else if (jflags & READ)\n+    {\n+      access = GENERIC_READ;\n+      create = OPEN_EXISTING; // ignore EXCL\n+    }\n+  else\n+    { \n+      access = GENERIC_WRITE;\n+      if (jflags & EXCL)\n+        create = CREATE_NEW;\n+      else if (jflags & APPEND)\n+        create = OPEN_ALWAYS;\n+      else\n+        create = CREATE_ALWAYS;\n+    }\n+\n+  handle = CreateFile(cpath, access, FILE_SHARE_READ | FILE_SHARE_WRITE,\n+    NULL, create, 0, NULL);\n+\n+  if (handle == INVALID_HANDLE_VALUE)\n+    {\n+       DWORD dwErrorCode = GetLastError ();\n+       throw new FileNotFoundException (_Jv_WinStrError (cpath, dwErrorCode));\n+    }\n+\n+  // For APPEND mode, move the file pointer to the end of the file.\n+  if (jflags & APPEND)\n+    {\n+      DWORD low = SetFilePointer (handle, 0, NULL, FILE_END);\n+      if ((low == (DWORD) 0xffffffff) && (GetLastError () != NO_ERROR)) \n+      {\n+        DWORD dwErrorCode = GetLastError ();\n+        throw new FileNotFoundException (_Jv_WinStrError (cpath, dwErrorCode));\n+      }\n+    }\n+    \n+  // Make this handle non-inheritable so that child\n+  // processes don't inadvertently prevent us from\n+  // closing this file.\n+  _Jv_platform_close_on_exec (handle);\n+\n+  return (jint) handle;\n+}\n+\n+void\n+FileChannelImpl::write (jint b)\n+{\n+  DWORD bytesWritten;\n+  jbyte buf = (jbyte)b;\n+\n+  if (WriteFile ((HANDLE)fd, &buf, 1, &bytesWritten, NULL))\n+    {\n+      if (::java::lang::Thread::interrupted())\n+        {\n+          InterruptedIOException *iioe = new InterruptedIOException (JvNewStringLatin1 (\"write interrupted\"));\n+          iioe->bytesTransferred = bytesWritten;\n+    throw iioe;\n+        }\n+      if (bytesWritten != 1)\n+        _Jv_ThrowIOException ();\n+    }\n+  else\n+    _Jv_ThrowIOException ();\n+  // FIXME: loop until bytesWritten == 1\n+}\n+\n+void\n+FileChannelImpl::write(jbyteArray b, jint offset, jint len)\n+{\n+  if (! b)\n+    throw new ::java::lang::NullPointerException;\n+  if(offset < 0 || len < 0 || offset + len > JvGetArrayLength (b))\n+    throw new ArrayIndexOutOfBoundsException;\n+\n+  jbyte *buf = elements (b) + offset;\n+  DWORD bytesWritten;\n+\n+  if (WriteFile ((HANDLE)fd, buf, len, &bytesWritten, NULL))\n+    {\n+      if (::java::lang::Thread::interrupted())\n+        {\n+          InterruptedIOException *iioe = new InterruptedIOException (JvNewStringLatin1 (\"write interrupted\"));\n+          iioe->bytesTransferred = bytesWritten;\n+          throw iioe;\n+        }\n+    }\n+  else\n+    _Jv_ThrowIOException ();\n+  // FIXME: loop until bytesWritten == len\n+}\n+\n+void\n+FileChannelImpl::implCloseChannel (void)\n+{\n+  HANDLE save = (HANDLE)fd;\n+  fd = (jint)INVALID_HANDLE_VALUE;\n+  if (! CloseHandle (save))\n+    _Jv_ThrowIOException ();\n+}\n+\n+void\n+FileChannelImpl::implTruncate (jlong size)\n+{\n+  LONG liOrigFilePointer;\n+  LONG liNewFilePointer;\n+  LONG liEndFilePointer;\n+\n+  // Get the original file pointer.\n+  if (SetFilePointer((HANDLE) fd, (LONG) 0, &liOrigFilePointer,\n+         FILE_CURRENT) != (BOOL) 0\n+      && (GetLastError() != NO_ERROR))\n+    _Jv_ThrowIOException ();\n+\n+  // Get the length of the file.\n+  if (SetFilePointer((HANDLE) fd, (LONG) 0, &liEndFilePointer,\n+         FILE_END) != (BOOL) 0\n+      && (GetLastError() != NO_ERROR))\n+    _Jv_ThrowIOException ();\n+\n+  if ((jlong)liEndFilePointer == size)\n+    {\n+      // Restore the file pointer.\n+      if (liOrigFilePointer != liEndFilePointer)\n+  {\n+    if (SetFilePointer((HANDLE) fd, liOrigFilePointer, &liNewFilePointer,\n+           FILE_BEGIN) != (BOOL) 0\n+        && (GetLastError() != NO_ERROR))\n+      _Jv_ThrowIOException ();\n+  }\n+      return;\n+    }\n+\n+  // Seek to the new end of file.\n+  if (SetFilePointer((HANDLE) fd, (LONG) size, &liNewFilePointer,\n+         FILE_BEGIN) != (BOOL) 0\n+      && (GetLastError() != NO_ERROR))\n+    _Jv_ThrowIOException ();\n+\n+  // Truncate the file at this point.\n+  if (SetEndOfFile((HANDLE) fd) != (BOOL) 0 && (GetLastError() != NO_ERROR))\n+    _Jv_ThrowIOException ();\n+\n+  if (liOrigFilePointer < liNewFilePointer)\n+    {\n+      // Restore the file pointer.\n+      if (SetFilePointer((HANDLE) fd, liOrigFilePointer, &liNewFilePointer,\n+        FILE_BEGIN) != (BOOL) 0\n+        && (GetLastError() != NO_ERROR))\n+        _Jv_ThrowIOException ();\n+    }\n+}\n+\n+void\n+FileChannelImpl::seek (jlong newPos)\n+{\n+  LONG high = pos >> 32;\n+  DWORD low = SetFilePointer ((HANDLE)fd, (DWORD)(0xffffffff & newPos), &high, FILE_BEGIN);\n+  if ((low == 0xffffffff) && (GetLastError () != NO_ERROR))\n+    _Jv_ThrowIOException ();\n+}\n+\n+jlong\n+FileChannelImpl::implPosition (void)\n+{\n+  LONG high = 0;\n+  DWORD low = SetFilePointer ((HANDLE)fd, 0, &high, FILE_CURRENT);\n+  if ((low == 0xffffffff) && (GetLastError() != NO_ERROR))\n+    _Jv_ThrowIOException ();\n+  return (((jlong)high) << 32L) | (jlong)low;\n+}\n+\n+jlong\n+FileChannelImpl::size (void)\n+{\n+  DWORD high;\n+  DWORD low;\n+\n+  low = GetFileSize ((HANDLE)fd, &high);\n+  // FIXME: Error checking\n+  return (((jlong)high) << 32L) | (jlong)low;\n+}\n+\n+jint\n+FileChannelImpl::read (void)\n+{\n+  CHAR buf;\n+  DWORD read;\n+\n+  if (! ReadFile ((HANDLE)fd, &buf, 1, &read, NULL))\n+    {\n+      if (GetLastError () == ERROR_BROKEN_PIPE)\n+        return -1;\n+      else\n+        _Jv_ThrowIOException ();\n+    }\n+\n+  if (! read)\n+    return -1;\n+  else\n+    return (jint)(buf & 0xff);\n+}\n+\n+jint\n+FileChannelImpl::read (jbyteArray buffer, jint offset, jint count)\n+{\n+  if (! buffer)\n+    throw new ::java::lang::NullPointerException;\n+\n+  jsize bsize = JvGetArrayLength (buffer);\n+  if (offset < 0 || count < 0 || offset + count > bsize)\n+    throw new ArrayIndexOutOfBoundsException;\n+\n+  // Must return 0 if an attempt is made to read 0 bytes.\n+  if (count == 0)\n+    return 0;\n+\n+  jbyte *bytes = elements (buffer) + offset;\n+\n+  DWORD read;\n+  if (! ReadFile((HANDLE)fd, bytes, count, &read, NULL))\n+    {\n+      if (GetLastError () == ERROR_BROKEN_PIPE)\n+        return -1;\n+      else\n+        _Jv_ThrowIOException ();\n+    }\n+\n+  if (read == 0) return -1;\n+\n+  return (jint)read;\n+}\n+\n+jint\n+FileChannelImpl::available (void)\n+{\n+  // FIXME:\n+  return size() - position();\n+}\n+\n+jboolean\n+FileChannelImpl::lock\n+(jlong /*pos*/, jlong /*len*/, jboolean /*shared*/, jboolean /*wait*/)\n+{\n+  throw new IOException (JvNewStringLatin1\n+    (\"FileChannel.lock() not implemented\"));\n+}\n+\n+void\n+FileChannelImpl::unlock (jlong /*pos*/, jlong /*len*/)\n+{\n+  throw new IOException (JvNewStringLatin1\n+    (\"FileChannel.unlock() not implemented\"));\n+}\n+\n+java::nio::MappedByteBuffer *\n+FileChannelImpl::mapImpl (jchar mmode, jlong position, jint size)\n+{\n+  SYSTEM_INFO siSysInfo;\n+  GetSystemInfo(&siSysInfo); \n+  DWORD page_size = siSysInfo.dwPageSize;\n+  jlong offset = position & ~(page_size-1);\n+  jint align = position - offset;\n+  jlong high = position + size;\n+  jlong max_size;\n+  if (mmode == '+')\n+    max_size = high - offset;\n+  else\n+    max_size = 0;\n+  DWORD access, protect;\n+  if (mmode == 'r')\n+    {\n+      access = FILE_MAP_READ;\n+      protect = PAGE_READONLY;\n+    }\n+  else if (mmode == '+')\n+    {\n+      access = FILE_MAP_WRITE;\n+      protect = PAGE_READWRITE;\n+    }\n+  else\n+    {\n+      access = FILE_MAP_COPY;\n+      protect = PAGE_WRITECOPY;\n+    }\n+  HANDLE hFileMapping = CreateFileMapping((HANDLE) fd,\n+\t\t\t\t\t  (LPSECURITY_ATTRIBUTES) NULL,\n+\t\t\t\t\t  protect,\n+\t\t\t\t\t  (DWORD) (max_size >> 32),\n+\t\t\t\t\t  (DWORD) max_size,\n+\t\t\t\t\t  (LPCTSTR) NULL);\n+  if (hFileMapping == NULL)\n+    throw new IOException();\n+  void *ptr = MapViewOfFile(hFileMapping, access,\n+\t\t\t    (DWORD) (offset >> 32), (DWORD) offset,\n+\t\t\t    (SIZE_T) (high - offset));\n+  if (ptr == NULL)\n+    throw new IOException();\n+  MappedByteBufferImpl *buf\n+    = new MappedByteBufferImpl((RawData *) ((char *) ptr + align),\n+\t\t\t       size, mode == 'r');\n+  buf->implPtr = reinterpret_cast<RawData*> (ptr);\n+  buf->implLen = (jlong) (size_t) hFileMapping;\n+  return buf;\n+}\n+\n+void\n+MappedByteBufferImpl::unmapImpl ()\n+{\n+  UnmapViewOfFile((void*)implPtr);\n+  CloseHandle((HANDLE) (size_t) implLen);\n+}\n+\n+void\n+MappedByteBufferImpl::loadImpl ()\n+{\n+}\n+\n+jboolean\n+MappedByteBufferImpl::isLoadedImpl ()\n+{\n+  return true;\n+}\n+\n+void\n+MappedByteBufferImpl::forceImpl ()\n+{\n+}"}]}