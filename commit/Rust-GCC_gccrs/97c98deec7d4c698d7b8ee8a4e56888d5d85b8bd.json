{"sha": "97c98deec7d4c698d7b8ee8a4e56888d5d85b8bd", "node_id": "C_kwDOANBUbNoAKDk3Yzk4ZGVlYzdkNGM2OThkN2I4ZWU4YTRlNTY4ODhkNWQ4NWI4YmQ", "commit": {"author": {"name": "David Faust", "email": "david.faust@oracle.com", "date": "2021-11-15T19:27:35Z"}, "committer": {"name": "David Faust", "email": "david.faust@oracle.com", "date": "2021-11-16T21:00:32Z"}, "message": "rust-backend.h: remove unused function prototypes\n\nThese functions are holdovers from the original port from the Go\nfrontend for Rust. They aren't used anywhere, so delete them from\nrust-backend.h and rust-gcc.cc.\n\n(set_)placeholder_xxx_type ()\n(is_)circular_pointer_type ()", "tree": {"sha": "ae5b3ebbe82642c8f9398505c61e64ca387adbe5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae5b3ebbe82642c8f9398505c61e64ca387adbe5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/97c98deec7d4c698d7b8ee8a4e56888d5d85b8bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97c98deec7d4c698d7b8ee8a4e56888d5d85b8bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97c98deec7d4c698d7b8ee8a4e56888d5d85b8bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97c98deec7d4c698d7b8ee8a4e56888d5d85b8bd/comments", "author": {"login": "dafaust", "id": 4460334, "node_id": "MDQ6VXNlcjQ0NjAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4460334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dafaust", "html_url": "https://github.com/dafaust", "followers_url": "https://api.github.com/users/dafaust/followers", "following_url": "https://api.github.com/users/dafaust/following{/other_user}", "gists_url": "https://api.github.com/users/dafaust/gists{/gist_id}", "starred_url": "https://api.github.com/users/dafaust/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dafaust/subscriptions", "organizations_url": "https://api.github.com/users/dafaust/orgs", "repos_url": "https://api.github.com/users/dafaust/repos", "events_url": "https://api.github.com/users/dafaust/events{/privacy}", "received_events_url": "https://api.github.com/users/dafaust/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dafaust", "id": 4460334, "node_id": "MDQ6VXNlcjQ0NjAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4460334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dafaust", "html_url": "https://github.com/dafaust", "followers_url": "https://api.github.com/users/dafaust/followers", "following_url": "https://api.github.com/users/dafaust/following{/other_user}", "gists_url": "https://api.github.com/users/dafaust/gists{/gist_id}", "starred_url": "https://api.github.com/users/dafaust/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dafaust/subscriptions", "organizations_url": "https://api.github.com/users/dafaust/orgs", "repos_url": "https://api.github.com/users/dafaust/repos", "events_url": "https://api.github.com/users/dafaust/events{/privacy}", "received_events_url": "https://api.github.com/users/dafaust/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3"}], "stats": {"total": 248, "additions": 0, "deletions": 248}, "files": [{"sha": "340284f1070228ee81e76e205f093191a6499a39", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97c98deec7d4c698d7b8ee8a4e56888d5d85b8bd/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97c98deec7d4c698d7b8ee8a4e56888d5d85b8bd/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=97c98deec7d4c698d7b8ee8a4e56888d5d85b8bd", "patch": "@@ -229,96 +229,13 @@ class Backend\n   // Get an array type.\n   virtual Btype *array_type (Btype *element_type, Bexpression *length) = 0;\n \n-  // Create a placeholder pointer type.  This is used for a named\n-  // pointer type, since in Go a pointer type may refer to itself.\n-  // NAME is the name of the type, and the location is where the named\n-  // type is defined.  This function is also used for unnamed function\n-  // types with multiple results, in which case the type has no name\n-  // and NAME will be empty.  FOR_FUNCTION is true if this is for a C\n-  // pointer to function type.  A Go func type is represented as a\n-  // pointer to a struct, and the first field of the struct is a C\n-  // pointer to function.  The return value will later be passed as\n-  // the first parameter to set_placeholder_pointer_type or\n-  // set_placeholder_function_type.\n-  virtual Btype *placeholder_pointer_type (const std::string &name, Location,\n-\t\t\t\t\t   bool for_function)\n-    = 0;\n-\n-  // Fill in a placeholder pointer type as a pointer.  This takes a\n-  // type returned by placeholder_pointer_type and arranges for it to\n-  // point to the type that TO_TYPE points to (that is, PLACEHOLDER\n-  // becomes the same type as TO_TYPE).  Returns true on success,\n-  // false on failure.\n-  virtual bool set_placeholder_pointer_type (Btype *placeholder, Btype *to_type)\n-    = 0;\n-\n-  // Fill in a placeholder pointer type as a function.  This takes a\n-  // type returned by placeholder_pointer_type and arranges for it to\n-  // become a real Go function type (which corresponds to a C/C++\n-  // pointer to function type).  FT will be something returned by the\n-  // function_type method.  Returns true on success, false on failure.\n-  virtual bool set_placeholder_function_type (Btype *placeholder, Btype *ft)\n-    = 0;\n-\n-  // Create a placeholder struct type.  This is used for a named\n-  // struct type, as with placeholder_pointer_type.  It is also used\n-  // for interface types, in which case NAME will be the empty string.\n-  virtual Btype *placeholder_struct_type (const std::string &name, Location)\n-    = 0;\n-\n-  // Fill in a placeholder struct type.  This takes a type returned by\n-  // placeholder_struct_type and arranges for it to become a real\n-  // struct type.  The parameter is as for struct_type.  Returns true\n-  // on success, false on failure.\n-  virtual bool\n-  set_placeholder_struct_type (Btype *placeholder,\n-\t\t\t       const std::vector<Btyped_identifier> &fields)\n-    = 0;\n-\n-  // Create a placeholder array type.  This is used for a named array\n-  // type, as with placeholder_pointer_type, to handle cases like\n-  // type A []*A.\n-  virtual Btype *placeholder_array_type (const std::string &name, Location) = 0;\n-\n-  // Fill in a placeholder array type.  This takes a type returned by\n-  // placeholder_array_type and arranges for it to become a real array\n-  // type.  The parameters are as for array_type.  Returns true on\n-  // success, false on failure.\n-  virtual bool set_placeholder_array_type (Btype *placeholder,\n-\t\t\t\t\t   Btype *element_type,\n-\t\t\t\t\t   Bexpression *length)\n-    = 0;\n-\n   // Return a named version of a type.  The location is the location\n   // of the type definition.  This will not be called for a type\n   // created via placeholder_pointer_type, placeholder_struct_type, or\n   // placeholder_array_type..  (It may be called for a pointer,\n   // struct, or array type in a case like \"type P *byte; type Q P\".)\n   virtual Btype *named_type (const std::string &name, Btype *, Location) = 0;\n \n-  // Create a marker for a circular pointer type.  Go pointer and\n-  // function types can refer to themselves in ways that are not\n-  // permitted in C/C++.  When a circular type is found, this function\n-  // is called for the circular reference.  This permits the backend\n-  // to decide how to handle such a type.  PLACEHOLDER is the\n-  // placeholder type which has already been created; if the backend\n-  // is prepared to handle a circular pointer type, it may simply\n-  // return PLACEHOLDER.  FOR_FUNCTION is true if this is for a\n-  // function type.\n-  //\n-  // For \"type P *P\" the sequence of calls will be\n-  //   bt1 = placeholder_pointer_type();\n-  //   bt2 = circular_pointer_type(bt1, false);\n-  //   set_placeholder_pointer_type(bt1, bt2);\n-  virtual Btype *circular_pointer_type (Btype *placeholder, bool for_function)\n-    = 0;\n-\n-  // Return whether the argument could be a special type created by\n-  // circular_pointer_type.  This is used to introduce explicit type\n-  // conversions where needed.  If circular_pointer_type returns its\n-  // PLACEHOLDER parameter, this may safely always return false.\n-  virtual bool is_circular_pointer_type (Btype *) = 0;\n-\n   // Return the size of a type.\n   virtual int64_t type_size (Btype *) = 0;\n "}, {"sha": "65fc1f3105607e9c71030d324eb7e305adb67813", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 0, "deletions": 165, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97c98deec7d4c698d7b8ee8a4e56888d5d85b8bd/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97c98deec7d4c698d7b8ee8a4e56888d5d85b8bd/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=97c98deec7d4c698d7b8ee8a4e56888d5d85b8bd", "patch": "@@ -274,27 +274,8 @@ class Gcc_backend : public Backend\n \n   Btype *array_type (Btype *, Bexpression *);\n \n-  Btype *placeholder_pointer_type (const std::string &, Location, bool);\n-\n-  bool set_placeholder_pointer_type (Btype *, Btype *);\n-\n-  bool set_placeholder_function_type (Btype *, Btype *);\n-\n-  Btype *placeholder_struct_type (const std::string &, Location);\n-\n-  bool set_placeholder_struct_type (Btype *placeholder,\n-\t\t\t\t    const std::vector<Btyped_identifier> &);\n-\n-  Btype *placeholder_array_type (const std::string &, Location);\n-\n-  bool set_placeholder_array_type (Btype *, Btype *, Bexpression *);\n-\n   Btype *named_type (const std::string &, Btype *, Location);\n \n-  Btype *circular_pointer_type (Btype *, bool);\n-\n-  bool is_circular_pointer_type (Btype *);\n-\n   int64_t type_size (Btype *);\n \n   int64_t type_alignment (Btype *);\n@@ -1222,136 +1203,6 @@ Gcc_backend::fill_in_array (Btype *fill, Btype *element_type,\n   return fill;\n }\n \n-// Create a placeholder for a pointer type.\n-\n-Btype *\n-Gcc_backend::placeholder_pointer_type (const std::string &name,\n-\t\t\t\t       Location location, bool)\n-{\n-  tree ret = build_distinct_type_copy (ptr_type_node);\n-  if (!name.empty ())\n-    {\n-      tree decl = build_decl (location.gcc_location (), TYPE_DECL,\n-\t\t\t      get_identifier_from_string (name), ret);\n-      TYPE_NAME (ret) = decl;\n-    }\n-  return this->make_type (ret);\n-}\n-\n-// Set the real target type for a placeholder pointer type.\n-\n-bool\n-Gcc_backend::set_placeholder_pointer_type (Btype *placeholder, Btype *to_type)\n-{\n-  tree pt = placeholder->get_tree ();\n-  if (pt == error_mark_node)\n-    return false;\n-  gcc_assert (TREE_CODE (pt) == POINTER_TYPE);\n-  tree tt = to_type->get_tree ();\n-  if (tt == error_mark_node)\n-    {\n-      placeholder->set_tree (error_mark_node);\n-      return false;\n-    }\n-  gcc_assert (TREE_CODE (tt) == POINTER_TYPE);\n-  TREE_TYPE (pt) = TREE_TYPE (tt);\n-  TYPE_CANONICAL (pt) = TYPE_CANONICAL (tt);\n-  if (TYPE_NAME (pt) != NULL_TREE)\n-    {\n-      // Build the data structure gcc wants to see for a typedef.\n-      tree copy = build_variant_type_copy (pt);\n-      TYPE_NAME (copy) = NULL_TREE;\n-      DECL_ORIGINAL_TYPE (TYPE_NAME (pt)) = copy;\n-    }\n-  return true;\n-}\n-\n-// Set the real values for a placeholder function type.\n-\n-bool\n-Gcc_backend::set_placeholder_function_type (Btype *placeholder, Btype *ft)\n-{\n-  return this->set_placeholder_pointer_type (placeholder, ft);\n-}\n-\n-// Create a placeholder for a struct type.\n-\n-Btype *\n-Gcc_backend::placeholder_struct_type (const std::string &name,\n-\t\t\t\t      Location location)\n-{\n-  tree ret = make_node (RECORD_TYPE);\n-  if (!name.empty ())\n-    {\n-      tree decl = build_decl (location.gcc_location (), TYPE_DECL,\n-\t\t\t      get_identifier_from_string (name), ret);\n-      TYPE_NAME (ret) = decl;\n-\n-      // The struct type that eventually replaces this placeholder will require\n-      // structural equality. The placeholder must too, so that the requirement\n-      // for structural equality propagates to references that are constructed\n-      // before the replacement occurs.\n-      SET_TYPE_STRUCTURAL_EQUALITY (ret);\n-    }\n-  return this->make_type (ret);\n-}\n-\n-// Fill in the fields of a placeholder struct type.\n-\n-bool\n-Gcc_backend::set_placeholder_struct_type (\n-  Btype *placeholder, const std::vector<Btyped_identifier> &fields)\n-{\n-  tree t = placeholder->get_tree ();\n-  gcc_assert (TREE_CODE (t) == RECORD_TYPE && TYPE_FIELDS (t) == NULL_TREE);\n-  Btype *r = this->fill_in_fields (placeholder, fields);\n-\n-  if (TYPE_NAME (t) != NULL_TREE)\n-    {\n-      // Build the data structure gcc wants to see for a typedef.\n-      tree copy = build_distinct_type_copy (t);\n-      TYPE_NAME (copy) = NULL_TREE;\n-      DECL_ORIGINAL_TYPE (TYPE_NAME (t)) = copy;\n-      TYPE_SIZE (copy) = NULL_TREE;\n-      Btype *bc = this->make_type (copy);\n-      this->fill_in_fields (bc, fields);\n-      delete bc;\n-    }\n-\n-  return r->get_tree () != error_mark_node;\n-}\n-\n-// Create a placeholder for an array type.\n-\n-Btype *\n-Gcc_backend::placeholder_array_type (const std::string &name, Location location)\n-{\n-  tree ret = make_node (ARRAY_TYPE);\n-  tree decl = build_decl (location.gcc_location (), TYPE_DECL,\n-\t\t\t  get_identifier_from_string (name), ret);\n-  TYPE_NAME (ret) = decl;\n-  return this->make_type (ret);\n-}\n-\n-// Fill in the fields of a placeholder array type.\n-\n-bool\n-Gcc_backend::set_placeholder_array_type (Btype *placeholder,\n-\t\t\t\t\t Btype *element_btype,\n-\t\t\t\t\t Bexpression *length)\n-{\n-  tree t = placeholder->get_tree ();\n-  gcc_assert (TREE_CODE (t) == ARRAY_TYPE && TREE_TYPE (t) == NULL_TREE);\n-  Btype *r = this->fill_in_array (placeholder, element_btype, length);\n-\n-  // Build the data structure gcc wants to see for a typedef.\n-  tree copy = build_distinct_type_copy (t);\n-  TYPE_NAME (copy) = NULL_TREE;\n-  DECL_ORIGINAL_TYPE (TYPE_NAME (t)) = copy;\n-\n-  return r->get_tree () != error_mark_node;\n-}\n-\n // Return a named version of a type.\n \n Btype *\n@@ -1385,22 +1236,6 @@ Gcc_backend::named_type (const std::string &name, Btype *btype,\n   return this->make_type (copy);\n }\n \n-// Return a pointer type used as a marker for a circular type.\n-\n-Btype *\n-Gcc_backend::circular_pointer_type (Btype *, bool)\n-{\n-  return this->make_type (ptr_type_node);\n-}\n-\n-// Return whether we might be looking at a circular type.\n-\n-bool\n-Gcc_backend::is_circular_pointer_type (Btype *btype)\n-{\n-  return btype->get_tree () == ptr_type_node;\n-}\n-\n // Return the size of a type.\n \n int64_t"}]}