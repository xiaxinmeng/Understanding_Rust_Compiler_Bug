{"sha": "e5ca969363516ec05db3357c22079d7fdcd70ccf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTVjYTk2OTM2MzUxNmVjMDVkYjMzNTdjMjIwNzlkN2ZkY2Q3MGNjZg==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2010-09-03T08:01:51Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2010-09-03T08:01:51Z"}, "message": "re PR fortran/44602 ([F2008] EXIT: Jump to end of construct)\n\n2010-09-03  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/44602\n\t* gfortran.h (struct gfc_code): Renamed `whichloop' to\n\t`which_construct' as this is no longer restricted to loops.\n\t* parse.h (struct gfc_state_data): New field `construct'.\n\t* match.c (match_exit_cycle): Handle EXIT from non-loops.\n\t* parse.c (push_state): Set `construct' field.\n\t* resolve.c (resolve_select_type): Extend comment.\n\t* trans-stmt.c (gfc_trans_if): Add exit label.\n\t(gfc_trans_block_construct), (gfc_trans_select): Ditto.\n\t(gfc_trans_simple_do): Store exit/cycle labels on the gfc_code itself.\n\t(gfc_trans_do), (gfc_trans_do_while): Ditto.\n\t(gfc_trans_exit): Use new name `which_construct' instead of `whichloop'.\n\t(gfc_trans_cycle): Ditto.\n\t(gfc_trans_if_1): Use fold_build3_loc instead of fold_build3.\n\n2010-09-03  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/44602\n\t* gfortran.dg/exit_2.f08; Adapt error messages.\n\t* gfortran.dg/exit_3.f08: New test.\n\t* gfortran.dg/exit_4.f08: New test.\n\t* gfortran.dg/exit_5.f03: New test.\n\nFrom-SVN: r163798", "tree": {"sha": "ab6ea012d837fff217565926dab37412151bd71e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab6ea012d837fff217565926dab37412151bd71e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5ca969363516ec05db3357c22079d7fdcd70ccf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5ca969363516ec05db3357c22079d7fdcd70ccf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5ca969363516ec05db3357c22079d7fdcd70ccf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5ca969363516ec05db3357c22079d7fdcd70ccf/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e97e08bc2e561f285dab48468b5fa0cba6a48d88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e97e08bc2e561f285dab48468b5fa0cba6a48d88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e97e08bc2e561f285dab48468b5fa0cba6a48d88"}], "stats": {"total": 340, "additions": 296, "deletions": 44}, "files": [{"sha": "7c75e503efb7699b227a404cfe21d47aba097c0d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5ca969363516ec05db3357c22079d7fdcd70ccf/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5ca969363516ec05db3357c22079d7fdcd70ccf/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=e5ca969363516ec05db3357c22079d7fdcd70ccf", "patch": "@@ -1,3 +1,20 @@\n+2010-09-03  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/44602\n+\t* gfortran.h (struct gfc_code): Renamed `whichloop' to\n+\t`which_construct' as this is no longer restricted to loops.\n+\t* parse.h (struct gfc_state_data): New field `construct'.\n+\t* match.c (match_exit_cycle): Handle EXIT from non-loops.\n+\t* parse.c (push_state): Set `construct' field.\n+\t* resolve.c (resolve_select_type): Extend comment.\n+\t* trans-stmt.c (gfc_trans_if): Add exit label.\n+\t(gfc_trans_block_construct), (gfc_trans_select): Ditto.\n+\t(gfc_trans_simple_do): Store exit/cycle labels on the gfc_code itself.\n+\t(gfc_trans_do), (gfc_trans_do_while): Ditto.\n+\t(gfc_trans_exit): Use new name `which_construct' instead of `whichloop'.\n+\t(gfc_trans_cycle): Ditto.\n+\t(gfc_trans_if_1): Use fold_build3_loc instead of fold_build3.\n+\n 2010-09-03  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \t* trans-intrinsic.c (gfc_conv_intrinsic_aint): Fix whitespace."}, {"sha": "3c15521b1a74364d392d2446bb0fddc4cee17970", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5ca969363516ec05db3357c22079d7fdcd70ccf/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5ca969363516ec05db3357c22079d7fdcd70ccf/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=e5ca969363516ec05db3357c22079d7fdcd70ccf", "patch": "@@ -2096,7 +2096,7 @@ typedef struct gfc_code\n     gfc_wait *wait;\n     gfc_dt *dt;\n     gfc_forall_iterator *forall_iterator;\n-    struct gfc_code *whichloop;\n+    struct gfc_code *which_construct;\n     int stop_code;\n     gfc_entry_list *entry;\n     gfc_omp_clauses *omp_clauses;\n@@ -2106,7 +2106,7 @@ typedef struct gfc_code\n   }\n   ext;\t\t/* Points to additional structures required by statement */\n \n-  /* Cycle and break labels in do loops.  */\n+  /* Cycle and break labels in constructs.  */\n   tree cycle_label;\n   tree exit_label;\n }"}, {"sha": "ff0ef44f64a5f623f29d448765d207e180432976", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 44, "deletions": 9, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5ca969363516ec05db3357c22079d7fdcd70ccf/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5ca969363516ec05db3357c22079d7fdcd70ccf/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=e5ca969363516ec05db3357c22079d7fdcd70ccf", "patch": "@@ -2034,37 +2034,71 @@ match_exit_cycle (gfc_statement st, gfc_exec_op op)\n       sym = stree->n.sym;\n       if (sym->attr.flavor != FL_LABEL)\n \t{\n-\t  gfc_error (\"Name '%s' in %s statement at %C is not a loop name\",\n+\t  gfc_error (\"Name '%s' in %s statement at %C is not a construct name\",\n \t\t     name, gfc_ascii_statement (st));\n \t  return MATCH_ERROR;\n \t}\n     }\n \n   /* Find the loop specified by the label (or lack of a label).  */\n   for (o = NULL, p = gfc_state_stack; p; p = p->previous)\n-    if (p->state == COMP_DO && (sym == NULL || sym == p->sym))\n-      break;\n-    else if (o == NULL && p->state == COMP_OMP_STRUCTURED_BLOCK)\n+    if (o == NULL && p->state == COMP_OMP_STRUCTURED_BLOCK)\n       o = p;\n     else if (p->state == COMP_CRITICAL)\n       {\n \tgfc_error(\"%s statement at %C leaves CRITICAL construct\",\n \t\t  gfc_ascii_statement (st));\n \treturn MATCH_ERROR;\n       }\n+    else if ((sym && sym == p->sym) || (!sym && p->state == COMP_DO))\n+      break;\n \n   if (p == NULL)\n     {\n       if (sym == NULL)\n-\tgfc_error (\"%s statement at %C is not within a loop\",\n+\tgfc_error (\"%s statement at %C is not within a construct\",\n \t\t   gfc_ascii_statement (st));\n       else\n-\tgfc_error (\"%s statement at %C is not within loop '%s'\",\n+\tgfc_error (\"%s statement at %C is not within construct '%s'\",\n \t\t   gfc_ascii_statement (st), sym->name);\n \n       return MATCH_ERROR;\n     }\n \n+  /* Special checks for EXIT from non-loop constructs.  */\n+  switch (p->state)\n+    {\n+    case COMP_DO:\n+      break;\n+\n+    case COMP_CRITICAL:\n+      /* This is already handled above.  */\n+      gcc_unreachable ();\n+\n+    case COMP_ASSOCIATE:\n+    case COMP_BLOCK:\n+    case COMP_IF:\n+    case COMP_SELECT:\n+    case COMP_SELECT_TYPE:\n+      gcc_assert (sym);\n+      if (op == EXEC_CYCLE)\n+\t{\n+\t  gfc_error (\"CYCLE statement at %C is not applicable to non-loop\"\n+\t\t     \" construct '%s'\", sym->name);\n+\t  return MATCH_ERROR;\n+\t}\n+      gcc_assert (op == EXEC_EXIT);\n+      if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: EXIT statement with no\"\n+\t\t\t  \" do-construct-name at %C\") == FAILURE)\n+\treturn MATCH_ERROR;\n+      break;\n+      \n+    default:\n+      gfc_error (\"%s statement at %C is not applicable to construct '%s'\",\n+\t\t gfc_ascii_statement (st), sym->name);\n+      return MATCH_ERROR;\n+    }\n+\n   if (o != NULL)\n     {\n       gfc_error (\"%s statement at %C leaving OpenMP structured block\",\n@@ -2096,13 +2130,14 @@ match_exit_cycle (gfc_statement st, gfc_exec_op op)\n \t}\n       if (st == ST_CYCLE && cnt < collapse)\n \t{\n-\t  gfc_error (\"CYCLE statement at %C to non-innermost collapsed !$OMP DO loop\");\n+\t  gfc_error (\"CYCLE statement at %C to non-innermost collapsed\"\n+\t\t     \" !$OMP DO loop\");\n \t  return MATCH_ERROR;\n \t}\n     }\n \n-  /* Save the first statement in the loop - needed by the backend.  */\n-  new_st.ext.whichloop = p->head;\n+  /* Save the first statement in the construct - needed by the backend.  */\n+  new_st.ext.which_construct = p->construct;\n \n   new_st.op = op;\n "}, {"sha": "4632a250294652a35a94f4bb151063f0bdfee4f8", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5ca969363516ec05db3357c22079d7fdcd70ccf/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5ca969363516ec05db3357c22079d7fdcd70ccf/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=e5ca969363516ec05db3357c22079d7fdcd70ccf", "patch": "@@ -989,6 +989,13 @@ push_state (gfc_state_data *p, gfc_compile_state new_state, gfc_symbol *sym)\n   p->sym = sym;\n   p->head = p->tail = NULL;\n   p->do_variable = NULL;\n+\n+  /* If this the state of a construct like BLOCK, DO or IF, the corresponding\n+     construct statement was accepted right before pushing the state.  Thus,\n+     the construct's gfc_code is available as tail of the parent state.  */\n+  gcc_assert (gfc_state_stack);\n+  p->construct = gfc_state_stack->tail;\n+\n   gfc_state_stack = p;\n }\n "}, {"sha": "b18056c1cd7550b00d3e23ff2c222acdc6b2849d", "filename": "gcc/fortran/parse.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5ca969363516ec05db3357c22079d7fdcd70ccf/gcc%2Ffortran%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5ca969363516ec05db3357c22079d7fdcd70ccf/gcc%2Ffortran%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.h?ref=e5ca969363516ec05db3357c22079d7fdcd70ccf", "patch": "@@ -42,6 +42,7 @@ typedef struct gfc_state_data\n   gfc_symbol *sym;              /* Block name associated with this level */\n   gfc_symtree *do_variable;     /* For DO blocks the iterator variable.  */\n \n+  struct gfc_code *construct;\n   struct gfc_code *head, *tail;\n   struct gfc_state_data *previous;\n "}, {"sha": "4b6ac1d78707e9c3c911e01a92dec52710155e5f", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5ca969363516ec05db3357c22079d7fdcd70ccf/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5ca969363516ec05db3357c22079d7fdcd70ccf/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=e5ca969363516ec05db3357c22079d7fdcd70ccf", "patch": "@@ -7688,7 +7688,10 @@ resolve_select_type (gfc_code *code)\n     return;\n \n   /* Transform SELECT TYPE statement to BLOCK and associate selector to\n-     target if present.  */\n+     target if present.  If there are any EXIT statements referring to the\n+     SELECT TYPE construct, this is no problem because the gfc_code\n+     reference stays the same and EXIT is equally possible from the BLOCK\n+     it is changed to.  */\n   code->op = EXEC_BLOCK;\n   if (code->expr2)\n     {"}, {"sha": "29b3322805899679ec1cd57a0a9eaae243c83ed5", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 78, "deletions": 29, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5ca969363516ec05db3357c22079d7fdcd70ccf/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5ca969363516ec05db3357c22079d7fdcd70ccf/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=e5ca969363516ec05db3357c22079d7fdcd70ccf", "patch": "@@ -750,10 +750,21 @@ gfc_trans_if_1 (gfc_code * code)\n tree\n gfc_trans_if (gfc_code * code)\n {\n-  /* Ignore the top EXEC_IF, it only announces an IF construct. The\n-     actual code we must translate is in code->block.  */\n+  stmtblock_t body;\n+  tree exit_label;\n+\n+  /* Create exit label so it is available for trans'ing the body code.  */\n+  exit_label = gfc_build_label_decl (NULL_TREE);\n+  code->exit_label = exit_label;\n+\n+  /* Translate the actual code in code->block.  */\n+  gfc_init_block (&body);\n+  gfc_add_expr_to_block (&body, gfc_trans_if_1 (code->block));\n+\n+  /* Add exit label.  */\n+  gfc_add_expr_to_block (&body, build1_v (LABEL_EXPR, exit_label));\n \n-  return gfc_trans_if_1 (code->block);\n+  return gfc_finish_block (&body);\n }\n \n \n@@ -860,22 +871,32 @@ gfc_trans_block_construct (gfc_code* code)\n {\n   gfc_namespace* ns;\n   gfc_symbol* sym;\n-  gfc_wrapped_block body;\n+  gfc_wrapped_block block;\n+  tree exit_label;\n+  stmtblock_t body;\n \n   ns = code->ext.block.ns;\n   gcc_assert (ns);\n   sym = ns->proc_name;\n   gcc_assert (sym);\n \n+  /* Process local variables.  */\n   gcc_assert (!sym->tlink);\n   sym->tlink = sym;\n-\n   gfc_process_block_locals (ns, code->ext.block.assoc);\n \n-  gfc_start_wrapped_block (&body, gfc_trans_code (ns->code));\n-  gfc_trans_deferred_vars (sym, &body);\n+  /* Generate code including exit-label.  */\n+  gfc_init_block (&body);\n+  exit_label = gfc_build_label_decl (NULL_TREE);\n+  code->exit_label = exit_label;\n+  gfc_add_expr_to_block (&body, gfc_trans_code (ns->code));\n+  gfc_add_expr_to_block (&body, build1_v (LABEL_EXPR, exit_label));\n+\n+  /* Finish everything.  */\n+  gfc_start_wrapped_block (&block, gfc_finish_block (&body));\n+  gfc_trans_deferred_vars (sym, &block);\n \n-  return gfc_finish_wrapped_block (&body);\n+  return gfc_finish_wrapped_block (&block);\n }\n \n \n@@ -938,8 +959,8 @@ gfc_trans_simple_do (gfc_code * code, stmtblock_t *pblock, tree dovar,\n   exit_label = gfc_build_label_decl (NULL_TREE);\n \n   /* Put the labels where they can be found later. See gfc_trans_do().  */\n-  code->block->cycle_label = cycle_label;\n-  code->block->exit_label = exit_label;\n+  code->cycle_label = cycle_label;\n+  code->exit_label = exit_label;\n \n   /* Loop body.  */\n   gfc_start_block (&body);\n@@ -1121,6 +1142,10 @@ gfc_trans_do (gfc_code * code, tree exit_cond)\n   exit_label = gfc_build_label_decl (NULL_TREE);\n   TREE_USED (exit_label) = 1;\n \n+  /* Put these labels where they can be found later.  */\n+  code->cycle_label = cycle_label;\n+  code->exit_label = exit_label;\n+\n   /* Initialize the DO variable: dovar = from.  */\n   gfc_add_modify (&block, dovar, from);\n \n@@ -1222,11 +1247,6 @@ gfc_trans_do (gfc_code * code, tree exit_cond)\n   /* Loop body.  */\n   gfc_start_block (&body);\n \n-  /* Put these labels where they can be found later.  */\n-\n-  code->block->cycle_label = cycle_label;\n-  code->block->exit_label = exit_label;\n-\n   /* Main loop body.  */\n   tmp = gfc_trans_code_cond (code->block->next, exit_cond);\n   gfc_add_expr_to_block (&body, tmp);\n@@ -1332,8 +1352,8 @@ gfc_trans_do_while (gfc_code * code)\n   exit_label = gfc_build_label_decl (NULL_TREE);\n \n   /* Put the labels where they can be found later. See gfc_trans_do().  */\n-  code->block->cycle_label = cycle_label;\n-  code->block->exit_label = exit_label;\n+  code->cycle_label = cycle_label;\n+  code->exit_label = exit_label;\n \n   /* Create a GIMPLE version of the exit condition.  */\n   gfc_init_se (&cond, NULL);\n@@ -1973,22 +1993,47 @@ gfc_trans_character_select (gfc_code *code)\n tree\n gfc_trans_select (gfc_code * code)\n {\n+  stmtblock_t block;\n+  tree body;\n+  tree exit_label;\n+\n   gcc_assert (code && code->expr1);\n+  gfc_init_block (&block);\n+\n+  /* Build the exit label and hang it in.  */\n+  exit_label = gfc_build_label_decl (NULL_TREE);\n+  code->exit_label = exit_label;\n \n   /* Empty SELECT constructs are legal.  */\n   if (code->block == NULL)\n-    return build_empty_stmt (input_location);\n+    body = build_empty_stmt (input_location);\n \n   /* Select the correct translation function.  */\n-  switch (code->expr1->ts.type)\n-    {\n-    case BT_LOGICAL:\treturn gfc_trans_logical_select (code);\n-    case BT_INTEGER:\treturn gfc_trans_integer_select (code);\n-    case BT_CHARACTER:\treturn gfc_trans_character_select (code);\n-    default:\n-      gfc_internal_error (\"gfc_trans_select(): Bad type for case expr.\");\n-      /* Not reached */\n-    }\n+  else\n+    switch (code->expr1->ts.type)\n+      {\n+      case BT_LOGICAL:\n+\tbody = gfc_trans_logical_select (code);\n+\tbreak;\n+\n+      case BT_INTEGER:\n+\tbody = gfc_trans_integer_select (code);\n+\tbreak;\n+\n+      case BT_CHARACTER:\n+\tbody = gfc_trans_character_select (code);\n+\tbreak;\n+\n+      default:\n+\tgfc_internal_error (\"gfc_trans_select(): Bad type for case expr.\");\n+\t/* Not reached */\n+      }\n+\n+  /* Build everything together.  */\n+  gfc_add_expr_to_block (&block, body);\n+  gfc_add_expr_to_block (&block, build1_v (LABEL_EXPR, exit_label));\n+\n+  return gfc_finish_block (&block);\n }\n \n \n@@ -4271,7 +4316,9 @@ gfc_trans_cycle (gfc_code * code)\n {\n   tree cycle_label;\n \n-  cycle_label = code->ext.whichloop->cycle_label;\n+  cycle_label = code->ext.which_construct->cycle_label;\n+  gcc_assert (cycle_label);\n+\n   TREE_USED (cycle_label) = 1;\n   return build1_v (GOTO_EXPR, cycle_label);\n }\n@@ -4286,7 +4333,9 @@ gfc_trans_exit (gfc_code * code)\n {\n   tree exit_label;\n \n-  exit_label = code->ext.whichloop->exit_label;\n+  exit_label = code->ext.which_construct->exit_label;\n+  gcc_assert (exit_label);\n+\n   TREE_USED (exit_label) = 1;\n   return build1_v (GOTO_EXPR, exit_label);\n }"}, {"sha": "015ce4c44087e3221b9ac86a2cfaea7758f2c7bd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5ca969363516ec05db3357c22079d7fdcd70ccf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5ca969363516ec05db3357c22079d7fdcd70ccf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e5ca969363516ec05db3357c22079d7fdcd70ccf", "patch": "@@ -1,3 +1,11 @@\n+2010-09-03  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/44602\n+\t* gfortran.dg/exit_2.f08; Adapt error messages.\n+\t* gfortran.dg/exit_3.f08: New test.\n+\t* gfortran.dg/exit_4.f08: New test.\n+\t* gfortran.dg/exit_5.f03: New test.\n+\n 2010-09-03  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \t* gfortran.dg/ishft_4.f90: New test."}, {"sha": "9b383f03bd4c1200bf55eb61ae87a6e5250b260d", "filename": "gcc/testsuite/gfortran.dg/exit_2.f08", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5ca969363516ec05db3357c22079d7fdcd70ccf/gcc%2Ftestsuite%2Fgfortran.dg%2Fexit_2.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5ca969363516ec05db3357c22079d7fdcd70ccf/gcc%2Ftestsuite%2Fgfortran.dg%2Fexit_2.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fexit_2.f08?ref=e5ca969363516ec05db3357c22079d7fdcd70ccf", "patch": "@@ -10,16 +10,16 @@\n PROGRAM main\n   IMPLICIT NONE\n   \n-  EXIT ! { dg-error \"is not within a loop\" }\n+  EXIT ! { dg-error \"is not within a construct\" }\n   EXIT foobar ! { dg-error \"is unknown\" }\n-  EXIT main ! { dg-error \"is not a loop name\" }\n+  EXIT main ! { dg-error \"is not a construct name\" }\n \n   mainLoop: DO\n     CALL test ()\n   END DO mainLoop\n \n   otherLoop: DO\n-    EXIT mainLoop ! { dg-error \"is not within loop 'mainloop'\" }\n+    EXIT mainLoop ! { dg-error \"is not within construct 'mainloop'\" }\n   END DO otherLoop\n \n CONTAINS"}, {"sha": "732497b6d3667f191320e4f1c727f338db799156", "filename": "gcc/testsuite/gfortran.dg/exit_3.f08", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5ca969363516ec05db3357c22079d7fdcd70ccf/gcc%2Ftestsuite%2Fgfortran.dg%2Fexit_3.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5ca969363516ec05db3357c22079d7fdcd70ccf/gcc%2Ftestsuite%2Fgfortran.dg%2Fexit_3.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fexit_3.f08?ref=e5ca969363516ec05db3357c22079d7fdcd70ccf", "patch": "@@ -0,0 +1,88 @@\n+! { dg-do run }\n+! { dg-options \"-std=f2008 -fall-intrinsics\" }\n+\n+! PR fortran/44602\n+! Check for correct behaviour of EXIT / CYCLE combined with non-loop\n+! constructs at run-time.\n+\n+! Contributed by Daniel Kraft, d@domob.eu.\n+\n+PROGRAM main\n+  IMPLICIT NONE\n+\n+  TYPE :: t\n+  END TYPE t\n+\n+  INTEGER :: i\n+  CLASS(t), ALLOCATABLE :: var\n+\n+  ! EXIT and CYCLE without names always refer to innermost *loop*.  This\n+  ! however is checked at run-time already in exit_1.f08.\n+\n+  ! Basic EXITs from different non-loop constructs.\n+\n+  i = 2\n+  myif: IF (i == 1) THEN\n+    CALL abort ()\n+    EXIT myif\n+  ELSE IF (i == 2) THEN\n+    EXIT myif\n+    CALL abort ()\n+  ELSE\n+    CALL abort ()\n+    EXIT myif\n+  END IF myif\n+\n+  mysel: SELECT CASE (i)\n+    CASE (1)\n+      CALL abort ()\n+      EXIT mysel\n+    CASE (2)\n+      EXIT mysel\n+      CALL abort ()\n+    CASE DEFAULT\n+      CALL abort ()\n+      EXIT mysel\n+  END SELECT mysel\n+\n+  mycharsel: SELECT CASE (\"foobar\")\n+    CASE (\"abc\")\n+      CALL abort ()\n+      EXIT mycharsel\n+    CASE (\"xyz\")\n+      CALL abort ()\n+      EXIT mycharsel\n+    CASE DEFAULT\n+      EXIT mycharsel\n+      CALL abort ()\n+  END SELECT mycharsel\n+\n+  myblock: BLOCK\n+    EXIT myblock\n+    CALL abort ()\n+  END BLOCK myblock\n+\n+  myassoc: ASSOCIATE (x => 5 + 2)\n+    EXIT myassoc\n+    CALL abort ()\n+  END ASSOCIATE myassoc\n+\n+  ALLOCATE (t :: var)\n+  mytypesel: SELECT TYPE (var)\n+    TYPE IS (t)\n+      EXIT mytypesel\n+      CALL abort ()\n+    CLASS DEFAULT\n+      CALL abort ()\n+      EXIT mytypesel\n+  END SELECT mytypesel\n+\n+  ! Check EXIT with nested constructs.\n+  outer: BLOCK\n+    inner: IF (.TRUE.) THEN\n+      EXIT outer\n+      CALL abort ()\n+    END IF inner\n+    CALL abort ()\n+  END BLOCK outer\n+END PROGRAM main"}, {"sha": "8033efc47c18bc5c283264cc740208867ab8cfc2", "filename": "gcc/testsuite/gfortran.dg/exit_4.f08", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5ca969363516ec05db3357c22079d7fdcd70ccf/gcc%2Ftestsuite%2Fgfortran.dg%2Fexit_4.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5ca969363516ec05db3357c22079d7fdcd70ccf/gcc%2Ftestsuite%2Fgfortran.dg%2Fexit_4.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fexit_4.f08?ref=e5ca969363516ec05db3357c22079d7fdcd70ccf", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2008 -fcoarray=single\" }\n+\n+! PR fortran/44602\n+! Check for compile-time errors with non-loop EXITs.\n+\n+! Contributed by Daniel Kraft, d@domob.eu.\n+\n+PROGRAM main\n+  IMPLICIT NONE\n+  INTEGER :: bar(2)\n+\n+  ! Must not exit CRITICAL.\n+  mycrit: CRITICAL\n+    EXIT mycrit ! { dg-error \"leaves CRITICAL\" }\n+  END CRITICAL mycrit\n+\n+  ! CYCLE is only allowed for loops!\n+  myblock: BLOCK\n+    CYCLE myblock ! { dg-error \"is not applicable to non-loop construct 'myblock'\" }\n+  END BLOCK myblock\n+\n+  ! Invalid construct.\n+  ! Thanks to Mikael Morin, mikael.morin@sfr.fr.\n+  baz: WHERE ([ .true., .true. ])\n+    bar = 0\n+    EXIT baz ! { dg-error \"is not applicable to construct 'baz'\" }\n+  END WHERE baz\n+END PROGRAM main"}, {"sha": "3129b47439c9fffd6b17894efdbe6d0fe37c4d71", "filename": "gcc/testsuite/gfortran.dg/exit_5.f03", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5ca969363516ec05db3357c22079d7fdcd70ccf/gcc%2Ftestsuite%2Fgfortran.dg%2Fexit_5.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5ca969363516ec05db3357c22079d7fdcd70ccf/gcc%2Ftestsuite%2Fgfortran.dg%2Fexit_5.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fexit_5.f03?ref=e5ca969363516ec05db3357c22079d7fdcd70ccf", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2003\" }\n+\n+! PR fortran/44602\n+! Check for F2008 rejection of non-loop EXIT.\n+\n+! Contributed by Daniel Kraft, d@domob.eu.\n+\n+PROGRAM main\n+  IMPLICIT NONE\n+\n+  myname: IF (.TRUE.) THEN\n+    EXIT myname ! { dg-error \"Fortran 2008\" }\n+  END IF myname\n+END PROGRAM main"}]}