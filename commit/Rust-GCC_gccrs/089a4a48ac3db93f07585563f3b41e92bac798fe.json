{"sha": "089a4a48ac3db93f07585563f3b41e92bac798fe", "node_id": "C_kwDOANBUbNoAKDA4OWE0YTQ4YWMzZGI5M2YwNzU4NTU2M2YzYjQxZTkyYmFjNzk4ZmU", "commit": {"author": {"name": "Julien Bortolussi", "email": "bortolussi@adacore.com", "date": "2022-05-04T15:45:34Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-07-04T07:45:51Z"}, "message": "[Ada] Create new unbounded functional sequence\n\nAdd a new unbounded functional sequence. This sequence is indexed by\nBig_Positive and so is unbounded from the user and spark points view.\nHower the actually implemented sequence are bounded by Count_Type'Last.\n\ngcc/ada/\n\n\t* libgnat/a-cfinse.adb, libgnat/a-cfinse.ads: Implementation\n\tfiles of the sequence.\n\t* Makefile.rtl, impunit.adb: Take into account the add of the\n\tnew files", "tree": {"sha": "f64d6171a8b4ee879bde8decc813d6a9d871292d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f64d6171a8b4ee879bde8decc813d6a9d871292d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/089a4a48ac3db93f07585563f3b41e92bac798fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/089a4a48ac3db93f07585563f3b41e92bac798fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/089a4a48ac3db93f07585563f3b41e92bac798fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/089a4a48ac3db93f07585563f3b41e92bac798fe/comments", "author": {"login": "JulienBortolussiAda", "id": 103429088, "node_id": "U_kgDOBioz4A", "avatar_url": "https://avatars.githubusercontent.com/u/103429088?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JulienBortolussiAda", "html_url": "https://github.com/JulienBortolussiAda", "followers_url": "https://api.github.com/users/JulienBortolussiAda/followers", "following_url": "https://api.github.com/users/JulienBortolussiAda/following{/other_user}", "gists_url": "https://api.github.com/users/JulienBortolussiAda/gists{/gist_id}", "starred_url": "https://api.github.com/users/JulienBortolussiAda/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JulienBortolussiAda/subscriptions", "organizations_url": "https://api.github.com/users/JulienBortolussiAda/orgs", "repos_url": "https://api.github.com/users/JulienBortolussiAda/repos", "events_url": "https://api.github.com/users/JulienBortolussiAda/events{/privacy}", "received_events_url": "https://api.github.com/users/JulienBortolussiAda/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad7ed87a43655162cbd5765445681870aa99a3a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad7ed87a43655162cbd5765445681870aa99a3a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad7ed87a43655162cbd5765445681870aa99a3a8"}], "stats": {"total": 683, "additions": 683, "deletions": 0}, "files": [{"sha": "09395d35a61d0f8d94136af486911732d60a96c4", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089a4a48ac3db93f07585563f3b41e92bac798fe/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089a4a48ac3db93f07585563f3b41e92bac798fe/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=089a4a48ac3db93f07585563f3b41e92bac798fe", "patch": "@@ -114,6 +114,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-cfhama$(objext) \\\n   a-cfhase$(objext) \\\n   a-cfinve$(objext) \\\n+  a-cfinse$(objext) \\\n   a-cforma$(objext) \\\n   a-cforse$(objext) \\\n   a-cgaaso$(objext) \\"}, {"sha": "b6a7bdee510c8ded1d452735e6404090bb1ef3dc", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089a4a48ac3db93f07585563f3b41e92bac798fe/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089a4a48ac3db93f07585563f3b41e92bac798fe/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=089a4a48ac3db93f07585563f3b41e92bac798fe", "patch": "@@ -605,6 +605,7 @@ package body Impunit is\n    -- GNAT Defined Additions to Ada 2012 --\n    ----------------------------------------\n \n+    (\"a-cfinse\", F),  -- Ada.Containers.Functional_Infinite_Sequences\n     (\"a-cfinve\", F),  -- Ada.Containers.Formal_Indefinite_Vectors\n     (\"a-coboho\", F),  -- Ada.Containers.Bounded_Holders\n     (\"a-cofove\", F),  -- Ada.Containers.Formal_Vectors"}, {"sha": "7b457f6fb9f57a06e625b6a72b6c7494a0ce656b", "filename": "gcc/ada/libgnat/a-cfinse.adb", "status": "added", "additions": 304, "deletions": 0, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089a4a48ac3db93f07585563f3b41e92bac798fe/gcc%2Fada%2Flibgnat%2Fa-cfinse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089a4a48ac3db93f07585563f3b41e92bac798fe/gcc%2Fada%2Flibgnat%2Fa-cfinse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfinse.adb?ref=089a4a48ac3db93f07585563f3b41e92bac798fe", "patch": "@@ -0,0 +1,304 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                ADA.CONTAINERS.FUNCTIONAL_INFINITE_SEQUENCE               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2022-2022, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Ada_2012;\n+\n+package body Ada.Containers.Functional_Infinite_Sequences\n+with SPARK_Mode => Off\n+is\n+   use Containers;\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   package Big_From_Count is new Signed_Conversions\n+     (Int => Count_Type);\n+\n+   function Big (C : Count_Type) return Big_Integer renames\n+     Big_From_Count.To_Big_Integer;\n+\n+   --  Store Count_Type'Last as a Big Natural because it is often used\n+\n+   Count_Type_Big_Last : constant Big_Natural := Big (Count_Type'Last);\n+\n+   function To_Count (C : Big_Natural) return Count_Type;\n+   --  Convert Big_Natural to Count_Type\n+\n+   ---------\n+   -- \"<\" --\n+   ---------\n+\n+   function \"<\" (Left : Sequence; Right : Sequence) return Boolean is\n+     (Length (Left) < Length (Right)\n+      and then (for all N in Left =>\n+                     Get (Left, N) = Get (Right, N)));\n+\n+   ----------\n+   -- \"<=\" --\n+   ----------\n+\n+   function \"<=\" (Left : Sequence; Right : Sequence) return Boolean is\n+     (Length (Left) <= Length (Right)\n+      and then (for all N in Left =>\n+                     Get (Left, N) = Get (Right, N)));\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (Left : Sequence; Right : Sequence) return Boolean is\n+     (Left.Content = Right.Content);\n+\n+   ---------\n+   -- Add --\n+   ---------\n+\n+   function Add (Container : Sequence; New_Item : Element_Type) return Sequence\n+   is\n+     (Add (Container, Last (Container) + 1, New_Item));\n+\n+   function Add\n+     (Container : Sequence;\n+      Position  : Big_Positive;\n+      New_Item  : Element_Type) return Sequence is\n+     (Content => Add (Container.Content, To_Count (Position), New_Item));\n+\n+   --------------------\n+   -- Constant_Range --\n+   --------------------\n+\n+   function Constant_Range\n+     (Container : Sequence;\n+      Fst       : Big_Positive;\n+      Lst       : Big_Natural;\n+      Item      : Element_Type) return Boolean\n+   is\n+      Count_Fst : constant Count_Type := To_Count (Fst);\n+      Count_Lst : constant Count_Type := To_Count (Lst);\n+\n+   begin\n+      for J in Count_Fst .. Count_Lst loop\n+         if Get (Container.Content, J) /= Item then\n+            return False;\n+         end if;\n+      end loop;\n+\n+      return True;\n+   end Constant_Range;\n+\n+   --------------\n+   -- Contains --\n+   --------------\n+\n+   function Contains\n+     (Container : Sequence;\n+      Fst       : Big_Positive;\n+      Lst       : Big_Natural;\n+      Item      : Element_Type) return Boolean\n+   is\n+      Count_Fst : constant Count_Type := To_Count (Fst);\n+      Count_Lst : constant Count_Type := To_Count (Lst);\n+\n+   begin\n+      for J in Count_Fst .. Count_Lst loop\n+         if Get (Container.Content, J) = Item then\n+            return True;\n+         end if;\n+      end loop;\n+\n+      return False;\n+   end Contains;\n+\n+   --------------------\n+   -- Empty_Sequence --\n+   --------------------\n+\n+   function Empty_Sequence return Sequence is\n+      (Content => <>);\n+\n+   ------------------\n+   -- Equal_Except --\n+   ------------------\n+\n+   function Equal_Except\n+     (Left     : Sequence;\n+      Right    : Sequence;\n+      Position : Big_Positive) return Boolean\n+   is\n+      Count_Pos : constant Count_Type := To_Count (Position);\n+      Count_Lst : constant Count_Type := To_Count (Last (Left));\n+\n+   begin\n+      if Length (Left) /= Length (Right) then\n+         return False;\n+      end if;\n+\n+      for J in 1 .. Count_Lst loop\n+         if J /= Count_Pos\n+              and then Get (Left.Content, J) /= Get (Right.Content, J)\n+         then\n+            return False;\n+         end if;\n+      end loop;\n+\n+      return True;\n+   end Equal_Except;\n+\n+   function Equal_Except\n+     (Left  : Sequence;\n+      Right : Sequence;\n+      X     : Big_Positive;\n+      Y     : Big_Positive) return Boolean\n+   is\n+      Count_X   : constant Count_Type := To_Count (X);\n+      Count_Y   : constant Count_Type := To_Count (Y);\n+      Count_Lst : constant Count_Type := To_Count (Last (Left));\n+\n+   begin\n+      if Length (Left) /= Length (Right) then\n+         return False;\n+      end if;\n+\n+      for J in 1 .. Count_Lst loop\n+         if J /= Count_X\n+              and then J /= Count_Y\n+              and then Get (Left.Content, J) /= Get (Right.Content, J)\n+         then\n+            return False;\n+         end if;\n+      end loop;\n+\n+      return True;\n+   end Equal_Except;\n+\n+   ---------\n+   -- Get --\n+   ---------\n+\n+   function Get\n+     (Container : Sequence;\n+      Position  : Big_Integer) return Element_Type is\n+     (Get (Container.Content, To_Count (Position)));\n+\n+   ----------\n+   -- Last --\n+   ----------\n+\n+   function Last (Container : Sequence) return Big_Natural is\n+      (Length (Container));\n+\n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (Container : Sequence) return Big_Natural is\n+     (Big (Length (Container.Content)));\n+\n+   -----------------\n+   -- Range_Equal --\n+   -----------------\n+\n+   function Range_Equal\n+     (Left  : Sequence;\n+      Right : Sequence;\n+      Fst   : Big_Positive;\n+      Lst   : Big_Natural) return Boolean\n+   is\n+      Count_Fst : constant Count_Type := To_Count (Fst);\n+      Count_Lst : constant Count_Type := To_Count (Lst);\n+\n+   begin\n+      for J in Count_Fst .. Count_Lst loop\n+         if Get (Left.Content, J) /= Get (Right.Content, J) then\n+            return False;\n+         end if;\n+      end loop;\n+\n+      return True;\n+   end Range_Equal;\n+\n+   -------------------\n+   -- Range_Shifted --\n+   -------------------\n+\n+   function Range_Shifted\n+     (Left   : Sequence;\n+      Right  : Sequence;\n+      Fst    : Big_Positive;\n+      Lst    : Big_Natural;\n+      Offset : Big_Integer) return Boolean\n+   is\n+      Count_Fst : constant Count_Type := To_Count (Fst);\n+      Count_Lst : constant Count_Type := To_Count (Lst);\n+\n+   begin\n+      for J in Count_Fst .. Count_Lst loop\n+         if Get (Left.Content, J) /= Get (Right, Big (J) + Offset) then\n+            return False;\n+         end if;\n+      end loop;\n+\n+      return True;\n+   end Range_Shifted;\n+\n+   ------------\n+   -- Remove --\n+   ------------\n+\n+   function Remove\n+     (Container : Sequence;\n+      Position : Big_Positive) return Sequence is\n+     (Content => Remove (Container.Content, To_Count (Position)));\n+\n+   ---------\n+   -- Set --\n+   ---------\n+\n+   function Set\n+     (Container : Sequence;\n+      Position  : Big_Positive;\n+      New_Item  : Element_Type) return Sequence is\n+     (Content => Set (Container.Content, To_Count (Position), New_Item));\n+\n+   --------------\n+   -- To_Count --\n+   --------------\n+\n+   function To_Count (C : Big_Natural) return Count_Type is\n+   begin\n+      if C > Count_Type_Big_Last then\n+         raise Program_Error with \"Big_Integer too large for Count_Type\";\n+      end if;\n+      return Big_From_Count.From_Big_Integer (C);\n+   end To_Count;\n+\n+end Ada.Containers.Functional_Infinite_Sequences;"}, {"sha": "cff2900e71f83bf42b139ff324f069dc7c8aec97", "filename": "gcc/ada/libgnat/a-cfinse.ads", "status": "added", "additions": 377, "deletions": 0, "changes": 377, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089a4a48ac3db93f07585563f3b41e92bac798fe/gcc%2Fada%2Flibgnat%2Fa-cfinse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089a4a48ac3db93f07585563f3b41e92bac798fe/gcc%2Fada%2Flibgnat%2Fa-cfinse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfinse.ads?ref=089a4a48ac3db93f07585563f3b41e92bac798fe", "patch": "@@ -0,0 +1,377 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                ADA.CONTAINERS.FUNCTIONAL_INFINITE_SEQUENCE               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2022-2022, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Ada_2012;\n+private with Ada.Containers.Functional_Base;\n+with Ada.Numerics.Big_Numbers.Big_Integers;\n+use Ada.Numerics.Big_Numbers.Big_Integers;\n+\n+generic\n+   type Element_Type (<>) is private;\n+   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+\n+package Ada.Containers.Functional_Infinite_Sequences with SPARK_Mode is\n+\n+   type Sequence is private\n+     with Default_Initial_Condition => Length (Sequence) = 0,\n+     Iterable => (First       => Iter_First,\n+                  Has_Element => Iter_Has_Element,\n+                  Next        => Iter_Next,\n+                  Element     => Get);\n+   --  Sequences are empty when default initialized.\n+   --  Quantification over sequences can be done using the regular\n+   --  quantification over its range or directly on its elements with \"for of\".\n+\n+   -----------------------\n+   --  Basic operations --\n+   -----------------------\n+\n+   --  Sequences are axiomatized using Length and Get, providing respectively\n+   --  the length of a sequence and an accessor to its Nth element:\n+\n+   function Length (Container : Sequence) return Big_Natural with\n+   --  Length of a sequence\n+\n+     Global => null;\n+\n+   function Get\n+     (Container : Sequence;\n+      Position  : Big_Integer) return Element_Type\n+   --  Access the Element at position Position in Container\n+\n+   with\n+     Global => null,\n+     Pre    => Iter_Has_Element (Container, Position);\n+\n+   function Last (Container : Sequence) return Big_Natural with\n+   --  Last index of a sequence\n+\n+     Global => null,\n+     Post =>\n+       Last'Result = Length (Container);\n+   pragma Annotate (GNATprove, Inline_For_Proof, Last);\n+\n+   function First return Big_Positive is (1) with\n+   --  First index of a sequence\n+\n+     Global => null;\n+\n+   ------------------------\n+   -- Property Functions --\n+   ------------------------\n+\n+   function \"=\" (Left : Sequence; Right : Sequence) return Boolean with\n+   --  Extensional equality over sequences\n+\n+     Global => null,\n+     Post   =>\n+       \"=\"'Result =\n+         (Length (Left) = Length (Right)\n+           and then (for all N in Left => Get (Left, N) = Get (Right, N)));\n+   pragma Annotate (GNATprove, Inline_For_Proof, \"=\");\n+\n+   function \"<\" (Left : Sequence; Right : Sequence) return Boolean with\n+   --  Left is a strict subsequence of Right\n+\n+     Global => null,\n+     Post   =>\n+       \"<\"'Result =\n+         (Length (Left) < Length (Right)\n+           and then (for all N in Left => Get (Left, N) = Get (Right, N)));\n+   pragma Annotate (GNATprove, Inline_For_Proof, \"<\");\n+\n+   function \"<=\" (Left : Sequence; Right : Sequence) return Boolean with\n+   --  Left is a subsequence of Right\n+\n+     Global => null,\n+     Post   =>\n+       \"<=\"'Result =\n+         (Length (Left) <= Length (Right)\n+           and then (for all N in Left => Get (Left, N) = Get (Right, N)));\n+   pragma Annotate (GNATprove, Inline_For_Proof, \"<=\");\n+\n+   function Contains\n+     (Container : Sequence;\n+      Fst       : Big_Positive;\n+      Lst       : Big_Natural;\n+      Item      : Element_Type) return Boolean\n+   --  Returns True if Item occurs in the range from Fst to Lst of Container\n+\n+   with\n+     Global => null,\n+     Pre    => Lst <= Last (Container),\n+     Post   =>\n+       Contains'Result =\n+           (for some J in Container =>\n+              Fst <= J and J <= Lst and Get (Container, J) = Item);\n+   pragma Annotate (GNATprove, Inline_For_Proof, Contains);\n+\n+   function Constant_Range\n+     (Container : Sequence;\n+      Fst       : Big_Positive;\n+      Lst       : Big_Natural;\n+      Item      : Element_Type) return Boolean\n+   --  Returns True if every element of the range from Fst to Lst of Container\n+   --  is equal to Item.\n+\n+   with\n+     Global => null,\n+     Pre    => Lst <= Last (Container),\n+     Post   =>\n+       Constant_Range'Result =\n+           (for all J in Container =>\n+              (if Fst <= J and J <= Lst then Get (Container, J) = Item));\n+   pragma Annotate (GNATprove, Inline_For_Proof, Constant_Range);\n+\n+   function Equal_Except\n+     (Left     : Sequence;\n+      Right    : Sequence;\n+      Position : Big_Positive) return Boolean\n+   --  Returns True is Left and Right are the same except at position Position\n+\n+   with\n+     Global => null,\n+     Pre    => Position <= Last (Left),\n+     Post   =>\n+       Equal_Except'Result =\n+         (Length (Left) = Length (Right)\n+           and then (for all J in Left =>\n+                       (if J /= Position then\n+                          Get (Left, J) = Get (Right, J))));\n+   pragma Annotate (GNATprove, Inline_For_Proof, Equal_Except);\n+\n+   function Equal_Except\n+     (Left  : Sequence;\n+      Right : Sequence;\n+      X     : Big_Positive;\n+      Y     : Big_Positive) return Boolean\n+   --  Returns True is Left and Right are the same except at positions X and Y\n+\n+   with\n+     Global => null,\n+     Pre    => X <= Last (Left) and Y <= Last (Left),\n+     Post   =>\n+       Equal_Except'Result =\n+         (Length (Left) = Length (Right)\n+           and then (for all J in Left =>\n+                       (if J /= X and J /= Y then\n+                          Get (Left, J) = Get (Right, J))));\n+   pragma Annotate (GNATprove, Inline_For_Proof, Equal_Except);\n+\n+   function Range_Equal\n+     (Left  : Sequence;\n+      Right : Sequence;\n+      Fst   : Big_Positive;\n+      Lst   : Big_Natural) return Boolean\n+   --  Returns True if the ranges from Fst to Lst contain the same elements in\n+   --  Left and Right.\n+\n+   with\n+     Global => null,\n+     Pre    => Lst <= Last (Left) and Lst <= Last (Right),\n+     Post   =>\n+       Range_Equal'Result =\n+         (for all J in Left =>\n+            (if Fst <= J and J <= Lst then Get (Left, J) = Get (Right, J)));\n+   pragma Annotate (GNATprove, Inline_For_Proof, Range_Equal);\n+\n+   function Range_Shifted\n+     (Left   : Sequence;\n+      Right  : Sequence;\n+      Fst    : Big_Positive;\n+      Lst    : Big_Natural;\n+      Offset : Big_Integer) return Boolean\n+   --  Returns True if the range from Fst to Lst in Left contains the same\n+   --  elements as the range from Fst + Offset to Lst + Offset in Right.\n+\n+   with\n+     Global => null,\n+     Pre    =>\n+       Lst <= Last (Left)\n+         and then\n+           (if Fst <= Lst then\n+              Offset + Fst >= 1 and Offset + Lst <= Length (Right)),\n+     Post   =>\n+       Range_Shifted'Result =\n+         ((for all J in Left =>\n+             (if Fst <= J and J <= Lst then\n+                Get (Left, J) = Get (Right, J + Offset)))\n+          and\n+            (for all J in Right =>\n+               (if Fst + Offset <= J and J <= Lst + Offset then\n+                  Get (Left, J - Offset) = Get (Right, J))));\n+   pragma Annotate (GNATprove, Inline_For_Proof, Range_Shifted);\n+\n+   ----------------------------\n+   -- Construction Functions --\n+   ----------------------------\n+\n+   --  For better efficiency of both proofs and execution, avoid using\n+   --  construction functions in annotations and rather use property functions.\n+\n+   function Set\n+     (Container : Sequence;\n+      Position  : Big_Positive;\n+      New_Item  : Element_Type) return Sequence\n+   --  Returns a new sequence which contains the same elements as Container\n+   --  except for the one at position Position which is replaced by New_Item.\n+\n+   with\n+     Global => null,\n+     Pre    => Position <= Last (Container),\n+     Post   =>\n+       Get (Set'Result, Position) = New_Item\n+         and then Equal_Except (Container, Set'Result, Position);\n+\n+   function Add (Container : Sequence; New_Item : Element_Type) return Sequence\n+   --  Returns a new sequence which contains the same elements as Container\n+   --  plus New_Item at the end.\n+\n+   with\n+     Global => null,\n+     Post   =>\n+       Length (Add'Result) = Length (Container) + 1\n+         and then Get (Add'Result, Last (Add'Result)) = New_Item\n+         and then Container <= Add'Result;\n+\n+   function Add\n+     (Container : Sequence;\n+      Position  : Big_Positive;\n+      New_Item  : Element_Type) return Sequence\n+   with\n+   --  Returns a new sequence which contains the same elements as Container\n+   --  except that New_Item has been inserted at position Position.\n+\n+     Global => null,\n+     Pre    => Position <= Last (Container) + 1,\n+     Post   =>\n+       Length (Add'Result) = Length (Container) + 1\n+         and then Get (Add'Result, Position) = New_Item\n+         and then Range_Equal\n+                    (Left  => Container,\n+                     Right => Add'Result,\n+                     Fst   => 1,\n+                     Lst   => Position - 1)\n+         and then Range_Shifted\n+                    (Left   => Container,\n+                     Right  => Add'Result,\n+                     Fst    => Position,\n+                     Lst    => Last (Container),\n+                     Offset => 1);\n+\n+   function Remove\n+     (Container : Sequence;\n+      Position : Big_Positive) return Sequence\n+   --  Returns a new sequence which contains the same elements as Container\n+   --  except that the element at position Position has been removed.\n+\n+   with\n+     Global => null,\n+     Pre    => Position <= Last (Container),\n+     Post   =>\n+       Length (Remove'Result) = Length (Container) - 1\n+         and then Range_Equal\n+                    (Left  => Container,\n+                     Right => Remove'Result,\n+                     Fst   => 1,\n+                     Lst   => Position - 1)\n+         and then Range_Shifted\n+                    (Left   => Remove'Result,\n+                     Right  => Container,\n+                     Fst    => Position,\n+                     Lst    => Last (Remove'Result),\n+                     Offset => 1);\n+\n+   function Copy_Element (Item : Element_Type) return Element_Type is (Item);\n+   --  Elements of containers are copied by numerous primitives in this\n+   --  package. This function causes GNATprove to verify that such a copy is\n+   --  valid (in particular, it does not break the ownership policy of SPARK,\n+   --  i.e. it does not contain pointers that could be used to alias mutable\n+   --  data).\n+\n+   function Empty_Sequence return Sequence with\n+   --  Return an empty Sequence\n+\n+     Global => null,\n+     Post   => Length (Empty_Sequence'Result) = 0;\n+\n+   ---------------------------\n+   --  Iteration Primitives --\n+   ---------------------------\n+\n+   function Iter_First (Container : Sequence) return Big_Integer with\n+     Global => null,\n+     Post   => Iter_First'Result = 1;\n+\n+   function Iter_Has_Element\n+     (Container : Sequence;\n+      Position  : Big_Integer) return Boolean\n+   with\n+     Global => null,\n+       Post   => Iter_Has_Element'Result =\n+                   In_Range (Position, 1, Length (Container));\n+   pragma Annotate (GNATprove, Inline_For_Proof, Iter_Has_Element);\n+\n+   function Iter_Next\n+     (Container : Sequence;\n+      Position  : Big_Integer) return Big_Integer\n+   with\n+     Global => null,\n+     Pre    => Iter_Has_Element (Container, Position),\n+     Post   => Iter_Next'Result = Position + 1;\n+\n+private\n+   pragma SPARK_Mode (Off);\n+\n+   subtype Positive_Count_Type is Count_Type range 1 .. Count_Type'Last;\n+\n+   package Containers is new Ada.Containers.Functional_Base\n+     (Index_Type   => Positive_Count_Type,\n+      Element_Type => Element_Type);\n+\n+   type Sequence is record\n+      Content : Containers.Container;\n+   end record;\n+\n+   function Iter_First (Container : Sequence) return Big_Integer is (1);\n+\n+   function Iter_Next\n+     (Container : Sequence;\n+      Position  : Big_Integer) return Big_Integer\n+   is\n+     (Position + 1);\n+\n+   function Iter_Has_Element\n+     (Container : Sequence;\n+      Position  : Big_Integer) return Boolean\n+   is\n+     (In_Range (Position, 1, Length (Container)));\n+end Ada.Containers.Functional_Infinite_Sequences;"}]}