{"sha": "e589ede6fdc3f0f3f70be950bdd85d996eb19eca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU4OWVkZTZmZGMzZjBmM2Y3MGJlOTUwYmRkODVkOTk2ZWIxOWVjYQ==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-03-02T14:01:40Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-03-02T14:01:40Z"}, "message": "2003-03-02  Michael Koch  <konqueror@gmx.de>\n\n\t* java/awt/Component.java\n\t(eventTypeEnabled): New method.\n\t(dispatchEventImpl): Moved checks for event to eventTypeEnabled.\n\t* java/awt/Container.java\n\t(changeSupport): New member variable.\n\t(addPropertyChangeListener): New methods.\n\t* java/awt/ContainerOrderFocusTraversalPolicy.java\n\t(ContainerOrderFocusTraversalPolicy): Added comment.\n\t(getComponentAfter): Throw exception, documentation added.\n\t(getComponentBefore): Throw exception, documentation added.\n\t(getFirstComponent): Throw exception, documentation added.\n\t(getLastComponent): Throw exception, documentation added.\n\t(getDefaultComponent): Throw exception, documentation added.\n\t* java/awt/EventQueue.java: Reindented.\n\t* java/awt/FocusTraversalPolicy.java:\n\t(FocusTraversalPolicy): Added comment.\n\t(getComponentAfter): Documentation added.\n\t(getComponentBefore): Documentation added.\n\t(getFirstComponent): Documentation added.\n\t(getLastComponent): Documentation added.\n\t(getDefaultComponent): Documentation added.\n\t(getInitialComponent): Documentation added.\n\t* java/awt/ScrollPane.java\n\t(wheelScrollingEnabled): New member variable.\n\t(ScrollPane): Initialize wheelScollingEnabled.\n\t(eventTypeEnabled): New method.\n\t(isWheelScrollingEnabled): New method.\n\t(setWheelScrollingEnabled): New method.\n\nFrom-SVN: r63663", "tree": {"sha": "9009d19b2288a0d97ad1295a9a9cf0e04c193766", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9009d19b2288a0d97ad1295a9a9cf0e04c193766"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e589ede6fdc3f0f3f70be950bdd85d996eb19eca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e589ede6fdc3f0f3f70be950bdd85d996eb19eca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e589ede6fdc3f0f3f70be950bdd85d996eb19eca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e589ede6fdc3f0f3f70be950bdd85d996eb19eca/comments", "author": null, "committer": null, "parents": [{"sha": "37db829b936aa6483eff60a7522e34ad6dcecb79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37db829b936aa6483eff60a7522e34ad6dcecb79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37db829b936aa6483eff60a7522e34ad6dcecb79"}], "stats": {"total": 358, "additions": 258, "deletions": 100}, "files": [{"sha": "6ac880bc938ede2f075a139bbbaf0c0418c67016", "filename": "libjava/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e589ede6fdc3f0f3f70be950bdd85d996eb19eca/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e589ede6fdc3f0f3f70be950bdd85d996eb19eca/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=e589ede6fdc3f0f3f70be950bdd85d996eb19eca", "patch": "@@ -1,3 +1,34 @@\n+2003-03-02  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/awt/Component.java\n+\t(eventTypeEnabled): New method.\n+\t(dispatchEventImpl): Moved checks for event to eventTypeEnabled.\n+\t* java/awt/Container.java\n+\t(changeSupport): New member variable.\n+\t(addPropertyChangeListener): New methods.\n+\t* java/awt/ContainerOrderFocusTraversalPolicy.java\n+\t(ContainerOrderFocusTraversalPolicy): Added comment.\n+\t(getComponentAfter): Throw exception, documentation added.\n+\t(getComponentBefore): Throw exception, documentation added.\n+\t(getFirstComponent): Throw exception, documentation added.\n+\t(getLastComponent): Throw exception, documentation added.\n+\t(getDefaultComponent): Throw exception, documentation added.\n+\t* java/awt/EventQueue.java: Reindented.\n+\t* java/awt/FocusTraversalPolicy.java:\n+\t(FocusTraversalPolicy): Added comment.\n+\t(getComponentAfter): Documentation added.\n+\t(getComponentBefore): Documentation added.\n+\t(getFirstComponent): Documentation added.\n+\t(getLastComponent): Documentation added.\n+\t(getDefaultComponent): Documentation added.\n+\t(getInitialComponent): Documentation added.\n+\t* java/awt/ScrollPane.java\n+\t(wheelScrollingEnabled): New member variable.\n+\t(ScrollPane): Initialize wheelScollingEnabled.\n+\t(eventTypeEnabled): New method.\n+\t(isWheelScrollingEnabled): New method.\n+\t(setWheelScrollingEnabled): New method.\n+\n 2003-03-02  Michael Koch  <konqueror@gmx.de>\n \n \t* java/net/DatagramSocket.java"}, {"sha": "c9afaa14bf35d4aee8a5c7029cf45588582077b4", "filename": "libjava/java/awt/Component.java", "status": "modified", "additions": 52, "deletions": 36, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e589ede6fdc3f0f3f70be950bdd85d996eb19eca/libjava%2Fjava%2Fawt%2FComponent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e589ede6fdc3f0f3f70be950bdd85d996eb19eca/libjava%2Fjava%2Fawt%2FComponent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FComponent.java?ref=e589ede6fdc3f0f3f70be950bdd85d996eb19eca", "patch": "@@ -4075,45 +4075,61 @@ GraphicsConfiguration getGraphicsConfigurationImpl()\n    */\n   void dispatchEventImpl(AWTEvent e)\n   {\n-    // Make use of event id's in order to avoid multiple instanceof tests.\n-    if (e.id <= ComponentEvent.COMPONENT_LAST\n-        && e.id >= ComponentEvent.COMPONENT_FIRST\n-        && (componentListener != null\n-            || (eventMask & AWTEvent.COMPONENT_EVENT_MASK) != 0))\n-      processEvent(e);\n-    else if (e.id <= KeyEvent.KEY_LAST\n-             && e.id >= KeyEvent.KEY_FIRST\n-             && (keyListener != null\n-                 || (eventMask & AWTEvent.KEY_EVENT_MASK) != 0))\n-      processEvent(e);\n-    else if (e.id <= MouseEvent.MOUSE_LAST\n-             && e.id >= MouseEvent.MOUSE_FIRST\n-             && (mouseListener != null\n-                 || mouseMotionListener != null\n-                 || (eventMask & AWTEvent.MOUSE_EVENT_MASK) != 0))\n-      processEvent(e);\n-    else if (e.id <= FocusEvent.FOCUS_LAST\n-             && e.id >= FocusEvent.FOCUS_FIRST\n-             && (focusListener != null\n-                 || (eventMask & AWTEvent.FOCUS_EVENT_MASK) != 0))\n-      processEvent(e);\n-    else if (e.id <= InputMethodEvent.INPUT_METHOD_LAST\n-             && e.id >= InputMethodEvent.INPUT_METHOD_FIRST\n-             && (inputMethodListener != null\n-                 || (eventMask & AWTEvent.INPUT_METHOD_EVENT_MASK) != 0))\n-      processEvent(e);\n-    else if (e.id <= HierarchyEvent.HIERARCHY_LAST\n-             && e.id >= HierarchyEvent.HIERARCHY_FIRST\n-             && (hierarchyListener != null\n-                 || hierarchyBoundsListener != null\n-                 || (eventMask & AWTEvent.HIERARCHY_EVENT_MASK) != 0))\n-      processEvent(e);\n-    else if (e.id <= PaintEvent.PAINT_LAST\n-             && e.id >= PaintEvent.PAINT_FIRST\n-             && (eventMask & AWTEvent.PAINT_EVENT_MASK) != 0)\n+    if (eventTypeEnabled (e.id))\n       processEvent(e);\n   }\n \n+  /**\n+   * Tells wether or not an event type is enabled.\n+   */\n+  boolean eventTypeEnabled (int type)\n+  {\n+    if (type > AWTEvent.RESERVED_ID_MAX)\n+      return true;\n+\n+    switch (type)\n+      {\n+      case ComponentEvent.COMPONENT_HIDDEN:\n+      case ComponentEvent.COMPONENT_MOVED:\n+      case ComponentEvent.COMPONENT_RESIZED:\n+      case ComponentEvent.COMPONENT_SHOWN:\n+        return (componentListener != null\n+                || (eventMask & AWTEvent.COMPONENT_EVENT_MASK) != 0);\n+\n+      case KeyEvent.KEY_PRESSED:\n+      case KeyEvent.KEY_RELEASED:\n+      case KeyEvent.KEY_TYPED:\n+        return (keyListener != null\n+                || (eventMask & AWTEvent.KEY_EVENT_MASK) != 0);\n+\n+      case MouseEvent.MOUSE_CLICKED:\n+      case MouseEvent.MOUSE_ENTERED:\n+      case MouseEvent.MOUSE_EXITED:\n+      case MouseEvent.MOUSE_PRESSED:\n+      case MouseEvent.MOUSE_RELEASED:\n+        return (mouseListener != null\n+                || mouseMotionListener != null\n+                || (eventMask & AWTEvent.MOUSE_EVENT_MASK) != 0);\n+        \n+      case FocusEvent.FOCUS_GAINED:\n+      case FocusEvent.FOCUS_LOST:\n+        return (focusListener != null\n+                || (eventMask & AWTEvent.FOCUS_EVENT_MASK) != 0);\n+\n+      case InputMethodEvent.INPUT_METHOD_TEXT_CHANGED:\n+      case InputMethodEvent.CARET_POSITION_CHANGED:\n+        return (inputMethodListener != null\n+                || (eventMask & AWTEvent.INPUT_METHOD_EVENT_MASK) != 0);\n+        \n+      case PaintEvent.PAINT:\n+      case PaintEvent.UPDATE:\n+        return (eventMask & AWTEvent.PAINT_EVENT_MASK) != 0;\n+        \n+      default:\n+        return false;\n+      }\n+  }\n+\n   /**\n    * Coalesce paint events. Current heuristic is: Merge if the union of\n    * areas is less than twice that of the sum of the areas. The X server"}, {"sha": "caffc50ab0e4aee15cd56204ca2e823e2f0073fc", "filename": "libjava/java/awt/Container.java", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e589ede6fdc3f0f3f70be950bdd85d996eb19eca/libjava%2Fjava%2Fawt%2FContainer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e589ede6fdc3f0f3f70be950bdd85d996eb19eca/libjava%2Fjava%2Fawt%2FContainer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FContainer.java?ref=e589ede6fdc3f0f3f70be950bdd85d996eb19eca", "patch": "@@ -45,6 +45,7 @@\n import java.awt.peer.ContainerPeer;\n import java.awt.peer.LightweightPeer;\n import java.beans.PropertyChangeListener;\n+import java.beans.PropertyChangeSupport;\n import java.io.PrintStream;\n import java.io.PrintWriter;\n import java.io.Serializable;\n@@ -89,6 +90,7 @@ public class Container extends Component\n \n   /* Anything else is non-serializable, and should be declared \"transient\". */\n   transient ContainerListener containerListener;\n+  transient PropertyChangeSupport changeSupport; \n \n   /**\n    * Default constructor for subclasses.\n@@ -1125,12 +1127,27 @@ public void applyComponentOrientation (ComponentOrientation orientation)\n       throw new NullPointerException ();\n   }\n   \n-  public void addPropertyChangeListener(PropertyChangeListener l)\n+  public void addPropertyChangeListener (PropertyChangeListener listener)\n   {\n+    if (listener == null)\n+      return;\n+\n+    if (changeSupport == null)\n+      changeSupport = new PropertyChangeSupport (this);\n+\n+    changeSupport.addPropertyChangeListener (listener);\n   }\n   \n-  public void addPropertyChangeListener(String name, PropertyChangeListener l)\n+  public void addPropertyChangeListener (String name,\n+                                         PropertyChangeListener listener)\n   {\n+    if (listener == null)\n+      return;\n+    \n+    if (changeSupport == null)\n+      changeSupport = new PropertyChangeSupport (this);\n+\n+    changeSupport.addPropertyChangeListener (name, listener);\n   }\n \n   // Hidden helper methods."}, {"sha": "1042939c076fc1c4209db642fbd7dd9c87ea6223", "filename": "libjava/java/awt/ContainerOrderFocusTraversalPolicy.java", "status": "modified", "additions": 52, "deletions": 2, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e589ede6fdc3f0f3f70be950bdd85d996eb19eca/libjava%2Fjava%2Fawt%2FContainerOrderFocusTraversalPolicy.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e589ede6fdc3f0f3f70be950bdd85d996eb19eca/libjava%2Fjava%2Fawt%2FContainerOrderFocusTraversalPolicy.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FContainerOrderFocusTraversalPolicy.java?ref=e589ede6fdc3f0f3f70be950bdd85d996eb19eca", "patch": "@@ -41,11 +41,15 @@\n import java.io.Serializable;\n \n /**\n- * STUB CLASS ONLY\n+ * @author Michael Koch\n+ * @since 1.4\n  */\n public class ContainerOrderFocusTraversalPolicy extends FocusTraversalPolicy\n   implements Serializable\n {\n+  /**\n+   * Compatible to JDK 1.4+\n+   */\n   static final long serialVersionUID = 486933713763926351L;\n \n   private boolean implicitDownCycleTraversal = true;\n@@ -55,31 +59,77 @@ public class ContainerOrderFocusTraversalPolicy extends FocusTraversalPolicy\n    */\n   public ContainerOrderFocusTraversalPolicy()\n   {\n-    throw new Error(\"not implemented\");\n+    // Nothing to do here\n   }\n \n+  /**\n+   * Returns the Component that should receive the focus after current.\n+   * root must be a focus cycle root of current.\n+   *\n+   * @exception IllegalArgumentException If root is not a focus cycle\n+   * root of current, or if either root or current is null.\n+   */\n   public Component getComponentAfter(Container root, Component current)\n   {\n+    if (root == null\n+        || current == null)\n+      throw new IllegalArgumentException ();\n+    \n     return null;\n   }\n \n+  /**\n+   * Returns the Component that should receive the focus before current.\n+   * root must be a focus cycle root of current.\n+   *\n+   * @exception IllegalArgumentException If root is not a focus cycle\n+   * root of current, or if either root or current is null.\n+   */\n   public Component getComponentBefore(Container root, Component current)\n   {\n+    if (root == null\n+        || current == null)\n+      throw new IllegalArgumentException ();\n+\n     return null;\n   }\n \n+  /**\n+   * Returns the first Component of root that should receive the focus.\n+   *\n+   * @exception IllegalArgumentException If root is null.\n+   */\n   public Component getFirstComponent(Container root)\n   {\n+    if (root == null)\n+      throw new IllegalArgumentException ();\n+\n     return null;\n   }\n \n+  /**\n+   * Returns the last Component of root that should receive the focus.\n+   *\n+   * @exception IllegalArgumentException If root is null.\n+   */\n   public Component getLastComponent(Container root)\n   {\n+    if (root == null)\n+      throw new IllegalArgumentException ();\n+\n     return null;\n   }\n \n+  /**\n+   * Returns the default Component of root that should receive the focus.\n+   *\n+   * @exception IllegalArgumentException If root is null.\n+   */\n   public Component getDefaultComponent(Container root)\n   {\n+    if (root == null)\n+      throw new IllegalArgumentException ();\n+\n     return null;\n   }\n "}, {"sha": "90ba6eafcf1c12b737e110fd6e09da524f2a59ee", "filename": "libjava/java/awt/EventQueue.java", "status": "modified", "additions": 67, "deletions": 60, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e589ede6fdc3f0f3f70be950bdd85d996eb19eca/libjava%2Fjava%2Fawt%2FEventQueue.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e589ede6fdc3f0f3f70be950bdd85d996eb19eca/libjava%2Fjava%2Fawt%2FEventQueue.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FEventQueue.java?ref=e589ede6fdc3f0f3f70be950bdd85d996eb19eca", "patch": "@@ -116,7 +116,8 @@ public synchronized AWTEvent peekEvent()\n \n     if (next_in != next_out)\n       return queue[next_out];\n-    else return null;\n+    else\n+      return null;\n   }\n \n   /**\n@@ -142,7 +143,7 @@ public synchronized AWTEvent peekEvent(int id)\n       {\n         AWTEvent qevt = queue[i];\n         if (qevt.id == id)\n-\t  return qevt;\n+          return qevt;\n       }\n     return null;\n   }\n@@ -159,7 +160,7 @@ public synchronized void postEvent(AWTEvent evt)\n     if (next != null)\n       {\n         next.postEvent(evt);\n-\treturn;\n+        return;\n       }\n     // FIXME: Security checks?\n \n@@ -169,25 +170,25 @@ public synchronized void postEvent(AWTEvent evt)\n     while (i != next_in)\n       {\n         AWTEvent qevt = queue[i];\n-\tObject src;\n-\tif (qevt.id == evt.id\n-\t    && (src = qevt.getSource()) == evt.getSource()\n-\t    && src instanceof Component)\n-\t  {\n-\t    /* If there are, call coalesceEvents on the source component \n-\t       to see if they can be combined. */\n-\t    Component srccmp = (Component) src;\n-\t    AWTEvent coalesced_evt = srccmp.coalesceEvents(qevt, evt);\n-\t    if (coalesced_evt != null)\n-\t      {\n-\t        /* Yes. Replace the existing event with the combined event. */\n-\t        queue[i] = coalesced_evt;\n-\t\treturn;\n-\t      }\n+        Object src;\n+        if (qevt.id == evt.id\n+            && (src = qevt.getSource()) == evt.getSource()\n+            && src instanceof Component)\n+          {\n+            /* If there are, call coalesceEvents on the source component \n+               to see if they can be combined. */\n+            Component srccmp = (Component) src;\n+            AWTEvent coalesced_evt = srccmp.coalesceEvents(qevt, evt);\n+            if (coalesced_evt != null)\n+              {\n+                /* Yes. Replace the existing event with the combined event. */\n+                queue[i] = coalesced_evt;\n+                return;\n+              }\n             break;\n-\t  }\n-\tif (++i == queue.length)\n-\t  i = 0;\n+          }\n+        if (++i == queue.length)\n+          i = 0;\n       }\n \n     queue[next_in] = evt;    \n@@ -198,15 +199,15 @@ public synchronized void postEvent(AWTEvent evt)\n       {\n         /* Queue is full. Extend it. */\n         AWTEvent[] oldQueue = queue;\n-\tqueue = new AWTEvent[queue.length * 2];\n+        queue = new AWTEvent[queue.length * 2];\n \n-\tint len = oldQueue.length - next_out;\n-\tSystem.arraycopy(oldQueue, next_out, queue, 0, len);\n-\tif (next_out != 0)\n-\t  System.arraycopy(oldQueue, 0, queue, len, next_out);\n+        int len = oldQueue.length - next_out;\n+        System.arraycopy(oldQueue, next_out, queue, 0, len);\n+        if (next_out != 0)\n+          System.arraycopy(oldQueue, 0, queue, len, next_out);\n \n-\tnext_out = 0;\n-\tnext_in = oldQueue.length;\n+        next_out = 0;\n+        next_in = oldQueue.length;\n       }\n     notify();\n   }\n@@ -237,8 +238,8 @@ public static void invokeAndWait(Runnable runnable)\n \n     synchronized (current)\n       {\n-\teq.postEvent(ie);\n-\tcurrent.wait();\n+        eq.postEvent(ie);\n+        current.wait();\n       }\n \n     Exception exception;\n@@ -247,7 +248,9 @@ public static void invokeAndWait(Runnable runnable)\n       throw new InvocationTargetException(exception);\n   }\n \n-  /** @since JDK1.2 */\n+  /**\n+   * @since 1.2\n+   */\n   public static void invokeLater(Runnable runnable)\n   {\n     EventQueue eq = Toolkit.getDefaultToolkit().getSystemEventQueue(); \n@@ -264,22 +267,26 @@ public static boolean isDispatchThread()\n     return (Thread.currentThread() == eq.dispatchThread);\n   }\n \n-  /** Allows a custom EventQueue implementation to replace this one. \n-    * All pending events are transferred to the new queue. Calls to postEvent,\n-    * getNextEvent, and peekEvent are forwarded to the pushed queue until it\n-    * is removed with a pop().\n-    *\n-    * @exception NullPointerException if newEventQueue is null.\n-    */\n+  /**\n+   * Allows a custom EventQueue implementation to replace this one. \n+   * All pending events are transferred to the new queue. Calls to postEvent,\n+   * getNextEvent, and peekEvent are forwarded to the pushed queue until it\n+   * is removed with a pop().\n+   *\n+   * @exception NullPointerException if newEventQueue is null.\n+   */\n   public synchronized void push(EventQueue newEventQueue)\n   {\n+    if (newEventQueue == null)\n+      throw new NullPointerException ();\n+\n     int i = next_out;\n     while (i != next_in)\n       {\n         newEventQueue.postEvent(queue[i]);\n-\tnext_out = i;\n-\tif (++i == queue.length)\n-\t  i = 0;\n+        next_out = i;\n+        if (++i == queue.length)\n+          i = 0;\n       }\n \n     next = newEventQueue;\n@@ -301,19 +308,19 @@ protected void pop() throws EmptyStackException\n     // occur.\n     synchronized (prev)\n       {\n-\tprev.next = null;\n+        prev.next = null;\n       }\n \n     synchronized (this)\n       {\n-\tint i = next_out;\n-\twhile (i != next_in)\n-\t  {\n+        int i = next_out;\n+        while (i != next_in)\n+          {\n             prev.postEvent(queue[i]);\n-\t    next_out = i;\n-\t    if (++i == queue.length)\n-\t      i = 0;\n-\t  }\n+            next_out = i;\n+            if (++i == queue.length)\n+              i = 0;\n+          }\n       }\n   }\n \n@@ -328,22 +335,22 @@ protected void dispatchEvent(AWTEvent evt)\n     if (evt instanceof ActiveEvent)\n       {\n         ActiveEvent active_evt = (ActiveEvent) evt;\n-\tactive_evt.dispatch();\n+        active_evt.dispatch();\n       }\n     else\n       {\n-\tObject source = evt.getSource();\n+        Object source = evt.getSource();\n \n-\tif (source instanceof Component)\n-\t  {\n+        if (source instanceof Component)\n+          {\n             Component srccmp = (Component) source;\n-\t    srccmp.dispatchEvent(evt);\n-\t  }\n-\telse if (source instanceof MenuComponent)\n-\t  {\n-\t    MenuComponent srccmp = (MenuComponent) source;\n-\t    srccmp.dispatchEvent(evt);\n-\t  }\n+            srccmp.dispatchEvent(evt);\n+          }\n+        else if (source instanceof MenuComponent)\n+          {\n+            MenuComponent srccmp = (MenuComponent) source;\n+            srccmp.dispatchEvent(evt);\n+          }\n       }\n   }\n "}, {"sha": "b5192f32faac64aff657a78675109332f82a313e", "filename": "libjava/java/awt/ScrollPane.java", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e589ede6fdc3f0f3f70be950bdd85d996eb19eca/libjava%2Fjava%2Fawt%2FScrollPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e589ede6fdc3f0f3f70be950bdd85d996eb19eca/libjava%2Fjava%2Fawt%2FScrollPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FScrollPane.java?ref=e589ede6fdc3f0f3f70be950bdd85d996eb19eca", "patch": "@@ -38,6 +38,7 @@\n \n package java.awt;\n \n+import java.awt.event.MouseEvent;\n import java.awt.peer.ScrollPanePeer;\n import java.awt.peer.ContainerPeer;\n import java.awt.peer.ComponentPeer;\n@@ -105,6 +106,8 @@ public class ScrollPane extends Container implements Accessible\n // Current scroll position\n private Point scrollPosition = new Point(0, 0);\n \n+private boolean wheelScrollingEnabled;\n+\n /*************************************************************************/\n \n /*\n@@ -153,6 +156,8 @@ public class ScrollPane extends Container implements Accessible\n       hAdjustable = new ScrollPaneAdjustable(Scrollbar.HORIZONTAL);\n       vAdjustable = new ScrollPaneAdjustable(Scrollbar.VERTICAL);\n     }\n+\n+  wheelScrollingEnabled = true;\n }\n \n /*************************************************************************/\n@@ -470,5 +475,37 @@ public class ScrollPane extends Container implements Accessible\n   return(getClass().getName());\n }\n \n+  /**\n+   * Tells wether or not an event is enabled.\n+   *\n+   * @since 1.4\n+   */\n+  public boolean eventTypeEnabled (int type)\n+  {\n+    if (type == MouseEvent.MOUSE_WHEEL)\n+      return wheelScrollingEnabled;\n+\n+    return super.eventTypeEnabled (type);\n+  }\n+\n+  /**\n+   * Tells wether or not wheel scrolling is enabled.\n+   *\n+   * @since 1.4\n+   */\n+  public boolean isWheelScrollingEnabled ()\n+  {\n+    return wheelScrollingEnabled;\n+  }\n+\n+  /**\n+   * Enables/disables wheel scrolling.\n+   *\n+   * @since 1.4\n+   */\n+  public void setWheelScrollingEnabled (boolean enable)\n+  {\n+    wheelScrollingEnabled = enable;\n+  }\n } // class ScrollPane \n "}]}