{"sha": "75d3a15b4d221ef3a8f04a9fb4af825df829ce26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzVkM2ExNWI0ZDIyMWVmM2E4ZjA0YTlmYjRhZjgyNWRmODI5Y2UyNg==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "1998-04-01T17:19:01Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1998-04-01T17:19:01Z"}, "message": "Add thumb-pe support.\n\nAdd super interworking.\n\nFrom-SVN: r18935", "tree": {"sha": "93acb74d0e8950bb98ee52e06ba004a46e2cb0f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93acb74d0e8950bb98ee52e06ba004a46e2cb0f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75d3a15b4d221ef3a8f04a9fb4af825df829ce26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75d3a15b4d221ef3a8f04a9fb4af825df829ce26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75d3a15b4d221ef3a8f04a9fb4af825df829ce26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75d3a15b4d221ef3a8f04a9fb4af825df829ce26/comments", "author": null, "committer": null, "parents": [{"sha": "7c76b292a2c186c2f3019591a44d6010b5de8a6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c76b292a2c186c2f3019591a44d6010b5de8a6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c76b292a2c186c2f3019591a44d6010b5de8a6f"}], "stats": {"total": 1658, "additions": 1506, "deletions": 152}, "files": [{"sha": "8e821948519c9c79b1a3fdafaaaf611108bb753f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d3a15b4d221ef3a8f04a9fb4af825df829ce26/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d3a15b4d221ef3a8f04a9fb4af825df829ce26/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=75d3a15b4d221ef3a8f04a9fb4af825df829ce26", "patch": "@@ -1,3 +1,20 @@\n+Wed Apr  1 17:06:19 1998  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/arm/thumb.h: Add super interworking support.\n+\t* config/arm/thumb.c: Add super interworking support.\n+\t* config/arm/thumb.md: Add super interworking support.\n+\t* config/arm/tpe.h: New file.\n+\t* config/arm/lib1funcs.asm: Add interworking support.\n+\t* config/arm/lib1thumb.asm: Add super interworking support.\n+\t* config/arm/t-pe: New file.\n+\t* config/arm/t-semi: Add interworking support.\n+\t* config/arm/t-thumb: Add interworking support.\n+\t* config/arm/t-pe-thumb: New file.\n+\t* config/arm/README-interworking: New file.\n+\t* config.sub: Add thumb-pe target.\n+\t* configure.in: Add thumb-pe target.\n+\t* configure: Add thumb-pe target.\n+\t\n Wed Apr  1 14:38:10 1998  Jim Wilson  <wilson@cygnus.com>\n \n \t* config/mips/iris6.h (MD_EXEC_PREFIX): Set to /usr/bin/."}, {"sha": "0271e3452bab083a3d7236271e0a6939e03b84a4", "filename": "gcc/config.sub", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d3a15b4d221ef3a8f04a9fb4af825df829ce26/gcc%2Fconfig.sub", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d3a15b4d221ef3a8f04a9fb4af825df829ce26/gcc%2Fconfig.sub", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.sub?ref=75d3a15b4d221ef3a8f04a9fb4af825df829ce26", "patch": "@@ -162,6 +162,10 @@ case $basic_machine in\n \tthumb | thumbel)\n \t\tbasic_machine=$basic_machine-unknown\n \t\t;;\n+\tthumb-pe) # CYGNUS LOCAL nickc/thumb-pe\n+\t\tbasic_machine=$basic_machine-unknown\n+\t\t;;\n+\t# END CYGNUS LOCAL nickc/thumb-pe\n \t# We use `pc' rather than `unknown'\n \t# because (1) that's what they normally are, and\n \t# (2) the word \"unknown\" tends to confuse beginning users."}, {"sha": "a0069a9ea80b57318998a7185fd1050a9900637d", "filename": "gcc/config/arm/README-interworking", "status": "added", "additions": 553, "deletions": 0, "changes": 553, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d3a15b4d221ef3a8f04a9fb4af825df829ce26/gcc%2Fconfig%2Farm%2FREADME-interworking", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d3a15b4d221ef3a8f04a9fb4af825df829ce26/gcc%2Fconfig%2Farm%2FREADME-interworking", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2FREADME-interworking?ref=75d3a15b4d221ef3a8f04a9fb4af825df829ce26", "patch": "@@ -0,0 +1,553 @@\n+\t\tArm / Thumb Interworking\n+\t\t========================\n+\n+The Cygnus GNU Pro Toolkit for the ARM7T processor supports function\n+calls between code compiled for the ARM instruction set and code\n+compiled for the Thumb instruction set and vice versa.  This document\n+describes how that interworking support operates and explains the\n+command line switches that should be used in order to produce working\n+programs.\n+\n+Note:  The Cygnus GNU Pro Toolkit does not support switching between\n+compiling for the ARM instruction set and the Thumb instruction set\n+on anything other than a per file basis.  There are in fact two\n+completely separate compilers, one that produces ARM assembler\n+instructions and one that produces Thumb assembler instructions.  The\n+two compilers share the same assembler, linker and so on.\n+\n+\n+1. Explicit interworking support for C and C++ files\n+====================================================\n+\n+By default if a file is compiled without any special command line\n+switches then the code produced will not support interworking.\n+Provided that a program is made up entirely from object files and\n+libraries produced in this way and which contain either exclusively\n+ARM instructions or exclusively Thumb instructions then this will not\n+matter and a working executable will be created.  If an attempt is\n+made to link together mixed ARM and Thumb object files and libraries,\n+then warning messages will be produced by the linker and a non-working\n+executable will be created.\n+\n+In order to produce code which does support interworking it should be\n+compiled with the\n+\n+\t-mthumb-interwork\n+\n+command line option.  Provided that a program is made up entirely from\n+object files and libraries built with this command line switch a\n+working executable will be produced, even if both ARM and Thumb\n+instructions are used by the various components of the program.  (No\n+warning messages will be produced by the linker either).\n+\n+Note that specifying -mthumb-interwork does result in slightly larger,\n+slower code being produced.  This is why interworking support must be\n+specifically enabled by a switch.\n+\n+\n+2. Explicit interworking support for assembler files\n+====================================================\n+\n+If assembler files are to be included into an interworking program\n+then the following rules must be obeyed:\n+\n+\t* Any externally visible functions must return by using the BX\n+\tinstruction.\n+\n+\t* Normal function calls can just use the BL instruction.  The\n+\tlinker will automatically insert code to switch between ARM\n+\tand Thumb modes as necessary.\n+\n+\t* Calls via function pointers should use the BX instruction if\n+\tthe call is made in ARM mode:\n+\n+\t\t.code 32\n+\t\tmov lr, pc\n+\t\tbx  rX\n+\n+\tThis code sequence will not work in Thumb mode however, since\n+\tthe mov instruction will not set the bottom bit of the lr\n+\tregister.  Instead a branch-and-link to the _call_via_rX\n+\tfunctions should be used instead:\n+\n+\t\t.code 16\n+\t\tbl  _call_via_rX\n+\n+\twhere rX is replaced by the name of the register containing\n+\tthe function address.\n+\n+\t* All externally visible functions which should be entered in\n+\tThumb mode must have the .thumb_func pseudo op specified just\n+\tbefore their entry point.  eg:\n+\n+\t\t\t.code 16\n+\t\t\t.global function\n+\t\t\t.thumb_func\n+\t\tfunction:\n+\t\t\t...start of function....\n+\n+\t* All assembler files must be assembled with the switch\n+\t-mthumb-interwork specified on the command line.  (If the file\n+\tis assembled by calling gcc it will automatically pass on the\n+\t-mthumb-interwork switch to the assembler, provided that it\n+\twas specified on the gcc command line in the first place.) \n+\n+\n+3. Support for old, non-interworking aware code.\n+================================================\n+\n+If it is necessary to link together code produced by an older,\n+non-interworking aware compiler, or code produced by the new compiler\n+but without the -mthumb-interwork command line switch specified, then\n+there are two command line switches that can be used to support this.\n+\n+The switch\n+\n+\t-mcaller-super-interworking\n+\n+will allow calls via function pointers in Thumb mode to work,\n+regardless of whether the function pointer points to old,\n+non-interworking aware code or not.  Specifying this switch does\n+produce slightly slower code however.\n+\n+Note:  There is no switch to allow calls via function pointers in ARM\n+mode to be handled specially.  Calls via function pointers from\n+interworking aware ARM code to non-interworking aware ARM code work\n+without any special considerations by the compiler.  Calls via\n+function pointers from interworking aware ARM code to non-interworking\n+aware Thumb code however will not work.  (Actually under some\n+circumstances they may work, but there are no guarantees).  This is\n+because only the new compiler is able to produce Thumb code, and this\n+compiler already has a command line switch to produce interworking\n+aware code.\n+\n+\n+The switch\n+\n+\t-mcallee-super-interworking\n+\n+will allow non-interworking aware ARM or Thumb code to call Thumb\n+functions, either directly or via function pointers.  Specifying this\n+switch does produce slightly larger, slower code however.\n+\n+Note:  There is no switch to allow non-interworking aware ARM or Thumb\n+code to call ARM functions.  There is no need for any special handling\n+of calls from non-interworking aware ARM code to interworking aware\n+ARM functions, they just work normally.  Calls from non-interworking\n+aware Thumb functions to ARM code however, will not work.  There is no\n+option to support this, since it is always possible to recompile the\n+Thumb code to be interworking aware.\n+\n+As an alternative to the command line switch\n+-mcallee-super-interworking, which affects all externally visible\n+functions in a file, it is possible to specify an attribute or\n+declspec for individual functions, indicating that that particular\n+function should support being called by non-interworking aware code.\n+The function should be defined like this:\n+\n+\tint function __attribute__((interfacearm))\n+\t{\n+\t\t... body of function ...\n+\t}\n+\n+or\n+\n+\tint function __declspec(interfacearm)\n+\t{\n+\t\t... body of function ...\n+\t}\n+\n+\n+\n+4. Interworking support in dlltool\n+==================================\n+\n+Currently there is no interworking support in dlltool.  This may be a\n+future enhancement.\n+\n+\n+\n+5. How interworking support works\n+=================================\n+\n+Switching between the ARM and Thumb instruction sets is accomplished\n+via the BX instruction which takes as an argument a register name.\n+Control is transfered to the address held in this register (with the\n+bottom bit masked out), and if the bottom bit is set, then Thumb\n+instruction processing is enabled, otherwise ARM instruction\n+processing is enabled.\n+\n+When the -mthumb-interwork command line switch is specified, gcc\n+arranges for all functions to return to their caller by using the BX\n+instruction.  Thus provided that the return address has the bottom bit\n+correctly initialised to indicate the instruction set of the caller,\n+correct operation will ensue.\n+\n+When a function is called explicitly (rather than via a function\n+pointer), the compiler generates a BL instruction to do this.  The\n+Thumb version of the BL instruction has the special property of\n+setting the bottom bit of the LR register after it has stored the\n+return address into it, so that a future BX instruction will correctly\n+return the instruction after the BL instruction, in Thumb mode.\n+\n+The BL instruction does not change modes itself however, so if an ARM\n+function is calling a Thumb function, or vice versa, it is necessary\n+to generate some extra instructions to handle this.  This is done in\n+the linker when it is storing the address of the referenced function\n+into the BL instruction.  If the BL instruction is an ARM style BL\n+instruction, but the referenced function is a Thumb function, then the\n+linker automatically generates a calling stub that converts from ARM\n+mode to Thumb mode, puts the address of this stub into the BL\n+instruction, and puts the address of the referenced function into the\n+stub.  Similarly if the BL instruction is a Thumb BL instruction, and\n+the referenced function is an ARM function, the linker generates a\n+stub which converts from Thumb to ARM mode, puts the address of this\n+stub into the BL instruction, and the address of the referenced\n+function into the stub.\n+\n+This is why it is necessary to mark Thumb functions with the\n+.thumb_func pseudo op when creating assembler files.  This pseudo op\n+allows the assembler to distinguish between ARM functions and Thumb\n+functions.  (The Thumb version of GCC automatically generates these\n+pseudo ops for any Thumb functions that it generates).\n+\n+Calls via function pointers work differently.  Whenever the address of\n+a function is taken, the linker examines the type of the function\n+being referenced.  If the function is a Thumb function, then it sets\n+the bottom bit of the address.  Technically this makes the address\n+incorrect, since it is now one byte into the start of the function,\n+but this is never a problem because:\n+\n+\ta. with interworking enabled all calls via function pointer\n+\t   are done using the BX instruction and this ignores the\n+\t   bottom bit when computing where to go to.\n+\n+\tb. the linker will always set the bottom bit when the address\n+\t   of the function is taken, so it is never possible to take\n+\t   the address of the function in two different places and\n+\t   then compare them and find that they are not equal.\n+\n+As already mentioned any call via a function pointer will use the BX\n+instruction (provided that interworking is enabled).  The only problem\n+with this is computing the return address for the return from the\n+called function.  For ARM code this can easily be done by the code\n+sequence:\n+\n+\tmov\tlr, pc\n+\tbx\trX\n+\n+(where rX is the name of the register containing the function\n+pointer).  This code does not work for the Thumb instruction set,\n+since the MOV instruction will not set the bottom bit of the LR\n+register, so that when the called function returns, it will return in\n+ARM mode not Thumb mode.  Instead the compiler generates this\n+sequence:\n+\n+\tbl\t_call_via_rX\n+\n+(again where rX is the name if the register containing the function\n+pointer).  The special call_via_rX functions look like this:\n+\n+\t.thumb_func\n+_call_via_r0:\n+\tbx\tr0\n+\tnop\n+\n+The BL instruction ensures that the correct return address is stored\n+in the LR register and then the BX instruction jumps to the address\n+stored in the function pointer, switch modes if necessary.\n+\n+\n+6. How caller-super-interworking support works\n+==============================================\n+\n+When the -mcaller-super-interworking command line switch is specified\n+it changes the code produced by the Thumb compiler so that all calls\n+via function pointers (including virtual function calls) now go via a\n+different stub function.  The code to call via a function pointer now\n+looks like this:\n+\n+\tbl _interwork_call_via_r0\n+\n+Note: The compiler does not insist that r0 be used to hold the\n+function address.  Any register will do, and there are a suite of stub\n+functions, one for each possible register.  The stub functions look\n+like this:\n+\n+\t.code 16\n+\t.thumb_func\n+_interwork_call_via_r0\n+\tbx \tpc\n+\tnop\n+\t\n+\t.code 32\n+\ttst\tr0, #1\n+\tstmeqdb\tr13!, {lr}\n+\tadreq\tlr, _arm_return\n+\tbx\tr0\n+\n+The stub first switches to ARM mode, since it is a lot easier to\n+perform the necessary operations using ARM instructions.  It then\n+tests the bottom bit of the register containing the address of the\n+function to be called.  If this bottom bit is set then the function\n+being called uses Thumb instructions and the BX instruction to come\n+will switch back into Thumb mode before calling this function.  (Note\n+that it does not matter how this called function chooses to return to\n+its caller, since the both the caller and callee are Thumb functions,\n+and mode switching is necessary).  If the function being called is an\n+ARM mode function however, the stub pushes the return address (with\n+its bottom bit set) onto the stack, replaces the return address with\n+the address of the a piece of code called '_arm_return' and then\n+performs a BX instruction to call the function.\n+\n+The '_arm_return' code looks like this:\n+\n+\t.code 32\n+_arm_return:\t\t\n+\tldmia \tr13!, {r12}\n+\tbx \tr12\n+\t.code 16\n+\n+\n+It simply retrieves the return address from the stack, and then\n+performs a BX operation to return to the caller and switch back into\n+Thumb mode.\n+\n+\n+7. How callee-super-interworking support works\n+==============================================\n+\n+When -mcallee-super-interworking is specified on the command line the\n+Thumb compiler behaves as if every externally visible function that it\n+compiles has had the (interfacearm) attribute specified for it.  What\n+this attribute does is to put a special, ARM mode header onto the\n+function which forces a switch into Thumb mode:\n+\n+  without __attribute__((interfacearm)):\n+\n+\t\t.code 16\n+\t\t.thumb_func\n+\tfunction:\n+\t\t... start of function ...\n+\n+  with __attribute__((interfacearm)):\n+\n+\t\t.code 32\n+\tfunction:\n+\t\torr\tr12, pc, #1\n+\t\tbx\tr12\n+\n+\t\t.code 16\n+                .thumb_func\n+        .real_start_of_function:\n+\n+\t\t... start of function ...\n+\n+Note that since the function now expects to be entered in ARM mode, it\n+no longer has the .thumb_func pseudo op specified for its name.\n+Instead the pseudo op is attached to a new label .real_start_of_<name>\n+(where <name> is the name of the function) which indicates the start\n+of the Thumb code.  This does have the interesting side effect in that\n+if this function is now called from a Thumb mode piece of code\n+outsside of the current file, the linker will generate a calling stub\n+to switch from Thumb mode into ARM mode, and then this is immediately\n+overridden by the function's header which switches back into Thumb\n+mode. \n+\n+In addition the (interfacearm) attribute also forces the function to\n+return by using the BX instruction, even if has not been compiled with\n+the -mthumb-interwork command line flag, so that the correct mode will\n+be restored upon exit from the function.\n+\n+\n+8. Some examples\n+================\n+\n+Given this test file:\n+\n+\tint func (void) { return 1; }\n+\n+\tint call (int (* ptr)(void)) { return ptr (); }\n+\n+The following varying pieces of assembler are produced depending upon\n+the command line options used:\n+\n+no options:\n+\n+\t@ Generated by gcc cygnus-2.91.07 980205 (gcc-2.8.0 release) for ARM/pe\n+\t\t.code\t16\n+\t\t.text\n+\t\t.globl\t_func\n+\t\t.thumb_func\n+\t_func:\n+\t\tmov\tr0, #1\n+\t\tbx\tlr\n+\n+\t\t.globl\t_call\n+\t\t.thumb_func\n+\t_call:\n+\t\tpush\t{lr}\n+\t\tbl\t__call_via_r0\n+\t\tpop\t{pc}\n+\n+Note how the two functions have different exit sequences.  In\n+particular call() uses pop {pc} to return.  This would not work if the\n+caller was in ARM mode.\n+\n+If -mthumb-interwork is specified on the command line:\n+\n+\t@ Generated by gcc cygnus-2.91.07 980205 (gcc-2.8.0 release) for ARM/pe\n+\t\t.code\t16\n+\t\t.text\n+\t\t.globl\t_func\n+\t\t.thumb_func\n+\t_func:\n+\t\tmov\tr0, #1\n+\t\tbx\tlr\n+\n+\t\t.globl\t_call\n+\t\t.thumb_func\n+\t_call:\n+\t\tpush\t{lr}\n+\t\tbl\t__call_via_r0\n+\t\tpop\t{r1}\n+\t\tbx\tr1\n+\n+This time both functions return by using the BX instruction.  This\n+means that call() is now two bytes longer and several cycles slower\n+than the version that is not interworking enabled.\n+\n+If -mcaller-super-interworking is specified:\n+\n+\t@ Generated by gcc cygnus-2.91.07 980205 (gcc-2.8.0 release) for ARM/pe\n+\t\t.code\t16\n+\t\t.text\n+\t\t.globl\t_func\n+\t\t.thumb_func\n+\t_func:\n+\t\tmov\tr0, #1\n+\t\tbx\tlr\n+\n+\t\t.globl\t_call\n+\t\t.thumb_func\n+\t_call:\n+\t\tpush\t{lr}\n+\t\tbl\t__interwork_call_via_r0\n+\t\tpop\t{pc}\n+\n+Very similar to the first (non-interworking) version, except that a\n+different stub is used to call via the function pointer.  Note that\n+the assembly code for call() is not interworking aware, and so should\n+not be called from ARM code.\n+\n+If -mcallee-super-interworking is specified:\n+\n+\t@ Generated by gcc cygnus-2.91.07 980205 (gcc-2.8.0 release) for ARM/pe\n+\t\t.code\t16\n+\t\t.text\n+\t\t.globl\t_func\n+\t\t.code\t32\n+\t_func:\n+\t\torr\tr12, pc, #1\n+\t\tbx\tr12\n+\t\t.code\t16\n+\t\t.globl .real_start_of_func\n+\t\t.thumb_func\n+\t.real_start_of_func:\n+\t\tmov\tr0, #1\n+\t\tbx\tlr\n+\n+\t\t.globl\t_call\n+\t\t.code\t32\n+\t_call:\n+\t\torr\tr12, pc, #1\n+\t\tbx\tr12\n+\t\t.code\t16\n+\t\t.globl .real_start_of_call\n+\t\t.thumb_func\n+\t.real_start_of_call:\n+\t\tpush\t{lr}\n+\t\tbl\t__call_via_r0\n+\t\tpop\t{r1}\n+\t\tbx\tr1\n+\n+Now both functions have an ARM coded prologue, and both functions\n+return by using the BX instruction.  These functions are interworking\n+aware therefore and can safely be called from ARM code.  The code for\n+the call() function is now 10 bytes longer than the original, non\n+interworking aware version, an increase of over 200%.\n+\n+If the source code is slightly altered so that only the call function\n+has an (interfacearm) attribute:\n+\n+\tint func (void) { return 1; }\n+\tint call () __attribute__((interfacearm));\n+\tint call (int (* ptr)(void)) { return ptr (); }\n+\tint main (void) { return printf (\"result: %d\\n\", call (func)); }\n+\n+then this code is produced (with no command line switches):\n+\n+\t@ Generated by gcc cygnus-2.91.07 980205 (gcc-2.8.0 release) for ARM/pe\n+\t\t.code\t16\n+\t\t.text\n+\t\t.globl\t_func\n+\t\t.thumb_func\n+\t_func:\n+\t\tmov\tr0, #1\n+\t\tbx\tlr\n+\n+\t\t.globl\t_call\n+\t\t.code\t32\n+\t_call:\n+\t\torr\tr12, pc, #1\n+\t\tbx\tr12\n+\t\t.code\t16\n+\t\t.globl .real_start_of_call\n+\t\t.thumb_func\n+\t.real_start_of_call:\n+\t\tpush\t{lr}\n+\t\tbl\t__call_via_r0\n+\t\tpop\t{r1}\n+\t\tbx\tr1\n+\n+\t\t.globl\t_main\n+\t\t.thumb_func\n+\t_main:\n+\t\tpush\t{r4, lr}\n+\t\tbl\t___gccmain\n+\t\tldr\tr4, .L4\n+\t\tldr\tr0, .L4+4\n+\t\tbl\t_call\n+\t\tadd\tr1, r0, #0\n+\t\tadd\tr0, r4, #0\n+\t\tbl\t_printf\n+\t\tpop\t{r4, pc}\n+\t.L4:\n+\t\t.word\t.LC0\n+\t\t.word\t_func\n+\n+\t\t.section .rdata\n+\t.LC0:\n+\t\t.ascii\t\"result: %d\\n\\000\"\n+\n+So now only call() can be called via non-interworking aware ARM code.\n+When this program is assembled, the assembler detects the fact that\n+main() is calling call() in Thumb mode, and so automatically adjusts\n+the BL instruction to point to the real start of call():\n+\n+\tDisassembly of section .text:\n+\n+\t00000028 <_main>:\n+\t  28:\tb530      \tb530\tpush\t{r4, r5, lr}\n+\t  2a:\tfffef7ff \tf7ff\tbl\t2a <_main+0x2>\n+\t  2e:\t4d06      \t4d06\tldr\tr5, [pc, #24]\t(48 <.L7>)\n+\t  30:\tffe8f7ff \tf7ff\tbl\t4 <_doit>\n+\t  34:\t1c04      \t1c04\tadd\tr4, r0, #0\n+\t  36:\t4805      \t4805\tldr\tr0, [pc, #20]\t(4c <.L7+0x4>)\n+\t  38:\tfff0f7ff \tf7ff\tbl\t1c <.real_start_of_call>\n+\t  3c:\t1824      \t1824\tadd\tr4, r4, r0\n+\t  3e:\t1c28      \t1c28\tadd\tr0, r5, #0\n+\t  40:\t1c21      \t1c21\tadd\tr1, r4, #0\n+\t  42:\tfffef7ff \tf7ff\tbl\t42 <_main+0x1a>\n+\t  46:\tbd30      \tbd30\tpop\t{r4, r5, pc}\n+"}, {"sha": "aac0ce1977f264615f9d76e0a4a5d6a93c7145a5", "filename": "gcc/config/arm/lib1funcs.asm", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d3a15b4d221ef3a8f04a9fb4af825df829ce26/gcc%2Fconfig%2Farm%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d3a15b4d221ef3a8f04a9fb4af825df829ce26/gcc%2Fconfig%2Farm%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flib1funcs.asm?ref=75d3a15b4d221ef3a8f04a9fb4af825df829ce26", "patch": "@@ -402,3 +402,120 @@ SYM (__div0):\n \tRET\tpc, lr\n \n #endif /* L_divmodsi_tools */\n+\n+#ifdef L_dvmd_lnx\n+@ GNU/Linux division-by zero handler.  Used in place of L_dvmd_tls\n+\n+#include <asm/unistd.h>\n+#define SIGFPE\t8\t\t\t@ cant use <asm/signal.h> as it\n+\t\t\t\t\t@ contains too much C rubbish\n+\t.globl SYM (__div0)\n+\t.align 0\n+SYM (__div0):\n+\tstmfd\tsp!, {r1, lr}\n+\tswi\t__NR_getpid\n+\tcmn\tr0, #1000\n+\tldmgefd\tsp!, {r1, pc}RETCOND\t@ not much we can do\n+\tmov\tr1, #SIGFPE\n+\tswi\t__NR_kill\n+\tldmfd\tsp!, {r1, pc}RETCOND\n+\n+#endif /* L_dvmd_lnx */\n+\n+/* These next two sections are here despite the fact that they contain Thumb \n+   assembler because their presence allows interworked code to be linked even\n+   when the GCC library is this one.  */\n+\t\t\n+#ifdef L_call_via_rX\n+\n+/* These labels & instructions are used by the Arm/Thumb interworking code. \n+   The address of function to be called is loaded into a register and then \n+   one of these labels is called via a BL instruction.  This puts the \n+   return address into the link register with the bottom bit set, and the \n+   code here switches to the correct mode before executing the function.  */\n+\t\n+\t.text\n+\t.align 0\n+\t.code 16\n+.macro call_via register\n+\t.globl\tSYM (_call_via_\\register)\n+\t.thumb_func\n+SYM (_call_via_\\register):\n+\tbx\t\\register\n+\tnop\n+.endm\n+\n+\tcall_via r0\n+\tcall_via r1\n+\tcall_via r2\n+\tcall_via r3\n+\tcall_via r4\n+\tcall_via r5\n+\tcall_via r6\n+\tcall_via r7\n+\tcall_via r8\n+\tcall_via r9\n+\tcall_via sl\n+\tcall_via fp\n+\tcall_via ip\n+\tcall_via sp\n+\tcall_via lr\n+\n+#endif /* L_call_via_rX */\n+\n+#ifdef L_interwork_call_via_rX\n+\n+/* These labels & instructions are used by the Arm/Thumb interworking code,\n+   when the target address is in an unknown instruction set.  The address \n+   of function to be called is loaded into a register and then one of these\n+   labels is called via a BL instruction.  This puts the return address \n+   into the link register with the bottom bit set, and the code here \n+   switches to the correct mode before executing the function.  Unfortunately\n+   the target code cannot be relied upon to return via a BX instruction, so\n+   instead we have to store the resturn address on the stack and allow the\n+   called function to return here instead.  Upon return we recover the real\n+   return address and use a BX to get back to Thumb mode.  */\n+\t\n+\t.text\n+\t.align 0\n+\n+\t.code   32\n+_arm_return:\t\t\n+\tldmia \tr13!, {r12}\n+\tbx \tr12\n+\t.code   16\n+\n+.macro interwork register\t\t\t\t\t\n+\t.code   16\n+\t.globl\tSYM (_interwork_call_via_\\register)\n+\t.thumb_func\n+SYM (_interwork_call_via_\\register):\n+\tbx \tpc\n+\tnop\n+\t\n+\t.code   32\n+\t.globl .Lchange_\\register\n+.Lchange_\\register:\n+\ttst\t\\register, #1\n+\tstmeqdb\tr13!, {lr}\n+\tadreq\tlr, _arm_return\n+\tbx\t\\register\n+.endm\n+\t\n+\tinterwork r0\n+\tinterwork r1\n+\tinterwork r2\n+\tinterwork r3\n+\tinterwork r4\n+\tinterwork r5\n+\tinterwork r6\n+\tinterwork r7\n+\tinterwork r8\n+\tinterwork r9\n+\tinterwork sl\n+\tinterwork fp\n+\tinterwork ip\n+\tinterwork sp\n+\tinterwork lr\n+\t\t\n+#endif /* L_interwork_call_via_rX */"}, {"sha": "d50d35d15f16ce1c941a4054a66072bbef9c4a99", "filename": "gcc/config/arm/lib1thumb.asm", "status": "modified", "additions": 76, "deletions": 83, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d3a15b4d221ef3a8f04a9fb4af825df829ce26/gcc%2Fconfig%2Farm%2Flib1thumb.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d3a15b4d221ef3a8f04a9fb4af825df829ce26/gcc%2Fconfig%2Farm%2Flib1thumb.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flib1thumb.asm?ref=75d3a15b4d221ef3a8f04a9fb4af825df829ce26", "patch": "@@ -605,98 +605,91 @@ SYM (__div0):\n    one of these labels is called via a BL instruction.  This puts the \n    return address into the link register with the bottom bit set, and the \n    code here switches to the correct mode before executing the function.  */\n-\n+\t\n \t.text\n \t.align 0\n-\t\n-\t.globl\tSYM (_call_via_r0)\n-\t.thumb_func\n-SYM (_call_via_r0):\n-\tbx\tr0 \n-\tnop\n-\n-\t.globl\tSYM (_call_via_r1)\n-\t.thumb_func\n-SYM (_call_via_r1):\n-\tbx \tr1\n-\tnop\n-\n-\t.globl\tSYM (_call_via_r2)\n-\t.thumb_func\n-SYM (_call_via_r2):\n-\tbx \tr2 \n-\tnop\n-\n-\t.globl\tSYM (_call_via_r3)\n-\t.thumb_func\n-SYM (_call_via_r3):\n-\tbx \tr3 \n-\tnop\n-\n-\t.globl\tSYM (_call_via_r4)\n-\t.thumb_func\n-SYM (_call_via_r4):\n-\tbx \tr4\n-\tnop\n-\n-\t.globl\tSYM (_call_via_r5)\n-\t.thumb_func\n-SYM (_call_via_r5):\n-\tbx \tr5\n-\tnop\n-\n-\t.globl\tSYM (_call_via_r6)\n-\t.thumb_func\n-SYM (_call_via_r6):\n-\tbx \tr6\n-\tnop\n \n-\t.globl\tSYM (_call_via_r7)\n+.macro call_via register\n+\t.globl\tSYM (_call_via_\\register)\n \t.thumb_func\n-SYM (_call_via_r7):\n-\tbx \tr7\n+SYM (_call_via_\\register):\n+\tbx\t\\register\n \tnop\n+.endm\n+\n+\tcall_via r0\n+\tcall_via r1\n+\tcall_via r2\n+\tcall_via r3\n+\tcall_via r4\n+\tcall_via r5\n+\tcall_via r6\n+\tcall_via r7\n+\tcall_via r8\n+\tcall_via r9\n+\tcall_via sl\n+\tcall_via fp\n+\tcall_via ip\n+\tcall_via sp\n+\tcall_via lr\n \n-\t.globl\tSYM (_call_via_r8)\n-\t.thumb_func\n-SYM (_call_via_r8):\n-\tbx \tr8\n-\tnop\n-\n-\t.globl\tSYM (_call_via_r9)\n-\t.thumb_func\n-SYM (_call_via_r9):\n-\tbx \tr9\n-\tnop\n-\n-\t.globl\tSYM (_call_via_sl)\n-\t.thumb_func\n-SYM (_call_via_sl):\n-\tbx \tsl \n-\tnop\n-\n-\t.globl\tSYM (_call_via_fp)\n-\t.thumb_func\n-SYM (_call_via_fp):\n-\tbx \tfp \n-\tnop\n+#endif /* L_call_via_rX */\n \n-\t.globl\tSYM (_call_via_ip)\n-\t.thumb_func\n-SYM (_call_via_ip):\n-\tbx \tip\n-\tnop\n+#ifdef L_interwork_call_via_rX\n+\n+/* These labels & instructions are used by the Arm/Thumb interworking code,\n+   when the target address is in an unknown instruction set.  The address \n+   of function to be called is loaded into a register and then one of these\n+   labels is called via a BL instruction.  This puts the return address \n+   into the link register with the bottom bit set, and the code here \n+   switches to the correct mode before executing the function.  Unfortunately\n+   the target code cannot be relied upon to return via a BX instruction, so\n+   instead we have to store the resturn address on the stack and allow the\n+   called function to return here instead.  Upon return we recover the real\n+   return address and use a BX to get back to Thumb mode.  */\n+\t\n+\t.text\n+\t.align 0\n \n-\t.globl\tSYM (_call_via_sp)\n-\t.thumb_func\n-SYM (_call_via_sp):\n-\tbx \tsp \n-\tnop\n+\t.code 32\n+_arm_return:\t\t\n+\tldmia \tr13!, {r12}\n+\tbx \tr12\n+\t.code 16\n \n-\t.globl\tSYM (_call_via_lr)\n+.macro interwork register\t\t\t\t\t\n+\t.globl\tSYM (_interwork_call_via_\\register)\n \t.thumb_func\n-SYM (_call_via_lr):\n-\tbx \tlr \n+SYM (_interwork_call_via_\\register):\n+\tbx \tpc\n \tnop\n+\t\n+\t.code 32\n+\t.globl .Lchange_\\register\n+.Lchange_\\register:\n+\ttst\t\\register, #1\n+\tstmeqdb\tr13!, {lr}\n+\tadreq\tlr, _arm_return\n+\tbx\t\\register\n+\t.code 16\n+.endm\n+\t\n+\tinterwork r0\n+\tinterwork r1\n+\tinterwork r2\n+\tinterwork r3\n+\tinterwork r4\n+\tinterwork r5\n+\tinterwork r6\n+\tinterwork r7\n+\tinterwork r8\n+\tinterwork r9\n+\tinterwork sl\n+\tinterwork fp\n+\tinterwork ip\n+\tinterwork sp\n+\tinterwork lr\n+\t\t\n+#endif /* L_interwork_call_via_rX */\n \n-#endif /* L_call_via_rX */\n+\t"}, {"sha": "e68b3c90e757f28e7aad3c03060f85e35798f03b", "filename": "gcc/config/arm/t-pe", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d3a15b4d221ef3a8f04a9fb4af825df829ce26/gcc%2Fconfig%2Farm%2Ft-pe", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d3a15b4d221ef3a8f04a9fb4af825df829ce26/gcc%2Fconfig%2Farm%2Ft-pe", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-pe?ref=75d3a15b4d221ef3a8f04a9fb4af825df829ce26", "patch": "@@ -0,0 +1,31 @@\n+CROSS_LIBGCC1 = libgcc1-asm.a\n+LIB1ASMSRC = arm/lib1funcs.asm\n+LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls _call_via_rX _interwork_call_via_rX\n+\n+# These are really part of libgcc1, but this will cause them to be\n+# built correctly, so...\n+\n+LIB2FUNCS_EXTRA = fp-bit.c dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\techo '#ifndef __ARMEB__' >> fp-bit.c\n+\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> fp-bit.c\n+\techo '#endif' >> fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#ifndef __ARMEB__' > dp-bit.c\n+\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> dp-bit.c\n+\techo '#define FLOAT_WORD_ORDER_MISMATCH' >> dp-bit.c\n+\techo '#endif' >> dp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n+\n+pe.o: $(srcdir)/config/arm/pe.c\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(srcdir)/config/arm/pe.c\n+\n+MULTILIB_OPTIONS = mhard-float\n+MULTILIB_DIRNAMES = fpu\n+\n+LIBGCC = stmp-multilib\n+INSTALL_LIBGCC = install-multilib"}, {"sha": "253c814cbaf6d2c4e4881f8df595c1c68d112efc", "filename": "gcc/config/arm/t-pe-thumb", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d3a15b4d221ef3a8f04a9fb4af825df829ce26/gcc%2Fconfig%2Farm%2Ft-pe-thumb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d3a15b4d221ef3a8f04a9fb4af825df829ce26/gcc%2Fconfig%2Farm%2Ft-pe-thumb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-pe-thumb?ref=75d3a15b4d221ef3a8f04a9fb4af825df829ce26", "patch": "@@ -0,0 +1,37 @@\n+# Makefile fragment\n+# Copyright (c) 1998 Free Software Foundation\n+# CYGNUS LOCAL (entire file) nickc/thumb-pe\n+\n+CROSS_LIBGCC1 = libgcc1-asm.a\n+LIB1ASMSRC = arm/lib1thumb.asm\n+LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls _call_via_rX _interwork_call_via_rX\n+\n+# These are really part of libgcc1, but this will cause them to be\n+# built correctly, so...\n+\n+LIB2FUNCS_EXTRA = fp-bit.c dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\techo '#ifndef __ARMEB__' >> fp-bit.c\n+\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> fp-bit.c\n+\techo '#endif' >> fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#ifndef __ARMEB__' > dp-bit.c\n+\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> dp-bit.c\n+\techo '#define FLOAT_WORD_ORDER_MISMATCH' >> dp-bit.c\n+\techo '#endif' >> dp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n+\n+# Rule to build Psion specific GCC functions.\n+pe.o: $(srcdir)/config/arm/pe.c\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(srcdir)/config/arm/pe.c\n+\n+# Avoid building a duplicate set of libraries for the default endian-ness.\n+MULTILIB_OPTIONS = mthumb-interwork\n+MULTILIB_DIRNAMES = interwork\n+\n+LIBGCC = stmp-multilib\n+INSTALL_LIBGCC = install-multilib"}, {"sha": "74fdef49920e2ddaa37ff3986cad69485580254d", "filename": "gcc/config/arm/t-semi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d3a15b4d221ef3a8f04a9fb4af825df829ce26/gcc%2Fconfig%2Farm%2Ft-semi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d3a15b4d221ef3a8f04a9fb4af825df829ce26/gcc%2Fconfig%2Farm%2Ft-semi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-semi?ref=75d3a15b4d221ef3a8f04a9fb4af825df829ce26", "patch": "@@ -11,7 +11,7 @@ LIBGCC1_TEST =\n \n CROSS_LIBGCC1 = libgcc1-asm.a\n LIB1ASMSRC = arm/lib1funcs.asm\n-LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls\n+LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls _call_via_rX _interwork_call_via_rX\n \n #Don't try to run fixproto\n STMP_FIXPROTO ="}, {"sha": "6b349e2fdf0c8b1681306c15ae39e844247135d1", "filename": "gcc/config/arm/t-thumb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d3a15b4d221ef3a8f04a9fb4af825df829ce26/gcc%2Fconfig%2Farm%2Ft-thumb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d3a15b4d221ef3a8f04a9fb4af825df829ce26/gcc%2Fconfig%2Farm%2Ft-thumb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-thumb?ref=75d3a15b4d221ef3a8f04a9fb4af825df829ce26", "patch": "@@ -1,6 +1,6 @@\n CROSS_LIBGCC1 = libgcc1-asm.a\n LIB1ASMSRC = arm/lib1thumb.asm\n-LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls _call_via_rX\n+LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls _call_via_rX _interwork_call_via_rX\n # adddi3/subdi3 added to machine description\n #LIB1ASMFUNCS = _adddi3 _subdi3 _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls\n "}, {"sha": "9f025f8dadcaf7ed555b57b19cab90efa11afe51", "filename": "gcc/config/arm/thumb.c", "status": "modified", "additions": 155, "deletions": 28, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d3a15b4d221ef3a8f04a9fb4af825df829ce26/gcc%2Fconfig%2Farm%2Fthumb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d3a15b4d221ef3a8f04a9fb4af825df829ce26/gcc%2Fconfig%2Farm%2Fthumb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb.c?ref=75d3a15b4d221ef3a8f04a9fb4af825df829ce26", "patch": "@@ -540,6 +540,43 @@ thumb_reload_out_si (operands)\n   abort ();\n }\n \n+#ifdef THUMB_PE /* CYGNUS LOCAL nickc/thumb-pe */\n+/* Return non-zero if FUNC is a naked function.  */\n+\n+static int\n+arm_naked_function_p (func)\n+     tree func;\n+{\n+  tree a;\n+\n+  if (TREE_CODE (func) != FUNCTION_DECL)\n+    abort ();\n+\n+  a = lookup_attribute (\"naked\", DECL_MACHINE_ATTRIBUTES (func));\n+  return a != NULL_TREE;\n+}\n+#endif /* END CYGNUS LOCAL nickc/thumb-pe */\n+\n+/* CYGNUS LOCAL nickc/super-interworking */\n+/* Return non-zero if FUNC must be entered in ARM mode.  */\n+int\n+is_called_in_ARM_mode (func)\n+     tree func;\n+{\n+  if (TREE_CODE (func) != FUNCTION_DECL)\n+    abort ();\n+\n+  /* Ignore the problem about functions whoes address is taken.  */\n+  if (TARGET_CALLEE_INTERWORKING && TREE_PUBLIC (func))\n+    return TRUE;\n+\n+#ifdef THUMB_PE \n+  return lookup_attribute (\"interfacearm\", DECL_MACHINE_ATTRIBUTES (func)) != NULL_TREE;\n+#else\n+  return FALSE;\n+#endif\n+}\n+/* END CYGNUS LOCAL */\n \f\n /* Routines for emitting code */\n \n@@ -585,10 +622,9 @@ number_of_first_bit_set (mask)\n #define LINK_REGISTER\t14\n #define PROGRAM_COUNTER 15\n \n-/* Generate code to return from a thumb function.\n-   If 'reg_containing_return_addr' is -1, then the\n-   address is actually on the stack, at the stack\n-   pointer.  */\n+/* Generate code to return from a thumb function.  If\n+   'reg_containing_return_addr' is -1, then the return address is\n+   actually on the stack, at the stack pointer.  */\n \n static void\n thumb_exit (f, reg_containing_return_addr)\n@@ -634,9 +670,15 @@ thumb_exit (f, reg_containing_return_addr)\n     }\n \n   /* Otherwise if we are not supporting interworking and we have not created\n-     a backtrace structure then just pop the return address straight into the PC.  */\n+     a backtrace structure and the function was not entered in ARM mode then\n+     just pop the return address straight into the PC. */\n   \n-  else if (! TARGET_THUMB_INTERWORK && ! TARGET_BACKTRACE)\n+  else if (   ! TARGET_THUMB_INTERWORK\n+\t   && ! TARGET_BACKTRACE\n+/* CYGNUS LOCAL nickc/super-interworking */\n+\t   && ! is_called_in_ARM_mode (current_function_decl)\n+/* END CYGNUS LOCAL */\n+\t      )\n     {\n       asm_fprintf (f, \"\\tpop\\t{pc}\\n\" );\n \n@@ -926,7 +968,7 @@ thumb_pushpop (f, mask, push)\n       if (mask & 0xFF)\n \tasm_fprintf (f, \", \");\n       \n-      asm_fprintf (f, \"%s\", reg_names[14]);\n+      asm_fprintf (f, reg_names[14]);\n     }\n   else if (!push && (mask & (1 << 15)))\n     {\n@@ -948,7 +990,7 @@ thumb_pushpop (f, mask, push)\n \t  if (mask & 0xFF)\n \t    asm_fprintf (f, \", \");\n \t  \n-\t  asm_fprintf (f, \"%s\", reg_names[15]);\n+\t  asm_fprintf (f, reg_names[15]);\n \t}\n     }\n        \n@@ -995,7 +1037,12 @@ output_return ()\n \t{\n \t  thumb_exit (asm_out_file, 14);\t      \n \t}\n-      else if (TARGET_THUMB_INTERWORK || TARGET_BACKTRACE)\n+      else if (   TARGET_THUMB_INTERWORK\n+\t       || TARGET_BACKTRACE\n+/* CYGNUS LOCAL nickc/super-interworking */\n+\t       || is_called_in_ARM_mode (current_function_decl)\n+/* END CYGNUS LOCAL */\t\t  \n+\t\t  )\n \t{\n \t  thumb_exit (asm_out_file, -1);\n \t}\n@@ -1014,7 +1061,12 @@ output_return ()\n \t\tasm_fprintf (asm_out_file, \", \");\n \t  }\n \n-      if (TARGET_THUMB_INTERWORK || TARGET_BACKTRACE)\n+      if (   TARGET_THUMB_INTERWORK\n+\t  || TARGET_BACKTRACE\n+/* CYGNUS LOCAL nickc/super-interworking */\n+\t  || is_called_in_ARM_mode (current_function_decl)\n+/* END CYGNUS LOCAL */\n+\t     )\n \t{\n \t  asm_fprintf (asm_out_file, \"}\\n\");\n \t  thumb_exit (asm_out_file, -1);\n@@ -1037,6 +1089,43 @@ thumb_function_prologue (f, frame_size)\n   int store_arg_regs = 0;\n   int regno;\n \n+#ifdef THUMB_PE   /* CYGNUS LOCAL nickc/thumb-pe */\n+  if (arm_naked_function_p (current_function_decl))\n+    return;\n+#endif /* CYGNUS LOCAL nickc/thumb-pe */\n+\n+/* CYGNUS LOCAL nickc/super-interworking */\n+  if (is_called_in_ARM_mode (current_function_decl))\n+    {\n+      char * name;\n+      if (GET_CODE (DECL_RTL (current_function_decl)) != MEM)\n+\tabort();\n+      if (GET_CODE (XEXP (DECL_RTL (current_function_decl), 0)) != SYMBOL_REF)\n+\tabort();\n+      name = XSTR  (XEXP (DECL_RTL (current_function_decl), 0), 0);\n+      \n+      /* Generate code sequence to switch us into Thumb mode.  */\n+      /* The .code 32 directive has already been emitted by\n+\t ASM_DECLARE_FUNCITON_NAME */\n+      asm_fprintf (f, \"\\torr\\tr12, pc, #1\\n\");\n+      asm_fprintf (f, \"\\tbx\\tr12\\n\");\n+\n+      /* Generate a label, so that the debugger will notice the\n+\t change in instruction sets.  This label is also used by\n+\t the assembler to bypass the ARM code when this function\n+\t is called from a Thumb encoded function elsewhere in the\n+\t same file.  Hence the definition of STUB_NAME here must\n+\t agree with the definition in gas/config/tc-arm.c  */\n+      \n+#define STUB_NAME \".real_start_of\"\n+      \n+      asm_fprintf (f, \"\\t.code\\t16\\n\");\n+      asm_fprintf (f, \"\\t.globl %s%U%s\\n\", STUB_NAME, name);\n+      asm_fprintf (f, \"\\t.thumb_func\\n\");\n+      asm_fprintf (f, \"%s%U%s:\\n\", STUB_NAME, name);\n+    }\n+/* END CYGNUS LOCAL nickc/super-interworking */\n+    \n   if (current_function_anonymous_args && current_function_pretend_args_size)\n     store_arg_regs = 1;\n \n@@ -1318,7 +1407,7 @@ thumb_unexpanded_epilogue ()\n   int high_regs_pushed = 0;\n   int leaf_function = leaf_function_p ();\n   int had_to_push_lr;\n-  \n+\n   if (return_used_this_function)\n     return \"\";\n \n@@ -1329,7 +1418,7 @@ thumb_unexpanded_epilogue ()\n   for (regno = 8; regno < 13; regno++)\n     {\n       if (regs_ever_live[regno] && ! call_used_regs[regno])\n-\thigh_regs_pushed++;\n+\thigh_regs_pushed ++;\n     }\n \n   /* The prolog may have pushed some high registers to use as\n@@ -1385,7 +1474,6 @@ thumb_unexpanded_epilogue ()\n       while (high_regs_pushed)\n \t{\n \t  /* Find low register(s) into which the high register(s) can be popped.  */\n-\t  \n \t  for (regno = 0; regno < 8; regno++)\n \t    {\n \t      if (mask & (1 << regno))\n@@ -1397,11 +1485,9 @@ thumb_unexpanded_epilogue ()\n \t  mask &= (2 << regno) - 1;\t/* A noop if regno == 8 */\n \n \t  /* Pop the values into the low register(s). */\n-\t  \n \t  thumb_pushpop (asm_out_file, mask, 0);\n \n \t  /* Move the value(s) into the high registers.  */\n-\t  \n \t  for (regno = 0; regno < 8; regno++)\n \t    {\n \t      if (mask & (1 << regno))\n@@ -1419,11 +1505,6 @@ thumb_unexpanded_epilogue ()\n \n   had_to_push_lr = (live_regs_mask || ! leaf_function || far_jump_used_p());\n   \n-  if (had_to_push_lr)\n-    {\n-      live_regs_mask |= 1 << PROGRAM_COUNTER;\n-    }\n-\n   if (TARGET_BACKTRACE && ((live_regs_mask & 0xFF) == 0) && regs_ever_live[ ARG_4_REGISTER ] != 0)\n     {\n       /* The stack backtrace structure creation code had to\n@@ -1435,6 +1516,13 @@ thumb_unexpanded_epilogue ()\n   \n   if (current_function_pretend_args_size == 0 || TARGET_BACKTRACE)\n     {\n+      if (had_to_push_lr\n+/* CYGNUS LOCAL nickc/super-interworking */\n+\t  && ! is_called_in_ARM_mode (current_function_decl)\n+/* END CYGNUS LOCAL nickc/super-interworking */\n+\t  )\n+\tlive_regs_mask |= 1 << PROGRAM_COUNTER;\n+\n       /* Either no argument registers were pushed or a backtrace\n \t structure was created which includes an adjusted stack\n \t pointer, so just pop everything.  */\n@@ -1443,15 +1531,23 @@ thumb_unexpanded_epilogue ()\n \tthumb_pushpop (asm_out_file, live_regs_mask, FALSE);\n       \n       /* We have either just popped the return address into the\n-\t PC or it is was kept in LR for the entire function.  */\n+\t PC or it is was kept in LR for the entire function or\n+\t it is still on the stack because we do not want to\n+\t return by doing a pop {pc}.  */\n       \n-      if (! had_to_push_lr)\n-\tthumb_exit (asm_out_file, LINK_REGISTER);\n+      if ((live_regs_mask & (1 << PROGRAM_COUNTER)) == 0)\n+\tthumb_exit (asm_out_file,\n+\t\t    (\n+\t\t     had_to_push_lr\n+/* CYGNUS LOCAL nickc/super-interworking */\n+\t\t     && is_called_in_ARM_mode (current_function_decl)\n+/* END CYGNUS LOCAL */\n+\t\t     ) ? -1 : LINK_REGISTER\n+\t\t    );\n     }\n   else\n     {\n       /* Pop everything but the return address.  */\n-      \n       live_regs_mask &= ~ (1 << PROGRAM_COUNTER);\n       \n       if (live_regs_mask)\n@@ -1460,15 +1556,13 @@ thumb_unexpanded_epilogue ()\n       if (had_to_push_lr)\n \t{\n \t  /* Get the return address into a temporary register.  */\n-      \n \t  thumb_pushpop (asm_out_file, 1 << ARG_4_REGISTER, 0);\n \t}\n       \n       /* Remove the argument registers that were pushed onto the stack.  */\n-      \n       asm_fprintf (asm_out_file, \"\\tadd\\t%s, %s, #%d\\n\",\n-\t\t   reg_names[STACK_POINTER],\n-\t\t   reg_names[STACK_POINTER],\n+\t\t   reg_names [STACK_POINTER],\n+\t\t   reg_names [STACK_POINTER],\n \t\t   current_function_pretend_args_size);\n       \n       thumb_exit (asm_out_file, had_to_push_lr ? ARG_4_REGISTER : LINK_REGISTER);\n@@ -1963,3 +2057,36 @@ void thumb_override_options()\n \twarning (\"Structure size boundary can only be set to 8 or 32\");\n     }\n }\n+\f\n+#ifdef THUMB_PE /* CYGNUS LOCAL nickc/thumb-pe */\n+/* Return nonzero if ATTR is a valid attribute for DECL.\n+   ATTRIBUTES are any existing attributes and ARGS are the arguments\n+   supplied with ATTR.\n+\n+   Supported attributes:\n+\n+   naked: don't output any prologue or epilogue code, the user is assumed\n+   to do the right thing.\n+\n+   interfacearm: Always assume that this function will be entered in ARM\n+   mode, not Thumb mode, and that the caller wishes to be returned to in\n+   ARM mode.  */\n+int\n+arm_valid_machine_decl_attribute (decl, attributes, attr, args)\n+     tree decl;\n+     tree attributes;\n+     tree attr;\n+     tree args;\n+{\n+  if (args != NULL_TREE)\n+    return 0;\n+\n+  if (is_attribute_p (\"naked\", attr))\n+    return TREE_CODE (decl) == FUNCTION_DECL;\n+  \n+  if (is_attribute_p (\"interfacearm\", attr))\n+    return TREE_CODE (decl) == FUNCTION_DECL;\n+  \n+  return 0;\n+}\n+#endif /* END CYGNUS LOCAL nickc/thumb-pe */"}, {"sha": "a847c5659a4f21322f9027c2f488c99345be0328", "filename": "gcc/config/arm/thumb.h", "status": "modified", "additions": 60, "deletions": 26, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d3a15b4d221ef3a8f04a9fb4af825df829ce26/gcc%2Fconfig%2Farm%2Fthumb.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d3a15b4d221ef3a8f04a9fb4af825df829ce26/gcc%2Fconfig%2Farm%2Fthumb.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb.h?ref=75d3a15b4d221ef3a8f04a9fb4af825df829ce26", "patch": "@@ -55,36 +55,63 @@ Boston, MA 02111-1307, USA.  */\n #define TARGET_VERSION  fputs (\" (ARM/THUMB:generic)\", stderr);\n \n /* Nonzero if we should compile with BYTES_BIG_ENDIAN set to 1.  */\n-#define THUMB_FLAG_BIG_END      \t(0x0001)\n-#define THUMB_FLAG_BACKTRACE    \t(0x0002)\n-#define THUMB_FLAG_LEAF_BACKTRACE\t(0x0004)\n-#define ARM_FLAG_THUMB\t\t\t(0x1000)\t/* same as in arm.h */\n+#define THUMB_FLAG_BIG_END      \t\t0x0001\n+#define THUMB_FLAG_BACKTRACE    \t\t0x0002\n+#define THUMB_FLAG_LEAF_BACKTRACE\t\t0x0004\n+#define ARM_FLAG_THUMB\t\t\t\t0x1000\t/* same as in arm.h */\n+#define THUMB_FLAG_CALLEE_SUPER_INTERWORKING\t0x40000 /* CYGNUS LOCAL nickc */\n+#define THUMB_FLAG_CALLER_SUPER_INTERWORKING\t0x80000 /* CYGNUS LOCAL nickc */\n+\n \n /* Run-time compilation parameters selecting different hardware/software subsets.  */\n extern int target_flags;\n #define TARGET_DEFAULT          0 /* ARM_FLAG_THUMB */\n #define TARGET_BIG_END          (target_flags & THUMB_FLAG_BIG_END)\n #define TARGET_THUMB_INTERWORK\t(target_flags & ARM_FLAG_THUMB)\n-#define TARGET_BACKTRACE\t(leaf_function_p()\t\t\t\t\\\n-\t\t\t\t ? (target_flags & THUMB_FLAG_LEAF_BACKTRACE)\t\\\n+#define TARGET_BACKTRACE\t(leaf_function_p()\t\t\t      \\\n+\t\t\t\t ? (target_flags & THUMB_FLAG_LEAF_BACKTRACE) \\\n \t\t\t\t : (target_flags & THUMB_FLAG_BACKTRACE))\n \n-#define TARGET_SWITCHES                                 \\\n-{                                                       \\\n-  {\"big-endian\",\t\tTHUMB_FLAG_BIG_END},\t\\\n-  {\"little-endian\",\t       -THUMB_FLAG_BIG_END},\t\\\n-  {\"thumb-interwork\",\t\tARM_FLAG_THUMB},\t\\\n-  {\"no-thumb-interwork\",       -ARM_FLAG_THUMB},\t\\\n-  {\"tpcs-frame\",\t\tTHUMB_FLAG_BACKTRACE},\t\\\n-  {\"no-tpcs-frame\",            -THUMB_FLAG_BACKTRACE},\t\\\n-  {\"tpcs-leaf-frame\",\t\tTHUMB_FLAG_LEAF_BACKTRACE},\t\\\n-  {\"no-tpcs-leaf-frame\",       -THUMB_FLAG_LEAF_BACKTRACE},\t\\\n-  {\"\",                          TARGET_DEFAULT}         \\\n+/* CYGNUS LOCAL nickc/super-interworking */\n+/* Set if externally visable functions should assume that they\n+   might be called in ARM mode, from a non-thumb aware code.  */\n+#define TARGET_CALLEE_INTERWORKING\t\\\n+     (target_flags & THUMB_FLAG_CALLEE_SUPER_INTERWORKING)\n+\n+/* Set if calls via function pointers should assume that their\n+   destination is non-Thumb aware.  */\n+#define TARGET_CALLER_INTERWORKING\t\\\n+     (target_flags & THUMB_FLAG_CALLER_SUPER_INTERWORKING)\n+/* END CYGNUS LOCAL */\n+\n+/* SUBTARGET_SWITCHES is used to add flags on a per-config basis. */\n+#ifndef SUBTARGET_SWITCHES\n+#define SUBTARGET_SWITCHES\n+#endif\n+\n+#define TARGET_SWITCHES                                 \t\\\n+{                                                       \t\\\n+  {\"big-endian\",\t\t    THUMB_FLAG_BIG_END},\t\\\n+  {\"little-endian\",\t           -THUMB_FLAG_BIG_END},\t\\\n+  {\"thumb-interwork\",\t\t    ARM_FLAG_THUMB},\t\t\\\n+  {\"no-thumb-interwork\",           -ARM_FLAG_THUMB},\t\t\\\n+  {\"tpcs-frame\",\t\t    THUMB_FLAG_BACKTRACE},\t\\\n+  {\"no-tpcs-frame\",                -THUMB_FLAG_BACKTRACE},\t\\\n+  {\"tpcs-leaf-frame\",\t  \t    THUMB_FLAG_LEAF_BACKTRACE},\t\\\n+  {\"no-tpcs-leaf-frame\",           -THUMB_FLAG_LEAF_BACKTRACE},\t\\\n+  /* CYGNUS LOCAL nickc/super-interworking */ \\\n+  {\"callee-super-interworking\",\t    THUMB_FLAG_CALLEE_SUPER_INTERWORKING}, \\\n+  {\"no-callee-super-interworking\", -THUMB_FLAG_CALLEE_SUPER_INTERWORKING}, \\\n+  {\"caller-super-interworking\",\t    THUMB_FLAG_CALLER_SUPER_INTERWORKING}, \\\n+  {\"no-caller-super-interworking\", -THUMB_FLAG_CALLER_SUPER_INTERWORKING}, \\\n+  /* END CYGNUS LOCAL */ \\\n+  SUBTARGET_SWITCHES\t\t\t\t\t\t\\\n+  {\"\",                          TARGET_DEFAULT}         \t\\\n }\n \n-#define TARGET_OPTIONS\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\\\n-  { \"structure-size-boundary=\", & structure_size_string }, \\\n+#define TARGET_OPTIONS\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  { \"structure-size-boundary=\", & structure_size_string }, \t\\\n }\n \n #define REGISTER_PREFIX \"\"\n@@ -1026,7 +1053,12 @@ int thumb_shiftable_const ();\n /* Emit a special directive when defining a function name.\n    This is used by the assembler to assit with interworking.  */\n #define ASM_DECLARE_FUNCTION_NAME(file, name, decl)             \\\n-  fprintf (file, \".thumb_func\\n\") ; \t\t\t\t\\\n+/* CYGNUS LOCAL nickc/supr-interworking */ \\\n+  if (! is_called_in_ARM_mode (decl))\t\t\t\\\n+    fprintf (file, \"\\t.thumb_func\\n\") ;\t\t\t\\\n+  else\t\t\t\t\t\t\t\\\n+    fprintf (file, \"\\t.code\\t32\\n\") ;\t\t\t\\\n+/* END CYGNUS LOCAL */ \\\n   ASM_OUTPUT_LABEL (file, name)\n \n #define ASM_OUTPUT_REG_PUSH(STREAM,REGNO)\t\t\t\\\n@@ -1095,8 +1127,10 @@ int thumb_shiftable_const ();\n int thumb_trivial_epilogue ();\n #define USE_RETURN (reload_completed && thumb_trivial_epilogue ())\n \n-extern char *thumb_unexpanded_epilogue ();\n-extern char *output_move_mem_multiple ();\n-extern char *thumb_load_double_from_address ();\n-extern char *output_return ();\n-extern int   far_jump_used_p();\n+extern char * thumb_unexpanded_epilogue ();\n+extern char * output_move_mem_multiple ();\n+extern char * thumb_load_double_from_address ();\n+extern char * output_return ();\n+extern int    far_jump_used_p();\n+extern int    is_called_in_ARM_mode (); /* CYGNUS LOCAL */\n+"}, {"sha": "2334aa1b10c501a2e882cf0ddb4672d37e66713e", "filename": "gcc/config/arm/thumb.md", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d3a15b4d221ef3a8f04a9fb4af825df829ce26/gcc%2Fconfig%2Farm%2Fthumb.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d3a15b4d221ef3a8f04a9fb4af825df829ce26/gcc%2Fconfig%2Farm%2Fthumb.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb.md?ref=75d3a15b4d221ef3a8f04a9fb4af825df829ce26", "patch": "@@ -989,19 +989,20 @@\n (define_insn \"*call_indirect\"\n   [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"l*r\"))\n \t (match_operand 1 \"\" \"\"))]\n-  \"TARGET_THUMB_INTERWORK\"\n+  \"! TARGET_CALLER_INTERWORKING\"\n   \"bl\\\\t__call_via_%0\"\n [(set_attr \"length\" \"4\")])\n+;; The non THUMB_INTERWORK, non TARGET_CALLER_INTERWORKING version\n+;; used to be: \"mov\\\\tlr,pc\\;bx\\\\t%0\", but the mov does not set\n+;; the bottom bit of lr so that a function return (using bx)\n+;; would switch back into ARM mode...\n \n-\n-(define_insn \"*call_indirect\"\n+(define_insn \"*call_indirect_interwork\"\n   [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"l*r\"))\n \t (match_operand 1 \"\" \"\"))]\n-  \"! TARGET_THUMB_INTERWORK\"\n-  \"bl\\\\t__call_via_%0\"\n+  \"TARGET_CALLER_INTERWORKING\"\n+  \"bl\\\\t__interwork_call_via_%0\"\n [(set_attr \"length\" \"4\")])\n-;; used to be: \"mov\\\\tlr,pc\\;bx\\\\t%0\"\n-;; but this does not set bottom bit of lr\n \n (define_expand \"call_value\"\n   [(set (match_operand 0 \"\" \"\")\n@@ -1014,19 +1015,19 @@\n   [(set (match_operand 0 \"\" \"=l\")\n \t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"l*r\"))\n \t      (match_operand 2 \"\" \"\")))]\n-  \"TARGET_THUMB_INTERWORK\"\n+  \"! TARGET_CALLER_INTERWORKING\"\n   \"bl\\\\t__call_via_%1\"\n [(set_attr \"length\" \"4\")])\n+;; See comment for call_indirect pattern\n \n-(define_insn \"*call_value_indirect\"\n+(define_insn \"*call_value_indirect_interwork\"\n   [(set (match_operand 0 \"\" \"=l\")\n \t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"l*r\"))\n \t      (match_operand 2 \"\" \"\")))]\n-  \"! TARGET_THUMB_INTERWORK\"\n-  \"bl\\\\t__call_via_%1\"\n+  \"TARGET_CALLER_INTERWORKING\"\n+  \"bl\\\\t__interwork_call_via_%1\"\n [(set_attr \"length\" \"4\")])\n-;; used to be  \"mov\\\\tlr,pc\\;bx\\\\t%1\"\n-;; but this does not set bottom bit of lr\n+\n \n (define_insn \"*call_insn\"\n   [(call (mem:SI (match_operand:SI 0 \"\" \"i\"))"}, {"sha": "375a84c107dd7cd872eb1e6c48d4276552b176fc", "filename": "gcc/config/arm/tpe.h", "status": "added", "additions": 420, "deletions": 0, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d3a15b4d221ef3a8f04a9fb4af825df829ce26/gcc%2Fconfig%2Farm%2Ftpe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d3a15b4d221ef3a8f04a9fb4af825df829ce26/gcc%2Fconfig%2Farm%2Ftpe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ftpe.h?ref=75d3a15b4d221ef3a8f04a9fb4af825df829ce26", "patch": "@@ -0,0 +1,420 @@\n+/* CYGNUS LOCAL (entire file) nickc/thumb-pe */\n+/* Definitions of target machine for GNU compiler,\n+   for Thumb with PE object format.\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Derived from arm/coff.h and arm/pe.h originally by Doug Evans (evans@cygnus.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"arm/thumb.h\"\n+\f\n+#define THUMB_PE 1\n+\n+/* Run-time Target Specification.  */\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fputs (\" (Thumb/pe)\", stderr)\n+\f\n+/* Support the __declspec keyword by turning them into attributes.\n+   We currently only support: naked, dllimport, and dllexport.\n+   Note that the current way we do this may result in a collision with\n+   predefined attributes later on.  This can be solved by using one attribute,\n+   say __declspec__, and passing args to it.  The problem with that approach\n+   is that args are not accumulated: each new appearance would clobber any\n+   existing args.  */\n+#undef CPP_PREDEFINES\n+#define CPP_PREDEFINES \"\\\n+-Dthumb -D__thumb -D__pe__ -Acpu(arm) -Amachine(arm) \\\n+-D__declspec(x)=__attribute__((x)) \\\n+\"\n+\n+/* Experimental addition for pr 7885.\n+   Ignore dllimport for functions.  */\n+#define ARM_FLAG_NOP_FUN_IMPORT\t\t0x20000\n+#define TARGET_NOP_FUN_DLLIMPORT (target_flags & ARM_FLAG_NOP_FUN_IMPORT)\n+\n+#undef SUBTARGET_SWITCHES\n+#define SUBTARGET_SWITCHES \\\n+{ \"nop-fun-dllimport\",\t\t  ARM_FLAG_NOP_FUN_IMPORT }, \\\n+{ \"no-nop-fun-dllimport\",\t -ARM_FLAG_NOP_FUN_IMPORT }, \n+\n+#undef TARGET_DEFAULT\n+#define TARGET_DEFAULT ARM_FLAG_NOP_FUN_IMPORT\n+\f\n+/* Setting this to 32 produces more efficient code, but the value set in previous\n+   versions of this toolchain was 8, which produces more compact structures. The\n+   command line option -mstructure_size_boundary=<n> can be used to change this\n+   value.  */\n+#undef STRUCTURE_SIZE_BOUNDARY\n+#define STRUCTURE_SIZE_BOUNDARY arm_structure_size_boundary\n+\n+extern int arm_structure_size_boundary;\n+\f\n+/* This is COFF, but prefer stabs.  */\n+#define SDB_DEBUGGING_INFO\n+\n+#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n+\n+#include \"dbxcoff.h\"\n+\f\n+/* Note - it is important that these definitions match those in semi.h for the ARM port.  */\n+#undef LOCAL_LABEL_PREFIX\n+#define LOCAL_LABEL_PREFIX \".\"\n+\n+#undef USER_LABEL_PREFIX\n+#define USER_LABEL_PREFIX \"_\"\n+\n+/* A C statement to output assembler commands which will identify the\n+   object file as having been compiled with GNU CC (or another GNU\n+   compiler).  */\n+#define ASM_IDENTIFY_GCC(STREAM)\t\t\t\t\\\n+     fprintf (STREAM, \"%sgcc2_compiled.:\\n%s\", LOCAL_LABEL_PREFIX, ASM_APP_OFF )\n+\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(STREAM) \\\n+do {\t\t\t\t\t\t\t\t\\\n+  extern char *version_string;\t\t\t\t\t\\\n+  fprintf ((STREAM), \"%s Generated by gcc %s for Thumb/coff\\n\", \\\n+\t   ASM_COMMENT_START, version_string);\t                \\\n+  fprintf ((STREAM), ASM_APP_OFF);                              \\\n+} while (0)\n+\n+/* A C statement to output something to the assembler file to switch to section\n+   NAME for object DECL which is either a FUNCTION_DECL, a VAR_DECL or\n+   NULL_TREE.  Some target formats do not support arbitrary sections.  Do not\n+   define this macro in such cases.  */\n+#define ASM_OUTPUT_SECTION_NAME(STREAM, DECL, NAME, RELOC) \\\n+do {\t\t\t\t\t\t\t\t\\\n+  if ((DECL) && TREE_CODE (DECL) == FUNCTION_DECL)\t\t\\\n+    fprintf (STREAM, \"\\t.section %s,\\\"x\\\"\\n\", (NAME));\t\t\\\n+  else if ((DECL) && DECL_READONLY_SECTION (DECL, RELOC))\t\\\n+    fprintf (STREAM, \"\\t.section %s,\\\"\\\"\\n\", (NAME));\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    fprintf (STREAM, \"\\t.section %s,\\\"w\\\"\\n\", (NAME));\t\t\\\n+} while (0)\n+\f\n+/* Support the ctors/dtors and other sections.  */\n+\n+#undef INIT_SECTION_ASM_OP\n+\n+/* Define this macro if jump tables (for `tablejump' insns) should be\n+   output in the text section, along with the assembler instructions.\n+   Otherwise, the readonly data section is used.  */\n+#define JUMP_TABLES_IN_TEXT_SECTION\n+\n+#undef READONLY_DATA_SECTION\n+#define READONLY_DATA_SECTION\trdata_section\n+#undef RDATA_SECTION_ASM_OP\n+#define RDATA_SECTION_ASM_OP\t\"\\t.section .rdata\"\n+\n+#undef CTORS_SECTION_ASM_OP\n+#define CTORS_SECTION_ASM_OP\t\"\\t.section .ctors,\\\"x\\\"\"\n+#undef DTORS_SECTION_ASM_OP\n+#define DTORS_SECTION_ASM_OP\t\"\\t.section .dtors,\\\"x\\\"\"\n+\n+/* A list of other sections which the compiler might be \"in\" at any\n+   given time.  */\n+\n+#undef EXTRA_SECTIONS\n+#define EXTRA_SECTIONS SUBTARGET_EXTRA_SECTIONS in_rdata, in_ctors, in_dtors\n+\n+#define SUBTARGET_EXTRA_SECTIONS\n+\n+/* A list of extra section function definitions.  */\n+\n+#undef EXTRA_SECTION_FUNCTIONS\n+#define EXTRA_SECTION_FUNCTIONS \\\n+  RDATA_SECTION_FUNCTION\t\\\n+  CTORS_SECTION_FUNCTION\t\\\n+  DTORS_SECTION_FUNCTION\t\\\n+  SUBTARGET_EXTRA_SECTION_FUNCTIONS\n+\n+#define SUBTARGET_EXTRA_SECTION_FUNCTIONS\n+\n+#define RDATA_SECTION_FUNCTION \\\n+void\t\t\t\t\t\t\t\t\t\\\n+rdata_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_rdata)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", RDATA_SECTION_ASM_OP);\t\t\\\n+      in_section = in_rdata;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define CTORS_SECTION_FUNCTION \\\n+void\t\t\t\t\t\t\t\t\t\\\n+ctors_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_ctors)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", CTORS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_ctors;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define DTORS_SECTION_FUNCTION \\\n+void\t\t\t\t\t\t\t\t\t\\\n+dtors_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_dtors)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", DTORS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_dtors;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\f\n+/* Support the ctors/dtors sections for g++.  */\n+\n+#define INT_ASM_OP \".word\"\n+\n+/* A C statement (sans semicolon) to output an element in the table of\n+   global constructors.  */\n+#undef ASM_OUTPUT_CONSTRUCTOR\n+#define ASM_OUTPUT_CONSTRUCTOR(STREAM,NAME) \\\n+do {\t\t\t\t\t\t\\\n+  ctors_section ();\t\t\t\t\\\n+  fprintf (STREAM, \"\\t%s\\t \", INT_ASM_OP);\t\\\n+  assemble_name (STREAM, NAME);\t\t\t\\\n+  fprintf (STREAM, \"\\n\");\t\t\t\\\n+} while (0)\n+\n+/* A C statement (sans semicolon) to output an element in the table of\n+   global destructors.  */\n+#undef ASM_OUTPUT_DESTRUCTOR\n+#define ASM_OUTPUT_DESTRUCTOR(STREAM,NAME) \\\n+do {\t\t\t\t\t\t\\\n+  dtors_section ();                   \t\t\\\n+  fprintf (STREAM, \"\\t%s\\t \", INT_ASM_OP);\t\\\n+  assemble_name (STREAM, NAME);              \t\\\n+  fprintf (STREAM, \"\\n\");\t\t\t\\\n+} while (0)\n+\n+/* __CTOR_LIST__ and __DTOR_LIST__ must be defined by the linker script.  */\n+#define CTOR_LISTS_DEFINED_EXTERNALLY\n+\n+#undef DO_GLOBAL_CTORS_BODY\n+#undef DO_GLOBAL_DTORS_BODY\n+\n+/* The ARM development system has atexit and doesn't have _exit,\n+   so define this for now.  */\n+#define HAVE_ATEXIT\n+\n+/* The ARM development system defines __main.  */\n+#define NAME__MAIN \"__gccmain\"\n+#define SYMBOL__MAIN __gccmain\n+\f\n+/* This is to better conform to the ARM PCS.\n+   Richard Earnshaw hasn't put this into FSF sources yet so it's here.  */\n+#undef RETURN_IN_MEMORY\n+#define RETURN_IN_MEMORY(TYPE) \t\t\t\t\t\t\\\n+  ((TYPE_MODE ((TYPE)) == BLKmode && ! TYPE_NO_FORCE_BLK (TYPE))\t\\\n+   || (AGGREGATE_TYPE_P ((TYPE)) && arm_pe_return_in_memory ((TYPE))))\n+\f\n+/* A C expression whose value is nonzero if IDENTIFIER with arguments ARGS\n+   is a valid machine specific attribute for DECL.\n+   The attributes in ATTRIBUTES have previously been assigned to DECL.  */\n+extern int arm_pe_valid_machine_decl_attribute ();\n+extern int arm_valid_machine_decl_attribute ();\n+#undef VALID_MACHINE_DECL_ATTRIBUTE\n+#define VALID_MACHINE_DECL_ATTRIBUTE(DECL, ATTRIBUTES, IDENTIFIER, ARGS) \\\n+  arm_pe_valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n+\n+extern union tree_node * arm_pe_merge_machine_decl_attributes ();\n+#define MERGE_MACHINE_DECL_ATTRIBUTES(OLD, NEW) \\\n+  arm_pe_merge_machine_decl_attributes ((OLD), (NEW))\n+\n+/* In addition to the stuff done in arm.h, we must mark dll symbols specially.\n+   Definitions of dllexport'd objects install some info in the .drectve\n+   section.  References to dllimport'd objects are fetched indirectly via\n+   __imp_.  If both are declared, dllexport overrides.\n+   This is also needed to implement one-only vtables: they go into their own\n+   section and we need to set DECL_SECTION_NAME so we do that here.\n+   Note that we can be called twice on the same decl.  */\n+extern void arm_pe_encode_section_info ();\n+#undef ENCODE_SECTION_INFO\n+#define ENCODE_SECTION_INFO(DECL) \\\n+  arm_pe_encode_section_info (DECL)\n+\n+     /* Utility used only in this file.  */\n+#define ARM_STRIP_NAME_ENCODING(SYM_NAME) \\\n+((SYM_NAME) + ((SYM_NAME)[0] == '@' ? 3 : 0))\n+\n+/* Strip any text from SYM_NAME added by ENCODE_SECTION_INFO and store\n+   the result in VAR.  */\n+#undef STRIP_NAME_ENCODING\n+#define STRIP_NAME_ENCODING(VAR, SYM_NAME) \\\n+(VAR) = ARM_STRIP_NAME_ENCODING (SYM_NAME)\n+\n+/* Define this macro if in some cases global symbols from one translation\n+   unit may not be bound to undefined symbols in another translation unit\n+   without user intervention.  For instance, under Microsoft Windows\n+   symbols must be explicitly imported from shared libraries (DLLs).  */\n+#define MULTIPLE_SYMBOL_SPACES\n+\n+#define UNIQUE_SECTION_P(DECL) DECL_ONE_ONLY (DECL)\n+extern void arm_pe_unique_section ();\n+#define UNIQUE_SECTION(DECL,RELOC) arm_pe_unique_section (DECL, RELOC)\n+\n+#define SUPPORTS_ONE_ONLY 1\n+\n+/* A C statement to output something to the assembler file to switch to section\n+   NAME for object DECL which is either a FUNCTION_DECL, a VAR_DECL or\n+   NULL_TREE.  Some target formats do not support arbitrary sections.  Do not\n+   define this macro in such cases.  */\n+#undef ASM_OUTPUT_SECTION_NAME\n+#define ASM_OUTPUT_SECTION_NAME(STREAM, DECL, NAME, RELOC) \t\\\n+do {\t\t\t\t\t\t\t\t\\\n+  if ((DECL) && TREE_CODE (DECL) == FUNCTION_DECL)\t\t\\\n+    fprintf (STREAM, \"\\t.section %s,\\\"x\\\"\\n\", (NAME));\t\t\\\n+  else if ((DECL) && DECL_READONLY_SECTION (DECL, RELOC))\t\\\n+    fprintf (STREAM, \"\\t.section %s,\\\"\\\"\\n\", (NAME));\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    fprintf (STREAM, \"\\t.section %s,\\\"w\\\"\\n\", (NAME));\t\t\\\n+  /* Functions may have been compiled at various levels of\t\\\n+     optimization so we can't use `same_size' here.  Instead,\t\\\n+     have the linker pick one.  */\t\t\t\t\\\n+  if ((DECL) && DECL_ONE_ONLY (DECL))\t\t\t\t\\\n+    fprintf (STREAM, \"\\t.linkonce %s\\n\",\t\t\t\\\n+\t     TREE_CODE (DECL) == FUNCTION_DECL\t\t\t\\\n+\t     ? \"discard\" : \"same_size\");\t\t\t\\\n+} while (0)\n+\f\n+/* This outputs a lot of .req's to define alias for various registers.\n+   Let's try to avoid this.  */\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(STREAM) \\\n+do {\t\t\t\t\t\t\t\t\\\n+  extern char *version_string;\t\t\t\t\t\\\n+  fprintf (STREAM, \"%s Generated by gcc %s for ARM/pe\\n\",\t\\\n+\t   ASM_COMMENT_START, version_string);\t\t\t\\\n+  output_file_directive ((STREAM), main_input_filename);\t\\\n+} while (0)\n+\n+/* Output a reference to a label.  */\n+#undef ASM_OUTPUT_LABELREF\n+#define ASM_OUTPUT_LABELREF(STREAM, NAME)  \\\n+fprintf (STREAM, \"%s%s\", USER_LABEL_PREFIX, ARM_STRIP_NAME_ENCODING (NAME))\n+\n+/* Output a function definition label.  */\n+#undef ASM_DECLARE_FUNCTION_NAME\n+#define ASM_DECLARE_FUNCTION_NAME(STREAM, NAME, DECL) \\\n+do {\t\t\t\t\t\t\t\\\n+  if (arm_dllexport_name_p (NAME))\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      drectve_section ();\t\t\t\t\\\n+      fprintf (STREAM, \"\\t.ascii \\\" -export:%s\\\"\\n\",\t\\\n+\t       ARM_STRIP_NAME_ENCODING (NAME));\t\t\\\n+      function_section (DECL);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  if (! is_called_in_ARM_mode (decl))\t\t\t\\\n+    fprintf (STREAM, \"\\t.thumb_func\\n\") ;\t\t\\\n+  else\t\t\t\t\t\t\t\\\n+    fprintf (STREAM, \"\\t.code\\t32\\n\") ;\t\t\t\\\n+  ASM_OUTPUT_LABEL ((STREAM), (NAME));\t\t\t\\\n+} while (0)\n+\n+/* Output a common block.  */\n+#undef ASM_OUTPUT_COMMON\n+#define ASM_OUTPUT_COMMON(STREAM, NAME, SIZE, ROUNDED) \\\n+do {\t\t\t\t\t\t\t\\\n+  if (arm_dllexport_name_p (NAME))\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      drectve_section ();\t\t\t\t\\\n+      fprintf ((STREAM), \"\\t.ascii \\\" -export:%s\\\"\\n\",\t\\\n+\t       ARM_STRIP_NAME_ENCODING (NAME));\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  if (! arm_dllimport_name_p (NAME))\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      fprintf ((STREAM), \"\\t.comm\\t\"); \t\t\t\\\n+      assemble_name ((STREAM), (NAME));\t\t\t\\\n+      fprintf ((STREAM), \", %d\\t%s %d\\n\",\t\t\\\n+\t       (ROUNDED), ASM_COMMENT_START, (SIZE));\t\\\n+    }\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* Output the label for an initialized variable.  */\n+#undef ASM_DECLARE_OBJECT_NAME\n+#define ASM_DECLARE_OBJECT_NAME(STREAM, NAME, DECL) \\\n+do {\t\t\t\t\t\t\t\\\n+  if (arm_dllexport_name_p (NAME))\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      enum in_section save_section = in_section;\t\\\n+      drectve_section ();\t\t\t\t\\\n+      fprintf (STREAM, \"\\t.ascii \\\" -export:%s\\\"\\n\",\t\\\n+\t       ARM_STRIP_NAME_ENCODING (NAME));\t\t\\\n+      switch_to_section (save_section, (DECL));\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  ASM_OUTPUT_LABEL ((STREAM), (NAME));\t\t\t\\\n+} while (0)\n+\f\n+/* Support the ctors/dtors and other sections.  */\n+\n+#define DRECTVE_SECTION_ASM_OP\t\"\\t.section .drectve\"\n+\n+/* A list of other sections which the compiler might be \"in\" at any\n+   given time.  */\n+\n+#undef SUBTARGET_EXTRA_SECTIONS\n+#define SUBTARGET_EXTRA_SECTIONS in_drectve,\n+\n+/* A list of extra section function definitions.  */\n+\n+#undef SUBTARGET_EXTRA_SECTION_FUNCTIONS\n+#define SUBTARGET_EXTRA_SECTION_FUNCTIONS \\\n+  DRECTVE_SECTION_FUNCTION\t\\\n+  SWITCH_TO_SECTION_FUNCTION\n+\n+#define DRECTVE_SECTION_FUNCTION \\\n+void\t\t\t\t\t\t\t\t\t\\\n+drectve_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_drectve)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", DRECTVE_SECTION_ASM_OP);\t\t\\\n+      in_section = in_drectve;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Switch to SECTION (an `enum in_section').\n+\n+   ??? This facility should be provided by GCC proper.\n+   The problem is that we want to temporarily switch sections in\n+   ASM_DECLARE_OBJECT_NAME and then switch back to the original section\n+   afterwards.  */\n+#define SWITCH_TO_SECTION_FUNCTION \\\n+void \\\n+switch_to_section (section, decl) \\\n+     enum in_section section; \\\n+     tree decl; \\\n+{ \\\n+  switch (section) \\\n+    { \\\n+      case in_text: text_section (); break; \\\n+      case in_data: data_section (); break; \\\n+      case in_named: named_section (decl, NULL, 0); break; \\\n+      case in_rdata: rdata_section (); break; \\\n+      case in_ctors: ctors_section (); break; \\\n+      case in_dtors: dtors_section (); break; \\\n+      case in_drectve: drectve_section (); break; \\\n+      default: abort (); break; \\\n+    } \\\n+}\n+\n+\n+\f\n+extern int thumb_pe_valid_machine_decl_attribute ();"}, {"sha": "7b010b5ab09069a8ff842662bdcf7be6ea2b49aa", "filename": "gcc/configure", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d3a15b4d221ef3a8f04a9fb4af825df829ce26/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d3a15b4d221ef3a8f04a9fb4af825df829ce26/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=75d3a15b4d221ef3a8f04a9fb4af825df829ce26", "patch": "@@ -4175,6 +4175,16 @@ for machine in $build $host $target; do\n \t\tmd_file=arm/thumb.md\n \t\ttmake_file=arm/t-thumb\n \t\t;;\n+\t# CYGNUS LOCAL thumb-pe/nickc\n+\tthumb-*-pe)\n+\t\ttm_file=arm/tpe.h\n+\t\tout_file=arm/thumb.c\n+\t\txm_file=arm/xm-thumb.h\n+\t\tmd_file=arm/thumb.md\n+\t\ttmake_file=arm/t-pe-thumb\n+\t\textra_objs=pe.o\n+\t\t;;\n+\t# END CYGNUS LOCAL\n # This hasn't been upgraded to GCC 2.\n #\ttron-*-*)\n #\t\tcpu_type=gmicro"}, {"sha": "70a13735fbf61eff71cbb548f82007a8aa5e8196", "filename": "gcc/configure.in", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d3a15b4d221ef3a8f04a9fb4af825df829ce26/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d3a15b4d221ef3a8f04a9fb4af825df829ce26/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=75d3a15b4d221ef3a8f04a9fb4af825df829ce26", "patch": "@@ -2492,6 +2492,16 @@ for machine in $build $host $target; do\n \t\tmd_file=arm/thumb.md\n \t\ttmake_file=arm/t-thumb\n \t\t;;\n+\t# CYGNUS LOCAL thumb-pe/nickc\n+\tthumb-*-pe)\n+\t\ttm_file=arm/tpe.h\n+\t\tout_file=arm/thumb.c\n+\t\txm_file=arm/xm-thumb.h\n+\t\tmd_file=arm/thumb.md\n+\t\ttmake_file=arm/t-pe-thumb\n+\t\textra_objs=pe.o\n+\t\t;;\n+\t# END CYGNUS LOCAL\n # This hasn't been upgraded to GCC 2.\n #\ttron-*-*)\n #\t\tcpu_type=gmicro"}]}