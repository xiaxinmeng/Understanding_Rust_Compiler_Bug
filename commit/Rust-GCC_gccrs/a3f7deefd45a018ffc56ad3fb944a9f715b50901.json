{"sha": "a3f7deefd45a018ffc56ad3fb944a9f715b50901", "node_id": "C_kwDOANBUbNoAKGEzZjdkZWVmZDQ1YTAxOGZmYzU2YWQzZmI5NDRhOWY3MTViNTA5MDE", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-11-19T16:44:02Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-11-24T06:38:27Z"}, "message": "Remove value_range_equiv.\n\nWith legacy VRP gone, value_range_equiv serves no purpose and any uses\nof it can just be replaced with value_range.\n\ngcc/ChangeLog:\n\n\t* Makefile.in: Remove value-range-equiv.o\n\t* gimple-array-bounds.cc\n\t(array_bounds_checker::array_bounds_checker): Remove comment.\n\t* tree-vrp.cc (supported_types_p): Remove use of value_range_equiv.\n\t* value-query.cc (class equiv_allocator): Same.\n\t(range_query::allocate_value_range_equiv): Remove.\n\t(range_query::free_value_range_equiv): Remove.\n\t(range_query::get_value_range): Remove.\n\t* value-query.h (class range_query): Remove get_value_range.\n\tRemove allocate_value_range_equiv.\n\tRemove free_value_range_equiv.\n\t* vr-values.cc (compare_ranges): Replace value_range_equiv with\n\tvalue_range.\n\t(simplify_using_ranges::get_vr_for_comparison): Same.\n\t(simplify_using_ranges::compare_names): Same.\n\t* vr-values.h: Remove value_range_equiv references.\n\t* value-range-equiv.cc: Removed.\n\t* value-range-equiv.h: Removed.", "tree": {"sha": "1f0d95997e23558cfc98b49875d0a2de47990484", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f0d95997e23558cfc98b49875d0a2de47990484"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3f7deefd45a018ffc56ad3fb944a9f715b50901", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3f7deefd45a018ffc56ad3fb944a9f715b50901", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3f7deefd45a018ffc56ad3fb944a9f715b50901", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3f7deefd45a018ffc56ad3fb944a9f715b50901/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca0be1bbedd6379d2645917bfff752486599b2a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca0be1bbedd6379d2645917bfff752486599b2a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca0be1bbedd6379d2645917bfff752486599b2a8"}], "stats": {"total": 564, "additions": 34, "deletions": 530}, "files": [{"sha": "fa5e5b444bb3f1e4db1c5c702ad0d91df8a0551f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3f7deefd45a018ffc56ad3fb944a9f715b50901/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3f7deefd45a018ffc56ad3fb944a9f715b50901/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=a3f7deefd45a018ffc56ad3fb944a9f715b50901", "patch": "@@ -1717,7 +1717,6 @@ OBJS = \\\n \tvalue-pointer-equiv.o \\\n \tvalue-query.o \\\n \tvalue-range.o \\\n-\tvalue-range-equiv.o \\\n \tvalue-range-pretty-print.o \\\n \tvalue-range-storage.o \\\n \tvalue-relation.o \\"}, {"sha": "1eafd3fd3e165d1bfbc89a5b5d2925076794db61", "filename": "gcc/gimple-array-bounds.cc", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3f7deefd45a018ffc56ad3fb944a9f715b50901/gcc%2Fgimple-array-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3f7deefd45a018ffc56ad3fb944a9f715b50901/gcc%2Fgimple-array-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-array-bounds.cc?ref=a3f7deefd45a018ffc56ad3fb944a9f715b50901", "patch": "@@ -46,9 +46,6 @@ array_bounds_checker::array_bounds_checker (struct function *func,\n   /* No-op.  */\n }\n \n-// This purposely returns a value_range, not a value_range_equiv, to\n-// break the dependency on equivalences for this pass.\n-\n const value_range *\n array_bounds_checker::get_value_range (const_tree op, gimple *stmt)\n {"}, {"sha": "df2f1eae203245dd4c80acd8d4fd1b101ea99364", "filename": "gcc/tree-vrp.cc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3f7deefd45a018ffc56ad3fb944a9f715b50901/gcc%2Ftree-vrp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3f7deefd45a018ffc56ad3fb944a9f715b50901/gcc%2Ftree-vrp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.cc?ref=a3f7deefd45a018ffc56ad3fb944a9f715b50901", "patch": "@@ -582,10 +582,9 @@ compare_values (tree val1, tree val2)\n static bool\n supported_types_p (value_range *vr,\n \t\t   tree type0,\n-\t\t   tree type1 = NULL)\n+\t\t   tree = NULL)\n {\n-  if (!value_range_equiv::supports_p (type0)\n-      || (type1 && !value_range_equiv::supports_p (type1)))\n+  if (!value_range::supports_p (type0))\n     {\n       vr->set_varying (type0);\n       return false;"}, {"sha": "f89225d748a392e25d1ad5206fbc43eaea905367", "filename": "gcc/value-query.cc", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3f7deefd45a018ffc56ad3fb944a9f715b50901/gcc%2Fvalue-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3f7deefd45a018ffc56ad3fb944a9f715b50901/gcc%2Fvalue-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-query.cc?ref=a3f7deefd45a018ffc56ad3fb944a9f715b50901", "patch": "@@ -28,7 +28,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ssa.h\"\n #include \"tree-pretty-print.h\"\n #include \"fold-const.h\"\n-#include \"value-range-equiv.h\"\n #include \"value-query.h\"\n #include \"alloc-pool.h\"\n #include \"gimple-range.h\"\n@@ -143,34 +142,22 @@ range_query::dump (FILE *)\n {\n }\n \n-// valuation_query support routines for value_range_equiv's.\n+// valuation_query support routines for value_range's.\n \n-class equiv_allocator : public object_allocator<value_range_equiv>\n+class equiv_allocator : public object_allocator<value_range>\n {\n public:\n   equiv_allocator ()\n-    : object_allocator<value_range_equiv> (\"equiv_allocator pool\") { }\n+    : object_allocator<value_range> (\"equiv_allocator pool\") { }\n };\n \n-value_range_equiv *\n-range_query::allocate_value_range_equiv ()\n-{\n-  return new (equiv_alloc->allocate ()) value_range_equiv;\n-}\n-\n-void\n-range_query::free_value_range_equiv (value_range_equiv *v)\n-{\n-  equiv_alloc->remove (v);\n-}\n-\n-const class value_range_equiv *\n+const value_range *\n range_query::get_value_range (const_tree expr, gimple *stmt)\n {\n   int_range_max r;\n   if (range_of_expr (r, const_cast<tree> (expr), stmt))\n-    return new (equiv_alloc->allocate ()) value_range_equiv (r);\n-  return new (equiv_alloc->allocate ()) value_range_equiv (TREE_TYPE (expr));\n+    return new (equiv_alloc->allocate ()) value_range (r);\n+  return new (equiv_alloc->allocate ()) value_range (TREE_TYPE (expr));\n }\n \n range_query::range_query ()"}, {"sha": "b860d66df20f66c044ed8b7caf0482002c0f34d2", "filename": "gcc/value-query.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3f7deefd45a018ffc56ad3fb944a9f715b50901/gcc%2Fvalue-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3f7deefd45a018ffc56ad3fb944a9f715b50901/gcc%2Fvalue-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-query.h?ref=a3f7deefd45a018ffc56ad3fb944a9f715b50901", "patch": "@@ -106,13 +106,10 @@ class range_query : public value_query\n \n   // DEPRECATED: This method is used from vr-values.  The plan is to\n   // rewrite all uses of it to the above API.\n-  virtual const class value_range_equiv *get_value_range (const_tree,\n-\t\t\t\t\t\t\t  gimple * = NULL);\n+  virtual const value_range *get_value_range (const_tree, gimple * = NULL);\n   virtual void dump (FILE *);\n \n protected:\n-  class value_range_equiv *allocate_value_range_equiv ();\n-  void free_value_range_equiv (class value_range_equiv *);\n   bool get_tree_range (vrange &v, tree expr, gimple *stmt);\n   bool get_arith_expr_range (vrange &r, tree expr, gimple *stmt);\n   relation_oracle *m_oracle;"}, {"sha": "bd58e5a90bc7fa41c5c03fda5efc696d961741cb", "filename": "gcc/value-range-equiv.cc", "status": "removed", "additions": 0, "deletions": 330, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0be1bbedd6379d2645917bfff752486599b2a8/gcc%2Fvalue-range-equiv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0be1bbedd6379d2645917bfff752486599b2a8/gcc%2Fvalue-range-equiv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range-equiv.cc?ref=ca0be1bbedd6379d2645917bfff752486599b2a8", "patch": "@@ -1,330 +0,0 @@\n-/* Support routines for value ranges with equivalences.\n-   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"backend.h\"\n-#include \"tree.h\"\n-#include \"gimple.h\"\n-#include \"ssa.h\"\n-#include \"tree-pretty-print.h\"\n-#include \"value-range-equiv.h\"\n-\n-value_range_equiv::value_range_equiv (tree min, tree max, bitmap equiv,\n-\t\t\t\t      value_range_kind kind)\n-{\n-  m_equiv = NULL;\n-  set (min, max, equiv, kind);\n-}\n-\n-value_range_equiv::value_range_equiv (const value_range &other)\n-{\n-  m_equiv = NULL;\n-  set (other.min(), other.max (), NULL, other.kind ());\n-}\n-\n-void\n-value_range_equiv::set (tree min, tree max, bitmap equiv,\n-\t\t\tvalue_range_kind kind)\n-{\n-  value_range::set (min, max, kind);\n-  set_equiv (equiv);\n-  if (flag_checking)\n-    check ();\n-}\n-\n-void\n-value_range_equiv::set (tree min, tree max, value_range_kind kind)\n-{\n-  set (min, max, m_equiv, kind);\n-}\n-\n-void\n-value_range_equiv::set (tree val)\n-{\n-  gcc_assert (TREE_CODE (val) == SSA_NAME || is_gimple_min_invariant (val));\n-  if (TREE_OVERFLOW_P (val))\n-    val = drop_tree_overflow (val);\n-  set (val, val);\n-}\n-\n-void\n-value_range_equiv::set_undefined ()\n-{\n-  set (NULL, NULL, NULL, VR_UNDEFINED);\n-}\n-\n-void\n-value_range_equiv::set_varying (tree type)\n-{\n-  value_range::set_varying (type);\n-  equiv_clear ();\n-}\n-\n-/* Like set, but keep the equivalences in place.  */\n-\n-void\n-value_range_equiv::update (tree min, tree max, value_range_kind kind)\n-{\n-  set (min, max,\n-       (kind != VR_UNDEFINED && kind != VR_VARYING) ? m_equiv : NULL, kind);\n-}\n-\n-/* Copy value_range in FROM into THIS while avoiding bitmap sharing.\n-\n-   Note: The code that avoids the bitmap sharing looks at the existing\n-   this->m_equiv, so this function cannot be used to initalize an\n-   object.  Use the constructors for initialization.  */\n-\n-void\n-value_range_equiv::deep_copy (const value_range_equiv *from)\n-{\n-  set (from->min (), from->max (), from->m_equiv, from->kind ());\n-}\n-\n-void\n-value_range_equiv::move (value_range_equiv *from)\n-{\n-  set (from->min (), from->max (), NULL, from->kind ());\n-  m_equiv = from->m_equiv;\n-  from->m_equiv = NULL;\n-}\n-\n-void\n-value_range_equiv::set_equiv (bitmap equiv)\n-{\n-  if (undefined_p () || varying_p ())\n-    equiv = NULL;\n-  /* Since updating the equivalence set involves deep copying the\n-     bitmaps, only do it if absolutely necessary.\n-\n-     All equivalence bitmaps are allocated from the same obstack.  So\n-     we can use the obstack associated with EQUIV to allocate vr->equiv.  */\n-  if (m_equiv == NULL\n-      && equiv != NULL)\n-    m_equiv = BITMAP_ALLOC (equiv->obstack);\n-\n-  if (equiv != m_equiv)\n-    {\n-      if (equiv && !bitmap_empty_p (equiv))\n-\tbitmap_copy (m_equiv, equiv);\n-      else\n-\tbitmap_clear (m_equiv);\n-    }\n-}\n-\n-void\n-value_range_equiv::check ()\n-{\n-  value_range::verify_range ();\n-  switch (kind ())\n-    {\n-    case VR_UNDEFINED:\n-    case VR_VARYING:\n-      gcc_assert (!m_equiv || bitmap_empty_p (m_equiv));\n-    default:;\n-    }\n-}\n-\n-/* Return true if the bitmaps B1 and B2 are equal.  */\n-\n-static bool\n-vr_bitmap_equal_p (const_bitmap b1, const_bitmap b2)\n-{\n-  return (b1 == b2\n-\t  || ((!b1 || bitmap_empty_p (b1))\n-\t      && (!b2 || bitmap_empty_p (b2)))\n-\t  || (b1 && b2\n-\t      && bitmap_equal_p (b1, b2)));\n-}\n-\n-/* Returns TRUE if THIS == OTHER.  Ignores the equivalence bitmap if\n-   IGNORE_EQUIVS is TRUE.  */\n-\n-bool\n-value_range_equiv::equal_p (const value_range_equiv &other,\n-\t\t\t    bool ignore_equivs) const\n-{\n-  return (value_range::operator== (other)\n-\t  && (ignore_equivs || vr_bitmap_equal_p (m_equiv, other.m_equiv)));\n-}\n-\n-void\n-value_range_equiv::equiv_clear ()\n-{\n-  if (m_equiv)\n-    bitmap_clear (m_equiv);\n-}\n-\n-/* Add VAR and VAR's equivalence set (VAR_VR) to the equivalence\n-   bitmap.  If no equivalence table has been created, OBSTACK is the\n-   obstack to use (NULL for the default obstack).\n-\n-   This is the central point where equivalence processing can be\n-   turned on/off.  */\n-\n-void\n-value_range_equiv::equiv_add (const_tree var,\n-\t\t\t      const value_range_equiv *var_vr,\n-\t\t\t      bitmap_obstack *obstack)\n-{\n-  if (!m_equiv)\n-    m_equiv = BITMAP_ALLOC (obstack);\n-  unsigned ver = SSA_NAME_VERSION (var);\n-  bitmap_set_bit (m_equiv, ver);\n-  if (var_vr && var_vr->m_equiv)\n-    bitmap_ior_into (m_equiv, var_vr->m_equiv);\n-}\n-\n-void\n-value_range_equiv::legacy_verbose_intersect (const value_range_equiv *other)\n-{\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"Intersecting\\n  \");\n-      dump_value_range (dump_file, this);\n-      fprintf (dump_file, \"\\nand\\n  \");\n-      dump_value_range (dump_file, other);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-\n-  /* If THIS is varying we want to pick up equivalences from OTHER.\n-     Just special-case this here rather than trying to fixup after the\n-     fact.  */\n-  if (this->varying_p ())\n-    this->deep_copy (other);\n-  else\n-    {\n-      legacy_intersect (this, other);\n-      if (varying_p () || undefined_p ())\n-\tequiv_clear ();\n-\n-      /* If the result is VR_UNDEFINED there is no need to mess with\n-\t equivalencies.  */\n-      if (!undefined_p ())\n-\t{\n-\t  /* The resulting set of equivalences for range intersection\n-\t     is the union of the two sets.  */\n-\t  if (m_equiv && other->m_equiv && m_equiv != other->m_equiv)\n-\t    bitmap_ior_into (m_equiv, other->m_equiv);\n-\t  else if (other->m_equiv && !m_equiv)\n-\t    {\n-\t      /* All equivalence bitmaps are allocated from the same\n-\t\t obstack.  So we can use the obstack associated with\n-\t\t VR to allocate this->m_equiv.  */\n-\t      m_equiv = BITMAP_ALLOC (other->m_equiv->obstack);\n-\t      bitmap_copy (m_equiv, other->m_equiv);\n-\t    }\n-\t}\n-    }\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"to\\n  \");\n-      dump_value_range (dump_file, this);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-}\n-\n-void\n-value_range_equiv::legacy_verbose_union_ (const value_range_equiv *other)\n-{\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"Meeting\\n  \");\n-      dump_value_range (dump_file, this);\n-      fprintf (dump_file, \"\\nand\\n  \");\n-      dump_value_range (dump_file, other);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-\n-  /* If THIS is undefined we want to pick up equivalences from OTHER.\n-     Just special-case this here rather than trying to fixup after the fact.  */\n-  if (this->undefined_p ())\n-    this->deep_copy (other);\n-  else\n-    {\n-      legacy_union (this, other);\n-      if (varying_p () || undefined_p ())\n-\tequiv_clear ();\n-\n-      /* The resulting set of equivalences is always the intersection of\n-\t the two sets.  */\n-      if (this->m_equiv && other->m_equiv && this->m_equiv != other->m_equiv)\n-\tbitmap_and_into (this->m_equiv, other->m_equiv);\n-      else if (this->m_equiv && !other->m_equiv)\n-\tbitmap_clear (this->m_equiv);\n-    }\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"to\\n  \");\n-      dump_value_range (dump_file, this);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-}\n-\n-void\n-value_range_equiv::dump (FILE *file) const\n-{\n-  value_range::dump (file);\n-  if ((kind () == VR_RANGE || kind () == VR_ANTI_RANGE)\n-      && m_equiv)\n-    {\n-      bitmap_iterator bi;\n-      unsigned i, c = 0;\n-\n-      fprintf (file, \"  EQUIVALENCES: { \");\n-      EXECUTE_IF_SET_IN_BITMAP (m_equiv, 0, i, bi)\n-\t{\n-\t  print_generic_expr (file, ssa_name (i));\n-\t  fprintf (file, \" \");\n-\t  c++;\n-\t}\n-      fprintf (file, \"} (%u elements)\", c);\n-    }\n-}\n-\n-void\n-value_range_equiv::dump () const\n-{\n-  dump (stderr);\n-}\n-\n-void\n-dump_value_range (FILE *file, const value_range_equiv *vr)\n-{\n-  if (!vr)\n-    fprintf (file, \"[]\");\n-  else\n-    vr->dump (file);\n-}\n-\n-DEBUG_FUNCTION void\n-debug (const value_range_equiv *vr)\n-{\n-  dump_value_range (stderr, vr);\n-}\n-\n-DEBUG_FUNCTION void\n-debug (const value_range_equiv &vr)\n-{\n-  dump_value_range (stderr, &vr);\n-}"}, {"sha": "1a8014df8342d12ac57c16adcbe961df96440b96", "filename": "gcc/value-range-equiv.h", "status": "removed", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0be1bbedd6379d2645917bfff752486599b2a8/gcc%2Fvalue-range-equiv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0be1bbedd6379d2645917bfff752486599b2a8/gcc%2Fvalue-range-equiv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range-equiv.h?ref=ca0be1bbedd6379d2645917bfff752486599b2a8", "patch": "@@ -1,90 +0,0 @@\n-/* Support routines for value ranges with equivalences.\n-   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_VALUE_RANGE_EQUIV_H\n-#define GCC_VALUE_RANGE_EQUIV_H\n-\n-#include \"value-range.h\"\n-\n-/* Note value_range_equiv cannot currently be used with GC memory,\n-   only value_range is fully set up for this.  */\n-class GTY((user)) value_range_equiv : public value_range\n-{\n- public:\n-  value_range_equiv () : value_range () { m_equiv = NULL; }\n-  value_range_equiv (const value_range &);\n-  /* Deep-copies equiv bitmap argument.  */\n-  value_range_equiv (tree, tree, bitmap = NULL, value_range_kind = VR_RANGE);\n-\n-  /* Shallow-copies equiv bitmap.  */\n-  value_range_equiv (const value_range_equiv &) /* = delete */;\n-  /* Shallow-copies equiv bitmap.  */\n-  value_range_equiv& operator=(const value_range_equiv &) /* = delete */;\n-\n-  /* Virtual destructor.  */\n-  virtual ~value_range_equiv () = default;\n-\n-  /* Move equiv bitmap from source range.  */\n-  void move (value_range_equiv *);\n-\n-  /* Leaves equiv bitmap alone.  */\n-  virtual void set (tree, tree, value_range_kind = VR_RANGE) override;\n-  void update (tree, tree, value_range_kind = VR_RANGE);\n-  /* Deep-copies equiv bitmap argument.  */\n-  void set (tree, tree, bitmap, value_range_kind = VR_RANGE);\n-  void set (tree);\n-\n-  bool operator== (const value_range_equiv &) const /* = delete */;\n-  bool operator!= (const value_range_equiv &) const /* = delete */;\n-  void legacy_verbose_intersect (const value_range_equiv *);\n-  void legacy_verbose_union_ (const value_range_equiv *);\n-  bool equal_p (const value_range_equiv &, bool ignore_equivs) const;\n-\n-  /* Types of value ranges.  */\n-  void set_undefined () override;\n-  void set_varying (tree) override;\n-\n-  /* Equivalence bitmap methods.  */\n-  bitmap equiv () const { return m_equiv; }\n-  void equiv_clear ();\n-  void equiv_add (const_tree, const value_range_equiv *,\n-\t\t  bitmap_obstack * = NULL);\n-\n-  /* Misc methods.  */\n-  void deep_copy (const value_range_equiv *);\n-  void dump (FILE *) const;\n-  void dump () const;\n-  static bool supports_p (tree type)\n-  {\n-    return INTEGRAL_TYPE_P (type) || POINTER_TYPE_P (type);\n-  }\n-\n- private:\n-  /* Deep-copies bitmap argument.  */\n-  void set_equiv (bitmap);\n-  void check ();\n-\n-  /* Set of SSA names whose value ranges are equivalent to this one.\n-     This set is only valid when TYPE is VR_RANGE or VR_ANTI_RANGE.  */\n-  bitmap m_equiv;\n-};\n-\n-extern void dump_value_range (FILE *, const value_range_equiv *);\n-\n-#endif // GCC_VALUE_RANGE_EQUIV_H"}, {"sha": "5b12a776c6a7bd3cc14fc7222b91a846b5e22835", "filename": "gcc/vr-values.cc", "status": "modified", "additions": 23, "deletions": 75, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3f7deefd45a018ffc56ad3fb944a9f715b50901/gcc%2Fvr-values.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3f7deefd45a018ffc56ad3fb944a9f715b50901/gcc%2Fvr-values.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.cc?ref=a3f7deefd45a018ffc56ad3fb944a9f715b50901", "patch": "@@ -215,8 +215,8 @@ check_for_binary_op_overflow (range_query *query,\n \n \n static tree\n-compare_ranges (enum tree_code comp, const value_range_equiv *vr0,\n-\t\tconst value_range_equiv *vr1, bool *strict_overflow_p)\n+compare_ranges (enum tree_code comp, const value_range *vr0,\n+\t\tconst value_range *vr1, bool *strict_overflow_p)\n {\n   /* VARYING or UNDEFINED ranges cannot be compared.  */\n   if (vr0->varying_p ()\n@@ -619,19 +619,20 @@ bounds_of_var_in_loop (tree *min, tree *max, range_query *query,\n    or a symbolic range containing the SSA_NAME only if the value range\n    is varying or undefined.  Uses TEM as storage for the alternate range.  */\n \n-const value_range_equiv *\n-simplify_using_ranges::get_vr_for_comparison (int i, value_range_equiv *tem,\n+const value_range *\n+simplify_using_ranges::get_vr_for_comparison (int i, value_range *tem,\n \t\t\t\t\t      gimple *s)\n {\n   /* Shallow-copy equiv bitmap.  */\n-  const value_range_equiv *vr = query->get_value_range (ssa_name (i), s);\n+  const value_range *vr = query->get_value_range (ssa_name (i), s);\n \n   /* If name N_i does not have a valid range, use N_i as its own\n      range.  This allows us to compare against names that may\n      have N_i in their ranges.  */\n   if (vr->varying_p () || vr->undefined_p ())\n     {\n-      tem->set (ssa_name (i));\n+      tree ssa = ssa_name (i);\n+      tem->set (ssa, ssa);\n       return tem;\n     }\n \n@@ -646,77 +647,26 @@ simplify_using_ranges::get_vr_for_comparison (int i, value_range_equiv *tem,\n tree\n simplify_using_ranges::compare_name_with_value\n \t\t\t\t(enum tree_code comp, tree var, tree val,\n-\t\t\t\t bool *strict_overflow_p, bool use_equiv_p,\n-\t\t\t\t gimple *s)\n+\t\t\t\t bool *strict_overflow_p, gimple *s)\n {\n-  /* Get the set of equivalences for VAR.  */\n-  bitmap e = query->get_value_range (var, s)->equiv ();\n-\n   /* Start at -1.  Set it to 0 if we do a comparison without relying\n      on overflow, or 1 if all comparisons rely on overflow.  */\n   int used_strict_overflow = -1;\n \n   /* Compare vars' value range with val.  */\n-  value_range_equiv tem_vr;\n-  const value_range_equiv *equiv_vr\n+  value_range tem_vr;\n+  const value_range *equiv_vr\n     = get_vr_for_comparison (SSA_NAME_VERSION (var), &tem_vr, s);\n   bool sop = false;\n   tree retval = compare_range_with_value (comp, equiv_vr, val, &sop);\n   if (retval)\n     used_strict_overflow = sop ? 1 : 0;\n \n-  /* If the equiv set is empty we have done all work we need to do.  */\n-  if (e == NULL)\n-    {\n-      if (retval && used_strict_overflow > 0)\n-\t*strict_overflow_p = true;\n-      return retval;\n-    }\n-\n-  unsigned i;\n-  bitmap_iterator bi;\n-  EXECUTE_IF_SET_IN_BITMAP (e, 0, i, bi)\n-    {\n-      tree name = ssa_name (i);\n-      if (!name)\n-\tcontinue;\n-\n-      if (!use_equiv_p\n-\t  && !SSA_NAME_IS_DEFAULT_DEF (name)\n-\t  && prop_simulate_again_p (SSA_NAME_DEF_STMT (name)))\n-\tcontinue;\n-\n-      equiv_vr = get_vr_for_comparison (i, &tem_vr, s);\n-      sop = false;\n-      tree t = compare_range_with_value (comp, equiv_vr, val, &sop);\n-      if (t)\n-\t{\n-\t  /* If we get different answers from different members\n-\t     of the equivalence set this check must be in a dead\n-\t     code region.  Folding it to a trap representation\n-\t     would be correct here.  For now just return don't-know.  */\n-\t  if (retval != NULL\n-\t      && t != retval)\n-\t    {\n-\t      retval = NULL_TREE;\n-\t      break;\n-\t    }\n-\t  retval = t;\n-\n-\t  if (!sop)\n-\t    used_strict_overflow = 0;\n-\t  else if (used_strict_overflow < 0)\n-\t    used_strict_overflow = 1;\n-\t}\n-    }\n-\n   if (retval && used_strict_overflow > 0)\n     *strict_overflow_p = true;\n-\n   return retval;\n }\n \n-\n /* Given a comparison code COMP and names N1 and N2, compare all the\n    ranges equivalent to N1 against all the ranges equivalent to N2\n    to determine the value of N1 COMP N2.  Return the same value\n@@ -728,10 +678,10 @@ tree\n simplify_using_ranges::compare_names (enum tree_code comp, tree n1, tree n2,\n \t\t\t\t      bool *strict_overflow_p, gimple *s)\n {\n-  /* Compare the ranges of every name equivalent to N1 against the\n-     ranges of every name equivalent to N2.  */\n-  bitmap e1 = query->get_value_range (n1, s)->equiv ();\n-  bitmap e2 = query->get_value_range (n2, s)->equiv ();\n+  /* ?? These bitmaps are NULL as there are no longer any equivalences\n+     available in the value_range*.  */\n+  bitmap e1 = NULL;\n+  bitmap e2 = NULL;\n \n   /* Use the fake bitmaps if e1 or e2 are not available.  */\n   static bitmap s_e1 = NULL, s_e2 = NULL;\n@@ -780,8 +730,8 @@ simplify_using_ranges::compare_names (enum tree_code comp, tree n1, tree n2,\n       if (!ssa_name (i1))\n \tcontinue;\n \n-      value_range_equiv tem_vr1;\n-      const value_range_equiv *vr1 = get_vr_for_comparison (i1, &tem_vr1, s);\n+      value_range tem_vr1;\n+      const value_range *vr1 = get_vr_for_comparison (i1, &tem_vr1, s);\n \n       tree t = NULL_TREE, retval = NULL_TREE;\n       bitmap_iterator bi2;\n@@ -793,9 +743,8 @@ simplify_using_ranges::compare_names (enum tree_code comp, tree n1, tree n2,\n \n \t  bool sop = false;\n \n-\t  value_range_equiv tem_vr2;\n-\t  const value_range_equiv *vr2 = get_vr_for_comparison (i2, &tem_vr2,\n-\t\t\t\t\t\t\t\ts);\n+\t  value_range tem_vr2;\n+\t  const value_range *vr2 = get_vr_for_comparison (i2, &tem_vr2, s);\n \n \t  t = compare_ranges (comp, vr1, vr2, &sop);\n \t  if (t)\n@@ -844,7 +793,7 @@ simplify_using_ranges::vrp_evaluate_conditional_warnv_with_ops_using_ranges\n     (enum tree_code code, tree op0, tree op1, bool * strict_overflow_p,\n      gimple *s)\n {\n-  const value_range_equiv *vr0, *vr1;\n+  const value_range *vr0, *vr1;\n   vr0 = (TREE_CODE (op0) == SSA_NAME) ? query->get_value_range (op0, s) : NULL;\n   vr1 = (TREE_CODE (op1) == SSA_NAME) ? query->get_value_range (op1, s) : NULL;\n \n@@ -925,7 +874,7 @@ simplify_using_ranges::vrp_evaluate_conditional_warnv_with_ops\n \t    }\n \t  else\n \t    gcc_unreachable ();\n-\t  const value_range_equiv *vr0 = query->get_value_range (op0, stmt);\n+\t  const value_range *vr0 = query->get_value_range (op0, stmt);\n \t  /* If vro, the range for OP0 to pass the overflow test, has\n \t     no intersection with *vr0, OP0's known range, then the\n \t     overflow test can't pass, so return the node for false.\n@@ -955,11 +904,10 @@ simplify_using_ranges::vrp_evaluate_conditional_warnv_with_ops\n       && use_equiv_p)\n     return compare_names (code, op0, op1, strict_overflow_p, stmt);\n   else if (TREE_CODE (op0) == SSA_NAME)\n-    return compare_name_with_value (code, op0, op1,\n-\t\t\t\t    strict_overflow_p, use_equiv_p, stmt);\n+    return compare_name_with_value (code, op0, op1, strict_overflow_p, stmt);\n   else if (TREE_CODE (op1) == SSA_NAME)\n     return compare_name_with_value (swap_tree_comparison (code), op1, op0,\n-\t\t\t\t    strict_overflow_p, use_equiv_p, stmt);\n+\t\t\t\t    strict_overflow_p, stmt);\n   return NULL_TREE;\n }\n \n@@ -1250,7 +1198,7 @@ simplify_using_ranges::simplify_div_or_mod_using_ranges\n   if (rhs_code == TRUNC_MOD_EXPR\n       && TREE_CODE (op1) == SSA_NAME)\n     {\n-      const value_range_equiv *vr1 = query->get_value_range (op1, stmt);\n+      const value_range *vr1 = query->get_value_range (op1, stmt);\n       if (range_int_cst_p (vr1))\n \top1min = vr1->min ();\n     }"}, {"sha": "9804aaf83d14c326b145ffaad62289f49e619a51", "filename": "gcc/vr-values.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3f7deefd45a018ffc56ad3fb944a9f715b50901/gcc%2Fvr-values.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3f7deefd45a018ffc56ad3fb944a9f715b50901/gcc%2Fvr-values.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.h?ref=a3f7deefd45a018ffc56ad3fb944a9f715b50901", "patch": "@@ -20,7 +20,6 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_VR_VALUES_H\n #define GCC_VR_VALUES_H\n \n-#include \"value-range-equiv.h\"\n #include \"value-query.h\"\n \n // Abstract class to return a range for a given SSA.\n@@ -54,11 +53,9 @@ class simplify_using_ranges\n \n   bool two_valued_val_range_p (tree, tree *, tree *, gimple *);\n   bool op_with_boolean_value_range_p (tree, gimple *);\n-  tree compare_name_with_value (enum tree_code, tree, tree, bool *, bool,\n-\t\t\t\tgimple *);\n+  tree compare_name_with_value (enum tree_code, tree, tree, bool *, gimple *);\n   tree compare_names (enum tree_code, tree, tree, bool *, gimple *s);\n-  const value_range_equiv *get_vr_for_comparison (int, value_range_equiv *,\n-\t\t\t\t\t\t  gimple *s);\n+  const value_range *get_vr_for_comparison (int, value_range *, gimple *s);\n   tree vrp_evaluate_conditional_warnv_with_ops_using_ranges (enum tree_code,\n \t\t\t\t\t\t\t     tree, tree,\n \t\t\t\t\t\t\t     bool *, gimple *s);"}]}