{"sha": "644d195145f7e535d426494e1f6a8a68aa0cb7a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQ0ZDE5NTE0NWY3ZTUzNWQ0MjY0OTRlMWY2YThhNjhhYTBjYjdhOA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-06-28T11:07:23Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-06-28T11:07:23Z"}, "message": "re PR c++/16174 (deducing top-level consts)\n\ncp:\n\tPR C++/16174\n\t* call.c (build_temp): Declare.\n\t(check_constructor_callable): New.\n\t(reference_binding): Only set CHECK_COPY_CONSTRUCTOR if not for\n\tCONSTRUCTOR_CALLABLE.\n\t(convert_like_real, initialize_reference): Use\n\tcheck_constructor_callable.\n\t* cp-tree.h (LOOKUP_CONSTRUCTOR_CALLABLE): New.\n\t(LOOKUP_*): Renumber.\ntestsuite:\n\t* PR C++/16174\n\t* g++.dg/template/ctor4.C: New.\n\nFrom-SVN: r83775", "tree": {"sha": "394b2c49cada83d43d85f498c43b298287f0e424", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/394b2c49cada83d43d85f498c43b298287f0e424"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/644d195145f7e535d426494e1f6a8a68aa0cb7a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/644d195145f7e535d426494e1f6a8a68aa0cb7a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/644d195145f7e535d426494e1f6a8a68aa0cb7a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/644d195145f7e535d426494e1f6a8a68aa0cb7a8/comments", "author": null, "committer": null, "parents": [{"sha": "a301e965cca8ec15a361fc5e3dd6886b9161a20c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a301e965cca8ec15a361fc5e3dd6886b9161a20c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a301e965cca8ec15a361fc5e3dd6886b9161a20c"}], "stats": {"total": 126, "additions": 91, "deletions": 35}, "files": [{"sha": "74d845710ac46e02118ef903b473f0ba16e596d2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644d195145f7e535d426494e1f6a8a68aa0cb7a8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644d195145f7e535d426494e1f6a8a68aa0cb7a8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=644d195145f7e535d426494e1f6a8a68aa0cb7a8", "patch": "@@ -1,5 +1,15 @@\n 2004-06-28  Nathan Sidwell  <nathan@codesourcery.com>\n \n+\tPR C++/16174\n+\t* call.c (build_temp): Declare.\n+\t(check_constructor_callable): New.\n+\t(reference_binding): Only set CHECK_COPY_CONSTRUCTOR if not for\n+\tCONSTRUCTOR_CALLABLE.\n+\t(convert_like_real, initialize_reference): Use\n+\tcheck_constructor_callable.\n+\t* cp-tree.h (LOOKUP_CONSTRUCTOR_CALLABLE): New.\n+\t(LOOKUP_*): Renumber.\n+\n \t* friend.c (add_friend): Only perform access checks when context\n \tis a class.\n \t* lex.c (cxx_make_type): Only create a binfo for aggregate types."}, {"sha": "207d7585f8806f568b88068c43209732c6dbfcbc", "filename": "gcc/cp/call.c", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644d195145f7e535d426494e1f6a8a68aa0cb7a8/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644d195145f7e535d426494e1f6a8a68aa0cb7a8/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=644d195145f7e535d426494e1f6a8a68aa0cb7a8", "patch": "@@ -188,6 +188,8 @@ static void add_candidates (tree, tree, tree, bool, tree, tree,\n \t\t\t    int, struct z_candidate **);\n static conversion *merge_conversion_sequences (conversion *, conversion *);\n static bool magic_varargs_p (tree);\n+static tree build_temp (tree, tree, int, void (**)(const char *, ...));\n+static void check_constructor_callable (tree, tree);\n \n tree\n build_vfield_ref (tree datum, tree type)\n@@ -1190,7 +1192,8 @@ reference_binding (tree rto, tree rfrom, tree expr, int flags)\n     {\n       conv = build_identity_conv (from, expr);\n       conv = direct_reference_binding (rto, conv);\n-      conv->u.next->check_copy_constructor_p = true;\n+      if (!(flags & LOOKUP_CONSTRUCTOR_CALLABLE))\n+\tconv->u.next->check_copy_constructor_p = true;\n       return conv;\n     }\n \n@@ -4063,6 +4066,20 @@ enforce_access (tree basetype_path, tree decl)\n   return true;\n }\n \n+/* Check that a callable constructor to initialize a temporary of\n+   TYPE from an EXPR exists.  */\n+\n+static void\n+check_constructor_callable (tree type, tree expr)\n+{\n+  build_special_member_call (NULL_TREE,\n+\t\t\t     complete_ctor_identifier,\n+\t\t\t     build_tree_list (NULL_TREE, expr), \n+\t\t\t     TYPE_BINFO (type),\n+\t\t\t     LOOKUP_NORMAL | LOOKUP_ONLYCONVERTING\n+\t\t\t     | LOOKUP_CONSTRUCTOR_CALLABLE);\n+}\n+\n /* Initialize a temporary of type TYPE with EXPR.  The FLAGS are a\n    bitwise or of LOOKUP_* values.  If any errors are warnings are\n    generated, set *DIAGNOSTIC_FN to \"error\" or \"warning\",\n@@ -4074,9 +4091,9 @@ build_temp (tree expr, tree type, int flags,\n \t    void (**diagnostic_fn)(const char *, ...))\n {\n   int savew, savee;\n-\n+  \n   savew = warningcount, savee = errorcount;\n-  expr = build_special_member_call (NULL_TREE, \n+  expr = build_special_member_call (NULL_TREE,\n \t\t\t\t    complete_ctor_identifier,\n \t\t\t\t    build_tree_list (NULL_TREE, expr), \n \t\t\t\t    TYPE_BINFO (type),\n@@ -4209,12 +4226,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t  && TREE_CODE (TREE_TYPE (expr)) != ARRAY_TYPE)\n \texpr = decl_constant_value (expr);\n       if (convs->check_copy_constructor_p)\n-\t/* Generate a temporary copy purely to generate the required\n-\t   diagnostics.  */\n-\tbuild_temp\n-\t  (build_dummy_object\n-\t   (build_qualified_type (totype, TYPE_QUAL_CONST)),\n-\t   totype, LOOKUP_NORMAL|LOOKUP_ONLYCONVERTING, &diagnostic_fn);\n+\tcheck_constructor_callable (totype, expr);\n \treturn expr;\n     case ck_ambig:\n       /* Call build_user_type_conversion again for the error.  */\n@@ -4243,12 +4255,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t  /* We are going to bind a reference directly to a base-class\n \t     subobject of EXPR.  */\n \t  if (convs->check_copy_constructor_p)\n-\t    /* Generate a temporary copy purely to generate the required\n-\t       diagnostics.  */\n-\t    build_temp (build_dummy_object (TREE_TYPE (expr)),\n-\t\t\tTREE_TYPE (expr),\n-\t\t\tLOOKUP_NORMAL|LOOKUP_ONLYCONVERTING,\n-\t\t\t&diagnostic_fn);\n+\t    check_constructor_callable (TREE_TYPE (expr), expr);\n \t  /* Build an expression for `*((base*) &expr)'.  */\n \t  expr = build_unary_op (ADDR_EXPR, expr, 0);\n \t  expr = perform_implicit_conversion (build_pointer_type (totype), \n@@ -6426,14 +6433,8 @@ initialize_reference (tree type, tree expr, tree decl, tree *cleanup)\n \t remember that the conversion was required.  */\n       if (conv->kind == ck_base && conv->need_temporary_p)\n \t{\n-\t  void (*diagnostic_fn) (const char *, ...);\n \t  if (conv->check_copy_constructor_p)\n-\t    /* Generate a temporary copy purely to generate the required\n-\t       diagnostics.  */\n-\t    build_temp (build_dummy_object (TREE_TYPE (expr)),\n-\t\t\tTREE_TYPE (expr),\n-\t\t\tLOOKUP_NORMAL|LOOKUP_ONLYCONVERTING,\n-\t\t\t&diagnostic_fn);\n+ \t    check_constructor_callable (TREE_TYPE (expr), expr);\n \t  base_conv_type = conv->type;\n \t  conv = conv->u.next;\n \t}"}, {"sha": "23e660e0a4d4ee4183979595a0f785e6e6047b23", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644d195145f7e535d426494e1f6a8a68aa0cb7a8/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644d195145f7e535d426494e1f6a8a68aa0cb7a8/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=644d195145f7e535d426494e1f6a8a68aa0cb7a8", "patch": "@@ -3330,19 +3330,20 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n    LOOKUP_PREFER_NAMESPACES means not to accept objects, and possibly types.\n    LOOKUP_PREFER_BOTH means class-or-namespace-name.  */\n \n-#define LOOKUP_PROTECT (1)\n-#define LOOKUP_COMPLAIN (2)\n-#define LOOKUP_NORMAL (3)\n-#define LOOKUP_NONVIRTUAL (8)\n-#define LOOKUP_GLOBAL (16)\n-#define LOOKUP_ONLYCONVERTING (128)\n-#define DIRECT_BIND (256)\n-#define LOOKUP_NO_CONVERSION (512)\n-#define LOOKUP_DESTRUCTOR (512)\n-#define LOOKUP_NO_TEMP_BIND (1024)\n-#define LOOKUP_PREFER_TYPES (2048)\n-#define LOOKUP_PREFER_NAMESPACES (4096)\n-#define LOOKUP_PREFER_BOTH (6144)\n+#define LOOKUP_PROTECT (1 << 0)\n+#define LOOKUP_COMPLAIN (1 << 1)\n+#define LOOKUP_NORMAL (LOOKUP_PROTECT | LOOKUP_COMPLAIN)\n+#define LOOKUP_NONVIRTUAL (1 << 2)\n+#define LOOKUP_GLOBAL (1 << 3)\n+#define LOOKUP_ONLYCONVERTING (1 << 4)\n+#define DIRECT_BIND (1 << 5)\n+#define LOOKUP_NO_CONVERSION (1 << 6)\n+#define LOOKUP_DESTRUCTOR (1 << 7)\n+#define LOOKUP_NO_TEMP_BIND (1 << 8)\n+#define LOOKUP_PREFER_TYPES (1 << 9)\n+#define LOOKUP_PREFER_NAMESPACES (1 << 10)\n+#define LOOKUP_PREFER_BOTH (LOOKUP_PREFER_TYPES | LOOKUP_PREFER_NAMESPACES)\n+#define LOOKUP_CONSTRUCTOR_CALLABLE (1 << 11)\n \n #define LOOKUP_NAMESPACES_ONLY(F)  \\\n   (((F) & LOOKUP_PREFER_NAMESPACES) && !((F) & LOOKUP_PREFER_TYPES))"}, {"sha": "2f8653e100916dca4ae87500aac65abb9bc98a17", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644d195145f7e535d426494e1f6a8a68aa0cb7a8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644d195145f7e535d426494e1f6a8a68aa0cb7a8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=644d195145f7e535d426494e1f6a8a68aa0cb7a8", "patch": "@@ -1,3 +1,8 @@\n+2004-06-28  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* PR C++/16174\n+\t* g++.dg/template/ctor4.C: New.\n+\n 2004-06-27  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR c++/16205"}, {"sha": "18ed628ee9bc4b984177170be56d7d69a63af869", "filename": "gcc/testsuite/g++.dg/template/ctor4.C", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644d195145f7e535d426494e1f6a8a68aa0cb7a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fctor4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644d195145f7e535d426494e1f6a8a68aa0cb7a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fctor4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fctor4.C?ref=644d195145f7e535d426494e1f6a8a68aa0cb7a8", "patch": "@@ -0,0 +1,39 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 24 Jun 2004 <nathan@codesourcery.com>\n+\n+// Origin Rani Sharoni via giovannibajo@libero.it\n+// Bug 16174, SFINAE failure.\n+\n+template <class T> struct K \n+{\n+  K();\n+\n+  K(K<T> & rhs);\n+  K(K<T> const& rhs);\n+  template <class U> K(K<U> const& rhs);\n+\n+private:\n+  template <class U> struct A;\n+  template <class U> struct A< K<U> const>\n+  {  typedef typename K<U>::compile_time_error type; };\n+\n+  // This is used to reject calls to the copy constructor\n+  //  with objects which are top-level const. If they are\n+  //  const, the specialization of A is instantiated and\n+  //  causes a compile time error. Otherwise, the general\n+  //  template is picked up, it misses definition, so this\n+  //  ctor declaration is rejected by SFINAE and everybody\n+  //  is happy.\n+  // GCC 3.4.1pre and 3.5.0 always matches A's specialization\n+  //  when instantiating from foo(), and this causes the error.\n+  template <class U>\n+  K(U& rhs, typename A<U>::type = 0);\n+};\n+\n+\n+K<int> foo(void)\n+{\n+  return K<int>();\n+}"}]}