{"sha": "68b26d5cd81e6d59faa9d363b936b65266936174", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjhiMjZkNWNkODFlNmQ1OWZhYTlkMzYzYjkzNmI2NTI2NjkzNjE3NA==", "commit": {"author": {"name": "Sebastian Pop", "email": "pop@cri.ensmp.fr", "date": "2004-10-04T09:12:43Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2004-10-04T09:12:43Z"}, "message": "tree-data-ref.c (array_base_name_differ_p): Fix comments.\n\n\t* tree-data-ref.c (array_base_name_differ_p): Fix comments.  When\n\tthe predicate cannot be computed, don't initialize the result to\n\tfalse.\n\nFrom-SVN: r88479", "tree": {"sha": "d5c0ce845ae910b92dae0f4512d059bb8ce62085", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5c0ce845ae910b92dae0f4512d059bb8ce62085"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68b26d5cd81e6d59faa9d363b936b65266936174", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68b26d5cd81e6d59faa9d363b936b65266936174", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68b26d5cd81e6d59faa9d363b936b65266936174", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68b26d5cd81e6d59faa9d363b936b65266936174/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d01edd7600090f4c938d232da3df3aeff3e1fe8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d01edd7600090f4c938d232da3df3aeff3e1fe8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d01edd7600090f4c938d232da3df3aeff3e1fe8"}], "stats": {"total": 51, "additions": 27, "deletions": 24}, "files": [{"sha": "f191277b4181f4470dce8e701e232f14ca5e174b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68b26d5cd81e6d59faa9d363b936b65266936174/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68b26d5cd81e6d59faa9d363b936b65266936174/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=68b26d5cd81e6d59faa9d363b936b65266936174", "patch": "@@ -1,3 +1,9 @@\n+2004-10-04  Sebastian Pop  <pop@cri.ensmp.fr>\n+\n+\t* tree-data-ref.c (array_base_name_differ_p): Fix comments.  When\n+\tthe predicate cannot be computed, don't initialize the result to\n+\tfalse.\n+\n 2004-10-01  Eric Christopher  <echristo@redhat.com>\n \n \t* dwarf2.h (dwarf_calling_convention): Add GNU prefix to"}, {"sha": "5b5905f3e3abef6619bb7c331171771007edb573", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68b26d5cd81e6d59faa9d363b936b65266936174/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68b26d5cd81e6d59faa9d363b936b65266936174/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=68b26d5cd81e6d59faa9d363b936b65266936174", "patch": "@@ -96,12 +96,12 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tree-pass.h\"\n #include \"lambda.h\"\n \n-\f\n /* This is the simplest data dependence test: determines whether the\n-   data references A and B access the same array/region. If can't determine -\n-   return false; Otherwise, return true, and DIFFER_P will record\n-   the result. This utility will not be necessary when alias_sets_conflict_p\n-   will be less conservative.  */\n+   data references A and B access the same array/region.  Returns\n+   false when the property is not computable at compile time.\n+   Otherwise return true, and DIFFER_P will record the result. This\n+   utility will not be necessary when alias_sets_conflict_p will be\n+   less conservative.  */\n \n bool\n array_base_name_differ_p (struct data_reference *a,\n@@ -113,17 +113,16 @@ array_base_name_differ_p (struct data_reference *a,\n   tree ta = TREE_TYPE (base_a);\n   tree tb = TREE_TYPE (base_b);\n \n-\n-  /** Determine if same base  **/\n-\n-  /* array accesses: a[i],b[i] or pointer accesses: *a,*b. bases are a,b.  */\n+  /* Determine if same base.  Example: for the array accesses\n+     a[i], b[i] or pointer accesses *a, *b, bases are a, b.  */\n   if (base_a == base_b)\n     {\n       *differ_p = false;\n       return true;\n     }\n \n-  /* pointer based accesses - (*p)[i],(*q)[j]. bases are (*p),(*q)  */\n+  /* For pointer based accesses, (*p)[i], (*q)[j], the bases are (*p)\n+     and (*q)  */\n   if (TREE_CODE (base_a) == INDIRECT_REF && TREE_CODE (base_b) == INDIRECT_REF\n       && TREE_OPERAND (base_a, 0) == TREE_OPERAND (base_b, 0))\n     {\n@@ -140,21 +139,21 @@ array_base_name_differ_p (struct data_reference *a,\n       return true;\n     }\n \n+  /* Determine if different bases.  */\n \n-  /** Determine if different bases  **/\n-\n-  /* at this point we know that base_a != base_b. However, pointer accesses\n-     of the form x=(*p) and y=(*q), which bases are p and q, may still by pointing\n-     to the same base. In SSAed GIMPLE p and q will be SSA_NAMES in this case.\n-     Therefore, here we check if it's really two different declarations.  */\n+  /* At this point we know that base_a != base_b.  However, pointer\n+     accesses of the form x=(*p) and y=(*q), which bases are p and q,\n+     may still pointing to the same base. In SSAed GIMPLE p and q will\n+     be SSA_NAMES in this case.  Therefore, here we check if it's\n+     really two diferent declarations.  */\n   if (TREE_CODE (base_a) == VAR_DECL && TREE_CODE (base_b) == VAR_DECL)\n     {\n       *differ_p = true;\n       return true;\n     }\n \n-  /* compare two record/union bases s.a and t.b: \n-     s != t or (a != b and s and t are not unions)  */\n+  /* Compare two record/union bases s.a and t.b: s != t or (a != b and\n+     s and t are not unions).  */\n   if (TREE_CODE (base_a) == COMPONENT_REF && TREE_CODE (base_b) == COMPONENT_REF\n       && ((TREE_CODE (TREE_OPERAND (base_a, 0)) == VAR_DECL\n            && TREE_CODE (TREE_OPERAND (base_b, 0)) == VAR_DECL\n@@ -167,7 +166,7 @@ array_base_name_differ_p (struct data_reference *a,\n       return true;\n     }\n \n-  /* compare a record/union access and an array access.  */ \n+  /* Compare a record/union access and an array access.  */ \n   if ((TREE_CODE (base_a) == VAR_DECL\n        && (TREE_CODE (base_b) == COMPONENT_REF\n            && TREE_CODE (TREE_OPERAND (base_b, 0)) == VAR_DECL))\n@@ -185,10 +184,9 @@ array_base_name_differ_p (struct data_reference *a,\n       return true;\n     }\n \n-  /* An insn writing through a restricted pointer is \"independent\" of any\n-     insn reading or writing through a different pointer, in the same\n-     block/scope.\n-   */\n+  /* An instruction writing through a restricted pointer is\n+     \"independent\" of any instruction reading or writing through a\n+     different pointer, in the same block/scope.  */\n   if ((TREE_CODE (ta) == POINTER_TYPE && TYPE_RESTRICT (ta)\n        && !DR_IS_READ(a))\n       || (TREE_CODE (tb) == POINTER_TYPE && TYPE_RESTRICT (tb)\n@@ -198,7 +196,6 @@ array_base_name_differ_p (struct data_reference *a,\n       return true;\n     }\n \n-  *differ_p = false; /* Don't know, but be conservative.  */\n   return false;\n }\n "}]}