{"sha": "dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5", "node_id": "C_kwDOANBUbNoAKGRkOWU0YzFlMGNhMGIxNDM4OGEzY2Q0M2YxOGE0ZTFhN2FlYmU2ZTU", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-04-21T13:32:21Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-04-21T15:06:18Z"}, "message": "Add name and type resolution for TuplePatterns\n\nThis adds the relevant pattern resolution steps to match up the\nTuplePattern. This patch leaves out type resolution on TupleRange Patterns\nfor now. Some thought is needed to figure out how do have a canonical\nalgorithm for code-generation here so splitting this up makes sense for\nnow.\n\nThis patch extracts the type-resolution handling for HIR::LiteralExpr\nto have a generic function to resolve the HIR::Literal which is used within\nHIR::LiteralExpr and HIR::LiteralPattern.\n\nAddresses #1081", "tree": {"sha": "234a6e1ecdbb1b0a185bf94c50121959926e90cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/234a6e1ecdbb1b0a185bf94c50121959926e90cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe10ca37aba8f3cb9bfaa9dd01bdb1329317cf21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe10ca37aba8f3cb9bfaa9dd01bdb1329317cf21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe10ca37aba8f3cb9bfaa9dd01bdb1329317cf21"}], "stats": {"total": 476, "additions": 293, "deletions": 183}, "files": [{"sha": "a53210ba768e82cde34a876c6e389e2c66b48839", "filename": "gcc/rust/hir/tree/rust-hir-full-test.cc", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc?ref=dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5", "patch": "@@ -2589,14 +2589,7 @@ StructPattern::as_string () const\n std::string\n LiteralPattern::as_string () const\n {\n-  std::string str;\n-\n-  if (has_minus)\n-    {\n-      str += \"-\";\n-    }\n-\n-  return str + lit.as_string ();\n+  return lit.as_string ();\n }\n \n std::string"}, {"sha": "880fc3e2e482a290c4faadb25e9807c7e769e5dd", "filename": "gcc/rust/hir/tree/rust-hir-pattern.h", "status": "modified", "additions": 34, "deletions": 7, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-pattern.h?ref=dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5", "patch": "@@ -29,24 +29,21 @@ namespace HIR {\n class LiteralPattern : public Pattern\n {\n   Literal lit;\n-  bool has_minus;\n   Location locus;\n   Analysis::NodeMapping mappings;\n \n public:\n   std::string as_string () const override;\n \n   // Constructor for a literal pattern\n-  LiteralPattern (Analysis::NodeMapping mappings, Literal lit, Location locus,\n-\t\t  bool has_minus = false)\n-    : lit (std::move (lit)), has_minus (has_minus), locus (locus),\n-      mappings (mappings)\n+  LiteralPattern (Analysis::NodeMapping mappings, Literal lit, Location locus)\n+    : lit (std::move (lit)), locus (locus), mappings (mappings)\n   {}\n \n   LiteralPattern (Analysis::NodeMapping mappings, std::string val,\n-\t\t  Literal::LitType type, Location locus, bool has_minus = false)\n+\t\t  Literal::LitType type, Location locus)\n     : lit (Literal (std::move (val), type, PrimitiveCoreType::CORETYPE_STR)),\n-      has_minus (has_minus), locus (locus), mappings (mappings)\n+      locus (locus), mappings (mappings)\n   {}\n \n   Location get_locus () const override { return locus; }\n@@ -64,6 +61,9 @@ class LiteralPattern : public Pattern\n     return PatternType::LITERAL;\n   }\n \n+  Literal &get_literal () { return lit; }\n+  const Literal &get_literal () const { return lit; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -962,6 +962,12 @@ class TupleStructPattern : public Pattern\n class TuplePatternItems\n {\n public:\n+  enum TuplePatternItemType\n+  {\n+    MULTIPLE,\n+    RANGED,\n+  };\n+\n   virtual ~TuplePatternItems () {}\n \n   // TODO: should this store location data?\n@@ -977,6 +983,8 @@ class TuplePatternItems\n \n   virtual void accept_vis (HIRFullVisitor &vis) = 0;\n \n+  virtual TuplePatternItemType get_pattern_type () const = 0;\n+\n protected:\n   // pure virtual clone implementation\n   virtual TuplePatternItems *clone_tuple_pattern_items_impl () const = 0;\n@@ -1019,6 +1027,17 @@ class TuplePatternItemsMultiple : public TuplePatternItems\n \n   void accept_vis (HIRFullVisitor &vis) override;\n \n+  TuplePatternItemType get_pattern_type () const override\n+  {\n+    return TuplePatternItemType::MULTIPLE;\n+  }\n+\n+  std::vector<std::unique_ptr<Pattern> > &get_patterns () { return patterns; }\n+  const std::vector<std::unique_ptr<Pattern> > &get_patterns () const\n+  {\n+    return patterns;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1077,6 +1096,11 @@ class TuplePatternItemsRanged : public TuplePatternItems\n \n   void accept_vis (HIRFullVisitor &vis) override;\n \n+  TuplePatternItemType get_pattern_type () const override\n+  {\n+    return TuplePatternItemType::RANGED;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1135,6 +1159,9 @@ class TuplePattern : public Pattern\n     return PatternType::TUPLE;\n   }\n \n+  std::unique_ptr<TuplePatternItems> &get_items () { return items; }\n+  const std::unique_ptr<TuplePatternItems> &get_items () const { return items; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "24cd171384db95cedf9b55b350ed84ec61687ce0", "filename": "gcc/rust/resolve/rust-ast-resolve-pattern.cc", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc?ref=dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5", "patch": "@@ -100,5 +100,35 @@ PatternDeclaration::visit (AST::StructPattern &pattern)\n   rust_assert (!struct_pattern_elems.has_etc ());\n }\n \n+void\n+PatternDeclaration::visit (AST::TuplePattern &pattern)\n+{\n+  std::unique_ptr<AST::TuplePatternItems> &items = pattern.get_items ();\n+  switch (items->get_pattern_type ())\n+    {\n+      case AST::TuplePatternItems::TuplePatternItemType::MULTIPLE: {\n+\tAST::TuplePatternItemsMultiple &ref\n+\t  = *static_cast<AST::TuplePatternItemsMultiple *> (\n+\t    pattern.get_items ().get ());\n+\n+\tfor (auto &p : ref.get_patterns ())\n+\t  p->accept_vis (*this);\n+      }\n+      break;\n+\n+      case AST::TuplePatternItems::TuplePatternItemType::RANGED: {\n+\tAST::TuplePatternItemsRanged &ref\n+\t  = *static_cast<AST::TuplePatternItemsRanged *> (\n+\t    pattern.get_items ().get ());\n+\n+\tfor (auto &p : ref.get_lower_patterns ())\n+\t  p->accept_vis (*this);\n+\tfor (auto &p : ref.get_upper_patterns ())\n+\t  p->accept_vis (*this);\n+      }\n+      break;\n+    }\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "464e3628768afb3284367fc2b387010341bad6e0", "filename": "gcc/rust/resolve/rust-ast-resolve-pattern.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h?ref=dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5", "patch": "@@ -101,6 +101,8 @@ class PatternDeclaration : public ResolverBase\n \n   void visit (AST::TupleStructPattern &pattern) override;\n \n+  void visit (AST::TuplePattern &pattern) override;\n+\n private:\n   PatternDeclaration (NodeId parent) : ResolverBase (parent) {}\n };"}, {"sha": "a924866997994638920f27d6aafefcdefa6c5838", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.cc", "status": "modified", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc?ref=dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5", "patch": "@@ -80,5 +80,177 @@ TypeCheckBase::check_for_unconstrained (\n   return unconstrained;\n }\n \n+TyTy::BaseType *\n+TypeCheckBase::resolve_literal (const Analysis::NodeMapping &expr_mappings,\n+\t\t\t\tHIR::Literal &literal, Location locus)\n+{\n+  TyTy::BaseType *infered = nullptr;\n+  switch (literal.get_lit_type ())\n+    {\n+      case HIR::Literal::LitType::INT: {\n+\tbool ok = false;\n+\n+\tswitch (literal.get_type_hint ())\n+\t  {\n+\t  case CORETYPE_I8:\n+\t    ok = context->lookup_builtin (\"i8\", &infered);\n+\t    break;\n+\t  case CORETYPE_I16:\n+\t    ok = context->lookup_builtin (\"i16\", &infered);\n+\t    break;\n+\t  case CORETYPE_I32:\n+\t    ok = context->lookup_builtin (\"i32\", &infered);\n+\t    break;\n+\t  case CORETYPE_I64:\n+\t    ok = context->lookup_builtin (\"i64\", &infered);\n+\t    break;\n+\t  case CORETYPE_I128:\n+\t    ok = context->lookup_builtin (\"i128\", &infered);\n+\t    break;\n+\n+\t  case CORETYPE_U8:\n+\t    ok = context->lookup_builtin (\"u8\", &infered);\n+\t    break;\n+\t  case CORETYPE_U16:\n+\t    ok = context->lookup_builtin (\"u16\", &infered);\n+\t    break;\n+\t  case CORETYPE_U32:\n+\t    ok = context->lookup_builtin (\"u32\", &infered);\n+\t    break;\n+\t  case CORETYPE_U64:\n+\t    ok = context->lookup_builtin (\"u64\", &infered);\n+\t    break;\n+\t  case CORETYPE_U128:\n+\t    ok = context->lookup_builtin (\"u128\", &infered);\n+\t    break;\n+\n+\t  case CORETYPE_F32:\n+\t    literal.set_lit_type (HIR::Literal::LitType::FLOAT);\n+\t    ok = context->lookup_builtin (\"f32\", &infered);\n+\t    break;\n+\t  case CORETYPE_F64:\n+\t    literal.set_lit_type (HIR::Literal::LitType::FLOAT);\n+\t    ok = context->lookup_builtin (\"f64\", &infered);\n+\t    break;\n+\n+\t  default:\n+\t    ok = true;\n+\t    infered\n+\t      = new TyTy::InferType (expr_mappings.get_hirid (),\n+\t\t\t\t     TyTy::InferType::InferTypeKind::INTEGRAL,\n+\t\t\t\t     locus);\n+\t    break;\n+\t  }\n+\trust_assert (ok);\n+      }\n+      break;\n+\n+      case HIR::Literal::LitType::FLOAT: {\n+\tbool ok = false;\n+\n+\tswitch (literal.get_type_hint ())\n+\t  {\n+\t  case CORETYPE_F32:\n+\t    ok = context->lookup_builtin (\"f32\", &infered);\n+\t    break;\n+\t  case CORETYPE_F64:\n+\t    ok = context->lookup_builtin (\"f64\", &infered);\n+\t    break;\n+\n+\t  default:\n+\t    ok = true;\n+\t    infered\n+\t      = new TyTy::InferType (expr_mappings.get_hirid (),\n+\t\t\t\t     TyTy::InferType::InferTypeKind::FLOAT,\n+\t\t\t\t     locus);\n+\t    break;\n+\t  }\n+\trust_assert (ok);\n+      }\n+      break;\n+\n+      case HIR::Literal::LitType::BOOL: {\n+\tauto ok = context->lookup_builtin (\"bool\", &infered);\n+\trust_assert (ok);\n+      }\n+      break;\n+\n+      case HIR::Literal::LitType::CHAR: {\n+\tauto ok = context->lookup_builtin (\"char\", &infered);\n+\trust_assert (ok);\n+      }\n+      break;\n+\n+      case HIR::Literal::LitType::BYTE: {\n+\tauto ok = context->lookup_builtin (\"u8\", &infered);\n+\trust_assert (ok);\n+      }\n+      break;\n+\n+      case HIR::Literal::LitType::STRING: {\n+\tTyTy::BaseType *base = nullptr;\n+\tauto ok = context->lookup_builtin (\"str\", &base);\n+\trust_assert (ok);\n+\n+\tinfered = new TyTy::ReferenceType (expr_mappings.get_hirid (),\n+\t\t\t\t\t   TyTy::TyVar (base->get_ref ()),\n+\t\t\t\t\t   Mutability::Imm);\n+      }\n+      break;\n+\n+      case HIR::Literal::LitType::BYTE_STRING: {\n+\t/* This is an arraytype of u8 reference (&[u8;size]). It isn't in\n+\t   UTF-8, but really just a byte array. Code to construct the array\n+\t   reference copied from ArrayElemsValues and ArrayType. */\n+\tTyTy::BaseType *u8;\n+\tauto ok = context->lookup_builtin (\"u8\", &u8);\n+\trust_assert (ok);\n+\n+\tauto crate_num = mappings->get_current_crate ();\n+\tAnalysis::NodeMapping capacity_mapping (crate_num, UNKNOWN_NODEID,\n+\t\t\t\t\t\tmappings->get_next_hir_id (\n+\t\t\t\t\t\t  crate_num),\n+\t\t\t\t\t\tUNKNOWN_LOCAL_DEFID);\n+\n+\t/* Capacity is the size of the string (number of chars).\n+\t   It is a constant, but for fold it to get a tree.  */\n+\tstd::string capacity_str\n+\t  = std::to_string (literal.as_string ().size ());\n+\tHIR::LiteralExpr *literal_capacity\n+\t  = new HIR::LiteralExpr (capacity_mapping, capacity_str,\n+\t\t\t\t  HIR::Literal::LitType::INT,\n+\t\t\t\t  PrimitiveCoreType::CORETYPE_USIZE, locus, {});\n+\n+\t// mark the type for this implicit node\n+\tTyTy::BaseType *expected_ty = nullptr;\n+\tok = context->lookup_builtin (\"usize\", &expected_ty);\n+\trust_assert (ok);\n+\tcontext->insert_type (capacity_mapping, expected_ty);\n+\n+\tAnalysis::NodeMapping array_mapping (crate_num, UNKNOWN_NODEID,\n+\t\t\t\t\t     mappings->get_next_hir_id (\n+\t\t\t\t\t       crate_num),\n+\t\t\t\t\t     UNKNOWN_LOCAL_DEFID);\n+\n+\tTyTy::ArrayType *array\n+\t  = new TyTy::ArrayType (array_mapping.get_hirid (), locus,\n+\t\t\t\t *literal_capacity,\n+\t\t\t\t TyTy::TyVar (u8->get_ref ()));\n+\tcontext->insert_type (array_mapping, array);\n+\n+\tinfered = new TyTy::ReferenceType (expr_mappings.get_hirid (),\n+\t\t\t\t\t   TyTy::TyVar (array->get_ref ()),\n+\t\t\t\t\t   Mutability::Imm);\n+      }\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+      break;\n+    }\n+\n+  return infered;\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "159f8261c9e02af545c0b5bad0a19fe9056ff8b3", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h?ref=dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5", "patch": "@@ -55,6 +55,9 @@ class TypeCheckBase : public HIR::HIRFullVisitorBase\n     const TyTy::SubstitutionArgumentMappings &constraint_b,\n     const TyTy::BaseType *reference);\n \n+  TyTy::BaseType *resolve_literal (const Analysis::NodeMapping &mappings,\n+\t\t\t\t   HIR::Literal &literal, Location locus);\n+\n   Analysis::Mappings *mappings;\n   Resolver *resolver;\n   TypeCheckContext *context;"}, {"sha": "5db00a43832c299337528d306fcc643455cbdc97", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 2, "deletions": 166, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5", "patch": "@@ -535,172 +535,8 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::LiteralExpr &expr) override\n   {\n-    switch (expr.get_lit_type ())\n-      {\n-\tcase HIR::Literal::LitType::INT: {\n-\t  bool ok = false;\n-\n-\t  switch (expr.get_literal ().get_type_hint ())\n-\t    {\n-\t    case CORETYPE_I8:\n-\t      ok = context->lookup_builtin (\"i8\", &infered);\n-\t      break;\n-\t    case CORETYPE_I16:\n-\t      ok = context->lookup_builtin (\"i16\", &infered);\n-\t      break;\n-\t    case CORETYPE_I32:\n-\t      ok = context->lookup_builtin (\"i32\", &infered);\n-\t      break;\n-\t    case CORETYPE_I64:\n-\t      ok = context->lookup_builtin (\"i64\", &infered);\n-\t      break;\n-\t    case CORETYPE_I128:\n-\t      ok = context->lookup_builtin (\"i128\", &infered);\n-\t      break;\n-\n-\t    case CORETYPE_U8:\n-\t      ok = context->lookup_builtin (\"u8\", &infered);\n-\t      break;\n-\t    case CORETYPE_U16:\n-\t      ok = context->lookup_builtin (\"u16\", &infered);\n-\t      break;\n-\t    case CORETYPE_U32:\n-\t      ok = context->lookup_builtin (\"u32\", &infered);\n-\t      break;\n-\t    case CORETYPE_U64:\n-\t      ok = context->lookup_builtin (\"u64\", &infered);\n-\t      break;\n-\t    case CORETYPE_U128:\n-\t      ok = context->lookup_builtin (\"u128\", &infered);\n-\t      break;\n-\n-\t    case CORETYPE_F32:\n-\t      expr.get_literal ().set_lit_type (HIR::Literal::LitType::FLOAT);\n-\t      ok = context->lookup_builtin (\"f32\", &infered);\n-\t      break;\n-\t    case CORETYPE_F64:\n-\t      expr.get_literal ().set_lit_type (HIR::Literal::LitType::FLOAT);\n-\t      ok = context->lookup_builtin (\"f64\", &infered);\n-\t      break;\n-\n-\t    default:\n-\t      ok = true;\n-\t      infered\n-\t\t= new TyTy::InferType (expr.get_mappings ().get_hirid (),\n-\t\t\t\t       TyTy::InferType::InferTypeKind::INTEGRAL,\n-\t\t\t\t       expr.get_locus ());\n-\t      break;\n-\t    }\n-\t  rust_assert (ok);\n-\t}\n-\tbreak;\n-\n-\tcase HIR::Literal::LitType::FLOAT: {\n-\t  bool ok = false;\n-\n-\t  switch (expr.get_literal ().get_type_hint ())\n-\t    {\n-\t    case CORETYPE_F32:\n-\t      ok = context->lookup_builtin (\"f32\", &infered);\n-\t      break;\n-\t    case CORETYPE_F64:\n-\t      ok = context->lookup_builtin (\"f64\", &infered);\n-\t      break;\n-\n-\t    default:\n-\t      ok = true;\n-\t      infered\n-\t\t= new TyTy::InferType (expr.get_mappings ().get_hirid (),\n-\t\t\t\t       TyTy::InferType::InferTypeKind::FLOAT,\n-\t\t\t\t       expr.get_locus ());\n-\t      break;\n-\t    }\n-\t  rust_assert (ok);\n-\t}\n-\tbreak;\n-\n-\tcase HIR::Literal::LitType::BOOL: {\n-\t  auto ok = context->lookup_builtin (\"bool\", &infered);\n-\t  rust_assert (ok);\n-\t}\n-\tbreak;\n-\n-\tcase HIR::Literal::LitType::CHAR: {\n-\t  auto ok = context->lookup_builtin (\"char\", &infered);\n-\t  rust_assert (ok);\n-\t}\n-\tbreak;\n-\n-\tcase HIR::Literal::LitType::BYTE: {\n-\t  auto ok = context->lookup_builtin (\"u8\", &infered);\n-\t  rust_assert (ok);\n-\t}\n-\tbreak;\n-\n-\tcase HIR::Literal::LitType::STRING: {\n-\t  TyTy::BaseType *base = nullptr;\n-\t  auto ok = context->lookup_builtin (\"str\", &base);\n-\t  rust_assert (ok);\n-\n-\t  infered = new TyTy::ReferenceType (expr.get_mappings ().get_hirid (),\n-\t\t\t\t\t     TyTy::TyVar (base->get_ref ()),\n-\t\t\t\t\t     Mutability::Imm);\n-\t}\n-\tbreak;\n-\n-\tcase HIR::Literal::LitType::BYTE_STRING: {\n-\t  /* This is an arraytype of u8 reference (&[u8;size]). It isn't in\n-\t     UTF-8, but really just a byte array. Code to construct the array\n-\t     reference copied from ArrayElemsValues and ArrayType. */\n-\t  TyTy::BaseType *u8;\n-\t  auto ok = context->lookup_builtin (\"u8\", &u8);\n-\t  rust_assert (ok);\n-\n-\t  auto crate_num = mappings->get_current_crate ();\n-\t  Analysis::NodeMapping capacity_mapping (crate_num, UNKNOWN_NODEID,\n-\t\t\t\t\t\t  mappings->get_next_hir_id (\n-\t\t\t\t\t\t    crate_num),\n-\t\t\t\t\t\t  UNKNOWN_LOCAL_DEFID);\n-\n-\t  /* Capacity is the size of the string (number of chars).\n-\t     It is a constant, but for fold it to get a tree.  */\n-\t  std::string capacity_str\n-\t    = std::to_string (expr.get_literal ().as_string ().size ());\n-\t  HIR::LiteralExpr *literal_capacity\n-\t    = new HIR::LiteralExpr (capacity_mapping, capacity_str,\n-\t\t\t\t    HIR::Literal::LitType::INT,\n-\t\t\t\t    PrimitiveCoreType::CORETYPE_USIZE,\n-\t\t\t\t    expr.get_locus (), expr.get_outer_attrs ());\n-\n-\t  // mark the type for this implicit node\n-\t  TyTy::BaseType *expected_ty = nullptr;\n-\t  ok = context->lookup_builtin (\"usize\", &expected_ty);\n-\t  rust_assert (ok);\n-\t  context->insert_type (capacity_mapping, expected_ty);\n-\n-\t  Analysis::NodeMapping array_mapping (crate_num, UNKNOWN_NODEID,\n-\t\t\t\t\t       mappings->get_next_hir_id (\n-\t\t\t\t\t\t crate_num),\n-\t\t\t\t\t       UNKNOWN_LOCAL_DEFID);\n-\n-\t  TyTy::ArrayType *array\n-\t    = new TyTy::ArrayType (array_mapping.get_hirid (),\n-\t\t\t\t   expr.get_locus (), *literal_capacity,\n-\t\t\t\t   TyTy::TyVar (u8->get_ref ()));\n-\t  context->insert_type (array_mapping, array);\n-\n-\t  infered = new TyTy::ReferenceType (expr.get_mappings ().get_hirid (),\n-\t\t\t\t\t     TyTy::TyVar (array->get_ref ()),\n-\t\t\t\t\t     Mutability::Imm);\n-\t}\n-\tbreak;\n-\n-      default:\n-\tgcc_unreachable ();\n-\tbreak;\n-      }\n-\n-    infered = infered->clone ();\n+    infered = resolve_literal (expr.get_mappings (), expr.get_literal (),\n+\t\t\t       expr.get_locus ());\n   }\n \n   void visit (HIR::ArithmeticOrLogicalExpr &expr) override"}, {"sha": "52d0d479d2915c7408e74079931976f269efcf73", "filename": "gcc/rust/typecheck/rust-hir-type-check-pattern.cc", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.cc?ref=dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5", "patch": "@@ -232,5 +232,46 @@ TypeCheckPattern::visit (HIR::WildcardPattern &pattern)\n   infered->set_ref (pattern.get_pattern_mappings ().get_hirid ());\n }\n \n+void\n+TypeCheckPattern::visit (HIR::TuplePattern &pattern)\n+{\n+  std::unique_ptr<HIR::TuplePatternItems> items;\n+  switch (pattern.get_items ()->get_pattern_type ())\n+    {\n+      case HIR::TuplePatternItems::TuplePatternItemType::MULTIPLE: {\n+\tHIR::TuplePatternItemsMultiple &ref\n+\t  = *static_cast<HIR::TuplePatternItemsMultiple *> (\n+\t    pattern.get_items ().get ());\n+\n+\tstd::vector<TyTy::TyVar> pattern_elems;\n+\tfor (auto &p : ref.get_patterns ())\n+\t  {\n+\t    TyTy::BaseType *elem = TypeCheckPattern::Resolve (p.get (), parent);\n+\t    pattern_elems.push_back (TyTy::TyVar (elem->get_ref ()));\n+\t  }\n+\tinfered\n+\t  = new TyTy::TupleType (pattern.get_pattern_mappings ().get_hirid (),\n+\t\t\t\t pattern.get_locus (), pattern_elems);\n+      }\n+      break;\n+\n+      case HIR::TuplePatternItems::TuplePatternItemType::RANGED: {\n+\t// HIR::TuplePatternItemsRanged &ref\n+\t//   = *static_cast<HIR::TuplePatternItemsRanged *> (\n+\t//     pattern.get_items ().get ());\n+\t// TODO\n+\tgcc_unreachable ();\n+      }\n+      break;\n+    }\n+}\n+\n+void\n+TypeCheckPattern::visit (HIR::LiteralPattern &pattern)\n+{\n+  infered = resolve_literal (pattern.get_pattern_mappings (),\n+\t\t\t     pattern.get_literal (), pattern.get_locus ());\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "b76c7baa6c3af5f780a9c329f1dfaa8c161b259d", "filename": "gcc/rust/typecheck/rust-hir-type-check-pattern.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.h?ref=dd9e4c1e0ca0b14388a3cd43f18a4e1a7aebe6e5", "patch": "@@ -39,6 +39,8 @@ class TypeCheckPattern : public TypeCheckBase\n       return new TyTy::ErrorType (\n \tpattern->get_pattern_mappings ().get_hirid ());\n \n+    resolver.context->insert_type (pattern->get_pattern_mappings (),\n+\t\t\t\t   resolver.infered);\n     return resolver.infered;\n   }\n \n@@ -50,13 +52,17 @@ class TypeCheckPattern : public TypeCheckBase\n \n   void visit (HIR::WildcardPattern &pattern) override;\n \n+  void visit (HIR::TuplePattern &pattern) override;\n+\n+  void visit (HIR::LiteralPattern &pattern) override;\n+\n private:\n   TypeCheckPattern (TyTy::BaseType *parent)\n-    : TypeCheckBase (), infered (nullptr), parent (parent)\n+    : TypeCheckBase (), parent (parent), infered (nullptr)\n   {}\n \n-  TyTy::BaseType *infered;\n   TyTy::BaseType *parent;\n+  TyTy::BaseType *infered;\n };\n \n } // namespace Resolver"}]}