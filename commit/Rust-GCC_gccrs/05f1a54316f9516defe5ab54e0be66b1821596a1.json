{"sha": "05f1a54316f9516defe5ab54e0be66b1821596a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDVmMWE1NDMxNmY5NTE2ZGVmZTVhYjU0ZTBiZTY2YjE4MjE1OTZhMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-10-12T14:37:35Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-10-12T14:37:35Z"}, "message": "[multiple changes]\n\n2016-10-12  Yannick Moy  <moy@adacore.com>\n\n\t* einfo.adb, einfo.ads (Partial_Refinement_Constituents): Take\n\tinto account constituents that are themselves abstract states\n\twith full or partial refinement visible.\n\t* sem_prag.adb (Find_Encapsulating_State): Move function\n\tto library-level, to share between subprograms.\n\t(Analyze_Refined_Global_In_Decl_Part): Use\n\tFind_Encapsulating_State to get relevant encapsulating state.\n\n2016-10-12  Arnaud Charlet  <charlet@adacore.com>\n\n\t* gnat1drv.adb: Fix minor typo.\n\nFrom-SVN: r241052", "tree": {"sha": "668d6e6bca34413ff3d8823da22c1dc246815c84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/668d6e6bca34413ff3d8823da22c1dc246815c84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05f1a54316f9516defe5ab54e0be66b1821596a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05f1a54316f9516defe5ab54e0be66b1821596a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05f1a54316f9516defe5ab54e0be66b1821596a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05f1a54316f9516defe5ab54e0be66b1821596a1/comments", "author": null, "committer": null, "parents": [{"sha": "c8dc49fb0318088e30040d1162cea181931f1ab4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8dc49fb0318088e30040d1162cea181931f1ab4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8dc49fb0318088e30040d1162cea181931f1ab4"}], "stats": {"total": 261, "additions": 169, "deletions": 92}, "files": [{"sha": "88090334494b9c93997521fdf9d80e067bad83b6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05f1a54316f9516defe5ab54e0be66b1821596a1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05f1a54316f9516defe5ab54e0be66b1821596a1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=05f1a54316f9516defe5ab54e0be66b1821596a1", "patch": "@@ -1,3 +1,17 @@\n+2016-10-12  Yannick Moy  <moy@adacore.com>\n+\n+\t* einfo.adb, einfo.ads (Partial_Refinement_Constituents): Take\n+\tinto account constituents that are themselves abstract states\n+\twith full or partial refinement visible.\n+\t* sem_prag.adb (Find_Encapsulating_State): Move function\n+\tto library-level, to share between subprograms.\n+\t(Analyze_Refined_Global_In_Decl_Part): Use\n+\tFind_Encapsulating_State to get relevant encapsulating state.\n+\n+2016-10-12  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* gnat1drv.adb: Fix minor typo.\n+\n 2016-10-12  Yannick Moy  <moy@adacore.com>\n \n \t* sem_prag.adb (Analyze_Refined_Depends_In_Decl_Part): Adapt checking"}, {"sha": "2cfb3325f46fe435178fa4309020374f0d7cca77", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 64, "deletions": 4, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05f1a54316f9516defe5ab54e0be66b1821596a1/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05f1a54316f9516defe5ab54e0be66b1821596a1/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=05f1a54316f9516defe5ab54e0be66b1821596a1", "patch": "@@ -8407,19 +8407,79 @@ package body Einfo is\n    -------------------------------------\n \n    function Partial_Refinement_Constituents (Id : E) return L is\n-      Constits : Elist_Id;\n+      Constits : Elist_Id := No_Elist;\n+\n+      procedure Add_Usable_Constituents (Item : E);\n+      --  Add global item Item and/or its constituents to list Constits when\n+      --  they can be used in a global refinement within the current scope. The\n+      --  criteria are:\n+      --    1) If Item is an abstract state with full refinement visible, add\n+      --       its constituents.\n+      --    2) If Item is an abstract state with only partial refinement\n+      --       visible, add both Item and its constituents.\n+      --    3) If Item is an abstract state without a visible refinement, add\n+      --       it.\n+      --    4) If Id is not an abstract state, add it.\n+\n+      procedure Add_Usable_Constituents (List : Elist_Id);\n+      --  Apply Add_Usable_Constituents to every constituent in List\n+\n+      -----------------------------\n+      -- Add_Usable_Constituents --\n+      -----------------------------\n+\n+      procedure Add_Usable_Constituents (Item : E) is\n+      begin\n+         if Ekind (Item) = E_Abstract_State then\n+            if Has_Visible_Refinement (Item) then\n+               Add_Usable_Constituents (Refinement_Constituents (Item));\n+\n+            elsif Has_Partial_Visible_Refinement (Item) then\n+               Append_New_Elmt (Item, Constits);\n+               Add_Usable_Constituents (Part_Of_Constituents (Item));\n+\n+            else\n+               Append_New_Elmt (Item, Constits);\n+            end if;\n+\n+         else\n+            Append_New_Elmt (Item, Constits);\n+         end if;\n+      end Add_Usable_Constituents;\n+\n+      procedure Add_Usable_Constituents (List : Elist_Id) is\n+         Constit_Elmt : Elmt_Id;\n+      begin\n+         if Present (List) then\n+            Constit_Elmt := First_Elmt (List);\n+            while Present (Constit_Elmt) loop\n+               Add_Usable_Constituents (Node (Constit_Elmt));\n+               Next_Elmt (Constit_Elmt);\n+            end loop;\n+         end if;\n+      end Add_Usable_Constituents;\n+\n+   --  Start of processing for Partial_Refinement_Constituents\n \n    begin\n       --  \"Refinement\" is a concept applicable only to abstract states\n \n       pragma Assert (Ekind (Id) = E_Abstract_State);\n-      Constits := Refinement_Constituents (Id);\n+\n+      if Has_Visible_Refinement (Id) then\n+         Constits := Refinement_Constituents (Id);\n \n       --  A refinement may be partially visible when objects declared in the\n       --  private part of a package are subject to a Part_Of indicator.\n \n-      if No (Constits) then\n-         Constits := Part_Of_Constituents (Id);\n+      elsif Has_Partial_Visible_Refinement (Id) then\n+         Add_Usable_Constituents (Part_Of_Constituents (Id));\n+\n+      --  Function should only be called when full or partial refinement is\n+      --  visible.\n+\n+      else\n+         raise Program_Error;\n       end if;\n \n       return Constits;"}, {"sha": "f62942c80ffaf0f07933d4758849c7960a7e4149", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05f1a54316f9516defe5ab54e0be66b1821596a1/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05f1a54316f9516defe5ab54e0be66b1821596a1/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=05f1a54316f9516defe5ab54e0be66b1821596a1", "patch": "@@ -3793,9 +3793,11 @@ package Einfo is\n --       way this is stored is as an element of the Subprograms_For_Type field.\n \n --    Partial_Refinement_Constituents (synthesized)\n---       Present in abstract state entities. Contains the constituents that\n---       refine the state in its private part, in other words, all the hidden\n---       states that indicate this abstract state in a Part_Of aspect/pragma.\n+--       Defined in abstract state entities. Returns the constituents that\n+--       refine the state in the current scope, which are allowed in a global\n+--       refinement in this scope. These consist in those constituents that are\n+--       abstract states with no or only partial refinement visible, and those\n+--       that are not themselves abstract states.\n \n --    Partial_View_Has_Unknown_Discr (Flag280)\n --       Present in all types. Set to Indicate that the partial view of a type"}, {"sha": "fa08414652c189aabe58be7e4ec97cc114a9bb90", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05f1a54316f9516defe5ab54e0be66b1821596a1/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05f1a54316f9516defe5ab54e0be66b1821596a1/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=05f1a54316f9516defe5ab54e0be66b1821596a1", "patch": "@@ -343,7 +343,7 @@ procedure Gnat1drv is\n          --  of compiler warnings, but these are being turned off by default,\n          --  and CodePeer generates better messages (referencing original\n          --  variables) this way.\n-         --  Do this only is -gnatws is set (the default with -gnatcC), so that\n+         --  Do this only if -gnatws is set (the default with -gnatcC), so that\n          --  if warnings are enabled, we'll get better messages from GNAT.\n \n          if Warning_Mode = Suppress then"}, {"sha": "649eb629b8c89307d7427f46fbc7d09e3493cc0e", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 85, "deletions": 84, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05f1a54316f9516defe5ab54e0be66b1821596a1/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05f1a54316f9516defe5ab54e0be66b1821596a1/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=05f1a54316f9516defe5ab54e0be66b1821596a1", "patch": "@@ -258,6 +258,13 @@ package body Sem_Prag is\n    --  Subsidiary to all Find_Related_xxx routines. Emit an error on pragma\n    --  Prag that duplicates previous pragma Prev.\n \n+   function Find_Encapsulating_State\n+     (States     : Elist_Id;\n+      Constit_Id : Entity_Id) return Entity_Id;\n+   --  Given the entity of a constituent Constit_Id, find the corresponding\n+   --  encapsulating state which appears in States. The routine returns Empty\n+   --  is no such state is found.\n+\n    function Find_Related_Context\n      (Prag      : Node_Id;\n       Do_Checks : Boolean := False) return Node_Id;\n@@ -24545,19 +24552,19 @@ package body Sem_Prag is\n       --  These list contain the entities of all Input, In_Out, Output and\n       --  Proof_In items defined in the corresponding Global pragma.\n \n+      Repeat_Items : Elist_Id := No_Elist;\n+      --  A list of all global items without full visible refinement found\n+      --  in pragma Global. These states should be repeated in the global\n+      --  refinement (SPARK RM 7.2.4(3c)) unless they have a partial visible\n+      --  refinement, in which case they may be repeated (SPARK RM 7.2.4(3d)).\n+\n       Spec_Id : Entity_Id;\n       --  The entity of the subprogram subject to pragma Refined_Global\n \n       States : Elist_Id := No_Elist;\n       --  A list of all states with full or partial visible refinement found in\n       --  pragma Global.\n \n-      Repeat_Items : Elist_Id := No_Elist;\n-      --  A list of all global items without full visible refinement found\n-      --  in pragma Global. These states should be repeated in the global\n-      --  refinement (SPARK RM 7.2.4(3c)) unless they have a partial visible\n-      --  refinement, in which case they may be repeated (SPARK RM 7.2.4(3d)).\n-\n       procedure Check_In_Out_States;\n       --  Determine whether the corresponding Global pragma mentions In_Out\n       --  states with visible refinement and if so, ensure that one of the\n@@ -24616,8 +24623,8 @@ package body Sem_Prag is\n       --  In_Out_Constits and Out_Constits of valid constituents.\n \n       procedure Present_Then_Remove (List : Elist_Id; Item : Entity_Id);\n-      --  Same as function Present_Then_Remove, but do not report presence of\n-      --  Item in List.\n+      --  Same as function Present_Then_Remove, but do not report the presence\n+      --  of Item in List.\n \n       procedure Report_Extra_Constituents;\n       --  Emit an error for each constituent found in lists In_Constits,\n@@ -24715,12 +24722,12 @@ package body Sem_Prag is\n                      N, State_Id);\n                end if;\n \n-            --  The state lacks a completion. When full refinement is\n-            --  visible, always emit an error (SPARK RM 7.2.4(3a)). When only\n-            --  partial refinement is visible, emit an error if the abstract\n-            --  state itself is not utilized (SPARK RM 7.2.4(3d)). In the\n-            --  case where both are utilized, an error will be issued in\n-            --  Check_State_And_Constituent_Use.\n+            --  The state lacks a completion. When full refinement is visible,\n+            --  always emit an error (SPARK RM 7.2.4(3a)). When only partial\n+            --  refinement is visible, emit an error if the abstract state\n+            --  itself is not utilized (SPARK RM 7.2.4(3d)). In the case where\n+            --  both are utilized, Check_State_And_Constituent_Use. will issue\n+            --  the error.\n \n             elsif not Input_Seen\n               and then not In_Out_Seen\n@@ -24836,17 +24843,16 @@ package body Sem_Prag is\n                end loop;\n             end if;\n \n-            --  Not one of the constituents appeared as Input. When full\n-            --  refinement is visible, always emit an error (SPARK RM\n-            --  7.2.4(3a)). When only partial refinement is visible, emit an\n+            --  Not one of the constituents appeared as Input. Always emit an\n+            --  error when the full refinement is visible (SPARK RM 7.2.4(3a)).\n+            --  When only partial refinement is visible, emit an\n             --  error if the abstract state itself is not utilized (SPARK RM\n             --  7.2.4(3d)). In the case where both are utilized, an error will\n             --  be issued in Check_State_And_Constituent_Use.\n \n             if not In_Seen\n               and then (Has_Visible_Refinement (State_Id)\n-                          or else\n-                        Contains (Repeat_Items, State_Id))\n+                         or else Contains (Repeat_Items, State_Id))\n             then\n                SPARK_Msg_NE\n                  (\"global refinement of state & must include at least one \"\n@@ -24910,10 +24916,10 @@ package body Sem_Prag is\n          procedure Check_Constituent_Usage (State_Id : Entity_Id) is\n             Constits     : constant Elist_Id :=\n                              Partial_Refinement_Constituents (State_Id);\n-            Constit_Elmt : Elmt_Id;\n-            Constit_Id   : Entity_Id;\n             Only_Partial : constant Boolean :=\n                              not Has_Visible_Refinement (State_Id);\n+            Constit_Elmt : Elmt_Id;\n+            Constit_Id   : Entity_Id;\n             Posted       : Boolean := False;\n \n          begin\n@@ -24922,9 +24928,9 @@ package body Sem_Prag is\n                while Present (Constit_Elmt) loop\n                   Constit_Id := Node (Constit_Elmt);\n \n-                  --  Issue an error when a constituent of State_Id is\n-                  --  utilized, and State_Id has only partial visible\n-                  --  refinement (SPARK RM 7.2.4(3d)).\n+                  --  Issue an error when a constituent of State_Id is utilized\n+                  --  and State_Id has only partial visible refinement\n+                  --  (SPARK RM 7.2.4(3d)).\n \n                   if Only_Partial then\n                      if Present_Then_Remove (Out_Constits, Constit_Id)\n@@ -24936,8 +24942,8 @@ package body Sem_Prag is\n                      then\n                         Error_Msg_Name_1 := Chars (State_Id);\n                         SPARK_Msg_NE\n-                          (\"constituent & of state % cannot be used in \"\n-                           & \"global refinement\", N, Constit_Id);\n+                          (\"constituent & of state % cannot be used in global \"\n+                           & \"refinement\", N, Constit_Id);\n                         Error_Msg_Name_1 := Chars (State_Id);\n                         SPARK_Msg_N (\"\\use state % instead\", N);\n                      end if;\n@@ -25000,9 +25006,9 @@ package body Sem_Prag is\n                Item_Id := Node (Item_Elmt);\n \n                --  When full refinement is visible, ensure that all of the\n-               --  constituents are utilized and they have mode Output.\n-               --  When only partial refinement is visible, ensure that\n-               --  no constituent is utilized.\n+               --  constituents are utilized and they have mode Output. When\n+               --  only partial refinement is visible, ensure that no\n+               --  constituent is utilized.\n \n                if Ekind (Item_Id) = E_Abstract_State\n                  and then Has_Non_Null_Visible_Refinement (Item_Id)\n@@ -25066,17 +25072,16 @@ package body Sem_Prag is\n                end loop;\n             end if;\n \n-            --  Not one of the constituents appeared as Proof_In. When\n-            --  full refinement is visible, always emit an error (SPARK RM\n-            --  7.2.4(3a)). When only partial refinement is visible, emit an\n-            --  error if the abstract state itself is not utilized (SPARK RM\n-            --  7.2.4(3d)). In the case where both are utilized, an error will\n-            --  be issued in Check_State_And_Constituent_Use.\n+            --  Not one of the constituents appeared as Proof_In. Always emit\n+            --  an error when full refinement is visible (SPARK RM 7.2.4(3a)).\n+            --  When only partial refinement is visible, emit an error if the\n+            --  abstract state itself is not utilized (SPARK RM 7.2.4(3d)). In\n+            --  the case where both are utilized, an error will be issued by\n+            --  Check_State_And_Constituent_Use.\n \n             if not Proof_In_Seen\n               and then (Has_Visible_Refinement (State_Id)\n-                          or else\n-                        Contains (Repeat_Items, State_Id))\n+                         or else Contains (Repeat_Items, State_Id))\n             then\n                SPARK_Msg_NE\n                  (\"global refinement of state & must include at least one \"\n@@ -25165,15 +25170,19 @@ package body Sem_Prag is\n                SPARK_Msg_N (\"\\expected mode %, found mode %\", Item);\n             end Inconsistent_Mode_Error;\n \n+            --  Local variables\n+\n             Enc_State : Entity_Id := Empty;\n             --  Encapsulating state for constituent, Empty otherwise\n \n          --  Start of processing for Check_Refined_Global_Item\n \n          begin\n-            if Ekind_In (Item_Id, E_Abstract_State, E_Constant, E_Variable)\n+            if Ekind_In (Item_Id, E_Abstract_State,\n+                                  E_Constant,\n+                                  E_Variable)\n             then\n-               Enc_State := Encapsulating_State (Item_Id);\n+               Enc_State := Find_Encapsulating_State (States, Item_Id);\n             end if;\n \n             --  When the state or object acts as a constituent of another\n@@ -25184,8 +25193,7 @@ package body Sem_Prag is\n \n             if Present (Enc_State)\n               and then (Has_Visible_Refinement (Enc_State)\n-                          or else\n-                        Has_Partial_Visible_Refinement (Enc_State))\n+                         or else Has_Partial_Visible_Refinement (Enc_State))\n               and then Contains (States, Enc_State)\n             then\n                --  If the state has only partial visible refinement, remove it\n@@ -25360,8 +25368,8 @@ package body Sem_Prag is\n             end if;\n \n             --  Record global items without full visible refinement found in\n-            --  pragma Global, which should (SPARK RM 7.2.4(3c)) or may (SPARK\n-            --  RM 7.2.4(3d)) be repeated in the global refinement.\n+            --  pragma Global which should be repeated in the global refinement\n+            --  (SPARK RM 7.2.4(3c), SPARK RM 7.2.4(3d)).\n \n             if Ekind (Item_Id) /= E_Abstract_State\n               or else not Has_Visible_Refinement (Item_Id)\n@@ -25523,6 +25531,7 @@ package body Sem_Prag is\n       procedure Report_Missing_Items is\n          Item_Elmt : Elmt_Id;\n          Item_Id   : Entity_Id;\n+\n       begin\n          --  Do not perform this check in an instance because it was already\n          --  performed successfully in the generic template.\n@@ -25650,10 +25659,11 @@ package body Sem_Prag is\n       --  refinement, prior to calling checking procedures which remove items\n       --  from the list of constituents.\n \n-      No_Constit := No (In_Constits)\n-        and then No (In_Out_Constits)\n-        and then No (Out_Constits)\n-        and then No (Proof_In_Constits);\n+      No_Constit :=\n+        No (In_Constits)\n+          and then No (In_Out_Constits)\n+          and then No (Out_Constits)\n+          and then No (Proof_In_Constits);\n \n       --  For Input states with visible refinement, at least one constituent\n       --  must be used as an Input in the global refinement.\n@@ -27267,46 +27277,10 @@ package body Sem_Prag is\n       Constits : Elist_Id;\n       Context  : Node_Id)\n    is\n-      function Find_Encapsulating_State\n-        (Constit_Id : Entity_Id) return Entity_Id;\n-      --  Given the entity of a constituent, try to find a corresponding\n-      --  encapsulating state that appears in the same context. The routine\n-      --  returns Empty is no such state is found.\n-\n-      ------------------------------\n-      -- Find_Encapsulating_State --\n-      ------------------------------\n-\n-      function Find_Encapsulating_State\n-        (Constit_Id : Entity_Id) return Entity_Id\n-      is\n-         State_Id : Entity_Id;\n-\n-      begin\n-         --  Since a constituent may be part of a larger constituent set, climb\n-         --  the encapsulating state chain looking for a state that appears in\n-         --  the same context.\n-\n-         State_Id := Encapsulating_State (Constit_Id);\n-         while Present (State_Id) loop\n-            if Contains (States, State_Id) then\n-               return State_Id;\n-            end if;\n-\n-            State_Id := Encapsulating_State (State_Id);\n-         end loop;\n-\n-         return Empty;\n-      end Find_Encapsulating_State;\n-\n-      --  Local variables\n-\n       Constit_Elmt : Elmt_Id;\n       Constit_Id   : Entity_Id;\n       State_Id     : Entity_Id;\n \n-   --  Start of processing for Check_State_And_Constituent_Use\n-\n    begin\n       --  Nothing to do if there are no states or constituents\n \n@@ -27325,7 +27299,7 @@ package body Sem_Prag is\n          --  state that appears in the same context and if this is the case,\n          --  emit an error (SPARK RM 7.2.6(7)).\n \n-         State_Id := Find_Encapsulating_State (Constit_Id);\n+         State_Id := Find_Encapsulating_State (States, Constit_Id);\n \n          if Present (State_Id) then\n             Error_Msg_Name_1 := Chars (Constit_Id);\n@@ -27801,6 +27775,33 @@ package body Sem_Prag is\n       return Num_Primitives (E mod 511);\n    end Entity_Hash;\n \n+   ------------------------------\n+   -- Find_Encapsulating_State --\n+   ------------------------------\n+\n+   function Find_Encapsulating_State\n+     (States     : Elist_Id;\n+      Constit_Id : Entity_Id) return Entity_Id\n+   is\n+      State_Id : Entity_Id;\n+\n+   begin\n+      --  Since a constituent may be part of a larger constituent set, climb\n+      --  the encapsulating state chain looking for a state that appears in\n+      --  States.\n+\n+      State_Id := Encapsulating_State (Constit_Id);\n+      while Present (State_Id) loop\n+         if Contains (States, State_Id) then\n+            return State_Id;\n+         end if;\n+\n+         State_Id := Encapsulating_State (State_Id);\n+      end loop;\n+\n+      return Empty;\n+   end Find_Encapsulating_State;\n+\n    --------------------------\n    -- Find_Related_Context --\n    --------------------------"}]}