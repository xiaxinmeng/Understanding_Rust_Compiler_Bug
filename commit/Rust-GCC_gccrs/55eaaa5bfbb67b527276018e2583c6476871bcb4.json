{"sha": "55eaaa5bfbb67b527276018e2583c6476871bcb4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTVlYWFhNWJmYmI2N2I1MjcyNzYwMThlMjU4M2M2NDc2ODcxYmNiNA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-02-04T21:46:45Z"}, "committer": {"name": "Steve Ellcey", "email": "sje@gcc.gnu.org", "date": "2011-02-04T21:46:45Z"}, "message": "re PR target/46997 (new ia64 vector instructions are broken on HP-UX (big-endian))\n\n2011-02-04  Richard Henderson  <rth@redhat.com>\n\t    Steve Ellcey  <sje@cup.hp.com>\n\n\tPR target/46997\n\t* config/ia64/predicates.md (mux1_brcst_element): New.\n\t* config/ia64/ia64-protos.h (ia64_unpack_assemble): New.\n\t* config/ia64/ia64.c (ia64_unpack_assemble): New.\n\t(ia64_unpack_sign): New.\n\t(ia64_expand_unpack): Rewrite using new routines.\n\t(ia64_expand_widen_sum): Ditto.\n\t(ia64_expand_dot_prod_v8qi): Ditto.\n\t* config/ia64/vect.md (mulv8qi3): Rewrite to use new\n\troutines, add endian check.\n\t(pmpy2_even): Rename from pmpy2_r, add endian check.\n\t(pmpy2_odd): Rename from pmpy2_l, add endian check.\n\t(vec_widen_smult_lo_v4hi): Rewrite using new routines.\n\t(vec_widen_smult_hi_v4hi): Ditto.\n\t(vec_widen_umult_lo_v4hi): Ditto.\n\t(vec_widen_umult_hi_v4hi): Ditto.\n\t(mulv2si3): Change endian checks.\n\t(sdot_prodv4hi): Rewrite with new calls.\n\t(udot_prodv4hi): New.\n\t(vec_pack_ssat_v4hi): Add endian check.\n\t(vec_pack_usat_v4hi): Ditto.\n\t(vec_pack_ssat_v2si): Ditto.\n\t(max1_even): Rename from max1_r, add endian check.\n\t(max1_odd): Rename from max1_l, add endian check.\n\t(*mux1_rev): Format change.\n\t(*mux1_mix): Ditto.\n\t(*mux1_shuf): Ditto.\n\t(*mux1_alt): Ditto.\n\t(*mux1_brcst_v8qi): Use new predicate.\n\t(vec_extract_evenv8qi): Remove endian check.\n\t(vec_extract_oddv8qi): Ditto.\n\t(vec_interleave_lowv4hi): Format change.\n\t(vec_interleave_highv4hi): Ditto.\n\t(mix2_even): Rename from mix2_r, add endian check.\n\t(mix2_odd): Rename from mux2_l, add endian check.\n\t(*mux2): Fix mask setting for TARGET_BIG_ENDIAN.\n\t(vec_extract_evenodd_helper): Format change.\n\t(vec_extract_evenv4hi): Remove endian check.\n\t(vec_extract_oddv4hi): Remove endian check.\n\t(vec_interleave_lowv2si): Format change.\n\t(vec_interleave_highv2si): Format change.\n\t(vec_initv2si): Remove endian check.\n\t(vecinit_v2si): Add endian check.\n\t(reduc_splus_v2sf): Add endian check.\n\t(reduc_smax_v2sf): Ditto.\n\t(reduc_smin_v2sf): Ditto.\n\t(vec_initv2sf): Remove endian check.\n\t(fpack): Add endian check.\n\t(fswap): Add endian check.\n\t(vec_interleave_highv2sf): Add endian check.\n\t(vec_interleave_lowv2sf): Add endian check.\n\t(fmix_lr): Add endian check.\n\t(vec_setv2sf): Format change.\n\t(*vec_extractv2sf_0_be): Use shift to extract operand.\n\t(*vec_extractv2sf_1_be): New.\n\t(vec_pack_trunc_v4hi): Add endian check.\n\t(vec_pack_trunc_v2si): Format change.\n\nCo-Authored-By: Steve Ellcey <sje@cup.hp.com>\n\nFrom-SVN: r169840", "tree": {"sha": "ae5c13bb70df956bd2a32cbaf1535518cc6d4725", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae5c13bb70df956bd2a32cbaf1535518cc6d4725"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55eaaa5bfbb67b527276018e2583c6476871bcb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55eaaa5bfbb67b527276018e2583c6476871bcb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55eaaa5bfbb67b527276018e2583c6476871bcb4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55eaaa5bfbb67b527276018e2583c6476871bcb4/comments", "author": null, "committer": null, "parents": [{"sha": "4946bd35e90fe6e04acbc765f32e88b266f902f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4946bd35e90fe6e04acbc765f32e88b266f902f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4946bd35e90fe6e04acbc765f32e88b266f902f0"}], "stats": {"total": 757, "additions": 416, "deletions": 341}, "files": [{"sha": "f1cc0ed475f1d675d139ecf2ddd6889f2fd33fc9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55eaaa5bfbb67b527276018e2583c6476871bcb4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55eaaa5bfbb67b527276018e2583c6476871bcb4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=55eaaa5bfbb67b527276018e2583c6476871bcb4", "patch": "@@ -1,3 +1,64 @@\n+2011-02-04  Richard Henderson  <rth@redhat.com>\n+\t    Steve Ellcey  <sje@cup.hp.com>\n+\n+\tPR target/46997\n+\t* config/ia64/predicates.md (mux1_brcst_element): New.\n+\t* config/ia64/ia64-protos.h (ia64_unpack_assemble): New.\n+\t* config/ia64/ia64.c (ia64_unpack_assemble): New.\n+\t(ia64_unpack_sign): New.\n+\t(ia64_expand_unpack): Rewrite using new routines.\n+\t(ia64_expand_widen_sum): Ditto.\n+\t(ia64_expand_dot_prod_v8qi): Ditto.\n+\t* config/ia64/vect.md (mulv8qi3): Rewrite to use new\n+\troutines, add endian check.\n+\t(pmpy2_even): Rename from pmpy2_r, add endian check.\n+\t(pmpy2_odd): Rename from pmpy2_l, add endian check.\n+\t(vec_widen_smult_lo_v4hi): Rewrite using new routines.\n+\t(vec_widen_smult_hi_v4hi): Ditto.\n+\t(vec_widen_umult_lo_v4hi): Ditto.\n+\t(vec_widen_umult_hi_v4hi): Ditto.\n+\t(mulv2si3): Change endian checks.\n+\t(sdot_prodv4hi): Rewrite with new calls.\n+\t(udot_prodv4hi): New.\n+\t(vec_pack_ssat_v4hi): Add endian check.\n+\t(vec_pack_usat_v4hi): Ditto.\n+\t(vec_pack_ssat_v2si): Ditto.\n+\t(max1_even): Rename from max1_r, add endian check.\n+\t(max1_odd): Rename from max1_l, add endian check.\n+\t(*mux1_rev): Format change.\n+\t(*mux1_mix): Ditto.\n+\t(*mux1_shuf): Ditto.\n+\t(*mux1_alt): Ditto.\n+\t(*mux1_brcst_v8qi): Use new predicate.\n+\t(vec_extract_evenv8qi): Remove endian check.\n+\t(vec_extract_oddv8qi): Ditto.\n+\t(vec_interleave_lowv4hi): Format change.\n+\t(vec_interleave_highv4hi): Ditto.\n+\t(mix2_even): Rename from mix2_r, add endian check.\n+\t(mix2_odd): Rename from mux2_l, add endian check.\n+\t(*mux2): Fix mask setting for TARGET_BIG_ENDIAN.\n+\t(vec_extract_evenodd_helper): Format change.\n+\t(vec_extract_evenv4hi): Remove endian check.\n+\t(vec_extract_oddv4hi): Remove endian check.\n+\t(vec_interleave_lowv2si): Format change.\n+\t(vec_interleave_highv2si): Format change.\n+\t(vec_initv2si): Remove endian check.\n+\t(vecinit_v2si): Add endian check.\n+\t(reduc_splus_v2sf): Add endian check.\n+\t(reduc_smax_v2sf): Ditto.\n+\t(reduc_smin_v2sf): Ditto.\n+\t(vec_initv2sf): Remove endian check.\n+\t(fpack): Add endian check.\n+\t(fswap): Add endian check.\n+\t(vec_interleave_highv2sf): Add endian check.\n+\t(vec_interleave_lowv2sf): Add endian check.\n+\t(fmix_lr): Add endian check.\n+\t(vec_setv2sf): Format change.\n+\t(*vec_extractv2sf_0_be): Use shift to extract operand.\n+\t(*vec_extractv2sf_1_be): New.\n+\t(vec_pack_trunc_v4hi): Add endian check.\n+\t(vec_pack_trunc_v2si): Format change.\n+\n 2011-02-04  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR inline-asm/23200"}, {"sha": "107a7ccb983fb180c78e5995c46969e4bcebfca6", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55eaaa5bfbb67b527276018e2583c6476871bcb4/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55eaaa5bfbb67b527276018e2583c6476871bcb4/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=55eaaa5bfbb67b527276018e2583c6476871bcb4", "patch": "@@ -39,9 +39,9 @@ extern bool ia64_expand_movxf_movrf (enum machine_mode, rtx[]);\n extern void ia64_expand_compare (rtx *, rtx *, rtx *);\n extern void ia64_expand_vecint_cmov (rtx[]);\n extern bool ia64_expand_vecint_minmax (enum rtx_code, enum machine_mode, rtx[]);\n+extern void ia64_unpack_assemble (rtx, rtx, rtx, bool);\n extern void ia64_expand_unpack (rtx [], bool, bool);\n extern void ia64_expand_widen_sum (rtx[], bool);\n-extern void ia64_expand_widen_mul_v4hi (rtx [], bool, bool);\n extern void ia64_expand_dot_prod_v8qi (rtx[], bool);\n extern void ia64_expand_call (rtx, rtx, rtx, int);\n extern void ia64_split_call (rtx, rtx, rtx, rtx, rtx, int, int);"}, {"sha": "1d3f8b18d347bd7db03de3d31338631ee05c9380", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 55, "deletions": 129, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55eaaa5bfbb67b527276018e2583c6476871bcb4/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55eaaa5bfbb67b527276018e2583c6476871bcb4/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=55eaaa5bfbb67b527276018e2583c6476871bcb4", "patch": "@@ -1972,12 +1972,13 @@ ia64_expand_vecint_minmax (enum rtx_code code, enum machine_mode mode,\n   return true;\n }\n \n-/* Emit an integral vector unpack operation.  */\n+/* The vectors LO and HI each contain N halves of a double-wide vector.\n+   Reassemble either the first N/2 or the second N/2 elements.  */\n \n void\n-ia64_expand_unpack (rtx operands[3], bool unsignedp, bool highp)\n+ia64_unpack_assemble (rtx out, rtx lo, rtx hi, bool highp)\n {\n-  enum machine_mode mode = GET_MODE (operands[1]);\n+  enum machine_mode mode = GET_MODE (lo);\n   rtx (*gen) (rtx, rtx, rtx);\n   rtx x;\n \n@@ -1993,173 +1994,98 @@ ia64_expand_unpack (rtx operands[3], bool unsignedp, bool highp)\n       gcc_unreachable ();\n     }\n \n-  /* Fill in x with the sign extension of each element in op1.  */\n-  if (unsignedp)\n-    x = CONST0_RTX (mode);\n-  else\n-    {\n-      bool neg;\n-\n-      x = gen_reg_rtx (mode);\n-\n-      neg = ia64_expand_vecint_compare (LT, mode, x, operands[1],\n-\t\t\t\t\tCONST0_RTX (mode));\n-      gcc_assert (!neg);\n-    }\n-\n+  x = gen_lowpart (mode, out);\n   if (TARGET_BIG_ENDIAN)\n-    emit_insn (gen (gen_lowpart (mode, operands[0]), x, operands[1]));\n+    x = gen (x, hi, lo);\n   else\n-    emit_insn (gen (gen_lowpart (mode, operands[0]), operands[1], x));\n+    x = gen (x, lo, hi);\n+  emit_insn (x);\n }\n \n-/* Emit an integral vector widening sum operations.  */\n+/* Return a vector of the sign-extension of VEC.  */\n \n-void\n-ia64_expand_widen_sum (rtx operands[3], bool unsignedp)\n+static rtx\n+ia64_unpack_sign (rtx vec, bool unsignedp)\n {\n-  rtx l, h, x, s;\n-  enum machine_mode wmode, mode;\n-  rtx (*unpack_l) (rtx, rtx, rtx);\n-  rtx (*unpack_h) (rtx, rtx, rtx);\n-  rtx (*plus) (rtx, rtx, rtx);\n-\n-  wmode = GET_MODE (operands[0]);\n-  mode = GET_MODE (operands[1]);\n+  enum machine_mode mode = GET_MODE (vec);\n+  rtx zero = CONST0_RTX (mode);\n \n-  switch (mode)\n-    {\n-    case V8QImode:\n-      unpack_l = gen_vec_interleave_lowv8qi;\n-      unpack_h = gen_vec_interleave_highv8qi;\n-      plus = gen_addv4hi3;\n-      break;\n-    case V4HImode:\n-      unpack_l = gen_vec_interleave_lowv4hi;\n-      unpack_h = gen_vec_interleave_highv4hi;\n-      plus = gen_addv2si3;\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  /* Fill in x with the sign extension of each element in op1.  */\n   if (unsignedp)\n-    x = CONST0_RTX (mode);\n+    return zero;\n   else\n     {\n+      rtx sign = gen_reg_rtx (mode);\n       bool neg;\n \n-      x = gen_reg_rtx (mode);\n-\n-      neg = ia64_expand_vecint_compare (LT, mode, x, operands[1],\n-\t\t\t\t\tCONST0_RTX (mode));\n+      neg = ia64_expand_vecint_compare (LT, mode, sign, vec, zero);\n       gcc_assert (!neg);\n+\n+      return sign;\n     }\n+}\n \n-  l = gen_reg_rtx (wmode);\n-  h = gen_reg_rtx (wmode);\n-  s = gen_reg_rtx (wmode);\n+/* Emit an integral vector unpack operation.  */\n \n-  if (TARGET_BIG_ENDIAN)\n-    {\n-      emit_insn (unpack_l (gen_lowpart (mode, l), x, operands[1]));\n-      emit_insn (unpack_h (gen_lowpart (mode, h), x, operands[1]));\n-    }\n-  else\n-    {\n-      emit_insn (unpack_l (gen_lowpart (mode, l), operands[1], x));\n-      emit_insn (unpack_h (gen_lowpart (mode, h), operands[1], x));\n-    }\n-  emit_insn (plus (s, l, operands[2]));\n-  emit_insn (plus (operands[0], h, s));\n+void\n+ia64_expand_unpack (rtx operands[3], bool unsignedp, bool highp)\n+{\n+  rtx sign = ia64_unpack_sign (operands[1], unsignedp);\n+  ia64_unpack_assemble (operands[0], operands[1], sign, highp);\n }\n \n+/* Emit an integral vector widening sum operations.  */\n+\n void\n-ia64_expand_widen_mul_v4hi (rtx operands[3], bool unsignedp, bool highp)\n+ia64_expand_widen_sum (rtx operands[3], bool unsignedp)\n {\n-  rtx l = gen_reg_rtx (V4HImode);\n-  rtx h = gen_reg_rtx (V4HImode);\n-  rtx (*mulhigh)(rtx, rtx, rtx, rtx);\n-  rtx (*interl)(rtx, rtx, rtx);\n+  enum machine_mode wmode;\n+  rtx l, h, t, sign;\n \n-  emit_insn (gen_mulv4hi3 (l, operands[1], operands[2]));\n+  sign = ia64_unpack_sign (operands[1], unsignedp);\n+\n+  wmode = GET_MODE (operands[0]);\n+  l = gen_reg_rtx (wmode);\n+  h = gen_reg_rtx (wmode);\n \n-  /* For signed, pmpy2.r would appear to more closely match this operation.\n-     However, the vectorizer is more likely to use the LO and HI patterns\n-     in pairs. At which point, with this formulation, the first two insns\n-     of each can be CSEd.  */\n-  mulhigh = unsignedp ? gen_pmpyshr2_u : gen_pmpyshr2;\n-  emit_insn (mulhigh (h, operands[1], operands[2], GEN_INT (16)));\n+  ia64_unpack_assemble (l, operands[1], sign, false);\n+  ia64_unpack_assemble (h, operands[1], sign, true);\n \n-  interl = highp ? gen_vec_interleave_highv4hi : gen_vec_interleave_lowv4hi;\n-  if (TARGET_BIG_ENDIAN)\n-    emit_insn (interl (gen_lowpart (V4HImode, operands[0]), h, l));\n-  else\n-    emit_insn (interl (gen_lowpart (V4HImode, operands[0]), l, h));\n+  t = expand_binop (wmode, add_optab, l, operands[2], NULL, 0, OPTAB_DIRECT);\n+  t = expand_binop (wmode, add_optab, h, t, operands[0], 0, OPTAB_DIRECT);\n+  if (t != operands[0])\n+    emit_move_insn (operands[0], t);\n }\n \n /* Emit a signed or unsigned V8QI dot product operation.  */\n \n void\n ia64_expand_dot_prod_v8qi (rtx operands[4], bool unsignedp)\n {\n-  rtx l1, l2, h1, h2, x1, x2, p1, p2, p3, p4, s1, s2, s3;\n+  rtx op1, op2, sn1, sn2, l1, l2, h1, h2;\n+  rtx p1, p2, p3, p4, s1, s2, s3;\n \n-  /* Fill in x1 and x2 with the sign extension of each element.  */\n-  if (unsignedp)\n-    x1 = x2 = CONST0_RTX (V8QImode);\n-  else\n-    {\n-      bool neg;\n-\n-      x1 = gen_reg_rtx (V8QImode);\n-      x2 = gen_reg_rtx (V8QImode);\n-\n-      neg = ia64_expand_vecint_compare (LT, V8QImode, x1, operands[1],\n-\t\t\t\t\tCONST0_RTX (V8QImode));\n-      gcc_assert (!neg);\n-      neg = ia64_expand_vecint_compare (LT, V8QImode, x2, operands[2],\n-\t\t\t\t\tCONST0_RTX (V8QImode));\n-      gcc_assert (!neg);\n-    }\n+  op1 = operands[1];\n+  op2 = operands[2];\n+  sn1 = ia64_unpack_sign (op1, unsignedp);\n+  sn2 = ia64_unpack_sign (op2, unsignedp);\n \n   l1 = gen_reg_rtx (V4HImode);\n   l2 = gen_reg_rtx (V4HImode);\n   h1 = gen_reg_rtx (V4HImode);\n   h2 = gen_reg_rtx (V4HImode);\n-\n-  if (TARGET_BIG_ENDIAN)\n-    {\n-      emit_insn (gen_vec_interleave_lowv8qi\n-\t\t (gen_lowpart (V8QImode, l1), x1, operands[1]));\n-      emit_insn (gen_vec_interleave_lowv8qi\n-\t\t (gen_lowpart (V8QImode, l2), x2, operands[2]));\n-      emit_insn (gen_vec_interleave_highv8qi\n-\t\t (gen_lowpart (V8QImode, h1), x1, operands[1]));\n-      emit_insn (gen_vec_interleave_highv8qi\n-\t\t (gen_lowpart (V8QImode, h2), x2, operands[2]));\n-    }\n-  else\n-    {\n-      emit_insn (gen_vec_interleave_lowv8qi\n-\t\t (gen_lowpart (V8QImode, l1), operands[1], x1));\n-      emit_insn (gen_vec_interleave_lowv8qi\n-\t\t (gen_lowpart (V8QImode, l2), operands[2], x2));\n-      emit_insn (gen_vec_interleave_highv8qi\n-\t\t (gen_lowpart (V8QImode, h1), operands[1], x1));\n-      emit_insn (gen_vec_interleave_highv8qi\n-\t\t (gen_lowpart (V8QImode, h2), operands[2], x2));\n-    }\n+  ia64_unpack_assemble (l1, op1, sn1, false);\n+  ia64_unpack_assemble (l2, op2, sn2, false);\n+  ia64_unpack_assemble (h1, op1, sn1, true);\n+  ia64_unpack_assemble (h2, op2, sn2, true);\n \n   p1 = gen_reg_rtx (V2SImode);\n   p2 = gen_reg_rtx (V2SImode);\n   p3 = gen_reg_rtx (V2SImode);\n   p4 = gen_reg_rtx (V2SImode);\n-  emit_insn (gen_pmpy2_r (p1, l1, l2));\n-  emit_insn (gen_pmpy2_l (p2, l1, l2));\n-  emit_insn (gen_pmpy2_r (p3, h1, h2));\n-  emit_insn (gen_pmpy2_l (p4, h1, h2));\n+  emit_insn (gen_pmpy2_even (p1, l1, l2));\n+  emit_insn (gen_pmpy2_even (p2, h1, h2));\n+  emit_insn (gen_pmpy2_odd (p3, l1, l2));\n+  emit_insn (gen_pmpy2_odd (p4, h1, h2));\n \n   s1 = gen_reg_rtx (V2SImode);\n   s2 = gen_reg_rtx (V2SImode);"}, {"sha": "6622b2001f4a6e8f2754fb96dcc5a420be317a9c", "filename": "gcc/config/ia64/predicates.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55eaaa5bfbb67b527276018e2583c6476871bcb4/gcc%2Fconfig%2Fia64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55eaaa5bfbb67b527276018e2583c6476871bcb4/gcc%2Fconfig%2Fia64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fpredicates.md?ref=55eaaa5bfbb67b527276018e2583c6476871bcb4", "patch": "@@ -624,3 +624,7 @@\n   return REG_P (op) && REG_POINTER (op);\n })\n \n+;; True if this is the right-most vector element; for mux1 @brcst.\n+(define_predicate \"mux1_brcst_element\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) == (TARGET_BIG_ENDIAN ? 7 : 0)\")))"}, {"sha": "ad367214d9d3b8c774ae17ea2e5087700cb41745", "filename": "gcc/config/ia64/vect.md", "status": "modified", "additions": 295, "deletions": 211, "changes": 506, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55eaaa5bfbb67b527276018e2583c6476871bcb4/gcc%2Fconfig%2Fia64%2Fvect.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55eaaa5bfbb67b527276018e2583c6476871bcb4/gcc%2Fconfig%2Fia64%2Fvect.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fvect.md?ref=55eaaa5bfbb67b527276018e2583c6476871bcb4", "patch": "@@ -172,35 +172,14 @@\n \t\t   (match_operand:V8QI 2 \"gr_register_operand\" \"r\")))]\n   \"\"\n {\n-  rtx r1, l1, r2, l2, rm, lm;\n-\n-  r1 = gen_reg_rtx (V4HImode);\n-  l1 = gen_reg_rtx (V4HImode);\n-  r2 = gen_reg_rtx (V4HImode);\n-  l2 = gen_reg_rtx (V4HImode);\n-\n-  /* Zero-extend the QImode elements into two words of HImode elements\n-     by interleaving them with zero bytes.  */\n-  emit_insn (gen_mix1_r (gen_lowpart (V8QImode, r1),\n-                         operands[1], CONST0_RTX (V8QImode)));\n-  emit_insn (gen_mix1_r (gen_lowpart (V8QImode, r2),\n-                         operands[2], CONST0_RTX (V8QImode)));\n-  emit_insn (gen_mix1_l (gen_lowpart (V8QImode, l1),\n-                         operands[1], CONST0_RTX (V8QImode)));\n-  emit_insn (gen_mix1_l (gen_lowpart (V8QImode, l2),\n-                         operands[2], CONST0_RTX (V8QImode)));\n-\n-  /* Multiply.  */\n-  rm = gen_reg_rtx (V4HImode);\n-  lm = gen_reg_rtx (V4HImode);\n-  emit_insn (gen_mulv4hi3 (rm, r1, r2));\n-  emit_insn (gen_mulv4hi3 (lm, l1, l2));\n-\n-  /* Zap the high order bytes of the HImode elements by overwriting those\n-     in one part with the low order bytes of the other.  */\n-  emit_insn (gen_mix1_r (operands[0],\n-                         gen_lowpart (V8QImode, rm),\n-                         gen_lowpart (V8QImode, lm)));\n+  rtx l = gen_reg_rtx (V4HImode);\n+  rtx h = gen_reg_rtx (V4HImode);\n+  emit_insn (gen_vec_widen_umult_lo_v8qi (l, operands[1], operands[2]));\n+  emit_insn (gen_vec_widen_umult_hi_v8qi (h, operands[1], operands[2]));\n+  if (TARGET_BIG_ENDIAN)\n+    emit_insn (gen_vec_pack_trunc_v4hi (operands[0], h, l));\n+  else\n+    emit_insn (gen_vec_pack_trunc_v4hi (operands[0], l, h));\n   DONE;\n })\n \n@@ -296,7 +275,7 @@\n   \"pmpyshr2.u %0 = %1, %2, %3\"\n   [(set_attr \"itanium_class\" \"mmmul\")])\n \n-(define_insn \"pmpy2_r\"\n+(define_insn \"pmpy2_even\"\n   [(set (match_operand:V2SI 0 \"gr_register_operand\" \"=r\")\n \t(mult:V2SI\n \t  (vec_select:V2SI\n@@ -308,10 +287,16 @@\n \t      (match_operand:V4HI 2 \"gr_register_operand\" \"r\"))\n \t    (parallel [(const_int 0) (const_int 2)]))))]\n   \"\"\n-  \"pmpy2.r %0 = %1, %2\"\n+{\n+  /* Recall that vector elements are numbered in memory order.  */\n+  if (TARGET_BIG_ENDIAN)\n+    return \"%,pmpy2.l %0 = %1, %2\";\n+  else\n+    return \"%,pmpy2.r %0 = %1, %2\";\n+}\n   [(set_attr \"itanium_class\" \"mmshf\")])\n \n-(define_insn \"pmpy2_l\"\n+(define_insn \"pmpy2_odd\"\n   [(set (match_operand:V2SI 0 \"gr_register_operand\" \"=r\")\n \t(mult:V2SI\n \t  (vec_select:V2SI\n@@ -323,7 +308,13 @@\n \t      (match_operand:V4HI 2 \"gr_register_operand\" \"r\"))\n \t    (parallel [(const_int 1) (const_int 3)]))))]\n   \"\"\n-  \"pmpy2.l %0 = %1, %2\"\n+{\n+  /* Recall that vector elements are numbered in memory order.  */\n+  if (TARGET_BIG_ENDIAN)\n+    return \"%,pmpy2.r %0 = %1, %2\";\n+  else\n+    return \"%,pmpy2.l %0 = %1, %2\";\n+}\n   [(set_attr \"itanium_class\" \"mmshf\")])\n \n (define_expand \"vec_widen_smult_lo_v4hi\"\n@@ -332,7 +323,11 @@\n    (match_operand:V4HI 2 \"gr_register_operand\" \"\")]\n   \"\"\n {\n-  ia64_expand_widen_mul_v4hi (operands, false, false);\n+  rtx l = gen_reg_rtx (V4HImode);\n+  rtx h = gen_reg_rtx (V4HImode);\n+  emit_insn (gen_mulv4hi3 (l, operands[1], operands[2]));\n+  emit_insn (gen_pmpyshr2 (h, operands[1], operands[2], GEN_INT (16)));\n+  ia64_unpack_assemble (operands[0], l, h, false);\n   DONE;\n })\n \n@@ -342,7 +337,11 @@\n    (match_operand:V4HI 2 \"gr_register_operand\" \"\")]\n   \"\"\n {\n-  ia64_expand_widen_mul_v4hi (operands, false, true);\n+  rtx l = gen_reg_rtx (V4HImode);\n+  rtx h = gen_reg_rtx (V4HImode);\n+  emit_insn (gen_mulv4hi3 (l, operands[1], operands[2]));\n+  emit_insn (gen_pmpyshr2 (h, operands[1], operands[2], GEN_INT (16)));\n+  ia64_unpack_assemble (operands[0], l, h, true);\n   DONE;\n })\n \n@@ -352,7 +351,11 @@\n    (match_operand:V4HI 2 \"gr_register_operand\" \"\")]\n   \"\"\n {\n-  ia64_expand_widen_mul_v4hi (operands, true, false);\n+  rtx l = gen_reg_rtx (V4HImode);\n+  rtx h = gen_reg_rtx (V4HImode);\n+  emit_insn (gen_mulv4hi3 (l, operands[1], operands[2]));\n+  emit_insn (gen_pmpyshr2_u (h, operands[1], operands[2], GEN_INT (16)));\n+  ia64_unpack_assemble (operands[0], l, h, false);\n   DONE;\n })\n \n@@ -362,7 +365,11 @@\n    (match_operand:V4HI 2 \"gr_register_operand\" \"\")]\n   \"\"\n {\n-  ia64_expand_widen_mul_v4hi (operands, true, true);\n+  rtx l = gen_reg_rtx (V4HImode);\n+  rtx h = gen_reg_rtx (V4HImode);\n+  emit_insn (gen_mulv4hi3 (l, operands[1], operands[2]));\n+  emit_insn (gen_pmpyshr2_u (h, operands[1], operands[2], GEN_INT (16)));\n+  ia64_unpack_assemble (operands[0], l, h, true);\n   DONE;\n })\n \n@@ -390,12 +397,8 @@\n      of the full 32-bit product.  */\n \n   /* T0 = CDBA.  */\n-  if (TARGET_BIG_ENDIAN)\n-    x = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (4, GEN_INT (3), const2_rtx,\n-\t\t\t\t\t       const1_rtx, const0_rtx));\n-  else\n-    x = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (4, const1_rtx, const0_rtx,\n-\t\t\t\t\t       GEN_INT (3), const2_rtx));\n+  x = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (4, const1_rtx, const0_rtx,\n+\t\t\t\t\t     GEN_INT (3), const2_rtx));\n   x = gen_rtx_VEC_SELECT (V4HImode, op1h, x);\n   emit_insn (gen_rtx_SET (VOIDmode, t0, x));\n \n@@ -409,15 +412,28 @@\n   emit_insn (gen_mulv4hi3 (t3, t0, op2h));\n \n   /* T4 = CY.h, CY.l, AW.h, AW.l = CY, AW.  */\n-  emit_insn (gen_mix2_r (gen_lowpart (V4HImode, t4), t1, t2));\n+  x = gen_lowpart (V4HImode, t4);\n+  if (TARGET_BIG_ENDIAN)\n+    x = gen_mix2_odd (x, t2, t1);\n+  else\n+    x = gen_mix2_even (x, t1, t2);\n+  emit_insn (x);\n \n   /* T5 = CZ.l, 0, AX.l, 0 = CZ << 16, AX << 16.  */\n-  emit_insn (gen_mix2_l (gen_lowpart (V4HImode, t5),\n-\t\t\t CONST0_RTX (V4HImode), t3));\n+  x = gen_lowpart (V4HImode, t5);\n+  if (TARGET_BIG_ENDIAN)\n+    x = gen_mix2_even (x, t3, CONST0_RTX (V4HImode));\n+  else\n+    x = gen_mix2_odd (x, CONST0_RTX (V4HImode), t3);\n+  emit_insn (x);\n \n   /* T6 = DY.l, 0, BW.l, 0 = DY << 16, BW << 16.  */\n-  emit_insn (gen_mix2_r (gen_lowpart (V4HImode, t6),\n-\t\t\t CONST0_RTX (V4HImode), t3));\n+  x = gen_lowpart (V4HImode, t6);\n+  if (TARGET_BIG_ENDIAN)\n+    x = gen_mix2_odd (x, t3, CONST0_RTX (V4HImode));\n+  else\n+    x = gen_mix2_even (x, CONST0_RTX (V4HImode), t3);\n+  emit_insn (x);\n \n   emit_insn (gen_addv2si3 (t7, t4, t5));\n   emit_insn (gen_addv2si3 (operands[0], t6, t7));\n@@ -612,16 +628,36 @@\n    (match_operand:V2SI 3 \"gr_register_operand\" \"\")]\n   \"\"\n {\n-  rtx l, r, t;\n+  rtx e, o, t;\n+\n+  e = gen_reg_rtx (V2SImode);\n+  o = gen_reg_rtx (V2SImode);\n+  t = gen_reg_rtx (V2SImode);\n+\n+  emit_insn (gen_pmpy2_even (e, operands[1], operands[2]));\n+  emit_insn (gen_pmpy2_odd (o, operands[1], operands[2]));\n+  emit_insn (gen_addv2si3 (t, e, operands[3]));\n+  emit_insn (gen_addv2si3 (operands[0], t, o));\n+  DONE;\n+})\n+\n+(define_expand \"udot_prodv4hi\"\n+  [(match_operand:V2SI 0 \"gr_register_operand\" \"\")\n+   (match_operand:V4HI 1 \"gr_register_operand\" \"\")\n+   (match_operand:V4HI 2 \"gr_register_operand\" \"\")\n+   (match_operand:V2SI 3 \"gr_register_operand\" \"\")]\n+  \"\"\n+{\n+  rtx l, h, t;\n \n-  r = gen_reg_rtx (V2SImode);\n   l = gen_reg_rtx (V2SImode);\n+  h = gen_reg_rtx (V2SImode);\n   t = gen_reg_rtx (V2SImode);\n \n-  emit_insn (gen_pmpy2_r (r, operands[1], operands[2]));\n-  emit_insn (gen_pmpy2_l (l, operands[1], operands[2]));\n-  emit_insn (gen_addv2si3 (t, r, operands[3]));\n-  emit_insn (gen_addv2si3 (operands[0], t, l));\n+  emit_insn (gen_vec_widen_umult_lo_v4hi (l, operands[1], operands[2]));\n+  emit_insn (gen_vec_widen_umult_hi_v4hi (h, operands[1], operands[2]));\n+  emit_insn (gen_addv2si3 (t, l, operands[3]));\n+  emit_insn (gen_addv2si3 (operands[0], t, h));\n   DONE;\n })\n \n@@ -677,7 +713,13 @@\n \t  (ss_truncate:V4QI\n \t    (match_operand:V4HI 2 \"gr_reg_or_0_operand\" \"rU\"))))]\n   \"\"\n-  \"pack2.sss %0 = %r1, %r2\"\n+{\n+  /* Recall that vector elements are numbered in memory order.  */\n+  if (TARGET_BIG_ENDIAN)\n+    return \"%,pack2.sss %0 = %r2, %r1\";\n+  else\n+    return \"%,pack2.sss %0 = %r1, %r2\";\n+}\n   [(set_attr \"itanium_class\" \"mmshf\")])\n \n (define_insn \"vec_pack_usat_v4hi\"\n@@ -688,7 +730,13 @@\n \t  (us_truncate:V4QI\n \t    (match_operand:V4HI 2 \"gr_reg_or_0_operand\" \"rU\"))))]\n   \"\"\n-  \"pack2.uss %0 = %r1, %r2\"\n+{\n+  /* Recall that vector elements are numbered in memory order.  */\n+  if (TARGET_BIG_ENDIAN)\n+    return \"%,pack2.uss %0 = %r2, %r1\";\n+  else\n+    return \"%,pack2.uss %0 = %r1, %r2\";\n+}\n   [(set_attr \"itanium_class\" \"mmshf\")])\n \n (define_insn \"vec_pack_ssat_v2si\"\n@@ -699,7 +747,13 @@\n \t  (ss_truncate:V2HI\n \t    (match_operand:V2SI 2 \"gr_reg_or_0_operand\" \"rU\"))))]\n   \"\"\n-  \"pack4.sss %0 = %r1, %r2\"\n+{\n+  /* Recall that vector elements are numbered in memory order.  */\n+  if (TARGET_BIG_ENDIAN)\n+    return \"%,pack4.sss %0 = %r2, %r1\";\n+  else\n+    return \"%,pack4.sss %0 = %r1, %r2\";\n+}\n   [(set_attr \"itanium_class\" \"mmshf\")])\n \n (define_insn \"vec_interleave_lowv8qi\"\n@@ -742,54 +796,54 @@\n }\n   [(set_attr \"itanium_class\" \"mmshf\")])\n \n-(define_insn \"mix1_r\"\n+(define_insn \"mix1_even\"\n   [(set (match_operand:V8QI 0 \"gr_register_operand\" \"=r\")\n \t(vec_select:V8QI\n \t  (vec_concat:V16QI\n \t    (match_operand:V8QI 1 \"gr_reg_or_0_operand\" \"rU\")\n \t    (match_operand:V8QI 2 \"gr_reg_or_0_operand\" \"rU\"))\n-\t  (parallel [(const_int 0)\n-\t\t     (const_int 8)\n-\t\t     (const_int 2)\n-\t\t     (const_int 10)\n-\t\t     (const_int 4)\n-\t\t     (const_int 12)\n-\t\t     (const_int 6)\n-\t\t     (const_int 14)])))]\n-  \"\"\n-  \"mix1.r %0 = %r2, %r1\"\n+\t  (parallel [(const_int 0) (const_int 8)\n+\t\t     (const_int 2) (const_int 10)\n+\t\t     (const_int 4) (const_int 12)\n+\t\t     (const_int 6) (const_int 14)])))]\n+  \"\"\n+{\n+  /* Recall that vector elements are numbered in memory order.  */\n+  if (TARGET_BIG_ENDIAN)\n+    return \"%,mix1.l %0 = %r1, %r2\";\n+  else\n+    return \"%,mix1.r %0 = %r2, %r1\";\n+}\n   [(set_attr \"itanium_class\" \"mmshf\")])\n \n-(define_insn \"mix1_l\"\n+(define_insn \"mix1_odd\"\n   [(set (match_operand:V8QI 0 \"gr_register_operand\" \"=r\")\n \t(vec_select:V8QI\n \t  (vec_concat:V16QI\n \t    (match_operand:V8QI 1 \"gr_reg_or_0_operand\" \"rU\")\n \t    (match_operand:V8QI 2 \"gr_reg_or_0_operand\" \"rU\"))\n-\t  (parallel [(const_int 1)\n-\t\t     (const_int 9)\n-\t\t     (const_int 3)\n-\t\t     (const_int 11)\n-\t\t     (const_int 5)\n-\t\t     (const_int 13)\n-\t\t     (const_int 7)\n-\t\t     (const_int 15)])))]\n-  \"\"\n-  \"mix1.l %0 = %r2, %r1\"\n+\t  (parallel [(const_int 1) (const_int 9)\n+\t\t     (const_int 3) (const_int 11)\n+\t\t     (const_int 5) (const_int 13)\n+\t\t     (const_int 7) (const_int 15)])))]\n+  \"\"\n+{\n+  /* Recall that vector elements are numbered in memory order.  */\n+  if (TARGET_BIG_ENDIAN)\n+    return \"%,mix1.r %0 = %r1, %r2\";\n+  else\n+    return \"%,mix1.l %0 = %r2, %r1\";\n+}\n   [(set_attr \"itanium_class\" \"mmshf\")])\n \n (define_insn \"*mux1_rev\"\n   [(set (match_operand:V8QI 0 \"gr_register_operand\" \"=r\")\n \t(vec_select:V8QI\n \t  (match_operand:V8QI 1 \"gr_register_operand\" \"r\")\n-\t  (parallel [(const_int 7)\n-\t\t     (const_int 6)\n-\t\t     (const_int 5)\n-\t\t     (const_int 4)\n-\t\t     (const_int 3)\n-\t\t     (const_int 2)\n-\t\t     (const_int 1)\n-\t\t     (const_int 0)])))]\n+\t  (parallel [(const_int 7) (const_int 6)\n+\t\t     (const_int 5) (const_int 4)\n+\t\t     (const_int 3) (const_int 2)\n+\t\t     (const_int 1) (const_int 0)])))]\n   \"\"\n   \"mux1 %0 = %1, @rev\"\n   [(set_attr \"itanium_class\" \"mmshf\")])\n@@ -798,14 +852,10 @@\n   [(set (match_operand:V8QI 0 \"gr_register_operand\" \"=r\")\n \t(vec_select:V8QI\n \t  (match_operand:V8QI 1 \"gr_register_operand\" \"r\")\n-\t  (parallel [(const_int 0)\n-\t\t     (const_int 4)\n-\t\t     (const_int 2)\n-\t\t     (const_int 6)\n-\t\t     (const_int 1)\n-\t\t     (const_int 5)\n-\t\t     (const_int 3)\n-\t\t     (const_int 7)])))]\n+\t  (parallel [(const_int 0) (const_int 4)\n+\t\t     (const_int 2) (const_int 6)\n+\t\t     (const_int 1) (const_int 5)\n+\t\t     (const_int 3) (const_int 7)])))]\n   \"\"\n   \"mux1 %0 = %1, @mix\"\n   [(set_attr \"itanium_class\" \"mmshf\")])\n@@ -814,14 +864,10 @@\n   [(set (match_operand:V8QI 0 \"gr_register_operand\" \"=r\")\n \t(vec_select:V8QI\n \t  (match_operand:V8QI 1 \"gr_register_operand\" \"r\")\n-\t  (parallel [(const_int 0)\n-\t\t     (const_int 4)\n-\t\t     (const_int 1)\n-\t\t     (const_int 5)\n-\t\t     (const_int 2)\n-\t\t     (const_int 6)\n-\t\t     (const_int 3)\n-\t\t     (const_int 7)])))]\n+\t  (parallel [(const_int 0) (const_int 4)\n+\t\t     (const_int 1) (const_int 5)\n+\t\t     (const_int 2) (const_int 6)\n+\t\t     (const_int 3) (const_int 7)])))]\n   \"\"\n   \"mux1 %0 = %1, @shuf\"\n   [(set_attr \"itanium_class\" \"mmshf\")])\n@@ -830,14 +876,10 @@\n   [(set (match_operand:V8QI 0 \"gr_register_operand\" \"=r\")\n \t(vec_select:V8QI\n \t  (match_operand:V8QI 1 \"gr_register_operand\" \"r\")\n-\t  (parallel [(const_int 0)\n-\t\t     (const_int 2)\n-\t\t     (const_int 4)\n-\t\t     (const_int 6)\n-\t\t     (const_int 1)\n-\t\t     (const_int 3)\n-\t\t     (const_int 5)\n-\t\t     (const_int 7)])))]\n+\t  (parallel [(const_int 0) (const_int 2)\n+\t\t     (const_int 4) (const_int 6)\n+\t\t     (const_int 1) (const_int 3)\n+\t\t     (const_int 5) (const_int 7)])))]\n   \"\"\n   \"mux1 %0 = %1, @alt\"\n   [(set_attr \"itanium_class\" \"mmshf\")])\n@@ -846,14 +888,14 @@\n   [(set (match_operand:V8QI 0 \"gr_register_operand\" \"=r\")\n \t(vec_select:V8QI\n \t  (match_operand:V8QI 1 \"gr_register_operand\" \"r\")\n-\t  (parallel [(const_int 0)\n-\t\t     (const_int 0)\n-\t\t     (const_int 0)\n-\t\t     (const_int 0)\n-\t\t     (const_int 0)\n-\t\t     (const_int 0)\n-\t\t     (const_int 0)\n-\t\t     (const_int 0)])))]\n+\t  (parallel [(match_operand 2 \"mux1_brcst_element\" \"\")\n+\t\t     (match_dup 2)\n+\t\t     (match_dup 2)\n+\t\t     (match_dup 2)\n+\t\t     (match_dup 2)\n+\t\t     (match_dup 2)\n+\t\t     (match_dup 2)\n+\t\t     (match_dup 2)])))]\n   \"\"\n   \"mux1 %0 = %1, @brcst\"\n   [(set_attr \"itanium_class\" \"mmshf\")])\n@@ -873,10 +915,7 @@\n   \"\"\n {\n   rtx temp = gen_reg_rtx (V8QImode);\n-  if (TARGET_BIG_ENDIAN)\n-    emit_insn (gen_mix1_l (temp, operands[2], operands[1]));\n-  else\n-    emit_insn (gen_mix1_r (temp, operands[1], operands[2]));\n+  emit_insn (gen_mix1_even (temp, operands[1], operands[2]));\n   emit_insn (gen_mux1_alt (operands[0], temp));\n   DONE;\n })\n@@ -888,10 +927,7 @@\n   \"\"\n {\n   rtx temp = gen_reg_rtx (V8QImode);\n-  if (TARGET_BIG_ENDIAN)\n-    emit_insn (gen_mix1_r (temp, operands[2], operands[1]));\n-  else\n-    emit_insn (gen_mix1_l (temp, operands[1], operands[2]));\n+  emit_insn (gen_mix1_odd (temp, operands[1], operands[2]));\n   emit_insn (gen_mux1_alt (operands[0], temp));\n   DONE;\n })\n@@ -902,10 +938,8 @@\n \t  (vec_concat:V8HI\n \t    (match_operand:V4HI 1 \"gr_reg_or_0_operand\" \"rU\")\n \t    (match_operand:V4HI 2 \"gr_reg_or_0_operand\" \"rU\"))\n-\t  (parallel [(const_int 0)\n-\t\t     (const_int 4)\n-\t\t     (const_int 1)\n-\t\t     (const_int 5)])))]\n+\t  (parallel [(const_int 0) (const_int 4)\n+\t\t     (const_int 1) (const_int 5)])))]\n   \"\"\n {\n   /* Recall that vector elements are numbered in memory order.  */\n@@ -922,10 +956,8 @@\n \t  (vec_concat:V8HI\n \t    (match_operand:V4HI 1 \"gr_reg_or_0_operand\" \"rU\")\n \t    (match_operand:V4HI 2 \"gr_reg_or_0_operand\" \"rU\"))\n-\t  (parallel [(const_int 2)\n-\t\t     (const_int 6)\n-\t\t     (const_int 3)\n-\t\t     (const_int 7)])))]\n+\t  (parallel [(const_int 2) (const_int 6)\n+\t\t     (const_int 3) (const_int 7)])))]\n   \"\"\n {\n   /* Recall that vector elements are numbered in memory order.  */\n@@ -936,32 +968,40 @@\n }\n   [(set_attr \"itanium_class\" \"mmshf\")])\n \n-(define_insn \"mix2_r\"\n+(define_insn \"mix2_even\"\n   [(set (match_operand:V4HI 0 \"gr_register_operand\" \"=r\")\n \t(vec_select:V4HI\n \t  (vec_concat:V8HI\n \t    (match_operand:V4HI 1 \"gr_reg_or_0_operand\" \"rU\")\n \t    (match_operand:V4HI 2 \"gr_reg_or_0_operand\" \"rU\"))\n-\t  (parallel [(const_int 0)\n-\t\t     (const_int 4)\n-\t\t     (const_int 2)\n-\t\t     (const_int 6)])))]\n+\t  (parallel [(const_int 0) (const_int 4)\n+\t\t     (const_int 2) (const_int 6)])))]\n   \"\"\n-  \"mix2.r %0 = %r2, %r1\"\n+{\n+  /* Recall that vector elements are numbered in memory order.  */\n+  if (TARGET_BIG_ENDIAN)\n+    return \"%,mix2.l %0 = %r1, %r2\";\n+  else\n+    return \"%,mix2.r %0 = %r2, %r1\";\n+}\n   [(set_attr \"itanium_class\" \"mmshf\")])\n \n-(define_insn \"mix2_l\"\n+(define_insn \"mix2_odd\"\n   [(set (match_operand:V4HI 0 \"gr_register_operand\" \"=r\")\n \t(vec_select:V4HI\n \t  (vec_concat:V8HI\n \t    (match_operand:V4HI 1 \"gr_reg_or_0_operand\" \"rU\")\n \t    (match_operand:V4HI 2 \"gr_reg_or_0_operand\" \"rU\"))\n-\t  (parallel [(const_int 1)\n-\t\t     (const_int 5)\n-\t\t     (const_int 3)\n-\t\t     (const_int 7)])))]\n+\t  (parallel [(const_int 1) (const_int 5)\n+\t\t     (const_int 3) (const_int 7)])))]\n   \"\"\n-  \"mix2.l %0 = %r2, %r1\"\n+{\n+  /* Recall that vector elements are numbered in memory order.  */\n+  if (TARGET_BIG_ENDIAN)\n+    return \"%,mix2.r %0 = %r1, %r2\";\n+  else\n+    return \"%,mix2.l %0 = %r2, %r1\";\n+}\n   [(set_attr \"itanium_class\" \"mmshf\")])\n \n (define_insn \"*mux2\"\n@@ -974,17 +1014,17 @@\n \t\t     (match_operand 5 \"const_int_2bit_operand\" \"\")])))]\n   \"\"\n {\n-  int mask;\n+  int mask = 0;\n   if (TARGET_BIG_ENDIAN)\n     {\n-      mask  = INTVAL (operands[2]) << 4;\n-      mask |= INTVAL (operands[3]) << 6;\n-      mask |= INTVAL (operands[4]);\n-      mask |= INTVAL (operands[5]) << 2;\n+      mask |= (3 - INTVAL (operands[2])) << 6;\n+      mask |= (3 - INTVAL (operands[3])) << 4;\n+      mask |= (3 - INTVAL (operands[4])) << 2;\n+      mask |= 3 - INTVAL (operands[5]);\n     }\n   else\n     {\n-      mask  = INTVAL (operands[2]);\n+      mask |= INTVAL (operands[2]);\n       mask |= INTVAL (operands[3]) << 2;\n       mask |= INTVAL (operands[4]) << 4;\n       mask |= INTVAL (operands[5]) << 6;\n@@ -998,10 +1038,8 @@\n   [(set (match_operand:V4HI 0 \"gr_register_operand\" \"\")\n \t(vec_select:V4HI\n \t  (match_operand:V4HI 1 \"gr_register_operand\" \"\")\n-\t  (parallel [(const_int 0)\n-\t\t     (const_int 2)\n-\t\t     (const_int 1)\n-\t\t     (const_int 3)])))]\n+\t  (parallel [(const_int 0) (const_int 2)\n+\t\t     (const_int 1) (const_int 3)])))]\n   \"\")\n \n (define_expand \"vec_extract_evenv4hi\"\n@@ -1011,10 +1049,7 @@\n   \"\"\n {\n   rtx temp = gen_reg_rtx (V4HImode);\n-  if (TARGET_BIG_ENDIAN)\n-    emit_insn (gen_mix2_l (temp, operands[1], operands[2]));\n-  else\n-    emit_insn (gen_mix2_r (temp, operands[1], operands[2]));\n+  emit_insn (gen_mix2_even (temp, operands[1], operands[2]));\n   emit_insn (gen_vec_extract_evenodd_helper (operands[0], temp));\n   DONE;\n })\n@@ -1026,10 +1061,7 @@\n   \"\"\n {\n   rtx temp = gen_reg_rtx (V4HImode);\n-  if (TARGET_BIG_ENDIAN)\n-    emit_insn (gen_mix2_r (temp, operands[1], operands[2]));\n-  else\n-    emit_insn (gen_mix2_l (temp, operands[1], operands[2]));\n+  emit_insn (gen_mix2_odd (temp, operands[1], operands[2]));\n   emit_insn (gen_vec_extract_evenodd_helper (operands[0], temp));\n   DONE;\n })\n@@ -1042,15 +1074,13 @@\n   \"mux2 %0 = %1, 0\"\n   [(set_attr \"itanium_class\" \"mmshf\")])\n \n-;; Note that mix4.r performs the exact same operation.\n (define_insn \"vec_interleave_lowv2si\"\n   [(set (match_operand:V2SI 0 \"gr_register_operand\" \"=r\")\n \t(vec_select:V2SI\n \t  (vec_concat:V4SI\n \t    (match_operand:V2SI 1 \"gr_reg_or_0_operand\" \"rU\")\n \t    (match_operand:V2SI 2 \"gr_reg_or_0_operand\" \"rU\"))\n-\t  (parallel [(const_int 0)\n-\t\t     (const_int 2)])))]\n+\t  (parallel [(const_int 0) (const_int 2)])))]\n   \"\"\n {\n   /* Recall that vector elements are numbered in memory order.  */\n@@ -1061,15 +1091,13 @@\n }\n   [(set_attr \"itanium_class\" \"mmshf\")])\n \n-;; Note that mix4.l performs the exact same operation.\n (define_insn \"vec_interleave_highv2si\"\n   [(set (match_operand:V2SI 0 \"gr_register_operand\" \"=r\")\n \t(vec_select:V2SI\n \t  (vec_concat:V4SI\n \t    (match_operand:V2SI 1 \"gr_reg_or_0_operand\" \"rU\")\n \t    (match_operand:V2SI 2 \"gr_reg_or_0_operand\" \"rU\"))\n-\t  (parallel [(const_int 1)\n-\t\t     (const_int 3)])))]\n+\t  (parallel [(const_int 1) (const_int 3)])))]\n   \"\"\n {\n   /* Recall that vector elements are numbered in memory order.  */\n@@ -1088,7 +1116,7 @@\n {\n   if (TARGET_BIG_ENDIAN)\n     emit_insn (gen_vec_interleave_highv2si (operands[0], operands[1],\n-\t\t\t\t\t   operands[2]));\n+\t\t\t\t\t    operands[2]));\n   else\n     emit_insn (gen_vec_interleave_lowv2si (operands[0], operands[1],\n \t\t\t\t\t   operands[2]));\n@@ -1103,7 +1131,7 @@\n {\n   if (TARGET_BIG_ENDIAN)\n     emit_insn (gen_vec_interleave_lowv2si (operands[0], operands[1],\n-\t\t\t\t\t    operands[2]));\n+\t\t\t\t\t   operands[2]));\n   else\n     emit_insn (gen_vec_interleave_highv2si (operands[0], operands[1],\n \t\t\t\t\t    operands[2]));\n@@ -1131,10 +1159,7 @@\n   if (!gr_reg_or_0_operand (op2, SImode))\n     op2 = force_reg (SImode, op2);\n \n-  if (TARGET_BIG_ENDIAN)\n-    x = gen_rtx_VEC_CONCAT (V2SImode, op2, op1);\n-  else\n-    x = gen_rtx_VEC_CONCAT (V2SImode, op1, op2);\n+  x = gen_rtx_VEC_CONCAT (V2SImode, op1, op2);\n   emit_insn (gen_rtx_SET (VOIDmode, operands[0], x));\n   DONE;\n })\n@@ -1145,7 +1170,13 @@\n \t  (match_operand:SI 1 \"gr_reg_or_0_operand\" \"rO\")\n \t  (match_operand:SI 2 \"gr_reg_or_0_operand\" \"rO\")))]\n   \"\"\n-  \"unpack4.l %0 = %r2, %r1\"\n+{\n+  /* Recall that vector elements are numbered in memory order.  */\n+  if (TARGET_BIG_ENDIAN)\n+    return \"%,unpack4.l %0 = %r1, %r2\";\n+  else\n+    return \"%,unpack4.l %0 = %r2, %r1\";\n+}\n   [(set_attr \"itanium_class\" \"mmshf\")])\n \n ;; Missing operations\n@@ -1315,7 +1346,10 @@\n   \"\"\n {\n   rtx tmp = gen_reg_rtx (V2SFmode);\n-  emit_insn (gen_fswap (tmp, operands[1], CONST0_RTX (V2SFmode)));\n+  if (TARGET_BIG_ENDIAN)\n+    emit_insn (gen_fswap (tmp, CONST0_RTX (V2SFmode), operands[1]));\n+  else\n+    emit_insn (gen_fswap (tmp, operands[1], CONST0_RTX (V2SFmode)));\n   emit_insn (gen_addv2sf3 (operands[0], operands[1], tmp));\n   DONE;\n })\n@@ -1326,7 +1360,10 @@\n   \"\"\n {\n   rtx tmp = gen_reg_rtx (V2SFmode);\n-  emit_insn (gen_fswap (tmp, operands[1], CONST0_RTX (V2SFmode)));\n+  if (TARGET_BIG_ENDIAN)\n+    emit_insn (gen_fswap (tmp, CONST0_RTX (V2SFmode), operands[1]));\n+  else\n+    emit_insn (gen_fswap (tmp, operands[1], CONST0_RTX (V2SFmode)));\n   emit_insn (gen_smaxv2sf3 (operands[0], operands[1], tmp));\n   DONE;\n })\n@@ -1337,7 +1374,10 @@\n   \"\"\n {\n   rtx tmp = gen_reg_rtx (V2SFmode);\n-  emit_insn (gen_fswap (tmp, operands[1], CONST0_RTX (V2SFmode)));\n+  if (TARGET_BIG_ENDIAN)\n+    emit_insn (gen_fswap (tmp, CONST0_RTX (V2SFmode), operands[1]));\n+  else\n+    emit_insn (gen_fswap (tmp, operands[1], CONST0_RTX (V2SFmode)));\n   emit_insn (gen_sminv2sf3 (operands[0], operands[1], tmp));\n   DONE;\n })\n@@ -1403,10 +1443,7 @@\n   if (!fr_reg_or_fp01_operand (op2, SFmode))\n     op2 = force_reg (SFmode, op2);\n \n-  if (TARGET_BIG_ENDIAN)\n-    emit_insn (gen_fpack (operands[0], op2, op1));\n-  else\n-    emit_insn (gen_fpack (operands[0], op1, op2));\n+  emit_insn (gen_fpack (operands[0], op1, op2));\n   DONE;\n })\n \n@@ -1416,7 +1453,13 @@\n \t  (match_operand:SF 1 \"fr_reg_or_fp01_operand\" \"fG\")\n \t  (match_operand:SF 2 \"fr_reg_or_fp01_operand\" \"fG\")))]\n   \"\"\n-  \"fpack %0 = %F2, %F1\"\n+{\n+  /* Recall that vector elements are numbered in memory order.  */\n+  if (TARGET_BIG_ENDIAN)\n+    return \"%,fpack %0 = %F1, %F2\";\n+  else\n+    return \"%,fpack %0 = %F2, %F1\";\n+}\n   [(set_attr \"itanium_class\" \"fmisc\")])\n \n (define_insn \"fswap\"\n@@ -1427,7 +1470,13 @@\n \t    (match_operand:V2SF 2 \"fr_reg_or_0_operand\" \"fU\"))\n \t  (parallel [(const_int 1) (const_int 2)])))]\n   \"\"\n-  \"fswap %0 = %F1, %F2\"\n+{\n+  /* Recall that vector elements are numbered in memory order.  */\n+  if (TARGET_BIG_ENDIAN)\n+    return \"%,fswap %0 = %F2, %F1\";\n+  else\n+    return \"%,fswap %0 = %F1, %F2\";\n+}\n   [(set_attr \"itanium_class\" \"fmisc\")])\n \n (define_insn \"vec_interleave_highv2sf\"\n@@ -1438,7 +1487,13 @@\n \t    (match_operand:V2SF 2 \"fr_reg_or_0_operand\" \"fU\"))\n \t  (parallel [(const_int 1) (const_int 3)])))]\n   \"\"\n-  \"fmix.l %0 = %F2, %F1\"\n+{\n+  /* Recall that vector elements are numbered in memory order.  */\n+  if (TARGET_BIG_ENDIAN)\n+    return \"%,fmix.r %0 = %F1, %F2\";\n+  else\n+    return \"%,fmix.l %0 = %F2, %F1\";\n+}\n   [(set_attr \"itanium_class\" \"fmisc\")])\n \n (define_insn \"vec_interleave_lowv2sf\"\n@@ -1449,7 +1504,13 @@\n \t    (match_operand:V2SF 2 \"fr_reg_or_0_operand\" \"fU\"))\n \t  (parallel [(const_int 0) (const_int 2)])))]\n   \"\"\n-  \"fmix.r %0 = %F2, %F1\"\n+{\n+  /* Recall that vector elements are numbered in memory order.  */\n+  if (TARGET_BIG_ENDIAN)\n+    return \"%,fmix.l %0 = %F1, %F2\";\n+  else\n+    return \"%,fmix.r %0 = %F2, %F1\";\n+}\n   [(set_attr \"itanium_class\" \"fmisc\")])\n \n (define_insn \"fmix_lr\"\n@@ -1460,7 +1521,13 @@\n \t    (match_operand:V2SF 2 \"fr_reg_or_0_operand\" \"fU\"))\n \t  (parallel [(const_int 0) (const_int 3)])))]\n   \"\"\n-  \"fmix.lr %0 = %F2, %F1\"\n+{\n+  /* Recall that vector elements are numbered in memory order.  */\n+  if (TARGET_BIG_ENDIAN)\n+    return \"%,fmix.lr %0 = %F1, %F2\";\n+  else\n+    return \"%,fmix.lr %0 = %F2, %F1\";\n+}\n   [(set_attr \"itanium_class\" \"fmisc\")])\n \n (define_expand \"vec_extract_evenv2sf\"\n@@ -1485,23 +1552,24 @@\n   DONE;\n })\n \n-\n (define_expand \"vec_setv2sf\"\n   [(match_operand:V2SF 0 \"fr_register_operand\" \"\")\n    (match_operand:SF 1 \"fr_register_operand\" \"\")\n    (match_operand 2 \"const_int_operand\" \"\")]\n   \"\"\n {\n+  rtx op0 = operands[0];\n   rtx tmp = gen_reg_rtx (V2SFmode);\n+\n   emit_insn (gen_fpack (tmp, operands[1], CONST0_RTX (SFmode)));\n \n   switch (INTVAL (operands[2]))\n     {\n     case 0:\n-      emit_insn (gen_fmix_lr (operands[0], tmp, operands[0]));\n+      emit_insn (gen_fmix_lr (op0, tmp, op0));\n       break;\n     case 1:\n-      emit_insn (gen_vec_interleave_lowv2sf (operands[0], operands[0], tmp));\n+      emit_insn (gen_vec_interleave_lowv2sf (op0, op0, tmp));\n       break;\n     default:\n       gcc_unreachable ();\n@@ -1528,40 +1596,53 @@\n })\n \n (define_insn_and_split \"*vec_extractv2sf_0_be\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r,f\")\n-\t(unspec:SF [(match_operand:V2SF 1 \"register_operand\" \"rf,r\")\n+  [(set (match_operand:SF 0 \"register_operand\" \"=rf,r\")\n+\t(unspec:SF [(match_operand:V2SF 1 \"nonimmediate_operand\" \"m,r\")\n \t\t    (const_int 0)]\n \t\t   UNSPEC_VECT_EXTR))]\n   \"TARGET_BIG_ENDIAN\"\n   \"#\"\n   \"reload_completed\"\n   [(set (match_dup 0) (match_dup 1))]\n {\n-  if (REG_P (operands[1]) && FR_REGNO_P (REGNO (operands[1])))\n-    operands[0] = gen_rtx_REG (V2SFmode, REGNO (operands[0]));\n+  if (MEM_P (operands[1]))\n+    operands[1] = adjust_address (operands[1], SFmode, 0);\n   else\n-    operands[1] = gen_rtx_REG (SFmode, REGNO (operands[1]));\n+    {\n+      emit_insn (gen_lshrdi3 (operands[0], operands[1], GEN_INT (32)));\n+      DONE;\n+    }\n })\n \n-(define_insn_and_split \"*vec_extractv2sf_1\"\n+(define_insn_and_split \"*vec_extractv2sf_1_le\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n \t(unspec:SF [(match_operand:V2SF 1 \"register_operand\" \"r\")\n \t\t    (const_int 1)]\n \t\t   UNSPEC_VECT_EXTR))]\n-  \"\"\n+  \"!TARGET_BIG_ENDIAN\"\n   \"#\"\n-  \"reload_completed\"\n+  \"&& reload_completed\"\n   [(const_int 0)]\n {\n   operands[0] = gen_rtx_REG (DImode, REGNO (operands[0]));\n   operands[1] = gen_rtx_REG (DImode, REGNO (operands[1]));\n-  if (TARGET_BIG_ENDIAN)\n-    emit_move_insn (operands[0], operands[1]);\n-  else\n-    emit_insn (gen_lshrdi3 (operands[0], operands[1], GEN_INT (32)));\n+  emit_insn (gen_lshrdi3 (operands[0], operands[1], GEN_INT (32)));\n   DONE;\n })\n \n+(define_insn_and_split \"*vec_extractv2sf_1_be\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=rf\")\n+\t(unspec:SF [(match_operand:V2SF 1 \"register_operand\" \"r\")\n+\t\t    (const_int 1)]\n+\t\t   UNSPEC_VECT_EXTR))]\n+  \"TARGET_BIG_ENDIAN\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0) (match_dup 1))]\n+{\n+  operands[1] = gen_rtx_REG (SFmode, REGNO (operands[1]));\n+})\n+\n (define_expand \"vec_extractv2sf\"\n   [(set (match_operand:SF 0 \"register_operand\" \"\")\n \t(unspec:SF [(match_operand:V2SF 1 \"register_operand\" \"\")\n@@ -1610,11 +1691,14 @@\n   [(match_operand:V8QI 0 \"gr_register_operand\" \"\")\n    (match_operand:V4HI 1 \"gr_register_operand\" \"\")\n    (match_operand:V4HI 2 \"gr_register_operand\" \"\")]\n-  \"!TARGET_BIG_ENDIAN\"\n+  \"\"\n {\n-  rtx op1 = gen_lowpart(V8QImode, operands[1]);\n-  rtx op2 = gen_lowpart(V8QImode, operands[2]);\n-  emit_insn (gen_vec_extract_evenv8qi (operands[0], op1, op2));\n+  rtx op1 = gen_lowpart (V8QImode, operands[1]);\n+  rtx op2 = gen_lowpart (V8QImode, operands[2]);\n+  if (TARGET_BIG_ENDIAN)\n+    emit_insn (gen_vec_extract_oddv8qi (operands[0], op1, op2));\n+  else\n+    emit_insn (gen_vec_extract_evenv8qi (operands[0], op1, op2));\n   DONE;\n })\n \n@@ -1624,8 +1708,8 @@\n    (match_operand:V2SI 2 \"gr_register_operand\" \"\")]\n   \"\"\n {\n-  rtx op1 = gen_lowpart(V4HImode, operands[1]);\n-  rtx op2 = gen_lowpart(V4HImode, operands[2]);\n+  rtx op1 = gen_lowpart (V4HImode, operands[1]);\n+  rtx op2 = gen_lowpart (V4HImode, operands[2]);\n   if (TARGET_BIG_ENDIAN)\n     emit_insn (gen_vec_extract_oddv4hi (operands[0], op1, op2));\n   else"}]}