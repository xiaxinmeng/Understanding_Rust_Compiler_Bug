{"sha": "eaa49b49418e32fc83f5b99217e6e7fc0cfeff32", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFhNDliNDk0MThlMzJmYzgzZjViOTkyMTdlNmU3ZmMwY2ZlZmYzMg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-01-14T00:33:49Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-01-14T00:33:49Z"}, "message": "re PR target/19009 (Loading of FP constants into FP reg via SSE reg)\n\n        PR target/19099\n        PR target/19250\n        PR target/19252\n        * config/i386/i386.md (cmpdf, cmpsf, bunordered, bordered, buneq,\n        bunge, bungt, bunle, bunlt, bltgt): Enable for TARGET_SSE_MATH,\n        not just TARGET_SSE.\n        (cmpfp_i_387): Rename from cmpfp_i.  Move after sse patterns.\n        (cmpfp_i_mixed): Rename from cmpfp_i_sse; use for TARGET_MIX_SSE_I387.\n        (cmpfp_i_sse): Rename from cmpfp_i_sse_only; use for TARGET_SSE_MATH.\n        (cmpfp_iu_mixed, cmpfp_iu_sse, cmpfp_iu_387): Similarly.\n        (fp_jcc_1_mixed, fp_jcc_1_sse, fp_jcc_1_387): Similarly.\n        (fp_jcc_2_mixed, fp_jcc_2_sse, fp_jcc_2_387): Similarly.\n        (fp_jcc_3_387, fp_jcc_4_387, fp_jcc_5_387, fp_jcc_6_387,\n        fp_jcc_7_387, fp_jcc_8_387): Rename from fp_jcc_N.\n        (movdicc_c_rex64): Rename with '*'.\n        (movsfcc, movdfcc): Add checks for 387 and sse math to condition.\n        (movsfcc_1_sse_min, movsfcc_1_sse_max, movsfcc_1_sse): New.\n        (movsfcc_1_387): Rename from movsfcc_1.\n        (movdfcc_1_sse_min, movdfcc_1_sse_max, movdfcc_1_sse): New.\n        (movdfcc_1, movdfcc_1_rex64): Add check for 387.\n        (sminsf3, smaxsf3, smindf3, smaxdf3): New.\n        (minsf3, minsf, minsf_nonieee, minsf_sse, mindf3, mindf,\n        mindf_nonieee, mindf_sse, maxsf3, maxsf, maxsf_nonieee, maxsf_sse,\n        maxdf3, maxdf, maxdf_nonieee, maxdf_sse, sse_movsfcc, sse_movsfcc_eq,\n        sse_movdfcc, sse_movdfcc_eq, sse_movsfcc_const0_1,\n        sse_movsfcc_const0_2, sse_movsfcc_const0_3, sse_movsfcc_const0_4,\n        sse_movdfcc_const0_1, sse_movdfcc_const0_2, sse_movdfcc_const0_3,\n        sse_movdfcc_const0_4): Remove.\n        * config/i386/i386.c (ix86_expand_fp_movcc): For TARGET_SSE_MATH,\n        recognize min/max early.  Update for changed sse cmove patterns.\n        (ix86_split_sse_movcc): New.\n        * config/i386/i386-protos.h: Update.\n\nFrom-SVN: r93620", "tree": {"sha": "d00bde60425ce12ced7b26a9deae38fb3e236e00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d00bde60425ce12ced7b26a9deae38fb3e236e00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eaa49b49418e32fc83f5b99217e6e7fc0cfeff32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaa49b49418e32fc83f5b99217e6e7fc0cfeff32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaa49b49418e32fc83f5b99217e6e7fc0cfeff32", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaa49b49418e32fc83f5b99217e6e7fc0cfeff32/comments", "author": null, "committer": null, "parents": [{"sha": "997e120f69b918083ac855511dd42d21b35326c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/997e120f69b918083ac855511dd42d21b35326c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/997e120f69b918083ac855511dd42d21b35326c6"}], "stats": {"total": 1266, "additions": 389, "deletions": 877}, "files": [{"sha": "6195716e02a297f5d217fcb5fd1d5c6a3933cf4d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa49b49418e32fc83f5b99217e6e7fc0cfeff32/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa49b49418e32fc83f5b99217e6e7fc0cfeff32/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eaa49b49418e32fc83f5b99217e6e7fc0cfeff32", "patch": "@@ -1,3 +1,38 @@\n+2005-01-13  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/19099\n+\tPR target/19250\n+\tPR target/19252\n+\t* config/i386/i386.md (cmpdf, cmpsf, bunordered, bordered, buneq,\n+\tbunge, bungt, bunle, bunlt, bltgt): Enable for TARGET_SSE_MATH,\n+\tnot just TARGET_SSE.\n+\t(cmpfp_i_387): Rename from cmpfp_i.  Move after sse patterns.\n+\t(cmpfp_i_mixed): Rename from cmpfp_i_sse; use for TARGET_MIX_SSE_I387.\n+\t(cmpfp_i_sse): Rename from cmpfp_i_sse_only; use for TARGET_SSE_MATH.\n+\t(cmpfp_iu_mixed, cmpfp_iu_sse, cmpfp_iu_387): Similarly.\n+\t(fp_jcc_1_mixed, fp_jcc_1_sse, fp_jcc_1_387): Similarly.\n+\t(fp_jcc_2_mixed, fp_jcc_2_sse, fp_jcc_2_387): Similarly.\n+\t(fp_jcc_3_387, fp_jcc_4_387, fp_jcc_5_387, fp_jcc_6_387,\n+\tfp_jcc_7_387, fp_jcc_8_387): Rename from fp_jcc_N.\n+\t(movdicc_c_rex64): Rename with '*'.\n+\t(movsfcc, movdfcc): Add checks for 387 and sse math to condition.\n+\t(movsfcc_1_sse_min, movsfcc_1_sse_max, movsfcc_1_sse): New.\n+\t(movsfcc_1_387): Rename from movsfcc_1.\n+\t(movdfcc_1_sse_min, movdfcc_1_sse_max, movdfcc_1_sse): New.\n+\t(movdfcc_1, movdfcc_1_rex64): Add check for 387.\n+\t(sminsf3, smaxsf3, smindf3, smaxdf3): New.\n+\t(minsf3, minsf, minsf_nonieee, minsf_sse, mindf3, mindf,\n+\tmindf_nonieee, mindf_sse, maxsf3, maxsf, maxsf_nonieee, maxsf_sse,\n+\tmaxdf3, maxdf, maxdf_nonieee, maxdf_sse, sse_movsfcc, sse_movsfcc_eq,\n+\tsse_movdfcc, sse_movdfcc_eq, sse_movsfcc_const0_1,\n+\tsse_movsfcc_const0_2, sse_movsfcc_const0_3, sse_movsfcc_const0_4,\n+\tsse_movdfcc_const0_1, sse_movdfcc_const0_2, sse_movdfcc_const0_3,\n+\tsse_movdfcc_const0_4): Remove.\n+\t* config/i386/i386.c (ix86_expand_fp_movcc): For TARGET_SSE_MATH,\n+\trecognize min/max early.  Update for changed sse cmove patterns.\n+\t(ix86_split_sse_movcc): New.\n+\t* config/i386/i386-protos.h: Update.\n+\n 2005-01-13  Steven Bosscher  <stevenb@suse.de>\n \n \t* tree-ssa-dse.c (fix_phi_uses): Use SSA operand iterators."}, {"sha": "06c857770a99eea4ecbfdbc58bc0620884f7c90b", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa49b49418e32fc83f5b99217e6e7fc0cfeff32/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa49b49418e32fc83f5b99217e6e7fc0cfeff32/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=eaa49b49418e32fc83f5b99217e6e7fc0cfeff32", "patch": "@@ -145,6 +145,7 @@ extern void ix86_expand_branch (enum rtx_code, rtx);\n extern int ix86_expand_setcc (enum rtx_code, rtx);\n extern int ix86_expand_int_movcc (rtx[]);\n extern int ix86_expand_fp_movcc (rtx[]);\n+extern void ix86_split_sse_movcc (rtx[]);\n extern int ix86_expand_int_addcc (rtx[]);\n extern void ix86_expand_call (rtx, rtx, rtx, rtx, rtx, int);\n extern void x86_initialize_trampoline (rtx, rtx, rtx);"}, {"sha": "4bc0c7533b567626bbc161e49ccfeb21f82e3ffc", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 136, "deletions": 111, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa49b49418e32fc83f5b99217e6e7fc0cfeff32/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa49b49418e32fc83f5b99217e6e7fc0cfeff32/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=eaa49b49418e32fc83f5b99217e6e7fc0cfeff32", "patch": "@@ -9743,118 +9743,95 @@ ix86_expand_int_movcc (rtx operands[])\n int\n ix86_expand_fp_movcc (rtx operands[])\n {\n-  enum rtx_code code;\n-  rtx tmp;\n-  rtx compare_op, second_test, bypass_test;\n-\n-  /* For SF/DFmode conditional moves based on comparisons\n-     in same mode, we may want to use SSE min/max instructions.  */\n-  if (((TARGET_SSE_MATH && GET_MODE (operands[0]) == SFmode)\n-       || (TARGET_SSE2 && TARGET_SSE_MATH && GET_MODE (operands[0]) == DFmode))\n-      && GET_MODE (ix86_compare_op0) == GET_MODE (operands[0])\n-      /* The SSE comparisons does not support the LTGT/UNEQ pair.  */\n-      && (!TARGET_IEEE_FP\n-\t  || (GET_CODE (operands[1]) != LTGT && GET_CODE (operands[1]) != UNEQ))\n-      /* We may be called from the post-reload splitter.  */\n-      && (!REG_P (operands[0])\n-\t  || SSE_REG_P (operands[0])\n-\t  || REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER))\n-    {\n-      rtx op0 = ix86_compare_op0, op1 = ix86_compare_op1;\n-      code = GET_CODE (operands[1]);\n-\n-      /* See if we have (cross) match between comparison operands and\n-         conditional move operands.  */\n-      if (rtx_equal_p (operands[2], op1))\n+  enum machine_mode mode = GET_MODE (operands[0]);\n+  enum rtx_code code = GET_CODE (operands[1]);\n+  rtx tmp, compare_op, second_test, bypass_test;\n+\n+  if (TARGET_SSE_MATH && SSE_FLOAT_MODE_P (mode))\n+    {\n+      rtx cmp_op0, cmp_op1, if_true, if_false;\n+      rtx clob;\n+      enum machine_mode vmode, cmode;\n+      bool is_minmax = false;\n+\n+      cmp_op0 = ix86_compare_op0;\n+      cmp_op1 = ix86_compare_op1;\n+      if_true = operands[2];\n+      if_false = operands[3];\n+\n+      /* Since we've no cmove for sse registers, don't force bad register\n+\t allocation just to gain access to it.  Deny movcc when the\n+\t comparison mode doesn't match the move mode.  */\n+      cmode = GET_MODE (cmp_op0);\n+      if (cmode == VOIDmode)\n+\tcmode = GET_MODE (cmp_op1);\n+      if (cmode != mode)\n+\treturn 0;\n+\n+      /* Massage condition to satisfy sse_comparison_operator.  In case we\n+\t are in non-ieee mode, try to canonicalize the destination operand\n+\t to be first in the comparison - this helps reload to avoid extra\n+\t moves.  */\n+      if (!sse_comparison_operator (operands[1], VOIDmode)\n+\t  || ((COMMUTATIVE_P (operands[1]) || !TARGET_IEEE_FP)\n+\t      && rtx_equal_p (operands[0], cmp_op1)))\n \t{\n-\t  rtx tmp = op0;\n-\t  op0 = op1;\n-\t  op1 = tmp;\n-\t  code = reverse_condition_maybe_unordered (code);\n+\t  tmp = cmp_op0;\n+\t  cmp_op0 = cmp_op1;\n+\t  cmp_op1 = tmp;\n+\t  code = swap_condition (code);\n \t}\n-      if (rtx_equal_p (operands[2], op0) && rtx_equal_p (operands[3], op1))\n+\n+      /* Detect conditional moves that exactly match min/max operational\n+\t semantics.  Note that this is IEEE safe, as long as we don't\n+\t interchange the operands.  Which is why we keep this in the form\n+\t if an IF_THEN_ELSE instead of reducing to SMIN/SMAX.  */\n+      if ((code == LT || code == UNGE) && REG_P (cmp_op0) && REG_P (cmp_op1))\n \t{\n-\t  /* Check for min operation.  */\n-\t  if (code == LT || code == UNLE)\n+\t  if (((cmp_op0 == if_true && cmp_op1 == if_false)\n+\t      || (cmp_op0 == if_false && cmp_op1 == if_true)))\n \t    {\n-\t       if (code == UNLE)\n+\t      is_minmax = true;\n+\t      if (code == UNGE)\n \t\t{\n-\t\t  rtx tmp = op0;\n-\t\t  op0 = op1;\n-\t\t  op1 = tmp;\n+\t\t  code = LT;\n+\t\t  tmp = if_true;\n+\t\t  if_true = if_false;\n+\t\t  if_false = tmp;\n \t\t}\n-\t       operands[0] = force_reg (GET_MODE (operands[0]), operands[0]);\n-\t       if (memory_operand (op0, VOIDmode))\n-\t\t op0 = force_reg (GET_MODE (operands[0]), op0);\n-\t       if (GET_MODE (operands[0]) == SFmode)\n-\t\t emit_insn (gen_minsf3 (operands[0], op0, op1));\n-\t       else\n-\t\t emit_insn (gen_mindf3 (operands[0], op0, op1));\n-\t       return 1;\n-\t    }\n-\t  /* Check for max operation.  */\n-\t  if (code == GT || code == UNGE)\n-\t    {\n-\t       if (code == UNGE)\n-\t\t{\n-\t\t  rtx tmp = op0;\n-\t\t  op0 = op1;\n-\t\t  op1 = tmp;\n-\t\t}\n-\t       operands[0] = force_reg (GET_MODE (operands[0]), operands[0]);\n-\t       if (memory_operand (op0, VOIDmode))\n-\t\t op0 = force_reg (GET_MODE (operands[0]), op0);\n-\t       if (GET_MODE (operands[0]) == SFmode)\n-\t\t emit_insn (gen_maxsf3 (operands[0], op0, op1));\n-\t       else\n-\t\t emit_insn (gen_maxdf3 (operands[0], op0, op1));\n-\t       return 1;\n \t    }\n \t}\n-      /* Manage condition to be sse_comparison_operator.  In case we are\n-\t in non-ieee mode, try to canonicalize the destination operand\n-\t to be first in the comparison - this helps reload to avoid extra\n-\t moves.  */\n-      if (!sse_comparison_operator (operands[1], VOIDmode)\n-\t  || (rtx_equal_p (operands[0], ix86_compare_op1) && !TARGET_IEEE_FP))\n-\t{\n-\t  rtx tmp = ix86_compare_op0;\n-\t  ix86_compare_op0 = ix86_compare_op1;\n-\t  ix86_compare_op1 = tmp;\n-\t  operands[1] = gen_rtx_fmt_ee (swap_condition (GET_CODE (operands[1])),\n-\t\t\t\t\tVOIDmode, ix86_compare_op0,\n-\t\t\t\t\tix86_compare_op1);\n-\t}\n-      /* Similarly try to manage result to be first operand of conditional\n-\t move. We also don't support the NE comparison on SSE, so try to\n-\t avoid it.  */\n-      if ((rtx_equal_p (operands[0], operands[3])\n-\t   && (!TARGET_IEEE_FP || GET_CODE (operands[1]) != EQ))\n-\t  || (GET_CODE (operands[1]) == NE && TARGET_IEEE_FP))\n-\t{\n-\t  rtx tmp = operands[2];\n-\t  operands[2] = operands[3];\n-\t  operands[3] = tmp;\n-\t  operands[1] = gen_rtx_fmt_ee (reverse_condition_maybe_unordered\n-\t\t\t\t\t  (GET_CODE (operands[1])),\n-\t\t\t\t\tVOIDmode, ix86_compare_op0,\n-\t\t\t\t\tix86_compare_op1);\n-\t}\n-      if (GET_MODE (operands[0]) == SFmode)\n-\temit_insn (gen_sse_movsfcc (operands[0], operands[1],\n-\t\t\t\t    operands[2], operands[3],\n-\t\t\t\t    ix86_compare_op0, ix86_compare_op1));\n+\n+      if (mode == SFmode)\n+\tvmode = V4SFmode;\n+      else if (mode == DFmode)\n+\tvmode = V2DFmode;\n       else\n-\temit_insn (gen_sse_movdfcc (operands[0], operands[1],\n-\t\t\t\t    operands[2], operands[3],\n-\t\t\t\t    ix86_compare_op0, ix86_compare_op1));\n+\tgcc_unreachable ();\n+\n+      cmp_op0 = force_reg (mode, cmp_op0);\n+      if (!nonimmediate_operand (cmp_op1, mode))\n+\tcmp_op1 = force_reg (mode, cmp_op1);\n+\n+      tmp = gen_rtx_fmt_ee (code, mode, cmp_op0, cmp_op1);\n+      gcc_assert (sse_comparison_operator (tmp, VOIDmode));\n+\n+      tmp = gen_rtx_IF_THEN_ELSE (mode, tmp, if_true, if_false);\n+      tmp = gen_rtx_SET (VOIDmode, operands[0], tmp);\n+\n+      if (!is_minmax)\n+\t{\n+\t  clob = gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (vmode));\n+\t  tmp = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, tmp, clob));\n+\t}\n+\n+      emit_insn (tmp);\n       return 1;\n     }\n \n   /* The floating point conditional move instructions don't directly\n      support conditions resulting from a signed integer comparison.  */\n \n-  code = GET_CODE (operands[1]);\n   compare_op = ix86_expand_compare (code, &second_test, &bypass_test);\n \n   /* The floating point conditional move instructions don't directly\n@@ -9873,38 +9850,86 @@ ix86_expand_fp_movcc (rtx operands[])\n     }\n   if (bypass_test && reg_overlap_mentioned_p (operands[0], operands[3]))\n     {\n-      tmp = gen_reg_rtx (GET_MODE (operands[0]));\n+      tmp = gen_reg_rtx (mode);\n       emit_move_insn (tmp, operands[3]);\n       operands[3] = tmp;\n     }\n   if (second_test && reg_overlap_mentioned_p (operands[0], operands[2]))\n     {\n-      tmp = gen_reg_rtx (GET_MODE (operands[0]));\n+      tmp = gen_reg_rtx (mode);\n       emit_move_insn (tmp, operands[2]);\n       operands[2] = tmp;\n     }\n \n   emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t  gen_rtx_IF_THEN_ELSE (GET_MODE (operands[0]),\n-\t\t\t\tcompare_op,\n-\t\t\t\toperands[2],\n-\t\t\t\toperands[3])));\n+\t\t\t  gen_rtx_IF_THEN_ELSE (mode, compare_op,\n+\t\t\t\t\t\toperands[2], operands[3])));\n   if (bypass_test)\n     emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t    gen_rtx_IF_THEN_ELSE (GET_MODE (operands[0]),\n-\t\t\t\t  bypass_test,\n-\t\t\t\t  operands[3],\n-\t\t\t\t  operands[0])));\n+\t\t\t    gen_rtx_IF_THEN_ELSE (mode, bypass_test,\n+\t\t\t\t\t\t  operands[3], operands[0])));\n   if (second_test)\n     emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t    gen_rtx_IF_THEN_ELSE (GET_MODE (operands[0]),\n-\t\t\t\t  second_test,\n-\t\t\t\t  operands[2],\n-\t\t\t\t  operands[0])));\n+\t\t\t    gen_rtx_IF_THEN_ELSE (mode, second_test,\n+\t\t\t\t\t\t  operands[2], operands[0])));\n \n   return 1;\n }\n \n+void\n+ix86_split_sse_movcc (rtx operands[])\n+{\n+  rtx dest, scratch, cmp, op_true, op_false, x;\n+  enum machine_mode mode, vmode;\n+\n+  /* Note that the operator CMP has been set up with matching constraints\n+     such that dest is valid for the comparison.  Unless one of the true\n+     or false operands are zero, the true operand has already been placed\n+     in SCRATCH.  */\n+  dest = operands[0];\n+  scratch = operands[1];\n+  op_true = operands[2];\n+  op_false = operands[3];\n+  cmp = operands[4];\n+\n+  mode = GET_MODE (dest);\n+  vmode = GET_MODE (scratch);\n+\n+  emit_insn (gen_rtx_SET (VOIDmode, dest, cmp));\n+\n+  dest = simplify_gen_subreg (vmode, dest, mode, 0);\n+\n+  if (op_false == CONST0_RTX (mode))\n+    {\n+      op_true = simplify_gen_subreg (vmode, op_true, mode, 0);\n+      x = gen_rtx_AND (vmode, dest, op_true);\n+      emit_insn (gen_rtx_SET (VOIDmode, dest, x));\n+    }\n+  else\n+    {\n+      op_false = simplify_gen_subreg (vmode, op_false, mode, 0);\n+\n+      if (op_true == CONST0_RTX (mode))\n+\t{\n+\t  x = gen_rtx_NOT (vmode, dest);\n+\t  x = gen_rtx_AND (vmode, x, op_false);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, dest, x));\n+\t}\n+      else\n+\t{\n+\t  x = gen_rtx_AND (vmode, scratch, dest);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, scratch, x));\n+\n+\t  x = gen_rtx_NOT (vmode, dest);\n+\t  x = gen_rtx_AND (vmode, x, op_false);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, dest, x));\n+\n+\t  x = gen_rtx_IOR (vmode, dest, scratch);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, dest, x));\n+\t}\n+    }\n+}\n+\n /* Expand conditional increment or decrement using adb/sbb instructions.\n    The default case using setcc followed by the conditional move can be\n    done by generic code.  */"}, {"sha": "674d0935740aaf47126305640318ce0e7b992605", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 217, "deletions": 766, "changes": 983, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa49b49418e32fc83f5b99217e6e7fc0cfeff32/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa49b49418e32fc83f5b99217e6e7fc0cfeff32/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=eaa49b49418e32fc83f5b99217e6e7fc0cfeff32", "patch": "@@ -774,7 +774,7 @@\n   [(set (reg:CC FLAGS_REG)\n \t(compare:CC (match_operand:DF 0 \"cmp_fp_expander_operand\" \"\")\n \t\t    (match_operand:DF 1 \"cmp_fp_expander_operand\" \"\")))]\n-  \"TARGET_80387 || TARGET_SSE2\"\n+  \"TARGET_80387 || (TARGET_SSE2 && TARGET_SSE_MATH)\"\n {\n   ix86_compare_op0 = operands[0];\n   ix86_compare_op1 = operands[1];\n@@ -785,7 +785,7 @@\n   [(set (reg:CC FLAGS_REG)\n \t(compare:CC (match_operand:SF 0 \"cmp_fp_expander_operand\" \"\")\n \t\t    (match_operand:SF 1 \"cmp_fp_expander_operand\" \"\")))]\n-  \"TARGET_80387 || TARGET_SSE\"\n+  \"TARGET_80387 || TARGET_SSE_MATH\"\n {\n   ix86_compare_op0 = operands[0];\n   ix86_compare_op1 = operands[1];\n@@ -935,30 +935,11 @@\n \n ;; Pentium Pro can do steps 1 through 3 in one go.\n \n-(define_insn \"*cmpfp_i\"\n-  [(set (reg:CCFP FLAGS_REG)\n-\t(compare:CCFP (match_operand 0 \"register_operand\" \"f\")\n-\t\t      (match_operand 1 \"register_operand\" \"f\")))]\n-  \"TARGET_80387 && TARGET_CMOVE\n-   && !SSE_FLOAT_MODE_P (GET_MODE (operands[0]))\n-   && FLOAT_MODE_P (GET_MODE (operands[0]))\n-   && GET_MODE (operands[0]) == GET_MODE (operands[1])\"\n-  \"* return output_fp_compare (insn, operands, 1, 0);\"\n-  [(set_attr \"type\" \"fcmp\")\n-   (set (attr \"mode\")\n-     (cond [(match_operand:SF 1 \"\" \"\")\n-\t      (const_string \"SF\")\n-\t    (match_operand:DF 1 \"\" \"\")\n-\t      (const_string \"DF\")\n-\t   ]\n-\t   (const_string \"XF\")))\n-   (set_attr \"athlon_decode\" \"vector\")])\n-\n-(define_insn \"*cmpfp_i_sse\"\n+(define_insn \"*cmpfp_i_mixed\"\n   [(set (reg:CCFP FLAGS_REG)\n \t(compare:CCFP (match_operand 0 \"register_operand\" \"f#x,x#f\")\n \t\t      (match_operand 1 \"nonimmediate_operand\" \"f#x,xm#f\")))]\n-  \"TARGET_80387\n+  \"TARGET_MIX_SSE_I387\n    && SSE_FLOAT_MODE_P (GET_MODE (operands[0]))\n    && GET_MODE (operands[0]) == GET_MODE (operands[1])\"\n   \"* return output_fp_compare (insn, operands, 1, 0);\"\n@@ -969,11 +950,12 @@\n         (const_string \"DF\")))\n    (set_attr \"athlon_decode\" \"vector\")])\n \n-(define_insn \"*cmpfp_i_sse_only\"\n+(define_insn \"*cmpfp_i_sse\"\n   [(set (reg:CCFP FLAGS_REG)\n \t(compare:CCFP (match_operand 0 \"register_operand\" \"x\")\n \t\t      (match_operand 1 \"nonimmediate_operand\" \"xm\")))]\n-  \"SSE_FLOAT_MODE_P (GET_MODE (operands[0]))\n+  \"TARGET_SSE_MATH\n+   && SSE_FLOAT_MODE_P (GET_MODE (operands[0]))\n    && GET_MODE (operands[0]) == GET_MODE (operands[1])\"\n   \"* return output_fp_compare (insn, operands, 1, 0);\"\n   [(set_attr \"type\" \"ssecomi\")\n@@ -983,15 +965,15 @@\n         (const_string \"DF\")))\n    (set_attr \"athlon_decode\" \"vector\")])\n \n-(define_insn \"*cmpfp_iu\"\n-  [(set (reg:CCFPU FLAGS_REG)\n-\t(compare:CCFPU (match_operand 0 \"register_operand\" \"f\")\n-\t\t       (match_operand 1 \"register_operand\" \"f\")))]\n+(define_insn \"*cmpfp_i_i387\"\n+  [(set (reg:CCFP FLAGS_REG)\n+\t(compare:CCFP (match_operand 0 \"register_operand\" \"f\")\n+\t\t      (match_operand 1 \"register_operand\" \"f\")))]\n   \"TARGET_80387 && TARGET_CMOVE\n-   && !SSE_FLOAT_MODE_P (GET_MODE (operands[0]))\n+   && (!TARGET_SSE_MATH || !SSE_FLOAT_MODE_P (GET_MODE (operands[0])))\n    && FLOAT_MODE_P (GET_MODE (operands[0]))\n    && GET_MODE (operands[0]) == GET_MODE (operands[1])\"\n-  \"* return output_fp_compare (insn, operands, 1, 1);\"\n+  \"* return output_fp_compare (insn, operands, 1, 0);\"\n   [(set_attr \"type\" \"fcmp\")\n    (set (attr \"mode\")\n      (cond [(match_operand:SF 1 \"\" \"\")\n@@ -1002,11 +984,11 @@\n \t   (const_string \"XF\")))\n    (set_attr \"athlon_decode\" \"vector\")])\n \n-(define_insn \"*cmpfp_iu_sse\"\n+(define_insn \"*cmpfp_iu_mixed\"\n   [(set (reg:CCFPU FLAGS_REG)\n \t(compare:CCFPU (match_operand 0 \"register_operand\" \"f#x,x#f\")\n \t\t       (match_operand 1 \"nonimmediate_operand\" \"f#x,xm#f\")))]\n-  \"TARGET_80387\n+  \"TARGET_MIX_SSE_I387\n    && SSE_FLOAT_MODE_P (GET_MODE (operands[0]))\n    && GET_MODE (operands[0]) == GET_MODE (operands[1])\"\n   \"* return output_fp_compare (insn, operands, 1, 1);\"\n@@ -1017,11 +999,12 @@\n         (const_string \"DF\")))\n    (set_attr \"athlon_decode\" \"vector\")])\n \n-(define_insn \"*cmpfp_iu_sse_only\"\n+(define_insn \"*cmpfp_iu_sse\"\n   [(set (reg:CCFPU FLAGS_REG)\n \t(compare:CCFPU (match_operand 0 \"register_operand\" \"x\")\n \t\t       (match_operand 1 \"nonimmediate_operand\" \"xm\")))]\n-  \"SSE_FLOAT_MODE_P (GET_MODE (operands[0]))\n+  \"TARGET_SSE_MATH\n+   && SSE_FLOAT_MODE_P (GET_MODE (operands[0]))\n    && GET_MODE (operands[0]) == GET_MODE (operands[1])\"\n   \"* return output_fp_compare (insn, operands, 1, 1);\"\n   [(set_attr \"type\" \"ssecomi\")\n@@ -1030,6 +1013,25 @@\n         (const_string \"SF\")\n         (const_string \"DF\")))\n    (set_attr \"athlon_decode\" \"vector\")])\n+\n+(define_insn \"*cmpfp_iu_387\"\n+  [(set (reg:CCFPU FLAGS_REG)\n+\t(compare:CCFPU (match_operand 0 \"register_operand\" \"f\")\n+\t\t       (match_operand 1 \"register_operand\" \"f\")))]\n+  \"TARGET_80387 && TARGET_CMOVE\n+   && (!TARGET_SSE_MATH || !SSE_FLOAT_MODE_P (GET_MODE (operands[0])))\n+   && FLOAT_MODE_P (GET_MODE (operands[0]))\n+   && GET_MODE (operands[0]) == GET_MODE (operands[1])\"\n+  \"* return output_fp_compare (insn, operands, 1, 1);\"\n+  [(set_attr \"type\" \"fcmp\")\n+   (set (attr \"mode\")\n+     (cond [(match_operand:SF 1 \"\" \"\")\n+\t      (const_string \"SF\")\n+\t    (match_operand:DF 1 \"\" \"\")\n+\t      (const_string \"DF\")\n+\t   ]\n+\t   (const_string \"XF\")))\n+   (set_attr \"athlon_decode\" \"vector\")])\n \f\n ;; Move instructions.\n \n@@ -12683,63 +12685,63 @@\n \t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_80387 || TARGET_SSE\"\n+  \"TARGET_80387 || TARGET_SSE_MATH\"\n   \"ix86_expand_branch (UNORDERED, operands[0]); DONE;\")\n \n (define_expand \"bordered\"\n   [(set (pc)\n \t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_80387 || TARGET_SSE\"\n+  \"TARGET_80387 || TARGET_SSE_MATH\"\n   \"ix86_expand_branch (ORDERED, operands[0]); DONE;\")\n \n (define_expand \"buneq\"\n   [(set (pc)\n \t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_80387 || TARGET_SSE\"\n+  \"TARGET_80387 || TARGET_SSE_MATH\"\n   \"ix86_expand_branch (UNEQ, operands[0]); DONE;\")\n \n (define_expand \"bunge\"\n   [(set (pc)\n \t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_80387 || TARGET_SSE\"\n+  \"TARGET_80387 || TARGET_SSE_MATH\"\n   \"ix86_expand_branch (UNGE, operands[0]); DONE;\")\n \n (define_expand \"bungt\"\n   [(set (pc)\n \t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_80387 || TARGET_SSE\"\n+  \"TARGET_80387 || TARGET_SSE_MATH\"\n   \"ix86_expand_branch (UNGT, operands[0]); DONE;\")\n \n (define_expand \"bunle\"\n   [(set (pc)\n \t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_80387 || TARGET_SSE\"\n+  \"TARGET_80387 || TARGET_SSE_MATH\"\n   \"ix86_expand_branch (UNLE, operands[0]); DONE;\")\n \n (define_expand \"bunlt\"\n   [(set (pc)\n \t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_80387 || TARGET_SSE\"\n+  \"TARGET_80387 || TARGET_SSE_MATH\"\n   \"ix86_expand_branch (UNLT, operands[0]); DONE;\")\n \n (define_expand \"bltgt\"\n   [(set (pc)\n \t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_80387 || TARGET_SSE\"\n+  \"TARGET_80387 || TARGET_SSE_MATH\"\n   \"ix86_expand_branch (LTGT, operands[0]); DONE;\")\n \n (define_insn \"*jcc_1\"\n@@ -12831,97 +12833,97 @@\n ;; during early optimization.  Splitting the operation apart early makes\n ;; for bad code when we want to reverse the operation.\n \n-(define_insn \"*fp_jcc_1\"\n+(define_insn \"*fp_jcc_1_mixed\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t[(match_operand 1 \"register_operand\" \"f\")\n-\t\t\t (match_operand 2 \"register_operand\" \"f\")])\n+\t\t\t[(match_operand 1 \"register_operand\" \"f#x,x#f\")\n+\t\t\t (match_operand 2 \"nonimmediate_operand\" \"f#x,xm#f\")])\n \t  (label_ref (match_operand 3 \"\" \"\"))\n \t  (pc)))\n    (clobber (reg:CCFP FPSR_REG))\n    (clobber (reg:CCFP FLAGS_REG))]\n-  \"TARGET_CMOVE && TARGET_80387\n-   && !SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\n-   && FLOAT_MODE_P (GET_MODE (operands[1]))\n+  \"TARGET_MIX_SSE_I387\n+   && SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\n    && GET_MODE (operands[1]) == GET_MODE (operands[2])\n    && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n   \"#\")\n \n (define_insn \"*fp_jcc_1_sse\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t[(match_operand 1 \"register_operand\" \"f#x,x#f\")\n-\t\t\t (match_operand 2 \"nonimmediate_operand\" \"f#x,xm#f\")])\n+\t\t\t[(match_operand 1 \"register_operand\" \"x\")\n+\t\t\t (match_operand 2 \"nonimmediate_operand\" \"xm\")])\n \t  (label_ref (match_operand 3 \"\" \"\"))\n \t  (pc)))\n    (clobber (reg:CCFP FPSR_REG))\n    (clobber (reg:CCFP FLAGS_REG))]\n-  \"TARGET_80387\n+  \"TARGET_SSE_MATH\n    && SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\n    && GET_MODE (operands[1]) == GET_MODE (operands[2])\n    && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n   \"#\")\n \n-(define_insn \"*fp_jcc_1_sse_only\"\n+(define_insn \"*fp_jcc_1_387\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t[(match_operand 1 \"register_operand\" \"x\")\n-\t\t\t (match_operand 2 \"nonimmediate_operand\" \"xm\")])\n+\t\t\t[(match_operand 1 \"register_operand\" \"f\")\n+\t\t\t (match_operand 2 \"register_operand\" \"f\")])\n \t  (label_ref (match_operand 3 \"\" \"\"))\n \t  (pc)))\n    (clobber (reg:CCFP FPSR_REG))\n    (clobber (reg:CCFP FLAGS_REG))]\n-  \"SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\n+  \"TARGET_CMOVE && TARGET_80387\n+   && FLOAT_MODE_P (GET_MODE (operands[1]))\n    && GET_MODE (operands[1]) == GET_MODE (operands[2])\n    && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n   \"#\")\n \n-(define_insn \"*fp_jcc_2\"\n+(define_insn \"*fp_jcc_2_mixed\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t[(match_operand 1 \"register_operand\" \"f\")\n-\t\t\t (match_operand 2 \"register_operand\" \"f\")])\n+\t\t\t[(match_operand 1 \"register_operand\" \"f#x,x#f\")\n+\t\t\t (match_operand 2 \"nonimmediate_operand\" \"f#x,xm#f\")])\n \t  (pc)\n \t  (label_ref (match_operand 3 \"\" \"\"))))\n    (clobber (reg:CCFP FPSR_REG))\n    (clobber (reg:CCFP FLAGS_REG))]\n-  \"TARGET_CMOVE && TARGET_80387\n-   && !SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\n-   && FLOAT_MODE_P (GET_MODE (operands[1]))\n+  \"TARGET_MIX_SSE_I387\n+   && SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\n    && GET_MODE (operands[1]) == GET_MODE (operands[2])\n    && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n   \"#\")\n \n (define_insn \"*fp_jcc_2_sse\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t[(match_operand 1 \"register_operand\" \"f#x,x#f\")\n-\t\t\t (match_operand 2 \"nonimmediate_operand\" \"f#x,xm#f\")])\n+\t\t\t[(match_operand 1 \"register_operand\" \"x\")\n+\t\t\t (match_operand 2 \"nonimmediate_operand\" \"xm\")])\n \t  (pc)\n \t  (label_ref (match_operand 3 \"\" \"\"))))\n    (clobber (reg:CCFP FPSR_REG))\n    (clobber (reg:CCFP FLAGS_REG))]\n-  \"TARGET_80387\n+  \"TARGET_SSE_MATH\n    && SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\n    && GET_MODE (operands[1]) == GET_MODE (operands[2])\n    && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n   \"#\")\n \n-(define_insn \"*fp_jcc_2_sse_only\"\n+(define_insn \"*fp_jcc_2_387\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t[(match_operand 1 \"register_operand\" \"x\")\n-\t\t\t (match_operand 2 \"nonimmediate_operand\" \"xm\")])\n+\t\t\t[(match_operand 1 \"register_operand\" \"f\")\n+\t\t\t (match_operand 2 \"register_operand\" \"f\")])\n \t  (pc)\n \t  (label_ref (match_operand 3 \"\" \"\"))))\n    (clobber (reg:CCFP FPSR_REG))\n    (clobber (reg:CCFP FLAGS_REG))]\n-  \"SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\n+  \"TARGET_CMOVE && TARGET_80387\n+   && FLOAT_MODE_P (GET_MODE (operands[1]))\n    && GET_MODE (operands[1]) == GET_MODE (operands[2])\n    && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n   \"#\")\n \n-(define_insn \"*fp_jcc_3\"\n+(define_insn \"*fp_jcc_3_387\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"comparison_operator\"\n \t\t\t[(match_operand 1 \"register_operand\" \"f\")\n@@ -12940,7 +12942,7 @@\n    && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n   \"#\")\n \n-(define_insn \"*fp_jcc_4\"\n+(define_insn \"*fp_jcc_4_387\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"comparison_operator\"\n \t\t\t[(match_operand 1 \"register_operand\" \"f\")\n@@ -12959,7 +12961,7 @@\n    && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n   \"#\")\n \n-(define_insn \"*fp_jcc_5\"\n+(define_insn \"*fp_jcc_5_387\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"comparison_operator\"\n \t\t\t[(match_operand 1 \"register_operand\" \"f\")\n@@ -12975,7 +12977,7 @@\n    && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n   \"#\")\n \n-(define_insn \"*fp_jcc_6\"\n+(define_insn \"*fp_jcc_6_387\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"comparison_operator\"\n \t\t\t[(match_operand 1 \"register_operand\" \"f\")\n@@ -12991,7 +12993,7 @@\n    && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n   \"#\")\n \n-(define_insn \"*fp_jcc_7\"\n+(define_insn \"*fp_jcc_7_387\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"comparison_operator\"\n \t\t\t[(match_operand 1 \"register_operand\" \"f\")\n@@ -13015,7 +13017,7 @@\n ;; with a precedence over other operators and is always put in the first\n ;; place. Swap condition and operands to match ficom instruction.\n \n-(define_insn \"*fp_jcc_8\"\n+(define_insn \"*fp_jcc_8_387\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"comparison_operator\"\n \t\t\t[(match_operator 1 \"float_operator\"\n@@ -17417,7 +17419,7 @@\n    (set_attr \"mode\" \"DI\")\n    (set_attr \"length_immediate\" \"0\")])\n \n-(define_insn \"movdicc_c_rex64\"\n+(define_insn \"*movdicc_c_rex64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n \t(if_then_else:DI (match_operator 1 \"ix86_comparison_operator\" \n \t\t\t\t[(reg FLAGS_REG) (const_int 0)])\n@@ -17507,7 +17509,8 @@\n (define_insn_and_split \"*movqicc_noc\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n \t(if_then_else:QI (match_operator 1 \"ix86_comparison_operator\" \n-\t\t\t\t[(match_operand 4 \"flags_reg_operand\" \"\") (const_int 0)])\n+\t\t\t\t[(match_operand 4 \"flags_reg_operand\" \"\")\n+\t\t\t\t (const_int 0)])\n \t\t      (match_operand:QI 2 \"register_operand\" \"r,0\")\n \t\t      (match_operand:QI 3 \"register_operand\" \"0,r\")))]\n   \"TARGET_CMOVE && !TARGET_PARTIAL_REG_STALL\"\n@@ -17528,16 +17531,61 @@\n \t(if_then_else:SF (match_operand 1 \"comparison_operator\" \"\")\n \t\t\t (match_operand:SF 2 \"register_operand\" \"\")\n \t\t\t (match_operand:SF 3 \"register_operand\" \"\")))]\n-  \"TARGET_CMOVE\"\n+  \"(TARGET_80387 && TARGET_CMOVE) || TARGET_SSE_MATH\"\n   \"if (! ix86_expand_fp_movcc (operands)) FAIL; DONE;\")\n \n-(define_insn \"*movsfcc_1\"\n+;; These versions of min/max are aware of the instruction's behaviour\n+;; wrt -0.0 and NaN inputs.  If we don't care about either, then we\n+;; should have used the smin/smax expanders in the first place.\n+(define_insn \"*movsfcc_1_sse_min\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=x\")\n+\t(if_then_else:SF\n+\t  (lt:SF (match_operand:SF 1 \"register_operand\" \"0\")\n+\t\t (match_operand:SF 2 \"nonimmediate_operand\" \"xm\"))\n+\t  (match_dup 1)\n+\t  (match_dup 2)))]\n+  \"TARGET_SSE_MATH\"\n+  \"minss\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sseadd\")\n+   (set_attr \"mode\" \"SF\")])\n+\n+(define_insn \"*movsfcc_1_sse_max\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=x\")\n+\t(if_then_else:SF\n+\t  (lt:SF (match_operand:SF 2 \"nonimmediate_operand\" \"xm\")\n+\t\t (match_operand:SF 1 \"register_operand\" \"0\"))\n+\t  (match_dup 1)\n+\t  (match_dup 2)))]\n+  \"TARGET_SSE_MATH\"\n+  \"maxss\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sseadd\")\n+   (set_attr \"mode\" \"SF\")])\n+\n+(define_insn_and_split \"*movsfcc_1_sse\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=x,x,x\")\n+\t(if_then_else:SF\n+\t  (match_operator:SF 4 \"sse_comparison_operator\"\n+\t    [(match_operand:SF 5 \"register_operand\" \"0,0,0\")\n+\t     (match_operand:SF 6 \"nonimmediate_operand\" \"xm,xm,xm\")])\n+\t  (match_operand:SF 2 \"reg_or_0_operand\" \"C,x,1\")\n+\t  (match_operand:SF 3 \"reg_or_0_operand\" \"x,C,x\")))\n+   (clobber (match_scratch:V4SF 1 \"=X,X,x\"))]\n+  \"TARGET_SSE_MATH\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  ix86_split_sse_movcc (operands);\n+  DONE;\n+})\n+\n+(define_insn \"*movsfcc_1_387\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f#r,f#r,r#f,r#f\")\n \t(if_then_else:SF (match_operator 1 \"fcmov_comparison_operator\" \n \t\t\t\t[(reg FLAGS_REG) (const_int 0)])\n \t\t      (match_operand:SF 2 \"nonimmediate_operand\" \"f#r,0,rm#f,0\")\n \t\t      (match_operand:SF 3 \"nonimmediate_operand\" \"0,f#r,0,rm#f\")))]\n-  \"TARGET_CMOVE\n+  \"TARGET_80387 && TARGET_CMOVE\n    && (GET_CODE (operands[2]) != MEM || GET_CODE (operands[3]) != MEM)\"\n   \"@\n    fcmov%F1\\t{%2, %0|%0, %2}\n@@ -17552,16 +17600,61 @@\n \t(if_then_else:DF (match_operand 1 \"comparison_operator\" \"\")\n \t\t\t (match_operand:DF 2 \"register_operand\" \"\")\n \t\t\t (match_operand:DF 3 \"register_operand\" \"\")))]\n-  \"TARGET_CMOVE\"\n+  \"(TARGET_80387 && TARGET_CMOVE) || (TARGET_SSE2 && TARGET_SSE_MATH)\"\n   \"if (! ix86_expand_fp_movcc (operands)) FAIL; DONE;\")\n \n+;; These versions of min/max are aware of the instruction's behaviour\n+;; wrt -0.0 and NaN inputs.  If we don't care about either, then we\n+;; should have used the smin/smax expanders in the first place.\n+(define_insn \"*movdfcc_1_sse_min\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=x\")\n+\t(if_then_else:DF\n+\t  (lt:DF (match_operand:DF 1 \"register_operand\" \"0\")\n+\t\t (match_operand:DF 2 \"nonimmediate_operand\" \"xm\"))\n+\t  (match_dup 1)\n+\t  (match_dup 2)))]\n+  \"TARGET_SSE2 && TARGET_SSE_MATH\"\n+  \"minsd\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sseadd\")\n+   (set_attr \"mode\" \"DF\")])\n+\n+(define_insn \"*movdfcc_1_sse_max\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=x\")\n+\t(if_then_else:DF\n+\t  (lt:DF (match_operand:DF 2 \"nonimmediate_operand\" \"xm\")\n+\t\t (match_operand:DF 1 \"register_operand\" \"0\"))\n+\t  (match_dup 1)\n+\t  (match_dup 2)))]\n+  \"TARGET_SSE2 && TARGET_SSE_MATH\"\n+  \"maxsd\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sseadd\")\n+   (set_attr \"mode\" \"DF\")])\n+\n+(define_insn_and_split \"*movdfcc_1_sse\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=x,x,x\")\n+\t(if_then_else:DF\n+\t  (match_operator:DF 4 \"sse_comparison_operator\"\n+\t    [(match_operand:DF 5 \"register_operand\" \"0,0,0\")\n+\t     (match_operand:DF 6 \"nonimmediate_operand\" \"xm,xm,xm\")])\n+\t  (match_operand:DF 2 \"reg_or_0_operand\" \"C,x,1\")\n+\t  (match_operand:DF 3 \"reg_or_0_operand\" \"x,C,x\")))\n+   (clobber (match_scratch:V2DF 1 \"=X,X,x\"))]\n+  \"TARGET_SSE2 && TARGET_SSE_MATH\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  ix86_split_sse_movcc (operands);\n+  DONE;\n+})\n+\n (define_insn \"*movdfcc_1\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f#r,f#r,&r#f,&r#f\")\n \t(if_then_else:DF (match_operator 1 \"fcmov_comparison_operator\" \n \t\t\t\t[(reg FLAGS_REG) (const_int 0)])\n \t\t      (match_operand:DF 2 \"nonimmediate_operand\" \"f#r,0,rm#f,0\")\n \t\t      (match_operand:DF 3 \"nonimmediate_operand\" \"0,f#r,0,rm#f\")))]\n-  \"!TARGET_64BIT && TARGET_CMOVE\n+  \"!TARGET_64BIT && TARGET_80387 && TARGET_CMOVE\n    && (GET_CODE (operands[2]) != MEM || GET_CODE (operands[3]) != MEM)\"\n   \"@\n    fcmov%F1\\t{%2, %0|%0, %2}\n@@ -17577,7 +17670,7 @@\n \t\t\t\t[(reg FLAGS_REG) (const_int 0)])\n \t\t      (match_operand:DF 2 \"nonimmediate_operand\" \"f#r,0#r,rm#f,0#f\")\n \t\t      (match_operand:DF 3 \"nonimmediate_operand\" \"0#r,f#r,0#f,rm#f\")))]\n-  \"TARGET_64BIT && TARGET_CMOVE\n+  \"TARGET_64BIT && TARGET_80387 && TARGET_CMOVE\n    && (GET_CODE (operands[2]) != MEM || GET_CODE (operands[3]) != MEM)\"\n   \"@\n    fcmov%F1\\t{%2, %0|%0, %2}\n@@ -17590,7 +17683,8 @@\n (define_split\n   [(set (match_operand:DF 0 \"register_and_not_any_fp_reg_operand\" \"\")\n \t(if_then_else:DF (match_operator 1 \"fcmov_comparison_operator\" \n-\t\t\t\t[(match_operand 4 \"flags_reg_operand\" \"\") (const_int 0)])\n+\t\t\t\t[(match_operand 4 \"flags_reg_operand\" \"\")\n+\t\t\t\t (const_int 0)])\n \t\t      (match_operand:DF 2 \"nonimmediate_operand\" \"\")\n \t\t      (match_operand:DF 3 \"nonimmediate_operand\" \"\")))]\n   \"!TARGET_64BIT && reload_completed\"\n@@ -17611,7 +17705,7 @@\n \t(if_then_else:XF (match_operand 1 \"comparison_operator\" \"\")\n \t\t\t (match_operand:XF 2 \"register_operand\" \"\")\n \t\t\t (match_operand:XF 3 \"register_operand\" \"\")))]\n-  \"TARGET_CMOVE\"\n+  \"TARGET_80387 && TARGET_CMOVE\"\n   \"if (! ix86_expand_fp_movcc (operands)) FAIL; DONE;\")\n \n (define_insn \"*movxfcc_1\"\n@@ -17620,62 +17714,53 @@\n \t\t\t\t[(reg FLAGS_REG) (const_int 0)])\n \t\t      (match_operand:XF 2 \"register_operand\" \"f,0\")\n \t\t      (match_operand:XF 3 \"register_operand\" \"0,f\")))]\n-  \"TARGET_CMOVE\"\n+  \"TARGET_80387 && TARGET_CMOVE\"\n   \"@\n    fcmov%F1\\t{%2, %0|%0, %2}\n    fcmov%f1\\t{%3, %0|%0, %3}\"\n   [(set_attr \"type\" \"fcmov\")\n    (set_attr \"mode\" \"XF\")])\n \n-(define_expand \"minsf3\"\n-  [(parallel [\n-     (set (match_operand:SF 0 \"register_operand\" \"\")\n-\t  (if_then_else:SF (lt (match_operand:SF 1 \"register_operand\" \"\")\n-\t\t\t       (match_operand:SF 2 \"nonimmediate_operand\" \"\"))\n-\t\t\t   (match_dup 1)\n-\t\t\t   (match_dup 2)))\n-     (clobber (reg:CC FLAGS_REG))])]\n-  \"TARGET_SSE\"\n-  \"\")\n+;; These versions of the min/max patterns are intentionally ignorant of\n+;; their behaviour wrt -0.0 and NaN (via the commutative operand mark).\n+;; Since both the tree-level MAX_EXPR and the rtl-level SMAX operator\n+;; are undefined in this condition, we're certain this is correct.\n \n-(define_insn \"*minsf\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=x#f,f#x,f#x\")\n-\t(if_then_else:SF (lt (match_operand:SF 1 \"register_operand\" \"0,0,f#x\")\n-\t\t\t     (match_operand:SF 2 \"nonimmediate_operand\" \"xm#f,f#x,0\"))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_SSE && TARGET_IEEE_FP\"\n-  \"#\")\n+(define_insn \"sminsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=x\")\n+\t(smin:SF (match_operand:SF 1 \"nonimmediate_operand\" \"%0\")\n+\t\t (match_operand:SF 2 \"nonimmediate_operand\" \"xm\")))]\n+  \"TARGET_SSE_MATH\"\n+  \"minss\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sseadd\")\n+   (set_attr \"mode\" \"SF\")])\n \n-(define_insn \"*minsf_nonieee\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=x#f,f#x\")\n-\t(if_then_else:SF (lt (match_operand:SF 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t\t     (match_operand:SF 2 \"nonimmediate_operand\" \"xm#f,f#x\"))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_SSE && !TARGET_IEEE_FP\n-   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n-  \"#\")\n+(define_insn \"smaxsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=x\")\n+\t(smax:SF (match_operand:SF 1 \"nonimmediate_operand\" \"%0\")\n+\t\t (match_operand:SF 2 \"nonimmediate_operand\" \"xm\")))]\n+  \"TARGET_SSE_MATH\"\n+  \"minss\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sseadd\")\n+   (set_attr \"mode\" \"SF\")])\n \n-(define_split\n-  [(set (match_operand:SF 0 \"register_operand\" \"\")\n-\t(if_then_else:SF (lt (match_operand:SF 1 \"register_operand\" \"\")\n-\t\t\t     (match_operand:SF 2 \"nonimmediate_operand\" \"\"))\n-\t\t\t (match_operand:SF 3 \"register_operand\" \"\")\n-\t\t\t (match_operand:SF 4 \"nonimmediate_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"SSE_REG_P (operands[0]) && reload_completed\n-   && ((operands_match_p (operands[1], operands[3])\n-\t&& operands_match_p (operands[2], operands[4]))\n-       || (operands_match_p (operands[1], operands[4])\n-\t   && operands_match_p (operands[2], operands[3])))\"\n-  [(set (match_dup 0)\n-\t(if_then_else:SF (lt (match_dup 1)\n-\t\t\t     (match_dup 2))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))])\n+(define_insn \"smindf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=x\")\n+\t(smin:DF (match_operand:DF 1 \"nonimmediate_operand\" \"%0\")\n+\t\t (match_operand:DF 2 \"nonimmediate_operand\" \"xm\")))]\n+  \"TARGET_SSE2 && TARGET_SSE_MATH\"\n+  \"minsd\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sseadd\")\n+   (set_attr \"mode\" \"DF\")])\n+\n+(define_insn \"smaxdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=x\")\n+\t(smax:DF (match_operand:DF 1 \"nonimmediate_operand\" \"%0\")\n+\t\t (match_operand:DF 2 \"nonimmediate_operand\" \"xm\")))]\n+  \"TARGET_SSE2 && TARGET_SSE_MATH\"\n+  \"maxsd\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sseadd\")\n+   (set_attr \"mode\" \"DF\")])\n \n ;; Conditional addition patterns\n (define_expand \"addqicc\"\n@@ -17710,282 +17795,6 @@\n   \"TARGET_64BIT\"\n   \"if (!ix86_expand_int_addcc (operands)) FAIL; DONE;\")\n \n-;; We can't represent the LT test directly.  Do this by swapping the operands.\n-\n-(define_split\n-  [(set (match_operand:SF 0 \"fp_register_operand\" \"\")\n-\t(if_then_else:SF (lt (match_operand:SF 1 \"register_operand\" \"\")\n-\t\t\t     (match_operand:SF 2 \"register_operand\" \"\"))\n-\t\t\t (match_operand:SF 3 \"register_operand\" \"\")\n-\t\t\t (match_operand:SF 4 \"register_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"reload_completed\n-   && ((operands_match_p (operands[1], operands[3])\n-\t&& operands_match_p (operands[2], operands[4]))\n-       || (operands_match_p (operands[1], operands[4])\n-\t   && operands_match_p (operands[2], operands[3])))\"\n-  [(set (reg:CCFP FLAGS_REG)\n-\t(compare:CCFP (match_dup 2)\n-\t\t      (match_dup 1)))\n-   (set (match_dup 0)\n-\t(if_then_else:SF (ge (reg:CCFP FLAGS_REG) (const_int 0))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))])\n-\n-(define_insn \"*minsf_sse\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=x\")\n-\t(if_then_else:SF (lt (match_operand:SF 1 \"register_operand\" \"0\")\n-\t\t\t     (match_operand:SF 2 \"nonimmediate_operand\" \"xm\"))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))]\n-  \"TARGET_SSE && reload_completed\"\n-  \"minss\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sse\")\n-   (set_attr \"mode\" \"SF\")])\n-\n-(define_expand \"mindf3\"\n-  [(parallel [\n-     (set (match_operand:DF 0 \"register_operand\" \"\")\n-\t  (if_then_else:DF (lt (match_operand:DF 1 \"register_operand\" \"\")\n-\t\t\t       (match_operand:DF 2 \"nonimmediate_operand\" \"\"))\n-\t\t\t   (match_dup 1)\n-\t\t\t   (match_dup 2)))\n-     (clobber (reg:CC FLAGS_REG))])]\n-  \"TARGET_SSE2 && TARGET_SSE_MATH\"\n-  \"#\")\n-\n-(define_insn \"*mindf\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=Y#f,f#Y,f#Y\")\n-\t(if_then_else:DF (lt (match_operand:DF 1 \"register_operand\" \"0,0,f#Y\")\n-\t\t\t     (match_operand:DF 2 \"nonimmediate_operand\" \"Ym#f,f#Y,0\"))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_SSE2 && TARGET_IEEE_FP && TARGET_SSE_MATH\"\n-  \"#\")\n-\n-(define_insn \"*mindf_nonieee\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=Y#f,f#Y\")\n-\t(if_then_else:DF (lt (match_operand:DF 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t\t     (match_operand:DF 2 \"nonimmediate_operand\" \"Ym#f,f#Y\"))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_SSE2 && TARGET_SSE_MATH && !TARGET_IEEE_FP\n-   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n-  \"#\")\n-\n-(define_split\n-  [(set (match_operand:DF 0 \"register_operand\" \"\")\n-\t(if_then_else:DF (lt (match_operand:DF 1 \"register_operand\" \"\")\n-\t\t\t     (match_operand:DF 2 \"nonimmediate_operand\" \"\"))\n-\t\t\t (match_operand:DF 3 \"register_operand\" \"\")\n-\t\t\t (match_operand:DF 4 \"nonimmediate_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"SSE_REG_P (operands[0]) && reload_completed\n-   && ((operands_match_p (operands[1], operands[3])\n-\t&& operands_match_p (operands[2], operands[4]))\n-       || (operands_match_p (operands[1], operands[4])\n-\t   && operands_match_p (operands[2], operands[3])))\"\n-  [(set (match_dup 0)\n-\t(if_then_else:DF (lt (match_dup 1)\n-\t\t\t     (match_dup 2))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))])\n-\n-;; We can't represent the LT test directly.  Do this by swapping the operands.\n-(define_split\n-  [(set (match_operand:DF 0 \"fp_register_operand\" \"\")\n-\t(if_then_else:DF (lt (match_operand:DF 1 \"register_operand\" \"\")\n-\t\t\t     (match_operand:DF 2 \"register_operand\" \"\"))\n-\t\t\t (match_operand:DF 3 \"register_operand\" \"\")\n-\t\t\t (match_operand:DF 4 \"register_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"reload_completed\n-   && ((operands_match_p (operands[1], operands[3])\n-\t&& operands_match_p (operands[2], operands[4]))\n-       || (operands_match_p (operands[1], operands[4])\n-\t   && operands_match_p (operands[2], operands[3])))\"\n-  [(set (reg:CCFP FLAGS_REG)\n-\t(compare:CCFP (match_dup 2)\n-\t\t      (match_dup 1)))\n-   (set (match_dup 0)\n-\t(if_then_else:DF (ge (reg:CCFP FLAGS_REG) (const_int 0))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))])\n-\n-(define_insn \"*mindf_sse\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=Y\")\n-\t(if_then_else:DF (lt (match_operand:DF 1 \"register_operand\" \"0\")\n-\t\t\t     (match_operand:DF 2 \"nonimmediate_operand\" \"Ym\"))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))]\n-  \"TARGET_SSE2 && TARGET_SSE_MATH && reload_completed\"\n-  \"minsd\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sse\")\n-   (set_attr \"mode\" \"DF\")])\n-\n-(define_expand \"maxsf3\"\n-  [(parallel [\n-     (set (match_operand:SF 0 \"register_operand\" \"\")\n-\t  (if_then_else:SF (gt (match_operand:SF 1 \"register_operand\" \"\")\n-\t\t\t       (match_operand:SF 2 \"nonimmediate_operand\" \"\"))\n-\t\t\t   (match_dup 1)\n-\t\t\t   (match_dup 2)))\n-     (clobber (reg:CC FLAGS_REG))])]\n-  \"TARGET_SSE\"\n-  \"#\")\n-\n-(define_insn \"*maxsf\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=x#f,f#x,f#x\")\n-\t(if_then_else:SF (gt (match_operand:SF 1 \"register_operand\" \"0,0,f#x\")\n-\t\t\t     (match_operand:SF 2 \"nonimmediate_operand\" \"xm#f,f#x,0\"))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_SSE && TARGET_IEEE_FP\"\n-  \"#\")\n-\n-(define_insn \"*maxsf_nonieee\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=x#f,f#x\")\n-\t(if_then_else:SF (gt (match_operand:SF 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t\t     (match_operand:SF 2 \"nonimmediate_operand\" \"xm#f,f#x\"))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_SSE && !TARGET_IEEE_FP\n-   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n-  \"#\")\n-\n-(define_split\n-  [(set (match_operand:SF 0 \"register_operand\" \"\")\n-\t(if_then_else:SF (gt (match_operand:SF 1 \"register_operand\" \"\")\n-\t\t\t     (match_operand:SF 2 \"nonimmediate_operand\" \"\"))\n-\t\t\t (match_operand:SF 3 \"register_operand\" \"\")\n-\t\t\t (match_operand:SF 4 \"nonimmediate_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"SSE_REG_P (operands[0]) && reload_completed\n-   && ((operands_match_p (operands[1], operands[3])\n-\t&& operands_match_p (operands[2], operands[4]))\n-       || (operands_match_p (operands[1], operands[4])\n-\t   && operands_match_p (operands[2], operands[3])))\"\n-  [(set (match_dup 0)\n-\t(if_then_else:SF (gt (match_dup 1)\n-\t\t\t     (match_dup 2))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))])\n-\n-(define_split\n-  [(set (match_operand:SF 0 \"fp_register_operand\" \"\")\n-\t(if_then_else:SF (gt (match_operand:SF 1 \"register_operand\" \"\")\n-\t\t\t     (match_operand:SF 2 \"register_operand\" \"\"))\n-\t\t\t (match_operand:SF 3 \"register_operand\" \"\")\n-\t\t\t (match_operand:SF 4 \"register_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"reload_completed\n-   && ((operands_match_p (operands[1], operands[3])\n-\t&& operands_match_p (operands[2], operands[4]))\n-       || (operands_match_p (operands[1], operands[4])\n-\t   && operands_match_p (operands[2], operands[3])))\"\n-  [(set (reg:CCFP FLAGS_REG)\n-\t(compare:CCFP (match_dup 1)\n-\t\t      (match_dup 2)))\n-   (set (match_dup 0)\n-\t(if_then_else:SF (gt (reg:CCFP FLAGS_REG) (const_int 0))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))])\n-\n-(define_insn \"*maxsf_sse\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=x\")\n-\t(if_then_else:SF (gt (match_operand:SF 1 \"register_operand\" \"0\")\n-\t\t\t     (match_operand:SF 2 \"nonimmediate_operand\" \"xm\"))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))]\n-  \"TARGET_SSE && reload_completed\"\n-  \"maxss\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sse\")\n-   (set_attr \"mode\" \"SF\")])\n-\n-(define_expand \"maxdf3\"\n-  [(parallel [\n-     (set (match_operand:DF 0 \"register_operand\" \"\")\n-\t  (if_then_else:DF (gt (match_operand:DF 1 \"register_operand\" \"\")\n-\t\t\t       (match_operand:DF 2 \"nonimmediate_operand\" \"\"))\n-\t\t\t   (match_dup 1)\n-\t\t\t   (match_dup 2)))\n-     (clobber (reg:CC FLAGS_REG))])]\n-  \"TARGET_SSE2 && TARGET_SSE_MATH\"\n-  \"#\")\n-\n-(define_insn \"*maxdf\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=Y#f,f#Y,f#Y\")\n-\t(if_then_else:DF (gt (match_operand:DF 1 \"register_operand\" \"0,0,f#Y\")\n-\t\t\t     (match_operand:DF 2 \"nonimmediate_operand\" \"Ym#f,f#Y,0\"))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_SSE2 && TARGET_SSE_MATH && TARGET_IEEE_FP\"\n-  \"#\")\n-\n-(define_insn \"*maxdf_nonieee\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=Y#f,f#Y\")\n-\t(if_then_else:DF (gt (match_operand:DF 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t\t     (match_operand:DF 2 \"nonimmediate_operand\" \"Ym#f,f#Y\"))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_SSE2 && TARGET_SSE_MATH && !TARGET_IEEE_FP\n-   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n-  \"#\")\n-\n-(define_split\n-  [(set (match_operand:DF 0 \"register_operand\" \"\")\n-\t(if_then_else:DF (gt (match_operand:DF 1 \"register_operand\" \"\")\n-\t\t\t     (match_operand:DF 2 \"nonimmediate_operand\" \"\"))\n-\t\t\t (match_operand:DF 3 \"register_operand\" \"\")\n-\t\t\t (match_operand:DF 4 \"nonimmediate_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"SSE_REG_P (operands[0]) && reload_completed\n-   && ((operands_match_p (operands[1], operands[3])\n-\t&& operands_match_p (operands[2], operands[4]))\n-       || (operands_match_p (operands[1], operands[4])\n-\t   && operands_match_p (operands[2], operands[3])))\"\n-  [(set (match_dup 0)\n-\t(if_then_else:DF (gt (match_dup 1)\n-\t\t\t     (match_dup 2))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))])\n-\n-(define_split\n-  [(set (match_operand:DF 0 \"fp_register_operand\" \"\")\n-\t(if_then_else:DF (gt (match_operand:DF 1 \"register_operand\" \"\")\n-\t\t\t     (match_operand:DF 2 \"register_operand\" \"\"))\n-\t\t\t (match_operand:DF 3 \"register_operand\" \"\")\n-\t\t\t (match_operand:DF 4 \"register_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"reload_completed\n-   && ((operands_match_p (operands[1], operands[3])\n-\t&& operands_match_p (operands[2], operands[4]))\n-       || (operands_match_p (operands[1], operands[4])\n-\t   && operands_match_p (operands[2], operands[3])))\"\n-  [(set (reg:CCFP FLAGS_REG)\n-\t(compare:CCFP (match_dup 1)\n-\t\t      (match_dup 2)))\n-   (set (match_dup 0)\n-\t(if_then_else:DF (gt (reg:CCFP FLAGS_REG) (const_int 0))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))])\n-\n-(define_insn \"*maxdf_sse\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=Y\")\n-\t(if_then_else:DF (gt (match_operand:DF 1 \"register_operand\" \"0\")\n-\t\t\t     (match_operand:DF 2 \"nonimmediate_operand\" \"Ym\"))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))]\n-  \"TARGET_SSE2 && TARGET_SSE_MATH && reload_completed\"\n-  \"maxsd\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sse\")\n-   (set_attr \"mode\" \"DF\")])\n \f\n ;; Misc patterns (?)\n \n@@ -18107,364 +17916,6 @@\n   [(set_attr \"type\" \"alu,lea\")\n    (set_attr \"mode\" \"DI\")])\n \n-;; Placeholder for the conditional moves.  This one is split either to SSE\n-;; based moves emulation or to usual cmove sequence.  Little bit unfortunate\n-;; fact is that compares supported by the cmp??ss instructions are exactly\n-;; swapped of those supported by cmove sequence.\n-;; The EQ/NE comparisons also needs bit care, since they are not directly\n-;; supported by i387 comparisons and we do need to emit two conditional moves\n-;; in tandem.\n-\n-(define_insn \"sse_movsfcc\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=&x#rf,x#rf,?f#xr,?f#xr,?f#xr,?f#xr,?r#xf,?r#xf,?r#xf,?r#xf\")\n-\t(if_then_else:SF (match_operator 1 \"sse_comparison_operator\"\n-\t\t\t[(match_operand:SF 4 \"nonimmediate_operand\" \"0#fx,x#fx,f#x,f#x,xm#f,xm#f,f#x,f#x,xm#f,xm#f\")\n-\t\t\t (match_operand:SF 5 \"nonimmediate_operand\" \"xm#f,xm#f,f#x,f#x,x#f,x#f,f#x,f#x,x#f,x#f\")])\n-\t\t      (match_operand:SF 2 \"nonimmediate_operand\" \"x#fr,0#fr,f#fx,0#fx,f#fx,0#fx,rm#rx,0#rx,rm#rx,0#rx\")\n-\t\t      (match_operand:SF 3 \"nonimmediate_operand\" \"x#fr,x#fr,0#fx,f#fx,0#fx,f#fx,0#fx,rm#rx,0#rx,rm#rx\")))\n-   (clobber (match_scratch:SF 6 \"=2,&4,X,X,X,X,X,X,X,X\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_SSE\n-   && (GET_CODE (operands[2]) != MEM || GET_CODE (operands[3]) != MEM)\n-   /* Avoid combine from being smart and converting min/max\n-      instruction patterns into conditional moves.  */\n-   && ((GET_CODE (operands[1]) != LT && GET_CODE (operands[1]) != GT\n-\t&& GET_CODE (operands[1]) != UNLE && GET_CODE (operands[1]) != UNGE)\n-       || !rtx_equal_p (operands[4], operands[2])\n-       || !rtx_equal_p (operands[5], operands[3]))\n-   && (!TARGET_IEEE_FP\n-       || (GET_CODE (operands[1]) != EQ && GET_CODE (operands[1]) != NE))\"\n-  \"#\")\n-\n-(define_insn \"sse_movsfcc_eq\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=&x#rf,x#rf,?f#xr,?f#xr,?r#xf,?r#xf\")\n-\t(if_then_else:SF (eq (match_operand:SF 3 \"nonimmediate_operand\" \"%0#fx,x#fx,f#x,xm#f,f#x,xm#f\")\n-\t\t\t     (match_operand:SF 4 \"nonimmediate_operand\" \"xm#f,xm#f,f#x,x#f,f#x,x#f\"))\n-\t\t      (match_operand:SF 1 \"nonimmediate_operand\" \"x#fr,0#fr,0#fx,0#fx,0#rx,0#rx\")\n-\t\t      (match_operand:SF 2 \"nonimmediate_operand\" \"x#fr,x#fr,f#fx,f#fx,rm#rx,rm#rx\")))\n-   (clobber (match_scratch:SF 5 \"=1,&3,X,X,X,X\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_SSE\n-   && (GET_CODE (operands[2]) != MEM || GET_CODE (operands[3]) != MEM)\"\n-  \"#\")\n-\n-(define_insn \"sse_movdfcc\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=&Y#rf,Y#rf,?f#Yr,?f#Yr,?f#Yr,?f#Yr,?r#Yf,?r#Yf,?r#Yf,?r#Yf\")\n-\t(if_then_else:DF (match_operator 1 \"sse_comparison_operator\"\n-\t\t\t[(match_operand:DF 4 \"nonimmediate_operand\" \"0#fY,Y#fY,f#Y,f#Y,Ym#f,Ym#f,f#Y,f#Y,Ym#f,Ym#f\")\n-\t\t\t (match_operand:DF 5 \"nonimmediate_operand\" \"Ym#f,Ym#f,f#Y,f#Y,Y#f,Y#f,f#Y,f#Y,Y#f,Y#f\")])\n-\t\t      (match_operand:DF 2 \"nonimmediate_operand\" \"Y#fr,0#fr,f#fY,0#fY,f#fY,0#fY,rm#rY,0#rY,rm#rY,0#rY\")\n-\t\t      (match_operand:DF 3 \"nonimmediate_operand\" \"Y#fr,Y#fr,0#fY,f#fY,0#fY,f#fY,0#fY,rm#rY,0#rY,rm#rY\")))\n-   (clobber (match_scratch:DF 6 \"=2,&4,X,X,X,X,X,X,X,X\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_SSE2\n-   && (GET_CODE (operands[2]) != MEM || GET_CODE (operands[3]) != MEM)\n-   /* Avoid combine from being smart and converting min/max\n-      instruction patterns into conditional moves.  */\n-   && ((GET_CODE (operands[1]) != LT && GET_CODE (operands[1]) != GT\n-\t&& GET_CODE (operands[1]) != UNLE && GET_CODE (operands[1]) != UNGE)\n-       || !rtx_equal_p (operands[4], operands[2])\n-       || !rtx_equal_p (operands[5], operands[3]))\n-   && (!TARGET_IEEE_FP\n-       || (GET_CODE (operands[1]) != EQ && GET_CODE (operands[1]) != NE))\"\n-  \"#\")\n-\n-(define_insn \"sse_movdfcc_eq\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=&Y#rf,Y#rf,?f#Yr,?f#Yr,?r#Yf,?r#Yf\")\n-\t(if_then_else:DF (eq (match_operand:DF 3 \"nonimmediate_operand\" \"%0#fY,Y#fY,f#Y,Ym#f,f#Y,Ym#f\")\n-\t\t\t     (match_operand:DF 4 \"nonimmediate_operand\" \"Ym#f,Ym#f,f#Y,Y#f,f#Y,Y#f\"))\n-\t\t      (match_operand:DF 1 \"nonimmediate_operand\" \"Y#fr,0#fr,0#fY,0#fY,0#rY,0#rY\")\n-\t\t      (match_operand:DF 2 \"nonimmediate_operand\" \"Y#fr,Y#fr,f#fY,f#fY,rm#rY,rm#rY\")))\n-   (clobber (match_scratch:DF 5 \"=1,&3,X,X,X,X\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_SSE\n-   && (GET_CODE (operands[2]) != MEM || GET_CODE (operands[3]) != MEM)\"\n-  \"#\")\n-\n-;; For non-sse moves just expand the usual cmove sequence.\n-(define_split\n-  [(set (match_operand 0 \"register_operand\" \"\")\n-\t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t[(match_operand 4 \"nonimmediate_operand\" \"\")\n-\t\t\t (match_operand 5 \"register_operand\" \"\")])\n-\t\t      (match_operand 2 \"nonimmediate_operand\" \"\")\n-\t\t      (match_operand 3 \"nonimmediate_operand\" \"\")))\n-   (clobber (match_operand 6 \"\" \"\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!SSE_REG_P (operands[0]) && reload_completed\n-   && (GET_MODE (operands[0]) == SFmode\n-       || (TARGET_SSE2 && GET_MODE (operands[0]) == DFmode))\"\n-  [(const_int 0)]\n-{\n-   ix86_compare_op0 = operands[5];\n-   ix86_compare_op1 = operands[4];\n-   operands[1] = gen_rtx_fmt_ee (swap_condition (GET_CODE (operands[1])),\n-\t\t\t\t VOIDmode, operands[5], operands[4]);\n-   ix86_expand_fp_movcc (operands);\n-   DONE;\n-})\n-\n-;; Split SSE based conditional move into sequence:\n-;; cmpCC op0, op4   -  set op0 to 0 or ffffffff depending on the comparison\n-;; and   op2, op0   -  zero op2 if comparison was false\n-;; nand  op0, op3   -  load op3 to op0 if comparison was false\n-;; or\t op2, op0   -  get the nonzero one into the result.\n-(define_split\n-  [(set (match_operand:SF 0 \"register_operand\" \"\")\n-\t(if_then_else:SF (match_operator:SF 1 \"sse_comparison_operator\"\n-\t\t\t   [(match_operand:SF 4 \"register_operand\" \"\")\n-\t\t\t    (match_operand:SF 5 \"nonimmediate_operand\" \"\")])\n-\t\t         (match_operand:SF 2 \"register_operand\" \"\")\n-\t\t         (match_operand:SF 3 \"register_operand\" \"\")))\n-   (clobber (match_operand 6 \"\" \"\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"SSE_REG_P (operands[0]) && reload_completed\"\n-  [(set (match_dup 4) (match_op_dup 1 [(match_dup 4) (match_dup 5)]))\n-   (set (match_dup 2) (and:V4SF (match_dup 2)\n-\t\t\t        (match_dup 8)))\n-   (set (match_dup 8) (and:V4SF (not:V4SF (match_dup 8))\n-\t\t\t\t          (match_dup 3)))\n-   (set (match_dup 0) (ior:V4SF (match_dup 6)\n-\t\t\t        (match_dup 7)))]\n-{\n-  /* If op2 == op3, op3 would be clobbered before it is used.  */\n-  if (operands_match_p (operands[2], operands[3]))\n-    {\n-      emit_move_insn (operands[0], operands[2]);\n-      DONE;\n-    }\n-\n-  PUT_MODE (operands[1], GET_MODE (operands[0]));\n-  if (operands_match_p (operands[0], operands[4]))\n-    operands[6] = operands[4], operands[7] = operands[2];\n-  else\n-    operands[6] = operands[2], operands[7] = operands[4];\n-  operands[0] = simplify_gen_subreg (V4SFmode, operands[0], SFmode, 0);\n-  operands[2] = simplify_gen_subreg (V4SFmode, operands[2], SFmode, 0);\n-  operands[3] = simplify_gen_subreg (V4SFmode, operands[3], SFmode, 0);\n-  operands[8] = simplify_gen_subreg (V4SFmode, operands[4], SFmode, 0);\n-  operands[6] = simplify_gen_subreg (V4SFmode, operands[6], SFmode, 0);\n-  operands[7] = simplify_gen_subreg (V4SFmode, operands[7], SFmode, 0);\n-})\n-\n-(define_split\n-  [(set (match_operand:DF 0 \"register_operand\" \"\")\n-\t(if_then_else:DF (match_operator:DF 1 \"sse_comparison_operator\"\n-\t\t\t   [(match_operand:DF 4 \"register_operand\" \"\")\n-\t\t\t    (match_operand:DF 5 \"nonimmediate_operand\" \"\")])\n-\t\t         (match_operand:DF 2 \"register_operand\" \"\")\n-\t\t         (match_operand:DF 3 \"register_operand\" \"\")))\n-   (clobber (match_operand 6 \"\" \"\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"SSE_REG_P (operands[0]) && reload_completed\"\n-  [(set (match_dup 4) (match_op_dup 1 [(match_dup 4) (match_dup 5)]))\n-   (set (match_dup 2) (and:V2DF (match_dup 2)\n-\t\t\t        (match_dup 8)))\n-   (set (match_dup 8) (and:V2DF (not:V2DF (match_dup 8))\n-\t\t\t\t          (match_dup 3)))\n-   (set (match_dup 0) (ior:V2DF (match_dup 6)\n-\t\t\t        (match_dup 7)))]\n-{\n-  if (TARGET_SSE_SPLIT_REGS && !optimize_size)\n-    {\n-      rtx op = simplify_gen_subreg (V2DFmode, operands[2], DFmode, 0);\n-      emit_insn (gen_sse2_unpcklpd (op, op, op));\n-      op = simplify_gen_subreg (V2DFmode, operands[3], DFmode, 0);\n-      emit_insn (gen_sse2_unpcklpd (op, op, op));\n-    }\n-\n-  /* If op2 == op3, op3 would be clobbered before it is used.  */\n-  if (operands_match_p (operands[2], operands[3]))\n-    {\n-      emit_move_insn (operands[0], operands[2]);\n-      DONE;\n-    }\n-\n-  PUT_MODE (operands[1], GET_MODE (operands[0]));\n-  if (operands_match_p (operands[0], operands[4]))\n-    operands[6] = operands[4], operands[7] = operands[2];\n-  else\n-    operands[6] = operands[2], operands[7] = operands[4];\n-  operands[0] = simplify_gen_subreg (V2DFmode, operands[0], DFmode, 0);\n-  operands[2] = simplify_gen_subreg (V2DFmode, operands[2], DFmode, 0);\n-  operands[3] = simplify_gen_subreg (V2DFmode, operands[3], DFmode, 0);\n-  operands[8] = simplify_gen_subreg (V2DFmode, operands[4], DFmode, 0);\n-  operands[6] = simplify_gen_subreg (V2DFmode, operands[6], DFmode, 0);\n-  operands[7] = simplify_gen_subreg (V2DFmode, operands[7], DFmode, 0);\n-})\n-\n-;; Special case of conditional move we can handle effectively.\n-;; Do not brother with the integer/floating point case, since these are\n-;; bot considerably slower, unlike in the generic case.\n-(define_insn \"*sse_movsfcc_const0_1\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=&x\")\n-\t(if_then_else:SF (match_operator 1 \"sse_comparison_operator\"\n-\t\t\t[(match_operand:SF 4 \"register_operand\" \"0\")\n-\t\t\t (match_operand:SF 5 \"nonimmediate_operand\" \"xm\")])\n-\t\t      (match_operand:SF 2 \"register_operand\" \"x\")\n-\t\t      (match_operand:SF 3 \"const0_operand\" \"X\")))]\n-  \"TARGET_SSE\"\n-  \"#\")\n-\n-(define_insn \"*sse_movsfcc_const0_2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=&x\")\n-\t(if_then_else:SF (match_operator 1 \"sse_comparison_operator\"\n-\t\t\t[(match_operand:SF 4 \"register_operand\" \"0\")\n-\t\t\t (match_operand:SF 5 \"nonimmediate_operand\" \"xm\")])\n-\t\t      (match_operand:SF 2 \"const0_operand\" \"X\")\n-\t\t      (match_operand:SF 3 \"register_operand\" \"x\")))]\n-  \"TARGET_SSE\"\n-  \"#\")\n-\n-(define_insn \"*sse_movsfcc_const0_3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=&x\")\n-\t(if_then_else:SF (match_operator 1 \"fcmov_comparison_operator\"\n-\t\t\t[(match_operand:SF 4 \"nonimmediate_operand\" \"xm\")\n-\t\t\t (match_operand:SF 5 \"register_operand\" \"0\")])\n-\t\t      (match_operand:SF 2 \"register_operand\" \"x\")\n-\t\t      (match_operand:SF 3 \"const0_operand\" \"X\")))]\n-  \"TARGET_SSE\"\n-  \"#\")\n-\n-(define_insn \"*sse_movsfcc_const0_4\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=&x\")\n-\t(if_then_else:SF (match_operator 1 \"fcmov_comparison_operator\"\n-\t\t\t[(match_operand:SF 4 \"nonimmediate_operand\" \"xm\")\n-\t\t\t (match_operand:SF 5 \"register_operand\" \"0\")])\n-\t\t      (match_operand:SF 2 \"const0_operand\" \"X\")\n-\t\t      (match_operand:SF 3 \"register_operand\" \"x\")))]\n-  \"TARGET_SSE\"\n-  \"#\")\n-\n-(define_insn \"*sse_movdfcc_const0_1\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=&Y\")\n-\t(if_then_else:DF (match_operator 1 \"sse_comparison_operator\"\n-\t\t\t[(match_operand:DF 4 \"register_operand\" \"0\")\n-\t\t\t (match_operand:DF 5 \"nonimmediate_operand\" \"Ym\")])\n-\t\t      (match_operand:DF 2 \"register_operand\" \"Y\")\n-\t\t      (match_operand:DF 3 \"const0_operand\" \"X\")))]\n-  \"TARGET_SSE2\"\n-  \"#\")\n-\n-(define_insn \"*sse_movdfcc_const0_2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=&Y\")\n-\t(if_then_else:DF (match_operator 1 \"sse_comparison_operator\"\n-\t\t\t[(match_operand:DF 4 \"register_operand\" \"0\")\n-\t\t\t (match_operand:DF 5 \"nonimmediate_operand\" \"Ym\")])\n-\t\t      (match_operand:DF 2 \"const0_operand\" \"X\")\n-\t\t      (match_operand:DF 3 \"register_operand\" \"Y\")))]\n-  \"TARGET_SSE2\"\n-  \"#\")\n-\n-(define_insn \"*sse_movdfcc_const0_3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=&Y\")\n-\t(if_then_else:DF (match_operator 1 \"fcmov_comparison_operator\"\n-\t\t\t[(match_operand:DF 4 \"nonimmediate_operand\" \"Ym\")\n-\t\t\t (match_operand:DF 5 \"register_operand\" \"0\")])\n-\t\t      (match_operand:DF 2 \"register_operand\" \"Y\")\n-\t\t      (match_operand:DF 3 \"const0_operand\" \"X\")))]\n-  \"TARGET_SSE2\"\n-  \"#\")\n-\n-(define_insn \"*sse_movdfcc_const0_4\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=&Y\")\n-\t(if_then_else:DF (match_operator 1 \"fcmov_comparison_operator\"\n-\t\t\t[(match_operand:DF 4 \"nonimmediate_operand\" \"Ym\")\n-\t\t\t (match_operand:DF 5 \"register_operand\" \"0\")])\n-\t\t      (match_operand:DF 2 \"const0_operand\" \"X\")\n-\t\t      (match_operand:DF 3 \"register_operand\" \"Y\")))]\n-  \"TARGET_SSE2\"\n-  \"#\")\n-\n-(define_split\n-  [(set (match_operand:SF 0 \"register_operand\" \"\")\n-\t(if_then_else:SF (match_operator 1 \"comparison_operator\"\n-\t\t\t   [(match_operand:SF 4 \"nonimmediate_operand\" \"\")\n-\t\t\t    (match_operand:SF 5 \"nonimmediate_operand\" \"\")])\n-\t\t         (match_operand:SF 2 \"nonmemory_operand\" \"\")\n-\t\t         (match_operand:SF 3 \"nonmemory_operand\" \"\")))]\n-  \"SSE_REG_P (operands[0]) && reload_completed\n-   && (const0_operand (operands[2], GET_MODE (operands[0]))\n-       || const0_operand (operands[3], GET_MODE (operands[0])))\"\n-  [(set (match_dup 0) (match_op_dup 1 [(match_dup 0) (match_dup 5)]))\n-   (set (match_dup 8) (and:V4SF (match_dup 6) (match_dup 7)))]\n-{\n-  PUT_MODE (operands[1], GET_MODE (operands[0]));\n-  if (!sse_comparison_operator (operands[1], VOIDmode)\n-      || !rtx_equal_p (operands[0], operands[4]))\n-    {\n-      rtx tmp = operands[5];\n-      operands[5] = operands[4];\n-      operands[4] = tmp;\n-      PUT_CODE (operands[1], swap_condition (GET_CODE (operands[1])));\n-    }\n-  if (!rtx_equal_p (operands[0], operands[4]))\n-    abort ();\n-  operands[8] = simplify_gen_subreg (V4SFmode, operands[0], SFmode, 0);\n-  if (const0_operand (operands[2], GET_MODE (operands[2])))\n-    {\n-      operands[7] = operands[3];\n-      operands[6] = gen_rtx_NOT (V4SFmode, operands[8]);\n-    }\n-  else\n-    {\n-      operands[7] = operands[2];\n-      operands[6] = operands[8];\n-    }\n-  operands[7] = simplify_gen_subreg (V4SFmode, operands[7], SFmode, 0);\n-})\n-\n-(define_split\n-  [(set (match_operand:DF 0 \"register_operand\" \"\")\n-\t(if_then_else:DF (match_operator 1 \"comparison_operator\"\n-\t\t\t   [(match_operand:DF 4 \"nonimmediate_operand\" \"\")\n-\t\t\t    (match_operand:DF 5 \"nonimmediate_operand\" \"\")])\n-\t\t         (match_operand:DF 2 \"nonmemory_operand\" \"\")\n-\t\t         (match_operand:DF 3 \"nonmemory_operand\" \"\")))]\n-  \"SSE_REG_P (operands[0]) && reload_completed\n-   && (const0_operand (operands[2], GET_MODE (operands[0]))\n-       || const0_operand (operands[3], GET_MODE (operands[0])))\"\n-  [(set (match_dup 0) (match_op_dup 1 [(match_dup 0) (match_dup 5)]))\n-   (set (match_dup 8) (and:V2DF (match_dup 6) (match_dup 7)))]\n-{\n-  if (TARGET_SSE_SPLIT_REGS && !optimize_size)\n-    {\n-      if (REG_P (operands[2]))\n-\t{\n-\t  rtx op = simplify_gen_subreg (V2DFmode, operands[2], DFmode, 0);\n-\t  emit_insn (gen_sse2_unpcklpd (op, op, op));\n-\t}\n-      if (REG_P (operands[3]))\n-\t{\n-\t  rtx op = simplify_gen_subreg (V2DFmode, operands[3], DFmode, 0);\n-\t  emit_insn (gen_sse2_unpcklpd (op, op, op));\n-\t}\n-    }\n-  PUT_MODE (operands[1], GET_MODE (operands[0]));\n-  if (!sse_comparison_operator (operands[1], VOIDmode)\n-      || !rtx_equal_p (operands[0], operands[4]))\n-    {\n-      rtx tmp = operands[5];\n-      operands[5] = operands[4];\n-      operands[4] = tmp;\n-      PUT_CODE (operands[1], swap_condition (GET_CODE (operands[1])));\n-    }\n-  if (!rtx_equal_p (operands[0], operands[4]))\n-    abort ();\n-  operands[8] = simplify_gen_subreg (V2DFmode, operands[0], DFmode, 0);\n-  if (const0_operand (operands[2], GET_MODE (operands[2])))\n-    {\n-      operands[7] = operands[3];\n-      operands[6] = gen_rtx_NOT (V2DFmode, operands[8]);\n-    }\n-  else\n-    {\n-      operands[7] = operands[2];\n-      operands[6] = operands[8];\n-    }\n-  operands[7] = simplify_gen_subreg (V2DFmode, operands[7], DFmode, 0);\n-})\n-\n (define_expand \"allocate_stack_worker\"\n   [(match_operand:SI 0 \"register_operand\" \"\")]\n   \"TARGET_STACK_PROBE\""}]}