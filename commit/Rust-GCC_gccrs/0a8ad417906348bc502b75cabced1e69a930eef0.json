{"sha": "0a8ad417906348bc502b75cabced1e69a930eef0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGE4YWQ0MTc5MDYzNDhiYzUwMmI3NWNhYmNlZDFlNjlhOTMwZWVmMA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2000-11-19T00:30:05Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2000-11-19T00:30:05Z"}, "message": "Makefile.in (tradcpp.o, tradcif.o): Depend on tradcpp.h.\n\n\t* Makefile.in (tradcpp.o, tradcif.o): Depend on tradcpp.h.\n\n\t* tradcif.y: Include tradcpp.h.  Constify.  Make functions static.\n\tMove extern function declarations to tradcpp.h.\n\n\t* tradcpp.c: Likewise.\n\n\t* tradcpp.h: New file.\n\nFrom-SVN: r37550", "tree": {"sha": "c9bfae10caf5467e25c2e0a2faa4f6f7e35a46e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9bfae10caf5467e25c2e0a2faa4f6f7e35a46e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a8ad417906348bc502b75cabced1e69a930eef0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a8ad417906348bc502b75cabced1e69a930eef0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a8ad417906348bc502b75cabced1e69a930eef0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a8ad417906348bc502b75cabced1e69a930eef0/comments", "author": null, "committer": null, "parents": [{"sha": "77c4d6c06a83f7d86471befb76a1be433dc2e3a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77c4d6c06a83f7d86471befb76a1be433dc2e3a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77c4d6c06a83f7d86471befb76a1be433dc2e3a3"}], "stats": {"total": 487, "additions": 270, "deletions": 217}, "files": [{"sha": "3981e577325e3bff5d03f8147d9d7d299ba90987", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a8ad417906348bc502b75cabced1e69a930eef0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a8ad417906348bc502b75cabced1e69a930eef0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0a8ad417906348bc502b75cabced1e69a930eef0", "patch": "@@ -1,3 +1,14 @@\n+2000-11-18  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* Makefile.in (tradcpp.o, tradcif.o): Depend on tradcpp.h.\n+\n+\t* tradcif.y: Include tradcpp.h.  Constify.  Make functions static.\n+\tMove extern function declarations to tradcpp.h.\n+\n+\t* tradcpp.c: Likewise.\n+\n+\t* tradcpp.h: New file.\n+\n 2000-11-18  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* c-decl.c (check_for_loop_decls): New function."}, {"sha": "219b3df62097dc16753b369d6494d68730a79e81", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a8ad417906348bc502b75cabced1e69a930eef0/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a8ad417906348bc502b75cabced1e69a930eef0/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0a8ad417906348bc502b75cabced1e69a930eef0", "patch": "@@ -1886,8 +1886,8 @@ tradcpp0$(exeext): tradcpp.o tradcif.o cppdefault.o version.o intl.o $(LIBDEPS)\n \t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o tradcpp0$(exeext) \\\n \ttradcpp.o tradcif.o cppdefault.o version.o intl.o $(LIBS)\n \n-tradcpp.o: tradcpp.c $(CONFIG_H) system.h version.h cppdefault.h\n-tradcif.o: $(srcdir)/tradcif.c $(CONFIG_H) system.h defaults.h\n+tradcpp.o: tradcpp.c $(CONFIG_H) system.h version.h cppdefault.h tradcpp.h\n+tradcif.o: $(srcdir)/tradcif.c $(CONFIG_H) system.h defaults.h tradcpp.h\n \n $(srcdir)/tradcif.c: $(srcdir)/tradcif.y\n \t(cd $(srcdir) && $(BISON) $(BISONFLAGS) -o tr$$$$.c tradcif.y && \\"}, {"sha": "db95563826e0e85db677296a7e43c1325d904eed", "filename": "gcc/tradcif.y", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a8ad417906348bc502b75cabced1e69a930eef0/gcc%2Ftradcif.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a8ad417906348bc502b75cabced1e69a930eef0/gcc%2Ftradcif.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftradcif.y?ref=0a8ad417906348bc502b75cabced1e69a930eef0", "patch": "@@ -25,24 +25,17 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"config.h\"\n #include \"system.h\"\n #include \"defaults.h\"\n+#include \"tradcpp.h\"\n #include <setjmp.h>\n \n-  int yylex PARAMS ((void));\n-  void yyerror PARAMS ((const char *msgid));\n-  extern void error   PARAMS ((const char *msgid, ...));\n-  extern void warning PARAMS ((const char *msgid, ...));\n-  extern struct hashnode *lookup PARAMS ((const unsigned char *, int, int));\n+  static int yylex PARAMS ((void));\n+  static void yyerror PARAMS ((const char *msgid));\n \n-  int parse_number PARAMS ((int));\n-  int parse_escape PARAMS ((char **));\n-  int parse_c_expression PARAMS ((char *));\n+  static int parse_number PARAMS ((int));\n+  static int parse_escape PARAMS ((const char **));\n \n-  int expression_value;\n+  static int expression_value;\n   static jmp_buf parse_return_error;\n-\n-  /* some external tables of character types */\n-  extern unsigned char is_idstart[], is_idchar[];\n-\n %}\n \n %union {\n@@ -212,19 +205,19 @@ exp\t:\texp '*' exp\n /* During parsing of a C expression, the pointer to the next character\n    is in this variable.  */\n \n-static char *lexptr;\n+static const char *lexptr;\n \n /* Take care of parsing a number (anything that starts with a digit).\n    Set yylval and return the token type; update lexptr.\n    LEN is the number of characters in it.  */\n \n /* maybe needs to actually deal with floating point numbers */\n \n-int\n+static int\n parse_number (olen)\n      int olen;\n {\n-  register char *p = lexptr;\n+  register const char *p = lexptr;\n   register long n = 0;\n   register int c;\n   register int base = 10;\n@@ -315,12 +308,12 @@ static struct token tokentab2[] = {\n \n /* Read one token, getting characters through lexptr.  */\n \n-int\n+static int\n yylex ()\n {\n   register int c;\n   register int namelen;\n-  register char *tokstart;\n+  register const char *tokstart;\n   register struct token *toktab;\n \n  retry:\n@@ -443,9 +436,9 @@ yylex ()\n    If \\ is followed by 000, we return 0 and leave the string pointer\n    after the zeros.  A value of 0 does not mean end of string.  */\n \n-int\n+static int\n parse_escape (string_ptr)\n-     char **string_ptr;\n+     const char **string_ptr;\n {\n   register int c = *(*string_ptr)++;\n   switch (c)\n@@ -538,7 +531,7 @@ parse_escape (string_ptr)\n     }\n }\n \n-void\n+static void\n yyerror (s)\n      const char *s;\n {\n@@ -555,7 +548,7 @@ yyerror (s)\n \n int\n parse_c_expression (string)\n-     char *string;\n+     const char *string;\n {\n   lexptr = string;\n   "}, {"sha": "3e4955fb40108838a28fde9a78f6a32896a35e57", "filename": "gcc/tradcpp.c", "status": "modified", "additions": 201, "deletions": 193, "changes": 394, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a8ad417906348bc502b75cabced1e69a930eef0/gcc%2Ftradcpp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a8ad417906348bc502b75cabced1e69a930eef0/gcc%2Ftradcpp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftradcpp.c?ref=0a8ad417906348bc502b75cabced1e69a930eef0", "patch": "@@ -23,12 +23,13 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n #include \"version.h\"\n #include \"cppdefault.h\"\n+#include \"tradcpp.h\"\n \n typedef unsigned char U_CHAR;\n \n /* Name under which this program was invoked.  */\n \n-char *progname;\n+static const char *progname;\n \n /* Current maximum length of directory names in the search path\n    for include files.  (Altered as we get more of them.)  */\n@@ -71,7 +72,7 @@ int no_output;\n \n /* Value of __USER_LABEL_PREFIX__.  Target-dependent, also controlled\n    by -f(no-)leading-underscore.  */\n-const char *user_label_prefix;\n+static const char *user_label_prefix;\n \n /* I/O buffer structure.\n    The `fname' field is nonzero for source files and #include files\n@@ -184,7 +185,7 @@ struct definition {\n      with comma-space between them.\n      The only use of this is that we warn on redefinition\n      if this differs between the old and new definitions.  */\n-  U_CHAR *argnames;\n+  const U_CHAR *argnames;\n };\n \n /* different kinds of things that can appear in the value field\n@@ -304,42 +305,30 @@ struct arglist {\n \n /* Function prototypes.  */\n \n-void do_define\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *));\n-void do_line\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *));\n-void do_include\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *));\n-void do_undef\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *));\n-void do_if\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *));\n-void do_xifdef\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *));\n-void do_else\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *));\n-void do_elif\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *));\n-void do_endif\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *));\n-\n-struct hashnode *install PARAMS ((const U_CHAR *, int, enum node_type, int));\n-struct hashnode *lookup  PARAMS ((const U_CHAR *, int, int));\n-int hashf\t\t PARAMS ((const U_CHAR *, int, int));\n-int compare_defs\t PARAMS ((DEFINITION *, DEFINITION *));\n-int comp_def_part\t PARAMS ((int, U_CHAR *, int, U_CHAR *, int, int));\n-void delete_macro\t PARAMS ((HASHNODE *));\n+static void do_define\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *));\n+static void do_line\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *));\n+static void do_include\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *));\n+static void do_undef\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *));\n+static void do_if\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *));\n+static void do_xifdef\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *));\n+static void do_else\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *));\n+static void do_elif\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *));\n+static void do_endif\tPARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *));\n+\n+static struct hashnode *install PARAMS ((const U_CHAR *, int, enum node_type, int));\n+static int hashf\t\t PARAMS ((const U_CHAR *, int, int));\n+static int compare_defs\t PARAMS ((DEFINITION *, DEFINITION *));\n+static int comp_def_part\t PARAMS ((int, const U_CHAR *, int,\n+\t\t\t\t\t  const U_CHAR *, int, int));\n+static void delete_macro\t PARAMS ((HASHNODE *));\n \n /* First arg to v_message.  */\n enum msgtype { WARNING = 0, ERROR, FATAL };\n-void v_message\t\t PARAMS ((enum msgtype mtype, int line,\n-\t\t\t\t  const char *msgid, va_list ap))\n+static void v_message\t\t PARAMS ((enum msgtype mtype, int line,\n+\t\t\t\t\t  const char *msgid, va_list ap))\n      ATTRIBUTE_PRINTF (3, 0);\n \n-void warning\t\t PARAMS ((const char *msgid, ...)) ATTRIBUTE_PRINTF_1;\n-void error\t\t PARAMS ((const char *msgid, ...)) ATTRIBUTE_PRINTF_1;\n-void fatal\t\t PARAMS ((const char *msgid, ...)) ATTRIBUTE_NORETURN\n-     ATTRIBUTE_PRINTF_1;\n-void error_with_line\t PARAMS ((int, const char *msgid, ...))\n-     ATTRIBUTE_PRINTF_2;\n-void error_from_errno\t PARAMS ((const char *msgid));\n-\n-void perror_with_name \t PARAMS ((const char *msgid));\n-void pfatal_with_name \t PARAMS ((const char *msgid)) ATTRIBUTE_NORETURN;\n-void fancy_abort \t PARAMS ((int, const char *)) ATTRIBUTE_NORETURN;\n-\n-int line_for_error\t PARAMS ((int));\n+static int line_for_error\t PARAMS ((int));\n \n /* We know perfectly well which file this is, so we don't need to\n    use __FILE__.  */\n@@ -350,39 +339,39 @@ int line_for_error\t PARAMS ((int));\n #define abort() fancy_abort(__LINE__, 0);\n #endif\n \n-void macroexpand \t\tPARAMS ((HASHNODE *, FILE_BUF *));\n-void special_symbol\t\tPARAMS ((HASHNODE *, FILE_BUF *));\n-void dump_all_macros \t\tPARAMS ((void));\n-void dump_defn_1\t\tPARAMS ((U_CHAR *, int, int));\n-void dump_arg_n\t\t\tPARAMS ((DEFINITION *, int));\n-void conditional_skip \t\tPARAMS ((FILE_BUF *, int, enum node_type));\n-void skip_if_group \t\tPARAMS ((FILE_BUF *, int));\n-void output_line_command \tPARAMS ((FILE_BUF *, FILE_BUF *,\n+static void macroexpand \tPARAMS ((HASHNODE *, FILE_BUF *));\n+static void special_symbol\tPARAMS ((HASHNODE *, FILE_BUF *));\n+static void dump_all_macros \tPARAMS ((void));\n+static void dump_defn_1\t\tPARAMS ((const U_CHAR *, int, int));\n+static void dump_arg_n\t\tPARAMS ((DEFINITION *, int));\n+static void conditional_skip \tPARAMS ((FILE_BUF *, int, enum node_type));\n+static void skip_if_group \tPARAMS ((FILE_BUF *, int));\n+static void output_line_command PARAMS ((FILE_BUF *, FILE_BUF *,\n \t\t\t\t\t int, enum file_change_code));\n \n-int eval_if_expression\t\tPARAMS ((U_CHAR *, int));\n-int parse_c_expression\t\tPARAMS ((char *));  /* in tradcif.y */\n-\n-void initialize_char_syntax\tPARAMS ((void));\n-void initialize_builtins\tPARAMS ((void));\n-void make_definition\t\tPARAMS ((U_CHAR *));\n-void make_undef\t\t\tPARAMS ((U_CHAR *));\n-\n-void grow_outbuf \tPARAMS ((FILE_BUF *, int));\n-int handle_directive \tPARAMS ((FILE_BUF *, FILE_BUF *));\n-void finclude\t\tPARAMS ((int, const char *, FILE_BUF *));\n-void deps_output\tPARAMS ((const char *, int));\n-void rescan\t\tPARAMS ((FILE_BUF *, int));\n-void newline_fix\tPARAMS ((U_CHAR *));\n-void name_newline_fix\tPARAMS ((U_CHAR *));\n-U_CHAR *macarg1 \tPARAMS ((U_CHAR *, U_CHAR *, int *, int *, int *));\n-const char *macarg\tPARAMS ((struct argdata *));\n-int discard_comments\tPARAMS ((U_CHAR *, int, int));\n-int file_size_and_mode\tPARAMS ((int, int *, long *));\n-\n-U_CHAR *skip_to_end_of_comment PARAMS ((FILE_BUF *, int *));\n-U_CHAR *skip_quoted_string     PARAMS ((U_CHAR *, U_CHAR *, int,\n-\t\t\t\t\tint *, int *, int *));\n+static int eval_if_expression\tPARAMS ((const U_CHAR *, int));\n+\n+static void initialize_char_syntax\tPARAMS ((void));\n+static void initialize_builtins\tPARAMS ((void));\n+static void make_definition\tPARAMS ((const U_CHAR *));\n+static void make_undef\t\tPARAMS ((U_CHAR *));\n+\n+static void grow_outbuf \tPARAMS ((FILE_BUF *, int));\n+static int handle_directive \tPARAMS ((FILE_BUF *, FILE_BUF *));\n+static void finclude\t\tPARAMS ((int, const char *, FILE_BUF *));\n+static void deps_output\t\tPARAMS ((const char *, int));\n+static void rescan\t\tPARAMS ((FILE_BUF *, int));\n+static void newline_fix\t\tPARAMS ((U_CHAR *));\n+static void name_newline_fix\tPARAMS ((U_CHAR *));\n+static U_CHAR *macarg1\t\tPARAMS ((U_CHAR *, const U_CHAR *, int *,\n+\t\t\t\t\t int *, int *));\n+static const char *macarg\tPARAMS ((struct argdata *));\n+static int discard_comments\tPARAMS ((U_CHAR *, int, int));\n+static int file_size_and_mode\tPARAMS ((int, int *, long *));\n+\n+static U_CHAR *skip_to_end_of_comment PARAMS ((FILE_BUF *, int *));\n+static U_CHAR *skip_quoted_string     PARAMS ((const U_CHAR *, const U_CHAR *,\n+\t\t\t\t\t       int, int *, int *, int *));\n \n int main\t\tPARAMS ((int, char **));\n \n@@ -419,9 +408,9 @@ U_CHAR is_space[256];\n   \n int errors = 0;\t\t\t/* Error counter for exit code */\n \n-FILE_BUF expand_to_temp_buffer PARAMS ((U_CHAR *, U_CHAR *, int));\n-DEFINITION *collect_expansion  PARAMS ((U_CHAR *, U_CHAR *, int,\n-\t\t\t\t\tstruct arglist *));\n+static FILE_BUF expand_to_temp_buffer PARAMS ((const U_CHAR *, const U_CHAR *, int));\n+static DEFINITION *collect_expansion  PARAMS ((U_CHAR *, U_CHAR *, int,\n+\t\t\t\t\t       struct arglist *));\n \n /* Stack of conditionals currently in progress\n    (including both successful and failing conditionals).  */\n@@ -713,7 +702,7 @@ main (argc, argv)\n   /* Do defines specified with -D and undefines specified with -U.  */\n   for (i = 1; i < argc; i++)\n     if (pend_defs[i])\n-      make_definition ((U_CHAR *)pend_defs[i]);\n+      make_definition ((const U_CHAR *)pend_defs[i]);\n     else if (pend_undefs[i])\n       make_undef ((U_CHAR *)pend_undefs[i]);\n \n@@ -971,7 +960,7 @@ main (argc, argv)\n    Potentially-embarrassing characters are / and *\n    (because a backslash-newline inside a comment delimiter\n    would cause it not to be recognized).  */\n-void\n+static void\n newline_fix (bp)\n      U_CHAR *bp;\n {\n@@ -1006,7 +995,7 @@ newline_fix (bp)\n \n /* Like newline_fix but for use within a directive-name.\n    Move any backslash-newlines up past any following symbol constituents.  */\n-void\n+static void\n name_newline_fix (bp)\n      U_CHAR *bp;\n {\n@@ -1075,7 +1064,7 @@ name_newline_fix (bp)\n  * explicitly, and before RECACHE, since RECACHE uses OBP.\n  */\n \n-void\n+static void\n rescan (op, output_marks)\n      FILE_BUF *op;\n      int output_marks;\n@@ -1711,9 +1700,9 @@ do { ip = &instack[indepth];\t\t\\\n  * OUTPUT_MARKS is 1 for macroexpanding a macro argument separately\n  * before substitution; it is 0 for other uses.\n  */\n-FILE_BUF\n+static FILE_BUF\n expand_to_temp_buffer (buf, limit, output_marks)\n-     U_CHAR *buf, *limit;\n+     const U_CHAR *buf, *limit;\n      int output_marks;\n {\n   register FILE_BUF *ip;\n@@ -1729,7 +1718,7 @@ expand_to_temp_buffer (buf, limit, output_marks)\n \n   buf1 = (U_CHAR *) alloca (length + 1);\n   {\n-    register U_CHAR *p1 = buf;\n+    register const U_CHAR *p1 = buf;\n     register U_CHAR *p2 = buf1;\n \n     while (p1 != limit)\n@@ -1789,7 +1778,7 @@ expand_to_temp_buffer (buf, limit, output_marks)\n  * Otherwise, returns zero, without advancing the input pointer.\n  */\n \n-int\n+static int\n handle_directive (ip, op)\n      FILE_BUF *ip, *op;\n {\n@@ -1851,7 +1840,7 @@ handle_directive (ip, op)\n    */\n   for (kt = directive_table; kt->length > 0; kt++) {\n     if (kt->length == ident_length\n-\t&& !strncmp (kt->name, (char *)ident, ident_length)) {\n+\t&& !strncmp (kt->name, (const char *)ident, ident_length)) {\n       register U_CHAR *buf;\n       register U_CHAR *limit = ip->buf + ip->length;\n       int unterminated = 0;\n@@ -1982,7 +1971,7 @@ handle_directive (ip, op)\n \t  case '\\'':\n \t  case '\\\"':\n \t    {\n-\t      register U_CHAR *bp1\n+\t      register const U_CHAR *bp1\n \t\t= skip_quoted_string (xp - 1, limit, ip->lineno, 0, 0, 0);\n \t      while (xp != bp1)\n \t\t*cp++ = *xp++;\n@@ -2036,12 +2025,12 @@ monthnames[] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n  * expand things like __FILE__.  Place the expansion into the output\n  * buffer *without* rescanning.\n  */\n-void\n+static void\n special_symbol (hp, op)\n      HASHNODE *hp;\n      FILE_BUF *op;\n {\n-  char *buf = 0;\n+  const char *buf;\n   time_t t;\n   int i, len;\n   int true_indepth;\n@@ -2070,56 +2059,70 @@ special_symbol (hp, op)\n \n       if (string)\n \t{\n-\t  buf = (char *) alloca (3 + strlen (string));\n-\t  sprintf (buf, \"\\\"%s\\\"\", string);\n+\t  char *tmp = (char *) alloca (3 + strlen (string));\n+\t  sprintf (tmp, \"\\\"%s\\\"\", string);\n+\t  buf = tmp;\n \t}\n       else\n-\tbuf = (char *) \"\";\n+\tbuf = \"\";\n \n       break;\n     }\n \n   case T_INCLUDE_LEVEL:\n-    true_indepth = 0;\n-    for (i = indepth; i >= 0; i--)\n-      if (instack[i].fname != NULL)\n-        true_indepth++;\n-\n-    buf = (char *) alloca (8);\t/* Eigth bytes ought to be more than enough */\n-    sprintf (buf, \"%d\", true_indepth - 1);\n+    {\n+      char *tmp = (char *) alloca (8);\t/* Eigth bytes ought to be more than enough */\n+      true_indepth = 0;\n+      for (i = indepth; i >= 0; i--)\n+\tif (instack[i].fname != NULL)\n+\t  true_indepth++;\n+\n+    sprintf (tmp, \"%d\", true_indepth - 1);\n+    buf = tmp;\n     break;\n+    }\n \n   case T_VERSION:\n-    buf = (char *) alloca (3 + strlen (version_string));\n-    sprintf (buf, \"\\\"%s\\\"\", version_string);\n-    break;\n+    {\n+      char *tmp = (char *) alloca (3 + strlen (version_string));\n+      sprintf (tmp, \"\\\"%s\\\"\", version_string);\n+      buf = tmp;\n+      break;\n+    }\n \n   case T_CONST:\n-    buf = (char *) hp->value.cpval;\n+    buf = hp->value.cpval;\n     break;\n \n   case T_SPECLINE:\n-    buf = (char *) alloca (10);\n-    sprintf (buf, \"%d\", ip->lineno);\n-    break;\n+    {\n+      char *tmp = (char *) alloca (10);\n+      sprintf (tmp, \"%d\", ip->lineno);\n+      buf = tmp;\n+      break;\n+    }\n \n   case T_DATE:\n   case T_TIME:\n-    if (timebuf == NULL) {\n-      t = time (0);\n-      timebuf = localtime (&t);\n+    {\n+      char *tmp = (char *) alloca (20);\n+\n+      if (timebuf == NULL) {\n+\tt = time (0);\n+\ttimebuf = localtime (&t);\n+      }\n+      if (hp->type == T_DATE)\n+\tsprintf (tmp, \"\\\"%s %2d %4d\\\"\", monthnames[timebuf->tm_mon],\n+\t\t timebuf->tm_mday, timebuf->tm_year + 1900);\n+      else\n+\tsprintf (tmp, \"\\\"%02d:%02d:%02d\\\"\", timebuf->tm_hour, timebuf->tm_min,\n+\t\t timebuf->tm_sec);\n+      buf = tmp;\n+      break;\n     }\n-    buf = (char *) alloca (20);\n-    if (hp->type == T_DATE)\n-      sprintf (buf, \"\\\"%s %2d %4d\\\"\", monthnames[timebuf->tm_mon],\n-\t      timebuf->tm_mday, timebuf->tm_year + 1900);\n-    else\n-      sprintf (buf, \"\\\"%02d:%02d:%02d\\\"\", timebuf->tm_hour, timebuf->tm_min,\n-\t      timebuf->tm_sec);\n-    break;\n \n   case T_SPEC_DEFINED:\n-    buf = (char *) \" 0 \";\t\t/* Assume symbol is not defined */\n+    buf = \" 0 \";\t\t\t/* Assume symbol is not defined */\n     ip = &instack[indepth];\n     SKIP_WHITE_SPACE (ip->bufp);\n     if (*ip->bufp == '(') {\n@@ -2131,7 +2134,7 @@ special_symbol (hp, op)\n     if (!is_idstart[*ip->bufp])\n       goto oops;\n     if (lookup (ip->bufp, -1, -1))\n-      buf = (char *) \" 1 \";\n+      buf = \" 1 \";\n     while (is_idchar[*ip->bufp])\n       ++ip->bufp;\n     SKIP_WHITE_SPACE (ip->bufp);\n@@ -2164,7 +2167,7 @@ special_symbol (hp, op)\n  * Process include file by reading it in and calling rescan.\n  * Expects to see \"fname\" or <fname> on the input.\n  */\n-void\n+static void\n do_include (buf, limit, op, keyword)\n      U_CHAR *buf, *limit;\n      FILE_BUF *op;\n@@ -2272,7 +2275,7 @@ do_include (buf, limit, op, keyword)\n   /* If specified file name is absolute, just open it.  */\n \n   if (*fbeg == '/') {\n-    strncpy (fname, (char *)fbeg, flen);\n+    strncpy (fname, (const char *)fbeg, flen);\n     fname[flen] = 0;\n     f = open (fname, O_RDONLY, 0666);\n   } else {\n@@ -2287,14 +2290,14 @@ do_include (buf, limit, op, keyword)\n       } else {\n \tfname[0] = 0;\n       }\n-      strncat (fname, (char *)fbeg, flen);\n+      strncat (fname, (const char *)fbeg, flen);\n       if ((f = open (fname, O_RDONLY, 0666)) >= 0)\n \tbreak;\n     }\n   }\n \n   if (f < 0) {\n-    strncpy (fname, (char *)fbeg, flen);\n+    strncpy (fname, (const char *)fbeg, flen);\n     fname[flen] = 0;\n     error_from_errno (fname);\n \n@@ -2360,7 +2363,7 @@ do_include (buf, limit, op, keyword)\n /* Process the contents of include file FNAME, already open on descriptor F,\n    with output to OP.  */\n \n-void\n+static void\n finclude (f, fname, op)\n      int f;\n      const char *fname;\n@@ -2455,7 +2458,7 @@ BUF points to the contents of the #define command, as a continguous string.\n LIMIT points to the first character past the end of the definition.\n KEYWORD is the keyword-table entry for #define.  */\n \n-void\n+static void\n do_define (buf, limit, op, keyword)\n      U_CHAR *buf, *limit;\n      FILE_BUF *op ATTRIBUTE_UNUSED;\n@@ -2489,7 +2492,7 @@ do_define (buf, limit, op, keyword)\n     msg[sym_length] = 0;\n     error (\"invalid macro name `%s'\", msg);\n   } else {\n-    if (! strncmp ((char *)symname, \"defined\", 7) && sym_length == 7)\n+    if (! strncmp ((const char *)symname, \"defined\", 7) && sym_length == 7)\n       error (\"defining `defined' as a macro\");\n   }\n \n@@ -2547,27 +2550,30 @@ do_define (buf, limit, op, keyword)\n     /* Now set defn->argnames to the result of concatenating\n        the argument names in reverse order\n        with comma-space between them.  */\n-    defn->argnames = (U_CHAR *) xmalloc (arglengths + 1);\n     {\n       struct arglist *temp;\n       int i = 0;\n+      U_CHAR *tmp = (U_CHAR *) xmalloc (arglengths + 1);\n+\n       for (temp = arg_ptrs; temp; temp = temp->next) {\n-\tmemcpy (&defn->argnames[i], temp->name, temp->length);\n+\tmemcpy (&tmp[i], temp->name, temp->length);\n \ti += temp->length;\n \tif (temp->next != 0) {\n-\t  defn->argnames[i++] = ',';\n-\t  defn->argnames[i++] = ' ';\n+\t  tmp[i++] = ',';\n+\t  tmp[i++] = ' ';\n \t}\n       }\n-      defn->argnames[i] = 0;\n+      tmp[i] = 0;\n+      defn->argnames = tmp;\n+      \n     }\n   } else {\n     /* simple expansion or empty definition; skip leading whitespace */\n     while (is_hor_space[*bp])\n       ++bp;\n     /* now everything from bp before limit is the definition. */\n     defn = collect_expansion (bp, limit, -1, 0);\n-    defn->argnames = (U_CHAR *) \"\";\n+    defn->argnames = (const U_CHAR *) \"\";\n   }\n \n   hashcode = hashf (symname, sym_length, HASHSIZE);\n@@ -2591,7 +2597,7 @@ do_define (buf, limit, op, keyword)\n /*\n  * return zero if two DEFINITIONs are isomorphic\n  */\n-int\n+static int\n compare_defs (d1, d2)\n      DEFINITION *d1, *d2;\n {\n@@ -2602,12 +2608,12 @@ compare_defs (d1, d2)\n \n   if (d1->nargs != d2->nargs)\n     return 1;\n-  if (strcmp ((char *)d1->argnames, (char *)d2->argnames))\n+  if (strcmp ((const char *)d1->argnames, (const char *)d2->argnames))\n     return 1;\n   for (a1 = d1->pattern, a2 = d2->pattern; a1 && a2;\n        a1 = a1->next, a2 = a2->next) {\n     if (!((a1->nchars == a2->nchars\n-\t   && ! strncmp ((char *)p1, (char *)p2, a1->nchars))\n+\t   && ! strncmp ((const char *)p1, (const char *)p2, a1->nchars))\n \t  || ! comp_def_part (first, p1, a1->nchars, p2, a2->nchars, 0))\n \t|| a1->argno != a2->argno\n \t|| a1->stringify != a2->stringify\n@@ -2634,15 +2640,15 @@ compare_defs (d1, d2)\n     so ignore leading whitespace entirely.\n    LAST means these parts are the last of a macro definition;\n     so ignore trailing whitespace entirely.  */\n-int\n+static int\n comp_def_part (first, beg1, len1, beg2, len2, last)\n      int first;\n-     U_CHAR *beg1, *beg2;\n+     const U_CHAR *beg1, *beg2;\n      int len1, len2;\n      int last;\n {\n-  register U_CHAR *end1 = beg1 + len1;\n-  register U_CHAR *end2 = beg2 + len2;\n+  register const U_CHAR *end1 = beg1 + len1;\n+  register const U_CHAR *end2 = beg2 + len2;\n   if (first) {\n     while (beg1 != end1 && is_space[*beg1]) beg1++;\n     while (beg2 != end2 && is_space[*beg2]) beg2++;\n@@ -2683,7 +2689,7 @@ from the argument.  */\n    If there is no trailing whitespace, a Newline Space is added at the end\n    to prevent concatenation that would be contrary to the standard.  */\n \n-DEFINITION *\n+static DEFINITION *\n collect_expansion (buf, end, nargs, arglist)\n      U_CHAR *buf, *end;\n      int nargs;\n@@ -2797,7 +2803,8 @@ collect_expansion (buf, end, nargs, arglist)\n \n \t  if (arg->name[0] == c\n \t      && arg->length == id_len\n-\t      && strncmp ((char *)arg->name, (char *)id_beg, id_len) == 0) {\n+\t      && strncmp ((const char *)arg->name,\n+\t\t\t  (const char *)id_beg, id_len) == 0) {\n \t    /* make a pat node for this arg and append it to the end of\n \t       the pat list */\n \t    tpat = (struct reflist *) xmalloc (sizeof (struct reflist));\n@@ -2862,7 +2869,7 @@ collect_expansion (buf, end, nargs, arglist)\n  * in its very own hash table.\n  */\n #define FNAME_HASHSIZE 37\n-void\n+static void\n do_line (buf, limit, op, keyword)\n      U_CHAR *buf, *limit;\n      FILE_BUF *op;\n@@ -2889,7 +2896,7 @@ do_line (buf, limit, op, keyword)\n   /* The Newline at the end of this line remains to be processed.\n      To put the next line at the specified line number,\n      we must store a line number now that is one less.  */\n-  new_lineno = atoi ((char *)bp) - 1;\n+  new_lineno = atoi ((const char *)bp) - 1;\n \n   /* skip over the line number.  */\n   while (isdigit (*bp))\n@@ -2945,7 +2952,7 @@ do_line (buf, limit, op, keyword)\n       &fname_table[hashf (fname, fname_length, FNAME_HASHSIZE)];\n     for (hp = *hash_bucket; hp != NULL; hp = hp->next)\n       if (hp->length == fname_length &&\n-\t  strncmp (hp->value.cpval, (char *)fname, fname_length) == 0) {\n+\t  strncmp (hp->value.cpval, (const char *)fname, fname_length) == 0) {\n \tip->fname = hp->value.cpval;\n \tbreak;\n       }\n@@ -2975,7 +2982,7 @@ do_line (buf, limit, op, keyword)\n  * according to un*x /lib/cpp, it is not an error to undef\n  * something that has no definitions, so it isn't one here either.\n  */\n-void\n+static void\n do_undef (buf, limit, op, keyword)\n      U_CHAR *buf;\n      U_CHAR *limit ATTRIBUTE_UNUSED;\n@@ -2986,7 +2993,7 @@ do_undef (buf, limit, op, keyword)\n \n   SKIP_WHITE_SPACE (buf);\n \n-  if (! strncmp ((char *)buf, \"defined\", 7) && ! is_idchar[buf[7]])\n+  if (! strncmp ((const char *)buf, \"defined\", 7) && ! is_idchar[buf[7]])\n     warning (\"undefining `defined'\");\n \n   while ((hp = lookup (buf, -1, -1)) != NULL) {\n@@ -3008,7 +3015,7 @@ do_undef (buf, limit, op, keyword)\n  *   5) call conditional_skip to skip til the next #endif (etc.),\n  *      or not, depending on the value from step 3.\n  */\n-void\n+static void\n do_if (buf, limit, op, keyword)\n      U_CHAR *buf, *limit;\n      FILE_BUF *op ATTRIBUTE_UNUSED;\n@@ -3025,7 +3032,7 @@ do_if (buf, limit, op, keyword)\n  * handle a #elif directive by not changing  if_stack  either.\n  * see the comment above do_else.\n  */\n-void\n+static void\n do_elif (buf, limit, op, keyword)\n      U_CHAR *buf, *limit;\n      FILE_BUF *op;\n@@ -3066,9 +3073,9 @@ do_elif (buf, limit, op, keyword)\n  * evaluate a #if expression in BUF, of length LENGTH,\n  * then parse the result as a C expression and return the value as an int.\n  */\n-int\n+static int\n eval_if_expression (buf, length)\n-     U_CHAR *buf;\n+     const U_CHAR *buf;\n      int length;\n {\n   FILE_BUF temp_obuf;\n@@ -3079,7 +3086,7 @@ eval_if_expression (buf, length)\n   temp_obuf = expand_to_temp_buffer (buf, buf + length, 0);\n   delete_macro (save_defined);\t/* clean up special symbol */\n \n-  value = parse_c_expression ((char *)temp_obuf.buf);\n+  value = parse_c_expression ((const char *)temp_obuf.buf);\n \n   free (temp_obuf.buf);\n \n@@ -3091,7 +3098,7 @@ eval_if_expression (buf, length)\n  * then do or don't skip to the #endif/#else/#elif depending\n  * on what directive is actually being processed.\n  */\n-void\n+static void\n do_xifdef (buf, limit, op, keyword)\n      U_CHAR *buf, *limit;\n      FILE_BUF *op ATTRIBUTE_UNUSED;\n@@ -3120,7 +3127,7 @@ do_xifdef (buf, limit, op, keyword)\n /*\n  * push TYPE on stack; then, if SKIP is nonzero, skip ahead.\n  */\n-void\n+static void\n conditional_skip (ip, skip, type)\n      FILE_BUF *ip;\n      int skip;\n@@ -3150,7 +3157,7 @@ conditional_skip (ip, skip, type)\n  * leaves input ptr at the sharp sign found.\n  * If ANY is nonzero, return at next directive of any sort.\n  */\n-void\n+static void\n skip_if_group (ip, any)\n      FILE_BUF *ip;\n      int any;\n@@ -3255,7 +3262,7 @@ skip_if_group (ip, any)\n \n       for (kt = directive_table; kt->length >= 0; kt++) {\n \tIF_STACK_FRAME *temp;\n-\tif (strncmp ((char *)cp, kt->name, kt->length) == 0\n+\tif (strncmp ((const char *)cp, kt->name, kt->length) == 0\n \t    && !is_idchar[cp[kt->length]]) {\n \n \t  /* If we are asked to return on next directive,\n@@ -3317,7 +3324,7 @@ skip_if_group (ip, any)\n  * for missing #endif's etc. will point to the original #if.  It\n  * is possible that something different would be better.\n  */\n-void\n+static void\n do_else (buf, limit, op, keyword)\n      U_CHAR *buf ATTRIBUTE_UNUSED;\n      U_CHAR *limit ATTRIBUTE_UNUSED;\n@@ -3351,7 +3358,7 @@ do_else (buf, limit, op, keyword)\n /*\n  * unstack after #endif command\n  */\n-void\n+static void\n do_endif (buf, limit, op, keyword)\n      U_CHAR *buf ATTRIBUTE_UNUSED;\n      U_CHAR *limit ATTRIBUTE_UNUSED;\n@@ -3375,7 +3382,7 @@ do_endif (buf, limit, op, keyword)\n  * Don't use this routine (or the next one) if bumping the line\n  * counter is not sufficient to deal with newlines in the string.\n  */\n-U_CHAR *\n+static U_CHAR *\n skip_to_end_of_comment (ip, line_counter)\n      register FILE_BUF *ip;\n      int *line_counter;\t\t/* place to remember newlines, or NULL */\n@@ -3438,10 +3445,10 @@ skip_to_end_of_comment (ip, line_counter)\n  *\n  * If EOFP is nonzero, set *EOFP to 1 if the string is unterminated.\n  */\n-U_CHAR *\n+static U_CHAR *\n skip_quoted_string (bp, limit, start_line, count_newlines, backslash_newlines_p, eofp)\n-     register U_CHAR *bp;\n-     register U_CHAR *limit;\n+     register const U_CHAR *bp;\n+     register const U_CHAR *limit;\n      int start_line;\n      int *count_newlines;\n      int *backslash_newlines_p;\n@@ -3482,7 +3489,7 @@ skip_quoted_string (bp, limit, start_line, count_newlines, backslash_newlines_p,\n     } else if (c == match)\n       break;\n   }\n-  return bp;\n+  return (U_CHAR *) bp;\n }\n \f\n /*\n@@ -3493,7 +3500,7 @@ skip_quoted_string (bp, limit, start_line, count_newlines, backslash_newlines_p,\n  * FILE_CHANGE says whether we are entering a file, leaving, or neither.\n  */\n \n-void\n+static void\n output_line_command (ip, op, conditional, file_change)\n      FILE_BUF *ip, *op;\n      int conditional;\n@@ -3547,7 +3554,7 @@ output_line_command (ip, op, conditional, file_change)\n    If macro wants arguments, caller has already verified that\n    an argument list follows; arguments come from the input stack.  */\n \n-void\n+static void\n macroexpand (hp, op)\n      HASHNODE *hp;\n      FILE_BUF *op;\n@@ -3601,8 +3608,8 @@ macroexpand (hp, op)\n \n     /* If we got one arg but it was just whitespace, call that 0 args.  */\n     if (i == 1) {\n-      register U_CHAR *bp = args[0].raw;\n-      register U_CHAR *lim = bp + args[0].raw_length;\n+      register const U_CHAR *bp = args[0].raw;\n+      register const U_CHAR *lim = bp + args[0].raw_length;\n       while (bp != lim && is_space[*bp]) bp++;\n       if (bp == lim)\n \ti = 0;\n@@ -3727,8 +3734,8 @@ macroexpand (hp, op)\n \t    }\n \t  }\n \t} else {\n-\t  U_CHAR *p1 = arg->raw;\n-\t  U_CHAR *l1 = p1 + arg->raw_length;\n+\t  const U_CHAR *p1 = arg->raw;\n+\t  const U_CHAR *l1 = p1 + arg->raw_length;\n \n \t  if (ap->raw_before) {\n \t    while (p1 != l1 && is_space[*p1]) p1++;\n@@ -3746,7 +3753,7 @@ macroexpand (hp, op)\n \t    while (p1 != l1) {\n \t      if (is_space[l1[-1]]) l1--;\n \t      else if (l1[-1] == '-') {\n-\t\tU_CHAR *p2 = l1 - 1;\n+\t\tconst U_CHAR *p2 = l1 - 1;\n \t\t/* If a `-' is preceded by an odd number of newlines then it\n \t\t   and the last newline are a no-reexpansion marker.  */\n \t\twhile (p2 != p1 && p2[-1] == '\\n') p2--;\n@@ -3810,7 +3817,7 @@ macroexpand (hp, op)\n  * Return nonzero to indicate a syntax error.\n  */\n \n-const char *\n+static const char *\n macarg (argptr)\n      register struct argdata *argptr;\n {\n@@ -3898,7 +3905,7 @@ macarg (argptr)\n \n   if (argptr != 0) {\n     FILE_BUF obuf;\n-    register U_CHAR *buf, *lim;\n+    register const U_CHAR *buf, *lim;\n     register int totlen;\n \n     obuf = expand_to_temp_buffer (argptr->raw,\n@@ -3941,10 +3948,10 @@ macarg (argptr)\n    Increment *NEWLINES each time a newline is passed.\n    Set *COMMENTS to 1 if a comment is seen.  */\n \n-U_CHAR *\n+static U_CHAR *\n macarg1 (start, limit, depthptr, newlines, comments)\n      U_CHAR *start;\n-     register U_CHAR *limit;\n+     register const U_CHAR *limit;\n      int *depthptr, *newlines, *comments;\n {\n   register U_CHAR *bp = start;\n@@ -4029,15 +4036,15 @@ macarg1 (start, limit, depthptr, newlines, comments)\n    We assume that that much extra space is available past the end\n    of the string.  */\n \n-int\n+static int\n discard_comments (start, length, newlines)\n      U_CHAR *start;\n      int length;\n      int newlines;\n {\n   register U_CHAR *ibp;\n   register U_CHAR *obp;\n-  register U_CHAR *limit;\n+  register const U_CHAR *limit;\n   register int c;\n \n   /* If we have newlines to duplicate, copy everything\n@@ -4122,7 +4129,7 @@ discard_comments (start, length, newlines)\n \f\n \n /* Core error handling routine.  */\n-void\n+static void\n v_message (mtype, line, msgid, ap)\n      enum msgtype mtype;\n      int line;\n@@ -4275,7 +4282,7 @@ pfatal_with_name (name)\n    If the current level is for a file, we return LINE.\n    But if the current level is not for a file, LINE is meaningless.\n    In that case, we return the lineno of the innermost file.  */\n-int\n+static int\n line_for_error (line)\n      int line;\n {\n@@ -4302,7 +4309,7 @@ line_for_error (line)\n  * should work ok.\n  */\n \n-void\n+static void\n grow_outbuf (obuf, needed)\n      register FILE_BUF *obuf;\n      register int needed;\n@@ -4343,7 +4350,7 @@ grow_outbuf (obuf, needed)\n  *\n  * caller must set the value, if any is desired.\n  */\n-HASHNODE *\n+static HASHNODE *\n install (name, len, type, hash)\n      const U_CHAR *name;\n      int len;\n@@ -4412,7 +4419,7 @@ lookup (name, len, hash)\n   bucket = hashtab[hash];\n   while (bucket) {\n     if (bucket->length == len\n-\t&& strncmp ((char *)bucket->name, (char *)name, len) == 0)\n+\t&& strncmp ((const char *)bucket->name, (const char *)name, len) == 0)\n       return bucket;\n     bucket = bucket->next;\n   }\n@@ -4432,7 +4439,7 @@ lookup (name, len, hash)\n    In any case, this is necessary, because a macro can be #undef'd\n    in the middle of reading the arguments to a call to it.\n    If #undef freed the DEFINITION, that would crash.  */\n-void\n+static void\n delete_macro (hp)\n      HASHNODE *hp;\n {\n@@ -4454,7 +4461,7 @@ delete_macro (hp)\n  * return hash function on name.  must be compatible with the one\n  * computed a step at a time, elsewhere\n  */\n-int\n+static int\n hashf (name, len, hashsize)\n      register const U_CHAR *name;\n      register int len;\n@@ -4470,7 +4477,7 @@ hashf (name, len, hashsize)\n \f\n /* Dump all macro definitions as #defines to stdout.  */\n \n-void\n+static void\n dump_all_macros ()\n {\n   int bucket;\n@@ -4533,20 +4540,20 @@ dump_all_macros ()\n    Output characters START thru LENGTH.\n    Discard newlines outside of strings, thus\n    converting funny-space markers to ordinary spaces.  */\n-void\n+static void\n dump_defn_1 (base, start, length)\n-     U_CHAR *base;\n+     const U_CHAR *base;\n      int start;\n      int length;\n {\n-  U_CHAR *p = base + start;\n-  U_CHAR *limit = base + start + length;\n+  const U_CHAR *p = base + start;\n+  const U_CHAR *limit = base + start + length;\n \n   while (p < limit) {\n     if (*p != '\\n')\n       putchar (*p);\n     else if (*p == '\\\"' || *p =='\\'') {\n-      U_CHAR *p1 = skip_quoted_string (p, limit, 0, 0, 0, 0);\n+      const U_CHAR *p1 = skip_quoted_string (p, limit, 0, 0, 0, 0);\n       fwrite (p, p1 - p, 1, stdout);\n       p = p1 - 1;\n     }\n@@ -4557,14 +4564,14 @@ dump_defn_1 (base, start, length)\n /* Print the name of argument number ARGNUM of macro definition DEFN.\n    Recall that DEFN->argnames contains all the arg names\n    concatenated in reverse order with comma-space in between.  */\n-void\n+static void\n dump_arg_n (defn, argnum)\n      DEFINITION *defn;\n      int argnum;\n {\n-  register U_CHAR *p = defn->argnames;\n+  register const U_CHAR *p = defn->argnames;\n   while (argnum + 1 < defn->nargs) {\n-    p = (U_CHAR *) strchr ((char *)p, ' ') + 1;\n+    p = (const U_CHAR *) strchr ((const char *)p, ' ') + 1;\n     argnum++;\n   }\n \n@@ -4575,7 +4582,7 @@ dump_arg_n (defn, argnum)\n }\n \f\n /* Initialize syntactic classifications of characters.  */\n-void\n+static void\n initialize_char_syntax ()\n {\n   register int i;\n@@ -4618,7 +4625,7 @@ initialize_char_syntax ()\n  install(DSC(name), type, -1);\n #define install_value(name, val) \\\n  hp = install(DSC(name), T_CONST, -1); hp->value.cpval = val;\n-void\n+static void\n initialize_builtins ()\n {\n   HASHNODE *hp;\n@@ -4656,16 +4663,17 @@ initialize_builtins ()\n  * If STR has anything after the identifier, then it should\n  * be identifier-space-definition.\n  */\n-void\n+static void\n make_definition (str)\n-     U_CHAR *str;\n+     const U_CHAR *str;\n {\n   FILE_BUF *ip;\n   struct directive *kt;\n-  U_CHAR *buf, *p;\n-  size_t len = strlen ((char *)str);\n+  U_CHAR *buf;\n+  const U_CHAR *p;\n+  size_t len = strlen ((const char *)str);\n \n-  p = (U_CHAR *) strchr ((char *)str, '=');\n+  p = (const U_CHAR *) strchr ((const char *)str, '=');\n   if (p == NULL) {\n     /* Change -DFOO into #define FOO 1 */\n     buf = (U_CHAR *) alloca (len + 3);\n@@ -4698,7 +4706,7 @@ make_definition (str)\n }\n \n /* JF, this does the work for the -U option */\n-void\n+static void\n make_undef (str)\n      U_CHAR *str;\n {\n@@ -4709,7 +4717,7 @@ make_undef (str)\n   ip->fname = \"*undef*\";\n \n   ip->buf = ip->bufp = str;\n-  ip->length = strlen ((char *)str);\n+  ip->length = strlen ((const char *)str);\n   ip->lineno = 1;\n   ip->macro = 0;\n   ip->free_ptr = 0;\n@@ -4726,7 +4734,7 @@ make_undef (str)\n    STRING points to the text to be output.\n    SIZE is the number of bytes, or 0 meaning output until a null.\n    If SIZE is nonzero, we break the line first, if it is long enough.  */\n-void\n+static void\n deps_output (string, size)\n      const char *string;\n      int size;\n@@ -4757,7 +4765,7 @@ deps_output (string, size)\n /* Get the file-mode and data size of the file open on FD\n    and store them in *MODE_POINTER and *SIZE_POINTER.  */\n \n-int\n+static int\n file_size_and_mode (fd, mode_pointer, size_pointer)\n      int fd;\n      int *mode_pointer;"}, {"sha": "023e642e1fa3de70fbf2f079f80057531872359b", "filename": "gcc/tradcpp.h", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a8ad417906348bc502b75cabced1e69a930eef0/gcc%2Ftradcpp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a8ad417906348bc502b75cabced1e69a930eef0/gcc%2Ftradcpp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftradcpp.h?ref=0a8ad417906348bc502b75cabced1e69a930eef0", "patch": "@@ -0,0 +1,41 @@\n+/* C Compatible Compiler Preprocessor (CCCP)\n+Copyright (C) 1986, 1987, 1989, 2000 Free Software Foundation, Inc.\n+                    Written by Paul Rubin, June 1986\n+\t\t    Adapted to ANSI C, Richard Stallman, Jan 1987\n+\t\t    Dusted off, polished, and adapted for use as traditional\n+\t\t    preprocessor only, Zack Weinberg, Jul 2000\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n+\n+#ifndef _TRADCPP_H_\n+#define _TRADCPP_H_\n+\n+extern void error PARAMS ((const char *msgid, ...)) ATTRIBUTE_PRINTF_1;\n+extern void warning PARAMS ((const char *msgid, ...)) ATTRIBUTE_PRINTF_1;\n+extern void fatal PARAMS ((const char *msgid, ...)) ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n+extern void error_with_line PARAMS ((int, const char *msgid, ...)) ATTRIBUTE_PRINTF_2;\n+extern void error_from_errno PARAMS ((const char *msgid));\n+\n+extern void perror_with_name PARAMS ((const char *msgid));\n+extern void pfatal_with_name PARAMS ((const char *msgid)) ATTRIBUTE_NORETURN;\n+extern void fancy_abort PARAMS ((int, const char *)) ATTRIBUTE_NORETURN;\n+\n+extern struct hashnode *lookup PARAMS ((const unsigned char *, int, int));\n+extern int parse_c_expression PARAMS ((const char *));  /* in tradcif.y */\n+\n+/* some external tables of character types */\n+extern unsigned char is_idstart[], is_idchar[];\n+\n+#endif /* ! _TRADCPP_H_ */"}]}