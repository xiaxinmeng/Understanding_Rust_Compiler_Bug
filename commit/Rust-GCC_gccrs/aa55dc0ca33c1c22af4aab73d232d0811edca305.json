{"sha": "aa55dc0ca33c1c22af4aab73d232d0811edca305", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE1NWRjMGNhMzNjMWMyMmFmNGFhYjczZDIzMmQwODExZWRjYTMwNQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2016-11-02T15:00:48Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2016-11-02T15:00:48Z"}, "message": "gimple-ssa-store-merging.c: Include gimplify-me.h.\n\n2016-11-02  Richard Biener  <rguenther@suse.de>\n\n\t* gimple-ssa-store-merging.c: Include gimplify-me.h.\n\t(imm_store_chain_info::output_merged_stores): Force base_addr\n\tto be proper GIMPLE for a MEM_REF address.\n\t(pass_store_merging::execute): Restrict negative bitpos\n\thandling to non-MEM_REF bases.  Remove TREE_THIS_VOLATILE\n\tcheck.  Take into account non-NULL_TREE offset if the base\n\tis already addressable.\n\n\t* gcc.dg/store_merging_8.c: New testcase.\n\nFrom-SVN: r241796", "tree": {"sha": "c0174797d5ae4269718454c3d3228a775255464b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0174797d5ae4269718454c3d3228a775255464b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa55dc0ca33c1c22af4aab73d232d0811edca305", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa55dc0ca33c1c22af4aab73d232d0811edca305", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa55dc0ca33c1c22af4aab73d232d0811edca305", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa55dc0ca33c1c22af4aab73d232d0811edca305/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3df19fa0d40019eff5060e31abd6add22ac1df4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3df19fa0d40019eff5060e31abd6add22ac1df4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3df19fa0d40019eff5060e31abd6add22ac1df4b"}], "stats": {"total": 93, "additions": 84, "deletions": 9}, "files": [{"sha": "241ff78d55593e15f375a4ef4157318a07056400", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa55dc0ca33c1c22af4aab73d232d0811edca305/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa55dc0ca33c1c22af4aab73d232d0811edca305/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aa55dc0ca33c1c22af4aab73d232d0811edca305", "patch": "@@ -1,3 +1,13 @@\n+2016-11-02  Richard Biener  <rguenther@suse.de>\n+\n+\t* gimple-ssa-store-merging.c: Include gimplify-me.h.\n+\t(imm_store_chain_info::output_merged_stores): Force base_addr\n+\tto be proper GIMPLE for a MEM_REF address.\n+\t(pass_store_merging::execute): Restrict negative bitpos\n+\thandling to non-MEM_REF bases.  Remove TREE_THIS_VOLATILE\n+\tcheck.  Take into account non-NULL_TREE offset if the base\n+\tis already addressable.\n+\n 2016-11-26  Wilco Dijkstra  <wdijkstr@arm.com>\n \n \t* config/aarch64/aarch64-simd.md (aarch64_crypto_sha1hv4si):"}, {"sha": "1bca4a137583dc0a66cec4196bbcfb646cae30dd", "filename": "gcc/gimple-ssa-store-merging.c", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa55dc0ca33c1c22af4aab73d232d0811edca305/gcc%2Fgimple-ssa-store-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa55dc0ca33c1c22af4aab73d232d0811edca305/gcc%2Fgimple-ssa-store-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.c?ref=aa55dc0ca33c1c22af4aab73d232d0811edca305", "patch": "@@ -125,6 +125,7 @@\n #include \"tree-cfg.h\"\n #include \"tree-eh.h\"\n #include \"target.h\"\n+#include \"gimplify-me.h\"\n \n /* The maximum size (in bits) of the stores this pass should generate.  */\n #define MAX_STORE_BITSIZE (BITS_PER_WORD)\n@@ -1127,6 +1128,8 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n   unsigned int i;\n   bool fail = false;\n \n+  tree addr = force_gimple_operand_1 (unshare_expr (base_addr), &seq,\n+\t\t\t\t      is_gimple_mem_ref_addr, NULL_TREE);\n   FOR_EACH_VEC_ELT (split_stores, i, split_store)\n     {\n       unsigned HOST_WIDE_INT try_size = split_store->size;\n@@ -1137,7 +1140,7 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n \n       tree int_type = build_nonstandard_integer_type (try_size, UNSIGNED);\n       int_type = build_aligned_type (int_type, align);\n-      tree dest = fold_build2 (MEM_REF, int_type, base_addr,\n+      tree dest = fold_build2 (MEM_REF, int_type, addr,\n \t\t\t       build_int_cst (offset_type, try_pos));\n \n       tree src = native_interpret_expr (int_type,\n@@ -1366,15 +1369,10 @@ pass_store_merging::execute (function *fun)\n \t\t\t\t       &unsignedp, &reversep, &volatilep);\n \t      /* As a future enhancement we could handle stores with the same\n \t\t base and offset.  */\n-\t      bool invalid = offset || reversep || bitpos < 0\n+\t      bool invalid = reversep\n \t\t\t     || ((bitsize > MAX_BITSIZE_MODE_ANY_INT)\n \t\t\t\t  && (TREE_CODE (rhs) != INTEGER_CST))\n-\t\t\t     || !rhs_valid_for_store_merging_p (rhs)\n-\t\t/* An access may not be volatile itself but base_addr may be\n-\t\t   a volatile decl i.e. MEM[&volatile-decl].  The hashing for\n-\t\t   tree_operand_hash won't consider such stores equal to each\n-\t\t   other so we can't track chains on them.  */\n-\t\t\t     || TREE_THIS_VOLATILE (base_addr);\n+\t\t\t     || !rhs_valid_for_store_merging_p (rhs);\n \n \t      /* We do not want to rewrite TARGET_MEM_REFs.  */\n \t      if (TREE_CODE (base_addr) == TARGET_MEM_REF)\n@@ -1398,7 +1396,32 @@ pass_store_merging::execute (function *fun)\n \t      /* get_inner_reference returns the base object, get at its\n \t         address now.  */\n \t      else\n-\t\tbase_addr = build_fold_addr_expr (base_addr);\n+\t\t{\n+\t\t  if (bitpos < 0)\n+\t\t    invalid = true;\n+\t\t  base_addr = build_fold_addr_expr (base_addr);\n+\t\t}\n+\n+\t      if (! invalid\n+\t\t  && offset != NULL_TREE)\n+\t\t{\n+\t\t  /* If the access is variable offset then a base\n+\t\t     decl has to be address-taken to be able to\n+\t\t     emit pointer-based stores to it.\n+\t\t     ???  We might be able to get away with\n+\t\t     re-using the original base up to the first\n+\t\t     variable part and then wrapping that inside\n+\t\t     a BIT_FIELD_REF.  */\n+\t\t  tree base = get_base_address (base_addr);\n+\t\t  if (! base\n+\t\t      || (DECL_P (base)\n+\t\t\t  && ! TREE_ADDRESSABLE (base)))\n+\t\t    invalid = true;\n+\t\t  else\n+\t\t    base_addr = build2 (POINTER_PLUS_EXPR,\n+\t\t\t\t\tTREE_TYPE (base_addr),\n+\t\t\t\t\tbase_addr, offset);\n+\t\t}\n \n \t      struct imm_store_chain_info **chain_info\n \t\t= m_stores.get (base_addr);"}, {"sha": "6ca1e69a0974defb5fb3fb6ec753d24f84870abf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa55dc0ca33c1c22af4aab73d232d0811edca305/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa55dc0ca33c1c22af4aab73d232d0811edca305/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=aa55dc0ca33c1c22af4aab73d232d0811edca305", "patch": "@@ -1,3 +1,7 @@\n+2016-11-02  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/store_merging_8.c: New testcase.\n+\n 2016-11-02  Fritz O. Reese <fritzoreese@gmail.com>\n \n \t* gfortran.dg/warn_argument_mismatch_1.f90: New test."}, {"sha": "15e80c7d9533c40f0159241eb6fd1953d017fbe9", "filename": "gcc/testsuite/gcc.dg/store_merging_8.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa55dc0ca33c1c22af4aab73d232d0811edca305/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa55dc0ca33c1c22af4aab73d232d0811edca305/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_8.c?ref=aa55dc0ca33c1c22af4aab73d232d0811edca305", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target non_strict_align } */\n+/* { dg-options \"-O2 -fdump-tree-store-merging\" } */\n+\n+struct baz {\n+  struct bar {\n+      int a;\n+      char b;\n+      char c;\n+      char d;\n+      char e;\n+      char f;\n+      char g;\n+  } a[4];\n+} x;\n+struct baz *xx = &x;\n+\n+void\n+foo1 (int i)\n+{\n+  x.a[i].b = 0;\n+  x.a[i].a = 0;\n+  x.a[i].c = 0;\n+  x.a[i].d = 0;\n+  x.a[i].e = 0;\n+}\n+\n+void\n+foo2 (int i)\n+{\n+  x.a[i].b = 0;\n+  x.a[i].a = 0;\n+  x.a[i].c = 1;\n+  x.a[i].d = 0;\n+  x.a[i].e = 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Merging successful\" 2 \"store-merging\" } } */"}]}