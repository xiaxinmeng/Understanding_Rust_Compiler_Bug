{"sha": "4cbb525ceeeb99ab9fe2b56f7d4cd1dee0ccd676", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNiYjUyNWNlZWViOTlhYjlmZTJiNTZmN2Q0Y2QxZGVlMGNjZDY3Ng==", "commit": {"author": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1993-03-12T09:22:53Z"}, "committer": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1993-03-12T09:22:53Z"}, "message": "(FLOAT_CLASS_P): New macro.\n\n(REGISTER_MOVE_COST): Use it instead of comparing to FLOAT_REGS.\n(PREFERRED_RELOAD_CLASS): Likewise.\n(SECONDARY_MEMORY_NEEDED): Likewise.\n(CLASS_MAX_NREGS): Likewise.\n(SELECT_CC_MODE): Use VOIDmode for non-FP-equality comparisons.\n\nFrom-SVN: r3713", "tree": {"sha": "5ce7b7f41ee5dd6e640cccc2ee7da6b0c320f37d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ce7b7f41ee5dd6e640cccc2ee7da6b0c320f37d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4cbb525ceeeb99ab9fe2b56f7d4cd1dee0ccd676", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cbb525ceeeb99ab9fe2b56f7d4cd1dee0ccd676", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cbb525ceeeb99ab9fe2b56f7d4cd1dee0ccd676", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cbb525ceeeb99ab9fe2b56f7d4cd1dee0ccd676/comments", "author": null, "committer": null, "parents": [{"sha": "dc577adaac67914bc5d67615aa78e93ffe76cd52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc577adaac67914bc5d67615aa78e93ffe76cd52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc577adaac67914bc5d67615aa78e93ffe76cd52"}], "stats": {"total": 28, "additions": 14, "deletions": 14}, "files": [{"sha": "fff1aab81eed15b88ade837de0202968b1a84ead", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cbb525ceeeb99ab9fe2b56f7d4cd1dee0ccd676/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cbb525ceeeb99ab9fe2b56f7d4cd1dee0ccd676/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=4cbb525ceeeb99ab9fe2b56f7d4cd1dee0ccd676", "patch": "@@ -300,10 +300,10 @@ extern int target_flags;\n    On the i386, copying between floating-point and fixed-point\n    registers is expensive.  */\n \n-#define REGISTER_MOVE_COST(CLASS1, CLASS2)\t\t\\\n-  ((((CLASS1) == FLOAT_REGS && (CLASS2) != FLOAT_REGS)\t\\\n-    || ((CLASS2) == FLOAT_REGS && (CLASS1) != FLOAT_REGS))\t\\\n-   ? 10 : 2)\n+#define REGISTER_MOVE_COST(CLASS1, CLASS2)\t\t\t\\\n+  (((FLOAT_CLASS_P (CLASS1) && ! FLOAT_CLASS_P (CLASS2))\t\t\\\n+    || (! FLOAT_CLASS_P (CLASS1) && FLOAT_CLASS_P (CLASS2))) ? 10\t\\\n+   : 2)\n \n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */\n@@ -389,6 +389,8 @@ enum reg_class\n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n+#define FLOAT_CLASS_P(CLASS) (reg_class_subset_p (CLASS, FLOAT_REGS))\n+\n /* Give names of register classes as strings for dump file.   */\n \n #define REG_CLASS_NAMES \\\n@@ -512,8 +514,8 @@ extern enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n   ((C) == 'G' ? standard_80387_constant_p (VALUE) : 0)\n \n /* Place additional restrictions on the register class to use when it\n-   is necessary to be able to hold a value of mode @var{mode} in a reload\n-   register for which class @var{class} would ordinarily be used. */\n+   is necessary to be able to hold a value of mode MODE in a reload\n+   register for which class CLASS would ordinarily be used. */\n \n #define LIMIT_RELOAD_CLASS(MODE, CLASS) \\\n   ((MODE) == QImode && ((CLASS) == ALL_REGS || (CLASS) == GENERAL_REGS) \\\n@@ -534,7 +536,7 @@ extern enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n #define PREFERRED_RELOAD_CLASS(X,CLASS)\t\\\n   (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) != VOIDmode ? NO_REGS\t\\\n    : GET_MODE (X) == QImode && ! reg_class_subset_p (CLASS, Q_REGS) ? Q_REGS \\\n-   : ((CLASS) == FLOAT_REGS\t\t\t\t\t\t\\\n+   : (FLOAT_CLASS_P (CLASS)\t\t\t\t\t\t\\\n       && (GET_MODE (X) == VOIDmode\t\t\t\t\t\\\n \t  || GET_MODE_CLASS (GET_MODE (X)) == MODE_INT)) ? GENERAL_REGS\t\\\n    : (CLASS) == ALL_REGS ? GENERAL_REGS\t\t\t\t\t\\\n@@ -548,18 +550,16 @@ extern enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n    location.  */\n \n #define SECONDARY_MEMORY_NEEDED(CLASS1,CLASS2,MODE) \\\n-  (((CLASS1) == FLOAT_REGS && (CLASS2) != FLOAT_REGS)\t\\\n-   || ((CLASS2) == FLOAT_REGS && (CLASS1) != FLOAT_REGS))\n+  ((FLOAT_CLASS_P (CLASS1) && ! FLOAT_CLASS_P (CLASS2))\t\\\n+   || (! FLOAT_CLASS_P (CLASS1) && FLOAT_CLASS_P (CLASS2)))\n \n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n /* On the 80386, this is the size of MODE in words,\n    except in the FP regs, where a single reg is always enough.  */\n #define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n- ((CLASS) == FLOAT_REGS ? 1 :\t\t\\\n-  (CLASS) == FP_TOP_REG ? 1 :\t\t\\\n-  (CLASS) == FP_SECOND_REG ? 1 :\t\\\n-   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+ (FLOAT_CLASS_P (CLASS) ? 1 :\t\t\\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \f\n /* Stack layout; function entry, exit and calling.  */\n \n@@ -1242,7 +1242,7 @@ while (0)\n \n #define SELECT_CC_MODE(OP,X,Y) \\\n   (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\t\\\n-   && ((OP) == EQ || (OP) == NE) ? CCFPEQmode : CCmode)\n+   && ((OP) == EQ || (OP) == NE) ? CCFPEQmode : VOIDmode)\n \n /* Define the information needed to generate branch and scc insns.  This is\n    stored from the compare operation.  Note that we can't use \"rtx\" here"}]}