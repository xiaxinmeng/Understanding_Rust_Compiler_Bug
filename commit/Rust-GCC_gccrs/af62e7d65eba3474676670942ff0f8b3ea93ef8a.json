{"sha": "af62e7d65eba3474676670942ff0f8b3ea93ef8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWY2MmU3ZDY1ZWJhMzQ3NDY3NjY3MDk0MmZmMGY4YjNlYTkzZWY4YQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-22T03:01:18Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-22T03:01:18Z"}, "message": "Initial revision\n\nFrom-SVN: r227", "tree": {"sha": "d25d311502bc9185b693dc15ce6956b7f931fcba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d25d311502bc9185b693dc15ce6956b7f931fcba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af62e7d65eba3474676670942ff0f8b3ea93ef8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af62e7d65eba3474676670942ff0f8b3ea93ef8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af62e7d65eba3474676670942ff0f8b3ea93ef8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af62e7d65eba3474676670942ff0f8b3ea93ef8a/comments", "author": null, "committer": null, "parents": [{"sha": "e378f5388e684f2782ffdfd6ef2e40f3093d72ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e378f5388e684f2782ffdfd6ef2e40f3093d72ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e378f5388e684f2782ffdfd6ef2e40f3093d72ca"}], "stats": {"total": 388, "additions": 388, "deletions": 0}, "files": [{"sha": "c20a2f29ecad764c6c13ae412df5793673c71e00", "filename": "gcc/config/i386/aix386.h", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af62e7d65eba3474676670942ff0f8b3ea93ef8a/gcc%2Fconfig%2Fi386%2Faix386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af62e7d65eba3474676670942ff0f8b3ea93ef8a/gcc%2Fconfig%2Fi386%2Faix386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Faix386.h?ref=af62e7d65eba3474676670942ff0f8b3ea93ef8a", "patch": "@@ -0,0 +1,129 @@\n+/* Definitions for IBM PS2 running AIX/386.\n+   From: Minh Tran-Le <TRANLE@intellicorp.com>\n+   Copyright (C) 1988 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include \"i386.h\"\n+\n+/* Get the generic definitions for system V.3.  */\n+\n+#include \"svr3.h\"\n+\n+/* Use the ATT assembler syntax.\n+   This overrides at least one macro (ASM_OUTPUT_LABELREF) from svr3.h.  */\n+\n+#include \"att386.h\"\n+\n+/* By default, target has a 80387.  */\n+\n+#define TARGET_DEFAULT 1\n+\n+/* Use crt1.o as a startup file and crtn.o as a closing file.  */\n+\n+#define STARTFILE_SPEC  \\\n+  \"%{pg:gcrt1.o%s}%{!pg:%{p:mcrt1.o%s}%{!p:crt1.o%s}} crtbegin.o%s\"\n+\n+#define LIB_SPEC \"%{p:-L/usr/lib/libp}%{pg:-L/usr/lib/libp} -lc \\\n+  crtend.o%s crtn.o%s\"\n+\n+/* Special flags for the linker.  I don't know what they do.  */\n+\n+#define LINK_SPEC \"%{K} %{!K:-K} %{T*} %{z:-lm}\"\n+\n+/* Specify predefined symbols in preprocessor.  */\n+\n+#define CPP_PREDEFINES \"-D_I386 -Di386 -DAIX -D_AIX\"\n+\n+/* special flags for the aix assembler to generate the short form for all\n+   qualifying forward reference */\n+\n+#define ASM_SPEC \"-s2\"\n+\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(FILE) \t\t\t\t\t\\\n+  do { fprintf (FILE, \"\\t.file\\t\\\"%s\\\"\\n\", dump_base_name);\t\\\n+       if (optimize)\t\t\t\t\t\t\\\n+          ASM_FILE_START_1 (FILE); \t\t\t\t\\\n+       else\t\t\t\t\t\t\t\\\n+          fprintf (FILE, \"\\t.noopt\\n\");\t\t\t\t\\\n+     } while (0)\n+\n+/* This was suggested, but it shouldn't be right for DBX output. -- RMS\n+   #define ASM_OUTPUT_SOURCE_FILENAME(FILE, NAME) */\n+\n+/* Writing `int' for a bitfield forces int alignment for the structure.  */\n+\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\n+#if 0\n+/* Don't write a `.optim' pseudo; this assembler\n+   is said to have a bug when .optim is used.  */\n+\n+#undef ASM_FILE_START_1\n+#define ASM_FILE_START_1(FILE) fprintf (FILE, \"\\t.noopt\\n\");\n+#endif\n+\f\n+/* Machines that use the AT&T assembler syntax\n+   also return floating point values in an FP register.  */\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.  */\n+\n+#define VALUE_REGNO(MODE) \\\n+  (((MODE)==SFmode || (MODE)==DFmode) ? FIRST_FLOAT_REG : 0)\n+\n+/* 1 if N is a possible register number for a function value. */\n+\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == 0 || (N)== FIRST_FLOAT_REG)\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+\n+#undef FUNCTION_PROFILER\n+#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n+   fprintf (FILE, \"\\tleal %sP%d,%%eax\\n\\tcall mcount\\n\", LPREFIX, (LABELNO));\n+\n+/* Note that using bss_section here caused errors\n+   in building shared libraries on system V.3.\n+   but AIX 1.2 does not have yet shareable libraries on PS2 */\n+#undef ASM_OUTPUT_LOCAL\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n+  (bss_section (),\t\t\t\t\t\\\n+   ASM_OUTPUT_LABEL ((FILE), (NAME)),\t\t\t\\\n+   fprintf ((FILE), \"\\t.set .,.+%u\\n\", (ROUNDED)))\n+\f\n+/* Define a few machine-specific details\n+   of the implementation of constructors.  */\n+\n+#undef INIT_SECTION_ASM_OP\n+#define INIT_SECTION_ASM_OP     \".section .init,\\\"x\\\"\"\n+\n+#define CTORS_SECTION_ASM_OP \\\n+  INIT_SECTION_ASM_OP \"\\n\"\t\\\n+  \"\\tpushl $0\\n\\t\"\t\t\\\n+  DATA_SECTION_ASM_OP\n+\n+#define ASM_OUTPUT_CONSTRUCTOR(FILE,NAME)\t\\\n+  do {\t\t\t\t\t\t\\\n+    init_section ();\t\t\t\t\\\n+    fprintf (FILE, \"\\tpushl $\");\t\t\\\n+    assemble_name (FILE, NAME);\t\t\t\\\n+    fprintf (FILE, \"\\n\");\t\t\t\\\n+  } while (0)"}, {"sha": "a259074e88d8ab0393d945c49dcd19d1e2ca8643", "filename": "gcc/config/i386/att.h", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af62e7d65eba3474676670942ff0f8b3ea93ef8a/gcc%2Fconfig%2Fi386%2Fatt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af62e7d65eba3474676670942ff0f8b3ea93ef8a/gcc%2Fconfig%2Fi386%2Fatt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fatt.h?ref=af62e7d65eba3474676670942ff0f8b3ea93ef8a", "patch": "@@ -0,0 +1,100 @@\n+/* Definitions for AT&T assembler syntax for the Intel 80386.\n+   Copyright (C) 1988 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* Include common aspects of all 386 Unix assemblers.  */\n+#include \"unx386.h\"\n+\n+#define TARGET_VERSION fprintf (stderr, \" (80386, ATT syntax)\");\n+\f\n+/* Define the syntax of instructions and addresses.  */\n+\n+/* Prefix for internally generated assembler labels.  */\n+#define LPREFIX \".L\"\n+\n+/* Assembler pseudos to introduce constants of various size.  */\n+\n+/* #define ASM_BYTE_OP \"\\t.byte\"  Now in svr3.h or svr4.h.  */\n+#define ASM_SHORT \"\\t.value\"\n+#define ASM_LONG \"\\t.long\"\n+#define ASM_DOUBLE \"\\t.double\"\n+\n+/* How to output an ASCII string constant.  */\n+\n+#define ASM_OUTPUT_ASCII(FILE, p, size) \\\n+{ int i = 0; \t\t\t\t\t\t\t\\\n+  while (i < (size))\t\t\t\t\t\t\\\n+    { if (i%10 == 0) { if (i!=0) fprintf ((FILE), \"\\n\");\t\\\n+\t\t       fprintf ((FILE), \"%s \", ASM_BYTE_OP); }\t\\\n+      else fprintf ((FILE), \",\");\t\t\t\t\t\\\n+\tfprintf ((FILE), \"0x%x\", ((p)[i++] & 0377)) ;}\t\t\\\n+      fprintf ((FILE), \"\\n\"); }\n+\n+/* Do use .optim by default on this machine.  */\n+#undef ASM_FILE_START_1\n+#define ASM_FILE_START_1(FILE) fprintf (FILE, \"\\t.optim\\n\")\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n+    if ((LOG)!=0) fprintf ((FILE), \"\\t.align %d\\n\", 1<<(LOG))\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter by SIZE bytes.  */\n+\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf ((FILE), \"\\t.set .,.+%u\\n\", (SIZE))\n+\n+/* Can't use ASM_OUTPUT_SKIP in text section; it doesn't leave 0s.  */\n+\n+#define ASM_NO_SKIP_IN_TEXT 1\n+\n+#define BSS_SECTION_FUNCTION \\\n+void\t\t\t\t\t\t\t\t\\\n+bss_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_bss)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", BSS_SECTION_ASM_OP);\t\\\n+      in_section = in_bss;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\f\n+/* Define the syntax of labels and symbol definitions/declarations.  */\n+\n+/* This is how to store into the string BUF\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.  */\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(BUF,PREFIX,NUMBER)\t\\\n+  sprintf ((BUF), \".%s%d\", (PREFIX), (NUMBER))\n+\n+/* This is how to output an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.  */\n+\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n+  fprintf (FILE, \".%s%d:\\n\", PREFIX, NUM)\n+\n+/* This is how to output a reference to a user-level label named NAME.  */\n+\n+#undef ASM_OUTPUT_LABELREF\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\\\n+  fprintf (FILE, \"%s\", NAME)"}, {"sha": "506e93d0e49ed4242713015eb6410b9aa8604413", "filename": "gcc/config/i860/sysv3.h", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af62e7d65eba3474676670942ff0f8b3ea93ef8a/gcc%2Fconfig%2Fi860%2Fsysv3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af62e7d65eba3474676670942ff0f8b3ea93ef8a/gcc%2Fconfig%2Fi860%2Fsysv3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fsysv3.h?ref=af62e7d65eba3474676670942ff0f8b3ea93ef8a", "patch": "@@ -0,0 +1,159 @@\n+/* Target definitions for GNU compiler for Intel 80860 running System V.3\n+   Copyright (C) 1991 Free Software Foundation, Inc.\n+\n+   Written by Ron Guilmette (rfg@ncd.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"i860.h\"\n+#include \"svr3.h\"\n+\n+/* Provide a set of pre-definitions and pre-assertions appropriate for\n+   the i860 running svr3.  */\n+#define CPP_PREDEFINES \"-Di860 -Dunix -DSVR3\"\n+\n+/* Use crt1.o as a startup file and crtn.o as a closing file.  */\n+\n+#define STARTFILE_SPEC  \\\n+  \"%{pg:gcrt1.o%s}%{!pg:%{p:mcrt1.o%s}%{!p:crt1.o%s}}\"\n+\n+#define LIB_SPEC \"%{p:-L/usr/lib/libp}%{pg:-L/usr/lib/libp} -lc crtn.o%s\"\n+\n+/* Special flags for the linker.  I don't know what they do.  */\n+\n+#define LINK_SPEC \"%{T*} %{z:-lm}\"\n+\n+/* The prefix to be used in assembler output for all names of registers.\n+   None is needed in V.3.  */\n+\n+#define I860_REG_PREFIX\t\"\"\n+\n+/* Delimiter that starts comments in the assembler code.  */\n+\n+#define ASM_COMMENT_START \"//\"\n+\n+/* Don't renumber the regusters for debugger output.  */\n+\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+/* Output the special word the System V SDB wants to see just before\n+   the first word of each function's prologue code.  */\n+\n+extern char *current_function_original_name;\n+\n+/* This special macro is used to output a magic word just before the\n+   first word of each function.  On some versions of UNIX running on\n+   the i860, this word can be any word that looks like a NOP, however\n+   under svr4, this neds to be an `shr r0,r0,r0' instruction in which\n+   the normally unused low-order bits contain the length of the function\n+   prologue code (in bytes).  This is needed to make the System V SDB\n+   debugger happy.  */\n+\n+#undef ASM_OUTPUT_FUNCTION_PREFIX\n+#define ASM_OUTPUT_FUNCTION_PREFIX(FILE, FNNAME)\t\t\t\\\n+  do {\tASM_OUTPUT_ALIGN (FILE, 2);\t\t\t\t\t\\\n+  \tfprintf ((FILE), \"\\t.long\\t.ep.\");\t\t\t\t\\\n+\tassemble_name (FILE, FNNAME);\t\t\t\t\t\\\n+\tfprintf (FILE, \"-\");\t\t\t\t\t\t\\\n+\tassemble_name (FILE, FNNAME);\t\t\t\t\t\\\n+\tfprintf (FILE, \"+0xc8000000\\n\");\t\t\t\t\\\n+\tcurrent_function_original_name = (FNNAME);\t\t\t\\\n+  } while (0)\n+\n+/* Output the special label that must go just after each function's\n+   prologue code to support svr4 SDB.  */\n+\n+#define ASM_OUTPUT_PROLOGUE_SUFFIX(FILE)\t\t\t\t\\\n+  do {\tfprintf (FILE, \".ep.\");\t\t\t\t\t\t\\\n+\tassemble_name (FILE, current_function_original_name);\t\t\\\n+\tfprintf (FILE, \":\\n\");\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* The routine used to output string literals.\n+\n+#define ASCII_DATA_ASM_OP\t\".byte\"\n+\n+#define ASM_OUTPUT_ASCII(FILE, STR, LENGTH)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      register unsigned char *str = (unsigned char *) (STR);\t\t\\\n+      register unsigned char *limit = str + (LENGTH);\t\t\t\\\n+      register unsigned bytes_in_chunk = 0;\t\t\t\t\\\n+      for (; str < limit; str++)\t\t\t\t\t\\\n+        {\t\t\t\t\t\t\t\t\\\n+          register unsigned ch = *str;\t\t\t\t\t\\\n+          if (ch < 32 || ch == '\\\\' || ch == '\"' || ch >= 127)\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      if (bytes_in_chunk > 0)\t\t\t\t\t\\\n+\t        {\t\t\t\t\t\t\t\\\n+\t          fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\\\n+\t          bytes_in_chunk = 0;\t\t\t\t\t\\\n+\t        }\t\t\t\t\t\t\t\\\n+\t      fprintf ((FILE), \"%s\\t%d\\n\", ASM_BYTE_OP, ch);\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+          else\t\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      if (bytes_in_chunk >= 60)\t\t\t\t\t\\\n+\t        {\t\t\t\t\t\t\t\\\n+\t          fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\\\n+\t          bytes_in_chunk = 0;\t\t\t\t\t\\\n+\t        }\t\t\t\t\t\t\t\\\n+\t      if (bytes_in_chunk == 0)\t\t\t\t\t\\\n+\t        fprintf ((FILE), \"\\t%s\\t\\\"\", ASCII_DATA_ASM_OP);\t\\\n+\t      putc (ch, (FILE));\t\t\t\t\t\\\n+\t      bytes_in_chunk++;\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+        }\t\t\t\t\t\t\t\t\\\n+      if (bytes_in_chunk > 0)\t\t\t\t\t\t\\\n+        fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+\n+#undef CTORS_SECTION_ASM_OP\n+#define CTORS_SECTION_ASM_OP\t\"\\t.section\\t.ctors,\\\"x\\\"\\n\"\n+#undef DTORS_SECTION_ASM_OP\n+#define DTORS_SECTION_ASM_OP\t\"\\t.section\\t.dtors,\\\"x\\\"\\n\"\n+\n+/* Add definitions to support the .tdesc section as specified in the svr4\n+   ABI for the i860.  */\n+\n+#define TDESC_SECTION_ASM_OP    \"\\t.section\\t.tdesc\"\n+\n+#undef EXTRA_SECTIONS\n+#define EXTRA_SECTIONS in_const, in_ctors, in_dtors, in_tdesc\n+\n+#undef EXTRA_SECTION_FUNCTIONS\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\t\\\n+  CONST_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  CTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  DTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  TDESC_SECTION_FUNCTION\n+\n+#define TDESC_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+tdesc_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_tdesc)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", TDESC_SECTION_ASM_OP);\t\t\\\n+      in_section = in_tdesc;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Enable the `const' section that svr3.h defines how to use.  */\n+#define USE_CONST_SECTION\t1"}]}