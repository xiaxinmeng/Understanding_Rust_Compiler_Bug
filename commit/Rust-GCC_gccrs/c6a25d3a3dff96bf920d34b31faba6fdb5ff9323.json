{"sha": "c6a25d3a3dff96bf920d34b31faba6fdb5ff9323", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzZhMjVkM2EzZGZmOTZiZjkyMGQzNGIzMWZhYmE2ZmRiNWZmOTMyMw==", "commit": {"author": {"name": "Ralph Loader", "email": "rcl@ihug.co.nz", "date": "2003-12-03T07:04:19Z"}, "committer": {"name": "Ralph Loader", "email": "ralph@gcc.gnu.org", "date": "2003-12-03T07:04:19Z"}, "message": "re PR java/12374 (Segfault on \"\".x)\n\n\n\tPR java/12374:\n\t* parse.y (qualify_ambiguous_name): Remove lots of broken\n\tfield access processing - there's no need to do that here,\n\tbecause we have resolve_field_access.  Remove\n\tRESOLVE_EXPRESSION_NAME_P as it isn't used anywhere else.\n\t* java-tree.h: Remove RESOLVE_EXPRESSION_NAME_P as it isn't\n\tused.\n\nFrom-SVN: r74217", "tree": {"sha": "d90afc44d1b9613a742916e7826c050bbd0cfd98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d90afc44d1b9613a742916e7826c050bbd0cfd98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6a25d3a3dff96bf920d34b31faba6fdb5ff9323", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6a25d3a3dff96bf920d34b31faba6fdb5ff9323", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6a25d3a3dff96bf920d34b31faba6fdb5ff9323", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6a25d3a3dff96bf920d34b31faba6fdb5ff9323/comments", "author": null, "committer": null, "parents": [{"sha": "a0506b54dd1dc77ed69b16514c9e3d24b52d97c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0506b54dd1dc77ed69b16514c9e3d24b52d97c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0506b54dd1dc77ed69b16514c9e3d24b52d97c1"}], "stats": {"total": 271, "additions": 74, "deletions": 197}, "files": [{"sha": "0f77672a4bf2ddc4678de52a433d5e1412dec5b7", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6a25d3a3dff96bf920d34b31faba6fdb5ff9323/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6a25d3a3dff96bf920d34b31faba6fdb5ff9323/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=c6a25d3a3dff96bf920d34b31faba6fdb5ff9323", "patch": "@@ -1,3 +1,13 @@\n+2003-12-03  Ralph Loader  <rcl@ihug.co.nz>\n+\n+\tPR java/12374:\n+\t* parse.y (qualify_ambiguous_name): Remove lots of broken\n+\tfield access processing - there's no need to do that here,\n+\tbecause we have resolve_field_access.  Remove\n+\tRESOLVE_EXPRESSION_NAME_P as it isn't used anywhere else.\n+\t* java-tree.h: Remove RESOLVE_EXPRESSION_NAME_P as it isn't\n+\tused.\n+\t\n 2003-12-01  Jeff Sturm  <jsturm@one-point.com>\n \n \tFix PR java/13237"}, {"sha": "88be2a034413350cd2dc2c3fd2b11a9f548fe2e0", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6a25d3a3dff96bf920d34b31faba6fdb5ff9323/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6a25d3a3dff96bf920d34b31faba6fdb5ff9323/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=c6a25d3a3dff96bf920d34b31faba6fdb5ff9323", "patch": "@@ -44,7 +44,6 @@ struct JCF;\n \n /* Usage of TREE_LANG_FLAG_?:\n    0: IS_A_SINGLE_IMPORT_CLASSFILE_NAME_P (in IDENTIFIER_NODE)\n-      RESOLVE_EXPRESSION_NAME_P (in EXPR_WITH_FILE_LOCATION)\n       FOR_LOOP_P (in LOOP_EXPR)\n       SUPPRESS_UNREACHABLE_ERROR (for other _EXPR nodes)\n       ANONYMOUS_CLASS_P (in RECORD_TYPE)\n@@ -1550,9 +1549,6 @@ extern tree *type_map;\n    feature a finalizer method. */\n #define HAS_FINALIZER_P(EXPR) TREE_LANG_FLAG_3 (EXPR)\n \n-/* True if EXPR (a WFL in that case) resolves into an expression name */\n-#define RESOLVE_EXPRESSION_NAME_P(WFL) TREE_LANG_FLAG_0 (WFL)\n-\n /* True if EXPR (a LOOP_EXPR in that case) is part of a for statement */\n #define FOR_LOOP_P(EXPR) TREE_LANG_FLAG_0 (EXPR)\n "}, {"sha": "bb833cbb979c6fd90b274900d676ee820286096c", "filename": "gcc/java/parse.y", "status": "modified", "additions": 32, "deletions": 193, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6a25d3a3dff96bf920d34b31faba6fdb5ff9323/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6a25d3a3dff96bf920d34b31faba6fdb5ff9323/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=c6a25d3a3dff96bf920d34b31faba6fdb5ff9323", "patch": "@@ -9802,7 +9802,6 @@ resolve_qualified_expression_name (tree wfl, tree *found_decl,\n \t\t  list = TREE_CHAIN (q);\n \t\t  while (list)\n \t\t    {\n-\t\t      RESOLVE_EXPRESSION_NAME_P (QUAL_WFL (list)) = 1;\n \t\t      RESOLVE_PACKAGE_NAME_P (QUAL_WFL (list)) = 0;\n \t\t      list = TREE_CHAIN (list);\n \t\t    }\n@@ -11280,211 +11279,58 @@ argument_types_convertible (tree m1, tree m2_or_arglist)\n \n /* Qualification routines */\n \n+/* Given a name x.y.z, look up x locally.  If it's found, save the\n+   decl.  If it's not found, mark the name as RESOLVE_PACKAGE_NAME_P,\n+   so that we later try and load the appropriate classes.  */\n static void\n qualify_ambiguous_name (tree id)\n {\n-  tree qual, qual_wfl, name = NULL_TREE, decl, ptr_type = NULL_TREE,\n-    saved_current_class;\n-  int again, super_found = 0, this_found = 0, new_array_found = 0;\n-  int code;\n-\n-  /* We first qualify the first element, then derive qualification of\n-     others based on the first one. If the first element is qualified\n-     by a resolution (field or type), this resolution is stored in the\n-     QUAL_RESOLUTION of the qual element being examined. We need to\n-     save the current_class since the use of SUPER might change the\n-     its value. */\n-  saved_current_class = current_class;\n-  qual = EXPR_WFL_QUALIFICATION (id);\n-  do {\n+  tree name, decl;\n \n-    /* Simple qualified expression feature a qual_wfl that is a\n-       WFL. Expression derived from a primary feature more complicated\n-       things like a CALL_EXPR. Expression from primary need to be\n-       worked out to extract the part on which the qualification will\n-       take place. */\n-    qual_wfl = QUAL_WFL (qual);\n-    switch (TREE_CODE (qual_wfl))\n-      {\n-      case CALL_EXPR:\n-\tqual_wfl = TREE_OPERAND (qual_wfl, 0);\n-\tif (TREE_CODE (qual_wfl) != EXPR_WITH_FILE_LOCATION\n-\t    || (EXPR_WFL_QUALIFICATION (qual_wfl)\n-\t\t&& TREE_CODE (EXPR_WFL_QUALIFICATION (qual_wfl)) == TREE_LIST))\n-\t  {\n-\t    qual = EXPR_WFL_QUALIFICATION (qual_wfl);\n-\t    qual_wfl = QUAL_WFL (qual);\n-\t  }\n-\tbreak;\n-      case NEW_ARRAY_EXPR:\n-      case NEW_ANONYMOUS_ARRAY_EXPR:\n-\tqual = TREE_CHAIN (qual);\n-\tagain = new_array_found = 1;\n-\tcontinue;\n-      case CONVERT_EXPR:\n-\tbreak;\n-      case NEW_CLASS_EXPR:\n-\tqual_wfl = TREE_OPERAND (qual_wfl, 0);\n-\tbreak;\n-      case ARRAY_REF:\n-\twhile (TREE_CODE (qual_wfl) == ARRAY_REF)\n-\t  qual_wfl = TREE_OPERAND (qual_wfl, 0);\n-\tbreak;\n-      case STRING_CST:\n-\tqual = TREE_CHAIN (qual);\n-\tqual_wfl = QUAL_WFL (qual);\n-\tbreak;\n-      case CLASS_LITERAL:\n-\tqual = TREE_CHAIN (qual);\n-\tqual_wfl = QUAL_WFL (qual);\n-      break;\n-      default:\n-\t/* Fix for -Wall. Just break doing nothing */\n-\tbreak;\n-      }\n-\n-    ptr_type = current_class;\n-    again = 0;\n-    code = TREE_CODE (qual_wfl);\n-\n-    /* Pos evaluation: non WFL leading expression nodes */\n-    if (code == CONVERT_EXPR\n-\t&& TREE_CODE (TREE_TYPE (qual_wfl)) == EXPR_WITH_FILE_LOCATION)\n-      name = EXPR_WFL_NODE (TREE_TYPE (qual_wfl));\n+  /* We inspect the first item of the qualification list.  As a sanity\n+     check, make sure that it is an identfier node.  */\n+  tree qual = EXPR_WFL_QUALIFICATION (id);\n+  tree qual_wfl = QUAL_WFL (qual);\n \n-    else if (code == INTEGER_CST)\n-      name = qual_wfl;\n-\n-    else if (code == CONVERT_EXPR &&\n-\t     TREE_CODE (TREE_OPERAND (qual_wfl, 0)) == EXPR_WITH_FILE_LOCATION)\n-      name = TREE_OPERAND (qual_wfl, 0);\n-\n-    else if (code == CONVERT_EXPR\n-\t     && TREE_CODE (TREE_OPERAND (qual_wfl, 0)) == CALL_EXPR\n-\t     && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (qual_wfl, 0), 0))\n-\t\t == EXPR_WITH_FILE_LOCATION))\n-      name = TREE_OPERAND (TREE_OPERAND (qual_wfl, 0), 0);\n-\n-    else if ((code == ARRAY_REF || code == CALL_EXPR || code == MODIFY_EXPR) &&\n-\t     TREE_CODE (TREE_OPERAND (qual_wfl, 0)) == EXPR_WITH_FILE_LOCATION)\n-      name = EXPR_WFL_NODE (TREE_OPERAND (qual_wfl, 0));\n+  if (TREE_CODE (qual_wfl) != EXPR_WITH_FILE_LOCATION)\n+    return;\n \n-    else if (code == TREE_LIST)\n-      name = EXPR_WFL_NODE (TREE_PURPOSE (qual_wfl));\n+  name = EXPR_WFL_NODE (qual_wfl);\n \n-    else if (code == STRING_CST || code == CONDITIONAL_EXPR\n-\t     || code == PLUS_EXPR)\n-      {\n-\tqual = TREE_CHAIN (qual);\n-\tqual_wfl = QUAL_WFL (qual);\n-\tagain = 1;\n-      }\n-    else\n-      {\n-\tname = EXPR_WFL_NODE (qual_wfl);\n-\tif (!name)\n-\t  {\n-\t    qual = EXPR_WFL_QUALIFICATION (qual_wfl);\n-\t    again = 1;\n-\t  }\n-      }\n-\n-    /* If we have a THIS (from a primary), we set the context accordingly */\n-    if (name == this_identifier_node)\n-      {\n-\t/* This isn't really elegant. One more added irregularity\n-\t   before I start using COMPONENT_REF (hopefully very soon.)  */\n-\tif (TREE_CODE (TREE_PURPOSE (qual)) == ARRAY_REF\n-\t    && TREE_CODE (TREE_OPERAND (TREE_PURPOSE (qual), 0)) ==\n-\t       EXPR_WITH_FILE_LOCATION\n-\t    && EXPR_WFL_NODE (TREE_OPERAND (TREE_PURPOSE (qual), 0)) ==\n-\t       this_identifier_node)\n-\t    {\n-\t      qual = TREE_OPERAND (TREE_PURPOSE (qual), 0);\n-\t      qual = EXPR_WFL_QUALIFICATION (qual);\n-\t    }\n-\tqual = TREE_CHAIN (qual);\n-\tqual_wfl = QUAL_WFL (qual);\n-\tif (TREE_CODE (qual_wfl) == CALL_EXPR)\n-\t  again = 1;\n-\telse if (TREE_CODE (qual_wfl) == EXPR_WITH_FILE_LOCATION)\n-\t  name = EXPR_WFL_NODE (qual_wfl);\n-\telse if (TREE_CODE (qual_wfl) == NEW_CLASS_EXPR)\n-\t  name = TREE_OPERAND (qual_wfl, 0);\n-\tthis_found = 1;\n-      }\n-    /* If we have a SUPER, we set the context accordingly */\n-    if (name == super_identifier_node)\n-      {\n-\tcurrent_class = CLASSTYPE_SUPER (ptr_type);\n-\t/* Check that there is such a thing as a super class. If not,\n-\t   return.  The error will be caught later on, during the\n-\t   resolution */\n-\tif (!current_class)\n-\t  {\n-\t    current_class = saved_current_class;\n-\t    return;\n-\t  }\n-\tqual = TREE_CHAIN (qual);\n-\t/* Do one more iteration to set things up */\n-\tsuper_found = again = 1;\n-      }\n-  } while (again);\n+  /* If we don't have an identifier, or we have a 'this' or 'super',\n+     then field access processing is all we need : there is nothing\n+     for us to do.  */\n+  if (!name || TREE_CODE (name) != IDENTIFIER_NODE ||\n+      name == this_identifier_node ||\n+      name == super_identifier_node)\n+    return;\n \n   /* If name appears within the scope of a local variable declaration\n-     or parameter declaration, then it is an expression name. We don't\n-     carry this test out if we're in the context of the use of SUPER\n-     or THIS */\n-  if (!this_found && !super_found\n-      && TREE_CODE (name) != STRING_CST && TREE_CODE (name) != INTEGER_CST\n-      && (decl = IDENTIFIER_LOCAL_VALUE (name)))\n-    {\n-      RESOLVE_EXPRESSION_NAME_P (qual_wfl) = 1;\n+     or parameter declaration, or is a field within an enclosing\n+     class, then it is an expression name.  Save the decl and let\n+     resolve_field_access do it's work.  */\n+  if ((decl = IDENTIFIER_LOCAL_VALUE (name)) ||\n+      (decl = lookup_field_wrapper (current_class, name)))\n+    {\n       QUAL_RESOLUTION (qual) = decl;\n+      return;\n     }\n \n-  /* If within the class/interface NAME was found to be used there\n-     exists a (possibly inherited) field named NAME, then this is an\n-     expression name. If we saw a NEW_ARRAY_EXPR before and want to\n-     address length, it is OK. */\n-  else if ((decl = lookup_field_wrapper (ptr_type, name))\n-\t   || name == length_identifier_node)\n-    {\n-      RESOLVE_EXPRESSION_NAME_P (qual_wfl) = 1;\n-      QUAL_RESOLUTION (qual) = (new_array_found ? NULL_TREE : decl);\n-    }\n-\n-  /* We reclassify NAME as yielding to a type name resolution if:\n-     - NAME is a class/interface declared within the compilation\n-       unit containing NAME,\n-     - NAME is imported via a single-type-import declaration,\n-     - NAME is declared in an another compilation unit of the package\n-       of the compilation unit containing NAME,\n-     - NAME is declared by exactly on type-import-on-demand declaration\n-     of the compilation unit containing NAME.\n-     - NAME is actually a STRING_CST.\n-     This can't happen if the expression was qualified by `this.' */\n-  else if (! this_found &&\n-\t   (TREE_CODE (name) == STRING_CST ||\n-\t    TREE_CODE (name) == INTEGER_CST ||\n-\t    (decl = resolve_and_layout (name, NULL_TREE))))\n+  /* If name is a known class name (either declared or imported), mark\n+     us as a type name.  */\n+  if ((decl = resolve_and_layout (name, NULL_TREE)))\n     {\n       RESOLVE_TYPE_NAME_P (qual_wfl) = 1;\n       QUAL_RESOLUTION (qual) = decl;\n     }\n \n-  /* Method call, array references and cast are expression name */\n-  else if (TREE_CODE (QUAL_WFL (qual)) == CALL_EXPR\n-\t   || TREE_CODE (QUAL_WFL (qual)) == ARRAY_REF\n-\t   || TREE_CODE (QUAL_WFL (qual)) == CONVERT_EXPR\n-\t   || TREE_CODE (QUAL_WFL (qual)) == MODIFY_EXPR)\n-    RESOLVE_EXPRESSION_NAME_P (qual_wfl) = 1;\n-\n   /* Check here that NAME isn't declared by more than one\n      type-import-on-demand declaration of the compilation unit\n      containing NAME. FIXME */\n \n-  /* Otherwise, NAME is reclassified as a package name */\n+  /* We couldn't find a declaration for the name.  Assume for now that\n+     we have a qualified class name that needs to be loaded from an\n+     external class file.  */\n   else\n     RESOLVE_PACKAGE_NAME_P (qual_wfl) = 1;\n \n@@ -11495,21 +11341,14 @@ qualify_ambiguous_name (tree id)\n     {\n       if (RESOLVE_PACKAGE_NAME_P (qual_wfl))\n \tRESOLVE_PACKAGE_NAME_P (QUAL_WFL (qual)) = 1;\n-      else\n-\tRESOLVE_EXPRESSION_NAME_P (QUAL_WFL (qual)) = 1;\n     }\n \n   /* Store the global qualification for the ambiguous part of ID back\n      into ID fields */\n-  if (RESOLVE_EXPRESSION_NAME_P (qual_wfl))\n-    RESOLVE_EXPRESSION_NAME_P (id) = 1;\n-  else if (RESOLVE_TYPE_NAME_P (qual_wfl))\n+  if (RESOLVE_TYPE_NAME_P (qual_wfl))\n     RESOLVE_TYPE_NAME_P (id) = 1;\n   else if (RESOLVE_PACKAGE_NAME_P (qual_wfl))\n     RESOLVE_PACKAGE_NAME_P (id) = 1;\n-\n-  /* Restore the current class */\n-  current_class = saved_current_class;\n }\n \n static int"}, {"sha": "e64b114b95b2012b8d100aea52d5dbf427277349", "filename": "libjava/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6a25d3a3dff96bf920d34b31faba6fdb5ff9323/libjava%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6a25d3a3dff96bf920d34b31faba6fdb5ff9323/libjava%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2FChangeLog?ref=c6a25d3a3dff96bf920d34b31faba6fdb5ff9323", "patch": "@@ -1,3 +1,8 @@\n+2003-12-03  Ralph Loader  <rcl@ihug.co.nz>\n+\n+\tPR java/12374:\n+\t* libjava.compile/PR12374.java: New file.\n+\t\n 2003-12-01  Jeff Sturm  <jsturm@one-point.com>\n \n \tPR optimization/13024"}, {"sha": "19e81935d59d9d5d2a0c10fc091fa9c3281eeb59", "filename": "libjava/testsuite/libjava.compile/PR12374.java", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6a25d3a3dff96bf920d34b31faba6fdb5ff9323/libjava%2Ftestsuite%2Flibjava.compile%2FPR12374.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6a25d3a3dff96bf920d34b31faba6fdb5ff9323/libjava%2Ftestsuite%2Flibjava.compile%2FPR12374.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.compile%2FPR12374.java?ref=c6a25d3a3dff96bf920d34b31faba6fdb5ff9323", "patch": "@@ -0,0 +1,27 @@\n+public class PR12374 {\n+\n+  /* We weren't coping with field refs on a string constant...  */\n+\n+  Object Foo()\n+  {\n+    return \"\".CASE_INSENSITIVE_ORDER;\n+  }\n+\n+  /* Special casing access to array.length while analysing syntax is\n+     evil.  Especially when it means we can't cope with a type\n+     called length.  */\n+\n+  class length\n+  {\n+    static final int i = 2;\n+  }\n+\n+  int bar()\n+  {\n+    return length.i;\n+  }\n+\n+  public static void main (String[] argv)\n+  {\n+  }\n+}"}]}