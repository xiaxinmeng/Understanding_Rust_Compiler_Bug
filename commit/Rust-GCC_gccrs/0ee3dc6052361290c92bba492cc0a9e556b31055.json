{"sha": "0ee3dc6052361290c92bba492cc0a9e556b31055", "node_id": "C_kwDOANBUbNoAKDBlZTNkYzYwNTIzNjEyOTBjOTJiYmE0OTJjYzBhOWU1NTZiMzEwNTU", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-10-04T22:55:43Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-10-08T12:17:47Z"}, "message": "loop: Fix profile updates after unrolling [PR102385]\n\nIn g:62acc72a957b5614 I'd stopped the unroller from using\nan epilogue loop in cases where the iteration count was\nknown to be a multiple of the unroll factor.  The epilogue\nand non-epilogue cases still shared this (preexisting) code\nto update the edge frequencies:\n\n  basic_block exit_bb = single_pred (loop->latch);\n  new_exit = find_edge (exit_bb, rest);\n  new_exit->probability = profile_probability::always ()\n                               .apply_scale (1, new_est_niter + 1);\n  [etc]\n\nBut of course (in hindsight) that only makes sense for the\nepilogue case, where we've already moved the main loop's exit edge\nto be a sibling of the latch edge.  For the non-epilogue case,\nthe exit edge stays (and needs to stay) in its original position.\n\nI don't really understand what the code is trying to do for\nthe epilogue case.  It has:\n\n      /* Ensure that the frequencies in the loop match the new estimated\n\t number of iterations, and change the probability of the new\n\t exit edge.  */\n\n      profile_count freq_h = loop->header->count;\n      profile_count freq_e = (loop_preheader_edge (loop))->count ();\n      if (freq_h.nonzero_p ())\n\t{\n          ...\n\t  scale_loop_frequencies (loop, freq_e.probability_in (freq_h));\n\t}\n\nHere, freq_e.probability_in (freq_h) is freq_e / freq_h, so for the\nheader block, this has the effect of:\n\n  new header count = freq_h * (freq_e / freq_h)\n\ni.e. we say that the header executes exactly as often as the\npreheader edge, which would only make sense if the loop never\niterates.  Also, after setting the probability of the nonexit edge\n(correctly) to new_est_niter / (new_est_niter + 1), the code does:\n\n    scale_bbs_frequencies (&loop->latch, 1, prob);\n\nfor this new probability.  I think that only makes sense if the\nnonexit edge was previously unconditional (100%).  But the code\ncarefully preserved the probability of the original exit edge\nwhen creating the new one.\n\nAll I'm trying to do here though is fix the mess I created\nand get the probabilities right for the non-epilogue case.\nThings are simpler there since we don't have to worry about\nloop versioning.  Hopefully the comments explain the approach.\n\nThe function's current interface implies that it can cope with\nmultiple exit edges and that the function only needs the iteration\ncount relative to one of those edges in order to work correctly.\nIn practice that's not the case: it assumes there is exactly one\nexit edge and all current callers also ensure that the exit test\ndominates the latch.  I think the function is easier to follow\nif we remove the implied generality.\n\ngcc/\n\tPR tree-optimization/102385\n\t* predict.h (change_edge_frequency): Declare.\n\t* predict.c (change_edge_frequency): New function.\n\t* tree-ssa-loop-manip.h (tree_transform_and_unroll_loop): Remove\n\tedge argument.\n\t(tree_unroll_loop): Likewise.\n\t* gimple-loop-jam.c (tree_loop_unroll_and_jam): Update accordingly.\n\t* tree-predcom.c (pcom_worker::tree_predictive_commoning_loop):\n\tLikewise.\n\t* tree-ssa-loop-prefetch.c (loop_prefetch_arrays): Likewise.\n\t* tree-ssa-loop-manip.c (tree_unroll_loop): Likewise.\n\t(tree_transform_and_unroll_loop): Likewise.  Use single_dom_exit\n\tto retrieve the exit edges.  Make all the old profile update code\n\tconditional on !single_loop_p -- the case it was written for --\n\tand use a different approach for the single-loop case.\n\ngcc/testsuite/\n\t* gcc.dg/pr102385.c: New test.", "tree": {"sha": "b191e3bb94fe67445ee327752388ceef80c7197e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b191e3bb94fe67445ee327752388ceef80c7197e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ee3dc6052361290c92bba492cc0a9e556b31055", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ee3dc6052361290c92bba492cc0a9e556b31055", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ee3dc6052361290c92bba492cc0a9e556b31055", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ee3dc6052361290c92bba492cc0a9e556b31055/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "816da497dfba541aabdbe08a03e6e9988a7d9573", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/816da497dfba541aabdbe08a03e6e9988a7d9573", "html_url": "https://github.com/Rust-GCC/gccrs/commit/816da497dfba541aabdbe08a03e6e9988a7d9573"}], "stats": {"total": 177, "additions": 140, "deletions": 37}, "files": [{"sha": "611d38053040da0977450a0887ca32e215f2a7e8", "filename": "gcc/gimple-loop-jam.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ee3dc6052361290c92bba492cc0a9e556b31055/gcc%2Fgimple-loop-jam.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ee3dc6052361290c92bba492cc0a9e556b31055/gcc%2Fgimple-loop-jam.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-loop-jam.c?ref=0ee3dc6052361290c92bba492cc0a9e556b31055", "patch": "@@ -587,8 +587,7 @@ tree_loop_unroll_and_jam (void)\n \t\t\t     \"applying unroll and jam with factor %d\\n\",\n \t\t\t     unroll_factor);\n \t  initialize_original_copy_tables ();\n-\t  tree_unroll_loop (outer, unroll_factor, single_dom_exit (outer),\n-\t\t\t    &desc);\n+\t  tree_unroll_loop (outer, unroll_factor, &desc);\n \t  free_original_copy_tables ();\n \t  fuse_loops (outer->inner);\n \t  todo |= TODO_cleanup_cfg;"}, {"sha": "68b111356804e2de6ce60aa08b64d0a9b1fc3fe7", "filename": "gcc/predict.c", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ee3dc6052361290c92bba492cc0a9e556b31055/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ee3dc6052361290c92bba492cc0a9e556b31055/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=0ee3dc6052361290c92bba492cc0a9e556b31055", "patch": "@@ -4481,6 +4481,43 @@ force_edge_cold (edge e, bool impossible)\n     }\n }\n \n+/* Change E's probability to NEW_E_PROB, redistributing the probabilities\n+   of other outgoing edges proportionally.\n+\n+   Note that this function does not change the profile counts of any\n+   basic blocks.  The caller must do that instead, using whatever\n+   information it has about the region that needs updating.  */\n+\n+void\n+change_edge_frequency (edge e, profile_probability new_e_prob)\n+{\n+  profile_probability old_e_prob = e->probability;\n+  profile_probability old_other_prob = old_e_prob.invert ();\n+  profile_probability new_other_prob = new_e_prob.invert ();\n+\n+  e->probability = new_e_prob;\n+  profile_probability cumulative_prob = new_e_prob;\n+\n+  unsigned int num_other = EDGE_COUNT (e->src->succs) - 1;\n+  edge other_e;\n+  edge_iterator ei;\n+  FOR_EACH_EDGE (other_e, ei, e->src->succs)\n+    if (other_e != e)\n+      {\n+\tnum_other -= 1;\n+\tif (num_other == 0)\n+\t  /* Ensure that the probabilities add up to 1 without\n+\t     rounding error.  */\n+\t  other_e->probability = cumulative_prob.invert ();\n+\telse\n+\t  {\n+\t    other_e->probability /= old_other_prob;\n+\t    other_e->probability *= new_other_prob;\n+\t    cumulative_prob += other_e->probability;\n+\t  }\n+      }\n+}\n+\n #if CHECKING_P\n \n namespace selftest {"}, {"sha": "4df51bd615ca16287f6de2d42efa559fb5855ad9", "filename": "gcc/predict.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ee3dc6052361290c92bba492cc0a9e556b31055/gcc%2Fpredict.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ee3dc6052361290c92bba492cc0a9e556b31055/gcc%2Fpredict.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.h?ref=0ee3dc6052361290c92bba492cc0a9e556b31055", "patch": "@@ -100,6 +100,7 @@ extern void rebuild_frequencies (void);\n extern void report_predictor_hitrates (void);\n extern void force_edge_cold (edge, bool);\n extern void propagate_unlikely_bbs_forward (void);\n+extern void change_edge_frequency (edge, profile_probability);\n \n extern void add_reg_br_prob_note (rtx_insn *, profile_probability);\n "}, {"sha": "1339540c722c0bf917908a516c339d094732cf0f", "filename": "gcc/testsuite/gcc.dg/pr102385.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ee3dc6052361290c92bba492cc0a9e556b31055/gcc%2Ftestsuite%2Fgcc.dg%2Fpr102385.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ee3dc6052361290c92bba492cc0a9e556b31055/gcc%2Ftestsuite%2Fgcc.dg%2Fpr102385.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr102385.c?ref=0ee3dc6052361290c92bba492cc0a9e556b31055", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-options \"-Wall -Wextra -O2 -fno-toplevel-reorder -fno-tree-ch -fno-tree-dce -fno-tree-dominator-opts -fno-tree-dse -fno-tree-loop-ivcanon -fpredictive-commoning\" } */\n+\n+short a, b;\n+int c[9];\n+void(d)() {}\n+void e() {\n+  a = 0;\n+  for (; a <= 4; a++) {\n+    short *f = &b;\n+    c[a] || (*f = 0);\n+    d(c[a + 2]);\n+  }\n+}\n+int main() {return 0;}"}, {"sha": "208e755c22ec9379dd0faffc89c3b61be4e816c3", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ee3dc6052361290c92bba492cc0a9e556b31055/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ee3dc6052361290c92bba492cc0a9e556b31055/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=0ee3dc6052361290c92bba492cc0a9e556b31055", "patch": "@@ -3398,8 +3398,7 @@ pcom_worker::tree_predictive_commoning_loop (bool allow_unroll_p)\n \t the phi nodes in execute_pred_commoning_cbck.  A bit hacky.  */\n       replace_phis_by_defined_names (m_chains);\n \n-      edge exit = single_dom_exit (m_loop);\n-      tree_transform_and_unroll_loop (m_loop, unroll_factor, exit, &desc,\n+      tree_transform_and_unroll_loop (m_loop, unroll_factor, &desc,\n \t\t\t\t      execute_pred_commoning_cbck, &dta);\n       eliminate_temp_copies (m_loop, tmp_vars);\n     }"}, {"sha": "2d576bfa3913e03c20be56bfd09192f05022dc0b", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 83, "deletions": 28, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ee3dc6052361290c92bba492cc0a9e556b31055/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ee3dc6052361290c92bba492cc0a9e556b31055/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=0ee3dc6052361290c92bba492cc0a9e556b31055", "patch": "@@ -1182,8 +1182,9 @@ niter_for_unrolled_loop (class loop *loop, unsigned factor)\n   return new_est_niter;\n }\n \n-/* Unroll LOOP FACTOR times.  DESC describes number of iterations of LOOP.\n-   EXIT is the exit of the loop to that DESC corresponds.\n+/* Unroll LOOP FACTOR times.  LOOP is known to have a single exit edge\n+   whose source block dominates the latch.  DESC describes the number of\n+   iterations of LOOP.\n \n    If N is number of iterations of the loop and MAY_BE_ZERO is the condition\n    under that loop exits in the first iteration even if N != 0,\n@@ -1241,7 +1242,7 @@ niter_for_unrolled_loop (class loop *loop, unsigned factor)\n \n void\n tree_transform_and_unroll_loop (class loop *loop, unsigned factor,\n-\t\t\t\tedge exit, class tree_niter_desc *desc,\n+\t\t\t\tclass tree_niter_desc *desc,\n \t\t\t\ttransform_callback transform,\n \t\t\t\tvoid *data)\n {\n@@ -1265,10 +1266,11 @@ tree_transform_and_unroll_loop (class loop *loop, unsigned factor,\n \n   gcond *exit_if = nullptr;\n   class loop *new_loop = nullptr;\n-  basic_block rest;\n   edge new_exit;\n   if (!single_loop_p)\n     {\n+      edge exit = single_dom_exit (loop);\n+\n       /* The values for scales should keep profile consistent, and somewhat\n \t close to correct.\n \n@@ -1291,7 +1293,7 @@ tree_transform_and_unroll_loop (class loop *loop, unsigned factor,\n \n       /* Prepare the cfg and update the phi nodes.  Move the loop exit to the\n \t loop latch (and make its condition dummy, for the moment).  */\n-      rest = loop_preheader_edge (new_loop)->src;\n+      basic_block rest = loop_preheader_edge (new_loop)->src;\n       edge precond_edge = single_pred_edge (rest);\n       split_edge (loop_latch_edge (loop));\n       basic_block exit_bb = single_pred (loop->latch);\n@@ -1373,10 +1375,7 @@ tree_transform_and_unroll_loop (class loop *loop, unsigned factor,\n       remove_path (exit);\n     }\n   else\n-    {\n-      new_exit = exit;\n-      rest = exit->dest;\n-    }\n+    new_exit = single_dom_exit (loop);\n \n   /* Transform the loop.  */\n   if (transform)\n@@ -1401,6 +1400,7 @@ tree_transform_and_unroll_loop (class loop *loop, unsigned factor,\n     }\n   update_ssa (TODO_update_ssa);\n \n+  new_exit = single_dom_exit (loop);\n   if (!single_loop_p)\n     {\n       /* Ensure that the frequencies in the loop match the new estimated\n@@ -1417,29 +1417,24 @@ tree_transform_and_unroll_loop (class loop *loop, unsigned factor,\n \t    freq_e = freq_e.force_nonzero ();\n \t  scale_loop_frequencies (loop, freq_e.probability_in (freq_h));\n \t}\n-    }\n \n-  basic_block exit_bb = single_pred (loop->latch);\n-  new_exit = find_edge (exit_bb, rest);\n-  new_exit->probability = profile_probability::always ()\n-\t\t\t\t.apply_scale (1, new_est_niter + 1);\n+      basic_block rest = new_exit->dest;\n+      new_exit->probability = profile_probability::always ()\n+\t.apply_scale (1, new_est_niter + 1);\n \n-  if (!single_loop_p)\n-    rest->count += new_exit->count ();\n+      rest->count += new_exit->count ();\n \n-  edge new_nonexit = single_pred_edge (loop->latch);\n-  profile_probability prob = new_nonexit->probability;\n-  new_nonexit->probability = new_exit->probability.invert ();\n-  prob = new_nonexit->probability / prob;\n-  if (prob.initialized_p ())\n-    scale_bbs_frequencies (&loop->latch, 1, prob);\n+      edge new_nonexit = single_pred_edge (loop->latch);\n+      profile_probability prob = new_nonexit->probability;\n+      new_nonexit->probability = new_exit->probability.invert ();\n+      prob = new_nonexit->probability / prob;\n+      if (prob.initialized_p ())\n+\tscale_bbs_frequencies (&loop->latch, 1, prob);\n \n-  if (!single_loop_p)\n-    {\n       /* Finally create the new counter for number of iterations and add\n \t the new exit instruction.  */\n       tree ctr_before, ctr_after;\n-      gimple_stmt_iterator bsi = gsi_last_nondebug_bb (exit_bb);\n+      gimple_stmt_iterator bsi = gsi_last_nondebug_bb (new_exit->src);\n       exit_if = as_a <gcond *> (gsi_stmt (bsi));\n       create_iv (exit_base, exit_step, NULL_TREE, loop,\n \t\t &bsi, false, &ctr_before, &ctr_after);\n@@ -1448,6 +1443,67 @@ tree_transform_and_unroll_loop (class loop *loop, unsigned factor,\n       gimple_cond_set_rhs (exit_if, exit_bound);\n       update_stmt (exit_if);\n     }\n+  else\n+    {\n+      /* gimple_duplicate_loop_to_header_edge has adjusted the loop body's\n+\t original profile counts in line with the unroll factor.  However,\n+\t the old counts might not have been consistent with the old\n+\t iteration count.\n+\n+\t Therefore, if the iteration count is known exactly, make sure that the\n+\t profile counts of the loop header (and any other blocks that might be\n+\t executed in the final iteration) are consistent with the combination\n+\t of (a) the incoming profile count and (b) the new iteration count.  */\n+      profile_count in_count = loop_preheader_edge (loop)->count ();\n+      profile_count old_header_count = loop->header->count;\n+      if (in_count.nonzero_p ()\n+\t  && old_header_count.nonzero_p ()\n+\t  && TREE_CODE (desc->niter) == INTEGER_CST)\n+\t{\n+\t  /* The + 1 converts latch counts to iteration counts.  */\n+\t  profile_count new_header_count\n+\t    = (in_count.apply_scale (new_est_niter + 1, 1));\n+\t  basic_block *body = get_loop_body (loop);\n+\t  scale_bbs_frequencies_profile_count (body, loop->num_nodes,\n+\t\t\t\t\t       new_header_count,\n+\t\t\t\t\t       old_header_count);\n+\t  free (body);\n+\t}\n+\n+      /* gimple_duplicate_loop_to_header_edge discarded FACTOR - 1\n+\t exit edges and adjusted the loop body's profile counts for the\n+\t new probabilities of the remaining non-exit edges.  However,\n+\t the remaining exit edge still has the same probability as it\n+\t did before, even though it is now more likely.\n+\n+\t Therefore, all blocks executed after a failed exit test now have\n+\t a profile count that is too high, and the sum of the profile counts\n+\t for the header's incoming edges is greater than the profile count\n+\t of the header itself.\n+\n+\t Adjust the profile counts of all code in the loop body after\n+\t the exit test so that the sum of the counts on entry to the\n+\t header agree.  */\n+      profile_count old_latch_count = loop_latch_edge (loop)->count ();\n+      profile_count new_latch_count = loop->header->count - in_count;\n+      if (old_latch_count.nonzero_p () && new_latch_count.nonzero_p ())\n+\tscale_dominated_blocks_in_loop (loop, new_exit->src, new_latch_count,\n+\t\t\t\t\told_latch_count);\n+\n+      /* Set the probability of the exit edge based on NEW_EST_NITER\n+\t (which estimates latch counts rather than iteration counts).\n+\t Update the probabilities of other edges to match.\n+\n+\t If the profile counts are large enough to give the required\n+\t precision, the updates above will have made\n+\n+\t    e->dest->count / e->src->count ~= new e->probability\n+\n+\t for every outgoing edge e of NEW_EXIT->src.  */\n+      profile_probability new_exit_prob = profile_probability::always ()\n+\t.apply_scale (1, new_est_niter + 1);\n+      change_edge_frequency (new_exit, new_exit_prob);\n+    }\n \n   checking_verify_flow_info ();\n   checking_verify_loop_structure ();\n@@ -1461,10 +1517,9 @@ tree_transform_and_unroll_loop (class loop *loop, unsigned factor,\n \n void\n tree_unroll_loop (class loop *loop, unsigned factor,\n-\t\t  edge exit, class tree_niter_desc *desc)\n+\t\t  class tree_niter_desc *desc)\n {\n-  tree_transform_and_unroll_loop (loop, factor, exit, desc,\n-\t\t\t\t  NULL, NULL);\n+  tree_transform_and_unroll_loop (loop, factor, desc, NULL, NULL);\n }\n \n /* Rewrite the phi node at position PSI in function of the main"}, {"sha": "5e2d7fa11a429afff4f3d8086862a9d2b725e93a", "filename": "gcc/tree-ssa-loop-manip.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ee3dc6052361290c92bba492cc0a9e556b31055/gcc%2Ftree-ssa-loop-manip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ee3dc6052361290c92bba492cc0a9e556b31055/gcc%2Ftree-ssa-loop-manip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.h?ref=0ee3dc6052361290c92bba492cc0a9e556b31055", "patch": "@@ -50,10 +50,9 @@ extern bool can_unroll_loop_p (class loop *loop, unsigned factor,\n \t\t\t       class tree_niter_desc *niter);\n extern gcov_type niter_for_unrolled_loop (class loop *, unsigned);\n extern void tree_transform_and_unroll_loop (class loop *, unsigned,\n-\t\t\t\t\t    edge, class tree_niter_desc *,\n+\t\t\t\t\t    tree_niter_desc *,\n \t\t\t\t\t    transform_callback, void *);\n-extern void tree_unroll_loop (class loop *, unsigned,\n-\t\t\t      edge, class tree_niter_desc *);\n+extern void tree_unroll_loop (class loop *, unsigned, tree_niter_desc *);\n extern tree canonicalize_loop_ivs (class loop *, tree *, bool);\n extern unsigned int loop_invariant_motion_in_fun (function *, bool);\n "}, {"sha": "04b2b33c1ba058df53e069d05d712b839f5bdec7", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ee3dc6052361290c92bba492cc0a9e556b31055/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ee3dc6052361290c92bba492cc0a9e556b31055/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=0ee3dc6052361290c92bba492cc0a9e556b31055", "patch": "@@ -1962,8 +1962,7 @@ loop_prefetch_arrays (class loop *loop)\n      iterations so that we do not issue superfluous prefetches.  */\n   if (unroll_factor != 1)\n     {\n-      tree_unroll_loop (loop, unroll_factor,\n-\t\t\tsingle_dom_exit (loop), &desc);\n+      tree_unroll_loop (loop, unroll_factor, &desc);\n       unrolled = true;\n     }\n "}]}