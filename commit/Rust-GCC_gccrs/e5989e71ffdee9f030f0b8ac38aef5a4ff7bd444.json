{"sha": "e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU5ODllNzFmZmRlZTlmMDMwZjBiOGFjMzhhZWY1YTRmZjdiZDQ0NA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2018-10-12T10:50:15Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2018-10-12T10:50:15Z"}, "message": "Initial commit of Networking TS implementation\n\n\t* include/Makefile.am: Add new headers.\n\t* include/Makefile.in: Regenerate.\n\t* include/experimental/bits/net.h: New header for common\n\timplementation details of Networking TS.\n\t* include/experimental/buffer: New header.\n\t* include/experimental/executor: New header.\n\t* include/experimental/internet: New header.\n\t* include/experimental/io_context: New header.\n\t* include/experimental/net: New header.\n\t* include/experimental/netfwd: New header.\n\t* include/experimental/socket: New header.\n\t* include/experimental/timer: New header.\n\t* testsuite/experimental/net/buffer/arithmetic.cc: New test.\n\t* testsuite/experimental/net/buffer/const.cc: New test.\n\t* testsuite/experimental/net/buffer/creation.cc: New test.\n\t* testsuite/experimental/net/buffer/mutable.cc: New test.\n\t* testsuite/experimental/net/buffer/size.cc: New test.\n\t* testsuite/experimental/net/buffer/traits.cc: New test.\n\t* testsuite/experimental/net/execution_context/use_service.cc: New\n\ttest.\n\t* testsuite/experimental/net/headers.cc: New test.\n\t* testsuite/experimental/net/internet/address/v4/comparisons.cc: New\n\ttest.\n\t* testsuite/experimental/net/internet/address/v4/cons.cc: New test.\n\t* testsuite/experimental/net/internet/address/v4/creation.cc: New\n\ttest.\n\t* testsuite/experimental/net/internet/address/v4/members.cc: New\n\ttest.\n\t* testsuite/experimental/net/internet/resolver/base.cc: New test.\n\t* testsuite/experimental/net/internet/resolver/ops/lookup.cc: New\n\ttest.\n\t* testsuite/experimental/net/internet/resolver/ops/reverse.cc: New\n\ttest.\n\t* testsuite/experimental/net/timer/waitable/cons.cc: New test.\n\t* testsuite/experimental/net/timer/waitable/dest.cc: New test.\n\t* testsuite/experimental/net/timer/waitable/ops.cc: New test.\n\nFrom-SVN: r265080", "tree": {"sha": "466a8231322ad61011ac1257e2e258147759a6b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/466a8231322ad61011ac1257e2e258147759a6b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0cfc095c8d150af9f0f68a3238abe76b43e73bec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cfc095c8d150af9f0f68a3238abe76b43e73bec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cfc095c8d150af9f0f68a3238abe76b43e73bec"}], "stats": {"total": 10668, "additions": 10668, "deletions": 0}, "files": [{"sha": "871d6ab4a09e3243982e3b7bd6e2544ea785088a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "patch": "@@ -1,5 +1,43 @@\n 2018-10-12  Jonathan Wakely  <jwakely@redhat.com>\n \n+\tInitial commit of Networking TS implementation.\n+\t* include/Makefile.am: Add new headers.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/experimental/bits/net.h: New header for common\n+\timplementation details of Networking TS.\n+\t* include/experimental/buffer: New header.\n+\t* include/experimental/executor: New header.\n+\t* include/experimental/internet: New header.\n+\t* include/experimental/io_context: New header.\n+\t* include/experimental/net: New header.\n+\t* include/experimental/netfwd: New header.\n+\t* include/experimental/socket: New header.\n+\t* include/experimental/timer: New header.\n+\t* testsuite/experimental/net/buffer/arithmetic.cc: New test.\n+\t* testsuite/experimental/net/buffer/const.cc: New test.\n+\t* testsuite/experimental/net/buffer/creation.cc: New test.\n+\t* testsuite/experimental/net/buffer/mutable.cc: New test.\n+\t* testsuite/experimental/net/buffer/size.cc: New test.\n+\t* testsuite/experimental/net/buffer/traits.cc: New test.\n+\t* testsuite/experimental/net/execution_context/use_service.cc: New\n+\ttest.\n+\t* testsuite/experimental/net/headers.cc: New test.\n+\t* testsuite/experimental/net/internet/address/v4/comparisons.cc: New\n+\ttest.\n+\t* testsuite/experimental/net/internet/address/v4/cons.cc: New test.\n+\t* testsuite/experimental/net/internet/address/v4/creation.cc: New\n+\ttest.\n+\t* testsuite/experimental/net/internet/address/v4/members.cc: New\n+\ttest.\n+\t* testsuite/experimental/net/internet/resolver/base.cc: New test.\n+\t* testsuite/experimental/net/internet/resolver/ops/lookup.cc: New\n+\ttest.\n+\t* testsuite/experimental/net/internet/resolver/ops/reverse.cc: New\n+\ttest.\n+\t* testsuite/experimental/net/timer/waitable/cons.cc: New test.\n+\t* testsuite/experimental/net/timer/waitable/dest.cc: New test.\n+\t* testsuite/experimental/net/timer/waitable/ops.cc: New test.\n+\n \tPR libstdc++/77691\n \t* include/experimental/memory_resource (__resource_adaptor_imp): Do\n \tnot allocate sizes smaller than alignment when relying on guaranteed"}, {"sha": "d45d937d3a7a102d40632de52eaee240d216509a", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "patch": "@@ -671,26 +671,34 @@ experimental_headers = \\\n \t${experimental_srcdir}/algorithm \\\n \t${experimental_srcdir}/any \\\n \t${experimental_srcdir}/array \\\n+\t${experimental_srcdir}/buffer \\\n \t${experimental_srcdir}/chrono \\\n \t${experimental_srcdir}/deque \\\n+\t${experimental_srcdir}/executor \\\n \t${experimental_srcdir}/forward_list \\\n \t${experimental_srcdir}/functional \\\n+\t${experimental_srcdir}/internet \\\n+\t${experimental_srcdir}/io_context \\\n \t${experimental_srcdir}/iterator \\\n \t${experimental_srcdir}/list \\\n \t${experimental_srcdir}/map \\\n \t${experimental_srcdir}/memory \\\n \t${experimental_srcdir}/memory_resource \\\n+\t${experimental_srcdir}/net \\\n+\t${experimental_srcdir}/netfwd \\\n \t${experimental_srcdir}/numeric \\\n \t${experimental_srcdir}/optional \\\n \t${experimental_srcdir}/propagate_const \\\n \t${experimental_srcdir}/random \\\n \t${experimental_srcdir}/ratio \\\n \t${experimental_srcdir}/regex \\\n \t${experimental_srcdir}/set \\\n+\t${experimental_srcdir}/socket \\\n \t${experimental_srcdir}/source_location \\\n \t${experimental_srcdir}/string \\\n \t${experimental_srcdir}/string_view \\\n \t${experimental_srcdir}/system_error \\\n+\t${experimental_srcdir}/timer \\\n \t${experimental_srcdir}/tuple \\\n \t${experimental_srcdir}/type_traits \\\n \t${experimental_srcdir}/unordered_map \\\n@@ -704,6 +712,7 @@ experimental_bits_builddir = ./experimental/bits\n experimental_bits_headers = \\\n \t${experimental_bits_srcdir}/erase_if.h \\\n \t${experimental_bits_srcdir}/lfts_config.h \\\n+\t${experimental_bits_srcdir}/net.h \\\n \t${experimental_bits_srcdir}/shared_ptr.h \\\n \t${experimental_bits_srcdir}/string_view.tcc \\\n \t${experimental_bits_filesystem_headers}"}, {"sha": "f872d928d716f288076bef229f0400fa4c958124", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "patch": "@@ -963,26 +963,34 @@ experimental_headers = \\\n \t${experimental_srcdir}/algorithm \\\n \t${experimental_srcdir}/any \\\n \t${experimental_srcdir}/array \\\n+\t${experimental_srcdir}/buffer \\\n \t${experimental_srcdir}/chrono \\\n \t${experimental_srcdir}/deque \\\n+\t${experimental_srcdir}/executor \\\n \t${experimental_srcdir}/forward_list \\\n \t${experimental_srcdir}/functional \\\n+\t${experimental_srcdir}/internet \\\n+\t${experimental_srcdir}/io_context \\\n \t${experimental_srcdir}/iterator \\\n \t${experimental_srcdir}/list \\\n \t${experimental_srcdir}/map \\\n \t${experimental_srcdir}/memory \\\n \t${experimental_srcdir}/memory_resource \\\n+\t${experimental_srcdir}/net \\\n+\t${experimental_srcdir}/netfwd \\\n \t${experimental_srcdir}/numeric \\\n \t${experimental_srcdir}/optional \\\n \t${experimental_srcdir}/propagate_const \\\n \t${experimental_srcdir}/random \\\n \t${experimental_srcdir}/ratio \\\n \t${experimental_srcdir}/regex \\\n \t${experimental_srcdir}/set \\\n+\t${experimental_srcdir}/socket \\\n \t${experimental_srcdir}/source_location \\\n \t${experimental_srcdir}/string \\\n \t${experimental_srcdir}/string_view \\\n \t${experimental_srcdir}/system_error \\\n+\t${experimental_srcdir}/timer \\\n \t${experimental_srcdir}/tuple \\\n \t${experimental_srcdir}/type_traits \\\n \t${experimental_srcdir}/unordered_map \\\n@@ -996,6 +1004,7 @@ experimental_bits_builddir = ./experimental/bits\n experimental_bits_headers = \\\n \t${experimental_bits_srcdir}/erase_if.h \\\n \t${experimental_bits_srcdir}/lfts_config.h \\\n+\t${experimental_bits_srcdir}/net.h \\\n \t${experimental_bits_srcdir}/shared_ptr.h \\\n \t${experimental_bits_srcdir}/string_view.tcc \\\n \t${experimental_bits_filesystem_headers}"}, {"sha": "17bd300ccf2557a463495cc91618999271c2fa64", "filename": "libstdc++-v3/include/experimental/bits/net.h", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fnet.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fnet.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fnet.h?ref=e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "patch": "@@ -0,0 +1,174 @@\n+// Networking implementation details -*- C++ -*-\n+\n+// Copyright (C) 2015-2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file experimental/bits/net.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{experimental/networking}\n+ */\n+\n+#ifndef _GLIBCXX_EXPERIMENTAL_NET_H\n+#define _GLIBCXX_EXPERIMENTAL_NET_H 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus >= 201402L\n+\n+#include <type_traits>\n+#include <system_error>\n+#include <experimental/netfwd>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+namespace experimental\n+{\n+namespace net\n+{\n+inline namespace v1\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /**\n+   * @ingroup networking\n+   * @{\n+   */\n+\n+  template<typename _CompletionToken, typename _Signature, typename>\n+    class async_result;\n+\n+  // A type denoted by DEDUCED in the TS.\n+  template<typename _CompletionToken, typename _Signature>\n+    using __deduced_t = typename\n+      async_result<decay_t<_CompletionToken>, _Signature, void>::return_type;\n+\n+  // Trait to check for construction from const/non-const lvalue/rvalue.\n+  template<typename _Tp>\n+    using __is_value_constructible = typename __and_<\n+      is_copy_constructible<_Tp>, is_move_constructible<_Tp>,\n+      is_constructible<_Tp, _Tp&>, is_constructible<_Tp, const _Tp&&>\n+      >::type;\n+\n+    struct __throw_on_error\n+    {\n+      explicit\n+      __throw_on_error(const char* __msg) : _M_msg(__msg) { }\n+\n+      ~__throw_on_error() noexcept(false)\n+      {\n+\tif (_M_ec)\n+\t  _GLIBCXX_THROW_OR_ABORT(system_error(_M_ec, _M_msg));\n+      }\n+\n+      __throw_on_error(const __throw_on_error&) = delete;\n+      __throw_on_error& operator=(const __throw_on_error&) = delete;\n+\n+      operator error_code&() noexcept { return _M_ec; }\n+\n+      const char* _M_msg;\n+      error_code _M_ec;\n+    };\n+\n+  // Base class for types meeting IntegerSocketOption requirements.\n+  template<typename _Tp>\n+    struct __sockopt_base\n+    {\n+      __sockopt_base() = default;\n+\n+      explicit __sockopt_base(int __val) : _M_value(__val) { }\n+\n+      int value() const noexcept { return _M_value; }\n+\n+      template<typename _Protocol>\n+\tvoid*\n+\tdata(const _Protocol&) noexcept\n+\t{ return std::addressof(_M_value); }\n+\n+      template<typename _Protocol>\n+\tconst void*\n+\tdata(const _Protocol&) const noexcept\n+\t{ return std::addressof(_M_value); }\n+\n+      template<typename _Protocol>\n+\tsize_t\n+\tsize(const _Protocol&) const noexcept\n+\t{ return sizeof(_M_value); }\n+\n+      template<typename _Protocol>\n+\tvoid\n+\tresize(const _Protocol&, size_t __s)\n+\t{\n+\t  if (__s != sizeof(_M_value))\n+\t    __throw_length_error(\"invalid value for socket option resize\");\n+\t}\n+\n+    protected:\n+      _Tp _M_value { };\n+    };\n+\n+  // Base class for types meeting BooleanSocketOption requirements.\n+  template<>\n+    struct __sockopt_base<bool> : __sockopt_base<int>\n+    {\n+      __sockopt_base() = default;\n+\n+      explicit __sockopt_base(bool __val) : __sockopt_base<int>(__val) { }\n+\n+      bool value() const noexcept { return __sockopt_base<int>::_M_value; }\n+      explicit operator bool() const noexcept { return value(); }\n+      bool operator!() const noexcept { return !value(); }\n+    };\n+\n+  template<typename _Derived, typename _Tp = int>\n+    struct __sockopt_crtp : __sockopt_base<_Tp>\n+    {\n+      using __sockopt_base<_Tp>::__sockopt_base;\n+\n+      _Derived&\n+      operator=(_Tp __value)\n+      {\n+\t__sockopt_base<_Tp>::_M_value = __value;\n+\treturn static_cast<_Derived&>(*this);\n+      }\n+\n+      template<typename _Protocol>\n+\tint\n+\tlevel(const _Protocol&) const noexcept\n+\t{ return _Derived::_S_level; }\n+\n+      template<typename _Protocol>\n+\tint\n+\tname(const _Protocol&) const noexcept\n+\t{ return _Derived::_S_name; }\n+    };\n+\n+  /// @}\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace v1\n+} // namespace net\n+} // namespace experimental\n+} // namespace std\n+\n+#endif // C++14\n+\n+#endif // _GLIBCXX_EXPERIMENTAL_NET_H"}, {"sha": "5541823165b911cc4812556de07668e416b38c8c", "filename": "libstdc++-v3/include/experimental/buffer", "status": "added", "additions": 897, "deletions": 0, "changes": 897, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbuffer", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbuffer", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbuffer?ref=e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "patch": "@@ -0,0 +1,897 @@\n+// <experimental/buffer> -*- C++ -*-\n+\n+// Copyright (C) 2015-2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file experimental/buffer\n+ *  This is a TS C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_EXPERIMENTAL_BUFFER\n+#define _GLIBCXX_EXPERIMENTAL_BUFFER 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus >= 201402L\n+\n+#include <array>\n+#include <string>\n+#include <system_error>\n+#include <vector>\n+#include <cstring>\n+#include <experimental/string_view>\n+#include <experimental/bits/net.h>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+namespace experimental\n+{\n+namespace net\n+{\n+inline namespace v1\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /**\n+   * @ingroup networking\n+   * @{\n+   */\n+\n+  enum class stream_errc {    // TODO decide values\n+    eof = 1,\n+    not_found = 2\n+  };\n+\n+  const error_category& stream_category() noexcept // TODO not inline\n+  {\n+    struct __cat : error_category\n+    {\n+      const char* name() const noexcept { return \"stream\"; }\n+\n+      std::string message(int __e) const\n+      {\n+\tif (__e == (int)stream_errc::eof)\n+\t  return \"EOF\";\n+\telse if (__e == (int)stream_errc::not_found)\n+\t  return \"not found\";\n+\treturn \"stream\";\n+      }\n+\n+      virtual void __message(int) { } // TODO dual ABI XXX\n+    };\n+    static __cat __c;\n+    return __c;\n+  }\n+\n+  inline error_code\n+  make_error_code(stream_errc __e) noexcept\n+  { return error_code(static_cast<int>(__e), stream_category()); }\n+\n+  inline error_condition\n+  make_error_condition(stream_errc __e) noexcept\n+  { return error_condition(static_cast<int>(__e), stream_category()); }\n+\n+  class mutable_buffer\n+  {\n+  public:\n+    // constructors:\n+    mutable_buffer() noexcept : _M_data(), _M_size() { }\n+\n+    mutable_buffer(void* __p, size_t __n) noexcept\n+    : _M_data(__p), _M_size(__n) { }\n+\n+    // members:\n+    void* data() const noexcept { return _M_data; }\n+    size_t size() const noexcept { return _M_size; }\n+\n+  private:\n+    void*\t_M_data;\n+    size_t\t_M_size;\n+  };\n+\n+  class const_buffer\n+  {\n+  public:\n+    // constructors:\n+    const_buffer() noexcept : _M_data(), _M_size() { }\n+\n+    const_buffer(const void* __p, size_t __n) noexcept\n+    : _M_data(__p), _M_size(__n) { }\n+\n+    const_buffer(const mutable_buffer& __b) noexcept\n+    : _M_data(__b.data()), _M_size(__b.size()) { }\n+\n+    // members:\n+    const void* data() const noexcept { return _M_data; }\n+    size_t size() const noexcept { return _M_size; }\n+\n+  private:\n+    const void*\t_M_data;\n+    size_t\t_M_size;\n+  };\n+\n+\n+  /** @brief buffer sequence access\n+   *\n+   * Uniform access to types that meet the BufferSequence requirements.\n+   * @{\n+   */\n+\n+  inline const mutable_buffer*\n+  buffer_sequence_begin(const mutable_buffer& __b)\n+  { return std::addressof(__b); }\n+\n+  inline const const_buffer*\n+  buffer_sequence_begin(const const_buffer& __b)\n+  { return std::addressof(__b); }\n+\n+  inline const mutable_buffer*\n+  buffer_sequence_end(const mutable_buffer& __b)\n+  { return std::addressof(__b) + 1; }\n+\n+  inline const const_buffer*\n+  buffer_sequence_end(const const_buffer& __b)\n+  { return std::addressof(__b) + 1; }\n+\n+  template<typename _Cont>\n+    auto\n+    buffer_sequence_begin(_Cont& __c) -> decltype(__c.begin())\n+    { return __c.begin(); }\n+\n+  template<typename _Cont>\n+    auto\n+    buffer_sequence_begin(const _Cont& __c) -> decltype(__c.begin())\n+    { return __c.begin(); }\n+\n+  template<typename _Cont>\n+    auto\n+    buffer_sequence_end(_Cont& __c) -> decltype(__c.end())\n+    { return __c.end(); }\n+\n+  template<typename _Cont>\n+    auto\n+    buffer_sequence_end(const _Cont& __c) -> decltype(__c.end())\n+    { return __c.end(); }\n+\n+  // @}\n+\n+\n+  /** @brief buffer type traits\n+   *\n+   * @{\n+   */\n+\n+  template<typename _Tp, typename _Buffer,\n+\t   typename _Begin\n+\t    = decltype(net::buffer_sequence_begin(std::declval<_Tp&>())),\n+\t   typename _End\n+\t    = decltype(net::buffer_sequence_end(std::declval<_Tp&>()))>\n+    using __buffer_sequence = enable_if_t<__and_<\n+      __is_value_constructible<_Tp>, is_same<_Begin, _End>,\n+      is_convertible<typename iterator_traits<_Begin>::value_type, _Buffer>\n+      >::value>;\n+\n+  template<typename _Tp, typename _Buffer, typename = void>\n+    struct __is_buffer_sequence : false_type\n+    { };\n+\n+  template<typename _Tp, typename _Buffer>\n+    struct __is_buffer_sequence<_Tp, _Buffer, __buffer_sequence<_Tp, _Buffer>>\n+    : true_type\n+    { };\n+\n+  template<typename _Tp>\n+    struct is_mutable_buffer_sequence\n+    : __is_buffer_sequence<_Tp, mutable_buffer>::type\n+    { };\n+\n+  template<typename _Tp>\n+    struct is_const_buffer_sequence\n+    : __is_buffer_sequence<_Tp, const_buffer>::type\n+    { };\n+\n+  template<typename _Tp>\n+    constexpr bool is_mutable_buffer_sequence_v\n+      = is_mutable_buffer_sequence<_Tp>::value;\n+\n+  template<typename _Tp>\n+    constexpr bool is_const_buffer_sequence_v\n+      = is_const_buffer_sequence<_Tp>::value;\n+\n+  template<typename _Tp, typename = void>\n+    struct __is_dynamic_buffer_impl : false_type\n+    { };\n+\n+  // Check DynamicBuffer requirements.\n+  template<typename _Tp, typename _Up = remove_const_t<_Tp>>\n+    auto\n+    __dynamic_buffer_reqs(_Up* __x = 0, const _Up* __x1 = 0, size_t __n = 0)\n+    -> enable_if_t<__and_<\n+      is_move_constructible<_Up>,\n+      is_const_buffer_sequence<typename _Tp::const_buffers_type>,\n+      is_mutable_buffer_sequence<typename _Tp::mutable_buffers_type>,\n+      is_same<decltype(__x1->size()), size_t>,\n+      is_same<decltype(__x1->max_size()), size_t>,\n+      is_same<decltype(__x1->capacity()), size_t>,\n+      is_same<decltype(__x1->data()), typename _Tp::const_buffers_type>,\n+      is_same<decltype(__x->prepare(__n)), typename _Tp::mutable_buffers_type>,\n+      is_void<decltype(__x->commit(__n), __x->consume(__n), void())>\n+    >::value>;\n+\n+  template<typename _Tp>\n+    struct __is_dynamic_buffer_impl<_Tp,\n+\t\t\t\t    decltype(__dynamic_buffer_reqs<_Tp>())>\n+    : true_type\n+    { };\n+\n+  template<typename _Tp>\n+    struct is_dynamic_buffer : __is_dynamic_buffer_impl<_Tp>::type\n+    { };\n+\n+  template<typename _Tp>\n+    constexpr bool is_dynamic_buffer_v = is_dynamic_buffer<_Tp>::value;\n+\n+  // @}\n+\n+  /// buffer size\n+  template<typename _ConstBufferSequence>\n+    size_t\n+    buffer_size(const _ConstBufferSequence& __buffers) noexcept\n+    {\n+      size_t __total_size = 0;\n+      auto __i = net::buffer_sequence_begin(__buffers);\n+      const auto __end = net::buffer_sequence_end(__buffers);\n+      for (; __i != __end; ++__i)\n+\t__total_size += const_buffer(*__i).size();\n+      return __total_size;\n+    }\n+\n+  template<typename _ConstBufferSequence>\n+    bool\n+    __buffer_empty(const _ConstBufferSequence& __buffers) noexcept\n+    {\n+      auto __i = net::buffer_sequence_begin(__buffers);\n+      const auto __end = net::buffer_sequence_end(__buffers);\n+      for (; __i != __end; ++__i)\n+\tif (const_buffer(*__i).size() != 0)\n+\t  return false;\n+      return true;\n+    }\n+\n+  // buffer copy:\n+\n+  template<typename _MutableBufferSequence, typename _ConstBufferSequence>\n+    size_t\n+    buffer_copy(const _MutableBufferSequence& __dest,\n+\t\tconst _ConstBufferSequence& __source,\n+\t\tsize_t __max_size) noexcept\n+    {\n+      size_t __total_size = 0;\n+      auto __to_i = net::buffer_sequence_begin(__dest);\n+      const auto __to_end = net::buffer_sequence_end(__dest);\n+      auto __from_i = net::buffer_sequence_begin(__source);\n+      const auto __from_end = net::buffer_sequence_end(__source);\n+      mutable_buffer __to;\n+      const_buffer __from;\n+      while (((__from_i != __from_end && __to_i != __to_end)\n+\t    || (__from.size() && __to.size()))\n+\t  && __total_size < __max_size)\n+\t{\n+\t  if (__from.size() == 0)\n+\t    __from = const_buffer{*__from_i++};\n+\t  if (__to.size() == 0)\n+\t    __to = mutable_buffer{*__to_i++};\n+\n+\t  size_t __n = std::min(__from.size(), __to.size());\n+\t  __n = std::min(__n, __max_size - __total_size);\n+\t  std::memcpy(__to.data(), __from.data(), __n);\n+\t  __from = { (const char*)__from.data() + __n, __from.size() - __n };\n+\t  __to = { (char*)__to.data() + __n, __to.size() - __n };\n+\t  __total_size += __n;\n+\t}\n+      return __total_size;\n+    }\n+\n+  template<typename _MutableBufferSequence, typename _ConstBufferSequence>\n+    inline size_t\n+    buffer_copy(const _MutableBufferSequence& __dest,\n+\t\tconst _ConstBufferSequence& __source) noexcept\n+    { return net::buffer_copy(__dest, __source, size_t{-1}); }\n+\n+\n+  // buffer arithmetic:\n+\n+  inline mutable_buffer\n+  operator+(const mutable_buffer& __b, size_t __n) noexcept\n+  {\n+    if (__n > __b.size())\n+      __n = __b.size();\n+    return { static_cast<char*>(__b.data()) + __n, __b.size() - __n };\n+  }\n+\n+  inline mutable_buffer\n+  operator+(size_t __n, const mutable_buffer& __b) noexcept\n+  { return __b + __n; }\n+\n+  inline const_buffer\n+  operator+(const const_buffer& __b, size_t __n) noexcept\n+  {\n+    if (__n > __b.size())\n+      __n = __b.size();\n+    return { static_cast<const char*>(__b.data()) + __n, __b.size() - __n };\n+  }\n+\n+  inline const_buffer\n+  operator+(size_t __n, const const_buffer& __b) noexcept\n+  { return __b + __n; }\n+\n+  // buffer creation:\n+\n+  inline mutable_buffer\n+  buffer(void* __p, size_t __n) noexcept\n+  { return { __p, __n }; }\n+\n+  inline const_buffer\n+  buffer(const void* __p, size_t __n) noexcept\n+  { return { __p, __n }; }\n+\n+  inline mutable_buffer\n+  buffer(const mutable_buffer& __b) noexcept\n+  { return __b; }\n+\n+  inline mutable_buffer\n+  buffer(const mutable_buffer& __b, size_t __n) noexcept\n+  { return { __b.data(), std::min(__b.size(), __n) }; }\n+\n+  inline const_buffer\n+  buffer(const const_buffer& __b) noexcept\n+  { return __b; }\n+\n+  inline const_buffer\n+  buffer(const const_buffer& __b, size_t __n) noexcept\n+  { return { __b.data(), std::min(__b.size(), __n) }; }\n+\n+  template<typename _Tp>\n+    inline mutable_buffer\n+    __to_mbuf(_Tp* __data, size_t __n)\n+    { return { __n ? __data : nullptr, __n * sizeof(_Tp) }; }\n+\n+  template<typename _Tp>\n+    inline const_buffer\n+    __to_cbuf(const _Tp* __data, size_t __n)\n+    { return { __n ? __data : nullptr, __n * sizeof(_Tp) }; }\n+\n+  template<typename _Tp, size_t _Nm>\n+    inline mutable_buffer\n+    buffer(_Tp (&__data)[_Nm]) noexcept\n+    { return net::__to_mbuf(__data, _Nm); }\n+\n+  template<typename _Tp, size_t _Nm>\n+    inline const_buffer\n+    buffer(const _Tp (&__data)[_Nm]) noexcept\n+    { return net::__to_cbuf(__data, _Nm); }\n+\n+  template<typename _Tp, size_t _Nm>\n+    inline mutable_buffer\n+    buffer(array<_Tp, _Nm>& __data) noexcept\n+    { return net::__to_mbuf(__data.data(), _Nm); }\n+\n+  template<typename _Tp, size_t _Nm>\n+    inline const_buffer\n+    buffer(array<const _Tp, _Nm>& __data) noexcept\n+    { return net::__to_cbuf(__data.data(), __data.size()); }\n+\n+  template<typename _Tp, size_t _Nm>\n+    inline const_buffer\n+    buffer(const array<_Tp, _Nm>& __data) noexcept\n+    { return net::__to_cbuf(__data.data(), __data.size()); }\n+\n+  template<typename _Tp, typename _Allocator>\n+    inline mutable_buffer\n+    buffer(vector<_Tp, _Allocator>& __data) noexcept\n+    { return net::__to_mbuf(__data.data(), __data.size()); }\n+\n+  template<typename _Tp, typename _Allocator>\n+    inline const_buffer\n+    buffer(const vector<_Tp, _Allocator>& __data) noexcept\n+    { return net::__to_cbuf(__data.data(), __data.size()); }\n+\n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline mutable_buffer\n+    buffer(basic_string<_CharT, _Traits, _Allocator>& __data) noexcept\n+    { return net::__to_mbuf(&__data.front(), __data.size()); }\n+\n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline const_buffer\n+    buffer(const basic_string<_CharT, _Traits, _Allocator>& __data) noexcept\n+    { return net::__to_cbuf(&__data.front(), __data.size()); }\n+\n+  template<typename _CharT, typename _Traits>\n+    inline const_buffer\n+    buffer(basic_string_view<_CharT, _Traits> __data) noexcept\n+    { return net::__to_cbuf(__data.data(), __data.size()); }\n+\n+  template<typename _Tp, size_t _Nm>\n+    inline mutable_buffer\n+    buffer(_Tp (&__data)[_Nm], size_t __n) noexcept\n+    { return buffer(net::buffer(__data), __n * sizeof(_Tp)); }\n+\n+  template<typename _Tp, size_t _Nm>\n+    inline const_buffer\n+    buffer(const _Tp (&__data)[_Nm], size_t __n) noexcept\n+    { return buffer(net::buffer(__data), __n * sizeof(_Tp)); }\n+\n+  template<typename _Tp, size_t _Nm>\n+    inline mutable_buffer\n+    buffer(array<_Tp, _Nm>& __data, size_t __n) noexcept\n+    { return buffer(net::buffer(__data), __n * sizeof(_Tp)); }\n+\n+  template<typename _Tp, size_t _Nm>\n+    inline const_buffer\n+    buffer(array<const _Tp, _Nm>& __data, size_t __n) noexcept\n+    { return buffer(net::buffer(__data), __n * sizeof(_Tp)); }\n+\n+  template<typename _Tp, size_t _Nm>\n+    inline const_buffer\n+    buffer(const array<_Tp, _Nm>& __data, size_t __n) noexcept\n+    { return buffer(net::buffer(__data), __n * sizeof(_Tp)); }\n+\n+  template<typename _Tp, typename _Allocator>\n+    inline mutable_buffer\n+    buffer(vector<_Tp, _Allocator>& __data, size_t __n) noexcept\n+    { return buffer(net::buffer(__data), __n * sizeof(_Tp)); }\n+\n+  template<typename _Tp, typename _Allocator>\n+    inline const_buffer\n+    buffer(const vector<_Tp, _Allocator>& __data, size_t __n) noexcept\n+    { return buffer(net::buffer(__data), __n * sizeof(_Tp)); }\n+\n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline mutable_buffer\n+    buffer(basic_string<_CharT, _Traits, _Allocator>& __data,\n+\t   size_t __n) noexcept\n+    { return buffer(net::buffer(__data), __n * sizeof(_CharT)); }\n+\n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline const_buffer\n+    buffer(const basic_string<_CharT, _Traits, _Allocator>& __data,\n+\t   size_t __n) noexcept\n+    { return buffer(net::buffer(__data), __n * sizeof(_CharT)); }\n+\n+  template<typename _CharT, typename _Traits>\n+    inline const_buffer\n+    buffer(basic_string_view<_CharT, _Traits> __data, size_t __n) noexcept\n+    { return buffer(net::buffer(__data), __n * sizeof(_CharT)); }\n+\n+\n+  template<typename _Sequence>\n+    class __dynamic_buffer_base\n+    {\n+    public:\n+      // types:\n+      typedef const_buffer const_buffers_type;\n+      typedef mutable_buffer mutable_buffers_type;\n+\n+      // constructors:\n+      explicit\n+      __dynamic_buffer_base(_Sequence& __seq) noexcept\n+      : _M_seq(__seq), _M_size(__seq.size()), _M_max_size(__seq.max_size())\n+      { }\n+\n+      __dynamic_buffer_base(_Sequence& __seq, size_t __maximum_size) noexcept\n+      : _M_seq(__seq), _M_size(__seq.size()), _M_max_size(__maximum_size)\n+      { __glibcxx_assert(__seq.size() <= __maximum_size); }\n+\n+      __dynamic_buffer_base(__dynamic_buffer_base&&) = default;\n+\n+      // members:\n+      size_t size() const noexcept { return _M_size; }\n+      size_t max_size() const noexcept { return _M_max_size; }\n+      size_t capacity() const noexcept { return _M_seq.capacity(); }\n+\n+      const_buffers_type\n+      data() const noexcept\n+      { return net::buffer(_M_seq, _M_size); }\n+\n+      mutable_buffers_type\n+      prepare(size_t __n)\n+      {\n+\tif ((_M_size + __n) > _M_max_size)\n+\t  __throw_length_error(\"dynamic_vector_buffer::prepare\");\n+\n+\t_M_seq.resize(_M_size + __n);\n+\treturn buffer(net::buffer(_M_seq) + _M_size, __n);\n+      }\n+\n+      void\n+      commit(size_t __n)\n+      {\n+\t_M_size += std::min(__n, _M_seq.size() - _M_size);\n+\t_M_seq.resize(_M_size);\n+      }\n+\n+      void\n+      consume(size_t __n)\n+      {\n+\tsize_t __m = std::min(__n, _M_size);\n+\t_M_seq.erase(_M_seq.begin(), _M_seq.begin() + __m);\n+\t_M_size -= __m;\n+      }\n+\n+    private:\n+      _Sequence&\t_M_seq;\n+      size_t\t\t_M_size;\n+      const size_t\t_M_max_size;\n+    };\n+\n+  template<typename _Tp, typename _Allocator>\n+    class dynamic_vector_buffer\n+    : public __dynamic_buffer_base<vector<_Tp, _Allocator>>\n+    {\n+    public:\n+      using __dynamic_buffer_base<vector<_Tp, _Allocator>>::__dynamic_buffer_base;\n+    };\n+\n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    class dynamic_string_buffer\n+    : public __dynamic_buffer_base<basic_string<_CharT, _Traits, _Allocator>>\n+    {\n+    public:\n+      using __dynamic_buffer_base<basic_string<_CharT, _Traits, _Allocator>>::\n+\t__dynamic_buffer_base;\n+    };\n+\n+  // dynamic buffer creation:\n+\n+  template<typename _Tp, typename _Allocator>\n+    inline dynamic_vector_buffer<_Tp, _Allocator>\n+    dynamic_buffer(vector<_Tp, _Allocator>& __vec) noexcept\n+    { return dynamic_vector_buffer<_Tp, _Allocator>{__vec}; }\n+\n+  template<typename _Tp, typename _Allocator>\n+    inline dynamic_vector_buffer<_Tp, _Allocator>\n+    dynamic_buffer(vector<_Tp, _Allocator>& __vec, size_t __n) noexcept\n+    { return {__vec, __n}; }\n+\n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline dynamic_string_buffer<_CharT, _Traits, _Allocator>\n+    dynamic_buffer(basic_string<_CharT, _Traits, _Allocator>& __str) noexcept\n+    { return dynamic_string_buffer<_CharT, _Traits, _Allocator>{__str}; }\n+\n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline dynamic_string_buffer<_CharT, _Traits, _Allocator>\n+    dynamic_buffer(basic_string<_CharT, _Traits, _Allocator>& __str,\n+\t\t   size_t __n) noexcept\n+    { return {__str, __n}; }\n+\n+  class transfer_all\n+  {\n+  public:\n+    size_t operator()(const error_code& __ec, size_t) const\n+    { return !__ec ? 1500 : 0; }\n+  };\n+\n+  class transfer_at_least\n+  {\n+  public:\n+    explicit transfer_at_least(size_t __m) : _M_minimum(__m) { }\n+\n+    size_t operator()(const error_code& __ec, size_t __n) const\n+    { return !__ec  && __n < _M_minimum ? _M_minimum - __n : 0; }\n+\n+  private:\n+    size_t _M_minimum;\n+  };\n+\n+  class transfer_exactly\n+  {\n+  public:\n+    explicit transfer_exactly(size_t __e) : _M_exact(__e) { }\n+\n+    size_t operator()(const error_code& __ec, size_t __n) const\n+    {\n+      size_t _Nm = -1;\n+      return !__ec  && __n < _M_exact ? std::min(_M_exact - __n, _Nm) : 0;\n+    }\n+\n+  private:\n+    size_t _M_exact;\n+  };\n+\n+  /** @brief synchronous read operations\n+   * @{\n+   */\n+\n+  template<typename _SyncReadStream, typename _MutableBufferSequence,\n+\t   typename _CompletionCondition>\n+    enable_if_t<is_mutable_buffer_sequence<_MutableBufferSequence>::value,\n+\t\tsize_t>\n+    read(_SyncReadStream& __stream, const _MutableBufferSequence& __buffers,\n+\t _CompletionCondition __completion_condition, error_code& __ec)\n+    {\n+      __ec.clear();\n+      auto __i = net::buffer_sequence_begin(__buffers);\n+      auto __end = net::buffer_sequence_end(__buffers);\n+      mutable_buffer __to;\n+      size_t __total = 0;\n+      size_t __n;\n+      while ((__n = __completion_condition(__ec, __total))\n+\t  && (__i != __end || __to.size()))\n+\t{\n+\t  if (__to.size() == 0)\n+\t    __to = mutable_buffer(*__i++);\n+\t  __n = __stream.read_some(buffer(__to, __n), __ec);\n+\t  __to = __to + __n;\n+\t  __total += __n;\n+\t}\n+      return __total;\n+    }\n+\n+  template<typename _SyncReadStream, typename _MutableBufferSequence>\n+    inline\n+    enable_if_t<is_mutable_buffer_sequence<_MutableBufferSequence>::value,\n+\t\tsize_t>\n+    read(_SyncReadStream& __stream, const _MutableBufferSequence& __buffers)\n+    {\n+      error_code __ec;\n+      return net::read(__stream, __buffers, transfer_all{}, __ec);\n+    }\n+\n+  template<typename _SyncReadStream, typename _MutableBufferSequence>\n+    inline\n+    enable_if_t<is_mutable_buffer_sequence<_MutableBufferSequence>::value,\n+\t\tsize_t>\n+    read(_SyncReadStream& __stream, const _MutableBufferSequence& __buffers,\n+\t error_code& __ec)\n+    { return net::read(__stream, __buffers, transfer_all{}, __ec); }\n+\n+  template<typename _SyncReadStream, typename _MutableBufferSequence,\n+\t   typename _CompletionCondition>\n+    inline\n+    enable_if_t<is_mutable_buffer_sequence<_MutableBufferSequence>::value,\n+\t\tsize_t>\n+    read(_SyncReadStream& __stream, const _MutableBufferSequence& __buffers,\n+\t _CompletionCondition __completion_condition)\n+    {\n+      error_code __ec;\n+      return net::read(__stream, __buffers, __completion_condition, __ec);\n+    }\n+\n+\n+  template<typename _SyncReadStream, typename _DynamicBuffer,\n+\t   typename _CompletionCondition>\n+    enable_if_t<is_dynamic_buffer<decay_t<_DynamicBuffer>>::value, size_t>\n+    read(_SyncReadStream& __stream, _DynamicBuffer&& __b,\n+\t _CompletionCondition __completion_condition, error_code& __ec)\n+    {\n+      const size_t __limit = 64;\n+      __ec.clear();\n+      size_t __cap = std::max(__b.capacity() - __b.size(), __limit);\n+      size_t __total = 0;\n+      size_t __n;\n+      while ((__n = __completion_condition(__ec, __total))\n+\t  && __b.size() != __b.max_size())\n+\t{\n+\t  __n =  std::min(__n, __b.max_size() - __b.size());\n+\t  size_t __cap = std::max(__b.capacity() - __b.size(), __limit);\n+\t  mutable_buffer __to = __b.prepare(std::min(__cap, __n));\n+\t  __n = __stream.read_some(__to, __ec);\n+\t  __to = __to + __n;\n+\t  __total += __n;\n+\t  __b.commit(__n);\n+\t}\n+      return __total;\n+    }\n+\n+  template<typename _SyncReadStream, typename _DynamicBuffer>\n+    inline enable_if_t<is_dynamic_buffer<_DynamicBuffer>::value, size_t>\n+    read(_SyncReadStream& __stream, _DynamicBuffer&& __b)\n+    {\n+      error_code __ec;\n+      return net::read(__stream, __b, transfer_all{}, __ec);\n+    }\n+\n+  template<typename _SyncReadStream, typename _DynamicBuffer>\n+    inline enable_if_t<is_dynamic_buffer<_DynamicBuffer>::value, size_t>\n+    read(_SyncReadStream& __stream, _DynamicBuffer&& __b, error_code& __ec)\n+    {\n+      return net::read(__stream, __b, transfer_all{}, __ec);\n+    }\n+\n+  template<typename _SyncReadStream, typename _DynamicBuffer,\n+\t   typename _CompletionCondition>\n+    inline enable_if_t<is_dynamic_buffer<_DynamicBuffer>::value, size_t>\n+    read(_SyncReadStream& __stream, _DynamicBuffer&& __b,\n+\t _CompletionCondition __completion_condition)\n+    {\n+      error_code __ec;\n+      return net::read(__stream, __b, __completion_condition, __ec);\n+    }\n+\n+  // @}\n+\n+  /** @brief asynchronous read operations\n+   * @{\n+   */\n+\n+  template<typename _AsyncReadStream, typename _MutableBufferSequence,\n+\t   typename _CompletionCondition, typename _CompletionToken>\n+    __deduced_t<_CompletionToken, void(error_code, size_t)>\n+    async_read(_AsyncReadStream& __stream,\n+\t       const _MutableBufferSequence& __buffers,\n+\t       _CompletionCondition __completion_condition,\n+\t       _CompletionToken&& __token)\n+    {\n+      error_code __ec;\n+    }\n+\n+  template<typename _AsyncReadStream, typename _MutableBufferSequence,\n+\t   typename _CompletionToken>\n+    inline __deduced_t<_CompletionToken, void(error_code, size_t)>\n+    async_read(_AsyncReadStream& __stream,\n+\t       const _MutableBufferSequence& __buffers,\n+\t       _CompletionToken&& __token)\n+    {\n+      return net::async_read(__stream, __buffers, transfer_all{},\n+\t\t\t     std::forward<_CompletionToken>(__token));\n+    }\n+\n+  template<typename _AsyncReadStream, typename _DynamicBuffer,\n+\t   typename _CompletionCondition, typename _CompletionToken>\n+    __deduced_t<_CompletionToken, void(error_code, size_t)>\n+    async_read(_AsyncReadStream& __stream, _DynamicBuffer&& __b,\n+\t       _CompletionCondition __completion_condition,\n+\t       _CompletionToken&& __token)\n+    {\n+      error_code __ec;\n+    }\n+\n+  template<typename _AsyncReadStream, typename _DynamicBuffer,\n+\t   typename _CompletionToken>\n+    inline __deduced_t<_CompletionToken, void(error_code, size_t)>\n+    async_read(_AsyncReadStream& __stream, _DynamicBuffer&& __b,\n+\t       _CompletionToken&& __token)\n+    {\n+      return net::async_read(__stream, __b, transfer_all{},\n+\t\t\t     std::forward<_CompletionToken>(__token));\n+    }\n+\n+  // @}\n+\n+#if 0\n+  /** @brief synchronous write operations:\n+   * @{\n+   */\n+\n+  template<typename _SyncWriteStream, typename _ConstBufferSequence>\n+    size_t write(_SyncWriteStream& __stream,\n+                 const _ConstBufferSequence& __buffers);\n+  template<typename _SyncWriteStream, typename _ConstBufferSequence>\n+    size_t write(_SyncWriteStream& __stream,\n+                 const _ConstBufferSequence& __buffers, error_code& __ec);\n+  template<typename _SyncWriteStream, typename _ConstBufferSequence,\n+    typename _CompletionCondition>\n+      size_t write(_SyncWriteStream& __stream,\n+                   const _ConstBufferSequence& __buffers,\n+                   _CompletionCondition __completion_condition);\n+  template<typename _SyncWriteStream, typename _ConstBufferSequence,\n+    typename _CompletionCondition>\n+      size_t write(_SyncWriteStream& __stream,\n+                   const _ConstBufferSequence& __buffers,\n+                   _CompletionCondition __completion_condition,\n+                   error_code& __ec);\n+\n+  template<typename _SyncWriteStream, typename _DynamicBuffer>\n+    size_t write(_SyncWriteStream& __stream, _DynamicBuffer&& __b);\n+  template<typename _SyncWriteStream, typename _DynamicBuffer>\n+    size_t write(_SyncWriteStream& __stream, _DynamicBuffer&& __b, error_code& __ec);\n+  template<typename _SyncWriteStream, typename _DynamicBuffer, typename _CompletionCondition>\n+    size_t write(_SyncWriteStream& __stream, _DynamicBuffer&& __b,\n+                 _CompletionCondition __completion_condition);\n+  template<typename _SyncWriteStream, typename _DynamicBuffer, typename _CompletionCondition>\n+    size_t write(_SyncWriteStream& __stream, _DynamicBuffer&& __b,\n+                 _CompletionCondition __completion_condition, error_code& __ec);\n+\n+  // @}\n+\n+  /** @brief asynchronous write operations\n+   * @{\n+   */\n+\n+  template<typename _AsyncWriteStream, typename _ConstBufferSequence,\n+    typename _CompletionToken>\n+      DEDUCED async_write(_AsyncWriteStream& __stream,\n+                       const _ConstBufferSequence& __buffers,\n+                       _CompletionToken&& __token);\n+  template<typename _AsyncWriteStream, typename _ConstBufferSequence,\n+    typename _CompletionCondition, typename _CompletionToken>\n+      DEDUCED async_write(_AsyncWriteStream& __stream,\n+                       const _ConstBufferSequence& __buffers,\n+                       _CompletionCondition __completion_condition,\n+                       _CompletionToken&& __token);\n+\n+  template<typename _AsyncWriteStream, typename _DynamicBuffer, typename _CompletionToken>\n+    DEDUCED async_write(_AsyncWriteStream& __stream,\n+                     _DynamicBuffer&& __b, _CompletionToken&& __token);\n+  template<typename _AsyncWriteStream, typename _DynamicBuffer,\n+    typename _CompletionCondition, typename _CompletionToken>\n+      DEDUCED async_write(_AsyncWriteStream& __stream,\n+                       _DynamicBuffer&& __b,\n+                       _CompletionCondition __completion_condition,\n+                       _CompletionToken&& __token);\n+\n+  // @}\n+\n+  /** @brief synchronous delimited read operations\n+   * @{\n+   */\n+\n+  template<typename _SyncReadStream, typename _DynamicBuffer>\n+    size_t read_until(_SyncReadStream& __s, _DynamicBuffer&& __b, char __delim);\n+  template<typename _SyncReadStream, typename _DynamicBuffer>\n+    size_t read_until(_SyncReadStream& __s, _DynamicBuffer&& __b,\n+                      char __delim, error_code& __ec);\n+  template<typename _SyncReadStream, typename _DynamicBuffer>\n+    size_t read_until(_SyncReadStream& __s, _DynamicBuffer&& __b, string_view __delim);\n+  template<typename _SyncReadStream, typename _DynamicBuffer>\n+    size_t read_until(_SyncReadStream& __s, _DynamicBuffer&& __b,\n+                      string_view __delim, error_code& __ec);\n+\n+  // @}\n+\n+  /** @brief asynchronous delimited read operations\n+   * @{\n+   */\n+\n+  template<typename _AsyncReadStream, typename _DynamicBuffer, typename _CompletionToken>\n+    DEDUCED async_read_until(_AsyncReadStream& __s,\n+                          _DynamicBuffer&& __b, char __delim,\n+                          _CompletionToken&& __token);\n+  template<typename _AsyncReadStream, typename _DynamicBuffer, typename _CompletionToken>\n+    DEDUCED async_read_until(_AsyncReadStream& __s,\n+                          _DynamicBuffer&& __b, string_view __delim,\n+                          _CompletionToken&& __token);\n+\n+  // @}\n+\n+#endif\n+  /// @}\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+\n+} // namespace v1\n+} // namespace net\n+} // namespace experimental\n+\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  template<>\n+    struct is_error_code_enum<experimental::net::v1::stream_errc>\n+    : public true_type {};\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+\n+} // namespace std\n+\n+#endif // C++14\n+\n+#endif // _GLIBCXX_EXPERIMENTAL_BUFFER"}, {"sha": "cd4adb58b0d97f0e32654c1847aa24dfc4eec122", "filename": "libstdc++-v3/include/experimental/executor", "status": "added", "additions": 1887, "deletions": 0, "changes": 1887, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fexecutor", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fexecutor", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fexecutor?ref=e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "patch": "@@ -0,0 +1,1887 @@\n+// <experimental/executor> -*- C++ -*-\n+\n+// Copyright (C) 2015-2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file experimental/executor\n+ *  This is a TS C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_EXPERIMENTAL_EXECUTOR\n+#define _GLIBCXX_EXPERIMENTAL_EXECUTOR 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus >= 201402L\n+\n+#include <algorithm>\n+#include <functional>\n+#include <future>\n+#include <list>\n+#include <mutex>\n+#include <queue>\n+#include <thread>\n+#include <tuple>\n+#include <unordered_map>\n+#include <utility>\n+#include <experimental/netfwd>\n+#include <bits/unique_ptr.h>\n+#include <experimental/bits/net.h>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+namespace experimental\n+{\n+namespace net\n+{\n+inline namespace v1\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /**\n+   * @ingroup networking\n+   * @{\n+   */\n+\n+  /// Customization point for asynchronous operations.\n+  template<typename _CompletionToken, typename _Signature, typename = void>\n+    class async_result;\n+\n+  /// Convenience utility to help implement asynchronous operations.\n+  template<typename _CompletionToken, typename _Signature>\n+    class async_completion;\n+\n+  template<typename _Tp, typename _ProtoAlloc, typename = __void_t<>>\n+    struct __associated_allocator_impl\n+    {\n+      using type = _ProtoAlloc;\n+\n+      static type\n+      _S_get(const _Tp&, const _ProtoAlloc& __a) noexcept { return __a; }\n+    };\n+\n+  template<typename _Tp, typename _ProtoAlloc>\n+    struct __associated_allocator_impl<_Tp, _ProtoAlloc,\n+\t\t\t\t       __void_t<typename _Tp::allocator_type>>\n+    {\n+      using type = typename _Tp::allocator_type;\n+\n+      static type\n+      _S_get(const _Tp& __t, const _ProtoAlloc&) noexcept\n+      { return __t.get_allocator(); }\n+    };\n+\n+  /// Helper to associate an allocator with a type.\n+  template<typename _Tp, typename _ProtoAllocator = allocator<void>>\n+    struct associated_allocator\n+    : __associated_allocator_impl<_Tp, _ProtoAllocator>\n+    {\n+      static auto\n+      get(const _Tp& __t,\n+\t  const _ProtoAllocator& __a = _ProtoAllocator()) noexcept\n+      {\n+\tusing _Impl = __associated_allocator_impl<_Tp, _ProtoAllocator>;\n+\treturn _Impl::_S_get(__t, __a);\n+      }\n+    };\n+\n+  /// Alias template for associated_allocator.\n+  template<typename _Tp, typename _ProtoAllocator = allocator<void>>\n+    using associated_allocator_t\n+      = typename associated_allocator<_Tp, _ProtoAllocator>::type;\n+\n+  // get_associated_allocator:\n+\n+  template<typename _Tp>\n+    inline associated_allocator_t<_Tp>\n+    get_associated_allocator(const _Tp& __t) noexcept\n+    { return associated_allocator<_Tp>::get(__t); }\n+\n+  template<typename _Tp, typename _ProtoAllocator>\n+    inline associated_allocator_t<_Tp, _ProtoAllocator>\n+    get_associated_allocator(const _Tp& __t,\n+\t\t\t     const _ProtoAllocator& __a) noexcept\n+    { return associated_allocator<_Tp, _ProtoAllocator>::get(__t, __a); }\n+\n+  enum class fork_event { prepare, parent, child };\n+\n+  /// An extensible, type-safe, polymorphic set of services.\n+  class execution_context;\n+\n+  class service_already_exists : public logic_error { };\n+\n+  template<typename _Tp> struct is_executor;\n+\n+  struct executor_arg_t { };\n+\n+  constexpr executor_arg_t executor_arg = executor_arg_t();\n+\n+  /// Trait for determining whether to construct an object with an executor.\n+  template<typename _Tp, typename _Executor> struct uses_executor;\n+\n+  template<typename _Tp, typename _Executor, typename = __void_t<>>\n+    struct __associated_executor_impl\n+    {\n+      using type = _Executor;\n+\n+      static type\n+      _S_get(const _Tp&, const _Executor& __e) noexcept { return __e; }\n+    };\n+\n+  template<typename _Tp, typename _Executor>\n+    struct __associated_executor_impl<_Tp, _Executor,\n+\t\t\t\t       __void_t<typename _Tp::executor_type>>\n+    {\n+      using type = typename _Tp::executor_type;\n+\n+      static type\n+      _S_get(const _Tp& __t, const _Executor&) noexcept\n+      { return __t.get_executor(); }\n+    };\n+\n+  /// Helper to associate an executor with a type.\n+  template<typename _Tp, typename _Executor = system_executor>\n+    struct associated_executor\n+    : __associated_executor_impl<_Tp, _Executor>\n+    {\n+      static auto\n+      get(const _Tp& __t, const _Executor& __e = _Executor()) noexcept\n+      { return __associated_executor_impl<_Tp, _Executor>::_S_get(__t, __e); }\n+    };\n+\n+\n+  template<typename _Tp, typename _Executor = system_executor>\n+    using associated_executor_t\n+      = typename associated_executor<_Tp, _Executor>::type;\n+\n+  template<typename _ExecutionContext>\n+    using __is_exec_context\n+      = is_convertible<_ExecutionContext&, execution_context&>;\n+\n+  template<typename _Tp>\n+    using __executor_t = typename _Tp::executor_type;\n+\n+  // get_associated_executor:\n+\n+  template<typename _Tp>\n+    inline associated_executor_t<_Tp>\n+    get_associated_executor(const _Tp& __t) noexcept\n+    { return associated_executor<_Tp>::get(__t); }\n+\n+  template<typename _Tp, typename _Executor>\n+    inline\n+    enable_if_t<is_executor<_Executor>::value,\n+\t\tassociated_executor_t<_Tp, _Executor>>\n+    get_associated_executor(const _Tp& __t, const _Executor& __ex)\n+    { return associated_executor<_Tp, _Executor>::get(__t, __ex); }\n+\n+  template<typename _Tp, typename _ExecutionContext>\n+    inline\n+    enable_if_t<__is_exec_context<_ExecutionContext>::value,\n+\t\tassociated_executor_t<_Tp, __executor_t<_ExecutionContext>>>\n+    get_associated_executor(const _Tp& __t, _ExecutionContext& __ctx) noexcept\n+    { return net::get_associated_executor(__t, __ctx.get_executor()); }\n+\n+\n+  /// Helper to bind an executor to an object or function.\n+  template<typename _Tp, typename _Executor>\n+    class executor_binder;\n+\n+  template<typename _Tp, typename _Executor, typename _Signature>\n+    class async_result<executor_binder<_Tp, _Executor>, _Signature>;\n+\n+  template<typename _Tp, typename _Executor, typename _ProtoAllocator>\n+    struct associated_allocator<executor_binder<_Tp, _Executor>,\n+\t\t\t\t_ProtoAllocator>;\n+\n+  template<typename _Tp, typename _Executor, typename _Executor1>\n+    struct associated_executor<executor_binder<_Tp, _Executor>, _Executor1>;\n+\n+  // bind_executor:\n+\n+  template<typename _Executor, typename _Tp>\n+    inline\n+    enable_if_t<is_executor<_Executor>::value,\n+\t\texecutor_binder<decay_t<_Tp>, _Executor>>\n+    bind_executor(const _Executor& __ex, _Tp&& __t)\n+    { return { std::forward<_Tp>(__t), __ex }; }\n+\n+  template<typename _ExecutionContext, typename _Tp>\n+    inline\n+    enable_if_t<__is_exec_context<_ExecutionContext>::value,\n+\t\texecutor_binder<decay_t<_Tp>, __executor_t<_ExecutionContext>>>\n+    bind_executor(_ExecutionContext& __ctx, _Tp&& __t)\n+    { return { __ctx.get_executor(), forward<_Tp>(__t) }; }\n+\n+\n+  /// A scope-guard type to record when work is started and finished.\n+  template<typename _Executor>\n+    class executor_work_guard;\n+\n+  // make_work_guard:\n+\n+  template<typename _Executor>\n+    inline\n+    enable_if_t<is_executor<_Executor>::value, executor_work_guard<_Executor>>\n+    make_work_guard(const _Executor& __ex)\n+    { return executor_work_guard<_Executor>(__ex); }\n+\n+  template<typename _ExecutionContext>\n+    inline\n+    enable_if_t<__is_exec_context<_ExecutionContext>::value,\n+\t\texecutor_work_guard<__executor_t<_ExecutionContext>>>\n+    make_work_guard(_ExecutionContext& __ctx)\n+    { return net::make_work_guard(__ctx.get_executor()); }\n+\n+  template<typename _Tp>\n+    inline\n+    enable_if_t<__not_<__or_<is_executor<_Tp>, __is_exec_context<_Tp>>>::value,\n+\t\texecutor_work_guard<associated_executor_t<_Tp>>>\n+    make_work_guard(const _Tp& __t)\n+    { return net::get_associated_executor(__t); }\n+\n+  template<typename _Tp, typename _Up>\n+    auto\n+    make_work_guard(const _Tp& __t, _Up&& __u)\n+    -> decltype(net::make_work_guard(\n+\t  net::get_associated_executor(__t, forward<_Up>(__u))))\n+    {\n+      return net::make_work_guard(\n+\t  net::get_associated_executor(__t, forward<_Up>(__u)));\n+    }\n+\n+  /// Allows function objects to execute on any thread.\n+  class system_executor;\n+\n+  /// The execution context associated with system_executor objects.\n+  class system_context;\n+\n+  inline bool\n+  operator==(const system_executor&, const system_executor&) { return true; }\n+\n+  inline bool\n+  operator!=(const system_executor&, const system_executor&) { return false; }\n+\n+  /// Exception thrown by empty executors.\n+  class bad_executor;\n+\n+  /// Polymorphic wrapper for types satisfying the Executor requirements.\n+  class executor;\n+\n+  bool\n+  operator==(const executor& __a, const executor& __b) noexcept;\n+\n+  bool\n+  operator==(const executor& __e, nullptr_t) noexcept;\n+\n+  inline bool\n+  operator==(nullptr_t, const executor& __e) noexcept\n+  { return __e == nullptr; }\n+\n+  inline bool\n+  operator!=(const executor& __a, const executor& __b) noexcept\n+  { return !(__a == __b); }\n+\n+  inline bool\n+  operator!=(const executor& __e, nullptr_t) noexcept\n+  { return !(__e == nullptr); }\n+\n+  inline bool\n+  operator!=(nullptr_t, const executor& __e) noexcept\n+  { return !(__e == nullptr); }\n+\n+  void swap(executor&, executor&) noexcept;\n+\n+  // dispatch:\n+\n+  template<typename _CompletionToken>\n+    __deduced_t<_CompletionToken, void()>\n+    dispatch(_CompletionToken&& __token);\n+\n+  template<typename _Executor, typename _CompletionToken>\n+    __deduced_t<_CompletionToken, void()>\n+    dispatch(const _Executor& __ex, _CompletionToken&& __token);\n+\n+  template<typename _ExecutionContext, typename _CompletionToken>\n+    __deduced_t<_CompletionToken, void()>\n+    dispatch(_ExecutionContext& __ctx, _CompletionToken&& __token);\n+\n+  // post:\n+\n+  template<typename _CompletionToken>\n+    __deduced_t<_CompletionToken, void()>\n+    post(_CompletionToken&& __token);\n+  template<typename _Executor, typename _CompletionToken>\n+    enable_if_t<is_executor<_Executor>::value,\n+\t\t__deduced_t<_CompletionToken, void()>>\n+    post(const _Executor& __ex, _CompletionToken&& __token);\n+  template<typename _ExecutionContext, typename _CompletionToken>\n+    enable_if_t<__is_exec_context<_ExecutionContext>::value,\n+\t\t__deduced_t<_CompletionToken, void()>>\n+    post(_ExecutionContext& __ctx, _CompletionToken&& __token);\n+\n+  // defer:\n+\n+  template<typename _CompletionToken>\n+    __deduced_t<_CompletionToken, void()>\n+    defer(_CompletionToken&& __token);\n+  template<typename _Executor, typename _CompletionToken>\n+    __deduced_t<_CompletionToken, void()>\n+    defer(const _Executor& __ex, _CompletionToken&& __token);\n+  template<typename _ExecutionContext, typename _CompletionToken>\n+    __deduced_t<_CompletionToken, void()>\n+    defer(_ExecutionContext& __ctx, _CompletionToken&& __token);\n+\n+  template<typename _Executor>\n+    class strand;\n+\n+  template<typename _Executor>\n+    bool\n+    operator==(const strand<_Executor>& __a, const strand<_Executor>& __b);\n+\n+  template<typename _Executor>\n+    bool\n+    operator!=(const strand<_Executor>& __a, const strand<_Executor>& __b)\n+    { return !(__a == __b); }\n+\n+  template<typename _CompletionToken, typename _Signature, typename>\n+    class async_result\n+    {\n+    public:\n+      typedef _CompletionToken completion_handler_type;\n+      typedef void return_type;\n+\n+      explicit async_result(completion_handler_type&) {}\n+      async_result(const async_result&) = delete;\n+      async_result& operator=(const async_result&) = delete;\n+\n+      return_type get() {}\n+    };\n+\n+  template<typename _CompletionToken, typename _Signature>\n+    class async_completion\n+    {\n+      using __result_type\n+\t= async_result<decay_t<_CompletionToken>, _Signature>;\n+\n+    public:\n+      using completion_handler_type\n+\t= typename __result_type::completion_handler_type;\n+\n+    private:\n+      using __handler_type = conditional_t<\n+\tis_same<_CompletionToken, completion_handler_type>::value,\n+\tcompletion_handler_type&,\n+\tcompletion_handler_type>;\n+\n+    public:\n+      explicit\n+      async_completion(_CompletionToken& __t)\n+      : completion_handler(std::forward<__handler_type>(__t)),\n+\tresult(completion_handler)\n+      { }\n+\n+      async_completion(const async_completion&) = delete;\n+      async_completion& operator=(const async_completion&) = delete;\n+\n+      __handler_type\tcompletion_handler;\n+      __result_type\tresult;\n+    };\n+\n+\n+  class execution_context\n+  {\n+  public:\n+    class service\n+    {\n+    protected:\n+      // construct / copy / destroy:\n+\n+      explicit\n+      service(execution_context& __owner) : _M_context(__owner) { }\n+\n+      service(const service&) = delete;\n+      service& operator=(const service&) = delete;\n+\n+      virtual ~service() { } // TODO should not be inline\n+\n+      // service observers:\n+\n+      execution_context& context() const noexcept { return _M_context; }\n+\n+    private:\n+      // service operations:\n+\n+      virtual void shutdown() noexcept = 0;\n+      virtual void notify_fork(fork_event) { }\n+\n+      friend class execution_context;\n+      execution_context& _M_context;\n+    };\n+\n+    // construct / copy / destroy:\n+\n+    execution_context() { }\n+\n+    execution_context(const execution_context&) = delete;\n+    execution_context& operator=(const execution_context&) = delete;\n+\n+    virtual ~execution_context()\n+    {\n+      shutdown();\n+      destroy();\n+    }\n+\n+    // execution context operations:\n+\n+    void\n+    notify_fork(fork_event __e)\n+    {\n+      auto __l = [=](auto& __svc) { __svc._M_ptr->notify_fork(__e); };\n+      if (__e == fork_event::prepare)\n+\tstd::for_each(_M_services.rbegin(), _M_services.rend(), __l);\n+      else\n+\tstd::for_each(_M_services.begin(), _M_services.end(), __l);\n+    }\n+\n+  protected:\n+    // execution context protected operations:\n+\n+    void\n+    shutdown()\n+    {\n+      std::for_each(_M_services.rbegin(), _M_services.rend(),\n+\t  [=](auto& __svc) {\n+\t    if (__svc._M_active)\n+\t      {\n+\t        __svc._M_ptr->shutdown();\n+\t\t__svc._M_active = false;\n+\t      }\n+\t  });\n+    }\n+\n+    void\n+    destroy()\n+    {\n+      while (_M_services.size())\n+\t_M_services.pop_back();\n+      _M_keys.clear();\n+    }\n+\n+  protected:\n+\n+    template<typename _Service>\n+      static void\n+      _S_deleter(service* __svc) { delete static_cast<_Service*>(__svc); }\n+\n+    struct _ServicePtr\n+    {\n+      template<typename _Service>\n+\texplicit\n+\t_ServicePtr(_Service* __svc)\n+\t: _M_ptr(__svc, &_S_deleter<_Service>), _M_active(true) { }\n+\n+      std::unique_ptr<service, void(*)(service*)> _M_ptr;\n+      bool _M_active;\n+    };\n+\n+    mutable std::mutex _M_mutex;\n+\n+    // Sorted in order of beginning of service object lifetime.\n+    std::list<_ServicePtr> _M_services;\n+\n+    template<typename _Service, typename... _Args>\n+      service*\n+      _M_add_svc(_Args&&... __args)\n+      {\n+\t_M_services.push_back(\n+\t    _ServicePtr{new _Service{*this, std::forward<_Args>(__args)...}} );\n+\treturn _M_services.back()._M_ptr.get();\n+      }\n+\n+    using __key_type = void(*)();\n+\n+    template<typename _Key>\n+      static __key_type\n+      _S_key() { return reinterpret_cast<__key_type>(&_S_key<_Key>); }\n+\n+    std::unordered_map<__key_type, service*> _M_keys;\n+\n+    template<typename _Service>\n+      friend typename _Service::key_type&\n+      use_service(execution_context&);\n+\n+    template<typename _Service, typename... _Args>\n+      friend _Service&\n+      make_service(execution_context&, _Args&&...);\n+\n+    template<typename _Service>\n+      friend bool\n+      has_service(const execution_context&) noexcept;\n+  };\n+\n+  // service access:\n+\n+  template<typename _Service>\n+    typename _Service::key_type&\n+    use_service(execution_context& __ctx)\n+    {\n+      using _Key = typename _Service::key_type;\n+      static_assert(is_base_of<execution_context::service, _Key>::value,\n+\t  \"a service type must derive from execution_context::service\");\n+      static_assert(is_base_of<_Key, _Service>::value,\n+\t  \"a service type must match or derive from its key_type\");\n+      auto __key = execution_context::_S_key<_Key>();\n+      std::lock_guard<std::mutex> __lock(__ctx._M_mutex);\n+      auto& __svc = __ctx._M_keys[__key];\n+      if (__svc == nullptr)\n+\t{\n+\t  __try {\n+\t    __svc = __ctx._M_add_svc<_Service>();\n+\t  } __catch(...) {\n+\t    __ctx._M_keys.erase(__key);\n+\t    __throw_exception_again;\n+\t  }\n+\t}\n+      return static_cast<_Key&>(*__svc);\n+    }\n+\n+  template<typename _Service, typename... _Args>\n+    _Service&\n+    make_service(execution_context& __ctx, _Args&&... __args)\n+    {\n+      using _Key = typename _Service::key_type;\n+      static_assert(is_base_of<execution_context::service, _Key>::value,\n+\t  \"a service type must derive from execution_context::service\");\n+      static_assert(is_base_of<_Key, _Service>::value,\n+\t  \"a service type must match or derive from its key_type\");\n+      auto __key = execution_context::_S_key<_Key>();\n+      std::lock_guard<std::mutex> __lock(__ctx._M_mutex);\n+      auto& __svc = __ctx._M_keys[__key];\n+      if (__svc != nullptr)\n+\tthrow service_already_exists();\n+      __try {\n+\t__svc = __ctx._M_add_svc<_Service>(std::forward<_Args>(__args)...);\n+      } __catch(...) {\n+\t__ctx._M_keys.erase(__key);\n+\t__throw_exception_again;\n+      }\n+      return static_cast<_Service&>(*__svc);\n+    }\n+\n+  template<typename _Service>\n+    inline bool\n+    has_service(const execution_context& __ctx) noexcept\n+    {\n+      using _Key = typename _Service::key_type;\n+      static_assert(is_base_of<execution_context::service, _Key>::value,\n+\t  \"a service type must derive from execution_context::service\");\n+      static_assert(is_base_of<_Key, _Service>::value,\n+\t  \"a service type must match or derive from its key_type\");\n+      std::lock_guard<std::mutex> __lock(__ctx._M_mutex);\n+      return __ctx._M_keys.count(execution_context::_S_key<_Key>());\n+    }\n+\n+  template<typename _Tp, typename = __void_t<>>\n+    struct __is_executor_impl : false_type\n+    { };\n+\n+  // Check Executor requirements.\n+  template<typename _Tp, typename _Up = remove_const_t<_Tp>>\n+    auto\n+    __executor_reqs(_Up* __x = 0, const _Up* __cx = 0, void(*__f)() = 0,\n+\t\t    const allocator<int>& __a = {})\n+    -> enable_if_t<__is_value_constructible<_Tp>::value, __void_t<\n+      decltype(*__cx == *__cx),\n+      decltype(*__cx != *__cx),\n+      decltype(__x->context()),\n+      decltype(__x->on_work_started()),\n+      decltype(__x->on_work_finished()),\n+      decltype(__x->dispatch(std::move(__f), __a)),\n+      decltype(__x->post(std::move(__f), __a)),\n+      decltype(__x->defer(std::move(__f), __a))\n+    >>;\n+\n+  template<typename _Tp>\n+    struct __is_executor_impl<_Tp, decltype(__executor_reqs<_Tp>())>\n+    : true_type\n+    { };\n+\n+  template<typename _Tp>\n+    struct is_executor : __is_executor_impl<_Tp>\n+    { };\n+\n+  template<typename _Tp>\n+    constexpr bool is_executor_v = is_executor<_Tp>::value;\n+\n+  template<typename _Tp, typename _Executor, typename = __void_t<>>\n+    struct __uses_executor_impl : false_type\n+    { };\n+\n+  template<typename _Tp, typename _Executor>\n+    struct __uses_executor_impl<_Tp, _Executor,\n+\t\t\t\t__void_t<typename _Tp::executor_type>>\n+    : is_convertible<_Executor, typename _Tp::executor_type>\n+    { };\n+\n+  template<typename _Tp, typename _Executor>\n+    struct uses_executor : __uses_executor_impl<_Tp, _Executor>::type\n+    { };\n+\n+  template<typename _Tp, typename _Executor>\n+    constexpr bool uses_executor_v = uses_executor<_Tp, _Executor>::value;\n+\n+  template<typename _Tp, typename _Executor>\n+    class executor_binder\n+    {\n+      struct __use_exec { };\n+\n+    public:\n+      // types:\n+\n+      typedef _Tp target_type;\n+      typedef _Executor executor_type;\n+\n+      // construct / copy / destroy:\n+\n+      executor_binder(_Tp __t, const _Executor& __ex)\n+      : executor_binder(__use_exec{}, std::move(__t), __ex)\n+      { }\n+\n+      executor_binder(const executor_binder&) = default;\n+      executor_binder(executor_binder&&) = default;\n+\n+      template<typename _Up, typename _OtherExecutor>\n+\texecutor_binder(const executor_binder<_Up, _OtherExecutor>& __other)\n+\t: executor_binder(__use_exec{}, __other.get(), __other.get_executor())\n+\t{ }\n+\n+      template<typename _Up, typename _OtherExecutor>\n+\texecutor_binder(executor_binder<_Up, _OtherExecutor>&& __other)\n+\t: executor_binder(__use_exec{}, std::move(__other.get()),\n+\t\t\t  __other.get_executor())\n+\t{ }\n+\n+      template<typename _Up, typename _OtherExecutor>\n+\texecutor_binder(executor_arg_t, const _Executor& __ex,\n+\t\t\tconst executor_binder<_Up, _OtherExecutor>& __other)\n+\t: executor_binder(__use_exec{}, __other.get(), __ex)\n+\t{ }\n+\n+      template<typename _Up, typename _OtherExecutor>\n+\texecutor_binder(executor_arg_t, const _Executor& __ex,\n+\t\t\texecutor_binder<_Up, _OtherExecutor>&& __other)\n+\t: executor_binder(__use_exec{}, std::move(__other.get()), __ex)\n+\t{ }\n+\n+      ~executor_binder();\n+\n+      // executor binder access:\n+\n+      _Tp& get() noexcept { return _M_target; }\n+      const _Tp& get() const noexcept { return _M_target; }\n+      executor_type get_executor() const noexcept { return _M_ex; }\n+\n+      // executor binder invocation:\n+\n+      template<class... _Args>\n+\tresult_of_t<_Tp&(_Args&&...)>\n+\toperator()(_Args&&... __args)\n+\t{ return std::__invoke(get(), std::forward<_Args>(__args)...); }\n+\n+      template<class... _Args>\n+\tresult_of_t<const _Tp&(_Args&&...)>\n+\toperator()(_Args&&... __args) const\n+\t{ return std::__invoke(get(), std::forward<_Args>(__args)...); }\n+\n+    private:\n+      template<typename _Up>\n+\tusing __use_exec_cond\n+\t  = __and_<uses_executor<_Tp, _Executor>,\n+\t\t   is_constructible<_Tp, executor_arg_t, _Executor, _Up>>;\n+\n+      template<typename _Up, typename _Exec, typename =\n+\t       enable_if_t<__use_exec_cond<_Up>::value>>\n+\texecutor_binder(__use_exec, _Up&& __u, _Exec&& __ex)\n+\t: _M_ex(std::forward<_Exec>(__ex)),\n+\t  _M_target(executor_arg, _M_ex, std::forward<_Up>(__u))\n+\t{ }\n+\n+      template<typename _Up, typename _Exec, typename =\n+\t       enable_if_t<!__use_exec_cond<_Up>::value>>\n+\texecutor_binder(__use_exec, _Up&& __u, const _Exec& __ex)\n+\t: _M_ex(std::forward<_Exec>(__ex)),\n+\t  _M_target(std::forward<_Up>(__u))\n+\t{ }\n+\n+      _Executor\t_M_ex;\n+      _Tp\t_M_target;\n+    };\n+\n+  template<typename _Tp, typename _Executor, typename _Signature>\n+    class async_result<executor_binder<_Tp, _Executor>, _Signature>\n+    {\n+      using __inner = async_result<_Tp, _Signature>;\n+\n+    public:\n+      using completion_handler_type =\n+\texecutor_binder<typename __inner::completion_handler_type, _Executor>;\n+\n+      using return_type = typename __inner::return_type;\n+\n+      explicit\n+      async_result(completion_handler_type& __h)\n+      : _M_target(__h.get()) { }\n+\n+      async_result(const async_result&) = delete;\n+      async_result& operator=(const async_result&) = delete;\n+\n+      return_type get() { return _M_target.get(); }\n+\n+    private:\n+      __inner _M_target;\n+    };\n+\n+  template<typename _Tp, typename _Executor, typename _ProtoAlloc>\n+    struct associated_allocator<executor_binder<_Tp, _Executor>, _ProtoAlloc>\n+    {\n+      typedef associated_allocator_t<_Tp, _ProtoAlloc> type;\n+\n+      static type\n+      get(const executor_binder<_Tp, _Executor>& __b,\n+\t  const _ProtoAlloc& __a = _ProtoAlloc()) noexcept\n+      { return associated_allocator<_Tp, _ProtoAlloc>::get(__b.get(), __a); }\n+    };\n+\n+  template<typename _Tp, typename _Executor, typename _Executor1>\n+    struct associated_executor<executor_binder<_Tp, _Executor>, _Executor1>\n+    {\n+      typedef _Executor type;\n+\n+      static type\n+      get(const executor_binder<_Tp, _Executor>& __b,\n+\t  const _Executor1& = _Executor1()) noexcept\n+      { return __b.get_executor(); }\n+    };\n+\n+  template<typename _Executor>\n+    class executor_work_guard\n+    {\n+    public:\n+      // types:\n+\n+      typedef _Executor executor_type;\n+\n+      // construct / copy / destroy:\n+\n+      explicit\n+      executor_work_guard(const executor_type& __ex) noexcept\n+      : _M_ex(__ex), _M_owns(true)\n+      { _M_ex.on_work_started(); }\n+\n+      executor_work_guard(const executor_work_guard& __other) noexcept\n+      : _M_ex(__other._M_ex), _M_owns(__other._M_owns)\n+      {\n+\tif (_M_owns)\n+\t  _M_ex.on_work_started();\n+      }\n+\n+      executor_work_guard(executor_work_guard&& __other) noexcept\n+      : _M_ex(__other._M_ex), _M_owns(__other._M_owns)\n+      { __other._M_owns = false; }\n+\n+      executor_work_guard& operator=(const executor_work_guard&) = delete;\n+\n+      ~executor_work_guard()\n+      {\n+\tif (_M_owns)\n+\t  _M_ex.on_work_finished();\n+      }\n+\n+      // executor work guard observers:\n+\n+      executor_type get_executor() const noexcept { return _M_ex; }\n+\n+      bool owns_work() const noexcept { return _M_owns; }\n+\n+      // executor work guard modifiers:\n+\n+      void reset() noexcept\n+      {\n+\tif (_M_owns)\n+\t  _M_ex.on_work_finished();\n+\t_M_owns = false;\n+      }\n+\n+    private:\n+      _Executor\t_M_ex;\n+      bool\t_M_owns;\n+    };\n+\n+\n+  class system_context : public execution_context\n+  {\n+  public:\n+    // types:\n+\n+    typedef system_executor executor_type;\n+\n+    // construct / copy / destroy:\n+\n+    system_context() = default;\n+    system_context(const system_context&) = delete;\n+    system_context& operator=(const system_context&) = delete;\n+\n+    ~system_context()\n+    {\n+      stop();\n+      join();\n+    }\n+\n+    // system_context operations:\n+\n+    executor_type get_executor() noexcept;\n+\n+    void stop()\n+    {\n+      lock_guard<mutex> __lock(_M_mtx);\n+      _M_stopped = true;\n+      _M_cv.notify_all();\n+    }\n+\n+    bool stopped() const noexcept\n+    {\n+      lock_guard<mutex> __lock(_M_mtx);\n+      return _M_stopped;\n+    }\n+\n+    void join()\n+    {\n+      _M_thread.join();\n+    }\n+\n+  private:\n+    friend system_executor;\n+\n+    struct __tag { };\n+    system_context(__tag) { }\n+\n+    thread\t\t\t_M_thread;\n+    mutable mutex\t\t_M_mtx;\n+    condition_variable\t\t_M_cv;\n+    queue<function<void()>>\t_M_tasks;\n+    bool\t\t\t_M_stopped = false;\n+\n+    void\n+    _M_run()\n+    {\n+      while (true)\n+\t{\n+\t  function<void()> __f;\n+\t  {\n+\t    unique_lock<mutex> __lock(_M_mtx);\n+\t    _M_cv.wait(__lock,\n+\t\t       [this]{ return !_M_stopped && !_M_tasks.empty(); });\n+\t    if (_M_stopped)\n+\t      return;\n+\t    __f = std::move(_M_tasks.front());\n+\t    _M_tasks.pop();\n+\t  }\n+\t  __f();\n+\t}\n+    }\n+\n+    void\n+    _M_post(std::function<void()> __f)\n+    {\n+      lock_guard<mutex> __lock(_M_mtx);\n+      if (_M_stopped)\n+\treturn;\n+      if (!_M_thread.joinable())\n+\t_M_thread = std::thread(&system_context::_M_run, this);\n+      _M_tasks.push(std::move(__f)); // XXX allocator not used\n+      _M_cv.notify_one();\n+    }\n+\n+    static system_context&\n+    _S_get() noexcept\n+    {\n+      static system_context __sc(__tag{});\n+      return __sc;\n+    }\n+  };\n+\n+  class system_executor\n+  {\n+  public:\n+    // executor operations:\n+\n+    system_executor() { }\n+\n+    system_context&\n+    context() const noexcept { return system_context::_S_get(); }\n+\n+    void on_work_started() const noexcept { }\n+    void on_work_finished() const noexcept { }\n+\n+    template<typename _Func, typename _ProtoAlloc>\n+      void\n+      dispatch(_Func&& __f, const _ProtoAlloc& __a) const\n+      { decay_t<_Func>{std::forward<_Func>(__f)}(); }\n+\n+    template<typename _Func, typename _ProtoAlloc>\n+      void\n+      post(_Func&& __f, const _ProtoAlloc&) const // XXX allocator not used\n+      {\n+\tsystem_context::_S_get()._M_post(std::forward<_Func>(__f));\n+      }\n+\n+    template<typename _Func, typename _ProtoAlloc>\n+      void\n+      defer(_Func&& __f, const _ProtoAlloc& __a) const\n+      { post(std::forward<_Func>(__f), __a); }\n+  };\n+\n+  inline system_executor\n+  system_context::get_executor() noexcept\n+  { return {}; }\n+\n+  class bad_executor : public std::exception\n+  {\n+    virtual const char* what() const noexcept { return \"bad executor\"; }\n+  };\n+\n+  inline void __throw_bad_executor() // TODO make non-inline\n+  {\n+#if __cpp_exceptions\n+    throw bad_executor();\n+#else\n+    __builtin_abort();\n+#endif\n+  }\n+\n+  class executor\n+  {\n+  public:\n+    // construct / copy / destroy:\n+\n+    executor() noexcept = default;\n+\n+    executor(nullptr_t) noexcept { }\n+    executor(const executor&) noexcept = default;\n+    executor(executor&&) noexcept = default;\n+\n+    template<typename _Executor>\n+      executor(_Executor __e)\n+      : _M_target(_M_create(std::move(__e)))\n+      { }\n+\n+    template<typename _Executor, typename _ProtoAlloc>\n+      executor(allocator_arg_t, const _ProtoAlloc& __a, _Executor __e)\n+      : _M_target(_M_create(std::move(__e), __a))\n+      { }\n+\n+    executor& operator=(const executor&) noexcept = default;\n+    executor& operator=(executor&&) noexcept = default;\n+\n+    executor&\n+    operator=(nullptr_t) noexcept\n+    {\n+      _M_target = nullptr;\n+      return *this;\n+    }\n+\n+    template<typename _Executor>\n+      executor&\n+      operator=(_Executor __e)\n+      {\n+\texecutor(std::move(__e)).swap(*this);\n+\treturn *this;\n+      }\n+\n+    ~executor() = default;\n+\n+    // executor modifiers:\n+\n+    void\n+    swap(executor& __other) noexcept\n+    { _M_target.swap(__other._M_target); }\n+\n+    template<typename _Executor, typename _Alloc>\n+      void\n+      assign(_Executor __e, const _Alloc& __a)\n+      { executor(allocator_arg, __a, std::move(__e)).swap(*this); }\n+\n+    // executor operations:\n+\n+    execution_context&\n+    context() const noexcept\n+    {\n+      __glibcxx_assert( _M_target );\n+      return _M_target->context();\n+    }\n+\n+    void\n+    on_work_started() const noexcept\n+    {\n+      __glibcxx_assert( _M_target );\n+      return _M_target->on_work_started();\n+    }\n+\n+    void\n+    on_work_finished() const noexcept\n+    {\n+      __glibcxx_assert( _M_target );\n+      return _M_target->on_work_finished();\n+    }\n+\n+    template<typename _Func, typename _Alloc>\n+      void\n+      dispatch(_Func&& __f, const _Alloc& __a) const\n+      {\n+\tif (!_M_target)\n+\t  __throw_bad_executor();\n+\t// _M_target->dispatch({allocator_arg, __a, std::forward<_Func>(__f)});\n+\t_M_target->dispatch(std::forward<_Func>(__f));\n+      }\n+\n+    template<typename _Func, typename _Alloc>\n+      void\n+      post(_Func&& __f, const _Alloc& __a) const\n+      {\n+\tif (!_M_target)\n+\t  __throw_bad_executor();\n+\t// _M_target->post({allocator_arg, __a, std::forward<_Func>(__f)});\n+\t_M_target->post(std::forward<_Func>(__f));\n+      }\n+\n+    template<typename _Func, typename _Alloc>\n+      void\n+      defer(_Func&& __f, const _Alloc& __a) const\n+      {\n+\tif (!_M_target)\n+\t  __throw_bad_executor();\n+\t// _M_target->defer({allocator_arg, __a, std::forward<_Func>(__f)});\n+\t_M_target->defer(std::forward<_Func>(__f));\n+      }\n+\n+    // executor capacity:\n+\n+    explicit operator bool() const noexcept\n+    { return static_cast<bool>(_M_target); }\n+\n+    // executor target access:\n+\n+#if __cpp_rtti\n+    const type_info&\n+    target_type() const noexcept\n+    { return _M_target ? _M_target->target_type() : typeid(void); }\n+\n+    template<typename _Executor>\n+      _Executor*\n+      target() noexcept\n+      {\n+\tif (_M_target)\n+\t  if (const auto* __p = _M_target->target(typeid(_Executor)))\n+\t    return const_cast<_Executor*>(static_cast<const _Executor>(__p));\n+\treturn nullptr;\n+      }\n+\n+    template<typename _Executor>\n+      const _Executor*\n+      target() const noexcept\n+      {\n+\tif (_M_target)\n+\t  if (const auto* __p = _M_target->target(typeid(_Executor)))\n+\t    return static_cast<const _Executor*>(__p);\n+\treturn nullptr;\n+      }\n+#endif\n+\n+  private:\n+    struct _Tgt\n+    {\n+      virtual void on_work_started() const noexcept = 0;\n+      virtual void on_work_finished() const noexcept = 0;\n+      virtual execution_context& context() const noexcept = 0;\n+      virtual void dispatch(std::function<void()>) const = 0;\n+      virtual void post(std::function<void()>) const = 0;\n+      virtual void defer(std::function<void()>) const = 0;\n+#if __cpp_rtti\n+      virtual const type_info& target_type() const = 0;\n+      virtual void* target(const std::type_info&) const = 0;\n+      virtual bool _M_equals(_Tgt*) const noexcept = 0;\n+      virtual const void* _M_get_executor() const noexcept = 0;\n+#endif\n+    };\n+\n+    template<typename _Ex, typename _Alloc>\n+      struct _TgtImpl : _Tgt\n+      {\n+\texplicit\n+\t_TgtImpl(_Ex&& __ex, const _Alloc& __a)\n+\t: _M_impl(std::move(__ex), __a) { }\n+\n+\tvoid on_work_started() const noexcept { _M_ex().on_work_started(); }\n+\tvoid on_work_finished() const noexcept { _M_ex().on_work_finished(); }\n+\texecution_context& context() const noexcept { return _M_ex().context(); }\n+\tvoid\n+\tdispatch(std::function<void()> __f) const\n+\t{ _M_ex().dispatch(std::move(__f), _M_alloc()); }\n+\tvoid\n+\tpost(std::function<void()> __f) const\n+\t{ _M_ex().post(std::move(__f), _M_alloc()); }\n+\tvoid\n+\tdefer(std::function<void()> __f) const\n+\t{ _M_ex().defer(std::move(__f), _M_alloc()); }\n+\n+#if __cpp_rtti\n+\tvirtual const type_info&\n+\ttarget_type() const\n+\t{ return typeid(_Ex); }\n+\n+\tvirtual const void*\n+\ttarget(const std::type_info& __ti) const\n+\t{\n+\t  if (__ti == typeid(_Ex))\n+\t    return std::addressof(_M_ex());\n+\t  return nullptr;\n+\t}\n+\n+\tvirtual bool\n+\t_M_equals(const _Tgt* __tgt) const noexcept\n+\t{\n+\t  if (__tgt->target_type() == typeid(_Ex))\n+\t    *static_cast<const _Ex*>(__tgt->_M_get_executor()) == _M_ex();\n+\t  return false;\n+\t}\n+\n+\tvirtual const void*\n+\t_M_get_executor() const noexcept\n+\t{ return std::addressof(_M_ex()); }\n+#endif\n+\n+\t_Ex& _M_ex() { return std::get<0>(_M_impl); }\n+\t_Alloc& _M_alloc() { return std::get<1>(_M_impl); }\n+\tstd::tuple<_Ex, _Alloc> _M_impl;\n+      };\n+\n+    template<typename _Ex, typename _Alloc = std::allocator<void>>\n+      shared_ptr<_Tgt>\n+      _M_create(_Ex&& __ex, const _Alloc& __a = _Alloc())\n+      {\n+\treturn allocate_shared<_TgtImpl<_Ex, _Alloc>>(__a, std::move(__ex),\n+\t\t\t\t\t\t      __a);\n+      }\n+\n+    friend bool\n+    operator==(const executor& __a, const executor& __b) noexcept\n+    {\n+      if (__a._M_target == __b._M_target)\n+\treturn true;\n+      if (!__a._M_target || !__b._M_target)\n+\treturn false;\n+#if __cpp_rtti\n+      return __a._M_target->_M_equals(__b._M_target.get());\n+#else\n+      return false; // XXX can we do better?\n+#endif\n+    }\n+\n+    shared_ptr<_Tgt> _M_target;\n+  };\n+\n+  template<> struct is_executor<executor> : true_type { };\n+\n+  /// executor comparisons\n+  inline bool\n+  operator==(const executor& __e, nullptr_t) noexcept\n+  { return !__e; }\n+\n+  /// Swap two executor objects.\n+  inline void swap(executor& __a, executor& __b) noexcept { __a.swap(__b); }\n+\n+\n+  template<typename _CompletionHandler>\n+    struct __dispatcher\n+    {\n+      explicit\n+      __dispatcher(_CompletionHandler& __h)\n+      : _M_h(std::move(__h)), _M_w(net::make_work_guard(_M_h))\n+      { }\n+\n+      void operator()()\n+      {\n+\tauto __alloc = net::get_associated_allocator(_M_h);\n+\t_M_w.get_executor().dispatch(std::move(_M_h), __alloc);\n+\t_M_w.reset();\n+      }\n+\n+      _CompletionHandler _M_h;\n+      decltype(net::make_work_guard(_M_h)) _M_w;\n+    };\n+\n+  template<typename _CompletionHandler>\n+    inline __dispatcher<_CompletionHandler>\n+    __make_dispatcher(_CompletionHandler& __h)\n+    { return __dispatcher<_CompletionHandler>{__h}; }\n+\n+\n+\n+  // dispatch:\n+\n+  template<typename _CompletionToken>\n+    inline __deduced_t<_CompletionToken, void()>\n+    dispatch(_CompletionToken&& __token)\n+    {\n+      async_completion<_CompletionToken, void()> __cmpl{__token};\n+      auto __ex = net::get_associated_executor(__cmpl.completion_handler);\n+      auto __alloc = net::get_associated_allocator(__cmpl.completion_handler);\n+      __ex.dispatch(std::move(__cmpl.completion_handler), __alloc);\n+      return __cmpl.result.get();\n+    }\n+\n+  template<typename _Executor, typename _CompletionToken>\n+    inline\n+    enable_if_t<is_executor<_Executor>::value,\n+\t\t__deduced_t<_CompletionToken, void()>>\n+    dispatch(const _Executor& __ex, _CompletionToken&& __token)\n+    {\n+      async_completion<_CompletionToken, void()> __cmpl{__token};\n+      auto __alloc = net::get_associated_allocator(__cmpl.completion_handler);\n+      __ex.dispatch(net::__make_dispatcher(__cmpl.completion_handler),\n+\t\t    __alloc);\n+      return __cmpl.result.get();\n+    }\n+\n+  template<typename _ExecutionContext, typename _CompletionToken>\n+    inline\n+    enable_if_t<__is_exec_context<_ExecutionContext>::value,\n+\t\t__deduced_t<_CompletionToken, void()>>\n+    dispatch(_ExecutionContext& __ctx, _CompletionToken&& __token)\n+    {\n+      return net::dispatch(__ctx.get_executor(),\n+\t\t\t   forward<_CompletionToken>(__token));\n+    }\n+\n+  // post:\n+\n+  template<typename _CompletionToken>\n+    inline __deduced_t<_CompletionToken, void()>\n+    post(_CompletionToken&& __token)\n+    {\n+      async_completion<_CompletionToken, void()> __cmpl{__token};\n+      auto __ex = net::get_associated_executor(__cmpl.completion_handler);\n+      auto __alloc = net::get_associated_allocator(__cmpl.completion_handler);\n+      __ex.post(std::move(__cmpl.completion_handler), __alloc);\n+      return __cmpl.result.get();\n+    }\n+\n+  template<typename _Executor, typename _CompletionToken>\n+    inline\n+    enable_if_t<is_executor<_Executor>::value,\n+\t\t__deduced_t<_CompletionToken, void()>>\n+    post(const _Executor& __ex, _CompletionToken&& __token)\n+    {\n+      async_completion<_CompletionToken, void()> __cmpl{__token};\n+      auto __alloc = net::get_associated_allocator(__cmpl.completion_handler);\n+      __ex.post(net::__make_dispatcher(__cmpl.completion_handler), __alloc);\n+      return __cmpl.result.get();\n+    }\n+\n+  template<typename _ExecutionContext, typename _CompletionToken>\n+    inline\n+    enable_if_t<__is_exec_context<_ExecutionContext>::value,\n+\t\t__deduced_t<_CompletionToken, void()>>\n+    post(_ExecutionContext& __ctx, _CompletionToken&& __token)\n+    {\n+      return net::post(__ctx.get_executor(),\n+\t\t       forward<_CompletionToken>(__token));\n+    }\n+\n+  // defer:\n+\n+  template<typename _CompletionToken>\n+    inline __deduced_t<_CompletionToken, void()>\n+    defer(_CompletionToken&& __token)\n+    {\n+      async_completion<_CompletionToken, void()> __cmpl{__token};\n+      auto __ex = net::get_associated_executor(__cmpl.completion_handler);\n+      auto __alloc = net::get_associated_allocator(__cmpl.completion_handler);\n+      __ex.defer(std::move(__cmpl.completion_handler), __alloc);\n+      return __cmpl.result.get();\n+    }\n+\n+  template<typename _Executor, typename _CompletionToken>\n+    inline\n+    enable_if_t<is_executor<_Executor>::value,\n+\t\t__deduced_t<_CompletionToken, void()>>\n+    defer(const _Executor& __ex, _CompletionToken&& __token)\n+    {\n+      async_completion<_CompletionToken, void()> __cmpl{__token};\n+      auto __alloc = net::get_associated_allocator(__cmpl.completion_handler);\n+      __ex.defer(net::__make_dispatcher(__cmpl.completion_handler), __alloc);\n+      return __cmpl.result.get();\n+    }\n+\n+  template<typename _ExecutionContext, typename _CompletionToken>\n+    inline\n+    enable_if_t<__is_exec_context<_ExecutionContext>::value,\n+\t\t__deduced_t<_CompletionToken, void()>>\n+    defer(_ExecutionContext& __ctx, _CompletionToken&& __token)\n+    {\n+      return net::defer(__ctx.get_executor(),\n+\t\t\tforward<_CompletionToken>(__token));\n+    }\n+\n+\n+  template<typename _Executor>\n+    class strand\n+    {\n+    public:\n+      // types:\n+\n+      typedef _Executor inner_executor_type;\n+\n+      // construct / copy / destroy:\n+\n+      strand(); // TODO make state\n+\n+      explicit strand(_Executor __ex) : _M_inner_ex(__ex) { } // TODO make state\n+\n+      template<typename _Alloc>\n+\tstrand(allocator_arg_t, const _Alloc& __a, _Executor __ex)\n+\t: _M_inner_ex(__ex) { } // TODO make state\n+\n+      strand(const strand& __other) noexcept\n+      : _M_state(__other._M_state), _M_inner_ex(__other._M_inner_ex) { }\n+\n+      strand(strand&& __other) noexcept\n+      : _M_state(std::move(__other._M_state)),\n+\t_M_inner_ex(std::move(__other._M_inner_ex)) { }\n+\n+      template<typename _OtherExecutor>\n+\tstrand(const strand<_OtherExecutor>& __other) noexcept\n+\t: _M_state(__other._M_state), _M_inner_ex(__other._M_inner_ex) { }\n+\n+      template<typename _OtherExecutor>\n+\tstrand(strand<_OtherExecutor>&& __other) noexcept\n+\t: _M_state(std::move(__other._M_state)),\n+\t  _M_inner_ex(std::move(__other._M_inner_ex)) { }\n+\n+      strand&\n+      operator=(const strand& __other) noexcept\n+      {\n+\tstatic_assert(is_copy_assignable<_Executor>::value,\n+\t\t      \"inner executor type must be CopyAssignable\");\n+\n+\t// TODO lock __other\n+\t// TODO copy state\n+\t_M_inner_ex = __other._M_inner_ex;\n+\treturn *this;\n+      }\n+\n+      strand&\n+      operator=(strand&& __other) noexcept\n+      {\n+\tstatic_assert(is_move_assignable<_Executor>::value,\n+\t\t      \"inner executor type must be MoveAssignable\");\n+\n+\t// TODO move state\n+\t_M_inner_ex = std::move(__other._M_inner_ex);\n+\treturn *this;\n+      }\n+\n+      template<typename _OtherExecutor>\n+\tstrand&\n+\toperator=(const strand<_OtherExecutor>& __other) noexcept\n+\t{\n+\t  static_assert(is_convertible<_OtherExecutor, _Executor>::value,\n+\t\t\t\"inner executor type must be compatible\");\n+\n+\t  // TODO lock __other\n+\t  // TODO copy state\n+\t  _M_inner_ex = __other._M_inner_ex;\n+\t  return *this;\n+\t}\n+\n+      template<typename _OtherExecutor>\n+\tstrand&\n+\toperator=(strand<_OtherExecutor>&& __other) noexcept\n+\t{\n+\t  static_assert(is_convertible<_OtherExecutor, _Executor>::value,\n+\t\t\t\"inner executor type must be compatible\");\n+\n+\t  // TODO move state\n+\t  _M_inner_ex = std::move(__other._M_inner_ex);\n+\t  return *this;\n+\t}\n+\n+      ~strand()\n+      {\n+\t// the task queue outlives this object if non-empty\n+\t// TODO create circular ref in queue?\n+      }\n+\n+      // strand operations:\n+\n+      inner_executor_type\n+      get_inner_executor() const noexcept\n+      { return _M_inner_ex; }\n+\n+      bool\n+      running_in_this_thread() const noexcept\n+      { return std::this_thread::get_id() == _M_state->_M_running_on; }\n+\n+      execution_context&\n+      context() const noexcept\n+      { return _M_inner_ex.context(); }\n+\n+      void on_work_started() const noexcept { _M_inner_ex.on_work_started(); }\n+      void on_work_finished() const noexcept { _M_inner_ex.on_work_finished(); }\n+\n+      template<typename _Func, typename _Alloc>\n+\tvoid\n+\tdispatch(_Func&& __f, const _Alloc& __a) const\n+\t{\n+\t  if (running_in_this_thread())\n+\t    decay_t<_Func>{std::forward<_Func>(__f)}();\n+\t  else\n+\t    post(std::forward<_Func>(__f), __a);\n+\t}\n+\n+      template<typename _Func, typename _Alloc>\n+\tvoid\n+\tpost(_Func&& __f, const _Alloc& __a) const; // TODO\n+\n+      template<typename _Func, typename _Alloc>\n+\tvoid\n+\tdefer(_Func&& __f, const _Alloc& __a) const\n+\t{ post(std::forward<_Func>(__f), __a); }\n+\n+    private:\n+      friend bool\n+      operator==(const strand& __a, const strand& __b)\n+      { return __a._M_state == __b._M_state; }\n+\n+      // TODO add synchronised queue\n+      struct _State\n+      {\n+\tstd::thread::id _M_running_on;\n+      };\n+      shared_ptr<_State> _M_state;\n+      _Executor _M_inner_ex;\n+    };\n+\n+#if defined(_GLIBCXX_HAS_GTHREADS) && defined(_GLIBCXX_USE_C99_STDINT_TR1)\n+\n+  // Completion token for asynchronous operations initiated with use_future.\n+  template<typename _Func, typename _Alloc>\n+    struct __use_future_ct\n+    {\n+      std::tuple<_Func, _Alloc> _M_t;\n+    };\n+\n+  template<typename _ProtoAllocator = allocator<void>>\n+    class use_future_t\n+    {\n+    public:\n+      // use_future_t types:\n+      typedef _ProtoAllocator allocator_type;\n+\n+      // use_future_t members:\n+      constexpr use_future_t() noexcept : _M_alloc() { }\n+\n+      explicit\n+      use_future_t(const _ProtoAllocator& __a) noexcept : _M_alloc(__a) { }\n+\n+      template<class _OtherAllocator>\n+\tuse_future_t<_OtherAllocator>\n+\trebind(const _OtherAllocator& __a) const noexcept\n+\t{ return use_future_t<_OtherAllocator>(__a); }\n+\n+      allocator_type get_allocator() const noexcept { return _M_alloc; }\n+\n+      template<typename _Func>\n+\tauto\n+\toperator()(_Func&& __f) const\n+\t{\n+\t  using _Token = __use_future_ct<decay_t<_Func>, _ProtoAllocator>;\n+\t  return _Token{ {std::forward<_Func>(__f), _M_alloc} };\n+\t}\n+\n+    private:\n+      _ProtoAllocator _M_alloc;\n+    };\n+\n+  constexpr use_future_t<> use_future = use_future_t<>();\n+\n+  template<typename _Func, typename _Alloc, typename _Res, typename... _Args>\n+    class async_result<__use_future_ct<_Func, _Alloc>, _Res(_Args...)>;\n+\n+  template<typename _Result, typename _Executor>\n+    struct __use_future_ex;\n+\n+  // Completion handler for asynchronous operations initiated with use_future.\n+  template<typename _Func, typename... _Args>\n+    struct __use_future_ch\n+    {\n+      template<typename _Alloc>\n+\texplicit\n+\t__use_future_ch(__use_future_ct<_Func, _Alloc>&& __token)\n+\t: _M_f{ std::move(std::get<0>(__token._M_t)) },\n+\t  _M_promise{ std::get<1>(__token._M_t) }\n+\t{ }\n+\n+      void\n+      operator()(_Args&&... __args)\n+      {\n+\t__try\n+\t  {\n+\t    _M_promise.set_value(_M_f(std::forward<_Args>(__args)...));\n+\t  }\n+\t__catch(__cxxabiv1::__forced_unwind&)\n+\t  {\n+\t    __throw_exception_again;\n+\t  }\n+\t__catch(...)\n+\t  {\n+\t    _M_promise.set_exception(std::current_exception());\n+\t  }\n+      }\n+\n+      using __result = result_of_t<_Func(decay_t<_Args>...)>;\n+\n+      future<__result> get_future() { return _M_promise.get_future(); }\n+\n+    private:\n+      template<typename _Result, typename _Executor>\n+\tfriend struct __use_future_ex;\n+\n+      _Func _M_f;\n+      mutable promise<__result> _M_promise;\n+    };\n+\n+  // Specialization of async_result for operations initiated with use_future.\n+  template<typename _Func, typename _Alloc, typename _Res, typename... _Args>\n+    class async_result<__use_future_ct<_Func, _Alloc>, _Res(_Args...)>\n+    {\n+    public:\n+      using completion_handler_type = __use_future_ch<_Func, _Args...>;\n+      using return_type = future<typename completion_handler_type::__result>;\n+\n+      explicit\n+      async_result(completion_handler_type& __h)\n+      : _M_future(__h.get_future())\n+      { }\n+\n+      async_result(const async_result&) = delete;\n+      async_result& operator=(const async_result&) = delete;\n+\n+      return_type get() { return std::move(_M_future); }\n+\n+    private:\n+      return_type _M_future;\n+    };\n+\n+  template<typename _Result, typename _Executor>\n+    struct __use_future_ex\n+    {\n+      template<typename _Handler>\n+      __use_future_ex(const _Handler& __h, _Executor __ex)\n+      : _M_t(__h._M_promise, __ex)\n+      { }\n+\n+      template<typename _Fn, typename _Alloc>\n+\tvoid\n+\tdispatch(_Fn&& __fn)\n+\t{\n+\t  __try\n+\t    {\n+\t      std::get<1>(_M_t).dispatch(std::forward<_Fn>(__fn));\n+\t    }\n+\t  __catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      __throw_exception_again;\n+\t    }\n+\t  __catch(...)\n+\t    {\n+\t      std::get<0>(_M_t).set_exception(std::current_exception());\n+\t    }\n+\t}\n+\n+      template<typename _Fn, typename _Alloc>\n+\tvoid\n+\tpost(_Fn&& __fn)\n+\t{\n+\t  __try\n+\t    {\n+\t      std::get<1>(_M_t).post(std::forward<_Fn>(__fn));\n+\t    }\n+\t  __catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      __throw_exception_again;\n+\t    }\n+\t  __catch(...)\n+\t    {\n+\t      std::get<0>(_M_t).set_exception(std::current_exception());\n+\t    }\n+\t}\n+\n+      template<typename _Fn, typename _Alloc>\n+\tvoid\n+\tdefer(_Fn&& __fn)\n+\t{\n+\t  __try\n+\t    {\n+\t      std::get<1>(_M_t).defer(std::forward<_Fn>(__fn));\n+\t    }\n+\t  __catch(__cxxabiv1::__forced_unwind&)\n+\t    {\n+\t      __throw_exception_again;\n+\t    }\n+\t  __catch(...)\n+\t    {\n+\t      std::get<0>(_M_t).set_exception(std::current_exception());\n+\t    }\n+\t}\n+\n+    private:\n+      tuple<promise<_Result>&, _Executor> _M_t;\n+    };\n+\n+  template<typename _Func, typename... _Args, typename _Executor>\n+    struct associated_executor<__use_future_ch<_Func, _Args...>, _Executor>\n+    {\n+    private:\n+      using __handler = __use_future_ch<_Func, _Args...>;\n+\n+      using type = __use_future_ex<typename __handler::__result, _Executor>;\n+\n+      static type\n+      get(const __handler& __h, const _Executor& __ex)\n+      { return { __h, __ex }; }\n+    };\n+\n+#if 0\n+\n+  // [async.use.future.traits]\n+  template<typename _Allocator, typename _Ret, typename... _Args>\n+    class handler_type<use_future_t<_Allocator>, _Ret(_Args...)> // TODO uglify name\n+    {\n+      template<typename... _Args>\n+\tstruct __is_error_result : false_type { };\n+\n+      template<typename... _Args>\n+\tstruct __is_error_result<error_code, _Args...> : true_type { };\n+\n+      template<typename... _Args>\n+\tstruct __is_error_result<exception_ptr, _Args...> : true_type { };\n+\n+      static exception_ptr\n+      _S_exptr(exception_ptr& __ex)\n+      { return std::move(__ex); }\n+\n+      static exception_ptr\n+      _S_exptr(const error_code& __ec)\n+      { return make_exception_ptr(system_error(__ec)); }\n+\n+      template<bool _IsError, typename... _UArgs>\n+\tstruct _Type;\n+\n+      // N == 0\n+      template<bool _IsError>\n+\tstruct _Type<_IsError>\n+\t{\n+\t  std::promise<void> _M_promise;\n+\n+\t  void\n+\t  operator()()\n+\t  {\n+\t    _M_promise.set_value();\n+\t  }\n+\t};\n+\n+      // N == 1, U0 is error_code or exception_ptr\n+      template<typename _UArg0>\n+\tstruct _Type<true, _UArg0>\n+\t{\n+\t  std::promise<void> _M_promise;\n+\n+\t  template<typename _Arg0>\n+\t    void\n+\t    operator()(_Arg0&& __a0)\n+\t    {\n+\t      if (__a0)\n+\t\t_M_promise.set_exception(_S_exptr(__a0));\n+\t      else\n+\t\t_M_promise.set_value();\n+\t    }\n+\t};\n+\n+      // N == 1, U0 is not error_code or exception_ptr\n+      template<typename _UArg0>\n+\tstruct _Type<false, _UArg0>\n+\t{\n+\t  std::promise<_UArg0> _M_promise;\n+\n+\t  template<typename _Arg0>\n+\t    void\n+\t    operator()(_Arg0&& __a0)\n+\t    {\n+\t      _M_promise.set_value(std::forward<_Arg0>(__a0));\n+\t    }\n+\t};\n+\n+      // N == 2, U0 is error_code or exception_ptr\n+      template<typename _UArg0, typename _UArg1>\n+\tstruct _Type<true, _UArg0, _UArg1>\n+\t{\n+\t  std::promise<_UArg1> _M_promise;\n+\n+\t  template<typename _Arg0, typename _Arg1>\n+\t    void\n+\t    operator()(_Arg0&& __a0, _Arg1&& __a1)\n+\t    {\n+\t      if (__a0)\n+\t\t_M_promise.set_exception(_S_exptr(__a0));\n+\t      else\n+\t\t_M_promise.set_value(std::forward<_Arg1>(__a1));\n+\t    }\n+\t};\n+\n+      // N >= 2, U0 is not error_code or exception_ptr\n+      template<typename... _UArgs>\n+\tstruct _Type<false, _UArgs...>\n+\t{\n+\t  static_assert(sizeof...(_UArgs) > 1, \"wrong partial specialization\");\n+\n+\t  std::promise<tuple<_UArgs...>> _M_promise;\n+\n+\t  template<typename... _Args>\n+\t    void\n+\t    operator()(_Args&&... __args)\n+\t    {\n+\t      _M_promise.set_value(\n+\t\t  std::forward_as_tuple(std::forward<_Args>(__args)...));\n+\t    }\n+\t};\n+\n+      // N > 2, U0 is error_code or exception_ptr\n+      template<typename _UArg0, typename... _UArgs>\n+\tstruct _Type<true, _UArg0, _UArgs...>\n+\t{\n+\t  static_assert(sizeof...(_UArgs) > 1, \"wrong partial specialization\");\n+\n+\t  std::promise<tuple<_UArgs...>> _M_promise;\n+\n+\t  template<typename _Arg0, typename... _Args>\n+\t    void\n+\t    operator()(_Arg0&& __a0, _Args&&... __args)\n+\t    {\n+\t      if (__a0)\n+\t\t_M_promise.set_exception(_S_exptr(__a0));\n+\t      else\n+\t\t_M_promise.set_value(\n+\t\t    std::forward_as_tuple(std::forward<_Args>(__args)...));\n+\t    }\n+\t};\n+\n+    public:\n+      using type =\n+\t_Type<__is_error_result<_Args...>::value, decay_t<_Args>...>;\n+    };\n+\n+\n+  template<typename _Alloc, typename _Ret, typename... _Args>\n+    struct async_result<use_future_t<_Alloc>, _Ret(_Args...)>\n+    {\n+      using completion_handler_type\n+\t= typename handler_type<use_future_t<_Alloc>, _Ret(_Args...)>::type;\n+\n+      using return_type = void; // XXX TODO ???;\n+\n+      explicit\n+      async_result(completion_handler_type& __h) : _M_handler(__h) { }\n+\n+      auto get() { return _M_handler._M_provider.get_future(); }\n+\n+      async_result(const async_result&) = delete;\n+      async_result& operator=(const async_result&) = delete;\n+\n+      return_type get() { return _M_handler._M_promise.get_future(); }\n+\n+    private:\n+      completion_handler_type& _M_handler;\n+    };\n+\n+  // TODO specialize associated_executor for\n+  // async_result<use_future_t<A>, Sig>::completion_handler_type\n+  // to use a __use_future_ex\n+  // (probably need to move _Type outside of handler_type so we don't have\n+  // a non-deduced context)\n+\n+\n+#endif\n+\n+  // [async.packaged.task.specializations]\n+  template<typename _Ret, typename... _Args, typename _Signature>\n+    class async_result<packaged_task<_Ret(_Args...)>, _Signature>\n+    {\n+    public:\n+      using completion_handler_type = packaged_task<_Ret(_Args...)>;\n+      using return_type = future<_Ret>;\n+\n+      explicit\n+      async_result(completion_handler_type& __h)\n+      : _M_future(__h.get_future()) { }\n+\n+      async_result(const async_result&) = delete;\n+      async_result& operator=(const async_result&) = delete;\n+\n+      return_type get() { return std::move(_M_future); }\n+\n+    private:\n+      return_type _M_future;\n+    };\n+\n+#endif\n+\n+  /// @}\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace v1\n+} // namespace net\n+} // namespace experimental\n+\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  template<typename _Alloc>\n+    struct uses_allocator<experimental::net::executor, _Alloc>\n+    : true_type {};\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+\n+#endif // C++14\n+\n+#endif // _GLIBCXX_EXPERIMENTAL_EXECUTOR"}, {"sha": "07fe6140f30072a58e5947117dadd7002bdfb46d", "filename": "libstdc++-v3/include/experimental/internet", "status": "added", "additions": 2397, "deletions": 0, "changes": 2397, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Finternet", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Finternet", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Finternet?ref=e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "patch": "@@ -0,0 +1,2397 @@\n+// <experimental/internet> -*- C++ -*-\n+\n+// Copyright (C) 2015-2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file experimental/internet\n+ *  This is a TS C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_EXPERIMENTAL_INTERNET\n+#define _GLIBCXX_EXPERIMENTAL_INTERNET\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus >= 201402L\n+\n+#include <experimental/netfwd>\n+#include <array>\n+#include <forward_list>\n+#include <sstream>\n+#include <typeinfo>\n+#include <cstring>\n+#include <cstdint>\n+#include <experimental/io_context>\n+#include <experimental/bits/net.h>\n+#include <experimental/string_view>\n+#include <unistd.h>\n+#include <arpa/inet.h>\n+#include <netinet/tcp.h>\n+#include <netdb.h>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+namespace experimental\n+{\n+namespace net\n+{\n+inline namespace v1\n+{\n+namespace ip\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /**\n+   * @ingroup networking\n+   * @{\n+   */\n+\n+  /** Error codes for resolver errors.\n+   * @{\n+   */\n+\n+  enum class resolver_errc : int {\n+    host_not_found = EAI_NONAME,\n+    host_not_found_try_again = EAI_AGAIN,\n+    service_not_found = EAI_SERVICE\n+  };\n+\n+  /// Error category for resolver errors.\n+  inline const error_category& resolver_category() noexcept // TODO non-inline\n+  {\n+    struct __cat : error_category\n+    {\n+      const char* name() const noexcept { return \"resolver\"; }\n+      std::string message(int __e) const { return ::gai_strerror(__e); }\n+      virtual void __message(int) { } // TODO dual ABI XXX\n+    };\n+    static __cat __c;\n+    return __c;\n+  }\n+\n+  error_code make_error_code(resolver_errc __e) noexcept\n+  { return error_code(static_cast<int>(__e), resolver_category()); }\n+\n+  error_condition make_error_condition(resolver_errc __e) noexcept\n+  { return error_condition(static_cast<int>(__e), resolver_category()); }\n+\n+  /// @}\n+\n+  typedef uint_least16_t port_type;\t///< Type used for port numbers.\n+  typedef uint_least32_t scope_id_type;\t///< Type used for IPv6 scope IDs.\n+\n+  /// Convenience alias for constraining allocators for strings.\n+  template<typename _Alloc>\n+    using __string_with\n+      = enable_if_t<std::is_same<typename _Alloc::value_type, char>::value,\n+\t\t    std::basic_string<char, std::char_traits<char>, _Alloc>>;\n+\n+  /** Tag indicating conversion between IPv4 and IPv4-mapped IPv6 addresses.\n+   * @{\n+   */\n+\n+  struct v4_mapped_t {};\n+  constexpr v4_mapped_t v4_mapped;\n+\n+  // @}\n+\n+  /// An IPv4 address.\n+  class address_v4\n+  {\n+  public:\n+    // types:\n+    typedef uint_least32_t uint_type;\n+\n+    struct bytes_type : array<unsigned char, 4>\n+    {\n+      template<typename... _Tp>\n+\texplicit constexpr\n+\tbytes_type(_Tp... __tp)\n+\t: array<unsigned char, 4>{{static_cast<unsigned char>(__tp)...}}\n+\t{\n+#if UCHAR_MAX > 0xFF\n+\t  for (auto __b : *this)\n+\t    if (__b > 0xFF)\n+\t      __throw_out_of_range(\"invalid address_v4::bytes_type value\");\n+#endif\n+\t}\n+    };\n+\n+    // constructors:\n+    constexpr address_v4() noexcept : _M_addr(0) { }\n+\n+    constexpr address_v4(const address_v4& a) noexcept = default;\n+\n+    constexpr\n+    address_v4(const bytes_type& __b)\n+    : _M_addr((__b[0] << 24) | (__b[1] << 16) | (__b[2] << 8) | __b[3])\n+    { }\n+\n+    explicit constexpr\n+    address_v4(uint_type __val) : _M_addr(_S_hton(__val))\n+    {\n+#if UINT_LEAST32_MAX > 0xFFFFFFFF\n+      if (__val > 0xFFFFFFFF)\n+\t__throw_out_of_range(\"invalid address_v4::uint_type value\");\n+#endif\n+    }\n+\n+    // assignment:\n+    address_v4& operator=(const address_v4& a) noexcept = default;\n+\n+    // members:\n+    constexpr bool is_unspecified() const noexcept { return to_uint() == 0; }\n+\n+    constexpr bool\n+    is_loopback() const noexcept\n+    { return (to_uint() & 0xFF000000) == 0x7F000000; }\n+\n+    constexpr bool\n+    is_multicast() const noexcept\n+    { return (to_uint() & 0xF0000000) == 0xE0000000; }\n+\n+    constexpr bytes_type\n+    to_bytes() const noexcept\n+    {\n+      return bytes_type{\n+\t  (_M_addr >> 24) & 0xFF,\n+\t  (_M_addr >> 16) & 0xFF,\n+\t  (_M_addr >> 8) & 0xFF,\n+\t  _M_addr & 0xFF\n+      };\n+    }\n+\n+    constexpr uint_type to_uint() const noexcept { return _S_ntoh(_M_addr); }\n+\n+    template<typename _Allocator = allocator<char>>\n+      __string_with<_Allocator>\n+      to_string(const _Allocator& __a = _Allocator()) const\n+      {\n+\t__string_with<_Allocator> __str(__a);\n+\t__str.resize(INET6_ADDRSTRLEN);\n+\tif (inet_ntop(AF_INET, &_M_addr, &__str.front(), __str.size()))\n+\t  __str.erase(__str.find('\\0'));\n+\telse\n+\t  __str.resize(0);\n+\treturn __str;\n+      }\n+\n+    // static members:\n+    static constexpr address_v4 any() noexcept { return address_v4{}; }\n+\n+    static constexpr\n+    address_v4 loopback() noexcept { return address_v4{0x7F000001}; }\n+\n+    static constexpr\n+    address_v4 broadcast() noexcept { return address_v4{0xFFFFFFFF}; }\n+\n+  private:\n+    template<typename _InternetProtocol>\n+      friend class basic_endpoint;\n+\n+    friend address_v4 make_address_v4(const char*, error_code&) noexcept;\n+\n+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+    static constexpr uint16_t _S_hton(uint16_t __h) { return __h; }\n+    static constexpr uint16_t _S_ntoh(uint16_t __n) { return __n; }\n+    static constexpr uint32_t _S_hton(uint32_t __h) { return __h; }\n+    static constexpr uint32_t _S_ntoh(uint32_t __n) { return __n; }\n+#else\n+    static constexpr uint16_t\n+    _S_hton(uint16_t __h) { return __builtin_bswap16(__h); }\n+\n+    static constexpr uint16_t\n+    _S_ntoh(uint16_t __n) { return __builtin_bswap16(__n); }\n+\n+    static constexpr uint32_t\n+    _S_hton(uint32_t __h) { return __builtin_bswap32(__h); }\n+\n+    static constexpr uint32_t\n+    _S_ntoh(uint32_t __n) { return __builtin_bswap32(__n); }\n+#endif\n+\n+    in_addr_t _M_addr; // network byte order\n+  };\n+\n+  /// An IPv6 address.\n+  class address_v6\n+  {\n+  public:\n+    // types:\n+    struct bytes_type : array<unsigned char, 16>\n+    {\n+      template<typename... _Tp> explicit constexpr bytes_type(_Tp... __t)\n+\t: array<unsigned char, 16>{{static_cast<unsigned char>(__t)...}} { }\n+    };\n+\n+    // constructors:\n+    constexpr address_v6() noexcept : _M_bytes(), _M_scope_id() { }\n+\n+    constexpr address_v6(const address_v6& __a) noexcept = default;\n+\n+    constexpr\n+    address_v6(const bytes_type& __bytes, scope_id_type __scope = 0)\n+    : _M_bytes(__bytes), _M_scope_id(__scope)\n+    { }\n+\n+    // assignment:\n+    address_v6& operator=(const address_v6& __a) noexcept = default;\n+\n+    // members:\n+    void scope_id(scope_id_type __id) noexcept { _M_scope_id = __id; }\n+\n+    constexpr scope_id_type scope_id() const noexcept { return _M_scope_id; }\n+\n+    constexpr bool\n+    is_unspecified() const noexcept\n+    {\n+      for (int __i = 0; __i < 16; ++__i)\n+\tif (_M_bytes[__i] != 0x00)\n+\t  return false;\n+      return _M_scope_id == 0;\n+    }\n+\n+    constexpr bool\n+    is_loopback() const noexcept\n+    {\n+      for (int __i = 0; __i < 15; ++__i)\n+\tif (_M_bytes[__i] != 0x00)\n+\t  return false;\n+      return _M_bytes[15] == 0x01 && _M_scope_id == 0;\n+    }\n+\n+    constexpr bool\n+    is_multicast() const noexcept { return _M_bytes[0] == 0xFF; }\n+\n+    constexpr bool\n+    is_link_local() const noexcept\n+    { return _M_bytes[0] == 0xFE && (_M_bytes[1] & 0xC0) == 0x80; }\n+\n+    constexpr bool\n+    is_site_local() const noexcept\n+    { return _M_bytes[0] == 0xFE && (_M_bytes[1] & 0xC0) == 0xC0; }\n+\n+    constexpr bool\n+    is_v4_mapped() const noexcept\n+    {\n+      const bytes_type& __b = _M_bytes;\n+      return __b[0] == 0 && __b[1] == 0 && __b[ 2] == 0    && __b[ 3] == 0\n+\t  && __b[4] == 0 && __b[5] == 0 && __b[ 6] == 0    && __b[ 7] == 0\n+\t  && __b[8] == 0 && __b[9] == 0 && __b[10] == 0xFF && __b[11] == 0xFF;\n+    }\n+\n+    constexpr bool\n+    is_multicast_node_local() const noexcept\n+    { return is_multicast() && (_M_bytes[1] & 0x0F) == 0x01; }\n+\n+    constexpr bool\n+    is_multicast_link_local() const noexcept\n+    { return is_multicast() && (_M_bytes[1] & 0x0F) == 0x02; }\n+\n+    constexpr bool\n+    is_multicast_site_local() const noexcept\n+    { return is_multicast() && (_M_bytes[1] & 0x0F) == 0x05; }\n+\n+    constexpr bool\n+    is_multicast_org_local() const noexcept\n+    { return is_multicast() && (_M_bytes[1] & 0x0F) == 0x08; }\n+\n+    constexpr bool\n+    is_multicast_global() const noexcept\n+    { return is_multicast() && (_M_bytes[1] & 0x0F) == 0x0b; }\n+\n+    constexpr bytes_type to_bytes() const noexcept { return _M_bytes; }\n+\n+    template<typename _Allocator = allocator<char>>\n+      __string_with<_Allocator>\n+      to_string(const _Allocator& __a = _Allocator()) const\n+      {\n+\t__string_with<_Allocator> __str(__a);\n+\t__str.resize(INET6_ADDRSTRLEN);\n+\tif (inet_ntop(AF_INET6, &_M_bytes, &__str.front(), __str.size()))\n+\t  __str.erase(__str.find('\\0'));\n+\telse\n+\t  __str.resize(0);\n+\treturn __str;\n+      }\n+\n+    // static members:\n+    static constexpr address_v6\n+    any() noexcept\n+    {\n+      address_v6 __addr;\n+      std::memcpy(&__addr._M_bytes, in6addr_any.s6_addr, 16);\n+      return __addr;\n+    }\n+\n+    static constexpr address_v6\n+    loopback() noexcept\n+    {\n+      address_v6 __addr;\n+      std::memcpy(&__addr._M_bytes, in6addr_loopback.s6_addr, 16);\n+      return __addr;\n+    }\n+\n+  private:\n+    template<typename _InternetProtocol>\n+      friend class basic_endpoint;\n+\n+    friend constexpr bool\n+    operator==(const address_v6&, const address_v6&) noexcept;\n+\n+    friend constexpr bool\n+    operator< (const address_v6&, const address_v6&) noexcept;\n+\n+    bytes_type _M_bytes;\n+    scope_id_type _M_scope_id;\n+  };\n+\n+  /// Exception type thrown on misuse of IPv4 addresses as IPv6 or vice versa.\n+  class bad_address_cast : public bad_cast\n+  {\n+  public:\n+    bad_address_cast() { }\n+\n+    const char* what() const noexcept { return \"bad address cast\"; }\n+  };\n+\n+  /// An IPv4 or IPv6 address.\n+  class address\n+  {\n+  public:\n+    // constructors:\n+    constexpr address() noexcept : _M_v4(), _M_is_v4(true) { }\n+\n+    constexpr\n+    address(const address& __a) noexcept : _M_uninit(), _M_is_v4(__a._M_is_v4)\n+    {\n+      if (_M_is_v4)\n+\t::new (std::addressof(_M_v4)) address_v4(__a.to_v4());\n+      else\n+\t::new (std::addressof(_M_v6)) address_v6(__a.to_v6());\n+    }\n+\n+    constexpr\n+    address(const address_v4& __a) noexcept : _M_v4(__a), _M_is_v4(true) { }\n+\n+    constexpr\n+    address(const address_v6& __a) noexcept : _M_v6(__a), _M_is_v4(false) { }\n+\n+    // assignment:\n+    address&\n+    operator=(const address& __a) noexcept\n+    {\n+      if (__a._M_is_v4)\n+\t*this = __a.to_v4();\n+      else\n+\t*this = __a.to_v6();\n+      return *this;\n+    }\n+\n+    address&\n+    operator=(const address_v4& __a) noexcept\n+    {\n+      ::new (std::addressof(_M_v4)) address_v4(__a);\n+      _M_is_v4 = true;\n+      return *this;\n+    }\n+\n+    address&\n+    operator=(const address_v6& __a) noexcept\n+    {\n+      ::new (std::addressof(_M_v6)) address_v6(__a);\n+      _M_is_v4 = false;\n+      return *this;\n+    }\n+\n+    // members:\n+\n+    constexpr bool is_v4() const noexcept { return _M_is_v4; }\n+    constexpr bool is_v6() const noexcept { return !_M_is_v4; }\n+\n+    constexpr address_v4\n+    to_v4() const\n+    {\n+      if (!is_v4())\n+\t_GLIBCXX_THROW_OR_ABORT(bad_address_cast());\n+      return _M_v4;\n+    }\n+\n+    constexpr address_v6\n+    to_v6() const\n+    {\n+      if (!is_v6())\n+\t_GLIBCXX_THROW_OR_ABORT(bad_address_cast());\n+      return _M_v6;\n+    }\n+\n+    constexpr bool\n+    is_unspecified() const noexcept\n+    { return _M_is_v4 ? _M_v4.is_unspecified() : _M_v6.is_unspecified(); }\n+\n+    constexpr bool\n+    is_loopback() const noexcept\n+    { return _M_is_v4 ? _M_v4.is_loopback() : _M_v6.is_loopback(); }\n+\n+    constexpr bool\n+    is_multicast() const noexcept\n+    { return _M_is_v4 ? _M_v4.is_multicast() : _M_v6.is_multicast(); }\n+\n+    template<typename _Allocator = allocator<char>>\n+      __string_with<_Allocator>\n+      to_string(const _Allocator& __a = _Allocator()) const\n+      {\n+\tif (_M_is_v4)\n+\t  return to_v4().to_string(__a);\n+\treturn to_v6().to_string(__a);\n+      }\n+\n+  private:\n+    template<typename _InternetProtocol>\n+      friend class basic_endpoint;\n+\n+    friend constexpr bool\n+    operator==(const address&, const address&) noexcept;\n+\n+    friend constexpr bool\n+    operator<(const address&, const address&) noexcept;\n+\n+    union {\n+      address_v4 _M_v4;\n+      address_v6 _M_v6;\n+      bool\t _M_uninit;\n+    };\n+    bool _M_is_v4;\n+  };\n+\n+  /** ip::address_v4 comparisons\n+   * @{\n+   */\n+\n+  constexpr bool\n+  operator==(const address_v4& __a, const address_v4& __b) noexcept\n+  { return __a.to_uint() == __b.to_uint(); }\n+\n+  constexpr bool\n+  operator!=(const address_v4& __a, const address_v4& __b) noexcept\n+  { return !(__a == __b); }\n+\n+  constexpr bool\n+  operator< (const address_v4& __a, const address_v4& __b) noexcept\n+  { return __a.to_uint() < __b.to_uint(); }\n+\n+  constexpr bool\n+  operator> (const address_v4& __a, const address_v4& __b) noexcept\n+  { return __b < __a; }\n+\n+  constexpr bool\n+  operator<=(const address_v4& __a, const address_v4& __b) noexcept\n+  { return !(__b < __a); }\n+\n+  constexpr bool\n+  operator>=(const address_v4& __a, const address_v4& __b) noexcept\n+  { return !(__a < __b); }\n+\n+  // @}\n+\n+  /** ip::address_v6 comparisons\n+   * @{\n+   */\n+\n+  constexpr bool\n+  operator==(const address_v6& __a, const address_v6& __b) noexcept\n+  {\n+    const auto& __aa = __a._M_bytes;\n+    const auto& __bb = __b._M_bytes;\n+    int __i = 0;\n+    for (; __aa[__i] == __bb[__i] && __i < 16; ++__i)\n+      ;\n+    return __i == 16 ? __a.scope_id() == __b.scope_id() : false;\n+  }\n+\n+  constexpr bool\n+  operator!=(const address_v6& __a, const address_v6& __b) noexcept\n+  { return !(__a == __b); }\n+\n+  constexpr bool\n+  operator< (const address_v6& __a, const address_v6& __b) noexcept\n+  {\n+    const auto& __aa = __a._M_bytes;\n+    const auto& __bb = __b._M_bytes;\n+    int __i = 0;\n+    for (; __aa[__i] == __bb[__i] && __i < 16; ++__i)\n+      ;\n+    return __i == 16 ? __a.scope_id() < __b.scope_id() : __aa[__i] < __bb[__i];\n+  }\n+\n+  constexpr bool\n+  operator> (const address_v6& __a, const address_v6& __b) noexcept\n+  { return __b < __a; }\n+\n+  constexpr bool\n+  operator<=(const address_v6& __a, const address_v6& __b) noexcept\n+  { return !(__b < __a); }\n+\n+  constexpr bool\n+  operator>=(const address_v6& __a, const address_v6& __b) noexcept\n+  { return !(__a < __b); }\n+\n+  // @}\n+\n+  /** ip::address comparisons\n+   * @{\n+   */\n+\n+  constexpr bool\n+  operator==(const address& __a, const address& __b) noexcept\n+  {\n+    if (__a.is_v4())\n+      return __b.is_v4() ? __a._M_v4 == __b._M_v4 : false;\n+    return __b.is_v4() ? false : __a._M_v6 == __b._M_v6;\n+  }\n+\n+  constexpr bool\n+  operator!=(const address& __a, const address& __b) noexcept\n+  { return !(__a == __b); }\n+\n+  constexpr bool\n+  operator< (const address& __a, const address& __b) noexcept\n+  {\n+    if (__a.is_v4())\n+      return __b.is_v4() ? __a._M_v4 < __b._M_v4 : true;\n+    return __b.is_v4() ? false : __a._M_v6 < __b._M_v6;\n+  }\n+\n+  constexpr bool\n+  operator> (const address& __a, const address& __b) noexcept\n+  { return __b < __a; }\n+\n+  constexpr bool\n+  operator<=(const address& __a, const address& __b) noexcept\n+  { return !(__b < __a); }\n+\n+  constexpr bool\n+  operator>=(const address& __a, const address& __b) noexcept\n+  { return !(__a < __b); }\n+\n+  // @}\n+\n+  /** ip::address_v4 creation\n+   * @{\n+   */\n+\n+  constexpr address_v4\n+  make_address_v4(const address_v4::bytes_type& __b)\n+  { return address_v4{__b}; }\n+\n+  constexpr address_v4\n+  make_address_v4(address_v4::uint_type __val)\n+  { return address_v4{__val}; }\n+\n+  constexpr address_v4\n+  make_address_v4(v4_mapped_t, const address_v6& __a)\n+  {\n+    if (!__a.is_v4_mapped())\n+      _GLIBCXX_THROW_OR_ABORT(bad_address_cast());\n+\n+    const auto __v6b = __a.to_bytes();\n+    return address_v4::bytes_type(__v6b[12], __v6b[13], __v6b[14], __v6b[15]);\n+  }\n+\n+  inline address_v4\n+  make_address_v4(const char* __str, error_code& __ec) noexcept\n+  {\n+    address_v4 __a;\n+    const int __res = ::inet_pton(AF_INET, __str, &__a._M_addr);\n+    if (__res == 1)\n+      {\n+\t__ec.clear();\n+\treturn __a;\n+      }\n+    if (__res == 0)\n+      __ec = std::make_error_code(std::errc::invalid_argument);\n+    else\n+      __ec.assign(errno, generic_category());\n+    return {};\n+  }\n+\n+  inline address_v4\n+  make_address_v4(const char* __str)\n+  { return make_address_v4(__str, __throw_on_error{\"make_address_v4\"}); }\n+\n+  inline address_v4\n+  make_address_v4(const string& __str, error_code& __ec) noexcept\n+  { return make_address_v4(__str.c_str(), __ec); }\n+\n+  inline address_v4\n+  make_address_v4(const string& __str)\n+  { return make_address_v4(__str.c_str()); }\n+\n+  inline address_v4\n+  make_address_v4(string_view __str, error_code& __ec) noexcept\n+  {\n+    char __buf[INET_ADDRSTRLEN];\n+    auto __len = __str.copy(__buf, sizeof(__buf));\n+    if (__len == sizeof(__buf))\n+      {\n+\t__ec = std::make_error_code(std::errc::invalid_argument);\n+\treturn {};\n+      }\n+    __ec.clear();\n+    __buf[__len] = '\\0';\n+    return make_address_v4(__buf, __ec);\n+  }\n+\n+  inline address_v4\n+  make_address_v4(string_view __str)\n+  { return make_address_v4(__str, __throw_on_error{\"make_address_v4\"}); }\n+\n+  // @}\n+\n+  /** ip::address_v6 creation\n+   * @{\n+   */\n+\n+  constexpr address_v6\n+  make_address_v6(const address_v6::bytes_type& __b, scope_id_type __scope = 0)\n+  { return address_v6{__b, __scope}; }\n+\n+  constexpr address_v6\n+  make_address_v6(v4_mapped_t, const address_v4& __a) noexcept\n+  {\n+    const address_v4::bytes_type __v4b = __a.to_bytes();\n+    address_v6::bytes_type __v6b(0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t\t 0, 0, 0xFF, 0xFF,\n+\t\t\t\t __v4b[0], __v4b[1], __v4b[2], __v4b[3]);\n+    return address_v6(__v6b);\n+  }\n+\n+  inline address_v6\n+  __make_address_v6(const char* __addr, const char* __scope, error_code& __ec)\n+  {\n+    address_v6::bytes_type __b;\n+    int __res = ::inet_pton(AF_INET6, __addr, __b.data());\n+    if (__res == 1)\n+      {\n+\t__ec.clear();\n+\tif (!__scope)\n+\t  {\n+\t    return { __b };\n+\t  }\n+\n+\tchar* __eptr;\n+\tunsigned long __val = std::strtoul(__scope, &__eptr, 10);\n+\tif (__eptr != __scope && !*__eptr\n+\t    && __val <= numeric_limits<scope_id_type>::max())\n+\t  {\n+\t    return { __b, static_cast<scope_id_type>(__val) };\n+\t  }\n+\t__ec = std::make_error_code(std::errc::invalid_argument);\n+      }\n+    else if (__res == 0)\n+      __ec = std::make_error_code(std::errc::invalid_argument);\n+    else\n+      __ec.assign(errno, generic_category());\n+    return {};\n+  }\n+\n+  inline address_v6\n+  make_address_v6(const char* __str, error_code& __ec) noexcept\n+  {\n+    auto __p = std::strchr(__str, '%');\n+    if (__p == nullptr)\n+      return __make_address_v6(__str, nullptr, __ec);\n+    char __buf[64];\n+    char* __out = __buf;\n+    bool __skip_leading_zero = true;\n+    while (__str < __p && __out < std::end(__buf))\n+      {\n+\tif (!__skip_leading_zero || *__str != '0')\n+\t  {\n+\t    if (*__str == ':' || *__str == '.')\n+\t      __skip_leading_zero = true;\n+\t    else\n+\t      __skip_leading_zero = false;\n+\t    *__out = *__str;\n+\t  }\n+\t__str++;\n+      }\n+    if (__out == std::end(__buf))\n+      __ec = std::make_error_code(std::errc::invalid_argument);\n+    else\n+      {\n+\t*__out = '\\0';\n+\treturn __make_address_v6(__buf, __p + 1, __ec);\n+      }\n+  }\n+\n+  inline address_v6\n+  make_address_v6(const char* __str)\n+  { return make_address_v6(__str, __throw_on_error{\"make_address_v6\"}); }\n+\n+  inline address_v6\n+  make_address_v6(const string& __str, error_code& __ec) noexcept\n+  {\n+    auto __pos = __str.find('%');\n+    if (__pos == string::npos)\n+      return __make_address_v6(__str.c_str(), nullptr, __ec);\n+    char __buf[64];\n+    char* __out = __buf;\n+    bool __skip_leading_zero = true;\n+    size_t __n = 0;\n+    while (__n < __pos && __out < std::end(__buf))\n+      {\n+\tif (!__skip_leading_zero || __str[__n] != '0')\n+\t  {\n+\t    if (__str[__n] == ':' || __str[__n] == '.')\n+\t      __skip_leading_zero = true;\n+\t    else\n+\t      __skip_leading_zero = false;\n+\t    *__out = __str[__n];\n+\t  }\n+\t__n++;\n+      }\n+    if (__out == std::end(__buf))\n+      __ec = std::make_error_code(std::errc::invalid_argument);\n+    else\n+      {\n+\t*__out = '\\0';\n+\treturn __make_address_v6(__buf, __str.c_str() + __pos + 1, __ec);\n+      }\n+  }\n+\n+  inline address_v6\n+  make_address_v6(const string& __str)\n+  { return make_address_v6(__str, __throw_on_error{\"make_address_v6\"}); }\n+\n+  inline address_v6\n+  make_address_v6(string_view __str, error_code& __ec) noexcept\n+  {\n+    char __buf[64];\n+    char* __out = __buf;\n+    char* __scope = nullptr;\n+    bool __skip_leading_zero = true;\n+    size_t __n = 0;\n+    while (__n < __str.length() && __out < std::end(__buf))\n+      {\n+\tif (__str[__n] == '%')\n+\t  {\n+\t    if (__scope)\n+\t      __out = std::end(__buf);\n+\t    else\n+\t      {\n+\t\t*__out = '\\0';\n+\t\t__scope = ++__out;\n+\t\t__skip_leading_zero = true;\n+\t      }\n+\t  }\n+\telse if (!__skip_leading_zero || __str[__n] != '0')\n+\t  {\n+\t    if (__str[__n] == ':' || __str[__n] == '.')\n+\t      __skip_leading_zero = true;\n+\t    else\n+\t      __skip_leading_zero = false;\n+\t    *__out = __str[__n];\n+\t    __out++;\n+\t  }\n+\t__n++;\n+      }\n+    if (__out == std::end(__buf))\n+      __ec = std::make_error_code(std::errc::invalid_argument);\n+    else\n+      {\n+\t*__out = '\\0';\n+\treturn __make_address_v6(__buf, __scope, __ec);\n+      }\n+  }\n+\n+  inline address_v6\n+  make_address_v6(string_view __str)\n+  { return make_address_v6(__str, __throw_on_error{\"make_address_v6\"}); }\n+\n+  // @}\n+\n+  /** ip::address creation\n+   * @{\n+   */\n+\n+  inline address\n+  make_address(const char* __str, error_code& __ec) noexcept\n+  {\n+    address __a;\n+    address_v6 __v6a = make_address_v6(__str, __ec);\n+    if (!__ec)\n+      __a = __v6a;\n+    else\n+    {\n+      address_v4 __v4a = make_address_v4(__str, __ec);\n+      if (!__ec)\n+\t__a = __v4a;\n+    }\n+    return __a;\n+  }\n+\n+  inline address\n+  make_address(const char* __str)\n+  { return make_address(__str, __throw_on_error{\"make_address\"}); }\n+\n+  inline address\n+  make_address(const string& __str, error_code& __ec) noexcept; // TODO\n+\n+  inline address\n+  make_address(const string& __str)\n+  { return make_address(__str, __throw_on_error{\"make_address\"}); }\n+\n+  inline address\n+  make_address(string_view __str, error_code& __ec) noexcept\n+  {\n+    if (__str.rfind('\\0') != string_view::npos)\n+      return make_address(__str.data(), __ec);\n+    return make_address(__str.to_string(), __ec); // TODO don't allocate\n+  }\n+\n+  inline address\n+  make_address(string_view __str)\n+  { return make_address(__str, __throw_on_error{\"make_address\"}); }\n+\n+  // @}\n+\n+  /// ip::address I/O\n+  template<typename _CharT, typename _Traits>\n+    inline basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os, const address& __a)\n+    { return __os << __a.to_string(); }\n+\n+  /// ip::address_v4 I/O\n+  template<typename _CharT, typename _Traits>\n+    inline basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os, const address_v4& __a)\n+    { return __os << __a.to_string(); }\n+\n+  /// ip::address_v6 I/O\n+  template<typename _CharT, typename _Traits>\n+    inline basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os, const address_v6& __a)\n+    { return __os << __a.to_string(); }\n+\n+  template<typename> class basic_address_iterator; // not defined\n+\n+  template<> class basic_address_iterator<address_v4>\n+  {\n+  public:\n+    // types:\n+    typedef address_v4 value_type;\n+    typedef ptrdiff_t difference_type;\n+    typedef const address_v4* pointer;\n+    typedef const address_v4& reference;\n+    typedef input_iterator_tag iterator_category;\n+\n+    // constructors:\n+    basic_address_iterator(const address_v4& __a) noexcept\n+    : _M_address(__a) { }\n+\n+    // members:\n+    reference operator*() const noexcept { return _M_address; }\n+    pointer operator->() const noexcept { return &_M_address; }\n+\n+    basic_address_iterator&\n+    operator++() noexcept\n+    {\n+      _M_address = value_type(_M_address.to_uint() + 1);\n+      return *this;\n+    }\n+\n+    basic_address_iterator operator++(int) noexcept\n+    {\n+      auto __tmp = *this;\n+      ++*this;\n+      return __tmp;\n+    }\n+\n+    basic_address_iterator& operator--() noexcept\n+    {\n+      _M_address = value_type(_M_address.to_uint() - 1);\n+      return *this;\n+    }\n+\n+    basic_address_iterator\n+    operator--(int) noexcept\n+    {\n+      auto __tmp = *this;\n+      --*this;\n+      return __tmp;\n+    }\n+\n+    bool\n+    operator==(const basic_address_iterator& __rhs) const noexcept\n+    { return _M_address == __rhs._M_address; }\n+\n+    bool\n+    operator!=(const basic_address_iterator& __rhs) const noexcept\n+    { return _M_address != __rhs._M_address; }\n+\n+  private:\n+    address_v4 _M_address;\n+  };\n+\n+  typedef basic_address_iterator<address_v4> address_v4_iterator;\n+\n+  template<> class basic_address_iterator<address_v6>\n+  {\n+  public:\n+    // types:\n+    typedef address_v6 value_type;\n+    typedef ptrdiff_t difference_type;\n+    typedef const address_v6* pointer;\n+    typedef const address_v6& reference;\n+    typedef input_iterator_tag iterator_category;\n+\n+    // constructors:\n+    basic_address_iterator(const address_v6& __a) noexcept\n+    : _M_address(__a) { }\n+\n+    // members:\n+    reference operator*() const noexcept { return _M_address; }\n+    pointer operator->() const noexcept { return &_M_address; }\n+\n+    basic_address_iterator&\n+    operator++() noexcept; // TODO\n+\n+    basic_address_iterator\n+    operator++(int) noexcept\n+    {\n+      auto __tmp = *this;\n+      ++*this;\n+      return __tmp;\n+    }\n+\n+    basic_address_iterator&\n+    operator--() noexcept; // TODO\n+\n+    basic_address_iterator\n+    operator--(int) noexcept\n+    {\n+      auto __tmp = *this;\n+      --*this;\n+      return __tmp;\n+    }\n+\n+    bool\n+    operator==(const basic_address_iterator& __rhs) const noexcept\n+    { return _M_address == __rhs._M_address; }\n+\n+    bool\n+    operator!=(const basic_address_iterator& __rhs) const noexcept\n+    { return _M_address != __rhs._M_address; }\n+\n+  private:\n+    address_v6 _M_address;\n+  };\n+\n+  typedef basic_address_iterator<address_v6> address_v6_iterator;\n+\n+  template<typename> class basic_address_range; // not defined\n+\n+  /** An IPv6 address range.\n+   * @{\n+   */\n+\n+  template<> class basic_address_range<address_v4>\n+  {\n+  public:\n+    // types:\n+\n+    typedef basic_address_iterator<address_v4> iterator;\n+\n+    // constructors:\n+\n+    basic_address_range() noexcept : _M_begin({}), _M_end({}) { }\n+\n+    basic_address_range(const address_v4& __first,\n+                        const address_v4& __last) noexcept\n+    : _M_begin(__first), _M_end(__last) { }\n+\n+    // members:\n+\n+    iterator begin() const noexcept { return _M_begin; }\n+    iterator end() const noexcept { return _M_end; }\n+    bool empty() const noexcept { return _M_begin == _M_end; }\n+\n+    size_t\n+    size() const noexcept { return _M_end->to_uint() - _M_begin->to_uint(); }\n+\n+    iterator\n+    find(const address_v4& __addr) const noexcept\n+    {\n+      if (*_M_begin <= __addr && __addr < *_M_end)\n+\treturn iterator{__addr};\n+      return end();\n+    }\n+\n+  private:\n+    iterator _M_begin;\n+    iterator _M_end;\n+  };\n+\n+  typedef basic_address_range<address_v4> address_v4_range;\n+\n+  // @}\n+\n+  /** An IPv6 address range.\n+   * @{\n+   */\n+\n+  template<> class basic_address_range<address_v6>\n+  {\n+  public:\n+    // types:\n+\n+    typedef basic_address_iterator<address_v6> iterator;\n+\n+    // constructors:\n+\n+    basic_address_range() noexcept : _M_begin({}), _M_end({}) { }\n+    basic_address_range(const address_v6& __first,\n+                        const address_v6& __last) noexcept\n+    : _M_begin(__first), _M_end(__last) { }\n+\n+    // members:\n+\n+    iterator begin() const noexcept { return _M_begin; }\n+    iterator end() const noexcept { return _M_end; }\n+    bool empty() const noexcept { return _M_begin == _M_end; }\n+\n+    iterator\n+    find(const address_v6& __addr) const noexcept\n+    {\n+      if (*_M_begin <= __addr && __addr < *_M_end)\n+\treturn iterator{__addr};\n+      return end();\n+    }\n+\n+  private:\n+    iterator _M_begin;\n+    iterator _M_end;\n+  };\n+\n+  typedef basic_address_range<address_v6> address_v6_range;\n+\n+  bool\n+  operator==(const network_v4& __a, const network_v4& __b) noexcept;\n+\n+  bool\n+  operator==(const network_v6& __a, const network_v6& __b) noexcept;\n+\n+  // @}\n+\n+  /// An IPv4 network address.\n+  class network_v4\n+  {\n+  public:\n+    // constructors:\n+    constexpr network_v4() noexcept : _M_addr(), _M_prefix_len(0) { }\n+\n+    constexpr\n+    network_v4(const address_v4& __addr, int __prefix_len)\n+    : _M_addr(__addr), _M_prefix_len(__prefix_len)\n+    {\n+      if (_M_prefix_len < 0 || _M_prefix_len > 32)\n+\t__throw_out_of_range(\"network_v4: invalid prefix length\");\n+    }\n+\n+    constexpr\n+    network_v4(const address_v4& __addr, const address_v4& __mask)\n+    : _M_addr(__addr), _M_prefix_len(__builtin_popcount(__mask.to_uint()))\n+    {\n+      if (_M_prefix_len != 0)\n+\t{\n+\t  address_v4::uint_type __mask_uint = __mask.to_uint();\n+\t  if (__builtin_ctz(__mask_uint) != (32 - _M_prefix_len))\n+\t    __throw_invalid_argument(\"network_v4: invalid mask\");\n+\t  if ((__mask_uint & 0x80000000) == 0)\n+\t    __throw_invalid_argument(\"network_v4: invalid mask\");\n+\t}\n+    }\n+\n+    // members:\n+\n+    constexpr address_v4 address() const noexcept { return _M_addr; }\n+    constexpr int prefix_length() const noexcept { return _M_prefix_len; }\n+\n+    constexpr address_v4\n+    netmask() const noexcept\n+    {\n+      address_v4::uint_type __val = address_v4::broadcast().to_uint();\n+      __val >>= (32 - _M_prefix_len);\n+      __val <<= (32 - _M_prefix_len);\n+      return address_v4{__val};\n+    }\n+\n+    constexpr address_v4\n+    network() const noexcept\n+    { return address_v4{_M_addr.to_uint() & netmask().to_uint()}; }\n+\n+    constexpr address_v4\n+    broadcast() const noexcept\n+    { return address_v4{_M_addr.to_uint() | ~netmask().to_uint()}; }\n+\n+    address_v4_range\n+    hosts() const noexcept\n+    {\n+      if (is_host())\n+\treturn { address(), *++address_v4_iterator(address()) };\n+      return { network(), broadcast() };\n+    }\n+\n+    constexpr network_v4\n+    canonical() const noexcept\n+    { return network_v4(network(), prefix_length()); }\n+\n+    constexpr bool is_host() const noexcept { return _M_prefix_len == 32; }\n+\n+    constexpr bool\n+    is_subnet_of(const network_v4& __other) const noexcept\n+    {\n+      if (__other.prefix_length() < prefix_length())\n+\t{\n+\t  network_v4 __net(address(), __other.prefix_length());\n+\t  return __net.canonical() == __other.canonical();\n+\t}\n+      return false;\n+    }\n+\n+    template<typename _Allocator = allocator<char>>\n+      __string_with<_Allocator>\n+      to_string(const _Allocator& __a = _Allocator()) const\n+      {\n+\treturn address().to_string(__a) + '/'\n+\t  + std::to_string(prefix_length());\n+      }\n+\n+  private:\n+    address_v4 _M_addr;\n+    int _M_prefix_len;\n+  };\n+\n+  /// An IPv6 network address.\n+  class network_v6\n+  {\n+  public:\n+    // constructors:\n+    constexpr network_v6() noexcept : _M_addr(), _M_prefix_len(0) { }\n+\n+    constexpr\n+    network_v6(const address_v6& __addr, int __prefix_len)\n+    : _M_addr(__addr), _M_prefix_len(__prefix_len)\n+    {\n+      if (_M_prefix_len < 0 || _M_prefix_len > 128)\n+\t__throw_out_of_range(\"network_v6: invalid prefix length\");\n+    }\n+\n+    // members:\n+    constexpr address_v6 address() const noexcept { return _M_addr; }\n+    constexpr int prefix_length() const noexcept { return _M_prefix_len; }\n+\n+    constexpr address_v6 network() const noexcept; // TODO\n+\n+    address_v6_range\n+    hosts() const noexcept\n+    {\n+      if (is_host())\n+\treturn { address(), *++address_v6_iterator(address()) };\n+      return {}; // { network(), XXX broadcast() XXX }; // TODO\n+    }\n+\n+    constexpr network_v6\n+    canonical() const noexcept\n+    { return network_v6{network(), prefix_length()}; }\n+\n+    constexpr bool is_host() const noexcept { return _M_prefix_len == 128; }\n+\n+    constexpr bool\n+    is_subnet_of(const network_v6& __other) const noexcept\n+    {\n+      if (__other.prefix_length() < prefix_length())\n+\t{\n+\t  network_v6 __net(address(), __other.prefix_length());\n+\t  return __net.canonical() == __other.canonical();\n+\t}\n+      return false;\n+    }\n+\n+    template<typename _Allocator = allocator<char>>\n+      __string_with<_Allocator>\n+      to_string(const _Allocator& __a = _Allocator()) const\n+      {\n+\treturn address().to_string(__a) + '/'\n+\t  + std::to_string(prefix_length());\n+      }\n+\n+  private:\n+    address_v6 _M_addr;\n+    int _M_prefix_len;\n+  };\n+\n+\n+  /** ip::network_v4 comparisons\n+   * @{\n+   */\n+\n+  inline bool\n+  operator==(const network_v4& __a, const network_v4& __b) noexcept\n+  {\n+    return __a.address() == __b.address()\n+      && __a.prefix_length() == __b.prefix_length();\n+  }\n+\n+  inline bool\n+  operator!=(const network_v4& __a, const network_v4& __b) noexcept\n+  { return !(__a == __b); }\n+\n+  // @}\n+\n+  /** ip::network_v6 comparisons\n+   * @{\n+   */\n+\n+  inline bool\n+  operator==(const network_v6& __a, const network_v6& __b) noexcept\n+  {\n+    return __a.address() == __b.address()\n+      && __a.prefix_length() == __b.prefix_length();\n+  }\n+\n+  inline bool\n+  operator!=(const network_v6& __a, const network_v6& __b) noexcept\n+  { return !(__a == __b); }\n+\n+  // @}\n+\n+  /** ip::network_v4 creation\n+   * @{\n+   */\n+\n+  inline network_v4\n+  make_network_v4(const address_v4& __a, int __prefix_len)\n+  { return network_v4{__a, __prefix_len}; }\n+\n+  network_v4\n+  make_network_v4(const address_v4& __a, const address_v4& __mask)\n+  { return network_v4{ __a, __mask }; }\n+\n+  network_v4 make_network_v4(const char*, error_code&) noexcept; // TODO\n+\n+  inline network_v4\n+  make_network_v4(const char* __str)\n+  { return make_network_v4(__str, __throw_on_error{\"make_network_v4\"}); }\n+\n+  network_v4 make_network_v4(const string&, error_code&) noexcept; // TODO\n+\n+  inline network_v4\n+  make_network_v4(const string& __str)\n+  { return make_network_v4(__str, __throw_on_error{\"make_network_v4\"}); }\n+\n+  network_v4 make_network_v4(string_view, error_code&) noexcept; // TODO\n+\n+  inline network_v4\n+  make_network_v4(string_view __str)\n+  { return make_network_v4(__str, __throw_on_error{\"make_network_v4\"}); }\n+\n+  // @}\n+\n+  /** ip::network_v6 creation\n+   * @{\n+   */\n+\n+  inline network_v6\n+  make_network_v6(const address_v6& __a, int __prefix_len)\n+  { return network_v6{__a, __prefix_len}; }\n+\n+  network_v6 make_network_v6(const char*, error_code&) noexcept; // TODO\n+\n+  inline network_v6\n+  make_network_v6(const char* __str)\n+  { return make_network_v6(__str, __throw_on_error{\"make_network_v6\"}); }\n+\n+  network_v6 make_network_v6(const string&, error_code&) noexcept; // TODO\n+\n+  inline network_v6\n+  make_network_v6(const string& __str)\n+  { return make_network_v6(__str, __throw_on_error{\"make_network_v6\"}); }\n+\n+  network_v6 make_network_v6(string_view, error_code&) noexcept; // TODO\n+\n+  inline network_v6\n+  make_network_v6(string_view __str)\n+  { return make_network_v6(__str, __throw_on_error{\"make_network_v6\"}); }\n+\n+  // @}\n+\n+  /// ip::network_v4 I/O\n+  template<typename _CharT, typename _Traits>\n+    inline basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os, const network_v4& __net)\n+    { return __os << __net.to_string(); }\n+\n+  /// ip::network_v6 I/O\n+  template<typename _CharT, typename _Traits>\n+    inline basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os, const network_v6& __net)\n+    { return __os << __net.to_string(); }\n+\n+  /// An IP endpoint.\n+  template<typename _InternetProtocol>\n+    class basic_endpoint\n+    {\n+    public:\n+      // types:\n+      typedef _InternetProtocol protocol_type;\n+\n+      // constructors:\n+\n+      constexpr\n+      basic_endpoint() noexcept : _M_data()\n+      { _M_data._M_v4.sin_family = protocol_type::v4().family(); }\n+\n+      constexpr\n+      basic_endpoint(const protocol_type& __proto,\n+\t\t     port_type __port_num) noexcept\n+      : _M_data()\n+      {\n+\t__glibcxx_assert(__proto == protocol_type::v4()\n+\t\t\t  || __proto == protocol_type::v6());\n+\n+\t_M_data._M_v4.sin_family = __proto.family();\n+\t_M_data._M_v4.sin_port = address_v4::_S_hton(__port_num);\n+      }\n+\n+      constexpr\n+      basic_endpoint(const ip::address& __addr,\n+\t\t     port_type __port_num) noexcept\n+      : _M_data()\n+      {\n+\tif (__addr.is_v4())\n+\t  {\n+\t    _M_data._M_v4.sin_family = protocol_type::v4().family();\n+\t    _M_data._M_v4.sin_port = address_v4::_S_hton(__port_num);\n+\t    _M_data._M_v4.sin_addr.s_addr = __addr._M_v4._M_addr;\n+\t  }\n+\telse\n+\t  {\n+\t    _M_data._M_v6 = {};\n+\t    _M_data._M_v6.sin6_family = protocol_type::v6().family();\n+\t    _M_data._M_v6.sin6_port = address_v4::_S_hton(__port_num);\n+\t    std::memcpy(_M_data._M_v6.sin6_addr.s6_addr,\n+\t\t\t__addr._M_v6._M_bytes.data(), 16);\n+\t    _M_data._M_v6.sin6_scope_id = __addr._M_v6._M_scope_id;\n+\t  }\n+      }\n+\n+      // members:\n+      constexpr protocol_type protocol() const noexcept\n+      {\n+\treturn _M_data._M_v4.sin_family == AF_INET6\n+\t  ? protocol_type::v6() : protocol_type::v4();\n+      }\n+\n+      constexpr ip::address\n+      address() const noexcept\n+      {\n+\tip::address __addr;\n+\tif (protocol().family() == AF_INET6)\n+\t  {\n+\t    std::memcpy(&__addr._M_v6._M_bytes,\n+\t\t\t_M_data._M_v6.sin6_addr.s6_addr, 16);\n+\t    __addr._M_is_v4 = false;\n+\t  }\n+\telse\n+\t  {\n+\t    std::memcpy(&__addr._M_v4._M_addr,\n+\t\t\t&_M_data._M_v4.sin_addr.s_addr, 4);\n+\t  }\n+\treturn __addr;\n+      }\n+\n+      void\n+      address(const ip::address& __addr) noexcept\n+      {\n+\tif (__addr.is_v6())\n+\t  {\n+\t    _M_data._M_v6 = {};\n+\t    _M_data._M_v6.sin6_family = protocol_type::v6().family();\n+\t    std::memcpy(_M_data._M_v6.sin6_addr.s6_addr,\n+\t\t\t__addr._M_v6._M_bytes.data(), 16);\n+\t    _M_data._M_v6.sin6_scope_id = __addr._M_v6._M_scope_id;\n+\t  }\n+\telse\n+\t  {\n+\t    _M_data._M_v4.sin_family = protocol_type::v4().family();\n+\t    _M_data._M_v4.sin_addr.s_addr = __addr._M_v4._M_addr;\n+\t  }\n+      }\n+\n+      constexpr port_type\n+      port() const noexcept\n+      { return address_v4::_S_ntoh(_M_data._M_v4.sin_port); }\n+\n+      void\n+      port(port_type __port_num) noexcept\n+      { _M_data._M_v4.sin_port = address_v4::_S_hton(__port_num); }\n+\n+      void* data() noexcept { return &_M_data; }\n+      const void* data() const noexcept { return &_M_data; }\n+      constexpr size_t size() const noexcept\n+      {\n+\treturn protocol().family() == AF_INET6\n+\t  ? sizeof(sockaddr_in6) : sizeof(sockaddr_in);\n+      }\n+\n+      void\n+      resize(size_t __s)\n+      {\n+\tif ((protocol().family() == AF_INET6 && __s != sizeof(sockaddr_in6))\n+\t    || (protocol().family() == AF_INET && __s != sizeof(sockaddr_in)))\n+\t  __throw_length_error(\"net::ip::basic_endpoint::resize\");\n+      }\n+\n+      constexpr size_t capacity() const noexcept { return sizeof(_M_data); }\n+\n+    private:\n+      union\n+      {\n+\tsockaddr_in\t_M_v4;\n+\tsockaddr_in6\t_M_v6;\n+      } _M_data;\n+    };\n+\n+  /** basic_endpoint comparisons\n+   * @{\n+   */\n+\n+  template<typename _InternetProtocol>\n+    inline bool\n+    operator==(const basic_endpoint<_InternetProtocol>& __a,\n+\t       const basic_endpoint<_InternetProtocol>& __b)\n+    { return __a.address() == __b.address() && __a.port() == __b.port(); }\n+\n+  template<typename _InternetProtocol>\n+    inline bool\n+    operator!=(const basic_endpoint<_InternetProtocol>& __a,\n+\t       const basic_endpoint<_InternetProtocol>& __b)\n+    { return !(__a == __b); }\n+\n+  template<typename _InternetProtocol>\n+    inline bool\n+    operator< (const basic_endpoint<_InternetProtocol>& __a,\n+\t       const basic_endpoint<_InternetProtocol>& __b)\n+    {\n+      return __a.address() < __b.address()\n+\t|| (!(__b.address() < __a.address()) && __a.port() < __b.port());\n+    }\n+\n+  template<typename _InternetProtocol>\n+    inline bool\n+    operator> (const basic_endpoint<_InternetProtocol>& __a,\n+\t       const basic_endpoint<_InternetProtocol>& __b)\n+    { return __b < __a; }\n+\n+  template<typename _InternetProtocol>\n+    inline bool\n+    operator<=(const basic_endpoint<_InternetProtocol>& __a,\n+\t       const basic_endpoint<_InternetProtocol>& __b)\n+    { return !(__b < __a); }\n+\n+  template<typename _InternetProtocol>\n+    inline bool\n+    operator>=(const basic_endpoint<_InternetProtocol>& __a,\n+\t       const basic_endpoint<_InternetProtocol>& __b)\n+    { return !(__a < __b); }\n+\n+  // @}\n+\n+  /// basic_endpoint I/O\n+  template<typename _CharT, typename _Traits, typename _InternetProtocol>\n+    inline basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os,\n+\t       const basic_endpoint<_InternetProtocol>& __ep)\n+    {\n+      basic_ostringstream<_CharT, _Traits> __ss;\n+      if (__ep.protocol()\n+\t  == basic_endpoint<_InternetProtocol>::protocol_type::v6())\n+\t__ss << '[' << __ep.address() << ']';\n+      else\n+\t__ss << __ep.address();\n+      __ss << ':' << __ep.port();\n+      __os << __ss.str();\n+      return __os;\n+    }\n+\n+  /** Type representing a single result of name/address resolution.\n+   * @{\n+   */\n+\n+  template<typename _InternetProtocol>\n+    class basic_resolver_entry\n+    {\n+    public:\n+      // types:\n+      typedef _InternetProtocol protocol_type;\n+      typedef typename _InternetProtocol::endpoint endpoint_type;\n+\n+      // constructors:\n+      basic_resolver_entry() { }\n+\n+      basic_resolver_entry(const endpoint_type& __ep,\n+\t\t\t   string_view __h, string_view __s)\n+      : _M_ep(__ep), _M_host(__h), _M_svc(__s) { }\n+\n+      // members:\n+      endpoint_type endpoint() const { return _M_ep; }\n+      operator endpoint_type() const { return _M_ep; }\n+\n+      template<typename _Allocator = allocator<char>>\n+\t__string_with<_Allocator>\n+\thost_name(const _Allocator& __a = _Allocator()) const\n+\t{ return { _M_host, __a }; }\n+\n+      template<typename _Allocator = allocator<char>>\n+\t__string_with<_Allocator>\n+\tservice_name(const _Allocator& __a = _Allocator()) const\n+\t{ return { _M_svc, __a }; }\n+\n+    private:\n+      basic_endpoint<_InternetProtocol> _M_ep;\n+      string _M_host;\n+      string _M_svc;\n+    };\n+\n+  template<typename _InternetProtocol>\n+    inline bool\n+    operator==(const basic_resolver_entry<_InternetProtocol>& __a,\n+\t       const basic_resolver_entry<_InternetProtocol>& __b)\n+    {\n+      return __a.endpoint() == __b.endpoint()\n+\t&& __a.host_name() == __b.host_name()\n+\t&& __a.service_name() == __b.service_name();\n+    }\n+\n+  template<typename _InternetProtocol>\n+    inline bool\n+    operator!=(const basic_resolver_entry<_InternetProtocol>& __a,\n+\t       const basic_resolver_entry<_InternetProtocol>& __b)\n+    { return !(__a == __b); }\n+\n+  // @}\n+\n+  /** Base class defining flags for name/address resolution.\n+   * @{\n+   */\n+\n+  class resolver_base\n+  {\n+  public:\n+    enum flags : int\n+    {\n+      __flags_passive\t\t\t= AI_PASSIVE,\n+      __flags_canonical_name\t\t= AI_CANONNAME,\n+      __flags_numeric_host\t\t= AI_NUMERICHOST,\n+      __flags_numeric_service\t\t= AI_NUMERICSERV,\n+      __flags_v4_mapped\t\t\t= AI_V4MAPPED,\n+      __flags_all_matching\t\t= AI_ALL,\n+      __flags_address_configured\t= AI_ADDRCONFIG\n+    };\n+    static constexpr flags passive\t\t= __flags_passive;\n+    static constexpr flags canonical_name\t= __flags_canonical_name;\n+    static constexpr flags numeric_host\t\t= __flags_numeric_host;\n+    static constexpr flags numeric_service\t= __flags_numeric_service;\n+    static constexpr flags v4_mapped\t\t= __flags_v4_mapped;\n+    static constexpr flags all_matching\t\t= __flags_all_matching;\n+    static constexpr flags address_configured\t= __flags_address_configured;\n+\n+  protected:\n+    resolver_base() = default;\n+    ~resolver_base() = default;\n+  };\n+\n+  constexpr resolver_base::flags\n+  operator&(resolver_base::flags __f1, resolver_base::flags __f2)\n+  { return resolver_base::flags( int(__f1) & int(__f2) ); }\n+\n+  constexpr resolver_base::flags\n+  operator|(resolver_base::flags __f1, resolver_base::flags __f2)\n+  { return resolver_base::flags( int(__f1) | int(__f2) ); }\n+\n+  constexpr resolver_base::flags\n+  operator^(resolver_base::flags __f1, resolver_base::flags __f2)\n+  { return resolver_base::flags( int(__f1) ^ int(__f2) ); }\n+\n+  constexpr resolver_base::flags\n+  operator~(resolver_base::flags __f)\n+  { return resolver_base::flags( ~int(__f) ); }\n+\n+  inline resolver_base::flags&\n+  operator&=(resolver_base::flags& __f1, resolver_base::flags __f2)\n+  { return __f1 = (__f1 & __f2); }\n+\n+  inline resolver_base::flags&\n+  operator|=(resolver_base::flags& __f1, resolver_base::flags __f2)\n+  { return __f1 = (__f1 | __f2); }\n+\n+  inline resolver_base::flags&\n+  operator^=(resolver_base::flags& __f1, resolver_base::flags __f2)\n+  { return __f1 = (__f1 ^ __f2); }\n+\n+  // TODO define resolver_base::flags static constants\n+\n+  // @}\n+\n+  /** Container for results of name/address resolution.\n+   * @{\n+   */\n+\n+  template<typename _InternetProtocol>\n+    class basic_resolver_results\n+    {\n+    public:\n+      // types:\n+      typedef _InternetProtocol protocol_type;\n+      typedef typename protocol_type::endpoint endpoint_type;\n+      typedef basic_resolver_entry<protocol_type> value_type;\n+      typedef const value_type& const_reference;\n+      typedef value_type& reference;\n+      typedef typename forward_list<value_type>::const_iterator const_iterator;\n+      typedef const_iterator iterator;\n+      typedef ptrdiff_t difference_type;\n+      typedef size_t size_type;\n+\n+      // construct / copy / destroy:\n+\n+      basic_resolver_results() = default;\n+\n+      basic_resolver_results(const basic_resolver_results&) = default;\n+\n+      basic_resolver_results(basic_resolver_results&&) noexcept = default;\n+\n+      basic_resolver_results&\n+      operator=(const basic_resolver_results&) = default;\n+\n+      basic_resolver_results&\n+      operator=(basic_resolver_results&&) = default;\n+\n+      ~basic_resolver_results() = default;\n+\n+      // size:\n+      size_type size() const noexcept { return _M_size; }\n+      size_type max_size() const noexcept { return _M_results.max_size(); }\n+      bool empty() const noexcept { return _M_results.empty(); }\n+\n+      // element access:\n+      const_iterator begin() const { return _M_results.begin(); }\n+      const_iterator end() const { return _M_results.end(); }\n+      const_iterator cbegin() const { return _M_results.begin(); }\n+      const_iterator cend() const { return _M_results.end(); }\n+\n+      // swap:\n+      void\n+      swap(basic_resolver_results& __that) noexcept\n+      { _M_results.swap(__that._M_results); }\n+\n+    private:\n+      friend class basic_resolver<protocol_type>;\n+\n+      basic_resolver_results(string_view, string_view, resolver_base::flags,\n+\t\t\t     error_code&, protocol_type* = nullptr);\n+\n+      basic_resolver_results(const endpoint_type&, error_code&);\n+\n+      forward_list<value_type> _M_results;\n+      size_t _M_size = 0;\n+    };\n+\n+  template<typename _InternetProtocol>\n+    inline bool\n+    operator==(const basic_resolver_results<_InternetProtocol>& __a,\n+\t       const basic_resolver_results<_InternetProtocol>& __b)\n+    {\n+      return __a.size() == __b.size()\n+\t&& std::equal(__a.begin(), __a.end(), __b.begin());\n+    }\n+\n+  template<typename _InternetProtocol>\n+    inline bool\n+    operator!=(const basic_resolver_results<_InternetProtocol>& __a,\n+\t       const basic_resolver_results<_InternetProtocol>& __b)\n+    { return !(__a == __b); }\n+\n+  // @}\n+\n+  /// Perform name/address resolution.\n+  template<typename _InternetProtocol>\n+    class basic_resolver : public resolver_base\n+    {\n+    public:\n+      // types:\n+\n+      typedef io_context::executor_type executor_type;\n+      typedef _InternetProtocol protocol_type;\n+      typedef typename _InternetProtocol::endpoint endpoint_type;\n+      typedef basic_resolver_results<_InternetProtocol> results_type;\n+\n+      // construct / copy / destroy:\n+\n+      explicit basic_resolver(io_context& __ctx) : _M_ctx(&__ctx) { }\n+\n+      basic_resolver(const basic_resolver&) = delete;\n+\n+      basic_resolver(basic_resolver&& __rhs) noexcept\n+      : _M_ctx(__rhs._M_ctx)\n+      { } // TODO move state/tasks etc.\n+\n+      ~basic_resolver() { cancel(); }\n+\n+      basic_resolver& operator=(const basic_resolver&) = delete;\n+\n+      basic_resolver& operator=(basic_resolver&& __rhs)\n+      {\n+\tcancel();\n+\t_M_ctx = __rhs._M_ctx;\n+\t// TODO move state/tasks etc.\n+\treturn *this;\n+      }\n+\n+      // basic_resolver operations:\n+\n+      executor_type get_executor() noexcept { return _M_ctx->get_executor(); }\n+\n+      void cancel() { } // TODO\n+\n+      results_type\n+      resolve(string_view __host_name, string_view __service_name)\n+      {\n+\treturn resolve(__host_name, __service_name, resolver_base::flags(),\n+\t\t       __throw_on_error{\"basic_resolver::resolve\"});\n+      }\n+\n+      results_type\n+      resolve(string_view __host_name, string_view __service_name,\n+\t      error_code& __ec)\n+      {\n+\treturn resolve(__host_name, __service_name, resolver_base::flags(),\n+\t\t       __ec);\n+      }\n+\n+      results_type\n+      resolve(string_view __host_name, string_view __service_name, flags __f)\n+      {\n+\treturn resolve(__host_name, __service_name, __f,\n+\t\t       __throw_on_error{\"basic_resolver::resolve\"});\n+      }\n+\n+      results_type\n+      resolve(string_view __host_name, string_view __service_name, flags __f,\n+\t      error_code& __ec)\n+      { return {__host_name, __service_name, __f, __ec}; }\n+\n+      template<typename _CompletionToken>\n+\t__deduced_t<_CompletionToken, void(error_code, results_type)>\n+\tasync_resolve(string_view __host_name, string_view __service_name,\n+\t\t      _CompletionToken&& __token)\n+\t{\n+\t  return async_resolve(__host_name, __service_name,\n+\t\t\t       resolver_base::flags(),\n+\t\t\t       forward<_CompletionToken>(__token));\n+\t}\n+\n+      template<typename _CompletionToken>\n+\t__deduced_t<_CompletionToken, void(error_code, results_type)>\n+\tasync_resolve(string_view __host_name, string_view __service_name,\n+\t\t      flags __f, _CompletionToken&& __token); // TODO\n+\n+      results_type\n+      resolve(const protocol_type& __protocol,\n+\t      string_view __host_name, string_view __service_name)\n+      {\n+\treturn resolve(__protocol, __host_name, __service_name,\n+\t\t       resolver_base::flags(),\n+\t\t       __throw_on_error{\"basic_resolver::resolve\"});\n+      }\n+\n+      results_type\n+      resolve(const protocol_type& __protocol,\n+\t      string_view __host_name, string_view __service_name,\n+\t      error_code& __ec)\n+      {\n+\treturn resolve(__protocol, __host_name, __service_name,\n+\t\t       resolver_base::flags(), __ec);\n+      }\n+\n+      results_type\n+      resolve(const protocol_type& __protocol,\n+\t      string_view __host_name, string_view __service_name, flags __f)\n+      {\n+\treturn resolve(__protocol, __host_name, __service_name, __f,\n+\t\t       __throw_on_error{\"basic_resolver::resolve\"});\n+      }\n+\n+      results_type\n+      resolve(const protocol_type& __protocol,\n+\t      string_view __host_name, string_view __service_name,\n+\t      flags __f, error_code& __ec)\n+      { return {__host_name, __service_name, __f, __ec, &__protocol}; }\n+\n+      template<typename _CompletionToken>\n+\t__deduced_t<_CompletionToken, void(error_code, results_type)>\n+\tasync_resolve(const protocol_type& __protocol,\n+\t\t      string_view __host_name, string_view __service_name,\n+\t\t      _CompletionToken&& __token)\n+\t{\n+\t  return async_resolve(__protocol, __host_name, __service_name,\n+\t\t\t       resolver_base::flags(),\n+\t\t\t       forward<_CompletionToken>(__token));\n+\t}\n+\n+      template<typename _CompletionToken>\n+\t__deduced_t<_CompletionToken, void(error_code, results_type)>\n+\tasync_resolve(const protocol_type& __protocol,\n+\t\t      string_view __host_name, string_view __service_name,\n+\t\t      flags __f, _CompletionToken&& __token); // TODO\n+\n+      results_type\n+      resolve(const endpoint_type& __ep)\n+      { return resolve(__ep, __throw_on_error{\"basic_resolver::resolve\"}); }\n+\n+      results_type\n+      resolve(const endpoint_type& __ep, error_code& __ec)\n+      { return { __ep, __ec }; }\n+\n+      template<typename _CompletionToken> // TODO\n+\t__deduced_t<_CompletionToken, void(error_code, results_type)>\n+\tasync_resolve(const endpoint_type& __ep, _CompletionToken&& __token);\n+\n+    private:\n+      io_context* _M_ctx;\n+    };\n+\n+  /// Private constructor to synchronously resolve host and service names.\n+  template<typename _InternetProtocol>\n+    basic_resolver_results<_InternetProtocol>::\n+    basic_resolver_results(string_view __host_name, string_view __service_name,\n+\t\t\t   resolver_base::flags __f, error_code& __ec,\n+\t\t\t   protocol_type* __protocol)\n+    {\n+      string __host;\n+      const char* __h = __host_name.data()\n+\t? (__host = __host_name.to_string()).c_str()\n+\t: nullptr;\n+      string __svc;\n+      const char* __s = __service_name.data()\n+\t? (__svc = __service_name.to_string()).c_str()\n+\t: nullptr;\n+\n+      ::addrinfo __hints{ };\n+      __hints.ai_flags = static_cast<int>(__f);\n+      if (__protocol)\n+\t{\n+\t  __hints.ai_family = __protocol->family();\n+\t  __hints.ai_socktype = __protocol->type();\n+\t  __hints.ai_protocol = __protocol->protocol();\n+\t}\n+      else\n+\t{\n+\t  auto __p = endpoint_type{}.protocol();\n+\t  __hints.ai_family = AF_UNSPEC;\n+\t  __hints.ai_socktype = __p.type();\n+\t  __hints.ai_protocol = __p.protocol();\n+\t}\n+\n+      struct __scoped_addrinfo\n+      {\n+\t~__scoped_addrinfo() { if (_M_p) ::freeaddrinfo(_M_p); }\n+\t::addrinfo* _M_p = nullptr;\n+      } __sai;\n+\n+      if (int __err = ::getaddrinfo(__h, __s, &__hints, &__sai._M_p))\n+\t{\n+\t  __ec.assign(__err, resolver_category());\n+\t  return;\n+\t}\n+      __ec.clear();\n+\n+      endpoint_type __ep;\n+      auto __tail = _M_results.before_begin();\n+      for (auto __ai = __sai._M_p; __ai != nullptr; __ai = __ai->ai_next)\n+\t{\n+\t  if (__ai->ai_family == AF_INET || __ai->ai_family == AF_INET6)\n+\t    {\n+\t      if (__ai->ai_addrlen <= __ep.capacity())\n+\t\tstd::memcpy(__ep.data(), __ai->ai_addr, __ai->ai_addrlen);\n+\t      __ep.resize(__ai->ai_addrlen);\n+\t      __tail = _M_results.emplace_after(__tail, __ep, __host, __svc);\n+\t      _M_size++;\n+\t    }\n+\t}\n+    }\n+\n+  /// Private constructor to synchronously resolve an endpoint.\n+  template<typename _InternetProtocol>\n+    basic_resolver_results<_InternetProtocol>::\n+    basic_resolver_results(const endpoint_type& __ep, error_code& __ec)\n+    {\n+      char __host_name[256];\n+      char __service_name[128];\n+      int __flags = 0;\n+      if (__ep.protocol().type() == SOCK_DGRAM)\n+\t__flags |= NI_DGRAM;\n+      auto __sa = static_cast<const sockaddr*>(__ep.data());\n+      int __err = ::getnameinfo(__sa, __ep.size(),\n+\t\t\t\t__host_name, sizeof(__host_name),\n+\t\t\t\t__service_name, sizeof(__service_name),\n+\t\t\t\t__flags);\n+      if (__err)\n+\t{\n+\t  __flags |= NI_NUMERICSERV;\n+\t  __err = ::getnameinfo(__sa, __ep.size(),\n+\t\t\t\t__host_name, sizeof(__host_name),\n+\t\t\t\t__service_name, sizeof(__service_name),\n+\t\t\t\t__flags);\n+\t}\n+      if (__err)\n+\t__ec.assign(__err, resolver_category());\n+      else\n+\t{\n+\t  __ec.clear();\n+\t  _M_results.emplace_front(__ep, __host_name, __service_name);\n+\t  _M_size = 1;\n+\t}\n+    }\n+\n+  /** The name of the local host.\n+   * @{\n+   */\n+\n+  template<typename _Allocator>\n+    __string_with<_Allocator>\n+    host_name(const _Allocator& __a, error_code& __ec)\n+    {\n+#ifdef HOST_NAME_MAX\n+      constexpr size_t __maxlen = HOST_NAME_MAX;\n+#else\n+      constexpr size_t __maxlen = 256;\n+#endif\n+      char __buf[__maxlen + 1];\n+      if (::gethostname(__buf, __maxlen) == -1)\n+\t__ec.assign(errno, generic_category());\n+      __buf[__maxlen] = '\\0';\n+      return { __buf, __a };\n+    }\n+\n+  template<typename _Allocator>\n+    inline __string_with<_Allocator>\n+    host_name(const _Allocator& __a)\n+    { return host_name(__a, __throw_on_error{\"host_name\"}); }\n+\n+  inline string\n+  host_name(error_code& __ec)\n+  { return host_name(std::allocator<char>{}, __ec); }\n+\n+  inline string\n+  host_name()\n+  { return host_name(std::allocator<char>{}, __throw_on_error{\"host_name\"}); }\n+\n+  // @}\n+\n+  /// The TCP byte-stream protocol.\n+  class tcp\n+  {\n+  public:\n+    // types:\n+    typedef basic_endpoint<tcp> endpoint;\t ///< A TCP endpoint.\n+    typedef basic_resolver<tcp> resolver;\t ///< A TCP resolver.\n+    typedef basic_stream_socket<tcp> socket;\t ///< A TCP socket.\n+    typedef basic_socket_acceptor<tcp> acceptor; ///< A TCP acceptor.\n+    typedef basic_socket_iostream<tcp> iostream; /// A TCP iostream.\n+\n+    /// Disable coalescing of small segments (i.e. the Nagle algorithm).\n+    struct no_delay : __sockopt_crtp<no_delay, bool>\n+    {\n+      using __sockopt_crtp::__sockopt_crtp;\n+\n+      static const int _S_level = IPPROTO_TCP;\n+      static const int _S_name = TCP_NODELAY;\n+    };\n+\n+    // static members:\n+\n+    /// A protocol object representing IPv4 TCP.\n+    static constexpr tcp v4() noexcept { return tcp(AF_INET); }\n+    /// A protocol object representing IPv6 TCP.\n+    static constexpr tcp v6() noexcept { return tcp(AF_INET6); }\n+\n+    tcp() = delete;\n+\n+    constexpr int family() const noexcept { return _M_family; }\n+    constexpr int type() const noexcept { return SOCK_STREAM; }\n+    constexpr int protocol() const noexcept { return IPPROTO_TCP; }\n+\n+  private:\n+    constexpr explicit tcp(int __family) : _M_family(__family) { }\n+\n+    int _M_family;\n+  };\n+\n+  /** tcp comparisons\n+   * @{\n+   */\n+\n+  inline bool\n+  operator==(const tcp& __a, const tcp& __b)\n+  { return __a.family() == __b.family(); }\n+\n+  inline bool\n+  operator!=(const tcp& __a, const tcp& __b)\n+  { return !(__a == __b); }\n+\n+  // @}\n+\n+  /// The UDP datagram protocol.\n+  class udp\n+  {\n+  public:\n+    // types:\n+    typedef basic_endpoint<udp> endpoint;\n+    typedef basic_resolver<udp> resolver;\n+    typedef basic_datagram_socket<udp> socket;\n+\n+    // static members:\n+    static constexpr udp v4() noexcept { return udp(AF_INET); }\n+    static constexpr udp v6() noexcept { return udp(AF_INET6); }\n+\n+    udp() = delete;\n+\n+    constexpr int family() const noexcept { return _M_family; }\n+    constexpr int type() const noexcept { return SOCK_DGRAM; }\n+    constexpr int protocol() const noexcept { return IPPROTO_UDP; }\n+\n+  private:\n+    constexpr explicit udp(int __family) : _M_family(__family) { }\n+\n+    int _M_family;\n+  };\n+\n+  /** udp comparisons\n+   * @{\n+   */\n+\n+  bool\n+  operator==(const udp& __a, const udp& __b)\n+  { return __a.family() == __b.family(); }\n+\n+  inline bool\n+  operator!=(const udp& __a, const udp& __b)\n+  { return !(__a == __b); }\n+\n+  // @}\n+\n+  /// Restrict a socket created for an IPv6 protocol to IPv6 only.\n+  struct v6_only : __sockopt_crtp<v6_only, bool>\n+  {\n+    using __sockopt_crtp::__sockopt_crtp;\n+\n+    static const int _S_level = IPPROTO_IPV6;\n+    static const int _S_name = IPV6_V6ONLY;\n+  };\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+\n+  namespace unicast {\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+    /// Set the default number of hops (TTL) for outbound datagrams.\n+    struct hops : __sockopt_crtp<hops>\n+    {\n+      using __sockopt_crtp::__sockopt_crtp;\n+\n+      template<typename _Protocol>\n+\tint\n+\tlevel(const _Protocol& __p) const noexcept\n+\t{ return __p.family() == AF_INET6 ? IPPROTO_IPV6 : IPPROTO_IP; }\n+\n+      template<typename _Protocol>\n+\tint\n+\tname(const _Protocol& __p) const noexcept\n+\t{ return __p.family() == AF_INET6 ? IPV6_UNICAST_HOPS : IP_TTL; }\n+    };\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+  } // namespace unicast\n+\n+  namespace multicast {\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+    /// Request that a socket joins a multicast group.\n+    struct join_group\n+    {\n+      explicit\n+      join_group(const address&);\n+\n+      explicit\n+      join_group(const address_v4&, const address_v4& = address_v4::any());\n+\n+      explicit\n+      join_group(const address_v6&, unsigned int = 0);\n+\n+      template<typename _Protocol>\n+\tint\n+\tlevel(const _Protocol& __p) const noexcept\n+\t{ return __p.family() == AF_INET6 ? IPPROTO_IPV6 : IPPROTO_IP; }\n+\n+      template<typename _Protocol>\n+\tint\n+\tname(const _Protocol& __p) const noexcept\n+\t{\n+\t  return __p.family() == AF_INET6\n+\t    ? IPV6_JOIN_GROUP : IP_ADD_MEMBERSHIP;\n+\t}\n+      template<typename _Protocol>\n+\tvoid*\n+\tdata(const _Protocol&) noexcept\n+\t{ return std::addressof(_M_value); }\n+\n+      template<typename _Protocol>\n+\tconst void*\n+\tdata(const _Protocol&) const noexcept\n+\t{ return std::addressof(_M_value); }\n+\n+      template<typename _Protocol>\n+\tsize_t\n+\tsize(const _Protocol& __p) const noexcept\n+\t{\n+\t  return __p.family() == AF_INET6\n+\t    ? sizeof(_M_value._M_v6) : sizeof(_M_value._M_v4);\n+\t}\n+\n+      template<typename _Protocol>\n+\tvoid\n+\tresize(const _Protocol& __p, size_t __s)\n+\t{\n+\t  if (__s != size(__p))\n+\t    __throw_length_error(\"invalid value for socket option resize\");\n+\t}\n+\n+    protected:\n+      union\n+      {\n+\tipv6_mreq _M_v6;\n+\tip_mreq _M_v4;\n+      } _M_value;\n+    };\n+\n+    /// Request that a socket leaves a multicast group.\n+    struct leave_group\n+    {\n+      explicit\n+      leave_group(const address&);\n+\n+      explicit\n+      leave_group(const address_v4&, const address_v4& = address_v4::any());\n+\n+      explicit\n+      leave_group(const address_v6&, unsigned int = 0);\n+\n+      template<typename _Protocol>\n+\tint\n+\tlevel(const _Protocol& __p) const noexcept\n+\t{ return __p.family() == AF_INET6 ? IPPROTO_IPV6 : IPPROTO_IP; }\n+\n+      template<typename _Protocol>\n+\tint\n+\tname(const _Protocol& __p) const noexcept\n+\t{\n+\t  return __p.family() == AF_INET6\n+\t    ? IPV6_LEAVE_GROUP : IP_DROP_MEMBERSHIP;\n+\t}\n+      template<typename _Protocol>\n+\tvoid*\n+\tdata(const _Protocol&) noexcept\n+\t{ return std::addressof(_M_value); }\n+\n+      template<typename _Protocol>\n+\tconst void*\n+\tdata(const _Protocol&) const noexcept\n+\t{ return std::addressof(_M_value); }\n+\n+      template<typename _Protocol>\n+\tsize_t\n+\tsize(const _Protocol& __p) const noexcept\n+\t{\n+\t  return __p.family() == AF_INET6\n+\t    ? sizeof(_M_value._M_v6) : sizeof(_M_value._M_v4);\n+\t}\n+\n+      template<typename _Protocol>\n+\tvoid\n+\tresize(const _Protocol& __p, size_t __s)\n+\t{\n+\t  if (__s != size(__p))\n+\t    __throw_length_error(\"invalid value for socket option resize\");\n+\t}\n+\n+    protected:\n+      union\n+      {\n+\tipv6_mreq _M_v6;\n+\tip_mreq _M_v4;\n+      } _M_value;\n+    };\n+\n+    /// Specify the network interface for outgoing multicast datagrams.\n+    class outbound_interface\n+    {\n+      explicit\n+      outbound_interface(const address_v4&);\n+\n+      explicit\n+      outbound_interface(unsigned int);\n+\n+      template<typename _Protocol>\n+\tint\n+\tlevel(const _Protocol& __p) const noexcept\n+\t{ return __p.family() == AF_INET6 ? IPPROTO_IPV6 : IPPROTO_IP; }\n+\n+      template<typename _Protocol>\n+\tint\n+\tname(const _Protocol& __p) const noexcept\n+\t{\n+\t  return __p.family() == AF_INET6\n+\t    ? IPV6_MULTICAST_IF : IP_MULTICAST_IF;\n+\t}\n+\n+      template<typename _Protocol>\n+\tconst void*\n+\tdata(const _Protocol&) const noexcept\n+\t{ return std::addressof(_M_value); }\n+\n+      template<typename _Protocol>\n+\tsize_t\n+\tsize(const _Protocol& __p) const noexcept\n+\t{\n+\t  return __p.family() == AF_INET6\n+\t    ? sizeof(_M_value._M_v6) : sizeof(_M_value._M_v4);\n+\t}\n+\n+    protected:\n+      union {\n+\tunsigned _M_v6;\n+\tin_addr _M_v4;\n+      } _M_value;\n+    };\n+\n+    /// Set the default number of hops (TTL) for outbound datagrams.\n+    struct hops : __sockopt_crtp<hops>\n+    {\n+      using __sockopt_crtp::__sockopt_crtp;\n+\n+      template<typename _Protocol>\n+\tint\n+\tlevel(const _Protocol& __p) const noexcept\n+\t{ return __p.family() == AF_INET6 ? IPPROTO_IPV6 : IPPROTO_IP; }\n+\n+      template<typename _Protocol>\n+\tint\n+\tname(const _Protocol& __p) const noexcept\n+\t{\n+\t  return __p.family() == AF_INET6\n+\t    ? IPV6_MULTICAST_HOPS : IP_MULTICAST_TTL;\n+\t}\n+    };\n+\n+    /// Set whether datagrams are delivered back to the local application.\n+    struct enable_loopback : __sockopt_crtp<enable_loopback>\n+    {\n+      using __sockopt_crtp::__sockopt_crtp;\n+\n+      template<typename _Protocol>\n+\tint\n+\tlevel(const _Protocol& __p) const noexcept\n+\t{ return __p.family() == AF_INET6 ? IPPROTO_IPV6 : IPPROTO_IP; }\n+\n+      template<typename _Protocol>\n+\tint\n+\tname(const _Protocol& __p) const noexcept\n+\t{\n+\t  return __p.family() == AF_INET6\n+\t    ? IPV6_MULTICAST_LOOP : IP_MULTICAST_LOOP;\n+\t}\n+    };\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+  } // namespace multicast\n+\n+  // @}\n+\n+} // namespace ip\n+} // namespace v1\n+} // namespace net\n+} // namespace experimental\n+\n+  template<>\n+    struct is_error_condition_enum<experimental::net::v1::ip::resolver_errc>\n+    : public true_type {};\n+\n+  // hash support\n+  template<typename _Tp> struct hash;\n+  template<>\n+    struct hash<experimental::net::v1::ip::address>\n+    : __hash_base<size_t, experimental::net::v1::ip::address>\n+    {\n+      size_t\n+      operator()(const argument_type& __a) const\n+      {\n+\tif (__a.is_v4())\n+\t  return _Hash_impl::hash(__a.to_v4());\n+\telse\n+\t  return _Hash_impl::hash(__a.to_v6());\n+      }\n+    };\n+\n+  template<>\n+    struct hash<experimental::net::v1::ip::address_v4>\n+    : __hash_base<size_t, experimental::net::v1::ip::address_v4>\n+    {\n+      size_t\n+      operator()(const argument_type& __a) const\n+      { return _Hash_impl::hash(__a.to_bytes()); }\n+    };\n+\n+  template<> struct hash<experimental::net::v1::ip::address_v6>\n+    : __hash_base<size_t, experimental::net::v1::ip::address_v6>\n+    {\n+      size_t\n+      operator()(const argument_type& __a) const\n+      { return _Hash_impl::hash(__a.to_bytes()); }\n+    };\n+\n+} // namespace std\n+\n+#endif // C++14\n+\n+#endif // _GLIBCXX_EXPERIMENTAL_INTERNET"}, {"sha": "7b42442a0348122d92fad5f1baea4f50c7f273f7", "filename": "libstdc++-v3/include/experimental/io_context", "status": "added", "additions": 864, "deletions": 0, "changes": 864, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fio_context", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fio_context", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fio_context?ref=e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "patch": "@@ -0,0 +1,864 @@\n+// <experimental/io_service> -*- C++ -*-\n+\n+// Copyright (C) 2015-2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file experimental/io_service\n+ *  This is a TS C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_EXPERIMENTAL_IO_SERVICE\n+#define _GLIBCXX_EXPERIMENTAL_IO_SERVICE 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus >= 201402L\n+\n+#include <atomic>\n+#include <chrono>\n+#include <forward_list>\n+#include <functional>\n+#include <system_error>\n+#include <thread>\n+#include <experimental/netfwd>\n+#include <experimental/executor>\n+#include <unistd.h>\n+#include <poll.h>\n+#include <fcntl.h>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+namespace experimental\n+{\n+namespace net\n+{\n+inline namespace v1\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /**\n+   * @ingroup networking\n+   * @{\n+   */\n+\n+  class __socket_impl;\n+\n+  /// An ExecutionContext for I/O operations.\n+  class io_context : public execution_context\n+  {\n+  public:\n+    // types:\n+\n+    /// An executor for an io_context.\n+    class executor_type\n+    {\n+    public:\n+      // construct / copy / destroy:\n+\n+      executor_type(const executor_type& __other) noexcept = default;\n+      executor_type(executor_type&& __other) noexcept = default;\n+\n+      executor_type& operator=(const executor_type& __other) noexcept = default;\n+      executor_type& operator=(executor_type&& __other) noexcept = default;\n+\n+      // executor operations:\n+\n+      bool running_in_this_thread() const noexcept\n+      {\n+\tlock_guard<mutex> __lock(_M_ctx->_M_mtx);\n+\tauto __end = _M_ctx->_M_call_stack.end();\n+\treturn std::find(_M_ctx->_M_call_stack.begin(), __end,\n+\t\t\t this_thread::get_id()) != __end;\n+      }\n+\n+      io_context& context() const noexcept { return *_M_ctx; }\n+\n+      void on_work_started() const noexcept { ++_M_ctx->_M_work_count; }\n+      void on_work_finished() const noexcept { --_M_ctx->_M_work_count; }\n+\n+      template<typename _Func, typename _ProtoAllocator>\n+\tvoid\n+\tdispatch(_Func&& __f, const _ProtoAllocator& __a) const\n+\t{\n+\t  if (running_in_this_thread())\n+\t    decay_t<_Func>{std::forward<_Func>(__f)}();\n+\t  else\n+\t    post(std::forward<_Func>(__f), __a);\n+\t}\n+\n+      template<typename _Func, typename _ProtoAllocator>\n+\tvoid\n+\tpost(_Func&& __f, const _ProtoAllocator& __a) const\n+\t{\n+\t  lock_guard<mutex> __lock(_M_ctx->_M_mtx);\n+\t  // TODO (re-use functionality in system_context)\n+\t  _M_ctx->_M_reactor._M_notify();\n+\t}\n+\n+      template<typename _Func, typename _ProtoAllocator>\n+\tvoid\n+\tdefer(_Func&& __f, const _ProtoAllocator& __a) const\n+\t{ post(std::forward<_Func>(__f), __a); }\n+\n+    private:\n+      friend io_context;\n+\n+      explicit\n+      executor_type(io_context& __ctx) : _M_ctx(std::addressof(__ctx)) { }\n+\n+      io_context* _M_ctx;\n+    };\n+\n+    using count_type =  size_t;\n+\n+    // construct / copy / destroy:\n+\n+    io_context() : _M_work_count(0) { }\n+\n+    explicit\n+    io_context(int __concurrency_hint) : _M_work_count(0) { }\n+\n+    io_context(const io_context&) = delete;\n+    io_context& operator=(const io_context&) = delete;\n+\n+    // io_context operations:\n+\n+    executor_type get_executor() noexcept { return executor_type(*this); }\n+\n+    count_type\n+    run()\n+    {\n+      count_type __n = 0;\n+      while (run_one())\n+\tif (__n != numeric_limits<count_type>::max())\n+\t  ++__n;\n+      return __n;\n+    }\n+\n+    template<typename _Rep, typename _Period>\n+      count_type\n+      run_for(const chrono::duration<_Rep, _Period>& __rel_time)\n+      { return run_until(chrono::steady_clock::now() + __rel_time); }\n+\n+    template<typename _Clock, typename _Duration>\n+      count_type\n+      run_until(const chrono::time_point<_Clock, _Duration>& __abs_time)\n+      {\n+\tcount_type __n = 0;\n+\twhile (run_one_until(__abs_time))\n+\t  if (__n != numeric_limits<count_type>::max())\n+\t    ++__n;\n+\treturn __n;\n+      }\n+\n+    count_type\n+    run_one()\n+    { return _M_do_one(chrono::milliseconds{-1}); }\n+\n+    template<typename _Rep, typename _Period>\n+      count_type\n+      run_one_for(const chrono::duration<_Rep, _Period>& __rel_time)\n+      { return run_one_until(chrono::steady_clock::now() + __rel_time); }\n+\n+    template<typename _Clock, typename _Duration>\n+      count_type\n+      run_one_until(const chrono::time_point<_Clock, _Duration>& __abs_time)\n+      {\n+\tauto __now = _Clock::now();\n+\twhile (__now < __abs_time)\n+\t  {\n+\t    using namespace std::chrono;\n+\t    auto __ms = duration_cast<milliseconds>(__abs_time - __now);\n+\t    if (_M_do_one(__ms))\n+\t      return 1;\n+\t    __now = _Clock::now();\n+\t  }\n+\treturn 0;\n+      }\n+\n+    count_type\n+    poll()\n+    {\n+      count_type __n = 0;\n+      while (poll_one())\n+\tif (__n != numeric_limits<count_type>::max())\n+\t  ++__n;\n+      return __n;\n+    }\n+\n+    count_type\n+    poll_one()\n+    { return _M_do_one(chrono::milliseconds{0}); }\n+\n+    void stop()\n+    {\n+      lock_guard<mutex> __lock(_M_mtx);\n+      _M_stopped = true;\n+      _M_reactor._M_notify();\n+    }\n+\n+    bool stopped() const noexcept\n+    {\n+      lock_guard<mutex> __lock(_M_mtx);\n+      return _M_stopped;\n+    }\n+\n+    void restart()\n+    {\n+      _M_stopped = false;\n+    }\n+\n+  private:\n+\n+    template<typename _Clock, typename _WaitTraits>\n+      friend class basic_waitable_timer;\n+\n+    friend __socket_impl;\n+\n+    template<typename _Protocol>\n+      friend class __basic_socket_impl;\n+\n+    template<typename _Protocol>\n+      friend class basic_socket;\n+\n+    template<typename _Protocol>\n+      friend class basic_datagram_socket;\n+\n+    template<typename _Protocol>\n+      friend class basic_stream_socket;\n+\n+    template<typename _Protocol>\n+      friend class basic_socket_acceptor;\n+\n+    count_type\n+    _M_outstanding_work() const\n+    { return _M_work_count + !_M_ops.empty(); }\n+\n+    struct __timer_queue_base : execution_context::service\n+    {\n+      // return milliseconds until next timer expires, or milliseconds::max()\n+      virtual chrono::milliseconds _M_next() const = 0;\n+      virtual bool run_one() = 0;\n+\n+    protected:\n+      explicit\n+      __timer_queue_base(execution_context& __ctx) : service(__ctx)\n+      {\n+\tauto& __ioc = static_cast<io_context&>(__ctx);\n+\tlock_guard<mutex> __lock(__ioc._M_mtx);\n+\t__ioc._M_timers.push_back(this);\n+      }\n+\n+      mutable mutex\t_M_qmtx;\n+    };\n+\n+    template<typename _Timer, typename _Key = typename _Timer::_Key>\n+      struct __timer_queue : __timer_queue_base\n+      {\n+\tusing key_type = __timer_queue;\n+\n+\texplicit\n+\t__timer_queue(execution_context& __ctx) : __timer_queue_base(__ctx)\n+\t{ }\n+\n+\tvoid shutdown() noexcept { }\n+\n+\tio_context& context() noexcept\n+\t{ return static_cast<io_context&>(service::context()); }\n+\n+\t// Start an asynchronous wait.\n+\tvoid\n+\tpush(const _Timer& __t, function<void(error_code)> __h)\n+\t{\n+\t  context().get_executor().on_work_started();\n+\t  lock_guard<mutex> __lock(_M_qmtx);\n+\t  _M_queue.emplace(__t, _M_next_id++, std::move(__h));\n+\t  // no need to notify reactor unless this timer went to the front?\n+\t}\n+\n+\t// Cancel all outstanding waits for __t\n+\tsize_t\n+\tcancel(const _Timer& __t)\n+\t{\n+\t  lock_guard<mutex> __lock(_M_qmtx);\n+\t  size_t __count = 0;\n+\t  auto __last = _M_queue.end();\n+\t  for (auto __it = _M_queue.begin(), __end = __last; __it != __end;\n+\t      ++__it)\n+\t    {\n+\t      if (__it->_M_key == __t._M_key.get())\n+\t\t{\n+\t\t  __it->cancel();\n+\t\t  __last = __it;\n+\t\t  ++__count;\n+\t\t}\n+\t    }\n+\t  if (__count)\n+\t    _M_queue._M_sort_to(__last);\n+\t  return __count;\n+\t}\n+\n+\t// Cancel oldest outstanding wait for __t\n+\tbool\n+\tcancel_one(const _Timer& __t)\n+\t{\n+\t  lock_guard<mutex> __lock(_M_qmtx);\n+\t  const auto __end = _M_queue.end();\n+\t  auto __oldest = __end;\n+\t  for (auto __it = _M_queue.begin(); __it != __end; ++__it)\n+\t    if (__it->_M_key == __t._M_key.get())\n+\t      if (__oldest == __end || __it->_M_id < __oldest->_M_id)\n+\t\t__oldest = __it;\n+\t  if (__oldest == __end)\n+\t    return false;\n+\t  __oldest->cancel();\n+\t  _M_queue._M_sort_to(__oldest);\n+\t  return true;\n+\t}\n+\n+\tchrono::milliseconds\n+\t_M_next() const override\n+\t{\n+\t  typename _Timer::time_point __exp;\n+\t  {\n+\t    lock_guard<mutex> __lock(_M_qmtx);\n+\t    if (_M_queue.empty())\n+\t      return chrono::milliseconds::max();  // no pending timers\n+\t    if (_M_queue.top()._M_key == nullptr)\n+\t      return chrono::milliseconds::zero(); // cancelled, run now\n+\t    __exp = _M_queue.top()._M_expiry;\n+\t  }\n+\t  auto __dur = _Timer::traits_type::to_wait_duration(__exp);\n+\t  if (__dur < __dur.zero())\n+\t    __dur = __dur.zero();\n+\t  return chrono::duration_cast<chrono::milliseconds>(__dur);\n+\t}\n+\n+      private:\n+\n+\tbool run_one() override\n+\t{\n+\t  auto __now = _Timer::clock_type::now();\n+\t  function<void(error_code)> __h;\n+\t  error_code __ec;\n+\t  {\n+\t    lock_guard<mutex> __lock(_M_qmtx);\n+\n+\t    if (_M_queue.top()._M_key == nullptr) // cancelled\n+\t      {\n+\t\t__h = std::move(_M_queue.top()._M_h);\n+\t\t__ec = std::make_error_code(errc::operation_canceled);\n+\t\t_M_queue.pop();\n+\t      }\n+\t    else if (_M_queue.top()._M_expiry <= _Timer::clock_type::now())\n+\t      {\n+\t\t__h = std::move(_M_queue.top()._M_h);\n+\t\t_M_queue.pop();\n+\t      }\n+\t  }\n+\t  if (__h)\n+\t    {\n+\t      __h(__ec);\n+\t      context().get_executor().on_work_finished();\n+\t      return true;\n+\t    }\n+\t  return false;\n+\t}\n+\n+\tusing __timer_id_type = uint64_t;\n+\n+\tstruct __pending_timer\n+\t{\n+\t  __pending_timer(const _Timer& __t, uint64_t __id,\n+\t\t\t  function<void(error_code)> __h)\n+\t  : _M_expiry(__t.expiry()), _M_key(__t._M_key.get()), _M_id(__id),\n+\t    _M_h(std::move(__h))\n+\t  { }\n+\n+\t  typename _Timer::time_point _M_expiry;\n+\t  _Key* _M_key;\n+\t  __timer_id_type _M_id;\n+\t  function<void(error_code)> _M_h;\n+\n+\t  void cancel() { _M_expiry = _M_expiry.min(); _M_key = nullptr; }\n+\n+\t  bool\n+\t  operator<(const __pending_timer& __rhs) const\n+\t  { return _M_expiry < __rhs._M_expiry; }\n+\t};\n+\n+\tstruct __queue : priority_queue<__pending_timer>\n+\t{\n+\t  using iterator =\n+\t    typename priority_queue<__pending_timer>::container_type::iterator;\n+\n+\t  // expose begin/end/erase for direct access to underlying container\n+\t  iterator begin() { return this->c.begin(); }\n+\t  iterator end() { return this->c.end(); }\n+\t  iterator erase(iterator __it) { return this->c.erase(__it); }\n+\n+\t  void\n+\t  _M_sort_to(iterator __it)\n+\t  { std::stable_sort(this->c.begin(), ++__it); }\n+\t};\n+\n+\t__queue\t_M_queue;\n+\t__timer_id_type _M_next_id = 0;\n+      };\n+\n+    template<typename _Timer, typename _CompletionHandler>\n+      void\n+      async_wait(const _Timer& __timer, _CompletionHandler&& __h)\n+      {\n+\tauto& __queue = use_service<__timer_queue<_Timer>>(*this);\n+\t__queue.push(__timer, std::move(__h));\n+\t_M_reactor._M_notify();\n+      }\n+\n+    // Cancel all wait operations initiated by __timer.\n+    template<typename _Timer>\n+      size_t\n+      cancel(const _Timer& __timer)\n+      {\n+\tif (!has_service<__timer_queue<_Timer>>(*this))\n+\t  return 0;\n+\n+\tauto __c = use_service<__timer_queue<_Timer>>(*this).cancel(__timer);\n+\tif (__c != 0)\n+\t  _M_reactor._M_notify();\n+\treturn __c;\n+      }\n+\n+    // Cancel the oldest wait operation initiated by __timer.\n+    template<typename _Timer>\n+      size_t\n+      cancel_one(const _Timer& __timer)\n+      {\n+\tif (!has_service<__timer_queue<_Timer>>(*this))\n+\t  return 0;\n+\n+\tif (use_service<__timer_queue<_Timer>>(*this).cancel_one(__timer))\n+\t  {\n+\t    _M_reactor._M_notify();\n+\t    return 1;\n+\t  }\n+\treturn 0;\n+      }\n+\n+    template<typename _Op>\n+      void\n+      async_wait(int __fd, int __w, _Op&& __op)\n+      {\n+\tlock_guard<mutex> __lock(_M_mtx);\n+\t// TODO need push_back, use std::list not std::forward_list\n+\tauto __tail = _M_ops.before_begin(), __it = _M_ops.begin();\n+\twhile (__it != _M_ops.end())\n+\t  {\n+\t    ++__it;\n+\t    ++__tail;\n+\t  }\n+\tusing __type = __async_operation_impl<_Op>;\n+\t_M_ops.emplace_after(__tail,\n+\t\t\t     make_unique<__type>(std::move(__op), __fd, __w));\n+\t_M_reactor._M_fd_interest(__fd, __w);\n+      }\n+\n+    void _M_add_fd(int __fd) { _M_reactor._M_add_fd(__fd); }\n+    void _M_remove_fd(int __fd) { _M_reactor._M_remove_fd(__fd); }\n+\n+    void cancel(int __fd, error_code&)\n+    {\n+      lock_guard<mutex> __lock(_M_mtx);\n+      const auto __end = _M_ops.end();\n+      auto __it = _M_ops.begin();\n+      auto __prev = _M_ops.before_begin();\n+      while (__it != __end && (*__it)->_M_is_cancelled())\n+\t{\n+\t  ++__it;\n+\t  ++__prev;\n+\t}\n+      auto __cancelled = __prev;\n+      while (__it != __end)\n+\t{\n+\t  if ((*__it)->_M_fd == __fd)\n+\t    {\n+\t      (*__it)->cancel();\n+\t      ++__it;\n+\t      _M_ops.splice_after(__cancelled, _M_ops, __prev);\n+\t      ++__cancelled;\n+\t    }\n+\t  else\n+\t    {\n+\t      ++__it;\n+\t      ++__prev;\n+\t    }\n+\t}\n+      _M_reactor._M_not_interested(__fd);\n+    }\n+\n+    struct __async_operation\n+    {\n+      __async_operation(int __fd, int __ev) : _M_fd(__fd), _M_ev(__ev) { }\n+\n+      virtual ~__async_operation() = default;\n+\n+      int _M_fd;\n+      short _M_ev;\n+\n+      void cancel() { _M_fd = -1; }\n+      bool _M_is_cancelled() const { return _M_fd == -1; }\n+      virtual void run(io_context&) = 0;\n+    };\n+\n+    template<typename _Op>\n+      struct __async_operation_impl : __async_operation\n+      {\n+\t__async_operation_impl(_Op&& __op, int __fd, int __ev)\n+\t: __async_operation{__fd, __ev}, _M_op(std::move(__op)) { }\n+\n+\t_Op _M_op;\n+\n+\tvoid run(io_context& __ctx)\n+\t{\n+\t  if (_M_is_cancelled())\n+\t    _M_op(std::make_error_code(errc::operation_canceled));\n+\t  else\n+\t    _M_op(error_code{});\n+\t}\n+      };\n+\n+    atomic<count_type>\t\t_M_work_count;\n+    mutable mutex\t\t_M_mtx;\n+    queue<function<void()>>\t_M_op;\n+    bool\t\t\t_M_stopped = false;\n+\n+    struct __monitor\n+    {\n+      __monitor(io_context& __c) : _M_ctx(__c)\n+      {\n+\tlock_guard<mutex> __lock(_M_ctx._M_mtx);\n+\t_M_ctx._M_call_stack.push_back(this_thread::get_id());\n+      }\n+\n+      ~__monitor()\n+      {\n+\tlock_guard<mutex> __lock(_M_ctx._M_mtx);\n+\t_M_ctx._M_call_stack.pop_back();\n+\tif (_M_ctx._M_outstanding_work() == 0)\n+\t  {\n+\t    _M_ctx._M_stopped = true;\n+\t    _M_ctx._M_reactor._M_notify();\n+\t  }\n+      }\n+\n+      __monitor(__monitor&&) = delete;\n+\n+      io_context& _M_ctx;\n+    };\n+\n+    bool\n+    _M_do_one(chrono::milliseconds __timeout)\n+    {\n+      const bool __block = __timeout != chrono::milliseconds::zero();\n+\n+      __reactor::__fdvec __fds;\n+\n+      __monitor __mon{*this};\n+\n+      __timer_queue_base* __timerq = nullptr;\n+      unique_ptr<__async_operation> __async_op;\n+\n+      while (true)\n+\t{\n+\t  if (__timerq)\n+\t    {\n+\t      if (__timerq->run_one())\n+\t\treturn true;\n+\t      else\n+\t\t__timerq = nullptr;\n+\t    }\n+\n+\t  if (__async_op)\n+\t    {\n+\t      __async_op->run(*this);\n+\t      // TODO need to unregister __async_op\n+\t      return true;\n+\t    }\n+\n+\t  chrono::milliseconds __ms{0};\n+\n+\t  {\n+\t    lock_guard<mutex> __lock(_M_mtx);\n+\n+\t    if (_M_stopped)\n+\t      return false;\n+\n+\t    // find first timer with something to do\n+\t    for (auto __q : _M_timers)\n+\t      {\n+\t\tauto __next = __q->_M_next();\n+\t\tif (__next == __next.zero())  // ready to run immediately\n+\t\t  {\n+\t\t    __timerq = __q;\n+\t\t    __ms = __next;\n+\t\t    break;\n+\t\t  }\n+\t\telse if (__next != __next.max() && __block\n+\t\t    && (__next < __ms || __timerq == nullptr))\n+\t\t  {\n+\t\t    __timerq = __q;\n+\t\t    __ms = __next;\n+\t\t  }\n+\t      }\n+\n+\t    if (__timerq && __ms == __ms.zero())\n+\t      continue;  // restart loop to run a timer immediately\n+\n+\t    if (!_M_ops.empty() && _M_ops.front()->_M_is_cancelled())\n+\t      {\n+\t\t_M_ops.front().swap(__async_op);\n+\t\t_M_ops.pop_front();\n+\t\tcontinue;\n+\t      }\n+\n+\t    // TODO run any posted items\n+\n+\t    if (__block)\n+\t      {\n+\t\tif (__timerq == nullptr)\n+\t\t  __ms = __timeout;\n+\t\telse if (__ms.zero() <= __timeout && __timeout < __ms)\n+\t\t  __ms = __timeout;\n+\t\telse if (__ms.count() > numeric_limits<int>::max())\n+\t\t  __ms = chrono::milliseconds{numeric_limits<int>::max()};\n+\t      }\n+\t    // else __ms == 0 and poll() will return immediately\n+\n+\t  }\n+\n+\t  auto __res = _M_reactor.wait(__fds, __ms);\n+\n+\t  if (__res == __reactor::_S_retry)\n+\t    continue;\n+\n+\t  if (__res == __reactor::_S_timeout)\n+\t    if (__timerq == nullptr)\n+\t      return false;\n+\t    else\n+\t      continue;  // timed out, so restart loop and process the timer\n+\n+\t  __timerq = nullptr;\n+\n+\t  if (__fds.empty()) // nothing to do\n+\t    return false;\n+\n+\t  lock_guard<mutex> __lock(_M_mtx);\n+\t  for (auto __it = _M_ops.begin(), __end = _M_ops.end(),\n+\t      __prev = _M_ops.before_begin(); __it != __end; ++__it, ++__prev)\n+\t    {\n+\t      auto& __op = **__it;\n+\t      auto __pos = std::lower_bound(__fds.begin(), __fds.end(),\n+\t\t  __op._M_fd,\n+\t\t  [](const auto& __p, int __fd) { return __p.fd < __fd; });\n+\t      if (__pos != __fds.end() && __pos->fd == __op._M_fd\n+\t\t  && __pos->revents & __op._M_ev)\n+\t\t{\n+\t\t  __it->swap(__async_op);\n+\t\t  _M_ops.erase_after(__prev);\n+\t\t  break;  // restart loop and run op\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+    struct __reactor\n+    {\n+      __reactor() : _M_fds(1)\n+      {\n+\tint __pipe[2];\n+\tif (::pipe(__pipe) == -1)\n+\t  __throw_system_error(errno);\n+\tif (::fcntl(__pipe[0], F_SETFL, O_NONBLOCK) == -1\n+\t    || ::fcntl(__pipe[1], F_SETFL, O_NONBLOCK) == -1)\n+\t  {\n+\t    int __e = errno;\n+\t    ::close(__pipe[0]);\n+\t    ::close(__pipe[1]);\n+\t    __throw_system_error(__e);\n+\t  }\n+\t_M_fds.back().events\t= POLLIN;\n+\t_M_fds.back().fd\t= __pipe[0];\n+\t_M_notify_wr\t\t= __pipe[1];\n+      }\n+\n+      ~__reactor()\n+      {\n+\t::close(_M_fds.back().fd);\n+\t::close(_M_notify_wr);\n+      }\n+\n+      // write a notification byte to the pipe (ignoring errors)\n+      void _M_notify()\n+      {\n+\tint __n;\n+\tdo {\n+\t  __n = ::write(_M_notify_wr, \"\", 1);\n+\t} while (__n == -1 && errno == EINTR);\n+      }\n+\n+      // read all notification bytes from the pipe\n+      void _M_on_notify()\n+      {\n+\t// Drain the pipe.\n+\tchar __buf[64];\n+\tssize_t __n;\n+\tdo {\n+\t  __n = ::read(_M_fds.back().fd, __buf, sizeof(__buf));\n+\t} while (__n != -1 || errno == EINTR);\n+      }\n+\n+      void\n+      _M_add_fd(int __fd)\n+      {\n+\tauto __pos = _M_lower_bound(__fd);\n+\tif (__pos->fd == __fd)\n+\t  __throw_system_error((int)errc::invalid_argument);\n+\t_M_fds.insert(__pos, __fdvec::value_type{})->fd = __fd;\n+\t_M_notify();\n+      }\n+\n+      void\n+      _M_remove_fd(int __fd)\n+      {\n+\tauto __pos = _M_lower_bound(__fd);\n+\tif (__pos->fd == __fd)\n+\t  _M_fds.erase(__pos);\n+\t// else bug!\n+\t_M_notify();\n+      }\n+\n+      void\n+      _M_fd_interest(int __fd, int __w)\n+      {\n+\tauto __pos = _M_lower_bound(__fd);\n+\tif (__pos->fd == __fd)\n+\t  __pos->events |= __w;\n+\t// else bug!\n+\t_M_notify();\n+      }\n+\n+      void\n+      _M_not_interested(int __fd)\n+      {\n+\tauto __pos = _M_lower_bound(__fd);\n+\tif (__pos->fd == __fd)\n+\t  __pos->events = 0;\n+\t_M_notify();\n+      }\n+\n+      using __fdvec = vector<::pollfd>;\n+\n+      // Find first element p such that !(p.fd < __fd)\n+      // N.B. always returns a dereferencable iterator.\n+      __fdvec::iterator\n+      _M_lower_bound(int __fd)\n+      {\n+\treturn std::lower_bound(_M_fds.begin(), _M_fds.end() - 1,\n+\t    __fd, [](const auto& __p, int __fd) { return __p.fd < __fd; });\n+      }\n+\n+      enum __status { _S_retry, _S_timeout, _S_ok, _S_error };\n+\n+      __status\n+      wait(__fdvec& __fds, chrono::milliseconds __timeout)\n+      {\n+\t// XXX not thread-safe!\n+\t__fds = _M_fds;  // take snapshot to pass to poll()\n+\n+\tint __res = ::poll(__fds.data(), __fds.size(), __timeout.count());\n+\n+\tif (__res == -1)\n+\t  {\n+\t    __fds.clear();\n+\t    if (errno == EINTR)\n+\t      return _S_retry;\n+\t    return _S_error; // XXX ???\n+\t  }\n+\telse if (__res == 0)\n+\t  {\n+\t    __fds.clear();\n+\t    return _S_timeout;\n+\t  }\n+\telse if (__fds.back().revents != 0) // something changed, restart\n+\t  {\n+\t    __fds.clear();\n+\t    _M_on_notify();\n+\t    return _S_retry;\n+\t  }\n+\n+\tauto __part = std::stable_partition(__fds.begin(), __fds.end() - 1,\n+\t      [](const __fdvec::value_type& __p) { return __p.revents != 0; });\n+\t__fds.erase(__part, __fds.end());\n+\n+\treturn _S_ok;\n+      }\n+\n+      __fdvec _M_fds;\t// _M_fds.back() is the read end of the self-pipe\n+      int _M_notify_wr;\t// write end of the self-pipe\n+    };\n+\n+    __reactor _M_reactor;\n+\n+    vector<__timer_queue_base*>\t\t\t_M_timers;\n+    forward_list<unique_ptr<__async_operation>>\t_M_ops;\n+\n+    vector<thread::id>\t_M_call_stack;\n+  };\n+\n+  inline bool\n+  operator==(const io_context::executor_type& __a,\n+\t     const io_context::executor_type& __b) noexcept\n+  {\n+    // https://github.com/chriskohlhoff/asio-tr2/issues/201\n+    using executor_type = io_context::executor_type;\n+    return std::addressof(executor_type(__a).context())\n+      == std::addressof(executor_type(__b).context());\n+  }\n+\n+  inline bool\n+  operator!=(const io_context::executor_type& __a,\n+\t     const io_context::executor_type& __b) noexcept\n+  { return !(__a == __b); }\n+\n+  template<> struct is_executor<io_context::executor_type> : true_type {};\n+\n+  /// @}\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace v1\n+} // namespace net\n+} // namespace experimental\n+} // namespace std\n+\n+#endif // C++14\n+\n+#endif // _GLIBCXX_EXPERIMENTAL_IO_SERVICE"}, {"sha": "3d97546c365bf5f2e0f348ced3013121003a2c4e", "filename": "libstdc++-v3/include/experimental/net", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fnet", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fnet", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fnet?ref=e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "patch": "@@ -0,0 +1,45 @@\n+// <experimental/net> -*- C++ -*-\n+\n+// Copyright (C) 2015-2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file experimental/net\n+ *  This is a TS C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_EXPERIMENTAL_NET\n+#define _GLIBCXX_EXPERIMENTAL_NET\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus >= 201402L\n+\n+#include <experimental/executor>\n+#include <experimental/io_context>\n+#include <experimental/timer>\n+#include <experimental/buffer>\n+#include <experimental/socket>\n+#include <experimental/internet>\n+\n+#endif // C++14\n+\n+#endif // _GLIBCXX_EXPERIMENTAL_NET"}, {"sha": "a0311a9aa697ccda63d1ad8a0173defa1b61f4ee", "filename": "libstdc++-v3/include/experimental/netfwd", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fnetfwd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fnetfwd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fnetfwd?ref=e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "patch": "@@ -0,0 +1,135 @@\n+// <experimental/netfwd> -*- C++ -*-\n+\n+// Copyright (C) 2015-2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file experimental/netfwd\n+ *  This is a TS C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_EXPERIMENTAL_NETFWD\n+#define _GLIBCXX_EXPERIMENTAL_NETFWD 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus >= 201402L\n+\n+// #define __cpp_lib_experimental_net 201803\n+// #define __cpp_lib_experimental_net_extensible 201803\n+\n+#include <chrono>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+namespace experimental\n+{\n+namespace net\n+{\n+inline namespace v1\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /**\n+   * @ingroup networking\n+   * @{\n+   */\n+\n+  class execution_context;\n+  template<typename _Tp, typename _Executor>\n+    class executor_binder;\n+  template<typename _Executor>\n+    class executor_work_guard;\n+  class system_executor;\n+  class executor;\n+  template<typename _Executor>\n+    class strand;\n+\n+  class io_service;\n+\n+  template<typename _Clock> struct wait_traits;\n+  template<typename _Clock, typename _WaitTraits = wait_traits<_Clock>>\n+    class basic_waitable_timer;\n+  typedef basic_waitable_timer<chrono::system_clock> system_timer;\n+  typedef basic_waitable_timer<chrono::steady_clock> steady_timer;\n+  typedef basic_waitable_timer<chrono::high_resolution_clock>\n+    high_resolution_timer;\n+\n+  template<typename _Protocol>\n+    class basic_socket;\n+  template<typename _Protocol>\n+    class basic_datagram_socket;\n+  template<typename _Protocol>\n+    class basic_stream_socket;\n+  template<typename _Protocol>\n+    class basic_socket_acceptor;\n+  template<typename _Protocol, typename _Clock = chrono::steady_clock,\n+\t   typename _WaitTraits = wait_traits<_Clock>>\n+    class basic_socket_streambuf;\n+  template<typename _Protocol, typename _Clock = chrono::steady_clock,\n+\t   typename _WaitTraits = wait_traits<_Clock>>\n+    class basic_socket_iostream;\n+\n+  /// @}\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+\n+namespace ip\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /**\n+   * @ingroup networking\n+   * @{\n+   */\n+    class address;\n+    class address_v4;\n+    class address_v6;\n+    class address_iterator_v4;\n+    class address_iterator_v6;\n+    class address_range_v4;\n+    class address_range_v6;\n+    class network_v4;\n+    class network_v6;\n+    template<typename _InternetProtocol>\n+      class basic_endpoint;\n+    template<typename _InternetProtocol>\n+      class basic_resolver_entry;\n+    template<typename _InternetProtocol>\n+      class basic_resolver_results;\n+    template<typename _InternetProtocol>\n+      class basic_resolver;\n+    class tcp;\n+    class udp;\n+  /// @}\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace ip\n+\n+\n+} // namespace v1\n+} // namespace net\n+} // namespace experimental\n+} // namespace std\n+\n+#endif // C++14\n+\n+#endif // _GLIBCXX_EXPERIMENTAL_NETFWD"}, {"sha": "7adb42e7e2071d6a8938177261d23712eab88093", "filename": "libstdc++-v3/include/experimental/socket", "status": "added", "additions": 2474, "deletions": 0, "changes": 2474, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fsocket", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fsocket", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fsocket?ref=e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "patch": "@@ -0,0 +1,2474 @@\n+// <experimental/socket> -*- C++ -*-\n+\n+// Copyright (C) 2015-2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file experimental/socket\n+ *  This is a TS C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_EXPERIMENTAL_SOCKET\n+#define _GLIBCXX_EXPERIMENTAL_SOCKET\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus >= 201402L\n+\n+#include <experimental/netfwd>\n+#include <experimental/buffer>\n+#include <experimental/io_context>\n+#include <experimental/bits/net.h>\n+#include <streambuf>\n+#include <istream>\n+#include <bits/unique_ptr.h>\n+#if _GLIBCXX_HAVE_UNISTD_H\n+# include <unistd.h>\n+# include <sys/socket.h>\n+# include <sys/ioctl.h>\n+# include <sys/fcntl.h>\n+# include <sys/uio.h>\n+# include <poll.h>\n+#endif\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+namespace experimental\n+{\n+namespace net\n+{\n+inline namespace v1\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /**\n+   * @ingroup networking\n+   * @{\n+   */\n+\n+  enum class socket_errc {  // TODO decide values\n+    already_open = 3,\n+    not_found = 4\n+  };\n+\n+  const error_category& socket_category() noexcept\n+  {\n+    struct __cat : error_category\n+    {\n+      const char* name() const noexcept { return \"socket\"; }\n+\n+      std::string message(int __e) const\n+      {\n+\tif (__e == (int)socket_errc::already_open)\n+\t  return \"already open\";\n+\telse if (__e == (int)socket_errc::not_found)\n+\t  return \"endpoint not found\";\n+\treturn \"socket error\";\n+      }\n+\n+      virtual void __message(int) { } // TODO dual ABI XXX\n+    };\n+    static __cat __c;\n+    return __c;\n+  }\n+\n+  inline error_code\n+  make_error_code(socket_errc __e) noexcept\n+  { return error_code(static_cast<int>(__e), socket_category()); }\n+\n+  inline error_condition\n+  make_error_condition(socket_errc __e) noexcept\n+  { return error_condition(static_cast<int>(__e), socket_category()); }\n+\n+  template<typename _Tp, typename = __void_t<>>\n+    struct __is_endpoint_impl : false_type\n+    { };\n+\n+  // Check Endpoint requirements.\n+  template<typename _Tp>\n+    auto\n+    __endpoint_reqs(const _Tp* __a = 0)\n+    -> enable_if_t<__and_<\n+      is_default_constructible<_Tp>,\n+      __is_value_constructible<_Tp>,\n+      is_same<decltype(__a->__protocol()), typename _Tp::protocol_type>\n+      >::value,\n+    __void_t< typename _Tp::protocol_type::endpoint >>;\n+\n+  template<typename _Tp>\n+    struct __is_endpoint_impl<_Tp, decltype(__endpoint_reqs<_Tp>())>\n+    : true_type\n+    { };\n+\n+  template<typename _Tp>\n+    struct __is_endpoint : __is_endpoint_impl<_Tp>\n+    { };\n+\n+  // TODO Endpoint reqs for extensible implementations\n+  // TODO _Protocol reqs\n+  // TODO AcceptableProtocol reqs\n+  // TODO GettableSocket reqs\n+  // TODO SettableSocket reqs\n+  // TODO BooleanSocketOption reqs\n+  // TODO IntegerSocketOption reqs\n+  // TODO _IoControlCommand reqs\n+  // TODO _ConnectCondition reqs\n+\n+  /** @brief Sockets\n+   * @{\n+   */\n+\n+  class socket_base\n+  {\n+  public:\n+    struct broadcast : __sockopt_crtp<broadcast, bool>\n+    {\n+      using __sockopt_crtp::__sockopt_crtp;\n+\n+      static const int _S_level = SOL_SOCKET;\n+      static const int _S_name = SO_BROADCAST;\n+    };\n+\n+    struct debug : __sockopt_crtp<debug, bool>\n+    {\n+      using __sockopt_crtp::__sockopt_crtp;\n+\n+      static const int _S_level = SOL_SOCKET;\n+      static const int _S_name = SO_DEBUG;\n+    };\n+\n+    struct do_not_route : __sockopt_crtp<do_not_route, bool>\n+    {\n+      using __sockopt_crtp::__sockopt_crtp;\n+\n+      static const int _S_level = SOL_SOCKET;\n+      static const int _S_name = SO_DONTROUTE;\n+    };\n+\n+    struct keep_alive : __sockopt_crtp<keep_alive, bool>\n+    {\n+      using __sockopt_crtp::__sockopt_crtp;\n+\n+      static const int _S_level = SOL_SOCKET;\n+      static const int _S_name = SO_KEEPALIVE;\n+    };\n+\n+    struct linger : __sockopt_crtp<linger, ::linger>\n+    {\n+      using __sockopt_crtp::__sockopt_crtp;\n+\n+      linger() noexcept = default;\n+\n+      linger(bool __e, chrono::seconds __t) noexcept\n+      {\n+\tenabled(__e);\n+\ttimeout(__t);\n+      }\n+\n+      bool\n+      enabled() const noexcept\n+      { return _M_value.l_onoff != 0; }\n+\n+      void\n+      enabled(bool __e) noexcept\n+      { _M_value.l_onoff = int(__e); }\n+\n+      chrono::seconds\n+      timeout() const noexcept\n+      { return chrono::seconds(_M_value.l_linger); }\n+\n+      void\n+      timeout(chrono::seconds __t) noexcept\n+      { _M_value.l_linger = __t.count(); }\n+\n+      static const int _S_level = SOL_SOCKET;\n+      static const int _S_name = SO_LINGER;\n+    };\n+\n+    struct out_of_band_inline : __sockopt_crtp<out_of_band_inline, bool>\n+    {\n+      using __sockopt_crtp::__sockopt_crtp;\n+\n+      static const int _S_level = SOL_SOCKET;\n+      static const int _S_name = SO_OOBINLINE;\n+    };\n+\n+    struct receive_buffer_size : __sockopt_crtp<receive_buffer_size>\n+    {\n+      using __sockopt_crtp::__sockopt_crtp;\n+\n+      static const int _S_level = SOL_SOCKET;\n+      static const int _S_name = SO_RCVBUF;\n+    };\n+\n+    struct receive_low_watermark : __sockopt_crtp<receive_low_watermark>\n+    {\n+      using __sockopt_crtp::__sockopt_crtp;\n+\n+      static const int _S_level = SOL_SOCKET;\n+      static const int _S_name = SO_RCVLOWAT;\n+    };\n+\n+    struct reuse_address : __sockopt_crtp<reuse_address, bool>\n+    {\n+      using __sockopt_crtp::__sockopt_crtp;\n+\n+      static const int _S_level = SOL_SOCKET;\n+      static const int _S_name = SO_REUSEADDR;\n+    };\n+\n+    struct send_buffer_size : __sockopt_crtp<send_buffer_size>\n+    {\n+      using __sockopt_crtp::__sockopt_crtp;\n+\n+      static const int _S_level = SOL_SOCKET;\n+      static const int _S_name = SO_SNDBUF;\n+    };\n+\n+    struct send_low_watermark : __sockopt_crtp<send_low_watermark>\n+    {\n+      using __sockopt_crtp::__sockopt_crtp;\n+\n+      static const int _S_level = SOL_SOCKET;\n+      static const int _S_name = SO_SNDLOWAT;\n+    };\n+\n+    enum shutdown_type : int\n+    {\n+      __shutdown_receive\t= SHUT_RD,\n+      __shutdown_send\t\t= SHUT_WR,\n+      __shutdown_both\t\t= SHUT_RDWR\n+    };\n+    static constexpr shutdown_type shutdown_receive\t= __shutdown_receive;\n+    static constexpr shutdown_type shutdown_send\t= __shutdown_send;\n+    static constexpr shutdown_type shutdown_both\t= __shutdown_both;\n+\n+    enum wait_type : int\n+    {\n+      __wait_read\t\t= POLLIN,\n+      __wait_write\t\t= POLLOUT,\n+      __wait_error\t\t= POLLERR\n+    };\n+    static constexpr wait_type wait_read\t\t= __wait_read;\n+    static constexpr wait_type wait_write\t\t= __wait_write;\n+    static constexpr wait_type wait_error\t\t= __wait_error;\n+\n+    enum message_flags : int\n+    {\n+      __message_peek\t\t= MSG_PEEK,\n+      __message_oob\t\t= MSG_OOB,\n+      __message_dontroute\t= MSG_DONTROUTE\n+    };\n+    static constexpr message_flags message_peek\t\t= __message_peek;\n+    static constexpr message_flags message_out_of_band\t= __message_oob;\n+    static constexpr message_flags message_do_not_route\t= __message_dontroute;\n+\n+    static const int max_listen_connections = SOMAXCONN;\n+\n+  protected:\n+    socket_base() = default;\n+    ~socket_base() = default;\n+\n+    struct __msg_hdr : ::msghdr\n+    {\n+#ifdef IOV_MAX\n+      using __iovec_array = array<::iovec, IOV_MAX>;\n+#elif _GLIBCXX_HAVE_UNISTD_H\n+      struct __iovec_array\n+      {\n+\t__iovec_array() : _M_ptr(new ::iovec[size()]) { }\n+\n+\t::iovec& operator[](size_t __n) noexcept { return _M_ptr[__n]; }\n+\n+\t::iovec* data() noexcept { return _M_ptr.get(); }\n+\n+\tstatic size_t size()\n+\t{\n+\t  static const size_t __iov_max = ::sysconf(_SC_IOV_MAX);\n+\t  return __iov_max;\n+\t}\n+\n+      private:\n+\tunique_ptr<::iovec[]> _M_ptr;\n+      };\n+#else\n+      using __iovec_array = array<::iovec, 16>;\n+#endif\n+\n+      __iovec_array _M_iov;\n+\n+      template<typename _BufferSequence>\n+\texplicit\n+\t__msg_hdr(const _BufferSequence& __buffers)\n+\t: msghdr()\n+\t{\n+\t  auto __buf = net::buffer_sequence_begin(__buffers);\n+\t  const auto __bufend = net::buffer_sequence_end(__buffers);\n+\t  size_t __len = 0;\n+\t  while (__buf != __bufend && __len != _M_iov.size())\n+\t    {\n+\t      _M_iov[__len].iov_base = (void*)__buf->data();\n+\t      _M_iov[__len].iov_len = __buf->size();\n+\t      ++__buf;\n+\t      ++__len;\n+\t    }\n+\t  this->msg_iovlen = __len;\n+\t  this->msg_iov = _M_iov.data();\n+\t}\n+\n+      template<typename _BufferSequence, typename _Endpoint>\n+\t__msg_hdr(const _BufferSequence& __buffers, const _Endpoint& __ep)\n+\t: __msg_hdr(__buffers)\n+\t{\n+\t  this->msg_name = __ep.data();\n+\t  this->msg_namelen = __ep.size();\n+\t}\n+    };\n+  };\n+\n+  constexpr socket_base::message_flags\n+  operator&(socket_base::message_flags __f1, socket_base::message_flags __f2)\n+  { return socket_base::message_flags( int(__f1) & int(__f2) ); }\n+\n+  constexpr socket_base::message_flags\n+  operator|(socket_base::message_flags __f1, socket_base::message_flags __f2)\n+  { return socket_base::message_flags( int(__f1) | int(__f2) ); }\n+\n+  constexpr socket_base::message_flags\n+  operator^(socket_base::message_flags __f1, socket_base::message_flags __f2)\n+  { return socket_base::message_flags( int(__f1) ^ int(__f2) ); }\n+\n+  constexpr socket_base::message_flags\n+  operator~(socket_base::message_flags __f)\n+  { return socket_base::message_flags( ~int(__f) ); }\n+\n+  inline socket_base::message_flags&\n+  operator&=(socket_base::message_flags& __f1, socket_base::message_flags __f2)\n+  { return __f1 = (__f1 & __f2); }\n+\n+  inline socket_base::message_flags&\n+  operator|=(socket_base::message_flags& __f1, socket_base::message_flags __f2)\n+  { return __f1 = (__f1 | __f2); }\n+\n+  inline socket_base::message_flags&\n+  operator^=(socket_base::message_flags& __f1, socket_base::message_flags __f2)\n+  { return __f1 = (__f1 ^ __f2); }\n+\n+#if _GLIBCXX_HAVE_UNISTD_H\n+\n+  class __socket_impl\n+  {\n+  protected:\n+\n+    using executor_type = io_context::executor_type;\n+    using native_handle_type = int;\n+\n+    explicit\n+    __socket_impl(io_context& __ctx) : _M_ctx(std::addressof(__ctx)) { }\n+\n+    __socket_impl(__socket_impl&& __rhs)\n+    : _M_ctx(__rhs._M_ctx),\n+      _M_sockfd(std::exchange(__rhs._M_sockfd, -1)),\n+      _M_bits(std::exchange(__rhs._M_bits, {}))\n+    { }\n+\n+    __socket_impl&\n+    operator=(__socket_impl&& __rhs)\n+    {\n+      _M_ctx = __rhs._M_ctx;\n+      _M_sockfd = std::exchange(__rhs._M_sockfd, -1);\n+      _M_bits = std::exchange(__rhs._M_bits, {});\n+      return *this;\n+    }\n+\n+    ~__socket_impl() = default;\n+\n+    __socket_impl(const __socket_impl&) = delete;\n+    __socket_impl& operator=(const __socket_impl&) = delete;\n+\n+    executor_type get_executor() noexcept { return _M_ctx->get_executor(); }\n+\n+    native_handle_type native_handle() noexcept { return _M_sockfd; }\n+\n+    bool is_open() const noexcept { return _M_sockfd != -1; }\n+\n+    void\n+    close(error_code& __ec)\n+    {\n+      if (is_open())\n+\t{\n+\t  cancel(__ec);\n+\t  if (!__ec)\n+\t    {\n+\t      if (::close(_M_sockfd) == -1)\n+\t\t__ec.assign(errno, generic_category());\n+\t      else\n+\t\t{\n+\t\t  get_executor().context()._M_remove_fd(_M_sockfd);\n+\t\t  _M_sockfd = -1;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+    void cancel(error_code& __ec) { _M_ctx->cancel(_M_sockfd, __ec); }\n+\n+    void\n+    non_blocking(bool __mode, error_code&)\n+    { _M_bits.non_blocking = __mode; }\n+\n+    bool non_blocking() const { return _M_bits.non_blocking; }\n+\n+    void\n+    native_non_blocking(bool __mode, error_code& __ec)\n+    {\n+      int __flags = ::fcntl(_M_sockfd, F_GETFL, 0);\n+      if (__flags >= 0)\n+\t{\n+\t  if (__mode)\n+\t    __flags |= O_NONBLOCK;\n+\t  else\n+\t    __flags &= ~O_NONBLOCK;\n+\t  __flags = ::fcntl(_M_sockfd, F_SETFL, __flags);\n+\t}\n+      if (__flags == -1)\n+\t__ec.assign(errno, generic_category());\n+      else\n+\t{\n+\t  __ec.clear();\n+\t  _M_bits.native_non_blocking = __mode;\n+\t}\n+    }\n+\n+    bool\n+    native_non_blocking() const\n+    {\n+      if (_M_bits.native_non_blocking == -1)\n+\t{\n+\t  const int __flags = ::fcntl(_M_sockfd, F_GETFL, 0);\n+\t  if (__flags == -1)\n+\t    return 0;\n+\t  _M_bits.native_non_blocking = __flags & O_NONBLOCK;\n+\t}\n+      return _M_bits.native_non_blocking;\n+    }\n+\n+    io_context*\t_M_ctx;\n+    int\t\t_M_sockfd{-1};\n+    struct {\n+      unsigned\t\tnon_blocking : 1;\n+      mutable signed\tnative_non_blocking : 2;\n+      unsigned\t\tenable_connection_aborted : 1;\n+    } _M_bits{};\n+  };\n+\n+  template<typename _Protocol>\n+    class __basic_socket_impl : public __socket_impl\n+    {\n+      using __base = __socket_impl;\n+\n+    protected:\n+      using protocol_type = _Protocol;\n+      using endpoint_type = typename protocol_type::endpoint;\n+\n+      explicit\n+      __basic_socket_impl(io_context& __ctx) : __base(__ctx) { }\n+\n+      __basic_socket_impl(__basic_socket_impl&&) = default;\n+\n+      template<typename _OtherProtocol>\n+\t__basic_socket_impl(__basic_socket_impl<_OtherProtocol>&& __rhs)\n+\t: __base(std::move(__rhs)), _M_protocol(std::move(__rhs._M_protocol))\n+\t{ }\n+\n+      __basic_socket_impl&\n+      operator=(__basic_socket_impl&& __rhs)\n+      {\n+\tif (this == std::addressof(__rhs))\n+\t  return *this;\n+\t_M_close();\n+\t__base::operator=(std::move(__rhs));\n+\treturn *this;\n+      }\n+\n+      ~__basic_socket_impl() { _M_close(); }\n+\n+      __basic_socket_impl(const __basic_socket_impl&) = delete;\n+      __basic_socket_impl& operator=(const __basic_socket_impl&) = delete;\n+\n+      void\n+      open(const protocol_type& __protocol, error_code& __ec)\n+      {\n+\tif (is_open())\n+\t  __ec = socket_errc::already_open;\n+\telse\n+\t  {\n+\t    _M_protocol = __protocol;\n+\t    _M_sockfd = ::socket(__protocol.family(), __protocol.type(),\n+\t\t\t\t __protocol.protocol());\n+\t    if (is_open())\n+\t      {\n+\t\tget_executor().context()._M_add_fd(_M_sockfd);\n+\t      __ec.clear();\n+\t      }\n+\t    else\n+\t      __ec.assign(errno, std::generic_category());\n+\t  }\n+      }\n+\n+      void\n+      assign(const protocol_type& __protocol,\n+\t     const native_handle_type& __native_socket,\n+\t     error_code& __ec)\n+      {\n+\tif (is_open())\n+\t  __ec = socket_errc::already_open;\n+\telse\n+\t  {\n+\t    _M_protocol = __protocol;\n+\t    _M_bits.native_non_blocking = -1;\n+\t    _M_sockfd = __native_socket;\n+\t    if (is_open())\n+\t      {\n+\t\tget_executor().context()._M_add_fd(_M_sockfd);\n+\t\t__ec.clear();\n+\t      }\n+\t    else\n+\t      __ec.assign(errno, std::generic_category());\n+\t  }\n+      }\n+\n+      template<typename _SettableSocketOption>\n+\tvoid\n+\tset_option(const _SettableSocketOption& __option, error_code& __ec)\n+\t{\n+\t  int __result = ::setsockopt(_M_sockfd, __option.level(_M_protocol),\n+\t\t\t\t      __option.name(_M_protocol),\n+\t\t\t\t      __option.data(_M_protocol),\n+\t\t\t\t      __option.size(_M_protocol));\n+\t  if (__result == -1)\n+\t    __ec.assign(errno, generic_category());\n+\t  else\n+\t    __ec.clear();\n+\t}\n+\n+      template<typename _GettableSocketOption>\n+\tvoid\n+\tget_option(_GettableSocketOption& __option, error_code& __ec) const\n+\t{\n+\t  int __result = ::getsockopt(_M_sockfd, __option.level(_M_protocol),\n+\t\t\t\t      __option.name(_M_protocol),\n+\t\t\t\t      __option.data(_M_protocol),\n+\t\t\t\t      __option.size(_M_protocol));\n+\t  if (__result == -1)\n+\t    __ec.assign(errno, generic_category());\n+\t  else\n+\t    __ec.clear();\n+\t}\n+\n+      template<typename _IoControlCommand>\n+\tvoid\n+\tio_control(_IoControlCommand& __command, error_code& __ec)\n+\t{\n+\t  int __result = ::ioctl(_M_sockfd, __command.name(_M_protocol),\n+\t\t\t\t __command.data(_M_protocol));\n+\t  if (__result == -1)\n+\t    __ec.assign(errno, generic_category());\n+\t  else\n+\t    __ec.clear();\n+\t}\n+\n+      endpoint_type\n+      local_endpoint(error_code& __ec) const\n+      {\n+\tendpoint_type __endpoint;\n+\tsocklen_t __endpoint_len = __endpoint.capacity();\n+\tif (::getsockname(_M_sockfd, (sockaddr*)__endpoint.data(),\n+                          &__endpoint_len) == -1)\n+\t  {\n+\t    __ec.assign(errno, generic_category());\n+\t    return endpoint_type{};\n+\t  }\n+\t__ec.clear();\n+\t__endpoint.resize(__endpoint_len);\n+\treturn __endpoint;\n+      }\n+\n+      void\n+      bind(const endpoint_type& __endpoint, error_code& __ec)\n+      {\n+\tif (::bind(_M_sockfd, (sockaddr*)__endpoint.data(), __endpoint.size())\n+\t    == -1)\n+\t  __ec.assign(errno, generic_category());\n+\telse\n+\t  __ec.clear();\n+      }\n+\n+      _Protocol\t_M_protocol{ endpoint_type{}.protocol() };\n+\n+    private:\n+      void\n+      _M_close()\n+      {\n+\tif (is_open())\n+\t  {\n+\t    error_code __ec;\n+\t    cancel(__ec);\n+\t    set_option(socket_base::linger{false, chrono::seconds{}}, __ec);\n+\t    ::close(_M_sockfd);\n+\t  }\n+      }\n+    };\n+\n+  template<typename _Protocol>\n+    class basic_socket\n+    : public socket_base, private __basic_socket_impl<_Protocol>\n+    {\n+      using __base = __basic_socket_impl<_Protocol>;\n+\n+    public:\n+      // types:\n+\n+      typedef io_context::executor_type executor_type;\n+      typedef int native_handle_type;\n+      typedef _Protocol protocol_type;\n+      typedef typename protocol_type::endpoint endpoint_type;\n+\n+      // basic_socket operations:\n+\n+      executor_type get_executor() noexcept { return __base::get_executor(); }\n+\n+      native_handle_type\n+      native_handle() noexcept { return __base::native_handle(); }\n+\n+      void\n+      open(const protocol_type& __protocol = protocol_type())\n+      { open(__protocol, __throw_on_error{\"basic_socket::open\"}); }\n+\n+      void\n+      open(const protocol_type& __protocol, error_code& __ec)\n+      { __base::open(__protocol, __ec); }\n+\n+      void\n+      assign(const protocol_type& __protocol,\n+\t     const native_handle_type& __native_socket)\n+      {\n+\tassign(__protocol, __native_socket,\n+\t       __throw_on_error{\"basic_socket::assign\"});\n+      }\n+\n+      void\n+      assign(const protocol_type& __protocol,\n+\t     const native_handle_type& __native_socket,\n+\t     error_code& __ec)\n+      { __base::assign(__protocol, __native_socket, __ec); }\n+\n+      bool is_open() const noexcept { return __base::is_open(); }\n+\n+      void close() { close(__throw_on_error{\"basic_socket::close\"}); }\n+\n+      void close(error_code& __ec) { __base::close(); }\n+\n+      void cancel() { cancel(__throw_on_error{\"basic_socket::cancel\"}); }\n+\n+      void cancel(error_code& __ec) { __base::cancel(__ec); }\n+\n+      template<typename _SettableSocketOption>\n+\tvoid\n+\tset_option(const _SettableSocketOption& __option)\n+\t{ set_option(__option, __throw_on_error{\"basic_socket::set_option\"}); }\n+\n+      template<typename _SettableSocketOption>\n+\tvoid\n+\tset_option(const _SettableSocketOption& __option, error_code& __ec)\n+\t{ __base::set_option(__option, __ec); }\n+\n+      template<typename _GettableSocketOption>\n+\tvoid\n+\tget_option(_GettableSocketOption& __option) const\n+\t{ get_option(__option, __throw_on_error{\"basic_socket::get_option\"}); }\n+\n+      template<typename _GettableSocketOption>\n+\tvoid\n+\tget_option(_GettableSocketOption& __option, error_code& __ec) const\n+\t{ __base::get_option(__option, __ec); }\n+\n+      template<typename _IoControlCommand>\n+\tvoid\n+\tio_control(_IoControlCommand& __command)\n+\t{\n+\t  io_control(__command, __throw_on_error{\"basic_socket::io_control\"});\n+\t}\n+\n+      template<typename _IoControlCommand>\n+\tvoid\n+\tio_control(_IoControlCommand& __command, error_code& __ec)\n+\t{ __base::io_control(__command, __ec); }\n+\n+      void\n+      non_blocking(bool __mode)\n+      { non_blocking(__mode, __throw_on_error{\"basic_socket::non_blocking\"}); }\n+\n+      void\n+      non_blocking(bool __mode, error_code& __ec)\n+      { __base::non_blocking(__mode, __ec); }\n+\n+      bool non_blocking() const { return __base::non_blocking(); }\n+\n+      void\n+      native_non_blocking(bool __mode)\n+      {\n+\tnative_non_blocking(__mode, __throw_on_error{\n+\t    \"basic_socket::native_non_blocking\"});\n+      }\n+\n+      void\n+      native_non_blocking(bool __mode, error_code& __ec)\n+      { __base::native_non_blocking(__mode, __ec); }\n+\n+      bool\n+      native_non_blocking() const\n+      { return __base::native_non_blocking(); }\n+\n+      bool at_mark() const\n+      { return at_mark(__throw_on_error{\"basic_socket::at_mark\"}); }\n+\n+      bool\n+      at_mark(error_code& __ec) const\n+      {\n+\tconst int __result = ::sockatmark(native_handle());\n+\tif (__result == -1)\n+\t  __ec.assign(errno, generic_category());\n+\telse\n+\t  {\n+\t    __ec.clear();\n+\t    return __result;\n+\t  }\n+      }\n+\n+      size_t\n+      available() const\n+      { return available(__throw_on_error{\"basic_socket::available\"}); }\n+\n+      size_t\n+      available(error_code& __ec) const\n+      {\n+\tif (!is_open())\n+\t  {\n+\t    __ec = std::make_error_code(errc::bad_file_descriptor);\n+\t    return 0;\n+\t  }\n+#ifdef FIONREAD\n+\tint __avail = 0;\n+\tif (::ioctl(this->_M_sockfd, FIONREAD, &__avail) == -1)\n+\t  {\n+\t    __ec.assign(errno, generic_category());\n+\t    return 0;\n+\t  }\n+\t__ec.clear();\n+\treturn __avail;\n+#else\n+\treturn 0;\n+#endif\n+      }\n+\n+      void\n+      bind(const endpoint_type& __endpoint)\n+      { return bind(__endpoint, __throw_on_error{\"basic_socket::bind\"}); }\n+\n+      void\n+      bind(const endpoint_type& __endpoint, error_code& __ec)\n+      { __base::bind(__endpoint, __ec); }\n+\n+      void shutdown(shutdown_type __what)\n+      { return shutdown(__what, __throw_on_error{\"basic_socket::shutdown\"}); }\n+\n+      void\n+      shutdown(shutdown_type __what, error_code& __ec)\n+      {\n+\tif (::shutdown(native_handle(), static_cast<int>(__what)) == -1)\n+\t  __ec.assign(errno, generic_category());\n+\telse\n+\t  __ec.clear();\n+      }\n+\n+      endpoint_type\n+      local_endpoint() const\n+      {\n+\treturn local_endpoint(\n+\t    __throw_on_error{\"basic_socket::local_endpoint\"});\n+      }\n+\n+      endpoint_type\n+      local_endpoint(error_code& __ec) const\n+      { return __base::local_endpoint(__ec); }\n+\n+      endpoint_type\n+      remote_endpoint() const\n+      {\n+\treturn remote_endpoint(\n+\t    __throw_on_error{\"basic_socket::remote_endpoint\"});\n+      }\n+\n+      endpoint_type\n+      remote_endpoint(error_code& __ec) const\n+      {\n+\tendpoint_type __endpoint;\n+\tsocklen_t __endpoint_len = __endpoint.capacity();\n+\tif (::getpeername(this->_M_sockfd, (sockaddr*)__endpoint.data(),\n+                          &__endpoint_len)\n+\t    == -1)\n+\t  {\n+\t    __ec.assign(errno, generic_category());\n+\t    return endpoint_type{};\n+\t  }\n+\t__ec.clear();\n+\t__endpoint.resize(__endpoint_len);\n+\treturn __endpoint;\n+      }\n+\n+      void\n+      connect(const endpoint_type& __endpoint)\n+      {\n+\treturn connect(__endpoint, __throw_on_error{\"basic_socket::connect\"});\n+      }\n+\n+      void\n+      connect(const endpoint_type& __endpoint, error_code& __ec)\n+      {\n+\tif (!is_open())\n+\t  {\n+\t    open(__endpoint.protocol(), __ec);\n+\t    if (__ec)\n+\t      return;\n+\t  }\n+\tif (::connect(native_handle(), (const sockaddr*)__endpoint.data(),\n+\t\t      __endpoint.size()) == -1)\n+\t  __ec.assign(errno, generic_category());\n+\telse\n+\t  __ec.clear();\n+      }\n+\n+      template<typename _CompletionToken>\n+\t__deduced_t<_CompletionToken, void(error_code)>\n+\tasync_connect(const endpoint_type& __endpoint,\n+\t\t      _CompletionToken&& __token)\n+\t{\n+\t  async_completion<_CompletionToken, void(error_code)> __init{__token};\n+\n+\t  if (!is_open())\n+\t    {\n+\t      error_code __ec;\n+\t      open(__endpoint.protocol(), __ec);\n+\t      if (__ec)\n+\t\t{\n+                  auto __ex = net::get_associated_executor(\n+                      __init.completion_handler, get_executor());\n+                  auto __a = get_associated_allocator(\n+                      __init.completion_handler, std::allocator<void>());\n+                  __ex.post(\n+                      [__h=std::move(__init.completion_handler), __ec]\n+                      () mutable\n+                      { __h(__ec); }, __a);\n+\t\t  return __init.result.get();\n+\t\t}\n+\t    }\n+\n+\t  get_executor().context().async_wait( native_handle(),\n+\t      socket_base::wait_read,\n+\t      [__h = std::move(__init.completion_handler),\n+               __ep = std::move(__endpoint),\n+               __fd = native_handle()]\n+               (error_code __ec) mutable {\n+                  if (!__ec && ::connect(__fd, (const sockaddr*)__ep.data(),\n+\t\t\t\t\t __ep.size()) == -1)\n+                    __ec.assign(errno, generic_category());\n+\t\t  __h(__ec);\n+\t      });\n+\t  return __init.result.get();\n+\t}\n+\n+      void\n+      wait(wait_type __w)\n+      { return wait(__w, __throw_on_error{\"basic_socket::wait\"}); }\n+\n+      void\n+      wait(wait_type __w, error_code& __ec)\n+      {\n+\t::pollfd __fd;\n+\t__fd.fd = native_handle();\n+\t__fd.events = static_cast<int>(__w);\n+\tint __res = ::poll(&__fd, 1, -1);\n+\tif (__res == -1)\n+\t  __ec.assign(errno, generic_category());\n+\telse\n+\t  __ec.clear();\n+      }\n+\n+      template<typename _CompletionToken>\n+\t__deduced_t<_CompletionToken, void(error_code)>\n+\tasync_wait(wait_type __w, _CompletionToken&& __token)\n+\t{\n+\t  async_completion<_CompletionToken, void(error_code)> __init{__token};\n+\t  get_executor().context().async_wait( native_handle(),\n+\t      static_cast<int>(__w),\n+\t      [__h = std::move(__init.completion_handler)]\n+              (error_code __ec) mutable {\n+\t\t  __h(__ec);\n+\t      });\n+\t  return __init.result.get();\n+\t}\n+\n+    protected:\n+      // construct / copy / destroy:\n+\n+      using __base::__base;\n+\n+      explicit\n+      basic_socket(io_context& __ctx) : __base(__ctx) { }\n+\n+      basic_socket(io_context& __ctx, const protocol_type& __protocol)\n+      : __base(__ctx)\n+      { open(__protocol); }\n+\n+      basic_socket(io_context& __ctx, const endpoint_type& __endpoint)\n+      : basic_socket(std::addressof(__ctx), __endpoint.protocol())\n+      { bind(__endpoint); }\n+\n+      basic_socket(io_context& __ctx, const protocol_type& __protocol,\n+\t\t   const native_handle_type& __native_socket)\n+      : __base(__ctx)\n+      { assign(__protocol, __native_socket); }\n+\n+      basic_socket(const basic_socket&) = delete;\n+\n+      basic_socket(basic_socket&& __rhs) = default;\n+\n+      template<typename _OtherProtocol, typename _Requires\n+\t       = _Require<is_convertible<_OtherProtocol, _Protocol>>>\n+\tbasic_socket(basic_socket<_OtherProtocol>&& __rhs)\n+\t: __base(std::move(__rhs)) { }\n+\n+      ~basic_socket() = default;\n+\n+      basic_socket& operator=(const basic_socket&) = delete;\n+\n+      basic_socket& operator=(basic_socket&& __rhs) = default;\n+\n+      template<typename _OtherProtocol>\n+\tenable_if_t<is_convertible<_OtherProtocol, _Protocol>::value,\n+\t\t    basic_socket&>\n+\toperator=(basic_socket<_OtherProtocol>&& __rhs)\n+        { return *this = basic_socket{std::move(__rhs)}; }\n+    };\n+\n+  template<typename _Protocol>\n+    class basic_datagram_socket : public basic_socket<_Protocol>\n+    {\n+      using __base = basic_socket<_Protocol>;\n+\n+    public:\n+      // types:\n+\n+      typedef int native_handle_type;\n+      typedef _Protocol protocol_type;\n+      typedef typename protocol_type::endpoint endpoint_type;\n+\n+      // construct / copy / destroy:\n+\n+      explicit\n+      basic_datagram_socket(io_context& __ctx) : __base(__ctx) { }\n+\n+      basic_datagram_socket(io_context& __ctx, const protocol_type& __protocol)\n+      : __base(__ctx, __protocol) { }\n+\n+      basic_datagram_socket(io_context& __ctx, const endpoint_type& __endpoint)\n+      : __base(__ctx, __endpoint) { }\n+\n+      basic_datagram_socket(io_context& __ctx, const protocol_type& __protocol,\n+\t\t\t    const native_handle_type& __native_socket)\n+      : __base(__ctx, __protocol, __native_socket) { }\n+\n+      basic_datagram_socket(const basic_datagram_socket&) = delete;\n+\n+      basic_datagram_socket(basic_datagram_socket&& __rhs) = default;\n+\n+      template<typename _OtherProtocol, typename _Requires\n+\t       = _Require<is_convertible<_OtherProtocol, _Protocol>>>\n+\tbasic_datagram_socket(basic_datagram_socket<_OtherProtocol>&& __rhs)\n+\t: __base(std::move(__rhs)) { }\n+\n+      ~basic_datagram_socket() = default;\n+\n+      basic_datagram_socket& operator=(const basic_datagram_socket&) = delete;\n+\n+      basic_datagram_socket& operator=(basic_datagram_socket&& __rhs) = default;\n+\n+      template<typename _OtherProtocol>\n+\tenable_if_t<is_convertible<_OtherProtocol, _Protocol>::value,\n+\t\t    basic_datagram_socket&>\n+\toperator=(basic_datagram_socket<_OtherProtocol>&& __rhs)\n+\t{\n+\t  __base::operator=(std::move(__rhs));\n+\t  return *this;\n+\t}\n+\n+      // basic_datagram_socket operations:\n+\n+      template<typename _MutableBufferSequence>\n+\tsize_t\n+\treceive(const _MutableBufferSequence& __buffers)\n+\t{\n+\t  return receive(__buffers, socket_base::message_flags(),\n+\t\t\t __throw_on_error{\"basic_datagram_socket::receive\"});\n+\t}\n+\n+      template<typename _MutableBufferSequence>\n+\tsize_t\n+\treceive(const _MutableBufferSequence& __buffers, error_code& __ec)\n+        { return receive(__buffers, socket_base::message_flags(), __ec); }\n+\n+      template<typename _MutableBufferSequence>\n+\tsize_t\n+\treceive(const _MutableBufferSequence& __buffers,\n+\t\t       socket_base::message_flags __flags)\n+\t{\n+\t  return receive(__buffers, __flags,\n+\t\t\t __throw_on_error{\"basic_datagram_socket::receive\"});\n+\t}\n+\n+      template<typename _MutableBufferSequence>\n+\tsize_t\n+\treceive(const _MutableBufferSequence& __buffers,\n+\t\tsocket_base::message_flags __flags, error_code& __ec)\n+\t{\n+\t  socket_base::__msg_hdr __msg(__buffers);\n+\t  ssize_t __result = ::recvmsg(this->native_handle(), &__msg,\n+\t\t\t\t       static_cast<int>(__flags));\n+\t  if (__result == -1)\n+            {\n+              __ec.assign(errno, generic_category());\n+              return 0;\n+            }\n+          __ec.clear();\n+          return __result;\n+\t}\n+\n+      template<typename _MutableBufferSequence, typename _CompletionToken>\n+\t__deduced_t<_CompletionToken, void(error_code, size_t)>\n+\tasync_receive(const _MutableBufferSequence& __buffers,\n+\t\t      _CompletionToken&& __token)\n+\t{\n+\t  return async_receive(__buffers, socket_base::message_flags(),\n+\t\t\t       std::forward<_CompletionToken>(__token));\n+\t}\n+\n+      template<typename _MutableBufferSequence, typename _CompletionToken>\n+\t__deduced_t<_CompletionToken, void(error_code, size_t)>\n+\tasync_receive(const _MutableBufferSequence& __buffers,\n+\t\t      socket_base::message_flags __flags,\n+\t\t      _CompletionToken&& __token)\n+\t{\n+          async_completion<_CompletionToken, void(error_code, size_t)>\n+            __init{__token};\n+\n+\t  this->get_executor().context().async_wait(this->native_handle(),\n+\t      socket_base::wait_read,\n+\t      [__h = std::move(__init.completion_handler),\n+               &__buffers, __flags = static_cast<int>(__flags),\n+               __fd = this->native_handle()]\n+              (error_code __ec) mutable {\n+                  if (__ec)\n+                    {\n+                      __h(__ec);\n+                      return;\n+                    }\n+                  socket_base::__msg_hdr __msg(__buffers);\n+                  ssize_t __result = ::recvmsg(__fd, &__msg, __flags);\n+                  if (__result == -1)\n+                    {\n+                      __ec.assign(errno, generic_category());\n+                      __result = 0;\n+                    }\n+                  else\n+                    __ec.clear();\n+\t\t  __h(__ec, __result);\n+\t      });\n+\t  return __init.result.get();\n+\t}\n+\n+      template<typename _MutableBufferSequence>\n+\tsize_t\n+\treceive_from(const _MutableBufferSequence& __buffers,\n+\t\t     endpoint_type& __sender)\n+\t{\n+\t  return receive_from(__buffers, __sender,\n+\t\t\t      socket_base::message_flags(),\n+\t\t\t      __throw_on_error{\n+\t\t\t\t  \"basic_datagram_socket::receive_from\"});\n+\t}\n+\n+      template<typename _MutableBufferSequence>\n+\tsize_t\n+\treceive_from(const _MutableBufferSequence& __buffers,\n+\t\t     endpoint_type& __sender, error_code& __ec)\n+\t{\n+\t  return receive_from(__buffers, __sender,\n+\t\t\t      socket_base::message_flags(), __ec);\n+\t}\n+\n+      template<typename _MutableBufferSequence>\n+\tsize_t\n+\treceive_from(const _MutableBufferSequence& __buffers,\n+\t\t     endpoint_type& __sender,\n+\t\t     socket_base::message_flags __flags)\n+\t{\n+\t  return receive_from(__buffers, __sender, __flags,\n+\t\t\t      __throw_on_error{\n+\t\t\t\t  \"basic_datagram_socket::receive_from\"});\n+\t}\n+\n+      template<typename _MutableBufferSequence>\n+\tsize_t\n+\treceive_from(const _MutableBufferSequence& __buffers,\n+\t\t     endpoint_type& __sender,\n+\t\t     socket_base::message_flags __flags,\n+\t\t     error_code& __ec)\n+\t{\n+\t  socket_base::__msg_hdr __msg(__buffers, __sender);\n+\t  ssize_t __result = ::recvmsg(this->native_handle(), &__msg,\n+\t\t\t\t       static_cast<int>(__flags));\n+\t  if (__result == -1)\n+            {\n+              __ec.assign(errno, generic_category());\n+              return 0;\n+            }\n+          __ec.clear();\n+          __sender.resize(__msg.msg_namelen);\n+          return __result;\n+\t}\n+\n+      template<typename _MutableBufferSequence, typename _CompletionToken>\n+\t__deduced_t<_CompletionToken, void(error_code, size_t)>\n+\tasync_receive_from(const _MutableBufferSequence& __buffers,\n+\t\t\t   endpoint_type& __sender,\n+\t\t\t   _CompletionToken&& __token)\n+\t{\n+\t  return async_receive_from(__buffers, __sender,\n+\t\t\t\t    socket_base::message_flags(),\n+\t\t\t\t    std::forward<_CompletionToken>(__token));\n+\t}\n+\n+      template<typename _MutableBufferSequence, typename _CompletionToken>\n+\t__deduced_t<_CompletionToken, void(error_code, size_t)>\n+\tasync_receive_from(const _MutableBufferSequence& __buffers,\n+\t\t\t   endpoint_type& __sender,\n+\t\t\t   socket_base::message_flags __flags,\n+\t\t\t   _CompletionToken&& __token)\n+\t{\n+\t  async_completion<_CompletionToken, void(error_code, size_t)>\n+            __init{__token};\n+\n+\t  this->get_executor().context().async_wait( this->native_handle(),\n+\t      socket_base::wait_read,\n+\t      [__h = std::move(__init.completion_handler),\n+               &__buffers, __flags = static_cast<int>(__flags),\n+               __sender = std::move(__sender),\n+               __fd = this->native_handle()]\n+              (error_code __ec) mutable {\n+                  if (__ec)\n+                    {\n+                      __h(__ec);\n+                      return;\n+                    }\n+                  socket_base::__msg_hdr __msg(__buffers, __sender);\n+                  ssize_t __result = ::recvmsg(__fd, &__msg, __flags);\n+                  if (__result == -1)\n+                    {\n+                      __ec.assign(errno, generic_category());\n+                      __result = 0;\n+                    }\n+                  else\n+                    {\n+                      __ec.clear();\n+                      __sender.resize(__msg.msg_namelen);\n+                    }\n+\t\t  __h(__ec, __result);\n+\t      });\n+\t  return __init.result.get();\n+\t}\n+\n+      template<typename _ConstBufferSequence>\n+\tsize_t\n+\tsend(const _ConstBufferSequence& __buffers)\n+\t{\n+\t  return send(__buffers, socket_base::message_flags(),\n+\t\t      __throw_on_error{\"basic_datagram_socket::send\"});\n+\t}\n+\n+      template<typename _ConstBufferSequence>\n+\tsize_t\n+\tsend(const _ConstBufferSequence& __buffers, error_code& __ec)\n+\t{ return send(__buffers, socket_base::message_flags(), __ec); }\n+\n+      template<typename _ConstBufferSequence>\n+\tsize_t\n+\tsend(const _ConstBufferSequence& __buffers,\n+\t     socket_base::message_flags __flags)\n+\t{\n+\t  return send(__buffers, __flags,\n+\t\t      __throw_on_error{\"basic_datagram_socket::send\"});\n+\t}\n+\n+      template<typename _ConstBufferSequence>\n+\tsize_t\n+\tsend(const _ConstBufferSequence& __buffers,\n+\t     socket_base::message_flags __flags, error_code& __ec)\n+\t{\n+\t  socket_base::__msg_hdr __msg(__buffers);\n+\t  ssize_t __result = ::sendmsg(this->native_handle(), &__msg,\n+\t\t\t\t       static_cast<int>(__flags));\n+\t  if (__result == -1)\n+            {\n+              __ec.assign(errno, generic_category());\n+              return 0;\n+            }\n+          __ec.clear();\n+          return __result;\n+\t}\n+\n+      template<typename _ConstBufferSequence, typename _CompletionToken>\n+\t__deduced_t<_CompletionToken, void(error_code, size_t)>\n+\tasync_send(const _ConstBufferSequence& __buffers,\n+\t\t\t_CompletionToken&& __token)\n+\t{\n+\t  return async_send(__buffers, socket_base::message_flags(),\n+\t\t\t    std::forward<_CompletionToken>(__token));\n+\t}\n+\n+      template<typename _ConstBufferSequence, typename _CompletionToken>\n+\t__deduced_t<_CompletionToken, void(error_code, size_t)>\n+\tasync_send(const _ConstBufferSequence& __buffers,\n+\t\t   socket_base::message_flags __flags,\n+\t\t   _CompletionToken&& __token)\n+\t{\n+\t  async_completion<_CompletionToken, void(error_code, size_t)>\n+            __init{__token};\n+\n+\t  this->get_executor().context().async_wait( this->native_handle(),\n+\t      socket_base::wait_write,\n+\t      [__h = std::move(__init.completion_handler),\n+               &__buffers, __flags = static_cast<int>(__flags),\n+               __fd = this->native_handle()]\n+              (error_code __ec) mutable {\n+                  if (__ec)\n+                    {\n+                      __h(__ec);\n+                      return;\n+                    }\n+                  socket_base::__msg_hdr __msg(__buffers);\n+                  ssize_t __result = ::sendmsg(__fd, &__msg, __flags);\n+                  if (__result == -1)\n+                    {\n+                      __ec.assign(errno, generic_category());\n+                      __result = 0;\n+                    }\n+                  else\n+                    __ec.clear();\n+\t\t  __h(__ec, __result);\n+\t      });\n+\t  return __init.result.get();\n+\t}\n+\n+      template<typename _ConstBufferSequence>\n+\tsize_t\n+\tsend_to(const _ConstBufferSequence& __buffers,\n+\t        const endpoint_type& __recipient)\n+\t{\n+\t  return send_to(__buffers, __recipient,\n+\t\t\t socket_base::message_flags(),\n+\t\t\t __throw_on_error{\"basic_datagram_socket::send_to\"});\n+\t}\n+\n+      template<typename _ConstBufferSequence>\n+\tsize_t\n+\tsend_to(const _ConstBufferSequence& __buffers,\n+\t\tconst endpoint_type& __recipient, error_code& __ec)\n+\t{\n+\t  return send_to(__buffers, __recipient,\n+\t\t\t socket_base::message_flags(), __ec);\n+\t}\n+\n+      template<typename _ConstBufferSequence>\n+\tsize_t\n+\tsend_to(const _ConstBufferSequence& __buffers,\n+\t\tconst endpoint_type& __recipient,\n+\t\tsocket_base::message_flags __flags)\n+\t{\n+\t  return send_to(__buffers, __recipient, __flags,\n+\t\t\t __throw_on_error{\"basic_datagram_socket::send_to\"});\n+\t}\n+\n+      template<typename _ConstBufferSequence>\n+\tsize_t\n+\tsend_to(const _ConstBufferSequence& __buffers,\n+\t        const endpoint_type& __recipient,\n+\t\tsocket_base::message_flags __flags, error_code& __ec)\n+\t{\n+\t  socket_base::__msg_hdr __msg(__buffers, __recipient);\n+\t  ssize_t __result = ::sendmsg(this->native_handle(), &__msg,\n+\t\t\t\t       static_cast<int>(__flags));\n+\t  if (__result == -1)\n+            {\n+              __ec.assign(errno, generic_category());\n+              return 0;\n+            }\n+          __ec.clear();\n+          __recipient.resize(__msg.msg_namelen);\n+          return __result;\n+\t}\n+\n+      template<typename _ConstBufferSequence, typename _CompletionToken>\n+\t__deduced_t<_CompletionToken, void(error_code, size_t)>\n+\tasync_send_to(const _ConstBufferSequence& __buffers,\n+\t\t      const endpoint_type& __recipient,\n+\t\t      _CompletionToken&& __token)\n+\t{\n+\t  return async_send_to(__buffers, __recipient,\n+\t\t\t       socket_base::message_flags(),\n+\t\t\t       std::forward<_CompletionToken>(__token));\n+\t}\n+\n+      template<typename _ConstBufferSequence, typename _CompletionToken>\n+\t__deduced_t<_CompletionToken, void(error_code, size_t)>\n+\tasync_send_to(const _ConstBufferSequence& __buffers,\n+\t\t      const endpoint_type& __recipient,\n+\t\t      socket_base::message_flags __flags,\n+\t\t      _CompletionToken&& __token)\n+\t{\n+\t  async_completion<_CompletionToken, void(error_code, size_t)>\n+            __init{__token};\n+\n+\t  this->get_executor().context().async_wait( this->native_handle(),\n+\t      socket_base::wait_write,\n+\t      [__h = std::move(__init.completion_handler),\n+               &__buffers, __flags = static_cast<int>(__flags),\n+               __recipient = std::move(__recipient),\n+               __fd = this->native_handle()]\n+              (error_code __ec) mutable {\n+                  if (__ec)\n+                    {\n+                      __h(__ec);\n+                      return;\n+                    }\n+                  socket_base::__msg_hdr __msg(__buffers, __recipient);\n+                  ssize_t __result = ::sendmsg(__fd, &__msg, __flags);\n+                  if (__result == -1)\n+                    {\n+                      __ec.assign(errno, generic_category());\n+                      __result = 0;\n+                    }\n+                  else\n+                    {\n+                      __ec.clear();\n+                      __recipient.resize(__msg.msg_namelen);\n+                    }\n+\t\t  __h(__ec, __result);\n+\t      });\n+\t  return __init.result.get();\n+\t}\n+    };\n+\n+  template<typename _Protocol>\n+    class basic_stream_socket : public basic_socket<_Protocol>\n+    {\n+      using __base = basic_socket<_Protocol>;\n+\n+    public:\n+      // types:\n+\n+      typedef int native_handle_type;\n+      typedef _Protocol protocol_type;\n+      typedef typename protocol_type::endpoint endpoint_type;\n+\n+      // construct / copy / destroy:\n+\n+      explicit\n+      basic_stream_socket(io_context& __ctx) : __base(__ctx) { }\n+\n+      basic_stream_socket(io_context& __ctx, const protocol_type& __protocol)\n+      : __base(__ctx, __protocol) { }\n+\n+      basic_stream_socket(io_context& __ctx, const endpoint_type& __endpoint)\n+      : __base(__ctx, __endpoint) { }\n+\n+      basic_stream_socket(io_context& __ctx, const protocol_type& __protocol,\n+\t\t\t  const native_handle_type& __native_socket)\n+      : __base(__ctx, __protocol, __native_socket) { }\n+\n+      basic_stream_socket(const basic_stream_socket&) = delete;\n+\n+      basic_stream_socket(basic_stream_socket&& __rhs) = default;\n+\n+      template<typename _OtherProtocol, typename _Requires\n+\t       = _Require<is_convertible<_OtherProtocol, _Protocol>>>\n+\tbasic_stream_socket(basic_stream_socket<_OtherProtocol>&& __rhs)\n+\t: __base(std::move(__rhs)) { }\n+\n+      ~basic_stream_socket() = default;\n+\n+      basic_stream_socket& operator=(const basic_stream_socket&) = delete;\n+\n+      basic_stream_socket& operator=(basic_stream_socket&& __rhs) = default;\n+\n+      template<class _OtherProtocol>\n+\tenable_if_t<is_convertible<_OtherProtocol, _Protocol>::value,\n+\t\t    basic_stream_socket&>\n+\toperator=(basic_stream_socket<_OtherProtocol>&& __rhs)\n+\t{\n+\t  __base::operator=(std::move(__rhs));\n+\t  return *this;\n+\t}\n+\n+      // basic_stream_socket operations:\n+\n+      template<class _MutableBufferSequence>\n+\tsize_t\n+\treceive(const _MutableBufferSequence& __buffers)\n+\t{\n+\t  return receive(__buffers, socket_base::message_flags(),\n+\t\t\t __throw_on_error{\"basic_stream_socket::receive\"});\n+\t}\n+\n+      template<class _MutableBufferSequence>\n+\tsize_t\n+\treceive(const _MutableBufferSequence& __buffers, error_code& __ec)\n+        { return receive(__buffers, socket_base::message_flags(), __ec); }\n+\n+      template<class _MutableBufferSequence>\n+\tsize_t\n+\treceive(const _MutableBufferSequence& __buffers,\n+\t\tsocket_base::message_flags __flags)\n+\t{\n+\t  return receive(__buffers, __flags,\n+\t\t\t __throw_on_error{\"basic_stream_socket::receive\"});\n+\t}\n+\n+      template<class _MutableBufferSequence>\n+\tsize_t\n+\treceive(const _MutableBufferSequence& __buffers,\n+\t\tsocket_base::message_flags __flags, error_code& __ec)\n+\t{\n+\t  if (__buffer_empty(__buffers))\n+\t    {\n+\t      __ec.clear();\n+\t      return 0;\n+\t    }\n+\n+\t  socket_base::__msg_hdr __msg(__buffers);\n+\t  ssize_t __result = ::recvmsg(this->native_handle(), &__msg,\n+\t\t\t\t       static_cast<int>(__flags));\n+\t  if (__result >= 0)\n+\t    {\n+\t      __ec.clear();\n+\t      return __result;\n+\t    }\n+\t  __ec.assign(errno, generic_category());\n+\t  return 0;\n+\t}\n+\n+      template<class _MutableBufferSequence, class _CompletionToken>\n+\t__deduced_t<_CompletionToken, void(error_code, size_t)>\n+\tasync_receive(const _MutableBufferSequence& __buffers,\n+\t\t      _CompletionToken&& __token)\n+\t{\n+\t  return async_receive(__buffers, socket_base::message_flags(),\n+\t\t\t       std::forward<_CompletionToken>(__token));\n+\t}\n+\n+      template<class _MutableBufferSequence, class _CompletionToken>\n+\t__deduced_t<_CompletionToken, void(error_code, size_t)>\n+\tasync_receive(const _MutableBufferSequence& __buffers,\n+\t\t      socket_base::message_flags __flags,\n+\t\t      _CompletionToken&& __token)\n+\t{\n+\t  async_completion<_CompletionToken, void(error_code, size_t)>\n+            __init{__token};\n+\n+          if (__buffer_empty(__buffers))\n+\t    {\n+              auto __ex = net::get_associated_executor(\n+                  __init.completion_handler, this->get_executor());\n+              auto __a = get_associated_allocator(\n+                  __init.completion_handler, std::allocator<void>());\n+              __ex.post(\n+                  [__h=std::move(__init.completion_handler)] () mutable\n+                  { __h(error_code{}, 0); }, __a);\n+              return __init.result.get();\n+\t    }\n+\n+          this->get_executor().context().async_wait(this->native_handle(),\n+\t      socket_base::wait_read,\n+\t      [__h = std::move(__init.completion_handler),\n+               &__buffers, __flags = static_cast<int>(__flags),\n+               __fd = this->native_handle()]\n+              (error_code __ec) mutable {\n+                  if (__ec)\n+                    {\n+                      __h(__ec);\n+                      return;\n+                    }\n+                  socket_base::__msg_hdr __msg(__buffers);\n+                  ssize_t __result = ::recvmsg(__fd, &__msg, __flags);\n+                  if (__result == -1)\n+                    {\n+                      __ec.assign(errno, generic_category());\n+                      __result = 0;\n+                    }\n+                  else\n+                    __ec.clear();\n+\t\t  __h(__ec, __result);\n+\t      });\n+\t  return __init.result.get();\n+\t}\n+\n+      template<class _ConstBufferSequence>\n+\tsize_t\n+\tsend(const _ConstBufferSequence& __buffers)\n+\t{\n+\t  return send(__buffers, socket_base::message_flags(),\n+\t\t      __throw_on_error{\"basic_stream_socket::send\"});\n+\t}\n+\n+      template<class _ConstBufferSequence>\n+\tsize_t\n+\tsend(const _ConstBufferSequence& __buffers, error_code& __ec)\n+\t{ return send(__buffers, socket_base::message_flags(), __ec); }\n+\n+      template<class _ConstBufferSequence>\n+\tsize_t\n+\tsend(const _ConstBufferSequence& __buffers,\n+\t     socket_base::message_flags __flags)\n+\t{\n+\t  return send(__buffers, socket_base::message_flags(),\n+\t\t      __throw_on_error{\"basic_stream_socket::send\"});\n+\t}\n+\n+      template<class _ConstBufferSequence>\n+\tsize_t\n+\tsend(const _ConstBufferSequence& __buffers,\n+\t     socket_base::message_flags __flags, error_code& __ec)\n+\t{\n+\t  if (__buffer_empty(__buffers))\n+\t    {\n+\t      __ec.clear();\n+\t      return 0;\n+\t    }\n+\n+\t  socket_base::__msg_hdr __msg(__buffers);\n+\t  ssize_t __result = ::sendmsg(this->native_handle(), &__msg,\n+\t\t\t\t       static_cast<int>(__flags));\n+\t  if (__result >= 0)\n+\t    {\n+\t      __ec.clear();\n+\t      return __result;\n+\t    }\n+\t  __ec.assign(errno, generic_category());\n+\t  return 0;\n+\t}\n+\n+      template<class _ConstBufferSequence, class _CompletionToken>\n+\t__deduced_t<_CompletionToken, void(error_code, size_t)>\n+\tasync_send(const _ConstBufferSequence& __buffers,\n+\t\t   _CompletionToken&& __token)\n+\t{\n+\t  return async_send(__buffers, socket_base::message_flags(),\n+\t\t\t    std::forward<_CompletionToken>(__token));\n+\t}\n+\n+      template<class _ConstBufferSequence, class _CompletionToken>\n+\t__deduced_t<_CompletionToken, void(error_code, size_t)>\n+\tasync_send(const _ConstBufferSequence& __buffers,\n+\t\t   socket_base::message_flags __flags,\n+\t\t   _CompletionToken&& __token)\n+\t{\n+\t  async_completion<_CompletionToken, void(error_code, size_t)>\n+            __init{__token};\n+\n+          if (__buffer_empty(__buffers))\n+\t    {\n+              auto __ex = net::get_associated_executor(\n+                  __init.completion_handler, this->get_executor());\n+              auto __a = get_associated_allocator(\n+                  __init.completion_handler, std::allocator<void>());\n+              __ex.post(\n+                  [__h=std::move(__init.completion_handler)] () mutable\n+                  { __h(error_code{}, 0); }, __a);\n+              return __init.result.get();\n+\t    }\n+\n+          this->get_executor().context().async_wait(this->native_handle(),\n+\t      socket_base::wait_write,\n+\t      [__h = std::move(__init.completion_handler),\n+               &__buffers, __flags = static_cast<int>(__flags),\n+               __fd = this->native_handle()]\n+              (error_code __ec) mutable {\n+                  if (__ec)\n+                    {\n+                      __h(__ec);\n+                      return;\n+                    }\n+                  socket_base::__msg_hdr __msg(__buffers);\n+                  ssize_t __result = ::sendmsg(__fd, &__msg, __flags);\n+                  if (__result == -1)\n+                    {\n+                      __ec.assign(errno, generic_category());\n+                      __result = 0;\n+                    }\n+                  else\n+                    __ec.clear();\n+\t\t  __h(__ec, __result);\n+\t      });\n+\t  return __init.result.get();\n+\t}\n+\n+      template<class _MutableBufferSequence>\n+\tsize_t\n+\tread_some(const _MutableBufferSequence& __buffers)\n+\t{\n+\t  return receive(__buffers,\n+\t\t\t __throw_on_error{\"basic_stream_socket::read_some\"});\n+\t}\n+\n+      template<class _MutableBufferSequence>\n+\tsize_t\n+\tread_some(const _MutableBufferSequence& __buffers, error_code& __ec)\n+\t{ return receive(__buffers, __ec); }\n+\n+      template<class _MutableBufferSequence, class _CompletionToken>\n+\t__deduced_t<_CompletionToken, void(error_code, size_t)>\n+\tasync_read_some(const _MutableBufferSequence& __buffers,\n+\t\t\t_CompletionToken&& __token)\n+\t{\n+\t  return async_receive(__buffers,\n+\t\t\t       std::forward<_CompletionToken>(__token));\n+\t}\n+\n+      template<class _ConstBufferSequence>\n+\tsize_t\n+\twrite_some(const _ConstBufferSequence& __buffers)\n+\t{\n+\t  return send(__buffers,\n+\t\t      __throw_on_error{\"basic_stream_socket:write_some\"});\n+\t}\n+\n+      template<class _ConstBufferSequence>\n+\tsize_t\n+\twrite_some(const _ConstBufferSequence& __buffers, error_code& __ec)\n+\t{  return send(__buffers, __ec); }\n+\n+      template<class _ConstBufferSequence, class _CompletionToken>\n+\t__deduced_t<_CompletionToken, void(error_code, size_t)>\n+\tasync_write_some(const _ConstBufferSequence& __buffers,\n+\t\t\t      _CompletionToken&& __token)\n+\t{\n+\t  return async_send(__buffers,\n+\t\t\t    std::forward<_CompletionToken>(__token));\n+\t}\n+    };\n+\n+  template<typename _AcceptableProtocol>\n+    class basic_socket_acceptor\n+    : public socket_base, private __basic_socket_impl<_AcceptableProtocol>\n+    {\n+      using __base = __basic_socket_impl<_AcceptableProtocol>;\n+\n+    public:\n+      // types:\n+\n+      typedef io_context::executor_type executor_type;\n+      typedef int native_handle_type;\n+      typedef _AcceptableProtocol protocol_type;\n+      typedef typename protocol_type::endpoint endpoint_type;\n+      typedef typename protocol_type::socket socket_type;\n+\n+      // construct / copy / destroy:\n+\n+      explicit\n+      basic_socket_acceptor(io_context& __ctx)\n+      : __base(__ctx), _M_protocol(endpoint_type{}.protocol()) { }\n+\n+      basic_socket_acceptor(io_context& __ctx,\n+\t\t\t    const protocol_type& __protocol)\n+      : __base(__ctx), _M_protocol(__protocol)\n+      { open(__protocol); }\n+\n+      basic_socket_acceptor(io_context& __ctx, const endpoint_type& __endpoint,\n+\t\t\t    bool __reuse_addr = true)\n+      : basic_socket_acceptor(__ctx, __endpoint.protocol())\n+      {\n+\tif (__reuse_addr)\n+\t  set_option(reuse_address(true));\n+\tbind(__endpoint);\n+\tlisten();\n+      }\n+\n+      basic_socket_acceptor(io_context& __ctx, const protocol_type& __protocol,\n+\t\t\t    const native_handle_type& __native_acceptor)\n+      : basic_socket_acceptor(__ctx, __protocol)\n+      { assign(__protocol, __native_acceptor); }\n+\n+      basic_socket_acceptor(const basic_socket_acceptor&) = delete;\n+\n+      basic_socket_acceptor(basic_socket_acceptor&&) = default;\n+\n+      template<typename _OtherProtocol, typename _Requires\n+\t       = _Require<is_convertible<_OtherProtocol, protocol_type>>>\n+\tbasic_socket_acceptor(basic_socket_acceptor<_OtherProtocol>&& __rhs)\n+\t: __base(std::move(__rhs)) { }\n+\n+      ~basic_socket_acceptor() = default;\n+\n+      basic_socket_acceptor& operator=(const basic_socket_acceptor&) = delete;\n+\n+      basic_socket_acceptor& operator=(basic_socket_acceptor&&) = default;\n+\n+      template<class _OtherProtocol>\n+\tenable_if_t<is_convertible<_OtherProtocol, protocol_type>::value,\n+\t\t    basic_socket_acceptor&>\n+\toperator=(basic_socket_acceptor<_OtherProtocol>&& __rhs)\n+\t{\n+\t  __base::operator=(std::move(__rhs));\n+\t  return *this;\n+\t}\n+\n+      // basic_socket_acceptor operations:\n+\n+      executor_type get_executor() noexcept { return __base::get_executor(); }\n+\n+      native_handle_type\n+      native_handle() noexcept { return __base::native_handle(); }\n+\n+      void\n+      open(const protocol_type& __protocol = protocol_type())\n+      { open(__protocol, __throw_on_error{\"basic_socket_acceptor::open\"}); }\n+\n+      void\n+      open(const protocol_type& __protocol, error_code& __ec)\n+      { __base::open(__protocol, __ec); }\n+\n+      void\n+      assign(const protocol_type& __protocol,\n+\t     const native_handle_type& __native_acceptor)\n+      {\n+\tassign(__protocol, __native_acceptor,\n+\t       __throw_on_error{\"basic_socket_acceptor::assign\"});\n+      }\n+\n+      void\n+      assign(const protocol_type& __protocol,\n+\t     const native_handle_type& __native_acceptor,\n+\t     error_code& __ec)\n+      { __base::assign(__protocol, __native_acceptor, __ec); }\n+\n+      bool\n+      is_open() const noexcept { return __base::is_open(); }\n+\n+      void\n+      close() { close(__throw_on_error{\"basic_socket_acceptor::close\"}); }\n+\n+      void\n+      close(error_code& __ec) { __base::_close(__ec); }\n+\n+      void\n+      cancel() { cancel(__throw_on_error{\"basic_socket_acceptor::cancel\"}); }\n+\n+      void\n+      cancel(error_code& __ec) { __base::cancel(__ec); }\n+\n+      template<typename _SettableSocketOption>\n+\tvoid\n+\tset_option(const _SettableSocketOption& __option)\n+\t{\n+\t  set_option(__option,\n+\t\t     __throw_on_error{\"basic_socket_acceptor::set_option\"});\n+\t}\n+\n+      template<typename _SettableSocketOption>\n+\tvoid\n+\tset_option(const _SettableSocketOption& __option, error_code& __ec)\n+\t{ __base::set_option(__option, __ec); }\n+\n+      template<typename _GettableSocketOption>\n+\tvoid\n+\tget_option(_GettableSocketOption& __option) const\n+\t{\n+\t  get_option(__option,\n+\t\t     __throw_on_error{\"basic_socket_acceptor::get_option\"});\n+\t}\n+\n+      template<typename _GettableSocketOption>\n+\tvoid\n+\tget_option(_GettableSocketOption& __option, error_code& __ec) const\n+\t{ __base::get_option(__option, __ec); }\n+\n+      template<typename _IoControlCommand>\n+\tvoid\n+\tio_control(_IoControlCommand& __command)\n+\t{\n+\t  io_control(__command,\n+\t\t     __throw_on_error{\"basic_socket_acceptor::io_control\"});\n+\t}\n+\n+      template<typename _IoControlCommand>\n+\tvoid\n+\tio_control(_IoControlCommand& __command, error_code& __ec)\n+\t{ __base::io_control(__command, __ec); }\n+\n+      void\n+      non_blocking(bool __mode)\n+      {\n+\tnon_blocking(__mode,\n+\t\t     __throw_on_error{\"basic_socket_acceptor::non_blocking\"});\n+      }\n+\n+      void\n+      non_blocking(bool __mode, error_code& __ec)\n+      { __base::non_blocking(__mode, __ec); }\n+\n+      bool non_blocking() const { return __base::non_blocking(); }\n+\n+      void\n+      native_non_blocking(bool __mode)\n+      {\n+\tnative_non_blocking(__mode, __throw_on_error{\n+\t    \"basic_socket_acceptor::native_non_blocking\"});\n+      }\n+\n+      void\n+      native_non_blocking(bool __mode, error_code& __ec)\n+      { __base::native_non_blocking(__mode, __ec); }\n+\n+      bool\n+      native_non_blocking() const\n+      { return __base::native_non_blocking(); }\n+\n+      void\n+      bind(const endpoint_type& __endpoint)\n+      {\n+\treturn bind(__endpoint,\n+\t\t    __throw_on_error{\"basic_socket_acceptor::bind\"});\n+      }\n+\n+      void\n+      bind(const endpoint_type& __endpoint, error_code& __ec)\n+      { __base::bind(__endpoint, __ec); }\n+\n+      void\n+      listen(int __backlog = max_listen_connections)\n+      {\n+\treturn listen(__backlog,\n+\t\t      __throw_on_error{\"basic_socket_acceptor::listen\"});\n+      }\n+\n+      void listen(int __backlog, error_code& __ec)\n+      {\n+\tif (::listen(native_handle(), __backlog) == -1)\n+\t  __ec.assign(errno, generic_category());\n+\telse\n+\t  __ec.clear();\n+      }\n+\n+      endpoint_type\n+      local_endpoint() const\n+      {\n+\treturn local_endpoint(\n+\t    __throw_on_error{\"basic_socket_acceptor::local_endpoint\"});\n+      }\n+\n+      endpoint_type\n+      local_endpoint(error_code& __ec) const\n+      { return __base::local_endpoint(__ec); }\n+\n+      void\n+      enable_connection_aborted(bool __mode)\n+      { __base::_M_bits.enable_connection_aborted = __mode; }\n+\n+      bool\n+      enable_connection_aborted() const\n+      { return __base::_M_bits.enable_connection_aborted; }\n+\n+      socket_type\n+      accept()\n+      { return accept(__throw_on_error{\"basic_socket_acceptor::accept\"}); }\n+\n+      socket_type\n+      accept(error_code& __ec)\n+      { return accept(get_executor().context(), __ec); }\n+\n+      socket_type accept(io_context& __ctx)\n+      {\n+\treturn accept(__ctx,\n+\t\t      __throw_on_error{\"basic_socket_acceptor::accept\"});\n+      }\n+\n+      socket_type\n+      accept(io_context& __ctx, error_code& __ec)\n+      {\n+\tdo\n+\t  {\n+\t    int __h = ::accept(native_handle(), nullptr, 0);\n+\t    if (__h != -1)\n+\t      {\n+\t\t__ec.clear();\n+\t\treturn socket_type{__ctx, _M_protocol, __h};\n+\t      }\n+\t  } while (errno == ECONNABORTED && enable_connection_aborted());\n+\t__ec.assign(errno, generic_category());\n+\treturn socket_type{__ctx};\n+      }\n+\n+      template<class _CompletionToken>\n+\t__deduced_t<_CompletionToken, void(error_code, socket_type)>\n+\tasync_accept(_CompletionToken&& __token)\n+\t{\n+\t  return async_accept(get_executor().context(),\n+\t\t\t      std::forward<_CompletionToken>(__token));\n+\t}\n+\n+      template<class _CompletionToken>\n+\t__deduced_t<_CompletionToken, void(error_code, socket_type)>\n+\tasync_accept(io_context& __ctx, _CompletionToken&& __token)\n+\t{\n+          async_completion<_CompletionToken, void(error_code, socket_type)>\n+            __init{__token};\n+\n+\t  __ctx.get_executor().context().async_wait(native_handle(),\n+\t      socket_base::wait_read,\n+\t      [__h = std::move(__init.completion_handler),\n+               __connabort = enable_connection_aborted(),\n+               __fd = native_handle(),\n+               __protocol = _M_protocol,\n+               &__ctx\n+              ]\n+              (error_code __ec) mutable {\n+                  if (__ec)\n+                    {\n+                      __h(__ec, socket_type(__ctx));\n+                      return;\n+                    }\n+                  do\n+                    {\n+                      int __newfd = ::accept(__fd, nullptr, 0);\n+                      if (__newfd != -1)\n+                        {\n+                          __ec.clear();\n+                          __h(__ec, socket_type{__ctx, __protocol, __newfd});\n+                          return;\n+                        }\n+                    } while (errno == ECONNABORTED && __connabort);\n+                  __ec.assign(errno, generic_category());\n+                  __h(__ec, socket_type(__ctx));\n+\t      });\n+\t  return __init.result.get();\n+\t}\n+\n+      socket_type\n+      accept(endpoint_type& __endpoint)\n+      {\n+\treturn accept(get_executor().context(), __endpoint,\n+\t\t      __throw_on_error{\"basic_socket_acceptor::accept\"});\n+      }\n+\n+      socket_type\n+      accept(endpoint_type& __endpoint, error_code& __ec)\n+      { return accept(get_executor().context(), __endpoint, __ec); }\n+\n+      socket_type\n+      accept(io_context& __ctx, endpoint_type& __endpoint)\n+      {\n+\treturn accept(__ctx, __endpoint,\n+\t\t      __throw_on_error{\"basic_socket_acceptor::accept\"});\n+      }\n+\n+      socket_type\n+      accept(io_context& __ctx, endpoint_type& __endpoint, error_code& __ec)\n+      {\n+\tdo\n+\t  {\n+\t    socklen_t __len = __endpoint.capacity();\n+\t    int __h = ::accept(native_handle(), (sockaddr*)__endpoint.data(),\n+\t\t\t       &__len);\n+\t    if (__h != -1)\n+\t      {\n+\t\t__endpoint.resize(__len);\n+\t\treturn socket_type{__ctx, _M_protocol, __h};\n+\t      }\n+\t  } while (errno == ECONNABORTED && enable_connection_aborted());\n+\t__ec.assign(errno, generic_category());\n+\treturn socket_type{__ctx};\n+      }\n+\n+      template<class _CompletionToken>\n+\t__deduced_t<_CompletionToken, void(error_code, socket_type)>\n+\tasync_accept(endpoint_type& __endpoint,\n+\t\t\t     _CompletionToken&& __token)\n+\t{\n+\t  return async_accept(get_executor().context(), __endpoint,\n+\t\t\t      std::forward<_CompletionToken>(__token));\n+\t}\n+\n+      template<class _CompletionToken>\n+\t__deduced_t<_CompletionToken, void(error_code, socket_type)>\n+\tasync_accept(io_context& __ctx, endpoint_type& __endpoint,\n+\t\t\t     _CompletionToken&& __token)\n+        {\n+          async_completion<_CompletionToken, void(error_code, socket_type)>\n+            __init{__token};\n+\n+\t  __ctx.get_executor().context().async_wait(native_handle(),\n+\t      socket_base::wait_read,\n+\t      [__h = std::move(__init.completion_handler),\n+              __ep = std::move(__endpoint),\n+               __connabort = enable_connection_aborted(),\n+               __fd = native_handle(),\n+               &__ctx\n+              ]\n+              (error_code __ec) mutable {\n+                  if (__ec)\n+                    {\n+                      __h(__ec, socket_type(__ctx));\n+                      return;\n+                    }\n+                  do\n+                    {\n+                      socklen_t __len = __ep.capacity();\n+                      int __newfd = ::accept(__fd, __ep.data, &__len);\n+                      if (__newfd != -1)\n+                        {\n+                          __ep.resize(__len);\n+                          auto __protocol = __ep.protocol();\n+                          __ec.clear();\n+                          __h(__ec, socket_type{__ctx, __protocol, __newfd});\n+                          return;\n+                        }\n+                    } while (errno == ECONNABORTED && __connabort);\n+                  __ec.assign(errno, generic_category());\n+                  __h(__ec, socket_type(__ctx));\n+\t      });\n+\t  return __init.result.get();\n+        }\n+\n+      void\n+      wait(wait_type __w)\n+      { wait(__w, __throw_on_error{\"basic_socket_acceptor::wait\"}); }\n+\n+      void\n+      wait(wait_type __w, error_code& __ec)\n+      {\n+\t::pollfd __fds;\n+\t__fds.fd = native_handle();\n+\t__fds.events = __w; // __w | POLLIN;\n+\tif (::poll(&__fds, 1, -1) == -1)\n+\t  __ec.assign(errno, generic_category());\n+\telse\n+\t  __ec.clear();\n+      }\n+\n+      template<class _CompletionToken>\n+\t__deduced_t<_CompletionToken, void(error_code)>\n+\tasync_wait(wait_type __w, _CompletionToken&& __token)\n+        {\n+\t  async_completion<_CompletionToken, void(error_code)> __init{__token};\n+\t  get_executor().context().async_wait( native_handle(),\n+\t      static_cast<int>(__w),\n+\t      [__h = std::move(__init.completion_handler)]\n+              (error_code __ec) mutable {\n+\t\t  __h(__ec);\n+\t      });\n+\t  return __init.result.get();\n+\t}\n+\n+    private:\n+      protocol_type _M_protocol;\n+    };\n+\n+  // @}\n+\n+  /** @brief Socket streams\n+   * @{\n+   */\n+\n+  template<typename _Protocol, typename _Clock, typename _WaitTraits>\n+    class basic_socket_streambuf : public basic_streambuf<char>\n+    {\n+    public:\n+      // types:\n+\n+      typedef _Protocol protocol_type;\n+      typedef typename protocol_type::endpoint endpoint_type;\n+      typedef _Clock clock_type;\n+      typedef typename clock_type::time_point time_point;\n+      typedef typename clock_type::duration duration;\n+      typedef _WaitTraits wait_traits_type;\n+\n+      // construct / copy / destroy:\n+\n+      basic_socket_streambuf() : _M_socket(_S_ctx()) { }\n+\n+      explicit\n+      basic_socket_streambuf(basic_stream_socket<protocol_type> __s)\n+      : _M_socket(std::move(__s)) { }\n+\n+      basic_socket_streambuf(const basic_socket_streambuf&) = delete;\n+\n+      basic_socket_streambuf(basic_socket_streambuf&& __rhs); // TODO\n+\n+\n+      virtual ~basic_socket_streambuf(); // TODO\n+\n+      basic_socket_streambuf& operator=(const basic_socket_streambuf&) = delete;\n+\n+      basic_socket_streambuf& operator=(basic_socket_streambuf&& __rhs); // TODO\n+\n+      // members:\n+\n+      basic_socket_streambuf* connect(const endpoint_type& __e); // TODO\n+\n+      template<typename... _Args>\n+\tbasic_socket_streambuf* connect(_Args&&... ); // TODO\n+\n+      basic_socket_streambuf* close(); // TODO\n+\n+      basic_socket<protocol_type>& socket() { return _M_socket; }\n+      error_code error() const { return _M_ec; }\n+\n+      time_point expiry() const { return _M_expiry; }\n+\n+      void\n+      expires_at(const time_point& __t)\n+      { _M_expiry = __t; }\n+\n+      void\n+      expires_after(const duration& __d)\n+      { expires_at(clock_type::now() + __d); }\n+\n+    protected:\n+      // overridden virtual functions: // TODO\n+      virtual int_type underflow() override;\n+      virtual int_type pbackfail(int_type __c = traits_type::eof()) override;\n+      virtual int_type overflow(int_type __c = traits_type::eof()) override;\n+      virtual int sync() override;\n+      virtual streambuf* setbuf(char_type* __s, streamsize __n) override;\n+\n+    private:\n+      static io_context&\n+      _S_ctx()\n+      {\n+\tstatic io_context __ctx;\n+\treturn __ctx;\n+      }\n+\n+      basic_stream_socket<protocol_type> _M_socket;\n+      error_code _M_ec;\n+      time_point _M_expiry{ time_point::max() };\n+    };\n+\n+  template<typename _Protocol, class _Clock, typename _WaitTraits>\n+    class basic_socket_iostream : public basic_iostream<char>\n+    {\n+      using __streambuf_type\n+\t= basic_socket_streambuf<_Protocol, _Clock, _WaitTraits>;\n+\n+    public:\n+      // types:\n+\n+      typedef _Protocol protocol_type;\n+      typedef typename protocol_type::endpoint endpoint_type;\n+      typedef _Clock clock_type;\n+      typedef typename clock_type::time_point time_point;\n+      typedef typename clock_type::duration duration;\n+      typedef _WaitTraits wait_traits_type;\n+\n+      // construct / copy / destroy:\n+\n+      // TODO base-from-member ?\n+      basic_socket_iostream() : basic_iostream(nullptr), _M_sb()\n+      {\n+\tthis->init(std::addressof(_M_sb));\n+\tthis->setf(std::ios::unitbuf);\n+      }\n+\n+      explicit\n+      basic_socket_iostream(basic_stream_socket<protocol_type> __s)\n+      : basic_iostream(nullptr), _M_sb(std::move(__s))\n+      {\n+\tthis->init(std::addressof(_M_sb));\n+\tthis->setf(std::ios::unitbuf);\n+      }\n+\n+      basic_socket_iostream(const basic_socket_iostream&) = delete;\n+\n+      basic_socket_iostream(basic_socket_iostream&& __rhs)\n+      : basic_iostream(nullptr), _M_sb(std::move(__rhs._M_sb))\n+\t// XXX ???     ^^^^^^^\n+      {\n+\t// XXX ??? this->init(std::addressof(_M_sb));\n+\tthis->set_rbduf(std::addressof(_M_sb));\n+      }\n+\n+      template<typename... _Args>\n+\texplicit\n+\tbasic_socket_iostream(_Args&&... __args)\n+\t: basic_iostream(nullptr), _M_sb()\n+\t{\n+\t  this->init(std::addressof(_M_sb));\n+\t  this->setf(std::ios::unitbuf);\n+\t  connect(forward<_Args>(__args)...);\n+\t}\n+\n+      basic_socket_iostream& operator=(const basic_socket_iostream&) = delete;\n+\n+      basic_socket_iostream& operator=(basic_socket_iostream&& __rhs); // TODO\n+\n+      // members:\n+\n+      template<typename... _Args>\n+\tvoid\n+\tconnect(_Args&&... __args)\n+\t{\n+\t  if (rdbuf()->connect(forward<_Args>(__args)...) == nullptr)\n+\t    this->setstate(failbit);\n+\t}\n+\n+      void\n+      close()\n+      {\n+\tif (rdbuf()->close() == nullptr)\n+\t  this->setstate(failbit);\n+      }\n+\n+      basic_socket_streambuf<protocol_type, clock_type, wait_traits_type>*\n+      rdbuf() const\n+      { return const_cast<__streambuf_type*>(std::addressof(_M_sb)); }\n+\n+      basic_socket<protocol_type>& socket() { return rdbuf()->socket(); }\n+      error_code error() const { return rdbuf()->error(); }\n+\n+      time_point expiry() const { return rdbuf()->expiry(); }\n+      void expires_at(const time_point& __t) { rdbuf()->expires_at(__t); }\n+      void expires_after(const duration& __d) { rdbuf()->expires_after(__d); }\n+\n+    private:\n+      __streambuf_type _M_sb;\n+    };\n+\n+  // @}\n+\n+  /** @brief synchronous connect operations\n+   * @{\n+   */\n+\n+  template<typename _Protocol, typename _EndpointSequence,\n+\t   typename _ConnectCondition>\n+    inline typename _Protocol::endpoint\n+    connect(basic_socket<_Protocol>& __s,\n+\t    const _EndpointSequence& __endpoints,\n+\t    _ConnectCondition __c, error_code& __ec)\n+    {\n+      __ec.clear();\n+      bool __found = false;\n+      for (auto& __ep : __endpoints)\n+\t{\n+\t  if (__c(__ec, __ep))\n+\t    {\n+\t      __found = true;\n+\t      __s.close(__ec);\n+\t      if (!__ec)\n+\t\t__s.open(__ep.protocol(), __ec);\n+\t      if (!__ec)\n+\t\t__s.connect(__ep, __ec);\n+\t      if (!__ec)\n+\t\treturn __ep;\n+\t    }\n+\t}\n+      if (!__found)\n+\t__ec = socket_errc::not_found;\n+      return typename _Protocol::endpoint{};\n+    }\n+\n+  template<typename _Protocol, typename _InputIterator,\n+\t   typename _ConnectCondition>\n+    inline _InputIterator\n+    connect(basic_socket<_Protocol>& __s,\n+\t    _InputIterator __first, _InputIterator __last,\n+\t    _ConnectCondition __c, error_code& __ec)\n+    {\n+      __ec.clear();\n+      bool __found = false;\n+      for (auto __i = __first; __i != __last; ++__i)\n+\t{\n+\t  if (__c(__ec, *__i))\n+\t    {\n+\t      __found = true;\n+\t      __s.close(__ec);\n+\t      if (!__ec)\n+\t\t__s.open(typename _Protocol::endpoint(*__i).protocol(), __ec);\n+\t      if (!__ec)\n+\t\t__s.connect(*__i, __ec);\n+\t      if (!__ec)\n+\t\treturn __i;\n+\t    }\n+\t}\n+      if (!__found)\n+\t__ec = socket_errc::not_found;\n+      return __last;\n+    }\n+\n+  template<typename _Protocol, typename _EndpointSequence,\n+\t   typename _ConnectCondition>\n+    inline typename _Protocol::endpoint\n+    connect(basic_socket<_Protocol>& __s,\n+\t    const _EndpointSequence& __endpoints,\n+\t    _ConnectCondition __c)\n+    {\n+      return net::connect(__s, __endpoints, __c, __throw_on_error{\"connect\"});\n+    }\n+\n+  template<typename _Protocol, typename _InputIterator,\n+\t   typename _ConnectCondition>\n+    inline _InputIterator\n+    connect(basic_socket<_Protocol>& __s,\n+\t    _InputIterator __first, _InputIterator __last,\n+\t    _ConnectCondition __c)\n+    {\n+      return net::connect(__s, __first, __last, __c,\n+\t\t\t  __throw_on_error{\"connect\"});\n+    }\n+\n+  template<typename _Protocol, typename _EndpointSequence>\n+    inline typename _Protocol::endpoint\n+    connect(basic_socket<_Protocol>& __s,\n+\t    const _EndpointSequence& __endpoints)\n+    {\n+      return net::connect(__s, __endpoints, [](auto, auto){ return true; },\n+\t\t\t  __throw_on_error{\"connect\"});\n+    }\n+\n+  template<typename _Protocol, typename _EndpointSequence>\n+    inline typename _Protocol::endpoint\n+    connect(basic_socket<_Protocol>& __s,\n+\t    const _EndpointSequence& __endpoints,\n+\t    error_code& __ec)\n+    {\n+      return net::connect(__s, __endpoints, [](auto, auto){ return true; },\n+\t\t\t  __ec);\n+    }\n+\n+  template<typename _Protocol, typename _InputIterator>\n+    inline _InputIterator\n+    connect(basic_socket<_Protocol>& __s,\n+\t    _InputIterator __first, _InputIterator __last)\n+    {\n+      return net::connect(__s, __first, __last, [](auto, auto){ return true; },\n+\t\t\t  __throw_on_error{\"connect\"});\n+    }\n+\n+  template<typename _Protocol, typename _InputIterator>\n+    inline _InputIterator\n+    connect(basic_socket<_Protocol>& __s,\n+\t    _InputIterator __first, _InputIterator __last,\n+\t    error_code& __ec)\n+    {\n+      return net::connect(__s, __first, __last, [](auto, auto){ return true; },\n+\t\t\t  __ec);\n+    }\n+\n+  // @}\n+\n+  /** @brief asynchronous connect operations\n+   * @{\n+   */\n+\n+  template<typename _Protocol, typename _EndpointSequence,\n+\t   typename _ConnectCondition, typename _CompletionToken>\n+    inline\n+    __deduced_t<_CompletionToken,\n+\t\tvoid(error_code, typename _Protocol::endpoint)>\n+    async_connect(basic_socket<_Protocol>& __s,\n+\t\t  const _EndpointSequence& __endpoints,\n+\t\t  _ConnectCondition __c, _CompletionToken&& __token); // TODO\n+\n+  template<typename _Protocol, typename _EndpointSequence,\n+\t   typename _CompletionToken>\n+    inline\n+    __deduced_t<_CompletionToken,\n+\t\tvoid(error_code, typename _Protocol::endpoint)>\n+    async_connect(basic_socket<_Protocol>& __s,\n+\t\t  const _EndpointSequence& __endpoints,\n+\t\t  _CompletionToken&& __token)\n+    {\n+      return net::async_connect(__s, __endpoints,\n+\t\t\t\t[](auto, auto){ return true; },\n+\t\t\t\tforward<_CompletionToken>(__token));\n+    }\n+\n+  template<typename _Protocol, typename _InputIterator,\n+\t   typename _ConnectCondition, typename _CompletionToken>\n+    inline\n+    __deduced_t<_CompletionToken, void(error_code, _InputIterator)>\n+    async_connect(basic_socket<_Protocol>& __s,\n+\t\t  _InputIterator __first, _InputIterator __last,\n+\t\t  _ConnectCondition __c, _CompletionToken&& __token); // TODO\n+\n+  template<typename _Protocol, typename _InputIterator,\n+\t   typename _CompletionToken>\n+    inline\n+    __deduced_t<_CompletionToken, void(error_code, _InputIterator)>\n+    async_connect(basic_socket<_Protocol>& __s,\n+\t\t  _InputIterator __first, _InputIterator __last,\n+\t\t  _CompletionToken&& __token)\n+    {\n+      return net::async_connect(__s, __first, __last,\n+\t\t\t\t[](auto, auto){ return true; },\n+\t\t\t\tforward<_CompletionToken>(__token));\n+    }\n+\n+  // @}\n+\n+#endif  // _GLIBCXX_HAVE_UNISTD_H\n+\n+  // @}\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace v1\n+} // namespace net\n+} // namespace experimental\n+\n+  template<>\n+    struct is_error_code_enum<experimental::net::v1::socket_errc>\n+    : public true_type {};\n+\n+} // namespace std\n+\n+#endif // C++14\n+\n+#endif // _GLIBCXX_EXPERIMENTAL_SOCKET"}, {"sha": "3ec365944da7685516e72388a3c070670714a535", "filename": "libstdc++-v3/include/experimental/timer", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ftimer", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ftimer", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ftimer?ref=e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "patch": "@@ -0,0 +1,208 @@\n+// <experimental/timer> -*- C++ -*-\n+\n+// Copyright (C) 2015-2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file experimental/timer\n+ *  This is a TS C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_EXPERIMENTAL_TIMER\n+#define _GLIBCXX_EXPERIMENTAL_TIMER 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus >= 201402L\n+\n+#include <chrono>\n+#include <system_error>\n+#include <thread>\n+#include <experimental/netfwd>\n+#include <experimental/io_context>\n+#include <experimental/bits/net.h>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+namespace experimental\n+{\n+namespace net\n+{\n+inline namespace v1\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /**\n+   * @ingroup networking\n+   * @{\n+   */\n+\n+  template<typename _Clock>\n+    struct wait_traits\n+    {\n+      static typename _Clock::duration\n+      to_wait_duration(const typename _Clock::duration& __d)\n+      { return __d; }\n+\n+      static typename _Clock::duration\n+      to_wait_duration(const typename _Clock::time_point& __t)\n+      {\n+\tauto __now = _Clock::now();\n+\tauto __diff = __t - __now;\n+\tif (__diff > _Clock::duration::max())\n+\t  return _Clock::duration::max();\n+\tif (__diff < _Clock::duration::min())\n+\t  return _Clock::duration::min();\n+\treturn __diff;\n+      }\n+    };\n+\n+  template<typename _Clock, typename _WaitTraits>\n+    class basic_waitable_timer\n+    {\n+    public:\n+      // types:\n+\n+      typedef io_context::executor_type executor_type;\n+      typedef _Clock clock_type;\n+      typedef typename clock_type::duration duration;\n+      typedef typename clock_type::time_point time_point;\n+      typedef _WaitTraits traits_type;\n+\n+      // construct / copy / destroy:\n+\n+      explicit\n+      basic_waitable_timer(io_context& __ctx)\n+      : _M_ex(__ctx.get_executor()), _M_expiry()\n+      { }\n+\n+      basic_waitable_timer(io_context& __ctx, const time_point& __t)\n+      : _M_ex(__ctx.get_executor()), _M_expiry(__t)\n+      { }\n+\n+      basic_waitable_timer(io_context& __ctx, const duration& __d)\n+      : _M_ex(__ctx.get_executor()), _M_expiry(_Clock::now() + __d)\n+      { }\n+\n+      basic_waitable_timer(const basic_waitable_timer&) = delete;\n+\n+      basic_waitable_timer(basic_waitable_timer&& __rhs)\n+      : _M_ex(std::move(__rhs._M_ex)), _M_expiry(__rhs._M_expiry)\n+      {\n+\t_M_key.swap(__rhs._M_key);\n+\t__rhs._M_expiry = time_point{};\n+      }\n+\n+      ~basic_waitable_timer() { cancel(); }\n+\n+      basic_waitable_timer& operator=(const basic_waitable_timer&) = delete;\n+\n+      basic_waitable_timer&\n+      operator=(basic_waitable_timer&& __rhs)\n+      {\n+\tif (this == std::addressof(__rhs))\n+\t  return *this;\n+\tcancel();\n+\t_M_ex = std::move(__rhs._M_ex);\n+\t_M_expiry = __rhs._M_expiry;\n+\t__rhs._M_expiry = time_point{};\n+\t_M_key.swap(__rhs._M_key);\n+\treturn *this;\n+      }\n+\n+      // basic_waitable_timer operations:\n+\n+      executor_type get_executor() noexcept { return _M_ex; }\n+\n+      size_t cancel() { return _M_ex.context().cancel(*this); }\n+      size_t cancel_one() { return _M_ex.context().cancel_one(*this); }\n+\n+      time_point expiry() const { return _M_expiry; }\n+\n+      size_t expires_at(const time_point& __t)\n+      {\n+\tsize_t __cancelled = cancel();\n+\t_M_expiry = __t;\n+\treturn __cancelled;\n+      }\n+\n+      size_t expires_after(const duration& __d)\n+      { return expires_at(_Clock::now() + __d); }\n+\n+      void wait();\n+      void wait(error_code& __ec);\n+\n+      template<typename _CompletionToken>\n+\t__deduced_t<_CompletionToken, void(error_code)>\n+\tasync_wait(_CompletionToken&& __token)\n+\t{\n+\t  async_completion<_CompletionToken, void(error_code)> __init(__token);\n+\t  _M_ex.context().async_wait(*this,\n+\t\t\t\t     std::move(__init.completion_handler));\n+\t  return __init.result.get();\n+\t}\n+\n+    private:\n+      executor_type _M_ex;\n+      time_point _M_expiry;\n+\n+      struct _Key { };  // TODO move _M_expiry into here?\n+      unique_ptr<_Key> _M_key{new _Key};\n+\n+      friend class io_context;\n+    };\n+\n+  typedef basic_waitable_timer<chrono::system_clock> system_timer;\n+  typedef basic_waitable_timer<chrono::steady_clock> steady_timer;\n+  typedef basic_waitable_timer<chrono::high_resolution_clock>\n+    high_resolution_timer;\n+\n+  template<typename _Clock, typename _WaitTraits>\n+    void\n+    basic_waitable_timer<_Clock, _WaitTraits>::wait()\n+    {\n+      _M_ex.dispatch([this] {\n+\t  while (clock_type::now() < _M_expiry)\n+\t    this_thread::sleep_for(traits_type::to_wait_duration(_M_expiry));\n+      }, allocator<void>{});\n+    }\n+\n+  template<typename _Clock, typename _WaitTraits>\n+    void\n+    basic_waitable_timer<_Clock, _WaitTraits>::wait(error_code&)\n+    {\n+      _M_ex.dispatch([this] {\n+\t  while (clock_type::now() < _M_expiry)\n+\t    this_thread::sleep_for(traits_type::to_wait_duration(_M_expiry));\n+      }, allocator<void>{});\n+    }\n+\n+  /// @}\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace v1\n+} // namespace net\n+} // namespace experimental\n+} // namespace std\n+\n+#endif // C++14\n+\n+#endif // _GLIBCXX_EXPERIMENTAL_TIMER"}, {"sha": "7a894a9053003a9c61a0e228affbc103b18ac945", "filename": "libstdc++-v3/testsuite/experimental/net/buffer/arithmetic.cc", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fbuffer%2Farithmetic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fbuffer%2Farithmetic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fbuffer%2Farithmetic.cc?ref=e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "patch": "@@ -0,0 +1,107 @@\n+// Copyright (C) 2015-2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++14\" }\n+\n+#include <experimental/buffer>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::net::mutable_buffer;\n+using std::experimental::net::const_buffer;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = false;\n+  char c[4];\n+\n+  mutable_buffer mb;\n+  mb = mb + 0;\n+  VERIFY( mb.data() == nullptr );\n+  VERIFY( mb.size() == 0 );\n+\n+  mb = 0 + mb;\n+  VERIFY( mb.data() == nullptr );\n+  VERIFY( mb.size() == 0 );\n+\n+  mb = mutable_buffer(c, sizeof(c));\n+  mb = mb + 1;\n+  VERIFY( mb.data() == c+1 );\n+  VERIFY( mb.size() == 3 );\n+\n+  mb = mb + 2;\n+  VERIFY( mb.data() == c+3 );\n+  VERIFY( mb.size() == 1 );\n+\n+  mb = mb + 2;\n+  VERIFY( mb.data() == c+4 );\n+  VERIFY( mb.size() == 0 );\n+\n+  mb = mutable_buffer(c, sizeof(c));\n+  mb = 3 + mb;\n+  VERIFY( mb.data() == c+3 );\n+  VERIFY( mb.size() == 1 );\n+\n+  mb = 2 + mb;\n+  VERIFY( mb.data() == c+4 );\n+  VERIFY( mb.size() == 0 );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = false;\n+  char c[4];\n+\n+  const_buffer cb;\n+  cb = cb + 0;\n+  VERIFY( cb.data() == nullptr );\n+  VERIFY( cb.size() == 0 );\n+\n+  cb = 0 + cb;\n+  VERIFY( cb.data() == nullptr );\n+  VERIFY( cb.size() == 0 );\n+\n+  cb = const_buffer(c, sizeof(c));\n+  cb = cb + 1;\n+  VERIFY( cb.data() == c+1 );\n+  VERIFY( cb.size() == 3 );\n+\n+  cb = cb + 2;\n+  VERIFY( cb.data() == c+3 );\n+  VERIFY( cb.size() == 1 );\n+\n+  cb = cb + 2;\n+  VERIFY( cb.data() == c+4 );\n+  VERIFY( cb.size() == 0 );\n+\n+  cb = const_buffer(c, sizeof(c));\n+  cb = 3 + cb;\n+  VERIFY( cb.data() == c+3 );\n+  VERIFY( cb.size() == 1 );\n+\n+  cb = 2 + cb;\n+  VERIFY( cb.data() == c+4 );\n+  VERIFY( cb.size() == 0 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "d61f05dc897c90b52793fe41da72a591dabb74a2", "filename": "libstdc++-v3/testsuite/experimental/net/buffer/const.cc", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fbuffer%2Fconst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fbuffer%2Fconst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fbuffer%2Fconst.cc?ref=e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "patch": "@@ -0,0 +1,74 @@\n+// Copyright (C) 2015-2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++14\" }\n+\n+#include <experimental/buffer>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::net::const_buffer;\n+using std::experimental::net::mutable_buffer;\n+\n+void\n+test01()\n+{\n+  using B = const_buffer;\n+  const B b;\n+\n+  static_assert( std::is_nothrow_default_constructible<B>::value,\n+      \"const_mutable is nothrow default constructible\" );\n+  static_assert( std::is_copy_assignable<B>::value,\n+      \"const_mutable is copy assignable\" );\n+  static_assert( std::is_nothrow_constructible<B, const void*, size_t>::value,\n+      \"const_mutable is nothrow constructible from pointer and length\" );\n+  static_assert( std::is_nothrow_constructible<B, mutable_buffer>::value,\n+      \"const_mutable is nothrow constructible from mutable_buffer\" );\n+  static_assert( std::is_same<decltype(b.data()), const void*>::value,\n+      \"data() return const void*\" );\n+  static_assert( noexcept(b.data()),\n+      \"data() is nothrow\" );\n+  static_assert( std::is_same<decltype(b.size()), size_t>::value,\n+      \"size() return size_t\" );\n+  static_assert( noexcept(b.size()),\n+      \"size() is nothrow\" );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = false;\n+  char c[4];\n+\n+  const_buffer b;\n+  VERIFY( b.data() == nullptr );\n+  VERIFY( b.size() == 0 );\n+\n+  b = const_buffer(c, sizeof(c));\n+  VERIFY( b.data() == c );\n+  VERIFY( b.size() == sizeof(c) );\n+\n+  b = const_buffer{};\n+  VERIFY( b.data() == nullptr );\n+  VERIFY( b.size() == 0 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "c89d79dbde27939df659e63471cab7acdfb23168", "filename": "libstdc++-v3/testsuite/experimental/net/buffer/creation.cc", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fbuffer%2Fcreation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fbuffer%2Fcreation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fbuffer%2Fcreation.cc?ref=e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "patch": "@@ -0,0 +1,172 @@\n+// Copyright (C) 2015-2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++14\" }\n+\n+#include <experimental/buffer>\n+#include <testsuite_hooks.h>\n+\n+namespace net = std::experimental::net;\n+\n+template<typename T>\n+bool is_mutable(const T&)\n+{ return std::is_same<T, net::mutable_buffer>::value; }\n+\n+template<typename T>\n+bool is_const(const T&)\n+{ return std::is_same<T, net::const_buffer>::value; }\n+\n+void\n+test01()\n+{\n+  bool test = false;\n+\n+  auto b1 = net::buffer((void*)&test, sizeof(test));\n+  VERIFY( is_mutable(b1) );\n+  VERIFY( b1.data() == &test );\n+  VERIFY( b1.size() == sizeof(test) );\n+\n+  auto b2 = net::buffer((const void*)&test, sizeof(test));\n+  VERIFY( is_const(b2) );\n+  VERIFY( b2.data() == &test );\n+  VERIFY( b1.size() == sizeof(test) );\n+\n+  auto b3 = net::buffer(b1);\n+  VERIFY( is_mutable(b3) );\n+  VERIFY( b3.data() == b1.data() );\n+  VERIFY( b3.size() == b1.size() );\n+\n+  auto b4 = net::buffer(b2);\n+  VERIFY( is_const(b4) );\n+  VERIFY( b4.data() == b2.data() );\n+  VERIFY( b4.size() == b2.size() );\n+\n+  auto b5 = net::buffer(b1, 0);\n+  VERIFY( is_mutable(b5) );\n+  VERIFY( b5.data() == b1.data() );\n+  VERIFY( b5.size() == 0 );\n+\n+  auto b6 = net::buffer(b2, 0);\n+  VERIFY( is_const(b6) );\n+  VERIFY( b6.data() == b2.data() );\n+  VERIFY( b6.size() == 0 );\n+\n+  int a7[7];\n+  auto b7 = net::buffer(a7);\n+  VERIFY( is_mutable(b7) );\n+  VERIFY( b7.data() == a7 );\n+  VERIFY( b7.size() == sizeof(a7) );\n+\n+  auto b7x = net::buffer(a7, 2);\n+  VERIFY( is_mutable(b7x) );\n+  VERIFY( b7x.data() == a7 );\n+  VERIFY( b7x.size() == sizeof(a7[0]) * 2 );\n+\n+  const short a8[8] = { };\n+  auto b8 = net::buffer(a8);\n+  VERIFY( is_const(b8) );\n+  VERIFY( b8.data() == a8 );\n+  VERIFY( b8.size() == sizeof(a8) );\n+\n+  auto b8x = net::buffer(a8, 3);\n+  VERIFY( is_const(b8x) );\n+  VERIFY( b8x.data() == a8 );\n+  VERIFY( b8x.size() == sizeof(a8[0]) * 3 );\n+\n+  std::array<short, 9> a9;\n+  auto b9 = net::buffer(a9);\n+  VERIFY( is_mutable(b9) );\n+  VERIFY( b9.data() == a9.data() );\n+  VERIFY( b9.size() == sizeof(a9) );\n+\n+  auto b9x = net::buffer(a9, 4);\n+  VERIFY( is_mutable(b9x) );\n+  VERIFY( b9x.data() == a9.data() );\n+  VERIFY( b9x.size() == sizeof(a9[0]) * 4 );\n+\n+  const std::array<long long, 10> a10{};\n+  auto b10 = net::buffer(a10);\n+  VERIFY( is_const(b10) );\n+  VERIFY( b10.data() == a10.data() );\n+  VERIFY( b10.size() == sizeof(a10) );\n+\n+  auto b10x = net::buffer(a10, 5);\n+  VERIFY( is_const(b10x) );\n+  VERIFY( b10x.data() == a10.data() );\n+  VERIFY( b10x.size() == sizeof(a10[0]) * 5 );\n+\n+  std::array<const int, 11> a11{};\n+  auto b11 = net::buffer(a11);\n+  VERIFY( is_const(b11) );\n+  VERIFY( b11.data() == a11.data() );\n+  VERIFY( b11.size() == sizeof(a11) );\n+\n+  auto b11x = net::buffer(a11, 6);\n+  VERIFY( is_const(b11x) );\n+  VERIFY( b11x.data() == a11.data() );\n+  VERIFY( b11x.size() == sizeof(a11[0]) * 6 );\n+\n+  std::vector<short> a12(12);\n+  auto b12 = net::buffer(a12);\n+  VERIFY( is_mutable(b12) );\n+  VERIFY( b12.data() == a12.data() );\n+  VERIFY( b12.size() == sizeof(a12[0]) * a12.size() );\n+\n+  auto b12x = net::buffer(a12, 7);\n+  VERIFY( is_mutable(b12x) );\n+  VERIFY( b12x.data() == a12.data() );\n+  VERIFY( b12x.size() == sizeof(a12[0]) * 7 );\n+\n+  const std::vector<long long> a13(13);\n+  auto b13 = net::buffer(a13);\n+  VERIFY( is_const(b13) );\n+  VERIFY( b13.data() == a13.data() );\n+  VERIFY( b13.size() == sizeof(a13[0]) * a13.size() );\n+\n+  auto b13x = net::buffer(a13, 7);\n+  VERIFY( is_const(b13x) );\n+  VERIFY( b13x.data() == a13.data() );\n+  VERIFY( b13x.size() == sizeof(a13[0]) * 7 );\n+\n+  std::u32string a14(14, ' ');\n+  auto b14 = net::buffer(a14);\n+  VERIFY( is_mutable(b14) );\n+  VERIFY( b14.data() == a14.data() );\n+  VERIFY( b14.size() == sizeof(a14[0]) * a14.size() );\n+\n+  auto b14x = net::buffer(a14, 8);\n+  VERIFY( is_mutable(b14x) );\n+  VERIFY( b14x.data() == a14.data() );\n+  VERIFY( b14x.size() == sizeof(a14[0]) * 8 );\n+\n+  const std::u16string a15(15, ' ');\n+  auto b15 = net::buffer(std::experimental::u16string_view(a15));\n+  VERIFY( is_const(b15) );\n+  VERIFY( b15.data() == a15.data() );\n+  VERIFY( b15.size() == sizeof(a15[0]) * a15.size() );\n+\n+  auto b15x = net::buffer(std::experimental::u16string_view(a15), 9);\n+  VERIFY( is_const(b15x) );\n+  VERIFY( b15x.data() == a15.data() );\n+  VERIFY( b15x.size() == sizeof(a15[0]) * 9 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "cbcae6fc68613cba256426dc98f62d7f2fb8dd94", "filename": "libstdc++-v3/testsuite/experimental/net/buffer/mutable.cc", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fbuffer%2Fmutable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fbuffer%2Fmutable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fbuffer%2Fmutable.cc?ref=e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "patch": "@@ -0,0 +1,71 @@\n+// Copyright (C) 2015-2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++14\" }\n+\n+#include <experimental/buffer>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::net::mutable_buffer;\n+\n+void\n+test01()\n+{\n+  using B = mutable_buffer;\n+  const B b;\n+\n+  static_assert( std::is_nothrow_default_constructible<B>::value,\n+      \"const_mutable is nothrow default constructible\" );\n+  static_assert( std::is_copy_assignable<B>::value,\n+      \"const_mutable is copy assignable\" );\n+  static_assert( std::is_nothrow_constructible<B, void*, size_t>::value,\n+      \"const_mutable is nothrow default constructible\" );\n+  static_assert( std::is_same<decltype(b.data()), void*>::value,\n+      \"data() return const void*\" );\n+  static_assert( noexcept(b.data()),\n+      \"data() is nothrow\" );\n+  static_assert( std::is_same<decltype(b.size()), size_t>::value,\n+      \"size() return size_t\" );\n+  static_assert( noexcept(b.size()),\n+      \"size() is nothrow\" );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = false;\n+  char c[4];\n+\n+  mutable_buffer b;\n+  VERIFY( b.data() == nullptr );\n+  VERIFY( b.size() == 0 );\n+\n+  b = mutable_buffer(c, sizeof(c));\n+  VERIFY( b.data() == c );\n+  VERIFY( b.size() == sizeof(c) );\n+\n+  b = mutable_buffer{};\n+  VERIFY( b.data() == nullptr );\n+  VERIFY( b.size() == 0 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "74fc49eca772c48bd09a2c5712bf15cb927da06a", "filename": "libstdc++-v3/testsuite/experimental/net/buffer/size.cc", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fbuffer%2Fsize.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fbuffer%2Fsize.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fbuffer%2Fsize.cc?ref=e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "patch": "@@ -0,0 +1,62 @@\n+// Copyright (C) 2015-2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++14\" }\n+\n+#include <experimental/buffer>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::net::const_buffer;\n+using std::experimental::net::mutable_buffer;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = false;\n+  char c[4];\n+\n+  mutable_buffer mb;\n+  VERIFY( buffer_size(mb) == 0 );\n+\n+  mb = mutable_buffer(c, sizeof(c));\n+  VERIFY( buffer_size(mb) == mb.size() );\n+\n+  const_buffer cb;\n+  VERIFY( buffer_size(cb) == 0 );\n+  cb = const_buffer(c, sizeof(c));\n+  VERIFY( buffer_size(cb) == cb.size() );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = false;\n+  char c[32];\n+\n+  std::vector<mutable_buffer> mv{ {c, 0}, {c, 32}, {c, 16}, {c, 3}, {c, 0} };\n+  VERIFY( buffer_size(mv) == (0 + 32 + 16 + 3 + 0) );\n+\n+  std::vector<const_buffer> cv{ {c, 0}, {c, 32}, {c, 16}, {c, 3}, {c, 0} };\n+  VERIFY( buffer_size(cv) == (0 + 32 + 16 + 3 + 0) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "fb19337f04146ea9783cac98f3a3c9ace353401c", "filename": "libstdc++-v3/testsuite/experimental/net/buffer/traits.cc", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fbuffer%2Ftraits.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fbuffer%2Ftraits.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fbuffer%2Ftraits.cc?ref=e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "patch": "@@ -0,0 +1,96 @@\n+// Copyright (C) 2015-2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++14\" }\n+// { dg-do compile }\n+\n+#include <experimental/buffer>\n+\n+using namespace std::experimental::net;\n+using std::vector;\n+using std::string;\n+using std::char_traits;\n+using std::allocator;\n+\n+template<typename T>\n+struct Seq {\n+  struct Buf {\n+    operator T() const { return {}; }\n+  };\n+\n+  Buf* begin() const { return nullptr; }\n+  Buf* end() const { return nullptr; }\n+};\n+\n+static_assert( is_mutable_buffer_sequence<mutable_buffer>::value,\n+    \"mutable_buffer is a mutable buffer sequence\" );\n+static_assert( is_mutable_buffer_sequence<const mutable_buffer>::value,\n+    \"const mutable_buffer is a mutable buffer sequence\" );\n+static_assert( is_mutable_buffer_sequence<vector<mutable_buffer>>::value,\n+    \"vector<mutable_buffer> is a mutable buffer sequence\" );\n+static_assert( is_mutable_buffer_sequence<const vector<mutable_buffer>>::value,\n+    \"const vector<mutable_buffer> is a mutable buffer sequence\" );\n+static_assert( is_mutable_buffer_sequence<Seq<mutable_buffer>>::value,\n+    \"Seq<mutable_buffer> is a mutable buffer sequence\" );\n+static_assert( is_mutable_buffer_sequence<const Seq<mutable_buffer>>::value,\n+    \"const Seq<mutable_buffer> is a mutable buffer sequence\" );\n+static_assert( is_mutable_buffer_sequence<Seq<const mutable_buffer>>::value,\n+    \"Seq<const mutable_buffer> is a mutable buffer sequence\" );\n+static_assert( ! is_mutable_buffer_sequence<const_buffer>::value,\n+    \"const_buffer is not a mutable buffer sequence\" );\n+static_assert( ! is_mutable_buffer_sequence<vector<const_buffer>>::value,\n+    \"vector<const_buffer> is not a mutable buffer sequence\" );\n+static_assert( ! is_mutable_buffer_sequence<Seq<const_buffer>>::value,\n+    \"Seq<const_buffer> is not a mutable buffer sequence\" );\n+\n+static_assert( is_const_buffer_sequence<const_buffer>::value,\n+    \"const_buffer is a const buffer sequence\" );\n+static_assert( is_const_buffer_sequence<const const_buffer>::value,\n+    \"const const_buffer is a const buffer sequence\" );\n+static_assert( is_const_buffer_sequence<vector<const_buffer>>::value,\n+    \"vector<const_buffer> is a const buffer sequence\" );\n+static_assert( is_const_buffer_sequence<const vector<const_buffer>>::value,\n+    \"const vector<const_buffer> is a const buffer sequence\" );\n+static_assert( is_const_buffer_sequence<Seq<const_buffer>>::value,\n+    \"Seq<const_buffer> is a const buffer sequence\" );\n+static_assert( is_const_buffer_sequence<const Seq<const_buffer>>::value,\n+    \"const Seq<const_buffer> is a const buffer sequence\" );\n+static_assert( is_const_buffer_sequence<Seq<const const_buffer>>::value,\n+    \"Seq<const const_buffer> is a const buffer sequence\" );\n+static_assert( is_const_buffer_sequence<mutable_buffer>::value,\n+    \"mutable_buffer is a const buffer sequence\" );\n+static_assert( is_const_buffer_sequence<const mutable_buffer>::value,\n+    \"const mutable_buffer is a const buffer sequence\" );\n+static_assert( is_const_buffer_sequence<vector<mutable_buffer>>::value,\n+    \"vector<mutable_buffer> is a const buffer sequence\" );\n+static_assert( is_const_buffer_sequence<const vector<mutable_buffer>>::value,\n+    \"const vector<mutable_buffer> is a const buffer sequence\" );\n+\n+// Buf -> mutable_buffer -> const_buffer needs two user-defined conversions:\n+static_assert( ! is_const_buffer_sequence<Seq<mutable_buffer>>::value,\n+    \"Seq<mutable_buffer> is not a const buffer sequence\" );\n+\n+static_assert( is_dynamic_buffer<\n+    dynamic_vector_buffer<int, allocator<int>>\n+    >::value, \"dynamic_vector_buffer is a dynamic buffer\" );\n+static_assert( is_dynamic_buffer<\n+    dynamic_string_buffer<char, char_traits<char>, allocator<int>>\n+    >::value, \"dynamic_string_buffer is a dynamic buffer\" );\n+static_assert( ! is_dynamic_buffer<vector<int>>::value,\n+    \"vector is not a dynamic buffer\" );\n+static_assert( ! is_dynamic_buffer<string>::value,\n+    \"string is not a dynamic buffer\" );"}, {"sha": "d8fb6404b3cde9a3293502edc76efe1b50ad8f30", "filename": "libstdc++-v3/testsuite/experimental/net/execution_context/use_service.cc", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fexecution_context%2Fuse_service.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fexecution_context%2Fuse_service.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fexecution_context%2Fuse_service.cc?ref=e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "patch": "@@ -0,0 +1,80 @@\n+// Copyright (C) 2015-2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++14\" }\n+\n+#include <experimental/executor>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::net::execution_context;\n+using std::experimental::net::use_service;\n+\n+struct service1 : execution_context::service\n+{\n+  using key_type = service1;\n+  service1(execution_context& c) : service(c) { }\n+  void shutdown() noexcept { }\n+};\n+\n+struct key2 : execution_context::service\n+{\n+  key2(execution_context& c) : service(c) { }\n+};\n+\n+struct service2 : key2\n+{\n+  using key_type = key2;\n+  service2(execution_context& c) : key2(c) { }\n+  void shutdown() noexcept { }\n+};\n+\n+struct service3 : service1\n+{\n+  using service1::service1;\n+};\n+\n+struct service4 : service2\n+{\n+  using service2::service2;\n+};\n+\n+void\n+test01()\n+{\n+  execution_context ctx;\n+  service1& svc1 = use_service<service1>(ctx);\n+  service1& svc1a = use_service<service1>(ctx);\n+  VERIFY( &svc1a == &svc1 );\n+\n+  key2& svc2 = use_service<service2>(ctx);\n+  key2& svc2a = use_service<service2>(ctx);\n+  VERIFY( &svc2a == &svc2 );\n+\n+  service1& svc3 = use_service<service3>(ctx);\n+  VERIFY( &svc3 == &svc1 );\n+\n+  key2& svc4 = use_service<service4>(ctx);\n+  VERIFY( &svc4 == &svc2 );\n+\n+  // TODO test02() function that puts derived types in first, then tests base comes out\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "58ba13f4744f7a7080c85eacf9622491fc129e41", "filename": "libstdc++-v3/testsuite/experimental/net/headers.cc", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fheaders.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fheaders.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fheaders.cc?ref=e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "patch": "@@ -0,0 +1,30 @@\n+// Copyright (C) 2015-2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++14\" }\n+// { dg-do compile }\n+\n+#include <experimental/net>\n+\n+// Re-include:\n+#include <experimental/buffer>\n+#include <experimental/executor>\n+#include <experimental/internet>\n+#include <experimental/io_context>\n+#include <experimental/netfwd>\n+#include <experimental/socket>\n+#include <experimental/timer>"}, {"sha": "d82e1e4f4fcb4b5ac94df61a6747185a6f5678a9", "filename": "libstdc++-v3/testsuite/experimental/net/internet/address/v4/comparisons.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Finternet%2Faddress%2Fv4%2Fcomparisons.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Finternet%2Faddress%2Fv4%2Fcomparisons.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Finternet%2Faddress%2Fv4%2Fcomparisons.cc?ref=e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "patch": "@@ -0,0 +1,67 @@\n+// Copyright (C) 2015-2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++14\" }\n+\n+#include <experimental/internet>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::net::ip::address_v4;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = false;\n+\n+  address_v4 addrs[] = {\n+    address_v4::any(), address_v4::loopback(), address_v4::broadcast(),\n+    address_v4{0x11001100}, address_v4{0xEFEFEFEF}\n+  };\n+\n+  auto begin = std::begin(addrs);\n+  auto end = std::end(addrs);\n+  for (auto it = begin; it != end; ++it)\n+  {\n+    auto& a = *it;\n+    VERIFY( a == a );\n+    VERIFY( a <= a );\n+    VERIFY( a >= a );\n+    VERIFY( ! (a != a) );\n+    VERIFY( ! (a < a) );\n+    VERIFY( ! (a > a) );\n+  }\n+\n+  std::sort(begin, end);\n+\n+  for (auto it = begin + 1; it != end; ++it)\n+  {\n+    auto& a = *it;\n+    auto& b = *begin;\n+    VERIFY( ! (a == b) );\n+    VERIFY( a != b );\n+    VERIFY( b < a );\n+    VERIFY( b <= a );\n+    VERIFY( a > b );\n+    VERIFY( a >= b );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "ed09b9cb9779101f9f13eedc000e8eb25ef08121", "filename": "libstdc++-v3/testsuite/experimental/net/internet/address/v4/cons.cc", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Finternet%2Faddress%2Fv4%2Fcons.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Finternet%2Faddress%2Fv4%2Fcons.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Finternet%2Faddress%2Fv4%2Fcons.cc?ref=e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "patch": "@@ -0,0 +1,71 @@\n+// Copyright (C) 2015-2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++14\" }\n+\n+#include <experimental/internet>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::net::ip::address_v4;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = false;\n+\n+  address_v4 a0;\n+  VERIFY( a0.to_uint() == 0 );\n+  VERIFY( a0.to_bytes() == address_v4::bytes_type{} );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = false;\n+\n+  address_v4 a0{ address_v4::bytes_type{} };\n+  VERIFY( a0.to_uint() == 0 );\n+  VERIFY( a0.to_bytes() == address_v4::bytes_type{} );\n+\n+  address_v4::bytes_type b1{ 1, 2, 3, 4 };\n+  address_v4 a1{ b1 };\n+  VERIFY( a1.to_uint() == ntohl((1 << 24) | (2 << 16) | (3 << 8) | 4) );\n+  VERIFY( a1.to_bytes() == b1 );\n+}\n+\n+void\n+test03()\n+{\n+  bool test __attribute__((unused)) = false;\n+\n+  address_v4 a0{ 0u };\n+  VERIFY( a0.to_uint() == 0 );\n+  VERIFY( a0.to_bytes() == address_v4::bytes_type{} );\n+\n+  address_v4::uint_type u1 = ntohl((5 << 24) | (6 << 16) | (7 << 8) | 8);\n+  address_v4 a1{ u1 };\n+  VERIFY( a1.to_uint() == u1 );\n+  VERIFY( a1.to_bytes() == address_v4::bytes_type( 5, 6, 7, 8 ) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "a168de66f72e6ca39aabc3fde37ee37c57fcbec4", "filename": "libstdc++-v3/testsuite/experimental/net/internet/address/v4/creation.cc", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Finternet%2Faddress%2Fv4%2Fcreation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Finternet%2Faddress%2Fv4%2Fcreation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Finternet%2Faddress%2Fv4%2Fcreation.cc?ref=e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "patch": "@@ -0,0 +1,91 @@\n+// Copyright (C) 2015-2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++14\" }\n+\n+#include <experimental/internet>\n+#include <testsuite_hooks.h>\n+\n+namespace ip = std::experimental::net::ip;\n+using ip::address_v4;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = false;\n+\n+  auto a0 = make_address_v4( address_v4::bytes_type{} );\n+  VERIFY( a0.to_uint() == 0 );\n+  VERIFY( a0.to_bytes() == address_v4::bytes_type{} );\n+\n+  address_v4::bytes_type b1{ 1, 2, 3, 4 };\n+  auto a1 = make_address_v4( b1 );\n+  VERIFY( a1.to_uint() == ntohl((1 << 24) | (2 << 16) | (3 << 8) | 4) );\n+  VERIFY( a1.to_bytes() == b1 );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = false;\n+\n+  auto a0 = ip::make_address_v4(0u);\n+  VERIFY( a0.to_uint() == 0 );\n+  VERIFY( a0.to_bytes() == address_v4::bytes_type{} );\n+\n+  address_v4::uint_type u1 = ntohl((5 << 24) | (6 << 16) | (7 << 8) | 8);\n+  auto a1 = ip::make_address_v4( u1 );\n+  VERIFY( a1.to_uint() == u1 );\n+  VERIFY( a1.to_bytes() == address_v4::bytes_type( 5, 6, 7, 8 ) );\n+}\n+\n+void\n+test03()\n+{\n+  bool test __attribute__((unused)) = false;\n+\n+  auto a1 = ip::make_address_v4(\"127.0.0.1\");\n+  VERIFY( a1.is_loopback() );\n+  auto a2 = ip::make_address_v4(std::string{\"127.0.0.2\"});\n+  VERIFY( a2.is_loopback() );\n+  auto a3 = ip::make_address_v4(std::experimental::string_view{\"127.0.0.3\"});\n+  VERIFY( a3.is_loopback() );\n+\n+  std::error_code ec;\n+  auto a4 = ip::make_address_v4(\"127...1\", ec);\n+  VERIFY( ec == std::errc::invalid_argument );\n+\n+  ip::make_address_v4(\"127.0.0.1\", ec);\n+  VERIFY( !ec );\n+\n+  a4 = ip::make_address_v4(std::string{\"256.0.0.1\"}, ec);\n+  VERIFY( ec == std::errc::invalid_argument );\n+\n+  ip::make_address_v4(std::string{\"127.0.0.1\"}, ec);\n+  VERIFY( !ec );\n+\n+  a4 = ip::make_address_v4(std::experimental::string_view{\"\"}, ec);\n+  VERIFY( ec == std::errc::invalid_argument );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "b854d8fcc142b8442ef76a36082a7d9cc956f7c2", "filename": "libstdc++-v3/testsuite/experimental/net/internet/address/v4/members.cc", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Finternet%2Faddress%2Fv4%2Fmembers.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Finternet%2Faddress%2Fv4%2Fmembers.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Finternet%2Faddress%2Fv4%2Fmembers.cc?ref=e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "patch": "@@ -0,0 +1,118 @@\n+// Copyright (C) 2015-2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++14\" }\n+\n+#include <experimental/internet>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::net::ip::address_v4;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = false;\n+\n+  address_v4 a;\n+  VERIFY( a.is_unspecified() );\n+\n+  a = address_v4::any();\n+  VERIFY( a.is_unspecified() );\n+\n+  a = address_v4::loopback();\n+  VERIFY( !a.is_unspecified() );\n+\n+  a = address_v4::broadcast();\n+  VERIFY( !a.is_unspecified() );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = false;\n+\n+  auto a = address_v4::loopback();\n+  VERIFY( a.is_loopback() );\n+\n+  a = address_v4{0x7F000001};\n+  VERIFY( a.is_loopback() );\n+\n+  a = address_v4{0x7F010203};\n+  VERIFY( a.is_loopback() );\n+\n+  a = address_v4{0x7FFFFFFF};\n+  VERIFY( a.is_loopback() );\n+\n+  a = address_v4::any();\n+  VERIFY( !a.is_loopback() );\n+\n+  a = address_v4::broadcast();\n+  VERIFY( !a.is_loopback() );\n+}\n+\n+void\n+test03()\n+{\n+  bool test __attribute__((unused)) = false;\n+\n+  auto a = address_v4{0xE0000001};\n+  VERIFY( a.is_multicast() );\n+\n+  a = address_v4{0xE0010203};\n+  VERIFY( a.is_multicast() );\n+\n+  a = address_v4{0xE0FFFFFF};\n+  VERIFY( a.is_multicast() );\n+\n+  a = address_v4{0xF0000000};\n+  VERIFY( !a.is_multicast() );\n+\n+  a = address_v4{0xDFFFFFFF};\n+  VERIFY( !a.is_multicast() );\n+}\n+\n+void\n+test04()\n+{\n+  bool test __attribute__((unused)) = false;\n+\n+  VERIFY( address_v4::any().to_string() == \"0.0.0.0\" );\n+  VERIFY( address_v4::loopback().to_string() == \"127.0.0.1\" );\n+  VERIFY( address_v4::broadcast().to_string() == \"255.255.255.255\" );\n+}\n+\n+void\n+test05()\n+{\n+  bool test __attribute__((unused)) = false;\n+\n+  std::ostringstream ss;\n+  ss << address_v4::any() << ' ' << address_v4::loopback() << ' '\n+    << address_v4::broadcast();\n+  VERIFY( ss.str() == \"0.0.0.0 127.0.0.1 255.255.255.255\" );\n+}\n+\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+}"}, {"sha": "c07de7aec5adcf1fa0756cf56adf82270f8dd752", "filename": "libstdc++-v3/testsuite/experimental/net/internet/resolver/base.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Finternet%2Fresolver%2Fbase.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Finternet%2Fresolver%2Fbase.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Finternet%2Fresolver%2Fbase.cc?ref=e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "patch": "@@ -0,0 +1,61 @@\n+// Copyright (C) 2015-2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++14\" }\n+\n+#include <experimental/internet>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = false;\n+\n+  using resolver = std::experimental::net::ip::resolver_base;\n+\n+  resolver::flags f = resolver::passive;\n+\n+  VERIFY( (f & resolver::numeric_host) == 0);\n+  f &= resolver::numeric_host;\n+  VERIFY( f == 0 );\n+\n+  VERIFY( (f | resolver::numeric_host) == resolver::numeric_host);\n+  f |= resolver::numeric_host;\n+  VERIFY( f == resolver::numeric_host );\n+\n+  VERIFY( (f ^ resolver::numeric_host) == 0 );\n+  f ^= resolver::numeric_host;\n+  VERIFY( f == 0 );\n+\n+  f = ~resolver::numeric_host;\n+  VERIFY( (f & resolver::numeric_host) == 0);\n+  VERIFY( (f | resolver::numeric_host) == ~resolver::flags{} );\n+\n+  (void) resolver::passive;\n+  (void) resolver::canonical_name;\n+  (void) resolver::numeric_host;\n+  (void) resolver::numeric_service;\n+  (void) resolver::v4_mapped;\n+  (void) resolver::all_matching;\n+  (void) resolver::address_configured;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "ca1018d218cb2824ebf7e67d0680be531b889134", "filename": "libstdc++-v3/testsuite/experimental/net/internet/resolver/ops/lookup.cc", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Finternet%2Fresolver%2Fops%2Flookup.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Finternet%2Fresolver%2Fops%2Flookup.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Finternet%2Fresolver%2Fops%2Flookup.cc?ref=e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "patch": "@@ -0,0 +1,110 @@\n+// Copyright (C) 2015-2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++14\" }\n+\n+#include <experimental/internet>\n+#include <testsuite_hooks.h>\n+\n+using namespace std::experimental::net;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = false;\n+\n+  std::error_code ec;\n+  io_context ctx;\n+  ip::tcp::resolver resolv(ctx);\n+  auto addrs = resolv.resolve(\"localhost\", \"http\", ec);\n+  VERIFY( !ec );\n+  VERIFY( addrs.size() > 0 );\n+  VERIFY( addrs.begin() != addrs.end() );\n+  VERIFY( ! addrs.empty() );\n+\n+  auto addrs2 = resolv.resolve(\"localhost\", \"http\");\n+  VERIFY( addrs == addrs2 );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = false;\n+\n+  std::error_code ec;\n+  io_context ctx;\n+  ip::tcp::resolver resolv(ctx);\n+  auto flags = ip::resolver_base::numeric_host | ip::tcp::resolver::numeric_service;\n+  auto addrs = resolv.resolve(\"127.0.0.1\", \"42\", flags, ec);\n+  VERIFY( !ec );\n+  VERIFY( addrs.size() > 0 );\n+  VERIFY( addrs.begin() != addrs.end() );\n+\n+  auto addrs2 = resolv.resolve(\"127.0.0.1\", \"42\", flags);\n+  VERIFY( addrs == addrs2 );\n+\n+  addrs = resolv.resolve(\"localhost\", \"42\", flags, ec);\n+  VERIFY( ec );\n+  VERIFY( addrs.empty() );\n+  addrs = resolv.resolve(\"127.0.0.1\", \"nameserver\", flags, ec);\n+  VERIFY( ec );\n+  VERIFY( addrs.empty() );\n+\n+#if __cpp_exceptions\n+  bool caught = false;\n+  try {\n+    resolv.resolve(\"localhost\", \"http\", flags);\n+  } catch (const std::system_error& e) {\n+    caught = true;\n+    VERIFY( e.code() == ec );\n+  }\n+  VERIFY( caught );\n+#endif\n+}\n+\n+void\n+test03()\n+{\n+  bool test __attribute__((unused)) = false;\n+\n+  std::error_code ec;\n+  io_context ctx;\n+  ip::tcp::resolver resolv(ctx);\n+  auto addrs = resolv.resolve(\"test.invalid\", \"http\", ec);\n+  VERIFY( ec );\n+  VERIFY( addrs.size() == 0 );\n+  VERIFY( addrs.begin() == addrs.end() );\n+  VERIFY( addrs.empty() );\n+#if __cpp_exceptions\n+  bool caught = false;\n+  try {\n+    resolv.resolve(\"test.invalid\", \"http\");\n+  } catch (const std::system_error& e) {\n+    caught = true;\n+    VERIFY( e.code() == ec );\n+  }\n+  VERIFY( caught );\n+#endif\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "f5035079eb6246fe58ede9b5eed05bae3fa67eef", "filename": "libstdc++-v3/testsuite/experimental/net/internet/resolver/ops/reverse.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Finternet%2Fresolver%2Fops%2Freverse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Finternet%2Fresolver%2Fops%2Freverse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Finternet%2Fresolver%2Fops%2Freverse.cc?ref=e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "patch": "@@ -0,0 +1,48 @@\n+// Copyright (C) 2015-2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++14\" }\n+\n+#include <experimental/internet>\n+#include <testsuite_hooks.h>\n+\n+using namespace std::experimental::net;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = false;\n+\n+  std::error_code ec;\n+  io_context ctx;\n+  ip::tcp::resolver resolv(ctx);\n+  ip::tcp::endpoint home{ip::address_v4::loopback(), 80};\n+  auto addrs = resolv.resolve(home, ec);\n+  VERIFY( !ec );\n+  VERIFY( addrs.size() == 1 );\n+  VERIFY( addrs.begin() != addrs.end() );\n+  VERIFY( ! addrs.empty() );\n+\n+  auto addrs2 = resolv.resolve(home);\n+  VERIFY( addrs == addrs2 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "3bce0576e12f1ebe03641069303230da2453ad40", "filename": "libstdc++-v3/testsuite/experimental/net/timer/waitable/cons.cc", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Ftimer%2Fwaitable%2Fcons.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Ftimer%2Fwaitable%2Fcons.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Ftimer%2Fwaitable%2Fcons.cc?ref=e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "patch": "@@ -0,0 +1,119 @@\n+// Copyright (C) 2015-2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++14\" }\n+\n+#include <experimental/timer>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::net::system_timer;\n+using std::experimental::net::io_context;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = false;\n+\n+  io_context ctx1, ctx2;\n+\n+  system_timer timer1(ctx1);\n+  VERIFY( timer1.get_executor() == ctx1.get_executor() );\n+  VERIFY( timer1.expiry() == system_timer::time_point() );\n+\n+  system_timer timer2(ctx2);\n+  VERIFY( timer2.get_executor() == ctx2.get_executor() );\n+  VERIFY( timer2.get_executor() != timer1.get_executor() );\n+  VERIFY( timer2.expiry() == system_timer::time_point() );\n+\n+  system_timer timer3(std::move(timer1));\n+  VERIFY( timer3.get_executor() == ctx1.get_executor() );\n+  VERIFY( timer3.expiry() == system_timer::time_point() );\n+  VERIFY( timer1.expiry() == system_timer::time_point() );\n+\n+  system_timer timer4(std::move(timer2));\n+  VERIFY( timer4.get_executor() == ctx2.get_executor() );\n+  VERIFY( timer4.expiry() == system_timer::time_point() );\n+  VERIFY( timer2.expiry() == system_timer::time_point() );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = false;\n+\n+  io_context ctx1, ctx2;\n+  auto t1 = system_timer::clock_type::now();\n+  auto t2 = t1 + system_timer::duration(10);\n+\n+  system_timer timer1(ctx1, t1);\n+  VERIFY( timer1.get_executor() == ctx1.get_executor() );\n+  VERIFY( timer1.expiry() == t1 );\n+\n+  system_timer timer2(ctx2, t2);\n+  VERIFY( timer2.get_executor() == ctx2.get_executor() );\n+  VERIFY( timer2.get_executor() != timer1.get_executor() );\n+  VERIFY( timer2.expiry() == t2 );\n+\n+  system_timer timer3(std::move(timer1));\n+  VERIFY( timer3.get_executor() == ctx1.get_executor() );\n+  VERIFY( timer3.expiry() == t1 );\n+  VERIFY( timer1.expiry() == system_timer::time_point() );\n+\n+  system_timer timer4(std::move(timer2));\n+  VERIFY( timer4.get_executor() == ctx2.get_executor() );\n+  VERIFY( timer4.expiry() == t2 );\n+  VERIFY( timer2.expiry() == system_timer::time_point() );\n+}\n+\n+void\n+test03()\n+{\n+  bool test __attribute__((unused)) = false;\n+\n+  io_context ctx1, ctx2;\n+  auto now = system_timer::clock_type::now();\n+  auto d1 = system_timer::duration(10);\n+  auto d2 = system_timer::duration(100);\n+\n+  system_timer timer1(ctx1, d1);\n+  VERIFY( timer1.get_executor() == ctx1.get_executor() );\n+  VERIFY( timer1.expiry() > now );\n+\n+  system_timer timer2(ctx2, d2);\n+  VERIFY( timer2.get_executor() == ctx2.get_executor() );\n+  VERIFY( timer2.get_executor() != timer1.get_executor() );\n+  VERIFY( timer2.expiry() > now );\n+  VERIFY( timer2.expiry() != timer1.expiry() );\n+\n+  system_timer timer3(std::move(timer1));\n+  VERIFY( timer3.get_executor() == ctx1.get_executor() );\n+  VERIFY( timer3.expiry() > now );\n+  VERIFY( timer1.expiry() == system_timer::time_point() );\n+\n+  system_timer timer4(std::move(timer2));\n+  VERIFY( timer4.get_executor() == ctx2.get_executor() );\n+  VERIFY( timer4.expiry() > now );\n+  VERIFY( timer2.expiry() == system_timer::time_point() );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "743f28a55e9e46225994b2f9304c25ce1f403556", "filename": "libstdc++-v3/testsuite/experimental/net/timer/waitable/dest.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Ftimer%2Fwaitable%2Fdest.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Ftimer%2Fwaitable%2Fdest.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Ftimer%2Fwaitable%2Fdest.cc?ref=e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "patch": "@@ -0,0 +1,48 @@\n+// Copyright (C) 2015-2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++14\" }\n+\n+#include <experimental/timer>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::net::system_timer;\n+using std::experimental::net::io_context;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = false;\n+\n+  std::error_code ec;\n+\n+  io_context ctx;\n+  {\n+    system_timer timer(ctx, system_timer::duration(3600));\n+    timer.async_wait([&ec](std::error_code e) { ec = e; });\n+  }\n+  auto n = ctx.run();\n+  __builtin_printf(\"ran %lu\\n\", n);\n+  VERIFY( n == 1 );\n+  VERIFY( ec == std::errc::operation_canceled );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "c4e0b1bfe4100e330cf46313d9b8058961b5fbca", "filename": "libstdc++-v3/testsuite/experimental/net/timer/waitable/ops.cc", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Ftimer%2Fwaitable%2Fops.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Ftimer%2Fwaitable%2Fops.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Ftimer%2Fwaitable%2Fops.cc?ref=e5989e71ffdee9f030f0b8ac38aef5a4ff7bd444", "patch": "@@ -0,0 +1,106 @@\n+// Copyright (C) 2015-2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++14\" }\n+\n+#include <experimental/timer>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::net::system_timer;\n+using std::experimental::net::io_context;\n+using std::error_code;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = false;\n+\n+  io_context ctx;\n+  error_code ec;\n+  bool complete = false;\n+\n+  auto then = system_timer::clock_type::now() + system_timer::duration(100);\n+\n+  system_timer timer(ctx, then);\n+  VERIFY( timer.cancel_one() == 0 );\n+  VERIFY( timer.cancel() == 0 );\n+\n+  timer.async_wait([&](error_code e) { ec = e; complete = true; });\n+  VERIFY( timer.cancel_one() == 1 );\n+  VERIFY( !complete );\n+\n+  VERIFY( timer.cancel_one() == 0 );\n+  VERIFY( timer.cancel() == 0 );\n+\n+  VERIFY( ctx.run() == 1 );\n+  VERIFY( ctx.stopped() );\n+  VERIFY( complete );\n+  VERIFY( ec == std::errc::operation_canceled );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = false;\n+\n+  io_context ctx;\n+  error_code ec1, ec2;\n+\n+  const auto now = system_timer::clock_type::now();\n+  const auto t1 = now + std::chrono::seconds(100);\n+  const auto t2 = t1 + std::chrono::seconds(100);\n+\n+  system_timer timer(ctx, t1);\n+  VERIFY( timer.expiry() == t1 );\n+\n+  VERIFY( timer.expires_at(t2) == 0 );\n+  VERIFY( timer.expiry() == t2 );\n+\n+  timer.async_wait([&ec1](error_code e) { ec1 = e; });\n+  timer.async_wait([&ec2](error_code e) { ec2 = e; });\n+  auto n = timer.expires_at(t1);\n+  VERIFY( n == 2 );\n+  VERIFY( timer.expiry() == t1 );\n+\n+  VERIFY( ctx.run_one() == 1 );\n+  VERIFY( ! ctx.stopped() );\n+  VERIFY( ctx.run_one() == 1 );\n+  VERIFY( ctx.stopped() );\n+  VERIFY( ec1 == std::errc::operation_canceled );\n+  VERIFY( ec2 == std::errc::operation_canceled );\n+\n+  VERIFY( timer.expires_after(std::chrono::seconds(50)) == 0 );\n+  VERIFY( timer.expiry() < t1 );\n+\n+  ec1.clear();\n+  ec2.clear();\n+  ctx.restart();\n+  timer.async_wait([&ec1](error_code e) { ec1 = e; });\n+  timer.async_wait([&ec2](error_code e) { ec2 = e; });\n+  VERIFY( timer.expires_after(std::chrono::seconds(10)) == 2 );\n+  VERIFY( timer.expiry() < t1 );\n+  ctx.run();\n+  VERIFY( ec1 == std::errc::operation_canceled );\n+  VERIFY( ec2 == std::errc::operation_canceled );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}]}