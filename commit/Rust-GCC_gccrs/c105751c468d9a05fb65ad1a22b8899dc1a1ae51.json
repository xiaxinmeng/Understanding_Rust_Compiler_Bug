{"sha": "c105751c468d9a05fb65ad1a22b8899dc1a1ae51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzEwNTc1MWM0NjhkOWEwNWZiNjVhZDFhMjJiODg5OWRjMWExYWU1MQ==", "commit": {"author": {"name": "Edward Smith-Rowland", "email": "3dw4rd@verizon.net", "date": "2009-08-14T17:54:44Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2009-08-14T17:54:44Z"}, "message": "stl_tree.h: Make erase return iterator as per DR 130.\n\n2009-08-14  Edward Smith-Rowland  <3dw4rd@verizon.net>\n\n\t* include/bits/stl_tree.h: Make erase return iterator as per DR 130.\n\t* include/bits/stl_set.h: Same.\n\t* include/bits/stl_multiset.h: Same.\n\t* include/bits/stl_map.h: Same.\n\t* include/bits/stl_multimap.h: Same.\n\t* doc/xml/manual/intro.xml: Document.\n\t* testsuite/23_containers/set/dr130.cc: New.\n\t* testsuite/23_containers/multiset/dr130.cc: New.\n\t* testsuite/23_containers/map/dr130.cc: New.\n\t* testsuite/23_containers/multimap/dr130.cc: New.\n\nFrom-SVN: r150768", "tree": {"sha": "a8a0aacfec4061b3e5831862f1685d6bac11b510", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8a0aacfec4061b3e5831862f1685d6bac11b510"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c105751c468d9a05fb65ad1a22b8899dc1a1ae51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c105751c468d9a05fb65ad1a22b8899dc1a1ae51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c105751c468d9a05fb65ad1a22b8899dc1a1ae51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c105751c468d9a05fb65ad1a22b8899dc1a1ae51/comments", "author": {"login": "emsr", "id": 1936479, "node_id": "MDQ6VXNlcjE5MzY0Nzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1936479?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emsr", "html_url": "https://github.com/emsr", "followers_url": "https://api.github.com/users/emsr/followers", "following_url": "https://api.github.com/users/emsr/following{/other_user}", "gists_url": "https://api.github.com/users/emsr/gists{/gist_id}", "starred_url": "https://api.github.com/users/emsr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emsr/subscriptions", "organizations_url": "https://api.github.com/users/emsr/orgs", "repos_url": "https://api.github.com/users/emsr/repos", "events_url": "https://api.github.com/users/emsr/events{/privacy}", "received_events_url": "https://api.github.com/users/emsr/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0942c722b3725ad3ae23ac11c8922860928dd3a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0942c722b3725ad3ae23ac11c8922860928dd3a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0942c722b3725ad3ae23ac11c8922860928dd3a3"}], "stats": {"total": 618, "additions": 616, "deletions": 2}, "files": [{"sha": "a48eb055c7a7a25f8e38804d27450b69e2ac322c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c105751c468d9a05fb65ad1a22b8899dc1a1ae51/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c105751c468d9a05fb65ad1a22b8899dc1a1ae51/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=c105751c468d9a05fb65ad1a22b8899dc1a1ae51", "patch": "@@ -1,3 +1,16 @@\n+2009-08-14  Edward Smith-Rowland  <3dw4rd@verizon.net>\n+\n+\t* include/bits/stl_tree.h: Make erase return iterator as per DR 130.\n+\t* include/bits/stl_set.h: Same.\n+\t* include/bits/stl_multiset.h: Same.\n+\t* include/bits/stl_map.h: Same.\n+\t* include/bits/stl_multimap.h: Same.\n+\t* doc/xml/manual/intro.xml: Document.\n+\t* testsuite/23_containers/set/dr130.cc: New.\n+\t* testsuite/23_containers/multiset/dr130.cc: New.\n+\t* testsuite/23_containers/map/dr130.cc: New.\n+\t* testsuite/23_containers/multimap/dr130.cc: New.\n+\n 2009-08-14  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* include/ext/pointer.h: Add pragma system_header, use"}, {"sha": "28b80c90af076705cd1f3cb61cd2df09ef6d62c2", "filename": "libstdc++-v3/doc/xml/manual/intro.xml", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c105751c468d9a05fb65ad1a22b8899dc1a1ae51/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fintro.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c105751c468d9a05fb65ad1a22b8899dc1a1ae51/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fintro.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fintro.xml?ref=c105751c468d9a05fb65ad1a22b8899dc1a1ae51", "patch": "@@ -393,6 +393,12 @@ requirements of the license of GCC.\n     <listitem><para>These functions set <code>failbit</code> on error now.\n     </para></listitem></varlistentry>\n \n+    <varlistentry><term><ulink url=\"../ext/lwg-defects.html#130\">130</ulink>:\n+        <emphasis>Return type of container::erase(iterator) differs for associative containers</emphasis>\n+    </term>\n+    <listitem><para>Make member <code>erase</code> return iterator for <code>set</code>, <code>multiset</code>, <code>map</code>, <code>multimap</code>. \n+    </para></listitem></varlistentry>\n+\n     <varlistentry><term><ulink url=\"../ext/lwg-defects.html#136\">136</ulink>:\n         <emphasis>seekp, seekg setting wrong streams?</emphasis>\n     </term>"}, {"sha": "a26e68a01c0aad700f67f64b9f9873982d92d7a2", "filename": "libstdc++-v3/include/bits/stl_map.h", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c105751c468d9a05fb65ad1a22b8899dc1a1ae51/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c105751c468d9a05fb65ad1a22b8899dc1a1ae51/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h?ref=c105751c468d9a05fb65ad1a22b8899dc1a1ae51", "patch": "@@ -552,6 +552,26 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n         insert(_InputIterator __first, _InputIterator __last)\n         { _M_t._M_insert_unique(__first, __last); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // DR 130. Associative erase should return an iterator.\n+      /**\n+       *  @brief Erases an element from a %map.\n+       *  @param  position  An iterator pointing to the element to be erased.\n+       *  @return An iterator pointing to the element immediately following\n+       *          @a position prior to the element being erased. If no such \n+       *          element exists, end() is returned.\n+       *\n+       *  This function erases an element, pointed to by the given\n+       *  iterator, from a %map.  Note that this function only erases\n+       *  the element, and that if the element is itself a pointer,\n+       *  the pointed-to memory is not touched in any way.  Managing\n+       *  the pointer is the user's responsibility.\n+       */\n+      iterator\n+      erase(iterator __position)\n+      { return _M_t.erase(__position); }\n+#else\n       /**\n        *  @brief Erases an element from a %map.\n        *  @param  position  An iterator pointing to the element to be erased.\n@@ -565,6 +585,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       void\n       erase(iterator __position)\n       { _M_t.erase(__position); }\n+#endif\n \n       /**\n        *  @brief Erases elements according to the provided key.\n@@ -581,6 +602,25 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       erase(const key_type& __x)\n       { return _M_t.erase(__x); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // DR 130. Associative erase should return an iterator.\n+      /**\n+       *  @brief Erases a [first,last) range of elements from a %map.\n+       *  @param  first  Iterator pointing to the start of the range to be\n+       *                 erased.\n+       *  @param  last  Iterator pointing to the end of the range to be erased.\n+       *  @return The iterator @a last.\n+       *\n+       *  This function erases a sequence of elements from a %map.\n+       *  Note that this function only erases the element, and that if\n+       *  the element is itself a pointer, the pointed-to memory is not touched\n+       *  in any way.  Managing the pointer is the user's responsibility.\n+       */\n+      iterator\n+      erase(iterator __first, iterator __last)\n+      { return _M_t.erase(__first, __last); }\n+#else\n       /**\n        *  @brief Erases a [first,last) range of elements from a %map.\n        *  @param  first  Iterator pointing to the start of the range to be\n@@ -595,6 +635,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       void\n       erase(iterator __first, iterator __last)\n       { _M_t.erase(__first, __last); }\n+#endif\n \n       /**\n        *  @brief  Swaps data with another %map."}, {"sha": "fa3f2539018aa60ff0f217b55463f56cd42fbf11", "filename": "libstdc++-v3/include/bits/stl_multimap.h", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c105751c468d9a05fb65ad1a22b8899dc1a1ae51/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c105751c468d9a05fb65ad1a22b8899dc1a1ae51/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h?ref=c105751c468d9a05fb65ad1a22b8899dc1a1ae51", "patch": "@@ -488,6 +488,26 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       { this->insert(__l.begin(), __l.end()); }\n #endif\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // DR 130. Associative erase should return an iterator.\n+      /**\n+       *  @brief Erases an element from a %multimap.\n+       *  @param  position  An iterator pointing to the element to be erased.\n+       *  @return An iterator pointing to the element immediately following\n+       *          @a position prior to the element being erased. If no such \n+       *          element exists, end() is returned.\n+       *\n+       *  This function erases an element, pointed to by the given iterator,\n+       *  from a %multimap.  Note that this function only erases the element,\n+       *  and that if the element is itself a pointer, the pointed-to memory is\n+       *  not touched in any way.  Managing the pointer is the user's\n+       *  responsibility.\n+       */\n+      iterator\n+      erase(iterator __position)\n+      { return _M_t.erase(__position); }\n+#else\n       /**\n        *  @brief Erases an element from a %multimap.\n        *  @param  position  An iterator pointing to the element to be erased.\n@@ -501,6 +521,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       void\n       erase(iterator __position)\n       { _M_t.erase(__position); }\n+#endif\n \n       /**\n        *  @brief Erases elements according to the provided key.\n@@ -517,6 +538,27 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       erase(const key_type& __x)\n       { return _M_t.erase(__x); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // DR 130. Associative erase should return an iterator.\n+      /**\n+       *  @brief Erases a [first,last) range of elements from a %multimap.\n+       *  @param  first  Iterator pointing to the start of the range to be\n+       *                 erased.\n+       *  @param  last  Iterator pointing to the end of the range to be erased.\n+       *  @return The iterator @a last.\n+       *\n+       *  This function erases a sequence of elements from a %multimap.\n+       *  Note that this function only erases the elements, and that if\n+       *  the elements themselves are pointers, the pointed-to memory is not\n+       *  touched in any way.  Managing the pointer is the user's responsibility.\n+       */\n+      iterator\n+      erase(iterator __first, iterator __last)\n+      { return _M_t.erase(__first, __last); }\n+#else\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // DR 130. Associative erase should return an iterator.\n       /**\n        *  @brief Erases a [first,last) range of elements from a %multimap.\n        *  @param  first  Iterator pointing to the start of the range to be\n@@ -531,6 +573,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       void\n       erase(iterator __first, iterator __last)\n       { _M_t.erase(__first, __last); }\n+#endif\n \n       /**\n        *  @brief  Swaps data with another %multimap."}, {"sha": "431cbae430281297cb7acd184915008ce0b18a82", "filename": "libstdc++-v3/include/bits/stl_multiset.h", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c105751c468d9a05fb65ad1a22b8899dc1a1ae51/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c105751c468d9a05fb65ad1a22b8899dc1a1ae51/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h?ref=c105751c468d9a05fb65ad1a22b8899dc1a1ae51", "patch": "@@ -445,6 +445,26 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       { this->insert(__l.begin(), __l.end()); }\n #endif\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // DR 130. Associative erase should return an iterator.\n+      /**\n+       *  @brief Erases an element from a %multiset.\n+       *  @param  position  An iterator pointing to the element to be erased.\n+       *  @return An iterator pointing to the element immediately following\n+       *          @a position prior to the element being erased. If no such \n+       *          element exists, end() is returned.\n+       *\n+       *  This function erases an element, pointed to by the given iterator,\n+       *  from a %multiset.  Note that this function only erases the element,\n+       *  and that if the element is itself a pointer, the pointed-to memory is\n+       *  not touched in any way.  Managing the pointer is the user's\n+       *  responsibility.\n+       */\n+      iterator\n+      erase(iterator __position)\n+      { return _M_t.erase(__position); }\n+#else\n       /**\n        *  @brief Erases an element from a %multiset.\n        *  @param  position  An iterator pointing to the element to be erased.\n@@ -458,6 +478,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       void\n       erase(iterator __position)\n       { _M_t.erase(__position); }\n+#endif\n \n       /**\n        *  @brief Erases elements according to the provided key.\n@@ -474,6 +495,25 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       erase(const key_type& __x)\n       { return _M_t.erase(__x); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // DR 130. Associative erase should return an iterator.\n+      /**\n+       *  @brief Erases a [first,last) range of elements from a %multiset.\n+       *  @param  first  Iterator pointing to the start of the range to be\n+       *                 erased.\n+       *  @param  last  Iterator pointing to the end of the range to be erased.\n+       *  @return The iterator @a last.\n+       *\n+       *  This function erases a sequence of elements from a %multiset.\n+       *  Note that this function only erases the elements, and that if\n+       *  the elements themselves are pointers, the pointed-to memory is not\n+       *  touched in any way.  Managing the pointer is the user's responsibility.\n+       */\n+      iterator\n+      erase(iterator __first, iterator __last)\n+      { return _M_t.erase(__first, __last); }\n+#else\n       /**\n        *  @brief Erases a [first,last) range of elements from a %multiset.\n        *  @param  first  Iterator pointing to the start of the range to be\n@@ -488,6 +528,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       void\n       erase(iterator __first, iterator __last)\n       { _M_t.erase(__first, __last); }\n+#endif\n \n       /**\n        *  Erases all elements in a %multiset.  Note that this function only"}, {"sha": "e87cccbab7715eb635a6eeb64db8c393aec94971", "filename": "libstdc++-v3/include/bits/stl_set.h", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c105751c468d9a05fb65ad1a22b8899dc1a1ae51/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c105751c468d9a05fb65ad1a22b8899dc1a1ae51/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h?ref=c105751c468d9a05fb65ad1a22b8899dc1a1ae51", "patch": "@@ -458,6 +458,25 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       { this->insert(__l.begin(), __l.end()); }\n #endif\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // DR 130. Associative erase should return an iterator.\n+      /**\n+       *  @brief Erases an element from a %set.\n+       *  @param  position  An iterator pointing to the element to be erased.\n+       *  @return An iterator pointing to the element immediately following\n+       *          @a position prior to the element being erased. If no such \n+       *          element exists, end() is returned.\n+       *\n+       *  This function erases an element, pointed to by the given iterator,\n+       *  from a %set.  Note that this function only erases the element, and\n+       *  that if the element is itself a pointer, the pointed-to memory is not\n+       *  touched in any way.  Managing the pointer is the user's responsibility.\n+       */\n+      iterator\n+      erase(iterator __position)\n+      { return _M_t.erase(__position); }\n+#else\n       /**\n        *  @brief Erases an element from a %set.\n        *  @param  position  An iterator pointing to the element to be erased.\n@@ -470,6 +489,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       void\n       erase(iterator __position)\n       { _M_t.erase(__position); }\n+#endif\n \n       /**\n        *  @brief Erases elements according to the provided key.\n@@ -486,6 +506,25 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       erase(const key_type& __x)\n       { return _M_t.erase(__x); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // DR 130. Associative erase should return an iterator.\n+      /**\n+       *  @brief Erases a [first,last) range of elements from a %set.\n+       *  @param  first  Iterator pointing to the start of the range to be\n+       *                 erased.\n+       *  @param  last  Iterator pointing to the end of the range to be erased.\n+       *  @return The iterator @a last.\n+       *\n+       *  This function erases a sequence of elements from a %set.\n+       *  Note that this function only erases the element, and that if\n+       *  the element is itself a pointer, the pointed-to memory is not touched\n+       *  in any way.  Managing the pointer is the user's responsibility.\n+       */\n+      iterator\n+      erase(iterator __first, iterator __last)\n+      { return _M_t.erase(__first, __last); }\n+#else\n       /**\n        *  @brief Erases a [first,last) range of elements from a %set.\n        *  @param  first  Iterator pointing to the start of the range to be\n@@ -500,6 +539,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       void\n       erase(iterator __first, iterator __last)\n       { _M_t.erase(__first, __last); }\n+#endif\n \n       /**\n        *  Erases all elements in a %set.  Note that this function only erases"}, {"sha": "d37dc57246e4c8a0b1644df497748bdb10b054f5", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 108, "deletions": 2, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c105751c468d9a05fb65ad1a22b8899dc1a1ae51/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c105751c468d9a05fb65ad1a22b8899dc1a1ae51/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=c105751c468d9a05fb65ad1a22b8899dc1a1ae51", "patch": "@@ -698,21 +698,43 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n         void\n         _M_insert_equal(_InputIterator __first, _InputIterator __last);\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // DR 130. Associative erase should return an iterator.\n+      iterator\n+      erase(iterator __position);\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // DR 130. Associative erase should return an iterator.\n+      const_iterator\n+      erase(const_iterator __position);\n+#else\n       void\n       erase(iterator __position);\n \n       void\n       erase(const_iterator __position);\n-\n+#endif\n       size_type\n       erase(const key_type& __x);\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // DR 130. Associative erase should return an iterator.\n+      iterator\n+      erase(iterator __first, iterator __last);\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // DR 130. Associative erase should return an iterator.\n+      const_iterator\n+      erase(const_iterator __first, const_iterator __last);\n+#else\n       void\n       erase(iterator __first, iterator __last);\n \n       void\n       erase(const_iterator __first, const_iterator __last);\n-\n+#endif\n       void\n       erase(const key_type* __first, const key_type* __last);\n \n@@ -1327,6 +1349,45 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t  _M_insert_equal_(end(), *__first);\n       }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+  // DR 130. Associative erase should return an iterator.\n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+           typename _Compare, typename _Alloc>\n+    inline typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+    erase(iterator __position)\n+    {\n+      iterator __result = __position;\n+      ++__result;\n+      _Link_type __y =\n+\tstatic_cast<_Link_type>(_Rb_tree_rebalance_for_erase\n+\t\t\t\t(__position._M_node,\n+\t\t\t\t this->_M_impl._M_header));\n+      _M_destroy_node(__y);\n+      --_M_impl._M_node_count;\n+      return __result;\n+    }\n+\n+  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+  // DR 130. Associative erase should return an iterator.\n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+           typename _Compare, typename _Alloc>\n+    inline typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+    erase(const_iterator __position)\n+    {\n+      const_iterator __result = __position;\n+      ++__result;\n+      _Link_type __y =\n+\tstatic_cast<_Link_type>(_Rb_tree_rebalance_for_erase\n+\t\t\t\t(const_cast<_Base_ptr>(__position._M_node),\n+\t\t\t\t this->_M_impl._M_header));\n+      _M_destroy_node(__y);\n+      --_M_impl._M_node_count;\n+      return __result;\n+    }\n+#else\n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     inline void\n@@ -1354,6 +1415,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       _M_destroy_node(__y);\n       --_M_impl._M_node_count;\n     }\n+#endif\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n@@ -1367,6 +1429,49 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       return __old_size - size();\n     }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+  // DR 130. Associative erase should return an iterator.\n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+           typename _Compare, typename _Alloc>\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+    erase(iterator __first, iterator __last)\n+    {\n+      if (__first == begin() && __last == end())\n+        {\n+\t  clear();\n+\t  return end();\n+        }\n+      else\n+        {\n+\t  while (__first != __last)\n+\t    erase(__first++);\n+\t  return __last;\n+        }\n+    }\n+\n+  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+  // DR 130. Associative erase should return an iterator.\n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+           typename _Compare, typename _Alloc>\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+    erase(const_iterator __first, const_iterator __last)\n+    {\n+      if (__first == begin() && __last == end())\n+        {\n+\t  clear();\n+\t  return end();\n+        }\n+      else\n+        {\n+\t  while (__first != __last)\n+\t    erase(__first++);\n+\t  return __last;\n+        }\n+    }\n+#else\n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     void\n@@ -1392,6 +1497,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \twhile (__first != __last)\n \t  erase(__first++);\n     }\n+#endif\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>"}, {"sha": "d7f3c2b08561eb1216e58d023fcaae8fc7adca4a", "filename": "libstdc++-v3/testsuite/23_containers/map/dr130.cc", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c105751c468d9a05fb65ad1a22b8899dc1a1ae51/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fdr130.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c105751c468d9a05fb65ad1a22b8899dc1a1ae51/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fdr130.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fdr130.cc?ref=c105751c468d9a05fb65ad1a22b8899dc1a1ae51", "patch": "@@ -0,0 +1,77 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// 2008-07-22  Edward Smith-Rowland  <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <map>\n+#include <testsuite_hooks.h>\n+\n+//  DR 130. Associative erase should return an iterator.\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  map<int, int> m0;\n+  typedef map<int, int>::iterator iterator;\n+  typedef map<int, int>::const_iterator const_iterator;\n+  typedef map<int, int>::value_type value_type;\n+  typedef pair<iterator, bool> insert_return_type;\n+\n+  insert_return_type irt0 = m0.insert(value_type(1, 1));\n+  insert_return_type irt1 = m0.insert(value_type(2, 2));\n+  insert_return_type irt2 = m0.insert(value_type(3, 3));\n+\n+  iterator pos1 = m0.erase(irt1.first);\n+  VERIFY( pos1 == irt2.first );\n+\n+  iterator pos2 = m0.erase(irt2.first);\n+  VERIFY( pos2 == m0.end() );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  map<int, int> m0;\n+  typedef map<int, int>::iterator iterator;\n+  typedef map<int, int>::const_iterator const_iterator;\n+  typedef map<int, int>::value_type value_type;\n+  typedef pair<iterator, bool> insert_return_type;\n+\n+  insert_return_type irt0 = m0.insert(value_type(1, 1));\n+  insert_return_type irt1 = m0.insert(value_type(2, 2));\n+  insert_return_type irt2 = m0.insert(value_type(3, 3));\n+  insert_return_type irt3 = m0.insert(value_type(4, 4));\n+\n+  iterator pos1 = m0.erase(irt0.first, irt2.first);\n+  VERIFY( pos1 == irt2.first );\n+\n+  iterator pos2 = m0.erase(irt2.first, ++irt3.first);\n+  VERIFY( pos2 == m0.end() );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "08684870642c9369bc0383a7cde28d3a237e3df8", "filename": "libstdc++-v3/testsuite/23_containers/multimap/dr130.cc", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c105751c468d9a05fb65ad1a22b8899dc1a1ae51/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fdr130.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c105751c468d9a05fb65ad1a22b8899dc1a1ae51/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fdr130.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fdr130.cc?ref=c105751c468d9a05fb65ad1a22b8899dc1a1ae51", "patch": "@@ -0,0 +1,87 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+\n+// NOTE: This makes use of the fact that we know how moveable\n+// is implemented on multiset (via swap). If the implementation changed\n+// this test may begin to fail.\n+\n+#include <map>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+using namespace std;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  multimap<int, int> mm0;\n+  typedef multimap<int, int>::iterator iterator;\n+  typedef multimap<int, int>::const_iterator const_iterator;\n+  typedef multimap<int, int>::value_type value_type;\n+  typedef iterator insert_return_type;\n+\n+  vector<insert_return_type> irt;\n+  for (int i = 1; i <= 4; ++i)\n+    for (int j = 1; j <= i; ++j)\n+      irt.push_back( mm0.insert( value_type( i, i ) ) );\n+\n+  iterator pos1 = mm0.erase(irt[1]);\n+  VERIFY( pos1 == irt[2] );\n+\n+  iterator pos2 = mm0.erase(irt[2]);\n+  VERIFY( pos2 == irt[3] );\n+\n+  iterator pos3 = mm0.erase(irt[9]);\n+  VERIFY( pos3 == mm0.end() );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  multimap<int, int> mm0;\n+  typedef multimap<int, int>::iterator iterator;\n+  typedef multimap<int, int>::const_iterator const_iterator;\n+  typedef multimap<int, int>::value_type value_type;\n+  typedef iterator insert_return_type;\n+\n+  vector<insert_return_type> irt;\n+  for (int i = 1; i <= 4; ++i)\n+    for (int j = 1; j <= i; ++j)\n+      irt.push_back( mm0.insert( value_type( i, i ) ) );\n+\n+  iterator pos1 = mm0.erase(irt[3], irt[6]);\n+  VERIFY( pos1 == irt[6] );\n+\n+  iterator pos2 = mm0.erase(irt[6], ++irt[9]);\n+  VERIFY( pos2 == mm0.end() );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "52392fcc153b3387b08399900207739c2fbbf866", "filename": "libstdc++-v3/testsuite/23_containers/multiset/dr130.cc", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c105751c468d9a05fb65ad1a22b8899dc1a1ae51/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fdr130.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c105751c468d9a05fb65ad1a22b8899dc1a1ae51/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fdr130.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fdr130.cc?ref=c105751c468d9a05fb65ad1a22b8899dc1a1ae51", "patch": "@@ -0,0 +1,85 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+\n+// NOTE: This makes use of the fact that we know how moveable\n+// is implemented on multiset (via swap). If the implementation changed\n+// this test may begin to fail.\n+\n+#include <set>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+using namespace std;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  multiset<int> ms0;\n+  typedef multiset<int>::iterator iterator;\n+  typedef multiset<int>::const_iterator const_iterator;\n+  typedef iterator insert_return_type;\n+\n+  vector<insert_return_type> irt;\n+  for ( int i = 1; i <= 4; ++i )\n+    for (int j = 1; j <= i; ++j)\n+      irt.push_back( ms0.insert( i ) );\n+\n+  iterator pos1 = ms0.erase(irt[1]);\n+  VERIFY( pos1 == irt[2] );\n+\n+  iterator pos2 = ms0.erase(irt[2]);\n+  VERIFY( pos2 == irt[3] );\n+\n+  iterator pos3 = ms0.erase(irt[9]);\n+  VERIFY( pos3 == ms0.end() );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  multiset<int> ms0;\n+  typedef multiset<int>::iterator iterator;\n+  typedef multiset<int>::const_iterator const_iterator;\n+  typedef iterator insert_return_type;\n+\n+  vector<insert_return_type> irt;\n+  for ( int i = 1; i <= 4; ++i )\n+    for (int j = 1; j <= i; ++j)\n+      irt.push_back( ms0.insert( i ) );\n+\n+  iterator pos1 = ms0.erase(irt[3], irt[6]);\n+  VERIFY( pos1 == irt[6] );\n+\n+  iterator pos2 = ms0.erase(irt[6], ++irt[9]);\n+  VERIFY( pos2 == ms0.end() );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "1904dcdc0bdea1f4f34b820c64e697015f4c57be", "filename": "libstdc++-v3/testsuite/23_containers/set/dr130.cc", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c105751c468d9a05fb65ad1a22b8899dc1a1ae51/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fdr130.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c105751c468d9a05fb65ad1a22b8899dc1a1ae51/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fdr130.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fdr130.cc?ref=c105751c468d9a05fb65ad1a22b8899dc1a1ae51", "patch": "@@ -0,0 +1,75 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// 2008-07-22  Edward Smith-Rowland  <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <set>\n+#include <testsuite_hooks.h>\n+\n+//  DR 130. Associative erase should return an iterator.\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  set<int> s0;\n+  typedef set<int>::iterator iterator;\n+  typedef set<int>::const_iterator const_iterator;\n+  typedef pair<iterator, bool> insert_return_type;\n+\n+  insert_return_type irt0 = s0.insert(1);\n+  insert_return_type irt1 = s0.insert(2);\n+  insert_return_type irt2 = s0.insert(3);\n+\n+  iterator pos1 = s0.erase(irt1.first);\n+  VERIFY( pos1 == irt2.first );\n+\n+  iterator pos2 = s0.erase(irt2.first);\n+  VERIFY( pos2 == s0.end() );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  set<int> s0;\n+  typedef set<int>::iterator iterator;\n+  typedef set<int>::const_iterator const_iterator;\n+  typedef pair<iterator, bool> insert_return_type;\n+\n+  insert_return_type irt0 = s0.insert(1);\n+  insert_return_type irt1 = s0.insert(2);\n+  insert_return_type irt2 = s0.insert(3);\n+  insert_return_type irt3 = s0.insert(4);\n+\n+  iterator pos1 = s0.erase(irt0.first, irt2.first);\n+  VERIFY( pos1 == irt2.first );\n+\n+  iterator pos2 = s0.erase(irt2.first, ++irt3.first);\n+  VERIFY( pos2 == s0.end() );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}]}