{"sha": "2971780e404ebe8f3094c4d014b258b5c337959d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk3MTc4MGU0MDRlYmU4ZjMwOTRjNGQwMTRiMjU4YjVjMzM3OTU5ZA==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2015-12-17T14:09:55Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2015-12-17T14:09:55Z"}, "message": "DWARF: add a language hook for fixed-point types\n\nSupport for fixed-point types in GCC is not powerful enough for Ada\nfixed-point types: GNAT uses regular scalar types to implement them.\nThis new language hook makes it possible to output the desired debugging\ninformation anyway.\n\ngcc/ada/ChangeLog:\n\n\t* gcc-interface/ada-tree.def (POWER_EXPR): New binary operation.\n\t* gcc-interface/ada-tree.h (TYPE_FIXED_POINT_P): New macro.\n\t(TYPE_IS_FIXED_POINT_P): New macro.\n\t(TYPE_SCALE_FACTOR): New macro.\n\t(SET_TYPE_SCALE_FACTOR): New macro.\n\t* gcc-interface/decl.c: Include urealp.h\n\t(gnat_to_gnu_entity): Attach trees to encode scale factors to\n\tfixed-point types.\n\t* gcc-interface/misc.c (gnat_print_type): Print scale factors\n\tfor fixed-point types.\n\t(gnat_get_fixed_point_type_info): New.\n\t(gnat_init_ts): Initialize data for the POWER_EXPR binary\n\toperation.\n\t(LANG_HOOKS_GET_FIXED_POINT_INFO): Redefine macro to implement\n\tthe get_fixed_point_type_info language hook.\n\ngcc/ChangeLog:\n\n\t* langhooks.h (struct lang_hooks_for_types): Add a\n\tget_fixed_point_type_info field.\n\t* langhooks-def.h (LANG_HOOKS_GET_FIXED_POINT_TYPE_INFO): New\n\tmacro.\n\t(LANG_HOOKS_FOR_TYPES_INITIALIZER): Initialize the\n\tget_fixed_point_type_info field.\n\t* dwarf2out.h (enum fixed_point_scale_factor): New.\n\t(struct fixed_point_type_info): New.\n\t* dwarf2out.c (base_type_die): In DWARFv3 or non-strict DWARF\n\tmode, get fixed-point type information using the debugging hook\n\tand describe it in DWARF, if any.\n\nFrom-SVN: r231764", "tree": {"sha": "95d7a868396094336050add983f43966dd2afabf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95d7a868396094336050add983f43966dd2afabf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2971780e404ebe8f3094c4d014b258b5c337959d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2971780e404ebe8f3094c4d014b258b5c337959d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2971780e404ebe8f3094c4d014b258b5c337959d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2971780e404ebe8f3094c4d014b258b5c337959d/comments", "author": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "eb59e42800b805e0bcced98ad2383c66a5839acc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb59e42800b805e0bcced98ad2383c66a5839acc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb59e42800b805e0bcced98ad2383c66a5839acc"}], "stats": {"total": 298, "additions": 295, "deletions": 3}, "files": [{"sha": "964b0a375af5815b4525ba034973127b982d563e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2971780e404ebe8f3094c4d014b258b5c337959d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2971780e404ebe8f3094c4d014b258b5c337959d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2971780e404ebe8f3094c4d014b258b5c337959d", "patch": "@@ -1,3 +1,17 @@\n+2015-12-17  Pierre-Marie de Rodat  <derodat@adacore.com>\n+\n+\t* langhooks.h (struct lang_hooks_for_types): Add a\n+\tget_fixed_point_type_info field.\n+\t* langhooks-def.h (LANG_HOOKS_GET_FIXED_POINT_TYPE_INFO): New\n+\tmacro.\n+\t(LANG_HOOKS_FOR_TYPES_INITIALIZER): Initialize the\n+\tget_fixed_point_type_info field.\n+\t* dwarf2out.h (enum fixed_point_scale_factor): New.\n+\t(struct fixed_point_type_info): New.\n+\t* dwarf2out.c (base_type_die): In DWARFv3 or non-strict DWARF\n+\tmode, get fixed-point type information using the debugging hook\n+\tand describe it in DWARF, if any.\n+\n 2015-12-17  Pierre-Marie de Rodat  <derodat@adacore.com>\n \n \t* langhooks.h (struct lang_hooks_for_types): Add a"}, {"sha": "31a059f8e25594b90cd64a12b0edac23cfb48a06", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2971780e404ebe8f3094c4d014b258b5c337959d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2971780e404ebe8f3094c4d014b258b5c337959d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2971780e404ebe8f3094c4d014b258b5c337959d", "patch": "@@ -1,3 +1,21 @@\n+2015-12-17  Pierre-Marie de Rodat  <derodat@adacore.com>\n+\n+\t* gcc-interface/ada-tree.def (POWER_EXPR): New binary operation.\n+\t* gcc-interface/ada-tree.h (TYPE_FIXED_POINT_P): New macro.\n+\t(TYPE_IS_FIXED_POINT_P): New macro.\n+\t(TYPE_SCALE_FACTOR): New macro.\n+\t(SET_TYPE_SCALE_FACTOR): New macro.\n+\t* gcc-interface/decl.c: Include urealp.h\n+\t(gnat_to_gnu_entity): Attach trees to encode scale factors to\n+\tfixed-point types.\n+\t* gcc-interface/misc.c (gnat_print_type): Print scale factors\n+\tfor fixed-point types.\n+\t(gnat_get_fixed_point_type_info): New.\n+\t(gnat_init_ts): Initialize data for the POWER_EXPR binary\n+\toperation.\n+\t(LANG_HOOKS_GET_FIXED_POINT_INFO): Redefine macro to implement\n+\tthe get_fixed_point_type_info language hook.\n+\n 2015-12-17  Pierre-Marie de Rodat  <derodat@adacore.com>\n \n \t* gcc-interface/ada-tree.h (struct lang_type): Rename the t"}, {"sha": "8eb4688e749cbf7381b19ae29acc691830249383", "filename": "gcc/ada/gcc-interface/ada-tree.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2971780e404ebe8f3094c4d014b258b5c337959d/gcc%2Fada%2Fgcc-interface%2Fada-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2971780e404ebe8f3094c4d014b258b5c337959d/gcc%2Fada%2Fgcc-interface%2Fada-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.def?ref=2971780e404ebe8f3094c4d014b258b5c337959d", "patch": "@@ -47,6 +47,11 @@ DEFTREECODE (PLUS_NOMOD_EXPR, \"plus_nomod_expr\", tcc_binary, 2)\n    This is used for loops and never shows up in the tree.  */\n DEFTREECODE (MINUS_NOMOD_EXPR, \"minus_nomod_expr\", tcc_binary, 2)\n \n+/* An expression that computes an exponentiation.  Operand 0 is the base and\n+   Operand 1 is the exponent.  This node is never passed to GCC: it is only\n+   used internally to describe fixed point types scale factors.  */\n+DEFTREECODE (POWER_EXPR, \"power_expr\", tcc_binary, 2)\n+\n /* Same as ADDR_EXPR, except that if the operand represents a bit field,\n    return the address of the byte containing the bit.  This is used\n    for the Address attribute and never shows up in the tree.  */"}, {"sha": "709fdc27061b7654c2591cd1f2ea69f97fb41600", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2971780e404ebe8f3094c4d014b258b5c337959d/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2971780e404ebe8f3094c4d014b258b5c337959d/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=2971780e404ebe8f3094c4d014b258b5c337959d", "patch": "@@ -126,6 +126,13 @@ do {\t\t\t\t\t\t\t \\\n #define TYPE_CONTAINS_TEMPLATE_P(NODE) \\\n   TYPE_LANG_FLAG_3 (RECORD_OR_UNION_CHECK (NODE))\n \n+/* For INTEGER_TYPE, nonzero if it implements a fixed-point type.  */\n+#define TYPE_FIXED_POINT_P(NODE) \\\n+  TYPE_LANG_FLAG_3 (INTEGER_TYPE_CHECK (NODE))\n+\n+#define TYPE_IS_FIXED_POINT_P(NODE) \\\n+  (TREE_CODE (NODE) == INTEGER_TYPE && TYPE_FIXED_POINT_P (NODE))\n+\n /* True if NODE is a thin pointer.  */\n #define TYPE_IS_THIN_POINTER_P(NODE)\t\t\t\\\n   (POINTER_TYPE_P (NODE)\t\t\t\t\\\n@@ -358,6 +365,16 @@ do {\t\t\t\t\t\t   \\\n #define SET_TYPE_DEBUG_TYPE(NODE, X) \\\n   SET_TYPE_LANG_SPECIFIC2(NODE, X)\n \n+/* For an INTEGER_TYPE with TYPE_IS_FIXED_POINT_P, this is the value of the\n+   scale factor.  Modular types, index types (sizetype subtypes) and\n+   fixed-point types are totally distinct types, so there is no problem with\n+   sharing type lang specific's first slot.  */\n+#define TYPE_SCALE_FACTOR(NODE) \\\n+  GET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))\n+#define SET_TYPE_SCALE_FACTOR(NODE, X) \\\n+  SET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE), X)\n+\n+\n /* Flags added to decl nodes.  */\n \n /* Nonzero in a FUNCTION_DECL that represents a stubbed function"}, {"sha": "760c7f439f14b956f9ace85f4c62c0106726cd73", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 70, "deletions": 2, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2971780e404ebe8f3094c4d014b258b5c337959d/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2971780e404ebe8f3094c4d014b258b5c337959d/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=2971780e404ebe8f3094c4d014b258b5c337959d", "patch": "@@ -44,6 +44,7 @@\n #include \"repinfo.h\"\n #include \"snames.h\"\n #include \"uintp.h\"\n+#include \"urealp.h\"\n #include \"fe.h\"\n #include \"sinfo.h\"\n #include \"einfo.h\"\n@@ -1619,13 +1620,80 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       break;\n \n     case E_Signed_Integer_Type:\n-    case E_Ordinary_Fixed_Point_Type:\n-    case E_Decimal_Fixed_Point_Type:\n       /* For integer types, just make a signed type the appropriate number\n \t of bits.  */\n       gnu_type = make_signed_type (esize);\n       goto discrete_type;\n \n+    case E_Ordinary_Fixed_Point_Type:\n+    case E_Decimal_Fixed_Point_Type:\n+      {\n+\t/* Small_Value is the scale factor.  */\n+\tconst Ureal gnat_small_value = Small_Value (gnat_entity);\n+\ttree scale_factor = NULL_TREE;\n+\n+\tgnu_type = make_signed_type (esize);\n+\n+\t/* Try to decode the scale factor and to save it for the fixed-point\n+\t   types debug hook.  */\n+\n+\t/* There are various ways to describe the scale factor, however there\n+\t   are cases where back-end internals cannot hold it.  In such cases,\n+\t   we output invalid scale factor for such cases (i.e. the 0/0\n+\t   rational constant) but we expect GNAT to output GNAT encodings,\n+\t   then.  Thus, keep this in sync with\n+\t   Exp_Dbug.Is_Handled_Scale_Factor.  */\n+\n+\t/* When encoded as 1/2**N or 1/10**N, describe the scale factor as a\n+\t   binary or decimal scale: it is easier to read for humans.  */\n+\tif (UI_Eq (Numerator (gnat_small_value), Uint_1)\n+\t    && (Rbase (gnat_small_value) == 2\n+\t\t|| Rbase (gnat_small_value) == 10))\n+\t  {\n+\t    /* Given RM restrictions on 'Small values, we assume here that\n+\t       the denominator fits in an int.  */\n+\t    const tree base = build_int_cst (integer_type_node,\n+\t\t\t\t\t     Rbase (gnat_small_value));\n+\t    const tree exponent\n+\t      = build_int_cst (integer_type_node,\n+\t\t\t       UI_To_Int (Denominator (gnat_small_value)));\n+\t    scale_factor\n+\t      = build2 (RDIV_EXPR, integer_type_node,\n+\t\t\tinteger_one_node,\n+\t\t\tbuild2 (POWER_EXPR, integer_type_node,\n+\t\t\t\tbase, exponent));\n+\t  }\n+\n+\t/* Default to arbitrary scale factors descriptions.  */\n+\telse\n+\t  {\n+\t    const Uint num = Norm_Num (gnat_small_value);\n+\t    const Uint den = Norm_Den (gnat_small_value);\n+\n+\t    if (UI_Is_In_Int_Range (num) && UI_Is_In_Int_Range (den))\n+\t      {\n+\t\tconst tree gnu_num\n+\t\t  = build_int_cst (integer_type_node,\n+\t\t\t\t   UI_To_Int (Norm_Num (gnat_small_value)));\n+\t\tconst tree gnu_den\n+\t\t  = build_int_cst (integer_type_node,\n+\t\t\t\t   UI_To_Int (Norm_Den (gnat_small_value)));\n+\t\tscale_factor = build2 (RDIV_EXPR, integer_type_node,\n+\t\t\t\t       gnu_num, gnu_den);\n+\t      }\n+\t    else\n+\t      /* If compiler internals cannot represent arbitrary scale\n+\t\t factors, output an invalid scale factor so that debugger\n+\t\t don't try to handle them but so that we still have a type\n+\t\t in the output.  Note that GNAT  */\n+\t      scale_factor = integer_zero_node;\n+\t  }\n+\n+\tTYPE_FIXED_POINT_P (gnu_type) = 1;\n+\tSET_TYPE_SCALE_FACTOR (gnu_type, scale_factor);\n+      }\n+      goto discrete_type;\n+\n     case E_Modular_Integer_Type:\n       {\n \t/* For modular types, make the unsigned type of the proper number"}, {"sha": "48e98fd583c0e829298f8c5215b2a4ddc711cd68", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2971780e404ebe8f3094c4d014b258b5c337959d/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2971780e404ebe8f3094c4d014b258b5c337959d/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=2971780e404ebe8f3094c4d014b258b5c337959d", "patch": "@@ -480,6 +480,9 @@ gnat_print_type (FILE *file, tree node, int indent)\n     case INTEGER_TYPE:\n       if (TYPE_MODULAR_P (node))\n \tprint_node_brief (file, \"modulus\", TYPE_MODULUS (node), indent + 4);\n+      else if (TYPE_FIXED_POINT_P (node))\n+\tprint_node (file, \"scale factor\", TYPE_SCALE_FACTOR (node),\n+\t\t    indent + 4);\n       else if (TYPE_HAS_ACTUAL_BOUNDS_P (node))\n \tprint_node (file, \"actual bounds\", TYPE_ACTUAL_BOUNDS (node),\n \t\t    indent + 4);\n@@ -578,6 +581,81 @@ gnat_get_debug_type (const_tree type)\n   return TYPE_DEBUG_TYPE (type);\n }\n \n+/* Provide information in INFO for debugging output about the TYPE fixed-point\n+   type.  Return whether TYPE is handled.  */\n+\n+static bool\n+gnat_get_fixed_point_type_info (const_tree type,\n+\t\t\t\tstruct fixed_point_type_info *info)\n+{\n+  tree scale_factor;\n+\n+  /* GDB cannot handle fixed-point types yet, so rely on GNAT encodings\n+     instead for it.  */\n+  if (gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL\n+      || !TYPE_IS_FIXED_POINT_P (type))\n+    return false;\n+\n+  scale_factor = TYPE_SCALE_FACTOR (type);\n+\n+  /* We expect here only a finite set of pattern.  See fixed-point types\n+     handling in gnat_to_gnu_entity.  */\n+\n+  /* Put invalid values when compiler internals cannot represent the scale\n+     factor.  */\n+  if (scale_factor == integer_zero_node)\n+    {\n+      info->scale_factor_kind = fixed_point_scale_factor_arbitrary;\n+      info->scale_factor.arbitrary.numerator = 0;\n+      info->scale_factor.arbitrary.denominator = 0;\n+      return true;\n+    }\n+\n+  if (TREE_CODE (scale_factor) == RDIV_EXPR)\n+    {\n+      const tree num = TREE_OPERAND (scale_factor, 0);\n+      const tree den = TREE_OPERAND (scale_factor, 1);\n+\n+      /* See if we have a binary or decimal scale.  */\n+      if (TREE_CODE (den) == POWER_EXPR)\n+\t{\n+\t  const tree base = TREE_OPERAND (den, 0);\n+\t  const tree exponent = TREE_OPERAND (den, 1);\n+\n+\t  /* We expect the scale factor to be 1 / 2 ** N or 1 / 10 ** N.  */\n+\t  gcc_assert (num == integer_one_node\n+\t\t      && TREE_CODE (base) == INTEGER_CST\n+\t\t      && TREE_CODE (exponent) == INTEGER_CST);\n+\t  switch (tree_to_shwi (base))\n+\t    {\n+\t    case 2:\n+\t      info->scale_factor_kind = fixed_point_scale_factor_binary;\n+\t      info->scale_factor.binary = -tree_to_shwi (exponent);\n+\t      return true;\n+\n+\t    case 10:\n+\t      info->scale_factor_kind = fixed_point_scale_factor_decimal;\n+\t      info->scale_factor.decimal = -tree_to_shwi (exponent);\n+\t      return true;\n+\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t}\n+\n+      /* If we reach this point, we are handling an arbitrary scale factor.  We\n+\t expect N / D with constant operands.  */\n+      gcc_assert (TREE_CODE (num) == INTEGER_CST\n+\t\t  && TREE_CODE (den) == INTEGER_CST);\n+      info->scale_factor_kind = fixed_point_scale_factor_arbitrary;\n+      info->scale_factor.arbitrary.numerator = tree_to_uhwi (num);\n+      info->scale_factor.arbitrary.denominator = tree_to_shwi (den);\n+      return true;\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n /* Return true if types T1 and T2 are identical for type hashing purposes.\n    Called only after doing all language independent checks.  At present,\n    this function is only called when both types are FUNCTION_TYPE.  */\n@@ -981,6 +1059,7 @@ gnat_init_ts (void)\n   MARK_TS_TYPED (NULL_EXPR);\n   MARK_TS_TYPED (PLUS_NOMOD_EXPR);\n   MARK_TS_TYPED (MINUS_NOMOD_EXPR);\n+  MARK_TS_TYPED (POWER_EXPR);\n   MARK_TS_TYPED (ATTR_ADDR_EXPR);\n   MARK_TS_TYPED (STMT_STMT);\n   MARK_TS_TYPED (LOOP_STMT);\n@@ -1052,6 +1131,9 @@ get_lang_specific (tree node)\n #define LANG_HOOKS_DESCRIPTIVE_TYPE\tgnat_descriptive_type\n #undef  LANG_HOOKS_GET_DEBUG_TYPE\n #define LANG_HOOKS_GET_DEBUG_TYPE\tgnat_get_debug_type\n+#undef  LANG_HOOKS_GET_FIXED_POINT_TYPE_INFO\n+#define LANG_HOOKS_GET_FIXED_POINT_TYPE_INFO \\\n+\t\t\t\t\tgnat_get_fixed_point_type_info\n #undef  LANG_HOOKS_ATTRIBUTE_TABLE\n #define LANG_HOOKS_ATTRIBUTE_TABLE\tgnat_internal_attribute_table\n #undef  LANG_HOOKS_BUILTIN_FUNCTION"}, {"sha": "538b76dd8788afba1337f68a04e52715e296dcc5", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2971780e404ebe8f3094c4d014b258b5c337959d/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2971780e404ebe8f3094c4d014b258b5c337959d/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=2971780e404ebe8f3094c4d014b258b5c337959d", "patch": "@@ -10807,6 +10807,8 @@ base_type_die (tree type)\n {\n   dw_die_ref base_type_result;\n   enum dwarf_type encoding;\n+  bool fpt_used = false;\n+  struct fixed_point_type_info fpt_info;\n \n   if (TREE_CODE (type) == ERROR_MARK || TREE_CODE (type) == VOID_TYPE)\n     return 0;\n@@ -10833,6 +10835,19 @@ base_type_die (tree type)\n \t      break;\n \t    }\n \t}\n+      if ((dwarf_version >= 3 || !dwarf_strict)\n+\t  && lang_hooks.types.get_fixed_point_type_info)\n+\t{\n+\t  memset (&fpt_info, 0, sizeof (fpt_info));\n+\t  if (lang_hooks.types.get_fixed_point_type_info (type, &fpt_info))\n+\t    {\n+\t      fpt_used = true;\n+\t      encoding = ((TYPE_UNSIGNED (type))\n+\t\t\t  ? DW_ATE_unsigned_fixed\n+\t\t\t  : DW_ATE_signed_fixed);\n+\t      break;\n+\t    }\n+\t}\n       if (TYPE_STRING_FLAG (type))\n \t{\n \t  if (TYPE_UNSIGNED (type))\n@@ -10891,6 +10906,43 @@ base_type_die (tree type)\n   add_AT_unsigned (base_type_result, DW_AT_byte_size,\n \t\t   int_size_in_bytes (type));\n   add_AT_unsigned (base_type_result, DW_AT_encoding, encoding);\n+\n+  if (fpt_used)\n+    {\n+      switch (fpt_info.scale_factor_kind)\n+\t{\n+\tcase fixed_point_scale_factor_binary:\n+\t  add_AT_int (base_type_result, DW_AT_binary_scale,\n+\t\t      fpt_info.scale_factor.binary);\n+\t  break;\n+\n+\tcase fixed_point_scale_factor_decimal:\n+\t  add_AT_int (base_type_result, DW_AT_decimal_scale,\n+\t\t      fpt_info.scale_factor.decimal);\n+\t  break;\n+\n+\tcase fixed_point_scale_factor_arbitrary:\n+\t  /* Arbitrary scale factors cannot be described in standard DWARF,\n+\t     yet.  */\n+\t  if (!dwarf_strict)\n+\t    {\n+\t      /* Describe the scale factor as a rational constant.  */\n+\t      const dw_die_ref scale_factor\n+\t\t= new_die (DW_TAG_constant, comp_unit_die (), type);\n+\n+\t      add_AT_unsigned (scale_factor, DW_AT_GNU_numerator,\n+\t\t\t       fpt_info.scale_factor.arbitrary.numerator);\n+\t      add_AT_int (scale_factor, DW_AT_GNU_denominator,\n+\t\t\t  fpt_info.scale_factor.arbitrary.denominator);\n+\n+\t      add_AT_die_ref (base_type_result, DW_AT_small, scale_factor);\n+\t    }\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n   add_pubtype (type, base_type_result);\n \n   return base_type_result;"}, {"sha": "91730766bebf2843396f07cbb5dacdc911a7de71", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2971780e404ebe8f3094c4d014b258b5c337959d/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2971780e404ebe8f3094c4d014b258b5c337959d/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=2971780e404ebe8f3094c4d014b258b5c337959d", "patch": "@@ -342,6 +342,35 @@ struct array_descr_info\n     } dimen[10];\n };\n \n+enum fixed_point_scale_factor\n+{\n+  fixed_point_scale_factor_binary,\n+  fixed_point_scale_factor_decimal,\n+  fixed_point_scale_factor_arbitrary\n+};\n+\n+struct fixed_point_type_info\n+{\n+  /* A scale factor is the value one has to multiply with physical data in\n+     order to get the fixed point logical data.  The DWARF standard enables one\n+     to encode it in three ways.  */\n+  enum fixed_point_scale_factor scale_factor_kind;\n+  union\n+    {\n+      /* For binary scale factor, the scale factor is: 2 ** binary.  */\n+      int binary;\n+      /* For decimal scale factor, the scale factor is: 10 ** binary.  */\n+      int decimal;\n+      /* For arbitrary scale factor, the scale factor is:\n+\t numerator / denominator.  */\n+      struct\n+\t{\n+\t  unsigned HOST_WIDE_INT numerator;\n+\t  HOST_WIDE_INT denominator;\n+\t} arbitrary;\n+    } scale_factor;\n+};\n+\n void dwarf2out_c_finalize (void);\n \n #endif /* GCC_DWARF2OUT_H */"}, {"sha": "2d02bf631d018d46ef881b78ddb92559201d1d11", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2971780e404ebe8f3094c4d014b258b5c337959d/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2971780e404ebe8f3094c4d014b258b5c337959d/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=2971780e404ebe8f3094c4d014b258b5c337959d", "patch": "@@ -177,6 +177,7 @@ extern tree lhd_make_node (enum tree_code);\n #define LANG_HOOKS_RECONSTRUCT_COMPLEX_TYPE reconstruct_complex_type\n #define LANG_HOOKS_ENUM_UNDERLYING_BASE_TYPE lhd_enum_underlying_base_type\n #define LANG_HOOKS_GET_DEBUG_TYPE\tNULL\n+#define LANG_HOOKS_GET_FIXED_POINT_TYPE_INFO NULL\n \n #define LANG_HOOKS_FOR_TYPES_INITIALIZER { \\\n   LANG_HOOKS_MAKE_TYPE, \\\n@@ -197,7 +198,8 @@ extern tree lhd_make_node (enum tree_code);\n   LANG_HOOKS_DESCRIPTIVE_TYPE, \\\n   LANG_HOOKS_RECONSTRUCT_COMPLEX_TYPE, \\\n   LANG_HOOKS_ENUM_UNDERLYING_BASE_TYPE, \\\n-  LANG_HOOKS_GET_DEBUG_TYPE \\\n+  LANG_HOOKS_GET_DEBUG_TYPE, \\\n+  LANG_HOOKS_GET_FIXED_POINT_TYPE_INFO \\\n }\n \n /* Declaration hooks.  */"}, {"sha": "f84bdf64bf4d95116bd3fd796b1dd4eeab10b6a7", "filename": "gcc/langhooks.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2971780e404ebe8f3094c4d014b258b5c337959d/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2971780e404ebe8f3094c4d014b258b5c337959d/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=2971780e404ebe8f3094c4d014b258b5c337959d", "patch": "@@ -149,6 +149,11 @@ struct lang_hooks_for_types\n      middle-end uses specialized types, for instance constrained discriminated\n      types in Ada.  */\n   tree (*get_debug_type) (const_tree);\n+\n+  /* Return TRUE if TYPE implements a fixed point type and fills in information\n+     for the debugger about scale factor, etc.  */\n+  bool (*get_fixed_point_type_info) (const_tree,\n+\t\t\t\t     struct fixed_point_type_info *);\n };\n \n /* Language hooks related to decls and the symbol table.  */"}]}