{"sha": "1d7542406205f9c697af04895250fa890cbdc356", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQ3NTQyNDA2MjA1ZjljNjk3YWYwNDg5NTI1MGZhODkwY2JkYzM1Ng==", "commit": {"author": {"name": "Paul Brook", "email": "paul@codesourcery.com", "date": "2004-08-14T15:35:51Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2004-08-14T15:35:51Z"}, "message": "* trans-decl.c (gfc_build_function_decl): Remove dead code.\n\nFrom-SVN: r85996", "tree": {"sha": "f61cf15bb91c63b8c42438b99410e5fe001a59f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f61cf15bb91c63b8c42438b99410e5fe001a59f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d7542406205f9c697af04895250fa890cbdc356", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d7542406205f9c697af04895250fa890cbdc356", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d7542406205f9c697af04895250fa890cbdc356", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d7542406205f9c697af04895250fa890cbdc356/comments", "author": null, "committer": null, "parents": [{"sha": "37de1373273fb26c2c2e01960092936bcf01047e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37de1373273fb26c2c2e01960092936bcf01047e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37de1373273fb26c2c2e01960092936bcf01047e"}], "stats": {"total": 232, "additions": 116, "deletions": 116}, "files": [{"sha": "9bea25a35dd1983b3cf7920309e2412218a27164", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d7542406205f9c697af04895250fa890cbdc356/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d7542406205f9c697af04895250fa890cbdc356/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=1d7542406205f9c697af04895250fa890cbdc356", "patch": "@@ -1,3 +1,7 @@\n+2004-08-14  Paul Brook  <paul@codesourcery.com>\n+\n+\t* trans-decl.c (gfc_build_function_decl): Remove dead code.\n+\n 2004-08-14  Paul Brook  <paul@codesourcery.com>\n \n \t* trans-arry.c (gfc_trans_auto_array_allocation): Remove unused var."}, {"sha": "e2707b4a98b0ca925ee6a2ce8c3c514a45dbe681", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 112, "deletions": 116, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d7542406205f9c697af04895250fa890cbdc356/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d7542406205f9c697af04895250fa890cbdc356/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=1d7542406205f9c697af04895250fa890cbdc356", "patch": "@@ -976,6 +976,7 @@ gfc_build_function_decl (gfc_symbol * sym)\n   tree length;\n   symbol_attribute attr;\n   gfc_formal_arglist *f;\n+  tree parm;\n \n   assert (!sym->backend_decl);\n   assert (!sym->attr.external);\n@@ -1049,14 +1050,13 @@ gfc_build_function_decl (gfc_symbol * sym)\n   DECL_CONTEXT (fndecl) = current_function_decl;\n   DECL_EXTERNAL (fndecl) = 0;\n \n-  /* This specifies if a function is globaly addressable, ie. it is\n+  /* This specifies if a function is globaly visible, ie. it is\n      the opposite of declaring static in C.  */\n-  if (DECL_CONTEXT (fndecl) == NULL_TREE || attr.external)\n+  if (DECL_CONTEXT (fndecl) == NULL_TREE)\n     TREE_PUBLIC (fndecl) = 1;\n \n   /* TREE_STATIC means the function body is defined here.  */\n-  if (!attr.external)\n-    TREE_STATIC (fndecl) = 1;\n+  TREE_STATIC (fndecl) = 1;\n \n   /* Set attributes for PURE functions. A call to PURE function in the\n      Fortran 95 sense is both pure and without side effects in the C\n@@ -1073,146 +1073,142 @@ gfc_build_function_decl (gfc_symbol * sym)\n \n   /* Layout the function declaration and put it in the binding level\n      of the current function.  */\n-  if (!attr.external)\n+  pushdecl (fndecl);\n+  /* Build formal argument list. Make sure that their TREE_CONTEXT is\n+     the new FUNCTION_DECL node.  */\n+  current_function_decl = fndecl;\n+  arglist = NULL_TREE;\n+  typelist = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n+  if (gfc_return_by_reference (sym))\n     {\n-      tree parm;\n-\n-      pushdecl (fndecl);\n-      /* Build formal argument list. Make sure that their TREE_CONTEXT is\n-         the new FUNCTION_DECL node.  */\n-      current_function_decl = fndecl;\n-      arglist = NULL_TREE;\n-      typelist = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n-      if (gfc_return_by_reference (sym))\n-\t{\n-\t  type = TREE_VALUE (typelist);\n-\t  parm = build_decl (PARM_DECL, get_identifier (\"__result\"), type);\n+      type = TREE_VALUE (typelist);\n+      parm = build_decl (PARM_DECL, get_identifier (\"__result\"), type);\n \n-\t  DECL_CONTEXT (parm) = fndecl;\n-\t  DECL_ARG_TYPE (parm) = type;\n-\t  TREE_READONLY (parm) = 1;\n-\t  gfc_finish_decl (parm, NULL_TREE);\n+      DECL_CONTEXT (parm) = fndecl;\n+      DECL_ARG_TYPE (parm) = type;\n+      TREE_READONLY (parm) = 1;\n+      gfc_finish_decl (parm, NULL_TREE);\n \n-\t  arglist = chainon (arglist, parm);\n-\t  typelist = TREE_CHAIN (typelist);\n+      arglist = chainon (arglist, parm);\n+      typelist = TREE_CHAIN (typelist);\n \n-\t  if (sym->ts.type == BT_CHARACTER)\n-\t    {\n-\t      gfc_allocate_lang_decl (parm);\n+      if (sym->ts.type == BT_CHARACTER)\n+\t{\n+\t  gfc_allocate_lang_decl (parm);\n \n-\t      /* Length of character result.  */\n-\t      type = TREE_VALUE (typelist);\n-\t      assert (type == gfc_strlen_type_node);\n+\t  /* Length of character result.  */\n+\t  type = TREE_VALUE (typelist);\n+\t  assert (type == gfc_strlen_type_node);\n \n-\t      length = build_decl (PARM_DECL,\n-\t\t\t\t   get_identifier (\".__result\"),\n-\t\t\t\t   type);\n-\t      if (!sym->ts.cl->length)\n-\t\t{\n-\t\t  sym->ts.cl->backend_decl = length;\n-\t\t  TREE_USED (length) = 1;\n-\t\t}\n-\t      assert (TREE_CODE (length) == PARM_DECL);\n-\t      arglist = chainon (arglist, length);\n-\t      typelist = TREE_CHAIN (typelist);\n-\t      DECL_CONTEXT (length) = fndecl;\n-\t      DECL_ARG_TYPE (length) = type;\n-\t      TREE_READONLY (length) = 1;\n-\t      gfc_finish_decl (length, NULL_TREE);\n+\t  length = build_decl (PARM_DECL,\n+\t\t\t       get_identifier (\".__result\"),\n+\t\t\t       type);\n+\t  if (!sym->ts.cl->length)\n+\t    {\n+\t      sym->ts.cl->backend_decl = length;\n+\t      TREE_USED (length) = 1;\n \t    }\n+\t  assert (TREE_CODE (length) == PARM_DECL);\n+\t  arglist = chainon (arglist, length);\n+\t  typelist = TREE_CHAIN (typelist);\n+\t  DECL_CONTEXT (length) = fndecl;\n+\t  DECL_ARG_TYPE (length) = type;\n+\t  TREE_READONLY (length) = 1;\n+\t  gfc_finish_decl (length, NULL_TREE);\n \t}\n+    }\n \n-      for (f = sym->formal; f; f = f->next)\n+  for (f = sym->formal; f; f = f->next)\n+    {\n+      if (f->sym != NULL)\t/* ignore alternate returns. */\n \t{\n-\t  if (f->sym != NULL)\t/* ignore alternate returns. */\n-\t    {\n-\t      length = NULL_TREE;\n+\t  length = NULL_TREE;\n \n-\t      type = TREE_VALUE (typelist);\n+\t  type = TREE_VALUE (typelist);\n \n-\t      /* Build a the argument declaration.  */\n-\t      parm = build_decl (PARM_DECL,\n-\t\t\t\t gfc_sym_identifier (f->sym), type);\n+\t  /* Build a the argument declaration.  */\n+\t  parm = build_decl (PARM_DECL,\n+\t\t\t     gfc_sym_identifier (f->sym), type);\n \n-\t      /* Fill in arg stuff.  */\n-\t      DECL_CONTEXT (parm) = fndecl;\n-\t      DECL_ARG_TYPE (parm) = type;\n-\t      DECL_ARG_TYPE_AS_WRITTEN (parm) = type;\n-\t      /* All implementation args are read-only.  */\n-\t      TREE_READONLY (parm) = 1;\n+\t  /* Fill in arg stuff.  */\n+\t  DECL_CONTEXT (parm) = fndecl;\n+\t  DECL_ARG_TYPE (parm) = type;\n+\t  DECL_ARG_TYPE_AS_WRITTEN (parm) = type;\n+\t  /* All implementation args are read-only.  */\n+\t  TREE_READONLY (parm) = 1;\n \n-\t      gfc_finish_decl (parm, NULL_TREE);\n+\t  gfc_finish_decl (parm, NULL_TREE);\n \n-\t      f->sym->backend_decl = parm;\n+\t  f->sym->backend_decl = parm;\n \n-\t      arglist = chainon (arglist, parm);\n-\t      typelist = TREE_CHAIN (typelist);\n-\t    }\n-        }\n+\t  arglist = chainon (arglist, parm);\n+\t  typelist = TREE_CHAIN (typelist);\n+\t}\n+    }\n \n-      /* Add the hidden string length parameters.  */\n-      parm = arglist;\n-      for (f = sym->formal; f; f = f->next)\n-\t{\n-          char name[GFC_MAX_SYMBOL_LEN + 2];\n-\t  /* Ignore alternate returns.  */\n-\t  if (f->sym == NULL)\n-            continue;\n+  /* Add the hidden string length parameters.  */\n+  parm = arglist;\n+  for (f = sym->formal; f; f = f->next)\n+    {\n+      char name[GFC_MAX_SYMBOL_LEN + 2];\n+      /* Ignore alternate returns.  */\n+      if (f->sym == NULL)\n+\tcontinue;\n \n-          if (f->sym->ts.type != BT_CHARACTER)\n-            continue;\n+      if (f->sym->ts.type != BT_CHARACTER)\n+\tcontinue;\n \n-          parm = f->sym->backend_decl;\n-          type = TREE_VALUE (typelist);\n-          assert (type == gfc_strlen_type_node);\n+      parm = f->sym->backend_decl;\n+      type = TREE_VALUE (typelist);\n+      assert (type == gfc_strlen_type_node);\n \n-          strcpy (&name[1], f->sym->name);\n-          name[0] = '_';\n-          length = build_decl (PARM_DECL, get_identifier (name), type);\n+      strcpy (&name[1], f->sym->name);\n+      name[0] = '_';\n+      length = build_decl (PARM_DECL, get_identifier (name), type);\n \n-          arglist = chainon (arglist, length);\n-          DECL_CONTEXT (length) = fndecl;\n-          DECL_ARG_TYPE (length) = type;\n-          TREE_READONLY (length) = 1;\n-          gfc_finish_decl (length, NULL_TREE);\n+      arglist = chainon (arglist, length);\n+      DECL_CONTEXT (length) = fndecl;\n+      DECL_ARG_TYPE (length) = type;\n+      TREE_READONLY (length) = 1;\n+      gfc_finish_decl (length, NULL_TREE);\n \n-\t  /* TODO: Check string lengths when -fbounds-check.  */\n+      /* TODO: Check string lengths when -fbounds-check.  */\n \n-\t  /* Use the passed value for assumed length variables.  */\n-          if (!f->sym->ts.cl->length)\n+      /* Use the passed value for assumed length variables.  */\n+      if (!f->sym->ts.cl->length)\n+\t{\n+\t  TREE_USED (length) = 1;\n+\t  if (!f->sym->ts.cl->backend_decl)\n+\t    f->sym->ts.cl->backend_decl = length;\n+\t  else\n \t    {\n-\t      TREE_USED (length) = 1;\n-\t      if (!f->sym->ts.cl->backend_decl)\n-\t\tf->sym->ts.cl->backend_decl = length;\n-\t      else\n-\t\t{\n-\t\t  /* there is already another variable using this\n-\t\t     gfc_charlen node, build a new one for this variable\n-\t\t     and chain it into the list of gfc_charlens.\n-\t\t     This happens for e.g. in the case\n-\t\t     CHARACTER(*)::c1,c2\n-\t\t     since CHARACTER declarations on the same line share\n-\t\t     the same gfc_charlen node.  */\n-\t\t  gfc_charlen *cl;\n-\t\t  \n-\t\t  cl = gfc_get_charlen ();\n-\t\t  cl->backend_decl = length;\n-\t\t  cl->next = f->sym->ts.cl->next;\n-\t\t  f->sym->ts.cl->next = cl;\n-\t\t  f->sym->ts.cl = cl;\n-\t\t}\n+\t      /* there is already another variable using this\n+\t\t gfc_charlen node, build a new one for this variable\n+\t\t and chain it into the list of gfc_charlens.\n+\t\t This happens for e.g. in the case\n+\t\t CHARACTER(*)::c1,c2\n+\t\t since CHARACTER declarations on the same line share\n+\t\t the same gfc_charlen node.  */\n+\t      gfc_charlen *cl;\n+\t      \n+\t      cl = gfc_get_charlen ();\n+\t      cl->backend_decl = length;\n+\t      cl->next = f->sym->ts.cl->next;\n+\t      f->sym->ts.cl->next = cl;\n+\t      f->sym->ts.cl = cl;\n \t    }\n-\n-          parm = TREE_CHAIN (parm);\n-          typelist = TREE_CHAIN (typelist);\n \t}\n \n-      assert (TREE_VALUE (typelist) == void_type_node);\n-      DECL_ARGUMENTS (fndecl) = arglist;\n-\n-      /* Restore the old context.  */\n-      current_function_decl = DECL_CONTEXT (fndecl);\n+      parm = TREE_CHAIN (parm);\n+      typelist = TREE_CHAIN (typelist);\n     }\n+\n+  assert (TREE_VALUE (typelist) == void_type_node);\n+  DECL_ARGUMENTS (fndecl) = arglist;\n+\n+  /* Restore the old context.  */\n+  current_function_decl = DECL_CONTEXT (fndecl);\n+\n   sym->backend_decl = fndecl;\n }\n "}]}