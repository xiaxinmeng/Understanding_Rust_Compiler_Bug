{"sha": "0045d504351e0aa05f1463820b0b86933ba14849", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA0NWQ1MDQzNTFlMGFhMDVmMTQ2MzgyMGIwYjg2OTMzYmExNDg0OQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-07-22T19:34:13Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-07-22T19:34:13Z"}, "message": "jump.c: Update comments.\n\n\t* jump.c: Update comments.\n\t(delete_barrier_successors, delete_unreferenced_labels,\n\tdelete_noop_moves, tension_vector_labels, delete_from_jump_chain,\n\tdelete_labelref_insn, redirect_tablejump, jump_optimize_1,\n\tjump_optimize, jump_optimize_minimal): Kill.\n\t(rebuild_jump_labels): Move code from jump_optimize_1.\n\t(purge_line_number_notes): Likewise.\n\t(copy_loop_headers): Likewise.\n\t* reg-stack.c: Update comment.\n\t* stmt.c: Likewise.\n\t* rtl.h (jump_optimize, jump_optimize_1, JUMP_NOOP_MOVES,\n\tJUMP_AFTER_REGSCAN): Kill.\n\t* toplev.c (rest_of_compilation): Use cleanup_cfg, call\n\tpurge_line_number_notes and copy_loop_headers.\n\nFrom-SVN: r44245", "tree": {"sha": "ee70281cc5f3db64b155ab564be9322e29c0204d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee70281cc5f3db64b155ab564be9322e29c0204d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0045d504351e0aa05f1463820b0b86933ba14849", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0045d504351e0aa05f1463820b0b86933ba14849", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0045d504351e0aa05f1463820b0b86933ba14849", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0045d504351e0aa05f1463820b0b86933ba14849/comments", "author": null, "committer": null, "parents": [{"sha": "3914abb46ef94ef60c9bb44c7e3573534c0c6815", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3914abb46ef94ef60c9bb44c7e3573534c0c6815", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3914abb46ef94ef60c9bb44c7e3573534c0c6815"}], "stats": {"total": 936, "additions": 92, "deletions": 844}, "files": [{"sha": "6dccbb7f3a463a3fabe69b569f7b3ca3381205a5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0045d504351e0aa05f1463820b0b86933ba14849/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0045d504351e0aa05f1463820b0b86933ba14849/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0045d504351e0aa05f1463820b0b86933ba14849", "patch": "@@ -1,3 +1,20 @@\n+Sun Jul 22 21:31:04 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* jump.c: Update comments.\n+\t(delete_barrier_successors, delete_unreferenced_labels,\n+\tdelete_noop_moves, tension_vector_labels, delete_from_jump_chain,\n+\tdelete_labelref_insn, redirect_tablejump, jump_optimize_1,\n+\tjump_optimize, jump_optimize_minimal): Kill.\n+\t(rebuild_jump_labels): Move code from jump_optimize_1.\n+\t(purge_line_number_notes): Likewise.\n+\t(copy_loop_headers): Likewise.\n+\t* reg-stack.c: Update comment.\n+\t* stmt.c: Likewise.\n+\t* rtl.h (jump_optimize, jump_optimize_1, JUMP_NOOP_MOVES,\n+\tJUMP_AFTER_REGSCAN): Kill.\n+\t* toplev.c (rest_of_compilation): Use cleanup_cfg, call\n+\tpurge_line_number_notes and copy_loop_headers.\n+\n 2001-07-22 Neil Booth  <neil@daikokuya.demon.co.uk>\n \t   Richard Henderson  <rth@redhat.com>\n "}, {"sha": "01fc7414308c93d00050fd21e42aa25e8ff21e19", "filename": "gcc/jump.c", "status": "modified", "additions": 54, "deletions": 829, "changes": 883, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0045d504351e0aa05f1463820b0b86933ba14849/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0045d504351e0aa05f1463820b0b86933ba14849/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=0045d504351e0aa05f1463820b0b86933ba14849", "patch": "@@ -19,14 +19,9 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-/* This is the jump-optimization pass of the compiler.\n-   It is run two or three times: once before cse, sometimes once after cse,\n-   and once after reload (before final).\n-\n-   jump_optimize deletes unreachable code and labels that are not used.\n-   It also deletes jumps that jump to the following insn,\n-   and simplifies jumps around unconditional jumps and jumps\n-   to unconditional jumps.\n+/* This is the pathetic reminder of old fame of the jump-optimization pass\n+   of the compiler.  Now it contains basically set of utility function to\n+   operate with jumps.\n \n    Each CODE_LABEL has a count of the times it is used\n    stored in the LABEL_NUSES internal field, and each JUMP_INSN\n@@ -36,13 +31,6 @@ Boston, MA 02111-1307, USA.  */\n    formerly used them.  The JUMP_LABEL info is sometimes looked\n    at by later passes.\n \n-   Jump optimization is done after cse when cse's constant-propagation\n-   causes jumps to become unconditional or to be deleted.\n-\n-   Unreachable loops are not detected here, because the labels\n-   have references and the insns appear reachable from the labels.\n-   find_basic_blocks in flow.c finds and deletes such loops.\n-\n    The subroutines delete_insn, redirect_jump, and invert_jump are used\n    from other passes as well.  */\n \n@@ -64,136 +52,36 @@ Boston, MA 02111-1307, USA.  */\n #include \"reload.h\"\n #include \"predict.h\"\n \n-/* ??? Eventually must record somehow the labels used by jumps\n-   from nested functions.  */\n-/* Pre-record the next or previous real insn for each label?\n-   No, this pass is very fast anyway.  */\n-/* Condense consecutive labels?\n-   This would make life analysis faster, maybe.  */\n /* Optimize jump y; x: ... y: jumpif... x?\n    Don't know if it is worth bothering with.  */\n /* Optimize two cases of conditional jump to conditional jump?\n    This can never delete any instruction or make anything dead,\n    or even change what is live at any point.\n    So perhaps let combiner do it.  */\n \n-/* Vector indexed by uid.\n-   For each CODE_LABEL, index by its uid to get first unconditional jump\n-   that jumps to the label.\n-   For each JUMP_INSN, index by its uid to get the next unconditional jump\n-   that jumps to the same label.\n-   Element 0 is the start of a chain of all return insns.\n-   (It is safe to use element 0 because insn uid 0 is not used.  */\n-\n-static rtx *jump_chain;\n-\n-/* Maximum index in jump_chain.  */\n-\n-static int max_jump_chain;\n-\n static int init_label_info\t\tPARAMS ((rtx));\n-static void delete_barrier_successors\tPARAMS ((rtx));\n static void mark_all_labels\t\tPARAMS ((rtx));\n-static rtx delete_unreferenced_labels\tPARAMS ((rtx));\n-static void delete_noop_moves\t\tPARAMS ((rtx));\n static int duplicate_loop_exit_test\tPARAMS ((rtx));\n-static int tension_vector_labels\tPARAMS ((rtx, int));\n static void delete_computation\t\tPARAMS ((rtx));\n static void redirect_exp_1\t\tPARAMS ((rtx *, rtx, rtx, rtx));\n static int redirect_exp\t\t\tPARAMS ((rtx, rtx, rtx));\n static void invert_exp_1\t\tPARAMS ((rtx));\n static int invert_exp\t\t\tPARAMS ((rtx));\n-static void delete_from_jump_chain\tPARAMS ((rtx));\n-static int delete_labelref_insn\t\tPARAMS ((rtx, rtx, int));\n-static void mark_modified_reg\t\tPARAMS ((rtx, rtx, void *));\n-static void redirect_tablejump\t\tPARAMS ((rtx, rtx));\n-static void jump_optimize_1\t\tPARAMS ((rtx, int, int, int, int));\n static int returnjump_p_1\t        PARAMS ((rtx *, void *));\n static void delete_prior_computation    PARAMS ((rtx, rtx));\n \f\n-/* Main external entry point into the jump optimizer.  See comments before\n-   jump_optimize_1 for descriptions of the arguments.  */\n-void\n-jump_optimize (f, noop_moves, after_regscan)\n-     rtx f;\n-     int noop_moves;\n-     int after_regscan;\n-{\n-  jump_optimize_1 (f, noop_moves, after_regscan, 0, 0);\n-}\n-\n /* Alternate entry into the jump optimizer.  This entry point only rebuilds\n    the JUMP_LABEL field in jumping insns and REG_LABEL notes in non-jumping\n    instructions.  */\n void\n rebuild_jump_labels (f)\n      rtx f;\n {\n-  jump_optimize_1 (f, 0, 0, 1, 0);\n-}\n-\n-/* Alternate entry into the jump optimizer.  Do only trivial optimizations.  */\n-\n-void\n-jump_optimize_minimal (f)\n-     rtx f;\n-{\n-  jump_optimize_1 (f, 0, 0, 0, 1);\n-}\n-\f\n-/* Delete no-op jumps and optimize jumps to jumps\n-   and jumps around jumps.\n-   Delete unused labels and unreachable code.\n-\n-   If NOOP_MOVES is nonzero, delete no-op move insns.\n-\n-   If AFTER_REGSCAN is nonzero, then this jump pass is being run immediately\n-   after regscan, and it is safe to use regno_first_uid and regno_last_uid.\n-\n-   If MARK_LABELS_ONLY is nonzero, then we only rebuild the jump chain\n-   and JUMP_LABEL field for jumping insns.\n-\n-   If `optimize' is zero, don't change any code,\n-   just determine whether control drops off the end of the function.\n-   This case occurs when we have -W and not -O.\n-   It works because `delete_insn' checks the value of `optimize'\n-   and refrains from actually deleting when that is 0.\n-\n-   If MINIMAL is nonzero, then we only perform trivial optimizations:\n-\n-     * Removal of unreachable code after BARRIERs.\n-     * Removal of unreferenced CODE_LABELs.\n-     * Removal of a jump to the next instruction.\n-     * Removal of a conditional jump followed by an unconditional jump\n-       to the same target as the conditional jump.\n-     * Simplify a conditional jump around an unconditional jump.\n-     * Simplify a jump to a jump.\n-     * Delete extraneous line number notes.\n-  */\n-\n-static void\n-jump_optimize_1 (f, noop_moves, after_regscan,\n-\t\t mark_labels_only, minimal)\n-     rtx f;\n-     int noop_moves;\n-     int after_regscan;\n-     int mark_labels_only;\n-     int minimal;\n-{\n-  register rtx insn, next;\n-  int changed;\n-  int old_max_reg;\n-  int first = 1;\n+  register rtx insn;\n   int max_uid = 0;\n-  rtx last_insn;\n \n   max_uid = init_label_info (f) + 1;\n \n-  /* Leave some extra room for labels and duplicate exit test insns\n-     we make.  */\n-  max_jump_chain = max_uid * 14 / 10;\n-  jump_chain = (rtx *) xcalloc (max_jump_chain, sizeof (rtx));\n-\n   mark_all_labels (f);\n \n   /* Keep track of labels used from static data; we don't track them\n@@ -210,308 +98,70 @@ jump_optimize_1 (f, noop_moves, after_regscan,\n   for (insn = exception_handler_labels; insn; insn = XEXP (insn, 1))\n     if (GET_CODE (XEXP (insn, 0)) == CODE_LABEL)\n       LABEL_NUSES (XEXP (insn, 0))++;\n-\n-  /* Quit now if we just wanted to rebuild the JUMP_LABEL and REG_LABEL\n-     notes and recompute LABEL_NUSES.  */\n-  if (mark_labels_only)\n-    goto end;\n-\n-  delete_barrier_successors (f);\n-\n-  last_insn = delete_unreferenced_labels (f);\n-\n-  if (noop_moves)\n-    delete_noop_moves (f);\n-\n+}\n+\f\n+void\n+copy_loop_headers (f)\n+     rtx f;\n+{\n+  register rtx insn, next;\n   /* Now iterate optimizing jumps until nothing changes over one pass.  */\n-  changed = 1;\n-  old_max_reg = max_reg_num ();\n-  while (changed)\n+  for (insn = f; insn; insn = next)\n     {\n-      changed = 0;\n-\n-      for (insn = f; insn; insn = next)\n-\t{\n-\t  rtx reallabelprev;\n-\t  rtx temp, temp1, temp2 = NULL_RTX;\n-\t  rtx temp4 ATTRIBUTE_UNUSED;\n-\t  rtx nlabel;\n-\t  int this_is_any_uncondjump;\n-\t  int this_is_any_condjump;\n-\t  int this_is_onlyjump;\n-\n-\t  next = NEXT_INSN (insn);\n-\n-\t  /* See if this is a NOTE_INSN_LOOP_BEG followed by an unconditional\n-\t     jump.  Try to optimize by duplicating the loop exit test if so.\n-\t     This is only safe immediately after regscan, because it uses\n-\t     the values of regno_first_uid and regno_last_uid.  */\n-\t  if (after_regscan && GET_CODE (insn) == NOTE\n-\t      && NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG\n-\t      && (temp1 = next_nonnote_insn (insn)) != 0\n-\t      && any_uncondjump_p (temp1)\n-\t      && onlyjump_p (temp1))\n-\t    {\n-\t      temp = PREV_INSN (insn);\n-\t      if (duplicate_loop_exit_test (insn))\n-\t\t{\n-\t\t  changed = 1;\n-\t\t  next = NEXT_INSN (temp);\n-\t\t  continue;\n-\t\t}\n-\t    }\n-\n-\t  if (GET_CODE (insn) != JUMP_INSN)\n-\t    continue;\n-\n-\t  this_is_any_condjump = any_condjump_p (insn);\n-\t  this_is_any_uncondjump = any_uncondjump_p (insn);\n-\t  this_is_onlyjump = onlyjump_p (insn);\n-\n-\t  /* Tension the labels in dispatch tables.  */\n-\n-\t  if (GET_CODE (PATTERN (insn)) == ADDR_VEC)\n-\t    changed |= tension_vector_labels (PATTERN (insn), 0);\n-\t  if (GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC)\n-\t    changed |= tension_vector_labels (PATTERN (insn), 1);\n-\n-\t  /* See if this jump goes to another jump and redirect if so.  */\n-\t  nlabel = follow_jumps (JUMP_LABEL (insn));\n-\t  if (nlabel != JUMP_LABEL (insn))\n-\t    changed |= redirect_jump (insn, nlabel, 1);\n-\n-\t  if (! optimize || minimal)\n-\t    continue;\n-\n-\t  /* If a dispatch table always goes to the same place,\n-\t     get rid of it and replace the insn that uses it.  */\n-\n-\t  if (GET_CODE (PATTERN (insn)) == ADDR_VEC\n-\t      || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC)\n-\t    {\n-\t      int i;\n-\t      rtx pat = PATTERN (insn);\n-\t      int diff_vec_p = GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC;\n-\t      int len = XVECLEN (pat, diff_vec_p);\n-\t      rtx dispatch = prev_real_insn (insn);\n-\t      rtx set;\n-\n-\t      for (i = 0; i < len; i++)\n-\t\tif (XEXP (XVECEXP (pat, diff_vec_p, i), 0)\n-\t\t    != XEXP (XVECEXP (pat, diff_vec_p, 0), 0))\n-\t\t  break;\n-\n-\t      if (i == len\n-\t\t  && dispatch != 0\n-\t\t  && GET_CODE (dispatch) == JUMP_INSN\n-\t\t  && JUMP_LABEL (dispatch) != 0\n-\t\t  /* Don't mess with a casesi insn.\n-\t\t     XXX according to the comment before computed_jump_p(),\n-\t\t     all casesi insns should be a parallel of the jump\n-\t\t     and a USE of a LABEL_REF.  */\n-\t\t  && ! ((set = single_set (dispatch)) != NULL\n-\t\t\t&& (GET_CODE (SET_SRC (set)) == IF_THEN_ELSE))\n-\t\t  && next_real_insn (JUMP_LABEL (dispatch)) == insn)\n-\t\t{\n-\t\t  redirect_tablejump (dispatch,\n-\t\t\t\t      XEXP (XVECEXP (pat, diff_vec_p, 0), 0));\n-\t\t  changed = 1;\n-\t\t}\n-\t    }\n-\n-\t  reallabelprev = prev_active_insn (JUMP_LABEL (insn));\n-\n-\t  /* Detect jump to following insn.  */\n-\t  if (reallabelprev == insn\n-\t      && (this_is_any_condjump || this_is_any_uncondjump)\n-\t      && this_is_onlyjump)\n-\t    {\n-\t      next = next_real_insn (JUMP_LABEL (insn));\n-\t      delete_jump (insn);\n-\n-\t      /* Remove the \"inactive\" but \"real\" insns (i.e. uses and\n-\t         clobbers) in between here and there.  */\n-\t      temp = insn;\n-\t      while ((temp = next_real_insn (temp)) != next)\n-\t\tdelete_insn (temp);\n-\n-\t      changed = 1;\n-\t      continue;\n-\t    }\n-\n-\t  /* Detect a conditional jump going to the same place\n-\t     as an immediately following unconditional jump.  */\n-\t  else if (this_is_any_condjump && this_is_onlyjump\n-\t\t   && (temp = next_active_insn (insn)) != 0\n-\t\t   && simplejump_p (temp)\n-\t\t   && (next_active_insn (JUMP_LABEL (insn))\n-\t\t       == next_active_insn (JUMP_LABEL (temp))))\n-\t    {\n-\t      /* Don't mess up test coverage analysis.  */\n-\t      temp2 = temp;\n-\t      if (flag_test_coverage && !reload_completed)\n-\t\tfor (temp2 = insn; temp2 != temp; temp2 = NEXT_INSN (temp2))\n-\t\t  if (GET_CODE (temp2) == NOTE && NOTE_LINE_NUMBER (temp2) > 0)\n-\t\t    break;\n-\n-\t      if (temp2 == temp)\n-\t\t{\n-\t\t  /* Ensure that we jump to the later of the two labels.  \n-\t\t     Consider:\n-\n-\t\t\tif (test) goto L2;\n-\t\t\tgoto L1;\n-\t\t\t...\n-\t\t      L1:\n-\t\t\t(clobber return-reg)\n-\t\t      L2:\n-\t\t\t(use return-reg)\n-\n-\t\t     If we leave the goto L1, we'll incorrectly leave\n-\t\t     return-reg dead for TEST true.  */\n-\n-\t\t  temp2 = next_active_insn (JUMP_LABEL (insn));\n-\t\t  if (!temp2)\n-\t\t    temp2 = get_last_insn ();\n-\t\t  if (GET_CODE (temp2) != CODE_LABEL)\n-\t\t    temp2 = prev_label (temp2);\n-\t\t  if (temp2 != JUMP_LABEL (temp))\n-\t\t    redirect_jump (temp, temp2, 1);\n-\n-\t\t  delete_jump (insn);\n-\t\t  changed = 1;\n-\t\t  continue;\n-\t\t}\n-\t    }\n-\n-\t  /* Detect a conditional jump jumping over an unconditional jump.  */\n-\n-\t  else if (this_is_any_condjump\n-\t\t   && reallabelprev != 0\n-\t\t   && GET_CODE (reallabelprev) == JUMP_INSN\n-\t\t   && prev_active_insn (reallabelprev) == insn\n-\t\t   && no_labels_between_p (insn, reallabelprev)\n-\t\t   && any_uncondjump_p (reallabelprev)\n-\t\t   && onlyjump_p (reallabelprev))\n-\t    {\n-\t      /* When we invert the unconditional jump, we will be\n-\t\t decrementing the usage count of its old label.\n-\t\t Make sure that we don't delete it now because that\n-\t\t might cause the following code to be deleted.  */\n-\t      rtx prev_uses = prev_nonnote_insn (reallabelprev);\n-\t      rtx prev_label = JUMP_LABEL (insn);\n-\n-\t      if (prev_label)\n-\t\t++LABEL_NUSES (prev_label);\n-\n-\t      if (invert_jump (insn, JUMP_LABEL (reallabelprev), 1))\n-\t\t{\n-\t\t  /* It is very likely that if there are USE insns before\n-\t\t     this jump, they hold REG_DEAD notes.  These REG_DEAD\n-\t\t     notes are no longer valid due to this optimization,\n-\t\t     and will cause the life-analysis that following passes\n-\t\t     (notably delayed-branch scheduling) to think that\n-\t\t     these registers are dead when they are not.\n-\n-\t\t     To prevent this trouble, we just remove the USE insns\n-\t\t     from the insn chain.  */\n-\n-\t\t  while (prev_uses && GET_CODE (prev_uses) == INSN\n-\t\t\t && GET_CODE (PATTERN (prev_uses)) == USE)\n-\t\t    {\n-\t\t      rtx useless = prev_uses;\n-\t\t      prev_uses = prev_nonnote_insn (prev_uses);\n-\t\t      delete_insn (useless);\n-\t\t    }\n-\n-\t\t  delete_insn (reallabelprev);\n-\t\t  changed = 1;\n-\t\t}\n+      rtx temp, temp1;\n \n-\t      /* We can now safely delete the label if it is unreferenced\n-\t\t since the delete_insn above has deleted the BARRIER.  */\n-\t      if (prev_label && --LABEL_NUSES (prev_label) == 0)\n-\t\tdelete_insn (prev_label);\n-\n-\t      next = NEXT_INSN (insn);\n-\t    }\n+      next = NEXT_INSN (insn);\n \n-\t  /* If we have an unconditional jump preceded by a USE, try to put\n-\t     the USE before the target and jump there.  This simplifies many\n-\t     of the optimizations below since we don't have to worry about\n-\t     dealing with these USE insns.  We only do this if the label\n-\t     being branch to already has the identical USE or if code\n-\t     never falls through to that label.  */\n-\n-\t  else if (this_is_any_uncondjump\n-\t\t   && (temp = prev_nonnote_insn (insn)) != 0\n-\t\t   && GET_CODE (temp) == INSN\n-\t\t   && GET_CODE (PATTERN (temp)) == USE\n-\t\t   && (temp1 = prev_nonnote_insn (JUMP_LABEL (insn))) != 0\n-\t\t   && (GET_CODE (temp1) == BARRIER\n-\t\t       || (GET_CODE (temp1) == INSN\n-\t\t\t   && rtx_equal_p (PATTERN (temp), PATTERN (temp1))))\n-\t\t   /* Don't do this optimization if we have a loop containing\n-\t\t      only the USE instruction, and the loop start label has\n-\t\t      a usage count of 1.  This is because we will redo this\n-\t\t      optimization everytime through the outer loop, and jump\n-\t\t      opt will never exit.  */\n-\t\t   && ! ((temp2 = prev_nonnote_insn (temp)) != 0\n-\t\t\t && temp2 == JUMP_LABEL (insn)\n-\t\t\t && LABEL_NUSES (temp2) == 1))\n+      /* See if this is a NOTE_INSN_LOOP_BEG followed by an unconditional\n+\t jump.  Try to optimize by duplicating the loop exit test if so.\n+\t This is only safe immediately after regscan, because it uses\n+\t the values of regno_first_uid and regno_last_uid.  */\n+      if (GET_CODE (insn) == NOTE\n+\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG\n+\t  && (temp1 = next_nonnote_insn (insn)) != 0\n+\t  && any_uncondjump_p (temp1) && onlyjump_p (temp1))\n+\t{\n+\t  temp = PREV_INSN (insn);\n+\t  if (duplicate_loop_exit_test (insn))\n \t    {\n-\t      if (GET_CODE (temp1) == BARRIER)\n-\t\t{\n-\t\t  emit_insn_after (PATTERN (temp), temp1);\n-\t\t  temp1 = NEXT_INSN (temp1);\n-\t\t}\n-\n-\t      delete_insn (temp);\n-\t      redirect_jump (insn, get_label_before (temp1), 1);\n-\t      reallabelprev = prev_real_insn (temp1);\n-\t      changed = 1;\n-\t      next = NEXT_INSN (insn);\n+\t      next = NEXT_INSN (temp);\n \t    }\n \t}\n-\n-      first = 0;\n     }\n+}\n \n+void\n+purge_line_number_notes (f)\n+     rtx f;\n+{\n+  rtx last_note = 0;\n+  rtx insn;\n   /* Delete extraneous line number notes.\n      Note that two consecutive notes for different lines are not really\n      extraneous.  There should be some indication where that line belonged,\n      even if it became empty.  */\n \n-  {\n-    rtx last_note = 0;\n-\n-    for (insn = f; insn; insn = NEXT_INSN (insn))\n-      if (GET_CODE (insn) == NOTE)\n-\t{\n-\t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_BEG)\n-\t    /* Any previous line note was for the prologue; gdb wants a new\n-\t       note after the prologue even if it is for the same line.  */\n-\t    last_note = NULL_RTX;\n-\t  else if (NOTE_LINE_NUMBER (insn) >= 0)\n-\t    {\n-\t      /* Delete this note if it is identical to previous note.  */\n-\t      if (last_note\n-\t\t  && NOTE_SOURCE_FILE (insn) == NOTE_SOURCE_FILE (last_note)\n-\t\t  && NOTE_LINE_NUMBER (insn) == NOTE_LINE_NUMBER (last_note))\n-\t\t{\n-\t\t  delete_insn (insn);\n-\t\t  continue;\n-\t\t}\n-\n-\t      last_note = insn;\n-\t    }\n-\t}\n-  }\n+  for (insn = f; insn; insn = NEXT_INSN (insn))\n+    if (GET_CODE (insn) == NOTE)\n+      {\n+\tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_BEG)\n+\t  /* Any previous line note was for the prologue; gdb wants a new\n+\t     note after the prologue even if it is for the same line.  */\n+\t  last_note = NULL_RTX;\n+\telse if (NOTE_LINE_NUMBER (insn) >= 0)\n+\t  {\n+\t    /* Delete this note if it is identical to previous note.  */\n+\t    if (last_note\n+\t\t&& NOTE_SOURCE_FILE (insn) == NOTE_SOURCE_FILE (last_note)\n+\t\t&& NOTE_LINE_NUMBER (insn) == NOTE_LINE_NUMBER (last_note))\n+\t      {\n+\t\tdelete_insn (insn);\n+\t\tcontinue;\n+\t      }\n \n-end:\n-  /* Clean up.  */\n-  free (jump_chain);\n-  jump_chain = 0;\n+\t    last_note = insn;\n+\t  }\n+      }\n }\n \f\n /* Initialize LABEL_NUSES and JUMP_LABEL fields.  Delete any REG_LABEL\n@@ -549,74 +199,8 @@ init_label_info (f)\n   return largest_uid;\n }\n \n-/* Delete insns following barriers, up to next label.\n-\n-   Also delete no-op jumps created by gcse.  */\n-\n-static void\n-delete_barrier_successors (f)\n-     rtx f;\n-{\n-  rtx insn;\n-  rtx set;\n-\n-  for (insn = f; insn;)\n-    {\n-      if (GET_CODE (insn) == BARRIER)\n-\t{\n-\t  insn = NEXT_INSN (insn);\n-\n-\t  never_reached_warning (insn);\n-\n-\t  while (insn != 0 && GET_CODE (insn) != CODE_LABEL)\n-\t    {\n-\t      if (GET_CODE (insn) == JUMP_INSN)\n-\t\t{\n-\t\t  /* Detect when we're deleting a tablejump; get rid of\n-\t\t     the jump table as well.  */\n-\t\t  rtx next1 = next_nonnote_insn (insn);\n-\t\t  rtx next2 = next1 ? next_nonnote_insn (next1) : 0;\n-\t\t  if (next2 && GET_CODE (next1) == CODE_LABEL\n-\t\t      && GET_CODE (next2) == JUMP_INSN\n-\t\t      && (GET_CODE (PATTERN (next2)) == ADDR_VEC\n-\t\t\t  || GET_CODE (PATTERN (next2)) == ADDR_DIFF_VEC))\n-\t\t    {\n-\t\t      delete_insn (insn);\n-\t\t      insn = next2;\n-\t\t    }\n-\t\t  else\n-\t\t    insn = delete_insn (insn);\n-\t\t}\n-\t      else if (GET_CODE (insn) == NOTE\n-\t\t  && NOTE_LINE_NUMBER (insn) != NOTE_INSN_FUNCTION_END)\n-\t\tinsn = NEXT_INSN (insn);\n-\t      else\n-\t\tinsn = delete_insn (insn);\n-\t    }\n-\t  /* INSN is now the code_label.  */\n-\t}\n-\n-      /* Also remove (set (pc) (pc)) insns which can be created by\n-\t gcse.  We eliminate such insns now to avoid having them\n-\t cause problems later.  */\n-      else if (GET_CODE (insn) == JUMP_INSN\n-\t       && (set = pc_set (insn)) != NULL\n-\t       && SET_SRC (set) == pc_rtx\n-\t       && SET_DEST (set) == pc_rtx\n-\t       && onlyjump_p (insn))\n-\tinsn = delete_insn (insn);\n-\n-      else\n-\tinsn = NEXT_INSN (insn);\n-    }\n-}\n-\n /* Mark the label each jump jumps to.\n-   Combine consecutive labels, and count uses of labels.\n-\n-   For each label, make a chain (using `jump_chain')\n-   of all the *unconditional* jumps that jump to it;\n-   also make a chain of all returns.  */\n+   Combine consecutive labels, and count uses of labels.  */\n \n static void\n mark_all_labels (f)\n@@ -668,180 +252,10 @@ mark_all_labels (f)\n \t\t    JUMP_LABEL (insn) = XEXP (label_note, 0);\n \t\t  }\n \t      }\n-\t    if (JUMP_LABEL (insn) != 0 && simplejump_p (insn))\n-\t      {\n-\t\tjump_chain[INSN_UID (insn)]\n-\t\t  = jump_chain[INSN_UID (JUMP_LABEL (insn))];\n-\t\tjump_chain[INSN_UID (JUMP_LABEL (insn))] = insn;\n-\t      }\n-\t    if (GET_CODE (PATTERN (insn)) == RETURN)\n-\t      {\n-\t\tjump_chain[INSN_UID (insn)] = jump_chain[0];\n-\t\tjump_chain[0] = insn;\n-\t      }\n \t  }\n       }\n }\n \n-/* Delete all labels already not referenced.\n-   Also find and return the last insn.  */\n-\n-static rtx\n-delete_unreferenced_labels (f)\n-     rtx f;\n-{\n-  rtx final = NULL_RTX;\n-  rtx insn;\n-\n-  for (insn = f; insn;)\n-    {\n-      if (GET_CODE (insn) == CODE_LABEL\n-\t  && LABEL_NUSES (insn) == 0\n-\t  && LABEL_ALTERNATE_NAME (insn) == NULL)\n-\tinsn = delete_insn (insn);\n-      else\n-\t{\n-\t  final = insn;\n-\t  insn = NEXT_INSN (insn);\n-\t}\n-    }\n-\n-  return final;\n-}\n-\n-/* Delete various simple forms of moves which have no necessary\n-   side effect.  */\n-\n-static void\n-delete_noop_moves (f)\n-     rtx f;\n-{\n-  rtx insn, next;\n-\n-  for (insn = f; insn;)\n-    {\n-      next = NEXT_INSN (insn);\n-\n-      if (GET_CODE (insn) == INSN)\n-\t{\n-\t  register rtx body = PATTERN (insn);\n-\n-\t  /* Detect and delete no-op move instructions\n-\t     resulting from not allocating a parameter in a register.  */\n-\n-\t  if (GET_CODE (body) == SET && set_noop_p (body))\n-\t    delete_computation (insn);\n-\n-\t  /* Detect and ignore no-op move instructions\n-\t     resulting from smart or fortuitous register allocation.  */\n-\n-\t  else if (GET_CODE (body) == SET)\n-\t    {\n-\t      int sreg = true_regnum (SET_SRC (body));\n-\t      int dreg = true_regnum (SET_DEST (body));\n-\n-\t      if (sreg == dreg && sreg >= 0)\n-\t\tdelete_insn (insn);\n-\t      else if (sreg >= 0 && dreg >= 0)\n-\t\t{\n-\t\t  rtx trial;\n-\t\t  rtx tem = find_equiv_reg (NULL_RTX, insn, 0,\n-\t\t\t\t\t    sreg, NULL, dreg,\n-\t\t\t\t\t    GET_MODE (SET_SRC (body)));\n-\n-\t\t  if (tem != 0\n-\t\t      && GET_MODE (tem) == GET_MODE (SET_DEST (body)))\n-\t\t    {\n-\t\t      /* DREG may have been the target of a REG_DEAD note in\n-\t\t\t the insn which makes INSN redundant.  If so, reorg\n-\t\t\t would still think it is dead.  So search for such a\n-\t\t\t note and delete it if we find it.  */\n-\t\t      if (! find_regno_note (insn, REG_UNUSED, dreg))\n-\t\t\tfor (trial = prev_nonnote_insn (insn);\n-\t\t\t     trial && GET_CODE (trial) != CODE_LABEL;\n-\t\t\t     trial = prev_nonnote_insn (trial))\n-\t\t\t  if (find_regno_note (trial, REG_DEAD, dreg))\n-\t\t\t    {\n-\t\t\t      remove_death (dreg, trial);\n-\t\t\t      break;\n-\t\t\t    }\n-\n-\t\t      /* Deleting insn could lose a death-note for SREG.  */\n-\t\t      if ((trial = find_regno_note (insn, REG_DEAD, sreg)))\n-\t\t\t{\n-\t\t\t  /* Change this into a USE so that we won't emit\n-\t\t\t     code for it, but still can keep the note.  */\n-\t\t\t  PATTERN (insn)\n-\t\t\t    = gen_rtx_USE (VOIDmode, XEXP (trial, 0));\n-\t\t\t  INSN_CODE (insn) = -1;\n-\t\t\t  /* Remove all reg notes but the REG_DEAD one.  */\n-\t\t\t  REG_NOTES (insn) = trial;\n-\t\t\t  XEXP (trial, 1) = NULL_RTX;\n-\t\t\t}\n-\t\t      else\n-\t\t\tdelete_insn (insn);\n-\t\t    }\n-\t\t}\n-\t      else if (dreg >= 0 && CONSTANT_P (SET_SRC (body))\n-\t\t       && find_equiv_reg (SET_SRC (body), insn, 0, dreg,\n-\t\t\t\t\t  NULL, 0, GET_MODE (SET_DEST (body))))\n-\t\t{\n-\t\t  /* This handles the case where we have two consecutive\n-\t\t     assignments of the same constant to pseudos that didn't\n-\t\t     get a hard reg.  Each SET from the constant will be\n-\t\t     converted into a SET of the spill register and an\n-\t\t     output reload will be made following it.  This produces\n-\t\t     two loads of the same constant into the same spill\n-\t\t     register.  */\n-\n-\t\t  rtx in_insn = insn;\n-\n-\t\t  /* Look back for a death note for the first reg.\n-\t\t     If there is one, it is no longer accurate.  */\n-\t\t  while (in_insn && GET_CODE (in_insn) != CODE_LABEL)\n-\t\t    {\n-\t\t      if ((GET_CODE (in_insn) == INSN\n-\t\t\t   || GET_CODE (in_insn) == JUMP_INSN)\n-\t\t\t  && find_regno_note (in_insn, REG_DEAD, dreg))\n-\t\t\t{\n-\t\t\t  remove_death (dreg, in_insn);\n-\t\t\t  break;\n-\t\t\t}\n-\t\t      in_insn = PREV_INSN (in_insn);\n-\t\t    }\n-\n-\t\t  /* Delete the second load of the value.  */\n-\t\t  delete_insn (insn);\n-\t\t}\n-\t    }\n-\t  else if (GET_CODE (body) == PARALLEL)\n-\t    {\n-\t      /* If each part is a set between two identical registers or\n-\t\t a USE or CLOBBER, delete the insn.  */\n-\t      int i, sreg, dreg;\n-\t      rtx tem;\n-\n-\t      for (i = XVECLEN (body, 0) - 1; i >= 0; i--)\n-\t\t{\n-\t\t  tem = XVECEXP (body, 0, i);\n-\t\t  if (GET_CODE (tem) == USE || GET_CODE (tem) == CLOBBER)\n-\t\t    continue;\n-\n-\t\t  if (GET_CODE (tem) != SET\n-\t\t      || (sreg = true_regnum (SET_SRC (tem))) < 0\n-\t\t      || (dreg = true_regnum (SET_DEST (tem))) < 0\n-\t\t      || dreg != sreg)\n-\t\t    break;\n-\t\t}\n-\n-\t      if (i < 0)\n-\t\tdelete_insn (insn);\n-\t    }\n-\t}\n-      insn = next;\n-    }\n-}\n-\n /* LOOP_START is a NOTE_INSN_LOOP_BEG note that is followed by an unconditional\n    jump.  Assume that this unconditional jump is to the exit test code.  If\n    the code is sufficiently simple, make a copy of it before INSN,\n@@ -1041,15 +455,6 @@ duplicate_loop_exit_test (loop_start)\n \t\t    predict_insn_def (copy, PRED_LOOP_HEADER, NOT_TAKEN);\n \t\t}\n \t    }\n-\t  /* If this is a simple jump, add it to the jump chain.  */\n-\n-\t  if (INSN_UID (copy) < max_jump_chain && JUMP_LABEL (copy)\n-\t      && simplejump_p (copy))\n-\t    {\n-\t      jump_chain[INSN_UID (copy)]\n-\t\t= jump_chain[INSN_UID (JUMP_LABEL (copy))];\n-\t      jump_chain[INSN_UID (JUMP_LABEL (copy))] = copy;\n-\t    }\n \t  break;\n \n \tdefault:\n@@ -1077,13 +482,6 @@ duplicate_loop_exit_test (loop_start)\n \tfirst_copy = copy;\n \n       mark_jump_label (PATTERN (copy), copy, 0);\n-      if (INSN_UID (copy) < max_jump_chain\n-\t  && INSN_UID (JUMP_LABEL (copy)) < max_jump_chain)\n-\t{\n-\t  jump_chain[INSN_UID (copy)]\n-\t    = jump_chain[INSN_UID (JUMP_LABEL (copy))];\n-\t  jump_chain[INSN_UID (JUMP_LABEL (copy))] = copy;\n-\t}\n       emit_barrier_before (loop_start);\n     }\n \n@@ -1920,33 +1318,6 @@ follow_jumps (label)\n   return value;\n }\n \n-/* Assuming that field IDX of X is a vector of label_refs,\n-   replace each of them by the ultimate label reached by it.\n-   Return nonzero if a change is made.\n-   If IGNORE_LOOPS is 0, we do not chain across a NOTE_INSN_LOOP_BEG.  */\n-\n-static int\n-tension_vector_labels (x, idx)\n-     register rtx x;\n-     register int idx;\n-{\n-  int changed = 0;\n-  register int i;\n-  for (i = XVECLEN (x, idx) - 1; i >= 0; i--)\n-    {\n-      register rtx olabel = XEXP (XVECEXP (x, idx, i), 0);\n-      register rtx nlabel = follow_jumps (olabel);\n-      if (nlabel && nlabel != olabel)\n-\t{\n-\t  XEXP (XVECEXP (x, idx, i), 0) = nlabel;\n-\t  ++LABEL_NUSES (nlabel);\n-\t  if (--LABEL_NUSES (olabel) == 0)\n-\t    delete_insn (olabel);\n-\t  changed = 1;\n-\t}\n-    }\n-  return changed;\n-}\n \f\n /* Find all CODE_LABELs referred to in X, and increment their use counts.\n    If INSN is a JUMP_INSN and there is at least one CODE_LABEL referenced\n@@ -2311,10 +1682,6 @@ delete_insn (insn)\n     /* Mark this insn as deleted.  */\n     INSN_DELETED_P (insn) = 1;\n \n-  /* If this is an unconditional jump, delete it from the jump chain.  */\n-  if (simplejump_p (insn))\n-    delete_from_jump_chain (insn);\n-\n   /* If instruction is followed by a barrier,\n      delete the barrier too.  */\n \n@@ -2673,23 +2040,6 @@ redirect_jump (jump, nlabel, delete_unused)\n   if (! redirect_exp (olabel, nlabel, jump))\n     return 0;\n \n-  /* If this is an unconditional branch, delete it from the jump_chain of\n-     OLABEL and add it to the jump_chain of NLABEL (assuming both labels\n-     have UID's in range and JUMP_CHAIN is valid).  */\n-  if (jump_chain && (simplejump_p (jump)\n-\t\t     || GET_CODE (PATTERN (jump)) == RETURN))\n-    {\n-      int label_index = nlabel ? INSN_UID (nlabel) : 0;\n-\n-      delete_from_jump_chain (jump);\n-      if (label_index < max_jump_chain\n-\t  && INSN_UID (jump) < max_jump_chain)\n-\t{\n-\t  jump_chain[INSN_UID (jump)] = jump_chain[label_index];\n-\t  jump_chain[label_index] = jump;\n-\t}\n-    }\n-\n   JUMP_LABEL (jump) = nlabel;\n   if (nlabel)\n     ++LABEL_NUSES (nlabel);\n@@ -2820,131 +2170,6 @@ invert_jump (jump, nlabel, delete_unused)\n   return 0;\n }\n \n-/* Delete the instruction JUMP from any jump chain it might be on.  */\n-\n-static void\n-delete_from_jump_chain (jump)\n-     rtx jump;\n-{\n-  int index;\n-  rtx olabel = JUMP_LABEL (jump);\n-\n-  /* Handle unconditional jumps.  */\n-  if (jump_chain && olabel != 0\n-      && INSN_UID (olabel) < max_jump_chain\n-      && simplejump_p (jump))\n-    index = INSN_UID (olabel);\n-  /* Handle return insns.  */\n-  else if (jump_chain && GET_CODE (PATTERN (jump)) == RETURN)\n-    index = 0;\n-  else\n-    return;\n-\n-  if (jump_chain[index] == jump)\n-    jump_chain[index] = jump_chain[INSN_UID (jump)];\n-  else\n-    {\n-      rtx insn;\n-\n-      for (insn = jump_chain[index];\n-\t   insn != 0;\n-\t   insn = jump_chain[INSN_UID (insn)])\n-\tif (jump_chain[INSN_UID (insn)] == jump)\n-\t  {\n-\t    jump_chain[INSN_UID (insn)] = jump_chain[INSN_UID (jump)];\n-\t    break;\n-\t  }\n-    }\n-}\n-\f\n-/* Make jump JUMP jump to label NLABEL, assuming it used to be a tablejump.\n-\n-   If the old jump target label (before the dispatch table) becomes unused,\n-   it and the dispatch table may be deleted.  In that case, find the insn\n-   before the jump references that label and delete it and logical successors\n-   too.  */\n-\n-static void\n-redirect_tablejump (jump, nlabel)\n-     rtx jump, nlabel;\n-{\n-  register rtx olabel = JUMP_LABEL (jump);\n-  rtx *notep, note, next;\n-\n-  /* Add this jump to the jump_chain of NLABEL.  */\n-  if (jump_chain && INSN_UID (nlabel) < max_jump_chain\n-      && INSN_UID (jump) < max_jump_chain)\n-    {\n-      jump_chain[INSN_UID (jump)] = jump_chain[INSN_UID (nlabel)];\n-      jump_chain[INSN_UID (nlabel)] = jump;\n-    }\n-\n-  for (notep = &REG_NOTES (jump), note = *notep; note; note = next)\n-    {\n-      next = XEXP (note, 1);\n-\n-      if (REG_NOTE_KIND (note) != REG_DEAD\n-\t  /* Verify that the REG_NOTE is legitimate.  */\n-\t  || GET_CODE (XEXP (note, 0)) != REG\n-\t  || ! reg_mentioned_p (XEXP (note, 0), PATTERN (jump)))\n-\tnotep = &XEXP (note, 1);\n-      else\n-\t{\n-\t  delete_prior_computation (note, jump);\n-\t  *notep = next;\n-\t}\n-    }\n-\n-  PATTERN (jump) = gen_jump (nlabel);\n-  JUMP_LABEL (jump) = nlabel;\n-  ++LABEL_NUSES (nlabel);\n-  INSN_CODE (jump) = -1;\n-\n-  if (--LABEL_NUSES (olabel) == 0)\n-    {\n-      delete_labelref_insn (jump, olabel, 0);\n-      delete_insn (olabel);\n-    }\n-}\n-\n-/* Find the insn referencing LABEL that is a logical predecessor of INSN.\n-   If we found one, delete it and then delete this insn if DELETE_THIS is\n-   non-zero.  Return non-zero if INSN or a predecessor references LABEL.  */\n-\n-static int\n-delete_labelref_insn (insn, label, delete_this)\n-     rtx insn, label;\n-     int delete_this;\n-{\n-  int deleted = 0;\n-  rtx link;\n-\n-  if (GET_CODE (insn) != NOTE\n-      && reg_mentioned_p (label, PATTERN (insn)))\n-    {\n-      if (delete_this)\n-\t{\n-\t  delete_insn (insn);\n-\t  deleted = 1;\n-\t}\n-      else\n-\treturn 1;\n-    }\n-\n-  for (link = LOG_LINKS (insn); link; link = XEXP (link, 1))\n-    if (delete_labelref_insn (XEXP (link, 0), label, 1))\n-      {\n-\tif (delete_this)\n-\t  {\n-\t    delete_insn (insn);\n-\t    deleted = 1;\n-\t  }\n-\telse\n-\t  return 1;\n-      }\n-\n-  return deleted;\n-}\n \f\n /* Like rtx_equal_p except that it considers two REGs as equal\n    if they renumber to the same value and considers two commutative"}, {"sha": "38803b21e802455087cfaac5f691a5e7cd5d974f", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0045d504351e0aa05f1463820b0b86933ba14849/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0045d504351e0aa05f1463820b0b86933ba14849/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=0045d504351e0aa05f1463820b0b86933ba14849", "patch": "@@ -406,7 +406,7 @@ pop_stack (regstack, regno)\n    dump file, if used.\n \n    Construct a CFG and run life analysis.  Then convert each insn one\n-   by one.  Run a last jump_optimize pass, if optimizing, to eliminate\n+   by one.  Run a last cleanup_cfg pass, if optimizing, to eliminate\n    code duplication created when the converter inserts pop insns on\n    the edges.  */\n "}, {"sha": "8c8a2db7854698d0104fe0a7b79a021c6aae0510", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0045d504351e0aa05f1463820b0b86933ba14849/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0045d504351e0aa05f1463820b0b86933ba14849/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=0045d504351e0aa05f1463820b0b86933ba14849", "patch": "@@ -1715,8 +1715,6 @@ extern int rtx_renumbered_equal_p\tPARAMS ((rtx, rtx));\n extern int true_regnum\t\t\tPARAMS ((rtx));\n extern int redirect_jump_1\t\tPARAMS ((rtx, rtx));\n extern int redirect_jump\t\tPARAMS ((rtx, rtx, int));\n-extern void jump_optimize\t\tPARAMS ((rtx, int, int));\n-extern void jump_optimize_minimal\tPARAMS ((rtx));\n extern void rebuild_jump_labels\t\tPARAMS ((rtx));\n extern void thread_jumps\t\tPARAMS ((rtx, int, int));\n extern int rtx_equal_for_thread_p\tPARAMS ((rtx, rtx, rtx));\n@@ -1727,10 +1725,8 @@ extern enum rtx_code reversed_comparison_code_parts PARAMS ((enum rtx_code,\n extern void delete_for_peephole\t\tPARAMS ((rtx, rtx));\n extern int condjump_in_parallel_p\tPARAMS ((rtx));\n extern void never_reached_warning\tPARAMS ((rtx));\n-\n-/* Flags for jump_optimize() */\n-#define JUMP_NOOP_MOVES\t\t\t1\n-#define JUMP_AFTER_REGSCAN\t\t1\n+extern void purge_line_number_notes\tPARAMS ((rtx));\n+extern void copy_loop_headers\t\tPARAMS ((rtx));\n \n /* In emit-rtl.c. */\n extern int max_reg_num\t\t\t\tPARAMS ((void));"}, {"sha": "c95db81de4a73ec94ef4293010bf6ae6290a21ba", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0045d504351e0aa05f1463820b0b86933ba14849/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0045d504351e0aa05f1463820b0b86933ba14849/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=0045d504351e0aa05f1463820b0b86933ba14849", "patch": "@@ -3467,7 +3467,7 @@ expand_nl_handler_label (slot, before_insn)\n   rtx insns;\n   rtx handler_label = gen_label_rtx ();\n \n-  /* Don't let jump_optimize delete the handler.  */\n+  /* Don't let cleanup_cfg delete the handler.  */\n   LABEL_PRESERVE_P (handler_label) = 1;\n \n   start_sequence ();"}, {"sha": "13a5d059b0cd9433220bea09ecd3d8beaeaac2a9", "filename": "gcc/toplev.c", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0045d504351e0aa05f1463820b0b86933ba14849/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0045d504351e0aa05f1463820b0b86933ba14849/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=0045d504351e0aa05f1463820b0b86933ba14849", "patch": "@@ -2774,7 +2774,7 @@ rest_of_compilation (decl)\n   purge_hard_subreg_sets (get_insns ());\n   emit_initial_value_sets ();\n \n-  /* Don't return yet if -Wreturn-type; we need to do jump_optimize.  */\n+  /* Don't return yet if -Wreturn-type; we need to do cleanup_cfg.  */\n   if ((rtl_dump_and_exit || flag_syntax_only) && !warn_return_type)\n     goto exit_rest_of_compilation;\n \n@@ -2839,7 +2839,11 @@ rest_of_compilation (decl)\n   expected_value_to_br_prob ();\n \n   reg_scan (insns, max_reg_num (), 0);\n-  jump_optimize (insns, !JUMP_NOOP_MOVES, JUMP_AFTER_REGSCAN);\n+  rebuild_jump_labels (insns);\n+  find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+  cleanup_cfg (optimize ? CLEANUP_EXPENSIVE : 0);\n+  copy_loop_headers (insns);\n+  purge_line_number_notes (insns);\n \n   timevar_pop (TV_JUMP);\n \n@@ -2981,7 +2985,9 @@ rest_of_compilation (decl)\n       if (tem || optimize > 1)\n \t{\n \t  timevar_push (TV_JUMP);\n-\t  jump_optimize (insns, !JUMP_NOOP_MOVES, !JUMP_AFTER_REGSCAN);\n+\t  rebuild_jump_labels (insns);\n+\t  find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+\t  cleanup_cfg (CLEANUP_EXPENSIVE);\n \t  timevar_pop (TV_JUMP);\n \t}\n \n@@ -3053,7 +3059,8 @@ rest_of_compilation (decl)\n \t{\n \t  tem = tem2 = 0;\n \t  timevar_push (TV_JUMP);\n-\t  jump_optimize (insns, !JUMP_NOOP_MOVES, !JUMP_AFTER_REGSCAN);\n+\t  rebuild_jump_labels (insns);\n+\t  cleanup_cfg (CLEANUP_EXPENSIVE);\n \t  timevar_pop (TV_JUMP);\n \n \t  if (flag_expensive_optimizations)\n@@ -3126,7 +3133,6 @@ rest_of_compilation (decl)\n \t  delete_trivially_dead_insns (insns, max_reg_num (), 0);\n \n \t  reg_scan (insns, max_reg_num (), 0);\n-\t  jump_optimize (insns, !JUMP_NOOP_MOVES, JUMP_AFTER_REGSCAN);\n \n \t  timevar_push (TV_IFCVT);\n \n@@ -3144,7 +3150,9 @@ rest_of_compilation (decl)\n \t  if (tem)\n \t    {\n \t      timevar_push (TV_JUMP);\n-\t      jump_optimize (insns, !JUMP_NOOP_MOVES, !JUMP_AFTER_REGSCAN);\n+\t      rebuild_jump_labels (insns);\n+\t      find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+\t      cleanup_cfg (CLEANUP_EXPENSIVE);\n \t      timevar_pop (TV_JUMP);\n \t    }\n \t}\n@@ -3461,8 +3469,8 @@ rest_of_compilation (decl)\n   timevar_push (TV_FLOW2);\n   open_dump_file (DFI_flow2, decl);\n \n-  jump_optimize (insns, JUMP_NOOP_MOVES, !JUMP_AFTER_REGSCAN);\n   find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+  cleanup_cfg (0);\n \n   /* On some machines, the prologue and epilogue code, or parts thereof,\n      can be represented as RTL.  Doing so lets us schedule insns between\n@@ -3599,6 +3607,8 @@ rest_of_compilation (decl)\n \n   /* CFG no longer kept up to date.  */\n \n+  purge_line_number_notes (insns);\n+\n   /* If a scheduling pass for delayed branches is to be done,\n      call the scheduling code.  */\n "}]}