{"sha": "3bb41228d76b3a3cbd9923d57388f0903f7683de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2JiNDEyMjhkNzZiM2EzY2JkOTkyM2Q1NzM4OGYwOTAzZjc2ODNkZQ==", "commit": {"author": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2021-04-26T22:36:18Z"}, "committer": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2021-04-27T15:23:18Z"}, "message": "op_by_pieces_d::run: Change a while loop to a do-while loop\n\nChange a while loop in op_by_pieces_d::run to a do-while loop to prepare\nfor offset adjusted operation for the remaining bytes on the last piece\noperation of a memory region.\n\n\tPR middle-end/90773\n\t* expr.c (op_by_pieces_d::get_usable_mode): New member function.\n\t(op_by_pieces_d::run): Cange a while loop to a do-while loop.", "tree": {"sha": "48d764ddb797c6912199cd3eb10165a4715fc32d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48d764ddb797c6912199cd3eb10165a4715fc32d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3bb41228d76b3a3cbd9923d57388f0903f7683de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bb41228d76b3a3cbd9923d57388f0903f7683de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bb41228d76b3a3cbd9923d57388f0903f7683de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bb41228d76b3a3cbd9923d57388f0903f7683de/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42a10bb884c0d5af2583b8bfe4d239ce95bf9e43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42a10bb884c0d5af2583b8bfe4d239ce95bf9e43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42a10bb884c0d5af2583b8bfe4d239ce95bf9e43"}], "stats": {"total": 76, "additions": 53, "deletions": 23}, "files": [{"sha": "a4a004dd177dd59b4e1a15c8f4ed6711a8a8dbd9", "filename": "gcc/expr.c", "status": "modified", "additions": 53, "deletions": 23, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bb41228d76b3a3cbd9923d57388f0903f7683de/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bb41228d76b3a3cbd9923d57388f0903f7683de/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=3bb41228d76b3a3cbd9923d57388f0903f7683de", "patch": "@@ -1041,6 +1041,9 @@ pieces_addr::maybe_postinc (HOST_WIDE_INT size)\n \n class op_by_pieces_d\n {\n+ private:\n+  scalar_int_mode get_usable_mode (scalar_int_mode mode, unsigned int);\n+\n  protected:\n   pieces_addr m_to, m_from;\n   unsigned HOST_WIDE_INT m_len;\n@@ -1108,6 +1111,25 @@ op_by_pieces_d::op_by_pieces_d (rtx to, bool to_load,\n   m_align = align;\n }\n \n+/* This function returns the largest usable integer mode for LEN bytes\n+   whose size is no bigger than size of MODE.  */\n+\n+scalar_int_mode\n+op_by_pieces_d::get_usable_mode (scalar_int_mode mode, unsigned int len)\n+{\n+  unsigned int size;\n+  do\n+    {\n+      size = GET_MODE_SIZE (mode);\n+      if (len >= size && prepare_mode (mode, m_align))\n+\tbreak;\n+      /* NB: widest_int_mode_for_size checks SIZE > 1.  */\n+      mode = widest_int_mode_for_size (size);\n+    }\n+  while (1);\n+  return mode;\n+}\n+\n /* This function contains the main loop used for expanding a block\n    operation.  First move what we can in the largest integer mode,\n    then go to successively smaller modes.  For every access, call\n@@ -1116,42 +1138,50 @@ op_by_pieces_d::op_by_pieces_d (rtx to, bool to_load,\n void\n op_by_pieces_d::run ()\n {\n-  while (m_max_size > 1 && m_len > 0)\n+  if (m_len == 0)\n+    return;\n+\n+  /* NB: widest_int_mode_for_size checks M_MAX_SIZE > 1.  */\n+  scalar_int_mode mode = widest_int_mode_for_size (m_max_size);\n+  mode = get_usable_mode (mode, m_len);\n+\n+  do\n     {\n-      scalar_int_mode mode = widest_int_mode_for_size (m_max_size);\n+      unsigned int size = GET_MODE_SIZE (mode);\n+      rtx to1 = NULL_RTX, from1;\n \n-      if (prepare_mode (mode, m_align))\n+      while (m_len >= size)\n \t{\n-\t  unsigned int size = GET_MODE_SIZE (mode);\n-\t  rtx to1 = NULL_RTX, from1;\n+\t  if (m_reverse)\n+\t    m_offset -= size;\n \n-\t  while (m_len >= size)\n-\t    {\n-\t      if (m_reverse)\n-\t\tm_offset -= size;\n+\t  to1 = m_to.adjust (mode, m_offset);\n+\t  from1 = m_from.adjust (mode, m_offset);\n \n-\t      to1 = m_to.adjust (mode, m_offset);\n-\t      from1 = m_from.adjust (mode, m_offset);\n+\t  m_to.maybe_predec (-(HOST_WIDE_INT)size);\n+\t  m_from.maybe_predec (-(HOST_WIDE_INT)size);\n \n-\t      m_to.maybe_predec (-(HOST_WIDE_INT)size);\n-\t      m_from.maybe_predec (-(HOST_WIDE_INT)size);\n+\t  generate (to1, from1, mode);\n \n-\t      generate (to1, from1, mode);\n+\t  m_to.maybe_postinc (size);\n+\t  m_from.maybe_postinc (size);\n \n-\t      m_to.maybe_postinc (size);\n-\t      m_from.maybe_postinc (size);\n+\t  if (!m_reverse)\n+\t    m_offset += size;\n \n-\t      if (!m_reverse)\n-\t\tm_offset += size;\n+\t  m_len -= size;\n+\t}\n \n-\t      m_len -= size;\n-\t    }\n+      finish_mode (mode);\n \n-\t  finish_mode (mode);\n-\t}\n+      if (m_len == 0)\n+\treturn;\n \n-      m_max_size = GET_MODE_SIZE (mode);\n+      /* NB: widest_int_mode_for_size checks SIZE > 1.  */\n+      mode = widest_int_mode_for_size (size);\n+      mode = get_usable_mode (mode, m_len);\n     }\n+  while (1);\n \n   /* The code above should have handled everything.  */\n   gcc_assert (!m_len);"}]}