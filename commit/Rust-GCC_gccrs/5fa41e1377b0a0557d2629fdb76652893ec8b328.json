{"sha": "5fa41e1377b0a0557d2629fdb76652893ec8b328", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWZhNDFlMTM3N2IwYTA1NTdkMjYyOWZkYjc2NjUyODkzZWM4YjMyOA==", "commit": {"author": {"name": "Stan Cox", "email": "scox@cygnus.com", "date": "2000-05-11T13:52:44Z"}, "committer": {"name": "Stan Cox", "email": "scox@gcc.gnu.org", "date": "2000-05-11T13:52:44Z"}, "message": "regrename.c (replace_reg_in_block): Improve REG_DEAD handling.\n\n\t* regrename.c (replace_reg_in_block): Improve REG_DEAD handling.\n\t* timevar.def (TV_RENAME_REGISTERS): Move before TV_SCHED2.\n\t* toplev.c (rest_of_compilation): Call regrename_optimize before sched2.\n\nFrom-SVN: r33845", "tree": {"sha": "de16cdc450bf07d7d0789dabc3235be3498d21f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de16cdc450bf07d7d0789dabc3235be3498d21f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5fa41e1377b0a0557d2629fdb76652893ec8b328", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fa41e1377b0a0557d2629fdb76652893ec8b328", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fa41e1377b0a0557d2629fdb76652893ec8b328", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fa41e1377b0a0557d2629fdb76652893ec8b328/comments", "author": null, "committer": null, "parents": [{"sha": "f5b105ca62822071a14228e1790f69429a9990c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5b105ca62822071a14228e1790f69429a9990c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5b105ca62822071a14228e1790f69429a9990c8"}], "stats": {"total": 117, "additions": 86, "deletions": 31}, "files": [{"sha": "3a7c61ebae230a347479c2dccab3406263eb1889", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa41e1377b0a0557d2629fdb76652893ec8b328/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa41e1377b0a0557d2629fdb76652893ec8b328/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5fa41e1377b0a0557d2629fdb76652893ec8b328", "patch": "@@ -1,3 +1,9 @@\n+2000-05-11 Stan Cox <scox@cygnus.com>\n+\n+\t* regrename.c (replace_reg_in_block): Improve REG_DEAD handling.\n+\t* timevar.def (TV_RENAME_REGISTERS): Move before TV_SCHED2.\n+\t* toplev.c (rest_of_compilation): Call regrename_optimize before sched2.\n+\n 2000-05-11  Bruce Korb  <bkorb@gnu.org>\n \n \t* fixinc/fixfixes.c(double_slash_fix):  obsolete"}, {"sha": "d5e8160c94faaa2ba7416e1995092ba966f16479", "filename": "gcc/regrename.c", "status": "modified", "additions": 64, "deletions": 15, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa41e1377b0a0557d2629fdb76652893ec8b328/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa41e1377b0a0557d2629fdb76652893ec8b328/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=5fa41e1377b0a0557d2629fdb76652893ec8b328", "patch": "@@ -526,8 +526,11 @@ replace_reg_in_block (du, uid_ruid, def, reg_def, avail_reg)\n      unsigned int avail_reg;\n {\n   int du_idx, status = 1;\n+  int last_replaced_insn;\n   unsigned int r = REGNO (reg_def);\n   rtx death_note;\n+  rtx reg_notes;\n+  rtx reg_use;\n   rtx new_reg = gen_rtx_REG (GET_MODE (reg_def), avail_reg);\n \n   rr_replace_reg (PATTERN (VARRAY_RTX (*uid_ruid, def)), reg_def, new_reg,\n@@ -536,39 +539,64 @@ replace_reg_in_block (du, uid_ruid, def, reg_def, avail_reg)\n   if (!status)\n     return status;\n \n-  death_note = find_reg_note (VARRAY_RTX (*uid_ruid, def), REG_DEAD, reg_def);\n-  if (!death_note)\n-    death_note = find_reg_note (VARRAY_RTX (*uid_ruid, def), REG_UNUSED,\n-\t\t\t\treg_def);\n+  death_note = 0;\n+  /* This typically happens if a constraint check failed and the register\n+     changes are being reversed. */\n+  for (reg_notes = REG_NOTES (VARRAY_RTX (*uid_ruid, def));\n+       reg_notes; reg_notes = XEXP (reg_notes, 1))\n+    {\n+      if (REG_NOTE_KIND (reg_notes) == REG_DEAD\n+\t  && REGNO (XEXP (reg_notes, 0)) == avail_reg)\n+\tdeath_note = reg_notes;\n+    }\n \n   if (death_note)\n-    rr_replace_reg (death_note, reg_def, new_reg, 0,\n-\t\t    VARRAY_RTX (*uid_ruid, def), &status);\n+    remove_note (VARRAY_RTX (*uid_ruid, def), death_note);\n+  \n+  /* The old destination is now dead if it is also a source. */\n+  if (regno_use_in (r, PATTERN (VARRAY_RTX (*uid_ruid, def))))\n+    REG_NOTES (VARRAY_RTX (*uid_ruid, def))\n+      = gen_rtx_EXPR_LIST (REG_DEAD, reg_def,\n+\t\t\t   REG_NOTES (VARRAY_RTX (*uid_ruid,\n+\t\t\t\t\t\t  def)));\n+\n+  last_replaced_insn = 0;\n \n+  /* Now replace in the uses. */\n   for (du_idx = def + 1; du_idx < du->high_bound; du_idx++)\n     {\n-      rtx reg_use;\n-      rtx new_reg;\n-\n       if (GET_RTX_CLASS (GET_CODE (VARRAY_RTX (*uid_ruid, du_idx))) != 'i')\n \tcontinue;\n \n       reg_use = regno_use_in (r, PATTERN (VARRAY_RTX (*uid_ruid, du_idx)));\n+\n       if (reg_use && TEST_BIT (du->uses[r], du_idx))\n \t{\n \t  new_reg = gen_rtx_REG (GET_MODE (reg_use), avail_reg);\n+\t  \n \t  rr_replace_reg (PATTERN (VARRAY_RTX (*uid_ruid, du_idx)), reg_use,\n \t\t\t  new_reg, SOURCE, VARRAY_RTX (*uid_ruid, du_idx),\n \t\t\t  &status);\n \t  death_note = find_reg_note (VARRAY_RTX (*uid_ruid, du_idx),\n \t\t\t\t      REG_DEAD, reg_use);\n-\t  if (!death_note)\n-\t    death_note = find_reg_note (VARRAY_RTX (*uid_ruid, du_idx),\n-\t\t\t\t\tREG_UNUSED, reg_use);\n \t  if (death_note)\n-\t    rr_replace_reg (death_note, reg_use, new_reg, 0,\n-\t\t\t    VARRAY_RTX (*uid_ruid, def), &status);\n+\t    {\n+\t      REG_NOTES (VARRAY_RTX (*uid_ruid, du_idx))\n+\t\t= gen_rtx_EXPR_LIST (REG_DEAD, new_reg,\n+\t\t\t\t     REG_NOTES (VARRAY_RTX (*uid_ruid,\n+\t\t\t\t\t\t\t    du_idx)));\n+\t      remove_note (VARRAY_RTX (*uid_ruid, du_idx),\n+\t\t\t   find_reg_note (VARRAY_RTX (*uid_ruid, du_idx),\n+\t\t\t\t\t  REG_DEAD, reg_use));\n+\t    }\n+\t}\n \n+      /* This insn may contain shared rtl replaced in the previous iteration.\n+\t Treat this equivalent to the rr_replace_reg case. */\n+      if (TEST_BIT (du->uses[r], du_idx))\n+\t{\n+\t  last_replaced_insn = du_idx;\n+\t  \n \t  SET_BIT (du->uses[avail_reg], du_idx);\n \t  RESET_BIT (du->uses[r], du_idx);\n \t  if (!status)\n@@ -579,6 +607,27 @@ replace_reg_in_block (du, uid_ruid, def, reg_def, avail_reg)\n \tbreak;\n     }\n \n+  /* Add REG_DEAD note for replaced register at last use. */\n+\n+  if (last_replaced_insn)\n+    {\n+      new_reg = regno_use_in (avail_reg,\n+\t\t\t      PATTERN (VARRAY_RTX (*uid_ruid,\n+\t\t\t\t\t\t   last_replaced_insn)));\n+      if (new_reg\n+\t  && ! find_reg_note (VARRAY_RTX (*uid_ruid, last_replaced_insn),\n+\t\t\t\t      REG_DEAD, new_reg))\n+\t{\n+\t  REG_NOTES (VARRAY_RTX (*uid_ruid, last_replaced_insn))\n+\t    = gen_rtx_EXPR_LIST (REG_DEAD, new_reg,\n+\t\t\t\t REG_NOTES (VARRAY_RTX (*uid_ruid,\n+\t\t\t\t\t\t\tlast_replaced_insn)));\n+\t  remove_note (VARRAY_RTX (*uid_ruid, last_replaced_insn),\n+\t\t       find_reg_note (VARRAY_RTX (*uid_ruid, last_replaced_insn),\n+\t\t\t\t\t    REG_DEAD, reg_use));\n+\t}\n+    }\n+\n   return status;\n }\n \n@@ -611,7 +660,7 @@ rr_replace_reg (x, reg_use, reg_sub, replace_type, insn, status)\n \t  if (GET_MODE (x) == GET_MODE (reg_use))\n \t    return reg_sub;\n \t  else\n-\t    return gen_rtx_REG (GET_MODE (x), REGNO (reg_use));\n+\t    return gen_rtx_REG (GET_MODE (x), REGNO (reg_sub));\n \t}\n \n       return x;"}, {"sha": "fcf21772c0203c07b6af863581845719e367cf97", "filename": "gcc/timevar.def", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa41e1377b0a0557d2629fdb76652893ec8b328/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa41e1377b0a0557d2629fdb76652893ec8b328/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=5fa41e1377b0a0557d2629fdb76652893ec8b328", "patch": "@@ -60,10 +60,10 @@ DEFTIMEVAR (TV_RELOAD_CSE_REGS       , \"reload CSE regs\")\n DEFTIMEVAR (TV_FLOW2                 , \"flow 2\")\n DEFTIMEVAR (TV_IFCVT2\t\t     , \"if-conversion 2\")\n DEFTIMEVAR (TV_PEEPHOLE2             , \"peephole 2\")\n-DEFTIMEVAR (TV_SCHED2                , \"schedulding 2\")\n+DEFTIMEVAR (TV_RENAME_REGISTERS      , \"rename registers\")\n+DEFTIMEVAR (TV_SCHED2                , \"scheduling 2\")\n DEFTIMEVAR (TV_DBR_SCHED             , \"delay branch sched\")\n DEFTIMEVAR (TV_REORDER_BLOCKS        , \"reorder blocks\")\n-DEFTIMEVAR (TV_RENAME_REGISTERS      , \"rename registers\")\n DEFTIMEVAR (TV_SHORTEN_BRANCH        , \"shorten branches\")\n DEFTIMEVAR (TV_REG_STACK             , \"reg stack\")\n DEFTIMEVAR (TV_TO_SSA                , \"convert to SSA\")"}, {"sha": "1d89a7c686b53077aae1fb1b1accb53fd5171c08", "filename": "gcc/toplev.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa41e1377b0a0557d2629fdb76652893ec8b328/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa41e1377b0a0557d2629fdb76652893ec8b328/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=5fa41e1377b0a0557d2629fdb76652893ec8b328", "patch": "@@ -272,9 +272,9 @@ enum dump_file_index\n   DFI_flow2,\n   DFI_ce2,\n   DFI_peephole2,\n+  DFI_rnreg,\n   DFI_sched2,\n   DFI_bbro,\n-  DFI_rnreg,\n   DFI_jump2,\n   DFI_mach,\n   DFI_dbr,\n@@ -314,9 +314,9 @@ struct dump_file_info dump_file[DFI_MAX] =\n   { \"flow2\",\t'w', 1, 0, 0 },\n   { \"ce2\",\t'E', 1, 0, 0 },\n   { \"peephole2\", 'z', 1, 0, 0 },\n+  { \"rnreg\",\t'n', 1, 0, 0 },\n   { \"sched2\",\t'R', 1, 0, 0 },\n   { \"bbro\",\t'B', 1, 0, 0 },\n-  { \"rnreg\",\t'n', 1, 0, 0 },\n   { \"jump2\",\t'J', 1, 0, 0 },\n   { \"mach\",\t'M', 1, 0, 0 },\n   { \"dbr\",\t'd', 0, 0, 0 },\n@@ -3358,7 +3358,7 @@ rest_of_compilation (decl)\n       cleanup_cfg (insns);\n       life_analysis (insns, rtl_dump_file, PROP_FINAL);\n \n-      /* This is kind of heruistics.  We need to run combine_stack_adjustments\n+      /* This is kind of a heuristic.  We need to run combine_stack_adjustments\n          even for machines with possibly nonzero RETURN_POPS_ARGS\n          and ACCUMULATE_OUTGOING_ARGS.  We expect that only ports having\n          push instructions will have popping returns.  */\n@@ -3400,6 +3400,17 @@ rest_of_compilation (decl)\n     }\n #endif\n \n+  if (optimize > 0 && flag_rename_registers)\n+    {\n+      timevar_push (TV_RENAME_REGISTERS);\n+      open_dump_file (DFI_rnreg, decl);\n+\n+      regrename_optimize ();\n+\n+      close_dump_file (DFI_rnreg, print_rtl_with_bb, insns);\n+      timevar_pop (TV_RENAME_REGISTERS);\n+    }    \n+\n #ifdef INSN_SCHEDULING\n   if (optimize > 0 && flag_schedule_insns_after_reload)\n     {\n@@ -3435,17 +3446,6 @@ rest_of_compilation (decl)\n       timevar_pop (TV_REORDER_BLOCKS);\n     }    \n \n-  if (optimize > 0 && flag_rename_registers)\n-    {\n-      timevar_push (TV_RENAME_REGISTERS);\n-      open_dump_file (DFI_rnreg, decl);\n-\n-      regrename_optimize ();\n-\n-      close_dump_file (DFI_rnreg, print_rtl_with_bb, insns);\n-      timevar_pop (TV_RENAME_REGISTERS);\n-    }    \n-\n   /* One more attempt to remove jumps to .+1 left by dead-store elimination. \n      Also do cross-jumping this time and delete no-op move insns.  */\n "}]}