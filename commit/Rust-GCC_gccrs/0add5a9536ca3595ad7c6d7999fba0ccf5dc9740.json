{"sha": "0add5a9536ca3595ad7c6d7999fba0ccf5dc9740", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGFkZDVhOTUzNmNhMzU5NWFkN2M2ZDc5OTlmYmEwY2NmNWRjOTc0MA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-12-02T15:00:35Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-12-02T15:00:35Z"}, "message": "[multiple changes]\n\n2011-12-02  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_dbug.adb: Comment reformatting.\n\t(Get_External_Name): Use Reset_Buffers to reset the contents of\n\tName_Buffer and Homonym_Numbers.\n\t(Qualify_All_Entity_Names): Reset the contents of Name_Buffer and\n\tHomonym_Numbers before creating a new qualified name for a particular\n\tentity.\n\t(Reset_Buffers): New routine.\n\n2011-12-02  Matthew Heaney  <heaney@adacore.com>\n\n\t* a-cbmutr.ads (No_Node): Moved declaration from body to spec\n\t* a-comutr.adb, a-cimutr.adb, a-cbmutr.adb (Iterator): Derives\n\tfrom Root_Iterator.\n\t(Child_Iterator): Derives from Root_Iterator.\n\t(Finalize): Implemented as an override operation for Root_Iterator.\n\t(First): Return value depends on Subtree component.\n\t(Last): Component was renamed from Parent to Subtree.\n\t(Next): Checks parameter value, and uses simplified loop.\n\t(Iterate): Forwards to Iterate_Subtree.\n\t(Iterate_Children): Component was renamed from Parent to Subtree.\n\t(Iterate_Subtree): Checks parameter value\n\n2011-12-02  Robert Dewar  <dewar@adacore.com>\n\n\t* usage.adb: Add lines for -gnatw.n and -gnatw.N\n\t(atomic sync info msgs).\n\n2011-12-02  Steve Baird  <baird@adacore.com>\n\n\t* sem_ch3.adb (Check_Completion): An Ada 2012\n\tgeneric formal type doesn't require a completion.\n\n2011-12-02  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* sem_util.adb (Set_Debug_Info_Needed): Also set the flag on the\n\tpacked array type if it is to be set on the array type used to\n\trepresent it.\n\n2011-12-02  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat_rm.texi: Eliminate confusing use of type name.\n\nFrom-SVN: r181919", "tree": {"sha": "1b7415ab9e85093c20b13f4f8eb683950dce5ac4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b7415ab9e85093c20b13f4f8eb683950dce5ac4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0add5a9536ca3595ad7c6d7999fba0ccf5dc9740", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0add5a9536ca3595ad7c6d7999fba0ccf5dc9740", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0add5a9536ca3595ad7c6d7999fba0ccf5dc9740", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0add5a9536ca3595ad7c6d7999fba0ccf5dc9740/comments", "author": null, "committer": null, "parents": [{"sha": "81435e80be7ece5ba2ed3851b04a0ec07da979fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81435e80be7ece5ba2ed3851b04a0ec07da979fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81435e80be7ece5ba2ed3851b04a0ec07da979fd"}], "stats": {"total": 638, "additions": 327, "deletions": 311}, "files": [{"sha": "3c668004cd56148635f99b211e16721d4cabc0f7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0add5a9536ca3595ad7c6d7999fba0ccf5dc9740/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0add5a9536ca3595ad7c6d7999fba0ccf5dc9740/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0add5a9536ca3595ad7c6d7999fba0ccf5dc9740", "patch": "@@ -1,3 +1,47 @@\n+2011-12-02  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_dbug.adb: Comment reformatting.\n+\t(Get_External_Name): Use Reset_Buffers to reset the contents of\n+\tName_Buffer and Homonym_Numbers.\n+\t(Qualify_All_Entity_Names): Reset the contents of Name_Buffer and\n+\tHomonym_Numbers before creating a new qualified name for a particular\n+\tentity.\n+\t(Reset_Buffers): New routine.\n+\n+2011-12-02  Matthew Heaney  <heaney@adacore.com>\n+\n+\t* a-cbmutr.ads (No_Node): Moved declaration from body to spec\n+\t* a-comutr.adb, a-cimutr.adb, a-cbmutr.adb (Iterator): Derives\n+\tfrom Root_Iterator.\n+\t(Child_Iterator): Derives from Root_Iterator.\n+\t(Finalize): Implemented as an override operation for Root_Iterator.\n+\t(First): Return value depends on Subtree component.\n+\t(Last): Component was renamed from Parent to Subtree.\n+\t(Next): Checks parameter value, and uses simplified loop.\n+\t(Iterate): Forwards to Iterate_Subtree.\n+\t(Iterate_Children): Component was renamed from Parent to Subtree.\n+\t(Iterate_Subtree): Checks parameter value\n+\n+2011-12-02  Robert Dewar  <dewar@adacore.com>\n+\n+\t* usage.adb: Add lines for -gnatw.n and -gnatw.N\n+\t(atomic sync info msgs).\n+\n+2011-12-02  Steve Baird  <baird@adacore.com>\n+\n+\t* sem_ch3.adb (Check_Completion): An Ada 2012\n+\tgeneric formal type doesn't require a completion.\n+\n+2011-12-02  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* sem_util.adb (Set_Debug_Info_Needed): Also set the flag on the\n+\tpacked array type if it is to be set on the array type used to\n+\trepresent it.\n+\n+2011-12-02  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat_rm.texi: Eliminate confusing use of type name.\n+\n 2011-12-02  Thomas Quinot  <quinot@adacore.com>\n \n \t* sem_ch10.adb (Analyze_Compilation_Unit): For a library subprogram"}, {"sha": "713e1be8d4bbbe43da8be67a482efd3a2fc3fced", "filename": "gcc/ada/a-cbmutr.adb", "status": "modified", "additions": 85, "deletions": 102, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0add5a9536ca3595ad7c6d7999fba0ccf5dc9740/gcc%2Fada%2Fa-cbmutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0add5a9536ca3595ad7c6d7999fba0ccf5dc9740/gcc%2Fada%2Fa-cbmutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbmutr.adb?ref=0add5a9536ca3595ad7c6d7999fba0ccf5dc9740", "patch": "@@ -33,45 +33,50 @@ with System; use type System.Address;\n \n package body Ada.Containers.Bounded_Multiway_Trees is\n \n-   No_Node : constant Count_Type'Base := -1;\n+   --------------------\n+   --  Root_Iterator --\n+   --------------------\n \n-   type Iterator is new Limited_Controlled and\n+   type Root_Iterator is abstract new Limited_Controlled and\n      Tree_Iterator_Interfaces.Forward_Iterator with\n    record\n       Container : Tree_Access;\n-      Position  : Cursor;\n-      From_Root : Boolean;\n+      Subtree   : Count_Type;\n    end record;\n \n-   overriding procedure Finalize (Object : in out Iterator);\n+   overriding procedure Finalize (Object : in out Root_Iterator);\n+\n+   -----------------------\n+   --  Subtree_Iterator --\n+   -----------------------\n+\n+   type Subtree_Iterator is new Root_Iterator with null record;\n \n-   overriding function First (Object : Iterator) return Cursor;\n+   overriding function First (Object : Subtree_Iterator) return Cursor;\n \n    overriding function Next\n-     (Object : Iterator;\n+     (Object   : Subtree_Iterator;\n       Position : Cursor) return Cursor;\n \n-   type Child_Iterator is new Limited_Controlled and\n-      Tree_Iterator_Interfaces.Reversible_Iterator with\n-   record\n-      Container : Tree_Access;\n-      Parent    : Count_Type;\n-   end record;\n+   ---------------------\n+   --  Child_Iterator --\n+   ---------------------\n \n-   overriding procedure Finalize (Object : in out Child_Iterator);\n+   type Child_Iterator is new Root_Iterator and\n+     Tree_Iterator_Interfaces.Reversible_Iterator with null record;\n \n    overriding function First (Object : Child_Iterator) return Cursor;\n \n    overriding function Next\n      (Object   : Child_Iterator;\n       Position : Cursor) return Cursor;\n \n+   overriding function Last (Object : Child_Iterator) return Cursor;\n+\n    overriding function Previous\n      (Object   : Child_Iterator;\n       Position : Cursor) return Cursor;\n \n-   overriding function Last (Object : Child_Iterator) return Cursor;\n-\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -1242,13 +1247,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n    -- Finalize --\n    --------------\n \n-   procedure Finalize (Object : in out Iterator) is\n-      B : Natural renames Object.Container.Busy;\n-   begin\n-      B := B - 1;\n-   end Finalize;\n-\n-   procedure Finalize (Object : in out Child_Iterator) is\n+   procedure Finalize (Object : in out Root_Iterator) is\n       B : Natural renames Object.Container.Busy;\n    begin\n       B := B - 1;\n@@ -1278,14 +1277,22 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       return Cursor'(Container'Unrestricted_Access, Node);\n    end Find;\n \n-   function First (Object : Iterator) return Cursor is\n+   -----------\n+   -- First --\n+   -----------\n+\n+   overriding function First (Object : Subtree_Iterator) return Cursor is\n    begin\n-      return Object.Position;\n+      if Object.Subtree = Root_Node (Object.Container.all) then\n+         return First_Child (Root (Object.Container.all));\n+      else\n+         return Cursor'(Object.Container, Object.Subtree);\n+      end if;\n    end First;\n \n-   function First (Object : Child_Iterator) return Cursor is\n+   overriding function First (Object : Child_Iterator) return Cursor is\n    begin\n-      return First_Child (Cursor'(Object.Container, Object.Parent));\n+      return First_Child (Cursor'(Object.Container, Object.Subtree));\n    end First;\n \n    -----------------\n@@ -1780,19 +1787,8 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n    function Iterate (Container : Tree)\n      return Tree_Iterator_Interfaces.Forward_Iterator'Class\n    is\n-      B  : Natural renames Container'Unrestricted_Access.all.Busy;\n-      RC : constant Cursor :=\n-             (Container'Unrestricted_Access, Root_Node (Container));\n-\n    begin\n-      return It : constant Iterator :=\n-                    Iterator'(Limited_Controlled with\n-                                Container => Container'Unrestricted_Access,\n-                                Position  => First_Child (RC),\n-                                From_Root => True)\n-      do\n-         B := B + 1;\n-      end return;\n+      return Iterate_Subtree (Root (Container));\n    end Iterate;\n \n    ----------------------\n@@ -1879,7 +1875,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       return It : constant Child_Iterator :=\n                     Child_Iterator'(Limited_Controlled with\n                                       Container => C,\n-                                      Parent    => Parent.Node)\n+                                      Subtree   => Parent.Node)\n       do\n          B := B + 1;\n       end return;\n@@ -1893,17 +1889,25 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n      (Position : Cursor)\n       return Tree_Iterator_Interfaces.Forward_Iterator'Class\n    is\n-      B : Natural renames Position.Container.all.Busy;\n-\n    begin\n-      return It : constant Iterator :=\n-                    Iterator'(Limited_Controlled with\n-                                Container => Position.Container,\n-                                Position  => Position,\n-                                From_Root => False)\n-      do\n-         B := B + 1;\n-      end return;\n+      if Position = No_Element then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      --  Implement Vet for multiway trees???\n+      --  pragma Assert (Vet (Position), \"bad subtree cursor\");\n+\n+      declare\n+         B : Natural renames Position.Container.Busy;\n+      begin\n+         return It : constant Subtree_Iterator :=\n+                       (Limited_Controlled with\n+                          Container => Position.Container,\n+                          Subtree   => Position.Node)\n+         do\n+            B := B + 1;\n+         end return;\n+      end;\n    end Iterate_Subtree;\n \n    procedure Iterate_Subtree\n@@ -1962,7 +1966,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n \n    overriding function Last (Object : Child_Iterator) return Cursor is\n    begin\n-      return Last_Child (Cursor'(Object.Container, Object.Parent));\n+      return Last_Child (Cursor'(Object.Container, Object.Subtree));\n    end Last;\n \n    ----------------\n@@ -2023,67 +2027,43 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n    -- Next --\n    ----------\n \n-   function Next\n-     (Object : Iterator;\n+   overriding function Next\n+     (Object   : Subtree_Iterator;\n       Position : Cursor) return Cursor\n    is\n-      T  : Tree renames Position.Container.all;\n-      NN : Tree_Node_Array renames T.Nodes;\n-      N  : Tree_Node_Type renames NN (Position.Node);\n-\n    begin\n-      if Is_Leaf (Position) then\n-\n-         --  If sibling is present, return it\n-\n-         if N.Next /= 0 then\n-            return (Object.Container, N.Next);\n-\n-         --  If this is the last sibling, go to sibling of first ancestor that\n-         --  has a sibling, or terminate.\n-\n-         else\n-            declare\n-               Pos : Count_Type := N.Parent;\n-               Par : Tree_Node_Type := NN (Pos);\n-\n-            begin\n-               while Par.Next = 0 loop\n-                  Pos := Par.Parent;\n-\n-                  --  If we are back at the root the iteration is complete\n-\n-                  if Pos = No_Node then\n-                     return No_Element;\n-\n-                  --  If this is a subtree iterator and we are back at the\n-                  --  starting node, iteration is complete.\n+      if Position.Container = null then\n+         return No_Element;\n+      end if;\n \n-                  elsif Pos = Object.Position.Node\n-                    and then not Object.From_Root\n-                  then\n-                     return No_Element;\n+      if Position.Container /= Object.Container then\n+         raise Program_Error with\n+           \"Position cursor of Next designates wrong tree\";\n+      end if;\n \n-                  else\n-                     Par := NN (Pos);\n-                  end if;\n-               end loop;\n+      pragma Assert (Object.Container.Count > 0);\n+      pragma Assert (Position.Node /= Root_Node (Object.Container.all));\n \n-               if Pos = Object.Position.Node\n-                 and then not Object.From_Root\n-               then\n-                  return No_Element;\n-               end if;\n+      declare\n+         Nodes : Tree_Node_Array renames Object.Container.Nodes;\n+         Node  : Count_Type;\n+      begin\n+         Node := Position.Node;\n \n-               return (Object.Container, Par.Next);\n-            end;\n+         if Nodes (Node).Children.First > 0 then\n+            return Cursor'(Object.Container, Nodes (Node).Children.First);\n          end if;\n \n-      --  If an internal node, return its first child\n+         while Node /= Object.Subtree loop\n+            if Nodes (Node).Next > 0 then\n+               return Cursor'(Object.Container, Nodes (Node).Next);\n+            end if;\n \n-      else\n-         return (Object.Container, N.Children.First);\n-      end if;\n+            Node := Nodes (Node).Parent;\n+         end loop;\n+\n+         return No_Element;\n+      end;\n    end Next;\n \n    overriding function Next\n@@ -2100,6 +2080,9 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n            \"Position cursor of Next designates wrong tree\";\n       end if;\n \n+      pragma Assert (Object.Container.Count > 0);\n+      pragma Assert (Position.Node /= Root_Node (Object.Container.all));\n+\n       return Next_Sibling (Position);\n    end Next;\n "}, {"sha": "73580d992cf92e41cab7546fe48fd6352dd68dcf", "filename": "gcc/ada/a-cbmutr.ads", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0add5a9536ca3595ad7c6d7999fba0ccf5dc9740/gcc%2Fada%2Fa-cbmutr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0add5a9536ca3595ad7c6d7999fba0ccf5dc9740/gcc%2Fada%2Fa-cbmutr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbmutr.ads?ref=0add5a9536ca3595ad7c6d7999fba0ccf5dc9740", "patch": "@@ -301,6 +301,8 @@ package Ada.Containers.Bounded_Multiway_Trees is\n private\n    use Ada.Streams;\n \n+   No_Node : constant Count_Type'Base := -1;\n+\n    type Children_Type is record\n       First : Count_Type'Base;\n       Last  : Count_Type'Base;\n@@ -319,7 +321,7 @@ private\n    type Tree (Capacity : Count_Type) is tagged record\n       Nodes    : Tree_Node_Array (0 .. Capacity) := (others => <>);\n       Elements : Element_Array (1 .. Capacity) := (others => <>);\n-      Free     : Count_Type'Base := -1;\n+      Free     : Count_Type'Base := No_Node;\n       Busy     : Integer := 0;\n       Lock     : Integer := 0;\n       Count    : Count_Type := 0;\n@@ -342,7 +344,7 @@ private\n \n    type Cursor is record\n       Container : Tree_Access;\n-      Node      : Count_Type'Base := -1;\n+      Node      : Count_Type'Base := No_Node;\n    end record;\n \n    procedure  Read"}, {"sha": "daac18feb04e88974bdc3e90fcf3fd044b6143ae", "filename": "gcc/ada/a-cimutr.adb", "status": "modified", "additions": 74, "deletions": 96, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0add5a9536ca3595ad7c6d7999fba0ccf5dc9740/gcc%2Fada%2Fa-cimutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0add5a9536ca3595ad7c6d7999fba0ccf5dc9740/gcc%2Fada%2Fa-cimutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cimutr.adb?ref=0add5a9536ca3595ad7c6d7999fba0ccf5dc9740", "patch": "@@ -33,41 +33,50 @@ with System; use type System.Address;\n \n package body Ada.Containers.Indefinite_Multiway_Trees is\n \n-   type Iterator is new Limited_Controlled and\n+   --------------------\n+   --  Root_Iterator --\n+   --------------------\n+\n+   type Root_Iterator is abstract new Limited_Controlled and\n      Tree_Iterator_Interfaces.Forward_Iterator with\n    record\n       Container : Tree_Access;\n-      Position  : Cursor;\n-      From_Root : Boolean;\n+      Subtree   : Tree_Node_Access;\n    end record;\n \n-   type Child_Iterator is new Limited_Controlled and\n-     Tree_Iterator_Interfaces.Reversible_Iterator with\n-   record\n-      Container : Tree_Access;\n-      Parent    : Tree_Node_Access;\n-   end record;\n+   overriding procedure Finalize (Object : in out Root_Iterator);\n \n-   overriding procedure Finalize (Object : in out Iterator);\n+   -----------------------\n+   --  Subtree_Iterator --\n+   -----------------------\n+\n+   type Subtree_Iterator is new Root_Iterator with null record;\n+\n+   overriding function First (Object : Subtree_Iterator) return Cursor;\n \n-   overriding function First (Object : Iterator) return Cursor;\n    overriding function Next\n-     (Object   : Iterator;\n+     (Object   : Subtree_Iterator;\n       Position : Cursor) return Cursor;\n \n-   overriding procedure Finalize (Object : in out Child_Iterator);\n+   ---------------------\n+   --  Child_Iterator --\n+   ---------------------\n+\n+   type Child_Iterator is new Root_Iterator and\n+     Tree_Iterator_Interfaces.Reversible_Iterator with null record;\n \n    overriding function First (Object : Child_Iterator) return Cursor;\n+\n    overriding function Next\n      (Object   : Child_Iterator;\n       Position : Cursor) return Cursor;\n \n+   overriding function Last (Object : Child_Iterator) return Cursor;\n+\n    overriding function Previous\n      (Object   : Child_Iterator;\n       Position : Cursor) return Cursor;\n \n-   overriding function Last (Object : Child_Iterator) return Cursor;\n-\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -936,13 +945,7 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n    -- Finalize --\n    --------------\n \n-   procedure Finalize (Object : in out Iterator) is\n-      B : Natural renames Object.Container.Busy;\n-   begin\n-      B := B - 1;\n-   end Finalize;\n-\n-   procedure Finalize (Object : in out Child_Iterator) is\n+   procedure Finalize (Object : in out Root_Iterator) is\n       B : Natural renames Object.Container.Busy;\n    begin\n       B := B - 1;\n@@ -971,14 +974,18 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n    -- First --\n    -----------\n \n-   function First (Object : Iterator) return Cursor is\n+   overriding function First (Object : Subtree_Iterator) return Cursor is\n    begin\n-      return Object.Position;\n+      if Object.Subtree = Root_Node (Object.Container.all) then\n+         return First_Child (Root (Object.Container.all));\n+      else\n+         return Cursor'(Object.Container, Object.Subtree);\n+      end if;\n    end First;\n \n-   function First (Object : Child_Iterator) return Cursor is\n+   overriding function First (Object : Child_Iterator) return Cursor is\n    begin\n-      return First_Child (Cursor'(Object.Container, Object.Parent));\n+      return First_Child (Cursor'(Object.Container, Object.Subtree));\n    end First;\n \n    -----------------\n@@ -1348,18 +1355,8 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n    function Iterate (Container : Tree)\n      return Tree_Iterator_Interfaces.Forward_Iterator'Class\n    is\n-      B  : Natural renames Container'Unrestricted_Access.all.Busy;\n-      RC : constant Cursor :=\n-             (Container'Unrestricted_Access, Root_Node (Container));\n-   begin\n-      return It : constant Iterator :=\n-                    Iterator'(Limited_Controlled with\n-                                Container => Container'Unrestricted_Access,\n-                                Position  => First_Child (RC),\n-                                From_Root => True)\n-      do\n-         B := B + 1;\n-      end return;\n+   begin\n+      return Iterate_Subtree (Root (Container));\n    end Iterate;\n \n    ----------------------\n@@ -1438,7 +1435,7 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       return It : constant Child_Iterator :=\n                     Child_Iterator'(Limited_Controlled with\n                                       Container => C,\n-                                      Parent    => Parent.Node)\n+                                      Subtree   => Parent.Node)\n       do\n          B := B + 1;\n       end return;\n@@ -1452,17 +1449,25 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n      (Position : Cursor)\n       return Tree_Iterator_Interfaces.Forward_Iterator'Class\n    is\n-      B : Natural renames Position.Container'Unrestricted_Access.all.Busy;\n-\n    begin\n-      return It : constant Iterator :=\n-                    Iterator'(Limited_Controlled with\n-                                Container => Position.Container,\n-                                Position  => Position,\n-                                From_Root => False)\n-      do\n-         B := B + 1;\n-      end return;\n+      if Position = No_Element then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      --  Implement Vet for multiway trees???\n+      --  pragma Assert (Vet (Position), \"bad subtree cursor\");\n+\n+      declare\n+         B : Natural renames Position.Container.Busy;\n+      begin\n+         return It : constant Subtree_Iterator :=\n+                       (Limited_Controlled with\n+                          Container => Position.Container,\n+                          Subtree   => Position.Node)\n+         do\n+            B := B + 1;\n+         end return;\n+      end;\n    end Iterate_Subtree;\n \n    procedure Iterate_Subtree\n@@ -1515,7 +1520,7 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n \n    overriding function Last (Object : Child_Iterator) return Cursor is\n    begin\n-      return Last_Child (Cursor'(Object.Container, Object.Parent));\n+      return Last_Child (Cursor'(Object.Container, Object.Subtree));\n    end Last;\n \n    ----------------\n@@ -1585,63 +1590,36 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n    ----------\n \n    function Next\n-     (Object : Iterator;\n+     (Object   : Subtree_Iterator;\n       Position : Cursor) return Cursor\n    is\n-      T  : Tree renames Position.Container.all;\n-      N  : constant Tree_Node_Access := Position.Node;\n+      Node : Tree_Node_Access;\n \n    begin\n-      if Is_Leaf (Position) then\n-\n-         --  If sibling is present, return it\n-\n-         if N.Next /= null then\n-            return (Object.Container, N.Next);\n-\n-         --  If this is the last sibling, go to sibling of first ancestor that\n-         --  has a sibling, or terminate.\n-\n-         else\n-            declare\n-               Par : Tree_Node_Access := N.Parent;\n-\n-            begin\n-               while Par.Next = null loop\n-\n-                  --  If we are back at the root the iteration is complete\n-\n-                  if Par = Root_Node (T)  then\n-                     return No_Element;\n-\n-                  --  If this is a subtree iterator and we are back at the\n-                  --  starting node, iteration is complete.\n+      if Position.Container = null then\n+         return No_Element;\n+      end if;\n \n-                  elsif Par = Object.Position.Node\n-                    and then not Object.From_Root\n-                  then\n-                     return No_Element;\n+      if Position.Container /= Object.Container then\n+         raise Program_Error with\n+           \"Position cursor of Next designates wrong tree\";\n+      end if;\n \n-                  else\n-                     Par := Par.Parent;\n-                  end if;\n-               end loop;\n+      Node := Position.Node;\n \n-               if Par = Object.Position.Node\n-                 and then not Object.From_Root\n-               then\n-                  return No_Element;\n-               end if;\n+      if Node.Children.First /= null then\n+         return Cursor'(Object.Container, Node.Children.First);\n+      end if;\n \n-               return (Object.Container, Par.Next);\n-            end;\n+      while Node /= Object.Subtree loop\n+         if Node.Next /= null then\n+            return Cursor'(Object.Container, Node.Next);\n          end if;\n \n-      --  If an internal node, return its first child\n+         Node := Node.Parent;\n+      end loop;\n \n-      else\n-         return (Object.Container, N.Children.First);\n-      end if;\n+      return No_Element;\n    end Next;\n \n    function Next"}, {"sha": "12d675ad57472867d0e5f3e34fb6efc416607670", "filename": "gcc/ada/a-comutr.adb", "status": "modified", "additions": 76, "deletions": 97, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0add5a9536ca3595ad7c6d7999fba0ccf5dc9740/gcc%2Fada%2Fa-comutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0add5a9536ca3595ad7c6d7999fba0ccf5dc9740/gcc%2Fada%2Fa-comutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-comutr.adb?ref=0add5a9536ca3595ad7c6d7999fba0ccf5dc9740", "patch": "@@ -34,41 +34,50 @@ with System; use type System.Address;\n \n package body Ada.Containers.Multiway_Trees is\n \n-   type Iterator is new Limited_Controlled and\n+   --------------------\n+   --  Root_Iterator --\n+   --------------------\n+\n+   type Root_Iterator is abstract new Limited_Controlled and\n      Tree_Iterator_Interfaces.Forward_Iterator with\n    record\n       Container : Tree_Access;\n-      Position  : Cursor;\n-      From_Root : Boolean;\n+      Subtree   : Tree_Node_Access;\n    end record;\n \n-   type Child_Iterator is new Limited_Controlled and\n-     Tree_Iterator_Interfaces.Reversible_Iterator with\n-   record\n-      Container : Tree_Access;\n-      Parent    : Tree_Node_Access;\n-   end record;\n+   overriding procedure Finalize (Object : in out Root_Iterator);\n \n-   overriding procedure Finalize (Object : in out Iterator);\n+   -----------------------\n+   --  Subtree_Iterator --\n+   -----------------------\n+\n+   type Subtree_Iterator is new Root_Iterator with null record;\n+\n+   overriding function First (Object : Subtree_Iterator) return Cursor;\n \n-   overriding function First (Object : Iterator) return Cursor;\n    overriding function Next\n-     (Object   : Iterator;\n+     (Object   : Subtree_Iterator;\n       Position : Cursor) return Cursor;\n \n-   overriding procedure Finalize (Object : in out Child_Iterator);\n+   ---------------------\n+   --  Child_Iterator --\n+   ---------------------\n+\n+   type Child_Iterator is new Root_Iterator and\n+     Tree_Iterator_Interfaces.Reversible_Iterator with null record;\n \n    overriding function First (Object : Child_Iterator) return Cursor;\n+\n    overriding function Next\n      (Object   : Child_Iterator;\n       Position : Cursor) return Cursor;\n \n+   overriding function Last (Object : Child_Iterator) return Cursor;\n+\n    overriding function Previous\n      (Object   : Child_Iterator;\n       Position : Cursor) return Cursor;\n \n-   overriding function Last (Object : Child_Iterator) return Cursor;\n-\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -909,13 +918,7 @@ package body Ada.Containers.Multiway_Trees is\n    -- Finalize --\n    --------------\n \n-   procedure Finalize (Object : in out Iterator) is\n-      B : Natural renames Object.Container.Busy;\n-   begin\n-      B := B - 1;\n-   end Finalize;\n-\n-   procedure Finalize (Object : in out Child_Iterator) is\n+   procedure Finalize (Object : in out Root_Iterator) is\n       B : Natural renames Object.Container.Busy;\n    begin\n       B := B - 1;\n@@ -943,14 +946,18 @@ package body Ada.Containers.Multiway_Trees is\n    -- First --\n    -----------\n \n-   function First (Object : Iterator) return Cursor is\n+   overriding function First (Object : Subtree_Iterator) return Cursor is\n    begin\n-      return Object.Position;\n+      if Object.Subtree = Root_Node (Object.Container.all) then\n+         return First_Child (Root (Object.Container.all));\n+      else\n+         return Cursor'(Object.Container, Object.Subtree);\n+      end if;\n    end First;\n \n-   function First (Object : Child_Iterator) return Cursor is\n+   overriding function First (Object : Child_Iterator) return Cursor is\n    begin\n-      return First_Child (Cursor'(Object.Container, Object.Parent));\n+      return First_Child (Cursor'(Object.Container, Object.Subtree));\n    end First;\n \n    -----------------\n@@ -1376,18 +1383,8 @@ package body Ada.Containers.Multiway_Trees is\n    function Iterate (Container : Tree)\n      return Tree_Iterator_Interfaces.Forward_Iterator'Class\n    is\n-      B  : Natural renames Container'Unrestricted_Access.all.Busy;\n-      RC : constant Cursor :=\n-            (Container'Unrestricted_Access, Root_Node (Container));\n-   begin\n-      return It : constant Iterator :=\n-                    Iterator'(Limited_Controlled with\n-                                Container => Container'Unrestricted_Access,\n-                                Position  => First_Child (RC),\n-                                From_Root => True)\n-      do\n-         B := B + 1;\n-      end return;\n+   begin\n+      return Iterate_Subtree (Root (Container));\n    end Iterate;\n \n    ----------------------\n@@ -1464,9 +1461,9 @@ package body Ada.Containers.Multiway_Trees is\n       end if;\n \n       return It : constant Child_Iterator :=\n-                    Child_Iterator'(Limited_Controlled with\n-                                      Container => C,\n-                                      Parent    => Parent.Node)\n+                    (Limited_Controlled with\n+                       Container => C,\n+                       Subtree   => Parent.Node)\n       do\n          B := B + 1;\n       end return;\n@@ -1480,16 +1477,25 @@ package body Ada.Containers.Multiway_Trees is\n      (Position : Cursor)\n       return Tree_Iterator_Interfaces.Forward_Iterator'Class\n    is\n-      B : Natural renames Position.Container'Unrestricted_Access.all.Busy;\n    begin\n-      return It : constant Iterator :=\n-                    Iterator'(Limited_Controlled with\n-                                Container => Position.Container,\n-                                Position  => Position,\n-                                From_Root => False)\n-      do\n-         B := B + 1;\n-      end return;\n+      if Position = No_Element then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      --  Implement Vet for multiway trees???\n+      --  pragma Assert (Vet (Position), \"bad subtree cursor\");\n+\n+      declare\n+         B : Natural renames Position.Container.Busy;\n+      begin\n+         return It : constant Subtree_Iterator :=\n+                       (Limited_Controlled with\n+                          Container => Position.Container,\n+                          Subtree   => Position.Node)\n+         do\n+            B := B + 1;\n+         end return;\n+      end;\n    end Iterate_Subtree;\n \n    procedure Iterate_Subtree\n@@ -1542,7 +1548,7 @@ package body Ada.Containers.Multiway_Trees is\n \n    overriding function Last (Object : Child_Iterator) return Cursor is\n    begin\n-      return Last_Child (Cursor'(Object.Container, Object.Parent));\n+      return Last_Child (Cursor'(Object.Container, Object.Subtree));\n    end Last;\n \n    ----------------\n@@ -1612,63 +1618,36 @@ package body Ada.Containers.Multiway_Trees is\n    ----------\n \n    function Next\n-     (Object   : Iterator;\n+     (Object   : Subtree_Iterator;\n       Position : Cursor) return Cursor\n    is\n-      T  : Tree renames Position.Container.all;\n-      N  : constant Tree_Node_Access := Position.Node;\n+      Node : Tree_Node_Access;\n \n    begin\n-      if Is_Leaf (Position) then\n-\n-         --  If sibling is present, return it\n-\n-         if N.Next /= null then\n-            return (Object.Container, N.Next);\n-\n-         --  If this is the last sibling, go to sibling of first ancestor that\n-         --  has a sibling, or terminate.\n-\n-         else\n-            declare\n-               Par : Tree_Node_Access := N.Parent;\n-\n-            begin\n-               while Par.Next = null loop\n-\n-                  --  If we are back at the root the iteration is complete\n-\n-                  if Par = Root_Node (T)  then\n-                     return No_Element;\n-\n-                  --  If this is a subtree iterator and we are back at the\n-                  --  starting node, iteration is complete.\n+      if Position.Container = null then\n+         return No_Element;\n+      end if;\n \n-                  elsif Par = Object.Position.Node\n-                    and then not Object.From_Root\n-                  then\n-                     return No_Element;\n+      if Position.Container /= Object.Container then\n+         raise Program_Error with\n+           \"Position cursor of Next designates wrong tree\";\n+      end if;\n \n-                  else\n-                     Par := Par.Parent;\n-                  end if;\n-               end loop;\n+      Node := Position.Node;\n \n-               if Par = Object.Position.Node\n-                 and then not Object.From_Root\n-               then\n-                  return No_Element;\n-               end if;\n+      if Node.Children.First /= null then\n+         return Cursor'(Object.Container, Node.Children.First);\n+      end if;\n \n-               return (Object.Container, Par.Next);\n-            end;\n+      while Node /= Object.Subtree loop\n+         if Node.Next /= null then\n+            return Cursor'(Object.Container, Node.Next);\n          end if;\n \n-      else\n-         --  If an internal node, return its first child\n+         Node := Node.Parent;\n+      end loop;\n \n-         return (Object.Container, N.Children.First);\n-      end if;\n+      return No_Element;\n    end Next;\n \n    function Next"}, {"sha": "5d605d75c500c5c5501464cc68062b6dd412c6cf", "filename": "gcc/ada/exp_dbug.adb", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0add5a9536ca3595ad7c6d7999fba0ccf5dc9740/gcc%2Fada%2Fexp_dbug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0add5a9536ca3595ad7c6d7999fba0ccf5dc9740/gcc%2Fada%2Fexp_dbug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dbug.adb?ref=0add5a9536ca3595ad7c6d7999fba0ccf5dc9740", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1996-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1996-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -105,11 +105,11 @@ package body Exp_Dbug is\n    -- Homonym_Suffix --\n    --------------------\n \n-   --  The string defined here (and its associated length) is used to\n-   --  gather the homonym string that will be appended to Name_Buffer\n-   --  when the name is complete. Strip_Suffixes appends to this string\n-   --  as does Append_Homonym_Number, and Output_Homonym_Numbers_Suffix\n-   --  appends the string to the end of Name_Buffer.\n+   --  The string defined here (and its associated length) is used to gather\n+   --  the homonym string that will be appended to Name_Buffer when the name\n+   --  is complete. Strip_Suffixes appends to this string as does\n+   --  Append_Homonym_Number, and Output_Homonym_Numbers_Suffix appends the\n+   --  string to the end of Name_Buffer.\n \n    Homonym_Numbers : String (1 .. 256);\n    Homonym_Len     : Natural := 0;\n@@ -147,6 +147,10 @@ package body Exp_Dbug is\n    --  If not already done, replaces the Chars field of the given entity\n    --  with the appropriate fully qualified name.\n \n+   procedure Reset_Buffers;\n+   --  Reset the contents of Name_Buffer and Homonym_Numbers by setting their\n+   --  respective lengths to zero.\n+\n    procedure Strip_Suffixes (BNPE_Suffix_Found : in out Boolean);\n    --  Given an qualified entity name in Name_Buffer, remove any plain X or\n    --  X{nb} qualification suffix. The contents of Name_Buffer is not changed\n@@ -701,8 +705,7 @@ package body Exp_Dbug is\n    --  Start of processing for Get_External_Name\n \n    begin\n-      Name_Len    := 0;\n-      Homonym_Len := 0;\n+      Reset_Buffers;\n \n       --  If this is a child unit, we want the child\n \n@@ -1022,6 +1025,7 @@ package body Exp_Dbug is\n    begin\n       for J in Name_Qualify_Units.First .. Name_Qualify_Units.Last loop\n          E := Defining_Entity (Name_Qualify_Units.Table (J));\n+         Reset_Buffers;\n          Qualify_Entity_Name (E);\n \n          --  Normally entities in the qualification list are scopes, but in the\n@@ -1033,6 +1037,7 @@ package body Exp_Dbug is\n          if Ekind (E) /= E_Variable then\n             Ent := First_Entity (E);\n             while Present (Ent) loop\n+               Reset_Buffers;\n                Qualify_Entity_Name (Ent);\n                Next_Entity (Ent);\n \n@@ -1101,10 +1106,10 @@ package body Exp_Dbug is\n          if No (E) then\n             return;\n \n-         --  If this we are qualifying entities local to a generic\n-         --  instance, use the name of the original instantiation,\n-         --  not that of the anonymous subprogram in the wrapper\n-         --  package, so that gdb doesn't have to know about these.\n+         --  If this we are qualifying entities local to a generic instance,\n+         --  use the name of the original instantiation, not that of the\n+         --  anonymous subprogram in the wrapper package, so that gdb doesn't\n+         --  have to know about these.\n \n          elsif Is_Generic_Instance (E)\n            and then Is_Subprogram (E)\n@@ -1394,6 +1399,16 @@ package body Exp_Dbug is\n       Name_Qualify_Units.Append (N);\n    end Qualify_Entity_Names;\n \n+   -------------------\n+   -- Reset_Buffers --\n+   -------------------\n+\n+   procedure Reset_Buffers is\n+   begin\n+      Name_Len    := 0;\n+      Homonym_Len := 0;\n+   end Reset_Buffers;\n+\n    --------------------\n    -- Strip_Suffixes --\n    --------------------"}, {"sha": "781e0ae6cc699a66058fa051cf0d5ad44377483a", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0add5a9536ca3595ad7c6d7999fba0ccf5dc9740/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0add5a9536ca3595ad7c6d7999fba0ccf5dc9740/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=0add5a9536ca3595ad7c6d7999fba0ccf5dc9740", "patch": "@@ -4953,12 +4953,14 @@ with this pragma and others compiled in normal mode without it.\n Syntax:\n \n @smallexample @c ada\n-pragma Suppress_Initialization ([Entity =>] type_Name);\n+pragma Suppress_Initialization ([Entity =>] subtype_Name);\n @end smallexample\n \n @noindent\n+Here subtype_Name is the name introduced by a type declaration\n+or subtype declaration.\n This pragma suppresses any implicit or explicit initialization\n-associated with the given type name for all variables of this type,\n+for all variables of the given type or subtype,\n including initialization resulting from the use of pragmas\n Normalize_Scalars or Initialize_Scalars.\n "}, {"sha": "6af0ed539899001b4b371271452432f73fd7da2c", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0add5a9536ca3595ad7c6d7999fba0ccf5dc9740/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0add5a9536ca3595ad7c6d7999fba0ccf5dc9740/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=0add5a9536ca3595ad7c6d7999fba0ccf5dc9740", "patch": "@@ -9585,6 +9585,7 @@ package body Sem_Ch3 is\n \n          elsif Ekind (E) = E_Incomplete_Type\n            and then No (Underlying_Type (E))\n+           and then not Is_Generic_Type (E)\n          then\n             Post_Error;\n "}, {"sha": "b38536fb5354b0ae0d0fd467917352286e7521ba", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0add5a9536ca3595ad7c6d7999fba0ccf5dc9740/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0add5a9536ca3595ad7c6d7999fba0ccf5dc9740/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=0add5a9536ca3595ad7c6d7999fba0ccf5dc9740", "patch": "@@ -12210,10 +12210,18 @@ package body Sem_Util is\n                end loop;\n             end;\n \n+            --  For a packed array type, we also need debug information for\n+            --  the type used to represent the packed array. Conversely, we\n+            --  also need it for the former if we need it for the latter.\n+\n             if Is_Packed (T) then\n                Set_Debug_Info_Needed_If_Not_Set (Packed_Array_Type (T));\n             end if;\n \n+            if Is_Packed_Array_Type (T) then\n+               Set_Debug_Info_Needed_If_Not_Set (Original_Array_Type (T));\n+            end if;\n+\n          elsif Is_Access_Type (T) then\n             Set_Debug_Info_Needed_If_Not_Set (Directly_Designated_Type (T));\n "}, {"sha": "aa4b8156906f84cfc231f697863cc572dac11cc3", "filename": "gcc/ada/usage.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0add5a9536ca3595ad7c6d7999fba0ccf5dc9740/gcc%2Fada%2Fusage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0add5a9536ca3595ad7c6d7999fba0ccf5dc9740/gcc%2Fada%2Fusage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fusage.adb?ref=0add5a9536ca3595ad7c6d7999fba0ccf5dc9740", "patch": "@@ -462,6 +462,10 @@ begin\n    Write_Line (\"        .m*  turn on warnings for suspicious modulus value\");\n    Write_Line (\"        .M   turn off warnings for suspicious modulus value\");\n    Write_Line (\"        n*   normal warning mode (cancels -gnatws/-gnatwe)\");\n+   Write_Line (\"        .n   turn on info messages for atomic \" &\n+                                                  \"synchronization\");\n+   Write_Line (\"        .N*  turn off info messages for atomic \" &\n+                                                  \"synchronization\");\n    Write_Line (\"        o*   turn on warnings for address clause overlay\");\n    Write_Line (\"        O    turn off warnings for address clause overlay\");\n    Write_Line (\"        .o   turn on warnings for out parameters assigned \" &"}]}