{"sha": "ca9a1314ec5f2b58921e24abdcebae1482c0e2c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E5YTEzMTRlYzVmMmI1ODkyMWUyNGFiZGNlYmFlMTQ4MmMwZTJjNg==", "commit": {"author": {"name": "Tony Reix", "email": "tony.reix@atos.net", "date": "2018-08-01T21:55:05Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-08-01T21:55:05Z"}, "message": "xcoff.c (struct xcoff_line, [...]): Remove.\n\n\t* xcoff.c (struct xcoff_line, struct xcoff_line_vector): Remove.\n\t(struct xcoff_func, struct xcoff_func_vector): New structs.\n\t(xcoff_syminfo): Drop leading dot from symbol name.\n\t(xcoff_line_compare, xcoff_line_search): Remove.\n\t(xcoff_func_compare, xcoff_func_search): New static functions.\n\t(xcoff_lookup_pc): Search function table.\n\t(xcoff_add_line, xcoff_process_linenos): Remove.\n\t(xcoff_initialize_fileline): Build function table.\n\nFrom-SVN: r263238", "tree": {"sha": "68f3823b178796072f1e89fc1ab599f618296c5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68f3823b178796072f1e89fc1ab599f618296c5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca9a1314ec5f2b58921e24abdcebae1482c0e2c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca9a1314ec5f2b58921e24abdcebae1482c0e2c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca9a1314ec5f2b58921e24abdcebae1482c0e2c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca9a1314ec5f2b58921e24abdcebae1482c0e2c6/comments", "author": {"login": "trex58", "id": 5690106, "node_id": "MDQ6VXNlcjU2OTAxMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/5690106?v=4", "gravatar_id": "", "url": "https://api.github.com/users/trex58", "html_url": "https://github.com/trex58", "followers_url": "https://api.github.com/users/trex58/followers", "following_url": "https://api.github.com/users/trex58/following{/other_user}", "gists_url": "https://api.github.com/users/trex58/gists{/gist_id}", "starred_url": "https://api.github.com/users/trex58/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/trex58/subscriptions", "organizations_url": "https://api.github.com/users/trex58/orgs", "repos_url": "https://api.github.com/users/trex58/repos", "events_url": "https://api.github.com/users/trex58/events{/privacy}", "received_events_url": "https://api.github.com/users/trex58/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "701d080a4b7d04d2f4f084b85fb2160fd6b96da9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/701d080a4b7d04d2f4f084b85fb2160fd6b96da9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/701d080a4b7d04d2f4f084b85fb2160fd6b96da9"}], "stats": {"total": 444, "additions": 212, "deletions": 232}, "files": [{"sha": "0a117a08042def66ceb297677a37092c638a5fa2", "filename": "libbacktrace/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9a1314ec5f2b58921e24abdcebae1482c0e2c6/libbacktrace%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9a1314ec5f2b58921e24abdcebae1482c0e2c6/libbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FChangeLog?ref=ca9a1314ec5f2b58921e24abdcebae1482c0e2c6", "patch": "@@ -1,3 +1,14 @@\n+2018-08-01  Tony Reix  <tony.reix@atos.net>\n+\n+\t* xcoff.c (struct xcoff_line, struct xcoff_line_vector): Remove.\n+\t(struct xcoff_func, struct xcoff_func_vector): New structs.\n+\t(xcoff_syminfo): Drop leading dot from symbol name.\n+\t(xcoff_line_compare, xcoff_line_search): Remove.\n+\t(xcoff_func_compare, xcoff_func_search): New static functions.\n+\t(xcoff_lookup_pc): Search function table.\n+\t(xcoff_add_line, xcoff_process_linenos): Remove.\n+\t(xcoff_initialize_fileline): Build function table.\n+\n 2018-06-21 Denis Khalikov <d.khalikov@partner.samsung.com>\n \n \tPR other/86198"}, {"sha": "84d0340d744c1c34401e83357adb198739f78ec0", "filename": "libbacktrace/xcoff.c", "status": "modified", "additions": 201, "deletions": 232, "changes": 433, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9a1314ec5f2b58921e24abdcebae1482c0e2c6/libbacktrace%2Fxcoff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9a1314ec5f2b58921e24abdcebae1482c0e2c6/libbacktrace%2Fxcoff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fxcoff.c?ref=ca9a1314ec5f2b58921e24abdcebae1482c0e2c6", "patch": "@@ -338,27 +338,32 @@ struct xcoff_incl_vector\n   size_t count;\n };\n \n-/* Map a single PC value to a file/function/line.  */\n+/* A growable vector of functions information.  */\n \n-struct xcoff_line\n+struct xcoff_func\n {\n   /* PC.  */\n   uintptr_t pc;\n-  /* File name.  Many entries in the array are expected to point to\n-     the same file name.  */\n-  const char *filename;\n+  /* The size of the function.  */\n+  size_t size;\n   /* Function name.  */\n-  const char *function;\n-  /* Line number.  */\n-  int lineno;\n+  const char *name;\n+  /* File name.  */\n+  const char *filename;\n+  /* Pointer to first lnno entry.  */\n+  uintptr_t lnnoptr;\n+  /* Base address of containing section.  */\n+  uintptr_t sect_base;\n+  /* Starting source line number.  */\n+  int lnno;\n };\n \n-/* A growable vector of line number information.  This is used while\n-   reading the line numbers.  */\n+/* A growable vector of function information.  This is used while\n+   reading the function symbols.  */\n \n-struct xcoff_line_vector\n+struct xcoff_func_vector\n {\n-  /* Memory.  This is an array of struct xcoff_line.  */\n+  /* Memory.  This is an array of struct xcoff_func.  */\n   struct backtrace_vector vec;\n   /* Number of valid mappings.  */\n   size_t count;\n@@ -370,8 +375,16 @@ struct xcoff_fileline_data\n {\n   /* The data for the next file we know about.  */\n   struct xcoff_fileline_data *next;\n-  /* Line number information.  */\n-  struct xcoff_line_vector vec;\n+  /* Functions information.  */\n+  struct xcoff_func_vector func_vec;\n+  /* Include files information.  */\n+  struct xcoff_incl_vector incl_vec;\n+  /* Line numbers information.  */\n+  const unsigned char *linenos;\n+  size_t linenos_size;\n+  uint64_t lnnoptr0;\n+  /* Loader address.  */\n+  uintptr_t base_address;\n };\n \n /* An index of DWARF sections we care about.  */\n@@ -509,6 +522,7 @@ xcoff_syminfo (struct backtrace_state *state ATTRIBUTE_UNUSED, uintptr_t addr,\n {\n   struct xcoff_syminfo_data *edata;\n   struct xcoff_symbol *sym = NULL;\n+  const char *name;\n \n   if (!state->threaded)\n     {\n@@ -547,7 +561,13 @@ xcoff_syminfo (struct backtrace_state *state ATTRIBUTE_UNUSED, uintptr_t addr,\n   if (sym == NULL)\n     callback (data, addr, NULL, 0, 0);\n   else\n-    callback (data, addr, sym->name, sym->address, sym->size);\n+    {\n+      name = sym->name;\n+      /* AIX prepends a '.' to function entry points, remove it.  */\n+      if (name && *name == '.')\n+\t++name;\n+      callback (data, addr, name, sym->address, sym->size);\n+    }\n }\n \n /* Return the name of an XCOFF symbol.  */\n@@ -640,43 +660,76 @@ xcoff_initialize_syminfo (struct backtrace_state *state,\n   return 1;\n }\n \n-/* Compare struct xcoff_line for qsort.  */\n+/* Compare struct xcoff_func for qsort.  */\n \n static int\n-xcoff_line_compare (const void *v1, const void *v2)\n+xcoff_func_compare (const void *v1, const void *v2)\n {\n-  const struct xcoff_line *ln1 = (const struct xcoff_line *) v1;\n-  const struct xcoff_line *ln2 = (const struct xcoff_line *) v2;\n+  const struct xcoff_func *fn1 = (const struct xcoff_func *) v1;\n+  const struct xcoff_func *fn2 = (const struct xcoff_func *) v2;\n \n-  if (ln1->pc < ln2->pc)\n+  if (fn1->pc < fn2->pc)\n     return -1;\n-  else if (ln1->pc > ln2->pc)\n+  else if (fn1->pc > fn2->pc)\n     return 1;\n   else\n     return 0;\n }\n \n-/* Find a PC in a line vector.  We always allocate an extra entry at\n-   the end of the lines vector, so that this routine can safely look\n-   at the next entry.  */\n+/* Compare a PC against an xcoff_func for bsearch.  */\n \n static int\n-xcoff_line_search (const void *vkey, const void *ventry)\n+xcoff_func_search (const void *vkey, const void *ventry)\n {\n   const uintptr_t *key = (const uintptr_t *) vkey;\n-  const struct xcoff_line *entry = (const struct xcoff_line *) ventry;\n+  const struct xcoff_func *entry = (const struct xcoff_func *) ventry;\n   uintptr_t pc;\n \n   pc = *key;\n   if (pc < entry->pc)\n     return -1;\n-  else if ((entry + 1)->pc == (uintptr_t) -1 || pc >= (entry + 1)->pc)\n+  else if ((entry->size == 0 && pc > entry->pc)\n+\t   || (entry->size > 0 && pc >= entry->pc + entry->size))\n     return 1;\n   else\n     return 0;\n }\n \n-/* Look for a PC in the line vector for one module.  On success,\n+/* Compare struct xcoff_incl for qsort.  */\n+\n+static int\n+xcoff_incl_compare (const void *v1, const void *v2)\n+{\n+  const struct xcoff_incl *in1 = (const struct xcoff_incl *) v1;\n+  const struct xcoff_incl *in2 = (const struct xcoff_incl *) v2;\n+\n+  if (in1->begin < in2->begin)\n+    return -1;\n+  else if (in1->begin > in2->begin)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Find a lnnoptr in an include file.  */\n+\n+static int\n+xcoff_incl_search (const void *vkey, const void *ventry)\n+{\n+  const uintptr_t *key = (const uintptr_t *) vkey;\n+  const struct xcoff_incl *entry = (const struct xcoff_incl *) ventry;\n+  uintptr_t lnno;\n+\n+  lnno = *key;\n+  if (lnno < entry->begin)\n+    return -1;\n+  else if (lnno > entry->end)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Look for a PC in the function vector for one module.  On success,\n    call CALLBACK and return whatever it returns.  On error, call\n    ERROR_CALLBACK and return 0.  Sets *FOUND to 1 if the PC is found,\n    0 if not.  */\n@@ -688,26 +741,82 @@ xcoff_lookup_pc (struct backtrace_state *state ATTRIBUTE_UNUSED,\n \t\t backtrace_error_callback error_callback ATTRIBUTE_UNUSED,\n \t\t void *data, int *found)\n {\n-  const struct xcoff_line *ln;\n+  const struct xcoff_incl *incl, *bincl;\n+  const struct xcoff_func *fn;\n+  const b_xcoff_lineno *lineno;\n+  const unsigned char *lineptr;\n   const char *function;\n+  const char *filename;\n+  uintptr_t lnnoptr, match;\n+  uint32_t lnno = 0;\n \n   *found = 1;\n \n-  ln = (struct xcoff_line *) bsearch (&pc, fdata->vec.vec.base,\n-\t\t\t\t      fdata->vec.count,\n-\t\t\t\t      sizeof (struct xcoff_line),\n-\t\t\t\t      xcoff_line_search);\n-  if (ln == NULL)\n+  if ((pc & 3) != 0)\n+    ++pc;\n+\n+  /* Find the function first.  */\n+  fn = ((struct xcoff_func *)\n+\tbsearch (&pc, fdata->func_vec.vec.base, fdata->func_vec.count,\n+\t\t sizeof (struct xcoff_func), xcoff_func_search));\n+  if (fn == NULL)\n     {\n       *found = 0;\n       return 0;\n     }\n \n-  function = ln->function;\n+  filename = fn->filename;\n+\n+  /* Find the line number next.  */\n+\n+  /* Skip first entry that points to symtab.  */\n+  lnnoptr = fn->lnnoptr + LINESZ;\n+  match = lnnoptr;\n+\n+  lineptr = fdata->linenos + (lnnoptr - fdata->lnnoptr0);\n+  while (lineptr + LINESZ <= fdata->linenos + fdata->linenos_size)\n+    {\n+      lineno = (const b_xcoff_lineno *) lineptr;\n+      if (lineno->l_lnno == 0)\n+\tbreak;\n+      if (pc <= fdata->base_address + lineno->l_addr.l_paddr - fn->sect_base)\n+\tbreak;\n+      match = lnnoptr;\n+      lnno = lineno->l_lnno;\n+\n+      lnnoptr += LINESZ;\n+      lineptr += LINESZ;\n+    }\n+\n+  /* If part of a function other than the beginning comes from an\n+     include file, the line numbers are absolute, rather than\n+     relative to the beginning of the function.  */\n+  incl = ((struct xcoff_incl *)\n+\t  bsearch (&match, fdata->incl_vec.vec.base,\n+\t\t   fdata->incl_vec.count, sizeof (struct xcoff_incl),\n+\t\t   xcoff_incl_search));\n+  if (incl != NULL)\n+    {\n+      bincl = ((struct xcoff_incl *)\n+\t       bsearch (&fn->lnnoptr, fdata->incl_vec.vec.base,\n+\t\t\tfdata->incl_vec.count, sizeof (struct xcoff_incl),\n+\t\t\txcoff_incl_search));\n+      if (bincl != NULL && strcmp (incl->filename, bincl->filename) == 0)\n+\t{\n+\t  lnno += fn->lnno - 1;\n+\t}\n+      filename = incl->filename;\n+    }\n+  else\n+    {\n+      lnno += fn->lnno - 1;\n+    }\n+\n+  function = fn->name;\n   /* AIX prepends a '.' to function entry points, remove it.  */\n-  if (*function == '.')\n+  if (function != NULL && *function == '.')\n     ++function;\n-  return callback (data, pc, ln->filename, ln->lineno, function);\n+  return callback (data, pc, filename, lnno, function);\n }\n \n /* Return the file/line information for a PC using the XCOFF lineno\n@@ -760,146 +869,7 @@ xcoff_fileline (struct backtrace_state *state, uintptr_t pc,\n   return callback (data, pc, NULL, 0, NULL);\n }\n \n-/* Compare struct xcoff_incl for qsort.  */\n-\n-static int\n-xcoff_incl_compare (const void *v1, const void *v2)\n-{\n-  const struct xcoff_incl *in1 = (const struct xcoff_incl *) v1;\n-  const struct xcoff_incl *in2 = (const struct xcoff_incl *) v2;\n-\n-  if (in1->begin < in2->begin)\n-    return -1;\n-  else if (in1->begin > in2->begin)\n-    return 1;\n-  else\n-    return 0;\n-}\n-\n-/* Find a lnnoptr in an include file.  */\n-\n-static int\n-xcoff_incl_search (const void *vkey, const void *ventry)\n-{\n-  const uintptr_t *key = (const uintptr_t *) vkey;\n-  const struct xcoff_incl *entry = (const struct xcoff_incl *) ventry;\n-  uintptr_t lnno;\n-\n-  lnno = *key;\n-  if (lnno < entry->begin)\n-    return -1;\n-  else if (lnno > entry->end)\n-    return 1;\n-  else\n-    return 0;\n-}\n-\n-/* Add a new mapping to the vector of line mappings that we are\n-   building.  Returns 1 on success, 0 on failure.  */\n-\n-static int\n-xcoff_add_line (struct backtrace_state *state, uintptr_t pc,\n-\t\tconst char *filename, const char *function, uint32_t lnno,\n-\t\tbacktrace_error_callback error_callback, void *data,\n-\t\tstruct xcoff_line_vector *vec)\n-{\n-  struct xcoff_line *ln;\n-\n-  ln = ((struct xcoff_line *)\n-\tbacktrace_vector_grow (state, sizeof (struct xcoff_line),\n-\t\t\t       error_callback, data, &vec->vec));\n-  if (ln == NULL)\n-    return 0;\n-\n-  ln->pc = pc;\n-  ln->filename = filename;\n-  ln->function = function;\n-  ln->lineno = lnno;\n-\n-  ++vec->count;\n-\n-  return 1;\n-}\n-\n-/* Add the line number entries for a function to the line vector.  */\n-\n-static int\n-xcoff_process_linenos (struct backtrace_state *state, uintptr_t base_address,\n-\t\t       const b_xcoff_syment *fsym, const char *filename,\n-\t\t       const b_xcoff_scnhdr *sects,\n-\t\t       const unsigned char *strtab, size_t strtab_size,\n-\t\t       uint32_t fcn_lnno, struct xcoff_incl_vector *vec,\n-\t\t       struct xcoff_line_vector *lvec,\n-\t\t       const unsigned char *linenos, size_t linenos_size,\n-\t\t       uintptr_t lnnoptr0,\n-\t\t       backtrace_error_callback error_callback, void *data)\n-{\n-  const b_xcoff_auxent *aux;\n-  const b_xcoff_lineno *lineno;\n-  const unsigned char *lineptr;\n-  const char *function;\n-  struct xcoff_incl *incl = NULL;\n-  uintptr_t lnnoptr;\n-  uintptr_t pc;\n-  uint32_t lnno;\n-  int begincl;\n-\n-  aux = (const b_xcoff_auxent *) (fsym + 1);\n-  lnnoptr = aux->x_fcn.x_lnnoptr;\n-\n-  if (lnnoptr < lnnoptr0 || lnnoptr + LINESZ > lnnoptr0 + linenos_size)\n-    return 0;\n-\n-  function = xcoff_symname (fsym, strtab, strtab_size);\n-  if (function == NULL)\n-    return 0;\n-\n-  /* Skip first entry that points to symtab.  */\n-\n-  lnnoptr += LINESZ;\n-\n-  lineptr = linenos + (lnnoptr - lnnoptr0);\n-\n-  begincl = -1;\n-  while (lineptr + LINESZ <= linenos + linenos_size)\n-    {\n-      lineno = (const b_xcoff_lineno *) lineptr;\n-\n-      lnno = lineno->l_lnno;\n-      if (lnno == 0)\n-\t  break;\n-\n-      /* If part of a function other than the beginning comes from an\n-\t include file, the line numbers are absolute, rather than\n-\t relative to the beginning of the function.  */\n-      incl = (struct xcoff_incl *) bsearch (&lnnoptr, vec->vec.base,\n-\t\t\t\t\t    vec->count,\n-\t\t\t\t\t    sizeof (struct xcoff_incl),\n-\t\t\t\t\t    xcoff_incl_search);\n-      if (begincl == -1)\n-\tbegincl = incl != NULL;\n-      if (incl != NULL)\n-\t{\n-\t  filename = incl->filename;\n-\t  if (begincl == 1)\n-\t    lnno += fcn_lnno - 1;\n-\t}\n-      else\n-\tlnno += fcn_lnno - 1;\n-\n-      pc = base_address + lineno->l_addr.l_paddr\n-\t - sects[fsym->n_scnum - 1].s_paddr;\n-      xcoff_add_line (state, pc, filename, function, lnno, error_callback,\n-\t\t      data, lvec);\n-\n-      lnnoptr += LINESZ;\n-      lineptr += LINESZ;\n-    }\n-\n-  return 1;\n-}\n-\n-/* Initialize the line vector info for xcoff_fileline.  */\n+/* Initialize the function vector info for xcoff_fileline.  */\n \n static int\n xcoff_initialize_fileline (struct backtrace_state *state,\n@@ -912,29 +882,33 @@ xcoff_initialize_fileline (struct backtrace_state *state,\n \t\t\t   backtrace_error_callback error_callback, void *data)\n {\n   struct xcoff_fileline_data *fdata;\n-  struct xcoff_incl_vector vec;\n-  struct xcoff_line *ln;\n+  struct xcoff_func *fn;\n   const b_xcoff_syment *fsym;\n   const b_xcoff_auxent *aux;\n   const char *filename;\n   const char *name;\n   struct xcoff_incl *incl;\n   uintptr_t begin, end;\n-  uintptr_t lnno;\n+  uintptr_t lnno, lnnoptr;\n+  uint32_t fsize;\n   size_t i;\n \n   fdata = ((struct xcoff_fileline_data *)\n \t   backtrace_alloc (state, sizeof (struct xcoff_fileline_data),\n \t\t\t    error_callback, data));\n   if (fdata == NULL)\n     return 0;\n-\n   memset (fdata, 0, sizeof *fdata);\n-  memset (&vec, 0, sizeof vec);\n-\n-  /* Process include files first.  */\n+  fdata->base_address = base_address;\n+  fdata->linenos = linenos;\n+  fdata->linenos_size = linenos_size;\n+  fdata->lnnoptr0 = lnnoptr0;\n \n   begin = 0;\n+  filename = NULL;\n+  fsym = NULL;\n+  lnnoptr = 0;\n+  fsize = 0;\n   for (i = 0; i < nsyms; ++i)\n     {\n       const b_xcoff_syment *asym = &syms[i];\n@@ -951,32 +925,18 @@ xcoff_initialize_fileline (struct backtrace_state *state,\n \t    end = asym->n_value;\n \t    incl = ((struct xcoff_incl *)\n \t\t    backtrace_vector_grow (state, sizeof (struct xcoff_incl),\n-\t\t\t\t\t   error_callback, data, &vec.vec));\n+\t\t\t\t\t   error_callback, data,\n+\t\t\t\t\t   &fdata->incl_vec.vec));\n \t    if (incl != NULL)\n \t      {\n \t\tincl->filename = xcoff_symname (asym, strtab, strtab_size);\n \t\tincl->begin = begin;\n \t\tincl->end = end;\n-\t\t++vec.count;\n+\t\t++fdata->incl_vec.count;\n \t      }\n \t    begin = 0;\n \t    break;\n-\t}\n-\n-      i += asym->n_numaux;\n-    }\n-\n-  backtrace_qsort (vec.vec.base, vec.count,\n-\t\t   sizeof (struct xcoff_incl), xcoff_incl_compare);\n-\n-  filename = NULL;\n-  fsym = NULL;\n-  for (i = 0; i < nsyms; ++i)\n-    {\n-      const b_xcoff_syment *asym = &syms[i];\n \n-      switch (asym->n_sclass)\n-\t{\n \t  case C_FILE:\n \t    filename = xcoff_symname (asym, strtab, strtab_size);\n \t    if (filename == NULL)\n@@ -988,7 +948,7 @@ xcoff_initialize_fileline (struct backtrace_state *state,\n \t       file auxiliary entry (by convention) contains the source\n \t       file name.  */\n \n-\t    if (asym->n_numaux > 0 && !strcmp (filename, \".file\"))\n+\t    if (asym->n_numaux > 0 && strcmp (filename, \".file\") == 0)\n \t      {\n \t\taux = (const b_xcoff_auxent *) (asym + 1);\n \t\tif (aux->x_file._x.x_zeroes != 0)\n@@ -1010,10 +970,20 @@ xcoff_initialize_fileline (struct backtrace_state *state,\n \t  case C_HIDEXT:\n \t  case C_WEAKEXT:\n \t    fsym = NULL;\n-\t    if (!ISFCN (asym->n_type) || asym->n_numaux == 0)\n+\t    lnnoptr = 0;\n+\t    fsize = 0;\n+\t    if (!ISFCN (asym->n_type) || asym->n_numaux == 0\n+\t\t|| asym->n_scnum <= 0)\n \t      break;\n \t    if (filename == NULL)\n \t      break;\n+\t    aux = (const b_xcoff_auxent *) (asym + 1);\n+\t    lnnoptr = aux->x_fcn.x_lnnoptr;\n+\t    if (lnnoptr < lnnoptr0\n+\t\t|| lnnoptr + LINESZ > lnnoptr0 + linenos_size)\n+\t      break;\n+\t    /* x_fsize will be 0 if there is no debug information.  */\n+\t    fsize = aux->x_fcn.x_fsize;\n \t    fsym = asym;\n \t    break;\n \n@@ -1023,48 +993,49 @@ xcoff_initialize_fileline (struct backtrace_state *state,\n \t    if (fsym == NULL)\n \t      break;\n \t    name = xcoff_symname (asym, strtab, strtab_size);\n-\t    if (name == NULL)\n-\t      break;\n+\t    if (name == NULL || strcmp (name, \".bf\") != 0)\n+\t      {\n+\t\tfsym = NULL;\n+\t\tbreak;\n+\t      }\n \t    aux = (const b_xcoff_auxent *) (asym + 1);\n #if BACKTRACE_XCOFF_SIZE == 32\n \t    lnno = (uint32_t) aux->x_block.x_lnnohi << 16\n \t\t | aux->x_block.x_lnno;\n #else\n \t    lnno = aux->x_block.x_lnno;\n #endif\n-\t    if (!strcmp (name, \".bf\"))\n-\t      {\n-\t\txcoff_process_linenos (state, base_address, fsym, filename,\n-\t\t\t\t       sects, strtab, strtab_size, lnno, &vec,\n-\t\t\t\t       &fdata->vec, linenos, linenos_size,\n-\t\t\t\t       lnnoptr0, error_callback, data);\n-\t      }\n-\t    else if (!strcmp (name, \".ef\"))\n-\t      {\n-\t\tfsym = NULL;\n-\t      }\n+\t    fn = ((struct xcoff_func *)\n+\t\t  backtrace_vector_grow (state, sizeof (struct xcoff_func),\n+\t\t\t\t\t error_callback, data,\n+\t\t\t\t\t &fdata->func_vec.vec));\n+\t    if (fn == NULL)\n+\t      break;\n+\t    fn->name = xcoff_symname (fsym, strtab, strtab_size);\n+\t    fn->filename = filename;\n+\t    fn->sect_base = sects[fsym->n_scnum - 1].s_paddr;\n+\t    fn->pc = base_address + fsym->n_value - fn->sect_base;\n+\t    fn->size = fsize;\n+\t    fn->lnno = lnno;\n+\t    fn->lnnoptr = lnnoptr;\n+\t    ++fdata->func_vec.count;\n \t    break;\n \t}\n \n       i += asym->n_numaux;\n     }\n \n-  /* Allocate one extra entry at the end.  */\n-  ln = ((struct xcoff_line *)\n-\tbacktrace_vector_grow (state, sizeof (struct xcoff_line),\n-\t\t\t       error_callback, data, &fdata->vec.vec));\n-  if (ln == NULL)\n+  if (!backtrace_vector_release (state, &fdata->func_vec.vec, error_callback,\n+\t\t\t\t data))\n     goto fail;\n-  ln->pc = (uintptr_t) -1;\n-  ln->filename = NULL;\n-  ln->function = NULL;\n-  ln->lineno = 0;\n+  backtrace_qsort (fdata->func_vec.vec.base, fdata->func_vec.count,\n+\t\t   sizeof (struct xcoff_func), xcoff_func_compare);\n \n-  if (!backtrace_vector_release (state, &fdata->vec.vec, error_callback, data))\n+  if (!backtrace_vector_release (state, &fdata->incl_vec.vec, error_callback,\n+\t\t\t\t data))\n     goto fail;\n-\n-  backtrace_qsort (fdata->vec.vec.base, fdata->vec.count,\n-\t\t   sizeof (struct xcoff_line), xcoff_line_compare);\n+  backtrace_qsort (fdata->incl_vec.vec.base, fdata->incl_vec.count,\n+\t\t   sizeof (struct xcoff_incl), xcoff_incl_compare);\n \n   if (!state->threaded)\n     {\n@@ -1354,6 +1325,7 @@ xcoff_add (struct backtrace_state *state, int descriptor, off_t offset,\n     {\n       size_t linenos_size = (size_t) nlnno * LINESZ;\n \n+      /* We never release this view.  */\n       if (!backtrace_get_view (state, descriptor, offset + lnnoptr,\n \t\t\t       linenos_size,\n \t\t\t       error_callback, data, &linenos_view))\n@@ -1366,9 +1338,6 @@ xcoff_add (struct backtrace_state *state, int descriptor, off_t offset,\n \t\t\t\t     linenos_view.data, linenos_size,\n \t\t\t\t     lnnoptr, error_callback, data))\n \t*fileline_fn = xcoff_fileline;\n-\n-      backtrace_release_view (state, &linenos_view, error_callback, data);\n-      linenos_view_valid = 0;\n     }\n \n   backtrace_release_view (state, &sects_view, error_callback, data);"}]}