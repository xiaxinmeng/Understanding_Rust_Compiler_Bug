{"sha": "ee7e677fdd929eb1b9fd60efa476c86fd0692784", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWU3ZTY3N2ZkZDkyOWViMWI5ZmQ2MGVmYTQ3NmM4NmZkMDY5Mjc4NA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2006-12-10T19:53:07Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2006-12-10T19:53:07Z"}, "message": "re PR fortran/23994 (PROTECTED attribute (F2003) is not implemented)\n\nfortran/\n2006-12-10  Tobias Burnus  <burnus@net-b.de>\n\n    PR fortran/23994\n    * interface.c (compare_actual_formal): PROTECTED is incompatible\nwith intent(out).\n    * symbol.c (check_conflict): Check for PROTECTED conflicts.\n      (gfc_add_protected): New function.\n      (gfc_copy_attr): Copy PROTECTED attribute.\n    * decl.c (match_attr_spec): Add PROTECTED support.\n      (gfc_match_protected): New function.\n    * dump-parse-tree.c (gfc_show_attr): Add PROTECTED support.\n    * gfortran.h (gfc_symbol): Add protected flag.\n      Add gfc_add_protected prototype.\n    * expr.c (gfc_check_pointer_assign): Add PROTECTED support.\n    * module.c (ab_attribute, attr_bits, mio_symbol_attribute,\nmio_symbol_attribute):\n       Add PROTECTED support.\n    * resolve.c (resolve_equivalence): Add PROTECTED support.\n    * match.c (gfc_match_assignment,)gfc_match_pointer_assignment:\n       Check PROTECTED attribute.\n    * match.h: Add gfc_match_protected prototype.\n    * parse.c (decode_statement): Match PROTECTED statement.\n    * primary.c (match_variable): Add PROTECTED support.\n\ntestsuite/\n2006-12-10  Tobias Burnus  <burnus@net-b.de>\n\n    PR fortran/23994\n    * gfortran.dg/protected_1.f90: New test.\n    * gfortran.dg/protected_2.f90: New test.\n    * gfortran.dg/protected_3.f90: New test.\n    * gfortran.dg/protected_4.f90: New test.\n    * gfortran.dg/protected_5.f90: New test.\n    * gfortran.dg/protected_6.f90: New test.\n\nFrom-SVN: r119709", "tree": {"sha": "fd873c228f212288e3d63dae896648e0ca50835b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd873c228f212288e3d63dae896648e0ca50835b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee7e677fdd929eb1b9fd60efa476c86fd0692784", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee7e677fdd929eb1b9fd60efa476c86fd0692784", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee7e677fdd929eb1b9fd60efa476c86fd0692784", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee7e677fdd929eb1b9fd60efa476c86fd0692784/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "42c1cd8a7ac43e4d324fbd4f6051ec56f83cd00b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42c1cd8a7ac43e4d324fbd4f6051ec56f83cd00b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42c1cd8a7ac43e4d324fbd4f6051ec56f83cd00b"}], "stats": {"total": 546, "additions": 541, "deletions": 5}, "files": [{"sha": "d211080eae58797231149471525cc083b297955d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ee7e677fdd929eb1b9fd60efa476c86fd0692784", "patch": "@@ -1,3 +1,26 @@\n+2006-12-10  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/23994\n+\t* interface.c (compare_actual_formal): PROTECTED is incompatible\n+\t  with intent(out).\n+\t* symbol.c (check_conflict): Check for PROTECTED conflicts.\n+\t  (gfc_add_protected): New function.\n+\t  (gfc_copy_attr): Copy PROTECTED attribute.\n+\t* decl.c (match_attr_spec): Add PROTECTED support.\n+\t  (gfc_match_protected): New function.\n+\t* dump-parse-tree.c (gfc_show_attr): Add PROTECTED support.\n+\t* gfortran.h (gfc_symbol): Add protected flag.\n+\t  Add gfc_add_protected prototype.\n+\t* expr.c (gfc_check_pointer_assign): Add PROTECTED support.\n+\t* module.c (ab_attribute, attr_bits, mio_symbol_attribute,\n+\t  mio_symbol_attribute): Add PROTECTED support.\n+\t* resolve.c (resolve_equivalence): Add PROTECTED support.\n+\t* match.c (gfc_match_assignment,gfc_match_pointer_assignment):\n+\t  Check PROTECTED attribute.\n+\t* match.h: Add gfc_match_protected prototype.\n+\t* parse.c (decode_statement): Match PROTECTED statement.\n+\t* primary.c (match_variable): Add PROTECTED support.\n+\n 2006-12-09  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/29975"}, {"sha": "eb3323733ee86d04dbb7abacb4db01ee6deee11d", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 85, "deletions": 2, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=ee7e677fdd929eb1b9fd60efa476c86fd0692784", "patch": "@@ -2116,8 +2116,9 @@ match_attr_spec (void)\n   { GFC_DECL_BEGIN = 0,\n     DECL_ALLOCATABLE = GFC_DECL_BEGIN, DECL_DIMENSION, DECL_EXTERNAL,\n     DECL_IN, DECL_OUT, DECL_INOUT, DECL_INTRINSIC, DECL_OPTIONAL,\n-    DECL_PARAMETER, DECL_POINTER, DECL_PRIVATE, DECL_PUBLIC, DECL_SAVE,\n-    DECL_TARGET, DECL_VALUE, DECL_VOLATILE, DECL_COLON, DECL_NONE,\n+    DECL_PARAMETER, DECL_POINTER, DECL_PROTECTED, DECL_PRIVATE,\n+    DECL_PUBLIC, DECL_SAVE, DECL_TARGET, DECL_VALUE, DECL_VOLATILE,\n+    DECL_COLON, DECL_NONE,\n     GFC_DECL_END /* Sentinel */\n   }\n   decl_types;\n@@ -2136,6 +2137,7 @@ match_attr_spec (void)\n     minit (\", optional\", DECL_OPTIONAL),\n     minit (\", parameter\", DECL_PARAMETER),\n     minit (\", pointer\", DECL_POINTER),\n+    minit (\", protected\", DECL_PROTECTED),\n     minit (\", private\", DECL_PRIVATE),\n     minit (\", public\", DECL_PUBLIC),\n     minit (\", save\", DECL_SAVE),\n@@ -2250,6 +2252,9 @@ match_attr_spec (void)\n \t  case DECL_POINTER:\n \t    attr = \"POINTER\";\n \t    break;\n+\t  case DECL_PROTECTED:\n+\t    attr = \"PROTECTED\";\n+\t    break;\n \t  case DECL_PRIVATE:\n \t    attr = \"PRIVATE\";\n \t    break;\n@@ -2364,6 +2369,23 @@ match_attr_spec (void)\n \t  t = gfc_add_pointer (&current_attr, &seen_at[d]);\n \t  break;\n \n+\tcase DECL_PROTECTED:\n+\t  if (gfc_current_ns->proc_name->attr.flavor != FL_MODULE)\n+\t    {\n+\t       gfc_error (\"PROTECTED at %C only allowed in specification \"\n+\t\t\t  \"part of a module\");\n+\t       t = FAILURE;\n+\t       break;\n+\t    }\n+\n+\t  if (gfc_notify_std (GFC_STD_F2003,\n+                              \"Fortran 2003: PROTECTED attribute at %C\")\n+\t      == FAILURE)\n+\t    t = FAILURE;\n+\t  else\n+\t    t = gfc_add_protected (&current_attr, NULL, &seen_at[d]);\n+\t  break;\n+\n \tcase DECL_PRIVATE:\n \t  t = gfc_add_access (&current_attr, ACCESS_PRIVATE, NULL,\n \t\t\t      &seen_at[d]);\n@@ -3840,6 +3862,67 @@ access_attr_decl (gfc_statement st)\n }\n \n \n+match\n+gfc_match_protected (void)\n+{\n+  gfc_symbol *sym;\n+  match m;\n+\n+  if (gfc_current_ns->proc_name->attr.flavor != FL_MODULE)\n+    {\n+       gfc_error (\"PROTECTED at %C only allowed in specification \"\n+\t\t  \"part of a module\");\n+       return MATCH_ERROR;\n+\n+    }\n+\n+  if (gfc_notify_std (GFC_STD_F2003, \n+\t\t      \"Fortran 2003: PROTECTED statement at %C\")\n+      == FAILURE)\n+    return MATCH_ERROR;\n+\n+  if (gfc_match (\" ::\") == MATCH_NO && gfc_match_space () == MATCH_NO)\n+    {\n+      return MATCH_ERROR;\n+    }\n+\n+  if (gfc_match_eos () == MATCH_YES)\n+    goto syntax;\n+\n+  for(;;)\n+    {\n+      m = gfc_match_symbol (&sym, 0);\n+      switch (m)\n+\t{\n+\tcase MATCH_YES:\n+\t  if (gfc_add_protected (&sym->attr, sym->name,\n+  \t\t\t         &gfc_current_locus) == FAILURE)\n+\t    return MATCH_ERROR;\n+\t  goto next_item;\n+\n+\tcase MATCH_NO:\n+\t  break;\n+\n+\tcase MATCH_ERROR:\n+\t  return MATCH_ERROR;\n+\t}\n+\n+    next_item:\n+      if (gfc_match_eos () == MATCH_YES)\n+\tbreak;\n+      if (gfc_match_char (',') != MATCH_YES)\n+\tgoto syntax;\n+    }\n+\n+  return MATCH_YES;\n+\n+syntax:\n+  gfc_error (\"Syntax error in PROTECTED statement at %C\");\n+  return MATCH_ERROR;\n+}\n+\n+\n+\n /* The PRIVATE statement is a bit weird in that it can be a attribute\n    declaration, but also works as a standlone statement inside of a\n    type declaration or a module.  */"}, {"sha": "17a7bf06052b7b0631dbad0f5df176925d720c64", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=ee7e677fdd929eb1b9fd60efa476c86fd0692784", "patch": "@@ -550,6 +550,8 @@ gfc_show_attr (symbol_attribute * attr)\n     gfc_status (\" OPTIONAL\");\n   if (attr->pointer)\n     gfc_status (\" POINTER\");\n+  if (attr->protected)\n+    gfc_status (\" PROTECTED\");\n   if (attr->save)\n     gfc_status (\" SAVE\");\n   if (attr->value)"}, {"sha": "7f6c699de59c8703d2af92ca3a53f06db4d07d24", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=ee7e677fdd929eb1b9fd60efa476c86fd0692784", "patch": "@@ -2414,6 +2414,13 @@ gfc_check_pointer_assign (gfc_expr * lvalue, gfc_expr * rvalue)\n       return FAILURE;\n     }\n \n+  if (attr.protected && attr.use_assoc)\n+    {\n+      gfc_error (\"Pointer assigment target has PROTECTED \"\n+                 \"attribute at %L\", &rvalue->where);\n+      return FAILURE;\n+    }\n+\n   return SUCCESS;\n }\n "}, {"sha": "0c67d10cf7e2dbb4ba91887acfefdd7be98a4008", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=ee7e677fdd929eb1b9fd60efa476c86fd0692784", "patch": "@@ -483,6 +483,7 @@ typedef struct\n     dummy:1, result:1, assign:1, threadprivate:1;\n \n   unsigned data:1,\t\t/* Symbol is named in a DATA statement.  */\n+    protected:1,\t\t/* Symbol has been marked as protected.  */\n     use_assoc:1,\t\t/* Symbol has been use-associated.  */\n     use_only:1;\t\t\t/* Symbol has been use-associated, with ONLY.  */\n \n@@ -1857,6 +1858,7 @@ try gfc_add_pointer (symbol_attribute *, locus *);\n try gfc_add_cray_pointer (symbol_attribute *, locus *);\n try gfc_add_cray_pointee (symbol_attribute *, locus *);\n try gfc_mod_pointee_as (gfc_array_spec *as);\n+try gfc_add_protected (symbol_attribute *, const char *, locus *);\n try gfc_add_result (symbol_attribute *, const char *, locus *);\n try gfc_add_save (symbol_attribute *, const char *, locus *);\n try gfc_add_threadprivate (symbol_attribute *, const char *, locus *);"}, {"sha": "28747e05be51d5d147a7255a35ba704f542ed510", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=ee7e677fdd929eb1b9fd60efa476c86fd0692784", "patch": "@@ -1206,6 +1206,36 @@ compare_parameter (gfc_symbol * formal, gfc_expr * actual,\n }\n \n \n+/* Given a symbol of a formal argument list and an expression, see if\n+   the two are compatible as arguments.  Returns nonzero if\n+   compatible, zero if not compatible.  */\n+\n+static int\n+compare_parameter_protected (gfc_symbol * formal, gfc_expr * actual)\n+{\n+  if (actual->expr_type != EXPR_VARIABLE)\n+    return 1;\n+\n+  if (!actual->symtree->n.sym->attr.protected)\n+    return 1;\n+\n+  if (!actual->symtree->n.sym->attr.use_assoc)\n+    return 1;\n+\n+  if (formal->attr.intent == INTENT_IN\n+      || formal->attr.intent == INTENT_UNKNOWN)\n+    return 1;\n+\n+  if (!actual->symtree->n.sym->attr.pointer)\n+    return 0;\n+\n+  if (actual->symtree->n.sym->attr.pointer && formal->attr.pointer)\n+    return 0;\n+\n+  return 1;\n+}\n+\n+\n /* Given formal and actual argument lists, see if they are compatible.\n    If they are compatible, the actual argument list is sorted to\n    correspond with the formal list, and elements for missing optional\n@@ -1393,6 +1423,16 @@ compare_actual_formal (gfc_actual_arglist ** ap,\n           return 0;\n         }\n \n+      if (!compare_parameter_protected(f->sym, a->expr))\n+\t{\n+\t  if (where)\n+\t    gfc_error (\"Actual argument at %L is use-associated with \"\n+\t\t       \"PROTECTED attribute and dummy argument '%s' is \"\n+\t\t       \"INTENT = OUT/INOUT\",\n+\t\t       &a->expr->where,f->sym->name);\n+          return 0;\n+\t}\n+\n     match:\n       if (a == actual)\n \tna = i;"}, {"sha": "0dc2c7295b15aabe80f02e8dc6161c844074931d", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=ee7e677fdd929eb1b9fd60efa476c86fd0692784", "patch": "@@ -852,6 +852,15 @@ gfc_match_assignment (void)\n       return MATCH_NO;\n     }\n \n+  if (lvalue->symtree->n.sym->attr.protected\n+      && lvalue->symtree->n.sym->attr.use_assoc)\n+    {\n+      gfc_current_locus = old_loc;\n+      gfc_free_expr (lvalue);\n+      gfc_error (\"Setting value of PROTECTED variable at %C\");\n+      return MATCH_ERROR;\n+    }\n+\n   rvalue = NULL;\n   m = gfc_match (\" %e%t\", &rvalue);\n   if (m != MATCH_YES)\n@@ -898,6 +907,15 @@ gfc_match_pointer_assignment (void)\n   if (m != MATCH_YES)\n     goto cleanup;\n \n+  if (lvalue->symtree->n.sym->attr.protected\n+      && lvalue->symtree->n.sym->attr.use_assoc)\n+    {\n+      gfc_error (\"Assigning to a PROTECTED pointer at %C\");\n+      m = MATCH_ERROR;\n+      goto cleanup;\n+    }\n+\n+\n   new_st.op = EXEC_POINTER_ASSIGN;\n   new_st.expr = lvalue;\n   new_st.expr2 = rvalue;"}, {"sha": "2209c0ded6d63b3d031c807f663b9414e3753ffb", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=ee7e677fdd929eb1b9fd60efa476c86fd0692784", "patch": "@@ -142,6 +142,7 @@ match gfc_match_intrinsic (void);\n match gfc_match_optional (void);\n match gfc_match_parameter (void);\n match gfc_match_pointer (void);\n+match gfc_match_protected (void);\n match gfc_match_private (gfc_statement *);\n match gfc_match_public (gfc_statement *);\n match gfc_match_save (void);"}, {"sha": "f54ef8e67cd0a460e12126f10a4f641808f0b295", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=ee7e677fdd929eb1b9fd60efa476c86fd0692784", "patch": "@@ -1491,7 +1491,7 @@ typedef enum\n   AB_IN_NAMELIST, AB_IN_COMMON, AB_FUNCTION, AB_SUBROUTINE, AB_SEQUENCE,\n   AB_ELEMENTAL, AB_PURE, AB_RECURSIVE, AB_GENERIC, AB_ALWAYS_EXPLICIT,\n   AB_CRAY_POINTER, AB_CRAY_POINTEE, AB_THREADPRIVATE, AB_ALLOC_COMP,\n-  AB_VALUE, AB_VOLATILE\n+  AB_VALUE, AB_VOLATILE, AB_PROTECTED\n }\n ab_attribute;\n \n@@ -1524,6 +1524,7 @@ static const mstring attr_bits[] =\n     minit (\"CRAY_POINTER\", AB_CRAY_POINTER),\n     minit (\"CRAY_POINTEE\", AB_CRAY_POINTEE),\n     minit (\"ALLOC_COMP\", AB_ALLOC_COMP),\n+    minit (\"PROTECTED\", AB_PROTECTED),\n     minit (NULL, -1)\n };\n \n@@ -1574,6 +1575,8 @@ mio_symbol_attribute (symbol_attribute * attr)\n \tMIO_NAME(ab_attribute) (AB_OPTIONAL, attr_bits);\n       if (attr->pointer)\n \tMIO_NAME(ab_attribute) (AB_POINTER, attr_bits);\n+      if (attr->protected)\n+\tMIO_NAME(ab_attribute) (AB_PROTECTED, attr_bits);\n       if (attr->save)\n \tMIO_NAME(ab_attribute) (AB_SAVE, attr_bits);\n       if (attr->value)\n@@ -1655,6 +1658,9 @@ mio_symbol_attribute (symbol_attribute * attr)\n \t    case AB_POINTER:\n \t      attr->pointer = 1;\n \t      break;\n+\t    case AB_PROTECTED:\n+\t      attr->protected = 1;\n+\t      break;\n \t    case AB_SAVE:\n \t      attr->save = 1;\n \t      break;"}, {"sha": "cbbf7341d59c457b2b219c6b45341be63c577703", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=ee7e677fdd929eb1b9fd60efa476c86fd0692784", "patch": "@@ -260,6 +260,7 @@ decode_statement (void)\n       match (\"program\", gfc_match_program, ST_PROGRAM);\n       if (gfc_match_public (&st) == MATCH_YES)\n \treturn st;\n+      match (\"protected\", gfc_match_protected, ST_ATTR_DECL);\n       break;\n \n     case 'r':"}, {"sha": "66ac2f15963b755bfe15b62d804ad5452772db58", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=ee7e677fdd929eb1b9fd60efa476c86fd0692784", "patch": "@@ -2303,6 +2303,11 @@ match_variable (gfc_expr ** result, int equiv_flag, int host_flag)\n   switch (sym->attr.flavor)\n     {\n     case FL_VARIABLE:\n+      if (sym->attr.protected && sym->attr.use_assoc)\n+        {\n+\t  gfc_error (\"Assigning to PROTECTED variable at %C\");\n+          return MATCH_ERROR;\n+        }\n       break;\n \n     case FL_UNKNOWN:"}, {"sha": "33ef7481470f687a89b8f363782deac6b8a3cc79", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=ee7e677fdd929eb1b9fd60efa476c86fd0692784", "patch": "@@ -6632,6 +6632,7 @@ resolve_equivalence_derived (gfc_symbol *derived, gfc_symbol *sym, gfc_expr *e)\n    the preceding objects.  A substring shall not have length zero.  A\n    derived type shall not have components with default initialization nor\n    shall two objects of an equivalence group be initialized.\n+   Either all or none of the objects shall have an protected attribute.\n    The simple constraints are done in symbol.c(check_conflict) and the rest\n    are implemented here.  */\n \n@@ -6646,7 +6647,7 @@ resolve_equivalence (gfc_equiv *eq)\n   locus *last_where = NULL;\n   seq_type eq_type, last_eq_type;\n   gfc_typespec *last_ts;\n-  int object;\n+  int object, cnt_protected;\n   const char *value_name;\n   const char *msg;\n \n@@ -6655,6 +6656,8 @@ resolve_equivalence (gfc_equiv *eq)\n \n   first_sym = eq->expr->symtree->n.sym;\n \n+  cnt_protected = 0;\n+\n   for (object = 1; eq; eq = eq->eq, object++)\n     {\n       e = eq->expr;\n@@ -6726,6 +6729,17 @@ resolve_equivalence (gfc_equiv *eq)\n \n       sym = e->symtree->n.sym;\n \n+      if (sym->attr.protected)\n+\tcnt_protected++;\n+      if (cnt_protected > 0 && cnt_protected != object)\n+       \t{\n+\t      gfc_error (\"Either all or none of the objects in the \"\n+\t\t\t \"EQUIVALENCE set at %L shall have the \"\n+\t\t\t \"PROTECTED attribute\",\n+\t\t\t &e->where);\n+\t      break;\n+        }\n+\n       /* An equivalence statement cannot have more than one initialized\n \t object.  */\n       if (sym->value)"}, {"sha": "12c5749acec3a12c1b2d6cfb273569b7ddfb770a", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=ee7e677fdd929eb1b9fd60efa476c86fd0692784", "patch": "@@ -275,7 +275,7 @@ check_conflict (symbol_attribute * attr, const char * name, locus * where)\n     *dimension = \"DIMENSION\", *in_equivalence = \"EQUIVALENCE\",\n     *use_assoc = \"USE ASSOCIATED\", *cray_pointer = \"CRAY POINTER\",\n     *cray_pointee = \"CRAY POINTEE\", *data = \"DATA\", *value = \"VALUE\",\n-    *volatile_ = \"VOLATILE\";\n+    *volatile_ = \"VOLATILE\", *protected = \"PROTECTED\";\n   static const char *threadprivate = \"THREADPRIVATE\";\n \n   const char *a1, *a2;\n@@ -404,6 +404,10 @@ check_conflict (symbol_attribute * attr, const char * name, locus * where)\n   conf (data, allocatable);\n   conf (data, use_assoc);\n \n+  conf (protected, intrinsic)\n+  conf (protected, external)\n+  conf (protected, in_common)\n+\n   conf (value, pointer)\n   conf (value, allocatable)\n   conf (value, subroutine)\n@@ -451,6 +455,7 @@ check_conflict (symbol_attribute * attr, const char * name, locus * where)\n       conf2 (save);\n       conf2 (volatile_);\n       conf2 (pointer);\n+      conf2 (protected);\n       conf2 (target);\n       conf2 (external);\n       conf2 (intrinsic);\n@@ -537,6 +542,7 @@ check_conflict (symbol_attribute * attr, const char * name, locus * where)\n       conf2 (subroutine);\n       conf2 (entry);\n       conf2 (pointer);\n+      conf2 (protected);\n       conf2 (target);\n       conf2 (dummy);\n       conf2 (in_common);\n@@ -781,6 +787,24 @@ gfc_add_cray_pointee (symbol_attribute * attr, locus * where)\n   return check_conflict (attr, NULL, where);\n }\n \n+try\n+gfc_add_protected (symbol_attribute * attr, const char *name, locus * where)\n+{\n+  if (check_used (attr, name, where))\n+    return FAILURE;\n+\n+  if (attr->protected)\n+    {\n+\tif (gfc_notify_std (GFC_STD_LEGACY, \n+\t\t\t    \"Duplicate PROTECTED attribute specified at %L\",\n+\t\t\t    where) \n+\t    == FAILURE)\n+\t  return FAILURE;\n+    }\n+\n+  attr->protected = 1;\n+  return check_conflict (attr, name, where);\n+}\n \n try\n gfc_add_result (symbol_attribute * attr, const char *name, locus * where)\n@@ -1293,6 +1317,8 @@ gfc_copy_attr (symbol_attribute * dest, symbol_attribute * src, locus * where)\n     goto fail;\n   if (src->pointer && gfc_add_pointer (dest, where) == FAILURE)\n     goto fail;\n+  if (src->protected && gfc_add_protected (dest, NULL, where) == FAILURE)\n+    goto fail;\n   if (src->save && gfc_add_save (dest, NULL, where) == FAILURE)\n     goto fail;\n   if (src->value && gfc_add_value (dest, NULL, where) == FAILURE)"}, {"sha": "cfdc64b5132ef509599f646b13167d767032f82b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ee7e677fdd929eb1b9fd60efa476c86fd0692784", "patch": "@@ -1,3 +1,13 @@\n+2006-12-10  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/23994\n+\t* gfortran.dg/protected_1.f90: New test.\n+\t* gfortran.dg/protected_2.f90: New test.\n+\t* gfortran.dg/protected_3.f90: New test.\n+\t* gfortran.dg/protected_4.f90: New test.\n+\t* gfortran.dg/protected_5.f90: New test.\n+\t* gfortran.dg/protected_6.f90: New test.\n+\n 2006-12-09  Paul Thomas  <pault@gcc.gnu.org>\n \t    Tobias Burnus  <burnus@gcc.gnu.org>\n "}, {"sha": "c1679f27e9dba0accf03510ad7cc216bc75d3793", "filename": "gcc/testsuite/gfortran.dg/protected_1.f90", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_1.f90?ref=ee7e677fdd929eb1b9fd60efa476c86fd0692784", "patch": "@@ -0,0 +1,61 @@\n+! { dg-run }\n+! { dg-options \"-std=f2003 -fall-intrinsics\" }\n+! PR fortran/23994\n+!\n+! Test PROTECTED attribute. Within the module everything is allowed.\n+! Outside (use-associated): For pointers, their association status\n+! may not be changed. For nonpointers, their value may not be changed.\n+!\n+! Test of a valid code\n+\n+module protmod\n+  implicit none\n+  integer          :: a,b\n+  integer, target  :: at,bt\n+  integer, pointer :: ap,bp\n+  protected :: a, at\n+  protected :: ap\n+contains\n+  subroutine setValue()\n+    a = 43\n+    ap => null()\n+    nullify(ap)\n+    ap => at\n+    ap = 3\n+    allocate(ap)\n+    ap = 73\n+    call increment(a,ap,at)\n+    if(a /= 44 .or. ap /= 74 .or. at /= 4) call abort()\n+  end subroutine setValue\n+  subroutine increment(a1,a2,a3)\n+    integer, intent(inout) :: a1, a2, a3\n+    a1 = a1 + 1\n+    a2 = a2 + 1\n+    a3 = a3 + 1\n+  end subroutine increment\n+end module protmod\n+\n+program main\n+  use protmod\n+  implicit none\n+  b = 5\n+  bp => bt\n+  bp = 4\n+  bt = 7\n+  call setValue()\n+  if(a /= 44 .or. ap /= 74 .or. at /= 4) call abort()\n+  call plus5(ap)\n+  if(a /= 44 .or. ap /= 79 .or. at /= 4) call abort()\n+  call checkVal(a,ap,at)\n+contains\n+  subroutine plus5(j)\n+    integer, intent(inout) :: j\n+    j = j + 5\n+  end subroutine plus5\n+  subroutine checkVal(x,y,z)\n+    integer, intent(in) :: x, y, z\n+    if(a /= 44 .or. ap /= 79 .or. at /= 4) call abort()\n+  end subroutine\n+end program main\n+\n+! { dg-final { cleanup-modules \"protmod\" } }"}, {"sha": "bba011571a9f44b62eb278b5721ba193c7f91986", "filename": "gcc/testsuite/gfortran.dg/protected_2.f90", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_2.f90?ref=ee7e677fdd929eb1b9fd60efa476c86fd0692784", "patch": "@@ -0,0 +1,55 @@\n+! { dg-run }\n+! { dg-options \"-std=f2003 -fall-intrinsics\" }\n+! PR fortran/23994\n+!\n+! Test PROTECTED attribute. Within the module everything is allowed.\n+! Outside (use-associated): For pointers, their association status\n+! may not be changed. For nonpointers, their value may not be changed.\n+!\n+! Test of a valid code\n+\n+module protmod\n+  implicit none\n+  integer, protected          :: a\n+  integer, protected, target  :: at\n+  integer, protected, pointer :: ap\n+contains\n+  subroutine setValue()\n+    a = 43\n+    ap => null()\n+    nullify(ap)\n+    ap => at\n+    ap = 3\n+    allocate(ap)\n+    ap = 73\n+    call increment(a,ap,at)\n+    if(a /= 44 .or. ap /= 74 .or. at /= 4) call abort()\n+  end subroutine setValue\n+  subroutine increment(a1,a2,a3)\n+    integer, intent(inout) :: a1, a2, a3\n+    a1 = a1 + 1\n+    a2 = a2 + 1\n+    a3 = a3 + 1\n+  end subroutine increment\n+end module protmod\n+\n+program main\n+  use protmod\n+  implicit none\n+  call setValue()\n+  if(a /= 44 .or. ap /= 74 .or. at /= 4) call abort()\n+  call plus5(ap)\n+  if(a /= 44 .or. ap /= 79 .or. at /= 4) call abort()\n+  call checkVal(a,ap,at)\n+contains\n+  subroutine plus5(j)\n+    integer, intent(inout) :: j\n+    j = j + 5\n+  end subroutine plus5\n+  subroutine checkVal(x,y,z)\n+    integer, intent(in) :: x, y, z\n+    if(a /= 44 .or. ap /= 79 .or. at /= 4) call abort()\n+  end subroutine\n+end program main\n+\n+! { dg-final { cleanup-modules \"protmod\" } }"}, {"sha": "a709b50d6f9ee6bb0afb17392a92a243a43f3d14", "filename": "gcc/testsuite/gfortran.dg/protected_3.f90", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_3.f90?ref=ee7e677fdd929eb1b9fd60efa476c86fd0692784", "patch": "@@ -0,0 +1,25 @@\n+! { dg-run }\n+! { dg-shouldfail \"Fortran 2003 code with -std=f95\" }\n+! { dg-options \"-std=f95 -fall-intrinsics\" }\n+! PR fortran/23994\n+!\n+! Test PROTECTED attribute. Within the module everything is allowed.\n+! Outside (use-associated): For pointers, their association status\n+! may not be changed. For nonpointers, their value may not be changed.\n+!\n+! Reject in Fortran 95\n+\n+module protmod\n+  implicit none\n+  integer          :: a\n+  integer, target  :: at\n+  integer, pointer :: ap\n+  protected :: a, at, ap ! { dg-error \"Fortran 2003: PROTECTED statement\" }\n+end module protmod\n+\n+module protmod2\n+  implicit none\n+  integer, protected          :: a  ! { dg-error \"Fortran 2003: PROTECTED attribute\" }\n+  integer, protected, target  :: at ! { dg-error \"Fortran 2003: PROTECTED attribute\" }\n+  integer, protected, pointer :: ap ! { dg-error \"Fortran 2003: PROTECTED attribute\" }\n+end module protmod2"}, {"sha": "be35b6bf60b20f0990cd0ed43014341f1df24675", "filename": "gcc/testsuite/gfortran.dg/protected_4.f90", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_4.f90?ref=ee7e677fdd929eb1b9fd60efa476c86fd0692784", "patch": "@@ -0,0 +1,50 @@\n+! { dg-compile }\n+! { dg-shouldfail \"Invalid Fortran 2003 code\" }\n+! { dg-options \"-std=f2003 -fall-intrinsics\" }\n+! PR fortran/23994\n+!\n+! Test PROTECTED attribute. Within the module everything is allowed.\n+! Outside (use-associated): For pointers, their association status\n+! may not be changed. For nonpointers, their value may not be changed.\n+!\n+! Test of a invalid code\n+\n+module protmod\n+  implicit none\n+  integer          :: a\n+  integer, target  :: at\n+  integer, pointer :: ap\n+  protected :: a, at, ap\n+end module protmod\n+\n+program main\n+  use protmod\n+  implicit none\n+  integer   :: j \n+  protected :: j ! { dg-error \"only allowed in specification part of a module\" }\n+  a = 43       ! { dg-error \"Assigning to PROTECTED variable\" }\n+  ap => null() ! { dg-error \"Assigning to PROTECTED variable\" }\n+  nullify(ap)  ! { dg-error \"Assigning to PROTECTED variable\" }\n+  ap => at     ! { dg-error \"Assigning to PROTECTED variable\" }\n+  ap = 3       ! { dg-error \"Assigning to PROTECTED variable\" }\n+  allocate(ap) ! { dg-error \"Assigning to PROTECTED variable\" }\n+  ap = 73      ! { dg-error \"Assigning to PROTECTED variable\" }\n+  call increment(a,at) ! { dg-error \"use-associated with PROTECTED attribute\" }\n+contains\n+  subroutine increment(a1,a3)\n+    integer, intent(inout) :: a1, a3\n+    a1 = a1 + 1\n+    a3 = a3 + 1\n+  end subroutine increment\n+  subroutine pointer_assignments(p)\n+    integer, pointer :: p ! with [pointer] intent(out)\n+    p => null()           ! this is invalid\n+  end subroutine pointer_assignments\n+end program main\n+\n+module test\n+  real :: a\n+  protected :: test ! { dg-error \"MODULE attribute conflicts with PROTECTED\" }\n+end module test\n+\n+! { dg-final { cleanup-modules \"protmod\" } }"}, {"sha": "24676340ecafb2053f6fc27eec61814175c4e317", "filename": "gcc/testsuite/gfortran.dg/protected_5.f90", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_5.f90?ref=ee7e677fdd929eb1b9fd60efa476c86fd0692784", "patch": "@@ -0,0 +1,57 @@\n+! { dg-compile }\n+! { dg-shouldfail \"Invalid Fortran 2003 code\" }\n+! { dg-options \"-std=f2003 -fall-intrinsics\" }\n+! PR fortran/23994\n+!\n+! Test PROTECTED attribute. Within the module everything is allowed.\n+! Outside (use-associated): For pointers, their association status\n+! may not be changed. For nonpointers, their value may not be changed.\n+!\n+! Test of a invalid code\n+\n+module good1\n+  implicit none\n+  integer              :: a\n+  integer              :: b,c\n+  protected            :: c\n+  equivalence (a,c) ! { dg-error \"Either all or none of the objects in the EQUIVALENCE\" }\n+end module good1\n+\n+\n+module bad1\n+  implicit none\n+  integer, protected   :: a\n+  integer              :: b,c\n+  protected            :: c\n+  equivalence (a,b) ! { dg-error \"Either all or none of the objects in the EQUIVALENCE\" }\n+end module bad1\n+\n+module bad2\n+  implicit none\n+  integer, protected   :: a\n+  integer              :: b,c,d\n+  protected            :: c\n+  common /one/ a,b  ! { dg-error \"PROTECTED attribute conflicts with COMMON\" }\n+  common /two/ c,d  ! { dg-error \"PROTECTED attribute conflicts with COMMON\" }\n+end module bad2\n+\n+module good2\n+  implicit none\n+  type myT\n+     integer :: j\n+     integer, pointer :: p\n+     real, allocatable, dimension(:) :: array\n+  end type myT\n+  type(myT), save :: t\n+  protected :: t\n+end module good2\n+\n+program main\n+  use good2\n+  implicit none\n+  t%j = 15             ! { dg-error \"Assigning to PROTECTED variable\" }\n+  nullify(t%p)         ! { dg-error \"Assigning to PROTECTED variable\" }\n+  allocate(t%array(15))! { dg-error \"Assigning to PROTECTED variable\" }\n+end program main\n+\n+! { dg-final { cleanup-modules \"good1 good2 bad1 bad2\" } }"}, {"sha": "50729495c8f8b8fd6536221ec47e9207e53188dc", "filename": "gcc/testsuite/gfortran.dg/protected_6.f90", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7e677fdd929eb1b9fd60efa476c86fd0692784/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_6.f90?ref=ee7e677fdd929eb1b9fd60efa476c86fd0692784", "patch": "@@ -0,0 +1,50 @@\n+! { dg-compile }\n+! { dg-shouldfail \"Invalid Fortran 2003 code\" }\n+! { dg-options \"-std=f2003 -fall-intrinsics\" }\n+! PR fortran/23994\n+!\n+! Test PROTECTED attribute. Within the module everything is allowed.\n+! Outside (use-associated): For pointers, their association status\n+! may not be changed. For nonpointers, their value may not be changed.\n+!\n+! Test of a invalid code\n+\n+module protmod\n+  implicit none\n+  integer, Protected          :: a\n+  integer, protected, target  :: at\n+  integer, protected, pointer :: ap\n+end module protmod\n+\n+program main\n+  use protmod\n+  implicit none\n+  a = 43       ! { dg-error \"Assigning to PROTECTED variable\" }\n+  ap => null() ! { dg-error \"Assigning to PROTECTED variable\" }\n+  nullify(ap)  ! { dg-error \"Assigning to PROTECTED variable\" }\n+  ap => at     ! { dg-error \"Assigning to PROTECTED variable\" }\n+  ap = 3       ! { dg-error \"Assigning to PROTECTED variable\" }\n+  allocate(ap) ! { dg-error \"Assigning to PROTECTED variable\" }\n+  ap = 73      ! { dg-error \"Assigning to PROTECTED variable\" }\n+  call increment(a,at) ! { dg-error \"use-associated with PROTECTED attribute\" }\n+contains\n+  subroutine increment(a1,a3)\n+    integer, intent(inout) :: a1, a3\n+    a1 = a1 + 1\n+    a3 = a3 + 1\n+  end subroutine increment\n+  subroutine pointer_assignments(p)\n+    integer, pointer :: p ! with [pointer] intent(out)\n+    p => null()           ! this is invalid\n+  end subroutine pointer_assignments\n+end program main\n+\n+module prot2\n+  implicit none\n+contains\n+  subroutine bar\n+    real, protected :: b ! { dg-error \"only allowed in specification part of a module\" }\n+  end subroutine bar\n+end module prot2\n+\n+! { dg-final { cleanup-modules \"protmod\" } }"}]}