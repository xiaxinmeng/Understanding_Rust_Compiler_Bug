{"sha": "f5d8c9f4053985a3694c56239b2c6a08b416bfa5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjVkOGM5ZjQwNTM5ODVhMzY5NGM1NjIzOWIyYzZhMDhiNDE2YmZhNQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "1999-12-13T13:21:35Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "1999-12-13T13:21:35Z"}, "message": "Simplify reload register allocation\n\nFrom-SVN: r30890", "tree": {"sha": "d9cb4c6b8528afdab21ca0ece166d271c5e19197", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9cb4c6b8528afdab21ca0ece166d271c5e19197"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5d8c9f4053985a3694c56239b2c6a08b416bfa5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5d8c9f4053985a3694c56239b2c6a08b416bfa5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5d8c9f4053985a3694c56239b2c6a08b416bfa5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5d8c9f4053985a3694c56239b2c6a08b416bfa5/comments", "author": null, "committer": null, "parents": [{"sha": "2cf4028a7c28adbbbcbda21a02bd851a140a8652", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cf4028a7c28adbbbcbda21a02bd851a140a8652", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cf4028a7c28adbbbcbda21a02bd851a140a8652"}], "stats": {"total": 1546, "additions": 416, "deletions": 1130}, "files": [{"sha": "621f39a40caffe47035ff8763b2dbc30d38db14d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5d8c9f4053985a3694c56239b2c6a08b416bfa5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5d8c9f4053985a3694c56239b2c6a08b416bfa5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f5d8c9f4053985a3694c56239b2c6a08b416bfa5", "patch": "@@ -1,3 +1,46 @@\n+1999-12-10  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* hard-reg-set.h (inv_reg_alloc_order): Declare if REG_ALLOC_ORDER is\n+\tdefined.\n+\t* regclass.c (inv_reg_alloc_order): New array.\n+\t(regclass_init): If REG_ALLOC_ORDER is defined, initialize it.\n+\n+\t* reload.h (struct insn_chain): Delete fields group_size, group_mode,\n+\tcounted_for_groups, counted_for_nongroups.  Add fields rld and\n+\tn_reloads.\n+\t* reload.c (push_secondary_reload): Don't set nongroup field of\n+\tnew reloads.\n+\t(push_reload): Likewise.\n+\t(find_reloads): Delete code to compute nongroup fields.\n+\t* reload1.c (reload_insn_firstobj): New static variable.\n+\t(pseudos_counted, spilled_pseudos): Now of type regset_head.  All\n+\tusers changed.\n+\t(calculate_needs, find_tworeg_group, find_group, possible_group_p,\n+\tcount_possible_groups, modes_equiv_for_class_p, new_spill_reg,\n+\tdump_needs, maybe_mark_pseudo_spilled, hard_reg_use_compare): Delete\n+\tfunctions.\n+\t(count_pseudo, select_reload_regs, copy_reloads, find_reg): New\n+\tfunctions.\n+\t(struct hard_reg_n_uses): Deleted.\n+\t(potential_reload_regs): Deleted.\n+\t(init_reload): Initialize spilled_pseudos and pseudos_counted.\n+\t(reload): Don't try to allocate reload registers if we already know\n+\twe have to make another pass.  Call select_reload_regs.  Free memory\n+\tstarting with reload_firstobj when starting another pass.\n+\tDon't allocate spilled_pseudos.\n+\t(calculate_needs_all_insns): Call copy_reloads for an insn that\n+\tneeds reloads; don't call calculate_needs.\n+\t(spill_cost): New static array.\n+\t(used_spill_regs_local): New static variable.\n+\t(order_regs_for_reload): Rewrite to lose hard_reg_n_uses and the code\n+\tto compute potential_reload_regs.\n+\t(find_reload_regs): Completely rewritten to use find_reg.\n+\t(allocate_reload_reg): Don't test counted_for_groups or\n+\tcounted_for_nongroups.  Lose NOERROR arg and code to give an error;\n+\tall cllers changed.\n+\t(choose_reload_regs): Add fallback code that uses the existing\n+\tregister allocation from find_reload_regs.\n+\n Mon Dec 13 00:54:14 1999  Philippe De Muyter  <phdm@macqel.be>\n \n \t* flow.c (create_edge_list): Cast xmalloc return value."}, {"sha": "dd093db3cbeceffed3ab1d32239c57f848bf731a", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5d8c9f4053985a3694c56239b2c6a08b416bfa5/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5d8c9f4053985a3694c56239b2c6a08b416bfa5/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=f5d8c9f4053985a3694c56239b2c6a08b416bfa5", "patch": "@@ -429,10 +429,14 @@ extern HARD_REG_SET call_fixed_reg_set;\n \n extern char global_regs[FIRST_PSEUDO_REGISTER];\n \n+#ifdef REG_ALLOC_ORDER\n /* Table of register numbers in the order in which to try to use them.  */\n \n-#ifdef REG_ALLOC_ORDER   /* Avoid undef symbol in certain broken linkers.  */\n extern int reg_alloc_order[FIRST_PSEUDO_REGISTER];\n+\n+/* The inverse of reg_alloc_order.  */\n+\n+extern int inv_reg_alloc_order[FIRST_PSEUDO_REGISTER];\n #endif\n \n /* For each reg class, a HARD_REG_SET saying which registers are in it.  */"}, {"sha": "630e3e8cfee7f98880ff690bcfed05efa15a5ed1", "filename": "gcc/regclass.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5d8c9f4053985a3694c56239b2c6a08b416bfa5/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5d8c9f4053985a3694c56239b2c6a08b416bfa5/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=f5d8c9f4053985a3694c56239b2c6a08b416bfa5", "patch": "@@ -118,6 +118,9 @@ char global_regs[FIRST_PSEUDO_REGISTER];\n /* Table of register numbers in the order in which to try to use them.  */\n #ifdef REG_ALLOC_ORDER\n int reg_alloc_order[FIRST_PSEUDO_REGISTER] = REG_ALLOC_ORDER;\n+\n+/* The inverse of reg_alloc_order.  */\n+int inv_reg_alloc_order[FIRST_PSEUDO_REGISTER];\n #endif\n \n /* For each reg class, a HARD_REG_SET saying which registers are in it.  */\n@@ -251,6 +254,11 @@ init_reg_sets ()\n \n   /* Do any additional initialization regsets may need */\n   INIT_ONCE_REG_SET ();\n+\n+#ifdef REG_ALLOC_ORDER\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    inv_reg_alloc_order[reg_alloc_order[i]] = i;\n+#endif\n }\n \n /* After switches have been processed, which perhaps alter"}, {"sha": "bcaef6cf534a472e9913f7ddd5f6a3377c1b8275", "filename": "gcc/reload.c", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5d8c9f4053985a3694c56239b2c6a08b416bfa5/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5d8c9f4053985a3694c56239b2c6a08b416bfa5/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=f5d8c9f4053985a3694c56239b2c6a08b416bfa5", "patch": "@@ -465,7 +465,6 @@ push_secondary_reload (in_p, x, opnum, optional, reload_class, reload_mode,\n \t  rld[t_reload].outmode = ! in_p ? t_mode : VOIDmode;\n \t  rld[t_reload].reg_rtx = 0;\n \t  rld[t_reload].optional = optional;\n-\t  rld[t_reload].nongroup = 0;\n \t  rld[t_reload].inc = 0;\n \t  /* Maybe we could combine these, but it seems too tricky.  */\n \t  rld[t_reload].nocombine = 1;\n@@ -535,7 +534,6 @@ push_secondary_reload (in_p, x, opnum, optional, reload_class, reload_mode,\n       rld[s_reload].outmode = ! in_p ? mode : VOIDmode;\n       rld[s_reload].reg_rtx = 0;\n       rld[s_reload].optional = optional;\n-      rld[s_reload].nongroup = 0;\n       rld[s_reload].inc = 0;\n       /* Maybe we could combine these, but it seems too tricky.  */\n       rld[s_reload].nocombine = 1;\n@@ -1246,7 +1244,6 @@ push_reload (in, out, inloc, outloc, class,\n       rld[i].outmode = outmode;\n       rld[i].reg_rtx = 0;\n       rld[i].optional = optional;\n-      rld[i].nongroup = 0;\n       rld[i].inc = 0;\n       rld[i].nocombine = 0;\n       rld[i].in_reg = inloc ? *inloc : 0;\n@@ -4119,67 +4116,6 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \tabort ();\n #endif\n \n-  /* Set which reloads must use registers not used in any group.  Start\n-     with those that conflict with a group and then include ones that\n-     conflict with ones that are already known to conflict with a group.  */\n-\n-  changed = 0;\n-  for (i = 0; i < n_reloads; i++)\n-    {\n-      enum machine_mode mode = rld[i].inmode;\n-      enum reg_class class = rld[i].class;\n-      int size;\n-\n-      if (GET_MODE_SIZE (rld[i].outmode) > GET_MODE_SIZE (mode))\n-\tmode = rld[i].outmode;\n-      size = CLASS_MAX_NREGS (class, mode);\n-\n-      if (size == 1)\n-\tfor (j = 0; j < n_reloads; j++)\n-\t  if ((CLASS_MAX_NREGS (rld[j].class,\n-\t\t\t\t(GET_MODE_SIZE (rld[j].outmode)\n-\t\t\t\t > GET_MODE_SIZE (rld[j].inmode))\n-\t\t\t\t? rld[j].outmode : rld[j].inmode)\n-\t       > 1)\n-\t      && !rld[j].optional\n-\t      && (rld[j].in != 0 || rld[j].out != 0\n-\t\t  || rld[j].secondary_p)\n-\t      && reloads_conflict (i, j)\n-\t      && reg_classes_intersect_p (class, rld[j].class))\n-\t    {\n-\t      rld[i].nongroup = 1;\n-\t      changed = 1;\n-\t      break;\n-\t    }\n-    }\n-\n-  while (changed)\n-    {\n-      changed = 0;\n-\n-      for (i = 0; i < n_reloads; i++)\n-\t{\n-\t  enum machine_mode mode = rld[i].inmode;\n-\t  enum reg_class class = rld[i].class;\n-\t  int size;\n-\n-\t  if (GET_MODE_SIZE (rld[i].outmode) > GET_MODE_SIZE (mode))\n-\t    mode = rld[i].outmode;\n-\t  size = CLASS_MAX_NREGS (class, mode);\n-\n-\t  if (! rld[i].nongroup && size == 1)\n-\t    for (j = 0; j < n_reloads; j++)\n-\t      if (rld[j].nongroup\n-\t\t  && reloads_conflict (i, j)\n-\t\t  && reg_classes_intersect_p (class, rld[j].class))\n-\t\t{\n-\t\t  rld[i].nongroup = 1;\n-\t\t  changed = 1;\n-\t\t  break;\n-\t\t}\n-\t}\n-    }\n-\n   /* Compute reload_mode and reload_nregs.  */\n   for (i = 0; i < n_reloads; i++)\n     {"}, {"sha": "52ede8dd9aea580347574533e28042c0b7adc5eb", "filename": "gcc/reload.h", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5d8c9f4053985a3694c56239b2c6a08b416bfa5/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5d8c9f4053985a3694c56239b2c6a08b416bfa5/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=f5d8c9f4053985a3694c56239b2c6a08b416bfa5", "patch": "@@ -231,25 +231,9 @@ struct insn_chain\n   regset live_before;\n   regset live_after;\n \n-  /* For each class, size of group of consecutive regs\n-     that is needed for the reloads of this class.  */\n-  char group_size[N_REG_CLASSES];\n-  /* For each class, the machine mode which requires consecutive\n-     groups of regs of that class.\n-     If two different modes ever require groups of one class,\n-     they must be the same size and equally restrictive for that class,\n-     otherwise we can't handle the complexity.  */\n-  enum machine_mode group_mode[N_REG_CLASSES];\n-\n-  /* Indicates if a register was counted against the need for\n-     groups.  0 means it can count against max_nongroup instead.  */\n-  HARD_REG_SET counted_for_groups;\n-\n-  /* Indicates if a register was counted against the need for\n-     non-groups.  0 means it can become part of a new group.\n-     During choose_reload_regs, 1 here means don't use this reg\n-     as part of a group, even if it seems to be otherwise ok.  */\n-  HARD_REG_SET counted_for_nongroups;\n+  /* Copies of the global variables computed by find_reloads.  */\n+  struct reload *rld;\n+  int n_reloads;\n \n   /* Indicates which registers have already been used for spills.  */\n   HARD_REG_SET used_spill_regs;"}, {"sha": "4bdcaf8de9df34165e8f6d27f75c6acd272bcf13", "filename": "gcc/reload1.c", "status": "modified", "additions": 357, "deletions": 1046, "changes": 1403, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5d8c9f4053985a3694c56239b2c6a08b416bfa5/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5d8c9f4053985a3694c56239b2c6a08b416bfa5/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=f5d8c9f4053985a3694c56239b2c6a08b416bfa5", "patch": "@@ -215,13 +215,6 @@ static HARD_REG_SET used_spill_regs;\n    a round-robin fashion.  */\n static int last_spill_reg;\n \n-/* Describes order of preference for putting regs into spill_regs.\n-   Contains the numbers of all the hard regs, in order most preferred first.\n-   This order is different for each function.\n-   It is set up by order_regs_for_reload.\n-   Empty elements at the end contain -1.  */\n-static short potential_reload_regs[FIRST_PSEUDO_REGISTER];\n-\n /* Nonzero if indirect addressing is supported on the machine; this means\n    that spilling (REG n) does not require reloading it into a register in\n    order to do (MEM (REG n)) or (MEM (PLUS (REG n) (CONST_INT c))).  The\n@@ -245,7 +238,11 @@ static rtx spill_stack_slot[FIRST_PSEUDO_REGISTER];\n static int spill_stack_slot_width[FIRST_PSEUDO_REGISTER];\n \n /* Record which pseudos needed to be spilled.  */\n-static regset spilled_pseudos;\n+static regset_head spilled_pseudos;\n+\n+/* Used for communication between order_regs_for_reload and count_pseudo.\n+   Used to avoid counting one pseudo twice.  */\n+static regset_head pseudos_counted;\n \n /* First uid used by insns created by reload in this function.\n    Used in find_equiv_reg.  */\n@@ -275,9 +272,13 @@ struct obstack reload_obstack;\n char *reload_startobj;\n \n /* The point after all insn_chain structures.  Used to quickly deallocate\n-   memory used while processing one insn.  */\n+   memory allocated in copy_reloads during calculate_needs_all_insns.  */\n char *reload_firstobj;\n \n+/* This points before all local rtl generated by register elimination.\n+   Used to quickly free all memory after processing one insn.  */\n+static char *reload_insn_firstobj;\n+\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n@@ -364,33 +365,18 @@ static int (*offsets_at)[NUM_ELIMINABLE_REGS];\n /* Number of labels in the current function.  */\n \n static int num_labels;\n-\n-struct hard_reg_n_uses\n-{\n-  int regno;\n-  unsigned int uses;\n-};\n \f\n static void maybe_fix_stack_asms\tPROTO((void));\n+static void copy_reloads\t\tPROTO((struct insn_chain *));\n static void calculate_needs_all_insns\tPROTO((int));\n-static void calculate_needs\t\tPROTO((struct insn_chain *));\n-static void find_reload_regs\t\tPROTO((struct insn_chain *chain,\n+static int find_reg\t\t\tPROTO((struct insn_chain *, int,\n \t\t\t\t\t       FILE *));\n-static void find_tworeg_group\t\tPROTO((struct insn_chain *, int,\n-\t\t\t\t\t       FILE *));\n-static void find_group\t\t\tPROTO((struct insn_chain *, int,\n-\t\t\t\t\t       FILE *));\n-static int possible_group_p\t\tPROTO((struct insn_chain *, int));\n-static void count_possible_groups\tPROTO((struct insn_chain *, int));\n-static int modes_equiv_for_class_p\tPROTO((enum machine_mode,\n-\t\t\t\t\t       enum machine_mode,\n-\t\t\t\t\t       enum reg_class));\n+static void find_reload_regs\t\tPROTO((struct insn_chain *, FILE *));\n+static void select_reload_regs\t\tPROTO((FILE *));\n static void delete_caller_save_insns\tPROTO((void));\n \n static void spill_failure\t\tPROTO((rtx));\n-static void new_spill_reg\t\tPROTO((struct insn_chain *, int, int,\n-\t\t\t\t\t       int, FILE *));\n-static void maybe_mark_pseudo_spilled\tPROTO((int));\n+static void count_spilled_pseudo\tPROTO((int, int, int));\n static void delete_dead_insn\t\tPROTO((rtx));\n static void alter_reg  \t\t\tPROTO((int, int));\n static void set_label_offsets\t\tPROTO((rtx, rtx, int));\n@@ -409,8 +395,7 @@ static void spill_hard_reg\t\tPROTO((int, FILE *, int));\n static int finish_spills\t\tPROTO((int, FILE *));\n static void ior_hard_reg_set\t\tPROTO((HARD_REG_SET *, HARD_REG_SET *));\n static void scan_paradoxical_subregs\tPROTO((rtx));\n-static int hard_reg_use_compare\t\tPROTO((const PTR, const PTR));\n-static void count_pseudo\t\tPROTO((struct hard_reg_n_uses *, int));\n+static void count_pseudo\t\tPROTO((int));\n static void order_regs_for_reload\tPROTO((struct insn_chain *));\n static void reload_as_needed\t\tPROTO((int));\n static void forget_old_reloads_1\tPROTO((rtx, rtx, void *));\n@@ -420,10 +405,12 @@ static void mark_reload_reg_in_use\tPROTO((int, int, enum reload_type,\n static void clear_reload_reg_in_use\tPROTO((int, int, enum reload_type,\n \t\t\t\t\t       enum machine_mode));\n static int reload_reg_free_p\t\tPROTO((int, int, enum reload_type));\n-static int reload_reg_free_for_value_p\tPROTO((int, int, enum reload_type, rtx, rtx, int, int));\n+static int reload_reg_free_for_value_p\tPROTO((int, int, enum reload_type,\n+\t\t\t\t\t       rtx, rtx, int, int));\n static int reload_reg_reaches_end_p\tPROTO((int, int, enum reload_type));\n-static int allocate_reload_reg\t\tPROTO((struct insn_chain *, int, int,\n-\t\t\t\t\t       int));\n+static int allocate_reload_reg\t\tPROTO((struct insn_chain *, int, int));\n+static void failed_reload\t\tPROTO((rtx, int));\n+static int set_reload_reg\t\tPROTO((int, int));\n static void choose_reload_regs_init\tPROTO((struct insn_chain *, rtx *));\n static void choose_reload_regs\t\tPROTO((struct insn_chain *));\n static void merge_assigned_reloads\tPROTO((rtx));\n@@ -509,6 +496,9 @@ init_reload ()\n   /* Initialize obstack for our rtl allocation.  */\n   gcc_obstack_init (&reload_obstack);\n   reload_startobj = (char *) obstack_alloc (&reload_obstack, 0);\n+\n+  INIT_REG_SET (&spilled_pseudos);\n+  INIT_REG_SET (&pseudos_counted);\n }\n \n /* List of insn chains that are currently unused.  */\n@@ -817,8 +807,6 @@ reload (first, global, dumpfile)\n   /* Initialize to -1, which means take the first spill register.  */\n   last_spill_reg = -1;\n \n-  spilled_pseudos = ALLOCA_REG_SET ();\n-\n   /* Spill any hard regs that we know we can't eliminate.  */\n   CLEAR_HARD_REG_SET (used_spill_regs);\n   for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n@@ -842,7 +830,6 @@ reload (first, global, dumpfile)\n     {\n       int something_changed;\n       int did_spill;\n-      struct insn_chain *chain;\n \n       HOST_WIDE_INT starting_frame_size;\n \n@@ -928,7 +915,7 @@ reload (first, global, dumpfile)\n \n       calculate_needs_all_insns (global);\n \n-      CLEAR_REG_SET (spilled_pseudos);\n+      CLEAR_REG_SET (&spilled_pseudos);\n       did_spill = 0;\n \n       something_changed = 0;\n@@ -961,23 +948,25 @@ reload (first, global, dumpfile)\n \t    }\n       }\n \n-      CLEAR_HARD_REG_SET (used_spill_regs);\n-      /* Try to satisfy the needs for each insn.  */\n-      for (chain = insns_need_reload; chain != 0;\n-\t   chain = chain->next_need_reload)\n-\tfind_reload_regs (chain, dumpfile);\n-\n-      if (failure)\n-\tgoto failed;\n+      /* No point in trying to select reload registers if we know we're\n+\t going to re-run everything again.  */\n+      if (! something_changed)\n+\t{\n+\t  select_reload_regs (dumpfile);\n \n-      if (insns_need_reload != 0 || did_spill)\n-\tsomething_changed |= finish_spills (global, dumpfile);\n+\t  if (failure)\n+\t    goto failed;\n \n+\t  if (insns_need_reload != 0 || did_spill)\n+\t    something_changed |= finish_spills (global, dumpfile);\n+\t}\n       if (! something_changed)\n \tbreak;\n \n       if (caller_save_needed)\n \tdelete_caller_save_insns ();\n+\n+      obstack_free (&reload_obstack, reload_firstobj);\n     }\n \n   /* If global-alloc was run, notify it of any register eliminations we have\n@@ -1049,6 +1038,7 @@ reload (first, global, dumpfile)\n      and we decide not to abort about it.  */\n  failed:\n \n+  CLEAR_REG_SET (&spilled_pseudos);\n   reload_in_progress = 0;\n \n   /* Now eliminate all pseudo regs by modifying them into\n@@ -1194,8 +1184,6 @@ reload (first, global, dumpfile)\n   free (pseudo_previous_regs);\n   free (pseudo_forbidden_regs);\n \n-  FREE_REG_SET (spilled_pseudos);\n-\n   CLEAR_HARD_REG_SET (used_spill_regs);\n   for (i = 0; i < n_spills; i++)\n     SET_HARD_REG_BIT (used_spill_regs, spill_regs[i]);\n@@ -1319,8 +1307,21 @@ maybe_fix_stack_asms ()\n \n #endif\n }\n-\n \f\n+/* Copy the global variables n_reloads and rld into the corresponding elts\n+   of CHAIN.  */\n+static void\n+copy_reloads (chain)\n+     struct insn_chain *chain;\n+{\n+  chain->n_reloads = n_reloads;\n+  chain->rld\n+    = (struct reload *) obstack_alloc (&reload_obstack,\n+\t\t\t\t       n_reloads * sizeof (struct reload));\n+  memcpy (chain->rld, rld, n_reloads * sizeof (struct reload));\n+  reload_insn_firstobj = (char *) obstack_alloc (&reload_obstack, 0);\n+}\n+\n /* Walk the chain of insns, and determine for each whether it needs reloads\n    and/or eliminations.  Build the corresponding insns_need_reload list, and\n    set something_needs_elimination as appropriate.  */\n@@ -1333,11 +1334,13 @@ calculate_needs_all_insns (global)\n \n   something_needs_elimination = 0;\n \n+  reload_insn_firstobj = (char *) obstack_alloc (&reload_obstack, 0);\n   for (chain = reload_insn_chain; chain != 0; chain = chain->next)\n     {\n       rtx insn = chain->insn;\n \n-      /* Clear out the shortcuts, in case they were set last time through.  */\n+      /* Clear out the shortcuts.  */\n+      chain->n_reloads = 0;\n       chain->need_elim = 0;\n       chain->need_reload = 0;\n       chain->need_operand_change = 0;\n@@ -1407,7 +1410,7 @@ calculate_needs_all_insns (global)\n \t  /* Discard any register replacements done.  */\n \t  if (did_elimination)\n \t    {\n-\t      obstack_free (&reload_obstack, reload_firstobj);\n+\t      obstack_free (&reload_obstack, reload_insn_firstobj);\n \t      PATTERN (insn) = old_body;\n \t      INSN_CODE (insn) = old_code;\n \t      REG_NOTES (insn) = old_notes;\n@@ -1418,611 +1421,332 @@ calculate_needs_all_insns (global)\n \n \t  if (n_reloads != 0)\n \t    {\n+\t      copy_reloads (chain);\n \t      *pprev_reload = chain;\n \t      pprev_reload = &chain->next_need_reload;\n-\n-\t      calculate_needs (chain);\n \t    }\n \t}\n     }\n   *pprev_reload = 0;\n }\n+\f\n+/* Comparison function for qsort to decide which of two reloads\n+   should be handled first.  *P1 and *P2 are the reload numbers.  */\n \n-/* Compute the most additional registers needed by one instruction,\n-   given by CHAIN.  Collect information separately for each class of regs.\n-\n-   To compute the number of reload registers of each class needed for an\n-   insn, we must simulate what choose_reload_regs can do.  We do this by\n-   splitting an insn into an \"input\" and an \"output\" part.  RELOAD_OTHER\n-   reloads are used in both.  The input part uses those reloads,\n-   RELOAD_FOR_INPUT reloads, which must be live over the entire input section\n-   of reloads, and the maximum of all the RELOAD_FOR_INPUT_ADDRESS and\n-   RELOAD_FOR_OPERAND_ADDRESS reloads, which conflict with the inputs.\n-\n-   The registers needed for output are RELOAD_OTHER and RELOAD_FOR_OUTPUT,\n-   which are live for the entire output portion, and the maximum of all the\n-   RELOAD_FOR_OUTPUT_ADDRESS reloads for each operand.\n-\n-   The total number of registers needed is the maximum of the\n-   inputs and outputs.  */\n-\n-static void\n-calculate_needs (chain)\n-     struct insn_chain *chain;\n+static int\n+reload_reg_class_lower (r1p, r2p)\n+     const PTR r1p;\n+     const PTR r2p;\n {\n-  int i;\n-\n-  /* Each `struct needs' corresponds to one RELOAD_... type.  */\n-  struct {\n-    struct needs other;\n-    struct needs input;\n-    struct needs output;\n-    struct needs insn;\n-    struct needs other_addr;\n-    struct needs op_addr;\n-    struct needs op_addr_reload;\n-    struct needs in_addr[MAX_RECOG_OPERANDS];\n-    struct needs in_addr_addr[MAX_RECOG_OPERANDS];\n-    struct needs out_addr[MAX_RECOG_OPERANDS];\n-    struct needs out_addr_addr[MAX_RECOG_OPERANDS];\n-  } insn_needs;\n-\n-  bzero ((char *) chain->group_size, sizeof chain->group_size);\n-  for (i = 0; i < N_REG_CLASSES; i++)\n-    chain->group_mode[i] = VOIDmode;\n-  bzero ((char *) &insn_needs, sizeof insn_needs);\n-\n-  /* Count each reload once in every class\n-     containing the reload's own class.  */\n-\n-  for (i = 0; i < n_reloads; i++)\n-    {\n-      register enum reg_class *p;\n-      enum reg_class class = rld[i].class;\n-      int size;\n-      enum machine_mode mode;\n-      struct needs *this_needs;\n-\n-      /* Don't count the dummy reloads, for which one of the\n-\t regs mentioned in the insn can be used for reloading.\n-\t Don't count optional reloads.\n-\t Don't count reloads that got combined with others.  */\n-      if (rld[i].reg_rtx != 0\n-\t  || rld[i].optional != 0\n-\t  || (rld[i].out == 0 && rld[i].in == 0\n-\t      && ! rld[i].secondary_p))\n-\tcontinue;\n-\n-      mode = rld[i].mode;\n-      size = rld[i].nregs;\n+  register int r1 = *(short *)r1p, r2 = *(short *)r2p;\n+  register int t;\n \n-      /* Decide which time-of-use to count this reload for.  */\n-      switch (rld[i].when_needed)\n-\t{\n-\tcase RELOAD_OTHER:\n-\t  this_needs = &insn_needs.other;\n-\t  break;\n-\tcase RELOAD_FOR_INPUT:\n-\t  this_needs = &insn_needs.input;\n-\t  break;\n-\tcase RELOAD_FOR_OUTPUT:\n-\t  this_needs = &insn_needs.output;\n-\t  break;\n-\tcase RELOAD_FOR_INSN:\n-\t  this_needs = &insn_needs.insn;\n-\t  break;\n-\tcase RELOAD_FOR_OTHER_ADDRESS:\n-\t  this_needs = &insn_needs.other_addr;\n-\t  break;\n-\tcase RELOAD_FOR_INPUT_ADDRESS:\n-\t  this_needs = &insn_needs.in_addr[rld[i].opnum];\n-\t  break;\n-\tcase RELOAD_FOR_INPADDR_ADDRESS:\n-\t  this_needs = &insn_needs.in_addr_addr[rld[i].opnum];\n-\t  break;\n-\tcase RELOAD_FOR_OUTPUT_ADDRESS:\n-\t  this_needs = &insn_needs.out_addr[rld[i].opnum];\n-\t  break;\n-\tcase RELOAD_FOR_OUTADDR_ADDRESS:\n-\t  this_needs = &insn_needs.out_addr_addr[rld[i].opnum];\n-\t  break;\n-\tcase RELOAD_FOR_OPERAND_ADDRESS:\n-\t  this_needs = &insn_needs.op_addr;\n-\t  break;\n-\tcase RELOAD_FOR_OPADDR_ADDR:\n-\t  this_needs = &insn_needs.op_addr_reload;\n-\t  break;\n-\tdefault:\n-\t  abort();\n-\t}\n+  /* Consider required reloads before optional ones.  */\n+  t = rld[r1].optional - rld[r2].optional;\n+  if (t != 0)\n+    return t;\n \n-      if (size > 1)\n-\t{\n-\t  enum machine_mode other_mode, allocate_mode;\n-\n-\t  /* Count number of groups needed separately from\n-\t     number of individual regs needed.  */\n-\t  this_needs->groups[(int) class]++;\n-\t  p = reg_class_superclasses[(int) class];\n-\t  while (*p != LIM_REG_CLASSES)\n-\t    this_needs->groups[(int) *p++]++;\n-\n-\t  /* Record size and mode of a group of this class.  */\n-\t  /* If more than one size group is needed,\n-\t     make all groups the largest needed size.  */\n-\t  if (chain->group_size[(int) class] < size)\n-\t    {\n-\t      other_mode = chain->group_mode[(int) class];\n-\t      allocate_mode = mode;\n+  /* Count all solitary classes before non-solitary ones.  */\n+  t = ((reg_class_size[(int) rld[r2].class] == 1)\n+       - (reg_class_size[(int) rld[r1].class] == 1));\n+  if (t != 0)\n+    return t;\n \n-\t      chain->group_size[(int) class] = size;\n-\t      chain->group_mode[(int) class] = mode;\n-\t    }\n-\t  else\n-\t    {\n-\t      other_mode = mode;\n-\t      allocate_mode = chain->group_mode[(int) class];\n-\t    }\n+  /* Aside from solitaires, consider all multi-reg groups first.  */\n+  t = rld[r2].nregs - rld[r1].nregs;\n+  if (t != 0)\n+    return t;\n \n-\t  /* Crash if two dissimilar machine modes both need\n-\t     groups of consecutive regs of the same class.  */\n+  /* Consider reloads in order of increasing reg-class number.  */\n+  t = (int) rld[r1].class - (int) rld[r2].class;\n+  if (t != 0)\n+    return t;\n \n-\t  if (other_mode != VOIDmode && other_mode != allocate_mode\n-\t      && ! modes_equiv_for_class_p (allocate_mode,\n-\t\t\t\t\t    other_mode, class))\n-\t    fatal_insn (\"Two dissimilar machine modes both need groups of consecutive regs of the same class\",\n-\t\t\tchain->insn);\n-\t}\n-      else if (size == 1)\n-\t{\n-\t  this_needs->regs[(unsigned char)rld[i].nongroup][(int) class] += 1;\n-\t  p = reg_class_superclasses[(int) class];\n-\t  while (*p != LIM_REG_CLASSES)\n-\t    this_needs->regs[(unsigned char)rld[i].nongroup][(int) *p++] += 1;\n-\t}\n-      else\n-\tabort ();\n-    }\n+  /* If reloads are equally urgent, sort by reload number,\n+     so that the results of qsort leave nothing to chance.  */\n+  return r1 - r2;\n+}\n+\f\n+/* The cost of spilling each hard reg.  */\n+static int spill_cost[FIRST_PSEUDO_REGISTER];\n \n-  /* All reloads have been counted for this insn;\n-     now merge the various times of use.\n-     This sets insn_needs, etc., to the maximum total number\n-     of registers needed at any point in this insn.  */\n+/* When spilling multiple hard registers, we use SPILL_COST for the first\n+   spilled hard reg and SPILL_ADD_COST for subsequent regs.  SPILL_ADD_COST\n+   only the first hard reg for a multi-reg pseudo.  */\n+static int spill_add_cost[FIRST_PSEUDO_REGISTER];\n \n-  for (i = 0; i < N_REG_CLASSES; i++)\n-    {\n-      int j, in_max, out_max;\n+/* Update the spill cost arrays, considering that pseudo REG is live.  */\n+static void\n+count_pseudo (reg)\n+     int reg;\n+{\n+  int n_refs = REG_N_REFS (reg);\n+  int r = reg_renumber[reg];\n+  int nregs;\n \n-      /* Compute normal and nongroup needs.  */\n-      for (j = 0; j <= 1; j++)\n-\t{\n-\t  int k;\n-\t  for (in_max = 0, out_max = 0, k = 0; k < reload_n_operands; k++)\n-\t    {\n-\t      in_max = MAX (in_max,\n-\t\t\t    (insn_needs.in_addr[k].regs[j][i]\n-\t\t\t     + insn_needs.in_addr_addr[k].regs[j][i]));\n-\t      out_max = MAX (out_max, insn_needs.out_addr[k].regs[j][i]);\n-\t      out_max = MAX (out_max,\n-\t\t\t     insn_needs.out_addr_addr[k].regs[j][i]);\n-\t    }\n+  if (REGNO_REG_SET_P (&pseudos_counted, reg)\n+      || REGNO_REG_SET_P (&spilled_pseudos, reg))\n+    return;\n \n-\t  /* RELOAD_FOR_INSN reloads conflict with inputs, outputs,\n-\t     and operand addresses but not things used to reload\n-\t     them.  Similarly, RELOAD_FOR_OPERAND_ADDRESS reloads\n-\t     don't conflict with things needed to reload inputs or\n-\t     outputs.  */\n+  SET_REGNO_REG_SET (&pseudos_counted, reg);\n \n-\t  in_max = MAX (MAX (insn_needs.op_addr.regs[j][i],\n-\t\t\t     insn_needs.op_addr_reload.regs[j][i]),\n-\t\t\tin_max);\n+  if (r < 0)\n+    abort ();\n+  \n+  spill_add_cost[r] += n_refs;\n \n-\t  out_max = MAX (out_max, insn_needs.insn.regs[j][i]);\n+  nregs = HARD_REGNO_NREGS (r, PSEUDO_REGNO_MODE (reg));\n+  while (nregs-- > 0)\n+    spill_cost[r + nregs] += n_refs;\n+}\n \n-\t  insn_needs.input.regs[j][i]\n-\t    = MAX (insn_needs.input.regs[j][i]\n-\t\t   + insn_needs.op_addr.regs[j][i]\n-\t\t   + insn_needs.insn.regs[j][i],\n-\t\t   in_max + insn_needs.input.regs[j][i]);\n+/* Calculate the SPILL_COST and SPILL_ADD_COST arrays and determine the\n+   contents of BAD_SPILL_REGS for the insn described by CHAIN.  */\n+static void\n+order_regs_for_reload (chain)\n+     struct insn_chain *chain;\n+{\n+  register int i, j;\n \n-\t  insn_needs.output.regs[j][i] += out_max;\n-\t  insn_needs.other.regs[j][i]\n-\t    += MAX (MAX (insn_needs.input.regs[j][i],\n-\t\t\t insn_needs.output.regs[j][i]),\n-\t\t    insn_needs.other_addr.regs[j][i]);\n+  COPY_HARD_REG_SET (bad_spill_regs, bad_spill_regs_global);\n \n-\t}\n+  memset (spill_cost, 0, sizeof spill_cost);\n+  memset (spill_add_cost, 0, sizeof spill_add_cost);\n \n-      /* Now compute group needs.  */\n-      for (in_max = 0, out_max = 0, j = 0; j < reload_n_operands; j++)\n-\t{\n-\t  in_max = MAX (in_max, insn_needs.in_addr[j].groups[i]);\n-\t  in_max = MAX (in_max, insn_needs.in_addr_addr[j].groups[i]);\n-\t  out_max = MAX (out_max, insn_needs.out_addr[j].groups[i]);\n-\t  out_max = MAX (out_max, insn_needs.out_addr_addr[j].groups[i]);\n-\t}\n+  /* Count number of uses of each hard reg by pseudo regs allocated to it\n+     and then order them by decreasing use.  */\n \n-      in_max = MAX (MAX (insn_needs.op_addr.groups[i],\n-\t\t\t insn_needs.op_addr_reload.groups[i]),\n-\t\t    in_max);\n-      out_max = MAX (out_max, insn_needs.insn.groups[i]);\n-\n-      insn_needs.input.groups[i]\n-\t= MAX (insn_needs.input.groups[i]\n-\t       + insn_needs.op_addr.groups[i]\n-\t       + insn_needs.insn.groups[i],\n-\t       in_max + insn_needs.input.groups[i]);\n-\n-      insn_needs.output.groups[i] += out_max;\n-      insn_needs.other.groups[i]\n-\t+= MAX (MAX (insn_needs.input.groups[i],\n-\t\t     insn_needs.output.groups[i]),\n-\t\tinsn_needs.other_addr.groups[i]);\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      /* Test the various reasons why we can't use a register for\n+\t spilling in this insn.  */\n+      if (fixed_regs[i]\n+\t  || REGNO_REG_SET_P (chain->live_before, i)\n+\t  || REGNO_REG_SET_P (chain->live_after, i))\n+\tSET_HARD_REG_BIT (bad_spill_regs, i);\n     }\n+  /* Now find out which pseudos are allocated to it, and update\n+     hard_reg_n_uses.  */\n+  CLEAR_REG_SET (&pseudos_counted);\n \n-  /* Record the needs for later.  */\n-  chain->need = insn_needs.other;\n+  EXECUTE_IF_SET_IN_REG_SET\n+    (chain->live_before, FIRST_PSEUDO_REGISTER, j,\n+     {\n+       count_pseudo (j);\n+     });\n+  EXECUTE_IF_SET_IN_REG_SET\n+    (chain->live_after, FIRST_PSEUDO_REGISTER, j,\n+     {\n+       count_pseudo (j);\n+     });\n+  CLEAR_REG_SET (&pseudos_counted);\n }\n \f\n-/* Find a group of exactly 2 registers.\n-\n-   First try to fill out the group by spilling a single register which\n-   would allow completion of the group.\n-\n-   Then try to create a new group from a pair of registers, neither of\n-   which are explicitly used.\n+/* Vector of reload-numbers showing the order in which the reloads should\n+   be processed.  */\n+static short reload_order[MAX_RELOADS];\n \n-   Then try to create a group from any pair of registers.  */\n+/* This is used to keep track of the spill regs used in one insn.  */\n+static HARD_REG_SET used_spill_regs_local;\n \n+/* We decided to spill hard register SPILLED, which has a size of\n+   SPILLED_NREGS.  Determine how pseudo REG, which is live during the insn,\n+   is affected.  We will add it to SPILLED_PSEUDOS if necessary, and we will\n+   update SPILL_COST/SPILL_ADD_COST.  */\n static void\n-find_tworeg_group (chain, class, dumpfile)\n-     struct insn_chain *chain;\n-     int class;\n-     FILE *dumpfile;\n+count_spilled_pseudo (spilled, spilled_nregs, reg)\n+     int spilled, spilled_nregs, reg;\n {\n-  int i;\n-  /* First, look for a register that will complete a group.  */\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    {\n-      int j, other;\n-\n-      j = potential_reload_regs[i];\n-      if (j >= 0 && ! TEST_HARD_REG_BIT (bad_spill_regs, j)\n-\t  && ((j > 0 && (other = j - 1, spill_reg_order[other] >= 0)\n-\t       && TEST_HARD_REG_BIT (reg_class_contents[class], j)\n-\t       && TEST_HARD_REG_BIT (reg_class_contents[class], other)\n-\t       && HARD_REGNO_MODE_OK (other, chain->group_mode[class])\n-\t       && ! TEST_HARD_REG_BIT (chain->counted_for_nongroups, other)\n-\t       /* We don't want one part of another group.\n-\t\t  We could get \"two groups\" that overlap!  */\n-\t       && ! TEST_HARD_REG_BIT (chain->counted_for_groups, other))\n-\t      || (j < FIRST_PSEUDO_REGISTER - 1\n-\t\t  && (other = j + 1, spill_reg_order[other] >= 0)\n-\t\t  && TEST_HARD_REG_BIT (reg_class_contents[class], j)\n-\t\t  && TEST_HARD_REG_BIT (reg_class_contents[class], other)\n-\t\t  && HARD_REGNO_MODE_OK (j, chain->group_mode[class])\n-\t\t  && ! TEST_HARD_REG_BIT (chain->counted_for_nongroups, other)\n-\t\t  && ! TEST_HARD_REG_BIT (chain->counted_for_groups, other))))\n-\t{\n-\t  register enum reg_class *p;\n-\n-\t  /* We have found one that will complete a group,\n-\t     so count off one group as provided.  */\n-\t  chain->need.groups[class]--;\n-\t  p = reg_class_superclasses[class];\n-\t  while (*p != LIM_REG_CLASSES)\n-\t    {\n-\t      if (chain->group_size [(int) *p] <= chain->group_size [class])\n-\t\tchain->need.groups[(int) *p]--;\n-\t      p++;\n-\t    }\n+  int r = reg_renumber[reg];\n+  int nregs = HARD_REGNO_NREGS (r, PSEUDO_REGNO_MODE (reg));\n \n-\t  /* Indicate both these regs are part of a group.  */\n-\t  SET_HARD_REG_BIT (chain->counted_for_groups, j);\n-\t  SET_HARD_REG_BIT (chain->counted_for_groups, other);\n-\t  break;\n-\t}\n-    }\n-  /* We can't complete a group, so start one.  */\n-  if (i == FIRST_PSEUDO_REGISTER)\n-    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-      {\n-\tint j, k;\n-\tj = potential_reload_regs[i];\n-\t/* Verify that J+1 is a potential reload reg.  */\n-\tfor (k = 0; k < FIRST_PSEUDO_REGISTER; k++)\n-\t  if (potential_reload_regs[k] == j + 1)\n-\t    break;\n-\tif (j >= 0 && j + 1 < FIRST_PSEUDO_REGISTER\n-\t    && k < FIRST_PSEUDO_REGISTER\n-\t    && spill_reg_order[j] < 0 && spill_reg_order[j + 1] < 0\n-\t    && TEST_HARD_REG_BIT (reg_class_contents[class], j)\n-\t    && TEST_HARD_REG_BIT (reg_class_contents[class], j + 1)\n-\t    && HARD_REGNO_MODE_OK (j, chain->group_mode[class])\n-\t    && ! TEST_HARD_REG_BIT (chain->counted_for_nongroups, j + 1)\n-\t    && ! TEST_HARD_REG_BIT (bad_spill_regs, j + 1))\n-\t  break;\n-      }\n+  if (REGNO_REG_SET_P (&spilled_pseudos, reg)\n+      || spilled + spilled_nregs <= r || r + nregs <= spilled)\n+    return;\n \n-  /* I should be the index in potential_reload_regs\n-     of the new reload reg we have found.  */\n+  SET_REGNO_REG_SET (&spilled_pseudos, reg);\n \n-  new_spill_reg (chain, i, class, 0, dumpfile);\n+  spill_add_cost[r] -= REG_N_REFS (reg);\n+  while (nregs-- > 0)\n+    spill_cost[r + nregs] -= REG_N_REFS (reg);\n }\n \n-/* Find a group of more than 2 registers.\n-   Look for a sufficient sequence of unspilled registers, and spill them all\n-   at once.  */\n+/* Find reload register to use for reload number ORDER.  */\n \n-static void\n-find_group (chain, class, dumpfile)\n+static int\n+find_reg (chain, order, dumpfile)\n      struct insn_chain *chain;\n-     int class;\n+     int order;\n      FILE *dumpfile;\n {\n-  int i;\n+  int rnum = reload_order[order];\n+  struct reload *rl = rld + rnum;\n+  int best_cost = INT_MAX;\n+  int best_reg = -1;\n+  int i, j;\n+  HARD_REG_SET not_usable;\n+  HARD_REG_SET used_by_other_reload;\n \n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+  COPY_HARD_REG_SET (not_usable, bad_spill_regs);\n+  IOR_HARD_REG_SET (not_usable, bad_spill_regs_global);\n+  IOR_COMPL_HARD_REG_SET (not_usable, reg_class_contents[rl->class]);\n+\n+  CLEAR_HARD_REG_SET (used_by_other_reload);\n+  for (i = 0; i < order; i++)\n     {\n-      int j = potential_reload_regs[i];\n+      int other = reload_order[i];\n+      if (rld[other].regno >= 0 && reloads_conflict (other, rnum))\n+\tfor (j = 0; j < rld[other].nregs; j++)\n+\t  SET_HARD_REG_BIT (used_by_other_reload, rld[other].regno + j);\n+    }\n \n-      if (j >= 0\n-\t  && j + chain->group_size[class] <= FIRST_PSEUDO_REGISTER\n-\t  && HARD_REGNO_MODE_OK (j, chain->group_mode[class]))\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      int regno = i;\n+      if (! TEST_HARD_REG_BIT (not_usable, regno)\n+\t  && ! TEST_HARD_REG_BIT (used_by_other_reload, regno)\n+\t  && HARD_REGNO_MODE_OK (regno, rl->mode))\n \t{\n-\t  int k;\n-\t  /* Check each reg in the sequence.  */\n-\t  for (k = 0; k < chain->group_size[class]; k++)\n-\t    if (! (spill_reg_order[j + k] < 0\n-\t\t   && ! TEST_HARD_REG_BIT (bad_spill_regs, j + k)\n-\t\t   && TEST_HARD_REG_BIT (reg_class_contents[class], j + k)))\n-\t      break;\n-\t  /* We got a full sequence, so spill them all.  */\n-\t  if (k == chain->group_size[class])\n-\t    {\n-\t      register enum reg_class *p;\n-\t      for (k = 0; k < chain->group_size[class]; k++)\n-\t\t{\n-\t\t  int idx;\n-\t\t  SET_HARD_REG_BIT (chain->counted_for_groups, j + k);\n-\t\t  for (idx = 0; idx < FIRST_PSEUDO_REGISTER; idx++)\n-\t\t    if (potential_reload_regs[idx] == j + k)\n-\t\t      break;\n-\t\t  new_spill_reg (chain, idx, class, 0, dumpfile);\n-\t\t}\n+\t  int this_cost = spill_cost[regno];\n+\t  int ok = 1;\n+\t  int this_nregs = HARD_REGNO_NREGS (regno, rl->mode);\n \n-\t      /* We have found one that will complete a group,\n-\t\t so count off one group as provided.  */\n-\t      chain->need.groups[class]--;\n-\t      p = reg_class_superclasses[class];\n-\t      while (*p != LIM_REG_CLASSES)\n-\t\t{\n-\t\t  if (chain->group_size [(int) *p]\n-\t\t      <= chain->group_size [class])\n-\t\t    chain->need.groups[(int) *p]--;\n-\t\t  p++;\n-\t\t}\n-\t      return;\n+\t  for (j = 1; j < this_nregs; j++)\n+\t    {\n+\t      this_cost += spill_add_cost[regno + j];\n+\t      if ((TEST_HARD_REG_BIT (not_usable, regno + j))\n+\t\t  || TEST_HARD_REG_BIT (used_by_other_reload, regno + j))\n+\t\tok = 0;\n+\t    }\n+\t  if (! ok)\n+\t    continue;\n+\t  if (rl->in && GET_CODE (rl->in) == REG && REGNO (rl->in) == regno)\n+\t    this_cost--;\n+\t  if (rl->out && GET_CODE (rl->out) == REG && REGNO (rl->out) == regno)\n+\t    this_cost--;\n+\t  if (this_cost < best_cost\n+\t      /* Among registers with equal cost, prefer caller-saved ones, or\n+\t\t use REG_ALLOC_ORDER if it is defined.  */\n+\t      || (this_cost == best_cost\n+#ifdef REG_ALLOC_ORDER\n+\t\t  && (inv_reg_alloc_order[regno]\n+\t\t      < inv_reg_alloc_order[best_reg])\n+#else\n+\t\t  && call_used_regs[regno]\n+\t\t  && ! call_used_regs[best_reg]\n+#endif\n+\t\t  ))\n+\t    {\n+\t      best_reg = regno;\n+\t      best_cost = this_cost;\n \t    }\n \t}\n     }\n-  /* There are no groups left.  */\n-  spill_failure (chain->insn);\n-  failure = 1;\n-}\n+  if (best_reg == -1)\n+    return 0;\n+  if (dumpfile)\n+    fprintf (dumpfile, \"Using reg %d for reload %d\\n\", best_reg, rnum);\n+  rl->nregs = HARD_REGNO_NREGS (best_reg, rl->mode);\n+  rl->regno = best_reg;\n \n-/* If pseudo REG conflicts with one of our reload registers, mark it as\n-   spilled.  */\n-static void\n-maybe_mark_pseudo_spilled (reg)\n-     int reg;\n-{\n-  int i;\n-  int r = reg_renumber[reg];\n-  int nregs;\n+  EXECUTE_IF_SET_IN_REG_SET\n+    (chain->live_before, FIRST_PSEUDO_REGISTER, j,\n+     {\n+       count_spilled_pseudo (best_reg, rl->nregs, j);\n+     });\n+  EXECUTE_IF_SET_IN_REG_SET\n+    (chain->live_after, FIRST_PSEUDO_REGISTER, j,\n+     {\n+       count_spilled_pseudo (best_reg, rl->nregs, j);\n+     });\n \n-  if (r < 0)\n-    abort ();\n-  nregs = HARD_REGNO_NREGS (r, PSEUDO_REGNO_MODE (reg));\n-  for (i = 0; i < n_spills; i++)\n-    if (r <= spill_regs[i] && r + nregs > spill_regs[i])\n-      {\n-\tSET_REGNO_REG_SET (spilled_pseudos, reg);\n-\treturn;\n-      }\n+  for (i = 0; i < rl->nregs; i++)\n+    {\n+      if (spill_cost[best_reg + i] != 0\n+\t  || spill_add_cost[best_reg + i] != 0)\n+\tabort ();\n+      SET_HARD_REG_BIT (used_spill_regs_local, best_reg + i);\n+    }\n+  return 1;\n }\n \n /* Find more reload regs to satisfy the remaining need of an insn, which\n    is given by CHAIN.\n    Do it by ascending class number, since otherwise a reg\n    might be spilled for a big class and might fail to count\n-   for a smaller class even though it belongs to that class.\n-\n-   Count spilled regs in `spills', and add entries to\n-   `spill_regs' and `spill_reg_order'.\n-\n-   ??? Note there is a problem here.\n-   When there is a need for a group in a high-numbered class,\n-   and also need for non-group regs that come from a lower class,\n-   the non-group regs are chosen first.  If there aren't many regs,\n-   they might leave no room for a group.\n-\n-   This was happening on the 386.  To fix it, we added the code\n-   that calls possible_group_p, so that the lower class won't\n-   break up the last possible group.\n-\n-   Really fixing the problem would require changes above\n-   in counting the regs already spilled, and in choose_reload_regs.\n-   It might be hard to avoid introducing bugs there.  */\n+   for a smaller class even though it belongs to that class.  */\n \n static void\n find_reload_regs (chain, dumpfile)\n      struct insn_chain *chain;\n      FILE *dumpfile;\n {\n-  int i, class;\n-  short *group_needs = chain->need.groups;\n-  short *simple_needs = chain->need.regs[0];\n-  short *nongroup_needs = chain->need.regs[1];\n-\n-  if (dumpfile)\n-    fprintf (dumpfile, \"Spilling for insn %d.\\n\", INSN_UID (chain->insn));\n-\n-  /* Compute the order of preference for hard registers to spill.\n-     Store them by decreasing preference in potential_reload_regs.  */\n-\n-  order_regs_for_reload (chain);\n-\n-  /* So far, no hard regs have been spilled.  */\n-  n_spills = 0;\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    spill_reg_order[i] = -1;\n-\n-  CLEAR_HARD_REG_SET (chain->used_spill_regs);\n-  CLEAR_HARD_REG_SET (chain->counted_for_groups);\n-  CLEAR_HARD_REG_SET (chain->counted_for_nongroups);\n+  int i;\n \n-  for (class = 0; class < N_REG_CLASSES; class++)\n+  /* In order to be certain of getting the registers we need,\n+     we must sort the reloads into order of increasing register class.\n+     Then our grabbing of reload registers will parallel the process\n+     that provided the reload registers.  */\n+  for (i = 0; i < chain->n_reloads; i++)\n     {\n-      /* First get the groups of registers.\n-\t If we got single registers first, we might fragment\n-\t possible groups.  */\n-      while (group_needs[class] > 0)\n+      /* Show whether this reload already has a hard reg.  */\n+      if (chain->rld[i].reg_rtx)\n \t{\n-\t  /* If any single spilled regs happen to form groups,\n-\t     count them now.  Maybe we don't really need\n-\t     to spill another group.  */\n-\t  count_possible_groups (chain, class);\n-\n-\t  if (group_needs[class] <= 0)\n-\t    break;\n-\n-\t  /* Groups of size 2, the only groups used on most machines,\n-\t     are treated specially.  */\n-\t  if (chain->group_size[class] == 2)\n-\t    find_tworeg_group (chain, class, dumpfile);\n-\t  else\n-\t    find_group (chain, class, dumpfile);\n-\t  if (failure)\n-\t    return;\n+\t  int regno = REGNO (chain->rld[i].reg_rtx);\n+\t  chain->rld[i].regno = regno;\n+\t  chain->rld[i].nregs = HARD_REGNO_NREGS (regno, GET_MODE (chain->rld[i].reg_rtx));\n \t}\n+      else\n+\tchain->rld[i].regno = -1;\n+      reload_order[i] = i;\n+    }\n \n-      /* Now similarly satisfy all need for single registers.  */\n-\n-      while (simple_needs[class] > 0 || nongroup_needs[class] > 0)\n-\t{\n-\t  /* If we spilled enough regs, but they weren't counted\n-\t     against the non-group need, see if we can count them now.\n-\t     If so, we can avoid some actual spilling.  */\n-\t  if (simple_needs[class] <= 0 && nongroup_needs[class] > 0)\n-\t    for (i = 0; i < n_spills; i++)\n-\t      {\n-\t\tint regno = spill_regs[i];\n-\t\tif (TEST_HARD_REG_BIT (reg_class_contents[class], regno)\n-\t\t    && !TEST_HARD_REG_BIT (chain->counted_for_groups, regno)\n-\t\t    && !TEST_HARD_REG_BIT (chain->counted_for_nongroups, regno)\n-\t\t    && nongroup_needs[class] > 0)\n-\t\t  {\n-\t\t    register enum reg_class *p;\n+  n_reloads = chain->n_reloads;\n+  memcpy (rld, chain->rld, n_reloads * sizeof (struct reload));\n \n-\t\t    SET_HARD_REG_BIT (chain->counted_for_nongroups, regno);\n-\t\t    nongroup_needs[class]--;\n-\t\t    p = reg_class_superclasses[class];\n-\t\t    while (*p != LIM_REG_CLASSES)\n-\t\t      nongroup_needs[(int) *p++]--;\n-\t\t  }\n-\t      }\n+  CLEAR_HARD_REG_SET (used_spill_regs_local);\n \n-\t  if (simple_needs[class] <= 0 && nongroup_needs[class] <= 0)\n-\t    break;\n+  if (dumpfile)\n+    fprintf (dumpfile, \"Spilling for insn %d.\\n\", INSN_UID (chain->insn));\n \n-\t  /* Consider the potential reload regs that aren't\n-\t     yet in use as reload regs, in order of preference.\n-\t     Find the most preferred one that's in this class.  */\n+  qsort (reload_order, n_reloads, sizeof (short), reload_reg_class_lower);\n \n-\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t    {\n-\t      int regno = potential_reload_regs[i];\n-\t      if (regno >= 0\n-\t\t  && TEST_HARD_REG_BIT (reg_class_contents[class], regno)\n-\t\t  /* If this reg will not be available for groups,\n-\t\t     pick one that does not foreclose possible groups.\n-\t\t     This is a kludge, and not very general,\n-\t\t     but it should be sufficient to make the 386 work,\n-\t\t     and the problem should not occur on machines with\n-\t\t     more registers.  */\n-\t\t  && (nongroup_needs[class] == 0\n-\t\t      || possible_group_p (chain, regno)))\n-\t\tbreak;\n-\t    }\n+  /* Compute the order of preference for hard registers to spill.  */\n \n-\t  /* If we couldn't get a register, try to get one even if we\n-\t     might foreclose possible groups.  This may cause problems\n-\t     later, but that's better than aborting now, since it is\n-\t     possible that we will, in fact, be able to form the needed\n-\t     group even with this allocation.  */\n-\n-\t  if (i >= FIRST_PSEUDO_REGISTER\n-\t      && asm_noperands (chain->insn) < 0)\n-\t    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t      if (potential_reload_regs[i] >= 0\n-\t\t  && TEST_HARD_REG_BIT (reg_class_contents[class],\n-\t\t\t\t\tpotential_reload_regs[i]))\n-\t\tbreak;\n+  order_regs_for_reload (chain);\n \n-\t  /* I should be the index in potential_reload_regs\n-\t     of the new reload reg we have found.  */\n+  for (i = 0; i < n_reloads; i++)\n+    {\n+      int r = reload_order[i];\n \n-\t  new_spill_reg (chain, i, class, 1, dumpfile);\n-\t  if (failure)\n+      /* Ignore reloads that got marked inoperative.  */\n+      if ((rld[r].out != 0 || rld[r].in != 0 || rld[r].secondary_p)\n+\t  && ! rld[r].optional\n+\t  && rld[r].regno == -1)\n+\tif (! find_reg (chain, i, dumpfile))\n+\t  {\n+\t    spill_failure (chain->insn);\n+\t    failure = 1;\n \t    return;\n-\t}\n+\t  }\n     }\n \n-  /* We know which hard regs to use, now mark the pseudos that live in them\n-     as needing to be kicked out.  */\n-  EXECUTE_IF_SET_IN_REG_SET\n-    (chain->live_before, FIRST_PSEUDO_REGISTER, i,\n-     {\n-       maybe_mark_pseudo_spilled (i);\n-     });\n-  EXECUTE_IF_SET_IN_REG_SET\n-    (chain->live_after, FIRST_PSEUDO_REGISTER, i,\n-     {\n-       maybe_mark_pseudo_spilled (i);\n-     });\n+  COPY_HARD_REG_SET (chain->used_spill_regs, used_spill_regs_local);\n+  IOR_HARD_REG_SET (used_spill_regs, used_spill_regs_local);\n \n-  IOR_HARD_REG_SET (used_spill_regs, chain->used_spill_regs);\n+  memcpy (chain->rld, rld, n_reloads * sizeof (struct reload));\n }\n \n-void\n-dump_needs (chain, dumpfile)\n-     struct insn_chain *chain;\n+static void\n+select_reload_regs (dumpfile)\n      FILE *dumpfile;\n {\n-  static const char * const reg_class_names[] = REG_CLASS_NAMES;\n-  int i;\n-  struct needs *n = &chain->need;\n+  struct insn_chain *chain;\n \n-  for (i = 0; i < N_REG_CLASSES; i++)\n-    {\n-      if (n->regs[i][0] > 0)\n-\tfprintf (dumpfile,\n-\t\t \";; Need %d reg%s of class %s.\\n\",\n-\t\t n->regs[i][0], n->regs[i][0] == 1 ? \"\" : \"s\",\n-\t\t reg_class_names[i]);\n-      if (n->regs[i][1] > 0)\n-\tfprintf (dumpfile,\n-\t\t \";; Need %d nongroup reg%s of class %s.\\n\",\n-\t\t n->regs[i][1], n->regs[i][1] == 1 ? \"\" : \"s\",\n-\t\t reg_class_names[i]);\n-      if (n->groups[i] > 0)\n-\tfprintf (dumpfile,\n-\t\t \";; Need %d group%s (%smode) of class %s.\\n\",\n-\t\t n->groups[i], n->groups[i] == 1 ? \"\" : \"s\",\n-\t\t GET_MODE_NAME(chain->group_mode[i]),\n-\t\t reg_class_names[i]);\n-    }\n+  /* Try to satisfy the needs for each insn.  */\n+  for (chain = insns_need_reload; chain != 0;\n+       chain = chain->next_need_reload)\n+    find_reload_regs (chain, dumpfile);\n }\n \f\n /* Delete all insns that were inserted by emit_caller_save_insns during\n@@ -2064,162 +1788,6 @@ delete_caller_save_insns ()\n     }\n }\n \f\n-/* Nonzero if, after spilling reg REGNO for non-groups,\n-   it will still be possible to find a group if we still need one.  */\n-\n-static int\n-possible_group_p (chain, regno)\n-     struct insn_chain *chain;\n-     int regno;\n-{\n-  int i;\n-  int class = (int) NO_REGS;\n-\n-  for (i = 0; i < (int) N_REG_CLASSES; i++)\n-    if (chain->need.groups[i] > 0)\n-      {\n-\tclass = i;\n-\tbreak;\n-      }\n-\n-  if (class == (int) NO_REGS)\n-    return 1;\n-\n-  /* Consider each pair of consecutive registers.  */\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER - 1; i++)\n-    {\n-      /* Ignore pairs that include reg REGNO.  */\n-      if (i == regno || i + 1 == regno)\n-\tcontinue;\n-\n-      /* Ignore pairs that are outside the class that needs the group.\n-\t ??? Here we fail to handle the case where two different classes\n-\t independently need groups.  But this never happens with our\n-\t current machine descriptions.  */\n-      if (! (TEST_HARD_REG_BIT (reg_class_contents[class], i)\n-\t     && TEST_HARD_REG_BIT (reg_class_contents[class], i + 1)))\n-\tcontinue;\n-\n-      /* A pair of consecutive regs we can still spill does the trick.  */\n-      if (spill_reg_order[i] < 0 && spill_reg_order[i + 1] < 0\n-\t  && ! TEST_HARD_REG_BIT (bad_spill_regs, i)\n-\t  && ! TEST_HARD_REG_BIT (bad_spill_regs, i + 1))\n-\treturn 1;\n-\n-      /* A pair of one already spilled and one we can spill does it\n-\t provided the one already spilled is not otherwise reserved.  */\n-      if (spill_reg_order[i] < 0\n-\t  && ! TEST_HARD_REG_BIT (bad_spill_regs, i)\n-\t  && spill_reg_order[i + 1] >= 0\n-\t  && ! TEST_HARD_REG_BIT (chain->counted_for_groups, i + 1)\n-\t  && ! TEST_HARD_REG_BIT (chain->counted_for_nongroups, i + 1))\n-\treturn 1;\n-      if (spill_reg_order[i + 1] < 0\n-\t  && ! TEST_HARD_REG_BIT (bad_spill_regs, i + 1)\n-\t  && spill_reg_order[i] >= 0\n-\t  && ! TEST_HARD_REG_BIT (chain->counted_for_groups, i)\n-\t  && ! TEST_HARD_REG_BIT (chain->counted_for_nongroups, i))\n-\treturn 1;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Count any groups of CLASS that can be formed from the registers recently\n-   spilled.  */\n-\n-static void\n-count_possible_groups (chain, class)\n-     struct insn_chain *chain;\n-     int class;\n-{\n-  HARD_REG_SET new;\n-  int i, j;\n-\n-  /* Now find all consecutive groups of spilled registers\n-     and mark each group off against the need for such groups.\n-     But don't count them against ordinary need, yet.  */\n-\n-  if (chain->group_size[class] == 0)\n-    return;\n-\n-  CLEAR_HARD_REG_SET (new);\n-\n-  /* Make a mask of all the regs that are spill regs in class I.  */\n-  for (i = 0; i < n_spills; i++)\n-    {\n-      int regno = spill_regs[i];\n-\n-      if (TEST_HARD_REG_BIT (reg_class_contents[class], regno)\n-\t  && ! TEST_HARD_REG_BIT (chain->counted_for_groups, regno)\n-\t  && ! TEST_HARD_REG_BIT (chain->counted_for_nongroups, regno))\n-\tSET_HARD_REG_BIT (new, regno);\n-    }\n-\n-  /* Find each consecutive group of them.  */\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER && chain->need.groups[class] > 0; i++)\n-    if (TEST_HARD_REG_BIT (new, i)\n-\t&& i + chain->group_size[class] <= FIRST_PSEUDO_REGISTER\n-\t&& HARD_REGNO_MODE_OK (i, chain->group_mode[class]))\n-      {\n-\tfor (j = 1; j < chain->group_size[class]; j++)\n-\t  if (! TEST_HARD_REG_BIT (new, i + j))\n-\t    break;\n-\n-\tif (j == chain->group_size[class])\n-\t  {\n-\t    /* We found a group.  Mark it off against this class's need for\n-\t       groups, and against each superclass too.  */\n-\t    register enum reg_class *p;\n-\n-\t    chain->need.groups[class]--;\n-\t    p = reg_class_superclasses[class];\n-\t    while (*p != LIM_REG_CLASSES)\n-\t      {\n-\t\tif (chain->group_size [(int) *p] <= chain->group_size [class])\n-\t\t  chain->need.groups[(int) *p]--;\n-\t\tp++;\n-\t      }\n-\n-\t    /* Don't count these registers again.  */\n-\t    for (j = 0; j < chain->group_size[class]; j++)\n-\t      SET_HARD_REG_BIT (chain->counted_for_groups, i + j);\n-\t  }\n-\n-\t/* Skip to the last reg in this group.  When i is incremented above,\n-\t   it will then point to the first reg of the next possible group.  */\n-\ti += j - 1;\n-      }\n-}\n-\f\n-/* ALLOCATE_MODE is a register mode that needs to be reloaded.  OTHER_MODE is\n-   another mode that needs to be reloaded for the same register class CLASS.\n-   If any reg in CLASS allows ALLOCATE_MODE but not OTHER_MODE, fail.\n-   ALLOCATE_MODE will never be smaller than OTHER_MODE.\n-\n-   This code used to also fail if any reg in CLASS allows OTHER_MODE but not\n-   ALLOCATE_MODE.  This test is unnecessary, because we will never try to put\n-   something of mode ALLOCATE_MODE into an OTHER_MODE register.  Testing this\n-   causes unnecessary failures on machines requiring alignment of register\n-   groups when the two modes are different sizes, because the larger mode has\n-   more strict alignment rules than the smaller mode.  */\n-\n-static int\n-modes_equiv_for_class_p (allocate_mode, other_mode, class)\n-     enum machine_mode allocate_mode, other_mode;\n-     enum reg_class class;\n-{\n-  register int regno;\n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    {\n-      if (TEST_HARD_REG_BIT (reg_class_contents[(int) class], regno)\n-\t  && HARD_REGNO_MODE_OK (regno, allocate_mode)\n-\t  && ! HARD_REGNO_MODE_OK (regno, other_mode))\n-\treturn 0;\n-    }\n-  return 1;\n-}\n-\f\n /* Handle the failure to find a register to spill.\n    INSN should be one of the insns which needed this particular spill reg.  */\n \n@@ -2232,83 +1800,6 @@ spill_failure (insn)\n   else\n     fatal_insn (\"Unable to find a register to spill.\", insn);\n }\n-\n-/* Add a new register to the tables of available spill-registers.\n-   CHAIN is the insn for which the register will be used; we decrease the\n-   needs of that insn.\n-   I is the index of this register in potential_reload_regs.\n-   CLASS is the regclass whose need is being satisfied.\n-   NONGROUP is 0 if this register is part of a group.\n-   DUMPFILE is the same as the one that `reload' got.  */\n-\n-static void\n-new_spill_reg (chain, i, class, nongroup, dumpfile)\n-     struct insn_chain *chain;\n-     int i;\n-     int class;\n-     int nongroup;\n-     FILE *dumpfile;\n-{\n-  register enum reg_class *p;\n-  int regno = potential_reload_regs[i];\n-\n-  if (i >= FIRST_PSEUDO_REGISTER)\n-    {\n-      spill_failure (chain->insn);\n-      failure = 1;\n-      return;\n-    }\n-\n-  if (TEST_HARD_REG_BIT (bad_spill_regs, regno))\n-    {\n-      static const char * const reg_class_names[] = REG_CLASS_NAMES;\n-\n-      if (asm_noperands (PATTERN (chain->insn)) < 0)\n-\t{\n-\t  /* The error message is still correct - we know only that it wasn't\n-\t     an asm statement that caused the problem, but one of the global\n-\t     registers declared by the users might have screwed us.  */\n-\t  error (\"fixed or forbidden register %d (%s) was spilled for class %s.\",\n-\t\t regno, reg_names[regno], reg_class_names[class]);\n-\t  error (\"This may be due to a compiler bug or to impossible asm\");\n-\t  error (\"statements or clauses.\");\n-\t  fatal_insn (\"This is the instruction:\", chain->insn);\n-\t}\n-      error_for_asm (chain->insn, \"Invalid `asm' statement:\");\n-      error_for_asm (chain->insn,\n-\t\t     \"fixed or forbidden register %d (%s) was spilled for class %s.\",\n-\t\t     regno, reg_names[regno], reg_class_names[class]);\n-      failure = 1;\n-      return;\n-    }\n-\n-  /* Make reg REGNO an additional reload reg.  */\n-\n-  potential_reload_regs[i] = -1;\n-  spill_regs[n_spills] = regno;\n-  spill_reg_order[regno] = n_spills;\n-  if (dumpfile)\n-    fprintf (dumpfile, \"Spilling reg %d.\\n\", regno);\n-  SET_HARD_REG_BIT (chain->used_spill_regs, regno);\n-\n-  /* Clear off the needs we just satisfied.  */\n-\n-  chain->need.regs[0][class]--;\n-  p = reg_class_superclasses[class];\n-  while (*p != LIM_REG_CLASSES)\n-    chain->need.regs[0][(int) *p++]--;\n-\n-  if (nongroup && chain->need.regs[1][class] > 0)\n-    {\n-      SET_HARD_REG_BIT (chain->counted_for_nongroups, regno);\n-      chain->need.regs[1][class]--;\n-      p = reg_class_superclasses[class];\n-      while (*p != LIM_REG_CLASSES)\n-\tchain->need.regs[1][(int) *p++]--;\n-    }\n-\n-  n_spills++;\n-}\n \f\n /* Delete an unneeded INSN and any previous insns who sole purpose is loading\n    data that is dead in INSN.  */\n@@ -3927,7 +3418,7 @@ spill_hard_reg (regno, dumpfile, cant_eliminate)\n \t    + HARD_REGNO_NREGS (reg_renumber[i],\n \t\t\t\tPSEUDO_REGNO_MODE (i))\n \t    > regno))\n-      SET_REGNO_REG_SET (spilled_pseudos, i);\n+      SET_REGNO_REG_SET (&spilled_pseudos, i);\n }\n \n /* I'm getting weird preprocessor errors if I use IOR_HARD_REG_SET\n@@ -3979,7 +3470,7 @@ finish_spills (global, dumpfile)\n       spill_reg_order[i] = -1;\n \n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n-    if (REGNO_REG_SET_P (spilled_pseudos, i))\n+    if (REGNO_REG_SET_P (&spilled_pseudos, i))\n       {\n \t/* Record the current hard register the pseudo is allocated to in\n \t   pseudo_previous_regs so we avoid reallocating it to the same\n@@ -4030,7 +3521,7 @@ finish_spills (global, dumpfile)\n \t    IOR_HARD_REG_SET (forbidden, pseudo_previous_regs[i]);\n \t    retry_global_alloc (i, forbidden);\n \t    if (reg_renumber[i] >= 0)\n-\t      CLEAR_REGNO_REG_SET (spilled_pseudos, i);\n+\t      CLEAR_REGNO_REG_SET (&spilled_pseudos, i);\n \t  }\n     }\n \n@@ -4042,8 +3533,8 @@ finish_spills (global, dumpfile)\n       HARD_REG_SET used_by_pseudos;\n       HARD_REG_SET used_by_pseudos2;\n \n-      AND_COMPL_REG_SET (chain->live_before, spilled_pseudos);\n-      AND_COMPL_REG_SET (chain->live_after, spilled_pseudos);\n+      AND_COMPL_REG_SET (chain->live_before, &spilled_pseudos);\n+      AND_COMPL_REG_SET (chain->live_after, &spilled_pseudos);\n \n       /* Mark any unallocated hard regs as available for spills.  That\n \t makes inheritance work somewhat better.  */\n@@ -4148,146 +3639,6 @@ scan_paradoxical_subregs (x)\n     }\n }\n \f\n-static int\n-hard_reg_use_compare (p1p, p2p)\n-     const PTR p1p;\n-     const PTR p2p;\n-{\n-  const struct hard_reg_n_uses *p1 = (const struct hard_reg_n_uses *)p1p;\n-  const struct hard_reg_n_uses *p2 = (const struct hard_reg_n_uses *)p2p;\n-  int bad1 = TEST_HARD_REG_BIT (bad_spill_regs, p1->regno);\n-  int bad2 = TEST_HARD_REG_BIT (bad_spill_regs, p2->regno);\n-  if (bad1 && bad2)\n-    return p1->regno - p2->regno;\n-  if (bad1)\n-    return 1;\n-  if (bad2)\n-    return -1;\n-  if (p1->uses > p2->uses)\n-    return 1;\n-  if (p1->uses < p2->uses)\n-    return -1;\n-  /* If regs are equally good, sort by regno,\n-     so that the results of qsort leave nothing to chance.  */\n-  return p1->regno - p2->regno;\n-}\n-\n-/* Used for communication between order_regs_for_reload and count_pseudo.\n-   Used to avoid counting one pseudo twice.  */\n-static regset pseudos_counted;\n-\n-/* Update the costs in N_USES, considering that pseudo REG is live.  */\n-static void\n-count_pseudo (n_uses, reg)\n-     struct hard_reg_n_uses *n_uses;\n-     int reg;\n-{\n-  int r = reg_renumber[reg];\n-  int nregs;\n-\n-  if (REGNO_REG_SET_P (pseudos_counted, reg))\n-    return;\n-  SET_REGNO_REG_SET (pseudos_counted, reg);\n-\n-  if (r < 0)\n-    abort ();\n-\n-  nregs = HARD_REGNO_NREGS (r, PSEUDO_REGNO_MODE (reg));\n-  while (nregs-- > 0)\n-    n_uses[r++].uses += REG_N_REFS (reg);\n-}\n-/* Choose the order to consider regs for use as reload registers\n-   based on how much trouble would be caused by spilling one.\n-   Store them in order of decreasing preference in potential_reload_regs.  */\n-\n-static void\n-order_regs_for_reload (chain)\n-     struct insn_chain *chain;\n-{\n-  register int i;\n-  register int o = 0;\n-  struct hard_reg_n_uses hard_reg_n_uses[FIRST_PSEUDO_REGISTER];\n-\n-  pseudos_counted = ALLOCA_REG_SET ();\n-\n-  COPY_HARD_REG_SET (bad_spill_regs, bad_spill_regs_global);\n-\n-  /* Count number of uses of each hard reg by pseudo regs allocated to it\n-     and then order them by decreasing use.  */\n-\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    {\n-      hard_reg_n_uses[i].regno = i;\n-      hard_reg_n_uses[i].uses = 0;\n-\n-      /* Test the various reasons why we can't use a register for\n-\t spilling in this insn.  */\n-      if (fixed_regs[i]\n-\t  || REGNO_REG_SET_P (chain->live_before, i)\n-\t  || REGNO_REG_SET_P (chain->live_after, i))\n-\tSET_HARD_REG_BIT (bad_spill_regs, i);\n-    }\n-\n-  /* Now compute hard_reg_n_uses.  */\n-  CLEAR_REG_SET (pseudos_counted);\n-\n-  EXECUTE_IF_SET_IN_REG_SET\n-    (chain->live_before, FIRST_PSEUDO_REGISTER, i,\n-     {\n-       count_pseudo (hard_reg_n_uses, i);\n-     });\n-  EXECUTE_IF_SET_IN_REG_SET\n-    (chain->live_after, FIRST_PSEUDO_REGISTER, i,\n-     {\n-       count_pseudo (hard_reg_n_uses, i);\n-     });\n-\n-  FREE_REG_SET (pseudos_counted);\n-\n-  /* Prefer registers not so far used, for use in temporary loading.\n-     Among them, if REG_ALLOC_ORDER is defined, use that order.\n-     Otherwise, prefer registers not preserved by calls.  */\n-\n-#ifdef REG_ALLOC_ORDER\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    {\n-      int regno = reg_alloc_order[i];\n-\n-      if (hard_reg_n_uses[regno].uses == 0\n-\t  && ! TEST_HARD_REG_BIT (bad_spill_regs, regno))\n-\tpotential_reload_regs[o++] = regno;\n-    }\n-#else\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    {\n-      if (hard_reg_n_uses[i].uses == 0 && call_used_regs[i]\n-\t  && ! TEST_HARD_REG_BIT (bad_spill_regs, i))\n-\tpotential_reload_regs[o++] = i;\n-    }\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    {\n-      if (hard_reg_n_uses[i].uses == 0 && ! call_used_regs[i]\n-\t  && ! TEST_HARD_REG_BIT (bad_spill_regs, i))\n-\tpotential_reload_regs[o++] = i;\n-    }\n-#endif\n-\n-  qsort (hard_reg_n_uses, FIRST_PSEUDO_REGISTER,\n-\t sizeof hard_reg_n_uses[0], hard_reg_use_compare);\n-\n-  /* Now add the regs that are already used,\n-     preferring those used less often.  The fixed and otherwise forbidden\n-     registers will be at the end of this list.  */\n-\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (hard_reg_n_uses[i].uses != 0\n-\t&& ! TEST_HARD_REG_BIT (bad_spill_regs, hard_reg_n_uses[i].regno))\n-      potential_reload_regs[o++] = hard_reg_n_uses[i].regno;\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (TEST_HARD_REG_BIT (bad_spill_regs, hard_reg_n_uses[i].regno))\n-      potential_reload_regs[o++] = hard_reg_n_uses[i].regno;\n-}\n-\f\n /* Reload pseudo-registers into hard regs around each insn as needed.\n    Additional register load insns are output before the insn that needs it\n    and perhaps store insns after insns that modify the reloaded pseudo reg.\n@@ -4626,43 +3977,6 @@ forget_old_reloads_1 (x, ignored, data)\n       reg_last_reload_reg[regno + nr] = 0;\n }\n \f\n-/* Comparison function for qsort to decide which of two reloads\n-   should be handled first.  *P1 and *P2 are the reload numbers.  */\n-\n-static int\n-reload_reg_class_lower (r1p, r2p)\n-     const PTR r1p;\n-     const PTR r2p;\n-{\n-  register int r1 = *(const short *)r1p, r2 = *(const short *)r2p;\n-  register int t;\n-\n-  /* Consider required reloads before optional ones.  */\n-  t = rld[r1].optional - rld[r2].optional;\n-  if (t != 0)\n-    return t;\n-\n-  /* Count all solitary classes before non-solitary ones.  */\n-  t = ((reg_class_size[(int) rld[r2].class] == 1)\n-       - (reg_class_size[(int) rld[r1].class] == 1));\n-  if (t != 0)\n-    return t;\n-\n-  /* Aside from solitaires, consider all multi-reg groups first.  */\n-  t = rld[r2].nregs - rld[r1].nregs;\n-  if (t != 0)\n-    return t;\n-\n-  /* Consider reloads in order of increasing reg-class number.  */\n-  t = (int) rld[r1].class - (int) rld[r2].class;\n-  if (t != 0)\n-    return t;\n-\n-  /* If reloads are equally urgent, sort by reload number,\n-     so that the results of qsort leave nothing to chance.  */\n-  return r1 - r2;\n-}\n-\f\n /* The following HARD_REG_SETs indicate when each hard register is\n    used for a reload of various parts of the current insn.  */\n \n@@ -5240,10 +4554,6 @@ reloads_conflict (r1, r2)\n     }\n }\n \f\n-/* Vector of reload-numbers showing the order in which the reloads should\n-   be processed.  */\n-short reload_order[MAX_RELOADS];\n-\n /* Indexed by reload number, 1 if incoming value\n    inherited from previous insns.  */\n char reload_inherited[MAX_RELOADS];\n@@ -5575,15 +4885,14 @@ set_reload_reg (i, r)\n \n    Set rld[R].reg_rtx to the register allocated.\n \n-   If NOERROR is nonzero, we return 1 if successful,\n-   or 0 if we couldn't find a spill reg and we didn't change anything.  */\n+   We return 1 if successful, or 0 if we couldn't find a spill reg and\n+   we didn't change anything.  */\n \n static int\n-allocate_reload_reg (chain, r, last_reload, noerror)\n+allocate_reload_reg (chain, r, last_reload)\n      struct insn_chain *chain;\n      int r;\n      int last_reload;\n-     int noerror;\n {\n   rtx insn = chain->insn;\n   int i, pass, count;\n@@ -5620,17 +4929,9 @@ allocate_reload_reg (chain, r, last_reload, noerror)\n       /* I is the index in spill_regs.\n \t We advance it round-robin between insns to use all spill regs\n \t equally, so that inherited reloads have a chance\n-\t of leapfrogging each other.  Don't do this, however, when we have\n-\t group needs and failure would be fatal; if we only have a relatively\n-\t small number of spill registers, and more than one of them has\n-\t group needs, then by starting in the middle, we may end up\n-\t allocating the first one in such a way that we are not left with\n-\t sufficient groups to handle the rest.  */\n-\n-      if (noerror || ! force_group)\n-\ti = last_spill_reg;\n-      else\n-\ti = -1;\n+\t of leapfrogging each other.  */\n+\n+      i = last_spill_reg;\n \n       for (count = 0; count < n_spills; count++)\n \t{\n@@ -5679,22 +4980,17 @@ allocate_reload_reg (chain, r, last_reload, noerror)\n \t\t  break;\n \t\t}\n \t      /* Otherwise check that as many consecutive regs as we need\n-\t\t are available here.\n-\t\t Also, don't use for a group registers that are\n-\t\t needed for nongroups.  */\n-\t      if (! TEST_HARD_REG_BIT (chain->counted_for_nongroups, regnum))\n-\t\twhile (nr > 1)\n-\t\t  {\n-\t\t    int regno = regnum + nr - 1;\n-\t\t    if (!(TEST_HARD_REG_BIT (reg_class_contents[class], regno)\n-\t\t\t  && spill_reg_order[regno] >= 0\n-\t\t\t  && reload_reg_free_p (regno, rld[r].opnum,\n-\t\t\t\t\t\trld[r].when_needed)\n-\t\t\t  && ! TEST_HARD_REG_BIT (chain->counted_for_nongroups,\n-\t\t\t\t\t\t  regno)))\n-\t\t      break;\n-\t\t    nr--;\n-\t\t  }\n+\t\t are available here.  */\n+\t      while (nr > 1)\n+\t\t{\n+\t\t  int regno = regnum + nr - 1;\n+\t\t  if (!(TEST_HARD_REG_BIT (reg_class_contents[class], regno)\n+\t\t\t&& spill_reg_order[regno] >= 0\n+\t\t\t&& reload_reg_free_p (regno, rld[r].opnum,\n+\t\t\t\t\t      rld[r].when_needed)))\n+\t\t    break;\n+\t\t  nr--;\n+\t\t}\n \t      if (nr == 1)\n \t\tbreak;\n \t    }\n@@ -5704,26 +5000,15 @@ allocate_reload_reg (chain, r, last_reload, noerror)\n       if (count < n_spills)\n \tbreak;\n     }\n-\n+    \n   /* We should have found a spill register by now.  */\n-  if (count == n_spills)\n-    {\n-      if (noerror)\n-\treturn 0;\n-      goto failure;\n-    }\n-\n-  if (set_reload_reg (i, r))\n-    return 1;\n-\n-  /* The reg is not OK.  */\n-  if (noerror)\n+  if (count >= n_spills)\n     return 0;\n \n- failure:\n-  failed_reload (insn, r);\n+  /* I is the index in SPILL_REG_RTX of the reload register we are to\n+     allocate.  Get an rtx for it and find its register number.  */\n \n-  return 1;\n+  return set_reload_reg (i, r);\n }\n \f\n /* Initialize all the tables needed to allocate reload registers.\n@@ -5797,8 +5082,7 @@ choose_reload_regs (chain)\n   register int i, j;\n   int max_group_size = 1;\n   enum reg_class group_class = NO_REGS;\n-  int inheritance;\n-  int pass;\n+  int pass, win, inheritance;\n \n   rtx save_reload_reg_rtx[MAX_RELOADS];\n \n@@ -5833,7 +5117,7 @@ choose_reload_regs (chain)\n      Using inheritance when not optimizing leads to paradoxes\n      with fp on the 68k: fp numbers (not NaNs) fail to be equal to themselves\n      because one side of the comparison might be inherited.  */\n-\n+  win = 0;\n   for (inheritance = optimize > 0; inheritance >= 0; inheritance--)\n     {\n       choose_reload_regs_init (chain, save_reload_reg_rtx);\n@@ -5891,7 +5175,7 @@ choose_reload_regs (chain)\n \t\t   || rld[reload_order[i]].secondary_p)\n \t\t  && ! rld[reload_order[i]].optional\n \t\t  && rld[reload_order[i]].reg_rtx == 0)\n-\t\tallocate_reload_reg (chain, reload_order[i], 0, inheritance);\n+\t\tallocate_reload_reg (chain, reload_order[i], 0);\n #endif\n \n \t  /* First see if this pseudo is already available as reloaded\n@@ -6248,7 +5532,7 @@ choose_reload_regs (chain)\n \t  if (i == n_reloads)\n \t    continue;\n \n-\t  allocate_reload_reg (chain, r, j == n_reloads - 1, inheritance);\n+\t  allocate_reload_reg (chain, r, j == n_reloads - 1);\n #endif\n \t}\n \n@@ -6267,17 +5551,44 @@ choose_reload_regs (chain)\n \t  if (rld[r].reg_rtx != 0 || rld[r].optional)\n \t    continue;\n \n-\t  if (! allocate_reload_reg (chain, r, j == n_reloads - 1, inheritance))\n+\t  if (! allocate_reload_reg (chain, r, j == n_reloads - 1))\n \t    break;\n \t}\n \n       /* If that loop got all the way, we have won.  */\n       if (j == n_reloads)\n-\tbreak;\n+\t{\n+\t  win = 1;\n+\t  break;\n+\t}\n \n       /* Loop around and try without any inheritance.  */\n     }\n \n+  if (! win)\n+    {\n+      /* First undo everything done by the failed attempt\n+\t to allocate with inheritance.  */\n+      choose_reload_regs_init (chain, save_reload_reg_rtx);\n+\n+      /* Some sanity tests to verify that the reloads found in the first\n+\t pass are identical to the ones we have now.  */\n+      if (chain->n_reloads != n_reloads)\n+\tabort ();\n+\n+      for (i = 0; i < n_reloads; i++)\n+\t{\n+\t  if (chain->rld[i].regno < 0 || chain->rld[i].reg_rtx != 0)\n+\t    continue;\n+\t  if (chain->rld[i].when_needed != rld[i].when_needed)\n+\t    abort ();\n+\t  for (j = 0; j < n_spills; j++)\n+\t    if (spill_regs[j] == chain->rld[i].regno)\n+\t      if (! set_reload_reg (j, i))\n+\t\tfailed_reload (chain->insn, i);\n+\t}\n+    }\n+\n   /* If we thought we could inherit a reload, because it seemed that\n      nothing else wanted the same reload register earlier in the insn,\n      verify that assumption, now that all reloads have been assigned."}]}