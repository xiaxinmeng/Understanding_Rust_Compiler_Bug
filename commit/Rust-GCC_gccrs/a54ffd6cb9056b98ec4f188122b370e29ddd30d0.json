{"sha": "a54ffd6cb9056b98ec4f188122b370e29ddd30d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTU0ZmZkNmNiOTA1NmI5OGVjNGYxODgxMjJiMzcwZTI5ZGRkMzBkMA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-31T15:39:17Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-31T15:39:17Z"}, "message": "[multiple changes]\n\n2014-01-31  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch4.adb: Minor reformatting.\n\n2014-01-31  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch2.adb: New calling sequence for Is_LHS.\n\t* frontend.adb: Add call to Process_Deferred_References.\n\t* lib-xref.ads, lib-xref.adb (Process_Deferred_References): New.\n\t(Deferred_References): New table.\n\t* sem_ch8.adb (Find_Direct_Name): Make deferred reference table\n\tentries.\n\t(Find_Expanded_Name): Ditto.\n\t* sem_res.adb: New calling sequence for Is_LHS.\n\t* sem_util.ads, sem_util.adb (Is_LHS): New calling sequence.\n\t* sem_warn.adb: Call Process_Deferred_References before issuing\n\twarnings.\n\n2014-01-31  Tristan Gingold  <gingold@adacore.com>\n\n\t* exp_util.adb (Corresponding_Runtime_Package): Restrict the\n\tuse of System_Tasking_Protected_Objects_Single_Entry.\n\t* exp_ch9.adb (Build_Simple_Entry_Call): Remove Mode parameter\n\tof Protected_Single_Entry_Call.\n\t(Expand_N_Timed_Entry_Call): Remove single_entry case.\n\t* exp_disp.adb (Make_Disp_Asynchronous_Select_Body): Remove\n\tsingle_entry case.\n\t(Make_Disp_Timed_Select_Body): Likewise.\n\t* rtsfind.ads (RE_Timed_Protected_Single_Entry_Call): Remove.\n\t* s-tposen.adb (Send_Program_Error, PO_Do_Or_Queue): Remove\n\tSelf_Id parameter.\n\t(Wakeup_Entry_Caller): Remove Self_ID and New_State parameters.\n\t(Wait_For_Completion_With_Timeout): Remove.\n\t(Protected_Single_Entry_Call): Remove Mode parameter\n\t(always Simple_Call).\n\t(Service_Entry): Remove Self_Id constant (not used anymore).\n\t(Timed_Protected_Single_Entry_Call): Remove.\n\t* s-tposen.ads (Timed_Protected_Single_Entry_Call): Remove.\n\t(Protected_Single_Entry_Call): Remove Mode parameter.\n\nFrom-SVN: r207349", "tree": {"sha": "cf41dba58aade03b495fc9aee9e400ce1e93476c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf41dba58aade03b495fc9aee9e400ce1e93476c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a54ffd6cb9056b98ec4f188122b370e29ddd30d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a54ffd6cb9056b98ec4f188122b370e29ddd30d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a54ffd6cb9056b98ec4f188122b370e29ddd30d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/comments", "author": null, "committer": null, "parents": [{"sha": "408249b2e2bc8ddc31d9041c31c3782392b54c3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/408249b2e2bc8ddc31d9041c31c3782392b54c3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/408249b2e2bc8ddc31d9041c31c3782392b54c3f"}], "stats": {"total": 548, "additions": 214, "deletions": 334}, "files": [{"sha": "47beaed1a48f802e06c6357a4c875c71fc97fe50", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a54ffd6cb9056b98ec4f188122b370e29ddd30d0", "patch": "@@ -1,3 +1,43 @@\n+2014-01-31  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch4.adb: Minor reformatting.\n+\n+2014-01-31  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch2.adb: New calling sequence for Is_LHS.\n+\t* frontend.adb: Add call to Process_Deferred_References.\n+\t* lib-xref.ads, lib-xref.adb (Process_Deferred_References): New.\n+\t(Deferred_References): New table.\n+\t* sem_ch8.adb (Find_Direct_Name): Make deferred reference table\n+\tentries.\n+\t(Find_Expanded_Name): Ditto.\n+\t* sem_res.adb: New calling sequence for Is_LHS.\n+\t* sem_util.ads, sem_util.adb (Is_LHS): New calling sequence.\n+\t* sem_warn.adb: Call Process_Deferred_References before issuing\n+\twarnings.\n+\n+2014-01-31  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* exp_util.adb (Corresponding_Runtime_Package): Restrict the\n+\tuse of System_Tasking_Protected_Objects_Single_Entry.\n+\t* exp_ch9.adb (Build_Simple_Entry_Call): Remove Mode parameter\n+\tof Protected_Single_Entry_Call.\n+\t(Expand_N_Timed_Entry_Call): Remove single_entry case.\n+\t* exp_disp.adb (Make_Disp_Asynchronous_Select_Body): Remove\n+\tsingle_entry case.\n+\t(Make_Disp_Timed_Select_Body): Likewise.\n+\t* rtsfind.ads (RE_Timed_Protected_Single_Entry_Call): Remove.\n+\t* s-tposen.adb (Send_Program_Error, PO_Do_Or_Queue): Remove\n+\tSelf_Id parameter.\n+\t(Wakeup_Entry_Caller): Remove Self_ID and New_State parameters.\n+\t(Wait_For_Completion_With_Timeout): Remove.\n+\t(Protected_Single_Entry_Call): Remove Mode parameter\n+\t(always Simple_Call).\n+\t(Service_Entry): Remove Self_Id constant (not used anymore).\n+\t(Timed_Protected_Single_Entry_Call): Remove.\n+\t* s-tposen.ads (Timed_Protected_Single_Entry_Call): Remove.\n+\t(Protected_Single_Entry_Call): Remove Mode parameter.\n+\n 2014-01-29  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* einfo.adb (Get_Pragma): Handle the retrieval of pragma Refined_Post."}, {"sha": "de3bbbcc1dacc248eab411c3491fd93491cddc11", "filename": "gcc/ada/exp_ch2.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2Fexp_ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2Fexp_ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch2.adb?ref=a54ffd6cb9056b98ec4f188122b370e29ddd30d0", "patch": "@@ -380,7 +380,7 @@ package body Exp_Ch2 is\n         and then Is_Scalar_Type (Etype (N))\n         and then (Is_Assignable (E) or else Is_Constant_Object (E))\n         and then Comes_From_Source (N)\n-        and then not Is_LHS (N)\n+        and then Is_LHS (N) = No\n         and then not Is_Actual_Out_Parameter (N)\n         and then (Nkind (Parent (N)) /= N_Attribute_Reference\n                    or else Attribute_Name (Parent (N)) /= Name_Valid)"}, {"sha": "078e8369fdad64fa9d3a8be24f710dfd022b4c99", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 6, "deletions": 28, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=a54ffd6cb9056b98ec4f188122b370e29ddd30d0", "patch": "@@ -4682,12 +4682,10 @@ package body Exp_Ch9 is\n          --  family index expressions are evaluated before the entry\n          --  parameters.\n \n-         if Abort_Allowed\n-           or else Restriction_Active (No_Entry_Queue) = False\n-           or else not Is_Protected_Type (Conctyp)\n-           or else Number_Entries (Conctyp) > 1\n-           or else (Has_Attach_Handler (Conctyp)\n-                     and then not Restricted_Profile)\n+         if not Is_Protected_Type (Conctyp)\n+           or else\n+             Corresponding_Runtime_Package (Conctyp) =\n+               System_Tasking_Protected_Objects_Entries\n          then\n             X := Make_Defining_Identifier (Loc, Name_uX);\n \n@@ -4902,8 +4900,7 @@ package body Exp_Ch9 is\n                when System_Tasking_Protected_Objects_Single_Entry =>\n                   --     Protected_Single_Entry_Call (\n                   --       Object => po._object'Access,\n-                  --       Uninterpreted_Data => P'Address;\n-                  --       Mode => Simple_Call);\n+                  --       Uninterpreted_Data => P'Address);\n \n                   Call :=\n                     Make_Procedure_Call_Statement (Loc,\n@@ -4914,8 +4911,7 @@ package body Exp_Ch9 is\n                         Make_Attribute_Reference (Loc,\n                           Attribute_Name => Name_Unchecked_Access,\n                           Prefix         => Parm1),\n-                        Parm3,\n-                        New_Reference_To (RTE (RE_Simple_Call), Loc)));\n+                        Parm3));\n \n                when others =>\n                   raise Program_Error;\n@@ -12481,24 +12477,6 @@ package body Exp_Ch9 is\n                           (RTE (RE_Timed_Protected_Entry_Call), Loc),\n                       Parameter_Associations => Params));\n \n-               when System_Tasking_Protected_Objects_Single_Entry =>\n-                  Param := First (Params);\n-                  while Present (Param)\n-                    and then not\n-                      Is_RTE (Etype (Param), RE_Protected_Entry_Index)\n-                  loop\n-                     Next (Param);\n-                  end loop;\n-\n-                  Remove (Param);\n-\n-                  Rewrite (Call,\n-                    Make_Procedure_Call_Statement (Loc,\n-                      Name =>\n-                        New_Reference_To\n-                          (RTE (RE_Timed_Protected_Single_Entry_Call), Loc),\n-                      Parameter_Associations => Params));\n-\n                when others =>\n                   raise Program_Error;\n             end case;"}, {"sha": "b0660fc02901e06c39ec7d9200c3ccd0e435e33c", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=a54ffd6cb9056b98ec4f188122b370e29ddd30d0", "patch": "@@ -2337,30 +2337,6 @@ package body Exp_Disp is\n \n                           New_Reference_To (Com_Block, Loc)))); -- comm block\n \n-               when System_Tasking_Protected_Objects_Single_Entry =>\n-\n-                  --  Generate:\n-                  --    procedure Protected_Single_Entry_Call\n-                  --      (Object              : Protection_Entry_Access;\n-                  --       Uninterpreted_Data  : System.Address;\n-                  --       Mode                : Call_Modes);\n-\n-                  Append_To (Stmts,\n-                    Make_Procedure_Call_Statement (Loc,\n-                      Name =>\n-                        New_Reference_To\n-                          (RTE (RE_Protected_Single_Entry_Call), Loc),\n-                      Parameter_Associations =>\n-                        New_List (\n-                          Obj_Ref,\n-\n-                          Make_Attribute_Reference (Loc,\n-                            Prefix         => Make_Identifier (Loc, Name_uP),\n-                            Attribute_Name => Name_Address),\n-\n-                            New_Reference_To\n-                             (RTE (RE_Asynchronous_Call), Loc))));\n-\n                when others =>\n                   raise Program_Error;\n             end case;\n@@ -3569,29 +3545,6 @@ package body Exp_Disp is\n                           Make_Identifier (Loc, Name_uM),   --  delay mode\n                           Make_Identifier (Loc, Name_uF)))); --  status flag\n \n-               when System_Tasking_Protected_Objects_Single_Entry =>\n-                  --  Generate:\n-\n-                  --   Timed_Protected_Single_Entry_Call\n-                  --     (T._object'access, P, D, M, F);\n-\n-                  --  where T is the protected object, P is the wrapped\n-                  --  parameters, D is the delay amount, M is the delay mode, F\n-                  --  is the status flag.\n-\n-                  Append_To (Stmts,\n-                    Make_Procedure_Call_Statement (Loc,\n-                      Name =>\n-                        New_Reference_To\n-                          (RTE (RE_Timed_Protected_Single_Entry_Call), Loc),\n-                      Parameter_Associations =>\n-                        New_List (\n-                          Obj_Ref,\n-                          Make_Identifier (Loc, Name_uP),   --  parameter block\n-                          Make_Identifier (Loc, Name_uD),   --  delay\n-                          Make_Identifier (Loc, Name_uM),   --  delay mode\n-                          Make_Identifier (Loc, Name_uF)))); --  status flag\n-\n                when others =>\n                   raise Program_Error;\n             end case;"}, {"sha": "b2ca1418238303a66264b94086cb6108bdaaef1e", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=a54ffd6cb9056b98ec4f188122b370e29ddd30d0", "patch": "@@ -1646,6 +1646,7 @@ package body Exp_Util is\n          then\n             if Abort_Allowed\n               or else Restriction_Active (No_Entry_Queue) = False\n+              or else Restriction_Active (No_Select_Statements) = False\n               or else Number_Entries (Typ) > 1\n               or else (Has_Attach_Handler (Typ)\n                         and then not Restricted_Profile)"}, {"sha": "2ead14c09da6d3f48c3f730883da7cbd58fcf796", "filename": "gcc/ada/frontend.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2Ffrontend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2Ffrontend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffrontend.adb?ref=a54ffd6cb9056b98ec4f188122b370e29ddd30d0", "patch": "@@ -36,6 +36,7 @@ with Fname.UF;\n with Inline;   use Inline;\n with Lib;      use Lib;\n with Lib.Load; use Lib.Load;\n+with Lib.Xref; use Lib.Xref;\n with Live;     use Live;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n@@ -392,6 +393,7 @@ begin\n \n          --  Output waiting warning messages\n \n+         Lib.Xref.Process_Deferred_References;\n          Sem_Warn.Output_Non_Modified_In_Out_Warnings;\n          Sem_Warn.Output_Unreferenced_Messages;\n          Sem_Warn.Check_Unused_Withs;"}, {"sha": "034e67af928b36e0572d426a1f947968e0513cb0", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=a54ffd6cb9056b98ec4f188122b370e29ddd30d0", "patch": "@@ -1705,8 +1705,8 @@ package body Lib.Xref is\n          end loop;\n       end Handle_Orphan_Type_References;\n \n-      --  Now we have all the references, including those for any embedded\n-      --  type references, so we can sort them, and output them.\n+      --  Now we have all the references, including those for any embedded type\n+      --  references, so we can sort them, and output them.\n \n       Output_Refs : declare\n \n@@ -2563,6 +2563,38 @@ package body Lib.Xref is\n       end Output_Refs;\n    end Output_References;\n \n+   ---------------------------------\n+   -- Process_Deferred_References --\n+   ---------------------------------\n+\n+   procedure Process_Deferred_References is\n+   begin\n+      for J in Deferred_References.First .. Deferred_References.Last loop\n+         declare\n+            D : Deferred_Reference_Entry renames Deferred_References.Table (J);\n+\n+         begin\n+            case Is_LHS (D.N) is\n+               when Yes =>\n+                  Generate_Reference (D.E, D.N, 'm');\n+\n+               when No =>\n+                  Generate_Reference (D.E, D.N, 'r');\n+\n+               --  Not clear if Unknown can occur at this stage, but if it\n+               --  does we will treat it as a normal reference.\n+\n+               when Unknown =>\n+                  Generate_Reference (D.E, D.N, 'r');\n+            end case;\n+         end;\n+      end loop;\n+\n+      --  Clear processed entries from table\n+\n+      Deferred_References.Init;\n+   end Process_Deferred_References;\n+\n --  Start of elaboration for Lib.Xref\n \n begin"}, {"sha": "b8f3e55ffceb62ccc431339d7125852236e2db49", "filename": "gcc/ada/lib-xref.ads", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2Flib-xref.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2Flib-xref.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.ads?ref=a54ffd6cb9056b98ec4f188122b370e29ddd30d0", "patch": "@@ -600,6 +600,39 @@ package Lib.Xref is\n    --  Export at line 4, that its body is exported to C, and that the link name\n    --  as given in the pragma is \"here\".\n \n+   -------------------------\n+   -- Deferred_References --\n+   -------------------------\n+\n+   --  Normally we generate references as we go along, but as discussed in\n+   --  Sem_Util.Is_LHS, and Sem_Ch8.Find_Direct_Name/Find_Selected_Component,\n+   --  we have one case where that is tricky, which is when we have something\n+   --  like X.A := 3, where we don't know until we know the type of X whether\n+   --  this is a reference (if X is an access type, so what we really have is\n+   --  X.all.A := 3) or a modification, where X is not an access type.\n+\n+   --  What we do in such cases is to gather nodes, where we would have liked\n+   --  to call Generate_Reference but we couldn't because we didn't know enough\n+   --  into this table, Then we deal with generating references later on when\n+   --  we have sufficient information to do it right.\n+\n+   type Deferred_Reference_Entry is record\n+      E : Entity_Id;\n+      N : Node_Id;\n+   end record;\n+   --  One entry, E, N are as required for Generate_Reference call\n+\n+   package Deferred_References is new Table.Table (\n+     Table_Component_Type => Deferred_Reference_Entry,\n+     Table_Index_Type     => Int,\n+     Table_Low_Bound      => 0,\n+     Table_Initial        => 512,\n+     Table_Increment      => 200,\n+     Table_Name           => \"Name_Deferred_References\");\n+\n+   procedure Process_Deferred_References;\n+   --  This procedure is called from Frontend to process these table entries.\n+\n    -----------------------------\n    -- SPARK Xrefs Information --\n    -----------------------------"}, {"sha": "5fcfb310c9dfcb2dcef1b6cc5187c7ce53008cc3", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=a54ffd6cb9056b98ec4f188122b370e29ddd30d0", "patch": "@@ -1750,7 +1750,6 @@ package Rtsfind is\n      RE_Exceptional_Complete_Single_Entry_Body,\n      RE_Protected_Count_Entry,           -- Protected_Objects.Single_Entry\n      RE_Protected_Single_Entry_Caller,   -- Protected_Objects.Single_Entry\n-     RE_Timed_Protected_Single_Entry_Call,\n \n      RE_Protected_Entry_Index,           -- System.Tasking.Protected_Objects\n      RE_Entry_Body,                      -- System.Tasking.Protected_Objects\n@@ -3062,8 +3061,6 @@ package Rtsfind is\n        System_Tasking_Protected_Objects_Single_Entry,\n      RE_Protected_Single_Entry_Caller    =>\n        System_Tasking_Protected_Objects_Single_Entry,\n-     RE_Timed_Protected_Single_Entry_Call =>\n-       System_Tasking_Protected_Objects_Single_Entry,\n \n      RE_Protected_Entry_Index            => System_Tasking_Protected_Objects,\n      RE_Entry_Body                       => System_Tasking_Protected_Objects,"}, {"sha": "697ee9dabb1b5e490c07836605ae87830425245b", "filename": "gcc/ada/s-tposen.adb", "status": "modified", "additions": 22, "deletions": 184, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2Fs-tposen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2Fs-tposen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tposen.adb?ref=a54ffd6cb9056b98ec4f188122b370e29ddd30d0", "patch": "@@ -74,29 +74,20 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n    -- Local Subprograms --\n    -----------------------\n \n-   procedure Send_Program_Error\n-     (Self_Id    : Task_Id;\n-      Entry_Call : Entry_Call_Link);\n+   procedure Send_Program_Error (Entry_Call : Entry_Call_Link);\n    pragma Inline (Send_Program_Error);\n    --  Raise Program_Error in the caller of the specified entry call\n \n    --------------------------\n    -- Entry Calls Handling --\n    --------------------------\n \n-   procedure Wakeup_Entry_Caller\n-     (Self_ID    : Task_Id;\n-      Entry_Call : Entry_Call_Link;\n-      New_State  : Entry_Call_State);\n+   procedure Wakeup_Entry_Caller (Entry_Call : Entry_Call_Link);\n    pragma Inline (Wakeup_Entry_Caller);\n    --  This is called at the end of service of an entry call,\n    --  to abort the caller if he is in an abortable part, and\n    --  to wake up the caller if he is on Entry_Caller_Sleep.\n    --  Call it holding the lock of Entry_Call.Self.\n-   --\n-   --  Timed_Call or Simple_Call:\n-   --    The caller is waiting on Entry_Caller_Sleep, in\n-   --    Wait_For_Completion, or Wait_For_Completion_With_Timeout.\n \n    procedure Wait_For_Completion (Entry_Call : Entry_Call_Link);\n    pragma Inline (Wait_For_Completion);\n@@ -105,13 +96,6 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n    --  queued. This waits for calls on protected entries.\n    --  Call this only when holding Self_ID locked.\n \n-   procedure Wait_For_Completion_With_Timeout\n-     (Entry_Call  : Entry_Call_Link;\n-      Wakeup_Time : Duration;\n-      Mode        : Delay_Modes);\n-   --  Same as Wait_For_Completion but it waits for a timeout with the value\n-   --  specified in Wakeup_Time as well.\n-\n    procedure Check_Exception\n      (Self_ID : Task_Id;\n       Entry_Call : Entry_Call_Link);\n@@ -122,8 +106,7 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n    --  The caller should not be holding any locks, or there will be deadlock.\n \n    procedure PO_Do_Or_Queue\n-     (Self_Id    : Task_Id;\n-      Object     : Protection_Entry_Access;\n+     (Object     : Protection_Entry_Access;\n       Entry_Call : Entry_Call_Link);\n    --  This procedure executes or queues an entry call, depending\n    --  on the status of the corresponding barrier. It assumes that the\n@@ -157,9 +140,7 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n    -- Send_Program_Error --\n    ------------------------\n \n-   procedure Send_Program_Error\n-     (Self_Id    : Task_Id;\n-      Entry_Call : Entry_Call_Link)\n+   procedure Send_Program_Error (Entry_Call : Entry_Call_Link)\n    is\n       Caller : constant Task_Id := Entry_Call.Self;\n    begin\n@@ -170,7 +151,7 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n       end if;\n \n       STPO.Write_Lock (Caller);\n-      Wakeup_Entry_Caller (Self_Id, Entry_Call, Done);\n+      Wakeup_Entry_Caller (Entry_Call);\n       STPO.Unlock (Caller);\n \n       if Single_Lock then\n@@ -190,51 +171,6 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n       Self_Id.Common.State := Runnable;\n    end Wait_For_Completion;\n \n-   --------------------------------------\n-   -- Wait_For_Completion_With_Timeout --\n-   --------------------------------------\n-\n-   procedure Wait_For_Completion_With_Timeout\n-     (Entry_Call  : Entry_Call_Link;\n-      Wakeup_Time : Duration;\n-      Mode        : Delay_Modes)\n-   is\n-      Self_Id  : constant Task_Id := Entry_Call.Self;\n-      Timedout : Boolean;\n-\n-      Yielded  : Boolean;\n-      pragma Unreferenced (Yielded);\n-\n-      use type Ada.Exceptions.Exception_Id;\n-\n-   begin\n-      --  This procedure waits for the entry call to be served, with a timeout.\n-      --  It tries to cancel the call if the timeout expires before the call is\n-      --  served.\n-\n-      --  If we wake up from the timed sleep operation here, it may be for the\n-      --  following possible reasons:\n-\n-      --  1) The entry call is done being served.\n-      --  2) The timeout has expired (Timedout = True)\n-\n-      --  Once the timeout has expired we may need to continue to wait if the\n-      --  call is already being serviced. In that case, we want to go back to\n-      --  sleep, but without any timeout. The variable Timedout is used to\n-      --  control this. If the Timedout flag is set, we do not need to Sleep\n-      --  with a timeout. We just sleep until we get a wakeup for some status\n-      --  change.\n-\n-      pragma Assert (Entry_Call.Mode = Timed_Call);\n-      Self_Id.Common.State := Entry_Caller_Sleep;\n-\n-      STPO.Timed_Sleep\n-        (Self_Id, Wakeup_Time, Mode, Entry_Caller_Sleep, Timedout, Yielded);\n-\n-      Entry_Call.State := (if Timedout then Cancelled else Done);\n-      Self_Id.Common.State := Runnable;\n-   end Wait_For_Completion_With_Timeout;\n-\n    -------------------------\n    -- Wakeup_Entry_Caller --\n    -------------------------\n@@ -246,31 +182,18 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n    --  (This enforces the rule that a task must be off-queue if its state is\n    --  Done or Cancelled.) Call it holding the lock of Entry_Call.Self.\n \n-   --  Timed_Call or Simple_Call:\n-   --    The caller is waiting on Entry_Caller_Sleep, in\n-   --    Wait_For_Completion, or Wait_For_Completion_With_Timeout.\n-\n-   --  Conditional_Call:\n-   --    The caller might be in Wait_For_Completion,\n-   --    waiting for a rendezvous (possibly requeued without abort)\n-   --    to complete.\n+   --  The caller is waiting on Entry_Caller_Sleep, in Wait_For_Completion.\n \n    procedure Wakeup_Entry_Caller\n-     (Self_ID    : Task_Id;\n-      Entry_Call : Entry_Call_Link;\n-      New_State  : Entry_Call_State)\n+     (Entry_Call : Entry_Call_Link)\n    is\n-      pragma Warnings (Off, Self_ID);\n-\n       Caller : constant Task_Id := Entry_Call.Self;\n-\n    begin\n-      pragma Assert (New_State = Done or else New_State = Cancelled);\n       pragma Assert\n         (Caller.Common.State /= Terminated and then\n          Caller.Common.State /= Unactivated);\n \n-      Entry_Call.State := New_State;\n+      Entry_Call.State := Done;\n       STPO.Wakeup (Caller, Entry_Caller_Sleep);\n    end Wakeup_Entry_Caller;\n \n@@ -338,8 +261,7 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n    --------------------\n \n    procedure PO_Do_Or_Queue\n-     (Self_Id    : Task_Id;\n-      Object     : Protection_Entry_Access;\n+     (Object     : Protection_Entry_Access;\n       Entry_Call : Entry_Call_Link)\n    is\n       Barrier_Value : Boolean;\n@@ -356,7 +278,7 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n             --  This violates the No_Entry_Queue restriction, send\n             --  Program_Error to the caller.\n \n-            Send_Program_Error (Self_Id, Entry_Call);\n+            Send_Program_Error (Entry_Call);\n             return;\n          end if;\n \n@@ -370,45 +292,32 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n          end if;\n \n          STPO.Write_Lock (Entry_Call.Self);\n-         Wakeup_Entry_Caller (Self_Id, Entry_Call, Done);\n+         Wakeup_Entry_Caller (Entry_Call);\n          STPO.Unlock (Entry_Call.Self);\n \n          if Single_Lock then\n             STPO.Unlock_RTS;\n          end if;\n \n-      elsif Entry_Call.Mode /= Conditional_Call then\n+      else\n+         pragma Assert (Entry_Call.Mode = Simple_Call);\n+\n          if Object.Entry_Queue /= null then\n \n             --  This violates the No_Entry_Queue restriction, send\n             --  Program_Error to the caller.\n \n-            Send_Program_Error (Self_Id, Entry_Call);\n+            Send_Program_Error (Entry_Call);\n             return;\n          else\n             Object.Entry_Queue := Entry_Call;\n          end if;\n \n-      else\n-         --  Conditional_Call\n-\n-         if Single_Lock then\n-            STPO.Lock_RTS;\n-         end if;\n-\n-         STPO.Write_Lock (Entry_Call.Self);\n-         Wakeup_Entry_Caller (Self_Id, Entry_Call, Cancelled);\n-         STPO.Unlock (Entry_Call.Self);\n-\n-         if Single_Lock then\n-            STPO.Unlock_RTS;\n-         end if;\n       end if;\n \n    exception\n       when others =>\n-         Send_Program_Error\n-           (Self_Id, Entry_Call);\n+         Send_Program_Error (Entry_Call);\n    end PO_Do_Or_Queue;\n \n    ----------------------------\n@@ -430,8 +339,7 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n \n    procedure Protected_Single_Entry_Call\n      (Object             : Protection_Entry_Access;\n-      Uninterpreted_Data : System.Address;\n-      Mode               : Call_Modes)\n+      Uninterpreted_Data : System.Address)\n    is\n       Self_Id    : constant Task_Id := STPO.Self;\n       Entry_Call : Entry_Call_Record renames Self_Id.Entry_Calls (1);\n@@ -448,12 +356,12 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n \n       Lock_Entry (Object);\n \n-      Entry_Call.Mode := Mode;\n+      Entry_Call.Mode := Simple_Call;\n       Entry_Call.State := Now_Abortable;\n       Entry_Call.Uninterpreted_Data := Uninterpreted_Data;\n       Entry_Call.Exception_To_Raise := Ada.Exceptions.Null_Id;\n \n-      PO_Do_Or_Queue (Self_Id, Object, Entry_Call'Access);\n+      PO_Do_Or_Queue (Object, Entry_Call'Access);\n       Unlock_Entry (Object);\n \n       --  The call is either `Done' or not. It cannot be cancelled since there\n@@ -493,7 +401,6 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n    -------------------\n \n    procedure Service_Entry (Object : Protection_Entry_Access) is\n-      Self_Id    : constant Task_Id := STPO.Self;\n       Entry_Call : constant Entry_Call_Link := Object.Entry_Queue;\n       Caller     : Task_Id;\n \n@@ -507,7 +414,7 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n \n             --  Violation of No_Entry_Queue restriction, raise exception\n \n-            Send_Program_Error (Self_Id, Entry_Call);\n+            Send_Program_Error (Entry_Call);\n             Unlock_Entry (Object);\n             return;\n          end if;\n@@ -524,7 +431,7 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n          end if;\n \n          STPO.Write_Lock (Caller);\n-         Wakeup_Entry_Caller (Self_Id, Entry_Call, Done);\n+         Wakeup_Entry_Caller (Entry_Call);\n          STPO.Unlock (Caller);\n \n          if Single_Lock then\n@@ -539,79 +446,10 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n \n    exception\n       when others =>\n-         Send_Program_Error (Self_Id, Entry_Call);\n+         Send_Program_Error (Entry_Call);\n          Unlock_Entry (Object);\n    end Service_Entry;\n \n-   ---------------------------------------\n-   -- Timed_Protected_Single_Entry_Call --\n-   ---------------------------------------\n-\n-   --  Compiler interface only (do not call from within the RTS)\n-\n-   procedure Timed_Protected_Single_Entry_Call\n-     (Object                : Protection_Entry_Access;\n-      Uninterpreted_Data    : System.Address;\n-      Timeout               : Duration;\n-      Mode                  : Delay_Modes;\n-      Entry_Call_Successful : out Boolean)\n-   is\n-      Self_Id           : constant Task_Id  := STPO.Self;\n-      Entry_Call        : Entry_Call_Record renames Self_Id.Entry_Calls (1);\n-\n-   begin\n-      --  If pragma Detect_Blocking is active then Program_Error must be\n-      --  raised if this potentially blocking operation is called from a\n-      --  protected action.\n-\n-      if Detect_Blocking\n-        and then Self_Id.Common.Protected_Action_Nesting > 0\n-      then\n-         raise Program_Error with \"potentially blocking operation\";\n-      end if;\n-\n-      Lock (Object.Common'Access);\n-\n-      Entry_Call.Mode := Timed_Call;\n-      Entry_Call.State := Now_Abortable;\n-      Entry_Call.Uninterpreted_Data := Uninterpreted_Data;\n-      Entry_Call.Exception_To_Raise := Ada.Exceptions.Null_Id;\n-\n-      PO_Do_Or_Queue (Self_Id, Object, Entry_Call'Access);\n-      Unlock_Entry (Object);\n-\n-      --  Try to avoid waiting for completed calls.\n-      --  The call is either `Done' or not. It cannot be cancelled since there\n-      --  is no ATC construct and the timed wait has not started yet.\n-\n-      pragma Assert (Entry_Call.State /= Cancelled);\n-\n-      if Entry_Call.State = Done then\n-         Check_Exception (Self_Id, Entry_Call'Access);\n-         Entry_Call_Successful := True;\n-         return;\n-      end if;\n-\n-      if Single_Lock then\n-         STPO.Lock_RTS;\n-      else\n-         STPO.Write_Lock (Self_Id);\n-      end if;\n-\n-      Wait_For_Completion_With_Timeout (Entry_Call'Access, Timeout, Mode);\n-\n-      if Single_Lock then\n-         STPO.Unlock_RTS;\n-      else\n-         STPO.Unlock (Self_Id);\n-      end if;\n-\n-      pragma Assert (Entry_Call.State >= Done);\n-\n-      Check_Exception (Self_Id, Entry_Call'Access);\n-      Entry_Call_Successful := Entry_Call.State = Done;\n-   end Timed_Protected_Single_Entry_Call;\n-\n    ------------------\n    -- Unlock_Entry --\n    ------------------"}, {"sha": "b2713bd32829d23f6b738a3d35b220114afc9d07", "filename": "gcc/ada/s-tposen.ads", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2Fs-tposen.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2Fs-tposen.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tposen.ads?ref=a54ffd6cb9056b98ec4f188122b370e29ddd30d0", "patch": "@@ -225,8 +225,7 @@ package System.Tasking.Protected_Objects.Single_Entry is\n \n    procedure Protected_Single_Entry_Call\n      (Object              : Protection_Entry_Access;\n-      Uninterpreted_Data  : System.Address;\n-      Mode                : Call_Modes);\n+      Uninterpreted_Data  : System.Address);\n    --  Make a protected entry call to the specified object\n    --\n    --  Pend a protected entry call on the protected object represented by\n@@ -237,18 +236,6 @@ package System.Tasking.Protected_Objects.Single_Entry is\n    --      This will be returned by Next_Entry_Call when this call is serviced.\n    --      It can be used by the compiler to pass information between the\n    --      caller and the server, in particular entry parameters.\n-   --\n-   --    Mode\n-   --      The kind of call to be pended\n-\n-   procedure Timed_Protected_Single_Entry_Call\n-     (Object                : Protection_Entry_Access;\n-      Uninterpreted_Data    : System.Address;\n-      Timeout               : Duration;\n-      Mode                  : Delay_Modes;\n-      Entry_Call_Successful : out Boolean);\n-   --  Same as the Protected_Entry_Call but with time-out specified.\n-   --  This routine is used to implement timed entry calls.\n \n    procedure Exceptional_Complete_Single_Entry_Body\n      (Object : Protection_Entry_Access;"}, {"sha": "abda180b7f378eecb3cab05e98af80a452f2a818", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=a54ffd6cb9056b98ec4f188122b370e29ddd30d0", "patch": "@@ -5890,23 +5890,26 @@ package body Sem_Ch4 is\n          --  correct. If an operand is universal it is compatible with any\n          --  numeric type.\n \n-         --  In Ada 2005, the equality on anonymous access types is declared\n-         --  in Standard, and is always visible.\n-         --  In an instance, the type may have been immediately visible.\n-         --  Either the types are compatible, or one operand is universal\n-         --  (numeric or null).\n-\n          elsif In_Open_Scopes (Scope (Bas))\n            or else Is_Potentially_Use_Visible (Bas)\n            or else In_Use (Bas)\n            or else (In_Use (Scope (Bas)) and then not Is_Hidden (Bas))\n+\n+            --  In an instance, the type may have been immediately visible.\n+            --  Either the types are compatible, or one operand is universal\n+            --  (numeric or null).\n+\n            or else (In_Instance\n                      and then\n                        (First_Subtype (T1) = First_Subtype (Etype (R))\n                          or else Nkind (R) = N_Null\n                          or else\n                            (Is_Numeric_Type (T1)\n                              and then Is_Universal_Numeric_Type (Etype (R)))))\n+\n+           --  In Ada 2005, the equality on anonymous access types is declared\n+           --  in Standard, and is always visible.\n+\n            or else Ekind (T1) = E_Anonymous_Access_Type\n          then\n             null;"}, {"sha": "0868e01ab7968e2a42fb14acf18f3787c0f8d195", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 36, "deletions": 30, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=a54ffd6cb9056b98ec4f188122b370e29ddd30d0", "patch": "@@ -5152,29 +5152,29 @@ package body Sem_Ch8 is\n \n             --  Normal case, not a label: generate reference\n \n-            --    ??? It is too early to generate a reference here even if the\n-            --    entity is unambiguous, because the tree is not sufficiently\n-            --    typed at this point for Generate_Reference to determine\n-            --    whether this reference modifies the denoted object (because\n-            --    implicit dereferences cannot be identified prior to full type\n-            --    resolution).\n+            else\n+               if not Is_Actual_Parameter then\n \n-            --    The Is_Actual_Parameter routine takes care of one of these\n-            --    cases but there are others probably ???\n+                  --  Package or generic package is always a simple reference\n \n-            --    If the entity is the LHS of an assignment, and is a variable\n-            --    (rather than a package prefix), we can mark it as a\n-            --    modification right away, to avoid duplicate references.\n+                  if Ekind_In (E, E_Package, E_Generic_Package) then\n+                     Generate_Reference (E, N, 'r');\n+\n+                  --  Else see if we have a left hand side\n \n-            else\n-               if not Is_Actual_Parameter then\n-                  if Is_LHS (N)\n-                    and then Ekind (E) /= E_Package\n-                    and then Ekind (E) /= E_Generic_Package\n-                  then\n-                     Generate_Reference (E, N, 'm');\n                   else\n-                     Generate_Reference (E, N);\n+                     case Is_LHS (N) is\n+                        when Yes =>\n+                           Generate_Reference (E, N, 'm');\n+\n+                        when No =>\n+                           Generate_Reference (E, N, 'r');\n+\n+                        --  If we don't know now, generate reference later\n+\n+                     when Unknown =>\n+                        Deferred_References.Append ((E, N));\n+                     end case;\n                   end if;\n                end if;\n \n@@ -5655,26 +5655,32 @@ package body Sem_Ch8 is\n \n       Change_Selected_Component_To_Expanded_Name (N);\n \n+      --  Set appropriate type\n+\n+      if Is_Type (Id) then\n+         Set_Etype (N, Id);\n+      else\n+         Set_Etype (N, Get_Full_View (Etype (Id)));\n+      end if;\n+\n       --  Do style check and generate reference, but skip both steps if this\n       --  entity has homonyms, since we may not have the right homonym set yet.\n       --  The proper homonym will be set during the resolve phase.\n \n       if Has_Homonym (Id) then\n          Set_Entity (N, Id);\n+\n       else\n          Set_Entity_Or_Discriminal (N, Id);\n \n-         if Is_LHS (N) then\n-            Generate_Reference (Id, N, 'm');\n-         else\n-            Generate_Reference (Id, N);\n-         end if;\n-      end if;\n-\n-      if Is_Type (Id) then\n-         Set_Etype (N, Id);\n-      else\n-         Set_Etype (N, Get_Full_View (Etype (Id)));\n+         case Is_LHS (N) is\n+            when Yes =>\n+               Generate_Reference (Id, N, 'm');\n+            when No =>\n+               Generate_Reference (Id, N, 'r');\n+            when Unknown =>\n+               Deferred_References.Append ((Id, N));\n+         end case;\n       end if;\n \n       --  Check for violation of No_Wide_Characters"}, {"sha": "a01c20a73170ec5b34d77abab7ee9d7231abe1e7", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=a54ffd6cb9056b98ec4f188122b370e29ddd30d0", "patch": "@@ -7673,7 +7673,7 @@ package body Sem_Res is\n                    or else (Is_Entity_Name (Prefix (N))\n                              and then Is_Atomic (Entity (Prefix (N)))))\n         and then Is_Bit_Packed_Array (Array_Type)\n-        and then Is_LHS (N)\n+        and then Is_LHS (N) = Yes\n       then\n          Error_Msg_N (\"??assignment to component of packed atomic array\",\n                       Prefix (N));\n@@ -9170,7 +9170,7 @@ package body Sem_Res is\n                    or else (Is_Entity_Name (Prefix (N))\n                              and then Is_Atomic (Entity (Prefix (N)))))\n         and then Is_Packed (T)\n-        and then Is_LHS (N)\n+        and then Is_LHS (N) = Yes\n       then\n          Error_Msg_N\n            (\"??assignment to component of packed atomic record\", Prefix (N));"}, {"sha": "12704a692d27907890e7b6331411688a6d9c8de7", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=a54ffd6cb9056b98ec4f188122b370e29ddd30d0", "patch": "@@ -5587,7 +5587,8 @@ package body Sem_Util is\n       --  we exclude overloaded calls, since we don't know enough to be sure\n       --  of giving the right answer in this case.\n \n-      if Is_Entity_Name (Name (Call))\n+      if Nkind_In (Call, N_Function_Call, N_Procedure_Call_Statement)\n+        and then Is_Entity_Name (Name (Call))\n         and then Present (Entity (Name (Call)))\n         and then Is_Overloadable (Entity (Name (Call)))\n         and then not Is_Overloaded (Name (Call))\n@@ -9982,14 +9983,18 @@ package body Sem_Util is\n    --  We seem to have a lot of overlapping functions that do similar things\n    --  (testing for left hand sides or lvalues???).\n \n-   function Is_LHS (N : Node_Id) return Boolean is\n+   function Is_LHS (N : Node_Id) return Is_LHS_Result is\n       P : constant Node_Id := Parent (N);\n \n    begin\n       --  Return True if we are the left hand side of an assignment statement\n \n       if Nkind (P) = N_Assignment_Statement then\n-         return Name (P) = N;\n+         if Name (P) = N then\n+            return Yes;\n+         else\n+            return No;\n+         end if;\n \n       --  Case of prefix of indexed or selected component or slice\n \n@@ -10002,23 +10007,16 @@ package body Sem_Util is\n          --  what we really have is N.all.Q (or N.all(Q .. R)). In either\n          --  case this makes N.all a left hand side but not N itself.\n \n-         --  Here follows a worrisome kludge. If Etype (N) is not set, which\n-         --  for sure happens in the call from Find_Direct_Name, that means we\n-         --  don't know if N is of an access type, so we can't give an accurate\n-         --  answer. For now, we assume we do not have an access type, which\n-         --  means for example that P.Q.R := X will look like a modification\n-         --  of P, even if P.Q eventually turns out to be an access type. The\n-         --  consequence is at least that in some cases we incorrectly identify\n-         --  a reference as a modification. It is not clear if there are any\n-         --  other bad consequences. ???\n+         --  If we don't know the type yet, this is the case where we return\n+         --  Unknown, since the answer depends on the type which is unknown.\n \n          if No (Etype (N)) then\n-            return False;\n+            return Unknown;\n \n          --  We have an Etype set, so we can check it\n \n          elsif Is_Access_Type (Etype (N)) then\n-            return False;\n+            return No;\n \n          --  OK, not access type case, so just test whole expression\n \n@@ -10029,7 +10027,7 @@ package body Sem_Util is\n       --  All other cases are not left hand sides\n \n       else\n-         return False;\n+         return No;\n       end if;\n    end Is_LHS;\n "}, {"sha": "0e26161fe211ed982eda93c525097303c7403481", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=a54ffd6cb9056b98ec4f188122b370e29ddd30d0", "patch": "@@ -1164,8 +1164,15 @@ package Sem_Util is\n    --  AI05-0139-2: Check whether Typ is one of the predefined interfaces in\n    --  Ada.Iterator_Interfaces, or it is derived from one.\n \n-   function Is_LHS (N : Node_Id) return Boolean;\n-   --  Returns True iff N is used as Name in an assignment statement\n+   type Is_LHS_Result is (Yes, No, Unknown);\n+   function Is_LHS (N : Node_Id) return Is_LHS_Result;\n+   --  Returns Yes if N is definitely used as Name in an assignment statement.\n+   --  Returns No if N is definitely NOT used as a Name in an assignment\n+   --  statement. Returns Unknown if we can't tell at this stage (happens in\n+   --  the case where we don't know the type of N yet, and we have something\n+   --  like N.A := 3, where this counts as N being used on the left side of\n+   --  an assignment only if N is not an access type. If it is an access type\n+   --  then it is N.all.A that is assigned, not N.\n \n    function Is_Library_Level_Entity (E : Entity_Id) return Boolean;\n    --  A library-level declaration is one that is accessible from Standard,"}, {"sha": "cca8c06ce713709ff479f4acd40f6fbe51d5d61f", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a54ffd6cb9056b98ec4f188122b370e29ddd30d0/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=a54ffd6cb9056b98ec4f188122b370e29ddd30d0", "patch": "@@ -30,6 +30,7 @@ with Errout;   use Errout;\n with Exp_Code; use Exp_Code;\n with Fname;    use Fname;\n with Lib;      use Lib;\n+with Lib.Xref; use Lib.Xref;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Opt;      use Opt;\n@@ -998,6 +999,8 @@ package body Sem_Warn is\n    --  Start of processing for Check_References\n \n    begin\n+      Process_Deferred_References;\n+\n       --  No messages if warnings are suppressed, or if we have detected any\n       --  real errors so far (this last check avoids junk messages resulting\n       --  from errors, e.g. a subunit that is not loaded).\n@@ -2566,6 +2569,8 @@ package body Sem_Warn is\n          return;\n       end if;\n \n+      Process_Deferred_References;\n+\n       --  Flag any unused with clauses. For a subunit, check only the units\n       --  in its context, not those of the parent, which may be needed by other\n       --  subunits.  We will get the full warnings when we compile the parent,"}]}