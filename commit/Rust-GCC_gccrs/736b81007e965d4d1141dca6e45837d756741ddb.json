{"sha": "736b81007e965d4d1141dca6e45837d756741ddb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzM2YjgxMDA3ZTk2NWQ0ZDExNDFkY2E2ZTQ1ODM3ZDc1Njc0MWRkYg==", "commit": {"author": {"name": "Simon Baldwin", "email": "simonb@google.com", "date": "2007-06-18T22:09:14Z"}, "committer": {"name": "Simon Baldwin", "email": "simonb@gcc.gnu.org", "date": "2007-06-18T22:09:14Z"}, "message": "re PR c++/31923 (g++ accepts a storage-class-specifier on a template explicit specialization)\n\ngcc/cp/ChangeLog\n2007-06-15  Simon Baldwin <simonb@google.com>\n\n        PR c++/31923\n        * parser.c (cp_parser_single_declaration): Added check for storage\n        class other than sc_none in parsed declaration, and a flag to indicate\n        if the call is part of an explicit template specialization parse.\n        * (cp_parser_explicit_specialization): Specialization check flag added\n        to call to cp_parser_single_declaration(), set true.\n        * (cp_parser_template_declaration_after_export): Specialization check\n        flag added to call to cp_parser_single_declaration(), set false.\n        * pt.c (check_explicit_specialization): Added code to copy visiblity\n        and linkage from the templated function to the explicit specialization.\n  \ngcc/testsuite/ChangeLog\n2007-06-15  Simon Baldwin <simonb@google.com>\n  \n        PR c++/31923\n        * g++.dg/template/error25.C: New.\n        * g++.dg/template/spec35.C: New.\n\nFrom-SVN: r125829", "tree": {"sha": "ebe83019aac080d1a8f2fefc14cab3473f2d4579", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ebe83019aac080d1a8f2fefc14cab3473f2d4579"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/736b81007e965d4d1141dca6e45837d756741ddb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/736b81007e965d4d1141dca6e45837d756741ddb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/736b81007e965d4d1141dca6e45837d756741ddb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/736b81007e965d4d1141dca6e45837d756741ddb/comments", "author": null, "committer": null, "parents": [{"sha": "d448952a83fa71a5658c2f775e7c86316821f4fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d448952a83fa71a5658c2f775e7c86316821f4fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d448952a83fa71a5658c2f775e7c86316821f4fe"}], "stats": {"total": 128, "additions": 120, "deletions": 8}, "files": [{"sha": "609b80cb31d0c6eb52a79bd6473e717bb5fb4d37", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/736b81007e965d4d1141dca6e45837d756741ddb/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/736b81007e965d4d1141dca6e45837d756741ddb/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=736b81007e965d4d1141dca6e45837d756741ddb", "patch": "@@ -1,3 +1,16 @@\n+2007-06-18  Simon Baldwin <simonb@google.com>\n+\n+\tPR c++/31923\n+\t* parser.c (cp_parser_single_declaration): Added check for storage\n+\tclass other than sc_none in parsed declaration, and a flag to indicate\n+\tif the call is part of an explicit template specialization parse.\n+\t* (cp_parser_explicit_specialization): Specialization check flag added\n+\tto call to cp_parser_single_declaration(), set true.\n+\t* (cp_parser_template_declaration_after_export): Specialization check\n+\tflag added to call to cp_parser_single_declaration(), set false.\n+\t* pt.c (check_explicit_specialization): Added code to copy visiblity\n+\tand linkage from the templated function to the explicit specialization.\n+\n 2007-06-15  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \t* typeck.c (build_binary_op): For templates build the"}, {"sha": "ca6620c71b71dc69588be6762b4a15b5613e6774", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/736b81007e965d4d1141dca6e45837d756741ddb/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/736b81007e965d4d1141dca6e45837d756741ddb/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=736b81007e965d4d1141dca6e45837d756741ddb", "patch": "@@ -1913,7 +1913,7 @@ static void cp_parser_template_declaration_after_export\n static void cp_parser_perform_template_parameter_access_checks\n   (VEC (deferred_access_check,gc)*);\n static tree cp_parser_single_declaration\n-  (cp_parser *, VEC (deferred_access_check,gc)*, bool, bool *);\n+  (cp_parser *, VEC (deferred_access_check,gc)*, bool, bool, bool *);\n static tree cp_parser_functional_cast\n   (cp_parser *, tree);\n static tree cp_parser_save_member_function_body\n@@ -10225,6 +10225,7 @@ cp_parser_explicit_specialization (cp_parser* parser)\n     cp_parser_single_declaration (parser,\n \t\t\t\t  /*checks=*/NULL,\n \t\t\t\t  /*member_p=*/false,\n+                                  /*explicit_specialization_p=*/true,\n \t\t\t\t  /*friend_p=*/NULL);\n   /* We're done with the specialization.  */\n   end_specialization ();\n@@ -16510,6 +16511,7 @@ cp_parser_template_declaration_after_export (cp_parser* parser, bool member_p)\n       decl = cp_parser_single_declaration (parser,\n \t\t\t\t\t   checks,\n \t\t\t\t\t   member_p,\n+                                           /*explicit_specialization_p=*/false,\n \t\t\t\t\t   &friend_p);\n       pop_deferring_access_checks ();\n \n@@ -16575,6 +16577,7 @@ static tree\n cp_parser_single_declaration (cp_parser* parser,\n \t\t\t      VEC (deferred_access_check,gc)* checks,\n \t\t\t      bool member_p,\n+                              bool explicit_specialization_p,\n \t\t\t      bool* friend_p)\n {\n   int declares_class_or_enum;\n@@ -16648,13 +16651,27 @@ cp_parser_single_declaration (cp_parser* parser,\n   if (!decl\n       && (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON)\n \t  || decl_specifiers.type != error_mark_node))\n-    decl = cp_parser_init_declarator (parser,\n-\t\t\t\t      &decl_specifiers,\n-\t\t\t\t      checks,\n-\t\t\t\t      /*function_definition_allowed_p=*/true,\n-\t\t\t\t      member_p,\n-\t\t\t\t      declares_class_or_enum,\n-\t\t\t\t      &function_definition_p);\n+    {\n+      decl = cp_parser_init_declarator (parser,\n+\t\t\t\t        &decl_specifiers,\n+\t\t\t\t        checks,\n+\t\t\t\t        /*function_definition_allowed_p=*/true,\n+\t\t\t\t        member_p,\n+\t\t\t\t        declares_class_or_enum,\n+\t\t\t\t        &function_definition_p);\n+\n+    /* 7.1.1-1 [dcl.stc]\n+\n+       A storage-class-specifier shall not be specified in an explicit\n+       specialization...  */\n+    if (decl\n+        && explicit_specialization_p\n+        && decl_specifiers.storage_class != sc_none)\n+      {\n+        error (\"explicit template specialization cannot have a storage class\");\n+        decl = error_mark_node;\n+      }\n+    }\n \n   pop_deferring_access_checks ();\n "}, {"sha": "63f8247095eea33b197c27eb169627f15dbc7b2f", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/736b81007e965d4d1141dca6e45837d756741ddb/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/736b81007e965d4d1141dca6e45837d756741ddb/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=736b81007e965d4d1141dca6e45837d756741ddb", "patch": "@@ -2193,6 +2193,37 @@ check_explicit_specialization (tree declarator,\n \t  TREE_PRIVATE (decl) = TREE_PRIVATE (gen_tmpl);\n \t  TREE_PROTECTED (decl) = TREE_PROTECTED (gen_tmpl);\n \n+          /* 7.1.1-1 [dcl.stc]\n+\n+             A storage-class-specifier shall not be specified in an\n+             explicit specialization...\n+\n+             The parser rejects these, so unless action is taken here,\n+             explicit function specializations will always appear with\n+             global linkage.\n+\n+             The action recommended by the C++ CWG in response to C++\n+             defect report 605 is to make the storage class and linkage\n+             of the explicit specialization match the templated function:\n+\n+             http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#605\n+           */\n+          if (tsk == tsk_expl_spec && DECL_FUNCTION_TEMPLATE_P (gen_tmpl))\n+            {\n+              tree tmpl_func = DECL_TEMPLATE_RESULT (gen_tmpl);\n+              gcc_assert (TREE_CODE (tmpl_func) == FUNCTION_DECL);\n+\n+              /* This specialization has the same linkage and visiblity as\n+                 the function template it specializes.  */\n+              TREE_PUBLIC (decl) = TREE_PUBLIC (tmpl_func);\n+              DECL_THIS_STATIC (decl) = DECL_THIS_STATIC (tmpl_func);\n+              if (DECL_VISIBILITY_SPECIFIED (tmpl_func))\n+                {\n+                  DECL_VISIBILITY_SPECIFIED (decl) = 1;\n+                  DECL_VISIBILITY (decl) = DECL_VISIBILITY (tmpl_func);\n+                }\n+            }\n+\n \t  /* If DECL is a friend declaration, declared using an\n \t     unqualified name, the namespace associated with DECL may\n \t     have been set incorrectly.  For example, in:"}, {"sha": "dbfb12bb95b3958462e1d5c0a54adc260709eddf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/736b81007e965d4d1141dca6e45837d756741ddb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/736b81007e965d4d1141dca6e45837d756741ddb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=736b81007e965d4d1141dca6e45837d756741ddb", "patch": "@@ -1,3 +1,9 @@\n+2007-06-18  Simon Baldwin <simonb@google.com>\n+\n+\tPR c++/31923\n+\t* g++.dg/template/error25.C: New.\n+\t* g++.dg/template/spec35.C: New.\n+\n 2007-06-18  Kenneth Zadeck <zadeck@naturalbridge.com>\n \n \t* gcc.c-torture/compile/pr32355.c: New testcase."}, {"sha": "89011576e0437eefe7777fa11e31929756bb7248", "filename": "gcc/testsuite/g++.dg/template/error25.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/736b81007e965d4d1141dca6e45837d756741ddb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ferror25.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/736b81007e965d4d1141dca6e45837d756741ddb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ferror25.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ferror25.C?ref=736b81007e965d4d1141dca6e45837d756741ddb", "patch": "@@ -0,0 +1,16 @@\n+// PR c++/31923\n+\n+template<class T>\n+static void f1 ();\n+\n+template<>\n+static void f1<void> ();  // { dg-error \"explicit template specialization cannot have a storage class\" }\n+\n+template<class T>\n+extern void f2 ();\n+\n+template<>\n+extern void f2<void> ();  // { dg-error \"explicit template specialization cannot have a storage class\" }\n+\n+export template<class T>  // { dg-warning \"keyword 'export' not implemented\" }\n+static void* f3 ();"}, {"sha": "801b744dc2e1e24554d60dae94a701a43eb65b30", "filename": "gcc/testsuite/g++.dg/template/spec35.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/736b81007e965d4d1141dca6e45837d756741ddb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fspec35.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/736b81007e965d4d1141dca6e45837d756741ddb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fspec35.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fspec35.C?ref=736b81007e965d4d1141dca6e45837d756741ddb", "patch": "@@ -0,0 +1,29 @@\n+// PR c++/31923\n+// C++ DR 605 -- \"...the linkage of an explicit specialization must be that of\n+// the template.\"\n+\n+// { dg-require-weak \"\" }\n+// { dg-do compile { target i?86-*-* x86_64-*-* } }\n+\n+template<class T>\n+static void f1 (T) { }\n+\n+// { dg-final { scan-assembler-not \".glob(a|)l\\[\\t \\]*_Z2f1IfEvT_\" } }\n+template<>\n+void f1<float> (float) { }  // Expected to have static linkage\n+\n+template<class T>\n+void f2 (T) { }\n+\n+// { dg-final { scan-assembler \".glob(a|)l\\[\\t \\]*_Z2f2IfEvT_\" } }\n+template<>\n+void f2<float> (float) { }  // Expected to have global linkage\n+\n+void instantiator ()\n+{\n+  // { dg-final { scan-assembler-not \".glob(a|)l\\[\\t \\]*_Z2f1IiEvT_\" } }\n+  f1(0);  // Expected to have static linkage\n+\n+  // { dg-final { scan-assembler \".weak\\[\\t \\]*_Z2f2IiEvT_\" } }\n+  f2(0);  // Expected to have weak global linkage\n+}"}]}