{"sha": "f5c21ef3733d6a56ee3407ba8768abe551667f67", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjVjMjFlZjM3MzNkNmE1NmVlMzQwN2JhODc2OGFiZTU1MTY2N2Y2Nw==", "commit": {"author": {"name": "Anatoly Sokolov", "email": "aesok@post.ru", "date": "2010-06-05T17:27:51Z"}, "committer": {"name": "Anatoly Sokolov", "email": "aesok@gcc.gnu.org", "date": "2010-06-05T17:27:51Z"}, "message": "target.h (struct gcc_target): Add memory_move_cost field.\n\n\t* target.h (struct gcc_target): Add memory_move_cost field.\n\t* target-def.h (TARGET_MEMORY_MOVE_COST): New.\n\t(TARGET_INITIALIZER): Use TARGET_MEMORY_MOVE_COST.\n\t* targhooks.c (default_memory_move_cost): New function.\n\t* targhooks.h (default_memory_move_cost): Declare function.\n\t* reload.h (memory_move_cost): Declare.\n\t(memory_move_secondary_cost): Change type of 'in' argument to bool.\n\t* reginfo.c (memory_move_cost): New function.\n\t(memory_move_secondary_cost): Change type of 'in' argument to bool.\n\t* ira.h (ira_memory_move_cost): Update comment.\n\t* ira.c: (ira_memory_move_cost): Update comment.\n\t(setup_class_subset_and_memory_move_costs): Replace MEMORY_MOVE_COST\n\twith memory_move_cost.\n\t* postreload.c (reload_cse_simplify_set): (Ditto.).\n\t* reload1.c (choose_reload_regs): (Ditto.).\n\t* doc/tm.texi (TARGET_MEMORY_MOVE_COST): New.\n\t(MEMORY_MOVE_COST):  Revise documentation.\n\n\t* config/i386/i386.h (MEMORY_MOVE_COST): Remove macro.\n\t* config/i386/i386-protos.h (int ix86_memory_move_cost): Remove.\n\t* config/i386/i386.h (ix86_memory_move_cost): Make static. Change\n\ttype of 'in' argument to bool.\n\t(TARGET_MEMORY_MOVE_COST): Define.\n\nFrom-SVN: r160323", "tree": {"sha": "5acbb363779f56a111143ed54e7f8d18e54e8448", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5acbb363779f56a111143ed54e7f8d18e54e8448"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5c21ef3733d6a56ee3407ba8768abe551667f67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5c21ef3733d6a56ee3407ba8768abe551667f67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5c21ef3733d6a56ee3407ba8768abe551667f67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5c21ef3733d6a56ee3407ba8768abe551667f67/comments", "author": null, "committer": null, "parents": [{"sha": "da8c7675f93c3b8a955c07aee1fd7f2bd1d324fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da8c7675f93c3b8a955c07aee1fd7f2bd1d324fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da8c7675f93c3b8a955c07aee1fd7f2bd1d324fd"}], "stats": {"total": 137, "additions": 104, "deletions": 33}, "files": [{"sha": "eff2a56dd4509f10e576d0d0c6c5071203da55f0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5c21ef3733d6a56ee3407ba8768abe551667f67/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5c21ef3733d6a56ee3407ba8768abe551667f67/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f5c21ef3733d6a56ee3407ba8768abe551667f67", "patch": "@@ -1,3 +1,29 @@\n+2010-06-05  Anatoly Sokolov  <aesok@post.ru>\n+\n+\t* target.h (struct gcc_target): Add memory_move_cost field.\n+\t* target-def.h (TARGET_MEMORY_MOVE_COST): New.\n+\t(TARGET_INITIALIZER): Use TARGET_MEMORY_MOVE_COST.\n+\t* targhooks.c (default_memory_move_cost): New function.\n+\t* targhooks.h (default_memory_move_cost): Declare function.\n+\t* reload.h (memory_move_cost): Declare.\n+\t(memory_move_secondary_cost): Change type of 'in' argument to bool.\n+\t* reginfo.c (memory_move_cost): New function.\n+\t(memory_move_secondary_cost): Change type of 'in' argument to bool.\n+\t* ira.h (ira_memory_move_cost): Update comment.\n+\t* ira.c: (ira_memory_move_cost): Update comment.\n+\t(setup_class_subset_and_memory_move_costs): Replace MEMORY_MOVE_COST\n+\twith memory_move_cost.\n+\t* postreload.c (reload_cse_simplify_set): (Ditto.).\n+\t* reload1.c (choose_reload_regs): (Ditto.).\n+\t* doc/tm.texi (TARGET_MEMORY_MOVE_COST): New.\n+\t(MEMORY_MOVE_COST):  Revise documentation.\n+\n+\t* config/i386/i386.h (MEMORY_MOVE_COST): Remove macro.\n+\t* config/i386/i386-protos.h (int ix86_memory_move_cost): Remove.\n+\t* config/i386/i386.h (ix86_memory_move_cost): Make static. Change\n+\ttype of 'in' argument to bool.\n+\t(TARGET_MEMORY_MOVE_COST): Define.\n+\n 2010-06-05  Jan Hubicka  <jh@suse.cz>\n \n \t* ipa-pure-const.c (propagate): Fix type in handling functions"}, {"sha": "5bd8749645e19d37c667d2723784fee16ddb6556", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5c21ef3733d6a56ee3407ba8768abe551667f67/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5c21ef3733d6a56ee3407ba8768abe551667f67/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=f5c21ef3733d6a56ee3407ba8768abe551667f67", "patch": "@@ -157,7 +157,6 @@ extern bool ix86_cannot_change_mode_class (enum machine_mode,\n \t\t\t\t\t   enum machine_mode, enum reg_class);\n extern enum reg_class ix86_preferred_reload_class (rtx, enum reg_class);\n extern enum reg_class ix86_preferred_output_reload_class (rtx, enum reg_class);\n-extern int ix86_memory_move_cost (enum machine_mode, enum reg_class, int);\n extern int ix86_mode_needed (int, rtx);\n extern void emit_i387_cw_initialization (int);\n extern void x86_order_regs_for_local_alloc (void);"}, {"sha": "2a46f89cb248c31c643661ba2aad7bcf4229a7f2", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5c21ef3733d6a56ee3407ba8768abe551667f67/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5c21ef3733d6a56ee3407ba8768abe551667f67/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f5c21ef3733d6a56ee3407ba8768abe551667f67", "patch": "@@ -25580,10 +25580,11 @@ inline_memory_move_cost (enum machine_mode mode, enum reg_class regclass,\n     }\n }\n \n-int\n-ix86_memory_move_cost (enum machine_mode mode, enum reg_class regclass, int in)\n+static int\n+ix86_memory_move_cost (enum machine_mode mode, enum reg_class regclass,\n+\t\t       bool in)\n {\n-  return inline_memory_move_cost (mode, regclass, in);\n+  return inline_memory_move_cost (mode, regclass, in ? 1 : 0);\n }\n \n \n@@ -30742,6 +30743,8 @@ ix86_enum_va_list (int idx, const char **pname, tree *ptree)\n #undef TARGET_HANDLE_OPTION\n #define TARGET_HANDLE_OPTION ix86_handle_option\n \n+#undef TARGET_MEMORY_MOVE_COST\n+#define TARGET_MEMORY_MOVE_COST ix86_memory_move_cost\n #undef TARGET_RTX_COSTS\n #define TARGET_RTX_COSTS ix86_rtx_costs\n #undef TARGET_ADDRESS_COST"}, {"sha": "c3fc0e436db8baceedddc2500e2060c66fbd51cc", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5c21ef3733d6a56ee3407ba8768abe551667f67/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5c21ef3733d6a56ee3407ba8768abe551667f67/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=f5c21ef3733d6a56ee3407ba8768abe551667f67", "patch": "@@ -1903,17 +1903,6 @@ do {\t\t\t\t\t\t\t\\\n #define REGISTER_MOVE_COST(MODE, CLASS1, CLASS2) \\\n    ix86_register_move_cost ((MODE), (CLASS1), (CLASS2))\n \n-/* A C expression for the cost of moving data of mode M between a\n-   register and memory.  A value of 2 is the default; this cost is\n-   relative to those in `REGISTER_MOVE_COST'.\n-\n-   If moving between registers and memory is more expensive than\n-   between two registers, you should define this macro to express the\n-   relative cost.  */\n-\n-#define MEMORY_MOVE_COST(MODE, CLASS, IN)\t\\\n-  ix86_memory_move_cost ((MODE), (CLASS), (IN))\n-\n /* A C expression for the cost of a branch instruction.  A value of 1\n    is the default; other values are interpreted relative to that.  */\n "}, {"sha": "16a30a866dcbfbe70cd5758ef198e57f91cec283", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5c21ef3733d6a56ee3407ba8768abe551667f67/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5c21ef3733d6a56ee3407ba8768abe551667f67/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=f5c21ef3733d6a56ee3407ba8768abe551667f67", "patch": "@@ -6178,8 +6178,35 @@ secondary register in the conventional way but the default base value of\n 4 is not correct for your machine, define this macro to add some other\n value to the result of that function.  The arguments to that function\n are the same as to this macro.\n+\n+These macros are obsolete, new ports should use the target hook\n+@code{TARGET_MEMORY_MOVE_COST} instead.\n @end defmac\n \n+@deftypefn {Target Hook} int TARGET_MEMORY_MOVE_COST (enum machine_mode @var{mode}, enum reg_class @var{regclass}, bool @var{in})\n+This target hook should return the cost of moving data of mode @var{mode}\n+between a register of class @var{class} and memory; @var{in} is @code{false}\n+if the value is to be written to memory, @code{true} if it is to be read in.\n+This cost is relative to those in @code{REGISTER_MOVE_COST}.  If moving\n+between registers and memory is more expensive than between two registers,\n+you should add this target hook to express the relative cost.\n+\n+If you do not add this target hook, GCC uses a default cost of 4 plus\n+the cost of copying via a secondary reload register, if one is\n+needed.  If your machine requires a secondary reload register to copy\n+between memory and a register of @var{class} but the reload mechanism is\n+more complex than copying via an intermediate, use this target hook to\n+reflect the actual cost of the move.\n+\n+GCC defines the function @code{memory_move_secondary_cost} if\n+secondary reloads are needed.  It computes the costs due to copying via\n+a secondary register.  If your machine copies from memory using a\n+secondary register in the conventional way but the default base value of\n+4 is not correct for your machine, use this target hook to add some other\n+value to the result of that function.  The arguments to that function\n+are the same as to this target hook.\n+@end deftypefn\n+\n @defmac BRANCH_COST (@var{speed_p}, @var{predictable_p})\n A C expression for the cost of a branch instruction.  A value of 1 is the\n default; other values are interpreted relative to that. Parameter @var{speed_p}"}, {"sha": "843095dbb935e9fe1490aad5663b8a269c2703be", "filename": "gcc/ira.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5c21ef3733d6a56ee3407ba8768abe551667f67/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5c21ef3733d6a56ee3407ba8768abe551667f67/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=f5c21ef3733d6a56ee3407ba8768abe551667f67", "patch": "@@ -358,9 +358,10 @@ HARD_REG_SET eliminable_regset;\n    of given mode starting with given hard register.  */\n HARD_REG_SET ira_reg_mode_hard_regset[FIRST_PSEUDO_REGISTER][NUM_MACHINE_MODES];\n \n-/* The following two variables are array analogs of the macros\n-   MEMORY_MOVE_COST and REGISTER_MOVE_COST.  */\n+/* Array analogous to target hook TARGET_MEMORY_MOVE_COST.  */\n short int ira_memory_move_cost[MAX_MACHINE_MODE][N_REG_CLASSES][2];\n+\n+/* Array analogous to macro REGISTER_MOVE_COST.  */\n move_table *ira_register_move_cost[MAX_MACHINE_MODE];\n \n /* Similar to may_move_in_cost but it is calculated in IRA instead of\n@@ -527,11 +528,11 @@ setup_class_subset_and_memory_move_costs (void)\n \tfor (mode = 0; mode < MAX_MACHINE_MODE; mode++)\n \t  {\n \t    ira_memory_move_cost[mode][cl][0] =\n-\t      MEMORY_MOVE_COST ((enum machine_mode) mode,\n-\t\t\t\t(enum reg_class) cl, 0);\n+\t      memory_move_cost ((enum machine_mode) mode,\n+\t\t\t\t(enum reg_class) cl, false);\n \t    ira_memory_move_cost[mode][cl][1] =\n-\t      MEMORY_MOVE_COST ((enum machine_mode) mode,\n-\t\t\t\t(enum reg_class) cl, 1);\n+\t      memory_move_cost ((enum machine_mode) mode,\n+\t\t\t\t(enum reg_class) cl, true);\n \t    /* Costs for NO_REGS are used in cost calculation on the\n \t       1st pass when the preferred register classes are not\n \t       known yet.  In this case we take the best scenario.  */"}, {"sha": "12b4b42017ad13c6d5d71699f3539f8196a57aab", "filename": "gcc/ira.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5c21ef3733d6a56ee3407ba8768abe551667f67/gcc%2Fira.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5c21ef3733d6a56ee3407ba8768abe551667f67/gcc%2Fira.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.h?ref=f5c21ef3733d6a56ee3407ba8768abe551667f67", "patch": "@@ -58,7 +58,7 @@ extern HARD_REG_SET ira_no_alloc_regs;\n    mode or when the conflict table is too big.  */\n extern bool ira_conflicts_p;\n \n-/* Array analogous to macro MEMORY_MOVE_COST.  */\n+/* Array analogous to target hook TARGET_MEMORY_MOVE_COST.  */\n extern short ira_memory_move_cost[MAX_MACHINE_MODE][N_REG_CLASSES][2];\n \n /* Array of number of hard registers of given class which are"}, {"sha": "c165b5245f178666c961fede87aadc76ec6376c4", "filename": "gcc/postreload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5c21ef3733d6a56ee3407ba8768abe551667f67/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5c21ef3733d6a56ee3407ba8768abe551667f67/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=f5c21ef3733d6a56ee3407ba8768abe551667f67", "patch": "@@ -262,7 +262,7 @@ reload_cse_simplify_set (rtx set, rtx insn)\n \n   /* If memory loads are cheaper than register copies, don't change them.  */\n   if (MEM_P (src))\n-    old_cost = MEMORY_MOVE_COST (GET_MODE (src), dclass, 1);\n+    old_cost = memory_move_cost (GET_MODE (src), dclass, true);\n   else if (REG_P (src))\n     old_cost = REGISTER_MOVE_COST (GET_MODE (src),\n \t\t\t\t   REGNO_REG_CLASS (REGNO (src)), dclass);"}, {"sha": "66e774a30c2d526a80839f618f0dfa00e890e30e", "filename": "gcc/reginfo.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5c21ef3733d6a56ee3407ba8768abe551667f67/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5c21ef3733d6a56ee3407ba8768abe551667f67/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=f5c21ef3733d6a56ee3407ba8768abe551667f67", "patch": "@@ -681,12 +681,18 @@ init_fake_stack_mems (void)\n     top_of_stack[i] = gen_rtx_MEM ((enum machine_mode) i, stack_pointer_rtx);\n }\n \n+/* Compute cost of moving registers to/from memory.  */\n+int\n+memory_move_cost (enum machine_mode mode, enum reg_class rclass, bool in)\n+{\n+  return targetm.memory_move_cost (mode, rclass, in);\n+}\n \n /* Compute extra cost of moving registers to/from memory due to reloads.\n    Only needed if secondary reloads are required for memory moves.  */\n int\n memory_move_secondary_cost (enum machine_mode mode, enum reg_class rclass,\n-\t\t\t    int in)\n+\t\t\t    bool in)\n {\n   enum reg_class altclass;\n   int partial_cost = 0;\n@@ -706,8 +712,8 @@ memory_move_secondary_cost (enum machine_mode mode, enum reg_class rclass,\n \n   if (rclass == altclass)\n     /* This isn't simply a copy-to-temporary situation.  Can't guess\n-       what it is, so MEMORY_MOVE_COST really ought not to be calling\n-       here in that case.\n+       what it is, so TARGET_MEMORY_MOVE_COST really ought not to be\n+       calling here in that case.\n \n        I'm tempted to put in an assert here, but returning this will\n        probably only give poor estimates, which is what we would've"}, {"sha": "4625bf7fc19290cc037bbf41b4b5a2d4c6105e3e", "filename": "gcc/reload.h", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5c21ef3733d6a56ee3407ba8768abe551667f67/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5c21ef3733d6a56ee3407ba8768abe551667f67/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=f5c21ef3733d6a56ee3407ba8768abe551667f67", "patch": "@@ -30,12 +30,9 @@ along with GCC; see the file COPYING3.  If not see\n   SECONDARY_RELOAD_CLASS (CLASS, MODE, X)\n #endif\n \n-/* If MEMORY_MOVE_COST isn't defined, give it a default here.  */\n-#ifndef MEMORY_MOVE_COST\n-#define MEMORY_MOVE_COST(MODE,CLASS,IN) \\\n-  (4 + memory_move_secondary_cost ((MODE), (CLASS), (IN)))\n-#endif\n-extern int memory_move_secondary_cost (enum machine_mode, enum reg_class, int);\n+extern int memory_move_cost (enum machine_mode, enum reg_class, bool);\n+extern int memory_move_secondary_cost (enum machine_mode, enum reg_class,\n+\t\t\t\t       bool);\n \n /* Maximum number of reloads we can need.  */\n #define MAX_RELOADS (2 * MAX_RECOG_OPERANDS * (MAX_REGS_PER_ADDRESS + 1))"}, {"sha": "f3d61c66a988d0b766bbc827cebadf119ddb9615", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5c21ef3733d6a56ee3407ba8768abe551667f67/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5c21ef3733d6a56ee3407ba8768abe551667f67/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=f5c21ef3733d6a56ee3407ba8768abe551667f67", "patch": "@@ -6501,7 +6501,7 @@ choose_reload_regs (struct insn_chain *chain)\n \t\t\t     if copying it to the desired class is cheap\n \t\t\t     enough.  */\n \t\t\t  || ((REGISTER_MOVE_COST (mode, last_class, rclass)\n-\t\t\t       < MEMORY_MOVE_COST (mode, rclass, 1))\n+\t\t\t       < memory_move_cost (mode, rclass, true))\n \t\t\t      && (secondary_reload_class (1, rclass, mode,\n \t\t\t\t\t\t\t  last_reg)\n \t\t\t\t  == NO_REGS)"}, {"sha": "5a088bcd4dc6f7fffe67a8efa4fed56d44ec6a29", "filename": "gcc/target-def.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5c21ef3733d6a56ee3407ba8768abe551667f67/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5c21ef3733d6a56ee3407ba8768abe551667f67/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=f5c21ef3733d6a56ee3407ba8768abe551667f67", "patch": "@@ -468,6 +468,10 @@\n #define TARGET_ADDRESS_COST default_address_cost\n #define TARGET_CONST_ANCHOR 0\n \n+#ifndef TARGET_MEMORY_MOVE_COST\n+#define TARGET_MEMORY_MOVE_COST default_memory_move_cost\n+#endif\n+\n /* In builtins.c.  */\n #define TARGET_INIT_BUILTINS hook_void_void\n #define TARGET_EXPAND_BUILTIN default_expand_builtin\n@@ -1017,6 +1021,7 @@\n   TARGET_ADDR_SPACE_HOOKS,\t\t\t\\\n   TARGET_SCALAR_MODE_SUPPORTED_P,\t\t\\\n   TARGET_VECTOR_MODE_SUPPORTED_P,               \\\n+  TARGET_MEMORY_MOVE_COST, \t\t\t\\\n   TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P,\t\\\n   TARGET_RTX_COSTS,\t\t\t\t\\\n   TARGET_ADDRESS_COST,\t\t\t\t\\"}, {"sha": "4e2bf984cb189c96315cd0be37c620c3624572ba", "filename": "gcc/target.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5c21ef3733d6a56ee3407ba8768abe551667f67/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5c21ef3733d6a56ee3407ba8768abe551667f67/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=f5c21ef3733d6a56ee3407ba8768abe551667f67", "patch": "@@ -791,6 +791,9 @@ struct gcc_target\n      for further details.  */\n   bool (* vector_mode_supported_p) (enum machine_mode mode);\n \n+  /* Compute cost of moving registers to/from memory.  */\n+  int (* memory_move_cost) (enum machine_mode, enum reg_class, bool);\n+\n   /* True for MODE if the target expects that registers in this mode will\n      be allocated to registers in a small register class.  The compiler is\n      allowed to use registers explicitly used in the rtl as spill registers"}, {"sha": "3dccae267f77a60c61eac13bacfff30c8677a5cc", "filename": "gcc/targhooks.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5c21ef3733d6a56ee3407ba8768abe551667f67/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5c21ef3733d6a56ee3407ba8768abe551667f67/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=f5c21ef3733d6a56ee3407ba8768abe551667f67", "patch": "@@ -1088,4 +1088,18 @@ default_have_conditional_execution (void)\n #endif\n }\n \n+/* Compute cost of moving registers to/from memory.  */\n+\n+int\n+default_memory_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t  enum reg_class rclass ATTRIBUTE_UNUSED,\n+\t\t\t  bool in ATTRIBUTE_UNUSED)\n+{\n+#ifndef MEMORY_MOVE_COST\n+    return (4 + memory_move_secondary_cost (mode, rclass, in));\n+#else\n+    return MEMORY_MOVE_COST (mode, rclass, in);\n+#endif\n+}\n+\n #include \"gt-targhooks.h\""}, {"sha": "efc8a981c68bfb4af8a3c3fa423d03e20f8d18be", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5c21ef3733d6a56ee3407ba8768abe551667f67/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5c21ef3733d6a56ee3407ba8768abe551667f67/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=f5c21ef3733d6a56ee3407ba8768abe551667f67", "patch": "@@ -137,3 +137,4 @@ extern bool default_addr_space_subset_p (addr_space_t, addr_space_t);\n extern rtx default_addr_space_convert (rtx, tree, tree);\n extern unsigned int default_case_values_threshold (void);\n extern bool default_have_conditional_execution (void);\n+extern int default_memory_move_cost (enum machine_mode, enum reg_class, bool);"}]}