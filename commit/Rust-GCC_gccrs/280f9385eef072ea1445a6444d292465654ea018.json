{"sha": "280f9385eef072ea1445a6444d292465654ea018", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjgwZjkzODVlZWYwNzJlYTE0NDVhNjQ0NGQyOTI0NjU2NTRlYTAxOA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-04-16T13:16:50Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-04-16T13:16:50Z"}, "message": "cp-tree.h (TREE_NONLOCAL_FLAG): Remove.\n\n\t* cp-tree.h (TREE_NONLOCAL_FLAG): Remove.\n\t(storetags): Declare.\n\t* class.c (finish_struct): Don't use TREE_NONLOCAL_FLAG.\n\t(pushclass): Likewise.  Use storetags to install tag declarations,\n\tnot pushtag.\n\t(invalidate_class_lookup_cache): Don't use TREE_NONLOCAL_FLAG.\n\t* decl.c (storetags): Make it global.\n\t(push_class_binding): Set INHERITED_VALUE_BINDING_P for an\n\timplicit typename declaration.\n\t(pushtag): Tidy.  Don't use TREE_NONLOCAL_FLAG.\n\t* method.c (hack_identifier): Likewise.\n\t* search.c (lookup_member): Likewise.\n\nFrom-SVN: r26491", "tree": {"sha": "0c1e8514e7ad5e47650495d973375000e5bd046e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c1e8514e7ad5e47650495d973375000e5bd046e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/280f9385eef072ea1445a6444d292465654ea018", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/280f9385eef072ea1445a6444d292465654ea018", "html_url": "https://github.com/Rust-GCC/gccrs/commit/280f9385eef072ea1445a6444d292465654ea018", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/280f9385eef072ea1445a6444d292465654ea018/comments", "author": null, "committer": null, "parents": [{"sha": "5e651bf2435e8bf24a2263f83ae2c21dd2ce5fac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e651bf2435e8bf24a2263f83ae2c21dd2ce5fac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e651bf2435e8bf24a2263f83ae2c21dd2ce5fac"}], "stats": {"total": 182, "additions": 106, "deletions": 76}, "files": [{"sha": "b7b3a85d98042b3d62be0097e7342b705913f851", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280f9385eef072ea1445a6444d292465654ea018/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280f9385eef072ea1445a6444d292465654ea018/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=280f9385eef072ea1445a6444d292465654ea018", "patch": "@@ -1,5 +1,18 @@\n 1999-04-16  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* cp-tree.h (TREE_NONLOCAL_FLAG): Remove.\n+\t(storetags): Declare.\n+\t* class.c (finish_struct): Don't use TREE_NONLOCAL_FLAG.\n+\t(pushclass): Likewise.  Use storetags to install tag declarations,\n+\tnot pushtag.\n+\t(invalidate_class_lookup_cache): Don't use TREE_NONLOCAL_FLAG.\n+\t* decl.c (storetags): Make it global.\n+\t(push_class_binding): Set INHERITED_VALUE_BINDING_P for an\n+\timplicit typename declaration.\n+\t(pushtag): Tidy.  Don't use TREE_NONLOCAL_FLAG.\n+\t* method.c (hack_identifier): Likewise.\n+\t* search.c (lookup_member): Likewise.\n+\t\n \t* decl.c (warn_about_implicit_typename_lookup): New function.\n \t(lookup_name_real): Use it.  Rework handling of implicit typename\n \textension."}, {"sha": "cc23b29cc134e2282b0e0d0947223ecc271401b0", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 30, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280f9385eef072ea1445a6444d292465654ea018/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280f9385eef072ea1445a6444d292465654ea018/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=280f9385eef072ea1445a6444d292465654ea018", "patch": "@@ -4185,10 +4185,6 @@ finish_struct (t, attributes, warn_anon)\n      as necessary.  */\n   unreverse_member_declarations (t);\n \n-  /* Mark all the tags in the class as class-local.  */\n-  for (x = CLASSTYPE_TAGS (t); x; x = TREE_CHAIN (x))\n-    TREE_NONLOCAL_FLAG (TREE_VALUE (x)) = 0;\n-\n   cplus_decl_attributes (t, attributes, NULL_TREE);\n \n   if (processing_template_decl)\n@@ -4511,17 +4507,7 @@ pushclass (type, modify)\n \t  unuse_fields (type);\n \t}\n \n-      for (tags = CLASSTYPE_TAGS (type); tags; tags = TREE_CHAIN (tags))\n-\t{\n-\t  tree tag_type = TREE_VALUE (tags);\n-\n-\t  TREE_NONLOCAL_FLAG (tag_type) = 1;\n-\t  if (! TREE_PURPOSE (tags))\n-\t    continue;\n-\t  if (! (IS_AGGR_TYPE_CODE (TREE_CODE (tag_type))\n-\t\t && CLASSTYPE_IS_TEMPLATE (tag_type)))\n-\t    pushtag (TREE_PURPOSE (tags), tag_type, 0);\n-\t}\n+      storetags (CLASSTYPE_TAGS (type));\n     }\n }\n \n@@ -4541,11 +4527,6 @@ invalidate_class_lookup_cache ()\n      them.  This is it!  */\n   for (t = previous_class_values; t; t = TREE_CHAIN (t))\n     IDENTIFIER_CLASS_VALUE (TREE_PURPOSE (t)) = NULL_TREE;\n-  while (tags)\n-    {\n-      TREE_NONLOCAL_FLAG (TREE_VALUE (tags)) = 0;\n-      tags = TREE_CHAIN (tags);\n-    }\n   \n   previous_class_type = NULL_TREE;\n }\n@@ -4556,16 +4537,6 @@ invalidate_class_lookup_cache ()\n void\n popclass ()\n {\n-  /* Just remove from this class what didn't make\n-\t it into IDENTIFIER_CLASS_VALUE.  */\n-  tree tags = CLASSTYPE_TAGS (current_class_type);\n-\n-  while (tags)\n-    {\n-      TREE_NONLOCAL_FLAG (TREE_VALUE (tags)) = 0;\n-      tags = TREE_CHAIN (tags);\n-    }\n-\n   poplevel (1, 0, 0);\n   /* Since poplevel_class does the popping of class decls nowadays,\n      this really only frees the obstack used for these decls.  */"}, {"sha": "282d1fa5324f72865171edf553c12b9c5316f471", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280f9385eef072ea1445a6444d292465654ea018/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280f9385eef072ea1445a6444d292465654ea018/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=280f9385eef072ea1445a6444d292465654ea018", "patch": "@@ -23,8 +23,7 @@ Boston, MA 02111-1307, USA.  */\n #define _CP_TREE_H\n \n /* Usage of TREE_LANG_FLAG_?:\n-   0: TREE_NONLOCAL_FLAG (in TREE_LIST or _TYPE).\n-      BINFO_MARKED (BINFO nodes).\n+   0: BINFO_MARKED (BINFO nodes).\n       COMPOUND_STMT_NO_SCOPE (in COMPOUND_STMT).\n       NEW_EXPR_USE_GLOBAL (in NEW_EXPR).\n       DELETE_EXPR_USE_GLOBAL (in DELETE_EXPR).\n@@ -803,9 +802,6 @@ struct lang_type\n   (TYPE_NEEDS_DESTRUCTOR (NODE) \\\n    || (TYPE_LANG_SPECIFIC (NODE) && TYPE_VEC_DELETE_TAKES_SIZE (NODE)))\n \n-/* Nonzero for TREE_LIST or _TYPE node means that this node is class-local.  */\n-#define TREE_NONLOCAL_FLAG(NODE) (TREE_LANG_FLAG_0 (NODE))\n-\n /* Nonzero means that this _CLASSTYPE node defines ways of converting\n    itself to other types.  */\n #define TYPE_HAS_CONVERSION(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_type_conversion)\n@@ -2885,6 +2881,7 @@ extern int push_class_binding                   PROTO((tree, tree));\n extern tree check_default_argument              PROTO((tree, tree));\n extern tree push_overloaded_decl\t\tPROTO((tree, int));\n extern void clear_identifier_class_values       PROTO((void));\n+extern void storetags                           PROTO((tree));\n \n /* in decl2.c */\n extern int check_java_method\t\t\tPROTO((tree));"}, {"sha": "d1f722cdb1965f79b9c7f94141a4ed9723d78c6c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 44, "deletions": 37, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280f9385eef072ea1445a6444d292465654ea018/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280f9385eef072ea1445a6444d292465654ea018/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=280f9385eef072ea1445a6444d292465654ea018", "patch": "@@ -148,7 +148,6 @@ static struct binding_level *make_binding_level PROTO((void));\n static void declare_namespace_level PROTO((void));\n static void signal_catch PROTO((int)) ATTRIBUTE_NORETURN;\n static void storedecls PROTO((tree));\n-static void storetags PROTO((tree));\n static void require_complete_types_for_parms PROTO((tree));\n static void push_overloaded_decl_1 PROTO((tree));\n static int ambi_op_p PROTO((tree));\n@@ -1231,19 +1230,29 @@ push_class_binding (id, decl)\n   binding = IDENTIFIER_BINDING (id);\n   if (BINDING_VALUE (binding) == decl && TREE_CODE (decl) != TREE_LIST)\n     {\n-      if (TREE_CODE (decl) == OVERLOAD)\n-\tcontext = DECL_REAL_CONTEXT (OVL_CURRENT (decl));\n+      /* Any implicit typename must be from a base-class.  The\n+\t context for an implicit typename declaration is always\n+\t the derived class in which the lookup was done, so the checks\n+\t based on the context of DECL below will not trigger.  */\n+      if (TREE_CODE (decl) == TYPE_DECL \n+\t  && IMPLICIT_TYPENAME_P (TREE_TYPE (decl)))\n+\tINHERITED_VALUE_BINDING_P (binding) = 1;\n       else\n \t{\n-\t  my_friendly_assert (TREE_CODE_CLASS (TREE_CODE (decl)) == 'd',\n-\t\t\t      0);\n-\t  context = DECL_REAL_CONTEXT (decl);\n-\t}\n+\t  if (TREE_CODE (decl) == OVERLOAD)\n+\t    context = DECL_REAL_CONTEXT (OVL_CURRENT (decl));\n+\t  else\n+\t    {\n+\t      my_friendly_assert (TREE_CODE_CLASS (TREE_CODE (decl)) == 'd',\n+\t\t\t\t  0);\n+\t      context = DECL_REAL_CONTEXT (decl);\n+\t    }\n \n-      if (is_properly_derived_from (current_class_type, context))\n-\tINHERITED_VALUE_BINDING_P (binding) = 1;\n-      else\n-\tINHERITED_VALUE_BINDING_P (binding) = 0;\n+\t  if (is_properly_derived_from (current_class_type, context))\n+\t    INHERITED_VALUE_BINDING_P (binding) = 1;\n+\t  else\n+\t    INHERITED_VALUE_BINDING_P (binding) = 0;\n+\t}\n     }\n   else if (BINDING_VALUE (binding) == decl)\n     /* We only encounter a TREE_LIST when push_class_decls detects an\n@@ -2616,7 +2625,6 @@ maybe_process_template_type_declaration (type, globalize, b)\n \t\t binding level, but is instead the pseudo-global level.  */\n \t      b->level_chain->tags = \n \t\tsaveable_tree_cons (name, type, b->level_chain->tags);\n-\t      TREE_NONLOCAL_FLAG (type) = 1;\n \t      if (TYPE_SIZE (current_class_type) == NULL_TREE)\n \t\tCLASSTYPE_TAGS (current_class_type) = b->level_chain->tags;\n \t    }\n@@ -2637,8 +2645,6 @@ pushtag (name, type, globalize)\n      int globalize;\n {\n   register struct binding_level *b;\n-  tree context = 0;\n-  tree c_decl = 0;\n \n   b = current_binding_level;\n   while (b->tag_transparent\n@@ -2652,32 +2658,34 @@ pushtag (name, type, globalize)\n \n   if (name)\n     {\n-      context = type ? TYPE_CONTEXT (type) : NULL_TREE;\n-      if (! context)\n-\t{\n-\t  tree cs = current_scope ();\n-\n-\t  if (! globalize)\n-\t    context = cs;\n-\t  else if (cs != NULL_TREE \n-\t\t   && TREE_CODE_CLASS (TREE_CODE (cs)) == 't')\n-\t    /* When declaring a friend class of a local class, we want\n-\t       to inject the newly named class into the scope\n-\t       containing the local class, not the namespace scope.  */\n-\t    context = hack_decl_function_context (get_type_decl (cs));\n-\t}\n-      if (context)\n-\tc_decl = TREE_CODE (context) == FUNCTION_DECL\n-\t  ? context : TYPE_MAIN_DECL (context);\n-\n-      if (!context)\n-\tcontext = current_namespace;\n-\n       /* Do C++ gratuitous typedefing.  */\n       if (IDENTIFIER_TYPE_VALUE (name) != type)\n         {\n           register tree d = NULL_TREE;\n \t  int newdecl = 0, in_class = 0;\n+\t  tree context;\n+\t  tree c_decl = NULL_TREE;\n+\n+\t  context = type ? TYPE_CONTEXT (type) : NULL_TREE;\n+\t  if (! context)\n+\t    {\n+\t      tree cs = current_scope ();\n+\n+\t      if (! globalize)\n+\t\tcontext = cs;\n+\t      else if (cs != NULL_TREE \n+\t\t       && TREE_CODE_CLASS (TREE_CODE (cs)) == 't')\n+\t\t/* When declaring a friend class of a local class, we want\n+\t\t   to inject the newly named class into the scope\n+\t\t   containing the local class, not the namespace scope.  */\n+\t\tcontext = hack_decl_function_context (get_type_decl (cs));\n+\t    }\n+\t  if (context)\n+\t    c_decl = TREE_CODE (context) == FUNCTION_DECL\n+\t      ? context : TYPE_MAIN_DECL (context);\n+\n+\t  if (!context)\n+\t    context = current_namespace;\n \n \t  if ((b->pseudo_global && b->level_chain->parm_flag == 2)\n \t      || b->parm_flag == 2)\n@@ -2732,7 +2740,6 @@ pushtag (name, type, globalize)\n         }\n       if (b->parm_flag == 2)\n \t{\n-\t  TREE_NONLOCAL_FLAG (type) = 1;\n \t  if (TYPE_SIZE (current_class_type) == NULL_TREE)\n \t    CLASSTYPE_TAGS (current_class_type) = b->tags;\n \t}\n@@ -4931,7 +4938,7 @@ storedecls (decls)\n \n /* Similarly, store the list of tags of the current level.  */\n \n-static void\n+void\n storetags (tags)\n      tree tags;\n {"}, {"sha": "39f7f0419370daee2fcc26670ecbbf62bebc0978", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280f9385eef072ea1445a6444d292465654ea018/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280f9385eef072ea1445a6444d292465654ea018/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=280f9385eef072ea1445a6444d292465654ea018", "patch": "@@ -2007,7 +2007,8 @@ hack_identifier (value, name)\n \t    return error_mark_node;\n \t}\n     }\n-  else if (TREE_CODE (value) == TREE_LIST && TREE_NONLOCAL_FLAG (value))\n+  else if (TREE_CODE (value) == TREE_LIST \n+\t   && TREE_TYPE (value) == error_mark_node)\n     {\n       error (\"request for member `%s' is ambiguous in multiple inheritance lattice\",\n \t     IDENTIFIER_POINTER (name));"}, {"sha": "74b9c2de0aea905e835f84732e9780bbc86c3a43", "filename": "gcc/cp/search.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280f9385eef072ea1445a6444d292465654ea018/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280f9385eef072ea1445a6444d292465654ea018/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=280f9385eef072ea1445a6444d292465654ea018", "patch": "@@ -1406,9 +1406,9 @@ lookup_member (xbasetype, name, protect, want_type)\n     {\n       if (lfi.ambiguous)\n \t{\n-\t  /* This flag tells hack_identifier that the lookup is\n-\t     ambiguous.  */\n-\t  TREE_NONLOCAL_FLAG (lfi.ambiguous) = 1;\n+\t  /* An ERROR_MARK for the TREE_TYPE tells hack_identifier\n+\t     that the lookup is ambiguous.  */\n+\t  TREE_TYPE (lfi.ambiguous) = error_mark_node;\n \t  return scratch_tree_cons (error_mark_node,\n \t\t\t\t    lfi.ambiguous,\n \t\t\t\t    NULL_TREE);"}, {"sha": "0f6c4fc1ef454d6a6b00b04c5788121d997b6230", "filename": "gcc/testsuite/g++.old-deja/g++.pt/typename20.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280f9385eef072ea1445a6444d292465654ea018/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280f9385eef072ea1445a6444d292465654ea018/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename20.C?ref=280f9385eef072ea1445a6444d292465654ea018", "patch": "@@ -0,0 +1,16 @@\n+// Build don't link:\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+// Special g++ Options:\n+\n+template <class T>\n+struct B {\n+  typedef int I;\n+};\n+\n+template <class T, class X = int>\n+struct S : public B <T> {\n+  struct I {\n+  };\n+\n+  void f(int i = true) {}\n+};"}, {"sha": "2dc52aa429ae31547ed359ddddddc9950ca0b940", "filename": "gcc/testsuite/g++.old-deja/g++.pt/typename21.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280f9385eef072ea1445a6444d292465654ea018/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename21.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280f9385eef072ea1445a6444d292465654ea018/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename21.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename21.C?ref=280f9385eef072ea1445a6444d292465654ea018", "patch": "@@ -0,0 +1,25 @@\n+// Build don't link:\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+// Special g++ Options:\n+\n+template <class T>\n+struct S1 {\n+  typedef T X;\n+};\n+\n+template <class T>\n+struct B {\n+  typedef T I;\n+};\n+\n+template <class T>\n+struct S2 : public B<T> {\n+  struct I {};\n+\n+  typedef typename S1<I>::X IX;\n+\n+  void f(IX);\n+};\n+\n+template <class T>\n+void S2<T>::f(IX) {}"}]}