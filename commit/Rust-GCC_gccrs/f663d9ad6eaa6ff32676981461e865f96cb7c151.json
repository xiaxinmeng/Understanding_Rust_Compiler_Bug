{"sha": "f663d9ad6eaa6ff32676981461e865f96cb7c151", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjY2M2Q5YWQ2ZWFhNmZmMzI2NzY5ODE0NjFlODY1Zjk2Y2I3YzE1MQ==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2016-10-28T14:18:50Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2016-10-28T14:18:50Z"}, "message": "GIMPLE store merging pass\n\n2016-10-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n\n\tPR middle-end/22141\n\t* Makefile.in (OBJS): Add gimple-ssa-store-merging.o.\n\t* common.opt (fstore-merging): New Optimization option.\n\t* opts.c (default_options_table): Add entry for\n\tOPT_ftree_store_merging.\n\t* fold-const.h (can_native_encode_type_p): Declare prototype.\n\t* fold-const.c (can_native_encode_type_p): Define.\n\t* params.def (PARAM_STORE_MERGING_ALLOW_UNALIGNED): Define.\n\t(PARAM_MAX_STORES_TO_MERGE): Likewise.\n\t* timevar.def (TV_GIMPLE_STORE_MERGING): New timevar.\n\t* passes.def: Insert pass_tree_store_merging.\n\t* tree-pass.h (make_pass_store_merging): Declare extern\n\tprototype.\n\t* gimple-ssa-store-merging.c: New file.\n\t* doc/invoke.texi (Optimization Options): Document\n\t-fstore-merging.\n\t(--param documentation): Document store-merging-allow-unaligned\n\tand max-stores-to-merge.\n\n2016-10-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n            Jakub Jelinek  <jakub@redhat.com>\n            Andrew Pinski  <pinskia@gmail.com>\n\n\tPR middle-end/22141\n\tPR rtl-optimization/23684\n\t* gcc.c-torture/execute/pr22141-1.c: New test.\n\t* gcc.c-torture/execute/pr22141-2.c: Likewise.\n\t* gcc.target/aarch64/ldp_stp_1.c: Adjust for -fstore-merging.\n\t* gcc.target/aarch64/ldp_stp_4.c: Likewise.\n\t* gcc.dg/store_merging_1.c: New test.\n\t* gcc.dg/store_merging_2.c: Likewise.\n\t* gcc.dg/store_merging_3.c: Likewise.\n\t* gcc.dg/store_merging_4.c: Likewise.\n\t* gcc.dg/store_merging_5.c: Likewise.\n\t* gcc.dg/store_merging_6.c: Likewise.\n\t* gcc.dg/store_merging_7.c: Likewise.\n\t* gcc.target/i386/pr22141.c: Likewise.\n\t* gcc.target/i386/pr34012.c: Add -fno-store-merging to dg-options.\n\t* g++.dg/init/new17.C: Likewise.\n\n\n\nCo-Authored-By: Andrew Pinski <pinskia@gmail.com>\nCo-Authored-By: Jakub Jelinek <jakub@redhat.com>\n\nFrom-SVN: r241649", "tree": {"sha": "c6b6f30f38de29c8fcc46fc859446438b55c447f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6b6f30f38de29c8fcc46fc859446438b55c447f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f663d9ad6eaa6ff32676981461e865f96cb7c151", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f663d9ad6eaa6ff32676981461e865f96cb7c151", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f663d9ad6eaa6ff32676981461e865f96cb7c151", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f663d9ad6eaa6ff32676981461e865f96cb7c151/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1f5700e95225d0a95cae2f96c17699c4d133f5e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f5700e95225d0a95cae2f96c17699c4d133f5e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f5700e95225d0a95cae2f96c17699c4d133f5e0"}], "stats": {"total": 2299, "additions": 2264, "deletions": 35}, "files": [{"sha": "5b6467293d12a1980a5fdee31090da14090c48e6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f663d9ad6eaa6ff32676981461e865f96cb7c151", "patch": "@@ -1,3 +1,24 @@\n+2016-10-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\tPR middle-end/22141\n+\t* Makefile.in (OBJS): Add gimple-ssa-store-merging.o.\n+\t* common.opt (fstore-merging): New Optimization option.\n+\t* opts.c (default_options_table): Add entry for\n+\tOPT_ftree_store_merging.\n+\t* fold-const.h (can_native_encode_type_p): Declare prototype.\n+\t* fold-const.c (can_native_encode_type_p): Define.\n+\t* params.def (PARAM_STORE_MERGING_ALLOW_UNALIGNED): Define.\n+\t(PARAM_MAX_STORES_TO_MERGE): Likewise.\n+\t* timevar.def (TV_GIMPLE_STORE_MERGING): New timevar.\n+\t* passes.def: Insert pass_tree_store_merging.\n+\t* tree-pass.h (make_pass_store_merging): Declare extern\n+\tprototype.\n+\t* gimple-ssa-store-merging.c: New file.\n+\t* doc/invoke.texi (Optimization Options): Document\n+\t-fstore-merging.\n+\t(--param documentation): Document store-merging-allow-unaligned\n+\tand max-stores-to-merge.\n+\n 2016-10-28  Will Schmidt <will_schmidt@vnet.ibm.com>\n \n \tPR middle-end/72747"}, {"sha": "622d038f6fb50c35ff48bc84a69967071aa17e90", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f663d9ad6eaa6ff32676981461e865f96cb7c151", "patch": "@@ -1296,6 +1296,7 @@ OBJS = \\\n \tgimple-ssa-isolate-paths.o \\\n \tgimple-ssa-nonnull-compare.o \\\n \tgimple-ssa-split-paths.o \\\n+\tgimple-ssa-store-merging.o \\\n \tgimple-ssa-strength-reduction.o \\\n \tgimple-ssa-sprintf.o \\\n \tgimple-ssa-warn-alloca.o \\"}, {"sha": "20dbfc1d6a1a496292d40ba904bb1eff441e03c4", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=f663d9ad6eaa6ff32676981461e865f96cb7c151", "patch": "@@ -1463,6 +1463,10 @@ fstrict-volatile-bitfields\n Common Report Var(flag_strict_volatile_bitfields) Init(-1) Optimization\n Force bitfield accesses to match their type width.\n \n+fstore-merging\n+Common Report Var(flag_store_merging) Optimization\n+Merge adjacent stores.\n+\n fguess-branch-probability\n Common Report Var(flag_guess_branch_prob) Optimization\n Enable guessing of branch probabilities."}, {"sha": "242eed7df34c6ad55ef4408b80f3b2e39505ece9", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=f663d9ad6eaa6ff32676981461e865f96cb7c151", "patch": "@@ -405,7 +405,7 @@ Objective-C and Objective-C++ Dialects}.\n -fsingle-precision-constant -fsplit-ivs-in-unroller -fsplit-loops@gol\n -fsplit-paths @gol\n -fsplit-wide-types -fssa-backprop -fssa-phiopt @gol\n--fstdarg-opt -fstrict-aliasing @gol\n+-fstdarg-opt -fstore-merging -fstrict-aliasing @gol\n -fstrict-overflow -fthread-jumps -ftracer -ftree-bit-ccp @gol\n -ftree-builtin-call-dce -ftree-ccp -ftree-ch @gol\n -ftree-coalesce-vars -ftree-copy-prop -ftree-dce -ftree-dominator-opts @gol\n@@ -416,8 +416,8 @@ Objective-C and Objective-C++ Dialects}.\n -ftree-loop-vectorize @gol\n -ftree-parallelize-loops=@var{n} -ftree-pre -ftree-partial-pre -ftree-pta @gol\n -ftree-reassoc -ftree-sink -ftree-slsr -ftree-sra @gol\n--ftree-switch-conversion -ftree-tail-merge -ftree-ter @gol\n--ftree-vectorize -ftree-vrp -funconstrained-commons @gol\n+-ftree-switch-conversion -ftree-tail-merge @gol\n+-ftree-ter -ftree-vectorize -ftree-vrp -funconstrained-commons @gol\n -funit-at-a-time -funroll-all-loops -funroll-loops @gol\n -funsafe-math-optimizations -funswitch-loops @gol\n -fipa-ra -fvariable-expansion-in-unroller -fvect-cost-model -fvpt @gol\n@@ -6753,6 +6753,7 @@ compilation time.\n -fsplit-wide-types @gol\n -fssa-backprop @gol\n -fssa-phiopt @gol\n+-fstore-merging @gol\n -ftree-bit-ccp @gol\n -ftree-ccp @gol\n -ftree-ch @gol\n@@ -8095,6 +8096,13 @@ Perform scalar replacement of aggregates.  This pass replaces structure\n references with scalars to prevent committing structures to memory too\n early.  This flag is enabled by default at @option{-O} and higher.\n \n+@item -fstore-merging\n+@opindex fstore-merging\n+Perform merging of narrow stores to consecutive memory addresses.  This pass\n+merges contiguous stores of immediate values narrower than a word into fewer\n+wider stores to reduce the number of instructions.  This is enabled by default\n+at @option{-O} and higher.\n+\n @item -ftree-ter\n @opindex ftree-ter\n Perform temporary expression replacement during the SSA->normal phase.  Single\n@@ -9573,6 +9581,14 @@ avoid quadratic behavior in tree tail merging.  The default value is 10.\n The maximum amount of iterations of the pass over the function.  This is used to\n limit compilation time in tree tail merging.  The default value is 2.\n \n+@item store-merging-allow-unaligned\n+Allow the store merging pass to introduce unaligned stores if it is legal to\n+do so.  The default value is 1.\n+\n+@item max-stores-to-merge\n+The maximum number of stores to attempt to merge into wider stores in the store\n+merging pass.  The minimum value is 2 and the default is 64.\n+\n @item max-unrolled-insns\n The maximum number of instructions that a loop may have to be unrolled.\n If a loop is unrolled, this parameter also determines how many times"}, {"sha": "fb6e45dd393cd752b181e208647bea3b90d154f4", "filename": "gcc/fold-const.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=f663d9ad6eaa6ff32676981461e865f96cb7c151", "patch": "@@ -7516,6 +7516,26 @@ can_native_interpret_type_p (tree type)\n     }\n }\n \n+/* Return true iff a constant of type TYPE is accepted by\n+   native_encode_expr.  */\n+\n+bool\n+can_native_encode_type_p (tree type)\n+{\n+  switch (TREE_CODE (type))\n+    {\n+    case INTEGER_TYPE:\n+    case REAL_TYPE:\n+    case FIXED_POINT_TYPE:\n+    case COMPLEX_TYPE:\n+    case VECTOR_TYPE:\n+    case POINTER_TYPE:\n+      return true;\n+    default:\n+      return false;\n+    }\n+}\n+\n /* Fold a VIEW_CONVERT_EXPR of a constant expression EXPR to type\n    TYPE at compile-time.  If we're unable to perform the conversion\n    return NULL_TREE.  */"}, {"sha": "ae37142bb843e558bb2fd644f75c30ffb08052d5", "filename": "gcc/fold-const.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ffold-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ffold-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.h?ref=f663d9ad6eaa6ff32676981461e865f96cb7c151", "patch": "@@ -27,6 +27,7 @@ extern int folding_initializer;\n /* Convert between trees and native memory representation.  */\n extern int native_encode_expr (const_tree, unsigned char *, int, int off = -1);\n extern tree native_interpret_expr (tree, const unsigned char *, int);\n+extern bool can_native_encode_type_p (tree);\n \n /* Fold constants as much as possible in an expression.\n    Returns the simplified expression."}, {"sha": "5a293d7f30735499aafebeb935b073946eab5691", "filename": "gcc/gimple-ssa-store-merging.c", "status": "added", "additions": 1471, "deletions": 0, "changes": 1471, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Fgimple-ssa-store-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Fgimple-ssa-store-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.c?ref=f663d9ad6eaa6ff32676981461e865f96cb7c151", "patch": "@@ -0,0 +1,1471 @@\n+/* GIMPLE store merging pass.\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by ARM Ltd.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* The purpose of this pass is to combine multiple memory stores of\n+   constant values to consecutive memory locations into fewer wider stores.\n+   For example, if we have a sequence peforming four byte stores to\n+   consecutive memory locations:\n+   [p     ] := imm1;\n+   [p + 1B] := imm2;\n+   [p + 2B] := imm3;\n+   [p + 3B] := imm4;\n+   we can transform this into a single 4-byte store if the target supports it:\n+  [p] := imm1:imm2:imm3:imm4 //concatenated immediates according to endianness.\n+\n+   The algorithm is applied to each basic block in three phases:\n+\n+   1) Scan through the basic block recording constant assignments to\n+   destinations that can be expressed as a store to memory of a certain size\n+   at a certain bit offset.  Record store chains to different bases in a\n+   hash_map (m_stores) and make sure to terminate such chains when appropriate\n+   (for example when when the stored values get used subsequently).\n+   These stores can be a result of structure element initializers, array stores\n+   etc.  A store_immediate_info object is recorded for every such store.\n+   Record as many such assignments to a single base as possible until a\n+   statement that interferes with the store sequence is encountered.\n+\n+   2) Analyze the chain of stores recorded in phase 1) (i.e. the vector of\n+   store_immediate_info objects) and coalesce contiguous stores into\n+   merged_store_group objects.\n+\n+   For example, given the stores:\n+   [p     ] := 0;\n+   [p + 1B] := 1;\n+   [p + 3B] := 0;\n+   [p + 4B] := 1;\n+   [p + 5B] := 0;\n+   [p + 6B] := 0;\n+   This phase would produce two merged_store_group objects, one recording the\n+   two bytes stored in the memory region [p : p + 1] and another\n+   recording the four bytes stored in the memory region [p + 3 : p + 6].\n+\n+   3) The merged_store_group objects produced in phase 2) are processed\n+   to generate the sequence of wider stores that set the contiguous memory\n+   regions to the sequence of bytes that correspond to it.  This may emit\n+   multiple stores per store group to handle contiguous stores that are not\n+   of a size that is a power of 2.  For example it can try to emit a 40-bit\n+   store as a 32-bit store followed by an 8-bit store.\n+   We try to emit as wide stores as we can while respecting STRICT_ALIGNMENT or\n+   SLOW_UNALIGNED_ACCESS rules.\n+\n+   Note on endianness and example:\n+   Consider 2 contiguous 16-bit stores followed by 2 contiguous 8-bit stores:\n+   [p     ] := 0x1234;\n+   [p + 2B] := 0x5678;\n+   [p + 4B] := 0xab;\n+   [p + 5B] := 0xcd;\n+\n+   The memory layout for little-endian (LE) and big-endian (BE) must be:\n+  p |LE|BE|\n+  ---------\n+  0 |34|12|\n+  1 |12|34|\n+  2 |78|56|\n+  3 |56|78|\n+  4 |ab|ab|\n+  5 |cd|cd|\n+\n+  To merge these into a single 48-bit merged value 'val' in phase 2)\n+  on little-endian we insert stores to higher (consecutive) bitpositions\n+  into the most significant bits of the merged value.\n+  The final merged value would be: 0xcdab56781234\n+\n+  For big-endian we insert stores to higher bitpositions into the least\n+  significant bits of the merged value.\n+  The final merged value would be: 0x12345678abcd\n+\n+  Then, in phase 3), we want to emit this 48-bit value as a 32-bit store\n+  followed by a 16-bit store.  Again, we must consider endianness when\n+  breaking down the 48-bit value 'val' computed above.\n+  For little endian we emit:\n+  [p]      (32-bit) := 0x56781234; // val & 0x0000ffffffff;\n+  [p + 4B] (16-bit) := 0xcdab;    // (val & 0xffff00000000) >> 32;\n+\n+  Whereas for big-endian we emit:\n+  [p]      (32-bit) := 0x12345678; // (val & 0xffffffff0000) >> 16;\n+  [p + 4B] (16-bit) := 0xabcd;     //  val & 0x00000000ffff;  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"builtins.h\"\n+#include \"fold-const.h\"\n+#include \"tree-pass.h\"\n+#include \"ssa.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"alias.h\"\n+#include \"fold-const.h\"\n+#include \"params.h\"\n+#include \"print-tree.h\"\n+#include \"tree-hash-traits.h\"\n+#include \"gimple-iterator.h\"\n+#include \"gimplify.h\"\n+#include \"stor-layout.h\"\n+#include \"timevar.h\"\n+#include \"tree-cfg.h\"\n+#include \"tree-eh.h\"\n+#include \"target.h\"\n+\n+/* The maximum size (in bits) of the stores this pass should generate.  */\n+#define MAX_STORE_BITSIZE (BITS_PER_WORD)\n+#define MAX_STORE_BYTES (MAX_STORE_BITSIZE / BITS_PER_UNIT)\n+\n+namespace {\n+\n+/* Struct recording the information about a single store of an immediate\n+   to memory.  These are created in the first phase and coalesced into\n+   merged_store_group objects in the second phase.  */\n+\n+struct store_immediate_info\n+{\n+  unsigned HOST_WIDE_INT bitsize;\n+  unsigned HOST_WIDE_INT bitpos;\n+  tree val;\n+  tree dest;\n+  gimple *stmt;\n+  unsigned int order;\n+  store_immediate_info (unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT, tree,\n+\t\t\ttree, gimple *, unsigned int);\n+};\n+\n+store_immediate_info::store_immediate_info (unsigned HOST_WIDE_INT bs,\n+\t\t\t\t\t    unsigned HOST_WIDE_INT bp, tree v,\n+\t\t\t\t\t    tree d, gimple *st,\n+\t\t\t\t\t    unsigned int ord)\n+  : bitsize (bs), bitpos (bp), val (v), dest (d), stmt (st), order (ord)\n+{\n+}\n+\n+/* Struct representing a group of stores to contiguous memory locations.\n+   These are produced by the second phase (coalescing) and consumed in the\n+   third phase that outputs the widened stores.  */\n+\n+struct merged_store_group\n+{\n+  unsigned HOST_WIDE_INT start;\n+  unsigned HOST_WIDE_INT width;\n+  /* The size of the allocated memory for val.  */\n+  unsigned HOST_WIDE_INT buf_size;\n+\n+  unsigned int align;\n+  unsigned int first_order;\n+  unsigned int last_order;\n+\n+  auto_vec<struct store_immediate_info *> stores;\n+  /* We record the first and last original statements in the sequence because\n+     we'll need their vuse/vdef and replacement position.  It's easier to keep\n+     track of them separately as 'stores' is reordered by apply_stores.  */\n+  gimple *last_stmt;\n+  gimple *first_stmt;\n+  unsigned char *val;\n+\n+  merged_store_group (store_immediate_info *);\n+  ~merged_store_group ();\n+  void merge_into (store_immediate_info *);\n+  void merge_overlapping (store_immediate_info *);\n+  bool apply_stores ();\n+};\n+\n+/* Debug helper.  Dump LEN elements of byte array PTR to FD in hex.  */\n+\n+static void\n+dump_char_array (FILE *fd, unsigned char *ptr, unsigned int len)\n+{\n+  if (!fd)\n+    return;\n+\n+  for (unsigned int i = 0; i < len; i++)\n+    fprintf (fd, \"%x \", ptr[i]);\n+  fprintf (fd, \"\\n\");\n+}\n+\n+/* Fill a byte array PTR of SZ elements with zeroes.  This is to be used by\n+   encode_tree_to_bitpos to zero-initialize most likely small arrays but\n+   with a non-compile-time-constant size.  */\n+\n+static inline void\n+zero_char_buf (unsigned char *ptr, unsigned int sz)\n+{\n+  for (unsigned int i = 0; i < sz; i++)\n+    ptr[i] = 0;\n+}\n+\n+/* Shift left the bytes in PTR of SZ elements by AMNT bits, carrying over the\n+   bits between adjacent elements.  AMNT should be within\n+   [0, BITS_PER_UNIT).\n+   Example, AMNT = 2:\n+   00011111|11100000 << 2 = 01111111|10000000\n+   PTR[1]  | PTR[0]         PTR[1]  | PTR[0].  */\n+\n+static void\n+shift_bytes_in_array (unsigned char *ptr, unsigned int sz, unsigned int amnt)\n+{\n+  if (amnt == 0)\n+    return;\n+\n+  unsigned char carry_over = 0U;\n+  unsigned char carry_mask = (~0U) << ((unsigned char)(BITS_PER_UNIT - amnt));\n+  unsigned char clear_mask = (~0U) << amnt;\n+\n+  for (unsigned int i = 0; i < sz; i++)\n+    {\n+      unsigned prev_carry_over = carry_over;\n+      carry_over\n+\t= (ptr[i] & carry_mask) >> (BITS_PER_UNIT - amnt);\n+\n+      ptr[i] <<= amnt;\n+      if (i != 0)\n+\t{\n+\t  ptr[i] &= clear_mask;\n+\t  ptr[i] |= prev_carry_over;\n+\t}\n+    }\n+}\n+\n+/* Like shift_bytes_in_array but for big-endian.\n+   Shift right the bytes in PTR of SZ elements by AMNT bits, carrying over the\n+   bits between adjacent elements.  AMNT should be within\n+   [0, BITS_PER_UNIT).\n+   Example, AMNT = 2:\n+   00011111|11100000 >> 2 = 00000111|11111000\n+   PTR[0]  | PTR[1]         PTR[0]  | PTR[1].  */\n+\n+static void\n+shift_bytes_in_array_right (unsigned char *ptr, unsigned int sz,\n+\t\t\t    unsigned int amnt)\n+{\n+  if (amnt == 0)\n+    return;\n+\n+  unsigned char carry_over = 0U;\n+  unsigned char carry_mask = ~(~0U << amnt);\n+\n+  for (unsigned int i = 0; i < sz; i++)\n+    {\n+      unsigned prev_carry_over = carry_over;\n+      carry_over\n+\t= (ptr[i] & carry_mask);\n+\n+     carry_over <<= ((unsigned char)BITS_PER_UNIT - amnt);\n+     ptr[i] >>= amnt;\n+     ptr[i] |= prev_carry_over;\n+    }\n+}\n+\n+/* Clear out LEN bits starting from bit START in the byte array\n+   PTR.  This clears the bits to the *right* from START.\n+   START must be within [0, BITS_PER_UNIT) and counts starting from\n+   the least significant bit.  */\n+\n+static void\n+clear_bit_region_be (unsigned char *ptr, unsigned int start,\n+\t\t     unsigned int len)\n+{\n+  if (len == 0)\n+    return;\n+  /* Clear len bits to the right of start.  */\n+  else if (len <= start + 1)\n+    {\n+      unsigned char mask = (~(~0U << len));\n+      mask = mask << (start + 1U - len);\n+      ptr[0] &= ~mask;\n+    }\n+  else if (start != BITS_PER_UNIT - 1)\n+    {\n+      clear_bit_region_be (ptr, start, (start % BITS_PER_UNIT) + 1);\n+      clear_bit_region_be (ptr + 1, BITS_PER_UNIT - 1,\n+\t\t\t   len - (start % BITS_PER_UNIT) - 1);\n+    }\n+  else if (start == BITS_PER_UNIT - 1\n+\t   && len > BITS_PER_UNIT)\n+    {\n+      unsigned int nbytes = len / BITS_PER_UNIT;\n+      for (unsigned int i = 0; i < nbytes; i++)\n+\tptr[i] = 0U;\n+      if (len % BITS_PER_UNIT != 0)\n+\tclear_bit_region_be (ptr + nbytes, BITS_PER_UNIT - 1,\n+\t\t\t     len % BITS_PER_UNIT);\n+    }\n+  else\n+    gcc_unreachable ();\n+}\n+\n+/* In the byte array PTR clear the bit region starting at bit\n+   START and is LEN bits wide.\n+   For regions spanning multiple bytes do this recursively until we reach\n+   zero LEN or a region contained within a single byte.  */\n+\n+static void\n+clear_bit_region (unsigned char *ptr, unsigned int start,\n+\t\t  unsigned int len)\n+{\n+  /* Degenerate base case.  */\n+  if (len == 0)\n+    return;\n+  else if (start >= BITS_PER_UNIT)\n+    clear_bit_region (ptr + 1, start - BITS_PER_UNIT, len);\n+  /* Second base case.  */\n+  else if ((start + len) <= BITS_PER_UNIT)\n+    {\n+      unsigned char mask = (~0U) << ((unsigned char)(BITS_PER_UNIT - len));\n+      mask >>= BITS_PER_UNIT - (start + len);\n+\n+      ptr[0] &= ~mask;\n+\n+      return;\n+    }\n+  /* Clear most significant bits in a byte and proceed with the next byte.  */\n+  else if (start != 0)\n+    {\n+      clear_bit_region (ptr, start, BITS_PER_UNIT - start);\n+      clear_bit_region (ptr + 1, 0, len - (BITS_PER_UNIT - start) + 1);\n+    }\n+  /* Whole bytes need to be cleared.  */\n+  else if (start == 0 && len > BITS_PER_UNIT)\n+    {\n+      unsigned int nbytes = len / BITS_PER_UNIT;\n+      /* We could recurse on each byte but do the loop here to avoid\n+\t recursing too deep.  */\n+      for (unsigned int i = 0; i < nbytes; i++)\n+\tptr[i] = 0U;\n+      /* Clear the remaining sub-byte region if there is one.  */\n+      if (len % BITS_PER_UNIT != 0)\n+\tclear_bit_region (ptr + nbytes, 0, len % BITS_PER_UNIT);\n+    }\n+  else\n+    gcc_unreachable ();\n+}\n+\n+/* Write BITLEN bits of EXPR to the byte array PTR at\n+   bit position BITPOS.  PTR should contain TOTAL_BYTES elements.\n+   Return true if the operation succeeded.  */\n+\n+static bool\n+encode_tree_to_bitpos (tree expr, unsigned char *ptr, int bitlen, int bitpos,\n+\t\t\tunsigned int total_bytes)\n+{\n+  unsigned int first_byte = bitpos / BITS_PER_UNIT;\n+  tree tmp_int = expr;\n+  bool sub_byte_op_p = (bitlen % BITS_PER_UNIT) || (bitpos % BITS_PER_UNIT)\n+\t\t\t|| mode_for_size (bitlen, MODE_INT, 0) == BLKmode;\n+\n+  if (!sub_byte_op_p)\n+    return native_encode_expr (tmp_int, ptr + first_byte, total_bytes, 0)\n+\t   != 0;\n+\n+  /* LITTLE-ENDIAN\n+     We are writing a non byte-sized quantity or at a position that is not\n+     at a byte boundary.\n+     |--------|--------|--------| ptr + first_byte\n+           ^              ^\n+           xxx xxxxxxxx xxx< bp>\n+           |______EXPR____|\n+\n+     First native_encode_expr EPXR into a temporary buffer and shift each\n+     byte in the buffer by 'bp' (carrying the bits over as necessary).\n+     |00000000|00xxxxxx|xxxxxxxx| << bp = |000xxxxx|xxxxxxxx|xxx00000|\n+                                              <------bitlen---->< bp>\n+    Then we clear the destination bits:\n+    |---00000|00000000|000-----| ptr + first_byte\n+        <-------bitlen--->< bp>\n+\n+    Finally we ORR the bytes of the shifted EXPR into the cleared region:\n+    |---xxxxx||xxxxxxxx||xxx-----| ptr + first_byte.\n+\n+   BIG-ENDIAN\n+   We are writing a non byte-sized quantity or at a position that is not\n+   at a byte boundary.\n+     ptr + first_byte |--------|--------|--------|\n+                            ^              ^\n+                       <bp >xxx xxxxxxxx xxx\n+                            |_____EXPR_____|\n+\n+     First native_encode_expr EPXR into a temporary buffer and shift each\n+     byte in the buffer to the right by (carrying the bits over as necessary).\n+     We shift by as much as needed to align the most significant bit of EXPR\n+     with bitpos:\n+     |00xxxxxx|xxxxxxxx| >> 3 = |00000xxx|xxxxxxxx|xxxxx000|\n+        <---bitlen---->          <bp ><-----bitlen----->\n+    Then we clear the destination bits:\n+    ptr + first_byte |-----000||00000000||00000---|\n+                      <bp ><-------bitlen----->\n+\n+    Finally we ORR the bytes of the shifted EXPR into the cleared region:\n+    ptr + first_byte |---xxxxx||xxxxxxxx||xxx-----|.\n+    The awkwardness comes from the fact that bitpos is counted from the\n+    most significant bit of a byte.  */\n+\n+  /* Allocate an extra byte so that we have space to shift into.  */\n+  unsigned int byte_size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (expr))) + 1;\n+  unsigned char *tmpbuf = XALLOCAVEC (unsigned char, byte_size);\n+  zero_char_buf (tmpbuf, byte_size);\n+  /* The store detection code should only have allowed constants that are\n+     accepted by native_encode_expr.  */\n+  if (native_encode_expr (expr, tmpbuf, byte_size, 0) == 0)\n+    gcc_unreachable ();\n+\n+  /* The native_encode_expr machinery uses TYPE_MODE to determine how many\n+     bytes to write.  This means it can write more than\n+     ROUND_UP (bitlen, BITS_PER_UNIT) / BITS_PER_UNIT bytes (for example\n+     write 8 bytes for a bitlen of 40).  Skip the bytes that are not within\n+     bitlen and zero out the bits that are not relevant as well (that may\n+     contain a sign bit due to sign-extension).  */\n+  unsigned int padding\n+    = byte_size - ROUND_UP (bitlen, BITS_PER_UNIT) / BITS_PER_UNIT - 1;\n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      tmpbuf += padding;\n+      byte_size -= padding;\n+      if (bitlen % BITS_PER_UNIT != 0)\n+\tclear_bit_region_be (tmpbuf, BITS_PER_UNIT - 1,\n+\t\t\t     BITS_PER_UNIT - (bitlen % BITS_PER_UNIT));\n+    }\n+\n+  /* Clear the bit region in PTR where the bits from TMPBUF will be\n+     inerted into.  */\n+  if (BYTES_BIG_ENDIAN)\n+    clear_bit_region_be (ptr + first_byte,\n+\t\t\t BITS_PER_UNIT - 1 - (bitpos % BITS_PER_UNIT), bitlen);\n+  else\n+    clear_bit_region (ptr + first_byte, bitpos % BITS_PER_UNIT, bitlen);\n+\n+  int shift_amnt;\n+  int bitlen_mod = bitlen % BITS_PER_UNIT;\n+  int bitpos_mod = bitpos % BITS_PER_UNIT;\n+\n+  bool skip_byte = false;\n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      /* BITPOS and BITLEN are exactly aligned and no shifting\n+\t is necessary.  */\n+      if (bitpos_mod + bitlen_mod == BITS_PER_UNIT\n+\t  || (bitpos_mod == 0 && bitlen_mod == 0))\n+\tshift_amnt = 0;\n+      /* |. . . . . . . .|\n+\t  <bp >   <blen >.\n+\t We always shift right for BYTES_BIG_ENDIAN so shift the beginning\n+\t of the value until it aligns with 'bp' in the next byte over.  */\n+      else if (bitpos_mod + bitlen_mod < BITS_PER_UNIT)\n+\t{\n+\t  shift_amnt = bitlen_mod + bitpos_mod;\n+\t  skip_byte = bitlen_mod != 0;\n+\t}\n+      /* |. . . . . . . .|\n+\t  <----bp--->\n+\t    <---blen---->.\n+\t Shift the value right within the same byte so it aligns with 'bp'.  */\n+      else\n+\tshift_amnt = bitlen_mod + bitpos_mod - BITS_PER_UNIT;\n+    }\n+  else\n+    shift_amnt = bitpos % BITS_PER_UNIT;\n+\n+  /* Create the shifted version of EXPR.  */\n+  if (!BYTES_BIG_ENDIAN)\n+    shift_bytes_in_array (tmpbuf, byte_size, shift_amnt);\n+  else\n+    {\n+      gcc_assert (BYTES_BIG_ENDIAN);\n+      shift_bytes_in_array_right (tmpbuf, byte_size, shift_amnt);\n+      /* If shifting right forced us to move into the next byte skip the now\n+\t empty byte.  */\n+      if (skip_byte)\n+\t{\n+\t  tmpbuf++;\n+\t  byte_size--;\n+\t}\n+    }\n+\n+  /* Insert the bits from TMPBUF.  */\n+  for (unsigned int i = 0; i < byte_size; i++)\n+    ptr[first_byte + i] |= tmpbuf[i];\n+\n+  return true;\n+}\n+\n+/* Sorting function for store_immediate_info objects.\n+   Sorts them by bitposition.  */\n+\n+static int\n+sort_by_bitpos (const void *x, const void *y)\n+{\n+  store_immediate_info *const *tmp = (store_immediate_info * const *) x;\n+  store_immediate_info *const *tmp2 = (store_immediate_info * const *) y;\n+\n+  if ((*tmp)->bitpos <= (*tmp2)->bitpos)\n+    return -1;\n+  else if ((*tmp)->bitpos > (*tmp2)->bitpos)\n+    return 1;\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Sorting function for store_immediate_info objects.\n+   Sorts them by the order field.  */\n+\n+static int\n+sort_by_order (const void *x, const void *y)\n+{\n+  store_immediate_info *const *tmp = (store_immediate_info * const *) x;\n+  store_immediate_info *const *tmp2 = (store_immediate_info * const *) y;\n+\n+  if ((*tmp)->order < (*tmp2)->order)\n+    return -1;\n+  else if ((*tmp)->order > (*tmp2)->order)\n+    return 1;\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Initialize a merged_store_group object from a store_immediate_info\n+   object.  */\n+\n+merged_store_group::merged_store_group (store_immediate_info *info)\n+{\n+  start = info->bitpos;\n+  width = info->bitsize;\n+  /* VAL has memory allocated for it in apply_stores once the group\n+     width has been finalized.  */\n+  val = NULL;\n+  align = get_object_alignment (info->dest);\n+  stores.create (1);\n+  stores.safe_push (info);\n+  last_stmt = info->stmt;\n+  last_order = info->order;\n+  first_stmt = last_stmt;\n+  first_order = last_order;\n+  buf_size = 0;\n+}\n+\n+merged_store_group::~merged_store_group ()\n+{\n+  if (val)\n+    XDELETEVEC (val);\n+}\n+\n+/* Merge a store recorded by INFO into this merged store.\n+   The store is not overlapping with the existing recorded\n+   stores.  */\n+\n+void\n+merged_store_group::merge_into (store_immediate_info *info)\n+{\n+  unsigned HOST_WIDE_INT wid = info->bitsize;\n+  /* Make sure we're inserting in the position we think we're inserting.  */\n+  gcc_assert (info->bitpos == start + width);\n+\n+  width += wid;\n+  gimple *stmt = info->stmt;\n+  stores.safe_push (info);\n+  if (info->order > last_order)\n+    {\n+      last_order = info->order;\n+      last_stmt = stmt;\n+    }\n+  else if (info->order < first_order)\n+    {\n+      first_order = info->order;\n+      first_stmt = stmt;\n+    }\n+}\n+\n+/* Merge a store described by INFO into this merged store.\n+   INFO overlaps in some way with the current store (i.e. it's not contiguous\n+   which is handled by merged_store_group::merge_into).  */\n+\n+void\n+merged_store_group::merge_overlapping (store_immediate_info *info)\n+{\n+  gimple *stmt = info->stmt;\n+  stores.safe_push (info);\n+\n+  /* If the store extends the size of the group, extend the width.  */\n+  if ((info->bitpos + info->bitsize) > (start + width))\n+    width += info->bitpos + info->bitsize - (start + width);\n+\n+  if (info->order > last_order)\n+    {\n+      last_order = info->order;\n+      last_stmt = stmt;\n+    }\n+  else if (info->order < first_order)\n+    {\n+      first_order = info->order;\n+      first_stmt = stmt;\n+    }\n+}\n+\n+/* Go through all the recorded stores in this group in program order and\n+   apply their values to the VAL byte array to create the final merged\n+   value.  Return true if the operation succeeded.  */\n+\n+bool\n+merged_store_group::apply_stores ()\n+{\n+  /* The total width of the stores must add up to a whole number of bytes\n+     and start at a byte boundary.  We don't support emitting bitfield\n+     references for now.  Also, make sure we have more than one store\n+     in the group, otherwise we cannot merge anything.  */\n+  if (width % BITS_PER_UNIT != 0\n+      || start % BITS_PER_UNIT != 0\n+      || stores.length () == 1)\n+    return false;\n+\n+  stores.qsort (sort_by_order);\n+  struct store_immediate_info *info;\n+  unsigned int i;\n+  /* Create a buffer of a size that is 2 times the number of bytes we're\n+     storing.  That way native_encode_expr can write power-of-2-sized\n+     chunks without overrunning.  */\n+  buf_size\n+    = 2 * (ROUND_UP (width, BITS_PER_UNIT) / BITS_PER_UNIT);\n+  val = XCNEWVEC (unsigned char, buf_size);\n+\n+  FOR_EACH_VEC_ELT (stores, i, info)\n+    {\n+      unsigned int pos_in_buffer = info->bitpos - start;\n+      bool ret = encode_tree_to_bitpos (info->val, val, info->bitsize,\n+\t\t\t\t\t pos_in_buffer, buf_size);\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  if (ret)\n+\t    {\n+\t      fprintf (dump_file, \"After writing \");\n+\t      print_generic_expr (dump_file, info->val, 0);\n+\t      fprintf (dump_file, \" of size \" HOST_WIDE_INT_PRINT_DEC\n+\t\t\t\" at position %d the merged region contains:\\n\",\n+\t\t\tinfo->bitsize, pos_in_buffer);\n+\t      dump_char_array (dump_file, val, buf_size);\n+\t    }\n+\t  else\n+\t    fprintf (dump_file, \"Failed to merge stores\\n\");\n+        }\n+      if (!ret)\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+/* Structure describing the store chain.  */\n+\n+struct imm_store_chain_info\n+{\n+  auto_vec<struct store_immediate_info *> m_store_info;\n+  auto_vec<merged_store_group *> m_merged_store_groups;\n+\n+  bool terminate_and_process_chain (tree);\n+  bool coalesce_immediate_stores ();\n+  bool output_merged_store (tree, merged_store_group *);\n+  bool output_merged_stores (tree);\n+};\n+\n+const pass_data pass_data_tree_store_merging = {\n+  GIMPLE_PASS,     /* type */\n+  \"store-merging\", /* name */\n+  OPTGROUP_NONE,   /* optinfo_flags */\n+  TV_GIMPLE_STORE_MERGING,\t /* tv_id */\n+  PROP_ssa,\t/* properties_required */\n+  0,\t\t   /* properties_provided */\n+  0,\t\t   /* properties_destroyed */\n+  0,\t\t   /* todo_flags_start */\n+  TODO_update_ssa, /* todo_flags_finish */\n+};\n+\n+class pass_store_merging : public gimple_opt_pass\n+{\n+public:\n+  pass_store_merging (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_tree_store_merging, ctxt)\n+  {\n+  }\n+\n+  /* Pass not supported for PDP-endianness.  */\n+  virtual bool\n+  gate (function *)\n+  {\n+    return flag_store_merging && (WORDS_BIG_ENDIAN == BYTES_BIG_ENDIAN);\n+  }\n+\n+  virtual unsigned int execute (function *);\n+\n+private:\n+  hash_map<tree_operand_hash, struct imm_store_chain_info *> m_stores;\n+\n+  bool terminate_and_process_all_chains ();\n+  bool terminate_all_aliasing_chains (tree, tree, bool, gimple *);\n+  bool terminate_and_release_chain (tree);\n+}; // class pass_store_merging\n+\n+/* Terminate and process all recorded chains.  Return true if any changes\n+   were made.  */\n+\n+bool\n+pass_store_merging::terminate_and_process_all_chains ()\n+{\n+  hash_map<tree_operand_hash, struct imm_store_chain_info *>::iterator iter\n+    = m_stores.begin ();\n+  bool ret = false;\n+  for (; iter != m_stores.end (); ++iter)\n+    ret |= terminate_and_release_chain ((*iter).first);\n+\n+  return ret;\n+}\n+\n+/* Terminate all chains that are affected by the assignment to DEST, appearing\n+   in statement STMT and ultimately points to the object BASE.  Return true if\n+   at least one aliasing chain was terminated.  BASE and DEST are allowed to\n+   be NULL_TREE.  In that case the aliasing checks are performed on the whole\n+   statement rather than a particular operand in it.  VAR_OFFSET_P signifies\n+   whether STMT represents a store to BASE offset by a variable amount.\n+   If that is the case we have to terminate any chain anchored at BASE.  */\n+\n+bool\n+pass_store_merging::terminate_all_aliasing_chains (tree dest, tree base,\n+\t\t\t\t\t\t   bool var_offset_p,\n+\t\t\t\t\t\t   gimple *stmt)\n+{\n+  bool ret = false;\n+\n+  /* If the statement doesn't touch memory it can't alias.  */\n+  if (!gimple_vuse (stmt))\n+    return false;\n+\n+  struct imm_store_chain_info **chain_info = NULL;\n+\n+  /* Check if the assignment destination (BASE) is part of a store chain.\n+     This is to catch non-constant stores to destinations that may be part\n+     of a chain.  */\n+  if (base)\n+    {\n+      chain_info = m_stores.get (base);\n+      if (chain_info)\n+\t{\n+\t  /* We have a chain at BASE and we're writing to [BASE + <variable>].\n+\t     This can interfere with any of the stores so terminate\n+\t     the chain.  */\n+\t  if (var_offset_p)\n+\t    {\n+\t      terminate_and_release_chain (base);\n+\t      ret = true;\n+\t    }\n+\t  /* Otherwise go through every store in the chain to see if it\n+\t     aliases with any of them.  */\n+\t  else\n+\t    {\n+\t      struct store_immediate_info *info;\n+\t      unsigned int i;\n+\t      FOR_EACH_VEC_ELT ((*chain_info)->m_store_info, i, info)\n+\t\t{\n+\t\t  if (refs_may_alias_p (info->dest, dest))\n+\t\t    {\n+\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t\t{\n+\t\t\t  fprintf (dump_file,\n+\t\t\t\t   \"stmt causes chain termination:\\n\");\n+\t\t\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t\t\t}\n+\t\t      terminate_and_release_chain (base);\n+\t\t      ret = true;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  hash_map<tree_operand_hash, struct imm_store_chain_info *>::iterator iter\n+    = m_stores.begin ();\n+\n+  /* Check for aliasing with all other store chains.  */\n+  for (; iter != m_stores.end (); ++iter)\n+    {\n+      /* We already checked all the stores in chain_info and terminated the\n+\t chain if necessary.  Skip it here.  */\n+      if (chain_info && (*chain_info) == (*iter).second)\n+\tcontinue;\n+\n+      tree key = (*iter).first;\n+      if (ref_maybe_used_by_stmt_p (stmt, key)\n+\t  || stmt_may_clobber_ref_p (stmt, key))\n+\t{\n+\t  terminate_and_release_chain (key);\n+\t  ret = true;\n+\t}\n+    }\n+\n+  return ret;\n+}\n+\n+/* Helper function.  Terminate the recorded chain storing to base object\n+   BASE.  Return true if the merging and output was successful.  The m_stores\n+   entry is removed after the processing in any case.  */\n+\n+bool\n+pass_store_merging::terminate_and_release_chain (tree base)\n+{\n+  struct imm_store_chain_info **chain_info = m_stores.get (base);\n+\n+  if (!chain_info)\n+    return false;\n+\n+  gcc_assert (*chain_info);\n+\n+  bool ret = (*chain_info)->terminate_and_process_chain (base);\n+  delete *chain_info;\n+  m_stores.remove (base);\n+\n+  return ret;\n+}\n+\n+/* Go through the candidate stores recorded in m_store_info and merge them\n+   into merged_store_group objects recorded into m_merged_store_groups\n+   representing the widened stores.  Return true if coalescing was successful\n+   and the number of widened stores is fewer than the original number\n+   of stores.  */\n+\n+bool\n+imm_store_chain_info::coalesce_immediate_stores ()\n+{\n+  /* Anything less can't be processed.  */\n+  if (m_store_info.length () < 2)\n+    return false;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Attempting to coalesce %u stores in chain.\\n\",\n+\t     m_store_info.length ());\n+\n+  store_immediate_info *info;\n+  unsigned int i;\n+\n+  /* Order the stores by the bitposition they write to.  */\n+  m_store_info.qsort (sort_by_bitpos);\n+\n+  info = m_store_info[0];\n+  merged_store_group *merged_store = new merged_store_group (info);\n+\n+  FOR_EACH_VEC_ELT (m_store_info, i, info)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Store %u:\\nbitsize:\" HOST_WIDE_INT_PRINT_DEC\n+\t\t\t      \" bitpos:\" HOST_WIDE_INT_PRINT_DEC \" val:\\n\",\n+\t\t   i, info->bitsize, info->bitpos);\n+\t  print_generic_expr (dump_file, info->val, 0);\n+\t  fprintf (dump_file, \"\\n------------\\n\");\n+\t}\n+\n+      if (i == 0)\n+\tcontinue;\n+\n+      /* |---store 1---|\n+\t       |---store 2---|\n+       Overlapping stores.  */\n+      unsigned HOST_WIDE_INT start = info->bitpos;\n+      if (IN_RANGE (start, merged_store->start,\n+\t\t    merged_store->start + merged_store->width - 1))\n+\t{\n+\t  merged_store->merge_overlapping (info);\n+\t  continue;\n+\t}\n+\n+      /* |---store 1---| <gap> |---store 2---|.\n+\t Gap between stores.  Start a new group.  */\n+      if (start != merged_store->start + merged_store->width)\n+\t{\n+\t  /* Try to apply all the stores recorded for the group to determine\n+\t     the bitpattern they write and discard it if that fails.\n+\t     This will also reject single-store groups.  */\n+\t  if (!merged_store->apply_stores ())\n+\t    delete merged_store;\n+\t  else\n+\t    m_merged_store_groups.safe_push (merged_store);\n+\n+\t  merged_store = new merged_store_group (info);\n+\n+\t  continue;\n+\t}\n+\n+      /* |---store 1---||---store 2---|\n+\t This store is consecutive to the previous one.\n+\t Merge it into the current store group.  */\n+       merged_store->merge_into (info);\n+    }\n+\n+    /* Record or discard the last store group.  */\n+    if (!merged_store->apply_stores ())\n+      delete merged_store;\n+    else\n+      m_merged_store_groups.safe_push (merged_store);\n+\n+  gcc_assert (m_merged_store_groups.length () <= m_store_info.length ());\n+  bool success\n+    = !m_merged_store_groups.is_empty ()\n+      && m_merged_store_groups.length () < m_store_info.length ();\n+\n+  if (success && dump_file)\n+    fprintf (dump_file, \"Coalescing successful!\\n\"\n+\t\t\t \"Merged into %u stores\\n\",\n+\t\tm_merged_store_groups.length ());\n+\n+  return success;\n+}\n+\n+/* Return the type to use for the merged stores described by STMTS.\n+   This is needed to get the alias sets right.  */\n+\n+static tree\n+get_alias_type_for_stmts (auto_vec<gimple *> &stmts)\n+{\n+  gimple *stmt;\n+  unsigned int i;\n+  tree lhs = gimple_assign_lhs (stmts[0]);\n+  tree type = reference_alias_ptr_type (lhs);\n+\n+  FOR_EACH_VEC_ELT (stmts, i, stmt)\n+    {\n+      if (i == 0)\n+\tcontinue;\n+\n+      lhs = gimple_assign_lhs (stmt);\n+      tree type1 = reference_alias_ptr_type (lhs);\n+      if (!alias_ptr_types_compatible_p (type, type1))\n+\treturn ptr_type_node;\n+    }\n+  return type;\n+}\n+\n+/* Return the location_t information we can find among the statements\n+   in STMTS.  */\n+\n+static location_t\n+get_location_for_stmts (auto_vec<gimple *> &stmts)\n+{\n+  gimple *stmt;\n+  unsigned int i;\n+\n+  FOR_EACH_VEC_ELT (stmts, i, stmt)\n+    if (gimple_has_location (stmt))\n+      return gimple_location (stmt);\n+\n+  return UNKNOWN_LOCATION;\n+}\n+\n+/* Used to decribe a store resulting from splitting a wide store in smaller\n+   regularly-sized stores in split_group.  */\n+\n+struct split_store\n+{\n+  unsigned HOST_WIDE_INT bytepos;\n+  unsigned HOST_WIDE_INT size;\n+  unsigned HOST_WIDE_INT align;\n+  auto_vec<gimple *> orig_stmts;\n+  split_store (unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n+\t       unsigned HOST_WIDE_INT);\n+};\n+\n+/* Simple constructor.  */\n+\n+split_store::split_store (unsigned HOST_WIDE_INT bp,\n+\t\t\t  unsigned HOST_WIDE_INT sz,\n+\t\t\t  unsigned HOST_WIDE_INT al)\n+\t\t\t  : bytepos (bp), size (sz), align (al)\n+{\n+  orig_stmts.create (0);\n+}\n+\n+/* Record all statements corresponding to stores in GROUP that write to\n+   the region starting at BITPOS and is of size BITSIZE.  Record such\n+   statements in STMTS.  The stores in GROUP must be sorted by\n+   bitposition.  */\n+\n+static void\n+find_constituent_stmts (struct merged_store_group *group,\n+\t\t\t auto_vec<gimple *> &stmts,\n+\t\t\t unsigned HOST_WIDE_INT bitpos,\n+\t\t\t unsigned HOST_WIDE_INT bitsize)\n+{\n+  struct store_immediate_info *info;\n+  unsigned int i;\n+  unsigned HOST_WIDE_INT end = bitpos + bitsize;\n+  FOR_EACH_VEC_ELT (group->stores, i, info)\n+    {\n+      unsigned HOST_WIDE_INT stmt_start = info->bitpos;\n+      unsigned HOST_WIDE_INT stmt_end = stmt_start + info->bitsize;\n+      if (stmt_end < bitpos)\n+\tcontinue;\n+      /* The stores in GROUP are ordered by bitposition so if we're past\n+\t  the region for this group return early.  */\n+      if (stmt_start > end)\n+\treturn;\n+\n+      if (IN_RANGE (stmt_start, bitpos, bitpos + bitsize)\n+\t  || IN_RANGE (stmt_end, bitpos, end)\n+\t  /* The statement writes a region that completely encloses the region\n+\t     that this group writes.  Unlikely to occur but let's\n+\t     handle it.  */\n+\t  || IN_RANGE (bitpos, stmt_start, stmt_end))\n+\tstmts.safe_push (info->stmt);\n+    }\n+}\n+\n+/* Split a merged store described by GROUP by populating the SPLIT_STORES\n+   vector with split_store structs describing the byte offset (from the base),\n+   the bit size and alignment of each store as well as the original statements\n+   involved in each such split group.\n+   This is to separate the splitting strategy from the statement\n+   building/emission/linking done in output_merged_store.\n+   At the moment just start with the widest possible size and keep emitting\n+   the widest we can until we have emitted all the bytes, halving the size\n+   when appropriate.  */\n+\n+static bool\n+split_group (merged_store_group *group,\n+\t     auto_vec<struct split_store *> &split_stores)\n+{\n+  unsigned HOST_WIDE_INT pos = group->start;\n+  unsigned HOST_WIDE_INT size = group->width;\n+  unsigned HOST_WIDE_INT bytepos = pos / BITS_PER_UNIT;\n+  unsigned HOST_WIDE_INT align = group->align;\n+\n+  /* We don't handle partial bitfields for now.  We shouldn't have\n+     reached this far.  */\n+  gcc_assert ((size % BITS_PER_UNIT == 0) && (pos % BITS_PER_UNIT == 0));\n+\n+  bool allow_unaligned\n+    = !STRICT_ALIGNMENT && PARAM_VALUE (PARAM_STORE_MERGING_ALLOW_UNALIGNED);\n+\n+  unsigned int try_size = MAX_STORE_BITSIZE;\n+  while (try_size > size\n+\t || (!allow_unaligned\n+\t     && try_size > align))\n+    {\n+      try_size /= 2;\n+      if (try_size < BITS_PER_UNIT)\n+\treturn false;\n+    }\n+\n+  unsigned HOST_WIDE_INT try_pos = bytepos;\n+  group->stores.qsort (sort_by_bitpos);\n+\n+  while (size > 0)\n+    {\n+      struct split_store *store = new split_store (try_pos, try_size, align);\n+      unsigned HOST_WIDE_INT try_bitpos = try_pos * BITS_PER_UNIT;\n+      find_constituent_stmts (group, store->orig_stmts, try_bitpos, try_size);\n+      split_stores.safe_push (store);\n+\n+      try_pos += try_size / BITS_PER_UNIT;\n+\n+      size -= try_size;\n+      align = try_size;\n+      while (size < try_size)\n+\ttry_size /= 2;\n+    }\n+  return true;\n+}\n+\n+/* Given a merged store group GROUP output the widened version of it.\n+   The store chain is against the base object BASE.\n+   Try store sizes of at most MAX_STORE_BITSIZE bits wide and don't output\n+   unaligned stores for STRICT_ALIGNMENT targets or if it's too expensive.\n+   Make sure that the number of statements output is less than the number of\n+   original statements.  If a better sequence is possible emit it and\n+   return true.  */\n+\n+bool\n+imm_store_chain_info::output_merged_store (tree base, merged_store_group *group)\n+{\n+  unsigned HOST_WIDE_INT start_byte_pos = group->start / BITS_PER_UNIT;\n+\n+  unsigned int orig_num_stmts = group->stores.length ();\n+  if (orig_num_stmts < 2)\n+    return false;\n+\n+  auto_vec<struct split_store *> split_stores;\n+  split_stores.create (0);\n+  if (!split_group (group, split_stores))\n+    return false;\n+\n+  gimple_stmt_iterator last_gsi = gsi_for_stmt (group->last_stmt);\n+  gimple_seq seq = NULL;\n+  unsigned int num_stmts = 0;\n+  tree last_vdef, new_vuse;\n+  last_vdef = gimple_vdef (group->last_stmt);\n+  new_vuse = gimple_vuse (group->last_stmt);\n+\n+  gimple *stmt = NULL;\n+  /* The new SSA names created.  Keep track of them so that we can free them\n+     if we decide to not use the new sequence.  */\n+  auto_vec<tree> new_ssa_names;\n+  split_store *split_store;\n+  unsigned int i;\n+  bool fail = false;\n+\n+  FOR_EACH_VEC_ELT (split_stores, i, split_store)\n+    {\n+      unsigned HOST_WIDE_INT try_size = split_store->size;\n+      unsigned HOST_WIDE_INT try_pos = split_store->bytepos;\n+      unsigned HOST_WIDE_INT align = split_store->align;\n+      tree offset_type = get_alias_type_for_stmts (split_store->orig_stmts);\n+      location_t loc = get_location_for_stmts (split_store->orig_stmts);\n+\n+      tree int_type = build_nonstandard_integer_type (try_size, UNSIGNED);\n+      SET_TYPE_ALIGN (int_type, align);\n+      tree addr = build_fold_addr_expr (base);\n+      tree dest = fold_build2 (MEM_REF, int_type, addr,\n+\t\t\t       build_int_cst (offset_type, try_pos));\n+\n+      tree src = native_interpret_expr (int_type,\n+\t\t\t\t\tgroup->val + try_pos - start_byte_pos,\n+\t\t\t\t\tgroup->buf_size);\n+\n+      stmt = gimple_build_assign (dest, src);\n+      gimple_set_location (stmt, loc);\n+      gimple_set_vuse (stmt, new_vuse);\n+      gimple_seq_add_stmt_without_update (&seq, stmt);\n+\n+      /* We didn't manage to reduce the number of statements.  Bail out.  */\n+      if (++num_stmts == orig_num_stmts)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Exceeded original number of stmts (%u).\"\n+\t\t\t\t  \"  Not profitable to emit new sequence.\\n\",\n+\t\t       orig_num_stmts);\n+\t    }\n+\t  unsigned int ssa_count;\n+\t  tree ssa_name;\n+\t  /* Don't forget to cleanup the temporary SSA names.  */\n+\t  FOR_EACH_VEC_ELT (new_ssa_names, ssa_count, ssa_name)\n+\t    release_ssa_name (ssa_name);\n+\n+\t  fail = true;\n+\t  break;\n+\t}\n+\n+      tree new_vdef;\n+      if (i < split_stores.length () - 1)\n+\t{\n+\t  new_vdef = make_ssa_name (gimple_vop (cfun), stmt);\n+\t  new_ssa_names.safe_push (new_vdef);\n+\t}\n+      else\n+\tnew_vdef = last_vdef;\n+\n+      gimple_set_vdef (stmt, new_vdef);\n+      SSA_NAME_DEF_STMT (new_vdef) = stmt;\n+      new_vuse = new_vdef;\n+    }\n+\n+  FOR_EACH_VEC_ELT (split_stores, i, split_store)\n+    delete split_store;\n+\n+  if (fail)\n+    return false;\n+\n+  gcc_assert (seq);\n+  if (dump_file)\n+    {\n+      fprintf (dump_file,\n+\t       \"New sequence of %u stmts to replace old one of %u stmts\\n\",\n+\t       num_stmts, orig_num_stmts);\n+      if (dump_flags & TDF_DETAILS)\n+\tprint_gimple_seq (dump_file, seq, 0, TDF_VOPS | TDF_MEMSYMS);\n+    }\n+  gsi_insert_seq_after (&last_gsi, seq, GSI_SAME_STMT);\n+\n+  return true;\n+}\n+\n+/* Process the merged_store_group objects created in the coalescing phase.\n+   The stores are all against the base object BASE.\n+   Try to output the widened stores and delete the original statements if\n+   successful.  Return true iff any changes were made.  */\n+\n+bool\n+imm_store_chain_info::output_merged_stores (tree base)\n+{\n+  unsigned int i;\n+  merged_store_group *merged_store;\n+  bool ret = false;\n+  FOR_EACH_VEC_ELT (m_merged_store_groups, i, merged_store)\n+    {\n+      if (output_merged_store (base, merged_store))\n+\t{\n+\t  unsigned int j;\n+\t  store_immediate_info *store;\n+\t  FOR_EACH_VEC_ELT (merged_store->stores, j, store)\n+\t    {\n+\t      gimple *stmt = store->stmt;\n+\t      gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+\t      gsi_remove (&gsi, true);\n+\t      if (stmt != merged_store->last_stmt)\n+\t\t{\n+\t\t  unlink_stmt_vdef (stmt);\n+\t\t  release_defs (stmt);\n+\t\t}\n+\t    }\n+\t  ret = true;\n+\t}\n+    }\n+  if (ret && dump_file)\n+    fprintf (dump_file, \"Merging successful!\\n\");\n+\n+  return ret;\n+}\n+\n+/* Coalesce the store_immediate_info objects recorded against the base object\n+   BASE in the first phase and output them.\n+   Delete the allocated structures.\n+   Return true if any changes were made.  */\n+\n+bool\n+imm_store_chain_info::terminate_and_process_chain (tree base)\n+{\n+  /* Process store chain.  */\n+  bool ret = false;\n+  if (m_store_info.length () > 1)\n+    {\n+      ret = coalesce_immediate_stores ();\n+      if (ret)\n+\tret = output_merged_stores (base);\n+    }\n+\n+  /* Delete all the entries we allocated ourselves.  */\n+  store_immediate_info *info;\n+  unsigned int i;\n+  FOR_EACH_VEC_ELT (m_store_info, i, info)\n+    delete info;\n+\n+  merged_store_group *merged_info;\n+  FOR_EACH_VEC_ELT (m_merged_store_groups, i, merged_info)\n+    delete merged_info;\n+\n+  return ret;\n+}\n+\n+/* Return true iff LHS is a destination potentially interesting for\n+   store merging.  In practice these are the codes that get_inner_reference\n+   can process.  */\n+\n+static bool\n+lhs_valid_for_store_merging_p (tree lhs)\n+{\n+  tree_code code = TREE_CODE (lhs);\n+\n+  if (code == ARRAY_REF || code == ARRAY_RANGE_REF || code == MEM_REF\n+      || code == COMPONENT_REF || code == BIT_FIELD_REF)\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Return true if the tree RHS is a constant we want to consider\n+   during store merging.  In practice accept all codes that\n+   native_encode_expr accepts.  */\n+\n+static bool\n+rhs_valid_for_store_merging_p (tree rhs)\n+{\n+  tree type = TREE_TYPE (rhs);\n+  if (TREE_CODE_CLASS (TREE_CODE (rhs)) != tcc_constant\n+      || !can_native_encode_type_p (type))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Entry point for the pass.  Go over each basic block recording chains of\n+  immediate stores.  Upon encountering a terminating statement (as defined\n+  by stmt_terminates_chain_p) process the recorded stores and emit the widened\n+  variants.  */\n+\n+unsigned int\n+pass_store_merging::execute (function *fun)\n+{\n+  basic_block bb;\n+  hash_set<gimple *> orig_stmts;\n+\n+  FOR_EACH_BB_FN (bb, fun)\n+    {\n+      gimple_stmt_iterator gsi;\n+      unsigned HOST_WIDE_INT num_statements = 0;\n+      /* Record the original statements so that we can keep track of\n+\t statements emitted in this pass and not re-process new\n+\t statements.  */\n+      for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  if (is_gimple_debug (gsi_stmt (gsi)))\n+\t    continue;\n+\n+\t  if (++num_statements > 2)\n+\t    break;\n+\t}\n+\n+      if (num_statements < 2)\n+\tcontinue;\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"Processing basic block <%d>:\\n\", bb->index);\n+\n+      for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gimple *stmt = gsi_stmt (gsi);\n+\n+\t  if (gimple_has_volatile_ops (stmt))\n+\t    {\n+\t      /* Terminate all chains.  */\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"Volatile access terminates \"\n+\t\t\t\t    \"all chains\\n\");\n+\t      terminate_and_process_all_chains ();\n+\t      continue;\n+\t    }\n+\n+\t  if (is_gimple_debug (stmt))\n+\t    continue;\n+\n+\t  if (gimple_assign_single_p (stmt) && gimple_vdef (stmt)\n+\t      && !stmt_can_throw_internal (stmt)\n+\t      && lhs_valid_for_store_merging_p (gimple_assign_lhs (stmt)))\n+\t    {\n+\t      tree lhs = gimple_assign_lhs (stmt);\n+\t      tree rhs = gimple_assign_rhs1 (stmt);\n+\n+\t      HOST_WIDE_INT bitsize, bitpos;\n+\t      machine_mode mode;\n+\t      int unsignedp = 0, reversep = 0, volatilep = 0;\n+\t      tree offset, base_addr;\n+\t      base_addr\n+\t\t= get_inner_reference (lhs, &bitsize, &bitpos, &offset, &mode,\n+\t\t\t\t       &unsignedp, &reversep, &volatilep);\n+\t      /* As a future enhancement we could handle stores with the same\n+\t\t base and offset.  */\n+\t      bool invalid = offset || reversep\n+\t\t\t     || ((bitsize > MAX_BITSIZE_MODE_ANY_INT)\n+\t\t\t\t  && (TREE_CODE (rhs) != INTEGER_CST))\n+\t\t\t     || !rhs_valid_for_store_merging_p (rhs)\n+\t\t/* An access may not be volatile itself but base_addr may be\n+\t\t   a volatile decl i.e. MEM[&volatile-decl].  The hashing for\n+\t\t   tree_operand_hash won't consider such stores equal to each\n+\t\t   other so we can't track chains on them.  */\n+\t\t\t     || TREE_THIS_VOLATILE (base_addr);\n+\n+\t      /* In some cases get_inner_reference may return a\n+\t\t MEM_REF [ptr + byteoffset].  For the purposes of this pass\n+\t\t canonicalize the base_addr to MEM_REF [ptr] and take\n+\t\t byteoffset into account in the bitpos.  This occurs in\n+\t\t PR 23684 and this way we can catch more chains.  */\n+\t      if (TREE_CODE (base_addr) == MEM_REF\n+\t\t  && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (base_addr, 0))))\n+\t\t{\n+\t\t  offset_int bit_off, byte_off = mem_ref_offset (base_addr);\n+\t\t  bit_off = byte_off << LOG2_BITS_PER_UNIT;\n+\t\t  bit_off += bitpos;\n+\t\t  if (!wi::neg_p (bit_off) && wi::fits_shwi_p (bit_off))\n+\t\t    {\n+\t\t      bitpos = bit_off.to_shwi ();\n+\t\t      base_addr = build2 (MEM_REF, TREE_TYPE (base_addr),\n+\t\t\t\t\t  TREE_OPERAND (base_addr, 0),\n+\t\t\t\t\t  build_zero_cst (TREE_TYPE (\n+\t\t\t\t\t  TREE_OPERAND (base_addr, 1))));\n+\t\t    }\n+\t\t  else\n+\t\t    invalid = true;\n+\t\t}\n+\n+\t      struct imm_store_chain_info **chain_info\n+\t\t= m_stores.get (base_addr);\n+\n+\t      if (!invalid)\n+\t\t{\n+\t\t  store_immediate_info *info;\n+\t\t  if (chain_info)\n+\t\t    {\n+\t\t      info = new store_immediate_info (\n+\t\t\tbitsize, bitpos, rhs, lhs, stmt,\n+\t\t\t(*chain_info)->m_store_info.length ());\n+\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t\t{\n+\t\t\t  fprintf (dump_file,\n+\t\t\t\t   \"Recording immediate store from stmt:\\n\");\n+\t\t\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t\t\t}\n+\t\t      (*chain_info)->m_store_info.safe_push (info);\n+\t\t      /* If we reach the limit of stores to merge in a chain\n+\t\t\t terminate and process the chain now.  */\n+\t\t      if ((*chain_info)->m_store_info.length ()\n+\t\t\t   == (unsigned int)\n+\t\t\t      PARAM_VALUE (PARAM_MAX_STORES_TO_MERGE))\n+\t\t\t{\n+\t\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t\t    fprintf (dump_file,\n+\t\t\t\t \"Reached maximum number of statements\"\n+\t\t\t\t \" to merge:\\n\");\n+\t\t\t  terminate_and_release_chain (base_addr);\n+\t\t\t}\n+\t\t      continue;\n+\t\t    }\n+\n+\t\t  /* Store aliases any existing chain?  */\n+\t\t  terminate_all_aliasing_chains (lhs, base_addr, false, stmt);\n+\t\t  /* Start a new chain.  */\n+\t\t  struct imm_store_chain_info *new_chain\n+\t\t    = new imm_store_chain_info;\n+\t\t  info = new store_immediate_info (bitsize, bitpos, rhs, lhs,\n+\t\t\t\t\t\t   stmt, 0);\n+\t\t  new_chain->m_store_info.safe_push (info);\n+\t\t  m_stores.put (base_addr, new_chain);\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    {\n+\t\t      fprintf (dump_file,\n+\t\t\t       \"Starting new chain with statement:\\n\");\n+\t\t      print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t\t      fprintf (dump_file, \"The base object is:\\n\");\n+\t\t      print_generic_expr (dump_file, base_addr, 0);\n+\t\t      fprintf (dump_file, \"\\n\");\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\tterminate_all_aliasing_chains (lhs, base_addr,\n+\t\t\t\t\t       offset != NULL_TREE, stmt);\n+\n+\t      continue;\n+\t    }\n+\n+\t  terminate_all_aliasing_chains (NULL_TREE, NULL_TREE, false, stmt);\n+\t}\n+      terminate_and_process_all_chains ();\n+    }\n+  return 0;\n+}\n+\n+} // anon namespace\n+\n+/* Construct and return a store merging pass object.  */\n+\n+gimple_opt_pass *\n+make_pass_store_merging (gcc::context *ctxt)\n+{\n+  return new pass_store_merging (ctxt);\n+}"}, {"sha": "d381cb5227c8b010871fbf67e096d60c4b60105e", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=f663d9ad6eaa6ff32676981461e865f96cb7c151", "patch": "@@ -521,6 +521,7 @@ static const struct default_options default_options_table[] =\n     { OPT_LEVELS_2_PLUS, OPT_fisolate_erroneous_paths_dereference, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_fipa_ra, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_flra_remat, NULL, 1 },\n+    { OPT_LEVELS_2_PLUS, OPT_fstore_merging, NULL, 1 },\n \n     /* -O3 optimizations.  */\n     { OPT_LEVELS_3_PLUS, OPT_ftree_loop_distribute_patterns, NULL, 1 },"}, {"sha": "ab3eb3d3b42e44ae21ca03c484192afd1a06d206", "filename": "gcc/params.def", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=f663d9ad6eaa6ff32676981461e865f96cb7c151", "patch": "@@ -1094,6 +1094,18 @@ DEFPARAM (PARAM_MAX_TAIL_MERGE_COMPARISONS,\n           \"Maximum amount of similar bbs to compare a bb with.\",\n           10, 0, 0)\n \n+DEFPARAM (PARAM_STORE_MERGING_ALLOW_UNALIGNED,\n+\t  \"store-merging-allow-unaligned\",\n+\t  \"Allow the store merging pass to introduce unaligned stores \"\n+\t  \"if it is legal to do so\",\n+\t  1, 0, 1)\n+\n+DEFPARAM (PARAM_MAX_STORES_TO_MERGE,\n+\t  \"max-stores-to-merge\",\n+\t  \"Maximum number of constant stores to merge in the\"\n+\t  \"store merging pass\",\n+\t  64, 2, 0)\n+\n DEFPARAM (PARAM_MAX_TAIL_MERGE_ITERATIONS,\n           \"max-tail-merge-iterations\",\n           \"Maximum amount of iterations of the pass over a function.\","}, {"sha": "85a5af088f3eabb3a6e13fc412b81c638b5f84eb", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=f663d9ad6eaa6ff32676981461e865f96cb7c151", "patch": "@@ -332,6 +332,7 @@ along with GCC; see the file COPYING3.  If not see\n       NEXT_PASS (pass_phiopt);\n       NEXT_PASS (pass_fold_builtins);\n       NEXT_PASS (pass_optimize_widening_mul);\n+      NEXT_PASS (pass_store_merging);\n       NEXT_PASS (pass_tail_calls);\n       /* If DCE is not run before checking for uninitialized uses,\n \t we may get false warnings (e.g., testsuite/gcc.dg/uninit-5.c)."}, {"sha": "3a4041de42df9672fec2728ba37bb1d693c4dba5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f663d9ad6eaa6ff32676981461e865f96cb7c151", "patch": "@@ -1,3 +1,24 @@\n+2016-10-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+            Jakub Jelinek  <jakub@redhat.com>\n+            Andrew Pinski  <pinskia@gmail.com>\n+\n+\tPR middle-end/22141\n+\tPR rtl-optimization/23684\n+\t* gcc.c-torture/execute/pr22141-1.c: New test.\n+\t* gcc.c-torture/execute/pr22141-2.c: Likewise.\n+\t* gcc.target/aarch64/ldp_stp_1.c: Adjust for -fstore-merging.\n+\t* gcc.target/aarch64/ldp_stp_4.c: Likewise.\n+\t* gcc.dg/store_merging_1.c: New test.\n+\t* gcc.dg/store_merging_2.c: Likewise.\n+\t* gcc.dg/store_merging_3.c: Likewise.\n+\t* gcc.dg/store_merging_4.c: Likewise.\n+\t* gcc.dg/store_merging_5.c: Likewise.\n+\t* gcc.dg/store_merging_6.c: Likewise.\n+\t* gcc.dg/store_merging_7.c: Likewise.\n+\t* gcc.target/i386/pr22141.c: Likewise.\n+\t* gcc.target/i386/pr34012.c: Add -fno-store-merging to dg-options.\n+\t* g++.dg/init/new17.C: Likewise.\n+\n 2016-10-26  Will Schmidt <will_schmidt@vnet.ibm.com>\n \n \tPR middle-end/72747"}, {"sha": "f6a3231f9aa7eb8abdf061b50073176bc0cd37c3", "filename": "gcc/testsuite/g++.dg/init/new17.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew17.C?ref=f663d9ad6eaa6ff32676981461e865f96cb7c151", "patch": "@@ -1,5 +1,5 @@\n // { dg-do compile }\n-// { dg-options \"-O2 -fstrict-aliasing -fdump-tree-optimized\" }\n+// { dg-options \"-O2 -fstrict-aliasing -fno-store-merging -fdump-tree-optimized\" }\n \n // Test that placement new does not introduce an unnecessary memory\n // barrier."}, {"sha": "7c888b469cf39f00ced8ddb8cc6dc245fa30b97b", "filename": "gcc/testsuite/gcc.c-torture/execute/pr22141-1.c", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr22141-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr22141-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr22141-1.c?ref=f663d9ad6eaa6ff32676981461e865f96cb7c151", "patch": "@@ -0,0 +1,122 @@\n+/* PR middle-end/22141 */\n+\n+extern void abort (void);\n+\n+struct S\n+{\n+  struct T\n+    {\n+      char a;\n+      char b;\n+      char c;\n+      char d;\n+    } t;\n+} u;\n+\n+struct U\n+{\n+  struct S s[4];\n+};\n+\n+void __attribute__((noinline))\n+c1 (struct T *p)\n+{\n+  if (p->a != 1 || p->b != 2 || p->c != 3 || p->d != 4)\n+    abort ();\n+  __builtin_memset (p, 0xaa, sizeof (*p));\n+}\n+\n+void __attribute__((noinline))\n+c2 (struct S *p)\n+{\n+  c1 (&p->t);\n+}\n+\n+void __attribute__((noinline))\n+c3 (struct U *p)\n+{\n+  c2 (&p->s[2]);\n+}\n+\n+void __attribute__((noinline))\n+f1 (void)\n+{\n+  u = (struct S) { { 1, 2, 3, 4 } };\n+}\n+\n+void __attribute__((noinline))\n+f2 (void)\n+{\n+  u.t.a = 1;\n+  u.t.b = 2;\n+  u.t.c = 3;\n+  u.t.d = 4;\n+}\n+\n+void __attribute__((noinline))\n+f3 (void)\n+{\n+  u.t.d = 4;\n+  u.t.b = 2;\n+  u.t.a = 1;\n+  u.t.c = 3;\n+}\n+\n+void __attribute__((noinline))\n+f4 (void)\n+{\n+  struct S v;\n+  v.t.a = 1;\n+  v.t.b = 2;\n+  v.t.c = 3;\n+  v.t.d = 4;\n+  c2 (&v);\n+}\n+\n+void __attribute__((noinline))\n+f5 (struct S *p)\n+{\n+  p->t.a = 1;\n+  p->t.c = 3;\n+  p->t.d = 4;\n+  p->t.b = 2;\n+}\n+\n+void __attribute__((noinline))\n+f6 (void)\n+{\n+  struct U v;\n+  v.s[2].t.a = 1;\n+  v.s[2].t.b = 2;\n+  v.s[2].t.c = 3;\n+  v.s[2].t.d = 4;\n+  c3 (&v);\n+}\n+\n+void __attribute__((noinline))\n+f7 (struct U *p)\n+{\n+  p->s[2].t.a = 1;\n+  p->s[2].t.c = 3;\n+  p->s[2].t.d = 4;\n+  p->s[2].t.b = 2;\n+}\n+\n+int\n+main (void)\n+{\n+  struct U w;\n+  f1 ();\n+  c2 (&u);\n+  f2 ();\n+  c1 (&u.t);\n+  f3 ();\n+  c2 (&u);\n+  f4 ();\n+  f5 (&u);\n+  c2 (&u);\n+  f6 ();\n+  f7 (&w);\n+  c3 (&w);\n+  return 0;\n+}"}, {"sha": "cb9cc79026310260ffc3a83bfdf9bfc92f998a86", "filename": "gcc/testsuite/gcc.c-torture/execute/pr22141-2.c", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr22141-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr22141-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr22141-2.c?ref=f663d9ad6eaa6ff32676981461e865f96cb7c151", "patch": "@@ -0,0 +1,122 @@\n+/* PR middle-end/22141 */\n+\n+extern void abort (void);\n+\n+struct S\n+{\n+  struct T\n+    {\n+      char a;\n+      char b;\n+      char c;\n+      char d;\n+    } t;\n+} u __attribute__((aligned));\n+\n+struct U\n+{\n+  struct S s[4];\n+};\n+\n+void __attribute__((noinline))\n+c1 (struct T *p)\n+{\n+  if (p->a != 1 || p->b != 2 || p->c != 3 || p->d != 4)\n+    abort ();\n+  __builtin_memset (p, 0xaa, sizeof (*p));\n+}\n+\n+void __attribute__((noinline))\n+c2 (struct S *p)\n+{\n+  c1 (&p->t);\n+}\n+\n+void __attribute__((noinline))\n+c3 (struct U *p)\n+{\n+  c2 (&p->s[2]);\n+}\n+\n+void __attribute__((noinline))\n+f1 (void)\n+{\n+  u = (struct S) { { 1, 2, 3, 4 } };\n+}\n+\n+void __attribute__((noinline))\n+f2 (void)\n+{\n+  u.t.a = 1;\n+  u.t.b = 2;\n+  u.t.c = 3;\n+  u.t.d = 4;\n+}\n+\n+void __attribute__((noinline))\n+f3 (void)\n+{\n+  u.t.d = 4;\n+  u.t.b = 2;\n+  u.t.a = 1;\n+  u.t.c = 3;\n+}\n+\n+void __attribute__((noinline))\n+f4 (void)\n+{\n+  struct S v __attribute__((aligned));\n+  v.t.a = 1;\n+  v.t.b = 2;\n+  v.t.c = 3;\n+  v.t.d = 4;\n+  c2 (&v);\n+}\n+\n+void __attribute__((noinline))\n+f5 (struct S *p)\n+{\n+  p->t.a = 1;\n+  p->t.c = 3;\n+  p->t.d = 4;\n+  p->t.b = 2;\n+}\n+\n+void __attribute__((noinline))\n+f6 (void)\n+{\n+  struct U v __attribute__((aligned));\n+  v.s[2].t.a = 1;\n+  v.s[2].t.b = 2;\n+  v.s[2].t.c = 3;\n+  v.s[2].t.d = 4;\n+  c3 (&v);\n+}\n+\n+void __attribute__((noinline))\n+f7 (struct U *p)\n+{\n+  p->s[2].t.a = 1;\n+  p->s[2].t.c = 3;\n+  p->s[2].t.d = 4;\n+  p->s[2].t.b = 2;\n+}\n+\n+int\n+main (void)\n+{\n+  struct U w __attribute__((aligned));\n+  f1 ();\n+  c2 (&u);\n+  f2 ();\n+  c1 (&u.t);\n+  f3 ();\n+  c2 (&u);\n+  f4 ();\n+  f5 (&u);\n+  c2 (&u);\n+  f6 ();\n+  f7 (&w);\n+  c3 (&w);\n+  return 0;\n+}"}, {"sha": "35f4d82e6b22a231f1d7c6b3688a4bbcb57d2510", "filename": "gcc/testsuite/gcc.dg/store_merging_1.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_1.c?ref=f663d9ad6eaa6ff32676981461e865f96cb7c151", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target non_strict_align } */\n+/* { dg-options \"-O2 -fdump-tree-store-merging\" } */\n+\n+struct bar {\n+  int a;\n+  char b;\n+  char c;\n+  char d;\n+  char e;\n+  char f;\n+  char g;\n+};\n+\n+void\n+foo1 (struct bar *p)\n+{\n+  p->b = 0;\n+  p->a = 0;\n+  p->c = 0;\n+  p->d = 0;\n+  p->e = 0;\n+}\n+\n+void\n+foo2 (struct bar *p)\n+{\n+  p->b = 0;\n+  p->a = 0;\n+  p->c = 1;\n+  p->d = 0;\n+  p->e = 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Merging successful\" 2 \"store-merging\" } } */"}, {"sha": "8e2acf390891284d96f646efd2b025a2ad7cb87d", "filename": "gcc/testsuite/gcc.dg/store_merging_2.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_2.c?ref=f663d9ad6eaa6ff32676981461e865f96cb7c151", "patch": "@@ -0,0 +1,80 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target non_strict_align } */\n+/* { dg-options \"-O2 -fdump-tree-store-merging\" } */\n+\n+struct bar\n+{\n+  int a;\n+  unsigned char b;\n+  unsigned char c;\n+  short d;\n+  unsigned char e;\n+  unsigned char f;\n+  unsigned char g;\n+};\n+\n+__attribute__ ((noinline)) void\n+foozero (struct bar *p)\n+{\n+  p->b = 0;\n+  p->a = 0;\n+  p->c = 0;\n+  p->d = 0;\n+  p->e = 0;\n+  p->f = 0;\n+  p->g = 0;\n+}\n+\n+__attribute__ ((noinline)) void\n+foo1 (struct bar *p)\n+{\n+  p->b = 1;\n+  p->a = 2;\n+  p->c = 3;\n+  p->d = 4;\n+  p->e = 5;\n+  p->f = 0;\n+  p->g = 0xff;\n+}\n+\n+__attribute__ ((noinline)) void\n+foo2 (struct bar *p, struct bar *p2)\n+{\n+  p->b = 0xff;\n+  p2->b = 0xa;\n+  p->a = 0xfffff;\n+  p2->c = 0xc;\n+  p->c = 0xff;\n+  p2->d = 0xbf;\n+  p->d = 0xfff;\n+}\n+\n+int\n+main (void)\n+{\n+  struct bar b1, b2;\n+  foozero (&b1);\n+  foozero (&b2);\n+\n+  foo1 (&b1);\n+  if (b1.b != 1 || b1.a != 2 || b1.c != 3 || b1.d != 4 || b1.e != 5\n+      || b1.f != 0 || b1.g != 0xff)\n+    __builtin_abort ();\n+\n+  foozero (&b1);\n+  /* Make sure writes to aliasing struct pointers preserve the\n+     correct order.  */\n+  foo2 (&b1, &b1);\n+  if (b1.b != 0xa || b1.a != 0xfffff || b1.c != 0xff || b1.d != 0xfff)\n+    __builtin_abort ();\n+\n+  foozero (&b1);\n+  foo2 (&b1, &b2);\n+  if (b1.a != 0xfffff || b1.b != 0xff || b1.c != 0xff || b1.d != 0xfff\n+      || b2.b != 0xa || b2.c != 0xc || b2.d != 0xbf)\n+    __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Merging successful\" 2 \"store-merging\" } } */"}, {"sha": "caf356da98159074488186dba6cad02233fa3aa2", "filename": "gcc/testsuite/gcc.dg/store_merging_3.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_3.c?ref=f663d9ad6eaa6ff32676981461e865f96cb7c151", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target non_strict_align } */\n+/* { dg-options \"-O2 -fdump-tree-store-merging-details\" } */\n+\n+/* Make sure stores to volatile addresses don't get combined with\n+   other accesses.  */\n+\n+struct bar\n+{\n+  int a;\n+  char b;\n+  char c;\n+  volatile short d;\n+  char e;\n+  char f;\n+  char g;\n+};\n+\n+void\n+foozero (struct bar *p)\n+{\n+  p->b = 0xa;\n+  p->a = 0xb;\n+  p->c = 0xc;\n+  p->d = 0;\n+  p->e = 0xd;\n+  p->f = 0xe;\n+  p->g = 0xf;\n+}\n+\n+/* { dg-final { scan-tree-dump \"Volatile access terminates all chains\" \"store-merging\" } } */\n+/* { dg-final { scan-tree-dump-times \"=\\{v\\} 0;\" 1 \"store-merging\" } } */"}, {"sha": "a3d67697d6418ba0cd8aaad2f92d9ea720ec7ffc", "filename": "gcc/testsuite/gcc.dg/store_merging_4.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_4.c?ref=f663d9ad6eaa6ff32676981461e865f96cb7c151", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target non_strict_align } */\n+/* { dg-options \"-O2 -fdump-tree-store-merging\" } */\n+\n+/* Check that we can merge interleaving stores that are guaranteed\n+   to be non-aliasing.  */\n+\n+struct bar\n+{\n+  int a;\n+  char b;\n+  char c;\n+  short d;\n+  char e;\n+  char f;\n+  char g;\n+};\n+\n+void\n+foozero (struct bar *restrict p, struct bar *restrict p2)\n+{\n+  p->b = 0xff;\n+  p2->b = 0xa;\n+  p->a = 0xfffff;\n+  p2->a = 0xab;\n+  p2->c = 0xc;\n+  p->c = 0xff;\n+  p2->d = 0xbf;\n+  p->d = 0xfff;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Merging successful\" 2 \"store-merging\" } } */"}, {"sha": "4ffe512b842b81d97d0158cb765669758c5ff898", "filename": "gcc/testsuite/gcc.dg/store_merging_5.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_5.c?ref=f663d9ad6eaa6ff32676981461e865f96cb7c151", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target non_strict_align } */\n+/* { dg-options \"-O2 -fdump-tree-store-merging\" } */\n+\n+/* Make sure that non-aliasing non-constant interspersed stores do not\n+   stop chains.  */\n+\n+struct bar {\n+  int a;\n+  char b;\n+  char c;\n+  char d;\n+  char e;\n+  char g;\n+};\n+\n+void\n+foo1 (struct bar *p, char tmp)\n+{\n+  p->a = 0;\n+  p->b = 0;\n+  p->g = tmp;\n+  p->c = 0;\n+  p->d = 0;\n+  p->e = 0;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"Merging successful\" 1 \"store-merging\" } } */\n+/* { dg-final { scan-tree-dump-times \"MEM\\\\\\[.*\\\\\\]\" 1 \"store-merging\" } } */"}, {"sha": "42b5c4f92dc8e99ec1a84cec4ce557eeaeab8d18", "filename": "gcc/testsuite/gcc.dg/store_merging_6.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_6.c?ref=f663d9ad6eaa6ff32676981461e865f96cb7c151", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target non_strict_align } */\n+/* { dg-options \"-O2 -fdump-tree-store-merging\" } */\n+\n+/* Check that we can widen accesses to bitfields.  */\n+\n+struct bar {\n+  int a : 3;\n+  unsigned char b : 4;\n+  unsigned char c : 1;\n+  char d;\n+  char e;\n+  char f;\n+  char g;\n+};\n+\n+__attribute__ ((noinline)) void\n+foozero (struct bar *p)\n+{\n+  p->b = 0;\n+  p->a = 0;\n+  p->c = 0;\n+  p->d = 0;\n+  p->e = 0;\n+  p->f = 0;\n+  p->g = 0;\n+}\n+\n+__attribute__ ((noinline)) void\n+foo1 (struct bar *p)\n+{\n+  p->b = 3;\n+  p->a = 2;\n+  p->c = 1;\n+  p->d = 4;\n+  p->e = 5;\n+}\n+\n+int\n+main (void)\n+{\n+  struct bar p;\n+  foozero (&p);\n+  foo1 (&p);\n+  if (p.a != 2 || p.b != 3 || p.c != 1 || p.d != 4 || p.e != 5\n+      || p.f != 0 || p.g != 0)\n+    __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"Merging successful\" 2 \"store-merging\" } } */"}, {"sha": "4be352fef4a61d97f0e95784f5061f7fc124b937", "filename": "gcc/testsuite/gcc.dg/store_merging_7.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_7.c?ref=f663d9ad6eaa6ff32676981461e865f96cb7c151", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target non_strict_align } */\n+/* { dg-options \"-O2 -fdump-tree-store-merging\" } */\n+\n+/* Check that we can merge consecutive array members through the pointer.\n+   PR rtl-optimization/23684.  */\n+\n+void\n+foo (char *input)\n+{\n+  input = __builtin_assume_aligned (input, 8);\n+  input[0] = 'H';\n+  input[1] = 'e';\n+  input[2] = 'l';\n+  input[3] = 'l';\n+  input[4] = 'o';\n+  input[5] = ' ';\n+  input[6] = 'w';\n+  input[7] = 'o';\n+  input[8] = 'r';\n+  input[9] = 'l';\n+  input[10] = 'd';\n+  input[11] = '\\0';\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Merging successful\" 1 \"store-merging\" } } */"}, {"sha": "9de4e771ab1e73bce960d4038f8ec5b49b5c612c", "filename": "gcc/testsuite/gcc.target/aarch64/ldp_stp_1.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_1.c?ref=f663d9ad6eaa6ff32676981461e865f96cb7c151", "patch": "@@ -3,22 +3,22 @@\n int arr[4][4];\n \n void\n-foo ()\n+foo (int x, int y)\n {\n-  arr[0][1] = 1;\n-  arr[1][0] = -1;\n-  arr[2][0] = 1;\n-  arr[1][1] = -1;\n-  arr[0][2] = 1;\n-  arr[0][3] = -1;\n-  arr[1][2] = 1;\n-  arr[2][1] = -1;\n-  arr[3][0] = 1;\n-  arr[3][1] = -1;\n-  arr[2][2] = 1;\n-  arr[1][3] = -1;\n-  arr[2][3] = 1;\n-  arr[3][2] = -1;\n+  arr[0][1] = x;\n+  arr[1][0] = y;\n+  arr[2][0] = x;\n+  arr[1][1] = y;\n+  arr[0][2] = x;\n+  arr[0][3] = y;\n+  arr[1][2] = x;\n+  arr[2][1] = y;\n+  arr[3][0] = x;\n+  arr[3][1] = y;\n+  arr[2][2] = x;\n+  arr[1][3] = y;\n+  arr[2][3] = x;\n+  arr[3][2] = y;\n }\n \n /* { dg-final { scan-assembler-times \"stp\\tw\\[0-9\\]+, w\\[0-9\\]\" 7 } } */"}, {"sha": "824f0d2e81bc250f40ffb71b3e39cde76c9ff28d", "filename": "gcc/testsuite/gcc.target/aarch64/ldp_stp_4.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fldp_stp_4.c?ref=f663d9ad6eaa6ff32676981461e865f96cb7c151", "patch": "@@ -3,22 +3,22 @@\n float arr[4][4];\n \n void\n-foo ()\n+foo (float x, float y)\n {\n-  arr[0][1] = 1;\n-  arr[1][0] = -1;\n-  arr[2][0] = 1;\n-  arr[1][1] = -1;\n-  arr[0][2] = 1;\n-  arr[0][3] = -1;\n-  arr[1][2] = 1;\n-  arr[2][1] = -1;\n-  arr[3][0] = 1;\n-  arr[3][1] = -1;\n-  arr[2][2] = 1;\n-  arr[1][3] = -1;\n-  arr[2][3] = 1;\n-  arr[3][2] = -1;\n+  arr[0][1] = x;\n+  arr[1][0] = y;\n+  arr[2][0] = x;\n+  arr[1][1] = y;\n+  arr[0][2] = x;\n+  arr[0][3] = y;\n+  arr[1][2] = x;\n+  arr[2][1] = y;\n+  arr[3][0] = x;\n+  arr[3][1] = y;\n+  arr[2][2] = x;\n+  arr[1][3] = y;\n+  arr[2][3] = x;\n+  arr[3][2] = y;\n }\n \n /* { dg-final { scan-assembler-times \"stp\\ts\\[0-9\\]+, s\\[0-9\\]\" 7 } } */"}, {"sha": "036422e8ccf3a60c8dde10b7ce90dd391afe7f1d", "filename": "gcc/testsuite/gcc.target/i386/pr22141.c", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr22141.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr22141.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr22141.c?ref=f663d9ad6eaa6ff32676981461e865f96cb7c151", "patch": "@@ -0,0 +1,126 @@\n+/* PR middle-end/22141 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Os\" } */\n+\n+extern void abort (void);\n+\n+struct S\n+{\n+  struct T\n+    {\n+      char a;\n+      char b;\n+      char c;\n+      char d;\n+    } t;\n+} u;\n+\n+struct U\n+{\n+  struct S s[4];\n+};\n+\n+void __attribute__((noinline))\n+c1 (struct T *p)\n+{\n+  if (p->a != 1 || p->b != 2 || p->c != 3 || p->d != 4)\n+    abort ();\n+  __builtin_memset (p, 0xaa, sizeof (*p));\n+}\n+\n+void __attribute__((noinline))\n+c2 (struct S *p)\n+{\n+  c1 (&p->t);\n+}\n+\n+void __attribute__((noinline))\n+c3 (struct U *p)\n+{\n+  c2 (&p->s[2]);\n+}\n+\n+void __attribute__((noinline))\n+f1 (void)\n+{\n+  u = (struct S) { { 1, 2, 3, 4 } };\n+}\n+\n+void __attribute__((noinline))\n+f2 (void)\n+{\n+  u.t.a = 1;\n+  u.t.b = 2;\n+  u.t.c = 3;\n+  u.t.d = 4;\n+}\n+\n+void __attribute__((noinline))\n+f3 (void)\n+{\n+  u.t.d = 4;\n+  u.t.b = 2;\n+  u.t.a = 1;\n+  u.t.c = 3;\n+}\n+\n+void __attribute__((noinline))\n+f4 (void)\n+{\n+  struct S v;\n+  v.t.a = 1;\n+  v.t.b = 2;\n+  v.t.c = 3;\n+  v.t.d = 4;\n+  c2 (&v);\n+}\n+\n+void __attribute__((noinline))\n+f5 (struct S *p)\n+{\n+  p->t.a = 1;\n+  p->t.c = 3;\n+  p->t.d = 4;\n+  p->t.b = 2;\n+}\n+\n+void __attribute__((noinline))\n+f6 (void)\n+{\n+  struct U v;\n+  v.s[2].t.a = 1;\n+  v.s[2].t.b = 2;\n+  v.s[2].t.c = 3;\n+  v.s[2].t.d = 4;\n+  c3 (&v);\n+}\n+\n+void __attribute__((noinline))\n+f7 (struct U *p)\n+{\n+  p->s[2].t.a = 1;\n+  p->s[2].t.c = 3;\n+  p->s[2].t.d = 4;\n+  p->s[2].t.b = 2;\n+}\n+\n+int\n+main (void)\n+{\n+  struct U w;\n+  f1 ();\n+  c2 (&u);\n+  f2 ();\n+  c1 (&u.t);\n+  f3 ();\n+  c2 (&u);\n+  f4 ();\n+  f5 (&u);\n+  c2 (&u);\n+  f6 ();\n+  f7 (&w);\n+  c3 (&w);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times \"67305985\\|4030201\" 7 } } */"}, {"sha": "d0cffa052905a1c11e0927e92ab295d71517f746", "filename": "gcc/testsuite/gcc.target/i386/pr34012.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr34012.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr34012.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr34012.c?ref=f663d9ad6eaa6ff32676981461e865f96cb7c151", "patch": "@@ -1,7 +1,7 @@\n /* PR rtl-optimization/34012 */\n /* { dg-do compile } */\n /* { dg-require-effective-target lp64 } */\n-/* { dg-options \"-O2\" } */\n+/* { dg-options \"-O2 -fno-store-merging\" } */\n \n void bar (long int *);\n void"}, {"sha": "f17ad8918881ccf1d2895e0326976a4adb2d0bd0", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=f663d9ad6eaa6ff32676981461e865f96cb7c151", "patch": "@@ -282,6 +282,7 @@ DEFTIMEVAR (TV_TREE_UNINIT           , \"uninit var analysis\")\n DEFTIMEVAR (TV_PLUGIN_INIT           , \"plugin initialization\")\n DEFTIMEVAR (TV_PLUGIN_RUN            , \"plugin execution\")\n DEFTIMEVAR (TV_GIMPLE_SLSR           , \"straight-line strength reduction\")\n+DEFTIMEVAR (TV_GIMPLE_STORE_MERGING  , \"store merging\")\n DEFTIMEVAR (TV_VTABLE_VERIFICATION   , \"vtable verification\")\n DEFTIMEVAR (TV_TREE_UBSAN            , \"tree ubsan\")\n DEFTIMEVAR (TV_INITIALIZE_RTL        , \"initialize rtl\")"}, {"sha": "da9ba1374b4e6d3e90f26efe0ec0111666d9e1be", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f663d9ad6eaa6ff32676981461e865f96cb7c151/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=f663d9ad6eaa6ff32676981461e865f96cb7c151", "patch": "@@ -426,6 +426,7 @@ extern gimple_opt_pass *make_pass_late_warn_uninitialized (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_cse_reciprocals (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_cse_sincos (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_optimize_bswap (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_store_merging (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_optimize_widening_mul (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_warn_function_return (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_warn_function_noreturn (gcc::context *ctxt);"}]}