{"sha": "99206968a8da4e5342b498f264eb365e11a499c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTkyMDY5NjhhOGRhNGU1MzQyYjQ5OGYyNjRlYjM2NWUxMWE0OTljOA==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2015-05-27T13:25:01Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2015-05-27T13:25:01Z"}, "message": "[expr.c] PR target/65358 Avoid clobbering partial argument during sibcall\n\n\tPR target/65358\n\t* expr.c (memory_load_overlap): New function.\n\t(emit_push_insn): When pushing partial args to the stack would\n\tclobber the register part load the overlapping part into a pseudo\n\tand put it into the hard reg after pushing.  Change return type\n\tto bool.  Add bool argument.\n\t* expr.h (emit_push_insn): Change return type to bool.\n\tAdd bool argument.\n\t* calls.c (expand_call): Cancel sibcall optimization when encountering\n\tpartial argument on targets with ARGS_GROW_DOWNWARD and\n\t!STACK_GROWS_DOWNWARD.\n\t(emit_library_call_value_1): Update callsite of emit_push_insn.\n\t(store_one_arg): Likewise. \n\n\tPR target/65358\n\t* gcc.dg/pr65358.c: New test.\n\nFrom-SVN: r223753", "tree": {"sha": "1f87b9fb46c70610a2b5ca644213e39984ef9d6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f87b9fb46c70610a2b5ca644213e39984ef9d6a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99206968a8da4e5342b498f264eb365e11a499c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99206968a8da4e5342b498f264eb365e11a499c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99206968a8da4e5342b498f264eb365e11a499c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99206968a8da4e5342b498f264eb365e11a499c8/comments", "author": null, "committer": null, "parents": [{"sha": "66371f94f55df849da15ffa9334868de99ac1f8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66371f94f55df849da15ffa9334868de99ac1f8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66371f94f55df849da15ffa9334868de99ac1f8c"}], "stats": {"total": 166, "additions": 151, "deletions": 15}, "files": [{"sha": "fae616144a50d2e8949f2a1044b87a659bab0642", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99206968a8da4e5342b498f264eb365e11a499c8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99206968a8da4e5342b498f264eb365e11a499c8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=99206968a8da4e5342b498f264eb365e11a499c8", "patch": "@@ -1,3 +1,19 @@\n+2015-05-27  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\tPR target/65358\n+\t* expr.c (memory_load_overlap): New function.\n+\t(emit_push_insn): When pushing partial args to the stack would\n+\tclobber the register part load the overlapping part into a pseudo\n+\tand put it into the hard reg after pushing.  Change return type\n+\tto bool.  Add bool argument.\n+\t* expr.h (emit_push_insn): Change return type to bool.\n+\tAdd bool argument.\n+\t* calls.c (expand_call): Cancel sibcall optimization when encountering\n+\tpartial argument on targets with ARGS_GROW_DOWNWARD and\n+\t!STACK_GROWS_DOWNWARD.\n+\t(emit_library_call_value_1): Update callsite of emit_push_insn.\n+\t(store_one_arg): Likewise. \n+\n 2015-05-27  Gregor Richards  <gregor.richards@uwaterloo.ca>\n \n \t* config/arm/linux-eabi.h (MUSL_DYNAMIC_LINKER): Define."}, {"sha": "2158ebad0b48d388d03d6469769476675f797e55", "filename": "gcc/calls.c", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99206968a8da4e5342b498f264eb365e11a499c8/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99206968a8da4e5342b498f264eb365e11a499c8/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=99206968a8da4e5342b498f264eb365e11a499c8", "patch": "@@ -3234,6 +3234,15 @@ expand_call (tree exp, rtx target, int ignore)\n \t    {\n \t      rtx_insn *before_arg = get_last_insn ();\n \n+\t     /* On targets with weird calling conventions (e.g. PA) it's\n+\t\thard to ensure that all cases of argument overlap between\n+\t\tstack and registers work.  Play it safe and bail out.  */\n+\t      if (ARGS_GROW_DOWNWARD && !STACK_GROWS_DOWNWARD)\n+\t\t{\n+\t\t  sibcall_failure = 1;\n+\t\t  break;\n+\t\t}\n+\n \t      if (store_one_arg (&args[i], argblock, flags,\n \t\t\t\t adjusted_args_size.var != 0,\n \t\t\t\t reg_parm_stack_space)\n@@ -4276,7 +4285,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t\t\t  partial, reg, 0, argblock,\n \t\t\t  GEN_INT (argvec[argnum].locate.offset.constant),\n \t\t\t  reg_parm_stack_space,\n-\t\t\t  ARGS_SIZE_RTX (argvec[argnum].locate.alignment_pad));\n+\t\t\t  ARGS_SIZE_RTX (argvec[argnum].locate.alignment_pad), false);\n \n \t  /* Now mark the segment we just used.  */\n \t  if (ACCUMULATE_OUTGOING_ARGS)\n@@ -4886,10 +4895,11 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n \n       /* This isn't already where we want it on the stack, so put it there.\n \t This can either be done with push or copy insns.  */\n-      emit_push_insn (arg->value, arg->mode, TREE_TYPE (pval), NULL_RTX,\n+      if (!emit_push_insn (arg->value, arg->mode, TREE_TYPE (pval), NULL_RTX,\n \t\t      parm_align, partial, reg, used - size, argblock,\n \t\t      ARGS_SIZE_RTX (arg->locate.offset), reg_parm_stack_space,\n-\t\t      ARGS_SIZE_RTX (arg->locate.alignment_pad));\n+\t\t      ARGS_SIZE_RTX (arg->locate.alignment_pad), true))\n+\tsibcall_failure = 1;\n \n       /* Unless this is a partially-in-register argument, the argument is now\n \t in the stack.  */\n@@ -4994,7 +5004,7 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n       emit_push_insn (arg->value, arg->mode, TREE_TYPE (pval), size_rtx,\n \t\t      parm_align, partial, reg, excess, argblock,\n \t\t      ARGS_SIZE_RTX (arg->locate.offset), reg_parm_stack_space,\n-\t\t      ARGS_SIZE_RTX (arg->locate.alignment_pad));\n+\t\t      ARGS_SIZE_RTX (arg->locate.alignment_pad), false);\n \n       /* Unless this is a partially-in-register argument, the argument is now\n \t in the stack."}, {"sha": "1dd1cf301f2abca1d7aaf62ff25d1319c346c75d", "filename": "gcc/expr.c", "status": "modified", "additions": 81, "deletions": 9, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99206968a8da4e5342b498f264eb365e11a499c8/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99206968a8da4e5342b498f264eb365e11a499c8/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=99206968a8da4e5342b498f264eb365e11a499c8", "patch": "@@ -4104,12 +4104,35 @@ emit_single_push_insn (machine_mode mode, rtx x, tree type)\n }\n #endif\n \n+/* If reading SIZE bytes from X will end up reading from\n+   Y return the number of bytes that overlap.  Return -1\n+   if there is no overlap or -2 if we can't determine\n+   (for example when X and Y have different base registers).  */\n+\n+static int\n+memory_load_overlap (rtx x, rtx y, HOST_WIDE_INT size)\n+{\n+  rtx tmp = plus_constant (Pmode, x, size);\n+  rtx sub = simplify_gen_binary (MINUS, Pmode, tmp, y);\n+\n+  if (!CONST_INT_P (sub))\n+    return -2;\n+\n+  HOST_WIDE_INT val = INTVAL (sub);\n+\n+  return IN_RANGE (val, 1, size) ? val : -1;\n+}\n+\n /* Generate code to push X onto the stack, assuming it has mode MODE and\n    type TYPE.\n    MODE is redundant except when X is a CONST_INT (since they don't\n    carry mode info).\n    SIZE is an rtx for the size of data to be copied (in bytes),\n    needed only if X is BLKmode.\n+   Return true if successful.  May return false if asked to push a\n+   partial argument during a sibcall optimization (as specified by\n+   SIBCALL_P) and the incoming and outgoing pointers cannot be shown\n+   to not overlap.\n \n    ALIGN (in bits) is maximum alignment we can assume.\n \n@@ -4135,11 +4158,11 @@ emit_single_push_insn (machine_mode mode, rtx x, tree type)\n    for arguments passed in registers.  If nonzero, it will be the number\n    of bytes required.  */\n \n-void\n+bool\n emit_push_insn (rtx x, machine_mode mode, tree type, rtx size,\n \t\tunsigned int align, int partial, rtx reg, int extra,\n \t\trtx args_addr, rtx args_so_far, int reg_parm_stack_space,\n-\t\trtx alignment_pad)\n+\t\trtx alignment_pad, bool sibcall_p)\n {\n   rtx xinner;\n   enum direction stack_direction = STACK_GROWS_DOWNWARD ? downward : upward;\n@@ -4157,6 +4180,10 @@ emit_push_insn (rtx x, machine_mode mode, tree type, rtx size,\n \n   xinner = x;\n \n+  int nregs = partial / UNITS_PER_WORD;\n+  rtx *tmp_regs = NULL;\n+  int overlapping = 0;\n+\n   if (mode == BLKmode\n       || (STRICT_ALIGNMENT && align < GET_MODE_ALIGNMENT (mode)))\n     {\n@@ -4287,6 +4314,43 @@ emit_push_insn (rtx x, machine_mode mode, tree type, rtx size,\n \t     PARM_BOUNDARY.  Assume the caller isn't lying.  */\n \t  set_mem_align (target, align);\n \n+\t  /* If part should go in registers and pushing to that part would\n+\t     overwrite some of the values that need to go into regs, load the\n+\t     overlapping values into temporary pseudos to be moved into the hard\n+\t     regs at the end after the stack pushing has completed.\n+\t     We cannot load them directly into the hard regs here because\n+\t     they can be clobbered by the block move expansions.\n+\t     See PR 65358.  */\n+\n+\t  if (partial > 0 && reg != 0 && mode == BLKmode\n+\t      && GET_CODE (reg) != PARALLEL)\n+\t    {\n+\t      overlapping = memory_load_overlap (XEXP (x, 0), temp, partial);\n+\t      if (overlapping > 0)\n+\t        {\n+\t\t  gcc_assert (overlapping % UNITS_PER_WORD == 0);\n+\t\t  overlapping /= UNITS_PER_WORD;\n+\n+\t\t  tmp_regs = XALLOCAVEC (rtx, overlapping);\n+\n+\t\t  for (int i = 0; i < overlapping; i++)\n+\t\t    tmp_regs[i] = gen_reg_rtx (word_mode);\n+\n+\t\t  for (int i = 0; i < overlapping; i++)\n+\t\t    emit_move_insn (tmp_regs[i],\n+\t\t\t\t    operand_subword_force (target, i, mode));\n+\t        }\n+\t      else if (overlapping == -1)\n+\t\toverlapping = 0;\n+\t      /* Could not determine whether there is overlap.\n+\t         Fail the sibcall.  */\n+\t      else\n+\t\t{\n+\t\t  overlapping = 0;\n+\t\t  if (sibcall_p)\n+\t\t    return false;\n+\t\t}\n+\t    }\n \t  emit_block_move (target, xinner, size, BLOCK_OP_CALL_PARM);\n \t}\n     }\n@@ -4341,12 +4405,13 @@ emit_push_insn (rtx x, machine_mode mode, tree type, rtx size,\n \t has a size a multiple of a word.  */\n       for (i = size - 1; i >= not_stack; i--)\n \tif (i >= not_stack + offset)\n-\t  emit_push_insn (operand_subword_force (x, i, mode),\n+\t  if (!emit_push_insn (operand_subword_force (x, i, mode),\n \t\t\t  word_mode, NULL_TREE, NULL_RTX, align, 0, NULL_RTX,\n \t\t\t  0, args_addr,\n \t\t\t  GEN_INT (args_offset + ((i - not_stack + skip)\n \t\t\t\t\t\t  * UNITS_PER_WORD)),\n-\t\t\t  reg_parm_stack_space, alignment_pad);\n+\t\t\t  reg_parm_stack_space, alignment_pad, sibcall_p))\n+\t    return false;\n     }\n   else\n     {\n@@ -4389,19 +4454,24 @@ emit_push_insn (rtx x, machine_mode mode, tree type, rtx size,\n \t}\n     }\n \n-  /* If part should go in registers, copy that part\n-     into the appropriate registers.  Do this now, at the end,\n-     since mem-to-mem copies above may do function calls.  */\n+  /* Move the partial arguments into the registers and any overlapping\n+     values that we moved into the pseudos in tmp_regs.  */\n   if (partial > 0 && reg != 0)\n     {\n       /* Handle calls that pass values in multiple non-contiguous locations.\n \t The Irix 6 ABI has examples of this.  */\n       if (GET_CODE (reg) == PARALLEL)\n \temit_group_load (reg, x, type, -1);\n       else\n-\t{\n+        {\n \t  gcc_assert (partial % UNITS_PER_WORD == 0);\n-\t  move_block_to_reg (REGNO (reg), x, partial / UNITS_PER_WORD, mode);\n+\t  move_block_to_reg (REGNO (reg), x, nregs - overlapping, mode);\n+\n+\t  for (int i = 0; i < overlapping; i++)\n+\t    emit_move_insn (gen_rtx_REG (word_mode, REGNO (reg)\n+\t\t\t\t\t\t    + nregs - overlapping + i),\n+\t\t\t    tmp_regs[i]);\n+\n \t}\n     }\n \n@@ -4410,6 +4480,8 @@ emit_push_insn (rtx x, machine_mode mode, tree type, rtx size,\n \n   if (alignment_pad && args_addr == 0)\n     anti_adjust_stack (alignment_pad);\n+\n+  return true;\n }\n \f\n /* Return X if X can be used as a subtarget in a sequence of arithmetic"}, {"sha": "7b28ffd8d39c1ec1ac75fe7ea5b14a5d7afed46e", "filename": "gcc/expr.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99206968a8da4e5342b498f264eb365e11a499c8/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99206968a8da4e5342b498f264eb365e11a499c8/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=99206968a8da4e5342b498f264eb365e11a499c8", "patch": "@@ -219,8 +219,8 @@ extern rtx emit_move_resolve_push (machine_mode, rtx);\n extern rtx push_block (rtx, int, int);\n \n /* Generate code to push something onto the stack, given its mode and type.  */\n-extern void emit_push_insn (rtx, machine_mode, tree, rtx, unsigned int,\n-\t\t\t    int, rtx, int, rtx, rtx, int, rtx);\n+extern bool emit_push_insn (rtx, machine_mode, tree, rtx, unsigned int,\n+\t\t\t    int, rtx, int, rtx, rtx, int, rtx, bool);\n \n /* Expand an assignment that stores the value of FROM into TO.  */\n extern void expand_assignment (tree, tree, bool);"}, {"sha": "4119cb8be62bc0e46433a81f814ed6291d1f4d47", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99206968a8da4e5342b498f264eb365e11a499c8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99206968a8da4e5342b498f264eb365e11a499c8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=99206968a8da4e5342b498f264eb365e11a499c8", "patch": "@@ -1,3 +1,8 @@\n+2015-05-27  Honggyu Kim  <hong.gyu.kim@lge.com>\n+\n+\tPR target/65358\n+\t* gcc.dg/pr65358.c: New test. \n+\n 2015-05-27  Andre Vehreschild  <vehre@gmx.de>\n \n \tPR fortran/65548"}, {"sha": "ba89fd4818bee39f515b79195ae0c6fcb04ef52d", "filename": "gcc/testsuite/gcc.dg/pr65358.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99206968a8da4e5342b498f264eb365e11a499c8/gcc%2Ftestsuite%2Fgcc.dg%2Fpr65358.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99206968a8da4e5342b498f264eb365e11a499c8/gcc%2Ftestsuite%2Fgcc.dg%2Fpr65358.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr65358.c?ref=99206968a8da4e5342b498f264eb365e11a499c8", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+struct pack\n+{\n+  int fine;\n+  int victim;\n+  int killer;\n+};\n+\n+int __attribute__ ((__noinline__, __noclone__))\n+bar (int a, int b, struct pack p)\n+{\n+  if (a != 20 || b != 30)\n+    __builtin_abort ();\n+  if (p.fine != 40 || p.victim != 50 || p.killer != 60)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+int __attribute__ ((__noinline__, __noclone__))\n+foo (int arg1, int arg2, int arg3, struct pack p)\n+{\n+  return bar (arg2, arg3, p);\n+}\n+\n+int main (void)\n+{\n+  struct pack p = { 40, 50, 60 };\n+\n+  (void) foo (10, 20, 30, p);\n+  return 0;\n+}"}]}