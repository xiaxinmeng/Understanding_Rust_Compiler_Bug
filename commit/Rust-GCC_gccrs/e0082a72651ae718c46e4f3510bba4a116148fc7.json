{"sha": "e0082a72651ae718c46e4f3510bba4a116148fc7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTAwODJhNzI2NTFhZTcxOGM0NmU0ZjM1MTBiYmE0YTExNjE0OGZjNw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2002-05-23T19:23:51Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2002-05-23T19:23:51Z"}, "message": "bb-reorder.c (make_reorder_chain, [...]): Use FOR_EACH_BB macros to iterate over basic block chain.\n\n\t* bb-reorder.c (make_reorder_chain, make_reorder_chain_1):\n\tUse FOR_EACH_BB macros to iterate over basic block chain.\n\t* cfg.c (clear_edges, clear_bb_flags, dump_flow_info,\n\talloc_aux_for_blocks, clear_aux_for_blocks, alloc_aux_for_edges):\n\tLikewise.\n\t* cfganal.c (set_edge_can_fallthru_flag, flow_call_edges_add,\n\tfind_unreachable_blocks, create_edge_list, verify_edge_list,\n\tremove_fake_edges, add_noreturn_fake_exit_edges,\n\tflow_preorder_transversal_compute, flow_dfs_compute_reverse_execute):\n\tLikewise.\n\t* cfgbuild.c (make_edges, find_basic_blocks, find_many_sub_basic_blocks,\n\tfind_sub_basic_blocks): Likewise.\n\t* cfgcleanup.c (try_optimize_cfg, delete_unreachable_blocks):\n\tLikewise.\n\t* cfglayout.c (record_effective_endpoints, cleanup_unconditional_jumps):\n\tLikewise.\n\t* cfgloop.c (flow_loops_cfg_dump, flow_loops_find):\n\tLikewise.\n\t* cfgrtl.c (compute_bb_for_insn, tidy_fallthru_edges,\n\tcommit_edge_insertions, commit_edge_insertions_watch_calls,\n\tprint_rtl_with_bb, verify_flow_info, purge_all_dead_edges): Likewise.\n\t* combine.c (combine_instructions, reg_dead_at_p): Likewise.\n\t* conflict.c (conflict_graph_compute): Likewise.\n\t* df.c (df_bitmaps_alloc, df_bitmaps_free, df_alloc, df_analyse_1,\n\tdf_modified_p, df_refs_unlink, df_dump): Likewise.\n\t* dominance.c (calc_dfs_tree, calculate_dominance_info): Likewise.\n\t* final.c (compute_alignments): Likewise.\n\t* flow.c (update_life_info, update_life_info_in_dirty_blocks,\n\tdelete_noop_moves, calculate_global_regs_live, allocate_bb_life_data,\n\tcount_or_remove_death_notes): Likewise.\n\t* gcse.c (oprs_unchanged_p, record_last_reg_set_info,\n\tcompute_hash_table, compute_kill_rd, compute_rd, compute_ae_kill,\n\tclassic_gcse, compute_transp, cprop, compute_pre_data,\n\tcompute_transpout, invalidate_nonnull_info,\n\tdelete_null_pointer_checks_1, delete_null_pointer_checks,\n\tcompute_code_hoist_vbeinout, hoist_code, compute_ld_motion_mems,\n\tcompute_store_table, build_store_vectors, store_motion): Likewise.\n\t* global.c (global_conflicts, mark_elimination): Likewise.\n\t* graph.c (print_rtl_graph_with_bb): Likewise.\n\t* haifa-sched.c (sched_init): Likewise.\n\t* ifcvt.c (if_convert): Likewise.\n\t* lcm.c (compute_antinout_edge, compute_laterin, compute_insert_delete,\n\tcompute_available, compute_nearerout, compute_rev_insert_delete,\n\toptimize_mode_switching): Likewise.\n\t* local-alloc.c (local_alloc, update_equiv_regs): Likewise.\n\t* predict.c (estimate_probability, note_prediction_to_br_prob,\n\tpropagate_freq, counts_to_freqs, expensive_function_p,\n\testimate_bb_frequencies): Likewise.\n\t* profile.c (instrument_edges, get_exec_counts,\n\tcompute_branch_probabilities, compute_checksum, branch_prob,\n\tfind_spanning_tree): Likewise.\n\t* recog.c (split_all_insns, peephole2_optimize): Likewise.\n\t* reg-stack.c (reg_to_stack, convert_regs_entry, convert_regs):\n\tLikewise.\n\t* regclass.c (scan_one_insn, regclass): Likewise.\n\t* regmove.c (mark_flags_life_zones, regmove_optimize,\n\trecord_stack_memrefs): Likewise.\n\t* regrename.c (regrename_optimize, copyprop_hardreg_forward): Likewise.\n\t* reload1.c (reload, reload_combine, fixup_abnormal_edges): Likewise.\n\t* resource.c (find_basic_block): Likewise.\n\t* sched-ebb.c (schedule_ebbs): Likewise.\n\t* sched-rgn.c (is_cfg_nonregular, build_control_flow,\n\tfind_single_block_region, find_rgns, schedule_insns)\n\t* sibcall.c (optimize_sibling_and_tail_recursive_call)\n\t* ssa-ccp.c (optimize_unexecutable_edges,\n\tssa_ccp_df_delete_unreachable_insns): Likewise.\n\t* ssa-dce.c (ssa_eliminate_dead_code): Likewise.\n\t* ssa.c (find_evaluations, compute_dominance_frontiers_1,\n\trename_block, convert_to_ssa, compute_conservative_reg_partition,\n\tcompute_coalesced_reg_partition, rename_equivalent_regs,\n\tconvert_from_ssa): Likewise.\n\t* config/ia64/ia64.c (emit_predicate_relation_info, process_epilogue,\n\tprocess_for_unwind_directive): Likewise.\n\n\t* df.c (FOR_ALL_BBS): Removed.\n\t* gcse.c (struct null_pointer_info): Type of current_block field\n\tchanged.\n\t(struct reg_avail_info): Type of last_bb field changed.\n\t* config/ia64/ia64.c (block_num): Removed.\n\t(need_copy_state): Type changed.\n\t(last_block): New.\n\nFrom-SVN: r53804", "tree": {"sha": "d9ef360c452a150ca3f25a23e593846ce26b64f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9ef360c452a150ca3f25a23e593846ce26b64f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0082a72651ae718c46e4f3510bba4a116148fc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0082a72651ae718c46e4f3510bba4a116148fc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0082a72651ae718c46e4f3510bba4a116148fc7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0082a72651ae718c46e4f3510bba4a116148fc7/comments", "author": null, "committer": null, "parents": [{"sha": "17645b154d8a32a6fad15296e1030d06f5a0456b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17645b154d8a32a6fad15296e1030d06f5a0456b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17645b154d8a32a6fad15296e1030d06f5a0456b"}], "stats": {"total": 2066, "additions": 957, "deletions": 1109}, "files": [{"sha": "054323d1b0d2f393bf755a5506bf5390785b344b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -1,3 +1,87 @@\n+2002-05-23  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* bb-reorder.c (make_reorder_chain, make_reorder_chain_1):\n+\tUse FOR_EACH_BB macros to iterate over basic block chain.\n+\t* cfg.c (clear_edges, clear_bb_flags, dump_flow_info,\n+\talloc_aux_for_blocks, clear_aux_for_blocks, alloc_aux_for_edges):\n+\tLikewise.\n+\t* cfganal.c (set_edge_can_fallthru_flag, flow_call_edges_add,\n+\tfind_unreachable_blocks, create_edge_list, verify_edge_list,\n+\tremove_fake_edges, add_noreturn_fake_exit_edges,\n+\tflow_preorder_transversal_compute, flow_dfs_compute_reverse_execute):\n+\tLikewise.\n+\t* cfgbuild.c (make_edges, find_basic_blocks, find_many_sub_basic_blocks,\n+\tfind_sub_basic_blocks): Likewise.\n+\t* cfgcleanup.c (try_optimize_cfg, delete_unreachable_blocks):\n+\tLikewise.\n+\t* cfglayout.c (record_effective_endpoints, cleanup_unconditional_jumps):\n+\tLikewise.\n+\t* cfgloop.c (flow_loops_cfg_dump, flow_loops_find):\n+\tLikewise.\n+\t* cfgrtl.c (compute_bb_for_insn, tidy_fallthru_edges,\n+\tcommit_edge_insertions, commit_edge_insertions_watch_calls,\n+\tprint_rtl_with_bb, verify_flow_info, purge_all_dead_edges): Likewise.\n+\t* combine.c (combine_instructions, reg_dead_at_p): Likewise.\n+\t* conflict.c (conflict_graph_compute): Likewise.\n+\t* df.c (df_bitmaps_alloc, df_bitmaps_free, df_alloc, df_analyse_1,\n+\tdf_modified_p, df_refs_unlink, df_dump): Likewise.\n+\t* dominance.c (calc_dfs_tree, calculate_dominance_info): Likewise.\n+\t* final.c (compute_alignments): Likewise.\n+\t* flow.c (update_life_info, update_life_info_in_dirty_blocks,\n+\tdelete_noop_moves, calculate_global_regs_live, allocate_bb_life_data,\n+\tcount_or_remove_death_notes): Likewise.\n+\t* gcse.c (oprs_unchanged_p, record_last_reg_set_info,\n+\tcompute_hash_table, compute_kill_rd, compute_rd, compute_ae_kill,\n+\tclassic_gcse, compute_transp, cprop, compute_pre_data,\n+\tcompute_transpout, invalidate_nonnull_info,\n+\tdelete_null_pointer_checks_1, delete_null_pointer_checks,\n+\tcompute_code_hoist_vbeinout, hoist_code, compute_ld_motion_mems,\n+\tcompute_store_table, build_store_vectors, store_motion): Likewise.\n+\t* global.c (global_conflicts, mark_elimination): Likewise.\n+\t* graph.c (print_rtl_graph_with_bb): Likewise.\n+\t* haifa-sched.c (sched_init): Likewise.\n+\t* ifcvt.c (if_convert): Likewise.\n+\t* lcm.c (compute_antinout_edge, compute_laterin, compute_insert_delete,\n+\tcompute_available, compute_nearerout, compute_rev_insert_delete,\n+\toptimize_mode_switching): Likewise.\n+\t* local-alloc.c (local_alloc, update_equiv_regs): Likewise.\n+\t* predict.c (estimate_probability, note_prediction_to_br_prob,\n+\tpropagate_freq, counts_to_freqs, expensive_function_p,\n+\testimate_bb_frequencies): Likewise.\n+\t* profile.c (instrument_edges, get_exec_counts,\n+\tcompute_branch_probabilities, compute_checksum, branch_prob,\n+\tfind_spanning_tree): Likewise.\n+\t* recog.c (split_all_insns, peephole2_optimize): Likewise.\n+\t* reg-stack.c (reg_to_stack, convert_regs_entry, convert_regs):\n+\tLikewise.\n+\t* regclass.c (scan_one_insn, regclass): Likewise.\n+\t* regmove.c (mark_flags_life_zones, regmove_optimize,\n+\trecord_stack_memrefs): Likewise.\n+\t* regrename.c (regrename_optimize, copyprop_hardreg_forward): Likewise.\n+\t* reload1.c (reload, reload_combine, fixup_abnormal_edges): Likewise.\n+\t* resource.c (find_basic_block): Likewise.\n+\t* sched-ebb.c (schedule_ebbs): Likewise.\n+\t* sched-rgn.c (is_cfg_nonregular, build_control_flow,\n+\tfind_single_block_region, find_rgns, schedule_insns)\n+\t* sibcall.c (optimize_sibling_and_tail_recursive_call)\n+\t* ssa-ccp.c (optimize_unexecutable_edges,\n+\tssa_ccp_df_delete_unreachable_insns): Likewise.\n+\t* ssa-dce.c (ssa_eliminate_dead_code): Likewise.\n+\t* ssa.c (find_evaluations, compute_dominance_frontiers_1,\n+\trename_block, convert_to_ssa, compute_conservative_reg_partition,\n+\tcompute_coalesced_reg_partition, rename_equivalent_regs,\n+\tconvert_from_ssa): Likewise.\n+\t* config/ia64/ia64.c (emit_predicate_relation_info, process_epilogue,\n+\tprocess_for_unwind_directive): Likewise.\n+\n+\t* df.c (FOR_ALL_BBS): Removed.\n+\t* gcse.c (struct null_pointer_info): Type of current_block field\n+\tchanged.\n+\t(struct reg_avail_info): Type of last_bb field changed.\n+\t* config/ia64/ia64.c (block_num): Removed.\n+\t(need_copy_state): Type changed.\n+\t(last_block): New.\n+\n 2002-05-23  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* cppinit.c (mark_named_operators): Split out from init_builtins."}, {"sha": "8ad50e1babffed2724216a80ed4bbae82b3bd2ad", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -102,14 +102,11 @@ static void\n make_reorder_chain ()\n {\n   basic_block prev = NULL;\n-  int nbb_m1 = n_basic_blocks - 1;\n-  basic_block next;\n+  basic_block next, bb;\n \n   /* Loop until we've placed every block.  */\n   do\n     {\n-      int i;\n-\n       next = NULL;\n \n       /* Find the next unplaced block.  */\n@@ -119,12 +116,13 @@ make_reorder_chain ()\n \t remove from the list as we place.  The head of that list is\n \t what we're looking for here.  */\n \n-      for (i = 0; i <= nbb_m1 && !next; ++i)\n-\t{\n-\t  basic_block bb = BASIC_BLOCK (i);\n-\t  if (! RBI (bb)->visited)\n+      FOR_EACH_BB (bb)\n+\tif (! RBI (bb)->visited)\n+\t  {\n \t    next = bb;\n-\t}\n+\t    break;\n+\t  }\n+      \n       if (next)\n         prev = make_reorder_chain_1 (next, prev);\n     }\n@@ -164,7 +162,7 @@ make_reorder_chain_1 (bb, prev)\n     }\n   else\n     {\n-      if (bb->index != 0)\n+      if (bb->prev_bb != ENTRY_BLOCK_PTR)\n \tabort ();\n     }\n   RBI (bb)->visited = 1;"}, {"sha": "d6c9f0d6ee786726c3196274630c039a31aca6e4", "filename": "gcc/cfg.c", "status": "modified", "additions": 20, "deletions": 40, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -167,12 +167,11 @@ free_edge (e)\n void\n clear_edges ()\n {\n-  int i;\n+  basic_block bb;\n   edge e;\n \n-  for (i = 0; i < n_basic_blocks; ++i)\n+  FOR_EACH_BB (bb)\n     {\n-      basic_block bb = BASIC_BLOCK (i);\n       edge e = bb->succ;\n \n       while (e)\n@@ -480,18 +479,18 @@ redirect_edge_pred (e, new_pred)\n void\n clear_bb_flags ()\n {\n-  int i;\n-  ENTRY_BLOCK_PTR->flags = 0;\n-  EXIT_BLOCK_PTR->flags = 0;\n-  for (i = 0; i < n_basic_blocks; i++)\n-    BASIC_BLOCK (i)->flags = 0;\n+  basic_block bb;\n+\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+    bb->flags = 0;\n }\n \f\n void\n dump_flow_info (file)\n      FILE *file;\n {\n   int i;\n+  basic_block bb;\n   static const char * const reg_class_names[] = REG_CLASS_NAMES;\n \n   fprintf (file, \"%d registers.\\n\", max_regno);\n@@ -539,9 +538,8 @@ dump_flow_info (file)\n       }\n \n   fprintf (file, \"\\n%d basic blocks, %d edges.\\n\", n_basic_blocks, n_edges);\n-  for (i = 0; i < n_basic_blocks; i++)\n+  FOR_EACH_BB (bb)\n     {\n-      basic_block bb = BASIC_BLOCK (i);\n       edge e;\n       int sum;\n       gcov_type lsum;\n@@ -709,13 +707,10 @@ alloc_aux_for_blocks (size)\n   first_block_aux_obj = (char *) obstack_alloc (&block_aux_obstack, 0);\n   if (size)\n     {\n-      int i;\n-\n-      for (i = 0; i < n_basic_blocks; i++)\n-\talloc_aux_for_block (BASIC_BLOCK (i), size);\n+      basic_block bb;\n \n-      alloc_aux_for_block (ENTRY_BLOCK_PTR, size);\n-      alloc_aux_for_block (EXIT_BLOCK_PTR, size);\n+      FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+\talloc_aux_for_block (bb, size);\n     }\n }\n \n@@ -724,13 +719,10 @@ alloc_aux_for_blocks (size)\n void\n clear_aux_for_blocks ()\n {\n-  int i;\n-\n-  for (i = 0; i < n_basic_blocks; i++)\n-    BASIC_BLOCK (i)->aux = NULL;\n+  basic_block bb;\n \n-  ENTRY_BLOCK_PTR->aux = NULL;\n-  EXIT_BLOCK_PTR->aux = NULL;\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+    bb->aux = NULL;\n }\n \n /* Free data allocated in block_aux_obstack and clear AUX pointers\n@@ -784,17 +776,12 @@ alloc_aux_for_edges (size)\n   first_edge_aux_obj = (char *) obstack_alloc (&edge_aux_obstack, 0);\n   if (size)\n     {\n-      int i;\n-      for (i = -1; i < n_basic_blocks; i++)\n+      basic_block bb;\n+\n+      FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n \t{\n-\t  basic_block bb;\n \t  edge e;\n \n-\t  if (i >= 0)\n-\t    bb = BASIC_BLOCK (i);\n-\t  else\n-\t    bb = ENTRY_BLOCK_PTR;\n-\n \t  for (e = bb->succ; e; e = e->succ_next)\n \t    alloc_aux_for_edge (e, size);\n \t}\n@@ -806,18 +793,11 @@ alloc_aux_for_edges (size)\n void\n clear_aux_for_edges ()\n {\n-  int i;\n+  basic_block bb;\n+  edge e;\n \n-  for (i = -1; i < n_basic_blocks; i++)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n     {\n-      basic_block bb;\n-      edge e;\n-\n-      if (i >= 0)\n-\tbb = BASIC_BLOCK (i);\n-      else\n-\tbb = ENTRY_BLOCK_PTR;\n-\n       for (e = bb->succ; e; e = e->succ_next)\n \te->aux = NULL;\n     }"}, {"sha": "71f54619763891f2c8bfd294315286b1c548a9f3", "filename": "gcc/cfganal.c", "status": "modified", "additions": 40, "deletions": 143, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -194,10 +194,10 @@ mark_dfs_back_edges ()\n void\n set_edge_can_fallthru_flag ()\n {\n-  int i;\n-  for (i = 0; i < n_basic_blocks; i++)\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n     {\n-      basic_block bb = BASIC_BLOCK (i);\n       edge e;\n \n       /* The FALLTHRU edge is also CAN_FALLTHRU edge.  */\n@@ -259,7 +259,7 @@ flow_call_edges_add (blocks)\n   int i;\n   int blocks_split = 0;\n   int bb_num = 0;\n-  basic_block *bbs;\n+  basic_block *bbs, bb;\n   bool check_last_block = false;\n \n   /* Map bb indices into basic block pointers since split_block\n@@ -269,8 +269,8 @@ flow_call_edges_add (blocks)\n \n   if (! blocks)\n     {\n-      for (i = 0; i < n_basic_blocks; i++)\n-\tbbs[bb_num++] = BASIC_BLOCK (i);\n+      FOR_EACH_BB (bb)\n+\tbbs[bb_num++] = bb;\n \n       check_last_block = true;\n     }\n@@ -386,16 +386,15 @@ void\n find_unreachable_blocks ()\n {\n   edge e;\n-  int i, n;\n-  basic_block *tos, *worklist;\n+  basic_block *tos, *worklist, bb;\n \n-  n = n_basic_blocks;\n-  tos = worklist = (basic_block *) xmalloc (sizeof (basic_block) * n);\n+  tos = worklist =\n+\t(basic_block *) xmalloc (sizeof (basic_block) * n_basic_blocks);\n \n   /* Clear all the reachability flags.  */\n \n-  for (i = 0; i < n; ++i)\n-    BASIC_BLOCK (i)->flags &= ~BB_REACHABLE;\n+  FOR_EACH_BB (bb)\n+    bb->flags &= ~BB_REACHABLE;\n \n   /* Add our starting points to the worklist.  Almost always there will\n      be only one.  It isn't inconceivable that we might one day directly\n@@ -445,46 +444,32 @@ create_edge_list ()\n   struct edge_list *elist;\n   edge e;\n   int num_edges;\n-  int x;\n   int block_count;\n+  basic_block bb;\n \n   block_count = n_basic_blocks + 2;   /* Include the entry and exit blocks.  */\n \n   num_edges = 0;\n \n   /* Determine the number of edges in the flow graph by counting successor\n      edges on each basic block.  */\n-  for (x = 0; x < n_basic_blocks; x++)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n     {\n-      basic_block bb = BASIC_BLOCK (x);\n-\n       for (e = bb->succ; e; e = e->succ_next)\n \tnum_edges++;\n     }\n \n-  /* Don't forget successors of the entry block.  */\n-  for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n-    num_edges++;\n-\n   elist = (struct edge_list *) xmalloc (sizeof (struct edge_list));\n   elist->num_blocks = block_count;\n   elist->num_edges = num_edges;\n   elist->index_to_edge = (edge *) xmalloc (sizeof (edge) * num_edges);\n \n   num_edges = 0;\n \n-  /* Follow successors of the entry block, and register these edges.  */\n-  for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n-    elist->index_to_edge[num_edges++] = e;\n-\n-  for (x = 0; x < n_basic_blocks; x++)\n-    {\n-      basic_block bb = BASIC_BLOCK (x);\n-\n-      /* Follow all successors of blocks, and register these edges.  */\n-      for (e = bb->succ; e; e = e->succ_next)\n-\telist->index_to_edge[num_edges++] = e;\n-    }\n+  /* Follow successors of blocks, and register these edges.  */\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n+    for (e = bb->succ; e; e = e->succ_next)\n+      elist->index_to_edge[num_edges++] = e;\n \n   return elist;\n }\n@@ -538,13 +523,12 @@ verify_edge_list (f, elist)\n      FILE *f;\n      struct edge_list *elist;\n {\n-  int x, pred, succ, index;\n+  int pred, succ, index;\n   edge e;\n+  basic_block bb, p, s;\n \n-  for (x = 0; x < n_basic_blocks; x++)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n     {\n-      basic_block bb = BASIC_BLOCK (x);\n-\n       for (e = bb->succ; e; e = e->succ_next)\n \t{\n \t  pred = e->src->index;\n@@ -565,33 +549,12 @@ verify_edge_list (f, elist)\n \t}\n     }\n \n-  for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n-    {\n-      pred = e->src->index;\n-      succ = e->dest->index;\n-      index = EDGE_INDEX (elist, e->src, e->dest);\n-      if (index == EDGE_INDEX_NO_EDGE)\n-\t{\n-\t  fprintf (f, \"*p* No index for edge from %d to %d\\n\", pred, succ);\n-\t  continue;\n-\t}\n-\n-      if (INDEX_EDGE_PRED_BB (elist, index)->index != pred)\n-\tfprintf (f, \"*p* Pred for index %d should be %d not %d\\n\",\n-\t\t index, pred, INDEX_EDGE_PRED_BB (elist, index)->index);\n-      if (INDEX_EDGE_SUCC_BB (elist, index)->index != succ)\n-\tfprintf (f, \"*p* Succ for index %d should be %d not %d\\n\",\n-\t\t index, succ, INDEX_EDGE_SUCC_BB (elist, index)->index);\n-    }\n-\n-  /* We've verified that all the edges are in the list, no lets make sure\n+  /* We've verified that all the edges are in the list, now lets make sure\n      there are no spurious edges in the list.  */\n \n-  for (pred = 0; pred < n_basic_blocks; pred++)\n-    for (succ = 0; succ < n_basic_blocks; succ++)\n+  FOR_BB_BETWEEN (p, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n+    FOR_BB_BETWEEN (s, ENTRY_BLOCK_PTR->next_bb, NULL, next_bb)\n       {\n-\tbasic_block p = BASIC_BLOCK (pred);\n-\tbasic_block s = BASIC_BLOCK (succ);\n \tint found_edge = 0;\n \n \tfor (e = p->succ; e; e = e->succ_next)\n@@ -608,78 +571,15 @@ verify_edge_list (f, elist)\n \t      break;\n \t    }\n \n-\tif (EDGE_INDEX (elist, BASIC_BLOCK (pred), BASIC_BLOCK (succ))\n+\tif (EDGE_INDEX (elist, p, s)\n \t    == EDGE_INDEX_NO_EDGE && found_edge != 0)\n \t  fprintf (f, \"*** Edge (%d, %d) appears to not have an index\\n\",\n-\t\t   pred, succ);\n-\tif (EDGE_INDEX (elist, BASIC_BLOCK (pred), BASIC_BLOCK (succ))\n+\t\t   p->index, s->index);\n+\tif (EDGE_INDEX (elist, p, s)\n \t    != EDGE_INDEX_NO_EDGE && found_edge == 0)\n \t  fprintf (f, \"*** Edge (%d, %d) has index %d, but there is no edge\\n\",\n-\t\t   pred, succ, EDGE_INDEX (elist, BASIC_BLOCK (pred),\n-\t\t\t\t\t   BASIC_BLOCK (succ)));\n+\t\t   p->index, s->index, EDGE_INDEX (elist, p, s));\n       }\n-\n-  for (succ = 0; succ < n_basic_blocks; succ++)\n-    {\n-      basic_block p = ENTRY_BLOCK_PTR;\n-      basic_block s = BASIC_BLOCK (succ);\n-      int found_edge = 0;\n-\n-      for (e = p->succ; e; e = e->succ_next)\n-\tif (e->dest == s)\n-\t  {\n-\t    found_edge = 1;\n-\t    break;\n-\t  }\n-\n-      for (e = s->pred; e; e = e->pred_next)\n-\tif (e->src == p)\n-\t  {\n-\t    found_edge = 1;\n-\t    break;\n-\t  }\n-\n-      if (EDGE_INDEX (elist, ENTRY_BLOCK_PTR, BASIC_BLOCK (succ))\n-\t  == EDGE_INDEX_NO_EDGE && found_edge != 0)\n-\tfprintf (f, \"*** Edge (entry, %d) appears to not have an index\\n\",\n-\t\t succ);\n-      if (EDGE_INDEX (elist, ENTRY_BLOCK_PTR, BASIC_BLOCK (succ))\n-\t  != EDGE_INDEX_NO_EDGE && found_edge == 0)\n-\tfprintf (f, \"*** Edge (entry, %d) has index %d, but no edge exists\\n\",\n-\t\t succ, EDGE_INDEX (elist, ENTRY_BLOCK_PTR,\n-\t\t\t\t   BASIC_BLOCK (succ)));\n-    }\n-\n-  for (pred = 0; pred < n_basic_blocks; pred++)\n-    {\n-      basic_block p = BASIC_BLOCK (pred);\n-      basic_block s = EXIT_BLOCK_PTR;\n-      int found_edge = 0;\n-\n-      for (e = p->succ; e; e = e->succ_next)\n-\tif (e->dest == s)\n-\t  {\n-\t    found_edge = 1;\n-\t    break;\n-\t  }\n-\n-      for (e = s->pred; e; e = e->pred_next)\n-\tif (e->src == p)\n-\t  {\n-\t    found_edge = 1;\n-\t    break;\n-\t  }\n-\n-      if (EDGE_INDEX (elist, BASIC_BLOCK (pred), EXIT_BLOCK_PTR)\n-\t  == EDGE_INDEX_NO_EDGE && found_edge != 0)\n-\tfprintf (f, \"*** Edge (%d, exit) appears to not have an index\\n\",\n-\t\t pred);\n-      if (EDGE_INDEX (elist, BASIC_BLOCK (pred), EXIT_BLOCK_PTR)\n-\t  != EDGE_INDEX_NO_EDGE && found_edge == 0)\n-\tfprintf (f, \"*** Edge (%d, exit) has index %d, but no edge exists\\n\",\n-\t\t pred, EDGE_INDEX (elist, BASIC_BLOCK (pred),\n-\t\t\t\t   EXIT_BLOCK_PTR));\n-    }\n }\n \n /* This routine will determine what, if any, edge there is between\n@@ -768,13 +668,10 @@ remove_fake_successors (bb)\n void\n remove_fake_edges ()\n {\n-  int x;\n-\n-  for (x = 0; x < n_basic_blocks; x++)\n-    remove_fake_successors (BASIC_BLOCK (x));\n+  basic_block bb;\n \n-  /* We've handled all successors except the entry block's.  */\n-  remove_fake_successors (ENTRY_BLOCK_PTR);\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n+    remove_fake_successors (bb);\n }\n \n /* This function will add a fake edge between any block which has no\n@@ -784,11 +681,11 @@ remove_fake_edges ()\n void\n add_noreturn_fake_exit_edges ()\n {\n-  int x;\n+  basic_block bb;\n \n-  for (x = 0; x < n_basic_blocks; x++)\n-    if (BASIC_BLOCK (x)->succ == NULL)\n-      make_single_succ_edge (BASIC_BLOCK (x), EXIT_BLOCK_PTR, EDGE_FAKE);\n+  FOR_EACH_BB (bb)\n+    if (bb->succ == NULL)\n+      make_single_succ_edge (bb, EXIT_BLOCK_PTR, EDGE_FAKE);\n }\n \n /* This function adds a fake edge between any infinite loops to the\n@@ -1014,6 +911,7 @@ flow_preorder_transversal_compute (pot_order)\n   sbitmap visited;\n   struct dfst_node *node;\n   struct dfst_node *dfst;\n+  basic_block bb;\n \n   /* Allocate stack for back-tracking up CFG.  */\n   stack = (edge *) xmalloc ((n_basic_blocks + 1) * sizeof (edge));\n@@ -1023,10 +921,10 @@ flow_preorder_transversal_compute (pot_order)\n   dfst = (struct dfst_node *) xcalloc (n_basic_blocks,\n \t\t\t\t       sizeof (struct dfst_node));\n \n-  for (i = 0; i < n_basic_blocks; i++)\n+  FOR_EACH_BB (bb)\n     {\n       max_successors = 0;\n-      for (e = BASIC_BLOCK (i)->succ; e; e = e->succ_next)\n+      for (e = bb->succ; e; e = e->succ_next)\n \tmax_successors++;\n \n       dfst[i].node\n@@ -1183,7 +1081,6 @@ flow_dfs_compute_reverse_execute (data)\n {\n   basic_block bb;\n   edge e;\n-  int i;\n \n   while (data->sp > 0)\n     {\n@@ -1197,9 +1094,9 @@ flow_dfs_compute_reverse_execute (data)\n     }\n \n   /* Determine if there are unvisited basic blocks.  */\n-  for (i = n_basic_blocks - (INVALID_BLOCK + 1); --i >= 0; )\n-    if (!TEST_BIT (data->visited_blocks, i))\n-      return BASIC_BLOCK (i + (INVALID_BLOCK + 1));\n+  FOR_BB_BETWEEN (bb, EXIT_BLOCK_PTR, NULL, prev_bb)\n+    if (!TEST_BIT (data->visited_blocks, bb->index - (INVALID_BLOCK + 1)))\n+      return bb;\n \n   return NULL;\n }"}, {"sha": "305c09fc94fa2e8383359ff799e6154c01931fb6", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 42, "deletions": 46, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -284,7 +284,7 @@ make_edges (label_value_list, min, max, update_p)\n      basic_block min, max;\n      int update_p;\n {\n-  int i;\n+  basic_block bb;\n   sbitmap *edge_cache = NULL;\n \n   /* Assume no computed jump; revise as we create edges.  */\n@@ -299,24 +299,24 @@ make_edges (label_value_list, min, max, update_p)\n       sbitmap_vector_zero (edge_cache, n_basic_blocks);\n \n       if (update_p)\n-\tfor (i = min->index; i <= max->index; ++i)\n+        FOR_BB_BETWEEN (bb, min, max->next_bb, next_bb)\n \t  {\n \t    edge e;\n \n-\t    for (e = BASIC_BLOCK (i)->succ; e ; e = e->succ_next)\n+\t    for (e = bb->succ; e ; e = e->succ_next)\n \t      if (e->dest != EXIT_BLOCK_PTR)\n-\t\tSET_BIT (edge_cache[i], e->dest->index);\n+\t\tSET_BIT (edge_cache[bb->index], e->dest->index);\n \t  }\n     }\n \n-  /* By nature of the way these get numbered, block 0 is always the entry.  */\n+  /* By nature of the way these get numbered, ENTRY_BLOCK_PTR->next_bb block\n+     is always the entry.  */\n   if (min == ENTRY_BLOCK_PTR->next_bb)\n     cached_make_edge (edge_cache, ENTRY_BLOCK_PTR, min,\n \t\t      EDGE_FALLTHRU);\n \n-  for (i = min->index; i <= max->index; ++i)\n+  FOR_BB_BETWEEN (bb, min, max->next_bb, next_bb)\n     {\n-      basic_block bb = BASIC_BLOCK (i);\n       rtx insn, x;\n       enum rtx_code code;\n       int force_fallthru = 0;\n@@ -614,22 +614,22 @@ find_basic_blocks (f, nregs, file)\n      FILE *file ATTRIBUTE_UNUSED;\n {\n   int max_uid;\n+  basic_block bb;\n+\n   timevar_push (TV_CFG);\n \n   basic_block_for_insn = 0;\n \n   /* Flush out existing data.  */\n   if (basic_block_info != NULL)\n     {\n-      int i;\n-\n       clear_edges ();\n \n       /* Clear bb->aux on all extant basic blocks.  We'll use this as a\n \t tag for reuse during create_basic_block, just in case some pass\n \t copies around basic block notes improperly.  */\n-      for (i = 0; i < n_basic_blocks; ++i)\n-\tBASIC_BLOCK (i)->aux = NULL;\n+      FOR_EACH_BB (bb)\n+ \tbb->aux = NULL;\n \n       VARRAY_FREE (basic_block_info);\n     }\n@@ -794,55 +794,53 @@ void\n find_many_sub_basic_blocks (blocks)\n      sbitmap blocks;\n {\n-  int i;\n-  int min, max;\n+  basic_block bb, min, max;\n \n-  for (i = 0; i < n_basic_blocks; i++)\n-    SET_STATE (BASIC_BLOCK (i),\n-\t       TEST_BIT (blocks, i) ? BLOCK_TO_SPLIT : BLOCK_ORIGINAL);\n+  FOR_EACH_BB (bb)\n+    SET_STATE (bb,\n+\t       TEST_BIT (blocks, bb->index) ? BLOCK_TO_SPLIT : BLOCK_ORIGINAL);\n \n-  for (i = 0; i < n_basic_blocks; i++)\n-    if (STATE (BASIC_BLOCK (i)) == BLOCK_TO_SPLIT)\n-      find_bb_boundaries (BASIC_BLOCK (i));\n+  FOR_EACH_BB (bb)\n+    if (STATE (bb) == BLOCK_TO_SPLIT)\n+      find_bb_boundaries (bb);\n \n-  for (i = 0; i < n_basic_blocks; i++)\n-    if (STATE (BASIC_BLOCK (i)) != BLOCK_ORIGINAL)\n+  FOR_EACH_BB (bb)\n+    if (STATE (bb) != BLOCK_ORIGINAL)\n       break;\n \n-  min = max = i;\n-  for (; i < n_basic_blocks; i++)\n-    if (STATE (BASIC_BLOCK (i)) != BLOCK_ORIGINAL)\n-      max = i;\n+  min = max = bb;\n+  for (; bb != EXIT_BLOCK_PTR; bb = bb->next_bb)\n+    if (STATE (bb) != BLOCK_ORIGINAL)\n+      max = bb;\n \n   /* Now re-scan and wire in all edges.  This expect simple (conditional)\n      jumps at the end of each new basic blocks.  */\n-  make_edges (NULL, BASIC_BLOCK (min), BASIC_BLOCK (max), 1);\n+  make_edges (NULL, min, max, 1);\n \n   /* Update branch probabilities.  Expect only (un)conditional jumps\n      to be created with only the forward edges.  */\n-  for (i = min; i <= max; i++)\n+  FOR_BB_BETWEEN (bb, min, max->next_bb, next_bb)\n     {\n       edge e;\n-      basic_block b = BASIC_BLOCK (i);\n \n-      if (STATE (b) == BLOCK_ORIGINAL)\n+      if (STATE (bb) == BLOCK_ORIGINAL)\n \tcontinue;\n-      if (STATE (b) == BLOCK_NEW)\n+      if (STATE (bb) == BLOCK_NEW)\n \t{\n-\t  b->count = 0;\n-\t  b->frequency = 0;\n-\t  for (e = b->pred; e; e=e->pred_next)\n+\t  bb->count = 0;\n+\t  bb->frequency = 0;\n+\t  for (e = bb->pred; e; e=e->pred_next)\n \t    {\n-\t      b->count += e->count;\n-\t      b->frequency += EDGE_FREQUENCY (e);\n+\t      bb->count += e->count;\n+\t      bb->frequency += EDGE_FREQUENCY (e);\n \t    }\n \t}\n \n-      compute_outgoing_frequencies (b);\n+      compute_outgoing_frequencies (bb);\n     }\n \n-  for (i = 0; i < n_basic_blocks; i++)\n-    SET_STATE (BASIC_BLOCK (i), 0);\n+  FOR_EACH_BB (bb)\n+    SET_STATE (bb, 0);\n }\n \n /* Like above but for single basic block only.  */\n@@ -851,26 +849,24 @@ void\n find_sub_basic_blocks (bb)\n      basic_block bb;\n {\n-  int i;\n-  int min, max;\n+  basic_block min, max, b;\n   basic_block next = bb->next_bb;\n \n-  min = bb->index;\n+  min = bb;\n   find_bb_boundaries (bb);\n-  max = next->prev_bb->index;\n+  max = next->prev_bb;\n \n   /* Now re-scan and wire in all edges.  This expect simple (conditional)\n      jumps at the end of each new basic blocks.  */\n-  make_edges (NULL, BASIC_BLOCK (min), BASIC_BLOCK (max), 1);\n+  make_edges (NULL, min, max, 1);\n \n   /* Update branch probabilities.  Expect only (un)conditional jumps\n      to be created with only the forward edges.  */\n-  for (i = min; i <= max; i++)\n+  FOR_BB_BETWEEN (b, min, max->next_bb, next_bb)\n     {\n       edge e;\n-      basic_block b = BASIC_BLOCK (i);\n \n-      if (i != min)\n+      if (b != min)\n \t{\n \t  b->count = 0;\n \t  b->frequency = 0;"}, {"sha": "a2ff17d6981904639d2782f7ce7095fecafdd839", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -1577,16 +1577,16 @@ static bool\n try_optimize_cfg (mode)\n      int mode;\n {\n-  int i;\n   bool changed_overall = false;\n   bool changed;\n   int iterations = 0;\n+  basic_block bb, b;\n \n   if (mode & CLEANUP_CROSSJUMP)\n     add_noreturn_fake_exit_edges ();\n \n-  for (i = 0; i < n_basic_blocks; i++)\n-    update_forwarder_flag (BASIC_BLOCK (i));\n+  FOR_EACH_BB (bb)\n+    update_forwarder_flag (bb);\n \n   if (mode & CLEANUP_UPDATE_LIFE)\n     clear_bb_flags ();\n@@ -1606,9 +1606,9 @@ try_optimize_cfg (mode)\n \t\t     \"\\n\\ntry_optimize_cfg iteration %i\\n\\n\",\n \t\t     iterations);\n \n-\t  for (i = 0; i < n_basic_blocks;)\n+\t  for (b = ENTRY_BLOCK_PTR->next_bb; b != EXIT_BLOCK_PTR;)\n \t    {\n-\t      basic_block c, b = BASIC_BLOCK (i);\n+\t      basic_block c;\n \t      edge s;\n \t      bool changed_here = false;\n \n@@ -1721,7 +1721,7 @@ try_optimize_cfg (mode)\n \t      /* Don't get confused by the index shift caused by\n \t\t deleting blocks.  */\n \t      if (!changed_here)\n-\t\ti = b->index + 1;\n+\t\tb = b->next_bb;\n \t      else\n \t\tchanged = true;\n \t    }\n@@ -1753,18 +1753,19 @@ try_optimize_cfg (mode)\n bool\n delete_unreachable_blocks ()\n {\n-  int i, j;\n   bool changed = false;\n+  basic_block b, next_bb;\n+  int j = 0;\n \n   find_unreachable_blocks ();\n \n   /* Delete all unreachable basic blocks.  Do compaction concurrently,\n      as otherwise we can wind up with O(N^2) behaviour here when we\n      have oodles of dead code.  */\n \n-  for (i = j = 0; i < n_basic_blocks; ++i)\n+  for (b = ENTRY_BLOCK_PTR->next_bb; b != EXIT_BLOCK_PTR; b = next_bb)\n     {\n-      basic_block b = BASIC_BLOCK (i);\n+      next_bb = b->next_bb;\n \n       if (!(b->flags & BB_REACHABLE))\n \t{"}, {"sha": "494fa7c96eb8334f2ab48f60ecb29a1b46809b30", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -191,11 +191,10 @@ static void\n record_effective_endpoints ()\n {\n   rtx next_insn = get_insns ();\n-  int i;\n+  basic_block bb;\n \n-  for (i = 0; i < n_basic_blocks; i++)\n+  FOR_EACH_BB (bb)\n     {\n-      basic_block bb = BASIC_BLOCK (i);\n       rtx end;\n \n       if (PREV_INSN (bb->head) && next_insn != bb->head)\n@@ -597,24 +596,22 @@ verify_insn_chain ()\n static void\n cleanup_unconditional_jumps ()\n {\n-  int i;\n-  for (i = 0; i < n_basic_blocks; i++)\n-    {\n-      basic_block bb = BASIC_BLOCK (i);\n+  basic_block bb;\n \n+  FOR_EACH_BB (bb)\n+    {\n       if (!bb->succ)\n \tcontinue;\n       if (bb->succ->flags & EDGE_FALLTHRU)\n \tcontinue;\n       if (!bb->succ->succ_next)\n \t{\n \t  rtx insn;\n-\t  if (GET_CODE (bb->head) != CODE_LABEL && forwarder_block_p (bb) && i)\n+\t  if (GET_CODE (bb->head) != CODE_LABEL && forwarder_block_p (bb)\n+\t      && bb->prev_bb != ENTRY_BLOCK_PTR)\n \t    {\n \t      basic_block prev = bb->prev_bb;\n \n-\t      i--;\n-\n \t      if (rtl_dump_file)\n \t\tfprintf (rtl_dump_file, \"Removing forwarder BB %i\\n\",\n \t\t\t bb->index);"}, {"sha": "f480d9a15d6131aaf27a4ca81df0cab98dc33900", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -50,16 +50,17 @@ flow_loops_cfg_dump (loops, file)\n      FILE *file;\n {\n   int i;\n+  basic_block bb;\n \n   if (! loops->num || ! file || ! loops->cfg.dom)\n     return;\n \n-  for (i = 0; i < n_basic_blocks; i++)\n+  FOR_EACH_BB (bb)\n     {\n       edge succ;\n \n-      fprintf (file, \";; %d succs { \", i);\n-      for (succ = BASIC_BLOCK (i)->succ; succ; succ = succ->succ_next)\n+      fprintf (file, \";; %d succs { \", bb->index);\n+      for (succ = bb->succ; succ; succ = succ->succ_next)\n \tfprintf (file, \"%d \", succ->dest->index);\n       flow_nodes_print (\"} dom\", loops->cfg.dom[i], file);\n     }\n@@ -643,6 +644,7 @@ flow_loops_find (loops, flags)\n   sbitmap *dom;\n   int *dfs_order;\n   int *rc_order;\n+  basic_block header;\n \n   /* This function cannot be repeatedly called with different\n      flags to build up the loop information.  The loop tree\n@@ -667,11 +669,8 @@ flow_loops_find (loops, flags)\n   /* Count the number of loop edges (back edges).  This should be the\n      same as the number of natural loops.  */\n   num_loops = 0;\n-  for (b = 0; b < n_basic_blocks; b++)\n+  FOR_EACH_BB (header)\n     {\n-      basic_block header;\n-\n-      header = BASIC_BLOCK (b);\n       header->loop_depth = 0;\n \n       for (e = header->pred; e; e = e->pred_next)\n@@ -684,10 +683,7 @@ flow_loops_find (loops, flags)\n \t     loop.  It also has single back edge to the header\n \t     from a latch node.  Note that multiple natural loops\n \t     may share the same header.  */\n-\t  if (b != header->index)\n-\t    abort ();\n-\n-\t  if (latch != ENTRY_BLOCK_PTR && TEST_BIT (dom[latch->index], b))\n+\t  if (latch != ENTRY_BLOCK_PTR && TEST_BIT (dom[latch->index], header->index))\n \t    num_loops++;\n \t}\n     }"}, {"sha": "226e301b1b447ff117bc1a0c16aad4b707a75a7a", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 26, "deletions": 39, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -448,16 +448,15 @@ void\n compute_bb_for_insn (max)\n      int max;\n {\n-  int i;\n+  basic_block bb;\n \n   if (basic_block_for_insn)\n     VARRAY_FREE (basic_block_for_insn);\n \n   VARRAY_BB_INIT (basic_block_for_insn, max, \"basic_block_for_insn\");\n \n-  for (i = 0; i < n_basic_blocks; ++i)\n+  FOR_EACH_BB (bb)\n     {\n-      basic_block bb = BASIC_BLOCK (i);\n       rtx end = bb->end;\n       rtx insn;\n \n@@ -1168,14 +1167,17 @@ tidy_fallthru_edge (e, b, c)\n void\n tidy_fallthru_edges ()\n {\n-  int i;\n+  basic_block b, c;\n+\n+  if (ENTRY_BLOCK_PTR->next_bb == EXIT_BLOCK_PTR)\n+    return;\n \n-  for (i = 1; i < n_basic_blocks; i++)\n+  FOR_BB_BETWEEN (b, ENTRY_BLOCK_PTR->next_bb, EXIT_BLOCK_PTR->prev_bb, next_bb)\n     {\n-      basic_block c = BASIC_BLOCK (i);\n-      basic_block b = c->prev_bb;\n       edge s;\n \n+      c = b->next_bb;\n+\n       /* We care about simple conditional or unconditional jumps with\n \t a single successor.\n \n@@ -1476,16 +1478,13 @@ commit_one_edge_insertion (e, watch_calls)\n void\n commit_edge_insertions ()\n {\n-  int i;\n   basic_block bb;\n \n #ifdef ENABLE_CHECKING\n   verify_flow_info ();\n #endif\n \n-  i = -1;\n-  bb = ENTRY_BLOCK_PTR;\n-  while (1)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n     {\n       edge e, next;\n \n@@ -1495,10 +1494,6 @@ commit_edge_insertions ()\n \t  if (e->insns)\n \t    commit_one_edge_insertion (e, false);\n \t}\n-\n-      if (++i >= n_basic_blocks)\n-\tbreak;\n-      bb = BASIC_BLOCK (i);\n     }\n }\n \f\n@@ -1508,16 +1503,13 @@ commit_edge_insertions ()\n void\n commit_edge_insertions_watch_calls ()\n {\n-  int i;\n   basic_block bb;\n \n #ifdef ENABLE_CHECKING\n   verify_flow_info ();\n #endif\n \n-  i = -1;\n-  bb = ENTRY_BLOCK_PTR;\n-  while (1)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n     {\n       edge e, next;\n \n@@ -1527,10 +1519,6 @@ commit_edge_insertions_watch_calls ()\n \t  if (e->insns)\n \t    commit_one_edge_insertion (e, true);\n \t}\n-\n-      if (++i >= n_basic_blocks)\n-\tbreak;\n-      bb = BASIC_BLOCK (i);\n     }\n }\n \f\n@@ -1601,7 +1589,6 @@ print_rtl_with_bb (outf, rtx_first)\n     fprintf (outf, \"(nil)\\n\");\n   else\n     {\n-      int i;\n       enum bb_state { NOT_IN_BB, IN_ONE_BB, IN_MULTIPLE_BB };\n       int max_uid = get_max_uid ();\n       basic_block *start\n@@ -1611,9 +1598,10 @@ print_rtl_with_bb (outf, rtx_first)\n       enum bb_state *in_bb_p\n \t= (enum bb_state *) xcalloc (max_uid, sizeof (enum bb_state));\n \n-      for (i = n_basic_blocks - 1; i >= 0; i--)\n+      basic_block bb;\n+\n+      FOR_EACH_BB_REVERSE (bb)\n \t{\n-\t  basic_block bb = BASIC_BLOCK (i);\n \t  rtx x;\n \n \t  start[INSN_UID (bb->head)] = bb;\n@@ -1634,7 +1622,6 @@ print_rtl_with_bb (outf, rtx_first)\n       for (tmp_rtx = rtx_first; NULL != tmp_rtx; tmp_rtx = NEXT_INSN (tmp_rtx))\n \t{\n \t  int did_output;\n-\t  basic_block bb;\n \n \t  if ((bb = start[INSN_UID (tmp_rtx)]) != NULL)\n \t    {\n@@ -1721,7 +1708,7 @@ verify_flow_info ()\n   basic_block *bb_info, *last_visited;\n   size_t *edge_checksum;\n   rtx x;\n-  int i, last_bb_num_seen, num_bb_notes, err = 0;\n+  int i, num_bb_notes, err = 0;\n   basic_block bb, last_bb_seen;\n \n   bb_info = (basic_block *) xcalloc (max_uid, sizeof (basic_block));\n@@ -1765,9 +1752,8 @@ verify_flow_info ()\n       last_bb_seen = bb;\n     }\n \n-  for (i = n_basic_blocks - 1; i >= 0; i--)\n+  FOR_EACH_BB_REVERSE (bb)\n     {\n-      basic_block bb = BASIC_BLOCK (i);\n       rtx head = bb->head;\n       rtx end = bb->end;\n \n@@ -1813,9 +1799,8 @@ verify_flow_info ()\n     }\n \n   /* Now check the basic blocks (boundaries etc.) */\n-  for (i = n_basic_blocks - 1; i >= 0; i--)\n+  FOR_EACH_BB_REVERSE (bb)\n     {\n-      basic_block bb = BASIC_BLOCK (i);\n       int n_fallthru = 0, n_eh = 0, n_call = 0, n_abnormal = 0, n_branch = 0;\n       edge e;\n       rtx note;\n@@ -2087,19 +2072,20 @@ verify_flow_info ()\n \terr = 1;\n       }\n \n-  last_bb_num_seen = -1;\n   num_bb_notes = 0;\n+  last_bb_seen = ENTRY_BLOCK_PTR;\n+\n   for (x = rtx_first; x; x = NEXT_INSN (x))\n     {\n       if (NOTE_INSN_BASIC_BLOCK_P (x))\n \t{\n \t  basic_block bb = NOTE_BASIC_BLOCK (x);\n \n \t  num_bb_notes++;\n-\t  if (bb->index != last_bb_num_seen + 1)\n+\t  if (bb != last_bb_seen->next_bb)\n \t    internal_error (\"basic blocks not numbered consecutively\");\n \n-\t  last_bb_num_seen = bb->index;\n+\t  last_bb_seen = bb;\n \t}\n \n       if (!bb_info[INSN_UID (x)])\n@@ -2325,22 +2311,23 @@ bool\n purge_all_dead_edges (update_life_p)\n      int update_life_p;\n {\n-  int i, purged = false;\n+  int purged = false;\n   sbitmap blocks = 0;\n+  basic_block bb;\n \n   if (update_life_p)\n     {\n       blocks = sbitmap_alloc (n_basic_blocks);\n       sbitmap_zero (blocks);\n     }\n \n-  for (i = 0; i < n_basic_blocks; i++)\n+  FOR_EACH_BB (bb)\n     {\n-      bool purged_here = purge_dead_edges (BASIC_BLOCK (i));\n+      bool purged_here = purge_dead_edges (bb);\n \n       purged |= purged_here;\n       if (purged_here && update_life_p)\n-\tSET_BIT (blocks, i);\n+\tSET_BIT (blocks, bb->index);\n     }\n \n   if (update_life_p && purged)"}, {"sha": "f3cb90f247dc1a326d3a5235eb0a234ab8e5105a", "filename": "gcc/combine.c", "status": "modified", "additions": 112, "deletions": 113, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -610,133 +610,132 @@ combine_instructions (f, nregs)\n \n   /* Now scan all the insns in forward order.  */\n \n-  this_basic_block = ENTRY_BLOCK_PTR;\n   label_tick = 1;\n   last_call_cuid = 0;\n   mem_last_set = 0;\n   init_reg_last_arrays ();\n   setup_incoming_promotions ();\n \n-  for (insn = f; insn; insn = next ? next : NEXT_INSN (insn))\n+  FOR_EACH_BB (this_basic_block)\n     {\n-      next = 0;\n-\n-      /* If INSN starts a new basic block, update our basic block number.  */\n-      if (this_basic_block->next_bb != EXIT_BLOCK_PTR\n-\t  && this_basic_block->next_bb->head == insn)\n-\tthis_basic_block = this_basic_block->next_bb;\n-\n-      if (GET_CODE (insn) == CODE_LABEL)\n-\tlabel_tick++;\n-\n-      else if (INSN_P (insn))\n+      for (insn = this_basic_block->head;\n+           insn != NEXT_INSN (this_basic_block->end);\n+\t   insn = next ? next : NEXT_INSN (insn))\n \t{\n-\t  /* See if we know about function return values before this\n-\t     insn based upon SUBREG flags.  */\n-\t  check_promoted_subreg (insn, PATTERN (insn));\n-\n-\t  /* Try this insn with each insn it links back to.  */\n+\t  next = 0;\n \n-\t  for (links = LOG_LINKS (insn); links; links = XEXP (links, 1))\n-\t    if ((next = try_combine (insn, XEXP (links, 0),\n-\t\t\t\t     NULL_RTX, &new_direct_jump_p)) != 0)\n-\t      goto retry;\n+\t  if (GET_CODE (insn) == CODE_LABEL)\n+\t    label_tick++;\n \n-\t  /* Try each sequence of three linked insns ending with this one.  */\n-\n-\t  for (links = LOG_LINKS (insn); links; links = XEXP (links, 1))\n+\t  else if (INSN_P (insn))\n \t    {\n-\t      rtx link = XEXP (links, 0);\n+\t      /* See if we know about function return values before this\n+\t\t insn based upon SUBREG flags.  */\n+\t      check_promoted_subreg (insn, PATTERN (insn));\n \n-\t      /* If the linked insn has been replaced by a note, then there\n-\t\t is no point in pursuing this chain any further.  */\n-\t      if (GET_CODE (link) == NOTE)\n-\t\tcontinue;\n+\t      /* Try this insn with each insn it links back to.  */\n \n-\t      for (nextlinks = LOG_LINKS (link);\n-\t\t   nextlinks;\n-\t\t   nextlinks = XEXP (nextlinks, 1))\n-\t\tif ((next = try_combine (insn, link,\n-\t\t\t\t\t XEXP (nextlinks, 0),\n-\t\t\t\t\t &new_direct_jump_p)) != 0)\n+\t      for (links = LOG_LINKS (insn); links; links = XEXP (links, 1))\n+\t\tif ((next = try_combine (insn, XEXP (links, 0),\n+\t\t\t\t\t NULL_RTX, &new_direct_jump_p)) != 0)\n \t\t  goto retry;\n-\t    }\n \n-#ifdef HAVE_cc0\n-\t  /* Try to combine a jump insn that uses CC0\n-\t     with a preceding insn that sets CC0, and maybe with its\n-\t     logical predecessor as well.\n-\t     This is how we make decrement-and-branch insns.\n-\t     We need this special code because data flow connections\n-\t     via CC0 do not get entered in LOG_LINKS.  */\n-\n-\t  if (GET_CODE (insn) == JUMP_INSN\n-\t      && (prev = prev_nonnote_insn (insn)) != 0\n-\t      && GET_CODE (prev) == INSN\n-\t      && sets_cc0_p (PATTERN (prev)))\n-\t    {\n-\t      if ((next = try_combine (insn, prev,\n-\t\t\t\t       NULL_RTX, &new_direct_jump_p)) != 0)\n-\t\tgoto retry;\n-\n-\t      for (nextlinks = LOG_LINKS (prev); nextlinks;\n-\t\t   nextlinks = XEXP (nextlinks, 1))\n-\t\tif ((next = try_combine (insn, prev,\n-\t\t\t\t\t XEXP (nextlinks, 0),\n-\t\t\t\t\t &new_direct_jump_p)) != 0)\n-\t\t  goto retry;\n-\t    }\n+\t      /* Try each sequence of three linked insns ending with this one.  */\n \n-\t  /* Do the same for an insn that explicitly references CC0.  */\n-\t  if (GET_CODE (insn) == INSN\n-\t      && (prev = prev_nonnote_insn (insn)) != 0\n-\t      && GET_CODE (prev) == INSN\n-\t      && sets_cc0_p (PATTERN (prev))\n-\t      && GET_CODE (PATTERN (insn)) == SET\n-\t      && reg_mentioned_p (cc0_rtx, SET_SRC (PATTERN (insn))))\n-\t    {\n-\t      if ((next = try_combine (insn, prev,\n-\t\t\t\t       NULL_RTX, &new_direct_jump_p)) != 0)\n-\t\tgoto retry;\n+\t      for (links = LOG_LINKS (insn); links; links = XEXP (links, 1))\n+\t\t{\n+\t\t  rtx link = XEXP (links, 0);\n+\n+\t\t  /* If the linked insn has been replaced by a note, then there\n+\t\t     is no point in pursuing this chain any further.  */\n+\t\t  if (GET_CODE (link) == NOTE)\n+\t\t    continue;\n+\n+\t\t  for (nextlinks = LOG_LINKS (link);\n+\t\t       nextlinks;\n+\t\t       nextlinks = XEXP (nextlinks, 1))\n+\t\t    if ((next = try_combine (insn, link,\n+\t\t\t\t\t     XEXP (nextlinks, 0),\n+\t\t\t\t\t     &new_direct_jump_p)) != 0)\n+\t\t      goto retry;\n+\t\t}\n \n-\t      for (nextlinks = LOG_LINKS (prev); nextlinks;\n-\t\t   nextlinks = XEXP (nextlinks, 1))\n-\t\tif ((next = try_combine (insn, prev,\n-\t\t\t\t\t XEXP (nextlinks, 0),\n-\t\t\t\t\t &new_direct_jump_p)) != 0)\n-\t\t  goto retry;\n-\t    }\n+    #ifdef HAVE_cc0\n+\t      /* Try to combine a jump insn that uses CC0\n+\t\t with a preceding insn that sets CC0, and maybe with its\n+\t\t logical predecessor as well.\n+\t\t This is how we make decrement-and-branch insns.\n+\t\t We need this special code because data flow connections\n+\t\t via CC0 do not get entered in LOG_LINKS.  */\n+\n+\t      if (GET_CODE (insn) == JUMP_INSN\n+\t\t  && (prev = prev_nonnote_insn (insn)) != 0\n+\t\t  && GET_CODE (prev) == INSN\n+\t\t  && sets_cc0_p (PATTERN (prev)))\n+\t\t{\n+\t\t  if ((next = try_combine (insn, prev,\n+\t\t\t\t\t   NULL_RTX, &new_direct_jump_p)) != 0)\n+\t\t    goto retry;\n+\n+\t\t  for (nextlinks = LOG_LINKS (prev); nextlinks;\n+\t\t       nextlinks = XEXP (nextlinks, 1))\n+\t\t    if ((next = try_combine (insn, prev,\n+\t\t\t\t\t     XEXP (nextlinks, 0),\n+\t\t\t\t\t     &new_direct_jump_p)) != 0)\n+\t\t      goto retry;\n+\t\t}\n \n-\t  /* Finally, see if any of the insns that this insn links to\n-\t     explicitly references CC0.  If so, try this insn, that insn,\n-\t     and its predecessor if it sets CC0.  */\n-\t  for (links = LOG_LINKS (insn); links; links = XEXP (links, 1))\n-\t    if (GET_CODE (XEXP (links, 0)) == INSN\n-\t\t&& GET_CODE (PATTERN (XEXP (links, 0))) == SET\n-\t\t&& reg_mentioned_p (cc0_rtx, SET_SRC (PATTERN (XEXP (links, 0))))\n-\t\t&& (prev = prev_nonnote_insn (XEXP (links, 0))) != 0\n-\t\t&& GET_CODE (prev) == INSN\n-\t\t&& sets_cc0_p (PATTERN (prev))\n-\t\t&& (next = try_combine (insn, XEXP (links, 0),\n-\t\t\t\t\tprev, &new_direct_jump_p)) != 0)\n-\t      goto retry;\n-#endif\n+\t      /* Do the same for an insn that explicitly references CC0.  */\n+\t      if (GET_CODE (insn) == INSN\n+\t\t  && (prev = prev_nonnote_insn (insn)) != 0\n+\t\t  && GET_CODE (prev) == INSN\n+\t\t  && sets_cc0_p (PATTERN (prev))\n+\t\t  && GET_CODE (PATTERN (insn)) == SET\n+\t\t  && reg_mentioned_p (cc0_rtx, SET_SRC (PATTERN (insn))))\n+\t\t{\n+\t\t  if ((next = try_combine (insn, prev,\n+\t\t\t\t\t   NULL_RTX, &new_direct_jump_p)) != 0)\n+\t\t    goto retry;\n+\n+\t\t  for (nextlinks = LOG_LINKS (prev); nextlinks;\n+\t\t       nextlinks = XEXP (nextlinks, 1))\n+\t\t    if ((next = try_combine (insn, prev,\n+\t\t\t\t\t     XEXP (nextlinks, 0),\n+\t\t\t\t\t     &new_direct_jump_p)) != 0)\n+\t\t      goto retry;\n+\t\t}\n \n-\t  /* Try combining an insn with two different insns whose results it\n-\t     uses.  */\n-\t  for (links = LOG_LINKS (insn); links; links = XEXP (links, 1))\n-\t    for (nextlinks = XEXP (links, 1); nextlinks;\n-\t\t nextlinks = XEXP (nextlinks, 1))\n-\t      if ((next = try_combine (insn, XEXP (links, 0),\n-\t\t\t\t       XEXP (nextlinks, 0),\n-\t\t\t\t       &new_direct_jump_p)) != 0)\n-\t\tgoto retry;\n+\t      /* Finally, see if any of the insns that this insn links to\n+\t\t explicitly references CC0.  If so, try this insn, that insn,\n+\t\t and its predecessor if it sets CC0.  */\n+\t      for (links = LOG_LINKS (insn); links; links = XEXP (links, 1))\n+\t\tif (GET_CODE (XEXP (links, 0)) == INSN\n+\t\t    && GET_CODE (PATTERN (XEXP (links, 0))) == SET\n+\t\t    && reg_mentioned_p (cc0_rtx, SET_SRC (PATTERN (XEXP (links, 0))))\n+\t\t    && (prev = prev_nonnote_insn (XEXP (links, 0))) != 0\n+\t\t    && GET_CODE (prev) == INSN\n+\t\t    && sets_cc0_p (PATTERN (prev))\n+\t\t    && (next = try_combine (insn, XEXP (links, 0),\n+\t\t\t\t\t    prev, &new_direct_jump_p)) != 0)\n+\t\t  goto retry;\n+    #endif\n+\n+\t      /* Try combining an insn with two different insns whose results it\n+\t\t uses.  */\n+\t      for (links = LOG_LINKS (insn); links; links = XEXP (links, 1))\n+\t\tfor (nextlinks = XEXP (links, 1); nextlinks;\n+\t\t     nextlinks = XEXP (nextlinks, 1))\n+\t\t  if ((next = try_combine (insn, XEXP (links, 0),\n+\t\t\t\t\t   XEXP (nextlinks, 0),\n+\t\t\t\t\t   &new_direct_jump_p)) != 0)\n+\t\t    goto retry;\n \n-\t  if (GET_CODE (insn) != NOTE)\n-\t    record_dead_and_set_regs (insn);\n+\t      if (GET_CODE (insn) != NOTE)\n+\t\trecord_dead_and_set_regs (insn);\n \n-\tretry:\n-\t  ;\n+\t    retry:\n+\t      ;\n+\t    }\n \t}\n     }\n   clear_bb_flags ();\n@@ -11666,7 +11665,7 @@ reg_dead_at_p (reg, insn)\n      rtx reg;\n      rtx insn;\n {\n-  int block;\n+  basic_block block;\n   unsigned int i;\n \n   /* Set variables for reg_dead_at_p_1.  */\n@@ -11699,21 +11698,21 @@ reg_dead_at_p (reg, insn)\n \treturn 1;\n     }\n \n-  /* Get the basic block number that we were in.  */\n+  /* Get the basic block that we were in.  */\n   if (insn == 0)\n-    block = 0;\n+    block = ENTRY_BLOCK_PTR->next_bb;\n   else\n     {\n-      for (block = 0; block < n_basic_blocks; block++)\n-\tif (insn == BLOCK_HEAD (block))\n+      FOR_EACH_BB (block)\n+\tif (insn == block->head)\n \t  break;\n \n-      if (block == n_basic_blocks)\n+      if (block == EXIT_BLOCK_PTR)\n \treturn 0;\n     }\n \n   for (i = reg_dead_regno; i < reg_dead_endregno; i++)\n-    if (REGNO_REG_SET_P (BASIC_BLOCK (block)->global_live_at_start, i))\n+    if (REGNO_REG_SET_P (block->global_live_at_start, i))\n       return 0;\n \n   return 1;"}, {"sha": "7e890a49f61a03acb347b697bea03f7e9494bd82", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -6566,11 +6566,10 @@ ia64_sched_finish (dump, sched_verbose)\n static void\n emit_predicate_relation_info ()\n {\n-  int i;\n+  basic_block bb;\n \n-  for (i = n_basic_blocks - 1; i >= 0; --i)\n+  FOR_EACH_BB_REVERSE (bb)\n     {\n-      basic_block bb = BASIC_BLOCK (i);\n       int r;\n       rtx head = bb->head;\n \n@@ -6596,9 +6595,8 @@ emit_predicate_relation_info ()\n      relations around them.  Otherwise the assembler will assume the call\n      returns, and complain about uses of call-clobbered predicates after\n      the call.  */\n-  for (i = n_basic_blocks - 1; i >= 0; --i)\n+  FOR_EACH_BB_REVERSE (bb)\n     {\n-      basic_block bb = BASIC_BLOCK (i);\n       rtx insn = bb->head;\n       \n       while (1)\n@@ -6974,11 +6972,11 @@ ia64_strip_name_encoding (str)\n \n /* The current basic block number.  */\n \n-static int block_num;\n+static bool last_block;\n \n /* True if we need a copy_state command at the start of the next block.  */\n \n-static int need_copy_state;\n+static bool need_copy_state;\n \n /* The function emits unwind directives for the start of an epilogue.  */\n \n@@ -6988,10 +6986,10 @@ process_epilogue ()\n   /* If this isn't the last block of the function, then we need to label the\n      current state, and copy it back in at the start of the next block.  */\n \n-  if (block_num != n_basic_blocks - 1)\n+  if (!last_block)\n     {\n       fprintf (asm_out_file, \"\\t.label_state 1\\n\");\n-      need_copy_state = 1;\n+      need_copy_state = true;\n     }\n \n   fprintf (asm_out_file, \"\\t.restore sp\\n\");\n@@ -7229,14 +7227,14 @@ process_for_unwind_directive (asm_out_file, insn)\n       if (GET_CODE (insn) == NOTE\n \t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_BASIC_BLOCK)\n \t{\n-\t  block_num = NOTE_BASIC_BLOCK (insn)->index;\n+\t  last_block = NOTE_BASIC_BLOCK (insn)->next_bb == EXIT_BLOCK_PTR;\n \n \t  /* Restore unwind state from immediately before the epilogue.  */\n \t  if (need_copy_state)\n \t    {\n \t      fprintf (asm_out_file, \"\\t.body\\n\");\n \t      fprintf (asm_out_file, \"\\t.copy_state 1\\n\");\n-\t      need_copy_state = 0;\n+\t      need_copy_state = false;\n \t    }\n \t}\n "}, {"sha": "e2c28414d82e56657c85bd7a974a81e1f82bcb73", "filename": "gcc/conflict.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fconflict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fconflict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconflict.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -447,19 +447,18 @@ conflict_graph_compute (regs, p)\n      regset regs;\n      partition p;\n {\n-  int b;\n   conflict_graph graph = conflict_graph_new (max_reg_num ());\n   regset_head live_head;\n   regset live = &live_head;\n   regset_head born_head;\n   regset born = &born_head;\n+  basic_block bb;\n \n   INIT_REG_SET (live);\n   INIT_REG_SET (born);\n \n-  for (b = n_basic_blocks; --b >= 0; )\n+  FOR_EACH_BB_REVERSE (bb)\n     {\n-      basic_block bb = BASIC_BLOCK (b);\n       rtx insn;\n       rtx head;\n "}, {"sha": "4711e337a9693163527036784f36fc8dd1ea0a59", "filename": "gcc/df.c", "status": "modified", "additions": 50, "deletions": 57, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -171,12 +171,6 @@ Perhaps there should be a bitmap argument to df_analyse to specify\n #include \"df.h\"\n #include \"fibheap.h\"\n \n-#define FOR_ALL_BBS(BB, CODE)\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\\\n-  int node_;\t\t\t\t\t\t\t\\\n-  for (node_ = 0; node_ < n_basic_blocks; node_++)\t\t\\\n-    {(BB) = BASIC_BLOCK (node_); CODE;};} while (0)\n-\n #define FOR_EACH_BB_IN_BITMAP(BITMAP, MIN, BB, CODE)\t\t\\\n do {\t\t\t\t\t\t\t\t\\\n   unsigned int node_;\t\t\t\t\t\t\\\n@@ -406,8 +400,8 @@ df_bitmaps_alloc (df, flags)\n      struct df *df;\n      int flags;\n {\n-  unsigned int i;\n   int dflags = 0;\n+  basic_block bb;\n \n   /* Free the bitmaps if they need resizing.  */\n   if ((flags & DF_LR) && df->n_regs < (unsigned int)max_reg_num ())\n@@ -423,9 +417,8 @@ df_bitmaps_alloc (df, flags)\n   df->n_defs = df->def_id;\n   df->n_uses = df->use_id;\n \n-  for (i = 0; i < df->n_bbs; i++)\n+  FOR_EACH_BB (bb)\n     {\n-      basic_block bb = BASIC_BLOCK (i);\n       struct bb_info *bb_info = DF_BB_INFO (df, bb);\n \n       if (flags & DF_RD && ! bb_info->rd_in)\n@@ -474,11 +467,10 @@ df_bitmaps_free (df, flags)\n      struct df *df ATTRIBUTE_UNUSED;\n      int flags;\n {\n-  unsigned int i;\n+  basic_block bb;\n \n-  for (i = 0; i < df->n_bbs; i++)\n+  FOR_EACH_BB (bb)\n     {\n-      basic_block bb = BASIC_BLOCK (i);\n       struct bb_info *bb_info = DF_BB_INFO (df, bb);\n \n       if (!bb_info)\n@@ -534,7 +526,7 @@ df_alloc (df, n_regs)\n      int n_regs;\n {\n   int n_insns;\n-  int i;\n+  basic_block bb;\n \n   gcc_obstack_init (&df_ref_obstack);\n \n@@ -572,8 +564,8 @@ df_alloc (df, n_regs)\n   df->bbs = xcalloc (df->n_bbs, sizeof (struct bb_info));\n \n   df->all_blocks = BITMAP_XMALLOC ();\n-  for (i = 0; i < n_basic_blocks; i++)\n-    bitmap_set_bit (df->all_blocks, i);\n+  FOR_EACH_BB (bb)\n+    bitmap_set_bit (df->all_blocks, bb->index);\n }\n \n \n@@ -1946,6 +1938,8 @@ df_analyse_1 (df, blocks, flags, update)\n   int aflags;\n   int dflags;\n   int i;\n+  basic_block bb;\n+\n   dflags = 0;\n   aflags = flags;\n   if (flags & DF_UD_CHAIN)\n@@ -2029,17 +2023,16 @@ df_analyse_1 (df, blocks, flags, update)\n       /* Compute the sets of gens and kills for the defs of each bb.  */\n       df_rd_local_compute (df, df->flags & DF_RD ? blocks : df->all_blocks);\n       {\n-\tint i;\n \tbitmap *in = xmalloc (sizeof (bitmap) * n_basic_blocks);\n \tbitmap *out = xmalloc (sizeof (bitmap) * n_basic_blocks);\n \tbitmap *gen = xmalloc (sizeof (bitmap) * n_basic_blocks);\n \tbitmap *kill = xmalloc (sizeof (bitmap) * n_basic_blocks);\n-\tfor (i = 0; i < n_basic_blocks; i ++)\n+\tFOR_EACH_BB (bb)\n \t  {\n-\t    in[i] = DF_BB_INFO (df, BASIC_BLOCK (i))->rd_in;\n-\t    out[i] = DF_BB_INFO (df, BASIC_BLOCK (i))->rd_out;\n-\t    gen[i] = DF_BB_INFO (df, BASIC_BLOCK (i))->rd_gen;\n-\t    kill[i] = DF_BB_INFO (df, BASIC_BLOCK (i))->rd_kill;\n+\t    in[bb->index] = DF_BB_INFO (df, bb)->rd_in;\n+\t    out[bb->index] = DF_BB_INFO (df, bb)->rd_out;\n+\t    gen[bb->index] = DF_BB_INFO (df, bb)->rd_gen;\n+\t    kill[bb->index] = DF_BB_INFO (df, bb)->rd_kill;\n \t  }\n \titerative_dataflow_bitmap (in, out, gen, kill, df->all_blocks,\n \t\t\t\t   FORWARD, UNION, df_rd_transfer_function,\n@@ -2066,17 +2059,16 @@ df_analyse_1 (df, blocks, flags, update)\n \t uses in each bb.  */\n       df_ru_local_compute (df, df->flags & DF_RU ? blocks : df->all_blocks);\n       {\n-\tint i;\n \tbitmap *in = xmalloc (sizeof (bitmap) * n_basic_blocks);\n \tbitmap *out = xmalloc (sizeof (bitmap) * n_basic_blocks);\n \tbitmap *gen = xmalloc (sizeof (bitmap) * n_basic_blocks);\n \tbitmap *kill = xmalloc (sizeof (bitmap) * n_basic_blocks);\n-\tfor (i = 0; i < n_basic_blocks; i ++)\n+\tFOR_EACH_BB (bb)\n \t  {\n-\t    in[i] = DF_BB_INFO (df, BASIC_BLOCK (i))->ru_in;\n-\t    out[i] = DF_BB_INFO (df, BASIC_BLOCK (i))->ru_out;\n-\t    gen[i] = DF_BB_INFO (df, BASIC_BLOCK (i))->ru_gen;\n-\t    kill[i] = DF_BB_INFO (df, BASIC_BLOCK (i))->ru_kill;\n+\t    in[bb->index] = DF_BB_INFO (df, bb)->ru_in;\n+\t    out[bb->index] = DF_BB_INFO (df, bb)->ru_out;\n+\t    gen[bb->index] = DF_BB_INFO (df, bb)->ru_gen;\n+\t    kill[bb->index] = DF_BB_INFO (df, bb)->ru_kill;\n \t  }\n \titerative_dataflow_bitmap (in, out, gen, kill, df->all_blocks,\n \t\t\t\t   BACKWARD, UNION, df_ru_transfer_function,\n@@ -2106,17 +2098,16 @@ df_analyse_1 (df, blocks, flags, update)\n       /* Compute the sets of defs and uses of live variables.  */\n       df_lr_local_compute (df, df->flags & DF_LR ? blocks : df->all_blocks);\n       {\n-\tint i;\n \tbitmap *in = xmalloc (sizeof (bitmap) * n_basic_blocks);\n \tbitmap *out = xmalloc (sizeof (bitmap) * n_basic_blocks);\n \tbitmap *use = xmalloc (sizeof (bitmap) * n_basic_blocks);\n \tbitmap *def = xmalloc (sizeof (bitmap) * n_basic_blocks);\n-\tfor (i = 0; i < n_basic_blocks; i ++)\n+\tFOR_EACH_BB (bb)\n \t  {\n-\t    in[i] = DF_BB_INFO (df, BASIC_BLOCK (i))->lr_in;\n-\t    out[i] = DF_BB_INFO (df, BASIC_BLOCK (i))->lr_out;\n-\t    use[i] = DF_BB_INFO (df, BASIC_BLOCK (i))->lr_use;\n-\t    def[i] = DF_BB_INFO (df, BASIC_BLOCK (i))->lr_def;\n+\t    in[bb->index] = DF_BB_INFO (df, bb)->lr_in;\n+\t    out[bb->index] = DF_BB_INFO (df, bb)->lr_out;\n+\t    use[bb->index] = DF_BB_INFO (df, bb)->lr_use;\n+\t    def[bb->index] = DF_BB_INFO (df, bb)->lr_def;\n \t  }\n \titerative_dataflow_bitmap (in, out, use, def, df->all_blocks,\n \t\t\t\t   BACKWARD, UNION, df_lr_transfer_function,\n@@ -2270,12 +2261,15 @@ df_modified_p (df, blocks)\n      struct df *df;\n      bitmap blocks;\n {\n-  unsigned int j;\n   int update = 0;\n+  basic_block bb;\n+\n+  if (!df->n_bbs)\n+    return 0;\n \n-  for (j = 0; j < df->n_bbs; j++)\n-    if (bitmap_bit_p (df->bbs_modified, j)\n-\t&& (! blocks || (blocks == (bitmap) -1) || bitmap_bit_p (blocks, j)))\n+  FOR_EACH_BB (bb)\n+    if (bitmap_bit_p (df->bbs_modified, bb->index)\n+\t&& (! blocks || (blocks == (bitmap) -1) || bitmap_bit_p (blocks, bb->index)))\n     {\n       update = 1;\n       break;\n@@ -2408,7 +2402,7 @@ df_refs_unlink (df, blocks)\n     }\n   else\n     {\n-      FOR_ALL_BBS (bb,\n+      FOR_EACH_BB (bb,\n       {\n \tdf_bb_refs_unlink (df, bb);\n       });\n@@ -3274,8 +3268,8 @@ df_dump (df, flags, file)\n      int flags;\n      FILE *file;\n {\n-  unsigned int i;\n   unsigned int j;\n+  basic_block bb;\n \n   if (! df || ! file)\n     return;\n@@ -3286,22 +3280,23 @@ df_dump (df, flags, file)\n \n   if (flags & DF_RD)\n     {\n+      basic_block bb;\n+\n       fprintf (file, \"Reaching defs:\\n\");\n-      for (i = 0; i < df->n_bbs; i++)\n+      FOR_EACH_BB (bb)\n \t{\n-\t  basic_block bb = BASIC_BLOCK (i);\n \t  struct bb_info *bb_info = DF_BB_INFO (df, bb);\n \n \t  if (! bb_info->rd_in)\n \t    continue;\n \n-\t  fprintf (file, \"bb %d in  \\t\", i);\n+\t  fprintf (file, \"bb %d in  \\t\", bb->index);\n \t  dump_bitmap (file, bb_info->rd_in);\n-\t  fprintf (file, \"bb %d gen \\t\", i);\n+\t  fprintf (file, \"bb %d gen \\t\", bb->index);\n \t  dump_bitmap (file, bb_info->rd_gen);\n-\t  fprintf (file, \"bb %d kill\\t\", i);\n+\t  fprintf (file, \"bb %d kill\\t\", bb->index);\n \t  dump_bitmap (file, bb_info->rd_kill);\n-\t  fprintf (file, \"bb %d out \\t\", i);\n+\t  fprintf (file, \"bb %d out \\t\", bb->index);\n \t  dump_bitmap (file, bb_info->rd_out);\n \t}\n     }\n@@ -3329,21 +3324,20 @@ df_dump (df, flags, file)\n   if (flags & DF_RU)\n     {\n       fprintf (file, \"Reaching uses:\\n\");\n-      for (i = 0; i < df->n_bbs; i++)\n+      FOR_EACH_BB (bb)\n \t{\n-\t  basic_block bb = BASIC_BLOCK (i);\n \t  struct bb_info *bb_info = DF_BB_INFO (df, bb);\n \n \t  if (! bb_info->ru_in)\n \t    continue;\n \n-\t  fprintf (file, \"bb %d in  \\t\", i);\n+\t  fprintf (file, \"bb %d in  \\t\", bb->index);\n \t  dump_bitmap (file, bb_info->ru_in);\n-\t  fprintf (file, \"bb %d gen \\t\", i);\n+\t  fprintf (file, \"bb %d gen \\t\", bb->index);\n \t  dump_bitmap (file, bb_info->ru_gen);\n-\t  fprintf (file, \"bb %d kill\\t\", i);\n+\t  fprintf (file, \"bb %d kill\\t\", bb->index);\n \t  dump_bitmap (file, bb_info->ru_kill);\n-\t  fprintf (file, \"bb %d out \\t\", i);\n+\t  fprintf (file, \"bb %d out \\t\", bb->index);\n \t  dump_bitmap (file, bb_info->ru_out);\n \t}\n     }\n@@ -3371,21 +3365,20 @@ df_dump (df, flags, file)\n   if (flags & DF_LR)\n     {\n       fprintf (file, \"Live regs:\\n\");\n-      for (i = 0; i < df->n_bbs; i++)\n+      FOR_EACH_BB (bb)\n \t{\n-\t  basic_block bb = BASIC_BLOCK (i);\n \t  struct bb_info *bb_info = DF_BB_INFO (df, bb);\n \n \t  if (! bb_info->lr_in)\n \t    continue;\n \n-\t  fprintf (file, \"bb %d in  \\t\", i);\n+\t  fprintf (file, \"bb %d in  \\t\", bb->index);\n \t  dump_bitmap (file, bb_info->lr_in);\n-\t  fprintf (file, \"bb %d use \\t\", i);\n+\t  fprintf (file, \"bb %d use \\t\", bb->index);\n \t  dump_bitmap (file, bb_info->lr_use);\n-\t  fprintf (file, \"bb %d def \\t\", i);\n+\t  fprintf (file, \"bb %d def \\t\", bb->index);\n \t  dump_bitmap (file, bb_info->lr_def);\n-\t  fprintf (file, \"bb %d out \\t\", i);\n+\t  fprintf (file, \"bb %d out \\t\", bb->index);\n \t  dump_bitmap (file, bb_info->lr_out);\n \t}\n     }"}, {"sha": "a4558c03e447a8b759ecadb2fe27575835522489", "filename": "gcc/dominance.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -326,10 +326,9 @@ calc_dfs_tree (di, reverse)\n          They are reverse-unreachable.  In the dom-case we disallow such\n          nodes, but in post-dom we have to deal with them, so we simply\n          include them in the DFS tree which actually becomes a forest.  */\n-      int i;\n-      for (i = n_basic_blocks - 1; i >= 0; i--)\n+      basic_block b;\n+      FOR_EACH_BB_REVERSE (b)\n \t{\n-\t  basic_block b = BASIC_BLOCK (i);\n \t  if (di->dfs_order[b->index])\n \t    continue;\n \t  di->dfs_order[b->index] = di->dfsnum;\n@@ -604,17 +603,17 @@ calculate_dominance_info (idom, doms, reverse)\n \n   if (idom)\n     {\n-      int i;\n-      for (i = 0; i < n_basic_blocks; i++)\n+      basic_block b;\n+\n+      FOR_EACH_BB (b)\n \t{\n-\t  basic_block b = BASIC_BLOCK (i);\n \t  TBB d = di.dom[di.dfs_order[b->index]];\n \n \t  /* The old code didn't modify array elements of nodes having only\n \t     itself as dominator (d==0) or only ENTRY_BLOCK (resp. EXIT_BLOCK)\n \t     (d==1).  */\n \t  if (d > 1)\n-\t    idom[i] = di.dfs_to_bb[d]->index;\n+\t    idom[b->index] = di.dfs_to_bb[d]->index;\n \t}\n     }\n   if (doms)"}, {"sha": "07e96197a66e43493e0a9e38ba4f700f7ba71e10", "filename": "gcc/final.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -934,8 +934,8 @@ insn_current_reference_address (branch)\n void\n compute_alignments ()\n {\n-  int i;\n   int log, max_skip, max_log;\n+  basic_block bb;\n \n   if (label_align)\n     {\n@@ -952,9 +952,8 @@ compute_alignments ()\n   if (! optimize || optimize_size)\n     return;\n \n-  for (i = 0; i < n_basic_blocks; i++)\n+  FOR_EACH_BB (bb)\n     {\n-      basic_block bb = BASIC_BLOCK (i);\n       rtx label = bb->head;\n       int fallthru_frequency = 0, branch_frequency = 0, has_fallthru = 0;\n       edge e;"}, {"sha": "1fb5a16eabbfd640a637e77c61d4f34ee38fa7e1", "filename": "gcc/flow.c", "status": "modified", "additions": 25, "deletions": 46, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -623,6 +623,7 @@ update_life_info (blocks, extent, prop_flags)\n   regset_head tmp_head;\n   int i;\n   int stabilized_prop_flags = prop_flags;\n+  basic_block bb;\n \n   tmp = INITIALIZE_REG_SET (tmp_head);\n   ndead = 0;\n@@ -653,10 +654,8 @@ update_life_info (blocks, extent, prop_flags)\n \n \t  /* Removing dead code may allow the CFG to be simplified which\n \t     in turn may allow for further dead code detection / removal.  */\n-\t  for (i = n_basic_blocks - 1; i >= 0; --i)\n+\t  FOR_EACH_BB_REVERSE (bb)\n \t    {\n-\t      basic_block bb = BASIC_BLOCK (i);\n-\n \t      COPY_REG_SET (tmp, bb->global_live_at_end);\n \t      changed |= propagate_block (bb, tmp, NULL, NULL,\n \t\t\t\tprop_flags & (PROP_SCAN_DEAD_CODE\n@@ -693,7 +692,7 @@ update_life_info (blocks, extent, prop_flags)\n     {\n       EXECUTE_IF_SET_IN_SBITMAP (blocks, 0, i,\n \t{\n-\t  basic_block bb = BASIC_BLOCK (i);\n+\t  bb = BASIC_BLOCK (i);\n \n \t  COPY_REG_SET (tmp, bb->global_live_at_end);\n \t  propagate_block (bb, tmp, NULL, NULL, stabilized_prop_flags);\n@@ -704,10 +703,8 @@ update_life_info (blocks, extent, prop_flags)\n     }\n   else\n     {\n-      for (i = n_basic_blocks - 1; i >= 0; --i)\n+      FOR_EACH_BB_REVERSE (bb)\n \t{\n-\t  basic_block bb = BASIC_BLOCK (i);\n-\n \t  COPY_REG_SET (tmp, bb->global_live_at_end);\n \n \t  propagate_block (bb, tmp, NULL, NULL, stabilized_prop_flags);\n@@ -762,15 +759,15 @@ update_life_info_in_dirty_blocks (extent, prop_flags)\n      int prop_flags;\n {\n   sbitmap update_life_blocks = sbitmap_alloc (n_basic_blocks);\n-  int block_num;\n   int n = 0;\n+  basic_block bb;\n   int retval = 0;\n \n   sbitmap_zero (update_life_blocks);\n-  for (block_num = 0; block_num < n_basic_blocks; block_num++)\n-    if (BASIC_BLOCK (block_num)->flags & BB_DIRTY)\n+  FOR_EACH_BB (bb)\n+    if (bb->flags & BB_DIRTY)\n       {\n-\tSET_BIT (update_life_blocks, block_num);\n+\tSET_BIT (update_life_blocks, bb->index);\n \tn++;\n       }\n \n@@ -811,14 +808,12 @@ int\n delete_noop_moves (f)\n      rtx f ATTRIBUTE_UNUSED;\n {\n-  int i;\n   rtx insn, next;\n   basic_block bb;\n   int nnoops = 0;\n \n-  for (i = 0; i < n_basic_blocks; i++)\n+  FOR_EACH_BB (bb)\n     {\n-      bb = BASIC_BLOCK (i);\n       for (insn = bb->head; insn != NEXT_INSN (bb->end); insn = next)\n \t{\n \t  next = NEXT_INSN (insn);\n@@ -1065,7 +1060,7 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n      sbitmap blocks_in, blocks_out;\n      int flags;\n {\n-  basic_block *queue, *qhead, *qtail, *qend;\n+  basic_block *queue, *qhead, *qtail, *qend, bb;\n   regset tmp, new_live_at_end, call_used;\n   regset_head tmp_head, call_used_head;\n   regset_head new_live_at_end_head;\n@@ -1074,10 +1069,8 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n   /* Some passes used to forget clear aux field of basic block causing\n      sick behaviour here.  */\n #ifdef ENABLE_CHECKING\n-  if (ENTRY_BLOCK_PTR->aux || EXIT_BLOCK_PTR->aux)\n-    abort ();\n-  for (i = 0; i < n_basic_blocks; i++)\n-    if (BASIC_BLOCK (i)->aux)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+    if (bb->aux)\n       abort ();\n #endif\n \n@@ -1102,16 +1095,12 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n      useful work.  We use AUX non-null to flag that the block is queued.  */\n   if (blocks_in)\n     {\n-      /* Clear out the garbage that might be hanging out in bb->aux.  */\n-      for (i = n_basic_blocks - 1; i >= 0; --i)\n-\tBASIC_BLOCK (i)->aux = NULL;\n-\n-      EXECUTE_IF_SET_IN_SBITMAP (blocks_in, 0, i,\n-\t{\n-\t  basic_block bb = BASIC_BLOCK (i);\n-\t  *--qhead = bb;\n-\t  bb->aux = bb;\n-\t});\n+      FOR_EACH_BB (bb)\n+\tif (TEST_BIT (blocks_in, bb->index))\n+\t  {\n+\t    *--qhead = bb;\n+\t    bb->aux = bb;\n+\t  }\n     }\n   else\n     {\n@@ -1356,9 +1345,8 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n     }\n   else\n     {\n-      for (i = n_basic_blocks - 1; i >= 0; --i)\n+      FOR_EACH_BB (bb)\n \t{\n-\t  basic_block bb = BASIC_BLOCK (i);\n \t  FREE_REG_SET (bb->local_set);\n \t  FREE_REG_SET (bb->cond_local_set);\n \t}\n@@ -1484,21 +1472,14 @@ initialize_uninitialized_subregs ()\n void\n allocate_bb_life_data ()\n {\n-  int i;\n+  basic_block bb;\n \n-  for (i = 0; i < n_basic_blocks; i++)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n     {\n-      basic_block bb = BASIC_BLOCK (i);\n-\n       bb->global_live_at_start = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n       bb->global_live_at_end = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n     }\n \n-  ENTRY_BLOCK_PTR->global_live_at_end\n-    = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n-  EXIT_BLOCK_PTR->global_live_at_start\n-    = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n-\n   regs_live_at_setjmp = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n }\n \n@@ -4228,18 +4209,16 @@ count_or_remove_death_notes (blocks, kill)\n      sbitmap blocks;\n      int kill;\n {\n-  int i, count = 0;\n+  int count = 0;\n+  basic_block bb;\n \n-  for (i = n_basic_blocks - 1; i >= 0; --i)\n+  FOR_EACH_BB_REVERSE (bb)\n     {\n-      basic_block bb;\n       rtx insn;\n \n-      if (blocks && ! TEST_BIT (blocks, i))\n+      if (blocks && ! TEST_BIT (blocks, bb->index))\n \tcontinue;\n \n-      bb = BASIC_BLOCK (i);\n-\n       for (insn = bb->head;; insn = NEXT_INSN (insn))\n \t{\n \t  if (INSN_P (insn))"}, {"sha": "65b98e1bba526d08c64656097100381093a0e14b", "filename": "gcc/gcse.c", "status": "modified", "additions": 140, "deletions": 128, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -541,7 +541,7 @@ static sbitmap *ae_kill, *ae_gen, *ae_in, *ae_out;\n struct null_pointer_info\n {\n   /* The basic block being processed.  */\n-  int current_block;\n+  basic_block current_block;\n   /* The first register to be handled in this pass.  */\n   unsigned int min_reg;\n   /* One greater than the last register to be handled in this pass.  */\n@@ -1292,13 +1292,13 @@ compute_sets (f)\n \n struct reg_avail_info\n {\n-  int last_bb;\n+  basic_block last_bb;\n   int first_set;\n   int last_set;\n };\n \n static struct reg_avail_info *reg_avail_info;\n-static int current_bb;\n+static basic_block current_bb;\n \n \n /* See whether X, the source of a set, is something we want to consider for\n@@ -1385,7 +1385,7 @@ oprs_unchanged_p (x, insn, avail_p)\n       }\n \n     case MEM:\n-      if (load_killed_in_block_p (BASIC_BLOCK (current_bb), INSN_CUID (insn),\n+      if (load_killed_in_block_p (current_bb, INSN_CUID (insn),\n \t\t\t\t  x, avail_p))\n \treturn 0;\n       else\n@@ -2375,7 +2375,7 @@ record_last_reg_set_info (insn, regno)\n     {\n       info->last_bb = current_bb;\n       info->first_set = cuid;\n-      SET_BIT (reg_set_in_block[current_bb], regno);\n+      SET_BIT (reg_set_in_block[current_bb->index], regno);\n     }\n }\n \n@@ -2504,9 +2504,9 @@ compute_hash_table (set_p)\n     gmalloc (max_gcse_regno * sizeof (struct reg_avail_info));\n \n   for (i = 0; i < max_gcse_regno; ++i)\n-    reg_avail_info[i].last_bb = NEVER_SET;\n+    reg_avail_info[i].last_bb = NULL;\n \n-  for (current_bb = 0; current_bb < n_basic_blocks; current_bb++)\n+  FOR_EACH_BB (current_bb)\n     {\n       rtx insn;\n       unsigned int regno;\n@@ -2517,8 +2517,8 @@ compute_hash_table (set_p)\n \t ??? hard-reg reg_set_in_block computation\n \t could be moved to compute_sets since they currently don't change.  */\n \n-      for (insn = BLOCK_HEAD (current_bb);\n-\t   insn && insn != NEXT_INSN (BLOCK_END (current_bb));\n+      for (insn = current_bb->head;\n+\t   insn && insn != NEXT_INSN (current_bb->end);\n \t   insn = NEXT_INSN (insn))\n \t{\n \t  if (! INSN_P (insn))\n@@ -2546,8 +2546,8 @@ compute_hash_table (set_p)\n \n       /* The next pass builds the hash table.  */\n \n-      for (insn = BLOCK_HEAD (current_bb), in_libcall_block = 0;\n-\t   insn && insn != NEXT_INSN (BLOCK_END (current_bb));\n+      for (insn = current_bb->head, in_libcall_block = 0;\n+\t   insn && insn != NEXT_INSN (current_bb->end);\n \t   insn = NEXT_INSN (insn))\n \tif (INSN_P (insn))\n \t  {\n@@ -2983,9 +2983,10 @@ handle_rd_kill_set (insn, regno, bb)\n static void\n compute_kill_rd ()\n {\n-  int bb, cuid;\n+  int cuid;\n   unsigned int regno;\n   int i;\n+  basic_block bb;\n \n   /* For each block\n        For each set bit in `gen' of the block (i.e each insn which\n@@ -2995,9 +2996,9 @@ compute_kill_rd ()\n \t For each setting of regx in the linked list, which is not in\n \t     this block\n \t   Set the bit in `kill' corresponding to that insn.  */\n-  for (bb = 0; bb < n_basic_blocks; bb++)\n+  FOR_EACH_BB (bb)\n     for (cuid = 0; cuid < max_cuid; cuid++)\n-      if (TEST_BIT (rd_gen[bb], cuid))\n+      if (TEST_BIT (rd_gen[bb->index], cuid))\n \t{\n \t  rtx insn = CUID_INSN (cuid);\n \t  rtx pat = PATTERN (insn);\n@@ -3006,7 +3007,7 @@ compute_kill_rd ()\n \t    {\n \t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \t\tif (TEST_HARD_REG_BIT (regs_invalidated_by_call, regno))\n-\t\t  handle_rd_kill_set (insn, regno, BASIC_BLOCK (bb));\n+\t\t  handle_rd_kill_set (insn, regno, bb);\n \t    }\n \n \t  if (GET_CODE (pat) == PARALLEL)\n@@ -3019,13 +3020,13 @@ compute_kill_rd ()\n \t\t      && GET_CODE (XEXP (XVECEXP (pat, 0, i), 0)) == REG)\n \t\t    handle_rd_kill_set (insn,\n \t\t\t\t\tREGNO (XEXP (XVECEXP (pat, 0, i), 0)),\n-\t\t\t\t\tBASIC_BLOCK (bb));\n+\t\t\t\t\tbb);\n \t\t}\n \t    }\n \t  else if (GET_CODE (pat) == SET && GET_CODE (SET_DEST (pat)) == REG)\n \t    /* Each setting of this register outside of this block\n \t       must be marked in the set of kills in this block.  */\n-\t    handle_rd_kill_set (insn, REGNO (SET_DEST (pat)), BASIC_BLOCK (bb));\n+\t    handle_rd_kill_set (insn, REGNO (SET_DEST (pat)), bb);\n \t}\n }\n \n@@ -3037,21 +3038,22 @@ compute_kill_rd ()\n static void\n compute_rd ()\n {\n-  int bb, changed, passes;\n+  int changed, passes;\n+  basic_block bb;\n \n-  for (bb = 0; bb < n_basic_blocks; bb++)\n-    sbitmap_copy (rd_out[bb] /*dst*/, rd_gen[bb] /*src*/);\n+  FOR_EACH_BB (bb)\n+    sbitmap_copy (rd_out[bb->index] /*dst*/, rd_gen[bb->index] /*src*/);\n \n   passes = 0;\n   changed = 1;\n   while (changed)\n     {\n       changed = 0;\n-      for (bb = 0; bb < n_basic_blocks; bb++)\n+      FOR_EACH_BB (bb)\n \t{\n-\t  sbitmap_union_of_preds (reaching_defs[bb], rd_out, bb);\n-\t  changed |= sbitmap_union_of_diff_cg (rd_out[bb], rd_gen[bb],\n-\t\t\t\t\t       reaching_defs[bb], rd_kill[bb]);\n+\t  sbitmap_union_of_preds (reaching_defs[bb->index], rd_out, bb->index);\n+\t  changed |= sbitmap_union_of_diff_cg (rd_out[bb->index], rd_gen[bb->index],\n+\t\t\t\t\t       reaching_defs[bb->index], rd_kill[bb->index]);\n \t}\n       passes++;\n     }\n@@ -3178,20 +3180,20 @@ static void\n compute_ae_kill (ae_gen, ae_kill)\n      sbitmap *ae_gen, *ae_kill;\n {\n-  int bb;\n+  basic_block bb;\n   unsigned int i;\n   struct expr *expr;\n \n-  for (bb = 0; bb < n_basic_blocks; bb++)\n+  FOR_EACH_BB (bb)\n     for (i = 0; i < expr_hash_table_size; i++)\n       for (expr = expr_hash_table[i]; expr; expr = expr->next_same_hash)\n \t{\n \t  /* Skip EXPR if generated in this block.  */\n-\t  if (TEST_BIT (ae_gen[bb], expr->bitmap_index))\n+\t  if (TEST_BIT (ae_gen[bb->index], expr->bitmap_index))\n \t    continue;\n \n-\t  if (expr_killed_p (expr->expr, BASIC_BLOCK (bb)))\n-\t    SET_BIT (ae_kill[bb], expr->bitmap_index);\n+\t  if (expr_killed_p (expr->expr, bb))\n+\t    SET_BIT (ae_kill[bb->index], expr->bitmap_index);\n \t}\n }\n \f\n@@ -3607,20 +3609,24 @@ handle_avail_expr (insn, expr)\n static int\n classic_gcse ()\n {\n-  int bb, changed;\n+  int changed;\n   rtx insn;\n+  basic_block bb;\n \n   /* Note we start at block 1.  */\n \n+  if (ENTRY_BLOCK_PTR->next_bb == EXIT_BLOCK_PTR)\n+    return 0;\n+\n   changed = 0;\n-  for (bb = 1; bb < n_basic_blocks; bb++)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR->next_bb->next_bb, EXIT_BLOCK_PTR, next_bb)\n     {\n       /* Reset tables used to keep track of what's still valid [since the\n \t start of the block].  */\n       reset_opr_set_tables ();\n \n-      for (insn = BLOCK_HEAD (bb);\n-\t   insn != NULL && insn != NEXT_INSN (BLOCK_END (bb));\n+      for (insn = bb->head;\n+\t   insn != NULL && insn != NEXT_INSN (bb->end);\n \t   insn = NEXT_INSN (insn))\n \t{\n \t  /* Is insn of form (set (pseudo-reg) ...)?  */\n@@ -3638,7 +3644,7 @@ classic_gcse ()\n \t\t  && ((expr = lookup_expr (src)) != NULL)\n \t\t  /* Is the expression available [at the start of the\n \t\t     block]?  */\n-\t\t  && TEST_BIT (ae_in[bb], expr->bitmap_index)\n+\t\t  && TEST_BIT (ae_in[bb->index], expr->bitmap_index)\n \t\t  /* Are the operands unchanged since the start of the\n \t\t     block?  */\n \t\t  && oprs_not_set_p (src, insn))\n@@ -3749,7 +3755,8 @@ compute_transp (x, indx, bmap, set_p)\n      sbitmap *bmap;\n      int set_p;\n {\n-  int bb, i, j;\n+  int i, j;\n+  basic_block bb;\n   enum rtx_code code;\n   reg_set *r;\n   const char *fmt;\n@@ -3769,9 +3776,9 @@ compute_transp (x, indx, bmap, set_p)\n \t{\n \t  if (REGNO (x) < FIRST_PSEUDO_REGISTER)\n \t    {\n-\t      for (bb = 0; bb < n_basic_blocks; bb++)\n-\t\tif (TEST_BIT (reg_set_in_block[bb], REGNO (x)))\n-\t\t  SET_BIT (bmap[bb], indx);\n+\t      FOR_EACH_BB (bb)\n+\t\tif (TEST_BIT (reg_set_in_block[bb->index], REGNO (x)))\n+\t\t  SET_BIT (bmap[bb->index], indx);\n \t    }\n \t  else\n \t    {\n@@ -3783,9 +3790,9 @@ compute_transp (x, indx, bmap, set_p)\n \t{\n \t  if (REGNO (x) < FIRST_PSEUDO_REGISTER)\n \t    {\n-\t      for (bb = 0; bb < n_basic_blocks; bb++)\n-\t\tif (TEST_BIT (reg_set_in_block[bb], REGNO (x)))\n-\t\t  RESET_BIT (bmap[bb], indx);\n+\t      FOR_EACH_BB (bb)\n+\t\tif (TEST_BIT (reg_set_in_block[bb->index], REGNO (x)))\n+\t\t  RESET_BIT (bmap[bb->index], indx);\n \t    }\n \t  else\n \t    {\n@@ -3797,9 +3804,9 @@ compute_transp (x, indx, bmap, set_p)\n       return;\n \n     case MEM:\n-      for (bb = 0; bb < n_basic_blocks; bb++)\n+      FOR_EACH_BB (bb)\n \t{\n-\t  rtx list_entry = canon_modify_mem_list[bb];\n+\t  rtx list_entry = canon_modify_mem_list[bb->index];\n \n \t  while (list_entry)\n \t    {\n@@ -3808,9 +3815,9 @@ compute_transp (x, indx, bmap, set_p)\n \t      if (GET_CODE (XEXP (list_entry, 0)) == CALL_INSN)\n \t\t{\n \t\t  if (set_p)\n-\t\t    SET_BIT (bmap[bb], indx);\n+\t\t    SET_BIT (bmap[bb->index], indx);\n \t\t  else\n-\t\t    RESET_BIT (bmap[bb], indx);\n+\t\t    RESET_BIT (bmap[bb->index], indx);\n \t\t  break;\n \t\t}\n \t      /* LIST_ENTRY must be an INSN of some kind that sets memory.\n@@ -3824,9 +3831,9 @@ compute_transp (x, indx, bmap, set_p)\n \t\t\t\t\t x, rtx_addr_varies_p))\n \t\t{\n \t\t  if (set_p)\n-\t\t    SET_BIT (bmap[bb], indx);\n+\t\t    SET_BIT (bmap[bb->index], indx);\n \t\t  else\n-\t\t    RESET_BIT (bmap[bb], indx);\n+\t\t    RESET_BIT (bmap[bb->index], indx);\n \t\t  break;\n \t\t}\n \t      list_entry = XEXP (list_entry, 1);\n@@ -4290,24 +4297,31 @@ static int\n cprop (alter_jumps)\n      int alter_jumps;\n {\n-  int bb, changed;\n+  int changed;\n+  basic_block bb;\n   rtx insn;\n \n   /* Note we start at block 1.  */\n+  if (ENTRY_BLOCK_PTR->next_bb == EXIT_BLOCK_PTR)\n+    {\n+      if (gcse_file != NULL)\n+\tfprintf (gcse_file, \"\\n\");\n+      return 0;\n+    }\n \n   changed = 0;\n-  for (bb = 1; bb < n_basic_blocks; bb++)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR->next_bb->next_bb, EXIT_BLOCK_PTR, next_bb)\n     {\n       /* Reset tables used to keep track of what's still valid [since the\n \t start of the block].  */\n       reset_opr_set_tables ();\n \n-      for (insn = BLOCK_HEAD (bb);\n-\t   insn != NULL && insn != NEXT_INSN (BLOCK_END (bb));\n+      for (insn = bb->head;\n+\t   insn != NULL && insn != NEXT_INSN (bb->end);\n \t   insn = NEXT_INSN (insn))\n \tif (INSN_P (insn))\n \t  {\n-\t    changed |= cprop_insn (BASIC_BLOCK (bb), insn, alter_jumps);\n+\t    changed |= cprop_insn (bb, insn, alter_jumps);\n \n \t    /* Keep track of everything modified by this insn.  */\n \t    /* ??? Need to be careful w.r.t. mods done to INSN.  Don't\n@@ -4454,7 +4468,7 @@ static void\n compute_pre_data ()\n {\n   sbitmap trapping_expr;\n-  int i;\n+  basic_block bb;\n   unsigned int ui;\n \n   compute_local_properties (transp, comp, antloc, 0);\n@@ -4477,24 +4491,24 @@ compute_pre_data ()\n \n      This is significantly faster than compute_ae_kill.  */\n \n-  for (i = 0; i < n_basic_blocks; i++)\n+  FOR_EACH_BB (bb)\n     {\n       edge e;\n \n       /* If the current block is the destination of an abnormal edge, we\n \t kill all trapping expressions because we won't be able to properly\n \t place the instruction on the edge.  So make them neither\n \t anticipatable nor transparent.  This is fairly conservative.  */\n-      for (e = BASIC_BLOCK (i)->pred; e ; e = e->pred_next)\n+      for (e = bb->pred; e ; e = e->pred_next)\n \tif (e->flags & EDGE_ABNORMAL)\n \t  {\n-\t    sbitmap_difference (antloc[i], antloc[i], trapping_expr);\n-\t    sbitmap_difference (transp[i], transp[i], trapping_expr);\n+\t    sbitmap_difference (antloc[bb->index], antloc[bb->index], trapping_expr);\n+\t    sbitmap_difference (transp[bb->index], transp[bb->index], trapping_expr);\n \t    break;\n \t  }\n \n-      sbitmap_a_or_b (ae_kill[i], transp[i], comp[i]);\n-      sbitmap_not (ae_kill[i], ae_kill[i]);\n+      sbitmap_a_or_b (ae_kill[bb->index], transp[bb->index], comp[bb->index]);\n+      sbitmap_not (ae_kill[bb->index], ae_kill[bb->index]);\n     }\n \n   edge_list = pre_edge_lcm (gcse_file, n_exprs, transp, comp, antloc,\n@@ -5181,18 +5195,18 @@ add_label_notes (x, insn)\n static void\n compute_transpout ()\n {\n-  int bb;\n+  basic_block bb;\n   unsigned int i;\n   struct expr *expr;\n \n   sbitmap_vector_ones (transpout, n_basic_blocks);\n \n-  for (bb = 0; bb < n_basic_blocks; ++bb)\n+  FOR_EACH_BB (bb)\n     {\n       /* Note that flow inserted a nop a the end of basic blocks that\n \t end in call instructions for reasons other than abnormal\n \t control flow.  */\n-      if (GET_CODE (BLOCK_END (bb)) != CALL_INSN)\n+      if (GET_CODE (bb->end) != CALL_INSN)\n \tcontinue;\n \n       for (i = 0; i < expr_hash_table_size; i++)\n@@ -5206,7 +5220,7 @@ compute_transpout ()\n \t      /* ??? Optimally, we would use interprocedural alias\n \t\t analysis to determine if this mem is actually killed\n \t\t by this call.  */\n-\t      RESET_BIT (transpout[bb], expr->bitmap_index);\n+\t      RESET_BIT (transpout[bb->index], expr->bitmap_index);\n \t    }\n     }\n }\n@@ -5239,8 +5253,8 @@ invalidate_nonnull_info (x, setter, data)\n \n   regno = REGNO (x) - npi->min_reg;\n \n-  RESET_BIT (npi->nonnull_local[npi->current_block], regno);\n-  SET_BIT (npi->nonnull_killed[npi->current_block], regno);\n+  RESET_BIT (npi->nonnull_local[npi->current_block->index], regno);\n+  SET_BIT (npi->nonnull_killed[npi->current_block->index], regno);\n }\n \n /* Do null-pointer check elimination for the registers indicated in\n@@ -5255,8 +5269,7 @@ delete_null_pointer_checks_1 (block_reg, nonnull_avin,\n      sbitmap *nonnull_avout;\n      struct null_pointer_info *npi;\n {\n-  int bb;\n-  int current_block;\n+  basic_block bb, current_block;\n   sbitmap *nonnull_local = npi->nonnull_local;\n   sbitmap *nonnull_killed = npi->nonnull_killed;\n   \n@@ -5271,7 +5284,7 @@ delete_null_pointer_checks_1 (block_reg, nonnull_avin,\n   sbitmap_vector_zero (nonnull_local, n_basic_blocks);\n   sbitmap_vector_zero (nonnull_killed, n_basic_blocks);\n \n-  for (current_block = 0; current_block < n_basic_blocks; current_block++)\n+  FOR_EACH_BB (current_block)\n     {\n       rtx insn, stop_insn;\n \n@@ -5280,8 +5293,8 @@ delete_null_pointer_checks_1 (block_reg, nonnull_avin,\n \n       /* Scan each insn in the basic block looking for memory references and\n \t register sets.  */\n-      stop_insn = NEXT_INSN (BLOCK_END (current_block));\n-      for (insn = BLOCK_HEAD (current_block);\n+      stop_insn = NEXT_INSN (current_block->end);\n+      for (insn = current_block->head;\n \t   insn != stop_insn;\n \t   insn = NEXT_INSN (insn))\n \t{\n@@ -5309,7 +5322,7 @@ delete_null_pointer_checks_1 (block_reg, nonnull_avin,\n \t      && GET_CODE ((reg = XEXP (SET_SRC (set), 0))) == REG\n \t      && REGNO (reg) >= npi->min_reg\n \t      && REGNO (reg) < npi->max_reg)\n-\t    SET_BIT (nonnull_local[current_block],\n+\t    SET_BIT (nonnull_local[current_block->index],\n \t\t     REGNO (reg) - npi->min_reg);\n \n \t  /* Now invalidate stuff clobbered by this insn.  */\n@@ -5322,7 +5335,7 @@ delete_null_pointer_checks_1 (block_reg, nonnull_avin,\n \t      && GET_CODE ((reg = XEXP (SET_DEST (set), 0))) == REG\n \t      && REGNO (reg) >= npi->min_reg\n \t      && REGNO (reg) < npi->max_reg)\n-\t    SET_BIT (nonnull_local[current_block],\n+\t    SET_BIT (nonnull_local[current_block->index],\n \t\t     REGNO (reg) - npi->min_reg);\n \t}\n     }\n@@ -5334,17 +5347,17 @@ delete_null_pointer_checks_1 (block_reg, nonnull_avin,\n \n   /* Now look at each bb and see if it ends with a compare of a value\n      against zero.  */\n-  for (bb = 0; bb < n_basic_blocks; bb++)\n+  FOR_EACH_BB (bb)\n     {\n-      rtx last_insn = BLOCK_END (bb);\n+      rtx last_insn = bb->end;\n       rtx condition, earliest;\n       int compare_and_branch;\n \n       /* Since MIN_REG is always at least FIRST_PSEUDO_REGISTER, and\n \t since BLOCK_REG[BB] is zero if this block did not end with a\n \t comparison against zero, this condition works.  */\n-      if (block_reg[bb] < npi->min_reg\n-\t  || block_reg[bb] >= npi->max_reg)\n+      if (block_reg[bb->index] < npi->min_reg\n+\t  || block_reg[bb->index] >= npi->max_reg)\n \tcontinue;\n \n       /* LAST_INSN is a conditional jump.  Get its condition.  */\n@@ -5355,7 +5368,7 @@ delete_null_pointer_checks_1 (block_reg, nonnull_avin,\n \tcontinue;\n \n       /* Is the register known to have a nonzero value?  */\n-      if (!TEST_BIT (nonnull_avout[bb], block_reg[bb] - npi->min_reg))\n+      if (!TEST_BIT (nonnull_avout[bb->index], block_reg[bb->index] - npi->min_reg))\n \tcontinue;\n \n       /* Try to compute whether the compare/branch at the loop end is one or\n@@ -5383,12 +5396,12 @@ delete_null_pointer_checks_1 (block_reg, nonnull_avin,\n       delete_insn (last_insn);\n       if (compare_and_branch == 2)\n         delete_insn (earliest);\n-      purge_dead_edges (BASIC_BLOCK (bb));\n+      purge_dead_edges (bb);\n \n       /* Don't check this block again.  (Note that BLOCK_END is\n \t invalid here; we deleted the last instruction in the \n \t block.)  */\n-      block_reg[bb] = 0;\n+      block_reg[bb->index] = 0;\n     }\n }\n \n@@ -5422,7 +5435,7 @@ delete_null_pointer_checks (f)\n {\n   sbitmap *nonnull_avin, *nonnull_avout;\n   unsigned int *block_reg;\n-  int bb;\n+  basic_block bb;\n   int reg;\n   int regs_per_pass;\n   int max_reg;\n@@ -5458,9 +5471,9 @@ delete_null_pointer_checks (f)\n      ends with a conditional branch whose condition is a comparison\n      against zero.  Record the register compared in BLOCK_REG.  */\n   block_reg = (unsigned int *) xcalloc (n_basic_blocks, sizeof (int));\n-  for (bb = 0; bb < n_basic_blocks; bb++)\n+  FOR_EACH_BB (bb)\n     {\n-      rtx last_insn = BLOCK_END (bb);\n+      rtx last_insn = bb->end;\n       rtx condition, earliest, reg;\n \n       /* We only want conditional branches.  */\n@@ -5486,7 +5499,7 @@ delete_null_pointer_checks (f)\n       if (GET_CODE (reg) != REG)\n \tcontinue;\n \n-      block_reg[bb] = REGNO (reg);\n+      block_reg[bb->index] = REGNO (reg);\n     }\n \n   /* Go through the algorithm for each block of registers.  */\n@@ -5570,7 +5583,8 @@ free_code_hoist_mem ()\n static void\n compute_code_hoist_vbeinout ()\n {\n-  int bb, changed, passes;\n+  int changed, passes;\n+  basic_block bb;\n \n   sbitmap_vector_zero (hoist_vbeout, n_basic_blocks);\n   sbitmap_vector_zero (hoist_vbein, n_basic_blocks);\n@@ -5584,12 +5598,12 @@ compute_code_hoist_vbeinout ()\n \n       /* We scan the blocks in the reverse order to speed up\n \t the convergence.  */\n-      for (bb = n_basic_blocks - 1; bb >= 0; bb--)\n+      FOR_EACH_BB_REVERSE (bb)\n \t{\n-\t  changed |= sbitmap_a_or_b_and_c_cg (hoist_vbein[bb], antloc[bb],\n-\t\t\t\t\t      hoist_vbeout[bb], transp[bb]);\n-\t  if (BASIC_BLOCK (bb)->next_bb != EXIT_BLOCK_PTR)\n-\t    sbitmap_intersection_of_succs (hoist_vbeout[bb], hoist_vbein, bb);\n+\t  changed |= sbitmap_a_or_b_and_c_cg (hoist_vbein[bb->index], antloc[bb->index],\n+\t\t\t\t\t      hoist_vbeout[bb->index], transp[bb->index]);\n+\t  if (bb->next_bb != EXIT_BLOCK_PTR)\n+\t    sbitmap_intersection_of_succs (hoist_vbeout[bb->index], hoist_vbein, bb->index);\n \t}\n \n       passes++;\n@@ -5677,7 +5691,7 @@ hoist_expr_reaches_here_p (expr_bb, expr_index, bb, visited)\n static void\n hoist_code ()\n {\n-  int bb, dominated;\n+  basic_block bb, dominated;\n   unsigned int i;\n   struct expr **index_map;\n   struct expr *expr;\n@@ -5694,42 +5708,41 @@ hoist_code ()\n \n   /* Walk over each basic block looking for potentially hoistable\n      expressions, nothing gets hoisted from the entry block.  */\n-  for (bb = 0; bb < n_basic_blocks; bb++)\n+  FOR_EACH_BB (bb)\n     {\n       int found = 0;\n       int insn_inserted_p;\n \n       /* Examine each expression that is very busy at the exit of this\n \t block.  These are the potentially hoistable expressions.  */\n-      for (i = 0; i < hoist_vbeout[bb]->n_bits; i++)\n+      for (i = 0; i < hoist_vbeout[bb->index]->n_bits; i++)\n \t{\n \t  int hoistable = 0;\n \n-\t  if (TEST_BIT (hoist_vbeout[bb], i) && TEST_BIT (transpout[bb], i))\n+\t  if (TEST_BIT (hoist_vbeout[bb->index], i) && TEST_BIT (transpout[bb->index], i))\n \t    {\n \t      /* We've found a potentially hoistable expression, now\n \t\t we look at every block BB dominates to see if it\n \t\t computes the expression.  */\n-\t      for (dominated = 0; dominated < n_basic_blocks; dominated++)\n+\t      FOR_EACH_BB (dominated)\n \t\t{\n \t\t  /* Ignore self dominance.  */\n \t\t  if (bb == dominated\n-\t\t      || ! TEST_BIT (dominators[dominated], bb))\n+\t\t      || ! TEST_BIT (dominators[dominated->index], bb->index))\n \t\t    continue;\n \n \t\t  /* We've found a dominated block, now see if it computes\n \t\t     the busy expression and whether or not moving that\n \t\t     expression to the \"beginning\" of that block is safe.  */\n-\t\t  if (!TEST_BIT (antloc[dominated], i))\n+\t\t  if (!TEST_BIT (antloc[dominated->index], i))\n \t\t    continue;\n \n \t\t  /* Note if the expression would reach the dominated block\n \t\t     unimpared if it was placed at the end of BB. \n \n \t\t     Keep track of how many times this expression is hoistable\n \t\t     from a dominated block into BB.  */\n-\t\t  if (hoist_expr_reaches_here_p (BASIC_BLOCK (bb), i, \n-\t\t\t\t\t\t BASIC_BLOCK (dominated), NULL))\n+\t\t  if (hoist_expr_reaches_here_p (bb, i, dominated, NULL))\n \t\t    hoistable++;\n \t\t}\n \n@@ -5745,7 +5758,7 @@ hoist_code ()\n \t\t to nullify any benefit we get from code hoisting.  */\n \t      if (hoistable > 1)\n \t\t{\n-\t\t  SET_BIT (hoist_exprs[bb], i);\n+\t\t  SET_BIT (hoist_exprs[bb->index], i);\n \t\t  found = 1;\n \t\t}\n \t    }\n@@ -5756,46 +5769,45 @@ hoist_code ()\n \tcontinue;\n \n       /* Loop over all the hoistable expressions.  */\n-      for (i = 0; i < hoist_exprs[bb]->n_bits; i++)\n+      for (i = 0; i < hoist_exprs[bb->index]->n_bits; i++)\n \t{\n \t  /* We want to insert the expression into BB only once, so\n \t     note when we've inserted it.  */\n \t  insn_inserted_p = 0;\n \n \t  /* These tests should be the same as the tests above.  */\n-\t  if (TEST_BIT (hoist_vbeout[bb], i))\n+\t  if (TEST_BIT (hoist_vbeout[bb->index], i))\n \t    {\n \t      /* We've found a potentially hoistable expression, now\n \t\t we look at every block BB dominates to see if it\n \t\t computes the expression.  */\n-\t      for (dominated = 0; dominated < n_basic_blocks; dominated++)\n+\t      FOR_EACH_BB (dominated)\n \t\t{\n \t\t  /* Ignore self dominance.  */\n \t\t  if (bb == dominated\n-\t\t      || ! TEST_BIT (dominators[dominated], bb))\n+\t\t      || ! TEST_BIT (dominators[dominated->index], bb->index))\n \t\t    continue;\n \n \t\t  /* We've found a dominated block, now see if it computes\n \t\t     the busy expression and whether or not moving that\n \t\t     expression to the \"beginning\" of that block is safe.  */\n-\t\t  if (!TEST_BIT (antloc[dominated], i))\n+\t\t  if (!TEST_BIT (antloc[dominated->index], i))\n \t\t    continue;\n \n \t\t  /* The expression is computed in the dominated block and\n \t\t     it would be safe to compute it at the start of the\n \t\t     dominated block.  Now we have to determine if the\n \t\t     expression would reach the dominated block if it was\n \t\t     placed at the end of BB.  */\n-\t\t  if (hoist_expr_reaches_here_p (BASIC_BLOCK (bb), i, \n-\t\t\t\t\t\t BASIC_BLOCK (dominated), NULL))\n+\t\t  if (hoist_expr_reaches_here_p (bb, i, dominated, NULL))\n \t\t    {\n \t\t      struct expr *expr = index_map[i];\n \t\t      struct occr *occr = expr->antic_occr;\n \t\t      rtx insn;\n \t\t      rtx set;\n \n \t\t      /* Find the right occurrence of this expression.  */\n-\t\t      while (BLOCK_NUM (occr->insn) != dominated && occr)\n+\t\t      while (BLOCK_FOR_INSN (occr->insn) != dominated && occr)\n \t\t\toccr = occr->next;\n \n \t\t      /* Should never happen.  */\n@@ -5829,8 +5841,7 @@ hoist_code ()\n \t\t\t  occr->deleted_p = 1;\n \t\t\t  if (!insn_inserted_p)\n \t\t\t    {\n-\t\t\t      insert_insn_end_bb (index_map[i], \n-\t\t\t\t\t\t  BASIC_BLOCK (bb), 0);\n+\t\t\t      insert_insn_end_bb (index_map[i], bb, 0);\n \t\t\t      insn_inserted_p = 1;\n \t\t\t    }\n \t\t\t}\n@@ -6110,15 +6121,15 @@ static void\n compute_ld_motion_mems ()\n {\n   struct ls_expr * ptr;\n-  int bb;\n+  basic_block bb;\n   rtx insn;\n   \n   pre_ldst_mems = NULL;\n \n-  for (bb = 0; bb < n_basic_blocks; bb++)\n+  FOR_EACH_BB (bb)\n     {\n-      for (insn = BLOCK_HEAD (bb);\n-\t   insn && insn != NEXT_INSN (BLOCK_END (bb));\n+      for (insn = bb->head;\n+\t   insn && insn != NEXT_INSN (bb->end);\n \t   insn = NEXT_INSN (insn))\n \t{\n \t  if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n@@ -6435,7 +6446,8 @@ find_moveable_store (insn)\n static int\n compute_store_table ()\n {\n-  int bb, ret;\n+  int ret;\n+  basic_block bb;\n   unsigned regno;\n   rtx insn, pat;\n \n@@ -6447,11 +6459,11 @@ compute_store_table ()\n   pre_ldst_mems = 0;\n \n   /* Find all the stores we care about.  */\n-  for (bb = 0; bb < n_basic_blocks; bb++)\n+  FOR_EACH_BB (bb)\n     {\n-      regvec = & (reg_set_in_block[bb]);\n-      for (insn = BLOCK_END (bb);\n-\t   insn && insn != PREV_INSN (BLOCK_HEAD (bb));\n+      regvec = & (reg_set_in_block[bb->index]);\n+      for (insn = bb->end;\n+\t   insn && insn != PREV_INSN (bb->end);\n \t   insn = PREV_INSN (insn))\n \t{\n \t  /* Ignore anything that is not a normal insn.  */\n@@ -6470,7 +6482,7 @@ compute_store_table ()\n \t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \t\tif (clobbers_all\n \t\t    || TEST_HARD_REG_BIT (regs_invalidated_by_call, regno))\n-\t\t  SET_BIT (reg_set_in_block[bb], regno);\n+\t\t  SET_BIT (reg_set_in_block[bb->index], regno);\n \t    }\n \t  \n \t  pat = PATTERN (insn);\n@@ -6636,8 +6648,7 @@ store_killed_before (x, insn, bb)\n static void\n build_store_vectors () \n {\n-  basic_block bb;\n-  int b;\n+  basic_block bb, b;\n   rtx insn, st;\n   struct ls_expr * ptr;\n \n@@ -6709,9 +6720,9 @@ build_store_vectors ()\n   sbitmap_vector_zero (transp, n_basic_blocks);\n \n   for (ptr = first_ls_expr (); ptr != NULL; ptr = next_ls_expr (ptr))\n-    for (b = 0; b < n_basic_blocks; b++)\n+    FOR_EACH_BB (b)\n       {\n-\tif (store_killed_after (ptr->pattern, BLOCK_HEAD (b), BASIC_BLOCK (b)))\n+\tif (store_killed_after (ptr->pattern, b->head, b))\n \t  {\n \t    /* The anticipatable expression is not killed if it's gen'd.  */\n \t    /*\n@@ -6729,10 +6740,10 @@ build_store_vectors ()\n \t      If we always kill it in this case, we'll sometimes do\n \t      uneccessary work, but it shouldn't actually hurt anything.\n \t    if (!TEST_BIT (ae_gen[b], ptr->index)).  */\n-\t    SET_BIT (ae_kill[b], ptr->index);\n+\t    SET_BIT (ae_kill[b->index], ptr->index);\n \t  }\n \telse\n-\t  SET_BIT (transp[b], ptr->index);\n+\t  SET_BIT (transp[b->index], ptr->index);\n       }\n \n   /* Any block with no exits calls some non-returning function, so\n@@ -6941,6 +6952,7 @@ free_store_memory ()\n static void\n store_motion ()\n {\n+  basic_block bb;\n   int x;\n   struct ls_expr * ptr;\n   int update_flow = 0;\n@@ -6974,9 +6986,9 @@ store_motion ()\n   /* Now we want to insert the new stores which are going to be needed.  */\n   for (ptr = first_ls_expr (); ptr != NULL; ptr = next_ls_expr (ptr))\n     {\n-      for (x = 0; x < n_basic_blocks; x++)\n-\tif (TEST_BIT (pre_delete_map[x], ptr->index))\n-\t  delete_store (ptr, BASIC_BLOCK (x));\n+      FOR_EACH_BB (bb)\n+\tif (TEST_BIT (pre_delete_map[bb->index], ptr->index))\n+\t  delete_store (ptr, bb);\n \n       for (x = 0; x < NUM_EDGES (edge_list); x++)\n \tif (TEST_BIT (pre_insert_map[x], ptr->index))"}, {"sha": "7539ae58a50ac90afd2fd4082f4504015b19df8d", "filename": "gcc/global.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -636,7 +636,8 @@ allocno_compare (v1p, v2p)\n static void\n global_conflicts ()\n {\n-  int b, i;\n+  int i;\n+  basic_block b;\n   rtx insn;\n   int *block_start_allocnos;\n \n@@ -645,7 +646,7 @@ global_conflicts ()\n \n   block_start_allocnos = (int *) xmalloc (max_allocno * sizeof (int));\n \n-  for (b = 0; b < n_basic_blocks; b++)\n+  FOR_EACH_BB (b)\n     {\n       memset ((char *) allocnos_live, 0, allocno_row_words * sizeof (INT_TYPE));\n \n@@ -664,7 +665,7 @@ global_conflicts ()\n \t are explicitly marked in basic_block_live_at_start.  */\n \n       {\n-\tregset old = BASIC_BLOCK (b)->global_live_at_start;\n+\tregset old = b->global_live_at_start;\n \tint ax = 0;\n \n \tREG_SET_TO_HARD_REG_SET (hard_regs_live, old);\n@@ -713,7 +714,7 @@ global_conflicts ()\n \t     that is reached by an abnormal edge.  */\n \n \t  edge e;\n-\t  for (e = BASIC_BLOCK (b)->pred; e ; e = e->pred_next)\n+\t  for (e = b->pred; e ; e = e->pred_next)\n \t    if (e->flags & EDGE_ABNORMAL)\n \t      break;\n \t  if (e != NULL)\n@@ -723,7 +724,7 @@ global_conflicts ()\n #endif\n       }\n \n-      insn = BLOCK_HEAD (b);\n+      insn = b->head;\n \n       /* Scan the code of this basic block, noting which allocnos\n \t and hard regs are born or die.  When one is born,\n@@ -823,7 +824,7 @@ global_conflicts ()\n \t\t}\n \t    }\n \n-\t  if (insn == BLOCK_END (b))\n+\t  if (insn == b->end)\n \t    break;\n \t  insn = NEXT_INSN (insn);\n \t}\n@@ -1708,11 +1709,11 @@ void\n mark_elimination (from, to)\n      int from, to;\n {\n-  int i;\n+  basic_block bb;\n \n-  for (i = 0; i < n_basic_blocks; i++)\n+  FOR_EACH_BB (bb)\n     {\n-      regset r = BASIC_BLOCK (i)->global_live_at_start; \n+      regset r = bb->global_live_at_start; \n       if (REGNO_REG_SET_P (r, from))\n \t{\n \t  CLEAR_REGNO_REG_SET (r, from);"}, {"sha": "572c6b26e24b92344f787feb1febc97367d35f6a", "filename": "gcc/graph.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -258,27 +258,26 @@ print_rtl_graph_with_bb (base, suffix, rtx_first)\n     fprintf (fp, \"(nil)\\n\");\n   else\n     {\n-      int i;\n       enum bb_state { NOT_IN_BB, IN_ONE_BB, IN_MULTIPLE_BB };\n       int max_uid = get_max_uid ();\n       int *start = (int *) xmalloc (max_uid * sizeof (int));\n       int *end = (int *) xmalloc (max_uid * sizeof (int));\n       enum bb_state *in_bb_p = (enum bb_state *)\n \txmalloc (max_uid * sizeof (enum bb_state));\n       basic_block bb;\n+      int i;\n \n       for (i = 0; i < max_uid; ++i)\n \t{\n \t  start[i] = end[i] = -1;\n \t  in_bb_p[i] = NOT_IN_BB;\n \t}\n \n-      for (i = n_basic_blocks - 1; i >= 0; --i)\n+      FOR_EACH_BB_REVERSE (bb)\n \t{\n \t  rtx x;\n-\t  bb = BASIC_BLOCK (i);\n-\t  start[INSN_UID (bb->head)] = i;\n-\t  end[INSN_UID (bb->end)] = i;\n+\t  start[INSN_UID (bb->head)] = bb->index;\n+\t  end[INSN_UID (bb->end)] = bb->index;\n \t  for (x = bb->head; x != NULL_RTX; x = NEXT_INSN (x))\n \t    {\n \t      in_bb_p[INSN_UID (x)]"}, {"sha": "147dd7d8818c08e941a4a60707c33785c0d8d080", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -2303,7 +2303,8 @@ void\n sched_init (dump_file)\n      FILE *dump_file;\n {\n-  int luid, b;\n+  int luid;\n+  basic_block b;\n   rtx insn;\n   int i;\n \n@@ -2356,8 +2357,8 @@ sched_init (dump_file)\n \n   h_i_d[0].luid = 0;\n   luid = 1;\n-  for (b = 0; b < n_basic_blocks; b++)\n-    for (insn = BLOCK_HEAD (b);; insn = NEXT_INSN (insn))\n+  FOR_EACH_BB (b)\n+    for (insn = b->head;; insn = NEXT_INSN (insn))\n       {\n \tINSN_LUID (insn) = luid;\n \n@@ -2369,7 +2370,7 @@ sched_init (dump_file)\n \tif (GET_CODE (insn) != NOTE)\n \t  ++luid;\n \n-\tif (insn == BLOCK_END (b))\n+\tif (insn == b->end)\n \t  break;\n       }\n \n@@ -2391,22 +2392,22 @@ sched_init (dump_file)\n          predecessor has been scheduled, it is impossible to accurately\n          determine the correct line number for the first insn of the block.  */\n \n-      for (b = 0; b < n_basic_blocks; b++)\n+      FOR_EACH_BB (b)\n \t{\n-\t  for (line = BLOCK_HEAD (b); line; line = PREV_INSN (line))\n+\t  for (line = b->head; line; line = PREV_INSN (line))\n \t    if (GET_CODE (line) == NOTE && NOTE_LINE_NUMBER (line) > 0)\n \t      {\n-\t\tline_note_head[b] = line;\n+\t\tline_note_head[b->index] = line;\n \t\tbreak;\n \t      }\n \t  /* Do a forward search as well, since we won't get to see the first\n \t     notes in a basic block.  */\n-\t  for (line = BLOCK_HEAD (b); line; line = NEXT_INSN (line))\n+\t  for (line = b->head; line; line = NEXT_INSN (line))\n \t    {\n \t      if (INSN_P (line))\n \t\tbreak;\n \t      if (GET_CODE (line) == NOTE && NOTE_LINE_NUMBER (line) > 0)\n-\t\tline_note_head[b] = line;\n+\t\tline_note_head[b->index] = line;\n \t    }\n \t}\n     }\n@@ -2420,22 +2421,22 @@ sched_init (dump_file)\n   /* ??? Add a NOTE after the last insn of the last basic block.  It is not\n      known why this is done.  */\n \n-  insn = BLOCK_END (n_basic_blocks - 1);\n+  insn = EXIT_BLOCK_PTR->prev_bb->end;\n   if (NEXT_INSN (insn) == 0\n       || (GET_CODE (insn) != NOTE\n \t  && GET_CODE (insn) != CODE_LABEL\n \t  /* Don't emit a NOTE if it would end up before a BARRIER.  */\n \t  && GET_CODE (NEXT_INSN (insn)) != BARRIER))\n     {\n-      emit_note_after (NOTE_INSN_DELETED, BLOCK_END (n_basic_blocks - 1));\n+      emit_note_after (NOTE_INSN_DELETED, EXIT_BLOCK_PTR->prev_bb->end);\n       /* Make insn to appear outside BB.  */\n-      BLOCK_END (n_basic_blocks - 1) = PREV_INSN (BLOCK_END (n_basic_blocks - 1));\n+      EXIT_BLOCK_PTR->prev_bb->end = PREV_INSN (EXIT_BLOCK_PTR->prev_bb->end);\n     }\n \n   /* Compute INSN_REG_WEIGHT for all blocks.  We must do this before\n      removing death notes.  */\n-  for (b = n_basic_blocks - 1; b >= 0; b--)\n-    find_insn_reg_weight (b);\n+  FOR_EACH_BB_REVERSE (b)\n+    find_insn_reg_weight (b->index);\n }\n \n /* Free global data used during insn scheduling.  */"}, {"sha": "c551f1413d58974617b66656f7175ab6b03c40c1", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -2685,7 +2685,7 @@ void\n if_convert (x_life_data_ok)\n      int x_life_data_ok;\n {\n-  int block_num;\n+  basic_block bb;\n \n   num_possible_if_blocks = 0;\n   num_updated_if_blocks = 0;\n@@ -2707,18 +2707,13 @@ if_convert (x_life_data_ok)\n     clear_bb_flags ();\n \n   /* Record initial block numbers.  */\n-  for (block_num = 0; block_num < n_basic_blocks; block_num++)\n-    SET_ORIG_INDEX (BASIC_BLOCK (block_num), block_num);\n+  FOR_EACH_BB (bb)\n+    SET_ORIG_INDEX (bb, bb->index);\n \n   /* Go through each of the basic blocks looking for things to convert.  */\n-  for (block_num = 0; block_num < n_basic_blocks; )\n-    {\n-      basic_block bb = BASIC_BLOCK (block_num);\n-      if (find_if_header (bb))\n-\tblock_num = bb->index;\n-      else \n-\tblock_num++;\n-    }\n+  FOR_EACH_BB (bb)\n+    while (find_if_header (bb))\n+      continue;\n \n   if (post_dominators)\n     sbitmap_vector_free (post_dominators);"}, {"sha": "3cb9fe067b42129e6259706ed9f8f2b0880366e1", "filename": "gcc/lcm.c", "status": "modified", "additions": 79, "deletions": 83, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -106,7 +106,7 @@ compute_antinout_edge (antloc, transp, antin, antout)\n      sbitmap *antin;\n      sbitmap *antout;\n {\n-  int bb;\n+  basic_block bb;\n   edge e;\n   basic_block *worklist, *qin, *qout, *qend;\n   unsigned int qlen;\n@@ -123,10 +123,10 @@ compute_antinout_edge (antloc, transp, antin, antout)\n \n   /* Put every block on the worklist; this is necessary because of the\n      optimistic initialization of ANTIN above.  */\n-  for (bb = n_basic_blocks - 1; bb >= 0; bb--)\n+  FOR_EACH_BB_REVERSE (bb)\n     {\n-      *qin++ = BASIC_BLOCK (bb);\n-      BASIC_BLOCK (bb)->aux = BASIC_BLOCK (bb);\n+      *qin++ =bb;\n+      bb->aux = bb;\n     }\n \n   qin = worklist;\n@@ -142,32 +142,31 @@ compute_antinout_edge (antloc, transp, antin, antout)\n   while (qlen)\n     {\n       /* Take the first entry off the worklist.  */\n-      basic_block b = *qout++;\n-      bb = b->index;\n+      bb = *qout++;\n       qlen--;\n \n       if (qout >= qend)\n         qout = worklist;\n \n-      if (b->aux == EXIT_BLOCK_PTR)\n+      if (bb->aux == EXIT_BLOCK_PTR)\n \t/* Do not clear the aux field for blocks which are predecessors of\n \t   the EXIT block.  That way we never add then to the worklist\n \t   again.  */\n-\tsbitmap_zero (antout[bb]);\n+\tsbitmap_zero (antout[bb->index]);\n       else\n \t{\n \t  /* Clear the aux field of this block so that it can be added to\n \t     the worklist again if necessary.  */\n-\t  b->aux = NULL;\n-\t  sbitmap_intersection_of_succs (antout[bb], antin, bb);\n+\t  bb->aux = NULL;\n+\t  sbitmap_intersection_of_succs (antout[bb->index], antin, bb->index);\n \t}\n \n-      if (sbitmap_a_or_b_and_c_cg (antin[bb], antloc[bb],\n-\t\t\t\t   transp[bb], antout[bb]))\n+      if (sbitmap_a_or_b_and_c_cg (antin[bb->index], antloc[bb->index],\n+\t\t\t\t   transp[bb->index], antout[bb->index]))\n \t/* If the in state of this block changed, then we need\n \t   to add the predecessors of this block to the worklist\n \t   if they are not already on the worklist.  */\n-\tfor (e = b->pred; e; e = e->pred_next)\n+\tfor (e = bb->pred; e; e = e->pred_next)\n \t  if (!e->src->aux && e->src != ENTRY_BLOCK_PTR)\n \t    {\n \t      *qin++ = e->src;\n@@ -263,9 +262,9 @@ compute_laterin (edge_list, earliest, antloc, later, laterin)\n      struct edge_list *edge_list;\n      sbitmap *earliest, *antloc, *later, *laterin;\n {\n-  int bb, num_edges, i;\n+  int num_edges, i;\n   edge e;\n-  basic_block *worklist, *qin, *qout, *qend;\n+  basic_block *worklist, *qin, *qout, *qend, bb;\n   unsigned int qlen;\n \n   num_edges = NUM_EDGES (edge_list);\n@@ -301,11 +300,10 @@ compute_laterin (edge_list, earliest, antloc, later, laterin)\n \n   /* Add all the blocks to the worklist.  This prevents an early exit from\n      the loop given our optimistic initialization of LATER above.  */\n-  for (bb = 0; bb < n_basic_blocks; bb++)\n+  FOR_EACH_BB (bb)\n     {\n-      basic_block b = BASIC_BLOCK (bb);\n-      *qin++ = b;\n-      b->aux = b;\n+      *qin++ = bb;\n+      bb->aux = bb;\n     }\n   qin = worklist;\n   /* Note that we do not use the last allocated element for our queue,\n@@ -318,20 +316,19 @@ compute_laterin (edge_list, earliest, antloc, later, laterin)\n   while (qlen)\n     {\n       /* Take the first entry off the worklist.  */\n-      basic_block b = *qout++;\n-      b->aux = NULL;\n+      bb = *qout++;\n+      bb->aux = NULL;\n       qlen--;\n       if (qout >= qend)\n         qout = worklist;\n \n       /* Compute the intersection of LATERIN for each incoming edge to B.  */\n-      bb = b->index;\n-      sbitmap_ones (laterin[bb]);\n-      for (e = b->pred; e != NULL; e = e->pred_next)\n-\tsbitmap_a_and_b (laterin[bb], laterin[bb], later[(size_t)e->aux]);\n+      sbitmap_ones (laterin[bb->index]);\n+      for (e = bb->pred; e != NULL; e = e->pred_next)\n+\tsbitmap_a_and_b (laterin[bb->index], laterin[bb->index], later[(size_t)e->aux]);\n \n       /* Calculate LATER for all outgoing edges.  */\n-      for (e = b->succ; e != NULL; e = e->succ_next)\n+      for (e = bb->succ; e != NULL; e = e->succ_next)\n \tif (sbitmap_union_of_diff_cg (later[(size_t) e->aux],\n \t\t\t\t      earliest[(size_t) e->aux],\n \t\t\t\t      laterin[e->src->index],\n@@ -370,9 +367,10 @@ compute_insert_delete (edge_list, antloc, later, laterin,\n      sbitmap *antloc, *later, *laterin, *insert, *delete;\n {\n   int x;\n+  basic_block bb;\n \n-  for (x = 0; x < n_basic_blocks; x++)\n-    sbitmap_difference (delete[x], antloc[x], laterin[x]);\n+  FOR_EACH_BB (bb)\n+    sbitmap_difference (delete[bb->index], antloc[bb->index], laterin[bb->index]);\n \n   for (x = 0; x < NUM_EDGES (edge_list); x++)\n     {\n@@ -496,9 +494,8 @@ void\n compute_available (avloc, kill, avout, avin)\n      sbitmap *avloc, *kill, *avout, *avin;\n {\n-  int bb;\n   edge e;\n-  basic_block *worklist, *qin, *qout, *qend;\n+  basic_block *worklist, *qin, *qout, *qend, bb;\n   unsigned int qlen;\n \n   /* Allocate a worklist array/queue.  Entries are only added to the\n@@ -512,10 +509,10 @@ compute_available (avloc, kill, avout, avin)\n \n   /* Put every block on the worklist; this is necessary because of the\n      optimistic initialization of AVOUT above.  */\n-  for (bb = 0; bb < n_basic_blocks; bb++)\n+  FOR_EACH_BB (bb)\n     {\n-      *qin++ = BASIC_BLOCK (bb);\n-      BASIC_BLOCK (bb)->aux = BASIC_BLOCK (bb);\n+      *qin++ = bb;\n+      bb->aux = bb;\n     }\n \n   qin = worklist;\n@@ -531,8 +528,7 @@ compute_available (avloc, kill, avout, avin)\n   while (qlen)\n     {\n       /* Take the first entry off the worklist.  */\n-      basic_block b = *qout++;\n-      bb = b->index;\n+      bb = *qout++;\n       qlen--;\n \n       if (qout >= qend)\n@@ -541,23 +537,23 @@ compute_available (avloc, kill, avout, avin)\n       /* If one of the predecessor blocks is the ENTRY block, then the\n \t intersection of avouts is the null set.  We can identify such blocks\n \t by the special value in the AUX field in the block structure.  */\n-      if (b->aux == ENTRY_BLOCK_PTR)\n+      if (bb->aux == ENTRY_BLOCK_PTR)\n \t/* Do not clear the aux field for blocks which are successors of the\n \t   ENTRY block.  That way we never add then to the worklist again.  */\n-\tsbitmap_zero (avin[bb]);\n+\tsbitmap_zero (avin[bb->index]);\n       else\n \t{\n \t  /* Clear the aux field of this block so that it can be added to\n \t     the worklist again if necessary.  */\n-\t  b->aux = NULL;\n-\t  sbitmap_intersection_of_preds (avin[bb], avout, bb);\n+\t  bb->aux = NULL;\n+\t  sbitmap_intersection_of_preds (avin[bb->index], avout, bb->index);\n \t}\n \n-      if (sbitmap_union_of_diff_cg (avout[bb], avloc[bb], avin[bb], kill[bb]))\n+      if (sbitmap_union_of_diff_cg (avout[bb->index], avloc[bb->index], avin[bb->index], kill[bb->index]))\n \t/* If the out state of this block changed, then we need\n \t   to add the successors of this block to the worklist\n \t   if they are not already on the worklist.  */\n-\tfor (e = b->succ; e; e = e->succ_next)\n+\tfor (e = bb->succ; e; e = e->succ_next)\n \t  if (!e->dest->aux && e->dest != EXIT_BLOCK_PTR)\n \t    {\n \t      *qin++ = e->dest;\n@@ -627,9 +623,9 @@ compute_nearerout (edge_list, farthest, st_avloc, nearer, nearerout)\n      struct edge_list *edge_list;\n      sbitmap *farthest, *st_avloc, *nearer, *nearerout;\n {\n-  int bb, num_edges, i;\n+  int num_edges, i;\n   edge e;\n-  basic_block *worklist, *tos;\n+  basic_block *worklist, *tos, bb;\n \n   num_edges = NUM_EDGES (edge_list);\n \n@@ -656,29 +652,27 @@ compute_nearerout (edge_list, farthest, st_avloc, nearer, nearerout)\n \n   /* Add all the blocks to the worklist.  This prevents an early exit\n      from the loop given our optimistic initialization of NEARER.  */\n-  for (bb = 0; bb < n_basic_blocks; bb++)\n+  FOR_EACH_BB (bb)\n     {\n-      basic_block b = BASIC_BLOCK (bb);\n-      *tos++ = b;\n-      b->aux = b;\n+      *tos++ = bb;\n+      bb->aux = bb;\n     }\n \n   /* Iterate until the worklist is empty.  */\n   while (tos != worklist)\n     {\n       /* Take the first entry off the worklist.  */\n-      basic_block b = *--tos;\n-      b->aux = NULL;\n+      bb = *--tos;\n+      bb->aux = NULL;\n \n       /* Compute the intersection of NEARER for each outgoing edge from B.  */\n-      bb = b->index;\n-      sbitmap_ones (nearerout[bb]);\n-      for (e = b->succ; e != NULL; e = e->succ_next)\n-\tsbitmap_a_and_b (nearerout[bb], nearerout[bb],\n+      sbitmap_ones (nearerout[bb->index]);\n+      for (e = bb->succ; e != NULL; e = e->succ_next)\n+\tsbitmap_a_and_b (nearerout[bb->index], nearerout[bb->index],\n \t\t\t nearer[(size_t) e->aux]);\n \n       /* Calculate NEARER for all incoming edges.  */\n-      for (e = b->pred; e != NULL; e = e->pred_next)\n+      for (e = bb->pred; e != NULL; e = e->pred_next)\n \tif (sbitmap_union_of_diff_cg (nearer[(size_t) e->aux],\n \t\t\t\t      farthest[(size_t) e->aux],\n \t\t\t\t      nearerout[e->dest->index],\n@@ -714,9 +708,10 @@ compute_rev_insert_delete (edge_list, st_avloc, nearer, nearerout,\n      sbitmap *st_avloc, *nearer, *nearerout, *insert, *delete;\n {\n   int x;\n+  basic_block bb;\n \n-  for (x = 0; x < n_basic_blocks; x++)\n-    sbitmap_difference (delete[x], st_avloc[x], nearerout[x]);\n+  FOR_EACH_BB (bb)\n+    sbitmap_difference (delete[bb->index], st_avloc[bb->index], nearerout[bb->index]);\n \n   for (x = 0; x < NUM_EDGES (edge_list); x++)\n     {\n@@ -1019,7 +1014,8 @@ optimize_mode_switching (file)\n      FILE *file;\n {\n   rtx insn;\n-  int bb, e;\n+  int e;\n+  basic_block bb;\n   int need_commit = 0;\n   sbitmap *kill;\n   struct edge_list *edge_list;\n@@ -1087,16 +1083,16 @@ optimize_mode_switching (file)\n       /* Determine what the first use (if any) need for a mode of entity E is.\n \t This will be the mode that is anticipatable for this block.\n \t Also compute the initial transparency settings.  */\n-      for (bb = 0 ; bb < n_basic_blocks; bb++)\n+      FOR_EACH_BB (bb)\n \t{\n \t  struct seginfo *ptr;\n \t  int last_mode = no_mode;\n \t  HARD_REG_SET live_now;\n \n \t  REG_SET_TO_HARD_REG_SET (live_now,\n-\t\t\t\t   BASIC_BLOCK (bb)->global_live_at_start);\n-\t  for (insn = BLOCK_HEAD (bb);\n-\t       insn != NULL && insn != NEXT_INSN (BLOCK_END (bb));\n+\t\t\t\t   bb->global_live_at_start);\n+\t  for (insn = bb->head;\n+\t       insn != NULL && insn != NEXT_INSN (bb->end);\n \t       insn = NEXT_INSN (insn))\n \t    {\n \t      if (INSN_P (insn))\n@@ -1107,9 +1103,9 @@ optimize_mode_switching (file)\n \t\t  if (mode != no_mode && mode != last_mode)\n \t\t    {\n \t\t      last_mode = mode;\n-\t\t      ptr = new_seginfo (mode, insn, bb, live_now);\n-\t\t      add_seginfo (info + bb, ptr);\n-\t\t      RESET_BIT (transp[bb], j);\n+\t\t      ptr = new_seginfo (mode, insn, bb->index, live_now);\n+\t\t      add_seginfo (info + bb->index, ptr);\n+\t\t      RESET_BIT (transp[bb->index], j);\n \t\t    }\n \n \t\t  /* Update LIVE_NOW.  */\n@@ -1124,12 +1120,12 @@ optimize_mode_switching (file)\n \t\t}\n \t    }\n \n-\t  info[bb].computing = last_mode;\n+\t  info[bb->index].computing = last_mode;\n \t  /* Check for blocks without ANY mode requirements.  */\n \t  if (last_mode == no_mode)\n \t    {\n-\t      ptr = new_seginfo (no_mode, insn, bb, live_now);\n-\t      add_seginfo (info + bb, ptr);\n+\t      ptr = new_seginfo (no_mode, insn, bb->index, live_now);\n+\t      add_seginfo (info + bb->index, ptr);\n \t    }\n \t}\n #ifdef NORMAL_MODE\n@@ -1142,13 +1138,13 @@ optimize_mode_switching (file)\n \n \t    for (eg = ENTRY_BLOCK_PTR->succ; eg; eg = eg->succ_next)\n \t      {\n-\t\tbb = eg->dest->index;\n+\t\tbb = eg->dest;\n \n \t        /* By always making this nontransparent, we save\n \t\t   an extra check in make_preds_opaque.  We also\n \t\t   need this to avoid confusing pre_edge_lcm when\n \t\t   antic is cleared but transp and comp are set.  */\n-\t\tRESET_BIT (transp[bb], j);\n+\t\tRESET_BIT (transp[bb->index], j);\n \n \t\t/* If the block already has MODE, pretend it\n \t\t   has none (because we don't need to set it),\n@@ -1166,7 +1162,7 @@ optimize_mode_switching (file)\n \t\t  }\n \t      }\n \n-\t    bb = n_basic_blocks - 1;\n+\t    bb = EXIT_BLOCK_PTR;\n \t    info[bb].seginfo->mode = mode;\n \t  }\n       }\n@@ -1186,21 +1182,21 @@ optimize_mode_switching (file)\n \t  int m = current_mode[j] = MODE_PRIORITY_TO_MODE (entity_map[j], i);\n \t  struct bb_info *info = bb_info[j];\n \n-\t  for (bb = 0 ; bb < n_basic_blocks; bb++)\n+\t  FOR_EACH_BB (bb)\n \t    {\n-\t      if (info[bb].seginfo->mode == m)\n-\t\tSET_BIT (antic[bb], j);\n+\t      if (info[bb->index].seginfo->mode == m)\n+\t\tSET_BIT (antic[bb->index], j);\n \n-\t      if (info[bb].computing == m)\n-\t\tSET_BIT (comp[bb], j);\n+\t      if (info[bb->index].computing == m)\n+\t\tSET_BIT (comp[bb->index], j);\n \t    }\n \t}\n \n       /* Calculate the optimal locations for the\n \t placement mode switches to modes with priority I.  */\n \n-      for (bb = n_basic_blocks - 1; bb >= 0; bb--)\n-\tsbitmap_not (kill[bb], transp[bb]);\n+      FOR_EACH_BB (bb)\n+\tsbitmap_not (kill[bb->index], transp[bb->index]);\n       edge_list = pre_edge_lcm (file, 1, transp, comp, antic,\n \t\t\t\tkill, &insert, &delete);\n \n@@ -1279,12 +1275,12 @@ optimize_mode_switching (file)\n \t\t}\n \t    }\n \n-\t  for (bb = n_basic_blocks - 1; bb >= 0; bb--)\n-\t    if (TEST_BIT (delete[bb], j))\n+\t  FOR_EACH_BB_REVERSE (bb)\n+\t    if (TEST_BIT (delete[bb->index], j))\n \t      {\n-\t\tmake_preds_opaque (BASIC_BLOCK (bb), j);\n+\t\tmake_preds_opaque (bb, j);\n \t\t/* Cancel the 'deleted' mode set.  */\n-\t\tbb_info[j][bb].seginfo->mode = no_mode;\n+\t\tbb_info[j][bb->index].seginfo->mode = no_mode;\n \t      }\n \t}\n \n@@ -1349,10 +1345,10 @@ optimize_mode_switching (file)\n \t}\n #endif\n \n-      for (bb = n_basic_blocks - 1; bb >= 0; bb--)\n+      FOR_EACH_BB_REVERSE (bb)\n \t{\n \t  struct seginfo *ptr, *next;\n-\t  for (ptr = bb_info[j][bb].seginfo; ptr; ptr = next)\n+\t  for (ptr = bb_info[j][bb->index].seginfo; ptr; ptr = next)\n \t    {\n \t      next = ptr->next;\n \t      if (ptr->mode != no_mode)"}, {"sha": "dea22dd869e4f6a7d0a3a0044c4419c928f9012b", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -336,8 +336,9 @@ alloc_qty (regno, mode, size, birth)\n int\n local_alloc ()\n {\n-  int b, i;\n+  int i;\n   int max_qty;\n+  basic_block b;\n \n   /* We need to keep track of whether or not we recorded a LABEL_REF so\n      that we know if the jump optimizer needs to be rerun.  */\n@@ -394,7 +395,7 @@ local_alloc ()\n \n   /* Allocate each block's local registers, block by block.  */\n \n-  for (b = 0; b < n_basic_blocks; b++)\n+  FOR_EACH_BB (b)\n     {\n       /* NEXT_QTY indicates which elements of the `qty_...'\n \t vectors might need to be initialized because they were used\n@@ -426,7 +427,7 @@ local_alloc ()\n \n       next_qty = 0;\n \n-      block_alloc (b);\n+      block_alloc (b->index);\n     }\n \n   free (qty);\n@@ -815,7 +816,7 @@ static void\n update_equiv_regs ()\n {\n   rtx insn;\n-  int block;\n+  basic_block bb;\n   int loop_depth;\n   regset_head cleared_regs;\n   int clear_regnos = 0;\n@@ -828,9 +829,8 @@ update_equiv_regs ()\n   /* Scan the insns and find which registers have equivalences.  Do this\n      in a separate scan of the insns because (due to -fcse-follow-jumps)\n      a register can be set below its use.  */\n-  for (block = 0; block < n_basic_blocks; block++)\n+  FOR_EACH_BB (bb)\n     {\n-      basic_block bb = BASIC_BLOCK (block);\n       loop_depth = bb->loop_depth;\n \n       for (insn = bb->head; insn != NEXT_INSN (bb->end); insn = NEXT_INSN (insn))\n@@ -1044,10 +1044,8 @@ update_equiv_regs ()\n      within the same loop (or in an inner loop), then move the register\n      initialization just before the use, so that they are in the same\n      basic block.  */\n-  for (block = n_basic_blocks - 1; block >= 0; block--)\n+  FOR_EACH_BB_REVERSE (bb)\n     {\n-      basic_block bb = BASIC_BLOCK (block);\n-\n       loop_depth = bb->loop_depth;\n       for (insn = bb->end; insn != PREV_INSN (bb->head); insn = PREV_INSN (insn))\n \t{\n@@ -1139,12 +1137,12 @@ update_equiv_regs ()\n \n \t\t      XEXP (reg_equiv[regno].init_insns, 0) = new_insn;\n \n-\t\t      REG_BASIC_BLOCK (regno) = block >= 0 ? block : 0;\n+\t\t      REG_BASIC_BLOCK (regno) = bb->index;\n \t\t      REG_N_CALLS_CROSSED (regno) = 0;\n \t\t      REG_LIVE_LENGTH (regno) = 2;\n \n-\t\t      if (block >= 0 && insn == BLOCK_HEAD (block))\n-\t\t\tBLOCK_HEAD (block) = PREV_INSN (insn);\n+\t\t      if (insn == bb->head)\n+\t\t\tbb->head = PREV_INSN (insn);\n \n \t\t      /* Remember to clear REGNO from all basic block's live\n \t\t\t info.  */\n@@ -1159,24 +1157,22 @@ update_equiv_regs ()\n   /* Clear all dead REGNOs from all basic block's live info.  */\n   if (clear_regnos)\n     {\n-      int j, l;\n+      int j;\n       if (clear_regnos > 8)\n         {\n-\t  for (l = 0; l < n_basic_blocks; l++)\n+\t  FOR_EACH_BB (bb)\n \t    {\n-\t      AND_COMPL_REG_SET (BASIC_BLOCK (l)->global_live_at_start,\n-\t                         &cleared_regs);\n-\t      AND_COMPL_REG_SET (BASIC_BLOCK (l)->global_live_at_end,\n-\t                         &cleared_regs);\n+\t      AND_COMPL_REG_SET (bb->global_live_at_start, &cleared_regs);\n+\t      AND_COMPL_REG_SET (bb->global_live_at_end, &cleared_regs);\n \t    }\n \t}\n       else\n         EXECUTE_IF_SET_IN_REG_SET (&cleared_regs, 0, j,\n           {\n-\t    for (l = 0; l < n_basic_blocks; l++)\n+\t    FOR_EACH_BB (bb)\n \t      {\n-\t        CLEAR_REGNO_REG_SET (BASIC_BLOCK (l)->global_live_at_start, j);\n-\t        CLEAR_REGNO_REG_SET (BASIC_BLOCK (l)->global_live_at_end, j);\n+\t        CLEAR_REGNO_REG_SET (bb->global_live_at_start, j);\n+\t        CLEAR_REGNO_REG_SET (bb->global_live_at_end, j);\n \t      }\n \t  });\n     }"}, {"sha": "4f53a9932eaa0eddcedbe02c7fd345d709215e41", "filename": "gcc/predict.c", "status": "modified", "additions": 43, "deletions": 77, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -409,6 +409,7 @@ estimate_probability (loops_info)\n      struct loops *loops_info;\n {\n   sbitmap *dominators, *post_dominators;\n+  basic_block bb;\n   int i;\n \n   dominators = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n@@ -420,15 +421,14 @@ estimate_probability (loops_info)\n      natural loop.  */\n   for (i = 0; i < loops_info->num; i++)\n     {\n-      int j;\n       int exits;\n       struct loop *loop = &loops_info->array[i];\n \n       flow_loop_scan (loops_info, loop, LOOP_EXIT_EDGES);\n       exits = loop->num_exits;\n \n-      for (j = loop->first->index; j <= loop->last->index; ++j)\n-\tif (TEST_BIT (loop->nodes, j))\n+      FOR_BB_BETWEEN (bb, loop->first, loop->last->next_bb, next_bb)\n+\tif (TEST_BIT (loop->nodes, bb->index))\n \t  {\n \t    int header_found = 0;\n \t    edge e;\n@@ -437,12 +437,12 @@ estimate_probability (loops_info)\n \t     statements construct loops via \"non-loop\" constructs\n \t     in the source language and are better to be handled\n \t     separately.  */\n-\t  if (predicted_by_p (BASIC_BLOCK (j), PRED_CONTINUE))\n+\t  if (predicted_by_p (bb, PRED_CONTINUE))\n \t    continue;\n \n \t    /* Loop branch heuristics - predict an edge back to a\n \t       loop's head as taken.  */\n-\t    for (e = BASIC_BLOCK(j)->succ; e; e = e->succ_next)\n+\t    for (e = bb->succ; e; e = e->succ_next)\n \t      if (e->dest == loop->header\n \t\t  && e->src == loop->latch)\n \t\t{\n@@ -453,7 +453,7 @@ estimate_probability (loops_info)\n \t    /* Loop exit heuristics - predict an edge exiting the loop if the\n \t       conditinal has no loop header successors as not taken.  */\n \t    if (!header_found)\n-\t      for (e = BASIC_BLOCK(j)->succ; e; e = e->succ_next)\n+\t      for (e = bb->succ; e; e = e->succ_next)\n \t\tif (e->dest->index < 0\n \t\t    || !TEST_BIT (loop->nodes, e->dest->index))\n \t\t  predict_edge\n@@ -465,9 +465,8 @@ estimate_probability (loops_info)\n     }\n \n   /* Attempt to predict conditional jumps using a number of heuristics.  */\n-  for (i = 0; i < n_basic_blocks; i++)\n+  FOR_EACH_BB (bb)\n     {\n-      basic_block bb = BASIC_BLOCK (i);\n       rtx last_insn = bb->end;\n       rtx cond, earliest;\n       edge e;\n@@ -604,11 +603,11 @@ estimate_probability (loops_info)\n     }\n \n   /* Attach the combined probability to each conditional jump.  */\n-  for (i = 0; i < n_basic_blocks; i++)\n-    if (GET_CODE (BLOCK_END (i)) == JUMP_INSN\n-\t&& any_condjump_p (BLOCK_END (i))\n-\t&& BASIC_BLOCK (i)->succ->succ_next != NULL)\n-      combine_predictions_for_insn (BLOCK_END (i), BASIC_BLOCK (i));\n+  FOR_EACH_BB (bb)\n+    if (GET_CODE (bb->end) == JUMP_INSN\n+\t&& any_condjump_p (bb->end)\n+\t&& bb->succ->succ_next != NULL)\n+      combine_predictions_for_insn (bb->end, bb);\n \n   sbitmap_vector_free (post_dominators);\n   sbitmap_vector_free (dominators);\n@@ -834,7 +833,7 @@ process_note_predictions (bb, heads, dominators, post_dominators)\n void\n note_prediction_to_br_prob ()\n {\n-  int i;\n+  basic_block bb;\n   sbitmap *post_dominators;\n   int *dominators, *heads;\n \n@@ -854,11 +853,8 @@ note_prediction_to_br_prob ()\n \n   /* Process all prediction notes.  */\n \n-  for (i = 0; i < n_basic_blocks; ++i)\n-    {\n-      basic_block bb = BASIC_BLOCK (i);\n-      process_note_predictions (bb, heads, dominators, post_dominators);\n-    }\n+  FOR_EACH_BB (bb)\n+    process_note_predictions (bb, heads, dominators, post_dominators);\n \n   sbitmap_vector_free (post_dominators);\n   free (dominators);\n@@ -906,17 +902,15 @@ static void\n propagate_freq (head)\n      basic_block head;\n {\n-  basic_block bb = head;\n-  basic_block last = bb;\n+  basic_block bb;\n+  basic_block last;\n   edge e;\n   basic_block nextbb;\n-  int n;\n \n   /* For each basic block we need to visit count number of his predecessors\n      we need to visit first.  */\n-  for (n = 0; n < n_basic_blocks; n++)\n+  FOR_EACH_BB (bb)\n     {\n-      basic_block bb = BASIC_BLOCK (n);\n       if (BLOCK_INFO (bb)->tovisit)\n \t{\n \t  int count = 0;\n@@ -934,7 +928,8 @@ propagate_freq (head)\n     }\n \n   memcpy (&BLOCK_INFO (head)->frequency, &real_one, sizeof (real_one));\n-  for (; bb; bb = nextbb)\n+  last = head;\n+  for (bb = head; bb; bb = nextbb)\n     {\n       REAL_VALUE_TYPE cyclic_probability, frequency;\n \n@@ -1077,24 +1072,13 @@ static void\n counts_to_freqs ()\n {\n   HOST_WIDEST_INT count_max = 1;\n-  int i;\n+  basic_block bb;\n \n-  for (i = 0; i < n_basic_blocks; i++)\n-    count_max = MAX (BASIC_BLOCK (i)->count, count_max);\n+  FOR_EACH_BB (bb)\n+    count_max = MAX (bb->count, count_max);\n \n-  for (i = -2; i < n_basic_blocks; i++)\n-    {\n-      basic_block bb;\n-\n-      if (i == -2)\n-\tbb = ENTRY_BLOCK_PTR;\n-      else if (i == -1)\n-\tbb = EXIT_BLOCK_PTR;\n-      else\n-\tbb = BASIC_BLOCK (i);\n-\n-      bb->frequency = (bb->count * BB_FREQ_MAX + count_max / 2) / count_max;\n-    }\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+    bb->frequency = (bb->count * BB_FREQ_MAX + count_max / 2) / count_max;\n }\n \n /* Return true if function is likely to be expensive, so there is no point to\n@@ -1107,7 +1091,7 @@ expensive_function_p (threshold)\n \tint threshold;\n {\n   unsigned int sum = 0;\n-  int i;\n+  basic_block bb;\n   unsigned int limit;\n \n   /* We can not compute accurately for large thresholds due to scaled\n@@ -1123,9 +1107,8 @@ expensive_function_p (threshold)\n \n   /* Maximally BB_FREQ_MAX^2 so overflow won't happen.  */\n   limit = ENTRY_BLOCK_PTR->frequency * threshold;\n-  for (i = 0; i < n_basic_blocks; i++)\n+  FOR_EACH_BB (bb)\n     {\n-      basic_block bb = BASIC_BLOCK (i);\n       rtx insn;\n \n       for (insn = bb->head; insn != NEXT_INSN (bb->end);\n@@ -1147,7 +1130,7 @@ static void\n estimate_bb_frequencies (loops)\n      struct loops *loops;\n {\n-  int i;\n+  basic_block bb;\n   REAL_VALUE_TYPE freq_max;\n   enum machine_mode double_mode = TYPE_MODE (double_type_node);\n \n@@ -1169,28 +1152,28 @@ estimate_bb_frequencies (loops)\n       mark_dfs_back_edges ();\n       /* Fill in the probability values in flowgraph based on the REG_BR_PROB\n          notes.  */\n-      for (i = 0; i < n_basic_blocks; i++)\n+      FOR_EACH_BB (bb)\n \t{\n-\t  rtx last_insn = BLOCK_END (i);\n+\t  rtx last_insn = bb->end;\n \n \t  if (GET_CODE (last_insn) != JUMP_INSN || !any_condjump_p (last_insn)\n \t      /* Avoid handling of conditional jumps jumping to fallthru edge.  */\n-\t      || BASIC_BLOCK (i)->succ->succ_next == NULL)\n+\t      || bb->succ->succ_next == NULL)\n \t    {\n \t      /* We can predict only conditional jumps at the moment.\n \t         Expect each edge to be equally probable.\n \t         ?? In the future we want to make abnormal edges improbable.  */\n \t      int nedges = 0;\n \t      edge e;\n \n-\t      for (e = BASIC_BLOCK (i)->succ; e; e = e->succ_next)\n+\t      for (e = bb->succ; e; e = e->succ_next)\n \t\t{\n \t\t  nedges++;\n \t\t  if (e->probability != 0)\n \t\t    break;\n \t\t}\n \t      if (!e)\n-\t\tfor (e = BASIC_BLOCK (i)->succ; e; e = e->succ_next)\n+\t\tfor (e = bb->succ; e; e = e->succ_next)\n \t\t  e->probability = (REG_BR_PROB_BASE + nedges / 2) / nedges;\n \t    }\n \t}\n@@ -1200,22 +1183,13 @@ estimate_bb_frequencies (loops)\n       /* Set up block info for each basic block.  */\n       alloc_aux_for_blocks (sizeof (struct block_info_def));\n       alloc_aux_for_edges (sizeof (struct edge_info_def));\n-      for (i = -2; i < n_basic_blocks; i++)\n+      FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n \t{\n \t  edge e;\n-\t  basic_block bb;\n-\n-\t  if (i == -2)\n-\t    bb = ENTRY_BLOCK_PTR;\n-\t  else if (i == -1)\n-\t    bb = EXIT_BLOCK_PTR;\n-\t  else\n-\t    bb = BASIC_BLOCK (i);\n \n \t  BLOCK_INFO (bb)->tovisit = 0;\n \t  for (e = bb->succ; e; e = e->succ_next)\n \t    {\n-\n \t      REAL_VALUE_FROM_INT (EDGE_INFO (e)->back_edge_prob,\n \t\t\t\t   e->probability, 0, double_mode);\n \t      REAL_ARITHMETIC (EDGE_INFO (e)->back_edge_prob,\n@@ -1229,32 +1203,24 @@ estimate_bb_frequencies (loops)\n       estimate_loops_at_level (loops->tree_root);\n \n       /* Now fake loop around whole function to finalize probabilities.  */\n-      for (i = 0; i < n_basic_blocks; i++)\n-\tBLOCK_INFO (BASIC_BLOCK (i))->tovisit = 1;\n+      FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+\tBLOCK_INFO (bb)->tovisit = 1;\n \n       BLOCK_INFO (ENTRY_BLOCK_PTR)->tovisit = 1;\n       BLOCK_INFO (EXIT_BLOCK_PTR)->tovisit = 1;\n       propagate_freq (ENTRY_BLOCK_PTR);\n \n       memcpy (&freq_max, &real_zero, sizeof (real_zero));\n-      for (i = 0; i < n_basic_blocks; i++)\n+      FOR_EACH_BB (bb)\n \tif (REAL_VALUES_LESS\n-\t    (freq_max, BLOCK_INFO (BASIC_BLOCK (i))->frequency))\n-\t  memcpy (&freq_max, &BLOCK_INFO (BASIC_BLOCK (i))->frequency,\n+\t    (freq_max, BLOCK_INFO (bb)->frequency))\n+\t  memcpy (&freq_max, &BLOCK_INFO (bb)->frequency,\n \t\t  sizeof (freq_max));\n \n-      for (i = -2; i < n_basic_blocks; i++)\n+      FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n \t{\n-\t  basic_block bb;\n \t  REAL_VALUE_TYPE tmp;\n \n-\t  if (i == -2)\n-\t    bb = ENTRY_BLOCK_PTR;\n-\t  else if (i == -1)\n-\t    bb = EXIT_BLOCK_PTR;\n-\t  else\n-\t    bb = BASIC_BLOCK (i);\n-\n \t  REAL_ARITHMETIC (tmp, MULT_EXPR, BLOCK_INFO (bb)->frequency,\n \t\t\t   real_bb_freq_max);\n \t  REAL_ARITHMETIC (tmp, RDIV_EXPR, tmp, freq_max);\n@@ -1274,14 +1240,14 @@ estimate_bb_frequencies (loops)\n static void\n compute_function_frequency ()\n {\n-  int i;\n+  basic_block bb;\n+\n   if (!profile_info.count_profiles_merged\n       || !flag_branch_probabilities)\n     return;\n   cfun->function_frequency = FUNCTION_FREQUENCY_UNLIKELY_EXECUTED;\n-  for (i = 0; i < n_basic_blocks; i++)\n+  FOR_EACH_BB (bb)\n     {\n-      basic_block bb = BASIC_BLOCK (i);\n       if (maybe_hot_bb_p (bb))\n \t{\n \t  cfun->function_frequency = FUNCTION_FREQUENCY_HOT;"}, {"sha": "10f2afba6d2f19f4d608901a81d42aa2e13f38ae", "filename": "gcc/profile.c", "status": "modified", "additions": 24, "deletions": 40, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -137,14 +137,13 @@ static void\n instrument_edges (el)\n      struct edge_list *el;\n {\n-  int i;\n   int num_instr_edges = 0;\n   int num_edges = NUM_EDGES (el);\n+  basic_block bb;\n   remove_fake_edges ();\n \n-  for (i = 0; i < n_basic_blocks + 2; i++)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n     {\n-      basic_block bb = GCOV_INDEX_TO_BB (i);\n       edge e = bb->succ;\n       while (e)\n \t{\n@@ -216,8 +215,8 @@ static gcov_type *\n get_exec_counts ()\n {\n   int num_edges = 0;\n-  int i;\n-  int okay = 1;\n+  basic_block bb;\n+  int okay = 1, i;\n   int mismatch = 0;\n   gcov_type *profile;\n   char *function_name_buffer;\n@@ -233,15 +232,12 @@ get_exec_counts ()\n \n   /* Count the edges to be (possibly) instrumented.  */\n \n-  for (i = 0; i < n_basic_blocks + 2; i++)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n     {\n-      basic_block bb = GCOV_INDEX_TO_BB (i);\n       edge e;\n       for (e = bb->succ; e; e = e->succ_next)\n \tif (!EDGE_INFO (e)->ignore && !EDGE_INFO (e)->on_tree)\n-\t  {\n-\t    num_edges++;\n-\t  }\n+\t  num_edges++;\n     }\n \n   /* now read and combine all matching profiles.  */\n@@ -382,6 +378,7 @@ get_exec_counts ()\n static void\n compute_branch_probabilities ()\n {\n+  basic_block bb;\n   int i;\n   int num_edges = 0;\n   int changes;\n@@ -395,9 +392,8 @@ compute_branch_probabilities ()\n   /* Attach extra info block to each bb.  */\n \n   alloc_aux_for_blocks (sizeof (struct bb_info));\n-  for (i = 0; i < n_basic_blocks + 2; i++)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n     {\n-      basic_block bb = GCOV_INDEX_TO_BB (i);\n       edge e;\n \n       for (e = bb->succ; e; e = e->succ_next)\n@@ -418,9 +414,8 @@ compute_branch_probabilities ()\n   /* The first count in the .da file is the number of times that the function\n      was entered.  This is the exec_count for block zero.  */\n \n-  for (i = 0; i < n_basic_blocks + 2; i++)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n     {\n-      basic_block bb = GCOV_INDEX_TO_BB (i);\n       edge e;\n       for (e = bb->succ; e; e = e->succ_next)\n \tif (!EDGE_INFO (e)->ignore && !EDGE_INFO (e)->on_tree)\n@@ -472,9 +467,8 @@ compute_branch_probabilities ()\n     {\n       passes++;\n       changes = 0;\n-      for (i = n_basic_blocks + 1; i >= 0; i--)\n+      FOR_BB_BETWEEN (bb, EXIT_BLOCK_PTR, NULL, prev_bb)\n \t{\n-\t  basic_block bb = GCOV_INDEX_TO_BB (i);\n \t  struct bb_info *bi = BB_INFO (bb);\n \t  if (! bi->count_valid)\n \t    {\n@@ -569,9 +563,8 @@ compute_branch_probabilities ()\n \n   /* If the graph has been correctly solved, every block will have a\n      succ and pred count of zero.  */\n-  for (i = 0; i < n_basic_blocks; i++)\n+  FOR_EACH_BB (bb)\n     {\n-      basic_block bb = BASIC_BLOCK (i);\n       if (BB_INFO (bb)->succ_count || BB_INFO (bb)->pred_count)\n \tabort ();\n     }\n@@ -584,9 +577,8 @@ compute_branch_probabilities ()\n   num_never_executed = 0;\n   num_branches = 0;\n \n-  for (i = 0; i <= n_basic_blocks + 1; i++)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n     {\n-      basic_block bb = GCOV_INDEX_TO_BB (i);\n       edge e;\n       gcov_type total;\n       rtx note;\n@@ -702,12 +694,10 @@ static long\n compute_checksum ()\n {\n   long chsum = 0;\n-  int i;\n-\n+  basic_block bb;\n \n-  for (i = 0; i < n_basic_blocks ; i++)\n+  FOR_EACH_BB (bb)\n     {\n-      basic_block bb = BASIC_BLOCK (i);\n       edge e;\n \n       for (e = bb->succ; e; e = e->succ_next)\n@@ -740,6 +730,7 @@ compute_checksum ()\n void\n branch_prob ()\n {\n+  basic_block bb;\n   int i;\n   int num_edges, ignored_edges;\n   struct edge_list *el;\n@@ -768,11 +759,10 @@ branch_prob ()\n      We also add fake exit edges for each call and asm statement in the\n      basic, since it may not return.  */\n \n-  for (i = 0; i < n_basic_blocks ; i++)\n+  FOR_EACH_BB (bb)\n     {\n       int need_exit_edge = 0, need_entry_edge = 0;\n       int have_exit_edge = 0, have_entry_edge = 0;\n-      basic_block bb = BASIC_BLOCK (i);\n       rtx insn;\n       edge e;\n \n@@ -797,7 +787,7 @@ branch_prob ()\n \t\t{\n \t\t  /* We should not get abort here, as call to setjmp should not\n \t\t     be the very first instruction of function.  */\n-\t\t  if (!i)\n+\t\t  if (bb == ENTRY_BLOCK_PTR)\n \t\t    abort ();\n \t\t  make_edge (ENTRY_BLOCK_PTR, bb, EDGE_FAKE);\n \t\t}\n@@ -864,10 +854,8 @@ branch_prob ()\n      GCOV utility.  */\n   if (flag_test_coverage)\n     {\n-      int i = 0;\n-      for (i = 0 ; i < n_basic_blocks; i++)\n+      FOR_EACH_BB (bb)\n \t{\n-\t  basic_block bb = BASIC_BLOCK (i);\n \t  rtx insn = bb->head;\n \t  static int ignore_next_note = 0;\n \n@@ -976,9 +964,8 @@ branch_prob ()\n       __write_long (n_basic_blocks + 2, bbg_file, 4);\n       __write_long (num_edges - ignored_edges + 1, bbg_file, 4);\n \n-      for (i = 0; i < n_basic_blocks + 1; i++)\n+      FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n \t{\n-\t  basic_block bb = GCOV_INDEX_TO_BB (i);\n \t  edge e;\n \t  long count = 0;\n \n@@ -1088,12 +1075,11 @@ find_spanning_tree (el)\n {\n   int i;\n   int num_edges = NUM_EDGES (el);\n+  basic_block bb;\n \n   /* We use aux field for standard union-find algorithm.  */\n-  EXIT_BLOCK_PTR->aux = EXIT_BLOCK_PTR;\n-  ENTRY_BLOCK_PTR->aux = ENTRY_BLOCK_PTR;\n-  for (i = 0; i < n_basic_blocks; i++)\n-    BASIC_BLOCK (i)->aux = BASIC_BLOCK (i);\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+    bb->aux = bb;\n \n   /* Add fake edge exit to entry we can't instrument.  */\n   union_groups (EXIT_BLOCK_PTR, ENTRY_BLOCK_PTR);\n@@ -1149,10 +1135,8 @@ find_spanning_tree (el)\n \t}\n     }\n \n-  EXIT_BLOCK_PTR->aux = NULL;\n-  ENTRY_BLOCK_PTR->aux = NULL;\n-  for (i = 0; i < n_basic_blocks; i++)\n-    BASIC_BLOCK (i)->aux = NULL;\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+    bb->aux = NULL;\n }\n \f\n /* Perform file-level initialization for branch-prob processing.  */"}, {"sha": "0efc6e3fdd8c2067ed8738ce7b7bb956a706eb5e", "filename": "gcc/recog.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -2727,15 +2727,14 @@ split_all_insns (upd_life)\n {\n   sbitmap blocks;\n   int changed;\n-  int i;\n+  basic_block bb;\n \n   blocks = sbitmap_alloc (n_basic_blocks);\n   sbitmap_zero (blocks);\n   changed = 0;\n \n-  for (i = n_basic_blocks - 1; i >= 0; --i)\n+  FOR_EACH_BB_REVERSE (bb)\n     {\n-      basic_block bb = BASIC_BLOCK (i);\n       rtx insn, next;\n       bool finish = false;\n \n@@ -2756,7 +2755,7 @@ split_all_insns (upd_life)\n \n \t      while (GET_CODE (last) == BARRIER)\n \t\tlast = PREV_INSN (last);\n-\t      SET_BIT (blocks, i);\n+\t      SET_BIT (blocks, bb->index);\n \t      changed = 1;\n \t      insn = last;\n \t    }\n@@ -2999,7 +2998,8 @@ peephole2_optimize (dump_file)\n   regset_head rs_heads[MAX_INSNS_PER_PEEP2 + 2];\n   rtx insn, prev;\n   regset live;\n-  int i, b;\n+  int i;\n+  basic_block bb;\n #ifdef HAVE_conditional_execution\n   sbitmap blocks;\n   bool changed;\n@@ -3020,9 +3020,8 @@ peephole2_optimize (dump_file)\n   count_or_remove_death_notes (NULL, 1);\n #endif\n \n-  for (b = n_basic_blocks - 1; b >= 0; --b)\n+  FOR_EACH_BB_REVERSE (bb)\n     {\n-      basic_block bb = BASIC_BLOCK (b);\n       struct propagate_block_info *pbi;\n \n       /* Indicate that all slots except the last holds invalid data.  */\n@@ -3201,7 +3200,7 @@ peephole2_optimize (dump_file)\n \t\t     death data structures are not so self-contained.\n \t\t     So record that we've made a modification to this\n \t\t     block and update life information at the end.  */\n-\t\t  SET_BIT (blocks, b);\n+\t\t  SET_BIT (blocks, bb->index);\n \t\t  changed = true;\n \n \t\t  for (i = 0; i < MAX_INSNS_PER_PEEP2 + 1; ++i)"}, {"sha": "a938b7d712344ef142321883c0f21073704393ba", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -418,6 +418,7 @@ reg_to_stack (first, file)\n      rtx first;\n      FILE *file;\n {\n+  basic_block bb;\n   int i;\n   int max_uid;\n \n@@ -451,10 +452,9 @@ reg_to_stack (first, file)\n \n   /* Set up block info for each basic block.  */\n   alloc_aux_for_blocks (sizeof (struct block_info_def));\n-  for (i = n_basic_blocks - 1; i >= 0; --i)\n+  FOR_EACH_BB_REVERSE (bb)\n     {\n       edge e;\n-      basic_block bb = BASIC_BLOCK (i);\n       for (e = bb->pred; e; e=e->pred_next)\n \tif (!(e->flags & EDGE_DFS_BACK)\n \t    && e->src != ENTRY_BLOCK_PTR)\n@@ -2380,12 +2380,12 @@ print_stack (file, s)\n static int\n convert_regs_entry ()\n {\n-  int inserted = 0, i;\n+  int inserted = 0;\n   edge e;\n+  basic_block block;\n \n-  for (i = n_basic_blocks - 1; i >= 0; --i)\n+  FOR_EACH_BB_REVERSE (block)\n     {\n-      basic_block block = BASIC_BLOCK (i);\n       block_info bi = BLOCK_INFO (block);\n       int reg;\n \n@@ -2813,7 +2813,8 @@ static int\n convert_regs (file)\n      FILE *file;\n {\n-  int inserted, i;\n+  int inserted;\n+  basic_block b;\n   edge e;\n \n   /* Initialize uninitialized registers on function entry.  */\n@@ -2833,9 +2834,8 @@ convert_regs (file)\n \n   /* ??? Process all unreachable blocks.  Though there's no excuse\n      for keeping these even when not optimizing.  */\n-  for (i = 0; i < n_basic_blocks; ++i)\n+  FOR_EACH_BB (b)\n     {\n-      basic_block b = BASIC_BLOCK (i);\n       block_info bi = BLOCK_INFO (b);\n \n       if (! bi->done)"}, {"sha": "57672baf3c4d867e9754b0fdf236526f02dc9aad", "filename": "gcc/regclass.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -1127,10 +1127,10 @@ scan_one_insn (insn, pass)\n \t INSN could not be at the beginning of that block.  */\n       if (previnsn == 0 || GET_CODE (previnsn) == JUMP_INSN)\n \t{\n-\t  int b;\n-\t  for (b = 0; b < n_basic_blocks; b++)\n-\t    if (insn == BLOCK_HEAD (b))\n-\t      BLOCK_HEAD (b) = newinsn;\n+\t  basic_block b;\n+\t  FOR_EACH_BB (b)\n+\t    if (insn == b->head)\n+\t      b->head = newinsn;\n \t}\n \n       /* This makes one more setting of new insns's dest.  */\n@@ -1255,7 +1255,7 @@ regclass (f, nregs, dump)\n \n   for (pass = 0; pass <= flag_expensive_optimizations; pass++)\n     {\n-      int index;\n+      basic_block bb;\n \n       if (dump)\n \tfprintf (dump, \"\\n\\nPass %i\\n\\n\",pass);\n@@ -1277,10 +1277,8 @@ regclass (f, nregs, dump)\n \t    insn = scan_one_insn (insn, pass);\n \t}\n       else\n-\tfor (index = 0; index < n_basic_blocks; index++)\n+\tFOR_EACH_BB (bb)\n \t  {\n-\t    basic_block bb = BASIC_BLOCK (index);\n-\n \t    /* Show that an insn inside a loop is likely to be executed three\n \t       times more than insns outside a loop.  This is much more\n \t       aggressive than the assumptions made elsewhere and is being"}, {"sha": "da5042dc26d937c27bf8ecac478fa4d3cfc7c27b", "filename": "gcc/regmove.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -223,7 +223,7 @@ mark_flags_life_zones (flags)\n {\n   int flags_regno;\n   int flags_nregs;\n-  int block;\n+  basic_block block;\n \n #ifdef HAVE_cc0\n   /* If we found a flags register on a cc0 host, bail.  */\n@@ -254,13 +254,13 @@ mark_flags_life_zones (flags)\n   flags_set_1_rtx = flags;\n \n   /* Process each basic block.  */\n-  for (block = n_basic_blocks - 1; block >= 0; block--)\n+  FOR_EACH_BB_REVERSE (block)\n     {\n       rtx insn, end;\n       int live;\n \n-      insn = BLOCK_HEAD (block);\n-      end = BLOCK_END (block);\n+      insn = block->head;\n+      end = block->end;\n \n       /* Look out for the (unlikely) case of flags being live across\n \t basic block boundaries.  */\n@@ -269,7 +269,7 @@ mark_flags_life_zones (flags)\n       {\n \tint i;\n \tfor (i = 0; i < flags_nregs; ++i)\n-\t  live |= REGNO_REG_SET_P (BASIC_BLOCK (block)->global_live_at_start,\n+\t  live |= REGNO_REG_SET_P (block->global_live_at_start,\n \t\t\t\t   flags_regno + i);\n       }\n #endif\n@@ -1061,6 +1061,7 @@ regmove_optimize (f, nregs, regmove_dump_file)\n   int pass;\n   int i;\n   rtx copy_src, copy_dst;\n+  basic_block bb;\n \n   /* ??? Hack.  Regmove doesn't examine the CFG, and gets mightily\n      confused by non-call exceptions ending blocks.  */\n@@ -1076,8 +1077,8 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \n   regmove_bb_head = (int *) xmalloc (sizeof (int) * (old_max_uid + 1));\n   for (i = old_max_uid; i >= 0; i--) regmove_bb_head[i] = -1;\n-  for (i = 0; i < n_basic_blocks; i++)\n-    regmove_bb_head[INSN_UID (BLOCK_HEAD (i))] = i;\n+  FOR_EACH_BB (bb)\n+    regmove_bb_head[INSN_UID (bb->head)] = bb->index;\n \n   /* A forward/backward pass.  Replace output operands with input operands.  */\n \n@@ -1504,9 +1505,8 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \n   /* In fixup_match_1, some insns may have been inserted after basic block\n      ends.  Fix that here.  */\n-  for (i = 0; i < n_basic_blocks; i++)\n+  FOR_EACH_BB (bb)\n     {\n-      basic_block bb = BASIC_BLOCK (i);\n       rtx end = bb->end;\n       rtx new = end;\n       rtx next = NEXT_INSN (new);\n@@ -2139,10 +2139,10 @@ static int record_stack_memrefs\tPARAMS ((rtx *, void *));\n void\n combine_stack_adjustments ()\n {\n-  int i;\n+  basic_block bb;\n \n-  for (i = 0; i < n_basic_blocks; ++i)\n-    combine_stack_adjustments_for_block (BASIC_BLOCK (i));\n+  FOR_EACH_BB (bb)\n+    combine_stack_adjustments_for_block (bb);\n }\n \n /* Recognize a MEM of the form (sp) or (plus sp const).  */"}, {"sha": "5161a4b50299cee10a68e36ad3d76eef5e67b882", "filename": "gcc/regrename.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -201,25 +201,24 @@ regrename_optimize ()\n {\n   int tick[FIRST_PSEUDO_REGISTER];\n   int this_tick = 0;\n-  int b;\n+  basic_block bb;\n   char *first_obj;\n \n   memset (tick, 0, sizeof tick);\n \n   gcc_obstack_init (&rename_obstack);\n   first_obj = (char *) obstack_alloc (&rename_obstack, 0);\n \n-  for (b = 0; b < n_basic_blocks; b++)\n+  FOR_EACH_BB (bb)\n     {\n-      basic_block bb = BASIC_BLOCK (b);\n       struct du_chain *all_chains = 0;\n       HARD_REG_SET unavailable;\n       HARD_REG_SET regs_seen;\n \n       CLEAR_HARD_REG_SET (unavailable);\n \n       if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"\\nBasic block %d:\\n\", b);\n+\tfprintf (rtl_dump_file, \"\\nBasic block %d:\\n\", bb->index);\n \n       all_chains = build_def_use (bb);\n \n@@ -1726,30 +1725,30 @@ copyprop_hardreg_forward ()\n {\n   struct value_data *all_vd;\n   bool need_refresh;\n-  int b;\n+  basic_block bb, bbp;\n \n   need_refresh = false;\n \n   all_vd = xmalloc (sizeof (struct value_data) * n_basic_blocks);\n \n-  for (b = 0; b < n_basic_blocks; b++)\n+  FOR_EACH_BB (bb)\n     {\n-      basic_block bb = BASIC_BLOCK (b);\n-\n       /* If a block has a single predecessor, that we've already\n \t processed, begin with the value data that was live at\n \t the end of the predecessor block.  */\n       /* ??? Ought to use more intelligent queueing of blocks.  */\n+      if (bb->pred)\n+\tfor (bbp = bb; bbp && bbp != bb->pred->src; bbp = bbp->prev_bb);\n       if (bb->pred\n \t  && ! bb->pred->pred_next\n \t  && ! (bb->pred->flags & (EDGE_ABNORMAL_CALL | EDGE_EH))\n-\t  && bb->pred->src->index != ENTRY_BLOCK\n-\t  && bb->pred->src->index < b)\n-\tall_vd[b] = all_vd[bb->pred->src->index];\n+\t  && bb->pred->src != ENTRY_BLOCK_PTR\n+\t  && bbp)\n+\tall_vd[bb->index] = all_vd[bb->pred->src->index];\n       else\n-\tinit_value_data (all_vd + b);\n+\tinit_value_data (all_vd + bb->index);\n \n-      if (copyprop_hardreg_forward_1 (bb, all_vd + b))\n+      if (copyprop_hardreg_forward_1 (bb, all_vd + bb->index))\n \tneed_refresh = true;\n     }\n "}, {"sha": "685957023c4dcd5addcd4f466bc18aadaed17b18", "filename": "gcc/reload1.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -676,6 +676,7 @@ reload (first, global)\n   int i;\n   rtx insn;\n   struct elim_table *ep;\n+  basic_block bb;\n \n   /* The two pointers used to track the true location of the memory used\n      for label offsets.  */\n@@ -1123,8 +1124,8 @@ reload (first, global)\n      pseudo.  */\n \n   if (! frame_pointer_needed)\n-    for (i = 0; i < n_basic_blocks; i++)\n-      CLEAR_REGNO_REG_SET (BASIC_BLOCK (i)->global_live_at_start,\n+    FOR_EACH_BB (bb)\n+      CLEAR_REGNO_REG_SET (bb->global_live_at_start,\n \t\t\t   HARD_FRAME_POINTER_REGNUM);\n \n   /* Come here (with failure set nonzero) if we can't get enough spill regs\n@@ -8613,6 +8614,7 @@ reload_combine ()\n   int first_index_reg = -1;\n   int last_index_reg = 0;\n   int i;\n+  basic_block bb;\n   unsigned int r;\n   int last_label_ruid;\n   int min_labelno, n_labels;\n@@ -8648,17 +8650,17 @@ reload_combine ()\n   label_live = (HARD_REG_SET *) xmalloc (n_labels * sizeof (HARD_REG_SET));\n   CLEAR_HARD_REG_SET (ever_live_at_start);\n \n-  for (i = n_basic_blocks - 1; i >= 0; i--)\n+  FOR_EACH_BB_REVERSE (bb)\n     {\n-      insn = BLOCK_HEAD (i);\n+      insn = bb->head;\n       if (GET_CODE (insn) == CODE_LABEL)\n \t{\n \t  HARD_REG_SET live;\n \n \t  REG_SET_TO_HARD_REG_SET (live,\n-\t\t\t\t   BASIC_BLOCK (i)->global_live_at_start);\n+\t\t\t\t   bb->global_live_at_start);\n \t  compute_use_by_pseudos (&live,\n-\t\t\t\t  BASIC_BLOCK (i)->global_live_at_start);\n+\t\t\t\t  bb->global_live_at_start);\n \t  COPY_HARD_REG_SET (LABEL_LIVE (insn), live);\n \t  IOR_HARD_REG_SET (ever_live_at_start, live);\n \t}\n@@ -9489,12 +9491,11 @@ copy_eh_notes (insn, x)\n void\n fixup_abnormal_edges ()\n {\n-  int i;\n   bool inserted = false;\n+  basic_block bb;\n \n-  for (i = 0; i < n_basic_blocks; i++)\n+  FOR_EACH_BB (bb)\n     {\n-      basic_block bb = BASIC_BLOCK (i);\n       edge e;\n \n       /* Look for cases we are interested in - an calls or instructions causing"}, {"sha": "644a0312a23c928d61dbee2b8863d97570e351aa", "filename": "gcc/resource.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -133,7 +133,7 @@ find_basic_block (insn, search_limit)\n      rtx insn;\n      int search_limit;\n {\n-  int i;\n+  basic_block bb;\n \n   /* Scan backwards to the previous BARRIER.  Then see if we can find a\n      label that starts a basic block.  Return the basic block number.  */\n@@ -156,9 +156,9 @@ find_basic_block (insn, search_limit)\n        insn && GET_CODE (insn) == CODE_LABEL;\n        insn = next_nonnote_insn (insn))\n     {\n-      for (i = 0; i < n_basic_blocks; i++)\n-\tif (insn == BLOCK_HEAD (i))\n-\t  return i;\n+      FOR_EACH_BB (bb)\n+\tif (insn == bb->head)\n+\t  return bb->index;\n     }\n \n   return -1;"}, {"sha": "fd4556e5fe1fb94ab722ca834a12096eb5edb12b", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -279,7 +279,7 @@ void\n schedule_ebbs (dump_file)\n      FILE *dump_file;\n {\n-  int i;\n+  basic_block bb;\n \n   /* Taking care of this degenerate case makes the rest of\n      this code simpler.  */\n@@ -296,20 +296,19 @@ schedule_ebbs (dump_file)\n   compute_bb_for_insn (get_max_uid ());\n \n   /* Schedule every region in the subroutine.  */\n-  for (i = 0; i < n_basic_blocks; i++)\n+  FOR_EACH_BB (bb)\n     {\n-      rtx head = BASIC_BLOCK (i)->head;\n+      rtx head = bb->head;\n       rtx tail;\n \n       for (;;)\n \t{\n-\t  basic_block b = BASIC_BLOCK (i);\n \t  edge e;\n-\t  tail = b->end;\n-\t  if (b->next_bb == EXIT_BLOCK_PTR\n-\t      || GET_CODE (b->next_bb->head) == CODE_LABEL)\n+\t  tail = bb->end;\n+\t  if (bb->next_bb == EXIT_BLOCK_PTR\n+\t      || GET_CODE (bb->next_bb->head) == CODE_LABEL)\n \t    break;\n-\t  for (e = b->succ; e; e = e->succ_next)\n+\t  for (e = bb->succ; e; e = e->succ_next)\n \t    if ((e->flags & EDGE_FALLTHRU) != 0)\n \t      break;\n \t  if (! e)\n@@ -325,7 +324,7 @@ schedule_ebbs (dump_file)\n \t\t}\n \t    }\n \n-\t  i++;\n+\t  bb = bb->next_bb;\n \t}\n \n       /* Blah.  We should fix the rest of the code not to get confused by"}, {"sha": "9f88dcc459b07e711e244af22cf2840e5a20d385", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 55, "deletions": 50, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -319,7 +319,7 @@ static void free_pending_lists PARAMS ((void));\n static int\n is_cfg_nonregular ()\n {\n-  int b;\n+  basic_block b;\n   rtx insn;\n   RTX_CODE code;\n \n@@ -346,8 +346,8 @@ is_cfg_nonregular ()\n   /* If we have non-jumping insns which refer to labels, then we consider\n      the cfg not well structured.  */\n   /* Check for labels referred to other thn by jumps.  */\n-  for (b = 0; b < n_basic_blocks; b++)\n-    for (insn = BLOCK_HEAD (b);; insn = NEXT_INSN (insn))\n+  FOR_EACH_BB (b)\n+    for (insn = b->head;; insn = NEXT_INSN (insn))\n       {\n \tcode = GET_CODE (insn);\n \tif (GET_RTX_CLASS (code) == 'i' && code != JUMP_INSN)\n@@ -361,7 +361,7 @@ is_cfg_nonregular ()\n \t      return 1;\n \t  }\n \n-\tif (insn == BLOCK_END (b))\n+\tif (insn == b->end)\n \t  break;\n       }\n \n@@ -382,6 +382,7 @@ build_control_flow (edge_list)\n      struct edge_list *edge_list;\n {\n   int i, unreachable, num_edges;\n+  basic_block b;\n \n   /* This already accounts for entry/exit edges.  */\n   num_edges = NUM_EDGES (edge_list);\n@@ -393,10 +394,8 @@ build_control_flow (edge_list)\n      test is redundant with the one in find_rgns, but it's much\n     cheaper to go ahead and catch the trivial case here.  */\n   unreachable = 0;\n-  for (i = 0; i < n_basic_blocks; i++)\n+  FOR_EACH_BB (b)\n     {\n-      basic_block b = BASIC_BLOCK (i);\n-\n       if (b->pred == NULL\n \t  || (b->pred->src == b\n \t      && b->pred->pred_next == NULL))\n@@ -544,17 +543,19 @@ debug_regions ()\n static void\n find_single_block_region ()\n {\n-  int i;\n+  basic_block bb;\n \n-  for (i = 0; i < n_basic_blocks; i++)\n+  nr_regions = 0;\n+\n+  FOR_EACH_BB (bb)\n     {\n-      rgn_bb_table[i] = i;\n-      RGN_NR_BLOCKS (i) = 1;\n-      RGN_BLOCKS (i) = i;\n-      CONTAINING_RGN (i) = i;\n-      BLOCK_TO_BB (i) = 0;\n+      rgn_bb_table[nr_regions] = bb->index;\n+      RGN_NR_BLOCKS (nr_regions) = 1;\n+      RGN_BLOCKS (nr_regions) = nr_regions;\n+      CONTAINING_RGN (bb->index) = nr_regions;\n+      BLOCK_TO_BB (bb->index) = 0;\n+      nr_regions++;\n     }\n-  nr_regions = n_basic_blocks;\n }\n \n /* Update number of blocks and the estimate for number of insns\n@@ -631,6 +632,7 @@ find_rgns (edge_list, dom)\n   int count = 0, sp, idx = 0, current_edge = out_edges[0];\n   int num_bbs, num_insns, unreachable;\n   int too_large_failure;\n+  basic_block bb;\n \n   /* Note if an edge has been passed.  */\n   sbitmap passed;\n@@ -772,8 +774,8 @@ find_rgns (edge_list, dom)\n      the entry node by placing a nonzero value in dfs_nr.  Thus if\n      dfs_nr is zero for any block, then it must be unreachable.  */\n   unreachable = 0;\n-  for (i = 0; i < n_basic_blocks; i++)\n-    if (dfs_nr[i] == 0)\n+  FOR_EACH_BB (bb)\n+    if (dfs_nr[bb->index] == 0)\n       {\n \tunreachable = 1;\n \tbreak;\n@@ -783,8 +785,8 @@ find_rgns (edge_list, dom)\n      to hold degree counts.  */\n   degree = dfs_nr;\n \n-  for (i = 0; i < n_basic_blocks; i++)\n-    degree[i] = 0;\n+  FOR_EACH_BB (bb)\n+    degree[bb->index] = 0;\n   for (i = 0; i < num_edges; i++)\n     {\n       edge e = INDEX_EDGE (edge_list, i);\n@@ -809,12 +811,12 @@ find_rgns (edge_list, dom)\n \n       /* Find blocks which are inner loop headers.  We still have non-reducible\n \t loops to consider at this point.  */\n-      for (i = 0; i < n_basic_blocks; i++)\n+      FOR_EACH_BB (bb)\n \t{\n-\t  if (TEST_BIT (header, i) && TEST_BIT (inner, i))\n+\t  if (TEST_BIT (header, bb->index) && TEST_BIT (inner, bb->index))\n \t    {\n \t      edge e;\n-\t      int j;\n+\t      basic_block jbb;\n \n \t      /* Now check that the loop is reducible.  We do this separate\n \t\t from finding inner loops so that we do not find a reducible\n@@ -827,59 +829,59 @@ find_rgns (edge_list, dom)\n \t\t If there exists a block that is not dominated by the loop\n \t\t header, then the block is reachable from outside the loop\n \t\t and thus the loop is not a natural loop.  */\n-\t      for (j = 0; j < n_basic_blocks; j++)\n+\t      FOR_EACH_BB (jbb)\n \t\t{\n \t\t  /* First identify blocks in the loop, except for the loop\n \t\t     entry block.  */\n-\t\t  if (i == max_hdr[j] && i != j)\n+\t\t  if (bb->index == max_hdr[jbb->index] && bb != jbb)\n \t\t    {\n \t\t      /* Now verify that the block is dominated by the loop\n \t\t\t header.  */\n-\t\t      if (!TEST_BIT (dom[j], i))\n+\t\t      if (!TEST_BIT (dom[jbb->index], bb->index))\n \t\t\tbreak;\n \t\t    }\n \t\t}\n \n \t      /* If we exited the loop early, then I is the header of\n \t\t a non-reducible loop and we should quit processing it\n \t\t now.  */\n-\t      if (j != n_basic_blocks)\n+\t      if (jbb != EXIT_BLOCK_PTR)\n \t\tcontinue;\n \n \t      /* I is a header of an inner loop, or block 0 in a subroutine\n \t\t with no loops at all.  */\n \t      head = tail = -1;\n \t      too_large_failure = 0;\n-\t      loop_head = max_hdr[i];\n+\t      loop_head = max_hdr[bb->index];\n \n \t      /* Decrease degree of all I's successors for topological\n \t\t ordering.  */\n-\t      for (e = BASIC_BLOCK (i)->succ; e; e = e->succ_next)\n+\t      for (e = bb->succ; e; e = e->succ_next)\n \t\tif (e->dest != EXIT_BLOCK_PTR)\n \t\t  --degree[e->dest->index];\n \n \t      /* Estimate # insns, and count # blocks in the region.  */\n \t      num_bbs = 1;\n-\t      num_insns = (INSN_LUID (BLOCK_END (i))\n-\t\t\t   - INSN_LUID (BLOCK_HEAD (i)));\n+\t      num_insns = (INSN_LUID (bb->end)\n+\t\t\t   - INSN_LUID (bb->head));\n \n \t      /* Find all loop latches (blocks with back edges to the loop\n \t\t header) or all the leaf blocks in the cfg has no loops.\n \n \t\t Place those blocks into the queue.  */\n \t      if (no_loops)\n \t\t{\n-\t\t  for (j = 0; j < n_basic_blocks; j++)\n+\t\t  FOR_EACH_BB (jbb)\n \t\t    /* Leaf nodes have only a single successor which must\n \t\t       be EXIT_BLOCK.  */\n-\t\t    if (BASIC_BLOCK (j)->succ\n-\t\t\t&& BASIC_BLOCK (j)->succ->dest == EXIT_BLOCK_PTR\n-\t\t\t&& BASIC_BLOCK (j)->succ->succ_next == NULL)\n+\t\t    if (jbb->succ\n+\t\t\t&& jbb->succ->dest == EXIT_BLOCK_PTR\n+\t\t\t&& jbb->succ->succ_next == NULL)\n \t\t      {\n-\t\t\tqueue[++tail] = j;\n-\t\t\tSET_BIT (in_queue, j);\n+\t\t\tqueue[++tail] = jbb->index;\n+\t\t\tSET_BIT (in_queue, jbb->index);\n \n-\t\t\tif (too_large (j, &num_bbs, &num_insns))\n+\t\t\tif (too_large (jbb->index, &num_bbs, &num_insns))\n \t\t\t  {\n \t\t\t    too_large_failure = 1;\n \t\t\t    break;\n@@ -890,14 +892,14 @@ find_rgns (edge_list, dom)\n \t\t{\n \t\t  edge e;\n \n-\t\t  for (e = BASIC_BLOCK (i)->pred; e; e = e->pred_next)\n+\t\t  for (e = bb->pred; e; e = e->pred_next)\n \t\t    {\n \t\t      if (e->src == ENTRY_BLOCK_PTR)\n \t\t\tcontinue;\n \n \t\t      node = e->src->index;\n \n-\t\t      if (max_hdr[node] == loop_head && node != i)\n+\t\t      if (max_hdr[node] == loop_head && node != bb->index)\n \t\t\t{\n \t\t\t  /* This is a loop latch.  */\n \t\t\t  queue[++tail] = node;\n@@ -959,7 +961,7 @@ find_rgns (edge_list, dom)\n \t\t\t  tail = -1;\n \t\t\t  break;\n \t\t\t}\n-\t\t      else if (!TEST_BIT (in_queue, node) && node != i)\n+\t\t      else if (!TEST_BIT (in_queue, node) && node != bb->index)\n \t\t\t{\n \t\t\t  queue[++tail] = node;\n \t\t\t  SET_BIT (in_queue, node);\n@@ -976,12 +978,12 @@ find_rgns (edge_list, dom)\n \t      if (tail >= 0 && !too_large_failure)\n \t\t{\n \t\t  /* Place the loop header into list of region blocks.  */\n-\t\t  degree[i] = -1;\n-\t\t  rgn_bb_table[idx] = i;\n+\t\t  degree[bb->index] = -1;\n+\t\t  rgn_bb_table[idx] = bb->index;\n \t\t  RGN_NR_BLOCKS (nr_regions) = num_bbs;\n \t\t  RGN_BLOCKS (nr_regions) = idx++;\n-\t\t  CONTAINING_RGN (i) = nr_regions;\n-\t\t  BLOCK_TO_BB (i) = count = 0;\n+\t\t  CONTAINING_RGN (bb->index) = nr_regions;\n+\t\t  BLOCK_TO_BB (bb->index) = count = 0;\n \n \t\t  /* Remove blocks from queue[] when their in degree\n \t\t     becomes zero.  Repeat until no blocks are left on the\n@@ -1020,14 +1022,14 @@ find_rgns (edge_list, dom)\n \n   /* Any block that did not end up in a region is placed into a region\n      by itself.  */\n-  for (i = 0; i < n_basic_blocks; i++)\n-    if (degree[i] >= 0)\n+  FOR_EACH_BB (bb)\n+    if (degree[bb->index] >= 0)\n       {\n-\trgn_bb_table[idx] = i;\n+\trgn_bb_table[idx] = bb->index;\n \tRGN_NR_BLOCKS (nr_regions) = 1;\n \tRGN_BLOCKS (nr_regions) = idx++;\n-\tCONTAINING_RGN (i) = nr_regions++;\n-\tBLOCK_TO_BB (i) = 0;\n+\tCONTAINING_RGN (bb->index) = nr_regions++;\n+\tBLOCK_TO_BB (bb->index) = 0;\n       }\n \n   free (max_hdr);\n@@ -2980,6 +2982,7 @@ schedule_insns (dump_file)\n   sbitmap large_region_blocks, blocks;\n   int rgn;\n   int any_large_regions;\n+  basic_block bb;\n \n   /* Taking care of this degenerate case makes the rest of\n      this code simpler.  */\n@@ -3019,7 +3022,9 @@ schedule_insns (dump_file)\n \n   any_large_regions = 0;\n   large_region_blocks = sbitmap_alloc (n_basic_blocks);\n-  sbitmap_ones (large_region_blocks);\n+  sbitmap_zero (large_region_blocks);\n+  FOR_EACH_BB (bb)\n+    SET_BIT (large_region_blocks, bb->index);\n \n   blocks = sbitmap_alloc (n_basic_blocks);\n   sbitmap_zero (blocks);"}, {"sha": "a626e1533a06380adc5b91f66b1bc813e28beef9", "filename": "gcc/sibcall.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fsibcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fsibcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsibcall.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -610,7 +610,7 @@ optimize_sibling_and_tail_recursive_calls ()\n \n       /* Walk forwards through the last normal block and see if it\n \t does nothing except fall into the exit block.  */\n-      for (insn = BLOCK_HEAD (n_basic_blocks - 1);\n+      for (insn = EXIT_BLOCK_PTR->prev_bb->head;\n \t   insn;\n \t   insn = NEXT_INSN (insn))\n \t{"}, {"sha": "85d5b50a99fef0ef765bf6ccedf3fa2bf361b1fd", "filename": "gcc/ssa-ccp.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa-ccp.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -740,6 +740,7 @@ optimize_unexecutable_edges (edges, executable_edges)\n      sbitmap executable_edges;\n {\n   int i;\n+  basic_block bb;\n \n   for (i = 0; i < NUM_EDGES (edges); i++)\n     {\n@@ -797,9 +798,8 @@ optimize_unexecutable_edges (edges, executable_edges)\n      In cases B & C we are removing uses of registers, so make sure\n      to note those changes for the DF analyzer.  */\n \n-  for (i = 0; i < n_basic_blocks; i++)\n+  FOR_EACH_BB (bb)\n     {\n-      basic_block bb = BASIC_BLOCK (i);\n       rtx insn = bb->end;\n       edge edge = bb->succ;\n \n@@ -929,18 +929,16 @@ ssa_ccp_substitute_constants ()\n static void\n ssa_ccp_df_delete_unreachable_insns ()\n {\n-  int i;\n+  basic_block b;\n \n   /* Use the CFG to find all the reachable blocks.  */\n   find_unreachable_blocks ();\n \n   /* Now we know what blocks are not reachable.  Mark all the insns\n      in those blocks as deleted for the DF analyzer.   We'll let the\n      normal flow code actually remove the unreachable blocks.  */\n-  for (i = n_basic_blocks - 1; i >= 0; --i)\n+  FOR_EACH_BB_REVERSE (b)\n     {\n-      basic_block b = BASIC_BLOCK (i);\n-\n       if (!(b->flags & BB_REACHABLE))\n \t{\n \t  rtx start = b->head;"}, {"sha": "7b8cff807bd2166f30979c4b36d19adee6aa6f90", "filename": "gcc/ssa-dce.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa-dce.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -490,6 +490,7 @@ ssa_eliminate_dead_code ()\n {\n   int i;\n   rtx insn;\n+  basic_block bb;\n   /* Necessary instructions with operands to explore.  */\n   varray_type unprocessed_instructions;\n   /* Map element (b,e) is nonzero if the block is control dependent on\n@@ -718,10 +719,8 @@ ssa_eliminate_dead_code ()\n   /* Find any blocks with no successors and ensure they are followed\n      by a BARRIER.  delete_insn has the nasty habit of deleting barriers\n      when deleting insns.  */\n-  for (i = 0; i < n_basic_blocks; i++)\n+  FOR_EACH_BB (bb)\n     {\n-      basic_block bb = BASIC_BLOCK (i);\n-\n       if (bb->succ == NULL)\n \t{\n \t  rtx next = NEXT_INSN (bb->end);"}, {"sha": "9fada952820dc29b8e688af5ec9e09ec04cd3325", "filename": "gcc/ssa.c", "status": "modified", "additions": 40, "deletions": 42, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0082a72651ae718c46e4f3510bba4a116148fc7/gcc%2Fssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa.c?ref=e0082a72651ae718c46e4f3510bba4a116148fc7", "patch": "@@ -470,18 +470,18 @@ find_evaluations (evals, nregs)\n      sbitmap *evals;\n      int nregs;\n {\n-  int bb;\n+  basic_block bb;\n \n   sbitmap_vector_zero (evals, nregs);\n   fe_evals = evals;\n \n-  for (bb = n_basic_blocks; --bb >= 0; )\n+  FOR_EACH_BB_REVERSE (bb)\n     {\n       rtx p, last;\n \n-      fe_current_bb = bb;\n-      p = BLOCK_HEAD (bb);\n-      last = BLOCK_END (bb);\n+      fe_current_bb = bb->index;\n+      p = bb->head;\n+      last = bb->end;\n       while (1)\n \t{\n \t  if (INSN_P (p))\n@@ -520,17 +520,17 @@ compute_dominance_frontiers_1 (frontiers, idom, bb, done)\n {\n   basic_block b = BASIC_BLOCK (bb);\n   edge e;\n-  int c;\n+  basic_block c;\n \n   SET_BIT (done, bb);\n   sbitmap_zero (frontiers[bb]);\n \n   /* Do the frontier of the children first.  Not all children in the\n      dominator tree (blocks dominated by this one) are children in the\n      CFG, so check all blocks.  */\n-  for (c = 0; c < n_basic_blocks; ++c)\n-    if (idom[c] == bb && ! TEST_BIT (done, c))\n-      compute_dominance_frontiers_1 (frontiers, idom, c, done);\n+  FOR_EACH_BB (c)\n+    if (idom[c->index] == bb && ! TEST_BIT (done, c->index))\n+      compute_dominance_frontiers_1 (frontiers, idom, c->index, done);\n \n   /* Find blocks conforming to rule (1) above.  */\n   for (e = b->succ; e; e = e->succ_next)\n@@ -542,11 +542,11 @@ compute_dominance_frontiers_1 (frontiers, idom, bb, done)\n     }\n \n   /* Find blocks conforming to rule (2).  */\n-  for (c = 0; c < n_basic_blocks; ++c)\n-    if (idom[c] == bb)\n+  FOR_EACH_BB (c)\n+    if (idom[c->index] == bb)\n       {\n \tint x;\n-\tEXECUTE_IF_SET_IN_SBITMAP (frontiers[c], 0, x,\n+\tEXECUTE_IF_SET_IN_SBITMAP (frontiers[c->index], 0, x,\n \t  {\n \t    if (idom[x] != bb)\n \t      SET_BIT (frontiers[bb], x);\n@@ -975,7 +975,7 @@ rename_block (bb, idom)\n   edge e;\n   rtx insn, next, last;\n   struct rename_set_data *set_data = NULL;\n-  int c;\n+  basic_block c;\n \n   /* Step One: Walk the basic block, adding new names for sets and\n      replacing uses.  */\n@@ -1078,9 +1078,9 @@ rename_block (bb, idom)\n   /* Step Three: Do the same to the children of this block in\n      dominator order.  */\n \n-  for (c = 0; c < n_basic_blocks; ++c)\n-    if (idom[c] == bb)\n-      rename_block (c, idom);\n+  FOR_EACH_BB (c)\n+    if (idom[c->index] == bb)\n+      rename_block (c->index, idom);\n \n   /* Step Four: Update the sets to refer to their new register,\n      and restore ssa_rename_to to its previous state.  */\n@@ -1140,6 +1140,8 @@ convert_to_ssa ()\n \n   int nregs;\n \n+  basic_block bb;\n+\n   /* Don't do it twice.  */\n   if (in_ssa_form)\n     abort ();\n@@ -1154,10 +1156,9 @@ convert_to_ssa ()\n \n   if (rtl_dump_file)\n     {\n-      int i;\n       fputs (\";; Immediate Dominators:\\n\", rtl_dump_file);\n-      for (i = 0; i < n_basic_blocks; ++i)\n-\tfprintf (rtl_dump_file, \";\\t%3d = %3d\\n\", i, idom[i]);\n+      FOR_EACH_BB (bb)\n+\tfprintf (rtl_dump_file, \";\\t%3d = %3d\\n\", bb->index, idom[bb->index]);\n       fflush (rtl_dump_file);\n     }\n \n@@ -1629,7 +1630,7 @@ make_equivalent_phi_alternatives_equivalent (bb, reg_partition)\n static partition\n compute_conservative_reg_partition ()\n {\n-  int bb;\n+  basic_block bb;\n   int changed = 0;\n \n   /* We don't actually work with hard registers, but it's easier to\n@@ -1642,17 +1643,17 @@ compute_conservative_reg_partition ()\n      be copied on abnormal critical edges are placed in the same\n      partition.  This saves us from having to split abnormal critical\n      edges.  */\n-  for (bb = n_basic_blocks; --bb >= 0; )\n-    changed += make_regs_equivalent_over_bad_edges (bb, p);\n+  FOR_EACH_BB_REVERSE (bb)\n+    changed += make_regs_equivalent_over_bad_edges (bb->index, p);\n \n   /* Now we have to insure that corresponding arguments of phi nodes\n      assigning to corresponding regs are equivalent.  Iterate until\n      nothing changes.  */\n   while (changed > 0)\n     {\n       changed = 0;\n-      for (bb = n_basic_blocks; --bb >= 0; )\n-\tchanged += make_equivalent_phi_alternatives_equivalent (bb, p);\n+      FOR_EACH_BB_REVERSE (bb)\n+\tchanged += make_equivalent_phi_alternatives_equivalent (bb->index, p);\n     }\n \n   return p;\n@@ -1848,7 +1849,7 @@ coalesce_regs_in_successor_phi_nodes (bb, p, conflicts)\n static partition\n compute_coalesced_reg_partition ()\n {\n-  int bb;\n+  basic_block bb;\n   int changed = 0;\n   regset_head phi_set_head;\n   regset phi_set = &phi_set_head;\n@@ -1860,8 +1861,8 @@ compute_coalesced_reg_partition ()\n      be copied on abnormal critical edges are placed in the same\n      partition.  This saves us from having to split abnormal critical\n      edges (which can't be done).  */\n-  for (bb = n_basic_blocks; --bb >= 0; )\n-    make_regs_equivalent_over_bad_edges (bb, p);\n+  FOR_EACH_BB_REVERSE (bb)\n+    make_regs_equivalent_over_bad_edges (bb->index, p);\n \n   INIT_REG_SET (phi_set);\n \n@@ -1883,12 +1884,11 @@ compute_coalesced_reg_partition ()\n \t blocks first, so that most frequently executed copies would\n \t be more likely to be removed by register coalescing.  But any\n \t order will generate correct, if non-optimal, results.  */\n-      for (bb = n_basic_blocks; --bb >= 0; )\n+      FOR_EACH_BB_REVERSE (bb)\n \t{\n-\t  basic_block block = BASIC_BLOCK (bb);\n-\t  changed += coalesce_regs_in_copies (block, p, conflicts);\n+\t  changed += coalesce_regs_in_copies (bb, p, conflicts);\n \t  changed +=\n-\t    coalesce_regs_in_successor_phi_nodes (block, p, conflicts);\n+\t    coalesce_regs_in_successor_phi_nodes (bb, p, conflicts);\n \t}\n \n       conflict_graph_delete (conflicts);\n@@ -2094,11 +2094,10 @@ static void\n rename_equivalent_regs (reg_partition)\n      partition reg_partition;\n {\n-  int bb;\n+  basic_block b;\n \n-  for (bb = n_basic_blocks; --bb >= 0; )\n+  FOR_EACH_BB_REVERSE (b)\n     {\n-      basic_block b = BASIC_BLOCK (bb);\n       rtx next = b->head;\n       rtx last = b->end;\n       rtx insn;\n@@ -2141,7 +2140,7 @@ rename_equivalent_regs (reg_partition)\n void\n convert_from_ssa ()\n {\n-  int bb;\n+  basic_block b, bb;\n   partition reg_partition;\n   rtx insns = get_insns ();\n \n@@ -2167,9 +2166,8 @@ convert_from_ssa ()\n   rename_equivalent_regs (reg_partition);\n \n   /* Eliminate the PHI nodes.  */\n-  for (bb = n_basic_blocks; --bb >= 0; )\n+  FOR_EACH_BB_REVERSE (b)\n     {\n-      basic_block b = BASIC_BLOCK (bb);\n       edge e;\n \n       for (e = b->pred; e; e = e->pred_next)\n@@ -2180,17 +2178,17 @@ convert_from_ssa ()\n   partition_delete (reg_partition);\n \n   /* Actually delete the PHI nodes.  */\n-  for (bb = n_basic_blocks; --bb >= 0; )\n+  FOR_EACH_BB_REVERSE (bb)\n     {\n-      rtx insn = BLOCK_HEAD (bb);\n+      rtx insn = bb->head;\n \n       while (1)\n \t{\n \t  /* If this is a PHI node delete it.  */\n \t  if (PHI_NODE_P (insn))\n \t    {\n-\t      if (insn == BLOCK_END (bb))\n-\t\tBLOCK_END (bb) = PREV_INSN (insn);\n+\t      if (insn == bb->end)\n+\t\tbb->end = PREV_INSN (insn);\n \t      insn = delete_insn (insn);\n \t    }\n \t  /* Since all the phi nodes come at the beginning of the\n@@ -2199,7 +2197,7 @@ convert_from_ssa ()\n \t  else if (INSN_P (insn))\n \t    break;\n \t  /* If we've reached the end of the block, stop.  */\n-\t  else if (insn == BLOCK_END (bb))\n+\t  else if (insn == bb->end)\n \t    break;\n \t  else\n \t    insn = NEXT_INSN (insn);"}]}