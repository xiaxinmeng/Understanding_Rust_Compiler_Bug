{"sha": "9476364759b1dc6e0f79b381b6adb7f995cc2706", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQ3NjM2NDc1OWIxZGM2ZTBmNzliMzgxYjZhZGI3Zjk5NWNjMjcwNg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-12-09T09:37:37Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-12-09T09:37:37Z"}, "message": "re PR c++/16681 (array initialization in struct construct is a memory hog)\n\ncp:\n\tPR c++/16681\n\t* init.c (build_zero_init): Build a RANGE_EXPR for an array\n\tinitializer.\ntestsuite:\n\tPR c++/16681\n\t* g++.dg/init/array15.C: New.\n\t* g++.dg/init/array16.C: New.\n\nFrom-SVN: r91928", "tree": {"sha": "c90b357b9524e70af672bd367baeefb8eeb3758d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c90b357b9524e70af672bd367baeefb8eeb3758d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9476364759b1dc6e0f79b381b6adb7f995cc2706", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9476364759b1dc6e0f79b381b6adb7f995cc2706", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9476364759b1dc6e0f79b381b6adb7f995cc2706", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9476364759b1dc6e0f79b381b6adb7f995cc2706/comments", "author": null, "committer": null, "parents": [{"sha": "42fabf21b2167ab9d0fc8482b297a7e75ff2964f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42fabf21b2167ab9d0fc8482b297a7e75ff2964f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42fabf21b2167ab9d0fc8482b297a7e75ff2964f"}], "stats": {"total": 183, "additions": 174, "deletions": 9}, "files": [{"sha": "2d73639bce1433cc824553b4d862c494fd5a1584", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9476364759b1dc6e0f79b381b6adb7f995cc2706/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9476364759b1dc6e0f79b381b6adb7f995cc2706/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9476364759b1dc6e0f79b381b6adb7f995cc2706", "patch": "@@ -1,3 +1,9 @@\n+2004-12-09  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/16681\n+\t* init.c (build_zero_init): Build a RANGE_EXPR for an array\n+\tinitializer.\n+\n 2004-12-08  Kelley Cook  <kcook@gcc.gnu.org>\n \n \t* typeck.c: Remove DOS line endings."}, {"sha": "70703efacacd0fe244f8729288b88ee234d737c2", "filename": "gcc/cp/init.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9476364759b1dc6e0f79b381b6adb7f995cc2706/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9476364759b1dc6e0f79b381b6adb7f995cc2706/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=9476364759b1dc6e0f79b381b6adb7f995cc2706", "patch": "@@ -214,7 +214,6 @@ build_zero_init (tree type, tree nelts, bool static_storage_p)\n     }\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n-      tree index;\n       tree max_index;\n       tree inits;\n \n@@ -228,14 +227,16 @@ build_zero_init (tree type, tree nelts, bool static_storage_p)\n       /* A zero-sized array, which is accepted as an extension, will\n \t have an upper bound of -1.  */\n       if (!tree_int_cst_equal (max_index, integer_minus_one_node))\n-\tfor (index = size_zero_node;\n-\t     !tree_int_cst_lt (max_index, index);\n-\t     index = size_binop (PLUS_EXPR, index, size_one_node))\n-\t  inits = tree_cons (index,\n-\t\t\t     build_zero_init (TREE_TYPE (type),\n-\t\t\t\t\t      /*nelts=*/NULL_TREE,\n-\t\t\t\t\t      static_storage_p),\n-\t\t\t     inits);\n+\t{\n+\t  tree elt_init = build_zero_init (TREE_TYPE (type),\n+\t\t\t\t\t   /*nelts=*/NULL_TREE,\n+\t\t\t\t\t   static_storage_p);\n+\t  tree range = build2 (RANGE_EXPR,\n+\t\t\t       sizetype, size_zero_node, max_index);\n+\t  \n+\t  inits = tree_cons (range, elt_init, inits);\n+\t}\n+      \n       CONSTRUCTOR_ELTS (init) = nreverse (inits);\n     }\n   else"}, {"sha": "d8ad0adbf58a070b3c5933600490020c12da2247", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9476364759b1dc6e0f79b381b6adb7f995cc2706/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9476364759b1dc6e0f79b381b6adb7f995cc2706/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9476364759b1dc6e0f79b381b6adb7f995cc2706", "patch": "@@ -1,3 +1,9 @@\n+2004-12-09  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/16681\n+\t* g++.dg/init/array15.C: New.\n+\t* g++.dg/init/array16.C: New.\n+\n 2004-12-08  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \tPR fortran/18826"}, {"sha": "17160d07611b80978b8cb8593fa77edf01345cd5", "filename": "gcc/testsuite/g++.dg/init/array15.C", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9476364759b1dc6e0f79b381b6adb7f995cc2706/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9476364759b1dc6e0f79b381b6adb7f995cc2706/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray15.C?ref=9476364759b1dc6e0f79b381b6adb7f995cc2706", "patch": "@@ -0,0 +1,46 @@\n+// { dg-do run }\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 8 Dec 2004 <nathan@codesourcery.com>\n+\n+// PR 16681 too much memory used\n+// Origin:  Matt LaFary <lafary@activmedia.com>\n+\n+struct foo {\n+  unsigned char buffer[4111222];\n+  foo() ;\n+  bool check () const;\n+};\n+\n+foo::foo ()\n+  : buffer()\n+{}\n+\n+bool foo::check () const\n+{\n+  for (unsigned ix = sizeof (buffer); ix--;)\n+    if (buffer[ix])\n+      return false;\n+  return true;\n+}\n+\n+void *operator new (__SIZE_TYPE__ size, void *p)\n+{\n+  return p;\n+}\n+\n+char heap[5000000];\n+\n+int main ()\n+{\n+  for (unsigned ix = sizeof (heap); ix--;)\n+    heap[ix] = ix;\n+  \n+  foo *f = new (heap) foo ();\n+\n+  if (!f->check ())\n+    return 1;\n+  return 0;\n+}\n+\n+  "}, {"sha": "fa4c1b6508819053943c9a5196d5333ff79f66c4", "filename": "gcc/testsuite/g++.dg/init/array16.C", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9476364759b1dc6e0f79b381b6adb7f995cc2706/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9476364759b1dc6e0f79b381b6adb7f995cc2706/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray16.C?ref=9476364759b1dc6e0f79b381b6adb7f995cc2706", "patch": "@@ -0,0 +1,106 @@\n+// { dg-do run }\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 8 Dec 2004 <nathan@codesourcery.com>\n+\n+// PR 16681 too much memory used\n+// Origin:  Matt LaFary <lafary@activmedia.com>\n+\n+\n+struct elt \n+{\n+  static int count;\n+  static elt*ptr;\n+  static int abort;\n+  char c;\n+  \n+  elt ();\n+  ~elt ();\n+  \n+};\n+\n+int elt::count;\n+elt *elt::ptr;\n+int elt::abort;\n+\n+elt::elt ()\n+  :c ()\n+{\n+  if (count >= 0)\n+    {\n+      if (!ptr)\n+\tptr = this;\n+      if (count == 100)\n+\tthrow 2;\n+      if (this != ptr)\n+\tabort = 1;\n+      count++;\n+      ptr++;\n+    }\n+}\n+\n+elt::~elt ()\n+{\n+  if (count >= 0)\n+    {\n+      ptr--;\n+      count--;\n+      if (ptr != this)\n+\tabort = 2;\n+    }\n+}\n+\n+struct foo {\n+  elt buffer[4111222];\n+  foo() ;\n+  bool check () const;\n+};\n+\n+foo::foo ()\n+  : buffer()\n+{}\n+\n+bool foo::check () const\n+{\n+  for (unsigned ix = sizeof (buffer)/ sizeof (buffer[0]); ix--;)\n+    if (buffer[ix].c)\n+      return false;\n+  return true;\n+}\n+\n+void *operator new (__SIZE_TYPE__ size, void *p)\n+{\n+  return p;\n+}\n+\n+char heap[5000000];\n+\n+int main ()\n+{\n+  for (unsigned ix = sizeof (heap); ix--;)\n+    heap[ix] = ix;\n+\n+  try\n+    {\n+      foo *f = new (heap) foo ();\n+      return 1;\n+    }\n+  catch (...)\n+    {\n+      if (elt::count)\n+\treturn 2;\n+      if (elt::abort)\n+\treturn elt::abort + 3;\n+    }\n+\n+  for (unsigned ix = sizeof (heap); ix--;)\n+    heap[ix] = ix;\n+\n+  elt::count = -1;\n+  foo *f = new (heap) foo ();\n+  if (!f->check ())\n+    return 3;\n+  return 0;\n+}\n+\n+  "}]}