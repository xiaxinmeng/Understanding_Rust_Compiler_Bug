{"sha": "7cafdb8bfe700513a2916358303f4f8c28eff4d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2NhZmRiOGJmZTcwMDUxM2EyOTE2MzU4MzAzZjRmOGMyOGVmZjRkOQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-06-05T20:01:47Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-06-05T20:01:47Z"}, "message": "class.c (indirect_primary_base_p): New function.\n\n\t* class.c (indirect_primary_base_p): New function.\n\t(determine_primary_base): Use it.\n\nFrom-SVN: r34412", "tree": {"sha": "0638c84abe9eac68245aa4a23a6ed3973215d5e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0638c84abe9eac68245aa4a23a6ed3973215d5e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7cafdb8bfe700513a2916358303f4f8c28eff4d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cafdb8bfe700513a2916358303f4f8c28eff4d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cafdb8bfe700513a2916358303f4f8c28eff4d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cafdb8bfe700513a2916358303f4f8c28eff4d9/comments", "author": null, "committer": null, "parents": [{"sha": "3faa108c7b6e3a8966a1bba7b2eea3f6612a6adf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3faa108c7b6e3a8966a1bba7b2eea3f6612a6adf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3faa108c7b6e3a8966a1bba7b2eea3f6612a6adf"}], "stats": {"total": 90, "additions": 78, "deletions": 12}, "files": [{"sha": "f0f7e367a05069a72462d1e4d7bd920118ec55ba", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cafdb8bfe700513a2916358303f4f8c28eff4d9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cafdb8bfe700513a2916358303f4f8c28eff4d9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7cafdb8bfe700513a2916358303f4f8c28eff4d9", "patch": "@@ -1,3 +1,8 @@\n+2000-06-05  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* class.c (indirect_primary_base_p): New function.\n+\t(determine_primary_base): Use it.\n+\n 2000-06-05  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tUpdate new-abi dynamic cast algorithm."}, {"sha": "77a5b7e6499609288e3c27e122fd7463a9b5e4d4", "filename": "gcc/cp/class.c", "status": "modified", "additions": 73, "deletions": 12, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cafdb8bfe700513a2916358303f4f8c28eff4d9/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cafdb8bfe700513a2916358303f4f8c28eff4d9/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=7cafdb8bfe700513a2916358303f4f8c28eff4d9", "patch": "@@ -188,6 +188,7 @@ static void build_vtt PARAMS ((tree));\n static tree *build_vtt_inits PARAMS ((tree, tree, tree *, tree *));\n static tree dfs_build_vtt_inits PARAMS ((tree, void *));\n static tree dfs_fixup_binfo_vtbls PARAMS ((tree, void *));\n+static int indirect_primary_base_p PARAMS ((tree, tree));\n \n /* Variables shared between class.c and call.c.  */\n \n@@ -1807,6 +1808,35 @@ set_primary_base (t, i, vfuns_p)\n   *vfuns_p = CLASSTYPE_VSIZE (basetype);\n }\n \n+/* Returns true iff BINFO (a direct virtual base of T) is an indirect\n+   primary base.  */\n+\n+static int\n+indirect_primary_base_p (t, binfo)\n+     tree t;\n+     tree binfo;\n+{\n+  int i;\n+\n+  for (i = 0; i < CLASSTYPE_N_BASECLASSES (t); ++i)\n+    {\n+      tree type;\n+      tree b;\n+\n+      /* Figure out to which type the Ith base corresponds.  */\n+      type = TYPE_BINFO_BASETYPE (t, i);\n+      /* See if any of the primary bases have the same type as BINFO.  */\n+      for (b = TYPE_BINFO (type); b; b = TREE_CHAIN (b))\n+\t/* If this base is primary, and has the same type as BINFO,\n+\t   then BINFO is an indirect primary base.  */\n+\tif (BINFO_PRIMARY_MARKED_P (b)\n+\t    && same_type_p (BINFO_TYPE (b), BINFO_TYPE (binfo)))\n+\t  return 1;\n+    }\n+\n+  return 0;\n+}\n+\n /* Determine the primary class for T.  */\n \n static void\n@@ -1874,19 +1904,50 @@ determine_primary_base (t, vfuns_p)\n      class as the primary base class if no non-virtual polymorphic\n      base can be found.  */\n   if (flag_new_abi && !CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n-    for (i = 0; i < n_baseclasses; ++i)\n-      {\n-\ttree base_binfo = TREE_VEC_ELT (TYPE_BINFO_BASETYPES (t), i);\n-\ttree basetype = BINFO_TYPE (base_binfo);\n+    {\n+      /* If not -1, this is the index in TYPE_BINFO_BASETYPEs of the\n+\t best primary base candidate we have found so far.  */\n+      int candidate = -1;\n \n-\tif (TREE_VIA_VIRTUAL (base_binfo) \n-\t    && CLASSTYPE_NEARLY_EMPTY_P (basetype))\n-\t  {\n-\t    set_primary_base (t, i, vfuns_p);\n-\t    CLASSTYPE_VFIELDS (t) = copy_list (CLASSTYPE_VFIELDS (basetype));\n-\t    break;\n-\t  }\n-      }\n+      /* Loop over the baseclasses.  */\n+      for (i = 0; i < n_baseclasses; ++i)\n+\t{\n+\t  tree base_binfo = TREE_VEC_ELT (TYPE_BINFO_BASETYPES (t), i);\n+\t  tree basetype = BINFO_TYPE (base_binfo);\n+\n+\t  if (TREE_VIA_VIRTUAL (base_binfo) \n+\t      && CLASSTYPE_NEARLY_EMPTY_P (basetype))\n+\t    {\n+\t      int indirect_primary_p;\n+\n+\t      /* Figure out whether or not this base is an indirect\n+\t\t primary base.  */\n+\t      indirect_primary_p = indirect_primary_base_p (t, base_binfo);\n+\n+\t      /* If this is not an indirect primary base, then it's\n+\t\t definitely our primary base.  */\n+\t      if (!indirect_primary_p) \n+\t\t{\n+\t\t  candidate = i;\n+\t\t  break;\n+\t\t}\n+\t      /* If this was an indirect primary base, it's still our\n+\t\t primary base -- unless there's another nearly-empty\n+\t\t virtual base that isn't an indirect primary base.  */\n+\t      else if (candidate == -1)\n+\t\tcandidate = i;\n+\t    }\n+\t}\n+\n+      /* If we've got a primary base, use it.  */\n+      if (candidate != -1) \n+\t{\n+\t  set_primary_base (t, candidate, vfuns_p);\n+\t  CLASSTYPE_VFIELDS (t) \n+\t    = copy_list (CLASSTYPE_VFIELDS (TYPE_BINFO_BASETYPE (t, \n+\t\t\t\t\t\t\t\t candidate)));\n+\t}\t\n+    }\n \n   /* Mark the primary base classes at this point.  */\n   mark_primary_bases (t);"}]}