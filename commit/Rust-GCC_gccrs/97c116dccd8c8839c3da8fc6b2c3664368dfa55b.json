{"sha": "97c116dccd8c8839c3da8fc6b2c3664368dfa55b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTdjMTE2ZGNjZDhjODgzOWMzZGE4ZmM2YjJjMzY2NDM2OGRmYTU1Yg==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2013-04-24T14:04:44Z"}, "committer": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2013-04-24T14:04:44Z"}, "message": "Prune SCEV\n\nFrom-SVN: r198233", "tree": {"sha": "7a9b87dede020ebca3097a7d9caa416ba77aa0f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a9b87dede020ebca3097a7d9caa416ba77aa0f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/97c116dccd8c8839c3da8fc6b2c3664368dfa55b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97c116dccd8c8839c3da8fc6b2c3664368dfa55b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97c116dccd8c8839c3da8fc6b2c3664368dfa55b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97c116dccd8c8839c3da8fc6b2c3664368dfa55b/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a378996bf6f7e4a8261129e9afce4b59983f5546", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a378996bf6f7e4a8261129e9afce4b59983f5546", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a378996bf6f7e4a8261129e9afce4b59983f5546"}], "stats": {"total": 143, "additions": 9, "deletions": 134}, "files": [{"sha": "2a6d864b5f850e7bbaea5f18989de2e282f883bc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97c116dccd8c8839c3da8fc6b2c3664368dfa55b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97c116dccd8c8839c3da8fc6b2c3664368dfa55b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=97c116dccd8c8839c3da8fc6b2c3664368dfa55b", "patch": "@@ -1,3 +1,12 @@\n+2013-04-24  Marek Polacek  <polacek@redhat.com>\n+\n+\t* tree-scalar-evolution.h (analyze_scalar_evolution): Remove.\n+\t* tree-scalar-evolution.c (get_exit_conditions_rec): Likewise.\n+\t(select_loops_exit_conditions): Likewise.\n+\t(number_of_iterations_for_all_loops): Likewise.\n+\t(analyze_scalar_evolution_for_all_loop_phi_nodes): Likewise.\n+\t(scev_analysis): Likewise.\n+\n 2013-04-02  Catherine Moore  <clm@codesourcery.com>\n \t    Chao-ying Fu <fu@mips.com>\n "}, {"sha": "a76d9aee46a941a122e3fbb108199da10625c275", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 0, "deletions": 133, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97c116dccd8c8839c3da8fc6b2c3664368dfa55b/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97c116dccd8c8839c3da8fc6b2c3664368dfa55b/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=97c116dccd8c8839c3da8fc6b2c3664368dfa55b", "patch": "@@ -868,39 +868,6 @@ get_loop_exit_condition (const struct loop *loop)\n   return res;\n }\n \n-/* Recursively determine and enqueue the exit conditions for a loop.  */\n-\n-static void\n-get_exit_conditions_rec (struct loop *loop,\n-\t\t\t vec<gimple> *exit_conditions)\n-{\n-  if (!loop)\n-    return;\n-\n-  /* Recurse on the inner loops, then on the next (sibling) loops.  */\n-  get_exit_conditions_rec (loop->inner, exit_conditions);\n-  get_exit_conditions_rec (loop->next, exit_conditions);\n-\n-  if (single_exit (loop))\n-    {\n-      gimple loop_condition = get_loop_exit_condition (loop);\n-\n-      if (loop_condition)\n-\texit_conditions->safe_push (loop_condition);\n-    }\n-}\n-\n-/* Select the candidate loop nests for the analysis.  This function\n-   initializes the EXIT_CONDITIONS array.  */\n-\n-static void\n-select_loops_exit_conditions (vec<gimple> *exit_conditions)\n-{\n-  struct loop *function_body = current_loops->tree_root;\n-\n-  get_exit_conditions_rec (function_body->inner, exit_conditions);\n-}\n-\n \f\n /* Depth first search algorithm.  */\n \n@@ -2882,41 +2849,6 @@ number_of_exit_cond_executions (struct loop *loop)\n   return ret;\n }\n \n-/* One of the drivers for testing the scalar evolutions analysis.\n-   This function computes the number of iterations for all the loops\n-   from the EXIT_CONDITIONS array.  */\n-\n-static void\n-number_of_iterations_for_all_loops (vec<gimple> *exit_conditions)\n-{\n-  unsigned int i;\n-  unsigned nb_chrec_dont_know_loops = 0;\n-  unsigned nb_static_loops = 0;\n-  gimple cond;\n-\n-  FOR_EACH_VEC_ELT (*exit_conditions, i, cond)\n-    {\n-      tree res = number_of_latch_executions (loop_containing_stmt (cond));\n-      if (chrec_contains_undetermined (res))\n-\tnb_chrec_dont_know_loops++;\n-      else\n-\tnb_static_loops++;\n-    }\n-\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"\\n(\\n\");\n-      fprintf (dump_file, \"-----------------------------------------\\n\");\n-      fprintf (dump_file, \"%d\\tnb_chrec_dont_know_loops\\n\", nb_chrec_dont_know_loops);\n-      fprintf (dump_file, \"%d\\tnb_static_loops\\n\", nb_static_loops);\n-      fprintf (dump_file, \"%d\\tnb_total_loops\\n\", number_of_loops ());\n-      fprintf (dump_file, \"-----------------------------------------\\n\");\n-      fprintf (dump_file, \")\\n\\n\");\n-\n-      print_loops (dump_file, 3);\n-    }\n-}\n-\n \f\n \n /* Counters for the stats.  */\n@@ -3028,54 +2960,6 @@ gather_chrec_stats (tree chrec, struct chrec_stats *stats)\n     fprintf (dump_file, \")\\n\");\n }\n \n-/* One of the drivers for testing the scalar evolutions analysis.\n-   This function analyzes the scalar evolution of all the scalars\n-   defined as loop phi nodes in one of the loops from the\n-   EXIT_CONDITIONS array.\n-\n-   TODO Optimization: A loop is in canonical form if it contains only\n-   a single scalar loop phi node.  All the other scalars that have an\n-   evolution in the loop are rewritten in function of this single\n-   index.  This allows the parallelization of the loop.  */\n-\n-static void\n-analyze_scalar_evolution_for_all_loop_phi_nodes (vec<gimple> *exit_conditions)\n-{\n-  unsigned int i;\n-  struct chrec_stats stats;\n-  gimple cond, phi;\n-  gimple_stmt_iterator psi;\n-\n-  reset_chrecs_counters (&stats);\n-\n-  FOR_EACH_VEC_ELT (*exit_conditions, i, cond)\n-    {\n-      struct loop *loop;\n-      basic_block bb;\n-      tree chrec;\n-\n-      loop = loop_containing_stmt (cond);\n-      bb = loop->header;\n-\n-      for (psi = gsi_start_phis (bb); !gsi_end_p (psi); gsi_next (&psi))\n-\t{\n-\t  phi = gsi_stmt (psi);\n-\t  if (!virtual_operand_p (PHI_RESULT (phi)))\n-\t    {\n-\t      chrec = instantiate_parameters\n-\t\t        (loop,\n-\t\t\t analyze_scalar_evolution (loop, PHI_RESULT (phi)));\n-\n-\t      if (dump_file && (dump_flags & TDF_STATS))\n-\t\tgather_chrec_stats (chrec, &stats);\n-\t    }\n-\t}\n-    }\n-\n-  if (dump_file && (dump_flags & TDF_STATS))\n-    dump_chrecs_stats (dump_file, &stats);\n-}\n-\n /* Callback for htab_traverse, gathers information on chrecs in the\n    hashtable.  */\n \n@@ -3254,23 +3138,6 @@ simple_iv (struct loop *wrto_loop, struct loop *use_loop, tree op,\n   return true;\n }\n \n-/* Runs the analysis of scalar evolutions.  */\n-\n-void\n-scev_analysis (void)\n-{\n-  vec<gimple> exit_conditions;\n-\n-  exit_conditions.create (37);\n-  select_loops_exit_conditions (&exit_conditions);\n-\n-  if (dump_file && (dump_flags & TDF_STATS))\n-    analyze_scalar_evolution_for_all_loop_phi_nodes (&exit_conditions);\n-\n-  number_of_iterations_for_all_loops (&exit_conditions);\n-  exit_conditions.release ();\n-}\n-\n /* Finalize the scalar evolution analysis.  */\n \n void"}, {"sha": "7e7f6f23833b566ce8e189d2378c6e5beca25066", "filename": "gcc/tree-scalar-evolution.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97c116dccd8c8839c3da8fc6b2c3664368dfa55b/gcc%2Ftree-scalar-evolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97c116dccd8c8839c3da8fc6b2c3664368dfa55b/gcc%2Ftree-scalar-evolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.h?ref=97c116dccd8c8839c3da8fc6b2c3664368dfa55b", "patch": "@@ -34,7 +34,6 @@ extern tree analyze_scalar_evolution (struct loop *, tree);\n extern tree instantiate_scev (basic_block, struct loop *, tree);\n extern tree resolve_mixers (struct loop *, tree);\n extern void gather_stats_on_scev_database (void);\n-extern void scev_analysis (void);\n extern unsigned int scev_const_prop (void);\n extern bool expression_expensive_p (tree);\n extern bool simple_iv (struct loop *, struct loop *, tree, affine_iv *, bool);"}]}