{"sha": "142870f570d036ec06127bad47679743e68010f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQyODcwZjU3MGQwMzZlYzA2MTI3YmFkNDc2Nzk3NDNlNjgwMTBmNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-18T10:37:47Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-18T10:37:47Z"}, "message": "[multiple changes]\n\n2016-04-18  Bob Duff  <duff@adacore.com>\n\n\t* a-cuprqu.ads: Change the representation of List_Type from a\n\tsingly-linked list to a doubly-linked list. In addition, add a\n\tpointer Next_Unequal, which points past a possibly-long chain\n\tof equal-priority items. This increases efficiency, especially\n\tin the case of many equal-priority items.\n\t* a-cuprqu.adb (Dequeue, Enqueue): Rewrite algorithms to take\n\tadvantage of new data structure.\n\t(Finalize): Rewrite in terms of Dequeue, for simplicity.\n\n2016-04-18  Yannick Moy  <moy@adacore.com>\n\n\t* contracts.adb (Analyze_Object_Contract,\n\tAnalyze_Protected_Contract): Remove tests performed in GNATprove.\n\t* sem_util.adb, sem_util.ads (Has_Full_Default_Initialization):\n\tRemove query for tests performed in GNATprove.\n\nFrom-SVN: r235121", "tree": {"sha": "14fd1d72159c7f31441c86782351cfc329c45590", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14fd1d72159c7f31441c86782351cfc329c45590"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/142870f570d036ec06127bad47679743e68010f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/142870f570d036ec06127bad47679743e68010f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/142870f570d036ec06127bad47679743e68010f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/142870f570d036ec06127bad47679743e68010f7/comments", "author": null, "committer": null, "parents": [{"sha": "ec3c7387ac65ab902350a08c654f4f8f4a65af47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec3c7387ac65ab902350a08c654f4f8f4a65af47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec3c7387ac65ab902350a08c654f4f8f4a65af47"}], "stats": {"total": 353, "additions": 131, "deletions": 222}, "files": [{"sha": "fbdfabcae2822dba77cc41b3ea79f74204607366", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/142870f570d036ec06127bad47679743e68010f7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/142870f570d036ec06127bad47679743e68010f7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=142870f570d036ec06127bad47679743e68010f7", "patch": "@@ -1,3 +1,21 @@\n+2016-04-18  Bob Duff  <duff@adacore.com>\n+\n+\t* a-cuprqu.ads: Change the representation of List_Type from a\n+\tsingly-linked list to a doubly-linked list. In addition, add a\n+\tpointer Next_Unequal, which points past a possibly-long chain\n+\tof equal-priority items. This increases efficiency, especially\n+\tin the case of many equal-priority items.\n+\t* a-cuprqu.adb (Dequeue, Enqueue): Rewrite algorithms to take\n+\tadvantage of new data structure.\n+\t(Finalize): Rewrite in terms of Dequeue, for simplicity.\n+\n+2016-04-18  Yannick Moy  <moy@adacore.com>\n+\n+\t* contracts.adb (Analyze_Object_Contract,\n+\tAnalyze_Protected_Contract): Remove tests performed in GNATprove.\n+\t* sem_util.adb, sem_util.ads (Has_Full_Default_Initialization):\n+\tRemove query for tests performed in GNATprove.\n+\n 2016-04-18  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_aggr.adb (Resolve_Record_Aggregate): If"}, {"sha": "fb02f096a525f2602c7fb3d7be813d204ef20f32", "filename": "gcc/ada/a-cuprqu.adb", "status": "modified", "additions": 90, "deletions": 51, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/142870f570d036ec06127bad47679743e68010f7/gcc%2Fada%2Fa-cuprqu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/142870f570d036ec06127bad47679743e68010f7/gcc%2Fada%2Fa-cuprqu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cuprqu.adb?ref=142870f570d036ec06127bad47679743e68010f7", "patch": "@@ -37,8 +37,21 @@ package body Ada.Containers.Unbounded_Priority_Queues is\n       -- Local Subprograms --\n       -----------------------\n \n+      function Before_Or_Equal (X, Y : Queue_Priority) return Boolean;\n+      --  True if X is before or equal to Y. Equal means both Before(X,Y) and\n+      --  Before(Y,X) are False.\n+\n       procedure Free is\n-         new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n+        new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n+\n+      ---------------------\n+      -- Before_Or_Equal --\n+      ---------------------\n+\n+      function Before_Or_Equal (X, Y : Queue_Priority) return Boolean is\n+      begin\n+         return (if Before (X, Y) then True else not Before (Y, X));\n+      end Before_Or_Equal;\n \n       -------------\n       -- Dequeue --\n@@ -48,20 +61,36 @@ package body Ada.Containers.Unbounded_Priority_Queues is\n         (List    : in out List_Type;\n          Element : out Queue_Interfaces.Element_Type)\n       is\n-         X : Node_Access;\n+         H : constant Node_Access := List.Header'Unchecked_Access;\n+         pragma Assert (List.Length /= 0);\n+         pragma Assert (List.Header.Next /= H);\n+         --  List can't be empty; see the barrier\n \n-      begin\n-         Element := List.First.Element;\n+         pragma Assert\n+           (List.Header.Next.Next = H or else\n+            Before_Or_Equal (Get_Priority (List.Header.Next.Element),\n+                             Get_Priority (List.Header.Next.Next.Element)));\n+         --  The first item is before-or-equal to the second\n \n-         X := List.First;\n-         List.First := List.First.Next;\n+         pragma Assert\n+           (List.Header.Next.Next_Unequal = H or else\n+            Before (Get_Priority (List.Header.Next.Element),\n+                    Get_Priority (List.Header.Next.Next_Unequal.Element)));\n+         --  The first item is before its Next_Unequal item\n \n-         if List.First = null then\n-            List.Last := null;\n-         end if;\n+         --  The highest-priority item is always first; just remove it and\n+         --  return that element.\n \n-         List.Length := List.Length - 1;\n+         X : Node_Access := List.Header.Next;\n+\n+      --  Start of processing for Dequeue\n \n+      begin\n+         Element := X.Element;\n+         X.Next.Prev := H;\n+         List.Header.Next := X.Next;\n+         List.Header.Next_Unequal := X.Next;\n+         List.Length := List.Length - 1;\n          Free (X);\n       end Dequeue;\n \n@@ -93,15 +122,13 @@ package body Ada.Containers.Unbounded_Priority_Queues is\n          --  dequeue an item. If it's false, it means no item is dequeued, and\n          --  we return False as the Success value.\n \n-         if List.Length = 0\n-           or else Before (At_Least, Get_Priority (List.First.Element))\n-         then\n-            Success := False;\n-            return;\n-         end if;\n+         Success := List.Length > 0\n+           and then\n+             not Before (At_Least, Get_Priority (List.Header.Next.Element));\n \n-         List.Dequeue (Element);\n-         Success := True;\n+         if Success then\n+            List.Dequeue (Element);\n+         end if;\n       end Dequeue;\n \n       -------------\n@@ -113,41 +140,55 @@ package body Ada.Containers.Unbounded_Priority_Queues is\n          New_Item : Queue_Interfaces.Element_Type)\n       is\n          P : constant Queue_Priority := Get_Priority (New_Item);\n+         H : constant Node_Access := List.Header'Unchecked_Access;\n+\n+         function Next return Node_Access;\n+         --  The node before which we wish to insert the new node\n+\n+         ----------\n+         -- Next --\n+         ----------\n+\n+         function Next return Node_Access is\n+         begin\n+            return Result : Node_Access := H.Next_Unequal do\n+               while Result /= H\n+                 and then not Before (P, Get_Priority (Result.Element))\n+               loop\n+                  Result := Result.Next_Unequal;\n+               end loop;\n+            end return;\n+         end Next;\n \n-         Node : Node_Access;\n-         Prev : Node_Access;\n-\n-      begin\n-         Node := new Node_Type'(New_Item, null);\n-\n-         if List.First = null then\n-            List.First := Node;\n-            List.Last := List.First;\n+         --  Local varaibles\n \n-         else\n-            Prev := List.First;\n+         Prev : constant Node_Access := Next.Prev;\n+         --  The node after which we wish to insert the new node. So Prev must\n+         --  be the header, or be higher or equal priority to the new item.\n+         --  Prev.Next must be the header, or be lower priority than the\n+         --  new item.\n \n-            if Before (P, Get_Priority (Prev.Element)) then\n-               Node.Next := List.First;\n-               List.First := Node;\n+         pragma Assert\n+           (Prev = H or else Before_Or_Equal (Get_Priority (Prev.Element), P));\n+         pragma Assert\n+           (Prev.Next = H\n+              or else Before (P, Get_Priority (Prev.Next.Element)));\n+         pragma Assert (Prev.Next = Prev.Next_Unequal);\n \n-            else\n-               while Prev.Next /= null loop\n-                  if Before (P, Get_Priority (Prev.Next.Element)) then\n-                     Node.Next := Prev.Next;\n-                     Prev.Next := Node;\n+         Node : constant Node_Access :=\n+                  new Node_Type'(New_Item,\n+                                 Prev         => Prev,\n+                                 Next         => Prev.Next,\n+                                 Next_Unequal => Prev.Next);\n \n-                     exit;\n-                  end if;\n+      --  Start of processing for Enqueue\n \n-                  Prev := Prev.Next;\n-               end loop;\n+      begin\n+         Prev.Next.Prev := Node;\n+         Prev.Next := Node;\n \n-               if Prev.Next = null then\n-                  List.Last.Next := Node;\n-                  List.Last := Node;\n-               end if;\n-            end if;\n+         if List.Length = 0 then\n+            List.Header.Next_Unequal := Node;\n          end if;\n \n          List.Length := List.Length + 1;\n@@ -162,12 +203,10 @@ package body Ada.Containers.Unbounded_Priority_Queues is\n       --------------\n \n       procedure Finalize (List : in out List_Type) is\n-         X : Node_Access;\n+         Ignore : Queue_Interfaces.Element_Type;\n       begin\n-         while List.First /= null loop\n-            X := List.First;\n-            List.First := List.First.Next;\n-            Free (X);\n+         while List.Length > 0 loop\n+            List.Dequeue (Ignore);\n          end loop;\n       end Finalize;\n "}, {"sha": "1a239837b1e9632e01f2089f5109b4b7d5589aef", "filename": "gcc/ada/a-cuprqu.ads", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/142870f570d036ec06127bad47679743e68010f7/gcc%2Fada%2Fa-cuprqu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/142870f570d036ec06127bad47679743e68010f7/gcc%2Fada%2Fa-cuprqu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cuprqu.ads?ref=142870f570d036ec06127bad47679743e68010f7", "patch": "@@ -81,18 +81,35 @@ package Ada.Containers.Unbounded_Priority_Queues is\n \n    private\n \n+      --  List_Type is implemented as a circular doubly-linked list with a\n+      --  dummy header node; Prev and Next are the links. The list is in\n+      --  decreasing priority order, so the highest-priority item is always\n+      --  first. (If there are multiple items with the highest priority, the\n+      --  oldest one is first.) Header.Element is undefined and not used.\n+      --\n+      --  In addition, Next_Unequal points to the next item with a different\n+      --  (i.e. strictly lower) priority. This is used to speed up the search\n+      --  for the next lower-priority item, in cases where there are many items\n+      --  with the same priority.\n+      --\n+      --  An empty list has Header.Prev, Header.Next, and Header.Next_Unequal\n+      --  all pointing to Header. A nonempty list has Header.Next_Unequal\n+      --  pointing to the first \"real\" item, and the last item has Next_Unequal\n+      --  pointing back to Header.\n+\n       type Node_Type;\n-      type Node_Access is access Node_Type;\n+      type Node_Access is access all Node_Type;\n \n       type Node_Type is limited record\n-         Element : Queue_Interfaces.Element_Type;\n-         Next    : Node_Access;\n+         Element      : Queue_Interfaces.Element_Type;\n+         Prev, Next   : Node_Access := Node_Type'Unchecked_Access;\n+         Next_Unequal : Node_Access := Node_Type'Unchecked_Access;\n       end record;\n \n       type List_Type is new Ada.Finalization.Limited_Controlled with record\n-         First, Last : Node_Access;\n-         Length      : Count_Type := 0;\n-         Max_Length  : Count_Type := 0;\n+         Header     : aliased Node_Type;\n+         Length     : Count_Type := 0;\n+         Max_Length : Count_Type := 0;\n       end record;\n \n       overriding procedure Finalize (List : in out List_Type);"}, {"sha": "f937b6878774f9e11f0687787428fdbc05247294", "filename": "gcc/ada/contracts.adb", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/142870f570d036ec06127bad47679743e68010f7/gcc%2Fada%2Fcontracts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/142870f570d036ec06127bad47679743e68010f7/gcc%2Fada%2Fcontracts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.adb?ref=142870f570d036ec06127bad47679743e68010f7", "patch": "@@ -660,7 +660,6 @@ package body Contracts is\n       Obj_Typ      : constant Entity_Id := Etype (Obj_Id);\n       AR_Val       : Boolean := False;\n       AW_Val       : Boolean := False;\n-      Encap_Id     : Entity_Id;\n       ER_Val       : Boolean := False;\n       EW_Val       : Boolean := False;\n       Items        : Node_Id;\n@@ -872,28 +871,6 @@ package body Contracts is\n                      Obj_Id);\n                end if;\n             end if;\n-\n-            --  A variable whose Part_Of pragma specifies a single concurrent\n-            --  type as encapsulator must be (SPARK RM 9.4):\n-            --    * Of a type that defines full default initialization, or\n-            --    * Declared with a default value, or\n-            --    * Imported\n-\n-            Encap_Id := Encapsulating_State (Obj_Id);\n-\n-            if Present (Encap_Id)\n-              and then Is_Single_Concurrent_Object (Encap_Id)\n-              and then not Has_Full_Default_Initialization (Etype (Obj_Id))\n-              and then not Has_Initial_Value (Obj_Id)\n-              and then not Is_Imported (Obj_Id)\n-            then\n-               Error_Msg_N (\"& requires full default initialization\", Obj_Id);\n-\n-               Error_Msg_Name_1 := Chars (Encap_Id);\n-               Error_Msg_N\n-                 (Fix_Msg (Encap_Id, \"\\object acts as constituent of single \"\n-                  & \"protected type %\"), Obj_Id);\n-            end if;\n          end if;\n       end if;\n \n@@ -1137,7 +1114,6 @@ package body Contracts is\n \n    procedure Analyze_Protected_Contract (Prot_Id : Entity_Id) is\n       Items : constant Node_Id := Contract (Prot_Id);\n-      Mode  : SPARK_Mode_Type;\n \n    begin\n       --  Do not analyze a contract multiple times\n@@ -1149,30 +1125,6 @@ package body Contracts is\n             Set_Analyzed (Items);\n          end if;\n       end if;\n-\n-      --  Due to the timing of contract analysis, delayed pragmas may be\n-      --  subject to the wrong SPARK_Mode, usually that of the enclosing\n-      --  context. To remedy this, restore the original SPARK_Mode of the\n-      --  related protected unit.\n-\n-      Save_SPARK_Mode_And_Set (Prot_Id, Mode);\n-\n-      --  A protected type must define full default initialization\n-      --  (SPARK RM 9.4). This check is relevant only when SPARK_Mode is on as\n-      --  it is not a standard Ada legality rule.\n-\n-      if SPARK_Mode = On\n-        and then not Has_Full_Default_Initialization (Prot_Id)\n-      then\n-         Error_Msg_N\n-           (\"protected type & must define full default initialization\",\n-            Prot_Id);\n-      end if;\n-\n-      --  Restore the SPARK_Mode of the enclosing context after all delayed\n-      --  pragmas have been analyzed.\n-\n-      Restore_SPARK_Mode (Mode);\n    end Analyze_Protected_Contract;\n \n    -------------------------------------------"}, {"sha": "35b08889ac20689da27f878c78469831abd6f813", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 0, "deletions": 104, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/142870f570d036ec06127bad47679743e68010f7/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/142870f570d036ec06127bad47679743e68010f7/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=142870f570d036ec06127bad47679743e68010f7", "patch": "@@ -9046,110 +9046,6 @@ package body Sem_Util is\n       end if;\n    end Has_Enabled_Property;\n \n-   -------------------------------------\n-   -- Has_Full_Default_Initialization --\n-   -------------------------------------\n-\n-   function Has_Full_Default_Initialization (Typ : Entity_Id) return Boolean is\n-      Arg  : Node_Id;\n-      Comp : Entity_Id;\n-      Prag : Node_Id;\n-\n-   begin\n-      --  A private type and its full view is fully default initialized when it\n-      --  is subject to pragma Default_Initial_Condition without an argument or\n-      --  with a non-null argument. Since any type may act as the full view of\n-      --  a private type, this check must be performed prior to the specialized\n-      --  tests below.\n-\n-      if Has_Default_Init_Cond (Typ)\n-        or else Has_Inherited_Default_Init_Cond (Typ)\n-      then\n-         Prag := Get_Pragma (Typ, Pragma_Default_Initial_Condition);\n-\n-         --  Pragma Default_Initial_Condition must be present if one of the\n-         --  related entity flags is set.\n-\n-         pragma Assert (Present (Prag));\n-         Arg := First (Pragma_Argument_Associations (Prag));\n-\n-         --  A non-null argument guarantees full default initialization\n-\n-         if Present (Arg) then\n-            return Nkind (Arg) /= N_Null;\n-\n-         --  Otherwise the missing argument defaults the pragma to \"True\" which\n-         --  is considered a non-null argument (see above).\n-\n-         else\n-            return True;\n-         end if;\n-      end if;\n-\n-      --  A scalar type is fully default initialized if it is subject to aspect\n-      --  Default_Value.\n-\n-      if Is_Scalar_Type (Typ) then\n-         return Has_Default_Aspect (Typ);\n-\n-      --  An array type is fully default initialized if its element type is\n-      --  scalar and the array type carries aspect Default_Component_Value or\n-      --  the element type is fully default initialized.\n-\n-      elsif Is_Array_Type (Typ) then\n-         return\n-           Has_Default_Aspect (Typ)\n-             or else Has_Full_Default_Initialization (Component_Type (Typ));\n-\n-      --  A protected type, record type or type extension is fully default\n-      --  initialized if all its components either carry an initialization\n-      --  expression or have a type that is fully default initialized. The\n-      --  parent type of a type extension must be fully default initialized.\n-\n-      elsif Is_Record_Type (Typ) or else Is_Protected_Type (Typ) then\n-\n-         --  Inspect all entities defined in the scope of the type, looking for\n-         --  uninitialized components.\n-\n-         Comp := First_Entity (Typ);\n-         while Present (Comp) loop\n-            if Ekind (Comp) = E_Component\n-              and then Comes_From_Source (Comp)\n-              and then No (Expression (Parent (Comp)))\n-              and then not Has_Full_Default_Initialization (Etype (Comp))\n-            then\n-               return False;\n-            end if;\n-\n-            Next_Entity (Comp);\n-         end loop;\n-\n-         --  Ensure that the parent type of a type extension is fully default\n-         --  initialized.\n-\n-         if Etype (Typ) /= Typ\n-           and then not Has_Full_Default_Initialization (Etype (Typ))\n-         then\n-            return False;\n-         end if;\n-\n-         --  If we get here, then all components and parent portion are fully\n-         --  default initialized.\n-\n-         return True;\n-\n-      --  A task type is fully default initialized by default\n-\n-      elsif Is_Task_Type (Typ) then\n-         return True;\n-\n-      --  Otherwise the type is not fully default initialized\n-\n-      else\n-         return False;\n-      end if;\n-   end Has_Full_Default_Initialization;\n-\n    --------------------\n    -- Has_Infinities --\n    --------------------"}, {"sha": "e868c83b2e6a94b26eb94b7a88ebdf04eaf3f50c", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/142870f570d036ec06127bad47679743e68010f7/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/142870f570d036ec06127bad47679743e68010f7/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=142870f570d036ec06127bad47679743e68010f7", "patch": "@@ -1034,19 +1034,6 @@ package Sem_Util is\n    --  Determine whether subprogram Subp_Id has an effectively volatile formal\n    --  parameter or returns an effectively volatile value.\n \n-   function Has_Full_Default_Initialization (Typ : Entity_Id) return Boolean;\n-   --  Determine whether type Typ defines \"full default initialization\" as\n-   --  specified by SPARK RM 3.1. To qualify as such, the type must be\n-   --    * A scalar type with specified Default_Value\n-   --    * An array-of-scalar type with specified Default_Component_Value\n-   --    * An array type whose element type defines full default initialization\n-   --    * A protected type, record type or type extension whose components\n-   --      either include a default expression or have a type which defines\n-   --      full default initialization. In the case of type extensions, the\n-   --      parent type defines full default initialization.\n-   --   * A task type\n-   --   * A private type whose Default_Initial_Condition is non-null\n-\n    function Has_Infinities (E : Entity_Id) return Boolean;\n    --  Determines if the range of the floating-point type E includes\n    --  infinities. Returns False if E is not a floating-point type."}]}