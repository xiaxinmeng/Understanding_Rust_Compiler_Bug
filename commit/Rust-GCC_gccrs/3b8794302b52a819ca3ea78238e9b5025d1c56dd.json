{"sha": "3b8794302b52a819ca3ea78238e9b5025d1c56dd", "node_id": "C_kwDOANBUbNoAKDNiODc5NDMwMmI1MmE4MTljYTNlYTc4MjM4ZTliNTAyNWQxYzU2ZGQ", "commit": {"author": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2022-06-24T06:15:08Z"}, "committer": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2022-06-24T06:15:08Z"}, "message": "PR target/105930: Split *xordi3_doubleword after reload on x86.\n\nThis patch addresses PR target/105930 which is an ia32 stack frame size\nregression in high-register pressure XOR-rich cryptography functions\nreported by Linus Torvalds.  The underlying problem is once the limited\nnumber of registers on the x86 are exhausted, the register allocator\nhas to decide which to spill, where some eviction choices lead to much\npoorer code, but these consequences are difficult to predict in advance.\n\nThe patch below, which splits xordi3_doubleword and iordi3_doubleword\nafter reload (instead of before), significantly reduces the amount of\nspill code and stack frame size, in what might appear to be an arbitrary\nchoice.\n\nMy explanation of this behaviour is that the mixing of pre-reload split\nSImode instructions and post-reload split DImode instructions is\nconfusing some of the heuristics used by reload.  One might think\nthat splitting early gives the register allocator more freedom to\nuse available registers, but in practice the constraint that double\nword values occupy consecutive registers (when ultimately used as a\nDImode value) is the greater constraint.  Instead, I believe in this\ncase, the pseudo registers used in memory addressing, appear to be\ndouble counted for split SImode instructions compared to unsplit\nDImode instructions.  For the reduced test case in comment #13, this\nleads to %eax being used to hold the long-lived argument pointer \"v\",\nblocking the use of the ax:dx pair for processing double word values.\nThe important lines are at the very top of the assembly output:\n\nGCC 11\t[use %ecx to address memory, require a 24-byte stack frame]\n        sub     esp, 24\n        mov     ecx, DWORD PTR [esp+40]\n\nGCC 12 [use %eax to address memory, require a 44-byte stack frame]\n        sub     esp, 44\n        mov     eax, DWORD PTR [esp+64]\n\n2022-06-24  Roger Sayle  <roger@nextmovesoftware.com>\n\t    Uro\u0161 Bizjak  <ubizjak@gmail.com>\n\ngcc/ChangeLog\n\tPR target/105930\n\t* config/i386/i386.md (*<any_or>di3_doubleword): Split after\n\treload.  Use rtx_equal_p to avoid creating memory-to-memory moves,\n\tand emit NOTE_INSN_DELETED if operand[2] is zero (i.e. with -O0).", "tree": {"sha": "0b38ea3270320c4f6b08ff807d0c2a259030ec86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b38ea3270320c4f6b08ff807d0c2a259030ec86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b8794302b52a819ca3ea78238e9b5025d1c56dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b8794302b52a819ca3ea78238e9b5025d1c56dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b8794302b52a819ca3ea78238e9b5025d1c56dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b8794302b52a819ca3ea78238e9b5025d1c56dd/comments", "author": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93070671eae44f24ba822383e17571a39257c637", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93070671eae44f24ba822383e17571a39257c637", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93070671eae44f24ba822383e17571a39257c637"}], "stats": {"total": 29, "additions": 21, "deletions": 8}, "files": [{"sha": "dd173f78508005fe6e36295eaafd71b887067ed4", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8794302b52a819ca3ea78238e9b5025d1c56dd/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8794302b52a819ca3ea78238e9b5025d1c56dd/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=3b8794302b52a819ca3ea78238e9b5025d1c56dd", "patch": "@@ -10539,22 +10539,30 @@\n   \"ix86_expand_binary_operator (<CODE>, <MODE>mode, operands); DONE;\")\n \n (define_insn_and_split \"*<code>di3_doubleword\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\")\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=ro,r\")\n \t(any_or:DI\n-\t (match_operand:DI 1 \"nonimmediate_operand\")\n-\t (match_operand:DI 2 \"x86_64_szext_general_operand\")))\n+\t (match_operand:DI 1 \"nonimmediate_operand\" \"0,0\")\n+\t (match_operand:DI 2 \"x86_64_szext_general_operand\" \"re,o\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"!TARGET_64BIT\n-   && ix86_binary_operator_ok (<CODE>, DImode, operands)\n-   && ix86_pre_reload_split ()\"\n+   && ix86_binary_operator_ok (<CODE>, DImode, operands)\"\n   \"#\"\n-  \"&& 1\"\n+  \"&& reload_completed\"\n   [(const_int 0)]\n {\n+  /* This insn may disappear completely when operands[2] == const0_rtx\n+     and operands[0] == operands[1], which requires a NOTE_INSN_DELETED.  */\n+  bool emit_insn_deleted_note_p = false;\n+\n   split_double_mode (DImode, &operands[0], 3, &operands[0], &operands[3]);\n \n   if (operands[2] == const0_rtx)\n-    emit_move_insn (operands[0], operands[1]);\n+    {\n+      if (!rtx_equal_p (operands[0], operands[1]))\n+\temit_move_insn (operands[0], operands[1]);\n+      else\n+\temit_insn_deleted_note_p = true;\n+    }\n   else if (operands[2] == constm1_rtx)\n     {\n       if (<CODE> == IOR)\n@@ -10566,7 +10574,12 @@\n     ix86_expand_binary_operator (<CODE>, SImode, &operands[0]);\n \n   if (operands[5] == const0_rtx)\n-    emit_move_insn (operands[3], operands[4]);\n+    {\n+      if (!rtx_equal_p (operands[3], operands[4]))\n+\temit_move_insn (operands[3], operands[4]);\n+      else if (emit_insn_deleted_note_p)\n+\temit_note (NOTE_INSN_DELETED);\n+    }\n   else if (operands[5] == constm1_rtx)\n     {\n       if (<CODE> == IOR)"}]}