{"sha": "2d319f3acef1e80d7bb288a6b5d1ae76f2968b45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQzMTlmM2FjZWYxZTgwZDdiYjI4OGE2YjVkMWFlNzZmMjk2OGI0NQ==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2019-09-17T07:59:29Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-09-17T07:59:29Z"}, "message": "[Ada] Avoid touching potentially nonexistent memory\n\n...in cases where the Val_2 might cross a page boundary, and the second\npage is now known to exist.\n\nCopy_Bitfield is still disabled in the compiler: no test possible.\n\n2019-09-17  Bob Duff  <duff@adacore.com>\n\ngcc/ada/\n\n\t* libgnat/s-bituti.adb (Get_Val_2, Set_Val_2): Use new routines\n\tfor getting and setting a Val_2, avoiding touching the second\n\thalf when that half might not exist.\n\t* exp_ch5.adb (Expand_Assign_Array_Loop_Or_Bitfield): Correct\n\ttests for potential volatile or independent components. In\n\tparticular, do not call Prefix unless we know it's a slice.\n\nFrom-SVN: r275771", "tree": {"sha": "55ea3a206daf26d327742af0ed5f06646e5e1029", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55ea3a206daf26d327742af0ed5f06646e5e1029"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d319f3acef1e80d7bb288a6b5d1ae76f2968b45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d319f3acef1e80d7bb288a6b5d1ae76f2968b45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d319f3acef1e80d7bb288a6b5d1ae76f2968b45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d319f3acef1e80d7bb288a6b5d1ae76f2968b45/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "38c4e50d8c738553de6f5e7a5fee3b55728ea457", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38c4e50d8c738553de6f5e7a5fee3b55728ea457", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38c4e50d8c738553de6f5e7a5fee3b55728ea457"}], "stats": {"total": 197, "additions": 158, "deletions": 39}, "files": [{"sha": "7220566d3c16b183c395c10ac1be045deebc1722", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d319f3acef1e80d7bb288a6b5d1ae76f2968b45/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d319f3acef1e80d7bb288a6b5d1ae76f2968b45/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2d319f3acef1e80d7bb288a6b5d1ae76f2968b45", "patch": "@@ -1,3 +1,12 @@\n+2019-09-17  Bob Duff  <duff@adacore.com>\n+\n+\t* libgnat/s-bituti.adb (Get_Val_2, Set_Val_2): Use new routines\n+\tfor getting and setting a Val_2, avoiding touching the second\n+\thalf when that half might not exist.\n+\t* exp_ch5.adb (Expand_Assign_Array_Loop_Or_Bitfield): Correct\n+\ttests for potential volatile or independent components. In\n+\tparticular, do not call Prefix unless we know it's a slice.\n+\n 2019-09-17  Dmitriy Anisimkov  <anisimko@adacore.com>\n \n \t* gsocket.h: Include sys/un.h."}, {"sha": "76e97fc9e185556af8b8766f226311f939f12128", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d319f3acef1e80d7bb288a6b5d1ae76f2968b45/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d319f3acef1e80d7bb288a6b5d1ae76f2968b45/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=2d319f3acef1e80d7bb288a6b5d1ae76f2968b45", "patch": "@@ -1440,18 +1440,31 @@ package body Exp_Ch5 is\n    is\n       Slices : constant Boolean :=\n         Nkind (Name (N)) = N_Slice or else Nkind (Expression (N)) = N_Slice;\n+      L_Prefix_Comp : constant Boolean :=\n+        --  True if the left-hand side is a slice of a component or slice\n+        Nkind (Name (N)) = N_Slice\n+        and then Nkind_In (Prefix (Name (N)),\n+                           N_Selected_Component,\n+                           N_Indexed_Component,\n+                           N_Slice);\n+      R_Prefix_Comp : constant Boolean :=\n+        --  Likewise for the right-hand side\n+        Nkind (Expression (N)) = N_Slice\n+        and then Nkind_In (Prefix (Expression (N)),\n+                           N_Selected_Component,\n+                           N_Indexed_Component,\n+                           N_Slice);\n    begin\n       --  Determine whether Copy_Bitfield is appropriate (will work, and will\n       --  be more efficient than component-by-component copy). Copy_Bitfield\n       --  doesn't work for reversed storage orders. It is efficient for slices\n       --  of bit-packed arrays. Copy_Bitfield can read and write bits that are\n       --  not part of the objects being copied, so we don't want to use it if\n       --  there are volatile or independent components. If the Prefix of the\n-      --  slice is a selected component (etc, see below), then it might be a\n-      --  component of an object with some other volatile or independent\n-      --  components, so we disable the optimization in that case as well.\n-      --  We could complicate this code by actually looking for such volatile\n-      --  and independent components.\n+      --  slice is a component or slice, then it might be a part of an object\n+      --  with some other volatile or independent components, so we disable the\n+      --  optimization in that case as well.  We could complicate this code by\n+      --  actually looking for such volatile and independent components.\n \n       --  Note that Expand_Assign_Array_Bitfield is disabled for now.\n \n@@ -1468,10 +1481,8 @@ package body Exp_Ch5 is\n         and then not Has_Volatile_Component (R_Type)\n         and then not Has_Independent_Components (L_Type)\n         and then not Has_Independent_Components (R_Type)\n-        and then not Nkind_In (Prefix (Name (N)),\n-                               N_Selected_Component,\n-                               N_Indexed_Component,\n-                               N_Slice)\n+        and then not L_Prefix_Comp\n+        and then not R_Prefix_Comp\n       then\n          return Expand_Assign_Array_Bitfield\n            (N, Larray, Rarray, L_Type, R_Type, Rev);"}, {"sha": "b425e9fb98bc29a681bb24cd5fab6c7f7bbdd1bb", "filename": "gcc/ada/libgnat/s-bituti.adb", "status": "modified", "additions": 129, "deletions": 30, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d319f3acef1e80d7bb288a6b5d1ae76f2968b45/gcc%2Fada%2Flibgnat%2Fs-bituti.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d319f3acef1e80d7bb288a6b5d1ae76f2968b45/gcc%2Fada%2Flibgnat%2Fs-bituti.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-bituti.adb?ref=2d319f3acef1e80d7bb288a6b5d1ae76f2968b45", "patch": "@@ -43,6 +43,31 @@ package body System.Bitfield_Utils is\n \n       Val_Bytes : constant Address := Address (Val'Size / Storage_Unit);\n \n+      --  A Val_2 can cross a memory page boundary (e.g. an 8-byte Val_2 that\n+      --  starts 4 bytes before the end of a page). If the bit field also\n+      --  crosses that boundary, then the second page is known to exist, and we\n+      --  can safely load or store the Val_2. On the other hand, if the bit\n+      --  field is entirely within the first half of the Val_2, then it is\n+      --  possible (albeit highly unlikely) that the second page does not\n+      --  exist, so we must load or store only the first half of the Val_2.\n+      --  Get_Val_2 and Set_Val_2 take care of all this.\n+\n+      function Get_Val_2\n+        (Src_Address : Address;\n+         Src_Offset : Bit_Offset;\n+         Size : Small_Size)\n+        return Val_2;\n+      --  Get the Val_2, taking care to only load the first half when\n+      --  necessary.\n+\n+      procedure Set_Val_2\n+        (Dest_Address : Address;\n+         Dest_Offset : Bit_Offset;\n+         V : Val_2;\n+         Size : Small_Size);\n+      --  Set the Val_2, taking care to only store the first half when\n+      --  necessary.\n+\n       --  Get_Bitfield and Set_Bitfield are helper functions that get/set small\n       --  bit fields -- the value fits in Val, and the bit field is placed\n       --  starting at some offset within the first half of a Val_2.\n@@ -56,11 +81,6 @@ package body System.Bitfield_Utils is\n       --  Returns the bit field in Src starting at Src_Offset, of the given\n       --  Size. If Size < Small_Size'Last, then high order bits are zero.\n \n-      function Get_Full_Bitfield\n-        (Src : Val_2; Src_Offset : Bit_Offset) return Val;\n-      --  Same as Get_Bitfield, except the Size is hardwired to the maximum\n-      --  allowed.\n-\n       function Set_Bitfield\n         (Src_Value : Val;\n          Dest : Val_2;\n@@ -71,6 +91,13 @@ package body System.Bitfield_Utils is\n       --  set to Src_Value. Src_Value must have high order bits (Size and\n       --  above) zero. The result is returned as the function result.\n \n+      procedure Set_Bitfield\n+        (Src_Value : Val;\n+         Dest_Address : Address;\n+         Dest_Offset : Bit_Offset;\n+         Size : Small_Size);\n+      --  This version takes the bit address and size of the destination.\n+\n       procedure Copy_Small_Bitfield\n         (Src_Address  : Address;\n          Src_Offset   : Bit_Offset;\n@@ -94,6 +121,69 @@ package body System.Bitfield_Utils is\n       --  bit address, because it copies forward (from lower to higher\n       --  bit addresses).\n \n+      function Get_Val_2\n+        (Src_Address : Address;\n+         Src_Offset : Bit_Offset;\n+         Size : Small_Size)\n+        return Val_2 is\n+      begin\n+         pragma Assert (Src_Address mod Val'Alignment = 0);\n+\n+         --  Bit field fits in first half; fetch just one Val. On little\n+         --  endian, we want that in the low half, but on big endian, we\n+         --  want it in the high half.\n+\n+         if Src_Offset + Size <= Val'Size then\n+            declare\n+               Result : aliased constant Val with\n+                 Import, Address => Src_Address;\n+            begin\n+               return (case Endian is\n+                  when Little => Val_2 (Result),\n+                  when Big => Shift_Left (Val_2 (Result), Val'Size));\n+            end;\n+\n+         --  Bit field crosses into the second half, so it's safe to fetch the\n+         --  whole Val_2.\n+\n+         else\n+            declare\n+               Result : aliased constant Val_2 with\n+                 Import, Address => Src_Address;\n+            begin\n+               return Result;\n+            end;\n+         end if;\n+      end Get_Val_2;\n+\n+      procedure Set_Val_2\n+        (Dest_Address : Address;\n+         Dest_Offset : Bit_Offset;\n+         V : Val_2;\n+         Size : Small_Size) is\n+      begin\n+         pragma Assert (Dest_Address mod Val'Alignment = 0);\n+\n+         --  Comments in Get_Val_2 apply, except we're storing instead of\n+         --  fetching.\n+\n+         if Dest_Offset + Size <= Val'Size then\n+            declare\n+               Dest : aliased Val with Import, Address => Dest_Address;\n+            begin\n+               Dest := (case Endian is\n+                  when Little => Val'Mod (V),\n+                  when Big => Val (Shift_Right (V, Val'Size)));\n+            end;\n+         else\n+            declare\n+               Dest : aliased Val_2 with Import, Address => Dest_Address;\n+            begin\n+               Dest := V;\n+            end;\n+         end if;\n+      end Set_Val_2;\n+\n       function Get_Bitfield\n         (Src : Val_2; Src_Offset : Bit_Offset; Size : Small_Size)\n          return Val\n@@ -110,12 +200,6 @@ package body System.Bitfield_Utils is\n          return Val (Temp2);\n       end Get_Bitfield;\n \n-      function Get_Full_Bitfield\n-        (Src : Val_2; Src_Offset : Bit_Offset) return Val is\n-      begin\n-         return Get_Bitfield (Src, Src_Offset, Size => Val'Size);\n-      end Get_Full_Bitfield;\n-\n       function Set_Bitfield\n         (Src_Value : Val;\n          Dest : Val_2;\n@@ -138,18 +222,31 @@ package body System.Bitfield_Utils is\n          return Result;\n       end Set_Bitfield;\n \n+      procedure Set_Bitfield\n+        (Src_Value : Val;\n+         Dest_Address : Address;\n+         Dest_Offset : Bit_Offset;\n+         Size : Small_Size)\n+      is\n+         Old_Dest : constant Val_2 :=\n+           Get_Val_2 (Dest_Address, Dest_Offset, Size);\n+         New_Dest : constant Val_2 :=\n+           Set_Bitfield (Src_Value, Old_Dest, Dest_Offset, Size);\n+      begin\n+         Set_Val_2 (Dest_Address, Dest_Offset, New_Dest, Size);\n+      end Set_Bitfield;\n+\n       procedure Copy_Small_Bitfield\n         (Src_Address  : Address;\n          Src_Offset   : Bit_Offset;\n          Dest_Address : Address;\n          Dest_Offset  : Bit_Offset;\n          Size         : Small_Size)\n       is\n-         Src : constant Val_2 with Import, Address => Src_Address;\n+         Src : constant Val_2 := Get_Val_2 (Src_Address, Src_Offset, Size);\n          V : constant Val := Get_Bitfield (Src, Src_Offset, Size);\n-         Dest : Val_2 with Import, Address => Dest_Address;\n       begin\n-         Dest := Set_Bitfield (V, Dest, Dest_Offset, Size);\n+         Set_Bitfield (V, Dest_Address, Dest_Offset, Size);\n       end Copy_Small_Bitfield;\n \n       --  Copy_Large_Bitfield does the main work. Copying aligned Vals is more\n@@ -168,9 +265,9 @@ package body System.Bitfield_Utils is\n       --      Address). Get_Bitfield and Set_Bitfield are used here.\n       --\n       --      Step 2:\n-      --      Loop, copying Vals. Get_Full_Bitfield is used to fetch a\n-      --      Val-sized bit field, but Set_Bitfield is not needed -- we can set\n-      --      the aligned Val with an array indexing.\n+      --      Loop, copying Vals. Get_Bitfield is used to fetch a Val-sized\n+      --      bit field, but Set_Bitfield is not needed -- we can set the\n+      --      aligned Val with an array indexing.\n       --\n       --      Step 3:\n       --      Copy remaining smaller-than-Val bits, if any\n@@ -216,13 +313,13 @@ package body System.Bitfield_Utils is\n \n             declare\n                Initial_Size : constant Small_Size := Val'Size - D_Off;\n-               Initial_Val_2 : constant Val_2 with Import, Address => S_Addr;\n+               Initial_Val_2 : constant Val_2 :=\n+                 Get_Val_2 (S_Addr, S_Off, Initial_Size);\n                Initial_Val : constant Val :=\n                  Get_Bitfield (Initial_Val_2, S_Off, Initial_Size);\n-               Initial_Dest : Val_2 with Import, Address => D_Addr;\n             begin\n-               Initial_Dest := Set_Bitfield\n-                 (Initial_Val, Initial_Dest, D_Off, Initial_Size);\n+               Set_Bitfield\n+                 (Initial_Val, D_Addr, D_Off, Initial_Size);\n \n                Sz := Sz - Initial_Size;\n                declare\n@@ -253,27 +350,29 @@ package body System.Bitfield_Utils is\n                   pragma Assert (Dest_Comp in Val);\n                   pragma Warnings (On);\n                   pragma Assert (Dest_Comp'Valid);\n-                  Src_V_2 : constant Val_2 with Import, Address => S_Addr;\n-                  Full_V : constant Val := Get_Full_Bitfield (Src_V_2, S_Off);\n+                  Src_V_2 : constant Val_2 :=\n+                    Get_Val_2 (S_Addr, S_Off, Val'Size);\n+                  Full_V : constant Val :=\n+                    Get_Bitfield (Src_V_2, S_Off, Val'Size);\n                begin\n                   Dest_Comp := Full_V;\n                   S_Addr := S_Addr + Val_Bytes;\n                   --  S_Off remains the same\n                end;\n             end loop;\n \n-            if Sz mod Val'Size /= 0 then\n+            Sz := Sz mod Val'Size;\n+            if Sz /= 0 then\n                --  Step 3:\n \n                declare\n-                  Final_Val_2 : constant Val_2 with Import, Address => S_Addr;\n+                  Final_Val_2 : constant Val_2 :=\n+                    Get_Val_2 (S_Addr, S_Off, Sz);\n                   Final_Val : constant Val :=\n-                    Get_Bitfield (Final_Val_2, S_Off, Sz mod Val'Size);\n-                  Final_Dest : Val_2  with Import,\n-                    Address => D_Addr + Dest_Arr'Length * Val_Bytes;\n+                    Get_Bitfield (Final_Val_2, S_Off, Sz);\n                begin\n-                  Final_Dest := Set_Bitfield\n-                    (Final_Val, Final_Dest, 0, Sz mod Val'Size);\n+                  Set_Bitfield\n+                    (Final_Val, D_Addr + Dest_Arr'Length * Val_Bytes, 0, Sz);\n                end;\n             end if;\n          end;"}]}