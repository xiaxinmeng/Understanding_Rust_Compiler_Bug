{"sha": "b767fc11d8fc76782a969535772caf9f6df95d68", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc2N2ZjMTFkOGZjNzY3ODJhOTY5NTM1NzcyY2FmOWY2ZGY5NWQ2OA==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2004-06-16T23:11:33Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2004-06-16T23:11:33Z"}, "message": "s390.c (struct machine_function): New member last_restore_gpr.\n\n\t* config/s390/s390.c (struct machine_function):  New member\n\tlast_restore_gpr.\n\t(s390_frame_info): Add BASE_USED and RETURN_ADDR_USED parameters.\n\tDo not modify machine->save_return_addr_p or regs_ever_live.\n\tFill in machine->last_restore_gpr.\n\t(s390_optimize_prolog): Use s390_frame_info to compute registers\n\tto save/restore, remove duplicated code.\n\t(s390_arg_frame_offset): Use s390_frame_info to compute frame\n\tsize, remove duplicated code.\n\t(s390_emit_prologue): Adapt s390_frame_info call.  Update\n\tmachine->save_return_addr_p and regs_ever_live.\n\t(s390_emit_epilogue): Use machine->last_restore_gpr instead of\n\tmachine->last_save_gpr.\n\nFrom-SVN: r83275", "tree": {"sha": "5c9c44f71a62ae0043526c48627ee887254bcf5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c9c44f71a62ae0043526c48627ee887254bcf5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b767fc11d8fc76782a969535772caf9f6df95d68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b767fc11d8fc76782a969535772caf9f6df95d68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b767fc11d8fc76782a969535772caf9f6df95d68", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b767fc11d8fc76782a969535772caf9f6df95d68/comments", "author": null, "committer": null, "parents": [{"sha": "16865eaaa8898e0ea0e87e8516a17d5f95ab471b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16865eaaa8898e0ea0e87e8516a17d5f95ab471b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16865eaaa8898e0ea0e87e8516a17d5f95ab471b"}], "stats": {"total": 247, "additions": 121, "deletions": 126}, "files": [{"sha": "0813d9260efbf016104bf59846a2ffb2d8d08596", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b767fc11d8fc76782a969535772caf9f6df95d68/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b767fc11d8fc76782a969535772caf9f6df95d68/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b767fc11d8fc76782a969535772caf9f6df95d68", "patch": "@@ -1,3 +1,19 @@\n+2004-06-16  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/s390.c (struct machine_function):  New member\n+\tlast_restore_gpr.\n+\t(s390_frame_info): Add BASE_USED and RETURN_ADDR_USED parameters.\n+\tDo not modify machine->save_return_addr_p or regs_ever_live.\n+\tFill in machine->last_restore_gpr.\n+\t(s390_optimize_prolog): Use s390_frame_info to compute registers\n+\tto save/restore, remove duplicated code.\n+\t(s390_arg_frame_offset): Use s390_frame_info to compute frame\n+\tsize, remove duplicated code.\n+\t(s390_emit_prologue): Adapt s390_frame_info call.  Update\n+\tmachine->save_return_addr_p and regs_ever_live.\n+\t(s390_emit_epilogue): Use machine->last_restore_gpr instead of\n+\tmachine->last_save_gpr.\n+\n 2004-06-16  Richard Henderson  <rth@redhat.com>\n \n \t* c-parse.in (if_stmt_locus): Remove."}, {"sha": "ed1eb50f83021c65b7bdcfe355e47858dc04e77f", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 105, "deletions": 126, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b767fc11d8fc76782a969535772caf9f6df95d68/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b767fc11d8fc76782a969535772caf9f6df95d68/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=b767fc11d8fc76782a969535772caf9f6df95d68", "patch": "@@ -213,6 +213,7 @@ struct machine_function GTY(())\n   int first_save_gpr;\n   int first_restore_gpr;\n   int last_save_gpr;\n+  int last_restore_gpr;\n \n   /* Size of stack frame.  */\n   HOST_WIDE_INT frame_size;\n@@ -242,7 +243,7 @@ static rtx find_ltrel_base (rtx);\n static void replace_ltrel_base (rtx *, rtx);\n static void s390_optimize_prolog (bool);\n static int find_unused_clobbered_reg (void);\n-static void s390_frame_info (void);\n+static void s390_frame_info (int, int);\n static rtx save_fpr (rtx, int, int);\n static rtx restore_fpr (rtx, int, int);\n static rtx save_gprs (rtx, int, int, int);\n@@ -4942,64 +4943,24 @@ s390_output_pool_entry (rtx exp, enum machine_mode mode, unsigned int align)\n static void\n s390_optimize_prolog (bool base_used)\n {\n-  int save_first, save_last, restore_first, restore_last;\n-  int i, j;\n   rtx insn, new_insn, next_insn;\n \n-  /* Recompute regs_ever_live data for special registers.  */\n+  /* Do a final recompute of the frame-related data.  */\n+\n+  s390_frame_info (base_used, cfun->machine->save_return_addr_p);\n   regs_ever_live[BASE_REGISTER] = base_used;\n   regs_ever_live[RETURN_REGNUM] = cfun->machine->save_return_addr_p;\n   regs_ever_live[STACK_POINTER_REGNUM] = cfun->machine->frame_size > 0;\n \n-\n-  /* Find first and last gpr to be saved.  */\n-\n-  for (i = 6; i < 16; i++)\n-    if (regs_ever_live[i])\n-      if (!global_regs[i]\n-\t  || i == STACK_POINTER_REGNUM\n-          || i == RETURN_REGNUM\n-          || i == BASE_REGISTER\n-          || (flag_pic && i == (int)PIC_OFFSET_TABLE_REGNUM))\n-\tbreak;\n-\n-  for (j = 15; j > i; j--)\n-    if (regs_ever_live[j])\n-      if (!global_regs[j]\n-\t  || j == STACK_POINTER_REGNUM\n-          || j == RETURN_REGNUM\n-          || j == BASE_REGISTER\n-          || (flag_pic && j == (int)PIC_OFFSET_TABLE_REGNUM))\n-\tbreak;\n-\n-  if (i == 16)\n-    {\n-      /* Nothing to save/restore.  */\n-      save_first = restore_first = -1;\n-      save_last = restore_last = -1;\n-    }\n-  else\n-    {\n-      /* Save/restore from i to j.  */\n-      save_first = restore_first = i;\n-      save_last = restore_last = j;\n-    }\n-\n-  /* Varargs functions need to save gprs 2 to 6.  */\n-  if (current_function_stdarg)\n-    {\n-      save_first = 2;\n-      if (save_last < 6)\n-        save_last = 6;\n-    }\n-\n-\n   /* If all special registers are in fact used, there's nothing we\n      can do, so no point in walking the insn list.  */\n-  if (i <= BASE_REGISTER && j >= BASE_REGISTER\n-      && (TARGET_CPU_ZARCH || (i <= RETURN_REGNUM && j >= RETURN_REGNUM)))\n-    return;\n \n+  if (cfun->machine->first_save_gpr <= BASE_REGISTER \n+      && cfun->machine->last_save_gpr >= BASE_REGISTER\n+      && (TARGET_CPU_ZARCH \n+          || (cfun->machine->first_save_gpr <= RETURN_REGNUM \n+              && cfun->machine->last_save_gpr >= RETURN_REGNUM)))\n+    return;\n \n   /* Search for prolog/epilog insns and replace them.  */\n \n@@ -5028,9 +4989,10 @@ s390_optimize_prolog (bool base_used)\n \t  if (first > BASE_REGISTER || last < BASE_REGISTER)\n \t    continue;\n \n-\t  if (save_first != -1)\n+\t  if (cfun->machine->first_save_gpr != -1)\n \t    {\n-\t      new_insn = save_gprs (base, off, save_first, save_last);\n+\t      new_insn = save_gprs (base, off, cfun->machine->first_save_gpr,\n+\t\t\t\t    cfun->machine->last_save_gpr);\n \t      new_insn = emit_insn_before (new_insn, insn);\n \t      INSN_ADDRESSES_NEW (new_insn, -1);\n \t    }\n@@ -5052,9 +5014,10 @@ s390_optimize_prolog (bool base_used)\n \t  if (GET_CODE (base) != REG || off < 0)\n \t    continue;\n \n-\t  if (save_first != -1)\n+\t  if (cfun->machine->first_save_gpr != -1)\n \t    {\n-\t      new_insn = save_gprs (base, off, save_first, save_last);\n+\t      new_insn = save_gprs (base, off, cfun->machine->first_save_gpr,\n+\t\t\t\t    cfun->machine->last_save_gpr);\n \t      new_insn = emit_insn_before (new_insn, insn);\n \t      INSN_ADDRESSES_NEW (new_insn, -1);\n \t    }\n@@ -5078,9 +5041,10 @@ s390_optimize_prolog (bool base_used)\n \t  if (first > BASE_REGISTER || last < BASE_REGISTER)\n \t    continue;\n \n-\t  if (restore_first != -1)\n+\t  if (cfun->machine->first_restore_gpr != -1)\n \t    {\n-\t      new_insn = restore_gprs (base, off, restore_first, restore_last);\n+\t      new_insn = restore_gprs (base, off, cfun->machine->first_restore_gpr,\n+\t\t\t\t       cfun->machine->last_restore_gpr);\n \t      new_insn = emit_insn_before (new_insn, insn);\n \t      INSN_ADDRESSES_NEW (new_insn, -1);\n \t    }\n@@ -5102,9 +5066,10 @@ s390_optimize_prolog (bool base_used)\n \t  if (GET_CODE (base) != REG || off < 0)\n \t    continue;\n \n-\t  if (restore_first != -1)\n+\t  if (cfun->machine->first_restore_gpr != -1)\n \t    {\n-\t      new_insn = restore_gprs (base, off, restore_first, restore_last);\n+\t      new_insn = restore_gprs (base, off, cfun->machine->first_restore_gpr,\n+\t\t\t\t       cfun->machine->last_restore_gpr);\n \t      new_insn = emit_insn_before (new_insn, insn);\n \t      INSN_ADDRESSES_NEW (new_insn, -1);\n \t    }\n@@ -5258,11 +5223,14 @@ find_unused_clobbered_reg (void)\n   return 0;\n }\n \n-/* Fill FRAME with info about frame of current function.  */\n+/* Fill cfun->machine with info about frame of current function.  \n+   BASE_USED and RETURN_ADDR_USED specify whether we assume the\n+   base and return address register will need to be saved.  */\n \n static void\n-s390_frame_info (void)\n+s390_frame_info (int base_used, int return_addr_used)\n {\n+  int live_regs[16];\n   int i, j;\n   HOST_WIDE_INT fsize = get_frame_size ();\n \n@@ -5283,59 +5251,65 @@ s390_frame_info (void)\n \n   /* Does function need to setup frame and save area.  */\n \n-  if (! current_function_is_leaf\n+  if (!current_function_is_leaf\n       || TARGET_TPF_PROFILING\n       || cfun->machine->frame_size > 0\n       || current_function_calls_alloca\n       || current_function_stdarg)\n     cfun->machine->frame_size += STARTING_FRAME_OFFSET;\n \n-  /* If we use the return register, we'll need to make sure\n-     it is going to be saved/restored.  */\n+  /* Find first and last gpr to be saved.  We trust regs_ever_live\n+     data, except that we don't save and restore global registers.\n \n-  if (!current_function_is_leaf\n-      || TARGET_TPF_PROFILING\n-      || regs_ever_live[RETURN_REGNUM])\n-    cfun->machine->save_return_addr_p = 1;\n+     Also, all registers with special meaning to the compiler need\n+     to be handled extra.  */\n \n-  /* Find first and last gpr to be saved.  Note that at this point,\n-     we assume the base register and -on S/390- the return register\n-     always need to be saved.  This is done because the usage of these\n-     register might change even after the prolog was emitted.\n-     If it turns out later that we really don't need them, the\n-     prolog/epilog code is modified again.  */\n+  for (i = 0; i < 16; i++)\n+    live_regs[i] = regs_ever_live[i] && !global_regs[i];\n \n-  regs_ever_live[BASE_REGISTER] = 1;\n-  if (!TARGET_CPU_ZARCH || cfun->machine->save_return_addr_p)\n-    regs_ever_live[RETURN_REGNUM] = 1;\n-  regs_ever_live[STACK_POINTER_REGNUM] = cfun->machine->frame_size > 0;\n+  if (flag_pic)\n+    live_regs[PIC_OFFSET_TABLE_REGNUM] = \n+    regs_ever_live[PIC_OFFSET_TABLE_REGNUM];\n \n-  for (i = 6; i < 16; i++)\n-    if (regs_ever_live[i])\n-      if (!global_regs[i]\n-\t  || i == STACK_POINTER_REGNUM\n-          || i == RETURN_REGNUM\n-          || i == BASE_REGISTER\n-          || (flag_pic && i == (int)PIC_OFFSET_TABLE_REGNUM))\n-\tbreak;\n+  live_regs[BASE_REGISTER] = base_used;\n+  live_regs[RETURN_REGNUM] = return_addr_used;\n+  live_regs[STACK_POINTER_REGNUM] = cfun->machine->frame_size > 0;\n \n+  for (i = 6; i < 16; i++)\n+    if (live_regs[i])\n+      break;\n   for (j = 15; j > i; j--)\n-    if (regs_ever_live[j])\n-      if (!global_regs[j]\n-\t  || j == STACK_POINTER_REGNUM\n-          || j == RETURN_REGNUM\n-          || j == BASE_REGISTER\n-          || (flag_pic && j == (int)PIC_OFFSET_TABLE_REGNUM))\n-\tbreak;\n+    if (live_regs[j])\n+      break;\n \n-  /* Save / Restore from gpr i to j.  */\n-  cfun->machine->first_save_gpr = i;\n-  cfun->machine->first_restore_gpr = i;\n-  cfun->machine->last_save_gpr  = j;\n+  if (i == 16)\n+    {\n+      /* Nothing to save/restore.  */\n+      cfun->machine->first_save_gpr = -1;\n+      cfun->machine->first_restore_gpr = -1;\n+      cfun->machine->last_save_gpr = -1;\n+      cfun->machine->last_restore_gpr = -1;\n+    }\n+  else\n+    {\n+      /* Save / Restore from gpr i to j.  */\n+      cfun->machine->first_save_gpr = i;\n+      cfun->machine->first_restore_gpr = i;\n+      cfun->machine->last_save_gpr = j;\n+      cfun->machine->last_restore_gpr = j;\n+    }\n \n   /* Varargs functions need to save gprs 2 to 6.  */\n   if (current_function_stdarg)\n-    cfun->machine->first_save_gpr = 2;\n+    {\n+      if (cfun->machine->first_save_gpr == -1\n+          || cfun->machine->first_save_gpr > 2)\n+        cfun->machine->first_save_gpr = 2;\n+\n+      if (cfun->machine->last_save_gpr == -1\n+          || cfun->machine->last_save_gpr < 6)\n+        cfun->machine->last_save_gpr = 6;\n+    }\n }\n \n /* Return offset between argument pointer and frame pointer\n@@ -5344,30 +5318,15 @@ s390_frame_info (void)\n HOST_WIDE_INT\n s390_arg_frame_offset (void)\n {\n-  HOST_WIDE_INT fsize = get_frame_size ();\n-  int save_fprs_p, i;\n+  /* See the comment in s390_emit_prologue about the assumptions we make\n+     whether or not the base and return address register need to be saved.  */\n+  int return_addr_used = !current_function_is_leaf\n+\t\t\t || TARGET_TPF_PROFILING\n+\t\t\t || regs_ever_live[RETURN_REGNUM]\n+\t\t\t || cfun->machine->save_return_addr_p;\n \n-  /* fprs 8 - 15 are caller saved for 64 Bit ABI.  */\n-  save_fprs_p = 0;\n-  if (TARGET_64BIT)\n-    for (i = 24; i < 32; i++)\n-      if (regs_ever_live[i] && !global_regs[i])\n-\t{\n-          save_fprs_p = 1;\n-\t  break;\n-\t}\n-\n-  fsize = fsize + save_fprs_p * 64;\n-\n-  /* Does function need to setup frame and save area.  */\n-\n-  if (! current_function_is_leaf\n-      || TARGET_TPF_PROFILING\n-      || fsize > 0\n-      || current_function_calls_alloca\n-      || current_function_stdarg)\n-    fsize += STARTING_FRAME_OFFSET;\n-  return fsize + STACK_POINTER_OFFSET;\n+  s390_frame_info (1, !TARGET_CPU_ZARCH || return_addr_used);\n+  return cfun->machine->frame_size + STACK_POINTER_OFFSET;\n }\n \n /* Emit insn to save fpr REGNUM at offset OFFSET relative\n@@ -5556,9 +5515,29 @@ s390_emit_prologue (void)\n   rtx temp_reg;\n   int i;\n \n-  /* Compute frame_info.  */\n+  /* At this point, we decide whether we'll need to save/restore the\n+     return address register.  This decision is final on zSeries machines;\n+     on S/390 it can still be overridden in s390_split_branches.  */\n+\n+  if (!current_function_is_leaf\n+      || TARGET_TPF_PROFILING\n+      || regs_ever_live[RETURN_REGNUM])\n+    cfun->machine->save_return_addr_p = 1;\n+\n+  /* Compute frame info.  Note that at this point, we assume the base \n+     register and -on S/390- the return register always need to be saved.\n+     This is done because the usage of these registers might change even \n+     after the prolog was emitted.  If it turns out later that we really \n+     don't need them, the prolog/epilog code is modified again.  */\n \n-  s390_frame_info ();\n+  s390_frame_info (1, !TARGET_CPU_ZARCH || cfun->machine->save_return_addr_p);\n+\n+  /* We need to update regs_ever_live to avoid data-flow problems.  */\n+\n+  regs_ever_live[BASE_REGISTER] = 1;\n+  regs_ever_live[RETURN_REGNUM] = !TARGET_CPU_ZARCH \n+\t\t\t\t  || cfun->machine->save_return_addr_p;\n+  regs_ever_live[STACK_POINTER_REGNUM] = cfun->machine->frame_size > 0;\n \n   /* Choose best register to use for temp use within prologue.\n      See below for why TPF must use the register 1.  */\n@@ -5736,7 +5715,7 @@ s390_emit_epilogue (bool sibcall)\n   if (cfun->machine->first_restore_gpr != -1)\n     {\n       area_bottom = cfun->machine->first_restore_gpr * UNITS_PER_WORD;\n-      area_top = (cfun->machine->last_save_gpr + 1) * UNITS_PER_WORD;\n+      area_top = (cfun->machine->last_restore_gpr + 1) * UNITS_PER_WORD;\n     }\n   else\n     {\n@@ -5834,7 +5813,7 @@ s390_emit_epilogue (bool sibcall)\n \t to stack location from where they get restored.  */\n \n       for (i = cfun->machine->first_restore_gpr;\n-\t   i <= cfun->machine->last_save_gpr;\n+\t   i <= cfun->machine->last_restore_gpr;\n \t   i++)\n \t{\n \t  /* These registers are special and need to be\n@@ -5862,7 +5841,7 @@ s390_emit_epilogue (bool sibcall)\n \n \t  if (cfun->machine->save_return_addr_p\n \t      || (cfun->machine->first_restore_gpr < BASE_REGISTER\n-\t\t  && cfun->machine->last_save_gpr > RETURN_REGNUM))\n+\t\t  && cfun->machine->last_restore_gpr > RETURN_REGNUM))\n \t    {\n \t      int return_regnum = find_unused_clobbered_reg();\n \t      if (!return_regnum)\n@@ -5885,7 +5864,7 @@ s390_emit_epilogue (bool sibcall)\n \n       insn = restore_gprs (frame_pointer, offset,\n \t\t\t   cfun->machine->first_restore_gpr,\n-\t\t\t   cfun->machine->last_save_gpr);\n+\t\t\t   cfun->machine->last_restore_gpr);\n       emit_insn (insn);\n     }\n "}]}