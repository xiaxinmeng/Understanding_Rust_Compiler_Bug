{"sha": "4f77a31b9e51f47b0145c7487f1ca5dd5711a3cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGY3N2EzMWI5ZTUxZjQ3YjAxNDVjNzQ4N2YxY2E1ZGQ1NzExYTNjYg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-09-02T05:32:43Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-09-02T05:32:43Z"}, "message": "(process_init_constructor): Handle ranges.\n\nFrom-SVN: r2023", "tree": {"sha": "48e155c3eecc515e04728428c6f6bc474911a7b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48e155c3eecc515e04728428c6f6bc474911a7b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f77a31b9e51f47b0145c7487f1ca5dd5711a3cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f77a31b9e51f47b0145c7487f1ca5dd5711a3cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f77a31b9e51f47b0145c7487f1ca5dd5711a3cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f77a31b9e51f47b0145c7487f1ca5dd5711a3cb/comments", "author": null, "committer": null, "parents": [{"sha": "d2e909818b53ae4fb56577b731fcfa2a89bbcfd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2e909818b53ae4fb56577b731fcfa2a89bbcfd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2e909818b53ae4fb56577b731fcfa2a89bbcfd4"}], "stats": {"total": 72, "additions": 67, "deletions": 5}, "files": [{"sha": "6f71cb6996c090d77b3dbef4c308c993952d6d98", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 67, "deletions": 5, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f77a31b9e51f47b0145c7487f1ca5dd5711a3cb/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f77a31b9e51f47b0145c7487f1ca5dd5711a3cb/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=4f77a31b9e51f47b0145c7487f1ca5dd5711a3cb", "patch": "@@ -4886,6 +4886,10 @@ process_init_constructor (type, init, elts, constant_value, constant_element,\n       tree min_index, max_index, current_index, members_index;\n       tree bound_type;\n       tree one;\n+      /* These are non-zero only within a range initializer.  */\n+      tree start_index = 0, end_index = 0;\n+      /* Within a range, this is the value for the elts in the range.  */\n+      tree range_val = 0;\n \n       /* If we have array bounds, set our bounds from that.  Otherwise,\n \t we have a lower bound of zero and an unknown upper bound.  Also\n@@ -4908,23 +4912,76 @@ process_init_constructor (type, init, elts, constant_value, constant_element,\n       /* Don't leave the loop based on index if the next item has an explicit\n \t index value that will override it. */\n \n-      for (current_index = min_index; tail != 0;\n+      for (current_index = min_index; tail != 0 || end_index;\n \t   current_index = fold (build (PLUS_EXPR, bound_type,\n \t\t\t\t\tcurrent_index, one)))\n \t{\n-\t  register tree next1;\n+\t  register tree next1 = 0;\n+\n+\t  /* Handle the case where we are inside of a range.\n+\t     current_index increments through the range,\n+\t     so just keep reusing the same element of TAIL\n+\t     until the end of the range.  */\n+\t  if (end_index != 0)\n+\t    {\n+\t      next1 = range_val;\n+\t      if (!tree_int_cst_lt (current_index, end_index))\n+\t\tend_index = 0;\n+\t    }\n \n \t  /* If this element specifies an index,\n \t     move to that index before storing it in the new list.  */\n-\t  if (TREE_PURPOSE (tail) != 0)\n+\t  else if (TREE_PURPOSE (tail) != 0)\n \t    {\n \t      int win = 0;\n \t      tree index = TREE_PURPOSE (tail);\n \n \t      if (index && TREE_CODE (index) == NON_LVALUE_EXPR)\n \t\tindex = TREE_OPERAND (index, 0);\n \n-\t      if (TREE_CODE (index) == IDENTIFIER_NODE)\n+\t      /* Begin a range.  */\n+\t      if (TREE_CODE (index) == TREE_LIST)\n+\t\t{\n+\t\t  start_index = TREE_PURPOSE (index);\n+\t\t  end_index = TREE_PURPOSE (TREE_CHAIN (index));\n+\n+\t\t  /* Expose constants.  */\n+\t\t  if (end_index && TREE_CODE (end_index) == NON_LVALUE_EXPR)\n+\t\t    end_index = TREE_OPERAND (end_index, 0);\n+\t\t  if (start_index && TREE_CODE (start_index) == NON_LVALUE_EXPR)\n+\t\t    start_index = TREE_OPERAND (start_index, 0);\n+\n+\t\t  if ((TREE_CODE (start_index) == IDENTIFIER_NODE) \n+\t\t      || (TREE_CODE (end_index) == IDENTIFIER_NODE))\n+\t\t    error (\"field name used as index in array initializer\");\n+\t\t  else if ((TREE_CODE (start_index) != INTEGER_CST)\n+\t\t\t   || (TREE_CODE (end_index) != INTEGER_CST))\n+\t\t    error (\"non-constant array index in initializer\");\n+\t\t  else if (tree_int_cst_lt (start_index, min_index)\n+\t\t\t   || (max_index && tree_int_cst_lt (max_index, start_index))\n+\t\t\t   || tree_int_cst_lt (end_index, min_index)\n+\t\t\t   || (max_index && tree_int_cst_lt (max_index, end_index)))\n+\t\t    error (\"array index out of range in initializer\");\n+\t\t  else if (tree_int_cst_lt (end_index, start_index))\n+\t\t    {\n+\t\t      /* If the range is empty, don't initialize any elements,\n+\t\t\t but do reset current_index for the next initializer\n+\t\t\t element.  */\n+\t\t      warning (\"empty array initializer range\");\n+\t\t      tail = TREE_CHAIN (tail);\n+\t\t      current_index = end_index;\n+\t\t      continue;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      current_index = start_index;\n+\t\t      win = 1;\n+\t\t      /* See if the first element is also the last.  */\n+\t\t      if (!tree_int_cst_lt (current_index, end_index))\n+\t\t\tend_index = 0;\n+\t\t    }\n+\t\t}\n+\t      else if (TREE_CODE (index) == IDENTIFIER_NODE)\n \t\terror (\"field name used as index in array initializer\");\n \t      else if (TREE_CODE (index) != INTEGER_CST)\n \t\terror (\"non-constant array index in initializer\");\n@@ -4942,7 +4999,9 @@ process_init_constructor (type, init, elts, constant_value, constant_element,\n \t    break;  /* Stop if we've indeed run out of elements. */\n \n \t  /* Now digest the value specified.  */\n-\t  if (TREE_VALUE (tail) != 0)\n+\t  if (next1 != 0)\n+\t    ;\n+\t  else if (TREE_VALUE (tail) != 0)\n \t    {\n \t      tree tail1 = tail;\n \n@@ -4978,6 +5037,9 @@ process_init_constructor (type, init, elts, constant_value, constant_element,\n \t      tail = TREE_CHAIN (tail);\n \t    }\n \n+\t  if (end_index != 0)\n+\t    range_val = next1;\n+\n \t  if (next1 == error_mark_node)\n \t    erroneous = 1;\n \t  else if (!TREE_CONSTANT (next1))"}]}