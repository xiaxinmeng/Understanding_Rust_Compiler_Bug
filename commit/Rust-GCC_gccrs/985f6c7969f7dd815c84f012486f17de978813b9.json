{"sha": "985f6c7969f7dd815c84f012486f17de978813b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTg1ZjZjNzk2OWY3ZGQ4MTVjODRmMDEyNDg2ZjE3ZGU5Nzg4MTNiOQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2015-12-09T22:15:47Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2015-12-09T22:15:47Z"}, "message": "trans.c (gfc_allocate_using_lib,gfc_deallocate_with_status): Introducing __asm__ __volatile__ (\"\":::\"memory\") after image control statements.\n\n2015-12-09  Tobias Burnus  <burnus@net-b.de>\n            Alessandro Fanfarillo <fanfarillo.gcc@gmail.com>\n\n        * trans.c (gfc_allocate_using_lib,gfc_deallocate_with_status):\n        Introducing __asm__ __volatile__ (\"\":::\"memory\")\n        after image control statements.\n        * trans-stmt.c  (gfc_trans_sync, gfc_trans_event_post_wait,\n        gfc_trans_lock_unlock, gfc_trans_critical): Ditto.\n        * trans-intrinsic.c (gfc_conv_intrinsic_caf_get,\n        conv_caf_send): Introducing __asm__ __volatile__ (\"\":::\"memory\")\n        after send, before get and around sendget.\n\n2015-12-09  Tobias Burnus  <burnus@net-b.de>\n            Alessandro Fanfarillo <fanfarillo.gcc@gmail.com>\n\n        * gfortran.dg/coarray_40.f90: New.\n\nCo-Authored-By: Alessandro Fanfarillo <fanfarillo.gcc@gmail.com>\n\nFrom-SVN: r231476", "tree": {"sha": "3c68836c67539e88ffe303acc01b9065d5ed4fa0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c68836c67539e88ffe303acc01b9065d5ed4fa0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/985f6c7969f7dd815c84f012486f17de978813b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/985f6c7969f7dd815c84f012486f17de978813b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/985f6c7969f7dd815c84f012486f17de978813b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/985f6c7969f7dd815c84f012486f17de978813b9/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ff70d83cea614853f2d893b39e0d69fd62a93af6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff70d83cea614853f2d893b39e0d69fd62a93af6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff70d83cea614853f2d893b39e0d69fd62a93af6"}], "stats": {"total": 135, "additions": 134, "deletions": 1}, "files": [{"sha": "f417aa8c2d01629e10960d68ec7df6a46bfaafc0", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/985f6c7969f7dd815c84f012486f17de978813b9/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/985f6c7969f7dd815c84f012486f17de978813b9/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=985f6c7969f7dd815c84f012486f17de978813b9", "patch": "@@ -1,3 +1,15 @@\n+2015-12-09  Tobias Burnus  <burnus@net-b.de>\n+\t    Alessandro Fanfarillo <fanfarillo.gcc@gmail.com>\n+\n+\t* trans.c (gfc_allocate_using_lib,gfc_deallocate_with_status):\n+\tIntroducing __asm__ __volatile__ (\"\":::\"memory\")\n+\tafter image control statements.\n+\t* trans-stmt.c \t(gfc_trans_sync, gfc_trans_event_post_wait,\n+\tgfc_trans_lock_unlock, gfc_trans_critical): Ditto.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_caf_get,\n+\tconv_caf_send): Introducing __asm__ __volatile__ (\"\":::\"memory\")\n+\tafter send, before get and around sendget.\n+\n 2015-12-09  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/68815"}, {"sha": "31bad3563185a7198bfeb5b6bf7495561c37a0a2", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/985f6c7969f7dd815c84f012486f17de978813b9/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/985f6c7969f7dd815c84f012486f17de978813b9/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=985f6c7969f7dd815c84f012486f17de978813b9", "patch": "@@ -1211,6 +1211,14 @@ gfc_conv_intrinsic_caf_get (gfc_se *se, gfc_expr *expr, tree lhs, tree lhs_kind,\n   if (lhs == NULL_TREE)\n     may_require_tmp = boolean_false_node;\n \n+  /* It guarantees memory consistency within the same segment */\n+  tmp = gfc_build_string_const (strlen (\"memory\")+1, \"memory\"),\n+  tmp = build5_loc (input_location, ASM_EXPR, void_type_node,\n+\t\t    gfc_build_string_const (1, \"\"), NULL_TREE, NULL_TREE,\n+\t\t    tree_cons (NULL_TREE, tmp, NULL_TREE), NULL_TREE);\n+  ASM_VOLATILE_P (tmp) = 1;\n+  gfc_add_expr_to_block (&se->pre, tmp);\n+\n   tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_get, 9,\n \t\t\t     token, offset, image_index, argse.expr, vec,\n \t\t\t     dst_var, kind, lhs_kind, may_require_tmp);\n@@ -1375,6 +1383,14 @@ conv_caf_send (gfc_code *code) {\n     {\n       tree rhs_token, rhs_offset, rhs_image_index;\n \n+      /* It guarantees memory consistency within the same segment */\n+      tmp = gfc_build_string_const (strlen (\"memory\")+1, \"memory\"),\n+\ttmp = build5_loc (input_location, ASM_EXPR, void_type_node,\n+\t\t\t  gfc_build_string_const (1, \"\"), NULL_TREE, NULL_TREE,\n+\t\t\t  tree_cons (NULL_TREE, tmp, NULL_TREE), NULL_TREE);\n+      ASM_VOLATILE_P (tmp) = 1;\n+      gfc_add_expr_to_block (&block, tmp);\n+\n       caf_decl = gfc_get_tree_for_caf_expr (rhs_expr);\n       if (TREE_CODE (TREE_TYPE (caf_decl)) == REFERENCE_TYPE)\n \tcaf_decl = build_fold_indirect_ref_loc (input_location, caf_decl);\n@@ -1390,6 +1406,15 @@ conv_caf_send (gfc_code *code) {\n   gfc_add_expr_to_block (&block, tmp);\n   gfc_add_block_to_block (&block, &lhs_se.post);\n   gfc_add_block_to_block (&block, &rhs_se.post);\n+\n+  /* It guarantees memory consistency within the same segment */\n+  tmp = gfc_build_string_const (strlen (\"memory\")+1, \"memory\"),\n+  tmp = build5_loc (input_location, ASM_EXPR, void_type_node,\n+\t\t    gfc_build_string_const (1, \"\"), NULL_TREE, NULL_TREE,\n+\t\t    tree_cons (NULL_TREE, tmp, NULL_TREE), NULL_TREE);\n+  ASM_VOLATILE_P (tmp) = 1;\n+  gfc_add_expr_to_block (&block, tmp);\n+\n   return gfc_finish_block (&block);\n }\n "}, {"sha": "72416d48bf4450e4804e243eb9c2a37daf09594a", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/985f6c7969f7dd815c84f012486f17de978813b9/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/985f6c7969f7dd815c84f012486f17de978813b9/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=985f6c7969f7dd815c84f012486f17de978813b9", "patch": "@@ -818,6 +818,15 @@ gfc_trans_lock_unlock (gfc_code *code, gfc_exec_op op)\n \t\t\t\t   errmsg, errmsg_len);\n       gfc_add_expr_to_block (&se.pre, tmp);\n \n+      /* It guarantees memory consistency within the same segment */\n+      tmp = gfc_build_string_const (strlen (\"memory\")+1, \"memory\"),\n+      tmp = build5_loc (input_location, ASM_EXPR, void_type_node,\n+\t\t\tgfc_build_string_const (1, \"\"), NULL_TREE, NULL_TREE,\n+\t\t\ttree_cons (NULL_TREE, tmp, NULL_TREE), NULL_TREE);\n+      ASM_VOLATILE_P (tmp) = 1;\n+\n+      gfc_add_expr_to_block (&se.pre, tmp);\n+\n       if (stat2 != NULL_TREE)\n \tgfc_add_modify (&se.pre, stat2,\n \t\t\tfold_convert (TREE_TYPE (stat2), stat));\n@@ -995,6 +1004,14 @@ gfc_trans_event_post_wait (gfc_code *code, gfc_exec_op op)\n \t\t\t       errmsg, errmsg_len);\n   gfc_add_expr_to_block (&se.pre, tmp);\n \n+  /* It guarantees memory consistency within the same segment */\n+  tmp = gfc_build_string_const (strlen (\"memory\")+1, \"memory\"),\n+  tmp = build5_loc (input_location, ASM_EXPR, void_type_node,\n+\t\t    gfc_build_string_const (1, \"\"), NULL_TREE, NULL_TREE,\n+\t\t    tree_cons (NULL_TREE, tmp, NULL_TREE), NULL_TREE);\n+  ASM_VOLATILE_P (tmp) = 1;\n+  gfc_add_expr_to_block (&se.pre, tmp);\n+\n   if (stat2 != NULL_TREE)\n     gfc_add_modify (&se.pre, stat2, fold_convert (TREE_TYPE (stat2), stat));\n \n@@ -1080,6 +1097,18 @@ gfc_trans_sync (gfc_code *code, gfc_exec_op type)\n \t\t\t       fold_convert (integer_type_node, images));\n     }\n \n+  /* Per F2008, 8.5.1, a SYNC MEMORY is implied by calling the\n+     image control statements SYNC IMAGES and SYNC ALL.  */\n+  if (flag_coarray == GFC_FCOARRAY_LIB)\n+    {\n+      tmp = gfc_build_string_const (strlen (\"memory\")+1, \"memory\"),\n+      tmp = build5_loc (input_location, ASM_EXPR, void_type_node,\n+\t\t\tgfc_build_string_const (1, \"\"), NULL_TREE, NULL_TREE,\n+\t\t\ttree_cons (NULL_TREE, tmp, NULL_TREE), NULL_TREE);\n+      ASM_VOLATILE_P (tmp) = 1;\n+      gfc_add_expr_to_block (&se.pre, tmp);\n+    }\n+\n   if (flag_coarray != GFC_FCOARRAY_LIB)\n     {\n       /* Set STAT to zero.  */\n@@ -1399,6 +1428,17 @@ gfc_trans_critical (gfc_code *code)\n \t\t\t\t null_pointer_node, null_pointer_node,\n \t\t\t\t null_pointer_node, integer_zero_node);\n       gfc_add_expr_to_block (&block, tmp);\n+\n+      /* It guarantees memory consistency within the same segment */\n+      tmp = gfc_build_string_const (strlen (\"memory\")+1, \"memory\"),\n+\ttmp = build5_loc (input_location, ASM_EXPR, void_type_node,\n+\t\t\t  gfc_build_string_const (1, \"\"),\n+\t\t\t  NULL_TREE, NULL_TREE,\n+\t\t\t  tree_cons (NULL_TREE, tmp, NULL_TREE),\n+\t\t\t  NULL_TREE);\n+      ASM_VOLATILE_P (tmp) = 1;\n+  \n+      gfc_add_expr_to_block (&block, tmp);\n     }\n \n   tmp = gfc_trans_code (code->block->next);\n@@ -1411,8 +1451,18 @@ gfc_trans_critical (gfc_code *code)\n \t\t\t\t null_pointer_node, null_pointer_node,\n \t\t\t\t integer_zero_node);\n       gfc_add_expr_to_block (&block, tmp);\n-    }\n \n+      /* It guarantees memory consistency within the same segment */\n+      tmp = gfc_build_string_const (strlen (\"memory\")+1, \"memory\"),\n+\ttmp = build5_loc (input_location, ASM_EXPR, void_type_node,\n+\t\t\t  gfc_build_string_const (1, \"\"),\n+\t\t\t  NULL_TREE, NULL_TREE,\n+\t\t\t  tree_cons (NULL_TREE, tmp, NULL_TREE),\n+\t\t\t  NULL_TREE);\n+      ASM_VOLATILE_P (tmp) = 1;\n+\n+      gfc_add_expr_to_block (&block, tmp);\n+    }\n \n   return gfc_finish_block (&block);\n }"}, {"sha": "19937436fcf8f09e05bce67fc029e5b3d02bc433", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/985f6c7969f7dd815c84f012486f17de978813b9/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/985f6c7969f7dd815c84f012486f17de978813b9/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=985f6c7969f7dd815c84f012486f17de978813b9", "patch": "@@ -746,6 +746,14 @@ gfc_allocate_using_lib (stmtblock_t * block, tree pointer, tree size,\n \t\t\t TREE_TYPE (pointer), pointer,\n \t\t\t fold_convert ( TREE_TYPE (pointer), tmp));\n   gfc_add_expr_to_block (block, tmp);\n+\n+  /* It guarantees memory consistency within the same segment */\n+  tmp = gfc_build_string_const (strlen (\"memory\")+1, \"memory\"),\n+  tmp = build5_loc (input_location, ASM_EXPR, void_type_node,\n+\t\t    gfc_build_string_const (1, \"\"), NULL_TREE, NULL_TREE,\n+\t\t    tree_cons (NULL_TREE, tmp, NULL_TREE), NULL_TREE);\n+  ASM_VOLATILE_P (tmp) = 1;\n+  gfc_add_expr_to_block (block, tmp);\n }\n \n \n@@ -1356,6 +1364,14 @@ gfc_deallocate_with_status (tree pointer, tree status, tree errmsg,\n \t     token, pstat, errmsg, errlen);\n       gfc_add_expr_to_block (&non_null, tmp);\n \n+      /* It guarantees memory consistency within the same segment */\n+      tmp = gfc_build_string_const (strlen (\"memory\")+1, \"memory\"),\n+      tmp = build5_loc (input_location, ASM_EXPR, void_type_node,\n+\t\t\tgfc_build_string_const (1, \"\"), NULL_TREE, NULL_TREE,\n+\t\t\ttree_cons (NULL_TREE, tmp, NULL_TREE), NULL_TREE);\n+      ASM_VOLATILE_P (tmp) = 1;\n+      gfc_add_expr_to_block (&non_null, tmp);\n+\n       if (status != NULL_TREE)\n \t{\n \t  tree stat = build_fold_indirect_ref_loc (input_location, status);"}, {"sha": "f09a875ec24a308b5782a2f45c3e14eeac0b9329", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/985f6c7969f7dd815c84f012486f17de978813b9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/985f6c7969f7dd815c84f012486f17de978813b9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=985f6c7969f7dd815c84f012486f17de978813b9", "patch": "@@ -1,3 +1,8 @@\n+2015-12-09  Tobias Burnus  <burnus@net-b.de>\n+\t    Alessandro Fanfarillo <fanfarillo.gcc@gmail.com>\n+\n+\t* gfortran.dg/coarray_40.f90: New.\n+\n 2015-12-08  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR lto/68811"}, {"sha": "84af50e7dadd4de8f9e1427124007dcc13e44d5b", "filename": "gcc/testsuite/gfortran.dg/coarray_40.f90", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/985f6c7969f7dd815c84f012486f17de978813b9/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_40.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/985f6c7969f7dd815c84f012486f17de978813b9/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_40.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_40.f90?ref=985f6c7969f7dd815c84f012486f17de978813b9", "patch": "@@ -0,0 +1,25 @@\n+! { dg-do run }\n+! { dg-options \"-fcoarray=lib -lcaf_single\" }\n+!\n+! Run-time test for memory consistency\n+!\n+! Contributed by Deepak Eachempati\n+\n+program cp_bug\n+    implicit none\n+    integer :: v1, v2, u[*]\n+    integer :: me\n+\n+    me = this_image()\n+\n+    u = 0\n+    v1 = 10\n+\n+    v1 = u[me]\n+\n+    ! v2 should get value in u (0)\n+    v2 = v1\n+\n+    if(v2 /= u) call abort()\n+\n+end program"}]}