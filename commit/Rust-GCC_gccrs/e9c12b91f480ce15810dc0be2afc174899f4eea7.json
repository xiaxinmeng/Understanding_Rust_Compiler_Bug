{"sha": "e9c12b91f480ce15810dc0be2afc174899f4eea7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTljMTJiOTFmNDgwY2UxNTgxMGRjMGJlMmFmYzE3NDg5OWY0ZWVhNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-11-25T15:14:27Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-11-25T15:14:27Z"}, "message": "[multiple changes]\n\n2015-11-25  Bob Duff  <duff@adacore.com>\n\n\t* sem_elab.adb (Check_Internal_Call_Continue): Code clean ups.\n\n2015-11-25  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* sem_util.ads (Has_Compatible_Alignment): Add Layout_Done\n\tparameter.\n\t* sem_util.adb (Has_Compatible_Alignment): Likewise.\n\t(Has_Compatible_Alignment_Internal): Likewise.\tDo not set the\n\tresult to Unknown for packed types if Layout_Done is true.\n\t* checks.adb (Apply_Address_Clause_Check): Adjust call and\n\tpass False to Has_Compatible_Alignment.\n\t* sem_ch13.adb (Validate_Address_Clauses): Likewise but pass True.\n\nFrom-SVN: r230877", "tree": {"sha": "096deb172e2cbea38717b92bb8db3a3c4f419122", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/096deb172e2cbea38717b92bb8db3a3c4f419122"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9c12b91f480ce15810dc0be2afc174899f4eea7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9c12b91f480ce15810dc0be2afc174899f4eea7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9c12b91f480ce15810dc0be2afc174899f4eea7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9c12b91f480ce15810dc0be2afc174899f4eea7/comments", "author": null, "committer": null, "parents": [{"sha": "3429710e69836c0eb5cf71c2f22ec7c6ca073db7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3429710e69836c0eb5cf71c2f22ec7c6ca073db7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3429710e69836c0eb5cf71c2f22ec7c6ca073db7"}], "stats": {"total": 125, "additions": 74, "deletions": 51}, "files": [{"sha": "19ddd9f90ceb9c87d24b914f5a8e20ca89aa195e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9c12b91f480ce15810dc0be2afc174899f4eea7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9c12b91f480ce15810dc0be2afc174899f4eea7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e9c12b91f480ce15810dc0be2afc174899f4eea7", "patch": "@@ -1,3 +1,18 @@\n+2015-11-25  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_elab.adb (Check_Internal_Call_Continue): Code clean ups.\n+\n+2015-11-25  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* sem_util.ads (Has_Compatible_Alignment): Add Layout_Done\n+\tparameter.\n+\t* sem_util.adb (Has_Compatible_Alignment): Likewise.\n+\t(Has_Compatible_Alignment_Internal): Likewise.\tDo not set the\n+\tresult to Unknown for packed types if Layout_Done is true.\n+\t* checks.adb (Apply_Address_Clause_Check): Adjust call and\n+\tpass False to Has_Compatible_Alignment.\n+\t* sem_ch13.adb (Validate_Address_Clauses): Likewise but pass True.\n+\n 2015-11-25  Vincent Celier  <celier@adacore.com>\n \n \t* gnatcmd.adb: When <target>-gnat is called with switch -P"}, {"sha": "a3ea4770c64d02d25f0d3f53975173e8aa8bbd1f", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9c12b91f480ce15810dc0be2afc174899f4eea7/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9c12b91f480ce15810dc0be2afc174899f4eea7/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=e9c12b91f480ce15810dc0be2afc174899f4eea7", "patch": "@@ -749,14 +749,15 @@ package body Checks is\n             end if;\n          end;\n \n-      --  If the expression has the form X'Address, then we can find out if\n-      --  the object X has an alignment that is compatible with the object E.\n-      --  If it hasn't or we don't know, we defer issuing the warning until\n-      --  the end of the compilation to take into account back end annotations.\n+      --  If the expression has the form X'Address, then we can find out if the\n+      --  object X has an alignment that is compatible with the object E. If it\n+      --  hasn't or we don't know, we defer issuing the warning until the end\n+      --  of the compilation to take into account back end annotations.\n \n       elsif Nkind (Expr) = N_Attribute_Reference\n         and then Attribute_Name (Expr) = Name_Address\n-        and then Has_Compatible_Alignment (E, Prefix (Expr)) = Known_Compatible\n+        and then\n+          Has_Compatible_Alignment (E, Prefix (Expr), False) = Known_Compatible\n       then\n          return;\n       end if;"}, {"sha": "688861e7e99dbae1119e6b2a89b7a3cc3159931a", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9c12b91f480ce15810dc0be2afc174899f4eea7/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9c12b91f480ce15810dc0be2afc174899f4eea7/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=e9c12b91f480ce15810dc0be2afc174899f4eea7", "patch": "@@ -13097,16 +13097,15 @@ package body Sem_Ch13 is\n                  and then X_Size > Uint_0\n                  and then X_Size > Y_Size\n                then\n-                  Error_Msg_NE\n-                    (\"??& overlays smaller object\", ACCR.N, ACCR.X);\n+                  Error_Msg_NE (\"??& overlays smaller object\", ACCR.N, ACCR.X);\n                   Error_Msg_N\n                     (\"\\??program execution may be erroneous\", ACCR.N);\n+\n                   Error_Msg_Uint_1 := X_Size;\n-                  Error_Msg_NE\n-                    (\"\\??size of & is ^\", ACCR.N, ACCR.X);\n+                  Error_Msg_NE (\"\\??size of & is ^\", ACCR.N, ACCR.X);\n+\n                   Error_Msg_Uint_1 := Y_Size;\n-                  Error_Msg_NE\n-                    (\"\\??size of & is ^\", ACCR.N, ACCR.Y);\n+                  Error_Msg_NE (\"\\??size of & is ^\", ACCR.N, ACCR.Y);\n \n                --  Check for inadequate alignment, both of the base object\n                --  and of the offset, if any. We only do this check if the\n@@ -13119,32 +13118,32 @@ package body Sem_Ch13 is\n \n                elsif not Alignment_Checks_Suppressed (ACCR.Y)\n                  and then Y_Alignment /= Uint_0\n-                 and then (Y_Alignment < X_Alignment\n-                             or else (ACCR.Off\n-                                        and then\n-                                          Nkind (Expr) = N_Attribute_Reference\n-                                        and then\n-                                          Attribute_Name (Expr) = Name_Address\n-                                        and then\n-                                          Has_Compatible_Alignment\n-                                            (ACCR.X, Prefix (Expr))\n-                                             /= Known_Compatible))\n+                 and then\n+                   (Y_Alignment < X_Alignment\n+                     or else\n+                       (ACCR.Off\n+                         and then Nkind (Expr) = N_Attribute_Reference\n+                         and then Attribute_Name (Expr) = Name_Address\n+                         and then Has_Compatible_Alignment\n+                                    (ACCR.X, Prefix (Expr), True) /=\n+                                      Known_Compatible))\n                then\n                   Error_Msg_NE\n-                    (\"??specified address for& may be inconsistent \"\n-                       & \"with alignment\", ACCR.N, ACCR.X);\n+                    (\"??specified address for& may be inconsistent with \"\n+                     & \"alignment\", ACCR.N, ACCR.X);\n                   Error_Msg_N\n                     (\"\\??program execution may be erroneous (RM 13.3(27))\",\n                      ACCR.N);\n+\n                   Error_Msg_Uint_1 := X_Alignment;\n-                  Error_Msg_NE\n-                    (\"\\??alignment of & is ^\", ACCR.N, ACCR.X);\n+                  Error_Msg_NE (\"\\??alignment of & is ^\", ACCR.N, ACCR.X);\n+\n                   Error_Msg_Uint_1 := Y_Alignment;\n-                  Error_Msg_NE\n-                    (\"\\??alignment of & is ^\", ACCR.N, ACCR.Y);\n+                  Error_Msg_NE (\"\\??alignment of & is ^\", ACCR.N, ACCR.Y);\n+\n                   if Y_Alignment >= X_Alignment then\n                      Error_Msg_N\n-                      (\"\\??but offset is not multiple of alignment\", ACCR.N);\n+                       (\"\\??but offset is not multiple of alignment\", ACCR.N);\n                   end if;\n                end if;\n             end if;"}, {"sha": "cc4a4fcdedec64abf05d39eabfd855ee7ca8a3fe", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9c12b91f480ce15810dc0be2afc174899f4eea7/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9c12b91f480ce15810dc0be2afc174899f4eea7/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=e9c12b91f480ce15810dc0be2afc174899f4eea7", "patch": "@@ -8368,13 +8368,15 @@ package body Sem_Util is\n    ------------------------------\n \n    function Has_Compatible_Alignment\n-     (Obj  : Entity_Id;\n-      Expr : Node_Id) return Alignment_Result\n+     (Obj         : Entity_Id;\n+      Expr        : Node_Id;\n+      Layout_Done : Boolean) return Alignment_Result\n    is\n       function Has_Compatible_Alignment_Internal\n-        (Obj     : Entity_Id;\n-         Expr    : Node_Id;\n-         Default : Alignment_Result) return Alignment_Result;\n+        (Obj         : Entity_Id;\n+         Expr        : Node_Id;\n+         Layout_Done : Boolean;\n+         Default     : Alignment_Result) return Alignment_Result;\n       --  This is the internal recursive function that actually does the work.\n       --  There is one additional parameter, which says what the result should\n       --  be if no alignment information is found, and there is no definite\n@@ -8387,9 +8389,10 @@ package body Sem_Util is\n       ---------------------------------------\n \n       function Has_Compatible_Alignment_Internal\n-        (Obj     : Entity_Id;\n-         Expr    : Node_Id;\n-         Default : Alignment_Result) return Alignment_Result\n+        (Obj         : Entity_Id;\n+         Expr        : Node_Id;\n+         Layout_Done : Boolean;\n+         Default     : Alignment_Result) return Alignment_Result\n       is\n          Result : Alignment_Result := Known_Compatible;\n          --  Holds the current status of the result. Note that once a value of\n@@ -8439,14 +8442,14 @@ package body Sem_Util is\n             then\n                Set_Result\n                  (Has_Compatible_Alignment_Internal\n-                    (Obj, Prefix (Expr), Known_Compatible));\n+                    (Obj, Prefix (Expr), Layout_Done, Known_Compatible));\n \n             --  In all other cases, we need a full check on the prefix\n \n             else\n                Set_Result\n                  (Has_Compatible_Alignment_Internal\n-                    (Obj, Prefix (Expr), Unknown));\n+                    (Obj, Prefix (Expr), Layout_Done, Unknown));\n             end if;\n          end Check_Prefix;\n \n@@ -8465,14 +8468,14 @@ package body Sem_Util is\n \n       begin\n          --  If Expr is a selected component, we must make sure there is no\n-         --  potentially troublesome component clause, and that the record is\n-         --  not packed.\n+         --  potentially troublesome component clause and that the record is\n+         --  not packed if the layout is not done.\n \n          if Nkind (Expr) = N_Selected_Component then\n \n-            --  Packed record always generate unknown alignment\n+            --  Packing generates unknown alignment if layout is not done\n \n-            if Is_Packed (Etype (Prefix (Expr))) then\n+            if Is_Packed (Etype (Prefix (Expr))) and then not Layout_Done then\n                Set_Result (Unknown);\n             end if;\n \n@@ -8483,17 +8486,17 @@ package body Sem_Util is\n \n          --  If Expr is an indexed component, we must make sure there is no\n          --  potentially troublesome Component_Size clause and that the array\n-         --  is not bit-packed.\n+         --  is not bit-packed if the layout is not done.\n \n          elsif Nkind (Expr) = N_Indexed_Component then\n             declare\n                Typ : constant Entity_Id := Etype (Prefix (Expr));\n                Ind : constant Node_Id   := First_Index (Typ);\n \n             begin\n-               --  Bit packed array always generates unknown alignment\n+               --  Packing generates unknown alignment if layout is not done\n \n-               if Is_Bit_Packed_Array (Typ) then\n+               if Is_Bit_Packed_Array (Typ) and then not Layout_Done then\n                   Set_Result (Unknown);\n                end if;\n \n@@ -8695,7 +8698,8 @@ package body Sem_Util is\n \n       --  Now do the internal call that does all the work\n \n-      return Has_Compatible_Alignment_Internal (Obj, Expr, Unknown);\n+      return\n+        Has_Compatible_Alignment_Internal (Obj, Expr, Layout_Done, Unknown);\n    end Has_Compatible_Alignment;\n \n    ----------------------"}, {"sha": "b37402ac0e2a58ca2cf42b79a39a0be9c7bc2036", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9c12b91f480ce15810dc0be2afc174899f4eea7/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9c12b91f480ce15810dc0be2afc174899f4eea7/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=e9c12b91f480ce15810dc0be2afc174899f4eea7", "patch": "@@ -991,17 +991,21 @@ package Sem_Util is\n    --  that the values are arranged in increasing order of problematicness.\n \n    function Has_Compatible_Alignment\n-     (Obj  : Entity_Id;\n-      Expr : Node_Id) return Alignment_Result;\n+     (Obj         : Entity_Id;\n+      Expr        : Node_Id;\n+      Layout_Done : Boolean) return Alignment_Result;\n    --  Obj is an object entity, and expr is a node for an object reference. If\n    --  the alignment of the object referenced by Expr is known to be compatible\n    --  with the alignment of Obj (i.e. is larger or the same), then the result\n    --  is Known_Compatible. If the alignment of the object referenced by Expr\n    --  is known to be less than the alignment of Obj, then Known_Incompatible\n    --  is returned. If neither condition can be reliably established at compile\n-   --  time, then Unknown is returned. This is used to determine if alignment\n-   --  checks are required for address clauses, and also whether copies must\n-   --  be made when objects are passed by reference.\n+   --  time, then Unknown is returned. If Layout_Done is True, the function can\n+   --  assume that the information on size and alignment of types and objects\n+   --  is present in the tree. This is used to determine if alignment checks\n+   --  are required for address clauses (Layout_Done is False in this case) as\n+   --  well as to issue appropriate warnings for them in the post compilation\n+   --  phase (Layout_Done is True in this case).\n    --\n    --  Note: Known_Incompatible does not mean that at run time the alignment\n    --  of Expr is known to be wrong for Obj, just that it can be determined"}]}