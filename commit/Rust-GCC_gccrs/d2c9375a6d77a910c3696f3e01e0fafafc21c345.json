{"sha": "d2c9375a6d77a910c3696f3e01e0fafafc21c345", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDJjOTM3NWE2ZDc3YTkxMGMzNjk2ZjNlMDFlMGZhZmFmYzIxYzM0NQ==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2006-11-17T23:15:29Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2006-11-17T23:15:29Z"}, "message": "reload1.c (reloads_unique_chain): New.\n\n* reload1.c (reloads_unique_chain): New.\n(reloads_conflict): Call it.\n\nFrom-SVN: r118953", "tree": {"sha": "cf353ee37fa3fdee81a2f7a5c7fec82e28b4a4b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf353ee37fa3fdee81a2f7a5c7fec82e28b4a4b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2c9375a6d77a910c3696f3e01e0fafafc21c345", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2c9375a6d77a910c3696f3e01e0fafafc21c345", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2c9375a6d77a910c3696f3e01e0fafafc21c345", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2c9375a6d77a910c3696f3e01e0fafafc21c345/comments", "author": null, "committer": null, "parents": [{"sha": "036a2b7a60782739d05a48d9968cdb8e2129b683", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/036a2b7a60782739d05a48d9968cdb8e2129b683", "html_url": "https://github.com/Rust-GCC/gccrs/commit/036a2b7a60782739d05a48d9968cdb8e2129b683"}], "stats": {"total": 53, "additions": 52, "deletions": 1}, "files": [{"sha": "f3c8b878653927abf4fe6225cce1101fc110fba0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2c9375a6d77a910c3696f3e01e0fafafc21c345/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2c9375a6d77a910c3696f3e01e0fafafc21c345/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d2c9375a6d77a910c3696f3e01e0fafafc21c345", "patch": "@@ -1,3 +1,8 @@\n+2006-11-17  DJ Delorie  <dj@redhat.com>\n+\n+\t* reload1.c (reloads_unique_chain): New.\n+\t(reloads_conflict): Call it.\n+\n 2006-11-17  Bob Wilson  <bob.wilson@acm.org>\n \n \t* config/xtensa/predicates.md (addsubx_operand): New."}, {"sha": "88b89feb8ff110f5c23c304d101b83df15378c37", "filename": "gcc/reload1.c", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2c9375a6d77a910c3696f3e01e0fafafc21c345/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2c9375a6d77a910c3696f3e01e0fafafc21c345/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=d2c9375a6d77a910c3696f3e01e0fafafc21c345", "patch": "@@ -4794,6 +4794,51 @@ reload_reg_reaches_end_p (unsigned int regno, int opnum, enum reload_type type)\n     }\n }\n \f\n+\n+/*  Returns whether R1 and R2 are uniquely chained: the value of one\n+    is used by the other, and that value is not used by any other\n+    reload for this insn.  This is used to partially undo the decision\n+    made in find_reloads when in the case of multiple\n+    RELOAD_FOR_OPERAND_ADDRESS reloads it converts all\n+    RELOAD_FOR_OPADDR_ADDR reloads into RELOAD_FOR_OPERAND_ADDRESS\n+    reloads.  This code tries to avoid the conflict created by that\n+    change.  It might be cleaner to explicitly keep track of which\n+    RELOAD_FOR_OPADDR_ADDR reload is associated with which\n+    RELOAD_FOR_OPERAND_ADDRESS reload, rather than to try to detect\n+    this after the fact. */\n+static bool\n+reloads_unique_chain_p (int r1, int r2)\n+{\n+  int i;\n+\n+  /* We only check input reloads.  */\n+  if (! rld[r1].in || ! rld[r2].in)\n+    return false;\n+\n+  /* Avoid anything with output reloads.  */\n+  if (rld[r1].out || rld[r2].out)\n+    return false;\n+\n+  /* \"chained\" means one reload is a component of the other reload,\n+     not the same as the other reload.  */\n+  if (rld[r1].opnum != rld[r2].opnum\n+      || rtx_equal_p (rld[r1].in, rld[r2].in)\n+      || rld[r1].optional || rld[r2].optional\n+      || ! (reg_mentioned_p (rld[r1].in, rld[r2].in)\n+\t    || reg_mentioned_p (rld[r2].in, rld[r1].in)))\n+    return false;\n+\n+  for (i = 0; i < n_reloads; i ++)\n+    /* Look for input reloads that aren't our two */\n+    if (i != r1 && i != r2 && rld[i].in)\n+      {\n+\t/* If our reload is mentioned at all, it isn't a simple chain.  */\n+\tif (reg_mentioned_p (rld[r1].in, rld[i].in))\n+\t  return false;\n+      }\n+  return true;\n+}\n+\n /* Return 1 if the reloads denoted by R1 and R2 cannot share a register.\n    Return 0 otherwise.\n \n@@ -4842,7 +4887,8 @@ reloads_conflict (int r1, int r2)\n \n     case RELOAD_FOR_OPERAND_ADDRESS:\n       return (r2_type == RELOAD_FOR_INPUT || r2_type == RELOAD_FOR_INSN\n-\t      || r2_type == RELOAD_FOR_OPERAND_ADDRESS);\n+\t      || (r2_type == RELOAD_FOR_OPERAND_ADDRESS\n+\t\t  && !reloads_unique_chain_p (r1, r2)));\n \n     case RELOAD_FOR_OPADDR_ADDR:\n       return (r2_type == RELOAD_FOR_INPUT"}]}