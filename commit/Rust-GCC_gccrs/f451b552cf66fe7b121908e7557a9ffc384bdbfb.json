{"sha": "f451b552cf66fe7b121908e7557a9ffc384bdbfb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQ1MWI1NTJjZjY2ZmU3YjEyMTkwOGU3NTU3YTlmZmMzODRiZGJmYg==", "commit": {"author": {"name": "David S. Miller", "email": "davem@redhat.com", "date": "2002-04-09T14:52:03Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "2002-04-09T14:52:03Z"}, "message": "sparc.c (sparc_extra_constraint_check): New function, implementing EXTRA_CONSTRAINTS.\n\n2002-04-09  David S. Miller  <davem@redhat.com>\n\n\t* config/sparc/sparc.c (sparc_extra_constraint_check): New\n\tfunction, implementing EXTRA_CONSTRAINTS.  For memory constraints,\n\tallow reloading pseudos.\n\t* config/sparc/sparc.h (EXTRA_CONSTRAINTS): Use it.\n\t* config/sparc/sparc-protos.h: Declare it.\n\n\t* config/sparc/sparc.c (const64_is_2insns): Kill signed vs.\n\tunsigned comparison warning.\n\t(output_restore_regs): Mark leaf_function as unused.\n\nFrom-SVN: r52080", "tree": {"sha": "efa0a6f3d5c2bc42fc719890f937e9b7962f8061", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/efa0a6f3d5c2bc42fc719890f937e9b7962f8061"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f451b552cf66fe7b121908e7557a9ffc384bdbfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f451b552cf66fe7b121908e7557a9ffc384bdbfb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f451b552cf66fe7b121908e7557a9ffc384bdbfb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f451b552cf66fe7b121908e7557a9ffc384bdbfb/comments", "author": null, "committer": null, "parents": [{"sha": "cd6af0c13a345daa0d71484864072b26363d0523", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd6af0c13a345daa0d71484864072b26363d0523", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd6af0c13a345daa0d71484864072b26363d0523"}], "stats": {"total": 120, "additions": 86, "deletions": 34}, "files": [{"sha": "c8dbbaf2c5ea7b94d8263309cc6c5000b6bf5127", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f451b552cf66fe7b121908e7557a9ffc384bdbfb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f451b552cf66fe7b121908e7557a9ffc384bdbfb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f451b552cf66fe7b121908e7557a9ffc384bdbfb", "patch": "@@ -1,3 +1,15 @@\n+2002-04-09  David S. Miller  <davem@redhat.com>\n+\n+\t* config/sparc/sparc.c (sparc_extra_constraint_check): New\n+\tfunction, implementing EXTRA_CONSTRAINTS.  For memory constraints,\n+\tallow reloading pseudos.\n+\t* config/sparc/sparc.h (EXTRA_CONSTRAINTS): Use it.\n+\t* config/sparc/sparc-protos.h: Declare it.\n+\n+\t* config/sparc/sparc.c (const64_is_2insns): Kill signed vs.\n+\tunsigned comparison warning.\n+\t(output_restore_regs): Mark leaf_function as unused.\n+\n Tue Apr  9 09:35:45 2002  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* expr.c (is_aligning_offset): New function."}, {"sha": "27359df462f4ab60a9883df9b9face4401b5d62c", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f451b552cf66fe7b121908e7557a9ffc384bdbfb/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f451b552cf66fe7b121908e7557a9ffc384bdbfb/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=f451b552cf66fe7b121908e7557a9ffc384bdbfb", "patch": "@@ -117,6 +117,7 @@ extern char *sparc_v8plus_shift PARAMS ((rtx *, rtx, const char *));\n    32 bits of REG are 0 before INSN.  */   \n extern int sparc_check_64 PARAMS ((rtx, rtx));\n extern rtx gen_df_reg PARAMS ((rtx, int));\n+extern int sparc_extra_constraint_check PARAMS ((rtx, char, int));\n #endif /* RTX_CODE */\n \n #endif /* __SPARC_PROTOS_H__ */"}, {"sha": "f7c28a70dc15132d53555f4e0f55726b01a3cbe2", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 64, "deletions": 2, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f451b552cf66fe7b121908e7557a9ffc384bdbfb/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f451b552cf66fe7b121908e7557a9ffc384bdbfb/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=f451b552cf66fe7b121908e7557a9ffc384bdbfb", "patch": "@@ -1861,7 +1861,7 @@ const64_is_2insns (high_bits, low_bits)\n   int highest_bit_set, lowest_bit_set, all_bits_between_are_set;\n \n   if (high_bits == 0\n-      || high_bits == -1)\n+      || high_bits == 0xffffffff)\n     return 1;\n \n   analyze_64bit_constant (high_bits, low_bits,\n@@ -3647,7 +3647,7 @@ sparc_nonflat_function_prologue (file, size, leaf_function)\n static void\n output_restore_regs (file, leaf_function)\n      FILE *file;\n-     int leaf_function;\n+     int leaf_function ATTRIBUTE_UNUSED;\n {\n   int offset, n_regs;\n   const char *base;\n@@ -8609,3 +8609,65 @@ sparc_elf_asm_named_section (name, flags)\n   fputc ('\\n', asm_out_file);\n }\n #endif /* OBJECT_FORMAT_ELF */\n+\n+int\n+sparc_extra_constraint_check (op, c, strict)\n+     rtx op;\n+     char c;\n+     int strict;\n+{\n+  int reload_ok_mem;\n+\n+  if (TARGET_ARCH64\n+      && (c == 'T' || c == 'U'))\n+    return 0;\n+\n+  switch (c)\n+    {\n+    case 'Q':\n+      return fp_sethi_p (op);\n+\n+    case 'R':\n+      return fp_mov_p (op);\n+\n+    case 'S':\n+      return fp_high_losum_p (op);\n+\n+    case 'U':\n+      if (! strict\n+\t  || (GET_CODE (op) == REG\n+\t      && (REGNO (op) < FIRST_PSEUDO_REGISTER\n+\t\t  || reg_renumber[REGNO (op)] >= 0)))\n+\treturn register_ok_for_ldd (op);\n+\n+      return 0;\n+\n+    case 'W':\n+    case 'T':\n+      break;\n+\n+    default:\n+      return 0;\n+    }\n+\n+  /* Our memory extra constraints have to emulate the\n+     behavior of 'm' and 'o' in order for reload to work\n+     correctly.  */\n+  if (GET_CODE (op) == MEM)\n+    {\n+      reload_ok_mem = 0;\n+      if ((TARGET_ARCH64 || mem_min_alignment (op, 8))\n+\t  && (! strict\n+\t      || strict_memory_address_p (Pmode, XEXP (op, 0))))\n+\treload_ok_mem = 1;\n+    }\n+  else\n+    {\n+      reload_ok_mem = (reload_in_progress\n+\t\t       && GET_CODE (op) == REG\n+\t\t       && REGNO (op) >= FIRST_PSEUDO_REGISTER\n+\t\t       && reg_renumber [REGNO (op)] < 0);\n+    }\n+\n+  return reload_ok_mem;\n+}"}, {"sha": "3ebe6267e6381e442f97a664c1bc94a6152c9c2a", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 9, "deletions": 32, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f451b552cf66fe7b121908e7557a9ffc384bdbfb/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f451b552cf66fe7b121908e7557a9ffc384bdbfb/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=f451b552cf66fe7b121908e7557a9ffc384bdbfb", "patch": "@@ -2104,12 +2104,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n    'W' handles the memory operand when moving operands in/out\n        of 'e' constraint floating point registers.  */\n \n-#define EXTRA_CONSTRAINT_BASE(OP, C)   \\\n-   ((C) == 'Q' ? fp_sethi_p(OP)        \\\n-    : (C) == 'R' ? fp_mov_p(OP)        \\\n-    : (C) == 'S' ? fp_high_losum_p(OP) \\\n-    : 0)\n-\n #ifndef REG_OK_STRICT\n \n /* Nonzero if X is a hard reg that can be used as an index\n@@ -2124,18 +2118,13 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define REG_OK_FOR_BASE_P(X)  REG_OK_FOR_INDEX_P (X)\n \n /* 'T', 'U' are for aligned memory loads which aren't needed for arch64.\n-   'W' is like 'T' but is assumed true on arch64.  */\n-\n-#define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\\\n-   (EXTRA_CONSTRAINT_BASE(OP, C)                        \\\n-    || ((! TARGET_ARCH64 && (C) == 'T')\t\t\t\\\n-        ? (mem_min_alignment (OP, 8))\t\t\t\\\n-        : ((! TARGET_ARCH64 && (C) == 'U')\t\t\\\n-            ? (register_ok_for_ldd (OP))\t\t\\\n-            : ((C) == 'W'\t\t\t\t\\\n-\t       ? ((TARGET_ARCH64 && GET_CODE (OP) == MEM) \\\n-\t          || mem_min_alignment (OP, 8)) \\\n-\t       : 0))))\n+   'W' is like 'T' but is assumed true on arch64.\n+\n+   Remember to accept pseudo-registers for memory constraints if reload is\n+   in progress.  */\n+\n+#define EXTRA_CONSTRAINT(OP, C) \\\n+\tsparc_extra_constraint_check(OP, C, 0)\n \n #else\n \n@@ -2144,20 +2133,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* Nonzero if X is a hard reg that can be used as a base reg.  */\n #define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n \n-#define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\\\n-   (EXTRA_CONSTRAINT_BASE(OP, C)                        \\\n-    || ((! TARGET_ARCH64 && (C) == 'T')\t\t\t\\\n-        ? mem_min_alignment (OP, 8) && strict_memory_address_p (Pmode, XEXP (OP, 0)) \\\n-        : ((! TARGET_ARCH64 && (C) == 'U')\t\t\\\n-           ? (GET_CODE (OP) == REG\t\t\t\\\n-              && (REGNO (OP) < FIRST_PSEUDO_REGISTER\t\\\n-\t          || reg_renumber[REGNO (OP)] >= 0)\t\\\n-              && register_ok_for_ldd (OP))\t\t\\\n-           : ((C) == 'W'\t\t\t\t\\\n-\t      ? (((TARGET_ARCH64 && GET_CODE (OP) == MEM) \\\n-\t\t  || mem_min_alignment (OP, 8))\t\t\\\n-                 && strict_memory_address_p (Pmode, XEXP (OP, 0))) \\\n-\t      : 0))))\n+#define EXTRA_CONSTRAINT(OP, C) \\\n+\tsparc_extra_constraint_check(OP, C, 1)\n \n #endif\n \f"}]}