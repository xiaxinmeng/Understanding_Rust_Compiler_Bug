{"sha": "a97901e608d0e3233e28a6d8e39d3124d661a650", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTk3OTAxZTYwOGQwZTMyMzNlMjhhNmQ4ZTM5ZDMxMjRkNjYxYTY1MA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-12-16T17:50:29Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-12-16T17:50:29Z"}, "message": "Makefile.in (INTREGRATE_H): Rename to INTEGRATE_H.\n\n\t* Makefile.in (INTREGRATE_H): Rename to INTEGRATE_H.\n\t* function.c (insert_block_after_note): Remove.\n\t(retrofit_block): Likewise.\n\t(identify_blocks): Fix indentation.\n\t(reorder_blocks): Don't NULL out NOTE_SOURCE_FILE for a\n\tNOTE_INSN_BLOCK_BEG or NOTE_INSN_BLOCK_END.\n\t* function.h (insert_block_after_note): Remove prototype.\n\t(retrofit_block): Likewise.\n\t* integrate.c (expand_inline_function): Don't call\n\tfind_loop_tree_blocks.  Use expand_start_bindings_and_block, not\n\tjust expand_start_bindings.  Use the block_map to remap old\n\tNOTE_BLOCKs to new ones.\n\t(integrate_decl_tree): Keep track of remapped blocks.\n\t* integrate.h (struct inline_remap): Add block_map.\n\t* stmt.c (expand_fixup): Don't try to retrofit_blocks.  Just set\n\tNOTE_BLOCK on the notes.\n\t(expand_start_bindings): Rename to ...\n\t(expand_start_bindings_and_block): Add parameter.  Set NOTE_BLOCK.\n\t(expand_end_bindings): Set NOTE_BLOCK.\n\t* toplev.c (rest_of_compilation): In function-at-a-time-mode,\n\treconstruct the BLOCK tree.\n\t* tree.h (expand_start_bindings): Macroize.  Call ...\n\t(expand_start_bindings_and_block): New function.\n\n\t* optimize.c (struct inline_data): Remove scope_stmt.\n\t(remap_block): Don't use insert_block_after_note.  Don't update\n\tscope_stmt.\n\t(expand_call_inline): Don't update scope_stmt.\n\t(optimize_function): Don't initialize scope_stmt.\n\t* semantics.c (expand_stmt): Set NOTE_BLOCK for newly emitted\n\tNOTE_INSN_BLOCK_BEG/NOTE_INSN_BLOCK_END notes.\n\nFrom-SVN: r30982", "tree": {"sha": "0e496457c98d2aabb71fdf3add8cb1bb884dc210", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e496457c98d2aabb71fdf3add8cb1bb884dc210"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a97901e608d0e3233e28a6d8e39d3124d661a650", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a97901e608d0e3233e28a6d8e39d3124d661a650", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a97901e608d0e3233e28a6d8e39d3124d661a650", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a97901e608d0e3233e28a6d8e39d3124d661a650/comments", "author": null, "committer": null, "parents": [{"sha": "0d9484c5ad47e319a075c5c091634b8adc3b9412", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d9484c5ad47e319a075c5c091634b8adc3b9412", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d9484c5ad47e319a075c5c091634b8adc3b9412"}], "stats": {"total": 333, "additions": 189, "deletions": 144}, "files": [{"sha": "5473179ef5488d199475c308bf182d6d23240605", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a97901e608d0e3233e28a6d8e39d3124d661a650/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a97901e608d0e3233e28a6d8e39d3124d661a650/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a97901e608d0e3233e28a6d8e39d3124d661a650", "patch": "@@ -1,3 +1,29 @@\n+1999-12-16  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* Makefile.in (INTREGRATE_H): Rename to INTEGRATE_H.\n+\t* function.c (insert_block_after_note): Remove.\n+\t(retrofit_block): Likewise.\n+\t(identify_blocks): Fix indentation.\n+\t(reorder_blocks): Don't NULL out NOTE_SOURCE_FILE for a\n+\tNOTE_INSN_BLOCK_BEG or NOTE_INSN_BLOCK_END.\n+\t* function.h (insert_block_after_note): Remove prototype.\n+\t(retrofit_block): Likewise.\n+\t* integrate.c (expand_inline_function): Don't call\n+\tfind_loop_tree_blocks.  Use expand_start_bindings_and_block, not\n+\tjust expand_start_bindings.  Use the block_map to remap old\n+\tNOTE_BLOCKs to new ones.\n+\t(integrate_decl_tree): Keep track of remapped blocks.\n+\t* integrate.h (struct inline_remap): Add block_map.\n+\t* stmt.c (expand_fixup): Don't try to retrofit_blocks.  Just set\n+\tNOTE_BLOCK on the notes.\n+\t(expand_start_bindings): Rename to ...\n+\t(expand_start_bindings_and_block): Add parameter.  Set NOTE_BLOCK.\n+\t(expand_end_bindings): Set NOTE_BLOCK.\n+\t* toplev.c (rest_of_compilation): In function-at-a-time-mode,\n+\treconstruct the BLOCK tree.\n+\t* tree.h (expand_start_bindings): Macroize.  Call ...\n+\t(expand_start_bindings_and_block): New function.\n+\t\n 1999-12-16  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/sparc/sparc.c (print_operand): Cast fprintf arguments"}, {"sha": "6f367cb26b031f97a5166d044843c5da5177c70d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a97901e608d0e3233e28a6d8e39d3124d661a650/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a97901e608d0e3233e28a6d8e39d3124d661a650/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=a97901e608d0e3233e28a6d8e39d3124d661a650", "patch": "@@ -748,7 +748,7 @@ DEMANGLE_H = $(srcdir)/../include/demangle.h\n RECOG_H = recog.h\n EXPR_H = expr.h insn-codes.h\n REGS_H = regs.h varray.h $(MACHMODE_H)\n-INTREGRATE_H = integrate.h varray.h\n+INTEGRATE_H = integrate.h varray.h\n LOOP_H = loop.h varray.h\n #\f\n # Language makefile fragments."}, {"sha": "05f1618310e3ab92ffbba1bb33b248fae17e0d85", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a97901e608d0e3233e28a6d8e39d3124d661a650/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a97901e608d0e3233e28a6d8e39d3124d661a650/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a97901e608d0e3233e28a6d8e39d3124d661a650", "patch": "@@ -1,3 +1,13 @@\n+1999-12-16  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* optimize.c (struct inline_data): Remove scope_stmt.\n+\t(remap_block): Don't use insert_block_after_note.  Don't update\n+\tscope_stmt.\n+\t(expand_call_inline): Don't update scope_stmt.\n+\t(optimize_function): Don't initialize scope_stmt.\n+\t* semantics.c (expand_stmt): Set NOTE_BLOCK for newly emitted\n+\tNOTE_INSN_BLOCK_BEG/NOTE_INSN_BLOCK_END notes.\n+\n 1999-12-15  Mark Mitchell  <mark@codesourcery.com>\n \n \t* class.c (handle_using_decl): Get TYPE_FIELDS and TYPE_METHODS"}, {"sha": "2dd151ccb010bcbc0bc933ec39e7d3ae961e01cc", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 8, "deletions": 30, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a97901e608d0e3233e28a6d8e39d3124d661a650/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a97901e608d0e3233e28a6d8e39d3124d661a650/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=a97901e608d0e3233e28a6d8e39d3124d661a650", "patch": "@@ -53,8 +53,6 @@ typedef struct inline_data\n      inlining the body of `h', the stack will contain, `h', followed\n      by `g', followed by `f'.  */\n   varray_type fns;\n-  /* The last SCOPE_STMT we have encountered.  */\n-  tree scope_stmt;\n   /* The label to jump to when a return statement is encountered.  */\n   tree ret_label;\n   /* The map from local declarations in the inlined function to\n@@ -146,6 +144,7 @@ remap_block (scope_stmt, decls, id)\n       tree old_block;\n       tree new_block;\n       tree old_var;\n+      tree fn;\n \n       /* Make the new block.  */\n       old_block = SCOPE_STMT_BLOCK (scope_stmt);\n@@ -175,13 +174,12 @@ remap_block (scope_stmt, decls, id)\n \t}\n       /* We put the BLOCK_VARS in reverse order; fix that now.  */\n       BLOCK_VARS (new_block) = nreverse (BLOCK_VARS (new_block));\n-      /* Graft the new block into the tree.  */\n-      insert_block_after_note (new_block,\n-\t\t\t       SCOPE_STMT_BLOCK (id->scope_stmt),\n-\t\t\t       SCOPE_BEGIN_P (id->scope_stmt));\n-      /* Remember that this is now the last scope statement with\n-\t an associated block.  */\n-      id->scope_stmt = scope_stmt;\n+      /* Attach this new block after the DECL_INITIAL block for the\n+\t function into which this block is being inlined.  In\n+\t rest_of_compilation we will straighten out the BLOCK tree.  */\n+      fn = VARRAY_TREE (id->fns, 0);\n+      BLOCK_CHAIN (new_block) = BLOCK_CHAIN (DECL_INITIAL (fn));\n+      BLOCK_CHAIN (DECL_INITIAL (fn)) = new_block;\n       /* Remember the remapped block.  */\n       splay_tree_insert (id->decl_map,\n \t\t\t (splay_tree_key) old_block,\n@@ -198,10 +196,6 @@ remap_block (scope_stmt, decls, id)\n \t\t\t     (splay_tree_key) SCOPE_STMT_BLOCK (scope_stmt));\n       my_friendly_assert (n != NULL, 19991203);\n       SCOPE_STMT_BLOCK (scope_stmt) = (tree) n->value;\n-\n-      /* Remember that this is now the last scope statement with an\n-\t associated block.  */\n-      id->scope_stmt = scope_stmt;\n     }\n }\n \n@@ -520,14 +514,6 @@ expand_call_inline (tp, walk_subtrees, data)\n   id = (inline_data *) data;\n   t = *tp;  \n \n-  /* Keep track of the last SCOPE_STMT we've seen.  */\n-  if (TREE_CODE (t) == SCOPE_STMT)\n-    {\n-      if (SCOPE_STMT_BLOCK (t) && !id->in_target_cleanup_p)\n-\tid->scope_stmt = t;\n-      return NULL_TREE;\n-    }\n-\n   /* Recurse, but letting recursive invocations know that we are\n      inside the body of a TARGET_EXPR.  */\n   if (TREE_CODE (*tp) == TARGET_EXPR)\n@@ -608,11 +594,9 @@ expand_call_inline (tp, walk_subtrees, data)\n   remap_block (scope_stmt, DECL_ARGUMENTS (fn), id);\n   TREE_CHAIN (scope_stmt) = STMT_EXPR_STMT (expr);\n   STMT_EXPR_STMT (expr) = scope_stmt;\n-  id->scope_stmt = scope_stmt;\n \n   /* Tell the debugging backends that this block represents the\n-     outermost scope of the inlined function.  FIXME what to do for\n-     inlines in cleanups?  */\n+     outermost scope of the inlined function.  */\n   if (SCOPE_STMT_BLOCK (scope_stmt))\n     BLOCK_ABSTRACT_ORIGIN (SCOPE_STMT_BLOCK (scope_stmt)) = DECL_ORIGIN (fn);\n \n@@ -723,12 +707,6 @@ optimize_function (fn)\n \t    prev_fn = s->function_decl;\n \t  }\n \n-      /* Initialize id->scope_stmt with a fake SCOPE_STMT for the outermost\n-\t block of the function (i.e. the BLOCK with __FUNCTION__ et al).  */\n-      id.scope_stmt = build_min_nt (SCOPE_STMT,\n-\t\t\t\t    BLOCK_SUBBLOCKS (DECL_INITIAL (fn)));\n-      SCOPE_BEGIN_P (id.scope_stmt) = 1;\n-\n       /* Replace all calls to inline functions with the bodies of those\n \t functions.  */\n       expand_calls_inline (&DECL_SAVED_TREE (fn), &id);"}, {"sha": "5ac7bdb83f702043822961a5ad0f4c24622f00b8", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a97901e608d0e3233e28a6d8e39d3124d661a650/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a97901e608d0e3233e28a6d8e39d3124d661a650/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=a97901e608d0e3233e28a6d8e39d3124d661a650", "patch": "@@ -2514,16 +2514,21 @@ expand_stmt (t)\n \t  if (!SCOPE_NO_CLEANUPS_P (t))\n \t    {\n \t      if (SCOPE_BEGIN_P (t))\n-\t\texpand_start_bindings (2 * SCOPE_NULLIFIED_P (t));\n+\t\texpand_start_bindings_and_block (2 * SCOPE_NULLIFIED_P (t),\n+\t\t\t\t\t\t SCOPE_STMT_BLOCK (t));\n \t      else if (SCOPE_END_P (t))\n \t\texpand_end_bindings (NULL_TREE, !SCOPE_NULLIFIED_P (t), \n \t\t\t\t     SCOPE_PARTIAL_P (t));\n \t    }\n \t  else if (!SCOPE_NULLIFIED_P (t))\n-\t    emit_note (NULL,\n-\t\t       (SCOPE_BEGIN_P (t) \n-\t\t\t? NOTE_INSN_BLOCK_BEG\n-\t\t\t: NOTE_INSN_BLOCK_END));\n+\t    {\n+\t      rtx note = emit_note (NULL,\n+\t\t\t\t    (SCOPE_BEGIN_P (t) \n+\t\t\t\t     ? NOTE_INSN_BLOCK_BEG\n+\t\t\t\t     : NOTE_INSN_BLOCK_END));\n+\t      NOTE_BLOCK (note) = SCOPE_STMT_BLOCK (t);\n+\t    }\n+\t      \n \t  break;\n \n \tcase RETURN_INIT:"}, {"sha": "02ee9fb14eb01f4bf9d4ba925ef849b52312c320", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 64, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a97901e608d0e3233e28a6d8e39d3124d661a650/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a97901e608d0e3233e28a6d8e39d3124d661a650/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=a97901e608d0e3233e28a6d8e39d3124d661a650", "patch": "@@ -5493,66 +5493,6 @@ round_trampoline_addr (tramp)\n   return tramp;\n }\n \f\n-/* Insert the BLOCK in the block-tree, knowing that the previous\n-   block-note is for OLD_BLOCK.  BEGIN_P is non-zero if the previous\n-   block-note was the for the beginning of a BLOCK.  */\n-\n-void \n-insert_block_after_note (block, old_block, begin_p)\n-     tree block;\n-     tree old_block;\n-     int begin_p;\n-{\n-  if (begin_p)\n-    {\n-      /* If there was no previous block, something's gone terribly\n-         wrong.  We used to try to use DECL_INITIAL for the current\n-         function, but that will never be correct, and completely\n-         hoses the block structure.  */\n-      if (!old_block)\n-\tabort ();\n-\n-      BLOCK_SUPERCONTEXT (block) = old_block;\n-      BLOCK_CHAIN (block) = BLOCK_SUBBLOCKS (old_block);\n-      BLOCK_SUBBLOCKS (old_block) = block;\n-    }\n-  else\n-    {\n-      BLOCK_SUPERCONTEXT (block) = BLOCK_SUPERCONTEXT (old_block);\n-      BLOCK_CHAIN (block) = BLOCK_CHAIN (old_block);\n-      BLOCK_CHAIN (old_block) = block;\n-    }\n-}\n-\n-/* Insert the BLOCK in the block-tree before LAST_INSN.  */\n-\n-void\n-retrofit_block (block, last_insn)\n-     tree block;\n-     rtx last_insn;\n-{\n-  rtx insn;\n-\n-  /* Now insert the new BLOCK at the right place in the block trees\n-     for the function which called the inline function.  We just look\n-     backwards for a NOTE_INSN_BLOCK_{BEG,END}.  If we find the\n-     beginning of a block, then this new block becomes the first\n-     subblock of that block.  If we find the end of a block, then this\n-     new block follows that block in the list of blocks.  */\n-  for (insn = last_insn; insn; insn = PREV_INSN (insn))\n-    if (GET_CODE (insn) == NOTE\n-\t&& (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG\n-\t    || NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END))\n-      break;\n-\n-  if (insn == NULL_RTX)\n-    abort ();\n-\n-  insert_block_after_note (block, \n-\t\t\t   NOTE_BLOCK (insn),\n-\t\t\t   NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG);\n-}\n-\n /* The functions identify_blocks and reorder_blocks provide a way to\n    reorder the tree of BLOCK nodes, for optimizers that reshuffle or\n    duplicate portions of the RTL code.  Call identify_blocks before\n@@ -5595,8 +5535,8 @@ identify_blocks (block, insns)\n \t  {\n \t    tree b;\n \n-\t      /* If there are more block notes than BLOCKs, something\n-\t\t is badly wrong.  */\n+\t    /* If there are more block notes than BLOCKs, something\n+\t       is badly wrong.  */\n \t    if (current_block_number == n_blocks)\n \t      abort ();\n \n@@ -5660,14 +5600,12 @@ reorder_blocks (block, insns)\n \t    BLOCK_CHAIN (block) = BLOCK_SUBBLOCKS (current_block);\n \t    BLOCK_SUBBLOCKS (current_block) = block;\n \t    current_block = block;\n-\t    NOTE_SOURCE_FILE (insn) = 0;\n \t  }\n \tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)\n \t  {\n \t    BLOCK_SUBBLOCKS (current_block)\n \t      = blocks_nreverse (BLOCK_SUBBLOCKS (current_block));\n \t    current_block = BLOCK_SUPERCONTEXT (current_block);\n-\t    NOTE_SOURCE_FILE (insn) = 0;\n \t  }\n       }\n "}, {"sha": "a641189e5d1e1df9501c2ed8953e46424dcb1fcc", "filename": "gcc/function.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a97901e608d0e3233e28a6d8e39d3124d661a650/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a97901e608d0e3233e28a6d8e39d3124d661a650/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=a97901e608d0e3233e28a6d8e39d3124d661a650", "patch": "@@ -543,12 +543,6 @@ extern struct function *outer_function_chain;\n    Also store in each NOTE for the beginning or end of a block\n    the index of that block in the vector.  */\n extern void identify_blocks PROTO((tree, rtx));\n-/* Insert the BLOCK in the block-tree, knowing that the previous\n-   block-note is for OLD_BLOCK.  BEGIN_P is non-zero if the previous\n-   block-note was the for the beginning of a BLOCK.  */\n-extern void insert_block_after_note PROTO((tree, tree, int));\n-/* Insert a new BLOCK at an appropriate place in the block tree.  */\n-extern void retrofit_block PROTO((tree, rtx));\n \n /* Return size needed for stack frame based on slots so far allocated.\n    This size counts from zero.  It is not rounded to STACK_BOUNDARY;"}, {"sha": "c50c1d4923c996cef81e090e3179d2728ca8cc89", "filename": "gcc/integrate.c", "status": "modified", "additions": 81, "deletions": 25, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a97901e608d0e3233e28a6d8e39d3124d661a650/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a97901e608d0e3233e28a6d8e39d3124d661a650/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=a97901e608d0e3233e28a6d8e39d3124d661a650", "patch": "@@ -78,6 +78,8 @@ static void process_reg_param\t\tPROTO((struct inline_remap *, rtx,\n void set_decl_abstract_flags\t\tPROTO((tree, int));\n static rtx expand_inline_function_eh_labelmap PROTO((rtx));\n static void mark_stores                 PROTO((rtx, rtx, void *));\n+static int compare_blocks               PROTO((const PTR, const PTR));\n+static int find_block                   PROTO((const PTR, const PTR));\n \n /* The maximum number of instructions accepted for inlining a\n    function.  Increasing values mean more agressive inlining.\n@@ -505,6 +507,35 @@ expand_inline_function_eh_labelmap (label)\n   return get_label_from_map (eif_eh_map, index);\n }\n \n+/* Compare two BLOCKs for qsort.  The key we sort on is the\n+   BLOCK_ABSTRACT_ORIGIN of the blocks.  */\n+\n+static int\n+compare_blocks (v1, v2)\n+     const PTR v1;\n+     const PTR v2;\n+{\n+  tree b1 = *((tree *) v1);\n+  tree b2 = *((tree *) v2);\n+\n+  return ((char *) BLOCK_ABSTRACT_ORIGIN (b1) \n+\t  - (char *) BLOCK_ABSTRACT_ORIGIN (b2));\n+}\n+\n+/* Compare two BLOCKs for bsearch.  The first pointer corresponds to\n+   an original block; the second to a remapped equivalent.  */\n+\n+static int\n+find_block (v1, v2)\n+     const PTR v1;\n+     const PTR v2;\n+{\n+  tree b1 = (tree) v1;\n+  tree b2 = *((tree *) v2);\n+\n+  return ((char *) b1 - (char *) BLOCK_ABSTRACT_ORIGIN (b2));\n+}\n+\n /* Integrate the procedure defined by FNDECL.  Note that this function\n    may wind up calling itself.  Since the static variables are not\n    reentrant, we do not assign them until after the possibility\n@@ -687,6 +718,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n   map = (struct inline_remap *) xmalloc (sizeof (struct inline_remap));\n   map->fndecl = fndecl;\n \n+  VARRAY_TREE_INIT (map->block_map, 10, \"block_map\");\n   map->reg_map = (rtx *) xcalloc (max_regno, sizeof (rtx));\n \n   /* We used to use alloca here, but the size of what it would try to\n@@ -757,11 +789,6 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \tRTX_INTEGRATED_P (note) = 1;\n     }\n \n-  /* Figure out where the blocks are if we're going to have to insert\n-     new BLOCKs into the existing block tree.  */\n-  if (current_function->x_whole_function_mode_p)\n-    find_loop_tree_blocks ();\n-\n   /* Process each argument.  For each, set up things so that the function's\n      reference to the argument will refer to the argument being passed.\n      We only replace REG with REG here.  Any simplifications are done\n@@ -1006,15 +1033,32 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n   else\n     abort ();\n \n-  /* Make a fresh binding contour that we can easily remove.  Do this after\n-     expanding our arguments so cleanups are properly scoped.  */\n-  expand_start_bindings (0);\n-\n   /* Initialize label_map.  get_label_from_map will actually make\n      the labels.  */\n   bzero ((char *) &map->label_map [min_labelno],\n \t (max_labelno - min_labelno) * sizeof (rtx));\n \n+  /* Make copies of the decls of the symbols in the inline function, so that\n+     the copies of the variables get declared in the current function.  Set\n+     up things so that lookup_static_chain knows that to interpret registers\n+     in SAVE_EXPRs for TYPE_SIZEs as local.  */\n+  inline_function_decl = fndecl;\n+  integrate_parm_decls (DECL_ARGUMENTS (fndecl), map, arg_vector);\n+  block = integrate_decl_tree (inl_f->original_decl_initial, map);\n+  BLOCK_ABSTRACT_ORIGIN (block) = DECL_ORIGIN (fndecl);\n+  inline_function_decl = 0;\n+\n+  /* Make a fresh binding contour that we can easily remove.  Do this after\n+     expanding our arguments so cleanups are properly scoped.  */\n+  expand_start_bindings_and_block (0, block);\n+\n+  /* Sort the block-map so that it will be easy to find remapped\n+     blocks later.  */\n+  qsort (&VARRAY_TREE (map->block_map, 0), \n+\t map->block_map->elements_used,\n+\t sizeof (tree),\n+\t compare_blocks);\n+\n   /* Perform postincrements before actually calling the function.  */\n   emit_queue ();\n \n@@ -1292,6 +1336,25 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \t\t     region.  */\n \t\t  NOTE_EH_HANDLER (copy) = CODE_LABEL_NUMBER (label);\n \t\t}\n+\t      else if (copy\n+\t\t       && (NOTE_LINE_NUMBER (copy) == NOTE_INSN_BLOCK_BEG\n+\t\t\t   || NOTE_LINE_NUMBER (copy) == NOTE_INSN_BLOCK_END)\n+\t\t       && NOTE_BLOCK (insn))\n+\t\t{\n+\t\t  tree *mapped_block_p;\n+\n+\t\t  mapped_block_p\n+\t\t    = (tree *) bsearch (NOTE_BLOCK (insn), \n+\t\t\t\t\t&VARRAY_TREE (map->block_map, 0),\n+\t\t\t\t\tmap->block_map->elements_used,\n+\t\t\t\t\tsizeof (tree),\n+\t\t\t\t\tfind_block);\n+\t\t  \n+\t\t  if (!mapped_block_p)\n+\t\t    abort ();\n+\t\t  else\n+\t\t    NOTE_BLOCK (copy) = *mapped_block_p;\n+\t\t}\n \t    }\n \t  else\n \t    copy = 0;\n@@ -1332,27 +1395,18 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n   if (inl_f->calls_alloca)\n     emit_stack_restore (SAVE_BLOCK, stack_save, NULL_RTX);\n \n-  /* Make copies of the decls of the symbols in the inline function, so that\n-     the copies of the variables get declared in the current function.  Set\n-     up things so that lookup_static_chain knows that to interpret registers\n-     in SAVE_EXPRs for TYPE_SIZEs as local.  */\n-\n-  inline_function_decl = fndecl;\n-  integrate_parm_decls (DECL_ARGUMENTS (fndecl), map, arg_vector);\n-  block = integrate_decl_tree (inl_f->original_decl_initial, map);\n-  BLOCK_ABSTRACT_ORIGIN (block) = (DECL_ABSTRACT_ORIGIN (fndecl) == NULL\n-\t\t\t\t   ? fndecl : DECL_ABSTRACT_ORIGIN (fndecl));\n-  inline_function_decl = 0;\n-\n-  if (current_function->x_whole_function_mode_p)\n-    /* Insert the block into the already existing block-tree.  */\n-    retrofit_block (block, map->insns_at_start);\n-  else\n+  if (!current_function->x_whole_function_mode_p)\n     /* In statement-at-a-time mode, we just tell the front-end to add\n        this block to the list of blocks at this binding level.  We\n        can't do it the way it's done for function-at-a-time mode the\n        superblocks have not been created yet.  */\n     insert_block (block);\n+  else\n+    {\n+      BLOCK_CHAIN (block) \n+\t= BLOCK_CHAIN (DECL_INITIAL (current_function_decl));\n+      BLOCK_CHAIN (DECL_INITIAL (current_function_decl)) = block;\n+    }\n \n   /* End the scope containing the copied formal parameter variables\n      and copied LABEL_DECLs.  We pass NULL_TREE for the variables list\n@@ -1392,6 +1446,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n     free (real_label_map);\n   VARRAY_FREE (map->const_equiv_varray);\n   free (map->reg_map);\n+  VARRAY_FREE (map->block_map);\n   free (map->insn_map);\n   free (map);\n   free (arg_vals);\n@@ -1451,6 +1506,7 @@ integrate_decl_tree (let, map)\n   tree *next;\n \n   new_block = make_node (BLOCK);\n+  VARRAY_PUSH_TREE (map->block_map, new_block);\n   next = &BLOCK_VARS (new_block);\n \n   for (t = BLOCK_VARS (let); t; t = TREE_CHAIN (t))"}, {"sha": "4cc75fabbdce62a8b322a88e9e8c7c3b6a8a3c27", "filename": "gcc/integrate.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a97901e608d0e3233e28a6d8e39d3124d661a650/gcc%2Fintegrate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a97901e608d0e3233e28a6d8e39d3124d661a650/gcc%2Fintegrate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.h?ref=a97901e608d0e3233e28a6d8e39d3124d661a650", "patch": "@@ -42,6 +42,8 @@ struct inline_remap\n   union tree_node *fndecl;\n   /* Place to put insns needed at start of function.  */\n   rtx insns_at_start;\n+  /* Mapping from old BLOCKs to new BLOCKs.  */\n+  varray_type block_map;\n   /* Mapping from old registers to new registers.\n      It is allocated and deallocated in `expand_inline_function' */\n   rtx *reg_map;"}, {"sha": "826295ba5bbd48a1df26e34b2a0c7473d0838d64", "filename": "gcc/stmt.c", "status": "modified", "additions": 38, "deletions": 12, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a97901e608d0e3233e28a6d8e39d3124d661a650/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a97901e608d0e3233e28a6d8e39d3124d661a650/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=a97901e608d0e3233e28a6d8e39d3124d661a650", "patch": "@@ -1024,23 +1024,30 @@ expand_fixup (tree_label, rtl_label, last_insn)\n         register rtx original_before_jump\n           = last_insn ? last_insn : get_last_insn ();\n \trtx start;\n+\trtx end;\n \ttree block;\n \n \tblock = make_node (BLOCK);\n \tTREE_USED (block) = 1;\n \n-\tif (current_function->x_whole_function_mode_p)\n+\tif (!current_function->x_whole_function_mode_p)\n+\t  insert_block (block);\n+\telse\n \t  {\n-\t    find_loop_tree_blocks ();\n-\t    retrofit_block (block, original_before_jump);\n+\t    BLOCK_CHAIN (block) \n+\t      = BLOCK_CHAIN (DECL_INITIAL (current_function_decl));\n+\t    BLOCK_CHAIN (DECL_INITIAL (current_function_decl))\n+\t      = block;\n \t  }\n-\telse\n-\t  insert_block (block);\n \n         start_sequence ();\n         start = emit_note (NULL_PTR, NOTE_INSN_BLOCK_BEG);\n+\tif (current_function->x_whole_function_mode_p)\n+\t  NOTE_BLOCK (start) = block;\n \tfixup->before_jump = emit_note (NULL_PTR, NOTE_INSN_DELETED);\n-\temit_note (NULL_PTR, NOTE_INSN_BLOCK_END);\n+\tend = emit_note (NULL_PTR, NOTE_INSN_BLOCK_END);\n+\tif (current_function->x_whole_function_mode_p)\n+\t  NOTE_BLOCK (end) = block;\n         fixup->context = block;\n         end_sequence ();\n         emit_insns_after (start, original_before_jump);\n@@ -3198,20 +3205,36 @@ tail_recursion_args (actuals, formals)\n \t will not create corresponding BLOCK nodes.  (There should be\n \t a one-to-one correspondence between NOTE_INSN_BLOCK_BEG notes\n \t and BLOCKs.)  If this flag is set, MARK_ENDS should be zero\n-\t when expand_end_bindings is called.  */\n+\t when expand_end_bindings is called.  \n+\n+    If we are creating a NOTE_INSN_BLOCK_BEG note, a BLOCK may\n+    optionally be supplied.  If so, it becomes the NOTE_BLOCK for the\n+    note.  */\n \n void\n-expand_start_bindings (flags)\n+expand_start_bindings_and_block (flags, block)\n      int flags;\n+     tree block;\n {\n   struct nesting *thisblock = ALLOC_NESTING ();\n   rtx note;\n   int exit_flag = ((flags & 1) != 0);\n   int block_flag = ((flags & 2) == 0);\n+  \n+  /* If a BLOCK is supplied, then the caller should be requesting a\n+     NOTE_INSN_BLOCK_BEG note.  */\n+  if (!block_flag && block)\n+    abort ();\n \n-  note = emit_note (NULL_PTR, \n-\t\t    block_flag ? NOTE_INSN_BLOCK_BEG : NOTE_INSN_DELETED);\n-\n+  /* Create a note to mark the beginning of the block.  */\n+  if (block_flag)\n+    {\n+      note = emit_note (NULL_PTR, NOTE_INSN_BLOCK_BEG);\n+      NOTE_BLOCK (note) = block;\n+    }\n+  else\n+    note = emit_note (NULL_PTR, NOTE_INSN_DELETED);\n+    \n   /* Make an entry on block_stack for the block we are entering.  */\n \n   thisblock->next = block_stack;\n@@ -3659,7 +3682,10 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n      just going out of scope, so they are in scope for their cleanups.  */\n \n   if (mark_ends)\n-    emit_note (NULL_PTR, NOTE_INSN_BLOCK_END);\n+    {\n+      rtx note = emit_note (NULL_PTR, NOTE_INSN_BLOCK_END);\n+      NOTE_BLOCK (note) = NOTE_BLOCK (thisblock->data.block.first_insn);\n+    }\n   else\n     /* Get rid of the beginning-mark if we don't make an end-mark.  */\n     NOTE_LINE_NUMBER (thisblock->data.block.first_insn) = NOTE_INSN_DELETED;"}, {"sha": "892149fc4af490467b81be3b85d0d5cdcefb3880", "filename": "gcc/toplev.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a97901e608d0e3233e28a6d8e39d3124d661a650/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a97901e608d0e3233e28a6d8e39d3124d661a650/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=a97901e608d0e3233e28a6d8e39d3124d661a650", "patch": "@@ -3605,6 +3605,14 @@ rest_of_compilation (decl)\n      collector to reclaim the memory used by the notes.  */\n   remove_unncessary_notes ();\n \n+  /* In function-at-a-time mode, we do not attempt to keep the BLOCK\n+     tree in sensible shape.  So, we just recalculate it here.  */\n+  if (current_function->x_whole_function_mode_p)\n+    {\n+      find_loop_tree_blocks ();\n+      unroll_block_trees ();\n+    }\n+\n   /* If we are reconsidering an inline function\n      at the end of compilation, skip the stuff for making it inline.  */\n "}, {"sha": "e802e0ccc041719901988ec0be76c1cf37840e24", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a97901e608d0e3233e28a6d8e39d3124d661a650/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a97901e608d0e3233e28a6d8e39d3124d661a650/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=a97901e608d0e3233e28a6d8e39d3124d661a650", "patch": "@@ -2100,7 +2100,9 @@ extern int expand_exit_something\t\tPROTO((void));\n extern void expand_null_return\t\t\tPROTO((void));\n extern void expand_return\t\t\tPROTO((tree));\n extern int optimize_tail_recursion\t\tPROTO((tree, struct rtx_def *));\n-extern void expand_start_bindings\t\tPROTO((int));\n+extern void expand_start_bindings_and_block     PROTO((int, tree));\n+#define expand_start_bindings(flags) \\\n+  expand_start_bindings_and_block(flags, NULL_TREE)\n extern void expand_end_bindings\t\t\tPROTO((tree, int, int));\n extern void warn_about_unused_variables         PROTO((tree));\n extern void start_cleanup_deferral\t\tPROTO((void));"}]}