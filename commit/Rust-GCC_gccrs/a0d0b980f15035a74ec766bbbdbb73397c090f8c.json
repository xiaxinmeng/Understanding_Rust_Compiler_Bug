{"sha": "a0d0b980f15035a74ec766bbbdbb73397c090f8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTBkMGI5ODBmMTUwMzVhNzRlYzc2NmJiYmRiYjczMzk3YzA5MGY4Yw==", "commit": {"author": {"name": "Steve Ellcey", "email": "sellcey@cavium.com", "date": "2018-12-17T19:14:04Z"}, "committer": {"name": "Steve Ellcey", "email": "sje@gcc.gnu.org", "date": "2018-12-17T19:14:04Z"}, "message": "aarch64-protos.h (aarch64_use_simple_return_insn_p): New prototype.\n\n2018-12-17  Steve Ellcey  <sellcey@cavium.com>\n\n\t* config/aarch64/aarch64-protos.h (aarch64_use_simple_return_insn_p):\n\tNew prototype.\n\t(aarch64_epilogue_uses): Ditto.\n\t* config/aarch64/aarch64.c (aarch64_attribute_table): New array.\n\t(aarch64_simd_decl_p): New function.\n\t(aarch64_reg_save_mode): New function.\n\t(aarch64_function_ok_for_sibcall): Check for simd calls.\n\t(aarch64_layout_frame): Check for simd function.\n\t(aarch64_gen_storewb_pair): Handle E_TFmode.\n\t(aarch64_push_regs): Use aarch64_reg_save_mode to get mode.\n\t(aarch64_gen_loadwb_pair): Handle E_TFmode.\n\t(aarch64_pop_regs): Use aarch64_reg_save_mode to get mode.\n\t(aarch64_gen_store_pair): Handle E_TFmode.\n\t(aarch64_gen_load_pair): Ditto.\n\t(aarch64_save_callee_saves): Handle different mode sizes.\n\t(aarch64_restore_callee_saves): Ditto.\n\t(aarch64_components_for_bb): Check for simd function.\n\t(aarch64_epilogue_uses): New function.\n\t(aarch64_process_components): Check for simd function.\n\t(aarch64_expand_prologue): Ditto.\n\t(aarch64_expand_epilogue): Ditto.\n\t(aarch64_expand_call): Ditto.\n\t(aarch64_use_simple_return_insn_p): New function.\n\t(TARGET_ATTRIBUTE_TABLE): New define.\n\t* config/aarch64/aarch64.h (EPILOGUE_USES): Redefine.\n\t(FP_SIMD_SAVED_REGNUM_P): New macro.\n\t* config/aarch64/aarch64.md (simple_return): New define_expand.\n\t(load_pair_dw_tftf): New instruction.\n\t(store_pair_dw_tftf): Ditto.\n\t(loadwb_pair<TX:mode>_<P:mode>): Ditto.\n\t(storewb_pair<TX:mode>_<P:mode>): Ditto.\n\nFrom-SVN: r267208", "tree": {"sha": "57a4101cfdc474d734b5e694328893dfedeeb5fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57a4101cfdc474d734b5e694328893dfedeeb5fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0d0b980f15035a74ec766bbbdbb73397c090f8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0d0b980f15035a74ec766bbbdbb73397c090f8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0d0b980f15035a74ec766bbbdbb73397c090f8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0d0b980f15035a74ec766bbbdbb73397c090f8c/comments", "author": {"login": "sellcey", "id": 25938520, "node_id": "MDQ6VXNlcjI1OTM4NTIw", "avatar_url": "https://avatars.githubusercontent.com/u/25938520?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sellcey", "html_url": "https://github.com/sellcey", "followers_url": "https://api.github.com/users/sellcey/followers", "following_url": "https://api.github.com/users/sellcey/following{/other_user}", "gists_url": "https://api.github.com/users/sellcey/gists{/gist_id}", "starred_url": "https://api.github.com/users/sellcey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sellcey/subscriptions", "organizations_url": "https://api.github.com/users/sellcey/orgs", "repos_url": "https://api.github.com/users/sellcey/repos", "events_url": "https://api.github.com/users/sellcey/events{/privacy}", "received_events_url": "https://api.github.com/users/sellcey/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4d814b69890171b7d742fabd966e5167b222cfd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d814b69890171b7d742fabd966e5167b222cfd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d814b69890171b7d742fabd966e5167b222cfd0"}], "stats": {"total": 277, "additions": 250, "deletions": 27}, "files": [{"sha": "637baa8e75732467b99b36fbb250a8c06af35e19", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0d0b980f15035a74ec766bbbdbb73397c090f8c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0d0b980f15035a74ec766bbbdbb73397c090f8c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a0d0b980f15035a74ec766bbbdbb73397c090f8c", "patch": "@@ -1,3 +1,37 @@\n+2018-12-17  Steve Ellcey  <sellcey@cavium.com>\n+\n+\t* config/aarch64/aarch64-protos.h (aarch64_use_simple_return_insn_p):\n+\tNew prototype.\n+\t(aarch64_epilogue_uses): Ditto.\n+\t* config/aarch64/aarch64.c (aarch64_attribute_table): New array.\n+\t(aarch64_simd_decl_p): New function.\n+\t(aarch64_reg_save_mode): New function.\n+\t(aarch64_function_ok_for_sibcall): Check for simd calls.\n+\t(aarch64_layout_frame): Check for simd function.\n+\t(aarch64_gen_storewb_pair): Handle E_TFmode.\n+\t(aarch64_push_regs): Use aarch64_reg_save_mode to get mode.\n+\t(aarch64_gen_loadwb_pair): Handle E_TFmode.\n+\t(aarch64_pop_regs): Use aarch64_reg_save_mode to get mode.\n+\t(aarch64_gen_store_pair): Handle E_TFmode.\n+\t(aarch64_gen_load_pair): Ditto.\n+\t(aarch64_save_callee_saves): Handle different mode sizes.\n+\t(aarch64_restore_callee_saves): Ditto.\n+\t(aarch64_components_for_bb): Check for simd function.\n+\t(aarch64_epilogue_uses): New function.\n+\t(aarch64_process_components): Check for simd function.\n+\t(aarch64_expand_prologue): Ditto.\n+\t(aarch64_expand_epilogue): Ditto.\n+\t(aarch64_expand_call): Ditto.\n+\t(aarch64_use_simple_return_insn_p): New function.\n+\t(TARGET_ATTRIBUTE_TABLE): New define.\n+\t* config/aarch64/aarch64.h (EPILOGUE_USES): Redefine.\n+\t(FP_SIMD_SAVED_REGNUM_P): New macro.\n+\t* config/aarch64/aarch64.md (simple_return): New define_expand.\n+\t(load_pair_dw_tftf): New instruction.\n+\t(store_pair_dw_tftf): Ditto.\n+\t(loadwb_pair<TX:mode>_<P:mode>): Ditto.\n+\t(storewb_pair<TX:mode>_<P:mode>): Ditto.\n+\n 2018-12-17  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/88502"}, {"sha": "e64768aadead2901c1168b3c2ec82c17052ff807", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0d0b980f15035a74ec766bbbdbb73397c090f8c/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0d0b980f15035a74ec766bbbdbb73397c090f8c/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=a0d0b980f15035a74ec766bbbdbb73397c090f8c", "patch": "@@ -471,6 +471,7 @@ bool aarch64_split_dimode_const_store (rtx, rtx);\n bool aarch64_symbolic_address_p (rtx);\n bool aarch64_uimm12_shift (HOST_WIDE_INT);\n bool aarch64_use_return_insn_p (void);\n+bool aarch64_use_simple_return_insn_p (void);\n const char *aarch64_mangle_builtin_type (const_tree);\n const char *aarch64_output_casesi (rtx *);\n \n@@ -556,6 +557,8 @@ void aarch64_split_simd_move (rtx, rtx);\n /* Check for a legitimate floating point constant for FMOV.  */\n bool aarch64_float_const_representable_p (rtx);\n \n+extern int aarch64_epilogue_uses (int);\n+\n #if defined (RTX_CODE)\n void aarch64_gen_unlikely_cbranch (enum rtx_code, machine_mode cc_mode,\n \t\t\t\t   rtx label_ref);"}, {"sha": "603849477063e8c70ece470404bdd34239fd6f19", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 146, "deletions": 19, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0d0b980f15035a74ec766bbbdbb73397c090f8c/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0d0b980f15035a74ec766bbbdbb73397c090f8c/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=a0d0b980f15035a74ec766bbbdbb73397c090f8c", "patch": "@@ -1141,6 +1141,15 @@ static const struct processor *selected_tune;\n /* The current tuning set.  */\n struct tune_params aarch64_tune_params = generic_tunings;\n \n+/* Table of machine attributes.  */\n+static const struct attribute_spec aarch64_attribute_table[] =\n+{\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req,\n+       affects_type_identity, handler, exclude } */\n+  { \"aarch64_vector_pcs\", 0, 0, false, true,  true,  false, NULL, NULL },\n+  { NULL,                 0, 0, false, false, false, false, NULL, NULL }\n+};\n+\n #define AARCH64_CPU_DEFAULT_FLAGS ((selected_cpu) ? selected_cpu->flags : 0)\n \n /* An ISA extension in the co-processor and main instruction set space.  */\n@@ -1523,6 +1532,39 @@ aarch64_hard_regno_mode_ok (unsigned regno, machine_mode mode)\n   return false;\n }\n \n+/* Return true if this is a definition of a vectorized simd function.  */\n+\n+static bool\n+aarch64_simd_decl_p (tree fndecl)\n+{\n+  tree fntype;\n+\n+  if (fndecl == NULL)\n+    return false;\n+  fntype = TREE_TYPE (fndecl);\n+  if (fntype == NULL)\n+    return false;\n+\n+  /* Functions with the aarch64_vector_pcs attribute use the simd ABI.  */\n+  if (lookup_attribute (\"aarch64_vector_pcs\", TYPE_ATTRIBUTES (fntype)) != NULL)\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Return the mode a register save/restore should use.  DImode for integer\n+   registers, DFmode for FP registers in non-SIMD functions (they only save\n+   the bottom half of a 128 bit register), or TFmode for FP registers in\n+   SIMD functions.  */\n+\n+static machine_mode\n+aarch64_reg_save_mode (tree fndecl, unsigned regno)\n+{\n+  return GP_REGNUM_P (regno)\n+\t   ? E_DImode\n+\t   : (aarch64_simd_decl_p (fndecl) ? E_TFmode : E_DFmode);\n+}\n+\n /* Implement TARGET_HARD_REGNO_CALL_PART_CLOBBERED.  The callee only saves\n    the lower 64 bits of a 128-bit register.  Tell the compiler the callee\n    clobbers the top 64 bits when restoring the bottom 64 bits.  */\n@@ -3349,7 +3391,9 @@ static bool\n aarch64_function_ok_for_sibcall (tree decl ATTRIBUTE_UNUSED,\n \t\t\t\t tree exp ATTRIBUTE_UNUSED)\n {\n-  /* Currently, always true.  */\n+  if (aarch64_simd_decl_p (cfun->decl) != aarch64_simd_decl_p (decl))\n+    return false;\n+\n   return true;\n }\n \n@@ -4210,6 +4254,7 @@ aarch64_layout_frame (void)\n {\n   HOST_WIDE_INT offset = 0;\n   int regno, last_fp_reg = INVALID_REGNUM;\n+  bool simd_function = aarch64_simd_decl_p (cfun->decl);\n \n   cfun->machine->frame.emit_frame_chain = aarch64_needs_frame_chain ();\n \n@@ -4223,6 +4268,17 @@ aarch64_layout_frame (void)\n   cfun->machine->frame.wb_candidate1 = INVALID_REGNUM;\n   cfun->machine->frame.wb_candidate2 = INVALID_REGNUM;\n \n+  /* If this is a non-leaf simd function with calls we assume that\n+     at least one of those calls is to a non-simd function and thus\n+     we must save V8 to V23 in the prologue.  */\n+\n+  if (simd_function && !crtl->is_leaf)\n+    {\n+      for (regno = V0_REGNUM; regno <= V31_REGNUM; regno++)\n+\tif (FP_SIMD_SAVED_REGNUM_P (regno))\n+ \t  df_set_regs_ever_live (regno, true);\n+    }\n+\n   /* First mark all the registers that really need to be saved...  */\n   for (regno = R0_REGNUM; regno <= R30_REGNUM; regno++)\n     cfun->machine->frame.reg_offset[regno] = SLOT_NOT_REQUIRED;\n@@ -4245,7 +4301,8 @@ aarch64_layout_frame (void)\n \n   for (regno = V0_REGNUM; regno <= V31_REGNUM; regno++)\n     if (df_regs_ever_live_p (regno)\n-\t&& !call_used_regs[regno])\n+\t&& (!call_used_regs[regno]\n+\t    || (simd_function && FP_SIMD_SAVED_REGNUM_P (regno))))\n       {\n \tcfun->machine->frame.reg_offset[regno] = SLOT_REQUIRED;\n \tlast_fp_reg = regno;\n@@ -4287,7 +4344,10 @@ aarch64_layout_frame (void)\n       {\n \t/* If there is an alignment gap between integer and fp callee-saves,\n \t   allocate the last fp register to it if possible.  */\n-\tif (regno == last_fp_reg && has_align_gap && (offset & 8) == 0)\n+\tif (regno == last_fp_reg\n+\t    && has_align_gap\n+\t    && !simd_function\n+\t    && (offset & 8) == 0)\n \t  {\n \t    cfun->machine->frame.reg_offset[regno] = max_int_offset;\n \t    break;\n@@ -4299,7 +4359,7 @@ aarch64_layout_frame (void)\n \telse if (cfun->machine->frame.wb_candidate2 == INVALID_REGNUM\n \t\t && cfun->machine->frame.wb_candidate1 >= V0_REGNUM)\n \t  cfun->machine->frame.wb_candidate2 = regno;\n-\toffset += UNITS_PER_WORD;\n+\toffset += simd_function ? UNITS_PER_VREG : UNITS_PER_WORD;\n       }\n \n   offset = ROUND_UP (offset, STACK_BOUNDARY / BITS_PER_UNIT);\n@@ -4442,6 +4502,10 @@ aarch64_gen_storewb_pair (machine_mode mode, rtx base, rtx reg, rtx reg2,\n       return gen_storewb_pairdf_di (base, base, reg, reg2,\n \t\t\t\t    GEN_INT (-adjustment),\n \t\t\t\t    GEN_INT (UNITS_PER_WORD - adjustment));\n+    case E_TFmode:\n+      return gen_storewb_pairtf_di (base, base, reg, reg2,\n+\t\t\t\t    GEN_INT (-adjustment),\n+\t\t\t\t    GEN_INT (UNITS_PER_VREG - adjustment));\n     default:\n       gcc_unreachable ();\n     }\n@@ -4454,7 +4518,7 @@ static void\n aarch64_push_regs (unsigned regno1, unsigned regno2, HOST_WIDE_INT adjustment)\n {\n   rtx_insn *insn;\n-  machine_mode mode = (regno1 <= R30_REGNUM) ? E_DImode : E_DFmode;\n+  machine_mode mode = aarch64_reg_save_mode (cfun->decl, regno1);\n \n   if (regno2 == INVALID_REGNUM)\n     return aarch64_pushwb_single_reg (mode, regno1, adjustment);\n@@ -4484,6 +4548,9 @@ aarch64_gen_loadwb_pair (machine_mode mode, rtx base, rtx reg, rtx reg2,\n     case E_DFmode:\n       return gen_loadwb_pairdf_di (base, base, reg, reg2, GEN_INT (adjustment),\n \t\t\t\t   GEN_INT (UNITS_PER_WORD));\n+    case E_TFmode:\n+      return gen_loadwb_pairtf_di (base, base, reg, reg2, GEN_INT (adjustment),\n+\t\t\t\t   GEN_INT (UNITS_PER_VREG));\n     default:\n       gcc_unreachable ();\n     }\n@@ -4497,7 +4564,7 @@ static void\n aarch64_pop_regs (unsigned regno1, unsigned regno2, HOST_WIDE_INT adjustment,\n \t\t  rtx *cfi_ops)\n {\n-  machine_mode mode = (regno1 <= R30_REGNUM) ? E_DImode : E_DFmode;\n+  machine_mode mode = aarch64_reg_save_mode (cfun->decl, regno1);\n   rtx reg1 = gen_rtx_REG (mode, regno1);\n \n   *cfi_ops = alloc_reg_note (REG_CFA_RESTORE, reg1, *cfi_ops);\n@@ -4532,6 +4599,9 @@ aarch64_gen_store_pair (machine_mode mode, rtx mem1, rtx reg1, rtx mem2,\n     case E_DFmode:\n       return gen_store_pair_dw_dfdf (mem1, reg1, mem2, reg2);\n \n+    case E_TFmode:\n+      return gen_store_pair_dw_tftf (mem1, reg1, mem2, reg2);\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -4552,6 +4622,9 @@ aarch64_gen_load_pair (machine_mode mode, rtx reg1, rtx mem1, rtx reg2,\n     case E_DFmode:\n       return gen_load_pair_dw_dfdf (reg1, mem1, reg2, mem2);\n \n+    case E_TFmode:\n+      return gen_load_pair_dw_tftf (reg1, mem1, reg2, mem2);\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -4591,6 +4664,7 @@ aarch64_save_callee_saves (machine_mode mode, poly_int64 start_offset,\n     {\n       rtx reg, mem;\n       poly_int64 offset;\n+      int offset_diff;\n \n       if (skip_wb\n \t  && (regno == cfun->machine->frame.wb_candidate1\n@@ -4606,12 +4680,12 @@ aarch64_save_callee_saves (machine_mode mode, poly_int64 start_offset,\n \t\t\t\t\t\toffset));\n \n       regno2 = aarch64_next_callee_save (regno + 1, limit);\n+      offset_diff = cfun->machine->frame.reg_offset[regno2]\n+\t\t    - cfun->machine->frame.reg_offset[regno];\n \n       if (regno2 <= limit\n \t  && !cfun->machine->reg_is_wrapped_separately[regno2]\n-\t  && ((cfun->machine->frame.reg_offset[regno] + UNITS_PER_WORD)\n-\t      == cfun->machine->frame.reg_offset[regno2]))\n-\n+\t  && known_eq (GET_MODE_SIZE (mode), offset_diff))\n \t{\n \t  rtx reg2 = gen_rtx_REG (mode, regno2);\n \t  rtx mem2;\n@@ -4659,6 +4733,7 @@ aarch64_restore_callee_saves (machine_mode mode,\n        continue;\n \n       rtx reg, mem;\n+      int offset_diff;\n \n       if (skip_wb\n \t  && (regno == cfun->machine->frame.wb_candidate1\n@@ -4670,11 +4745,12 @@ aarch64_restore_callee_saves (machine_mode mode,\n       mem = gen_frame_mem (mode, plus_constant (Pmode, base_rtx, offset));\n \n       regno2 = aarch64_next_callee_save (regno + 1, limit);\n+      offset_diff = cfun->machine->frame.reg_offset[regno2]\n+\t\t    - cfun->machine->frame.reg_offset[regno];\n \n       if (regno2 <= limit\n \t  && !cfun->machine->reg_is_wrapped_separately[regno2]\n-\t  && ((cfun->machine->frame.reg_offset[regno] + UNITS_PER_WORD)\n-\t      == cfun->machine->frame.reg_offset[regno2]))\n+\t  && known_eq (GET_MODE_SIZE (mode), offset_diff))\n \t{\n \t  rtx reg2 = gen_rtx_REG (mode, regno2);\n \t  rtx mem2;\n@@ -4808,13 +4884,15 @@ aarch64_components_for_bb (basic_block bb)\n   bitmap in = DF_LIVE_IN (bb);\n   bitmap gen = &DF_LIVE_BB_INFO (bb)->gen;\n   bitmap kill = &DF_LIVE_BB_INFO (bb)->kill;\n+  bool simd_function = aarch64_simd_decl_p (cfun->decl);\n \n   sbitmap components = sbitmap_alloc (LAST_SAVED_REGNUM + 1);\n   bitmap_clear (components);\n \n   /* GPRs are used in a bb if they are in the IN, GEN, or KILL sets.  */\n   for (unsigned regno = 0; regno <= LAST_SAVED_REGNUM; regno++)\n-    if ((!call_used_regs[regno])\n+    if ((!call_used_regs[regno]\n+\t|| (simd_function && FP_SIMD_SAVED_REGNUM_P (regno)))\n        && (bitmap_bit_p (in, regno)\n \t   || bitmap_bit_p (gen, regno)\n \t   || bitmap_bit_p (kill, regno)))\n@@ -4885,9 +4963,11 @@ aarch64_process_components (sbitmap components, bool prologue_p)\n \n   while (regno != last_regno)\n     {\n-      /* AAPCS64 section 5.1.2 requires only the bottom 64 bits to be saved\n-\t so DFmode for the vector registers is enough.  */\n-      machine_mode mode = GP_REGNUM_P (regno) ? E_DImode : E_DFmode;\n+      /* AAPCS64 section 5.1.2 requires only the low 64 bits to be saved\n+\t so DFmode for the vector registers is enough.  For simd functions\n+\t we want to save the low 128 bits.  */\n+      machine_mode mode = aarch64_reg_save_mode (cfun->decl, regno);\n+      \n       rtx reg = gen_rtx_REG (mode, regno);\n       poly_int64 offset = cfun->machine->frame.reg_offset[regno];\n       if (!frame_pointer_needed)\n@@ -4916,6 +4996,7 @@ aarch64_process_components (sbitmap components, bool prologue_p)\n \t mergeable with the current one into a pair.  */\n       if (!satisfies_constraint_Ump (mem)\n \t  || GP_REGNUM_P (regno) != GP_REGNUM_P (regno2)\n+\t  || (aarch64_simd_decl_p (cfun->decl) && FP_REGNUM_P (regno))\n \t  || maybe_ne ((offset2 - cfun->machine->frame.reg_offset[regno]),\n \t\t       GET_MODE_SIZE (mode)))\n \t{\n@@ -5231,6 +5312,28 @@ aarch64_allocate_and_probe_stack_space (rtx temp1, rtx temp2,\n     }\n }\n \n+/* Return 1 if the register is used by the epilogue.  We need to say the\n+   return register is used, but only after epilogue generation is complete.\n+   Note that in the case of sibcalls, the values \"used by the epilogue\" are\n+   considered live at the start of the called function.\n+\n+   For SIMD functions we need to return 1 for FP registers that are saved and\n+   restored by a function but are not zero in call_used_regs.  If we do not do \n+   this optimizations may remove the restore of the register.  */\n+\n+int\n+aarch64_epilogue_uses (int regno)\n+{\n+  if (epilogue_completed)\n+    {\n+      if (regno == LR_REGNUM)\n+\treturn 1;\n+      if (aarch64_simd_decl_p (cfun->decl) && FP_SIMD_SAVED_REGNUM_P (regno))\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\n /* Add a REG_CFA_EXPRESSION note to INSN to say that register REG\n    is saved at BASE + OFFSET.  */\n \n@@ -5405,8 +5508,12 @@ aarch64_expand_prologue (void)\n \n   aarch64_save_callee_saves (DImode, callee_offset, R0_REGNUM, R30_REGNUM,\n \t\t\t     callee_adjust != 0 || emit_frame_chain);\n-  aarch64_save_callee_saves (DFmode, callee_offset, V0_REGNUM, V31_REGNUM,\n-\t\t\t     callee_adjust != 0 || emit_frame_chain);\n+  if (aarch64_simd_decl_p (cfun->decl))\n+    aarch64_save_callee_saves (TFmode, callee_offset, V0_REGNUM, V31_REGNUM,\n+\t\t\t       callee_adjust != 0 || emit_frame_chain);\n+  else\n+    aarch64_save_callee_saves (DFmode, callee_offset, V0_REGNUM, V31_REGNUM,\n+\t\t\t       callee_adjust != 0 || emit_frame_chain);\n \n   /* We may need to probe the final adjustment if it is larger than the guard\n      that is assumed by the called.  */\n@@ -5432,6 +5539,19 @@ aarch64_use_return_insn_p (void)\n   return known_eq (cfun->machine->frame.frame_size, 0);\n }\n \n+/* Return false for non-leaf SIMD functions in order to avoid\n+   shrink-wrapping them.  Doing this will lose the necessary\n+   save/restore of FP registers.  */\n+\n+bool\n+aarch64_use_simple_return_insn_p (void)\n+{\n+  if (aarch64_simd_decl_p (cfun->decl) && !crtl->is_leaf)\n+    return false;\n+\n+  return true;\n+}\n+\n /* Generate the epilogue instructions for returning from a function.\n    This is almost exactly the reverse of the prolog sequence, except\n    that we need to insert barriers to avoid scheduling loads that read\n@@ -5500,8 +5620,12 @@ aarch64_expand_epilogue (bool for_sibcall)\n \n   aarch64_restore_callee_saves (DImode, callee_offset, R0_REGNUM, R30_REGNUM,\n \t\t\t\tcallee_adjust != 0, &cfi_ops);\n-  aarch64_restore_callee_saves (DFmode, callee_offset, V0_REGNUM, V31_REGNUM,\n-\t\t\t\tcallee_adjust != 0, &cfi_ops);\n+  if (aarch64_simd_decl_p (cfun->decl))\n+    aarch64_restore_callee_saves (TFmode, callee_offset, V0_REGNUM, V31_REGNUM,\n+\t\t\t\t  callee_adjust != 0, &cfi_ops);\n+  else\n+    aarch64_restore_callee_saves (DFmode, callee_offset, V0_REGNUM, V31_REGNUM,\n+\t\t\t\t  callee_adjust != 0, &cfi_ops);\n \n   if (need_barrier_p)\n     emit_insn (gen_stack_tie (stack_pointer_rtx, stack_pointer_rtx));\n@@ -18422,6 +18546,9 @@ aarch64_libgcc_floating_mode_supported_p\n #undef TARGET_ESTIMATED_POLY_VALUE\n #define TARGET_ESTIMATED_POLY_VALUE aarch64_estimated_poly_value\n \n+#undef TARGET_ATTRIBUTE_TABLE\n+#define TARGET_ATTRIBUTE_TABLE aarch64_attribute_table\n+\n #if CHECKING_P\n #undef TARGET_RUN_TARGET_SELFTESTS\n #define TARGET_RUN_TARGET_SELFTESTS selftest::aarch64_run_selftests"}, {"sha": "8b5b2ab0bdb0e37d8a3fc2278715d3c8f5adbddb", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0d0b980f15035a74ec766bbbdbb73397c090f8c/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0d0b980f15035a74ec766bbbdbb73397c090f8c/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=a0d0b980f15035a74ec766bbbdbb73397c090f8c", "patch": "@@ -409,13 +409,7 @@ extern unsigned aarch64_architecture_version;\n     V_ALIASES(28), V_ALIASES(29), V_ALIASES(30), V_ALIASES(31)  \\\n   }\n \n-/* Say that the return address register is used by the epilogue, but only after\n-   epilogue generation is complete.  Note that in the case of sibcalls, the\n-   values \"used by the epilogue\" are considered live at the start of the called\n-   function.  */\n-\n-#define EPILOGUE_USES(REGNO) \\\n-  (epilogue_completed && (REGNO) == LR_REGNUM)\n+#define EPILOGUE_USES(REGNO) (aarch64_epilogue_uses (REGNO))\n \n /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n    the stack pointer does not matter.  This is only true if the function\n@@ -523,6 +517,8 @@ extern unsigned aarch64_architecture_version;\n #define PR_LO_REGNUM_P(REGNO)\\\n   (((unsigned) (REGNO - P0_REGNUM)) <= (P7_REGNUM - P0_REGNUM))\n \n+#define FP_SIMD_SAVED_REGNUM_P(REGNO)\t\t\t\\\n+  (((unsigned) (REGNO - V8_REGNUM)) <= (V23_REGNUM - V8_REGNUM))\n \f\n /* Register and constant classes.  */\n "}, {"sha": "cf2732e15e05db0a8825b1b7004fe904cc19ec19", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 64, "deletions": 1, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0d0b980f15035a74ec766bbbdbb73397c090f8c/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0d0b980f15035a74ec766bbbdbb73397c090f8c/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=a0d0b980f15035a74ec766bbbdbb73397c090f8c", "patch": "@@ -727,7 +727,7 @@\n \n (define_insn \"simple_return\"\n   [(simple_return)]\n-  \"\"\n+  \"aarch64_use_simple_return_insn_p ()\"\n   \"ret\"\n   [(set_attr \"type\" \"branch\")]\n )\n@@ -1387,6 +1387,21 @@\n    (set_attr \"arch\" \"*,fp\")]\n )\n \n+(define_insn \"load_pair_dw_tftf\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=w\")\n+\t(match_operand:TF 1 \"aarch64_mem_pair_operand\" \"Ump\"))\n+   (set (match_operand:TF 2 \"register_operand\" \"=w\")\n+\t(match_operand:TF 3 \"memory_operand\" \"m\"))]\n+   \"TARGET_SIMD\n+    && rtx_equal_p (XEXP (operands[3], 0),\n+\t\t    plus_constant (Pmode,\n+\t\t\t\t   XEXP (operands[1], 0),\n+\t\t\t\t   GET_MODE_SIZE (TFmode)))\"\n+  \"ldp\\\\t%q0, %q2, %1\"\n+  [(set_attr \"type\" \"neon_ldp_q\")\n+   (set_attr \"fp\" \"yes\")]\n+)\n+\n ;; Operands 0 and 2 are tied together by the final condition; so we allow\n ;; fairly lax checking on the second memory operation.\n (define_insn \"store_pair_sw_<SX:mode><SX2:mode>\"\n@@ -1422,6 +1437,21 @@\n    (set_attr \"arch\" \"*,fp\")]\n )\n \n+(define_insn \"store_pair_dw_tftf\"\n+  [(set (match_operand:TF 0 \"aarch64_mem_pair_operand\" \"=Ump\")\n+\t(match_operand:TF 1 \"register_operand\" \"w\"))\n+   (set (match_operand:TF 2 \"memory_operand\" \"=m\")\n+\t(match_operand:TF 3 \"register_operand\" \"w\"))]\n+   \"TARGET_SIMD &&\n+    rtx_equal_p (XEXP (operands[2], 0),\n+\t\t plus_constant (Pmode,\n+\t\t\t\tXEXP (operands[0], 0),\n+\t\t\t\tGET_MODE_SIZE (TFmode)))\"\n+  \"stp\\\\t%q1, %q3, %0\"\n+  [(set_attr \"type\" \"neon_stp_q\")\n+   (set_attr \"fp\" \"yes\")]\n+)\n+\n ;; Load pair with post-index writeback.  This is primarily used in function\n ;; epilogues.\n (define_insn \"loadwb_pair<GPI:mode>_<P:mode>\"\n@@ -1454,6 +1484,21 @@\n   [(set_attr \"type\" \"neon_load1_2reg\")]\n )\n \n+(define_insn \"loadwb_pair<TX:mode>_<P:mode>\"\n+  [(parallel\n+    [(set (match_operand:P 0 \"register_operand\" \"=k\")\n+          (plus:P (match_operand:P 1 \"register_operand\" \"0\")\n+                  (match_operand:P 4 \"aarch64_mem_pair_offset\" \"n\")))\n+     (set (match_operand:TX 2 \"register_operand\" \"=w\")\n+          (mem:TX (match_dup 1)))\n+     (set (match_operand:TX 3 \"register_operand\" \"=w\")\n+          (mem:TX (plus:P (match_dup 1)\n+\t\t\t  (match_operand:P 5 \"const_int_operand\" \"n\"))))])]\n+  \"TARGET_SIMD && INTVAL (operands[5]) == GET_MODE_SIZE (<TX:MODE>mode)\"\n+  \"ldp\\\\t%q2, %q3, [%1], %4\"\n+  [(set_attr \"type\" \"neon_ldp_q\")]\n+)\n+\n ;; Store pair with pre-index writeback.  This is primarily used in function\n ;; prologues.\n (define_insn \"storewb_pair<GPI:mode>_<P:mode>\"\n@@ -1488,6 +1533,24 @@\n   [(set_attr \"type\" \"neon_store1_2reg<q>\")]\n )\n \n+(define_insn \"storewb_pair<TX:mode>_<P:mode>\"\n+  [(parallel\n+    [(set (match_operand:P 0 \"register_operand\" \"=&k\")\n+          (plus:P (match_operand:P 1 \"register_operand\" \"0\")\n+                  (match_operand:P 4 \"aarch64_mem_pair_offset\" \"n\")))\n+     (set (mem:TX (plus:P (match_dup 0)\n+\t\t\t  (match_dup 4)))\n+          (match_operand:TX 2 \"register_operand\" \"w\"))\n+     (set (mem:TX (plus:P (match_dup 0)\n+\t\t\t  (match_operand:P 5 \"const_int_operand\" \"n\")))\n+          (match_operand:TX 3 \"register_operand\" \"w\"))])]\n+  \"TARGET_SIMD\n+   && INTVAL (operands[5])\n+      == INTVAL (operands[4]) + GET_MODE_SIZE (<TX:MODE>mode)\"\n+  \"stp\\\\t%q2, %q3, [%0, %4]!\"\n+  [(set_attr \"type\" \"neon_stp_q\")]\n+)\n+\n ;; -------------------------------------------------------------------\n ;; Sign/Zero extension\n ;; -------------------------------------------------------------------"}]}