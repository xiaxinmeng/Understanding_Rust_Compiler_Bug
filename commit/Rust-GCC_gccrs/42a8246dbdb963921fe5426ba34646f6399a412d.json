{"sha": "42a8246dbdb963921fe5426ba34646f6399a412d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJhODI0NmRiZGI5NjM5MjFmZTU0MjZiYTM0NjQ2ZjYzOTlhNDEyZA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2014-07-12T19:02:57Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2014-07-12T19:02:57Z"}, "message": "libgfortran.h (libcaf_atomic_codes): Add.\n\n2014-07-12  Tobias Burnus  <burnus@net-b.de>\n\ngcc/fortran/\n        * libgfortran.h (libcaf_atomic_codes): Add.\n        * trans-decl.c (gfor_fndecl_caf_atomic_def,\n        gfor_fndecl_caf_atomic_ref, gfor_fndecl_caf_atomic_cas,\n        gfor_fndecl_caf_atomic_op): New variables.\n        (gfc_build_builtin_function_decls): Initialize them.\n        * trans.h (gfor_fndecl_caf_atomic_def,\n        gfor_fndecl_caf_atomic_ref, gfor_fndecl_caf_atomic_cas,\n        gfor_fndecl_caf_atomic_op): New variables.\n        * trans-intrinsic.c (conv_intrinsic_atomic_op,\n        conv_intrinsic_atomic_ref, conv_intrinsic_atomic_cas):\n        Add library calls with -fcoarray=lib.\n\nlibgfortran/\n        * caf/libcaf.h (_gfortran_caf_atomic_define,\n        _gfortran_caf_atomic_ref, _gfortran_caf_atomic_op,\n        _gfortran_caf_atomic_cas): New prototypes.\n        * caf/single.c (_gfortran_caf_atomic_define,\n        _gfortran_caf_atomic_ref, _gfortran_caf_atomic_op,\n        _gfortran_caf_atomic_cas): New functions.\n\nFrom-SVN: r212484", "tree": {"sha": "9c63676c636ff51b2efc0a019d14caccdf82245e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c63676c636ff51b2efc0a019d14caccdf82245e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42a8246dbdb963921fe5426ba34646f6399a412d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42a8246dbdb963921fe5426ba34646f6399a412d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42a8246dbdb963921fe5426ba34646f6399a412d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42a8246dbdb963921fe5426ba34646f6399a412d/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7f4aaf912bdab4fe3ccad012add9a1d00a26dab1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1"}], "stats": {"total": 511, "additions": 430, "deletions": 81}, "files": [{"sha": "4ec7835ddec1ed6f1991520d2c3b3cac970922f3", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42a8246dbdb963921fe5426ba34646f6399a412d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42a8246dbdb963921fe5426ba34646f6399a412d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=42a8246dbdb963921fe5426ba34646f6399a412d", "patch": "@@ -1,3 +1,17 @@\n+2014-07-12  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* libgfortran.h (libcaf_atomic_codes): Add.\n+\t* trans-decl.c (gfor_fndecl_caf_atomic_def,\n+\tgfor_fndecl_caf_atomic_ref, gfor_fndecl_caf_atomic_cas,\n+\tgfor_fndecl_caf_atomic_op): New variables.\n+\t(gfc_build_builtin_function_decls): Initialize them.\n+\t* trans.h (gfor_fndecl_caf_atomic_def,\n+\tgfor_fndecl_caf_atomic_ref, gfor_fndecl_caf_atomic_cas,\n+\tgfor_fndecl_caf_atomic_op): New variables.\n+\t* trans-intrinsic.c (conv_intrinsic_atomic_op,\n+\tconv_intrinsic_atomic_ref, conv_intrinsic_atomic_cas):\n+\tAdd library calls with -fcoarray=lib.\n+\n 2014-07-12  Tobias Burnus  <burnus@net-b.de>\n \n \t* check.c (gfc_check_atomic): Update for STAT=."}, {"sha": "df5c14f8cc660932d5263a8e531fe76d8773e90f", "filename": "gcc/fortran/libgfortran.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42a8246dbdb963921fe5426ba34646f6399a412d/gcc%2Ffortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42a8246dbdb963921fe5426ba34646f6399a412d/gcc%2Ffortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flibgfortran.h?ref=42a8246dbdb963921fe5426ba34646f6399a412d", "patch": "@@ -120,6 +120,14 @@ typedef enum\n }\n libgfortran_stat_codes;\n \n+typedef enum\n+{\n+  GFC_CAF_ATOMIC_ADD = 1,\n+  GFC_CAF_ATOMIC_AND,\n+  GFC_CAF_ATOMIC_OR,\n+  GFC_CAF_ATOMIC_XOR\n+} libcaf_atomic_codes;\n+\n /* Default unit number for preconnected standard input and output.  */\n #define GFC_STDIN_UNIT_NUMBER 5\n #define GFC_STDOUT_UNIT_NUMBER 6"}, {"sha": "4db10becfd48d8cb7eb43a217550f88c2667d0ec", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42a8246dbdb963921fe5426ba34646f6399a412d/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42a8246dbdb963921fe5426ba34646f6399a412d/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=42a8246dbdb963921fe5426ba34646f6399a412d", "patch": "@@ -141,6 +141,10 @@ tree gfor_fndecl_caf_sync_all;\n tree gfor_fndecl_caf_sync_images;\n tree gfor_fndecl_caf_error_stop;\n tree gfor_fndecl_caf_error_stop_str;\n+tree gfor_fndecl_caf_atomic_def;\n+tree gfor_fndecl_caf_atomic_ref;\n+tree gfor_fndecl_caf_atomic_cas;\n+tree gfor_fndecl_caf_atomic_op;\n tree gfor_fndecl_co_max;\n tree gfor_fndecl_co_min;\n tree gfor_fndecl_co_sum;\n@@ -3391,6 +3395,28 @@ gfc_build_builtin_function_decls (void)\n       /* CAF's ERROR STOP doesn't return.  */\n       TREE_THIS_VOLATILE (gfor_fndecl_caf_error_stop_str) = 1;\n \n+      gfor_fndecl_caf_atomic_def = gfc_build_library_function_decl_with_spec (\n+\tget_identifier (PREFIX(\"caf_atomic_define\")), \"R..RW\",\n+\tvoid_type_node, 7, pvoid_type_node, size_type_node, integer_type_node,\n+        pvoid_type_node, pint_type, integer_type_node, integer_type_node);\n+\n+      gfor_fndecl_caf_atomic_ref = gfc_build_library_function_decl_with_spec (\n+\tget_identifier (PREFIX(\"caf_atomic_ref\")), \"R..WW\",\n+\tvoid_type_node, 7, pvoid_type_node, size_type_node, integer_type_node,\n+        pvoid_type_node, pint_type, integer_type_node, integer_type_node);\n+\n+      gfor_fndecl_caf_atomic_cas = gfc_build_library_function_decl_with_spec (\n+\tget_identifier (PREFIX(\"caf_atomic_cas\")), \"R..WRRW\",\n+\tvoid_type_node, 9, pvoid_type_node, size_type_node, integer_type_node,\n+        pvoid_type_node, pvoid_type_node, pvoid_type_node, pint_type,\n+\tinteger_type_node, integer_type_node);\n+\n+      gfor_fndecl_caf_atomic_op = gfc_build_library_function_decl_with_spec (\n+\tget_identifier (PREFIX(\"caf_atomic_op\")), \".R..RWW\",\n+\tvoid_type_node, 9, integer_type_node, pvoid_type_node, size_type_node,\n+\tinteger_type_node, pvoid_type_node, pvoid_type_node, pint_type,\n+\tinteger_type_node, integer_type_node);\n+\n       gfor_fndecl_co_max = gfc_build_library_function_decl_with_spec (\n \tget_identifier (PREFIX(\"caf_co_max\")), \"W.WW\",\n \tvoid_type_node, 6, pvoid_type_node, integer_type_node,"}, {"sha": "57b7f4d1b30134dee4057cf837f360f8bddacce0", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 270, "deletions": 81, "changes": 351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42a8246dbdb963921fe5426ba34646f6399a412d/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42a8246dbdb963921fe5426ba34646f6399a412d/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=42a8246dbdb963921fe5426ba34646f6399a412d", "patch": "@@ -7007,7 +7007,7 @@ gfc_conv_intrinsic_loc (gfc_se * se, gfc_expr * expr)\n     gfc_conv_expr_reference (se, arg_expr);\n   else\n     gfc_conv_array_parameter (se, arg_expr, true, NULL, NULL, NULL);\n-  se->expr= convert (gfc_get_int_type (gfc_index_integer_kind), se->expr);\n+  se->expr = convert (gfc_get_int_type (gfc_index_integer_kind), se->expr);\n    \n   /* Create a temporary variable for loc return value.  Without this, \n      we get an error an ICE in gcc/expr.c(expand_expr_addr_expr_1).  */\n@@ -8341,11 +8341,11 @@ conv_co_minmaxsum (gfc_code *code)\n static tree\n conv_intrinsic_atomic_op (gfc_code *code)\n {\n-  gfc_se atom, value, old;\n-  tree tmp;\n+  gfc_se argse;\n+  tree tmp, atom, value, old = NULL_TREE, stat = NULL_TREE;\n   stmtblock_t block, post_block;\n   gfc_expr *atom_expr = code->ext.actual->expr;\n-  gfc_expr *stat;\n+  gfc_expr *stat_expr;\n   built_in_function fn;\n \n   if (atom_expr->expr_type == EXPR_FUNCTION\n@@ -8355,15 +8355,129 @@ conv_intrinsic_atomic_op (gfc_code *code)\n \n   gfc_start_block (&block);\n   gfc_init_block (&post_block);\n-  gfc_init_se (&atom, NULL);\n-  gfc_init_se (&value, NULL);\n-  atom.want_pointer = 1;\n-  gfc_conv_expr (&atom, atom_expr);\n-  gfc_add_block_to_block (&block, &atom.pre);\n-  gfc_add_block_to_block (&post_block, &atom.post);\n-  gfc_conv_expr (&value, code->ext.actual->next->expr);\n-  gfc_add_block_to_block (&block, &value.pre);\n-  gfc_add_block_to_block (&post_block, &value.post);\n+\n+  gfc_init_se (&argse, NULL);\n+  argse.want_pointer = 1;\n+  gfc_conv_expr (&argse, atom_expr);\n+  gfc_add_block_to_block (&block, &argse.pre);\n+  gfc_add_block_to_block (&post_block, &argse.post);\n+  atom = argse.expr;\n+\n+  gfc_init_se (&argse, NULL);\n+  if (gfc_option.coarray == GFC_FCOARRAY_LIB\n+      && code->ext.actual->next->expr->ts.kind == atom_expr->ts.kind)\n+    argse.want_pointer = 1;\n+  gfc_conv_expr (&argse, code->ext.actual->next->expr);\n+  gfc_add_block_to_block (&block, &argse.pre);\n+  gfc_add_block_to_block (&post_block, &argse.post);\n+  value = argse.expr;\n+\n+  switch (code->resolved_isym->id)\n+    {\n+    case GFC_ISYM_ATOMIC_ADD:\n+    case GFC_ISYM_ATOMIC_AND:\n+    case GFC_ISYM_ATOMIC_DEF:\n+    case GFC_ISYM_ATOMIC_OR:\n+    case GFC_ISYM_ATOMIC_XOR:\n+      stat_expr = code->ext.actual->next->next->expr;\n+      if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+\told = null_pointer_node;\n+      break;\n+    default:\n+      gfc_init_se (&argse, NULL);\n+      if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+\targse.want_pointer = 1;\n+      gfc_conv_expr (&argse, code->ext.actual->next->next->expr);\n+      gfc_add_block_to_block (&block, &argse.pre);\n+      gfc_add_block_to_block (&post_block, &argse.post);\n+      old = argse.expr;\n+      stat_expr = code->ext.actual->next->next->next->expr;\n+    }\n+\n+  /* STAT=  */\n+  if (stat_expr != NULL)\n+    {\n+      gcc_assert (stat_expr->expr_type == EXPR_VARIABLE);\n+      gfc_init_se (&argse, NULL);\n+      if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+\targse.want_pointer = 1;\n+      gfc_conv_expr_val (&argse, stat_expr);\n+      gfc_add_block_to_block (&block, &argse.pre);\n+      gfc_add_block_to_block (&post_block, &argse.post);\n+      stat = argse.expr;\n+    }\n+  else if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+    stat = null_pointer_node;\n+\n+  if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+    {\n+      tree image_index, caf_decl, offset, token;\n+      int op;\n+\n+      switch (code->resolved_isym->id)\n+\t{\n+\tcase GFC_ISYM_ATOMIC_ADD:\n+\tcase GFC_ISYM_ATOMIC_FETCH_ADD:\n+\t  op = (int) GFC_CAF_ATOMIC_ADD;\n+\t  break;\n+\tcase GFC_ISYM_ATOMIC_AND:\n+\tcase GFC_ISYM_ATOMIC_FETCH_AND:\n+\t  op = (int) GFC_CAF_ATOMIC_AND;\n+\t  break;\n+\tcase GFC_ISYM_ATOMIC_OR:\n+\tcase GFC_ISYM_ATOMIC_FETCH_OR:\n+\t  op = (int) GFC_CAF_ATOMIC_OR;\n+\t  break;\n+\tcase GFC_ISYM_ATOMIC_XOR:\n+\tcase GFC_ISYM_ATOMIC_FETCH_XOR:\n+\t  op = (int) GFC_CAF_ATOMIC_XOR;\n+\t  break;\n+\tcase GFC_ISYM_ATOMIC_DEF:\n+\t  op = 0;  /* Unused.  */\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      caf_decl = gfc_get_tree_for_caf_expr (atom_expr);\n+      if (TREE_CODE (TREE_TYPE (caf_decl)) == REFERENCE_TYPE)\n+\tcaf_decl = build_fold_indirect_ref_loc (input_location, caf_decl);\n+\n+      if (gfc_is_coindexed (atom_expr))\n+\timage_index = caf_get_image_index (&block, atom_expr, caf_decl);\n+      else\n+\timage_index = integer_zero_node;\n+\n+      if (TREE_TYPE (TREE_TYPE (atom)) != TREE_TYPE (TREE_TYPE (value)))\n+\t{\n+\t  tmp = gfc_create_var (TREE_TYPE (TREE_TYPE (atom)), \"value\");\n+\t  gfc_add_modify (&block, tmp, fold_convert (TREE_TYPE (tmp), value));\n+          value = gfc_build_addr_expr (NULL_TREE, tmp);\n+\t}\n+\n+      get_caf_token_offset (&token, &offset, caf_decl, atom, atom_expr);\n+\n+      if (code->resolved_isym->id == GFC_ISYM_ATOMIC_DEF)\n+\ttmp = build_call_expr_loc (input_location, gfor_fndecl_caf_atomic_def, 7,\n+\t\t\t\t   token, offset, image_index, value, stat,\n+\t\t\t\t   build_int_cst (integer_type_node,\n+\t\t\t\t\t\t  (int) atom_expr->ts.type),\n+\t\t\t\t   build_int_cst (integer_type_node,\n+\t\t\t\t\t\t  (int) atom_expr->ts.kind));\n+      else\n+\ttmp = build_call_expr_loc (input_location, gfor_fndecl_caf_atomic_op, 9,\n+\t\t\t\t   build_int_cst (integer_type_node, op),\n+\t\t\t\t   token, offset, image_index, value, old, stat,\n+\t\t\t\t   build_int_cst (integer_type_node,\n+\t\t\t\t\t\t  (int) atom_expr->ts.type),\n+\t\t\t\t   build_int_cst (integer_type_node,\n+\t\t\t\t\t\t  (int) atom_expr->ts.kind));\n+\n+      gfc_add_expr_to_block (&block, tmp);\n+      gfc_add_block_to_block (&block, &post_block);\n+      return gfc_finish_block (&block);\n+    }\n+\n \n   switch (code->resolved_isym->id)\n     {\n@@ -8390,12 +8504,12 @@ conv_intrinsic_atomic_op (gfc_code *code)\n       gcc_unreachable ();\n     }\n \n-  tmp = TREE_TYPE (TREE_TYPE (atom.expr));\n+  tmp = TREE_TYPE (TREE_TYPE (atom));\n   fn = (built_in_function) ((int) fn\n \t\t\t    + exact_log2 (tree_to_uhwi (TYPE_SIZE_UNIT (tmp)))\n \t\t\t    + 1);\n   tmp = builtin_decl_explicit (fn);\n-  tree itype = TREE_TYPE (TREE_TYPE (atom.expr));\n+  tree itype = TREE_TYPE (TREE_TYPE (atom));\n   tmp = builtin_decl_explicit (fn);\n \n   switch (code->resolved_isym->id)\n@@ -8405,37 +8519,21 @@ conv_intrinsic_atomic_op (gfc_code *code)\n     case GFC_ISYM_ATOMIC_DEF:\n     case GFC_ISYM_ATOMIC_OR:\n     case GFC_ISYM_ATOMIC_XOR:\n-      stat = code->ext.actual->next->next->expr;\n-      tmp = build_call_expr_loc (input_location, tmp, 3, atom.expr,\n-\t\t\t\t fold_convert (itype, value.expr),\n+      tmp = build_call_expr_loc (input_location, tmp, 3, atom,\n+\t\t\t\t fold_convert (itype, value),\n \t\t\t\t build_int_cst (NULL, MEMMODEL_RELAXED));\n       gfc_add_expr_to_block (&block, tmp);\n       break;\n     default:\n-      stat = code->ext.actual->next->next->next->expr;\n-      gfc_init_se (&old, NULL);\n-      gfc_conv_expr (&old, code->ext.actual->next->next->expr);\n-      gfc_add_block_to_block (&block, &old.pre);\n-      gfc_add_block_to_block (&post_block, &old.post);\n-      tmp = build_call_expr_loc (input_location, tmp, 3, atom.expr,\n-\t\t\t\t fold_convert (itype, value.expr),\n+      tmp = build_call_expr_loc (input_location, tmp, 3, atom,\n+\t\t\t\t fold_convert (itype, value),\n \t\t\t\t build_int_cst (NULL, MEMMODEL_RELAXED));\n-      gfc_add_modify (&block, old.expr,\n-\t\t      fold_convert (TREE_TYPE (old.expr), tmp));\n+      gfc_add_modify (&block, old, fold_convert (TREE_TYPE (old), tmp));\n       break;\n     }\n \n-  /* STAT=  */\n-  if (stat != NULL)\n-    {\n-      gcc_assert (stat->expr_type == EXPR_VARIABLE);\n-      gfc_init_se (&value, NULL);\n-      gfc_conv_expr_val (&value, stat);\n-      gfc_add_block_to_block (&block, &value.pre);\n-      gfc_add_block_to_block (&post_block, &value.post);\n-      gfc_add_modify (&block, value.expr,\n-\t\t      build_int_cst (TREE_TYPE (value.expr), 0));\n-    }\n+  if (stat != NULL_TREE)\n+    gfc_add_modify (&block, stat, build_int_cst (TREE_TYPE (stat), 0));\n   gfc_add_block_to_block (&block, &post_block);\n   return gfc_finish_block (&block);\n }\n@@ -8444,8 +8542,8 @@ conv_intrinsic_atomic_op (gfc_code *code)\n static tree\n conv_intrinsic_atomic_ref (gfc_code *code)\n {\n-  gfc_se atom, value;\n-  tree tmp;\n+  gfc_se argse;\n+  tree tmp, atom, value, stat = NULL_TREE;\n   stmtblock_t block, post_block;\n   built_in_function fn;\n   gfc_expr *atom_expr = code->ext.actual->next->expr;\n@@ -8457,39 +8555,75 @@ conv_intrinsic_atomic_ref (gfc_code *code)\n \n   gfc_start_block (&block);\n   gfc_init_block (&post_block);\n-  gfc_init_se (&atom, NULL);\n-  gfc_init_se (&value, NULL);\n-  atom.want_pointer = 1;\n-  gfc_conv_expr (&value, code->ext.actual->expr);\n-  gfc_add_block_to_block (&block, &value.pre);\n-  gfc_add_block_to_block (&post_block, &value.post);\n-  gfc_conv_expr (&atom, atom_expr);\n-  gfc_add_block_to_block (&block, &atom.pre);\n-  gfc_add_block_to_block (&post_block, &atom.post);\n-\n-  tmp = TREE_TYPE (TREE_TYPE (atom.expr));\n-  fn = (built_in_function) ((int) BUILT_IN_ATOMIC_LOAD_N\n-\t\t\t    + exact_log2 (tree_to_uhwi (TYPE_SIZE_UNIT (tmp)))\n-\t\t\t    + 1);\n-  tmp = builtin_decl_explicit (fn);\n-  tmp = build_call_expr_loc (input_location, tmp, 2, atom.expr,\n-\t\t\t     build_int_cst (integer_type_node,\n-\t\t\t\t\t    MEMMODEL_RELAXED));\n-  gfc_add_modify (&block, value.expr,\n-\t\t  fold_convert (TREE_TYPE (value.expr), tmp));\n-  \n+  gfc_init_se (&argse, NULL);\n+  argse.want_pointer = 1;\n+  gfc_conv_expr (&argse, atom_expr);\n+  gfc_add_block_to_block (&block, &argse.pre);\n+  gfc_add_block_to_block (&post_block, &argse.post);\n+  atom = argse.expr;\n+\n+  gfc_init_se (&argse, NULL);\n+  if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+    argse.want_pointer = 1;\n+  gfc_conv_expr (&argse, code->ext.actual->expr);\n+  gfc_add_block_to_block (&block, &argse.pre);\n+  gfc_add_block_to_block (&post_block, &argse.post);\n+  value = argse.expr;\n+\n   /* STAT=  */\n   if (code->ext.actual->next->next->expr != NULL)\n     {\n       gcc_assert (code->ext.actual->next->next->expr->expr_type\n \t\t  == EXPR_VARIABLE);\n-      gfc_init_se (&value, NULL);\n-      gfc_conv_expr_val (&value, code->ext.actual->next->next->expr);\n-      gfc_add_block_to_block (&block, &value.pre);\n-      gfc_add_block_to_block (&post_block, &value.post);\n-      gfc_add_modify (&block, value.expr,\n-\t\t      build_int_cst (TREE_TYPE (value.expr), 0));\n+      gfc_init_se (&argse, NULL);\n+      if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+\targse.want_pointer = 1;\n+      gfc_conv_expr_val (&argse, code->ext.actual->next->next->expr);\n+      gfc_add_block_to_block (&block, &argse.pre);\n+      gfc_add_block_to_block (&post_block, &argse.post);\n+      stat = argse.expr;\n+    }\n+  else if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+    stat = null_pointer_node;\n+\n+  if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+    {\n+      tree image_index, caf_decl, offset, token;\n+\n+      caf_decl = gfc_get_tree_for_caf_expr (atom_expr);\n+      if (TREE_CODE (TREE_TYPE (caf_decl)) == REFERENCE_TYPE)\n+\tcaf_decl = build_fold_indirect_ref_loc (input_location, caf_decl);\n+\n+      if (gfc_is_coindexed (atom_expr))\n+\timage_index = caf_get_image_index (&block, atom_expr, caf_decl);\n+      else\n+\timage_index = integer_zero_node;\n+\n+      get_caf_token_offset (&token, &offset, caf_decl, atom, atom_expr);\n+\n+      tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_atomic_ref, 7,\n+\t\t\t\t token, offset, image_index, value, stat,\n+\t\t\t\t build_int_cst (integer_type_node,\n+\t\t\t\t\t\t(int) atom_expr->ts.type),\n+\t\t\t\t build_int_cst (integer_type_node,\n+\t\t\t\t\t\t(int) atom_expr->ts.kind));\n+      gfc_add_expr_to_block (&block, tmp);\n+      gfc_add_block_to_block (&block, &post_block);\n+      return gfc_finish_block (&block);\n     }\n+\n+  tmp = TREE_TYPE (TREE_TYPE (atom));\n+  fn = (built_in_function) ((int) BUILT_IN_ATOMIC_LOAD_N\n+\t\t\t    + exact_log2 (tree_to_uhwi (TYPE_SIZE_UNIT (tmp)))\n+\t\t\t    + 1);\n+  tmp = builtin_decl_explicit (fn);\n+  tmp = build_call_expr_loc (input_location, tmp, 2, atom,\n+\t\t\t     build_int_cst (integer_type_node,\n+\t\t\t\t\t    MEMMODEL_RELAXED));\n+  gfc_add_modify (&block, value, fold_convert (TREE_TYPE (value), tmp));\n+\n+  if (stat != NULL_TREE)\n+    gfc_add_modify (&block, stat, build_int_cst (TREE_TYPE (stat), 0));\n   gfc_add_block_to_block (&block, &post_block);\n   return gfc_finish_block (&block);\n }\n@@ -8499,7 +8633,7 @@ static tree\n conv_intrinsic_atomic_cas (gfc_code *code)\n {\n   gfc_se argse;\n-  tree tmp, atom, old, new_val, comp;\n+  tree tmp, atom, old, new_val, comp, stat = NULL_TREE;\n   stmtblock_t block, post_block;\n   built_in_function fn;\n   gfc_expr *atom_expr = code->ext.actual->expr;\n@@ -8517,23 +8651,89 @@ conv_intrinsic_atomic_cas (gfc_code *code)\n   atom = argse.expr;\n \n   gfc_init_se (&argse, NULL);\n+  if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+    argse.want_pointer = 1;\n   gfc_conv_expr (&argse, code->ext.actual->next->expr);\n   gfc_add_block_to_block (&block, &argse.pre);\n   gfc_add_block_to_block (&post_block, &argse.post);\n   old = argse.expr;\n \n   gfc_init_se (&argse, NULL);\n+  if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+    argse.want_pointer = 1;\n   gfc_conv_expr (&argse, code->ext.actual->next->next->expr);\n   gfc_add_block_to_block (&block, &argse.pre);\n   gfc_add_block_to_block (&post_block, &argse.post);\n   comp = argse.expr;\n \n   gfc_init_se (&argse, NULL);\n+  if (gfc_option.coarray == GFC_FCOARRAY_LIB\n+      && code->ext.actual->next->next->next->expr->ts.kind\n+\t == atom_expr->ts.kind)\n+    argse.want_pointer = 1;\n   gfc_conv_expr (&argse, code->ext.actual->next->next->next->expr);\n   gfc_add_block_to_block (&block, &argse.pre);\n   gfc_add_block_to_block (&post_block, &argse.post);\n   new_val = argse.expr;\n \n+  /* STAT=  */\n+  if (code->ext.actual->next->next->next->next->expr != NULL)\n+    {\n+      gcc_assert (code->ext.actual->next->next->next->next->expr->expr_type\n+\t\t  == EXPR_VARIABLE);\n+      gfc_init_se (&argse, NULL);\n+      if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+\targse.want_pointer = 1;\n+      gfc_conv_expr_val (&argse,\n+\t\t\t code->ext.actual->next->next->next->next->expr);\n+      gfc_add_block_to_block (&block, &argse.pre);\n+      gfc_add_block_to_block (&post_block, &argse.post);\n+      stat = argse.expr;\n+    }\n+  else if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+    stat = null_pointer_node;\n+\n+  if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n+    {\n+      tree image_index, caf_decl, offset, token;\n+\n+      caf_decl = gfc_get_tree_for_caf_expr (atom_expr);\n+      if (TREE_CODE (TREE_TYPE (caf_decl)) == REFERENCE_TYPE)\n+\tcaf_decl = build_fold_indirect_ref_loc (input_location, caf_decl);\n+\n+      if (gfc_is_coindexed (atom_expr))\n+\timage_index = caf_get_image_index (&block, atom_expr, caf_decl);\n+      else\n+\timage_index = integer_zero_node;\n+\n+      if (TREE_TYPE (TREE_TYPE (new_val)) != TREE_TYPE (TREE_TYPE (old)))\n+\t{\n+\t  tmp = gfc_create_var (TREE_TYPE (TREE_TYPE (old)), \"new\");\n+\t  gfc_add_modify (&block, tmp, fold_convert (TREE_TYPE (tmp), new_val));\n+          new_val = gfc_build_addr_expr (NULL_TREE, tmp);\n+\t}\n+\n+      /* Convert a constant to a pointer.  */\n+      if (!POINTER_TYPE_P (TREE_TYPE (comp)))\n+\t{\n+\t  tmp = gfc_create_var (TREE_TYPE (TREE_TYPE (old)), \"comp\");\n+\t  gfc_add_modify (&block, tmp, fold_convert (TREE_TYPE (tmp), comp));\n+          comp = gfc_build_addr_expr (NULL_TREE, tmp);\n+\t}\n+\n+      get_caf_token_offset (&token, &offset, caf_decl, atom, atom_expr);\n+\n+      tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_atomic_cas, 9,\n+\t\t\t\t token, offset, image_index, old, comp, new_val,\n+\t\t\t\t stat, build_int_cst (integer_type_node,\n+\t\t\t\t\t\t      (int) atom_expr->ts.type),\n+\t\t\t\t build_int_cst (integer_type_node,\n+\t\t\t\t\t\t(int) atom_expr->ts.kind));\n+      gfc_add_expr_to_block (&block, tmp);\n+      gfc_add_block_to_block (&block, &post_block);\n+      return gfc_finish_block (&block);\n+    }\n+\n   tmp = TREE_TYPE (TREE_TYPE (atom));\n   fn = (built_in_function) ((int) BUILT_IN_ATOMIC_COMPARE_EXCHANGE_N\n \t\t\t    + exact_log2 (tree_to_uhwi (TYPE_SIZE_UNIT (tmp)))\n@@ -8549,19 +8749,8 @@ conv_intrinsic_atomic_cas (gfc_code *code)\n \t\t\t     build_int_cst (NULL, MEMMODEL_RELAXED));\n   gfc_add_expr_to_block (&block, tmp);\n   \n-  /* STAT=  */\n-  if (code->ext.actual->next->next->next->next->expr != NULL)\n-    {\n-      gcc_assert (code->ext.actual->next->next->next->next->expr->expr_type\n-\t\t  == EXPR_VARIABLE);\n-      gfc_init_se (&argse, NULL);\n-      gfc_conv_expr_val (&argse,\n-\t\t\t code->ext.actual->next->next->next->next->expr);\n-      gfc_add_block_to_block (&block, &argse.pre);\n-      gfc_add_block_to_block (&post_block, &argse.post);\n-      gfc_add_modify (&block, argse.expr,\n-\t\t      build_int_cst (TREE_TYPE (argse.expr), 0));\n-    }\n+  if (stat != NULL_TREE)\n+    gfc_add_modify (&block, stat, build_int_cst (TREE_TYPE (stat), 0));\n   gfc_add_block_to_block (&block, &post_block);\n   return gfc_finish_block (&block);\n }"}, {"sha": "bae51bf515a8efb486ffb045eaa578696230657c", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42a8246dbdb963921fe5426ba34646f6399a412d/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42a8246dbdb963921fe5426ba34646f6399a412d/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=42a8246dbdb963921fe5426ba34646f6399a412d", "patch": "@@ -720,6 +720,10 @@ extern GTY(()) tree gfor_fndecl_caf_sync_all;\n extern GTY(()) tree gfor_fndecl_caf_sync_images;\n extern GTY(()) tree gfor_fndecl_caf_error_stop;\n extern GTY(()) tree gfor_fndecl_caf_error_stop_str;\n+extern GTY(()) tree gfor_fndecl_caf_atomic_def;\n+extern GTY(()) tree gfor_fndecl_caf_atomic_ref;\n+extern GTY(()) tree gfor_fndecl_caf_atomic_cas;\n+extern GTY(()) tree gfor_fndecl_caf_atomic_op;\n extern GTY(()) tree gfor_fndecl_co_max;\n extern GTY(()) tree gfor_fndecl_co_min;\n extern GTY(()) tree gfor_fndecl_co_sum;"}, {"sha": "8a71b8046fccfdba0951fd82baeeb6907539c5b4", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42a8246dbdb963921fe5426ba34646f6399a412d/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42a8246dbdb963921fe5426ba34646f6399a412d/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=42a8246dbdb963921fe5426ba34646f6399a412d", "patch": "@@ -1,3 +1,12 @@\n+2014-07-12  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* caf/libcaf.h (_gfortran_caf_atomic_define,\n+\t_gfortran_caf_atomic_ref, _gfortran_caf_atomic_op,\n+\t_gfortran_caf_atomic_cas): New prototypes.\n+\t* caf/single.c (_gfortran_caf_atomic_define,\n+\t_gfortran_caf_atomic_ref, _gfortran_caf_atomic_op,\n+\t_gfortran_caf_atomic_cas): New functions.\n+\n 2014-07-10  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \t* config/fpu-*.h (get_fpu_rounding_mode, set_fpu_rounding_mode,"}, {"sha": "0ae7135885f0ba13423f8cf40da7458cc5cbca49", "filename": "libgfortran/caf/libcaf.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42a8246dbdb963921fe5426ba34646f6399a412d/libgfortran%2Fcaf%2Flibcaf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42a8246dbdb963921fe5426ba34646f6399a412d/libgfortran%2Fcaf%2Flibcaf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fcaf%2Flibcaf.h?ref=42a8246dbdb963921fe5426ba34646f6399a412d", "patch": "@@ -128,4 +128,13 @@ void _gfortran_caf_send (caf_token_t, size_t, int, gfc_descriptor_t *,\n void _gfortran_caf_sendget (caf_token_t, size_t, int, gfc_descriptor_t *,\n \t\t\t    caf_vector_t *, caf_token_t, size_t, int,\n \t\t\t    gfc_descriptor_t *, caf_vector_t *, int, int);\n+\n+void _gfortran_caf_atomic_define (caf_token_t, size_t, int, void *, int *,\n+\t\t\t\t  int, int);\n+void _gfortran_caf_atomic_ref (caf_token_t, size_t, int, void *, int *,\n+\t\t\t       int, int);\n+void _gfortran_caf_atomic_cas (caf_token_t, size_t, int, void *, void *,\n+\t\t\t       void *, int *, int, int);\n+void _gfortran_caf_atomic_op (int, caf_token_t, size_t, int, void *, void *,\n+\t\t\t      int *, int, int);\n #endif  /* LIBCAF_H  */"}, {"sha": "1f5da7293e55311b39d80fb448aa7e3aa88dc9c9", "filename": "libgfortran/caf/single.c", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42a8246dbdb963921fe5426ba34646f6399a412d/libgfortran%2Fcaf%2Fsingle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42a8246dbdb963921fe5426ba34646f6399a412d/libgfortran%2Fcaf%2Fsingle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fcaf%2Fsingle.c?ref=42a8246dbdb963921fe5426ba34646f6399a412d", "patch": "@@ -28,6 +28,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <stdlib.h> /* For exit and malloc.  */\n #include <string.h> /* For memcpy and memset.  */\n #include <stdarg.h> /* For variadic arguments.  */\n+#include <assert.h>\n \n /* Define GFC_CAF_CHECK to enable run-time checking.  */\n /* #define GFC_CAF_CHECK  1  */\n@@ -774,3 +775,92 @@ _gfortran_caf_sendget (caf_token_t dst_token, size_t dst_offset,\n \t\t      src, dst_len, src_len);\n   GFC_DESCRIPTOR_DATA (src) = src_base;\n }\n+\n+\n+void\n+_gfortran_caf_atomic_define (caf_token_t token, size_t offset,\n+\t\t\t     int image_index __attribute__ ((unused)),\n+\t\t\t     void *value, int *stat,\n+\t\t\t     int type __attribute__ ((unused)), int kind)\n+{\n+  assert(kind == 4);\n+\n+  uint32_t *atom = (uint32_t *) ((char *) TOKEN (token) + offset);\n+\n+  __atomic_store (atom, (uint32_t *) value, __ATOMIC_RELAXED);\n+\n+  if (stat)\n+    *stat = 0;\n+}\n+\n+void\n+_gfortran_caf_atomic_ref (caf_token_t token, size_t offset,\n+\t\t\t  int image_index __attribute__ ((unused)),\n+\t\t\t  void *value, int *stat,\n+\t\t\t  int type __attribute__ ((unused)), int kind)\n+{\n+  assert(kind == 4);\n+\n+  uint32_t *atom = (uint32_t *) ((char *) TOKEN (token) + offset);\n+\n+  __atomic_load (atom, (uint32_t *) value, __ATOMIC_RELAXED);\n+\n+  if (stat)\n+    *stat = 0;\n+}\n+\n+\n+void\n+_gfortran_caf_atomic_cas (caf_token_t token, size_t offset,\n+\t\t\t  int image_index __attribute__ ((unused)),\n+\t\t\t  void *old, void *compare, void *new_val, int *stat,\n+\t\t\t  int type __attribute__ ((unused)), int kind)\n+{\n+  assert(kind == 4);\n+\n+  uint32_t *atom = (uint32_t *) ((char *) TOKEN (token) + offset);\n+\n+  *(uint32_t *) old = *(uint32_t *) compare;\n+  (void) __atomic_compare_exchange_n (atom, (uint32_t *) old,\n+\t\t\t\t      *(uint32_t *) new_val, false,\n+\t\t\t\t      __ATOMIC_RELAXED, __ATOMIC_RELAXED);\n+  if (stat)\n+    *stat = 0;\n+}\n+\n+\n+void\n+_gfortran_caf_atomic_op (int op, caf_token_t token, size_t offset,\n+\t\t\t int image_index __attribute__ ((unused)),\n+\t\t\t void *value, void *old, int *stat,\n+\t\t\t int type __attribute__ ((unused)), int kind)\n+{\n+  assert(kind == 4);\n+\n+  uint32_t res;\n+  uint32_t *atom = (uint32_t *) ((char *) TOKEN (token) + offset);\n+\n+  switch (op)\n+    {\n+    case GFC_CAF_ATOMIC_ADD:\n+      res = __atomic_fetch_add (atom, *(uint32_t *) value, __ATOMIC_RELAXED);\n+      break;\n+    case GFC_CAF_ATOMIC_AND:\n+      res = __atomic_fetch_and (atom, *(uint32_t *) value, __ATOMIC_RELAXED);\n+      break;\n+    case GFC_CAF_ATOMIC_OR:\n+      res = __atomic_fetch_or (atom, *(uint32_t *) value, __ATOMIC_RELAXED);\n+      break;\n+    case GFC_CAF_ATOMIC_XOR:\n+      res = __atomic_fetch_xor (atom, *(uint32_t *) value, __ATOMIC_RELAXED);\n+      break;\n+    default:\n+      __builtin_unreachable();\n+    }\n+\n+  if (old)\n+    *(uint32_t *) old = res;\n+\n+  if (stat)\n+    *stat = 0;\n+}"}]}