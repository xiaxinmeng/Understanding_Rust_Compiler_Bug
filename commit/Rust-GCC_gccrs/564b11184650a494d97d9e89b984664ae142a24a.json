{"sha": "564b11184650a494d97d9e89b984664ae142a24a", "node_id": "C_kwDOANBUbNoAKDU2NGIxMTE4NDY1MGE0OTRkOTdkOWU4OWI5ODQ2NjRhZTE0MmEyNGE", "commit": {"author": {"name": "David Faust", "email": "david.faust@oracle.com", "date": "2022-11-07T18:40:01Z"}, "committer": {"name": "David Faust", "email": "david.faust@oracle.com", "date": "2022-11-08T16:37:04Z"}, "message": "bpf: Use enum for resolved overloaded builtins\n\nChange several places in the eBPF backend dealing with overloaded\nbuilt-in functions to consistently use the enum bpf_builtins type,\nrather than variously using integer constants or booleans. The result is\neaiser to read and extend.\n\ngcc/\n\n\t* config/bpf/bpf.cc (struct core_walk_data): Add field `which'...\n\t(bpf_resolve_overloaded_builtin): ... set it here. Use values of enum\n\tbpf_builtins for error checks.\n\t(bpf_core_walk): Use values of enum bpf_builtins.\n\t(bpf_core_newdecl): Likewise.\n\t(bpf_expand_builtin): Likewise.", "tree": {"sha": "36f7d6345be042ad8840d70de6e0ea6c7f17efd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36f7d6345be042ad8840d70de6e0ea6c7f17efd7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/564b11184650a494d97d9e89b984664ae142a24a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/564b11184650a494d97d9e89b984664ae142a24a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/564b11184650a494d97d9e89b984664ae142a24a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/564b11184650a494d97d9e89b984664ae142a24a/comments", "author": {"login": "dafaust", "id": 4460334, "node_id": "MDQ6VXNlcjQ0NjAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4460334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dafaust", "html_url": "https://github.com/dafaust", "followers_url": "https://api.github.com/users/dafaust/followers", "following_url": "https://api.github.com/users/dafaust/following{/other_user}", "gists_url": "https://api.github.com/users/dafaust/gists{/gist_id}", "starred_url": "https://api.github.com/users/dafaust/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dafaust/subscriptions", "organizations_url": "https://api.github.com/users/dafaust/orgs", "repos_url": "https://api.github.com/users/dafaust/repos", "events_url": "https://api.github.com/users/dafaust/events{/privacy}", "received_events_url": "https://api.github.com/users/dafaust/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dafaust", "id": 4460334, "node_id": "MDQ6VXNlcjQ0NjAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4460334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dafaust", "html_url": "https://github.com/dafaust", "followers_url": "https://api.github.com/users/dafaust/followers", "following_url": "https://api.github.com/users/dafaust/following{/other_user}", "gists_url": "https://api.github.com/users/dafaust/gists{/gist_id}", "starred_url": "https://api.github.com/users/dafaust/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dafaust/subscriptions", "organizations_url": "https://api.github.com/users/dafaust/orgs", "repos_url": "https://api.github.com/users/dafaust/repos", "events_url": "https://api.github.com/users/dafaust/events{/privacy}", "received_events_url": "https://api.github.com/users/dafaust/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d96a286992a0fd9ecdd6a58cd9a413c8c49f477", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d96a286992a0fd9ecdd6a58cd9a413c8c49f477", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d96a286992a0fd9ecdd6a58cd9a413c8c49f477"}], "stats": {"total": 106, "additions": 59, "deletions": 47}, "files": [{"sha": "16af2412bf6b00314401460579b139ab62181420", "filename": "gcc/config/bpf/bpf.cc", "status": "modified", "additions": 59, "deletions": 47, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/564b11184650a494d97d9e89b984664ae142a24a/gcc%2Fconfig%2Fbpf%2Fbpf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/564b11184650a494d97d9e89b984664ae142a24a/gcc%2Fconfig%2Fbpf%2Fbpf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbpf%2Fbpf.cc?ref=564b11184650a494d97d9e89b984664ae142a24a", "patch": "@@ -1222,7 +1222,7 @@ bpf_expand_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n       return gen_rtx_REG (ops[0].mode, BPF_R0);\n     }\n \n-  else if (code == -1)\n+  else if (code == -BPF_BUILTIN_PRESERVE_ACCESS_INDEX)\n     {\n       /* A resolved overloaded __builtin_preserve_access_index.  */\n       tree arg = CALL_EXPR_ARG (exp, 0);\n@@ -1249,7 +1249,7 @@ bpf_expand_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n       return expand_normal (arg);\n     }\n \n-  else if (code == -2)\n+  else if (code == -BPF_BUILTIN_PRESERVE_FIELD_INFO)\n     {\n       /* A resolved overloaded __builtin_preserve_field_info.  */\n       tree src = CALL_EXPR_ARG (exp, 0);\n@@ -1444,28 +1444,37 @@ bpf_core_get_index (const tree node)\n    __builtin_preserve_access_index.  */\n \n static tree\n-bpf_core_newdecl (tree type, bool is_pai)\n+bpf_core_newdecl (tree type, enum bpf_builtins which)\n {\n   tree rettype;\n   char name[80];\n   static unsigned long pai_count = 0;\n   static unsigned long pfi_count = 0;\n \n-  if (is_pai)\n+  switch (which)\n     {\n-      rettype = build_function_type_list (type, type, NULL);\n-      int len = snprintf (name, sizeof (name), \"%s\", \"__builtin_pai_\");\n-      len = snprintf (name + len, sizeof (name) - len, \"%lu\", pai_count++);\n-    }\n-  else\n-    {\n-      rettype = build_function_type_list (unsigned_type_node, type,\n-\t\t\t\t\t  unsigned_type_node, NULL);\n-      int len = snprintf (name, sizeof (name), \"%s\", \"__builtin_pfi_\");\n-      len = snprintf (name + len, sizeof (name) - len, \"%lu\", pfi_count++);\n+    case BPF_BUILTIN_PRESERVE_ACCESS_INDEX:\n+      {\n+\trettype = build_function_type_list (type, type, NULL);\n+\tint len = snprintf (name, sizeof (name), \"%s\", \"__builtin_pai_\");\n+\tlen = snprintf (name + len, sizeof (name) - len, \"%lu\", pai_count++);\n+      }\n+      break;\n+\n+    case BPF_BUILTIN_PRESERVE_FIELD_INFO:\n+      {\n+\trettype = build_function_type_list (unsigned_type_node, type,\n+\t\t\t\t\t    unsigned_type_node, NULL);\n+\tint len = snprintf (name, sizeof (name), \"%s\", \"__builtin_pfi_\");\n+\tlen = snprintf (name + len, sizeof (name) - len, \"%lu\", pfi_count++);\n+      }\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n     }\n \n-  return add_builtin_function_ext_scope (name, rettype, is_pai ? -1 : -2,\n+  return add_builtin_function_ext_scope (name, rettype, -which,\n \t\t\t\t\t BUILT_IN_MD, NULL, NULL_TREE);\n }\n \n@@ -1492,6 +1501,7 @@ bpf_core_is_maybe_aggregate_access (tree expr)\n \n struct core_walk_data {\n   location_t loc;\n+  enum bpf_builtins which;\n   tree arg;\n };\n \n@@ -1501,7 +1511,6 @@ static tree\n bpf_core_walk (tree *tp, int *walk_subtrees, void *data)\n {\n   struct core_walk_data *dat = (struct core_walk_data *) data;\n-  bool is_pai = dat->arg == NULL_TREE;\n \n   /* If this is a type, don't do anything. */\n   if (TYPE_P (*tp))\n@@ -1510,19 +1519,21 @@ bpf_core_walk (tree *tp, int *walk_subtrees, void *data)\n       return NULL_TREE;\n     }\n \n-  /* Build a new function call to a resolved builtin for the desired operation.\n-     If this is a preserve_field_info call, pass along the argument to the\n-     resolved builtin call. */\n-  if (bpf_core_is_maybe_aggregate_access (*tp))\n-    {\n-      tree newdecl = bpf_core_newdecl (TREE_TYPE (*tp), is_pai);\n-      tree newcall;\n-      if (is_pai)\n-\tnewcall = build_call_expr_loc (dat->loc, newdecl, 1, *tp);\n-      else\n-\tnewcall = build_call_expr_loc (dat->loc, newdecl, 2, *tp, dat->arg);\n+  /* Build a new function call to a type-resolved temporary builtin for the\n+     desired operation, and pass along args as necessary.  */\n+  tree newdecl = bpf_core_newdecl (TREE_TYPE (*tp), dat->which);\n \n-      *tp = newcall;\n+  if (dat->which == BPF_BUILTIN_PRESERVE_ACCESS_INDEX)\n+    {\n+      if (bpf_core_is_maybe_aggregate_access (*tp))\n+\t{\n+\t  *tp = build_call_expr_loc (dat->loc, newdecl, 1, *tp);\n+\t  *walk_subtrees = 0;\n+\t}\n+    }\n+  else\n+    {\n+      *tp = build_call_expr_loc (dat->loc, newdecl, 2, *tp, dat->arg);\n       *walk_subtrees = 0;\n     }\n \n@@ -1572,45 +1583,42 @@ bpf_is_valid_preserve_field_info_arg (tree expr)\n \n /* Implement TARGET_RESOLVE_OVERLOADED_BUILTIN (see gccint manual section\n    Target Macros::Misc.).\n-   We use this for the __builtin_preserve_access_index builtin for CO-RE\n-   support.\n+   Used for CO-RE support builtins such as __builtin_preserve_access_index\n+   and __builtin_preserve_field_info.\n \n    FNDECL is the declaration of the builtin, and ARGLIST is the list of\n-   arguments passed to it, and is really a vec<tree,_> *.\n-\n-   In this case, the 'operation' implemented by the builtin is a no-op;\n-   the builtin is just a marker. So, the result is simply the argument.  */\n+   arguments passed to it, and is really a vec<tree,_> *.  */\n \n static tree\n bpf_resolve_overloaded_builtin (location_t loc, tree fndecl, void *arglist)\n {\n-  bool is_pai = DECL_MD_FUNCTION_CODE (fndecl)\n-    == BPF_BUILTIN_PRESERVE_ACCESS_INDEX;\n-  bool is_pfi = DECL_MD_FUNCTION_CODE (fndecl)\n-    == BPF_BUILTIN_PRESERVE_FIELD_INFO;\n+  enum bpf_builtins which = (enum bpf_builtins) DECL_MD_FUNCTION_CODE (fndecl);\n \n-  if (!is_pai && !is_pfi)\n+  if (which < BPF_BUILTIN_PRESERVE_ACCESS_INDEX\n+      || which >= BPF_BUILTIN_MAX)\n     return NULL_TREE;\n \n-  /* We only expect one argument, but it may be an arbitrarily-complicated\n-     statement-expression. */\n   vec<tree, va_gc> *params = static_cast<vec<tree, va_gc> *> (arglist);\n   unsigned n_params = params ? params->length() : 0;\n \n-  if ((is_pai && n_params != 1) || (is_pfi && n_params != 2))\n+  if (!(which == BPF_BUILTIN_PRESERVE_ACCESS_INDEX && n_params == 1)\n+      && n_params != 2)\n     {\n       error_at (loc, \"wrong number of arguments\");\n       return error_mark_node;\n     }\n \n   tree param = (*params)[0];\n \n-  /* If not generating BPF_CORE information, preserve_access_index does nothing,\n-     and simply \"resolves to\" the argument.  */\n-  if (!TARGET_BPF_CORE && is_pai)\n+  /* If not generating BPF_CORE information, preserve_access_index does\n+     nothing, and simply \"resolves to\" the argument.  */\n+  if (which == BPF_BUILTIN_PRESERVE_ACCESS_INDEX && !TARGET_BPF_CORE)\n     return param;\n \n-  if (is_pfi && !bpf_is_valid_preserve_field_info_arg (param))\n+  /* For __builtin_preserve_field_info, enforce that the parameter is exactly a\n+     field access and not a more complex expression.  */\n+  else if (which == BPF_BUILTIN_PRESERVE_FIELD_INFO\n+\t   && !bpf_is_valid_preserve_field_info_arg (param))\n     {\n       error_at (EXPR_LOC_OR_LOC (param, loc),\n \t\t\"argument is not a field access\");\n@@ -1642,7 +1650,11 @@ bpf_resolve_overloaded_builtin (location_t loc, tree fndecl, void *arglist)\n \n   struct core_walk_data data;\n   data.loc = loc;\n-  data.arg = is_pai ? NULL_TREE : (*params)[1];\n+  data.which = which;\n+  if (which == BPF_BUILTIN_PRESERVE_ACCESS_INDEX)\n+    data.arg = NULL_TREE;\n+  else\n+    data.arg = (*params)[1];\n \n   walk_tree (&param, bpf_core_walk, (void *) &data, NULL);\n "}]}