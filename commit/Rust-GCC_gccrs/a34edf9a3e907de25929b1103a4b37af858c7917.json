{"sha": "a34edf9a3e907de25929b1103a4b37af858c7917", "node_id": "C_kwDOANBUbNoAKGEzNGVkZjlhM2U5MDdkZTI1OTI5YjExMDNhNGIzN2FmODU4Yzc5MTc", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-14T23:10:06Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-14T23:10:06Z"}, "message": "Track nondeterminism and interposable calls in ipa-modref\n\nAdds tracking of two new flags in ipa-modref: nondeterministic and\ncalls_interposable.  First is set when function does something that is not\nguaranteed to be the same if run again (volatile memory access, volatile asm or\nexternal function call).  Second is set if function calls something that\ndoes not bind to current def.\n\nnondeterministic enables ipa-modref to discover looping pure/const functions\nand it now discovers 138 of them during cc1plus link (which about doubles\nnumber of such functions detected late).  We however can do more\n\n 1) We can extend FRE to eliminate redundant calls.\n    I filled a PR103168 for that.\n    A common case are inline functions that are not autodetected as ECF_CONST\n    just becuase they do not bind to local def and can be easily handled.\n    More tricky is to use modref summary to check what memory locations are\n    read.\n 2) DSE can eliminate redundant stores\n\nThe calls_interposable flag currently also improves tree-ssa-structalias\non functions that are not binds_to_current_def since reads_global_memory\nis now not cleared by interposable functions.\n\ngcc/ChangeLog:\n\n\t* ipa-modref.h (struct modref_summary): Add nondeterministic\n\tand calls_interposable flags.\n\t* ipa-modref.c (modref_summary::modref_summary): Initialize new flags.\n\t(modref_summary::useful_p): Check new flags.\n\t(struct modref_summary_lto): Add nondeterministic and\n\tcalls_interposable flags.\n\t(modref_summary_lto::modref_summary_lto): Initialize new flags.\n\t(modref_summary_lto::useful_p): Check new flags.\n\t(modref_summary::dump): Dump new flags.\n\t(modref_summary_lto::dump): Dump new flags.\n\t(ignore_nondeterminism_p): New function.\n\t(merge_call_side_effects): Merge new flags.\n\t(process_fnspec): Likewise.\n\t(analyze_load): Volatile access is nondeterministic.\n\t(analyze_store): Liekwise.\n\t(analyze_stmt): Volatile ASM is nondeterministic.\n\t(analyze_function): Clear new flags.\n\t(modref_summaries::duplicate): Duplicate new flags.\n\t(modref_summaries_lto::duplicate): Duplicate new flags.\n\t(modref_write): Stream new flags.\n\t(read_section): Stream new flags.\n\t(propagate_unknown_call): Update new flags.\n\t(modref_propagate_in_scc): Propagate new flags.\n\t* tree-ssa-alias.c (ref_maybe_used_by_call_p_1): Check\n\tcalls_interposable.\n\t* tree-ssa-structalias.c (determine_global_memory_access):\n\tLikewise.", "tree": {"sha": "09a613250d0d99564a39e7b334b878ecceda2525", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09a613250d0d99564a39e7b334b878ecceda2525"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a34edf9a3e907de25929b1103a4b37af858c7917", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a34edf9a3e907de25929b1103a4b37af858c7917", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a34edf9a3e907de25929b1103a4b37af858c7917", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a34edf9a3e907de25929b1103a4b37af858c7917/comments", "author": null, "committer": null, "parents": [{"sha": "3057f1ab737582a9fb37a3fb967ed8bf3659f2f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3057f1ab737582a9fb37a3fb967ed8bf3659f2f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3057f1ab737582a9fb37a3fb967ed8bf3659f2f4"}], "stats": {"total": 221, "additions": 187, "deletions": 34}, "files": [{"sha": "d9d48cc22915956d467766a79fc9df6e6f89da34", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 165, "deletions": 33, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a34edf9a3e907de25929b1103a4b37af858c7917/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a34edf9a3e907de25929b1103a4b37af858c7917/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=a34edf9a3e907de25929b1103a4b37af858c7917", "patch": "@@ -276,7 +276,8 @@ static GTY(()) fast_function_summary <modref_summary_lto *, va_gc>\n \n modref_summary::modref_summary ()\n   : loads (NULL), stores (NULL), retslot_flags (0), static_chain_flags (0),\n-    writes_errno (false), side_effects (false), global_memory_read (false),\n+    writes_errno (false), side_effects (false), nondeterministic (false),\n+    calls_interposable (false), global_memory_read (false),\n     global_memory_written (false), try_dse (false)\n {\n }\n@@ -332,13 +333,15 @@ modref_summary::useful_p (int ecf_flags, bool check_flags)\n       && remove_useless_eaf_flags (static_chain_flags, ecf_flags, false))\n     return true;\n   if (ecf_flags & (ECF_CONST | ECF_NOVOPS))\n-    return (!side_effects && (ecf_flags & ECF_LOOPING_CONST_OR_PURE));\n+    return ((!side_effects || !nondeterministic)\n+\t    && (ecf_flags & ECF_LOOPING_CONST_OR_PURE));\n   if (loads && !loads->every_base)\n     return true;\n   else\n     kills.release ();\n   if (ecf_flags & ECF_PURE)\n-    return (!side_effects && (ecf_flags & ECF_LOOPING_CONST_OR_PURE));\n+    return ((!side_effects || !nondeterministic)\n+\t    && (ecf_flags & ECF_LOOPING_CONST_OR_PURE));\n   return stores && !stores->every_base;\n }\n \n@@ -357,8 +360,10 @@ struct GTY(()) modref_summary_lto\n   auto_vec<eaf_flags_t> GTY((skip)) arg_flags;\n   eaf_flags_t retslot_flags;\n   eaf_flags_t static_chain_flags;\n-  bool writes_errno;\n-  bool side_effects;\n+  unsigned writes_errno : 1;\n+  unsigned side_effects : 1;\n+  unsigned nondeterministic : 1;\n+  unsigned calls_interposable : 1;\n \n   modref_summary_lto ();\n   ~modref_summary_lto ();\n@@ -370,7 +375,8 @@ struct GTY(()) modref_summary_lto\n \n modref_summary_lto::modref_summary_lto ()\n   : loads (NULL), stores (NULL), retslot_flags (0), static_chain_flags (0),\n-    writes_errno (false), side_effects (false)\n+    writes_errno (false), side_effects (false), nondeterministic (false),\n+    calls_interposable (false)\n {\n }\n \n@@ -400,11 +406,13 @@ modref_summary_lto::useful_p (int ecf_flags, bool check_flags)\n       && remove_useless_eaf_flags (static_chain_flags, ecf_flags, false))\n     return true;\n   if (ecf_flags & (ECF_CONST | ECF_NOVOPS))\n-    return (!side_effects && (ecf_flags & ECF_LOOPING_CONST_OR_PURE));\n+    return ((!side_effects || !nondeterministic)\n+\t    && (ecf_flags & ECF_LOOPING_CONST_OR_PURE));\n   if (loads && !loads->every_base)\n     return true;\n   if (ecf_flags & ECF_PURE)\n-    return (!side_effects && (ecf_flags & ECF_LOOPING_CONST_OR_PURE));\n+    return ((!side_effects || !nondeterministic)\n+\t    && (ecf_flags & ECF_LOOPING_CONST_OR_PURE));\n   return stores && !stores->every_base;\n }\n \n@@ -586,6 +594,10 @@ modref_summary::dump (FILE *out)\n     fprintf (out, \"  Writes errno\\n\");\n   if (side_effects)\n     fprintf (out, \"  Side effects\\n\");\n+  if (nondeterministic)\n+    fprintf (out, \"  Nondeterministic\\n\");\n+  if (calls_interposable)\n+    fprintf (out, \"  Calls interposable\\n\");\n   if (global_memory_read)\n     fprintf (out, \"  Global memory read\\n\");\n   if (global_memory_written)\n@@ -626,6 +638,10 @@ modref_summary_lto::dump (FILE *out)\n     fprintf (out, \"  Writes errno\\n\");\n   if (side_effects)\n     fprintf (out, \"  Side effects\\n\");\n+  if (nondeterministic)\n+    fprintf (out, \"  Nondeterministic\\n\");\n+  if (calls_interposable)\n+    fprintf (out, \"  Calls interposable\\n\");\n   if (arg_flags.length ())\n     {\n       for (unsigned int i = 0; i < arg_flags.length (); i++)\n@@ -869,6 +885,20 @@ record_access_p (tree expr)\n   return true;\n }\n \n+/* Return true if ECF flags says that nondeterminsm can be ignored.  */\n+\n+static bool\n+ignore_nondeterminism_p (tree caller, int flags)\n+{\n+  if ((flags & (ECF_CONST | ECF_PURE))\n+      && !(flags & ECF_LOOPING_CONST_OR_PURE))\n+    return true;\n+  if ((flags & (ECF_NORETURN | ECF_NOTHROW)) == (ECF_NORETURN | ECF_NOTHROW)\n+      || (!opt_for_fn (caller, flag_exceptions) && (flags & ECF_NORETURN)))\n+    return true;\n+  return false;\n+}\n+\n /* Return true if ECF flags says that return value can be ignored.  */\n \n static bool\n@@ -953,17 +983,37 @@ merge_call_side_effects (modref_summary *cur_summary,\n       && !(flags & ECF_LOOPING_CONST_OR_PURE))\n     return changed;\n \n-  if (!cur_summary->side_effects && callee_summary->side_effects)\n+  if (!(flags & (ECF_CONST | ECF_NOVOPS | ECF_PURE))\n+      || (flags & ECF_LOOPING_CONST_OR_PURE))\n     {\n-      if (dump_file)\n-\tfprintf (dump_file, \" - merging side effects.\\n\");\n-      cur_summary->side_effects = true;\n-      changed = true;\n-    }\n+      if (!cur_summary->side_effects && callee_summary->side_effects)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \" - merging side effects.\\n\");\n+\t  cur_summary->side_effects = true;\n+\t  changed = true;\n+\t}\n+      if (!cur_summary->nondeterministic && callee_summary->nondeterministic\n+\t  && !ignore_nondeterminism_p (current_function_decl, flags))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \" - merging nondeterministic.\\n\");\n+\t  cur_summary->nondeterministic = true;\n+\t  changed = true;\n+\t}\n+     }\n \n   if (flags & (ECF_CONST | ECF_NOVOPS))\n     return changed;\n \n+  if (!cur_summary->calls_interposable && callee_summary->calls_interposable)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \" - merging calls interposable.\\n\");\n+      cur_summary->calls_interposable = true;\n+      changed = true;\n+    }\n+\n   if (always_executed\n       && callee_summary->kills.length ()\n       && (!cfun->can_throw_non_call_exceptions\n@@ -1000,11 +1050,13 @@ merge_call_side_effects (modref_summary *cur_summary,\n      not always bind to current def: it is possible that memory load\n      was optimized out earlier which may not happen in the interposed\n      variant.  */\n-  if (!callee_node->binds_to_current_def_p ())\n+  if (!callee_node->binds_to_current_def_p ()\n+      && !cur_summary->calls_interposable)\n     {\n       if (dump_file)\n-\tfprintf (dump_file, \" - May be interposed: collapsing loads.\\n\");\n-      cur_summary->loads->collapse ();\n+\tfprintf (dump_file, \" - May be interposed.\\n\");\n+      cur_summary->calls_interposable = true;\n+      changed = true;\n     }\n \n   if (dump_file)\n@@ -1161,9 +1213,17 @@ process_fnspec (modref_summary *cur_summary,\n \t  && stmt_could_throw_p (cfun, call)))\n     {\n       if (cur_summary)\n-\tcur_summary->side_effects = true;\n+\t{\n+\t  cur_summary->side_effects = true;\n+\t  if (!ignore_nondeterminism_p (current_function_decl, flags))\n+\t    cur_summary->nondeterministic = true;\n+\t}\n       if (cur_summary_lto)\n-\tcur_summary_lto->side_effects = true;\n+\t{\n+\t  cur_summary_lto->side_effects = true;\n+\t  if (!ignore_nondeterminism_p (current_function_decl, flags))\n+\t    cur_summary_lto->nondeterministic = true;\n+\t}\n     }\n   if (flags & (ECF_CONST | ECF_NOVOPS))\n     return true;\n@@ -1388,9 +1448,9 @@ analyze_load (gimple *, tree, tree op, void *data)\n       if (dump_file)\n \tfprintf (dump_file, \" (volatile or can throw; marking side effects) \");\n       if (summary)\n-\tsummary->side_effects = true;\n+\tsummary->side_effects = summary->nondeterministic = true;\n       if (summary_lto)\n-\tsummary_lto->side_effects = true;\n+\tsummary_lto->side_effects = summary_lto->nondeterministic = true;\n     }\n \n   if (!record_access_p (op))\n@@ -1429,9 +1489,9 @@ analyze_store (gimple *stmt, tree, tree op, void *data)\n       if (dump_file)\n \tfprintf (dump_file, \" (volatile or can throw; marking side effects) \");\n       if (summary)\n-\tsummary->side_effects = true;\n+\tsummary->side_effects = summary->nondeterministic = true;\n       if (summary_lto)\n-\tsummary_lto->side_effects = true;\n+\tsummary_lto->side_effects = summary_lto->nondeterministic = true;\n     }\n \n   if (!record_access_p (op))\n@@ -1497,9 +1557,15 @@ analyze_stmt (modref_summary *summary, modref_summary_lto *summary_lto,\n   switch (gimple_code (stmt))\n    {\n    case GIMPLE_ASM:\n-      if (gimple_asm_volatile_p (as_a <gasm *> (stmt))\n-\t  || (cfun->can_throw_non_call_exceptions\n-\t      && stmt_could_throw_p (cfun, stmt)))\n+      if (gimple_asm_volatile_p (as_a <gasm *> (stmt)))\n+\t{\n+\t  if (summary)\n+\t    summary->side_effects = summary->nondeterministic = true;\n+\t  if (summary_lto)\n+\t    summary_lto->side_effects = summary_lto->nondeterministic = true;\n+\t}\n+      if (cfun->can_throw_non_call_exceptions\n+\t  && stmt_could_throw_p (cfun, stmt))\n \t{\n \t  if (summary)\n \t    summary->side_effects = true;\n@@ -2826,6 +2892,8 @@ analyze_function (function *f, bool ipa)\n \t\t\t\t\t\t    param_modref_max_accesses);\n       summary->writes_errno = false;\n       summary->side_effects = false;\n+      summary->nondeterministic = false;\n+      summary->calls_interposable = false;\n     }\n   if (lto)\n     {\n@@ -2841,6 +2909,8 @@ analyze_function (function *f, bool ipa)\n \t\t\t\t  param_modref_max_accesses);\n       summary_lto->writes_errno = false;\n       summary_lto->side_effects = false;\n+      summary_lto->nondeterministic = false;\n+      summary_lto->calls_interposable = false;\n     }\n \n   analyze_parms (summary, summary_lto, ipa,\n@@ -2913,9 +2983,10 @@ analyze_function (function *f, bool ipa)\n   if (!ipa && flag_ipa_pure_const)\n     {\n       if (!summary->stores->every_base && !summary->stores->bases\n-\t  && !summary->side_effects)\n+\t  && !summary->nondeterministic)\n \t{\n-\t  if (!summary->loads->every_base && !summary->loads->bases)\n+\t  if (!summary->loads->every_base && !summary->loads->bases\n+\t      && !summary->calls_interposable)\n \t    fixup_cfg = ipa_make_function_const\n \t\t   (cgraph_node::get (current_function_decl),\n \t\t    summary->side_effects, true);\n@@ -3149,6 +3220,8 @@ modref_summaries::duplicate (cgraph_node *, cgraph_node *dst,\n   dst_data->kills.splice (src_data->kills);\n   dst_data->writes_errno = src_data->writes_errno;\n   dst_data->side_effects = src_data->side_effects;\n+  dst_data->nondeterministic = src_data->nondeterministic;\n+  dst_data->calls_interposable = src_data->calls_interposable;\n   if (src_data->arg_flags.length ())\n     dst_data->arg_flags = src_data->arg_flags.copy ();\n   dst_data->retslot_flags = src_data->retslot_flags;\n@@ -3177,6 +3250,8 @@ modref_summaries_lto::duplicate (cgraph_node *, cgraph_node *,\n   dst_data->loads->copy_from (src_data->loads);\n   dst_data->writes_errno = src_data->writes_errno;\n   dst_data->side_effects = src_data->side_effects;\n+  dst_data->nondeterministic = src_data->nondeterministic;\n+  dst_data->calls_interposable = src_data->calls_interposable;\n   if (src_data->arg_flags.length ())\n     dst_data->arg_flags = src_data->arg_flags.copy ();\n   dst_data->retslot_flags = src_data->retslot_flags;\n@@ -3506,6 +3581,8 @@ modref_write ()\n \t  struct bitpack_d bp = bitpack_create (ob->main_stream);\n \t  bp_pack_value (&bp, r->writes_errno, 1);\n \t  bp_pack_value (&bp, r->side_effects, 1);\n+\t  bp_pack_value (&bp, r->nondeterministic, 1);\n+\t  bp_pack_value (&bp, r->calls_interposable, 1);\n \t  if (!flag_wpa)\n \t    {\n \t      for (cgraph_edge *e = cnode->indirect_calls;\n@@ -3578,11 +3655,15 @@ read_section (struct lto_file_decl_data *file_data, const char *data,\n \t{\n \t  modref_sum->writes_errno = false;\n \t  modref_sum->side_effects = false;\n+\t  modref_sum->nondeterministic = false;\n+\t  modref_sum->calls_interposable = false;\n \t}\n       if (modref_sum_lto)\n \t{\n \t  modref_sum_lto->writes_errno = false;\n \t  modref_sum_lto->side_effects = false;\n+\t  modref_sum_lto->nondeterministic = false;\n+\t  modref_sum_lto->calls_interposable = false;\n \t}\n \n       gcc_assert (!modref_sum || (!modref_sum->loads\n@@ -3635,6 +3716,20 @@ read_section (struct lto_file_decl_data *file_data, const char *data,\n \t  if (modref_sum_lto)\n \t    modref_sum_lto->side_effects = true;\n \t}\n+      if (bp_unpack_value (&bp, 1))\n+\t{\n+\t  if (modref_sum)\n+\t    modref_sum->nondeterministic = true;\n+\t  if (modref_sum_lto)\n+\t    modref_sum_lto->nondeterministic = true;\n+\t}\n+      if (bp_unpack_value (&bp, 1))\n+\t{\n+\t  if (modref_sum)\n+\t    modref_sum->calls_interposable = true;\n+\t  if (modref_sum_lto)\n+\t    modref_sum_lto->calls_interposable = true;\n+\t}\n       if (!flag_ltrans)\n \t{\n \t  for (cgraph_edge *e = node->indirect_calls; e; e = e->next_callee)\n@@ -4162,6 +4257,18 @@ propagate_unknown_call (cgraph_node *node,\n \t  cur_summary_lto->side_effects = true;\n \t  changed = true;\n \t}\n+      if (cur_summary && !cur_summary->nondeterministic\n+\t  && !ignore_nondeterminism_p (node->decl, ecf_flags))\n+\t{\n+\t  cur_summary->nondeterministic = true;\n+\t  changed = true;\n+\t}\n+      if (cur_summary_lto && !cur_summary_lto->nondeterministic\n+\t  && !ignore_nondeterminism_p (node->decl, ecf_flags))\n+\t{\n+\t  cur_summary_lto->nondeterministic = true;\n+\t  changed = true;\n+\t}\n     }\n   if (ecf_flags & (ECF_CONST | ECF_NOVOPS))\n     return changed;\n@@ -4421,6 +4528,20 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t\t  cur_summary_lto->side_effects = true;\n \t\t  changed = true;\n \t\t}\n+\t      if (callee_summary && !cur_summary->nondeterministic\n+\t\t  && callee_summary->nondeterministic\n+\t\t  && !ignore_nondeterminism_p (cur->decl, flags))\n+\t\t{\n+\t\t  cur_summary->nondeterministic = true;\n+\t\t  changed = true;\n+\t\t}\n+\t      if (callee_summary_lto && !cur_summary_lto->nondeterministic\n+\t\t  && callee_summary_lto->nondeterministic\n+\t\t  && !ignore_nondeterminism_p (cur->decl, flags))\n+\t\t{\n+\t\t  cur_summary_lto->nondeterministic = true;\n+\t\t  changed = true;\n+\t\t}\n \t      if (flags & (ECF_CONST | ECF_NOVOPS))\n \t\tcontinue;\n \n@@ -4430,7 +4551,16 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t\t the interposed variant.  */\n \t      if (!callee_edge->binds_to_current_def_p ())\n \t\t{\n-\t\t  changed |= collapse_loads (cur_summary, cur_summary_lto);\n+\t\t  if (cur_summary && !cur_summary->calls_interposable)\n+\t\t    {\n+\t\t      cur_summary->calls_interposable = true;\n+\t\t      changed = true;\n+\t\t    }\n+\t\t  if (cur_summary_lto && !cur_summary_lto->calls_interposable)\n+\t\t    {\n+\t\t      cur_summary_lto->calls_interposable = true;\n+\t\t      changed = true;\n+\t\t    }\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file, \"      May not bind local;\"\n \t\t\t     \" collapsing loads\\n\");\n@@ -4516,19 +4646,21 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t\t\t\t\t  ? summaries_lto->get (cur)\n \t\t\t\t\t  : NULL;\n \tif (summary && !summary->stores->every_base && !summary->stores->bases\n-\t    && !summary->side_effects)\n+\t    && !summary->nondeterministic)\n \t  {\n-\t    if (!summary->loads->every_base && !summary->loads->bases)\n+\t    if (!summary->loads->every_base && !summary->loads->bases\n+\t\t&& !summary->calls_interposable)\n \t      pureconst |= ipa_make_function_const\n \t\t     (cur, summary->side_effects, false);\n \t    else\n \t      pureconst |= ipa_make_function_pure\n \t\t     (cur, summary->side_effects, false);\n \t  }\n \tif (summary_lto && !summary_lto->stores->every_base\n-\t    && !summary_lto->stores->bases && !summary_lto->side_effects)\n+\t    && !summary_lto->stores->bases && !summary_lto->nondeterministic)\n \t  {\n-\t    if (!summary_lto->loads->every_base && !summary_lto->loads->bases)\n+\t    if (!summary_lto->loads->every_base && !summary_lto->loads->bases\n+\t\t&& !summary_lto->calls_interposable)\n \t      pureconst |= ipa_make_function_const\n \t\t     (cur, summary_lto->side_effects, false);\n \t    else"}, {"sha": "4eb696d086aa5259c23ec6ccbb4aafdeef4e8f3a", "filename": "gcc/ipa-modref.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a34edf9a3e907de25929b1103a4b37af858c7917/gcc%2Fipa-modref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a34edf9a3e907de25929b1103a4b37af858c7917/gcc%2Fipa-modref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.h?ref=a34edf9a3e907de25929b1103a4b37af858c7917", "patch": "@@ -32,11 +32,31 @@ struct GTY(()) modref_summary\n   modref_records *stores;\n   auto_vec<modref_access_node> GTY((skip)) kills;\n   auto_vec<eaf_flags_t> GTY((skip)) arg_flags;\n+\n   eaf_flags_t retslot_flags;\n   eaf_flags_t static_chain_flags;\n+\n   unsigned writes_errno : 1;\n+  /* Side effects does not include memory loads and stores which are\n+     expressed using loads, stores and calls_interposable fields.  */\n   unsigned side_effects : 1;\n+  /* If true function can not be CSE optimized because it may behave\n+     differently even if invoked with same inputs.  */\n+  unsigned nondeterministic : 1;\n+  /* IF true the function may read any reachable memory but not use\n+     it for anything useful.  This may happen i.e. when interposing\n+     function with optimized out conditional with unoptimized one.\n+\n+     In this situation the loads summary is not useful for DSE but\n+     it is still useful for CSE.  */\n+  unsigned calls_interposable : 1;\n+\n   /* Flags coputed by finalize method.  */\n+\n+  /* global_memory_read is not set for functions calling functions\n+     with !binds_to_current_def which, after interposition, may read global\n+     memory but do nothing useful with it (except for crashing if some\n+     stores are optimized out.  */\n   unsigned global_memory_read : 1;\n   unsigned global_memory_written : 1;\n   unsigned try_dse : 1;"}, {"sha": "02bbc87b5973b3afc21bcac9d96c96159d3234e7", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a34edf9a3e907de25929b1103a4b37af858c7917/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a34edf9a3e907de25929b1103a4b37af858c7917/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=a34edf9a3e907de25929b1103a4b37af858c7917", "patch": "@@ -2765,7 +2765,7 @@ ref_maybe_used_by_call_p_1 (gcall *call, ao_ref *ref, bool tbaa_p)\n       if (node && node->binds_to_current_def_p ())\n \t{\n \t  modref_summary *summary = get_modref_function_summary (node);\n-\t  if (summary)\n+\t  if (summary && !summary->calls_interposable)\n \t    {\n \t      if (!modref_may_conflict (call, summary->loads, ref, tbaa_p))\n \t\t{"}, {"sha": "06eb22c029ae4c3c9b994a91287be0f47fe8b78f", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a34edf9a3e907de25929b1103a4b37af858c7917/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a34edf9a3e907de25929b1103a4b37af858c7917/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=a34edf9a3e907de25929b1103a4b37af858c7917", "patch": "@@ -4266,6 +4266,7 @@ determine_global_memory_access (gcall *stmt,\n       if (reads_global_memory && *reads_global_memory)\n \t*reads_global_memory = summary->global_memory_read;\n       if (reads_global_memory && uses_global_memory\n+\t  && !summary->calls_interposable\n \t  && !*reads_global_memory && node->binds_to_current_def_p ())\n \t*uses_global_memory = false;\n     }"}]}