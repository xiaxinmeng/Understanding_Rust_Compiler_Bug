{"sha": "c628d1c325e81467fac06a92c8dfb7768e0cf7ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzYyOGQxYzMyNWU4MTQ2N2ZhYzA2YTkyYzhkZmI3NzY4ZTBjZjdhZA==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2019-01-20T20:17:02Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2019-01-20T20:17:02Z"}, "message": "Limit AA walking in IPA summary generation\n\n2019-01-20  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/87615\n\t* ipa-prop.h (struct ipa_func_body_info): Replaced field aa_walked\n\twith aa_walk_budget.\n\t* cgraph.h (ipa_polymorphic_call_context::get_dynamic_type): Add\n\taa_walk_budget_p parameter.\n\t* ipa-fnsummary.c (unmodified_parm_1): New parameter fbi.  Limit AA\n\twalk.  Updated all callers.\n\t(unmodified_parm): New parameter fbi, pass it to unmodified_parm_1.\n\t(eliminated_by_inlining_prob): New parameter fbi, pass it on to\n\tunmodified_parm.\n\t(will_be_nonconstant_expr_predicate): New parameter fbi, removed\n\tparameter info.  Extract info from fbi.  Pass fbi to recursive calls\n\tand to unmodified_parm.\n\t(phi_result_unknown_predicate): New parameter fbi, removed parameter\n\tinfo, updated call to will_be_nonconstant_expr_predicate.\n\t(param_change_prob): New parameter fbi, limit AA walking.\n\t(analyze_function_body): Initialize aa_walk_budget in fbi.  Update\n\tcalls to various above functions.\n\t* ipa-polymorphic-call.c (get_dynamic_type): Add aa_walk_budget_p\n\tparameter.  Use it to limit AA walking.\n\t* ipa-prop.c (detect_type_change_from_memory_writes): New parameter\n\tfbi, limit AA walk.\n\t(detect_type_change): New parameter fbi, pass it on to\n\tdetect_type_change_from_memory_writes.\n\t(detect_type_change_ssa): Likewise.\n\t(aa_overwalked): Removed.\n\t(parm_preserved_before_stmt_p): Assume fbi is never NULL, stream line\n\taccordingly, adjust to the neew AA limiting scheme.\n\t(parm_ref_data_preserved_p): Likewise.\n\t(ipa_compute_jump_functions_for_edge): Adjust call to\n\tget_dynamic_type.\n\t(ipa_analyze_call_uses): Likewise.\n\t(ipa_analyze_virtual_call_uses): Pass fbi to detect_type_change_ssa.\n\t(ipa_analyze_node): Initialize aa_walk_budget.\n\t(ipcp_transform_function): Likewise.\n\t* tree-ssa-sccvn.c (eliminate_dom_walker::eliminate_stmt): Update call\n\tto get_dynamic_type.\n\nFrom-SVN: r268107", "tree": {"sha": "c6bd7c0f2480cdcaf35aa161824faa675368d629", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6bd7c0f2480cdcaf35aa161824faa675368d629"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c628d1c325e81467fac06a92c8dfb7768e0cf7ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c628d1c325e81467fac06a92c8dfb7768e0cf7ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c628d1c325e81467fac06a92c8dfb7768e0cf7ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c628d1c325e81467fac06a92c8dfb7768e0cf7ad/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "49686677ed7aa84d05b0c5db8eb28f06ebb5e529", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49686677ed7aa84d05b0c5db8eb28f06ebb5e529", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49686677ed7aa84d05b0c5db8eb28f06ebb5e529"}], "stats": {"total": 316, "additions": 194, "deletions": 122}, "files": [{"sha": "6ce35e078b8ae0e9e5a52f9f9f1b29e600e301c9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c628d1c325e81467fac06a92c8dfb7768e0cf7ad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c628d1c325e81467fac06a92c8dfb7768e0cf7ad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c628d1c325e81467fac06a92c8dfb7768e0cf7ad", "patch": "@@ -1,3 +1,43 @@\n+2019-01-20  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR ipa/87615\n+\t* ipa-prop.h (struct ipa_func_body_info): Replaced field aa_walked\n+\twith aa_walk_budget.\n+\t* cgraph.h (ipa_polymorphic_call_context::get_dynamic_type): Add\n+\taa_walk_budget_p parameter.\n+\t* ipa-fnsummary.c (unmodified_parm_1): New parameter fbi.  Limit AA\n+\twalk.  Updated all callers.\n+\t(unmodified_parm): New parameter fbi, pass it to unmodified_parm_1.\n+\t(eliminated_by_inlining_prob): New parameter fbi, pass it on to\n+\tunmodified_parm.\n+\t(will_be_nonconstant_expr_predicate): New parameter fbi, removed\n+\tparameter info.  Extract info from fbi.  Pass fbi to recursive calls\n+\tand to unmodified_parm.\n+\t(phi_result_unknown_predicate): New parameter fbi, removed parameter\n+\tinfo, updated call to will_be_nonconstant_expr_predicate.\n+\t(param_change_prob): New parameter fbi, limit AA walking.\n+\t(analyze_function_body): Initialize aa_walk_budget in fbi.  Update\n+\tcalls to various above functions.\n+\t* ipa-polymorphic-call.c (get_dynamic_type): Add aa_walk_budget_p\n+\tparameter.  Use it to limit AA walking.\n+\t* ipa-prop.c (detect_type_change_from_memory_writes): New parameter\n+\tfbi, limit AA walk.\n+\t(detect_type_change): New parameter fbi, pass it on to\n+\tdetect_type_change_from_memory_writes.\n+\t(detect_type_change_ssa): Likewise.\n+\t(aa_overwalked): Removed.\n+\t(parm_preserved_before_stmt_p): Assume fbi is never NULL, stream line\n+\taccordingly, adjust to the neew AA limiting scheme.\n+\t(parm_ref_data_preserved_p): Likewise.\n+\t(ipa_compute_jump_functions_for_edge): Adjust call to\n+\tget_dynamic_type.\n+\t(ipa_analyze_call_uses): Likewise.\n+\t(ipa_analyze_virtual_call_uses): Pass fbi to detect_type_change_ssa.\n+\t(ipa_analyze_node): Initialize aa_walk_budget.\n+\t(ipcp_transform_function): Likewise.\n+\t* tree-ssa-sccvn.c (eliminate_dom_walker::eliminate_stmt): Update call\n+\tto get_dynamic_type.\n+\n 2019-01-19  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/aarch64/aarch64.c (aarch64_stack_protect_guard): Move"}, {"sha": "75d4cec0ba8cdca2ff5804d3bde9f3764ca5ecd4", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c628d1c325e81467fac06a92c8dfb7768e0cf7ad/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c628d1c325e81467fac06a92c8dfb7768e0cf7ad/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=c628d1c325e81467fac06a92c8dfb7768e0cf7ad", "patch": "@@ -1557,7 +1557,7 @@ class GTY(()) ipa_polymorphic_call_context {\n \n   /* Look for vtable stores or constructor calls to work out dynamic type\n      of memory location.  */\n-  bool get_dynamic_type (tree, tree, tree, gimple *);\n+  bool get_dynamic_type (tree, tree, tree, gimple *, unsigned *);\n \n   /* Make context non-speculative.  */\n   void clear_speculation ();"}, {"sha": "535b3f22d495ebbca718f7945929c52c5b02fa12", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 65, "deletions": 46, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c628d1c325e81467fac06a92c8dfb7768e0cf7ad/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c628d1c325e81467fac06a92c8dfb7768e0cf7ad/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=c628d1c325e81467fac06a92c8dfb7768e0cf7ad", "patch": "@@ -941,7 +941,8 @@ mark_modified (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef ATTRIBUTE_UNUSED,\n    PARM_DECL) will be stored to *SIZE_P in that case too.  */\n \n static tree\n-unmodified_parm_1 (gimple *stmt, tree op, HOST_WIDE_INT *size_p)\n+unmodified_parm_1 (ipa_func_body_info *fbi, gimple *stmt, tree op,\n+\t\t   HOST_WIDE_INT *size_p)\n {\n   /* SSA_NAME referring to parm default def?  */\n   if (TREE_CODE (op) == SSA_NAME\n@@ -959,8 +960,14 @@ unmodified_parm_1 (gimple *stmt, tree op, HOST_WIDE_INT *size_p)\n \n       ao_ref refd;\n       ao_ref_init (&refd, op);\n-      walk_aliased_vdefs (&refd, gimple_vuse (stmt), mark_modified, &modified,\n-\t\t\t  NULL);\n+      int walked = walk_aliased_vdefs (&refd, gimple_vuse (stmt),\n+\t\t\t\t       mark_modified, &modified, NULL, NULL,\n+\t\t\t\t       fbi->aa_walk_budget + 1);\n+      if (walked < 0)\n+\t{\n+\t  fbi->aa_walk_budget = 0;\n+\t  return NULL_TREE;\n+\t}\n       if (!modified)\n \t{\n \t  if (size_p)\n@@ -977,16 +984,17 @@ unmodified_parm_1 (gimple *stmt, tree op, HOST_WIDE_INT *size_p)\n    stored to *SIZE_P in that case too.  */\n \n static tree\n-unmodified_parm (gimple *stmt, tree op, HOST_WIDE_INT *size_p)\n+unmodified_parm (ipa_func_body_info *fbi, gimple *stmt, tree op,\n+\t\t HOST_WIDE_INT *size_p)\n {\n-  tree res = unmodified_parm_1 (stmt, op, size_p);\n+  tree res = unmodified_parm_1 (fbi, stmt, op, size_p);\n   if (res)\n     return res;\n \n   if (TREE_CODE (op) == SSA_NAME\n       && !SSA_NAME_IS_DEFAULT_DEF (op)\n       && gimple_assign_single_p (SSA_NAME_DEF_STMT (op)))\n-    return unmodified_parm (SSA_NAME_DEF_STMT (op),\n+    return unmodified_parm (fbi, SSA_NAME_DEF_STMT (op),\n \t\t\t    gimple_assign_rhs1 (SSA_NAME_DEF_STMT (op)),\n \t\t\t    size_p);\n   return NULL_TREE;\n@@ -1005,7 +1013,7 @@ unmodified_parm_or_parm_agg_item (struct ipa_func_body_info *fbi,\n \t\t\t\t  HOST_WIDE_INT *size_p,\n \t\t\t\t  struct agg_position_info *aggpos)\n {\n-  tree res = unmodified_parm_1 (stmt, op, size_p);\n+  tree res = unmodified_parm_1 (fbi, stmt, op, size_p);\n \n   gcc_checking_assert (aggpos);\n   if (res)\n@@ -1044,7 +1052,7 @@ unmodified_parm_or_parm_agg_item (struct ipa_func_body_info *fbi,\n    penalty wrappers.  */\n \n static int\n-eliminated_by_inlining_prob (gimple *stmt)\n+eliminated_by_inlining_prob (ipa_func_body_info *fbi, gimple *stmt)\n {\n   enum gimple_code code = gimple_code (stmt);\n   enum tree_code rhs_code;\n@@ -1084,7 +1092,7 @@ eliminated_by_inlining_prob (gimple *stmt)\n \t    inner_lhs = lhs;\n \n \t  /* Reads of parameter are expected to be free.  */\n-\t  if (unmodified_parm (stmt, inner_rhs, NULL))\n+\t  if (unmodified_parm (fbi, stmt, inner_rhs, NULL))\n \t    rhs_free = true;\n \t  /* Match expressions of form &this->field. Those will most likely\n \t     combine with something upstream after inlining.  */\n@@ -1094,7 +1102,8 @@ eliminated_by_inlining_prob (gimple *stmt)\n \t      if (TREE_CODE (op) == PARM_DECL)\n \t\trhs_free = true;\n \t      else if (TREE_CODE (op) == MEM_REF\n-\t\t       && unmodified_parm (stmt, TREE_OPERAND (op, 0), NULL))\n+\t\t       && unmodified_parm (fbi, stmt, TREE_OPERAND (op, 0),\n+\t\t\t\t\t   NULL))\n \t\trhs_free = true;\n \t    }\n \n@@ -1107,7 +1116,7 @@ eliminated_by_inlining_prob (gimple *stmt)\n \t  /* Reads of parameters passed by reference\n \t     expected to be free (i.e. optimized out after inlining).  */\n \t  if (TREE_CODE (inner_rhs) == MEM_REF\n-\t      && unmodified_parm (stmt, TREE_OPERAND (inner_rhs, 0), NULL))\n+\t      && unmodified_parm (fbi, stmt, TREE_OPERAND (inner_rhs, 0), NULL))\n \t    rhs_free = true;\n \n \t  /* Copying parameter passed by reference into gimple register is\n@@ -1148,7 +1157,8 @@ eliminated_by_inlining_prob (gimple *stmt)\n \t  if (TREE_CODE (inner_lhs) == PARM_DECL\n \t      || TREE_CODE (inner_lhs) == RESULT_DECL\n \t      || (TREE_CODE (inner_lhs) == MEM_REF\n-\t\t  && (unmodified_parm (stmt, TREE_OPERAND (inner_lhs, 0), NULL)\n+\t\t  && (unmodified_parm (fbi, stmt, TREE_OPERAND (inner_lhs, 0),\n+\t\t\t\t       NULL)\n \t\t      || (TREE_CODE (TREE_OPERAND (inner_lhs, 0)) == SSA_NAME\n \t\t\t  && SSA_NAME_VAR (TREE_OPERAND (inner_lhs, 0))\n \t\t\t  && TREE_CODE (SSA_NAME_VAR (TREE_OPERAND\n@@ -1396,7 +1406,7 @@ compute_bb_predicates (struct ipa_func_body_info *fbi,\n    a compile time constant.  */\n \n static predicate\n-will_be_nonconstant_expr_predicate (struct ipa_node_params *info,\n+will_be_nonconstant_expr_predicate (ipa_func_body_info *fbi,\n \t\t\t\t    struct ipa_fn_summary *summary,\n \t\t\t\t    tree expr,\n \t\t\t\t    vec<predicate> nonconstant_names)\n@@ -1408,8 +1418,8 @@ will_be_nonconstant_expr_predicate (struct ipa_node_params *info,\n   while (UNARY_CLASS_P (expr))\n     expr = TREE_OPERAND (expr, 0);\n \n-  parm = unmodified_parm (NULL, expr, &size);\n-  if (parm && (index = ipa_get_param_decl_index (info, parm)) >= 0)\n+  parm = unmodified_parm (fbi, NULL, expr, &size);\n+  if (parm && (index = ipa_get_param_decl_index (fbi->info, parm)) >= 0)\n     return add_condition (summary, index, size, NULL, predicate::changed,\n \t\t\t  NULL_TREE);\n   if (is_gimple_min_invariant (expr))\n@@ -1418,34 +1428,36 @@ will_be_nonconstant_expr_predicate (struct ipa_node_params *info,\n     return nonconstant_names[SSA_NAME_VERSION (expr)];\n   if (BINARY_CLASS_P (expr) || COMPARISON_CLASS_P (expr))\n     {\n-      predicate p1 = will_be_nonconstant_expr_predicate\n-\t(info, summary, TREE_OPERAND (expr, 0),\n-\t nonconstant_names);\n+      predicate p1\n+\t= will_be_nonconstant_expr_predicate (fbi, summary,\n+\t\t\t\t\t      TREE_OPERAND (expr, 0),\n+\t\t\t\t\t      nonconstant_names);\n       if (p1 == true)\n \treturn p1;\n \n-      predicate p2;\n-      p2 = will_be_nonconstant_expr_predicate (info, summary,\n-\t\t\t\t\t       TREE_OPERAND (expr, 1),\n-\t\t\t\t\t       nonconstant_names);\n+      predicate p2\n+\t= will_be_nonconstant_expr_predicate (fbi, summary,\n+\t\t\t\t\t      TREE_OPERAND (expr, 1),\n+\t\t\t\t\t      nonconstant_names);\n       return p1.or_with (summary->conds, p2);\n     }\n   else if (TREE_CODE (expr) == COND_EXPR)\n     {\n-      predicate p1 = will_be_nonconstant_expr_predicate\n-\t(info, summary, TREE_OPERAND (expr, 0),\n-\t nonconstant_names);\n+      predicate p1\n+\t= will_be_nonconstant_expr_predicate (fbi, summary,\n+\t\t\t\t\t      TREE_OPERAND (expr, 0),\n+\t\t\t\t\t      nonconstant_names);\n       if (p1 == true)\n \treturn p1;\n \n-      predicate p2;\n-      p2 = will_be_nonconstant_expr_predicate (info, summary,\n-\t\t\t\t\t       TREE_OPERAND (expr, 1),\n-\t\t\t\t\t       nonconstant_names);\n+      predicate p2\n+\t= will_be_nonconstant_expr_predicate (fbi, summary,\n+\t\t\t\t\t      TREE_OPERAND (expr, 1),\n+\t\t\t\t\t      nonconstant_names);\n       if (p2 == true)\n \treturn p2;\n       p1 = p1.or_with (summary->conds, p2);\n-      p2 = will_be_nonconstant_expr_predicate (info, summary,\n+      p2 = will_be_nonconstant_expr_predicate (fbi, summary,\n \t\t\t\t\t       TREE_OPERAND (expr, 2),\n \t\t\t\t\t       nonconstant_names);\n       return p2.or_with (summary->conds, p1);\n@@ -1511,7 +1523,7 @@ will_be_nonconstant_predicate (struct ipa_func_body_info *fbi,\n      adding conditionals.  */\n   FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n     {\n-      tree parm = unmodified_parm (stmt, use, NULL);\n+      tree parm = unmodified_parm (fbi, stmt, use, NULL);\n       /* For arguments we can build a condition.  */\n       if (parm && ipa_get_param_decl_index (fbi->info, parm) >= 0)\n \tcontinue;\n@@ -1533,7 +1545,7 @@ will_be_nonconstant_predicate (struct ipa_func_body_info *fbi,\n   FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n     {\n       HOST_WIDE_INT size;\n-      tree parm = unmodified_parm (stmt, use, &size);\n+      tree parm = unmodified_parm (fbi, stmt, use, &size);\n       int index;\n \n       if (parm && (index = ipa_get_param_decl_index (fbi->info, parm)) >= 0)\n@@ -1620,7 +1632,7 @@ record_modified (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef, void *data)\n    ought to be REG_BR_PROB_BASE / estimated_iters.  */\n \n static int\n-param_change_prob (gimple *stmt, int i)\n+param_change_prob (ipa_func_body_info *fbi, gimple *stmt, int i)\n {\n   tree op = gimple_call_arg (stmt, i);\n   basic_block bb = gimple_bb (stmt);\n@@ -1680,12 +1692,18 @@ param_change_prob (gimple *stmt, int i)\n       info.op = op;\n       info.stmt = stmt;\n       info.bb_set = BITMAP_ALLOC (NULL);\n-      walk_aliased_vdefs (&refd, gimple_vuse (stmt), record_modified, &info,\n-\t\t\t  NULL);\n-      if (bitmap_bit_p (info.bb_set, bb->index))\n+      int walked\n+\t= walk_aliased_vdefs (&refd, gimple_vuse (stmt), record_modified, &info,\n+\t\t\t      NULL, NULL, fbi->aa_walk_budget);\n+      if (walked < 0 || bitmap_bit_p (info.bb_set, bb->index))\n \t{\n \t  if (dump_file)\n-\t    fprintf (dump_file, \"     Set in same BB as used.\\n\");\n+\t    {\n+\t      if (walked < 0)\n+\t\tfprintf (dump_file, \"     Ran out of AA walking budget.\\n\");\n+\t      else\n+\t\tfprintf (dump_file, \"     Set in same BB as used.\\n\");\n+\t    }\n \t  BITMAP_FREE (info.bb_set);\n \t  return REG_BR_PROB_BASE;\n \t}\n@@ -1719,7 +1737,7 @@ param_change_prob (gimple *stmt, int i)\n    return true and store the pointer the predicate in *P.  */\n \n static bool\n-phi_result_unknown_predicate (struct ipa_node_params *info,\n+phi_result_unknown_predicate (ipa_func_body_info *fbi,\n \t\t\t      ipa_fn_summary *summary, basic_block bb,\n \t\t\t      predicate *p,\n \t\t\t      vec<predicate> nonconstant_names)\n@@ -1764,7 +1782,7 @@ phi_result_unknown_predicate (struct ipa_node_params *info,\n       || !is_gimple_ip_invariant (gimple_cond_rhs (stmt)))\n     return false;\n \n-  *p = will_be_nonconstant_expr_predicate (info, summary,\n+  *p = will_be_nonconstant_expr_predicate (fbi, summary,\n \t\t\t\t\t   gimple_cond_lhs (stmt),\n \t\t\t\t\t   nonconstant_names);\n   if (*p == true)\n@@ -2018,7 +2036,9 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t  fbi.info = IPA_NODE_REF (node);\n \t  fbi.bb_infos = vNULL;\n \t  fbi.bb_infos.safe_grow_cleared (last_basic_block_for_fn (cfun));\n-\t  fbi.param_count = count_formal_params(node->decl);\n+\t  fbi.param_count = count_formal_params (node->decl);\n+\t  fbi.aa_walk_budget = PARAM_VALUE (PARAM_IPA_MAX_AA_STEPS);\n+\n \t  nonconstant_names.safe_grow_cleared\n \t    (SSANAMES (my_function)->length ());\n \t}\n@@ -2083,7 +2103,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t       gsi_next (&bsi))\n \t    {\n \t      if (first_phi\n-\t\t  && !phi_result_unknown_predicate (fbi.info, info, bb,\n+\t\t  && !phi_result_unknown_predicate (&fbi, info, bb,\n \t\t\t\t\t\t    &phi_predicate,\n \t\t\t\t\t\t    nonconstant_names))\n \t\tbreak;\n@@ -2173,7 +2193,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t\t    es->param.safe_grow_cleared (count);\n \t\t  for (i = 0; i < count; i++)\n \t\t    {\n-\t\t      int prob = param_change_prob (stmt, i);\n+\t\t      int prob = param_change_prob (&fbi, stmt, i);\n \t\t      gcc_assert (prob >= 0 && prob <= REG_BR_PROB_BASE);\n \t\t      es->param[i].change_prob = prob;\n \t\t    }\n@@ -2209,7 +2229,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t    {\n \t      sreal final_time = (sreal)this_time * freq;\n \n-\t      prob = eliminated_by_inlining_prob (stmt);\n+\t      prob = eliminated_by_inlining_prob (&fbi, stmt);\n \t      if (prob == 1 && dump_file && (dump_flags & TDF_DETAILS))\n \t\tfprintf (dump_file,\n \t\t\t \"\\t\\t50%% will be eliminated by inlining\\n\");\n@@ -2286,7 +2306,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t\t&& !is_gimple_min_invariant (niter_desc.niter))\n \t    {\n \t      predicate will_be_nonconstant\n-\t\t= will_be_nonconstant_expr_predicate (fbi.info, info,\n+\t\t= will_be_nonconstant_expr_predicate (&fbi, info,\n \t\t\t\t\t\t      niter_desc.niter,\n \t\t\t\t\t\t      nonconstant_names);\n \t      if (will_be_nonconstant != true)\n@@ -2331,8 +2351,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t\t    continue;\n \n \t\t  predicate will_be_nonconstant\n-\t\t    = will_be_nonconstant_expr_predicate (fbi.info, info,\n-\t\t\t\t\t\t\t  iv.step,\n+\t\t    = will_be_nonconstant_expr_predicate (&fbi, info, iv.step,\n \t\t\t\t\t\t\t  nonconstant_names);\n \t\t  if (will_be_nonconstant != true)\n \t\t    will_be_nonconstant = bb_predicate & will_be_nonconstant;"}, {"sha": "75d8ebc1c446f87cead4b276aca13ad620b4f525", "filename": "gcc/ipa-polymorphic-call.c", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c628d1c325e81467fac06a92c8dfb7768e0cf7ad/gcc%2Fipa-polymorphic-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c628d1c325e81467fac06a92c8dfb7768e0cf7ad/gcc%2Fipa-polymorphic-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-polymorphic-call.c?ref=c628d1c325e81467fac06a92c8dfb7768e0cf7ad", "patch": "@@ -1554,13 +1554,18 @@ check_stmt_for_type_change (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef, void *data)\n \n    We do not include this analysis in the context analysis itself, because\n    it needs memory SSA to be fully built and the walk may be expensive.\n-   So it is not suitable for use withing fold_stmt and similar uses.  */\n+   So it is not suitable for use withing fold_stmt and similar uses.\n+\n+   AA_WALK_BUDGET_P, if not NULL, is how statements we should allow\n+   walk_aliased_vdefs to examine.  The value should be decremented by the\n+   number of stetements we examined or set to zero if exhausted.  */\n \n bool\n ipa_polymorphic_call_context::get_dynamic_type (tree instance,\n \t\t\t\t\t\ttree otr_object,\n \t\t\t\t\t\ttree otr_type,\n-\t\t\t\t\t\tgimple *call)\n+\t\t\t\t\t\tgimple *call,\n+\t\t\t\t\t\tunsigned *aa_walk_budget_p)\n {\n   struct type_change_info tci;\n   ao_ref ao;\n@@ -1723,8 +1728,13 @@ ipa_polymorphic_call_context::get_dynamic_type (tree instance,\n   tci.speculative = 0;\n   tci.seen_unanalyzed_store = false;\n \n-  walk_aliased_vdefs (&ao, gimple_vuse (stmt), check_stmt_for_type_change,\n-\t\t      &tci, NULL, &function_entry_reached);\n+  unsigned aa_walk_budget = 0;\n+  if (aa_walk_budget_p)\n+    aa_walk_budget = *aa_walk_budget_p + 1;\n+\n+  int walked\n+   = walk_aliased_vdefs (&ao, gimple_vuse (stmt), check_stmt_for_type_change,\n+\t\t\t &tci, NULL, &function_entry_reached, aa_walk_budget);\n \n   /* If we did not find any type changing statements, we may still drop\n      maybe_in_construction flag if the context already have outer type. \n@@ -1772,6 +1782,16 @@ ipa_polymorphic_call_context::get_dynamic_type (tree instance,\n      only if there was dyanmic type store that may affect given variable\n      (seen_unanalyzed_store)  */\n \n+  if (walked < 0)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"  AA walk budget exhausted.\\n\");\n+      *aa_walk_budget_p = 0;\n+      return false;\n+    }\n+  else if (aa_walk_budget_p)\n+    *aa_walk_budget_p -= walked;\n+\n   if (!tci.type_maybe_changed\n       || (outer_type\n \t  && !dynamic"}, {"sha": "40ab130b750f0ceb9f5840e755af6555f021006a", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 60, "deletions": 68, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c628d1c325e81467fac06a92c8dfb7768e0cf7ad/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c628d1c325e81467fac06a92c8dfb7768e0cf7ad/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=c628d1c325e81467fac06a92c8dfb7768e0cf7ad", "patch": "@@ -746,13 +746,13 @@ param_type_may_change_p (tree function, tree arg, gimple *call)\n    that does the heavy work which is usually unnecesary.  */\n \n static bool\n-detect_type_change_from_memory_writes (tree arg, tree base, tree comp_type,\n-\t\t\t\t       gcall *call, struct ipa_jump_func *jfunc,\n+detect_type_change_from_memory_writes (ipa_func_body_info *fbi, tree arg,\n+\t\t\t\t       tree base, tree comp_type, gcall *call,\n+\t\t\t\t       struct ipa_jump_func *jfunc,\n \t\t\t\t       HOST_WIDE_INT offset)\n {\n   struct prop_type_change_info tci;\n   ao_ref ao;\n-  bool entry_reached = false;\n \n   gcc_checking_assert (DECL_P (arg)\n \t\t       || TREE_CODE (arg) == MEM_REF\n@@ -780,9 +780,11 @@ detect_type_change_from_memory_writes (tree arg, tree base, tree comp_type,\n   tci.object = get_base_address (arg);\n   tci.type_maybe_changed = false;\n \n-  walk_aliased_vdefs (&ao, gimple_vuse (call), check_stmt_for_type_change,\n-\t\t      &tci, NULL, &entry_reached);\n-  if (!tci.type_maybe_changed)\n+  int walked\n+    = walk_aliased_vdefs (&ao, gimple_vuse (call), check_stmt_for_type_change,\n+\t\t\t  &tci, NULL, NULL, fbi->aa_walk_budget + 1);\n+\n+  if (walked >= 0 && !tci.type_maybe_changed)\n     return false;\n \n   ipa_set_jf_unknown (jfunc);\n@@ -796,8 +798,9 @@ detect_type_change_from_memory_writes (tree arg, tree base, tree comp_type,\n    returned by get_ref_base_and_extent, as is the offset.  */\n \n static bool\n-detect_type_change (tree arg, tree base, tree comp_type, gcall *call,\n-\t\t    struct ipa_jump_func *jfunc, HOST_WIDE_INT offset)\n+detect_type_change (ipa_func_body_info *fbi, tree arg, tree base,\n+\t\t    tree comp_type, gcall *call, struct ipa_jump_func *jfunc,\n+\t\t    HOST_WIDE_INT offset)\n {\n   if (!flag_devirtualize)\n     return false;\n@@ -807,7 +810,7 @@ detect_type_change (tree arg, tree base, tree comp_type, gcall *call,\n \t\t\t\t   TREE_OPERAND (base, 0),\n \t\t\t\t   call))\n     return false;\n-  return detect_type_change_from_memory_writes (arg, base, comp_type,\n+  return detect_type_change_from_memory_writes (fbi, arg, base, comp_type,\n \t\t\t\t\t\tcall, jfunc, offset);\n }\n \n@@ -816,7 +819,7 @@ detect_type_change (tree arg, tree base, tree comp_type, gcall *call,\n    be zero).  */\n \n static bool\n-detect_type_change_ssa (tree arg, tree comp_type,\n+detect_type_change_ssa (ipa_func_body_info *fbi, tree arg, tree comp_type,\n \t\t\tgcall *call, struct ipa_jump_func *jfunc)\n {\n   gcc_checking_assert (TREE_CODE (arg) == SSA_NAME);\n@@ -830,7 +833,7 @@ detect_type_change_ssa (tree arg, tree comp_type,\n   arg = build2 (MEM_REF, ptr_type_node, arg,\n \t\tbuild_int_cst (ptr_type_node, 0));\n \n-  return detect_type_change_from_memory_writes (arg, arg, comp_type,\n+  return detect_type_change_from_memory_writes (fbi, arg, arg, comp_type,\n \t\t\t\t\t\tcall, jfunc, 0);\n }\n \n@@ -846,16 +849,6 @@ mark_modified (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef ATTRIBUTE_UNUSED,\n   return true;\n }\n \n-/* Return true if we have already walked so many statements in AA that we\n-   should really just start giving up.  */\n-\n-static bool\n-aa_overwalked (struct ipa_func_body_info *fbi)\n-{\n-  gcc_checking_assert (fbi);\n-  return fbi->aa_walked > (unsigned) PARAM_VALUE (PARAM_IPA_MAX_AA_STEPS);\n-}\n-\n /* Find the nearest valid aa status for parameter specified by INDEX that\n    dominates BB.  */\n \n@@ -922,28 +915,24 @@ parm_preserved_before_stmt_p (struct ipa_func_body_info *fbi, int index,\n   if (TREE_READONLY (base))\n     return true;\n \n-  /* FIXME: FBI can be NULL if we are being called from outside\n-     ipa_node_analysis or ipcp_transform_function, which currently happens\n-     during inlining analysis.  It would be great to extend fbi's lifetime and\n-     always have it.  Currently, we are just not afraid of too much walking in\n-     that case.  */\n-  if (fbi)\n-    {\n-      if (aa_overwalked (fbi))\n-\treturn false;\n-      paa = parm_bb_aa_status_for_bb (fbi, gimple_bb (stmt), index);\n-      if (paa->parm_modified)\n-\treturn false;\n-    }\n-  else\n-    paa = NULL;\n+  gcc_checking_assert (fbi);\n+  paa = parm_bb_aa_status_for_bb (fbi, gimple_bb (stmt), index);\n+  if (paa->parm_modified)\n+    return false;\n \n   gcc_checking_assert (gimple_vuse (stmt) != NULL_TREE);\n   ao_ref_init (&refd, parm_load);\n   int walked = walk_aliased_vdefs (&refd, gimple_vuse (stmt), mark_modified,\n-\t\t\t\t   &modified, NULL);\n-  if (fbi)\n-    fbi->aa_walked += walked;\n+\t\t\t\t   &modified, NULL, NULL,\n+\t\t\t\t   fbi->aa_walk_budget + 1);\n+  if (walked < 0)\n+    {\n+      modified = true;\n+      if (fbi)\n+\tfbi->aa_walk_budget = 0;\n+    }\n+  else if (fbi)\n+    fbi->aa_walk_budget -= walked;\n   if (paa && modified)\n     paa->parm_modified = true;\n   return !modified;\n@@ -988,29 +977,24 @@ parm_ref_data_preserved_p (struct ipa_func_body_info *fbi,\n   bool modified = false;\n   ao_ref refd;\n \n-  /* FIXME: FBI can be NULL if we are being called from outside\n-     ipa_node_analysis or ipcp_transform_function, which currently happens\n-     during inlining analysis.  It would be great to extend fbi's lifetime and\n-     always have it.  Currently, we are just not afraid of too much walking in\n-     that case.  */\n-  if (fbi)\n-    {\n-      if (aa_overwalked (fbi))\n-\treturn false;\n-      paa = parm_bb_aa_status_for_bb (fbi, gimple_bb (stmt), index);\n-      if (paa->ref_modified)\n-\treturn false;\n-    }\n-  else\n-    paa = NULL;\n+  gcc_checking_assert (fbi);\n+  paa = parm_bb_aa_status_for_bb (fbi, gimple_bb (stmt), index);\n+  if (paa->ref_modified)\n+    return false;\n \n   gcc_checking_assert (gimple_vuse (stmt));\n   ao_ref_init (&refd, ref);\n   int walked = walk_aliased_vdefs (&refd, gimple_vuse (stmt), mark_modified,\n-\t\t\t\t   &modified, NULL);\n-  if (fbi)\n-    fbi->aa_walked += walked;\n-  if (paa && modified)\n+\t\t\t\t   &modified, NULL, NULL,\n+\t\t\t\t   fbi->aa_walk_budget + 1);\n+  if (walked < 0)\n+    {\n+      modified = true;\n+      fbi->aa_walk_budget = 0;\n+    }\n+  else\n+    fbi->aa_walk_budget -= walked;\n+  if (modified)\n     paa->ref_modified = true;\n   return !modified;\n }\n@@ -1030,8 +1014,7 @@ parm_ref_data_pass_through_p (struct ipa_func_body_info *fbi, int index,\n      function because it is not goin to use it.  But do not cache the result\n      either.  Also, no such calculations for non-pointers.  */\n   if (!gimple_vuse (call)\n-      || !POINTER_TYPE_P (TREE_TYPE (parm))\n-      || aa_overwalked (fbi))\n+      || !POINTER_TYPE_P (TREE_TYPE (parm)))\n     return false;\n \n   struct ipa_param_aa_status *paa = parm_bb_aa_status_for_bb (fbi,\n@@ -1042,8 +1025,15 @@ parm_ref_data_pass_through_p (struct ipa_func_body_info *fbi, int index,\n \n   ao_ref_init_from_ptr_and_size (&refd, parm, NULL_TREE);\n   int walked = walk_aliased_vdefs (&refd, gimple_vuse (call), mark_modified,\n-\t\t\t\t   &modified, NULL);\n-  fbi->aa_walked += walked;\n+\t\t\t\t   &modified, NULL, NULL,\n+\t\t\t\t   fbi->aa_walk_budget + 1);\n+  if (walked < 0)\n+    {\n+      fbi->aa_walk_budget = 0;\n+      modified = true;\n+    }\n+  else\n+    fbi->aa_walk_budget -= walked;\n   if (modified)\n     paa->pt_modified = true;\n   return !modified;\n@@ -1851,7 +1841,8 @@ ipa_compute_jump_functions_for_edge (struct ipa_func_body_info *fbi,\n \t  struct ipa_polymorphic_call_context context (cs->caller->decl,\n \t\t\t\t\t\t       arg, cs->call_stmt,\n \t\t\t\t\t\t       &instance);\n-\t  context.get_dynamic_type (instance, arg, NULL, cs->call_stmt);\n+\t  context.get_dynamic_type (instance, arg, NULL, cs->call_stmt,\n+\t\t\t\t    &fbi->aa_walk_budget);\n \t  *ipa_get_ith_polymorhic_call_context (args, n) = context;\n \t  if (!context.useless_p ())\n \t    useful_context = true;\n@@ -2324,7 +2315,7 @@ ipa_analyze_virtual_call_uses (struct ipa_func_body_info *fbi,\n       anc_offset = 0;\n       index = ipa_get_param_decl_index (info, SSA_NAME_VAR (obj));\n       gcc_assert (index >= 0);\n-      if (detect_type_change_ssa (obj, obj_type_ref_class (target),\n+      if (detect_type_change_ssa (fbi, obj, obj_type_ref_class (target),\n \t\t\t\t  call, &jfunc))\n \treturn;\n     }\n@@ -2340,7 +2331,7 @@ ipa_analyze_virtual_call_uses (struct ipa_func_body_info *fbi,\n       index = ipa_get_param_decl_index (info,\n \t\t\t\t\tSSA_NAME_VAR (TREE_OPERAND (expr, 0)));\n       gcc_assert (index >= 0);\n-      if (detect_type_change (obj, expr, obj_type_ref_class (target),\n+      if (detect_type_change (fbi, obj, expr, obj_type_ref_class (target),\n \t\t\t      call, &jfunc, anc_offset))\n \treturn;\n     }\n@@ -2388,7 +2379,8 @@ ipa_analyze_call_uses (struct ipa_func_body_info *fbi, gcall *call)\n       cs->indirect_info->vptr_changed\n \t= !context.get_dynamic_type (instance,\n \t\t\t\t     OBJ_TYPE_REF_OBJECT (target),\n-\t\t\t\t     obj_type_ref_class (target), call);\n+\t\t\t\t     obj_type_ref_class (target), call,\n+\t\t\t\t     &fbi->aa_walk_budget);\n       cs->indirect_info->context = context;\n     }\n \n@@ -2588,7 +2580,7 @@ ipa_analyze_node (struct cgraph_node *node)\n   fbi.bb_infos = vNULL;\n   fbi.bb_infos.safe_grow_cleared (last_basic_block_for_fn (cfun));\n   fbi.param_count = ipa_get_param_count (info);\n-  fbi.aa_walked = 0;\n+  fbi.aa_walk_budget = PARAM_VALUE (PARAM_IPA_MAX_AA_STEPS);\n \n   for (struct cgraph_edge *cs = node->callees; cs; cs = cs->next_callee)\n     {\n@@ -5157,7 +5149,7 @@ ipcp_transform_function (struct cgraph_node *node)\n   fbi.bb_infos = vNULL;\n   fbi.bb_infos.safe_grow_cleared (last_basic_block_for_fn (cfun));\n   fbi.param_count = param_count;\n-  fbi.aa_walked = 0;\n+  fbi.aa_walk_budget = PARAM_VALUE (PARAM_IPA_MAX_AA_STEPS);\n \n   vec_safe_grow_cleared (descriptors, param_count);\n   ipa_populate_param_decls (node, *descriptors);"}, {"sha": "7257a6d04f141ddd25b75947231ecc1666cad5c8", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c628d1c325e81467fac06a92c8dfb7768e0cf7ad/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c628d1c325e81467fac06a92c8dfb7768e0cf7ad/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=c628d1c325e81467fac06a92c8dfb7768e0cf7ad", "patch": "@@ -428,8 +428,9 @@ struct ipa_func_body_info\n   /* Number of parameters.  */\n   int param_count;\n \n-  /* Number of statements already walked by when analyzing this function.  */\n-  unsigned int aa_walked;\n+  /* Number of statements we are still allowed to walked by when analyzing this\n+     function.  */\n+  unsigned int aa_walk_budget;\n };\n \n /* ipa_node_params access functions.  Please use these to access fields that"}, {"sha": "7e8e05e7af0c2eba47c2abd4d77199a7c7952199", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c628d1c325e81467fac06a92c8dfb7768e0cf7ad/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c628d1c325e81467fac06a92c8dfb7768e0cf7ad/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=c628d1c325e81467fac06a92c8dfb7768e0cf7ad", "patch": "@@ -5275,7 +5275,7 @@ eliminate_dom_walker::eliminate_stmt (basic_block b, gimple_stmt_iterator *gsi)\n \t  ipa_polymorphic_call_context context (current_function_decl,\n \t\t\t\t\t\tfn, stmt, &instance);\n \t  context.get_dynamic_type (instance, OBJ_TYPE_REF_OBJECT (fn),\n-\t\t\t\t    otr_type, stmt);\n+\t\t\t\t    otr_type, stmt, NULL);\n \t  bool final;\n \t  vec <cgraph_node *> targets\n \t      = possible_polymorphic_call_targets (obj_type_ref_class (fn),"}]}