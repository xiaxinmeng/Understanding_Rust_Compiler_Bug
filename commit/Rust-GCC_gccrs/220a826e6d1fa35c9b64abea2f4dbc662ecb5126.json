{"sha": "220a826e6d1fa35c9b64abea2f4dbc662ecb5126", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjIwYTgyNmU2ZDFmYTM1YzliNjRhYmVhMmY0ZGJjNjYyZWNiNTEyNg==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2004-07-14T13:09:09Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2004-07-14T13:09:09Z"}, "message": "s390.md (\"udivsi3\"): Ensure trap is generated for division by zero.\n\ngcc/ChangeLog:\n\n\t* config/s390/s390.md (\"udivsi3\"): Ensure trap is generated\n\tfor division by zero.\n\t(\"umodsi3\"): Likewise.\n\nlibjava/ChangeLog:\n\n\t* configure.host (DIVIDESPEC) [s390*-*-*]: Set to\n\t-fno-use-divide-subroutine.\n\t* include/s390-signal.h: Include <ucontext.h> and <limits.h>.\n\t(HANDLE_FPE): Define.\n\t(SIGNAL_HANDLER): Change third argument to ucontext_t *.\n\t(struct old_s390_kernel_sigaction): Likewise for k_sa_handler.\n\t(HANDLE_DIVIDE_OVERFLOW): Define.\n\nFrom-SVN: r84683", "tree": {"sha": "8c1149be9d6bd70d5d9e66146dc0e63270631f23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c1149be9d6bd70d5d9e66146dc0e63270631f23"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/220a826e6d1fa35c9b64abea2f4dbc662ecb5126", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/220a826e6d1fa35c9b64abea2f4dbc662ecb5126", "html_url": "https://github.com/Rust-GCC/gccrs/commit/220a826e6d1fa35c9b64abea2f4dbc662ecb5126", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/220a826e6d1fa35c9b64abea2f4dbc662ecb5126/comments", "author": null, "committer": null, "parents": [{"sha": "bb732af86378799aa21ead613328f261480aad14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb732af86378799aa21ead613328f261480aad14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb732af86378799aa21ead613328f261480aad14"}], "stats": {"total": 179, "additions": 174, "deletions": 5}, "files": [{"sha": "98278ae5a5c8cfbd978e87bc97062e58c38f49fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/220a826e6d1fa35c9b64abea2f4dbc662ecb5126/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/220a826e6d1fa35c9b64abea2f4dbc662ecb5126/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=220a826e6d1fa35c9b64abea2f4dbc662ecb5126", "patch": "@@ -1,3 +1,9 @@\n+2004-07-14  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/s390.md (\"udivsi3\"): Ensure trap is generated\n+\tfor division by zero.\n+\t(\"umodsi3\"): Likewise.\n+\n 2004-07-14  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.c (mips_output_move): When generating mips16 code,"}, {"sha": "8a95d0cc3ab3af8b79412cba553e134386d53ce2", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/220a826e6d1fa35c9b64abea2f4dbc662ecb5126/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/220a826e6d1fa35c9b64abea2f4dbc662ecb5126/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=220a826e6d1fa35c9b64abea2f4dbc662ecb5126", "patch": "@@ -4990,7 +4990,7 @@\n       emit_move_insn (operands[0], const0_rtx);\n       emit_insn (gen_cmpsi (operands[2], operands[1]));\n       emit_jump_insn (gen_bgtu (label3));\n-      emit_insn (gen_cmpsi (operands[2], const1_rtx));\n+      emit_insn (gen_cmpsi (operands[2], const0_rtx));\n       emit_jump_insn (gen_blt (label2));\n       emit_insn (gen_cmpsi (operands[2], const1_rtx));\n       emit_jump_insn (gen_beq (label1));\n@@ -5082,7 +5082,7 @@\n       emit_move_insn(operands[0], operands[1]);\n       emit_insn (gen_cmpsi (operands[2], operands[1]));\n       emit_jump_insn (gen_bgtu (label3));\n-      emit_insn (gen_cmpsi (operands[2], const1_rtx));\n+      emit_insn (gen_cmpsi (operands[2], const0_rtx));\n       emit_jump_insn (gen_blt (label2));\n       emit_insn (gen_cmpsi (operands[2], const1_rtx));\n       emit_jump_insn (gen_beq (label1));"}, {"sha": "4a2f6454e0f6e1888300c9b0c8b1b7c4793a289f", "filename": "libjava/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/220a826e6d1fa35c9b64abea2f4dbc662ecb5126/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/220a826e6d1fa35c9b64abea2f4dbc662ecb5126/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=220a826e6d1fa35c9b64abea2f4dbc662ecb5126", "patch": "@@ -1,3 +1,13 @@\n+2004-07-14  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* configure.host (DIVIDESPEC) [s390*-*-*]: Set to \n+\t-fno-use-divide-subroutine.\n+\t* include/s390-signal.h: Include <ucontext.h> and <limits.h>.\n+\t(HANDLE_FPE): Define.\n+\t(SIGNAL_HANDLER): Change third argument to ucontext_t *.\n+\t(struct old_s390_kernel_sigaction): Likewise for k_sa_handler.\n+\t(HANDLE_DIVIDE_OVERFLOW): Define.\n+\n 2004-07-14  Michael Koch  <konqueror@gmx.de> \n \t    Matthias Klose  <doko@debian.org> \n "}, {"sha": "4cef1b8a5d130c3581250d90f950ce0fd2ea8b33", "filename": "libjava/configure.host", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/220a826e6d1fa35c9b64abea2f4dbc662ecb5126/libjava%2Fconfigure.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/220a826e6d1fa35c9b64abea2f4dbc662ecb5126/libjava%2Fconfigure.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure.host?ref=220a826e6d1fa35c9b64abea2f4dbc662ecb5126", "patch": "@@ -138,6 +138,7 @@ case \"${host}\" in\n   s390*-*)\n \tsysdeps_dir=s390\n \tlibgcj_interpreter=yes\n+\tDIVIDESPEC=-fno-use-divide-subroutine\n \tenable_hash_synchronization_default=yes\n \t;;\n   sparc*-*)"}, {"sha": "fe965bd2b460f8aab713121d0a3b765a535c59c1", "filename": "libjava/include/s390-signal.h", "status": "modified", "additions": 155, "deletions": 3, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/220a826e6d1fa35c9b64abea2f4dbc662ecb5126/libjava%2Finclude%2Fs390-signal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/220a826e6d1fa35c9b64abea2f4dbc662ecb5126/libjava%2Finclude%2Fs390-signal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fs390-signal.h?ref=220a826e6d1fa35c9b64abea2f4dbc662ecb5126", "patch": "@@ -15,18 +15,170 @@ details.  */\n \n #include <signal.h>\n #include <sys/syscall.h>\n+#include <ucontext.h>\n+#include <limits.h>\n \n #define HANDLE_SEGV 1\n-#undef HANDLE_FPE\n+#define HANDLE_FPE 1\n \n #define SIGNAL_HANDLER(_name)\t\\\n-static void _name (int, siginfo_t *, void *)\n+static void _name (int, siginfo_t *_si __attribute__((unused)), \\\n+\t\t   ucontext_t *_uc __attribute__((unused)))\n \n /* We no longer need to fiddle with the PSW address in the signal handler;\n    this is now all handled correctly in MD_FALLBACK_FRAME_STATE_FOR.  */\n #define MAKE_THROW_FRAME(_exception)\n \n \n+/* According to the JVM spec, \"if the dividend is the negative integer \n+   of the smallest magnitude and the divisor is -1, then overflow occurs \n+   and the result is equal to the dividend.  Despite the overflow, no \n+   exception occurs\".\n+\n+   We handle this by inspecting the instruction which generated the signal,\n+   and if dividend and divisor are as above, we simply return from the signal\n+   handler.  This causes execution to continue after the instruction.  \n+   Before returning, we the set result registers as expected.  */\n+\n+#define HANDLE_DIVIDE_OVERFLOW\t\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  unsigned char *_eip = (unsigned char *)\t\t\t\t\\\n+    __builtin_extract_return_addr (_si->si_addr);\t\t\t\\\n+  unsigned long *_regs = _uc->uc_mcontext.gregs;\t\t\t\\\n+  int _r1, _r2, _d2, _x2, _b2;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* First, a couple of helper routines to decode instructions.  */\t\\\n+  struct _decode \t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      /* Decode RR instruction format.  */\t\t\t\t\\\n+      static inline int _is_rr (unsigned char *_eip, \t\t\t\\\n+\t\t\t\tunsigned char _op,\t\t\t\\\n+\t\t\t\tint *_r1, int *_r2) \t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tif (_eip[0] == _op)\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    *_r1 = _eip[1] >> 4;\t\t\t\t\t\\\n+\t    *_r2 = _eip[1] & 0xf;\t\t\t\t\t\\\n+\t    return 1;\t\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\treturn 0;\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      /* Decode RX instruction format.  */\t\t\t\t\\\n+      static inline int _is_rx (unsigned char *_eip,\t\t\t\\\n+\t\t\t\tunsigned char _op,\t\t\t\\\n+\t\t\t\tint *_r1, int *_d2, int *_x2, int *_b2) \\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tif (_eip[0] == _op)\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    *_r1 = _eip[1] >> 4;\t\t\t\t\t\\\n+\t    *_x2 = _eip[1] & 0xf;\t\t\t\t\t\\\n+\t    *_b2 = _eip[2] >> 4;\t\t\t\t\t\\\n+\t    *_d2 = ((_eip[2] & 0xf) << 8) + _eip[3];\t\t\t\\\n+\t    return 1;\t\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\treturn 0;\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      /* Decode RRE instruction format.  */\t\t\t\t\\\n+      static inline int _is_rre (unsigned char *_eip,\t\t\t\\\n+\t\t\t\t unsigned char _op1, unsigned char _op2,\\\n+\t\t\t\t int *_r1, int *_r2)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tif (_eip[0] == _op1 && _eip[1] == _op2)\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    *_r1 = _eip[3] >> 4;\t\t\t\t\t\\\n+\t    *_r2 = _eip[3] & 0xf;\t\t\t\t\t\\\n+\t    return 1;\t\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\treturn 0;\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      /* Decode RXY instruction format.  */\t\t\t\t\\\n+      static inline int _is_rxy (unsigned char *_eip,\t\t\t\\\n+\t\t\t\t unsigned char _op1, unsigned char _op2,\\\n+\t\t\t\t int *_r1, int *_d2, int *_x2, int *_b2)\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tif (_eip[0] == _op1 && _eip[5] == _op2)\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    *_r1 = _eip[1] >> 4;\t\t\t\t\t\\\n+\t    *_x2 = _eip[1] & 0xf;\t\t\t\t\t\\\n+\t    *_b2 = _eip[2] >> 4;\t\t\t\t\t\\\n+\t    *_d2 = ((_eip[2] & 0xf) << 8) + _eip[3] + (_eip[4] << 12);\t\\\n+\t    /* We have a 20-bit signed displacement.  */\t\t\\\n+\t    *_d2 = (*_d2 ^ 0x80000) - 0x80000;\t\t\t\t\\\n+\t    return 1;\t\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\treturn 0;\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      /* Compute effective address.  */\t\t\t\t\t\\\n+      static inline unsigned long _eff (unsigned long *_regs,\t\t\\\n+\t\t\t\t\tlong _d, int _x, int _b)\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\treturn _d + (_x? _regs[_x] : 0) + (_b? _regs[_b] : 0);\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    };\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* DR r1,r2 */\t\t\t\t\t\t\t\\\n+  if (_decode::_is_rr (_eip, 0x1d, &_r1, &_r2)\t\t\t\t\\\n+      && (int) _regs[_r1] == -1 && (int) _regs[_r1+1] == INT_MIN\t\\\n+      && (int) _regs[_r2] == -1)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      _regs[_r1] &= ~0xffffffff;\t\t\t\t\t\\\n+      return;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+ \t\t\t\t\t\t\t\t\t\\\n+  /* D r1,d2(x2,b2) */\t\t\t\t\t\t\t\\\n+  if (_decode::_is_rx (_eip, 0x5d, &_r1, &_d2, &_x2, &_b2)\t\t\\\n+      && (int) _regs[_r1] == -1 && (int) _regs[_r1+1] == INT_MIN\t\\\n+      && *(int *) _decode::_eff (_regs, _d2, _x2, _b2) == -1)\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      _regs[_r1] &= ~0xffffffff;\t\t\t\t\t\\\n+      return;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* DSGR r1,r2 */\t\t\t\t\t\t\t\\\n+  if (_decode::_is_rre (_eip, 0xb9, 0x0d, &_r1, &_r2)\t\t\t\\\n+      && (long) _regs[_r1+1] == LONG_MIN\t\t\t\t\\\n+      && (long) _regs[_r2] == -1L)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      _regs[_r1] = 0;\t\t\t\t\t\t\t\\\n+      return;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* DSGFR r1,r2 */\t\t\t\t\t\t\t\\\n+  if (_decode::_is_rre (_eip, 0xb9, 0x1d, &_r1, &_r2)\t\t\t\\\n+      && (long) _regs[_r1+1] == LONG_MIN\t\t\t\t\\\n+      && (int) _regs[_r2] == -1)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      _regs[_r1] = 0;\t\t\t\t\t\t\t\\\n+      return;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* DSG r1,d2(x2,b2) */\t\t\t\t\t\t\\\n+  if (_decode::_is_rxy (_eip, 0xe3, 0x0d, &_r1, &_d2, &_x2, &_b2)\t\\\n+      && (long) _regs[_r1+1] == LONG_MIN\t\t\t\t\\\n+      && *(long *) _decode::_eff (_regs, _d2, _x2, _b2) == -1L)\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      _regs[_r1] = 0;\t\t\t\t\t\t\t\\\n+      return;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* DSGF r1,d2(x2,b2) */\t\t\t\t\t\t\\\n+  if (_decode::_is_rxy (_eip, 0xe3, 0x1d, &_r1, &_d2, &_x2, &_b2)\t\\\n+      && (long) _regs[_r1+1] == LONG_MIN\t\t\t\t\\\n+      && *(int *) _decode::_eff (_regs, _d2, _x2, _b2) == -1)\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      _regs[_r1] = 0;\t\t\t\t\t\t\t\\\n+      return;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n /* For an explanation why we cannot simply use sigaction to\n    install the handlers, see i386-signal.h.  */\n \n@@ -36,7 +188,7 @@ static void _name (int, siginfo_t *, void *)\n    visible to us in a header file so we define it here.  */\n \n struct old_s390_kernel_sigaction {\n-\tvoid (*k_sa_handler) (int, siginfo_t *, void *);\n+\tvoid (*k_sa_handler) (int, siginfo_t *, ucontext_t *);\n \tunsigned long k_sa_mask;\n \tunsigned long k_sa_flags;\n \tvoid (*sa_restorer) (void);"}]}