{"sha": "999646c1ee2b7e11c5beb86109fe660ca4d4235f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk5NjQ2YzFlZTJiN2UxMWM1YmViODYxMDlmZTY2MGNhNGQ0MjM1Zg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-07-23T20:25:47Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-07-23T20:25:47Z"}, "message": "dwarf2cfi: Convert queued_reg_save to a VEC.\n\nAlso, allocate it in the heap instead of garbage collected.\n\n        * dwarf2cfi.c (queued_reg_save): Reorder for packing.  Don't GTY.\n        (queued_reg_saves): Don't GTY.  Change to a VEC.\n        (queue_reg_save): Update to match.\n        (dwarf2out_flush_queued_reg_saves): Likewise.\n        (clobbers_queued_reg_save): Likewise.\n        (reg_saved_in): Likewise.\n        (execute_dwarf2_frame): Free queued_reg_saves.\n\nFrom-SVN: r176702", "tree": {"sha": "8e427909aedaf796c46ffc03a46069aa6f269e28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e427909aedaf796c46ffc03a46069aa6f269e28"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/999646c1ee2b7e11c5beb86109fe660ca4d4235f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/999646c1ee2b7e11c5beb86109fe660ca4d4235f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/999646c1ee2b7e11c5beb86109fe660ca4d4235f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/999646c1ee2b7e11c5beb86109fe660ca4d4235f/comments", "author": null, "committer": null, "parents": [{"sha": "ce363ef2bd9b1f2b7c1640160062c53398052c39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce363ef2bd9b1f2b7c1640160062c53398052c39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce363ef2bd9b1f2b7c1640160062c53398052c39"}], "stats": {"total": 61, "additions": 36, "deletions": 25}, "files": [{"sha": "45ad5af254327630088a26e15d4a87c8fcb755cc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999646c1ee2b7e11c5beb86109fe660ca4d4235f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999646c1ee2b7e11c5beb86109fe660ca4d4235f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=999646c1ee2b7e11c5beb86109fe660ca4d4235f", "patch": "@@ -1,3 +1,13 @@\n+2011-07-23  Richard Henderson  <rth@redhat.com>\n+\n+\t* dwarf2cfi.c (queued_reg_save): Reorder for packing.  Don't GTY.\n+\t(queued_reg_saves): Don't GTY.  Change to a VEC.\n+\t(queue_reg_save): Update to match.\n+\t(dwarf2out_flush_queued_reg_saves): Likewise.\n+\t(clobbers_queued_reg_save): Likewise.\n+\t(reg_saved_in): Likewise.\n+\t(execute_dwarf2_frame): Free queued_reg_saves.\n+\n 2011-07-23  Richard Henderson  <rth@redhat.com>\n \n \t* dwarf2cfi.c (dw_cfi_row_ref): Remove.  Update all users."}, {"sha": "a800cb4880d5065563885df3a6829f7e470207da", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999646c1ee2b7e11c5beb86109fe660ca4d4235f/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999646c1ee2b7e11c5beb86109fe660ca4d4235f/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=999646c1ee2b7e11c5beb86109fe660ca4d4235f", "patch": "@@ -1091,14 +1091,16 @@ dwarf2out_notice_stack_adjust (rtx insn, bool after_p)\n    of the prologue or (b) the register is clobbered.  This clusters\n    register saves so that there are fewer pc advances.  */\n \n-struct GTY(()) queued_reg_save {\n-  struct queued_reg_save *next;\n+typedef struct {\n   rtx reg;\n-  HOST_WIDE_INT cfa_offset;\n   rtx saved_reg;\n-};\n+  HOST_WIDE_INT cfa_offset;\n+} queued_reg_save;\n \n-static GTY(()) struct queued_reg_save *queued_reg_saves;\n+DEF_VEC_O (queued_reg_save);\n+DEF_VEC_ALLOC_O (queued_reg_save, heap);\n+\n+static VEC(queued_reg_save, heap) *queued_reg_saves;\n \n /* The caller's ORIG_REG is saved in SAVED_IN_REG.  */\n typedef struct GTY(()) reg_saved_in_data {\n@@ -1170,34 +1172,32 @@ record_reg_saved_in_reg (rtx dest, rtx src)\n static void\n queue_reg_save (rtx reg, rtx sreg, HOST_WIDE_INT offset)\n {\n-  struct queued_reg_save *q;\n+  queued_reg_save *q;\n+  size_t i;\n \n   /* Duplicates waste space, but it's also necessary to remove them\n      for correctness, since the queue gets output in reverse order.  */\n-  for (q = queued_reg_saves; q != NULL; q = q->next)\n+  FOR_EACH_VEC_ELT (queued_reg_save, queued_reg_saves, i, q)\n     if (compare_reg_or_pc (q->reg, reg))\n-      break;\n+      goto found;\n \n-  if (q == NULL)\n-    {\n-      q = ggc_alloc_queued_reg_save ();\n-      q->next = queued_reg_saves;\n-      queued_reg_saves = q;\n-    }\n+  q = VEC_safe_push (queued_reg_save, heap, queued_reg_saves, NULL);\n \n+ found:\n   q->reg = reg;\n-  q->cfa_offset = offset;\n   q->saved_reg = sreg;\n+  q->cfa_offset = offset;\n }\n \n /* Output all the entries in QUEUED_REG_SAVES.  */\n \n static void\n dwarf2out_flush_queued_reg_saves (void)\n {\n-  struct queued_reg_save *q;\n+  queued_reg_save *q;\n+  size_t i;\n \n-  for (q = queued_reg_saves; q; q = q->next)\n+  FOR_EACH_VEC_ELT (queued_reg_save, queued_reg_saves, i, q)\n     {\n       unsigned int reg, sreg;\n \n@@ -1214,7 +1214,7 @@ dwarf2out_flush_queued_reg_saves (void)\n       reg_save (reg, sreg, q->cfa_offset);\n     }\n \n-  queued_reg_saves = NULL;\n+  VEC_truncate (queued_reg_save, queued_reg_saves, 0);\n }\n \n /* Does INSN clobber any register which QUEUED_REG_SAVES lists a saved\n@@ -1225,17 +1225,18 @@ dwarf2out_flush_queued_reg_saves (void)\n static bool\n clobbers_queued_reg_save (const_rtx insn)\n {\n-  struct queued_reg_save *q;\n+  queued_reg_save *q;\n+  size_t iq;\n \n-  for (q = queued_reg_saves; q; q = q->next)\n+  FOR_EACH_VEC_ELT (queued_reg_save, queued_reg_saves, iq, q)\n     {\n-      size_t i;\n+      size_t ir;\n       reg_saved_in_data *rir;\n \n       if (modified_in_p (q->reg, insn))\n \treturn true;\n \n-      FOR_EACH_VEC_ELT (reg_saved_in_data, regs_saved_in_regs, i, rir)\n+      FOR_EACH_VEC_ELT (reg_saved_in_data, regs_saved_in_regs, ir, rir)\n \tif (compare_reg_or_pc (q->reg, rir->orig_reg)\n \t    && modified_in_p (rir->saved_in_reg, insn))\n \t  return true;\n@@ -1250,11 +1251,11 @@ static rtx\n reg_saved_in (rtx reg)\n {\n   unsigned int regn = REGNO (reg);\n-  struct queued_reg_save *q;\n+  queued_reg_save *q;\n   reg_saved_in_data *rir;\n   size_t i;\n \n-  for (q = queued_reg_saves; q; q = q->next)\n+  FOR_EACH_VEC_ELT (queued_reg_save, queued_reg_saves, i, q)\n     if (q->saved_reg && regn == REGNO (q->saved_reg))\n       return q->reg;\n \n@@ -2770,7 +2771,7 @@ execute_dwarf2_frame (void)\n   XDELETEVEC (barrier_args_size);\n   barrier_args_size = NULL;\n   regs_saved_in_regs = NULL;\n-  queued_reg_saves = NULL;\n+  VEC_free (queued_reg_save, heap, queued_reg_saves);\n \n   free_cfi_row (cur_row);\n   cur_row = NULL;"}]}