{"sha": "1f41df916c2d6d7598cb5e67cdaebdc86910e902", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWY0MWRmOTE2YzJkNmQ3NTk4Y2I1ZTY3Y2RhZWJkYzg2OTEwZTkwMg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2019-11-27T22:05:47Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-11-27T22:05:47Z"}, "message": "Fix constrained alias template transparency.\n\nA constrained alias template can't be treated as equivalent to its\nunderlying template/type for much the same reason that an alias template\nlike void_t can't; we're relying on checking during substitution.\n\n\t* cxx-pretty-print.c (pp_cxx_unqualified_id): Handle alias\n\ttemplate-id.\n\t* pt.c (complex_alias_template_p): True if constraints.\n\t(get_underlying_template, tsubst): Check alias constraints.\n\t(push_template_decl_real): Set alias constraints here.\n\t* parser.c (cp_parser_alias_declaration): Not here.\n\t* constraint.cc (get_constraints): Take const_tree.\n\nFrom-SVN: r278785", "tree": {"sha": "50c06c4b53bf6fd71ab1e834aabdcf0a2c7e4b37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50c06c4b53bf6fd71ab1e834aabdcf0a2c7e4b37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f41df916c2d6d7598cb5e67cdaebdc86910e902", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f41df916c2d6d7598cb5e67cdaebdc86910e902", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f41df916c2d6d7598cb5e67cdaebdc86910e902", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f41df916c2d6d7598cb5e67cdaebdc86910e902/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "96cbfa7ff8a146febd6af9a53d10468a90706419", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96cbfa7ff8a146febd6af9a53d10468a90706419", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96cbfa7ff8a146febd6af9a53d10468a90706419"}], "stats": {"total": 125, "additions": 97, "deletions": 28}, "files": [{"sha": "9dbc61c2151f4a5eff0c1694509df9fe50bd43a2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f41df916c2d6d7598cb5e67cdaebdc86910e902/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f41df916c2d6d7598cb5e67cdaebdc86910e902/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1f41df916c2d6d7598cb5e67cdaebdc86910e902", "patch": "@@ -1,3 +1,13 @@\n+2019-11-16  Jason Merrill  <jason@redhat.com>\n+\n+\t* cxx-pretty-print.c (pp_cxx_unqualified_id): Handle alias\n+\ttemplate-id.\n+\t* pt.c (complex_alias_template_p): True if constraints.\n+\t(get_underlying_template, tsubst): Check alias constraints.\n+\t(push_template_decl_real): Set alias constraints here.\n+\t* parser.c (cp_parser_alias_declaration): Not here.\n+\t* constraint.cc (get_constraints): Take const_tree.\n+\n 2019-11-12  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/92206 - ICE with typedef to dependent alias."}, {"sha": "0d1c27a6d1699880bedd2db03e87499c20d663f0", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f41df916c2d6d7598cb5e67cdaebdc86910e902/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f41df916c2d6d7598cb5e67cdaebdc86910e902/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=1f41df916c2d6d7598cb5e67cdaebdc86910e902", "patch": "@@ -1124,7 +1124,7 @@ static GTY ((cache)) decl_tree_cache_map *decl_constraints;\n    constrained, return NULL_TREE. Note that T must be non-null. */\n \n tree\n-get_constraints (tree t)\n+get_constraints (const_tree t)\n {\n   if (!flag_concepts)\n     return NULL_TREE;\n@@ -1134,7 +1134,7 @@ get_constraints (tree t)\n   gcc_assert (DECL_P (t));\n   if (TREE_CODE (t) == TEMPLATE_DECL)\n     t = DECL_TEMPLATE_RESULT (t);\n-  tree* found = decl_constraints->get (t);\n+  tree* found = decl_constraints->get (CONST_CAST_TREE (t));\n   if (found)\n     return *found;\n   else\n@@ -2966,6 +2966,17 @@ more_constrained (tree d1, tree d2)\n   return winner;\n }\n \n+/* Return whether D1 is at least as constrained as D2.  */\n+\n+bool\n+at_least_as_constrained (tree d1, tree d2)\n+{\n+  tree n1 = get_normalized_constraints_from_decl (d1);\n+  tree n2 = get_normalized_constraints_from_decl (d2);\n+\n+  return subsumes (n1, n2);\n+}\n+\n /*---------------------------------------------------------------------------\n                         Constraint diagnostics\n ---------------------------------------------------------------------------*/"}, {"sha": "fd3be60d407fa8ebb41c9a6d6c3a6a3851665a4c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f41df916c2d6d7598cb5e67cdaebdc86910e902/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f41df916c2d6d7598cb5e67cdaebdc86910e902/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1f41df916c2d6d7598cb5e67cdaebdc86910e902", "patch": "@@ -7772,7 +7772,8 @@ extern cp_expr finish_constraint_and_expr\t(location_t, cp_expr, cp_expr);\n extern cp_expr finish_constraint_primary_expr\t(cp_expr);\n extern tree finish_concept_definition\t\t(cp_expr, tree);\n extern tree combine_constraint_expressions      (tree, tree);\n-extern tree get_constraints                     (tree);\n+extern tree append_constraint\t\t\t(tree, tree);\n+extern tree get_constraints                     (const_tree);\n extern void set_constraints                     (tree, tree);\n extern void remove_constraints                  (tree);\n extern tree current_template_constraints\t(void);\n@@ -7834,6 +7835,7 @@ extern bool subsumes_constraints                (tree, tree);\n extern bool strictly_subsumes\t\t\t(tree, tree, tree);\n extern bool weakly_subsumes\t\t\t(tree, tree, tree);\n extern int more_constrained                     (tree, tree);\n+extern bool at_least_as_constrained             (tree, tree);\n extern bool constraints_equivalent_p            (tree, tree);\n extern bool atomic_constraints_identical_p\t(tree, tree);\n extern hashval_t iterative_hash_constraint      (tree, hashval_t);"}, {"sha": "909b2a4ef1d4110157a78380185077ecdfbbfe7e", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f41df916c2d6d7598cb5e67cdaebdc86910e902/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f41df916c2d6d7598cb5e67cdaebdc86910e902/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=1f41df916c2d6d7598cb5e67cdaebdc86910e902", "patch": "@@ -172,11 +172,11 @@ pp_cxx_unqualified_id (cxx_pretty_printer *pp, tree t)\n     case TYPENAME_TYPE:\n     case UNBOUND_CLASS_TEMPLATE:\n       pp_cxx_unqualified_id (pp, TYPE_NAME (t));\n-      if (CLASS_TYPE_P (t) && CLASSTYPE_USE_TEMPLATE (t))\n+      if (tree ti = TYPE_TEMPLATE_INFO_MAYBE_ALIAS (t))\n \t{\n \t  pp_cxx_begin_template_argument_list (pp);\n-\t  pp_cxx_template_argument_list (pp, INNERMOST_TEMPLATE_ARGS\n-                                                 (CLASSTYPE_TI_ARGS (t)));\n+\t  tree args = INNERMOST_TEMPLATE_ARGS (TI_ARGS (ti));\n+\t  pp_cxx_template_argument_list (pp, args);\n \t  pp_cxx_end_template_argument_list (pp);\n \t}\n       break;"}, {"sha": "c08b7b32a329e2c106c5c366393c866614a89715", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f41df916c2d6d7598cb5e67cdaebdc86910e902/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f41df916c2d6d7598cb5e67cdaebdc86910e902/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=1f41df916c2d6d7598cb5e67cdaebdc86910e902", "patch": "@@ -19901,14 +19901,6 @@ cp_parser_alias_declaration (cp_parser* parser)\n   if (decl == error_mark_node)\n     return decl;\n \n-  /* Attach constraints to the alias declaration.  */\n-  if (flag_concepts && current_template_parms)\n-    {\n-      tree reqs = TEMPLATE_PARMS_CONSTRAINTS (current_template_parms);\n-      tree constr = build_constraints (reqs, NULL_TREE);\n-      set_constraints (decl, constr);\n-    }\n-\n   cp_finish_decl (decl, NULL_TREE, 0, NULL_TREE, 0);\n \n   if (pushed_scope)"}, {"sha": "6e712bdb4e10f88adc36cb2d95464e20b0122326", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 46, "deletions": 7, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f41df916c2d6d7598cb5e67cdaebdc86910e902/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f41df916c2d6d7598cb5e67cdaebdc86910e902/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=1f41df916c2d6d7598cb5e67cdaebdc86910e902", "patch": "@@ -215,6 +215,7 @@ static tree listify_autos (tree, tree);\n static tree tsubst_template_parm (tree, tree, tsubst_flags_t);\n static tree instantiate_alias_template (tree, tree, tsubst_flags_t);\n static bool complex_alias_template_p (const_tree tmpl);\n+static tree get_underlying_template (tree);\n static tree tsubst_attributes (tree, tree, tsubst_flags_t, tree);\n static tree canonicalize_expr_argument (tree, tsubst_flags_t);\n static tree make_argument_pack (tree);\n@@ -5989,9 +5990,18 @@ push_template_decl_real (tree decl, bool is_friend)\n \t}\n \n       if (TREE_CODE (decl) == TYPE_DECL\n-\t  && TYPE_DECL_ALIAS_P (decl)\n-\t  && complex_alias_template_p (tmpl))\n-\tTEMPLATE_DECL_COMPLEX_ALIAS_P (tmpl) = true;\n+\t  && TYPE_DECL_ALIAS_P (decl))\n+\t{\n+\t  if (tree constr\n+\t      = TEMPLATE_PARMS_CONSTRAINTS (DECL_TEMPLATE_PARMS (tmpl)))\n+\t    {\n+\t      /* ??? Why don't we do this here for all templates?  */\n+\t      constr = build_constraints (constr, NULL_TREE);\n+\t      set_constraints (decl, constr);\n+\t    }\n+\t  if (complex_alias_template_p (tmpl))\n+\t    TEMPLATE_DECL_COMPLEX_ALIAS_P (tmpl) = true;\n+\t}\n     }\n \n   /* The DECL_TI_ARGS of DECL contains full set of arguments referring\n@@ -6350,6 +6360,14 @@ uses_all_template_parms_r (tree t, void *data_)\n static bool\n complex_alias_template_p (const_tree tmpl)\n {\n+  /* A renaming alias isn't complex.  */\n+  if (get_underlying_template (CONST_CAST_TREE (tmpl)) != tmpl)\n+    return false;\n+\n+  /* Any other constrained alias is complex.  */\n+  if (get_constraints (tmpl))\n+    return true;\n+\n   struct uses_all_template_parms_data data;\n   tree pat = DECL_ORIGINAL_TYPE (DECL_TEMPLATE_RESULT (tmpl));\n   tree parms = DECL_TEMPLATE_PARMS (tmpl);\n@@ -6395,7 +6413,7 @@ dependent_alias_template_spec_p (const_tree t, bool transparent_typedefs)\n /* Return the number of innermost template parameters in TMPL.  */\n \n static int\n-num_innermost_template_parms (tree tmpl)\n+num_innermost_template_parms (const_tree tmpl)\n {\n   tree parms = INNERMOST_TEMPLATE_PARMS (DECL_TEMPLATE_PARMS (tmpl));\n   return TREE_VEC_LENGTH (parms);\n@@ -6430,6 +6448,11 @@ get_underlying_template (tree tmpl)\n       if (!comp_template_args (TI_ARGS (tinfo), alias_args))\n \tbreak;\n \n+      /* If TMPL adds or changes any constraints, it isn't equivalent.  I think\n+\t it's appropriate to treat a less-constrained alias as equivalent.  */\n+      if (!at_least_as_constrained (underlying, tmpl))\n+\tbreak;\n+\n       /* Alias is equivalent.  Strip it and repeat.  */\n       tmpl = underlying;\n     }\n@@ -9679,7 +9702,9 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,\n          Note that the check is deferred until after the hash\n          lookup. This prevents redundant checks on previously\n          instantiated specializations. */\n-      if (flag_concepts && !constraints_satisfied_p (gen_tmpl, arglist))\n+      if (flag_concepts\n+\t  && !DECL_ALIAS_TEMPLATE_P (gen_tmpl)\n+\t  && !constraints_satisfied_p (gen_tmpl, arglist))\n         {\n           if (complain & tf_error)\n             {\n@@ -20499,15 +20524,29 @@ instantiate_alias_template (tree tmpl, tree args, tsubst_flags_t complain)\n {\n   if (tmpl == error_mark_node || args == error_mark_node)\n     return error_mark_node;\n-  if (!push_tinst_level (tmpl, args))\n-    return error_mark_node;\n \n   args =\n     coerce_innermost_template_parms (DECL_TEMPLATE_PARMS (tmpl),\n \t\t\t\t     args, tmpl, complain,\n \t\t\t\t     /*require_all_args=*/true,\n \t\t\t\t     /*use_default_args=*/true);\n \n+  /* FIXME check for satisfaction in check_instantiated_args.  */\n+  if (flag_concepts\n+      && !any_dependent_template_arguments_p (args)\n+      && !constraints_satisfied_p (tmpl, args))\n+    {\n+      if (complain & tf_error)\n+\t{\n+\t  auto_diagnostic_group d;\n+\t  error (\"template constraint failure for %qD\", tmpl);\n+\t  diagnose_constraints (input_location, tmpl, args);\n+\t}\n+      return error_mark_node;\n+    }\n+\n+  if (!push_tinst_level (tmpl, args))\n+    return error_mark_node;\n   tree r = instantiate_template (tmpl, args, complain);\n   pop_tinst_level ();\n "}, {"sha": "862879169fb763e9b95ccc2a4b6c94d4abc581cc", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-alias.C", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f41df916c2d6d7598cb5e67cdaebdc86910e902/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-alias.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f41df916c2d6d7598cb5e67cdaebdc86910e902/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-alias.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-alias.C?ref=1f41df916c2d6d7598cb5e67cdaebdc86910e902", "patch": "@@ -7,19 +7,14 @@ template<typename T>\n   requires Class<T>\n using X = T*;\n \n-// BUG: Alias templates are expanded at the point of use, regardless\n-// of whether or not they are dependent. This causes T* to be substituted\n-// without acutally checking the constraints. See the declaration of y1\n-// below.\n template<typename T>\n-using Y = X<T>;\n+using Y = X<T>;\t\t\t// { dg-error \"constraint\" }\n \n template<Class T> using Z = T*;\n \n struct S { };\n \n X<S> x1; // OK\n X<int> x2; // { dg-error \"template constraint failure\" }\n-Y<int> y1; // { dg-error \"\" \"\" { xfail *-*-* } }\n+Y<int> y1; // { dg-message \"\" }\n Z<S> z1; // ok\n-"}, {"sha": "02e960ad40a36d87d72e59af3b919be7bd21b67d", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-alias3.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f41df916c2d6d7598cb5e67cdaebdc86910e902/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-alias3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f41df916c2d6d7598cb5e67cdaebdc86910e902/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-alias3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-alias3.C?ref=1f41df916c2d6d7598cb5e67cdaebdc86910e902", "patch": "@@ -0,0 +1,10 @@\n+// { dg-do compile { target c++2a } }\n+\n+template <typename T> struct A { };\n+template <typename T> concept int_type = __is_same_as (T, int);\n+template <int_type T> using intA = A<T>;\n+\n+template <template <typename T> class TT> struct B {\n+  TT<char> tt;\t\t\t// { dg-error \"\" }\n+};\n+B<intA> b;"}, {"sha": "d37ce6a51e88b471d0682c44109b1ea2a4f53c36", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-alias4.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f41df916c2d6d7598cb5e67cdaebdc86910e902/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-alias4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f41df916c2d6d7598cb5e67cdaebdc86910e902/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-alias4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-alias4.C?ref=1f41df916c2d6d7598cb5e67cdaebdc86910e902", "patch": "@@ -0,0 +1,10 @@\n+// { dg-do compile { target c++2a } }\n+\n+template <typename T> struct A { };\n+template <typename T> concept int_type = __is_same_as (T, int);\n+template <int_type T> using intA = A<T>;\n+\n+template <class T> struct B {\n+  intA<T> a;\t\t\t// { dg-error \"\" }\n+};\n+B<char> b;"}]}