{"sha": "06772c7d0e9076d373ab6b1a623c617ea565b699", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDY3NzJjN2QwZTkwNzZkMzczYWI2YjFhNjIzYzYxN2VhNTY1YjY5OQ==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@albatross.co.nz", "date": "2000-06-28T06:03:11Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2000-06-28T06:03:11Z"}, "message": "ThreadGroup.java: Added synchronized flag to many methods.\n\n\t* ThreadGroup.java: Added synchronized flag to many methods.\n\t(destroyed_flag): Removed.\n\t(isDestroyed, removeGroup, removeThread): Test for parent == null.\n\t(activeCount): Added spec note.\n\nFrom-SVN: r34750", "tree": {"sha": "a7da1fb1b9f14b6cbbd85436ce63e1acdbc39b95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7da1fb1b9f14b6cbbd85436ce63e1acdbc39b95"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06772c7d0e9076d373ab6b1a623c617ea565b699", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06772c7d0e9076d373ab6b1a623c617ea565b699", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06772c7d0e9076d373ab6b1a623c617ea565b699", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06772c7d0e9076d373ab6b1a623c617ea565b699/comments", "author": null, "committer": null, "parents": [{"sha": "d9984f96fc77e17846ab30e756c2a4a7f00be258", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9984f96fc77e17846ab30e756c2a4a7f00be258", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9984f96fc77e17846ab30e756c2a4a7f00be258"}], "stats": {"total": 87, "additions": 51, "deletions": 36}, "files": [{"sha": "f2ba41e37d160b6f212bd92a72e3513e6c94adf6", "filename": "libjava/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06772c7d0e9076d373ab6b1a623c617ea565b699/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06772c7d0e9076d373ab6b1a623c617ea565b699/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=06772c7d0e9076d373ab6b1a623c617ea565b699", "patch": "@@ -1,3 +1,10 @@\n+2000-06-28  Bryce McKinlay  <bryce@albatross.co.nz>\n+\n+\t* ThreadGroup.java: Added synchronized flag to many methods.\n+\t(destroyed_flag): Removed.\n+\t(isDestroyed, removeGroup, removeThread): Test for parent == null.\t\n+\t(activeCount): Added spec note.\n+\n 2000-06-27  Warren Levy  <warrenl@cygnus.com>\n \n \t* java/security/Principal.java: New file."}, {"sha": "f566e106f176b61fe93a7ee60d7265b68c7c69fc", "filename": "libjava/java/lang/ThreadGroup.java", "status": "modified", "additions": 44, "deletions": 36, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06772c7d0e9076d373ab6b1a623c617ea565b699/libjava%2Fjava%2Flang%2FThreadGroup.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06772c7d0e9076d373ab6b1a623c617ea565b699/libjava%2Fjava%2Flang%2FThreadGroup.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FThreadGroup.java?ref=06772c7d0e9076d373ab6b1a623c617ea565b699", "patch": "@@ -31,8 +31,8 @@\n \n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n  * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Complete for 1.2.  Parts from the JDK 1.0 spec only are\n+ * plus online API docs for JDK 1.2 from http://www.javasoft.com.\n+ * Status:  Complete for 1.2.  Some parts from the JDK 1.0 spec only are\n  * not implemented. \n  */\n  \n@@ -44,7 +44,8 @@\n  *\n  * @author John Keiser\n  * @author Tom Tromey\n- * @version 1.2.0, June 20, 2000\n+ * @author Bryce McKinlay\n+ * @version 1.2.0\n  * @since JDK1.0\n  */\n \n@@ -58,7 +59,6 @@\n   private Vector threads = new Vector();\n   private Vector groups = new Vector();\n   private boolean daemon_flag = false;\n-  private boolean destroyed_flag = false;\n   private int maxpri = Thread.MAX_PRIORITY;\n \n   private ThreadGroup()\n@@ -87,7 +87,7 @@ public ThreadGroup(ThreadGroup parent, String name)\n   {\n     parent.checkAccess();\n     this.parent = parent;\n-    if (parent.destroyed_flag)\n+    if (parent.isDestroyed())\n       throw new IllegalArgumentException ();\n     this.name = name;\n     maxpri = parent.maxpri;\n@@ -118,7 +118,7 @@ public final ThreadGroup getParent()\n    *  @param maxpri the new maximum priority for this ThreadGroup.\n    *  @exception SecurityException if you cannoy modify this ThreadGroup.\n    */\n-  public final void setMaxPriority(int maxpri)\n+  public final synchronized void setMaxPriority(int maxpri)\n   {\n     checkAccess();\n     if (maxpri < this.maxpri\n@@ -168,9 +168,9 @@ public final boolean isDaemon()\n   /** Tell whether this ThreadGroup has been destroyed or not.\n     * @return whether this ThreadGroup has been destroyed or not.\n     */\n-  public boolean isDestroyed()\n+  public synchronized boolean isDestroyed()\n   {\n-    return destroyed_flag;\n+    return parent == null && this != root;\n   }\n \n   /** Check whether this ThreadGroup is an ancestor of the\n@@ -200,6 +200,13 @@ public final boolean parentOf(ThreadGroup tg)\n     *\n     * @return the number of active threads in this ThreadGroup and\n     *\t      its descendants.\n+    * @specnote it isn't clear what the definition of an \"Active\" thread is.\n+    *           Current JDKs regard all threads as active until they are \n+    *           finished, regardless of whether the thread has been started \n+    *           or not. We implement this behaviour.\n+    *           There is open JDC bug, <A HREF=\"http://developer.java.sun.com/developer/bugParade/bugs/4089701.html\">\n+    *           4089701</A>, regarding this issue.\n+    *           \n     */\n   public synchronized int activeCount()\n   {\n@@ -216,17 +223,17 @@ public synchronized int activeCount()\n     * itself is not included in the count.\n     * @specnote it is unclear what exactly constitutes an\n     *\t\tactive ThreadGroup.  Currently we assume that\n-    *\t\tall sub-groups are active.\n+    *\t\tall sub-groups are active, per current JDKs.\n     * @return the number of active groups in this ThreadGroup.\n     */\n-  public int activeGroupCount()\n+  public synchronized int activeGroupCount()\n   {\n     int total = groups.size();\n     for (int i=0; i < groups.size(); i++)\n       {\n \tThreadGroup g = (ThreadGroup) groups.elementAt(i);\n \ttotal += g.activeGroupCount();\n-      }      \n+      }\n     return total;\n   }\n \n@@ -240,7 +247,7 @@ public int activeGroupCount()\n     */\n   public int enumerate(Thread[] threads)\n   {\n-    return enumerate(threads, true);\n+    return enumerate(threads, 0, true);\n   }\n \n   /** Copy all of the active Threads from this ThreadGroup and,\n@@ -259,7 +266,8 @@ public int enumerate(Thread[] threads, boolean useDescendants)\n   }\n \n   // This actually implements enumerate.\n-  private int enumerate (Thread[] list, int next_index, boolean recurse)\n+  private synchronized int enumerate(Thread[] list, int next_index, \n+\t\t\t\t     boolean recurse)\n   {\n     Enumeration e = threads.elements();\n     while (e.hasMoreElements() && next_index < list.length)\n@@ -286,7 +294,7 @@ private int enumerate (Thread[] list, int next_index, boolean recurse)\n     */\n   public int enumerate(ThreadGroup[] groups)\n   {\n-    return enumerate(groups, false);\n+    return enumerate(groups, 0, true);\n   }\n \n   /** Copy all active ThreadGroups that are children of this\n@@ -296,18 +304,19 @@ public int enumerate(ThreadGroup[] groups)\n     * ThreadGroups simply will not be copied.\n     *\n     * @param groups the array to put the ThreadGroups into.\n-    * @param useDescendants whether to include all descendants\n+    * @param recurse whether to include all descendants\n     *\t     of this ThreadGroup's children in determining\n     *\t     activeness.\n     * @return the number of ThreadGroups copied into the array.\n     */\n-  public int enumerate(ThreadGroup[] groups, boolean useDescendants)\n+  public int enumerate(ThreadGroup[] groups, boolean recurse)\n   {\n-    return enumerate(groups, 0, useDescendants);\n+    return enumerate(groups, 0, recurse);\n   }\n \n   // This actually implements enumerate.\n-  private int enumerate (ThreadGroup[] list, int next_index, boolean recurse)\n+  private synchronized int enumerate (ThreadGroup[] list, int next_index, \n+\t\t\t\t      boolean recurse)\n   {\n     Enumeration e = groups.elements();\n     while (e.hasMoreElements() && next_index < list.length)\n@@ -326,7 +335,7 @@ private int enumerate (ThreadGroup[] list, int next_index, boolean recurse)\n     *\t\t ThreadGroups.\n     * @since JDK1.2\n     */\n-  public final void interrupt()\n+  public final synchronized void interrupt()\n   {\n     checkAccess();\n     for (int i=0; i < threads.size(); i++)\n@@ -347,7 +356,7 @@ public final void interrupt()\n     *\t\t ThreadGroups.\n     * @deprecated This method calls Thread.stop(), which is dangerous.\n     */\n-  public final void stop()\n+  public final synchronized void stop()\n   {\n     checkAccess();\n     for (int i=0; i<threads.size(); i++)\n@@ -368,7 +377,7 @@ public final void stop()\n     *\t\t ThreadGroups.\n     * @deprecated This method calls Thread.suspend(), which is dangerous.\n     */\n-  public final void suspend()\n+  public final synchronized void suspend()\n   {\n     checkAccess();\n     for (int i=0; i<threads.size(); i++)\n@@ -389,7 +398,7 @@ public final void suspend()\n     *\t\t ThreadGroups.\n     * @deprecated This method relies on Thread.suspend(), which is dangerous.\n     */\n-  public final void resume()\n+  public final synchronized void resume()\n   {\n     checkAccess();\n     for (int i=0; i < threads.size(); i++)\n@@ -405,7 +414,7 @@ public final void resume()\n   }\n \n   // This is a helper that is used to implement the destroy method.\n-  private final void checkDestroy ()\n+  private synchronized void checkDestroy ()\n   {\n     if (! threads.isEmpty())\n       throw new IllegalThreadStateException (\"ThreadGroup has threads\");\n@@ -425,15 +434,14 @@ private final void checkDestroy ()\n     * @exception SecurityException if you cannot modify this\n     *\t\t ThreadGroup or any of its descendants.\n     */\n-  public final void destroy()\n+  public final synchronized void destroy()\n   {\n     checkAccess();\n-    if (destroyed_flag)\n+    if (isDestroyed())\n       throw new IllegalThreadStateException(\"Already destroyed.\");\n     checkDestroy ();\n     if (parent != null)\n       parent.removeGroup(this);\n-    destroyed_flag = true;\n     parent = null;\n \n     for (int i=0; i < groups.size(); i++)\n@@ -450,7 +458,7 @@ public void list()\n     list(\"\");\n   }\n \n-  private final void list (String indentation)\n+  private synchronized void list(String indentation)\n   {\n     System.out.print(indentation);\n     System.out.println(toString ());\n@@ -531,18 +539,18 @@ public final void checkAccess()\n   }\n \n   // This is called to add a Thread to our internal list.\n-  final void addThread(Thread t)\n+  final synchronized void addThread(Thread t)\n   {\n-    if (destroyed_flag)\n+    if (isDestroyed())\n       throw new IllegalThreadStateException (\"ThreadGroup is destroyed\");\n   \n     threads.addElement(t);\n   }\n \n   // This is called to remove a Thread from our internal list.\n-  final void removeThread(Thread t)\n+  final synchronized void removeThread(Thread t)\n   {\n-    if (destroyed_flag)\n+    if (isDestroyed())\n       throw new IllegalThreadStateException ();\n   \n     threads.removeElement(t);\n@@ -552,27 +560,27 @@ final void removeThread(Thread t)\n \t// We inline destroy to avoid the access check.\n \tif (parent != null)\n \t  parent.removeGroup(this);\n-\tdestroyed_flag = true;\n+\tparent = null;\n       }\n   }\n \n   // This is called to add a ThreadGroup to our internal list.\n-  final void addGroup(ThreadGroup g)\n+  final synchronized void addGroup(ThreadGroup g)\n   {\n     groups.addElement(g);\n   }\n \n   // This is called to remove a ThreadGroup from our internal list.\n-  final void removeGroup(ThreadGroup g)\n+  final synchronized void removeGroup(ThreadGroup g)\n   {\n     groups.removeElement(g);\n     // Daemon groups are automatically destroyed when all their threads die.\n     if (daemon_flag && groups.size() == 0 && threads.size() == 0)\n       {\n \t// We inline destroy to avoid the access check.\n \tif (parent != null)\n-\t  parent.removeGroup(this);\t\n-\tdestroyed_flag = true;\n+\t  parent.removeGroup(this);\n+\tparent = null;\n       }\n   }\n }"}]}