{"sha": "c5274326e08088f3fddff1f94e035a0352362fd0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzUyNzQzMjZlMDgwODhmM2ZkZGZmMWY5NGUwMzVhMDM1MjM2MmZkMA==", "commit": {"author": {"name": "Thomas Neumann", "email": "tneumann@users.sourceforge.net", "date": "2007-06-30T10:52:30Z"}, "committer": {"name": "Thomas Neumann", "email": "tneumann@gcc.gnu.org", "date": "2007-06-30T10:52:30Z"}, "message": "ipa.c (cgraph_postorder): Cast according to the coding conventions.\n\n\t* ipa.c (cgraph_postorder): Cast according to the coding conventions.\n\t(cgraph_remove_unreachable_nodes): Likewise.\n\t* ipa-cp.c (ipcp_propagate_stage): Use BOTTOM instead of integer 0.\n\t* ipa-inline.c (update_caller_keys): Cast according to the coding\n\tconventions.\n\t(cgraph_decide_recursive_inlining): Likewise.\n\t(cgraph_decide_inlining_of_small_function): Likewise.\n\t(try_inline): Likewise.\n\t(cgraph_decide_inlining_incrementally): Likewise.\n\t* ipa-pure-const.c (get_function_state): Likewise.\n\t(scan_function): Likewise.\n\t(analyze_function): Likewise.\n \t(static_execute): Likewise.\n\t* gcc/ipa-reference.c (scan_for_static_refs): Likewise.\n\t(merge_callee_local_info): Likewise.\n\t(analyze_function): Use type safe memory macros.\n\t(static_execute): Likewise. Cast according to the coding conventions.\n\t* ipa-type-escape.c (scan_for_regs): Cast according to the coding\n\tconventions.\n\t* ipa-utils.c (searchc): Likewise. Avoid using C++ keywords as variable\n\tnames.\n\t(ipa_utils_reduced_inorder): Likewise. Use type safe memory macros.\n\t* ipa-utils.h (struct ipa_dfa_info): Avoid using C++ keywords as\n\tvariable names.\n\nFrom-SVN: r126140", "tree": {"sha": "8419d77742232e2a832b7b3fc66904637698ca40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8419d77742232e2a832b7b3fc66904637698ca40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5274326e08088f3fddff1f94e035a0352362fd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5274326e08088f3fddff1f94e035a0352362fd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5274326e08088f3fddff1f94e035a0352362fd0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5274326e08088f3fddff1f94e035a0352362fd0/comments", "author": {"login": "neumannt", "id": 25097991, "node_id": "MDQ6VXNlcjI1MDk3OTkx", "avatar_url": "https://avatars.githubusercontent.com/u/25097991?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neumannt", "html_url": "https://github.com/neumannt", "followers_url": "https://api.github.com/users/neumannt/followers", "following_url": "https://api.github.com/users/neumannt/following{/other_user}", "gists_url": "https://api.github.com/users/neumannt/gists{/gist_id}", "starred_url": "https://api.github.com/users/neumannt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neumannt/subscriptions", "organizations_url": "https://api.github.com/users/neumannt/orgs", "repos_url": "https://api.github.com/users/neumannt/repos", "events_url": "https://api.github.com/users/neumannt/events{/privacy}", "received_events_url": "https://api.github.com/users/neumannt/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "23512eb32c50149c0096a77726edb1220a816cdc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23512eb32c50149c0096a77726edb1220a816cdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23512eb32c50149c0096a77726edb1220a816cdc"}], "stats": {"total": 121, "additions": 75, "deletions": 46}, "files": [{"sha": "047c18ff7c3bf6c5eee36f21c5722c2837a3eab1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5274326e08088f3fddff1f94e035a0352362fd0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5274326e08088f3fddff1f94e035a0352362fd0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c5274326e08088f3fddff1f94e035a0352362fd0", "patch": "@@ -1,3 +1,30 @@\n+2006-06-30  Thomas Neumann  <tneumann@users.sourceforge.net>\n+\n+\t* ipa.c (cgraph_postorder): Cast according to the coding conventions.\n+\t(cgraph_remove_unreachable_nodes): Likewise.\n+\t* ipa-cp.c (ipcp_propagate_stage): Use BOTTOM instead of integer 0.\n+\t* ipa-inline.c (update_caller_keys): Cast according to the coding\n+\tconventions.\n+\t(cgraph_decide_recursive_inlining): Likewise.\n+\t(cgraph_decide_inlining_of_small_function): Likewise.\n+\t(try_inline): Likewise.\n+\t(cgraph_decide_inlining_incrementally): Likewise.\n+\t* ipa-pure-const.c (get_function_state): Likewise.\n+\t(scan_function): Likewise.\n+\t(analyze_function): Likewise.\n+ \t(static_execute): Likewise.\n+\t* gcc/ipa-reference.c (scan_for_static_refs): Likewise.\n+\t(merge_callee_local_info): Likewise.\n+\t(analyze_function): Use type safe memory macros.\n+\t(static_execute): Likewise. Cast according to the coding conventions.\n+\t* ipa-type-escape.c (scan_for_regs): Cast according to the coding\n+\tconventions.\n+\t* ipa-utils.c (searchc): Likewise. Avoid using C++ keywords as variable\n+\tnames.\n+\t(ipa_utils_reduced_inorder): Likewise. Use type safe memory macros.\n+\t* ipa-utils.h (struct ipa_dfa_info): Avoid using C++ keywords as\n+\tvariable names.\n+\n 2007-06-29  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \tPR middle-end/30024"}, {"sha": "fe34881372601ff976d740dbcda09f6bac0e250b", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5274326e08088f3fddff1f94e035a0352362fd0/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5274326e08088f3fddff1f94e035a0352362fd0/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=c5274326e08088f3fddff1f94e035a0352362fd0", "patch": "@@ -570,7 +570,7 @@ static void\n ipcp_propagate_stage (void)\n {\n   int i;\n-  struct ipcp_formal cval1 = { 0, {0} }, cval = { 0,{0} };\n+  struct ipcp_formal cval1 = { BOTTOM, {0} }, cval = { BOTTOM, {0} };\n   struct ipcp_formal *cval2;\n   struct cgraph_node *mt, *callee;\n   struct cgraph_edge *cs;"}, {"sha": "cd7d2aff5625a723d10611e89852f9e1caecd34b", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5274326e08088f3fddff1f94e035a0352362fd0/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5274326e08088f3fddff1f94e035a0352362fd0/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=c5274326e08088f3fddff1f94e035a0352362fd0", "patch": "@@ -583,7 +583,7 @@ update_caller_keys (fibheap_t heap, struct cgraph_node *node,\n       for (edge = node->callers; edge; edge = edge->next_caller)\n \tif (edge->aux)\n \t  {\n-\t    fibheap_delete_node (heap, edge->aux);\n+\t    fibheap_delete_node (heap, (fibnode_t) edge->aux);\n \t    edge->aux = NULL;\n \t    if (edge->inline_failed)\n \t      edge->inline_failed = failed_reason;\n@@ -597,15 +597,15 @@ update_caller_keys (fibheap_t heap, struct cgraph_node *node,\n \tint badness = cgraph_edge_badness (edge);\n \tif (edge->aux)\n \t  {\n-\t    fibnode_t n = edge->aux;\n+\t    fibnode_t n = (fibnode_t) edge->aux;\n \t    gcc_assert (n->data == edge);\n \t    if (n->key == badness)\n \t      continue;\n \n \t    /* fibheap_replace_key only increase the keys.  */\n \t    if (fibheap_replace_key (heap, n, badness))\n \t      continue;\n-\t    fibheap_delete_node (heap, edge->aux);\n+\t    fibheap_delete_node (heap, (fibnode_t) edge->aux);\n \t  }\n \tedge->aux = fibheap_insert (heap, badness, edge);\n       }\n@@ -705,7 +705,8 @@ cgraph_decide_recursive_inlining (struct cgraph_node *node)\n \t && (cgraph_estimate_size_after_inlining (1, node, master_clone)\n \t     <= limit))\n     {\n-      struct cgraph_edge *curr = fibheap_extract_min (heap);\n+      struct cgraph_edge *curr\n+\t= (struct cgraph_edge *) fibheap_extract_min (heap);\n       struct cgraph_node *cnode;\n \n       depth = 1;\n@@ -856,7 +857,8 @@ cgraph_decide_inlining_of_small_functions (void)\n   max_insns = compute_max_insns (overall_insns);\n   min_insns = overall_insns;\n \n-  while (overall_insns <= max_insns && (edge = fibheap_extract_min (heap)))\n+  while (overall_insns <= max_insns\n+\t && (edge = (struct cgraph_edge *) fibheap_extract_min (heap)))\n     {\n       int old_insns = overall_insns;\n       struct cgraph_node *where;\n@@ -994,7 +996,7 @@ cgraph_decide_inlining_of_small_functions (void)\n \t    fprintf (dump_file, \"New minimal insns reached: %i\\n\", min_insns);\n \t}\n     }\n-  while ((edge = fibheap_extract_min (heap)) != NULL)\n+  while ((edge = (struct cgraph_edge *) fibheap_extract_min (heap)) != NULL)\n     {\n       gcc_assert (edge->aux);\n       edge->aux = NULL;\n@@ -1182,7 +1184,7 @@ static bool\n try_inline (struct cgraph_edge *e, enum inlining_mode mode, int depth)\n {\n   struct cgraph_node *callee = e->callee;\n-  enum inlining_mode callee_mode = (size_t) callee->aux;\n+  enum inlining_mode callee_mode = (enum inlining_mode) (size_t) callee->aux;\n   bool always_inline = e->callee->local.disregard_inline_limits;\n \n   /* We've hit cycle?  */\n@@ -1259,7 +1261,7 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n   verify_cgraph_node (node);\n #endif\n \n-  old_mode = (size_t)node->aux;\n+  old_mode = (enum inlining_mode) (size_t)node->aux;\n \n   if (mode != INLINE_ALWAYS_INLINE\n       && lookup_attribute (\"flatten\", DECL_ATTRIBUTES (node->decl)) != NULL)"}, {"sha": "b710bf0ea0e6ed1a9e83cffd2390de1bc459ce80", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5274326e08088f3fddff1f94e035a0352362fd0/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5274326e08088f3fddff1f94e035a0352362fd0/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=c5274326e08088f3fddff1f94e035a0352362fd0", "patch": "@@ -80,8 +80,8 @@ typedef struct funct_state_d * funct_state;\n static inline funct_state\n get_function_state (struct cgraph_node *node)\n {\n-  struct ipa_dfs_info * info = node->aux;\n-  return info->aux;\n+  struct ipa_dfs_info * info = (struct ipa_dfs_info *) node->aux;\n+  return (funct_state) info->aux;\n }\n \n /* Check to see if the use (or definition when CHECHING_WRITE is true) \n@@ -396,7 +396,7 @@ scan_function (tree *tp,\n \t\t      int *walk_subtrees, \n \t\t      void *data)\n {\n-  struct cgraph_node *fn = data;\n+  struct cgraph_node *fn = (struct cgraph_node *) data;\n   tree t = *tp;\n   funct_state local = get_function_state (fn);\n \n@@ -505,7 +505,7 @@ analyze_function (struct cgraph_node *fn)\n {\n   funct_state l = XCNEW (struct funct_state_d);\n   tree decl = fn->decl;\n-  struct ipa_dfs_info * w_info = fn->aux;\n+  struct ipa_dfs_info * w_info = (struct ipa_dfs_info *) fn->aux;\n \n   w_info->aux = l;\n \n@@ -602,7 +602,7 @@ static_execute (void)\n   struct cgraph_node *w;\n   struct cgraph_node **order =\n     XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n-  int order_pos = order_pos = ipa_utils_reduced_inorder (order, true, false);\n+  int order_pos = ipa_utils_reduced_inorder (order, true, false);\n   int i;\n   struct ipa_dfs_info * w_info;\n \n@@ -673,7 +673,7 @@ static_execute (void)\n \t\t    }\n \t\t}\n \t    }\n-\t  w_info = w->aux;\n+\t  w_info = (struct ipa_dfs_info *) w->aux;\n \t  w = w_info->next_cycle;\n \t}\n \n@@ -708,7 +708,7 @@ static_execute (void)\n \t\t  break;\n \t\t}\n \t    }\n-\t  w_info = w->aux;\n+\t  w_info = (struct ipa_dfs_info *) w->aux;\n \t  w = w_info->next_cycle;\n \t}\n     }\n@@ -718,7 +718,7 @@ static_execute (void)\n     /* Get rid of the aux information.  */\n     if (node->aux)\n       {\n-\tw_info = node->aux;\n+\tw_info = (struct ipa_dfs_info *) node->aux;\n \tif (w_info->aux)\n \t  free (w_info->aux);\n \tfree (node->aux);"}, {"sha": "62b1c1dd1a4f21110644e97aed88aa68ff614127", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5274326e08088f3fddff1f94e035a0352362fd0/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5274326e08088f3fddff1f94e035a0352362fd0/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=c5274326e08088f3fddff1f94e035a0352362fd0", "patch": "@@ -475,7 +475,7 @@ scan_for_static_refs (tree *tp,\n \t\t      int *walk_subtrees, \n \t\t      void *data)\n {\n-  struct cgraph_node *fn = data;\n+  struct cgraph_node *fn = (struct cgraph_node *) data;\n   tree t = *tp;\n   ipa_reference_local_vars_info_t local = NULL;\n   if (fn)\n@@ -692,7 +692,7 @@ merge_callee_local_info (struct cgraph_node *target,\n     get_reference_vars_info_from_cgraph (target)->local;\n \n   /* Make the world safe for tail recursion.  */\n-  struct ipa_dfs_info *node_info = x->aux;\n+  struct ipa_dfs_info *node_info = (struct ipa_dfs_info *) x->aux;\n   \n   if (node_info->aux) \n     return;\n@@ -787,9 +787,9 @@ static void\n analyze_function (struct cgraph_node *fn)\n {\n   ipa_reference_vars_info_t info \n-    = xcalloc (1, sizeof (struct ipa_reference_vars_info_d));\n+    = XCNEW (struct ipa_reference_vars_info_d);\n   ipa_reference_local_vars_info_t l\n-    = xcalloc (1, sizeof (struct ipa_reference_local_vars_info_d));\n+    = XCNEW (struct ipa_reference_local_vars_info_d);\n   tree decl = fn->decl;\n \n   /* Add the info to the tree's annotation.  */\n@@ -908,8 +908,8 @@ static_execute (void)\n   struct varpool_node *vnode;\n   struct cgraph_node *w;\n   struct cgraph_node **order =\n-    xcalloc (cgraph_n_nodes, sizeof (struct cgraph_node *));\n-  int order_pos = order_pos = ipa_utils_reduced_inorder (order, false, true);\n+    XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n+  int order_pos = ipa_utils_reduced_inorder (order, false, true);\n   int i;\n \n   ipa_init ();\n@@ -1080,7 +1080,7 @@ static_execute (void)\n     {\n       ipa_reference_vars_info_t node_info;\n       ipa_reference_global_vars_info_t node_g = \n-\txcalloc (1, sizeof (struct ipa_reference_global_vars_info_d));\n+\tXCNEW (struct ipa_reference_global_vars_info_d);\n       ipa_reference_local_vars_info_t node_l;\n       \n       bool read_all;\n@@ -1104,7 +1104,7 @@ static_execute (void)\n \n       /* If any node in a cycle is calls_read_all or calls_write_all\n \t they all are. */\n-      w_info = node->aux;\n+      w_info = (struct ipa_dfs_info *) node->aux;\n       w = w_info->next_cycle;\n       while (w)\n \t{\n@@ -1113,7 +1113,7 @@ static_execute (void)\n \t  read_all |= w_l->calls_read_all;\n \t  write_all |= w_l->calls_write_all;\n \n-\t  w_info = w->aux;\n+\t  w_info = (struct ipa_dfs_info *) w->aux;\n \t  w = w_info->next_cycle;\n \t}\n \n@@ -1136,7 +1136,7 @@ static_execute (void)\n \t\t       node_l->statics_written);\n \t}\n \n-      w_info = node->aux;\n+      w_info = (struct ipa_dfs_info *) node->aux;\n       w = w_info->next_cycle;\n       while (w)\n \t{\n@@ -1157,15 +1157,15 @@ static_execute (void)\n \t  if (!write_all)\n \t    bitmap_ior_into (node_g->statics_written,\n \t\t\t     w_l->statics_written);\n-\t  w_info = w->aux;\n+\t  w_info = (struct ipa_dfs_info *) w->aux;\n \t  w = w_info->next_cycle;\n \t}\n \n       w = node;\n       while (w)\n \t{\n \t  propagate_bits (w);\n-\t  w_info = w->aux;\n+\t  w_info = (struct ipa_dfs_info *) w->aux;\n \t  w = w_info->next_cycle;\n \t}\n     }\n@@ -1182,12 +1182,12 @@ static_execute (void)\n       node = order[i];\n       merge_callee_local_info (node, node);\n       \n-      w_info = node->aux;\n+      w_info = (struct ipa_dfs_info *) node->aux;\n       w = w_info->next_cycle;\n       while (w)\n \t{\n \t  merge_callee_local_info (w, w);\n-\t  w_info = w->aux;\n+\t  w_info = (struct ipa_dfs_info *) w->aux;\n \t  w = w_info->next_cycle;\n \t}\n     }\n@@ -1225,7 +1225,7 @@ static_execute (void)\n \t\t      get_static_name (index));\n \t    }\n \n-\t  w_info = node->aux;\n+\t  w_info = (struct ipa_dfs_info *) node->aux;\n \t  w = w_info->next_cycle;\n \t  while (w) \n \t    {\n@@ -1251,7 +1251,7 @@ static_execute (void)\n \t\t}\n \t      \n \n-\t      w_info = w->aux;\n+\t      w_info = (struct ipa_dfs_info *) w->aux;\n \t      w = w_info->next_cycle;\n \t    }\n \t  fprintf (dump_file, \"\\n  globals read: \");"}, {"sha": "a2d459ab6902f8a1a2c0fa36f869cb23fb7f6d65", "filename": "gcc/ipa-type-escape.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5274326e08088f3fddff1f94e035a0352362fd0/gcc%2Fipa-type-escape.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5274326e08088f3fddff1f94e035a0352362fd0/gcc%2Fipa-type-escape.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-type-escape.c?ref=c5274326e08088f3fddff1f94e035a0352362fd0", "patch": "@@ -1499,7 +1499,7 @@ okay_pointer_operation (enum tree_code code, tree op0, tree op1)\n static tree\n scan_for_refs (tree *tp, int *walk_subtrees, void *data)\n {\n-  struct cgraph_node *fn = data;\n+  struct cgraph_node *fn = (struct cgraph_node *) data;\n   tree t = *tp;\n \n   switch (TREE_CODE (t))  "}, {"sha": "8b7aeafa9672b0729fc3d82482433eeed8816a60", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5274326e08088f3fddff1f94e035a0352362fd0/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5274326e08088f3fddff1f94e035a0352362fd0/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=c5274326e08088f3fddff1f94e035a0352362fd0", "patch": "@@ -86,10 +86,10 @@ static void\n searchc (struct searchc_env* env, struct cgraph_node *v) \n {\n   struct cgraph_edge *edge;\n-  struct ipa_dfs_info *v_info = v->aux;\n+  struct ipa_dfs_info *v_info = (struct ipa_dfs_info *) v->aux;\n   \n   /* mark node as old */\n-  v_info->new = false;\n+  v_info->new_node = false;\n   splay_tree_remove (env->nodes_marked_new, v->uid);\n   \n   v_info->dfn_number = env->count;\n@@ -107,8 +107,8 @@ searchc (struct searchc_env* env, struct cgraph_node *v)\n       w = cgraph_master_clone (w);\n       if (w && w->aux) \n \t{\n-\t  w_info = w->aux;\n-\t  if (w_info->new) \n+\t  w_info = (struct ipa_dfs_info *) w->aux;\n+\t  if (w_info->new_node) \n \t    {\n \t      searchc (env, w);\n \t      v_info->low_link =\n@@ -132,7 +132,7 @@ searchc (struct searchc_env* env, struct cgraph_node *v)\n       struct ipa_dfs_info *x_info;\n       do {\n \tx = env->stack[--(env->stack_size)];\n-\tx_info = x->aux;\n+\tx_info = (struct ipa_dfs_info *) x->aux;\n \tx_info->on_stack = false;\n \t\n \tif (env->reduce) \n@@ -177,10 +177,10 @@ ipa_utils_reduced_inorder (struct cgraph_node **order,\n \t\t AVAIL_OVERWRITABLE))))\n       {\n \t/* Reuse the info if it is already there.  */\n-\tstruct ipa_dfs_info *info = node->aux;\n+\tstruct ipa_dfs_info *info = (struct ipa_dfs_info *) node->aux;\n \tif (!info)\n-\t  info = xcalloc (1, sizeof (struct ipa_dfs_info));\n-\tinfo->new = true;\n+\t  info = XCNEW (struct ipa_dfs_info);\n+\tinfo->new_node = true;\n \tinfo->on_stack = false;\n \tinfo->next_cycle = NULL;\n \tnode->aux = info;"}, {"sha": "25293f5a60208bf6937d8f2942e10c1efde8e2d2", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5274326e08088f3fddff1f94e035a0352362fd0/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5274326e08088f3fddff1f94e035a0352362fd0/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=c5274326e08088f3fddff1f94e035a0352362fd0", "patch": "@@ -30,7 +30,7 @@ extern tree memory_identifier_string;\n struct ipa_dfs_info {\n   int dfn_number;\n   int low_link;\n-  bool new;\n+  bool new_node;\n   bool on_stack;\n   struct cgraph_node* next_cycle;\n   PTR aux;"}, {"sha": "5326af659a01cabf38fec6736b9a2849b89fecec", "filename": "gcc/ipa.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5274326e08088f3fddff1f94e035a0352362fd0/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5274326e08088f3fddff1f94e035a0352362fd0/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=c5274326e08088f3fddff1f94e035a0352362fd0", "patch": "@@ -58,7 +58,7 @@ cgraph_postorder (struct cgraph_node **order)\n \t  {\n \t    while (node2->aux != &last)\n \t      {\n-\t\tedge = node2->aux;\n+\t\tedge = (struct cgraph_edge *) node2->aux;\n \t\tif (edge->next_caller)\n \t\t  node2->aux = edge->next_caller;\n \t\telse\n@@ -98,7 +98,7 @@ cgraph_postorder (struct cgraph_node **order)\n bool\n cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n {\n-  struct cgraph_node *first = (void *) 1;\n+  struct cgraph_node *first = (struct cgraph_node *) (void *) 1;\n   struct cgraph_node *node, *next;\n   bool changed = false;\n   int insns = 0;\n@@ -131,7 +131,7 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n     {\n       struct cgraph_edge *e;\n       node = first;\n-      first = first->aux;\n+      first = (struct cgraph_node *) first->aux;\n \n       for (e = node->callees; e; e = e->next_callee)\n \tif (!e->callee->aux"}]}