{"sha": "fd59e3a04e282342dc4d5ab878a2df37bd44e2a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQ1OWUzYTA0ZTI4MjM0MmRjNGQ1YWI4NzhhMmRmMzdiZDQ0ZTJhOA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "1999-09-08T00:43:06Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-09-08T00:43:06Z"}, "message": "posix-threads.cc (_Jv_CondWait): Check `errno' against EINTR, not `r'.\n\n1999-09-07  Tom Tromey  <tromey@cygnus.com>\n\n\t* posix-threads.cc (_Jv_CondWait): Check `errno' against EINTR,\n\tnot `r'.  Changed `done_sleeping' to a `bool'.\n\n1999-09-07  Matt Welsh <mdw@cs.berkeley.edu\n\n\t* libjava/posix-threads.cc: Added _Jv_ThreadDataKey.\n\tAdded FLAG_INTERRUPTED to indicate that a thread was interrupted\n\tby another thread, rather than by the GC.\n\t(_Jv_CondWait): Prevent premature thread wakeup by GC.\n\t(_Jv_InitThreads): Initialize _Jv_ThreadDataKey.\n\t* libjava/include/posix-threads.h (_Jv_ThreadCurrentData): New\n\tfunction.\n\nFrom-SVN: r29177", "tree": {"sha": "0340cef1b68eb2b2d979c8dc372792f40a424945", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0340cef1b68eb2b2d979c8dc372792f40a424945"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd59e3a04e282342dc4d5ab878a2df37bd44e2a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd59e3a04e282342dc4d5ab878a2df37bd44e2a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd59e3a04e282342dc4d5ab878a2df37bd44e2a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd59e3a04e282342dc4d5ab878a2df37bd44e2a8/comments", "author": null, "committer": null, "parents": [{"sha": "d07d525a85f68646d68a5a2bc6c885894674ebc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d07d525a85f68646d68a5a2bc6c885894674ebc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d07d525a85f68646d68a5a2bc6c885894674ebc3"}], "stats": {"total": 86, "additions": 77, "deletions": 9}, "files": [{"sha": "401462028380470dc4658be736ac01c954f72d70", "filename": "libjava/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd59e3a04e282342dc4d5ab878a2df37bd44e2a8/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd59e3a04e282342dc4d5ab878a2df37bd44e2a8/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=fd59e3a04e282342dc4d5ab878a2df37bd44e2a8", "patch": "@@ -1,3 +1,18 @@\n+1999-09-07  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* posix-threads.cc (_Jv_CondWait): Check `errno' against EINTR,\n+\tnot `r'.  Changed `done_sleeping' to a `bool'.\n+\n+1999-09-07  Matt Welsh <mdw@cs.berkeley.edu\n+\n+\t* libjava/posix-threads.cc: Added _Jv_ThreadDataKey.\n+\tAdded FLAG_INTERRUPTED to indicate that a thread was interrupted\n+\tby another thread, rather than by the GC.\n+\t(_Jv_CondWait): Prevent premature thread wakeup by GC.\n+\t(_Jv_InitThreads): Initialize _Jv_ThreadDataKey.\n+\t* libjava/include/posix-threads.h (_Jv_ThreadCurrentData): New \n+\tfunction.\n+\n 1999-09-03  Tom Tromey  <tromey@cygnus.com>\n \n \t* configure: Rebuilt."}, {"sha": "cc8493a4f3ed671feda44c836aa0937ee5f71197", "filename": "libjava/include/posix-threads.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd59e3a04e282342dc4d5ab878a2df37bd44e2a8/libjava%2Finclude%2Fposix-threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd59e3a04e282342dc4d5ab878a2df37bd44e2a8/libjava%2Finclude%2Fposix-threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fposix-threads.h?ref=fd59e3a04e282342dc4d5ab878a2df37bd44e2a8", "patch": "@@ -249,6 +249,13 @@ _Jv_ThreadCurrent (void)\n   return (java::lang::Thread *) pthread_getspecific (_Jv_ThreadKey);\n }\n \n+inline _Jv_Thread_t *\n+_Jv_ThreadCurrentData (void)\n+{\n+  extern pthread_key_t _Jv_ThreadDataKey;\n+  return (_Jv_Thread_t *) pthread_getspecific (_Jv_ThreadDataKey);\n+}\n+\n inline void\n _Jv_ThreadYield (void)\n {"}, {"sha": "50c626fccac924b31e373f8a1aa4791c5ba851ec", "filename": "libjava/posix-threads.cc", "status": "modified", "additions": 55, "deletions": 9, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd59e3a04e282342dc4d5ab878a2df37bd44e2a8/libjava%2Fposix-threads.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd59e3a04e282342dc4d5ab878a2df37bd44e2a8/libjava%2Fposix-threads.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fposix-threads.cc?ref=fd59e3a04e282342dc4d5ab878a2df37bd44e2a8", "patch": "@@ -46,6 +46,10 @@ struct starter\n // threads, so it is ok to make it a global here.\n pthread_key_t _Jv_ThreadKey;\n \n+// This is the key used to map from the POSIX thread value back to the\n+// _Jv_Thread_t* representing the thread.\n+pthread_key_t _Jv_ThreadDataKey;\n+\n // We keep a count of all non-daemon threads which are running.  When\n // this reaches zero, _Jv_ThreadWait returns.\n static pthread_mutex_t daemon_mutex;\n@@ -68,6 +72,8 @@ static int non_daemon_count;\n #define FLAG_START   0x01\n // Thread is daemon.\n #define FLAG_DAEMON  0x02\n+// Thread was interrupted by _Jv_ThreadInterrupt.\n+#define FLAG_INTERRUPTED  0x04\n \n \f\n \n@@ -80,20 +86,57 @@ _Jv_CondWait (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *mu,\n \n   int r;\n   pthread_mutex_t *pmu = _Jv_PthreadGetMutex (mu);\n+  struct timespec ts; \n+  jlong m, m2, startTime;\n+  bool done_sleeping = false;\n \n   if (millis == 0 && nanos == 0)\n     r = pthread_cond_wait (cv, pmu);\n   else\n     {\n-      struct timespec ts; \n-      jlong m = millis + java::lang::System::currentTimeMillis (); \n-      ts.tv_sec = m / 1000; \n-      ts.tv_nsec = ((m % 1000) * 1000000) + nanos; \n-             \n-      r = pthread_cond_timedwait (cv, pmu, &ts);\n-      /* A timeout is a normal result.  */\n-      if (r && errno == ETIMEDOUT)\n-\tr = 0;\n+      startTime = java::lang::System::currentTimeMillis();\n+      m = millis + startTime;\n+\n+      do\n+\t{  \n+\t  ts.tv_sec = m / 1000; \n+\t  ts.tv_nsec = ((m % 1000) * 1000000) + nanos; \n+\n+\t  r = pthread_cond_timedwait (cv, pmu, &ts);\n+\n+\t  if (r && errno == EINTR)\n+\t    {\n+\t      /* We were interrupted by a signal.  Either this is\n+\t\t because we were interrupted intentionally (i.e. by\n+\t\t Thread.interrupt()) or by the GC if it is\n+\t\t signal-based.  */\n+\t      _Jv_Thread_t *current = _Jv_ThreadCurrentData();\n+\t      if (current->flags & FLAG_INTERRUPTED)\n+\t\t{\n+                  current->flags &= ~(FLAG_INTERRUPTED);\n+                  done_sleeping = true;\n+                }\n+\t      else\n+                {\n+\t\t  /* We were woken up by the GC or another signal.  */\n+\t\t  m2 = java::lang::System::currentTimeMillis ();\n+\t\t  if (m2 >= m)\n+\t\t    {\n+\t\t      r = 0;\n+\t\t      done_sleeping = true;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  else if (r && errno == ETIMEDOUT)\n+\t    {\n+\t      /* A timeout is a normal result.  */\n+\t      r = 0;\n+\t      done_sleeping = true;\n+\t    }\n+\t  else\n+\t    done_sleeping = true;\n+\t}\n+      while (! done_sleeping);\n     }\n \n   return r;\n@@ -215,6 +258,7 @@ void\n _Jv_InitThreads (void)\n {\n   pthread_key_create (&_Jv_ThreadKey, NULL);\n+  pthread_key_create (&_Jv_ThreadDataKey, NULL);\n   pthread_mutex_init (&daemon_mutex, NULL);\n   pthread_cond_init (&daemon_cond, 0);\n   non_daemon_count = 0;\n@@ -290,6 +334,7 @@ really_start (void *x)\n \n   pthread_cleanup_push (throw_cleanup, info->data);\n   pthread_setspecific (_Jv_ThreadKey, info->object);\n+  pthread_setspecific (_Jv_ThreadDataKey, info->data);\n   info->method (info->object);\n   pthread_cleanup_pop (0);\n \n@@ -359,5 +404,6 @@ _Jv_ThreadWait (void)\n void\n _Jv_ThreadInterrupt (_Jv_Thread_t *data)\n {\n+  data->flags |= FLAG_INTERRUPTED; \n   pthread_kill (data->thread, INTR);\n }"}]}