{"sha": "c7e152b57d8f22c33077340f5684d8098062bdff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdlMTUyYjU3ZDhmMjJjMzMwNzczNDBmNTY4NGQ4MDk4MDYyYmRmZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-02T08:04:47Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-02T08:04:47Z"}, "message": "[multiple changes]\n\n2012-10-02  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_dim.adb: Minor code reorganization.\n\t* sem_dim.ads: Add comment.\n\n2012-10-02  Robert Dewar  <dewar@adacore.com>\n\n\t* checks.ads, exp_ch4.adb, checks.adb\n\t(Minimize_Eliminate_Overflow_Checks): Add Top_Level parameter to avoid\n\tunnecessary conversions to Bignum.\n\tMinor reformatting.\n\n2012-10-02  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Process_PPCs): Generate invariant checks for a\n\treturn value whose type is an access type and whose designated\n\ttype has invariants. Ditto for in-out parameters and in-parameters\n\tof an access type.\n\t* exp_ch3.adb (Build_Component_Invariant_Call): Add invariant check\n\tfor an access component whose designated type has invariants.\n\nFrom-SVN: r191956", "tree": {"sha": "ff87aebf201b633f8c9217e599e37bf01db0773c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff87aebf201b633f8c9217e599e37bf01db0773c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7e152b57d8f22c33077340f5684d8098062bdff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7e152b57d8f22c33077340f5684d8098062bdff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7e152b57d8f22c33077340f5684d8098062bdff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7e152b57d8f22c33077340f5684d8098062bdff/comments", "author": null, "committer": null, "parents": [{"sha": "0c609a21446d5ff209003d898a11878b343ca6db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c609a21446d5ff209003d898a11878b343ca6db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c609a21446d5ff209003d898a11878b343ca6db"}], "stats": {"total": 277, "additions": 228, "deletions": 49}, "files": [{"sha": "3b8405c07c448e65359d83a3718db88815d36eee", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e152b57d8f22c33077340f5684d8098062bdff/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e152b57d8f22c33077340f5684d8098062bdff/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c7e152b57d8f22c33077340f5684d8098062bdff", "patch": "@@ -1,3 +1,24 @@\n+2012-10-02  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_dim.adb: Minor code reorganization.\n+\t* sem_dim.ads: Add comment.\n+\n+2012-10-02  Robert Dewar  <dewar@adacore.com>\n+\n+\t* checks.ads, exp_ch4.adb, checks.adb\n+\t(Minimize_Eliminate_Overflow_Checks): Add Top_Level parameter to avoid\n+\tunnecessary conversions to Bignum.\n+\tMinor reformatting.\n+\n+2012-10-02  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Process_PPCs): Generate invariant checks for a\n+\treturn value whose type is an access type and whose designated\n+\ttype has invariants. Ditto for in-out parameters and in-parameters\n+\tof an access type.\n+\t* exp_ch3.adb (Build_Component_Invariant_Call): Add invariant check\n+\tfor an access component whose designated type has invariants.\n+\n 2012-10-01  Vincent Pucci  <pucci@adacore.com>\n \n \t* sem_aggr.adb (New_Copy_Tree_And_Copy_Dimensions): New routine."}, {"sha": "5923c83c0a47bfb1dd75eab436c0f64185c4f542", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 57, "deletions": 18, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e152b57d8f22c33077340f5684d8098062bdff/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e152b57d8f22c33077340f5684d8098062bdff/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=c7e152b57d8f22c33077340f5684d8098062bdff", "patch": "@@ -1113,8 +1113,11 @@ package body Checks is\n \n       --  Otherwise, we have a top level arithmetic operator node, and this\n       --  is where we commence the special processing for minimize/eliminate.\n+      --  This is the case where we tell the machinery not to move into Bignum\n+      --  mode at this top level (of course the top level operation will still\n+      --  be in Bignum mode if either of its operands are of type Bignum).\n \n-      Minimize_Eliminate_Overflow_Checks (Op, Lo, Hi);\n+      Minimize_Eliminate_Overflow_Checks (Op, Lo, Hi, Top_Level => True);\n \n       --  That call may but does not necessarily change the result type of Op.\n       --  It is the job of this routine to undo such changes, so that at the\n@@ -2333,23 +2336,24 @@ package body Checks is\n             Error_Msg_N\n               (\"\\this will result in infinite recursion?\", Parent (N));\n             Insert_Action (N,\n-               Make_Raise_Storage_Error\n-                 (Sloc (N), Reason => SE_Infinite_Recursion));\n+              Make_Raise_Storage_Error (Sloc (N),\n+                Reason => SE_Infinite_Recursion));\n \n-         else\n+         --  Here for normal case of predicate active.\n \n+         else\n             --  If the predicate is a static predicate and the operand is\n             --  static, the predicate must be evaluated statically. If the\n             --  evaluation fails this is a static constraint error.\n \n             if Is_OK_Static_Expression (N) then\n-               if  Present (Static_Predicate (Typ)) then\n+               if Present (Static_Predicate (Typ)) then\n                   if Eval_Static_Predicate_Check (N, Typ) then\n                      return;\n                   else\n                      Error_Msg_NE\n                        (\"static expression fails static predicate check on&\",\n-                          N, Typ);\n+                        N, Typ);\n                   end if;\n                end if;\n             end if;\n@@ -6549,9 +6553,10 @@ package body Checks is\n    ----------------------------------------\n \n    procedure Minimize_Eliminate_Overflow_Checks\n-     (N  : Node_Id;\n-      Lo : out Uint;\n-      Hi : out Uint)\n+     (N         : Node_Id;\n+      Lo        : out Uint;\n+      Hi        : out Uint;\n+      Top_Level : Boolean)\n    is\n       pragma Assert (Is_Signed_Integer_Type (Etype (N)));\n \n@@ -6578,6 +6583,11 @@ package body Checks is\n       OK : Boolean;\n       --  Used in call to Determine_Range\n \n+      Bignum_Operands : Boolean;\n+      --  Set True if one or more operands is already of type Bignum, meaning\n+      --  that for sure (regardless of Top_Level setting) we are committed to\n+      --  doing the operation in Bignum mode.\n+\n       procedure Max (A : in out Uint; B : Uint);\n       --  If A is No_Uint, sets A to B, else to UI_Max (A, B);\n \n@@ -6609,7 +6619,7 @@ package body Checks is\n    --  Start of processing for Minimize_Eliminate_Overflow_Checks\n \n    begin\n-      --  Case where we do not have an arithmetic operator.\n+      --  Case where we do not have an arithmetic operator\n \n       if not Is_Signed_Integer_Arithmetic_Op (N) then\n \n@@ -6638,10 +6648,12 @@ package body Checks is\n       --  that lies below us!)\n \n       else\n-         Minimize_Eliminate_Overflow_Checks (Right_Opnd (N), Rlo, Rhi);\n+         Minimize_Eliminate_Overflow_Checks\n+           (Right_Opnd (N), Rlo, Rhi, Top_Level => False);\n \n          if Binary then\n-            Minimize_Eliminate_Overflow_Checks (Left_Opnd (N), Llo, Lhi);\n+            Minimize_Eliminate_Overflow_Checks\n+              (Left_Opnd (N), Llo, Lhi, Top_Level => False);\n          end if;\n       end if;\n \n@@ -6650,10 +6662,13 @@ package body Checks is\n       if Rlo = No_Uint or else (Binary and then Llo = No_Uint) then\n          Lo := No_Uint;\n          Hi := No_Uint;\n+         Bignum_Operands := True;\n \n       --  Otherwise compute result range\n \n       else\n+         Bignum_Operands := False;\n+\n          case Nkind (N) is\n \n             --  Absolute value\n@@ -7007,14 +7022,33 @@ package body Checks is\n \n       if Lo = No_Uint or else Lo < LLLo or else Hi > LLHi then\n \n-         --  In MINIMIZED mode, note that an overflow check is required\n-         --  Note that we know we don't have a Bignum, since Bignums only\n-         --  appear in Eliminated mode.\n-\n-         if Check_Mode = Minimized then\n+         --  OK, we are definitely outside the range of Long_Long_Integer. The\n+         --  question is whether to move into Bignum mode, or remain the domain\n+         --  of Long_Long_Integer, signalling that an overflow check is needed.\n+\n+         --  Obviously in MINIMIZED mode we stay with LLI, since we are not in\n+         --  the Bignum business. In ELIMINATED mode, we will normally move\n+         --  into Bignum mode, but there is an exception if neither of our\n+         --  operands is Bignum now, and we are at the top level (Top_Level\n+         --  set True). In this case, there is no point in moving into Bignum\n+         --  mode to prevent overflow if the caller will immediately convert\n+         --  the Bignum value back to LLI with an overflow check. It's more\n+         --  efficient to stay in LLI mode with an overflow check.\n+\n+         if Check_Mode = Minimized\n+           or else (Top_Level and not Bignum_Operands)\n+         then\n             Enable_Overflow_Check (N);\n \n-         --  Otherwise we are in ELIMINATED mode, switch to bignum\n+            --  Since we are doing an overflow check, the result has to be in\n+            --  Long_Long_Integer mode, so adjust the possible range to reflect\n+            --  this. Note these calls also change No_Uint values from the top\n+            --  level case to LLI bounds.\n+\n+            Max (Lo, LLLo);\n+            Min (Hi, LLHi);\n+\n+         --  Otherwise we are in ELIMINATED mode and we switch to Bignum mode\n \n          else\n             pragma Assert (Check_Mode = Eliminated);\n@@ -7079,6 +7113,11 @@ package body Checks is\n                    Name                   => New_Occurrence_Of (Fent, Loc),\n                    Parameter_Associations => Args));\n                Analyze_And_Resolve (N, RTE (RE_Bignum));\n+\n+               --  Indicate result is Bignum mode\n+\n+               Lo := No_Uint;\n+               Hi := No_Uint;\n                return;\n             end;\n          end if;"}, {"sha": "583d558e7df7d2e26b50e06d71f0463bc5456655", "filename": "gcc/ada/checks.ads", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e152b57d8f22c33077340f5684d8098062bdff/gcc%2Fada%2Fchecks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e152b57d8f22c33077340f5684d8098062bdff/gcc%2Fada%2Fchecks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.ads?ref=c7e152b57d8f22c33077340f5684d8098062bdff", "patch": "@@ -260,9 +260,10 @@ package Checks is\n    --  parameter is used to supply Sloc values for the constructed tree.\n \n    procedure Minimize_Eliminate_Overflow_Checks\n-     (N  : Node_Id;\n-      Lo : out Uint;\n-      Hi : out Uint);\n+     (N         : Node_Id;\n+      Lo        : out Uint;\n+      Hi        : out Uint;\n+      Top_Level : Boolean);\n    --  This is the main routine for handling MINIMIZED and ELIMINATED overflow\n    --  checks. On entry N is a node whose result is a signed integer subtype.\n    --  If the node is an artihmetic operation, then a range analysis is carried\n@@ -321,6 +322,16 @@ package Checks is\n    --\n    --  Note that if Bignum values appear, the caller must take care of doing\n    --  the appropriate mark/release operation on the secondary stack.\n+   --\n+   --  Top_Level is used to avoid inefficient unnecessary transitions into the\n+   --  Bignum domain. If Top_Level is True, it means that the caller will have\n+   --  to convert any Bignum value back to Long_Long_Integer, checking that the\n+   --  value is in range. This is the normal case for a top level operator in\n+   --  a subexpression. There is no point in going into Bignum mode to avoid an\n+   --  overflow just so we can check for overflow the next moment. For calls\n+   --  from comparisons and membership tests, and for all recursive calls, we\n+   --  do want to transition into the Bignum domain if necessary. Note that\n+   --  this setting is only relevant in ELIMINATED mode.\n \n    -------------------------------------------------------\n    -- Control and Optimization of Range/Overflow Checks --"}, {"sha": "af5dadd9abc68bf98432dd10af59950ee4e10c15", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 44, "deletions": 7, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e152b57d8f22c33077340f5684d8098062bdff/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e152b57d8f22c33077340f5684d8098062bdff/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=c7e152b57d8f22c33077340f5684d8098062bdff", "patch": "@@ -3674,20 +3674,43 @@ package body Exp_Ch3 is\n       return Node_Id\n       is\n          Sel_Comp : Node_Id;\n+         Typ      : Entity_Id;\n+         Call     : Node_Id;\n \n       begin\n          Invariant_Found := True;\n+         Typ := Etype (Comp);\n+\n          Sel_Comp :=\n            Make_Selected_Component (Loc,\n              Prefix      => New_Occurrence_Of (Object_Entity, Loc),\n              Selector_Name => New_Occurrence_Of (Comp, Loc));\n \n-         return\n+         if Is_Access_Type (Typ) then\n+            Sel_Comp := Make_Explicit_Dereference (Loc, Sel_Comp);\n+            Typ := Designated_Type (Typ);\n+         end if;\n+\n+         Call :=\n            Make_Procedure_Call_Statement (Loc,\n              Name                   =>\n-               New_Occurrence_Of\n-                 (Invariant_Procedure (Etype (Comp)), Loc),\n+               New_Occurrence_Of (Invariant_Procedure (Typ), Loc),\n              Parameter_Associations => New_List (Sel_Comp));\n+\n+         if Is_Access_Type (Etype (Comp)) then\n+            Call :=\n+              Make_If_Statement (Loc,\n+                Condition =>\n+                  Make_Op_Ne (Loc,\n+                    Left_Opnd   => Make_Null (Loc),\n+                    Right_Opnd  =>\n+                       Make_Selected_Component (Loc,\n+                         Prefix      => New_Occurrence_Of (Object_Entity, Loc),\n+                         Selector_Name => New_Occurrence_Of (Comp, Loc))),\n+                Then_Statements => New_List (Call));\n+         end if;\n+\n+         return Call;\n       end Build_Component_Invariant_Call;\n \n       ----------------------------\n@@ -3706,7 +3729,16 @@ package body Exp_Ch3 is\n             if Nkind (Decl) = N_Component_Declaration then\n                Id  := Defining_Identifier (Decl);\n \n-               if Has_Invariants (Etype (Id)) then\n+               if Has_Invariants (Etype (Id))\n+                 and then In_Open_Scopes (Scope (R_Type))\n+               then\n+                  Append_To (Stmts, Build_Component_Invariant_Call (Id));\n+\n+               elsif Is_Access_Type (Etype (Id))\n+                 and then not Is_Access_Constant (Etype (Id))\n+                 and then Has_Invariants (Designated_Type (Etype (Id)))\n+                 and then In_Open_Scopes (Scope (Designated_Type (Etype (Id))))\n+               then\n                   Append_To (Stmts, Build_Component_Invariant_Call (Id));\n                end if;\n             end if;\n@@ -5861,9 +5893,14 @@ package body Exp_Ch3 is\n          Build_Array_Init_Proc (Base, N);\n       end if;\n \n-      if Has_Invariants (Component_Type (Base)) then\n-\n-         --  Generate component invariant checking procedure.\n+      if Has_Invariants (Component_Type (Base))\n+        and then In_Open_Scopes (Scope (Component_Type (Base)))\n+      then\n+         --  Generate component invariant checking procedure. This is only\n+         --  relevant if the array type is within the scope of the component\n+         --  type. Otherwise an array object can only be built using the public\n+         --  subprograms for the component type, and calls to those will have\n+         --  invariant checks.\n \n          Insert_Component_Invariant_Checks\n            (N, Base, Build_Array_Invariant_Proc (Base, N));"}, {"sha": "79476fffc2564d14d0b8e47d8f1cbeca38325c82", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e152b57d8f22c33077340f5684d8098062bdff/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e152b57d8f22c33077340f5684d8098062bdff/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=c7e152b57d8f22c33077340f5684d8098062bdff", "patch": "@@ -2345,8 +2345,10 @@ package body Exp_Ch4 is\n       --  our operands using the Minimize_Eliminate circuitry which applies\n       --  this processing to the two operand subtrees.\n \n-      Minimize_Eliminate_Overflow_Checks (Left_Opnd (N),  Llo, Lhi);\n-      Minimize_Eliminate_Overflow_Checks (Right_Opnd (N), Rlo, Rhi);\n+      Minimize_Eliminate_Overflow_Checks\n+        (Left_Opnd (N),  Llo, Lhi, Top_Level => False);\n+      Minimize_Eliminate_Overflow_Checks\n+        (Right_Opnd (N), Rlo, Rhi, Top_Level => False);\n \n       --  See if the range information decides the result of the comparison\n \n@@ -3735,7 +3737,7 @@ package body Exp_Ch4 is\n       --  Entity for Long_Long_Integer'Base (Standard should export this???)\n \n    begin\n-      Minimize_Eliminate_Overflow_Checks (Lop, Lo, Hi);\n+      Minimize_Eliminate_Overflow_Checks (Lop, Lo, Hi, Top_Level => False);\n \n       --  If right operand is a subtype name, and the subtype name has no\n       --  predicate, then we can just replace the right operand with an\n@@ -3760,8 +3762,10 @@ package body Exp_Ch4 is\n       --  have not been processed for minimized or eliminated checks.\n \n       if Nkind (Rop) = N_Range then\n-         Minimize_Eliminate_Overflow_Checks (Low_Bound (Rop),  Lo, Hi);\n-         Minimize_Eliminate_Overflow_Checks (High_Bound (Rop), Lo, Hi);\n+         Minimize_Eliminate_Overflow_Checks\n+           (Low_Bound (Rop),  Lo, Hi, Top_Level => False);\n+         Minimize_Eliminate_Overflow_Checks\n+           (High_Bound (Rop), Lo, Hi, Top_Level => False);\n \n          --  We have A in B .. C, treated as  A >= B and then A <= C\n "}, {"sha": "e73b875838685de33b6f66c3ca8397c8d39e62e8", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e152b57d8f22c33077340f5684d8098062bdff/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e152b57d8f22c33077340f5684d8098062bdff/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=c7e152b57d8f22c33077340f5684d8098062bdff", "patch": "@@ -4080,6 +4080,7 @@ package body Sem_Aggr is\n                      --  We build a partially initialized aggregate with the\n                      --  values of the discriminants and box initialization\n                      --  for the rest, if other components are present.\n+\n                      --  The type of the aggregate is the known subtype of\n                      --  the component. The capture of discriminants must\n                      --  be recursive because subcomponents may be constrained\n@@ -4434,9 +4435,8 @@ package body Sem_Aggr is\n                   Next (New_Assoc);\n                end loop;\n \n-               --  If no association, this is not a legal component of\n-               --  of the type in question, except if its association\n-               --  is provided with a box.\n+               --  If no association, this is not a legal component of the type\n+               --  in question, unless its association is provided with a box.\n \n                if No (New_Assoc) then\n                   if Box_Present (Parent (Selectr)) then"}, {"sha": "6d825987c59767191b0a60bba3b0bc5d10649fda", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 67, "deletions": 5, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e152b57d8f22c33077340f5684d8098062bdff/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e152b57d8f22c33077340f5684d8098062bdff/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=c7e152b57d8f22c33077340f5684d8098062bdff", "patch": "@@ -11078,6 +11078,12 @@ package body Sem_Ch6 is\n       Plist : List_Id := No_List;\n       --  List of generated postconditions\n \n+      procedure Check_Access_Invariants (E : Entity_Id);\n+      --  If the subprogram returns an access to a type with invariants, or\n+      --  has access parameters whose designated type has an invariant, then\n+      --  under the same visibility conditions as for other invariant checks,\n+      --  the type invariant must be applied to the returned value.\n+\n       function Grab_CC return Node_Id;\n       --  Prag contains an analyzed contract case pragma. This function copies\n       --  relevant components of the pragma, creates the corresponding Check\n@@ -11108,6 +11114,43 @@ package body Sem_Ch6 is\n       --  that an invariant check is required (for an IN OUT parameter, or\n       --  the returned value of a function.\n \n+      -----------------------------\n+      -- Check_Access_Invariants --\n+      -----------------------------\n+\n+      procedure Check_Access_Invariants (E : Entity_Id) is\n+         Call : Node_Id;\n+         Obj  : Node_Id;\n+         Typ  : Entity_Id;\n+\n+      begin\n+         if Is_Access_Type (Etype (E))\n+           and then not Is_Access_Constant (Etype (E))\n+         then\n+            Typ := Designated_Type (Etype (E));\n+\n+            if Has_Invariants (Typ)\n+              and then Present (Invariant_Procedure (Typ))\n+              and then Is_Public_Subprogram_For (Typ)\n+            then\n+               Obj :=\n+                 Make_Explicit_Dereference (Loc,\n+                   Prefix => New_Occurrence_Of (E, Loc));\n+               Set_Etype (Obj, Typ);\n+\n+               Call := Make_Invariant_Call (Obj);\n+\n+               Append_To (Plist,\n+                 Make_If_Statement (Loc,\n+                   Condition =>\n+                     Make_Op_Ne (Loc,\n+                       Left_Opnd   => Make_Null (Loc),\n+                       Right_Opnd  => New_Occurrence_Of (E, Loc)),\n+                   Then_Statements => New_List (Call)));\n+            end if;\n+         end if;\n+      end Check_Access_Invariants;\n+\n       -------------\n       -- Grab_CC --\n       -------------\n@@ -11308,22 +11351,33 @@ package body Sem_Ch6 is\n          Formal : Entity_Id;\n \n       begin\n-         --  Check function return result\n+         --  Check function return result. If result is an access type there\n+         --  may be invariants on the designated type.\n \n          if Ekind (Designator) /= E_Procedure\n            and then Has_Invariants (Etype (Designator))\n          then\n             return True;\n+\n+         elsif Ekind (Designator) /= E_Procedure\n+           and then Is_Access_Type (Etype (Designator))\n+           and then Has_Invariants (Designated_Type (Etype (Designator)))\n+         then\n+            return True;\n          end if;\n \n          --  Check parameters\n \n          Formal := First_Formal (Designator);\n          while Present (Formal) loop\n             if Ekind (Formal) /= E_In_Parameter\n-              and then\n-                (Has_Invariants (Etype (Formal))\n-                  or else Present (Predicate_Function (Etype (Formal))))\n+              and then (Has_Invariants (Etype (Formal))\n+                         or else Present (Predicate_Function (Etype (Formal))))\n+            then\n+               return True;\n+\n+            elsif Is_Access_Type (Etype (Formal))\n+              and then Has_Invariants (Designated_Type (Etype (Formal)))\n             then\n                return True;\n             end if;\n@@ -11731,6 +11785,10 @@ package body Sem_Ch6 is\n                   Append_To (Plist,\n                     Make_Invariant_Call (New_Occurrence_Of (Rent, Loc)));\n                end if;\n+\n+               --  Same if return value is an access to type with invariants.\n+\n+               Check_Access_Invariants (Rent);\n             end;\n \n          --  Procedure rather than a function\n@@ -11750,7 +11808,9 @@ package body Sem_Ch6 is\n          begin\n             Formal := First_Formal (Designator);\n             while Present (Formal) loop\n-               if Ekind (Formal) /= E_In_Parameter then\n+               if Ekind (Formal) /= E_In_Parameter\n+                 or else Is_Access_Type (Etype (Formal))\n+               then\n                   Ftype := Etype (Formal);\n \n                   if Has_Invariants (Ftype)\n@@ -11762,6 +11822,8 @@ package body Sem_Ch6 is\n                          (New_Occurrence_Of (Formal, Loc)));\n                   end if;\n \n+                  Check_Access_Invariants (Formal);\n+\n                   if Present (Predicate_Function (Ftype)) then\n                      Append_To (Plist,\n                        Make_Predicate_Check"}, {"sha": "15b32dca7fc2a10d2c90d46fa1bbb63b65f994c7", "filename": "gcc/ada/sem_dim.adb", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e152b57d8f22c33077340f5684d8098062bdff/gcc%2Fada%2Fsem_dim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e152b57d8f22c33077340f5684d8098062bdff/gcc%2Fada%2Fsem_dim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.adb?ref=c7e152b57d8f22c33077340f5684d8098062bdff", "patch": "@@ -2206,13 +2206,14 @@ package body Sem_Dim is\n       Dims_Of_From : constant Dimension_Type := Dimensions_Of (From);\n \n    begin\n+      --  Ignore if not Ada 2012 or beyond\n+\n       if Ada_Version < Ada_2012 then\n          return;\n-      end if;\n \n-      --  Copy the dimension of 'From to 'To'\n+      --  For Ada 2012, Copy the dimension of 'From to 'To'\n \n-      if Exists (Dims_Of_From) then\n+      elsif Exists (Dims_Of_From) then\n          Set_Dimensions (To, Dims_Of_From);\n       end if;\n    end Copy_Dimensions;\n@@ -2730,14 +2731,14 @@ package body Sem_Dim is\n          --  Look for a symbols parameter association in the list of actuals\n \n          while Present (Actual) loop\n+\n             --  Positional parameter association case when the actual is a\n             --  string literal.\n \n             if Nkind (Actual) = N_String_Literal then\n                Actual_Str := Actual;\n \n-            --  Named parameter association case when the selector name is\n-            --  Symbol.\n+            --  Named parameter association case when selector name is Symbol\n \n             elsif Nkind (Actual) = N_Parameter_Association\n               and then Chars (Selector_Name (Actual)) = Name_Symbol\n@@ -2751,6 +2752,7 @@ package body Sem_Dim is\n             end if;\n \n             if Present (Actual_Str) then\n+\n                --  Return True if the actual comes from source or if the string\n                --  of symbols doesn't have the default value (i.e. it is \"\").\n \n@@ -3206,7 +3208,8 @@ package body Sem_Dim is\n \n       return\n         Is_RTU (E, System_Dim_Float_IO)\n-          or Is_RTU (E, System_Dim_Integer_IO);\n+          or else\n+        Is_RTU (E, System_Dim_Integer_IO);\n    end Is_Dim_IO_Package_Entity;\n \n    -------------------------------------"}, {"sha": "d069df944869e29de204b34c8e4744a7f0a83ea7", "filename": "gcc/ada/sem_dim.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e152b57d8f22c33077340f5684d8098062bdff/gcc%2Fada%2Fsem_dim.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e152b57d8f22c33077340f5684d8098062bdff/gcc%2Fada%2Fsem_dim.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.ads?ref=c7e152b57d8f22c33077340f5684d8098062bdff", "patch": "@@ -163,7 +163,8 @@ package Sem_Dim is\n    --  literal default value in the list of formals Formals.\n \n    procedure Copy_Dimensions (From, To : Node_Id);\n-   --  Copy dimension vector of From to To.\n+   --  Copy dimension vector of From to To\n+   --  We should say what the requirements on From and To are here ???\n \n    procedure Eval_Op_Expon_For_Dimensioned_Type\n      (N    : Node_Id;"}, {"sha": "f18dc00c65517b2e4d3cd3110b567ab59314f824", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e152b57d8f22c33077340f5684d8098062bdff/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e152b57d8f22c33077340f5684d8098062bdff/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=c7e152b57d8f22c33077340f5684d8098062bdff", "patch": "@@ -3260,6 +3260,7 @@ package body Sem_Eval is\n       Loc  : constant Source_Ptr := Sloc (N);\n       Pred : constant List_Id := Static_Predicate (Typ);\n       Test : Node_Id;\n+\n    begin\n       if No (Pred) then\n          return True;"}, {"sha": "b2f5aa22ca14f806d477b7a2c8c7108adf5d5271", "filename": "gcc/ada/sem_eval.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e152b57d8f22c33077340f5684d8098062bdff/gcc%2Fada%2Fsem_eval.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e152b57d8f22c33077340f5684d8098062bdff/gcc%2Fada%2Fsem_eval.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.ads?ref=c7e152b57d8f22c33077340f5684d8098062bdff", "patch": "@@ -320,7 +320,7 @@ package Sem_Eval is\n    function Eval_Static_Predicate_Check\n      (N  : Node_Id;\n      Typ : Entity_Id) return Boolean;\n-   --  Evaluate a static predicate check applied to a scalar literal.\n+   --  Evaluate a static predicate check applied to a scalar literal\n \n    procedure Fold_Str (N : Node_Id; Val : String_Id; Static : Boolean);\n    --  Rewrite N with a new N_String_Literal node as the result of the compile"}]}