{"sha": "de6f5f57650500a447a389252bc215384db2bd80", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGU2ZjVmNTc2NTA1MDBhNDQ3YTM4OTI1MmJjMjE1Mzg0ZGIyYmQ4MA==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2019-05-04T07:38:46Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2019-05-04T07:38:46Z"}, "message": "hashtable.h (_Hashtable<>::rehash): Review comment.\n\n2019-05-04  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\t* include/bits/hashtable.h (_Hashtable<>::rehash): Review comment.\n\t* include/bits/hashtable_policy.h\n\t(_Prime_rehash_policy::_M_bkt_for_elements): Use __builtin_ceill.\n\t(_Power2_rehash_policy::_M_bkt_for_elements): Likewise.\n\t(_Power2_rehash_policy::_M_next_bkt): Enforce returning a result not\n\tsmaller than input value rather than always greater. Preserve\n\t_M_next_resize if called with 0 input. Use __builtin_floorl.\n\t(_Power2_rehash_policy::_M_need_rehash): Rehash only if number of\n\telements + number of insertions is greater than _M_next_resize. Start\n\twith 11 buckets if not told otherwise. Use __builtin_floorl.\n\t(_Rehash_base<>::reserve): Use rehash policy _M_bkt_for_elements.\n\t* src/c++11/hashtable_c++0x.cc (_Prime_rehash_policy::_M_next_bkt):\n\tPreserve _M_next_resize if called with 0 input. Use __builtin_floorl.\n\t(_Prime_rehash_policy::_M_need_rehash): Start with 11 buckets if not\n\ttold otherwise. Use __builtin_floorl.\n\t* testsuite/23_containers/unordered_set/hash_policy/71181.cc: Adapt test\n\tto also validate _Power2_rehash_policy.\n\t* testsuite/23_containers/unordered_set/hash_policy/power2_rehash.cc:\n\tAdapt.\n\nFrom-SVN: r270868", "tree": {"sha": "e6012e85b93c61beeb2739fe1d9a59eb2b653ea4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6012e85b93c61beeb2739fe1d9a59eb2b653ea4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de6f5f57650500a447a389252bc215384db2bd80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de6f5f57650500a447a389252bc215384db2bd80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de6f5f57650500a447a389252bc215384db2bd80", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de6f5f57650500a447a389252bc215384db2bd80/comments", "author": null, "committer": null, "parents": [{"sha": "a3871acdb82e27e1c832ff6271fa69e55d3db375", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3871acdb82e27e1c832ff6271fa69e55d3db375", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3871acdb82e27e1c832ff6271fa69e55d3db375"}], "stats": {"total": 143, "additions": 101, "deletions": 42}, "files": [{"sha": "995ae0f6bb0b43480dc4d4964c02a099b0876486", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6f5f57650500a447a389252bc215384db2bd80/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6f5f57650500a447a389252bc215384db2bd80/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=de6f5f57650500a447a389252bc215384db2bd80", "patch": "@@ -1,3 +1,25 @@\n+2019-05-04  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\t* include/bits/hashtable.h (_Hashtable<>::rehash): Review comment.\n+\t* include/bits/hashtable_policy.h\n+\t(_Prime_rehash_policy::_M_bkt_for_elements): Use __builtin_ceill.\n+\t(_Power2_rehash_policy::_M_bkt_for_elements): Likewise.\n+\t(_Power2_rehash_policy::_M_next_bkt): Enforce returning a result not\n+\tsmaller than input value rather than always greater. Preserve\n+\t_M_next_resize if called with 0 input. Use __builtin_floorl.\n+\t(_Power2_rehash_policy::_M_need_rehash): Rehash only if number of\n+\telements + number of insertions is greater than _M_next_resize. Start\n+\twith 11 buckets if not told otherwise. Use __builtin_floorl.\n+\t(_Rehash_base<>::reserve): Use rehash policy _M_bkt_for_elements.\n+\t* src/c++11/hashtable_c++0x.cc (_Prime_rehash_policy::_M_next_bkt):\n+\tPreserve _M_next_resize if called with 0 input. Use __builtin_floorl.\n+\t(_Prime_rehash_policy::_M_need_rehash): Start with 11 buckets if not\n+\ttold otherwise. Use __builtin_floorl.\n+\t* testsuite/23_containers/unordered_set/hash_policy/71181.cc: Adapt test\n+\tto also validate _Power2_rehash_policy.\n+\t* testsuite/23_containers/unordered_set/hash_policy/power2_rehash.cc:\n+\tAdapt.\n+\n 2019-05-03  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/61761"}, {"sha": "2e8aeb7e4d4147962b735d87b03bd8d897f6c12e", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6f5f57650500a447a389252bc215384db2bd80/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6f5f57650500a447a389252bc215384db2bd80/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=de6f5f57650500a447a389252bc215384db2bd80", "patch": "@@ -2055,7 +2055,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       if (__buckets != _M_bucket_count)\n \t_M_rehash(__buckets, __saved_state);\n       else\n-\t// No rehash, restore previous state to keep a consistent state.\n+\t// No rehash, restore previous state to keep it consistent with\n+\t// container state.\n \t_M_rehash_policy._M_reset(__saved_state);\n     }\n "}, {"sha": "c7f466cd686a4f52c6c1c12fd2090c1de77bf1c2", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6f5f57650500a447a389252bc215384db2bd80/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6f5f57650500a447a389252bc215384db2bd80/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=de6f5f57650500a447a389252bc215384db2bd80", "patch": "@@ -460,7 +460,7 @@ namespace __detail\n     // Return a bucket count appropriate for n elements\n     std::size_t\n     _M_bkt_for_elements(std::size_t __n) const\n-    { return __builtin_ceil(__n / (long double)_M_max_load_factor); }\n+    { return __builtin_ceill(__n / (long double)_M_max_load_factor); }\n \n     // __n_bkt is current bucket count, __n_elt is current element count,\n     // and __n_ins is number of elements to be inserted.  Do we need to\n@@ -535,32 +535,40 @@ namespace __detail\n     std::size_t\n     _M_next_bkt(std::size_t __n) noexcept\n     {\n+      if (__n == 0)\n+\t// Special case on container 1st initialization with 0 bucket count\n+\t// hint. We keep _M_next_resize to 0 to make sure that next time we\n+\t// want to add an element allocation will take place.\n+\treturn 1;\n+\n       const auto __max_width = std::min<size_t>(sizeof(size_t), 8);\n       const auto __max_bkt = size_t(1) << (__max_width * __CHAR_BIT__ - 1);\n       std::size_t __res = __clp2(__n);\n \n-      if (__res == __n)\n-\t__res <<= 1;\n-\n       if (__res == 0)\n \t__res = __max_bkt;\n+      else if (__res == 1)\n+\t// If __res is 1 we force it to 2 to make sure there will be an\n+\t// allocation so that nothing need to be stored in the initial\n+\t// single bucket\n+\t__res = 2;\n \n       if (__res == __max_bkt)\n \t// Set next resize to the max value so that we never try to rehash again\n \t// as we already reach the biggest possible bucket number.\n \t// Note that it might result in max_load_factor not being respected.\n-\t_M_next_resize = std::size_t(-1);\n+\t_M_next_resize = numeric_limits<size_t>::max();\n       else\n \t_M_next_resize\n-\t  = __builtin_ceil(__res * (long double)_M_max_load_factor);\n+\t  = __builtin_floorl(__res * (long double)_M_max_load_factor);\n \n       return __res;\n     }\n \n     // Return a bucket count appropriate for n elements\n     std::size_t\n     _M_bkt_for_elements(std::size_t __n) const noexcept\n-    { return __builtin_ceil(__n / (long double)_M_max_load_factor); }\n+    { return __builtin_ceill(__n / (long double)_M_max_load_factor); }\n \n     // __n_bkt is current bucket count, __n_elt is current element count,\n     // and __n_ins is number of elements to be inserted.  Do we need to\n@@ -570,21 +578,25 @@ namespace __detail\n     _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,\n \t\t   std::size_t __n_ins) noexcept\n     {\n-      if (__n_elt + __n_ins >= _M_next_resize)\n+      if (__n_elt + __n_ins > _M_next_resize)\n \t{\n-\t  long double __min_bkts = (__n_elt + __n_ins)\n-\t\t\t\t\t/ (long double)_M_max_load_factor;\n+\t  // If _M_next_resize is 0 it means that we have nothing allocated so\n+\t  // far and that we start inserting elements. In this case we start\n+\t  // with an initial bucket size of 11.\n+\t  long double __min_bkts\n+\t    = std::max<std::size_t>(__n_elt + __n_ins, _M_next_resize ? 0 : 11)\n+\t      / (long double)_M_max_load_factor;\n \t  if (__min_bkts >= __n_bkt)\n-\t    return std::make_pair(true,\n-\t      _M_next_bkt(std::max<std::size_t>(__builtin_floor(__min_bkts) + 1,\n-\t\t\t\t\t\t__n_bkt * _S_growth_factor)));\n+\t    return { true,\n+\t      _M_next_bkt(std::max<std::size_t>(__builtin_floorl(__min_bkts) + 1,\n+\t\t\t\t\t\t__n_bkt * _S_growth_factor)) };\n \n \t  _M_next_resize\n-\t    = __builtin_floor(__n_bkt * (long double)_M_max_load_factor);\n-\t  return std::make_pair(false, 0);\n+\t    = __builtin_floorl(__n_bkt * (long double)_M_max_load_factor);\n+\t  return { false, 0 };\n \t}\n       else\n-\treturn std::make_pair(false, 0);\n+\treturn { false, 0 };\n     }\n \n     typedef std::size_t _State;\n@@ -1074,7 +1086,7 @@ namespace __detail\n       reserve(std::size_t __n)\n       {\n \t__hashtable* __this = static_cast<__hashtable*>(this);\n-\t__this->rehash(__builtin_ceil(__n / max_load_factor()));\n+\t__this->rehash(__this->__rehash_policy()._M_bkt_for_elements(__n));\n       }\n     };\n "}, {"sha": "de437d00b565dfc32cdd9cd3605c62be3ac94a62", "filename": "libstdc++-v3/src/c++11/hashtable_c++0x.cc", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6f5f57650500a447a389252bc215384db2bd80/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fhashtable_c%2B%2B0x.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6f5f57650500a447a389252bc215384db2bd80/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fhashtable_c%2B%2B0x.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fhashtable_c%2B%2B0x.cc?ref=de6f5f57650500a447a389252bc215384db2bd80", "patch": "@@ -51,8 +51,14 @@ namespace __detail\n \n     if (__n < sizeof(__fast_bkt))\n       {\n+\tif (__n == 0)\n+\t  // Special case on container 1st initialization with 0 bucket count\n+\t  // hint. We keep _M_next_resize to 0 to make sure that next time we\n+\t  // want to add an element allocation will take place.\n+\t  return 1;\n+\n \t_M_next_resize =\n-\t  __builtin_floor(__fast_bkt[__n] * (long double)_M_max_load_factor);\n+\t  __builtin_floorl(__fast_bkt[__n] * (long double)_M_max_load_factor);\n \treturn __fast_bkt[__n];\n       }\n \n@@ -72,10 +78,10 @@ namespace __detail\n       // Set next resize to the max value so that we never try to rehash again\n       // as we already reach the biggest possible bucket number.\n       // Note that it might result in max_load_factor not being respected.\n-      _M_next_resize = std::size_t(-1);\n+      _M_next_resize = numeric_limits<size_t>::max();\n     else\n       _M_next_resize =\n-\t__builtin_floor(*__next_bkt * (long double)_M_max_load_factor);\n+\t__builtin_floorl(*__next_bkt * (long double)_M_max_load_factor);\n \n     return *__next_bkt;\n   }\n@@ -96,19 +102,23 @@ namespace __detail\n   {\n     if (__n_elt + __n_ins > _M_next_resize)\n       {\n-\tlong double __min_bkts = (__n_elt + __n_ins)\n-\t\t\t\t   / (long double)_M_max_load_factor;\n+\t// If _M_next_resize is 0 it means that we have nothing allocated so\n+\t// far and that we start inserting elements. In this case we start\n+\t// with an initial bucket size of 11.\n+\tlong double __min_bkts\n+\t  = std::max<std::size_t>(__n_elt + __n_ins, _M_next_resize ? 0 : 11)\n+\t  / (long double)_M_max_load_factor;\n \tif (__min_bkts >= __n_bkt)\n-\t  return std::make_pair(true,\n-\t    _M_next_bkt(std::max<std::size_t>(__builtin_floor(__min_bkts) + 1,\n-\t\t\t\t\t      __n_bkt * _S_growth_factor)));\n+\t  return { true,\n+\t    _M_next_bkt(std::max<std::size_t>(__builtin_floorl(__min_bkts) + 1,\n+\t\t\t\t\t      __n_bkt * _S_growth_factor)) };\n \n \t_M_next_resize\n-\t  = __builtin_floor(__n_bkt * (long double)_M_max_load_factor);\n-\treturn std::make_pair(false, 0);\n+\t  = __builtin_floorl(__n_bkt * (long double)_M_max_load_factor);\n+\treturn { false, 0 };\n       }\n     else\n-      return std::make_pair(false, 0);\n+      return { false, 0 };\n   }\n } // namespace __detail\n "}, {"sha": "7bbf4fd73db8ec36e8aa6ba69cfe333641c6ceb6", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/hash_policy/71181.cc", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6f5f57650500a447a389252bc215384db2bd80/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fhash_policy%2F71181.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6f5f57650500a447a389252bc215384db2bd80/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fhash_policy%2F71181.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fhash_policy%2F71181.cc?ref=de6f5f57650500a447a389252bc215384db2bd80", "patch": "@@ -22,22 +22,22 @@\n #include <testsuite_hooks.h>\n \n template<typename _USet>\n-  void test(int threshold)\n+  void\n+  test(_USet& us, int threshold)\n   {\n-    _USet us;\n     auto nb_reserved = us.bucket_count();\n     us.reserve(nb_reserved);\n     auto bkts = us.bucket_count();\n-    for (int i = 0; i != threshold; ++i)\n+    for (int nb_insert = 1; nb_insert <= threshold; ++nb_insert)\n       {\n-\tif (i >= nb_reserved)\n+\tif (nb_insert > nb_reserved)\n \t  {\n \t    nb_reserved = bkts;\n \t    us.reserve(nb_reserved);\n \t    bkts = us.bucket_count();\n \t  }\n \n-\tus.insert(i);\n+\tus.insert(nb_insert);\n \n \tVERIFY( us.bucket_count() == bkts );\n       }\n@@ -54,9 +54,22 @@ template<typename _Value>\n \t\t  std::__detail::_Power2_rehash_policy,\n \t\t  std::__detail::_Hashtable_traits<false, true, true>>;\n \n+template<typename _USet>\n+  void\n+  test_cont()\n+  {\n+    _USet us;\n+    test(us, 150);\n+\n+    us.clear();\n+    us.rehash(0);\n+\n+    test(us, 150);\n+  }\n+\n int main()\n {\n-  test<std::unordered_set<int>>(150);\n-  test<unordered_set_power2_rehash<int>>(150);\n+  test_cont<std::unordered_set<int>>();\n+  test_cont<unordered_set_power2_rehash<int>>();\n   return 0;\n }"}, {"sha": "5e42485b9778f689fc4d68febbf4aa6548828c2e", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/hash_policy/power2_rehash.cc", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6f5f57650500a447a389252bc215384db2bd80/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fhash_policy%2Fpower2_rehash.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6f5f57650500a447a389252bc215384db2bd80/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fhash_policy%2Fpower2_rehash.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fhash_policy%2Fpower2_rehash.cc?ref=de6f5f57650500a447a389252bc215384db2bd80", "patch": "@@ -26,9 +26,10 @@ void test01()\n {\n   std::__detail::_Power2_rehash_policy policy;\n   VERIFY( policy._M_next_bkt(1) == 2 );\n-  VERIFY( policy._M_next_bkt(2) == 4 );\n+  VERIFY( policy._M_next_bkt(2) == 2 );\n   VERIFY( policy._M_next_bkt(3) == 4 );\n   VERIFY( policy._M_next_bkt(5) == 8 );\n+  VERIFY( policy._M_next_bkt(16) == 16 );\n   VERIFY( policy._M_next_bkt(33) == 64 );\n   VERIFY( policy._M_next_bkt((std::size_t(1) << (sizeof(std::size_t) * 8 - 2)) + 1)\n \t  == (std::size_t(1) << (sizeof(std::size_t) * 8 - 1)) );\n@@ -38,20 +39,20 @@ void test02()\n {\n   std::__detail::_Power2_rehash_policy policy;\n \n-  for (std::size_t i = 1;;)\n+  for (std::size_t i = 3;;)\n     {\n       auto nxt = policy._M_next_bkt(i);\n \n-      if (nxt == i)\n+      if (nxt <= i)\n \t{\n-\t  // Equals only when reaching max.\n+\t  // Lower or equal only when reaching max.\n \t  constexpr auto mx = std::numeric_limits<std::size_t>::max();\n \t  VERIFY( nxt == policy._M_next_bkt(mx) );\n \t  break;\n \t}\n \n-      VERIFY( nxt > i );\n-      i = nxt;\n+      VERIFY( nxt >= i );\n+      i = nxt + 1;\n     }\n }\n "}]}