{"sha": "c58936b6b75bfea1b486a7040081e423e58a56de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU4OTM2YjZiNzViZmVhMWI0ODZhNzA0MDA4MWU0MjNlNThhNTZkZQ==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2006-12-04T19:07:05Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2006-12-04T19:07:05Z"}, "message": "tree-ssa-alias.c (compute_may_aliases): Compute flow sensitive before flow insensitive.\n\n2006-12-04  Daniel Berlin  <dberlin@dberlin.org>\n\t\n\t* tree-ssa-alias.c (compute_may_aliases):\n\tCompute flow sensitive before flow insensitive.\n\t(compute_flow_sensitive_aliasing): Don't try to add\n\ta symbol memory tag to itself.\n\t\n\t* alias.h (alias_set_subset_of): New prototype.\n\n\t* alias.c (alias_set_subset_of): New function.\n\n\t* tree-ssa-structalias.c: Update comments.\n\t(struct variable_info): Add finished_solution.\n\t(new_varinfo): Set finished solution to NULL.\n\t(var_escaped_vars): Remove.\n\t(escaped_vars_tree): Remove.\n\t(escaped_vars_id): Remove.\n\t(nonlocal_vars_id): Remove.\n\t(constraint_expr_type): Add INCLUDES.\n\t(graph_size): Removed.\n\t(dump_constraint): Support INCLUDES.\n\t(build_constraint_graph): Ditto.\n\t(collapse_nodes): Add merge_solutions argument.\n\tDon't merge attributes.\n\t(process_unification_queue): Just use collapse_nodes.\n\t(perform_var_substitution): Update call to collapse_nodes.\n\t(get_constraint_exp_from_ssa_var): Use INCLUDES.\n\t(process_constraint): Fix non-field sensitive handling\n\tHandle includes.\n\t(get_constraint_for): Use INCLUDES.\n\t(make_constraint_from_anything): Renamed from\n\tmake_constraint_from_escaped.\n\t(make_constraint_to_escaped): Removed.\n\t(find_global_initializers): Removed.\n\t(create_variable_info_for): Do not make constraints to escaped\n\tvars anymore.\n\t(dump_solution_for_var): Don't print out the equivalent points-to\n\tsets, just use the name of the variable it shares it with.\n\t(intra_create_variable_infos): Use INCLUDES.\n\tChange nonlocal variable sets to anything sets.\n\t(init_base_vars): Remove escaped_vars and nonlocal_var\n\tinitialization. \n\t(find_escape_constraints): Removed.\n\t(delete_points_to_sets): Remove dead code.\n\t(used_smt_calculated): New variable.\n\t(set_used_smts): New function.\n\t(merge_smts_into): New function.\n\t(find_what_p_points_to): Modify to use SMTs.\n\t(create_nonlocal_var): Remove.\n\t\n\t* tree-ssa-operands.c (access_can_touch_variable): Remove\n\treference to nonlocal_all. \n\n\t* tree-ssa.c (verify_name_tags): Remove.\n\nFrom-SVN: r119502", "tree": {"sha": "8dbfc56117f5c8e2683fa7f0f2fb59efb7c301b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8dbfc56117f5c8e2683fa7f0f2fb59efb7c301b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c58936b6b75bfea1b486a7040081e423e58a56de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c58936b6b75bfea1b486a7040081e423e58a56de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c58936b6b75bfea1b486a7040081e423e58a56de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c58936b6b75bfea1b486a7040081e423e58a56de/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2c05d05ede8e14d8e709b172e83004c53fb30187", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c05d05ede8e14d8e709b172e83004c53fb30187", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c05d05ede8e14d8e709b172e83004c53fb30187"}], "stats": {"total": 1363, "additions": 599, "deletions": 764}, "files": [{"sha": "3fbc38ae7b70e2b6fc33bed41b5184b3b9830f37", "filename": "gcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c58936b6b75bfea1b486a7040081e423e58a56de/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c58936b6b75bfea1b486a7040081e423e58a56de/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c58936b6b75bfea1b486a7040081e423e58a56de", "patch": "@@ -1,3 +1,50 @@\n+2006-12-04  Daniel Berlin  <dberlin@dberlin.org>\n+\t\n+\t* tree-ssa-alias.c (compute_may_aliases):\n+\tCompute flow sensitive before flow insensitive.\n+\t(compute_flow_sensitive_aliasing): Don't try to add\n+\ta symbol memory tag to itself.\n+\t* alias.h (alias_set_subset_of): New prototype.\n+\t* alias.c (alias_set_subset_of): New function.\n+\t* tree-ssa-structalias.c: Update comments.\n+\t(struct variable_info): Add finished_solution.\n+\t(new_varinfo): Set finished solution to NULL.\n+\t(var_escaped_vars): Remove.\n+\t(escaped_vars_tree): Remove.\n+\t(escaped_vars_id): Remove.\n+\t(constraint_expr_type): Add INCLUDES.\n+\t(graph_size): Removed.\n+\t(dump_constraint): Support INCLUDES.\n+\t(build_constraint_graph): Ditto.\n+\t(collapse_nodes): Add merge_solutions argument.\n+\tDon't merge attributes.\n+\t(process_unification_queue): Just use collapse_nodes.\n+\t(perform_var_substitution): Update call to collapse_nodes.\n+\t(get_constraint_exp_from_ssa_var): Use INCLUDES.\n+\t(process_constraint): Fix non-field sensitive handling\n+\tHandle includes.\n+\t(get_constraint_for): Use INCLUDES.\n+\t(make_constraint_from_escaped): Use nonlocal_vars_id.\n+\t(make_constraint_to_escaped): Removed.\n+\t(find_global_initializers): Removed.\n+\t(create_variable_info_for): Do not make constraints to escaped\n+\tvars anymore.\n+\t(dump_solution_for_var): Don't print out the equivalent points-to\n+\tsets, just use the name of the variable it shares it with.\n+\t(intra_create_variable_infos): Use INCLUDES.\n+\tMove initialization of nonlocal variable to init_base_vars.\n+\t(init_base_vars): Init nonlocal variable here.\n+\tRemove escaped_vars initialization.\n+\t(find_escape_constraints): Removed.\n+\t(delete_points_to_sets): Remove dead code.\n+\t(used_smt_calculated): New variable.\n+\t(set_used_smts): New function.\n+\t(merge_smts_into): New function.\n+\t(find_what_p_points_to): Modify to use SMTs.\n+\t* tree-ssa-operands.c (access_can_touch_variable): Remove\n+\treference to nonlocal_all. \n+\t* tree-ssa.c (verify_name_tags): Remove.\n+\t\n 2006-12-04  Carlos O'Donell  <carlos@codesourcery.com>\n \n \t* config/arm/unwind-arm.c: Adjust __cxa_type_match declaration."}, {"sha": "76e29b01fac3c5f51d04f04fc1a94d602d9de4c2", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c58936b6b75bfea1b486a7040081e423e58a56de/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c58936b6b75bfea1b486a7040081e423e58a56de/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c58936b6b75bfea1b486a7040081e423e58a56de", "patch": "@@ -1837,7 +1837,7 @@ stor-layout.o : stor-layout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n tree-ssa-structalias.o: tree-ssa-structalias.c tree-ssa-structalias.h \\\n    $(SYSTEM_H) $(CONFIG_H) $(GGC_H) $(TREE_H) $(TREE_FLOW_H) \\\n    $(TM_H) coretypes.h $(CGRAPH_H) tree-pass.h $(TIMEVAR_H) \\\n-   gt-tree-ssa-structalias.h $(PARAMS_H)\n+   gt-tree-ssa-structalias.h $(PARAMS_H) $(ALIAS_H)\n tree-ssa.o : tree-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) output.h $(DIAGNOSTIC_H) \\\n    toplev.h $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h \\"}, {"sha": "ba7f948c89ea387caf685b6da1694385f0dcae9a", "filename": "gcc/alias.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c58936b6b75bfea1b486a7040081e423e58a56de/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c58936b6b75bfea1b486a7040081e423e58a56de/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=c58936b6b75bfea1b486a7040081e423e58a56de", "patch": "@@ -293,6 +293,26 @@ insert_subset_children (splay_tree_node node, void *data)\n   return 0;\n }\n \n+/* Return true if the first alias set is a subset of the second.  */\n+\n+bool\n+alias_set_subset_of (HOST_WIDE_INT set1, HOST_WIDE_INT set2)\n+{\n+  alias_set_entry ase;\n+\n+  /* Everything is a subset of the \"aliases everything\" set.  */\n+  if (set2 == 0)\n+    return true;\n+\n+  /* Otherwise, check if set1 is a subset of set2.  */\n+  ase = get_alias_set_entry (set2);\n+  if (ase != 0\n+      && (splay_tree_lookup (ase->children,\n+\t\t\t     (splay_tree_key) set1)))\n+    return true;\n+  return false;\n+}\n+\n /* Return 1 if the two specified alias sets may conflict.  */\n \n int"}, {"sha": "46130e8e438d0b830c1a011ae48dad2ecbaa95dc", "filename": "gcc/alias.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c58936b6b75bfea1b486a7040081e423e58a56de/gcc%2Falias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c58936b6b75bfea1b486a7040081e423e58a56de/gcc%2Falias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.h?ref=c58936b6b75bfea1b486a7040081e423e58a56de", "patch": "@@ -25,6 +25,7 @@ extern HOST_WIDE_INT new_alias_set (void);\n extern HOST_WIDE_INT get_varargs_alias_set (void);\n extern HOST_WIDE_INT get_frame_alias_set (void);\n extern bool component_uses_parent_alias_set (tree);\n+extern bool alias_set_subset_of (HOST_WIDE_INT, HOST_WIDE_INT);\n \n /* This alias set can be used to force a memory to conflict with all\n    other memories, creating a barrier across which no memory reference"}, {"sha": "302165608d55b2bda384b79dc73bfdbbb20d14e1", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20031015-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c58936b6b75bfea1b486a7040081e423e58a56de/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20031015-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c58936b6b75bfea1b486a7040081e423e58a56de/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20031015-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20031015-1.c?ref=c58936b6b75bfea1b486a7040081e423e58a56de", "patch": "@@ -14,5 +14,5 @@ main(void)\n }\n \n /* The V_*_DEF comes from the initial assignment and the asm.  */\n-/* { dg-final { scan-tree-dump-times \"_DEF\" 3 \"alias1\" } } */\n+/* { dg-final { scan-tree-dump-times \"_DEF\" 2 \"alias1\" } } */\n /* { dg-final { cleanup-tree-dump \"alias1\" } } */"}, {"sha": "543e5cd823917769b9437575002785dc419ab2cf", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20040517-1.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c58936b6b75bfea1b486a7040081e423e58a56de/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040517-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c58936b6b75bfea1b486a7040081e423e58a56de/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040517-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040517-1.c?ref=c58936b6b75bfea1b486a7040081e423e58a56de", "patch": "@@ -17,5 +17,6 @@ void bar (void)\n    malloc functions may clobber global memory.  Only the function result\n    does not alias any other pointer.\n    Hence, we must have a VDEF for a before and after the call to foo().  */\n-/* { dg-final { scan-tree-dump-times \"V_MAY_DEF\" 2 \"alias1\"} } */\n+/* { dg-final { scan-tree-dump-times \"V_MAY_DEF\" 1 \"alias1\"} } */\n+/* { dg-final { scan-tree-dump-times \"V_MUST_DEF\" 1 \"alias1\"} } */\n /* { dg-final { cleanup-tree-dump \"alias1\" } } */"}, {"sha": "d8631f8d056f5158724111efbb032d0643d788a9", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr26421.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c58936b6b75bfea1b486a7040081e423e58a56de/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr26421.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c58936b6b75bfea1b486a7040081e423e58a56de/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr26421.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr26421.c?ref=c58936b6b75bfea1b486a7040081e423e58a56de", "patch": "@@ -16,5 +16,6 @@ int foo(void)\n   return a.i;\n }\n \n-/* { dg-final { scan-tree-dump-times \"V_MAY_DEF\" 2 \"alias1\" } } */\n+/* { dg-final { scan-tree-dump-times \"V_MAY_DEF\" 1 \"alias1\" } } */\n+/* { dg-final { scan-tree-dump-times \"V_MUST_DEF\" 1 \"alias1\" } } */\n /* { dg-final { cleanup-tree-dump \"alias1\" } } */"}, {"sha": "d4f1590151073ceb5aca2f66340c54d6e9a58250", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c58936b6b75bfea1b486a7040081e423e58a56de/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c58936b6b75bfea1b486a7040081e423e58a56de/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=c58936b6b75bfea1b486a7040081e423e58a56de", "patch": "@@ -646,15 +646,13 @@ compute_may_aliases (void)\n      not needed anymore.  */\n   setup_pointers_and_addressables (ai);\n \n-  /* Compute flow-sensitive, points-to based aliasing for all the name\n-     memory tags.  Note that this pass needs to be done before flow\n-     insensitive analysis because it uses the points-to information\n-     gathered before to mark call-clobbered symbol tags.  */\n-  compute_flow_sensitive_aliasing (ai);\n-\n   /* Compute type-based flow-insensitive aliasing for all the type\n      memory tags.  */\n   compute_flow_insensitive_aliasing (ai);\n+\n+  /* Compute flow-sensitive, points-to based aliasing for all the name\n+     memory tags.  */\n+  compute_flow_sensitive_aliasing (ai);\n   \n   /* Compute call clobbering information.  */\n   compute_call_clobbered (ai);\n@@ -1121,7 +1119,8 @@ compute_flow_sensitive_aliasing (struct alias_info *ai)\n \tEXECUTE_IF_SET_IN_BITMAP (pi->pt_vars, 0, j, bi)\n \t  {\n \t    add_may_alias (pi->name_mem_tag, referenced_var (j));\n-\t    add_may_alias (v_ann->symbol_mem_tag, referenced_var (j));\n+\t    if (j != DECL_UID (v_ann->symbol_mem_tag))\n+\t      add_may_alias (v_ann->symbol_mem_tag, referenced_var (j));\n \t  }\n     }\n }"}, {"sha": "5c4e100595d914584ac945b75cfa46a2aa5324de", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c58936b6b75bfea1b486a7040081e423e58a56de/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c58936b6b75bfea1b486a7040081e423e58a56de/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=c58936b6b75bfea1b486a7040081e423e58a56de", "patch": "@@ -1056,11 +1056,6 @@ access_can_touch_variable (tree ref, tree alias, HOST_WIDE_INT offset,\n   if (alias == gimple_global_var (cfun))\n     return true;\n \n-  /* We cannot prune nonlocal aliases because they are not type\n-     specific.  */\n-  if (alias == gimple_nonlocal_all (cfun))\n-    return true;\n-\n   /* If ALIAS is an SFT, it can't be touched if the offset     \n      and size of the access is not overlapping with the SFT offset and\n      size.  This is only true if we are accessing through a pointer"}, {"sha": "6a27972e7ef3c63c65bb1fb15a5c756f2712876a", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 519, "deletions": 622, "changes": 1141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c58936b6b75bfea1b486a7040081e423e58a56de/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c58936b6b75bfea1b486a7040081e423e58a56de/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=c58936b6b75bfea1b486a7040081e423e58a56de", "patch": "@@ -51,10 +51,11 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n #include \"params.h\"\n #include \"tree-ssa-structalias.h\"\n #include \"cgraph.h\"\n+#include \"alias.h\"\n \n /* The idea behind this analyzer is to generate set constraints from the\n    program, then solve the resulting constraints in order to generate the\n-   points-to sets. \n+   points-to sets.\n \n    Set constraints are a way of modeling program analysis problems that\n    involve sets.  They consist of an inclusion constraint language,\n@@ -70,33 +71,38 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n \n    Also see \"Ultra-fast Aliasing Analysis using CLA: A Million Lines\n    of C Code in a Second\" by \"\"Nevin Heintze and Olivier Tardieu\" at\n-   http://citeseer.ist.psu.edu/heintze01ultrafast.html \n+   http://citeseer.ist.psu.edu/heintze01ultrafast.html\n+\n+   There are three types of real constraint expressions, DEREF,\n+   ADDRESSOF, and SCALAR.  There is one type of fake constraint\n+   expression, called INCLUDES.  Each constraint expression consists\n+   of a constraint type, a variable, and an offset.\n \n-   There are three types of constraint expressions, DEREF, ADDRESSOF, and\n-   SCALAR.  Each constraint expression consists of a constraint type,\n-   a variable, and an offset.  \n-   \n    SCALAR is a constraint expression type used to represent x, whether\n    it appears on the LHS or the RHS of a statement.\n    DEREF is a constraint expression type used to represent *x, whether\n-   it appears on the LHS or the RHS of a statement. \n+   it appears on the LHS or the RHS of a statement.\n    ADDRESSOF is a constraint expression used to represent &x, whether\n    it appears on the LHS or the RHS of a statement.\n-   \n+   INCLUDES is a constraint expression type used to represent just a\n+   setting of a bit in the points-to set without having the address\n+   taken.  It exists mainly for abstraction sake, and is used for\n+   initializing fake variables like the ESCAPED_VARS set.\n+\n    Each pointer variable in the program is assigned an integer id, and\n    each field of a structure variable is assigned an integer id as well.\n-   \n+\n    Structure variables are linked to their list of fields through a \"next\n    field\" in each variable that points to the next field in offset\n-   order.  \n-   Each variable for a structure field has \n+   order.\n+   Each variable for a structure field has\n \n    1. \"size\", that tells the size in bits of that field.\n    2. \"fullsize, that tells the size in bits of the entire structure.\n    3. \"offset\", that tells the offset in bits from the beginning of the\n    structure to this field.\n \n-   Thus, \n+   Thus,\n    struct f\n    {\n      int a;\n@@ -110,59 +116,59 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n    foo.b -> id 2, size 32, offset 32, fullsize 64, next NULL\n    bar -> id 3, size 32, offset 0, fullsize 32, next NULL\n \n-   \n+\n   In order to solve the system of set constraints, the following is\n   done:\n \n   1. Each constraint variable x has a solution set associated with it,\n   Sol(x).\n-  \n+\n   2. Constraints are separated into direct, copy, and complex.\n   Direct constraints are ADDRESSOF constraints that require no extra\n   processing, such as P = &Q\n   Copy constraints are those of the form P = Q.\n   Complex constraints are all the constraints involving dereferences\n   and offsets (including offsetted copies).\n-  \n+\n   3. All direct constraints of the form P = &Q are processed, such\n-  that Q is added to Sol(P) \n+  that Q is added to Sol(P)\n \n   4. All complex constraints for a given constraint variable are stored in a\n-  linked list attached to that variable's node.  \n+  linked list attached to that variable's node.\n \n   5. A directed graph is built out of the copy constraints. Each\n-  constraint variable is a node in the graph, and an edge from \n+  constraint variable is a node in the graph, and an edge from\n   Q to P is added for each copy constraint of the form P = Q\n-  \n+\n   6. The graph is then walked, and solution sets are\n   propagated along the copy edges, such that an edge from Q to P\n   causes Sol(P) <- Sol(P) union Sol(Q).\n-  \n+\n   7.  As we visit each node, all complex constraints associated with\n   that node are processed by adding appropriate copy edges to the graph, or the\n-  appropriate variables to the solution set.  \n+  appropriate variables to the solution set.\n \n   8. The process of walking the graph is iterated until no solution\n   sets change.\n \n   Prior to walking the graph in steps 6 and 7, We perform static\n-  cycle elimination on the constraint graph, as well \n+  cycle elimination on the constraint graph, as well\n   as off-line variable substitution.\n-  \n+\n   TODO: Adding offsets to pointer-to-structures can be handled (IE not punted\n   on and turned into anything), but isn't.  You can just see what offset\n   inside the pointed-to struct it's going to access.\n-  \n+\n   TODO: Constant bounded arrays can be handled as if they were structs of the\n-  same number of elements. \n+  same number of elements.\n \n   TODO: Modeling heap and incoming pointers becomes much better if we\n   add fields to them as we discover them, which we could do.\n \n   TODO: We could handle unions, but to be honest, it's probably not\n   worth the pain or slowdown.  */\n \n-static GTY ((if_marked (\"tree_map_marked_p\"), param_is (struct tree_map))) \n+static GTY ((if_marked (\"tree_map_marked_p\"), param_is (struct tree_map)))\n htab_t heapvar_for_stmt;\n \n static bool use_field_sensitive = true;\n@@ -203,7 +209,7 @@ struct variable_info\n   tree decl;\n \n   /* Offset of this variable, in bits, from the base variable  */\n-  unsigned HOST_WIDE_INT offset;  \n+  unsigned HOST_WIDE_INT offset;\n \n   /* Size of the variable, in bits.  */\n   unsigned HOST_WIDE_INT size;\n@@ -225,7 +231,7 @@ struct variable_info\n   /* True if this variable is the target of a dereference.  Needed for\n      variable substitution.  */\n   unsigned int indirect_target:1;\n-  \n+\n   /* True if the variable is directly the target of a dereference.\n      This is used to track which variables are *actually* dereferenced\n      so we can prune their points to listed. This is equivalent to the\n@@ -235,13 +241,13 @@ struct variable_info\n   /* True if this is a variable created by the constraint analysis, such as\n      heap variables and constraints we had to break up.  */\n   unsigned int is_artificial_var:1;\n-  \n+\n   /* True if this is a special variable whose solution set should not be\n      changed.  */\n   unsigned int is_special_var:1;\n \n   /* True for variables whose size is not known or variable.  */\n-  unsigned int is_unknown_size_var:1;  \n+  unsigned int is_unknown_size_var:1;\n \n   /* True for variables that have unions somewhere in them.  */\n   unsigned int has_union:1;\n@@ -252,13 +258,17 @@ struct variable_info\n   /* Points-to set for this variable.  */\n   bitmap solution;\n \n+  /* Finished points-to set for this variable (IE what is returned\n+     from find_what_p_points_to.  */\n+  bitmap finished_solution;\n+\n   /* Variable ids represented by this node.  */\n   bitmap variables;\n \n   /* Vector of complex constraints for this node.  Complex\n      constraints are those involving dereferences.  */\n   VEC(constraint_t,heap) *complex;\n-  \n+\n   /* Variable id this was collapsed to due to type unsafety.\n      This should be unused completely after build_constraint_graph, or\n      something is broken.  */\n@@ -320,19 +330,9 @@ static varinfo_t var_integer;\n static tree integer_tree;\n static unsigned int integer_id;\n \n-/* Variable that represents escaped variables.  This is used to give\n-   incoming pointer variables a better set than ANYTHING.  */\n-static varinfo_t var_escaped_vars;\n-static tree escaped_vars_tree;\n-static unsigned int escaped_vars_id;\n-\n-/* Variable that represents non-local variables before we expand it to\n-   one for each type.  */\n-static unsigned int nonlocal_vars_id;\n-\n /* Lookup a heap var for FROM, and return it if we find one.  */\n \n-static tree \n+static tree\n heapvar_lookup (tree from)\n {\n   struct tree_map *h, in;\n@@ -383,17 +383,18 @@ new_var_info (tree t, unsigned int id, const char *name, unsigned int node)\n   ret->has_union = false;\n   ret->solution = BITMAP_ALLOC (&ptabitmap_obstack);\n   ret->variables = BITMAP_ALLOC (&ptabitmap_obstack);\n+  ret->finished_solution = NULL;\n   ret->complex = NULL;\n   ret->next = NULL;\n   ret->collapsed_to = NULL;\n   return ret;\n }\n \n-typedef enum {SCALAR, DEREF, ADDRESSOF} constraint_expr_type;\n+typedef enum {SCALAR, DEREF, ADDRESSOF, INCLUDES} constraint_expr_type;\n \n /* An expression that appears in a constraint.  */\n \n-struct constraint_expr \n+struct constraint_expr\n {\n   /* Constraint type.  */\n   constraint_expr_type type;\n@@ -416,7 +417,7 @@ static void get_constraint_for (tree, VEC(ce_s, heap) **);\n static void do_deref (VEC (ce_s, heap) **);\n \n /* Our set constraints are made up of two constraint expressions, one\n-   LHS, and one RHS.  \n+   LHS, and one RHS.\n \n    As described in the introduction, our set constraints each represent an\n    operation between set valued variables.\n@@ -445,11 +446,10 @@ struct constraint_graph\n typedef struct constraint_graph *constraint_graph_t;\n \n static constraint_graph_t graph;\n-static int graph_size;\n \n /* Create a new constraint consisting of LHS and RHS expressions.  */\n \n-static constraint_t \n+static constraint_t\n new_constraint (const struct constraint_expr lhs,\n \t\tconst struct constraint_expr rhs)\n {\n@@ -467,7 +467,7 @@ dump_constraint (FILE *file, constraint_t c)\n   if (c->lhs.type == ADDRESSOF)\n     fprintf (file, \"&\");\n   else if (c->lhs.type == DEREF)\n-    fprintf (file, \"*\");  \n+    fprintf (file, \"*\");\n   fprintf (file, \"%s\", get_varinfo_fc (c->lhs.var)->name);\n   if (c->lhs.offset != 0)\n     fprintf (file, \" + \" HOST_WIDE_INT_PRINT_DEC, c->lhs.offset);\n@@ -476,9 +476,13 @@ dump_constraint (FILE *file, constraint_t c)\n     fprintf (file, \"&\");\n   else if (c->rhs.type == DEREF)\n     fprintf (file, \"*\");\n+  else if (c->rhs.type == INCLUDES)\n+    fprintf (file, \"{\");\n   fprintf (file, \"%s\", get_varinfo_fc (c->rhs.var)->name);\n   if (c->rhs.offset != 0)\n     fprintf (file, \" + \" HOST_WIDE_INT_PRINT_DEC, c->rhs.offset);\n+  if (c->rhs.type == INCLUDES)\n+    fprintf (file, \"}\");\n   fprintf (file, \"\\n\");\n }\n \n@@ -509,11 +513,11 @@ debug_constraints (void)\n   dump_constraints (stderr);\n }\n \n-/* SOLVER FUNCTIONS \n+/* SOLVER FUNCTIONS\n \n    The solver is a simple worklist solver, that works on the following\n    algorithm:\n-   \n+\n    sbitmap changed_nodes = all ones;\n    changed_count = number of nodes;\n    For each node that was already collapsed:\n@@ -522,10 +526,10 @@ debug_constraints (void)\n    while (changed_count > 0)\n    {\n      compute topological ordering for constraint graph\n-  \n+\n      find and collapse cycles in the constraint graph (updating\n      changed if necessary)\n-     \n+\n      for each node (n) in the graph in topological order:\n        changed_count--;\n \n@@ -578,11 +582,11 @@ constraint_less (const constraint_t a, const constraint_t b)\n }\n \n /* Return true if two constraints A and B are equal.  */\n-  \n+\n static bool\n constraint_equal (struct constraint a, struct constraint b)\n {\n-  return constraint_expr_equal (a.lhs, b.lhs) \n+  return constraint_expr_equal (a.lhs, b.lhs)\n     && constraint_expr_equal (a.rhs, b.rhs);\n }\n \n@@ -593,7 +597,7 @@ static constraint_t\n constraint_vec_find (VEC(constraint_t,heap) *vec,\n \t\t     struct constraint lookfor)\n {\n-  unsigned int place;  \n+  unsigned int place;\n   constraint_t found;\n \n   if (vec == NULL)\n@@ -643,7 +647,7 @@ solution_set_add (bitmap set, unsigned HOST_WIDE_INT offset)\n       /* If this is a properly sized variable, only add offset if it's\n \t less than end.  Otherwise, it is globbed to a single\n \t variable.  */\n-      \n+\n       if ((get_varinfo (i)->offset + offset) < get_varinfo (i)->fullsize)\n \t{\n \t  unsigned HOST_WIDE_INT fieldoffset = get_varinfo (i)->offset + offset;\n@@ -652,15 +656,15 @@ solution_set_add (bitmap set, unsigned HOST_WIDE_INT offset)\n \t    continue;\n \t  bitmap_set_bit (result, v->id);\n \t}\n-      else if (get_varinfo (i)->is_artificial_var \n+      else if (get_varinfo (i)->is_artificial_var\n \t       || get_varinfo (i)->has_union\n \t       || get_varinfo (i)->is_unknown_size_var)\n \t{\n \t  bitmap_set_bit (result, i);\n \t}\n     }\n-  \n-  bitmap_copy (set, result);  \n+\n+  bitmap_copy (set, result);\n   BITMAP_FREE (result);\n }\n \n@@ -701,31 +705,31 @@ insert_into_complex (unsigned int var, constraint_t c)\n /* Condense two variable nodes into a single variable node, by moving\n    all associated info from SRC to TO.  */\n \n-static void \n+static void\n condense_varmap_nodes (unsigned int to, unsigned int src)\n {\n   varinfo_t tovi = get_varinfo (to);\n   varinfo_t srcvi = get_varinfo (src);\n   unsigned int i;\n   constraint_t c;\n   bitmap_iterator bi;\n-  \n+\n   /* the src node, and all its variables, are now the to node.  */\n   srcvi->node = to;\n   EXECUTE_IF_SET_IN_BITMAP (srcvi->variables, 0, i, bi)\n     get_varinfo (i)->node = to;\n-  \n+\n   /* Merge the src node variables and the to node variables.  */\n   bitmap_set_bit (tovi->variables, src);\n   bitmap_ior_into (tovi->variables, srcvi->variables);\n   bitmap_clear (srcvi->variables);\n-  \n+\n   /* Move all complex constraints from src node into to node  */\n   for (i = 0; VEC_iterate (constraint_t, srcvi->complex, i, c); i++)\n     {\n       /* In complex constraints for node src, we may have either\n \t a = *src, and *src = a.  */\n-      \n+\n       if (c->rhs.type == DEREF)\n \tc->rhs.var = to;\n       else\n@@ -746,24 +750,24 @@ clear_edges_for_node (constraint_graph_t graph, unsigned int node)\n   unsigned int j;\n \n   /* Walk the successors, erase the associated preds.  */\n-  \n+\n   EXECUTE_IF_IN_NONNULL_BITMAP (graph->succs[node], 0, j, bi)\n     if (j != node)\n       bitmap_clear_bit (graph->preds[j], node);\n-  \n+\n \n   /* Walk the preds, erase the associated succs.  */\n \n   EXECUTE_IF_IN_NONNULL_BITMAP (graph->preds[node], 0, j, bi)\n     if (j != node)\n       bitmap_clear_bit (graph->succs[j], node);\n-  \n+\n \n   if (graph->preds[node])\n     {\n       BITMAP_FREE (graph->preds[node]);\n       graph->preds[node] = NULL;\n-    } \n+    }\n \n   if (graph->succs[node])\n     {\n@@ -777,7 +781,7 @@ static bool edge_added = false;\n /* Merge GRAPH nodes FROM and TO into node TO.  */\n \n static void\n-merge_graph_nodes (constraint_graph_t graph, unsigned int to, \n+merge_graph_nodes (constraint_graph_t graph, unsigned int to,\n \t\t   unsigned int from)\n {\n   unsigned int j;\n@@ -788,7 +792,7 @@ merge_graph_nodes (constraint_graph_t graph, unsigned int to,\n     {\n       if (!graph->preds[to])\n \tgraph->preds[to] = BITMAP_ALLOC (&predbitmap_obstack);\n-      \n+\n       EXECUTE_IF_SET_IN_BITMAP (graph->preds[from], 0, j, bi)\n \t{\n \t  if (j != to)\n@@ -797,7 +801,7 @@ merge_graph_nodes (constraint_graph_t graph, unsigned int to,\n \t      bitmap_set_bit (graph->succs[j], to);\n \t    }\n \t}\n-      bitmap_ior_into (graph->preds[to], \n+      bitmap_ior_into (graph->preds[to],\n \t\t       graph->preds[from]);\n     }\n \n@@ -811,7 +815,7 @@ merge_graph_nodes (constraint_graph_t graph, unsigned int to,\n \t  bitmap_clear_bit (graph->preds[j], from);\n \t  bitmap_set_bit (graph->preds[j], to);\n \t}\n-      bitmap_ior_into (graph->succs[to], \n+      bitmap_ior_into (graph->succs[to],\n \t\t       graph->succs[from]);\n     }\n \n@@ -833,7 +837,7 @@ add_graph_edge (constraint_graph_t graph, unsigned int to,\n   else\n     {\n       bool r = false;\n-      \n+\n       if (!graph->preds[to])\n \tgraph->preds[to] = BITMAP_ALLOC (&predbitmap_obstack);\n       if (!graph->succs[from])\n@@ -854,10 +858,10 @@ add_graph_edge (constraint_graph_t graph, unsigned int to,\n /* Return true if {DEST.SRC} is an existing graph edge in GRAPH.  */\n \n static bool\n-valid_graph_edge (constraint_graph_t graph, unsigned int src, \n+valid_graph_edge (constraint_graph_t graph, unsigned int src,\n \t\t  unsigned int dest)\n {\n-  return (graph->succs[dest] \n+  return (graph->succs[dest]\n \t  && bitmap_bit_p (graph->succs[dest], src));\n }\n \n@@ -868,6 +872,7 @@ build_constraint_graph (void)\n {\n   int i = 0;\n   constraint_t c;\n+  int graph_size;\n \n   graph = XNEW (struct constraint_graph);\n   graph_size = VEC_length (varinfo_t, varmap) + 1;\n@@ -893,7 +898,7 @@ build_constraint_graph (void)\n \t  if (!(get_varinfo (lhsvar)->is_special_var))\n \t    insert_into_complex (rhsvar, c);\n \t}\n-      else if (rhs.type == ADDRESSOF)\n+      else if (rhs.type == ADDRESSOF || rhs.type == INCLUDES)\n \t{\n \t  /* x = &y */\n \t  bitmap_set_bit (get_varinfo (lhsvar)->solution, rhsvar);\n@@ -909,7 +914,7 @@ build_constraint_graph (void)\n \t      else\n \t\tadd_graph_edge (graph, lhs.var, rhs.var);\n \t    }\n-\t  \n+\n \t}\n     }\n }\n@@ -939,9 +944,9 @@ struct scc_info\n /* Recursive routine to find strongly connected components in GRAPH.\n    SI is the SCC info to store the information in, and N is the id of current\n    graph node we are processing.\n-   \n+\n    This is Tarjan's strongly connected component finding algorithm, as\n-   modified by Nuutila to keep only non-root nodes on the stack.  \n+   modified by Nuutila to keep only non-root nodes on the stack.\n    The algorithm can be found in \"On finding the strongly connected\n    connected components in a directed graph\" by Esko Nuutila and Eljas\n    Soisalon-Soininen, in Information Processing Letters volume 49,\n@@ -957,7 +962,7 @@ scc_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n   SET_BIT (si->visited, n);\n   RESET_BIT (si->in_component, n);\n   si->visited_index[n] = si->current_index ++;\n-  \n+\n   /* Visit all the successors.  */\n   EXECUTE_IF_IN_NONNULL_BITMAP (graph->succs[n], 0, i, bi)\n     {\n@@ -972,39 +977,45 @@ scc_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n \t    get_varinfo (n)->node = t;\n \t}\n     }\n-  \n+\n   /* See if any components have been identified.  */\n   if (get_varinfo (n)->node == n)\n     {\n       unsigned int t = si->visited_index[n];\n       SET_BIT (si->in_component, n);\n-      while (VEC_length (unsigned, si->scc_stack) != 0 \n+      while (VEC_length (unsigned, si->scc_stack) != 0\n \t     && t < si->visited_index[VEC_last (unsigned, si->scc_stack)])\n \t{\n \t  unsigned int w = VEC_pop (unsigned, si->scc_stack);\n \t  get_varinfo (w)->node = n;\n \t  SET_BIT (si->in_component, w);\n \t  /* Mark this node for collapsing.  */\n \t  VEC_safe_push (unsigned, heap, si->unification_queue, w);\n-\t} \n+\t}\n     }\n   else\n     VEC_safe_push (unsigned, heap, si->scc_stack, n);\n }\n \n \n-/* Collapse two variables into one variable.  */\n+/* Collapse two variables into one variable, merging solutions if\n+   requested.  */\n \n static void\n-collapse_nodes (constraint_graph_t graph, unsigned int to, unsigned int from)\n+collapse_nodes (constraint_graph_t graph, unsigned int to, unsigned int from,\n+\t\tbool merge_solutions)\n {\n   bitmap tosol, fromsol;\n \n-  condense_varmap_nodes (to, from);\n-  tosol = get_varinfo (to)->solution;\n-  fromsol = get_varinfo (from)->solution;\n-  bitmap_ior_into (tosol, fromsol);\n   merge_graph_nodes (graph, to, from);\n+  condense_varmap_nodes (to, from);\n+  if (merge_solutions)\n+    {\n+      tosol = get_varinfo (to)->solution;\n+      fromsol = get_varinfo (from)->solution;\n+      bitmap_ior_into (tosol, fromsol);\n+      BITMAP_FREE (fromsol);\n+    }\n \n   if (valid_graph_edge (graph, to, to))\n     {\n@@ -1014,9 +1025,6 @@ collapse_nodes (constraint_graph_t graph, unsigned int to, unsigned int from)\n \t  bitmap_clear_bit (graph->succs[to], to);\n \t}\n     }\n-  BITMAP_FREE (fromsol);\n-  get_varinfo (to)->address_taken |= get_varinfo (from)->address_taken;\n-  get_varinfo (to)->indirect_target |= get_varinfo (from)->indirect_target;\n }\n \n \n@@ -1039,14 +1047,14 @@ process_unification_queue (constraint_graph_t graph, struct scc_info *si,\n      For each component in the queue (components are delineated by\n      when current_queue_element->node != next_queue_element->node):\n \n-        rep = representative node for component\n+\trep = representative node for component\n \n-        For each node (tounify) to be unified in the component,\n-           merge the solution for tounify into tmp bitmap\n+\tFor each node (tounify) to be unified in the component,\n+\t   merge the solution for tounify into tmp bitmap\n \n-           clear solution for tounify\n+\t   clear solution for tounify\n \n-           merge edges from tounify into rep\n+\t   merge edges from tounify into rep\n \n \t   merge complex constraints from tounify into rep\n \n@@ -1055,25 +1063,24 @@ process_unification_queue (constraint_graph_t graph, struct scc_info *si,\n \n \tMerge tmp into solution for rep, marking rep changed if this\n \tchanged rep's solution.\n-\t\n+\n \tDelete any self-edges we now have for rep.  */\n   while (i != VEC_length (unsigned, si->unification_queue))\n     {\n       unsigned int tounify = VEC_index (unsigned, si->unification_queue, i);\n       unsigned int n = get_varinfo (tounify)->node;\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"Unifying %s to %s\\n\", \n+\tfprintf (dump_file, \"Unifying %s to %s\\n\",\n \t\t get_varinfo (tounify)->name,\n \t\t get_varinfo (n)->name);\n       if (update_changed)\n \tstats.unified_vars_dynamic++;\n       else\n \tstats.unified_vars_static++;\n       bitmap_ior_into (tmp, get_varinfo (tounify)->solution);\n-      merge_graph_nodes (graph, n, tounify);\n-      condense_varmap_nodes (n, tounify);\n-      \n+      collapse_nodes (graph, n, tounify, false);\n+\n       if (update_changed && TEST_BIT (changed, tounify))\n \t{\n \t  RESET_BIT (changed, tounify);\n@@ -1172,7 +1179,7 @@ topo_visit (constraint_graph_t graph, struct topo_info *ti,\n   SET_BIT (ti->visited, n);\n   temp = graph->succs[n];\n \n-  if (temp) \n+  if (temp)\n     EXECUTE_IF_SET_IN_BITMAP (temp, 0, j, bi)\n       {\n \tif (!TEST_BIT (ti->visited, j))\n@@ -1183,7 +1190,7 @@ topo_visit (constraint_graph_t graph, struct topo_info *ti,\n \n /* Return true if variable N + OFFSET is a legal field of N.  */\n \n-static bool \n+static bool\n type_safe (unsigned int n, unsigned HOST_WIDE_INT *offset)\n {\n   varinfo_t ninfo = get_varinfo (n);\n@@ -1229,7 +1236,7 @@ do_da_constraint (constraint_graph_t graph ATTRIBUTE_UNUSED,\n \t  t = v->node;\n \t  sol = get_varinfo (t)->solution;\n \t  if (!bitmap_bit_p (sol, rhs))\n-\t    {\t\t  \n+\t    {\n \t      bitmap_set_bit (sol, rhs);\n \t      if (!TEST_BIT (changed, t))\n \t\t{\n@@ -1240,7 +1247,7 @@ do_da_constraint (constraint_graph_t graph ATTRIBUTE_UNUSED,\n \t}\n       else if (0 && dump_file && !(get_varinfo (j)->is_special_var))\n \tfprintf (dump_file, \"Untypesafe usage in do_da_constraint.\\n\");\n-      \n+\n     }\n }\n \n@@ -1264,7 +1271,7 @@ do_sd_constraint (constraint_graph_t graph, constraint_t c,\n        bitmap_set_bit (sol, anything_id);\n      goto done;\n    }\n-  /* For each variable j in delta (Sol(y)), add    \n+  /* For each variable j in delta (Sol(y)), add\n      an edge in the graph from j to x, and union Sol(j) into Sol(x).  */\n   EXECUTE_IF_SET_IN_BITMAP (delta, 0, j, bi)\n     {\n@@ -1289,7 +1296,7 @@ do_sd_constraint (constraint_graph_t graph, constraint_t c,\n \t}\n       else if (0 && dump_file && !(get_varinfo (j)->is_special_var))\n \tfprintf (dump_file, \"Untypesafe usage in do_sd_constraint\\n\");\n-      \n+\n     }\n \n done:\n@@ -1302,7 +1309,7 @@ do_sd_constraint (constraint_graph_t graph, constraint_t c,\n \t  SET_BIT (changed, lhs);\n \t  changed_count++;\n \t}\n-    }    \n+    }\n }\n \n /* Process a constraint C that represents *x = y.  */\n@@ -1330,7 +1337,7 @@ do_ds_constraint (constraint_t c, bitmap delta)\n \t if (!v)\n \t   continue;\n \t t = v->node;\n-\t \n+\n \t if (!bitmap_bit_p (get_varinfo (t)->solution, anything_id))\n \t   {\n \t     bitmap_set_bit (get_varinfo (t)->solution, anything_id);\n@@ -1355,7 +1362,7 @@ do_ds_constraint (constraint_t c, bitmap delta)\n \t  unsigned int t;\n \t  unsigned HOST_WIDE_INT fieldoffset = get_varinfo (j)->offset + loff;\n \t  bitmap tmp;\n-\t  \n+\n \t  v = first_vi_for_offset (get_varinfo (j), fieldoffset);\n \t  if (!v)\n \t    continue;\n@@ -1381,7 +1388,7 @@ do_ds_constraint (constraint_t c, bitmap delta)\n \n /* Handle a non-simple (simple meaning requires no iteration), non-copy\n    constraint (IE *x = &y, x = *y, and *x = y).  */\n-   \n+\n static void\n do_complex_constraint (constraint_graph_t graph, constraint_t c, bitmap delta)\n {\n@@ -1404,9 +1411,9 @@ do_complex_constraint (constraint_graph_t graph, constraint_t c, bitmap delta)\n       if (!(get_varinfo (c->lhs.var)->is_special_var))\n \tdo_sd_constraint (graph, c, delta);\n     }\n-  else \n+  else\n     {\n-      bitmap tmp; \n+      bitmap tmp;\n       bitmap solution;\n       bool flag = false;\n       unsigned int t;\n@@ -1418,7 +1425,7 @@ do_complex_constraint (constraint_graph_t graph, constraint_t c, bitmap delta)\n       tmp = get_varinfo (t)->solution;\n \n       flag = set_union_with_increment (tmp, solution, c->rhs.offset);\n-      \n+\n       if (flag)\n \t{\n \t  get_varinfo (t)->solution = tmp;\n@@ -1454,13 +1461,13 @@ init_scc_info (void)\n \n static void\n free_scc_info (struct scc_info *si)\n-{  \n+{\n   sbitmap_free (si->visited);\n   sbitmap_free (si->in_component);\n   free (si->visited_index);\n   VEC_free (unsigned, heap, si->scc_stack);\n   VEC_free (unsigned, heap, si->unification_queue);\n-  free(si); \n+  free(si);\n }\n \n \n@@ -1479,28 +1486,28 @@ find_and_collapse_graph_cycles (constraint_graph_t graph, bool update_changed)\n   for (i = 0; i != size; ++i)\n     if (!TEST_BIT (si->visited, i) && get_varinfo (i)->node == i)\n       scc_visit (graph, si, i);\n-  \n+\n   process_unification_queue (graph, si, update_changed);\n   free_scc_info (si);\n }\n \n /* Compute a topological ordering for GRAPH, and store the result in the\n    topo_info structure TI.  */\n \n-static void \n+static void\n compute_topo_order (constraint_graph_t graph,\n \t\t    struct topo_info *ti)\n {\n   unsigned int i;\n   unsigned int size = VEC_length (varinfo_t, varmap);\n-  \n+\n   for (i = 0; i != size; ++i)\n     if (!TEST_BIT (ti->visited, i) && get_varinfo (i)->node == i)\n       topo_visit (graph, ti, i);\n }\n \n /* Perform offline variable substitution.\n-   \n+\n    This is a linear time way of identifying variables that must have\n    equivalent points-to sets, including those caused by static cycles,\n    and single entry subgraphs, in the constraint graph.\n@@ -1513,12 +1520,12 @@ static void\n perform_var_substitution (constraint_graph_t graph)\n {\n   struct topo_info *ti = init_topo_info ();\n- \n+\n   bitmap_obstack_initialize (&iteration_obstack);\n   /* Compute the topological ordering of the graph, then visit each\n      node in topological order.  */\n   compute_topo_order (graph, ti);\n- \n+\n   while (VEC_length (unsigned, ti->topo_order) != 0)\n     {\n       unsigned int i = VEC_pop (unsigned, ti->topo_order);\n@@ -1555,7 +1562,7 @@ perform_var_substitution (constraint_graph_t graph)\n \n \t    /* Theorem 4 in Rountev and Chandra: If i is a direct node,\n \t       then Solution(i) is a subset of Solution (w), where w is a\n-\t       predecessor in the graph.  \n+\t       predecessor in the graph.\n \t       Corollary: If all predecessors of i have the same\n \t       points-to set, then i has that same points-to set as\n \t       those predecessors.  */\n@@ -1571,13 +1578,13 @@ perform_var_substitution (constraint_graph_t graph)\n \t    BITMAP_FREE (tmp);\n \t  }\n \n-      /* See if the root is different than the original node. \n+      /* See if the root is different than the original node.\n \t If so, we've found an equivalence.  */\n       if (root != get_varinfo (i)->node && okay_to_elim)\n \t{\n \t  /* Found an equivalence */\n \t  get_varinfo (i)->node = root;\n-\t  collapse_nodes (graph, root, i);\n+\t  collapse_nodes (graph, root, i, true);\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"Collapsing %s into %s\\n\",\n \t\t     get_varinfo (i)->name,\n@@ -1606,21 +1613,21 @@ solve_graph (constraint_graph_t graph)\n   changed_count = size;\n   changed = sbitmap_alloc (size);\n   sbitmap_ones (changed);\n-  \n+\n   /* The already collapsed/unreachable nodes will never change, so we\n      need to  account for them in changed_count.  */\n   for (i = 0; i < size; i++)\n     if (get_varinfo (i)->node != i)\n       changed_count--;\n-  \n+\n   while (changed_count > 0)\n     {\n       unsigned int i;\n       struct topo_info *ti = init_topo_info ();\n       stats.iterations++;\n \n       bitmap_obstack_initialize (&iteration_obstack);\n-      \n+\n       if (edge_added)\n \t{\n \t  /* We already did cycle elimination once, when we did\n@@ -1672,16 +1679,16 @@ solve_graph (constraint_graph_t graph)\n \t      if (!solution_empty)\n \t\t{\n \t\t  /* Propagate solution to all successors.  */\n-\t\t  EXECUTE_IF_IN_NONNULL_BITMAP (graph->succs[i], \n+\t\t  EXECUTE_IF_IN_NONNULL_BITMAP (graph->succs[i],\n \t\t\t\t\t\t0, j, bi)\n \t\t    {\n \t\t      bitmap tmp = get_varinfo (j)->solution;\n \t\t      bool flag = false;\n-\t\t  \n+\n \t\t      gcc_assert (get_varinfo (j)->node == j);\n-\t\t      \n+\n \t\t      flag = set_union_with_increment (tmp, solution, 0);\n-\t\t  \n+\n \t\t      if (flag)\n \t\t\t{\n \t\t\t  get_varinfo (j)->solution = tmp;\n@@ -1698,14 +1705,14 @@ solve_graph (constraint_graph_t graph)\n       free_topo_info (ti);\n       bitmap_obstack_release (&iteration_obstack);\n     }\n-  \n+\n   sbitmap_free (changed);\n }\n \n \n /* CONSTRAINT AND VARIABLE GENERATION FUNCTIONS */\n \n-/* Map from trees to variable ids.  */    \n+/* Map from trees to variable ids.  */\n static htab_t id_for_tree;\n \n typedef struct tree_id\n@@ -1716,7 +1723,7 @@ typedef struct tree_id\n \n /* Hash a tree id structure.  */\n \n-static hashval_t \n+static hashval_t\n tree_id_hash (const void *p)\n {\n   const tree_id_t ta = (tree_id_t) p;\n@@ -1735,13 +1742,13 @@ tree_id_eq (const void *p1, const void *p2)\n \n /* Insert ID as the variable id for tree T in the hashtable.  */\n \n-static void \n+static void\n insert_id_for_tree (tree t, int id)\n {\n   void **slot;\n   struct tree_id finder;\n   tree_id_t new_pair;\n-  \n+\n   finder.t = t;\n   slot = htab_find_slot (id_for_tree, &finder, INSERT);\n   gcc_assert (*slot == NULL);\n@@ -1787,7 +1794,7 @@ alias_get_name (tree decl)\n \n   if (TREE_CODE (decl) == SSA_NAME)\n     {\n-      num_printed = asprintf (&temp, \"%s_%u\", \n+      num_printed = asprintf (&temp, \"%s_%u\",\n \t\t\t      alias_get_name (SSA_NAME_VAR (decl)),\n \t\t\t      SSA_NAME_VERSION (decl));\n     }\n@@ -1816,7 +1823,7 @@ get_id_for_tree (tree t)\n   pair = htab_find (id_for_tree,  &finder);\n   if (pair == NULL)\n     return create_variable_info_for (t, alias_get_name (t));\n-  \n+\n   return pair->id;\n }\n \n@@ -1831,22 +1838,22 @@ get_constraint_exp_from_ssa_var (tree t)\n \n   /* For parameters, get at the points-to set for the actual parm\n      decl.  */\n-  if (TREE_CODE (t) == SSA_NAME \n-      && TREE_CODE (SSA_NAME_VAR (t)) == PARM_DECL \n+  if (TREE_CODE (t) == SSA_NAME\n+      && TREE_CODE (SSA_NAME_VAR (t)) == PARM_DECL\n       && gimple_default_def (cfun, SSA_NAME_VAR (t)) == t)\n     return get_constraint_exp_from_ssa_var (SSA_NAME_VAR (t));\n \n   cexpr.type = SCALAR;\n-  \n+\n   cexpr.var = get_id_for_tree (t);\n   /* If we determine the result is \"anything\", and we know this is readonly,\n      say it points to readonly memory instead.  */\n   if (cexpr.var == anything_id && TREE_READONLY (t))\n     {\n-      cexpr.type = ADDRESSOF;\n+      cexpr.type = INCLUDES;\n       cexpr.var = readonly_id;\n     }\n-    \n+\n   cexpr.offset = 0;\n   return cexpr;\n }\n@@ -1859,27 +1866,36 @@ process_constraint (constraint_t t)\n {\n   struct constraint_expr rhs = t->rhs;\n   struct constraint_expr lhs = t->lhs;\n-  \n+\n   gcc_assert (rhs.var < VEC_length (varinfo_t, varmap));\n   gcc_assert (lhs.var < VEC_length (varinfo_t, varmap));\n \n+  gcc_assert (lhs.type != INCLUDES);\n+\n   if (lhs.type == DEREF)\n     get_varinfo (lhs.var)->directly_dereferenced = true;\n   if (rhs.type == DEREF)\n     get_varinfo (rhs.var)->directly_dereferenced = true;\n-  \n+\n+  if (!use_field_sensitive)\n+    {\n+      t->rhs.offset = 0;\n+      t->lhs.offset = 0;\n+    }\n+\n   /* ANYTHING == ANYTHING is pointless.  */\n   if (lhs.var == anything_id && rhs.var == anything_id)\n     return;\n \n   /* If we have &ANYTHING = something, convert to SOMETHING = &ANYTHING) */\n-  else if (lhs.var == anything_id && lhs.type == ADDRESSOF)\n+  else if (lhs.var == anything_id\n+\t   && (lhs.type == INCLUDES || lhs.type == ADDRESSOF))\n     {\n       rhs = t->lhs;\n       t->lhs = t->rhs;\n       t->rhs = rhs;\n       process_constraint (t);\n-    }   \n+    }\n   /* This can happen in our IR with things like n->a = *p */\n   else if (rhs.type == DEREF && lhs.type == DEREF && rhs.var != anything_id)\n     {\n@@ -1889,26 +1905,23 @@ process_constraint (constraint_t t)\n       tree pointedtotype = TREE_TYPE (pointertype);\n       tree tmpvar = create_tmp_var_raw (pointedtotype, \"doubledereftmp\");\n       struct constraint_expr tmplhs = get_constraint_exp_from_ssa_var (tmpvar);\n-      \n+\n       /* If this is an aggregate of known size, we should have passed\n \t this off to do_structure_copy, and it should have broken it\n \t up.  */\n-      gcc_assert (!AGGREGATE_TYPE_P (pointedtotype) \n+      gcc_assert (!AGGREGATE_TYPE_P (pointedtotype)\n \t\t  || get_varinfo (rhs.var)->is_unknown_size_var);\n-      \n+\n       process_constraint (new_constraint (tmplhs, rhs));\n       process_constraint (new_constraint (lhs, tmplhs));\n     }\n   else if (rhs.type == ADDRESSOF)\n     {\n       varinfo_t vi;\n       gcc_assert (rhs.offset == 0);\n-      \n-      /* No need to mark address taken simply because of escaped vars\n-\t constraints.  */\n-      if (lhs.var != escaped_vars_id)\n-\tfor (vi = get_varinfo (rhs.var); vi != NULL; vi = vi->next)\n-\t  vi->address_taken = true;\n+\n+      for (vi = get_varinfo (rhs.var); vi != NULL; vi = vi->next)\n+\tvi->address_taken = true;\n \n       VEC_safe_push (constraint_t, heap, constraints, t);\n     }\n@@ -1927,7 +1940,7 @@ static bool\n could_have_pointers (tree t)\n {\n   tree type = TREE_TYPE (t);\n-  \n+\n   if (POINTER_TYPE_P (type) || AGGREGATE_TYPE_P (type)\n       || TREE_CODE (type) == COMPLEX_TYPE)\n     return true;\n@@ -1944,9 +1957,9 @@ bitpos_of_field (const tree fdecl)\n   if (TREE_CODE (DECL_FIELD_OFFSET (fdecl)) != INTEGER_CST\n       || TREE_CODE (DECL_FIELD_BIT_OFFSET (fdecl)) != INTEGER_CST)\n     return -1;\n-  \n-  return (tree_low_cst (DECL_FIELD_OFFSET (fdecl), 1) * 8) \n-         + tree_low_cst (DECL_FIELD_BIT_OFFSET (fdecl), 1);\n+\n+  return (tree_low_cst (DECL_FIELD_OFFSET (fdecl), 1) * 8)\n+\t + tree_low_cst (DECL_FIELD_BIT_OFFSET (fdecl), 1);\n }\n \n \n@@ -1965,7 +1978,7 @@ offset_overlaps_with_access (const unsigned HOST_WIDE_INT fieldpos,\n     return true;\n   if (accesspos < fieldpos && (accesspos + accesssize > fieldpos))\n     return true;\n-  \n+\n   return false;\n }\n \n@@ -1988,17 +2001,17 @@ get_constraint_for_component_ref (tree t, VEC(ce_s, heap) **results)\n   while (!SSA_VAR_P (forzero) && !CONSTANT_CLASS_P (forzero))\n     forzero = TREE_OPERAND (forzero, 0);\n \n-  if (CONSTANT_CLASS_P (forzero) && integer_zerop (forzero)) \n+  if (CONSTANT_CLASS_P (forzero) && integer_zerop (forzero))\n     {\n       struct constraint_expr temp;\n-      \n+\n       temp.offset = 0;\n       temp.var = integer_id;\n       temp.type = SCALAR;\n       VEC_safe_push (ce_s, heap, *results, &temp);\n       return;\n     }\n- \n+\n   t = get_ref_base_and_extent (t, &bitpos, &bitsize, &bitmaxsize);\n \n   /* String constants are readonly, so there is nothing to really do\n@@ -2015,21 +2028,21 @@ get_constraint_for_component_ref (tree t, VEC(ce_s, heap) **results)\n   /* This can also happen due to weird offsetof type macros.  */\n   if (TREE_CODE (t) != ADDR_EXPR && result->type == ADDRESSOF)\n     result->type = SCALAR;\n- \n+\n   if (result->type == SCALAR)\n     {\n       /* In languages like C, you can access one past the end of an\n \t array.  You aren't allowed to dereference it, so we can\n \t ignore this constraint. When we handle pointer subtraction,\n \t we may have to do something cute here.  */\n-      \n+\n       if (result->offset < get_varinfo (result->var)->fullsize\n \t  && bitmaxsize != 0)\n \t{\n \t  /* It's also not true that the constraint will actually start at the\n \t     right offset, it may start in some padding.  We only care about\n \t     setting the constraint to the first actual field it touches, so\n-\t     walk to find it.  */ \n+\t     walk to find it.  */\n \t  varinfo_t curr;\n \t  for (curr = get_varinfo (result->var); curr; curr = curr->next)\n \t    {\n@@ -2072,6 +2085,7 @@ do_deref (VEC (ce_s, heap) **constraints)\n {\n   struct constraint_expr *c;\n   unsigned int i = 0;\n+\n   for (i = 0; VEC_iterate (ce_s, *constraints, i, c); i++)\n     {\n       if (c->type == SCALAR)\n@@ -2090,21 +2104,6 @@ do_deref (VEC (ce_s, heap) **constraints)\n     }\n }\n \n-/* Create a nonlocal variable of TYPE to represent nonlocals we can\n-   alias.  */\n-\n-static tree\n-create_nonlocal_var (tree type)\n-{\n-  tree nonlocal = create_tmp_var_raw (type, \"NONLOCAL\");\n-  \n-  if (gimple_referenced_vars (cfun))\n-    add_referenced_var (nonlocal);\n-\n-  DECL_EXTERNAL (nonlocal) = 1;\n-  return nonlocal;\n-}\n-\n /* Given a tree T, return the constraint expression for it.  */\n \n static void\n@@ -2165,7 +2164,7 @@ get_constraint_for (tree t, VEC (ce_s, heap) **results)\n \n \t\t  if (VEC_length (ce_s, *results) == 0)\n \t\t    return;\n-\t\t  \n+\n \t\t  gcc_assert (VEC_length (ce_s, *results) == 1);\n \t\t  origrhs = VEC_last (ce_s, *results);\n \t\t  tmp = *origrhs;\n@@ -2196,12 +2195,12 @@ get_constraint_for (tree t, VEC (ce_s, heap) **results)\n \t\t      VEC_safe_push (ce_s, heap, *results, &tmp);\n \t\t    }\n \t\t}\n-\t      \n+\n \t      for (i = 0; VEC_iterate (ce_s, *results, i, c); i++)\n \t\t{\n \t\t  if (c->type == DEREF)\n \t\t    c->type = SCALAR;\n-\t\t  else \n+\t\t  else\n \t\t    c->type = ADDRESSOF;\n \t\t}\n \t      return;\n@@ -2215,9 +2214,9 @@ get_constraint_for (tree t, VEC (ce_s, heap) **results)\n \t      {\n \t\tvarinfo_t vi;\n \t\ttree heapvar = heapvar_lookup (t);\n-\t\t\n+\n \t\tif (heapvar == NULL)\n-\t\t  {\t\t    \n+\t\t  {\n \t\t    heapvar = create_tmp_var_raw (ptr_type_node, \"HEAP\");\n \t\t    DECL_EXTERNAL (heapvar) = 1;\n \t\t    get_var_ann (heapvar)->is_heapvar = 1;\n@@ -2228,18 +2227,18 @@ get_constraint_for (tree t, VEC (ce_s, heap) **results)\n \n \t\ttemp.var = create_variable_info_for (heapvar,\n \t\t\t\t\t\t     alias_get_name (heapvar));\n-\t\t\n+\n \t\tvi = get_varinfo (temp.var);\n \t\tvi->is_artificial_var = 1;\n \t\tvi->is_heap_var = 1;\n-\t\ttemp.type = ADDRESSOF;\n+\t\ttemp.type = INCLUDES;\n \t\ttemp.offset = 0;\n \t\tVEC_safe_push (ce_s, heap, *results, &temp);\n \t\treturn;\n \t      }\n \t    else\n \t      {\n-\t\ttemp.var = escaped_vars_id;\n+\t\ttemp.var = anything_id;\n \t\ttemp.type = SCALAR;\n \t\ttemp.offset = 0;\n \t\tVEC_safe_push (ce_s, heap, *results, &temp);\n@@ -2290,7 +2289,7 @@ get_constraint_for (tree t, VEC (ce_s, heap) **results)\n \t  case NON_LVALUE_EXPR:\n \t    {\n \t      tree op = TREE_OPERAND (t, 0);\n-\t      \n+\n \t      /* Cast from non-pointer to pointers are bad news for us.\n \t\t Anything else, we see through */\n \t      if (!(POINTER_TYPE_P (TREE_TYPE (t))\n@@ -2316,7 +2315,7 @@ get_constraint_for (tree t, VEC (ce_s, heap) **results)\n       {\n \tswitch (TREE_CODE (t))\n \t  {\n-\t  case PHI_NODE:\t   \n+\t  case PHI_NODE:\n \t    {\n \t      get_constraint_for (PHI_RESULT (t), results);\n \t      return;\n@@ -2360,8 +2359,8 @@ get_constraint_for (tree t, VEC (ce_s, heap) **results)\n \n \n /* Handle the structure copy case where we have a simple structure copy\n-   between LHS and RHS that is of SIZE (in bits) \n-  \n+   between LHS and RHS that is of SIZE (in bits)\n+\n    For each field of the lhs variable (lhsfield)\n      For each field of the rhs variable at lhsfield.offset (rhsfield)\n        add the constraint lhsfield = rhsfield\n@@ -2386,7 +2385,7 @@ do_simple_structure_copy (const struct constraint_expr lhs,\n       struct constraint_expr temprhs = rhs;\n       unsigned HOST_WIDE_INT fieldoffset;\n \n-      templhs.var = p->id;            \n+      templhs.var = p->id;\n       q = get_varinfo (temprhs.var);\n       fieldoffset = p->offset - pstart;\n       q = first_vi_for_offset (q, q->offset + fieldoffset);\n@@ -2401,8 +2400,8 @@ do_simple_structure_copy (const struct constraint_expr lhs,\n \n /* Handle the structure copy case where we have a  structure copy between a\n    aggregate on the LHS and a dereference of a pointer on the RHS\n-   that is of SIZE (in bits) \n-  \n+   that is of SIZE (in bits)\n+\n    For each field of the lhs variable (lhsfield)\n        rhs.offset = lhsfield->offset\n        add the constraint lhsfield = rhs\n@@ -2427,20 +2426,20 @@ do_rhs_deref_structure_copy (const struct constraint_expr lhs,\n \n \n       if (templhs.type == SCALAR)\n-\ttemplhs.var = p->id;      \n+\ttemplhs.var = p->id;\n       else\n \ttemplhs.offset = p->offset;\n-      \n+\n       q = get_varinfo (temprhs.var);\n-      fieldoffset = p->offset - pstart;      \n+      fieldoffset = p->offset - pstart;\n       temprhs.offset += fieldoffset;\n       process_constraint (new_constraint (templhs, temprhs));\n     }\n }\n \n /* Handle the structure copy case where we have a structure copy\n    between a aggregate on the RHS and a dereference of a pointer on\n-   the LHS that is of SIZE (in bits) \n+   the LHS that is of SIZE (in bits)\n \n    For each field of the rhs variable (rhsfield)\n        lhs.offset = rhsfield->offset\n@@ -2466,20 +2465,20 @@ do_lhs_deref_structure_copy (const struct constraint_expr lhs,\n \n \n       if (temprhs.type == SCALAR)\n-\ttemprhs.var = p->id;      \n+\ttemprhs.var = p->id;\n       else\n \ttemprhs.offset = p->offset;\n-      \n+\n       q = get_varinfo (templhs.var);\n-      fieldoffset = p->offset - pstart;      \n+      fieldoffset = p->offset - pstart;\n       templhs.offset += fieldoffset;\n       process_constraint (new_constraint (templhs, temprhs));\n     }\n }\n \n /* Sometimes, frontends like to give us bad type information.  This\n    function will collapse all the fields from VAR to the end of VAR,\n-   into VAR, so that we treat those fields as a single variable. \n+   into VAR, so that we treat those fields as a single variable.\n    We return the variable they were collapsed into.  */\n \n static unsigned int\n@@ -2491,16 +2490,16 @@ collapse_rest_of_var (unsigned int var)\n   for (field = currvar->next; field; field = field->next)\n     {\n       if (dump_file)\n-\tfprintf (dump_file, \"Type safety: Collapsing var %s into %s\\n\", \n+\tfprintf (dump_file, \"Type safety: Collapsing var %s into %s\\n\",\n \t\t field->name, currvar->name);\n-      \n+\n       gcc_assert (!field->collapsed_to);\n       field->collapsed_to = currvar;\n     }\n \n   currvar->next = NULL;\n   currvar->size = currvar->fullsize - currvar->offset;\n-  \n+\n   return currvar->id;\n }\n \n@@ -2522,7 +2521,7 @@ do_structure_copy (tree lhsop, tree rhsop)\n   gcc_assert (VEC_length (ce_s, rhsc) == 1);\n   lhs = *(VEC_last (ce_s, lhsc));\n   rhs = *(VEC_last (ce_s, rhsc));\n-  \n+\n   VEC_free (ce_s, heap, lhsc);\n   VEC_free (ce_s, heap, rhsc);\n \n@@ -2533,7 +2532,7 @@ do_structure_copy (tree lhsop, tree rhsop)\n       lhs = rhs;\n       rhs = tmp;\n     }\n-  \n+\n   /*  This is fairly conservative for the RHS == ADDRESSOF case, in that it's\n       possible it's something we could handle.  However, most cases falling\n       into this are dealing with transparent unions, which are slightly\n@@ -2599,11 +2598,11 @@ do_structure_copy (tree lhsop, tree rhsop)\n       else\n \tlhssize = TREE_INT_CST_LOW (lhstypesize);\n \n-  \n-      if (rhs.type == SCALAR && lhs.type == SCALAR)  \n+\n+      if (rhs.type == SCALAR && lhs.type == SCALAR)\n \t{\n \t  if (!do_simple_structure_copy (lhs, rhs, MIN (lhssize, rhssize)))\n-\t    {\t      \n+\t    {\n \t      lhs.var = collapse_rest_of_var (lhs.var);\n \t      rhs.var = collapse_rest_of_var (rhs.var);\n \t      lhs.offset = 0;\n@@ -2620,7 +2619,7 @@ do_structure_copy (tree lhsop, tree rhsop)\n       else\n \t{\n \t  tree pointedtotype = lhstype;\n-\t  tree tmpvar;  \n+\t  tree tmpvar;\n \n \t  gcc_assert (rhs.type == DEREF && lhs.type == DEREF);\n \t  tmpvar = create_tmp_var_raw (pointedtotype, \"structcopydereftmp\");\n@@ -2705,7 +2704,7 @@ update_alias_info (tree stmt, struct alias_info *ai)\n \t     Currently, they are treated as second-class\n \t     statements.  */\n \t  add_to_addressable_set (TREE_OPERAND (op, 0),\n-                                  &addressable_vars);\n+\t\t\t\t  &addressable_vars);\n \t  continue;\n \t}\n \n@@ -2810,7 +2809,8 @@ update_alias_info (tree stmt, struct alias_info *ai)\n \t  /* If the statement makes a function call, assume\n \t     that pointer OP will be dereferenced in a store\n \t     operation inside the called function.  */\n-\t  if (get_call_expr_in (stmt))\n+\t  if (get_call_expr_in (stmt)\n+\t      || stmt_escape_type == ESCAPE_STORED_IN_GLOBAL)\n \t    {\n \t      bitmap_set_bit (ai->dereferenced_ptrs_store, DECL_UID (var));\n \t      pi->is_dereferenced = 1;\n@@ -2831,9 +2831,9 @@ update_alias_info (tree stmt, struct alias_info *ai)\n       bitmap_set_bit (ai->written_vars, DECL_UID (var));\n       if (may_be_aliased (var))\n \tNUM_REFERENCES_INC (ann);\n-      \n+\n     }\n-  \n+\n   /* Mark variables in V_MAY_DEF operands as being written to.  */\n   FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_VIRTUAL_DEFS)\n     {\n@@ -2885,7 +2885,7 @@ handle_ptr_arith (VEC (ce_s, heap) *lhsc, tree expr)\n     {\n       rhsoffset = TREE_INT_CST_LOW (op1) * BITS_PER_UNIT;\n     }\n-  \n+\n \n   for (i = 0; VEC_iterate (ce_s, lhsc, i, c); i++)\n     for (j = 0; VEC_iterate (ce_s, temp, j, c2); j++)\n@@ -2940,12 +2940,12 @@ find_func_aliases (tree origt)\n \t{\n \t  int i;\n \t  unsigned int j;\n-\t  \n+\n \t  /* For a phi node, assign all the arguments to\n \t     the result.  */\n \t  get_constraint_for (PHI_RESULT (t), &lhsc);\n \t  for (i = 0; i < PHI_NUM_ARGS (t); i++)\n-\t    { \n+\t    {\n \t      tree rhstype;\n \t      tree strippedrhs = PHI_ARG_DEF (t, i);\n \n@@ -2963,20 +2963,20 @@ find_func_aliases (tree origt)\n \t\t      VEC_pop (ce_s, rhsc);\n \t\t    }\n \t\t}\n-\t    } \n+\t    }\n \t}\n     }\n   /* In IPA mode, we need to generate constraints to pass call\n      arguments through their calls.   There are two case, either a\n      modify_expr when we are returning a value, or just a plain\n      call_expr when we are not.   */\n   else if (in_ipa_mode\n-\t   && ((TREE_CODE (t) == MODIFY_EXPR \n+\t   && ((TREE_CODE (t) == MODIFY_EXPR\n \t\t&& TREE_CODE (TREE_OPERAND (t, 1)) == CALL_EXPR\n-\t       && !(call_expr_flags (TREE_OPERAND (t, 1)) \n+\t       && !(call_expr_flags (TREE_OPERAND (t, 1))\n \t\t    & (ECF_MALLOC | ECF_MAY_BE_ALLOCA)))\n-\t       || (TREE_CODE (t) == CALL_EXPR \n-\t\t   && !(call_expr_flags (t) \n+\t       || (TREE_CODE (t) == CALL_EXPR\n+\t\t   && !(call_expr_flags (t)\n \t\t\t& (ECF_MALLOC | ECF_MAY_BE_ALLOCA)))))\n     {\n       tree lhsop;\n@@ -3015,7 +3015,7 @@ find_func_aliases (tree origt)\n \t parameters of the function.  */\n       fi = get_varinfo (varid);\n       arglist = TREE_OPERAND (rhsop, 1);\n-\t\n+\n       for (;arglist; arglist = TREE_CHAIN (arglist))\n \t{\n \t  tree arg = TREE_VALUE (arglist);\n@@ -3049,7 +3049,7 @@ find_func_aliases (tree origt)\n \t  struct constraint_expr rhs;\n \t  struct constraint_expr *lhsp;\n \t  unsigned int j = 0;\n-\t  \n+\n \t  get_constraint_for (lhsop, &lhsc);\n \t  if (TREE_CODE (decl) != FUNCTION_DECL)\n \t    {\n@@ -3065,7 +3065,7 @@ find_func_aliases (tree origt)\n \t    }\n \t  for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n \t    process_constraint (new_constraint (*lhsp, rhs));\n-\t}      \n+\t}\n     }\n   /* Otherwise, just a regular assignment statement.  */\n   else if (TREE_CODE (t) == MODIFY_EXPR)\n@@ -3074,7 +3074,7 @@ find_func_aliases (tree origt)\n       tree rhsop = TREE_OPERAND (t, 1);\n       int i;\n \n-      if ((AGGREGATE_TYPE_P (TREE_TYPE (lhsop)) \n+      if ((AGGREGATE_TYPE_P (TREE_TYPE (lhsop))\n \t   || TREE_CODE (TREE_TYPE (lhsop)) == COMPLEX_TYPE)\n \t  && (AGGREGATE_TYPE_P (TREE_TYPE (rhsop))\n \t      || TREE_CODE (TREE_TYPE (lhsop)) == COMPLEX_TYPE))\n@@ -3093,7 +3093,7 @@ find_func_aliases (tree origt)\n \t\t{\n \t\t  /* RHS that consist of unary operations,\n \t\t     exceptional types, or bare decls/constants, get\n-\t\t     handled directly by get_constraint_for.  */ \n+\t\t     handled directly by get_constraint_for.  */\n \t\t  case tcc_reference:\n \t\t  case tcc_declaration:\n \t\t  case tcc_constant:\n@@ -3108,7 +3108,7 @@ find_func_aliases (tree origt)\n \t\t\t  {\n \t\t\t    struct constraint_expr *c2;\n \t\t\t    unsigned int k;\n-\t\t\t    \n+\n \t\t\t    for (k = 0; VEC_iterate (ce_s, rhsc, k, c2); k++)\n \t\t\t      process_constraint (new_constraint (*c, *c2));\n \t\t\t  }\n@@ -3150,15 +3150,15 @@ find_func_aliases (tree origt)\n \t\t\t      }\n \t\t\t  }\n \t\t      }\n-\t\t}      \n+\t\t}\n \t    }\n \t}\n     }\n \n   /* After promoting variables and computing aliasing we will\n      need to re-scan most statements.  FIXME: Try to minimize the\n      number of statements re-scanned.  It's not really necessary to\n-     re-scan *all* statements.  */  \n+     re-scan *all* statements.  */\n   mark_stmt_modified (origt);\n   VEC_free (ce_s, heap, rhsc);\n   VEC_free (ce_s, heap, lhsc);\n@@ -3171,7 +3171,7 @@ find_func_aliases (tree origt)\n    first field that overlaps with OFFSET.\n    Return NULL if we can't find one.  */\n \n-static varinfo_t \n+static varinfo_t\n first_vi_for_offset (varinfo_t start, unsigned HOST_WIDE_INT offset)\n {\n   varinfo_t curr = start;\n@@ -3197,7 +3197,7 @@ insert_into_field_list (varinfo_t base, varinfo_t field)\n {\n   varinfo_t prev = base;\n   varinfo_t curr = base->next;\n-  \n+\n   field->next = curr;\n   prev->next = field;\n }\n@@ -3210,7 +3210,7 @@ insert_into_field_list_sorted (varinfo_t base, varinfo_t field)\n {\n   varinfo_t prev = base;\n   varinfo_t curr = base->next;\n-  \n+\n   if (curr == NULL)\n     {\n       prev->next = field;\n@@ -3232,13 +3232,13 @@ insert_into_field_list_sorted (varinfo_t base, varinfo_t field)\n \n /* qsort comparison function for two fieldoff's PA and PB */\n \n-static int \n+static int\n fieldoff_compare (const void *pa, const void *pb)\n {\n   const fieldoff_s *foa = (const fieldoff_s *)pa;\n   const fieldoff_s *fob = (const fieldoff_s *)pb;\n   HOST_WIDE_INT foasize, fobsize;\n-  \n+\n   if (foa->offset != fob->offset)\n     return foa->offset - fob->offset;\n \n@@ -3251,8 +3251,8 @@ fieldoff_compare (const void *pa, const void *pb)\n void\n sort_fieldstack (VEC(fieldoff_s,heap) *fieldstack)\n {\n-  qsort (VEC_address (fieldoff_s, fieldstack), \n-\t VEC_length (fieldoff_s, fieldstack), \n+  qsort (VEC_address (fieldoff_s, fieldstack),\n+\t VEC_length (fieldoff_s, fieldstack),\n \t sizeof (fieldoff_s),\n \t fieldoff_compare);\n }\n@@ -3266,12 +3266,12 @@ sort_fieldstack (VEC(fieldoff_s,heap) *fieldstack)\n    TYPE.  */\n \n int\n-push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack, \n+push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n \t\t\t     HOST_WIDE_INT offset, bool *has_union)\n {\n   tree field;\n   int count = 0;\n-  \n+\n   if (TREE_CODE (type) == COMPLEX_TYPE)\n     {\n       fieldoff_s *real_part, *img_part;\n@@ -3280,13 +3280,13 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n       real_part->size = TYPE_SIZE (TREE_TYPE (type));\n       real_part->offset = offset;\n       real_part->decl = NULL_TREE;\n-      \n+\n       img_part = VEC_safe_push (fieldoff_s, heap, *fieldstack, NULL);\n       img_part->type = TREE_TYPE (type);\n       img_part->size = TYPE_SIZE (TREE_TYPE (type));\n       img_part->offset = offset + TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (type)));\n       img_part->decl = NULL_TREE;\n-      \n+\n       return 2;\n     }\n \n@@ -3313,12 +3313,12 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n \t{\n \t  bool push = false;\n \t  int pushed = 0;\n-\t\n-\t  if (has_union \n+\n+\t  if (has_union\n \t      && (TREE_CODE (TREE_TYPE (type)) == QUAL_UNION_TYPE\n \t\t  || TREE_CODE (TREE_TYPE (type)) == UNION_TYPE))\n \t    *has_union = true;\n-\t\n+\n \t  if (!AGGREGATE_TYPE_P (TREE_TYPE (type))) /* var_can_have_subvars */\n \t    push = true;\n \t  else if (!(pushed = push_fields_onto_fieldstack\n@@ -3352,12 +3352,12 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n       {\n \tbool push = false;\n \tint pushed = 0;\n-\t\n-\tif (has_union \n+\n+\tif (has_union\n \t    && (TREE_CODE (TREE_TYPE (field)) == QUAL_UNION_TYPE\n \t\t|| TREE_CODE (TREE_TYPE (field)) == UNION_TYPE))\n \t  *has_union = true;\n-\t\n+\n \tif (!var_can_have_subvars (field))\n \t  push = true;\n \telse if (!(pushed = push_fields_onto_fieldstack\n@@ -3369,7 +3369,7 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n \t     see if we didn't push any subfields and the size is\n \t     nonzero, push the field onto the stack */\n \t  push = true;\n-\t\n+\n \tif (push)\n \t  {\n \t    fieldoff_s *pair;\n@@ -3388,34 +3388,19 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n   return count;\n }\n \n-/* Create a constraint from ESCAPED_VARS variable to VI.  */\n+/* Create a constraint from ANYTHING variable to VI.  */\n static void\n-make_constraint_from_escaped (varinfo_t vi)\n+make_constraint_from_anything (varinfo_t vi)\n {\n   struct constraint_expr lhs, rhs;\n-  \n-  lhs.var = vi->id;\n-  lhs.offset = 0;\n-  lhs.type = SCALAR;\n-  \n-  rhs.var = escaped_vars_id;\n-  rhs.offset = 0;\n-  rhs.type = SCALAR;\n-  process_constraint (new_constraint (lhs, rhs));\n-}\n \n-/* Create a constraint to the ESCAPED_VARS variable from constraint\n-   expression RHS. */\n-\n-static void\n-make_constraint_to_escaped (struct constraint_expr rhs)\n-{\n-  struct constraint_expr lhs;\n-  \n-  lhs.var = escaped_vars_id;\n+  lhs.var = vi->id;\n   lhs.offset = 0;\n   lhs.type = SCALAR;\n \n+  rhs.var = anything_id;\n+  rhs.offset = 0;\n+  rhs.type = INCLUDES;\n   process_constraint (new_constraint (lhs, rhs));\n }\n \n@@ -3428,15 +3413,15 @@ count_num_arguments (tree decl, bool *is_varargs)\n   unsigned int i = 0;\n   tree t;\n \n-  for (t = TYPE_ARG_TYPES (TREE_TYPE (decl)); \n+  for (t = TYPE_ARG_TYPES (TREE_TYPE (decl));\n        t;\n        t = TREE_CHAIN (t))\n-    {\t\n+    {\n       if (TREE_VALUE (t) == void_type_node)\n \tbreak;\n       i++;\n     }\n-  \n+\n   if (!t)\n     *is_varargs = true;\n   return i;\n@@ -3450,7 +3435,7 @@ create_function_info_for (tree decl, const char *name)\n {\n   unsigned int index = VEC_length (varinfo_t, varmap);\n   varinfo_t vi;\n-  tree arg; \n+  tree arg;\n   unsigned int i;\n   bool is_varargs = false;\n \n@@ -3462,7 +3447,7 @@ create_function_info_for (tree decl, const char *name)\n   vi->has_union = 0;\n   vi->size = 1;\n   vi->fullsize = count_num_arguments (decl, &is_varargs) + 1;\n-  insert_id_for_tree (vi->decl, index);  \n+  insert_id_for_tree (vi->decl, index);\n   VEC_safe_push (varinfo_t, heap, varmap, vi);\n \n   stats.total_vars++;\n@@ -3478,12 +3463,12 @@ create_function_info_for (tree decl, const char *name)\n       return index;\n     }\n \n-  \n+\n   arg = DECL_ARGUMENTS (decl);\n \n   /* Set up variables for each argument.  */\n   for (i = 1; i < vi->fullsize; i++)\n-    {      \n+    {\n       varinfo_t argvi;\n       const char *newname;\n       char *tempname;\n@@ -3492,7 +3477,7 @@ create_function_info_for (tree decl, const char *name)\n \n       if (arg)\n \targdecl = arg;\n-      \n+\n       newindex = VEC_length (varinfo_t, varmap);\n       asprintf (&tempname, \"%s.arg%d\", name, i-1);\n       newname = ggc_strdup (tempname);\n@@ -3528,7 +3513,7 @@ create_function_info_for (tree decl, const char *name)\n \n       if (DECL_RESULT (decl))\n \tresultdecl = DECL_RESULT (decl);\n-      \n+\n       newindex = VEC_length (varinfo_t, varmap);\n       asprintf (&tempname, \"%s.result\", name);\n       newname = ggc_strdup (tempname);\n@@ -3547,10 +3532,10 @@ create_function_info_for (tree decl, const char *name)\n \tinsert_id_for_tree (DECL_RESULT (decl), newindex);\n     }\n   return index;\n-}  \n+}\n \n \n-/* Return true if FIELDSTACK contains fields that overlap. \n+/* Return true if FIELDSTACK contains fields that overlap.\n    FIELDSTACK is assumed to be sorted by offset.  */\n \n static bool\n@@ -3569,59 +3554,6 @@ check_for_overlaps (VEC (fieldoff_s,heap) *fieldstack)\n   return false;\n }\n \n-/* This function is called through walk_tree to walk global\n-   initializers looking for constraints we need to add to the\n-   constraint list.  */\n-\n-static tree\n-find_global_initializers (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n-\t\t\t  void *viv)\n-{\n-  varinfo_t vi = (varinfo_t)viv;\n-  tree t = *tp;\n-\n-  switch (TREE_CODE (t))\n-    {\n-      /* Dereferences and addressofs are the only important things\n-\t here, and i don't even remember if dereferences are legal\n-\t here in initializers.  */\n-    case INDIRECT_REF:\n-    case ADDR_EXPR:\n-      {\n-\tstruct constraint_expr *c;\n-\tsize_t i;\n-\t\n-\tVEC(ce_s, heap) *rhsc = NULL;\n-\tget_constraint_for (t, &rhsc);\n-\tfor (i = 0; VEC_iterate (ce_s, rhsc, i, c); i++)\n-\t  {\n-\t    struct constraint_expr lhs;\n-\t    \n-\t    lhs.var = vi->id;\n-\t    lhs.type = SCALAR;\n-\t    lhs.offset = 0;\n-\t    process_constraint (new_constraint (lhs, *c));\n-\t  }\n-\n-\tVEC_free (ce_s, heap, rhsc);\n-      }\n-      break;\n-    case VAR_DECL:\n-      /* We might not have walked this because we skip\n-\t DECL_EXTERNALs during the initial scan.  */\n-      if (gimple_referenced_vars (cfun))\n-\t{\n-\t  get_var_ann (t);\n-\t  if (referenced_var_check_and_insert (t))\n-\t    mark_sym_for_renaming (t);\n-\t}\n-      break;\n-    default:\n-      break;\n-    }\n-  return NULL_TREE;\n-}\n-\n /* Create a varinfo structure for NAME and DECL, and add it to VARMAP.\n    This will also create any varinfo structures necessary for fields\n    of DECL.  */\n@@ -3637,12 +3569,12 @@ create_variable_info_for (tree decl, const char *name)\n   bool hasunion;\n   bool is_global = DECL_P (decl) ? is_global_var (decl) : false;\n   VEC (fieldoff_s,heap) *fieldstack = NULL;\n-  \n+\n   if (TREE_CODE (decl) == FUNCTION_DECL && in_ipa_mode)\n     return create_function_info_for (decl, name);\n \n   hasunion = TREE_CODE (decltype) == UNION_TYPE\n-             || TREE_CODE (decltype) == QUAL_UNION_TYPE;\n+\t     || TREE_CODE (decltype) == QUAL_UNION_TYPE;\n   if (var_can_have_subvars (decl) && use_field_sensitive && !hasunion)\n     {\n       push_fields_onto_fieldstack (decltype, &fieldstack, 0, &hasunion);\n@@ -3652,7 +3584,7 @@ create_variable_info_for (tree decl, const char *name)\n \t  notokay = true;\n \t}\n     }\n-  \n+\n \n   /* If the variable doesn't have subvars, we may end up needing to\n      sort the field list and create fake variables for all the\n@@ -3675,36 +3607,16 @@ create_variable_info_for (tree decl, const char *name)\n       vi->fullsize = TREE_INT_CST_LOW (declsize);\n       vi->size = vi->fullsize;\n     }\n-  \n-  insert_id_for_tree (vi->decl, index);  \n+\n+  insert_id_for_tree (vi->decl, index);\n   VEC_safe_push (varinfo_t, heap, varmap, vi);\n   if (is_global && (!flag_whole_program || !in_ipa_mode))\n-    {\n-      make_constraint_from_escaped (vi);\n-\n-      /* If the variable can't be aliased, there is no point in\n-\t putting it in the set of nonlocal vars.  */\n-      if (may_be_aliased (vi->decl))\n-\t{\n-\t  struct constraint_expr rhs;\n-\t  rhs.var = index;\n-\t  rhs.type = ADDRESSOF;\n-\t  rhs.offset = 0;\n-\t  make_constraint_to_escaped (rhs);\n-\t} \n-\n-      if (TREE_CODE (decl) != FUNCTION_DECL && DECL_INITIAL (decl))\n-\t{\n-\t  walk_tree_without_duplicates (&DECL_INITIAL (decl),\n-\t\t\t\t\tfind_global_initializers,\n-\t\t\t\t\t(void *)vi);\n-\t}\n-    }\n+    make_constraint_from_anything (vi);\n \n   stats.total_vars++;\n-  if (use_field_sensitive \n-      && !notokay \n-      && !vi->is_unknown_size_var \n+  if (use_field_sensitive\n+      && !notokay\n+      && !vi->is_unknown_size_var\n       && var_can_have_subvars (decl)\n       && VEC_length (fieldoff_s, fieldstack) <= MAX_FIELDS_FOR_FIELD_SENSITIVE)\n     {\n@@ -3728,16 +3640,16 @@ create_variable_info_for (tree decl, const char *name)\n \t without creating varinfos for the fields anyway, so sorting them is a\n \t waste to boot.  */\n       if (!notokay)\n-\t{\t\n+\t{\n \t  sort_fieldstack (fieldstack);\n \t  /* Due to some C++ FE issues, like PR 22488, we might end up\n \t     what appear to be overlapping fields even though they,\n \t     in reality, do not overlap.  Until the C++ FE is fixed,\n \t     we will simply disable field-sensitivity for these cases.  */\n \t  notokay = check_for_overlaps (fieldstack);\n \t}\n-      \n-      \n+\n+\n       if (VEC_length (fieldoff_s, fieldstack) != 0)\n \tfo = VEC_index (fieldoff_s, fieldstack, 0);\n \n@@ -3749,11 +3661,11 @@ create_variable_info_for (tree decl, const char *name)\n \t  VEC_free (fieldoff_s, heap, fieldstack);\n \t  return index;\n \t}\n-      \n+\n       vi->size = TREE_INT_CST_LOW (fo->size);\n       vi->offset = fo->offset;\n-      for (i = VEC_length (fieldoff_s, fieldstack) - 1; \n-\t   i >= 1 && VEC_iterate (fieldoff_s, fieldstack, i, fo); \n+      for (i = VEC_length (fieldoff_s, fieldstack) - 1;\n+\t   i >= 1 && VEC_iterate (fieldoff_s, fieldstack, i, fo);\n \t   i--)\n \t{\n \t  varinfo_t newvi;\n@@ -3764,10 +3676,10 @@ create_variable_info_for (tree decl, const char *name)\n \t  if (dump_file)\n \t    {\n \t      if (fo->decl)\n-\t        asprintf (&tempname, \"%s.%s\",\n+\t\tasprintf (&tempname, \"%s.%s\",\n \t\t\t  vi->name, alias_get_name (fo->decl));\n \t      else\n-\t        asprintf (&tempname, \"%s.\" HOST_WIDE_INT_PRINT_DEC,\n+\t\tasprintf (&tempname, \"%s.\" HOST_WIDE_INT_PRINT_DEC,\n \t\t\t  vi->name, fo->offset);\n \t      newname = ggc_strdup (tempname);\n \t      free (tempname);\n@@ -3779,21 +3691,8 @@ create_variable_info_for (tree decl, const char *name)\n \t  insert_into_field_list (vi, newvi);\n \t  VEC_safe_push (varinfo_t, heap, varmap, newvi);\n \t  if (is_global && (!flag_whole_program || !in_ipa_mode))\n-\t    {\n-\t      /* If the variable can't be aliased, there is no point in\n-\t\t putting it in the set of nonlocal vars.  */\n-\t      if (may_be_aliased (vi->decl))\n-\t\t{\n-\t\t  struct constraint_expr rhs;\n-\t      \n-\t\t  rhs.var = newindex;\n-\t\t  rhs.type = ADDRESSOF;\n-\t\t  rhs.offset = 0;\n-\t\t  make_constraint_to_escaped (rhs);\n-\t\t} \n-\t      make_constraint_from_escaped (newvi);\n-\t    }\n-\t  \n+\t      make_constraint_from_anything (newvi);\n+\n \t  stats.total_vars++;\n \t}\n       VEC_free (fieldoff_s, heap, fieldstack);\n@@ -3808,14 +3707,22 @@ dump_solution_for_var (FILE *file, unsigned int var)\n {\n   varinfo_t vi = get_varinfo (var);\n   unsigned int i;\n-  bitmap_iterator bi; \n-  \n-  fprintf (file, \"%s = { \", vi->name);\n-  EXECUTE_IF_SET_IN_BITMAP (get_varinfo (vi->node)->solution, 0, i, bi)\n+  bitmap_iterator bi;\n+\n+  if (vi->node != var)\n     {\n-      fprintf (file, \"%s \", get_varinfo (i)->name);\n+      varinfo_t vipt = get_varinfo (vi->node);\n+      fprintf (file, \"%s = same as %s\\n\", vi->name, vipt->name);\n+    }\n+  else\n+    {\n+      fprintf (file, \"%s = { \", vi->name);\n+      EXECUTE_IF_SET_IN_BITMAP (get_varinfo (vi->node)->solution, 0, i, bi)\n+\t{\n+\t  fprintf (file, \"%s \", get_varinfo (i)->name);\n+\t}\n+      fprintf (file, \"}\\n\");\n     }\n-  fprintf (file, \"}\\n\");\n }\n \n /* Print the points-to solution for VAR to stdout.  */\n@@ -3834,37 +3741,36 @@ intra_create_variable_infos (void)\n {\n   tree t;\n   struct constraint_expr lhs, rhs;\n-  varinfo_t nonlocal_vi;\n \n-  /* For each incoming pointer argument arg, ARG = ESCAPED_VARS or a\n+  /* For each incoming pointer argument arg, ARG = ANYTHING or a\n      dummy variable if flag_argument_noalias > 2. */\n   for (t = DECL_ARGUMENTS (current_function_decl); t; t = TREE_CHAIN (t))\n     {\n       varinfo_t p;\n       unsigned int arg_id;\n-      \n+\n       if (!could_have_pointers (t))\n \tcontinue;\n-      \n+\n       arg_id = get_id_for_tree (t);\n \n       /* With flag_argument_noalias greater than two means that the incoming\n-         argument cannot alias anything except for itself so create a HEAP\n-         variable.  */\n+\t argument cannot alias anything except for itself so create a HEAP\n+\t variable.  */\n       if (POINTER_TYPE_P (TREE_TYPE (t))\n \t  && flag_argument_noalias > 2)\n \t{\n \t  varinfo_t vi;\n \t  tree heapvar = heapvar_lookup (t);\n \t  unsigned int id;\n-\t  \n+\n \t  lhs.offset = 0;\n \t  lhs.type = SCALAR;\n \t  lhs.var  = get_id_for_tree (t);\n-\t  \n+\n \t  if (heapvar == NULL_TREE)\n \t    {\n-\t      heapvar = create_tmp_var_raw (TREE_TYPE (TREE_TYPE (t)), \n+\t      heapvar = create_tmp_var_raw (TREE_TYPE (TREE_TYPE (t)),\n \t\t\t\t\t    \"PARM_NOALIAS\");\n \t      get_var_ann (heapvar)->is_heapvar = 1;\n \t      DECL_EXTERNAL (heapvar) = 1;\n@@ -3877,44 +3783,21 @@ intra_create_variable_infos (void)\n \t  vi->is_artificial_var = 1;\n \t  vi->is_heap_var = 1;\n \t  rhs.var = id;\n-\t  rhs.type = ADDRESSOF;\n+\t  rhs.type = INCLUDES;\n \t  rhs.offset = 0;\n-          for (p = get_varinfo (lhs.var); p; p = p->next)\n+\t  for (p = get_varinfo (lhs.var); p; p = p->next)\n \t    {\n \t      struct constraint_expr temp = lhs;\n \t      temp.var = p->id;\n \t      process_constraint (new_constraint (temp, rhs));\n \t    }\n \t}\n-      else      \n+      else\n \t{\n \t  for (p = get_varinfo (arg_id); p; p = p->next)\n-\t    make_constraint_from_escaped (p);\n+\t    make_constraint_from_anything (p);\n \t}\n     }\n-  if (!gimple_nonlocal_all (cfun))\n-    cfun->gimple_df->nonlocal_all = create_nonlocal_var (void_type_node);\n-\n-  /* Create variable info for the nonlocal var if it does not\n-     exist.  */\n-  nonlocal_vars_id = create_variable_info_for (gimple_nonlocal_all (cfun),\n-\t\t\t\t\t       get_name (gimple_nonlocal_all\n-\t\t\t\t\t\t\t (cfun)));\n-  nonlocal_vi = get_varinfo (nonlocal_vars_id);\n-  nonlocal_vi->is_artificial_var = 1;\n-  nonlocal_vi->is_heap_var = 1; \n-  nonlocal_vi->is_unknown_size_var = 1;\n-  nonlocal_vi->directly_dereferenced = true;\n-\n-  rhs.var = nonlocal_vars_id;\n-  rhs.type = ADDRESSOF;\n-  rhs.offset = 0;\n-  \n-  lhs.var = escaped_vars_id;\n-  lhs.type = SCALAR;\n-  lhs.offset = 0;\n-  \n-  process_constraint (new_constraint (lhs, rhs));\n }\n \n /* Set bits in INTO corresponding to the variable uids in solution set\n@@ -3928,26 +3811,26 @@ set_uids_in_ptset (tree ptr, bitmap into, bitmap from)\n   unsigned int i;\n   bitmap_iterator bi;\n   subvar_t sv;\n-  unsigned HOST_WIDE_INT ptr_alias_set = get_alias_set (TREE_TYPE (ptr));\n+  HOST_WIDE_INT ptr_alias_set = get_alias_set (TREE_TYPE (ptr));\n \n   EXECUTE_IF_SET_IN_BITMAP (from, 0, i, bi)\n     {\n       varinfo_t vi = get_varinfo (i);\n       unsigned HOST_WIDE_INT var_alias_set;\n-      \n+\n       /* The only artificial variables that are allowed in a may-alias\n \t set are heap variables.  */\n       if (vi->is_artificial_var && !vi->is_heap_var)\n \tcontinue;\n-      \n+\n       if (vi->has_union && get_subvars_for_var (vi->decl) != NULL)\n \t{\n \t  /* Variables containing unions may need to be converted to\n \t     their SFT's, because SFT's can have unions and we cannot.  */\n \t  for (sv = get_subvars_for_var (vi->decl); sv; sv = sv->next)\n \t    bitmap_set_bit (into, DECL_UID (sv->var));\n \t}\n-      else if (TREE_CODE (vi->decl) == VAR_DECL \n+      else if (TREE_CODE (vi->decl) == VAR_DECL\n \t       || TREE_CODE (vi->decl) == PARM_DECL)\n \t{\n \t  if (var_can_have_subvars (vi->decl)\n@@ -3985,8 +3868,123 @@ set_uids_in_ptset (tree ptr, bitmap into, bitmap from)\n \n static bool have_alias_info = false;\n \n+/* The list of SMT's that are in use by our pointer variables.  This\n+   is the set of SMT's for all pointers that can point to anything.   */\n+static bitmap used_smts;\n+\n+/* Due to the ordering of points-to set calculation and SMT\n+   calculation being a bit co-dependent, we can't just calculate SMT\n+   used info whenever we want, we have to calculate it around the time\n+   that find_what_p_points_to is called.  */\n+static bool used_smt_calculated;\n+\n+/* Mark which SMT's are in use by points-to anything variables.  */\n+\n+static void\n+set_used_smts (void)\n+{\n+  int i;\n+  varinfo_t vi;\n+  used_smts = BITMAP_ALLOC (&ptabitmap_obstack);\n+\n+  for (i = 0; VEC_iterate (varinfo_t, varmap, i, vi); i++)\n+    {\n+      tree var = vi->decl;\n+      tree smt;\n+      bitmap_iterator bi;\n+      unsigned int j;\n+      var_ann_t va;\n+      struct ptr_info_def *pi = NULL;\n+\n+      if (TREE_CODE (vi->decl) == SSA_NAME)\n+\tpi = SSA_NAME_PTR_INFO (var);\n+\n+      /* Skip the special variables and those without their own\n+\t solution set.  */\n+      if (vi->is_special_var || vi->node != vi->id || !SSA_VAR_P (var)\n+\t  || (pi && !pi->is_dereferenced) \n+\t  || (DECL_P (var) && !may_be_aliased (var)))\n+\tcontinue;\n+\n+      if (TREE_CODE (var) == SSA_NAME)\n+\tvar = SSA_NAME_VAR (var);\n+\n+      va = var_ann (var);\n+      if (!va)\n+\tcontinue;\n+\n+      smt = va->symbol_mem_tag;\n+      if (smt)\n+\t{\n+\t  EXECUTE_IF_SET_IN_BITMAP (vi->solution, 0, j, bi)\n+\t    {\n+\t      if (get_varinfo (j)->is_artificial_var)\n+\t\t{\n+\t\t  bitmap_set_bit (used_smts, DECL_UID (smt));\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  used_smt_calculated = true;\n+}\n+\n+/* Merge the necessary SMT's into the solution set for VI, which is\n+   P's varinfo.  This involves merging all SMT's that are a subset of\n+   the SMT necessary for P. */\n+\n+static void\n+merge_smts_into (tree p, varinfo_t vi)\n+{\n+  unsigned int i;\n+  bitmap_iterator bi;\n+  tree smt;\n+  VEC(tree, gc) *aliases;\n+  tree var = p;\n+\n+  if (TREE_CODE (p) == SSA_NAME)\n+    var = SSA_NAME_VAR (p);\n+\n+  smt = var_ann (var)->symbol_mem_tag;\n+  if (smt)\n+    {\n+      HOST_WIDE_INT smtset = get_alias_set (TREE_TYPE (smt));\n+\n+      /* Need to set the SMT subsets first before this\n+\t will work properly.  */\n+      bitmap_set_bit (vi->finished_solution, DECL_UID (smt));\n+      EXECUTE_IF_SET_IN_BITMAP (used_smts, 0, i, bi)\n+\t{\n+\t  tree newsmt = referenced_var (i);\n+\t  tree newsmttype = TREE_TYPE (newsmt);\n+\n+\t  if (alias_set_subset_of (get_alias_set (newsmttype),\n+\t\t\t\t   smtset))\n+\t    bitmap_set_bit (vi->finished_solution, i);\n+\t}\n+\n+      aliases = var_ann (smt)->may_aliases;\n+      if (aliases)\n+\t{\n+\t  size_t k;\n+\t  tree al;\n+\t  for (k = 0; VEC_iterate (tree, aliases, k, al); k++)\n+\t    bitmap_set_bit (vi->finished_solution,\n+\t\t\t    DECL_UID (al));\n+\t}\n+    }\n+}\n+\n /* Given a pointer variable P, fill in its points-to set, or return\n-   false if we can't.  */\n+   false if we can't.  \n+   Rather than return false for variables that point-to anything, we\n+   instead find the corresponding SMT, and merge in it's aliases.  In\n+   addition to these aliases, we also set the bits for the SMT's\n+   themselves and their subsets, as SMT's are still in use by\n+   non-SSA_NAME's, and pruning may eliminate every one of their\n+   aliases.  In such a case, if we did not include the right set of\n+   SMT's in the points-to set of the variable, we'd end up with\n+   statements that do not conflict but should.  */\n \n bool\n find_what_p_points_to (tree p)\n@@ -3999,8 +3997,8 @@ find_what_p_points_to (tree p)\n \n   /* For parameters, get at the points-to set for the actual parm\n      decl.  */\n-  if (TREE_CODE (p) == SSA_NAME \n-      && TREE_CODE (SSA_NAME_VAR (p)) == PARM_DECL \n+  if (TREE_CODE (p) == SSA_NAME\n+      && TREE_CODE (SSA_NAME_VAR (p)) == PARM_DECL\n       && gimple_default_def (cfun, SSA_NAME_VAR (p)) == p)\n     lookup_p = SSA_NAME_VAR (p);\n \n@@ -4020,17 +4018,21 @@ find_what_p_points_to (tree p)\n \t  if (!var_can_have_subvars (vi->decl)\n \t      || get_subvars_for_var (vi->decl) == NULL)\n \t    return false;\n-\t} \n+\t}\n       else\n \t{\n \t  struct ptr_info_def *pi = get_ptr_info (p);\n \t  unsigned int i;\n \t  bitmap_iterator bi;\n+\t  bool was_pt_anything = false;\n+\n+\t  if (!pi->is_dereferenced)\n+\t    return false;\n \n \t  /* This variable may have been collapsed, let's get the real\n \t     variable.  */\n \t  vi = get_varinfo (vi->node);\n-\t  \n+\n \t  /* Translate artificial variables into SSA_NAME_PTR_INFO\n \t     attributes.  */\n \t  EXECUTE_IF_SET_IN_BITMAP (vi->solution, 0, i, bi)\n@@ -4045,23 +4047,44 @@ find_what_p_points_to (tree p)\n \t\t  if (vi->id == nothing_id)\n \t\t    pi->pt_null = 1;\n \t\t  else if (vi->id == anything_id)\n-\t\t    pi->pt_anything = 1;\n+\t\t    was_pt_anything = 1;\n \t\t  else if (vi->id == readonly_id)\n-\t\t    pi->pt_anything = 1;\n+\t\t    was_pt_anything = 1;\n \t\t  else if (vi->id == integer_id)\n-\t\t    pi->pt_anything = 1;\n+\t\t    was_pt_anything = 1;\n \t\t  else if (vi->is_heap_var)\n \t\t    pi->pt_global_mem = 1;\n \t\t}\n \t    }\n \n-\t  if (pi->pt_anything)\n-\t    return false;\n+\t  /* Share the final set of variables between the SSA_NAME\n+\t     pointer infos for collapsed nodes that are collapsed to\n+\t     non-special variables.  This is because special vars have\n+\t     no real types associated with them, so while we know the\n+\t     pointers are equivalent to them, we need to generate the\n+\t     solution separately since it will include SMT's from the\n+\t     original non-collapsed variable.  */\n+\t  if (!vi->is_special_var && vi->finished_solution)\n+\t    {\n+\t      pi->pt_vars = vi->finished_solution;\n+\t    }\n+\t  else\n+\t    {\n+\t      vi->finished_solution = BITMAP_GGC_ALLOC ();\n \n-\t  if (!pi->pt_vars)\n-\t    pi->pt_vars = BITMAP_GGC_ALLOC ();\n+\t      /* Instead of using pt_anything, we instead merge in the SMT\n+\t\t aliases for the underlying SMT.  */\n+\t      if (was_pt_anything)\n+\t\t{\n+\t\t  if (!used_smt_calculated)\n+\t\t    set_used_smts ();\n+\t\t  merge_smts_into (p, vi);\n+\t\t  pi->pt_global_mem = 1;\n \n-\t  set_uids_in_ptset (vi->decl, pi->pt_vars, vi->solution);\n+\t\t}\n+\t      set_uids_in_ptset (vi->decl, vi->finished_solution, vi->solution);\n+\t      pi->pt_vars = vi->finished_solution;\n+\t    }\n \n \t  if (bitmap_empty_p (pi->pt_vars))\n \t    pi->pt_vars = NULL;\n@@ -4135,7 +4158,7 @@ init_base_vars (void)\n   /* Create the ANYTHING variable, used to represent that a variable\n      points to some unknown piece of memory.  */\n   anything_tree = create_tmp_var_raw (void_type_node, \"ANYTHING\");\n-  var_anything = new_var_info (anything_tree, 1, \"ANYTHING\", 1); \n+  var_anything = new_var_info (anything_tree, 1, \"ANYTHING\", 1);\n   insert_id_for_tree (anything_tree, 1);\n   var_anything->is_artificial_var = 1;\n   var_anything->size = ~0;\n@@ -4146,13 +4169,13 @@ init_base_vars (void)\n   anything_id = 1;\n \n   /* Anything points to anything.  This makes deref constraints just\n-     work in the presence of linked list and other p = *p type loops, \n+     work in the presence of linked list and other p = *p type loops,\n      by saying that *ANYTHING = ANYTHING. */\n   VEC_safe_push (varinfo_t, heap, varmap, var_anything);\n   lhs.type = SCALAR;\n   lhs.var = anything_id;\n   lhs.offset = 0;\n-  rhs.type = ADDRESSOF;\n+  rhs.type = INCLUDES;\n   rhs.var = anything_id;\n   rhs.offset = 0;\n   var_anything->address_taken = true;\n@@ -4161,7 +4184,7 @@ init_base_vars (void)\n      process_constraint ignores all anything = anything constraints, since all\n      but this one are redundant.  */\n   VEC_safe_push (constraint_t, heap, constraints, new_constraint (lhs, rhs));\n-  \n+\n   /* Create the READONLY variable, used to represent that a variable\n      points to readonly memory.  */\n   readonly_tree = create_tmp_var_raw (void_type_node, \"READONLY\");\n@@ -4183,12 +4206,12 @@ init_base_vars (void)\n   lhs.type = SCALAR;\n   lhs.var = readonly_id;\n   lhs.offset = 0;\n-  rhs.type = ADDRESSOF;\n+  rhs.type = INCLUDES;\n   rhs.var = anything_id;\n   rhs.offset = 0;\n-  \n+\n   process_constraint (new_constraint (lhs, rhs));\n-  \n+\n   /* Create the INTEGER variable, used to represent that a variable points\n      to an INTEGER.  */\n   integer_tree = create_tmp_var_raw (void_type_node, \"INTEGER\");\n@@ -4208,34 +4231,11 @@ init_base_vars (void)\n   lhs.type = SCALAR;\n   lhs.var = integer_id;\n   lhs.offset = 0;\n-  rhs.type = ADDRESSOF;\n+  rhs.type = INCLUDES;\n   rhs.var = anything_id;\n   rhs.offset = 0;\n   process_constraint (new_constraint (lhs, rhs));\n-  \n-  /* Create the ESCAPED_VARS variable used to represent variables that\n-     escape this function.  */\n-  escaped_vars_tree = create_tmp_var_raw (void_type_node, \"ESCAPED_VARS\");\n-  var_escaped_vars = new_var_info (escaped_vars_tree, 4, \"ESCAPED_VARS\", 4);\n-  insert_id_for_tree (escaped_vars_tree, 4);\n-  var_escaped_vars->is_artificial_var = 1;\n-  var_escaped_vars->size = ~0;\n-  var_escaped_vars->fullsize = ~0;\n-  var_escaped_vars->offset = 0;\n-  var_escaped_vars->next = NULL;\n-  escaped_vars_id = 4;\n-  VEC_safe_push (varinfo_t, heap, varmap, var_escaped_vars);\n-\n-  /* ESCAPED_VARS = *ESCAPED_VARS */\n-  lhs.type = SCALAR;\n-  lhs.var = escaped_vars_id;\n-  lhs.offset = 0;\n-  rhs.type = DEREF;\n-  rhs.var = escaped_vars_id;\n-  rhs.offset = 0;\n-  process_constraint (new_constraint (lhs, rhs));\n-  \n-}  \n+}\n \n /* Initialize things necessary to perform PTA */\n \n@@ -4245,7 +4245,7 @@ init_alias_vars (void)\n   bitmap_obstack_initialize (&ptabitmap_obstack);\n   bitmap_obstack_initialize (&predbitmap_obstack);\n \n-  constraint_pool = create_alloc_pool (\"Constraint pool\", \n+  constraint_pool = create_alloc_pool (\"Constraint pool\",\n \t\t\t\t       sizeof (struct constraint), 30);\n   variable_info_pool = create_alloc_pool (\"Variable info pool\",\n \t\t\t\t\t  sizeof (struct variable_info), 30);\n@@ -4257,105 +4257,6 @@ init_alias_vars (void)\n   init_base_vars ();\n }\n \n-/* Given a statement STMT, generate necessary constraints to\n-   escaped_vars for the escaping variables.  */\n-\n-static void\n-find_escape_constraints (tree stmt)\n-{\n-  enum escape_type stmt_escape_type = is_escape_site (stmt);\n-  tree rhs;\n-  VEC(ce_s, heap) *rhsc = NULL;\n-  struct constraint_expr *c;\n-  size_t i;\n-\n-  if (stmt_escape_type == NO_ESCAPE)\n-    return;\n-\n-  if (TREE_CODE (stmt) == RETURN_EXPR)\n-    {\n-      /* Returns are either bare, with an embedded MODIFY_EXPR, or\n-\t just a plain old expression.  */\n-      if (!TREE_OPERAND (stmt, 0))\n-\treturn;\n-      if (TREE_CODE (TREE_OPERAND (stmt, 0)) == MODIFY_EXPR)\n-\trhs = TREE_OPERAND (TREE_OPERAND (stmt, 0), 1);\n-      else\n-\trhs = TREE_OPERAND (stmt, 0);\n-\n-      get_constraint_for (rhs, &rhsc);\n-      for (i = 0; VEC_iterate (ce_s, rhsc, i, c); i++)\n-\tmake_constraint_to_escaped (*c);\n-      VEC_free (ce_s, heap, rhsc);\n-      return;\n-    }\n-  else if (TREE_CODE (stmt) == ASM_EXPR)\n-    {\n-      /* Whatever the inputs of the ASM are, escape.  */\n-      tree arg;\n-\n-      for (arg = ASM_INPUTS (stmt); arg; arg = TREE_CHAIN (arg))\n-\t{\n-\t  rhsc = NULL;\n-\t  get_constraint_for (TREE_VALUE (arg), &rhsc);\n-\t  for (i = 0; VEC_iterate (ce_s, rhsc, i, c); i++)\n-\t    make_constraint_to_escaped (*c);\n-\t  VEC_free (ce_s, heap, rhsc);\n-\t}\n-      return;\n-    }\n-  else if (TREE_CODE (stmt) == CALL_EXPR\n-\t   || (TREE_CODE (stmt) == MODIFY_EXPR\n-\t       && TREE_CODE (TREE_OPERAND (stmt, 1)) == CALL_EXPR))\n-    {\n-      /* Calls cause all of the arguments passed in to escape.  */\n-      tree arg;\n-\n-      if (TREE_CODE (stmt) == MODIFY_EXPR)\n-\tstmt = TREE_OPERAND (stmt, 1);\n-      for (arg = TREE_OPERAND (stmt, 1); arg; arg = TREE_CHAIN (arg))\n-\t{\n-\t  if (POINTER_TYPE_P (TREE_TYPE (TREE_VALUE (arg))))\n-\t    {\n-\t      rhsc = NULL;\n-\t      get_constraint_for (TREE_VALUE (arg), &rhsc);\n-\t      for (i = 0; VEC_iterate (ce_s, rhsc, i, c); i++)\n-\t\tmake_constraint_to_escaped (*c);\n-\t      VEC_free (ce_s, heap, rhsc);\n-\t    }\n-\t}\n-      return;\n-    }\n-  else\n-    {\n-      gcc_assert (TREE_CODE (stmt) == MODIFY_EXPR);\n-    }\n-\n-  gcc_assert (stmt_escape_type == ESCAPE_BAD_CAST\n-\t      || stmt_escape_type == ESCAPE_STORED_IN_GLOBAL\n-\t      || stmt_escape_type == ESCAPE_UNKNOWN);\n-  rhs = TREE_OPERAND (stmt, 1);\n-  \n-  /* Look through casts for the real escaping variable.\n-     Constants don't really escape, so ignore them.\n-     Otherwise, whatever escapes must be on our RHS.  */\n-  if (TREE_CODE (rhs) == NOP_EXPR\n-      || TREE_CODE (rhs) == CONVERT_EXPR\n-      || TREE_CODE (rhs) == NON_LVALUE_EXPR)\n-    {\n-      get_constraint_for (TREE_OPERAND (rhs, 0), &rhsc);\n-    }\n-  else if (CONSTANT_CLASS_P (rhs))\n-    return;\n-  else\n-    {\n-      get_constraint_for (rhs, &rhsc);\n-    }\n-  for (i = 0; VEC_iterate (ce_s, rhsc, i, c); i++)\n-    make_constraint_to_escaped (*c);\n-  VEC_free (ce_s, heap, rhsc);\n-}\n-\n /* Create points-to sets for the current function.  See the comments\n    at the start of the file for an algorithmic overview.  */\n \n@@ -4373,7 +4274,7 @@ compute_points_to_sets (struct alias_info *ai)\n   /* Now walk all statements and derive aliases.  */\n   FOR_EACH_BB (bb)\n     {\n-      block_stmt_iterator bsi; \n+      block_stmt_iterator bsi;\n       tree phi;\n \n       for (phi = phi_nodes (bb); phi; phi = TREE_CHAIN (phi))\n@@ -4394,7 +4295,6 @@ compute_points_to_sets (struct alias_info *ai)\n \t  tree stmt = bsi_stmt (bsi);\n \n \t  find_func_aliases (stmt);\n-\t  find_escape_constraints (stmt);\n \t  /* Update various related attributes like escaped\n \t     addresses, pointer dereferences for loads and stores.\n \t     This is used when creating name tags and alias\n@@ -4410,23 +4310,25 @@ compute_points_to_sets (struct alias_info *ai)\n       fprintf (dump_file, \"Points-to analysis\\n\\nConstraints:\\n\\n\");\n       dump_constraints (dump_file);\n     }\n-  \n+\n   if (dump_file)\n     fprintf (dump_file,\n \t     \"\\nCollapsing static cycles and doing variable \"\n \t     \"substitution:\\n\");\n-      \n+\n   find_and_collapse_graph_cycles (graph, false);\n   perform_var_substitution (graph);\n-      \n+\n   if (dump_file)\n     fprintf (dump_file, \"\\nSolving graph:\\n\");\n-      \n+\n   solve_graph (graph);\n-  \n+\n+  used_smt_calculated = false;\n+\n   if (dump_file)\n     dump_sa_points_to_info (dump_file);\n-  \n+\n   have_alias_info = true;\n \n   timevar_pop (TV_TREE_PTA);\n@@ -4440,27 +4342,22 @@ delete_points_to_sets (void)\n {\n   varinfo_t v;\n   int i;\n-  \n+\n   htab_delete (id_for_tree);\n   bitmap_obstack_release (&ptabitmap_obstack);\n   bitmap_obstack_release (&predbitmap_obstack);\n   VEC_free (constraint_t, heap, constraints);\n-  \n+\n   for (i = 0; VEC_iterate (varinfo_t, varmap, i, v); i++)\n-    {\n-      /* Nonlocal vars may add more varinfos.  */\n-      if (i >= graph_size)\n-\tbreak;\n+    VEC_free (constraint_t, heap, v->complex);\n \n-      VEC_free (constraint_t, heap, v->complex);\n-    }\n   free (graph->preds);\n   free (graph->succs);\n   free (graph);\n \n   VEC_free (varinfo_t, heap, varmap);\n   free_alloc_pool (variable_info_pool);\n-  free_alloc_pool (constraint_pool); \n+  free_alloc_pool (constraint_pool);\n   have_alias_info = false;\n }\n \n@@ -4469,7 +4366,7 @@ static bool\n gate_ipa_pta (void)\n {\n   return (flag_unit_at_a_time != 0\n-          && flag_ipa_pta\n+\t  && flag_ipa_pta\n \t  /* Don't bother doing anything if the program has errors.  */\n \t  && !(errorcount || sorrycount));\n }\n@@ -4482,20 +4379,20 @@ ipa_pta_execute (void)\n   in_ipa_mode = 1;\n   init_alias_heapvars ();\n   init_alias_vars ();\n-   \n+\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n       if (!node->analyzed || cgraph_is_master_clone (node))\n \t{\n \t  unsigned int varid;\n-\t  \n-\t  varid = create_function_info_for (node->decl, \n+\n+\t  varid = create_function_info_for (node->decl,\n \t\t\t\t\t    cgraph_node_name (node));\n \t  if (node->local.externally_visible)\n \t    {\n \t      varinfo_t fi = get_varinfo (varid);\n \t      for (; fi; fi = fi->next)\n-\t\tmake_constraint_from_escaped (fi);\n+\t\tmake_constraint_from_anything (fi);\n \t    }\n \t}\n     }\n@@ -4507,33 +4404,33 @@ ipa_pta_execute (void)\n \t  basic_block bb;\n \t  tree old_func_decl = current_function_decl;\n \t  if (dump_file)\n-\t    fprintf (dump_file, \n-\t\t     \"Generating constraints for %s\\n\", \n-\t\t     cgraph_node_name (node)); \n+\t    fprintf (dump_file,\n+\t\t     \"Generating constraints for %s\\n\",\n+\t\t     cgraph_node_name (node));\n \t  push_cfun (cfun);\n \t  current_function_decl = node->decl;\n \n \t  FOR_EACH_BB_FN (bb, cfun)\n \t    {\n-\t      block_stmt_iterator bsi; \n+\t      block_stmt_iterator bsi;\n \t      tree phi;\n-\t      \n+\n \t      for (phi = phi_nodes (bb); phi; phi = TREE_CHAIN (phi))\n \t\t{\n \t\t  if (is_gimple_reg (PHI_RESULT (phi)))\n \t\t    {\n \t\t      find_func_aliases (phi);\n \t\t    }\n \t\t}\n-\t      \n+\n \t      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n \t\t{\n \t\t  tree stmt = bsi_stmt (bsi);\n \t\t  find_func_aliases (stmt);\n \t\t}\n-\t    }\t\n+\t    }\n \t  current_function_decl = old_func_decl;\n-\t  pop_cfun ();\t  \n+\t  pop_cfun ();\n \t}\n       else\n \t{\n@@ -4548,28 +4445,30 @@ ipa_pta_execute (void)\n       fprintf (dump_file, \"Points-to analysis\\n\\nConstraints:\\n\\n\");\n       dump_constraints (dump_file);\n     }\n-  \n+\n   if (dump_file)\n-    fprintf (dump_file, \n+    fprintf (dump_file,\n \t     \"\\nCollapsing static cycles and doing variable \"\n \t     \"substitution:\\n\");\n-      \n+\n   find_and_collapse_graph_cycles (graph, false);\n   perform_var_substitution (graph);\n-      \n+\n   if (dump_file)\n     fprintf (dump_file, \"\\nSolving graph:\\n\");\n-      \n+\n   solve_graph (graph);\n-  \n+  set_used_smts ();\n+\n   if (dump_file)\n     dump_sa_points_to_info (dump_file);\n+\n   in_ipa_mode = 0;\n   delete_alias_heapvars ();\n   delete_points_to_sets ();\n   return 0;\n }\n-  \n+\n struct tree_opt_pass pass_ipa_pta =\n {\n   \"pta\",\t\t                /* name */\n@@ -4593,15 +4492,13 @@ init_alias_heapvars (void)\n {\n   heapvar_for_stmt = htab_create_ggc (11, tree_map_hash, tree_map_eq,\n \t\t\t\t      NULL);\n-  cfun->gimple_df->nonlocal_all = NULL_TREE;\n }\n \n void\n delete_alias_heapvars (void)\n {\n-  cfun->gimple_df->nonlocal_all = NULL_TREE;\n   htab_delete (heapvar_for_stmt);\n }\n \n-  \n+\n #include \"gt-tree-ssa-structalias.h\""}, {"sha": "470427180696f7504cbbb37777533855144e0c57", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 0, "deletions": 126, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c58936b6b75bfea1b486a7040081e423e58a56de/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c58936b6b75bfea1b486a7040081e423e58a56de/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=c58936b6b75bfea1b486a7040081e423e58a56de", "patch": "@@ -488,131 +488,6 @@ verify_flow_sensitive_alias_info (void)\n   internal_error (\"verify_flow_sensitive_alias_info failed\");\n }\n \n-DEF_VEC_P (bitmap);\n-DEF_VEC_ALLOC_P (bitmap,heap);\n-\n-/* Verify that all name tags have different points to sets.\n-   This algorithm takes advantage of the fact that every variable with the\n-   same name tag must have the same points-to set. \n-   So we check a single variable for each name tag, and verify that its\n-   points-to set is different from every other points-to set for other name\n-   tags.\n-\n-   Additionally, given a pointer P_i with name tag NMT and symbol tag\n-   SMT, this function verified the alias set of SMT is a superset of\n-   the alias set of NMT.  */\n-\n-static void\n-verify_name_tags (void)\n-{\n-  size_t i;  \n-  size_t j;\n-  bitmap first, second;  \n-  VEC(tree,heap) *name_tag_reps = NULL;\n-  VEC(bitmap,heap) *pt_vars_for_reps = NULL;\n-  bitmap type_aliases = BITMAP_ALLOC (NULL);\n-\n-  /* First we compute the name tag representatives and their points-to sets.  */\n-  for (i = 0; i < num_ssa_names; i++)\n-    {\n-      struct ptr_info_def *pi;\n-      tree smt, ptr = ssa_name (i);\n-\n-      if (ptr == NULL_TREE)\n-\tcontinue;\n-      \n-      pi = SSA_NAME_PTR_INFO (ptr);\n-\n-      if (!TREE_VISITED (ptr) \n-\t  || !POINTER_TYPE_P (TREE_TYPE (ptr)) \n-\t  || !pi\n-\t  || !pi->name_mem_tag \n-\t  || TREE_VISITED (pi->name_mem_tag))\n-\tcontinue;\n-\n-      TREE_VISITED (pi->name_mem_tag) = 1;\n-\n-      if (pi->pt_vars == NULL)\n-\tcontinue;\n-\n-      VEC_safe_push (tree, heap, name_tag_reps, ptr);\n-      VEC_safe_push (bitmap, heap, pt_vars_for_reps, pi->pt_vars);\n-\n-      /* Verify that alias set of PTR's symbol tag is a superset of the\n-\t alias set of PTR's name tag.  */\n-      smt = var_ann (SSA_NAME_VAR (ptr))->symbol_mem_tag;\n-      if (smt)\n-\t{\n-\t  size_t i;\n-\t  VEC(tree,gc) *aliases = var_ann (smt)->may_aliases;\n-\t  tree alias;\n-\n-\t  bitmap_clear (type_aliases);\n-\t  for (i = 0; VEC_iterate (tree, aliases, i, alias); i++)\n-\t    bitmap_set_bit (type_aliases, DECL_UID (alias));\n-\n-\t  /* When grouping, we may have added PTR's symbol tag into the\n-\t     alias set of PTR's name tag.  To prevent a false\n-\t     positive, pretend that SMT is in its own alias set.  */\n-\t  bitmap_set_bit (type_aliases, DECL_UID (smt));\n-\n-\t  if (bitmap_equal_p (type_aliases, pi->pt_vars))\n-\t    continue;\n-\n-\t  if (!bitmap_intersect_compl_p (type_aliases, pi->pt_vars))\n-\t    {\n-\t      error (\"alias set of a pointer's symbol tag should be a superset of the corresponding name tag\");\n-\t      debug_variable (smt);\n-\t      debug_variable (pi->name_mem_tag);\n-\t      goto err;\n-\t    }\n-\t}\n-    }\n-  \n-  /* Now compare all the representative bitmaps with all other representative\n-     bitmaps, to verify that they are all different.  */\n-  for (i = 0; VEC_iterate (bitmap, pt_vars_for_reps, i, first); i++)\n-    {\n-       for (j = i + 1; VEC_iterate (bitmap, pt_vars_for_reps, j, second); j++)\n-\t { \n-\t   if (bitmap_equal_p (first, second))\n-\t     {\n-\t       error (\"two different pointers with identical points-to sets but different name tags\");\n-\t       debug_variable (VEC_index (tree, name_tag_reps, j));\n-\t       goto err;\n-\t     }\n-\t }\n-    }\n-\n-  /* Lastly, clear out the visited flags.  */\n-  for (i = 0; i < num_ssa_names; i++)\n-    {\n-      if (ssa_name (i))\n-\t{\n-\t  tree ptr = ssa_name (i);\n-\t  struct ptr_info_def *pi = SSA_NAME_PTR_INFO (ptr);\n-\t  if (!TREE_VISITED (ptr) \n-\t      || !POINTER_TYPE_P (TREE_TYPE (ptr)) \n-\t      || !pi\n-\t      || !pi->name_mem_tag)\n-\t    continue;\n-\t  TREE_VISITED (pi->name_mem_tag) = 0;\n-\t}\n-    } \n-\n-  /* We do not have to free the bitmaps or trees in the vectors, as\n-     they are not owned by us.  */\n-  VEC_free (bitmap, heap, pt_vars_for_reps);\n-  VEC_free (tree, heap, name_tag_reps);\n-  BITMAP_FREE (type_aliases);\n-  return;\n-  \n-err:\n-  debug_variable (VEC_index (tree, name_tag_reps, i));\n-  internal_error (\"verify_name_tags failed\");\n-}\n-\n-\n /* Verify the consistency of call clobbering information.  */\n static void\n verify_call_clobbering (void)\n@@ -659,7 +534,6 @@ static void\n verify_alias_info (void)\n {\n   verify_flow_sensitive_alias_info ();\n-  verify_name_tags ();\n   verify_call_clobbering ();\n   verify_flow_insensitive_alias_info ();\n }"}]}