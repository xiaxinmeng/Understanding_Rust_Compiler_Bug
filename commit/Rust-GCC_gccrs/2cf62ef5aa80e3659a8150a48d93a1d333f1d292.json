{"sha": "2cf62ef5aa80e3659a8150a48d93a1d333f1d292", "node_id": "C_kwDOANBUbNoAKDJjZjYyZWY1YWE4MGUzNjU5YTgxNTBhNDhkOTNhMWQzMzNmMWQyOTI", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-12-14T17:23:32Z"}, "committer": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-12-14T17:23:32Z"}, "message": "rs6000: Remove new_builtins_are_live and dead code it was guarding\n\nTo allow for a sane switch-over from the old built-in infrastructure to the\nnew, both sets of code have co-existed, with the enabled one under the control\nof the boolean variable new_builtins_are_live.  As a first step in removing the\nold code, remove this variable and the now-dead code it was guarding.\n\n2021-12-06  Bill Schmidt  <wschmidt@linux.ibm.com>\n\ngcc/\n\t* config/rs6000/darwin.h (SUBTARGET_INIT_BUILTINS): Remove\n\ttest for new_builtins_are_live and simplify.\n\t* config/rs6000/rs6000-c.c (altivec_build_resolved_builtin): Remove\n\tdead function.\n\t(altivec_resolve_overloaded_builtin): Remove test for\n\tnew_builtins_are_live and simplify.\n\t* config/rs6000/rs6000-call.c (altivec_init_builtins): Remove forward\n\tdeclaration.\n\t(builtin_function_type): Likewise.\n\t(rs6000_common_init_builtins): Likewise.\n\t(htm_init_builtins): Likewise.\n\t(mma_init_builtins): Likewise.\n\t(def_builtin): Remove dead function.\n\t(rs6000_expand_zeroop_builtin): Likewise.\n\t(rs6000_expand_mtfsf_builtin): Likewise.\n\t(rs6000_expand_mtfsb_builtin): Likewise.\n\t(rs6000_expand_set_fpscr_rn_builtin): Likewise.\n\t(rs6000_expand_set_fpscr_drn_builtin): Likewise.\n\t(rs6000_expand_unop_builtin): Likewise.\n\t(altivec_expand_abs_builtin): Likewise.\n\t(rs6000_expand_binop_builtin): Likewise.\n\t(altivec_expand_lxvr_builtin): Likewise.\n\t(altivec_expand_lv_builtin): Likewise.\n\t(altivec_expand_stxvl_builtin): Likewise.\n\t(altivec_expand_stv_builtin): Likewise.\n\t(mma_expand_builtin): Likewise.\n\t(htm_expand_builtin): Likewise.\n\t(cpu_expand_builtin): Likewise.\n\t(rs6000_expand_quaternop_builtin): Likewise.\n\t(rs6000_expand_ternop_builtin): Likewise.\n\t(altivec_expand_dst_builtin): Likewise.\n\t(altivec_expand_vec_sel_builtin): Likewise.\n\t(altivec_expand_builtin): Likewise.\n\t(rs6000_invalid_builtin): Likewise.\n\t(rs6000_builtin_valid_without_lhs): Likewise.\n\t(rs6000_gimple_fold_builtin): Remove test for new_builtins_are_live and\n\tsimplify.\n\t(rs6000_expand_builtin): Likewise.\n\t(rs6000_init_builtins): Remove tests for new_builtins_are_live and\n\tsimplify.\n\t(rs6000_builtin_decl): Likewise.\n\t(altivec_init_builtins): Remove dead function.\n\t(mma_init_builtins): Likewise.\n\t(htm_init_builtins): Likewise.\n\t(builtin_quaternary_function_type): Likewise.\n\t(builtin_function_type): Likewise.\n\t(rs6000_common_init_builtins): Likewise.\n\t* config/rs6000/rs6000-gen-builtins.c (write_header_file): Don't\n\tdeclare new_builtins_are_live.\n\t(write_init_bif_table): In generated code, remove test for\n\tnew_builtins_are_live and simplify.\n\t(write_init_ovld_table): Likewise.\n\t(write_init_file): Don't initialize new_builtins_are_live.\n\t* config/rs6000/rs6000.c (rs6000_builtin_vectorized_function): Remove\n\ttest for new_builtins_are_live and simplify.\n\t(rs6000_builtin_md_vectorized_function): Likewise.\n\t(rs6000_builtin_reciprocal): Likewise.\n\t(add_condition_to_bb): Likewise.\n\t(rs6000_atomic_assign_expand_fenv): Likewise.", "tree": {"sha": "ccb2c24d02af742f438f36f53a5cd35acc1e8838", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ccb2c24d02af742f438f36f53a5cd35acc1e8838"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2cf62ef5aa80e3659a8150a48d93a1d333f1d292", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cf62ef5aa80e3659a8150a48d93a1d333f1d292", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cf62ef5aa80e3659a8150a48d93a1d333f1d292", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cf62ef5aa80e3659a8150a48d93a1d333f1d292/comments", "author": null, "committer": null, "parents": [{"sha": "936051f9241ee2eafae8f5b8a4ad99fd7ed693bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/936051f9241ee2eafae8f5b8a4ad99fd7ed693bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/936051f9241ee2eafae8f5b8a4ad99fd7ed693bc"}], "stats": {"total": 12958, "additions": 3208, "deletions": 9750}, "files": [{"sha": "7bc1009a523f41ebc37e1856e737e8f3d8f20e58", "filename": "gcc/config/rs6000/darwin.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cf62ef5aa80e3659a8150a48d93a1d333f1d292/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cf62ef5aa80e3659a8150a48d93a1d333f1d292/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdarwin.h?ref=2cf62ef5aa80e3659a8150a48d93a1d333f1d292", "patch": "@@ -507,12 +507,8 @@\n #define SUBTARGET_INIT_BUILTINS\t\t\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n   darwin_patch_builtins ();\t\t\t\t\t\t\\\n-  if (new_builtins_are_live)\t\t\t\t\t\t\\\n-    rs6000_builtin_decls_x[(unsigned) (RS6000_BIF_CFSTRING)]\t\t\\\n-      = darwin_init_cfstring_builtins ((unsigned) (RS6000_BIF_CFSTRING)); \\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    rs6000_builtin_decls[(unsigned) (RS6000_BUILTIN_CFSTRING)]\t\t\\\n-      = darwin_init_cfstring_builtins ((unsigned) (RS6000_BUILTIN_CFSTRING)); \\\n+  rs6000_builtin_decls_x[(unsigned) (RS6000_BIF_CFSTRING)]\t\t\\\n+    = darwin_init_cfstring_builtins ((unsigned) (RS6000_BIF_CFSTRING)); \\\n } while(0)\n \n /* So far, there is no rs6000_fold_builtin, if one is introduced, then"}, {"sha": "d44edf585aa350ef4cfe6897ce01311c6da4ef9b", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 1, "deletions": 1083, "changes": 1084, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cf62ef5aa80e3659a8150a48d93a1d333f1d292/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cf62ef5aa80e3659a8150a48d93a1d333f1d292/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=2cf62ef5aa80e3659a8150a48d93a1d333f1d292", "patch": "@@ -873,1096 +873,14 @@ fully_fold_convert (tree type, tree expr)\n   return result;\n }\n \n-/* Build a tree for a function call to an Altivec non-overloaded builtin.\n-   The overloaded builtin that matched the types and args is described\n-   by DESC.  The N arguments are given in ARGS, respectively.  \n-\n-   Actually the only thing it does is calling fold_convert on ARGS, with\n-   a small exception for vec_{all,any}_{ge,le} predicates. */\n-\n-static tree\n-altivec_build_resolved_builtin (tree *args, int n,\n-\t\t\t\tconst struct altivec_builtin_types *desc)\n-{\n-  tree impl_fndecl = rs6000_builtin_decls[desc->overloaded_code];\n-  tree ret_type = rs6000_builtin_type (desc->ret_type);\n-  tree argtypes = TYPE_ARG_TYPES (TREE_TYPE (impl_fndecl));\n-  tree arg_type[4];\n-  tree call;\n-\n-  int i;\n-  for (i = 0; i < n; i++)\n-    arg_type[i] = TREE_VALUE (argtypes), argtypes = TREE_CHAIN (argtypes);\n-\n-  /* The AltiVec overloading implementation is overall gross, but this\n-     is particularly disgusting.  The vec_{all,any}_{ge,le} builtins\n-     are completely different for floating-point vs. integer vector\n-     types, because the former has vcmpgefp, but the latter should use\n-     vcmpgtXX.\n-\n-     In practice, the second and third arguments are swapped, and the\n-     condition (LT vs. EQ, which is recognizable by bit 1 of the first\n-     argument) is reversed.  Patch the arguments here before building\n-     the resolved CALL_EXPR.  */\n-  if (n == 3\n-      && desc->code == ALTIVEC_BUILTIN_VEC_VCMPGE_P\n-      && desc->overloaded_code != ALTIVEC_BUILTIN_VCMPGEFP_P\n-      && desc->overloaded_code != VSX_BUILTIN_XVCMPGEDP_P)\n-    {\n-      std::swap (args[1], args[2]);\n-      std::swap (arg_type[1], arg_type[2]);\n-\n-      args[0] = fold_build2 (BIT_XOR_EXPR, TREE_TYPE (args[0]), args[0],\n-\t\t\t     build_int_cst (NULL_TREE, 2));\n-    }\n-\n-  switch (n)\n-    {\n-    case 0:\n-      call = build_call_expr (impl_fndecl, 0);\n-      break;\n-    case 1:\n-      call = build_call_expr (impl_fndecl, 1,\n-\t\t\t      fully_fold_convert (arg_type[0], args[0]));\n-      break;\n-    case 2:\n-      call = build_call_expr (impl_fndecl, 2,\n-\t\t\t      fully_fold_convert (arg_type[0], args[0]),\n-\t\t\t      fully_fold_convert (arg_type[1], args[1]));\n-      break;\n-    case 3:\n-      call = build_call_expr (impl_fndecl, 3,\n-\t\t\t      fully_fold_convert (arg_type[0], args[0]),\n-\t\t\t      fully_fold_convert (arg_type[1], args[1]),\n-\t\t\t      fully_fold_convert (arg_type[2], args[2]));\n-      break;\n-    case 4:\n-      call = build_call_expr (impl_fndecl, 4,\n-\t\t\t      fully_fold_convert (arg_type[0], args[0]),\n-\t\t\t      fully_fold_convert (arg_type[1], args[1]),\n-\t\t\t      fully_fold_convert (arg_type[2], args[2]),\n-\t\t\t      fully_fold_convert (arg_type[3], args[3]));\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-  return fold_convert (ret_type, call);\n-}\n-\n /* Implementation of the resolve_overloaded_builtin target hook, to\n    support Altivec's overloaded builtins.  */\n \n tree\n altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t\t\t\t    void *passed_arglist)\n {\n-  if (new_builtins_are_live)\n-    return altivec_resolve_new_overloaded_builtin (loc, fndecl,\n-\t\t\t\t\t\t   passed_arglist);\n-\n-  vec<tree, va_gc> *arglist = static_cast<vec<tree, va_gc> *> (passed_arglist);\n-  unsigned int nargs = vec_safe_length (arglist);\n-  enum rs6000_builtins fcode\n-    = (enum rs6000_builtins) DECL_MD_FUNCTION_CODE (fndecl);\n-  tree fnargs = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n-  tree types[4], args[4];\n-  const struct altivec_builtin_types *desc;\n-  unsigned int n;\n-\n-  if (!rs6000_overloaded_builtin_p (fcode))\n-    return NULL_TREE;\n-\n-  if (TARGET_DEBUG_BUILTIN)\n-    fprintf (stderr, \"altivec_resolve_overloaded_builtin, code = %4d, %s\\n\",\n-\t     (int)fcode, IDENTIFIER_POINTER (DECL_NAME (fndecl)));\n- \n-  /* vec_lvsl and vec_lvsr are deprecated for use with LE element order.  */\n-  if (fcode == ALTIVEC_BUILTIN_VEC_LVSL && !BYTES_BIG_ENDIAN)\n-    warning (OPT_Wdeprecated,\n-\t     \"%<vec_lvsl%> is deprecated for little endian; use \"\n-\t     \"assignment for unaligned loads and stores\");\n-  else if (fcode == ALTIVEC_BUILTIN_VEC_LVSR && !BYTES_BIG_ENDIAN)\n-    warning (OPT_Wdeprecated,\n-\t     \"%<vec_lvsr%> is deprecated for little endian; use \"\n-\t     \"assignment for unaligned loads and stores\");\n-\n-  if (fcode == ALTIVEC_BUILTIN_VEC_MUL)\n-    {\n-      /* vec_mul needs to be special cased because there are no instructions\n-\t for it for the {un}signed char, {un}signed short, and {un}signed int\n-\t types.  */\n-      if (nargs != 2)\n-\t{\n-\t  error (\"builtin %qs only accepts 2 arguments\", \"vec_mul\");\n-\t  return error_mark_node;\n-\t}\n-\n-      tree arg0 = (*arglist)[0];\n-      tree arg0_type = TREE_TYPE (arg0);\n-      tree arg1 = (*arglist)[1];\n-      tree arg1_type = TREE_TYPE (arg1);\n-\n-      /* Both arguments must be vectors and the types must be compatible.  */\n-      if (TREE_CODE (arg0_type) != VECTOR_TYPE)\n-\tgoto bad;\n-      if (!lang_hooks.types_compatible_p (arg0_type, arg1_type))\n-\tgoto bad;\n-\n-      switch (TYPE_MODE (TREE_TYPE (arg0_type)))\n-\t{\n-\t  case E_QImode:\n-\t  case E_HImode:\n-\t  case E_SImode:\n-\t  case E_DImode:\n-\t  case E_TImode:\n-\t    {\n-\t      /* For scalar types just use a multiply expression.  */\n-\t      return fold_build2_loc (loc, MULT_EXPR, TREE_TYPE (arg0), arg0,\n-\t\t\t\t      fold_convert (TREE_TYPE (arg0), arg1));\n-\t    }\n-\t  case E_SFmode:\n-\t    {\n-\t      /* For floats use the xvmulsp instruction directly.  */\n-\t      tree call = rs6000_builtin_decls[VSX_BUILTIN_XVMULSP];\n-\t      return build_call_expr (call, 2, arg0, arg1);\n-\t    }\n-\t  case E_DFmode:\n-\t    {\n-\t      /* For doubles use the xvmuldp instruction directly.  */\n-\t      tree call = rs6000_builtin_decls[VSX_BUILTIN_XVMULDP];\n-\t      return build_call_expr (call, 2, arg0, arg1);\n-\t    }\n-\t  /* Other types are errors.  */\n-\t  default:\n-\t    goto bad;\n-\t}\n-    }\n-\n-  if (fcode == ALTIVEC_BUILTIN_VEC_CMPNE)\n-    {\n-      /* vec_cmpne needs to be special cased because there are no instructions\n-\t for it (prior to power 9).  */\n-      if (nargs != 2)\n-\t{\n-\t  error (\"builtin %qs only accepts 2 arguments\", \"vec_cmpne\");\n-\t  return error_mark_node;\n-\t}\n-\n-      tree arg0 = (*arglist)[0];\n-      tree arg0_type = TREE_TYPE (arg0);\n-      tree arg1 = (*arglist)[1];\n-      tree arg1_type = TREE_TYPE (arg1);\n-\n-      /* Both arguments must be vectors and the types must be compatible.  */\n-      if (TREE_CODE (arg0_type) != VECTOR_TYPE)\n-\tgoto bad;\n-      if (!lang_hooks.types_compatible_p (arg0_type, arg1_type))\n-\tgoto bad;\n-\n-      /* Power9 instructions provide the most efficient implementation of\n-\t ALTIVEC_BUILTIN_VEC_CMPNE if the mode is not DImode or TImode\n-\t or SFmode or DFmode.  */\n-      if (!TARGET_P9_VECTOR\n-\t  || (TYPE_MODE (TREE_TYPE (arg0_type)) == DImode)\n-\t  || (TYPE_MODE (TREE_TYPE (arg0_type)) == TImode)\n-\t  || (TYPE_MODE (TREE_TYPE (arg0_type)) == SFmode)\n-\t  || (TYPE_MODE (TREE_TYPE (arg0_type)) == DFmode))\n-\t{\n-\t  switch (TYPE_MODE (TREE_TYPE (arg0_type)))\n-\t    {\n-\t      /* vec_cmpneq (va, vb) == vec_nor (vec_cmpeq (va, vb),\n-\t\t vec_cmpeq (va, vb)).  */\n-\t      /* Note:  vec_nand also works but opt changes vec_nand's\n-\t\t to vec_nor's anyway.  */\n-\t    case E_QImode:\n-\t    case E_HImode:\n-\t    case E_SImode:\n-\t    case E_DImode:\n-\t    case E_TImode:\n-\t    case E_SFmode:\n-\t    case E_DFmode:\n-\t      {\n-\t\t/* call = vec_cmpeq (va, vb)\n-\t\t   result = vec_nor (call, call).  */\n-\t\tvec<tree, va_gc> *params = make_tree_vector ();\n-\t\tvec_safe_push (params, arg0);\n-\t\tvec_safe_push (params, arg1);\n-\t\ttree call = altivec_resolve_overloaded_builtin\n-\t\t  (loc, rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_CMPEQ],\n-\t\t   params);\n-\t\t/* Use save_expr to ensure that operands used more than once\n-\t\t   that may have side effects (like calls) are only evaluated\n-\t\t   once.  */\n-\t\tcall = save_expr (call);\n-\t\tparams = make_tree_vector ();\n-\t\tvec_safe_push (params, call);\n-\t\tvec_safe_push (params, call);\n-\t\treturn altivec_resolve_overloaded_builtin\n-\t\t  (loc, rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_NOR], params);\n-\t      }\n-\t      /* Other types are errors.  */\n-\t    default:\n-\t      goto bad;\n-\t    }\n-\t}\n-      /* else, fall through and process the Power9 alternative below */\n-    }\n-\n-  if (fcode == ALTIVEC_BUILTIN_VEC_ADDE\n-      || fcode == ALTIVEC_BUILTIN_VEC_SUBE)\n-    {\n-      /* vec_adde needs to be special cased because there is no instruction\n-\t  for the {un}signed int version.  */\n-      if (nargs != 3)\n-\t{\n-\t  const char *name = fcode == ALTIVEC_BUILTIN_VEC_ADDE ?\n-\t    \"vec_adde\": \"vec_sube\";\n-\t  error (\"builtin %qs only accepts 3 arguments\", name);\n-\t  return error_mark_node;\n-\t}\n-\n-      tree arg0 = (*arglist)[0];\n-      tree arg0_type = TREE_TYPE (arg0);\n-      tree arg1 = (*arglist)[1];\n-      tree arg1_type = TREE_TYPE (arg1);\n-      tree arg2 = (*arglist)[2];\n-      tree arg2_type = TREE_TYPE (arg2);\n-\n-      /* All 3 arguments must be vectors of (signed or unsigned) (int or\n-\t __int128) and the types must be compatible.  */\n-      if (TREE_CODE (arg0_type) != VECTOR_TYPE)\n-\tgoto bad;\n-      if (!lang_hooks.types_compatible_p (arg0_type, arg1_type)\n-\t  || !lang_hooks.types_compatible_p (arg1_type, arg2_type))\n-\tgoto bad;\n-\n-      switch (TYPE_MODE (TREE_TYPE (arg0_type)))\n-\t{\n-\t  /* For {un}signed ints,\n-\t     vec_adde (va, vb, carryv) == vec_add (vec_add (va, vb),\n-\t\t\t\t\t\t   vec_and (carryv, 1)).\n-\t     vec_sube (va, vb, carryv) == vec_sub (vec_sub (va, vb),\n-\t\t\t\t\t\t   vec_and (carryv, 1)).  */\n-\t  case E_SImode:\n-\t    {\n-\t      tree add_sub_builtin;\n-\n-\t      vec<tree, va_gc> *params = make_tree_vector ();\n-\t      vec_safe_push (params, arg0);\n-\t      vec_safe_push (params, arg1);\n-\n-\t      if (fcode == ALTIVEC_BUILTIN_VEC_ADDE)\n-\t\tadd_sub_builtin = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_ADD];\n-\t      else\n-\t\tadd_sub_builtin = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_SUB];\n-\n-\t      tree call = altivec_resolve_overloaded_builtin (loc,\n-\t\t\t\t\t\t\t      add_sub_builtin,\n-\t\t\t\t\t\t\t      params);\n-\t      tree const1 = build_int_cstu (TREE_TYPE (arg0_type), 1);\n-\t      tree ones_vector = build_vector_from_val (arg0_type, const1);\n-\t      tree and_expr = fold_build2_loc (loc, BIT_AND_EXPR, arg0_type,\n-\t\t\t\t\t       arg2, ones_vector);\n-\t      params = make_tree_vector ();\n-\t      vec_safe_push (params, call);\n-\t      vec_safe_push (params, and_expr);\n-\t      return altivec_resolve_overloaded_builtin (loc, add_sub_builtin,\n-\t\t\t\t\t\t\t params);\n-\t    }\n-\t  /* For {un}signed __int128s use the vaddeuqm instruction\n-\t\tdirectly.  */\n-\t  case E_TImode:\n-\t    {\n-\t       tree bii;\n-\n-\t       if (fcode == ALTIVEC_BUILTIN_VEC_ADDE)\n-\t\t bii = rs6000_builtin_decls[P8V_BUILTIN_VEC_VADDEUQM];\n-\n-\t       else\n-\t\t bii = rs6000_builtin_decls[P8V_BUILTIN_VEC_VSUBEUQM];\n-\n-\t       return altivec_resolve_overloaded_builtin (loc, bii, arglist);\n-\t    }\n-\n-\t  /* Types other than {un}signed int and {un}signed __int128\n-\t\tare errors.  */\n-\t  default:\n-\t    goto bad;\n-\t}\n-    }\n-\n-  if (fcode == ALTIVEC_BUILTIN_VEC_ADDEC\n-      || fcode == ALTIVEC_BUILTIN_VEC_SUBEC)\n-    {\n-      /* vec_addec and vec_subec needs to be special cased because there is\n-\t no instruction for the {un}signed int version.  */\n-      if (nargs != 3)\n-\t{\n-\t  const char *name = fcode == ALTIVEC_BUILTIN_VEC_ADDEC ?\n-\t    \"vec_addec\": \"vec_subec\";\n-\t  error (\"builtin %qs only accepts 3 arguments\", name);\n-\t  return error_mark_node;\n-\t}\n-\n-      tree arg0 = (*arglist)[0];\n-      tree arg0_type = TREE_TYPE (arg0);\n-      tree arg1 = (*arglist)[1];\n-      tree arg1_type = TREE_TYPE (arg1);\n-      tree arg2 = (*arglist)[2];\n-      tree arg2_type = TREE_TYPE (arg2);\n-\n-      /* All 3 arguments must be vectors of (signed or unsigned) (int or\n-\t __int128) and the types must be compatible.  */\n-      if (TREE_CODE (arg0_type) != VECTOR_TYPE)\n-\tgoto bad;\n-      if (!lang_hooks.types_compatible_p (arg0_type, arg1_type)\n-\t  || !lang_hooks.types_compatible_p (arg1_type, arg2_type))\n-\tgoto bad;\n-\n-      switch (TYPE_MODE (TREE_TYPE (arg0_type)))\n-\t{\n-\t  /* For {un}signed ints,\n-\t      vec_addec (va, vb, carryv) ==\n-\t\t\t\tvec_or (vec_addc (va, vb),\n-\t\t\t\t\tvec_addc (vec_add (va, vb),\n-\t\t\t\t\t\t  vec_and (carryv, 0x1))).  */\n-\t  case E_SImode:\n-\t    {\n-\t    /* Use save_expr to ensure that operands used more than once\n-\t\tthat may have side effects (like calls) are only evaluated\n-\t\tonce.  */\n-\t    tree as_builtin;\n-\t    tree as_c_builtin;\n-\n-\t    arg0 = save_expr (arg0);\n-\t    arg1 = save_expr (arg1);\n-\t    vec<tree, va_gc> *params = make_tree_vector ();\n-\t    vec_safe_push (params, arg0);\n-\t    vec_safe_push (params, arg1);\n-\n-\t    if (fcode == ALTIVEC_BUILTIN_VEC_ADDEC)\n-\t      as_c_builtin = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_ADDC];\n-\t    else\n-\t      as_c_builtin = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_SUBC];\n-\n-\t    tree call1 = altivec_resolve_overloaded_builtin (loc, as_c_builtin,\n-\t\t\t\t\t\t\t     params);\n-\t    params = make_tree_vector ();\n-\t    vec_safe_push (params, arg0);\n-\t    vec_safe_push (params, arg1);\n-\n-\n-\t    if (fcode == ALTIVEC_BUILTIN_VEC_ADDEC)\n-\t      as_builtin = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_ADD];\n-\t    else\n-\t      as_builtin = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_SUB];\n-\n-\t    tree call2 = altivec_resolve_overloaded_builtin (loc, as_builtin,\n-\t\t\t\t\t\t\t     params);\n-\t    tree const1 = build_int_cstu (TREE_TYPE (arg0_type), 1);\n-\t    tree ones_vector = build_vector_from_val (arg0_type, const1);\n-\t    tree and_expr = fold_build2_loc (loc, BIT_AND_EXPR, arg0_type,\n-\t\t\t\t\t     arg2, ones_vector);\n-\t    params = make_tree_vector ();\n-\t    vec_safe_push (params, call2);\n-\t    vec_safe_push (params, and_expr);\n-\t    call2 = altivec_resolve_overloaded_builtin (loc, as_c_builtin,\n-\t\t\t\t\t\t\tparams);\n-\t    params = make_tree_vector ();\n-\t    vec_safe_push (params, call1);\n-\t    vec_safe_push (params, call2);\n-\t    tree or_builtin = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_OR];\n-\t    return altivec_resolve_overloaded_builtin (loc, or_builtin,\n-\t\t\t\t\t\t       params);\n-\t    }\n-\t  /* For {un}signed __int128s use the vaddecuq/vsubbecuq\n-\t     instructions.  */\n-\t  case E_TImode:\n-\t    {\n-\t       tree bii;\n-\n-\t       if (fcode == ALTIVEC_BUILTIN_VEC_ADDEC)\n-\t\t bii = rs6000_builtin_decls[P8V_BUILTIN_VEC_VADDECUQ];\n-\n-\t       else\n-\t\t bii = rs6000_builtin_decls[P8V_BUILTIN_VEC_VSUBECUQ];\n-\n-\t       return altivec_resolve_overloaded_builtin (loc, bii, arglist);\n-\t    }\n-\t  /* Types other than {un}signed int and {un}signed __int128\n-\t\tare errors.  */\n-\t  default:\n-\t    goto bad;\n-\t}\n-    }\n-\n-  /* For now treat vec_splats and vec_promote as the same.  */\n-  if (fcode == ALTIVEC_BUILTIN_VEC_SPLATS\n-      || fcode == ALTIVEC_BUILTIN_VEC_PROMOTE)\n-    {\n-      tree type, arg;\n-      int size;\n-      int i;\n-      bool unsigned_p;\n-      vec<constructor_elt, va_gc> *vec;\n-      const char *name = fcode == ALTIVEC_BUILTIN_VEC_SPLATS ? \"vec_splats\": \"vec_promote\";\n-\n-      if (fcode == ALTIVEC_BUILTIN_VEC_SPLATS && nargs != 1)\n-\t{\n-\t  error (\"builtin %qs only accepts 1 argument\", name);\n-\t  return error_mark_node;\n-\t}\n-      if (fcode == ALTIVEC_BUILTIN_VEC_PROMOTE && nargs != 2)\n-\t{\n-\t  error (\"builtin %qs only accepts 2 arguments\", name);\n-\t  return error_mark_node;\n-\t}\n-      /* Ignore promote's element argument.  */\n-      if (fcode == ALTIVEC_BUILTIN_VEC_PROMOTE\n-\t  && !INTEGRAL_TYPE_P (TREE_TYPE ((*arglist)[1])))\n-\tgoto bad;\n-\n-      arg = (*arglist)[0];\n-      type = TREE_TYPE (arg);\n-      if (!SCALAR_FLOAT_TYPE_P (type)\n-\t  && !INTEGRAL_TYPE_P (type))\n-\tgoto bad;\n-      unsigned_p = TYPE_UNSIGNED (type);\n-      switch (TYPE_MODE (type))\n-\t{\n-\t  case E_TImode:\n-\t    type = (unsigned_p ? unsigned_V1TI_type_node : V1TI_type_node);\n-\t    size = 1;\n-\t    break;\n-\t  case E_DImode:\n-\t    type = (unsigned_p ? unsigned_V2DI_type_node : V2DI_type_node);\n-\t    size = 2;\n-\t    break;\n-\t  case E_SImode:\n-\t    type = (unsigned_p ? unsigned_V4SI_type_node : V4SI_type_node);\n-\t    size = 4;\n-\t    break;\n-\t  case E_HImode:\n-\t    type = (unsigned_p ? unsigned_V8HI_type_node : V8HI_type_node);\n-\t    size = 8;\n-\t    break;\n-\t  case E_QImode:\n-\t    type = (unsigned_p ? unsigned_V16QI_type_node : V16QI_type_node);\n-\t    size = 16;\n-\t    break;\n-\t  case E_SFmode: type = V4SF_type_node; size = 4; break;\n-\t  case E_DFmode: type = V2DF_type_node; size = 2; break;\n-\t  default:\n-\t    goto bad;\n-\t}\n-      arg = save_expr (fold_convert (TREE_TYPE (type), arg));\n-      vec_alloc (vec, size);\n-      for(i = 0; i < size; i++)\n-\t{\n-\t  constructor_elt elt = {NULL_TREE, arg};\n-\t  vec->quick_push (elt);\n-\t}\n-\treturn build_constructor (type, vec);\n-    }\n-\n-  /* For now use pointer tricks to do the extraction, unless we are on VSX\n-     extracting a double from a constant offset.  */\n-  if (fcode == ALTIVEC_BUILTIN_VEC_EXTRACT)\n-    {\n-      tree arg1;\n-      tree arg1_type;\n-      tree arg2;\n-      tree arg1_inner_type;\n-      tree decl, stmt;\n-      tree innerptrtype;\n-      machine_mode mode;\n-\n-      /* No second argument. */\n-      if (nargs != 2)\n-\t{\n-\t  error (\"builtin %qs only accepts 2 arguments\", \"vec_extract\");\n-\t  return error_mark_node;\n-\t}\n-\n-      arg2 = (*arglist)[1];\n-      arg1 = (*arglist)[0];\n-      arg1_type = TREE_TYPE (arg1);\n-\n-      if (TREE_CODE (arg1_type) != VECTOR_TYPE)\n-\tgoto bad;\n-      if (!INTEGRAL_TYPE_P (TREE_TYPE (arg2)))\n-\tgoto bad;\n-\n-      /* See if we can optimize vec_extracts with the current VSX instruction\n-\t set.  */\n-      mode = TYPE_MODE (arg1_type);\n-      if (VECTOR_MEM_VSX_P (mode))\n-\n-\t{\n-\t  tree call = NULL_TREE;\n-\t  int nunits = GET_MODE_NUNITS (mode);\n-\n-\t  arg2 = fold_for_warn (arg2);\n-\n-\t  /* If the second argument is an integer constant, generate\n-\t     the built-in code if we can.  We need 64-bit and direct\n-\t     move to extract the small integer vectors.  */\n-\t  if (TREE_CODE (arg2) == INTEGER_CST)\n-\t    {\n-\t      wide_int selector = wi::to_wide (arg2);\n-\t      selector = wi::umod_trunc (selector, nunits);\n-\t      arg2 = wide_int_to_tree (TREE_TYPE (arg2), selector);\n-\t      switch (mode)\n-\t\t{\n-\t\tdefault:\n-\t\t  break;\n-\n-\t\tcase E_V1TImode:\n-\t\t  call = rs6000_builtin_decls[VSX_BUILTIN_VEC_EXT_V1TI];\n-\t\t  break;\n-\n-\t\tcase E_V2DFmode:\n-\t\t  call = rs6000_builtin_decls[VSX_BUILTIN_VEC_EXT_V2DF];\n-\t\t  break;\n-\n-\t\tcase E_V2DImode:\n-\t\t  call = rs6000_builtin_decls[VSX_BUILTIN_VEC_EXT_V2DI];\n-\t\t  break;\n-\n-\t\tcase E_V4SFmode:\n-\t\t  call = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_EXT_V4SF];\n-\t\t  break;\n-\n-\t\tcase E_V4SImode:\n-\t\t  if (TARGET_DIRECT_MOVE_64BIT)\n-\t\t    call = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_EXT_V4SI];\n-\t\t  break;\n-\n-\t\tcase E_V8HImode:\n-\t\t  if (TARGET_DIRECT_MOVE_64BIT)\n-\t\t    call = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_EXT_V8HI];\n-\t\t  break;\n-\n-\t\tcase E_V16QImode:\n-\t\t  if (TARGET_DIRECT_MOVE_64BIT)\n-\t\t    call = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_EXT_V16QI];\n-\t\t  break;\n-\t\t}\n-\t    }\n-\n-\t  /* If the second argument is variable, we can optimize it if we are\n-\t     generating 64-bit code on a machine with direct move.  */\n-\t  else if (TREE_CODE (arg2) != INTEGER_CST && TARGET_DIRECT_MOVE_64BIT)\n-\t    {\n-\t      switch (mode)\n-\t\t{\n-\t\tdefault:\n-\t\t  break;\n-\n-\t\tcase E_V2DFmode:\n-\t\t  call = rs6000_builtin_decls[VSX_BUILTIN_VEC_EXT_V2DF];\n-\t\t  break;\n-\n-\t\tcase E_V2DImode:\n-\t\t  call = rs6000_builtin_decls[VSX_BUILTIN_VEC_EXT_V2DI];\n-\t\t  break;\n-\n-\t\tcase E_V4SFmode:\n-\t\t  call = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_EXT_V4SF];\n-\t\t  break;\n-\n-\t\tcase E_V4SImode:\n-\t\t  call = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_EXT_V4SI];\n-\t\t  break;\n-\n-\t\tcase E_V8HImode:\n-\t\t  call = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_EXT_V8HI];\n-\t\t  break;\n-\n-\t\tcase E_V16QImode:\n-\t\t  call = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_EXT_V16QI];\n-\t\t  break;\n-\t\t}\n-\t    }\n-\n-\t  if (call)\n-\t    {\n-\t      tree result = build_call_expr (call, 2, arg1, arg2);\n-\t      /* Coerce the result to vector element type.  May be no-op.  */\n-\t      arg1_inner_type = TREE_TYPE (arg1_type);\n-\t      result = fold_convert (arg1_inner_type, result);\n-\t      return result;\n-\t    }\n-\t}\n-\n-      /* Build *(((arg1_inner_type*)&(vector type){arg1})+arg2). */\n-      arg1_inner_type = TREE_TYPE (arg1_type);\n-      arg2 = build_binary_op (loc, BIT_AND_EXPR, arg2,\n-\t\t\t      build_int_cst (TREE_TYPE (arg2),\n-\t\t\t\t\t     TYPE_VECTOR_SUBPARTS (arg1_type)\n-\t\t\t\t\t     - 1), 0);\n-      decl = build_decl (loc, VAR_DECL, NULL_TREE, arg1_type);\n-      DECL_EXTERNAL (decl) = 0;\n-      TREE_PUBLIC (decl) = 0;\n-      DECL_CONTEXT (decl) = current_function_decl;\n-      TREE_USED (decl) = 1;\n-      TREE_TYPE (decl) = arg1_type;\n-      TREE_READONLY (decl) = TYPE_READONLY (arg1_type);\n-      if (c_dialect_cxx ())\n-\t{\n-\t  stmt = build4 (TARGET_EXPR, arg1_type, decl, arg1,\n-\t\t\t NULL_TREE, NULL_TREE);\n-\t  SET_EXPR_LOCATION (stmt, loc);\n-\t}\n-      else\n-\t{\n-\t  DECL_INITIAL (decl) = arg1;\n-\t  stmt = build1 (DECL_EXPR, arg1_type, decl);\n-\t  TREE_ADDRESSABLE (decl) = 1;\n-\t  SET_EXPR_LOCATION (stmt, loc);\n-\t  stmt = build1 (COMPOUND_LITERAL_EXPR, arg1_type, stmt);\n-\t}\n-\n-      innerptrtype = build_pointer_type (arg1_inner_type);\n-\n-      stmt = build_unary_op (loc, ADDR_EXPR, stmt, 0);\n-      stmt = convert (innerptrtype, stmt);\n-      stmt = build_binary_op (loc, PLUS_EXPR, stmt, arg2, 1);\n-      stmt = build_indirect_ref (loc, stmt, RO_NULL);\n-\n-      /* PR83660: We mark this as having side effects so that\n-\t downstream in fold_build_cleanup_point_expr () it will get a\n-\t CLEANUP_POINT_EXPR.  If it does not we can run into an ICE\n-\t later in gimplify_cleanup_point_expr ().  Potentially this\n-\t causes missed optimization because the actually is no side\n-\t effect.  */\n-      if (c_dialect_cxx ())\n-\tTREE_SIDE_EFFECTS (stmt) = 1;\n-\n-      return stmt;\n-    }\n-\n-  /* For now use pointer tricks to do the insertion, unless we are on VSX\n-     inserting a double to a constant offset..  */\n-  if (fcode == ALTIVEC_BUILTIN_VEC_INSERT)\n-    {\n-      tree arg0;\n-      tree arg1;\n-      tree arg2;\n-      tree arg1_type;\n-      tree decl, stmt;\n-      machine_mode mode;\n-\n-      /* No second or third arguments. */\n-      if (nargs != 3)\n-\t{\n-\t  error (\"builtin %qs only accepts 3 arguments\", \"vec_insert\");\n-\t  return error_mark_node;\n-\t}\n-\n-      arg0 = (*arglist)[0];\n-      arg1 = (*arglist)[1];\n-      arg1_type = TREE_TYPE (arg1);\n-      arg2 = fold_for_warn ((*arglist)[2]);\n-\n-      if (TREE_CODE (arg1_type) != VECTOR_TYPE)\n-\tgoto bad;\n-      if (!INTEGRAL_TYPE_P (TREE_TYPE (arg2)))\n-\tgoto bad;\n-\n-      /* If we can use the VSX xxpermdi instruction, use that for insert.  */\n-      mode = TYPE_MODE (arg1_type);\n-      if ((mode == V2DFmode || mode == V2DImode) && VECTOR_UNIT_VSX_P (mode)\n-\t  && TREE_CODE (arg2) == INTEGER_CST)\n-\t{\n-\t  wide_int selector = wi::to_wide (arg2);\n-\t  selector = wi::umod_trunc (selector, 2);\n-\t  tree call = NULL_TREE;\n-\n-\t  arg2 = wide_int_to_tree (TREE_TYPE (arg2), selector);\n-\t  if (mode == V2DFmode)\n-\t    call = rs6000_builtin_decls[VSX_BUILTIN_VEC_SET_V2DF];\n-\t  else if (mode == V2DImode)\n-\t    call = rs6000_builtin_decls[VSX_BUILTIN_VEC_SET_V2DI];\n-\n-\t  /* Note, __builtin_vec_insert_<xxx> has vector and scalar types\n-\t     reversed.  */\n-\t  if (call)\n-\t    return build_call_expr (call, 3, arg1, arg0, arg2);\n-\t}\n-      else if (mode == V1TImode && VECTOR_UNIT_VSX_P (mode)\n-\t       && TREE_CODE (arg2) == INTEGER_CST)\n-\t{\n-\t  tree call = rs6000_builtin_decls[VSX_BUILTIN_VEC_SET_V1TI];\n-\t  wide_int selector = wi::zero(32);\n-\n-\t  arg2 = wide_int_to_tree (TREE_TYPE (arg2), selector);\n-\t  /* Note, __builtin_vec_insert_<xxx> has vector and scalar types\n-\t     reversed.  */\n-\t  return build_call_expr (call, 3, arg1, arg0, arg2);\n-\t}\n-\n-      /* Build *(((arg1_inner_type*)&(vector type){arg1})+arg2) = arg0 with\n-\t VIEW_CONVERT_EXPR.  i.e.:\n-\t D.3192 = v1;\n-\t _1 = n & 3;\n-\t VIEW_CONVERT_EXPR<int[4]>(D.3192)[_1] = i;\n-\t v1 = D.3192;\n-\t D.3194 = v1;  */\n-      if (TYPE_VECTOR_SUBPARTS (arg1_type) == 1)\n-\targ2 = build_int_cst (TREE_TYPE (arg2), 0);\n-      else\n-\targ2 = build_binary_op (loc, BIT_AND_EXPR, arg2,\n-\t\t\t\tbuild_int_cst (TREE_TYPE (arg2),\n-\t\t\t\t\t       TYPE_VECTOR_SUBPARTS (arg1_type)\n-\t\t\t\t\t       - 1), 0);\n-      decl = build_decl (loc, VAR_DECL, NULL_TREE, arg1_type);\n-      DECL_EXTERNAL (decl) = 0;\n-      TREE_PUBLIC (decl) = 0;\n-      DECL_CONTEXT (decl) = current_function_decl;\n-      TREE_USED (decl) = 1;\n-      TREE_TYPE (decl) = arg1_type;\n-      TREE_READONLY (decl) = TYPE_READONLY (arg1_type);\n-      TREE_ADDRESSABLE (decl) = 1;\n-      if (c_dialect_cxx ())\n-\t{\n-\t  stmt = build4 (TARGET_EXPR, arg1_type, decl, arg1,\n-\t\t\t NULL_TREE, NULL_TREE);\n-\t  SET_EXPR_LOCATION (stmt, loc);\n-\t}\n-      else\n-\t{\n-\t  DECL_INITIAL (decl) = arg1;\n-\t  stmt = build1 (DECL_EXPR, arg1_type, decl);\n-\t  SET_EXPR_LOCATION (stmt, loc);\n-\t  stmt = build1 (COMPOUND_LITERAL_EXPR, arg1_type, stmt);\n-\t}\n-\n-      if (TARGET_VSX)\n-\t{\n-\t  stmt = build_array_ref (loc, stmt, arg2);\n-\t  stmt = fold_build2 (MODIFY_EXPR, TREE_TYPE (arg0), stmt,\n-\t\t\t      convert (TREE_TYPE (stmt), arg0));\n-\t  stmt = build2 (COMPOUND_EXPR, arg1_type, stmt, decl);\n-\t}\n-      else\n-\t{\n-\t  tree arg1_inner_type;\n-\t  tree innerptrtype;\n-\t  arg1_inner_type = TREE_TYPE (arg1_type);\n-\t  innerptrtype = build_pointer_type (arg1_inner_type);\n-\n-\t  stmt = build_unary_op (loc, ADDR_EXPR, stmt, 0);\n-\t  stmt = convert (innerptrtype, stmt);\n-\t  stmt = build_binary_op (loc, PLUS_EXPR, stmt, arg2, 1);\n-\t  stmt = build_indirect_ref (loc, stmt, RO_NULL);\n-\t  stmt = build2 (MODIFY_EXPR, TREE_TYPE (stmt), stmt,\n-\t\t\t convert (TREE_TYPE (stmt), arg0));\n-\t  stmt = build2 (COMPOUND_EXPR, arg1_type, stmt, decl);\n-\t}\n-      return stmt;\n-    }\n-\n-  for (n = 0;\n-       !VOID_TYPE_P (TREE_VALUE (fnargs)) && n < nargs;\n-       fnargs = TREE_CHAIN (fnargs), n++)\n-    {\n-      tree decl_type = TREE_VALUE (fnargs);\n-      tree arg = (*arglist)[n];\n-      tree type;\n-\n-      if (arg == error_mark_node)\n-\treturn error_mark_node;\n-\n-      if (n >= 4)\n-        abort ();\n-\n-      arg = default_conversion (arg);\n-\n-      /* The C++ front-end converts float * to const void * using\n-\t NOP_EXPR<const void *> (NOP_EXPR<void *> (x)).  */\n-      type = TREE_TYPE (arg);\n-      if (POINTER_TYPE_P (type)\n-\t  && TREE_CODE (arg) == NOP_EXPR\n-\t  && lang_hooks.types_compatible_p (TREE_TYPE (arg),\n-\t\t\t\t\t    const_ptr_type_node)\n-\t  && lang_hooks.types_compatible_p (TREE_TYPE (TREE_OPERAND (arg, 0)),\n-\t\t\t\t\t    ptr_type_node))\n-\t{\n-\t  arg = TREE_OPERAND (arg, 0);\n-          type = TREE_TYPE (arg);\n-\t}\n-\n-      /* Remove the const from the pointers to simplify the overload\n-\t matching further down.  */\n-      if (POINTER_TYPE_P (decl_type)\n-\t  && POINTER_TYPE_P (type)\n-\t  && TYPE_QUALS (TREE_TYPE (type)) != 0)\n-\t{\n-          if (TYPE_READONLY (TREE_TYPE (type))\n-\t      && !TYPE_READONLY (TREE_TYPE (decl_type)))\n-\t    warning (0, \"passing argument %d of %qE discards qualifiers from \"\n-\t\t        \"pointer target type\", n + 1, fndecl);\n-\t  type = build_pointer_type (build_qualified_type (TREE_TYPE (type),\n-\t\t\t\t\t\t\t   0));\n-\t  arg = fold_convert (type, arg);\n-\t}\n-\n-      /* For P9V_BUILTIN_VEC_LXVL, convert any const * to its non constant\n-\t equivalent to simplify the overload matching below.  */\n-      if (fcode == P9V_BUILTIN_VEC_LXVL)\n-\t{\n-\t  if (POINTER_TYPE_P (type)\n-\t      && TYPE_READONLY (TREE_TYPE (type)))\n-\t    {\n-\t      type = build_pointer_type (build_qualified_type (\n-\t\t\t\t\t\tTREE_TYPE (type),0));\n-\t      arg = fold_convert (type, arg);\n-\t    }\n-\t}\n-\n-      args[n] = arg;\n-      types[n] = type;\n-    }\n-\n-  /* If the number of arguments did not match the prototype, return NULL\n-     and the generic code will issue the appropriate error message.  */\n-  if (!VOID_TYPE_P (TREE_VALUE (fnargs)) || n < nargs)\n-    return NULL;\n-\n-  if (n == 0)\n-    abort ();\n-\n-  if (fcode == ALTIVEC_BUILTIN_VEC_STEP)\n-    {\n-      if (TREE_CODE (types[0]) != VECTOR_TYPE)\n-\tgoto bad;\n-\n-      return build_int_cst (NULL_TREE, TYPE_VECTOR_SUBPARTS (types[0]));\n-    }\n-\n-  {\n-    bool unsupported_builtin = false;\n-    enum rs6000_builtins overloaded_code;\n-    tree result = NULL;\n-    for (desc = altivec_overloaded_builtins;\n-\t desc->code && desc->code != fcode; desc++)\n-      continue;\n-\n-    /* Need to special case __builtin_cmp because the overloaded forms\n-       of this function take (unsigned int, unsigned int) or (unsigned\n-       long long int, unsigned long long int).  Since C conventions\n-       allow the respective argument types to be implicitly coerced into\n-       each other, the default handling does not provide adequate\n-       discrimination between the desired forms of the function.  */\n-    if (fcode == P6_OV_BUILTIN_CMPB)\n-      {\n-\tmachine_mode arg1_mode = TYPE_MODE (types[0]);\n-\tmachine_mode arg2_mode = TYPE_MODE (types[1]);\n-\n-\tif (nargs != 2)\n-\t  {\n-\t    error (\"builtin %qs only accepts 2 arguments\", \"__builtin_cmpb\");\n-\t    return error_mark_node;\n-\t  }\n-\n-\t/* If any supplied arguments are wider than 32 bits, resolve to\n-\t   64-bit variant of built-in function.  */\n-\tif ((GET_MODE_PRECISION (arg1_mode) > 32)\n-\t    || (GET_MODE_PRECISION (arg2_mode) > 32))\n-\t  {\n-\t    /* Assure all argument and result types are compatible with\n-\t       the built-in function represented by P6_BUILTIN_CMPB.  */\n-\t    overloaded_code = P6_BUILTIN_CMPB;\n-\t  }\n-\telse\n-\t  {\n-\t    /* Assure all argument and result types are compatible with\n-\t       the built-in function represented by P6_BUILTIN_CMPB_32.  */\n-\t    overloaded_code = P6_BUILTIN_CMPB_32;\n-\t  }\n-\n-\twhile (desc->code && desc->code == fcode\n-\t       && desc->overloaded_code != overloaded_code)\n-\t  desc++;\n-\n-\tif (desc->code && (desc->code == fcode)\n-\t    && rs6000_builtin_type_compatible (types[0], desc->op1)\n-\t    && rs6000_builtin_type_compatible (types[1], desc->op2))\n-\t  {\n-\t    if (rs6000_builtin_decls[desc->overloaded_code] != NULL_TREE)\n-\t      {\n-\t\tresult = altivec_build_resolved_builtin (args, n, desc);\n-\t\t/* overloaded_code is set above */\n-\t\tif (!rs6000_builtin_is_supported_p (overloaded_code))\n-\t\t  unsupported_builtin = true;\n-\t\telse\n-\t\t  return result;\n-\t      }\n-\t    else\n-\t      unsupported_builtin = true;\n-\t  }\n-      }\n-    else if (fcode == P9V_BUILTIN_VEC_VSIEDP)\n-      {\n-\tmachine_mode arg1_mode = TYPE_MODE (types[0]);\n-\n-\tif (nargs != 2)\n-\t  {\n-\t    error (\"builtin %qs only accepts 2 arguments\",\n-\t\t   \"scalar_insert_exp\");\n-\t    return error_mark_node;\n-\t  }\n-\n-\t/* If supplied first argument is wider than 64 bits, resolve to\n-\t   128-bit variant of built-in function.  */\n-\tif (GET_MODE_PRECISION (arg1_mode) > 64)\n-\t  {\n-\t    /* If first argument is of float variety, choose variant\n-\t       that expects __ieee128 argument.  Otherwise, expect\n-\t       __int128 argument.  */\n-\t    if (GET_MODE_CLASS (arg1_mode) == MODE_FLOAT)\n-\t      overloaded_code = P9V_BUILTIN_VSIEQPF;\n-\t    else\n-\t      overloaded_code = P9V_BUILTIN_VSIEQP;\n-\t  }\n-\telse\n-\t  {\n-\t    /* If first argument is of float variety, choose variant\n-\t       that expects double argument.  Otherwise, expect\n-\t       long long int argument.  */\n-\t    if (GET_MODE_CLASS (arg1_mode) == MODE_FLOAT)\n-\t      overloaded_code = P9V_BUILTIN_VSIEDPF;\n-\t    else\n-\t      overloaded_code = P9V_BUILTIN_VSIEDP;\n-\t  }\n-\twhile (desc->code && desc->code == fcode\n-\t       && desc->overloaded_code != overloaded_code)\n-\t  desc++;\n-\n-\tif (desc->code && (desc->code == fcode)\n-\t    && rs6000_builtin_type_compatible (types[0], desc->op1)\n-\t    && rs6000_builtin_type_compatible (types[1], desc->op2))\n-\t  {\n-\t    if (rs6000_builtin_decls[desc->overloaded_code] != NULL_TREE)\n-\t      {\n-\t\tresult = altivec_build_resolved_builtin (args, n, desc);\n-\t\t/* overloaded_code is set above.  */\n-\t\tif (!rs6000_builtin_is_supported_p (overloaded_code))\n-\t\t  unsupported_builtin = true;\n-\t\telse\n-\t\t  return result;\n-\t      }\n-\t    else\n-\t      unsupported_builtin = true;\n-\t  }\n-      }\n-    else if ((fcode == P10_BUILTIN_VEC_XXEVAL)\n-\t    || (fcode == P10V_BUILTIN_VXXPERMX))\n-      {\n-\tsigned char op3_type;\n-\n-\t/* Need to special case P10_BUILTIN_VEC_XXEVAL and\n-\t   P10V_BUILTIN_VXXPERMX because they take 4 arguments and the\n-\t   existing infrastructure only handles three.  */\n-\tif (nargs != 4)\n-\t  {\n-\t    const char *name = fcode == P10_BUILTIN_VEC_XXEVAL ?\n-\t      \"__builtin_vec_xxeval\":\"__builtin_vec_xxpermx\";\n-\n-\t    error (\"builtin %qs requires 4 arguments\", name);\n-\t    return error_mark_node;\n-\t  }\n-\n-\tfor ( ; desc->code == fcode; desc++)\n-\t  {\n-\t    if (fcode == P10_BUILTIN_VEC_XXEVAL)\n-\t      op3_type = desc->op3;\n-\t    else  /* P10V_BUILTIN_VXXPERMX */\n-\t      op3_type = RS6000_BTI_V16QI;\n-\n-\t    if (rs6000_builtin_type_compatible (types[0], desc->op1)\n-\t\t&& rs6000_builtin_type_compatible (types[1], desc->op2)\n-\t\t&& rs6000_builtin_type_compatible (types[2], desc->op3)\n-\t\t&& rs6000_builtin_type_compatible (types[2], op3_type)\n-\t\t&& rs6000_builtin_type_compatible (types[3],\n-\t\t\t\t\t\t   RS6000_BTI_UINTSI))\n-\t      {\n-\t\tif (rs6000_builtin_decls[desc->overloaded_code] == NULL_TREE)\n-\t\t  unsupported_builtin = true;\n-\t\telse\n-\t\t  {\n-\t\t    result = altivec_build_resolved_builtin (args, n, desc);\n-\t\t    if (rs6000_builtin_is_supported_p (desc->overloaded_code))\n-\t\t      return result;\n-\t\t    /* Allow loop to continue in case a different\n-\t\t       definition is supported.  */\n-\t\t    overloaded_code = desc->overloaded_code;\n-\t\t    unsupported_builtin = true;\n-\t\t  }\n-\t      }\n-\t  }\n-      }\n-    else\n-      {\n-\t/* For arguments after the last, we have RS6000_BTI_NOT_OPAQUE in\n-\t   the opX fields.  */\n-\tfor (; desc->code == fcode; desc++)\n-\t  {\n-\t    if ((desc->op1 == RS6000_BTI_NOT_OPAQUE\n-\t\t || rs6000_builtin_type_compatible (types[0], desc->op1))\n-\t\t&& (desc->op2 == RS6000_BTI_NOT_OPAQUE\n-\t\t    || rs6000_builtin_type_compatible (types[1], desc->op2))\n-\t\t&& (desc->op3 == RS6000_BTI_NOT_OPAQUE\n-\t\t    || rs6000_builtin_type_compatible (types[2], desc->op3)))\n-\t      {\n-\t\tif (rs6000_builtin_decls[desc->overloaded_code] != NULL_TREE)\n-\t\t  {\n-\t\t    result = altivec_build_resolved_builtin (args, n, desc);\n-\t\t    if (!rs6000_builtin_is_supported_p (desc->overloaded_code))\n-\t\t      {\n-\t\t\t/* Allow loop to continue in case a different\n-\t\t\t   definition is supported.  */\n-\t\t\toverloaded_code = desc->overloaded_code;\n-\t\t\tunsupported_builtin = true;\n-\t\t      }\n-\t\t    else\n-\t\t      return result;\n-\t\t  }\n-\t\telse\n-\t\t  unsupported_builtin = true;\n-\t      }\n-\t  }\n-      }\n-\n-    if (unsupported_builtin)\n-      {\n-\tconst char *name = rs6000_overloaded_builtin_name (fcode);\n-\tif (result != NULL)\n-\t  {\n-\t    const char *internal_name\n-\t      = rs6000_overloaded_builtin_name (overloaded_code);\n-\t    /* An error message making reference to the name of the\n-\t       non-overloaded function has already been issued.  Add\n-\t       clarification of the previous message.  */\n-\t    rich_location richloc (line_table, input_location);\n-\t    inform (&richloc,\n-\t\t    \"overloaded builtin %qs is implemented by builtin %qs\",\n-\t\t    name, internal_name);\n-\t  }\n-\telse\n-\t  error (\"%qs is not supported in this compiler configuration\", name);\n-\t/* If an error-representing  result tree was returned from\n-\t   altivec_build_resolved_builtin above, use it.  */\n-\treturn (result != NULL) ? result : error_mark_node;\n-      }\n-  }\n- bad:\n-  {\n-    const char *name = rs6000_overloaded_builtin_name (fcode);\n-    error (\"invalid parameter combination for AltiVec intrinsic %qs\", name);\n-    return error_mark_node;\n-  }\n+  return altivec_resolve_new_overloaded_builtin (loc, fndecl, passed_arglist);\n }\n \n /* Build a tree for a function call to an Altivec non-overloaded builtin."}, {"sha": "85aea9b8c2f46a9280f6de96e8030b67288ba654", "filename": "gcc/config/rs6000/rs6000-call.c", "status": "modified", "additions": 3160, "deletions": 8363, "changes": 11523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cf62ef5aa80e3659a8150a48d93a1d333f1d292/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cf62ef5aa80e3659a8150a48d93a1d333f1d292/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-call.c?ref=2cf62ef5aa80e3659a8150a48d93a1d333f1d292"}, {"sha": "0034fe0011171d0a1ae80e73d83ce19018cb24f6", "filename": "gcc/config/rs6000/rs6000-gen-builtins.c", "status": "modified", "additions": 38, "deletions": 49, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cf62ef5aa80e3659a8150a48d93a1d333f1d292/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cf62ef5aa80e3659a8150a48d93a1d333f1d292/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c?ref=2cf62ef5aa80e3659a8150a48d93a1d333f1d292", "patch": "@@ -2492,7 +2492,6 @@ write_header_file (void)\n \n   fprintf (header_file, \"#ifndef _RS6000_BUILTINS_H\\n\");\n   fprintf (header_file, \"#define _RS6000_BUILTINS_H 1\\n\\n\");\n-  fprintf (header_file, \"extern int new_builtins_are_live;\\n\\n\");\n \n   write_decls ();\n \n@@ -2691,68 +2690,64 @@ write_init_bif_table (void)\n \t\t       || strstr (bifs[i].fndecl, \"dd\") != NULL\n \t\t       || strstr (bifs[i].fndecl, \"td\") != NULL);\n \n-      fprintf (init_file,\n-\t       \"  if (new_builtins_are_live)\\n\");\n-      fprintf (init_file, \"    {\\n\");\n-\n       if (tf_found)\n \t{\n-\t  fprintf (init_file, \"      if (float128_type_node)\\n\");\n-\t  fprintf (init_file, \"        {\\n\");\n+\t  fprintf (init_file, \"  if (float128_type_node)\\n\");\n+\t  fprintf (init_file, \"    {\\n\");\n \t}\n       else if (dfp_found)\n \t{\n-\t  fprintf (init_file, \"      if (dfloat64_type_node)\\n\");\n-\t  fprintf (init_file, \"        {\\n\");\n+\t  fprintf (init_file, \"  if (dfloat64_type_node)\\n\");\n+\t  fprintf (init_file, \"    {\\n\");\n \t}\n \n       fprintf (init_file,\n-\t       \"      rs6000_builtin_decls_x[(int)RS6000_BIF_%s] = t\\n\",\n+\t       \"  rs6000_builtin_decls_x[(int)RS6000_BIF_%s] = t\\n\",\n \t       bifs[i].idname);\n       fprintf (init_file,\n-\t       \"        = add_builtin_function (\\\"%s\\\",\\n\",\n+\t       \"    = add_builtin_function (\\\"%s\\\",\\n\",\n \t       bifs[i].proto.bifname);\n       fprintf (init_file,\n-\t       \"                                %s,\\n\",\n+\t       \"                            %s,\\n\",\n \t       bifs[i].fndecl);\n       fprintf (init_file,\n-\t       \"                                (int)RS6000_BIF_%s,\"\n+\t       \"                            (int)RS6000_BIF_%s,\"\n \t       \" BUILT_IN_MD,\\n\",\n \t       bifs[i].idname);\n       fprintf (init_file,\n-\t       \"                                NULL, NULL_TREE);\\n\");\n+\t       \"                            NULL, NULL_TREE);\\n\");\n       if (bifs[i].kind == FNK_CONST)\n \t{\n-\t  fprintf (init_file, \"      TREE_READONLY (t) = 1;\\n\");\n-\t  fprintf (init_file, \"      TREE_NOTHROW (t) = 1;\\n\");\n+\t  fprintf (init_file, \"  TREE_READONLY (t) = 1;\\n\");\n+\t  fprintf (init_file, \"  TREE_NOTHROW (t) = 1;\\n\");\n \t}\n       else if (bifs[i].kind == FNK_PURE)\n \t{\n-\t  fprintf (init_file, \"      DECL_PURE_P (t) = 1;\\n\");\n-\t  fprintf (init_file, \"      TREE_NOTHROW (t) = 1;\\n\");\n+\t  fprintf (init_file, \"  DECL_PURE_P (t) = 1;\\n\");\n+\t  fprintf (init_file, \"  TREE_NOTHROW (t) = 1;\\n\");\n \t}\n       else if (bifs[i].kind == FNK_FPMATH)\n \t{\n-\t  fprintf (init_file, \"      TREE_NOTHROW (t) = 1;\\n\");\n-\t  fprintf (init_file, \"      if (flag_rounding_math)\\n\");\n-\t  fprintf (init_file, \"        {\\n\");\n-\t  fprintf (init_file, \"          DECL_PURE_P (t) = 1;\\n\");\n-\t  fprintf (init_file, \"          DECL_IS_NOVOPS (t) = 1;\\n\");\n-\t  fprintf (init_file, \"        }\\n\");\n-\t  fprintf (init_file, \"      else\\n\");\n-\t  fprintf (init_file, \"        TREE_READONLY (t) = 1;\\n\");\n+\t  fprintf (init_file, \"  TREE_NOTHROW (t) = 1;\\n\");\n+\t  fprintf (init_file, \"  if (flag_rounding_math)\\n\");\n+\t  fprintf (init_file, \"    {\\n\");\n+\t  fprintf (init_file, \"      DECL_PURE_P (t) = 1;\\n\");\n+\t  fprintf (init_file, \"      DECL_IS_NOVOPS (t) = 1;\\n\");\n+\t  fprintf (init_file, \"    }\\n\");\n+\t  fprintf (init_file, \"  else\\n\");\n+\t  fprintf (init_file, \"    TREE_READONLY (t) = 1;\\n\");\n \t}\n \n       if (tf_found || dfp_found)\n \t{\n-\t  fprintf (init_file, \"        }\\n\");\n-\t  fprintf (init_file, \"      else\\n\");\n-\t  fprintf (init_file, \"        {\\n\");\n-\t  fprintf (init_file, \"          rs6000_builtin_decls_x\"\n+\t  fprintf (init_file, \"    }\\n\");\n+\t  fprintf (init_file, \"  else\\n\");\n+\t  fprintf (init_file, \"    {\\n\");\n+\t  fprintf (init_file, \"      rs6000_builtin_decls_x\"\n \t\t   \"[(int)RS6000_BIF_%s] = NULL_TREE;\\n\", bifs[i].idname);\n-\t  fprintf (init_file, \"        }\\n\");\n+\t  fprintf (init_file, \"    }\\n\");\n \t}\n-      fprintf (init_file, \"    }\\n\\n\");\n+      fprintf (init_file, \"\\n\");\n     }\n }\n \n@@ -2789,41 +2784,37 @@ write_init_ovld_table (void)\n \t\t\t   || strstr (ovlds[i].fndecl, \"dd\") != NULL\n \t\t\t   || strstr (ovlds[i].fndecl, \"td\") != NULL);\n \n-\t  fprintf (init_file,\n-\t\t   \"  if (new_builtins_are_live)\\n\");\n-\t  fprintf (init_file, \"    {\\n\");\n-\n \t  if (tf_found)\n \t    {\n-\t      fprintf (init_file, \"      if (float128_type_node)\\n\");\n-\t      fprintf (init_file, \"        {\\n\");\n+\t      fprintf (init_file, \"  if (float128_type_node)\\n\");\n+\t      fprintf (init_file, \"    {\\n\");\n \t    }\n \t  else if (dfp_found)\n \t    {\n-\t      fprintf (init_file, \"      if (dfloat64_type_node)\\n\");\n-\t      fprintf (init_file, \"        {\\n\");\n+\t      fprintf (init_file, \"  if (dfloat64_type_node)\\n\");\n+\t      fprintf (init_file, \"    {\\n\");\n \t    }\n \n \t  fprintf (init_file,\n-\t\t   \"      rs6000_builtin_decls_x[(int)RS6000_OVLD_%s] = t\\n\",\n+\t\t   \"  rs6000_builtin_decls_x[(int)RS6000_OVLD_%s] = t\\n\",\n \t\t   stanza->stanza_id);\n \t  fprintf (init_file,\n-\t\t   \"        = add_builtin_function (\\\"%s\\\",\\n\",\n+\t\t   \"    = add_builtin_function (\\\"%s\\\",\\n\",\n \t\t   stanza->intern_name);\n \t  fprintf (init_file,\n-\t\t   \"                                %s,\\n\",\n+\t\t   \"                            %s,\\n\",\n \t\t   ovlds[i].fndecl);\n \t  fprintf (init_file,\n-\t\t   \"                                (int)RS6000_OVLD_%s,\"\n+\t\t   \"                            (int)RS6000_OVLD_%s,\"\n \t\t   \" BUILT_IN_MD,\\n\",\n \t\t   stanza->stanza_id);\n \t  fprintf (init_file,\n-\t\t   \"                                NULL, NULL_TREE);\\n\");\n+\t\t   \"                            NULL, NULL_TREE);\\n\");\n \n \t  if (tf_found || dfp_found)\n-\t    fprintf (init_file, \"        }\\n\");\n+\t    fprintf (init_file, \"    }\\n\");\n \n-\t  fprintf (init_file, \"    }\\n\\n\");\n+\t  fprintf (init_file, \"\\n\");\n \n \t  fprintf (init_file,\n \t\t   \"  rs6000_overload_info[RS6000_OVLD_%s - base]\"\n@@ -2854,8 +2845,6 @@ write_init_file (void)\n   fprintf (init_file, \"#include \\\"rs6000-builtins.h\\\"\\n\");\n   fprintf (init_file, \"\\n\");\n \n-  fprintf (init_file, \"int new_builtins_are_live = 1;\\n\\n\");\n-\n   fprintf (init_file, \"tree rs6000_builtin_decls_x[RS6000_OVLD_MAX];\\n\\n\");\n \n   write_bif_static_init ();"}, {"sha": "70df511ff9813efc749cd8dfb1ed56f9a52dec27", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 7, "deletions": 249, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cf62ef5aa80e3659a8150a48d93a1d333f1d292/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cf62ef5aa80e3659a8150a48d93a1d333f1d292/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=2cf62ef5aa80e3659a8150a48d93a1d333f1d292", "patch": "@@ -5929,132 +5929,7 @@ static tree\n rs6000_builtin_vectorized_function (unsigned int fn, tree type_out,\n \t\t\t\t    tree type_in)\n {\n-  machine_mode in_mode, out_mode;\n-  int in_n, out_n;\n-\n-  if (new_builtins_are_live)\n-    return rs6000_new_builtin_vectorized_function (fn, type_out, type_in);\n-\n-  if (TARGET_DEBUG_BUILTIN)\n-    fprintf (stderr, \"rs6000_builtin_vectorized_function (%s, %s, %s)\\n\",\n-\t     combined_fn_name (combined_fn (fn)),\n-\t     GET_MODE_NAME (TYPE_MODE (type_out)),\n-\t     GET_MODE_NAME (TYPE_MODE (type_in)));\n-\n-  if (TREE_CODE (type_out) != VECTOR_TYPE\n-      || TREE_CODE (type_in) != VECTOR_TYPE)\n-    return NULL_TREE;\n-\n-  out_mode = TYPE_MODE (TREE_TYPE (type_out));\n-  out_n = TYPE_VECTOR_SUBPARTS (type_out);\n-  in_mode = TYPE_MODE (TREE_TYPE (type_in));\n-  in_n = TYPE_VECTOR_SUBPARTS (type_in);\n-\n-  switch (fn)\n-    {\n-    CASE_CFN_COPYSIGN:\n-      if (VECTOR_UNIT_VSX_P (V2DFmode)\n-\t  && out_mode == DFmode && out_n == 2\n-\t  && in_mode == DFmode && in_n == 2)\n-\treturn rs6000_builtin_decls[VSX_BUILTIN_CPSGNDP];\n-      if (VECTOR_UNIT_VSX_P (V4SFmode)\n-\t  && out_mode == SFmode && out_n == 4\n-\t  && in_mode == SFmode && in_n == 4)\n-\treturn rs6000_builtin_decls[VSX_BUILTIN_CPSGNSP];\n-      if (VECTOR_UNIT_ALTIVEC_P (V4SFmode)\n-\t  && out_mode == SFmode && out_n == 4\n-\t  && in_mode == SFmode && in_n == 4)\n-\treturn rs6000_builtin_decls[ALTIVEC_BUILTIN_COPYSIGN_V4SF];\n-      break;\n-    CASE_CFN_CEIL:\n-      if (VECTOR_UNIT_VSX_P (V2DFmode)\n-\t  && out_mode == DFmode && out_n == 2\n-\t  && in_mode == DFmode && in_n == 2)\n-\treturn rs6000_builtin_decls[VSX_BUILTIN_XVRDPIP];\n-      if (VECTOR_UNIT_VSX_P (V4SFmode)\n-\t  && out_mode == SFmode && out_n == 4\n-\t  && in_mode == SFmode && in_n == 4)\n-\treturn rs6000_builtin_decls[VSX_BUILTIN_XVRSPIP];\n-      if (VECTOR_UNIT_ALTIVEC_P (V4SFmode)\n-\t  && out_mode == SFmode && out_n == 4\n-\t  && in_mode == SFmode && in_n == 4)\n-\treturn rs6000_builtin_decls[ALTIVEC_BUILTIN_VRFIP];\n-      break;\n-    CASE_CFN_FLOOR:\n-      if (VECTOR_UNIT_VSX_P (V2DFmode)\n-\t  && out_mode == DFmode && out_n == 2\n-\t  && in_mode == DFmode && in_n == 2)\n-\treturn rs6000_builtin_decls[VSX_BUILTIN_XVRDPIM];\n-      if (VECTOR_UNIT_VSX_P (V4SFmode)\n-\t  && out_mode == SFmode && out_n == 4\n-\t  && in_mode == SFmode && in_n == 4)\n-\treturn rs6000_builtin_decls[VSX_BUILTIN_XVRSPIM];\n-      if (VECTOR_UNIT_ALTIVEC_P (V4SFmode)\n-\t  && out_mode == SFmode && out_n == 4\n-\t  && in_mode == SFmode && in_n == 4)\n-\treturn rs6000_builtin_decls[ALTIVEC_BUILTIN_VRFIM];\n-      break;\n-    CASE_CFN_FMA:\n-      if (VECTOR_UNIT_VSX_P (V2DFmode)\n-\t  && out_mode == DFmode && out_n == 2\n-\t  && in_mode == DFmode && in_n == 2)\n-\treturn rs6000_builtin_decls[VSX_BUILTIN_XVMADDDP];\n-      if (VECTOR_UNIT_VSX_P (V4SFmode)\n-\t  && out_mode == SFmode && out_n == 4\n-\t  && in_mode == SFmode && in_n == 4)\n-\treturn rs6000_builtin_decls[VSX_BUILTIN_XVMADDSP];\n-      if (VECTOR_UNIT_ALTIVEC_P (V4SFmode)\n-\t  && out_mode == SFmode && out_n == 4\n-\t  && in_mode == SFmode && in_n == 4)\n-\treturn rs6000_builtin_decls[ALTIVEC_BUILTIN_VMADDFP];\n-      break;\n-    CASE_CFN_TRUNC:\n-      if (VECTOR_UNIT_VSX_P (V2DFmode)\n-\t  && out_mode == DFmode && out_n == 2\n-\t  && in_mode == DFmode && in_n == 2)\n-\treturn rs6000_builtin_decls[VSX_BUILTIN_XVRDPIZ];\n-      if (VECTOR_UNIT_VSX_P (V4SFmode)\n-\t  && out_mode == SFmode && out_n == 4\n-\t  && in_mode == SFmode && in_n == 4)\n-\treturn rs6000_builtin_decls[VSX_BUILTIN_XVRSPIZ];\n-      if (VECTOR_UNIT_ALTIVEC_P (V4SFmode)\n-\t  && out_mode == SFmode && out_n == 4\n-\t  && in_mode == SFmode && in_n == 4)\n-\treturn rs6000_builtin_decls[ALTIVEC_BUILTIN_VRFIZ];\n-      break;\n-    CASE_CFN_NEARBYINT:\n-      if (VECTOR_UNIT_VSX_P (V2DFmode)\n-\t  && flag_unsafe_math_optimizations\n-\t  && out_mode == DFmode && out_n == 2\n-\t  && in_mode == DFmode && in_n == 2)\n-\treturn rs6000_builtin_decls[VSX_BUILTIN_XVRDPI];\n-      if (VECTOR_UNIT_VSX_P (V4SFmode)\n-\t  && flag_unsafe_math_optimizations\n-\t  && out_mode == SFmode && out_n == 4\n-\t  && in_mode == SFmode && in_n == 4)\n-\treturn rs6000_builtin_decls[VSX_BUILTIN_XVRSPI];\n-      break;\n-    CASE_CFN_RINT:\n-      if (VECTOR_UNIT_VSX_P (V2DFmode)\n-\t  && !flag_trapping_math\n-\t  && out_mode == DFmode && out_n == 2\n-\t  && in_mode == DFmode && in_n == 2)\n-\treturn rs6000_builtin_decls[VSX_BUILTIN_XVRDPIC];\n-      if (VECTOR_UNIT_VSX_P (V4SFmode)\n-\t  && !flag_trapping_math\n-\t  && out_mode == SFmode && out_n == 4\n-\t  && in_mode == SFmode && in_n == 4)\n-\treturn rs6000_builtin_decls[VSX_BUILTIN_XVRSPIC];\n-      break;\n-    default:\n-      break;\n-    }\n-\n-  /* Generate calls to libmass if appropriate.  */\n-  if (rs6000_veclib_handler)\n-    return rs6000_veclib_handler (combined_fn (fn), type_out, type_in);\n-\n-  return NULL_TREE;\n+  return rs6000_new_builtin_vectorized_function (fn, type_out, type_in);\n }\n \n /* Implement TARGET_VECTORIZE_BUILTIN_MD_VECTORIZED_FUNCTION.  */\n@@ -6063,113 +5938,7 @@ static tree\n rs6000_builtin_md_vectorized_function (tree fndecl, tree type_out,\n \t\t\t\t       tree type_in)\n {\n-  machine_mode in_mode, out_mode;\n-  int in_n, out_n;\n-\n-  if (new_builtins_are_live)\n-    return rs6000_new_builtin_md_vectorized_function (fndecl, type_out,\n-\t\t\t\t\t\t      type_in);\n-\n-  if (TARGET_DEBUG_BUILTIN)\n-    fprintf (stderr, \"rs6000_builtin_md_vectorized_function (%s, %s, %s)\\n\",\n-\t     IDENTIFIER_POINTER (DECL_NAME (fndecl)),\n-\t     GET_MODE_NAME (TYPE_MODE (type_out)),\n-\t     GET_MODE_NAME (TYPE_MODE (type_in)));\n-\n-  if (TREE_CODE (type_out) != VECTOR_TYPE\n-      || TREE_CODE (type_in) != VECTOR_TYPE)\n-    return NULL_TREE;\n-\n-  out_mode = TYPE_MODE (TREE_TYPE (type_out));\n-  out_n = TYPE_VECTOR_SUBPARTS (type_out);\n-  in_mode = TYPE_MODE (TREE_TYPE (type_in));\n-  in_n = TYPE_VECTOR_SUBPARTS (type_in);\n-\n-  enum rs6000_builtins fn\n-    = (enum rs6000_builtins) DECL_MD_FUNCTION_CODE (fndecl);\n-  switch (fn)\n-    {\n-    case RS6000_BUILTIN_RSQRTF:\n-      if (VECTOR_UNIT_ALTIVEC_OR_VSX_P (V4SFmode)\n-\t  && out_mode == SFmode && out_n == 4\n-\t  && in_mode == SFmode && in_n == 4)\n-\treturn rs6000_builtin_decls[ALTIVEC_BUILTIN_VRSQRTFP];\n-      break;\n-    case RS6000_BUILTIN_RSQRT:\n-      if (VECTOR_UNIT_VSX_P (V2DFmode)\n-\t  && out_mode == DFmode && out_n == 2\n-\t  && in_mode == DFmode && in_n == 2)\n-\treturn rs6000_builtin_decls[VSX_BUILTIN_RSQRT_2DF];\n-      break;\n-    case RS6000_BUILTIN_RECIPF:\n-      if (VECTOR_UNIT_ALTIVEC_OR_VSX_P (V4SFmode)\n-\t  && out_mode == SFmode && out_n == 4\n-\t  && in_mode == SFmode && in_n == 4)\n-\treturn rs6000_builtin_decls[ALTIVEC_BUILTIN_VRECIPFP];\n-      break;\n-    case RS6000_BUILTIN_RECIP:\n-      if (VECTOR_UNIT_VSX_P (V2DFmode)\n-\t  && out_mode == DFmode && out_n == 2\n-\t  && in_mode == DFmode && in_n == 2)\n-\treturn rs6000_builtin_decls[VSX_BUILTIN_RECIP_V2DF];\n-      break;\n-    default:\n-      break;\n-    }\n-\n-  machine_mode in_vmode = TYPE_MODE (type_in);\n-  machine_mode out_vmode = TYPE_MODE (type_out);\n-\n-  /* Power10 supported vectorized built-in functions.  */\n-  if (TARGET_POWER10\n-      && in_vmode == out_vmode\n-      && VECTOR_UNIT_ALTIVEC_OR_VSX_P (in_vmode))\n-    {\n-      machine_mode exp_mode = DImode;\n-      machine_mode exp_vmode = V2DImode;\n-      enum rs6000_builtins bif;\n-      switch (fn)\n-\t{\n-\tcase MISC_BUILTIN_DIVWE:\n-\tcase MISC_BUILTIN_DIVWEU:\n-\t  exp_mode = SImode;\n-\t  exp_vmode = V4SImode;\n-\t  if (fn == MISC_BUILTIN_DIVWE)\n-\t    bif = P10V_BUILTIN_DIVES_V4SI;\n-\t  else\n-\t    bif = P10V_BUILTIN_DIVEU_V4SI;\n-\t  break;\n-\tcase MISC_BUILTIN_DIVDE:\n-\tcase MISC_BUILTIN_DIVDEU:\n-\t  if (fn == MISC_BUILTIN_DIVDE)\n-\t    bif = P10V_BUILTIN_DIVES_V2DI;\n-\t  else\n-\t    bif = P10V_BUILTIN_DIVEU_V2DI;\n-\t  break;\n-\tcase P10_BUILTIN_CFUGED:\n-\t  bif = P10V_BUILTIN_VCFUGED;\n-\t  break;\n-\tcase P10_BUILTIN_CNTLZDM:\n-\t  bif = P10V_BUILTIN_VCLZDM;\n-\t  break;\n-\tcase P10_BUILTIN_CNTTZDM:\n-\t  bif = P10V_BUILTIN_VCTZDM;\n-\t  break;\n-\tcase P10_BUILTIN_PDEPD:\n-\t  bif = P10V_BUILTIN_VPDEPD;\n-\t  break;\n-\tcase P10_BUILTIN_PEXTD:\n-\t  bif = P10V_BUILTIN_VPEXTD;\n-\t  break;\n-\tdefault:\n-\t  return NULL_TREE;\n-\t}\n-\n-      if (in_mode == exp_mode && in_vmode == exp_vmode)\n-\treturn rs6000_builtin_decls[bif];\n-    }\n-\n-  return NULL_TREE;\n+  return rs6000_new_builtin_md_vectorized_function (fndecl, type_out, type_in);\n }\n \f\n /* Default CPU string for rs6000*_file_start functions.  */\n@@ -22749,17 +22518,13 @@ rs6000_builtin_reciprocal (tree fndecl)\n       if (!RS6000_RECIP_AUTO_RSQRTE_P (V2DFmode))\n \treturn NULL_TREE;\n \n-      if (new_builtins_are_live)\n-\treturn rs6000_builtin_decls_x[RS6000_BIF_RSQRT_2DF];\n-      return rs6000_builtin_decls[VSX_BUILTIN_RSQRT_2DF];\n+      return rs6000_builtin_decls_x[RS6000_BIF_RSQRT_2DF];\n \n     case RS6000_BIF_XVSQRTSP:\n       if (!RS6000_RECIP_AUTO_RSQRTE_P (V4SFmode))\n \treturn NULL_TREE;\n \n-      if (new_builtins_are_live)\n-\treturn rs6000_builtin_decls_x[RS6000_BIF_RSQRT_4SF];\n-      return rs6000_builtin_decls[VSX_BUILTIN_RSQRT_4SF];\n+      return rs6000_builtin_decls_x[RS6000_BIF_RSQRT_4SF];\n \n     default:\n       return NULL_TREE;\n@@ -25381,10 +25146,7 @@ add_condition_to_bb (tree function_decl, tree version_decl,\n \n   tree bool_zero = build_int_cst (bool_int_type_node, 0);\n   tree cond_var = create_tmp_var (bool_int_type_node);\n-  tree predicate_decl\n-    = new_builtins_are_live\n-\t? rs6000_builtin_decls_x[(int) RS6000_BIF_CPU_SUPPORTS]\n-\t: rs6000_builtin_decls [(int) RS6000_BUILTIN_CPU_SUPPORTS];\n+  tree predicate_decl = rs6000_builtin_decls_x[(int) RS6000_BIF_CPU_SUPPORTS];\n   const char *arg_str = rs6000_clone_map[clone_isa].name;\n   tree predicate_arg = build_string_literal (strlen (arg_str) + 1, arg_str);\n   gimple *call_cond_stmt = gimple_build_call (predicate_decl, 1, predicate_arg);\n@@ -28024,12 +27786,8 @@ rs6000_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)\n       return;\n     }\n \n-  tree mffs\n-    = new_builtins_are_live ? rs6000_builtin_decls_x[RS6000_BIF_MFFS]\n-\t\t\t    : rs6000_builtin_decls[RS6000_BUILTIN_MFFS];\n-  tree mtfsf\n-    = new_builtins_are_live ? rs6000_builtin_decls_x[RS6000_BIF_MTFSF]\n-\t\t\t    : rs6000_builtin_decls[RS6000_BUILTIN_MTFSF];\n+  tree mffs = rs6000_builtin_decls_x[RS6000_BIF_MFFS];\n+  tree mtfsf = rs6000_builtin_decls_x[RS6000_BIF_MTFSF];\n   tree call_mffs = build_call_expr (mffs, 0);\n \n   /* Generates the equivalent of feholdexcept (&fenv_var)"}]}