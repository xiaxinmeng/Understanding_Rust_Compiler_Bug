{"sha": "93f7aeea7ac79573748c5f2632059aa6b50d74e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNmN2FlZWE3YWM3OTU3Mzc0OGM1ZjI2MzIwNTlhYTZiNTBkNzRlMg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2002-06-13T18:16:26Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-06-13T18:16:26Z"}, "message": "natString.cc (init): Handle case where DONT_COPY is true and OFFSET!=0.\n\n\t* java/lang/natString.cc (init): Handle case where DONT_COPY is\n\ttrue and OFFSET!=0.\n\t* java/lang/String.java (String(char[],int,int,boolean): New\n\tconstructor.\n\t* java/lang/Long.java: Imported new version from Classpath.\n\t* java/lang/Number.java: Likewise.\n\t* java/lang/Integer.java: Likewise.\n\t* java/lang/Long.java: Likewise.\n\t* java/lang/Float.java: Likewise.\n\t* java/lang/Boolean.java: Likewise.\n\t* java/lang/Double.java: Likewise.\n\t* java/lang/Void.java: Likewise.\n\nFrom-SVN: r54595", "tree": {"sha": "fbd871ac981d77c90c17e4051a89bbbdb5953005", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fbd871ac981d77c90c17e4051a89bbbdb5953005"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93f7aeea7ac79573748c5f2632059aa6b50d74e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93f7aeea7ac79573748c5f2632059aa6b50d74e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93f7aeea7ac79573748c5f2632059aa6b50d74e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93f7aeea7ac79573748c5f2632059aa6b50d74e2/comments", "author": null, "committer": null, "parents": [{"sha": "a8fa30f301536452a5840e8f605ff7a568174881", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8fa30f301536452a5840e8f605ff7a568174881", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8fa30f301536452a5840e8f605ff7a568174881"}], "stats": {"total": 3247, "additions": 1699, "deletions": 1548}, "files": [{"sha": "1b97fe772d7d4df555efdd57efd4544718faab92", "filename": "libjava/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f7aeea7ac79573748c5f2632059aa6b50d74e2/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f7aeea7ac79573748c5f2632059aa6b50d74e2/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=93f7aeea7ac79573748c5f2632059aa6b50d74e2", "patch": "@@ -1,3 +1,18 @@\n+2002-06-13  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/lang/natString.cc (init): Handle case where DONT_COPY is\n+\ttrue and OFFSET!=0.\n+\t* java/lang/String.java (String(char[],int,int,boolean): New\n+\tconstructor.\n+\t* java/lang/Long.java: Imported new version from Classpath.\n+\t* java/lang/Number.java: Likewise.\n+\t* java/lang/Integer.java: Likewise.\n+\t* java/lang/Long.java: Likewise.\n+\t* java/lang/Float.java: Likewise.\n+\t* java/lang/Boolean.java: Likewise.\n+\t* java/lang/Double.java: Likewise.\n+\t* java/lang/Void.java: Likewise.\n+\n 2002-06-12  Tom Tromey  <tromey@redhat.com>\n \n \t* java/io/natFilePosix.cc (getCanonicalPath): Treat \"\" like \".\"."}, {"sha": "3c09a1505c1160704941a323eb40b22969cbaf2f", "filename": "libjava/java/lang/Boolean.java", "status": "modified", "additions": 177, "deletions": 141, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f7aeea7ac79573748c5f2632059aa6b50d74e2/libjava%2Fjava%2Flang%2FBoolean.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f7aeea7ac79573748c5f2632059aa6b50d74e2/libjava%2Fjava%2Flang%2FBoolean.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FBoolean.java?ref=93f7aeea7ac79573748c5f2632059aa6b50d74e2", "patch": "@@ -1,13 +1,13 @@\n /* Boolean.java -- object wrapper for boolean\n-   Copyright (C) 1998, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -41,148 +41,184 @@\n import java.io.Serializable;\n \n /**\n- * Instances of class <code>Boolean</code> represent primitive \n+ * Instances of class <code>Boolean</code> represent primitive\n  * <code>boolean</code> values.\n  *\n  * @author Paul Fisher\n- * @since JDK1.0\n- */ \n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @since 1.0\n+ * @status updated to 1.4\n+ */\n public final class Boolean implements Serializable\n {\n-    static final long serialVersionUID = -3665804199014368530L;\n-    \n-    /**\n-     * This field is a <code>Boolean</code> object representing the\n-     * primitive value <code>true</code>. This instance is returned\n-     * by the static <code>valueOf()</code> methods if they return\n-     * a <code>Boolean</code> representing <code>true</code>.\n-     */\n-    public static final Boolean TRUE  = new Boolean(true);\n-    \n-    /**\n-     * This field is a <code>Boolean</code> object representing the \n-     * primitive value <code>false</code>. This instance is returned\n-     * by the static <code>valueOf()</code> methods if they return\n-     * a <code>Boolean</code> representing <code>false</code>.\n-     */\n-     public static final Boolean FALSE = new Boolean(false);\n-\n-    /**\n-     * The primitive type <code>boolean</code> is represented by this \n-     * <code>Class</code> object.\n-     */\n-    public static final Class TYPE = VMClassLoader.getPrimitiveClass('Z');\n-    \n-    /**\n-     * The immutable value of this Boolean.\n-     */\n-    private final boolean value;\n-    \n-    /**\n-     * Create a <code>Boolean</code> object representing the value of the \n-     * argument <code>value</code>. In general the use of the static\n-     * method <code>valueof(boolean)</code> is more efficient since it will\n-     * not create a new object.\n-     *\n-     * @param value the primitive value of this <code>Boolean</code>\n-     */    \n-    public Boolean(boolean value) {\n-\tthis.value = value;\n-    }\n-    \n-    /**\n-     * Creates a <code>Boolean</code> object representing the primitive \n-     * <code>true</code> if and only if <code>s</code> matches \n-     * the string \"true\" ignoring case, otherwise the object will represent \n-     * the primitive <code>false</code>. In general the use of the static\n-     * method <code>valueof(String)</code> is more efficient since it will\n-     * not create a new object.\n-     *\n-     * @param s the <code>String</code> representation of <code>true</code>\n-     *   or false\n-     */\n-    public Boolean(String s) {\n-\tvalue = \"true\".equalsIgnoreCase(s);\n-    }\n-\n-    /**\n-     * Return the primitive <code>boolean</code> value of this \n-     * <code>Boolean</code> object.\n-     */\n-    public boolean booleanValue() {\n-\treturn value;\n-    }\n-\n-    /**\n-     * Returns the Boolean <code>TRUE</code> if the given boolean is\n-     * <code>true</code>, otherwise it will return the Boolean\n-     * <code>FALSE</code>.\n-     *\n-     * @since 1.4\n-     */\n-    public static Boolean valueOf(boolean b) {\n-    \treturn b ? TRUE : FALSE;\n-    }\n-\n-    /**\n-     * Returns the Boolean <code>TRUE</code> if and only if the given\n-     * String is equal, ignoring case, to the the String \"true\", otherwise\n-     * it will return the Boolean <code>FALSE</code>.\n-     */\n-    public static Boolean valueOf(String s) {\n-    \treturn \"true\".equalsIgnoreCase(s) ? TRUE : FALSE;\n-    }\n-\n-    /**\n-     * Returns the integer <code>1231</code> if this object represents \n-     * the primitive <code>true</code> and the integer <code>1237</code>\n-     * otherwise.\n-     */    \n-    public int hashCode() {\n-\treturn (value) ? 1231 : 1237;\n-    }\n-\n-    /**\n-     * If the <code>obj</code> is an instance of <code>Boolean</code> and\n-     * has the same primitive value as this object then <code>true</code>\n-     * is returned.  In all other cases, including if the <code>obj</code>\n-     * is <code>null</code>, <code>false</code> is returned.\n-     *\n-     * @param obj possibly an instance of any <code>Class</code>\n-     * @return <code>false</code> is <code>obj</code> is an instance of\n-     *   <code>Boolean</code> and has the same primitive value as this \n-     *   object.\n-     */    \n-    public boolean equals(Object obj) {\n-\treturn (obj instanceof Boolean && value == ((Boolean)obj).value);\n-    }\n-\n-    /**\n-     * If the value of the system property <code>name</code> matches\n-     * \"true\" ignoring case then the function returns <code>true</code>.\n-     */\n-    public static boolean getBoolean(String name) {\n-\tString val = System.getProperty(name);\n-\treturn (\"true\".equalsIgnoreCase(val));\n-    }\n-    \n-    /**\n-     * Returns \"true\" if the value of the give boolean is <code>true</code> and\n-     * returns \"false\" if the value of the given boolean is <code>false</code>.\n-     *\n-     * @since 1.4\n-     */\n-    public static String toString(boolean b)\n-    {\n-\treturn b ? \"true\" : \"false\";\n-    }\n-\n-    /**\n-     * Returns \"true\" if the value of this object is <code>true</code> and\n-     * returns \"false\" if the value of this object is <code>false</code>.\n-     */\n-    public String toString()\n-    {\n-\treturn (value) ? \"true\" : \"false\";\n-    }   \n+  /**\n+   * Compatible with JDK 1.0.2+.\n+   */\n+  private static final long serialVersionUID = -3665804199014368530L;\n+\n+  /**\n+   * This field is a <code>Boolean</code> object representing the\n+   * primitive value <code>true</code>. This instance is returned\n+   * by the static <code>valueOf()</code> methods if they return\n+   * a <code>Boolean</code> representing <code>true</code>.\n+   */\n+  public static final Boolean TRUE = new Boolean(true);\n+\n+  /**\n+   * This field is a <code>Boolean</code> object representing the\n+   * primitive value <code>false</code>. This instance is returned\n+   * by the static <code>valueOf()</code> methods if they return\n+   * a <code>Boolean</code> representing <code>false</code>.\n+   */\n+  public static final Boolean FALSE = new Boolean(false);\n+\n+  /**\n+   * The primitive type <code>boolean</code> is represented by this\n+   * <code>Class</code> object.\n+   *\n+   * @since 1.1\n+   */\n+  public static final Class TYPE = VMClassLoader.getPrimitiveClass('Z');\n+\n+  /**\n+   * The immutable value of this Boolean.\n+   * @serial the wrapped value\n+   */\n+  private final boolean value;\n+\n+  /**\n+   * Create a <code>Boolean</code> object representing the value of the\n+   * argument <code>value</code>. In general the use of the static\n+   * method <code>valueof(boolean)</code> is more efficient since it will\n+   * not create a new object.\n+   *\n+   * @param value the primitive value of this <code>Boolean</code>\n+   * @see #valueOf(boolean)\n+   */\n+  public Boolean(boolean value)\n+  {\n+    this.value = value;\n+  }\n+\n+  /**\n+   * Creates a <code>Boolean</code> object representing the primitive\n+   * <code>true</code> if and only if <code>s</code> matches\n+   * the string \"true\" ignoring case, otherwise the object will represent\n+   * the primitive <code>false</code>. In general the use of the static\n+   * method <code>valueof(String)</code> is more efficient since it will\n+   * not create a new object.\n+   *\n+   * @param s the <code>String</code> representation of <code>true</code>\n+   *        or false\n+   */\n+  public Boolean(String s)\n+  {\n+    value = \"true\".equalsIgnoreCase(s);\n+  }\n+\n+  /**\n+   * Return the primitive <code>boolean</code> value of this\n+   * <code>Boolean</code> object.\n+   *\n+   * @return true or false, depending on the value of this Boolean\n+   */\n+  public boolean booleanValue()\n+  {\n+    return value;\n+  }\n+\n+  /**\n+   * Returns the Boolean <code>TRUE</code> if the given boolean is\n+   * <code>true</code>, otherwise it will return the Boolean\n+   * <code>FALSE</code>.\n+   *\n+   * @param b the boolean to wrap\n+   * @return the wrapper object\n+   * @see #TRUE\n+   * @see #FALSE\n+   * @since 1.4\n+   */\n+  public static Boolean valueOf(boolean b)\n+  {\n+    return b ? TRUE : FALSE;\n+  }\n+\n+  /**\n+   * Returns the Boolean <code>TRUE</code> if and only if the given\n+   * String is equal, ignoring case, to the the String \"true\", otherwise\n+   * it will return the Boolean <code>FALSE</code>.\n+   *\n+   * @param s the string to convert\n+   * @return a wrapped boolean from the string\n+   */\n+  public static Boolean valueOf(String s)\n+  {\n+    return \"true\".equalsIgnoreCase(s) ? TRUE : FALSE;\n+  }\n+\n+  /**\n+   * Returns \"true\" if the value of the give boolean is <code>true</code> and\n+   * returns \"false\" if the value of the given boolean is <code>false</code>.\n+   *\n+   * @param b the boolean to convert\n+   * @return the string representation of the boolean\n+   * @since 1.4\n+   */\n+  public static String toString(boolean b)\n+  {\n+    return b ? \"true\" : \"false\";\n+  }\n+\n+  /**\n+   * Returns \"true\" if the value of this object is <code>true</code> and\n+   * returns \"false\" if the value of this object is <code>false</code>.\n+   *\n+   * @return the string representation of this\n+   */\n+  public String toString()\n+  {\n+    return value ? \"true\" : \"false\";\n+  }\n+\n+  /**\n+   * Returns the integer <code>1231</code> if this object represents\n+   * the primitive <code>true</code> and the integer <code>1237</code>\n+   * otherwise.\n+   *\n+   * @return the hash code\n+   */\n+  public int hashCode()\n+  {\n+    return value ? 1231 : 1237;\n+  }\n+\n+  /**\n+   * If the <code>obj</code> is an instance of <code>Boolean</code> and\n+   * has the same primitive value as this object then <code>true</code>\n+   * is returned.  In all other cases, including if the <code>obj</code>\n+   * is <code>null</code>, <code>false</code> is returned.\n+   *\n+   * @param obj possibly an instance of any <code>Class</code>\n+   * @return true if <code>obj</code> equals this\n+   */\n+  public boolean equals(Object obj)\n+  {\n+    return obj instanceof Boolean && value == ((Boolean) obj).value;\n+  }\n+\n+  /**\n+   * If the value of the system property <code>name</code> matches\n+   * \"true\" ignoring case then the function returns <code>true</code>.\n+   *\n+   * @param name the property name to look up\n+   * @return true if the property resulted in \"true\"\n+   * @throws SecurityException if accessing the system property is forbidden\n+   * @see System#getProperty(String)\n+   */\n+  public static boolean getBoolean(String name)\n+  {\n+    if (name == null || \"\".equals(name))\n+      return false;\n+    return \"true\".equalsIgnoreCase(System.getProperty(name));\n+  }\n }"}, {"sha": "22f2b5f524a4ba2fc5343a00d6f1cdf9912c58a2", "filename": "libjava/java/lang/Double.java", "status": "modified", "additions": 325, "deletions": 313, "changes": 638, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f7aeea7ac79573748c5f2632059aa6b50d74e2/libjava%2Fjava%2Flang%2FDouble.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f7aeea7ac79573748c5f2632059aa6b50d74e2/libjava%2Fjava%2Flang%2FDouble.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FDouble.java?ref=93f7aeea7ac79573748c5f2632059aa6b50d74e2", "patch": "@@ -1,4 +1,4 @@\n-/* Double.java -- object wrapper for double primitive\n+/* Double.java -- object wrapper for double\n    Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -40,12 +40,6 @@\n \n import gnu.classpath.Configuration;\n \n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete and correct.\n- */\n-\n /**\n  * Instances of class <code>Double</code> represent primitive\n  * <code>double</code> values.\n@@ -55,60 +49,68 @@\n  *\n  * @author Paul Fisher\n  * @author Andrew Haley <aph@cygnus.com>\n- * @since JDK 1.0\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @since 1.0\n+ * @status updated to 1.4\n  */\n public final class Double extends Number implements Comparable\n {\n   /**\n-   * The minimum positive value a <code>double</code> may represent\n-   * is 5e-324.\n+   * Compatible with JDK 1.0+.\n    */\n-  public static final double MIN_VALUE = 5e-324;\n+  private static final long serialVersionUID = -9172774392245257468L;\n \n   /**\n    * The maximum positive value a <code>double</code> may represent\n    * is 1.7976931348623157e+308.\n    */\n   public static final double MAX_VALUE = 1.7976931348623157e+308;\n \n+  /**\n+   * The minimum positive value a <code>double</code> may represent\n+   * is 5e-324.\n+   */\n+  public static final double MIN_VALUE = 5e-324;\n+\n   /**\n    * The value of a double representation -1.0/0.0, negative\n-   * infinity.  \n+   * infinity.\n    */\n-  public static final double NEGATIVE_INFINITY = -1.0d/0.0d;\n+  public static final double NEGATIVE_INFINITY = -1.0 / 0.0;\n \n   /**\n    * The value of a double representing 1.0/0.0, positive infinity.\n    */\n-  public static final double POSITIVE_INFINITY = 1.0d/0.0d;\n+  public static final double POSITIVE_INFINITY = 1.0 / 0.0;\n \n   /**\n    * All IEEE 754 values of NaN have the same value in Java.\n    */\n-  public static final double NaN = 0.0d/0.0d;\n+  public static final double NaN = 0.0 / 0.0;\n \n   /**\n    * The primitive type <code>double</code> is represented by this\n    * <code>Class</code> object.\n+   * @since 1.1\n    */\n   public static final Class TYPE = VMClassLoader.getPrimitiveClass('D');\n \n   /**\n    * The immutable value of this Double.\n+   *\n+   * @serial the wrapped double\n    */\n   private final double value;\n \n-  private static final long serialVersionUID = -9172774392245257468L;\n-\n   /**\n-   * Load native routines necessary for this class.  \n+   * Load native routines necessary for this class.\n    */\n   static\n   {\n     if (Configuration.INIT_LOAD_LIBRARY)\n       {\n-\tSystem.loadLibrary (\"javalang\");\n-\tinitIDs ();\n+\tSystem.loadLibrary(\"javalang\");\n+\tinitIDs();\n       }\n   }\n \n@@ -118,411 +120,421 @@ public final class Double extends Number implements Comparable\n    *\n    * @param value the <code>double</code> argument\n    */\n-  public Double (double value)\n+  public Double(double value)\n   {\n     this.value = value;\n   }\n \n   /**\n-   * Create a <code>Double</code> from the specified\n-   * <code>String</code>.\n-   *\n+   * Create a <code>Double</code> from the specified <code>String</code>.\n    * This method calls <code>Double.parseDouble()</code>.\n    *\n-   * @exception NumberFormatException when the <code>String</code> cannot\n-   *            be parsed into a <code>Float</code>.\n    * @param s the <code>String</code> to convert\n-   * @see #parseDouble(java.lang.String) \n+   * @throws NumberFormatException if <code>s</code> cannot be parsed as a\n+   *         <code>double</code>\n+   * @throws NullPointerException if <code>s</code> is null\n+   * @see #parseDouble(String)\n    */\n-  public Double (String s) throws NumberFormatException\n+  public Double(String s)\n   {\n-    value = parseDouble (s);\n+    value = parseDouble(s);\n   }\n \n   /**\n-   * Convert the <code>double</code> value of this <code>Double</code>\n-   * to a <code>String</code>.  This method calls\n-   * <code>Double.toString(double)</code> to do its dirty work.\n+   * Convert the <code>double</code> to a <code>String</code>.\n+   * Floating-point string representation is fairly complex: here is a\n+   * rundown of the possible values.  \"<code>[-]</code>\" indicates that a\n+   * negative sign will be printed if the value (or exponent) is negative.\n+   * \"<code>&lt;number&gt;</code>\" means a string of digits ('0' to '9').\n+   * \"<code>&lt;digit&gt;</code>\" means a single digit ('0' to '9').<br>\n    *\n-   * @return the <code>String</code> representation of this <code>Double</code>.\n-   * @see #toString(double)\n+   * <table border=1>\n+   * <tr><th>Value of Double</th><th>String Representation</th></tr>\n+   * <tr><td>[+-] 0</td> <td><code>[-]0.0</code></td></tr>\n+   * <tr><td>Between [+-] 10<sup>-3</sup> and 10<sup>7</sup>, exclusive</td>\n+   *     <td><code>[-]number.number</code></td></tr>\n+   * <tr><td>Other numeric value</td>\n+   *     <td><code>[-]&lt;digit&gt;.&lt;number&gt;\n+   *          E[-]&lt;number&gt;</code></td></tr>\n+   * <tr><td>[+-] infinity</td> <td><code>[-]Infinity</code></td></tr>\n+   * <tr><td>NaN</td> <td><code>NaN</code></td></tr>\n+   * </table>\n+   *\n+   * Yes, negative zero <em>is</em> a possible value.  Note that there is\n+   * <em>always</em> a <code>.</code> and at least one digit printed after\n+   * it: even if the number is 3, it will be printed as <code>3.0</code>.\n+   * After the \".\", all digits will be printed except trailing zeros. The\n+   * result is rounded to the shortest decimal number which will parse back\n+   * to the same double.\n+   *\n+   * <p>To create other output formats, use {@link java.text.NumberFormat}.\n+   *\n+   * @XXX specify where we are not in accord with the spec.\n+   *\n+   * @param d the <code>double</code> to convert\n+   * @return the <code>String</code> representing the <code>double</code>\n    */\n-  public String toString ()\n+  public static String toString(double d)\n   {\n-    return toString (value);\n+    return toString(d, false);\n   }\n \n   /**\n-   * If the <code>Object</code> is not <code>null</code>, is an\n-   * <code>instanceof</code> <code>Double</code>, and represents\n-   * the same primitive <code>double</code> value return \n-   * <code>true</code>.  Otherwise <code>false</code> is returned.\n-   * <p>\n-   * Note that there are two differences between <code>==</code> and\n-   * <code>equals()</code>. <code>0.0d == -0.0d</code> returns <code>true</code>\n-   * but <code>new Double(0.0d).equals(new Double(-0.0d))</code> returns\n-   * <code>false</code>. And <code>Double.NaN == Double.NaN</code> returns\n-   * <code>false</code>, but\n-   * <code>new Double(Double.NaN).equals(new Double(Double.NaN))</code> returns\n-   * <code>true</code>.\n+   * Create a new <code>Double</code> object using the <code>String</code>.\n    *\n-   * @param obj the object to compare to\n-   * @return whether the objects are semantically equal.\n+   * @param s the <code>String</code> to convert\n+   * @return the new <code>Double</code>\n+   * @throws NumberFormatException if <code>s</code> cannot be parsed as a\n+   *         <code>double</code>\n+   * @throws NullPointerException if <code>s</code> is null.\n+   * @see #parseDouble(String)\n    */\n-  public boolean equals (Object obj)\n+  public static Double valueOf(String s)\n   {\n-    if (!(obj instanceof Double))\n-      return false;\n-\n-    double d = ((Double) obj).value;\n-\n-    // GCJ LOCAL: this implementation is probably faster than\n-    // Classpath's, especially once we inline doubleToLongBits.\n-    return doubleToLongBits (value) == doubleToLongBits (d);\n-    // END GCJ LOCAL\n+    // XXX just call new Double(parseDouble(s));\n+    if (s == null)\n+      throw new NullPointerException();\n+    return new Double(s);\n   }\n \n   /**\n-   * The hashcode is the value of the expression: <br>\n-   * <br>\n-   * <code>(int)(v^(v>>>32))</code><br>\n-   * <br>\n-   * where v is defined by: <br>\n-   * <code>long v = Double.doubleToLongBits(this.longValue());</code><br>\n+   * Parse the specified <code>String</code> as a <code>double</code>. The\n+   * extended BNF grammar is as follows:<br>\n+   * <pre>\n+   * <em>DecodableString</em>:\n+   *      ( [ <code>-</code> | <code>+</code> ] <code>NaN</code> )\n+   *    | ( [ <code>-</code> | <code>+</code> ] <code>Infinity</code> )\n+   *    | ( [ <code>-</code> | <code>+</code> ] <em>FloatingPoint</em>\n+   *              [ <code>f</code> | <code>F</code> | <code>d</code>\n+   *                | <code>D</code>] )\n+   * <em>FloatingPoint</em>:\n+   *      ( { <em>Digit</em> }+ [ <code>.</code> { <em>Digit</em> } ]\n+   *              [ <em>Exponent</em> ] )\n+   *    | ( <code>.</code> { <em>Digit</em> }+ [ <em>Exponent</em> ] )\n+   * <em>Exponent</em>:\n+   *      ( ( <code>e</code> | <code>E</code> )\n+   *              [ <code>-</code> | <code>+</code> ] { <em>Digit</em> }+ )\n+   * <em>Digit</em>: <em><code>'0'</code> through <code>'9'</code></em>\n+   * </pre>\n+   *\n+   * <p>NaN and infinity are special cases, to allow parsing of the output\n+   * of toString.  Otherwise, the result is determined by calculating\n+   * <em>n * 10<sup>exponent</sup></em> to infinite precision, then rounding\n+   * to the nearest double. Remember that many numbers cannot be precisely\n+   * represented in floating point. In case of overflow, infinity is used,\n+   * and in case of underflow, signed zero is used. Unlike Integer.parseInt,\n+   * this does not accept Unicode digits outside the ASCII range.\n+   *\n+   * <p>If an unexpected character is found in the <code>String</code>, a\n+   * <code>NumberFormatException</code> will be thrown.  Leading and trailing\n+   * 'whitespace' is ignored via <code>String.trim()</code>, but spaces\n+   * internal to the actual number are not allowed.\n+   *\n+   * <p>To parse numbers according to another format, consider using\n+   * {@link java.text.NumberFormat}.\n+   *\n+   * @XXX specify where/how we are not in accord with the spec.\n+   *\n+   * @param str the <code>String</code> to convert\n+   * @return the <code>double</code> value of <code>s</code>\n+   * @throws NumberFormatException if <code>s</code> cannot be parsed as a\n+   *         <code>double</code>\n+   * @throws NullPointerException if <code>s</code> is null\n+   * @see #MIN_VALUE\n+   * @see #MAX_VALUE\n+   * @see #POSITIVE_INFINITY\n+   * @see #NEGATIVE_INFINITY\n+   * @since 1.2\n    */\n-  public int hashCode ()\n-  {\n-    long v = doubleToLongBits (value);\n-    return (int) (v ^ (v >>> 32));\n-  }\n+  public static native double parseDouble(String s);\n \n   /**\n-   * Return the value of this <code>Double</code> when cast to an \n-   * <code>int</code>.\n+   * Return <code>true</code> if the <code>double</code> has the same\n+   * value as <code>NaN</code>, otherwise return <code>false</code>.\n+   *\n+   * @param v the <code>double</code> to compare\n+   * @return whether the argument is <code>NaN</code>.\n    */\n-  public int intValue ()\n+  public static boolean isNaN(double v)\n   {\n-    return (int) value;\n+    // This works since NaN != NaN is the only reflexive inequality\n+    // comparison which returns true.\n+    return v != v;\n   }\n \n   /**\n-   * Return the value of this <code>Double</code> when cast to a\n-   * <code>long</code>.\n+   * Return <code>true</code> if the <code>double</code> has a value\n+   * equal to either <code>NEGATIVE_INFINITY</code> or\n+   * <code>POSITIVE_INFINITY</code>, otherwise return <code>false</code>.\n+   *\n+   * @param v the <code>double</code> to compare\n+   * @return whether the argument is (-/+) infinity.\n    */\n-  public long longValue ()\n+  public static boolean isInfinite(double v)\n   {\n-    return (long) value;\n+    return v == POSITIVE_INFINITY || v == NEGATIVE_INFINITY;\n   }\n \n   /**\n-   * Return the value of this <code>Double</code> when cast to a\n-   * <code>float</code>.\n+   * Return <code>true</code> if the value of this <code>Double</code>\n+   * is the same as <code>NaN</code>, otherwise return <code>false</code>.\n+   *\n+   * @return whether this <code>Double</code> is <code>NaN</code>\n    */\n-  public float floatValue ()\n+  public boolean isNaN()\n   {\n-    return (float) value;\n+    return isNaN(value);\n   }\n \n   /**\n-   * Return the primitive <code>double</code> value represented by this\n-   * <code>Double</code>.\n+   * Return <code>true</code> if the value of this <code>Double</code>\n+   * is the same as <code>NEGATIVE_INFINITY</code> or\n+   * <code>POSITIVE_INFINITY</code>, otherwise return <code>false</code>.\n+   *\n+   * @return whether this <code>Double</code> is (-/+) infinity\n    */\n-  public double doubleValue ()\n+  public boolean isInfinite()\n   {\n-    return value;\n+    return isInfinite(value);\n   }\n \n   /**\n-   * Return the result of calling <code>new Double(java.lang.String)</code>.\n-   *\n-   * @param s the <code>String</code> to convert to a <code>Double</code>.\n-   * @return a new <code>Double</code> representing the <code>String</code>'s\n-   *         numeric value.\n+   * Convert the <code>double</code> value of this <code>Double</code>\n+   * to a <code>String</code>.  This method calls\n+   * <code>Double.toString(double)</code> to do its dirty work.\n    *\n-   * @exception NullPointerException thrown if <code>String</code> is \n-   * <code>null</code>.\n-   * @exception NumberFormatException thrown if <code>String</code> cannot\n-   * be parsed as a <code>double</code>.\n-   * @see #Double(java.lang.String)\n-   * @see #parseDouble(java.lang.String)\n+   * @return the <code>String</code> representation\n+   * @see #toString(double)\n    */\n-  public static Double valueOf (String s) throws NumberFormatException\n+  public String toString()\n   {\n-    return new Double (s);\n+    return toString(value);\n   }\n \n   /**\n-   * Return <code>true</code> if the value of this <code>Double</code>\n-   * is the same as <code>NaN</code>, otherwise return <code>false</code>.\n-   * @return whether this <code>Double</code> is <code>NaN</code>.\n+   * Return the value of this <code>Double</code> as a <code>byte</code>.\n+   *\n+   * @return the byte value\n+   * @since 1.1\n    */\n-  public boolean isNaN ()\n+  public byte byteValue()\n   {\n-    return isNaN (value);\n+    return (byte) value;\n   }\n \n   /**\n-   * Return <code>true</code> if the <code>double</code> has the same\n-   * value as <code>NaN</code>, otherwise return <code>false</code>.\n+   * Return the value of this <code>Double</code> as a <code>short</code>.\n    *\n-   * @param v the <code>double</code> to compare\n-   * @return whether the argument is <code>NaN</code>.\n+   * @return the short value\n+   * @since 1.1\n    */\n-  public static boolean isNaN (double v)\n+  public short shortValue()\n   {\n-    // This works since NaN != NaN is the only reflexive inequality\n-    // comparison which returns true.\n-    return v != v;\n+    return (short) value;\n   }\n \n   /**\n-   * Return <code>true</code> if the value of this <code>Double</code>\n-   * is the same as <code>NEGATIVE_INFINITY</code> or \n-   * <code>POSITIVE_INFINITY</code>, otherwise return <code>false</code>.\n+   * Return the value of this <code>Double</code> as an <code>int</code>.\n    *\n-   * @return whether this <code>Double</code> is (-/+) infinity.\n+   * @return the int value\n    */\n-  public boolean isInfinite ()\n+  public int intValue()\n   {\n-    return isInfinite (value);\n+    return (int) value;\n   }\n \n   /**\n-   * Return <code>true</code> if the <code>double</code> has a value \n-   * equal to either <code>NEGATIVE_INFINITY</code> or \n-   * <code>POSITIVE_INFINITY</code>, otherwise return <code>false</code>.\n+   * Return the value of this <code>Double</code> as a <code>long</code>.\n    *\n-   * @param v the <code>double</code> to compare\n-   * @return whether the argument is (-/+) infinity.\n+   * @return the long value\n    */\n-  public static boolean isInfinite (double v)\n+  public long longValue()\n   {\n-    return (v == POSITIVE_INFINITY || v == NEGATIVE_INFINITY);\n+    return (long) value;\n   }\n \n   /**\n-   * Returns 0 if the <code>double</code> value of the argument is \n-   * equal to the value of this <code>Double</code>.  Returns a number\n-   * less than zero if the value of this <code>Double</code> is less \n-   * than the <code>double</code> value of the argument, and returns a \n-   * number greater than zero if the value of this <code>Double</code> \n-   * is greater than the <code>double</code> value of the argument.\n-   * <br>\n-   * <code>Double.NaN</code> is greater than any number other than itself, \n-   * even <code>Double.POSITIVE_INFINITY</code>.\n-   * <br>\n-   * <code>0.0d</code> is greater than <code>-0.0d</code>.\n-   *\n-   * @param d the Double to compare to.\n-   * @return  0 if the <code>Double</code>s are the same, &lt; 0 if this\n-   *          <code>Double</code> is less than the <code>Double</code> in\n-   *          in question, or &gt; 0 if it is greater.\n-   * @since 1.2\n+   * Return the value of this <code>Double</code> as a <code>float</code>.\n+   *\n+   * @return the float value\n    */\n-  public int compareTo (Double d)\n+  public float floatValue()\n   {\n-    return compare (value, d.value);\n+    return (float) value;\n   }\n \n   /**\n-   * Returns 0 if the first argument is equal to the second argument.\n-   * Returns a number less than zero if the first argument is less than the\n-   * second argument, and returns a number greater than zero if the first\n-   * argument is greater than the second argument.\n-   * <br>\n-   * <code>Double.NaN</code> is greater than any number other than itself, \n-   * even <code>Double.POSITIVE_INFINITY</code>.\n-   * <br>\n-   * <code>0.0d</code> is greater than <code>-0.0d</code>.\n-   *\n-   * @param x the first double to compare.\n-   * @param y the second double to compare.\n-   * @return  0 if the arguments are the same, &lt; 0 if the\n-   *          first argument is less than the second argument in\n-   *          in question, or &gt; 0 if it is greater.\n-   * @since 1.4\n+   * Return the value of this <code>Double</code>.\n+   *\n+   * @return the double value\n    */\n-  public static int compare (double x, double y)\n+  public double doubleValue()\n   {\n-    if (isNaN (x))\n-      return isNaN (y) ? 0 : 1;\n-    if (isNaN (y))\n-      return -1;\n-    // recall that 0.0 == -0.0, so we convert to infinites and try again\n-    if (x == 0 && y == 0)\n-      return (int) (1 / x - 1 / y);\n-    if (x == y)\n-      return 0;\n-\n-    return x > y ? 1 : -1;\n+    return value;\n   }\n \n   /**\n-   * Compares the specified <code>Object</code> to this <code>Double</code>\n-   * if and only if the <code>Object</code> is an instanceof \n-   * <code>Double</code>.\n+   * Return a hashcode representing this Object. <code>Double</code>'s hash\n+   * code is calculated by:<br>\n+   * <code>long v = Double.doubleToLongBits(doubleValue());<br>\n+   *    int hash = (int)(v^(v&gt;&gt;32))</code>.\n    *\n-   * @param o the Object to compare to.\n-   * @return  0 if the <code>Double</code>s are the same, &lt; 0 if this\n-   *          <code>Double</code> is less than the <code>Double</code> in\n-   *          in question, or &gt; 0 if it is greater.\n-   * @throws ClassCastException if the argument is not a <code>Double</code>\n+   * @return this Object's hash code\n+   * @see #doubleToLongBits(double)\n    */\n-  public int compareTo (Object o)\n+  public int hashCode()\n   {\n-    return compareTo ((Double) o);\n+    long v = doubleToLongBits(value);\n+    return (int) (v ^ (v >>> 32));\n   }\n \n   /**\n-   * Convert the <code>double</code> to a <code>String</code>.\n-   * <P>\n-   * \n-   * Floating-point string representation is fairly complex: here is a\n-   * rundown of the possible values.  \"<CODE>[-]</CODE>\" indicates that a\n-   * negative sign will be printed if the value (or exponent) is negative.\n-   * \"<CODE>&lt;number&gt;</CODE>\" means a string of digits (0-9).\n-   * \"<CODE>&lt;digit&gt;</CODE>\" means a single digit (0-9).\n-   * <P>\n-   *\n-   * <TABLE BORDER=1>\n-   * <TR><TH>Value of Float</TH><TH>String Representation</TH></TR>\n-   * <TR>\n-   *     <TD>[+-] 0</TD>\n-   *     <TD>[<CODE>-</CODE>]<CODE>0.0</CODE></TD>\n-   * </TR>\n-   * <TR>\n-   *     <TD>Between [+-] 10<SUP>-3</SUP> and 10<SUP>7</SUP></TD>\n-   *     <TD><CODE>[-]number.number</CODE></TD>\n-   * </TR>\n-   * <TR>\n-   *     <TD>Other numeric value</TD>\n-   *     <TD><CODE>[-]&lt;digit&gt;.&lt;number&gt;E[-]&lt;number&gt;</CODE></TD>\n-   * </TR>\n-   * <TR>\n-   *     <TD>[+-] infinity</TD>\n-   *     <TD><CODE>[-]Infinity</CODE></TD>\n-   * </TR>\n-   * <TR>\n-   *     <TD>NaN</TD>\n-   *     <TD><CODE>NaN</CODE></TD>\n-   * </TR>\n-   * </TABLE>\n-   *\n-   * Yes, negative zero <EM>is</EM> a possible value.  Note that there is\n-   * <EM>always</EM> a <CODE>.</CODE> and at least one digit printed after\n-   * it: even if the number is 3, it will be printed as <CODE>3.0</CODE>.\n-   * After the \".\", all digits will be printed except trailing zeros.  No\n-   * truncation or rounding is done by this function.\n-   *\n+   * Returns <code>true</code> if <code>obj</code> is an instance of\n+   * <code>Double</code> and represents the same double value. Unlike comparing\n+   * two doubles with <code>==</code>, this treats two instances of\n+   * <code>Double.NaN</code> as equal, but treats <code>0.0</code> and\n+   * <code>-0.0</code> as unequal.\n    *\n-   * @XXX specify where we are not in accord with the spec.\n+   * <p>Note that <code>d1.equals(d2)<code> is identical to\n+   * <code>doubleToLongBits(d1.doubleValue()) ==\n+   *    doubleToLongBits(d2.doubleValue())<code>.\n    *\n-   * @param d the <code>double</code> to convert\n-   * @return the <code>String</code> representing the <code>double</code>.\n+   * @param obj the object to compare\n+   * @return whether the objects are semantically equal\n    */\n-  public static String toString (double d)\n+  public boolean equals(Object obj)\n   {\n-    return toString (d, false);\n-  }\n+    if (! (obj instanceof Double))\n+      return false;\n \n-  static native String toString (double d, boolean isFloat);\n+    double d = ((Double) obj).value;\n+\n+    // Avoid call to native method. However, some implementations, like gcj,\n+    // are better off using floatToIntBits(value) == floatToIntBits(f).\n+    // Check common case first, then check NaN and 0.\n+    if (value == d)\n+      return (value != 0) || (1 / value == 1 / d);\n+    return isNaN(value) && isNaN(d);\n+  }\n \n   /**\n-   * Return the long bits of the specified <code>double</code>.\n-   * The result of this function can be used as the argument to\n-   * <code>Double.longBitsToDouble(long)</code> to obtain the\n-   * original <code>double</code> value.\n+   * Convert the double to the IEEE 754 floating-point \"double format\" bit\n+   * layout. Bit 63 (the most significant) is the sign bit, bits 62-52\n+   * (masked by 0x7ff0000000000000L) represent the exponent, and bits 51-0\n+   * (masked by 0x000fffffffffffffL) are the mantissa. This function\n+   * collapses all versions of NaN to 0x7ff8000000000000L. The result of this\n+   * function can be used as the argument to\n+   * <code>Double.longBitsToDouble(long)</code> to obtain the original\n+   * <code>double</code> value.\n    *\n    * @param value the <code>double</code> to convert\n-   * @return the bits of the <code>double</code>.\n+   * @return the bits of the <code>double</code>\n+   * @see #longBitsToDouble(long)\n    */\n-  public static native long doubleToLongBits (double value);\n+  public static native long doubleToLongBits(double value);\n \n   /**\n-   * Return the long bits of the specified <code>double</code>.\n-   * The result of this function can be used as the argument to\n-   * <code>Double.longBitsToDouble(long)</code> to obtain the\n-   * original <code>double</code> value.  This method differs from \n-   * <code>doubleToLongBits</code> in that it does not collapse\n-   * NaN values.\n+   * Convert the double to the IEEE 754 floating-point \"double format\" bit\n+   * layout. Bit 63 (the most significant) is the sign bit, bits 62-52\n+   * (masked by 0x7ff0000000000000L) represent the exponent, and bits 51-0\n+   * (masked by 0x000fffffffffffffL) are the mantissa. This function\n+   * leaves NaN alone, rather than collapsing to a canonical value. The\n+   * result of this function can be used as the argument to\n+   * <code>Double.longBitsToDouble(long)</code> to obtain the original\n+   * <code>double</code> value.\n    *\n    * @param value the <code>double</code> to convert\n-   * @return the bits of the <code>double</code>.\n-   */\n-  public static native long doubleToRawLongBits (double value);\n-\n-  /**\n-   * Return the <code>double</code> represented by the long\n-   * bits specified.\n-   *\n-   * @param bits the long bits representing a <code>double</code>\n-   * @return the <code>double</code> represented by the bits.\n-   */\n-  public static native double longBitsToDouble (long bits);\n-\n-  /**\n-   * Parse the specified <code>String</code> as a <code>double</code>.\n-   *\n-   * The number is really read as <em>n * 10<sup>exponent</sup></em>.  The\n-   * first number is <em>n</em>, and if there is an \"<code>E</code>\"\n-   * (\"<code>e</code>\" is also acceptable), then the integer after that is\n-   * the exponent.\n-   * <P>\n-   * Here are the possible forms the number can take:\n-   * <BR>\n-   * <TABLE BORDER=1>\n-   *     <TR><TH>Form</TH><TH>Examples</TH></TR>\n-   *     <TR><TD><CODE>[+-]&lt;number&gt;[.]</CODE></TD><TD>345., -10, 12</TD></TR>\n-   *     <TR><TD><CODE>[+-]&lt;number&gt;.&lt;number&gt;</CODE></TD><TD>40.2, 80.00, -12.30</TD></TR>\n-   *     <TR><TD><CODE>[+-]&lt;number&gt;[.]E[+-]&lt;number&gt;</CODE></TD><TD>80E12, -12e+7, 4.E-123</TD></TR>\n-   *     <TR><TD><CODE>[+-]&lt;number&gt;.&lt;number&gt;E[+-]&lt;number&gt;</CODE></TD><TD>6.02e-22, -40.2E+6, 12.3e9</TD></TR>\n-   * </TABLE>\n-   *\n-   * \"<code>[+-]</code>\" means either a plus or minus sign may go there, or\n-   * neither, in which case + is assumed.\n-   * <BR>\n-   * \"<code>[.]</code>\" means a dot may be placed here, but is optional.\n-   * <BR>\n-   * \"<code>&lt;number&gt;</code>\" means a string of digits (0-9), basically\n-   * an integer.  \"<code>&lt;number&gt;.&lt;number&gt;</code>\" is basically\n-   * a real number, a floating-point value.\n-   * <P>\n-   *\n-   * Remember that a <code>double</code> has a limited range.  If the\n-   * number you specify is greater than <code>Double.MAX_VALUE</code> or less\n-   * than <code>-Double.MAX_VALUE</code>, it will be set at\n-   * <code>Double.POSITIVE_INFINITY</code> or\n-   * <code>Double.NEGATIVE_INFINITY</code>, respectively.\n-   * <P>\n-   * Note also that <code>double</code> does not have perfect precision.  Many\n-   * numbers cannot be precisely represented.  The number you specify\n-   * will be rounded to the nearest representable value.\n-   * <code>Double.MIN_VALUE</code> is the margin of error for\n-   * <code>double</code> values.\n-   * <P>\n-   * If an unexpected character is found in the <code>String</code>, a\n-   * <code>NumberFormatException</code> will be thrown.  Spaces are not\n-   * allowed, and will cause the same exception.\n+   * @return the bits of the <code>double</code>\n+   * @see #longBitsToDouble(long)\n+   */\n+  public static native long doubleToRawLongBits(double value);\n+\n+  /**\n+   * Convert the argument in IEEE 754 floating-point \"double format\" bit\n+   * layout to the corresponding float. Bit 63 (the most significant) is the\n+   * sign bit, bits 62-52 (masked by 0x7ff0000000000000L) represent the\n+   * exponent, and bits 51-0 (masked by 0x000fffffffffffffL) are the mantissa.\n+   * This function leaves NaN alone, so that you can recover the bit pattern\n+   * with <code>Double.doubleToRawLongBits(double)</code>.\n    *\n-   * @XXX specify where/how we are not in accord with the spec.\n+   * @param bits the bits to convert\n+   * @return the <code>double</code> represented by the bits\n+   * @see #doubleToLongBits(double)\n+   * @see #doubleToRawLongBits(double)\n+   */\n+  public static native double longBitsToDouble(long bits);\n+\n+  /**\n+   * Compare two Doubles numerically by comparing their <code>double</code>\n+   * values. The result is positive if the first is greater, negative if the\n+   * second is greater, and 0 if the two are equal. However, this special\n+   * cases NaN and signed zero as follows: NaN is considered greater than\n+   * all other doubles, including <code>POSITIVE_INFINITY</code>, and positive\n+   * zero is considered greater than negative zero.\n    *\n-   * @param str the <code>String</code> to convert\n-   * @return the value of the <code>String</code> as a <code>double</code>.\n-   * @exception NumberFormatException when the string cannot be parsed to a\n-   *            <code>double</code>.\n-   * @exception NullPointerException when the string is null.\n-   * @see #MIN_VALUE\n-   * @see #MAX_VALUE\n-   * @see #POSITIVE_INFINITY\n-   * @see #NEGATIVE_INFINITY\n+   * @param d the Double to compare\n+   * @return the comparison\n+   * @since 1.2\n+   */\n+  public int compareTo(Double d)\n+  {\n+    return compare(value, d.value);\n+  }\n+\n+  /**\n+   * Behaves like <code>compareTo(Double)</code> unless the Object\n+   * is not an <code>Double</code>.\n+   *\n+   * @param o the object to compare\n+   * @return the comparison\n+   * @throws ClassCastException if the argument is not a <code>Double</code>\n+   * @see #compareTo(Double)\n+   * @see Comparable\n    * @since 1.2\n    */\n-  public static native double parseDouble (String s)\n-    throws NumberFormatException;\n+  public int compareTo(Object o)\n+  {\n+    return compare(value, ((Double) o).value);\n+  }\n+\n+  /**\n+   * Behaves like <code>new Double(x).compareTo(new Double(y))</code>; in\n+   * other words this compares two doubles, special casing NaN and zero,\n+   * without the overhead of objects.\n+   *\n+   * @param x the first double to compare\n+   * @param y the second double to compare\n+   * @return the comparison\n+   * @since 1.4\n+   */\n+  public static int compare(double x, double y)\n+  {\n+    if (isNaN(x))\n+      return isNaN(y) ? 0 : 1;\n+    if (isNaN(y))\n+      return -1;\n+    // recall that 0.0 == -0.0, so we convert to infinites and try again\n+    if (x == 0 && y == 0)\n+      return (int) (1 / x - 1 / y);\n+    if (x == y)\n+      return 0;\n+\n+    return x > y ? 1 : -1;\n+  }\n+\n+  /**\n+   * Helper method to convert to string.\n+   *\n+   * @param d the double to convert\n+   * @param isFloat true if the conversion is requested by Float (results in\n+   *        fewer digits)\n+   */\n+  // Package visible for use by Float.\n+  static native String toString(double d, boolean isFloat);\n \n   /**\n-   * Initialize JNI cache.  This method is called only by the \n+   * Initialize JNI cache.  This method is called only by the\n    * static initializer when using JNI.\n    */\n-  private static native void initIDs ();\n+  private static native void initIDs();\n }"}, {"sha": "930b8415076d91b4bcf35eaea6fc3f7094f3e8dd", "filename": "libjava/java/lang/Float.java", "status": "modified", "additions": 289, "deletions": 287, "changes": 576, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f7aeea7ac79573748c5f2632059aa6b50d74e2/libjava%2Fjava%2Flang%2FFloat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f7aeea7ac79573748c5f2632059aa6b50d74e2/libjava%2Fjava%2Flang%2FFloat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FFloat.java?ref=93f7aeea7ac79573748c5f2632059aa6b50d74e2", "patch": "@@ -1,4 +1,4 @@\n-/* java.lang.Float\n+/* Float.java -- object wrapper for float\n    Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -40,12 +40,6 @@\n \n import gnu.classpath.Configuration;\n \n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete and correct.\n- */\n-\n /**\n  * Instances of class <code>Float</code> represent primitive\n  * <code>float</code> values.\n@@ -55,10 +49,17 @@\n  *\n  * @author Paul Fisher\n  * @author Andrew Haley <aph@cygnus.com>\n- * @since JDK 1.0\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @since 1.0\n+ * @status updated to 1.4\n  */\n public final class Float extends Number implements Comparable\n {\n+  /**\n+   * Compatible with JDK 1.0+.\n+   */\n+  private static final long serialVersionUID = -2671257302660747028L;\n+\n   /**\n    * The maximum positive value a <code>double</code> may represent\n    * is 3.4028235e+38f.\n@@ -74,46 +75,50 @@ public final class Float extends Number implements Comparable\n   /**\n    * The value of a float representation -1.0/0.0, negative infinity.\n    */\n-  public static final float NEGATIVE_INFINITY = -1.0f/0.0f;\n+  public static final float NEGATIVE_INFINITY = -1.0f / 0.0f;\n \n   /**\n    * The value of a float representation 1.0/0.0, positive infinity.\n    */\n-  public static final float POSITIVE_INFINITY = 1.0f/0.0f;\n+  public static final float POSITIVE_INFINITY = 1.0f / 0.0f;\n \n   /**\n    * All IEEE 754 values of NaN have the same value in Java.\n    */\n-  public static final float NaN = 0.0f/0.0f;\n+  public static final float NaN = 0.0f / 0.0f;\n \n   /**\n-   * The primitive type <code>float</code> is represented by this \n+   * The primitive type <code>float</code> is represented by this\n    * <code>Class</code> object.\n+   * @since 1.1\n    */\n   public static final Class TYPE = VMClassLoader.getPrimitiveClass('F');\n \n   /**\n    * The immutable value of this Float.\n+   *\n+   * @serial the wrapped float\n    */\n   private final float value;\n \n-  private static final long serialVersionUID = -2671257302660747028L;\n-\n+  /**\n+   * Load native routines necessary for this class.\n+   */\n   static\n   {\n     if (Configuration.INIT_LOAD_LIBRARY)\n       {\n-\tSystem.loadLibrary (\"javalang\");\n+        System.loadLibrary(\"javalang\");\n       }\n   }\n \n   /**\n-   * Create a <code>float</code> from the primitive <code>Float</code>\n+   * Create a <code>Float</code> from the primitive <code>float</code>\n    * specified.\n    *\n-   * @param value the <code>Float</code> argument\n+   * @param value the <code>float</code> argument\n    */\n-  public Float (float value)\n+  public Float(float value)\n   {\n     this.value = value;\n   }\n@@ -124,379 +129,395 @@ public Float (float value)\n    *\n    * @param value the <code>double</code> argument\n    */\n-  public Float (double value)\n+  public Float(double value)\n   {\n-    this.value = (float)value;\n+    this.value = (float) value;\n   }\n \n   /**\n    * Create a <code>Float</code> from the specified <code>String</code>.\n-   *\n    * This method calls <code>Float.parseFloat()</code>.\n    *\n-   * @exception NumberFormatException when the <code>String</code> cannot\n-   *            be parsed into a <code>Float</code>.\n    * @param s the <code>String</code> to convert\n-   * @see #parseFloat(java.lang.String)\n+   * @throws NumberFormatException if <code>s</code> cannot be parsed as a\n+   *         <code>float</code>\n+   * @throws NullPointerException if <code>s</code> is null\n+   * @see #parseFloat(String)\n+   */\n+  public Float(String s)\n+  {\n+    value = parseFloat(s);\n+  }\n+\n+  /**\n+   * Convert the <code>float</code> to a <code>String</code>.\n+   * Floating-point string representation is fairly complex: here is a\n+   * rundown of the possible values.  \"<code>[-]</code>\" indicates that a\n+   * negative sign will be printed if the value (or exponent) is negative.\n+   * \"<code>&lt;number&gt;</code>\" means a string of digits ('0' to '9').\n+   * \"<code>&lt;digit&gt;</code>\" means a single digit ('0' to '9').<br>\n+   *\n+   * <table border=1>\n+   * <tr><th>Value of Float</th><th>String Representation</th></tr>\n+   * <tr><td>[+-] 0</td> <td><code>[-]0.0</code></td></tr>\n+   * <tr><td>Between [+-] 10<sup>-3</sup> and 10<sup>7</sup>, exclusive</td>\n+   *     <td><code>[-]number.number</code></td></tr>\n+   * <tr><td>Other numeric value</td>\n+   *     <td><code>[-]&lt;digit&gt;.&lt;number&gt;\n+   *          E[-]&lt;number&gt;</code></td></tr>\n+   * <tr><td>[+-] infinity</td> <td><code>[-]Infinity</code></td></tr>\n+   * <tr><td>NaN</td> <td><code>NaN</code></td></tr>\n+   * </table>\n+   *\n+   * Yes, negative zero <em>is</em> a possible value.  Note that there is\n+   * <em>always</em> a <code>.</code> and at least one digit printed after\n+   * it: even if the number is 3, it will be printed as <code>3.0</code>.\n+   * After the \".\", all digits will be printed except trailing zeros. The\n+   * result is rounded to the shortest decimal number which will parse back\n+   * to the same float.\n+   *\n+   * <p>To create other output formats, use {@link java.text.NumberFormat}.\n+   *\n+   * @XXX specify where we are not in accord with the spec.\n+   *\n+   * @param f the <code>float</code> to convert\n+   * @return the <code>String</code> representing the <code>float</code>\n+   */\n+  public static String toString(float f)\n+  {\n+    return Double.toString(f, true);\n+  }\n+\n+  /**\n+   * Creates a new <code>Float</code> object using the <code>String</code>.\n+   *\n+   * @param s the <code>String</code> to convert\n+   * @return the new <code>Float</code>\n+   * @throws NumberFormatException if <code>s</code> cannot be parsed as a\n+   *         <code>float</code>\n+   * @throws NullPointerException if <code>s</code> is null\n+   * @see #parseFloat(String)\n    */\n-  public Float (String s) throws NumberFormatException\n+  public static Float valueOf(String s)\n   {\n-    this.value = parseFloat (s);\n+    return new Float(parseFloat(s));\n   }\n \n   /**\n-   * Parse the specified <code>String</code> as a <code>float</code>.\n-   *\n-   * The number is really read as <em>n * 10<sup>exponent</sup></em>.  The\n-   * first number is <em>n</em>, and if there is an \"<code>E</code>\"\n-   * (\"<code>e</code>\" is also acceptable), then the integer after that is\n-   * the exponent.\n-   * <P>\n-   * Here are the possible forms the number can take:\n-   * <BR>\n-   * <TABLE BORDER=1>\n-   *     <TR><TH>Form</TH><TH>Examples</TH></TR>\n-   *     <TR><TD><CODE>[+-]&lt;number&gt;[.]</CODE></TD><TD>345., -10, 12</TD></TR>\n-   *     <TR><TD><CODE>[+-]&lt;number&gt;.&lt;number&gt;</CODE></TD><TD>40.2, 80.00, -12.30</TD></TR>\n-   *     <TR><TD><CODE>[+-]&lt;number&gt;[.]E[+-]&lt;number&gt;</CODE></TD><TD>80E12, -12e+7, 4.E-123</TD></TR>\n-   *     <TR><TD><CODE>[+-]&lt;number&gt;.&lt;number&gt;E[+-]&lt;number&gt;</CODE></TD><TD>6.02e-22, -40.2E+6, 12.3e9</TD></TR>\n-   * </TABLE>\n-   *\n-   * \"<code>[+-]</code>\" means either a plus or minus sign may go there, or\n-   * neither, in which case + is assumed.\n-   * <BR>\n-   * \"<code>[.]</code>\" means a dot may be placed here, but is optional.\n-   * <BR>\n-   * \"<code>&lt;number&gt;</code>\" means a string of digits (0-9), basically\n-   * an integer.  \"<code>&lt;number&gt;.&lt;number&gt;</code>\" is basically\n-   * a real number, a floating-point value.\n-   * <P>\n-   * Remember that a <code>float</code> has a limited range.  If the\n-   * number you specify is greater than <code>Float.MAX_VALUE</code> or less\n-   * than <code>-Float.MAX_VALUE</code>, it will be set at\n-   * <code>Float.POSITIVE_INFINITY</code> or\n-   * <code>Float.NEGATIVE_INFINITY</code>, respectively.\n-   * <P>\n-   *\n-   * Note also that <code>float</code> does not have perfect precision.  Many\n-   * numbers cannot be precisely represented.  The number you specify\n-   * will be rounded to the nearest representable value.\n-   * <code>Float.MIN_VALUE</code> is the margin of error for <code>float</code>\n-   * values.\n-   * <P>\n-   * If an unexpected character is found in the <code>String</code>, a\n-   * <code>NumberFormatException</code> will be thrown.  Spaces are not\n-   * allowed and will cause this exception to be thrown.\n+   * Parse the specified <code>String</code> as a <code>float</code>. The\n+   * extended BNF grammar is as follows:<br>\n+   * <pre>\n+   * <em>DecodableString</em>:\n+   *      ( [ <code>-</code> | <code>+</code> ] <code>NaN</code> )\n+   *    | ( [ <code>-</code> | <code>+</code> ] <code>Infinity</code> )\n+   *    | ( [ <code>-</code> | <code>+</code> ] <em>FloatingPoint</em>\n+   *              [ <code>f</code> | <code>F</code> | <code>d</code>\n+   *                | <code>D</code>] )\n+   * <em>FloatingPoint</em>:\n+   *      ( { <em>Digit</em> }+ [ <code>.</code> { <em>Digit</em> } ]\n+   *              [ <em>Exponent</em> ] )\n+   *    | ( <code>.</code> { <em>Digit</em> }+ [ <em>Exponent</em> ] )\n+   * <em>Exponent</em>:\n+   *      ( ( <code>e</code> | <code>E</code> )\n+   *              [ <code>-</code> | <code>+</code> ] { <em>Digit</em> }+ )\n+   * <em>Digit</em>: <em><code>'0'</code> through <code>'9'</code></em>\n+   * </pre>\n+   *\n+   * <p>NaN and infinity are special cases, to allow parsing of the output\n+   * of toString.  Otherwise, the result is determined by calculating\n+   * <em>n * 10<sup>exponent</sup></em> to infinite precision, then rounding\n+   * to the nearest float. Remember that many numbers cannot be precisely\n+   * represented in floating point. In case of overflow, infinity is used,\n+   * and in case of underflow, signed zero is used. Unlike Integer.parseInt,\n+   * this does not accept Unicode digits outside the ASCII range.\n+   *\n+   * <p>If an unexpected character is found in the <code>String</code>, a\n+   * <code>NumberFormatException</code> will be thrown.  Leading and trailing\n+   * 'whitespace' is ignored via <code>String.trim()</code>, but spaces\n+   * internal to the actual number are not allowed.\n+   *\n+   * <p>To parse numbers according to another format, consider using\n+   * {@link java.text.NumberFormat}.\n    *\n    * @XXX specify where/how we are not in accord with the spec.\n    *\n    * @param str the <code>String</code> to convert\n-   * @return the value of the <code>String</code> as a <code>float</code>.\n-   * @exception NumberFormatException when the string cannot be parsed to a\n-   *            <code>float</code>.\n-   * @since JDK 1.2\n+   * @return the <code>float</code> value of <code>s</code>\n+   * @throws NumberFormatException if <code>s</code> cannot be parsed as a\n+   *         <code>float</code>\n+   * @throws NullPointerException if <code>s</code> is null\n    * @see #MIN_VALUE\n    * @see #MAX_VALUE\n    * @see #POSITIVE_INFINITY\n    * @see #NEGATIVE_INFINITY\n+   * @since 1.2\n    */\n-  public static float parseFloat (String s) throws NumberFormatException\n+  public static float parseFloat(String s)\n   {\n-    // The spec says that parseFloat() should work like\n-    // Double.valueOf().  This is equivalent, in our implementation,\n-    // but more efficient.\n-    return (float) Double.parseDouble (s);\n+    // XXX Rounding parseDouble() causes some errors greater than 1 ulp from\n+    // the infinitely precise decimal.\n+    return (float) Double.parseDouble(s);\n   }\n \n   /**\n-   * Convert the <code>float</code> value of this <code>Float</code>\n-   * to a <code>String</code>.  This method calls\n-   * <code>Float.toString(float)</code> to do its dirty work.\n+   * Return <code>true</code> if the <code>float</code> has the same\n+   * value as <code>NaN</code>, otherwise return <code>false</code>.\n    *\n-   * @return the <code>String</code> representation of this <code>Float</code>.\n-   * @see #toString(float)\n+   * @param v the <code>float</code> to compare\n+   * @return whether the argument is <code>NaN</code>\n    */\n-  public String toString ()\n+  public static boolean isNaN(float v)\n   {\n-    return toString (value);\n+    // This works since NaN != NaN is the only reflexive inequality\n+    // comparison which returns true.\n+    return v != v;\n   }\n \n   /**\n-   * If the <code>Object</code> is not <code>null</code>, is an\n-   * <code>instanceof</code> <code>Float</code>, and represents\n-   * the same primitive <code>float</code> value return \n-   * <code>true</code>.  Otherwise <code>false</code> is returned.\n-   * <p>\n-   * Note that there are two differences between <code>==</code> and\n-   * <code>equals()</code>. <code>0.0f == -0.0f</code> returns <code>true</code>\n-   * but <code>new Float(0.0f).equals(new Float(-0.0f))</code> returns\n-   * <code>false</code>. And <code>Float.NaN == Float.NaN</code> returns\n-   * <code>false</code>, but\n-   * <code>new Float(Float.NaN).equals(new Float(Float.NaN))</code> returns\n-   * <code>true</code>.\n+   * Return <code>true</code> if the <code>float</code> has a value\n+   * equal to either <code>NEGATIVE_INFINITY</code> or\n+   * <code>POSITIVE_INFINITY</code>, otherwise return <code>false</code>.\n    *\n-   * @param obj the object to compare to\n-   * @return whether the objects are semantically equal.\n+   * @param v the <code>float</code> to compare\n+   * @return whether the argument is (-/+) infinity\n    */\n-  public boolean equals (Object obj)\n+  public static boolean isInfinite(float v)\n   {\n-    if (!(obj instanceof Float))\n-      return false;\n-\n-    float f = ((Float) obj).value;\n-\n-    // GCJ LOCAL: this implementation is probably faster than\n-    // Classpath's, especially once we inline floatToIntBits.\n-    return floatToIntBits (value) == floatToIntBits (f);\n-    // END GCJ LOCAL\n+    return v == POSITIVE_INFINITY || v == NEGATIVE_INFINITY;\n   }\n \n   /**\n-   * Return a hashcode representing this Object.\n-   * <code>Float</code>'s hash code is calculated by calling the\n-   * <code>floatToIntBits()</code> function.\n-   * @return this Object's hash code.\n-   * @see java.lang.Float.floatToIntBits(float)\n+   * Return <code>true</code> if the value of this <code>Float</code>\n+   * is the same as <code>NaN</code>, otherwise return <code>false</code>.\n+   *\n+   * @return whether this <code>Float</code> is <code>NaN</code>\n    */\n-  public int hashCode ()\n+  public boolean isNaN()\n   {\n-    return floatToIntBits (value);\n+    return isNaN(value);\n   }\n \n   /**\n-   * Return the value of this <code>Double</code> when cast to an \n-   * <code>int</code>.\n+   * Return <code>true</code> if the value of this <code>Float</code>\n+   * is the same as <code>NEGATIVE_INFINITY</code> or\n+   * <code>POSITIVE_INFINITY</code>, otherwise return <code>false</code>.\n+   *\n+   * @return whether this <code>Float</code> is (-/+) infinity\n    */\n-  public int intValue ()\n+  public boolean isInfinite()\n   {\n-    return (int) value;\n+    return isInfinite(value);\n   }\n \n   /**\n-   * Return the value of this <code>Double</code> when cast to a\n-   * <code>long</code>.\n+   * Convert the <code>float</code> value of this <code>Float</code>\n+   * to a <code>String</code>.  This method calls\n+   * <code>Float.toString(float)</code> to do its dirty work.\n+   *\n+   * @return the <code>String</code> representation\n+   * @see #toString(float)\n    */\n-  public long longValue ()\n+  public String toString()\n   {\n-    return (long) value;\n+    return toString(value);\n   }\n \n   /**\n-   * Return the value of this <code>Double</code> when cast to a\n-   * <code>float</code>.\n+   * Return the value of this <code>Float</code> as a <code>byte</code>.\n+   *\n+   * @return the byte value\n+   * @since 1.1\n    */\n-  public float floatValue ()\n+  public byte byteValue()\n   {\n-    return (float) value;\n+    return (byte) value;\n   }\n \n   /**\n-   * Return the primitive <code>double</code> value represented by this\n-   * <code>Double</code>.\n+   * Return the value of this <code>Float</code> as a <code>short</code>.\n+   *\n+   * @return the short value\n+   * @since 1.1\n    */\n-  public double doubleValue ()\n+  public short shortValue()\n   {\n-    return (double) value;\n+    return (short) value;\n   }\n \n   /**\n-   * Convert the <code>float</code> to a <code>String</code>.\n-   * <P>\n+   * Return the value of this <code>Integer</code> as an <code>int</code>.\n    *\n-   * Floating-point string representation is fairly complex: here is a\n-   * rundown of the possible values.  \"<CODE>[-]</CODE>\" indicates that a\n-   * negative sign will be printed if the value (or exponent) is negative.\n-   * \"<CODE>&lt;number&gt;</CODE>\" means a string of digits (0-9).\n-   * \"<CODE>&lt;digit&gt;</CODE>\" means a single digit (0-9).\n-   * <P>\n-   *\n-   * <TABLE BORDER=1>\n-   * <TR><TH>Value of Float</TH><TH>String Representation</TH></TR>\n-   * <TR>\n-   *     <TD>[+-] 0</TD>\n-   *     <TD>[<CODE>-</CODE>]<CODE>0.0</CODE></TD>\n-   * </TR>\n-   * <TR>\n-   *     <TD>Between [+-] 10<SUP>-3</SUP> and 10<SUP>7</SUP></TD>\n-   *     <TD><CODE>[-]number.number</CODE></TD>\n-   * </TR>\n-   * <TR>\n-   *     <TD>Other numeric value</TD>\n-   *     <TD><CODE>[-]&lt;digit&gt;.&lt;number&gt;E[-]&lt;number&gt;</CODE></TD>\n-   * </TR>\n-   * <TR>\n-   *     <TD>[+-] infinity</TD>\n-   *     <TD><CODE>[-]Infinity</CODE></TD>\n-   * </TR>\n-   * <TR>\n-   *     <TD>NaN</TD>\n-   *     <TD><CODE>NaN</CODE></TD>\n-   * </TR>\n-   * </TABLE>\n-   *\n-   * Yes, negative zero <EM>is</EM> a possible value.  Note that there is\n-   * <EM>always</EM> a <CODE>.</CODE> and at least one digit printed after\n-   * it: even if the number is 3, it will be printed as <CODE>3.0</CODE>.\n-   * After the \".\", all digits will be printed except trailing zeros.  No\n-   * truncation or rounding is done by this function.\n-   *\n-   * @XXX specify where we are not in accord with the spec.\n-   *\n-   * @param f the <code>float</code> to convert\n-   * @return the <code>String</code> representing the <code>float</code>.\n+   * @return the int value\n    */\n-  public static String toString (float f)\n+  public int intValue()\n   {\n-    return Double.toString ((double) f, true);\n+    return (int) value;\n   }\n \n   /**\n-   * Return the result of calling <code>new Float(java.lang.String)</code>.\n-   *\n-   * @param s the <code>String</code> to convert to a <code>Float</code>.\n-   * @return a new <code>Float</code> representing the <code>String</code>'s\n-   *         numeric value.\n+   * Return the value of this <code>Integer</code> as a <code>long</code>.\n    *\n-   * @exception NumberFormatException thrown if <code>String</code> cannot\n-   * be parsed as a <code>double</code>.\n-   * @see #Float(java.lang.String)\n-   * @see #parseFloat(java.lang.String)\n+   * @return the long value\n    */\n-  public static Float valueOf (String s) throws NumberFormatException\n+  public long longValue()\n   {\n-    return new Float (s);\n+    return (long) value;\n   }\n \n   /**\n-   * Return <code>true</code> if the value of this <code>Float</code>\n-   * is the same as <code>NaN</code>, otherwise return <code>false</code>.\n-   * @return whether this <code>Float</code> is <code>NaN</code>.\n+   * Return the value of this <code>Float</code>.\n+   *\n+   * @return the float value\n    */\n-  public boolean isNaN ()\n+  public float floatValue()\n   {\n-    return isNaN (value);\n+    return value;\n   }\n \n   /**\n-   * Return <code>true</code> if the <code>float</code> has the same\n-   * value as <code>NaN</code>, otherwise return <code>false</code>.\n+   * Return the value of this <code>Float</code> as a <code>double</code>\n    *\n-   * @param v the <code>float</code> to compare\n-   * @return whether the argument is <code>NaN</code>.\n+   * @return the double value\n    */\n-  public static boolean isNaN (float v)\n+  public double doubleValue()\n   {\n-    // This works since NaN != NaN is the only reflexive inequality\n-    // comparison which returns true.\n-    return v != v;\n+    return value;\n   }\n \n   /**\n-   * Return <code>true</code> if the value of this <code>Float</code>\n-   * is the same as <code>NEGATIVE_INFINITY</code> or \n-   * <code>POSITIVE_INFINITY</code>, otherwise return <code>false</code>.\n+   * Return a hashcode representing this Object. <code>Float</code>'s hash\n+   * code is calculated by calling <code>floatToIntBits(floatValue())</code>.\n    *\n-   * @return whether this <code>Float</code> is (-/+) infinity.\n+   * @return this Object's hash code\n+   * @see #floatToIntBits(float)\n    */\n-  public boolean isInfinite ()\n+  public int hashCode()\n   {\n-    return isInfinite (value);\n+    return floatToIntBits(value);\n   }\n \n   /**\n-   * Return <code>true</code> if the <code>float</code> has a value \n-   * equal to either <code>NEGATIVE_INFINITY</code> or \n-   * <code>POSITIVE_INFINITY</code>, otherwise return <code>false</code>.\n+   * Returns <code>true</code> if <code>obj</code> is an instance of\n+   * <code>Float</code> and represents the same float value. Unlike comparing\n+   * two floats with <code>==</code>, this treats two instances of\n+   * <code>Float.NaN</code> as equal, but treats <code>0.0</code> and\n+   * <code>-0.0</code> as unequal.\n    *\n-   * @param v the <code>float</code> to compare\n-   * @return whether the argument is (-/+) infinity.\n+   * <p>Note that <code>f1.equals(f2)<code> is identical to\n+   * <code>floatToIntBits(f1.floatValue()) ==\n+   *    floatToIntBits(f2.floatValue())<code>.\n+   *\n+   * @param obj the object to compare\n+   * @return whether the objects are semantically equal\n    */\n-  public static boolean isInfinite (float v)\n+  public boolean equals(Object obj)\n   {\n-    return (v == POSITIVE_INFINITY || v == NEGATIVE_INFINITY);\n+    if (! (obj instanceof Float))\n+      return false;\n+\n+    float f = ((Float) obj).value;\n+\n+    // Avoid call to native method. However, some implementations, like gcj,\n+    // are better off using floatToIntBits(value) == floatToIntBits(f).\n+    // Check common case first, then check NaN and 0.\n+    if (value == f)\n+      return (value != 0) || (1 / value == 1 / f);\n+    return isNaN(value) && isNaN(f);\n   }\n \n   /**\n-   * Return the int bits of the specified <code>float</code>.\n-   * The result of this function can be used as the argument to\n-   * <code>Float.intBitsToFloat(long)</code> to obtain the\n+   * Convert the float to the IEEE 754 floating-point \"single format\" bit\n+   * layout. Bit 31 (the most significant) is the sign bit, bits 30-23\n+   * (masked by 0x7f800000) represent the exponent, and bits 22-0\n+   * (masked by 0x007fffff) are the mantissa. This function collapses all\n+   * versions of NaN to 0x7fc00000. The result of this function can be used\n+   * as the argument to <code>Float.intBitsToFloat(int)</code> to obtain the\n    * original <code>float</code> value.\n    *\n    * @param value the <code>float</code> to convert\n-   * @return the bits of the <code>float</code>.\n+   * @return the bits of the <code>float</code>\n+   * @see #intBitsToFloat(int)\n    */\n-  public static native int floatToIntBits (float value);\n+  public static native int floatToIntBits(float value);\n \n   /**\n-   * Return the int bits of the specified <code>float</code>.\n-   * The result of this function can be used as the argument to\n-   * <code>Float.intBitsToFloat(long)</code> to obtain the\n-   * original <code>float</code> value.  The difference between\n-   * this function and <code>floatToIntBits</code> is that this\n-   * function does not collapse NaN values.\n+   * Convert the float to the IEEE 754 floating-point \"single format\" bit\n+   * layout. Bit 31 (the most significant) is the sign bit, bits 30-23\n+   * (masked by 0x7f800000) represent the exponent, and bits 22-0\n+   * (masked by 0x007fffff) are the mantissa. This function leaves NaN alone,\n+   * rather than collapsing to a canonical value. The result of this function\n+   * can be used as the argument to <code>Float.intBitsToFloat(int)</code> to\n+   * obtain the original <code>float</code> value.\n    *\n    * @param value the <code>float</code> to convert\n-   * @return the bits of the <code>float</code>.\n+   * @return the bits of the <code>float</code>\n+   * @see #intBitsToFloat(int)\n    */\n-  public static native int floatToRawIntBits (float value);\n+  public static native int floatToRawIntBits(float value);\n \n   /**\n-   * Return the <code>float</code> represented by the long\n-   * bits specified.\n+   * Convert the argument in IEEE 754 floating-point \"single format\" bit\n+   * layout to the corresponding float. Bit 31 (the most significant) is the\n+   * sign bit, bits 30-23 (masked by 0x7f800000) represent the exponent, and\n+   * bits 22-0 (masked by 0x007fffff) are the mantissa. This function leaves\n+   * NaN alone, so that you can recover the bit pattern with\n+   * <code>Float.floatToRawIntBits(float)</code>.\n    *\n-   * @param bits the long bits representing a <code>double</code>\n-   * @return the <code>float</code> represented by the bits.\n+   * @param bits the bits to convert\n+   * @return the <code>float</code> represented by the bits\n+   * @see #floatToIntBits(float)\n+   * @see #floatToRawIntBits(float)\n    */\n-  public static native float intBitsToFloat (int bits);\n+  public static native float intBitsToFloat(int bits);\n \n   /**\n-   * Returns 0 if the <code>float</code> value of the argument is \n-   * equal to the value of this <code>Float</code>.  Returns a number\n-   * less than zero if the value of this <code>Float</code> is less \n-   * than the <code>Float</code> value of the argument, and returns a \n-   * number greater than zero if the value of this <code>Float</code> \n-   * is greater than the <code>float</code> value of the argument.\n-   * <br>\n-   * <code>Float.NaN</code> is greater than any number other than itself, \n-   * even <code>Float.POSITIVE_INFINITY</code>.\n-   * <br>\n-   * <code>0.0</code> is greater than <code>-0.0</code>.\n+   * Compare two Floats numerically by comparing their <code>float</code>\n+   * values. The result is positive if the first is greater, negative if the\n+   * second is greater, and 0 if the two are equal. However, this special\n+   * cases NaN and signed zero as follows: NaN is considered greater than\n+   * all other floats, including <code>POSITIVE_INFINITY</code>, and positive\n+   * zero is considered greater than negative zero.\n    *\n-   * @param f the Float to compare to.\n-   * @return  0 if the <code>Float</code>s are the same, &lt; 0 if this\n-   *          <code>Float</code> is less than the <code>Float</code> in\n-   *          in question, or &gt; 0 if it is greater.\n+   * @param f the Float to compare\n+   * @return the comparison\n+   * @since 1.2\n+   */\n+  public int compareTo(Float f)\n+  {\n+    return compare(value, f.value);\n+  }\n+\n+  /**\n+   * Behaves like <code>compareTo(Float)</code> unless the Object\n+   * is not an <code>Float</code>.\n    *\n+   * @param o the object to compare\n+   * @return the comparison\n+   * @throws ClassCastException if the argument is not a <code>Float</code>\n+   * @see #compareTo(Float)\n+   * @see Comparable\n    * @since 1.2\n    */\n-  public int compareTo (Float f)\n+  public int compareTo(Object o)\n   {\n-    return compare (value, f.value);\n+    return compare(value, ((Float) o).value);\n   }\n \n   /**\n-   * Returns 0 if the first argument is equal to the second argument.\n-   * Returns a number less than zero if the first argument is less than the\n-   * second argument, and returns a number greater than zero if the first\n-   * argument is greater than the second argument.\n-   * <br>\n-   * <code>Float.NaN</code> is greater than any number other than itself, \n-   * even <code>Float.POSITIVE_INFINITY</code>.\n-   * <br>\n-   * <code>0.0</code> is greater than <code>-0.0</code>.\n-   *\n-   * @param x the first float to compare.\n-   * @param y the second float to compare.\n-   * @return  0 if the arguments are the same, &lt; 0 if the\n-   *          first argument is less than the second argument in\n-   *          in question, or &gt; 0 if it is greater.\n+   * Behaves like <code>new Float(x).compareTo(new Float(y))</code>; in\n+   * other words this compares two floats, special casing NaN and zero,\n+   * without the overhead of objects.\n+   *\n+   * @param x the first float to compare\n+   * @param y the second float to compare\n+   * @return the comparison\n    * @since 1.4\n    */\n-  public static int compare (float x, float y)\n+  public static int compare(float x, float y)\n   {\n-    if (isNaN (x))\n-      return isNaN (y) ? 0 : 1;\n-    if (isNaN (y))\n+    if (isNaN(x))\n+      return isNaN(y) ? 0 : 1;\n+    if (isNaN(y))\n       return -1;\n     // recall that 0.0 == -0.0, so we convert to infinities and try again\n     if (x == 0 && y == 0)\n@@ -506,23 +527,4 @@ public static int compare (float x, float y)\n \n     return x > y ? 1 : -1;\n   }\n-\n-  /**\n-   * Compares the specified <code>Object</code> to this <code>Float</code>\n-   * if and only if the <code>Object</code> is an instanceof \n-   * <code>Float</code>.\n-   * Otherwise it throws a <code>ClassCastException</code>\n-   *\n-   * @param o the Object to compare to.\n-   * @return  0 if the <code>Float</code>s are the same, &lt; 0 if this\n-   *          <code>Float</code> is less than the <code>Float</code> in\n-   *          in question, or &gt; 0 if it is greater.\n-   * @throws ClassCastException if the argument is not a <code>Float</code>\n-   *\n-   * @since 1.2\n-   */\n-  public int compareTo (Object o)\n-  {\n-    return compareTo ((Float) o);\n-  }\n }"}, {"sha": "f9d901804f7090789ed7955d0f5b34adc19a00e3", "filename": "libjava/java/lang/Integer.java", "status": "modified", "additions": 386, "deletions": 362, "changes": 748, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f7aeea7ac79573748c5f2632059aa6b50d74e2/libjava%2Fjava%2Flang%2FInteger.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f7aeea7ac79573748c5f2632059aa6b50d74e2/libjava%2Fjava%2Flang%2FInteger.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FInteger.java?ref=93f7aeea7ac79573748c5f2632059aa6b50d74e2", "patch": "@@ -1,13 +1,13 @@\n-/* java.lang.Integer\n-   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n+/* Integer.java -- object wrapper for int\n+   Copyright (C) 1998, 1999, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -48,36 +48,45 @@\n  * @author Paul Fisher\n  * @author John Keiser\n  * @author Warren Levy\n- * @since JDK 1.0\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @since 1.0\n+ * @status updated to 1.4\n  */\n public final class Integer extends Number implements Comparable\n {\n-  // compatible with JDK 1.0.2+\n+  /**\n+   * Compatible with JDK 1.0.2+.\n+   */\n   private static final long serialVersionUID = 1360826667806852920L;\n \n   /**\n-   * The minimum value an <code>int</code> can represent is -2147483648.\n+   * The minimum value an <code>int</code> can represent is -2147483648 (or\n+   * -2<sup>31</sup>).\n    */\n   public static final int MIN_VALUE = 0x80000000;\n \n   /**\n-   * The maximum value an <code>int</code> can represent is 2147483647.\n+   * The maximum value an <code>int</code> can represent is 2147483647 (or\n+   * 2<sup>31</sup> - 1).\n    */\n   public static final int MAX_VALUE = 0x7fffffff;\n \n   /**\n-   * The primitive type <code>int</code> is represented by this \n+   * The primitive type <code>int</code> is represented by this\n    * <code>Class</code> object.\n+   * @since 1.1\n    */\n-  public static final Class TYPE = VMClassLoader.getPrimitiveClass ('I');\n+  public static final Class TYPE = VMClassLoader.getPrimitiveClass('I');\n \n   /**\n    * The immutable value of this Integer.\n+   *\n+   * @serial the wrapped int\n    */\n   private final int value;\n \n   /**\n-   * Create an <code>Integer</code> object representing the value of the \n+   * Create an <code>Integer</code> object representing the value of the\n    * <code>int</code> argument.\n    *\n    * @param value the value to use\n@@ -88,135 +97,73 @@ public Integer(int value)\n   }\n \n   /**\n-   * Create an <code>Integer</code> object representing the value of the \n+   * Create an <code>Integer</code> object representing the value of the\n    * argument after conversion to an <code>int</code>.\n    *\n-   * @param s the string to convert.\n+   * @param s the string to convert\n+   * @throws NumberFormatException if the String does not contain an int\n+   * @see #valueOf(String)\n    */\n-  public Integer(String s) throws NumberFormatException\n+  public Integer(String s)\n   {\n-    value = parseInt(s, 10);\n+    value = parseInt(s, 10, false);\n   }\n \n   /**\n-   * Return a hashcode representing this Object.\n-   *\n-   * <code>Integer</code>'s hash code is calculated by simply returning its\n-   * value.\n-   *\n-   * @return this Object's hash code.\n-   */\n-  public int hashCode()\n-  {\n-    return value;\n-  }\n-\n-  /**\n-   * If the <code>Object</code> is not <code>null</code>, is an\n-   * <code>instanceof</code> <code>Integer</code>, and represents\n-   * the same primitive <code>int</code> value return \n-   * <code>true</code>.  Otherwise <code>false</code> is returned.\n-   */\n-  public boolean equals(Object obj)\n-  {\n-    return obj instanceof Integer && value == ((Integer)obj).value;\n-  }\n-\n-  /**\n-   * Get the specified system property as an <code>Integer</code>.\n-   *\n-   * The <code>decode()</code> method will be used to interpret the value of\n-   * the property.\n-   * @param nm the name of the system property\n-   * @return the system property as an <code>Integer</code>, or\n-   *         <code>null</code> if the property is not found or cannot be\n-   *         decoded as an <code>Integer</code>.\n-   * @see java.lang.System#getProperty(java.lang.String)\n-   * @see #decode(int)\n-   */\n-  public static Integer getInteger(String nm)\n-  {\n-    return getInteger(nm, null);\n-  }\n-\n-  /**\n-   * Get the specified system property as an <code>Integer</code>, or use a\n-   * default <code>int</code> value if the property is not found or is not\n-   * decodable.\n-   * \n-   * The <code>decode()</code> method will be used to interpret the value of\n-   * the property.\n+   * Converts the <code>int</code> to a <code>String</code> using\n+   * the specified radix (base). If the radix exceeds\n+   * <code>Character.MIN_RADIX</code> or <code>Character.MAX_RADIX</code>, 10\n+   * is used instead. If the result is negative, the leading character is\n+   * '-' ('\\\\u002D'). The remaining characters come from\n+   * <code>Character.forDigit(digit, radix)</code> ('0'-'9','a'-'z').\n    *\n-   * @param nm the name of the system property\n-   * @param val the default value to use if the property is not found or not\n-   *        a number.\n-   * @return the system property as an <code>Integer</code>, or the default\n-   *         value if the property is not found or cannot be decoded as an\n-   *         <code>Integer</code>.\n-   * @see java.lang.System#getProperty(java.lang.String)\n-   * @see #decode(int)\n-   * @see #getInteger(java.lang.String,java.lang.Integer)\n+   * @param num the <code>int</code> to convert to <code>String</code>\n+   * @param radix the radix (base) to use in the conversion\n+   * @return the <code>String</code> representation of the argument\n    */\n-  public static Integer getInteger(String nm, int val)\n+  public static String toString(int num, int radix)\n   {\n-    Integer result = getInteger(nm, null);\n-    return (result == null) ? new Integer(val) : result;\n-  }\n+    if (radix < Character.MIN_RADIX || radix > Character.MAX_RADIX)\n+      radix = 10;\n \n-  /**\n-   * Get the specified system property as an <code>Integer</code>, or use a\n-   * default <code>Integer</code> value if the property is not found or is\n-   * not decodable.\n-   * \n-   * The <code>decode()</code> method will be used to interpret the value of\n-   * the property.\n-   *\n-   * @param nm the name of the system property\n-   * @param val the default value to use if the property is not found or not\n-   *        a number.\n-   * @return the system property as an <code>Integer</code>, or the default\n-   *         value if the property is not found or cannot be decoded as an\n-   *         <code>Integer</code>.\n-   * @see java.lang.System#getProperty(java.lang.String)\n-   * @see #decode(int)\n-   * @see #getInteger(java.lang.String,int)\n-   */\n-  public static Integer getInteger(String nm, Integer def)\n-  {\n-    String val = System.getProperty(nm);\n-    if (val == null) return def;\n-    try\n-      {\n-      return decode(val);\n-      }\n-    catch (NumberFormatException e)\n+    // For negative numbers, print out the absolute value w/ a leading '-'.\n+    // Use an array large enough for a binary number.\n+    char[] buffer = new char[33];\n+    int i = 33;\n+    boolean isNeg = false;\n+    if (num < 0)\n       {\n-\treturn def;\n+        isNeg = true;\n+        num = -num;\n+\n+        // When the value is MIN_VALUE, it overflows when made positive\n+        if (num < 0)\n+\t  {\n+\t    buffer[--i] = digits[(int) (-(num + radix) % radix)];\n+\t    num = -(num / radix);\n+\t  }\n       }\n-  }\n \n-  private static String toUnsignedString(int num, int exp)\n-  {\n-    // Use an array large enough for a binary number.\n-    int radix = 1 << exp;\n-    int mask = radix - 1;\n-    char[] buffer = new char[32];\n-    int i = 32;\n     do\n       {\n-        buffer[--i] = Character.forDigit(num & mask, radix);\n-        num = num >>> exp;\n+        buffer[--i] = digits[num % radix];\n+        num /= radix;\n       }\n-    while (num != 0);\n+    while (num > 0);\n \n-    return String.valueOf(buffer, i, 32-i);\n+    if (isNeg)\n+      buffer[--i] = '-';\n+\n+    // Package constructor avoids an array copy.\n+    return new String(buffer, i, 33 - i, true);\n   }\n \n   /**\n    * Converts the <code>int</code> to a <code>String</code> assuming it is\n    * unsigned in base 16.\n+   *\n    * @param i the <code>int</code> to convert to <code>String</code>\n-   * @return the <code>String</code> representation of the argument.\n+   * @return the <code>String</code> representation of the argument\n    */\n   public static String toHexString(int i)\n   {\n@@ -226,8 +173,9 @@ public static String toHexString(int i)\n   /**\n    * Converts the <code>int</code> to a <code>String</code> assuming it is\n    * unsigned in base 8.\n+   *\n    * @param i the <code>int</code> to convert to <code>String</code>\n-   * @return the <code>String</code> representation of the argument.\n+   * @return the <code>String</code> representation of the argument\n    */\n   public static String toOctalString(int i)\n   {\n@@ -237,8 +185,9 @@ public static String toOctalString(int i)\n   /**\n    * Converts the <code>int</code> to a <code>String</code> assuming it is\n    * unsigned in base 2.\n+   *\n    * @param i the <code>int</code> to convert to <code>String</code>\n-   * @return the <code>String</code> representation of the argument.\n+   * @return the <code>String</code> representation of the argument\n    */\n   public static String toBinaryString(int i)\n   {\n@@ -248,335 +197,410 @@ public static String toBinaryString(int i)\n   /**\n    * Converts the <code>int</code> to a <code>String</code> and assumes\n    * a radix of 10.\n+   *\n    * @param i the <code>int</code> to convert to <code>String</code>\n-   * @return the <code>String</code> representation of the argument.\n+   * @return the <code>String</code> representation of the argument\n+   * @see #toString(int, int)\n    */\n   public static String toString(int i)\n   {\n     // This is tricky: in libgcj, String.valueOf(int) is a fast native\n     // implementation.  In Classpath it just calls back to\n-    // Integer.toString(int,int).\n-    return String.valueOf (i);\n+    // Integer.toString(int, int).\n+    return String.valueOf(i);\n   }\n \n   /**\n-   * Converts the <code>Integer</code> value to a <code>String</code> and\n-   * assumes a radix of 10.\n-   * @return the <code>String</code> representation of this <code>Integer</code>.\n-   */    \n-  public String toString()\n-  {\n-    return toString (value);\n-  }\n-\n-  /**\n-   * Converts the <code>int</code> to a <code>String</code> using\n-   * the specified radix (base).\n-   * @param i the <code>int</code> to convert to <code>String</code>.\n-   * @param radix the radix (base) to use in the conversion.\n-   * @return the <code>String</code> representation of the argument.\n+   * Converts the specified <code>String</code> into an <code>int</code>\n+   * using the specified radix (base). The string must not be <code>null</code>\n+   * or empty. It may begin with an optional '-', which will negate the answer,\n+   * provided that there are also valid digits. Each digit is parsed as if by\n+   * <code>Character.digit(d, radix)</code>, and must be in the range\n+   * <code>0</code> to <code>radix - 1</code>. Finally, the result must be\n+   * within <code>MIN_VALUE</code> to <code>MAX_VALUE</code>, inclusive.\n+   * Unlike Double.parseDouble, you may not have a leading '+'.\n+   *\n+   * @param s the <code>String</code> to convert\n+   * @param radix the radix (base) to use in the conversion\n+   * @return the <code>String</code> argument converted to </code>int</code>\n+   * @throws NumberFormatException if <code>s</code> cannot be parsed as an\n+   *         <code>int</code>\n    */\n-  public static String toString(int num, int radix)\n+  public static int parseInt(String str, int radix)\n   {\n-    if (radix < Character.MIN_RADIX || radix > Character.MAX_RADIX)\n-      radix = 10;\n-\n-    // For negative numbers, print out the absolute value w/ a leading '-'.\n-    // Use an array large enough for a binary number.\n-    char[] buffer = new char[33];\n-    int i = 33;\n-    boolean isNeg;\n-    if (num < 0)\n-      {\n-        isNeg = true;\n-        num = -(num);\n-\n-        // When the value is MIN_VALUE, it overflows when made positive\n-        if (num < 0)\n-          {\n-            buffer[--i] = Character.forDigit(-(num + radix) % radix, radix);\n-            num = -(num / radix);\n-          }\n-      }\n-    else\n-      isNeg = false;\n-\n-    do\n-      {\n-        buffer[--i] = Character.forDigit(num % radix, radix);\n-        num /= radix;\n-      }\n-    while (num > 0);\n-\n-    if (isNeg)\n-      buffer[--i] = '-';\n-\n-    return String.valueOf(buffer, i, 33-i);\n+    return parseInt(str, radix, false);\n   }\n \n   /**\n-   * Creates a new <code>Integer</code> object using the <code>String</code>,\n-   * assuming a radix of 10.\n-   * @param s the <code>String</code> to convert.\n-   * @return the new <code>Integer</code>.\n-   * @see #Integer(java.lang.String)\n-   * @see #parseInt(java.lang.String)\n-   * @exception NumberFormatException thrown if the <code>String</code> \n-   * cannot be parsed as an <code>int</code>.\n-   */\n-  public static Integer valueOf(String s) throws NumberFormatException\n+   * Converts the specified <code>String</code> into an <code>int</code>.\n+   * This function assumes a radix of 10.\n+   *\n+   * @param s the <code>String</code> to convert\n+   * @return the <code>int</code> value of <code>s</code>\n+   * @throws NumberFormatException if <code>s</code> cannot be parsed as an\n+   *         <code>int</code>\n+   * @see #parseInt(String, int)\n+   */\n+  public static int parseInt(String s)\n   {\n-    return new Integer(parseInt(s));\n+    return parseInt(s, 10, false);\n   }\n \n   /**\n    * Creates a new <code>Integer</code> object using the <code>String</code>\n    * and specified radix (base).\n-   * @param s the <code>String</code> to convert.\n-   * @param radix the radix (base) to convert with.\n-   * @return the new <code>Integer</code>.\n-   * @see #parseInt(java.lang.String,int)\n-   * @exception NumberFormatException thrown if the <code>String</code> \n-   * cannot be parsed as an <code>int</code>.\n+   *\n+   * @param s the <code>String</code> to convert\n+   * @param radix the radix (base) to convert with\n+   * @return the new <code>Integer</code>\n+   * @throws NumberFormatException if <code>s</code> cannot be parsed as an\n+   *         <code>int</code>\n+   * @see #parseInt(String, int)\n    */\n   public static Integer valueOf(String s, int radix)\n-    throws NumberFormatException\n   {\n-    return new Integer(parseInt(s, radix));\n+    return new Integer(parseInt(s, radix, false));\n   }\n \n   /**\n-   * Converts the specified <code>String</code> into an <code>int</code>.\n-   * This function assumes a radix of 10.\n+   * Creates a new <code>Integer</code> object using the <code>String</code>,\n+   * assuming a radix of 10.\n    *\n    * @param s the <code>String</code> to convert\n-   * @return the <code>int</code> value of the <code>String</code>\n-   *         argument.\n-   * @exception NumberFormatException thrown if the <code>String</code> \n-   * cannot be parsed as an <code>int</code>.\n+   * @return the new <code>Integer</code>\n+   * @throws NumberFormatException if <code>s</code> cannot be parsed as an\n+   *         <code>int</code>\n+   * @see #Integer(String)\n+   * @see #parseInt(String)\n    */\n-  public static int parseInt(String s) throws NumberFormatException\n+  public static Integer valueOf(String s)\n   {\n-    return parseInt(s, 10);\n+    return new Integer(parseInt(s, 10, false));\n   }\n \n   /**\n-   * Converts the specified <code>String</code> into an <code>int</code>\n-   * using the specified radix (base).\n+   * Return the value of this <code>Integer</code> as a <code>byte</code>.\n    *\n-   * @param s the <code>String</code> to convert\n-   * @param radix the radix (base) to use in the conversion\n-   * @return the <code>String</code> argument converted to </code>int</code>.\n-   * @exception NumberFormatException thrown if the <code>String</code> \n-   * cannot be parsed as a <code>int</code>.    \n+   * @return the byte value\n    */\n-  public static int parseInt(String str, int radix)\n-    throws NumberFormatException\n+  public byte byteValue()\n   {\n-    final int len;\n-\n-    if (str == null)\n-      throw new NumberFormatException ();\n-\n-    if ((len = str.length()) == 0 ||\n-        radix < Character.MIN_RADIX || radix > Character.MAX_RADIX)\n-      throw new NumberFormatException();\n-\n-    boolean isNeg = false;\n-    int index = 0;\n-    if (str.charAt(index) == '-')\n-      if (len > 1)\n-        {\n-          isNeg = true;\n-          index++;\n-        }\n-      else\n-        throw new NumberFormatException();\n-\n-    return parseInt(str, index, len, isNeg, radix);\n+    return (byte) value;\n   }\n \n-  private static int parseInt(String str, int index, int len, boolean isNeg,\n-\t\t\t      int radix)\n-    throws NumberFormatException\n+  /**\n+   * Return the value of this <code>Integer</code> as a <code>short</code>.\n+   *\n+   * @return the short value\n+   */\n+  public short shortValue()\n   {\n-    int val = 0;\n-    int digval;\n-\n-    int max = MAX_VALUE / radix;\n-    // We can't directly write `max = (MAX_VALUE + 1) / radix'.\n-    // So instead we fake it.\n-    if (isNeg && MAX_VALUE % radix == radix - 1)\n-      ++max;\n-\n-    for ( ; index < len; index++)\n-      {\n-\tif (val < 0 || val > max)\n-\t  throw new NumberFormatException();\n-\n-        if ((digval = Character.digit(str.charAt(index), radix)) < 0)\n-          throw new NumberFormatException();\n-\n-        // Throw an exception for overflow if result is negative.\n-\t// However, we special-case the most negative value.\n-\tval = val * radix + digval;\n-\tif (val < 0 && (! isNeg || val != MIN_VALUE))\n-\t  throw new NumberFormatException();\n-      }\n+    return (short) value;\n+  }\n \n-    return isNeg ? -(val) : val;\n+  /**\n+   * Return the value of this <code>Integer</code>.\n+   * @return the int value\n+   */\n+  public int intValue()\n+  {\n+    return value;\n   }\n \n   /**\n-   * Convert the specified <code>String</code> into an <code>Integer</code>.\n-   * The <code>String</code> may represent decimal, hexadecimal, or \n-   * octal numbers.\n-   *\n-   * The <code>String</code> argument is interpreted based on the leading\n-   * characters.  Depending on what the String begins with, the base will be\n-   * interpreted differently:\n+   * Return the value of this <code>Integer</code> as a <code>long</code>.\n    *\n-   * <table border=1>\n-   * <tr><th>Leading<br>Characters</th><th>Base</th></tr>\n-   * <tr><td>#</td><td>16</td></tr>\n-   * <tr><td>0x</td><td>16</td></tr>\n-   * <tr><td>0X</td><td>16</td></tr>\n-   * <tr><td>0</td><td>8</td></tr>\n-   * <tr><td>Anything<br>Else</td><td>10</td></tr>\n-   * </table>\n-   *\n-   * @param str the <code>String</code> to interpret.\n-   * @return the value of the String as an <code>Integer</code>.\n-   * @exception NumberFormatException thrown if the <code>String</code> \n-   * cannot be parsed as an <code>int</code>.    \n+   * @return the long value\n    */\n-  public static Integer decode(String str) throws NumberFormatException\n+  public long longValue()\n   {\n-    boolean isNeg = false;\n-    int index = 0;\n-    int radix = 10;\n-    final int len;\n-\n-    if (str == null || (len = str.length()) == 0)\n-      throw new NumberFormatException(\"string null or empty\");\n-\n-    // Negative numbers are always radix 10.\n-    if (str.charAt(index) == '-')\n-      {\n-        radix = 10;\n-        index++;\n-        isNeg = true;\n-      }\n-    else if (str.charAt(index) == '#')\n-      {\n-        radix = 16;\n-        index++;\n-      }\n-    else if (str.charAt(index) == '0')\n-      {\n-        // Check if str is just \"0\"\n-        if (len == 1)\n-          return new Integer(0);\n+    return value;\n+  }\n \n-        index++;\n-        if (str.charAt(index) == 'x' || str.charAt(index) == 'X')\n-          {\n-            radix = 16;\n-            index++;\n-          }\n-        else\n-          radix = 8;\n-      }\n+  /**\n+   * Return the value of this <code>Integer</code> as a <code>float</code>.\n+   *\n+   * @return the float value\n+   */\n+  public float floatValue()\n+  {\n+    return value;\n+  }\n \n-    if (index >= len)\n-      throw new NumberFormatException(\"empty value\");\n+  /**\n+   * Return the value of this <code>Integer</code> as a <code>double</code>.\n+   *\n+   * @return the double value\n+   */\n+  public double doubleValue()\n+  {\n+    return value;\n+  }\n \n-    return new Integer(parseInt(str, index, len, isNeg, radix));\n+  /**\n+   * Converts the <code>Integer</code> value to a <code>String</code> and\n+   * assumes a radix of 10.\n+   *\n+   * @return the <code>String</code> representation\n+   */\n+  public String toString()\n+  {\n+    return String.valueOf(value);\n   }\n \n-  /** Return the value of this <code>Integer</code> as a <code>byte</code>.\n-   ** @return the value of this <code>Integer</code> as a <code>byte</code>.\n-   **/\n-  public byte byteValue()\n+  /**\n+   * Return a hashcode representing this Object. <code>Integer</code>'s hash\n+   * code is simply its value.\n+   *\n+   * @return this Object's hash code\n+   */\n+  public int hashCode()\n   {\n-    return (byte) value;\n+    return value;\n   }\n \n-  /** Return the value of this <code>Integer</code> as a <code>short</code>.\n-   ** @return the value of this <code>Integer</code> as a <code>short</code>.\n-   **/\n-  public short shortValue()\n+  /**\n+   * Returns <code>true</code> if <code>obj</code> is an instance of\n+   * <code>Integer</code> and represents the same int value.\n+   *\n+   * @param obj the object to compare\n+   * @return whether these Objects are semantically equal\n+   */\n+  public boolean equals(Object obj)\n   {\n-    return (short) value;\n+    return obj instanceof Integer && value == ((Integer) obj).value;\n   }\n \n-  /** Return the value of this <code>Integer</code> as an <code>int</code>.\n-   ** @return the value of this <code>Integer</code> as an <code>int</code>.\n-   **/\n-  public int intValue()\n+  /**\n+   * Get the specified system property as an <code>Integer</code>. The\n+   * <code>decode()</code> method will be used to interpret the value of\n+   * the property.\n+   *\n+   * @param nm the name of the system property\n+   * @return the system property as an <code>Integer</code>, or null if the\n+   *         property is not found or cannot be decoded\n+   * @throws SecurityException if accessing the system property is forbidden\n+   * @see System#getProperty(String)\n+   * @see #decode(String)\n+   */\n+  public static Integer getInteger(String nm)\n   {\n-    return value;\n+    return getInteger(nm, null);\n   }\n \n-  /** Return the value of this <code>Integer</code> as a <code>long</code>.\n-   ** @return the value of this <code>Integer</code> as a <code>long</code>.\n-   **/\n-  public long longValue()\n+  /**\n+   * Get the specified system property as an <code>Integer</code>, or use a\n+   * default <code>int</code> value if the property is not found or is not\n+   * decodable. The <code>decode()</code> method will be used to interpret\n+   * the value of the property.\n+   *\n+   * @param nm the name of the system property\n+   * @param val the default value\n+   * @return the value of the system property, or the default\n+   * @throws SecurityException if accessing the system property is forbidden\n+   * @see System#getProperty(String)\n+   * @see #decode(String)\n+   */\n+  public static Integer getInteger(String nm, int val)\n   {\n-    return value;\n+    Integer result = getInteger(nm, null);\n+    return result == null ? new Integer(val) : result;\n   }\n \n-  /** Return the value of this <code>Integer</code> as a <code>float</code>.\n-   ** @return the value of this <code>Integer</code> as a <code>float</code>.\n-   **/\n-  public float floatValue()\n+  /**\n+   * Get the specified system property as an <code>Integer</code>, or use a\n+   * default <code>Integer</code> value if the property is not found or is\n+   * not decodable. The <code>decode()</code> method will be used to\n+   * interpret the value of the property.\n+   *\n+   * @param nm the name of the system property\n+   * @param val the default value\n+   * @return the value of the system property, or the default\n+   * @throws SecurityException if accessing the system property is forbidden\n+   * @see System#getProperty(String)\n+   * @see #decode(String)\n+   */\n+  public static Integer getInteger(String nm, Integer def)\n   {\n-    return value;\n+    if (nm == null || \"\".equals(nm))\n+      return def;\n+    nm = System.getProperty(nm);\n+    if (nm == null)\n+      return def;\n+    try\n+      {\n+        return decode(nm);\n+      }\n+    catch (NumberFormatException e)\n+      {\n+        return def;\n+      }\n   }\n \n-  /** Return the value of this <code>Integer</code> as a <code>double</code>.\n-   ** @return the value of this <code>Integer</code> as a <code>double</code>.\n-   **/\n-  public double doubleValue()\n+  /**\n+   * Convert the specified <code>String</code> into an <code>Integer</code>.\n+   * The <code>String</code> may represent decimal, hexadecimal, or\n+   * octal numbers.\n+   *\n+   * <p>The extended BNF grammar is as follows:<br>\n+   * <pre>\n+   * <em>DecodableString</em>:\n+   *      ( [ <code>-</code> ] <em>DecimalNumber</em> )\n+   *    | ( [ <code>-</code> ] ( <code>0x</code> | <code>0X</code>\n+   *              | <code>#</code> ) <em>HexDigit</em> { <em>HexDigit</em> } )\n+   *    | ( [ <code>-</code> ] <code>0</code> { <em>OctalDigit</em> } )\n+   * <em>DecimalNumber</em>:\n+   *        <em>DecimalDigit except '0'</em> { <em>DecimalDigit</em> }\n+   * <em>DecimalDigit</em>:\n+   *        <em>Character.digit(d, 10) has value 0 to 9</em>\n+   * <em>OctalDigit</em>:\n+   *        <em>Character.digit(d, 8) has value 0 to 7</em>\n+   * <em>DecimalDigit</em>:\n+   *        <em>Character.digit(d, 16) has value 0 to 15</em>\n+   * </pre>\n+   * Finally, the value must be in the range <code>MIN_VALUE</code> to\n+   * <code>MAX_VALUE</code>, or an exception is thrown.\n+   *\n+   * @param s the <code>String</code> to interpret\n+   * @return the value of the String as an <code>Integer</code>\n+   * @throws NumberFormatException if <code>s</code> cannot be parsed as a\n+   *         <code>int</code>\n+   * @throws NullPointerException if <code>s</code> is null\n+   * @since 1.2\n+   */\n+  public static Integer decode(String str)\n   {\n-    return value;\n+    return new Integer(parseInt(str, 10, true));\n   }\n \n   /**\n-   * Compare two Integers numerically by comparing their\n-   * <code>int</code> values.\n-   * @return a positive value if this <code>Integer</code> is greater\n-   * in value than the argument <code>Integer</code>; a negative value\n-   * if this <code>Integer</code> is smaller in value than the argument\n-   * <code>Integer</code>; and <code>0</code>, zero, if this\n-   * <code>Integer</code> is equal in value to the argument\n-   * <code>Integer</code>.  \n+   * Compare two Integers numerically by comparing their <code>int</code>\n+   * values. The result is positive if the first is greater, negative if the\n+   * second is greater, and 0 if the two are equal.\n    *\n+   * @param i the Integer to compare\n+   * @return the comparison\n    * @since 1.2\n    */\n   public int compareTo(Integer i)\n   {\n-    if (this.value == i.value)\n+    if (value == i.value)\n       return 0;\n-\n     // Returns just -1 or 1 on inequality; doing math might overflow.\n-    if (this.value > i.value)\n-      return 1;\n-\n-    return -1;\n+    return value > i.value ? 1 : -1;\n   }\n \n   /**\n-   * Behaves like <code>compareTo(java.lang.Integer)</code> unless the Object\n-   * is not a <code>Integer</code>.  Then it throws a \n-   * <code>ClassCastException</code>.\n-   * @exception ClassCastException if the argument is not a\n-   * <code>Integer</code>.\n+   * Behaves like <code>compareTo(Integer)</code> unless the Object\n+   * is not an <code>Integer</code>.\n    *\n+   * @param o the object to compare\n+   * @return the comparison\n+   * @throws ClassCastException if the argument is not an <code>Integer</code>\n+   * @see #compareTo(Integer)\n+   * @see Comparable\n    * @since 1.2\n    */\n   public int compareTo(Object o)\n   {\n-    return compareTo((Integer)o);\n+    return compareTo((Integer) o);\n+  }\n+\n+  /**\n+   * Helper for converting unsigned numbers to String.\n+   *\n+   * @param num the number\n+   * @param exp log2(digit) (ie. 1, 3, or 4 for binary, oct, hex)\n+   */\n+  // Package visible for use by Long.\n+  static String toUnsignedString(int num, int exp)\n+  {\n+    // Use an array large enough for a binary number.\n+    int mask = (1 << exp) - 1;\n+    char[] buffer = new char[32];\n+    int i = 32;\n+    do\n+      {\n+        buffer[--i] = digits[num & mask];\n+        num >>>= exp;\n+      }\n+    while (num != 0);\n+\n+    // Package constructor avoids an array copy.\n+    return new String(buffer, i, 32 - i, true);\n+  }\n+\n+  /**\n+   * Helper for parsing ints, used by Integer, Short, and Byte.\n+   *\n+   * @param str the string to parse\n+   * @param radix the radix to use, must be 10 if decode is true\n+   * @param decode if called from decode\n+   * @return the parsed int value\n+   * @throws NumberFormatException if there is an error\n+   * @throws NullPointerException if decode is true and str if null\n+   * @see #parseInt(String, int)\n+   * @see #decode(String)\n+   * @see Byte#parseInt(String, int)\n+   * @see Short#parseInt(String, int)\n+   */\n+  static int parseInt(String str, int radix, boolean decode)\n+  {\n+    if (! decode && str == null)\n+      throw new NumberFormatException();\n+    int index = 0;\n+    int len = str.length();\n+    boolean isNeg = false;\n+    if (len == 0)\n+      throw new NumberFormatException();\n+    int ch = str.charAt(index);\n+    if (ch == '-')\n+      {\n+        if (len == 1)\n+          throw new NumberFormatException();\n+        isNeg = true;\n+        ch = str.charAt(++index);\n+      }\n+    if (decode)\n+      {\n+        if (ch == '0')\n+          {\n+            if (++index == len)\n+              return 0;\n+            if ((str.charAt(index) & ~('x' ^ 'X')) == 'X')\n+              {\n+                radix = 16;\n+                index++;\n+              }\n+            else\n+              radix = 8;\n+          }\n+        else if (ch == '#')\n+          {\n+            radix = 16;\n+            index++;\n+          }\n+      }\n+    if (index == len)\n+      throw new NumberFormatException();\n+\n+    int max = MAX_VALUE / radix;\n+    // We can't directly write `max = (MAX_VALUE + 1) / radix'.\n+    // So instead we fake it.\n+    if (isNeg && MAX_VALUE % radix == radix - 1)\n+      ++max;\n+\n+    int val = 0;\n+    while (index < len)\n+      {\n+\tif (val < 0 || val > max)\n+\t  throw new NumberFormatException();\n+\n+        ch = Character.digit(str.charAt(index++), radix);\n+        val = val * radix + ch;\n+        if (ch < 0 || (val < 0 && (! isNeg || val != MIN_VALUE)))\n+          throw new NumberFormatException();\n+      }\n+    return isNeg ? -val : val;\n   }\n }"}, {"sha": "1420e58d6c4763db9c7449dc9bd58c28e82a4b4c", "filename": "libjava/java/lang/Long.java", "status": "modified", "additions": 410, "deletions": 389, "changes": 799, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f7aeea7ac79573748c5f2632059aa6b50d74e2/libjava%2Fjava%2Flang%2FLong.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f7aeea7ac79573748c5f2632059aa6b50d74e2/libjava%2Fjava%2Flang%2FLong.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FLong.java?ref=93f7aeea7ac79573748c5f2632059aa6b50d74e2", "patch": "@@ -1,13 +1,13 @@\n-/* java.lang.Long\n-   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n+/* Long.java -- object wrapper for long\n+   Copyright (C) 1998, 1999, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -39,47 +39,54 @@\n package java.lang;\n \n /**\n- * Instances of class <code>Double</code> represent primitive\n- * <code>double</code> values.\n+ * Instances of class <code>Long</code> represent primitive\n+ * <code>long</code> values.\n  *\n  * Additionally, this class provides various helper functions and variables\n  * related to longs.\n  *\n  * @author Paul Fisher\n  * @author John Keiser\n  * @author Warren Levy\n- * @since JDK 1.0\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @since 1.0\n+ * @status updated to 1.4\n  */\n public final class Long extends Number implements Comparable\n {\n-  // compatible with JDK 1.0.2+\n-  static final long serialVersionUID = 4290774380558885855L;\n+  /**\n+   * Compatible with JDK 1.0.2+.\n+   */\n+  private static final long serialVersionUID = 4290774380558885855L;\n \n   /**\n    * The minimum value a <code>long</code> can represent is\n-   * -9223372036854775808.\n+   * -9223372036854775808L (or -2<sup>63</sup>).\n    */\n   public static final long MIN_VALUE = 0x8000000000000000L;\n \n   /**\n    * The maximum value a <code>long</code> can represent is\n-   * 9223372036854775807.\n+   * 9223372036854775807 (or 2<sup>63</sup> - 1).\n    */\n   public static final long MAX_VALUE = 0x7fffffffffffffffL;\n \n   /**\n-   * The primitive type <code>long</code> is represented by this \n+   * The primitive type <code>long</code> is represented by this\n    * <code>Class</code> object.\n+   * @since 1.1\n    */\n   public static final Class TYPE = VMClassLoader.getPrimitiveClass ('J');\n \n   /**\n    * The immutable value of this Long.\n+   *\n+   * @serial the wrapped long\n    */\n   private final long value;\n \n   /**\n-   * Create a <code>Long</code> object representing the value of the \n+   * Create a <code>Long</code> object representing the value of the\n    * <code>long</code> argument.\n    *\n    * @param value the value to use\n@@ -90,504 +97,518 @@ public Long(long value)\n   }\n \n   /**\n-   * Create a <code>Long</code> object representing the value of the \n+   * Create a <code>Long</code> object representing the value of the\n    * argument after conversion to a <code>long</code>.\n    *\n-   * @param s the string to convert.\n+   * @param s the string to convert\n+   * @throws NumberFormatException if the String does not contain a long\n+   * @see #valueOf(String)\n    */\n-  public Long(String s) throws NumberFormatException\n+  public Long(String s)\n   {\n-    value = parseLong(s, 10);\n+    value = parseLong(s, 10, false);\n   }\n \n   /**\n-   * If the <code>Object</code> is not <code>null</code>, is an\n-   * <code>instanceof</code> <code>Long</code>, and represents\n-   * the same primitive <code>long</code> value return \n-   * <code>true</code>.  Otherwise <code>false</code> is returned.\n+   * Converts the <code>long</code> to a <code>String</code> using\n+   * the specified radix (base). If the radix exceeds\n+   * <code>Character.MIN_RADIX</code> or <code>Character.MAX_RADIX</code>, 10\n+   * is used instead. If the result is negative, the leading character is\n+   * '-' ('\\\\u002D'). The remaining characters come from\n+   * <code>Character.forDigit(digit, radix)</code> ('0'-'9','a'-'z').\n+   *\n+   * @param num the <code>long</code> to convert to <code>String</code>\n+   * @param radix the radix (base) to use in the conversion\n+   * @return the <code>String</code> representation of the argument\n    */\n-  public boolean equals(Object obj)\n+  public static String toString(long num, int radix)\n   {\n-    return obj instanceof Long && ((Long)obj).value == value;\n+    // Use the Integer toString for efficiency if possible.\n+    if ((int) num == num)\n+      return Integer.toString((int) num, radix);\n+\n+    if (radix < Character.MIN_RADIX || radix > Character.MAX_RADIX)\n+      radix = 10;\n+\n+    // For negative numbers, print out the absolute value w/ a leading '-'.\n+    // Use an array large enough for a binary number.\n+    char[] buffer = new char[65];\n+    int i = 65;\n+    boolean isNeg = false;\n+    if (num < 0)\n+      {\n+        isNeg = true;\n+        num = -num;\n+\n+        // When the value is MIN_VALUE, it overflows when made positive\n+        if (num < 0)\n+\t  {\n+\t    buffer[--i] = digits[(int) (-(num + radix) % radix)];\n+\t    num = -(num / radix);\n+\t  }\n+      }\n+\n+    do\n+      {\n+        buffer[--i] = digits[(int) (num % radix)];\n+        num /= radix;\n+      }\n+    while (num > 0);\n+\n+    if (isNeg)\n+      buffer[--i] = '-';\n+\n+    // Package constructor avoids an array copy.\n+    return new String(buffer, i, 65 - i, true);\n   }\n \n   /**\n-   * Return a hashcode representing this Object.\n+   * Converts the <code>long</code> to a <code>String</code> assuming it is\n+   * unsigned in base 16.\n    *\n-   * <code>Long</code>'s hash code is calculated by simply returning its\n-   * value.\n+   * @param l the <code>long</code> to convert to <code>String</code>\n+   * @return the <code>String</code> representation of the argument\n+   */\n+  public static String toHexString(long l)\n+  {\n+    return toUnsignedString(l, 4);\n+  }\n+\n+  /**\n+   * Converts the <code>long</code> to a <code>String</code> assuming it is\n+   * unsigned in base 8.\n    *\n-   * @return this Object's hash code.\n+   * @param l the <code>long</code> to convert to <code>String</code>\n+   * @return the <code>String</code> representation of the argument\n    */\n-  public int hashCode()\n+  public static String toOctalString(long l)\n   {\n-    return (int)(value^(value>>>32));\n+    return toUnsignedString(l, 3);\n   }\n \n   /**\n-   * Get the specified system property as a <code>Long</code>.\n+   * Converts the <code>long</code> to a <code>String</code> assuming it is\n+   * unsigned in base 2.\n    *\n-   * A method similar to <code>Integer</code>'s <code>decode()</code> will be\n-   * used to interpret the value of the property.\n-   * \n-   * @param nm the name of the system property\n-   * @return the system property as an <code>Long</code>, or\n-   *         <code>null</code> if the property is not found or cannot be\n-   *         decoded as a <code>Long</code>.\n-   * @see java.lang.System#getProperty(java.lang.String)\n-   * @see java.lang.Integer#decode(int)\n+   * @param l the <code>long</code> to convert to <code>String</code>\n+   * @return the <code>String</code> representation of the argument\n    */\n-  public static Long getLong(String nm)\n+  public static String toBinaryString(long l)\n   {\n-    return getLong(nm, null);\n+    return toUnsignedString(l, 1);\n   }\n \n   /**\n-   * Get the specified system property as an <code>Long</code>, or use a\n-   * default <code>long</code> value if the property is not found or is not\n-   * decodable.\n-   * \n-   * A method similar to <code>Integer</code>'s <code>decode()</code> will be\n-   * used to interpret the value of the property.\n-   * \n-   * @param nm the name of the system property\n-   * @param val the default value to use if the property is not found or not\n-   *        a number.\n-   * @return the system property as a <code>Long</code>, or the default\n-   *         value if the property is not found or cannot be decoded as a\n-   *         <code>Long</code>.\n-   * @see java.lang.System#getProperty(java.lang.String)\n-   * @see java.lang.Integer#decode(int)\n-   * @see #getLong(java.lang.String,java.lang.Long)\n+   * Converts the <code>long</code> to a <code>String</code> and assumes\n+   * a radix of 10.\n+   *\n+   * @param num the <code>long</code> to convert to <code>String</code>\n+   * @return the <code>String</code> representation of the argument\n+   * @see #toString(long, int)\n    */\n-  public static Long getLong(String nm, long val)\n+  public static String toString(long num)\n   {\n-    Long result = getLong(nm, null);\n-    return (result == null) ? new Long(val) : result;\n+    return toString(num, 10);\n   }\n \n   /**\n-   * Get the specified system property as an <code>Long</code>, or use a\n-   * default <code>Long</code> value if the property is not found or is\n-   * not decodable.\n-   * \n-   * The <code>decode()</code> method will be used to interpret the value of\n-   * the property.\n+   * Converts the specified <code>String</code> into an <code>int</code>\n+   * using the specified radix (base). The string must not be <code>null</code>\n+   * or empty. It may begin with an optional '-', which will negate the answer,\n+   * provided that there are also valid digits. Each digit is parsed as if by\n+   * <code>Character.digit(d, radix)</code>, and must be in the range\n+   * <code>0</code> to <code>radix - 1</code>. Finally, the result must be\n+   * within <code>MIN_VALUE</code> to <code>MAX_VALUE</code>, inclusive.\n+   * Unlike Double.parseDouble, you may not have a leading '+'; and 'l' or\n+   * 'L' as the last character is only valid in radices 22 or greater, where\n+   * it is a digit and not a type indicator.\n    *\n-   * @param nm the name of the system property\n-   * @param val the default value to use if the property is not found or not\n-   *        a number.\n-   * @return the system property as an <code>Long</code>, or the default\n-   *         value if the property is not found or cannot be decoded as an\n-   *         <code>Long</code>.\n-   * @see java.lang.System#getProperty(java.lang.String)\n-   * @see java.lang.Integer#decode(int)\n-   * @see #getLong(java.lang.String,long)\n+   * @param s the <code>String</code> to convert\n+   * @param radix the radix (base) to use in the conversion\n+   * @return the <code>String</code> argument converted to </code>long</code>\n+   * @throws NumberFormatException if <code>s</code> cannot be parsed as a\n+   *         <code>long</code>\n    */\n-  public static Long getLong(String nm, Long def)\n+  public static long parseLong(String str, int radix)\n   {\n-    String val = System.getProperty(nm);\n-    if (val == null)\n-      return def;\n-    try\n-      {\n-\treturn decode(nm);\n-      }\n-    catch (NumberFormatException e)\n-      {\n-\treturn def;\n-      }\n+    return parseLong(str, radix, false);\n   }\n \n-  private static String toUnsignedString(long num, int exp)\n+  /**\n+   * Converts the specified <code>String</code> into a <code>long</code>.\n+   * This function assumes a radix of 10.\n+   *\n+   * @param s the <code>String</code> to convert\n+   * @return the <code>int</code> value of <code>s</code>\n+   * @throws NumberFormatException if <code>s</code> cannot be parsed as a\n+   *         <code>long</code>\n+   * @see #parseLong(String, int)\n+   */\n+  public static long parseLong(String s)\n   {\n-    // Use an array large enough for a binary number.\n-    int radix = 1 << exp;\n-    int mask = radix - 1;\n-    char[] buffer = new char[64];\n-    int i = 64;\n-    do\n-      {\n-        buffer[--i] = Character.forDigit((int) num & mask, radix);\n-        num = num >>> exp;\n-      }\n-    while (num != 0);\n+    return parseLong(s, 10, false);\n+  }\n \n-    return String.valueOf(buffer, i, 64-i);\n+  /**\n+   * Creates a new <code>Long</code> object using the <code>String</code>\n+   * and specified radix (base).\n+   *\n+   * @param s the <code>String</code> to convert\n+   * @param radix the radix (base) to convert with\n+   * @return the new <code>Long</code>\n+   * @throws NumberFormatException if <code>s</code> cannot be parsed as a\n+   *         <code>long</code>\n+   * @see #parseLong(String, int)\n+   */\n+  public static Long valueOf(String s, int radix)\n+  {\n+    return new Long(parseLong(s, radix, false));\n   }\n \n   /**\n-   * Converts the <code>long</code> to a <code>String</code> assuming it is\n-   * unsigned in base 16.\n-   * @param i the <code>long</code> to convert to <code>String</code>\n-   * @return the <code>String</code> representation of the argument.\n+   * Creates a new <code>Long</code> object using the <code>String</code>,\n+   * assuming a radix of 10.\n+   *\n+   * @param s the <code>String</code> to convert\n+   * @return the new <code>Long</code>\n+   * @throws NumberFormatException if <code>s</code> cannot be parsed as a\n+   *         <code>long</code>\n+   * @see #Long(String)\n+   * @see #parseLong(String)\n    */\n-  public static String toHexString(long i)\n+  public static Long valueOf(String s)\n   {\n-    return toUnsignedString(i, 4);\n+    return new Long(parseLong(s, 10, false));\n   }\n \n   /**\n-   * Converts the <code>long</code> to a <code>String</code> assuming it is\n-   * unsigned in base 8.\n-   * @param i the <code>long</code> to convert to <code>String</code>\n-   * @return the <code>String</code> representation of the argument.\n+   * Convert the specified <code>String</code> into a <code>Long</code>.\n+   * The <code>String</code> may represent decimal, hexadecimal, or\n+   * octal numbers.\n+   *\n+   * <p>The extended BNF grammar is as follows:<br>\n+   * <pre>\n+   * <em>DecodableString</em>:\n+   *      ( [ <code>-</code> ] <em>DecimalNumber</em> )\n+   *    | ( [ <code>-</code> ] ( <code>0x</code> | <code>0X</code>\n+   *              | <code>#</code> ) <em>HexDigit</em> { <em>HexDigit</em> } )\n+   *    | ( [ <code>-</code> ] <code>0</code> { <em>OctalDigit</em> } )\n+   * <em>DecimalNumber</em>:\n+   *        <em>DecimalDigit except '0'</em> { <em>DecimalDigit</em> }\n+   * <em>DecimalDigit</em>:\n+   *        <em>Character.digit(d, 10) has value 0 to 9</em>\n+   * <em>OctalDigit</em>:\n+   *        <em>Character.digit(d, 8) has value 0 to 7</em>\n+   * <em>DecimalDigit</em>:\n+   *        <em>Character.digit(d, 16) has value 0 to 15</em>\n+   * </pre>\n+   * Finally, the value must be in the range <code>MIN_VALUE</code> to\n+   * <code>MAX_VALUE</code>, or an exception is thrown. Note that you cannot\n+   * use a trailing 'l' or 'L', unlike in Java source code.\n+   *\n+   * @param s the <code>String</code> to interpret\n+   * @return the value of the String as a <code>Long</code>\n+   * @throws NumberFormatException if <code>s</code> cannot be parsed as a\n+   *         <code>long</code>\n+   * @throws NullPointerException if <code>s</code> is null\n+   * @since 1.2\n    */\n-  public static String toOctalString(long i)\n+  public static Long decode(String str)\n   {\n-    return toUnsignedString(i, 3);\n+    return new Long(parseLong(str, 10, true));\n   }\n \n   /**\n-   * Converts the <code>long</code> to a <code>String</code> assuming it is\n-   * unsigned in base 2.\n-   * @param i the <code>long</code> to convert to <code>String</code>\n-   * @return the <code>String</code> representation of the argument.\n+   * Return the value of this <code>Long</code> as a <code>byte</code>.\n+   *\n+   * @return the byte value\n    */\n-  public static String toBinaryString(long i) {\n-    return toUnsignedString(i, 1);\n+  public byte byteValue()\n+  {\n+    return (byte) value;\n   }\n \n   /**\n-   * Converts the <code>long</code> to a <code>String</code> and assumes\n-   * a radix of 10.\n-   * @param num the <code>long</code> to convert to <code>String</code>\n-   * @return the <code>String</code> representation of the argument.\n-   */    \n-  public static String toString(long num)\n+   * Return the value of this <code>Long</code> as a <code>short</code>.\n+   *\n+   * @return the short value\n+   */\n+  public short shortValue()\n   {\n-    // Use the Integer toString for efficiency if possible.\n-    if (num <= Integer.MAX_VALUE && num >= Integer.MIN_VALUE)\n-      return Integer.toString((int) num);\n+    return (short) value;\n+  }\n \n-    // Use an array large enough for \"-9223372036854775808\"; i.e. 20 chars.\n-    char[] buffer = new char[20];\n-    int i = 20;\n-    boolean isNeg;\n-    if (num < 0)\n-      {\n-        isNeg = true;\n-        num = -(num);\n-        if (num < 0)\n-          {\n-            // Must be MIN_VALUE, so handle this special case.\n-            buffer[--i] = '8';\n-            num = 922337203685477580L;\n-          }\n-      }\n-    else\n-      isNeg = false;\n+  /**\n+   * Return the value of this <code>Long</code> as an <code>int</code>.\n+   *\n+   * @return the int value\n+   */\n+  public int intValue()\n+  {\n+    return (int) value;\n+  }\n \n-    do\n-      {\n-        buffer[--i] = (char) ((int) '0' + (num % 10));\n-        num /= 10;\n-      }\n-    while (num > 0);\n+  /**\n+   * Return the value of this <code>Long</code>.\n+   *\n+   * @return the long value\n+   */\n+  public long longValue()\n+  {\n+    return value;\n+  }\n \n-    if (isNeg)\n-      buffer[--i] = '-';\n+  /**\n+   * Return the value of this <code>Long</code> as a <code>float</code>.\n+   *\n+   * @return the float value\n+   */\n+  public float floatValue()\n+  {\n+    return value;\n+  }\n \n-    return String.valueOf(buffer, i, 20-i);\n+  /**\n+   * Return the value of this <code>Long</code> as a <code>double</code>.\n+   *\n+   * @return the double value\n+   */\n+  public double doubleValue()\n+  {\n+    return value;\n   }\n \n   /**\n    * Converts the <code>Long</code> value to a <code>String</code> and\n    * assumes a radix of 10.\n-   * @return the <code>String</code> representation of this <code>Long</code>.\n-   */    \n+   *\n+   * @return the <code>String</code> representation\n+   */\n   public String toString()\n   {\n-    return toString(value);\n+    return toString(value, 10);\n   }\n-  \n+\n   /**\n-   * Converts the <code>long</code> to a <code>String</code> using\n-   * the specified radix (base).\n-   * @param num the <code>long</code> to convert to <code>String</code>.\n-   * @param radix the radix (base) to use in the conversion.\n-   * @return the <code>String</code> representation of the argument.\n+   * Return a hashcode representing this Object. <code>Long</code>'s hash\n+   * code is calculated by <code>(int) (value ^ (value &gt;&gt; 32))</code>.\n+   *\n+   * @return this Object's hash code\n    */\n-  public static String toString(long num, int radix)\n+  public int hashCode()\n   {\n-    // Use optimized method for the typical case.\n-    if (radix == 10 ||\n-        radix < Character.MIN_RADIX || radix > Character.MAX_RADIX)\n-      return toString(num);\n-\n-    // Use the Integer toString for efficiency if possible.\n-    if (num <= Integer.MAX_VALUE && num >= Integer.MIN_VALUE)\n-      return Integer.toString((int) num, radix);\n-\n-    // For negative numbers, print out the absolute value w/ a leading '-'.\n-    // Use an array large enough for a binary number.\n-    char[] buffer = new char[65];\n-    int i = 65;\n-    boolean isNeg;\n-    if (num < 0)\n-      {\n-        isNeg = true;\n-        num = -(num);\n-\n-        // When the value is MIN_VALUE, it overflows when made positive\n-        if (num < 0)\n-          {\n-            buffer[--i] = Character.forDigit((int) (-(num + radix) % radix),\n-\t\t\t\t\t\tradix);\n-            num = -(num / radix);\n-          }\n-      }\n-    else\n-      isNeg = false;\n+    return (int) (value ^ (value >>> 32));\n+  }\n \n-    do\n-      {\n-        buffer[--i] = Character.forDigit((int) (num % radix), radix);\n-        num /= radix;\n-      }\n-    while (num > 0);\n+  /**\n+   * Returns <code>true</code> if <code>obj</code> is an instance of\n+   * <code>Long</code> and represents the same long value.\n+   *\n+   * @param obj the object to compare\n+   * @return whether these Objects are semantically equal\n+   */\n+  public boolean equals(Object obj)\n+  {\n+    return obj instanceof Long && value == ((Long) obj).value;\n+  }\n \n-    if (isNeg)\n-      buffer[--i] = '-';\n+  /**\n+   * Get the specified system property as a <code>Long</code>. The\n+   * <code>decode()</code> method will be used to interpret the value of\n+   * the property.\n+   *\n+   * @param nm the name of the system property\n+   * @return the system property as a <code>Long</code>, or null if the\n+   *         property is not found or cannot be decoded\n+   * @throws SecurityException if accessing the system property is forbidden\n+   * @see System#getProperty(String)\n+   * @see #decode(String)\n+   */\n+  public static Long getLong(String nm)\n+  {\n+    return getLong(nm, null);\n+  }\n \n-    return String.valueOf(buffer, i, 65-i);\n+  /**\n+   * Get the specified system property as a <code>Long</code>, or use a\n+   * default <code>long</code> value if the property is not found or is not\n+   * decodable. The <code>decode()</code> method will be used to interpret\n+   * the value of the property.\n+   *\n+   * @param nm the name of the system property\n+   * @param val the default value\n+   * @return the value of the system property, or the default\n+   * @throws SecurityException if accessing the system property is forbidden\n+   * @see System#getProperty(String)\n+   * @see #decode(String)\n+   */\n+  public static Long getLong(String nm, long val)\n+  {\n+    Long result = getLong(nm, null);\n+    return result == null ? new Long(val) : result;\n   }\n-    \n+\n   /**\n-   * Creates a new <code>Long</code> object using the <code>String</code>,\n-   * assuming a radix of 10.\n-   * @param s the <code>String</code> to convert.\n-   * @return the new <code>Long</code>.\n-   * @see #Long(java.lang.String)\n-   * @see #parseLong(java.lang.String)\n-   * @exception NumberFormatException thrown if the <code>String</code> \n-   * cannot be parsed as a <code>long</code>.\n-   */\n-  public static Long valueOf(String s) throws NumberFormatException\n+   * Get the specified system property as a <code>Long</code>, or use a\n+   * default <code>Long</code> value if the property is not found or is\n+   * not decodable. The <code>decode()</code> method will be used to\n+   * interpret the value of the property.\n+   *\n+   * @param nm the name of the system property\n+   * @param val the default value\n+   * @return the value of the system property, or the default\n+   * @throws SecurityException if accessing the system property is forbidden\n+   * @see System#getProperty(String)\n+   * @see #decode(String)\n+   */\n+  public static Long getLong(String nm, Long def)\n   {\n-    return new Long(parseLong(s));\n+    if (nm == null || \"\".equals(nm))\n+      return def;\n+    nm = System.getProperty(nm);\n+    if (nm == null)\n+      return def;\n+    try\n+      {\n+        return decode(nm);\n+      }\n+    catch (NumberFormatException e)\n+      {\n+        return def;\n+      }\n   }\n \n   /**\n-   * Creates a new <code>Long</code> object using the <code>String</code>\n-   * and specified radix (base).\n-   * @param s the <code>String</code> to convert.\n-   * @param radix the radix (base) to convert with.\n-   * @return the new <code>Long</code>.\n-   * @see #parseLong(java.lang.String,int)\n-   * @exception NumberFormatException thrown if the <code>String</code> \n-   * cannot be parsed as a <code>long</code>.\n-   */\n-  public static Long valueOf(String s, int radix) throws NumberFormatException\n+   * Compare two Longs numerically by comparing their <code>long</code>\n+   * values. The result is positive if the first is greater, negative if the\n+   * second is greater, and 0 if the two are equal.\n+   *\n+   * @param l the Long to compare\n+   * @return the comparison\n+   * @since 1.2\n+   */\n+  public int compareTo(Long l)\n   {\n-    return new Long(parseLong(s, radix));\n+    if (value == l.value)\n+      return 0;\n+    // Returns just -1 or 1 on inequality; doing math might overflow the long.\n+    return value > l.value ? 1 : -1;\n   }\n \n   /**\n-   * Converts the specified <code>String</code> into a <code>long</code>.\n-   * This function assumes a radix of 10.\n+   * Behaves like <code>compareTo(Long)</code> unless the Object\n+   * is not a <code>Long</code>.\n    *\n-   * @param s the <code>String</code> to convert\n-   * @return the <code>long</code> value of the <code>String</code>\n-   *         argument.\n-   * @exception NumberFormatException thrown if the <code>String</code> \n-   * cannot be parsed as a <code>long</code>.\n+   * @param o the object to compare\n+   * @return the comparison\n+   * @throws ClassCastException if the argument is not a <code>Long</code>\n+   * @see #compareTo(Long)\n+   * @see Comparable\n+   * @since 1.2\n    */\n-  public static long parseLong(String s) throws NumberFormatException\n+  public int compareTo(Object o)\n   {\n-    return parseLong(s, 10);\n+    return compareTo((Long) o);\n   }\n \n   /**\n-   * Converts the specified <code>String</code> into a <code>long</code>\n-   * using the specified radix (base).\n+   * Helper for converting unsigned numbers to String.\n    *\n-   * @param s the <code>String</code> to convert\n-   * @param radix the radix (base) to use in the conversion\n-   * @return the <code>String</code> argument converted to </code>long</code>.\n-   * @exception NumberFormatException thrown if the <code>String</code> \n-   * cannot be parsed as a <code>long</code>.    \n+   * @param num the number\n+   * @param exp log2(digit) (ie. 1, 3, or 4 for binary, oct, hex)\n    */\n-  public static long parseLong(String str, int radix)\n-    throws NumberFormatException\n+  private static String toUnsignedString(long num, int exp)\n   {\n-    final int len;\n+    // Use the Integer toUnsignedString for efficiency if possible.\n+    // If NUM<0 then this particular optimization doesn't work\n+    // properly.\n+    if (num >= 0 && (int) num == num)\n+      return Integer.toUnsignedString((int) num, exp);\n \n-    if ((len = str.length()) == 0 || radix < Character.MIN_RADIX \n-         || radix > Character.MAX_RADIX)\n-      throw new NumberFormatException();\n+    // Use an array large enough for a binary number.\n+    int mask = (1 << exp) - 1;\n+    char[] buffer = new char[64];\n+    int i = 64;\n+    do\n+      {\n+        buffer[--i] = digits[(int) num & mask];\n+        num >>>= exp;\n+      }\n+    while (num != 0);\n \n-    boolean isNeg = false;\n-    int index = 0;\n-    if (str.charAt(index) == '-')\n-      if (len > 1)\n-        {\n-          isNeg = true;\n-          index++;\n-        }\n-      else\n-        throw new NumberFormatException();\n-\n-    return parseLong(str, index, len, isNeg, radix);\n+    // Package constructor avoids an array copy.\n+    return new String(buffer, i, 64 - i, true);\n   }\n \n-  public static Long decode(String str) throws NumberFormatException\n+  /**\n+   * Helper for parsing longs.\n+   *\n+   * @param str the string to parse\n+   * @param radix the radix to use, must be 10 if decode is true\n+   * @param decode if called from decode\n+   * @return the parsed long value\n+   * @throws NumberFormatException if there is an error\n+   * @throws NullPointerException if decode is true and str is null\n+   * @see #parseLong(String, int)\n+   * @see #decode(String)\n+   */\n+  private static long parseLong(String str, int radix, boolean decode)\n   {\n-    boolean isNeg = false;\n+    if (! decode && str == null)\n+      throw new NumberFormatException();\n     int index = 0;\n-    int radix = 10;\n-    final int len;\n-\n-    if ((len = str.length()) == 0)\n+    int len = str.length();\n+    boolean isNeg = false;\n+    if (len == 0)\n       throw new NumberFormatException();\n-\n-    // Negative numbers are always radix 10.\n-    if (str.charAt(0) == '-')\n+    int ch = str.charAt(index);\n+    if (ch == '-')\n       {\n-        radix = 10;\n-        index++;\n+        if (len == 1)\n+          throw new NumberFormatException();\n         isNeg = true;\n+        ch = str.charAt(++index);\n       }\n-    else if (str.charAt(index) == '#')\n-      {\n-        radix = 16;\n-        index++;\n-      }\n-    else if (str.charAt(index) == '0')\n+    if (decode)\n       {\n-        // Check if str is just \"0\"\n-        if (len == 1)\n-          return new Long(0L);\n-\n-        index++;\n-        if (str.charAt(index) == 'x')\n+        if (ch == '0')\n+          {\n+            if (++index == len)\n+              return 0;\n+            if ((str.charAt(index) & ~('x' ^ 'X')) == 'X')\n+              {\n+                radix = 16;\n+                index++;\n+              }\n+            else\n+              radix = 8;\n+          }\n+        else if (ch == '#')\n           {\n             radix = 16;\n             index++;\n           }\n-        else\n-          radix = 8;\n       }\n-\n-    if (index >= len)\n+    if (index == len)\n       throw new NumberFormatException();\n \n-    return new Long(parseLong(str, index, len, isNeg, radix));\n-  }\n-\n-  private static long parseLong(String str, int index, int len, boolean isNeg,\n-        \t\t\tint radix) throws NumberFormatException\n-  {\n-    long val = 0;\n-    int digval;\n-\n     long max = MAX_VALUE / radix;\n     // We can't directly write `max = (MAX_VALUE + 1) / radix'.\n     // So instead we fake it.\n     if (isNeg && MAX_VALUE % radix == radix - 1)\n       ++max;\n \n-    for ( ; index < len; index++)\n+    long val = 0;\n+    while (index < len)\n       {\n \tif (val < 0 || val > max)\n \t  throw new NumberFormatException();\n \n-        if ((digval = Character.digit(str.charAt(index), radix)) < 0)\n+        ch = Character.digit(str.charAt(index++), radix);\n+        val = val * radix + ch;\n+        if (ch < 0 || (val < 0 && (! isNeg || val != MIN_VALUE)))\n           throw new NumberFormatException();\n-\n-        // Throw an exception for overflow if result is negative.\n-\t// However, we special-case the most negative value.\n-\tval = val * radix + digval;\n-\tif (val < 0 && (! isNeg || val != MIN_VALUE))\n-\t  throw new NumberFormatException();\n       }\n-\n-    return isNeg ? -(val) : val;\n-  }\n-\n-  /** Return the value of this <code>Long</code> as an <code>short</code>.\n-   ** @return the value of this <code>Long</code> as an <code>short</code>.\n-   **/\n-  public byte byteValue()\n-  {\n-    return (byte) value;\n-  }\n-\n-  /** Return the value of this <code>Long</code> as an <code>short</code>.\n-   ** @return the value of this <code>Long</code> as an <code>short</code>.\n-   **/\n-  public short shortValue()\n-  {\n-    return (short) value;\n-  }\n-\n-  /** Return the value of this <code>Long</code> as an <code>int</code>.\n-   ** @return the value of this <code>Long</code> as an <code>int</code>.\n-   **/\n-  public int intValue()\n-  {\n-    return (int) value;\n-  }\n-\n-  /** Return the value of this <code>Long</code> as a <code>long</code>.\n-   ** @return the value of this <code>Long</code> as a <code>long</code>.\n-   **/\n-  public long longValue()\n-  {\n-    return value;\n-  }\n-\n-  /** Return the value of this <code>Long</code> as a <code>float</code>.\n-   ** @return the value of this <code>Long</code> as a <code>float</code>.\n-   **/\n-  public float floatValue()\n-  {\n-    return value;\n-  }\n-\n-  /** Return the value of this <code>Long</code> as a <code>double</code>.\n-   ** @return the value of this <code>Long</code> as a <code>double</code>.\n-   **/\n-  public double doubleValue()\n-  {\n-    return value;\n-  }\n-\n-  /**\n-   * Compare two Longs numerically by comparing their\n-   * <code>long</code> values.\n-   * @return a positive value if this <code>Long</code> is greater\n-   * in value than the argument <code>Long</code>; a negative value\n-   * if this <code>Long</code> is smaller in value than the argument\n-   * <code>Long</code>; and <code>0</code>, zero, if this\n-   * <code>Long</code> is equal in value to the argument\n-   * <code>Long</code>.  \n-   *\n-   * @since 1.2\n-   */\n-  public int compareTo(Long l)\n-  {\n-    if (this.value == l.value)\n-      return 0;\n-\n-    // Returns just -1 or 1 on inequality; doing math might overflow the long.\n-    if (this.value > l.value)\n-      return 1;\n-\n-    return -1;\n-  }\n-    \n-  /**\n-   * Behaves like <code>compareTo(java.lang.Long)</code> unless the Object\n-   * is not a <code>Long</code>.  Then it throws a \n-   * <code>ClassCastException</code>.\n-   * @exception ClassCastException if the argument is not a\n-   * <code>Long</code>.\n-   *\n-   * @since 1.2\n-   */\n-  public int compareTo(Object o)\n-  {\n-    return compareTo((Long)o);\n+    return isNeg ? -val : val;\n   }\n }"}, {"sha": "eb230b060cada74bc37babf1248bdd85ac5fbd98", "filename": "libjava/java/lang/Number.java", "status": "modified", "additions": 76, "deletions": 39, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f7aeea7ac79573748c5f2632059aa6b50d74e2/libjava%2Fjava%2Flang%2FNumber.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f7aeea7ac79573748c5f2632059aa6b50d74e2/libjava%2Fjava%2Flang%2FNumber.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FNumber.java?ref=93f7aeea7ac79573748c5f2632059aa6b50d74e2", "patch": "@@ -1,13 +1,13 @@\n-/* java.lang.Number\n-   Copyright (C) 1998, 2001 Free Software Foundation, Inc.\n+/* Number.java =- abstract superclass of numeric objects\n+   Copyright (C) 1998, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -41,54 +41,91 @@\n import java.io.Serializable;\n \n /**\n- ** Number is a generic superclass of all the numeric classes, namely\n- ** <code>Byte</code>, <code>Short</code>, <code>Integer</code>,\n- ** <code>Long</code>, <code>Float</code>, and <code>Double</code>.\n- **\n- ** It provides ways to convert from any one value to any other.\n- **\n- ** @author Paul Fisher\n- ** @author John Keiser\n- ** @author Warren Levy\n- ** @since JDK1.0\n- **/\n+ * Number is a generic superclass of all the numeric classes, including\n+ * the wrapper classes {@link Byte}, {@link Short}, {@link Integer},\n+ * {@link Long}, {@link Float}, and {@link Double}.  Also worth mentioning\n+ * are the classes in {@link java.math}.\n+ *\n+ * It provides ways to convert numeric objects to any primitive.\n+ *\n+ * @author Paul Fisher\n+ * @author John Keiser\n+ * @author Warren Levy\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @since 1.0\n+ * @status updated to 1.4\n+ */\n public abstract class Number implements Serializable\n {\n-  /** Return the value of this <code>Number</code> as a <code>byte</code>.\n-   ** @return the value of this <code>Number</code> as a <code>byte</code>.\n-   **/\n-  public byte byteValue()\n-  {\n-    return (byte) intValue();\n-  }\n+  /**\n+   * Compatible with JDK 1.1+.\n+   */\n+  private static final long serialVersionUID = -8742448824652078965L;\n \n-  /** Return the value of this <code>Number</code> as a <code>short</code>.\n-   ** @return the value of this <code>Number</code> as a <code>short</code>.\n-   **/\n-  public short shortValue()\n+  /**\n+   * Table for calculating digits, used in Character, Long, and Integer.\n+   */\n+  static final char[] digits = {\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\n+    'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n+    'u', 'v', 'w', 'x', 'y', 'z'\n+  };\n+\n+  /**\n+   * The basic constructor (often called implicitly).\n+   */\n+  public Number()\n   {\n-    return (short) intValue();\n   }\n \n-  /** Return the value of this <code>Number</code> as an <code>int</code>.\n-   ** @return the value of this <code>Number</code> as an <code>int</code>.\n-   **/\n+  /**\n+   * Return the value of this <code>Number</code> as an <code>int</code>.\n+   *\n+   * @return the int value\n+   */\n   public abstract int intValue();\n \n-  /** Return the value of this <code>Number</code> as a <code>long</code>.\n-   ** @return the value of this <code>Number</code> as a <code>long</code>.\n-   **/\n+  /**\n+   * Return the value of this <code>Number</code> as a <code>long</code>.\n+   *\n+   * @return the long value\n+   */\n   public abstract long longValue();\n \n-  /** Return the value of this <code>Number</code> as a <code>float</code>.\n-   ** @return the value of this <code>Number</code> as a <code>float</code>.\n-   **/\n+  /**\n+   * Return the value of this <code>Number</code> as a <code>float</code>.\n+   *\n+   * @return the float value\n+   */\n   public abstract float floatValue();\n \n-  /** Return the value of this <code>Number</code> as a <code>float</code>.\n-   ** @return the value of this <code>Number</code> as a <code>float</code>.\n-   **/\n+  /**\n+   * Return the value of this <code>Number</code> as a <code>float</code>.\n+   *\n+   * @return the double value\n+   */\n   public abstract double doubleValue();\n \n-  private static final long serialVersionUID = -8742448824652078965L;\n+  /**\n+   * Return the value of this <code>Number</code> as a <code>byte</code>.\n+   *\n+   * @return the byte value\n+   * @since 1.1\n+   */\n+  public byte byteValue()\n+  {\n+    return (byte) intValue();\n+  }\n+\n+  /**\n+   * Return the value of this <code>Number</code> as a <code>short</code>.\n+   *\n+   * @return the short value\n+   * @since 1.1\n+   */\n+  public short shortValue()\n+  {\n+    return (short) intValue();\n+  }\n }"}, {"sha": "2c814e1f797bc389cf95b53b7a08bd8fb490e721", "filename": "libjava/java/lang/String.java", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f7aeea7ac79573748c5f2632059aa6b50d74e2/libjava%2Fjava%2Flang%2FString.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f7aeea7ac79573748c5f2632059aa6b50d74e2/libjava%2Fjava%2Flang%2FString.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FString.java?ref=93f7aeea7ac79573748c5f2632059aa6b50d74e2", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1998, 1999, 2000, 2001  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2002  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -112,6 +112,12 @@ public String (char[] data, int offset, int count)\n     init(data, offset, count, false);\n   }\n \n+  // This is used by Integer.toString(int,int).\n+  String (char[] data, int offset, int count, boolean dont_copy)\n+  {\n+    init(data, offset, count, dont_copy);\n+  }\n+\n   public String (byte[] byteArray)\n   {\n     this (byteArray, 0, byteArray.length);"}, {"sha": "b2d64dd5b728fa932d88f28fbb43099ac82d78b4", "filename": "libjava/java/lang/Void.java", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f7aeea7ac79573748c5f2632059aa6b50d74e2/libjava%2Fjava%2Flang%2FVoid.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f7aeea7ac79573748c5f2632059aa6b50d74e2/libjava%2Fjava%2Flang%2FVoid.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FVoid.java?ref=93f7aeea7ac79573748c5f2632059aa6b50d74e2", "patch": "@@ -1,13 +1,13 @@\n-/* java.lang.Void\n-   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n+/* Void.class - defines void.class\n+   Copyright (C) 1998, 1999, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -38,30 +38,29 @@\n \n package java.lang;\n \n-/* Written using \"Java Class Libraries\", 2nd edition, plus online\n- * API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Complete.\n- */\n-\n /**\n- * Void is a placeholder class so that the variable Void.TYPE can be\n- * supported for reflection return types.\n+ * Void is a placeholder class so that the variable <code>Void.TYPE</code>\n+ * (also available as <code>void.class</code>) can be supported for\n+ * reflection return types.\n+ *\n+ * <p>This class could be Serializable, but that is up to Sun.\n  *\n  * @author Paul Fisher\n  * @author John Keiser\n- * @author Per Bothner <bothner@cygnus.com>\n- * @since JDK1.1\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @since 1.1\n+ * @status updated to 1.4\n  */\n public final class Void\n {\n   /**\n-   * The return type <code>void</code> is represented by this \n+   * The return type <code>void</code> is represented by this\n    * <code>Class</code> object.\n    */\n   public static final Class TYPE = VMClassLoader.getPrimitiveClass('V');\n \n   /**\n-   * Don't allow Void objects to be made.\n+   * Void is non-instantiable.\n    */\n   private Void() { }\n }"}, {"sha": "0d30a35af5170bf46c6f435addbbad750ba0844b", "filename": "libjava/java/lang/natString.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f7aeea7ac79573748c5f2632059aa6b50d74e2/libjava%2Fjava%2Flang%2FnatString.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f7aeea7ac79573748c5f2632059aa6b50d74e2/libjava%2Fjava%2Flang%2FnatString.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatString.cc?ref=93f7aeea7ac79573748c5f2632059aa6b50d74e2", "patch": "@@ -456,9 +456,8 @@ java::lang::String::init(jcharArray chars, jint offset, jint count,\n     }\n   else\n     {\n-      JvAssert (offset == 0);\n       array = chars;\n-      pdst = elements (array);\n+      pdst = &(elements(array)[offset]);\n     }\n \n   data = array;"}]}