{"sha": "2f59e40ed6df2304eeab78f179ab772cb20d8528", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY1OWU0MGVkNmRmMjMwNGVlYWI3OGYxNzlhYjc3MmNiMjBkODUyOA==", "commit": {"author": {"name": "Dale Johannesen", "email": "dalej@apple.com", "date": "2004-10-13T19:14:44Z"}, "committer": {"name": "Dale Johannesen", "email": "dalej@gcc.gnu.org", "date": "2004-10-13T19:14:44Z"}, "message": "extend.texi (Extended Asm): Rewrite asm volatile description.\n\n\n2004-10-13  Dale Johannesen  <dalej@apple.com>\n\n       * doc/extend.texi (Extended Asm):  Rewrite asm volatile description.\n\nFrom-SVN: r88999", "tree": {"sha": "9671b20a87109e33e5442b96cdd7c4121530cce7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9671b20a87109e33e5442b96cdd7c4121530cce7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f59e40ed6df2304eeab78f179ab772cb20d8528", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f59e40ed6df2304eeab78f179ab772cb20d8528", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f59e40ed6df2304eeab78f179ab772cb20d8528", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f59e40ed6df2304eeab78f179ab772cb20d8528/comments", "author": null, "committer": null, "parents": [{"sha": "ddfabf89bbf2d7295725609ac997490160adf8fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddfabf89bbf2d7295725609ac997490160adf8fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddfabf89bbf2d7295725609ac997490160adf8fc"}], "stats": {"total": 60, "additions": 33, "deletions": 27}, "files": [{"sha": "03b19d6b58ee516909aee1110192b1079a8ae8f7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f59e40ed6df2304eeab78f179ab772cb20d8528/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f59e40ed6df2304eeab78f179ab772cb20d8528/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f59e40ed6df2304eeab78f179ab772cb20d8528", "patch": "@@ -1,3 +1,7 @@\n+2004-10-13  Dale Johannesen  <dalej@apple.com>\n+\n+\t* doc/extend.texi (Extended Asm):  Rewrite asm volatile description.\n+\n 2004-10-13  Frank Ch. Eigler  <fche@redhat.com>\n \n \t* toplev.c (compile_file): Call mudflap_finish_file from here ..."}, {"sha": "d5236154d42839f424d12bd784db305f2647062e", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f59e40ed6df2304eeab78f179ab772cb20d8528/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f59e40ed6df2304eeab78f179ab772cb20d8528/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=2f59e40ed6df2304eeab78f179ab772cb20d8528", "patch": "@@ -3724,8 +3724,8 @@ if your instruction does have a side effect on a variable that otherwise\n appears not to change, the old value of the variable may be reused later\n if it happens to be found in a register.\n \n-You can prevent an @code{asm} instruction from being deleted, moved\n-significantly, or combined, by writing the keyword @code{volatile} after\n+You can prevent an @code{asm} instruction from being deleted\n+by writing the keyword @code{volatile} after\n the @code{asm}.  For example:\n \n @smallexample\n@@ -3737,40 +3737,42 @@ the @code{asm}.  For example:\n @end smallexample\n \n @noindent\n-If you write an @code{asm} instruction with no outputs, GCC will know\n-the instruction has side-effects and will not delete the instruction or\n-move it outside of loops.\n-\n The @code{volatile} keyword indicates that the instruction has\n important side-effects.  GCC will not delete a volatile @code{asm} if\n it is reachable.  (The instruction can still be deleted if GCC can\n prove that control-flow will never reach the location of the\n-instruction.)  In addition, GCC will not reschedule instructions\n-across a volatile @code{asm} instruction.  For example:\n+instruction.)  Note that even a volatile @code{asm} instruction \n+can be moved relative to other code, including across jump\n+instructions.  For example, on many targets there is a system \n+register which can be set to control the rounding mode of \n+floating point operations.  You might try\n+setting it with a volatile @code{asm}, like this PowerPC example:\n \n @smallexample\n-*(volatile int *)addr = foo;\n-asm volatile (\"eieio\" : : );\n+       asm volatile(\"mtfsf 255,%0\" : : \"f\" (fpenv));\n+       sum = x + y;\n @end smallexample\n \n @noindent\n-Assume @code{addr} contains the address of a memory mapped device\n-register.  The PowerPC @code{eieio} instruction (Enforce In-order\n-Execution of I/O) tells the CPU to make sure that the store to that\n-device register happens before it issues any other I/O@.\n-\n-Note that even a volatile @code{asm} instruction can be moved in ways\n-that appear insignificant to the compiler, such as across jump\n-instructions.  You can't expect a sequence of volatile @code{asm}\n-instructions to remain perfectly consecutive.  If you want consecutive\n-output, use a single @code{asm}.  Also, GCC will perform some\n-optimizations across a volatile @code{asm} instruction; GCC does not\n-``forget everything'' when it encounters a volatile @code{asm}\n-instruction the way some other compilers do.\n-\n-An @code{asm} instruction without any operands or clobbers (an ``old\n-style'' @code{asm}) will be treated identically to a volatile\n-@code{asm} instruction.\n+This will not work reliably, as the compiler may move the addition back\n+before the volatile @code{asm}.  To make it work you need to add an\n+artificial dependency to the @code{asm} referencing a variable in the code\n+you don't want moved, for example:\n+\n+@smallexample\n+    asm volatile (\"mtfsf 255,%1\" : \"=X\"(sum): \"f\"(fpenv));\n+    sum = x + y;\n+@end smallexample\n+\n+Similarly, you can't expect a\n+sequence of volatile @code{asm} instructions to remain perfectly\n+consecutive.  If you want consecutive output, use a single @code{asm}.\n+Also, GCC will perform some optimizations across a volatile @code{asm}\n+instruction; GCC does not ``forget everything'' when it encounters\n+a volatile @code{asm} instruction the way some other compilers do.\n+\n+An @code{asm} instruction without any output operands will be treated\n+identically to a volatile @code{asm} instruction.\n \n It is a natural idea to look for a way to give access to the condition\n code left by the assembler instruction.  However, when we attempted to"}]}