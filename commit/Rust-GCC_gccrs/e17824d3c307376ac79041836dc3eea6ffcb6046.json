{"sha": "e17824d3c307376ac79041836dc3eea6ffcb6046", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE3ODI0ZDNjMzA3Mzc2YWM3OTA0MTgzNmRjM2VlYTZmZmNiNjA0Ng==", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2021-09-09T12:17:41Z"}, "committer": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2021-09-09T12:17:41Z"}, "message": "Merge commit 'bca1debe33bf477df850db5979e4206627b3790b' into HEAD", "tree": {"sha": "eb8033b46d5d9fe7fcae7542913b100552c0af75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb8033b46d5d9fe7fcae7542913b100552c0af75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e17824d3c307376ac79041836dc3eea6ffcb6046", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e17824d3c307376ac79041836dc3eea6ffcb6046", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e17824d3c307376ac79041836dc3eea6ffcb6046", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e17824d3c307376ac79041836dc3eea6ffcb6046/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8fb0fd650712b91c7c18a493b56e10faa5a1fd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8fb0fd650712b91c7c18a493b56e10faa5a1fd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8fb0fd650712b91c7c18a493b56e10faa5a1fd0"}, {"sha": "bca1debe33bf477df850db5979e4206627b3790b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bca1debe33bf477df850db5979e4206627b3790b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bca1debe33bf477df850db5979e4206627b3790b"}], "stats": {"total": 342, "additions": 235, "deletions": 107}, "files": [{"sha": "0e181a673d360a0c587a1ce8c99127f94ada1009", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e17824d3c307376ac79041836dc3eea6ffcb6046/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e17824d3c307376ac79041836dc3eea6ffcb6046/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=e17824d3c307376ac79041836dc3eea6ffcb6046", "patch": "@@ -70,6 +70,7 @@ GRS_OBJS = \\\n     rust/rust-ast-full-test.o \\\n     rust/rust-session-manager.o \\\n     rust/rust-compile.o \\\n+    rust/rust-mangle.o \\\n     rust/rust-compile-resolve-path.o \\\n     rust/rust-macro-expand.o \\\n     rust/rust-hir-full-test.o \\"}, {"sha": "05c15e3c7ea50d6052a5f16f3a6af827739e9fa9", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e17824d3c307376ac79041836dc3eea6ffcb6046/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e17824d3c307376ac79041836dc3eea6ffcb6046/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=e17824d3c307376ac79041836dc3eea6ffcb6046", "patch": "@@ -28,6 +28,7 @@\n #include \"rust-ast-full.h\"\n #include \"rust-hir-full.h\"\n #include \"rust-hir-const-fold-ctx.h\"\n+#include \"rust-mangle.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -45,7 +46,7 @@ class Context\n     : backend (backend), resolver (Resolver::Resolver::get ()),\n       tyctx (Resolver::TypeCheckContext::get ()),\n       mappings (Analysis::Mappings::get ()),\n-      const_ctx (ConstFold::Context::get ())\n+      const_ctx (ConstFold::Context::get ()), mangler (Mangler ())\n   {\n     // insert the builtins\n     auto builtins = resolver->get_builtin_types ();\n@@ -285,13 +286,19 @@ class Context\n     return pop;\n   }\n \n-  // this needs to support Legacy and V0 see github #429 or #305\n   std::string mangle_item (const TyTy::BaseType *ty,\n-\t\t\t   const Resolver::CanonicalPath &path) const;\n+\t\t\t   const Resolver::CanonicalPath &path) const\n+  {\n+    return mangler.mangle_item (ty, path, mappings->get_current_crate_name ());\n+  }\n \n   std::string mangle_impl_item (const TyTy::BaseType *self,\n \t\t\t\tconst TyTy::BaseType *ty,\n-\t\t\t\tconst std::string &name) const;\n+\t\t\t\tconst std::string &name) const\n+  {\n+    return mangler.mangle_impl_item (self, ty, name,\n+\t\t\t\t     mappings->get_current_crate_name ());\n+  }\n \n private:\n   ::Backend *backend;\n@@ -300,6 +307,7 @@ class Context\n   Analysis::Mappings *mappings;\n   ConstFold::Context *const_ctx;\n   std::set<HirId> builtin_range;\n+  Mangler mangler;\n \n   // state\n   std::vector<fncontext> fn_stack;"}, {"sha": "ef2c16a1ed5a97785261b2fe7cd81e1f371c17fa", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e17824d3c307376ac79041836dc3eea6ffcb6046/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e17824d3c307376ac79041836dc3eea6ffcb6046/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=e17824d3c307376ac79041836dc3eea6ffcb6046", "patch": "@@ -22,7 +22,6 @@\n #include \"rust-compile-struct-field-expr.h\"\n #include \"rust-hir-trait-resolve.h\"\n #include \"rust-hir-path-probe.h\"\n-#include \"fnv-hash.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -538,107 +537,5 @@ HIRCompileBase::compile_locals_for_block (Resolver::Rib &rib, Bfunction *fndecl,\n \n   return true;\n }\n-\n-// Mr Mangle time\n-\n-static const std::string kMangledSymbolPrefix = \"_ZN\";\n-static const std::string kMangledSymbolDelim = \"E\";\n-static const std::string kMangledGenericDelim = \"$C$\";\n-static const std::string kMangledSubstBegin = \"$LT$\";\n-static const std::string kMangledSubstEnd = \"$GT$\";\n-\n-static std::string\n-mangle_name (const std::string &name)\n-{\n-  return std::to_string (name.size ()) + name;\n-}\n-\n-static std::string\n-mangle_canonical_path (const Resolver::CanonicalPath &path)\n-{\n-  std::string buffer;\n-  path.iterate_segs ([&] (const Resolver::CanonicalPath &p) -> bool {\n-    buffer += mangle_name (p.get ());\n-    return true;\n-  });\n-  return buffer;\n-}\n-\n-// rustc uses a sip128 hash for legacy mangling, but an fnv 128 was quicker to\n-// implement for now\n-static std::string\n-legacy_hash (const std::string &fingerprint)\n-{\n-  Hash::FNV128 hasher;\n-  hasher.write ((const unsigned char *) fingerprint.c_str (),\n-\t\tfingerprint.size ());\n-\n-  uint64_t hi, lo;\n-  hasher.sum (&hi, &lo);\n-\n-  char hex[16 + 1];\n-  memset (hex, 0, sizeof hex);\n-  snprintf (hex, sizeof hex, \"%08\" PRIx64 \"%08\" PRIx64, lo, hi);\n-\n-  return \"h\" + std::string (hex, sizeof (hex) - 1);\n-}\n-\n-static std::string\n-mangle_self (const TyTy::BaseType *self)\n-{\n-  if (self->get_kind () != TyTy::TypeKind::ADT)\n-    return mangle_name (self->get_name ());\n-\n-  const TyTy::ADTType *s = static_cast<const TyTy::ADTType *> (self);\n-  std::string buf = s->get_identifier ();\n-\n-  if (s->has_subsititions_defined ())\n-    {\n-      buf += kMangledSubstBegin;\n-\n-      const std::vector<TyTy::SubstitutionParamMapping> &params\n-\t= s->get_substs ();\n-      for (size_t i = 0; i < params.size (); i++)\n-\t{\n-\t  const TyTy::SubstitutionParamMapping &sub = params.at (i);\n-\t  buf += sub.as_string ();\n-\n-\t  if ((i + 1) < params.size ())\n-\t    buf += kMangledGenericDelim;\n-\t}\n-\n-      buf += kMangledSubstEnd;\n-    }\n-\n-  return mangle_name (buf);\n-}\n-\n-std::string\n-Context::mangle_item (const TyTy::BaseType *ty,\n-\t\t      const Resolver::CanonicalPath &path) const\n-{\n-  const std::string &crate_name = mappings->get_current_crate_name ();\n-\n-  const std::string hash = legacy_hash (ty->as_string ());\n-  const std::string hash_sig = mangle_name (hash);\n-\n-  return kMangledSymbolPrefix + mangle_name (crate_name)\n-\t + mangle_canonical_path (path) + hash_sig + kMangledSymbolDelim;\n-}\n-\n-// FIXME this is a wee bit broken\n-std::string\n-Context::mangle_impl_item (const TyTy::BaseType *self, const TyTy::BaseType *ty,\n-\t\t\t   const std::string &name) const\n-{\n-  const std::string &crate_name = mappings->get_current_crate_name ();\n-\n-  const std::string hash = legacy_hash (ty->as_string ());\n-  const std::string hash_sig = mangle_name (hash);\n-\n-  return kMangledSymbolPrefix + mangle_name (crate_name) + mangle_self (self)\n-\t + mangle_name (name) + hash_sig + kMangledSymbolDelim;\n-}\n-\n } // namespace Compile\n } // namespace Rust"}, {"sha": "40822b4be7b1681a7878d02d1c3d87b279a88593", "filename": "gcc/rust/backend/rust-mangle.cc", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e17824d3c307376ac79041836dc3eea6ffcb6046/gcc%2Frust%2Fbackend%2Frust-mangle.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e17824d3c307376ac79041836dc3eea6ffcb6046/gcc%2Frust%2Fbackend%2Frust-mangle.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-mangle.cc?ref=e17824d3c307376ac79041836dc3eea6ffcb6046", "patch": "@@ -0,0 +1,152 @@\n+#include \"rust-mangle.h\"\n+#include \"fnv-hash.h\"\n+\n+// FIXME: Rename those to legacy_*\n+static const std::string kMangledSymbolPrefix = \"_ZN\";\n+static const std::string kMangledSymbolDelim = \"E\";\n+static const std::string kMangledGenericDelim = \"$C$\";\n+static const std::string kMangledSubstBegin = \"$LT$\";\n+static const std::string kMangledSubstEnd = \"$GT$\";\n+\n+namespace Rust {\n+namespace Compile {\n+\n+Mangler::MangleVersion Mangler::version = MangleVersion::LEGACY;\n+\n+static std::string\n+legacy_mangle_name (const std::string &name)\n+{\n+  return std::to_string (name.size ()) + name;\n+}\n+\n+static std::string\n+legacy_mangle_canonical_path (const Resolver::CanonicalPath &path)\n+{\n+  std::string buffer;\n+  path.iterate_segs ([&] (const Resolver::CanonicalPath &p) -> bool {\n+    buffer += legacy_mangle_name (p.get ());\n+    return true;\n+  });\n+  return buffer;\n+}\n+\n+// rustc uses a sip128 hash for legacy mangling, but an fnv 128 was quicker to\n+// implement for now\n+static std::string\n+legacy_hash (const std::string &fingerprint)\n+{\n+  Hash::FNV128 hasher;\n+  hasher.write ((const unsigned char *) fingerprint.c_str (),\n+\t\tfingerprint.size ());\n+\n+  uint64_t hi, lo;\n+  hasher.sum (&hi, &lo);\n+\n+  char hex[16 + 1];\n+  memset (hex, 0, sizeof hex);\n+  snprintf (hex, sizeof hex, \"%08\" PRIx64 \"%08\" PRIx64, lo, hi);\n+\n+  return \"h\" + std::string (hex, sizeof (hex) - 1);\n+}\n+\n+static std::string\n+legacy_mangle_self (const TyTy::BaseType *self)\n+{\n+  if (self->get_kind () != TyTy::TypeKind::ADT)\n+    return legacy_mangle_name (self->get_name ());\n+\n+  const TyTy::ADTType *s = static_cast<const TyTy::ADTType *> (self);\n+  std::string buf = s->get_identifier ();\n+\n+  if (s->has_subsititions_defined ())\n+    {\n+      buf += kMangledSubstBegin;\n+\n+      const std::vector<TyTy::SubstitutionParamMapping> &params\n+\t= s->get_substs ();\n+      for (size_t i = 0; i < params.size (); i++)\n+\t{\n+\t  const TyTy::SubstitutionParamMapping &sub = params.at (i);\n+\t  buf += sub.as_string ();\n+\n+\t  if ((i + 1) < params.size ())\n+\t    buf += kMangledGenericDelim;\n+\t}\n+\n+      buf += kMangledSubstEnd;\n+    }\n+\n+  return legacy_mangle_name (buf);\n+}\n+\n+static std::string\n+legacy_mangle_item (const TyTy::BaseType *ty,\n+\t\t    const Resolver::CanonicalPath &path,\n+\t\t    const std::string &crate_name)\n+{\n+  const std::string hash = legacy_hash (ty->as_string ());\n+  const std::string hash_sig = legacy_mangle_name (hash);\n+\n+  return kMangledSymbolPrefix + legacy_mangle_name (crate_name)\n+\t + legacy_mangle_canonical_path (path) + hash_sig + kMangledSymbolDelim;\n+}\n+\n+// FIXME this is a wee bit broken\n+static std::string\n+legacy_mangle_impl_item (const TyTy::BaseType *self, const TyTy::BaseType *ty,\n+\t\t\t const std::string &name, const std::string &crate_name)\n+{\n+  const std::string hash = legacy_hash (ty->as_string ());\n+  const std::string hash_sig = legacy_mangle_name (hash);\n+\n+  return kMangledSymbolPrefix + legacy_mangle_name (crate_name)\n+\t + legacy_mangle_self (self) + legacy_mangle_name (name) + hash_sig\n+\t + kMangledSymbolDelim;\n+}\n+\n+// FIXME: Uncomment once v0 mangling is implemented\n+// static std::string\n+// Mangler::v0_mangle_item (const TyTy::BaseType *ty,\n+// \t\t\t const std::string &name)\n+// {}\n+//\n+// static std::string\n+// Mangler::v0_mangle_impl_item (const TyTy::BaseType *self,\n+// \t\t\t      const TyTy::BaseType *ty,\n+// \t\t\t      const std::string &name)\n+// {}\n+\n+std::string\n+Mangler::mangle_item (const TyTy::BaseType *ty,\n+\t\t      const Resolver::CanonicalPath &path,\n+\t\t      const std::string &crate_name) const\n+{\n+  switch (version)\n+    {\n+    case Mangler::MangleVersion::LEGACY:\n+      return legacy_mangle_item (ty, path, crate_name);\n+    case Mangler::MangleVersion::V0:\n+      gcc_unreachable ();\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+std::string\n+Mangler::mangle_impl_item (const TyTy::BaseType *self, const TyTy::BaseType *ty,\n+\t\t\t   const std::string &name,\n+\t\t\t   const std::string &crate_name) const\n+{\n+  switch (version)\n+    {\n+    case Mangler::MangleVersion::LEGACY:\n+      return legacy_mangle_impl_item (self, ty, name, crate_name);\n+    case Mangler::MangleVersion::V0:\n+      gcc_unreachable ();\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "9e77c54423189bfdff9e41292273099c1bf6d7dd", "filename": "gcc/rust/backend/rust-mangle.h", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e17824d3c307376ac79041836dc3eea6ffcb6046/gcc%2Frust%2Fbackend%2Frust-mangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e17824d3c307376ac79041836dc3eea6ffcb6046/gcc%2Frust%2Fbackend%2Frust-mangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-mangle.h?ref=e17824d3c307376ac79041836dc3eea6ffcb6046", "patch": "@@ -0,0 +1,54 @@\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_MANGLE_H\n+#define RUST_MANGLE_H\n+\n+#include \"rust-compile-tyty.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+class Mangler\n+{\n+public:\n+  enum MangleVersion\n+  {\n+    // Values defined in rust/lang.opt\n+    LEGACY = 0,\n+    V0 = 1,\n+  };\n+\n+  // this needs to support Legacy and V0 see github #429 or #305\n+  std::string mangle_item (const TyTy::BaseType *ty,\n+\t\t\t   const Resolver::CanonicalPath &path,\n+\t\t\t   const std::string &crate_name) const;\n+\n+  std::string mangle_impl_item (const TyTy::BaseType *self,\n+\t\t\t\tconst TyTy::BaseType *ty,\n+\t\t\t\tconst std::string &name,\n+\t\t\t\tconst std::string &crate_name) const;\n+\n+  static void set_mangling (int frust_mangling_value)\n+  {\n+    version = static_cast<MangleVersion> (frust_mangling_value);\n+  }\n+\n+private:\n+  static enum MangleVersion version;\n+};\n+} // namespace Compile\n+} // namespace Rust\n+#endif // RUST_MANGLE_H"}, {"sha": "27e3c443b386ffd99d8d21893f6366813771ba43", "filename": "gcc/rust/lang.opt", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e17824d3c307376ac79041836dc3eea6ffcb6046/gcc%2Frust%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e17824d3c307376ac79041836dc3eea6ffcb6046/gcc%2Frust%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flang.opt?ref=e17824d3c307376ac79041836dc3eea6ffcb6046", "patch": "@@ -43,6 +43,19 @@ frust-dump-\n Rust Joined RejectNegative\n -frust-dump-<type>\tDump Rust frontend internal information.\n \n+frust-mangling=\n+Rust Joined RejectNegative Enum(frust_mangling) Var(flag_rust_mangling)\n+-frust-mangling=[legacy|v0]     Choose which version to use for name mangling\n+\n+Enum\n+Name(frust_mangling) Type(int) UnknownError(unknown rust mangling option %qs)\n+\n+EnumValue\n+Enum(frust_mangling) String(legacy) Value(0)\n+\n+EnumValue\n+Enum(frust_mangling) String(v0) Value(1)\n+\n o\n Rust Joined Separate\n ; Documented in common.opt"}, {"sha": "4c1dda8d9ce1bfab3b758d7848728e6ec8941b6a", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e17824d3c307376ac79041836dc3eea6ffcb6046/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e17824d3c307376ac79041836dc3eea6ffcb6046/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=e17824d3c307376ac79041836dc3eea6ffcb6046", "patch": "@@ -3499,6 +3499,7 @@ Gcc_backend::write_global_definitions (\n \t  rust_preserve_from_gc (decl);\n \t  if (DECL_STRUCT_FUNCTION (decl) == NULL)\n \t    allocate_struct_function (decl, false);\n+\t  dump_function (TDI_original, decl);\n \t  cgraph_node::finalize_function (decl, true);\n \n \t  defs[i] = decl;"}, {"sha": "a924c4b9581c26106472215e2eed551f3d8ecdc2", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e17824d3c307376ac79041836dc3eea6ffcb6046/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e17824d3c307376ac79041836dc3eea6ffcb6046/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=e17824d3c307376ac79041836dc3eea6ffcb6046", "patch": "@@ -370,6 +370,8 @@ Session::handle_option (\n \t  ret = false;\n \t}\n       break;\n+    case OPT_frust_mangling_:\n+      Compile::Mangler::set_mangling (flag_rust_mangling);\n     // no option handling for -o\n     default:\n       // return 1 to indicate option is valid"}]}