{"sha": "0fb7aa205afebe178c06683037ccd4c41104337a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZiN2FhMjA1YWZlYmUxNzhjMDY2ODMwMzdjY2Q0YzQxMTA0MzM3YQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-01-21T16:20:24Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-01-21T16:22:45Z"}, "message": "c++: Fix up potential_constant_expression_1 FOR/WHILE_STMT handling [PR98672]\n\nThe following testcase is rejected even when it is valid.\nThe problem is that potential_constant_expression_1 doesn't have the\naccurate *jump_target tracking cxx_eval_* has, and when the loop has\na condition that isn't guaranteed to be always true, the body isn't walked\nat all.  That is mostly a correct conservative behavior, except that it\ndoesn't detect if there are any return statements in the body, which means\nthe loop might return instead of falling through to the next statement.\nWe already have code for return stmt discovery in code snippets we don't\ntry to evaluate for switches, so this patch reuses that for FOR_STMT\nand WHILE_STMT bodies.\n\nNote, I haven't touched FOR_EXPR, with statement expressions it could\nhave return stmts in it too, or it could have break or continue statements\nthat wouldn't bind to the current loop but to something outer.  That\ncase is clearly mishandled by potential_constant_expression_1 even\nwhen the condition is missing or is always true, and it wouldn't surprise me\nif cxx_eval_* didn't handle it right either, so I'm deferring that to\nseparate PR for later.  We'd need proper test coverage for all of that.\n\n> Hmm, IF_STMT probably also needs to check the else clause, if the condition\n> isn't a known constant.\n\nYou're right, I thought it was ok because it recurses with tf_none, but\nif the then branch is potentially constant and only else returns, continues\nor breaks, then as the enhanced testcase shows we were mishandling it too.\n\n2021-01-21  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR c++/98672\n\t* constexpr.c (check_for_return_continue_data): Add break_stmt member.\n\t(check_for_return_continue): Also look for BREAK_STMT.  Handle\n\tSWITCH_STMT by ignoring break_stmt from its body.\n\t(potential_constant_expression_1) <case FOR_STMT>,\n\t<case WHILE_STMT>: If the condition isn't constant true, check if\n\tthe loop body can contain a return stmt.\n\t<case SWITCH_STMT>: Adjust check_for_return_continue_data initializer.\n\t<case IF_STMT>: If recursion with tf_none is successful,\n\tmerge *jump_target from the branches - returns with highest priority,\n\tbreaks or continues lower.  If then branch is potentially constant and\n\tdoesn't return, check the else branch if it could return, break or\n\tcontinue.\n\n\t* g++.dg/cpp1y/constexpr-98672.C: New test.", "tree": {"sha": "6728c65b4d08ab5e7a09c623b8448c58fec856a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6728c65b4d08ab5e7a09c623b8448c58fec856a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0fb7aa205afebe178c06683037ccd4c41104337a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fb7aa205afebe178c06683037ccd4c41104337a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fb7aa205afebe178c06683037ccd4c41104337a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fb7aa205afebe178c06683037ccd4c41104337a/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43705f3fa343e08b2fb030460fc5e2a969954398", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43705f3fa343e08b2fb030460fc5e2a969954398", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43705f3fa343e08b2fb030460fc5e2a969954398"}], "stats": {"total": 190, "additions": 181, "deletions": 9}, "files": [{"sha": "b787919942ba84bd835c9cdcf44bdd6134db7542", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 89, "deletions": 9, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb7aa205afebe178c06683037ccd4c41104337a/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb7aa205afebe178c06683037ccd4c41104337a/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=0fb7aa205afebe178c06683037ccd4c41104337a", "patch": "@@ -7649,15 +7649,16 @@ check_automatic_or_tls (tree ref)\n struct check_for_return_continue_data {\n   hash_set<tree> *pset;\n   tree continue_stmt;\n+  tree break_stmt;\n };\n \n /* Helper function for potential_constant_expression_1 SWITCH_STMT handling,\n    called through cp_walk_tree.  Return the first RETURN_EXPR found, or note\n-   the first CONTINUE_STMT if RETURN_EXPR is not found.  */\n+   the first CONTINUE_STMT and/or BREAK_STMT if RETURN_EXPR is not found.  */\n static tree\n check_for_return_continue (tree *tp, int *walk_subtrees, void *data)\n {\n-  tree t = *tp, s;\n+  tree t = *tp, s, b;\n   check_for_return_continue_data *d = (check_for_return_continue_data *) data;\n   switch (TREE_CODE (t))\n     {\n@@ -7669,6 +7670,11 @@ check_for_return_continue (tree *tp, int *walk_subtrees, void *data)\n \td->continue_stmt = t;\n       break;\n \n+    case BREAK_STMT:\n+      if (d->break_stmt == NULL_TREE)\n+\td->break_stmt = t;\n+      break;\n+\n #define RECUR(x) \\\n       if (tree r = cp_walk_tree (&x, check_for_return_continue, data,\t\\\n \t\t\t\t d->pset))\t\t\t\t\\\n@@ -7680,16 +7686,20 @@ check_for_return_continue (tree *tp, int *walk_subtrees, void *data)\n       *walk_subtrees = 0;\n       RECUR (DO_COND (t));\n       s = d->continue_stmt;\n+      b = d->break_stmt;\n       RECUR (DO_BODY (t));\n       d->continue_stmt = s;\n+      d->break_stmt = b;\n       break;\n \n     case WHILE_STMT:\n       *walk_subtrees = 0;\n       RECUR (WHILE_COND (t));\n       s = d->continue_stmt;\n+      b = d->break_stmt;\n       RECUR (WHILE_BODY (t));\n       d->continue_stmt = s;\n+      d->break_stmt = b;\n       break;\n \n     case FOR_STMT:\n@@ -7698,16 +7708,28 @@ check_for_return_continue (tree *tp, int *walk_subtrees, void *data)\n       RECUR (FOR_COND (t));\n       RECUR (FOR_EXPR (t));\n       s = d->continue_stmt;\n+      b = d->break_stmt;\n       RECUR (FOR_BODY (t));\n       d->continue_stmt = s;\n+      d->break_stmt = b;\n       break;\n \n     case RANGE_FOR_STMT:\n       *walk_subtrees = 0;\n       RECUR (RANGE_FOR_EXPR (t));\n       s = d->continue_stmt;\n+      b = d->break_stmt;\n       RECUR (RANGE_FOR_BODY (t));\n       d->continue_stmt = s;\n+      d->break_stmt = b;\n+      break;\n+\n+    case SWITCH_STMT:\n+      *walk_subtrees = 0;\n+      RECUR (SWITCH_STMT_COND (t));\n+      b = d->break_stmt;\n+      RECUR (SWITCH_STMT_BODY (t));\n+      d->break_stmt = b;\n       break;\n #undef RECUR\n \n@@ -8190,7 +8212,18 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t  /* If we couldn't evaluate the condition, it might not ever be\n \t     true.  */\n \t  if (!integer_onep (tmp))\n-\t    return true;\n+\t    {\n+\t      /* Before returning true, check if the for body can contain\n+\t\t a return.  */\n+\t      hash_set<tree> pset;\n+\t      check_for_return_continue_data data = { &pset, NULL_TREE,\n+\t\t\t\t\t\t      NULL_TREE };\n+\t      if (tree ret_expr\n+\t\t  = cp_walk_tree (&FOR_BODY (t), check_for_return_continue,\n+\t\t\t\t  &data, &pset))\n+\t\t*jump_target = ret_expr;\n+\t      return true;\n+\t    }\n \t}\n       if (!RECUR (FOR_EXPR (t), any))\n \treturn false;\n@@ -8219,7 +8252,18 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \ttmp = cxx_eval_outermost_constant_expr (tmp, true);\n       /* If we couldn't evaluate the condition, it might not ever be true.  */\n       if (!integer_onep (tmp))\n-\treturn true;\n+\t{\n+\t  /* Before returning true, check if the while body can contain\n+\t     a return.  */\n+\t  hash_set<tree> pset;\n+\t  check_for_return_continue_data data = { &pset, NULL_TREE,\n+\t\t\t\t\t\t  NULL_TREE  };\n+\t  if (tree ret_expr\n+\t      = cp_walk_tree (&WHILE_BODY (t), check_for_return_continue,\n+\t\t\t      &data, &pset))\n+\t    *jump_target = ret_expr;\n+\t  return true;\n+\t}\n       if (!RECUR (WHILE_BODY (t), any))\n \treturn false;\n       if (breaks (jump_target) || continues (jump_target))\n@@ -8238,7 +8282,8 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n       else\n \t{\n \t  hash_set<tree> pset;\n-\t  check_for_return_continue_data data = { &pset, NULL_TREE };\n+\t  check_for_return_continue_data data = { &pset, NULL_TREE,\n+\t\t\t\t\t\t  NULL_TREE };\n \t  if (tree ret_expr\n \t      = cp_walk_tree (&SWITCH_STMT_BODY (t), check_for_return_continue,\n \t\t\t      &data, &pset))\n@@ -8648,11 +8693,46 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \treturn RECUR (TREE_OPERAND (t, 2), want_rval);\n       else if (TREE_CODE (tmp) == INTEGER_CST)\n \treturn RECUR (TREE_OPERAND (t, 1), want_rval);\n+      tmp = *jump_target;\n       for (i = 1; i < 3; ++i)\n-\tif (potential_constant_expression_1 (TREE_OPERAND (t, i),\n-\t\t\t\t\t     want_rval, strict, now,\n-\t\t\t\t\t     tf_none, jump_target))\n-\t  return true;\n+\t{\n+\t  tree this_jump_target = tmp;\n+\t  if (potential_constant_expression_1 (TREE_OPERAND (t, i),\n+\t\t\t\t\t       want_rval, strict, now,\n+\t\t\t\t\t       tf_none, &this_jump_target))\n+\t    {\n+\t      if (returns (&this_jump_target))\n+\t\t*jump_target = this_jump_target;\n+\t      else if (!returns (jump_target))\n+\t\t{\n+\t\t  if (breaks (&this_jump_target)\n+\t\t      || continues (&this_jump_target))\n+\t\t    *jump_target = this_jump_target;\n+\t\t  if (i == 1)\n+\t\t    {\n+\t\t      /* If the then branch is potentially constant, but\n+\t\t\t does not return, check if the else branch\n+\t\t\t couldn't return, break or continue.  */\n+\t\t      hash_set<tree> pset;\n+\t\t      check_for_return_continue_data data = { &pset, NULL_TREE,\n+\t\t\t\t\t\t\t      NULL_TREE };\n+\t\t      if (tree ret_expr\n+\t\t\t= cp_walk_tree (&TREE_OPERAND (t, 2),\n+\t\t\t\t\tcheck_for_return_continue, &data,\n+\t\t\t\t\t&pset))\n+\t\t\t*jump_target = ret_expr;\n+\t\t      else if (*jump_target == NULL_TREE)\n+\t\t\t{\n+\t\t\t  if (data.continue_stmt)\n+\t\t\t    *jump_target = data.continue_stmt;\n+\t\t\t  else if (data.break_stmt)\n+\t\t\t    *jump_target = data.break_stmt;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t      return true;\n+\t    }\n+\t}\n       if (flags & tf_error)\n \terror_at (loc, \"expression %qE is not a constant expression\", t);\n       return false;"}, {"sha": "06f7e42ed246271ef93eded2a857b82e35b077e8", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-98672.C", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb7aa205afebe178c06683037ccd4c41104337a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-98672.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb7aa205afebe178c06683037ccd4c41104337a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-98672.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-98672.C?ref=0fb7aa205afebe178c06683037ccd4c41104337a", "patch": "@@ -0,0 +1,92 @@\n+// PR c++/98672\n+// { dg-do compile { target c++14 } }\n+\n+void\n+foo ()\n+{\n+}\n+\n+constexpr int\n+bar ()\n+{\n+  for (int i = 0; i < 5; ++i)\n+    return i;\n+  foo ();\n+  return 0;\n+}\n+\n+constexpr int\n+baz ()\n+{\n+  int i = 0;\n+  while (i < 5)\n+    {\n+      if (i == 3)\n+\treturn i;\n+      else\n+\t++i;\n+    }\n+  foo ();\n+  return 0;\n+}\n+\n+constexpr int\n+qux (int x)\n+{\n+  if (x > 10)\n+    ++x;\n+  else\n+    return 7;\n+  foo ();\n+  return 0;\n+}\n+\n+constexpr int\n+corge (int x)\n+{\n+  for (int a = 1; ; a++)\n+    {\n+      if (x > 10)\n+\t++x;\n+      else\n+\treturn 4;\n+      foo ();\n+    }\n+}\n+\n+constexpr int\n+garply (int x)\n+{\n+  for (int a = 1; ; a++)\n+    {\n+      if (x > 10)\n+\t++x;\n+      else\n+\tbreak;\n+      foo ();\n+    }\n+  return x;\n+}\n+\n+constexpr int\n+waldo (int x)\n+{\n+  for (int a = 1; ; a++)\n+    {\n+      if (x > 10)\n+\tbreak;\n+      else\n+\treturn 5;\n+      foo ();\n+    }\n+  foo ();\n+  return x;\n+}\n+\n+constexpr int i = bar ();\n+constexpr int j = baz ();\n+constexpr int k = qux (4);\n+constexpr int l = corge (5);\n+constexpr int m = garply (2);\n+constexpr int n = waldo (-2);\n+static_assert (i == 0 && j == 3 && k == 7 && l == 4 && m == 2 && n == 5, \"\");"}]}