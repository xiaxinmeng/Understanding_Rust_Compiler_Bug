{"sha": "11fc42759850498a535a03418e667a57461fab91", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTFmYzQyNzU5ODUwNDk4YTUzNWEwMzQxOGU2NjdhNTc0NjFmYWI5MQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2006-07-03T20:14:18Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2006-07-03T20:14:18Z"}, "message": "tree.c (range_in_array_bounds_p): New predicate.\n\n\t* tree.c (range_in_array_bounds_p): New predicate.\n\t* tree.h (range_in_array_bounds_p): Declare it.\n\t* tree-eh.c (tree_could_trap_p) <ARRAY_RANGE_REF>: Use it to\n\treturn a less conservative answer.\n\t* tree-sra.c (struct sra_elt): Add new pointer field 'groups'\n\tand flag 'is_group'.\n\t(IS_ELEMENT_FOR_GROUP): New macro.\n\t(FOR_EACH_ACTUAL_CHILD): Likewise.\n\t(next_child_for_group): New helper function.\n\t(can_completely_scalarize_p): Take into account groups.\n\t(sra_hash_tree): Handle RANGE_EXPR.\n\t(sra_elt_eq): Likewise.\n\t(lookup_element): Be prepared for handling groups.\n\t(is_valid_const_index): Delete.\n\t(maybe_lookup_element_for_expr) <ARRAY_REF>: Use in_array_bounds_p\n\tinstead of is_valid_const_index.\n\t<ARRAY_RANGE_REF>: New case.\n\t(sra_walk_expr) <ARRAY_REF>: Use in_array_bounds_p instead of\n\tis_valid_const_index.\n\t<ARRAY_RANGE_REF>: Do not unconditionally punt.\n\t(scan_dump): Dump info for groups too.\n\t(decide_instantiation_1): Likewise.\n\t(decide_block_copy): Assert that the element is not a group.\n\tPropagate decision to groups.\n\t(generate_one_element_ref): Handle RANGE_EXPR.\n\t(mark_no_warning): Iterate over actual childs.\n\t(generate_copy_inout): Likewise.\n\t(generate_element_copy): Likewise.\n\t(generate_element_zero): Likewise.\n\t(generate_element_init_1): Likewise.\n\t(dump_sra_elt_name): Handle RANGE_EXPR.\n\nFrom-SVN: r115160", "tree": {"sha": "730ad49fb04e92cd040cc6234ab11f52bd71851f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/730ad49fb04e92cd040cc6234ab11f52bd71851f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/11fc42759850498a535a03418e667a57461fab91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11fc42759850498a535a03418e667a57461fab91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11fc42759850498a535a03418e667a57461fab91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11fc42759850498a535a03418e667a57461fab91/comments", "author": null, "committer": null, "parents": [{"sha": "2da7ea252a6b95314132dea56d806501a3303f77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2da7ea252a6b95314132dea56d806501a3303f77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2da7ea252a6b95314132dea56d806501a3303f77"}], "stats": {"total": 316, "additions": 252, "deletions": 64}, "files": [{"sha": "7d88546dd64f57a832d9af1d28a0dbfc39b7f160", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11fc42759850498a535a03418e667a57461fab91/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11fc42759850498a535a03418e667a57461fab91/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=11fc42759850498a535a03418e667a57461fab91", "patch": "@@ -1,3 +1,37 @@\n+2006-07-03  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* tree.c (range_in_array_bounds_p): New predicate.\n+\t* tree.h (range_in_array_bounds_p): Declare it.\n+\t* tree-eh.c (tree_could_trap_p) <ARRAY_RANGE_REF>: Use it to\n+\treturn a less conservative answer.\n+\t* tree-sra.c (struct sra_elt): Add new pointer field 'groups'\n+\tand flag 'is_group'.\n+\t(IS_ELEMENT_FOR_GROUP): New macro.\n+\t(FOR_EACH_ACTUAL_CHILD): Likewise.\n+\t(next_child_for_group): New helper function.\n+\t(can_completely_scalarize_p): Take into account groups.\n+\t(sra_hash_tree): Handle RANGE_EXPR.\n+\t(sra_elt_eq): Likewise.\n+\t(lookup_element): Be prepared for handling groups.\n+\t(is_valid_const_index): Delete.\n+\t(maybe_lookup_element_for_expr) <ARRAY_REF>: Use in_array_bounds_p\n+\tinstead of is_valid_const_index.\n+\t<ARRAY_RANGE_REF>: New case.\n+\t(sra_walk_expr) <ARRAY_REF>: Use in_array_bounds_p instead of\n+\tis_valid_const_index.\n+\t<ARRAY_RANGE_REF>: Do not unconditionally punt.\n+\t(scan_dump): Dump info for groups too.\n+\t(decide_instantiation_1): Likewise.\n+\t(decide_block_copy): Assert that the element is not a group.\n+\tPropagate decision to groups.\n+\t(generate_one_element_ref): Handle RANGE_EXPR.\n+\t(mark_no_warning): Iterate over actual childs.\n+\t(generate_copy_inout): Likewise.\n+\t(generate_element_copy): Likewise.\n+\t(generate_element_zero): Likewise.\n+\t(generate_element_init_1): Likewise.\n+\t(dump_sra_elt_name): Handle RANGE_EXPR.\n+\n 2006-07-03  Roger Sayle  <roger@eyesopen.com>\n \n \tPR tree-optimization/26251"}, {"sha": "05ae56b8a3e8e56613417e3e5f92435a87496521", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11fc42759850498a535a03418e667a57461fab91/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11fc42759850498a535a03418e667a57461fab91/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=11fc42759850498a535a03418e667a57461fab91", "patch": "@@ -1,3 +1,7 @@\n+2006-07-03  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/gnat.dg/string_slice.adb: New test.\n+\n 2006-07-01  Tobias Schl\ufffdter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \tPR fortran/19259"}, {"sha": "c14ae49b7b7d9a02789004f981deaa05ec827f88", "filename": "gcc/testsuite/gnat.dg/string_slice.adb", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11fc42759850498a535a03418e667a57461fab91/gcc%2Ftestsuite%2Fgnat.dg%2Fstring_slice.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11fc42759850498a535a03418e667a57461fab91/gcc%2Ftestsuite%2Fgnat.dg%2Fstring_slice.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fstring_slice.adb?ref=11fc42759850498a535a03418e667a57461fab91", "patch": "@@ -0,0 +1,21 @@\n+-- { dg-do run }\n+-- { dg-options \"-O\" }\n+\n+procedure string_slice is\n+\n+   subtype Key_T is String (1 .. 3);\n+\n+   function One_Xkey return Key_T is\n+      Key : Key_T := \"XXX\";\n+   begin\n+      Key (1 .. 2) := \"__\";\n+      return Key;\n+   end;\n+\n+   Key : Key_T := One_Xkey;\n+\n+begin\n+   if Key (3) /= 'X' then\n+      raise Program_Error;\n+   end if;\n+end;"}, {"sha": "e3341b1bcb8761c627aeaac13927bb235f79cd32", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11fc42759850498a535a03418e667a57461fab91/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11fc42759850498a535a03418e667a57461fab91/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=11fc42759850498a535a03418e667a57461fab91", "patch": "@@ -1889,13 +1889,14 @@ tree_could_trap_p (tree expr)\n       goto restart;\n \n     case ARRAY_RANGE_REF:\n-      /* Let us be conservative here for now.  We might be checking bounds of\n-\t the access similarly to the case below.  */\n-      if (!TREE_THIS_NOTRAP (expr))\n+      base = TREE_OPERAND (expr, 0);\n+      if (tree_could_trap_p (base))\n \treturn true;\n \n-      base = TREE_OPERAND (expr, 0);\n-      return tree_could_trap_p (base);\n+      if (TREE_THIS_NOTRAP (expr))\n+\treturn false;\n+\n+      return !range_in_array_bounds_p (expr);\n \n     case ARRAY_REF:\n       base = TREE_OPERAND (expr, 0);"}, {"sha": "80c4ca744e050c5660683a7924dff1b7e37d2065", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 153, "deletions": 59, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11fc42759850498a535a03418e667a57461fab91/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11fc42759850498a535a03418e667a57461fab91/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=11fc42759850498a535a03418e667a57461fab91", "patch": "@@ -89,20 +89,22 @@ static bitmap needs_copy_in;\n static bitmap sra_type_decomp_cache;\n static bitmap sra_type_inst_cache;\n \n-/* One of these structures is created for each candidate aggregate\n-   and each (accessed) member of such an aggregate.  */\n+/* One of these structures is created for each candidate aggregate and\n+   each (accessed) member or group of members of such an aggregate.  */\n struct sra_elt\n {\n   /* A tree of the elements.  Used when we want to traverse everything.  */\n   struct sra_elt *parent;\n+  struct sra_elt *groups;\n   struct sra_elt *children;\n   struct sra_elt *sibling;\n \n   /* If this element is a root, then this is the VAR_DECL.  If this is\n      a sub-element, this is some token used to identify the reference.\n      In the case of COMPONENT_REF, this is the FIELD_DECL.  In the case\n-     of an ARRAY_REF, this is the (constant) index.  In the case of a\n-     complex number, this is a zero or one.  */\n+     of an ARRAY_REF, this is the (constant) index.  In the case of an\n+     ARRAY_RANGE_REF, this is the (constant) RANGE_EXPR.  In the case\n+     of a complex number, this is a zero or one.  */\n   tree element;\n \n   /* The type of the element.  */\n@@ -122,6 +124,9 @@ struct sra_elt\n   /* True if TYPE is scalar.  */\n   bool is_scalar;\n \n+  /* True if this element is a group of members of its parent.  */\n+  bool is_group;\n+\n   /* True if we saw something about this element that prevents scalarization,\n      such as non-constant indexing.  */\n   bool cannot_scalarize;\n@@ -137,6 +142,48 @@ struct sra_elt\n   bool visited;\n };\n \n+#define IS_ELEMENT_FOR_GROUP(ELEMENT) (TREE_CODE (ELEMENT) == RANGE_EXPR)\n+\n+#define FOR_EACH_ACTUAL_CHILD(CHILD, ELT)\t\t\t\\\n+  for ((CHILD) = (ELT)->is_group\t\t\t\t\\\n+\t\t ? next_child_for_group (NULL, (ELT))\t\t\\\n+\t\t : (ELT)->children;\t\t\t\t\\\n+       (CHILD);\t\t\t\t\t\t\t\\\n+       (CHILD) = (ELT)->is_group\t\t\t\t\\\n+\t\t ? next_child_for_group ((CHILD), (ELT))\t\\\n+\t\t : (CHILD)->sibling)\n+\n+/* Helper function for above macro.  Return next child in group.  */\n+static struct sra_elt *\n+next_child_for_group (struct sra_elt *child, struct sra_elt *group)\n+{\n+  gcc_assert (group->is_group);\n+\n+  /* Find the next child in the parent.  */\n+  if (child)\n+    child = child->sibling;\n+  else\n+    child = group->parent->children;\n+\n+  /* Skip siblings that do not belong to the group.  */\n+  while (child)\n+    {\n+      tree g_elt = group->element;\n+      if (TREE_CODE (g_elt) == RANGE_EXPR)\n+\t{\n+\t  if (!tree_int_cst_lt (child->element, TREE_OPERAND (g_elt, 0))\n+\t      && !tree_int_cst_lt (TREE_OPERAND (g_elt, 1), child->element))\n+\t    break;\n+\t}\n+      else\n+\tgcc_unreachable ();\n+\n+      child = child->sibling;\n+    }\n+\n+  return child;\n+}\n+\n /* Random access to the child of a parent is performed by hashing.\n    This prevents quadratic behavior, and allows SRA to function\n    reasonably on larger records.  */\n@@ -352,7 +399,11 @@ can_completely_scalarize_p (struct sra_elt *elt)\n   if (elt->cannot_scalarize)\n     return false;\n \n-  for (c = elt->children; c ; c = c->sibling)\n+  for (c = elt->children; c; c = c->sibling)\n+    if (!can_completely_scalarize_p (c))\n+      return false;\n+\n+  for (c = elt->groups; c; c = c->sibling)\n     if (!can_completely_scalarize_p (c))\n       return false;\n \n@@ -380,6 +431,11 @@ sra_hash_tree (tree t)\n       h = TREE_INT_CST_LOW (t) ^ TREE_INT_CST_HIGH (t);\n       break;\n \n+    case RANGE_EXPR:\n+      h = iterative_hash_expr (TREE_OPERAND (t, 0), 0);\n+      h = iterative_hash_expr (TREE_OPERAND (t, 1), h);\n+      break;\n+\n     case FIELD_DECL:\n       /* We can have types that are compatible, but have different member\n \t lists, so we can't hash fields by ID.  Use offsets instead.  */\n@@ -447,6 +503,11 @@ sra_elt_eq (const void *x, const void *y)\n       /* Integers are not pointer unique, so compare their values.  */\n       return tree_int_cst_equal (ae, be);\n \n+    case RANGE_EXPR:\n+      return\n+\ttree_int_cst_equal (TREE_OPERAND (ae, 0), TREE_OPERAND (be, 0))\n+\t&& tree_int_cst_equal (TREE_OPERAND (ae, 1), TREE_OPERAND (be, 1));\n+\n     case FIELD_DECL:\n       /* Fields are unique within a record, but not between\n \t compatible records.  */\n@@ -470,7 +531,10 @@ lookup_element (struct sra_elt *parent, tree child, tree type,\n   struct sra_elt **slot;\n   struct sra_elt *elt;\n \n-  dummy.parent = parent;\n+  if (parent)\n+    dummy.parent = parent->is_group ? parent->parent : parent;\n+  else\n+    dummy.parent = NULL;\n   dummy.element = child;\n \n   slot = (struct sra_elt **) htab_find_slot (sra_map, &dummy, insert);\n@@ -490,8 +554,17 @@ lookup_element (struct sra_elt *parent, tree child, tree type,\n \n       if (parent)\n \t{\n-\t  elt->sibling = parent->children;\n-\t  parent->children = elt;\n+\t  if (IS_ELEMENT_FOR_GROUP (elt->element))\n+\t    {\n+\t      elt->is_group = true;\n+\t      elt->sibling = parent->groups;\n+\t      parent->groups = elt;\n+\t    }\n+\t  else\n+\t    {\n+\t      elt->sibling = parent->children;\n+\t      parent->children = elt;\n+\t    }\n \t}\n \n       /* If this is a parameter, then if we want to scalarize, we have\n@@ -506,42 +579,6 @@ lookup_element (struct sra_elt *parent, tree child, tree type,\n   return elt;\n }\n \n-/* Return true if the ARRAY_REF in EXPR is a constant, in bounds access.  */\n-\n-static bool\n-is_valid_const_index (tree expr)\n-{\n-  tree dom, t, index = TREE_OPERAND (expr, 1);\n-\n-  if (TREE_CODE (index) != INTEGER_CST)\n-    return false;\n-\n-  /* Watch out for stupid user tricks, indexing outside the array.\n-\n-     Careful, we're not called only on scalarizable types, so do not\n-     assume constant array bounds.  We needn't do anything with such\n-     cases, since they'll be referring to objects that we should have\n-     already rejected for scalarization, so returning false is fine.  */\n-\n-  dom = TYPE_DOMAIN (TREE_TYPE (TREE_OPERAND (expr, 0)));\n-  if (dom == NULL)\n-    return false;\n-\n-  t = TYPE_MIN_VALUE (dom);\n-  if (!t || TREE_CODE (t) != INTEGER_CST)\n-    return false;\n-  if (tree_int_cst_lt (index, t))\n-    return false;\n-\n-  t = TYPE_MAX_VALUE (dom);\n-  if (!t || TREE_CODE (t) != INTEGER_CST)\n-    return false;\n-  if (tree_int_cst_lt (t, index))\n-    return false;\n-\n-  return true;\n-}\n-\n /* Create or return the SRA_ELT structure for EXPR if the expression\n    refers to a scalarizable variable.  */\n \n@@ -561,13 +598,25 @@ maybe_lookup_element_for_expr (tree expr)\n       return NULL;\n \n     case ARRAY_REF:\n-      /* We can't scalarize variable array indicies.  */\n-      if (is_valid_const_index (expr))\n+      /* We can't scalarize variable array indices.  */\n+      if (in_array_bounds_p (expr))\n         child = TREE_OPERAND (expr, 1);\n       else\n \treturn NULL;\n       break;\n \n+    case ARRAY_RANGE_REF:\n+      /* We can't scalarize variable array indices.  */\n+      if (range_in_array_bounds_p (expr))\n+\t{\n+\t  tree domain = TYPE_DOMAIN (TREE_TYPE (expr));\n+\t  child = build2 (RANGE_EXPR, integer_type_node,\n+\t\t\t  TYPE_MIN_VALUE (domain), TYPE_MAX_VALUE (domain));\n+\t}\n+      else\n+\treturn NULL;\n+      break;\n+\n     case COMPONENT_REF:\n       /* Don't look through unions.  */\n       if (TREE_CODE (TREE_TYPE (TREE_OPERAND (expr, 0))) != RECORD_TYPE)\n@@ -697,7 +746,7 @@ sra_walk_expr (tree *expr_p, block_stmt_iterator *bsi, bool is_output,\n \t   the effort.  */\n \t/* ??? Hack.  Figure out how to push this into the scan routines\n \t   without duplicating too much code.  */\n-\tif (!is_valid_const_index (inner))\n+\tif (!in_array_bounds_p (inner))\n \t  {\n \t    disable_scalarization = true;\n \t    goto use_all;\n@@ -709,6 +758,18 @@ sra_walk_expr (tree *expr_p, block_stmt_iterator *bsi, bool is_output,\n \tinner = TREE_OPERAND (inner, 0);\n \tbreak;\n \n+      case ARRAY_RANGE_REF:\n+\tif (!range_in_array_bounds_p (inner))\n+\t  {\n+\t    disable_scalarization = true;\n+\t    goto use_all;\n+\t  }\n+\t/* ??? See above non-constant bounds and stride .  */\n+\tif (TREE_OPERAND (inner, 2) || TREE_OPERAND (inner, 3))\n+\t  goto use_all;\n+\tinner = TREE_OPERAND (inner, 0);\n+\tbreak;\n+\n       case COMPONENT_REF:\n \t/* A reference to a union member constitutes a reference to the\n \t   entire union.  */\n@@ -731,11 +792,6 @@ sra_walk_expr (tree *expr_p, block_stmt_iterator *bsi, bool is_output,\n \t   complete outer element, to which walk_tree will bring us next.  */\n \tgoto use_all;\n \n-      case ARRAY_RANGE_REF:\n-\t/* Similarly, a subrange reference is used to modify indexing.  Which\n-\t   means that the canonical element names that we have won't work.  */\n-\tgoto use_all;\n-\n       case VIEW_CONVERT_EXPR:\n       case NOP_EXPR:\n \t/* Similarly, a view/nop explicitly wants to look at an object in a\n@@ -1016,6 +1072,9 @@ scan_dump (struct sra_elt *elt)\n \n   for (c = elt->children; c ; c = c->sibling)\n     scan_dump (c);\n+\n+  for (c = elt->groups; c ; c = c->sibling)\n+    scan_dump (c);\n }\n \n /* Entry point to phase 2.  Scan the entire function, building up\n@@ -1186,10 +1245,19 @@ decide_instantiation_1 (struct sra_elt *elt, unsigned int parent_uses,\n     }\n   else\n     {\n-      struct sra_elt *c;\n+      struct sra_elt *c, *group;\n       unsigned int this_uses = elt->n_uses + parent_uses;\n       unsigned int this_copies = elt->n_copies + parent_copies;\n \n+      /* Consider groups of sub-elements as weighing in favour of\n+\t instantiation whatever their size.  */\n+      for (group = elt->groups; group ; group = group->sibling)\n+\tFOR_EACH_ACTUAL_CHILD (c, group)\n+\t  {\n+\t    c->n_uses += group->n_uses;\n+\t    c->n_copies += group->n_copies;\n+\t  }\n+\n       for (c = elt->children; c ; c = c->sibling)\n \tdecide_instantiation_1 (c, this_uses, this_copies);\n     }\n@@ -1293,6 +1361,10 @@ decide_block_copy (struct sra_elt *elt)\n   struct sra_elt *c;\n   bool any_inst;\n \n+  /* We shouldn't be invoked on groups of sub-elements as they must\n+     behave like their parent as far as block copy is concerned.  */\n+  gcc_assert (!elt->is_group);\n+\n   /* If scalarization is disabled, respect it.  */\n   if (elt->cannot_scalarize)\n     {\n@@ -1311,6 +1383,14 @@ decide_block_copy (struct sra_elt *elt)\n \t  c->cannot_scalarize = 1;\n \t  decide_block_copy (c);\n \t}\n+\n+      /* Groups behave like their parent.  */\n+      for (c = elt->groups; c; c = c->sibling)\n+\t{\n+\t  c->cannot_scalarize = 1;\n+\t  c->use_block_copy = 1;\n+\t}\n+\n       return false;\n     }\n \n@@ -1372,8 +1452,13 @@ decide_block_copy (struct sra_elt *elt)\n \t\t  || !type_can_instantiate_all_elements (elt->type)))\n \t    use_block_copy = true;\n \t}\n+\n       elt->use_block_copy = use_block_copy;\n \n+      /* Groups behave like their parent.  */\n+      for (c = elt->groups; c; c = c->sibling)\n+\tc->use_block_copy = use_block_copy;\n+\n       if (dump_file)\n \t{\n \t  fprintf (dump_file, \"Using %s for \",\n@@ -1496,9 +1581,10 @@ mark_no_warning (struct sra_elt *elt)\n       else\n \t{\n \t  struct sra_elt *c;\n-\t  for (c = elt->children; c ; c = c->sibling)\n+\t  FOR_EACH_ACTUAL_CHILD (c, elt)\n \t    mark_no_warning (c);\n \t}\n+      elt->all_no_warning = true;\n     }\n }\n \n@@ -1522,7 +1608,11 @@ generate_one_element_ref (struct sra_elt *elt, tree base)\n \n     case ARRAY_TYPE:\n       todoflags |= TODO_update_smt_usage;\n-      return build4 (ARRAY_REF, elt->type, base, elt->element, NULL, NULL);\n+      if (TREE_CODE (elt->element) == RANGE_EXPR)\n+\treturn build4 (ARRAY_RANGE_REF, elt->type, base,\n+\t\t       TREE_OPERAND (elt->element, 0), NULL, NULL);\n+      else\n+\treturn build4 (ARRAY_REF, elt->type, base, elt->element, NULL, NULL);\n \n     case COMPLEX_TYPE:\n       if (elt->element == integer_zero_node)\n@@ -1583,7 +1673,7 @@ generate_copy_inout (struct sra_elt *elt, bool copy_out, tree expr,\n     }\n   else\n     {\n-      for (c = elt->children; c ; c = c->sibling)\n+      FOR_EACH_ACTUAL_CHILD (c, elt)\n \t{\n \t  t = generate_one_element_ref (c, unshare_expr (expr));\n \t  generate_copy_inout (c, copy_out, t, list_p);\n@@ -1600,7 +1690,7 @@ generate_element_copy (struct sra_elt *dst, struct sra_elt *src, tree *list_p)\n {\n   struct sra_elt *dc, *sc;\n \n-  for (dc = dst->children; dc ; dc = dc->sibling)\n+  FOR_EACH_ACTUAL_CHILD (dc, dst)\n     {\n       sc = lookup_element (src, dc->element, NULL, NO_INSERT);\n       gcc_assert (sc);\n@@ -1635,7 +1725,7 @@ generate_element_zero (struct sra_elt *elt, tree *list_p)\n       return;\n     }\n \n-  for (c = elt->children; c ; c = c->sibling)\n+  FOR_EACH_ACTUAL_CHILD (c, elt)\n     generate_element_zero (c, list_p);\n \n   if (elt->replacement)\n@@ -1696,7 +1786,7 @@ generate_element_init_1 (struct sra_elt *elt, tree init, tree *list_p)\n     {\n     case COMPLEX_CST:\n     case COMPLEX_EXPR:\n-      for (sub = elt->children; sub ; sub = sub->sibling)\n+      FOR_EACH_ACTUAL_CHILD (sub, elt)\n \t{\n \t  if (sub->element == integer_zero_node)\n \t    t = (init_code == COMPLEX_EXPR\n@@ -2158,6 +2248,10 @@ dump_sra_elt_name (FILE *f, struct sra_elt *elt)\n \t    fputc ('.', f);\n \t  print_generic_expr (f, elt->element, dump_flags);\n \t}\n+      else if (TREE_CODE (elt->element) == RANGE_EXPR)\n+\tfprintf (f, \"[\"HOST_WIDE_INT_PRINT_DEC\"..\"HOST_WIDE_INT_PRINT_DEC\"]\",\n+\t\t TREE_INT_CST_LOW (TREE_OPERAND (elt->element, 0)),\n+\t\t TREE_INT_CST_LOW (TREE_OPERAND (elt->element, 1)));\n       else\n \tfprintf (f, \"[\" HOST_WIDE_INT_PRINT_DEC \"]\",\n \t\t TREE_INT_CST_LOW (elt->element));"}, {"sha": "f3889e282f21dc438ea051460e619a38acc6958c", "filename": "gcc/tree.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11fc42759850498a535a03418e667a57461fab91/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11fc42759850498a535a03418e667a57461fab91/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=11fc42759850498a535a03418e667a57461fab91", "patch": "@@ -6892,6 +6892,39 @@ in_array_bounds_p (tree ref)\n   return true;\n }\n \n+/* Returns true if it is possible to prove that the range of\n+   an array access REF (an ARRAY_RANGE_REF expression) falls\n+   into the array bounds.  */\n+\n+bool\n+range_in_array_bounds_p (tree ref)\n+{\n+  tree domain_type = TYPE_DOMAIN (TREE_TYPE (ref));\n+  tree range_min, range_max, min, max;\n+\n+  range_min = TYPE_MIN_VALUE (domain_type);\n+  range_max = TYPE_MAX_VALUE (domain_type);\n+  if (!range_min\n+      || !range_max\n+      || TREE_CODE (range_min) != INTEGER_CST\n+      || TREE_CODE (range_max) != INTEGER_CST)\n+    return false;\n+\n+  min = array_ref_low_bound (ref);\n+  max = array_ref_up_bound (ref);\n+  if (!min\n+      || !max\n+      || TREE_CODE (min) != INTEGER_CST\n+      || TREE_CODE (max) != INTEGER_CST)\n+    return false;\n+\n+  if (tree_int_cst_lt (range_min, min)\n+      || tree_int_cst_lt (max, range_max))\n+    return false;\n+\n+  return true;\n+}\n+\n /* Return true if T (assumed to be a DECL) is a global variable.  */\n \n bool"}, {"sha": "a6a8f43f72bb20120362843ddf672fd0cd946140", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11fc42759850498a535a03418e667a57461fab91/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11fc42759850498a535a03418e667a57461fab91/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=11fc42759850498a535a03418e667a57461fab91", "patch": "@@ -3576,6 +3576,7 @@ extern tree build_complex_type (tree);\n extern tree build_resx (int);\n extern tree array_type_nelts (tree);\n extern bool in_array_bounds_p (tree);\n+extern bool range_in_array_bounds_p (tree);\n \n extern tree value_member (tree, tree);\n extern tree purpose_member (tree, tree);"}]}