{"sha": "4e65deeffb7205dc20b70fdfbce51bc6b381f0db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU2NWRlZWZmYjcyMDVkYzIwYjcwZmRmYmNlNTFiYzZiMzgxZjBkYg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-05-16T21:44:40Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-05-16T21:44:40Z"}, "message": "omp-low.c (lower_rec_input_clauses): If OMP_CLAUSE_IF has non-constant expression...\n\n\t* omp-low.c (lower_rec_input_clauses): If OMP_CLAUSE_IF\n\thas non-constant expression, force sctx.lane and use two\n\targument IFN_GOMP_SIMD_LANE instead of single argument.\n\t* tree-ssa-dce.c (eliminate_unnecessary_stmts): Don't DCE\n\ttwo argument IFN_GOMP_SIMD_LANE without lhs.\n\t* tree-vectorizer.h (struct _loop_vec_info): Add simd_if_cond\n\tmember.\n\t(LOOP_VINFO_SIMD_IF_COND, LOOP_REQUIRES_VERSIONING_FOR_SIMD_IF_COND):\n\tDefine.\n\t(LOOP_REQUIRES_VERSIONING): Or in\n\tLOOP_REQUIRES_VERSIONING_FOR_SIMD_IF_COND.\n\t* tree-vect-loop.c (_loop_vec_info::_loop_vec_info): Initialize\n\tsimd_if_cond.\n\t(vect_analyze_loop_2): Punt if LOOP_VINFO_SIMD_IF_COND is constant 0.\n\t* tree-vect-loop-manip.c (vect_loop_versioning): Add runtime check\n\tfrom simd if clause if needed.\n\n\t* gcc.dg/vect/vect-simd-1.c: New test.\n\t* gcc.dg/vect/vect-simd-2.c: New test.\n\t* gcc.dg/vect/vect-simd-3.c: New test.\n\t* gcc.dg/vect/vect-simd-4.c: New test.\n\nFrom-SVN: r271298", "tree": {"sha": "04497663af09ac6033253ea43e12935fb81791b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04497663af09ac6033253ea43e12935fb81791b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e65deeffb7205dc20b70fdfbce51bc6b381f0db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e65deeffb7205dc20b70fdfbce51bc6b381f0db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e65deeffb7205dc20b70fdfbce51bc6b381f0db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e65deeffb7205dc20b70fdfbce51bc6b381f0db/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d069df01eda5094cb2c934a7e1567219ba36e511", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d069df01eda5094cb2c934a7e1567219ba36e511", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d069df01eda5094cb2c934a7e1567219ba36e511"}], "stats": {"total": 236, "additions": 231, "deletions": 5}, "files": [{"sha": "232a7d6546dbd2f211df00d282924433169e10f1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e65deeffb7205dc20b70fdfbce51bc6b381f0db/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e65deeffb7205dc20b70fdfbce51bc6b381f0db/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4e65deeffb7205dc20b70fdfbce51bc6b381f0db", "patch": "@@ -1,3 +1,22 @@\n+2019-05-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* omp-low.c (lower_rec_input_clauses): If OMP_CLAUSE_IF\n+\thas non-constant expression, force sctx.lane and use two\n+\targument IFN_GOMP_SIMD_LANE instead of single argument.\n+\t* tree-ssa-dce.c (eliminate_unnecessary_stmts): Don't DCE\n+\ttwo argument IFN_GOMP_SIMD_LANE without lhs.\n+\t* tree-vectorizer.h (struct _loop_vec_info): Add simd_if_cond\n+\tmember.\n+\t(LOOP_VINFO_SIMD_IF_COND, LOOP_REQUIRES_VERSIONING_FOR_SIMD_IF_COND):\n+\tDefine.\n+\t(LOOP_REQUIRES_VERSIONING): Or in\n+\tLOOP_REQUIRES_VERSIONING_FOR_SIMD_IF_COND.\n+\t* tree-vect-loop.c (_loop_vec_info::_loop_vec_info): Initialize\n+\tsimd_if_cond.\n+\t(vect_analyze_loop_2): Punt if LOOP_VINFO_SIMD_IF_COND is constant 0.\n+\t* tree-vect-loop-manip.c (vect_loop_versioning): Add runtime check\n+\tfrom simd if clause if needed.\n+\n 2019-05-16  Richard Biener  <rguenther@suse.de>\n \n \t* tree-affine.c (expr_to_aff_combination): New function split"}, {"sha": "04fc5f6aaa8ec492c98e96eb425507f37b1ee563", "filename": "gcc/omp-low.c", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e65deeffb7205dc20b70fdfbce51bc6b381f0db/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e65deeffb7205dc20b70fdfbce51bc6b381f0db/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=4e65deeffb7205dc20b70fdfbce51bc6b381f0db", "patch": "@@ -3783,6 +3783,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n   tree simt_lane = NULL_TREE, simtrec = NULL_TREE;\n   tree ivar = NULL_TREE, lvar = NULL_TREE, uid = NULL_TREE;\n   gimple_seq llist[3] = { };\n+  tree nonconst_simd_if = NULL_TREE;\n \n   copyin_seq = NULL;\n   sctx.is_simt = is_simd && omp_find_clause (clauses, OMP_CLAUSE__SIMT_);\n@@ -3814,6 +3815,8 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \tcase OMP_CLAUSE_IF:\n \t  if (integer_zerop (OMP_CLAUSE_IF_EXPR (c)))\n \t    sctx.max_vf = 1;\n+\t  else if (TREE_CODE (OMP_CLAUSE_IF_EXPR (c)) != INTEGER_CST)\n+\t    nonconst_simd_if = OMP_CLAUSE_IF_EXPR (c);\n \t  break;\n         case OMP_CLAUSE_SIMDLEN:\n \t  if (integer_onep (OMP_CLAUSE_SIMDLEN_EXPR (c)))\n@@ -5190,6 +5193,17 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n   if (known_eq (sctx.max_vf, 1U))\n     sctx.is_simt = false;\n \n+  if (nonconst_simd_if)\n+    {\n+      if (sctx.lane == NULL_TREE)\n+\t{\n+\t  sctx.idx = create_tmp_var (unsigned_type_node);\n+\t  sctx.lane = create_tmp_var (unsigned_type_node);\n+\t}\n+      /* FIXME: For now.  */\n+      sctx.is_simt = false;\n+    }\n+\n   if (sctx.lane || sctx.is_simt)\n     {\n       uid = create_tmp_var (ptr_type_node, \"simduid\");\n@@ -5219,8 +5233,9 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n     }\n   if (sctx.lane)\n     {\n-      gimple *g\n-\t= gimple_build_call_internal (IFN_GOMP_SIMD_LANE, 1, uid);\n+      gimple *g = gimple_build_call_internal (IFN_GOMP_SIMD_LANE,\n+\t\t\t\t\t      1 + (nonconst_simd_if != NULL),\n+\t\t\t\t\t      uid, nonconst_simd_if);\n       gimple_call_set_lhs (g, sctx.lane);\n       gimple_stmt_iterator gsi = gsi_start_1 (gimple_omp_body_ptr (ctx->stmt));\n       gsi_insert_before_without_update (&gsi, g, GSI_SAME_STMT);"}, {"sha": "c352cebe46e39fa9daf7f8a8edde03ad01bf2107", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e65deeffb7205dc20b70fdfbce51bc6b381f0db/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e65deeffb7205dc20b70fdfbce51bc6b381f0db/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4e65deeffb7205dc20b70fdfbce51bc6b381f0db", "patch": "@@ -1,3 +1,10 @@\n+2019-05-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.dg/vect/vect-simd-1.c: New test.\n+\t* gcc.dg/vect/vect-simd-2.c: New test.\n+\t* gcc.dg/vect/vect-simd-3.c: New test.\n+\t* gcc.dg/vect/vect-simd-4.c: New test.\n+\n 2019-05-16  Martin Liska  <mliska@suse.cz>\n \n \tPR lto/90500"}, {"sha": "7c3feeeffae363b8ad42989a3569ca394519a414", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-1.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e65deeffb7205dc20b70fdfbce51bc6b381f0db/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e65deeffb7205dc20b70fdfbce51bc6b381f0db/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-1.c?ref=4e65deeffb7205dc20b70fdfbce51bc6b381f0db", "patch": "@@ -0,0 +1,64 @@\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+#include \"tree-vect.h\"\n+\n+#define N 1024\n+int a[N];\n+int x;\n+\n+__attribute__((noipa)) int\n+bar (void)\n+{\n+  return x;\n+}\n+\n+__attribute__((noipa)) void\n+foo (void)\n+{\n+  #pragma omp simd if (bar ())\n+  for (int i = 0; i < N; ++i)\n+    a[i] = a[i] + 1;\n+}\n+\n+__attribute__((noipa)) void\n+baz (void)\n+{\n+  int c = 0;\n+  #pragma omp simd if (c)\n+  for (int i = 0; i < N; ++i)\n+    a[i] = a[i] + 1;\n+}\n+\n+__attribute__((noipa)) void\n+qux (void)\n+{\n+  int c = 1;\n+  #pragma omp simd if (c)\n+  for (int i = 0; i < N; ++i)\n+    a[i] = a[i] + 1;\n+}\n+\n+int\n+main ()\n+{\n+  check_vect ();\n+  foo ();\n+  for (int i = 0; i < N; ++i)\n+    if (a[i] != 1)\n+      abort ();\n+  x = 1;\n+  foo ();\n+  for (int i = 0; i < N; ++i)\n+    if (a[i] != 2)\n+      abort ();\n+  baz ();\n+  for (int i = 0; i < N; ++i)\n+    if (a[i] != 3)\n+      abort ();\n+  qux ();\n+  for (int i = 0; i < N; ++i)\n+    if (a[i] != 4)\n+      abort ();\n+  return 0;\n+}"}, {"sha": "42bb782a8015ad4dadae1696e2669a8ba43892a0", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-2.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e65deeffb7205dc20b70fdfbce51bc6b381f0db/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e65deeffb7205dc20b70fdfbce51bc6b381f0db/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-2.c?ref=4e65deeffb7205dc20b70fdfbce51bc6b381f0db", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+\n+#define N 1024\n+int a[N];\n+int bar (void);\n+\n+void\n+foo (void)\n+{\n+  #pragma omp simd if (bar ())\n+  for (int i = 0; i < N; ++i)\n+    a[i] = a[i] + 1;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"created versioning for simd if condition check\" 1 \"vect\" } } */"}, {"sha": "ff7f0dcc7a416546580353f7d12d76987204bf7f", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-3.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e65deeffb7205dc20b70fdfbce51bc6b381f0db/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e65deeffb7205dc20b70fdfbce51bc6b381f0db/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-3.c?ref=4e65deeffb7205dc20b70fdfbce51bc6b381f0db", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+\n+#define N 1024\n+int a[N];\n+\n+void\n+foo (void)\n+{\n+  int c = 0;\n+  #pragma omp simd if (c)\n+  for (int i = 0; i < N; ++i)\n+    a[i] = a[i] + 1;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\" } } */"}, {"sha": "b78b7b1dbe1bb686aab02aecf27ae877d8aeacde", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-4.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e65deeffb7205dc20b70fdfbce51bc6b381f0db/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e65deeffb7205dc20b70fdfbce51bc6b381f0db/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-4.c?ref=4e65deeffb7205dc20b70fdfbce51bc6b381f0db", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+\n+#define N 1024\n+int a[N];\n+\n+void\n+foo (void)\n+{\n+  int c = 1;\n+  #pragma omp simd if (c)\n+  for (int i = 0; i < N; ++i)\n+    a[i] = a[i] + 1;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-not \"created versioning for simd if condition check\" \"vect\" } } */"}, {"sha": "2478219d8737d9e95fbc7eab47a56e8b6a86aa4d", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e65deeffb7205dc20b70fdfbce51bc6b381f0db/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e65deeffb7205dc20b70fdfbce51bc6b381f0db/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=4e65deeffb7205dc20b70fdfbce51bc6b381f0db", "patch": "@@ -1328,12 +1328,16 @@ eliminate_unnecessary_stmts (void)\n \t\t  update_stmt (stmt);\n \t\t  release_ssa_name (name);\n \n-\t\t  /* GOMP_SIMD_LANE or ASAN_POISON without lhs is not\n-\t\t     needed.  */\n+\t\t  /* GOMP_SIMD_LANE (unless two argument) or ASAN_POISON\n+\t\t     without lhs is not needed.  */\n \t\t  if (gimple_call_internal_p (stmt))\n \t\t    switch (gimple_call_internal_fn (stmt))\n \t\t      {\n \t\t      case IFN_GOMP_SIMD_LANE:\n+\t\t\tif (gimple_call_num_args (stmt) >= 2\n+\t\t\t    && !integer_nonzerop (gimple_call_arg (stmt, 1)))\n+\t\t\t  break;\n+\t\t\t/* FALLTHRU */\n \t\t      case IFN_ASAN_POISON:\n \t\t\tremove_dead_stmt (&gsi, bb, to_remove_edges);\n \t\t\tbreak;"}, {"sha": "b3fae5ba4dacdd1bed8ec082d1cf2e002fc5bda7", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e65deeffb7205dc20b70fdfbce51bc6b381f0db/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e65deeffb7205dc20b70fdfbce51bc6b381f0db/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=4e65deeffb7205dc20b70fdfbce51bc6b381f0db", "patch": "@@ -3009,6 +3009,8 @@ vect_loop_versioning (loop_vec_info loop_vinfo,\n   bool version_align = LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT (loop_vinfo);\n   bool version_alias = LOOP_REQUIRES_VERSIONING_FOR_ALIAS (loop_vinfo);\n   bool version_niter = LOOP_REQUIRES_VERSIONING_FOR_NITERS (loop_vinfo);\n+  tree version_simd_if_cond\n+    = LOOP_REQUIRES_VERSIONING_FOR_SIMD_IF_COND (loop_vinfo);\n \n   if (check_profitability)\n     cond_expr = fold_build2 (GE_EXPR, boolean_type_node, scalar_loop_iters,\n@@ -3044,6 +3046,31 @@ vect_loop_versioning (loop_vec_info loop_vinfo,\n       vect_create_cond_for_alias_checks (loop_vinfo, &cond_expr);\n     }\n \n+  if (version_simd_if_cond)\n+    {\n+      gcc_assert (dom_info_available_p (CDI_DOMINATORS));\n+      if (flag_checking)\n+\tif (basic_block bb\n+\t    = gimple_bb (SSA_NAME_DEF_STMT (version_simd_if_cond)))\n+\t  gcc_assert (bb != loop->header\n+\t\t      && dominated_by_p (CDI_DOMINATORS, loop->header, bb)\n+\t\t      && (scalar_loop == NULL\n+\t\t\t  || (bb != scalar_loop->header\n+\t\t\t      && dominated_by_p (CDI_DOMINATORS,\n+\t\t\t\t\t\t scalar_loop->header, bb))));\n+      tree zero = build_zero_cst (TREE_TYPE (version_simd_if_cond));\n+      tree c = fold_build2 (NE_EXPR, boolean_type_node,\n+\t\t\t    version_simd_if_cond, zero);\n+      if (cond_expr)\n+        cond_expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t c, cond_expr);\n+      else\n+        cond_expr = c;\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"created versioning for simd if condition check.\\n\");\n+    }\n+\n   cond_expr = force_gimple_operand_1 (unshare_expr (cond_expr),\n \t\t\t\t      &gimplify_stmt_list,\n \t\t\t\t      is_gimple_condexpr, NULL_TREE);"}, {"sha": "57764176df003517dbcf6b8eabf650e6693ede7f", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e65deeffb7205dc20b70fdfbce51bc6b381f0db/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e65deeffb7205dc20b70fdfbce51bc6b381f0db/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=4e65deeffb7205dc20b70fdfbce51bc6b381f0db", "patch": "@@ -819,6 +819,7 @@ _loop_vec_info::_loop_vec_info (struct loop *loop_in, vec_info_shared *shared)\n     max_vectorization_factor (0),\n     mask_skip_niters (NULL_TREE),\n     mask_compare_type (NULL_TREE),\n+    simd_if_cond (NULL_TREE),\n     unaligned_dr (NULL),\n     peeling_for_alignment (0),\n     ptr_mask (0),\n@@ -862,6 +863,26 @@ _loop_vec_info::_loop_vec_info (struct loop *loop_in, vec_info_shared *shared)\n \t  gimple *stmt = gsi_stmt (si);\n \t  gimple_set_uid (stmt, 0);\n \t  add_stmt (stmt);\n+\t  /* If .GOMP_SIMD_LANE call for the current loop has 2 arguments, the\n+\t     second argument is the #pragma omp simd if (x) condition, when 0,\n+\t     loop shouldn't be vectorized, when non-zero constant, it should\n+\t     be vectorized normally, otherwise versioned with vectorized loop\n+\t     done if the condition is non-zero at runtime.  */\n+\t  if (loop_in->simduid\n+\t      && is_gimple_call (stmt)\n+\t      && gimple_call_internal_p (stmt)\n+\t      && gimple_call_internal_fn (stmt) == IFN_GOMP_SIMD_LANE\n+\t      && gimple_call_num_args (stmt) >= 2\n+\t      && TREE_CODE (gimple_call_arg (stmt, 0)) == SSA_NAME\n+\t      && (loop_in->simduid\n+\t\t  == SSA_NAME_VAR (gimple_call_arg (stmt, 0))))\n+\t    {\n+\t      tree arg = gimple_call_arg (stmt, 1);\n+\t      if (integer_zerop (arg) || TREE_CODE (arg) == SSA_NAME)\n+\t\tsimd_if_cond = arg;\n+\t      else\n+\t\tgcc_assert (integer_nonzerop (arg));\n+\t    }\n \t}\n     }\n }\n@@ -1769,6 +1790,11 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n   /* The first group of checks is independent of the vector size.  */\n   fatal = true;\n \n+  if (LOOP_VINFO_SIMD_IF_COND (loop_vinfo)\n+      && integer_zerop (LOOP_VINFO_SIMD_IF_COND (loop_vinfo)))\n+    return opt_result::failure_at (vect_location,\n+\t\t\t\t   \"not vectorized: simd if(0)\\n\");\n+\n   /* Find all data references in the loop (which correspond to vdefs/vuses)\n      and analyze their evolution in the loop.  */\n "}, {"sha": "d5fd4690b1de64604acdb09943aa7028b7b5109e", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e65deeffb7205dc20b70fdfbce51bc6b381f0db/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e65deeffb7205dc20b70fdfbce51bc6b381f0db/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=4e65deeffb7205dc20b70fdfbce51bc6b381f0db", "patch": "@@ -428,6 +428,13 @@ typedef struct _loop_vec_info : public vec_info {\n      loops.  */\n   tree mask_compare_type;\n \n+  /* For #pragma omp simd if (x) loops the x expression.  If constant 0,\n+     the loop should not be vectorized, if constant non-zero, simd_if_cond\n+     shouldn't be set and loop vectorized normally, if SSA_NAME, the loop\n+     should be versioned on that condition, using scalar loop if the condition\n+     is false and vectorized loop otherwise.  */\n+  tree simd_if_cond;\n+\n   /* Unknown DRs according to which loop was peeled.  */\n   struct dr_vec_info *unaligned_dr;\n \n@@ -591,6 +598,7 @@ typedef struct _loop_vec_info : public vec_info {\n #define LOOP_VINFO_SCALAR_ITERATION_COST(L) (L)->scalar_cost_vec\n #define LOOP_VINFO_SINGLE_SCALAR_ITERATION_COST(L) (L)->single_scalar_iteration_cost\n #define LOOP_VINFO_ORIG_LOOP_INFO(L)       (L)->orig_loop_info\n+#define LOOP_VINFO_SIMD_IF_COND(L)         (L)->simd_if_cond\n \n #define LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT(L)\t\\\n   ((L)->may_misalign_stmts.length () > 0)\n@@ -600,10 +608,13 @@ typedef struct _loop_vec_info : public vec_info {\n    || (L)->lower_bounds.length () > 0)\n #define LOOP_REQUIRES_VERSIONING_FOR_NITERS(L)\t\t\\\n   (LOOP_VINFO_NITERS_ASSUMPTIONS (L))\n+#define LOOP_REQUIRES_VERSIONING_FOR_SIMD_IF_COND(L)\t\\\n+  (LOOP_VINFO_SIMD_IF_COND (L))\n #define LOOP_REQUIRES_VERSIONING(L)\t\t\t\\\n   (LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT (L)\t\t\\\n    || LOOP_REQUIRES_VERSIONING_FOR_ALIAS (L)\t\t\\\n-   || LOOP_REQUIRES_VERSIONING_FOR_NITERS (L))\n+   || LOOP_REQUIRES_VERSIONING_FOR_NITERS (L)\t\t\\\n+   || LOOP_REQUIRES_VERSIONING_FOR_SIMD_IF_COND (L))\n \n #define LOOP_VINFO_NITERS_KNOWN_P(L)          \\\n   (tree_fits_shwi_p ((L)->num_iters) && tree_to_shwi ((L)->num_iters) > 0)"}]}