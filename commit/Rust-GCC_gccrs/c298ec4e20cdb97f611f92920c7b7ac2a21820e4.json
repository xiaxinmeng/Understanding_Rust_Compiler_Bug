{"sha": "c298ec4e20cdb97f611f92920c7b7ac2a21820e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI5OGVjNGUyMGNkYjk3ZjYxMWY5MjkyMGM3YjdhYzJhMjE4MjBlNA==", "commit": {"author": {"name": "James A. Morrison", "email": "phython@gcc.gnu.org", "date": "2005-09-18T19:10:15Z"}, "committer": {"name": "James A. Morrison", "email": "phython@gcc.gnu.org", "date": "2005-09-18T19:10:15Z"}, "message": "builtins.c (max_builtin, [...]): Use fold_buildN.\n\n2005-09-18  James A. Morrison  <phython@gcc.gnu.org>\n\n        * builtins.c (max_builtin, min_builtin, abs_builtin,\n        java_build_function_call_expr): Use fold_buildN.\n        * class.c (layout_class_method): Likewise.\n        * expr.c (java_truthvalue_conversion, build_java_jsr,\n        build_java_arrayaccess, expand_java_arrayload, expand_iinc,\n        build_java_binop, build_field_ref, expand_compare,\n        build_known_method_ref, build_invokevirtual,\n        process_jvm_instruction): Likewise.\n        * parse.y (patch_binop, patch_exit_expr): Likewise.\n        * typeck.c (convert_ieee_real_to_integer): Likewise.\n        (convert): Don't call fold after convert_ieee_real_to_integer.\n\nFrom-SVN: r104407", "tree": {"sha": "7a0442d15d00052dffd5178ca24bfb40f1386122", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a0442d15d00052dffd5178ca24bfb40f1386122"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c298ec4e20cdb97f611f92920c7b7ac2a21820e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c298ec4e20cdb97f611f92920c7b7ac2a21820e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c298ec4e20cdb97f611f92920c7b7ac2a21820e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c298ec4e20cdb97f611f92920c7b7ac2a21820e4/comments", "author": null, "committer": null, "parents": [{"sha": "2c05c0dad5f65ca5e17cfd16429d686fada2221c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c05c0dad5f65ca5e17cfd16429d686fada2221c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c05c0dad5f65ca5e17cfd16429d686fada2221c"}], "stats": {"total": 173, "additions": 92, "deletions": 81}, "files": [{"sha": "b6299790f076cb536a5af44af85e9054797194c1", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c298ec4e20cdb97f611f92920c7b7ac2a21820e4/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c298ec4e20cdb97f611f92920c7b7ac2a21820e4/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=c298ec4e20cdb97f611f92920c7b7ac2a21820e4", "patch": "@@ -1,3 +1,17 @@\n+2005-09-18  James A. Morrison  <phython@gcc.gnu.org>\n+\n+\t* builtins.c (max_builtin, min_builtin, abs_builtin,\n+\tjava_build_function_call_expr): Use fold_buildN.\n+\t* class.c (layout_class_method): Likewise.\n+\t* expr.c (java_truthvalue_conversion, build_java_jsr,\n+\tbuild_java_arrayaccess, expand_java_arrayload, expand_iinc,\n+\tbuild_java_binop, build_field_ref, expand_compare,\n+\tbuild_known_method_ref, build_invokevirtual,\n+\tprocess_jvm_instruction): Likewise.\n+\t* parse.y (patch_binop, patch_exit_expr): Likewise.\n+\t* typeck.c (convert_ieee_real_to_integer): Likewise.\n+\t(convert): Don't call fold after convert_ieee_real_to_integer.\n+\n 2005-09-14  Bryce McKinlay  <mckinlay@redhat.com>\n \n \tPR java/23891"}, {"sha": "2ea9e5787848caf909128231d5e8b14c82ee6453", "filename": "gcc/java/builtins.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c298ec4e20cdb97f611f92920c7b7ac2a21820e4/gcc%2Fjava%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c298ec4e20cdb97f611f92920c7b7ac2a21820e4/gcc%2Fjava%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fbuiltins.c?ref=c298ec4e20cdb97f611f92920c7b7ac2a21820e4", "patch": "@@ -94,24 +94,24 @@ static GTY(()) struct builtin_record java_builtins[] =\n static tree\n max_builtin (tree method_return_type, tree method_arguments)\n {\n-  return fold (build2 (MAX_EXPR, method_return_type,\n-\t\t       TREE_VALUE (method_arguments),\n-\t\t       TREE_VALUE (TREE_CHAIN (method_arguments))));\n+  return fold_build2 (MAX_EXPR, method_return_type,\n+\t\t      TREE_VALUE (method_arguments),\n+\t\t      TREE_VALUE (TREE_CHAIN (method_arguments)));\n }\n \n static tree\n min_builtin (tree method_return_type, tree method_arguments)\n {\n-  return fold (build2 (MIN_EXPR, method_return_type,\n-\t\t       TREE_VALUE (method_arguments),\n-\t\t       TREE_VALUE (TREE_CHAIN (method_arguments))));\n+  return fold_build2 (MIN_EXPR, method_return_type,\n+\t\t      TREE_VALUE (method_arguments),\n+\t\t      TREE_VALUE (TREE_CHAIN (method_arguments)));\n }\n \n static tree\n abs_builtin (tree method_return_type, tree method_arguments)\n {\n-  return fold (build1 (ABS_EXPR, method_return_type,\n-\t\t       TREE_VALUE (method_arguments)));\n+  return fold_build1 (ABS_EXPR, method_return_type,\n+\t\t      TREE_VALUE (method_arguments));\n }\n \n /* Mostly copied from ../builtins.c.  */\n@@ -121,10 +121,8 @@ java_build_function_call_expr (tree fn, tree arglist)\n   tree call_expr;\n \n   call_expr = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (fn)), fn);\n-  call_expr = build3 (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n+  return fold_build3 (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n \t\t      call_expr, arglist, NULL_TREE);\n-  TREE_SIDE_EFFECTS (call_expr) = 1;\n-  return fold (call_expr);\n }\n \n \f"}, {"sha": "47ae3368363968a5588fda26669e93995a86e12f", "filename": "gcc/java/class.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c298ec4e20cdb97f611f92920c7b7ac2a21820e4/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c298ec4e20cdb97f611f92920c7b7ac2a21820e4/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=c298ec4e20cdb97f611f92920c7b7ac2a21820e4", "patch": "@@ -2380,8 +2380,8 @@ layout_class_method (tree this_class, tree super_class,\n \t  /* We generate vtable entries for final methods because they\n \t     may one day be changed to non-final.  */\n \t  set_method_index (method_decl, dtable_count);\n-\t  dtable_count = fold (build2 (PLUS_EXPR, integer_type_node,\n-\t\t\t\t       dtable_count, integer_one_node));\n+\t  dtable_count = fold_build2 (PLUS_EXPR, integer_type_node,\n+\t\t\t\t      dtable_count, integer_one_node);\n \t}\n     }\n "}, {"sha": "a21e1513d6e75539f99fe60b0bff216bd7b0a319", "filename": "gcc/java/expr.c", "status": "modified", "additions": 46, "deletions": 47, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c298ec4e20cdb97f611f92920c7b7ac2a21820e4/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c298ec4e20cdb97f611f92920c7b7ac2a21820e4/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=c298ec4e20cdb97f611f92920c7b7ac2a21820e4", "patch": "@@ -192,10 +192,9 @@ java_truthvalue_conversion (tree expr)\n \n     case COND_EXPR:\n       /* Distribute the conversion into the arms of a COND_EXPR.  */\n-      return fold\n-\t       (build3 (COND_EXPR, boolean_type_node, TREE_OPERAND (expr, 0),\n-\t\t\tjava_truthvalue_conversion (TREE_OPERAND (expr, 1)),\n-\t\t\tjava_truthvalue_conversion (TREE_OPERAND (expr, 2))));\n+      return fold_build3 (COND_EXPR, boolean_type_node, TREE_OPERAND (expr, 0),\n+\t\t\t  java_truthvalue_conversion (TREE_OPERAND (expr, 1)),\n+\t\t\t  java_truthvalue_conversion (TREE_OPERAND (expr, 2)));\n \n     case NOP_EXPR:\n       /* If this is widening the argument, we can ignore it.  */\n@@ -205,8 +204,8 @@ java_truthvalue_conversion (tree expr)\n       /* fall through to default */\n \n     default:\n-      return fold (build2 (NE_EXPR, boolean_type_node,\n-\t\t\t   expr, boolean_false_node));\n+      return fold_build2 (NE_EXPR, boolean_type_node,\n+\t\t\t  expr, boolean_false_node);\n     }\n }\n \n@@ -729,7 +728,7 @@ build_java_jsr (int target_pc, int return_pc)\n {\n   tree where =  lookup_label (target_pc);\n   tree ret = lookup_label (return_pc);\n-  tree ret_label = fold (build1 (ADDR_EXPR, return_address_type_node, ret));\n+  tree ret_label = fold_build1 (ADDR_EXPR, return_address_type_node, ret);\n   push_value (ret_label);\n   flush_quick_stack ();\n   java_add_stmt (build1 (GOTO_EXPR, void_type_node, where));\n@@ -896,9 +895,9 @@ build_java_arrayaccess (tree array, tree type, tree index)\n       tree test;\n       tree len = convert (unsigned_int_type_node,\n \t\t\t  build_java_array_length_access (array));\n-      test = fold (build2 (GE_EXPR, boolean_type_node, \n-\t\t\t   convert (unsigned_int_type_node, index),\n-\t\t\t   len));\n+      test = fold_build2 (GE_EXPR, boolean_type_node, \n+\t\t\t  convert (unsigned_int_type_node, index),\n+\t\t\t  len);\n       if (! integer_zerop (test))\n \t{\n \t  throw = build2 (TRUTH_ANDIF_EXPR, int_type_node, test,\n@@ -1190,7 +1189,7 @@ expand_java_arrayload (tree lhs_type_node)\n \t\t\t\t      lhs_type_node,\n \t\t\t\t      index_node);\n   if (INTEGRAL_TYPE_P (lhs_type_node) && TYPE_PRECISION (lhs_type_node) <= 32)\n-    load_node = fold (build1 (NOP_EXPR, int_type_node, load_node));\n+    load_node = fold_build1 (NOP_EXPR, int_type_node, load_node);\n   push_value (load_node);\n }\n \n@@ -1451,7 +1450,7 @@ expand_iinc (unsigned int local_var_index, int ival, int pc)\n   flush_quick_stack ();\n   local_var = find_local_variable (local_var_index, int_type_node, pc);\n   constant_value = build_int_cst (NULL_TREE, ival);\n-  res = fold (build2 (PLUS_EXPR, int_type_node, local_var, constant_value));\n+  res = fold_build2 (PLUS_EXPR, int_type_node, local_var, constant_value);\n   java_add_stmt (build2 (MODIFY_EXPR, TREE_TYPE (local_var), local_var, res));\n   update_aliases (local_var, local_var_index, pc);\n }\n@@ -1522,36 +1521,36 @@ build_java_binop (enum tree_code op, tree type, tree arg1, tree arg2)\n     case RSHIFT_EXPR:\n       mask = build_int_cst (NULL_TREE,\n \t\t\t    TYPE_PRECISION (TREE_TYPE (arg1)) - 1);\n-      arg2 = fold (build2 (BIT_AND_EXPR, int_type_node, arg2, mask));\n+      arg2 = fold_build2 (BIT_AND_EXPR, int_type_node, arg2, mask);\n       break;\n \n     case COMPARE_L_EXPR:  /* arg1 > arg2 ?  1 : arg1 == arg2 ? 0 : -1 */\n     case COMPARE_G_EXPR:  /* arg1 < arg2 ? -1 : arg1 == arg2 ? 0 :  1 */\n       arg1 = save_expr (arg1);  arg2 = save_expr (arg2);\n       {\n-\ttree ifexp1 = fold (build2 (op == COMPARE_L_EXPR ? GT_EXPR : LT_EXPR,\n-\t\t\t\t    boolean_type_node, arg1, arg2));\n-\ttree ifexp2 = fold (build2 (EQ_EXPR, boolean_type_node, arg1, arg2));\n-\ttree second_compare = fold (build3 (COND_EXPR, int_type_node,\n-\t\t\t\t\t    ifexp2, integer_zero_node,\n-\t\t\t\t\t    op == COMPARE_L_EXPR\n-\t\t\t\t\t    ? integer_minus_one_node\n-\t\t\t\t\t    : integer_one_node));\n-\treturn fold (build3 (COND_EXPR, int_type_node, ifexp1,\n-\t\t\t     op == COMPARE_L_EXPR ? integer_one_node\n-\t\t\t     : integer_minus_one_node,\n-\t\t\t     second_compare));\n+\ttree ifexp1 = fold_build2 (op == COMPARE_L_EXPR ? GT_EXPR : LT_EXPR,\n+\t\t\t\t   boolean_type_node, arg1, arg2);\n+\ttree ifexp2 = fold_build2 (EQ_EXPR, boolean_type_node, arg1, arg2);\n+\ttree second_compare = fold_build3 (COND_EXPR, int_type_node,\n+\t\t\t\t\t   ifexp2, integer_zero_node,\n+\t\t\t\t\t   op == COMPARE_L_EXPR\n+\t\t\t\t\t   ? integer_minus_one_node\n+\t\t\t\t\t   : integer_one_node);\n+\treturn fold_build3 (COND_EXPR, int_type_node, ifexp1,\n+\t\t\t    op == COMPARE_L_EXPR ? integer_one_node\n+\t\t\t    : integer_minus_one_node,\n+\t\t\t    second_compare);\n       }\n     case COMPARE_EXPR:\n       arg1 = save_expr (arg1);  arg2 = save_expr (arg2);\n       {\n-\ttree ifexp1 = fold (build2 (LT_EXPR, boolean_type_node, arg1, arg2));\n-\ttree ifexp2 = fold (build2 (GT_EXPR, boolean_type_node, arg1, arg2));\n-\ttree second_compare = fold (build3 (COND_EXPR, int_type_node,\n-\t\t\t\t\t    ifexp2, integer_one_node,\n-\t\t\t\t\t    integer_zero_node));\n-\treturn fold (build3 (COND_EXPR, int_type_node,\n-\t\t\t     ifexp1, integer_minus_one_node, second_compare));\n+\ttree ifexp1 = fold_build2 (LT_EXPR, boolean_type_node, arg1, arg2);\n+\ttree ifexp2 = fold_build2 (GT_EXPR, boolean_type_node, arg1, arg2);\n+\ttree second_compare = fold_build3 (COND_EXPR, int_type_node,\n+\t\t\t\t\t   ifexp2, integer_one_node,\n+\t\t\t\t\t   integer_zero_node);\n+\treturn fold_build3 (COND_EXPR, int_type_node,\n+\t\t\t    ifexp1, integer_minus_one_node, second_compare);\n       }      \n     case TRUNC_DIV_EXPR:\n     case TRUNC_MOD_EXPR:\n@@ -1582,7 +1581,7 @@ build_java_binop (enum tree_code op, tree type, tree arg1, tree arg2)\n       break;\n     default:  ;\n     }\n-  return fold (build2 (op, type, arg1, arg2));\n+  return fold_build2 (op, type, arg1, arg2);\n }\n \n static void\n@@ -1692,7 +1691,7 @@ build_field_ref (tree self_value, tree self_class, tree name)\n \n       tree base_type = promote_type (base_class);\n       if (base_type != TREE_TYPE (self_value))\n-\tself_value = fold (build1 (NOP_EXPR, base_type, self_value));\n+\tself_value = fold_build1 (NOP_EXPR, base_type, self_value);\n       if (! flag_syntax_only && flag_indirect_dispatch)\n \t{\n \t  tree otable_index\n@@ -1706,16 +1705,16 @@ build_field_ref (tree self_value, tree self_class, tree name)\n \n \t  field_offset = fold (convert (sizetype, field_offset));\n \t  address \n-\t    = fold (build2 (PLUS_EXPR, \n-\t\t\t    build_pointer_type (TREE_TYPE (field_decl)),\n-\t\t\t    self_value, field_offset));\n-\t  return fold (build1 (INDIRECT_REF, TREE_TYPE (field_decl), address));\n+\t    = fold_build2 (PLUS_EXPR, \n+\t\t\t   build_pointer_type (TREE_TYPE (field_decl)),\n+\t\t\t   self_value, field_offset);\n+\t  return fold_build1 (INDIRECT_REF, TREE_TYPE (field_decl), address);\n \t}\n \n       self_value = build_java_indirect_ref (TREE_TYPE (TREE_TYPE (self_value)),\n \t\t\t\t\t    self_value, check);\n-      return fold (build3 (COMPONENT_REF, TREE_TYPE (field_decl),\n-\t\t\t   self_value, field_decl, NULL_TREE));\n+      return fold_build3 (COMPONENT_REF, TREE_TYPE (field_decl),\n+\t\t\t  self_value, field_decl, NULL_TREE);\n     }\n }\n \n@@ -1781,7 +1780,7 @@ expand_compare (enum tree_code condition, tree value1, tree value2,\n \t\tint target_pc)\n {\n   tree target = lookup_label (target_pc);\n-  tree cond = fold (build2 (condition, boolean_type_node, value1, value2));\n+  tree cond = fold_build2 (condition, boolean_type_node, value1, value2);\n   java_add_stmt \n     (build3 (COND_EXPR, void_type_node, java_truthvalue_conversion (cond),\n \t     build1 (GOTO_EXPR, void_type_node, target), \n@@ -2061,8 +2060,8 @@ build_known_method_ref (tree method, tree method_type ATTRIBUTE_UNUSED,\n \t  method_index++;\n \t}\n       method_index *= int_size_in_bytes (method_type_node);\n-      ref = fold (build2 (PLUS_EXPR, method_ptr_type_node,\n-\t\t\t  ref, build_int_cst (NULL_TREE, method_index)));\n+      ref = fold_build2 (PLUS_EXPR, method_ptr_type_node,\n+\t\t\t ref, build_int_cst (NULL_TREE, method_index));\n       ref = build1 (INDIRECT_REF, method_type_node, ref);\n       func = build3 (COMPONENT_REF, nativecode_ptr_type_node,\n \t\t     ref, lookup_field (&method_type_node, ncode_ident),\n@@ -2165,8 +2164,8 @@ build_invokevirtual (tree dtable, tree method)\n \t\t\t\t   size_int (TARGET_VTABLE_USES_DESCRIPTORS));\n     }\n \n-  func = fold (build2 (PLUS_EXPR, nativecode_ptr_ptr_type_node, dtable,\n-\t\t       convert (nativecode_ptr_ptr_type_node, method_index)));\n+  func = fold_build2 (PLUS_EXPR, nativecode_ptr_ptr_type_node, dtable,\n+\t\t      convert (nativecode_ptr_ptr_type_node, method_index));\n \n   if (TARGET_VTABLE_USES_DESCRIPTORS)\n     func = build1 (NOP_EXPR, nativecode_ptr_type_node, func);\n@@ -3182,8 +3181,8 @@ process_jvm_instruction (int PC, const unsigned char* byte_ops,\n   }\n \n #define UNOP(OPERAND_TYPE, OPERAND_VALUE) \\\n-  push_value (fold (build1 (NEGATE_EXPR, OPERAND_TYPE##_type_node, \\\n-\t\t\t    pop_value (OPERAND_TYPE##_type_node))));\n+  push_value (fold_build1 (NEGATE_EXPR, OPERAND_TYPE##_type_node, \\\n+\t\t\t   pop_value (OPERAND_TYPE##_type_node)));\n \n #define CONVERT2(FROM_TYPE, TO_TYPE)\t\t\t\t\t \\\n   {\t\t\t\t\t\t\t\t\t \\"}, {"sha": "b728554fb92e013d64bb213942a8af662caad52d", "filename": "gcc/java/parse.y", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c298ec4e20cdb97f611f92920c7b7ac2a21820e4/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c298ec4e20cdb97f611f92920c7b7ac2a21820e4/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=c298ec4e20cdb97f611f92920c7b7ac2a21820e4", "patch": "@@ -13643,11 +13643,11 @@ patch_binop (tree node, tree wfl_op1, tree wfl_op2, int folding)\n \n       /* Shift int only up to 0x1f and long up to 0x3f */\n       if (prom_type == int_type_node)\n-\top2 = fold (build2 (BIT_AND_EXPR, int_type_node, op2,\n-\t\t\t    build_int_cst (NULL_TREE, 0x1f)));\n+\top2 = fold_build2 (BIT_AND_EXPR, int_type_node, op2,\n+\t\t\t   build_int_cst (NULL_TREE, 0x1f));\n       else\n-\top2 = fold (build2 (BIT_AND_EXPR, int_type_node, op2,\n-\t\t\t    build_int_cst (NULL_TREE, 0x3f)));\n+\top2 = fold_build2 (BIT_AND_EXPR, int_type_node, op2,\n+\t\t\t   build_int_cst (NULL_TREE, 0x3f));\n \n       /* The >>> operator is a >> operating on unsigned quantities */\n       if (code == URSHIFT_EXPR && (folding || ! flag_emit_class_files))\n@@ -15422,7 +15422,7 @@ patch_exit_expr (tree node)\n   /* Now we know things are allright, invert the condition, fold and\n      return */\n   TREE_OPERAND (node, 0) =\n-    fold (build1 (TRUTH_NOT_EXPR, boolean_type_node, expression));\n+    fold_build1 (TRUTH_NOT_EXPR, boolean_type_node, expression);\n \n   if (! integer_zerop (TREE_OPERAND (node, 0))\n       && ctxp->current_loop != NULL_TREE"}, {"sha": "2bafd84cccaf7649e39a18b3a757123e1d38b226", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c298ec4e20cdb97f611f92920c7b7ac2a21820e4/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c298ec4e20cdb97f611f92920c7b7ac2a21820e4/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=c298ec4e20cdb97f611f92920c7b7ac2a21820e4", "patch": "@@ -83,24 +83,24 @@ convert_ieee_real_to_integer (tree type, tree expr)\n   tree result;\n   expr = save_expr (expr);\n \n-  result = fold (build3 (COND_EXPR, type,\n-\t\t\t fold (build2 (NE_EXPR, boolean_type_node, expr, expr)),\n+  result = fold_build3 (COND_EXPR, type,\n+\t\t\tfold_build2 (NE_EXPR, boolean_type_node, expr, expr),\n \t\t\t convert (type, integer_zero_node),\n-\t\t\t convert_to_integer (type, expr)));\n+\t\t\t convert_to_integer (type, expr));\n   \n-  result = fold (build3 (COND_EXPR, type, \n-\t\t\t fold (build2 (LE_EXPR, boolean_type_node, expr, \n-\t\t\t\t       convert (TREE_TYPE (expr), \n-\t\t\t\t\t\tTYPE_MIN_VALUE (type)))),\n-\t\t\t TYPE_MIN_VALUE (type),\n-\t\t\t result));\n+  result = fold_build3 (COND_EXPR, type, \n+\t\t\tfold_build2 (LE_EXPR, boolean_type_node, expr, \n+\t\t\t\t     convert (TREE_TYPE (expr), \n+\t\t\t\t\t      TYPE_MIN_VALUE (type))),\n+\t\t\tTYPE_MIN_VALUE (type),\n+\t\t\tresult);\n   \n-  result = fold (build3 (COND_EXPR, type,\n-\t\t\t fold (build2 (GE_EXPR, boolean_type_node, expr, \n-\t\t\t\t       convert (TREE_TYPE (expr), \n-\t\t\t\t\t\tTYPE_MAX_VALUE (type)))),\n-\t\t\t TYPE_MAX_VALUE (type),\n-\t\t\t result));\n+  result = fold_build3 (COND_EXPR, type,\n+\t\t\tfold_build2 (GE_EXPR, boolean_type_node, expr, \n+\t\t\t\t     convert (TREE_TYPE (expr), \n+\t\t\t\t\t      TYPE_MAX_VALUE (type))),\n+\t\t\tTYPE_MAX_VALUE (type),\n+\t\t\tresult);\n \n   return result;\n }  \n@@ -135,7 +135,7 @@ convert (tree type, tree expr)\n \t       && ! flag_emit_class_files))\n \t  && TREE_CODE (TREE_TYPE (expr)) == REAL_TYPE\n \t  && TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT)\n-\treturn fold (convert_ieee_real_to_integer (type, expr));\n+\treturn convert_ieee_real_to_integer (type, expr);\n       else\n \t{\n \t  /* fold very helpfully sets the overflow status if a type"}]}