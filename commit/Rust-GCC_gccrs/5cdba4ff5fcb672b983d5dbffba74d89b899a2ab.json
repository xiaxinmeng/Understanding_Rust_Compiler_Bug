{"sha": "5cdba4ff5fcb672b983d5dbffba74d89b899a2ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWNkYmE0ZmY1ZmNiNjcyYjk4M2Q1ZGJmZmJhNzRkODliODk5YTJhYg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2001-05-07T15:45:24Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2001-05-07T15:45:24Z"}, "message": "splay-tree.h (splay_tree_max): New function.\n\n\t* splay-tree.h (splay_tree_max): New function.\n\t(splay_tree_min): Likewise.\n\nFrom-SVN: r41895", "tree": {"sha": "f4070967fe8b5e20c049120c92a27ab4519f2986", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4070967fe8b5e20c049120c92a27ab4519f2986"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5cdba4ff5fcb672b983d5dbffba74d89b899a2ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cdba4ff5fcb672b983d5dbffba74d89b899a2ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cdba4ff5fcb672b983d5dbffba74d89b899a2ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cdba4ff5fcb672b983d5dbffba74d89b899a2ab/comments", "author": null, "committer": null, "parents": [{"sha": "b73bff7e3f78151ef33441bd66e8ac3df12f0b80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b73bff7e3f78151ef33441bd66e8ac3df12f0b80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b73bff7e3f78151ef33441bd66e8ac3df12f0b80"}], "stats": {"total": 98, "additions": 90, "deletions": 8}, "files": [{"sha": "37acdde8e69bcee97e1750a401e5c41e4f5c7195", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cdba4ff5fcb672b983d5dbffba74d89b899a2ab/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cdba4ff5fcb672b983d5dbffba74d89b899a2ab/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5cdba4ff5fcb672b983d5dbffba74d89b899a2ab", "patch": "@@ -1,3 +1,8 @@\n+2001-05-07  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* splay-tree.h (splay_tree_max): New function.\n+\t(splay_tree_min): Likewise.\n+\n 2001-05-03  Geoffrey Keating  <geoffk@redhat.com>\n \n \t* cp-tree.h (enum cp_tree_index): Add CPTI_PFN_VFLAG_IDENTIFIER."}, {"sha": "52c43c38ba37a595faa2af1d02518505e73204e3", "filename": "gcc/cp/class.c", "status": "modified", "additions": 36, "deletions": 7, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cdba4ff5fcb672b983d5dbffba74d89b899a2ab/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cdba4ff5fcb672b983d5dbffba74d89b899a2ab/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=5cdba4ff5fcb672b983d5dbffba74d89b899a2ab", "patch": "@@ -208,7 +208,7 @@ static tree dfs_get_primary_binfo PARAMS ((tree, void*));\n static int record_subobject_offset PARAMS ((tree, tree, splay_tree));\n static int check_subobject_offset PARAMS ((tree, tree, splay_tree));\n static int walk_subobject_offsets PARAMS ((tree, subobject_offset_fn,\n-\t\t\t\t\t   tree, splay_tree, int));\n+\t\t\t\t\t   tree, splay_tree, tree, int));\n static void record_subobject_offsets PARAMS ((tree, tree, splay_tree, int));\n static int layout_conflict_p PARAMS ((tree, tree, splay_tree, int));\n static int splay_tree_compare_integer_csts PARAMS ((splay_tree_key k1,\n@@ -3822,20 +3822,30 @@ check_subobject_offset (type, offset, offsets)\n /* Walk through all the subobjects of TYPE (located at OFFSET).  Call\n    F for every subobject, passing it the type, offset, and table of\n    OFFSETS.  If VBASES_P is non-zero, then even virtual non-primary\n-   bases should be traversed; otherwise, they are ignored.  If F\n-   returns a non-zero value, the traversal ceases, and that value is\n-   returned.  Otherwise, returns zero.  */\n+   bases should be traversed; otherwise, they are ignored.  \n+\n+   If MAX_OFFSET is non-NULL, then subobjects with an offset greater\n+   than MAX_OFFSET will not be walked.\n+\n+   If F returns a non-zero value, the traversal ceases, and that value\n+   is returned.  Otherwise, returns zero.  */\n \n static int\n-walk_subobject_offsets (type, f, offset, offsets, vbases_p)\n+walk_subobject_offsets (type, f, offset, offsets, max_offset, vbases_p)\n      tree type;\n      subobject_offset_fn f;\n      tree offset;\n      splay_tree offsets;\n+     tree max_offset;\n      int vbases_p;\n {\n   int r = 0;\n \n+  /* If this OFFSET is bigger than the MAX_OFFSET, then we should\n+     stop.  */\n+  if (max_offset && INT_CST_LT (max_offset, offset))\n+    return 0;\n+\n   if (CLASS_TYPE_P (type))\n     {\n       tree field;\n@@ -3862,6 +3872,7 @@ walk_subobject_offsets (type, f, offset, offsets, vbases_p)\n \t\t\t\t\t\t  offset,\n \t\t\t\t\t\t  BINFO_OFFSET (binfo)),\n \t\t\t\t      offsets,\n+\t\t\t\t      max_offset,\n \t\t\t\t      vbases_p);\n \t  if (r)\n \t    return r;\n@@ -3877,6 +3888,7 @@ walk_subobject_offsets (type, f, offset, offsets, vbases_p)\n \t\t\t\t\t\t    offset,\n \t\t\t\t\t\t    DECL_FIELD_OFFSET (field)),\n \t\t\t\t\toffsets,\n+\t\t\t\t\tmax_offset,\n \t\t\t\t\t/*vbases_p=*/1);\n \t    if (r)\n \t      return r;\n@@ -3896,11 +3908,17 @@ walk_subobject_offsets (type, f, offset, offsets, vbases_p)\n \t\t\t\t      f,\n \t\t\t\t      offset,\n \t\t\t\t      offsets,\n+\t\t\t\t      max_offset,\n \t\t\t\t      /*vbases_p=*/1);\n \t  if (r)\n \t    return r;\n \t  offset = size_binop (PLUS_EXPR, offset, \n \t\t\t       TYPE_SIZE_UNIT (TREE_TYPE (type)));\n+\t  /* If this new OFFSET is bigger than the MAX_OFFSET, then\n+\t     there's no point in iterating through the remaining\n+\t     elements of the array.  */\n+\t  if (max_offset && INT_CST_LT (max_offset, offset))\n+\t    break;\n \t}\n     }\n \n@@ -3919,7 +3937,7 @@ record_subobject_offsets (type, offset, offsets, vbases_p)\n      int vbases_p;\n {\n   walk_subobject_offsets (type, record_subobject_offset, offset,\n-\t\t\t  offsets, vbases_p);\n+\t\t\t  offsets, /*max_offset=*/NULL_TREE, vbases_p);\n }\n \n /* Returns non-zero if any of the empty subobjects of TYPE (located at\n@@ -3933,8 +3951,19 @@ layout_conflict_p (type, offset, offsets, vbases_p)\n      splay_tree offsets;\n      int vbases_p;\n {\n+  splay_tree_node max_node;\n+\n+  /* Get the node in OFFSETS that indicates the maximum offset where\n+     an empty subobject is located.  */\n+  max_node = splay_tree_max (offsets);\n+  /* If there aren't any empty subobjects, then there's no point in\n+     performing this check.  */\n+  if (!max_node)\n+    return 0;\n+\n   return walk_subobject_offsets (type, check_subobject_offset, offset,\n-\t\t\t\t offsets, vbases_p);\n+\t\t\t\t offsets, (tree) (max_node->key),\n+\t\t\t\t vbases_p);\n }\n \n /* DECL is a FIELD_DECL corresponding either to a base subobject of a"}, {"sha": "e441ba9381498eb4178e1ad9c05e48436053c9d4", "filename": "include/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cdba4ff5fcb672b983d5dbffba74d89b899a2ab/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cdba4ff5fcb672b983d5dbffba74d89b899a2ab/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=5cdba4ff5fcb672b983d5dbffba74d89b899a2ab", "patch": "@@ -1,3 +1,8 @@\n+2001-05-07  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* splay-tree.h (splay_tree_max): New function.\n+\t(splay_tree_min): Likewise.\n+\n 2001-04-15  Daniel Berlin  <dan@cgsoftware.com>\n \n \t* ternary.h: New file - Ternary search tree header."}, {"sha": "37e9a35937f4f03b21ecefa674da355adcfe1ee4", "filename": "include/splay-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cdba4ff5fcb672b983d5dbffba74d89b899a2ab/include%2Fsplay-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cdba4ff5fcb672b983d5dbffba74d89b899a2ab/include%2Fsplay-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fsplay-tree.h?ref=5cdba4ff5fcb672b983d5dbffba74d89b899a2ab", "patch": "@@ -110,6 +110,10 @@ extern splay_tree_node splay_tree_predecessor\n extern splay_tree_node splay_tree_successor\n                                         PARAMS((splay_tree,\n \t\t\t\t\t\tsplay_tree_key));\n+extern splay_tree_node splay_tree_max\n+                                        PARAMS((splay_tree));\n+extern splay_tree_node splay_tree_min\n+                                        PARAMS((splay_tree));\n extern int splay_tree_foreach           PARAMS((splay_tree,\n \t\t\t\t\t        splay_tree_foreach_fn,\n \t\t\t\t\t        void*));"}, {"sha": "9f635430edcb00b914dd280b00cba9bc668494ce", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cdba4ff5fcb672b983d5dbffba74d89b899a2ab/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cdba4ff5fcb672b983d5dbffba74d89b899a2ab/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=5cdba4ff5fcb672b983d5dbffba74d89b899a2ab", "patch": "@@ -1,3 +1,8 @@\n+2001-05-07  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* splay-tree.h (splay_tree_max): New function.\n+\t(splay_tree_min): Likewise.\n+\n 2001-04-15  Daniel Berlin  <dan@cgsoftware.com>\n \n \t* ternary.c: New file - Ternary search tree implementation."}, {"sha": "a71239526717aee4feadbf6432ac15aa8ec58918", "filename": "libiberty/splay-tree.c", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cdba4ff5fcb672b983d5dbffba74d89b899a2ab/libiberty%2Fsplay-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cdba4ff5fcb672b983d5dbffba74d89b899a2ab/libiberty%2Fsplay-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsplay-tree.c?ref=5cdba4ff5fcb672b983d5dbffba74d89b899a2ab", "patch": "@@ -1,5 +1,5 @@\n /* A splay-tree datatype.  \n-   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n    Contributed by Mark Mitchell (mark@markmitchell.com).\n \n This file is part of GNU CC.\n@@ -368,6 +368,40 @@ splay_tree_lookup (sp, key)\n     return 0;\n }\n \n+/* Return the node in SP with the greatest key.  */\n+\n+splay_tree_node\n+splay_tree_max (sp)\n+     splay_tree sp;\n+{\n+  splay_tree_node n = sp->root;\n+\n+  if (!n)\n+    return NULL;\n+\n+  while (n->right)\n+    n = n->right;\n+\n+  return n;\n+}\n+\n+/* Return the node in SP with the smallest key.  */\n+\n+splay_tree_node\n+splay_tree_min (sp)\n+     splay_tree sp;\n+{\n+  splay_tree_node n = sp->root;\n+\n+  if (!n)\n+    return NULL;\n+\n+  while (n->left)\n+    n = n->left;\n+\n+  return n;\n+}\n+\n /* Return the immediate predecessor KEY, or NULL if there is no\n    predecessor.  KEY need not be present in the tree.  */\n "}]}