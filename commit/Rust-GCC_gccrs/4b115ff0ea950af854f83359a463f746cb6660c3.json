{"sha": "4b115ff0ea950af854f83359a463f746cb6660c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGIxMTVmZjBlYTk1MGFmODU0ZjgzMzU5YTQ2M2Y3NDZjYjY2NjBjMw==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-10-14T23:04:13Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-10-14T23:04:13Z"}, "message": "cpplib.c (struct pragma_entry): Store the name as a hashnode.\n\n\t* cpplib.c (struct pragma_entry): Store the name as a hashnode.\n\t(lookup_pragma_entry, insert_pragma_entry, do_pragma,\n\tcpp_register_pragma): Update accordingly.\n\nFrom-SVN: r46255", "tree": {"sha": "14a7ba0c8a56918c072c9ebed2d40886baf5a592", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14a7ba0c8a56918c072c9ebed2d40886baf5a592"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b115ff0ea950af854f83359a463f746cb6660c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b115ff0ea950af854f83359a463f746cb6660c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b115ff0ea950af854f83359a463f746cb6660c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b115ff0ea950af854f83359a463f746cb6660c3/comments", "author": null, "committer": null, "parents": [{"sha": "a5da89c6a82230eedae86e6ccfc829b577037e32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5da89c6a82230eedae86e6ccfc829b577037e32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5da89c6a82230eedae86e6ccfc829b577037e32"}], "stats": {"total": 52, "additions": 26, "deletions": 26}, "files": [{"sha": "d765745266da5a5e01fab0894f8198fbfe9f9991", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b115ff0ea950af854f83359a463f746cb6660c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b115ff0ea950af854f83359a463f746cb6660c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b115ff0ea950af854f83359a463f746cb6660c3", "patch": "@@ -1,3 +1,9 @@\n+2001-10-15  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpplib.c (struct pragma_entry): Store the name as a hashnode.\n+\t(lookup_pragma_entry, insert_pragma_entry, do_pragma,\n+\tcpp_register_pragma): Update accordingly.\n+\n 2001-10-14  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* c-pragma.h (cpp_register_pragma_space): Remove."}, {"sha": "093c9dc806f4a2dc806942cf50387827097083d9", "filename": "gcc/cpplib.c", "status": "modified", "additions": 20, "deletions": 26, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b115ff0ea950af854f83359a463f746cb6660c3/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b115ff0ea950af854f83359a463f746cb6660c3/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=4b115ff0ea950af854f83359a463f746cb6660c3", "patch": "@@ -52,8 +52,7 @@ typedef void (*pragma_cb) PARAMS ((cpp_reader *));\n struct pragma_entry\n {\n   struct pragma_entry *next;\n-  const char *name;\n-  size_t len;\n+  const cpp_hashnode *pragma;\t/* Name and length.  */\n   int is_nspace;\n   union {\n     pragma_cb handler;\n@@ -111,9 +110,10 @@ static void do_diagnostic\tPARAMS ((cpp_reader *, enum error_type, int));\n static cpp_hashnode *lex_macro_node\tPARAMS ((cpp_reader *));\n static void do_include_common\tPARAMS ((cpp_reader *, enum include_type));\n static struct pragma_entry *lookup_pragma_entry\n-  PARAMS ((struct pragma_entry *, const char *pragma));\n+  PARAMS ((struct pragma_entry *, const cpp_hashnode *pragma));\n static struct pragma_entry *insert_pragma_entry\n-  PARAMS ((cpp_reader *, struct pragma_entry **, const char *, pragma_cb));\n+  PARAMS ((cpp_reader *, struct pragma_entry **, const cpp_hashnode *,\n+\t   pragma_cb));\n static void do_pragma_once\tPARAMS ((cpp_reader *));\n static void do_pragma_poison\tPARAMS ((cpp_reader *));\n static void do_pragma_system_header\tPARAMS ((cpp_reader *));\n@@ -866,16 +866,10 @@ do_ident (pfile)\n static struct pragma_entry *\n lookup_pragma_entry (chain, pragma)\n      struct pragma_entry *chain;\n-     const char *pragma;\n+     const cpp_hashnode *pragma;\n {\n-  size_t len = strlen (pragma);\n-\n-  while (chain)\n-    {\n-      if (chain->len == len && !memcmp (chain->name, pragma, len))\n-\tbreak;\n-      chain = chain->next;\n-    }\n+  while (chain && chain->pragma != pragma)\n+    chain = chain->next;\n \n   return chain;\n }\n@@ -884,18 +878,17 @@ lookup_pragma_entry (chain, pragma)\n    singly-linked CHAIN.  If handler is NULL, it is a namespace,\n    otherwise it is a pragma and its handler.  */\n static struct pragma_entry *\n-insert_pragma_entry (pfile, chain, name, handler)\n+insert_pragma_entry (pfile, chain, pragma, handler)\n      cpp_reader *pfile;\n      struct pragma_entry **chain;\n-     const char *name;\n+     const cpp_hashnode *pragma;\n      pragma_cb handler;\n {\n   struct pragma_entry *new;\n \n   new = (struct pragma_entry *)\n     _cpp_aligned_alloc (pfile, sizeof (struct pragma_entry));\n-  new->name = name;\n-  new->len = strlen (name);\n+  new->pragma = pragma;\n   if (handler)\n     {\n       new->is_nspace = 0;\n@@ -924,36 +917,39 @@ cpp_register_pragma (pfile, space, name, handler)\n {\n   struct pragma_entry **chain = &pfile->pragmas;\n   struct pragma_entry *entry;\n+  const cpp_hashnode *node;\n \n   if (!handler)\n     abort ();\n \n   if (space)\n     {\n-      entry = lookup_pragma_entry (*chain, space);\n+      node = cpp_lookup (pfile, U space, strlen (space));\n+      entry = lookup_pragma_entry (*chain, node);\n       if (!entry)\n-\tentry = insert_pragma_entry (pfile, chain, space, NULL);\n+\tentry = insert_pragma_entry (pfile, chain, node, NULL);\n       else if (!entry->is_nspace)\n \tgoto clash;\n       chain = &entry->u.space;\n     }\n \n   /* Check for duplicates.  */\n-  entry = lookup_pragma_entry (*chain, name);\n+  node = cpp_lookup (pfile, U name, strlen (name));\n+  entry = lookup_pragma_entry (*chain, node);\n   if (entry)\n     {\n       if (entry->is_nspace)\n \tclash:\n \tcpp_ice (pfile,\n \t\t \"registering \\\"%s\\\" as both a pragma and a pragma namespace\",\n-\t\t entry->name);\n+\t\t NODE_NAME (node));\n       else if (space)\n \tcpp_ice (pfile, \"#pragma %s %s is already registered\", space, name);\n       else\n \tcpp_ice (pfile, \"#pragma %s is already registered\", name);\n     }\n   else\n-    insert_pragma_entry (pfile, chain, name, handler);\n+    insert_pragma_entry (pfile, chain, node, handler);\n }\n \n /* Register the pragmas the preprocessor itself handles.  */\n@@ -989,15 +985,13 @@ do_pragma (pfile)\n   token = cpp_get_token (pfile);\n   if (token->type == CPP_NAME)\n     {\n-      p = lookup_pragma_entry (pfile->pragmas,\n-\t\t\t       (char *) NODE_NAME (token->val.node));\n+      p = lookup_pragma_entry (pfile->pragmas, token->val.node);\n       if (p && p->is_nspace)\n \t{\n \t  count = 2;\n \t  token = cpp_get_token (pfile);\n \t  if (token->type == CPP_NAME)\n-\t    p = lookup_pragma_entry (p->u.space,\n-\t\t\t\t     (char *) NODE_NAME (token->val.node));\n+\t    p = lookup_pragma_entry (p->u.space, token->val.node);\n \t  else\n \t    p = NULL;\n \t}"}]}