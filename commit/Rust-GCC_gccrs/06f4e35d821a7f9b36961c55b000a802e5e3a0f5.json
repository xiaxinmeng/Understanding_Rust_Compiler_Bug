{"sha": "06f4e35d821a7f9b36961c55b000a802e5e3a0f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZmNGUzNWQ4MjFhN2Y5YjM2OTYxYzU1YjAwMGE4MDJlNWUzYTBmNQ==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2007-06-02T09:07:00Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2007-06-02T09:07:00Z"}, "message": "i386.h (enum reg_class): New.\n\n        * config/i386/i386.h (enum reg_class) [SSE_FIRST_REG]: New.\n        (SSE_CLASS_P): Use reg_class_subset_p between SSE_REGS.\n        (REG_CLASS_NAMES): Add \"FIRST_SSE_REG\" string.\n        (REG_CLASS_CONTENTS): Add members of FIRST_SSE_REG class.\n        * config/i386/constraints.md (\"z\"): New register constraint\n        for members of SSE_FIRST_REG class.\n        * config/i386/i386-modes.def (CCA, CCC, CCO, CCS): New compare modes.\n        * config/i386/i386.c (regclass_map): Change class of %xmm0 to\n        SSE_FIRST_REG class.\n        (put_condition_code) [EQ, NE]: Output suffixes for new compare modes.\n        (ix86_cc_modes_compatible): Handle CCA, CCC, CCO and CCS modes.\n        (IX86_BUILTIN_PCMPESTRI128): New for SSE4.2.\n        (IX86_BUILTIN_PCMPESTRM128): Likewise.\n        (IX86_BUILTIN_PCMPESTRA128): Likewise.\n        (IX86_BUILTIN_PCMPESTRC128): Likewise.\n        (IX86_BUILTIN_PCMPESTRO128): Likewise.\n        (IX86_BUILTIN_PCMPESTRS128): Likewise.\n        (IX86_BUILTIN_PCMPESTRZ128): Likewise.\n        (IX86_BUILTIN_PCMPISTRI128): Likewise.\n        (IX86_BUILTIN_PCMPISTRM128): Likewise.\n        (IX86_BUILTIN_PCMPISTRA128): Likewise.\n        (IX86_BUILTIN_PCMPISTRC128): Likewise.\n        (IX86_BUILTIN_PCMPISTRO128): Likewise.\n        (IX86_BUILTIN_PCMPISTRS128): Likewise.\n        (IX86_BUILTIN_PCMPISTRZ128): Likewise.\n        (struct builtin_description): Change \"flag\" field to unsigned.\n        (bdesc_pcmpestr): New builtin description table.\n        (bdesc_pcmpistr): Likewise.\n        (ix86_init_mmx_sse_builtins): Define int_ftype_v16qi_int_v16qi_int_int,\n        v16qi_ftype_v16qi_int_v16qi_int_int and int_ftype_v16qi_v16qi_int.\n        Initialize pcmp[ei]str[im] insns for SSE4.2.\n        (ix86_expand_sse_pcmpestr): New subroutine of ix86_expand_builtin.\n        (ix86_expand_sse_pcmpistr): Likewise.\n        (ix86_expand_builtin): Expand pcmp[ei]str[im] builtins for SSE4.2.\n        * config/i386/i386.md (UNSPEC_PCMPESTR): New for SSE4.2.\n        (UNSPEC_PCMPISTR): Likewise.\n        * config/i386/sse.md (sse4_2_pcmpestr): New insn patern and splitter.\n        (sse4_2_pcmpestri):New isns pattern.\n        (sse4_2_pcmpestrm): Likewise.\n        (sse4_2_pcmpestr_cconly): Likewise.\n        (sse4_2_pcmpistr): New insn patern and splitter.\n        (sse4_2_pcmpistri):New isns pattern.\n        (sse4_2_pcmpistrm): Likewise.\n        (sse4_2_pcmpistr_cconly): Likewise.\n        * config/i386/smmintrin.h: Enable pcmp[ei]str[im] intrinsics\n        in SSE4.2.\n\n\nCo-Authored-By: Uros Bizjak <ubizjak@gmail.com>\n\nFrom-SVN: r125279", "tree": {"sha": "1a46abf87b3bfec77fc9f40db121f3c193579003", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a46abf87b3bfec77fc9f40db121f3c193579003"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06f4e35d821a7f9b36961c55b000a802e5e3a0f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06f4e35d821a7f9b36961c55b000a802e5e3a0f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06f4e35d821a7f9b36961c55b000a802e5e3a0f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06f4e35d821a7f9b36961c55b000a802e5e3a0f5/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "82a6cadf506e70f45ca7f716688656040a793551", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82a6cadf506e70f45ca7f716688656040a793551", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82a6cadf506e70f45ca7f716688656040a793551"}], "stats": {"total": 698, "additions": 672, "deletions": 26}, "files": [{"sha": "c7ade0af844bf4035d44174d4501838e491a78b0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 54, "deletions": 17, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06f4e35d821a7f9b36961c55b000a802e5e3a0f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06f4e35d821a7f9b36961c55b000a802e5e3a0f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=06f4e35d821a7f9b36961c55b000a802e5e3a0f5", "patch": "@@ -1,3 +1,53 @@\n+2007-06-02  H.J. Lu  <hongjiu.lu@intel.com>\n+\t    Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.h (enum reg_class) [SSE_FIRST_REG]: New.\n+\t(SSE_CLASS_P): Use reg_class_subset_p between SSE_REGS.\n+\t(REG_CLASS_NAMES): Add \"FIRST_SSE_REG\" string.\n+\t(REG_CLASS_CONTENTS): Add members of FIRST_SSE_REG class.\n+\t* config/i386/constraints.md (\"z\"): New register constraint\n+\tfor members of SSE_FIRST_REG class.\n+\t* config/i386/i386-modes.def (CCA, CCC, CCO, CCS): New compare modes.\n+\t* config/i386/i386.c (regclass_map): Change class of %xmm0 to\n+\tSSE_FIRST_REG class.\n+\t(put_condition_code) [EQ, NE]: Output suffixes for new compare modes.\n+\t(ix86_cc_modes_compatible): Handle CCA, CCC, CCO and CCS modes.\n+\t(IX86_BUILTIN_PCMPESTRI128): New for SSE4.2.\n+\t(IX86_BUILTIN_PCMPESTRM128): Likewise.\n+\t(IX86_BUILTIN_PCMPESTRA128): Likewise.\n+\t(IX86_BUILTIN_PCMPESTRC128): Likewise.\n+\t(IX86_BUILTIN_PCMPESTRO128): Likewise.\n+\t(IX86_BUILTIN_PCMPESTRS128): Likewise.\n+\t(IX86_BUILTIN_PCMPESTRZ128): Likewise.\n+\t(IX86_BUILTIN_PCMPISTRI128): Likewise.\n+\t(IX86_BUILTIN_PCMPISTRM128): Likewise.\n+\t(IX86_BUILTIN_PCMPISTRA128): Likewise.\n+\t(IX86_BUILTIN_PCMPISTRC128): Likewise.\n+\t(IX86_BUILTIN_PCMPISTRO128): Likewise.\n+\t(IX86_BUILTIN_PCMPISTRS128): Likewise.\n+\t(IX86_BUILTIN_PCMPISTRZ128): Likewise.\n+\t(struct builtin_description): Change \"flag\" field to unsigned.\n+\t(bdesc_pcmpestr): New builtin description table.\n+\t(bdesc_pcmpistr): Likewise.\n+\t(ix86_init_mmx_sse_builtins): Define int_ftype_v16qi_int_v16qi_int_int,\n+\tv16qi_ftype_v16qi_int_v16qi_int_int and int_ftype_v16qi_v16qi_int.\n+\tInitialize pcmp[ei]str[im] insns for SSE4.2.\n+\t(ix86_expand_sse_pcmpestr): New subroutine of ix86_expand_builtin.\n+\t(ix86_expand_sse_pcmpistr): Likewise.\n+\t(ix86_expand_builtin): Expand pcmp[ei]str[im] builtins for SSE4.2.\n+\t* config/i386/i386.md (UNSPEC_PCMPESTR): New for SSE4.2.\n+\t(UNSPEC_PCMPISTR): Likewise.\n+\t* config/i386/sse.md (sse4_2_pcmpestr): New insn patern and splitter.\n+\t(sse4_2_pcmpestri):New isns pattern.\n+\t(sse4_2_pcmpestrm): Likewise.\n+\t(sse4_2_pcmpestr_cconly): Likewise.\n+\t(sse4_2_pcmpistr): New insn patern and splitter.\n+\t(sse4_2_pcmpistri):New isns pattern.\n+\t(sse4_2_pcmpistrm): Likewise.\n+\t(sse4_2_pcmpistr_cconly): Likewise.\n+\t* config/i386/smmintrin.h: Enable pcmp[ei]str[im] intrinsics\n+\tin SSE4.2.\n+\n 2007-06-01  David Daney  <ddaney@avtrex.com>\n \n \t* config/mips/mips.c (mips_output_mi_thunk): Only load gp if not\n@@ -48,10 +98,8 @@\n \n 2007-05-31  H.J. Lu  <hongjiu.lu@intel.com>\n \n-\t* config.gcc (i[34567]86-*-*): Add nmmintrin.h to\n-\textra_headers.\n+\t* config.gcc (i[34567]86-*-*): Add nmmintrin.h to extra_headers.\n \t(x86_64-*-*): Likewise.\n-\n \t* config/i386/i386.c (OPTION_MASK_ISA_MMX_UNSET): New.\n \t(OPTION_MASK_ISA_3DNOW_UNSET): Likewise.\n \t(OPTION_MASK_ISA_SSE_UNSET): Likewise.\n@@ -63,8 +111,7 @@\n \t(OPTION_MASK_ISA_SSE4): Likewise.\n \t(OPTION_MASK_ISA_SSE4_UNSET): Likewise.\n \t(OPTION_MASK_ISA_SSE4A_UNSET): Likewise.\n-\t(ix86_handle_option): Use OPTION_MASK_ISA_*_UNSET.  Handle\n-\tSSE4.2.\n+\t(ix86_handle_option): Use OPTION_MASK_ISA_*_UNSET.  Handle SSE4.2.\n \t(override_options): Support SSE4.2.\n \t(ix86_build_const_vector): Support SImode and DImode.\n \t(ix86_build_signbit_mask): Likewise.\n@@ -79,32 +126,22 @@\n \t(ix86_expand_crc32): Likewise.\n \t(ix86_init_mmx_sse_builtins): Support SSE4.2.\n \t(ix86_expand_builtin): Likewise.\n-\n \t* config/i386/i386.h (TARGET_CPU_CPP_BUILTINS): Define\n \t__SSE4_2__ for -msse4.2.\n-\n \t* config/i386/i386.md (UNSPEC_CRC32): New for SSE4.2.\n \t(CRC32MODE): Likewise.\n \t(crc32modesuffix): Likewise.\n \t(crc32modeconstraint): Likewise.\n \t(sse4_2_crc32<mode>): Likewise.\n \t(sse4_2_crc32di): Likewise.\n-\n \t* config/i386/i386.opt (msse4.2): New for SSE4.2.\n \t(msse4): Likewise.\n-\n-\t* config/i386/nmmintrin.h: New. The dummy SSE4.2 intrinsic header\n-\tfile.\n-\n+\t* config/i386/nmmintrin.h: New. The dummy SSE4.2 intrinsic header file.\n \t* config/i386/smmintrin.h: Add SSE4.2 intrinsics.\n-\n-\t* config/i386/sse.md (sse4_2_gtv2di3): New pattern for\n-\tSSE4.2.\n+\t* config/i386/sse.md (sse4_2_gtv2di3): New pattern for SSE4.2.\n \t(vcond<mode>): Use SSEMODEI instead of SSEMODE124.\n \t(vcondu<mode>): Likewise.\n-\n \t* doc/extend.texi: Document SSE4.2 built-in functions.\n-\n \t* doc/invoke.texi: Document -msse4.2/-msse4.\n \n 2007-05-31  Zdenek Dvorak  <dvorakz@suse.cz>"}, {"sha": "281d01ff90722b08042959ac07073a022c9a9fe3", "filename": "gcc/config/i386/constraints.md", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06f4e35d821a7f9b36961c55b000a802e5e3a0f5/gcc%2Fconfig%2Fi386%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06f4e35d821a7f9b36961c55b000a802e5e3a0f5/gcc%2Fconfig%2Fi386%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fconstraints.md?ref=06f4e35d821a7f9b36961c55b000a802e5e3a0f5", "patch": "@@ -19,8 +19,8 @@\n ;; Boston, MA 02110-1301, USA.\n \n ;;; Unused letters:\n-;;;     B     H           TU W   \n-;;;           h jk          vw  z\n+;;;     B     H           TU W\n+;;;           h jk          vw\n \n ;; Integer register constraints.\n ;; It is not necessary to define 'r' here.\n@@ -83,6 +83,9 @@\n (define_register_constraint \"x\" \"TARGET_SSE ? SSE_REGS : NO_REGS\"\n  \"Any SSE register.\")\n \n+(define_register_constraint \"z\" \"TARGET_SSE ? SSE_FIRST_REG : NO_REGS\"\n+ \"First SSE register (@code{%xmm0}).\")\n+\n ;; We use the Y prefix to denote any number of conditional register sets:\n ;;  2\tSSE2 enabled\n ;;  i\tSSE2 inter-unit moves enabled"}, {"sha": "c772e06685cd2a72d23daaeb7ceafa66ef90d7aa", "filename": "gcc/config/i386/i386-modes.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06f4e35d821a7f9b36961c55b000a802e5e3a0f5/gcc%2Fconfig%2Fi386%2Fi386-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06f4e35d821a7f9b36961c55b000a802e5e3a0f5/gcc%2Fconfig%2Fi386%2Fi386-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-modes.def?ref=06f4e35d821a7f9b36961c55b000a802e5e3a0f5", "patch": "@@ -53,11 +53,19 @@ ADJUST_ALIGNMENT (XF, TARGET_128BIT_LONG_DOUBLE ? 16 : 4);\n    mode is used to simulate comparisons of (a-b) and (a+b)\n    against zero using sub/cmp/add operations.\n \n+   Add CCA to indicate that only the Above flag is valid.\n+   Add CCC to indicate that only the Carry flag is valid.\n+   Add CCO to indicate that only the Overflow flag is valid.\n+   Add CCS to indicate that only the Sign flag is valid.\n    Add CCZ to indicate that only the Zero flag is valid.  */\n \n CC_MODE (CCGC);\n CC_MODE (CCGOC);\n CC_MODE (CCNO);\n+CC_MODE (CCA);\n+CC_MODE (CCC);\n+CC_MODE (CCO);\n+CC_MODE (CCS);\n CC_MODE (CCZ);\n CC_MODE (CCFP);\n CC_MODE (CCFPU);"}, {"sha": "593db77a4e0bfdf317d9e016ecb6490478ac761f", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 354, "deletions": 4, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06f4e35d821a7f9b36961c55b000a802e5e3a0f5/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06f4e35d821a7f9b36961c55b000a802e5e3a0f5/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=06f4e35d821a7f9b36961c55b000a802e5e3a0f5", "patch": "@@ -1278,12 +1278,16 @@ enum reg_class const regclass_map[FIRST_PSEUDO_REGISTER] =\n   NON_Q_REGS,\n   /* flags, fpsr, fpcr, frame */\n   NO_REGS, NO_REGS, NO_REGS, NON_Q_REGS,\n-  SSE_REGS, SSE_REGS, SSE_REGS, SSE_REGS, SSE_REGS, SSE_REGS,\n+  /* SSE registers */\n+  SSE_FIRST_REG, SSE_REGS, SSE_REGS, SSE_REGS, SSE_REGS, SSE_REGS,\n   SSE_REGS, SSE_REGS,\n+  /* MMX registers */\n   MMX_REGS, MMX_REGS, MMX_REGS, MMX_REGS, MMX_REGS, MMX_REGS,\n   MMX_REGS, MMX_REGS,\n+  /* REX registers */\n   NON_Q_REGS, NON_Q_REGS, NON_Q_REGS, NON_Q_REGS,\n   NON_Q_REGS, NON_Q_REGS, NON_Q_REGS, NON_Q_REGS,\n+  /* SSE REX registers */\n   SSE_REGS, SSE_REGS, SSE_REGS, SSE_REGS, SSE_REGS, SSE_REGS,\n   SSE_REGS, SSE_REGS,\n };\n@@ -8160,10 +8164,50 @@ put_condition_code (enum rtx_code code, enum machine_mode mode, int reverse,\n   switch (code)\n     {\n     case EQ:\n-      suffix = \"e\";\n+      switch (mode)\n+\t{\n+\tcase CCAmode:\n+\t  suffix = \"a\";\n+\t  break;\n+\n+\tcase CCCmode:\n+\t  suffix = \"c\";\n+\t  break;\n+\n+\tcase CCOmode:\n+\t  suffix = \"o\";\n+\t  break;\n+\n+\tcase CCSmode:\n+\t  suffix = \"s\";\n+\t  break;\n+\n+\tdefault:\n+\t  suffix = \"e\";\n+\t}\n       break;\n     case NE:\n-      suffix = \"ne\";\n+      switch (mode)\n+\t{\n+\tcase CCAmode:\n+\t  suffix = \"na\";\n+\t  break;\n+\n+\tcase CCCmode:\n+\t  suffix = \"nc\";\n+\t  break;\n+\n+\tcase CCOmode:\n+\t  suffix = \"no\";\n+\t  break;\n+\n+\tcase CCSmode:\n+\t  suffix = \"ns\";\n+\t  break;\n+\n+\tdefault:\n+\t  suffix = \"ne\";\n+\t}\n       break;\n     case GT:\n       gcc_assert (mode == CCmode || mode == CCNOmode || mode == CCGCmode);\n@@ -10991,6 +11035,10 @@ ix86_cc_modes_compatible (enum machine_mode m1, enum machine_mode m2)\n     case CCGCmode:\n     case CCGOCmode:\n     case CCNOmode:\n+    case CCAmode:\n+    case CCCmode:\n+    case CCOmode:\n+    case CCSmode:\n     case CCZmode:\n       switch (m2)\n \t{\n@@ -11001,6 +11049,10 @@ ix86_cc_modes_compatible (enum machine_mode m1, enum machine_mode m2)\n \tcase CCGCmode:\n \tcase CCGOCmode:\n \tcase CCNOmode:\n+\tcase CCAmode:\n+\tcase CCCmode:\n+\tcase CCOmode:\n+\tcase CCSmode:\n \tcase CCZmode:\n \t  return CCmode;\n \t}\n@@ -16736,6 +16788,21 @@ enum ix86_builtins\n   IX86_BUILTIN_CRC32SI,\n   IX86_BUILTIN_CRC32DI,\n \n+  IX86_BUILTIN_PCMPESTRI128,\n+  IX86_BUILTIN_PCMPESTRM128,\n+  IX86_BUILTIN_PCMPESTRA128,\n+  IX86_BUILTIN_PCMPESTRC128,\n+  IX86_BUILTIN_PCMPESTRO128,\n+  IX86_BUILTIN_PCMPESTRS128,\n+  IX86_BUILTIN_PCMPESTRZ128,\n+  IX86_BUILTIN_PCMPISTRI128,\n+  IX86_BUILTIN_PCMPISTRM128,\n+  IX86_BUILTIN_PCMPISTRA128,\n+  IX86_BUILTIN_PCMPISTRC128,\n+  IX86_BUILTIN_PCMPISTRO128,\n+  IX86_BUILTIN_PCMPISTRS128,\n+  IX86_BUILTIN_PCMPISTRZ128,\n+\n   IX86_BUILTIN_PCMPGTQ,\n \n   IX86_BUILTIN_MAX\n@@ -16790,7 +16857,7 @@ struct builtin_description\n   const char *const name;\n   const enum ix86_builtins code;\n   const enum rtx_code comparison;\n-  const unsigned int flag;\n+  const int flag;\n };\n \n static const struct builtin_description bdesc_comi[] =\n@@ -16829,6 +16896,30 @@ static const struct builtin_description bdesc_ptest[] =\n   { OPTION_MASK_ISA_SSE4_1, CODE_FOR_sse4_1_ptest, \"__builtin_ia32_ptestnzc128\", IX86_BUILTIN_PTESTNZC, GTU, 0 },\n };\n \n+static const struct builtin_description bdesc_pcmpestr[] =\n+{\n+  /* SSE4.2 */\n+  { OPTION_MASK_ISA_SSE4_2, CODE_FOR_sse4_2_pcmpestr, \"__builtin_ia32_pcmpestri128\", IX86_BUILTIN_PCMPESTRI128, 0, 0 },\n+  { OPTION_MASK_ISA_SSE4_2, CODE_FOR_sse4_2_pcmpestr, \"__builtin_ia32_pcmpestrm128\", IX86_BUILTIN_PCMPESTRM128, 0, 0 },\n+  { OPTION_MASK_ISA_SSE4_2, CODE_FOR_sse4_2_pcmpestr, \"__builtin_ia32_pcmpestria128\", IX86_BUILTIN_PCMPESTRA128, 0, (int) CCAmode },\n+  { OPTION_MASK_ISA_SSE4_2, CODE_FOR_sse4_2_pcmpestr, \"__builtin_ia32_pcmpestric128\", IX86_BUILTIN_PCMPESTRC128, 0, (int) CCCmode },\n+  { OPTION_MASK_ISA_SSE4_2, CODE_FOR_sse4_2_pcmpestr, \"__builtin_ia32_pcmpestrio128\", IX86_BUILTIN_PCMPESTRO128, 0, (int) CCOmode },\n+  { OPTION_MASK_ISA_SSE4_2, CODE_FOR_sse4_2_pcmpestr, \"__builtin_ia32_pcmpestris128\", IX86_BUILTIN_PCMPESTRS128, 0, (int) CCSmode },\n+  { OPTION_MASK_ISA_SSE4_2, CODE_FOR_sse4_2_pcmpestr, \"__builtin_ia32_pcmpestriz128\", IX86_BUILTIN_PCMPESTRZ128, 0, (int) CCZmode },\n+};\n+\n+static const struct builtin_description bdesc_pcmpistr[] =\n+{\n+  /* SSE4.2 */\n+  { OPTION_MASK_ISA_SSE4_2, CODE_FOR_sse4_2_pcmpistr, \"__builtin_ia32_pcmpistri128\", IX86_BUILTIN_PCMPISTRI128, 0, 0 },\n+  { OPTION_MASK_ISA_SSE4_2, CODE_FOR_sse4_2_pcmpistr, \"__builtin_ia32_pcmpistrm128\", IX86_BUILTIN_PCMPISTRM128, 0, 0 },\n+  { OPTION_MASK_ISA_SSE4_2, CODE_FOR_sse4_2_pcmpistr, \"__builtin_ia32_pcmpistria128\", IX86_BUILTIN_PCMPISTRA128, 0, (int) CCAmode },\n+  { OPTION_MASK_ISA_SSE4_2, CODE_FOR_sse4_2_pcmpistr, \"__builtin_ia32_pcmpistric128\", IX86_BUILTIN_PCMPISTRC128, 0, (int) CCCmode },\n+  { OPTION_MASK_ISA_SSE4_2, CODE_FOR_sse4_2_pcmpistr, \"__builtin_ia32_pcmpistrio128\", IX86_BUILTIN_PCMPISTRO128, 0, (int) CCOmode },\n+  { OPTION_MASK_ISA_SSE4_2, CODE_FOR_sse4_2_pcmpistr, \"__builtin_ia32_pcmpistris128\", IX86_BUILTIN_PCMPISTRS128, 0, (int) CCSmode },\n+  { OPTION_MASK_ISA_SSE4_2, CODE_FOR_sse4_2_pcmpistr, \"__builtin_ia32_pcmpistriz128\", IX86_BUILTIN_PCMPISTRZ128, 0, (int) CCZmode },\n+};\n+\n static const struct builtin_description bdesc_crc32[] =\n {\n   /* SSE4.2 */\n@@ -17591,6 +17682,28 @@ ix86_init_mmx_sse_builtins (void)\n     = build_function_type_list (integer_type_node,\n \t\t\t\tV2DI_type_node, V2DI_type_node,\n \t\t\t\tNULL_TREE);\n+  tree int_ftype_v16qi_int_v16qi_int_int\n+    = build_function_type_list (integer_type_node,\n+\t\t\t\tV16QI_type_node,\n+\t\t\t\tinteger_type_node,\n+\t\t\t\tV16QI_type_node,\n+\t\t\t\tinteger_type_node,\n+\t\t\t\tinteger_type_node,\n+\t\t\t\tNULL_TREE);\n+  tree v16qi_ftype_v16qi_int_v16qi_int_int\n+    = build_function_type_list (V16QI_type_node,\n+\t\t\t\tV16QI_type_node,\n+\t\t\t\tinteger_type_node,\n+\t\t\t\tV16QI_type_node,\n+\t\t\t\tinteger_type_node,\n+\t\t\t\tinteger_type_node,\n+\t\t\t\tNULL_TREE);\n+  tree int_ftype_v16qi_v16qi_int\n+    = build_function_type_list (integer_type_node,\n+\t\t\t\tV16QI_type_node,\n+\t\t\t\tV16QI_type_node,\n+\t\t\t\tinteger_type_node,\n+\t\t\t\tNULL_TREE);\n \n   tree float80_type;\n   tree float128_type;\n@@ -17781,6 +17894,30 @@ ix86_init_mmx_sse_builtins (void)\n       def_builtin (d->mask, d->name, type, d->code);\n     }\n \n+  /* pcmpestr[im] insns.  */\n+  for (i = 0, d = bdesc_pcmpestr;\n+       i < ARRAY_SIZE (bdesc_pcmpestr);\n+       i++, d++)\n+    {\n+      if (d->code == IX86_BUILTIN_PCMPESTRM128)\n+\tftype = v16qi_ftype_v16qi_int_v16qi_int_int;\n+      else\n+\tftype = int_ftype_v16qi_int_v16qi_int_int;\n+      def_builtin (d->mask, d->name, ftype, d->code);\n+    }\n+\n+  /* pcmpistr[im] insns.  */\n+  for (i = 0, d = bdesc_pcmpistr;\n+       i < ARRAY_SIZE (bdesc_pcmpistr);\n+       i++, d++)\n+    {\n+      if (d->code == IX86_BUILTIN_PCMPISTRM128)\n+\tftype = v16qi_ftype_v16qi_v16qi_int;\n+      else\n+\tftype = int_ftype_v16qi_v16qi_int;\n+      def_builtin (d->mask, d->name, ftype, d->code);\n+    }\n+\n   /* Add the remaining MMX insns with somewhat more complicated types.  */\n   def_builtin (OPTION_MASK_ISA_MMX, \"__builtin_ia32_emms\", void_ftype_void, IX86_BUILTIN_EMMS);\n   def_builtin (OPTION_MASK_ISA_MMX, \"__builtin_ia32_psllw\", v4hi_ftype_v4hi_di, IX86_BUILTIN_PSLLW);\n@@ -18562,6 +18699,207 @@ ix86_expand_sse_ptest (const struct builtin_description *d, tree exp,\n   return SUBREG_REG (target);\n }\n \n+/* Subroutine of ix86_expand_builtin to take care of pcmpestr[im] insns.  */\n+\n+static rtx\n+ix86_expand_sse_pcmpestr (const struct builtin_description *d,\n+\t\t\t  tree exp, rtx target)\n+{\n+  rtx pat;\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n+  tree arg1 = CALL_EXPR_ARG (exp, 1);\n+  tree arg2 = CALL_EXPR_ARG (exp, 2);\n+  tree arg3 = CALL_EXPR_ARG (exp, 3);\n+  tree arg4 = CALL_EXPR_ARG (exp, 4);\n+  rtx scratch0, scratch1;\n+  rtx op0 = expand_normal (arg0);\n+  rtx op1 = expand_normal (arg1);\n+  rtx op2 = expand_normal (arg2);\n+  rtx op3 = expand_normal (arg3);\n+  rtx op4 = expand_normal (arg4);\n+  enum machine_mode tmode0, tmode1, modev2, modei3, modev4, modei5, modeimm;\n+\n+  tmode0 = insn_data[d->icode].operand[0].mode;\n+  tmode1 = insn_data[d->icode].operand[1].mode;\n+  modev2 = insn_data[d->icode].operand[2].mode;\n+  modei3 = insn_data[d->icode].operand[3].mode;\n+  modev4 = insn_data[d->icode].operand[4].mode;\n+  modei5 = insn_data[d->icode].operand[5].mode;\n+  modeimm = insn_data[d->icode].operand[6].mode;\n+\n+  if (VECTOR_MODE_P (modev2))\n+    op0 = safe_vector_operand (op0, modev2);\n+  if (VECTOR_MODE_P (modev4))\n+    op2 = safe_vector_operand (op2, modev4);\n+\n+  if ((optimize && !register_operand (op0, modev2))\n+      || !(*insn_data[d->icode].operand[2].predicate) (op0, modev2))\n+    op0 = copy_to_mode_reg (modev2, op0);\n+  if ((optimize && !register_operand (op1, modei3))\n+      || !(*insn_data[d->icode].operand[3].predicate) (op1, modei3))\n+    op1 = copy_to_mode_reg (modei3, op1);\n+  if ((optimize && !register_operand (op2, modev4))\n+      || !(*insn_data[d->icode].operand[4].predicate) (op2, modev4))\n+    op2 = copy_to_mode_reg (modev4, op2);\n+  if ((optimize && !register_operand (op3, modei5))\n+      || !(*insn_data[d->icode].operand[5].predicate) (op3, modei5))\n+    op3 = copy_to_mode_reg (modei5, op3);\n+\n+  if (! (*insn_data[d->icode].operand[6].predicate) (op4, modeimm))\n+    {\n+      error (\"the fifth argument must be a 8-bit immediate\");\n+      return const0_rtx;\n+    }\n+\n+  if (d->code == IX86_BUILTIN_PCMPESTRI128)\n+    {\n+      if (optimize || !target\n+\t  || GET_MODE (target) != tmode0\n+\t  || ! (*insn_data[d->icode].operand[0].predicate) (target, tmode0))\n+\ttarget = gen_reg_rtx (tmode0);\n+\n+      scratch1 = gen_reg_rtx (tmode1);\n+\n+      pat = GEN_FCN (d->icode) (target, scratch1, op0, op1, op2, op3, op4);\n+    }\n+  else if (d->code == IX86_BUILTIN_PCMPESTRM128)\n+    {\n+      if (optimize || !target\n+\t  || GET_MODE (target) != tmode1\n+\t  || ! (*insn_data[d->icode].operand[1].predicate) (target, tmode1))\n+\ttarget = gen_reg_rtx (tmode1);\n+\n+      scratch0 = gen_reg_rtx (tmode0);\n+\n+      pat = GEN_FCN (d->icode) (scratch0, target, op0, op1, op2, op3, op4);\n+    }\n+  else\n+    {\n+      gcc_assert (d->flag);\n+\n+      scratch0 = gen_reg_rtx (tmode0);\n+      scratch1 = gen_reg_rtx (tmode1);\n+\n+      pat = GEN_FCN (d->icode) (scratch0, scratch1, op0, op1, op2, op3, op4);\n+    }\n+\n+  if (! pat)\n+    return 0;\n+\n+  emit_insn (pat);\n+\n+  if (d->flag)\n+    {\n+      target = gen_reg_rtx (SImode);\n+      emit_move_insn (target, const0_rtx);\n+      target = gen_rtx_SUBREG (QImode, target, 0);\n+\n+      emit_insn\n+\t(gen_rtx_SET (VOIDmode, gen_rtx_STRICT_LOW_PART (VOIDmode, target),\n+\t\t      gen_rtx_fmt_ee (EQ, QImode,\n+\t\t\t\t      gen_rtx_REG (d->flag, FLAGS_REG),\n+\t\t\t\t      const0_rtx)));\n+      return SUBREG_REG (target);\n+    }\n+  else\n+    return target;\n+}\n+\n+\n+/* Subroutine of ix86_expand_builtin to take care of pcmpistr[im] insns.  */\n+\n+static rtx\n+ix86_expand_sse_pcmpistr (const struct builtin_description *d,\n+\t\t\t  tree exp, rtx target)\n+{\n+  rtx pat;\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n+  tree arg1 = CALL_EXPR_ARG (exp, 1);\n+  tree arg2 = CALL_EXPR_ARG (exp, 2);\n+  rtx scratch0, scratch1;\n+  rtx op0 = expand_normal (arg0);\n+  rtx op1 = expand_normal (arg1);\n+  rtx op2 = expand_normal (arg2);\n+  enum machine_mode tmode0, tmode1, modev2, modev3, modeimm;\n+\n+  tmode0 = insn_data[d->icode].operand[0].mode;\n+  tmode1 = insn_data[d->icode].operand[1].mode;\n+  modev2 = insn_data[d->icode].operand[2].mode;\n+  modev3 = insn_data[d->icode].operand[3].mode;\n+  modeimm = insn_data[d->icode].operand[4].mode;\n+\n+  if (VECTOR_MODE_P (modev2))\n+    op0 = safe_vector_operand (op0, modev2);\n+  if (VECTOR_MODE_P (modev3))\n+    op1 = safe_vector_operand (op1, modev3);\n+\n+  if ((optimize && !register_operand (op0, modev2))\n+      || !(*insn_data[d->icode].operand[2].predicate) (op0, modev2))\n+    op0 = copy_to_mode_reg (modev2, op0);\n+  if ((optimize && !register_operand (op1, modev3))\n+      || !(*insn_data[d->icode].operand[3].predicate) (op1, modev3))\n+    op1 = copy_to_mode_reg (modev3, op1);\n+\n+  if (! (*insn_data[d->icode].operand[4].predicate) (op2, modeimm))\n+    {\n+      error (\"the third argument must be a 8-bit immediate\");\n+      return const0_rtx;\n+    }\n+\n+  if (d->code == IX86_BUILTIN_PCMPISTRI128)\n+    {\n+      if (optimize || !target\n+\t  || GET_MODE (target) != tmode0\n+\t  || ! (*insn_data[d->icode].operand[0].predicate) (target, tmode0))\n+\ttarget = gen_reg_rtx (tmode0);\n+\n+      scratch1 = gen_reg_rtx (tmode1);\n+\n+      pat = GEN_FCN (d->icode) (target, scratch1, op0, op1, op2);\n+    }\n+  else if (d->code == IX86_BUILTIN_PCMPISTRM128)\n+    {\n+      if (optimize || !target\n+\t  || GET_MODE (target) != tmode1\n+\t  || ! (*insn_data[d->icode].operand[1].predicate) (target, tmode1))\n+\ttarget = gen_reg_rtx (tmode1);\n+\n+      scratch0 = gen_reg_rtx (tmode0);\n+\n+      pat = GEN_FCN (d->icode) (scratch0, target, op0, op1, op2);\n+    }\n+  else\n+    {\n+      gcc_assert (d->flag);\n+\n+      scratch0 = gen_reg_rtx (tmode0);\n+      scratch1 = gen_reg_rtx (tmode1);\n+\n+      pat = GEN_FCN (d->icode) (scratch0, scratch1, op0, op1, op2);\n+    }\n+\n+  if (! pat)\n+    return 0;\n+\n+  emit_insn (pat);\n+\n+  if (d->flag)\n+    {\n+      target = gen_reg_rtx (SImode);\n+      emit_move_insn (target, const0_rtx);\n+      target = gen_rtx_SUBREG (QImode, target, 0);\n+\n+      emit_insn\n+\t(gen_rtx_SET (VOIDmode, gen_rtx_STRICT_LOW_PART (VOIDmode, target),\n+\t\t      gen_rtx_fmt_ee (EQ, QImode,\n+\t\t\t\t      gen_rtx_REG (d->flag, FLAGS_REG),\n+\t\t\t\t      const0_rtx)));\n+      return SUBREG_REG (target);\n+    }\n+  else\n+    return target;\n+}\n+\n /* Return the integer constant in ARG.  Constrain it to be in the range\n    of the subparts of VEC_TYPE; issue an error if not.  */\n \n@@ -19392,6 +19730,18 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n     if (d->code == fcode)\n       return ix86_expand_crc32 (d->icode, exp, target);\n \n+  for (i = 0, d = bdesc_pcmpestr;\n+       i < ARRAY_SIZE (bdesc_pcmpestr);\n+       i++, d++)\n+    if (d->code == fcode)\n+      return ix86_expand_sse_pcmpestr (d, exp, target);\n+\n+  for (i = 0, d = bdesc_pcmpistr;\n+       i < ARRAY_SIZE (bdesc_pcmpistr);\n+       i++, d++)\n+    if (d->code == fcode)\n+      return ix86_expand_sse_pcmpistr (d, exp, target);\n+\n   gcc_unreachable ();\n }\n "}, {"sha": "6d351f6575350b5997c3739c47385bea526f70d4", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06f4e35d821a7f9b36961c55b000a802e5e3a0f5/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06f4e35d821a7f9b36961c55b000a802e5e3a0f5/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=06f4e35d821a7f9b36961c55b000a802e5e3a0f5", "patch": "@@ -1268,6 +1268,7 @@ enum reg_class\n   GENERAL_REGS,\t\t\t/* %eax %ebx %ecx %edx %esi %edi %ebp %esp %r8 - %r15*/\n   FP_TOP_REG, FP_SECOND_REG,\t/* %st(0) %st(1) */\n   FLOAT_REGS,\n+  SSE_FIRST_REG,\n   SSE_REGS,\n   MMX_REGS,\n   FP_TOP_SSE_REGS,\n@@ -1286,7 +1287,7 @@ enum reg_class\n #define FLOAT_CLASS_P(CLASS) \\\n   reg_class_subset_p ((CLASS), FLOAT_REGS)\n #define SSE_CLASS_P(CLASS) \\\n-  ((CLASS) == SSE_REGS)\n+  reg_class_subset_p ((CLASS), SSE_REGS)\n #define MMX_CLASS_P(CLASS) \\\n   ((CLASS) == MMX_REGS)\n #define MAYBE_INTEGER_CLASS_P(CLASS) \\\n@@ -1314,6 +1315,7 @@ enum reg_class\n    \"GENERAL_REGS\",\t\t\t\\\n    \"FP_TOP_REG\", \"FP_SECOND_REG\",\t\\\n    \"FLOAT_REGS\",\t\t\t\\\n+   \"FIRST_SSE_REG\",\t\t\t\\\n    \"SSE_REGS\",\t\t\t\t\\\n    \"MMX_REGS\",\t\t\t\t\\\n    \"FP_TOP_SSE_REGS\",\t\t\t\\\n@@ -1341,6 +1343,7 @@ enum reg_class\n   { 0x1100ff,  0x1fe0 },\t\t/* GENERAL_REGS */\t\t\\\n      { 0x100,     0x0 }, { 0x0200, 0x0 },/* FP_TOP_REG, FP_SECOND_REG */\\\n     { 0xff00,     0x0 },\t\t/* FLOAT_REGS */\t\t\\\n+  { 0x200000,     0x0 },\t\t/* FIRST_SSE_REG */\t\t\\\n { 0x1fe00000,0x1fe000 },\t\t/* SSE_REGS */\t\t\t\\\n { 0xe0000000,    0x1f },\t\t/* MMX_REGS */\t\t\t\\\n { 0x1fe00100,0x1fe000 },\t\t/* FP_TOP_SSE_REG */\t\t\\"}, {"sha": "3d101772f05833188f649a38b6d57bebb315c55e", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06f4e35d821a7f9b36961c55b000a802e5e3a0f5/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06f4e35d821a7f9b36961c55b000a802e5e3a0f5/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=06f4e35d821a7f9b36961c55b000a802e5e3a0f5", "patch": "@@ -176,6 +176,8 @@\n \n    ; For SSE4.2 support\n    (UNSPEC_CRC32\t\t143)\n+   (UNSPEC_PCMPESTR\t\t144)\n+   (UNSPEC_PCMPISTR\t\t145)\n   ])\n \n (define_constants"}, {"sha": "01943cd2bb7684a34b2d71ce204684b1766683e4", "filename": "gcc/config/i386/smmintrin.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06f4e35d821a7f9b36961c55b000a802e5e3a0f5/gcc%2Fconfig%2Fi386%2Fsmmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06f4e35d821a7f9b36961c55b000a802e5e3a0f5/gcc%2Fconfig%2Fi386%2Fsmmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsmmintrin.h?ref=06f4e35d821a7f9b36961c55b000a802e5e3a0f5", "patch": "@@ -603,7 +603,7 @@ _mm_stream_load_si128 (__m128i *__X)\n \n /* Intrinsics for text/string processing.  */\n \n-#if 0\n+#ifdef __OPTIMIZE__\n static __inline __m128i __attribute__((__always_inline__))\n _mm_cmpistrm (__m128i __X, __m128i __Y, const int __M)\n {\n@@ -652,7 +652,7 @@ _mm_cmpestri (__m128i __X, int __LX, __m128i __Y, int __LY, const int __M)\n /* Intrinsics for text/string processing and reading values of\n    EFlags.  */\n \n-#if 0\n+#ifdef __OPTIMIZE__\n static __inline int __attribute__((__always_inline__))\n _mm_cmpistra (__m128i __X, __m128i __Y, const int __M)\n {"}, {"sha": "da7e582b9abfa978255d26b71ebbcf7e12a86e3e", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06f4e35d821a7f9b36961c55b000a802e5e3a0f5/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06f4e35d821a7f9b36961c55b000a802e5e3a0f5/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=06f4e35d821a7f9b36961c55b000a802e5e3a0f5", "patch": "@@ -6383,3 +6383,246 @@\n   [(set_attr \"type\" \"ssecvt\")\n    (set_attr \"prefix_extra\" \"1\")\n    (set_attr \"mode\" \"V4SF\")])\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Intel SSE4.2 string/text processing instructions\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+(define_insn_and_split \"sse4_2_pcmpestr\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=c,c\")\n+\t(unspec:SI\n+\t  [(match_operand:V16QI 2 \"register_operand\" \"x,x\")\n+\t   (match_operand:SI 3 \"register_operand\" \"a,a\")\n+\t   (match_operand:V16QI 4 \"nonimmediate_operand\" \"x,m\")\n+\t   (match_operand:SI 5 \"register_operand\" \"d,d\")\n+\t   (match_operand:SI 6 \"const_0_to_255_operand\" \"n,n\")]\n+\t  UNSPEC_PCMPESTR))\n+   (set (match_operand:V16QI 1 \"register_operand\" \"=z,z\")\n+\t(unspec:V16QI\n+\t  [(match_dup 2)\n+\t   (match_dup 3)\n+\t   (match_dup 4)\n+\t   (match_dup 5)\n+\t   (match_dup 6)]\n+\t  UNSPEC_PCMPESTR))\n+   (set (reg:CC FLAGS_REG)\n+\t(unspec:CC\n+\t  [(match_dup 2)\n+\t   (match_dup 3)\n+\t   (match_dup 4)\n+\t   (match_dup 5)\n+\t   (match_dup 6)]\n+\t  UNSPEC_PCMPESTR))]\n+  \"TARGET_SSE4_2\n+   && !(reload_completed || reload_in_progress)\"\n+  \"#\"\n+  \"&& 1\"\n+  [(const_int 0)]\n+{\n+  int ecx = !find_regno_note (curr_insn, REG_UNUSED, REGNO (operands[0]));\n+  int xmm0 = !find_regno_note (curr_insn, REG_UNUSED, REGNO (operands[1]));\n+  int flags = !find_regno_note (curr_insn, REG_UNUSED, FLAGS_REG);\n+\n+  if (ecx)\n+    emit_insn (gen_sse4_2_pcmpestri (operands[0], operands[2],\n+\t\t\t\t     operands[3], operands[4],\n+\t\t\t\t     operands[5], operands[6]));\n+  if (xmm0)\n+    emit_insn (gen_sse4_2_pcmpestrm (operands[1], operands[2],\n+\t\t\t\t     operands[3], operands[4],\n+\t\t\t\t     operands[5], operands[6]));\n+  if (flags && !(ecx || xmm0))\n+    emit_insn (gen_sse4_2_pcmpestr_cconly (operands[2], operands[3],\n+\t\t\t\t\t   operands[4], operands[5],\n+\t\t\t\t\t   operands[6]));\n+  DONE;\n+}\n+  [(set_attr \"type\" \"sselog\")\n+   (set_attr \"prefix_data16\" \"1\")\n+   (set_attr \"prefix_extra\" \"1\")\n+   (set_attr \"memory\" \"none,load\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+(define_insn \"sse4_2_pcmpestri\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=c,c\")\n+\t(unspec:SI\n+\t  [(match_operand:V16QI 1 \"register_operand\" \"x,x\")\n+\t   (match_operand:SI 2 \"register_operand\" \"a,a\")\n+\t   (match_operand:V16QI 3 \"nonimmediate_operand\" \"x,m\")\n+\t   (match_operand:SI 4 \"register_operand\" \"d,d\")\n+\t   (match_operand:SI 5 \"const_0_to_255_operand\" \"n,n\")]\n+\t  UNSPEC_PCMPESTR))\n+   (set (reg:CC FLAGS_REG)\n+\t(unspec:CC\n+\t  [(match_dup 1)\n+\t   (match_dup 2)\n+\t   (match_dup 3)\n+\t   (match_dup 4)\n+\t   (match_dup 5)]\n+\t  UNSPEC_PCMPESTR))]\n+  \"TARGET_SSE4_2\"\n+  \"pcmpestri\\t{%5, %3, %1|%1, %3, %5}\"\n+  [(set_attr \"type\" \"sselog\")\n+   (set_attr \"prefix_data16\" \"1\")\n+   (set_attr \"prefix_extra\" \"1\")\n+   (set_attr \"memory\" \"none,load\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+(define_insn \"sse4_2_pcmpestrm\"\n+  [(set (match_operand:V16QI 0 \"register_operand\" \"=z,z\")\n+\t(unspec:V16QI\n+\t  [(match_operand:V16QI 1 \"register_operand\" \"x,x\")\n+\t   (match_operand:SI 2 \"register_operand\" \"a,a\")\n+\t   (match_operand:V16QI 3 \"nonimmediate_operand\" \"x,m\")\n+\t   (match_operand:SI 4 \"register_operand\" \"d,d\")\n+\t   (match_operand:SI 5 \"const_0_to_255_operand\" \"n,n\")]\n+\t  UNSPEC_PCMPESTR))\n+   (set (reg:CC FLAGS_REG)\n+\t(unspec:CC\n+\t  [(match_dup 1)\n+\t   (match_dup 2)\n+\t   (match_dup 3)\n+\t   (match_dup 4)\n+\t   (match_dup 5)]\n+\t  UNSPEC_PCMPESTR))]\n+  \"TARGET_SSE4_2\"\n+  \"pcmpestrm\\t{%5, %3, %1|%1, %3, %5}\"\n+  [(set_attr \"type\" \"sselog\")\n+   (set_attr \"prefix_data16\" \"1\")\n+   (set_attr \"prefix_extra\" \"1\")\n+   (set_attr \"memory\" \"none,load\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+(define_insn \"sse4_2_pcmpestr_cconly\"\n+  [(set (reg:CC FLAGS_REG)\n+\t(unspec:CC\n+\t  [(match_operand:V16QI 0 \"register_operand\" \"x,x,x,x\")\n+\t   (match_operand:SI 1 \"register_operand\" \"a,a,a,a\")\n+\t   (match_operand:V16QI 2 \"nonimmediate_operand\" \"x,m,x,m\")\n+\t   (match_operand:SI 3 \"register_operand\" \"d,d,d,d\")\n+\t   (match_operand:SI 4 \"const_0_to_255_operand\" \"n,n,n,n\")]\n+\t  UNSPEC_PCMPESTR))\n+   (clobber (match_scratch:SI    5 \"=c,c,X,X\"))\n+   (clobber (match_scratch:V16QI 6 \"=X,X,z,z\"))]\n+  \"TARGET_SSE4_2\"\n+  \"@\n+   pcmpestri\\t{%4, %2, %0|%0, %2, %4}\n+   pcmpestri\\t{%4, %2, %0|%0, %2, %4}\n+   pcmpestrm\\t{%4, %2, %0|%0, %2, %4}\n+   pcmpestrm\\t{%4, %2, %0|%0, %2, %4}\"\n+  [(set_attr \"type\" \"sselog\")\n+   (set_attr \"prefix_data16\" \"1\")\n+   (set_attr \"prefix_extra\" \"1\")\n+   (set_attr \"memory\" \"none,load,none,load\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+(define_insn_and_split \"sse4_2_pcmpistr\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=c,c\")\n+\t(unspec:SI\n+\t  [(match_operand:V16QI 2 \"register_operand\" \"x,x\")\n+\t   (match_operand:V16QI 3 \"nonimmediate_operand\" \"x,m\")\n+\t   (match_operand:SI 4 \"const_0_to_255_operand\" \"n,n\")]\n+\t  UNSPEC_PCMPISTR))\n+   (set (match_operand:V16QI 1 \"register_operand\" \"=z,z\")\n+\t(unspec:V16QI\n+\t  [(match_dup 2)\n+\t   (match_dup 3)\n+\t   (match_dup 4)]\n+\t  UNSPEC_PCMPISTR))\n+   (set (reg:CC FLAGS_REG)\n+\t(unspec:CC\n+\t  [(match_dup 2)\n+\t   (match_dup 3)\n+\t   (match_dup 4)]\n+\t  UNSPEC_PCMPISTR))]\n+  \"TARGET_SSE4_2\n+   && !(reload_completed || reload_in_progress)\"\n+  \"#\"\n+  \"&& 1\"\n+  [(const_int 0)]\n+{\n+  int ecx = !find_regno_note (curr_insn, REG_UNUSED, REGNO (operands[0]));\n+  int xmm0 = !find_regno_note (curr_insn, REG_UNUSED, REGNO (operands[1]));\n+  int flags = !find_regno_note (curr_insn, REG_UNUSED, FLAGS_REG);\n+\n+  if (ecx)\n+    emit_insn (gen_sse4_2_pcmpistri (operands[0], operands[2],\n+\t\t\t\t     operands[3], operands[4]));\n+  if (xmm0)\n+    emit_insn (gen_sse4_2_pcmpistrm (operands[1], operands[2],\n+\t\t\t\t     operands[3], operands[4]));\n+  if (flags && !(ecx || xmm0))\n+    emit_insn (gen_sse4_2_pcmpistr_cconly (operands[2], operands[3],\n+\t\t\t\t\t   operands[4]));\n+  DONE;\n+}\n+  [(set_attr \"type\" \"sselog\")\n+   (set_attr \"prefix_data16\" \"1\")\n+   (set_attr \"prefix_extra\" \"1\")\n+   (set_attr \"memory\" \"none,load\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+(define_insn \"sse4_2_pcmpistri\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=c,c\")\n+\t(unspec:SI\n+\t  [(match_operand:V16QI 1 \"register_operand\" \"x,x\")\n+\t   (match_operand:V16QI 2 \"nonimmediate_operand\" \"x,m\")\n+\t   (match_operand:SI 3 \"const_0_to_255_operand\" \"n,n\")]\n+\t  UNSPEC_PCMPISTR))\n+   (set (reg:CC FLAGS_REG)\n+\t(unspec:CC\n+\t  [(match_dup 1)\n+\t   (match_dup 2)\n+\t   (match_dup 3)]\n+\t  UNSPEC_PCMPISTR))]\n+  \"TARGET_SSE4_2\"\n+  \"pcmpistri\\t{%3, %2, %1|%1, %2, %3}\"\n+  [(set_attr \"type\" \"sselog\")\n+   (set_attr \"prefix_data16\" \"1\")\n+   (set_attr \"prefix_extra\" \"1\")\n+   (set_attr \"memory\" \"none,load\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+(define_insn \"sse4_2_pcmpistrm\"\n+  [(set (match_operand:V16QI 0 \"register_operand\" \"=z,z\")\n+\t(unspec:V16QI\n+\t  [(match_operand:V16QI 1 \"register_operand\" \"x,x\")\n+\t   (match_operand:V16QI 2 \"nonimmediate_operand\" \"x,m\")\n+\t   (match_operand:SI 3 \"const_0_to_255_operand\" \"n,n\")]\n+\t  UNSPEC_PCMPISTR))\n+   (set (reg:CC FLAGS_REG)\n+\t(unspec:CC\n+\t  [(match_dup 1)\n+\t   (match_dup 2)\n+\t   (match_dup 3)]\n+\t  UNSPEC_PCMPISTR))]\n+  \"TARGET_SSE4_2\"\n+  \"pcmpistrm\\t{%3, %2, %1|%1, %2, %3}\"\n+  [(set_attr \"type\" \"sselog\")\n+   (set_attr \"prefix_data16\" \"1\")\n+   (set_attr \"prefix_extra\" \"1\")\n+   (set_attr \"memory\" \"none,load\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+(define_insn \"sse4_2_pcmpistr_cconly\"\n+  [(set (reg:CC FLAGS_REG)\n+\t(unspec:CC\n+\t  [(match_operand:V16QI 0 \"register_operand\" \"x,x,x,x\")\n+\t   (match_operand:V16QI 1 \"nonimmediate_operand\" \"x,m,x,m\")\n+\t   (match_operand:SI 2 \"const_0_to_255_operand\" \"n,n,n,n\")]\n+\t  UNSPEC_PCMPISTR))\n+   (clobber (match_scratch:SI    3 \"=c,c,X,X\"))\n+   (clobber (match_scratch:V16QI 4 \"=X,X,z,z\"))]\n+  \"TARGET_SSE4_2\"\n+  \"@\n+   pcmpistri\\t{%2, %1, %0|%0, %1, %2}\n+   pcmpistri\\t{%2, %1, %0|%0, %1, %2}\n+   pcmpistrm\\t{%2, %1, %0|%0, %1, %2}\n+   pcmpistrm\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"type\" \"sselog\")\n+   (set_attr \"prefix_data16\" \"1\")\n+   (set_attr \"prefix_extra\" \"1\")\n+   (set_attr \"memory\" \"none,load,none,load\")\n+   (set_attr \"mode\" \"TI\")])"}]}