{"sha": "5d5bb9bc26bbd714ef81a7eb91e77e312582ccdc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ1YmI5YmMyNmJiZDcxNGVmODFhN2ViOTFlNzdlMzEyNTgyY2NkYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-07-29T18:50:25Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-07-29T18:50:25Z"}, "message": "Fix inchash handling of wide_ints (PR91242)\n\ninchash::hash::add_wide_int operated directly on the raw encoding\nof the wide_int, including any redundant upper bits.  The problem\nwith that is that the upper bits are only defined for some wide-int\nstorage types (including wide_int itself).  wi::to_wide(tree) instead\nreturns a value that is extended according to the signedness of the\ntype (so that wi::to_widest can use the same encoding) while rtxes\nhave the awkward special case of BI, which can be zero-extended\nrather than sign-extended.\n\nIn the PR, we computed a hash for a \"normal\" sign-extended wide_int\nwhile the existing entries hashed wi::to_wide(tree).  This gives\ndifferent results for unsigned types that have the top bit set.\n\nThe patch fixes that by hashing the canonical sign-extended form even\nif the raw encoding happens to be different.\n\n2019-07-29  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* wide-int.h (generic_wide_int::sext_elt): New function.\n\t* inchash.h (hash::add_wide_int): Use it instead of elt.\n\nFrom-SVN: r273881", "tree": {"sha": "83bf374fb969d0c189428c6b47e87b52b4cff13f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83bf374fb969d0c189428c6b47e87b52b4cff13f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d5bb9bc26bbd714ef81a7eb91e77e312582ccdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d5bb9bc26bbd714ef81a7eb91e77e312582ccdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d5bb9bc26bbd714ef81a7eb91e77e312582ccdc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d5bb9bc26bbd714ef81a7eb91e77e312582ccdc/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5c6aa9a8919cbf0dcf3c375f51012720bfb5f3a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c6aa9a8919cbf0dcf3c375f51012720bfb5f3a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c6aa9a8919cbf0dcf3c375f51012720bfb5f3a1"}], "stats": {"total": 25, "additions": 24, "deletions": 1}, "files": [{"sha": "7f3dfa7a3b4d583435c5eecab7db2f9cac1667a7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d5bb9bc26bbd714ef81a7eb91e77e312582ccdc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d5bb9bc26bbd714ef81a7eb91e77e312582ccdc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5d5bb9bc26bbd714ef81a7eb91e77e312582ccdc", "patch": "@@ -1,3 +1,8 @@\n+2019-07-29  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* wide-int.h (generic_wide_int::sext_elt): New function.\n+\t* inchash.h (hash::add_wide_int): Use it instead of elt.\n+\n 2019-07-29  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/arm/arm-builtins.c (acle_builtin_data): Expand VAR1 to"}, {"sha": "56588d27dafe4c3cf4b8ab1e7f425542e892fa33", "filename": "gcc/inchash.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d5bb9bc26bbd714ef81a7eb91e77e312582ccdc/gcc%2Finchash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d5bb9bc26bbd714ef81a7eb91e77e312582ccdc/gcc%2Finchash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finchash.h?ref=5d5bb9bc26bbd714ef81a7eb91e77e312582ccdc", "patch": "@@ -85,7 +85,7 @@ class hash\n   {\n     add_int (x.get_len ());\n     for (unsigned i = 0; i < x.get_len (); i++)\n-      add_hwi (x.elt (i));\n+      add_hwi (x.sext_elt (i));\n   }\n \n   /* Hash in pointer PTR.  */"}, {"sha": "862079a854922e7970e7759e165f5be4d0158e0b", "filename": "gcc/wide-int.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d5bb9bc26bbd714ef81a7eb91e77e312582ccdc/gcc%2Fwide-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d5bb9bc26bbd714ef81a7eb91e77e312582ccdc/gcc%2Fwide-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int.h?ref=5d5bb9bc26bbd714ef81a7eb91e77e312582ccdc", "patch": "@@ -730,6 +730,7 @@ class GTY(()) generic_wide_int : public storage\n   /* Public accessors for the interior of a wide int.  */\n   HOST_WIDE_INT sign_mask () const;\n   HOST_WIDE_INT elt (unsigned int) const;\n+  HOST_WIDE_INT sext_elt (unsigned int) const;\n   unsigned HOST_WIDE_INT ulow () const;\n   unsigned HOST_WIDE_INT uhigh () const;\n   HOST_WIDE_INT slow () const;\n@@ -909,6 +910,23 @@ generic_wide_int <storage>::elt (unsigned int i) const\n     return this->get_val ()[i];\n }\n \n+/* Like elt, but sign-extend beyond the upper bit, instead of returning\n+   the raw encoding.  */\n+template <typename storage>\n+inline HOST_WIDE_INT\n+generic_wide_int <storage>::sext_elt (unsigned int i) const\n+{\n+  HOST_WIDE_INT elt_i = elt (i);\n+  if (!is_sign_extended)\n+    {\n+      unsigned int precision = this->get_precision ();\n+      unsigned int lsb = i * HOST_BITS_PER_WIDE_INT;\n+      if (precision - lsb < HOST_BITS_PER_WIDE_INT)\n+\telt_i = sext_hwi (elt_i, precision - lsb);\n+    }\n+  return elt_i;\n+}\n+\n template <typename storage>\n template <typename T>\n inline generic_wide_int <storage> &"}]}