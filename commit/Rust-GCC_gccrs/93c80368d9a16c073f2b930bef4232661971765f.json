{"sha": "93c80368d9a16c073f2b930bef4232661971765f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNjODAzNjhkOWExNmMwNzNmMmI5MzBiZWY0MjMyNjYxOTcxNzY1Zg==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-10-28T17:59:06Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-10-28T17:59:06Z"}, "message": "New macro expander.\n\n2000-10-28  Neil Booth  <neilb@earthling.net>\n\n\tNew macro expander.\n\n\t* cpplib.c (struct answer): New.\n\t(struct if_stack): Use cpp_lexer_pos rather than line and col.\n\tRename cmacro mi_cmacro.\n\t(struct directive, KANDR, STDC89, EXTENSION, COND, IF_COND, INCL,\n\tIN_I): New directive and flags.\n\t(skip_rest_of_line, check_eol, run_directive, glue_header_name,\n\tparse_answer, parse_assertion, find_answer): New functions.\n\t(parse_ifdef, detect_if_not_defined, validate_else): Remove.\n\t(lex_macro_node): New function to replace parse_ifdef and\n\tget_define_node.\n\n\t(_cpp_handle_directive): New function, combines _cpp_check_directive\n\tand _cpp_check_linemarker.\n\n\t(do_define, do_undef, parse_include, do_include, do_import,\n\tdo_include_next, read_line_number, do_line, do_ident, do_pragma,\n\tdo_pragma_once, do_pragma_poison, do_pragma_dependency):\n\tUpdate for new token getting interface.\n\n\t(do_ifdef, do_ifndef, do_if, do_else, do_endif, push_conditional)\n\t: Update for new multiple-include optimisation technique.\n\t(do_elif): Don't forget to invalidate controlling macros.\n\n\t(unwind_if_stack, cpp_defined, cpp_push_buffer, cpp_pop_buffer): Update.\n\t(parse_assertion, parse_answer, find_answer, _cpp_test_assertion):\n\tFunctions to handle assertions with the new token interface.\n\t(do_assert, do_unassert): Use them.\n\n\t(cpp_define, _cpp_define_builtin, cpp_undef, cpp_assert, cpp_unassert):\n\tUse run_directive.\n\n\t(_cpp_init_stacks): Register directive names.  Don't register special\n\tnodes.\n\n\t* cpperror.c (print_containing_files, _cpp_begin_message): Update to\n\tnew position recording regime.\n\t(cpp_ice, cpp_fatal, cpp_error, cpp_error_with_line, cpp_warning,\n\tcpp_warning_with_line, cpp_pedwarn, cpp_pedwarn_with_line,\n\tcpp_pedwarn_with_file_and_line): Update for _cpp_begin_message changes.\n\t(cpp_type2name): Move to cpplex.c.\n\n\t* cppexp.c (parse_charconst): spec_nodes is no longer a pointer.\n\t(parse_defined): Update to handle new multiple include optimisation\n\tmethod.  Remove poisoned identifier warning.\n\t(parse_assertion, TYPE_NAME): Delete.\n\t(lex): Update for multiple include optimisation, removal of\n\tCPP_DEFINED, to use _cpp_test_assertion for assertions and\n\tcpp_token_as_text.\n\t(_cpp_parse_expr): Update for MI optimisation, and to use op_as_text.\n\t(op_as_text): New function, to wrap cpp_token_as_text.\n\n\t* cppfiles.c (stack_include_file, _cpp_pop_file_buffer):\n\tUpdate for MI optimisation.\n\t(_cpp_execute_include): Take a token rather than 3 arguments.  Fix\n\tsegfault on diagnostic.\n\t(_cpp_compare_file_date): Take a token rather than 3 args.\n\t(cpp_read_file): Work correctly for zero-length files.\n\n\t* cpphash.c (_cpp_init_macros, _cpp_cleanup_macros): Rename\n\t_cpp_init_hashtable and _cpp_cleanup_hashtable.\n\t(cpp_lookup): Place identifiers at front of identifier pool\n\tfor _cpp_lookup_with_hash.\n\t(_cpp_lookup_with_hash): Require identifiers to be at the front of\n\tthe identifier pool.  Commit the memory if not already in the\n\thash table.\n\n\t* cppinit.c (cpp_reader_init): Move cpp_init_completed test to top.\n\tInitialise various members of cpp_reader, memory pools, and the\n\tspecial nodes.\n\t(cpp_printer_init): Delete.\n\t(cpp_cleanup): Update.\n\t(struct builtin, builtin_array, initialize_builtins): Update for new\n\thashnode definition and builtin handling.\n\t(cpp_start_read, cpp_finish): Don't take or initialise a\n\tprinter.  Update.\n\n\t* cpplib.h (cpp_printer, cpp_toklist, CPP_DEFINED, BOL,\n\tPASTED, VAR_ARGS, BEG_OF_FILE, IN_DIRECTIVE, KNOWN_DIRECTIVE,\n\tT_VOID, T_SPECLINE, T_DATE, T_FILE, T_BASE_FILE, T_INCLUDE_LEVEL,\n\tT_TIME, T_STDC, T_OPERATOR, T_POISON, T_MACRO, T_ASSERTION): Delete.\n\t(struct cpp_pool, struct cpp_macro, struct cpp_lexer_pos,\n\tstruct cpp_lookahead, CPP_DHASH, enum mi_state, enum mi_ind,\n\tNO_EXPAND, VARARGS_FIRST, struct cpp_token_with_pos,\n\tstruct toklist, struct cpp_context, struct specnodes,\n\tTOKEN_LOOKAHEAD, TOKEN_BUFFSIZE, NODE_OPERATOR, NODE_POISONED,\n\tNODE_BUILTIN, NODE_DIAGNOSTIC, NT_VOID, NT_MACRO, NT_ASSERTION,\n\tenum builtin_type, cpp_can_paste): New.\n\t(struct cpp_token): Delete line and col members.\n\t(struct cpp_buffer): New member output_lineno.\n\t(struct lexer_state): Delete indented, in_lex_line, seen_dot.\n\tAdd va_args_ok, poisoned_ok, prevent_expansion, parsing_args.\n\t(struct cpp_reader): New members lexer_pos, macro_pos, directive_pos,\n\tident_pool, temp_string_pool, macro_pool, argument_pool, string_pool,\n\tbase_context, context, directive, mi_state, mi_if_not_defined,\n\tmi_lexed, mi_cmacro, mi_ind_cmacro, la_read, la_write, la_unused,\n\tmlstring_pos, macro_buffer, macro_buffer_len.\n\tDelete members mls_line, mls_column, token_list, potential_control_macro,\n\ttemp_tokens, temp_cap, temp_alloced, temp_used, first_directive_token,\n\tcontext_cap, cur_context, no_expand_level, paste_level, contexts, args,\n\tsave_parameter_spellings, need_newline, .\n\tChange type of date, time and spec_nodes members.\n\tChange prototypes for include and ident callbacks.\n\t(struct cpp_hashnode): Change type of name.  Remove union members\n\texpansion and code.  Add members macro, operator and builtin.\n\n\t(cpp_token_len, cpp_token_as_text, cpp_spell_token, cpp_start_read,\n\tcpp_finish, cpp_avoid_paste, cpp_get_token, cpp_get_line,\n\tcpp_get_output_line, cpp_macro_definition, cpp_start_lookahead,\n\tcpp_stop_lookahead): New prototypes.\n\t(cpp_printer_init, cpp_dump_definition): Delete prototypes.\n\n\t(U_CHAR, U, ustrcmp, ustrncmp, ustrlen, uxstrdup, ustrchr, ufputs):\n\tMove from cpphash.h.\n\n\t* cpphash.h (U_CHAR, U, ustrcmp, ustrncmp, ustrlen, uxstrdup, ustrchr,\n\tufputs): Move to cpplib.h.\n\t(enum spell_type, struct token_spelling, _cpp_token_spellings, TOKEN_SPELL,\n\tTOKEN_NAME, struct answer, FREE_ANSWER, KANDR, STDC89, EXTENSION,\n\tCOND, EXPAND, INCL, COMMENTS, IN_I, struct directive, directive_handler,\n\tstruct spec_nodes, _cpp_digraph_spellings, _cpp_free_temp_tokens,\n\t_cpp_init_input_buffer, _cpp_grow_token_buffer, _cpp_init_toklist,\n\t_cpp_clear_toklist, _cpp_expand_token_space, _cpp_expand_name_space,\n\t_cpp_equiv_tokens, _cpp_equiv_toklists, _cpp_process_directive,\n\t_cpp_run_directive, _cpp_get_line, _cpp_get_raw_token, _cpp_glue_header_name,\n\t_cpp_can_paste, _cpp_check_directive, _cpp_check_linemarker,\n\t_cpp_parse_assertion, _cpp_find_answer): Delete.\n\t(VALID_SIGN, ALIGN, POOL_FRONT, POOL_LIMIT, POOL_BASE, POOL_SIZE,\n\tPOOL_USED, POOL_COMMIT, struct cpp_chunk, _cpp_lex_token, _cpp_init_pool,\n\t_cpp_free_pool, _cpp_pool_reserve, _cpp_pool_alloc, _cpp_next_chunk,\n\t_cpp_lock_pool, _cpp_unlock_pool, _cpp_test_assertion,\n\t_cpp_handle_directive, DSC): New.\n\t(struct include_file): New member defined.\n\n\t(DO_NOT_REREAD, _cpp_begin_message, _cpp_execute_include,\n\t_cpp_compare_file_date): Update.\n\t(_cpp_pop_context, _cpp_get_token, _cpp_free_lookaheads, _cpp_push_token): New.\n\t(_cpp_init_macros, _cpp_cleanup_macros): Rename to _cpp_init_hashtable,\n\t_cpp_cleanup_hashtable.\n\n\t* Makefile.in: Remove cppoutput.c.\n\n\t* cppoutput.c: Delete\n\n\t* fixheader.c (read_scan_file): Update for new cpp_get_token\n\tprototype.\n\t(recognized_function): New argument LINE.\n\n\t* scan-decls.c (skip_to_closing_brace, scan_decls): Update for\n\tnew cpp_get_token prototype.\n\n\t* scan.h (recognized_function): Update prototype.\n\n\t* po/POTFILES.in: Remove cppoutput.c.\n\nFrom-SVN: r37098", "tree": {"sha": "b1f50a88de9fbdd6a784d0c03fa8cd31e4ac5916", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1f50a88de9fbdd6a784d0c03fa8cd31e4ac5916"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93c80368d9a16c073f2b930bef4232661971765f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93c80368d9a16c073f2b930bef4232661971765f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93c80368d9a16c073f2b930bef4232661971765f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93c80368d9a16c073f2b930bef4232661971765f/comments", "author": null, "committer": null, "parents": [{"sha": "de48b52da8468f94c0bdffc11fa7e8fe49b4ba66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de48b52da8468f94c0bdffc11fa7e8fe49b4ba66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de48b52da8468f94c0bdffc11fa7e8fe49b4ba66"}], "stats": {"total": 8048, "additions": 3914, "deletions": 4134}, "files": [{"sha": "cd5df85fbdc6f7cb1ceb2e06a84950cc19ab8dca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c80368d9a16c073f2b930bef4232661971765f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c80368d9a16c073f2b930bef4232661971765f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=93c80368d9a16c073f2b930bef4232661971765f", "patch": "@@ -1,3 +1,161 @@\n+2000-10-28  Neil Booth  <neilb@earthling.net>\n+\n+\tNew macro expander.\n+\t\n+\t* cpplib.c (struct answer): New.\n+\t(struct if_stack): Use cpp_lexer_pos rather than line and col.\n+\tRename cmacro mi_cmacro.\n+\t(struct directive, KANDR, STDC89, EXTENSION, COND, IF_COND, INCL,\n+\tIN_I): New directive and flags.\n+\t(skip_rest_of_line, check_eol, run_directive, glue_header_name,\n+\tparse_answer, parse_assertion, find_answer): New functions.\n+\t(parse_ifdef, detect_if_not_defined, validate_else): Remove.\n+\t(lex_macro_node): New function to replace parse_ifdef and\n+\tget_define_node.\n+\n+\t(_cpp_handle_directive): New function, combines _cpp_check_directive\n+\tand _cpp_check_linemarker.\n+\n+\t(do_define, do_undef, parse_include, do_include, do_import,\n+\tdo_include_next, read_line_number, do_line, do_ident, do_pragma,\n+\tdo_pragma_once, do_pragma_poison, do_pragma_dependency):\n+\tUpdate for new token getting interface.\n+\n+\t(do_ifdef, do_ifndef, do_if, do_else, do_endif, push_conditional)\n+\t: Update for new multiple-include optimisation technique.\n+\t(do_elif): Don't forget to invalidate controlling macros.\n+\n+\t(unwind_if_stack, cpp_defined, cpp_push_buffer, cpp_pop_buffer): Update.\n+\t(parse_assertion, parse_answer, find_answer, _cpp_test_assertion):\n+\tFunctions to handle assertions with the new token interface.\n+\t(do_assert, do_unassert): Use them.\n+\n+\t(cpp_define, _cpp_define_builtin, cpp_undef, cpp_assert, cpp_unassert):\n+\tUse run_directive.\n+\n+\t(_cpp_init_stacks): Register directive names.  Don't register special\n+\tnodes.\n+\n+\t* cpperror.c (print_containing_files, _cpp_begin_message): Update to\n+\tnew position recording regime.\n+\t(cpp_ice, cpp_fatal, cpp_error, cpp_error_with_line, cpp_warning,\n+\tcpp_warning_with_line, cpp_pedwarn, cpp_pedwarn_with_line,\n+\tcpp_pedwarn_with_file_and_line): Update for _cpp_begin_message changes.\n+\t(cpp_type2name): Move to cpplex.c.\n+\n+\t* cppexp.c (parse_charconst): spec_nodes is no longer a pointer.\n+\t(parse_defined): Update to handle new multiple include optimisation\n+\tmethod.  Remove poisoned identifier warning.\n+\t(parse_assertion, TYPE_NAME): Delete.\n+\t(lex): Update for multiple include optimisation, removal of\n+\tCPP_DEFINED, to use _cpp_test_assertion for assertions and\n+\tcpp_token_as_text.\n+\t(_cpp_parse_expr): Update for MI optimisation, and to use op_as_text.\n+\t(op_as_text): New function, to wrap cpp_token_as_text.\n+\n+\t* cppfiles.c (stack_include_file, _cpp_pop_file_buffer):\n+\tUpdate for MI optimisation.\n+\t(_cpp_execute_include): Take a token rather than 3 arguments.  Fix\n+\tsegfault on diagnostic.\n+\t(_cpp_compare_file_date): Take a token rather than 3 args.\n+\t(cpp_read_file): Work correctly for zero-length files.\n+\n+\t* cpphash.c (_cpp_init_macros, _cpp_cleanup_macros): Rename\n+\t_cpp_init_hashtable and _cpp_cleanup_hashtable.\n+\t(cpp_lookup): Place identifiers at front of identifier pool\n+\tfor _cpp_lookup_with_hash.\n+\t(_cpp_lookup_with_hash): Require identifiers to be at the front of\n+\tthe identifier pool.  Commit the memory if not already in the\n+\thash table.\n+\n+\t* cppinit.c (cpp_reader_init): Move cpp_init_completed test to top.\n+\tInitialise various members of cpp_reader, memory pools, and the\n+\tspecial nodes.\n+\t(cpp_printer_init): Delete.\n+\t(cpp_cleanup): Update.\n+\t(struct builtin, builtin_array, initialize_builtins): Update for new\n+\thashnode definition and builtin handling.\n+\t(cpp_start_read, cpp_finish): Don't take or initialise a\n+\tprinter.  Update.\n+\n+\t* cpplib.h (cpp_printer, cpp_toklist, CPP_DEFINED, BOL,\n+\tPASTED, VAR_ARGS, BEG_OF_FILE, IN_DIRECTIVE, KNOWN_DIRECTIVE,\n+\tT_VOID, T_SPECLINE, T_DATE, T_FILE, T_BASE_FILE, T_INCLUDE_LEVEL,\n+\tT_TIME, T_STDC, T_OPERATOR, T_POISON, T_MACRO, T_ASSERTION): Delete.\n+\t(struct cpp_pool, struct cpp_macro, struct cpp_lexer_pos,\n+\tstruct cpp_lookahead, CPP_DHASH, enum mi_state, enum mi_ind,\n+\tNO_EXPAND, VARARGS_FIRST, struct cpp_token_with_pos,\n+\tstruct toklist, struct cpp_context, struct specnodes,\n+\tTOKEN_LOOKAHEAD, TOKEN_BUFFSIZE, NODE_OPERATOR, NODE_POISONED,\n+\tNODE_BUILTIN, NODE_DIAGNOSTIC, NT_VOID, NT_MACRO, NT_ASSERTION,\n+\tenum builtin_type, cpp_can_paste): New.\n+\t(struct cpp_token): Delete line and col members.\n+\t(struct cpp_buffer): New member output_lineno.\n+\t(struct lexer_state): Delete indented, in_lex_line, seen_dot.\n+\tAdd va_args_ok, poisoned_ok, prevent_expansion, parsing_args.\n+\t(struct cpp_reader): New members lexer_pos, macro_pos, directive_pos,\n+\tident_pool, temp_string_pool, macro_pool, argument_pool, string_pool,\n+\tbase_context, context, directive, mi_state, mi_if_not_defined,\n+\tmi_lexed, mi_cmacro, mi_ind_cmacro, la_read, la_write, la_unused,\n+\tmlstring_pos, macro_buffer, macro_buffer_len.\n+\tDelete members mls_line, mls_column, token_list, potential_control_macro,\n+\ttemp_tokens, temp_cap, temp_alloced, temp_used, first_directive_token,\n+\tcontext_cap, cur_context, no_expand_level, paste_level, contexts, args,\n+\tsave_parameter_spellings, need_newline, .\n+\tChange type of date, time and spec_nodes members.\n+\tChange prototypes for include and ident callbacks.\n+\t(struct cpp_hashnode): Change type of name.  Remove union members\n+\texpansion and code.  Add members macro, operator and builtin.\n+\n+\t(cpp_token_len, cpp_token_as_text, cpp_spell_token, cpp_start_read,\n+\tcpp_finish, cpp_avoid_paste, cpp_get_token, cpp_get_line,\n+\tcpp_get_output_line, cpp_macro_definition, cpp_start_lookahead,\n+\tcpp_stop_lookahead): New prototypes.\n+\t(cpp_printer_init, cpp_dump_definition): Delete prototypes.\n+\n+\t(U_CHAR, U, ustrcmp, ustrncmp, ustrlen, uxstrdup, ustrchr, ufputs):\n+\tMove from cpphash.h.\n+\n+\t* cpphash.h (U_CHAR, U, ustrcmp, ustrncmp, ustrlen, uxstrdup, ustrchr,\n+\tufputs): Move to cpplib.h.\n+\t(enum spell_type, struct token_spelling, _cpp_token_spellings, TOKEN_SPELL,\n+\tTOKEN_NAME, struct answer, FREE_ANSWER, KANDR, STDC89, EXTENSION,\n+\tCOND, EXPAND, INCL, COMMENTS, IN_I, struct directive, directive_handler,\n+\tstruct spec_nodes, _cpp_digraph_spellings, _cpp_free_temp_tokens,\n+\t_cpp_init_input_buffer, _cpp_grow_token_buffer, _cpp_init_toklist,\n+\t_cpp_clear_toklist, _cpp_expand_token_space, _cpp_expand_name_space,\n+\t_cpp_equiv_tokens, _cpp_equiv_toklists, _cpp_process_directive,\n+\t_cpp_run_directive, _cpp_get_line, _cpp_get_raw_token, _cpp_glue_header_name,\n+\t_cpp_can_paste, _cpp_check_directive, _cpp_check_linemarker,\n+\t_cpp_parse_assertion, _cpp_find_answer): Delete.\n+\t(VALID_SIGN, ALIGN, POOL_FRONT, POOL_LIMIT, POOL_BASE, POOL_SIZE,\n+\tPOOL_USED, POOL_COMMIT, struct cpp_chunk, _cpp_lex_token, _cpp_init_pool,\n+\t_cpp_free_pool, _cpp_pool_reserve, _cpp_pool_alloc, _cpp_next_chunk,\n+\t_cpp_lock_pool, _cpp_unlock_pool, _cpp_test_assertion,\n+\t_cpp_handle_directive, DSC): New.\n+\t(struct include_file): New member defined.\n+\n+\t(DO_NOT_REREAD, _cpp_begin_message, _cpp_execute_include,\n+\t_cpp_compare_file_date): Update.\n+\t(_cpp_pop_context, _cpp_get_token, _cpp_free_lookaheads, _cpp_push_token): New.\n+\t(_cpp_init_macros, _cpp_cleanup_macros): Rename to _cpp_init_hashtable,\n+\t_cpp_cleanup_hashtable.\n+\n+\t* Makefile.in: Remove cppoutput.c.\n+\t\n+\t* cppoutput.c: Delete\n+\n+\t* fixheader.c (read_scan_file): Update for new cpp_get_token\n+\tprototype.\n+\t(recognized_function): New argument LINE.\n+\n+\t* scan-decls.c (skip_to_closing_brace, scan_decls): Update for\n+\tnew cpp_get_token prototype.\n+\n+\t* scan.h (recognized_function): Update prototype.\n+\n+\t* po/POTFILES.in: Remove cppoutput.c.\n+\t\n 2000-10-27  Mark Mitchell  <mark@codesourcery.com>\n \n \t* c-typeck.c (check_init_type_bitfields): Remove."}, {"sha": "27561cd9956e2fa1cd1ec1af4978d250190289c0", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c80368d9a16c073f2b930bef4232661971765f/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c80368d9a16c073f2b930bef4232661971765f/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=93c80368d9a16c073f2b930bef4232661971765f", "patch": "@@ -1841,7 +1841,7 @@ PREPROCESSOR_DEFINES = \\\n   -DTOOL_INCLUDE_DIR=\\\"$(gcc_tooldir)/include\\\"\n \n LIBCPP_OBJS =\tcpplib.o cpplex.o cppmacro.o cppexp.o cppfiles.o \\\n-\t\tcpphash.o cpperror.o cppinit.o cppdefault.o cppoutput.o \\\n+\t\tcpphash.o cpperror.o cppinit.o cppdefault.o \\\n \t\tmkdeps.o prefix.o version.o mbchar.o\n \n LIBCPP_DEPS =\tcpplib.h cpphash.h intl.h system.h\n@@ -1863,7 +1863,6 @@ cpperror.o: cpperror.c $(CONFIG_H) $(LIBCPP_DEPS)\n cppexp.o:   cppexp.c   $(CONFIG_H) $(LIBCPP_DEPS) defaults.h\n cpplex.o:   cpplex.c   $(CONFIG_H) $(LIBCPP_DEPS)\n cppmacro.o: cppmacro.c $(CONFIG_H) $(LIBCPP_DEPS)\n-cppoutput.o: cppoutput.c $(CONFIG_H) $(LIBCPP_DEPS)\n cpplib.o:   cpplib.c   $(CONFIG_H) $(LIBCPP_DEPS) $(OBSTACK_H)\n cpphash.o:  cpphash.c  $(CONFIG_H) $(LIBCPP_DEPS) $(OBSTACK_H)\n cppfiles.o: cppfiles.c $(CONFIG_H) $(LIBCPP_DEPS) $(SPLAY_TREE_H) mkdeps.h"}, {"sha": "d598fbd78a438978d26c70fd0f6b840619babd9b", "filename": "gcc/cpperror.c", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c80368d9a16c073f2b930bef4232661971765f/gcc%2Fcpperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c80368d9a16c073f2b930bef4232661971765f/gcc%2Fcpperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpperror.c?ref=93c80368d9a16c073f2b930bef4232661971765f", "patch": "@@ -57,11 +57,10 @@ print_containing_files (pfile, ip)\n       if (first)\n \t{\n \t  first = 0;\n-\t  /* N.B. The current line in each outer source file is one\n-\t     greater than the line of the #include, so we must\n-\t     subtract one to correct for that.  */\n+\t  /* The current line in each outer source file is now the\n+\t     same as the line of the #include.  */\n \t  fprintf (stderr,  _(\"In file included from %s:%u\"),\n-\t\t   ip->nominal_fname, CPP_BUF_LINE (ip) - 1);\n+\t\t   ip->nominal_fname, CPP_BUF_LINE (ip));\n \t}\n       else\n \t/* Translators note: this message is used in conjunction\n@@ -107,12 +106,11 @@ print_file_and_line (filename, line, column)\n    If it returns 0, this error has been suppressed.  */\n \n int\n-_cpp_begin_message (pfile, code, file, line, col)\n+_cpp_begin_message (pfile, code, file, pos)\n      cpp_reader *pfile;\n      enum error_type code;\n      const char *file;\n-     unsigned int line;\n-     unsigned int col;\n+     const cpp_lexer_pos *pos;\n {\n   cpp_buffer *ip = CPP_BUFFER (pfile);\n   int is_warning = 0;\n@@ -177,11 +175,11 @@ _cpp_begin_message (pfile, code, file, line, col)\n     {\n       if (file == NULL)\n \tfile = ip->nominal_fname;\n-      if (line == 0)\n-\tline = _cpp_get_line (pfile, &col);\n+      if (pos == 0)\n+\tpos = cpp_get_line (pfile);\n       print_containing_files (pfile, ip);\n-      print_file_and_line (file, line,\n-\t\t\t   CPP_OPTION (pfile, show_column) ? col : 0);\n+      print_file_and_line (file, pos->line,\n+\t\t\t   CPP_OPTION (pfile, show_column) ? pos->col : 0);\n     }\n   else\n     fprintf (stderr, \"%s: \", progname);\n@@ -213,7 +211,7 @@ cpp_ice VPARAMS ((cpp_reader *pfile, const char *msgid, ...))\n   msgid = va_arg (ap, const char *);\n #endif\n \n-  if (_cpp_begin_message (pfile, ICE, NULL, 0, 0))\n+  if (_cpp_begin_message (pfile, ICE, NULL, 0))\n     v_message (msgid, ap);\n   va_end(ap);\n }\n@@ -240,7 +238,7 @@ cpp_fatal VPARAMS ((cpp_reader *pfile, const char *msgid, ...))\n   msgid = va_arg (ap, const char *);\n #endif\n \n-  if (_cpp_begin_message (pfile, FATAL, NULL, 0, 0))\n+  if (_cpp_begin_message (pfile, FATAL, NULL, 0))\n     v_message (msgid, ap);\n   va_end(ap);\n }\n@@ -261,7 +259,7 @@ cpp_error VPARAMS ((cpp_reader * pfile, const char *msgid, ...))\n   msgid = va_arg (ap, const char *);\n #endif\n \n-  if (_cpp_begin_message (pfile, ERROR, NULL, 0, 0))\n+  if (_cpp_begin_message (pfile, ERROR, NULL, 0))\n     v_message (msgid, ap);\n   va_end(ap);\n }\n@@ -277,6 +275,7 @@ cpp_error_with_line VPARAMS ((cpp_reader *pfile, int line, int column,\n   const char *msgid;\n #endif\n   va_list ap;\n+  cpp_lexer_pos pos;\n   \n   VA_START (ap, msgid);\n   \n@@ -287,7 +286,9 @@ cpp_error_with_line VPARAMS ((cpp_reader *pfile, int line, int column,\n   msgid = va_arg (ap, const char *);\n #endif\n \n-  if (_cpp_begin_message (pfile, ERROR, NULL, line, column))\n+  pos.line = line;\n+  pos.col = column;\n+  if (_cpp_begin_message (pfile, ERROR, NULL, &pos))\n     v_message (msgid, ap);\n   va_end(ap);\n }\n@@ -317,7 +318,7 @@ cpp_warning VPARAMS ((cpp_reader * pfile, const char *msgid, ...))\n   msgid = va_arg (ap, const char *);\n #endif\n \n-  if (_cpp_begin_message (pfile, WARNING, NULL, 0, 0))\n+  if (_cpp_begin_message (pfile, WARNING, NULL, 0))\n     v_message (msgid, ap);\n   va_end(ap);\n }\n@@ -333,6 +334,7 @@ cpp_warning_with_line VPARAMS ((cpp_reader * pfile, int line, int column,\n   const char *msgid;\n #endif\n   va_list ap;\n+  cpp_lexer_pos pos;\n   \n   VA_START (ap, msgid);\n   \n@@ -343,7 +345,9 @@ cpp_warning_with_line VPARAMS ((cpp_reader * pfile, int line, int column,\n   msgid = va_arg (ap, const char *);\n #endif\n \n-  if (_cpp_begin_message (pfile, WARNING, NULL, line, column))\n+  pos.line = line;\n+  pos.col = column;\n+  if (_cpp_begin_message (pfile, WARNING, NULL, &pos))\n     v_message (msgid, ap);\n   va_end(ap);\n }\n@@ -364,7 +368,7 @@ cpp_pedwarn VPARAMS ((cpp_reader * pfile, const char *msgid, ...))\n   msgid = va_arg (ap, const char *);\n #endif\n \n-  if (_cpp_begin_message (pfile, PEDWARN, NULL, 0, 0))\n+  if (_cpp_begin_message (pfile, PEDWARN, NULL, 0))\n     v_message (msgid, ap);\n   va_end(ap);\n }\n@@ -380,6 +384,7 @@ cpp_pedwarn_with_line VPARAMS ((cpp_reader * pfile, int line, int column,\n   const char *msgid;\n #endif\n   va_list ap;\n+  cpp_lexer_pos pos;\n   \n   VA_START (ap, msgid);\n   \n@@ -390,7 +395,9 @@ cpp_pedwarn_with_line VPARAMS ((cpp_reader * pfile, int line, int column,\n   msgid = va_arg (ap, const char *);\n #endif\n \n-  if (_cpp_begin_message (pfile, PEDWARN, NULL, line, column))\n+  pos.line = line;\n+  pos.col = column;\n+  if (_cpp_begin_message (pfile, PEDWARN, NULL, &pos))\n     v_message (msgid, ap);\n   va_end(ap);\n }\n@@ -411,6 +418,7 @@ cpp_pedwarn_with_file_and_line VPARAMS ((cpp_reader *pfile,\n   const char *msgid;\n #endif\n   va_list ap;\n+  cpp_lexer_pos pos;\n   \n   VA_START (ap, msgid);\n \n@@ -422,7 +430,9 @@ cpp_pedwarn_with_file_and_line VPARAMS ((cpp_reader *pfile,\n   msgid = va_arg (ap, const char *);\n #endif\n \n-  if (_cpp_begin_message (pfile, PEDWARN, file, line, col))\n+  pos.line = line;\n+  pos.col = col;\n+  if (_cpp_begin_message (pfile, PEDWARN, file, &pos))\n     v_message (msgid, ap);\n   va_end(ap);\n }\n@@ -462,11 +472,3 @@ cpp_notice_from_errno (pfile, name)\n     name = \"stdout\";\n   cpp_notice (pfile, \"%s: %s\", name, xstrerror (errno));\n }\n-\n-const char *\n-cpp_type2name (type)\n-     enum cpp_ttype type;\n-{\n-  return (const char *) _cpp_token_spellings[type].name;\n-}\n-"}, {"sha": "566eb15dac8a2a8749f83b6997dda322a25e8ad7", "filename": "gcc/cppexp.c", "status": "modified", "additions": 111, "deletions": 70, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c80368d9a16c073f2b930bef4232661971765f/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c80368d9a16c073f2b930bef4232661971765f/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=93c80368d9a16c073f2b930bef4232661971765f", "patch": "@@ -63,10 +63,10 @@ static HOST_WIDEST_INT right_shift PARAMS ((cpp_reader *, HOST_WIDEST_INT,\n static struct op parse_number PARAMS ((cpp_reader *, const cpp_token *));\n static struct op parse_charconst PARAMS ((cpp_reader *, const cpp_token *));\n static struct op parse_defined PARAMS ((cpp_reader *));\n-static struct op parse_assertion PARAMS ((cpp_reader *));\n static HOST_WIDEST_INT parse_escape PARAMS ((cpp_reader *, const U_CHAR **,\n \t\t\t\t\t     const U_CHAR *, HOST_WIDEST_INT));\n-static struct op lex PARAMS ((cpp_reader *, int));\n+static struct op lex PARAMS ((cpp_reader *, int, cpp_token *));\n+static const unsigned char *op_as_text PARAMS ((cpp_reader *, enum cpp_ttype));\n \n struct op\n {\n@@ -291,7 +291,7 @@ parse_charconst (pfile, tok)\n   /* If char type is signed, sign-extend the constant.  */\n   num_bits = num_chars * width;\n       \n-  if (pfile->spec_nodes->n__CHAR_UNSIGNED__->type != T_VOID\n+  if (pfile->spec_nodes.n__CHAR_UNSIGNED__->type == NT_MACRO\n       || ((result >> (num_bits - 1)) & 1) == 0)\n     op.value = result & ((unsigned HOST_WIDEST_INT) ~0\n \t\t\t >> (HOST_BITS_PER_WIDEST_INT - num_bits));\n@@ -313,85 +313,85 @@ static struct op\n parse_defined (pfile)\n      cpp_reader *pfile;\n {\n-  int paren;\n-  const cpp_token *tok;\n+  int paren = 0;\n+  cpp_hashnode *node = 0;\n+  cpp_token token;\n   struct op op;\n \n-  paren = 0;\n-  tok = _cpp_get_raw_token (pfile);\n-  if (tok->type == CPP_OPEN_PAREN)\n+  /* Don't expand macros.  */\n+  pfile->state.prevent_expansion++;\n+\n+  _cpp_get_token (pfile, &token);\n+  if (token.type == CPP_OPEN_PAREN)\n     {\n       paren = 1;\n-      tok = _cpp_get_raw_token (pfile);\n+      _cpp_get_token (pfile, &token);\n     }\n \n-  if (tok->type != CPP_NAME)\n-    SYNTAX_ERROR (\"\\\"defined\\\" without an identifier\");\n-\n-  if (paren && _cpp_get_raw_token (pfile)->type != CPP_CLOSE_PAREN)\n-    SYNTAX_ERROR (\"missing close paren after \\\"defined\\\"\");\n-\n-  if (tok->val.node->type == T_POISON)\n-    SYNTAX_ERROR2 (\"attempt to use poisoned \\\"%s\\\"\", tok->val.node->name);\n-\n-  op.value = tok->val.node->type != T_VOID;\n-  op.unsignedp = 0;\n-  op.op = CPP_INT;\n-  return op;\n-\n- syntax_error:\n-  op.op = CPP_ERROR;\n-  return op;\n-}\n-\n-static struct op\n-parse_assertion (pfile)\n-     cpp_reader *pfile;\n-{\n-  struct op op;\n-  struct answer *answer;\n-  cpp_hashnode *hp;\n+  if (token.type == CPP_NAME)\n+    {\n+      node = token.val.node;\n+      if (paren)\n+\t{\n+\t  _cpp_get_token (pfile, &token);\n+\t  if (token.type != CPP_CLOSE_PAREN)\n+\t    {\n+\t      cpp_error (pfile, \"missing ')' after \\\"defined\\\"\");\n+\t      node = 0;\n+\t    }\n+\t}\n+    }\n+  else\n+    cpp_error (pfile, \"\\\"defined\\\" without an identifier\");\n \n-  op.op = CPP_ERROR;\n-  hp = _cpp_parse_assertion (pfile, &answer);\n-  if (hp)\n+  if (!node)\n+    op.op = CPP_ERROR;\n+  else\n     {\n-      /* If we get here, the syntax is valid.  */\n-      op.op = CPP_INT;\n+      op.value = node->type == NT_MACRO;\n       op.unsignedp = 0;\n-      op.value = (hp->type == T_ASSERTION &&\n-\t\t  (answer == 0 || *_cpp_find_answer (hp, &answer->list) != 0));\n+      op.op = CPP_INT;\n \n-      if (answer)\n-\tFREE_ANSWER (answer);\n+      /* No macros?  At top of file?  */\n+      if (pfile->mi_state == MI_OUTSIDE && pfile->mi_cmacro == 0\n+\t  && pfile->mi_if_not_defined == MI_IND_NOT && pfile->mi_lexed == 1)\n+\t{\n+\t  cpp_start_lookahead (pfile);\n+\t  cpp_get_token (pfile, &token);\n+\t  if (token.type == CPP_EOF)\n+\t    pfile->mi_ind_cmacro = node;\n+\t  cpp_stop_lookahead (pfile, 0);\n+\t}\n     }\n+\n+  pfile->state.prevent_expansion--;\n   return op;\n }\n \n /* Read one token.  */\n \n static struct op\n-lex (pfile, skip_evaluation)\n+lex (pfile, skip_evaluation, token)\n      cpp_reader *pfile;\n      int skip_evaluation;\n+     cpp_token *token;\n {\n   struct op op;\n-  const cpp_token *tok;\n \n  retry:\n-  tok = _cpp_get_token (pfile);\n+  _cpp_get_token (pfile, token);\n \n-  switch (tok->type)\n+  switch (token->type)\n     {\n     case CPP_PLACEMARKER:\n       goto retry;\n \n     case CPP_INT:\n     case CPP_NUMBER:\n-      return parse_number (pfile, tok);\n+      return parse_number (pfile, token);\n     case CPP_CHAR:\n     case CPP_WCHAR:\n-      return parse_charconst (pfile, tok);\n+      return parse_charconst (pfile, token);\n \n     case CPP_STRING:\n     case CPP_WSTRING:\n@@ -401,36 +401,60 @@ lex (pfile, skip_evaluation)\n       SYNTAX_ERROR (\"floating point numbers are not valid in #if\");\n \n     case CPP_OTHER:\n-      if (ISGRAPH (tok->val.aux))\n-\tSYNTAX_ERROR2 (\"invalid character '%c' in #if\", tok->val.aux);\n+      if (ISGRAPH (token->val.aux))\n+\tSYNTAX_ERROR2 (\"invalid character '%c' in #if\", token->val.aux);\n       else\n-\tSYNTAX_ERROR2 (\"invalid character '\\\\%03o' in #if\", tok->val.aux);\n-\n-    case CPP_DEFINED:\n-      return parse_defined (pfile);\n+\tSYNTAX_ERROR2 (\"invalid character '\\\\%03o' in #if\", token->val.aux);\n \n     case CPP_NAME:\n+      if (token->val.node == pfile->spec_nodes.n_defined)\n+\t{\n+\t  if (pfile->context->prev && CPP_PEDANTIC (pfile))\n+\t    cpp_pedwarn (pfile, \"\\\"defined\\\" operator appears during macro expansion\");\n+\n+\t  return parse_defined (pfile);\n+\t}\n+      /* Controlling #if expressions cannot contain identifiers (they\n+\t could become macros in the future).  */\n+      pfile->mi_state = MI_FAILED;\n+\n       op.op = CPP_INT;\n       op.unsignedp = 0;\n       op.value = 0;\n \n       if (CPP_OPTION (pfile, warn_undef) && !skip_evaluation)\n-\tcpp_warning (pfile, \"\\\"%s\\\" is not defined\", tok->val.node->name);\n+\tcpp_warning (pfile, \"\\\"%s\\\" is not defined\", token->val.node->name);\n+\n       return op;\n \n     case CPP_HASH:\n-      return parse_assertion (pfile);\n+      {\n+\tint temp;\n+\n+\top.op = CPP_INT;\n+\tif (_cpp_test_assertion (pfile, &temp))\n+\t  op.op = CPP_ERROR;\n+\top.unsignedp = 0;\n+\top.value = temp;\n+\treturn op;\n+      }\n+\n+    case CPP_NOT:\n+      /* We don't worry about its position here.  */\n+      pfile->mi_if_not_defined = MI_IND_NOT;\n+      /* Fall through.  */\n \n     default:\n-      if ((tok->type > CPP_EQ && tok->type < CPP_PLUS_EQ)\n-\t  || tok->type == CPP_EOF)\n+      if ((token->type > CPP_EQ && token->type < CPP_PLUS_EQ)\n+\t  || token->type == CPP_EOF)\n \t{\n-\t  op.op = tok->type;\n+\t  op.op = token->type;\n \t  return op;\n \t}\n \n-      SYNTAX_ERROR2(\"'%s' is not valid in #if expressions\", TOKEN_NAME (tok));\n-  }\n+      SYNTAX_ERROR2 (\"\\\"%s\\\" is not valid in #if expressions\",\n+\t\t     cpp_token_as_text (pfile, token));\n+    }\n \n  syntax_error:\n   op.op = CPP_ERROR;\n@@ -709,8 +733,6 @@ op_to_prio[] =\n /* Parse and evaluate a C expression, reading from PFILE.\n    Returns the truth value of the expression.  */\n \n-#define TYPE_NAME(t) _cpp_token_spellings[t].name\n-\n int\n _cpp_parse_expr (pfile)\n      cpp_reader *pfile;\n@@ -729,6 +751,7 @@ _cpp_parse_expr (pfile)\n   struct op init_stack[INIT_STACK_SIZE];\n   struct op *stack = init_stack;\n   struct op *limit = stack + INIT_STACK_SIZE;\n+  cpp_token token;\n   register struct op *top = stack + 1;\n   int skip_evaluation = 0;\n   int result;\n@@ -737,6 +760,10 @@ _cpp_parse_expr (pfile)\n   int save_skipping = pfile->skipping;\n   pfile->skipping = 0;\n \n+  /* Set up detection of #if ! defined().  */\n+  pfile->mi_lexed = 0;\n+  pfile->mi_if_not_defined = MI_IND_NONE;\n+\n   /* We've finished when we try to reduce this.  */\n   top->op = CPP_EOF;\n   /* Nifty way to catch missing '('.  */\n@@ -751,7 +778,8 @@ _cpp_parse_expr (pfile)\n       struct op op;\n \n       /* Read a token */\n-      op = lex (pfile, skip_evaluation);\n+      op = lex (pfile, skip_evaluation, &token);\n+      pfile->mi_lexed++;\n \n       /* If the token is an operand, push its value and get next\n \t token.  If it is an operator, get its priority and flags, and\n@@ -797,7 +825,7 @@ _cpp_parse_expr (pfile)\n \t\tSYNTAX_ERROR (\"void expression between '(' and ')'\");\n \t      else\n \t\tSYNTAX_ERROR2 (\"operator '%s' has no right operand\",\n-\t\t\t       TYPE_NAME (top->op));\n+\t\t\t       op_as_text (pfile, top->op));\n \t    }\n \n \t  unsigned2 = top->unsignedp, v2 = top->value;\n@@ -808,7 +836,8 @@ _cpp_parse_expr (pfile)\n \t  switch (top[1].op)\n \t    {\n \t    default:\n-\t      cpp_ice (pfile, \"impossible operator type %s\", TYPE_NAME (op.op));\n+\t      cpp_ice (pfile, \"impossible operator '%s'\",\n+\t\t\t       op_as_text (pfile, top[1].op));\n \t      goto syntax_error;\n \n \t    case CPP_NOT:\t UNARY(!);\tbreak;\n@@ -967,13 +996,13 @@ _cpp_parse_expr (pfile)\n \t{\n \t  if (top->flags & HAVE_VALUE)\n \t    SYNTAX_ERROR2 (\"missing binary operator before '%s'\",\n-\t\t\t   TYPE_NAME (op.op));\n+\t\t\t   op_as_text (pfile, top->op));\n \t}\n       else\n \t{\n \t  if (!(top->flags & HAVE_VALUE))\n \t    SYNTAX_ERROR2 (\"operator '%s' has no left operand\",\n-\t\t\t   TYPE_NAME (op.op));\n+\t\t\t   op_as_text (pfile, top->op));\n \t}\n \n       /* Check for and handle stack overflow.  */\n@@ -1017,3 +1046,15 @@ _cpp_parse_expr (pfile)\n   pfile->skipping = save_skipping;\n   return result;\n }\n+\n+static const unsigned char *\n+op_as_text (pfile, op)\n+     cpp_reader *pfile;\n+     enum cpp_ttype op;\n+{\n+  cpp_token token;\n+\n+  token.type = op;\n+  token.flags = 0;\n+  return cpp_token_as_text (pfile, &token);\n+}"}, {"sha": "f54fe8a155a2c626aacc7535ff0db8d9c4a8037f", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 39, "deletions": 27, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c80368d9a16c073f2b930bef4232661971765f/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c80368d9a16c073f2b930bef4232661971765f/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=93c80368d9a16c073f2b930bef4232661971765f", "patch": "@@ -217,6 +217,10 @@ stack_include_file (pfile, inc)\n   if (fp == 0)\n     return 0;\n \n+  /* Initialise controlling macro state.  */\n+  pfile->mi_state = MI_OUTSIDE;\n+  pfile->mi_cmacro = 0;\n+\n   fp->inc = inc;\n   fp->nominal_fname = inc->name;\n   fp->buf = inc->buffer;\n@@ -233,8 +237,10 @@ stack_include_file (pfile, inc)\n   fp->inc->refcnt++;\n   pfile->include_depth++;\n   pfile->input_stack_listing_current = 0;\n+\n   if (pfile->cb.enter_file)\n     (*pfile->cb.enter_file) (pfile);\n+\n   return 1;\n }\n \n@@ -562,17 +568,21 @@ report_missing_guard (n, b)\n \n #define PRINT_THIS_DEP(p, b) (CPP_PRINT_DEPS(p) > (b||p->system_include_depth))\n void\n-_cpp_execute_include (pfile, f, len, no_reinclude, search_start, angle_brackets)\n+_cpp_execute_include (pfile, header, no_reinclude, search_start)\n      cpp_reader *pfile;\n-     const U_CHAR *f;\n-     unsigned int len;\n+     const cpp_token *header;\n      int no_reinclude;\n      struct file_name_list *search_start;\n-     int angle_brackets;\n {\n+  unsigned int len = header->val.str.len;\n+  unsigned int angle_brackets = header->type == CPP_HEADER_NAME;\n   struct include_file *inc;\n   char *fname;\n \n+  fname = alloca (len + 1);\n+  memcpy (fname, header->val.str.text, len);\n+  fname[len] = '\\0';\n+\n   if (!search_start)\n     {\n       if (angle_brackets)\n@@ -581,18 +591,14 @@ _cpp_execute_include (pfile, f, len, no_reinclude, search_start, angle_brackets)\n \tsearch_start = CPP_OPTION (pfile, quote_include);\n       else\n \tsearch_start = CPP_BUFFER (pfile)->actual_dir;\n-    }\n \n-  if (!search_start)\n-    {\n-      cpp_error (pfile, \"No include path in which to find %s\", f);\n-      return;\n+      if (!search_start)\n+\t{\n+\t  cpp_error (pfile, \"No include path in which to find %s\", fname);\n+\t  return;\n+\t}\n     }\n \n-  fname = alloca (len + 1);\n-  memcpy (fname, f, len);\n-  fname[len] = '\\0';\n-\n   inc = find_include_file (pfile, fname, search_start);\n \n   if (inc)\n@@ -666,28 +672,25 @@ _cpp_execute_include (pfile, f, len, no_reinclude, search_start, angle_brackets)\n \n /* Locate file F, and determine whether it is newer than PFILE. Return -1,\n    if F cannot be located or dated, 1, if it is newer and 0 if older.  */\n-\n int\n-_cpp_compare_file_date (pfile, f, len, angle_brackets)\n+_cpp_compare_file_date (pfile, f)\n      cpp_reader *pfile;\n-     const U_CHAR *f;\n-     unsigned int len;\n-     int angle_brackets;\n+     const cpp_token *f;\n {\n+  unsigned int len = f->val.str.len;\n   char *fname;\n   struct file_name_list *search_start;\n   struct include_file *inc;\n-  struct include_file *current_include = CPP_BUFFER (pfile)->inc;\n \n-  if (angle_brackets)\n+  if (f->type == CPP_HEADER_NAME)\n     search_start = CPP_OPTION (pfile, bracket_include);\n   else if (CPP_OPTION (pfile, ignore_srcdir))\n     search_start = CPP_OPTION (pfile, quote_include);\n   else\n     search_start = CPP_BUFFER (pfile)->actual_dir;\n \n   fname = alloca (len + 1);\n-  memcpy (fname, f, len);\n+  memcpy (fname, f->val.str.text, len);\n   fname[len] = '\\0';\n   inc = find_include_file (pfile, fname, search_start);\n   \n@@ -699,7 +702,7 @@ _cpp_compare_file_date (pfile, f, len, angle_brackets)\n       inc->fd = -1;\n     }\n     \n-  return inc->st.st_mtime > current_include->st.st_mtime;\n+  return inc->st.st_mtime > CPP_BUFFER (pfile)->inc->st.st_mtime;\n }\n \n \n@@ -723,6 +726,10 @@ cpp_read_file (pfile, fname)\n       return 0;\n     }\n \n+  /* Return success for zero-length files.  */\n+  if (DO_NOT_REREAD (f))\n+    return 1;\n+\n   return stack_include_file (pfile, f);\n }\n \n@@ -739,13 +746,18 @@ _cpp_pop_file_buffer (pfile, buf)\n     pfile->system_include_depth--;\n   if (pfile->include_depth)\n     pfile->include_depth--;\n-  if (pfile->potential_control_macro)\n+  pfile->input_stack_listing_current = 0;\n+\n+  /* Record the inclusion-preventing macro and its definedness.  */\n+  if (pfile->mi_state == MI_OUTSIDE && inc->cmacro != NEVER_REREAD)\n     {\n-      if (inc->cmacro != NEVER_REREAD)\n-\tinc->cmacro = pfile->potential_control_macro;\n-      pfile->potential_control_macro = 0;\n+      /* This could be NULL meaning no controlling macro.  */\n+      inc->cmacro = pfile->mi_cmacro;\n+      inc->defined = 1;\n     }\n-  pfile->input_stack_listing_current = 0;\n+\n+  /* Invalidate control macros in the #including file.  */\n+  pfile->mi_state = MI_FAILED;\n \n   inc->refcnt--;\n   if (inc->refcnt == 0 && DO_NOT_REREAD (inc))"}, {"sha": "1c7366d9746d4c6e92218cbd99f0b49f5349e7ba", "filename": "gcc/cpphash.c", "status": "modified", "additions": 44, "deletions": 40, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c80368d9a16c073f2b930bef4232661971765f/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c80368d9a16c073f2b930bef4232661971765f/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=93c80368d9a16c073f2b930bef4232661971765f", "patch": "@@ -49,7 +49,7 @@ static unsigned long higher_prime_number PARAMS ((unsigned long));\n \n /* Set up and tear down internal structures for macro expansion.  */\n void\n-_cpp_init_macros (pfile)\n+_cpp_init_hashtable (pfile)\n      cpp_reader *pfile;\n {\n   pfile->hash_ob = xnew (struct obstack);\n@@ -63,7 +63,7 @@ _cpp_init_macros (pfile)\n }\n \n void\n-_cpp_cleanup_macros (pfile)\n+_cpp_cleanup_hashtable (pfile)\n      cpp_reader *pfile;\n {\n   cpp_hashnode **p, **limit;\n@@ -101,29 +101,32 @@ cpp_lookup (pfile, name, len)\n   size_t n = len;\n   unsigned int r = 0;\n   const U_CHAR *str = name;\n+  U_CHAR *dest = _cpp_pool_reserve (&pfile->ident_pool, len + 1);\n \n   do\n     {\n       r = HASHSTEP (r, *str);\n-      str++;\n+      *dest++ = *str++;\n     }\n   while (--n);\n+  *dest = '\\0';\n \n-  return _cpp_lookup_with_hash (pfile, name, len, r);\n+  return _cpp_lookup_with_hash (pfile, len, r);\n }\n \n+/* NAME is a null-terminated identifier of length len.  It is assumed\n+   to have been placed at the front of the identifier pool.  */\n cpp_hashnode *\n-_cpp_lookup_with_hash (pfile, name, len, hash)\n+_cpp_lookup_with_hash (pfile, len, hash)\n      cpp_reader *pfile;\n-     const U_CHAR *name;\n      size_t len;\n      unsigned int hash;\n {\n   unsigned int index;\n-  unsigned int hash2;\n   size_t size;\n   cpp_hashnode *entry;\n   cpp_hashnode **entries;\n+  unsigned char *name = POOL_FRONT (&pfile->ident_pool);\n \n   entries = pfile->hashtab->entries;\n   size = pfile->hashtab->size;\n@@ -132,48 +135,49 @@ _cpp_lookup_with_hash (pfile, name, len, hash)\n   index = hash % size;\n \n   entry = entries[index];\n-  if (entry == NULL)\n-    goto insert;\n-  if (entry->hash == hash && entry->length == len\n-      && !memcmp (entry->name, name, len))\n-    return entry;\n-\n-  hash2 = 1 + hash % (size - 2);\n-\n-  for (;;)\n+  if (entry)\n     {\n-      index += hash2;\n-      if (index >= size)\n-\tindex -= size;\n-      entry = entries[index];\n+      unsigned int hash2;\n \n-      if (entry == NULL)\n-\tgoto insert;\n       if (entry->hash == hash && entry->length == len\n \t  && !memcmp (entry->name, name, len))\n \treturn entry;\n+\n+      hash2 = 1 + hash % (size - 2);\n+\n+      for (;;)\n+\t{\n+\t  index += hash2;\n+\t  if (index >= size)\n+\t    index -= size;\n+\t  entry = entries[index];\n+\n+\t  if (entry == NULL)\n+\t    break;\n+\t  if (entry->hash == hash && entry->length == len\n+\t      && !memcmp (entry->name, name, len))\n+\t    return entry;\n+\t}\n     }\n \n- insert:\n-  pfile->hashtab->nelts++;\n+  /* Commit the memory for the identifier.  */\n+  POOL_COMMIT (&pfile->ident_pool, len + 1);\n \n-  /* Create a new hash node.  */\n-  {\n-    U_CHAR *p = obstack_alloc (pfile->hash_ob, sizeof (cpp_hashnode) + len);\n-    entry = (cpp_hashnode *)p;\n-    p += offsetof (cpp_hashnode, name);\n-    \n-    entry->type = T_VOID;\n-    entry->fe_value = 0;\n-    entry->length = len;\n-    entry->hash = hash;\n-    entry->value.expansion = NULL;\n-    memcpy (p, name, len);\n-    p[len] = 0;\n-\n-    entries[index] = entry;\n-  }\n+  /* Create a new hash node and insert it in the table.  */\n+  entries[index] = obstack_alloc (pfile->hash_ob, sizeof (cpp_hashnode));\n \n+  entry = entries[index];\n+  entry->type = NT_VOID;\n+  entry->flags = 0;\n+  entry->fe_value = 0;\n+  entry->directive_index = 0;\n+  entry->arg_index = 0;\n+  entry->length = len;\n+  entry->hash = hash;\n+  entry->name = name;\n+  entry->value.macro = 0;\n+\n+  pfile->hashtab->nelts++;\n   if (size * 3 <= pfile->hashtab->nelts * 4)\n     expand_hash (pfile->hashtab);\n "}, {"sha": "bba1ba91df33ebe4197f5be91c78236069039e4b", "filename": "gcc/cpphash.h", "status": "modified", "additions": 57, "deletions": 182, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c80368d9a16c073f2b930bef4232661971765f/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c80368d9a16c073f2b930bef4232661971765f/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=93c80368d9a16c073f2b930bef4232661971765f", "patch": "@@ -22,68 +22,30 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #ifndef __GCC_CPPHASH__\n #define __GCC_CPPHASH__\n \n-typedef unsigned char U_CHAR;\n-#define U (const U_CHAR *)  /* Intended use: U\"string\" */\n-\n-/* Tokens with SPELL_STRING store their spelling in the token list,\n-   and it's length in the token->val.name.len.  */\n-enum spell_type\n+/* Test if a sign is valid within a preprocessing number.  */\n+#define VALID_SIGN(c, prevc) \\\n+  (((c) == '+' || (c) == '-') && \\\n+   ((prevc) == 'e' || (prevc) == 'E' \\\n+    || (((prevc) == 'p' || (prevc) == 'P') && !CPP_OPTION (pfile, c89))))\n+\n+/* Memory pools.  */\n+#define ALIGN(size, align) (((size) + ((align) - 1)) & ~((align) - 1))\n+#define POOL_FRONT(p) ((p)->cur->front)\n+#define POOL_LIMIT(p) ((p)->cur->limit)\n+#define POOL_BASE(p)  ((p)->cur->base)\n+#define POOL_SIZE(p)  ((p)->cur->limit - (p)->cur->base)\n+#define POOL_ROOM(p)  ((p)->cur->limit - (p)->cur->front)\n+#define POOL_USED(p)  ((p)->cur->front - (p)->cur->base)\n+#define POOL_COMMIT(p, len) do {((p)->cur->front += ALIGN (len, (p)->align));\\\n+  if ((p)->cur->front > (p)->cur->limit) abort ();} while (0)\n+\n+typedef struct cpp_chunk cpp_chunk;\n+struct cpp_chunk\n {\n-  SPELL_OPERATOR = 0,\n-  SPELL_CHAR,\n-  SPELL_IDENT,\n-  SPELL_STRING,\n-  SPELL_NONE\n-};\n-\n-struct token_spelling\n-{\n-  enum spell_type category;\n-  const U_CHAR *name;\n-};\n-\n-extern const struct token_spelling _cpp_token_spellings[];\n-#define TOKEN_SPELL(token) (_cpp_token_spellings[(token)->type].category)\n-#define TOKEN_NAME(token) (_cpp_token_spellings[(token)->type].name)\n-\n-/* Chained list of answers to an assertion.  */\n-struct answer\n-{\n-  struct answer *next;\n-  cpp_toklist list;\n-};\n-#define FREE_ANSWER(answer) do {_cpp_free_toklist (&answer->list); \\\n-\t\t\t\tfree (answer); } while (0)\n-\n-/* Values for the origin field of struct directive.  KANDR directives\n-   come from traditional (K&R) C.  STDC89 directives come from the\n-   1989 C standard.  EXTENSION directives are extensions.  */\n-#define KANDR\t\t0\n-#define STDC89\t\t1\n-#define EXTENSION\t2\n-\n-/* Values for the flags field of struct directive.  COND indicates a\n-   conditional.  EXPAND means that macros are to be expanded on the\n-   directive line.  INCL means to treat \"...\" and <...> as\n-   q-char-sequence and h-char-sequence respectively.  COMMENTS means\n-   preserve comments in the directive if -C.  IN_I means this directive\n-   should be handled even if -fpreprocessed is in effect (these are the\n-   directives with callback hooks).  */\n-#define COND\t\t(1 << 0)\n-#define EXPAND   \t(1 << 1)\n-#define INCL\t\t(1 << 2)\n-#define COMMENTS\t(1 << 3)\n-#define IN_I\t\t(1 << 4)\n-\n-/* Defines one #-directive, including how to handle it.  */\n-typedef void (*directive_handler) PARAMS ((cpp_reader *));\n-struct directive\n-{\n-  directive_handler handler;\t/* Function to handle directive.  */\n-  const U_CHAR *name;\t\t/* Name of directive.  */\n-  unsigned short length;\t/* Length of name.  */\n-  unsigned char origin;\t\t/* Origin of directive.  */\n-  unsigned char flags;\t        /* Flags describing this directive.  */\n+  cpp_chunk *next;\n+  unsigned char *front;\n+  unsigned char *limit;\n+  unsigned char *base;\n };\n \n /* List of directories to look for include files in. */\n@@ -122,28 +84,18 @@ struct include_file\n   unsigned short refcnt;\t/* number of stacked buffers using this file */\n   unsigned char sysp;\t\t/* file is a system header */\n   unsigned char mapped;\t\t/* file buffer is mmapped */\n+  unsigned char defined;\t/* cmacro prevents inclusion in this state */\n };\n \n /* The cmacro works like this: If it's NULL, the file is to be\n    included again.  If it's NEVER_REREAD, the file is never to be\n    included again.  Otherwise it is a macro hashnode, and the file is\n-   to be included again if the macro is not defined.  */\n+   to be included again if the macro is defined or not as specified by\n+   DEFINED.  */\n #define NEVER_REREAD ((const cpp_hashnode *)-1)\n #define DO_NOT_REREAD(inc) \\\n-((inc)->cmacro && \\\n- ((inc)->cmacro == NEVER_REREAD || (inc)->cmacro->type != T_VOID))\n-\n-/* Special nodes - identifiers with predefined significance.\n-   Note that the array length of dirs[] must be kept in sync with\n-   cpplib.c's dtable[].  */\n-struct spec_nodes\n-{\n-  cpp_hashnode *n_L;\t\t\t/* L\"str\" */\n-  cpp_hashnode *n__STRICT_ANSI__;\t/* STDC_0_IN_SYSTEM_HEADERS */\n-  cpp_hashnode *n__CHAR_UNSIGNED__;\t/* plain char is unsigned */\n-  cpp_hashnode *n__VA_ARGS__;\t\t/* C99 vararg macros */\n-  cpp_hashnode *dirs[19];\t\t/* 19 directives counting #sccs */\n-};\n+((inc)->cmacro && ((inc)->cmacro == NEVER_REREAD \\\n+\t\t   || ((inc)->cmacro->type == NT_MACRO) == (inc)->defined))\n \n /* Character classes.\n    If the definition of `numchar' looks odd to you, please look up the\n@@ -200,27 +152,30 @@ extern unsigned char _cpp_trigraph_map[UCHAR_MAX + 1];\n /* In cpperror.c  */\n enum error_type { WARNING = 0, PEDWARN, ERROR, FATAL, ICE };\n extern int _cpp_begin_message PARAMS ((cpp_reader *, enum error_type,\n-\t\t\t\t       const char *, unsigned int,\n-\t\t\t\t       unsigned int));\n+\t\t\t\t       const char *, const cpp_lexer_pos *));\n \n /* In cppmacro.c */\n extern void _cpp_free_definition\tPARAMS ((cpp_hashnode *));\n extern int _cpp_create_definition\tPARAMS ((cpp_reader *, cpp_hashnode *));\n+extern void _cpp_pop_context\t\tPARAMS ((cpp_reader *));\n+extern void _cpp_get_token \t\tPARAMS ((cpp_reader *, cpp_token *));\n+extern void _cpp_free_lookaheads\tPARAMS ((cpp_reader *));\n+extern void _cpp_push_token\t\tPARAMS ((cpp_reader *, const cpp_token *,\n+\t\t\t\t\t\t const cpp_lexer_pos *));\n \n /* In cpphash.c */\n-extern void _cpp_init_macros\t\tPARAMS ((cpp_reader *));\n-extern void _cpp_cleanup_macros\t\tPARAMS ((cpp_reader *));\n-extern cpp_hashnode *_cpp_lookup_with_hash PARAMS ((cpp_reader*, const U_CHAR *,\n-\t\t\t\t\t\t    size_t, unsigned int));\n+extern void _cpp_init_hashtable\t\tPARAMS ((cpp_reader *));\n+extern void _cpp_cleanup_hashtable\tPARAMS ((cpp_reader *));\n+extern cpp_hashnode *_cpp_lookup_with_hash PARAMS ((cpp_reader*, size_t,\n+\t\t\t\t\t\t    unsigned int));\n \n /* In cppfiles.c */\n extern void _cpp_simplify_pathname\tPARAMS ((char *));\n-extern void _cpp_execute_include\tPARAMS ((cpp_reader *, const U_CHAR *,\n-\t\t\t\t\t\t unsigned int, int,\n-\t\t\t\t\t\t struct file_name_list *,\n-\t\t\t\t\t\t int));\n-extern int _cpp_compare_file_date       PARAMS ((cpp_reader *, const U_CHAR *,\n-                                                 unsigned int, int));\n+extern void _cpp_execute_include\tPARAMS ((cpp_reader *,\n+\t\t\t\t\t\t const cpp_token *, int,\n+\t\t\t\t\t\t struct file_name_list *));\n+extern int _cpp_compare_file_date       PARAMS ((cpp_reader *,\n+\t\t\t\t\t\t const cpp_token *));\n extern void _cpp_report_missing_guards\tPARAMS ((cpp_reader *));\n extern void _cpp_init_includes\t\tPARAMS ((cpp_reader *));\n extern void _cpp_cleanup_includes\tPARAMS ((cpp_reader *));\n@@ -231,113 +186,33 @@ extern void _cpp_pop_file_buffer\tPARAMS ((cpp_reader *, cpp_buffer *));\n extern int _cpp_parse_expr\t\tPARAMS ((cpp_reader *));\n \n /* In cpplex.c */\n-extern const unsigned char *_cpp_digraph_spellings[];\n-extern void _cpp_skip_rest_of_line\tPARAMS ((cpp_reader *));\n-extern void _cpp_free_temp_tokens\tPARAMS ((cpp_reader *));\n-extern void _cpp_init_input_buffer\tPARAMS ((cpp_reader *));\n-extern void _cpp_grow_token_buffer\tPARAMS ((cpp_reader *, long));\n-extern void _cpp_init_toklist\t\tPARAMS ((cpp_toklist *, int));\n-extern void _cpp_clear_toklist\t\tPARAMS ((cpp_toklist *));\n-extern void _cpp_free_toklist\t\tPARAMS ((const cpp_toklist *));\n+extern void _cpp_lex_token\t\tPARAMS ((cpp_reader *, cpp_token *));\n extern int _cpp_equiv_tokens\t\tPARAMS ((const cpp_token *,\n \t\t\t\t\t\t const cpp_token *));\n-extern int _cpp_equiv_toklists\t\tPARAMS ((const cpp_toklist *,\n-\t\t\t\t\t\t const cpp_toklist *));\n-extern void _cpp_expand_token_space\tPARAMS ((cpp_toklist *, unsigned int));\n-extern void _cpp_reserve_name_space\tPARAMS ((cpp_toklist *, unsigned int));\n-extern void _cpp_expand_name_space\tPARAMS ((cpp_toklist *, unsigned int));\n-extern int _cpp_equiv_tokens\t\tPARAMS ((const cpp_token *,\n-\t\t\t\t\t\t const cpp_token *));\n-extern void _cpp_process_directive PARAMS ((cpp_reader *, const cpp_token *));\n-extern void _cpp_run_directive\t\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\t const struct directive *,\n-\t\t\t\t\t\t const char *, size_t,\n-\t\t\t\t\t\t const char *));\n-extern unsigned int _cpp_get_line\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\t unsigned int *));\n-extern const cpp_token *_cpp_get_token PARAMS ((cpp_reader *));\n-extern const cpp_token *_cpp_get_raw_token PARAMS ((cpp_reader *));\n-extern void _cpp_push_token PARAMS ((cpp_reader *, const cpp_token*));\n-extern const cpp_token *_cpp_glue_header_name PARAMS ((cpp_reader *));\n-extern enum cpp_ttype _cpp_can_paste PARAMS ((cpp_reader *, const cpp_token *,\n-\t\t\t\t\t      const cpp_token *, int *));\n+extern void _cpp_init_pool\t\tPARAMS ((cpp_pool *, unsigned int,\n+\t\t\t\t\t\t  unsigned int, unsigned int));\n+extern void _cpp_free_pool\t\tPARAMS ((cpp_pool *));\n+extern unsigned char *_cpp_pool_reserve PARAMS ((cpp_pool *, unsigned int));\n+extern unsigned char *_cpp_pool_alloc\tPARAMS ((cpp_pool *, unsigned int));\n+extern unsigned char *_cpp_next_chunk\tPARAMS ((cpp_pool *, unsigned int,\n+\t\t\t\t\t\t unsigned char **));\n+extern void _cpp_lock_pool\t\tPARAMS ((cpp_pool *));\n+extern void _cpp_unlock_pool\t\tPARAMS ((cpp_pool *));\n \n /* In cpplib.c */\n-extern const struct directive *_cpp_check_directive\n-\t\t\tPARAMS ((cpp_reader *, const cpp_token *));\n-extern const struct directive *_cpp_check_linemarker\n-\t\t\tPARAMS ((cpp_reader *, const cpp_token *));\n-extern cpp_hashnode *_cpp_parse_assertion PARAMS ((cpp_reader *,\n-\t\t\t\t\t\t    struct answer **));\n-extern struct answer **_cpp_find_answer\tPARAMS ((cpp_hashnode *,\n-\t\t\t\t\t\t const cpp_toklist *));\n-extern void _cpp_define_builtin\t\tPARAMS ((cpp_reader *, const char *));\n-\n+extern int _cpp_test_assertion PARAMS ((cpp_reader *, int *));\n+extern int _cpp_handle_directive PARAMS ((cpp_reader *, int));\n+extern void _cpp_define_builtin\tPARAMS ((cpp_reader *, const char *));\n extern void _cpp_init_stacks\tPARAMS ((cpp_reader *));\n extern void _cpp_cleanup_stacks\tPARAMS ((cpp_reader *));\n extern void _cpp_init_internal_pragmas PARAMS ((cpp_reader *));\n \n /* Utility routines and macros.  */\n+#define DSC(str) (const U_CHAR *)str, sizeof str - 1\n #define xnew(T)\t\t(T *) xmalloc (sizeof(T))\n #define xcnew(T)\t(T *) xcalloc (1, sizeof(T))\n #define xnewvec(T, N)\t(T *) xmalloc (sizeof(T) * (N))\n #define xcnewvec(T, N)\t(T *) xcalloc (N, sizeof(T))\n #define xobnew(O, T)\t(T *) obstack_alloc (O, sizeof(T))\n \n-/* These are inline functions instead of macros so we can get type\n-   checking.  */\n-\n-static inline int ustrcmp\tPARAMS ((const U_CHAR *, const U_CHAR *));\n-static inline int ustrncmp\tPARAMS ((const U_CHAR *, const U_CHAR *,\n-\t\t\t\t\t size_t));\n-static inline size_t ustrlen\tPARAMS ((const U_CHAR *));\n-static inline U_CHAR *uxstrdup\tPARAMS ((const U_CHAR *));\n-static inline U_CHAR *ustrchr\tPARAMS ((const U_CHAR *, int));\n-static inline int ufputs\tPARAMS ((const U_CHAR *, FILE *));\n-\n-static inline int\n-ustrcmp (s1, s2)\n-     const U_CHAR *s1, *s2;\n-{\n-  return strcmp ((const char *)s1, (const char *)s2);\n-}\n-\n-static inline int\n-ustrncmp (s1, s2, n)\n-     const U_CHAR *s1, *s2;\n-     size_t n;\n-{\n-  return strncmp ((const char *)s1, (const char *)s2, n);\n-}\n-\n-static inline size_t\n-ustrlen (s1)\n-     const U_CHAR *s1;\n-{\n-  return strlen ((const char *)s1);\n-}\n-\n-static inline U_CHAR *\n-uxstrdup (s1)\n-     const U_CHAR *s1;\n-{\n-  return (U_CHAR *) xstrdup ((const char *)s1);\n-}\n-\n-static inline U_CHAR *\n-ustrchr (s1, c)\n-     const U_CHAR *s1;\n-     int c;\n-{\n-  return (U_CHAR *) strchr ((const char *)s1, c);\n-}\n-\n-static inline int\n-ufputs (s, f)\n-     const U_CHAR *s;\n-     FILE *f;\n-{\n-  return fputs ((const char *)s, f);\n-}\n-\n #endif"}, {"sha": "20dfc633e3cc7be9613cccc838111f1e040d46f5", "filename": "gcc/cppinit.c", "status": "modified", "additions": 115, "deletions": 109, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c80368d9a16c073f2b930bef4232661971765f/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c80368d9a16c073f2b930bef4232661971765f/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=93c80368d9a16c073f2b930bef4232661971765f", "patch": "@@ -427,8 +427,19 @@ void\n cpp_reader_init (pfile)\n      cpp_reader *pfile;\n {\n+  struct spec_nodes *s;\n+\n   memset ((char *) pfile, 0, sizeof (cpp_reader));\n \n+  /* If cpp_init hasn't been called, generate a fatal error (by hand)\n+     and call it here.  */\n+  if (!cpp_init_completed)\n+    {\n+      fputs (\"cpp_reader_init: internal error: cpp_init not called.\\n\", stderr);\n+      pfile->errors = CPP_FATAL_LIMIT;\n+      cpp_init ();\n+    }\n+\n   CPP_OPTION (pfile, dollars_in_ident) = 1;\n   CPP_OPTION (pfile, cplusplus_comments) = 1;\n   CPP_OPTION (pfile, warn_import) = 1;\n@@ -441,44 +452,45 @@ cpp_reader_init (pfile)\n   CPP_OPTION (pfile, pending) =\n     (struct cpp_pending *) xcalloc (1, sizeof (struct cpp_pending));\n \n-  /* If cpp_init hasn't been called, generate a fatal error (by hand)\n-     and call it here.  */\n-  if (!cpp_init_completed)\n-    {\n-      fputs (\"cpp_reader_init: internal error: cpp_init not called.\\n\", stderr);\n-      pfile->errors = CPP_FATAL_LIMIT;\n-      cpp_init ();\n-    }\n+  /* Initialize comment saving state.  */\n+  pfile->state.save_comments = ! CPP_OPTION (pfile, discard_comments);\n+\n+  /* Indicate date and time not yet calculated.  */\n+  pfile->date.type = CPP_EOF;\n+\n+  /* Initialise the base context.  */\n+  pfile->context = &pfile->base_context;\n+  pfile->base_context.macro = 0;\n+  pfile->base_context.prev = pfile->base_context.next = 0;\n+\n+  /* Identifier pool initially 8K.  Unaligned, permanent pool.  */\n+  _cpp_init_pool (&pfile->ident_pool, 8 * 1024, 1, 0);\n+\n+  /* String and number pool initially 4K.  Unaligned, temporary pool.  */\n+  _cpp_init_pool (&pfile->temp_string_pool, 4 * 1024, 1, 1);\n+\n+  /* Argument pool initially 8K.  Aligned, temporary pool.  */\n+  _cpp_init_pool (&pfile->argument_pool, 8 * 1024, 0, 1);\n+\n+  /* Macro pool initially 8K.  Aligned, permanent pool.  */\n+  _cpp_init_pool (&pfile->macro_pool, 8 * 1024, 0, 0);\n \n-  _cpp_init_macros (pfile);\n+  /* Start with temporary pool.   */\n+  pfile->string_pool = &pfile->temp_string_pool;\n+\n+  _cpp_init_hashtable (pfile);\n   _cpp_init_stacks (pfile);\n   _cpp_init_includes (pfile);\n   _cpp_init_internal_pragmas (pfile);\n-}\n \n-/* Initialize a cpp_printer structure.  As a side effect, open the\n-   output file.  */\n-cpp_printer *\n-cpp_printer_init (pfile, print)\n-     cpp_reader *pfile;\n-     cpp_printer *print;\n-{\n-  memset (print, '\\0', sizeof (cpp_printer));\n-  if (CPP_OPTION (pfile, out_fname) == NULL)\n-    CPP_OPTION (pfile, out_fname) = \"\";\n-  \n-  if (CPP_OPTION (pfile, out_fname)[0] == '\\0')\n-    print->outf = stdout;\n-  else\n-    {\n-      print->outf = fopen (CPP_OPTION (pfile, out_fname), \"w\");\n-      if (! print->outf)\n-\t{\n-\t  cpp_notice_from_errno (pfile, CPP_OPTION (pfile, out_fname));\n-\t  return NULL;\n-\t}\n-    }\n-  return print;\n+  /* Initialize the special nodes.  */\n+  s = &pfile->spec_nodes;\n+  s->n_L                = cpp_lookup (pfile, DSC(\"L\"));\n+  s->n_defined\t\t= cpp_lookup (pfile, DSC(\"defined\"));\n+  s->n__STRICT_ANSI__   = cpp_lookup (pfile, DSC(\"__STRICT_ANSI__\"));\n+  s->n__CHAR_UNSIGNED__ = cpp_lookup (pfile, DSC(\"__CHAR_UNSIGNED__\"));\n+  s->n__VA_ARGS__       = cpp_lookup (pfile, DSC(\"__VA_ARGS__\"));\n+  s->n__VA_ARGS__->flags |= NODE_DIAGNOSTIC;\n }\n \n /* Free resources used by PFILE.\n@@ -487,69 +499,84 @@ void\n cpp_cleanup (pfile)\n      cpp_reader *pfile;\n {\n-  struct file_name_list *dir, *next;\n+  struct file_name_list *dir, *dirn;\n+  cpp_context *context, *contextn;\n \n   while (CPP_BUFFER (pfile) != NULL)\n     cpp_pop_buffer (pfile);\n \n+  if (pfile->macro_buffer)\n+    free ((PTR) pfile->macro_buffer);\n+\n   if (pfile->deps)\n     deps_free (pfile->deps);\n \n-  if (pfile->spec_nodes)\n-    free (pfile->spec_nodes);\n-\n-  _cpp_free_temp_tokens (pfile);\n   _cpp_cleanup_includes (pfile);\n   _cpp_cleanup_stacks (pfile);\n-  _cpp_cleanup_macros (pfile);\n+  _cpp_cleanup_hashtable (pfile);\n+\n+  _cpp_free_lookaheads (pfile);\n \n-  for (dir = CPP_OPTION (pfile, quote_include); dir; dir = next)\n+  _cpp_free_pool (&pfile->ident_pool);\n+  _cpp_free_pool (&pfile->temp_string_pool);\n+  _cpp_free_pool (&pfile->macro_pool);\n+  _cpp_free_pool (&pfile->argument_pool);\n+\n+  for (dir = CPP_OPTION (pfile, quote_include); dir; dir = dirn)\n     {\n-      next = dir->next;\n+      dirn = dir->next;\n       free (dir->name);\n       free (dir);\n     }\n+\n+  for (context = pfile->base_context.next; context; context = contextn)\n+    {\n+      contextn = context->next;\n+      free (context);\n+    }\n }\n \n \n-/* This structure defines one built-in macro.  A node of type TYPE will\n-   be entered in the macro hash table under the name NAME, with value\n-   VALUE (if any).  If TYPE is T_OPERATOR, the CODE field is used instead.\n+/* This structure defines one built-in identifier.  A node will be\n+   entered in the hash table under the name NAME, with value VALUE (if\n+   any).  If flags has OPERATOR, the node's operator field is used; if\n+   flags has BUILTIN the node's builtin field is used.\n \n    Two values are not compile time constants, so we tag\n    them in the FLAGS field instead:\n    VERS\t\tvalue is the global version_string, quoted\n    ULP\t\tvalue is the global user_label_prefix\n \n-   Also, macros with CPLUS set in the flags field are entered only for C++.\n- */\n+   Also, macros with CPLUS set in the flags field are entered only for C++.  */\n \n struct builtin\n {\n   const U_CHAR *name;\n   const char *value;\n-  unsigned char code;\n-  unsigned char type;\n+  unsigned char builtin;\n+  unsigned char operator;\n   unsigned short flags;\n-  unsigned int len;\n+  unsigned short len;\n };\n-#define VERS  0x01\n-#define ULP   0x02\n-#define CPLUS 0x04\n-\n-#define B(n, t)       { U n, 0, 0, t,          0, sizeof n - 1 }\n-#define C(n, v)       { U n, v, 0, T_MACRO,    0, sizeof n - 1 }\n-#define X(n, f)       { U n, 0, 0, T_MACRO,    f, sizeof n - 1 }\n-#define O(n, c, f)    { U n, 0, c, T_OPERATOR, f, sizeof n - 1 }\n+#define VERS\t\t0x01\n+#define ULP\t\t0x02\n+#define CPLUS\t\t0x04\n+#define BUILTIN\t\t0x08\n+#define OPERATOR  \t0x10\n+\n+#define B(n, t)       { U n, 0, t, 0, BUILTIN, sizeof n - 1 }\n+#define C(n, v)       { U n, v, 0, 0, 0, sizeof n - 1 }\n+#define X(n, f)       { U n, 0, 0, 0, f, sizeof n - 1 }\n+#define O(n, c, f)    { U n, 0, 0, c, OPERATOR | f, sizeof n - 1 }\n static const struct builtin builtin_array[] =\n {\n-  B(\"__TIME__\",\t\t T_TIME),\n-  B(\"__DATE__\",\t\t T_DATE),\n-  B(\"__FILE__\",\t\t T_FILE),\n-  B(\"__BASE_FILE__\",\t T_BASE_FILE),\n-  B(\"__LINE__\",\t\t T_SPECLINE),\n-  B(\"__INCLUDE_LEVEL__\", T_INCLUDE_LEVEL),\n-  B(\"__STDC__\",\t\t T_STDC),\n+  B(\"__TIME__\",\t\t BT_TIME),\n+  B(\"__DATE__\",\t\t BT_DATE),\n+  B(\"__FILE__\",\t\t BT_FILE),\n+  B(\"__BASE_FILE__\",\t BT_BASE_FILE),\n+  B(\"__LINE__\",\t\t BT_SPECLINE),\n+  B(\"__INCLUDE_LEVEL__\", BT_INCLUDE_LEVEL),\n+  B(\"__STDC__\",\t\t BT_STDC),\n \n   X(\"__VERSION__\",\t\tVERS),\n   X(\"__USER_LABEL_PREFIX__\",\tULP),\n@@ -570,9 +597,8 @@ static const struct builtin builtin_array[] =\n \n   /* Named operators known to the preprocessor.  These cannot be #defined\n      and always have their stated meaning.  They are treated like normal\n-     string tokens except for the type code and the meaning.  Most of them\n+     identifiers except for the type code and the meaning.  Most of them\n      are only for C++ (but see iso646.h).  */\n-  O(\"defined\",\tCPP_DEFINED, 0),\n   O(\"and\",\tCPP_AND_AND, CPLUS),\n   O(\"and_eq\",\tCPP_AND_EQ,  CPLUS),\n   O(\"bitand\",\tCPP_AND,     CPLUS),\n@@ -583,7 +609,7 @@ static const struct builtin builtin_array[] =\n   O(\"or\",\tCPP_OR_OR,   CPLUS),\n   O(\"or_eq\",\tCPP_OR_EQ,   CPLUS),\n   O(\"xor\",\tCPP_XOR,     CPLUS),\n-  O(\"xor_eq\",\tCPP_XOR_EQ,  CPLUS),\n+  O(\"xor_eq\",\tCPP_XOR_EQ,  CPLUS)\n };\n #undef B\n #undef C\n@@ -601,10 +627,25 @@ initialize_builtins (pfile)\n \n   for(b = builtin_array; b < builtin_array_end; b++)\n     {\n-      if (b->flags & CPLUS && ! CPP_OPTION (pfile, cplusplus))\n+      if ((b->flags & CPLUS) && ! CPP_OPTION (pfile, cplusplus))\n \tcontinue;\n \n-      if (b->type == T_MACRO)\n+      if (b->flags & (OPERATOR | BUILTIN))\n+\t{\n+\t  cpp_hashnode *hp = cpp_lookup (pfile, b->name, b->len);\n+\t  if (b->flags & OPERATOR)\n+\t    {\n+\t      hp->flags |= NODE_OPERATOR;\n+\t      hp->value.operator = b->operator;\n+\t    }\n+\t  else\n+\t    {\n+\t      hp->type = NT_MACRO;\n+\t      hp->flags |= NODE_BUILTIN;\n+\t      hp->value.builtin = b->builtin;\n+\t    }\n+\t}\n+      else\t\t\t/* A standard macro of some kind.  */\n \t{\n \t  const char *val;\n \t  char *str;\n@@ -629,17 +670,13 @@ initialize_builtins (pfile)\n \n \t  _cpp_define_builtin (pfile, str);\n \t}\n-      else\n-\t{\n-\t  cpp_hashnode *hp = cpp_lookup (pfile, b->name, b->len);\n-\t  hp->type = b->type;\n-\t  if (b->type == T_OPERATOR)\n-\t    hp->value.code = b->code;\n-\t}\n     }\n }\n+#undef BUILTIN\n+#undef OPERATOR\n #undef VERS\n #undef ULP\n+#undef CPLUS\n #undef builtin_array_end\n \n /* Another subroutine of cpp_start_read.  This one sets up to do\n@@ -799,9 +836,8 @@ initialize_standard_includes (pfile)\n  */\n \n int\n-cpp_start_read (pfile, print, fname)\n+cpp_start_read (pfile, fname)\n      cpp_reader *pfile;\n-     cpp_printer *print;\n      const char *fname;\n {\n   struct pending_option *p, *q;\n@@ -829,19 +865,6 @@ cpp_start_read (pfile, print, fname)\n   if (CPP_OPTION (pfile, user_label_prefix) == NULL)\n     CPP_OPTION (pfile, user_label_prefix) = USER_LABEL_PREFIX;\n \n-  /* Figure out if we need to save function macro parameter spellings.\n-     We don't use CPP_PEDANTIC() here because that depends on whether\n-     or not the current file is a system header, and there is no\n-     current file yet.  */\n-  pfile->save_parameter_spellings =\n-    CPP_OPTION (pfile, pedantic)\n-    || CPP_OPTION (pfile, debug_output)\n-    || CPP_OPTION (pfile, dump_macros) == dump_definitions\n-    || CPP_OPTION (pfile, dump_macros) == dump_only;\n-\n-  /* Set up the tables used by read_and_prescan.  */\n-  _cpp_init_input_buffer (pfile);\n-\n   /* Set up the include search path now.  */\n   if (! CPP_OPTION (pfile, no_standard_includes))\n     initialize_standard_includes (pfile);\n@@ -893,13 +916,6 @@ cpp_start_read (pfile, print, fname)\n     }\n   pfile->done_initializing = 1;\n \n-  /* We start at line 1 of the main input file.  */\n-  if (print)\n-    {\n-      print->last_fname = CPP_BUFFER (pfile)->nominal_fname;\n-      print->lineno = 1;\n-    }\n-\n   /* The -imacros files can be scanned now, but the -include files\n      have to be pushed onto the include stack and processed later,\n      in the main loop calling cpp_get_token.  */\n@@ -934,9 +950,8 @@ cpp_start_read (pfile, print, fname)\n    clear macro definitions, such that you could call cpp_start_read\n    with a new filename to restart processing. */\n void\n-cpp_finish (pfile, print)\n+cpp_finish (pfile)\n      cpp_reader *pfile;\n-     cpp_printer *print;\n {\n   if (CPP_BUFFER (pfile))\n     {\n@@ -971,15 +986,6 @@ cpp_finish (pfile, print)\n \t}\n     }\n \n-  /* Flush any pending output.  */\n-  if (print)\n-    {\n-      if (pfile->need_newline)\n-\tputc ('\\n', print->outf);\n-      if (ferror (print->outf) || fclose (print->outf))\n-\tcpp_notice_from_errno (pfile, CPP_OPTION (pfile, out_fname));\n-    }\n-\n   /* Report on headers that could use multiple include guards.  */\n   if (CPP_OPTION (pfile, print_include_names))\n     _cpp_report_missing_guards (pfile);"}, {"sha": "fa737a98f29e27178d8ae1c25c8c220169d313b5", "filename": "gcc/cpplex.c", "status": "modified", "additions": 522, "deletions": 1884, "changes": 2406, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c80368d9a16c073f2b930bef4232661971765f/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c80368d9a16c073f2b930bef4232661971765f/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=93c80368d9a16c073f2b930bef4232661971765f", "patch": "@@ -20,79 +20,54 @@ You should have received a copy of the GNU General Public License\n along with this program; if not, write to the Free Software\n Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n-/*\n-\n-Cleanups to do:-\n-\n-o Distinguish integers, floats, and 'other' pp-numbers.\n-o Store ints and char constants as binary values.\n-o New command-line assertion syntax.\n-o Comment all functions, and describe macro expansion algorithm.\n-o Move as much out of header files as possible.\n-o Remove single quote pairs `', and some '', from diagnostics.\n-o Correct pastability test for CPP_NAME and CPP_NUMBER.\n-\n-*/\n+/* This lexer works with a single pass of the file.  Recently I\n+   re-wrote it to minimize the places where we step backwards in the\n+   input stream, to make future changes to support multi-byte\n+   character sets fairly straight-forward.\n+\n+   There is now only one routine where we do step backwards:\n+   skip_escaped_newlines.  This routine could probably also be changed\n+   so that it doesn't need to step back.  One possibility is to use a\n+   trick similar to that used in lex_period and lex_percent.  Two\n+   extra characters might be needed, but skip_escaped_newlines itself\n+   would probably be the only place that needs to be aware of that,\n+   and changes to the remaining routines would probably only be needed\n+   if they process a backslash.  */\n \n #include \"config.h\"\n #include \"system.h\"\n-#include \"intl.h\"\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n #include \"symcat.h\"\n \n-const unsigned char *_cpp_digraph_spellings [] = {U\"%:\", U\"%:%:\", U\"<:\",\n-\t\t\t\t\t\t  U\":>\", U\"<%\", U\"%>\"};\n-static const cpp_token placemarker_token = {0, 0, CPP_PLACEMARKER,\n-\t\t\t\t\t    0 UNION_INIT_ZERO};\n-static const cpp_token eof_token = {0, 0, CPP_EOF, 0 UNION_INIT_ZERO};\n-\n-/* Flags for cpp_context.  */\n-#define CONTEXT_PASTEL\t(1 << 0) /* An argument context on LHS of ##.  */\n-#define CONTEXT_PASTER\t(1 << 1) /* An argument context on RHS of ##.  */\n-#define CONTEXT_RAW\t(1 << 2) /* If argument tokens already expanded.  */\n-#define CONTEXT_ARG\t(1 << 3) /* If an argument context.  */\n-#define CONTEXT_VARARGS\t(1 << 4) /* If a varargs argument context.  */\n-\n-typedef struct cpp_context cpp_context;\n-struct cpp_context\n+/* Tokens with SPELL_STRING store their spelling in the token list,\n+   and it's length in the token->val.name.len.  */\n+enum spell_type\n {\n-  union\n-  {\n-    const cpp_toklist *list;\t/* Used for macro contexts only.  */\n-    const cpp_token **arg;\t/* Used for arg contexts only.  */\n-  } u;\n-\n-  /* Pushed token to be returned by next call to get_raw_token.  */\n-  const cpp_token *pushed_token;\n-\n-  struct macro_args *args;\t/* The arguments for a function-like\n-\t\t\t\t   macro.  NULL otherwise.  */\n-  unsigned short posn;\t\t/* Current posn, index into u.  */\n-  unsigned short count;\t\t/* No. of tokens in u.  */\n-  unsigned short level;\n-  unsigned char flags;\n+  SPELL_OPERATOR = 0,\n+  SPELL_CHAR,\n+  SPELL_IDENT,\n+  SPELL_STRING,\n+  SPELL_NONE\n };\n \n-typedef struct macro_args macro_args;\n-struct macro_args\n+struct token_spelling\n {\n-  unsigned int *ends;\n-  const cpp_token **tokens;\n-  unsigned int capacity;\n-  unsigned int used;\n-  unsigned short level;\n+  enum spell_type category;\n+  const unsigned char *name;\n };\n \n-static const cpp_token *get_raw_token PARAMS ((cpp_reader *));\n-static const cpp_token *parse_arg PARAMS ((cpp_reader *, int, unsigned int,\n-\t\t\t\t\t   macro_args *, unsigned int *));\n-static int parse_args PARAMS ((cpp_reader *, cpp_hashnode *, macro_args *));\n-static void save_token PARAMS ((macro_args *, const cpp_token *));\n-static int pop_context PARAMS ((cpp_reader *));\n-static int push_macro_context PARAMS ((cpp_reader *, const cpp_token *));\n-static void push_arg_context PARAMS ((cpp_reader *, const cpp_token *));\n-static void free_macro_args PARAMS ((macro_args *));\n+const unsigned char *digraph_spellings [] = {U\"%:\", U\"%:%:\", U\"<:\",\n+\t\t\t\t\t     U\":>\", U\"<%\", U\"%>\"};\n+\n+#define OP(e, s) { SPELL_OPERATOR, U s           },\n+#define TK(e, s) { s,              U STRINGX (e) },\n+const struct token_spelling token_spellings [N_TTYPES] = {TTYPE_TABLE };\n+#undef OP\n+#undef TK\n+\n+#define TOKEN_SPELL(token) (token_spellings[(token)->type].category)\n+#define TOKEN_NAME(token) (token_spellings[(token)->type].name)\n \n static cppchar_t handle_newline PARAMS ((cpp_buffer *, cppchar_t));\n static cppchar_t skip_escaped_newlines PARAMS ((cpp_buffer *, cppchar_t));\n@@ -103,278 +78,18 @@ static int skip_line_comment PARAMS ((cpp_reader *));\n static void adjust_column PARAMS ((cpp_reader *));\n static void skip_whitespace PARAMS ((cpp_reader *, cppchar_t));\n static cpp_hashnode *parse_identifier PARAMS ((cpp_reader *, cppchar_t));\n-static void parse_number PARAMS ((cpp_reader *, cpp_string *, cppchar_t));\n+static void parse_number PARAMS ((cpp_reader *, cpp_string *, cppchar_t, int));\n+static int unescaped_terminator_p PARAMS ((cpp_reader *, const U_CHAR *));\n static void parse_string PARAMS ((cpp_reader *, cpp_token *, cppchar_t));\n-static void unterminated PARAMS ((cpp_reader *, unsigned int, int));\n+static void unterminated PARAMS ((cpp_reader *, int));\n static int trigraph_ok PARAMS ((cpp_reader *, cppchar_t));\n static void save_comment PARAMS ((cpp_reader *, cpp_token *, const U_CHAR *));\n static void lex_percent PARAMS ((cpp_buffer *, cpp_token *));\n static void lex_dot PARAMS ((cpp_reader *, cpp_token *));\n-static void lex_line PARAMS ((cpp_reader *, cpp_toklist *));\n-static void lex_token PARAMS ((cpp_reader *, cpp_token *));\n-static int lex_next PARAMS ((cpp_reader *, int));\n-\n-static int is_macro_disabled PARAMS ((cpp_reader *, const cpp_toklist *,\n-\t\t\t\t      const cpp_token *));\n-\n-static cpp_token *stringify_arg PARAMS ((cpp_reader *, const cpp_token *));\n-static void expand_context_stack PARAMS ((cpp_reader *));\n-static unsigned char * spell_token PARAMS ((cpp_reader *, const cpp_token *,\n-\t\t\t\t\t    unsigned char *));\n-typedef unsigned int (* speller) PARAMS ((unsigned char *, cpp_toklist *,\n-\t\t\t\t\t  cpp_token *));\n-static cpp_token *make_string_token PARAMS ((cpp_token *, const U_CHAR *,\n-\t\t\t\t\t    unsigned int));\n-static cpp_token *alloc_number_token PARAMS ((cpp_reader *, int number));\n-static const cpp_token *special_symbol PARAMS ((cpp_reader *, cpp_hashnode *,\n-\t\t\t\t\t\tconst cpp_token *));\n-static cpp_token *duplicate_token PARAMS ((cpp_reader *, const cpp_token *));\n-static const cpp_token *maybe_paste_with_next PARAMS ((cpp_reader *,\n-\t\t\t\t\t\t       const cpp_token *));\n-static unsigned int prevent_macro_expansion\tPARAMS ((cpp_reader *));\n-static void restore_macro_expansion\tPARAMS ((cpp_reader *, unsigned int));\n-static cpp_token *get_temp_token\tPARAMS ((cpp_reader *));\n-static void release_temp_tokens\t\tPARAMS ((cpp_reader *));\n-static U_CHAR * quote_string PARAMS ((U_CHAR *, const U_CHAR *, unsigned int));\n-\n-#define VALID_SIGN(c, prevc) \\\n-  (((c) == '+' || (c) == '-') && \\\n-   ((prevc) == 'e' || (prevc) == 'E' \\\n-    || (((prevc) == 'p' || (prevc) == 'P') && !CPP_OPTION (pfile, c89))))\n-\n-/* An upper bound on the number of bytes needed to spell a token,\n-   including preceding whitespace.  */\n-static inline size_t TOKEN_LEN PARAMS ((const cpp_token *));\n-static inline size_t\n-TOKEN_LEN (token)\n-     const cpp_token *token;\n-{\n-  size_t len;\n-\n-  switch (TOKEN_SPELL (token))\n-    {\n-    default:\t\tlen = 0;\t\t\tbreak;\n-    case SPELL_STRING:\tlen = token->val.str.len;\tbreak;\n-    case SPELL_IDENT:\tlen = token->val.node->length;\tbreak;\n-    }\n-  return len + 5;\n-}\n-\n-#define IS_ARG_CONTEXT(c) ((c)->flags & CONTEXT_ARG)\n-#define CURRENT_CONTEXT(pfile) ((pfile)->contexts + (pfile)->cur_context)\n-\n-#define ASSIGN_FLAGS_AND_POS(d, s) \\\n-  do {(d)->flags = (s)->flags & (PREV_WHITE | BOL | PASTE_LEFT); \\\n-      if ((d)->flags & BOL) {(d)->col = (s)->col; (d)->line = (s)->line;} \\\n-  } while (0)\n-\n-/* f is flags, just consisting of PREV_WHITE | BOL.  */\n-#define MODIFY_FLAGS_AND_POS(d, s, f) \\\n-  do {(d)->flags &= ~(PREV_WHITE | BOL); (d)->flags |= (f); \\\n-      if ((f) & BOL) {(d)->col = (s)->col; (d)->line = (s)->line;} \\\n-  } while (0)\n-\n-#define OP(e, s) { SPELL_OPERATOR, U s           },\n-#define TK(e, s) { s,              U STRINGX (e) },\n-\n-const struct token_spelling\n-_cpp_token_spellings [N_TTYPES] = {TTYPE_TABLE };\n-\n-#undef OP\n-#undef TK\n-\n-/* Helper routine used by parse_include, which can't see spell_token.\n-   Reinterpret the current line as an h-char-sequence (< ... >); we are\n-   looking at the first token after the <.  */\n-const cpp_token *\n-_cpp_glue_header_name (pfile)\n-     cpp_reader *pfile;\n-{\n-  const cpp_token *t;\n-  cpp_token *hdr;\n-  U_CHAR *buf, *p;\n-  size_t len, avail;\n-\n-  avail = 40;\n-  len = 0;\n-  buf = xmalloc (avail);\n-\n-  for (;;)\n-    {\n-      t = _cpp_get_token (pfile);\n-      if (t->type == CPP_GREATER || t->type == CPP_EOF)\n-\tbreak;\n-\n-      if (len + TOKEN_LEN (t) > avail)\n-\t{\n-\t  avail = len + TOKEN_LEN (t) + 40;\n-\t  buf = xrealloc (buf, avail);\n-\t}\n-\n-      if (t->flags & PREV_WHITE)\n-\tbuf[len++] = ' ';\n-\n-      p = spell_token (pfile, t, buf + len);\n-      len = (size_t) (p - buf);  /* p known >= buf */\n-    }\n-\n-  if (t->type == CPP_EOF)\n-    cpp_error (pfile, \"missing terminating > character\");\n-\n-  buf = xrealloc (buf, len);\n-\n-  hdr = get_temp_token (pfile);\n-  hdr->type = CPP_HEADER_NAME;\n-  hdr->flags = 0;\n-  hdr->val.str.text = buf;\n-  hdr->val.str.len = len;\n-  return hdr;\n-}\n-\n-/* Token-buffer helper functions.  */\n-\n-/* Expand a token list's string space. It is *vital* that\n-   list->tokens_used is correct, to get pointer fix-up right.  */\n-void\n-_cpp_expand_name_space (list, len)\n-     cpp_toklist *list;\n-     unsigned int len;\n-{\n-  const U_CHAR *old_namebuf;\n-\n-  old_namebuf = list->namebuf;\n-  list->name_cap += len;\n-  list->namebuf = (unsigned char *) xrealloc (list->namebuf, list->name_cap);\n-\n-  /* Fix up token text pointers.  */\n-  if (list->namebuf != old_namebuf)\n-    {\n-      unsigned int i;\n+static int name_p PARAMS ((cpp_reader *, const cpp_string *));\n \n-      for (i = 0; i < list->tokens_used; i++)\n-\tif (TOKEN_SPELL (&list->tokens[i]) == SPELL_STRING)\n-\t  list->tokens[i].val.str.text += (list->namebuf - old_namebuf);\n-    }\n-}\n-\n-/* If there is not enough room for LEN more characters, expand the\n-   list by just enough to have room for LEN characters.  */\n-void\n-_cpp_reserve_name_space (list, len)\n-     cpp_toklist *list;\n-     unsigned int len;\n-{\n-  unsigned int room = list->name_cap - list->name_used;\n-\n-  if (room < len)\n-    _cpp_expand_name_space (list, len - room);\n-}\n-\n-/* Expand the number of tokens in a list.  */\n-void\n-_cpp_expand_token_space (list, count)\n-     cpp_toklist *list;\n-     unsigned int count;\n-{\n-  list->tokens_cap += count;\n-  list->tokens = (cpp_token *)\n-    xrealloc (list->tokens, list->tokens_cap * sizeof (cpp_token));\n-}\n-\n-/* Initialize a token list.  If EMPTY is false, some token and name\n-   space is provided.  */\n-void\n-_cpp_init_toklist (list, empty)\n-     cpp_toklist *list;\n-     int empty;\n-{\n-  if (empty)\n-    {\n-      list->tokens_cap = 0;\n-      list->tokens = 0;\n-      list->name_cap = 0;\n-      list->namebuf = 0;\n-    }\n-  else\n-    {\n-      /* Initialize token space.  */\n-      list->tokens_cap = 256;\t/* 4K's worth.  */\n-      list->tokens = (cpp_token *)\n-\txmalloc ((list->tokens_cap + 1) * sizeof (cpp_token));\n-\n-      /* Initialize name space.  */\n-      list->name_cap = 1024;\n-      list->namebuf = (unsigned char *) xmalloc (list->name_cap);\n-    }\n-\n-  _cpp_clear_toklist (list);\n-}\n-\n-/* Clear a token list.  */\n-void\n-_cpp_clear_toklist (list)\n-     cpp_toklist *list;\n-{\n-  list->tokens_used = 0;\n-  list->name_used = 0;\n-  list->directive = 0;\n-  list->paramc = 0;\n-  list->params_len = 0;\n-  list->flags = 0;\n-}\n-\n-/* Free a token list.  Does not free the list itself, which may be\n-   embedded in a larger structure.  */\n-void\n-_cpp_free_toklist (list)\n-     const cpp_toklist *list;\n-{\n-  free (list->tokens);\n-  free (list->namebuf);\n-}\n-\n-/* Compare two tokens.  */\n-int\n-_cpp_equiv_tokens (a, b)\n-     const cpp_token *a, *b;\n-{\n-  if (a->type == b->type && a->flags == b->flags)\n-    switch (TOKEN_SPELL (a))\n-      {\n-      default:\t\t\t/* Keep compiler happy.  */\n-      case SPELL_OPERATOR:\n-\treturn 1;\n-      case SPELL_CHAR:\n-      case SPELL_NONE:\n-\treturn a->val.aux == b->val.aux; /* arg_no or character.  */\n-      case SPELL_IDENT:\n-\treturn a->val.node == b->val.node;\n-      case SPELL_STRING:\n-\treturn (a->val.str.len == b->val.str.len\n-\t\t&& !memcmp (a->val.str.text, b->val.str.text,\n-\t\t\t    a->val.str.len));\n-      }\n-\n-  return 0;\n-}\n-\n-/* Compare two token lists.  */\n-int\n-_cpp_equiv_toklists (a, b)\n-     const cpp_toklist *a, *b;\n-{\n-  unsigned int i;\n-\n-  if (a->tokens_used != b->tokens_used\n-      || a->flags != b->flags\n-      || a->paramc != b->paramc)\n-    return 0;\n-\n-  for (i = 0; i < a->tokens_used; i++)\n-    if (! _cpp_equiv_tokens (&a->tokens[i], &b->tokens[i]))\n-      return 0;\n-  return 1;\n-}\n+static cpp_chunk *new_chunk PARAMS ((unsigned int));\n+static int chunk_suitable PARAMS ((cpp_pool *, cpp_chunk *, unsigned int));\n \n /* Utility routine:\n \n@@ -389,7 +104,7 @@ cpp_ideq (token, string)\n   if (token->type != CPP_NAME)\n     return 0;\n \n-  return !ustrcmp (token->val.node->name, (const U_CHAR *)string);\n+  return !ustrcmp (token->val.node->name, (const U_CHAR *) string);\n }\n \n /* Call when meeting a newline.  Returns the character after the newline\n@@ -578,7 +293,7 @@ skip_block_comment (pfile)\n \n     next_char:\n       /* FIXME: For speed, create a new character class of characters\n-\t of no interest inside block comments.  */\n+\t of interest inside block comments.  */\n       if (c == '?' || c == '\\\\')\n \tc = skip_escaped_newlines (buffer, c);\n \n@@ -692,7 +407,7 @@ skip_whitespace (pfile, c)\n \t      warned = 1;\n \t    }\n \t}\n-      else if (IN_DIRECTIVE (pfile) && CPP_PEDANTIC (pfile))\n+      else if (pfile->state.in_directive && CPP_PEDANTIC (pfile))\n \tcpp_pedwarn_with_line (pfile, CPP_BUF_LINE (buffer),\n \t\t\t       CPP_BUF_COL (buffer),\n \t\t\t       \"%s in preprocessing directive\",\n@@ -710,6 +425,22 @@ skip_whitespace (pfile, c)\n   buffer->read_ahead = c;\n }\n \n+/* See if the characters of a number token are valid in a name (no\n+   '.', '+' or '-').  */\n+static int\n+name_p (pfile, string)\n+     cpp_reader *pfile;\n+     const cpp_string *string;\n+{\n+  unsigned int i;\n+\n+  for (i = 0; i < string->len; i++)\n+    if (!is_idchar (string->text[i]))\n+      return 0;\n+\n+  return 1;  \n+}\n+\n /* Parse an identifier, skipping embedded backslash-newlines.\n    Calculate the hash value of the token while parsing, for improved\n    performance.  The hashing algorithm *must* match cpp_lookup().  */\n@@ -719,18 +450,23 @@ parse_identifier (pfile, c)\n      cpp_reader *pfile;\n      cppchar_t c;\n {\n+  cpp_hashnode *result;\n   cpp_buffer *buffer = pfile->buffer;\n+  unsigned char *dest, *limit;\n   unsigned int r = 0, saw_dollar = 0;\n-  unsigned int orig_used = pfile->token_list.name_used;\n+\n+  dest = POOL_FRONT (&pfile->ident_pool);\n+  limit = POOL_LIMIT (&pfile->ident_pool);\n \n   do\n     {\n       do\n \t{\n-\t  if (pfile->token_list.name_used == pfile->token_list.name_cap)\n-\t    _cpp_expand_name_space (&pfile->token_list,\n-\t\t\t\t    pfile->token_list.name_used + 256);\n-\t  pfile->token_list.namebuf[pfile->token_list.name_used++] = c;\n+\t  /* Need room for terminating null.  */\n+\t  if (dest + 1 >= limit)\n+\t    limit = _cpp_next_chunk (&pfile->ident_pool, 0, &dest);\n+\n+\t  *dest++ = c;\n \t  r = HASHSTEP (r, c);\n \n \t  if (c == '$')\n@@ -751,86 +487,137 @@ parse_identifier (pfile, c)\n     }\n   while (is_idchar (c));\n \n+  /* Remember the next character.  */\n+  buffer->read_ahead = c;\n+\n   /* $ is not a identifier character in the standard, but is commonly\n      accepted as an extension.  Don't warn about it in skipped\n      conditional blocks.  */\n   if (saw_dollar && CPP_PEDANTIC (pfile) && ! pfile->skipping)\n     cpp_pedwarn (pfile, \"'$' character(s) in identifier\");\n \n-  /* Remember the next character.  */\n-  buffer->read_ahead = c;\n-  return _cpp_lookup_with_hash (pfile, &pfile->token_list.namebuf[orig_used],\n-\t\t\t\tpfile->token_list.name_used - orig_used, r);\n+  /* Identifiers are null-terminated.  */\n+  *dest = '\\0';\n+\n+  /* This routine commits the memory if necessary.  */\n+  result = _cpp_lookup_with_hash (pfile,\n+\t\t\t\t  dest - POOL_FRONT (&pfile->ident_pool), r);\n+\n+  /* Some identifiers require diagnostics when lexed.  */\n+  if (result->flags & NODE_DIAGNOSTIC && !pfile->skipping)\n+    {\n+      /* It is allowed to poison the same identifier twice.  */\n+      if ((result->flags & NODE_POISONED) && !pfile->state.poisoned_ok)\n+\tcpp_error (pfile, \"attempt to use poisoned \\\"%s\\\"\", result->name);\n+\n+      /* Constraint 6.10.3.5: __VA_ARGS__ should only appear in the\n+\t replacement list of a variable-arguments macro.  */\n+      if (result == pfile->spec_nodes.n__VA_ARGS__\n+\t  && !pfile->state.va_args_ok)\n+\tcpp_pedwarn (pfile, \"__VA_ARGS__ can only appear in the expansion of a C99 variable-argument macro\");\n+    }\n+\n+  return result;\n }\n \n /* Parse a number, skipping embedded backslash-newlines.  */\n static void\n-parse_number (pfile, number, c)\n+parse_number (pfile, number, c, leading_period)\n      cpp_reader *pfile;\n      cpp_string *number;\n      cppchar_t c;\n+     int leading_period;\n {\n-  cppchar_t prevc;\n   cpp_buffer *buffer = pfile->buffer;\n-  unsigned int orig_used = pfile->token_list.name_used;\n+  cpp_pool *pool = pfile->string_pool;\n+  unsigned char *dest, *limit;\n \n-  /* Reserve space for a leading period.  */\n-  if (pfile->state.seen_dot)\n-    pfile->token_list.name_used++;\n+  dest = POOL_FRONT (pool);\n+  limit = POOL_LIMIT (pool);\n \n+  /* Place a leading period.  */\n+  if (leading_period)\n+    {\n+      if (dest >= limit)\n+\tlimit = _cpp_next_chunk (pool, 0, &dest);\n+      *dest++ = '.';\n+    }\n+  \n   do\n     {\n       do\n \t{\n-\t  if (pfile->token_list.name_used >= pfile->token_list.name_cap)\n-\t    _cpp_expand_name_space (&pfile->token_list,\n-\t\t\t\t    pfile->token_list.name_used + 256);\n-\t  pfile->token_list.namebuf[pfile->token_list.name_used++] = c;\n+\t  /* Need room for terminating null.  */\n+\t  if (dest + 1 >= limit)\n+\t    limit = _cpp_next_chunk (pool, 0, &dest);\n+\t  *dest++ = c;\n \n-\t  prevc = c;\n \t  c = EOF;\n \t  if (buffer->cur == buffer->rlimit)\n \t    break;\n \n \t  c = *buffer->cur++;\n \t}\n-      while (is_numchar (c) || c == '.' || VALID_SIGN (c, prevc));\n+      while (is_numchar (c) || c == '.' || VALID_SIGN (c, dest[-1]));\n \n       /* Potential escaped newline?  */\n       if (c != '?' && c != '\\\\')\n \tbreak;\n       c = skip_escaped_newlines (buffer, c);\n     }\n-  while (is_numchar (c) || c == '.' || VALID_SIGN (c, prevc));\n-\n-  /* Put any leading period in place, now we have the room.  */\n-  if (pfile->state.seen_dot)\n-    pfile->token_list.namebuf[orig_used] = '.';\n+  while (is_numchar (c) || c == '.' || VALID_SIGN (c, dest[-1]));\n \n   /* Remember the next character.  */\n   buffer->read_ahead = c;\n \n-  number->text = &pfile->token_list.namebuf[orig_used];\n-  number->len = pfile->token_list.name_used - orig_used;\n+  /* Null-terminate the number.  */\n+  *dest = '\\0';\n+\n+  number->text = POOL_FRONT (pool);\n+  number->len = dest - number->text;\n+  POOL_COMMIT (pool, number->len + 1);\n }\n \n /* Subroutine of parse_string.  Emits error for unterminated strings.  */\n static void\n-unterminated (pfile, line, term)\n+unterminated (pfile, term)\n      cpp_reader *pfile;\n-     unsigned int line;\n      int term;\n {\n   cpp_error (pfile, \"missing terminating %c character\", term);\n \n-  if (term == '\\\"' && pfile->mls_line && pfile->mls_line != line)\n+  if (term == '\\\"' && pfile->mlstring_pos.line\n+      && pfile->mlstring_pos.line != pfile->lexer_pos.line)\n     {\n-      cpp_error_with_line (pfile, pfile->mls_line, pfile->mls_column,\n+      cpp_error_with_line (pfile, pfile->mlstring_pos.line,\n+\t\t\t   pfile->mlstring_pos.col,\n \t\t\t   \"possible start of unterminated string literal\");\n-      pfile->mls_line = 0;\n+      pfile->mlstring_pos.line = 0;\n     }\n }\n \n+/* Subroutine of parse_string.  */\n+static int\n+unescaped_terminator_p (pfile, dest)\n+     cpp_reader *pfile;\n+     const unsigned char *dest;\n+{\n+  const unsigned char *start, *temp;\n+\n+  /* In #include-style directives, terminators are not escapeable.  */\n+  if (pfile->state.angled_headers)\n+    return 1;\n+\n+  start = POOL_FRONT (pfile->string_pool);\n+\n+  /* An odd number of consecutive backslashes represents an escaped\n+     terminator.  */\n+  for (temp = dest; temp > start && temp[-1] == '\\\\'; temp--)\n+    ;\n+\n+  return ((dest - temp) & 1) == 0;\n+}\n+\n /* Parses a string, character constant, or angle-bracketed header file\n    name.  Handles embedded trigraphs and escaped newlines.\n \n@@ -843,16 +630,20 @@ parse_string (pfile, token, terminator)\n      cppchar_t terminator;\n {\n   cpp_buffer *buffer = pfile->buffer;\n-  unsigned int orig_used = pfile->token_list.name_used;\n+  cpp_pool *pool = pfile->string_pool;\n+  unsigned char *dest, *limit;\n   cppchar_t c;\n   unsigned int nulls = 0;\n \n+  dest = POOL_FRONT (pool);\n+  limit = POOL_LIMIT (pool);\n+\n   for (;;)\n     {\n       if (buffer->cur == buffer->rlimit)\n \t{\n \t  c = EOF;\n-\t  unterminated (pfile, token->line, terminator);\n+\t  unterminated (pfile, terminator);\n \t  break;\n \t}\n       c = *buffer->cur++;\n@@ -862,20 +653,10 @@ parse_string (pfile, token, terminator)\n       if (c == '?' || c == '\\\\')\n \tc = skip_escaped_newlines (buffer, c);\n \n-      if (c == terminator)\n+      if (c == terminator && unescaped_terminator_p (pfile, dest))\n \t{\n-\t  unsigned int u = pfile->token_list.name_used;\n-\n-\t  /* An odd number of consecutive backslashes represents an\n-\t     escaped terminator.  */\n-\t  while (u > orig_used && pfile->token_list.namebuf[u - 1] == '\\\\')\n-\t    u--;\n-\n-\t  if ((pfile->token_list.name_used - u) % 2 == 0)\n-\t    {\n-\t      c = EOF;\n-\t      break;\n-\t    }\n+\t  c = EOF;\n+\t  break;\n \t}\n       else if (is_vspace (c))\n \t{\n@@ -888,18 +669,16 @@ parse_string (pfile, token, terminator)\n \t  /* Character constants and header names may not extend over\n \t     multiple lines.  In Standard C, neither may strings.\n \t     Unfortunately, we accept multiline strings as an\n-\t     extension.  (Deprecatedly even in directives - otherwise,\n-\t     glibc's longlong.h breaks.)  */\n+\t     extension.  */\n \t  if (terminator != '\"')\n \t    {\n-\t      unterminated (pfile, token->line, terminator);\n+\t      unterminated (pfile, terminator);\n \t      break;\n \t    }\n \n-\t  if (pfile->mls_line == 0)\n+\t  if (pfile->mlstring_pos.line == 0)\n \t    {\n-\t      pfile->mls_line = token->line;\n-\t      pfile->mls_column = token->col;\n+\t      pfile->mlstring_pos = pfile->lexer_pos;\n \t      if (CPP_PEDANTIC (pfile))\n \t\tcpp_pedwarn (pfile, \"multi-line string constant\");\n \t    }\n@@ -913,11 +692,11 @@ parse_string (pfile, token, terminator)\n \t    cpp_warning (pfile, \"null character(s) preserved in literal\");\n \t}\n \n-      if (pfile->token_list.name_used == pfile->token_list.name_cap)\n-\t_cpp_expand_name_space (&pfile->token_list,\n-\t\t\t\tpfile->token_list.name_used + 256);\n+      /* No terminating null for strings - they could contain nulls.  */\n+      if (dest >= limit)\n+\tlimit = _cpp_next_chunk (pool, 0, &dest);\n+      *dest++ = c;\n \n-      pfile->token_list.namebuf[pfile->token_list.name_used++] = c;\n       /* If we had a new line, the next character is in read_ahead.  */\n       if (c != '\\n')\n \tcontinue;\n@@ -926,14 +705,15 @@ parse_string (pfile, token, terminator)\n \tgoto have_char;\n     }\n \n+  /* Remember the next character.  */\n   buffer->read_ahead = c;\n \n-  token->val.str.text = &pfile->token_list.namebuf[orig_used];\n-  token->val.str.len = pfile->token_list.name_used - orig_used;\n+  token->val.str.text = POOL_FRONT (pool);\n+  token->val.str.len = dest - token->val.str.text;\n+  POOL_COMMIT (pool, token->val.str.len);\n }\n \n-/* For output routine simplicity, the stored comment includes the\n-   comment start and any terminator.  */\n+/* The stored comment includes the comment start and any terminator.  */\n static void\n save_comment (pfile, token, from)\n      cpp_reader *pfile;\n@@ -942,12 +722,9 @@ save_comment (pfile, token, from)\n {\n   unsigned char *buffer;\n   unsigned int len;\n-  cpp_toklist *list = &pfile->token_list;\n   \n   len = pfile->buffer->cur - from + 1; /* + 1 for the initial '/'.  */\n-  _cpp_reserve_name_space (list, len);\n-  buffer = list->namebuf + list->name_used;\n-  list->name_used += len;\n+  buffer = _cpp_pool_alloc (pfile->string_pool, len);\n   \n   token->type = CPP_COMMENT;\n   token->val.str.len = len;\n@@ -1029,9 +806,7 @@ lex_dot (pfile, result)\n   if (c >= '0' && c <= '9')\n     {\n       result->type = CPP_NUMBER;\n-      buffer->pfile->state.seen_dot = 1;\n-      parse_number (pfile, &result->val.str, c);\n-      buffer->pfile->state.seen_dot = 0;\n+      parse_number (pfile, &result->val.str, c, 1);\n     }\n   else\n     {\n@@ -1053,39 +828,41 @@ lex_dot (pfile, result)\n     }\n }\n \n-static void\n-lex_token (pfile, result)\n+void\n+_cpp_lex_token (pfile, result)\n      cpp_reader *pfile;\n      cpp_token *result;\n {\n   cppchar_t c;\n   cpp_buffer *buffer = pfile->buffer;\n   const unsigned char *comment_start;\n+  unsigned char was_skip_newlines = pfile->state.skip_newlines;\n+  unsigned char newline_in_args = 0;\n \n+  pfile->state.skip_newlines = 0;\n   result->flags = 0;\n  next_char:\n-  result->line = CPP_BUF_LINE (buffer);\n+  pfile->lexer_pos.line = buffer->lineno;\n  next_char2:\n-  result->col = CPP_BUF_COLUMN (buffer, buffer->cur);\n+  pfile->lexer_pos.col = CPP_BUF_COLUMN (buffer, buffer->cur);\n \n   c = buffer->read_ahead;\n   if (c == EOF && buffer->cur < buffer->rlimit)\n     {\n       c = *buffer->cur++;\n-      result->col++;\n+      pfile->lexer_pos.col++;\n     }\n \n  do_switch:\n   buffer->read_ahead = EOF;\n   switch (c)\n     {\n     case EOF:\n-      /* Non-empty files should end in a newline.  Testing\n-         skip_newlines ensures we only emit the warning once.  */\n-      if (buffer->cur != buffer->line_base && buffer->cur != buffer->buf\n-\t  && pfile->state.skip_newlines)\n-\tcpp_pedwarn_with_line (pfile, buffer->lineno, CPP_BUF_COL (buffer),\n-\t\t\t       \"no newline at end of file\");\n+      /* Non-empty files should end in a newline.  Ignore for command\n+\t line - we get e.g. -A options with no trailing \\n.  */\n+      if (pfile->lexer_pos.col != 0 && pfile->done_initializing)\n+\tcpp_pedwarn (pfile, \"no newline at end of file\");\n+      pfile->state.skip_newlines = 1;\n       result->type = CPP_EOF;\n       break;\n \n@@ -1095,15 +872,35 @@ lex_token (pfile, result)\n       goto next_char2;\n \n     case '\\n': case '\\r':\n-      result->type = CPP_EOF;\n-      handle_newline (buffer, c);\n-      /* Handling here will change significantly when moving to\n-\t token-at-a-time.  */\n-      if (pfile->state.skip_newlines)\n+      /* Don't let directives spill over to the next line.  */\n+      if (pfile->state.in_directive)\n+\tbuffer->read_ahead = c;\n+      else\n \t{\n-\t  result->flags &= ~PREV_WHITE; /* Clear any whitespace flag.   */\n-\t  goto next_char;\n+\t  handle_newline (buffer, c);\n+\n+\t  pfile->lexer_pos.output_line = buffer->lineno;\n+\n+\t  /* Skip newlines in macro arguments (except in directives).  */\n+\t  if (pfile->state.parsing_args)\n+\t    {\n+\t      /* Set the whitespace flag.   */\n+\t      newline_in_args = 1;\n+\t      result->flags |= PREV_WHITE;\n+\t      goto next_char;\n+\t    }\n+\n+\t  if (was_skip_newlines)\n+\t    {\n+\t      /* Clear any whitespace flag.   */\n+\t      result->flags &= ~PREV_WHITE;\n+\t      goto next_char;\n+\t    }\n \t}\n+\n+      /* Next we're at BOL, so skip new lines.  */\n+      pfile->state.skip_newlines = 1;\n+      result->type = CPP_EOF;\n       break;\n \n     case '?':\n@@ -1133,7 +930,7 @@ lex_token (pfile, result)\n     case '0': case '1': case '2': case '3': case '4':\n     case '5': case '6': case '7': case '8': case '9':\n       result->type = CPP_NUMBER;\n-      parse_number (pfile, &result->val.str, c);\n+      parse_number (pfile, &result->val.str, c, 0);\n       break;\n \n     case '$':\n@@ -1156,7 +953,7 @@ lex_token (pfile, result)\n       result->val.node = parse_identifier (pfile, c);\n \n       /* 'L' may introduce wide characters or strings.  */\n-      if (result->val.node == pfile->spec_nodes->n_L)\n+      if (result->val.node == pfile->spec_nodes.n_L)\n \t{\n \t  c = buffer->read_ahead; /* For make_string.  */\n \t  if (c == '\\'' || c == '\"')\n@@ -1166,10 +963,10 @@ lex_token (pfile, result)\n \t    }\n \t}\n       /* Convert named operators to their proper types.  */\n-      else if (result->val.node->type == T_OPERATOR)\n+      else if (result->val.node->flags & NODE_OPERATOR)\n \t{\n \t  result->flags |= NAMED_OP;\n-\t  result->type = result->val.node->value.code;\n+\t  result->type = result->val.node->value.operator;\n \t}\n       break;\n \n@@ -1193,7 +990,8 @@ lex_token (pfile, result)\n       if (c == '*')\n \t{\n \t  if (skip_block_comment (pfile))\n-\t    cpp_error_with_line (pfile, result->line, result->col,\n+\t    cpp_error_with_line (pfile, pfile->lexer_pos.line,\n+\t\t\t\t pfile->lexer_pos.col,\n \t\t\t\t \"unterminated comment\");\n \t}\n       else\n@@ -1218,7 +1016,8 @@ lex_token (pfile, result)\n \n \t  /* Skip_line_comment updates buffer->read_ahead.  */\n \t  if (skip_line_comment (pfile))\n-\t    cpp_warning_with_line (pfile, result->line, result->col,\n+\t    cpp_warning_with_line (pfile, pfile->lexer_pos.line,\n+\t\t\t\t   pfile->lexer_pos.col,\n \t\t\t\t   \"multi-line comment\");\n \t}\n \n@@ -1290,6 +1089,8 @@ lex_token (pfile, result)\n \n     case '%':\n       lex_percent (buffer, result);\n+      if (result->type == CPP_HASH)\n+\tgoto do_hash;\n       break;\n \n     case '.':\n@@ -1349,9 +1150,21 @@ lex_token (pfile, result)\n       break;\n \t  \n     case '#':\n-      result->type = CPP_HASH;\n       if (get_effective_char (buffer) == '#')\n \tACCEPT_CHAR (CPP_PASTE);\n+      else\n+\t{\n+\t  result->type = CPP_HASH;\n+\tdo_hash:\n+\t  /* CPP_DHASH is the hash introducing a directive.  */\n+\t  if (was_skip_newlines || newline_in_args)\n+\t    {\n+\t      result->type = CPP_DHASH;\n+\t      /* Get whitespace right - newline_in_args sets it.  */\n+\t      if (pfile->lexer_pos.col == 1)\n+\t\tresult->flags &= ~PREV_WHITE;\n+\t    }\n+\t}\n       break;\n \n     case '|':\n@@ -1423,117 +1236,30 @@ lex_token (pfile, result)\n     }\n }\n \n-/*\n- *  The tokenizer's main loop.  Returns a token list, representing a\n- *  logical line in the input file.  On EOF after some tokens have\n- *  been processed, we return immediately.  Then in next call, or if\n- *  EOF occurred at the beginning of a logical line, a single CPP_EOF\n- *  token is placed in the list.\n- */\n-\n-static void\n-lex_line (pfile, list)\n-     cpp_reader *pfile;\n-     cpp_toklist *list;\n+/* An upper bound on the number of bytes needed to spell a token,\n+   including preceding whitespace.  */\n+unsigned int\n+cpp_token_len (token)\n+     const cpp_token *token;\n {\n-  unsigned int first_token;\n-  cpp_token *cur_token, *first;\n-  cpp_buffer *buffer = pfile->buffer;\n-\n-  pfile->state.in_lex_line = 1;\n-  if (pfile->buffer->cur == pfile->buffer->buf)\n-    list->flags |= BEG_OF_FILE;\n-\n- retry:\n-  pfile->state.in_directive = 0;\n-  pfile->state.angled_headers = 0;\n-  pfile->state.skip_newlines = 1;\n-  pfile->state.save_comments = ! CPP_OPTION (pfile, discard_comments);\n-  first_token = list->tokens_used;\n-  list->file = buffer->nominal_fname;\n-\n-  do\n-    {\n-      if (list->tokens_used >= list->tokens_cap)\n-\t_cpp_expand_token_space (list, 256);\n-\n-      cur_token = list->tokens + list->tokens_used;\n-      lex_token (pfile, cur_token);\n-\n-      if (pfile->state.skip_newlines)\n-\t{\n-\t  pfile->state.skip_newlines = 0;\n-\t  list->line = buffer->lineno;\n-\t  if (cur_token->type == CPP_HASH)\n-\t    {\n-\t      pfile->state.in_directive = 1;\n-\t      pfile->state.save_comments = 0;\n-\t      pfile->state.indented = cur_token->flags & PREV_WHITE;\n-\t    }\n-\t  /* 6.10.3.10: Within the sequence of preprocessing tokens\n-\t     making up the invocation of a function-like macro, new\n-\t     line is considered a normal white-space character.  */\n-\t  else if (first_token != 0)\n-\t    cur_token->flags |= PREV_WHITE;\n-\t}\n-      else if (IN_DIRECTIVE (pfile) && list->tokens_used == first_token + 1)\n-\t{\n-\t  if (cur_token->type == CPP_NUMBER)\n-\t    list->directive = _cpp_check_linemarker (pfile, cur_token);\n-\t  else\n-\t    list->directive = _cpp_check_directive (pfile, cur_token);\n-\t}\n+  unsigned int len;\n \n-      /* _cpp_get_line assumes list->tokens_used refers to the current\n-\t token being lexed.  So do this after _cpp_check_directive to\n-\t get the warnings therein correct.  */\n-      list->tokens_used++;\n-    }\n-  while (cur_token->type != CPP_EOF);\n-\n-  /* All tokens are allocated, so the memory location is fixed.  */\n-  first = &list->tokens[first_token];\n-  first->flags |= BOL;\n-  pfile->first_directive_token = first;\n-\n-  /* Don't complain about the null directive, nor directives in\n-     assembly source: we don't know where the comments are, and # may\n-     introduce assembler pseudo-ops.  Don't complain about invalid\n-     directives in skipped conditional groups (6.10 p4).  */\n-  if (IN_DIRECTIVE (pfile) && !KNOWN_DIRECTIVE (list) && !pfile->skipping\n-      && !CPP_OPTION (pfile, lang_asm))\n+  switch (TOKEN_SPELL (token))\n     {\n-      if (cur_token > first + 1)\n-\t{\n-\t  if (first[1].type == CPP_NAME)\n-\t    cpp_error_with_line (pfile, first->line, first->col,\n-\t\t\t\t \"invalid preprocessing directive #%s\",\n-\t\t\t\t first[1].val.node->name);\n-\t  else\n-\t    cpp_error_with_line (pfile, first->line, first->col,\n-\t\t\t\t \"invalid preprocessing directive\");\n-\t}\n-\n-      /* Discard this line to prevent further errors from cc1.  */\n-      _cpp_clear_toklist (list);\n-      goto retry;\n+    default:\t\tlen = 0;\t\t\tbreak;\n+    case SPELL_STRING:\tlen = token->val.str.len;\tbreak;\n+    case SPELL_IDENT:\tlen = token->val.node->length;\tbreak;\n     }\n-\n-  /* Drop the EOF unless really at EOF or in a directive.  */\n-  if (cur_token != first && !KNOWN_DIRECTIVE (list)\n-      && pfile->done_initializing)\n-    list->tokens_used--;\n-\n-  pfile->state.in_lex_line = 0;\n+  /* 1 for whitespace, 4 for comment delimeters.  */\n+  return len + 5;\n }\n \n /* Write the spelling of a token TOKEN to BUFFER.  The buffer must\n    already contain the enough space to hold the token's spelling.\n    Returns a pointer to the character after the last character\n    written.  */\n-\n-static unsigned char *\n-spell_token (pfile, token, buffer)\n+unsigned char *\n+cpp_spell_token (pfile, token, buffer)\n      cpp_reader *pfile;\t\t/* Would be nice to be rid of this...  */\n      const cpp_token *token;\n      unsigned char *buffer;\n@@ -1546,7 +1272,7 @@ spell_token (pfile, token, buffer)\n \tunsigned char c;\n \n \tif (token->flags & DIGRAPH)\n-\t  spelling = _cpp_digraph_spellings[token->type - CPP_FIRST_DIGRAPH];\n+\t  spelling = digraph_spellings[token->type - CPP_FIRST_DIGRAPH];\n \telse if (token->flags & NAMED_OP)\n \t  goto spell_ident;\n \telse\n@@ -1596,581 +1322,145 @@ spell_token (pfile, token, buffer)\n   return buffer;\n }\n \n-/* Macro expansion algorithm.\n-\n-Macro expansion is implemented by a single-pass algorithm; there are\n-no rescan passes involved.  cpp_get_token expands just enough to be\n-able to return a token to the caller, a consequence is that when it\n-returns the preprocessor can be in a state of mid-expansion.  The\n-algorithm does not work by fully expanding a macro invocation into\n-some kind of token list, and then returning them one by one.\n-\n-Our expansion state is recorded in a context stack.  We start out with\n-a single context on the stack, let's call it base context.  This\n-consists of the token list returned by lex_line that forms the next\n-logical line in the source file.\n-\n-The current level in the context stack is stored in the cur_context\n-member of the cpp_reader structure.  The context it references keeps,\n-amongst other things, a count of how many tokens form that context and\n-our position within those tokens.\n-\n-Fundamentally, calling cpp_get_token will return the next token from\n-the current context.  If we're at the end of the current context, that\n-context is popped from the stack first, unless it is the base context,\n-in which case the next logical line is lexed from the source file.\n-\n-However, before returning the token, if it is a CPP_NAME token\n-_cpp_get_token checks to see if it is a macro and if it is enabled.\n-Each time it encounters a macro name, it calls push_macro_context.\n-This function checks that the macro should be expanded (with\n-is_macro_enabled), and if so pushes a new macro context on the stack\n-which becomes the current context.  It then loops back to read the\n-first token of the macro context.\n-\n-A macro context basically consists of the token list representing the\n-macro's replacement list, which was saved in the hash table by\n-save_macro_expansion when its #define statement was parsed.  If the\n-macro is function-like, it also contains the tokens that form the\n-arguments to the macro.  I say more about macro arguments below, but\n-for now just saying that each argument is a set of pointers to tokens\n-is enough.\n-\n-When taking tokens from a macro context, we may get a CPP_MACRO_ARG\n-token.  This represents an argument passed to the macro, with the\n-argument number stored in the token's AUX field.  The argument should\n-be substituted, this is achieved by pushing an \"argument context\".  An\n-argument context is just refers to the tokens forming the argument,\n-which are obtained directly from the macro context.  The STRINGIFY\n-flag on a CPP_MACRO_ARG token indicates that the argument should be\n-stringified.\n-\n-Here's a few simple rules the context stack obeys:-\n-\n-  1) The lex_line token list is always context zero.\n-\n-  2) Context 1, if it exists, must be a macro context.\n-\n-  3) An argument context can only appear above a macro context.\n-\n-  4) A macro context can appear above the base context, another macro\n-  context, or an argument context.\n-\n-  5) These imply that the minimal level of an argument context is 2.\n-\n-The only tricky thing left is ensuring that macros are enabled and\n-disabled correctly.  The algorithm controls macro expansion by the\n-level of the context a token is taken from in the context stack.  If a\n-token is taken from a level equal to no_expand_level (a member of\n-struct cpp_reader), no expansion is performed.\n-\n-When popping a context off the stack, if no_expand_level equals the\n-level of the popped context, it is reduced by one to match the new\n-context level, so that expansion is still disabled.  It does not\n-increase if a context is pushed, though.  It starts out life as\n-UINT_MAX, which has the effect that initially macro expansion is\n-enabled.  I explain how this mechanism works below.\n-\n-The standard requires:-\n-\n-  1) Arguments to be fully expanded before substitution.\n-\n-  2) Stringified arguments to not be expanded, nor the tokens\n-  immediately surrounding a ## operator.\n-\n-  3) Continual rescanning until there are no more macros left to\n-  replace.\n-\n-  4) Once a macro has been expanded in stage 1) or 3), it cannot be\n-  expanded again during later rescans.  This prevents infinite\n-  recursion.\n-\n-The first thing to observe is that stage 3) is mostly redundant.\n-Since a macro is disabled once it has been expanded, how can a rescan\n-find an unexpanded macro name?  There are only two cases where this is\n-possible:-\n-\n-  a) If the macro name results from a token paste operation.\n-\n-  b) If the macro in question is a function-like macro that hasn't\n-  already been expanded because previously there was not the required\n-  '(' token immediately following it.  This is only possible when an\n-  argument is substituted, and after substitution the last token of\n-  the argument can bind with a parenthesis appearing in the tokens\n-  following the substitution.  Note that if the '(' appears within the\n-  argument, the ')' must too, as expanding macro arguments cannot\n-  \"suck in\" tokens outside the argument.\n-\n-So we tackle this as follows.  When parsing the macro invocation for\n-arguments, we record the tokens forming each argument as a list of\n-pointers to those tokens.  We do not expand any tokens that are \"raw\",\n-i.e. directly from the macro invocation, but other tokens that come\n-from (nested) argument substitution are fully expanded.\n-\n-This is achieved by setting the no_expand_level to that of the macro\n-invocation.  A CPP_MACRO_ARG token never appears in the list of tokens\n-forming an argument, because parse_args (indirectly) calls\n-get_raw_token which automatically pushes argument contexts and traces\n-into them.  Since these contexts are at a higher level than the\n-no_expand_level, they get fully macro expanded.\n-\n-\"Raw\" and non-raw tokens are separated in arguments by null pointers,\n-with the policy that the initial state of an argument is raw.  If the\n-first token is not raw, it should be preceded by a null pointer.  When\n-tracing through the tokens of an argument context, each time\n-get_raw_token encounters a null pointer, it toggles the flag\n-CONTEXT_RAW.\n-\n-This flag, when set, indicates to is_macro_disabled that we are\n-reading raw tokens which should be macro-expanded.  Similarly, if\n-clear, is_macro_disabled suppresses re-expansion.\n-\n-It's probably time for an example.\n-\n-#define hash #\n-#define str(x) #x\n-#define xstr(y) str(y hash)\n-str(hash)\t\t\t// \"hash\"\n-xstr(hash)\t\t\t// \"# hash\"\n-\n-In the invocation of str, parse_args turns off macro expansion and so\n-parses the argument as <hash>.  This is the only token (pointer)\n-passed as the argument to str.  Since <hash> is raw there is no need\n-for an initial null pointer.  stringify_arg is called from\n-get_raw_token when tracing through the expansion of str, since the\n-argument has the STRINGIFY flag set.  stringify_arg turns off\n-macro_expansion by setting the no_expand_level to that of the argument\n-context.  Thus it gets the token <hash> and stringifies it to \"hash\"\n-correctly.\n-\n-Similary xstr is passed <hash>.  However, when parse_args is parsing\n-the invocation of str() in xstr's expansion, get_raw_token encounters\n-a CPP_MACRO_ARG token for y.  Transparently to parse_args, it pushes\n-an argument context, and enters the tokens of the argument,\n-i.e. <hash>.  This is at a higher context level than parse_args\n-disabled, and so is_macro_disabled permits expansion of it and a macro\n-context is pushed on top of the argument context.  This contains the\n-<#> token, and the end result is that <hash> is macro expanded.\n-However, after popping off the argument context, the <hash> of xstr's\n-expansion does not get macro expanded because we're back at the\n-no_expand_level.  The end result is that the argument passed to str is\n-<NULL> <#> <NULL> <hash>.  Note the nulls - policy is we start off\n-raw, <#> is not raw, but then <hash> is.\n-\n-*/\n-\n-\n-/* Free the storage allocated for macro arguments.  */\n-static void\n-free_macro_args (args)\n-     macro_args *args;\n-{\n-  if (args->tokens)\n-    free ((PTR) args->tokens);\n-  free (args->ends);\n-  free (args);\n-}\n-\n-/* Determines if a macro has been already used (and is therefore\n-   disabled).  */\n-static int\n-is_macro_disabled (pfile, expansion, token)\n+/* Returns a token as a null-terminated string.  The string is\n+   temporary, and automatically freed later.  Useful for diagnostics.  */\n+unsigned char *\n+cpp_token_as_text (pfile, token)\n      cpp_reader *pfile;\n-     const cpp_toklist *expansion;\n      const cpp_token *token;\n {\n-  cpp_context *context = CURRENT_CONTEXT (pfile);\n-\n-  /* Arguments on either side of ## are inserted in place without\n-     macro expansion (6.10.3.3.2).  Conceptually, any macro expansion\n-     occurs during a later rescan pass.  The effect is that we expand\n-     iff we would as part of the macro's expansion list, so we should\n-     drop to the macro's context.  */\n-  if (IS_ARG_CONTEXT (context))\n-    {\n-      if (token->flags & PASTED)\n-\tcontext--;\n-      else if (!(context->flags & CONTEXT_RAW))\n-\treturn 1;\n-      else if (context->flags & (CONTEXT_PASTEL | CONTEXT_PASTER))\n-\tcontext--;\n-    }\n+  unsigned int len = cpp_token_len (token);\n+  unsigned char *start = _cpp_pool_alloc (&pfile->temp_string_pool, len), *end;\n \n-  /* Have we already used this macro?  */\n-  while (context->level > 0)\n-    {\n-      if (!IS_ARG_CONTEXT (context) && context->u.list == expansion)\n-\treturn 1;\n-      /* Raw argument tokens are judged based on the token list they\n-         came from.  */\n-      if (context->flags & CONTEXT_RAW)\n-\tcontext = pfile->contexts + context->level;\n-      else\n-\tcontext--;\n-    }\n+  end = cpp_spell_token (pfile, token, start);\n+  end[0] = '\\0';\n \n-  /* Function-like macros may be disabled if the '(' is not in the\n-     current context.  We check this without disrupting the context\n-     stack.  */\n-  if (expansion->paramc >= 0)\n-    {\n-      const cpp_token *next;\n-      unsigned int prev_nme;\n+  return start;\n+}\n \n-      context = CURRENT_CONTEXT (pfile);\n-      /* Drop down any contexts we're at the end of: the '(' may\n-         appear in lower macro expansions, or in the rest of the file.  */\n-      while (context->posn == context->count && context > pfile->contexts)\n-\t{\n-\t  context--;\n-\t  /* If we matched, we are disabled, as we appear in the\n-\t     expansion of each macro we meet.  */\n-\t  if (!IS_ARG_CONTEXT (context) && context->u.list == expansion)\n-\t    return 1;\n-\t}\n+/* Used by C front ends.  Should really move to using cpp_token_as_text.  */\n+const char *\n+cpp_type2name (type)\n+     enum cpp_ttype type;\n+{\n+  return (const char *) token_spellings[type].name;\n+}\n \n-      prev_nme = pfile->no_expand_level;\n-      pfile->no_expand_level = context - pfile->contexts;\n-      next = _cpp_get_token (pfile);\n-      restore_macro_expansion (pfile, prev_nme);\n+/* Writes the spelling of token to FP.  Separate from cpp_spell_token\n+   for efficiency - to avoid double-buffering.  Also, outputs a space\n+   if PREV_WHITE is flagged.  */\n+void\n+cpp_output_token (token, fp)\n+     const cpp_token *token;\n+     FILE *fp;\n+{\n+  if (token->flags & PREV_WHITE)\n+    putc (' ', fp);\n \n-      if (next->type != CPP_OPEN_PAREN)\n-\t{\n-\t  _cpp_push_token (pfile, next);\n-\t  if (CPP_WTRADITIONAL (pfile))\n-\t    cpp_warning (pfile,\n-\t \"function macro %s must be used with arguments in traditional C\",\n-\t\t\t token->val.node->name);\n-\t  return 1;\n-\t}\n-    }\n-\n-  return 0;\n-}\n-\n-/* Add a token to the set of tokens forming the arguments to the macro\n-   being parsed in parse_args.  */\n-static void\n-save_token (args, token)\n-     macro_args *args;\n-     const cpp_token *token;\n-{\n-  if (args->used == args->capacity)\n-    {\n-      args->capacity += args->capacity + 100;\n-      args->tokens = (const cpp_token **)\n-\txrealloc ((PTR) args->tokens,\n-\t\t  args->capacity * sizeof (const cpp_token *));\n-    }\n-  args->tokens[args->used++] = token;\n-}\n-\n-/* Take and save raw tokens until we finish one argument.  Empty\n-   arguments are saved as a single CPP_PLACEMARKER token.  */\n-static const cpp_token *\n-parse_arg (pfile, var_args, paren_context, args, pcount)\n-     cpp_reader *pfile;\n-     int var_args;\n-     unsigned int paren_context;\n-     macro_args *args;\n-     unsigned int *pcount;\n-{\n-  const cpp_token *token;\n-  unsigned int paren = 0, count = 0;\n-  int raw, was_raw = 1;\n-  \n-  for (count = 0;; count++)\n+  switch (TOKEN_SPELL (token))\n     {\n-      token = _cpp_get_token (pfile);\n-\n-      switch (token->type)\n-\t{\n-\tdefault:\n-\t  break;\n+    case SPELL_OPERATOR:\n+      {\n+\tconst unsigned char *spelling;\n \n-\tcase CPP_OPEN_PAREN:\n-\t  paren++;\n-\t  break;\n+\tif (token->flags & DIGRAPH)\n+\t  spelling = digraph_spellings[token->type - CPP_FIRST_DIGRAPH];\n+\telse if (token->flags & NAMED_OP)\n+\t  goto spell_ident;\n+\telse\n+\t  spelling = TOKEN_NAME (token);\n \n-\tcase CPP_CLOSE_PAREN:\n-\t  if (paren-- != 0)\n-\t    break;\n-\t  goto out;\n+\tufputs (spelling, fp);\n+      }\n+      break;\n \n-\tcase CPP_COMMA:\n-\t  /* Commas are not terminators within parantheses or var_args.  */\n-\t  if (paren || var_args)\n-\t    break;\n-\t  goto out;\n+    spell_ident:\n+    case SPELL_IDENT:\n+      ufputs (token->val.node->name, fp);\n+    break;\n \n-\tcase CPP_EOF:\t\t/* Error reported by caller.  */\n-\t  goto out;\n-\t}\n+    case SPELL_STRING:\n+      {\n+\tint left, right, tag;\n+\tswitch (token->type)\n+\t  {\n+\t  case CPP_STRING:\tleft = '\"';  right = '\"';  tag = '\\0'; break;\n+\t  case CPP_WSTRING:\tleft = '\"';  right = '\"';  tag = 'L';  break;\n+\t  case CPP_OSTRING:\tleft = '\"';  right = '\"';  tag = '@';  break;\n+\t  case CPP_CHAR:\tleft = '\\''; right = '\\''; tag = '\\0'; break;\n+    \t  case CPP_WCHAR:\tleft = '\\''; right = '\\''; tag = 'L';  break;\n+\t  case CPP_HEADER_NAME:\tleft = '<';  right = '>';  tag = '\\0'; break;\n+\t  default:\t\tleft = '\\0'; right = '\\0'; tag = '\\0'; break;\n+\t  }\n+\tif (tag) putc (tag, fp);\n+\tif (left) putc (left, fp);\n+\tfwrite (token->val.str.text, 1, token->val.str.len, fp);\n+\tif (right) putc (right, fp);\n+      }\n+      break;\n \n-      raw = pfile->cur_context <= paren_context;\n-      if (raw != was_raw)\n-\t{\n-\t  was_raw = raw;\n-\t  save_token (args, 0);\n-\t  count++;\n-\t}\n-      save_token (args, token);\n-    }\n+    case SPELL_CHAR:\n+      putc (token->val.aux, fp);\n+      break;\n \n- out:\n-  if (count == 0)\n-    {\n-      /* Duplicate the placemarker.  Then we can set its flags and\n-\t position and safely be using more than one.  */\n-      save_token (args, duplicate_token (pfile, &placemarker_token));\n-      count++;\n+    case SPELL_NONE:\n+      /* An error, most probably.  */\n+      break;\n     }\n-\n-  *pcount = count;\n-  return token;\n }\n \n-/* This macro returns true if the argument starting at offset O of arglist\n-   A is empty - that is, it's either a single PLACEMARKER token, or a null\n-   pointer followed by a PLACEMARKER.  */\n-\n-#define empty_argument(A, O) \\\n- ((A)->tokens[O] ? (A)->tokens[O]->type == CPP_PLACEMARKER \\\n-\t\t : (A)->tokens[(O)+1]->type == CPP_PLACEMARKER)\n-   \n-/* Parse the arguments making up a macro invocation.  Nested arguments\n-   are automatically macro expanded, but immediate macros are not\n-   expanded; this enables e.g. operator # to work correctly.  Returns\n-   non-zero on error.  */\n-static int\n-parse_args (pfile, hp, args)\n-     cpp_reader *pfile;\n-     cpp_hashnode *hp;\n-     macro_args *args;\n+/* Compare two tokens.  */\n+int\n+_cpp_equiv_tokens (a, b)\n+     const cpp_token *a, *b;\n {\n-  const cpp_token *token;\n-  const cpp_toklist *macro;\n-  unsigned int total = 0;\n-  unsigned int paren_context = pfile->cur_context;\n-  int argc = 0;\n-\n-  macro = hp->value.expansion;\n-  do\n-    {\n-      unsigned int count;\n-\n-      token = parse_arg (pfile, (argc + 1 == macro->paramc\n-\t\t\t\t && (macro->flags & VAR_ARGS)),\n-\t\t\t paren_context, args, &count);\n-      if (argc < macro->paramc)\n-\t{\n-\t  total += count;\n-\t  args->ends[argc] = total;\n-\t}\n-      argc++;\n-    }\n-  while (token->type != CPP_CLOSE_PAREN && token->type != CPP_EOF);\n-\n-  if (token->type == CPP_EOF)\n-    {\n-      cpp_error(pfile, \"unterminated argument list for macro \\\"%s\\\"\", hp->name);\n-      return 1;\n-    }\n-  else if (argc < macro->paramc)\n-    {\n-      /* A rest argument is allowed to not appear in the invocation at all.\n-\t e.g. #define debug(format, args...) ...\n-\t debug(\"string\");\n-\t This is exactly the same as if the rest argument had received no\n-\t tokens - debug(\"string\",);  This extension is deprecated.  */\n-\n-      if (argc + 1 == macro->paramc && (macro->flags & VAR_ARGS))\n-\t{\n-\t  /* Duplicate the placemarker.  Then we can set its flags and\n-             position and safely be using more than one.  */\n-\t  save_token (args, duplicate_token (pfile, &placemarker_token));\n-\t  args->ends[argc] = total + 1;\n-\n-\t  if (CPP_OPTION (pfile, c99) && CPP_PEDANTIC (pfile))\n-\t    cpp_pedwarn (pfile, \"ISO C99 requires rest arguments to be used\");\n-\n-\t  return 0;\n-\t}\n-      else\n-\t{\n-\t  cpp_error (pfile, \"%u arguments is not enough for macro \\\"%s\\\"\",\n-\t\t     argc, hp->name);\n-\t  return 1;\n-\t}\n-    }\n-  /* An empty argument to an empty function-like macro is fine.  */\n-  else if (argc > macro->paramc\n-\t   && !(macro->paramc == 0 && argc == 1 && empty_argument (args, 0)))\n-    {\n-      cpp_error (pfile, \"%u arguments is too many for macro \\\"%s\\\"\",\n-\t\t argc, hp->name);\n-      return 1;\n-    }\n+  if (a->type == b->type && a->flags == b->flags)\n+    switch (TOKEN_SPELL (a))\n+      {\n+      default:\t\t\t/* Keep compiler happy.  */\n+      case SPELL_OPERATOR:\n+\treturn 1;\n+      case SPELL_CHAR:\n+\treturn a->val.aux == b->val.aux; /* Character.  */\n+      case SPELL_NONE:\n+\treturn (a->type != CPP_MACRO_ARG || a->val.aux == b->val.aux);\n+      case SPELL_IDENT:\n+\treturn a->val.node == b->val.node;\n+      case SPELL_STRING:\n+\treturn (a->val.str.len == b->val.str.len\n+\t\t&& !memcmp (a->val.str.text, b->val.str.text,\n+\t\t\t    a->val.str.len));\n+      }\n \n   return 0;\n }\n \n-/* Adds backslashes before all backslashes and double quotes appearing\n-   in strings.  Non-printable characters are converted to octal.  */\n-static U_CHAR *\n-quote_string (dest, src, len)\n-     U_CHAR *dest;\n-     const U_CHAR *src;\n-     unsigned int len;\n-{\n-  while (len--)\n-    {\n-      U_CHAR c = *src++;\n-\n-      if (c == '\\\\' || c == '\"')\n-\t{\n-\t  *dest++ = '\\\\';\n-\t  *dest++ = c;\n-\t}\n-      else\n-\t{\n-\t  if (ISPRINT (c))\n-\t    *dest++ = c;\n-\t  else\n-\t    {\n-\t      sprintf ((char *) dest, \"\\\\%03o\", c);\n-\t      dest += 4;\n-\t    }\n-\t}\n-    }\n-\n-  return dest;\n-}\n-\n-/* Allocates a buffer to hold a token's TEXT, and converts TOKEN to a\n-   CPP_STRING token containing TEXT in quoted form.  */\n-static cpp_token *\n-make_string_token (token, text, len)\n-     cpp_token *token;\n-     const U_CHAR *text;\n-     unsigned int len;\n-{\n-  U_CHAR *buf;\n- \n-  buf = (U_CHAR *) xmalloc (len * 4);\n-  token->type = CPP_STRING;\n-  token->flags = 0;\n-  token->val.str.text = buf;\n-  token->val.str.len = quote_string (buf, text, len) - buf;\n-  return token;\n-}\n-\n-/* Allocates and converts a temporary token to a CPP_NUMBER token,\n-   evaluating to NUMBER.  */\n-static cpp_token *\n-alloc_number_token (pfile, number)\n-     cpp_reader *pfile;\n-     int number;\n-{\n-  cpp_token *result;\n-  char *buf;\n-\n-  result = get_temp_token (pfile);\n-  buf = xmalloc (20);\n-  sprintf (buf, \"%d\", number);\n-\n-  result->type = CPP_NUMBER;\n-  result->flags = 0;\n-  result->val.str.text = (U_CHAR *) buf;\n-  result->val.str.len = strlen (buf);\n-  return result;\n-}\n-\n-/* Returns a temporary token from the temporary token store of PFILE.  */\n-static cpp_token *\n-get_temp_token (pfile)\n-     cpp_reader *pfile;\n-{\n-  if (pfile->temp_used == pfile->temp_alloced)\n-    {\n-      if (pfile->temp_used == pfile->temp_cap)\n-\t{\n-\t  pfile->temp_cap += pfile->temp_cap + 20;\n-\t  pfile->temp_tokens = (cpp_token **) xrealloc\n-\t    (pfile->temp_tokens, pfile->temp_cap * sizeof (cpp_token *));\n-\t}\n-      pfile->temp_tokens[pfile->temp_alloced++] = (cpp_token *) xmalloc\n-\t(sizeof (cpp_token));\n-    }\n-\n-  return pfile->temp_tokens[pfile->temp_used++];\n-}\n-\n-/* Release (not free) for re-use the temporary tokens of PFILE.  */\n-static void\n-release_temp_tokens (pfile)\n-     cpp_reader *pfile;\n+#if 0\n+/* Compare two token lists.  */\n+int\n+_cpp_equiv_toklists (a, b)\n+     const struct toklist *a, *b;\n {\n-  while (pfile->temp_used)\n-    {\n-      cpp_token *token = pfile->temp_tokens[--pfile->temp_used];\n+  unsigned int i, count;\n \n-      if (TOKEN_SPELL (token) == SPELL_STRING)\n-\t{\n-\t  free ((char *) token->val.str.text);\n-\t  token->val.str.text = 0;\n-\t}\n-    }\n-}\n-\n-/* Free all of PFILE's dynamically-allocated temporary tokens.  */\n-void\n-_cpp_free_temp_tokens (pfile)\n-     cpp_reader *pfile;\n-{\n-  if (pfile->temp_tokens)\n-    {\n-      /* It is possible, though unlikely (looking for '(' of a funlike\n-\t macro into EOF), that we haven't released the tokens yet.  */\n-      release_temp_tokens (pfile);\n-      while (pfile->temp_alloced)\n-\tfree (pfile->temp_tokens[--pfile->temp_alloced]);\n-      free (pfile->temp_tokens);\n-    }\n-\n-  if (pfile->date)\n-    {\n-      free ((char *) pfile->date->val.str.text);\n-      free (pfile->date);\n-      free ((char *) pfile->time->val.str.text);\n-      free (pfile->time);\n-    }\n-}\n+  count = a->limit - a->first;\n+  if (count != (b->limit - b->first))\n+    return 0;\n \n-/* Copy TOKEN into a temporary token from PFILE's store.  */\n-static cpp_token *\n-duplicate_token (pfile, token)\n-     cpp_reader *pfile;\n-     const cpp_token *token;\n-{\n-  cpp_token *result = get_temp_token (pfile);\n+  for (i = 0; i < count; i++)\n+    if (! _cpp_equiv_tokens (&a->first[i], &b->first[i]))\n+      return 0;\n \n-  *result = *token;\n-  if (TOKEN_SPELL (token) == SPELL_STRING)\n-    {\n-      U_CHAR *buff = (U_CHAR *) xmalloc (token->val.str.len);\n-      memcpy (buff, token->val.str.text, token->val.str.len);\n-      result->val.str.text = buff;\n-    }\n-  return result;\n+  return 1;\n }\n+#endif\n \n /* Determine whether two tokens can be pasted together, and if so,\n    what the resulting token is.  Returns CPP_EOF if the tokens cannot\n    be pasted, or the appropriate type for the merged token if they\n    can.  */\n enum cpp_ttype\n-_cpp_can_paste (pfile, token1, token2, digraph)\n+cpp_can_paste (pfile, token1, token2, digraph)\n      cpp_reader * pfile;\n      const cpp_token *token1, *token2;\n      int* digraph;\n@@ -2247,11 +1537,11 @@ _cpp_can_paste (pfile, token1, token2, digraph)\n     case CPP_NAME:\n       if (b == CPP_NAME)\treturn CPP_NAME;\n       if (b == CPP_NUMBER\n-\t  && is_numstart(token2->val.str.text[0]))\t return CPP_NAME;\n+\t  && name_p (pfile, &token2->val.str)) return CPP_NAME;\n       if (b == CPP_CHAR\n-\t  && token1->val.node == pfile->spec_nodes->n_L) return CPP_WCHAR;\n+\t  && token1->val.node == pfile->spec_nodes.n_L) return CPP_WCHAR;\n       if (b == CPP_STRING\n-\t  && token1->val.node == pfile->spec_nodes->n_L) return CPP_WSTRING;\n+\t  && token1->val.node == pfile->spec_nodes.n_L) return CPP_WSTRING;\n       break;\n \n     case CPP_NUMBER:\n@@ -2278,882 +1568,230 @@ _cpp_can_paste (pfile, token1, token2, digraph)\n   return CPP_EOF;\n }\n \n-/* Check if TOKEN is to be ##-pasted with the token after it.  */\n-static const cpp_token *\n-maybe_paste_with_next (pfile, token)\n-     cpp_reader *pfile;\n-     const cpp_token *token;\n-{\n-  cpp_token *pasted;\n-  const cpp_token *second;\n-  cpp_context *context = CURRENT_CONTEXT (pfile);\n-\n-  /* Is this token on the LHS of ## ? */\n-\n-  while ((token->flags & PASTE_LEFT)\n-\t || ((context->flags & CONTEXT_PASTEL)\n-\t     && context->posn == context->count))\n-    {\n-      /* Suppress macro expansion for next token, but don't conflict\n-\t with the other method of suppression.  If it is an argument,\n-\t macro expansion within the argument will still occur.  */\n-      pfile->paste_level = pfile->cur_context;\n-      second = _cpp_get_token (pfile);\n-      pfile->paste_level = 0;\n-      context = CURRENT_CONTEXT (pfile);\n-\n-      /* Ignore placemarker argument tokens (cannot be from an empty\n-\t macro since macros are not expanded).  */\n-      if (token->type == CPP_PLACEMARKER)\n-\tpasted = duplicate_token (pfile, second);\n-      else if (second->type == CPP_PLACEMARKER)\n-\t{\n-\t  /* GCC has special extended semantics for , ## b where b is\n-\t     a varargs parameter: the comma disappears if b was given\n-\t     no actual arguments (not merely if b is an empty\n-\t     argument).  */\n-\t  if (token->type == CPP_COMMA && (context->flags & CONTEXT_VARARGS))\n-\t    pasted = duplicate_token (pfile, second);\n-\t  else\n-\t    pasted = duplicate_token (pfile, token);\n-\t}\n-      else\n-\t{\n-\t  int digraph = 0;\n-\t  enum cpp_ttype type = _cpp_can_paste (pfile, token, second, &digraph);\n-\n-\t  if (type == CPP_EOF)\n-\t    {\n-\t      if (CPP_OPTION (pfile, warn_paste))\n-\t\t{\n-\t\t  /* Do not complain about , ## <whatever> if\n-\t\t     <whatever> came from a variable argument, because\n-\t\t     the author probably intended the ## to trigger\n-\t\t     the special extended semantics (see above).  */\n-\t\t  if (token->type == CPP_COMMA\n-\t\t      && (context->flags & CONTEXT_VARARGS))\n-\t\t    /* no warning */;\n-\t\t  else\n-\t\t    cpp_warning (pfile,\n-\t\t\t\"pasting would not give a valid preprocessing token\");\n-\t\t}\n-\t      _cpp_push_token (pfile, second);\n-\t      /* A short term hack to safely clear the PASTE_LEFT flag.  */\n-\t      pasted = duplicate_token (pfile, token);\n-\t      pasted->flags &= ~PASTE_LEFT;\n-\t      return pasted;\n-\t    }\n-\n-\t  if (type == CPP_NAME || type == CPP_NUMBER)\n-\t    {\n-\t      /* Join spellings.  */\n-\t      U_CHAR *buf, *end;\n-\n-\t      pasted = get_temp_token (pfile);\n-\t      buf = (U_CHAR *) alloca (TOKEN_LEN (token) + TOKEN_LEN (second));\n-\t      end = spell_token (pfile, token, buf);\n-\t      end = spell_token (pfile, second, end);\n-\t      *end = '\\0';\n-\n-\t      if (type == CPP_NAME)\n-\t\tpasted->val.node = cpp_lookup (pfile, buf, end - buf);\n-\t      else\n-\t\t{\n-\t\t  pasted->val.str.text = uxstrdup (buf);\n-\t\t  pasted->val.str.len = end - buf;\n-\t\t}\n-\t    }\n-\t  else if (type == CPP_WCHAR || type == CPP_WSTRING\n-\t\t   || type == CPP_OSTRING)\n-\t    pasted = duplicate_token (pfile, second);\n-\t  else\n-\t    {\n-\t      pasted = get_temp_token (pfile);\n-\t      pasted->val.integer = 0;\n-\t    }\n-\n-\t  pasted->type = type;\n-\t  pasted->flags = digraph ? DIGRAPH : 0;\n-\n-\t  if (type == CPP_NAME && pasted->val.node->type == T_OPERATOR)\n-\t    {\n-\t      pasted->type = pasted->val.node->value.code;\n-\t      pasted->flags |= NAMED_OP;\n-\t    }\n-\t}\n+/* Returns nonzero if a space should be inserted to avoid an\n+   accidental token paste for output.  For simplicity, it is\n+   conservative, and occasionally advises a space where one is not\n+   needed, e.g. \".\" and \".2\".  */\n \n-      /* The pasted token gets the whitespace flags and position of the\n-\t first token, the PASTE_LEFT flag of the second token, plus the\n-\t PASTED flag to indicate it is the result of a paste.  However, we\n-\t want to preserve the DIGRAPH flag.  */\n-      pasted->flags &= ~(PREV_WHITE | BOL | PASTE_LEFT);\n-      pasted->flags |= ((token->flags & (PREV_WHITE | BOL))\n-\t\t\t| (second->flags & PASTE_LEFT) | PASTED);\n-      pasted->col = token->col;\n-      pasted->line = token->line;\n-\n-      /* See if there is another token to be pasted onto the one we just\n-\t constructed.  */\n-      token = pasted;\n-      /* and loop */\n-    }\n-  return token;\n-}\n-\n-/* Convert a token sequence to a single string token according to the\n-   rules of the ISO C #-operator.  */\n-#define INIT_SIZE 200\n-static cpp_token *\n-stringify_arg (pfile, token)\n+int\n+cpp_avoid_paste (pfile, token1, token2)\n      cpp_reader *pfile;\n-     const cpp_token *token;\n+     const cpp_token *token1, *token2;\n {\n-  cpp_token *result;\n-  unsigned char *main_buf;\n-  unsigned int prev_value, backslash_count = 0;\n-  unsigned int buf_used = 0, whitespace = 0, buf_cap = INIT_SIZE;\n-\n-  push_arg_context (pfile, token);\n-  prev_value  = prevent_macro_expansion (pfile);\n-  main_buf = (unsigned char *) xmalloc (buf_cap);\n-\n-  result = get_temp_token (pfile);\n-  ASSIGN_FLAGS_AND_POS (result, token);\n-\n-  for (; (token = _cpp_get_token (pfile))->type != CPP_EOF; )\n-    {\n-      int escape;\n-      unsigned char *buf;\n-      unsigned int len = TOKEN_LEN (token);\n-\n-      if (token->type == CPP_PLACEMARKER)\n-\tcontinue;\n-\n-      escape = (token->type == CPP_STRING || token->type == CPP_WSTRING\n-\t\t|| token->type == CPP_CHAR || token->type == CPP_WCHAR);\n-      if (escape)\n-\tlen *= 4 + 1;\n-\n-      if (buf_used + len > buf_cap)\n-\t{\n-\t  buf_cap = buf_used + len + INIT_SIZE;\n-\t  main_buf = xrealloc (main_buf, buf_cap);\n-\t}\n-\n-      if (whitespace && (token->flags & PREV_WHITE))\n-\tmain_buf[buf_used++] = ' ';\n-\n-      if (escape)\n-\tbuf = (unsigned char *) xmalloc (len);\n-      else\n-\tbuf = main_buf + buf_used;\n-      \n-      len = spell_token (pfile, token, buf) - buf;\n-      if (escape)\n-\t{\n-\t  buf_used = quote_string (&main_buf[buf_used], buf, len) - main_buf;\n-\t  free (buf);\n-\t}\n-      else\n-\tbuf_used += len;\n-\n-      whitespace = 1;\n-      if (token->type == CPP_BACKSLASH)\n-\tbackslash_count++;\n-      else\n-\tbackslash_count = 0;\n-    }\n+  enum cpp_ttype a = token1->type, b = token2->type;\n+  cppchar_t c;\n \n-  /* Ignore the final \\ of invalid string literals.  */\n-  if (backslash_count & 1)\n-    {\n-      cpp_warning (pfile, \"invalid string literal, ignoring final '\\\\'\");\n-      buf_used--;\n-    }\n+  if (token1->flags & NAMED_OP)\n+    a = CPP_NAME;\n+  if (token2->flags & NAMED_OP)\n+    b = CPP_NAME;\n \n-  result->type = CPP_STRING;\n-  result->val.str.text = main_buf;\n-  result->val.str.len = buf_used;\n-  restore_macro_expansion (pfile, prev_value);\n-  return result;\n-}\n+  c = EOF;\n+  if (token2->flags & DIGRAPH)\n+    c = digraph_spellings[b - CPP_FIRST_DIGRAPH][0];\n+  else if (token_spellings[b].category == SPELL_OPERATOR)\n+    c = token_spellings[b].name[0];\n \n-/* Allocate more room on the context stack of PFILE.  */\n-static void\n-expand_context_stack (pfile)\n-     cpp_reader *pfile;\n-{\n-  pfile->context_cap += pfile->context_cap + 20;\n-  pfile->contexts = (cpp_context *)\n-    xrealloc (pfile->contexts, pfile->context_cap * sizeof (cpp_context));\n-}\n+  /* Quickly get everything that can paste with an '='.  */\n+  if (a <= CPP_LAST_EQ && c == '=')\n+    return 1;\n \n-/* Push the context of macro NODE onto the context stack.  TOKEN is\n-   the CPP_NAME token invoking the macro.  */\n-static int\n-push_macro_context (pfile, token)\n-     cpp_reader *pfile;\n-     const cpp_token *token;\n-{\n-  unsigned char orig_flags;\n-  macro_args *args;\n-  cpp_context *context;\n-  cpp_hashnode *node = token->val.node;\n-\n-  /* Token's flags may change when parsing args containing a nested\n-     invocation of this macro.  */\n-  orig_flags = token->flags & (PREV_WHITE | BOL);\n-  args = 0;\n-  if (node->value.expansion->paramc >= 0)\n+  switch (a)\n     {\n-      unsigned int error, prev_nme;\n-\n-      /* Allocate room for the argument contexts, and parse them.  */\n-      args  = (macro_args *) xmalloc (sizeof (macro_args));\n-      args->ends = (unsigned int *)\n-\txmalloc (node->value.expansion->paramc * sizeof (unsigned int));\n-      args->tokens = 0;\n-      args->capacity = 0;\n-      args->used = 0;\n-\n-      prev_nme = prevent_macro_expansion (pfile);\n-      pfile->args = args;\n-      error = parse_args (pfile, node, args);\n-      pfile->args = 0;\n-      restore_macro_expansion (pfile, prev_nme);\n-      if (error)\n-\t{\n-\t  free_macro_args (args);\n-\t  return 1;\n-\t}\n-      /* Set the level after the call to parse_args.  */\n-      args->level = pfile->cur_context;\n+    case CPP_GREATER:\treturn c == '>' || c == '?';\n+    case CPP_LESS:\treturn c == '<' || c == '?' || c == '%' || c == ':';\n+    case CPP_PLUS:\treturn c == '+';\n+    case CPP_MINUS:\treturn c == '-' || c == '>';\n+    case CPP_DIV:\treturn c == '/' || c == '*'; /* Comments.  */\n+    case CPP_MOD:\treturn c == ':' || c == '>';\n+    case CPP_AND:\treturn c == '&';\n+    case CPP_OR:\treturn c == '|';\n+    case CPP_COLON:\treturn c == ':' || c == '>';\n+    case CPP_DEREF:\treturn c == '*';\n+    case CPP_DOT:\treturn c == '.' || c == '%';\n+    case CPP_HASH:\treturn c == '#' || c == '%'; /* Digraph form.  */\n+    case CPP_NAME:\treturn ((b == CPP_NUMBER\n+\t\t\t\t && name_p (pfile, &token2->val.str))\n+\t\t\t\t|| b == CPP_NAME\n+\t\t\t\t|| b == CPP_CHAR || b == CPP_STRING); /* L */\n+    case CPP_NUMBER:\treturn (b == CPP_NUMBER || b == CPP_NAME\n+\t\t\t\t|| c == '.' || c == '+' || c == '-');\n+    case CPP_OTHER:\treturn (CPP_OPTION (pfile, objc)\n+\t\t\t\t&& token1->val.aux == '@'\n+\t\t\t\t&& (b == CPP_NAME || b == CPP_STRING));\n+    default:\t\tbreak;\n     }\n \n-  /* Now push its context.  */\n-  pfile->cur_context++;\n-  if (pfile->cur_context == pfile->context_cap)\n-    expand_context_stack (pfile);\n-\n-  context = CURRENT_CONTEXT (pfile);\n-  context->u.list = node->value.expansion;\n-  context->args = args;\n-  context->posn = 0;\n-  context->count = context->u.list->tokens_used;\n-  context->level = pfile->cur_context;\n-  context->flags = 0;\n-  context->pushed_token = 0;\n-\n-  /* Set the flags of the first token.  We know there must\n-     be one, empty macros are a single placemarker token.  */\n-  MODIFY_FLAGS_AND_POS (&context->u.list->tokens[0], token, orig_flags);\n-\n   return 0;\n }\n \n-/* Push an argument to the current macro onto the context stack.\n-   TOKEN is the MACRO_ARG token representing the argument expansion.  */\n-static void\n-push_arg_context (pfile, token)\n-     cpp_reader *pfile;\n-     const cpp_token *token;\n-{\n-  cpp_context *context;\n-  macro_args *args;\n-\n-  pfile->cur_context++;\n-  if (pfile->cur_context == pfile->context_cap)\n-      expand_context_stack (pfile);\n-\n-  context = CURRENT_CONTEXT (pfile);\n-  args = context[-1].args;\n-\n-  context->count = token->val.aux ? args->ends[token->val.aux - 1]: 0;\n-  context->u.arg = args->tokens + context->count;\n-  context->count = args->ends[token->val.aux] - context->count;\n-  context->args = 0;\n-  context->posn = 0;\n-  context->level = args->level;\n-  context->flags = CONTEXT_ARG | CONTEXT_RAW;\n-  if ((context[-1].u.list->flags & VAR_ARGS)\n-      && token->val.aux + 1 == (unsigned) context[-1].u.list->paramc)\n-    context->flags |= CONTEXT_VARARGS;\n-  context->pushed_token = 0;\n-\n-  /* Set the flags of the first token.  There is one.  */\n-  {\n-    const cpp_token *first = context->u.arg[0];\n-    if (!first)\n-      first = context->u.arg[1];\n-\n-    MODIFY_FLAGS_AND_POS ((cpp_token *) first, token,\n-\t\t\t  token->flags & (PREV_WHITE | BOL));\n-  }\n-\n-  if (token->flags & PASTE_LEFT)\n-    context->flags |= CONTEXT_PASTEL;\n-  if (pfile->paste_level)\n-    context->flags |= CONTEXT_PASTER;\n-}\n-\n-/* \"Unget\" a token.  It is effectively inserted in the token queue and\n-   will be returned by the next call to get_raw_token.  */\n+/* Output all the remaining tokens on the current line, and a newline\n+   character, to FP.  Leading whitespace is removed.  */\n void\n-_cpp_push_token (pfile, token)\n+cpp_output_line (pfile, fp)\n      cpp_reader *pfile;\n-     const cpp_token *token;\n+     FILE *fp;\n {\n-  cpp_context *context = CURRENT_CONTEXT (pfile);\n+  cpp_token token;\n \n-  if (context->posn > 0)\n+  _cpp_get_token (pfile, &token);\n+  token.flags &= ~PREV_WHITE;\n+  while (token.type != CPP_EOF)\n     {\n-      const cpp_token *prev;\n-      if (IS_ARG_CONTEXT (context))\n-\tprev = context->u.arg[context->posn - 1];\n-      else\n-\tprev = &context->u.list->tokens[context->posn - 1];\n-\n-      if (prev == token)\n-\t{\n-\t  context->posn--;\n-\t  return;\n-\t}\n+      cpp_output_token (&token, fp);\n+      _cpp_get_token (pfile, &token);\n     }\n \n-  if (context->pushed_token)\n-    cpp_ice (pfile, \"two tokens pushed in a row\");\n-  if (token->type != CPP_EOF)\n-    context->pushed_token = token;\n-  /* Don't push back a directive's CPP_EOF, step back instead.  */\n-  else if (pfile->cur_context == 0)\n-    pfile->contexts[0].posn--;\n+  putc ('\\n', fp);\n }\n \n-/* Handle a preprocessing directive.  TOKEN is the CPP_HASH token\n-   introducing the directive.  */\n-void\n-_cpp_process_directive (pfile, token)\n-     cpp_reader *pfile;\n-     const cpp_token *token;\n-{\n-  const struct directive *d = pfile->token_list.directive;\n-  int prev_nme = 0;\n-\n-  /* Skip over the directive name.  */\n-  if (token[1].type == CPP_NAME)\n-    _cpp_get_raw_token (pfile);\n-  else if (token[1].type != CPP_NUMBER)\n-    cpp_ice (pfile, \"directive begins with %s?!\", TOKEN_NAME (token));\n-\n-  if (! (d->flags & EXPAND))\n-    prev_nme = prevent_macro_expansion (pfile);\n-  (void) (*d->handler) (pfile);\n-  if (! (d->flags & EXPAND))\n-    restore_macro_expansion (pfile, prev_nme);\n-  _cpp_skip_rest_of_line (pfile);\n-}\n-\n-/* The external interface to return the next token.  All macro\n-   expansion and directive processing is handled internally, the\n-   caller only ever sees the output after preprocessing.  */\n-const cpp_token *\n-cpp_get_token (pfile)\n-     cpp_reader *pfile;\n-{\n-  const cpp_token *token;\n-  /* Loop till we hit a non-directive, non-placemarker token.  */\n-  for (;;)\n-    {\n-      token = _cpp_get_token (pfile);\n-\n-      if (token->type == CPP_PLACEMARKER)\n-\tcontinue;\n+/* Memory pools.  */\n \n-      if (token->type == CPP_HASH && token->flags & BOL\n-\t  && pfile->token_list.directive)\n-\t{\n-\t  _cpp_process_directive (pfile, token);\n-\t  continue;\n-\t}\n-\n-      return token;\n-    }\n-}\n-\n-/* The internal interface to return the next token.  There are two\n-   differences between the internal and external interfaces: the\n-   internal interface may return a PLACEMARKER token, and it does not\n-   process directives.  */\n-const cpp_token *\n-_cpp_get_token (pfile)\n-     cpp_reader *pfile;\n+struct dummy\n {\n-  const cpp_token *token, *old_token;\n-  cpp_hashnode *node;\n-\n-  /* Loop until we hit a non-macro token.  */\n-  for (;;)\n-    {\n-      token = get_raw_token (pfile);\n-\n-      /* Short circuit EOF. */\n-      if (token->type == CPP_EOF)\n-\treturn token;\n+  char c;\n+  union\n+  {\n+    double d;\n+    int *p;\n+  } u;\n+};\n \n-      /* If we are skipping... */\n-      if (pfile->skipping)\n-\t{\n-\t  /* we still have to process directives,  */\n-\t  if (pfile->token_list.directive)\n-\t    return token;\n+#define DEFAULT_ALIGNMENT (offsetof (struct dummy, u))\n \n-\t  /* but everything else is ignored.  */\n-\t  _cpp_skip_rest_of_line (pfile);\n-\t  continue;\n-\t}\n-\n-      /* If there's a potential control macro and we get here, then that\n-\t #ifndef didn't cover the entire file and its argument shouldn't\n-\t be taken as a control macro.  */\n-      pfile->potential_control_macro = 0;\n-\n-      /* If we are rescanning preprocessed input, no macro expansion or\n-\t token pasting may occur.  */\n-      if (CPP_OPTION (pfile, preprocessed))\n-\treturn token;\n-\n-      old_token = token;\n-\n-      /* See if there's a token to paste with this one.  */\n-      if (!pfile->paste_level)\n-\ttoken = maybe_paste_with_next (pfile, token);\n-\n-      /* If it isn't a macro, return it now.  */\n-      if (token->type != CPP_NAME || token->val.node->type == T_VOID)\n-\treturn token;\n-\n-      /* Is macro expansion disabled in general, or are we in the\n-\t middle of a token paste, or was this token just pasted?\n-\t (Note we don't check token->flags & PASTED, because that\n-\t counts tokens that were pasted at some point in the past,\n-\t we're only interested in tokens that were pasted by this call\n-\t to maybe_paste_with_next.)  */\n-      if (pfile->no_expand_level == pfile->cur_context\n-\t  || pfile->paste_level\n-\t  || (token != old_token\n-\t      && pfile->no_expand_level + 1 == pfile->cur_context))\n-\treturn token;\n-\n-      node = token->val.node;\n-      if (node->type != T_MACRO)\n-\treturn special_symbol (pfile, node, token);\n-\n-      if (is_macro_disabled (pfile, node->value.expansion, token))\n-\treturn token;\n-\n-      if (push_macro_context (pfile, token))\n-\treturn token;\n-      /* else loop */\n-    }\n+static int\n+chunk_suitable (pool, chunk, size)\n+     cpp_pool *pool;\n+     cpp_chunk *chunk;\n+     unsigned int size;\n+{\n+  /* Being at least twice SIZE means we can use memcpy in\n+     _cpp_next_chunk rather than memmove.  Besides, it's a good idea\n+     anyway.  */\n+  return (chunk && pool->locked != chunk\n+\t  && (unsigned int) (chunk->limit - chunk->base) >= size * 2);\n }\n \n-/* Returns the next raw token, i.e. without performing macro\n-   expansion.  Argument contexts are automatically entered.  */\n-static const cpp_token *\n-get_raw_token (pfile)\n-     cpp_reader *pfile;\n+/* Returns the end of the new pool.  PTR points to a char in the old\n+   pool, and is updated to point to the same char in the new pool.  */\n+unsigned char *\n+_cpp_next_chunk (pool, len, ptr)\n+     cpp_pool *pool;\n+     unsigned int len;\n+     unsigned char **ptr;\n {\n-  const cpp_token *result;\n-  cpp_context *context;\n+  cpp_chunk *chunk = pool->cur->next;\n \n-  for (;;)\n+  /* LEN is the minimum size we want in the new pool.  */\n+  len += POOL_ROOM (pool);\n+  if (! chunk_suitable (pool, chunk, len))\n     {\n-      context = CURRENT_CONTEXT (pfile);\n-      if (context->pushed_token)\n-\t{\n-\t  result = context->pushed_token;\n-\t  context->pushed_token = 0;\n-\t  return result;\t/* Cannot be a CPP_MACRO_ARG */\n-\t}\n-      else if (context->posn == context->count)\n-\t{\n-\t  if (pop_context (pfile))\n-\t    return &eof_token;\n-\t  continue;\n-\t}\n-      else if (IS_ARG_CONTEXT (context))\n-\t{\n-\t  result = context->u.arg[context->posn++];\n-\t  if (result == 0)\n-\t    {\n-\t      context->flags ^= CONTEXT_RAW;\n-\t      result = context->u.arg[context->posn++];\n-\t    }\n-\t  return result;\t/* Cannot be a CPP_MACRO_ARG */\n-\t}\n-\n-      result = &context->u.list->tokens[context->posn++];\n-\n-      if (result->type != CPP_MACRO_ARG)\n-\treturn result;\n-\n-      if (result->flags & STRINGIFY_ARG)\n-\treturn stringify_arg (pfile, result);\n-\n-      push_arg_context (pfile, result);\n-    }\n-}\n-\n-/* Internal interface to get the token without macro expanding.  */\n-const cpp_token *\n-_cpp_get_raw_token (pfile)\n-     cpp_reader *pfile;\n-{\n-  int prev_nme = prevent_macro_expansion (pfile);\n-  const cpp_token *result = _cpp_get_token (pfile);\n-  restore_macro_expansion (pfile, prev_nme);\n-  return result;\n-}\n-\n-/* A thin wrapper to lex_line.  CLEAR is non-zero if the current token\n-   list should be overwritten, or zero if we need to append\n-   (typically, if we are within the arguments to a macro, or looking\n-   for the '(' to start a function-like macro invocation).  */\n-static int\n-lex_next (pfile, clear)\n-     cpp_reader *pfile;\n-     int clear;\n-{\n-  cpp_toklist *list = &pfile->token_list;\n-  const cpp_token *old_list = list->tokens;\n-  unsigned int old_used = list->tokens_used;\n+      chunk = new_chunk (POOL_SIZE (pool) * 2 + len);\n \n-  if (clear)\n-    {\n-      /* Release all temporary tokens.  */\n-      _cpp_clear_toklist (list);\n-      pfile->contexts[0].posn = 0;\n-      if (pfile->temp_used)\n-\trelease_temp_tokens (pfile);\n+      chunk->next = pool->cur->next;\n+      pool->cur->next = chunk;\n     }\n-  lex_line (pfile, list);\n-  pfile->contexts[0].count = list->tokens_used;\n \n-  if (!clear && pfile->args)\n-    {\n-      /* Fix up argument token pointers.  */\n-      if (old_list != list->tokens)\n-\t{\n-\t  unsigned int i;\n+  /* Update the pointer before changing chunk's front.  */\n+  if (ptr)\n+    *ptr += chunk->base - POOL_FRONT (pool);\n \n-\t  for (i = 0; i < pfile->args->used; i++)\n-\t    {\n-\t      const cpp_token *token = pfile->args->tokens[i];\n-\t      if (token >= old_list && token < old_list + old_used)\n-\t\tpfile->args->tokens[i] = (const cpp_token *)\n-\t        ((char *) token + ((char *) list->tokens - (char *) old_list));\n-\t    }\n-\t}\n-\n-      /* 6.10.3 paragraph 11: If there are sequences of preprocessing\n-\t tokens within the list of arguments that would otherwise act as\n-\t preprocessing directives, the behavior is undefined.\n-\n-\t This implementation will report a hard error and treat the\n-\t 'sequence of preprocessing tokens' as part of the macro argument,\n-\t not a directive.  \n+  memcpy (chunk->base, POOL_FRONT (pool), POOL_ROOM (pool));\n+  chunk->front = chunk->base;\n \n-         Note if pfile->args == 0, we're OK since we're only inside a\n-         macro argument after a '('.  */\n-      if (list->directive)\n-\t{\n-\t  cpp_error_with_line (pfile, list->tokens[old_used].line,\n-\t\t\t       list->tokens[old_used].col,\n-\t\t\t       \"#%s may not be used inside a macro argument\",\n-\t\t\t       list->directive->name);\n-\t  return 1;\n-\t}\n-    }\n-\n-  return 0;\n+  pool->cur = chunk;\n+  return POOL_LIMIT (pool);\n }\n \n-/* Pops a context off the context stack.  If we're at the bottom, lexes\n-   the next logical line.  Returns EOF if we're at the end of the\n-   argument list to the # operator, or we should not \"overflow\"\n-   into the rest of the file (e.g. 6.10.3.1.1).  */\n-static int\n-pop_context (pfile)\n-     cpp_reader *pfile;\n+static cpp_chunk *\n+new_chunk (size)\n+     unsigned int size;\n {\n-  cpp_context *context;\n+  unsigned char *base;\n+  cpp_chunk *result;\n \n-  if (pfile->cur_context == 0)\n-    {\n-      /* If we are currently processing a directive, do not advance.  6.10\n-\t paragraph 2: A new-line character ends the directive even if it\n-\t occurs within what would otherwise be an invocation of a\n-\t function-like macro.  */\n-      if (pfile->token_list.directive)\n-\treturn 1;\n+  size = ALIGN (size, DEFAULT_ALIGNMENT);\n+  base = (unsigned char *) xmalloc (size + sizeof (cpp_chunk));\n+  /* Put the chunk descriptor at the end.  Then chunk overruns will\n+     cause obvious chaos.  */\n+  result = (cpp_chunk *) (base + size);\n+  result->base = base;\n+  result->front = base;\n+  result->limit = base + size;\n+  result->next = 0;\n \n-      return lex_next (pfile, pfile->no_expand_level == UINT_MAX);\n-    }\n-\n-  /* Argument contexts, when parsing args or handling # operator\n-     return CPP_EOF at the end.  */\n-  context = CURRENT_CONTEXT (pfile);\n-  if (IS_ARG_CONTEXT (context) && pfile->cur_context == pfile->no_expand_level)\n-    return 1;\n-\n-  /* Free resources when leaving macro contexts.  */\n-  if (context->args)\n-    free_macro_args (context->args);\n-\n-  if (pfile->cur_context == pfile->no_expand_level)\n-    pfile->no_expand_level--;\n-  pfile->cur_context--;\n-\n-  return 0;\n+  return result;\n }\n \n-/* Turn off macro expansion at the current context level.  */\n-static unsigned int\n-prevent_macro_expansion (pfile)\n-     cpp_reader *pfile;\n-{\n-  unsigned int prev_value = pfile->no_expand_level;\n-  pfile->no_expand_level = pfile->cur_context;\n-  return prev_value;\n+void\n+_cpp_init_pool (pool, size, align, temp)\n+     cpp_pool *pool;\n+     unsigned int size, align, temp;\n+{\n+  if (align == 0)\n+    align = DEFAULT_ALIGNMENT;\n+  if (align & (align - 1))\n+    abort ();\n+  pool->align = align;\n+  pool->cur = new_chunk (size);\n+  pool->locked = 0;\n+  pool->locks = 0;\n+  if (temp)\n+    pool->cur->next = pool->cur;\n }\n \n-/* Restore macro expansion to its previous state.  */\n-static void\n-restore_macro_expansion (pfile, prev_value)\n-     cpp_reader *pfile;\n-     unsigned int prev_value;\n+void\n+_cpp_lock_pool (pool)\n+     cpp_pool *pool;\n {\n-  pfile->no_expand_level = prev_value;\n+  if (pool->locks++ == 0)\n+    pool->locked = pool->cur;\n }\n \n-/* Used by cpperror.c to obtain the correct line and column to report\n-   in a diagnostic.  */\n-unsigned int\n-_cpp_get_line (pfile, pcol)\n-     cpp_reader *pfile;\n-     unsigned int *pcol;\n+void\n+_cpp_unlock_pool (pool)\n+     cpp_pool *pool;\n {\n-  unsigned int index;\n-  const cpp_token *cur_token;\n-\n-  if (pfile->state.in_lex_line)\n-    index = pfile->token_list.tokens_used;\n-  else\n-    {\n-      index = pfile->contexts[0].posn;\n-\n-      if (index == 0)\n-\t{\n-\t  if (pcol)\n-\t    *pcol = 0;\n-\t  return 0;\n-\t}\n-      index--;\n-    }\n-\n-  cur_token = &pfile->token_list.tokens[index];\n-  if (pcol)\n-    *pcol = cur_token->col;\n-  return cur_token->line;\n+  if (--pool->locks == 0)\n+    pool->locked = 0;\n }\n \n-#define DSC(str) (const U_CHAR *)str, sizeof str - 1\n-static const char * const monthnames[] =\n-{\n-  \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n-  \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\",\n-};\n-\n-/* Handle builtin macros like __FILE__.  */\n-static const cpp_token *\n-special_symbol (pfile, node, token)\n-     cpp_reader *pfile;\n-     cpp_hashnode *node;\n-     const cpp_token *token;\n+void\n+_cpp_free_pool (pool)\n+     cpp_pool *pool;\n {\n-  cpp_token *result;\n-  cpp_buffer *ip;\n+  cpp_chunk *chunk = pool->cur, *next;\n \n-  switch (node->type)\n+  do\n     {\n-    case T_FILE:\n-    case T_BASE_FILE:\n-      {\n-\tconst char *file;\n-\n-\tip = CPP_BUFFER (pfile);\n-\tif (ip == 0)\n-\t  file = \"\";\n-\telse\n-\t  {\n-\t    if (node->type == T_BASE_FILE)\n-\t      while (CPP_PREV_BUFFER (ip) != NULL)\n-\t\tip = CPP_PREV_BUFFER (ip);\n-\n-\t    file = ip->nominal_fname;\n-\t  }\n-\tresult = make_string_token (get_temp_token (pfile), (U_CHAR *) file,\n-\t\t\t\t    strlen (file));\n-      }\n-      break;\n-\t\n-    case T_INCLUDE_LEVEL:\n-      /* pfile->include_depth counts the primary source as level 1,\n-\t but historically __INCLUDE_DEPTH__ has called the primary\n-\t source level 0.  */\n-      result = alloc_number_token (pfile, pfile->include_depth - 1);\n-      break;\n-\n-    case T_SPECLINE:\n-      /* If __LINE__ is embedded in a macro, it must expand to the\n-\t line of the macro's invocation, not its definition.\n-\t Otherwise things like assert() will not work properly.  */\n-      result = alloc_number_token (pfile, _cpp_get_line (pfile, NULL));\n-      break;\n-\n-    case T_STDC:\n-      {\n-\tint stdc = 1;\n-\n-#ifdef STDC_0_IN_SYSTEM_HEADERS\n-\tif (CPP_IN_SYSTEM_HEADER (pfile)\n-\t    && pfile->spec_nodes->n__STRICT_ANSI__->type == T_VOID)\n-\t  stdc = 0;\n-#endif\n-\tresult = alloc_number_token (pfile, stdc);\n-      }\n-      break;\n-\n-    case T_DATE:\n-    case T_TIME:\n-      if (pfile->date == 0)\n-\t{\n-\t  /* Allocate __DATE__ and __TIME__ from permanent storage,\n-\t     and save them in pfile so we don't have to do this again.\n-\t     We don't generate these strings at init time because\n-\t     time() and localtime() are very slow on some systems.  */\n-\t  time_t tt = time (NULL);\n-\t  struct tm *tb = localtime (&tt);\n-\n-\t  pfile->date = make_string_token\n-\t    ((cpp_token *) xmalloc (sizeof (cpp_token)), DSC(\"Oct 11 1347\"));\n-\t  pfile->time = make_string_token\n-\t    ((cpp_token *) xmalloc (sizeof (cpp_token)), DSC(\"12:34:56\"));\n-\n-\t  sprintf ((char *) pfile->date->val.str.text, \"%s %2d %4d\",\n-\t\t   monthnames[tb->tm_mon], tb->tm_mday, tb->tm_year + 1900);\n-\t  sprintf ((char *) pfile->time->val.str.text, \"%02d:%02d:%02d\",\n-\t\t   tb->tm_hour, tb->tm_min, tb->tm_sec);\n-\t}\n-      result = node->type == T_DATE ? pfile->date: pfile->time;\n-      break;\n-\n-    case T_POISON:\n-      cpp_error (pfile, \"attempt to use poisoned \\\"%s\\\"\", node->name);\n-      return token;\n-\n-    default:\n-      cpp_ice (pfile, \"invalid special hash type\");\n-      return token;\n+      next = chunk->next;\n+      free (chunk->base);\n+      chunk = next;\n     }\n-\n-  ASSIGN_FLAGS_AND_POS (result, token);\n-  return result;\n+  while (chunk && chunk != pool->cur);\n }\n-#undef DSC\n \n-/* Allocate pfile->input_buffer, and initialize _cpp_trigraph_map[]\n-   if it hasn't happened already.  */\n-\n-void\n-_cpp_init_input_buffer (pfile)\n-     cpp_reader *pfile;\n+/* Reserve LEN bytes from a memory pool.  */\n+unsigned char *\n+_cpp_pool_reserve (pool, len)\n+     cpp_pool *pool;\n+     unsigned int len;\n {\n-  cpp_context *base;\n-\n-  _cpp_init_toklist (&pfile->token_list, 0);\n-  pfile->no_expand_level = UINT_MAX;\n-  pfile->context_cap = 20;\n-  pfile->cur_context = 0;\n-\n-  pfile->contexts = (cpp_context *)\n-    xmalloc (pfile->context_cap * sizeof (cpp_context));\n-\n-  /* Clear the base context.  */\n-  base = &pfile->contexts[0];\n-  base->u.list = &pfile->token_list;\n-  base->posn = 0;\n-  base->count = 0;\n-  base->args = 0;\n-  base->level = 0;\n-  base->flags = 0;\n-  base->pushed_token = 0;\n-}\n+  len = ALIGN (len, pool->align);\n+  if (len > (unsigned int) POOL_ROOM (pool))\n+    _cpp_next_chunk (pool, len, 0);\n \n-/* Moves to the end of the directive line, popping contexts as\n-   necessary.  */\n-void\n-_cpp_skip_rest_of_line (pfile)\n-     cpp_reader *pfile;\n-{\n-  /* Discard all stacked contexts.  */\n-  int i;\n-  for (i = pfile->cur_context; i > 0; i--)\n-    if (pfile->contexts[i].args)\n-      free_macro_args (pfile->contexts[i].args);\n-\n-  if (pfile->no_expand_level <= pfile->cur_context)\n-    pfile->no_expand_level = 0;\n-  pfile->cur_context = 0;\n-\n-  /* Clear the base context, and clear the directive pointer so that\n-     get_raw_token will advance to the next line.  */\n-  pfile->contexts[0].count = 0;\n-  pfile->contexts[0].posn = 0;\n-  pfile->token_list.directive = 0;\n+  return POOL_FRONT (pool);\n }\n \n-/* Directive handler wrapper used by the command line option\n-   processor.  */\n-void\n-_cpp_run_directive (pfile, dir, buf, count, name)\n-     cpp_reader *pfile;\n-     const struct directive *dir;\n-     const char *buf;\n-     size_t count;\n-     const char *name;\n+/* Allocate LEN bytes from a memory pool.  */\n+unsigned char *\n+_cpp_pool_alloc (pool, len)\n+     cpp_pool *pool;\n+     unsigned int len;\n {\n-  if (cpp_push_buffer (pfile, (const U_CHAR *)buf, count) != NULL)\n-    {\n-      unsigned int prev_lvl = 0;\n+  unsigned char *result = _cpp_pool_reserve (pool, len);\n \n-      if (name)\n-\tCPP_BUFFER (pfile)->nominal_fname = name;\n-      else\n-\tCPP_BUFFER (pfile)->nominal_fname = _(\"<command line>\");\n-      CPP_BUFFER (pfile)->lineno = (unsigned int)-1;\n-\n-      /* Scan the line now, else prevent_macro_expansion won't work.  */\n-      lex_next (pfile, 1);\n-      if (! (dir->flags & EXPAND))\n-\tprev_lvl = prevent_macro_expansion (pfile);\n-\n-      (void) (*dir->handler) (pfile);\n-\n-      if (! (dir->flags & EXPAND))\n-\trestore_macro_expansion (pfile, prev_lvl);\n-      \n-      _cpp_skip_rest_of_line (pfile);\n-      cpp_pop_buffer (pfile);\n-    }\n+  POOL_COMMIT (pool, len);\n+  return result;\n }"}, {"sha": "5f54e604797bbcce92782e865b861063a4a76a66", "filename": "gcc/cpplib.c", "status": "modified", "additions": 794, "deletions": 666, "changes": 1460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c80368d9a16c073f2b930bef4232661971765f/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c80368d9a16c073f2b930bef4232661971765f/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=93c80368d9a16c073f2b930bef4232661971765f", "patch": "@@ -28,48 +28,112 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"obstack.h\"\n #include \"symcat.h\"\n \n+/* Chained list of answers to an assertion.  */\n+struct answer\n+{\n+  struct answer *next;\n+  unsigned int count;\n+  cpp_token first[1];\n+};\n+\n /* Stack of conditionals currently in progress\n    (including both successful and failing conditionals).  */\n \n struct if_stack\n {\n   struct if_stack *next;\n-  unsigned int lineno;\t\t/* line number where condition started */\n-  unsigned int colno;\t\t/* and column */\n+  cpp_lexer_pos pos;\t\t/* line and column where condition started */\n+  const cpp_hashnode *mi_cmacro;/* macro name for #ifndef around entire file */\n   int was_skipping;\t\t/* value of pfile->skipping before this if */\n-  const cpp_hashnode *cmacro;\t/* macro name for #ifndef around entire file */\n   int type;\t\t\t/* type of last directive seen in this group */\n };\n \n+/* Values for the origin field of struct directive.  KANDR directives\n+   come from traditional (K&R) C.  STDC89 directives come from the\n+   1989 C standard.  EXTENSION directives are extensions.  */\n+#define KANDR\t\t0\n+#define STDC89\t\t1\n+#define EXTENSION\t2\n+\n+/* Values for the flags field of struct directive.  COND indicates a\n+   conditional; IF_COND an opening conditional.  INCL means to treat\n+   \"...\" and <...> as q-char and h-char sequences respectively.  IN_I\n+   means this directive should be handled even if -fpreprocessed is in\n+   effect (these are the directives with callback hooks).  */\n+#define COND\t\t(1 << 0)\n+#define IF_COND\t\t(1 << 1)\n+#define INCL\t\t(1 << 2)\n+#define IN_I\t\t(1 << 3)\n+\n+/* Defines one #-directive, including how to handle it.  */\n+typedef void (*directive_handler) PARAMS ((cpp_reader *));\n+typedef struct directive directive;\n+struct directive\n+{\n+  directive_handler handler;\t/* Function to handle directive.  */\n+  const U_CHAR *name;\t\t/* Name of directive.  */\n+  unsigned short length;\t/* Length of name.  */\n+  unsigned char origin;\t\t/* Origin of directive.  */\n+  unsigned char flags;\t        /* Flags describing this directive.  */\n+};\n+\n /* Forward declarations.  */\n \n-static void validate_else\tPARAMS ((cpp_reader *, const U_CHAR *));\n-static int  parse_include\tPARAMS ((cpp_reader *, const U_CHAR *, int,\n-\t\t\t\t\t const U_CHAR **, unsigned int *,\n-\t\t\t\t\t int *));\n+static void skip_rest_of_line\tPARAMS ((cpp_reader *));\n+static void check_eol\t\tPARAMS ((cpp_reader *));\n+static void run_directive\tPARAMS ((cpp_reader *, int,\n+\t\t\t\t\t const char *, unsigned int,\n+\t\t\t\t\t const char *));\n+static int glue_header_name\tPARAMS ((cpp_reader *, cpp_token *));\n+static int  parse_include\tPARAMS ((cpp_reader *, cpp_token *));\n static void push_conditional\tPARAMS ((cpp_reader *, int, int,\n \t\t\t\t\t const cpp_hashnode *));\n static int  read_line_number\tPARAMS ((cpp_reader *, int *));\n static int  strtoul_for_line\tPARAMS ((const U_CHAR *, unsigned int,\n \t\t\t\t\t unsigned long *));\n static void do_diagnostic\tPARAMS ((cpp_reader *, enum error_type));\n-static const cpp_hashnode *\n-\t    parse_ifdef\t\tPARAMS ((cpp_reader *, const U_CHAR *));\n-static const cpp_hashnode *\n-\t    detect_if_not_defined PARAMS ((cpp_reader *));\n static cpp_hashnode *\n-\t    get_define_node\tPARAMS ((cpp_reader *));\n+\tlex_macro_node\t\tPARAMS ((cpp_reader *));\n static void unwind_if_stack\tPARAMS ((cpp_reader *, cpp_buffer *));\n+static void do_pragma_once\tPARAMS ((cpp_reader *));\n+static void do_pragma_poison\tPARAMS ((cpp_reader *));\n+static void do_pragma_system_header\tPARAMS ((cpp_reader *));\n+static void do_pragma_dependency\tPARAMS ((cpp_reader *));\n+static int parse_answer PARAMS ((cpp_reader *, struct answer **, int));\n+static cpp_hashnode *parse_assertion PARAMS ((cpp_reader *, struct answer **,\n+\t\t\t\t\t      int));\n+static struct answer ** find_answer PARAMS ((cpp_hashnode *,\n+\t\t\t\t\t     const struct answer *));\n \n /* This is the table of directive handlers.  It is ordered by\n    frequency of occurrence; the numbers at the end are directive\n    counts from all the source code I have lying around (egcs and libc\n    CVS as of 1999-05-18, plus grub-0.5.91, linux-2.2.9, and\n-   pcmcia-cs-3.0.9).\n+   pcmcia-cs-3.0.9).  This is no longer important as directive lookup\n+   is now O(1).  All extensions other than #warning and #include_next\n+   are deprecated.  The name is where the extension appears to have\n+   come from.  */\n \n-   The entries with a dash and a name after the count are extensions,\n-   of which all but #warning and #include_next are deprecated.  The name\n-   is where the extension appears to have come from.  */\n+#define DIRECTIVE_TABLE\t\t\t\t\t\t\t\\\n+D(define,\tT_DEFINE = 0,\tKANDR,     IN_I)\t   /* 270554 */ \\\n+D(include,\tT_INCLUDE,\tKANDR,     INCL)\t   /*  52262 */ \\\n+D(endif,\tT_ENDIF,\tKANDR,     COND)\t   /*  45855 */ \\\n+D(ifdef,\tT_IFDEF,\tKANDR,     COND | IF_COND) /*  22000 */ \\\n+D(if,\t\tT_IF,\t\tKANDR,     COND | IF_COND) /*  18162 */ \\\n+D(else,\t\tT_ELSE,\t\tKANDR,     COND)\t   /*   9863 */ \\\n+D(ifndef,\tT_IFNDEF,\tKANDR,     COND | IF_COND) /*   9675 */ \\\n+D(undef,\tT_UNDEF,\tKANDR,     IN_I)\t   /*   4837 */ \\\n+D(line,\t\tT_LINE,\t\tKANDR,     IN_I)\t   /*   2465 */ \\\n+D(elif,\t\tT_ELIF,\t\tKANDR,     COND)\t   /*    610 */ \\\n+D(error,\tT_ERROR,\tSTDC89,    0)\t\t   /*    475 */ \\\n+D(pragma,\tT_PRAGMA,\tSTDC89,    IN_I)\t   /*    195 */ \\\n+D(warning,\tT_WARNING,\tEXTENSION, 0)\t\t   /*     22 */ \\\n+D(include_next,\tT_INCLUDE_NEXT,\tEXTENSION, INCL)\t   /*     19 */ \\\n+D(ident,\tT_IDENT,\tEXTENSION, IN_I)\t   /*     11 */ \\\n+D(import,\tT_IMPORT,\tEXTENSION, INCL)\t   /* 0 ObjC */\t\\\n+D(assert,\tT_ASSERT,\tEXTENSION, 0)\t\t   /* 0 SVR4 */\t\\\n+D(unassert,\tT_UNASSERT,\tEXTENSION, 0)\t\t   /* 0 SVR4 */\t\\\n+SCCS_ENTRY\t\t\t\t\t\t   /* 0 SVR4? */\n \n /* #sccs is not always recognized.  */\n #ifdef SCCS_DIRECTIVE\n@@ -78,27 +142,6 @@ static void unwind_if_stack\tPARAMS ((cpp_reader *, cpp_buffer *));\n # define SCCS_ENTRY /* nothing */\n #endif\n \n-#define DIRECTIVE_TABLE\t\t\t\t\t\t\t\\\n-D(define,\tT_DEFINE = 0,\tKANDR,     COMMENTS | IN_I)/* 270554 */ \\\n-D(include,\tT_INCLUDE,\tKANDR,     EXPAND | INCL)  /*  52262 */ \\\n-D(endif,\tT_ENDIF,\tKANDR,     COND)\t   /*  45855 */ \\\n-D(ifdef,\tT_IFDEF,\tKANDR,     COND)\t   /*  22000 */ \\\n-D(if,\t\tT_IF,\t\tKANDR,     COND | EXPAND)  /*  18162 */ \\\n-D(else,\t\tT_ELSE,\t\tKANDR,     COND)\t   /*   9863 */ \\\n-D(ifndef,\tT_IFNDEF,\tKANDR,     COND)\t   /*   9675 */ \\\n-D(undef,\tT_UNDEF,\tKANDR,     IN_I)\t   /*   4837 */ \\\n-D(line,\t\tT_LINE,\t\tKANDR,     EXPAND)    \t   /*   2465 */ \\\n-D(elif,\t\tT_ELIF,\t\tKANDR,     COND | EXPAND)  /*    610 */ \\\n-D(error,\tT_ERROR,\tSTDC89,    0)\t\t   /*    475 */ \\\n-D(pragma,\tT_PRAGMA,\tSTDC89,    IN_I)\t   /*    195 */ \\\n-D(warning,\tT_WARNING,\tEXTENSION, 0)\t\t   /*     22 GNU   */ \\\n-D(include_next,\tT_INCLUDE_NEXT,\tEXTENSION, EXPAND | INCL)  /*     19 GNU   */ \\\n-D(ident,\tT_IDENT,\tEXTENSION, IN_I)\t   /*     11 SVR4  */ \\\n-D(import,\tT_IMPORT,\tEXTENSION, EXPAND | INCL)  /*      0 ObjC  */ \\\n-D(assert,\tT_ASSERT,\tEXTENSION, 0)  \t\t   /*      0 SVR4  */ \\\n-D(unassert,\tT_UNASSERT,\tEXTENSION, 0)  \t\t   /*      0 SVR4  */ \\\n-SCCS_ENTRY\t\t\t\t\t\t   /*      0 SVR2? */\n-\n /* Use the table to generate a series of prototypes, an enum for the\n    directive names, and an array of directive handlers.  */\n \n@@ -114,6 +157,7 @@ DIRECTIVE_TABLE\n #define D(n, tag, o, f) tag,\n enum\n {\n+  T_BAD_DIRECTIVE,\n   DIRECTIVE_TABLE\n   N_DIRECTIVES\n };\n@@ -123,265 +167,405 @@ enum\n #define D(name, t, origin, flags) \\\n { CONCAT2(do_,name), (const U_CHAR *) STRINGX(name), \\\n   sizeof STRINGX(name) - 1, origin, flags },\n-static const struct directive dtable[] =\n+static const directive dtable[] =\n {\n DIRECTIVE_TABLE\n };\n #undef D\n #undef DIRECTIVE_TABLE\n \n-/* Check if a token's name matches that of a known directive.  Put in\n-   this file to save exporting dtable and other unneeded information.  */\n-const struct directive *\n-_cpp_check_directive (pfile, token)\n+/* Skip any remaining tokens in a directive.  */\n+static void\n+skip_rest_of_line (pfile)\n      cpp_reader *pfile;\n-     const cpp_token *token;\n {\n-  unsigned int i;\n+  cpp_token token;\n+\n+  /* Discard all stacked contexts.  */\n+  while (pfile->context != &pfile->base_context)\n+    _cpp_pop_context (pfile);\n+\n+  /* Sweep up all tokens remaining on the line.  We need to read\n+     tokens from lookahead, but cannot just drop the lookahead buffers\n+     because they may be saving tokens prior to this directive for an\n+     external client.  So we use cpp_get_token, with macros disabled.  */\n+  pfile->state.prevent_expansion++;\n+  while (!pfile->state.skip_newlines)\n+    _cpp_lex_token (pfile, &token);\n+  pfile->state.prevent_expansion--;\n+}\n \n-  if (token->type != CPP_NAME)\n+/* Ensure there are no stray tokens at the end of a directive.  */\n+static void\n+check_eol (pfile)\n+     cpp_reader *pfile;\n+{\n+  if (!pfile->state.skip_newlines)\n     {\n-      if (token->type == CPP_EOF && CPP_WTRADITIONAL (pfile)\n-\t  && pfile->state.indented)\n-\tcpp_warning (pfile, \"traditional C ignores #\\\\n with the # indented\");\n+      cpp_token token;\n \n-      return 0;\n+      _cpp_lex_token (pfile, &token);\n+      if (token.type != CPP_EOF)\n+\tcpp_pedwarn (pfile, \"extra tokens at end of #%s directive\",\n+\t\t     pfile->directive->name);\n     }\n+}\n+\n+/* Check if a token's name matches that of a known directive.  Put in\n+   this file to save exporting dtable and other unneeded information.  */\n+int\n+_cpp_handle_directive (pfile, indented)\n+     cpp_reader *pfile;\n+     int indented;\n+{\n+  const directive *dir = 0;\n+  cpp_token dname;\n+  int not_asm = 1;\n \n-  for (i = 0; i < N_DIRECTIVES; i++)\n-    if (pfile->spec_nodes->dirs[i] == token->val.node)\n-      break;\n+  /* Some handlers need the position of the # for diagnostics.  */\n+  pfile->directive_pos = pfile->lexer_pos;\n \n-  if (i == N_DIRECTIVES)\n-    return 0;\n+  /* We're now in a directive.  This ensures we get pedantic warnings\n+     about /v and /f in whitespace.  */\n+  pfile->state.in_directive = 1;\n+  pfile->state.save_comments = 0;\n \n-  /* We should lex headers correctly, regardless of whether we're\n-     skipping or not.  */\n-  pfile->state.angled_headers = dtable[i].flags & INCL;\n+  /* Lex the directive name directly.  */\n+  _cpp_lex_token (pfile, &dname);\n \n-  /* If we are rescanning preprocessed input, only directives tagged\n-     with IN_I are honored, and the warnings below are suppressed.  */\n-  if (CPP_OPTION (pfile, preprocessed))\n+  if (dname.type == CPP_NAME)\n     {\n-      if (!dtable[i].flags & IN_I)\n-\treturn 0;\n+      unsigned int index = dname.val.node->directive_index;\n+      if (index)\n+\tdir = &dtable[index - 1];\n     }\n-  else\n+  else if (dname.type == CPP_NUMBER)\n     {\n-      /* Traditionally, a directive is ignored unless its # is in\n-\t column 1.  Therefore in code intended to work with K+R\n-\t compilers, directives added by C89 must have their #\n-\t indented, and directives present in traditional C must not.\n-\t This is true even of directives in skipped conditional\n-\t blocks.  */\n-      if (CPP_WTRADITIONAL (pfile))\n+      /* # followed by a number is equivalent to #line.  Do not\n+\t recognize this form in assembly language source files or\n+\t skipped conditional groups.  Complain about this form if\n+\t we're being pedantic, but not if this is regurgitated input\n+\t (preprocessed or fed back in by the C++ frontend).  */\n+      if (!pfile->skipping  && !CPP_OPTION (pfile, lang_asm))\n \t{\n-\t  if (pfile->state.indented && dtable[i].origin == KANDR)\n-\t    cpp_warning (pfile, \n-\t\t\t \"traditional C ignores #%s with the # indented\",\n-\t\t\t dtable[i].name);\n-\n-\t  else if (!pfile->state.indented && dtable[i].origin != KANDR)\n-\t    cpp_warning (pfile,\n-\t\t \"suggest hiding #%s from traditional C with an indented #\",\n-\t\t\t dtable[i].name);\n+\t  dir = &dtable[T_LINE];\n+\t  _cpp_push_token (pfile, &dname, &pfile->directive_pos);\n+\t  if (CPP_PEDANTIC (pfile) && CPP_BUFFER (pfile)->inc\n+\t      && ! CPP_OPTION (pfile, preprocessed))\n+\t    cpp_pedwarn (pfile, \"# followed by integer\");\n \t}\n+    }\n \n-      /* If we are skipping a failed conditional group, all non-conditional\n-\t directives are ignored.  */\n-      if (pfile->skipping && !(dtable[i].flags & COND))\n-\treturn 0;\n+  pfile->directive = dir;\n+  if (dir)\n+    {\n+      /* Make sure we lex headers correctly, whether skipping or not.  */\n+      pfile->state.angled_headers = dir->flags & INCL;\n \n-      /* Issue -pedantic warnings for extended directives.   */\n-      if (CPP_PEDANTIC (pfile) && dtable[i].origin == EXTENSION)\n-\tcpp_pedwarn (pfile, \"ISO C does not allow #%s\", dtable[i].name);\n+      /* If we are rescanning preprocessed input, only directives tagged\n+\t with IN_I are honored, and the warnings below are suppressed.  */\n+      if (! CPP_OPTION (pfile, preprocessed) || dir->flags & IN_I)\n+\t{\n+\t  /* Traditionally, a directive is ignored unless its # is in\n+\t     column 1.  Therefore in code intended to work with K+R\n+\t     compilers, directives added by C89 must have their #\n+\t     indented, and directives present in traditional C must\n+\t     not.  This is true even of directives in skipped\n+\t     conditional blocks.  */\n+\t  if (CPP_WTRADITIONAL (pfile))\n+\t    {\n+\t      if (indented && dir->origin == KANDR)\n+\t\tcpp_warning (pfile,\n+\t\t\t     \"traditional C ignores #%s with the # indented\",\n+\t\t\t     dir->name);\n+\t      else if (!indented && dir->origin != KANDR)\n+\t\tcpp_warning (pfile,\n+\t     \"suggest hiding #%s from traditional C with an indented #\",\n+\t\t\t     dir->name);\n+\t    }\n+\n+\t  /* If we are skipping a failed conditional group, all\n+\t     non-conditional directives are ignored.  */\n+\t  if (!pfile->skipping || (dir->flags & COND))\n+\t    {\n+\t      /* Issue -pedantic warnings for extensions.   */\n+\t      if (CPP_PEDANTIC (pfile) && dir->origin == EXTENSION)\n+\t\tcpp_pedwarn (pfile, \"#%s is a GCC extension\", dir->name);\n+\n+\t      /* If we have a directive that is not an opening\n+\t\t conditional, invalidate any control macro.  */\n+\t      if (! (dir->flags & IF_COND))\n+\t\tpfile->mi_state = MI_FAILED;\n+\n+\t      (*dir->handler) (pfile);\n+\t    }\n+\t}\n+    }\n+  else if (dname.type == CPP_EOF)\n+    {\n+      /* The null directive.  */\n+      if (indented && CPP_WTRADITIONAL (pfile))\n+\tcpp_warning (pfile, \"traditional C ignores #\\\\n with the # indented\");\n+    }\n+  else\n+    {\n+      /* An unknown directive.  Don't complain about it in assembly\n+\t source: we don't know where the comments are, and # may\n+\t introduce assembler pseudo-ops.  Don't complain about invalid\n+\t directives in skipped conditional groups (6.10 p4).  */\n+      if (CPP_OPTION (pfile, lang_asm))\n+\t{\n+\t  /* Output the # and lookahead token for the assembler.  */\n+\t  not_asm = 0;\n+\t  _cpp_push_token (pfile, &dname, &pfile->directive_pos);\n+\t}\n+      else if (!pfile->skipping)\n+\tcpp_error (pfile, \"invalid preprocessing directive #%s\",\n+\t\t   cpp_token_as_text (pfile, &dname));\n     }\n \n-  /* Only flag to save comments if we process the directive.  */\n-  pfile->state.save_comments = (! CPP_OPTION (pfile, discard_comments)\n-\t\t\t\t&& (dtable[i].flags & COMMENTS));\n+  /* Save the lookahead token for assembler.  */\n+  if (not_asm)\n+    skip_rest_of_line (pfile);\n+  pfile->state.save_comments = ! CPP_OPTION (pfile, discard_comments);\n+  pfile->state.in_directive = 0;\n+  pfile->state.angled_headers = 0;\n+  pfile->directive = 0;\n \n-  return &dtable[i];\n+  return not_asm;\n }\n \n-const struct directive *\n-_cpp_check_linemarker (pfile, token)\n+/* Directive handler wrapper used by the command line option\n+   processor.  */\n+static void\n+run_directive (pfile, dir_no, buf, count, name)\n      cpp_reader *pfile;\n-     const cpp_token *token ATTRIBUTE_UNUSED;\n+     int dir_no;\n+     const char *buf;\n+     size_t count;\n+     const char *name;\n {\n-  /* # followed by a number is equivalent to #line.  Do not recognize\n-     this form in assembly language source files or skipped\n-     conditional groups.  Complain about this form if we're being\n-     pedantic, but not if this is regurgitated input (preprocessed or\n-     fed back in by the C++ frontend).  */\n-  if (pfile->skipping || CPP_OPTION (pfile, lang_asm))\n-    return 0;\n-\n-  if (CPP_PEDANTIC (pfile) && CPP_BUFFER (pfile)->inc\n-      && ! CPP_OPTION (pfile, preprocessed))\n-    cpp_pedwarn (pfile, \"# followed by integer\");\n-\n-  /* In -traditional mode, a directive is ignored unless its #\n-     is in column 1.  */\n-  if (pfile->state.indented && CPP_WTRADITIONAL (pfile))\n-    cpp_warning (pfile, \"traditional C ignores #%s with the # indented\",\n-\t\t dtable[T_LINE].name);\n-\n-  return &dtable[T_LINE];\n-}  \n+  if (cpp_push_buffer (pfile, (const U_CHAR *)buf, count) != NULL)\n+    {\n+      const struct directive *dir = &dtable[dir_no];\n+\n+      if (name)\n+\tCPP_BUFFER (pfile)->nominal_fname = name;\n+      else\n+\tCPP_BUFFER (pfile)->nominal_fname = _(\"<command line>\");\n+      CPP_BUFFER (pfile)->lineno = (unsigned int)-1;\n+\n+      pfile->state.in_directive = 1;\n+      pfile->directive = dir;\n+      (void) (*dir->handler) (pfile);\n+      pfile->directive = 0;\n+      pfile->state.in_directive = 0;\n \n+      skip_rest_of_line (pfile);\n+      cpp_pop_buffer (pfile);\n+    }\n+}\n+\n+/* Checks for validity the macro name in #define, #undef, #ifdef and\n+   #ifndef directives.  */\n static cpp_hashnode *\n-get_define_node (pfile)\n+lex_macro_node (pfile)\n      cpp_reader *pfile;\n {\n-  const cpp_token *token;\n+  cpp_token token;\n \n-  /* Skip any -C comments.  */\n-  while ((token = _cpp_get_token (pfile))->type == CPP_COMMENT)\n-    ;\n+  /* Lex the macro name directly.  */\n+  _cpp_lex_token (pfile, &token);\n \n   /* The token immediately after #define must be an identifier.  That\n      identifier is not allowed to be \"defined\".  See predefined macro\n      names (6.10.8.4).  In C++, it is not allowed to be any of the\n      <iso646.h> macro names (which are keywords in C++) either.  */\n \n-  if (token->type != CPP_NAME)\n+  if (token.type != CPP_NAME)\n     {\n-      if (token->type == CPP_DEFINED)\n-\tcpp_error_with_line (pfile, token->line, token->col,\n-\t\t\t     \"\\\"defined\\\" cannot be used as a macro name\");\n-      else if (token->flags & NAMED_OP)\n-\tcpp_error_with_line (pfile, token->line, token->col,\n-\t\t\t     \"\\\"%s\\\" cannot be used as a macro name in C++\",\n-\t\t\t     token->val.node->name);\n+      if (token.type == CPP_EOF)\n+\tcpp_error (pfile, \"no macro name given in #%s directive\",\n+\t\t   pfile->directive->name);\n+      else if (token.flags & NAMED_OP)\n+\tcpp_error (pfile,\n+\t\t   \"\\\"%s\\\" cannot be used as a macro name as it is an operator in C++\",\n+\t\t   token.val.node->name);\n       else\n-\tcpp_error_with_line (pfile, token->line, token->col,\n-\t\t\t   \"macro names must be identifiers\");\n-      return 0;\n-    }\n-\n-  /* In Objective C, some keywords begin with '@', but general identifiers\n-     do not, and you're not allowed to #define them.  */\n-  if (token->val.node->name[0] == '@')\n-    {\n-      cpp_error_with_line (pfile, token->line, token->col,\n-\t\t\t   \"\\\"%s\\\" cannot be used as a macro name\",\n-\t\t\t   token->val.node->name);\n-      return 0;\n+\tcpp_error (pfile, \"macro names must be identifiers\");\n     }\n-\n-  /* Check for poisoned identifiers now.  */\n-  if (token->val.node->type == T_POISON)\n+  else\n     {\n-      cpp_error_with_line (pfile, token->line, token->col,\n-\t\t\t   \"attempt to use poisoned \\\"%s\\\"\",\n-\t\t\t   token->val.node->name);\n-      return 0;\n+      cpp_hashnode *node = token.val.node;\n+\n+      /* In Objective C, some keywords begin with '@', but general\n+\t identifiers do not, and you're not allowed to #define them.  */\n+      if (node == pfile->spec_nodes.n_defined || node->name[0] == '@')\n+\tcpp_error (pfile, \"\\\"%s\\\" cannot be used as a macro name\", node->name);\n+      else if (!(node->flags & NODE_POISONED))\n+\treturn node;\n     }\n \n-  return token->val.node;\n+  return 0;\n }\n \n-/* Process a #define command.  */\n+/* Process a #define directive.  Most work is done in cppmacro.c.  */\n static void\n do_define (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_hashnode *node;\n+  cpp_hashnode *node = lex_macro_node (pfile);\n \n-  if ((node = get_define_node (pfile)))\n-    if (_cpp_create_definition (pfile, node))\n-      if (pfile->cb.define)\n-\t(*pfile->cb.define) (pfile, node);\n+  if (node)\n+    {\n+      /* Use the permanent pool for storage.  */\n+      pfile->string_pool = &pfile->ident_pool;\n+\n+      if (_cpp_create_definition (pfile, node))\n+\tif (pfile->cb.define)\n+\t  (*pfile->cb.define) (pfile, node);\n+\n+      /* Revert to the temporary pool.  */\n+      pfile->string_pool = &pfile->temp_string_pool;\n+    }\n }\n \n-/* Remove the definition of a symbol from the symbol table.  */\n+/* Handle #undef.  Marks the identifier NT_VOID in the hash table.  */\n static void\n do_undef (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_hashnode *node = get_define_node (pfile);  \n-\n-  if (_cpp_get_token (pfile)->type != CPP_EOF)\n-    cpp_pedwarn (pfile, \"junk on line after #undef\");\n+  cpp_hashnode *node = lex_macro_node (pfile);  \n \n   /* 6.10.3.5 paragraph 2: [#undef] is ignored if the specified identifier\n      is not currently defined as a macro name.  */\n-  if (node && node->type != T_VOID)\n+  if (node && node->type == NT_MACRO)\n     {\n       if (pfile->cb.undef)\n \t(*pfile->cb.undef) (pfile, node);\n \n-      if (node->type != T_MACRO)\n+      if (node->flags & NODE_BUILTIN)\n \tcpp_warning (pfile, \"undefining \\\"%s\\\"\", node->name);\n \n       _cpp_free_definition (node);\n     }\n+  check_eol (pfile);\n }\n \n+/* Helper routine used by parse_include.  Reinterpret the current line\n+   as an h-char-sequence (< ... >); we are looking at the first token\n+   after the <.  Returns zero on success.  */\n+static int\n+glue_header_name (pfile, header)\n+     cpp_reader *pfile;\n+     cpp_token *header;\n+{\n+  cpp_token token;\n+  unsigned char *buffer, *token_mem;\n+  size_t len, total_len = 0, capacity = 1024;\n+\n+  /* To avoid lexed tokens overwriting our glued name, we can only\n+     allocate from the string pool once we've lexed everything.  */\n+\n+  buffer = (unsigned char *) xmalloc (capacity);\n+  for (;;)\n+    {\n+      _cpp_get_token (pfile, &token);\n+\n+      if (token.type == CPP_GREATER || token.type == CPP_EOF)\n+\tbreak;\n+\n+      len = cpp_token_len (&token);\n+      if (total_len + len > capacity)\n+\t{\n+\t  capacity = (capacity + len) * 2;\n+\t  buffer = (unsigned char *) realloc (buffer, capacity);\n+\t}\n+\n+      if (token.flags & PREV_WHITE)\n+\tbuffer[total_len++] = ' ';\n+\n+      total_len = cpp_spell_token (pfile, &token, &buffer[total_len]) - buffer;\n+    }\n+\n+  if (token.type == CPP_EOF)\n+    cpp_error (pfile, \"missing terminating > character\");\n+  else\n+    {\n+      token_mem = _cpp_pool_alloc (pfile->string_pool, total_len);\n+      memcpy (token_mem, buffer, total_len);\n+\n+      header->type = CPP_HEADER_NAME;\n+      header->flags &= ~PREV_WHITE;\n+      header->val.str.len = total_len;\n+      header->val.str.text = token_mem;\n+    }\n \n-/* Handle #include and #import.  */\n+  free ((PTR) buffer);\n+  return token.type == CPP_EOF;\n+}\n \n+/* Parse the header name of #include, #include_next, #import and\n+   #pragma dependency.  Returns zero on success.  */\n static int\n-parse_include (pfile, dir, trail, strp, lenp, abp)\n+parse_include (pfile, header)\n      cpp_reader *pfile;\n-     const U_CHAR *dir;\n-     int trail;\n-     const U_CHAR **strp;\n-     unsigned int *lenp;\n-     int *abp;\n+     cpp_token *header;\n {\n-  const cpp_token *name = _cpp_get_token (pfile);\n+  int is_pragma = pfile->directive == &dtable[T_PRAGMA];\n+  const unsigned char *dir;\n \n-  if (name->type != CPP_STRING && name->type != CPP_HEADER_NAME)\n+  if (is_pragma)\n+    dir = U\"pragma dependency\";\n+  else\n+    dir = pfile->directive->name;\n+\n+  /* Allow macro expansion.  */\n+  cpp_get_token (pfile, header);\n+  if (header->type != CPP_STRING && header->type != CPP_HEADER_NAME)\n     {\n-      if (name->type == CPP_LESS)\n-\tname = _cpp_glue_header_name (pfile);\n-      else\n+      if (header->type != CPP_LESS)\n \t{\n \t  cpp_error (pfile, \"#%s expects \\\"FILENAME\\\" or <FILENAME>\", dir);\n \t  return 1;\n \t}\n+      if (glue_header_name (pfile, header))\n+\treturn 1;\n     }\n-  if (name->val.str.len == 0)\n+\n+  if (header->val.str.len == 0)\n     {\n       cpp_error (pfile, \"empty file name in #%s\", dir);\n       return 1;\n     }\n \n-  if (!trail && _cpp_get_token (pfile)->type != CPP_EOF)\n-    cpp_error (pfile, \"junk at end of #%s\", dir);\n-\n-  *lenp = name->val.str.len;\n-  *strp = name->val.str.text;\n-  *abp = (name->type == CPP_HEADER_NAME);\n+  if (!is_pragma)\n+    {\n+      check_eol (pfile);\n+      /* Get out of macro context, if we are.  */\n+      skip_rest_of_line (pfile);\n+      if (pfile->cb.include)\n+\t(*pfile->cb.include) (pfile, dir, header);\n+    }\n \n-  if (pfile->cb.include)\n-    (*pfile->cb.include) (pfile, dir, *strp, *lenp, *abp);\n   return 0;\n }\n \n static void\n do_include (pfile)\n      cpp_reader *pfile;\n {\n-  unsigned int len;\n-  const U_CHAR *str;\n-  int ab;\n-\n-  if (parse_include (pfile, dtable[T_INCLUDE].name, 0, &str, &len, &ab))\n-    return;\n+  cpp_token header;\n \n-  _cpp_execute_include (pfile, str, len, 0, 0, ab);\n+  if (!parse_include (pfile, &header))\n+    _cpp_execute_include (pfile, &header, 0, 0);\n }\n \n static void\n do_import (pfile)\n      cpp_reader *pfile;\n {\n-  unsigned int len;\n-  const U_CHAR *str;\n-  int ab;\n+  cpp_token header;\n \n   if (!pfile->import_warning && CPP_OPTION (pfile, warn_import))\n     {\n@@ -390,22 +574,18 @@ do_import (pfile)\n \t   \"#import is obsolete, use an #ifndef wrapper in the header file\");\n     }\n \n-  if (parse_include (pfile, dtable[T_IMPORT].name, 0, &str, &len, &ab))\n-    return;\n-\n-  _cpp_execute_include (pfile, str, len, 1, 0, ab);\n+  if (!parse_include (pfile, &header))\n+    _cpp_execute_include (pfile, &header, 1, 0);\n }\n \n static void\n do_include_next (pfile)\n      cpp_reader *pfile;\n {\n-  unsigned int len;\n-  const U_CHAR *str;\n+  cpp_token header;\n   struct file_name_list *search_start = 0;\n-  int ab;\n \n-  if (parse_include (pfile, dtable[T_INCLUDE_NEXT].name, 0, &str, &len, &ab))\n+  if (parse_include (pfile, &header))\n     return;\n \n   /* For #include_next, skip in the search path past the dir in which\n@@ -426,7 +606,7 @@ do_include_next (pfile)\n   else\n     cpp_warning (pfile, \"#include_next in primary source file\");\n \n-  _cpp_execute_include (pfile, str, len, 0, search_start, ab);\n+  _cpp_execute_include (pfile, &header, 0, search_start);\n }\n \n /* Subroutine of do_line.  Read next token from PFILE without adding it to\n@@ -439,22 +619,23 @@ read_line_number (pfile, num)\n      cpp_reader *pfile;\n      int *num;\n {\n-  const cpp_token *tok = _cpp_get_token (pfile);\n-  enum cpp_ttype type = tok->type;\n-  const U_CHAR *p = tok->val.str.text;\n-  unsigned int len = tok->val.str.len;\n+  cpp_token token;\n+  unsigned int val;\n \n-  if (type == CPP_NUMBER && len == 1 && p[0] >= '1' && p[0] <= '4')\n+  _cpp_lex_token (pfile, &token);\n+  if (token.type == CPP_NUMBER && token.val.str.len == 1)\n     {\n-      *num = p[0] - '0';\n-      return 1;\n-    }\n-  else\n-    {\n-      if (type != CPP_EOF)\n-\tcpp_error (pfile, \"invalid format #line\");\n-      return 0;\n+      val = token.val.str.text[0] - '1';\n+      if (val <= 3)\n+\t{\n+\t  *num = val + 1;\n+\t  return 1;\n+\t}\n     }\n+\n+  if (token.type != CPP_EOF)\n+    cpp_error (pfile, \"invalid format #line\");\n+  return 0;\n }\n \n /* Another subroutine of do_line.  Convert a number in STR, of length\n@@ -489,90 +670,88 @@ do_line (pfile)\n      cpp_reader *pfile;\n {\n   cpp_buffer *ip = CPP_BUFFER (pfile);\n-  unsigned long new_lineno, old_lineno;\n+  unsigned long new_lineno;\n   /* C99 raised the minimum limit on #line numbers.  */\n   unsigned int cap = CPP_OPTION (pfile, c99) ? 2147483647 : 32767;\n-  int action_number = 0;\n   int enter = 0, leave = 0, rename = 0;\n-  enum cpp_ttype type;\n-  const U_CHAR *str;\n-  char *fname;\n-  unsigned int len;\n-  const cpp_token *tok;\n-\n-  tok = _cpp_get_token (pfile);\n-  type = tok->type;\n-  str = tok->val.str.text;\n-  len = tok->val.str.len;\n-\n-  if (type != CPP_NUMBER || strtoul_for_line (str, len, &new_lineno))\n+  cpp_token token;\n+\n+  /* #line commands expand macros.  */\n+  _cpp_get_token (pfile, &token);\n+  if (token.type != CPP_NUMBER\n+      || strtoul_for_line (token.val.str.text, token.val.str.len, &new_lineno))\n     {\n-      cpp_error (pfile, \"token after #line is not a positive integer\");\n+      cpp_error (pfile, \"\\\"%s\\\" after #line is not a positive integer\",\n+\t\t cpp_token_as_text (pfile, &token));\n       return;\n     }      \n \n   if (CPP_PEDANTIC (pfile) && (new_lineno == 0 || new_lineno > cap))\n     cpp_pedwarn (pfile, \"line number out of range\");\n \n-  old_lineno = ip->lineno;\n-  ip->lineno = new_lineno;\n-  tok = _cpp_get_token (pfile);\n-  type = tok->type;\n-  str = tok->val.str.text;\n-  len = tok->val.str.len;\n+  _cpp_get_token (pfile, &token);\n \n-  if (type == CPP_EOF)\n-    goto done;\n-  else if (type != CPP_STRING)\n+  if (token.type != CPP_EOF)\n     {\n-      cpp_error (pfile, \"second token after #line is not a string\");\n-      ip->lineno = old_lineno;  /* malformed #line should have no effect */\n-      return;\n-    }\n+      char *fname;\n+      unsigned int len;\n+      int action_number = 0;\n \n-  fname = alloca (len + 1);\n-  memcpy (fname, str, len);\n-  fname[len] = '\\0';\n-    \n-  if (strcmp (fname, ip->nominal_fname))\n-    {\n-      rename = 1;\n-      if (!strcmp (fname, ip->inc->name))\n-\tip->nominal_fname = ip->inc->name;\n-      else\n-\tip->nominal_fname = _cpp_fake_include (pfile, fname);\n-    }\n+      if (token.type != CPP_STRING)\n+\t{\n+\t  cpp_error (pfile, \"\\\"%s\\\" is not a valid filename\",\n+\t\t     cpp_token_as_text (pfile, &token));\n+\t  return;\n+\t}\n \n-  if (read_line_number (pfile, &action_number) == 0)\n-    goto done;\n+      len = token.val.str.len;\n+      fname = alloca (len + 1);\n+      memcpy (fname, token.val.str.text, len);\n+      fname[len] = '\\0';\n+    \n+      if (strcmp (fname, ip->nominal_fname))\n+\t{\n+\t  rename = 1;\n+\t  if (!strcmp (fname, ip->inc->name))\n+\t    ip->nominal_fname = ip->inc->name;\n+\t  else\n+\t    ip->nominal_fname = _cpp_fake_include (pfile, fname);\n+\t}\n \n-  if (CPP_PEDANTIC (pfile))\n-    cpp_pedwarn (pfile, \"garbage at end of #line\");\n+      if (read_line_number (pfile, &action_number) != 0)\n+\t{\n+\t  if (CPP_PEDANTIC (pfile))\n+\t    cpp_pedwarn (pfile,  \"extra tokens at end of #line directive\");\n \n-  if (action_number == 1)\n-    {\n-      enter = 1;\n-      cpp_make_system_header (pfile, ip, 0);\n-      read_line_number (pfile, &action_number);\n-    }\n-  else if (action_number == 2)\n-    {\n-      leave = 1;\n-      cpp_make_system_header (pfile, ip, 0);\n-      read_line_number (pfile, &action_number);\n-    }\n-  if (action_number == 3)\n-    {\n-      cpp_make_system_header (pfile, ip, 1);\n-      read_line_number (pfile, &action_number);\n-    }\n-  if (action_number == 4)\n-    {\n-      cpp_make_system_header (pfile, ip, 2);\n-      read_line_number (pfile, &action_number);\n+\t  if (action_number == 1)\n+\t    {\n+\t      enter = 1;\n+\t      cpp_make_system_header (pfile, ip, 0);\n+\t      read_line_number (pfile, &action_number);\n+\t    }\n+\t  else if (action_number == 2)\n+\t    {\n+\t      leave = 1;\n+\t      cpp_make_system_header (pfile, ip, 0);\n+\t      read_line_number (pfile, &action_number);\n+\t    }\n+\t  if (action_number == 3)\n+\t    {\n+\t      cpp_make_system_header (pfile, ip, 1);\n+\t      read_line_number (pfile, &action_number);\n+\t    }\n+\t  if (action_number == 4)\n+\t    {\n+\t      cpp_make_system_header (pfile, ip, 2);\n+\t      read_line_number (pfile, &action_number);\n+\t    }\n+\t}\n+      check_eol (pfile);\n     }\n \n- done:\n+  /* Our line number is incremented after the directive is processed.  */\n+  ip->lineno = new_lineno - 1;\n+  pfile->lexer_pos.output_line = ip->lineno;\n   if (enter && pfile->cb.enter_file)\n     (*pfile->cb.enter_file) (pfile);\n   if (leave && pfile->cb.leave_file)\n@@ -591,11 +770,12 @@ do_diagnostic (pfile, code)\n      cpp_reader *pfile;\n      enum error_type code;\n {\n-  if (_cpp_begin_message (pfile, code, NULL, 0, 0))\n+  if (_cpp_begin_message (pfile, code, NULL, 0))\n     {\n-      cpp_output_list (pfile, stderr, &pfile->token_list,\n-\t\t       pfile->first_directive_token);\n-      putc ('\\n', stderr);\n+      fprintf (stderr, \"#%s \", pfile->directive->name);\n+      pfile->state.prevent_expansion++;\n+      cpp_output_line (pfile, stderr);\n+      pfile->state.prevent_expansion--;\n     }\n }\n \n@@ -619,16 +799,15 @@ static void\n do_ident (pfile)\n      cpp_reader *pfile;\n {\n-  const cpp_token *str = _cpp_get_token (pfile);\n+  cpp_token str;\n \n-  if (str->type == CPP_STRING && _cpp_get_token (pfile)->type == CPP_EOF)\n-    {\n-      if (pfile->cb.ident)\n-\t(*pfile->cb.ident) (pfile, str->val.str.text, str->val.str.len);\n-      return;\n-    }\n+  _cpp_get_token (pfile, &str);\n+  if (str.type != CPP_STRING)\n+    cpp_error (pfile, \"invalid #ident\");\n+  else if (pfile->cb.ident)\n+    (*pfile->cb.ident) (pfile, &str.val.str);\n \n-  cpp_error (pfile, \"invalid #ident\");\n+  check_eol (pfile);\n }\n \n /* Pragmata handling.  We handle some of these, and pass the rest on\n@@ -723,11 +902,6 @@ cpp_register_pragma_space (pfile, space)\n   pfile->pragmas = new;\n }\n   \n-static void do_pragma_once\t\tPARAMS ((cpp_reader *));\n-static void do_pragma_poison\t\tPARAMS ((cpp_reader *));\n-static void do_pragma_system_header\tPARAMS ((cpp_reader *));\n-static void do_pragma_dependency\tPARAMS ((cpp_reader *));\n-\n void\n _cpp_init_internal_pragmas (pfile)\n      cpp_reader *pfile;\n@@ -749,46 +923,47 @@ do_pragma (pfile)\n      cpp_reader *pfile;\n {\n   const struct pragma_entry *p;\n-  const cpp_token *tok;\n+  cpp_token tok;\n   const cpp_hashnode *node;\n   const U_CHAR *name;\n   size_t len;\n+  int drop = 0;\n \n   p = pfile->pragmas;\n+  pfile->state.prevent_expansion++;\n+  cpp_start_lookahead (pfile);\n \n  new_space:\n-  tok = _cpp_get_token (pfile);\n-  if (tok->type == CPP_EOF)\n-    return;\n-\n-  if (tok->type != CPP_NAME)\n+  cpp_get_token (pfile, &tok);\n+  if (tok.type == CPP_NAME)\n     {\n-      cpp_error (pfile, \"malformed #pragma directive\");\n-      return;\n-    }\n-\n-  node = tok->val.node;\n-  name = node->name;\n-  len = node->length;\n-  while (p)\n-    {\n-      if (strlen (p->name) == len && !memcmp (p->name, name, len))\n+      node = tok.val.node;\n+      name = node->name;\n+      len = node->length;\n+      while (p)\n \t{\n-\t  if (p->isnspace)\n+\t  if (strlen (p->name) == len && !memcmp (p->name, name, len))\n \t    {\n-\t      p = p->u.space;\n-\t      goto new_space;\n-\t    }\n-\t  else\n-\t    {\n-\t      (*p->u.handler) (pfile);\n-\t      return;\n+\t      if (p->isnspace)\n+\t\t{\n+\t\t  p = p->u.space;\n+\t\t  goto new_space;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  (*p->u.handler) (pfile);\n+\t\t  drop = 1;\n+\t\t  break;\n+\t\t}\n \t    }\n+\t  p = p->next;\n \t}\n-      p = p->next;\n     }\n \n-  if (pfile->cb.def_pragma)\n+  cpp_stop_lookahead (pfile, drop);\n+  pfile->state.prevent_expansion--;\n+\n+  if (!drop && pfile->cb.def_pragma)\n     (*pfile->cb.def_pragma) (pfile);\n }\n \n@@ -798,14 +973,14 @@ do_pragma_once (pfile)\n {\n   cpp_buffer *ip = CPP_BUFFER (pfile);\n \n-  /* Allow #pragma once in system headers, since that's not the user's\n-     fault.  */\n   cpp_warning (pfile, \"#pragma once is obsolete\");\n  \n   if (CPP_PREV_BUFFER (ip) == NULL)\n-    cpp_warning (pfile, \"#pragma once outside include file\");\n+    cpp_warning (pfile, \"#pragma once in main file\");\n   else\n     ip->inc->cmacro = NEVER_REREAD;\n+\n+  check_eol (pfile);\n }\n \n static void\n@@ -814,34 +989,36 @@ do_pragma_poison (pfile)\n {\n   /* Poison these symbols so that all subsequent usage produces an\n      error message.  */\n-  const cpp_token *tok;\n+  cpp_token tok;\n   cpp_hashnode *hp;\n \n+  pfile->state.poisoned_ok = 1;\n   for (;;)\n     {\n-      tok = _cpp_get_token (pfile);\n-      if (tok->type == CPP_EOF)\n+      _cpp_lex_token (pfile, &tok);\n+      if (tok.type == CPP_EOF)\n \tbreak;\n-      if (tok->type != CPP_NAME)\n+      if (tok.type != CPP_NAME)\n \t{\n-\t  cpp_error (pfile, \"invalid #pragma poison directive\");\n-\t  return;\n+\t  cpp_error (pfile, \"invalid #pragma GCC poison directive\");\n+\t  break;\n \t}\n \n-      hp = tok->val.node;\n-      if (hp->type == T_POISON)\n-\t;  /* It is allowed to poison the same identifier twice.  */\n-      else\n-\t{\n-\t  if (hp->type != T_VOID)\n-\t    cpp_warning (pfile, \"poisoning existing macro \\\"%s\\\"\", hp->name);\n-\t  _cpp_free_definition (hp);\n-\t  hp->type = T_POISON;\n-\t}\n+      hp = tok.val.node;\n+      if (hp->flags & NODE_POISONED)\n+\tcontinue;\n+\n+      if (hp->type == NT_MACRO)\n+\tcpp_warning (pfile, \"poisoning existing macro \\\"%s\\\"\", hp->name);\n+      _cpp_free_definition (hp);\n+      hp->flags |= NODE_POISONED | NODE_DIAGNOSTIC;\n     }\n+  pfile->state.poisoned_ok = 0;\n \n-  if (pfile->cb.poison)\n+#if 0\t\t\t\t/* Doesn't quite work yet.  */\n+  if (tok.type == CPP_EOF && pfile->cb.poison)\n     (*pfile->cb.poison) (pfile);\n+#endif\n }\n \n /* Mark the current header as a system header.  This will suppress\n@@ -859,6 +1036,8 @@ do_pragma_system_header (pfile)\n     cpp_warning (pfile, \"#pragma system_header outside include file\");\n   else\n     cpp_make_system_header (pfile, ip, 1);\n+\n+  check_eol (pfile);\n }\n \n /* Check the modified date of the current include file against a specified\n@@ -868,32 +1047,25 @@ static void\n do_pragma_dependency (pfile)\n      cpp_reader *pfile;\n {\n-  const U_CHAR *name;\n-  unsigned int len;\n-  int ordering, ab;\n-  char left, right;\n+  cpp_token header, msg;\n+  int ordering;\n  \n-  if (parse_include (pfile, U\"pragma dependency\", 1, &name, &len, &ab))\n+  if (parse_include (pfile, &header))\n     return;\n \n-  left = ab ? '<' : '\"';\n-  right = ab ? '>' : '\"';\n- \n-  ordering = _cpp_compare_file_date (pfile, name, len, ab);\n+  ordering = _cpp_compare_file_date (pfile, &header);\n   if (ordering < 0)\n-    cpp_warning (pfile, \"cannot find source %c%s%c\", left, name, right);\n+    cpp_warning (pfile, \"cannot find source %s\",\n+\t\t cpp_token_as_text (pfile, &header));\n   else if (ordering > 0)\n     {\n-      const cpp_token *msg = _cpp_get_token (pfile);\n-      \n-      cpp_warning (pfile, \"current file is older than %c%.*s%c\",\n-\t\t   left, (int)len, name, right);\n-      if (msg->type != CPP_EOF\n-\t  && _cpp_begin_message (pfile, WARNING, NULL, msg->line, msg->col))\n-\t{\n-\t  cpp_output_list (pfile, stderr, &pfile->token_list, msg);\n-\t  putc ('\\n', stderr);\n-\t}\n+      cpp_warning (pfile, \"current file is older than %s\",\n+\t\t   cpp_token_as_text (pfile, &header));\n+      cpp_start_lookahead (pfile);\n+      cpp_get_token (pfile, &msg);\n+      cpp_stop_lookahead (pfile, msg.type == CPP_EOF);\n+      if (msg.type != CPP_EOF && _cpp_begin_message (pfile, WARNING, NULL, 0))\n+\tcpp_output_line (pfile, stderr);\n     }\n }\n \n@@ -906,137 +1078,61 @@ do_sccs (pfile)\n }\n #endif\n \n-/* We've found an `#if' directive.  If the only thing before it in\n-   this file is white space, and if it is of the form\n-   `#if ! defined SYMBOL', then SYMBOL is a possible controlling macro\n-   for inclusion of this file.  (See redundant_include_p in cppfiles.c\n-   for an explanation of controlling macros.)  If so, return the\n-   hash node for SYMBOL.  Otherwise, return NULL.  */\n-\n-static const cpp_hashnode *\n-detect_if_not_defined (pfile)\n-     cpp_reader *pfile;\n-{\n-  const cpp_token *token;\n-  cpp_hashnode *cmacro = 0;\n-\n-  /* We are guaranteed that tokens are consecutive and end in CPP_EOF.  */\n-  token = pfile->first_directive_token + 2;\n-\n-  if (token->type != CPP_NOT)\n-    return 0;\n-\n-  token++;\n-  if (token->type != CPP_DEFINED)\n-    return 0;\n-\n-  token++;\n-  if (token->type == CPP_OPEN_PAREN)\n-    token++;\n-\n-  if (token->type != CPP_NAME)\n-    return 0;\n-\n-  cmacro = token->val.node;\n-\n-  if (token[-1].type == CPP_OPEN_PAREN)\n-    {\n-      token++;\n-      if (token->type != CPP_CLOSE_PAREN)\n-\treturn 0;\n-    }\n-\n-  token++;\n-  if (token->type != CPP_EOF)\n-    return 0;\n-\n-  return cmacro;\n-}\n-\n-/* Parse an #ifdef or #ifndef directive.  Returns the hash node of the\n-   macro being tested, and issues various error messages.  */\n-\n-static const cpp_hashnode *\n-parse_ifdef (pfile, name)\n-     cpp_reader *pfile;\n-     const U_CHAR *name;\n-{\n-  enum cpp_ttype type;\n-  const cpp_hashnode *node = 0;\n-\n-  const cpp_token *token = _cpp_get_token (pfile);\n-  type = token->type;\n-\n-  if (type == CPP_EOF)\n-    cpp_pedwarn (pfile, \"#%s with no argument\", name);\n-  else if (type != CPP_NAME)\n-    cpp_pedwarn (pfile, \"#%s with invalid argument\", name);\n-  else if (_cpp_get_token (pfile)->type != CPP_EOF)\n-    cpp_pedwarn (pfile, \"garbage at end of #%s\", name);\n-\n-  if (type == CPP_NAME)\n-    node = token->val.node;\n-  if (node && node->type == T_POISON)\n-    {\n-      cpp_error (pfile, \"attempt to use poisoned identifier \\\"%s\\\"\",\n-\t\t node->name);\n-      node = 0;\n-    }\n-\n-  return node;\n-}\n-\n-/* #ifdef is dead simple.  */\n-\n static void\n do_ifdef (pfile)\n      cpp_reader *pfile;\n {\n-  const cpp_hashnode *node = 0;\n+  int skip = 1;\n \n   if (! pfile->skipping)\n-    node = parse_ifdef (pfile, dtable[T_IFDEF].name);\n+    {\n+      const cpp_hashnode *node = lex_macro_node (pfile);\n \n-  push_conditional (pfile, !(node && node->type != T_VOID), T_IFDEF, 0);\n-}\n+      if (node)\n+\tskip = node->type != NT_MACRO;\n+    }\n \n-/* #ifndef is a tad more complex, because we need to check for a\n-   no-reinclusion wrapper.  */\n+  push_conditional (pfile, skip, T_IFDEF, 0);\n+}\n \n static void\n do_ifndef (pfile)\n      cpp_reader *pfile;\n {\n-  int start_of_file = 0;\n+  int skip = 1;\n   const cpp_hashnode *node = 0;\n \n   if (! pfile->skipping)\n     {\n-      start_of_file = (pfile->token_list.flags & BEG_OF_FILE);\n-      node = parse_ifdef (pfile, dtable[T_IFNDEF].name);\n+      node = lex_macro_node (pfile);\n+      if (node)\n+\tskip = node->type == NT_MACRO;\n     }\n \n-  push_conditional (pfile, node && node->type != T_VOID,\n-\t\t    T_IFNDEF, start_of_file ? node : 0);\n+  push_conditional (pfile, skip, T_IFNDEF, node);\n }\n \n-/* #if is straightforward; just call _cpp_parse_expr, then conditional_skip.\n-   Also, check for a reinclude preventer of the form #if !defined (MACRO).  */\n+/* #if cooperates with parse_defined to handle multiple-include\n+   optimisations.  If macro expansions or identifiers appear in the\n+   expression, we cannot treat it as a controlling conditional, since\n+   their values could change in the future.  */\n \n static void\n do_if (pfile)\n      cpp_reader *pfile;\n {\n+  int skip = 1;\n   const cpp_hashnode *cmacro = 0;\n-  int value = 0;\n \n-  if (! pfile->skipping)\n+  if (!pfile->skipping)\n     {\n-      if (pfile->token_list.flags & BEG_OF_FILE)\n-\tcmacro = detect_if_not_defined (pfile);\n-      value = _cpp_parse_expr (pfile);\n+      /* Controlling macro of #if ! defined ()  */\n+      pfile->mi_ind_cmacro = 0;\n+      skip = _cpp_parse_expr (pfile) == 0;\n+      cmacro = pfile->mi_ind_cmacro;\n     }\n-  push_conditional (pfile, value == 0, T_IF, cmacro);\n+\n+  push_conditional (pfile, skip, T_IF, cmacro);\n }\n \n /* #else flips pfile->skipping and continues without changing\n@@ -1048,37 +1144,36 @@ do_else (pfile)\n      cpp_reader *pfile;\n {\n   struct if_stack *ifs = CPP_BUFFER (pfile)->if_stack;\n-  validate_else (pfile, dtable[T_ELSE].name);\n \n   if (ifs == NULL)\n+    cpp_error (pfile, \"#else without #if\");\n+  else\n     {\n-      cpp_error (pfile, \"#else without #if\");\n-      return;\n-    }\n-  if (ifs->type == T_ELSE)\n-    {\n-      cpp_error (pfile, \"#else after #else\");\n-      cpp_error_with_line (pfile, ifs->lineno, ifs->colno,\n-\t\t\t   \"the conditional began here\");\n-    }\n+      if (ifs->type == T_ELSE)\n+\t{\n+\t  cpp_error (pfile, \"#else after #else\");\n+\t  cpp_error_with_line (pfile, ifs->pos.line, ifs->pos.col,\n+\t\t\t       \"the conditional began here\");\n+\t}\n \n-  /* #ifndef can't have its special treatment for containing the whole file\n-     if it has a #else clause.  */\n-  ifs->cmacro = 0;\n-  ifs->type = T_ELSE;\n-  if (! ifs->was_skipping)\n-    {\n-      /* If pfile->skipping is 2, one of the blocks in an #if/#elif/... chain\n-\t succeeded, so we mustn't do the else block.  */\n-      if (pfile->skipping < 2)\n-\tpfile->skipping = ! pfile->skipping;\n+      /* Invalidate any controlling macro.  */\n+      ifs->mi_cmacro = 0;\n+\n+      ifs->type = T_ELSE;\n+      if (! ifs->was_skipping)\n+\t{\n+\t  /* If pfile->skipping is 2, one of the blocks in an #if\n+\t     #elif ... chain succeeded, so we skip the else block.  */\n+\t  if (pfile->skipping < 2)\n+\t    pfile->skipping = ! pfile->skipping;\n+\t}\n     }\n+\n+  check_eol (pfile);\n }\n \n-/*\n- * handle a #elif directive by not changing if_stack either.\n- * see the comment above do_else.\n- */\n+/* handle a #elif directive by not changing if_stack either.  see the\n+   comment above do_else.  */\n \n static void\n do_elif (pfile)\n@@ -1091,13 +1186,17 @@ do_elif (pfile)\n       cpp_error (pfile, \"#elif without #if\");\n       return;\n     }\n+\n   if (ifs->type == T_ELSE)\n     {\n       cpp_error (pfile, \"#elif after #else\");\n-      cpp_error_with_line (pfile, ifs->lineno, ifs->colno,\n+      cpp_error_with_line (pfile, ifs->pos.line, ifs->pos.col,\n \t\t\t   \"the conditional began here\");\n     }\n \n+  /* Invalidate any controlling macro.  */\n+  ifs->mi_cmacro = 0;\n+\n   ifs->type = T_ELIF;\n   if (ifs->was_skipping)\n     return;  /* Don't evaluate a nested #if */\n@@ -1119,19 +1218,24 @@ do_endif (pfile)\n {\n   struct if_stack *ifs = CPP_BUFFER (pfile)->if_stack;\n \n-  validate_else (pfile, dtable[T_ENDIF].name);\n-\n   if (ifs == NULL)\n     cpp_error (pfile, \"#endif without #if\");\n   else\n     {\n+      /* If potential control macro, we go back outside again.  */\n+      if (ifs->next == 0 && ifs->mi_cmacro)\n+\t{\n+\t  pfile->mi_state = MI_OUTSIDE;\n+\t  pfile->mi_cmacro = ifs->mi_cmacro;\n+\t}\n+\n       CPP_BUFFER (pfile)->if_stack = ifs->next;\n       pfile->skipping = ifs->was_skipping;\n-      pfile->potential_control_macro = ifs->cmacro;\n       obstack_free (pfile->buffer_ob, ifs);\n     }\n-}\n \n+  check_eol (pfile);\n+}\n \n /* Push an if_stack entry and set pfile->skipping accordingly.\n    If this is a #ifndef starting at the beginning of a file,\n@@ -1147,30 +1251,21 @@ push_conditional (pfile, skip, type, cmacro)\n   struct if_stack *ifs;\n \n   ifs = xobnew (pfile->buffer_ob, struct if_stack);\n-  ifs->lineno = _cpp_get_line (pfile, &ifs->colno);\n+  ifs->pos = pfile->directive_pos;\n   ifs->next = CPP_BUFFER (pfile)->if_stack;\n-  ifs->cmacro = cmacro;\n   ifs->was_skipping = pfile->skipping;\n   ifs->type = type;\n+  if (pfile->mi_state == MI_OUTSIDE && pfile->mi_cmacro == 0)\n+    ifs->mi_cmacro = cmacro;\n+  else\n+    ifs->mi_cmacro = 0;\n \n   if (!pfile->skipping)\n     pfile->skipping = skip;\n \n   CPP_BUFFER (pfile)->if_stack = ifs;\n }\n \n-/* Issue -pedantic warning for text which is not a comment following\n-   an #else or #endif.  */\n-\n-static void\n-validate_else (pfile, directive)\n-     cpp_reader *pfile;\n-     const U_CHAR *directive;\n-{\n-  if (CPP_PEDANTIC (pfile) && _cpp_get_token (pfile)->type != CPP_EOF)\n-    cpp_pedwarn (pfile, \"ISO C forbids text after #%s\", directive);\n-}\n-\n /* Called when we reach the end of a file.  Walk back up the\n    conditional stack till we reach its level at entry to this file,\n    issuing error messages.  Then force skipping off.  */\n@@ -1179,209 +1274,246 @@ unwind_if_stack (pfile, pbuf)\n      cpp_reader *pfile;\n      cpp_buffer *pbuf;\n {\n-  struct if_stack *ifs, *nifs;\n+  struct if_stack *ifs;\n+\n+  /* No need to free stack - they'll all go away with the buffer.  */\n+  for (ifs = pbuf->if_stack; ifs; ifs = ifs->next)\n+    cpp_error_with_line (pfile, ifs->pos.line, ifs->pos.col,\n+\t\t\t \"unterminated #%s\", dtable[ifs->type].name);\n \n-  for (ifs = pbuf->if_stack; ifs; ifs = nifs)\n-    {\n-      cpp_error_with_line (pfile, ifs->lineno, ifs->colno, \"unterminated #%s\",\n-\t\t\t   dtable[ifs->type].name);\n-      nifs = ifs->next;\n-      /* No need to free - they'll all go away with the buffer.  */\n-    }\n   pfile->skipping = 0;\n }\n \n-/* Parses an assertion, returning a pointer to the hash node of the\n-   predicate, or 0 on error.  If an answer was supplied, it is\n-   allocated and placed in ANSWERP, otherwise it is set to 0.  We use\n-   _cpp_get_raw_token, since we cannot assume tokens are consecutive\n-   in a #if statement (we may be in a macro), and we don't want to\n-   macro expand.  */\n-cpp_hashnode *\n-_cpp_parse_assertion (pfile, answerp)\n+/* Read the tokens of the answer into the macro pool.  Only commit the\n+   memory if we intend it as permanent storage, i.e. the #assert case.\n+   Returns 0 on success.  */\n+\n+static int\n+parse_answer (pfile, answerp, type)\n      cpp_reader *pfile;\n      struct answer **answerp;\n+     int type;\n {\n-  struct answer *answer = 0;\n-  cpp_toklist *list;\n-  U_CHAR *sym;\n-  const cpp_token *token, *predicate;\n-  const struct directive *d = pfile->token_list.directive;\n-  unsigned int len = 0;\n-\n-  predicate = _cpp_get_raw_token (pfile);\n-  if (predicate->type == CPP_EOF)\n+  cpp_token paren, *token;\n+  struct answer *answer;\n+\n+  if (POOL_FRONT (&pfile->macro_pool) + sizeof (struct answer) >\n+      POOL_LIMIT (&pfile->macro_pool))\n+    _cpp_next_chunk (&pfile->macro_pool, sizeof (struct answer), 0);\n+  answer = (struct answer *) POOL_FRONT (&pfile->macro_pool);\n+  answer->count = 0;\n+\n+  /* In a conditional, it is legal to not have an open paren.  We\n+     should save the following token in this case.  */\n+  if (type == T_IF)\n+    cpp_start_lookahead (pfile);\n+  cpp_get_token (pfile, &paren);\n+  if (type == T_IF)\n+    cpp_stop_lookahead (pfile, paren.type == CPP_OPEN_PAREN);\n+\n+  /* If not a paren, see if we're OK.  */\n+  if (paren.type != CPP_OPEN_PAREN)\n     {\n-      cpp_error (pfile, \"assertion without predicate\");\n-      return 0;\n-    }\n-  else if (predicate->type != CPP_NAME)\n-    {\n-      cpp_error (pfile, \"predicate must be an identifier\");\n-      return 0;\n-    }\n+      /* In a conditional no answer is a test for any answer.  It\n+         could be followed by any token.  */\n+      if (type == T_IF)\n+\treturn 0;\n+\n+      /* #unassert with no answer is valid - it removes all answers.  */\n+      if (type == T_UNASSERT && paren.type == CPP_EOF)\n+\treturn 0;\n \n-  token = _cpp_get_raw_token (pfile);\n-  if (token->type != CPP_OPEN_PAREN)\n-    {\n-      /* #unassert and #if are OK without predicate.  */\n-      if (d == &dtable[T_UNASSERT])\n-\t{\n-\t  if (token->type == CPP_EOF)\n-\t    goto lookup_node;\n-\t}\n-      else if (d != &dtable[T_ASSERT])\n-\t{\n-\t  _cpp_push_token (pfile, token);\n-\t  goto lookup_node;\n-\t}\n       cpp_error (pfile, \"missing '(' after predicate\");\n-      return 0;\n+      return 1;\n     }\n \n-  /* Allocate a struct answer, and copy the answer to it.  */\n-  answer = (struct answer *) xmalloc (sizeof (struct answer));\n-  list = &answer->list;\n-  _cpp_init_toklist (list, 1);\t/* Empty.  */\n-\n   for (;;)\n     {\n-      cpp_token *dest;\n-\n-      token = _cpp_get_raw_token (pfile);\n-\n-      if (token->type == CPP_EOF)\n+      token = &answer->first[answer->count];\n+      /* Check we have room for the token.  */\n+      if ((unsigned char *) (token + 1) >= POOL_LIMIT (&pfile->macro_pool))\n \t{\n-\t  cpp_error (pfile, \"missing ')' to complete answer\");\n-\t  goto error;\n+\t  _cpp_next_chunk (&pfile->macro_pool, sizeof (cpp_token),\n+\t\t\t   (unsigned char **) &answer);\n+\t  token = &answer->first[answer->count];\n \t}\n+\n+      _cpp_get_token (pfile, token);\n       if (token->type == CPP_CLOSE_PAREN)\n \tbreak;\n \n-      /* Copy the token.  */\n-      _cpp_expand_token_space (list, 1);\n-      dest = &list->tokens[list->tokens_used++];\n-      *dest = *token;\n-\n-      if (TOKEN_SPELL (token) == SPELL_STRING)\n+      if (token->type == CPP_EOF)\n \t{\n-\t  _cpp_expand_name_space (list, token->val.str.len);\n-\t  dest->val.str.text = list->namebuf + list->name_used;\n-\t  memcpy (list->namebuf + list->name_used,\n-\t\t  token->val.str.text, token->val.str.len);\n-\t  list->name_used += token->val.str.len;\n+\t  cpp_error (pfile, \"missing ')' to complete answer\");\n+\t  return 1;\n \t}\n+      answer->count++;\n     }\n \n-  if (list->tokens_used == 0)\n+  if (answer->count == 0)\n     {\n       cpp_error (pfile, \"predicate's answer is empty\");\n-      goto error;\n+      return 1;\n     }\n \n   /* Drop whitespace at start.  */\n-  list->tokens[0].flags &= ~PREV_WHITE;\n+  answer->first->flags &= ~PREV_WHITE;\n+  *answerp = answer;\n \n-  if ((d == &dtable[T_ASSERT] || d == &dtable[T_UNASSERT])\n-      && token[1].type != CPP_EOF)\n-    {\n-      cpp_error (pfile, \"junk at end of assertion\");\n-      goto error;\n-    }\n+  if (type == T_ASSERT || type == T_UNASSERT)\n+    check_eol (pfile);\n+  return 0;\n+}\n \n- lookup_node:\n-  *answerp = answer;\n-  len = predicate->val.node->length;\n-  sym = alloca (len + 1);\n+/* Parses an assertion, returning a pointer to the hash node of the\n+   predicate, or 0 on error.  If an answer was supplied, it is placed\n+   in ANSWERP, otherwise it is set to 0.  We use _cpp_get_raw_token,\n+   since we cannot assume tokens are consecutive in a #if statement\n+   (we may be in a macro), and we don't want to macro expand.  */\n+static cpp_hashnode *\n+parse_assertion (pfile, answerp, type)\n+     cpp_reader *pfile;\n+     struct answer **answerp;\n+     int type;\n+{\n+  cpp_hashnode *result = 0;\n+  cpp_token predicate;\n+\n+  /* We don't expand predicates or answers.  */\n+  pfile->state.prevent_expansion++;\n+\n+  /* Use the permanent pool for storage (for the answers).  */\n+  pfile->string_pool = &pfile->ident_pool;\n+\n+  *answerp = 0;\n+  _cpp_get_token (pfile, &predicate);\n+  if (predicate.type == CPP_EOF)\n+    cpp_error (pfile, \"assertion without predicate\");\n+  else if (predicate.type != CPP_NAME)\n+    cpp_error (pfile, \"predicate must be an identifier\");\n+  else if (parse_answer (pfile, answerp, type) == 0)\n+    {\n+      unsigned int len = predicate.val.node->length;\n+      unsigned char *sym = alloca (len + 1);\n \n-  /* Prefix '#' to get it out of macro namespace.  */\n-  sym[0] = '#';\n-  memcpy (sym + 1, predicate->val.node->name, len);\n-  return cpp_lookup (pfile, sym, len + 1);\n+      /* Prefix '#' to get it out of macro namespace.  */\n+      sym[0] = '#';\n+      memcpy (sym + 1, predicate.val.node->name, len);\n+      result = cpp_lookup (pfile, sym, len + 1);\n+    }\n \n- error:\n-  FREE_ANSWER (answer);\n-  return 0;\n+  pfile->string_pool = &pfile->temp_string_pool;\n+  pfile->state.prevent_expansion--;\n+  return result;\n }\n \n /* Returns a pointer to the pointer to the answer in the answer chain,\n    or a pointer to NULL if the answer is not in the chain.  */\n-struct answer **\n-_cpp_find_answer (node, candidate)\n+static struct answer **\n+find_answer (node, candidate)\n      cpp_hashnode *node;\n-     const cpp_toklist *candidate;\n+     const struct answer *candidate;\n {\n+  unsigned int i;\n   struct answer **result;\n \n   for (result = &node->value.answers; *result; result = &(*result)->next)\n-    if (_cpp_equiv_toklists (&(*result)->list, candidate))\n-      break;\n+    {\n+      struct answer *answer = *result;\n+\n+      if (answer->count == candidate->count)\n+\t{\n+\t  for (i = 0; i < answer->count; i++)\n+\t    if (! _cpp_equiv_tokens (&answer->first[i], &candidate->first[i]))\n+\t      break;\n+\n+\t  if (i == answer->count)\n+\t    break;\n+\t}\n+    }\n \n   return result;\n }\n \n+/* Test an assertion within a preprocessor conditional.  Returns\n+   non-zero on failure, zero on success.  On success, the result of\n+   the test is written into VALUE.  */\n+int\n+_cpp_test_assertion (pfile, value)\n+     cpp_reader *pfile;\n+     int *value;\n+{\n+  struct answer *answer;\n+  cpp_hashnode *node;\n+\n+  node = parse_assertion (pfile, &answer, T_IF);\n+  if (node)\n+    *value = (node->type == NT_ASSERTION &&\n+\t      (answer == 0 || *find_answer (node, answer) != 0));\n+\n+  /* We don't commit the memory for the answer - it's temporary only.  */\n+  return node == 0;\n+}\n+\n static void\n do_assert (pfile)\n      cpp_reader *pfile;\n {\n   struct answer *new_answer;\n   cpp_hashnode *node;\n   \n-  node = _cpp_parse_assertion (pfile, &new_answer);\n+  node = parse_assertion (pfile, &new_answer, T_ASSERT);\n   if (node)\n     {\n+      /* Place the new answer in the answer list.  First check there\n+         is not a duplicate.  */\n       new_answer->next = 0;\n-      new_answer->list.file = pfile->token_list.file;\n-\n-      if (node->type == T_ASSERTION)\n+      if (node->type == NT_ASSERTION)\n \t{\n-\t  if (*_cpp_find_answer (node, &new_answer->list))\n-\t    goto err;\n+\t  if (*find_answer (node, new_answer))\n+\t    {\n+\t      cpp_warning (pfile, \"\\\"%s\\\" re-asserted\", node->name + 1);\n+\t      return;\n+\t    }\n \t  new_answer->next = node->value.answers;\n \t}\n-      node->type = T_ASSERTION;\n+      node->type = NT_ASSERTION;\n       node->value.answers = new_answer;\n+      POOL_COMMIT (&pfile->macro_pool, (sizeof (struct answer)\n+\t\t\t\t\t+ (new_answer->count - 1)\n+\t\t\t\t\t* sizeof (cpp_token)));\n     }\n-  return;\n-\n- err:\n-  cpp_warning (pfile, \"\\\"%s\\\" re-asserted\", node->name + 1);\n-  FREE_ANSWER (new_answer);\n }\n \n static void\n do_unassert (pfile)\n      cpp_reader *pfile;\n {\n   cpp_hashnode *node;\n-  struct answer *answer, *temp;\n+  struct answer *answer;\n   \n-  node = _cpp_parse_assertion (pfile, &answer);\n-  if (node)\n+  node = parse_assertion (pfile, &answer, T_UNASSERT);\n+  /* It isn't an error to #unassert something that isn't asserted.  */\n+  if (node && node->type == NT_ASSERTION)\n     {\n-      /* It isn't an error to #unassert something that isn't asserted.  */\n-      if (node->type == T_ASSERTION)\n+      if (answer)\n \t{\n-\t  if (answer)\n-\t    {\n-\t      struct answer **p = _cpp_find_answer (node, &answer->list);\n+\t  struct answer **p = find_answer (node, answer), *temp;\n \n-\t      temp = *p;\n-\t      if (temp)\n-\t\t{\n-\t\t  *p = temp->next;\n-\t\t  FREE_ANSWER (temp);\n-\t\t}\n-\t      if (node->value.answers == 0)\n-\t\tnode->type = T_VOID;\n-\t    }\n-\t  else\n-\t    _cpp_free_definition (node);\n-\t}\n+\t  /* Remove the answer from the list.  */\n+\t  temp = *p;\n+\t  if (temp)\n+\t    *p = temp->next;\n \n-      if (answer)\n-\tFREE_ANSWER (answer);\n+\t  /* Did we free the last answer?  */\n+\t  if (node->value.answers == 0)\n+\t    node->type = NT_VOID;\n+\t}\n+      else\n+\t_cpp_free_definition (node);\n     }\n+\n+  /* We don't commit the memory for the answer - it's temporary only.  */\n }\n \n /* These are for -D, -U, -A.  */\n@@ -1421,7 +1553,7 @@ cpp_define (pfile, str)\n       strcpy (&buf[count-4], \" 1\\n\");\n     }\n \n-  _cpp_run_directive (pfile, &dtable[T_DEFINE], buf, count - 1, 0);\n+  run_directive (pfile, T_DEFINE, buf, count - 1, 0);\n }\n \n /* Slight variant of the above for use by initialize_builtins, which (a)\n@@ -1432,9 +1564,7 @@ _cpp_define_builtin (pfile, str)\n      cpp_reader *pfile;\n      const char *str;\n {\n-  _cpp_run_directive (pfile, &dtable[T_DEFINE],\n-\t\t      str, strlen (str),\n-\t\t      _(\"<builtin>\"));\n+  run_directive (pfile, T_DEFINE, str, strlen (str), _(\"<builtin>\"));\n }\n \n /* Process MACRO as if it appeared as the body of an #undef.  */\n@@ -1443,7 +1573,7 @@ cpp_undef (pfile, macro)\n      cpp_reader *pfile;\n      const char *macro;\n {\n-  _cpp_run_directive (pfile, &dtable[T_UNDEF], macro, strlen (macro), 0);\n+  run_directive (pfile, T_UNDEF, macro, strlen (macro), 0);\n }\n \n /* Process the string STR as if it appeared as the body of a #assert. */\n@@ -1452,7 +1582,7 @@ cpp_assert (pfile, str)\n      cpp_reader *pfile;\n      const char *str;\n {\n-  _cpp_run_directive (pfile, &dtable[T_ASSERT], str, strlen (str), 0);\n+  run_directive (pfile, T_ASSERT, str, strlen (str), 0);\n }\n \n /* Process STR as if it appeared as the body of an #unassert. */\n@@ -1461,7 +1591,7 @@ cpp_unassert (pfile, str)\n      cpp_reader *pfile;\n      const char *str;\n {\n-  _cpp_run_directive (pfile, &dtable[T_UNASSERT], str, strlen (str), 0);\n+  run_directive (pfile, T_UNASSERT, str, strlen (str), 0);\n }  \n \n /* Determine whether the identifier ID, of length LEN, is a defined macro.  */\n@@ -1472,18 +1602,15 @@ cpp_defined (pfile, id, len)\n      int len;\n {\n   cpp_hashnode *hp = cpp_lookup (pfile, id, len);\n-  if (hp->type == T_POISON)\n-    {\n-      cpp_error (pfile, \"attempt to use poisoned \\\"%s\\\"\", hp->name);\n-      return 0;\n-    }\n-  return (hp->type != T_VOID);\n+\n+  /* If it's of type NT_MACRO, it cannot be poisoned.  */\n+  return hp->type == NT_MACRO;\n }\n \n-/* Allocate a new cpp_buffer for PFILE, and push it on the input buffer stack.\n-   If BUFFER != NULL, then use the LENGTH characters in BUFFER\n-   as the new input buffer.\n-   Return the new buffer, or NULL on failure.  */\n+/* Allocate a new cpp_buffer for PFILE, and push it on the input\n+   buffer stack.  If BUFFER != NULL, then use the LENGTH characters in\n+   BUFFER as the new input buffer.  Return the new buffer, or NULL on\n+   failure.  */\n \n cpp_buffer *\n cpp_push_buffer (pfile, buffer, length)\n@@ -1498,22 +1625,26 @@ cpp_push_buffer (pfile, buffer, length)\n       cpp_fatal (pfile, \"#include nested too deeply\");\n       return NULL;\n     }\n-  if (pfile->cur_context > 0)\n+\n+  if (pfile->context->prev)\n     {\n       cpp_ice (pfile, \"buffer pushed with contexts stacked\");\n-      _cpp_skip_rest_of_line (pfile);\n+      skip_rest_of_line (pfile);\n     }\n \n   new = xobnew (pfile->buffer_ob, cpp_buffer);\n+  /* Clears, amongst other things, if_stack and mi_cmacro.  */\n   memset (new, 0, sizeof (cpp_buffer));\n \n+  pfile->lexer_pos.output_line = 1;\n   new->line_base = new->buf = new->cur = buffer;\n   new->rlimit = buffer + length;\n   new->prev = buf;\n   new->pfile = pfile;\n   /* No read ahead or extra char initially.  */\n   new->read_ahead = EOF;\n   new->extra_char = EOF;\n+  pfile->state.skip_newlines = 1;\n \n   CPP_BUFFER (pfile) = new;\n   return new;\n@@ -1535,33 +1666,30 @@ cpp_pop_buffer (pfile)\n   obstack_free (pfile->buffer_ob, buf);\n   pfile->buffer_stack_depth--;\n \n-  if (wfb && pfile->cb.leave_file && CPP_BUFFER (pfile))\n+  if (CPP_BUFFER (pfile) && wfb && pfile->cb.leave_file)\n     (*pfile->cb.leave_file) (pfile);\n   \n   return CPP_BUFFER (pfile);\n }\n \n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n-#define DSC(x) U x, sizeof x - 1\n void\n _cpp_init_stacks (pfile)\n      cpp_reader *pfile;\n {\n   int i;\n-  struct spec_nodes *s;\n+  cpp_hashnode *node;\n \n   pfile->buffer_ob = xnew (struct obstack);\n   obstack_init (pfile->buffer_ob);\n \n-  /* Perhaps not the ideal place to put this.  */\n-  pfile->spec_nodes = s = xnew (struct spec_nodes);\n-  s->n_L                = cpp_lookup (pfile, DSC(\"L\"));\n-  s->n__STRICT_ANSI__   = cpp_lookup (pfile, DSC(\"__STRICT_ANSI__\"));\n-  s->n__CHAR_UNSIGNED__ = cpp_lookup (pfile, DSC(\"__CHAR_UNSIGNED__\"));\n-  s->n__VA_ARGS__       = cpp_lookup (pfile, DSC(\"__VA_ARGS__\"));\n-  for (i = 0; i < N_DIRECTIVES; i++)\n-    s->dirs[i] = cpp_lookup (pfile, dtable[i].name, dtable[i].length);\n+  /* Register the directives.  */\n+  for (i = 1; i < N_DIRECTIVES; i++)\n+    {\n+      node = cpp_lookup (pfile, dtable[i - 1].name, dtable[i - 1].length);\n+      node->directive_index = i;\n+    }\n }\n \n void"}, {"sha": "eecd867be02a1ca34a434bafe94f8237982a344c", "filename": "gcc/cpplib.h", "status": "modified", "additions": 270, "deletions": 171, "changes": 441, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c80368d9a16c073f2b930bef4232661971765f/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c80368d9a16c073f2b930bef4232661971765f/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=93c80368d9a16c073f2b930bef4232661971765f", "patch": "@@ -34,11 +34,21 @@ typedef struct cpp_reader cpp_reader;\n #endif\n typedef struct cpp_buffer cpp_buffer;\n typedef struct cpp_options cpp_options;\n-typedef struct cpp_printer cpp_printer;\n typedef struct cpp_token cpp_token;\n-typedef struct cpp_toklist cpp_toklist;\n typedef struct cpp_string cpp_string;\n typedef struct cpp_hashnode cpp_hashnode;\n+typedef struct cpp_pool cpp_pool;\n+typedef struct cpp_macro cpp_macro;\n+typedef struct cpp_lexer_pos cpp_lexer_pos;\n+typedef struct cpp_lookahead cpp_lookahead;\n+\n+struct directive;\t\t/* These are deliberately incomplete.  */\n+struct answer;\n+struct cpp_macro;\n+struct macro_args;\n+struct cpp_chunk;\n+struct file_name_map_list;\n+struct htab;\n \n /* The first two groups, apart from '=', can appear in preprocessor\n    expressions.  This allows a lookup table to be implemented in\n@@ -114,7 +124,6 @@ typedef struct cpp_hashnode cpp_hashnode;\n   OP(CPP_SCOPE,\t\t\"::\")\t\t\t\\\n   OP(CPP_DEREF_STAR,\t\"->*\")\t\t\t\\\n   OP(CPP_DOT_STAR,\t\".*\")\t\t\t\\\n-  OP(CPP_DEFINED,\t\"defined\") /* #if */\t\\\n \\\n   TK(CPP_NAME,\t\tSPELL_IDENT)\t/* word */\t\t\t\\\n   TK(CPP_INT,\t\tSPELL_STRING)\t/* 23 */\t\t\t\\\n@@ -131,9 +140,10 @@ typedef struct cpp_hashnode cpp_hashnode;\n   TK(CPP_HEADER_NAME,\tSPELL_STRING)\t/* <stdio.h> in #include */\t\\\n \\\n   TK(CPP_COMMENT,\tSPELL_STRING)\t/* Only if output comments.  */ \\\n+  TK(CPP_DHASH,\t\tSPELL_NONE)\t/* The # of a directive.  */\t\\\n   TK(CPP_MACRO_ARG,\tSPELL_NONE)\t/* Macro argument.  */\t\t\\\n   TK(CPP_PLACEMARKER,\tSPELL_NONE)\t/* Placemarker token.  */\t\\\n-  TK(CPP_EOF,\t\tSPELL_NONE)\t/* End of file.\t */\n+  OP(CPP_EOF,\t\t\"EOL\")\t\t/* End of line or file.  */\n \n #define OP(e, s) e,\n #define TK(e, s) e,\n@@ -145,6 +155,10 @@ enum cpp_ttype\n #undef OP\n #undef TK\n \n+/* Multiple-include optimisation.  */\n+enum mi_state {MI_FAILED = 0, MI_OUTSIDE};\n+enum mi_ind {MI_IND_NONE = 0, MI_IND_NOT};\n+\n /* Payload of a NUMBER, FLOAT, STRING, or COMMENT token.  */\n struct cpp_string\n {\n@@ -154,19 +168,17 @@ struct cpp_string\n \n /* Flags for the cpp_token structure.  */\n #define PREV_WHITE\t(1 << 0) /* If whitespace before this token.  */\n-#define BOL\t\t(1 << 1) /* Beginning of logical line.  */\n-#define DIGRAPH\t\t(1 << 2) /* If it was a digraph.  */\n-#define STRINGIFY_ARG\t(1 << 3) /* If macro argument to be stringified.  */\n-#define PASTE_LEFT\t(1 << 4) /* If on LHS of a ## operator.  */\n-#define PASTED\t\t(1 << 5) /* The result of a ## operator.  */\n-#define NAMED_OP\t(1 << 6) /* C++ named operators, also \"defined\".  */\n+#define DIGRAPH\t\t(1 << 1) /* If it was a digraph.  */\n+#define STRINGIFY_ARG\t(1 << 2) /* If macro argument to be stringified.  */\n+#define PASTE_LEFT\t(1 << 3) /* If on LHS of a ## operator.  */\n+#define NAMED_OP\t(1 << 4) /* C++ named operators, also \"defined\".  */\n+#define NO_EXPAND\t(1 << 5) /* Do not macro-expand this token.  */\n+#define VARARGS_FIRST   STRINGIFY_ARG /* First token of varargs expansion.  */\n \n /* A preprocessing token.  This has been carefully packed and should\n-   occupy 16 bytes on 32-bit hosts and 24 bytes on 64-bit hosts.  */\n+   occupy 12 bytes on 32-bit hosts and 16 bytes on 64-bit hosts.  */\n struct cpp_token\n {\n-  unsigned int line;\t\t/* starting line number of this token */\n-  unsigned short col;\t\t/* starting column of this token */\n   ENUM_BITFIELD(cpp_ttype) type : CHAR_BIT;  /* token type */\n   unsigned char flags;\t\t/* flags - see above */\n \n@@ -180,37 +192,58 @@ struct cpp_token\n   } val;\n };\n \n-/* cpp_toklist flags.  */\n-#define VAR_ARGS\t(1 << 0)\n-#define BEG_OF_FILE\t(1 << 1)\n-\n-struct directive;\t\t/* These are deliberately incomplete.  */\n-struct answer;\n-struct macro_args;\n-struct cpp_context;\n+/* The position of a token in the current file.  */\n+struct cpp_lexer_pos\n+{\n+  unsigned int line;\n+  unsigned int output_line;\n+  unsigned short col;\n+};\n \n-struct cpp_toklist\n+typedef struct cpp_token_with_pos cpp_token_with_pos;\n+struct cpp_token_with_pos\n {\n-  cpp_token *tokens;\t\t/* actual tokens as an array */\n-  unsigned int tokens_used;\t/* tokens used */\n-  unsigned int tokens_cap;\t/* tokens allocated */\n+  cpp_token token;\n+  cpp_lexer_pos pos;\n+};\n \n-  unsigned char *namebuf;\t/* names buffer */\n-  unsigned int name_used;\t/* _bytes_ used */\n-  unsigned int name_cap;\t/* _bytes_ allocated */\n+/* Token lookahead.  */\n+struct cpp_lookahead\n+{\n+  struct cpp_lookahead *next;\n+  cpp_token_with_pos *tokens;\n+  cpp_lexer_pos pos;\n+  unsigned int cur, count, cap;\n+};\n \n-  /* If the list represents a directive, this points to it.  */\n-  const struct directive *directive;\n+/* Memory pools.  */\n+struct cpp_pool\n+{\n+  struct cpp_chunk *cur, *locked;\n+  unsigned char *pos;\t\t/* Current position.  */\n+  unsigned int align;\n+  unsigned int locks;\n+};\n \n-  const char *file;\t\t/* in file name */\n-  unsigned int line;\t\t/* starting line number */\n+typedef struct toklist toklist;\n+struct toklist\n+{\n+  cpp_token *first;\n+  cpp_token *limit;\n+};\n \n-  unsigned short params_len;\t/* length of macro parameter names.  */\n+typedef struct cpp_context cpp_context;\n+struct cpp_context\n+{\n+  /* Doubly-linked list.  */\n+  cpp_context *next, *prev;\n \n-  short int paramc;\t\t/* no. of macro params (-1 = obj-like).  */\n+  /* Contexts other than the base context are contiguous tokens.\n+     e.g. macro expansions, expanded argument tokens.  */\n+  struct toklist list;\n \n-  /* Per-list flags, see above */\n-  unsigned short flags;\n+  /* For a macro context, these are the macro and its arguments.  */\n+  cpp_macro *macro;\n };\n \n /* A standalone character.  We may want to make it unsigned for the\n@@ -257,9 +290,6 @@ struct cpp_buffer\n   char warned_cplusplus_comments;\n };\n \n-struct file_name_map_list;\n-struct htab;\n-\n /* Maximum nesting of cpp_buffers.  We use a static limit, partly for\n    efficiency, and partly to limit runaway recursion.  */\n #define CPP_STACK_MAX 200\n@@ -448,35 +478,45 @@ struct lexer_state\n   /* Nonzero if first token on line is CPP_HASH.  */\n   unsigned char in_directive;\n \n-  /* Nonzero if the directive's # was not in the first column.  Used\n-     by -Wtraditional.  */\n-  unsigned char indented;\n-\n   /* Nonzero if in a directive that takes angle-bracketed headers.  */\n   unsigned char angled_headers;\n \n   /* Nonzero to save comments.  Turned off if discard_comments, and in\n      all directives apart from #define.  */\n   unsigned char save_comments;\n \n-  /* Nonzero to force the lexer to skip newlines.  */\n+  /* If nonzero the lexer skips newlines.  Internal to the lexer.  */\n   unsigned char skip_newlines;\n \n-  /* Nonzero if we're in the subroutine lex_line.  */\n-  unsigned char in_lex_line;\n-\n   /* Nonzero if we're mid-comment.  */\n   unsigned char lexing_comment;\n \n-  /* Tells parse_number we saw a leading period.  */\n-  unsigned char seen_dot;\n+  /* Nonzero if lexing __VA_ARGS__ is valid.  */\n+  unsigned char va_args_ok;\n+\n+  /* Nonzero if lexing poisoned identifiers is valid.  */\n+  unsigned char poisoned_ok;\n+\n+  /* Nonzero to prevent macro expansion.  */\n+  unsigned char prevent_expansion;  \n+\n+  /* Nonzero when parsing arguments to a function-like macro.  */\n+  unsigned char parsing_args;\n };\n-#define IN_DIRECTIVE(pfile) (pfile->state.in_directive)\n-#define KNOWN_DIRECTIVE(list) (list->directive != 0)\n \n-/* A cpp_reader encapsulates the \"state\" of a pre-processor run.\n+/* Special nodes - identifiers with predefined significance.  */\n+struct spec_nodes\n+{\n+  cpp_hashnode *n_L;\t\t\t/* L\"str\" */\n+  cpp_hashnode *n_defined;\t\t/* defined operator */\n+  cpp_hashnode *n__STRICT_ANSI__;\t/* STDC_0_IN_SYSTEM_HEADERS */\n+  cpp_hashnode *n__CHAR_UNSIGNED__;\t/* plain char is unsigned */\n+  cpp_hashnode *n__VA_ARGS__;\t\t/* C99 vararg macros */\n+};\n+\n+/* a cpp_reader encapsulates the \"state\" of a pre-processor run.\n    Applying cpp_get_token repeatedly yields a stream of pre-processor\n-   tokens.  Usually, there is only one cpp_reader object active. */\n+   tokens.  Usually, there is only one cpp_reader object active.  */\n \n struct cpp_reader\n {\n@@ -486,70 +526,76 @@ struct cpp_reader\n   /* Lexer state.  */\n   struct lexer_state state;\n \n-  /* Error counter for exit code */\n+  /* The position of the last lexed token, last lexed directive, and\n+     last macro invocation.  */\n+  cpp_lexer_pos lexer_pos;\n+  cpp_lexer_pos macro_pos;\n+  cpp_lexer_pos directive_pos;\n+\n+  /* Memory pools.  */\n+  cpp_pool ident_pool;\t\t/* For all identifiers, and permanent\n+\t\t\t\t   numbers and strings.  */\n+  cpp_pool temp_string_pool;\t/* For temporary numbers and strings.   */\n+  cpp_pool macro_pool;\t\t/* For macro definitions.  Permanent.  */\n+  cpp_pool argument_pool;\t/* For macro arguments.  Temporary.   */\n+  cpp_pool* string_pool;\t/* Either temp_string_pool or ident_pool.   */\n+\n+  /* Context stack.  */\n+  struct cpp_context base_context;\n+  struct cpp_context *context;\n+\n+  /* If in_directive, the directive if known.  */\n+  const struct directive *directive;\n+\n+  /* Multiple inlcude optimisation.  */\n+  enum mi_state mi_state;\n+  enum mi_ind mi_if_not_defined;\n+  unsigned int mi_lexed;\n+  const cpp_hashnode *mi_cmacro;\n+  const cpp_hashnode *mi_ind_cmacro;\n+\n+  /* Token lookahead.  */\n+  struct cpp_lookahead *la_read;\t/* Read from this lookahead.  */\n+  struct cpp_lookahead *la_write;\t/* Write to this lookahead.  */\n+  struct cpp_lookahead *la_unused;\t/* Free store.  */\n+\n+  /* Error counter for exit code.  */\n   unsigned int errors;\n \n   /* Line and column where a newline was first seen in a string\n      constant (multi-line strings).  */\n-  unsigned int mls_line;\n-  unsigned int mls_column;\n+  cpp_lexer_pos mlstring_pos;\n+\n+  /* Buffer to hold macro definition string.  */\n+  unsigned char *macro_buffer;\n+  unsigned int macro_buffer_len;\n \n   /* Current depth in #include directives that use <...>.  */\n   unsigned int system_include_depth;\n \n-  /* Current depth of buffer stack. */\n+  /* Current depth of buffer stack.  */\n   unsigned int buffer_stack_depth;\n \n   /* Current depth in #include directives.  */\n   unsigned int include_depth;\n \n-  /* Hash table of macros and assertions.  See cpphash.c */\n+  /* Hash table of macros and assertions.  See cpphash.c.  */\n   struct htab *hashtab;\n \n-  /* Tree of other included files.  See cppfiles.c */\n+  /* Tree of other included files.  See cppfiles.c.  */\n   struct splay_tree_s *all_include_files;\n \n-  /* Chain of `actual directory' file_name_list entries,\n-     for \"\" inclusion. */\n+  /* Chain of `actual directory' file_name_list entries, for \"\"\n+     inclusion.  */\n   struct file_name_list *actual_dirs;\n \n   /* Current maximum length of directory names in the search path\n      for include files.  (Altered as we get more of them.)  */\n   unsigned int max_include_len;\n \n-  /* Potential controlling macro for the current buffer.  This is only\n-     live between the #endif and the end of file, and there can only\n-     be one at a time, so it is per-reader not per-buffer.  */\n-  const cpp_hashnode *potential_control_macro;\n-\n-  /* Token list used to store logical lines with new lexer.  */\n-  cpp_toklist token_list;\n-\n-  /* Temporary token store.  */\n-  cpp_token **temp_tokens;\n-  unsigned int temp_cap;\n-  unsigned int temp_alloced;\n-  unsigned int temp_used;\n-\n   /* Date and time tokens.  Calculated together if either is requested.  */\n-  cpp_token *date;\n-  cpp_token *time;\n-\n-  /* The # of a the current directive. It may not be first in line if\n-     we append, and finding it is tedious.  */\n-  const cpp_token *first_directive_token;\n-\n-  /* Context stack.  Used for macro expansion and for determining\n-     which macros are disabled.  */\n-  unsigned int context_cap;\n-  unsigned int cur_context;\n-  unsigned int no_expand_level;\n-  unsigned int paste_level;\n-  struct cpp_context *contexts;\n-\n-  /* Current arguments when scanning arguments. Used for pointer\n-     fix-up.  */\n-  struct macro_args *args;\n+  cpp_token date;\n+  cpp_token time;\n \n   /* Buffer of -M output.  */\n   struct deps *deps;\n@@ -572,17 +618,21 @@ struct cpp_reader\n     void (*leave_file) PARAMS ((cpp_reader *));\n     void (*rename_file) PARAMS ((cpp_reader *));\n     void (*include) PARAMS ((cpp_reader *, const unsigned char *,\n-\t\t\t     const unsigned char *, unsigned int, int));\n+\t\t\t     const cpp_token *));\n     void (*define) PARAMS ((cpp_reader *, cpp_hashnode *));\n     void (*undef) PARAMS ((cpp_reader *, cpp_hashnode *));\n     void (*poison) PARAMS ((cpp_reader *));\n-    void (*ident) PARAMS ((cpp_reader *, const unsigned char *, unsigned int));\n+    void (*ident) PARAMS ((cpp_reader *, const cpp_string *));\n     void (*def_pragma) PARAMS ((cpp_reader *));\n   } cb;\n \n   /* User visible options.  */\n   struct cpp_options opts;\n \n+  /* Special nodes - identifiers with predefined significance to the\n+     preprocessor.  */\n+  struct spec_nodes spec_nodes;\n+\n   /* Nonzero means we have printed (while error reporting) a list of\n      containing files that matches the current status.  */\n   unsigned char input_stack_listing_current;\n@@ -596,28 +646,6 @@ struct cpp_reader\n \n   /* True if we are skipping a failed conditional group.  */\n   unsigned char skipping;\n-\n-  /* True if we need to save parameter spellings - only if -pedantic,\n-     or we might need to write out definitions.  */\n-  unsigned char save_parameter_spellings;\n-\n-  /* True if output_line_command needs to output a newline.  */\n-  unsigned char need_newline;\n-\n-  /* Special nodes - identifiers with predefined significance to the\n-     preprocessor.  */\n-  struct spec_nodes *spec_nodes;\n-};\n-\n-/* struct cpp_printer encapsulates state used to convert the stream of\n-   tokens coming from cpp_get_token back into a text file.  Not\n-   everyone wants to do that, hence we separate the function.  */\n-\n-struct cpp_printer\n-{\n-  FILE *outf;\t\t\t/* stream to write to */\n-  const char *last_fname;\t/* previous file name */\n-  unsigned int lineno;\t\t/* line currently being written */\n };\n \n #define CPP_FATAL_LIMIT 1000\n@@ -633,28 +661,41 @@ struct cpp_printer\n /* Name under which this program was invoked.  */\n extern const char *progname;\n \n-/* The structure of a node in the hash table.  The hash table\n-   has entries for all tokens defined by #define commands (type T_MACRO),\n-   plus some special tokens like __LINE__ (these each have their own\n-   type, and the appropriate code is run when that type of node is seen.\n-   It does not contain control words like \"#define\", which are recognized\n-   by a separate piece of code. */\n-\n-/* different flavors of hash nodes */\n+/* The structure of a node in the hash table.  The hash table has\n+   entries for all identifiers: either macros defined by #define\n+   commands (type NT_MACRO), assertions created with #assert\n+   (NT_ASSERTION), or neither of the above (NT_VOID).  Builtin macros\n+   like __LINE__ are flagged NODE_BUILTIN.  Poisioned identifiers are\n+   flagged NODE_POISONED.  NODE_OPERATOR (C++ only) indicates an\n+   identifier that behaves like an operator such as \"xor\".\n+   NODE_DIAGNOSTIC is for speed in lex_token: it indicates a\n+   diagnostic may be required for this node.  Currently this only\n+   applies to __VA_ARGS__ and poisoned identifiers.  */\n+\n+/* Hash node flags.  */\n+#define NODE_OPERATOR\t(1 << 0)\t/* C++ named operator.  */\n+#define NODE_POISONED\t(1 << 1)\t/* Poisoned identifier.  */\n+#define NODE_BUILTIN\t(1 << 2)\t/* Builtin macro.  */\n+#define NODE_DIAGNOSTIC (1 << 3)\t/* Possible diagnostic when lexed.  */\n+\n+/* Different flavors of hash node.  */\n enum node_type\n {\n-  T_VOID = 0,\t   /* no definition yet */\n-  T_SPECLINE,\t   /* `__LINE__' */\n-  T_DATE,\t   /* `__DATE__' */\n-  T_FILE,\t   /* `__FILE__' */\n-  T_BASE_FILE,\t   /* `__BASE_FILE__' */\n-  T_INCLUDE_LEVEL, /* `__INCLUDE_LEVEL__' */\n-  T_TIME,\t   /* `__TIME__' */\n-  T_STDC,\t   /* `__STDC__' */\n-  T_OPERATOR,\t   /* operator with a name; val.code is token type */\n-  T_POISON,\t   /* poisoned identifier */\n-  T_MACRO,\t   /* a macro, either object-like or function-like */\n-  T_ASSERTION\t   /* predicate for #assert */\n+  NT_VOID = 0,\t   /* No definition yet.  */\n+  NT_MACRO,\t   /* A macro of some form.  */\n+  NT_ASSERTION\t   /* Predicate for #assert.  */\n+};\n+\n+/* Different flavors of builtin macro.  */\n+enum builtin_type\n+{\n+  BT_SPECLINE = 0,\t\t/* `__LINE__' */\n+  BT_DATE,\t\t\t/* `__DATE__' */\n+  BT_FILE,\t\t\t/* `__FILE__' */\n+  BT_BASE_FILE,\t\t\t/* `__BASE_FILE__' */\n+  BT_INCLUDE_LEVEL,\t\t/* `__INCLUDE_LEVEL__' */\n+  BT_TIME,\t\t\t/* `__TIME__' */\n+  BT_STDC\t\t\t/* `__STDC__' */\n };\n \n /* There is a slot in the hashnode for use by front ends when integrated\n@@ -665,47 +706,56 @@ union tree_node;\n \n struct cpp_hashnode\n {\n+  const unsigned char *name;\t\t/* null-terminated name */\n   unsigned int hash;\t\t\t/* cached hash value */\n-  unsigned short length;\t\t/* length of name */\n-  ENUM_BITFIELD(node_type) type : 8;\t/* node type */\n+  unsigned short length;\t\t/* length of name excluding null */\n+  unsigned short arg_index;\t\t/* macro argument index */\n+  unsigned char directive_index;\t/* index into directive table.  */\n+  ENUM_BITFIELD(node_type) type : 8;\t/* node type.  */\n+  unsigned char flags;\t\t\t/* node flags.  */\n \n   union\n   {\n-    const cpp_toklist *expansion;\t/* a macro's replacement list.  */\n+    cpp_macro *macro;\t\t\t/* a macro.  */\n     struct answer *answers;\t\t/* answers to an assertion.  */\n-    enum cpp_ttype code;\t\t/* code for a named operator.  */\n+    enum cpp_ttype operator;\t\t/* code for a named operator.  */\n+    enum builtin_type builtin;\t\t/* code for a builtin macro.  */\n   } value;\n \n   union tree_node *fe_value;\t\t/* front end value */\n-\n-  const unsigned char name[1];\t\t/* name[length] */\n };\n \n+extern unsigned int cpp_token_len PARAMS ((const cpp_token *));\n+extern unsigned char *cpp_token_as_text PARAMS ((cpp_reader *, const cpp_token *));\n+extern unsigned char *cpp_spell_token PARAMS ((cpp_reader *, const cpp_token *,\n+\t\t\t\t\t       unsigned char *));\n extern void cpp_init PARAMS ((void));\n extern int cpp_handle_options PARAMS ((cpp_reader *, int, char **));\n extern int cpp_handle_option PARAMS ((cpp_reader *, int, char **));\n extern void cpp_reader_init PARAMS ((cpp_reader *));\n-extern cpp_printer *cpp_printer_init PARAMS ((cpp_reader *, cpp_printer *));\n \n extern void cpp_register_pragma PARAMS ((cpp_reader *,\n \t\t\t\t\t const char *, const char *,\n \t\t\t\t\t void (*) PARAMS ((cpp_reader *))));\n extern void cpp_register_pragma_space PARAMS ((cpp_reader *, const char *));\n \n-extern int cpp_start_read PARAMS ((cpp_reader *, cpp_printer *, const char *));\n-extern void cpp_output_tokens PARAMS ((cpp_reader *, cpp_printer *,\n-\t\t\t\t       unsigned int));\n-extern void cpp_finish PARAMS ((cpp_reader *, cpp_printer *));\n+extern int cpp_start_read PARAMS ((cpp_reader *, const char *));\n+extern void cpp_finish PARAMS ((cpp_reader *));\n extern void cpp_cleanup PARAMS ((cpp_reader *));\n-\n-extern const cpp_token *cpp_get_token PARAMS ((cpp_reader *));\n+extern int cpp_avoid_paste PARAMS ((cpp_reader *, const cpp_token *,\n+\t\t\t\t    const cpp_token *));\n+extern enum cpp_ttype cpp_can_paste PARAMS ((cpp_reader *, const cpp_token *,\n+\t\t\t\t\t     const cpp_token *, int *));\n+extern void cpp_get_token PARAMS ((cpp_reader *, cpp_token *));\n+extern const cpp_lexer_pos *cpp_get_line PARAMS ((cpp_reader *));\n+extern const unsigned char *cpp_macro_definition PARAMS ((cpp_reader *,\n+\t\t\t\t\t\t  const cpp_hashnode *));\n \n extern void cpp_define PARAMS ((cpp_reader *, const char *));\n extern void cpp_assert PARAMS ((cpp_reader *, const char *));\n extern void cpp_undef  PARAMS ((cpp_reader *, const char *));\n extern void cpp_unassert PARAMS ((cpp_reader *, const char *));\n \n-extern void cpp_free_token_list PARAMS ((cpp_toklist *));\n extern cpp_buffer *cpp_push_buffer PARAMS ((cpp_reader *,\n \t\t\t\t\t    const unsigned char *, long));\n extern cpp_buffer *cpp_pop_buffer PARAMS ((cpp_reader *));\n@@ -740,39 +790,88 @@ extern void cpp_pedwarn_with_file_and_line PARAMS ((cpp_reader *, const char *,\n extern void cpp_error_from_errno PARAMS ((cpp_reader *, const char *));\n extern void cpp_notice_from_errno PARAMS ((cpp_reader *, const char *));\n \n-extern const char *cpp_type2name PARAMS ((enum cpp_ttype));\n-\n /* In cpplex.c */\n-extern cpp_buffer *cpp_push_buffer\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\t const unsigned char *, long));\n-extern cpp_buffer *cpp_pop_buffer\tPARAMS ((cpp_reader *));\n-extern void cpp_scan_buffer\t\tPARAMS ((cpp_reader *, cpp_printer *));\n-extern void cpp_scan_buffer_nooutput\tPARAMS ((cpp_reader *));\n extern int cpp_ideq\t\t\tPARAMS ((const cpp_token *,\n \t\t\t\t\t\t const char *));\n-extern void cpp_printf\t\t\tPARAMS ((cpp_reader *, cpp_printer *,\n-\t\t\t\t\t\t const char *, ...));\n-\n-extern void cpp_output_list\t\tPARAMS ((cpp_reader *, FILE *,\n-\t\t\t\t\t\t const cpp_toklist *,\n-\t\t\t\t\t\t const cpp_token *));\n+extern void cpp_output_line\t\tPARAMS ((cpp_reader *, FILE *));\n+extern void cpp_output_token\t\tPARAMS ((const cpp_token *, FILE *));\n+extern const char *cpp_type2name\tPARAMS ((enum cpp_ttype));\n \n /* In cpphash.c */\n-extern cpp_hashnode *cpp_lookup\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t const unsigned char *, size_t));\n-extern void cpp_forall_identifiers PARAMS ((cpp_reader *,\n-\t\t\t\t\t    int (*) PARAMS ((cpp_reader *,\n-\t\t\t\t\t\t\t     cpp_hashnode *))));\n+extern cpp_hashnode *cpp_lookup\t\tPARAMS ((cpp_reader *,\n+\t\t\t\t\t\t const unsigned char *, size_t));\n+extern void cpp_forall_identifiers\tPARAMS ((cpp_reader *,\n+\t\t\t\t\t\t int (*) PARAMS ((cpp_reader *,\n+\t\t\t\t\t\t\t\t  cpp_hashnode *))));\n /* In cppmacro.c */\n-extern void cpp_dump_definition PARAMS ((cpp_reader *, FILE *,\n-\t\t\t\t\t const cpp_hashnode *));\n+extern void cpp_scan_buffer_nooutput\tPARAMS ((cpp_reader *));\n+extern void cpp_start_lookahead\t\tPARAMS ((cpp_reader *));\n+extern void cpp_stop_lookahead\t\tPARAMS ((cpp_reader *, int));\n \n /* In cppfiles.c */\n extern int cpp_included\tPARAMS ((cpp_reader *, const char *));\n extern int cpp_read_file PARAMS ((cpp_reader *, const char *));\n extern void cpp_make_system_header PARAMS ((cpp_reader *, cpp_buffer *, int));\n extern const char *cpp_syshdr_flags PARAMS ((cpp_reader *, cpp_buffer *));\n \n+/* These are inline functions instead of macros so we can get type\n+   checking.  */\n+typedef unsigned char U_CHAR;\n+#define U (const U_CHAR *)  /* Intended use: U\"string\" */\n+\n+static inline int ustrcmp\tPARAMS ((const U_CHAR *, const U_CHAR *));\n+static inline int ustrncmp\tPARAMS ((const U_CHAR *, const U_CHAR *,\n+\t\t\t\t\t size_t));\n+static inline size_t ustrlen\tPARAMS ((const U_CHAR *));\n+static inline U_CHAR *uxstrdup\tPARAMS ((const U_CHAR *));\n+static inline U_CHAR *ustrchr\tPARAMS ((const U_CHAR *, int));\n+static inline int ufputs\tPARAMS ((const U_CHAR *, FILE *));\n+\n+static inline int\n+ustrcmp (s1, s2)\n+     const U_CHAR *s1, *s2;\n+{\n+  return strcmp ((const char *)s1, (const char *)s2);\n+}\n+\n+static inline int\n+ustrncmp (s1, s2, n)\n+     const U_CHAR *s1, *s2;\n+     size_t n;\n+{\n+  return strncmp ((const char *)s1, (const char *)s2, n);\n+}\n+\n+static inline size_t\n+ustrlen (s1)\n+     const U_CHAR *s1;\n+{\n+  return strlen ((const char *)s1);\n+}\n+\n+static inline U_CHAR *\n+uxstrdup (s1)\n+     const U_CHAR *s1;\n+{\n+  return (U_CHAR *) xstrdup ((const char *)s1);\n+}\n+\n+static inline U_CHAR *\n+ustrchr (s1, c)\n+     const U_CHAR *s1;\n+     int c;\n+{\n+  return (U_CHAR *) strchr ((const char *)s1, c);\n+}\n+\n+static inline int\n+ufputs (s, f)\n+     const U_CHAR *s;\n+     FILE *f;\n+{\n+  return fputs ((const char *)s, f);\n+}\n+\n #ifdef __cplusplus\n }\n #endif"}, {"sha": "58d3020797c4003b9f3a3233d15db8e2a03be369", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 1473, "deletions": 418, "changes": 1891, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c80368d9a16c073f2b930bef4232661971765f/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c80368d9a16c073f2b930bef4232661971765f/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=93c80368d9a16c073f2b930bef4232661971765f", "patch": "@@ -1,4 +1,4 @@\n-/* Part of CPP library.  (Macro handling.)\n+/* Part of CPP library.  (Macro and #define handling.)\n    Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1998,\n    1999, 2000 Free Software Foundation, Inc.\n    Written by Per Bothner, 1994.\n@@ -25,573 +25,1521 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n \n #include \"config.h\"\n #include \"system.h\"\n+#include \"intl.h\"\t\t/* for _(\"<command line>\") below.  */\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n \n-/* Stores basic information about a macro, before it is allocated.  */\n-struct macro_info\n+struct cpp_macro\n {\n-  const cpp_token *first_param;\t/* First parameter token.  */\n-  const cpp_token *first;\t/* First expansion token.  */\n-  unsigned int paramlen;\t/* Length of parameter names. */\n-  unsigned int len;\t\t/* Length of token strings.  */\n-  unsigned int ntokens;\t\t/* Number of tokens in expansion.  */\n-  short paramc;\t\t\t/* Number of parameters.  */\n-  unsigned char flags;\n+  cpp_hashnode **params;\t/* Parameters, if any.  */\n+  cpp_token *expansion;\t\t/* First token of replacement list.   */\n+  const char *file;\t\t/* Defined in file name.  */\n+  unsigned int line;\t\t/* Starting line number.  */\n+  unsigned int count;\t\t/* Number of tokens in expansion.  */\n+  unsigned short paramc;\t/* Number of parameters.  */\n+  unsigned int fun_like : 1;\t/* If a function-like macro.  */\n+  unsigned int var_args : 1;\t/* If a variable-args macro.  */\n+  unsigned int disabled : 1;\t/* If macro is disabled.  */\n+};\n+\n+typedef struct macro_arg macro_arg;\n+struct macro_arg\n+{\n+  cpp_token *first;\t\t/* First token in unexpanded argument.  */\n+  cpp_token *expanded;\t\t/* Macro-expanded argument.   */\n+  cpp_token *stringified;\t/* Stringified argument.  */\n+  unsigned int count;\t\t/* # of tokens in argument.  */\n+  unsigned int expanded_count;\t/* # of tokens in expanded argument.  */\n };\n \n-static void count_params PARAMS ((cpp_reader *, struct macro_info *));\n-static int is__va_args__ PARAMS ((cpp_reader *, const cpp_token *));\n-\n-static int parse_define PARAMS((cpp_reader *, struct macro_info *));\n-static int check_macro_redefinition PARAMS((cpp_reader *, cpp_hashnode *hp,\n-\t\t\t\t\t    const cpp_toklist *));\n-static const cpp_toklist * save_expansion PARAMS((cpp_reader *,\n- \t\t\t\t\t\t  struct macro_info *));\n-static unsigned int find_param PARAMS ((const cpp_token *,\n- \t\t\t\t\tconst cpp_token *));\n-static cpp_toklist * alloc_macro PARAMS ((cpp_reader *, struct macro_info *));\n+/* Macro expansion.  */\n+\n+static void lock_pools PARAMS ((cpp_reader *));\n+static void unlock_pools PARAMS ((cpp_reader *));\n+static int enter_macro_context PARAMS ((cpp_reader *, cpp_token *));\n+static void builtin_macro PARAMS ((cpp_reader *, cpp_token *));\n+static cpp_context *push_arg_context PARAMS ((cpp_reader *, macro_arg *));\n+static enum cpp_ttype parse_arg PARAMS ((cpp_reader *, macro_arg *, int));\n+static macro_arg *parse_args PARAMS ((cpp_reader *, const cpp_hashnode *));\n+static cpp_context *next_context PARAMS ((cpp_reader *));\n+static void expand_arg PARAMS ((cpp_reader *, macro_arg *));\n+static unsigned char *quote_string PARAMS ((unsigned char *,\n+\t\t\t\t\t    const unsigned char *,\n+\t\t\t\t\t    unsigned int));\n+static void make_string_token PARAMS ((cpp_pool *, cpp_token *,\n+\t\t\t\t       const U_CHAR *, unsigned int));\n+static void make_number_token PARAMS ((cpp_reader *, cpp_token *, int));\n+static void stringify_arg PARAMS ((cpp_reader *, macro_arg *));\n+static void paste_all_tokens PARAMS ((cpp_reader *, cpp_token *));\n+static void paste_payloads PARAMS ((cpp_reader *, cpp_token *,\n+\t\t\t\t    const cpp_token *));\n+static int funlike_invocation_p PARAMS ((cpp_reader *, const cpp_hashnode *,\n+\t\t\t\t\t  struct toklist *));\n+static void replace_args PARAMS ((cpp_reader *, cpp_macro *, macro_arg *,\n+\t\t\t\t  struct toklist *));\n+\n+/* Lookaheads.  */\n+\n+static void save_lookahead_token PARAMS ((cpp_reader *, const cpp_token *));\n+static void take_lookahead_token PARAMS ((cpp_reader *, cpp_token *));\n+static void release_lookahead PARAMS ((cpp_reader *));\n+static cpp_lookahead *alloc_lookahead PARAMS ((cpp_reader *));\n+static void free_lookahead PARAMS ((cpp_lookahead *));\n+\n+/* #define directive parsing and handling.  */\n+\n+static cpp_token *lex_expansion_token PARAMS ((cpp_reader *, cpp_macro *));\n+static int check_macro_redefinition PARAMS ((cpp_reader *,\n+\t\t\t\t\t     const cpp_hashnode *,\n+\t\t\t\t\t     const cpp_macro *));\n+static int save_parameter PARAMS ((cpp_reader *, cpp_macro *, cpp_hashnode *));\n+static int parse_params PARAMS ((cpp_reader *, cpp_macro *));\n static void check_trad_stringification PARAMS ((cpp_reader *,\n-\t\t\t\t\t\tconst struct macro_info *,\n+\t\t\t\t\t\tconst cpp_macro *,\n \t\t\t\t\t\tconst cpp_string *));\n \n-/* These are all the tokens that can have something pasted after them.\n-   Comma is included in the list only to support the GNU varargs extension\n-   (where you write a ## b and a disappears if b is an empty rest argument).\n-   CPP_OTHER is included because of Objective C's use of '@'.  */\n-#define CAN_PASTE_AFTER(type) \\\n-((type) <= CPP_LAST_EQ || (type) == CPP_COLON || (type) == CPP_HASH \\\n- || (type) == CPP_DEREF || (type) == CPP_DOT || (type) == CPP_NAME \\\n- || (type) == CPP_INT || (type) == CPP_FLOAT || (type) == CPP_NUMBER \\\n- || (type) == CPP_MACRO_ARG || (type) == CPP_PLACEMARKER \\\n- || (type) == CPP_COMMA || (type) == CPP_OTHER)\n-\n-/* Scans for a given token, returning the parameter number if found,\n-   or 0 if not found.  Scans from FIRST to TOKEN - 1 or the first\n-   CPP_CLOSE_PAREN for TOKEN.  */\n-static unsigned int\n-find_param (first, token)\n-     const cpp_token *first, *token;\n-{\n-  unsigned int param = 0;\n-\n-  for (; first < token && first->type != CPP_CLOSE_PAREN; first++)\n-    if (first->type == CPP_NAME || first->type == CPP_DEFINED)\n+/* Allocates a buffer to hold a token's TEXT, and converts TOKEN to a\n+   CPP_STRING token containing TEXT in quoted form.  */\n+static void\n+make_string_token (pool, token, text, len)\n+     cpp_pool *pool;\n+     cpp_token *token;\n+     const U_CHAR *text;\n+     unsigned int len;\n+{\n+  U_CHAR *buf = _cpp_pool_alloc (pool, len * 4);\n+\n+  token->type = CPP_STRING;\n+  token->val.str.text = buf;\n+  token->val.str.len = quote_string (buf, text, len) - buf;\n+  token->flags = 0;\n+}\n+\n+/* Allocates and converts a temporary token to a CPP_NUMBER token,\n+   evaluating to NUMBER.  */\n+static void\n+make_number_token (pfile, token, number)\n+     cpp_reader *pfile;\n+     cpp_token *token;\n+     int number;\n+{\n+  unsigned char *buf = _cpp_pool_alloc (pfile->string_pool, 20);\n+\n+  sprintf ((char *) buf, \"%d\", number);\n+  token->type = CPP_NUMBER;\n+  token->val.str.text = buf;\n+  token->val.str.len = ustrlen (buf);\n+  token->flags = 0;\n+}\n+\n+static const char * const monthnames[] =\n+{\n+  \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n+  \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n+};\n+\n+/* Handle builtin macros like __FILE__.  */\n+static void\n+builtin_macro (pfile, token)\n+     cpp_reader *pfile;\n+     cpp_token *token;\n+{\n+  unsigned char flags = token->flags & PREV_WHITE;\n+  cpp_hashnode *node = token->val.node;\n+  cpp_buffer *ip;\n+\n+  switch (node->value.builtin)\n+    {\n+    case BT_FILE:\n+    case BT_BASE_FILE:\n       {\n-\tparam++;\n-\tif (first->val.node == token->val.node)\n-\t  return param;\n+\tconst char *file;\n+\n+\tip = CPP_BUFFER (pfile);\n+\tif (ip == 0)\n+\t  file = \"\";\n+\telse\n+\t  {\n+\t    if (node->value.builtin == BT_BASE_FILE)\n+\t      while (CPP_PREV_BUFFER (ip) != NULL)\n+\t\tip = CPP_PREV_BUFFER (ip);\n+\n+\t    file = ip->nominal_fname;\n+\t  }\n+\tmake_string_token (pfile->string_pool, token,\n+\t\t\t   (U_CHAR *) file, strlen (file));\n       }\n+      break;\n+\t\n+    case BT_INCLUDE_LEVEL:\n+      /* pfile->include_depth counts the primary source as level 1,\n+\t but historically __INCLUDE_DEPTH__ has called the primary\n+\t source level 0.  */\n+      make_number_token (pfile, token, pfile->include_depth - 1);\n+      break;\n+\n+    case BT_SPECLINE:\n+      /* If __LINE__ is embedded in a macro, it must expand to the\n+\t line of the macro's invocation, not its definition.\n+\t Otherwise things like assert() will not work properly.  */\n+      make_number_token (pfile, token, cpp_get_line (pfile)->line);\n+      break;\n+\n+    case BT_STDC:\n+      {\n+\tint stdc = 1;\n+\n+#ifdef STDC_0_IN_SYSTEM_HEADERS\n+\tif (CPP_IN_SYSTEM_HEADER (pfile)\n+\t    && pfile->spec_nodes.n__STRICT_ANSI__->type == T_VOID)\n+\t  stdc = 0;\n+#endif\n+\tmake_number_token (pfile, token, stdc);\n+      }\n+      break;\n \n-  return 0;\n+    case BT_DATE:\n+    case BT_TIME:\n+      if (pfile->date.type == CPP_EOF)\n+\t{\n+\t  /* Allocate __DATE__ and __TIME__ from permanent storage,\n+\t     and save them in pfile so we don't have to do this again.\n+\t     We don't generate these strings at init time because\n+\t     time() and localtime() are very slow on some systems.  */\n+\t  time_t tt = time (NULL);\n+\t  struct tm *tb = localtime (&tt);\n+\n+\t  make_string_token (&pfile->ident_pool, &pfile->date,\n+\t\t\t     DSC(\"Oct 11 1347\"));\n+\t  make_string_token (&pfile->ident_pool, &pfile->time,\n+\t\t\t     DSC(\"12:34:56\"));\n+\n+\t  sprintf ((char *) pfile->date.val.str.text, \"%s %2d %4d\",\n+\t\t   monthnames[tb->tm_mon], tb->tm_mday, tb->tm_year + 1900);\n+\t  sprintf ((char *) pfile->time.val.str.text, \"%02d:%02d:%02d\",\n+\t\t   tb->tm_hour, tb->tm_min, tb->tm_sec);\n+\t}\n+      *token = node->value.builtin == BT_DATE ? pfile->date: pfile->time;\n+      break;\n+\n+    default:\n+      cpp_ice (pfile, \"invalid builtin macro \\\"%s\\\"\", node->name);\n+      break;\n+    }\n+\n+  token->flags = flags;\n }\n \n-/* Constraint 6.10.3.5: __VA_ARGS__ should only appear in the\n-   replacement list of a variable-arguments macro.  TOKEN is assumed\n-   to be of type CPP_NAME.  */\n-static int\n-is__va_args__ (pfile, token)\n+/* Used by cpperror.c to obtain the correct line and column to report\n+   in a diagnostic.  */\n+const cpp_lexer_pos *\n+cpp_get_line (pfile)\n      cpp_reader *pfile;\n-     const cpp_token *token;\n {\n-  if (!CPP_PEDANTIC (pfile)\n-      || token->val.node != pfile->spec_nodes->n__VA_ARGS__)\n-    return 0;\n+  /* Within a macro expansion, return the position of the outermost\n+     invocation.  */\n+  if (pfile->context->prev)\n+    return &pfile->macro_pos;\n+  return &pfile->lexer_pos;\n+}\n \n-  cpp_pedwarn_with_line (pfile, token->line, token->col,\n-       \"\\\"%s\\\" is only valid in the replacement list of a function-like macro\",\n-\t\t       token->val.node->name);\n-  return 1;\n+static void\n+lock_pools (pfile)\n+     cpp_reader *pfile;\n+{\n+  _cpp_lock_pool (&pfile->temp_string_pool);\n+  _cpp_lock_pool (&pfile->argument_pool);\n }\n \n-/* Counts the parameters to a function-like macro, the length of their\n-   null-terminated names, and whether the macro is a variable-argument\n-   one.  FIRST is the token immediately after the open parenthesis,\n-   INFO stores the data.\n+static void\n+unlock_pools (pfile)\n+     cpp_reader *pfile;\n+{\n+  _cpp_unlock_pool (&pfile->temp_string_pool);\n+  _cpp_unlock_pool (&pfile->argument_pool);\n+}\n \n-   On success, info->first is updated to the token after the closing\n-   parenthesis, i.e. the first token of the expansion.  Otherwise\n-   there was an error, which has been reported.  */\n static void\n-count_params (pfile, info)\n+paste_payloads (pfile, lhs, rhs)\n      cpp_reader *pfile;\n-     struct macro_info *info;\n+     cpp_token *lhs;\n+     const cpp_token *rhs;\n {\n-  unsigned int prev_ident = 0;\n-  const cpp_token *token;\n+  unsigned int total_len = cpp_token_len (lhs) + cpp_token_len (rhs);\n+  unsigned char *result, *end;\n+  cpp_pool *pool;\n+\n+  pool = lhs->type == CPP_NAME ? &pfile->ident_pool: pfile->string_pool;\n+  result = _cpp_pool_alloc (pool, total_len + 1);\n \n-  info->paramc = 0;\n-  info->paramlen = 0;\n-  info->flags = 0;\n-  info->first = info->first_param; /* Not a ')' indicating success.  */\n+  /* Paste the spellings and null terminate.  */\n+  end = cpp_spell_token (pfile, rhs, cpp_spell_token (pfile, lhs, result));\n+  *end = '\\0';\n+  total_len = end - result;\n \n-  for (token = info->first_param;; token++)\n+  if (lhs->type == CPP_NAME)\n     {\n-      switch (token->type)\n+      lhs->val.node = cpp_lookup (pfile, result, total_len);\n+      if (lhs->val.node->flags & NODE_OPERATOR)\n \t{\n-\tdefault:\n-\t  cpp_error_with_line (pfile, token->line, token->col,\n-\t\t\t       \"token may not appear in macro parameter list\");\n-\t  return;\n-\n-\tcase CPP_EOF:\n-\tmissing_paren:\n-\t  cpp_error_with_line (pfile, token->line, token->col,\n-\t\t\t       \"missing ')' in macro parameter list\");\n-\t  return;\n+\t  lhs->flags |= NAMED_OP;\n+\t  lhs->type = lhs->val.node->value.operator;\n+\t}\n+    }\n+  else\n+    {\n+      lhs->val.str.text = result;\n+      lhs->val.str.len = total_len;\n+    }\n+}\n \n-\tcase CPP_COMMENT:\n-\t  continue;\t\t/* Ignore -C comments.  */\n+/* Adds backslashes before all backslashes and double quotes appearing\n+   in strings.  Non-printable characters are converted to octal.  */\n+static U_CHAR *\n+quote_string (dest, src, len)\n+     U_CHAR *dest;\n+     const U_CHAR *src;\n+     unsigned int len;\n+{\n+  while (len--)\n+    {\n+      U_CHAR c = *src++;\n \n-\tcase CPP_DEFINED:\t/* 'defined' may be used as a macro\n-\t\t\t\t   parameter name.  */\n-\tcase CPP_NAME:\n-\t  if (prev_ident)\n+      if (c == '\\\\' || c == '\"')\n+\t{\n+\t  *dest++ = '\\\\';\n+\t  *dest++ = c;\n+\t}\n+      else\n+\t{\n+\t  if (ISPRINT (c))\n+\t    *dest++ = c;\n+\t  else\n \t    {\n-\t      cpp_error_with_line (pfile, token->line, token->col,\n-\t\t\t   \"macro parameters must be comma-separated\");\n-\t      return;\n+\t      sprintf ((char *) dest, \"\\\\%03o\", c);\n+\t      dest += 4;\n \t    }\n+\t}\n+    }\n \n-\t  /* Constraint 6.10.3.5  */\n-\t  if (is__va_args__ (pfile, token))\n-\t    return;\n+  return dest;\n+}\n \n-\t  /* Constraint 6.10.3.6 - duplicate parameter names.  */\n-\t  if (find_param (info->first, token))\n-\t    {\n-\t      cpp_error_with_line (pfile, token->line, token->col,\n-\t\t\t\t   \"duplicate macro parameter \\\"%s\\\"\",\n-\t\t\t\t   token->val.node->name);\n-\t      return;\n-\t    }\n+/* Convert a token sequence to a single string token according to the\n+   rules of the ISO C #-operator.  */\n+static void\n+stringify_arg (pfile, arg)\n+     cpp_reader *pfile;\n+     macro_arg *arg;\n+{\n+  cpp_pool *pool = pfile->string_pool;\n+  unsigned char *start = POOL_FRONT (pool);\n+  unsigned int i, escape_it, total_len = 0, backslash_count = 0;\n+  unsigned int prev_white = 0;\n \n-\t  prev_ident = 1;\n-\t  info->paramc++;\n-\t  info->paramlen += token->val.node->length + 1;\n-\t  continue;\n+  /* Loop, reading in the argument's tokens.  */\n+  for (i = 0; i < arg->count; i++)\n+    {\n+      unsigned char *dest;\n+      const cpp_token *token = &arg->first[i];\n+      unsigned int len = cpp_token_len (token);\n \n-\tcase CPP_CLOSE_PAREN:\n-\t  if (prev_ident || info->paramc == 0)\n-\t    break;\n+      escape_it = (token->type == CPP_STRING || token->type == CPP_WSTRING\n+\t\t   || token->type == CPP_CHAR || token->type == CPP_WCHAR\n+\t\t   || token->type == CPP_OSTRING);\n \n-\t  /* Fall through to pick up the error.  */\n-\tcase CPP_COMMA:\n-\t  if (!prev_ident)\n-\t    {\n-\t      cpp_error_with_line (pfile, token->line, token->col,\n-\t\t\t\t   \"parameter name expected\");\n-\t      return;\n-\t    }\n-\t  prev_ident = 0;\n-\t  continue;\n+      if (escape_it)\n+\t/* Worst case is each char is octal.  */\n+\tlen *= 4;\n+      len++;\t\t\t/* Room for initial space.  */\n \n-\tcase CPP_ELLIPSIS:\n-\t  /* Convert ISO-style var_args to named varargs by changing\n-\t     the ellipsis into an identifier with name __VA_ARGS__.\n-\t     This simplifies other handling. */\n-\t  if (!prev_ident)\n-\t    {\n-\t      cpp_token *tok = (cpp_token *) token;\n+      dest = &start[total_len];\n+      if (dest + len > POOL_LIMIT (pool))\n+\t{\n+\t  _cpp_next_chunk (pool, len, (unsigned char **) &start);\n+\t  dest = &start[total_len];\n+\t}\n \n-\t      tok->type = CPP_NAME;\n-\t      tok->val.node = pfile->spec_nodes->n__VA_ARGS__;\n+      prev_white |= token->flags & PREV_WHITE;\n+      if (token->type == CPP_PLACEMARKER)\n+\tcontinue;\n \n-\t      info->paramc++;\n-\t      info->paramlen += tok->val.node->length + 1;\n+      /* No leading white space.  */\n+      if (prev_white)\n+\t{\n+\t  prev_white = 0;\n+\t  if (total_len > 0)\n+\t    *dest++ = ' ';\n+\t}\n \n-\t      if (CPP_PEDANTIC (pfile) && ! CPP_OPTION (pfile, c99))\n-\t\tcpp_pedwarn (pfile,\n-\t\t\t     \"C89 does not permit anon varargs macros\");\n-\t    }\n-\t  else\n+      if (escape_it)\n+\t{\n+\t  unsigned char *buf = (unsigned char *) xmalloc (len);\n+\n+\t  len = cpp_spell_token (pfile, token, buf) - buf;\n+\t  dest = quote_string (dest, buf, len);\n+\t  free (buf);\n+\t}\n+      else\n+\tdest = cpp_spell_token (pfile, token, dest);\n+      total_len = dest - start;\n+\n+      if (token->type == CPP_BACKSLASH)\n+\tbackslash_count++;\n+      else\n+\tbackslash_count = 0;\n+    }\n+\n+  /* Ignore the final \\ of invalid string literals.  */\n+  if (backslash_count & 1)\n+    {\n+      cpp_warning (pfile, \"invalid string literal, ignoring final '\\\\'\");\n+      total_len--;\n+    }\n+\n+  POOL_COMMIT (pool, total_len);\n+\n+  arg->stringified = xnew (cpp_token);\n+  arg->stringified->flags = 0;\n+  arg->stringified->type = CPP_STRING;\n+  arg->stringified->val.str.text = start;\n+  arg->stringified->val.str.len = total_len;\n+}\n+\n+/* Handles an arbitrarily long sequence of ## operators.  This\n+   implementation is left-associative, non-recursive, and finishes a\n+   paste before handling succeeding ones.  If the paste fails, the\n+   right hand side of the ## operator is placed in the then-current\n+   context's lookahead buffer, with the effect that it appears in the\n+   output stream normally.  */\n+static void\n+paste_all_tokens (pfile, lhs)\n+     cpp_reader *pfile;\n+     cpp_token *lhs;\n+{\n+  unsigned char orig_flags = lhs->flags;\n+  cpp_token *rhs;\n+\n+  do\n+    {\n+      /* Take the token directly from the current context.  We can do\n+\t this, because we are in the replacement list of either an\n+\t object-like macro, or a function-like macro with arguments\n+\t inserted.  In either case, the constraints to #define\n+\t guarantee we have at least one more token (empty arguments\n+\t become placemarkers).  */\n+      rhs = pfile->context->list.first++;\n+\n+      if (rhs->type == CPP_PLACEMARKER)\n+\t{\n+\t  /* GCC has special extended semantics for , ## b where b is\n+\t     a varargs parameter: the comma disappears if b was given\n+\t     no actual arguments (not merely if b is an empty\n+\t     argument).  */\n+\t  if (lhs->type == CPP_COMMA && (rhs->flags & VARARGS_FIRST))\n+\t    lhs->type = CPP_PLACEMARKER;\n+\t}\n+      else if (lhs->type == CPP_PLACEMARKER)\n+\t*lhs = *rhs;\n+      else\n+\t{\n+\t  int digraph = 0;\n+\t  enum cpp_ttype type = cpp_can_paste (pfile, lhs, rhs, &digraph);\n+\n+\t  if (type == CPP_EOF)\n \t    {\n-\t      if (CPP_PEDANTIC (pfile))\n-\t\tcpp_pedwarn (pfile,\n-\t\t\t     \"ISO C does not permit named varargs parameters\");\n+\t      /* Do nothing special about , ## <whatever> if\n+\t\t <whatever> came from a variable argument, because the\n+\t\t author probably intended the ## to trigger the\n+\t\t special extended semantics (see above).  */\n+\t      if (lhs->type == CPP_COMMA && (rhs->flags & VARARGS_FIRST))\n+\t\t/* nothing */;\n+\t      else\n+\t\t{\n+\t\t  if (CPP_OPTION (pfile, warn_paste))\n+\t\t    cpp_warning (pfile,\n+\t\t \"pasting \\\"%s\\\" and \\\"%s\\\" does not give a valid preprocessing token\",\n+\t\t\t\t cpp_token_as_text (pfile, lhs),\n+\t\t\t\t cpp_token_as_text (pfile, rhs));\n+\n+\t\t  /* The standard states that behaviour is undefined.\n+\t\t     By the principle of least surpise, we step back\n+\t\t     before the RHS, and mark it to prevent macro\n+\t\t     expansion.  Tests in the testsuite rely on\n+\t\t     clearing PREV_WHITE here, though you could argue\n+\t\t     we should actually set it.  */\n+\t\t  rhs->flags &= ~PREV_WHITE;\n+\t\t  rhs->flags |= NO_EXPAND;\n+\t\t}\n+\n+\t      /* Step back so we read the RHS in next.  */\n+\t      pfile->context->list.first--;\n+\t      break;\n \t    }\n \n-\t  info->flags |= VAR_ARGS;\n-\t  token++;\n-\t  if (token->type == CPP_CLOSE_PAREN)\n-\t    break;\n-\t  goto missing_paren;\n+\t  lhs->type = type;\n+\t  lhs->flags &= ~DIGRAPH;\n+\t  if (digraph)\n+\t    lhs->flags |= DIGRAPH;\n+\n+\t  if (type == CPP_NAME || type == CPP_NUMBER)\n+\t    paste_payloads (pfile, lhs, rhs);\n+\t  else if (type == CPP_WCHAR || type == CPP_WSTRING)\n+\t    lhs->val.str = rhs->val.str;\n+\t}\n+    }\n+  while (rhs->flags & PASTE_LEFT);\n+\n+  /* The pasted token has the PREV_WHITE flag of the LHS, is no longer\n+     PASTE_LEFT, and is subject to macro expansion.  */\n+  lhs->flags &= ~(PREV_WHITE | PASTE_LEFT | NO_EXPAND);\n+  lhs->flags |= orig_flags & PREV_WHITE;\n+}\n+\n+/* Reads the unexpanded tokens of a macro argument into ARG.  Empty\n+   arguments are saved as a single CPP_PLACEMARKER token.  VAR_ARGS is\n+   non-zero if this is a variable argument.  Returns the type of the\n+   token that caused reading to finish.  */\n+static enum cpp_ttype\n+parse_arg (pfile, arg, var_args)\n+     cpp_reader *pfile;\n+     struct macro_arg *arg;\n+     int var_args;\n+{\n+  enum cpp_ttype result;\n+  unsigned int paren = 0;\n+\n+  arg->first = (cpp_token *) POOL_FRONT (&pfile->argument_pool);\n+  for (;; arg->count++)\n+    {\n+      cpp_token *token = &arg->first[arg->count];\n+      if ((unsigned char *) (token + 1) >= POOL_LIMIT (&pfile->argument_pool))\n+\t{\n+\t  _cpp_next_chunk (&pfile->argument_pool, sizeof (cpp_token),\n+\t\t\t   (unsigned char **) &arg->first);\n+\t  token = &arg->first[arg->count];\n+\t}\n+\n+      _cpp_get_token (pfile, token);\n+      result = token->type;\n+\n+      if (result == CPP_OPEN_PAREN)\n+\tparen++;\n+      else if (result == CPP_CLOSE_PAREN && paren-- == 0)\n+\tbreak;\n+      /* Commas are not terminators within parantheses or var_args.  */\n+      else if (result == CPP_COMMA && paren == 0 && !var_args)\n+\tbreak;\n+      else if (result == CPP_EOF)\n+\tbreak;\t\t/* Error reported by caller.  */\n+      else if (result == CPP_DHASH)\n+\t{\n+\t  /* 6.10.3 paragraph 11: If there are sequences of\n+\t     preprocessing tokens within the list of arguments that\n+\t     would otherwise act as preprocessing directives, the\n+\t     behavior is undefined.\n+\n+\t     This implementation will report a hard error, terminate\n+\t     the macro invocation, and proceed to process the\n+\t     directive.  */\n+\t  cpp_error (pfile, \"directives may not be used inside a macro argument\");\n+\t  _cpp_push_token (pfile, token, &pfile->lexer_pos);\n+\t  result = CPP_EOF;\n+\t  break;\n \t}\n+    }\n \n-      /* Success.  */\n-      info->first = token + 1;\n-      if (!pfile->save_parameter_spellings)\n-\tinfo->paramlen = 0;\n-      return;\n+  /* Empty arguments become a single placemarker token.  */\n+  if (arg->count == 0)\n+    {\n+      arg->first->type = CPP_PLACEMARKER;\n+      arg->count = 1;\n     }\n+\n+  /* Commit the memory used to store the arguments.  */\n+  POOL_COMMIT (&pfile->argument_pool, arg->count * sizeof (cpp_token));\n+\n+  return result;\n }\n \n-/* Parses a #define directive.  On success, returns zero, and INFO is\n-   filled in appropriately.  */\n+/* Parse the arguments making up a macro invocation.  */\n+static macro_arg *\n+parse_args (pfile, node)\n+     cpp_reader *pfile;\n+     const cpp_hashnode *node;\n+{\n+  cpp_macro *macro = node->value.macro;\n+  macro_arg *args, *cur;\n+  enum cpp_ttype type;\n+  int argc, error = 0;\n+\n+  /* Allocate room for at least one argument, and zero it out.  */\n+  argc = macro->paramc ? macro->paramc: 1;\n+  args = xcnewvec (macro_arg, argc);\n+\n+  for (cur = args, argc = 0; ;)\n+    {\n+      argc++;\n+\n+      type = parse_arg (pfile, cur, argc == macro->paramc && macro->var_args);\n+      if (type == CPP_CLOSE_PAREN || type == CPP_EOF)\n+\tbreak;\n+\n+      /* Re-use the last argument for excess arguments.  */\n+      if (argc < macro->paramc)\n+\tcur++;\n+    }\n+\n+  if (type == CPP_EOF)\n+    {\n+      cpp_error (pfile, \"unterminated argument list invoking macro \\\"%s\\\"\",\n+\t\t node->name);\n+      error = 1;\n+    }\n+  else if (argc < macro->paramc)\n+    {\n+      /* As an extension, a rest argument is allowed to not appear in\n+\t the invocation at all.\n+\t e.g. #define debug(format, args...) something\n+\t debug(\"string\");\n+\t \n+\t This is exactly the same as if there had been an empty rest\n+\t argument - debug(\"string\", ).  */\n+\n+      if (argc + 1 == macro->paramc && macro->var_args)\n+\t{\n+\t  /* parse_arg ensured there was space for the closing\n+\t     parenthesis.  Use this space to store a placemarker.  */\n+\t  args[argc].first = (cpp_token *) POOL_FRONT (&pfile->argument_pool);\n+\t  args[argc].first->type = CPP_PLACEMARKER;\n+\t  args[argc].count = 1;\n+\t  POOL_COMMIT (&pfile->argument_pool, sizeof (cpp_token));\n+\n+\t  if (CPP_OPTION (pfile, c99) && CPP_PEDANTIC (pfile))\n+\t    cpp_pedwarn (pfile, \"ISO C99 requires rest arguments to be used\");\n+\t}\n+      else\n+\t{\n+\t  cpp_error (pfile,\n+\t\t     \"macro \\\"%s\\\" requires %u arguments, but only %u given\",\n+\t\t     node->name, macro->paramc, argc);\n+\t  error = 1;\n+\t}\n+    }\n+  else if (argc > macro->paramc)\n+    {\n+      /* An empty argument to an empty function-like macro is fine.  */\n+      if (argc != 1 || args[0].first->type != CPP_PLACEMARKER)\n+\t{\n+\t  cpp_error (pfile,\n+\t\t     \"macro \\\"%s\\\" passed %u arguments, but takes just %u\",\n+\t\t     node->name, argc, macro->paramc);\n+\t  error = 1;\n+\t}\n+    }\n+\n+  if (error)\n+    {\n+      free (args);\n+      args = 0;\n+    }\n+\n+  return args;\n+}\n+\n+static int\n+funlike_invocation_p (pfile, node, list)\n+     cpp_reader *pfile;\n+     const cpp_hashnode *node;\n+     struct toklist *list;\n+{\n+  cpp_context *orig_context;\n+  cpp_token maybe_paren;\n+  macro_arg *args = 0;\n+\n+  pfile->state.parsing_args = 1;\n+  pfile->state.prevent_expansion++;\n+  orig_context = pfile->context;\n+\n+  cpp_start_lookahead (pfile);\n+  cpp_get_token (pfile, &maybe_paren);\n+  cpp_stop_lookahead (pfile, maybe_paren.type == CPP_OPEN_PAREN);\n+\n+  if (maybe_paren.type == CPP_OPEN_PAREN)\n+    args = parse_args (pfile, node);\n+  else if (CPP_WTRADITIONAL (pfile))\n+    cpp_warning (pfile,\n+\t \"function-like macro \\\"%s\\\" must be used with arguments in traditional C\",\n+\t\t node->name);\n+\n+  /* Restore original context.  */\n+  pfile->context = orig_context;\n+  pfile->state.prevent_expansion--;\n+  pfile->state.parsing_args = 0;\n+\n+  if (args)\n+    {\n+      if (node->value.macro->paramc > 0)\n+\treplace_args (pfile, node->value.macro, args, list);\n+      free (args);\n+    }\n+\n+  return args != 0;\n+}\n+\n+/* Push the context of a macro onto the context stack.  TOKEN is the\n+   macro name.  If we can successfully start expanding the macro,\n+   TOKEN is replaced with the first token of the expansion.  */\n static int\n-parse_define (pfile, info)\n+enter_macro_context (pfile, token)\n      cpp_reader *pfile;\n-     struct macro_info *info;\n+     cpp_token *token;\n {\n-  const cpp_token *token;\n-  int prev_white = 0;\n+  cpp_context *context;\n+  cpp_macro *macro;\n+  unsigned char flags;\n+  struct toklist list;\n \n-  /* The first token after the macro's name.  */\n-  token = _cpp_get_token (pfile);\n+  macro = token->val.node->value.macro;\n+  if (macro->disabled)\n+    {\n+      token->flags |= NO_EXPAND;\n+      return 1;\n+    }\n \n-  /* Constraint 6.10.3.5  */\n-  if (is__va_args__ (pfile, token - 1))\n-    return 1;\n+  /* Save the position of the outermost macro invocation.  */\n+  if (!pfile->context->prev)\n+    {\n+      pfile->macro_pos = pfile->lexer_pos;\n+      lock_pools (pfile);\n+    }\n \n-  while (token->type == CPP_COMMENT)\n-    token++, prev_white = 1;\n-  prev_white |= token->flags & PREV_WHITE;\n+  if (macro->fun_like && !funlike_invocation_p (pfile, token->val.node, &list))\n+    {\n+      if (!pfile->context->prev)\n+\tunlock_pools (pfile);\n+      return 1;\n+    }\n \n-  if (token->type == CPP_OPEN_PAREN && !prev_white)\n+  /* Now push its context.  */\n+  context = next_context (pfile);\n+  if (macro->paramc == 0)\n     {\n-      /* A function-like macro.  */\n-      info->first_param = token + 1;\n-      count_params (pfile, info);\n-      if (info->first[-1].type != CPP_CLOSE_PAREN)\n-\treturn 1;\n+      context->list.first = macro->expansion;\n+      context->list.limit = macro->expansion + macro->count;\n     }\n   else\n+    context->list = list;\n+  context->macro = macro;\n+\n+  /* The first expansion token inherits the PREV_WHITE of TOKEN.  */\n+  flags = token->flags & PREV_WHITE;\n+  *token = *context->list.first++;\n+  token->flags |= flags;\n+\n+  /* Disable the macro within its expansion.  */\n+  macro->disabled = 1;\n+\n+  return 0;\n+}\n+\n+/* Move to the next context.  Create one if there is none.  */\n+static cpp_context *\n+next_context (pfile)\n+     cpp_reader *pfile;\n+{\n+  cpp_context *prev = pfile->context;\n+  cpp_context *result = prev->next;\n+\n+  if (result == 0)\n     {\n-      /* An object-like macro.  */\n-      info->paramc = -1;\n-      info->paramlen = 0;\n-      info->flags = 0;\n-      info->first = token;\n-      if (!prev_white && token->type != CPP_EOF)\n-\tcpp_pedwarn (pfile, \"ISO C requires whitespace after the macro name\");\n+      result = xnew (cpp_context);\n+      prev->next = result;\n+      result->prev = prev;\n+      result->next = 0;\n     }\n \n-  /* Count tokens in expansion.  We drop paste tokens, and stringize\n-     tokens, so don't count them.  */\n-  info->ntokens = info->len = 0;\n-  for (token = info->first; token->type != CPP_EOF; token++)\n+  pfile->context = result;\n+  return result;\n+}\n+\n+static void\n+replace_args (pfile, macro, args, list)\n+     cpp_reader *pfile;\n+     cpp_macro *macro;\n+     macro_arg *args;\n+     struct toklist *list;\n+{\n+  unsigned int i, total;\n+  const cpp_token *src, *limit;\n+  cpp_token *dest;\n+  macro_arg *arg;\n+\n+  src = macro->expansion;\n+  limit = src + macro->count;\n+\n+  /* First, fully macro-expand arguments, calculating the number of\n+     tokens in the final expansion as we go.  This ensures that the\n+     possible recursive use of argument_pool is fine.  */\n+  total = limit - src;\n+  for (; src < limit; src++)\n+    if (src->type == CPP_MACRO_ARG)\n+      {\n+\t/* We have an argument.  If it is not being stringified or\n+\t   pasted it is macro-replaced before insertion.  */\n+\targ = &args[src->val.aux - 1];\n+\tif (src->flags & STRINGIFY_ARG)\n+\t  {\n+\t    if (!arg->stringified)\n+\t      stringify_arg (pfile, arg);\n+\t  }\n+\telse if ((src->flags & PASTE_LEFT)\n+\t\t || (src > macro->expansion && (src[-1].flags & PASTE_LEFT)))\n+\t  total += arg->count - 1;\n+\telse\n+\t  {\n+\t    if (!arg->expanded)\n+\t      expand_arg (pfile, arg);\n+\t    total += arg->expanded_count - 1;\n+\t  }\n+      }\n+\n+  dest = (cpp_token *) _cpp_pool_alloc (&pfile->argument_pool,\n+\t\t\t\t\ttotal * sizeof (cpp_token));\n+  list->first = dest;\n+  list->limit = list->first + total;\n+\n+  for (src = macro->expansion; src < limit; src++)\n+    if (src->type == CPP_MACRO_ARG)\n+      {\n+\tunsigned int count;\n+\tconst cpp_token *from;\n+\n+\targ = &args[src->val.aux - 1];\n+\tif (src->flags & STRINGIFY_ARG)\n+\t  from = arg->stringified, count = 1;\n+\telse if ((src->flags & PASTE_LEFT)\n+\t\t || (src > macro->expansion && (src[-1].flags & PASTE_LEFT)))\n+\t  count = arg->count, from = arg->first;\n+\telse\n+\t  count = arg->expanded_count, from = arg->expanded;\n+\tmemcpy (dest, from, count * sizeof (cpp_token));\n+\n+\t/* The first token gets PREV_WHITE of the CPP_MACRO_ARG.  If\n+           it is a variable argument, it is also flagged.  */\n+\tdest->flags &= ~PREV_WHITE;\n+\tdest->flags |= src->flags & PREV_WHITE;\n+\tif (macro->var_args && src->val.aux == macro->paramc)\n+\t  dest->flags |= VARARGS_FIRST;\n+\n+\t/* The last token gets the PASTE_LEFT of the CPP_MACRO_ARG.  */\n+\tdest[count - 1].flags |= src->flags & PASTE_LEFT;\n+\n+\tdest += count;\n+      }\n+    else\n+      *dest++ = *src;\n+\n+  /* Free the expanded arguments.  */\n+  for (i = 0; i < macro->paramc; i++)\n     {\n-      if (token->type == CPP_PASTE)\n+      if (args[i].expanded)\n+\tfree (args[i].expanded);\n+      if (args[i].stringified)\n+\tfree (args[i].stringified);\n+    }\n+}\n+\n+/* Subroutine of expand_arg to put the unexpanded tokens on the\n+   context stack.  */\n+static cpp_context *\n+push_arg_context (pfile, arg)\n+     cpp_reader *pfile;\n+     macro_arg *arg;\n+{\n+  cpp_context *context = next_context (pfile);\n+  context->macro = 0;\n+  context->list.first = arg->first;\n+  context->list.limit = arg->first + arg->count;\n+\n+  return context;\n+}\n+\n+static void\n+expand_arg (pfile, arg)\n+     cpp_reader *pfile;\n+     macro_arg *arg;\n+{\n+  cpp_token *token;\n+  unsigned int capacity = 256;\n+\n+  /* Loop, reading in the arguments.  */\n+  arg->expanded = (cpp_token *) xmalloc (capacity * sizeof (cpp_token));\n+  arg->expanded_count = 0;\n+\n+  push_arg_context (pfile, arg);\n+  do\n+    {\n+      if (arg->expanded_count >= capacity)\n \t{\n-\t  /* Token-paste ##, can appear in both object-like and\n-\t     function-like macros, but not at the ends.  Constraint\n-\t     6.10.3.3.1 */\n-\t  if (token == info->first || token[1].type == CPP_EOF)\n+\t  capacity *= 2;\n+\t  arg->expanded = (cpp_token *)\n+\t    xrealloc (arg->expanded, capacity * sizeof (cpp_token));\n+\t}\n+      token = &arg->expanded[arg->expanded_count++];\n+      _cpp_get_token (pfile, token);\n+    }\n+  while (token->type != CPP_EOF);\n+\n+  arg->expanded_count--;\n+\n+  /* Pop the context we pushed.  */ \n+  pfile->context = pfile->context->prev;\n+}\n+\n+void\n+_cpp_pop_context (pfile)\n+     cpp_reader *pfile;\n+{\n+  cpp_context *context = pfile->context;\n+\n+  pfile->context = context->prev;\n+  /* Re-enable a macro and free resources when leaving its expansion.  */\n+  if (!pfile->state.parsing_args)\n+    {\n+      if (!pfile->context->prev)\n+\tunlock_pools (pfile);\n+      context->macro->disabled = 0;\n+    }\n+}\n+\n+/* Internal routine to return a token, either from an in-progress\n+   macro expansion, or from the source file as appropriate.  Handles\n+   macros, so tokens returned are post-expansion.  Does not filter\n+   CPP_PLACEMARKER tokens.  Returns CPP_EOF at EOL and EOF.  */\n+void\n+_cpp_get_token (pfile, token)\n+     cpp_reader *pfile;\n+     cpp_token *token;\n+{\n+  for (;;)\n+    {\n+      cpp_context *context = pfile->context;\n+\n+      if (pfile->la_read)\n+\ttake_lookahead_token (pfile, token);\n+      /* Context->prev == 0 <=> base context.  */\n+      else if (!context->prev)\n+\t_cpp_lex_token (pfile, token);\n+      else if (context->list.first != context->list.limit)\n+\t*token = *context->list.first++;\n+      else\n+\t{\n+\t  if (context->macro)\n \t    {\n-\t      cpp_error_with_line (pfile, token->line, token->col,\n-\t\t\"'##' cannot appear at either end of a macro expansion\");\n-\t      return 1;\n+\t      _cpp_pop_context (pfile);\n+\t      continue;\n \t    }\n+\t  token->type = CPP_EOF;\n+\t  token->flags = 0;\n+\t}\n+      break;\n+    }\n+\n+  /* Only perform macro expansion (and therefore pasting) when not\n+     skipping, or when skipping but in a directive.  The only\n+     directive where this could be true is #elif.  A possible later\n+     optimisation: get do_elif to clear skipping so we don't need the\n+     directive test here.  */\n+  if (pfile->skipping && !pfile->state.in_directive)\n+    return;\n+\n+  for (;;)\n+    {\n+      if (token->flags & PASTE_LEFT)\n+\tpaste_all_tokens (pfile, token);\n+\n+      if (token->type != CPP_NAME\n+\t  || token->val.node->type != NT_MACRO\n+\t  || pfile->state.prevent_expansion\n+\t  || token->flags & NO_EXPAND)\n+\tbreak;\n+\n+      /* Macros, built-in or not, invalidate controlling macros.  */\n+      pfile->mi_state = MI_FAILED;\n+\n+      if (token->val.node->flags & NODE_BUILTIN)\n+\t{\n+\t  builtin_macro (pfile, token);\n+\t  break;\n+\t}\n+      else if (enter_macro_context (pfile, token))\n+\tbreak;\n+    }\n+}\n+\n+/* External interface to get a token.  Tokens are returned after macro\n+   expansion and directives have been handled, as a continuous stream.\n+   Transparently enters included files.  CPP_EOF indicates end of\n+   original source file.  Filters out CPP_PLACEMARKER tokens.\n+\n+   For the benefit of #pragma callbacks which may want to get the\n+   pragma's tokens, returns CPP_EOF to indicate end-of-directive in\n+   this case.  */\n+void\n+cpp_get_token (pfile, token)\n+     cpp_reader *pfile;\n+     cpp_token *token;\n+{\n+  for (;;)\n+    {\n+      _cpp_get_token (pfile, token);\n+\n+      if (token->type == CPP_EOF)\n+\t{\n+\t  /* In directives we should pass through EOLs for the callbacks.  */\n+\t  if (pfile->buffer->cur == pfile->buffer->rlimit\n+\t      || pfile->state.in_directive || pfile->state.parsing_args)\n+\t    break;\n \t  continue;\n \t}\n-      else if (token->type == CPP_HASH)\n+      else if (token->type == CPP_DHASH)\n \t{\n-\t  /* Stringifying #, but a normal character in object-like\n-             macros.  Must come before a parameter name.  Constraint\n-             6.10.3.2.1.  */\n-\t  if (info->paramc >= 0)\n-\t    {\n-\t      if (token[1].type == CPP_NAME\n-\t\t  && find_param (info->first_param, token + 1))\n-\t\tcontinue;\n-\t      if (! CPP_OPTION (pfile, lang_asm))\n-\t\t{\n-\t\t  cpp_error_with_line (pfile, token->line, token->col,\n-\t\t\t       \"'#' is not followed by a macro parameter\");\n-\t\t  return 1;\n-\t\t}\n-\t    }\n+\t  /* Handle directives.  */\n+\t  if (_cpp_handle_directive (pfile, token->flags & PREV_WHITE))\n+\t    continue;\n+\t  /* This is in fact an assembler #.  */\n+\t  if (pfile->skipping)\n+\t    continue;\n+\t  token->type = CPP_HASH;\n \t}\n-      else if (token->type == CPP_NAME)\n+      /* We are not merging the PREV_WHITE of CPP_PLACEMARKERS.  I\n+         don't think it really matters.  */\n+      else if (pfile->skipping || token->type == CPP_PLACEMARKER)\n+\tcontinue;\n+\n+      /* Non-comment tokens invalidate any controlling macros.  */\n+      if (token->type != CPP_COMMENT)\n+\tpfile->mi_state = MI_FAILED;\n+\n+      break;\n+    }\n+\n+  if (pfile->la_write)\n+    save_lookahead_token (pfile, token);\n+}\n+\n+/* Read each token in, until EOF.  Directives are transparently\n+   processed.  */\n+void\n+cpp_scan_buffer_nooutput (pfile)\n+     cpp_reader *pfile;\n+{\n+  cpp_token token;\n+\n+  do\n+    do\n+      cpp_get_token (pfile, &token);\n+    while (token.type != CPP_EOF);\n+  while (cpp_pop_buffer (pfile) != 0);\n+}\n+\n+/* Lookahead handling.  */\n+\n+static void\n+save_lookahead_token (pfile, token)\n+     cpp_reader *pfile;\n+     const cpp_token *token;\n+{\n+  if (token->type != CPP_EOF)\n+    {\n+      cpp_lookahead *la = pfile->la_write;\n+      cpp_token_with_pos *twp;\n+\n+      if (la->count == la->cap)\n \t{\n-\t  /* Constraint 6.10.3.5  */\n-\t  if (!(info->flags & VAR_ARGS) && is__va_args__ (pfile, token))\n-\t    return 1;\n+\t  la->cap += la->cap + 8;\n+\t  la->tokens = (cpp_token_with_pos *)\n+\t    xrealloc (la->tokens, la->cap * sizeof (cpp_token_with_pos));\n \t}\n-      info->ntokens++;\n-      if (TOKEN_SPELL (token) == SPELL_STRING)\n-\tinfo->len += token->val.str.len;\n+\n+      twp = &la->tokens[la->count++];\n+      twp->token = *token;\n+      twp->pos = *cpp_get_line (pfile);\n     }\n-  \n-  return 0;\n }\n \n-/* Returns non-zero if a macro redefinition is trivial.  */\n-static int\n-check_macro_redefinition (pfile, hp, list2)\n+static void\n+take_lookahead_token (pfile, token)\n      cpp_reader *pfile;\n-     cpp_hashnode *hp;\n-     const cpp_toklist *list2;\n+     cpp_token *token;\n {\n-  const cpp_toklist *list1;\n+  cpp_lookahead *la = pfile->la_read;\n+  cpp_token_with_pos *twp = &la->tokens[la->cur];\n \n-  if (hp->type != T_MACRO)\n-    return ! pfile->done_initializing;\n+  *token = twp->token;\n+  pfile->lexer_pos = twp->pos;\n \n-  /* Clear the whitespace and BOL flags of the first tokens.  They get\n-     altered during macro expansion, but is not significant here.  */\n-  list1  = hp->value.expansion;\n-  list1->tokens[0].flags &= ~(PREV_WHITE|BOL);\n-  list2->tokens[0].flags &= ~(PREV_WHITE|BOL);\n+  if (++la->cur == la->count)\n+    release_lookahead (pfile);\n+}\n \n-  if (!_cpp_equiv_toklists (list1, list2))\n-    return 0;\n+/* Moves the lookahead at the front of the read list to the free store.  */\n+static void\n+release_lookahead (pfile)\n+     cpp_reader *pfile;\n+{\n+  cpp_lookahead *la = pfile->la_read;\n \n-  if (CPP_OPTION (pfile, pedantic)\n-      && list1->paramc > 0\n-      && (list1->params_len != list2->params_len\n-\t  || memcmp (list1->namebuf, list2->namebuf, list1->params_len)))\n-    return 0;\n+  pfile->la_read = la->next;\n+  la->next = pfile->la_unused;\n+  pfile->la_unused = la;\n+  unlock_pools (pfile);\n+}\n \n-  return 1;\n+/* Take a new lookahead from the free store, or allocate one if none.  */\n+static cpp_lookahead *\n+alloc_lookahead (pfile)\n+     cpp_reader *pfile;\n+{\n+  cpp_lookahead *la = pfile->la_unused;\n+\n+  if (la)\n+    pfile->la_unused = la->next;\n+  else\n+    {\n+      la = xnew (cpp_lookahead);\n+      la->tokens = 0;\n+      la->cap = 0;\n+    }\n+\n+  la->cur = la->count = 0;\n+  return la;\n }\n \n-/* This is a dummy structure whose only purpose is getting alignment\n-   correct.  */\n-struct toklist_dummy\n+/* Free memory associated with a lookahead list.  */\n+static void\n+free_lookahead (la)\n+     cpp_lookahead *la;\n {\n-  cpp_toklist list;\n-  cpp_token first_token;\n-};\n+  if (la->tokens)\n+    free ((PTR) la->tokens);\n+  free ((PTR) la);\n+}\n \n-/* Allocate space to hold the token list, its tokens, their text, and\n-   the parameter names if needed.  Empty expansions are stored as a\n-   single placemarker token.\n+/* Free all the lookaheads of a cpp_reader.  */\n+void\n+_cpp_free_lookaheads (pfile)\n+     cpp_reader *pfile;\n+{\n+  cpp_lookahead *la, *lan;\n+\n+  if (pfile->la_read)\n+    free_lookahead (pfile->la_read);\n+  if (pfile->la_write)\n+    free_lookahead (pfile->la_write);\n+\n+  for (la = pfile->la_unused; la; la = lan)\n+    {\n+      lan = la->next;\n+      free_lookahead (la);\n+    }\n+}\n \n-   These are all allocated in a block together for performance\n-   reasons.  Therefore, this token list cannot be expanded like a\n-   normal token list.  Try to do so, and you lose.  */\n-static cpp_toklist *\n-alloc_macro (pfile, info)\n+/* Allocate a lookahead and move it to the front of the write list.  */\n+void\n+cpp_start_lookahead (pfile)\n      cpp_reader *pfile;\n-     struct macro_info *info;\n {\n-  unsigned int size;\n-  struct toklist_dummy *dummy;\n-  cpp_toklist *list;\n+  cpp_lookahead *la = alloc_lookahead (pfile);\n \n-  /* Empty macros become a single placemarker token.  */\n-  if (info->ntokens == 0)\n-    info->ntokens = 1;\n+  la->next = pfile->la_write;\n+  pfile->la_write = la;\n \n-  size = sizeof (struct toklist_dummy);\n-  size += (info->ntokens - 1) * sizeof(cpp_token);\n-  size += info->len + info->paramlen;\n+  la->pos = *cpp_get_line (pfile);\n \n-  dummy = (struct toklist_dummy *) xmalloc (size);\n-  list = (cpp_toklist *) dummy;\n-  \n-  /* Initialize the monster.  */\n-  list->tokens = &dummy->first_token;\n-  list->tokens_used = list->tokens_cap = info->ntokens;\n+  /* Don't allow memory pools to be re-used whilst we're reading ahead.  */\n+  lock_pools (pfile);\n+}\n \n-  list->namebuf = (unsigned char *) &list->tokens[info->ntokens];\n-  list->name_used = list->name_cap = info->len + info->paramlen;\n+/* Stop reading ahead - either step back, or drop the read ahead.  */\n+void\n+cpp_stop_lookahead (pfile, drop)\n+     cpp_reader *pfile;\n+     int drop;\n+{\n+  cpp_lookahead *la = pfile->la_write;\n \n-  list->directive = 0;\n-  list->line = pfile->token_list.line;\n-  list->file = pfile->token_list.file;\n-  list->params_len = info->paramlen;\n-  list->paramc = info->paramc;\n-  list->flags = info->flags;\n+  pfile->la_write = la->next;\n+  la->next = pfile->la_read;\n+  pfile->la_read = la;\n \n-  return list;\n+  if (drop || la->count == 0)\n+    release_lookahead (pfile);\n+  else\n+    pfile->lexer_pos = la->pos;\n }\n \n-/* Free the definition of macro H.  */\n+/* Push a single token back to the front of the queue.  Only to be\n+   used by cpplib, and only then when necessary.  POS is the position\n+   to report for the preceding token.  */\n+void\n+_cpp_push_token (pfile, token, pos)\n+     cpp_reader *pfile;\n+     const cpp_token *token;\n+     const cpp_lexer_pos *pos;\n+{\n+  cpp_start_lookahead (pfile);\n+  save_lookahead_token (pfile, token);\n+  cpp_stop_lookahead (pfile, 0);\n+  pfile->lexer_pos = *pos;\n+}\n+\n+/* #define directive parsing and handling.  */\n+\n+/* Returns non-zero if a macro redefinition is trivial.  */\n+static int\n+check_macro_redefinition (pfile, node, macro2)\n+     cpp_reader *pfile;\n+     const cpp_hashnode *node;\n+     const cpp_macro *macro2;\n+{\n+  const cpp_macro *macro1;\n+  unsigned int i;\n+\n+  if (node->type != NT_MACRO || node->flags & NODE_BUILTIN)\n+    return ! pfile->done_initializing;\n+\n+  macro1 = node->value.macro;\n+\n+  /* The quick failures.  */\n+  if (macro1->count != macro2->count\n+      || macro1->paramc != macro2->paramc\n+      || macro1->fun_like != macro2->fun_like\n+      || macro1->var_args != macro2->var_args)\n+    return 0;\n+\n+  /* Check each token.  */\n+  for (i = 0; i < macro1->count; i++)\n+    if (! _cpp_equiv_tokens (&macro1->expansion[i], &macro2->expansion[i]))\n+      return 0;\n+\n+  /* Check parameter spellings.  */\n+  for (i = 0; i < macro1->paramc; i++)\n+    if (macro1->params[i] != macro2->params[i])\n+      return 0;\n+\n+  return 1;\n+}\n+\n+/* Free the definition of hashnode H.  */\n \n void\n _cpp_free_definition (h)\n      cpp_hashnode *h;\n {\n-  if (h->type == T_MACRO)\n-    free ((PTR) h->value.expansion);\n-  else if (h->type == T_ASSERTION)\n+  /* Macros and assertions no longer have anything to free.  */\n+  h->type = NT_VOID;\n+  /* Clear builtin flag in case of redefinition.  */\n+  h->flags &= ~NODE_BUILTIN;\n+}\n+\n+static int\n+save_parameter (pfile, macro, node)\n+     cpp_reader *pfile;\n+     cpp_macro *macro;\n+     cpp_hashnode *node;\n+{\n+  cpp_hashnode **dest;\n+\n+  /* Constraint 6.10.3.6 - duplicate parameter names.  */\n+  if (node->arg_index)\n     {\n-      struct answer *temp, *next;\n+      cpp_error (pfile, \"duplicate macro parameter \\\"%s\\\"\", node->name);\n+      return 1;\n+    }\n \n-      for (temp = h->value.answers; temp; temp = next)\n-\t{\n-\t  next = temp->next;\n-\t  FREE_ANSWER (temp);\n-\t}\n+  dest = &macro->params[macro->paramc];\n+\n+  /* Check we have room for the parameters.  */\n+  if ((unsigned char *) (dest + 1) >= POOL_LIMIT (&pfile->macro_pool))\n+    {\n+      _cpp_next_chunk (&pfile->macro_pool, sizeof (cpp_hashnode *),\n+\t\t       (unsigned char **) &macro->params);\n+      dest = &macro->params[macro->paramc];\n     }\n \n-  h->type = T_VOID;\n-  h->value.expansion = NULL;\n+  *dest = node;\n+  node->arg_index = ++macro->paramc;\n+  return 0;\n }\n \n-/* Copy the tokens of the expansion, beginning with info->first until\n-   CPP_EOF.  INFO contains information about the macro.\n-\n-   Change the type of macro arguments in the expansion from CPP_NAME\n-   to CPP_MACRO_ARG.  Remove #'s that represent stringification,\n-   flagging the CPP_MACRO_ARG it operates on STRINGIFY.  Remove ##'s,\n-   flagging the token on its immediate left PASTE_LEFT.  Returns the\n-   token list for the macro expansion.  */\n-static const cpp_toklist *\n-save_expansion (pfile, info)\n+static int\n+parse_params (pfile, macro)\n      cpp_reader *pfile;\n-     struct macro_info *info;\n+     cpp_macro *macro;\n {\n-  const cpp_token *token;\n-  cpp_toklist *list;\n-  cpp_token *dest;\n-  unsigned char *buf;\n-      \n-  list = alloc_macro (pfile, info);\n-  buf = list->namebuf;\n-\n-  /* Store the null-terminated parameter spellings of a macro, to\n-     provide pedantic warnings to satisfy 6.10.3.2, or for use when\n-     dumping macro definitions.  They must go first.  */\n-  if (list->params_len)\n-    for (token = info->first_param; token < info->first; token++)\n-      if (token->type == CPP_NAME || token->type == CPP_DEFINED)\n-\t{\n-\t  /* Copy null too.  */\n-\t  memcpy (buf, token->val.node->name, token->val.node->length + 1);\n-\t  buf += token->val.node->length + 1;\n-\t}\n+  cpp_token token;\n+  unsigned int prev_ident = 0;\n \n-  dest = list->tokens;\n-  for (token = info->first; token->type != CPP_EOF; token++)\n+  macro->params = (cpp_hashnode **) POOL_FRONT (&pfile->macro_pool);\n+  for (;;)\n     {\n-      unsigned int param_no;\n+      _cpp_lex_token (pfile, &token);\n \n-      switch (token->type)\n+      switch (token.type)\n \t{\n-\tcase CPP_DEFINED:\n+\tdefault:\n+\t  cpp_error (pfile, \"\\\"%s\\\" may not appear in macro parameter list\",\n+\t\t     cpp_token_as_text (pfile, &token));\n+\t  return 0;\n+\n \tcase CPP_NAME:\n-\t  if (list->paramc == -1)\n-\t    break;\n+\t  if (prev_ident)\n+\t    {\n+\t      cpp_error (pfile, \"macro parameters must be comma-separated\");\n+\t      return 0;\n+\t    }\n+\t  prev_ident = 1;\n+\n+\t  if (save_parameter (pfile, macro, token.val.node))\n+\t    return 0;\n+\t  continue;\n \n-\t  /* Check if the name is a macro parameter.  */\n-\t  param_no = find_param (info->first_param, token);\n-\t  if (param_no == 0)\n+\tcase CPP_CLOSE_PAREN:\n+\t  if (prev_ident || macro->paramc == 0)\n \t    break;\n-\t  dest->val.aux = param_no - 1;\n \n-\t  dest->type = CPP_MACRO_ARG;\n-\t  if (token[-1].type == CPP_HASH)\n-\t    dest->flags = token[-1].flags | STRINGIFY_ARG;\n-\t  else\n-\t    dest->flags = token->flags;  /* Particularly PREV_WHITE.  */\n-\t  /* Turn off PREV_WHITE if we immediately follow a paste.\n-\t     That way, even if the paste turns out to be invalid, there\n-\t     will be no space between the two tokens in the output.  */\n-\t  if (token[-1].type == CPP_PASTE)\n-\t    dest->flags &= ~PREV_WHITE;\n-\t  dest++;\n+\t  /* Fall through to pick up the error.  */\n+\tcase CPP_COMMA:\n+\t  if (!prev_ident)\n+\t    {\n+\t      cpp_error (pfile, \"parameter name missing\");\n+\t      return 0;\n+\t    }\n+\t  prev_ident = 0;\n \t  continue;\n \n-\tcase CPP_PASTE:\n-\t  /* Set the paste flag on the token to our left, unless there\n-\t     is no possible token to which it might be pasted.  That\n-\t     is critical for correct operation under some circumstances;\n-\t     see gcc.dg/cpp/paste6.c. */\n-\t  if (CAN_PASTE_AFTER (dest[-1].type) || (dest[-1].flags & NAMED_OP))\n-\t    dest[-1].flags |= PASTE_LEFT;\n-\t  else if (CPP_OPTION (pfile, warn_paste))\n-\t    cpp_warning_with_line (pfile, dest[-1].line, dest[-1].col,\n-\t\t\t\t   \"nothing can be pasted after this token\");\n-\t  continue;\n+\tcase CPP_ELLIPSIS:\n+\t  macro->var_args = 1;\n+\t  if (!prev_ident)\n+\t    {\n+\t      save_parameter (pfile, macro, pfile->spec_nodes.n__VA_ARGS__);\n+\t      pfile->state.va_args_ok = 1;\n+\t      if (! CPP_OPTION (pfile, c99) && CPP_OPTION (pfile, pedantic))\n+\t\tcpp_pedwarn (pfile,\n+\t\t     \"C89 does not permit anonymous variable arguments\");\n+\t    }\n+\t  else if (CPP_OPTION (pfile, pedantic))\n+\t    cpp_pedwarn (pfile,\n+\t\t\t \"ISO C does not permit named variable arguments\");\n \n-\tcase CPP_HASH:\n-\t  /* Stringifying #.  Constraint 6.10.3.2.1  */\n-\t  if (list->paramc >= 0 && token[1].type == CPP_NAME\n-\t      && find_param (info->first_param, token + 1))\n-\t    continue;\n-\t  break;\n+\t  /* We're at the end, and just expect a closing parenthesis.  */\n+\t  _cpp_lex_token (pfile, &token);\n+\t  if (token.type == CPP_CLOSE_PAREN)\n+\t    break;\n+\t  /* Fall through.  */\n \n-\tcase CPP_STRING:\n-\tcase CPP_CHAR:\n-\t  if (CPP_WTRADITIONAL (pfile) && list->paramc > 0)\n-\t    check_trad_stringification (pfile, info, &token->val.str);\n-\t  break;\n-\t  \n-\tdefault:\n-\t  break;\n+\tcase CPP_EOF:\n+\t  cpp_error (pfile, \"missing ')' in macro parameter list\");\n+\t  return 0;\n \t}\n \n-      /* Copy the token.  */\n-      *dest = *token;\n-      if (TOKEN_SPELL (token) == SPELL_STRING)\n-\t{\n-\t  memcpy (buf, token->val.str.text, token->val.str.len);\n-\t  dest->val.str.text = buf;\n-\t  buf += dest->val.str.len;\n-\t}\n-      if (token[-1].type == CPP_PASTE)\n-\tdest->flags &= ~PREV_WHITE;\n-      dest++;\n+      /* Success.  Commit the parameter array.  */\n+      POOL_COMMIT (&pfile->macro_pool,\n+\t\t   macro->paramc * sizeof (cpp_hashnode *));\n+      return 1;\n     }\n+}\n+\n+/* Lex a token from a macro's replacement list.  Translate it to a\n+   CPP_MACRO_ARG if appropriate.  */\n+static cpp_token *\n+lex_expansion_token (pfile, macro)\n+     cpp_reader *pfile;\n+     cpp_macro *macro;\n+{\n+  cpp_token *token = &macro->expansion[macro->count];\n \n-  /* Empty macros become a single placemarker token.  */\n-  if (dest == list->tokens)\n+  /* Check we have room for the token.  */\n+  if ((unsigned char *) (token + 1) >= POOL_LIMIT (&pfile->macro_pool))\n     {\n-      dest->type = CPP_PLACEMARKER;\n-      dest->flags = 0;\n-      dest->val.aux = 0;\n+      _cpp_next_chunk (&pfile->macro_pool, sizeof (cpp_token),\n+\t\t       (unsigned char **) &macro->expansion);\n+      token = &macro->expansion[macro->count];\n     }\n \n-  return list;\n+  macro->count++;\n+  _cpp_lex_token (pfile, token);\n+\n+  /* Is this an argument?  */\n+  if (token->type == CPP_NAME && token->val.node->arg_index)\n+    {\n+      token->type = CPP_MACRO_ARG;\n+      token->val.aux = token->val.node->arg_index;\n+    }\n+  else if (CPP_WTRADITIONAL (pfile) && macro->paramc > 0\n+\t   && (token->type == CPP_STRING || token->type == CPP_CHAR))\n+    check_trad_stringification (pfile, macro, &token->val.str);\n+\n+  return token;\n }\n \n /* Parse a macro and save its expansion.  Returns non-zero on success.  */\n int\n-_cpp_create_definition (pfile, hp)\n+_cpp_create_definition (pfile, node)\n      cpp_reader *pfile;\n-     cpp_hashnode *hp;\n+     cpp_hashnode *node;\n {\n-  struct macro_info info;\n-  const cpp_toklist *list;\n+  cpp_macro *macro;\n+  cpp_token *token;\n+  unsigned int i, ok = 1;\n+\n+  macro = (cpp_macro *) _cpp_pool_alloc (&pfile->macro_pool,\n+\t\t\t\t\t sizeof (cpp_macro));\n+  macro->file = pfile->buffer->nominal_fname;\n+  macro->line = pfile->directive_pos.line;\n+  macro->params = 0;\n+  macro->paramc = 0;\n+  macro->fun_like = 0;\n+  macro->var_args = 0;\n+  macro->disabled = 0;\n+  macro->count = 0;\n+  macro->expansion = (cpp_token *) POOL_FRONT (&pfile->macro_pool);\n+\n+  /* Get the first token of the expansion (or the '(' of a\n+     function-like macro).  */\n+  token = lex_expansion_token (pfile, macro);\n+  if (token->type == CPP_OPEN_PAREN && !(token->flags & PREV_WHITE))\n+    {\n+      if (!(ok = parse_params (pfile, macro)))\n+\tgoto cleanup;\n+      macro->count = 0;\n+      macro->fun_like = 1;\n+      /* Some of the pool may have been used for the parameter store.  */\n+      macro->expansion = (cpp_token *) POOL_FRONT (&pfile->macro_pool);\n+      token = lex_expansion_token (pfile, macro);\n+    }\n+  else if (token->type != CPP_EOF && !(token->flags & PREV_WHITE))\n+    cpp_pedwarn (pfile, \"ISO C requires whitespace after the macro name\");\n \n-  if (parse_define (pfile, &info))\n-    return 0;\n-  list = save_expansion (pfile, &info);\n+  /* Setting it here means we don't catch leading comments.  */\n+  pfile->state.save_comments = ! CPP_OPTION (pfile, discard_comments);\n \n-  /* Check for a redefinition.  Redefinition of a macro is allowed if\n-     and only if the old and new definitions are the same.\n-     (6.10.3 paragraph 2). */\n+  for (;;)\n+    {\n+      /* Check the stringifying # constraint 6.10.3.2.1 of\n+\t function-like macros when lexing the subsequent token.  */\n+      if (macro->count > 1 && token[-1].type == CPP_HASH && macro->fun_like)\n+\t{\n+\t  if (token->type == CPP_MACRO_ARG)\n+\t    {\n+\t      token->flags &= ~PREV_WHITE;\n+\t      token->flags |= STRINGIFY_ARG;\n+\t      token->flags |= token[-1].flags & PREV_WHITE;\n+\t      token[-1] = token[0];\n+\t      macro->count--;\n+\t    }\n+\t  /* Let assembler get away with murder.  */\n+\t  else if (!CPP_OPTION (pfile, lang_asm))\n+\t    {\n+\t      ok = 0;\n+\t      cpp_error (pfile, \"'#' is not followed by a macro parameter\");\n+\t      goto cleanup;\n+\t    }\n+\t}\n+\n+      if (token->type == CPP_EOF)\n+\tbreak;\n+\n+      /* Paste operator constraint 6.10.3.3.1.  */\n+      if (token->type == CPP_PASTE)\n+\t{\n+\t  /* Token-paste ##, can appear in both object-like and\n+\t     function-like macros, but not at the ends.  */\n+\t  if (--macro->count > 0)\n+\t    token = lex_expansion_token (pfile, macro);\n+\n+\t  if (macro->count == 0 || token->type == CPP_EOF)\n+\t    {\n+\t      ok = 0;\n+\t      cpp_error (pfile,\n+\t\t\t \"'##' cannot appear at either end of a macro expansion\");\n+\t      goto cleanup;\n+\t    }\n \n-  if (hp->type != T_VOID)\n+\t  token[-1].flags |= PASTE_LEFT;\n+\t  /* Give it a PREV_WHITE for -dM etc.  */\n+\t  token->flags |= PREV_WHITE;\n+\t}\n+\n+      token = lex_expansion_token (pfile, macro);\n+    }\n+\n+  /* Don't count the CPP_EOF.  Empty macros become a place marker.  */\n+  if (macro->count > 1)\n+    macro->count--;\n+  else\n+    macro->expansion[0].type = CPP_PLACEMARKER;\n+\n+  /* Clear the whitespace flag from the leading token.  */\n+  macro->expansion[0].flags &= ~PREV_WHITE;\n+\n+  /* Commit the memory.  */\n+  POOL_COMMIT (&pfile->macro_pool, macro->count * sizeof (cpp_token));\n+\n+  /* Redefinition of a macro is allowed if and only if the old and new\n+     definitions are the same.  (6.10.3 paragraph 2). */\n+  if (node->type != NT_VOID)\n     {\n-      if (!check_macro_redefinition (pfile, hp, list))\n+      if (CPP_PEDANTIC (pfile)\n+\t  && !check_macro_redefinition (pfile, node, macro))\n \t{\n-\t  cpp_pedwarn (pfile, \"\\\"%s\\\" redefined\", hp->name);\n-\t  if (pfile->done_initializing && hp->type == T_MACRO)\n+\t  cpp_pedwarn_with_line (pfile, pfile->directive_pos.line,\n+\t\t\t\t pfile->directive_pos.col,\n+\t\t\t\t \"\\\"%s\\\" redefined\", node->name);\n+\n+\t  if (pfile->done_initializing && node->type == NT_MACRO\n+\t      && !(node->flags & NODE_BUILTIN))\n \t    cpp_pedwarn_with_file_and_line (pfile,\n-\t\t\t\t\t    hp->value.expansion->file,\n-\t\t\t\t\t    hp->value.expansion->line, 1,\n+\t\t\t\t\t    node->value.macro->file,\n+\t\t\t\t\t    node->value.macro->line, 1,\n \t\t\t    \"this is the location of the previous definition\");\n \t}\n-      _cpp_free_definition (hp);\n+      _cpp_free_definition (node);\n     }\n \n   /* Enter definition in hash table.  */\n-  hp->type = T_MACRO;\n-  hp->value.expansion = list;\n+  node->type = NT_MACRO;\n+  node->value.macro = macro;\n \n-  return 1;\n+ cleanup:\n+\n+  /* Stop the lexer accepting __VA_ARGS__.  */\n+  pfile->state.va_args_ok = 0;\n+\n+  /* Clear the fast argument lookup indices.  */\n+  for (i = macro->paramc; i-- > 0; )\n+    macro->params[i]->arg_index = 0;\n+\n+  return ok;\n }\n \n /* Warn if a token in `string' matches one of the function macro\n    arguments in `info'.  This function assumes that the macro is a\n    function macro and not an object macro.  */\n static void\n-check_trad_stringification (pfile, info, string)\n+check_trad_stringification (pfile, macro, string)\n      cpp_reader *pfile;\n-     const struct macro_info *info;\n+     const cpp_macro *macro;\n      const cpp_string *string;\n {\n+  unsigned int i, len;\n   const U_CHAR *p, *q, *limit = string->text + string->len;\n   \n   /* Loop over the string.  */\n   for (p = string->text; p < limit; p = q)\n     {\n-      const cpp_token *token;\n-\n       /* Find the start of an identifier.  */\n       while (p < limit && !is_idstart (*p))\n \tp++;\n@@ -600,23 +1548,130 @@ check_trad_stringification (pfile, info, string)\n       q = p;\n       while (q < limit && is_idchar (*q))\n \tq++;\n-     \n+\n+      len = q - p;\n+\n       /* Loop over the function macro arguments to see if the\n \t identifier inside the string matches one of them.  */\n-      for (token = info->first_param; token < info->first; token++)\n-        {\n-\t  /* Skip the commas in between the arguments.  */\n-\t  if (token->type != CPP_NAME)\n-\t    continue;\n+      for (i = 0; i < macro->paramc; i++)\n+\t{\n+\t  const cpp_hashnode *node = macro->params[i];\n \n-\t  if (token->val.node->length == (q - p)\n-\t      && !memcmp (p, token->val.node->name, (q - p)))\n+\t  if (node->length == len && !memcmp (p, node->name, len))\n \t    {\n \t      cpp_warning (pfile,\n-\t\t\t   \"macro arg \\\"%.*s\\\" would be stringified with -traditional.\",\n-\t\t\t   (int) (q - p), p);\n+\t   \"macro argument \\\"%s\\\" would be stringified with -traditional.\",\n+\t\t\t   node->name);\n \t      break;\n \t    }\n \t}\n     }\n }\n+\n+/* Returns the expansion of a macro, in a format suitable to be read\n+   back in again, and therefore also for DWARF 2 debugging info.\n+   Caller is expected to generate the \"#define NAME\" bit.  The\n+   returned text is temporary, and automatically freed later.  */\n+\n+const unsigned char *\n+cpp_macro_definition (pfile, node)\n+     cpp_reader *pfile;\n+     const cpp_hashnode *node;\n+{\n+  unsigned int i, len;\n+  const cpp_macro *macro = node->value.macro;\n+  unsigned char *buffer;\n+\n+  if (node->type != NT_MACRO || (node->flags & NODE_BUILTIN))\n+    {\n+      cpp_ice (pfile, \"invalid hash type %d in dump_definition\", node->type);\n+      return 0;\n+    }\n+\n+  /* Calculate length.  */\n+  len = 1;\t\t\t/* ' ' */\n+  if (macro->fun_like)\n+    {\n+      len += 3;\t\t/* \"()\" plus possible final \".\" of ellipsis.  */\n+      for (i = 0; i < macro->paramc; i++)\n+\tlen += macro->params[i]->length + 2; /* \", \" */\n+    }\n+\n+  if (macro->count > 1 || macro->expansion[0].type != CPP_PLACEMARKER)\n+    {\n+      for (i = 0; i < macro->count; i++)\n+\t{\n+\t  cpp_token *token = &macro->expansion[i];\n+\n+\t  if (token->type == CPP_MACRO_ARG)\n+\t    len += macro->params[token->val.aux - 1]->length;\n+\t  else\n+\t    len += cpp_token_len (token); /* Includes room for ' '.  */\n+\t  if (token->flags & STRINGIFY_ARG)\n+\t    len++;\t\t\t/* \"#\" */\n+\t  if (token->flags & PASTE_LEFT)\n+\t    len += 3;\t\t/* \" ##\" */\n+\t}\n+    }\n+\n+  if (len > pfile->macro_buffer_len)\n+    pfile->macro_buffer = (U_CHAR *) xrealloc (pfile->macro_buffer, len);\n+  buffer = pfile->macro_buffer;\n+\n+  /* Parameter names.  */\n+  if (macro->fun_like)\n+    {\n+      *buffer++ = '(';\n+      for (i = 0; i < macro->paramc; i++)\n+\t{\n+\t  cpp_hashnode *param = macro->params[i];\n+\n+\t  if (param != pfile->spec_nodes.n__VA_ARGS__)\n+\t    {\n+\t      memcpy (buffer, param->name, param->length);\n+\t      buffer += param->length;\n+\t    }\n+\n+\t  if (i + 1 < macro->paramc)\n+\t    *buffer++ = ',', *buffer++ = ' ';\n+\t  else if (macro->var_args)\n+\t    *buffer++ = '.', *buffer++ = '.', *buffer++ = '.';\n+\t}\n+      *buffer++ = ')';\n+    }\n+\n+  /* Expansion tokens.  */\n+  if (macro->count > 1 || macro->expansion[0].type != CPP_PLACEMARKER)\n+    {\n+      *buffer++ = ' ';\n+      for (i = 0; i < macro->count; i++)\n+\t{\n+\t  cpp_token *token = &macro->expansion[i];\n+\n+\t  if (token->flags & PREV_WHITE)\n+\t    *buffer++ = ' ';\n+\t  if (token->flags & STRINGIFY_ARG)\n+\t    *buffer++ = '#';\n+\n+\t  if (token->type == CPP_MACRO_ARG)\n+\t    {\n+\t      len = macro->params[token->val.aux - 1]->length;\n+\t      memcpy (buffer, macro->params[token->val.aux - 1]->name, len);\n+\t      buffer += len;\n+\t    }\n+\t  else\n+\t    buffer = cpp_spell_token (pfile, token, buffer);\n+\n+\t  if (token->flags & PASTE_LEFT)\n+\t    {\n+\t      *buffer++ = ' ';\n+\t      *buffer++ = '#';\n+\t      *buffer++ = '#';\n+\t      /* Next has PREV_WHITE; see _cpp_create_definition.  */\n+\t    }\n+\t}\n+    }\n+\n+  *buffer = '\\0';\n+  return pfile->macro_buffer;\n+}"}, {"sha": "fc58f6a9d00b7c55d4f80f4398e8d85b7eee984c", "filename": "gcc/cppmain.c", "status": "modified", "additions": 252, "deletions": 105, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c80368d9a16c073f2b930bef4232661971765f/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c80368d9a16c073f2b930bef4232661971765f/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=93c80368d9a16c073f2b930bef4232661971765f", "patch": "@@ -25,29 +25,45 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #include \"cpplib.h\"\n #include \"intl.h\"\n \n-const char *progname;\n-\n-cpp_reader parse_in;\n-cpp_printer parse_out;\n+/* Encapsulates state used to convert the stream of tokens coming from\n+   cpp_get_token back into a text file.  */\n+struct printer\n+{\n+  FILE *outf;\t\t\t/* stream to write to.  */\n+  const char *last_fname;\t/* previous file name.  */\n+  const char *syshdr_flags;\t/* system header flags, if any.  */\n+  unsigned int lineno;\t\t/* line currently being written.  */\n+  unsigned char printed;\t/* nonzero if something output at lineno.  */\n+  unsigned char no_line_dirs;\t/* nonzero to output no line directives.  */\n+};\n \n int main\t\tPARAMS ((int, char **));\n \n+/* General output routines.  */\n+static void scan_buffer\tPARAMS ((cpp_reader *));\n+static int printer_init PARAMS ((cpp_reader *));\n+static int dump_macro PARAMS ((cpp_reader *, cpp_hashnode *));\n+\n+static void print_line PARAMS ((const char *));\n+static void maybe_print_line PARAMS ((unsigned int));\n+static void move_printer PARAMS ((cpp_reader *, unsigned int, const char *));\n+\n /* Callback routines for the parser.   Most of these are active only\n    in specific modes.  */\n static void cb_define\tPARAMS ((cpp_reader *, cpp_hashnode *));\n static void cb_undef\tPARAMS ((cpp_reader *, cpp_hashnode *));\n static void cb_include\tPARAMS ((cpp_reader *, const unsigned char *,\n-\t\t\t\t const unsigned char *, unsigned int, int));\n-\n-static void cb_ident\t  PARAMS ((cpp_reader *, const unsigned char *,\n-\t\t\t\t   unsigned int));\n+\t\t\t\t const cpp_token *));\n+static void cb_ident\t  PARAMS ((cpp_reader *, const cpp_string *));\n static void cb_enter_file PARAMS ((cpp_reader *));\n static void cb_leave_file PARAMS ((cpp_reader *));\n static void cb_rename_file PARAMS ((cpp_reader *));\n static void cb_def_pragma PARAMS ((cpp_reader *));\n-\n static void do_pragma_implementation PARAMS ((cpp_reader *));\n-static int dump_macros_helper PARAMS ((cpp_reader *, cpp_hashnode *));\n+\n+const char *progname;\n+cpp_reader parse_in;\n+struct printer print;\n \n int\n main (argc, argv)\n@@ -56,7 +72,6 @@ main (argc, argv)\n {\n   char *p;\n   cpp_reader *pfile = &parse_in;\n-  cpp_printer *print;\n   int argi = 1;  /* Next argument to handle.  */\n \n   p = argv[0] + strlen (argv[0]);\n@@ -83,8 +98,7 @@ main (argc, argv)\n   /* Open the output now.  We must do so even if no_output is on,\n      because there may be other output than from the actual\n      preprocessing (e.g. from -dM).  */\n-  print = cpp_printer_init (pfile, &parse_out);\n-  if (! print)\n+  if (printer_init (pfile))\n     return (FATAL_EXIT_CODE);\n \n   /* Set callbacks.  */\n@@ -116,134 +130,260 @@ main (argc, argv)\n   cpp_register_pragma(pfile, 0, \"implementation\", do_pragma_implementation);\n   cpp_register_pragma(pfile, \"GCC\", \"implementation\", do_pragma_implementation);\n \n-  if (! cpp_start_read (pfile, print, CPP_OPTION (pfile, in_fname)))\n+  if (! cpp_start_read (pfile, CPP_OPTION (pfile, in_fname)))\n     return (FATAL_EXIT_CODE);\n \n-  if (CPP_OPTION (pfile, no_output))\n-    while (CPP_BUFFER (pfile) != NULL)\n-      cpp_scan_buffer_nooutput (pfile);\n-  else\n-    while (CPP_BUFFER (pfile) != NULL)\n-      cpp_scan_buffer (pfile, print);\n+  if (CPP_BUFFER (pfile))\n+    {\n+      if (CPP_OPTION (pfile, no_output))\n+\tcpp_scan_buffer_nooutput (pfile);\n+      else\n+\tscan_buffer (pfile);\n+    }\n \n+  /* -dM command line option.  */\n   if (CPP_OPTION (pfile, dump_macros) == dump_only)\n-    cpp_forall_identifiers (pfile, dump_macros_helper);\n-  \n-  cpp_finish (pfile, print);\n+    cpp_forall_identifiers (pfile, dump_macro);\n+\n+  cpp_finish (pfile);\n   cpp_cleanup (pfile);\n \n+  /* Flush any pending output.  */\n+  if (print.printed)\n+    putc ('\\n', print.outf);\n+  if (ferror (print.outf) || fclose (print.outf))\n+    cpp_notice_from_errno (pfile, CPP_OPTION (pfile, out_fname));\n+\n   if (parse_in.errors)\n     return (FATAL_EXIT_CODE);\n   return (SUCCESS_EXIT_CODE);\n }\n \n-/* Callbacks */\n+/* Writes out the preprocessed file.  Alternates between two tokens,\n+   so that we can avoid accidental token pasting.  */\n+static void\n+scan_buffer (pfile)\n+     cpp_reader *pfile;\n+{\n+  unsigned int index, line;\n+  cpp_token tokens[2], *token;\n \n+  do\n+    {\n+      for (index = 0;; index = 1 - index)\n+\t{\n+\t  token = &tokens[index];\n+\t  cpp_get_token (pfile, token);\n+\n+\t  if (token->type == CPP_EOF)\n+\t    break;\n+\n+\t  line = cpp_get_line (pfile)->output_line;\n+\t  if (print.lineno != line)\n+\t    {\n+\t      unsigned int col = cpp_get_line (pfile)->col;\n+\n+\t      /* Supply enough whitespace to put this token in its original\n+\t\t column.  Don't bother trying to reconstruct tabs; we can't\n+\t\t get it right in general, and nothing ought to care.  (Yes,\n+\t\t some things do care; the fault lies with them.)  */\n+\t      maybe_print_line (line);\n+\t      if (col > 1)\n+\t\t{\n+\t\t  if (token->flags & PREV_WHITE)\n+\t\t    col--;\n+\t\t  while (--col)\n+\t\t    putc (' ', print.outf);\n+\t\t}\n+\t    }\n+\t  else if (print.printed && ! (token->flags & PREV_WHITE)\n+\t\t   && cpp_avoid_paste (pfile, &tokens[1 - index], token))\n+\t    token->flags |= PREV_WHITE;\n+\n+\t  cpp_output_token (token, print.outf);\n+\t  print.printed = 1;\n+\t}\n+    }\n+  while (cpp_pop_buffer (pfile) != 0);\n+}\n+\n+/* Initialize a cpp_printer structure.  As a side effect, open the\n+   output file.  */\n+static int\n+printer_init (pfile)\n+     cpp_reader *pfile;\n+{\n+  print.last_fname = 0;\n+  print.lineno = 0;\n+  print.printed = 0;\n+  print.no_line_dirs = CPP_OPTION (pfile, no_line_commands);\n+\n+  if (CPP_OPTION (pfile, out_fname) == NULL)\n+    CPP_OPTION (pfile, out_fname) = \"\";\n+  \n+  if (CPP_OPTION (pfile, out_fname)[0] == '\\0')\n+    print.outf = stdout;\n+  else\n+    {\n+      print.outf = fopen (CPP_OPTION (pfile, out_fname), \"w\");\n+      if (! print.outf)\n+\t{\n+\t  cpp_notice_from_errno (pfile, CPP_OPTION (pfile, out_fname));\n+\t  return 1;\n+\t}\n+    }\n+  return 0;\n+}\n+\n+/* Newline-terminate any output line currently in progress.  If\n+   appropriate, write the current line number to the output, or pad\n+   with newlines so the output line matches the current line.  */\n static void\n-cb_ident (pfile, str, len)\n+maybe_print_line (line)\n+     unsigned int line;\n+{\n+  /* End the previous line of text (probably only needed until we get\n+     multi-line tokens fixed).  */\n+  if (print.printed)\n+    {\n+      putc ('\\n', print.outf);\n+      print.lineno++;\n+      print.printed = 0;\n+    }\n+\n+  if (print.no_line_dirs)\n+    return;\n+\n+  if (line >= print.lineno && line < print.lineno + 8)\n+    {\n+      while (line > print.lineno)\n+\t{\n+\t  putc ('\\n', print.outf);\n+\t  print.lineno++;\n+\t}\n+    }\n+  else\n+    {\n+      print.lineno = line;\n+      print_line (\"\");\n+    }\n+}\n+\n+static void\n+print_line (special_flags)\n+  const char *special_flags;\n+{\n+  /* End any previous line of text.  */\n+  if (print.printed)\n+    putc ('\\n', print.outf);\n+  print.printed = 0;\n+\n+  fprintf (print.outf, \"# %u \\\"%s\\\"%s%s\\n\",\n+\t   print.lineno, print.last_fname, special_flags, print.syshdr_flags);\n+}\n+\n+static void\n+move_printer (pfile, line, special_flags)\n      cpp_reader *pfile;\n-     const unsigned char *str;\n-     unsigned int len;\n+     unsigned int line;\n+     const char *special_flags;\n+{\n+  print.lineno = line;\n+  print.last_fname = pfile->buffer->nominal_fname;\n+  print.syshdr_flags = cpp_syshdr_flags (pfile, pfile->buffer);\n+  print_line (special_flags);\n+}\n+\n+/* Callbacks */\n+\n+static void\n+cb_ident (pfile, str)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+     const cpp_string * str;\n {\n-  cpp_printf (pfile, &parse_out, \"#ident \\\"%.*s\\\"\\n\", (int) len, str);\n-  parse_out.lineno++;\n+  maybe_print_line (cpp_get_line (pfile)->output_line);\n+  fprintf (print.outf, \"#ident \\\"%.*s\\\"\\n\", (int) str->len, str->text);\n+  print.lineno++;\n }\n \n static void\n-cb_define (pfile, hash)\n+cb_define (pfile, node)\n      cpp_reader *pfile;\n-     cpp_hashnode *hash;\n+     cpp_hashnode *node;\n {\n   if (pfile->done_initializing)\n     {\n-      cpp_printf (pfile, &parse_out, \"#define %s\", hash->name);\n+      maybe_print_line (cpp_get_line (pfile)->output_line);\n+      fprintf (print.outf, \"#define %s\", node->name);\n+\n+      /* -dD or -g3 command line options.  */\n       if (CPP_OPTION (pfile, debug_output)\n \t  || CPP_OPTION (pfile, dump_macros) == dump_definitions)\n-\tcpp_dump_definition (pfile, parse_out.outf, hash);\n-      putc ('\\n', parse_out.outf);\n-      parse_out.lineno++;\n+\tfputs ((const char *) cpp_macro_definition (pfile, node), print.outf);\n+\n+      putc ('\\n', print.outf);\n+      print.lineno++;\n     }\n }\n \n static void\n-cb_undef (pfile, hash)\n+cb_undef (pfile, node)\n      cpp_reader *pfile;\n-     cpp_hashnode *hash;\n+     cpp_hashnode *node;\n {\n   if (pfile->done_initializing)\n     {\n-      cpp_printf (pfile, &parse_out, \"#undef %s\\n\", hash->name);\n-      parse_out.lineno++;\n+      maybe_print_line (cpp_get_line (pfile)->output_line);\n+      fprintf (print.outf, \"#undef %s\\n\", node->name);\n+      print.lineno++;\n     }\n }\n \n static void\n-cb_include (pfile, dir, str, len, ab)\n-     cpp_reader *pfile;\n+cb_include (pfile, dir, header)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n      const unsigned char *dir;\n-     const unsigned char *str;\n-     unsigned int len;\n-     int ab;\n+     const cpp_token *header;\n {\n-  int l, r;\n-  if (ab)\n-    l = '<', r = '>';\n-  else\n-    l = '\"', r = '\"';\n-\n-  cpp_printf (pfile, &parse_out, \"#%s %c%.*s%c\\n\", dir, l, (int) len, str, r);\n-  parse_out.lineno++;\n+  maybe_print_line (cpp_get_line (pfile)->output_line);\n+  fprintf (print.outf, \"#%s %s\\n\", dir, cpp_token_as_text (pfile, header));\n+  print.lineno++;\n }\n \n static void\n cb_enter_file (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_buffer *ip = CPP_BUFFER (pfile);\n+  /* Bring current file to correct line (except main file).  FIXME: we\n+     may be using the same buffer via a # NUMBER \"file\" 1 directive.  */\n+  if (pfile->done_initializing && pfile->buffer->prev)\n+    maybe_print_line (pfile->buffer->prev->lineno);\n \n-  cpp_printf (pfile, &parse_out, \"# 1 \\\"%s\\\"%s%s\\n\", ip->nominal_fname,\n-\t      pfile->done_initializing ? \" 1\" : \"\",\n-\t      cpp_syshdr_flags (pfile, ip));\n-\n-  parse_out.lineno = 1;\n-  parse_out.last_fname = ip->nominal_fname;\n+  move_printer (pfile, 1, pfile->done_initializing ? \" 1\": \"\");\n }\n \n static void\n cb_leave_file (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_buffer *ip = CPP_BUFFER (pfile);\n-\n-  cpp_printf (pfile, &parse_out, \"# %u \\\"%s\\\" 2%s\\n\", ip->lineno,\n-\t      ip->nominal_fname, cpp_syshdr_flags (pfile, ip));\n-\n-  parse_out.lineno = ip->lineno;\n-  parse_out.last_fname = ip->nominal_fname;\n+  move_printer (pfile, pfile->buffer->lineno + 1, \" 2\");\n }\n \n static void\n cb_rename_file (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_buffer *ip = CPP_BUFFER (pfile);\n-\n-  cpp_printf (pfile, &parse_out, \"# %u \\\"%s\\\"%s\\n\", ip->lineno,\n-\t      ip->nominal_fname, cpp_syshdr_flags (pfile, ip));\n-\n-  parse_out.lineno = ip->lineno;\n-  parse_out.last_fname = ip->nominal_fname;\n+  move_printer (pfile, pfile->buffer->lineno + 1, \"\");\n }\n \n static void\n cb_def_pragma (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_printf (pfile, &parse_out, \"#pragma \");\n-  cpp_output_list (pfile, parse_out.outf, &pfile->token_list,\n-\t\t   pfile->first_directive_token + 2);\n-  putc ('\\n', parse_out.outf);\n-  parse_out.lineno++;\n+  maybe_print_line (cpp_get_line (pfile)->output_line);\n+  fputs (\"#pragma \", print.outf);\n+  cpp_output_line (pfile, print.outf);\n+  print.lineno++;\n }\n \n static void\n@@ -252,47 +392,54 @@ do_pragma_implementation (pfile)\n {\n   /* Be quiet about `#pragma implementation' for a file only if it hasn't\n      been included yet.  */\n-  const cpp_token *tok = cpp_get_token (pfile);\n-  char *copy;\n+  cpp_token token;\n \n-  if (tok->type != CPP_EOF)\n-    {\n-      if (tok->type != CPP_STRING || cpp_get_token (pfile)->type != CPP_EOF)\n-\t{\n-\t  cpp_error (pfile, \"malformed #pragma implementation\");\n-\t  return;\n-\t}\n+  cpp_start_lookahead (pfile);\n+  cpp_get_token (pfile, &token);\n+  cpp_stop_lookahead (pfile, 0);\n \n-      /* Make a NUL-terminated copy of the string.  */\n-      copy = alloca (tok->val.str.len + 1);\n-      memcpy (copy, tok->val.str.text, tok->val.str.len);\n-      copy[tok->val.str.len] = '\\0';\n-  \n-      if (cpp_included (pfile, copy))\n+  /* If it's not a string, pass it through and let the front end complain.  */\n+  if (token.type == CPP_STRING)\n+    {\n+     /* Make a NUL-terminated copy of the string.  */\n+      char *filename = alloca (token.val.str.len + 1);\n+      memcpy (filename, token.val.str.text, token.val.str.len);\n+      filename[token.val.str.len] = '\\0';\n+      if (cpp_included (pfile, filename))\n \tcpp_warning (pfile,\n-\t\t\"#pragma implementation for %s appears after file is included\",\n-\t\t     copy);\n+\t     \"#pragma GCC implementation for \\\"%s\\\" appears after file is included\",\n+\t\t     filename);\n+    }\n+  else if (token.type != CPP_EOF)\n+    {\n+      cpp_error (pfile, \"malformed #pragma GCC implementation\");\n+      return;\n     }\n \n-  /* forward to default-pragma handler.  */\n+  /* Output?  This is nasty, but we don't have [GCC] implementation in\n+     the buffer.  */\n   if (pfile->cb.def_pragma)\n-    (*pfile->cb.def_pragma) (pfile);\n+    {\n+      maybe_print_line (cpp_get_line (pfile)->output_line);\n+      fputs (\"#pragma GCC implementation \", print.outf);\n+      cpp_output_line (pfile, print.outf);\n+      print.lineno++;\n+    }\n }\n \n /* Dump out the hash table.  */\n static int\n-dump_macros_helper (pfile, hp)\n+dump_macro (pfile, node)\n      cpp_reader *pfile;\n-     cpp_hashnode *hp;\n+     cpp_hashnode *node;\n {\n-  if (hp->type == T_MACRO)\n+  if (node->type == NT_MACRO && !(node->flags & NODE_BUILTIN))\n     {\n-      cpp_printf (pfile, &parse_out, \"#define %s\", hp->name);\n-      cpp_dump_definition (pfile, parse_out.outf, hp);\n-      putc ('\\n', parse_out.outf);\n-      parse_out.lineno++;\n+      fprintf (print.outf, \"#define %s\", node->name);\n+      fputs ((const char *) cpp_macro_definition (pfile, node), print.outf);\n+      putc ('\\n', print.outf);\n+      print.lineno++;\n     }\n \n   return 1;\n }\n-"}, {"sha": "53433ce4abd627443baf1b65308b274dc12bb20b", "filename": "gcc/cppoutput.c", "status": "removed", "additions": 0, "deletions": 390, "changes": 390, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de48b52da8468f94c0bdffc11fa7e8fe49b4ba66/gcc%2Fcppoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de48b52da8468f94c0bdffc11fa7e8fe49b4ba66/gcc%2Fcppoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppoutput.c?ref=de48b52da8468f94c0bdffc11fa7e8fe49b4ba66", "patch": "@@ -1,390 +0,0 @@\n-/* CPP Library - non-diagnostic output.\n-   Copyright (C) 2000 Free Software Foundation, Inc.\n-   Contributed by Per Bothner, 1994-95.\n-   Based on CCCP program by Paul Rubin, June 1986\n-   Adapted to ANSI C, Richard Stallman, Jan 1987\n-   Broken out to separate file, Sep 2000\n-\n-This program is free software; you can redistribute it and/or modify it\n-under the terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option) any\n-later version.\n-\n-This program is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this program; if not, write to the Free Software\n-Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"intl.h\"\n-#include \"cpplib.h\"\n-#include \"cpphash.h\"\n-\n-static void output_line_command PARAMS ((cpp_reader *, cpp_printer *,\n-\t\t\t\t\t unsigned int));\n-static void output_token PARAMS ((cpp_reader *, FILE *, const cpp_token *,\n-\t\t\t\t  const cpp_token *, int));\n-static void dump_macro_args PARAMS ((FILE *, const cpp_toklist *));\n-static void dump_param_spelling PARAMS ((FILE *, const cpp_toklist *,\n-\t\t\t\t\t unsigned int));\n-\n-/* Scan until CPP_BUFFER (PFILE) is exhausted, discarding output.  Used\n-   for handling -imacros, -dM, -M and -MM.  */\n-void\n-cpp_scan_buffer_nooutput (pfile)\n-     cpp_reader *pfile;\n-{\n-  cpp_buffer *stop = CPP_PREV_BUFFER (CPP_BUFFER (pfile));\n-  const cpp_token *token;\n-\n-  /* In no-output mode, we can ignore everything but directives.  */\n-  for (;;)\n-    {\n-      token = _cpp_get_token (pfile);\n-\n-      if (token->type == CPP_EOF)\n-\t{\n-\t  cpp_pop_buffer (pfile);\n-\t  if (CPP_BUFFER (pfile) == stop)\n-\t    break;\n-\t}\n-\n-      if (token->type == CPP_HASH && token->flags & BOL\n-\t  && pfile->token_list.directive)\n-\t{\n-\t  _cpp_process_directive (pfile, token);\n-\t  continue;\n-\t}\n-\n-      _cpp_skip_rest_of_line (pfile);\n-    }\n-}\n-\n-/* Scan until CPP_BUFFER (pfile) is exhausted, writing output to PRINT.  */\n-void\n-cpp_scan_buffer (pfile, print)\n-     cpp_reader *pfile;\n-     cpp_printer *print;\n-{\n-  cpp_buffer *stop = CPP_PREV_BUFFER (CPP_BUFFER (pfile));\n-  const cpp_token *token, *prev = 0;\n-\n-  for (;;)\n-    {\n-      token = _cpp_get_token (pfile);\n-      if (token->type == CPP_EOF)\n-\t{\n-\t  cpp_pop_buffer (pfile);\n-\n-\t  if (CPP_BUFFER (pfile) == stop)\n-\t    return;\n-\n-\t  prev = 0;\n-\t  continue;\n-\t}\n-\n-      if (token->flags & BOL)\n-\t{\n-\t  output_line_command (pfile, print, token->line);\n-\t  prev = 0;\n-\n-\t  if (token->type == CPP_HASH && pfile->token_list.directive)\n-\t    {\n-\t      _cpp_process_directive (pfile, token);\n-\t      continue;\n-\t    }\n-\t}\n-\n-      if (token->type != CPP_PLACEMARKER)\n-\t{\n-\t  output_token (pfile, print->outf, token, prev, 1);\n-\t  pfile->need_newline = 1;\n-\t}\n-\n-      prev = token;\n-    }\n-}\n-\n-/* Notify the compiler proper that the current line number has jumped,\n-   or the current file name has changed.  */\n-static void\n-output_line_command (pfile, print, line)\n-     cpp_reader *pfile;\n-     cpp_printer *print;\n-     unsigned int line;\n-{\n-  cpp_buffer *ip = CPP_BUFFER (pfile);\n-\n-  if (line == 0)\n-    return;\n-\n-  /* End the previous line of text.  */\n-  if (pfile->need_newline)\n-    {\n-      putc ('\\n', print->outf);\n-      print->lineno++;\n-    }\n-  pfile->need_newline = 0;\n-\n-  if (CPP_OPTION (pfile, no_line_commands))\n-    return;\n-\n-  /* If the current file has not changed, we can output a few newlines\n-     instead if we want to increase the line number by a small amount.\n-     We cannot do this if print->lineno is zero, because that means we\n-     haven't output any line commands yet.  (The very first line\n-     command output is a `same_file' command.)\n-\n-     'nominal_fname' values are unique, so they can be compared by\n-     comparing pointers.  */\n-  if (ip->nominal_fname == print->last_fname && print->lineno > 0\n-      && line >= print->lineno && line < print->lineno + 8)\n-    {\n-      while (line > print->lineno)\n-\t{\n-\t  putc ('\\n', print->outf);\n-\t  print->lineno++;\n-\t}\n-      return;\n-    }\n-\n-  fprintf (print->outf, \"# %u \\\"%s\\\"%s\\n\", line, ip->nominal_fname,\n-\t   cpp_syshdr_flags (pfile, ip));\n-\n-  print->last_fname = ip->nominal_fname;\n-  print->lineno = line;\n-}\n-\n-/* Output all the tokens of LIST, starting at TOKEN, to FP.  */\n-void\n-cpp_output_list (pfile, fp, list, token)\n-     cpp_reader *pfile;\n-     FILE *fp;\n-     const cpp_toklist *list;\n-     const cpp_token *token;\n-{\n-  const cpp_token *limit = list->tokens + list->tokens_used;\n-  const cpp_token *prev = 0;\n-  int white = 0;\n-\n-  while (token < limit)\n-    {\n-      /* XXX Find some way we can write macro args from inside\n-\t output_token/spell_token.  */\n-      if (token->type == CPP_MACRO_ARG)\n-\t{\n-\t  if (white && token->flags & PREV_WHITE)\n-\t    putc (' ', fp);\n-\t  if (token->flags & STRINGIFY_ARG)\n-\t    putc ('#', fp);\n-\t  dump_param_spelling (fp, list, token->val.aux);\n-\t}\n-      else\n-\toutput_token (pfile, fp, token, prev, white);\n-      if (token->flags & PASTE_LEFT)\n-\tfputs (\" ##\", fp);\n-      prev = token;\n-      token++;\n-      white = 1;\n-    }\n-}\n-\n-/* Write the spelling of a token TOKEN, with any appropriate\n-   whitespace before it, to FP.  PREV is the previous token, which\n-   is used to determine if we need to shove in an extra space in order\n-   to avoid accidental token paste.  If WHITE is 0, do not insert any\n-   leading whitespace.  */\n-static void\n-output_token (pfile, fp, token, prev, white)\n-     cpp_reader *pfile;\n-     FILE *fp;\n-     const cpp_token *token, *prev;\n-     int white;\n-{\n-  if (white)\n-    {\n-      int dummy;\n-\n-      if (token->col && (token->flags & BOL))\n-\t{\n-\t  /* Supply enough whitespace to put this token in its original\n-\t     column.  Don't bother trying to reconstruct tabs; we can't\n-\t     get it right in general, and nothing ought to care.  (Yes,\n-\t     some things do care; the fault lies with them.)  */\n-\t  unsigned int spaces = token->col - 1;\n-      \n-\t  while (spaces--)\n-\t    putc (' ', fp);\n-\t}\n-      else if (token->flags & PREV_WHITE)\n-\tputc (' ', fp);\n-      else\n-      /* Check for and prevent accidental token pasting.\n-\t In addition to the cases handled by _cpp_can_paste, consider\n-\n-\t a + ++b - if there is not a space between the + and ++, it\n-\t will be misparsed as a++ + b.  But + ## ++ doesn't produce\n-\t a valid token.  */\n-\tif (prev\n-\t    && (_cpp_can_paste (pfile, prev, token, &dummy) != CPP_EOF\n-\t\t|| (prev->type == CPP_PLUS && token->type == CPP_PLUS_PLUS)\n-\t\t|| (prev->type == CPP_MINUS && token->type == CPP_MINUS_MINUS)))\n-\tputc (' ', fp);\n-    }\n-\n-  switch (TOKEN_SPELL (token))\n-    {\n-    case SPELL_OPERATOR:\n-      {\n-\tconst unsigned char *spelling;\n-\n-\tif (token->flags & DIGRAPH)\n-\t  spelling = _cpp_digraph_spellings[token->type - CPP_FIRST_DIGRAPH];\n-\telse if (token->flags & NAMED_OP)\n-\t  goto spell_ident;\n-\telse\n-\t  spelling = TOKEN_NAME (token);\n-\n-\tufputs (spelling, fp);\n-      }\n-      break;\n-\n-    case SPELL_IDENT:\n-      spell_ident:\n-      ufputs (token->val.node->name, fp);\n-      break;\n-\n-    case SPELL_STRING:\n-      {\n-\tint left, right, tag;\n-\tswitch (token->type)\n-\t  {\n-\t  case CPP_STRING:\tleft = '\"';  right = '\"';  tag = '\\0'; break;\n-\t  case CPP_WSTRING:\tleft = '\"';  right = '\"';  tag = 'L';  break;\n-\t  case CPP_OSTRING:\tleft = '\"';  right = '\"';  tag = '@';  break;\n-\t  case CPP_CHAR:\tleft = '\\''; right = '\\''; tag = '\\0'; break;\n-    \t  case CPP_WCHAR:\tleft = '\\''; right = '\\''; tag = 'L';  break;\n-\t  case CPP_HEADER_NAME:\tleft = '<';  right = '>';  tag = '\\0'; break;\n-\t  default:\t\tleft = '\\0'; right = '\\0'; tag = '\\0'; break;\n-\t  }\n-\tif (tag) putc (tag, fp);\n-\tif (left) putc (left, fp);\n-\tfwrite (token->val.str.text, 1, token->val.str.len, fp);\n-\tif (right) putc (right, fp);\n-      }\n-      break;\n-\n-    case SPELL_CHAR:\n-      putc (token->val.aux, fp);\n-      break;\n-\n-    case SPELL_NONE:\n-      /* Placemarker or EOF - no output.  (Macro args are handled\n-         elsewhere.  */\n-      break;\n-    }\n-}\n-\n-/* Dump the original user's spelling of argument index ARG_NO to the\n-   macro whose expansion is LIST.  */\n-static void\n-dump_param_spelling (fp, list, arg_no)\n-     FILE *fp;\n-     const cpp_toklist *list;\n-     unsigned int arg_no;\n-{\n-  const U_CHAR *param = list->namebuf;\n-\n-  while (arg_no--)\n-    param += ustrlen (param) + 1;\n-  ufputs (param, fp);\n-}\n-\n-/* Dump the definition of macro MACRO on FP.  The format is suitable\n-   to be read back in again.  Caller is expected to generate the\n-   \"#define NAME\" bit.  */\n-\n-void\n-cpp_dump_definition (pfile, fp, hp)\n-     cpp_reader *pfile;\n-     FILE *fp;\n-     const cpp_hashnode *hp;\n-{\n-  const cpp_toklist *list = hp->value.expansion;\n-\n-  if (hp->type != T_MACRO)\n-    {\n-      cpp_ice (pfile, \"invalid hash type %d in dump_definition\", hp->type);\n-      return;\n-    }\n-\n-  if (list->paramc >= 0)\n-    dump_macro_args (fp, list);\n-\n-  putc (' ', fp);\n-  cpp_output_list (pfile, fp, list, list->tokens);\n-}\n-\n-static void\n-dump_macro_args (fp, list)\n-     FILE *fp;\n-     const cpp_toklist *list;\n-{\n-  int i;\n-  const U_CHAR *param = list->namebuf;\n-\n-  putc ('(', fp);\n-  for (i = 0; i++ < list->paramc;)\n-    {\n-      unsigned int len;\n-\n-      len = ustrlen (param);\n-      if (!(list->flags & VAR_ARGS) || ustrcmp (param, U\"__VA_ARGS__\"))\n-\tufputs (param, fp);\n-      if (i < list->paramc)\n-\tfputs (\", \", fp);\n-      else if (list->flags & VAR_ARGS)\n-\tfputs (\"...\", fp);\n-\n-      param += len + 1;\n-    }\n-  putc (')', fp);\n-}\n-\n-/* Like fprintf, but writes to a printer object.  You should be sure\n-   always to generate a complete line when you use this function.  */\n-void\n-cpp_printf VPARAMS ((cpp_reader *pfile, cpp_printer *print,\n-\t\t     const char *fmt, ...))\n-{\n-  va_list ap;\n-#ifndef ANSI_PROTOTYPES\n-  cpp_reader *pfile;\n-  cpp_printer *print;\n-  const char *fmt;\n-#endif\n-\n-  VA_START (ap, fmt);\n-\n-#ifndef ANSI_PROTOTYPES\n-  pfile = va_arg (ap, cpp_reader *);\n-  print = va_arg (ap, cpp_printer *);\n-  fmt = va_arg (ap, const char *);\n-#endif\n-\n-  /* End the previous line of text.  */\n-  if (pfile->need_newline)\n-    {\n-      putc ('\\n', print->outf);\n-      print->lineno++;\n-    }\n-  pfile->need_newline = 0;\n-\n-  vfprintf (print->outf, fmt, ap);\n-  va_end (ap);\n-}"}, {"sha": "3741a1383335d0eace72cfa9c7f91c889b89c79a", "filename": "gcc/fix-header.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c80368d9a16c073f2b930bef4232661971765f/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c80368d9a16c073f2b930bef4232661971765f/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=93c80368d9a16c073f2b930bef4232661971765f", "patch": "@@ -517,8 +517,9 @@ recognized_extern (name)\n    'f' for other function declarations.  */\n \n void\n-recognized_function (fname, kind, have_arg_list, file_seen)\n+recognized_function (fname, line, kind, have_arg_list, file_seen)\n      const cpp_token *fname;\n+     unsigned int line;\n      int kind; /* One of 'f' 'F' or 'I' */\n      int have_arg_list;\n      const char *file_seen;\n@@ -566,7 +567,7 @@ recognized_function (fname, kind, have_arg_list, file_seen)\n   partial_count++;\n   partial = (struct partial_proto *)\n     obstack_alloc (&scan_file_obstack, sizeof (struct partial_proto));\n-  partial->line_seen = fname->line;\n+  partial->line_seen = line;\n   partial->fn = fn;\n   fn->partial = partial;\n   partial->next = partial_proto_list;\n@@ -622,7 +623,7 @@ read_scan_file (in_fname, argc, argv)\n   if (CPP_FATAL_ERRORS (&scan_in))\n     exit (FATAL_EXIT_CODE);\n \n-  if (! cpp_start_read (&scan_in, 0, in_fname))\n+  if (! cpp_start_read (&scan_in, in_fname))\n     exit (FATAL_EXIT_CODE);\n \n   /* We are scanning a system header, so mark it as such.  */\n@@ -647,15 +648,16 @@ read_scan_file (in_fname, argc, argv)\n       /* Scan the macro expansion of \"getchar();\".  */\n       for (;;)\n \t{\n-\t  const cpp_token *t = cpp_get_token (&scan_in);\n+\t  cpp_token t;\n \n-\t  if (t->type == CPP_EOF)\n+\t  cpp_get_token (&scan_in, &t);\n+\t  if (t.type == CPP_EOF)\n \t    {\n \t      cpp_pop_buffer (&scan_in);\n \t      if (CPP_BUFFER (&scan_in) == buf)\n \t\tbreak;\n \t    }\n-\t  else if (cpp_ideq (t, \"_filbuf\"))\n+\t  else if (cpp_ideq (&t, \"_filbuf\"))\n \t    seen_filbuf++;\n \t}\n       if (seen_filbuf)"}, {"sha": "223d684c323b980d5350d341e7b0bdd7f415558c", "filename": "gcc/po/POTFILES.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c80368d9a16c073f2b930bef4232661971765f/gcc%2Fpo%2FPOTFILES.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c80368d9a16c073f2b930bef4232661971765f/gcc%2Fpo%2FPOTFILES.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpo%2FPOTFILES.in?ref=93c80368d9a16c073f2b930bef4232661971765f", "patch": "@@ -582,7 +582,6 @@ cpplex.c\n cpplib.c\n cpplib.h\n cppmain.c\n-cppoutput.c\n cppspec.c\n #crtstuff.c is part of the GCC library\n cse.c"}, {"sha": "6adcbcbb67d63b3a29982dd9537cb3156de6d81a", "filename": "gcc/scan-decls.c", "status": "modified", "additions": 38, "deletions": 34, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c80368d9a16c073f2b930bef4232661971765f/gcc%2Fscan-decls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c80368d9a16c073f2b930bef4232661971765f/gcc%2Fscan-decls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fscan-decls.c?ref=93c80368d9a16c073f2b930bef4232661971765f", "patch": "@@ -45,7 +45,11 @@ skip_to_closing_brace (pfile)\n   int nesting = 1;\n   for (;;)\n     {\n-      enum cpp_ttype token = cpp_get_token (pfile)->type;\n+      cpp_token tok;\n+      enum cpp_ttype token;\n+\n+      cpp_get_token (pfile, &tok);\n+      token = tok.type;\n       if (token == CPP_EOF)\n \tbreak;\n       if (token == CPP_OPEN_BRACE)\n@@ -84,17 +88,16 @@ scan_decls (pfile, argc, argv)\n      char **argv ATTRIBUTE_UNUSED;\n {\n   int saw_extern, saw_inline;\n-  const cpp_token *prev_id;\n-  const cpp_token *token;\n+  cpp_token token, prev_id;\n \n  new_statement:\n-  token = cpp_get_token (pfile);\n+  cpp_get_token (pfile, &token);\n \n  handle_statement:\n   current_extern_C = 0;\n   saw_extern = 0;\n   saw_inline = 0;\n-  if (token->type == CPP_OPEN_BRACE)\n+  if (token.type == CPP_OPEN_BRACE)\n     {\n       /* Pop an 'extern \"C\"' nesting level, if appropriate.  */\n       if (extern_C_braces_length\n@@ -103,28 +106,28 @@ scan_decls (pfile, argc, argv)\n       brace_nesting--;\n       goto new_statement;\n     }\n-  if (token->type == CPP_OPEN_BRACE)\n+  if (token.type == CPP_OPEN_BRACE)\n     {\n       brace_nesting++;\n       goto new_statement;\n     }\n-  if (token->type == CPP_EOF)\n+  if (token.type == CPP_EOF)\n     {\n       cpp_pop_buffer (pfile);\n       if (CPP_BUFFER (pfile) == NULL)\n \treturn 0;\n \n       goto new_statement;\n     }\n-  if (token->type == CPP_SEMICOLON)\n+  if (token.type == CPP_SEMICOLON)\n     goto new_statement;\n-  if (token->type != CPP_NAME)\n+  if (token.type != CPP_NAME)\n     goto new_statement;\n \n-  prev_id = 0;\n+  prev_id.type = CPP_EOF;\n   for (;;)\n     {\n-      switch (token->type)\n+      switch (token.type)\n \t{\n \tdefault:\n \t  goto handle_statement;\n@@ -136,11 +139,11 @@ scan_decls (pfile, argc, argv)\n \n \tcase CPP_COMMA:\n \tcase CPP_SEMICOLON:\n-\t  if (prev_id && saw_extern)\n+\t  if (prev_id.type != CPP_EOF && saw_extern)\n \t    {\n-\t      recognized_extern (prev_id);\n+\t      recognized_extern (&prev_id);\n \t    }\n-\t  if (token->type == CPP_COMMA)\n+\t  if (token.type == CPP_COMMA)\n \t    break;\n \t  /* ... fall through ...  */\n \tcase CPP_OPEN_BRACE:  case CPP_CLOSE_BRACE:\n@@ -154,60 +157,61 @@ scan_decls (pfile, argc, argv)\n \n \tcase CPP_OPEN_PAREN:\n \t  /* Looks like this is the start of a formal parameter list.  */\n-\t  if (prev_id)\n+\t  if (prev_id.type != CPP_EOF)\n \t    {\n \t      int nesting = 1;\n \t      int have_arg_list = 0;\n \t      for (;;)\n \t\t{\n-\t\t  token = cpp_get_token (pfile);\n-\t\t  if (token->type == CPP_OPEN_PAREN)\n+\t\t  cpp_get_token (pfile, &token);\n+\t\t  if (token.type == CPP_OPEN_PAREN)\n \t\t    nesting++;\n-\t\t  else if (token->type == CPP_CLOSE_PAREN)\n+\t\t  else if (token.type == CPP_CLOSE_PAREN)\n \t\t    {\n \t\t      nesting--;\n \t\t      if (nesting == 0)\n \t\t\tbreak;\n \t\t    }\n-\t\t  else if (token->type == CPP_EOF)\n+\t\t  else if (token.type == CPP_EOF)\n \t\t    break;\n-\t\t  else if (token->type == CPP_NAME\n-\t\t\t   || token->type == CPP_ELLIPSIS)\n+\t\t  else if (token.type == CPP_NAME\n+\t\t\t   || token.type == CPP_ELLIPSIS)\n \t\t    have_arg_list = 1;\n \t\t}\n-\t      recognized_function (prev_id, \n+\t      recognized_function (&prev_id, \n+\t\t\t\t   cpp_get_line (pfile)->line,\n \t\t\t\t   (saw_inline ? 'I'\n \t\t\t\t    : in_extern_C_brace || current_extern_C\n \t\t\t\t    ? 'F' : 'f'), have_arg_list,\n \t\t\t\t   CPP_BUFFER (pfile)->nominal_fname);\n-\t      token = cpp_get_token (pfile);\n-\t      if (token->type == CPP_OPEN_BRACE)\n+\t      cpp_get_token (pfile, &token);\n+\t      if (token.type == CPP_OPEN_BRACE)\n \t\t{\n \t\t  /* skip body of (normally) inline function */\n \t\t  skip_to_closing_brace (pfile);\n \t\t  goto new_statement;\n \t\t}\n-\t      if (token->type == CPP_SEMICOLON)\n+\t      if (token.type == CPP_SEMICOLON)\n \t\tgoto new_statement;\n \t    }\n \t  break;\n \tcase CPP_NAME:\n \t  /* \"inline\" and \"extern\" are recognized but skipped */\n-\t  if (cpp_ideq (token, \"inline\"))\n+\t  if (cpp_ideq (&token, \"inline\"))\n \t    {\n \t      saw_inline = 1;\n \t    }\n-\t  else if (cpp_ideq (token, \"extern\"))\n+\t  else if (cpp_ideq (&token, \"extern\"))\n \t    {\n \t      saw_extern = 1;\n-\t      token = cpp_get_token (pfile);\n-\t      if (token->type == CPP_STRING\n-\t\t  && token->val.str.len == 1\n-\t\t  && token->val.str.text[0] == 'C')\n+\t      cpp_get_token (pfile, &token);\n+\t      if (token.type == CPP_STRING\n+\t\t  && token.val.str.len == 1\n+\t\t  && token.val.str.text[0] == 'C')\n \t\t{\n \t\t  current_extern_C = 1;\n-\t\t  token = cpp_get_token (pfile);\n-\t\t  if (token->type == CPP_OPEN_BRACE)\n+\t\t  cpp_get_token (pfile, &token);\n+\t\t  if (token.type == CPP_OPEN_BRACE)\n \t\t    {\n \t\t      brace_nesting++;\n \t\t      extern_C_braces[extern_C_braces_length++]\n@@ -223,6 +227,6 @@ scan_decls (pfile, argc, argv)\n \t  prev_id = token;\n \t  break;\n \t}\n-      token = cpp_get_token (pfile);\n+      cpp_get_token (pfile, &token);\n     }\n }"}, {"sha": "d0ae23c3a5f789af466a2539b5d65052fef5dcd0", "filename": "gcc/scan.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c80368d9a16c073f2b930bef4232661971765f/gcc%2Fscan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c80368d9a16c073f2b930bef4232661971765f/gcc%2Fscan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fscan.h?ref=93c80368d9a16c073f2b930bef4232661971765f", "patch": "@@ -60,7 +60,8 @@ extern int scan_ident _PARAMS((FILE *, sstring *, int));\n extern int scan_string _PARAMS((FILE *, sstring *, int));\n extern int read_upto _PARAMS((FILE *, sstring *, int));\n extern unsigned long hash _PARAMS((const char *));\n-extern void recognized_function _PARAMS((const struct cpp_token *, int, int,\n+extern void recognized_function _PARAMS((const struct cpp_token *,\n+\t\t\t\t\t unsigned int, int, int,\n \t\t\t\t\t const char *));\n extern void recognized_extern _PARAMS((const struct cpp_token *));\n extern unsigned int hashstr _PARAMS((const char *, unsigned int));"}]}