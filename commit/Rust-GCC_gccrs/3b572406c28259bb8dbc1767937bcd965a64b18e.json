{"sha": "3b572406c28259bb8dbc1767937bcd965a64b18e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2I1NzI0MDZjMjgyNTliYjhkYmMxNzY3OTM3YmNkOTY1YTY0YjE4ZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-06-18T18:54:43Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-06-18T18:54:43Z"}, "message": "ia64-protos.h (process_for_unwind_directive): Declare.\n\n\t* config/ia64/ia64-protos.h (process_for_unwind_directive): Declare.\n\t(ia64_file_start): Declare.\n\t* config/ia64/ia64.h (ADDL_REGNO_P): Don't compare unsigned against 0.\n\t(GR_REGNO_P): Likewise.\n\t* config/ia64/ia64.c: Many prototypes.\n\t(ia64_reg_numbers): Constify.\n\t(ia64_input_reg_names, ia64_local_reg_names): Likewise.\n\t(ia64_section_threshold): Make unsigned.\n\t(ia64_print_operand): Constify.\n\t(fix_range): Constify.\n\t(ia64_init_builtins): Don't compare signed vs unsigned.\n\t(ia64_expand_builtin): Likewise.\n\n\t* config/ia64/ia64.h (EXTRA_CONSTRAINT): New.\n\t(CONSTRAINT_OK_FOR_Q): New.\n\t* config/ia64/ia64.md (movdi_internal): Use Q for fp<->mem.\n\t(movsf_internal, movdf_internal): Likewise.\n\t(cmovdi_internal): Rewrite so that constraints and predicates match;\n\tsimplify splitters.\n\t(cmovsi_internal): Likewise.\n\n\t* config/ia64/ia64.h (ASM_SPEC): Add -x for gas.\n\t(ASM_FILE_START): New.\n\t* config/ia64/ia64.c (ia64_file_start): New.\n\t(rtx_needs_barrier): Handle pred.rel.mutex.\n\t(emit_predicate_relation_info): New.\n\t* config/ia64/ia64.md (pred_rel_mutex): New.\n\t* config/ia64/linux.h (ASM_SPEC): Define.\n\t* config/ia64/sysv4.h (ASM_FILE_START): Define.\n\n\t* config/ia64/ia64.c (ia64_encode_section_info): Fix thinko\n\tfiltering global register variables.\n\nFrom-SVN: r34589", "tree": {"sha": "0d265c79e3b4883fed53bfec770ed8a0ab59adf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d265c79e3b4883fed53bfec770ed8a0ab59adf5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b572406c28259bb8dbc1767937bcd965a64b18e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b572406c28259bb8dbc1767937bcd965a64b18e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b572406c28259bb8dbc1767937bcd965a64b18e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b572406c28259bb8dbc1767937bcd965a64b18e/comments", "author": null, "committer": null, "parents": [{"sha": "5538e30f194c64edaae424688e28a2064902fa1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5538e30f194c64edaae424688e28a2064902fa1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5538e30f194c64edaae424688e28a2064902fa1a"}], "stats": {"total": 529, "additions": 340, "deletions": 189}, "files": [{"sha": "efd8221db9fc33d8d58bae8cec3c7f9dd8ee37eb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b572406c28259bb8dbc1767937bcd965a64b18e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b572406c28259bb8dbc1767937bcd965a64b18e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3b572406c28259bb8dbc1767937bcd965a64b18e", "patch": "@@ -1,3 +1,38 @@\n+2000-06-18  Richard Henderson  <rth@cygnus.com>\n+\n+\t* config/ia64/ia64-protos.h (process_for_unwind_directive): Declare.\n+\t(ia64_file_start): Declare.\n+\t* config/ia64/ia64.h (ADDL_REGNO_P): Don't compare unsigned against 0.\n+\t(GR_REGNO_P): Likewise.\n+\t* config/ia64/ia64.c: Many prototypes.\n+\t(ia64_reg_numbers): Constify.\n+\t(ia64_input_reg_names, ia64_local_reg_names): Likewise.\n+\t(ia64_section_threshold): Make unsigned.\n+\t(ia64_print_operand): Constify.\n+\t(fix_range): Constify.\n+\t(ia64_init_builtins): Don't compare signed vs unsigned.\n+\t(ia64_expand_builtin): Likewise.\n+\n+\t* config/ia64/ia64.h (EXTRA_CONSTRAINT): New.\n+\t(CONSTRAINT_OK_FOR_Q): New.\n+\t* config/ia64/ia64.md (movdi_internal): Use Q for fp<->mem.\n+\t(movsf_internal, movdf_internal): Likewise.\n+\t(cmovdi_internal): Rewrite so that constraints and predicates match;\n+\tsimplify splitters.\n+\t(cmovsi_internal): Likewise.\n+\n+\t* config/ia64/ia64.h (ASM_SPEC): Add -x for gas.\n+\t(ASM_FILE_START): New.\n+\t* config/ia64/ia64.c (ia64_file_start): New.\n+\t(rtx_needs_barrier): Handle pred.rel.mutex.\n+\t(emit_predicate_relation_info): New.\n+\t* config/ia64/ia64.md (pred_rel_mutex): New.\n+\t* config/ia64/linux.h (ASM_SPEC): Define.\n+\t* config/ia64/sysv4.h (ASM_FILE_START): Define.\n+\n+\t* config/ia64/ia64.c (ia64_encode_section_info): Fix thinko\n+\tfiltering global register variables.\n+\n 2000-06-18  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* c-common.c (add_c_tree_codes): Fix definition for traditional C."}, {"sha": "dcfe8ccdbb01109dabb0f0a604e7bcee9a2976ad", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b572406c28259bb8dbc1767937bcd965a64b18e/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b572406c28259bb8dbc1767937bcd965a64b18e/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=3b572406c28259bb8dbc1767937bcd965a64b18e", "patch": "@@ -61,6 +61,7 @@ extern enum reg_class ia64_secondary_reload_class PARAMS((enum reg_class,\n \t\t\t\t\t\t\t  enum machine_mode,\n \t\t\t\t\t\t\t  rtx));\n extern void ia64_reorg PARAMS((rtx));\n+extern void process_for_unwind_directive PARAMS ((FILE *, rtx));\n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE\n@@ -90,6 +91,7 @@ extern void ia64_encode_section_info PARAMS((tree));\n #endif /* TREE_CODE */\n \n extern int ia64_epilogue_uses PARAMS((int));\n+extern void ia64_file_start PARAMS((FILE *));\n extern void ia64_expand_prologue PARAMS((void));\n extern void ia64_expand_epilogue PARAMS((void));\n extern void ia64_function_prologue PARAMS((FILE *, int));"}, {"sha": "66f928b1c97e951b981e3f34a124d03f64dc8cbb", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 209, "deletions": 69, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b572406c28259bb8dbc1767937bcd965a64b18e/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b572406c28259bb8dbc1767937bcd965a64b18e/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=3b572406c28259bb8dbc1767937bcd965a64b18e", "patch": "@@ -78,7 +78,7 @@ int ia64_local_regs;\n int ia64_need_regstk;\n \n /* Register names for ia64_expand_prologue.  */\n-char *ia64_reg_numbers[96] =\n+static const char * const ia64_reg_numbers[96] =\n { \"r32\", \"r33\", \"r34\", \"r35\", \"r36\", \"r37\", \"r38\", \"r39\",\n   \"r40\", \"r41\", \"r42\", \"r43\", \"r44\", \"r45\", \"r46\", \"r47\",\n   \"r48\", \"r49\", \"r50\", \"r51\", \"r52\", \"r53\", \"r54\", \"r55\",\n@@ -93,11 +93,11 @@ char *ia64_reg_numbers[96] =\n   \"r120\",\"r121\",\"r122\",\"r123\",\"r124\",\"r125\",\"r126\",\"r127\"};\n \n /* ??? These strings could be shared with REGISTER_NAMES.  */\n-char *ia64_input_reg_names[8] =\n+static const char * const ia64_input_reg_names[8] =\n { \"in0\",  \"in1\",  \"in2\",  \"in3\",  \"in4\",  \"in5\",  \"in6\",  \"in7\" };\n \n /* ??? These strings could be shared with REGISTER_NAMES.  */\n-char *ia64_local_reg_names[80] =\n+static const char * const ia64_local_reg_names[80] =\n { \"loc0\", \"loc1\", \"loc2\", \"loc3\", \"loc4\", \"loc5\", \"loc6\", \"loc7\",\n   \"loc8\", \"loc9\", \"loc10\",\"loc11\",\"loc12\",\"loc13\",\"loc14\",\"loc15\",\n   \"loc16\",\"loc17\",\"loc18\",\"loc19\",\"loc20\",\"loc21\",\"loc22\",\"loc23\",\n@@ -110,7 +110,7 @@ char *ia64_local_reg_names[80] =\n   \"loc72\",\"loc73\",\"loc74\",\"loc75\",\"loc76\",\"loc77\",\"loc78\",\"loc79\" };\n \n /* ??? These strings could be shared with REGISTER_NAMES.  */\n-char *ia64_output_reg_names[8] =\n+static const char * const ia64_output_reg_names[8] =\n { \"out0\", \"out1\", \"out2\", \"out3\", \"out4\", \"out5\", \"out6\", \"out7\" };\n \n /* String used with the -mfixed-range= option.  */\n@@ -119,8 +119,20 @@ const char *ia64_fixed_range_string;\n /* Variables which are this size or smaller are put in the sdata/sbss\n    sections.  */\n \n-int ia64_section_threshold;\n-\n+unsigned int ia64_section_threshold;\n+\f\n+static enum machine_mode hfa_element_mode PARAMS ((tree, int));\n+static void fix_range PARAMS ((const char *));\n+static void ia64_add_gc_roots PARAMS ((void));\n+static void ia64_init_machine_status PARAMS ((struct function *));\n+static void ia64_mark_machine_status PARAMS ((struct function *));\n+static void emit_insn_group_barriers PARAMS ((rtx));\n+static void emit_predicate_relation_info PARAMS ((rtx));\n+static int process_set PARAMS ((FILE *, rtx));\n+static rtx ia64_expand_compare_and_swap PARAMS ((enum insn_code, tree,\n+\t\t\t\t\t\t rtx, int));\n+static rtx ia64_expand_binop_builtin PARAMS ((enum insn_code, tree, rtx));\n+\f\n /* Return 1 if OP is a valid operand for the MEM of a CALL insn.  */\n \n int\n@@ -486,6 +498,42 @@ predicate_operator (op, mode)\n \t  && (code == EQ || code == NE));\n }\n \f\n+/* Begin the assembly file.  */\n+\n+void\n+ia64_file_start (f)\n+     FILE *f;\n+{\n+  unsigned int rs, re;\n+  int out_state;\n+\n+  rs = 1;\n+  out_state = 0;\n+  while (1)\n+    {\n+      while (rs < 64 && call_used_regs[PR_REG (rs)])\n+\trs++;\n+      if (rs >= 64)\n+\tbreak;\n+      for (re = rs + 1; re < 64 && ! call_used_regs[PR_REG (re)]; re++)\n+\tcontinue;\n+      if (out_state == 0)\n+\t{\n+\t  fputs (\"\\t.pred.safe_across_calls \", f);\n+\t  out_state = 1;\n+\t}\n+      else\n+\tfputc (',', f);\n+      if (re == rs + 1)\n+\tfprintf (f, \"p%u\", rs);\n+      else\n+\tfprintf (f, \"p%u-p%u\", rs, re - 1);\n+      rs = re + 1;\n+    }\n+  if (out_state)\n+    fputc ('\\n', f);\n+}\n+\n /* Structure to be filled in by ia64_compute_frame_size with register\n    save masks and offsets for the current function.  */\n \n@@ -1834,7 +1882,7 @@ ia64_print_operand (file, x, code)\n     case 'U':\n       if (! TARGET_GNU_AS && GET_CODE (x) == CONST_INT)\n \t{\n-\t  char *prefix = \"0x\";\n+\t  const char *prefix = \"0x\";\n \t  if (INTVAL (x) & 0x80000000)\n \t    {\n \t      fprintf (file, \"0xffffffff\");\n@@ -2028,18 +2076,22 @@ ia64_asm_output_external (file, decl, name)\n /* Parse the -mfixed-range= option string.  */\n \n static void\n-fix_range (str)\n-     char *str;\n+fix_range (const_str)\n+     const char *const_str;\n {\n   int i, first, last;\n-  char *dash, *comma;\n+  char *str, *dash, *comma;\n \n   /* str must be of the form REG1'-'REG2{,REG1'-'REG} where REG1 and\n      REG2 are either register names or register numbers.  The effect\n      of this option is to mark the registers in the range from REG1 to\n      REG2 as ``fixed'' so they won't be used by the compiler.  This is\n      used, e.g., to ensure that kernel mode code doesn't use f32-f127.  */\n \n+  i = strlen (const_str);\n+  str = (char *) alloca (i + 1);\n+  memcpy (str, const_str, i + 1);\n+\n   while (1)\n     {\n       dash = strchr (str, '-');\n@@ -2188,6 +2240,11 @@ struct reg_flags\n   unsigned int is_branch : 1;\t/* Is register used as part of a branch?  */\n };\n \n+static void rws_update PARAMS ((struct reg_write_state *, int,\n+\t\t\t\tstruct reg_flags, int));\n+static int rws_access_reg PARAMS ((int, struct reg_flags, int));\n+static int rtx_needs_barrier PARAMS ((rtx, struct reg_flags, int));\n+\n /* Update *RWS for REGNO, which is being written by the current instruction,\n    with predicate PRED, and associated register flags in FLAGS.  */\n \n@@ -2637,6 +2694,10 @@ rtx_needs_barrier (x, flags, pred)\n \t  need_barrier = rws_access_reg (REG_AR_PFS, new_flags, pred);\n \t  break;\n \n+\tcase 5: /* set_bsp  */\n+\t  need_barrier = 1;\n+          break;\n+\n \tcase 6: /* mov pr= */\n \t  /* This writes all predicate registers.  */\n \t  new_flags.is_write = 1;\n@@ -2647,9 +2708,8 @@ rtx_needs_barrier (x, flags, pred)\n \t    need_barrier |= rws_access_reg (i, new_flags, pred);\n \t  break;\n \n-\tcase 5: /* set_bsp  */\n-\t  need_barrier = 1;\n-          break;\n+\tcase 7: /* pred.rel.mutex */\n+\t  return 0;\n \n \tdefault:\n \t  abort ();\n@@ -2809,12 +2869,54 @@ emit_insn_group_barriers (insns)\n     }\n }\n \n+/* Emit pseudo-ops for the assembler to describe predicate relations.\n+   At present this assumes that we only consider predicate pairs to\n+   be mutex, and that the assembler can deduce proper values from\n+   straight-line code.  */\n+\n+static void\n+emit_predicate_relation_info (insns)\n+     rtx insns;\n+{\n+  int i;\n+\n+  /* Make sure the CFG and global_live_at_start are correct.  */\n+  find_basic_blocks (insns, max_reg_num (), NULL);\n+  life_analysis (insns, NULL, 0);\n+\n+  for (i = n_basic_blocks - 1; i >= 0; --i)\n+    {\n+      basic_block bb = BASIC_BLOCK (i);\n+      int r;\n+      rtx head = bb->head;\n+\n+      /* We only need such notes at code labels.  */\n+      if (GET_CODE (head) != CODE_LABEL)\n+\tcontinue;\n+      if (GET_CODE (NEXT_INSN (head)) == NOTE\n+\t  && NOTE_LINE_NUMBER (NEXT_INSN (head)) == NOTE_INSN_BASIC_BLOCK)\n+\thead = NEXT_INSN (head);\n+\n+      for (r = PR_REG (0); r < PR_REG (64); r += 2)\n+\tif (REGNO_REG_SET_P (bb->global_live_at_start, r))\n+\t  {\n+\t    rtx p1 = gen_rtx_REG (CCmode, r);\n+\t    rtx p2 = gen_rtx_REG (CCmode, r + 1);\n+\t    rtx n = emit_insn_after (gen_pred_rel_mutex (p1, p2), head);\n+\t    if (head == bb->end)\n+\t      bb->end = n;\n+\t    head = n;\n+\t  }\n+    }\n+}\n+\n /* Perform machine dependent operations on the rtl chain INSNS.  */\n \n void\n ia64_reorg (insns)\n      rtx insns;\n {\n+  emit_predicate_relation_info (insns);\n   emit_insn_group_barriers (insns);\n }\n \f\n@@ -2916,7 +3018,8 @@ ia64_encode_section_info (decl)\n \n   /* Careful not to prod global register variables.  */\n   if (TREE_CODE (decl) != VAR_DECL\n-      || GET_CODE (DECL_RTL (decl)) != SYMBOL_REF)\n+      || GET_CODE (DECL_RTL (decl)) != MEM\n+      || GET_CODE (XEXP (DECL_RTL (decl), 0)) != SYMBOL_REF)\n     return;\n     \n   symbol_str = XSTR (XEXP (DECL_RTL (decl), 0), 0);\n@@ -3250,62 +3353,87 @@ struct builtin_description\n /* All 32 bit intrinsics that take 2 arguments. */\n static struct builtin_description bdesc_2argsi[] =\n {\n-  { CODE_FOR_fetch_and_add_si, \"__sync_fetch_and_add_si\", IA64_BUILTIN_FETCH_AND_ADD_SI, 0, 0 },\n-  { CODE_FOR_fetch_and_sub_si, \"__sync_fetch_and_sub_si\", IA64_BUILTIN_FETCH_AND_SUB_SI, 0, 0 },\n-  { CODE_FOR_fetch_and_or_si, \"__sync_fetch_and_or_si\", IA64_BUILTIN_FETCH_AND_OR_SI, 0, 0 },\n-  { CODE_FOR_fetch_and_and_si, \"__sync_fetch_and_and_si\", IA64_BUILTIN_FETCH_AND_AND_SI, 0, 0 },\n-  { CODE_FOR_fetch_and_xor_si, \"__sync_fetch_and_xor_si\", IA64_BUILTIN_FETCH_AND_XOR_SI, 0, 0 },\n-  { CODE_FOR_fetch_and_nand_si, \"__sync_fetch_and_nand_si\", IA64_BUILTIN_FETCH_AND_NAND_SI, 0, 0 },\n-  { CODE_FOR_add_and_fetch_si, \"__sync_add_and_fetch_si\", IA64_BUILTIN_ADD_AND_FETCH_SI, 0, 0 },\n-  { CODE_FOR_sub_and_fetch_si, \"__sync_sub_and_fetch_si\", IA64_BUILTIN_SUB_AND_FETCH_SI, 0, 0 },\n-  { CODE_FOR_or_and_fetch_si, \"__sync_or_and_fetch_si\", IA64_BUILTIN_OR_AND_FETCH_SI, 0, 0 },\n-  { CODE_FOR_and_and_fetch_si, \"__sync_and_and_fetch_si\", IA64_BUILTIN_AND_AND_FETCH_SI, 0, 0 },\n-  { CODE_FOR_xor_and_fetch_si, \"__sync_xor_and_fetch_si\", IA64_BUILTIN_XOR_AND_FETCH_SI, 0, 0 },\n-  { CODE_FOR_nand_and_fetch_si, \"__sync_nand_and_fetch_si\", IA64_BUILTIN_NAND_AND_FETCH_SI, 0, 0 }\n+  { CODE_FOR_fetch_and_add_si, \"__sync_fetch_and_add_si\",\n+    IA64_BUILTIN_FETCH_AND_ADD_SI, 0, 0 },\n+  { CODE_FOR_fetch_and_sub_si, \"__sync_fetch_and_sub_si\",\n+    IA64_BUILTIN_FETCH_AND_SUB_SI, 0, 0 },\n+  { CODE_FOR_fetch_and_or_si, \"__sync_fetch_and_or_si\",\n+    IA64_BUILTIN_FETCH_AND_OR_SI, 0, 0 },\n+  { CODE_FOR_fetch_and_and_si, \"__sync_fetch_and_and_si\",\n+    IA64_BUILTIN_FETCH_AND_AND_SI, 0, 0 },\n+  { CODE_FOR_fetch_and_xor_si, \"__sync_fetch_and_xor_si\",\n+    IA64_BUILTIN_FETCH_AND_XOR_SI, 0, 0 },\n+  { CODE_FOR_fetch_and_nand_si, \"__sync_fetch_and_nand_si\",\n+    IA64_BUILTIN_FETCH_AND_NAND_SI, 0, 0 },\n+  { CODE_FOR_add_and_fetch_si, \"__sync_add_and_fetch_si\",\n+    IA64_BUILTIN_ADD_AND_FETCH_SI, 0, 0 },\n+  { CODE_FOR_sub_and_fetch_si, \"__sync_sub_and_fetch_si\",\n+    IA64_BUILTIN_SUB_AND_FETCH_SI, 0, 0 },\n+  { CODE_FOR_or_and_fetch_si, \"__sync_or_and_fetch_si\",\n+    IA64_BUILTIN_OR_AND_FETCH_SI, 0, 0 },\n+  { CODE_FOR_and_and_fetch_si, \"__sync_and_and_fetch_si\",\n+    IA64_BUILTIN_AND_AND_FETCH_SI, 0, 0 },\n+  { CODE_FOR_xor_and_fetch_si, \"__sync_xor_and_fetch_si\",\n+    IA64_BUILTIN_XOR_AND_FETCH_SI, 0, 0 },\n+  { CODE_FOR_nand_and_fetch_si, \"__sync_nand_and_fetch_si\",\n+    IA64_BUILTIN_NAND_AND_FETCH_SI, 0, 0 }\n };\n \n /* All 64 bit intrinsics that take 2 arguments. */\n static struct builtin_description bdesc_2argdi[] =\n {\n-  { CODE_FOR_fetch_and_add_di, \"__sync_fetch_and_add_di\", IA64_BUILTIN_FETCH_AND_ADD_DI, 0, 0 },\n-  { CODE_FOR_fetch_and_sub_di, \"__sync_fetch_and_sub_di\", IA64_BUILTIN_FETCH_AND_SUB_DI, 0, 0 },\n-  { CODE_FOR_fetch_and_or_di, \"__sync_fetch_and_or_di\", IA64_BUILTIN_FETCH_AND_OR_DI, 0, 0 },\n-  { CODE_FOR_fetch_and_and_di, \"__sync_fetch_and_and_di\", IA64_BUILTIN_FETCH_AND_AND_DI, 0, 0 },\n-  { CODE_FOR_fetch_and_xor_di, \"__sync_fetch_and_xor_di\", IA64_BUILTIN_FETCH_AND_XOR_DI, 0, 0 },\n-  { CODE_FOR_fetch_and_nand_di, \"__sync_fetch_and_nand_di\", IA64_BUILTIN_FETCH_AND_NAND_DI, 0, 0 },\n-  { CODE_FOR_add_and_fetch_di, \"__sync_add_and_fetch_di\", IA64_BUILTIN_ADD_AND_FETCH_DI, 0, 0 },\n-  { CODE_FOR_sub_and_fetch_di, \"__sync_sub_and_fetch_di\", IA64_BUILTIN_SUB_AND_FETCH_DI, 0, 0 },\n-  { CODE_FOR_or_and_fetch_di, \"__sync_or_and_fetch_di\", IA64_BUILTIN_OR_AND_FETCH_DI, 0, 0 },\n-  { CODE_FOR_and_and_fetch_di, \"__sync_and_and_fetch_di\", IA64_BUILTIN_AND_AND_FETCH_DI, 0, 0 },\n-  { CODE_FOR_xor_and_fetch_di, \"__sync_xor_and_fetch_di\", IA64_BUILTIN_XOR_AND_FETCH_DI, 0, 0 },\n-  { CODE_FOR_nand_and_fetch_di, \"__sync_nand_and_fetch_di\", IA64_BUILTIN_NAND_AND_FETCH_DI, 0, 0 }\n+  { CODE_FOR_fetch_and_add_di, \"__sync_fetch_and_add_di\",\n+    IA64_BUILTIN_FETCH_AND_ADD_DI, 0, 0 },\n+  { CODE_FOR_fetch_and_sub_di, \"__sync_fetch_and_sub_di\",\n+    IA64_BUILTIN_FETCH_AND_SUB_DI, 0, 0 },\n+  { CODE_FOR_fetch_and_or_di, \"__sync_fetch_and_or_di\",\n+    IA64_BUILTIN_FETCH_AND_OR_DI, 0, 0 },\n+  { CODE_FOR_fetch_and_and_di, \"__sync_fetch_and_and_di\",\n+    IA64_BUILTIN_FETCH_AND_AND_DI, 0, 0 },\n+  { CODE_FOR_fetch_and_xor_di, \"__sync_fetch_and_xor_di\",\n+    IA64_BUILTIN_FETCH_AND_XOR_DI, 0, 0 },\n+  { CODE_FOR_fetch_and_nand_di, \"__sync_fetch_and_nand_di\",\n+    IA64_BUILTIN_FETCH_AND_NAND_DI, 0, 0 },\n+  { CODE_FOR_add_and_fetch_di, \"__sync_add_and_fetch_di\",\n+    IA64_BUILTIN_ADD_AND_FETCH_DI, 0, 0 },\n+  { CODE_FOR_sub_and_fetch_di, \"__sync_sub_and_fetch_di\",\n+    IA64_BUILTIN_SUB_AND_FETCH_DI, 0, 0 },\n+  { CODE_FOR_or_and_fetch_di, \"__sync_or_and_fetch_di\",\n+    IA64_BUILTIN_OR_AND_FETCH_DI, 0, 0 },\n+  { CODE_FOR_and_and_fetch_di, \"__sync_and_and_fetch_di\",\n+    IA64_BUILTIN_AND_AND_FETCH_DI, 0, 0 },\n+  { CODE_FOR_xor_and_fetch_di, \"__sync_xor_and_fetch_di\",\n+    IA64_BUILTIN_XOR_AND_FETCH_DI, 0, 0 },\n+  { CODE_FOR_nand_and_fetch_di, \"__sync_nand_and_fetch_di\",\n+    IA64_BUILTIN_NAND_AND_FETCH_DI, 0, 0 }\n };\n \n void\n ia64_init_builtins ()\n {\n-  int i;\n-  struct builtin_description *d;\n+  size_t i;\n \n   tree psi_type_node = build_pointer_type (integer_type_node);\n   tree pdi_type_node = build_pointer_type (long_integer_type_node);\n   tree endlink = tree_cons (NULL_TREE, void_type_node, NULL_TREE);\n \n-\n   /* __sync_val_compare_and_swap_si, __sync_bool_compare_and_swap_si */\n   tree si_ftype_psi_si_si\n     = build_function_type (integer_type_node,\n                            tree_cons (NULL_TREE, psi_type_node,\n                                       tree_cons (NULL_TREE, integer_type_node,\n-                                                 tree_cons (NULL_TREE, integer_type_node,\n+                                                 tree_cons (NULL_TREE,\n+\t\t\t\t\t\t\t    integer_type_node,\n                                                             endlink))));\n \n   /* __sync_val_compare_and_swap_di, __sync_bool_compare_and_swap_di */\n   tree di_ftype_pdi_di_di\n     = build_function_type (long_integer_type_node,\n                            tree_cons (NULL_TREE, pdi_type_node,\n-                                      tree_cons (NULL_TREE, long_integer_type_node,\n-                                                 tree_cons (NULL_TREE, long_integer_type_node,\n+                                      tree_cons (NULL_TREE,\n+\t\t\t\t\t\t long_integer_type_node,\n+                                                 tree_cons (NULL_TREE,\n+\t\t\t\t\t\t\t    long_integer_type_node,\n                                                             endlink))));\n   /* __sync_synchronize */\n   tree void_ftype_void\n@@ -3321,45 +3449,59 @@ ia64_init_builtins ()\n   tree di_ftype_pdi_di\n     = build_function_type (long_integer_type_node,\n                            tree_cons (NULL_TREE, pdi_type_node,\n-                           tree_cons (NULL_TREE, long_integer_type_node, endlink)));\n+                           tree_cons (NULL_TREE, long_integer_type_node,\n+\t\t\t\t      endlink)));\n \n   /* __sync_lock_release_si */\n   tree void_ftype_psi\n-    = build_function_type (void_type_node, tree_cons (NULL_TREE, psi_type_node, endlink));\n+    = build_function_type (void_type_node, tree_cons (NULL_TREE, psi_type_node,\n+\t\t\t\t\t\t      endlink));\n \n   /* __sync_lock_release_di */\n   tree void_ftype_pdi\n-    = build_function_type (void_type_node, tree_cons (NULL_TREE, pdi_type_node, endlink));\n+    = build_function_type (void_type_node, tree_cons (NULL_TREE, pdi_type_node,\n+\t\t\t\t\t\t      endlink));\n \n-  def_builtin (\"__sync_val_compare_and_swap_si\", si_ftype_psi_si_si, IA64_BUILTIN_VAL_COMPARE_AND_SWAP_SI);\n+  def_builtin (\"__sync_val_compare_and_swap_si\", si_ftype_psi_si_si,\n+\t       IA64_BUILTIN_VAL_COMPARE_AND_SWAP_SI);\n \n-  def_builtin (\"__sync_val_compare_and_swap_di\", di_ftype_pdi_di_di, IA64_BUILTIN_VAL_COMPARE_AND_SWAP_DI);\n+  def_builtin (\"__sync_val_compare_and_swap_di\", di_ftype_pdi_di_di,\n+\t       IA64_BUILTIN_VAL_COMPARE_AND_SWAP_DI);\n \n-  def_builtin (\"__sync_bool_compare_and_swap_si\", si_ftype_psi_si_si, IA64_BUILTIN_BOOL_COMPARE_AND_SWAP_SI);\n+  def_builtin (\"__sync_bool_compare_and_swap_si\", si_ftype_psi_si_si,\n+\t       IA64_BUILTIN_BOOL_COMPARE_AND_SWAP_SI);\n \n-  def_builtin (\"__sync_bool_compare_and_swap_di\", di_ftype_pdi_di_di, IA64_BUILTIN_BOOL_COMPARE_AND_SWAP_DI);\n+  def_builtin (\"__sync_bool_compare_and_swap_di\", di_ftype_pdi_di_di,\n+\t       IA64_BUILTIN_BOOL_COMPARE_AND_SWAP_DI);\n \n-  def_builtin (\"__sync_synchronize\", void_ftype_void, IA64_BUILTIN_SYNCHRONIZE);\n+  def_builtin (\"__sync_synchronize\", void_ftype_void,\n+\t       IA64_BUILTIN_SYNCHRONIZE);\n \n-  def_builtin (\"__sync_lock_test_and_set_si\", si_ftype_psi_si, IA64_BUILTIN_LOCK_TEST_AND_SET_SI);\n+  def_builtin (\"__sync_lock_test_and_set_si\", si_ftype_psi_si,\n+\t       IA64_BUILTIN_LOCK_TEST_AND_SET_SI);\n \n-  def_builtin (\"__sync_lock_test_and_set_di\", di_ftype_pdi_di, IA64_BUILTIN_LOCK_TEST_AND_SET_DI);\n+  def_builtin (\"__sync_lock_test_and_set_di\", di_ftype_pdi_di,\n+\t       IA64_BUILTIN_LOCK_TEST_AND_SET_DI);\n \n-  def_builtin (\"__sync_lock_release_si\", void_ftype_psi, IA64_BUILTIN_LOCK_RELEASE_SI);\n+  def_builtin (\"__sync_lock_release_si\", void_ftype_psi,\n+\t       IA64_BUILTIN_LOCK_RELEASE_SI);\n \n-  def_builtin (\"__sync_lock_release_di\", void_ftype_pdi, IA64_BUILTIN_LOCK_RELEASE_DI);\n+  def_builtin (\"__sync_lock_release_di\", void_ftype_pdi,\n+\t       IA64_BUILTIN_LOCK_RELEASE_DI);\n \n-  def_builtin (\"__builtin_ia64_bsp\", build_function_type (ptr_type_node, endlink), IA64_BUILTIN_BSP);\n+  def_builtin (\"__builtin_ia64_bsp\",\n+\t       build_function_type (ptr_type_node, endlink),\n+\t       IA64_BUILTIN_BSP);\n \n   def_builtin (\"__builtin_ia64_flushrs\", \n \t       build_function_type (void_type_node, endlink), \n \t       IA64_BUILTIN_FLUSHRS);\n \n   /* Add all builtins that are operations on two args. */\n-  for (i=0, d = bdesc_2argsi; i < sizeof(bdesc_2argsi) / sizeof *d; i++, d++)\n-    def_builtin (d->name, si_ftype_psi_si, d->code);\n-  for (i=0, d = bdesc_2argdi; i < sizeof(bdesc_2argdi) / sizeof *d; i++, d++)\n-    def_builtin (d->name, di_ftype_pdi_di, d->code);\n+  for (i = 0; i < sizeof(bdesc_2argsi) / sizeof *bdesc_2argsi; i++)\n+    def_builtin (bdesc_2argsi[i].name, si_ftype_psi_si, bdesc_2argsi[i].code);\n+  for (i = 0; i < sizeof(bdesc_2argdi) / sizeof *bdesc_2argdi; i++)\n+    def_builtin (bdesc_2argdi[i].name, si_ftype_psi_si, bdesc_2argdi[i].code);\n }\n \n /* Expand fetch_and_op intrinsics.  The basic code sequence is:\n@@ -3679,7 +3821,7 @@ ia64_expand_builtin (exp, target, subtarget, mode, ignore)\n   int fcode = DECL_FUNCTION_CODE (fndecl);\n   enum machine_mode tmode, mode0, mode1;\n   enum insn_code icode;\n-  int i;\n+  size_t i;\n   struct builtin_description *d;\n \n   switch (fcode)\n@@ -3705,7 +3847,7 @@ ia64_expand_builtin (exp, target, subtarget, mode, ignore)\n       tmp_reg = gen_rtx_REG (DImode, GR_REG(0));\n       target = gen_rtx_MEM (BLKmode, tmp_reg);\n       emit_insn (gen_mf (target));\n-      return 0;\n+      return const0_rtx;\n \n     case IA64_BUILTIN_LOCK_TEST_AND_SET_SI:\n       icode = CODE_FOR_lock_test_and_set_si;\n@@ -3759,15 +3901,15 @@ ia64_expand_builtin (exp, target, subtarget, mode, ignore)\n       op0 = gen_rtx_MEM (SImode, copy_to_mode_reg (Pmode, op0));\n       MEM_VOLATILE_P (op0) = 1;\n       emit_insn (gen_movsi (op0, GEN_INT(0)));\n-      return 0;\n+      return const0_rtx;\n \n     case IA64_BUILTIN_LOCK_RELEASE_DI:\n       arg0 = TREE_VALUE (arglist);\n       op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n       op0 = gen_rtx_MEM (DImode, copy_to_mode_reg (Pmode, op0));\n       MEM_VOLATILE_P (op0) = 1;\n       emit_insn (gen_movdi (op0, GEN_INT(0)));\n-      return 0;\n+      return const0_rtx;\n \n     case IA64_BUILTIN_BSP:\n       {\n@@ -3777,10 +3919,8 @@ ia64_expand_builtin (exp, target, subtarget, mode, ignore)\n       }\n \n     case IA64_BUILTIN_FLUSHRS:\n-      {\n-\temit_insn (gen_flushrs ());\n-\treturn 0;\n-      }\n+      emit_insn (gen_flushrs ());\n+      return const0_rtx;\n \n     default:\n       break;"}, {"sha": "9dd28957ef38a252ac287fc464cd1d055f3460b9", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b572406c28259bb8dbc1767937bcd965a64b18e/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b572406c28259bb8dbc1767937bcd965a64b18e/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=3b572406c28259bb8dbc1767937bcd965a64b18e", "patch": "@@ -238,10 +238,10 @@ extern const char *ia64_fixed_range_string;\n \n #if ((TARGET_CPU_DEFAULT | TARGET_DEFAULT) & MASK_GNU_AS) != 0\n /* GNU AS.  */\n-#define ASM_SPEC \"%{mno-gnu-as:-N so}\"\n+#define ASM_SPEC \"%{mno-gnu-as:-N so}%{!mno-gnu-as: -x}\"\n #else\n /* Intel ias.  */\n-#define ASM_SPEC \"%{!mgnu-as:-N so}\"\n+#define ASM_SPEC \"%{!mgnu-as:-N so}%{mgnu-as: -x}\"\n #endif\n \n /* A C string constant that tells the GNU CC driver program options to pass to\n@@ -543,8 +543,8 @@ while (0)\n #define FIRST_PSEUDO_REGISTER 330\n \n /* Ranges for the various kinds of registers.  */\n-#define ADDL_REGNO_P(REGNO) ((REGNO) >= 0 && (REGNO) <= 3)\n-#define GR_REGNO_P(REGNO) ((REGNO) >= 0 && (REGNO) <= 127)\n+#define ADDL_REGNO_P(REGNO) ((unsigned HOST_WIDE_INT) (REGNO) <= 3)\n+#define GR_REGNO_P(REGNO) ((unsigned HOST_WIDE_INT) (REGNO) <= 127)\n #define FR_REGNO_P(REGNO) ((REGNO) >= 128 && (REGNO) <= 255)\n #define PR_REGNO_P(REGNO) ((REGNO) >= 256 && (REGNO) <= 319)\n #define BR_REGNO_P(REGNO) ((REGNO) >= 320 && (REGNO) <= 327)\n@@ -1067,9 +1067,12 @@ enum reg_class\n /* A C expression that defines the optional machine-dependent constraint\n    letters (`Q', `R', `S', `T', `U') that can be used to segregate specific\n    types of operands, usually memory references, for the target machine.  */\n-/* ??? This might be useful considering that we have already used all of the\n-   integer constant contraint letters.  */\n-/* #define EXTRA_CONSTRAINT(VALUE, C) */\n+\n+#define CONSTRAINT_OK_FOR_Q(VALUE) \\\n+  (memory_operand((VALUE), VOIDmode) && ! MEM_VOLATILE_P (VALUE))\n+\n+#define EXTRA_CONSTRAINT(VALUE, C) \\\n+  ((C) == 'Q' ? CONSTRAINT_OK_FOR_Q (VALUE) : 0)\n \f\n /* Basic Stack Layout */\n \n@@ -1460,6 +1463,11 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define FUNCTION_EPILOGUE(FILE, SIZE) \\\n   ia64_function_epilogue (FILE, SIZE)\n \n+/* Output at beginning of assembler file.  */\n+\n+#define ASM_FILE_START(FILE) \\\n+  ia64_file_start (FILE)\n+\n /* A C compound statement that outputs the assembler code for a thunk function,\n    used to implement C++ virtual function calls with multiple inheritance.  */\n "}, {"sha": "90ef6a231282711341bbd243ef1fbda2cf655023", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 76, "deletions": 109, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b572406c28259bb8dbc1767937bcd965a64b18e/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b572406c28259bb8dbc1767937bcd965a64b18e/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=3b572406c28259bb8dbc1767937bcd965a64b18e", "patch": "@@ -80,6 +80,7 @@\n ;;\t4\tpfs_restore\n ;;\t5\tset_bsp\n ;;\t6\tpr_restore\n+;;\t7\tpred.rel.mutex\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -288,8 +289,8 @@\n }\")\n \n (define_insn \"*movdi_internal\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r, m, r,*f,*f,*f, m, r,*b\")\n-\t(match_operand:DI 1 \"move_operand\"         \"rO,J,i,m,rO,*f,rO,*f, m,*f,*b,rO\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r, m,r,*f,*f,*f,Q, r,*b\")\n+\t(match_operand:DI 1 \"move_operand\"         \"rO,J,i,m,rO,*f,rO,*f,Q,*f,*b,rO\"))]\n   \"! memory_operand (operands[0], DImode)\n    || ! memory_operand (operands[1], DImode)\"\n   \"@\n@@ -301,8 +302,8 @@\n   getf.sig %0 = %1\n   setf.sig %0 = %r1\n   mov %0 = %1\n-  ldf8%O1 %0 = %1%P1\n-  stf8%Q0 %0 = %1%P0\n+  ldf8 %0 = %1%P1\n+  stf8 %0 = %1%P0\n   mov %0 = %1\n   mov %0 = %r1\"\n   [(set_attr \"type\" \"A,A,L,M,M,M,M,F,M,M,I,I\")])\n@@ -392,8 +393,8 @@\n }\")\n \n (define_insn \"*movsf_internal\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,f, m,*r, f,*r,*r, m\")\n-\t(match_operand:SF 1 \"general_operand\"      \"fG,m,fG,fG,*r,*r, m,*r\"))]\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,f, Q,*r, f,*r,*r, m\")\n+\t(match_operand:SF 1 \"general_operand\"      \"fG,Q,fG,fG,*r,*r, m,*r\"))]\n   \"! memory_operand (operands[0], SFmode)\n    || ! memory_operand (operands[1], SFmode)\"\n   \"@\n@@ -420,8 +421,8 @@\n }\")\n \n (define_insn \"*movdf_internal\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,f, m,*r, f,*r,*r, m\")\n-\t(match_operand:DF 1 \"general_operand\"      \"fG,m,fG,fG,*r,*r, m,*r\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,f, Q,*r, f,*r,*r, m\")\n+\t(match_operand:DF 1 \"general_operand\"      \"fG,Q,fG,fG,*r,*r, m,*r\"))]\n   \"! memory_operand (operands[0], DFmode)\n    || ! memory_operand (operands[1], DFmode)\"\n   \"@\n@@ -447,6 +448,7 @@\n     operands[1] = copy_to_mode_reg (XFmode, operands[1]);\n }\")\n \n+;; ??? There's no easy way to mind volatile acquire/release semantics.\n (define_insn \"*movxf_internal\"\n   [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f,f, m\")\n \t(match_operand:XF 1 \"general_operand\"      \"fG,m,fG\"))]\n@@ -2383,71 +2385,47 @@\n \n ;; ??? Add movXXcc patterns?\n \n-;; ??? The predicates don't match the constraints.\n-\n-;; ??? r/c/m/m and m/c/r/r alternatives make sense, but won't work until the\n-;; predicates are fixed, because the define_splits won't recognize them.\n-\n ;;\n ;; DImode if_then_else patterns.\n ;;\n \n-(define_insn \"*cmovdi_internal\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,r,m,r,r,m,r\")\n+(define_insn_and_split \"*cmovdi_internal\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\"\n+\t\t\t  \"=r,m,*f,Q,*b,r,m,*f,Q,*b,r,m,*f,Q,*b\")\n \t(if_then_else:DI\n \t  (match_operator:CC 4 \"predicate_operator\"\n-\t    [(match_operand:CC 1 \"register_operand\" \"c,c,c,c,c,c,c\")\n+\t    [(match_operand:CC 1 \"register_operand\"\n+\t\t\t       \"c,c,c,c,c,c,c,c,c,c,c,c,c,c,c\")\n \t     (const_int 0)])\n-\t  (match_operand:DI 2 \"reg_or_22bit_operand\" \"0,0,0,rI,m,r,rI\")\n-\t  (match_operand:DI 3 \"reg_or_22bit_operand\" \"rI,m,r,0,0,0,rI\")))]\n+\t  (match_operand:DI 2 \"general_operand\"\n+\t\t    \"0,0,0,0,0,rim*f*b,rO,rOQ,*f,r,rim*f*b,rO,rOQ,*f,r\")\n+\t  (match_operand:DI 3 \"general_operand\"\n+\t\t    \"rim*f*b,rO,rOQ,*f,r,0,0,0,0,0,rim*f*b,rO,rOQ,*f,r\")))]\n   \"\"\n   \"#\"\n-  [(set_attr \"type\" \"A,M,M,A,M,M,unknown\")])\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(if_then_else:DI\n-\t  (match_operator:CC 4 \"predicate_operator\"\n-\t    [(match_operand:CC 1 \"register_operand\" \"\")\n-\t     (const_int 0)])\n-\t  (match_operand:DI 2 \"reg_or_22bit_operand\" \"\")\n-\t  (match_operand:DI 3 \"reg_or_22bit_operand\" \"\")))]\n-  \"(reload_completed\n-    && (rtx_equal_p (operands[0], operands[2])\n-        || rtx_equal_p (operands[0], operands[3])))\"\n-  [(cond_exec\n-     (match_dup 4)\n-     (set (match_dup 0) (match_dup 2)))]\n+  \"reload_completed\"\n+  [(const_int 0)]\n   \"\n {\n-  if (rtx_equal_p (operands[0], operands[2]))\n+  rtx tmp;\n+  if (! rtx_equal_p (operands[0], operands[2]))\n     {\n-      operands[2] = operands[3];\n-      operands[4] = gen_rtx_fmt_ee (GET_CODE (operands[4]) == NE ? EQ : NE,\n-\t\t\t\t    CCmode, operands[1], const0_rtx);\n+      tmp = gen_rtx_SET (VOIDmode, operands[0], operands[2]);\n+      tmp = gen_rtx_COND_EXEC (VOIDmode, operands[4], tmp);\n+      emit_insn (tmp);\n     }\n-}\")\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(if_then_else:DI\n-\t  (match_operator:CC 4 \"predicate_operator\"\n-\t    [(match_operand:CC 1 \"register_operand\" \"\")\n-\t     (const_int 0)])\n-\t  (match_operand:DI 2 \"reg_or_22bit_operand\" \"\")\n-\t  (match_operand:DI 3 \"reg_or_22bit_operand\" \"\")))]\n-  \"reload_completed\"\n-  [(cond_exec\n-     (match_dup 4)\n-     (set (match_dup 0) (match_dup 2)))\n-   (cond_exec\n-     (match_dup 5)\n-     (set (match_dup 0) (match_dup 3)))]\n-  \"\n-{\n-  operands[5] = gen_rtx_fmt_ee (GET_CODE (operands[4]) == NE ? EQ : NE,\n-\t\t\t\tCCmode, operands[1], const0_rtx);\n-}\")\n+  if (! rtx_equal_p (operands[0], operands[3]))\n+    {\n+      tmp = gen_rtx_fmt_ee (GET_CODE (operands[4]) == NE ? EQ : NE,\n+\t\t\t    CCmode, operands[1], const0_rtx);\n+      tmp = gen_rtx_COND_EXEC (VOIDmode, tmp,\n+\t\t\t       gen_rtx_SET (VOIDmode, operands[0],\n+\t\t\t\t\t    operands[3]));\n+      emit_insn (tmp);\n+    }\n+  DONE;\n+}\"\n+  [(set_attr \"predicable\" \"no\")])\n \n ;; Absolute value pattern.\n \n@@ -2461,7 +2439,8 @@\n \t  (match_operand:DI 3 \"reg_or_22bit_operand\" \"0,rI\")))]\n   \"\"\n   \"#\"\n-  [(set_attr \"type\" \"A,unknown\")])\n+  [(set_attr \"type\" \"A,unknown\")\n+   (set_attr \"predicable\" \"no\")])\n \n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -2503,62 +2482,41 @@\n ;; SImode if_then_else patterns.\n ;;\n \n-(define_insn \"*cmovsi_internal\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,m,r,r,m,r\")\n+(define_insn_and_split \"*cmovsi_internal\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,m,*f,r,m,*f,r,m,*f\")\n \t(if_then_else:SI\n \t  (match_operator:CC 4 \"predicate_operator\"\n-\t    [(match_operand:CC 1 \"register_operand\" \"c,c,c,c,c,c,c\")\n+\t    [(match_operand:CC 1 \"register_operand\" \"c,c,c,c,c,c,c,c,c\")\n \t     (const_int 0)])\n-\t  (match_operand:SI 2 \"reg_or_22bit_operand\" \"0,0,0,rI,m,r,rI\")\n-\t  (match_operand:SI 3 \"reg_or_22bit_operand\" \"rI,m,r,0,0,0,rI\")))]\n+\t  (match_operand:SI 2 \"general_operand\"\n+\t\t    \"0,0,0,rim*f,rO,rO,rim*f,rO,rO\")\n+\t  (match_operand:SI 3 \"general_operand\"\n+\t\t    \"rim*f,rO,rO,0,0,0,rim*f,rO,rO\")))]\n   \"\"\n   \"#\"\n-  [(set_attr \"type\" \"A,M,M,A,M,M,unknown\")])\n-\n-(define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(if_then_else:SI\n-\t  (match_operator:CC 4 \"predicate_operator\"\n-\t    [(match_operand:CC 1 \"register_operand\" \"\")\n-\t     (const_int 0)])\n-\t  (match_operand:SI 2 \"reg_or_22bit_operand\" \"\")\n-\t  (match_operand:SI 3 \"reg_or_22bit_operand\" \"\")))]\n-  \"(reload_completed\n-    && (rtx_equal_p (operands[0], operands[2])\n-        || rtx_equal_p (operands[0], operands[3])))\"\n-  [(cond_exec\n-     (match_dup 4)\n-     (set (match_dup 0) (match_dup 2)))]\n+  \"reload_completed\"\n+  [(const_int 0)]\n   \"\n {\n-  if (rtx_equal_p (operands[0], operands[2]))\n+  rtx tmp;\n+  if (! rtx_equal_p (operands[0], operands[2]))\n     {\n-      operands[2] = operands[3];\n-      operands[4] = gen_rtx_fmt_ee (GET_CODE (operands[4]) == NE ? EQ : NE,\n-\t\t\t\t    CCmode, operands[1], const0_rtx);\n+      tmp = gen_rtx_SET (VOIDmode, operands[0], operands[2]);\n+      tmp = gen_rtx_COND_EXEC (VOIDmode, operands[4], tmp);\n+      emit_insn (tmp);\n     }\n-}\")\n-\n-(define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(if_then_else:SI\n-\t  (match_operator:CC 4 \"predicate_operator\"\n-\t    [(match_operand:CC 1 \"register_operand\" \"\")\n-\t     (const_int 0)])\n-\t  (match_operand:SI 2 \"reg_or_22bit_operand\" \"\")\n-\t  (match_operand:SI 3 \"reg_or_22bit_operand\" \"\")))]\n-  \"reload_completed\"\n-  [(cond_exec\n-     (match_dup 4)\n-     (set (match_dup 0) (match_dup 2)))\n-   (cond_exec\n-     (match_dup 5)\n-     (set (match_dup 0) (match_dup 3)))]\n-  \"\n-{\n-  operands[5] = gen_rtx_fmt_ee (GET_CODE (operands[4]) == NE ? EQ : NE,\n-\t\t\t\tCCmode, operands[1], const0_rtx);\n-}\")\n+  if (! rtx_equal_p (operands[0], operands[3]))\n+    {\n+      tmp = gen_rtx_fmt_ee (GET_CODE (operands[4]) == NE ? EQ : NE,\n+\t\t\t    CCmode, operands[1], const0_rtx);\n+      tmp = gen_rtx_COND_EXEC (VOIDmode, tmp,\n+\t\t\t       gen_rtx_SET (VOIDmode, operands[0],\n+\t\t\t\t\t    operands[3]));\n+      emit_insn (tmp);\n+    }\n+  DONE;\n+}\"\n+  [(set_attr \"predicable\" \"no\")])\n \n (define_insn \"*abssi2_internal\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n@@ -2570,7 +2528,8 @@\n \t  (match_operand:SI 2 \"reg_or_22bit_operand\" \"0,rI\")))]\n   \"\"\n   \"#\"\n-  [(set_attr \"type\" \"A,unknown\")])\n+  [(set_attr \"type\" \"A,unknown\")\n+   (set_attr \"predicable\" \"no\")])\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -3769,3 +3728,11 @@\n       (const_int 0)])]\n   \"\"\n   \"(%J0)\")\n+\n+(define_insn \"pred_rel_mutex\"\n+  [(unspec_volatile [(match_operand:CC 0 \"register_operand\" \"c\")\n+\t\t     (match_operand:CC 1 \"register_operand\" \"c\")] 7)]\n+  \"\"\n+  \".pred.rel.mutex %0,%1\"\n+  [(set_attr \"type\" \"unknown\")\n+   (set_attr \"predicable\" \"no\")])"}, {"sha": "50e5e6f96a3b000368ec9be598c36733c231e046", "filename": "gcc/config/ia64/linux.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b572406c28259bb8dbc1767937bcd965a64b18e/gcc%2Fconfig%2Fia64%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b572406c28259bb8dbc1767937bcd965a64b18e/gcc%2Fconfig%2Fia64%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Flinux.h?ref=3b572406c28259bb8dbc1767937bcd965a64b18e", "patch": "@@ -10,6 +10,7 @@\n \n /* ??? ia64 gas doesn't accept standard svr4 assembler options?  */\n #undef ASM_SPEC\n+#define ASM_SPEC \"-x\"\n \n /* Define this for shared library support because it isn't in the main\n    linux.h file.  */"}, {"sha": "906e66b1b03ba0018bc2fc40e94ccdee07487a88", "filename": "gcc/config/ia64/sysv4.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b572406c28259bb8dbc1767937bcd965a64b18e/gcc%2Fconfig%2Fia64%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b572406c28259bb8dbc1767937bcd965a64b18e/gcc%2Fconfig%2Fia64%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fsysv4.h?ref=3b572406c28259bb8dbc1767937bcd965a64b18e", "patch": "@@ -179,14 +179,12 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* ??? Unrelated, but dwarf2out.c emits unnecessary newlines after strings,\n    may as well fix at the same time.  */\n \n-#if 0\n #undef ASM_FILE_START\n #define ASM_FILE_START(STREAM) \\\n do {\t\t\t\t\t\t\t\t\t\\\n-  fputs (ASM_APP_OFF, STREAM);\t\t\t\t\t\t\\\n   output_file_directive (STREAM, main_input_filename);\t\t\t\\\n+  ia64_file_start(STREAM);\t\t\t\t\t\t\\\n } while (0)\n-#endif\n \n /* Case label alignment is handled by ADDR_VEC_ALIGN now.  */\n \n@@ -228,7 +226,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* Similarly for constant pool data.  */\n \n-extern int ia64_section_threshold;\n+extern unsigned int ia64_section_threshold;\n #undef SELECT_RTX_SECTION\n #define SELECT_RTX_SECTION(MODE, RTX)\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\"}]}