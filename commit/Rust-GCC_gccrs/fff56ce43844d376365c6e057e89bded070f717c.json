{"sha": "fff56ce43844d376365c6e057e89bded070f717c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZmNTZjZTQzODQ0ZDM3NjM2NWM2ZTA1N2U4OWJkZWQwNzBmNzE3Yw==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2020-09-02T02:53:47Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2020-09-08T01:15:15Z"}, "message": "ubsan: d-demangle.c:214 signed integer overflow\n\nRunning the libiberty testsuite\n./test-demangle < libiberty/testsuite/d-demangle-expected\nlibiberty/d-demangle.c:214:14: runtime error: signed integer overflow: 922337203 * 10 cannot be represented in type 'long int'\n\nOn looking at silencing ubsan, I found a real bug in dlang_number.\nFor a 32-bit long, some overflows won't be detected.  For example,\n21474836480.  Why?  Well 214748364 * 10 is 0x7FFFFFF8 (no overflow so\nfar).  Adding 8 gives 0x80000000 (which does overflow but there is no\ntest for that overflow in the code).  Then multiplying 0x80000000 * 10\n= 0x500000000 = 0 won't be caught by the multiplication overflow test.\nThe same holds for a 64-bit long using similarly crafted digit\nsequences.\n\n\t* d-demangle.c: Include limits.h.\n\t(ULONG_MAX, UINT_MAX): Provide fall-back definition.\n\t(dlang_number): Simplify and correct overflow test.  Only\n\twrite *ret on returning non-NULL.  Make \"ret\" an unsigned long*.\n\tOnly succeed for result of [0,UINT_MAX].\n\t(dlang_decode_backref): Simplify and correct overflow test.\n\tOnly write *ret on returning non-NULL.  Only succeed for\n\tresult [1,MAX_LONG].\n\t(dlang_backref): Remove now unnecessary range check.\n\t(dlang_symbol_name_p): Likewise.\n\t(string_need): Take a size_t n arg, and use size_t tem.\n\t(string_append): Use size_t n.\n\t(string_appendn, string_prependn): Take a size_t n arg.\n\t(TEMPLATE_LENGTH_UNKNOWN): Define as -1UL.\n\t(dlang_lname, dlang_parse_template): Take an unsigned long len\n\targ.\n\t(dlang_symbol_backref, dlang_identifier, dlang_parse_integer),\n\t(dlang_parse_integer, dlang_parse_string),\n\t(dlang_parse_arrayliteral, dlang_parse_assocarray),\n\t(dlang_parse_structlit, dlang_parse_tuple),\n\t(dlang_template_symbol_param, dlang_template_args): Use\n\tunsigned long variables.\n\t* testsuite/d-demangle-expected: Add new tests.", "tree": {"sha": "22740fc4c05e71669628a5b5d5094a6f3b90c76b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22740fc4c05e71669628a5b5d5094a6f3b90c76b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fff56ce43844d376365c6e057e89bded070f717c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fff56ce43844d376365c6e057e89bded070f717c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fff56ce43844d376365c6e057e89bded070f717c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fff56ce43844d376365c6e057e89bded070f717c/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a995c40d03ea8829a7c05836c5f4ca557dddfae4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a995c40d03ea8829a7c05836c5f4ca557dddfae4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a995c40d03ea8829a7c05836c5f4ca557dddfae4"}], "stats": {"total": 114, "additions": 69, "deletions": 45}, "files": [{"sha": "cd3bc96303ecfbc4b1c998f76dfff46ed37e5572", "filename": "libiberty/d-demangle.c", "status": "modified", "additions": 61, "deletions": 45, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fff56ce43844d376365c6e057e89bded070f717c/libiberty%2Fd-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fff56ce43844d376365c6e057e89bded070f717c/libiberty%2Fd-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fd-demangle.c?ref=fff56ce43844d376365c6e057e89bded070f717c", "patch": "@@ -31,6 +31,9 @@ If not, see <http://www.gnu.org/licenses/>.  */\n #ifdef HAVE_CONFIG_H\n #include \"config.h\"\n #endif\n+#ifdef HAVE_LIMITS_H\n+#include <limits.h>\n+#endif\n \n #include \"safe-ctype.h\"\n \n@@ -45,6 +48,13 @@ If not, see <http://www.gnu.org/licenses/>.  */\n #include <demangle.h>\n #include \"libiberty.h\"\n \n+#ifndef ULONG_MAX\n+#define\tULONG_MAX\t(~0UL)\n+#endif\n+#ifndef UINT_MAX\n+#define\tUINT_MAX\t(~0U)\n+#endif\n+\n /* A mini string-handling package */\n \n typedef struct string\t\t/* Beware: these aren't required to be */\n@@ -55,9 +65,9 @@ typedef struct string\t\t/* Beware: these aren't required to be */\n } string;\n \n static void\n-string_need (string *s, int n)\n+string_need (string *s, size_t n)\n {\n-  int tem;\n+  size_t tem;\n \n   if (s->b == NULL)\n     {\n@@ -68,7 +78,7 @@ string_need (string *s, int n)\n       s->p = s->b = XNEWVEC (char, n);\n       s->e = s->b + n;\n     }\n-  else if (s->e - s->p < n)\n+  else if ((size_t) (s->e - s->p) < n)\n     {\n       tem = s->p - s->b;\n       n += tem;\n@@ -117,14 +127,14 @@ string_setlength (string *s, int n)\n static void\n string_append (string *p, const char *s)\n {\n-  int n = strlen (s);\n+  size_t n = strlen (s);\n   string_need (p, n);\n   memcpy (p->p, s, n);\n   p->p += n;\n }\n \n static void\n-string_appendn (string *p, const char *s, int n)\n+string_appendn (string *p, const char *s, size_t n)\n {\n   if (n != 0)\n     {\n@@ -135,7 +145,7 @@ string_appendn (string *p, const char *s, int n)\n }\n \n static void\n-string_prependn (string *p, const char *s, int n)\n+string_prependn (string *p, const char *s, size_t n)\n {\n   char *q;\n \n@@ -170,7 +180,7 @@ struct dlang_info\n };\n \n /* Pass as the LEN to dlang_parse_template if symbol length is not known.  */\n-enum { TEMPLATE_LENGTH_UNKNOWN = -1 };\n+#define TEMPLATE_LENGTH_UNKNOWN (-1UL)\n \n /* Prototypes for forward referenced functions */\n static const char *dlang_function_type (string *, const char *,\n@@ -193,38 +203,39 @@ static const char *dlang_parse_tuple (string *, const char *,\n \t\t\t\t      struct dlang_info *);\n \n static const char *dlang_parse_template (string *, const char *,\n-\t\t\t\t\t struct dlang_info *, long);\n+\t\t\t\t\t struct dlang_info *, unsigned long);\n \n-static const char *dlang_lname (string *, const char *, long);\n+static const char *dlang_lname (string *, const char *, unsigned long);\n \n \n /* Extract the number from MANGLED, and assign the result to RET.\n-   Return the remaining string on success or NULL on failure.  */\n+   Return the remaining string on success or NULL on failure.\n+   A result larger than UINT_MAX is considered a failure.  */\n static const char *\n-dlang_number (const char *mangled, long *ret)\n+dlang_number (const char *mangled, unsigned long *ret)\n {\n   /* Return NULL if trying to extract something that isn't a digit.  */\n   if (mangled == NULL || !ISDIGIT (*mangled))\n     return NULL;\n \n-  (*ret) = 0;\n+  unsigned long val = 0;\n \n   while (ISDIGIT (*mangled))\n     {\n-      (*ret) *= 10;\n+      unsigned long digit = mangled[0] - '0';\n \n-      /* If an overflow occured when multiplying by ten, the result\n-\t will not be a multiple of ten.  */\n-      if ((*ret % 10) != 0)\n+      /* Check for overflow.  */\n+      if (val > (UINT_MAX - digit) / 10)\n \treturn NULL;\n \n-      (*ret) += mangled[0] - '0';\n+      val = val * 10 + digit;\n       mangled++;\n     }\n \n-  if (*mangled == '\\0' || *ret < 0)\n+  if (*mangled == '\\0')\n     return NULL;\n \n+  *ret = val;\n   return mangled;\n }\n \n@@ -273,7 +284,8 @@ dlang_call_convention_p (const char *mangled)\n }\n \n /* Extract the back reference position from MANGLED, and assign the result\n-   to RET.  Return the remaining string on success or NULL on failure.  */\n+   to RET.  Return the remaining string on success or NULL on failure.\n+   A result <= 0 is a failure.  */\n static const char *\n dlang_decode_backref (const char *mangled, long *ret)\n {\n@@ -294,24 +306,26 @@ dlang_decode_backref (const char *mangled, long *ret)\n \t    [A-Z] NumberBackRef\n \t    ^\n    */\n-  (*ret) = 0;\n+  unsigned long val = 0;\n \n   while (ISALPHA (*mangled))\n     {\n-      (*ret) *= 26;\n+      /* Check for overflow.  */\n+      if (val > (ULONG_MAX - 25) / 26)\n+\tbreak;\n \n-      /* If an overflow occured when multiplying by 26, the result\n-\t will not be a multiple of 26.  */\n-      if ((*ret % 26) != 0)\n-\treturn NULL;\n+      val *= 26;\n \n       if (mangled[0] >= 'a' && mangled[0] <= 'z')\n \t{\n-\t  (*ret) += mangled[0] - 'a';\n+\t  val += mangled[0] - 'a';\n+\t  if ((long) val <= 0)\n+\t    break;\n+\t  *ret = val;\n \t  return mangled + 1;\n \t}\n \n-      (*ret) += mangled[0] - 'A';\n+      val += mangled[0] - 'A';\n       mangled++;\n     }\n \n@@ -337,7 +351,7 @@ dlang_backref (const char *mangled, const char **ret, struct dlang_info *info)\n   if (mangled == NULL)\n     return NULL;\n \n-  if (refpos <= 0 || refpos > qpos - info->s)\n+  if (refpos > qpos - info->s)\n     return NULL;\n \n   /* Set the position of the back reference.  */\n@@ -359,7 +373,7 @@ dlang_symbol_backref (string *decl, const char *mangled,\n \t    ^\n    */\n   const char *backref;\n-  long len;\n+  unsigned long len;\n \n   /* Get position of the back reference.  */\n   mangled = dlang_backref (mangled, &backref, info);\n@@ -435,7 +449,7 @@ dlang_symbol_name_p (const char *mangled, struct dlang_info *info)\n     return 0;\n \n   mangled = dlang_decode_backref (mangled + 1, &ret);\n-  if (mangled == NULL || ret <= 0 || ret > qref - info->s)\n+  if (mangled == NULL || ret > qref - info->s)\n     return 0;\n \n   return ISDIGIT (qref[-ret]);\n@@ -993,7 +1007,7 @@ dlang_type (string *decl, const char *mangled, struct dlang_info *info)\n static const char *\n dlang_identifier (string *decl, const char *mangled, struct dlang_info *info)\n {\n-  long len;\n+  unsigned long len;\n \n   if (mangled == NULL || *mangled == '\\0')\n     return NULL;\n@@ -1011,7 +1025,7 @@ dlang_identifier (string *decl, const char *mangled, struct dlang_info *info)\n   if (endptr == NULL || len == 0)\n     return NULL;\n \n-  if (strlen (endptr) < (size_t) len)\n+  if (strlen (endptr) < len)\n     return NULL;\n \n   mangled = endptr;\n@@ -1028,7 +1042,7 @@ dlang_identifier (string *decl, const char *mangled, struct dlang_info *info)\n    with special treatment for some magic compiler generted symbols.\n    Return the remaining string on success or NULL on failure.  */\n static const char *\n-dlang_lname (string *decl, const char *mangled, long len)\n+dlang_lname (string *decl, const char *mangled, unsigned long len)\n {\n   switch (len)\n     {\n@@ -1127,7 +1141,7 @@ dlang_parse_integer (string *decl, const char *mangled, char type)\n       char value[20];\n       int pos = sizeof(value);\n       int width = 0;\n-      long val;\n+      unsigned long val;\n \n       mangled = dlang_number (mangled, &val);\n       if (mangled == NULL)\n@@ -1183,7 +1197,7 @@ dlang_parse_integer (string *decl, const char *mangled, char type)\n   else if (type == 'b')\n     {\n       /* Parse boolean value.  */\n-      long val;\n+      unsigned long val;\n \n       mangled = dlang_number (mangled, &val);\n       if (mangled == NULL)\n@@ -1302,7 +1316,7 @@ static const char *\n dlang_parse_string (string *decl, const char *mangled)\n {\n   char type = *mangled;\n-  long len;\n+  unsigned long len;\n \n   mangled++;\n   mangled = dlang_number (mangled, &len);\n@@ -1366,7 +1380,7 @@ dlang_parse_string (string *decl, const char *mangled)\n static const char *\n dlang_parse_arrayliteral (string *decl, const char *mangled)\n {\n-  long elements;\n+  unsigned long elements;\n \n   mangled = dlang_number (mangled, &elements);\n   if (mangled == NULL)\n@@ -1392,7 +1406,7 @@ dlang_parse_arrayliteral (string *decl, const char *mangled)\n static const char *\n dlang_parse_assocarray (string *decl, const char *mangled)\n {\n-  long elements;\n+  unsigned long elements;\n \n   mangled = dlang_number (mangled, &elements);\n   if (mangled == NULL)\n@@ -1423,7 +1437,7 @@ dlang_parse_assocarray (string *decl, const char *mangled)\n static const char *\n dlang_parse_structlit (string *decl, const char *mangled, const char *name)\n {\n-  long args;\n+  unsigned long args;\n \n   mangled = dlang_number (mangled, &args);\n   if (mangled == NULL)\n@@ -1650,7 +1664,7 @@ dlang_parse_qualified (string *decl, const char *mangled,\n static const char *\n dlang_parse_tuple (string *decl, const char *mangled, struct dlang_info *info)\n {\n-  long elements;\n+  unsigned long elements;\n \n   mangled = dlang_number (mangled, &elements);\n   if (mangled == NULL)\n@@ -1685,7 +1699,7 @@ dlang_template_symbol_param (string *decl, const char *mangled,\n   if (*mangled == 'Q')\n     return dlang_parse_qualified (decl, mangled, info, 0);\n \n-  long len;\n+  unsigned long len;\n   const char *endptr = dlang_number (mangled, &len);\n \n   if (endptr == NULL || len == 0)\n@@ -1798,12 +1812,12 @@ dlang_template_args (string *decl, const char *mangled, struct dlang_info *info)\n \t}\n \tcase 'X': /* Externally mangled parameter.  */\n \t{\n-\t  long len;\n+\t  unsigned long len;\n \t  const char *endptr;\n \n \t  mangled++;\n \t  endptr = dlang_number (mangled, &len);\n-\t  if (endptr == NULL || strlen (endptr) < (size_t) len)\n+\t  if (endptr == NULL || strlen (endptr) < len)\n \t    return NULL;\n \n \t  string_appendn (decl, endptr, len);\n@@ -1823,7 +1837,7 @@ dlang_template_args (string *decl, const char *mangled, struct dlang_info *info)\n    Returns the remaining signature on success or NULL on failure.  */\n static const char *\n dlang_parse_template (string *decl, const char *mangled,\n-\t\t      struct dlang_info *info, long len)\n+\t\t      struct dlang_info *info, unsigned long len)\n {\n   const char *start = mangled;\n   string args;\n@@ -1859,7 +1873,9 @@ dlang_parse_template (string *decl, const char *mangled,\n   string_delete (&args);\n \n   /* Check for template name length mismatch.  */\n-  if (len != TEMPLATE_LENGTH_UNKNOWN && mangled && (mangled - start) != len)\n+  if (len != TEMPLATE_LENGTH_UNKNOWN\n+      && mangled\n+      && (unsigned long) (mangled - start) != len)\n     return NULL;\n \n   return mangled;"}, {"sha": "ba0ffed5c8d6b9898b53f3556cd5278b38e1e4f4", "filename": "libiberty/testsuite/d-demangle-expected", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fff56ce43844d376365c6e057e89bded070f717c/libiberty%2Ftestsuite%2Fd-demangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fff56ce43844d376365c6e057e89bded070f717c/libiberty%2Ftestsuite%2Fd-demangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Fd-demangle-expected?ref=fff56ce43844d376365c6e057e89bded070f717c", "patch": "@@ -1140,6 +1140,14 @@ _D4test34__T3barVG3uw3_616263VG3wd3_646566Z1xi\n test.bar!(\"abc\"w, \"def\"d).x\n #\n --format=dlang\n+_D4test21__T3funVwi4294967295Z3funFNaNbNiNfZv\n+test.fun!('\\Uffffffff').fun()\n+#\n+--format=dlang\n+_D4test21__T3funVwi4294967296Z3funFNaNbNiNfZv\n+_D4test21__T3funVwi4294967296Z3funFNaNbNiNfZv\n+#\n+--format=dlang\n _D6plugin8generateFiiZAya\n plugin.generate(int, int)\n #"}]}