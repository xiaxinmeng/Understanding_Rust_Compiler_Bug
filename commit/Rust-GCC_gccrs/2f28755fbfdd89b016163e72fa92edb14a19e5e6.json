{"sha": "2f28755fbfdd89b016163e72fa92edb14a19e5e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmYyODc1NWZiZmRkODliMDE2MTYzZTcyZmE5MmVkYjE0YTE5ZTVlNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-09-25T18:57:44Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-09-25T18:57:44Z"}, "message": "ipa-devirt.c (polymorphic_call_target_d): Add SPECULATIVE; reorder for better storage.\n\n\n\t* ipa-devirt.c (polymorphic_call_target_d): Add SPECULATIVE; reorder\n\tfor better storage.\n\t(polymorphic_call_target_hasher::hash): Hash SPECULATIVE.\n\t(possible_polymorphic_call_targets): Instead of computing both\n\tspeculative and non-speculative answers, do just one at a time.\n\tReplace NONSPECULATIVE_TARGETSP parameter with SPECULATIVE flag.\n\t(dump_targets): Break out from ...\n\t(dump_possible_polymorphic_call_targets): ... here; dump both speculative\n\tand non-speculative lists.\n\t(ipa_devirt): Update for new possible_polymorphic_call_targets API.\n\t* ipa-utils.h (possible_polymorphic_call_targets): Update.\n\n\t* testsuite/g++.dg/ipa/devirt-34.C: Update template.\n\nFrom-SVN: r215614", "tree": {"sha": "633107f19b3832c67e16400b92999b85d3950f0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/633107f19b3832c67e16400b92999b85d3950f0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f28755fbfdd89b016163e72fa92edb14a19e5e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f28755fbfdd89b016163e72fa92edb14a19e5e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f28755fbfdd89b016163e72fa92edb14a19e5e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f28755fbfdd89b016163e72fa92edb14a19e5e6/comments", "author": null, "committer": null, "parents": [{"sha": "0be35aa0a1c35976c8aa3da816afbfe05d4ba4b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0be35aa0a1c35976c8aa3da816afbfe05d4ba4b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0be35aa0a1c35976c8aa3da816afbfe05d4ba4b3"}], "stats": {"total": 338, "additions": 184, "deletions": 154}, "files": [{"sha": "cfc1120c195d04ed9da3c4573c62e9fd9a058bdf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f28755fbfdd89b016163e72fa92edb14a19e5e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f28755fbfdd89b016163e72fa92edb14a19e5e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f28755fbfdd89b016163e72fa92edb14a19e5e6", "patch": "@@ -1,3 +1,17 @@\n+2014-09-25  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-devirt.c (polymorphic_call_target_d): Add SPECULATIVE; reorder\n+\tfor better storage.\n+\t(polymorphic_call_target_hasher::hash): Hash SPECULATIVE.\n+\t(possible_polymorphic_call_targets): Instead of computing both\n+\tspeculative and non-speculative answers, do just one at a time.\n+\tReplace NONSPECULATIVE_TARGETSP parameter with SPECULATIVE flag.\n+\t(dump_targets): Break out from ...\n+\t(dump_possible_polymorphic_call_targets): ... here; dump both speculative\n+\tand non-speculative lists.\n+\t(ipa_devirt): Update for new possible_polymorphic_call_targets API.\n+\t* ipa-utils.h (possible_polymorphic_call_targets): Update.\n+\n 2014-09-25  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR rtl-optimization/63348"}, {"sha": "357a506a651dde982ed76faeb2dfc09125e66601", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 162, "deletions": 150, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f28755fbfdd89b016163e72fa92edb14a19e5e6/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f28755fbfdd89b016163e72fa92edb14a19e5e6/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=2f28755fbfdd89b016163e72fa92edb14a19e5e6", "patch": "@@ -1884,10 +1884,10 @@ struct polymorphic_call_target_d\n   ipa_polymorphic_call_context context;\n   odr_type type;\n   vec <cgraph_node *> targets;\n-  int speculative_targets;\n-  bool complete;\n-  int type_warning;\n   tree decl_warning;\n+  int type_warning;\n+  bool complete;\n+  bool speculative;\n };\n \n /* Polymorphic call target cache helpers.  */\n@@ -1917,6 +1917,7 @@ polymorphic_call_target_hasher::hash (const value_type *odr_query)\n       hstate.merge_hash (TYPE_UID (odr_query->context.speculative_outer_type));\n       hstate.add_wide_int (odr_query->context.speculative_offset);\n     }\n+  hstate.add_flag (odr_query->speculative);\n   hstate.add_flag (odr_query->context.maybe_in_construction);\n   hstate.add_flag (odr_query->context.maybe_derived_type);\n   hstate.add_flag (odr_query->context.speculative_maybe_derived_type);\n@@ -1931,6 +1932,7 @@ polymorphic_call_target_hasher::equal (const value_type *t1,\n \t\t\t\t       const compare_type *t2)\n {\n   return (t1->type == t2->type && t1->otr_token == t2->otr_token\n+\t  && t1->speculative == t2->speculative\n \t  && t1->context.offset == t2->context.offset\n \t  && t1->context.speculative_offset == t2->context.speculative_offset\n \t  && t1->context.outer_type == t2->context.outer_type\n@@ -3667,10 +3669,8 @@ struct final_warning_record *final_warning_records;\n    in the target cache.  If user needs to visit every target list\n    just once, it can memoize them.\n \n-   SPECULATION_TARGETS specify number of targets that are speculatively\n-   likely.  These include targets specified by the speculative part\n-   of polymoprhic call context and also exclude all targets for classes\n-   in construction.\n+   If SPECULATIVE is set, the list will not contain targets that\n+   are not speculatively taken.\n \n    Returned vector is placed into cache.  It is NOT caller's responsibility\n    to free it.  The vector can be freed on cgraph_remove_node call if\n@@ -3682,7 +3682,7 @@ possible_polymorphic_call_targets (tree otr_type,\n \t\t\t\t   ipa_polymorphic_call_context context,\n \t\t\t           bool *completep,\n \t\t\t           void **cache_token,\n-\t\t\t\t   int *speculative_targetsp)\n+\t\t\t\t   bool speculative)\n {\n   static struct cgraph_node_hook_list *node_removal_hook_holder;\n   vec <cgraph_node *> nodes = vNULL;\n@@ -3706,13 +3706,11 @@ possible_polymorphic_call_targets (tree otr_type,\n \t*completep = context.invalid;\n       if (cache_token)\n \t*cache_token = NULL;\n-      if (speculative_targetsp)\n-\t*speculative_targetsp = 0;\n       return nodes;\n     }\n \n   /* Do not bother to compute speculative info when user do not asks for it.  */\n-  if (!speculative_targetsp || !context.speculative_outer_type)\n+  if (!speculative || !context.speculative_outer_type)\n     context.clear_speculation ();\n \n   type = get_odr_type (otr_type, true);\n@@ -3730,8 +3728,6 @@ possible_polymorphic_call_targets (tree otr_type,\n \t*completep = true;\n       if (cache_token)\n \t*cache_token = NULL;\n-      if (speculative_targetsp)\n-\t*speculative_targetsp = 0;\n       return nodes;\n     }\n   gcc_assert (!context.invalid);\n@@ -3783,6 +3779,7 @@ possible_polymorphic_call_targets (tree otr_type,\n   /* Lookup cached answer.  */\n   key.type = type;\n   key.otr_token = otr_token;\n+  key.speculative = speculative;\n   key.context = context;\n   slot = polymorphic_call_target_hash->find_slot (&key, INSERT);\n   if (cache_token)\n@@ -3791,15 +3788,13 @@ possible_polymorphic_call_targets (tree otr_type,\n     {\n       if (completep)\n \t*completep = (*slot)->complete;\n-      if (speculative_targetsp)\n-\t*speculative_targetsp = (*slot)->speculative_targets;\n       if ((*slot)->type_warning && final_warning_records)\n \t{\n \t  final_warning_records->type_warnings[(*slot)->type_warning - 1].count++;\n \t  final_warning_records->type_warnings[(*slot)->type_warning - 1].dyn_count\n \t    += final_warning_records->dyn_count;\n \t}\n-      if ((*slot)->decl_warning && final_warning_records)\n+      if (!speculative && (*slot)->decl_warning && final_warning_records)\n \t{\n \t  struct decl_warn_count *c =\n \t     final_warning_records->decl_warnings.get ((*slot)->decl_warning);\n@@ -3819,7 +3814,7 @@ possible_polymorphic_call_targets (tree otr_type,\n   (*slot)->type = type;\n   (*slot)->otr_token = otr_token;\n   (*slot)->context = context;\n-  (*slot)->speculative_targets = 0;\n+  (*slot)->speculative = speculative;\n \n   hash_set<tree> inserted;\n   hash_set<tree> matched_vtables;\n@@ -3864,137 +3859,136 @@ possible_polymorphic_call_targets (tree otr_type,\n \t\t\t\t\t       &speculation_complete,\n \t\t\t\t\t       bases_to_consider,\n \t\t\t\t\t       false);\n-      (*slot)->speculative_targets = nodes.length();\n     }\n \n-  /* First see virtual method of type itself.  */\n-  binfo = get_binfo_at_offset (TYPE_BINFO (outer_type->type),\n-\t\t\t       context.offset, otr_type);\n-  if (binfo)\n-    target = gimple_get_virt_method_for_binfo (otr_token, binfo,\n-\t\t\t\t\t       &can_refer);\n-  else\n+  if (!speculative || !nodes.length ())\n     {\n-      gcc_assert (odr_violation_reported);\n-      target = NULL;\n-    }\n+      /* First see virtual method of type itself.  */\n+      binfo = get_binfo_at_offset (TYPE_BINFO (outer_type->type),\n+\t\t\t\t   context.offset, otr_type);\n+      if (binfo)\n+\ttarget = gimple_get_virt_method_for_binfo (otr_token, binfo,\n+\t\t\t\t\t\t   &can_refer);\n+      else\n+\t{\n+\t  gcc_assert (odr_violation_reported);\n+\t  target = NULL;\n+\t}\n \n-  /* Destructors are never called through construction virtual tables,\n-     because the type is always known.  */\n-  if (target && DECL_CXX_DESTRUCTOR_P (target))\n-    context.maybe_in_construction = false;\n+      /* Destructors are never called through construction virtual tables,\n+\t because the type is always known.  */\n+      if (target && DECL_CXX_DESTRUCTOR_P (target))\n+\tcontext.maybe_in_construction = false;\n \n-  if (target)\n-    {\n-      /* In the case we get complete method, we don't need \n-\t to walk derivations.  */\n-      if (DECL_FINAL_P (target))\n-\tcontext.maybe_derived_type = false;\n-    }\n+      if (target)\n+\t{\n+\t  /* In the case we get complete method, we don't need \n+\t     to walk derivations.  */\n+\t  if (DECL_FINAL_P (target))\n+\t    context.maybe_derived_type = false;\n+\t}\n \n-  /* If OUTER_TYPE is abstract, we know we are not seeing its instance.  */\n-  if (type_possibly_instantiated_p (outer_type->type))\n-    maybe_record_node (nodes, target, &inserted, can_refer, &complete);\n-  else\n-    skipped = true;\n+      /* If OUTER_TYPE is abstract, we know we are not seeing its instance.  */\n+      if (type_possibly_instantiated_p (outer_type->type))\n+\tmaybe_record_node (nodes, target, &inserted, can_refer, &complete);\n+      else\n+\tskipped = true;\n \n-  if (binfo)\n-    matched_vtables.add (BINFO_VTABLE (binfo));\n+      if (binfo)\n+\tmatched_vtables.add (BINFO_VTABLE (binfo));\n \n-  /* Next walk recursively all derived types.  */\n-  if (context.maybe_derived_type)\n-    {\n-      for (i = 0; i < outer_type->derived_types.length(); i++)\n-\tpossible_polymorphic_call_targets_1 (nodes, &inserted,\n-\t\t\t\t\t     &matched_vtables,\n-\t\t\t\t\t     otr_type,\n-\t\t\t\t\t     outer_type->derived_types[i],\n-\t\t\t\t\t     otr_token, outer_type->type,\n-\t\t\t\t\t     context.offset, &complete,\n-\t\t\t\t\t     bases_to_consider,\n-\t\t\t\t\t     context.maybe_in_construction);\n-\n-      if (!outer_type->all_derivations_known)\n+      /* Next walk recursively all derived types.  */\n+      if (context.maybe_derived_type)\n \t{\n-\t  if (final_warning_records)\n+\t  for (i = 0; i < outer_type->derived_types.length(); i++)\n+\t    possible_polymorphic_call_targets_1 (nodes, &inserted,\n+\t\t\t\t\t\t &matched_vtables,\n+\t\t\t\t\t\t otr_type,\n+\t\t\t\t\t\t outer_type->derived_types[i],\n+\t\t\t\t\t\t otr_token, outer_type->type,\n+\t\t\t\t\t\t context.offset, &complete,\n+\t\t\t\t\t\t bases_to_consider,\n+\t\t\t\t\t\t context.maybe_in_construction);\n+\n+\t  if (!outer_type->all_derivations_known)\n \t    {\n-\t      if (complete\n-\t\t  && nodes.length () == 1\n-\t\t  && warn_suggest_final_types\n-\t\t  && !outer_type->derived_types.length ())\n+\t      if (!speculative && final_warning_records)\n \t\t{\n-\t\t  if (outer_type->id >= (int)final_warning_records->type_warnings.length ())\n-\t            final_warning_records->type_warnings.safe_grow_cleared\n-\t\t      (odr_types.length ());\n-\t\t  final_warning_records->type_warnings[outer_type->id].count++;\n-\t\t  final_warning_records->type_warnings[outer_type->id].dyn_count\n-\t\t    += final_warning_records->dyn_count;\n-\t\t  final_warning_records->type_warnings[outer_type->id].type\n-\t\t    = outer_type->type;\n-\t\t  (*slot)->type_warning = outer_type->id + 1;\n-\t\t}\n-\t      if (complete\n-\t\t  && warn_suggest_final_methods\n-\t\t  && nodes.length () == 1\n-\t\t  && types_same_for_odr (DECL_CONTEXT (nodes[0]->decl),\n-\t\t\t\t\t outer_type->type))\n-\t\t{\n-\t\t  bool existed;\n-\t\t  struct decl_warn_count &c =\n-\t\t     final_warning_records->decl_warnings.get_or_insert\n-\t\t\t(nodes[0]->decl, &existed);\n-\n-\t\t  if (existed)\n+\t\t  if (complete\n+\t\t      && nodes.length () == 1\n+\t\t      && warn_suggest_final_types\n+\t\t      && !outer_type->derived_types.length ())\n \t\t    {\n-\t\t      c.count++;\n-\t\t      c.dyn_count += final_warning_records->dyn_count;\n+\t\t      if (outer_type->id >= (int)final_warning_records->type_warnings.length ())\n+\t\t\tfinal_warning_records->type_warnings.safe_grow_cleared\n+\t\t\t  (odr_types.length ());\n+\t\t      final_warning_records->type_warnings[outer_type->id].count++;\n+\t\t      final_warning_records->type_warnings[outer_type->id].dyn_count\n+\t\t\t+= final_warning_records->dyn_count;\n+\t\t      final_warning_records->type_warnings[outer_type->id].type\n+\t\t\t= outer_type->type;\n+\t\t      (*slot)->type_warning = outer_type->id + 1;\n \t\t    }\n-\t\t  else\n+\t\t  if (complete\n+\t\t      && warn_suggest_final_methods\n+\t\t      && nodes.length () == 1\n+\t\t      && types_same_for_odr (DECL_CONTEXT (nodes[0]->decl),\n+\t\t\t\t\t     outer_type->type))\n \t\t    {\n-\t\t      c.count = 1;\n-\t\t      c.dyn_count = final_warning_records->dyn_count;\n-\t\t      c.decl = nodes[0]->decl;\n+\t\t      bool existed;\n+\t\t      struct decl_warn_count &c =\n+\t\t\t final_warning_records->decl_warnings.get_or_insert\n+\t\t\t    (nodes[0]->decl, &existed);\n+\n+\t\t      if (existed)\n+\t\t\t{\n+\t\t\t  c.count++;\n+\t\t\t  c.dyn_count += final_warning_records->dyn_count;\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  c.count = 1;\n+\t\t\t  c.dyn_count = final_warning_records->dyn_count;\n+\t\t\t  c.decl = nodes[0]->decl;\n+\t\t\t}\n+\t\t      (*slot)->decl_warning = nodes[0]->decl;\n \t\t    }\n-\t\t  (*slot)->decl_warning = nodes[0]->decl;\n \t\t}\n+\t      complete = false;\n \t    }\n-\t  complete = false;\n \t}\n-    }\n-\n-  /* Finally walk bases, if asked to.  */\n-  if (!(*slot)->speculative_targets)\n-    (*slot)->speculative_targets = nodes.length();\n \n-  /* Destructors are never called through construction virtual tables,\n-     because the type is always known.  One of entries may be cxa_pure_virtual\n-     so look to at least two of them.  */\n-  if (context.maybe_in_construction)\n-    for (i =0 ; i < MIN (nodes.length (), 2); i++)\n-      if (DECL_CXX_DESTRUCTOR_P (nodes[i]->decl))\n-\tcontext.maybe_in_construction = false;\n-  if (context.maybe_in_construction)\n-    {\n-      if (type != outer_type\n-\t  && (!skipped\n-\t      || (context.maybe_derived_type\n-\t          && !type_all_derivations_known_p (outer_type->type))))\n-\trecord_targets_from_bases (otr_type, otr_token, outer_type->type,\n-\t\t\t\t   context.offset, nodes, &inserted,\n-\t\t\t\t   &matched_vtables, &complete);\n-      if (skipped)\n-        maybe_record_node (nodes, target, &inserted, can_refer, &complete);\n-      for (i = 0; i < bases_to_consider.length(); i++)\n-        maybe_record_node (nodes, bases_to_consider[i], &inserted, can_refer, &complete);\n+      if (!speculative)\n+\t{\n+\t  /* Destructors are never called through construction virtual tables,\n+\t     because the type is always known.  One of entries may be cxa_pure_virtual\n+\t     so look to at least two of them.  */\n+\t  if (context.maybe_in_construction)\n+\t    for (i =0 ; i < MIN (nodes.length (), 2); i++)\n+\t      if (DECL_CXX_DESTRUCTOR_P (nodes[i]->decl))\n+\t\tcontext.maybe_in_construction = false;\n+\t  if (context.maybe_in_construction)\n+\t    {\n+\t      if (type != outer_type\n+\t\t  && (!skipped\n+\t\t      || (context.maybe_derived_type\n+\t\t\t  && !type_all_derivations_known_p (outer_type->type))))\n+\t\trecord_targets_from_bases (otr_type, otr_token, outer_type->type,\n+\t\t\t\t\t   context.offset, nodes, &inserted,\n+\t\t\t\t\t   &matched_vtables, &complete);\n+\t      if (skipped)\n+\t\tmaybe_record_node (nodes, target, &inserted, can_refer, &complete);\n+\t      for (i = 0; i < bases_to_consider.length(); i++)\n+\t\tmaybe_record_node (nodes, bases_to_consider[i], &inserted, can_refer, &complete);\n+\t    }\n+\t}\n     }\n-  bases_to_consider.release();\n \n+  bases_to_consider.release();\n   (*slot)->targets = nodes;\n   (*slot)->complete = complete;\n   if (completep)\n     *completep = complete;\n-  if (speculative_targetsp)\n-    *speculative_targetsp = (*slot)->speculative_targets;\n \n   timevar_pop (TV_IPA_VIRTUAL_CALL);\n   return nodes;\n@@ -4008,6 +4002,29 @@ add_decl_warning (const tree &key ATTRIBUTE_UNUSED, const decl_warn_count &value\n   return true;\n }\n \n+/* Dump target list TARGETS into FILE.  */\n+\n+static void\n+dump_targets (FILE *f, vec <cgraph_node *> targets)\n+{\n+  unsigned int i;\n+\n+  for (i = 0; i < targets.length (); i++)\n+    {\n+      char *name = NULL;\n+      if (in_lto_p)\n+\tname = cplus_demangle_v3 (targets[i]->asm_name (), 0);\n+      fprintf (f, \" %s/%i\", name ? name : targets[i]->name (), targets[i]->order);\n+      if (in_lto_p)\n+\tfree (name);\n+      if (!targets[i]->definition)\n+\tfprintf (f, \" (no definition%s)\",\n+\t\t DECL_DECLARED_INLINE_P (targets[i]->decl)\n+\t\t ? \" inline\" : \"\");\n+    }\n+  fprintf (f, \"\\n\");\n+}\n+\n /* Dump all possible targets of a polymorphic call.  */\n \n void\n@@ -4019,14 +4036,13 @@ dump_possible_polymorphic_call_targets (FILE *f,\n   vec <cgraph_node *> targets;\n   bool final;\n   odr_type type = get_odr_type (TYPE_MAIN_VARIANT (otr_type), false);\n-  unsigned int i;\n-  int speculative;\n+  unsigned int len;\n \n   if (!type)\n     return;\n   targets = possible_polymorphic_call_targets (otr_type, otr_token,\n \t\t\t\t\t       ctx,\n-\t\t\t\t\t       &final, NULL, &speculative);\n+\t\t\t\t\t       &final, NULL, false);\n   fprintf (f, \"  Targets of polymorphic call of type %i:\", type->id);\n   print_generic_expr (f, type->type, TDF_SLIM);\n   fprintf (f, \" token %i\\n\", (int)otr_token);\n@@ -4039,23 +4055,19 @@ dump_possible_polymorphic_call_targets (FILE *f,\n \t   ctx.maybe_in_construction ? \" (base types included)\" : \"\",\n \t   ctx.maybe_derived_type ? \" (derived types included)\" : \"\",\n \t   ctx.speculative_maybe_derived_type ? \" (speculative derived types included)\" : \"\");\n-  for (i = 0; i < targets.length (); i++)\n+  len = targets.length ();\n+  dump_targets (f, targets);\n+\n+  targets = possible_polymorphic_call_targets (otr_type, otr_token,\n+\t\t\t\t\t       ctx,\n+\t\t\t\t\t       &final, NULL, true);\n+  gcc_assert (targets.length () <= len);\n+  if (targets.length () != len)\n     {\n-      char *name = NULL;\n-      if (i == (unsigned)speculative)\n-\tfprintf (f, \"\\n     Targets that are not likely:\\n\"\n-\t\t \"      \");\n-      if (in_lto_p)\n-\tname = cplus_demangle_v3 (targets[i]->asm_name (), 0);\n-      fprintf (f, \" %s/%i\", name ? name : targets[i]->name (), targets[i]->order);\n-      if (in_lto_p)\n-\tfree (name);\n-      if (!targets[i]->definition)\n-\tfprintf (f, \" (no definition%s)\",\n-\t\t DECL_DECLARED_INLINE_P (targets[i]->decl)\n-\t\t ? \" inline\" : \"\");\n+      fprintf (f, \"  Speculative targets:\");\n+      dump_targets (f, targets);\n     }\n-  fprintf (f, \"\\n\\n\");\n+  fprintf (f, \"\\n\");\n }\n \n \n@@ -4241,16 +4253,19 @@ ipa_devirt (void)\n \t    struct cgraph_node *likely_target = NULL;\n \t    void *cache_token;\n \t    bool final;\n-\t    int speculative_targets;\n \n \t    if (final_warning_records)\n \t      final_warning_records->dyn_count = e->count;\n \n \t    vec <cgraph_node *>targets\n \t       = possible_polymorphic_call_targets\n-\t\t    (e, &final, &cache_token, &speculative_targets);\n+\t\t    (e, &final, &cache_token, true);\n \t    unsigned int i;\n \n+\t    /* Trigger warnings by calculating non-speculative targets.  */\n+\t    if (warn_suggest_final_methods || warn_suggest_final_types)\n+\t      possible_polymorphic_call_targets (e);\n+\n \t    if (dump_file)\n \t      dump_possible_polymorphic_call_targets \n \t\t(dump_file, e);\n@@ -4289,13 +4304,10 @@ ipa_devirt (void)\n \t\t{\n \t\t  if (likely_target)\n \t\t    {\n-\t\t      if (i < (unsigned) speculative_targets)\n-\t\t\t{\n-\t\t\t  likely_target = NULL;\n-\t\t\t  if (dump_file)\n-\t\t\t    fprintf (dump_file, \"More than one likely target\\n\\n\");\n-\t\t\t  nmultiple++;\n-\t\t\t}\n+\t\t      likely_target = NULL;\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file, \"More than one likely target\\n\\n\");\n+\t\t      nmultiple++;\n \t\t      break;\n \t\t    }\n \t\t  likely_target = targets[i];"}, {"sha": "494397b76a4743c654906e3d0c73c2a768932edd", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f28755fbfdd89b016163e72fa92edb14a19e5e6/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f28755fbfdd89b016163e72fa92edb14a19e5e6/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=2f28755fbfdd89b016163e72fa92edb14a19e5e6", "patch": "@@ -62,7 +62,7 @@ possible_polymorphic_call_targets (tree, HOST_WIDE_INT,\n \t\t\t\t   ipa_polymorphic_call_context,\n \t\t\t\t   bool *copletep = NULL,\n \t\t\t\t   void **cache_token = NULL,\n-\t\t\t\t   int *nonconstruction_targets = NULL);\n+\t\t\t\t   bool speuclative = false);\n odr_type get_odr_type (tree, bool insert = false);\n bool possible_polymorphic_call_target_p (tree ref, gimple stmt, struct cgraph_node *n);\n void dump_possible_polymorphic_call_targets (FILE *, tree, HOST_WIDE_INT,\n@@ -92,15 +92,15 @@ inline vec <cgraph_node *>\n possible_polymorphic_call_targets (struct cgraph_edge *e,\n \t\t\t\t   bool *completep = NULL,\n \t\t\t\t   void **cache_token = NULL,\n-\t\t\t\t   int *nonconstruction_targets = NULL)\n+\t\t\t\t   bool speculative = false)\n {\n   ipa_polymorphic_call_context context(e);\n \n   return possible_polymorphic_call_targets (e->indirect_info->otr_type,\n \t\t\t\t\t    e->indirect_info->otr_token,\n \t\t\t\t\t    context,\n \t\t\t\t\t    completep, cache_token,\n-\t\t\t\t\t    nonconstruction_targets);\n+\t\t\t\t\t    speculative);\n }\n \n /* Same as above but taking OBJ_TYPE_REF as an parameter.  */"}, {"sha": "57ae679a97ef16055997e05c7cd2ad404dd0aa42", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f28755fbfdd89b016163e72fa92edb14a19e5e6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f28755fbfdd89b016163e72fa92edb14a19e5e6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2f28755fbfdd89b016163e72fa92edb14a19e5e6", "patch": "@@ -1,3 +1,7 @@\n+2014-09-25  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* testsuite/g++.dg/ipa/devirt-34.C: Update template.\n+\n 2014-09-25  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* gcc.target/aarch64/simd/vqshlb_1.c: New."}, {"sha": "6487f8ee3d901579b3f442a446541c4f0c2e35e9", "filename": "gcc/testsuite/g++.dg/ipa/devirt-34.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f28755fbfdd89b016163e72fa92edb14a19e5e6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-34.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f28755fbfdd89b016163e72fa92edb14a19e5e6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-34.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-34.C?ref=2f28755fbfdd89b016163e72fa92edb14a19e5e6", "patch": "@@ -15,6 +15,6 @@ t(struct B *b)\n /* We should guess that the pointer of type B probably points to an instance\n    of B or its derivates and exclude A::t from list of likely targets.  */\n \n-/* { dg-final { scan-ipa-dump \"Targets that are not likely\"  \"devirt\"  } } */\n+/* { dg-final { scan-ipa-dump \"Speculative targets\"  \"devirt\"  } } */\n /* { dg-final { scan-ipa-dump \"1 speculatively devirtualized\"  \"devirt\"  } } */\n /* { dg-final { cleanup-ipa-dump \"devirt\" } } */"}]}