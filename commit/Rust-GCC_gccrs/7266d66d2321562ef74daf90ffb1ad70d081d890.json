{"sha": "7266d66d2321562ef74daf90ffb1ad70d081d890", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzI2NmQ2NmQyMzIxNTYyZWY3NGRhZjkwZmZiMWFkNzBkMDgxZDg5MA==", "commit": {"author": {"name": "Nala Ginrut", "email": "mulei@gnu.org", "date": "2020-04-29T16:22:36Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-27T18:07:04Z"}, "message": "Fix indentation", "tree": {"sha": "89ad46fd0e85eed625eac6ceba9b04d770b0390a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89ad46fd0e85eed625eac6ceba9b04d770b0390a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7266d66d2321562ef74daf90ffb1ad70d081d890", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7266d66d2321562ef74daf90ffb1ad70d081d890", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7266d66d2321562ef74daf90ffb1ad70d081d890", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7266d66d2321562ef74daf90ffb1ad70d081d890/comments", "author": {"login": "NalaGinrut", "id": 19734, "node_id": "MDQ6VXNlcjE5NzM0", "avatar_url": "https://avatars.githubusercontent.com/u/19734?v=4", "gravatar_id": "", "url": "https://api.github.com/users/NalaGinrut", "html_url": "https://github.com/NalaGinrut", "followers_url": "https://api.github.com/users/NalaGinrut/followers", "following_url": "https://api.github.com/users/NalaGinrut/following{/other_user}", "gists_url": "https://api.github.com/users/NalaGinrut/gists{/gist_id}", "starred_url": "https://api.github.com/users/NalaGinrut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/NalaGinrut/subscriptions", "organizations_url": "https://api.github.com/users/NalaGinrut/orgs", "repos_url": "https://api.github.com/users/NalaGinrut/repos", "events_url": "https://api.github.com/users/NalaGinrut/events{/privacy}", "received_events_url": "https://api.github.com/users/NalaGinrut/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89d78a4a9e0af7e4a7da88c3e6d7688b8423fc39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89d78a4a9e0af7e4a7da88c3e6d7688b8423fc39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89d78a4a9e0af7e4a7da88c3e6d7688b8423fc39"}], "stats": {"total": 27031, "additions": 14451, "deletions": 12580}, "files": [{"sha": "7d530d2ede023a07cbf913e09fde307ba7003422", "filename": "gcc/rust/ast/clone-test.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Fast%2Fclone-test.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Fast%2Fclone-test.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Fclone-test.h?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -87,4 +87,4 @@ namespace user_code {\n }\n #endif\n \n-#endif\n\\ No newline at end of file\n+#endif"}, {"sha": "fa400f166bbdc5c77f6f657e87df84817eadab38", "filename": "gcc/rust/ast/rust-ast-containers.h", "status": "modified", "additions": 44, "deletions": 39, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Fast%2Frust-ast-containers.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Fast%2Frust-ast-containers.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-containers.h?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -2,47 +2,52 @@\n #define RUST_AST_CONTAINERS_H\n // crappy redefined AST maybe. may move\n \n-/* This is mainly the \"logical\", more \"abstract\" representation of the code, while the \"AST\" itself is\n- * more high-level and matches the language better. */\n+/* This is mainly the \"logical\", more \"abstract\" representation of the code,\n+ * while the \"AST\" itself is more high-level and matches the language better. */\n \n // this is now deprecated and replaced with the proper AST\n #error \"rust-ast-containers.h was included by accident. Don't use.\"\n \n namespace Rust {\n-    namespace AST {\n-        struct Module {\n-          public:\n-        };\n-\n-        struct Crate {\n-          public:\n-            Module root_module;\n-        };\n-\n-        // replace with rust-types.h version\n-        struct AttributeList {\n-          public:\n-            //::std::vector<Attribute> attribs;\n-        };\n-\n-        // replace with rust-types.h version\n-        struct Visibility {};\n-\n-        /*enum VisibilityType {\n-            Private,\n-            PublicFull,\n-            PublicInPath,\n-            PublicCrate,\n-            PublicSuper,\n-            PublicSelfModule\n-        };\n-\n-        // Represents visibility - maybe make into an enum or union or something\n-        struct Visibility {\n-        }; \n-\n-        */\n-    }\n-}\n-\n-#endif\n\\ No newline at end of file\n+namespace AST {\n+struct Module\n+{\n+public:\n+};\n+\n+struct Crate\n+{\n+public:\n+  Module root_module;\n+};\n+\n+// replace with rust-types.h version\n+struct AttributeList\n+{\n+public:\n+  //::std::vector<Attribute> attribs;\n+};\n+\n+// replace with rust-types.h version\n+struct Visibility\n+{\n+};\n+\n+/*enum VisibilityType {\n+    Private,\n+    PublicFull,\n+    PublicInPath,\n+    PublicCrate,\n+    PublicSuper,\n+    PublicSelfModule\n+};\n+\n+// Represents visibility - maybe make into an enum or union or something\n+struct Visibility {\n+};\n+\n+*/\n+} // namespace AST\n+} // namespace Rust\n+\n+#endif"}, {"sha": "eb680b824a281bab2d199a9168e3a2ed71a9aa55", "filename": "gcc/rust/ast/rust-ast-visitor.h", "status": "modified", "additions": 211, "deletions": 209, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Fast%2Frust-ast-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Fast%2Frust-ast-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-visitor.h?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -1,224 +1,226 @@\n #ifndef RUST_AST_VISITOR_H\n #define RUST_AST_VISITOR_H\n-// Visitor base for AST \n+// Visitor base for AST\n \n // full include not required - only forward decls\n #include \"rust-ast-full-decls.h\"\n \n namespace Rust {\n-    namespace AST {\n-        // Pure abstract class that provides an interface for accessing different classes of the AST. \n-        class ASTVisitor {\n-          public:\n-            // only concrete class overloads are required\n+namespace AST {\n+// Pure abstract class that provides an interface for accessing different\n+// classes of the AST.\n+class ASTVisitor\n+{\n+public:\n+  // only concrete class overloads are required\n \n-            // rust-ast.h\n-            //virtual void visit(AttrInput& attr_input) = 0;\n-            //virtual void visit(TokenTree& token_tree) = 0;\n-            //virtual void visit(MacroMatch& macro_match) = 0;\n-            virtual void visit(Token& tok) = 0;\n-            virtual void visit(DelimTokenTree& delim_tok_tree) = 0;\n-            virtual void visit(AttrInputMetaItemContainer& input) = 0;\n-            //virtual void visit(MetaItem& meta_item) = 0;\n-            //virtual void visit(Stmt& stmt) = 0;\n-            //virtual void visit(Expr& expr) = 0;\n-            virtual void visit(IdentifierExpr& ident_expr) = 0;\n-            //virtual void visit(Pattern& pattern) = 0;\n-            //virtual void visit(Type& type) = 0;\n-            //virtual void visit(TypeParamBound& type_param_bound) = 0;\n-            virtual void visit(Lifetime& lifetime) = 0;\n-            //virtual void visit(GenericParam& generic_param) = 0;\n-            virtual void visit(LifetimeParam& lifetime_param) = 0;\n-            //virtual void visit(TraitItem& trait_item) = 0;\n-            //virtual void visit(InherentImplItem& inherent_impl_item) = 0;\n-            //virtual void visit(TraitImplItem& trait_impl_item) = 0;\n-            virtual void visit(MacroInvocationSemi& macro) = 0;\n-            \n-            // rust-path.h\n-            virtual void visit(PathInExpression& path) = 0;\n-            virtual void visit(TypePathSegment& segment) = 0;\n-            virtual void visit(TypePathSegmentGeneric& segment) = 0;\n-            virtual void visit(TypePathSegmentFunction& segment) = 0;\n-            virtual void visit(TypePath& path) = 0;\n-            virtual void visit(QualifiedPathInExpression& path) = 0;\n-            virtual void visit(QualifiedPathInType& path) = 0;\n+  // rust-ast.h\n+  // virtual void visit(AttrInput& attr_input) = 0;\n+  // virtual void visit(TokenTree& token_tree) = 0;\n+  // virtual void visit(MacroMatch& macro_match) = 0;\n+  virtual void visit (Token &tok) = 0;\n+  virtual void visit (DelimTokenTree &delim_tok_tree) = 0;\n+  virtual void visit (AttrInputMetaItemContainer &input) = 0;\n+  // virtual void visit(MetaItem& meta_item) = 0;\n+  // virtual void visit(Stmt& stmt) = 0;\n+  // virtual void visit(Expr& expr) = 0;\n+  virtual void visit (IdentifierExpr &ident_expr) = 0;\n+  // virtual void visit(Pattern& pattern) = 0;\n+  // virtual void visit(Type& type) = 0;\n+  // virtual void visit(TypeParamBound& type_param_bound) = 0;\n+  virtual void visit (Lifetime &lifetime) = 0;\n+  // virtual void visit(GenericParam& generic_param) = 0;\n+  virtual void visit (LifetimeParam &lifetime_param) = 0;\n+  // virtual void visit(TraitItem& trait_item) = 0;\n+  // virtual void visit(InherentImplItem& inherent_impl_item) = 0;\n+  // virtual void visit(TraitImplItem& trait_impl_item) = 0;\n+  virtual void visit (MacroInvocationSemi &macro) = 0;\n \n-            // rust-expr.h\n-            virtual void visit(LiteralExpr& expr) = 0;\n-            virtual void visit(AttrInputLiteral& attr_input) = 0;\n-            virtual void visit(MetaItemLitExpr& meta_item) = 0;\n-            virtual void visit(MetaItemPathLit& meta_item) = 0;\n-            virtual void visit(BorrowExpr& expr) = 0;\n-            virtual void visit(DereferenceExpr& expr) = 0;\n-            virtual void visit(ErrorPropagationExpr& expr) = 0;\n-            virtual void visit(NegationExpr& expr) = 0;\n-            virtual void visit(ArithmeticOrLogicalExpr& expr) = 0;\n-            virtual void visit(ComparisonExpr& expr) = 0;\n-            virtual void visit(LazyBooleanExpr& expr) = 0;\n-            virtual void visit(TypeCastExpr& expr) = 0;\n-            virtual void visit(AssignmentExpr& expr) = 0;\n-            virtual void visit(CompoundAssignmentExpr& expr) = 0;\n-            virtual void visit(GroupedExpr& expr) = 0;\n-            //virtual void visit(ArrayElems& elems) = 0;\n-            virtual void visit(ArrayElemsValues& elems) = 0;\n-            virtual void visit(ArrayElemsCopied& elems) = 0;\n-            virtual void visit(ArrayExpr& expr) = 0;\n-            virtual void visit(ArrayIndexExpr& expr) = 0;\n-            virtual void visit(TupleExpr& expr) = 0;\n-            virtual void visit(TupleIndexExpr& expr) = 0;\n-            virtual void visit(StructExprStruct& expr) = 0;\n-            //virtual void visit(StructExprField& field) = 0;\n-            virtual void visit(StructExprFieldIdentifier& field) = 0;\n-            virtual void visit(StructExprFieldIdentifierValue& field) = 0;\n-            virtual void visit(StructExprFieldIndexValue& field) = 0;\n-            virtual void visit(StructExprStructFields& expr) = 0;\n-            virtual void visit(StructExprStructBase& expr) = 0;\n-            virtual void visit(StructExprTuple& expr) = 0;\n-            virtual void visit(StructExprUnit& expr) = 0;\n-            //virtual void visit(EnumExprField& field) = 0;\n-            virtual void visit(EnumExprFieldIdentifier& field) = 0;\n-            virtual void visit(EnumExprFieldIdentifierValue& field) = 0;\n-            virtual void visit(EnumExprFieldIndexValue& field) = 0;\n-            virtual void visit(EnumExprStruct& expr) = 0;\n-            virtual void visit(EnumExprTuple& expr) = 0;\n-            virtual void visit(EnumExprFieldless& expr) = 0;\n-            virtual void visit(CallExpr& expr) = 0;\n-            virtual void visit(MethodCallExpr& expr) = 0;\n-            virtual void visit(FieldAccessExpr& expr) = 0;\n-            virtual void visit(ClosureExprInner& expr) = 0;\n-            virtual void visit(BlockExpr& expr) = 0;\n-            virtual void visit(ClosureExprInnerTyped& expr) = 0;\n-            virtual void visit(ContinueExpr& expr) = 0;\n-            virtual void visit(BreakExpr& expr) = 0;\n-            virtual void visit(RangeFromToExpr& expr) = 0;\n-            virtual void visit(RangeFromExpr& expr) = 0;\n-            virtual void visit(RangeToExpr& expr) = 0;\n-            virtual void visit(RangeFullExpr& expr) = 0;\n-            virtual void visit(RangeFromToInclExpr& expr) = 0;\n-            virtual void visit(RangeToInclExpr& expr) = 0;\n-            virtual void visit(ReturnExpr& expr) = 0;\n-            virtual void visit(UnsafeBlockExpr& expr) = 0;\n-            virtual void visit(LoopExpr& expr) = 0;\n-            virtual void visit(WhileLoopExpr& expr) = 0;\n-            virtual void visit(WhileLetLoopExpr& expr) = 0;\n-            virtual void visit(ForLoopExpr& expr) = 0;\n-            virtual void visit(IfExpr& expr) = 0;\n-            virtual void visit(IfExprConseqElse& expr) = 0;\n-            virtual void visit(IfExprConseqIf& expr) = 0;\n-            virtual void visit(IfExprConseqIfLet& expr) = 0;\n-            virtual void visit(IfLetExpr& expr) = 0;\n-            virtual void visit(IfLetExprConseqElse& expr) = 0;\n-            virtual void visit(IfLetExprConseqIf& expr) = 0;\n-            virtual void visit(IfLetExprConseqIfLet& expr) = 0;\n-            //virtual void visit(MatchCase& match_case) = 0;\n-            virtual void visit(MatchCaseBlockExpr& match_case) = 0;\n-            virtual void visit(MatchCaseExpr& match_case) = 0;\n-            virtual void visit(MatchExpr& expr) = 0;\n-            virtual void visit(AwaitExpr& expr) = 0;\n-            virtual void visit(AsyncBlockExpr& expr) = 0;\n+  // rust-path.h\n+  virtual void visit (PathInExpression &path) = 0;\n+  virtual void visit (TypePathSegment &segment) = 0;\n+  virtual void visit (TypePathSegmentGeneric &segment) = 0;\n+  virtual void visit (TypePathSegmentFunction &segment) = 0;\n+  virtual void visit (TypePath &path) = 0;\n+  virtual void visit (QualifiedPathInExpression &path) = 0;\n+  virtual void visit (QualifiedPathInType &path) = 0;\n \n-            // rust-item.h\n-            virtual void visit(TypeParam& param) = 0;\n-            //virtual void visit(WhereClauseItem& item) = 0;\n-            virtual void visit(LifetimeWhereClauseItem& item) = 0;\n-            virtual void visit(TypeBoundWhereClauseItem& item) = 0;\n-            virtual void visit(Method& method) = 0;\n-            virtual void visit(ModuleBodied& module) = 0;\n-            virtual void visit(ModuleNoBody& module) = 0;\n-            virtual void visit(ExternCrate& crate) = 0;\n-            //virtual void visit(UseTree& use_tree) = 0;\n-            virtual void visit(UseTreeGlob& use_tree) = 0;\n-            virtual void visit(UseTreeList& use_tree) = 0;\n-            virtual void visit(UseTreeRebind& use_tree) = 0;\n-            virtual void visit(UseDeclaration& use_decl) = 0;\n-            virtual void visit(Function& function) = 0;\n-            virtual void visit(TypeAlias& type_alias) = 0;\n-            virtual void visit(StructStruct& struct_item) = 0;\n-            virtual void visit(TupleStruct& tuple_struct) = 0;\n-            virtual void visit(EnumItem& item) = 0;\n-            virtual void visit(EnumItemTuple& item) = 0;\n-            virtual void visit(EnumItemStruct& item) = 0;\n-            virtual void visit(EnumItemDiscriminant& item) = 0;\n-            virtual void visit(Enum& enum_item) = 0;\n-            virtual void visit(Union& union_item) = 0;\n-            virtual void visit(ConstantItem& const_item) = 0;\n-            virtual void visit(StaticItem& static_item) = 0;\n-            virtual void visit(TraitItemFunc& item) = 0;\n-            virtual void visit(TraitItemMethod& item) = 0;\n-            virtual void visit(TraitItemConst& item) = 0;\n-            virtual void visit(TraitItemType& item) = 0;\n-            virtual void visit(Trait& trait) = 0;\n-            virtual void visit(InherentImpl& impl) = 0;\n-            virtual void visit(TraitImpl& impl) = 0;\n-            //virtual void visit(ExternalItem& item) = 0;\n-            virtual void visit(ExternalStaticItem& item) = 0;\n-            virtual void visit(ExternalFunctionItem& item) = 0;\n-            virtual void visit(ExternBlock& block) = 0;\n+  // rust-expr.h\n+  virtual void visit (LiteralExpr &expr) = 0;\n+  virtual void visit (AttrInputLiteral &attr_input) = 0;\n+  virtual void visit (MetaItemLitExpr &meta_item) = 0;\n+  virtual void visit (MetaItemPathLit &meta_item) = 0;\n+  virtual void visit (BorrowExpr &expr) = 0;\n+  virtual void visit (DereferenceExpr &expr) = 0;\n+  virtual void visit (ErrorPropagationExpr &expr) = 0;\n+  virtual void visit (NegationExpr &expr) = 0;\n+  virtual void visit (ArithmeticOrLogicalExpr &expr) = 0;\n+  virtual void visit (ComparisonExpr &expr) = 0;\n+  virtual void visit (LazyBooleanExpr &expr) = 0;\n+  virtual void visit (TypeCastExpr &expr) = 0;\n+  virtual void visit (AssignmentExpr &expr) = 0;\n+  virtual void visit (CompoundAssignmentExpr &expr) = 0;\n+  virtual void visit (GroupedExpr &expr) = 0;\n+  // virtual void visit(ArrayElems& elems) = 0;\n+  virtual void visit (ArrayElemsValues &elems) = 0;\n+  virtual void visit (ArrayElemsCopied &elems) = 0;\n+  virtual void visit (ArrayExpr &expr) = 0;\n+  virtual void visit (ArrayIndexExpr &expr) = 0;\n+  virtual void visit (TupleExpr &expr) = 0;\n+  virtual void visit (TupleIndexExpr &expr) = 0;\n+  virtual void visit (StructExprStruct &expr) = 0;\n+  // virtual void visit(StructExprField& field) = 0;\n+  virtual void visit (StructExprFieldIdentifier &field) = 0;\n+  virtual void visit (StructExprFieldIdentifierValue &field) = 0;\n+  virtual void visit (StructExprFieldIndexValue &field) = 0;\n+  virtual void visit (StructExprStructFields &expr) = 0;\n+  virtual void visit (StructExprStructBase &expr) = 0;\n+  virtual void visit (StructExprTuple &expr) = 0;\n+  virtual void visit (StructExprUnit &expr) = 0;\n+  // virtual void visit(EnumExprField& field) = 0;\n+  virtual void visit (EnumExprFieldIdentifier &field) = 0;\n+  virtual void visit (EnumExprFieldIdentifierValue &field) = 0;\n+  virtual void visit (EnumExprFieldIndexValue &field) = 0;\n+  virtual void visit (EnumExprStruct &expr) = 0;\n+  virtual void visit (EnumExprTuple &expr) = 0;\n+  virtual void visit (EnumExprFieldless &expr) = 0;\n+  virtual void visit (CallExpr &expr) = 0;\n+  virtual void visit (MethodCallExpr &expr) = 0;\n+  virtual void visit (FieldAccessExpr &expr) = 0;\n+  virtual void visit (ClosureExprInner &expr) = 0;\n+  virtual void visit (BlockExpr &expr) = 0;\n+  virtual void visit (ClosureExprInnerTyped &expr) = 0;\n+  virtual void visit (ContinueExpr &expr) = 0;\n+  virtual void visit (BreakExpr &expr) = 0;\n+  virtual void visit (RangeFromToExpr &expr) = 0;\n+  virtual void visit (RangeFromExpr &expr) = 0;\n+  virtual void visit (RangeToExpr &expr) = 0;\n+  virtual void visit (RangeFullExpr &expr) = 0;\n+  virtual void visit (RangeFromToInclExpr &expr) = 0;\n+  virtual void visit (RangeToInclExpr &expr) = 0;\n+  virtual void visit (ReturnExpr &expr) = 0;\n+  virtual void visit (UnsafeBlockExpr &expr) = 0;\n+  virtual void visit (LoopExpr &expr) = 0;\n+  virtual void visit (WhileLoopExpr &expr) = 0;\n+  virtual void visit (WhileLetLoopExpr &expr) = 0;\n+  virtual void visit (ForLoopExpr &expr) = 0;\n+  virtual void visit (IfExpr &expr) = 0;\n+  virtual void visit (IfExprConseqElse &expr) = 0;\n+  virtual void visit (IfExprConseqIf &expr) = 0;\n+  virtual void visit (IfExprConseqIfLet &expr) = 0;\n+  virtual void visit (IfLetExpr &expr) = 0;\n+  virtual void visit (IfLetExprConseqElse &expr) = 0;\n+  virtual void visit (IfLetExprConseqIf &expr) = 0;\n+  virtual void visit (IfLetExprConseqIfLet &expr) = 0;\n+  // virtual void visit(MatchCase& match_case) = 0;\n+  virtual void visit (MatchCaseBlockExpr &match_case) = 0;\n+  virtual void visit (MatchCaseExpr &match_case) = 0;\n+  virtual void visit (MatchExpr &expr) = 0;\n+  virtual void visit (AwaitExpr &expr) = 0;\n+  virtual void visit (AsyncBlockExpr &expr) = 0;\n \n-            // rust-macro.h\n-            virtual void visit(MacroMatchFragment& match) = 0;\n-            virtual void visit(MacroMatchRepetition& match) = 0;\n-            virtual void visit(MacroMatcher& matcher) = 0;\n-            virtual void visit(MacroRulesDefinition& rules_def) = 0;\n-            virtual void visit(MacroInvocation& macro_invoc) = 0;\n-            virtual void visit(MetaItemPath& meta_item) = 0;\n-            virtual void visit(MetaItemSeq& meta_item) = 0;\n-            virtual void visit(MetaWord& meta_item) = 0;\n-            virtual void visit(MetaNameValueStr& meta_item) = 0;\n-            virtual void visit(MetaListPaths& meta_item) = 0;\n-            virtual void visit(MetaListNameValueStr& meta_item) = 0;\n+  // rust-item.h\n+  virtual void visit (TypeParam &param) = 0;\n+  // virtual void visit(WhereClauseItem& item) = 0;\n+  virtual void visit (LifetimeWhereClauseItem &item) = 0;\n+  virtual void visit (TypeBoundWhereClauseItem &item) = 0;\n+  virtual void visit (Method &method) = 0;\n+  virtual void visit (ModuleBodied &module) = 0;\n+  virtual void visit (ModuleNoBody &module) = 0;\n+  virtual void visit (ExternCrate &crate) = 0;\n+  // virtual void visit(UseTree& use_tree) = 0;\n+  virtual void visit (UseTreeGlob &use_tree) = 0;\n+  virtual void visit (UseTreeList &use_tree) = 0;\n+  virtual void visit (UseTreeRebind &use_tree) = 0;\n+  virtual void visit (UseDeclaration &use_decl) = 0;\n+  virtual void visit (Function &function) = 0;\n+  virtual void visit (TypeAlias &type_alias) = 0;\n+  virtual void visit (StructStruct &struct_item) = 0;\n+  virtual void visit (TupleStruct &tuple_struct) = 0;\n+  virtual void visit (EnumItem &item) = 0;\n+  virtual void visit (EnumItemTuple &item) = 0;\n+  virtual void visit (EnumItemStruct &item) = 0;\n+  virtual void visit (EnumItemDiscriminant &item) = 0;\n+  virtual void visit (Enum &enum_item) = 0;\n+  virtual void visit (Union &union_item) = 0;\n+  virtual void visit (ConstantItem &const_item) = 0;\n+  virtual void visit (StaticItem &static_item) = 0;\n+  virtual void visit (TraitItemFunc &item) = 0;\n+  virtual void visit (TraitItemMethod &item) = 0;\n+  virtual void visit (TraitItemConst &item) = 0;\n+  virtual void visit (TraitItemType &item) = 0;\n+  virtual void visit (Trait &trait) = 0;\n+  virtual void visit (InherentImpl &impl) = 0;\n+  virtual void visit (TraitImpl &impl) = 0;\n+  // virtual void visit(ExternalItem& item) = 0;\n+  virtual void visit (ExternalStaticItem &item) = 0;\n+  virtual void visit (ExternalFunctionItem &item) = 0;\n+  virtual void visit (ExternBlock &block) = 0;\n \n-            // rust-pattern.h\n-            virtual void visit(LiteralPattern& pattern) = 0;\n-            virtual void visit(IdentifierPattern& pattern) = 0;\n-            virtual void visit(WildcardPattern& pattern) = 0;\n-            //virtual void visit(RangePatternBound& bound) = 0;\n-            virtual void visit(RangePatternBoundLiteral& bound) = 0;\n-            virtual void visit(RangePatternBoundPath& bound) = 0;\n-            virtual void visit(RangePatternBoundQualPath& bound) = 0;\n-            virtual void visit(RangePattern& pattern) = 0;\n-            virtual void visit(ReferencePattern& pattern) = 0;\n-            //virtual void visit(StructPatternField& field) = 0;\n-            virtual void visit(StructPatternFieldTuplePat& field) = 0;\n-            virtual void visit(StructPatternFieldIdentPat& field) = 0;\n-            virtual void visit(StructPatternFieldIdent& field) = 0;\n-            virtual void visit(StructPattern& pattern) = 0;\n-            //virtual void visit(TupleStructItems& tuple_items) = 0;\n-            virtual void visit(TupleStructItemsNoRange& tuple_items) = 0;\n-            virtual void visit(TupleStructItemsRange& tuple_items) = 0;\n-            virtual void visit(TupleStructPattern& pattern) = 0;\n-            //virtual void visit(TuplePatternItems& tuple_items) = 0;\n-            virtual void visit(TuplePatternItemsMultiple& tuple_items) = 0;\n-            virtual void visit(TuplePatternItemsRanged& tuple_items) = 0;\n-            virtual void visit(TuplePattern& pattern) = 0;\n-            virtual void visit(GroupedPattern& pattern) = 0;\n-            virtual void visit(SlicePattern& pattern) = 0;\n+  // rust-macro.h\n+  virtual void visit (MacroMatchFragment &match) = 0;\n+  virtual void visit (MacroMatchRepetition &match) = 0;\n+  virtual void visit (MacroMatcher &matcher) = 0;\n+  virtual void visit (MacroRulesDefinition &rules_def) = 0;\n+  virtual void visit (MacroInvocation &macro_invoc) = 0;\n+  virtual void visit (MetaItemPath &meta_item) = 0;\n+  virtual void visit (MetaItemSeq &meta_item) = 0;\n+  virtual void visit (MetaWord &meta_item) = 0;\n+  virtual void visit (MetaNameValueStr &meta_item) = 0;\n+  virtual void visit (MetaListPaths &meta_item) = 0;\n+  virtual void visit (MetaListNameValueStr &meta_item) = 0;\n \n-            // rust-stmt.h\n-            virtual void visit(EmptyStmt& stmt) = 0;\n-            virtual void visit(LetStmt& stmt) = 0;\n-            virtual void visit(ExprStmtWithoutBlock& stmt) = 0;\n-            virtual void visit(ExprStmtWithBlock& stmt) = 0;\n-            \n-            // rust-type.h\n-            virtual void visit(TraitBound& bound) = 0;\n-            virtual void visit(ImplTraitType& type) = 0;\n-            virtual void visit(TraitObjectType& type) = 0;\n-            virtual void visit(ParenthesisedType& type) = 0;\n-            virtual void visit(ImplTraitTypeOneBound& type) = 0;\n-            virtual void visit(TraitObjectTypeOneBound& type) = 0;\n-            virtual void visit(TupleType& type) = 0;\n-            virtual void visit(NeverType& type) = 0;\n-            virtual void visit(RawPointerType& type) = 0;\n-            virtual void visit(ReferenceType& type) = 0;\n-            virtual void visit(ArrayType& type) = 0;\n-            virtual void visit(SliceType& type) = 0;\n-            virtual void visit(InferredType& type) = 0;\n-            virtual void visit(BareFunctionType& type) = 0;\n+  // rust-pattern.h\n+  virtual void visit (LiteralPattern &pattern) = 0;\n+  virtual void visit (IdentifierPattern &pattern) = 0;\n+  virtual void visit (WildcardPattern &pattern) = 0;\n+  // virtual void visit(RangePatternBound& bound) = 0;\n+  virtual void visit (RangePatternBoundLiteral &bound) = 0;\n+  virtual void visit (RangePatternBoundPath &bound) = 0;\n+  virtual void visit (RangePatternBoundQualPath &bound) = 0;\n+  virtual void visit (RangePattern &pattern) = 0;\n+  virtual void visit (ReferencePattern &pattern) = 0;\n+  // virtual void visit(StructPatternField& field) = 0;\n+  virtual void visit (StructPatternFieldTuplePat &field) = 0;\n+  virtual void visit (StructPatternFieldIdentPat &field) = 0;\n+  virtual void visit (StructPatternFieldIdent &field) = 0;\n+  virtual void visit (StructPattern &pattern) = 0;\n+  // virtual void visit(TupleStructItems& tuple_items) = 0;\n+  virtual void visit (TupleStructItemsNoRange &tuple_items) = 0;\n+  virtual void visit (TupleStructItemsRange &tuple_items) = 0;\n+  virtual void visit (TupleStructPattern &pattern) = 0;\n+  // virtual void visit(TuplePatternItems& tuple_items) = 0;\n+  virtual void visit (TuplePatternItemsMultiple &tuple_items) = 0;\n+  virtual void visit (TuplePatternItemsRanged &tuple_items) = 0;\n+  virtual void visit (TuplePattern &pattern) = 0;\n+  virtual void visit (GroupedPattern &pattern) = 0;\n+  virtual void visit (SlicePattern &pattern) = 0;\n \n-            // TODO: rust-cond-compilation.h visiting? not currently used\n-        };\n-    }\n-}\n+  // rust-stmt.h\n+  virtual void visit (EmptyStmt &stmt) = 0;\n+  virtual void visit (LetStmt &stmt) = 0;\n+  virtual void visit (ExprStmtWithoutBlock &stmt) = 0;\n+  virtual void visit (ExprStmtWithBlock &stmt) = 0;\n \n-#endif\n\\ No newline at end of file\n+  // rust-type.h\n+  virtual void visit (TraitBound &bound) = 0;\n+  virtual void visit (ImplTraitType &type) = 0;\n+  virtual void visit (TraitObjectType &type) = 0;\n+  virtual void visit (ParenthesisedType &type) = 0;\n+  virtual void visit (ImplTraitTypeOneBound &type) = 0;\n+  virtual void visit (TraitObjectTypeOneBound &type) = 0;\n+  virtual void visit (TupleType &type) = 0;\n+  virtual void visit (NeverType &type) = 0;\n+  virtual void visit (RawPointerType &type) = 0;\n+  virtual void visit (ReferenceType &type) = 0;\n+  virtual void visit (ArrayType &type) = 0;\n+  virtual void visit (SliceType &type) = 0;\n+  virtual void visit (InferredType &type) = 0;\n+  virtual void visit (BareFunctionType &type) = 0;\n+\n+  // TODO: rust-cond-compilation.h visiting? not currently used\n+};\n+} // namespace AST\n+} // namespace Rust\n+\n+#endif"}, {"sha": "6a7511eb9f8b7aa38fb5a14ce49d59aac23d2194", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 1495, "deletions": 1348, "changes": 2843, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -24,1355 +24,1502 @@\n #include \"rust-location.h\"\n \n namespace Rust {\n-    // TODO: remove typedefs and make actual types for these\n-    // typedef int Location;\n-    // typedef ::std::string SimplePath;\n-    typedef ::std::string Identifier;\n-    typedef int TupleIndex;\n-\n-    struct Session;\n-\n-    namespace AST {\n-        // foward decl: ast visitor\n-        class ASTVisitor;\n-\n-        // Delimiter types - used in macros and whatever.\n-        enum DelimType { PARENS, SQUARE, CURLY };\n-\n-        // Base AST node object - TODO is this really required or useful? Where to draw line?\n-        /*class Node {\n-          public:\n-            // Gets node's Location.\n-            Location get_locus() const {\n-                return loc;\n-            }\n-\n-            // Sets node's Location.\n-            void set_locus(Location loc_) {\n-                loc = loc_;\n-            }\n-\n-            // Get node output as a string. Pure virtual.\n-            virtual ::std::string as_string() const = 0;\n-\n-            virtual ~Node() {}\n-\n-            // TODO: constructor including Location? Make all derived classes have Location?\n-\n-          private:\n-            // The node's location.\n-            Location loc;\n-        };*/\n-        // decided to not have node as a \"node\" would never need to be stored\n-\n-        // Attribute body - abstract base class\n-        class AttrInput {\n-          public:\n-            virtual ~AttrInput() {}\n-\n-            // Unique pointer custom clone function\n-            ::std::unique_ptr<AttrInput> clone_attr_input() const {\n-                return ::std::unique_ptr<AttrInput>(clone_attr_input_impl());\n-            }\n-\n-            virtual ::std::string as_string() const = 0;\n-\n-            virtual void accept_vis(ASTVisitor& vis) = 0;\n-\n-            virtual bool check_cfg_predicate(const Session& session) const = 0;\n-\n-            // Parse attribute input to meta item, if possible\n-            virtual AttrInput* parse_to_meta_item() const {\n-                return NULL;\n-            }\n-\n-          protected:\n-            // pure virtual clone implementation\n-            virtual AttrInput* clone_attr_input_impl() const = 0;\n-        };\n-\n-        // forward decl for use in token tree method\n-        class Token;\n-\n-        // A tree of tokens (or a single token) - abstract base class\n-        class TokenTree {\n-          public:\n-            virtual ~TokenTree() {}\n-\n-            // Unique pointer custom clone function\n-            ::std::unique_ptr<TokenTree> clone_token_tree() const {\n-                return ::std::unique_ptr<TokenTree>(clone_token_tree_impl());\n-            }\n-\n-            virtual ::std::string as_string() const = 0;\n-\n-            virtual void accept_vis(ASTVisitor& vis) = 0;\n-\n-            /* Converts token tree to a flat token stream. Tokens must be pointer to avoid mutual\n-             * dependency with Token. */\n-            virtual ::std::vector< ::std::unique_ptr<Token> > to_token_stream() const = 0;\n-\n-          protected:\n-            // pure virtual clone implementation\n-            virtual TokenTree* clone_token_tree_impl() const = 0;\n-        };\n-\n-        // Abstract base class for a macro match\n-        class MacroMatch {\n-          public:\n-            virtual ~MacroMatch() {}\n-\n-            virtual ::std::string as_string() const = 0;\n-\n-            // Unique pointer custom clone function\n-            ::std::unique_ptr<MacroMatch> clone_macro_match() const {\n-                return ::std::unique_ptr<MacroMatch>(clone_macro_match_impl());\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) = 0;\n-\n-          protected:\n-            // pure virtual clone implementation\n-            virtual MacroMatch* clone_macro_match_impl() const = 0;\n-        };\n-\n-        // A token is a kind of token tree (except delimiter tokens)\n-        class Token\n-          : public TokenTree\n-          , public MacroMatch {\n-            // A token is a kind of token tree (except delimiter tokens)\n-            // A token is a kind of MacroMatch (except $ and delimiter tokens)\n-            // TODO: improve member variables - current ones are the same as lexer token\n-            // Token kind.\n-            TokenId token_id;\n-            // Token location.\n-            Location locus;\n-            // Associated text (if any) of token.\n-            std::string str;\n-            // Token type hint (if any).\n-            PrimitiveCoreType type_hint;\n-\n-          public:\n-            // Unique pointer custom clone function\n-            ::std::unique_ptr<Token> clone_token() const {\n-                return ::std::unique_ptr<Token>(clone_token_impl());\n-            }\n-\n-            // constructor from general text - avoid using if lexer const_TokenPtr is available\n-            Token(TokenId token_id, Location locus, ::std::string str, PrimitiveCoreType type_hint) :\n-              token_id(token_id), locus(locus), str(::std::move(str)), type_hint(type_hint) {}\n-\n-            // Constructor from lexer const_TokenPtr\n-            /* TODO: find workaround for std::string being NULL - probably have to introduce new\n-             * method in lexer Token, or maybe make conversion method there*/\n-            Token(const_TokenPtr lexer_token_ptr) :\n-              token_id(lexer_token_ptr->get_id()), locus(lexer_token_ptr->get_locus()), str(\"\"),\n-              type_hint(lexer_token_ptr->get_type_hint()) {\n-                // FIXME: change to \"should have str\" later?\n-                if (lexer_token_ptr->has_str()) {\n-                    str = lexer_token_ptr->get_str();\n-\n-                    // DEBUG\n-                    fprintf(stderr, \"ast token created with str '%s'\\n\", str.c_str());\n-                } else {\n-                    // FIXME: is this returning correct thing?\n-                    str = lexer_token_ptr->get_token_description();\n-\n-                    // DEBUG\n-                    fprintf(stderr, \"ast token created with string '%s'\\n\", str.c_str());\n-                }\n-\n-                // DEBUG\n-                if (lexer_token_ptr->should_have_str() && !lexer_token_ptr->has_str()) {\n-                    fprintf(stderr, \"BAD: for token '%s', should have string but does not!\\n\",\n-                      lexer_token_ptr->get_token_description());\n-                }\n-            }\n-\n-            ::std::string as_string() const;\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-            // Return copy of itself but in token stream form.\n-            virtual ::std::vector< ::std::unique_ptr<Token> > to_token_stream() const OVERRIDE;\n-\n-            TokenId get_id() const {\n-                return token_id;\n-            }\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-          protected:\n-            // No virtual for now as not polymorphic but can be in future\n-            /*virtual*/ Token* clone_token_impl() const {\n-                return new Token(*this);\n-            }\n-\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual Token* clone_token_tree_impl() const OVERRIDE {\n-                return new Token(*this);\n-            }\n-\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual Token* clone_macro_match_impl() const OVERRIDE {\n-                return new Token(*this);\n-            }\n-        };\n-\n-        // A literal - value with a type. Used in LiteralExpr and LiteralPattern.\n-        struct Literal {\n-          public:\n-            enum LitType {\n-                CHAR,\n-                STRING,\n-                RAW_STRING,\n-                BYTE,\n-                BYTE_STRING,\n-                RAW_BYTE_STRING,\n-                INT,\n-                FLOAT,\n-                BOOL\n-            };\n-\n-          private:\n-            // TODO: maybe make subclasses of each type of literal with their typed values (or\n-            // generics)\n-            ::std::string value_as_string;\n-            LitType type;\n-\n-          public:\n-            ::std::string as_string() const {\n-                return value_as_string;\n-            }\n-\n-            inline LitType get_lit_type() const {\n-                return type;\n-            }\n-\n-            Literal(::std::string value_as_string, LitType type) :\n-              value_as_string(::std::move(value_as_string)), type(type) {}\n-\n-            static Literal create_error() {\n-                return Literal(\"\", CHAR);\n-            }\n-\n-            // Returns whether literal is in an invalid state.\n-            bool is_error() const {\n-                return value_as_string == \"\";\n-            }\n-        };\n-\n-        // A token tree with delimiters\n-        class DelimTokenTree\n-          : public TokenTree\n-          , public AttrInput {\n-            DelimType delim_type;\n-            ::std::vector< ::std::unique_ptr<TokenTree> > token_trees;\n-\n-            Location locus;\n-\n-            // TODO: move all the \"parse\" functions into a separate class that has the token stream\n-            // reference - will be cleaner Parse a meta item inner.\n-            //::std::unique_ptr<MetaItemInner> parse_meta_item_inner(const ::std::vector<\n-            //::std::unique_ptr<Token> >& token_stream, int& i) const; SimplePath\n-            // parse_simple_path(const ::std::vector< ::std::unique_ptr<Token> >& token_stream, int&\n-            // i) const; SimplePathSegment parse_simple_path_segment(const ::std::vector<\n-            // ::std::unique_ptr<Token> >& token_stream, int& i) const;\n-            //::std::unique_ptr<MetaItemLitExpr> parse_meta_item_lit(const ::std::unique_ptr<Token>&\n-            // tok) const;\n-            //::std::vector< ::std::unique_ptr<MetaItemInner> > parse_meta_item_seq(const\n-            //::std::vector< ::std::unique_ptr<Token> >& token_stream, int& i) const; Literal\n-            // parse_literal(const ::std::unique_ptr<Token>& tok) const;\n-            //::std::unique_ptr<MetaItem> parse_path_meta_item(const ::std::vector<\n-            //::std::unique_ptr<Token> >& token_stream, int& i) const; bool\n-            // is_end_meta_item_tok(TokenId tok) const;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning a DelimTokenTree object\n-            virtual DelimTokenTree* clone_attr_input_impl() const OVERRIDE {\n-                return new DelimTokenTree(*this);\n-            }\n-\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual DelimTokenTree* clone_token_tree_impl() const OVERRIDE {\n-                return new DelimTokenTree(*this);\n-            }\n-\n-          public:\n-            DelimTokenTree(DelimType delim_type,\n-              ::std::vector< ::std::unique_ptr<TokenTree> > token_trees\n-              = ::std::vector< ::std::unique_ptr<TokenTree> >(),\n-              Location locus = Location()) :\n-              delim_type(delim_type),\n-              token_trees(::std::move(token_trees)), locus(locus) {}\n-\n-            // Copy constructor with vector clone\n-            DelimTokenTree(DelimTokenTree const& other) :\n-              delim_type(other.delim_type), locus(other.locus) {\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                token_trees.reserve(other.token_trees.size());\n-\n-                for (const auto& e : other.token_trees) {\n-                    token_trees.push_back(e->clone_token_tree());\n-                }\n-            }\n-\n-            // overloaded assignment operator with vector clone\n-            DelimTokenTree& operator=(DelimTokenTree const& other) {\n-                delim_type = other.delim_type;\n-                locus = other.locus;\n-\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                token_trees.reserve(other.token_trees.size());\n-\n-                for (const auto& e : other.token_trees) {\n-                    token_trees.push_back(e->clone_token_tree());\n-                }\n-\n-                return *this;\n-            }\n-\n-            // move constructors\n-            DelimTokenTree(DelimTokenTree&& other) = default;\n-            DelimTokenTree& operator=(DelimTokenTree&& other) = default;\n-\n-            static DelimTokenTree create_empty() {\n-                return DelimTokenTree(PARENS);\n-            }\n-\n-            ::std::string as_string() const;\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-            virtual bool check_cfg_predicate(const Session& session ATTRIBUTE_UNUSED) const OVERRIDE {\n-                // this should never be called - should be converted first\n-                return false;\n-            }\n-\n-            virtual AttrInput* parse_to_meta_item() const OVERRIDE;\n-\n-            virtual ::std::vector< ::std::unique_ptr<Token> > to_token_stream() const OVERRIDE;\n-        };\n-\n-        // Forward decl - definition moved to rust-expr.h as it requires LiteralExpr to be defined\n-        class AttrInputLiteral;\n-\n-        // TODO: move applicable stuff into here or just don't include it because nothing uses it\n-        // A segment of a path (maybe)\n-        class PathSegment {\n-          public:\n-            virtual ~PathSegment() {}\n-\n-            virtual ::std::string as_string() const = 0;\n-\n-            // TODO: add visitor here?\n-        };\n-\n-        // A segment of a simple path without generic or type arguments\n-        class SimplePathSegment : public PathSegment {\n-            ::std::string segment_name;\n-            Location locus;\n-\n-            // only allow identifiers, \"super\", \"self\", \"crate\", or \"$crate\"\n-          public:\n-            // TODO: put checks in constructor to enforce this rule?\n-            SimplePathSegment(::std::string segment_name, Location locus = Location()) :\n-              segment_name(::std::move(segment_name)), locus(locus) {}\n-\n-            // Returns whether simple path segment is in an invalid state (currently, if empty).\n-            inline bool is_error() const {\n-                return segment_name.empty();\n-            }\n-\n-            // Creates an error SimplePathSegment\n-            static SimplePathSegment create_error() {\n-                return SimplePathSegment(::std::string(\"\"));\n-            }\n-\n-            ::std::string as_string() const;\n-\n-            inline Location get_locus() const {\n-                return locus;\n-            }\n-\n-            // TODO: visitor pattern?\n-        };\n-\n-        // A simple path without generic or type arguments\n-        class SimplePath {\n-            bool has_opening_scope_resolution;\n-            ::std::vector<SimplePathSegment> segments;\n-            Location locus;\n-\n-          public:\n-            // Constructor\n-            SimplePath(::std::vector<SimplePathSegment> path_segments,\n-              bool has_opening_scope_resolution = false, Location locus = Location()) :\n-              has_opening_scope_resolution(has_opening_scope_resolution),\n-              segments(::std::move(path_segments)), locus(locus) {}\n-\n-            // Creates an empty SimplePath.\n-            static SimplePath create_empty() {\n-                return SimplePath(::std::vector<SimplePathSegment>());\n-            }\n-\n-            // Returns whether the SimplePath is empty, i.e. has path segments.\n-            inline bool is_empty() const {\n-                return segments.empty();\n-            }\n-\n-            ::std::string as_string() const;\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-            // does this need visitor if not polymorphic? probably not\n-\n-            // path-to-string comparison operator\n-            bool operator==(const ::std::string& rhs) {\n-                return !has_opening_scope_resolution && segments.size() == 1\n-                       && segments[0].as_string() == rhs;\n-            }\n-\n-            /* Creates a single-segment SimplePath from a string. This will not check to ensure that\n-             * this is a valid identifier in path, so be careful. Also, this will have no location\n-             * data.\n-             * TODO have checks? */\n-            static SimplePath from_str(::std::string str) {\n-                ::std::vector<AST::SimplePathSegment> single_segments\n-                  = { AST::SimplePathSegment(::std::move(str)) };\n-                return SimplePath(::std::move(single_segments));\n-            }\n-        };\n-\n-        // aka Attr\n-        // Attribute AST representation\n-        struct Attribute {\n-          private:\n-            SimplePath path;\n-\n-            // bool has_attr_input;\n-            // AttrInput* attr_input;\n-            ::std::unique_ptr<AttrInput> attr_input;\n-\n-            Location locus;\n-\n-            // TODO: maybe a variable storing whether attr input is parsed or not\n-\n-          public:\n-            // Returns whether Attribute has AttrInput\n-            inline bool has_attr_input() const {\n-                return attr_input != NULL;\n-            }\n-\n-            // Constructor has pointer AttrInput for polymorphism reasons\n-            Attribute(\n-              SimplePath path, ::std::unique_ptr<AttrInput> input, Location locus = Location()) :\n-              path(::std::move(path)),\n-              attr_input(::std::move(input)), locus(locus) {}\n-\n-            // Copy constructor must deep copy attr_input as unique pointer\n-            Attribute(Attribute const& other) : path(other.path), locus(other.locus) {\n-                // guard to protect from null pointer dereference\n-                if (other.attr_input != NULL) {\n-                    attr_input = other.attr_input->clone_attr_input();\n-                }\n-            }\n-\n-            // default destructor\n-            ~Attribute() = default;\n-\n-            // overload assignment operator to use custom clone method\n-            Attribute& operator=(Attribute const& other) {\n-                path = other.path;\n-                locus = other.locus;\n-                // guard to protect from null pointer dereference\n-                if (other.attr_input != NULL) {\n-                    attr_input = other.attr_input->clone_attr_input();\n-                }\n-\n-                return *this;\n-            }\n-\n-            // default move semantics\n-            Attribute(Attribute&& other) = default;\n-            Attribute& operator=(Attribute&& other) = default;\n-\n-            // Unique pointer custom clone function\n-            ::std::unique_ptr<Attribute> clone_attribute() const {\n-                return ::std::unique_ptr<Attribute>(clone_attribute_impl());\n-            }\n-\n-            /*~Attribute() {\n-                delete attr_input;\n-            }*/\n-\n-            // Creates an empty attribute (which is invalid)\n-            static Attribute create_empty() {\n-                return Attribute(SimplePath::create_empty(), NULL);\n-            }\n-\n-            // Returns whether the attribute is considered an \"empty\" attribute.\n-            inline bool is_empty() const {\n-                return attr_input == NULL && path.is_empty();\n-            }\n-\n-            /* e.g.:\n-                #![crate_type = \"lib\"]\n-                #[test]\n-                #[cfg(target_os = \"linux\")]\n-                #[allow(non_camel_case_types)]\n-                #![allow(unused_variables)]\n-            */\n-\n-            // Full built-in attribute list:\n-            /*   cfg\n-             *   cfg_attr\n-             *   test\n-             *   ignore\n-             *   should_panic\n-             *   derive\n-             *   macro_export\n-             *   macro_use\n-             *   proc_macro\n-             *   proc_macro_derive\n-             *   proc_macro_attribute\n-             *   allow\n-             *   warn\n-             *   deny\n-             *   forbid\n-             *   deprecated\n-             *   must_use\n-             *   link\n-             *   link_name\n-             *   no_link\n-             *   repr\n-             *   crate_type\n-             *   no_main\n-             *   export_name\n-             *   link_section\n-             *   no_mangle\n-             *   used\n-             *   crate_name\n-             *   inline\n-             *   cold\n-             *   no_builtins\n-             *   target_feature\n-             *   doc\n-             *   no_std\n-             *   no_implicit_prelude\n-             *   path\n-             *   recursion_limit\n-             *   type_length_limit\n-             *   panic_handler\n-             *   global_allocator\n-             *   windows_subsystem\n-             *   feature     */\n-\n-            ::std::string as_string() const;\n-\n-            // TODO: does this require visitor pattern as not polymorphic?\n-\n-            // Maybe change to const-reference in future\n-            SimplePath get_path() const {\n-                return path;\n-            }\n-\n-            // Call to parse attribute body to meta item syntax.\n-            void parse_attr_to_meta_item();\n-\n-            // Determines whether cfg predicate is true and item with attribute should not be\n-            // stripped.\n-            bool check_cfg_predicate(const Session& session) {\n-                // assume that cfg predicate actually can exist, i.e. attribute has cfg or cfg_attr\n-                // path\n-\n-                if (!has_attr_input()) {\n-                    return false;\n-                }\n-\n-                // TODO: maybe replace with storing a \"has been parsed\" variable?\n-                parse_attr_to_meta_item();\n-                // can't be const because of this anyway\n-\n-                return attr_input->check_cfg_predicate(session);\n-            }\n-\n-          protected:\n-            // not virtual as currently no subclasses of Attribute, but could be in future\n-            /*virtual*/ Attribute* clone_attribute_impl() const {\n-                return new Attribute(*this);\n-            }\n-        };\n-\n-        // Forward decl - defined in rust-macro.h\n-        class MetaNameValueStr;\n-\n-        // abstract base meta item inner class\n-        class MetaItemInner {\n-          protected:\n-            // pure virtual as MetaItemInner\n-            virtual MetaItemInner* clone_meta_item_inner_impl() const = 0;\n-\n-          public:\n-            // Unique pointer custom clone function\n-            ::std::unique_ptr<MetaItemInner> clone_meta_item_inner() const {\n-                return ::std::unique_ptr<MetaItemInner>(clone_meta_item_inner_impl());\n-            }\n-\n-            virtual ~MetaItemInner() {}\n-\n-            virtual ::std::string as_string() const = 0;\n-\n-            virtual void accept_vis(ASTVisitor& vis) = 0;\n-\n-            // HACK: used to simplify parsing - creates a copy of that type, or returns null\n-            virtual MetaNameValueStr* to_meta_name_value_str() const {\n-                return NULL;\n-            }\n-\n-            // HACK: used to simplify parsing - same thing\n-            virtual SimplePath to_path_item() const {\n-                return SimplePath::create_empty();\n-            }\n-\n-            virtual bool check_cfg_predicate(const Session& session) const = 0;\n-        };\n-\n-        // Container used to store MetaItems as AttrInput (bridge-ish kinda thing)\n-        class AttrInputMetaItemContainer : public AttrInput {\n-            ::std::vector< ::std::unique_ptr<MetaItemInner> > items;\n-\n-          public:\n-            AttrInputMetaItemContainer(::std::vector< ::std::unique_ptr<MetaItemInner> > items) :\n-              items(::std::move(items)) {}\n-\n-            // copy constructor with vector clone\n-            AttrInputMetaItemContainer(const AttrInputMetaItemContainer& other) {\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                items.reserve(other.items.size());\n-\n-                for (const auto& e : other.items) {\n-                    items.push_back(e->clone_meta_item_inner());\n-                }\n-            }\n-\n-            // no destructor definition required\n-\n-            // copy assignment operator with vector clone\n-            AttrInputMetaItemContainer& operator=(const AttrInputMetaItemContainer& other) {\n-                AttrInput::operator=(other);\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                items.reserve(other.items.size());\n-\n-                for (const auto& e : other.items) {\n-                    items.push_back(e->clone_meta_item_inner());\n-                }\n-\n-                return *this;\n-            }\n-\n-            // default move constructors\n-            AttrInputMetaItemContainer(AttrInputMetaItemContainer&& other) = default;\n-            AttrInputMetaItemContainer& operator=(AttrInputMetaItemContainer&& other) = default;\n-\n-            ::std::string as_string() const OVERRIDE;\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-            virtual bool check_cfg_predicate(const Session& session) const OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this type\n-            virtual AttrInputMetaItemContainer* clone_attr_input_impl() const OVERRIDE {\n-                return new AttrInputMetaItemContainer(*this);\n-            }\n-        };\n-\n-        // abstract base meta item class\n-        class MetaItem : public MetaItemInner {};\n-\n-        // Forward decl - defined in rust-expr.h\n-        class MetaItemLitExpr;\n-\n-        // Forward decl - defined in rust-expr.h\n-        class MetaItemPathLit;\n-\n-        // Forward decl - defined in rust-macro.h\n-        class MetaItemPath;\n-\n-        // Forward decl - defined in rust-macro.h\n-        class MetaItemSeq;\n-\n-        // Forward decl - defined in rust-macro.h\n-        class MetaWord;\n-\n-        // Forward decl - defined in rust-macro.h\n-        class MetaListPaths;\n-\n-        // Forward decl - defined in rust-macro.h\n-        struct MetaListNameValueStr;\n-\n-        /* Base statement abstract class. Note that most \"statements\" are not allowed in top-level\n-         * module scope - only a subclass of statements called \"items\" are. */\n-        class Stmt {\n-          public:\n-            // Unique pointer custom clone function\n-            ::std::unique_ptr<Stmt> clone_stmt() const {\n-                return ::std::unique_ptr<Stmt>(clone_stmt_impl());\n-            }\n-\n-            virtual ~Stmt() {}\n-\n-            virtual ::std::string as_string() const = 0;\n-\n-            virtual void accept_vis(ASTVisitor& vis) = 0;\n-\n-          protected:\n-            // Clone function implementation as pure virtual method\n-            virtual Stmt* clone_stmt_impl() const = 0;\n-        };\n-\n-        // Rust \"item\" AST node (declaration of top-level/module-level allowed stuff)\n-        class Item : public Stmt {\n-            ::std::vector<Attribute> outer_attrs;\n-\n-            // TODO: should outer attrs be defined here or in each derived class?\n-\n-          public:\n-            // Unique pointer custom clone function\n-            ::std::unique_ptr<Item> clone_item() const {\n-                return ::std::unique_ptr<Item>(clone_item_impl());\n-            }\n-\n-            ::std::string as_string() const;\n-\n-            // Adds crate names to the vector passed by reference, if it can (polymorphism).\n-            virtual void add_crate_name(::std::vector< ::std::string>& names ATTRIBUTE_UNUSED) const {\n-            }\n-\n-          protected:\n-            // Constructor\n-            Item(::std::vector<Attribute> outer_attribs = ::std::vector<Attribute>()) :\n-              outer_attrs(::std::move(outer_attribs)) {}\n-\n-            // Clone function implementation as pure virtual method\n-            virtual Item* clone_item_impl() const = 0;\n-\n-            /* Save having to specify two clone methods in derived classes by making statement clone\n-             * return item clone. Hopefully won't affect performance too much. */\n-            virtual Item* clone_stmt_impl() const OVERRIDE {\n-                return clone_item_impl();\n-            }\n-        };\n-\n-        // forward decl of ExprWithoutBlock\n-        class ExprWithoutBlock;\n-\n-        // Base expression AST node - abstract\n-        class Expr {\n-            // TODO: move outer attribute data to derived classes?\n-            ::std::vector<Attribute> outer_attrs;\n+// TODO: remove typedefs and make actual types for these\n+// typedef int Location;\n+// typedef ::std::string SimplePath;\n+typedef ::std::string Identifier;\n+typedef int TupleIndex;\n+\n+struct Session;\n+\n+namespace AST {\n+// foward decl: ast visitor\n+class ASTVisitor;\n+\n+// Delimiter types - used in macros and whatever.\n+enum DelimType\n+{\n+  PARENS,\n+  SQUARE,\n+  CURLY\n+};\n+\n+// Base AST node object - TODO is this really required or useful? Where to draw\n+// line?\n+/*class Node {\n+  public:\n+    // Gets node's Location.\n+    Location get_locus() const {\n+\treturn loc;\n+    }\n \n-          public:\n-            inline const ::std::vector<Attribute>& get_outer_attrs() const {\n-                return outer_attrs;\n-            }\n-\n-            // Unique pointer custom clone function\n-            ::std::unique_ptr<Expr> clone_expr() const {\n-                return ::std::unique_ptr<Expr>(clone_expr_impl());\n-            }\n-\n-            /* TODO: public methods that could be useful:\n-             *  - get_type() - returns type of expression. set_type() may also be useful for some?\n-             *  - evaluate() - evaluates expression if constant? can_evaluate()? */\n-\n-            // HACK: downcasting without dynamic_cast (if possible) via polymorphism - overrided in\n-            // subclasses of ExprWithoutBlock\n-            virtual ExprWithoutBlock* as_expr_without_block() const {\n-                // DEBUG\n-                fprintf(stderr, \"clone expr without block returns null and has not been overriden\\n\");\n-\n-                return NULL;\n-            }\n-\n-            // TODO: make pure virtual if move out outer attributes to derived classes\n-            virtual ::std::string as_string() const;\n-\n-            virtual ~Expr() {}\n-\n-            // HACK: slow way of getting location from base expression through virtual methods.\n-            virtual Location get_locus_slow() const {\n-                return Location();\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) = 0;\n-\n-          protected:\n-            // Constructor\n-            Expr(::std::vector<Attribute> outer_attribs = ::std::vector<Attribute>()) :\n-              outer_attrs(::std::move(outer_attribs)) {}\n-\n-            // Clone function implementation as pure virtual method\n-            virtual Expr* clone_expr_impl() const = 0;\n-\n-            // TODO: think of less hacky way to implement this kind of thing\n-            // Sets outer attributes.\n-            void set_outer_attrs(::std::vector<Attribute> outer_attrs_to_set) {\n-                outer_attrs = ::std::move(outer_attrs_to_set);\n-            }\n-        };\n-\n-        // AST node for an expression without an accompanying block - abstract\n-        class ExprWithoutBlock : public Expr {\n-          protected:\n-            // Constructor\n-            ExprWithoutBlock(::std::vector<Attribute> outer_attribs = ::std::vector<Attribute>()) :\n-              Expr(::std::move(outer_attribs)) {}\n-\n-            // pure virtual clone implementation\n-            virtual ExprWithoutBlock* clone_expr_without_block_impl() const = 0;\n-\n-            /* Save having to specify two clone methods in derived classes by making expr clone\n-             * return exprwithoutblock clone. Hopefully won't affect performance too much. */\n-            virtual ExprWithoutBlock* clone_expr_impl() const OVERRIDE {\n-                return clone_expr_without_block_impl();\n-            }\n-\n-          public:\n-            // Unique pointer custom clone function\n-            ::std::unique_ptr<ExprWithoutBlock> clone_expr_without_block() const {\n-                return ::std::unique_ptr<ExprWithoutBlock>(clone_expr_without_block_impl());\n-            }\n-\n-            // downcasting hack from expr to use pratt parsing with parse_expr_without_block\n-            virtual ExprWithoutBlock* as_expr_without_block() const OVERRIDE {\n-                // DEBUG\n-                fprintf(stderr, \"about to call the impl for clone expr without block\\n\");\n-\n-                return clone_expr_without_block_impl();\n-            }\n-        };\n-\n-        // HACK: IdentifierExpr, delete when figure out identifier vs expr problem in Pratt parser\n-        // Alternatively, identifiers could just be represented as single-segment paths\n-        class IdentifierExpr : public ExprWithoutBlock {\n-            Identifier ident;\n-\n-            Location locus;\n-\n-          public:\n-            IdentifierExpr(Identifier ident, Location locus = Location(),\n-              ::std::vector<Attribute> outer_attrs = ::std::vector<Attribute>()) :\n-              ExprWithoutBlock(::std::move(outer_attrs)),\n-              ident(::std::move(ident)), locus(locus) {}\n-\n-            ::std::string as_string() const OVERRIDE {\n-                return ident;\n-            }\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-            Location get_locus_slow() const OVERRIDE {\n-                return get_locus();\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Clone method implementation\n-            virtual IdentifierExpr* clone_expr_without_block_impl() const OVERRIDE {\n-                return new IdentifierExpr(*this);\n-            }\n-        };\n-\n-        // Pattern base AST node\n-        class Pattern {\n-          public:\n-            // Unique pointer custom clone function\n-            ::std::unique_ptr<Pattern> clone_pattern() const {\n-                return ::std::unique_ptr<Pattern>(clone_pattern_impl());\n-            }\n-\n-            // possible virtual methods: is_refutable()\n-\n-            virtual ~Pattern() {}\n-\n-            virtual ::std::string as_string() const = 0;\n-\n-            virtual void accept_vis(ASTVisitor& vis) = 0;\n-\n-          protected:\n-            // Clone pattern implementation as pure virtual method\n-            virtual Pattern* clone_pattern_impl() const = 0;\n-        };\n-\n-        // forward decl for Type\n-        class TraitBound;\n-\n-        // Base class for types as represented in AST - abstract\n-        class Type {\n-          public:\n-            // Unique pointer custom clone function\n-            ::std::unique_ptr<Type> clone_type() const {\n-                return ::std::unique_ptr<Type>(clone_type_impl());\n-            }\n-\n-            // virtual destructor\n-            virtual ~Type() {}\n-\n-            virtual ::std::string as_string() const = 0;\n-\n-            // HACK: convert to trait bound. Virtual method overriden by classes that enable this.\n-            virtual TraitBound* to_trait_bound(bool in_parens ATTRIBUTE_UNUSED) const {\n-                return NULL;\n-            }\n-            // as pointer, shouldn't require definition beforehand, only forward declaration.\n-\n-            virtual void accept_vis(ASTVisitor& vis) = 0;\n-\n-          protected:\n-            // Clone function implementation as pure virtual method\n-            virtual Type* clone_type_impl() const = 0;\n-        };\n-\n-        // A type without parentheses? - abstract\n-        class TypeNoBounds : public Type {\n-          public:\n-            // Unique pointer custom clone function\n-            ::std::unique_ptr<TypeNoBounds> clone_type_no_bounds() const {\n-                return ::std::unique_ptr<TypeNoBounds>(clone_type_no_bounds_impl());\n-            }\n-\n-          protected:\n-            // Clone function implementation as pure virtual method\n-            virtual TypeNoBounds* clone_type_no_bounds_impl() const = 0;\n-\n-            /* Save having to specify two clone methods in derived classes by making type clone\n-             * return typenobounds clone. Hopefully won't affect performance too much. */\n-            virtual TypeNoBounds* clone_type_impl() const OVERRIDE {\n-                return clone_type_no_bounds_impl();\n-            }\n-        };\n-\n-        // Abstract base class representing a type param bound - Lifetime and TraitBound extends it\n-        class TypeParamBound {\n-          public:\n-            virtual ~TypeParamBound() {}\n-\n-            // Unique pointer custom clone function\n-            ::std::unique_ptr<TypeParamBound> clone_type_param_bound() const {\n-                return ::std::unique_ptr<TypeParamBound>(clone_type_param_bound_impl());\n-            }\n-\n-            virtual ::std::string as_string() const = 0;\n-\n-            virtual void accept_vis(ASTVisitor& vis) = 0;\n-\n-          protected:\n-            // Clone function implementation as pure virtual method\n-            virtual TypeParamBound* clone_type_param_bound_impl() const = 0;\n-        };\n-\n-        // Represents a lifetime (and is also a kind of type param bound)\n-        class Lifetime : public TypeParamBound {\n-          public:\n-            enum LifetimeType {\n-                NAMED,   // corresponds to LIFETIME_OR_LABEL\n-                STATIC,  // corresponds to 'static\n-                WILDCARD // corresponds to '_\n-            };\n-\n-          private:\n-            LifetimeType lifetime_type;\n-\n-            // TODO: LIFETIME_OR_LABEL (aka lifetime token) is only field\n-            // find way of enclosing token or something\n-            ::std::string lifetime_name;\n-            // only applies for NAMED lifetime_type\n-\n-            Location locus;\n-\n-          public:\n-            // Constructor\n-            Lifetime(\n-              LifetimeType type, ::std::string name = ::std::string(), Location locus = Location()) :\n-              lifetime_type(type),\n-              lifetime_name(::std::move(name)), locus(locus) {}\n-\n-            // Creates an \"error\" lifetime.\n-            static Lifetime error() {\n-                return Lifetime(NAMED, ::std::string(\"\"));\n-            }\n-\n-            // Returns true if the lifetime is in an error state.\n-            inline bool is_error() const {\n-                return lifetime_type == NAMED && lifetime_name.empty();\n-            }\n-\n-            ::std::string as_string() const;\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual Lifetime* clone_type_param_bound_impl() const OVERRIDE {\n-                return new Lifetime(*this);\n-            }\n-        };\n-\n-        // Base generic parameter in AST. Abstract - can be represented by a Lifetime or Type param\n-        class GenericParam {\n-          public:\n-            virtual ~GenericParam() {}\n-\n-            // Unique pointer custom clone function\n-            ::std::unique_ptr<GenericParam> clone_generic_param() const {\n-                return ::std::unique_ptr<GenericParam>(clone_generic_param_impl());\n-            }\n-\n-            virtual ::std::string as_string() const = 0;\n-\n-            virtual void accept_vis(ASTVisitor& vis) = 0;\n-\n-          protected:\n-            // Clone function implementation as pure virtual method\n-            virtual GenericParam* clone_generic_param_impl() const = 0;\n-        };\n-\n-        // A lifetime generic parameter (as opposed to a type generic parameter)\n-        class LifetimeParam : public GenericParam {\n-            Lifetime lifetime;\n-\n-            // bool has_lifetime_bounds;\n-            // LifetimeBounds lifetime_bounds;\n-            ::std::vector<Lifetime> lifetime_bounds; // inlined LifetimeBounds\n-\n-            // bool has_outer_attribute;\n-            //::std::unique_ptr<Attribute> outer_attr;\n-            Attribute outer_attr;\n-\n-            Location locus;\n-\n-          public:\n-            // Returns whether the lifetime param has any lifetime bounds.\n-            inline bool has_lifetime_bounds() const {\n-                return !lifetime_bounds.empty();\n-            }\n-\n-            // Returns whether the lifetime param has an outer attribute.\n-            inline bool has_outer_attribute() const {\n-                return !outer_attr.is_empty();\n-            }\n-\n-            // Creates an error state lifetime param.\n-            static LifetimeParam create_error() {\n-                return LifetimeParam(Lifetime::error());\n-            }\n-\n-            // Returns whether the lifetime param is in an error state.\n-            inline bool is_error() const {\n-                return lifetime.is_error();\n-            }\n-\n-            // Constructor\n-            LifetimeParam(Lifetime lifetime, Location locus = Location(),\n-              ::std::vector<Lifetime> lifetime_bounds = ::std::vector<Lifetime>(),\n-              Attribute outer_attr = Attribute::create_empty()) :\n-              lifetime(::std::move(lifetime)),\n-              lifetime_bounds(::std::move(lifetime_bounds)), outer_attr(::std::move(outer_attr)),\n-              locus(locus) {}\n-\n-            // TODO: remove copy and assignment operator definitions - not required\n-\n-            // Copy constructor with clone\n-            LifetimeParam(LifetimeParam const& other) :\n-              lifetime(other.lifetime), lifetime_bounds(other.lifetime_bounds),\n-              outer_attr(other.outer_attr), locus(other.locus) {}\n-\n-            // Destructor - define here if required\n-\n-            // Overloaded assignment operator to clone attribute\n-            LifetimeParam& operator=(LifetimeParam const& other) {\n-                lifetime = other.lifetime;\n-                lifetime_bounds = other.lifetime_bounds;\n-                outer_attr = other.outer_attr;\n-                locus = other.locus;\n-\n-                return *this;\n-            }\n-\n-            // move constructors\n-            LifetimeParam(LifetimeParam&& other) = default;\n-            LifetimeParam& operator=(LifetimeParam&& other) = default;\n-\n-            ::std::string as_string() const;\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual LifetimeParam* clone_generic_param_impl() const OVERRIDE {\n-                return new LifetimeParam(*this);\n-            }\n-        };\n-\n-        // A macro item AST node - potentially abstract base class\n-        class MacroItem : public Item {\n-            /*public:\n-            ::std::string as_string() const;*/\n-          protected:\n-            MacroItem(::std::vector<Attribute> outer_attribs) : Item(::std::move(outer_attribs)) {}\n-        };\n-\n-        // Item used in trait declarations - abstract base class\n-        class TraitItem {\n-            // bool has_outer_attrs;\n-            // TODO: remove and rely on virtual functions and VisItem-derived attributes?\n-            //::std::vector<Attribute> outer_attrs;\n-\n-            // NOTE: all children should have outer attributes\n-\n-          protected:\n-            // Constructor\n-            /*TraitItem(::std::vector<Attribute> outer_attrs = ::std::vector<Attribute>()) :\n-              outer_attrs(::std::move(outer_attrs)) {}*/\n-\n-            // Clone function implementation as pure virtual method\n-            virtual TraitItem* clone_trait_item_impl() const = 0;\n-\n-          public:\n-            virtual ~TraitItem() {}\n-\n-            // Returns whether TraitItem has outer attributes.\n-            /*inline bool has_outer_attrs() const {\n-                return !outer_attrs.empty();\n-            }*/\n-\n-            // Unique pointer custom clone function\n-            ::std::unique_ptr<TraitItem> clone_trait_item() const {\n-                return ::std::unique_ptr<TraitItem>(clone_trait_item_impl());\n-            }\n-\n-            virtual ::std::string as_string() const = 0;\n-\n-            virtual void accept_vis(ASTVisitor& vis) = 0;\n-        };\n-\n-        // Abstract base class for items used within an inherent impl block (the impl name {} one)\n-        class InherentImplItem {\n-          protected:\n-            // Clone function implementation as pure virtual method\n-            virtual InherentImplItem* clone_inherent_impl_item_impl() const = 0;\n-\n-          public:\n-            virtual ~InherentImplItem() {}\n-\n-            // Unique pointer custom clone function\n-            ::std::unique_ptr<InherentImplItem> clone_inherent_impl_item() const {\n-                return ::std::unique_ptr<InherentImplItem>(clone_inherent_impl_item_impl());\n-            }\n-\n-            virtual ::std::string as_string() const = 0;\n-\n-            virtual void accept_vis(ASTVisitor& vis) = 0;\n-        };\n-\n-        // Abstract base class for items used in a trait impl\n-        class TraitImplItem {\n-          protected:\n-            virtual TraitImplItem* clone_trait_impl_item_impl() const = 0;\n-\n-          public:\n-            virtual ~TraitImplItem(){};\n-\n-            // Unique pointer custom clone function\n-            ::std::unique_ptr<TraitImplItem> clone_trait_impl_item() const {\n-                return ::std::unique_ptr<TraitImplItem>(clone_trait_impl_item_impl());\n-            }\n-\n-            virtual ::std::string as_string() const = 0;\n-\n-            virtual void accept_vis(ASTVisitor& vis) = 0;\n-        };\n-\n-        // A macro invocation item (or statement) AST node (i.e. semi-coloned macro invocation)\n-        class MacroInvocationSemi\n-          : public MacroItem\n-          , public TraitItem\n-          , public InherentImplItem\n-          , public TraitImplItem\n-        /*, public Statement*/ {\n-            // already inherits from statement indirectly via item as item is a subclass of statement\n-            SimplePath path;\n-            // all delim types except curly must have invocation end with a semicolon\n-            DelimType delim_type;\n-            //::std::vector<TokenTree> token_trees;\n-            ::std::vector< ::std::unique_ptr<TokenTree> > token_trees;\n-\n-            Location locus;\n-\n-          public:\n-            ::std::string as_string() const;\n-\n-            MacroInvocationSemi(SimplePath macro_path, DelimType delim_type,\n-              ::std::vector< ::std::unique_ptr<TokenTree> > token_trees,\n-              ::std::vector<Attribute> outer_attribs, Location locus) :\n-              MacroItem(::std::move(outer_attribs)),\n-              path(::std::move(macro_path)), delim_type(delim_type),\n-              token_trees(::std::move(token_trees)), locus(locus) {}\n-            /* TODO: possible issue with Item and TraitItem hierarchies both having outer attributes\n-             * - storage inefficiency at least.\n-             * Best current idea is to make Item preferred and have TraitItem get virtual functions\n-             * for attributes or something.\n-             * Or just redo the \"composition\" approach, but then this prevents polymorphism and would\n-             * entail redoing quite a bit of the parser. */\n-\n-            // Copy constructor with vector clone\n-            MacroInvocationSemi(MacroInvocationSemi const& other) :\n-              MacroItem(other), TraitItem(other), InherentImplItem(other), TraitImplItem(other),\n-              path(other.path), delim_type(other.delim_type), locus(other.locus) {\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                token_trees.reserve(other.token_trees.size());\n-\n-                for (const auto& e : other.token_trees) {\n-                    token_trees.push_back(e->clone_token_tree());\n-                }\n-            }\n-\n-            // Overloaded assignment operator to vector clone\n-            MacroInvocationSemi& operator=(MacroInvocationSemi const& other) {\n-                MacroItem::operator=(other);\n-                TraitItem::operator=(other);\n-                InherentImplItem::operator=(other);\n-                TraitImplItem::operator=(other);\n-                path = other.path;\n-                delim_type = other.delim_type;\n-                locus = other.locus;\n-\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                token_trees.reserve(other.token_trees.size());\n-\n-                for (const auto& e : other.token_trees) {\n-                    token_trees.push_back(e->clone_token_tree());\n-                }\n-\n-                return *this;\n-            }\n-\n-            // Move constructors\n-            MacroInvocationSemi(MacroInvocationSemi&& other) = default;\n-            MacroInvocationSemi& operator=(MacroInvocationSemi&& other) = default;\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual MacroInvocationSemi* clone_item_impl() const OVERRIDE {\n-                return new MacroInvocationSemi(*this);\n-            }\n-\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual MacroInvocationSemi* clone_inherent_impl_item_impl() const OVERRIDE {\n-                return new MacroInvocationSemi(*this);\n-            }\n-\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual MacroInvocationSemi* clone_trait_impl_item_impl() const OVERRIDE {\n-                return new MacroInvocationSemi(*this);\n-            }\n-\n-            // FIXME: remove if item impl virtual override works properly\n-            // Use covariance to implement clone function as returning this object rather than base\n-            /*virtual MacroInvocationSemi* clone_statement_impl() const OVERRIDE {\n-                return new MacroInvocationSemi(*this);\n-            }*/\n-\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual MacroInvocationSemi* clone_trait_item_impl() const OVERRIDE {\n-                return new MacroInvocationSemi(*this);\n-            }\n-        };\n-\n-        // A crate AST object - holds all the data for a single compilation unit\n-        struct Crate {\n-            bool has_utf8bom;\n-            bool has_shebang;\n-\n-            ::std::vector<Attribute> inner_attrs;\n-            //::std::vector<Item> items;\n-            // dodgy spacing required here\n-            // TODO: is it better to have a vector of items here or a module (implicit top-level one)?\n-            ::std::vector< ::std::unique_ptr<Item> > items;\n-\n-          public:\n-            // Constructor\n-            Crate(::std::vector< ::std::unique_ptr<Item> > items,\n-              ::std::vector<Attribute> inner_attrs, bool has_utf8bom = false,\n-              bool has_shebang = false) :\n-              has_utf8bom(has_utf8bom),\n-              has_shebang(has_shebang), inner_attrs(::std::move(inner_attrs)),\n-              items(::std::move(items)) {}\n-\n-            // Copy constructor with vector clone\n-            Crate(Crate const& other) :\n-              has_utf8bom(other.has_utf8bom), has_shebang(other.has_shebang),\n-              inner_attrs(other.inner_attrs) {\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                items.reserve(other.items.size());\n-\n-                for (const auto& e : other.items) {\n-                    items.push_back(e->clone_item());\n-                }\n-            }\n-\n-            ~Crate() = default;\n-\n-            // Overloaded assignment operator with vector clone\n-            Crate& operator=(Crate const& other) {\n-                inner_attrs = other.inner_attrs;\n-                has_shebang = other.has_shebang;\n-                has_utf8bom = other.has_utf8bom;\n-\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                items.reserve(other.items.size());\n-\n-                for (const auto& e : other.items) {\n-                    items.push_back(e->clone_item());\n-                }\n-\n-                return *this;\n-            }\n-\n-            // Move constructors\n-            Crate(Crate&& other) = default;\n-            Crate& operator=(Crate&& other) = default;\n-\n-            // Get crate representation as string (e.g. for debugging).\n-            ::std::string as_string() const;\n-        };\n-\n-        // Base path expression AST node - abstract\n-        class PathExpr : public ExprWithoutBlock {\n-          protected:\n-            PathExpr(::std::vector<Attribute> outer_attribs) :\n-              ExprWithoutBlock(::std::move(outer_attribs)) {}\n-\n-          public:\n-            // TODO: think of a better and less hacky way to allow this\n-\n-            // Replaces the outer attributes of this path expression with the given outer attributes.\n-            void replace_outer_attrs(::std::vector<Attribute> outer_attrs) {\n-                set_outer_attrs(::std::move(outer_attrs));\n-            }\n-        };\n+    // Sets node's Location.\n+    void set_locus(Location loc_) {\n+\tloc = loc_;\n     }\n-}\n+\n+    // Get node output as a string. Pure virtual.\n+    virtual ::std::string as_string() const = 0;\n+\n+    virtual ~Node() {}\n+\n+    // TODO: constructor including Location? Make all derived classes have\n+Location?\n+\n+  private:\n+    // The node's location.\n+    Location loc;\n+};*/\n+// decided to not have node as a \"node\" would never need to be stored\n+\n+// Attribute body - abstract base class\n+class AttrInput\n+{\n+public:\n+  virtual ~AttrInput () {}\n+\n+  // Unique pointer custom clone function\n+  ::std::unique_ptr<AttrInput> clone_attr_input () const\n+  {\n+    return ::std::unique_ptr<AttrInput> (clone_attr_input_impl ());\n+  }\n+\n+  virtual ::std::string as_string () const = 0;\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+  virtual bool check_cfg_predicate (const Session &session) const = 0;\n+\n+  // Parse attribute input to meta item, if possible\n+  virtual AttrInput *parse_to_meta_item () const { return NULL; }\n+\n+protected:\n+  // pure virtual clone implementation\n+  virtual AttrInput *clone_attr_input_impl () const = 0;\n+};\n+\n+// forward decl for use in token tree method\n+class Token;\n+\n+// A tree of tokens (or a single token) - abstract base class\n+class TokenTree\n+{\n+public:\n+  virtual ~TokenTree () {}\n+\n+  // Unique pointer custom clone function\n+  ::std::unique_ptr<TokenTree> clone_token_tree () const\n+  {\n+    return ::std::unique_ptr<TokenTree> (clone_token_tree_impl ());\n+  }\n+\n+  virtual ::std::string as_string () const = 0;\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+  /* Converts token tree to a flat token stream. Tokens must be pointer to avoid\n+   * mutual dependency with Token. */\n+  virtual ::std::vector< ::std::unique_ptr<Token> >\n+  to_token_stream () const = 0;\n+\n+protected:\n+  // pure virtual clone implementation\n+  virtual TokenTree *clone_token_tree_impl () const = 0;\n+};\n+\n+// Abstract base class for a macro match\n+class MacroMatch\n+{\n+public:\n+  virtual ~MacroMatch () {}\n+\n+  virtual ::std::string as_string () const = 0;\n+\n+  // Unique pointer custom clone function\n+  ::std::unique_ptr<MacroMatch> clone_macro_match () const\n+  {\n+    return ::std::unique_ptr<MacroMatch> (clone_macro_match_impl ());\n+  }\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+protected:\n+  // pure virtual clone implementation\n+  virtual MacroMatch *clone_macro_match_impl () const = 0;\n+};\n+\n+// A token is a kind of token tree (except delimiter tokens)\n+class Token : public TokenTree, public MacroMatch\n+{\n+  // A token is a kind of token tree (except delimiter tokens)\n+  // A token is a kind of MacroMatch (except $ and delimiter tokens)\n+  // TODO: improve member variables - current ones are the same as lexer token\n+  // Token kind.\n+  TokenId token_id;\n+  // Token location.\n+  Location locus;\n+  // Associated text (if any) of token.\n+  std::string str;\n+  // Token type hint (if any).\n+  PrimitiveCoreType type_hint;\n+\n+public:\n+  // Unique pointer custom clone function\n+  ::std::unique_ptr<Token> clone_token () const\n+  {\n+    return ::std::unique_ptr<Token> (clone_token_impl ());\n+  }\n+\n+  // constructor from general text - avoid using if lexer const_TokenPtr is\n+  // available\n+  Token (TokenId token_id, Location locus, ::std::string str,\n+\t PrimitiveCoreType type_hint)\n+    : token_id (token_id), locus (locus), str (::std::move (str)),\n+      type_hint (type_hint)\n+  {}\n+\n+  // Constructor from lexer const_TokenPtr\n+  /* TODO: find workaround for std::string being NULL - probably have to\n+   * introduce new method in lexer Token, or maybe make conversion method\n+   * there*/\n+  Token (const_TokenPtr lexer_token_ptr)\n+    : token_id (lexer_token_ptr->get_id ()),\n+      locus (lexer_token_ptr->get_locus ()), str (\"\"),\n+      type_hint (lexer_token_ptr->get_type_hint ())\n+  {\n+    // FIXME: change to \"should have str\" later?\n+    if (lexer_token_ptr->has_str ())\n+      {\n+\tstr = lexer_token_ptr->get_str ();\n+\n+\t// DEBUG\n+\tfprintf (stderr, \"ast token created with str '%s'\\n\", str.c_str ());\n+      }\n+    else\n+      {\n+\t// FIXME: is this returning correct thing?\n+\tstr = lexer_token_ptr->get_token_description ();\n+\n+\t// DEBUG\n+\tfprintf (stderr, \"ast token created with string '%s'\\n\", str.c_str ());\n+      }\n+\n+    // DEBUG\n+    if (lexer_token_ptr->should_have_str () && !lexer_token_ptr->has_str ())\n+      {\n+\tfprintf (stderr,\n+\t\t \"BAD: for token '%s', should have string but does not!\\n\",\n+\t\t lexer_token_ptr->get_token_description ());\n+      }\n+  }\n+\n+  ::std::string as_string () const;\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+  // Return copy of itself but in token stream form.\n+  virtual ::std::vector< ::std::unique_ptr<Token> >\n+  to_token_stream () const OVERRIDE;\n+\n+  TokenId get_id () const { return token_id; }\n+\n+  Location get_locus () const { return locus; }\n+\n+protected:\n+  // No virtual for now as not polymorphic but can be in future\n+  /*virtual*/ Token *clone_token_impl () const { return new Token (*this); }\n+\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual Token *clone_token_tree_impl () const OVERRIDE\n+  {\n+    return new Token (*this);\n+  }\n+\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual Token *clone_macro_match_impl () const OVERRIDE\n+  {\n+    return new Token (*this);\n+  }\n+};\n+\n+// A literal - value with a type. Used in LiteralExpr and LiteralPattern.\n+struct Literal\n+{\n+public:\n+  enum LitType\n+  {\n+    CHAR,\n+    STRING,\n+    RAW_STRING,\n+    BYTE,\n+    BYTE_STRING,\n+    RAW_BYTE_STRING,\n+    INT,\n+    FLOAT,\n+    BOOL\n+  };\n+\n+private:\n+  // TODO: maybe make subclasses of each type of literal with their typed values\n+  // (or generics)\n+  ::std::string value_as_string;\n+  LitType type;\n+\n+public:\n+  ::std::string as_string () const { return value_as_string; }\n+\n+  inline LitType get_lit_type () const { return type; }\n+\n+  Literal (::std::string value_as_string, LitType type)\n+    : value_as_string (::std::move (value_as_string)), type (type)\n+  {}\n+\n+  static Literal create_error () { return Literal (\"\", CHAR); }\n+\n+  // Returns whether literal is in an invalid state.\n+  bool is_error () const { return value_as_string == \"\"; }\n+};\n+\n+// A token tree with delimiters\n+class DelimTokenTree : public TokenTree, public AttrInput\n+{\n+  DelimType delim_type;\n+  ::std::vector< ::std::unique_ptr<TokenTree> > token_trees;\n+\n+  Location locus;\n+\n+  // TODO: move all the \"parse\" functions into a separate class that has the\n+  // token stream reference - will be cleaner Parse a meta item inner.\n+  //::std::unique_ptr<MetaItemInner> parse_meta_item_inner(const ::std::vector<\n+  //::std::unique_ptr<Token> >& token_stream, int& i) const; SimplePath\n+  // parse_simple_path(const ::std::vector< ::std::unique_ptr<Token> >&\n+  // token_stream, int& i) const; SimplePathSegment\n+  // parse_simple_path_segment(const ::std::vector<\n+  // ::std::unique_ptr<Token> >& token_stream, int& i) const;\n+  //::std::unique_ptr<MetaItemLitExpr> parse_meta_item_lit(const\n+  //::std::unique_ptr<Token>&\n+  // tok) const;\n+  //::std::vector< ::std::unique_ptr<MetaItemInner> > parse_meta_item_seq(const\n+  //::std::vector< ::std::unique_ptr<Token> >& token_stream, int& i) const;\n+  //Literal\n+  // parse_literal(const ::std::unique_ptr<Token>& tok) const;\n+  //::std::unique_ptr<MetaItem> parse_path_meta_item(const ::std::vector<\n+  //::std::unique_ptr<Token> >& token_stream, int& i) const; bool\n+  // is_end_meta_item_tok(TokenId tok) const;\n+\n+protected:\n+  // Use covariance to implement clone function as returning a DelimTokenTree\n+  // object\n+  virtual DelimTokenTree *clone_attr_input_impl () const OVERRIDE\n+  {\n+    return new DelimTokenTree (*this);\n+  }\n+\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual DelimTokenTree *clone_token_tree_impl () const OVERRIDE\n+  {\n+    return new DelimTokenTree (*this);\n+  }\n+\n+public:\n+  DelimTokenTree (DelimType delim_type,\n+\t\t  ::std::vector< ::std::unique_ptr<TokenTree> > token_trees\n+\t\t  = ::std::vector< ::std::unique_ptr<TokenTree> > (),\n+\t\t  Location locus = Location ())\n+    : delim_type (delim_type), token_trees (::std::move (token_trees)),\n+      locus (locus)\n+  {}\n+\n+  // Copy constructor with vector clone\n+  DelimTokenTree (DelimTokenTree const &other)\n+    : delim_type (other.delim_type), locus (other.locus)\n+  {\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    token_trees.reserve (other.token_trees.size ());\n+\n+    for (const auto &e : other.token_trees)\n+      {\n+\ttoken_trees.push_back (e->clone_token_tree ());\n+      }\n+  }\n+\n+  // overloaded assignment operator with vector clone\n+  DelimTokenTree &operator= (DelimTokenTree const &other)\n+  {\n+    delim_type = other.delim_type;\n+    locus = other.locus;\n+\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    token_trees.reserve (other.token_trees.size ());\n+\n+    for (const auto &e : other.token_trees)\n+      {\n+\ttoken_trees.push_back (e->clone_token_tree ());\n+      }\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  DelimTokenTree (DelimTokenTree &&other) = default;\n+  DelimTokenTree &operator= (DelimTokenTree &&other) = default;\n+\n+  static DelimTokenTree create_empty () { return DelimTokenTree (PARENS); }\n+\n+  ::std::string as_string () const;\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+  virtual bool\n+  check_cfg_predicate (const Session &session ATTRIBUTE_UNUSED) const OVERRIDE\n+  {\n+    // this should never be called - should be converted first\n+    return false;\n+  }\n+\n+  virtual AttrInput *parse_to_meta_item () const OVERRIDE;\n+\n+  virtual ::std::vector< ::std::unique_ptr<Token> >\n+  to_token_stream () const OVERRIDE;\n+};\n+\n+// Forward decl - definition moved to rust-expr.h as it requires LiteralExpr to\n+// be defined\n+class AttrInputLiteral;\n+\n+// TODO: move applicable stuff into here or just don't include it because\n+// nothing uses it A segment of a path (maybe)\n+class PathSegment\n+{\n+public:\n+  virtual ~PathSegment () {}\n+\n+  virtual ::std::string as_string () const = 0;\n+\n+  // TODO: add visitor here?\n+};\n+\n+// A segment of a simple path without generic or type arguments\n+class SimplePathSegment : public PathSegment\n+{\n+  ::std::string segment_name;\n+  Location locus;\n+\n+  // only allow identifiers, \"super\", \"self\", \"crate\", or \"$crate\"\n+public:\n+  // TODO: put checks in constructor to enforce this rule?\n+  SimplePathSegment (::std::string segment_name, Location locus = Location ())\n+    : segment_name (::std::move (segment_name)), locus (locus)\n+  {}\n+\n+  // Returns whether simple path segment is in an invalid state (currently, if\n+  // empty).\n+  inline bool is_error () const { return segment_name.empty (); }\n+\n+  // Creates an error SimplePathSegment\n+  static SimplePathSegment create_error ()\n+  {\n+    return SimplePathSegment (::std::string (\"\"));\n+  }\n+\n+  ::std::string as_string () const;\n+\n+  inline Location get_locus () const { return locus; }\n+\n+  // TODO: visitor pattern?\n+};\n+\n+// A simple path without generic or type arguments\n+class SimplePath\n+{\n+  bool has_opening_scope_resolution;\n+  ::std::vector<SimplePathSegment> segments;\n+  Location locus;\n+\n+public:\n+  // Constructor\n+  SimplePath (::std::vector<SimplePathSegment> path_segments,\n+\t      bool has_opening_scope_resolution = false,\n+\t      Location locus = Location ())\n+    : has_opening_scope_resolution (has_opening_scope_resolution),\n+      segments (::std::move (path_segments)), locus (locus)\n+  {}\n+\n+  // Creates an empty SimplePath.\n+  static SimplePath create_empty ()\n+  {\n+    return SimplePath (::std::vector<SimplePathSegment> ());\n+  }\n+\n+  // Returns whether the SimplePath is empty, i.e. has path segments.\n+  inline bool is_empty () const { return segments.empty (); }\n+\n+  ::std::string as_string () const;\n+\n+  Location get_locus () const { return locus; }\n+\n+  // does this need visitor if not polymorphic? probably not\n+\n+  // path-to-string comparison operator\n+  bool operator== (const ::std::string &rhs)\n+  {\n+    return !has_opening_scope_resolution && segments.size () == 1\n+\t   && segments[0].as_string () == rhs;\n+  }\n+\n+  /* Creates a single-segment SimplePath from a string. This will not check to\n+   * ensure that this is a valid identifier in path, so be careful. Also, this\n+   * will have no location data.\n+   * TODO have checks? */\n+  static SimplePath from_str (::std::string str)\n+  {\n+    ::std::vector<AST::SimplePathSegment> single_segments\n+      = {AST::SimplePathSegment (::std::move (str))};\n+    return SimplePath (::std::move (single_segments));\n+  }\n+};\n+\n+// aka Attr\n+// Attribute AST representation\n+struct Attribute\n+{\n+private:\n+  SimplePath path;\n+\n+  // bool has_attr_input;\n+  // AttrInput* attr_input;\n+  ::std::unique_ptr<AttrInput> attr_input;\n+\n+  Location locus;\n+\n+  // TODO: maybe a variable storing whether attr input is parsed or not\n+\n+public:\n+  // Returns whether Attribute has AttrInput\n+  inline bool has_attr_input () const { return attr_input != NULL; }\n+\n+  // Constructor has pointer AttrInput for polymorphism reasons\n+  Attribute (SimplePath path, ::std::unique_ptr<AttrInput> input,\n+\t     Location locus = Location ())\n+    : path (::std::move (path)), attr_input (::std::move (input)), locus (locus)\n+  {}\n+\n+  // Copy constructor must deep copy attr_input as unique pointer\n+  Attribute (Attribute const &other) : path (other.path), locus (other.locus)\n+  {\n+    // guard to protect from null pointer dereference\n+    if (other.attr_input != NULL)\n+      {\n+\tattr_input = other.attr_input->clone_attr_input ();\n+      }\n+  }\n+\n+  // default destructor\n+  ~Attribute () = default;\n+\n+  // overload assignment operator to use custom clone method\n+  Attribute &operator= (Attribute const &other)\n+  {\n+    path = other.path;\n+    locus = other.locus;\n+    // guard to protect from null pointer dereference\n+    if (other.attr_input != NULL)\n+      {\n+\tattr_input = other.attr_input->clone_attr_input ();\n+      }\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  Attribute (Attribute &&other) = default;\n+  Attribute &operator= (Attribute &&other) = default;\n+\n+  // Unique pointer custom clone function\n+  ::std::unique_ptr<Attribute> clone_attribute () const\n+  {\n+    return ::std::unique_ptr<Attribute> (clone_attribute_impl ());\n+  }\n+\n+  /*~Attribute() {\n+      delete attr_input;\n+  }*/\n+\n+  // Creates an empty attribute (which is invalid)\n+  static Attribute create_empty ()\n+  {\n+    return Attribute (SimplePath::create_empty (), NULL);\n+  }\n+\n+  // Returns whether the attribute is considered an \"empty\" attribute.\n+  inline bool is_empty () const\n+  {\n+    return attr_input == NULL && path.is_empty ();\n+  }\n+\n+  /* e.g.:\n+      #![crate_type = \"lib\"]\n+      #[test]\n+      #[cfg(target_os = \"linux\")]\n+      #[allow(non_camel_case_types)]\n+      #![allow(unused_variables)]\n+  */\n+\n+  // Full built-in attribute list:\n+  /*   cfg\n+   *   cfg_attr\n+   *   test\n+   *   ignore\n+   *   should_panic\n+   *   derive\n+   *   macro_export\n+   *   macro_use\n+   *   proc_macro\n+   *   proc_macro_derive\n+   *   proc_macro_attribute\n+   *   allow\n+   *   warn\n+   *   deny\n+   *   forbid\n+   *   deprecated\n+   *   must_use\n+   *   link\n+   *   link_name\n+   *   no_link\n+   *   repr\n+   *   crate_type\n+   *   no_main\n+   *   export_name\n+   *   link_section\n+   *   no_mangle\n+   *   used\n+   *   crate_name\n+   *   inline\n+   *   cold\n+   *   no_builtins\n+   *   target_feature\n+   *   doc\n+   *   no_std\n+   *   no_implicit_prelude\n+   *   path\n+   *   recursion_limit\n+   *   type_length_limit\n+   *   panic_handler\n+   *   global_allocator\n+   *   windows_subsystem\n+   *   feature     */\n+\n+  ::std::string as_string () const;\n+\n+  // TODO: does this require visitor pattern as not polymorphic?\n+\n+  // Maybe change to const-reference in future\n+  SimplePath get_path () const { return path; }\n+\n+  // Call to parse attribute body to meta item syntax.\n+  void parse_attr_to_meta_item ();\n+\n+  // Determines whether cfg predicate is true and item with attribute should not\n+  // be stripped.\n+  bool check_cfg_predicate (const Session &session)\n+  {\n+    // assume that cfg predicate actually can exist, i.e. attribute has cfg or\n+    // cfg_attr path\n+\n+    if (!has_attr_input ())\n+      {\n+\treturn false;\n+      }\n+\n+    // TODO: maybe replace with storing a \"has been parsed\" variable?\n+    parse_attr_to_meta_item ();\n+    // can't be const because of this anyway\n+\n+    return attr_input->check_cfg_predicate (session);\n+  }\n+\n+protected:\n+  // not virtual as currently no subclasses of Attribute, but could be in future\n+  /*virtual*/ Attribute *clone_attribute_impl () const\n+  {\n+    return new Attribute (*this);\n+  }\n+};\n+\n+// Forward decl - defined in rust-macro.h\n+class MetaNameValueStr;\n+\n+// abstract base meta item inner class\n+class MetaItemInner\n+{\n+protected:\n+  // pure virtual as MetaItemInner\n+  virtual MetaItemInner *clone_meta_item_inner_impl () const = 0;\n+\n+public:\n+  // Unique pointer custom clone function\n+  ::std::unique_ptr<MetaItemInner> clone_meta_item_inner () const\n+  {\n+    return ::std::unique_ptr<MetaItemInner> (clone_meta_item_inner_impl ());\n+  }\n+\n+  virtual ~MetaItemInner () {}\n+\n+  virtual ::std::string as_string () const = 0;\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+  // HACK: used to simplify parsing - creates a copy of that type, or returns\n+  // null\n+  virtual MetaNameValueStr *to_meta_name_value_str () const { return NULL; }\n+\n+  // HACK: used to simplify parsing - same thing\n+  virtual SimplePath to_path_item () const\n+  {\n+    return SimplePath::create_empty ();\n+  }\n+\n+  virtual bool check_cfg_predicate (const Session &session) const = 0;\n+};\n+\n+// Container used to store MetaItems as AttrInput (bridge-ish kinda thing)\n+class AttrInputMetaItemContainer : public AttrInput\n+{\n+  ::std::vector< ::std::unique_ptr<MetaItemInner> > items;\n+\n+public:\n+  AttrInputMetaItemContainer (\n+    ::std::vector< ::std::unique_ptr<MetaItemInner> > items)\n+    : items (::std::move (items))\n+  {}\n+\n+  // copy constructor with vector clone\n+  AttrInputMetaItemContainer (const AttrInputMetaItemContainer &other)\n+  {\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    items.reserve (other.items.size ());\n+\n+    for (const auto &e : other.items)\n+      {\n+\titems.push_back (e->clone_meta_item_inner ());\n+      }\n+  }\n+\n+  // no destructor definition required\n+\n+  // copy assignment operator with vector clone\n+  AttrInputMetaItemContainer &\n+  operator= (const AttrInputMetaItemContainer &other)\n+  {\n+    AttrInput::operator= (other);\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    items.reserve (other.items.size ());\n+\n+    for (const auto &e : other.items)\n+      {\n+\titems.push_back (e->clone_meta_item_inner ());\n+      }\n+\n+    return *this;\n+  }\n+\n+  // default move constructors\n+  AttrInputMetaItemContainer (AttrInputMetaItemContainer &&other) = default;\n+  AttrInputMetaItemContainer &operator= (AttrInputMetaItemContainer &&other)\n+    = default;\n+\n+  ::std::string as_string () const OVERRIDE;\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+  virtual bool check_cfg_predicate (const Session &session) const OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this type\n+  virtual AttrInputMetaItemContainer *clone_attr_input_impl () const OVERRIDE\n+  {\n+    return new AttrInputMetaItemContainer (*this);\n+  }\n+};\n+\n+// abstract base meta item class\n+class MetaItem : public MetaItemInner\n+{\n+};\n+\n+// Forward decl - defined in rust-expr.h\n+class MetaItemLitExpr;\n+\n+// Forward decl - defined in rust-expr.h\n+class MetaItemPathLit;\n+\n+// Forward decl - defined in rust-macro.h\n+class MetaItemPath;\n+\n+// Forward decl - defined in rust-macro.h\n+class MetaItemSeq;\n+\n+// Forward decl - defined in rust-macro.h\n+class MetaWord;\n+\n+// Forward decl - defined in rust-macro.h\n+class MetaListPaths;\n+\n+// Forward decl - defined in rust-macro.h\n+struct MetaListNameValueStr;\n+\n+/* Base statement abstract class. Note that most \"statements\" are not allowed in\n+ * top-level module scope - only a subclass of statements called \"items\" are. */\n+class Stmt\n+{\n+public:\n+  // Unique pointer custom clone function\n+  ::std::unique_ptr<Stmt> clone_stmt () const\n+  {\n+    return ::std::unique_ptr<Stmt> (clone_stmt_impl ());\n+  }\n+\n+  virtual ~Stmt () {}\n+\n+  virtual ::std::string as_string () const = 0;\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+protected:\n+  // Clone function implementation as pure virtual method\n+  virtual Stmt *clone_stmt_impl () const = 0;\n+};\n+\n+// Rust \"item\" AST node (declaration of top-level/module-level allowed stuff)\n+class Item : public Stmt\n+{\n+  ::std::vector<Attribute> outer_attrs;\n+\n+  // TODO: should outer attrs be defined here or in each derived class?\n+\n+public:\n+  // Unique pointer custom clone function\n+  ::std::unique_ptr<Item> clone_item () const\n+  {\n+    return ::std::unique_ptr<Item> (clone_item_impl ());\n+  }\n+\n+  ::std::string as_string () const;\n+\n+  // Adds crate names to the vector passed by reference, if it can\n+  // (polymorphism).\n+  virtual void\n+  add_crate_name (::std::vector< ::std::string> &names ATTRIBUTE_UNUSED) const\n+  {}\n+\n+protected:\n+  // Constructor\n+  Item (::std::vector<Attribute> outer_attribs = ::std::vector<Attribute> ())\n+    : outer_attrs (::std::move (outer_attribs))\n+  {}\n+\n+  // Clone function implementation as pure virtual method\n+  virtual Item *clone_item_impl () const = 0;\n+\n+  /* Save having to specify two clone methods in derived classes by making\n+   * statement clone return item clone. Hopefully won't affect performance too\n+   * much. */\n+  virtual Item *clone_stmt_impl () const OVERRIDE { return clone_item_impl (); }\n+};\n+\n+// forward decl of ExprWithoutBlock\n+class ExprWithoutBlock;\n+\n+// Base expression AST node - abstract\n+class Expr\n+{\n+  // TODO: move outer attribute data to derived classes?\n+  ::std::vector<Attribute> outer_attrs;\n+\n+public:\n+  inline const ::std::vector<Attribute> &get_outer_attrs () const\n+  {\n+    return outer_attrs;\n+  }\n+\n+  // Unique pointer custom clone function\n+  ::std::unique_ptr<Expr> clone_expr () const\n+  {\n+    return ::std::unique_ptr<Expr> (clone_expr_impl ());\n+  }\n+\n+  /* TODO: public methods that could be useful:\n+   *  - get_type() - returns type of expression. set_type() may also be useful\n+   * for some?\n+   *  - evaluate() - evaluates expression if constant? can_evaluate()? */\n+\n+  // HACK: downcasting without dynamic_cast (if possible) via polymorphism -\n+  // overrided in subclasses of ExprWithoutBlock\n+  virtual ExprWithoutBlock *as_expr_without_block () const\n+  {\n+    // DEBUG\n+    fprintf (\n+      stderr,\n+      \"clone expr without block returns null and has not been overriden\\n\");\n+\n+    return NULL;\n+  }\n+\n+  // TODO: make pure virtual if move out outer attributes to derived classes\n+  virtual ::std::string as_string () const;\n+\n+  virtual ~Expr () {}\n+\n+  // HACK: slow way of getting location from base expression through virtual\n+  // methods.\n+  virtual Location get_locus_slow () const { return Location (); }\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+protected:\n+  // Constructor\n+  Expr (::std::vector<Attribute> outer_attribs = ::std::vector<Attribute> ())\n+    : outer_attrs (::std::move (outer_attribs))\n+  {}\n+\n+  // Clone function implementation as pure virtual method\n+  virtual Expr *clone_expr_impl () const = 0;\n+\n+  // TODO: think of less hacky way to implement this kind of thing\n+  // Sets outer attributes.\n+  void set_outer_attrs (::std::vector<Attribute> outer_attrs_to_set)\n+  {\n+    outer_attrs = ::std::move (outer_attrs_to_set);\n+  }\n+};\n+\n+// AST node for an expression without an accompanying block - abstract\n+class ExprWithoutBlock : public Expr\n+{\n+protected:\n+  // Constructor\n+  ExprWithoutBlock (::std::vector<Attribute> outer_attribs\n+\t\t    = ::std::vector<Attribute> ())\n+    : Expr (::std::move (outer_attribs))\n+  {}\n+\n+  // pure virtual clone implementation\n+  virtual ExprWithoutBlock *clone_expr_without_block_impl () const = 0;\n+\n+  /* Save having to specify two clone methods in derived classes by making expr\n+   * clone\n+   * return exprwithoutblock clone. Hopefully won't affect performance too much.\n+   */\n+  virtual ExprWithoutBlock *clone_expr_impl () const OVERRIDE\n+  {\n+    return clone_expr_without_block_impl ();\n+  }\n+\n+public:\n+  // Unique pointer custom clone function\n+  ::std::unique_ptr<ExprWithoutBlock> clone_expr_without_block () const\n+  {\n+    return ::std::unique_ptr<ExprWithoutBlock> (\n+      clone_expr_without_block_impl ());\n+  }\n+\n+  // downcasting hack from expr to use pratt parsing with\n+  // parse_expr_without_block\n+  virtual ExprWithoutBlock *as_expr_without_block () const OVERRIDE\n+  {\n+    // DEBUG\n+    fprintf (stderr, \"about to call the impl for clone expr without block\\n\");\n+\n+    return clone_expr_without_block_impl ();\n+  }\n+};\n+\n+// HACK: IdentifierExpr, delete when figure out identifier vs expr problem in\n+// Pratt parser Alternatively, identifiers could just be represented as\n+// single-segment paths\n+class IdentifierExpr : public ExprWithoutBlock\n+{\n+  Identifier ident;\n+\n+  Location locus;\n+\n+public:\n+  IdentifierExpr (Identifier ident, Location locus = Location (),\n+\t\t  ::std::vector<Attribute> outer_attrs\n+\t\t  = ::std::vector<Attribute> ())\n+    : ExprWithoutBlock (::std::move (outer_attrs)), ident (::std::move (ident)),\n+      locus (locus)\n+  {}\n+\n+  ::std::string as_string () const OVERRIDE { return ident; }\n+\n+  Location get_locus () const { return locus; }\n+\n+  Location get_locus_slow () const OVERRIDE { return get_locus (); }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Clone method implementation\n+  virtual IdentifierExpr *clone_expr_without_block_impl () const OVERRIDE\n+  {\n+    return new IdentifierExpr (*this);\n+  }\n+};\n+\n+// Pattern base AST node\n+class Pattern\n+{\n+public:\n+  // Unique pointer custom clone function\n+  ::std::unique_ptr<Pattern> clone_pattern () const\n+  {\n+    return ::std::unique_ptr<Pattern> (clone_pattern_impl ());\n+  }\n+\n+  // possible virtual methods: is_refutable()\n+\n+  virtual ~Pattern () {}\n+\n+  virtual ::std::string as_string () const = 0;\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+protected:\n+  // Clone pattern implementation as pure virtual method\n+  virtual Pattern *clone_pattern_impl () const = 0;\n+};\n+\n+// forward decl for Type\n+class TraitBound;\n+\n+// Base class for types as represented in AST - abstract\n+class Type\n+{\n+public:\n+  // Unique pointer custom clone function\n+  ::std::unique_ptr<Type> clone_type () const\n+  {\n+    return ::std::unique_ptr<Type> (clone_type_impl ());\n+  }\n+\n+  // virtual destructor\n+  virtual ~Type () {}\n+\n+  virtual ::std::string as_string () const = 0;\n+\n+  // HACK: convert to trait bound. Virtual method overriden by classes that\n+  // enable this.\n+  virtual TraitBound *to_trait_bound (bool in_parens ATTRIBUTE_UNUSED) const\n+  {\n+    return NULL;\n+  }\n+  // as pointer, shouldn't require definition beforehand, only forward\n+  // declaration.\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+protected:\n+  // Clone function implementation as pure virtual method\n+  virtual Type *clone_type_impl () const = 0;\n+};\n+\n+// A type without parentheses? - abstract\n+class TypeNoBounds : public Type\n+{\n+public:\n+  // Unique pointer custom clone function\n+  ::std::unique_ptr<TypeNoBounds> clone_type_no_bounds () const\n+  {\n+    return ::std::unique_ptr<TypeNoBounds> (clone_type_no_bounds_impl ());\n+  }\n+\n+protected:\n+  // Clone function implementation as pure virtual method\n+  virtual TypeNoBounds *clone_type_no_bounds_impl () const = 0;\n+\n+  /* Save having to specify two clone methods in derived classes by making type\n+   * clone return typenobounds clone. Hopefully won't affect performance too\n+   * much. */\n+  virtual TypeNoBounds *clone_type_impl () const OVERRIDE\n+  {\n+    return clone_type_no_bounds_impl ();\n+  }\n+};\n+\n+// Abstract base class representing a type param bound - Lifetime and TraitBound\n+// extends it\n+class TypeParamBound\n+{\n+public:\n+  virtual ~TypeParamBound () {}\n+\n+  // Unique pointer custom clone function\n+  ::std::unique_ptr<TypeParamBound> clone_type_param_bound () const\n+  {\n+    return ::std::unique_ptr<TypeParamBound> (clone_type_param_bound_impl ());\n+  }\n+\n+  virtual ::std::string as_string () const = 0;\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+protected:\n+  // Clone function implementation as pure virtual method\n+  virtual TypeParamBound *clone_type_param_bound_impl () const = 0;\n+};\n+\n+// Represents a lifetime (and is also a kind of type param bound)\n+class Lifetime : public TypeParamBound\n+{\n+public:\n+  enum LifetimeType\n+  {\n+    NAMED,   // corresponds to LIFETIME_OR_LABEL\n+    STATIC,  // corresponds to 'static\n+    WILDCARD // corresponds to '_\n+  };\n+\n+private:\n+  LifetimeType lifetime_type;\n+\n+  // TODO: LIFETIME_OR_LABEL (aka lifetime token) is only field\n+  // find way of enclosing token or something\n+  ::std::string lifetime_name;\n+  // only applies for NAMED lifetime_type\n+\n+  Location locus;\n+\n+public:\n+  // Constructor\n+  Lifetime (LifetimeType type, ::std::string name = ::std::string (),\n+\t    Location locus = Location ())\n+    : lifetime_type (type), lifetime_name (::std::move (name)), locus (locus)\n+  {}\n+\n+  // Creates an \"error\" lifetime.\n+  static Lifetime error () { return Lifetime (NAMED, ::std::string (\"\")); }\n+\n+  // Returns true if the lifetime is in an error state.\n+  inline bool is_error () const\n+  {\n+    return lifetime_type == NAMED && lifetime_name.empty ();\n+  }\n+\n+  ::std::string as_string () const;\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual Lifetime *clone_type_param_bound_impl () const OVERRIDE\n+  {\n+    return new Lifetime (*this);\n+  }\n+};\n+\n+// Base generic parameter in AST. Abstract - can be represented by a Lifetime or\n+// Type param\n+class GenericParam\n+{\n+public:\n+  virtual ~GenericParam () {}\n+\n+  // Unique pointer custom clone function\n+  ::std::unique_ptr<GenericParam> clone_generic_param () const\n+  {\n+    return ::std::unique_ptr<GenericParam> (clone_generic_param_impl ());\n+  }\n+\n+  virtual ::std::string as_string () const = 0;\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+protected:\n+  // Clone function implementation as pure virtual method\n+  virtual GenericParam *clone_generic_param_impl () const = 0;\n+};\n+\n+// A lifetime generic parameter (as opposed to a type generic parameter)\n+class LifetimeParam : public GenericParam\n+{\n+  Lifetime lifetime;\n+\n+  // bool has_lifetime_bounds;\n+  // LifetimeBounds lifetime_bounds;\n+  ::std::vector<Lifetime> lifetime_bounds; // inlined LifetimeBounds\n+\n+  // bool has_outer_attribute;\n+  //::std::unique_ptr<Attribute> outer_attr;\n+  Attribute outer_attr;\n+\n+  Location locus;\n+\n+public:\n+  // Returns whether the lifetime param has any lifetime bounds.\n+  inline bool has_lifetime_bounds () const { return !lifetime_bounds.empty (); }\n+\n+  // Returns whether the lifetime param has an outer attribute.\n+  inline bool has_outer_attribute () const { return !outer_attr.is_empty (); }\n+\n+  // Creates an error state lifetime param.\n+  static LifetimeParam create_error ()\n+  {\n+    return LifetimeParam (Lifetime::error ());\n+  }\n+\n+  // Returns whether the lifetime param is in an error state.\n+  inline bool is_error () const { return lifetime.is_error (); }\n+\n+  // Constructor\n+  LifetimeParam (Lifetime lifetime, Location locus = Location (),\n+\t\t ::std::vector<Lifetime> lifetime_bounds\n+\t\t = ::std::vector<Lifetime> (),\n+\t\t Attribute outer_attr = Attribute::create_empty ())\n+    : lifetime (::std::move (lifetime)),\n+      lifetime_bounds (::std::move (lifetime_bounds)),\n+      outer_attr (::std::move (outer_attr)), locus (locus)\n+  {}\n+\n+  // TODO: remove copy and assignment operator definitions - not required\n+\n+  // Copy constructor with clone\n+  LifetimeParam (LifetimeParam const &other)\n+    : lifetime (other.lifetime), lifetime_bounds (other.lifetime_bounds),\n+      outer_attr (other.outer_attr), locus (other.locus)\n+  {}\n+\n+  // Destructor - define here if required\n+\n+  // Overloaded assignment operator to clone attribute\n+  LifetimeParam &operator= (LifetimeParam const &other)\n+  {\n+    lifetime = other.lifetime;\n+    lifetime_bounds = other.lifetime_bounds;\n+    outer_attr = other.outer_attr;\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  LifetimeParam (LifetimeParam &&other) = default;\n+  LifetimeParam &operator= (LifetimeParam &&other) = default;\n+\n+  ::std::string as_string () const;\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual LifetimeParam *clone_generic_param_impl () const OVERRIDE\n+  {\n+    return new LifetimeParam (*this);\n+  }\n+};\n+\n+// A macro item AST node - potentially abstract base class\n+class MacroItem : public Item\n+{\n+  /*public:\n+  ::std::string as_string() const;*/\n+protected:\n+  MacroItem (::std::vector<Attribute> outer_attribs)\n+    : Item (::std::move (outer_attribs))\n+  {}\n+};\n+\n+// Item used in trait declarations - abstract base class\n+class TraitItem\n+{\n+  // bool has_outer_attrs;\n+  // TODO: remove and rely on virtual functions and VisItem-derived attributes?\n+  //::std::vector<Attribute> outer_attrs;\n+\n+  // NOTE: all children should have outer attributes\n+\n+protected:\n+  // Constructor\n+  /*TraitItem(::std::vector<Attribute> outer_attrs = ::std::vector<Attribute>())\n+    : outer_attrs(::std::move(outer_attrs)) {}*/\n+\n+  // Clone function implementation as pure virtual method\n+  virtual TraitItem *clone_trait_item_impl () const = 0;\n+\n+public:\n+  virtual ~TraitItem () {}\n+\n+  // Returns whether TraitItem has outer attributes.\n+  /*inline bool has_outer_attrs() const {\n+      return !outer_attrs.empty();\n+  }*/\n+\n+  // Unique pointer custom clone function\n+  ::std::unique_ptr<TraitItem> clone_trait_item () const\n+  {\n+    return ::std::unique_ptr<TraitItem> (clone_trait_item_impl ());\n+  }\n+\n+  virtual ::std::string as_string () const = 0;\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+};\n+\n+// Abstract base class for items used within an inherent impl block (the impl\n+// name {} one)\n+class InherentImplItem\n+{\n+protected:\n+  // Clone function implementation as pure virtual method\n+  virtual InherentImplItem *clone_inherent_impl_item_impl () const = 0;\n+\n+public:\n+  virtual ~InherentImplItem () {}\n+\n+  // Unique pointer custom clone function\n+  ::std::unique_ptr<InherentImplItem> clone_inherent_impl_item () const\n+  {\n+    return ::std::unique_ptr<InherentImplItem> (\n+      clone_inherent_impl_item_impl ());\n+  }\n+\n+  virtual ::std::string as_string () const = 0;\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+};\n+\n+// Abstract base class for items used in a trait impl\n+class TraitImplItem\n+{\n+protected:\n+  virtual TraitImplItem *clone_trait_impl_item_impl () const = 0;\n+\n+public:\n+  virtual ~TraitImplItem (){};\n+\n+  // Unique pointer custom clone function\n+  ::std::unique_ptr<TraitImplItem> clone_trait_impl_item () const\n+  {\n+    return ::std::unique_ptr<TraitImplItem> (clone_trait_impl_item_impl ());\n+  }\n+\n+  virtual ::std::string as_string () const = 0;\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+};\n+\n+// A macro invocation item (or statement) AST node (i.e. semi-coloned macro\n+// invocation)\n+class MacroInvocationSemi : public MacroItem,\n+\t\t\t    public TraitItem,\n+\t\t\t    public InherentImplItem,\n+\t\t\t    public TraitImplItem\n+/*, public Statement*/ {\n+  // already inherits from statement indirectly via item as item is a subclass\n+  // of statement\n+  SimplePath path;\n+  // all delim types except curly must have invocation end with a semicolon\n+  DelimType delim_type;\n+  //::std::vector<TokenTree> token_trees;\n+  ::std::vector< ::std::unique_ptr<TokenTree> > token_trees;\n+\n+  Location locus;\n+\n+public:\n+  ::std::string as_string () const;\n+\n+  MacroInvocationSemi (\n+    SimplePath macro_path, DelimType delim_type,\n+    ::std::vector< ::std::unique_ptr<TokenTree> > token_trees,\n+    ::std::vector<Attribute> outer_attribs, Location locus)\n+    : MacroItem (::std::move (outer_attribs)), path (::std::move (macro_path)),\n+      delim_type (delim_type), token_trees (::std::move (token_trees)),\n+      locus (locus)\n+  {}\n+  /* TODO: possible issue with Item and TraitItem hierarchies both having outer\n+   * attributes\n+   * - storage inefficiency at least.\n+   * Best current idea is to make Item preferred and have TraitItem get virtual\n+   * functions for attributes or something. Or just redo the \"composition\"\n+   * approach, but then this prevents polymorphism and would entail redoing\n+   * quite a bit of the parser. */\n+\n+  // Copy constructor with vector clone\n+  MacroInvocationSemi (MacroInvocationSemi const &other)\n+    : MacroItem (other), TraitItem (other), InherentImplItem (other),\n+      TraitImplItem (other), path (other.path), delim_type (other.delim_type),\n+      locus (other.locus)\n+  {\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    token_trees.reserve (other.token_trees.size ());\n+\n+    for (const auto &e : other.token_trees)\n+      {\n+\ttoken_trees.push_back (e->clone_token_tree ());\n+      }\n+  }\n+\n+  // Overloaded assignment operator to vector clone\n+  MacroInvocationSemi &operator= (MacroInvocationSemi const &other)\n+  {\n+    MacroItem::operator= (other);\n+    TraitItem::operator= (other);\n+    InherentImplItem::operator= (other);\n+    TraitImplItem::operator= (other);\n+    path = other.path;\n+    delim_type = other.delim_type;\n+    locus = other.locus;\n+\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    token_trees.reserve (other.token_trees.size ());\n+\n+    for (const auto &e : other.token_trees)\n+      {\n+\ttoken_trees.push_back (e->clone_token_tree ());\n+      }\n+\n+    return *this;\n+  }\n+\n+  // Move constructors\n+  MacroInvocationSemi (MacroInvocationSemi &&other) = default;\n+  MacroInvocationSemi &operator= (MacroInvocationSemi &&other) = default;\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual MacroInvocationSemi *clone_item_impl () const OVERRIDE\n+  {\n+    return new MacroInvocationSemi (*this);\n+  }\n+\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual MacroInvocationSemi *clone_inherent_impl_item_impl () const OVERRIDE\n+  {\n+    return new MacroInvocationSemi (*this);\n+  }\n+\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual MacroInvocationSemi *clone_trait_impl_item_impl () const OVERRIDE\n+  {\n+    return new MacroInvocationSemi (*this);\n+  }\n+\n+  // FIXME: remove if item impl virtual override works properly\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  /*virtual MacroInvocationSemi* clone_statement_impl() const OVERRIDE {\n+      return new MacroInvocationSemi(*this);\n+  }*/\n+\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual MacroInvocationSemi *clone_trait_item_impl () const OVERRIDE\n+  {\n+    return new MacroInvocationSemi (*this);\n+  }\n+};\n+\n+// A crate AST object - holds all the data for a single compilation unit\n+struct Crate\n+{\n+  bool has_utf8bom;\n+  bool has_shebang;\n+\n+  ::std::vector<Attribute> inner_attrs;\n+  //::std::vector<Item> items;\n+  // dodgy spacing required here\n+  // TODO: is it better to have a vector of items here or a module (implicit\n+  // top-level one)?\n+  ::std::vector< ::std::unique_ptr<Item> > items;\n+\n+public:\n+  // Constructor\n+  Crate (::std::vector< ::std::unique_ptr<Item> > items,\n+\t ::std::vector<Attribute> inner_attrs, bool has_utf8bom = false,\n+\t bool has_shebang = false)\n+    : has_utf8bom (has_utf8bom), has_shebang (has_shebang),\n+      inner_attrs (::std::move (inner_attrs)), items (::std::move (items))\n+  {}\n+\n+  // Copy constructor with vector clone\n+  Crate (Crate const &other)\n+    : has_utf8bom (other.has_utf8bom), has_shebang (other.has_shebang),\n+      inner_attrs (other.inner_attrs)\n+  {\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    items.reserve (other.items.size ());\n+\n+    for (const auto &e : other.items)\n+      {\n+\titems.push_back (e->clone_item ());\n+      }\n+  }\n+\n+  ~Crate () = default;\n+\n+  // Overloaded assignment operator with vector clone\n+  Crate &operator= (Crate const &other)\n+  {\n+    inner_attrs = other.inner_attrs;\n+    has_shebang = other.has_shebang;\n+    has_utf8bom = other.has_utf8bom;\n+\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    items.reserve (other.items.size ());\n+\n+    for (const auto &e : other.items)\n+      {\n+\titems.push_back (e->clone_item ());\n+      }\n+\n+    return *this;\n+  }\n+\n+  // Move constructors\n+  Crate (Crate &&other) = default;\n+  Crate &operator= (Crate &&other) = default;\n+\n+  // Get crate representation as string (e.g. for debugging).\n+  ::std::string as_string () const;\n+};\n+\n+// Base path expression AST node - abstract\n+class PathExpr : public ExprWithoutBlock\n+{\n+protected:\n+  PathExpr (::std::vector<Attribute> outer_attribs)\n+    : ExprWithoutBlock (::std::move (outer_attribs))\n+  {}\n+\n+public:\n+  // TODO: think of a better and less hacky way to allow this\n+\n+  // Replaces the outer attributes of this path expression with the given outer\n+  // attributes.\n+  void replace_outer_attrs (::std::vector<Attribute> outer_attrs)\n+  {\n+    set_outer_attrs (::std::move (outer_attrs));\n+  }\n+};\n+} // namespace AST\n+} // namespace Rust\n \n #endif"}, {"sha": "ae6eb0ab15bd4c00a53ec0678c7ee541773e7f87", "filename": "gcc/rust/ast/rust-cond-compilation.h", "status": "modified", "additions": 232, "deletions": 193, "changes": 425, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Fast%2Frust-cond-compilation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Fast%2Frust-cond-compilation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-cond-compilation.h?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -5,196 +5,235 @@\n #include \"rust-ast.h\"\n \n namespace Rust {\n-    namespace AST {\n-        // Base conditional compilation configuration predicate thing - abstract\n-        class ConfigurationPredicate {\n-          public:\n-            virtual ~ConfigurationPredicate() {}\n-\n-            // Unique pointer custom clone function\n-            ::std::unique_ptr<ConfigurationPredicate> clone_configuration_predicate() const {\n-                return ::std::unique_ptr<ConfigurationPredicate>(\n-                  clone_configuration_predicate_impl());\n-            }\n-\n-            // not sure if I'll use this but here anyway\n-            virtual void accept_vis(ASTVisitor& vis) = 0;\n-\n-          protected:\n-            // Clone function impl to be overriden in base classes\n-            virtual ConfigurationPredicate* clone_configuration_predicate_impl() const = 0;\n-        };\n-\n-        // A configuration option - true if option is set, false if option is not set.\n-        class ConfigurationOption : public ConfigurationPredicate {\n-            Identifier option_name;\n-\n-            // bool has_string_literal_option_body;\n-            ::std::string option_value; // technically a string or raw string literal\n-\n-          public:\n-            // Returns whether the configuration option has a \"value\" part of the key-value pair.\n-            inline bool has_option_value() const {\n-                return !option_value.empty();\n-            }\n-\n-            // Key-value pair constructor\n-            ConfigurationOption(Identifier option_name, ::std::string option_value) :\n-              option_name(option_name), option_value(option_value) {}\n-\n-            // Name-only constructor\n-            ConfigurationOption(Identifier option_name) : option_name(option_name) {}\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual ConfigurationOption* clone_configuration_predicate_impl() const OVERRIDE {\n-                return new ConfigurationOption(*this);\n-            }\n-        };\n-\n-        // TODO: inline\n-        struct ConfigurationPredicateList {\n-            ::std::vector< ::std::unique_ptr<ConfigurationPredicate> > predicate_list;\n-        };\n-\n-        // Predicate that returns true if all of the supplied predicates return true.\n-        class ConfigurationAll : public ConfigurationPredicate {\n-            ::std::vector< ::std::unique_ptr<ConfigurationPredicate> > predicate_list; // inlined form\n-\n-          public:\n-            ConfigurationAll(\n-              ::std::vector< ::std::unique_ptr<ConfigurationPredicate> > predicate_list) :\n-              predicate_list(predicate_list) {}\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual ConfigurationAll* clone_configuration_predicate_impl() const OVERRIDE {\n-                return new ConfigurationAll(*this);\n-            }\n-        };\n-\n-        // Predicate that returns true if any of the supplied predicates are true.\n-        class ConfigurationAny : public ConfigurationPredicate {\n-            ::std::vector< ::std::unique_ptr<ConfigurationPredicate> > predicate_list; // inlined form\n-\n-          public:\n-            ConfigurationAny(\n-              ::std::vector< ::std::unique_ptr<ConfigurationPredicate> > predicate_list) :\n-              predicate_list(predicate_list) {}\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual ConfigurationAny* clone_configuration_predicate_impl() const OVERRIDE {\n-                return new ConfigurationAny(*this);\n-            }\n-        };\n-\n-        // Predicate that produces the negation of a supplied other configuration predicate.\n-        class ConfigurationNot : public ConfigurationPredicate {\n-            ::std::unique_ptr<ConfigurationPredicate> config_to_negate;\n-\n-          public:\n-            ConfigurationNot(ConfigurationPredicate* config_to_negate) :\n-              config_to_negate(config_to_negate) {}\n-\n-            // Copy constructor with clone\n-            ConfigurationNot(ConfigurationNot const& other) :\n-              config_to_negate(other.config_to_negate->clone_configuration_predicate()) {}\n-\n-            // Destructor - define here if required\n-\n-            // Overloaded assignment operator to clone\n-            ConfigurationNot& operator=(ConfigurationNot const& other) {\n-                config_to_negate = other.config_to_negate->clone_configuration_predicate();\n-\n-                return *this;\n-            }\n-\n-            // move constructors\n-            ConfigurationNot(ConfigurationNot&& other) = default;\n-            ConfigurationNot& operator=(ConfigurationNot&& other) = default;\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual ConfigurationNot* clone_configuration_predicate_impl() const OVERRIDE {\n-                return new ConfigurationNot(*this);\n-            }\n-        };\n-\n-        // TODO: relationship to other attributes?\n-        class CfgAttribute {\n-            ::std::unique_ptr<ConfigurationPredicate> config_to_include;\n-\n-          public:\n-            CfgAttribute(ConfigurationPredicate* config_to_include) :\n-              config_to_include(config_to_include) {}\n-\n-            // Copy constructor with clone\n-            CfgAttribute(CfgAttribute const& other) :\n-              config_to_include(other.config_to_include->clone_configuration_predicate()) {}\n-\n-            // Destructor - define here if required\n-\n-            // Overloaded assignment operator to clone\n-            CfgAttribute& operator=(CfgAttribute const& other) {\n-                config_to_include = other.config_to_include->clone_configuration_predicate();\n-\n-                return *this;\n-            }\n-\n-            // move constructors\n-            CfgAttribute(CfgAttribute&& other) = default;\n-            CfgAttribute& operator=(CfgAttribute&& other) = default;\n-        };\n-        /* TODO: ok, best thing to do would be eliminating this class, making Attribute has a\n-         * \"is_cfg()\" method, and having attribute path as \"cfg\" and AttrInput as\n-         * ConfigurationPredicate (so make ConfigurationPredicate a subclass of AttrInput?). Would\n-         * need special handling in parser, however. */\n-\n-        // TODO: inline\n-        struct CfgAttrs {\n-            ::std::vector<Attribute> cfg_attrs;\n-        };\n-\n-        // TODO: relationship to other attributes?\n-        class CfgAttrAttribute {\n-            ::std::unique_ptr<ConfigurationPredicate> config_to_include;\n-            ::std::vector<Attribute> cfg_attrs;\n-\n-          public:\n-            CfgAttrAttribute(\n-              ConfigurationPredicate* config_to_include, ::std::vector<Attribute> cfg_attrs) :\n-              config_to_include(config_to_include),\n-              cfg_attrs(cfg_attrs) {}\n-\n-            // Copy constructor with clone\n-            CfgAttrAttribute(CfgAttrAttribute const& other) :\n-              config_to_include(other.config_to_include->clone_configuration_predicate()),\n-              cfg_attrs(cfg_attrs) {}\n-\n-            // Destructor - define here if required\n-\n-            // Overloaded assignment operator to clone\n-            CfgAttrAttribute& operator=(CfgAttrAttribute const& other) {\n-                config_to_include = other.config_to_include->clone_configuration_predicate();\n-                cfg_attrs = other.cfg_attrs;\n-\n-                return *this;\n-            }\n-\n-            // move constructors\n-            CfgAttrAttribute(CfgAttrAttribute&& other) = default;\n-            CfgAttrAttribute& operator=(CfgAttrAttribute&& other) = default;\n-        };\n-    }\n-}\n-\n-#endif\n\\ No newline at end of file\n+namespace AST {\n+// Base conditional compilation configuration predicate thing - abstract\n+class ConfigurationPredicate\n+{\n+public:\n+  virtual ~ConfigurationPredicate () {}\n+\n+  // Unique pointer custom clone function\n+  ::std::unique_ptr<ConfigurationPredicate>\n+  clone_configuration_predicate () const\n+  {\n+    return ::std::unique_ptr<ConfigurationPredicate> (\n+      clone_configuration_predicate_impl ());\n+  }\n+\n+  // not sure if I'll use this but here anyway\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+protected:\n+  // Clone function impl to be overriden in base classes\n+  virtual ConfigurationPredicate *\n+  clone_configuration_predicate_impl () const = 0;\n+};\n+\n+// A configuration option - true if option is set, false if option is not set.\n+class ConfigurationOption : public ConfigurationPredicate\n+{\n+  Identifier option_name;\n+\n+  // bool has_string_literal_option_body;\n+  ::std::string option_value; // technically a string or raw string literal\n+\n+public:\n+  // Returns whether the configuration option has a \"value\" part of the\n+  // key-value pair.\n+  inline bool has_option_value () const { return !option_value.empty (); }\n+\n+  // Key-value pair constructor\n+  ConfigurationOption (Identifier option_name, ::std::string option_value)\n+    : option_name (option_name), option_value (option_value)\n+  {}\n+\n+  // Name-only constructor\n+  ConfigurationOption (Identifier option_name) : option_name (option_name) {}\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual ConfigurationOption *\n+  clone_configuration_predicate_impl () const OVERRIDE\n+  {\n+    return new ConfigurationOption (*this);\n+  }\n+};\n+\n+// TODO: inline\n+struct ConfigurationPredicateList\n+{\n+  ::std::vector< ::std::unique_ptr<ConfigurationPredicate> > predicate_list;\n+};\n+\n+// Predicate that returns true if all of the supplied predicates return true.\n+class ConfigurationAll : public ConfigurationPredicate\n+{\n+  ::std::vector< ::std::unique_ptr<ConfigurationPredicate> >\n+    predicate_list; // inlined form\n+\n+public:\n+  ConfigurationAll (\n+    ::std::vector< ::std::unique_ptr<ConfigurationPredicate> > predicate_list)\n+    : predicate_list (predicate_list)\n+  {}\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual ConfigurationAll *clone_configuration_predicate_impl () const OVERRIDE\n+  {\n+    return new ConfigurationAll (*this);\n+  }\n+};\n+\n+// Predicate that returns true if any of the supplied predicates are true.\n+class ConfigurationAny : public ConfigurationPredicate\n+{\n+  ::std::vector< ::std::unique_ptr<ConfigurationPredicate> >\n+    predicate_list; // inlined form\n+\n+public:\n+  ConfigurationAny (\n+    ::std::vector< ::std::unique_ptr<ConfigurationPredicate> > predicate_list)\n+    : predicate_list (predicate_list)\n+  {}\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual ConfigurationAny *clone_configuration_predicate_impl () const OVERRIDE\n+  {\n+    return new ConfigurationAny (*this);\n+  }\n+};\n+\n+// Predicate that produces the negation of a supplied other configuration\n+// predicate.\n+class ConfigurationNot : public ConfigurationPredicate\n+{\n+  ::std::unique_ptr<ConfigurationPredicate> config_to_negate;\n+\n+public:\n+  ConfigurationNot (ConfigurationPredicate *config_to_negate)\n+    : config_to_negate (config_to_negate)\n+  {}\n+\n+  // Copy constructor with clone\n+  ConfigurationNot (ConfigurationNot const &other)\n+    : config_to_negate (\n+\tother.config_to_negate->clone_configuration_predicate ())\n+  {}\n+\n+  // Destructor - define here if required\n+\n+  // Overloaded assignment operator to clone\n+  ConfigurationNot &operator= (ConfigurationNot const &other)\n+  {\n+    config_to_negate = other.config_to_negate->clone_configuration_predicate ();\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  ConfigurationNot (ConfigurationNot &&other) = default;\n+  ConfigurationNot &operator= (ConfigurationNot &&other) = default;\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual ConfigurationNot *clone_configuration_predicate_impl () const OVERRIDE\n+  {\n+    return new ConfigurationNot (*this);\n+  }\n+};\n+\n+// TODO: relationship to other attributes?\n+class CfgAttribute\n+{\n+  ::std::unique_ptr<ConfigurationPredicate> config_to_include;\n+\n+public:\n+  CfgAttribute (ConfigurationPredicate *config_to_include)\n+    : config_to_include (config_to_include)\n+  {}\n+\n+  // Copy constructor with clone\n+  CfgAttribute (CfgAttribute const &other)\n+    : config_to_include (\n+\tother.config_to_include->clone_configuration_predicate ())\n+  {}\n+\n+  // Destructor - define here if required\n+\n+  // Overloaded assignment operator to clone\n+  CfgAttribute &operator= (CfgAttribute const &other)\n+  {\n+    config_to_include\n+      = other.config_to_include->clone_configuration_predicate ();\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  CfgAttribute (CfgAttribute &&other) = default;\n+  CfgAttribute &operator= (CfgAttribute &&other) = default;\n+};\n+/* TODO: ok, best thing to do would be eliminating this class, making Attribute\n+ * has a \"is_cfg()\" method, and having attribute path as \"cfg\" and AttrInput as\n+ * ConfigurationPredicate (so make ConfigurationPredicate a subclass of\n+ * AttrInput?). Would need special handling in parser, however. */\n+\n+// TODO: inline\n+struct CfgAttrs\n+{\n+  ::std::vector<Attribute> cfg_attrs;\n+};\n+\n+// TODO: relationship to other attributes?\n+class CfgAttrAttribute\n+{\n+  ::std::unique_ptr<ConfigurationPredicate> config_to_include;\n+  ::std::vector<Attribute> cfg_attrs;\n+\n+public:\n+  CfgAttrAttribute (ConfigurationPredicate *config_to_include,\n+\t\t    ::std::vector<Attribute> cfg_attrs)\n+    : config_to_include (config_to_include), cfg_attrs (cfg_attrs)\n+  {}\n+\n+  // Copy constructor with clone\n+  CfgAttrAttribute (CfgAttrAttribute const &other)\n+    : config_to_include (\n+\tother.config_to_include->clone_configuration_predicate ()),\n+      cfg_attrs (cfg_attrs)\n+  {}\n+\n+  // Destructor - define here if required\n+\n+  // Overloaded assignment operator to clone\n+  CfgAttrAttribute &operator= (CfgAttrAttribute const &other)\n+  {\n+    config_to_include\n+      = other.config_to_include->clone_configuration_predicate ();\n+    cfg_attrs = other.cfg_attrs;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  CfgAttrAttribute (CfgAttrAttribute &&other) = default;\n+  CfgAttrAttribute &operator= (CfgAttrAttribute &&other) = default;\n+};\n+} // namespace AST\n+} // namespace Rust\n+\n+#endif"}, {"sha": "2bc6cf992e96402a4ad40fa0a3f342c0f246af82", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 5186, "deletions": 4595, "changes": 9781, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=7266d66d2321562ef74daf90ffb1ad70d081d890"}, {"sha": "fe5b5d813d8dbf5939582e20e485ed997ddc42fd", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 640, "deletions": 577, "changes": 1217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -4,584 +4,647 @@\n #include \"rust-ast.h\"\n \n namespace Rust {\n-    namespace AST {\n-        // Decls as definitions moved to rust-ast.h\n-        class MacroItem;\n-        class MacroInvocationSemi;\n-\n-        enum MacroFragSpec {\n-            BLOCK,\n-            EXPR,\n-            IDENT,\n-            ITEM,\n-            LIFETIME,\n-            LITERAL,\n-            META,\n-            PAT,\n-            PATH,\n-            STMT,\n-            TT,\n-            TY,\n-            VIS,\n-            INVALID // not really a specifier, but used to mark invalid one passed in\n-        };\n-\n-        inline MacroFragSpec get_frag_spec_from_str(::std::string str) {\n-            if (str == \"block\")\n-                return BLOCK;\n-            else if (str == \"expr\")\n-                return EXPR;\n-            else if (str == \"ident\")\n-                return IDENT;\n-            else if (str == \"item\")\n-                return ITEM;\n-            else if (str == \"lifetime\")\n-                return LIFETIME;\n-            else if (str == \"literal\")\n-                return LITERAL;\n-            else if (str == \"meta\")\n-                return META;\n-            else if (str == \"pat\")\n-                return PAT;\n-            else if (str == \"path\")\n-                return PATH;\n-            else if (str == \"stmt\")\n-                return STMT;\n-            else if (str == \"tt\")\n-                return TT;\n-            else if (str == \"ty\")\n-                return TY;\n-            else if (str == \"vis\")\n-                return VIS;\n-            else {\n-                // error_at(\"invalid string '%s' used as fragment specifier\", str->c_str());\n-                return INVALID;\n-            }\n-        }\n-\n-        // A macro match that has an identifier and fragment spec\n-        class MacroMatchFragment : public MacroMatch {\n-            Identifier ident;\n-            MacroFragSpec frag_spec;\n-\n-            // TODO: should store location information?\n-\n-          public:\n-            MacroMatchFragment(Identifier ident, MacroFragSpec frag_spec) :\n-              ident(::std::move(ident)), frag_spec(frag_spec) {}\n-\n-            // Returns whether macro match fragment is in an error state.\n-            inline bool is_error() const {\n-                return frag_spec == INVALID;\n-            }\n-\n-            // Creates an error state macro match fragment.\n-            static MacroMatchFragment create_error() {\n-                return MacroMatchFragment(::std::string(\"\"), INVALID);\n-            }\n-\n-            ::std::string as_string() const;\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual MacroMatchFragment* clone_macro_match_impl() const OVERRIDE {\n-                return new MacroMatchFragment(*this);\n-            }\n-        };\n-\n-        // A repetition macro match\n-        class MacroMatchRepetition : public MacroMatch {\n-          public:\n-            enum MacroRepOp { NONE, ASTERISK, PLUS, QUESTION_MARK };\n-\n-          private:\n-            //::std::vector<MacroMatch> matches;\n-            ::std::vector< ::std::unique_ptr<MacroMatch> > matches;\n-            MacroRepOp op;\n-\n-            // bool has_sep;\n-            typedef Token MacroRepSep;\n-            // any token except delimiters and repetition operators\n-            ::std::unique_ptr<MacroRepSep> sep;\n-\n-            // TODO: should store location information?\n-\n-          public:\n-            // Returns whether macro match repetition has separator token.\n-            inline bool has_sep() const {\n-                return sep != NULL;\n-            }\n-\n-            MacroMatchRepetition(::std::vector< ::std::unique_ptr<MacroMatch> > matches,\n-              MacroRepOp op, ::std::unique_ptr<MacroRepSep> sep) :\n-              matches(::std::move(matches)),\n-              op(op), sep(::std::move(sep)) {}\n-\n-            // Copy constructor with clone\n-            MacroMatchRepetition(MacroMatchRepetition const& other) :\n-              /*matches(other.matches),*/ op(other.op), sep(other.sep->clone_token()) {\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                matches.reserve(other.matches.size());\n-\n-                for (const auto& e : other.matches) {\n-                    matches.push_back(e->clone_macro_match());\n-                }\n-            }\n-\n-            // Destructor - define here if required\n-\n-            // Overloaded assignment operator to clone\n-            MacroMatchRepetition& operator=(MacroMatchRepetition const& other) {\n-                // matches = other.matches; // TODO: this needs to clone somehow?\n-                op = other.op;\n-                sep = other.sep->clone_token();\n-\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                matches.reserve(other.matches.size());\n-\n-                for (const auto& e : other.matches) {\n-                    matches.push_back(e->clone_macro_match());\n-                }\n-\n-                return *this;\n-            }\n-\n-            // move constructors\n-            MacroMatchRepetition(MacroMatchRepetition&& other) = default;\n-            MacroMatchRepetition& operator=(MacroMatchRepetition&& other) = default;\n-\n-            ::std::string as_string() const;\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual MacroMatchRepetition* clone_macro_match_impl() const OVERRIDE {\n-                return new MacroMatchRepetition(*this);\n-            }\n-        };\n-\n-        // can't inline due to polymorphism\n-        class MacroMatcher : public MacroMatch {\n-            DelimType delim_type;\n-            //::std::vector<MacroMatch> matches;\n-            ::std::vector< ::std::unique_ptr<MacroMatch> > matches;\n-\n-            // TODO: think of way to mark invalid that doesn't take up more space\n-            bool is_invalid;\n-\n-            // TODO: should store location information?\n-\n-          public:\n-            MacroMatcher(\n-              DelimType delim_type, ::std::vector< ::std::unique_ptr<MacroMatch> > matches) :\n-              delim_type(delim_type),\n-              matches(::std::move(matches)), is_invalid(false) {}\n-\n-            // copy constructor with vector clone\n-            MacroMatcher(MacroMatcher const& other) : delim_type(other.delim_type) {\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                matches.reserve(other.matches.size());\n-\n-                for (const auto& e : other.matches) {\n-                    matches.push_back(e->clone_macro_match());\n-                }\n-            }\n-\n-            // overloaded assignment operator with vector clone\n-            MacroMatcher& operator=(MacroMatcher const& other) {\n-                delim_type = other.delim_type;\n-\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                matches.reserve(other.matches.size());\n-\n-                for (const auto& e : other.matches) {\n-                    matches.push_back(e->clone_macro_match());\n-                }\n-\n-                return *this;\n-            }\n-\n-            // move constructors\n-            MacroMatcher(MacroMatcher&& other) = default;\n-            MacroMatcher& operator=(MacroMatcher&& other) = default;\n-\n-            // Creates an error state macro matcher.\n-            static MacroMatcher create_error() {\n-                return MacroMatcher(true);\n-            }\n-\n-            // Returns whether MacroMatcher is in an error state.\n-            inline bool is_error() const {\n-                return is_invalid;\n-            }\n-\n-            ::std::string as_string() const;\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual MacroMatcher* clone_macro_match_impl() const OVERRIDE {\n-                return new MacroMatcher(*this);\n-            }\n-\n-            // constructor only used to create error matcher\n-            MacroMatcher(bool is_invalid) : delim_type(PARENS), is_invalid(is_invalid) {}\n-        };\n-\n-        // TODO: inline?\n-        struct MacroTranscriber {\n-          private:\n-            DelimTokenTree token_tree;\n-\n-            // TODO: should store location information?\n-\n-          public:\n-            MacroTranscriber(DelimTokenTree token_tree) : token_tree(::std::move(token_tree)) {}\n-\n-            ::std::string as_string() const {\n-                return token_tree.as_string();\n-            }\n-        };\n-\n-        // A macro rule? Matcher and transcriber pair?\n-        struct MacroRule {\n-          private:\n-            MacroMatcher matcher;\n-            MacroTranscriber transcriber;\n-\n-            // TODO: should store location information?\n-\n-          public:\n-            MacroRule(MacroMatcher matcher, MacroTranscriber transcriber) :\n-              matcher(::std::move(matcher)), transcriber(::std::move(transcriber)) {}\n-\n-            // Returns whether macro rule is in error state.\n-            inline bool is_error() const {\n-                return matcher.is_error();\n-            }\n-\n-            // Creates an error state macro rule.\n-            static MacroRule create_error() {\n-                return MacroRule(\n-                  MacroMatcher::create_error(), MacroTranscriber(DelimTokenTree::create_empty()));\n-            }\n-\n-            ::std::string as_string() const;\n-        };\n-\n-        // A macro rules definition item AST node\n-        class MacroRulesDefinition : public MacroItem {\n-            Identifier rule_name;\n-            // MacroRulesDef rules_def; // TODO: inline\n-            // only curly without required semicolon at end\n-            DelimType delim_type;\n-            // MacroRules rules;\n-            ::std::vector<MacroRule> rules; // inlined form\n-\n-            Location locus;\n-\n-          public:\n-            ::std::string as_string() const;\n-\n-            MacroRulesDefinition(Identifier rule_name, DelimType delim_type,\n-              ::std::vector<MacroRule> rules, ::std::vector<Attribute> outer_attrs, Location locus) :\n-              MacroItem(::std::move(outer_attrs)),\n-              rule_name(::std::move(rule_name)), delim_type(delim_type), rules(::std::move(rules)),\n-              locus(locus) {}\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual MacroRulesDefinition* clone_item_impl() const OVERRIDE {\n-                return new MacroRulesDefinition(*this);\n-            }\n-        };\n-\n-        // AST node of a macro invocation, which is replaced by the macro result at compile time\n-        class MacroInvocation\n-          : public TypeNoBounds\n-          , public Pattern\n-          , public ExprWithoutBlock {\n-            SimplePath path;\n-            DelimTokenTree token_tree;\n-\n-            Location locus;\n-\n-          public:\n-            ::std::string as_string() const;\n-\n-            MacroInvocation(SimplePath path, DelimTokenTree token_tree,\n-              ::std::vector<Attribute> outer_attrs, Location locus) :\n-              ExprWithoutBlock(::std::move(outer_attrs)),\n-              path(::std::move(path)), token_tree(::std::move(token_tree)), locus(locus) {}\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-            Location get_locus_slow() const OVERRIDE {\n-                return get_locus();\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual MacroInvocation* clone_pattern_impl() const OVERRIDE {\n-                return new MacroInvocation(*this);\n-            }\n-\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual MacroInvocation* clone_expr_impl() const OVERRIDE {\n-                return new MacroInvocation(*this);\n-            }\n-\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual MacroInvocation* clone_expr_without_block_impl() const OVERRIDE {\n-                return new MacroInvocation(*this);\n-            }\n-\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual MacroInvocation* clone_type_impl() const OVERRIDE {\n-                return new MacroInvocation(*this);\n-            }\n-\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual MacroInvocation* clone_type_no_bounds_impl() const OVERRIDE {\n-                return new MacroInvocation(*this);\n-            }\n-        };\n-\n-        // more generic meta item path-only form\n-        class MetaItemPath : public MetaItem {\n-            SimplePath path;\n-\n-          public:\n-            MetaItemPath(SimplePath path) : path(::std::move(path)) {}\n-\n-            ::std::string as_string() const OVERRIDE {\n-                return path.as_string();\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-            // HACK: used to simplify parsing - returns non-empty only in this case\n-            virtual SimplePath to_path_item() const OVERRIDE {\n-                // this should copy construct - TODO ensure it does\n-                return path;\n-            }\n-\n-            virtual bool check_cfg_predicate(const Session& session) const OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this type\n-            virtual MetaItemPath* clone_meta_item_inner_impl() const OVERRIDE {\n-                return new MetaItemPath(*this);\n-            }\n-        };\n-\n-        // more generic meta item sequence form\n-        class MetaItemSeq : public MetaItem {\n-            SimplePath path;\n-            ::std::vector< ::std::unique_ptr<MetaItemInner> > seq;\n-\n-          public:\n-            MetaItemSeq(SimplePath path, ::std::vector< ::std::unique_ptr<MetaItemInner> > seq) :\n-              path(::std::move(path)), seq(::std::move(seq)) {}\n-\n-            // copy constructor with vector clone\n-            MetaItemSeq(const MetaItemSeq& other) : path(other.path) {\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                seq.reserve(other.seq.size());\n-\n-                for (const auto& e : other.seq) {\n-                    seq.push_back(e->clone_meta_item_inner());\n-                }\n-            }\n-\n-            // destructor definition not required\n-\n-            // overloaded assignment operator with vector clone\n-            MetaItemSeq& operator=(const MetaItemSeq& other) {\n-                MetaItem::operator=(other);\n-                path = other.path;\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                seq.reserve(other.seq.size());\n-\n-                for (const auto& e : other.seq) {\n-                    seq.push_back(e->clone_meta_item_inner());\n-                }\n-\n-                return *this;\n-            }\n-\n-            // default move constructors\n-            MetaItemSeq(MetaItemSeq&& other) = default;\n-            MetaItemSeq& operator=(MetaItemSeq&& other) = default;\n-\n-            ::std::string as_string() const OVERRIDE;\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-            virtual bool check_cfg_predicate(const Session& session) const OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this type\n-            virtual MetaItemSeq* clone_meta_item_inner_impl() const OVERRIDE {\n-                return new MetaItemSeq(*this);\n-            }\n-        };\n-\n-        // Preferred specialisation for single-identifier meta items.\n-        class MetaWord : public MetaItem {\n-            Identifier ident;\n-\n-          public:\n-            MetaWord(Identifier ident) : ident(::std::move(ident)) {}\n-\n-            ::std::string as_string() const OVERRIDE {\n-                return ident;\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-            virtual bool check_cfg_predicate(const Session& session) const OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this type\n-            virtual MetaWord* clone_meta_item_inner_impl() const OVERRIDE {\n-                return new MetaWord(*this);\n-            }\n-        };\n-\n-        // Preferred specialisation for \"identifier '=' string literal\" meta items.\n-        class MetaNameValueStr : public MetaItem {\n-            Identifier ident;\n-            ::std::string str;\n-\n-          public:\n-            MetaNameValueStr(Identifier ident, ::std::string str) :\n-              ident(::std::move(ident)), str(::std::move(str)) {}\n-\n-            ::std::string as_string() const OVERRIDE {\n-                return ident + \" = \" + str;\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-            // HACK: used to simplify parsing - creates a copy of this\n-            virtual MetaNameValueStr* to_meta_name_value_str() const OVERRIDE {\n-                return clone_meta_item_inner_impl();\n-            }\n-\n-            virtual bool check_cfg_predicate(const Session& session) const OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this type\n-            virtual MetaNameValueStr* clone_meta_item_inner_impl() const OVERRIDE {\n-                return new MetaNameValueStr(*this);\n-            }\n-        };\n-\n-        // doubles up as MetaListIdents - determine via iterating through each path?\n-        // Preferred specialisation for \"identifier '(' SimplePath, SimplePath, ... ')'\"\n-        class MetaListPaths : public MetaItem {\n-            Identifier ident;\n-            ::std::vector<SimplePath> paths;\n-\n-          public:\n-            MetaListPaths(Identifier ident, ::std::vector<SimplePath> paths) :\n-              ident(::std::move(ident)), paths(::std::move(paths)) {}\n-\n-            ::std::string as_string() const OVERRIDE;\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-            virtual bool check_cfg_predicate(const Session& session) const OVERRIDE;\n-\n-          private:\n-            bool check_path_exists_in_cfg(const Session& session, const SimplePath& path) const;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this type\n-            virtual MetaListPaths* clone_meta_item_inner_impl() const OVERRIDE {\n-                return new MetaListPaths(*this);\n-            }\n-        };\n-\n-        // Preferred specialisation for \"identifier '(' MetaNameValueStr, ... ')'\"\n-        class MetaListNameValueStr : public MetaItem {\n-            Identifier ident;\n-            ::std::vector<MetaNameValueStr> strs;\n-\n-          public:\n-            MetaListNameValueStr(Identifier ident, ::std::vector<MetaNameValueStr> strs) :\n-              ident(::std::move(ident)), strs(::std::move(strs)) {}\n-\n-            ::std::string as_string() const OVERRIDE;\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-            virtual bool check_cfg_predicate(const Session& session) const OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this type\n-            virtual MetaListNameValueStr* clone_meta_item_inner_impl() const OVERRIDE {\n-                return new MetaListNameValueStr(*this);\n-            }\n-        };\n-\n-        // Object that parses macros from a token stream.\n-        struct MacroParser {\n-          private:\n-            ::std::vector< ::std::unique_ptr<Token> > token_stream;\n-            // probably have to make this mutable (mutable int stream_pos) otherwise const has to be\n-            // removed up to DelimTokenTree or further ok since this changing would have an effect on\n-            // the results of the methods run (i.e. not logically const), the parsing methods\n-            // shouldn't be const\n-            int stream_pos;\n-\n-          public:\n-            MacroParser(\n-              ::std::vector< ::std::unique_ptr<Token> > token_stream, int stream_start_pos = 0) :\n-              token_stream(::std::move(token_stream)),\n-              stream_pos(stream_start_pos) {}\n-\n-            ~MacroParser() = default;\n-\n-            ::std::vector< ::std::unique_ptr<MetaItemInner> > parse_meta_item_seq();\n-\n-          private:\n-            // Parses a MetaItemInner.\n-            ::std::unique_ptr<MetaItemInner> parse_meta_item_inner();\n-            // Returns whether token can end a meta item.\n-            bool is_end_meta_item_tok(TokenId id) const;\n-            // Parses a simple path.\n-            SimplePath parse_simple_path();\n-            // Parses a segment of a simple path (but not scope resolution operator).\n-            SimplePathSegment parse_simple_path_segment();\n-            // Parses a MetaItemLitExpr.\n-            ::std::unique_ptr<MetaItemLitExpr> parse_meta_item_lit();\n-            // Parses a literal.\n-            Literal parse_literal();\n-            // Parses a meta item that begins with a simple path.\n-            ::std::unique_ptr<MetaItem> parse_path_meta_item();\n-\n-            // TODO: should this be const?\n-            ::std::unique_ptr<Token>& peek_token(int i = 0) {\n-                return token_stream[stream_pos + i];\n-            }\n-\n-            void skip_token(int i = 0) {\n-                stream_pos += 1 + i;\n-            }\n-        };\n+namespace AST {\n+// Decls as definitions moved to rust-ast.h\n+class MacroItem;\n+class MacroInvocationSemi;\n+\n+enum MacroFragSpec\n+{\n+  BLOCK,\n+  EXPR,\n+  IDENT,\n+  ITEM,\n+  LIFETIME,\n+  LITERAL,\n+  META,\n+  PAT,\n+  PATH,\n+  STMT,\n+  TT,\n+  TY,\n+  VIS,\n+  INVALID // not really a specifier, but used to mark invalid one passed in\n+};\n+\n+inline MacroFragSpec\n+get_frag_spec_from_str (::std::string str)\n+{\n+  if (str == \"block\")\n+    return BLOCK;\n+  else if (str == \"expr\")\n+    return EXPR;\n+  else if (str == \"ident\")\n+    return IDENT;\n+  else if (str == \"item\")\n+    return ITEM;\n+  else if (str == \"lifetime\")\n+    return LIFETIME;\n+  else if (str == \"literal\")\n+    return LITERAL;\n+  else if (str == \"meta\")\n+    return META;\n+  else if (str == \"pat\")\n+    return PAT;\n+  else if (str == \"path\")\n+    return PATH;\n+  else if (str == \"stmt\")\n+    return STMT;\n+  else if (str == \"tt\")\n+    return TT;\n+  else if (str == \"ty\")\n+    return TY;\n+  else if (str == \"vis\")\n+    return VIS;\n+  else\n+    {\n+      // error_at(\"invalid string '%s' used as fragment specifier\",\n+      // str->c_str());\n+      return INVALID;\n     }\n }\n \n+// A macro match that has an identifier and fragment spec\n+class MacroMatchFragment : public MacroMatch\n+{\n+  Identifier ident;\n+  MacroFragSpec frag_spec;\n+\n+  // TODO: should store location information?\n+\n+public:\n+  MacroMatchFragment (Identifier ident, MacroFragSpec frag_spec)\n+    : ident (::std::move (ident)), frag_spec (frag_spec)\n+  {}\n+\n+  // Returns whether macro match fragment is in an error state.\n+  inline bool is_error () const { return frag_spec == INVALID; }\n+\n+  // Creates an error state macro match fragment.\n+  static MacroMatchFragment create_error ()\n+  {\n+    return MacroMatchFragment (::std::string (\"\"), INVALID);\n+  }\n+\n+  ::std::string as_string () const;\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual MacroMatchFragment *clone_macro_match_impl () const OVERRIDE\n+  {\n+    return new MacroMatchFragment (*this);\n+  }\n+};\n+\n+// A repetition macro match\n+class MacroMatchRepetition : public MacroMatch\n+{\n+public:\n+  enum MacroRepOp\n+  {\n+    NONE,\n+    ASTERISK,\n+    PLUS,\n+    QUESTION_MARK\n+  };\n+\n+private:\n+  //::std::vector<MacroMatch> matches;\n+  ::std::vector< ::std::unique_ptr<MacroMatch> > matches;\n+  MacroRepOp op;\n+\n+  // bool has_sep;\n+  typedef Token MacroRepSep;\n+  // any token except delimiters and repetition operators\n+  ::std::unique_ptr<MacroRepSep> sep;\n+\n+  // TODO: should store location information?\n+\n+public:\n+  // Returns whether macro match repetition has separator token.\n+  inline bool has_sep () const { return sep != NULL; }\n+\n+  MacroMatchRepetition (::std::vector< ::std::unique_ptr<MacroMatch> > matches,\n+\t\t\tMacroRepOp op, ::std::unique_ptr<MacroRepSep> sep)\n+    : matches (::std::move (matches)), op (op), sep (::std::move (sep))\n+  {}\n+\n+  // Copy constructor with clone\n+  MacroMatchRepetition (MacroMatchRepetition const &other)\n+    : /*matches(other.matches),*/ op (other.op), sep (other.sep->clone_token ())\n+  {\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    matches.reserve (other.matches.size ());\n+\n+    for (const auto &e : other.matches)\n+      {\n+\tmatches.push_back (e->clone_macro_match ());\n+      }\n+  }\n+\n+  // Destructor - define here if required\n+\n+  // Overloaded assignment operator to clone\n+  MacroMatchRepetition &operator= (MacroMatchRepetition const &other)\n+  {\n+    // matches = other.matches; // TODO: this needs to clone somehow?\n+    op = other.op;\n+    sep = other.sep->clone_token ();\n+\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    matches.reserve (other.matches.size ());\n+\n+    for (const auto &e : other.matches)\n+      {\n+\tmatches.push_back (e->clone_macro_match ());\n+      }\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  MacroMatchRepetition (MacroMatchRepetition &&other) = default;\n+  MacroMatchRepetition &operator= (MacroMatchRepetition &&other) = default;\n+\n+  ::std::string as_string () const;\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual MacroMatchRepetition *clone_macro_match_impl () const OVERRIDE\n+  {\n+    return new MacroMatchRepetition (*this);\n+  }\n+};\n+\n+// can't inline due to polymorphism\n+class MacroMatcher : public MacroMatch\n+{\n+  DelimType delim_type;\n+  //::std::vector<MacroMatch> matches;\n+  ::std::vector< ::std::unique_ptr<MacroMatch> > matches;\n+\n+  // TODO: think of way to mark invalid that doesn't take up more space\n+  bool is_invalid;\n+\n+  // TODO: should store location information?\n+\n+public:\n+  MacroMatcher (DelimType delim_type,\n+\t\t::std::vector< ::std::unique_ptr<MacroMatch> > matches)\n+    : delim_type (delim_type), matches (::std::move (matches)),\n+      is_invalid (false)\n+  {}\n+\n+  // copy constructor with vector clone\n+  MacroMatcher (MacroMatcher const &other) : delim_type (other.delim_type)\n+  {\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    matches.reserve (other.matches.size ());\n+\n+    for (const auto &e : other.matches)\n+      {\n+\tmatches.push_back (e->clone_macro_match ());\n+      }\n+  }\n+\n+  // overloaded assignment operator with vector clone\n+  MacroMatcher &operator= (MacroMatcher const &other)\n+  {\n+    delim_type = other.delim_type;\n+\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    matches.reserve (other.matches.size ());\n+\n+    for (const auto &e : other.matches)\n+      {\n+\tmatches.push_back (e->clone_macro_match ());\n+      }\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  MacroMatcher (MacroMatcher &&other) = default;\n+  MacroMatcher &operator= (MacroMatcher &&other) = default;\n+\n+  // Creates an error state macro matcher.\n+  static MacroMatcher create_error () { return MacroMatcher (true); }\n+\n+  // Returns whether MacroMatcher is in an error state.\n+  inline bool is_error () const { return is_invalid; }\n+\n+  ::std::string as_string () const;\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual MacroMatcher *clone_macro_match_impl () const OVERRIDE\n+  {\n+    return new MacroMatcher (*this);\n+  }\n+\n+  // constructor only used to create error matcher\n+  MacroMatcher (bool is_invalid) : delim_type (PARENS), is_invalid (is_invalid)\n+  {}\n+};\n+\n+// TODO: inline?\n+struct MacroTranscriber\n+{\n+private:\n+  DelimTokenTree token_tree;\n+\n+  // TODO: should store location information?\n+\n+public:\n+  MacroTranscriber (DelimTokenTree token_tree)\n+    : token_tree (::std::move (token_tree))\n+  {}\n+\n+  ::std::string as_string () const { return token_tree.as_string (); }\n+};\n+\n+// A macro rule? Matcher and transcriber pair?\n+struct MacroRule\n+{\n+private:\n+  MacroMatcher matcher;\n+  MacroTranscriber transcriber;\n+\n+  // TODO: should store location information?\n+\n+public:\n+  MacroRule (MacroMatcher matcher, MacroTranscriber transcriber)\n+    : matcher (::std::move (matcher)), transcriber (::std::move (transcriber))\n+  {}\n+\n+  // Returns whether macro rule is in error state.\n+  inline bool is_error () const { return matcher.is_error (); }\n+\n+  // Creates an error state macro rule.\n+  static MacroRule create_error ()\n+  {\n+    return MacroRule (MacroMatcher::create_error (),\n+\t\t      MacroTranscriber (DelimTokenTree::create_empty ()));\n+  }\n+\n+  ::std::string as_string () const;\n+};\n+\n+// A macro rules definition item AST node\n+class MacroRulesDefinition : public MacroItem\n+{\n+  Identifier rule_name;\n+  // MacroRulesDef rules_def; // TODO: inline\n+  // only curly without required semicolon at end\n+  DelimType delim_type;\n+  // MacroRules rules;\n+  ::std::vector<MacroRule> rules; // inlined form\n+\n+  Location locus;\n+\n+public:\n+  ::std::string as_string () const;\n+\n+  MacroRulesDefinition (Identifier rule_name, DelimType delim_type,\n+\t\t\t::std::vector<MacroRule> rules,\n+\t\t\t::std::vector<Attribute> outer_attrs, Location locus)\n+    : MacroItem (::std::move (outer_attrs)),\n+      rule_name (::std::move (rule_name)), delim_type (delim_type),\n+      rules (::std::move (rules)), locus (locus)\n+  {}\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual MacroRulesDefinition *clone_item_impl () const OVERRIDE\n+  {\n+    return new MacroRulesDefinition (*this);\n+  }\n+};\n+\n+// AST node of a macro invocation, which is replaced by the macro result at\n+// compile time\n+class MacroInvocation : public TypeNoBounds,\n+\t\t\tpublic Pattern,\n+\t\t\tpublic ExprWithoutBlock\n+{\n+  SimplePath path;\n+  DelimTokenTree token_tree;\n+\n+  Location locus;\n+\n+public:\n+  ::std::string as_string () const;\n+\n+  MacroInvocation (SimplePath path, DelimTokenTree token_tree,\n+\t\t   ::std::vector<Attribute> outer_attrs, Location locus)\n+    : ExprWithoutBlock (::std::move (outer_attrs)), path (::std::move (path)),\n+      token_tree (::std::move (token_tree)), locus (locus)\n+  {}\n+\n+  Location get_locus () const { return locus; }\n+\n+  Location get_locus_slow () const OVERRIDE { return get_locus (); }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual MacroInvocation *clone_pattern_impl () const OVERRIDE\n+  {\n+    return new MacroInvocation (*this);\n+  }\n+\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual MacroInvocation *clone_expr_impl () const OVERRIDE\n+  {\n+    return new MacroInvocation (*this);\n+  }\n+\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual MacroInvocation *clone_expr_without_block_impl () const OVERRIDE\n+  {\n+    return new MacroInvocation (*this);\n+  }\n+\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual MacroInvocation *clone_type_impl () const OVERRIDE\n+  {\n+    return new MacroInvocation (*this);\n+  }\n+\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual MacroInvocation *clone_type_no_bounds_impl () const OVERRIDE\n+  {\n+    return new MacroInvocation (*this);\n+  }\n+};\n+\n+// more generic meta item path-only form\n+class MetaItemPath : public MetaItem\n+{\n+  SimplePath path;\n+\n+public:\n+  MetaItemPath (SimplePath path) : path (::std::move (path)) {}\n+\n+  ::std::string as_string () const OVERRIDE { return path.as_string (); }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+  // HACK: used to simplify parsing - returns non-empty only in this case\n+  virtual SimplePath to_path_item () const OVERRIDE\n+  {\n+    // this should copy construct - TODO ensure it does\n+    return path;\n+  }\n+\n+  virtual bool check_cfg_predicate (const Session &session) const OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this type\n+  virtual MetaItemPath *clone_meta_item_inner_impl () const OVERRIDE\n+  {\n+    return new MetaItemPath (*this);\n+  }\n+};\n+\n+// more generic meta item sequence form\n+class MetaItemSeq : public MetaItem\n+{\n+  SimplePath path;\n+  ::std::vector< ::std::unique_ptr<MetaItemInner> > seq;\n+\n+public:\n+  MetaItemSeq (SimplePath path,\n+\t       ::std::vector< ::std::unique_ptr<MetaItemInner> > seq)\n+    : path (::std::move (path)), seq (::std::move (seq))\n+  {}\n+\n+  // copy constructor with vector clone\n+  MetaItemSeq (const MetaItemSeq &other) : path (other.path)\n+  {\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    seq.reserve (other.seq.size ());\n+\n+    for (const auto &e : other.seq)\n+      {\n+\tseq.push_back (e->clone_meta_item_inner ());\n+      }\n+  }\n+\n+  // destructor definition not required\n+\n+  // overloaded assignment operator with vector clone\n+  MetaItemSeq &operator= (const MetaItemSeq &other)\n+  {\n+    MetaItem::operator= (other);\n+    path = other.path;\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    seq.reserve (other.seq.size ());\n+\n+    for (const auto &e : other.seq)\n+      {\n+\tseq.push_back (e->clone_meta_item_inner ());\n+      }\n+\n+    return *this;\n+  }\n+\n+  // default move constructors\n+  MetaItemSeq (MetaItemSeq &&other) = default;\n+  MetaItemSeq &operator= (MetaItemSeq &&other) = default;\n+\n+  ::std::string as_string () const OVERRIDE;\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+  virtual bool check_cfg_predicate (const Session &session) const OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this type\n+  virtual MetaItemSeq *clone_meta_item_inner_impl () const OVERRIDE\n+  {\n+    return new MetaItemSeq (*this);\n+  }\n+};\n+\n+// Preferred specialisation for single-identifier meta items.\n+class MetaWord : public MetaItem\n+{\n+  Identifier ident;\n+\n+public:\n+  MetaWord (Identifier ident) : ident (::std::move (ident)) {}\n+\n+  ::std::string as_string () const OVERRIDE { return ident; }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+  virtual bool check_cfg_predicate (const Session &session) const OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this type\n+  virtual MetaWord *clone_meta_item_inner_impl () const OVERRIDE\n+  {\n+    return new MetaWord (*this);\n+  }\n+};\n+\n+// Preferred specialisation for \"identifier '=' string literal\" meta items.\n+class MetaNameValueStr : public MetaItem\n+{\n+  Identifier ident;\n+  ::std::string str;\n+\n+public:\n+  MetaNameValueStr (Identifier ident, ::std::string str)\n+    : ident (::std::move (ident)), str (::std::move (str))\n+  {}\n+\n+  ::std::string as_string () const OVERRIDE { return ident + \" = \" + str; }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+  // HACK: used to simplify parsing - creates a copy of this\n+  virtual MetaNameValueStr *to_meta_name_value_str () const OVERRIDE\n+  {\n+    return clone_meta_item_inner_impl ();\n+  }\n+\n+  virtual bool check_cfg_predicate (const Session &session) const OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this type\n+  virtual MetaNameValueStr *clone_meta_item_inner_impl () const OVERRIDE\n+  {\n+    return new MetaNameValueStr (*this);\n+  }\n+};\n+\n+// doubles up as MetaListIdents - determine via iterating through each path?\n+// Preferred specialisation for \"identifier '(' SimplePath, SimplePath, ... ')'\"\n+class MetaListPaths : public MetaItem\n+{\n+  Identifier ident;\n+  ::std::vector<SimplePath> paths;\n+\n+public:\n+  MetaListPaths (Identifier ident, ::std::vector<SimplePath> paths)\n+    : ident (::std::move (ident)), paths (::std::move (paths))\n+  {}\n+\n+  ::std::string as_string () const OVERRIDE;\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+  virtual bool check_cfg_predicate (const Session &session) const OVERRIDE;\n+\n+private:\n+  bool check_path_exists_in_cfg (const Session &session,\n+\t\t\t\t const SimplePath &path) const;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this type\n+  virtual MetaListPaths *clone_meta_item_inner_impl () const OVERRIDE\n+  {\n+    return new MetaListPaths (*this);\n+  }\n+};\n+\n+// Preferred specialisation for \"identifier '(' MetaNameValueStr, ... ')'\"\n+class MetaListNameValueStr : public MetaItem\n+{\n+  Identifier ident;\n+  ::std::vector<MetaNameValueStr> strs;\n+\n+public:\n+  MetaListNameValueStr (Identifier ident, ::std::vector<MetaNameValueStr> strs)\n+    : ident (::std::move (ident)), strs (::std::move (strs))\n+  {}\n+\n+  ::std::string as_string () const OVERRIDE;\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+  virtual bool check_cfg_predicate (const Session &session) const OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this type\n+  virtual MetaListNameValueStr *clone_meta_item_inner_impl () const OVERRIDE\n+  {\n+    return new MetaListNameValueStr (*this);\n+  }\n+};\n+\n+// Object that parses macros from a token stream.\n+struct MacroParser\n+{\n+private:\n+  ::std::vector< ::std::unique_ptr<Token> > token_stream;\n+  // probably have to make this mutable (mutable int stream_pos) otherwise const\n+  // has to be removed up to DelimTokenTree or further ok since this changing\n+  // would have an effect on the results of the methods run (i.e. not logically\n+  // const), the parsing methods shouldn't be const\n+  int stream_pos;\n+\n+public:\n+  MacroParser (::std::vector< ::std::unique_ptr<Token> > token_stream,\n+\t       int stream_start_pos = 0)\n+    : token_stream (::std::move (token_stream)), stream_pos (stream_start_pos)\n+  {}\n+\n+  ~MacroParser () = default;\n+\n+  ::std::vector< ::std::unique_ptr<MetaItemInner> > parse_meta_item_seq ();\n+\n+private:\n+  // Parses a MetaItemInner.\n+  ::std::unique_ptr<MetaItemInner> parse_meta_item_inner ();\n+  // Returns whether token can end a meta item.\n+  bool is_end_meta_item_tok (TokenId id) const;\n+  // Parses a simple path.\n+  SimplePath parse_simple_path ();\n+  // Parses a segment of a simple path (but not scope resolution operator).\n+  SimplePathSegment parse_simple_path_segment ();\n+  // Parses a MetaItemLitExpr.\n+  ::std::unique_ptr<MetaItemLitExpr> parse_meta_item_lit ();\n+  // Parses a literal.\n+  Literal parse_literal ();\n+  // Parses a meta item that begins with a simple path.\n+  ::std::unique_ptr<MetaItem> parse_path_meta_item ();\n+\n+  // TODO: should this be const?\n+  ::std::unique_ptr<Token> &peek_token (int i = 0)\n+  {\n+    return token_stream[stream_pos + i];\n+  }\n+\n+  void skip_token (int i = 0) { stream_pos += 1 + i; }\n+};\n+} // namespace AST\n+} // namespace Rust\n+\n #endif"}, {"sha": "434ed62ad6502282e7bc4f98838717091ea2cf87", "filename": "gcc/rust/ast/rust-path.h", "status": "modified", "additions": 869, "deletions": 792, "changes": 1661, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -1,803 +1,880 @@\n #ifndef RUST_AST_PATH_H\n #define RUST_AST_PATH_H\n-/* \"Path\" (identifier within namespaces, essentially) handling. Required include for virtually all\n- * AST-related functionality. */\n+/* \"Path\" (identifier within namespaces, essentially) handling. Required include\n+ * for virtually all AST-related functionality. */\n \n #include \"rust-ast.h\"\n \n #include <string>\n #include <vector>\n \n namespace Rust {\n-    namespace AST {\n-        // make intellisense calm\n-        /*typedef ::std::string Symbol;\n-        typedef int Lifetime;\n-        typedef int Type;\n-        typedef int Binding;*/\n-\n-        // The \"identifier\" (not generic args) aspect of each path expression segment\n-        class PathIdentSegment {\n-            ::std::string segment_name;\n-\n-            // TODO: should this have location info stored?\n-\n-            // only allow identifiers, \"super\", \"self\", \"Self\", \"crate\", or \"$crate\"\n-          public:\n-            PathIdentSegment(::std::string segment_name) : segment_name(::std::move(segment_name)) {}\n-\n-            /* TODO: insert check in constructor for this? Or is this a semantic error best handled\n-             * then? */\n-\n-            // TODO: does this require visitor. pretty sure this isn't polymorphic, but not entirely\n-            // sure\n-\n-            // Creates an error PathIdentSegment.\n-            static PathIdentSegment create_error() {\n-                return PathIdentSegment(\"\");\n-            }\n-\n-            // Returns whether PathIdentSegment is in an error state.\n-            inline bool is_error() const {\n-                return segment_name.empty();\n-            }\n-\n-            ::std::string as_string() const {\n-                return segment_name;\n-            }\n-        };\n-\n-        // A binding of an identifier to a type used in generic arguments in paths\n-        struct GenericArgsBinding {\n-          private:\n-            Identifier identifier;\n-            // Type type;\n-            ::std::unique_ptr<Type> type;\n-\n-            Location locus;\n-\n-          public:\n-            // Returns whether binding is in an error state.\n-            inline bool is_error() const {\n-                return type == NULL; // and also identifier is empty, but cheaper computation\n-            }\n-\n-            // Creates an error state generic args binding.\n-            static GenericArgsBinding create_error() {\n-                return GenericArgsBinding(\"\", NULL);\n-            }\n-\n-            // Pointer type for type in constructor to enable polymorphism\n-            GenericArgsBinding(\n-              Identifier ident, ::std::unique_ptr<Type> type_ptr, Location locus = Location()) :\n-              identifier(::std::move(ident)),\n-              type(::std::move(type_ptr)), locus(locus) {}\n-\n-            // Copy constructor has to deep copy the type as it is a unique pointer\n-            GenericArgsBinding(GenericArgsBinding const& other) :\n-              identifier(other.identifier), type(other.type->clone_type()), locus(other.locus) {}\n-\n-            // default destructor\n-            ~GenericArgsBinding() = default;\n-\n-            // Overload assignment operator to deep copy the pointed-to type\n-            GenericArgsBinding& operator=(GenericArgsBinding const& other) {\n-                identifier = other.identifier;\n-                type = other.type->clone_type();\n-                locus = other.locus;\n-                return *this;\n-            }\n-\n-            // move constructors\n-            GenericArgsBinding(GenericArgsBinding&& other) = default;\n-            GenericArgsBinding& operator=(GenericArgsBinding&& other) = default;\n-\n-            ::std::string as_string() const;\n-        };\n-\n-        // Generic arguments allowed in each path expression segment - inline?\n-        struct GenericArgs {\n-            ::std::vector<Lifetime> lifetime_args;\n-            //::std::vector<Type> type_args;\n-            ::std::vector< ::std::unique_ptr<Type> > type_args;\n-            ::std::vector<GenericArgsBinding> binding_args;\n-\n-            Location locus;\n-\n-          public:\n-            // Returns true if there are any generic arguments\n-            inline bool has_generic_args() const {\n-                return !(lifetime_args.empty() && type_args.empty() && binding_args.empty());\n-            }\n-\n-            GenericArgs(::std::vector<Lifetime> lifetime_args,\n-              ::std::vector< ::std::unique_ptr<Type> > type_args,\n-              ::std::vector<GenericArgsBinding> binding_args, Location locus = Location()) :\n-              lifetime_args(::std::move(lifetime_args)),\n-              type_args(::std::move(type_args)), binding_args(::std::move(binding_args)),\n-              locus(locus) {}\n-\n-            // copy constructor with vector clone\n-            GenericArgs(GenericArgs const& other) :\n-              lifetime_args(other.lifetime_args), binding_args(other.binding_args),\n-              locus(other.locus) {\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                type_args.reserve(other.type_args.size());\n-\n-                for (const auto& e : other.type_args) {\n-                    type_args.push_back(e->clone_type());\n-                }\n-            }\n-\n-            ~GenericArgs() = default;\n-\n-            // overloaded assignment operator to vector clone\n-            GenericArgs& operator=(GenericArgs const& other) {\n-                lifetime_args = other.lifetime_args;\n-                binding_args = other.binding_args;\n-                locus = other.locus;\n-\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                type_args.reserve(other.type_args.size());\n-\n-                for (const auto& e : other.type_args) {\n-                    type_args.push_back(e->clone_type());\n-                }\n-\n-                return *this;\n-            }\n-\n-            // move constructors\n-            GenericArgs(GenericArgs&& other) = default;\n-            GenericArgs& operator=(GenericArgs&& other) = default;\n-\n-            // Creates an empty GenericArgs (no arguments)\n-            static GenericArgs create_empty() {\n-                return GenericArgs(::std::vector<Lifetime>(),\n-                  ::std::vector< ::std::unique_ptr<Type> >(), ::std::vector<GenericArgsBinding>());\n-            }\n-\n-            ::std::string as_string() const;\n-        };\n-\n-        // A segment of a path in expression, including an identifier aspect and maybe generic args\n-        class PathExprSegment { // or should this extend PathIdentSegment?\n-          private:\n-            PathIdentSegment segment_name;\n-\n-            // bool has_generic_args;\n-            GenericArgs generic_args;\n-\n-            Location locus;\n-\n-            // TODO: does this require visitor? pretty sure not polymorphic\n-\n-          public:\n-            // Returns true if there are any generic arguments\n-            inline bool has_generic_args() const {\n-                return generic_args.has_generic_args();\n-            }\n-\n-            // Constructor for segment (from IdentSegment and GenericArgs)\n-            PathExprSegment(PathIdentSegment segment_name, Location locus = Location(),\n-              GenericArgs generic_args = GenericArgs::create_empty()) :\n-              segment_name(::std::move(segment_name)),\n-              generic_args(::std::move(generic_args)), locus(locus) {}\n-\n-            // Constructor for segment with generic arguments (from segment name and all args)\n-            PathExprSegment(::std::string segment_name, Location locus,\n-              ::std::vector<Lifetime> lifetime_args = ::std::vector<Lifetime>(),\n-              ::std::vector< ::std::unique_ptr<Type> > type_args\n-              = ::std::vector< ::std::unique_ptr<Type> >(),\n-              ::std::vector<GenericArgsBinding> binding_args = ::std::vector<GenericArgsBinding>()) :\n-              segment_name(PathIdentSegment(::std::move(segment_name))),\n-              generic_args(GenericArgs(\n-                ::std::move(lifetime_args), ::std::move(type_args), ::std::move(binding_args))),\n-              locus(locus) {}\n-\n-            // Returns whether path expression segment is in an error state.\n-            inline bool is_error() const {\n-                return segment_name.is_error();\n-            }\n-\n-            // Creates an error-state path expression segment.\n-            static PathExprSegment create_error() {\n-                return PathExprSegment(PathIdentSegment::create_error());\n-            }\n-\n-            ::std::string as_string() const;\n-\n-            inline Location get_locus() const {\n-                return locus;\n-            }\n-        };\n-\n-        // AST node representing a pattern that involves a \"path\" - abstract base class\n-        class PathPattern : public Pattern {\n-            ::std::vector<PathExprSegment> segments;\n-\n-          protected:\n-            PathPattern(::std::vector<PathExprSegment> segments) : segments(::std::move(segments)) {}\n-\n-            // Returns whether path has segments.\n-            inline bool has_segments() const {\n-                return !segments.empty();\n-            }\n-\n-            /* Converts path segments to their equivalent SimplePath segments if possible, and creates\n-             * a SimplePath from them. */\n-            SimplePath convert_to_simple_path(bool with_opening_scope_resolution) const;\n-\n-          public:\n-            /* Returns whether the path is a single segment (excluding qualified path initial as\n-             * segment). */\n-            inline bool is_single_segment() const {\n-                return segments.size() == 1;\n-            }\n-\n-            virtual ::std::string as_string() const;\n-        };\n-\n-        // AST node representing a path-in-expression pattern (path that allows generic arguments)\n-        class PathInExpression\n-          : public PathPattern\n-          , public PathExpr {\n-            bool has_opening_scope_resolution;\n-\n-            Location locus;\n-\n-          public:\n-            ::std::string as_string() const;\n-\n-            // Constructor\n-            PathInExpression(::std::vector<PathExprSegment> path_segments,\n-              Location locus = Location(), bool has_opening_scope_resolution = false,\n-              ::std::vector<Attribute> outer_attrs = ::std::vector<Attribute>()) :\n-              PathPattern(::std::move(path_segments)),\n-              PathExpr(::std::move(outer_attrs)),\n-              has_opening_scope_resolution(has_opening_scope_resolution), locus(locus) {}\n-\n-            // Creates an error state path in expression.\n-            static PathInExpression create_error() {\n-                return PathInExpression(::std::vector<PathExprSegment>());\n-            }\n-\n-            // Returns whether path in expression is in an error state.\n-            inline bool is_error() const {\n-                return !has_segments();\n-            }\n-\n-            /* Converts PathInExpression to SimplePath if possible (i.e. no generic arguments).\n-             * Otherwise returns an empty SimplePath. */\n-            inline SimplePath as_simple_path() const {\n-                /* delegate to parent class as can't access segments. however,\n-                 * QualifiedPathInExpression conversion to simple path wouldn't make sense, so the\n-                 * method in the parent class should be protected, not public.\n-                 * Have to pass in opening scope resolution as parent class has no access to it. */\n-                return convert_to_simple_path(has_opening_scope_resolution);\n-            }\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-            Location get_locus_slow() const OVERRIDE {\n-                return get_locus();\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual PathInExpression* clone_pattern_impl() const OVERRIDE {\n-                return new PathInExpression(*this);\n-            }\n-\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual PathInExpression* clone_expr_without_block_impl() const OVERRIDE {\n-                return new PathInExpression(*this);\n-            }\n-        };\n-\n-        // Base class for segments used in type paths - not abstract (represents an ident-only\n-        // segment)\n-        class TypePathSegment {\n-            /* TODO: may have to unify TypePathSegment and PathExprSegment (which are mostly the\n-             * same anyway) in order to resolve goddamn syntax ambiguities.\n-             * One difference is that function on TypePathSegment is not allowed if GenericArgs are,\n-             * so could disallow that in constructor, which won't give that much size overhead. */\n-            PathIdentSegment ident_segment;\n-\n-            Location locus;\n-\n-          protected:\n-            // This is protected because it is only really used by derived classes, not the base.\n-            bool has_separating_scope_resolution;\n-\n-            // Clone function implementation - not pure virtual as overrided by subclasses\n-            virtual TypePathSegment* clone_type_path_segment_impl() const {\n-                return new TypePathSegment(*this);\n-            }\n-\n-          public:\n-            virtual ~TypePathSegment() {}\n-\n-            // Unique pointer custom clone function\n-            ::std::unique_ptr<TypePathSegment> clone_type_path_segment() const {\n-                return ::std::unique_ptr<TypePathSegment>(clone_type_path_segment_impl());\n-            }\n-\n-            TypePathSegment(\n-              PathIdentSegment ident_segment, bool has_separating_scope_resolution, Location locus) :\n-              ident_segment(::std::move(ident_segment)),\n-              locus(locus), has_separating_scope_resolution(has_separating_scope_resolution) {}\n-\n-            TypePathSegment(\n-              ::std::string segment_name, bool has_separating_scope_resolution, Location locus) :\n-              ident_segment(PathIdentSegment(::std::move(segment_name))),\n-              locus(locus), has_separating_scope_resolution(has_separating_scope_resolution) {}\n-\n-            virtual ::std::string as_string() const {\n-                return ident_segment.as_string();\n-            }\n-\n-            // Returns whether the type path segment is in an error state. May be virtual in future.\n-            inline bool is_error() const {\n-                return ident_segment.is_error();\n-            }\n-\n-            /* Returns whether segment is identifier only (as opposed to generic args or function).\n-            Overriden in derived classes with other segments. */\n-            virtual bool is_ident_only() const {\n-                return true;\n-            }\n-\n-            inline Location get_locus() const {\n-                return locus;\n-            }\n-\n-            // not pure virtual as class not abstract\n-            virtual void accept_vis(ASTVisitor& vis);\n-        };\n-\n-        // Segment used in type path with generic args\n-        class TypePathSegmentGeneric : public TypePathSegment {\n-            GenericArgs generic_args;\n-\n-          public:\n-            inline bool has_generic_args() const {\n-                return generic_args.has_generic_args();\n-            }\n-\n-            bool is_ident_only() const {\n-                return false;\n-            }\n-\n-            // Constructor with PathIdentSegment and GenericArgs\n-            TypePathSegmentGeneric(PathIdentSegment ident_segment,\n-              bool has_separating_scope_resolution, GenericArgs generic_args, Location locus) :\n-              TypePathSegment(::std::move(ident_segment), has_separating_scope_resolution, locus),\n-              generic_args(::std::move(generic_args)) {}\n-\n-            // Constructor from segment name and all args\n-            TypePathSegmentGeneric(::std::string segment_name, bool has_separating_scope_resolution,\n-              ::std::vector<Lifetime> lifetime_args,\n-              ::std::vector< ::std::unique_ptr<Type> > type_args,\n-              ::std::vector<GenericArgsBinding> binding_args, Location locus) :\n-              TypePathSegment(::std::move(segment_name), has_separating_scope_resolution, locus),\n-              generic_args(GenericArgs(\n-                ::std::move(lifetime_args), ::std::move(type_args), ::std::move(binding_args))) {}\n-\n-            ::std::string as_string() const;\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to override base class method\n-            virtual TypePathSegmentGeneric* clone_type_path_segment_impl() const OVERRIDE {\n-                return new TypePathSegmentGeneric(*this);\n-            }\n-        };\n-\n-        // A function as represented in a type path\n-        struct TypePathFunction {\n-          private:\n-            // TODO: remove\n-            /*bool has_inputs;\n-            TypePathFnInputs inputs;*/\n-            //::std::vector<Type> inputs; // inlined from TypePathFnInputs\n-            ::std::vector< ::std::unique_ptr<Type> > inputs;\n-\n-            // bool has_type;\n-            // Type type;\n-            ::std::unique_ptr<Type> return_type;\n-\n-            // FIXME: think of better way to mark as invalid than taking up storage\n-            bool is_invalid;\n-\n-            // TODO: should this have location info?\n-\n-          protected:\n-            // Constructor only used to create invalid type path functions.\n-            TypePathFunction(bool is_invalid) : is_invalid(is_invalid) {}\n-\n-          public:\n-            // Returns whether the return type of the function has been specified.\n-            inline bool has_return_type() const {\n-                return return_type != NULL;\n-            }\n-\n-            // Returns whether the function has inputs.\n-            inline bool has_inputs() const {\n-                return !inputs.empty();\n-            }\n-\n-            // Returns whether function is in an error state.\n-            inline bool is_error() const {\n-                return is_invalid;\n-            }\n-\n-            // Creates an error state function.\n-            static TypePathFunction create_error() {\n-                return TypePathFunction(true);\n-            }\n-\n-            // Constructor\n-            TypePathFunction(::std::vector< ::std::unique_ptr<Type> > inputs, Type* type = NULL) :\n-              inputs(::std::move(inputs)), return_type(type), is_invalid(false) {}\n-            // FIXME: deprecated\n-\n-            // Constructor\n-            TypePathFunction(\n-              ::std::vector< ::std::unique_ptr<Type> > inputs, ::std::unique_ptr<Type> type = NULL) :\n-              inputs(::std::move(inputs)),\n-              return_type(::std::move(type)), is_invalid(false) {}\n-\n-            // Copy constructor with clone\n-            TypePathFunction(TypePathFunction const& other) :\n-              /*inputs(other.inputs),*/ return_type(other.return_type->clone_type()),\n-              is_invalid(other.is_invalid) {\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                inputs.reserve(other.inputs.size());\n-\n-                for (const auto& e : other.inputs) {\n-                    inputs.push_back(e->clone_type());\n-                }\n-            }\n-\n-            ~TypePathFunction() = default;\n-\n-            // Overloaded assignment operator to clone type\n-            TypePathFunction& operator=(TypePathFunction const& other) {\n-                // inputs = other.inputs;\n-                return_type = other.return_type->clone_type();\n-                is_invalid = other.is_invalid;\n-\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                inputs.reserve(other.inputs.size());\n-\n-                for (const auto& e : other.inputs) {\n-                    inputs.push_back(e->clone_type());\n-                }\n-\n-                return *this;\n-            }\n-\n-            // move constructors\n-            TypePathFunction(TypePathFunction&& other) = default;\n-            TypePathFunction& operator=(TypePathFunction&& other) = default;\n-\n-            ::std::string as_string() const;\n-        };\n-\n-        // Segment used in type path with a function argument\n-        class TypePathSegmentFunction : public TypePathSegment {\n-            TypePathFunction function_path;\n-\n-          public:\n-            // Constructor with PathIdentSegment and TypePathFn\n-            TypePathSegmentFunction(PathIdentSegment ident_segment,\n-              bool has_separating_scope_resolution, TypePathFunction function_path, Location locus) :\n-              TypePathSegment(::std::move(ident_segment), has_separating_scope_resolution, locus),\n-              function_path(::std::move(function_path)) {}\n-\n-            // Constructor with segment name and TypePathFn\n-            TypePathSegmentFunction(::std::string segment_name, bool has_separating_scope_resolution,\n-              TypePathFunction function_path, Location locus) :\n-              TypePathSegment(::std::move(segment_name), has_separating_scope_resolution, locus),\n-              function_path(::std::move(function_path)) {}\n-\n-            ::std::string as_string() const;\n-\n-            bool is_ident_only() const {\n-                return false;\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to override base class method\n-            virtual TypePathSegmentFunction* clone_type_path_segment_impl() const OVERRIDE {\n-                return new TypePathSegmentFunction(*this);\n-            }\n-        };\n-\n-        // Path used inside types\n-        class TypePath : public TypeNoBounds {\n-            bool has_opening_scope_resolution;\n-            ::std::vector< ::std::unique_ptr<TypePathSegment> > segments;\n-\n-            Location locus;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual TypePath* clone_type_impl() const OVERRIDE {\n-                return new TypePath(*this);\n-            }\n-\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual TypePath* clone_type_no_bounds_impl() const OVERRIDE {\n-                return new TypePath(*this);\n-            }\n-\n-          public:\n-            /* Returns whether the TypePath has an opening scope resolution operator (i.e. is global\n-             * path or crate-relative path, not module-relative) */\n-            inline bool has_opening_scope_resolution_op() const {\n-                return has_opening_scope_resolution;\n-            }\n-\n-            // Returns whether the TypePath is in an invalid state.\n-            inline bool is_error() const {\n-                return segments.empty();\n-            }\n-\n-            // Creates an error state TypePath.\n-            static TypePath create_error() {\n-                return TypePath(::std::vector< ::std::unique_ptr<TypePathSegment> >(), Location());\n-            }\n-\n-            // Constructor\n-            TypePath(::std::vector< ::std::unique_ptr<TypePathSegment> > segments, Location locus,\n-              bool has_opening_scope_resolution = false) :\n-              has_opening_scope_resolution(has_opening_scope_resolution),\n-              segments(::std::move(segments)), locus(locus) {}\n-\n-            // Copy constructor with vector clone\n-            TypePath(TypePath const& other) :\n-              has_opening_scope_resolution(other.has_opening_scope_resolution), locus(other.locus) {\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                segments.reserve(other.segments.size());\n-\n-                for (const auto& e : other.segments) {\n-                    segments.push_back(e->clone_type_path_segment());\n-                }\n-            }\n-\n-            // Overloaded assignment operator with clone\n-            TypePath& operator=(TypePath const& other) {\n-                has_opening_scope_resolution = other.has_opening_scope_resolution;\n-                locus = other.locus;\n-\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                segments.reserve(other.segments.size());\n-\n-                for (const auto& e : other.segments) {\n-                    segments.push_back(e->clone_type_path_segment());\n-                }\n-\n-                return *this;\n-            }\n-\n-            // move constructors\n-            TypePath(TypePath&& other) = default;\n-            TypePath& operator=(TypePath&& other) = default;\n-\n-            ::std::string as_string() const;\n-\n-            /* Converts TypePath to SimplePath if possible (i.e. no generic or function arguments).\n-             * Otherwise returns an empty SimplePath. */\n-            SimplePath as_simple_path() const;\n-\n-            // Creates a trait bound with a clone of this type path as its only element.\n-            virtual TraitBound* to_trait_bound(bool in_parens) const OVERRIDE;\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-        };\n-\n-        struct QualifiedPathType {\n-          private:\n-            // Type type_to_invoke_on;\n-            ::std::unique_ptr<Type> type_to_invoke_on;\n-\n-            // bool has_as_clause;\n-            TypePath trait_path;\n-\n-            Location locus;\n-\n-          public:\n-            // Constructor\n-            QualifiedPathType(::std::unique_ptr<Type> invoke_on_type, Location locus = Location(),\n-              TypePath trait_path = TypePath::create_error()) :\n-              type_to_invoke_on(::std::move(invoke_on_type)),\n-              trait_path(::std::move(trait_path)), locus(locus) {}\n-\n-            // Copy constructor uses custom deep copy for Type to preserve polymorphism\n-            QualifiedPathType(QualifiedPathType const& other) :\n-              type_to_invoke_on(other.type_to_invoke_on->clone_type()), trait_path(other.trait_path),\n-              locus(other.locus) {}\n-\n-            // default destructor\n-            ~QualifiedPathType() = default;\n-\n-            // overload assignment operator to use custom clone method\n-            QualifiedPathType& operator=(QualifiedPathType const& other) {\n-                type_to_invoke_on = other.type_to_invoke_on->clone_type();\n-                trait_path = other.trait_path;\n-                locus = other.locus;\n-                return *this;\n-            }\n-\n-            // move constructor\n-            QualifiedPathType(QualifiedPathType&& other) = default;\n-            QualifiedPathType& operator=(QualifiedPathType&& other) = default;\n-\n-            // Returns whether the qualified path type has a rebind as clause.\n-            inline bool has_as_clause() const {\n-                return !trait_path.is_error();\n-            }\n-\n-            // Returns whether the qualified path type is in an error state.\n-            inline bool is_error() const {\n-                return type_to_invoke_on == NULL;\n-            }\n-\n-            // Creates an error state qualified path type.\n-            static QualifiedPathType create_error() {\n-                return QualifiedPathType(NULL);\n-            }\n-\n-            ::std::string as_string() const;\n-\n-            inline Location get_locus() const {\n-                return locus;\n-            }\n-        };\n-\n-        /* AST node representing a qualified path-in-expression pattern (path that allows specifying\n-         * trait functions) */\n-        class QualifiedPathInExpression\n-          : public PathPattern\n-          , public PathExpr {\n-            QualifiedPathType path_type;\n-\n-            Location locus;\n-\n-          public:\n-            ::std::string as_string() const;\n-\n-            QualifiedPathInExpression(QualifiedPathType qual_path_type,\n-              ::std::vector<PathExprSegment> path_segments, Location locus = Location(),\n-              ::std::vector<Attribute> outer_attrs = ::std::vector<Attribute>()) :\n-              PathPattern(::std::move(path_segments)),\n-              PathExpr(::std::move(outer_attrs)), path_type(::std::move(qual_path_type)),\n-              locus(locus) {}\n-\n-            // TODO: maybe make a shortcut constructor that has QualifiedPathType elements as params\n-\n-            // Copy constructor, destructor, and assignment operator overload shouldn't be required\n-\n-            // Returns whether qualified path in expression is in an error state.\n-            inline bool is_error() const {\n-                return path_type.is_error();\n-            }\n-\n-            // Creates an error qualified path in expression.\n-            static QualifiedPathInExpression create_error() {\n-                return QualifiedPathInExpression(\n-                  QualifiedPathType::create_error(), ::std::vector<PathExprSegment>());\n-            }\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-            Location get_locus_slow() const OVERRIDE {\n-                return get_locus();\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual QualifiedPathInExpression* clone_pattern_impl() const OVERRIDE {\n-                return new QualifiedPathInExpression(*this);\n-            }\n-\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual QualifiedPathInExpression* clone_expr_without_block_impl() const OVERRIDE {\n-                return new QualifiedPathInExpression(*this);\n-            }\n-        };\n-\n-        // Represents a qualified path in a type; used for disambiguating trait function calls\n-        class QualifiedPathInType : public TypeNoBounds {\n-            QualifiedPathType path_type;\n-            // ::std::vector<TypePathSegment> segments;\n-            ::std::vector< ::std::unique_ptr<TypePathSegment> > segments;\n-\n-            Location locus;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual QualifiedPathInType* clone_type_impl() const OVERRIDE {\n-                return new QualifiedPathInType(*this);\n-            }\n-\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual QualifiedPathInType* clone_type_no_bounds_impl() const OVERRIDE {\n-                return new QualifiedPathInType(*this);\n-            }\n-\n-          public:\n-            QualifiedPathInType(QualifiedPathType qual_path_type,\n-              ::std::vector< ::std::unique_ptr<TypePathSegment> > path_segments,\n-              Location locus = Location()) :\n-              path_type(::std::move(qual_path_type)),\n-              segments(::std::move(path_segments)), locus(locus) {}\n-\n-            // TODO: maybe make a shortcut constructor that has QualifiedPathType elements as params\n-\n-            // Copy constructor with vector clone\n-            QualifiedPathInType(QualifiedPathInType const& other) :\n-              path_type(other.path_type), locus(other.locus) {\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                segments.reserve(other.segments.size());\n-\n-                for (const auto& e : other.segments) {\n-                    segments.push_back(e->clone_type_path_segment());\n-                }\n-            }\n-\n-            // Overloaded assignment operator with vector clone\n-            QualifiedPathInType& operator=(QualifiedPathInType const& other) {\n-                path_type = other.path_type;\n-                locus = other.locus;\n-\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                segments.reserve(other.segments.size());\n-\n-                for (const auto& e : other.segments) {\n-                    segments.push_back(e->clone_type_path_segment());\n-                }\n-\n-                return *this;\n-            }\n-\n-            // move constructors\n-            QualifiedPathInType(QualifiedPathInType&& other) = default;\n-            QualifiedPathInType& operator=(QualifiedPathInType&& other) = default;\n-\n-            // Returns whether qualified path in type is in an error state.\n-            inline bool is_error() const {\n-                return path_type.is_error();\n-            }\n-\n-            // Creates an error state qualified path in type.\n-            static QualifiedPathInType create_error() {\n-                return QualifiedPathInType(QualifiedPathType::create_error(),\n-                  ::std::vector< ::std::unique_ptr<TypePathSegment> >());\n-            }\n-\n-            ::std::string as_string() const;\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-        };\n-    }\n-}\n+namespace AST {\n+// make intellisense calm\n+/*typedef ::std::string Symbol;\n+typedef int Lifetime;\n+typedef int Type;\n+typedef int Binding;*/\n+\n+// The \"identifier\" (not generic args) aspect of each path expression segment\n+class PathIdentSegment\n+{\n+  ::std::string segment_name;\n+\n+  // TODO: should this have location info stored?\n+\n+  // only allow identifiers, \"super\", \"self\", \"Self\", \"crate\", or \"$crate\"\n+public:\n+  PathIdentSegment (::std::string segment_name)\n+    : segment_name (::std::move (segment_name))\n+  {}\n+\n+  /* TODO: insert check in constructor for this? Or is this a semantic error\n+   * best handled then? */\n+\n+  // TODO: does this require visitor. pretty sure this isn't polymorphic, but\n+  // not entirely sure\n+\n+  // Creates an error PathIdentSegment.\n+  static PathIdentSegment create_error () { return PathIdentSegment (\"\"); }\n+\n+  // Returns whether PathIdentSegment is in an error state.\n+  inline bool is_error () const { return segment_name.empty (); }\n+\n+  ::std::string as_string () const { return segment_name; }\n+};\n+\n+// A binding of an identifier to a type used in generic arguments in paths\n+struct GenericArgsBinding\n+{\n+private:\n+  Identifier identifier;\n+  // Type type;\n+  ::std::unique_ptr<Type> type;\n+\n+  Location locus;\n+\n+public:\n+  // Returns whether binding is in an error state.\n+  inline bool is_error () const\n+  {\n+    return type\n+\t   == NULL; // and also identifier is empty, but cheaper computation\n+  }\n+\n+  // Creates an error state generic args binding.\n+  static GenericArgsBinding create_error ()\n+  {\n+    return GenericArgsBinding (\"\", NULL);\n+  }\n+\n+  // Pointer type for type in constructor to enable polymorphism\n+  GenericArgsBinding (Identifier ident, ::std::unique_ptr<Type> type_ptr,\n+\t\t      Location locus = Location ())\n+    : identifier (::std::move (ident)), type (::std::move (type_ptr)),\n+      locus (locus)\n+  {}\n+\n+  // Copy constructor has to deep copy the type as it is a unique pointer\n+  GenericArgsBinding (GenericArgsBinding const &other)\n+    : identifier (other.identifier), type (other.type->clone_type ()),\n+      locus (other.locus)\n+  {}\n+\n+  // default destructor\n+  ~GenericArgsBinding () = default;\n+\n+  // Overload assignment operator to deep copy the pointed-to type\n+  GenericArgsBinding &operator= (GenericArgsBinding const &other)\n+  {\n+    identifier = other.identifier;\n+    type = other.type->clone_type ();\n+    locus = other.locus;\n+    return *this;\n+  }\n+\n+  // move constructors\n+  GenericArgsBinding (GenericArgsBinding &&other) = default;\n+  GenericArgsBinding &operator= (GenericArgsBinding &&other) = default;\n+\n+  ::std::string as_string () const;\n+};\n+\n+// Generic arguments allowed in each path expression segment - inline?\n+struct GenericArgs\n+{\n+  ::std::vector<Lifetime> lifetime_args;\n+  //::std::vector<Type> type_args;\n+  ::std::vector< ::std::unique_ptr<Type> > type_args;\n+  ::std::vector<GenericArgsBinding> binding_args;\n+\n+  Location locus;\n+\n+public:\n+  // Returns true if there are any generic arguments\n+  inline bool has_generic_args () const\n+  {\n+    return !(lifetime_args.empty () && type_args.empty ()\n+\t     && binding_args.empty ());\n+  }\n+\n+  GenericArgs (::std::vector<Lifetime> lifetime_args,\n+\t       ::std::vector< ::std::unique_ptr<Type> > type_args,\n+\t       ::std::vector<GenericArgsBinding> binding_args,\n+\t       Location locus = Location ())\n+    : lifetime_args (::std::move (lifetime_args)),\n+      type_args (::std::move (type_args)),\n+      binding_args (::std::move (binding_args)), locus (locus)\n+  {}\n+\n+  // copy constructor with vector clone\n+  GenericArgs (GenericArgs const &other)\n+    : lifetime_args (other.lifetime_args), binding_args (other.binding_args),\n+      locus (other.locus)\n+  {\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    type_args.reserve (other.type_args.size ());\n+\n+    for (const auto &e : other.type_args)\n+      {\n+\ttype_args.push_back (e->clone_type ());\n+      }\n+  }\n+\n+  ~GenericArgs () = default;\n+\n+  // overloaded assignment operator to vector clone\n+  GenericArgs &operator= (GenericArgs const &other)\n+  {\n+    lifetime_args = other.lifetime_args;\n+    binding_args = other.binding_args;\n+    locus = other.locus;\n+\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    type_args.reserve (other.type_args.size ());\n+\n+    for (const auto &e : other.type_args)\n+      {\n+\ttype_args.push_back (e->clone_type ());\n+      }\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  GenericArgs (GenericArgs &&other) = default;\n+  GenericArgs &operator= (GenericArgs &&other) = default;\n+\n+  // Creates an empty GenericArgs (no arguments)\n+  static GenericArgs create_empty ()\n+  {\n+    return GenericArgs (::std::vector<Lifetime> (),\n+\t\t\t::std::vector< ::std::unique_ptr<Type> > (),\n+\t\t\t::std::vector<GenericArgsBinding> ());\n+  }\n+\n+  ::std::string as_string () const;\n+};\n+\n+// A segment of a path in expression, including an identifier aspect and maybe\n+// generic args\n+class PathExprSegment\n+{ // or should this extend PathIdentSegment?\n+private:\n+  PathIdentSegment segment_name;\n+\n+  // bool has_generic_args;\n+  GenericArgs generic_args;\n+\n+  Location locus;\n+\n+  // TODO: does this require visitor? pretty sure not polymorphic\n+\n+public:\n+  // Returns true if there are any generic arguments\n+  inline bool has_generic_args () const\n+  {\n+    return generic_args.has_generic_args ();\n+  }\n+\n+  // Constructor for segment (from IdentSegment and GenericArgs)\n+  PathExprSegment (PathIdentSegment segment_name, Location locus = Location (),\n+\t\t   GenericArgs generic_args = GenericArgs::create_empty ())\n+    : segment_name (::std::move (segment_name)),\n+      generic_args (::std::move (generic_args)), locus (locus)\n+  {}\n+\n+  // Constructor for segment with generic arguments (from segment name and all\n+  // args)\n+  PathExprSegment (::std::string segment_name, Location locus,\n+\t\t   ::std::vector<Lifetime> lifetime_args\n+\t\t   = ::std::vector<Lifetime> (),\n+\t\t   ::std::vector< ::std::unique_ptr<Type> > type_args\n+\t\t   = ::std::vector< ::std::unique_ptr<Type> > (),\n+\t\t   ::std::vector<GenericArgsBinding> binding_args\n+\t\t   = ::std::vector<GenericArgsBinding> ())\n+    : segment_name (PathIdentSegment (::std::move (segment_name))),\n+      generic_args (GenericArgs (::std::move (lifetime_args),\n+\t\t\t\t ::std::move (type_args),\n+\t\t\t\t ::std::move (binding_args))),\n+      locus (locus)\n+  {}\n+\n+  // Returns whether path expression segment is in an error state.\n+  inline bool is_error () const { return segment_name.is_error (); }\n+\n+  // Creates an error-state path expression segment.\n+  static PathExprSegment create_error ()\n+  {\n+    return PathExprSegment (PathIdentSegment::create_error ());\n+  }\n+\n+  ::std::string as_string () const;\n+\n+  inline Location get_locus () const { return locus; }\n+};\n+\n+// AST node representing a pattern that involves a \"path\" - abstract base class\n+class PathPattern : public Pattern\n+{\n+  ::std::vector<PathExprSegment> segments;\n+\n+protected:\n+  PathPattern (::std::vector<PathExprSegment> segments)\n+    : segments (::std::move (segments))\n+  {}\n+\n+  // Returns whether path has segments.\n+  inline bool has_segments () const { return !segments.empty (); }\n+\n+  /* Converts path segments to their equivalent SimplePath segments if possible,\n+   * and creates a SimplePath from them. */\n+  SimplePath convert_to_simple_path (bool with_opening_scope_resolution) const;\n+\n+public:\n+  /* Returns whether the path is a single segment (excluding qualified path\n+   * initial as segment). */\n+  inline bool is_single_segment () const { return segments.size () == 1; }\n+\n+  virtual ::std::string as_string () const;\n+};\n+\n+// AST node representing a path-in-expression pattern (path that allows generic\n+// arguments)\n+class PathInExpression : public PathPattern, public PathExpr\n+{\n+  bool has_opening_scope_resolution;\n+\n+  Location locus;\n+\n+public:\n+  ::std::string as_string () const;\n+\n+  // Constructor\n+  PathInExpression (::std::vector<PathExprSegment> path_segments,\n+\t\t    Location locus = Location (),\n+\t\t    bool has_opening_scope_resolution = false,\n+\t\t    ::std::vector<Attribute> outer_attrs\n+\t\t    = ::std::vector<Attribute> ())\n+    : PathPattern (::std::move (path_segments)),\n+      PathExpr (::std::move (outer_attrs)),\n+      has_opening_scope_resolution (has_opening_scope_resolution), locus (locus)\n+  {}\n+\n+  // Creates an error state path in expression.\n+  static PathInExpression create_error ()\n+  {\n+    return PathInExpression (::std::vector<PathExprSegment> ());\n+  }\n+\n+  // Returns whether path in expression is in an error state.\n+  inline bool is_error () const { return !has_segments (); }\n+\n+  /* Converts PathInExpression to SimplePath if possible (i.e. no generic\n+   * arguments). Otherwise returns an empty SimplePath. */\n+  inline SimplePath as_simple_path () const\n+  {\n+    /* delegate to parent class as can't access segments. however,\n+     * QualifiedPathInExpression conversion to simple path wouldn't make sense,\n+     * so the method in the parent class should be protected, not public. Have\n+     * to pass in opening scope resolution as parent class has no access to it.\n+     */\n+    return convert_to_simple_path (has_opening_scope_resolution);\n+  }\n+\n+  Location get_locus () const { return locus; }\n+\n+  Location get_locus_slow () const OVERRIDE { return get_locus (); }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual PathInExpression *clone_pattern_impl () const OVERRIDE\n+  {\n+    return new PathInExpression (*this);\n+  }\n+\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual PathInExpression *clone_expr_without_block_impl () const OVERRIDE\n+  {\n+    return new PathInExpression (*this);\n+  }\n+};\n+\n+// Base class for segments used in type paths - not abstract (represents an\n+// ident-only segment)\n+class TypePathSegment\n+{\n+  /* TODO: may have to unify TypePathSegment and PathExprSegment (which are\n+   * mostly the same anyway) in order to resolve goddamn syntax ambiguities. One\n+   * difference is that function on TypePathSegment is not allowed if\n+   * GenericArgs are, so could disallow that in constructor, which won't give\n+   * that much size overhead. */\n+  PathIdentSegment ident_segment;\n+\n+  Location locus;\n+\n+protected:\n+  // This is protected because it is only really used by derived classes, not\n+  // the base.\n+  bool has_separating_scope_resolution;\n+\n+  // Clone function implementation - not pure virtual as overrided by subclasses\n+  virtual TypePathSegment *clone_type_path_segment_impl () const\n+  {\n+    return new TypePathSegment (*this);\n+  }\n+\n+public:\n+  virtual ~TypePathSegment () {}\n+\n+  // Unique pointer custom clone function\n+  ::std::unique_ptr<TypePathSegment> clone_type_path_segment () const\n+  {\n+    return ::std::unique_ptr<TypePathSegment> (clone_type_path_segment_impl ());\n+  }\n+\n+  TypePathSegment (PathIdentSegment ident_segment,\n+\t\t   bool has_separating_scope_resolution, Location locus)\n+    : ident_segment (::std::move (ident_segment)), locus (locus),\n+      has_separating_scope_resolution (has_separating_scope_resolution)\n+  {}\n+\n+  TypePathSegment (::std::string segment_name,\n+\t\t   bool has_separating_scope_resolution, Location locus)\n+    : ident_segment (PathIdentSegment (::std::move (segment_name))),\n+      locus (locus),\n+      has_separating_scope_resolution (has_separating_scope_resolution)\n+  {}\n+\n+  virtual ::std::string as_string () const\n+  {\n+    return ident_segment.as_string ();\n+  }\n+\n+  // Returns whether the type path segment is in an error state. May be virtual\n+  // in future.\n+  inline bool is_error () const { return ident_segment.is_error (); }\n+\n+  /* Returns whether segment is identifier only (as opposed to generic args or\n+  function). Overriden in derived classes with other segments. */\n+  virtual bool is_ident_only () const { return true; }\n+\n+  inline Location get_locus () const { return locus; }\n+\n+  // not pure virtual as class not abstract\n+  virtual void accept_vis (ASTVisitor &vis);\n+};\n+\n+// Segment used in type path with generic args\n+class TypePathSegmentGeneric : public TypePathSegment\n+{\n+  GenericArgs generic_args;\n+\n+public:\n+  inline bool has_generic_args () const\n+  {\n+    return generic_args.has_generic_args ();\n+  }\n+\n+  bool is_ident_only () const { return false; }\n+\n+  // Constructor with PathIdentSegment and GenericArgs\n+  TypePathSegmentGeneric (PathIdentSegment ident_segment,\n+\t\t\t  bool has_separating_scope_resolution,\n+\t\t\t  GenericArgs generic_args, Location locus)\n+    : TypePathSegment (::std::move (ident_segment),\n+\t\t       has_separating_scope_resolution, locus),\n+      generic_args (::std::move (generic_args))\n+  {}\n+\n+  // Constructor from segment name and all args\n+  TypePathSegmentGeneric (::std::string segment_name,\n+\t\t\t  bool has_separating_scope_resolution,\n+\t\t\t  ::std::vector<Lifetime> lifetime_args,\n+\t\t\t  ::std::vector< ::std::unique_ptr<Type> > type_args,\n+\t\t\t  ::std::vector<GenericArgsBinding> binding_args,\n+\t\t\t  Location locus)\n+    : TypePathSegment (::std::move (segment_name),\n+\t\t       has_separating_scope_resolution, locus),\n+      generic_args (GenericArgs (::std::move (lifetime_args),\n+\t\t\t\t ::std::move (type_args),\n+\t\t\t\t ::std::move (binding_args)))\n+  {}\n+\n+  ::std::string as_string () const;\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to override base class method\n+  virtual TypePathSegmentGeneric *clone_type_path_segment_impl () const OVERRIDE\n+  {\n+    return new TypePathSegmentGeneric (*this);\n+  }\n+};\n+\n+// A function as represented in a type path\n+struct TypePathFunction\n+{\n+private:\n+  // TODO: remove\n+  /*bool has_inputs;\n+  TypePathFnInputs inputs;*/\n+  //::std::vector<Type> inputs; // inlined from TypePathFnInputs\n+  ::std::vector< ::std::unique_ptr<Type> > inputs;\n+\n+  // bool has_type;\n+  // Type type;\n+  ::std::unique_ptr<Type> return_type;\n+\n+  // FIXME: think of better way to mark as invalid than taking up storage\n+  bool is_invalid;\n+\n+  // TODO: should this have location info?\n+\n+protected:\n+  // Constructor only used to create invalid type path functions.\n+  TypePathFunction (bool is_invalid) : is_invalid (is_invalid) {}\n+\n+public:\n+  // Returns whether the return type of the function has been specified.\n+  inline bool has_return_type () const { return return_type != NULL; }\n+\n+  // Returns whether the function has inputs.\n+  inline bool has_inputs () const { return !inputs.empty (); }\n+\n+  // Returns whether function is in an error state.\n+  inline bool is_error () const { return is_invalid; }\n+\n+  // Creates an error state function.\n+  static TypePathFunction create_error () { return TypePathFunction (true); }\n+\n+  // Constructor\n+  TypePathFunction (::std::vector< ::std::unique_ptr<Type> > inputs,\n+\t\t    Type *type = NULL)\n+    : inputs (::std::move (inputs)), return_type (type), is_invalid (false)\n+  {}\n+  // FIXME: deprecated\n+\n+  // Constructor\n+  TypePathFunction (::std::vector< ::std::unique_ptr<Type> > inputs,\n+\t\t    ::std::unique_ptr<Type> type = NULL)\n+    : inputs (::std::move (inputs)), return_type (::std::move (type)),\n+      is_invalid (false)\n+  {}\n+\n+  // Copy constructor with clone\n+  TypePathFunction (TypePathFunction const &other)\n+    : /*inputs(other.inputs),*/ return_type (other.return_type->clone_type ()),\n+      is_invalid (other.is_invalid)\n+  {\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    inputs.reserve (other.inputs.size ());\n+\n+    for (const auto &e : other.inputs)\n+      {\n+\tinputs.push_back (e->clone_type ());\n+      }\n+  }\n+\n+  ~TypePathFunction () = default;\n+\n+  // Overloaded assignment operator to clone type\n+  TypePathFunction &operator= (TypePathFunction const &other)\n+  {\n+    // inputs = other.inputs;\n+    return_type = other.return_type->clone_type ();\n+    is_invalid = other.is_invalid;\n+\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    inputs.reserve (other.inputs.size ());\n+\n+    for (const auto &e : other.inputs)\n+      {\n+\tinputs.push_back (e->clone_type ());\n+      }\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TypePathFunction (TypePathFunction &&other) = default;\n+  TypePathFunction &operator= (TypePathFunction &&other) = default;\n+\n+  ::std::string as_string () const;\n+};\n+\n+// Segment used in type path with a function argument\n+class TypePathSegmentFunction : public TypePathSegment\n+{\n+  TypePathFunction function_path;\n+\n+public:\n+  // Constructor with PathIdentSegment and TypePathFn\n+  TypePathSegmentFunction (PathIdentSegment ident_segment,\n+\t\t\t   bool has_separating_scope_resolution,\n+\t\t\t   TypePathFunction function_path, Location locus)\n+    : TypePathSegment (::std::move (ident_segment),\n+\t\t       has_separating_scope_resolution, locus),\n+      function_path (::std::move (function_path))\n+  {}\n+\n+  // Constructor with segment name and TypePathFn\n+  TypePathSegmentFunction (::std::string segment_name,\n+\t\t\t   bool has_separating_scope_resolution,\n+\t\t\t   TypePathFunction function_path, Location locus)\n+    : TypePathSegment (::std::move (segment_name),\n+\t\t       has_separating_scope_resolution, locus),\n+      function_path (::std::move (function_path))\n+  {}\n+\n+  ::std::string as_string () const;\n+\n+  bool is_ident_only () const { return false; }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to override base class method\n+  virtual TypePathSegmentFunction *\n+  clone_type_path_segment_impl () const OVERRIDE\n+  {\n+    return new TypePathSegmentFunction (*this);\n+  }\n+};\n+\n+// Path used inside types\n+class TypePath : public TypeNoBounds\n+{\n+  bool has_opening_scope_resolution;\n+  ::std::vector< ::std::unique_ptr<TypePathSegment> > segments;\n+\n+  Location locus;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual TypePath *clone_type_impl () const OVERRIDE\n+  {\n+    return new TypePath (*this);\n+  }\n+\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual TypePath *clone_type_no_bounds_impl () const OVERRIDE\n+  {\n+    return new TypePath (*this);\n+  }\n+\n+public:\n+  /* Returns whether the TypePath has an opening scope resolution operator (i.e.\n+   * is global path or crate-relative path, not module-relative) */\n+  inline bool has_opening_scope_resolution_op () const\n+  {\n+    return has_opening_scope_resolution;\n+  }\n+\n+  // Returns whether the TypePath is in an invalid state.\n+  inline bool is_error () const { return segments.empty (); }\n+\n+  // Creates an error state TypePath.\n+  static TypePath create_error ()\n+  {\n+    return TypePath (::std::vector< ::std::unique_ptr<TypePathSegment> > (),\n+\t\t     Location ());\n+  }\n+\n+  // Constructor\n+  TypePath (::std::vector< ::std::unique_ptr<TypePathSegment> > segments,\n+\t    Location locus, bool has_opening_scope_resolution = false)\n+    : has_opening_scope_resolution (has_opening_scope_resolution),\n+      segments (::std::move (segments)), locus (locus)\n+  {}\n+\n+  // Copy constructor with vector clone\n+  TypePath (TypePath const &other)\n+    : has_opening_scope_resolution (other.has_opening_scope_resolution),\n+      locus (other.locus)\n+  {\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    segments.reserve (other.segments.size ());\n+\n+    for (const auto &e : other.segments)\n+      {\n+\tsegments.push_back (e->clone_type_path_segment ());\n+      }\n+  }\n+\n+  // Overloaded assignment operator with clone\n+  TypePath &operator= (TypePath const &other)\n+  {\n+    has_opening_scope_resolution = other.has_opening_scope_resolution;\n+    locus = other.locus;\n+\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    segments.reserve (other.segments.size ());\n+\n+    for (const auto &e : other.segments)\n+      {\n+\tsegments.push_back (e->clone_type_path_segment ());\n+      }\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TypePath (TypePath &&other) = default;\n+  TypePath &operator= (TypePath &&other) = default;\n+\n+  ::std::string as_string () const;\n+\n+  /* Converts TypePath to SimplePath if possible (i.e. no generic or function\n+   * arguments). Otherwise returns an empty SimplePath. */\n+  SimplePath as_simple_path () const;\n+\n+  // Creates a trait bound with a clone of this type path as its only element.\n+  virtual TraitBound *to_trait_bound (bool in_parens) const OVERRIDE;\n+\n+  Location get_locus () const { return locus; }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+};\n+\n+struct QualifiedPathType\n+{\n+private:\n+  // Type type_to_invoke_on;\n+  ::std::unique_ptr<Type> type_to_invoke_on;\n+\n+  // bool has_as_clause;\n+  TypePath trait_path;\n+\n+  Location locus;\n+\n+public:\n+  // Constructor\n+  QualifiedPathType (::std::unique_ptr<Type> invoke_on_type,\n+\t\t     Location locus = Location (),\n+\t\t     TypePath trait_path = TypePath::create_error ())\n+    : type_to_invoke_on (::std::move (invoke_on_type)),\n+      trait_path (::std::move (trait_path)), locus (locus)\n+  {}\n+\n+  // Copy constructor uses custom deep copy for Type to preserve polymorphism\n+  QualifiedPathType (QualifiedPathType const &other)\n+    : type_to_invoke_on (other.type_to_invoke_on->clone_type ()),\n+      trait_path (other.trait_path), locus (other.locus)\n+  {}\n+\n+  // default destructor\n+  ~QualifiedPathType () = default;\n+\n+  // overload assignment operator to use custom clone method\n+  QualifiedPathType &operator= (QualifiedPathType const &other)\n+  {\n+    type_to_invoke_on = other.type_to_invoke_on->clone_type ();\n+    trait_path = other.trait_path;\n+    locus = other.locus;\n+    return *this;\n+  }\n+\n+  // move constructor\n+  QualifiedPathType (QualifiedPathType &&other) = default;\n+  QualifiedPathType &operator= (QualifiedPathType &&other) = default;\n+\n+  // Returns whether the qualified path type has a rebind as clause.\n+  inline bool has_as_clause () const { return !trait_path.is_error (); }\n+\n+  // Returns whether the qualified path type is in an error state.\n+  inline bool is_error () const { return type_to_invoke_on == NULL; }\n+\n+  // Creates an error state qualified path type.\n+  static QualifiedPathType create_error () { return QualifiedPathType (NULL); }\n+\n+  ::std::string as_string () const;\n+\n+  inline Location get_locus () const { return locus; }\n+};\n+\n+/* AST node representing a qualified path-in-expression pattern (path that\n+ * allows specifying trait functions) */\n+class QualifiedPathInExpression : public PathPattern, public PathExpr\n+{\n+  QualifiedPathType path_type;\n+\n+  Location locus;\n+\n+public:\n+  ::std::string as_string () const;\n+\n+  QualifiedPathInExpression (QualifiedPathType qual_path_type,\n+\t\t\t     ::std::vector<PathExprSegment> path_segments,\n+\t\t\t     Location locus = Location (),\n+\t\t\t     ::std::vector<Attribute> outer_attrs\n+\t\t\t     = ::std::vector<Attribute> ())\n+    : PathPattern (::std::move (path_segments)),\n+      PathExpr (::std::move (outer_attrs)),\n+      path_type (::std::move (qual_path_type)), locus (locus)\n+  {}\n+\n+  // TODO: maybe make a shortcut constructor that has QualifiedPathType elements\n+  // as params\n+\n+  // Copy constructor, destructor, and assignment operator overload shouldn't be\n+  // required\n+\n+  // Returns whether qualified path in expression is in an error state.\n+  inline bool is_error () const { return path_type.is_error (); }\n+\n+  // Creates an error qualified path in expression.\n+  static QualifiedPathInExpression create_error ()\n+  {\n+    return QualifiedPathInExpression (QualifiedPathType::create_error (),\n+\t\t\t\t      ::std::vector<PathExprSegment> ());\n+  }\n+\n+  Location get_locus () const { return locus; }\n+\n+  Location get_locus_slow () const OVERRIDE { return get_locus (); }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual QualifiedPathInExpression *clone_pattern_impl () const OVERRIDE\n+  {\n+    return new QualifiedPathInExpression (*this);\n+  }\n+\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual QualifiedPathInExpression *\n+  clone_expr_without_block_impl () const OVERRIDE\n+  {\n+    return new QualifiedPathInExpression (*this);\n+  }\n+};\n+\n+// Represents a qualified path in a type; used for disambiguating trait function\n+// calls\n+class QualifiedPathInType : public TypeNoBounds\n+{\n+  QualifiedPathType path_type;\n+  // ::std::vector<TypePathSegment> segments;\n+  ::std::vector< ::std::unique_ptr<TypePathSegment> > segments;\n+\n+  Location locus;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual QualifiedPathInType *clone_type_impl () const OVERRIDE\n+  {\n+    return new QualifiedPathInType (*this);\n+  }\n+\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual QualifiedPathInType *clone_type_no_bounds_impl () const OVERRIDE\n+  {\n+    return new QualifiedPathInType (*this);\n+  }\n+\n+public:\n+  QualifiedPathInType (\n+    QualifiedPathType qual_path_type,\n+    ::std::vector< ::std::unique_ptr<TypePathSegment> > path_segments,\n+    Location locus = Location ())\n+    : path_type (::std::move (qual_path_type)),\n+      segments (::std::move (path_segments)), locus (locus)\n+  {}\n+\n+  // TODO: maybe make a shortcut constructor that has QualifiedPathType elements\n+  // as params\n+\n+  // Copy constructor with vector clone\n+  QualifiedPathInType (QualifiedPathInType const &other)\n+    : path_type (other.path_type), locus (other.locus)\n+  {\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    segments.reserve (other.segments.size ());\n+\n+    for (const auto &e : other.segments)\n+      {\n+\tsegments.push_back (e->clone_type_path_segment ());\n+      }\n+  }\n+\n+  // Overloaded assignment operator with vector clone\n+  QualifiedPathInType &operator= (QualifiedPathInType const &other)\n+  {\n+    path_type = other.path_type;\n+    locus = other.locus;\n+\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    segments.reserve (other.segments.size ());\n+\n+    for (const auto &e : other.segments)\n+      {\n+\tsegments.push_back (e->clone_type_path_segment ());\n+      }\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  QualifiedPathInType (QualifiedPathInType &&other) = default;\n+  QualifiedPathInType &operator= (QualifiedPathInType &&other) = default;\n+\n+  // Returns whether qualified path in type is in an error state.\n+  inline bool is_error () const { return path_type.is_error (); }\n+\n+  // Creates an error state qualified path in type.\n+  static QualifiedPathInType create_error ()\n+  {\n+    return QualifiedPathInType (\n+      QualifiedPathType::create_error (),\n+      ::std::vector< ::std::unique_ptr<TypePathSegment> > ());\n+  }\n+\n+  ::std::string as_string () const;\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+};\n+} // namespace AST\n+} // namespace Rust\n \n #endif"}, {"sha": "533a65f12db662106c187ebdd9f06a8bf6293896", "filename": "gcc/rust/ast/rust-pattern.h", "status": "modified", "additions": 1304, "deletions": 1144, "changes": 2448, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Fast%2Frust-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Fast%2Frust-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-pattern.h?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -4,1160 +4,1320 @@\n #include \"rust-ast.h\"\n \n namespace Rust {\n-    namespace AST {\n-        // Literal pattern AST node (comparing to a literal)\n-        class LiteralPattern : public Pattern {\n-            Literal lit; // make literal have a type given by enum, etc. rustc uses an extended form\n-            // of its literal token implementation\n-            // FIXME: literal representation - use LiteralExpr? or another thing?\n-\n-            // Minus prefixed to literal (if integer or floating-point)\n-            bool has_minus;\n-            // Actually, this might be a good place to use a template.\n-\n-            Location locus;\n-\n-          public:\n-            ::std::string as_string() const;\n-\n-            // Constructor for a literal pattern\n-            LiteralPattern(Literal lit, Location locus, bool has_minus = false) :\n-              lit(::std::move(lit)), has_minus(has_minus), locus(locus) {}\n-\n-            LiteralPattern(\n-              ::std::string val, Literal::LitType type, Location locus, bool has_minus = false) :\n-              lit(Literal(::std::move(val), type)),\n-              has_minus(has_minus), locus(locus) {}\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual LiteralPattern* clone_pattern_impl() const OVERRIDE {\n-                return new LiteralPattern(*this);\n-            }\n-        };\n-\n-        // Identifier pattern AST node (bind value matched to a variable)\n-        class IdentifierPattern : public Pattern {\n-            Identifier variable_ident;\n-            bool is_ref;\n-            bool is_mut;\n-\n-            // bool has_pattern;\n-            // Pattern* to_bind;\n-            ::std::unique_ptr<Pattern> to_bind;\n-\n-            Location locus;\n-\n-          public:\n-            /*~IdentifierPattern() {\n-                delete to_bind;\n-            }*/\n-\n-            ::std::string as_string() const;\n-\n-            // Returns whether the IdentifierPattern has a pattern to bind.\n-            inline bool has_pattern_to_bind() const {\n-                return to_bind != NULL;\n-            }\n-\n-            // Constructor\n-            IdentifierPattern(Identifier ident, Location locus, bool is_ref = false,\n-              bool is_mut = false, ::std::unique_ptr<Pattern> to_bind = NULL) :\n-              variable_ident(::std::move(ident)),\n-              is_ref(is_ref), is_mut(is_mut), to_bind(::std::move(to_bind)), locus(locus) {}\n-\n-            // Copy constructor with clone\n-            IdentifierPattern(IdentifierPattern const& other) :\n-              variable_ident(other.variable_ident), is_ref(other.is_ref), is_mut(other.is_mut),\n-              locus(other.locus) {\n-                // fix to get prevent null pointer dereference\n-                if (other.to_bind != NULL) {\n-                    to_bind = other.to_bind->clone_pattern();\n-                }\n-            }\n-\n-            // Destructor - define here if required\n-\n-            // Overload assignment operator to use clone\n-            IdentifierPattern& operator=(IdentifierPattern const& other) {\n-                variable_ident = other.variable_ident;\n-                is_ref = other.is_ref;\n-                is_mut = other.is_mut;\n-                locus = other.locus;\n-                // fix to get prevent null pointer dereference\n-                if (other.to_bind != NULL) {\n-                    to_bind = other.to_bind->clone_pattern();\n-                }\n-\n-                return *this;\n-            }\n-\n-            // default move semantics\n-            IdentifierPattern(IdentifierPattern&& other) = default;\n-            IdentifierPattern& operator=(IdentifierPattern&& other) = default;\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual IdentifierPattern* clone_pattern_impl() const OVERRIDE {\n-                return new IdentifierPattern(*this);\n-            }\n-        };\n-\n-        // AST node for using the '_' wildcard \"match any value\" pattern\n-        class WildcardPattern : public Pattern {\n-            Location locus;\n-\n-          public:\n-            ::std::string as_string() const {\n-                return ::std::string(1, '_');\n-            }\n-\n-            WildcardPattern(Location locus) : locus(locus) {}\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual WildcardPattern* clone_pattern_impl() const OVERRIDE {\n-                return new WildcardPattern(*this);\n-            }\n-        };\n-\n-        // Base range pattern bound (lower or upper limit) - abstract\n-        class RangePatternBound {\n-            /*union {\n-                CharLiteral char_lit;\n-                ByteLiteral byte_lit;\n-                IntLiteral int_lit;\n-                FloatLiteral float_lit;\n-                PathInExpression path;\n-                QualifiedPathInExpression qual_path;\n-            } pattern;*/\n-          public:\n-            virtual ~RangePatternBound() {}\n-\n-            // Unique pointer custom clone function\n-            ::std::unique_ptr<RangePatternBound> clone_range_pattern_bound() const {\n-                return ::std::unique_ptr<RangePatternBound>(clone_range_pattern_bound_impl());\n-            }\n-\n-            virtual ::std::string as_string() const = 0;\n-\n-            virtual void accept_vis(ASTVisitor& vis) = 0;\n-\n-          protected:\n-            // pure virtual as RangePatternBound is abstract\n-            virtual RangePatternBound* clone_range_pattern_bound_impl() const = 0;\n-        };\n-\n-        // Literal-based pattern bound\n-        class RangePatternBoundLiteral : public RangePatternBound {\n-            Literal literal;\n-            // Can only be a char, byte, int, or float literal - same impl here as previously\n-\n-            // Minus prefixed to literal (if integer or floating-point)\n-            bool has_minus;\n-\n-            Location locus;\n-\n-          public:\n-            // Constructor\n-            RangePatternBoundLiteral(Literal literal, Location locus, bool has_minus = false) :\n-              literal(literal), has_minus(has_minus), locus(locus) {}\n-\n-            ::std::string as_string() const;\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual RangePatternBoundLiteral* clone_range_pattern_bound_impl() const OVERRIDE {\n-                return new RangePatternBoundLiteral(*this);\n-            }\n-        };\n-\n-        // Path-based pattern bound\n-        class RangePatternBoundPath : public RangePatternBound {\n-            PathInExpression path;\n-\n-            // TODO: should this be refactored so that PathInExpression is a subclass of\n-            // RangePatternBound?\n-\n-          public:\n-            RangePatternBoundPath(PathInExpression path) : path(::std::move(path)) {}\n-\n-            ::std::string as_string() const {\n-                return path.as_string();\n-            }\n-\n-            Location get_locus() const {\n-                return path.get_locus();\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual RangePatternBoundPath* clone_range_pattern_bound_impl() const OVERRIDE {\n-                return new RangePatternBoundPath(*this);\n-            }\n-        };\n-\n-        // Qualified path-based pattern bound\n-        class RangePatternBoundQualPath : public RangePatternBound {\n-            QualifiedPathInExpression path;\n-\n-            /* TODO: should this be refactored so that QualifiedPathInExpression is a subclass of\n-             * RangePatternBound? */\n-\n-          public:\n-            RangePatternBoundQualPath(QualifiedPathInExpression path) : path(::std::move(path)) {}\n-\n-            ::std::string as_string() const {\n-                return path.as_string();\n-            }\n-\n-            Location get_locus() const {\n-                return path.get_locus();\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual RangePatternBoundQualPath* clone_range_pattern_bound_impl() const OVERRIDE {\n-                return new RangePatternBoundQualPath(*this);\n-            }\n-        };\n+namespace AST {\n+// Literal pattern AST node (comparing to a literal)\n+class LiteralPattern : public Pattern\n+{\n+  Literal lit; // make literal have a type given by enum, etc. rustc uses an\n+\t       // extended form\n+  // of its literal token implementation\n+  // FIXME: literal representation - use LiteralExpr? or another thing?\n+\n+  // Minus prefixed to literal (if integer or floating-point)\n+  bool has_minus;\n+  // Actually, this might be a good place to use a template.\n+\n+  Location locus;\n+\n+public:\n+  ::std::string as_string () const;\n+\n+  // Constructor for a literal pattern\n+  LiteralPattern (Literal lit, Location locus, bool has_minus = false)\n+    : lit (::std::move (lit)), has_minus (has_minus), locus (locus)\n+  {}\n+\n+  LiteralPattern (::std::string val, Literal::LitType type, Location locus,\n+\t\t  bool has_minus = false)\n+    : lit (Literal (::std::move (val), type)), has_minus (has_minus),\n+      locus (locus)\n+  {}\n+\n+  Location get_locus () const { return locus; }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual LiteralPattern *clone_pattern_impl () const OVERRIDE\n+  {\n+    return new LiteralPattern (*this);\n+  }\n+};\n+\n+// Identifier pattern AST node (bind value matched to a variable)\n+class IdentifierPattern : public Pattern\n+{\n+  Identifier variable_ident;\n+  bool is_ref;\n+  bool is_mut;\n+\n+  // bool has_pattern;\n+  // Pattern* to_bind;\n+  ::std::unique_ptr<Pattern> to_bind;\n+\n+  Location locus;\n+\n+public:\n+  /*~IdentifierPattern() {\n+      delete to_bind;\n+  }*/\n+\n+  ::std::string as_string () const;\n+\n+  // Returns whether the IdentifierPattern has a pattern to bind.\n+  inline bool has_pattern_to_bind () const { return to_bind != NULL; }\n+\n+  // Constructor\n+  IdentifierPattern (Identifier ident, Location locus, bool is_ref = false,\n+\t\t     bool is_mut = false,\n+\t\t     ::std::unique_ptr<Pattern> to_bind = NULL)\n+    : variable_ident (::std::move (ident)), is_ref (is_ref), is_mut (is_mut),\n+      to_bind (::std::move (to_bind)), locus (locus)\n+  {}\n+\n+  // Copy constructor with clone\n+  IdentifierPattern (IdentifierPattern const &other)\n+    : variable_ident (other.variable_ident), is_ref (other.is_ref),\n+      is_mut (other.is_mut), locus (other.locus)\n+  {\n+    // fix to get prevent null pointer dereference\n+    if (other.to_bind != NULL)\n+      {\n+\tto_bind = other.to_bind->clone_pattern ();\n+      }\n+  }\n+\n+  // Destructor - define here if required\n+\n+  // Overload assignment operator to use clone\n+  IdentifierPattern &operator= (IdentifierPattern const &other)\n+  {\n+    variable_ident = other.variable_ident;\n+    is_ref = other.is_ref;\n+    is_mut = other.is_mut;\n+    locus = other.locus;\n+    // fix to get prevent null pointer dereference\n+    if (other.to_bind != NULL)\n+      {\n+\tto_bind = other.to_bind->clone_pattern ();\n+      }\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  IdentifierPattern (IdentifierPattern &&other) = default;\n+  IdentifierPattern &operator= (IdentifierPattern &&other) = default;\n+\n+  Location get_locus () const { return locus; }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual IdentifierPattern *clone_pattern_impl () const OVERRIDE\n+  {\n+    return new IdentifierPattern (*this);\n+  }\n+};\n+\n+// AST node for using the '_' wildcard \"match any value\" pattern\n+class WildcardPattern : public Pattern\n+{\n+  Location locus;\n+\n+public:\n+  ::std::string as_string () const { return ::std::string (1, '_'); }\n+\n+  WildcardPattern (Location locus) : locus (locus) {}\n+\n+  Location get_locus () const { return locus; }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual WildcardPattern *clone_pattern_impl () const OVERRIDE\n+  {\n+    return new WildcardPattern (*this);\n+  }\n+};\n+\n+// Base range pattern bound (lower or upper limit) - abstract\n+class RangePatternBound\n+{\n+  /*union {\n+      CharLiteral char_lit;\n+      ByteLiteral byte_lit;\n+      IntLiteral int_lit;\n+      FloatLiteral float_lit;\n+      PathInExpression path;\n+      QualifiedPathInExpression qual_path;\n+  } pattern;*/\n+public:\n+  virtual ~RangePatternBound () {}\n+\n+  // Unique pointer custom clone function\n+  ::std::unique_ptr<RangePatternBound> clone_range_pattern_bound () const\n+  {\n+    return ::std::unique_ptr<RangePatternBound> (\n+      clone_range_pattern_bound_impl ());\n+  }\n+\n+  virtual ::std::string as_string () const = 0;\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+protected:\n+  // pure virtual as RangePatternBound is abstract\n+  virtual RangePatternBound *clone_range_pattern_bound_impl () const = 0;\n+};\n+\n+// Literal-based pattern bound\n+class RangePatternBoundLiteral : public RangePatternBound\n+{\n+  Literal literal;\n+  // Can only be a char, byte, int, or float literal - same impl here as\n+  // previously\n+\n+  // Minus prefixed to literal (if integer or floating-point)\n+  bool has_minus;\n+\n+  Location locus;\n+\n+public:\n+  // Constructor\n+  RangePatternBoundLiteral (Literal literal, Location locus,\n+\t\t\t    bool has_minus = false)\n+    : literal (literal), has_minus (has_minus), locus (locus)\n+  {}\n+\n+  ::std::string as_string () const;\n+\n+  Location get_locus () const { return locus; }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual RangePatternBoundLiteral *\n+  clone_range_pattern_bound_impl () const OVERRIDE\n+  {\n+    return new RangePatternBoundLiteral (*this);\n+  }\n+};\n+\n+// Path-based pattern bound\n+class RangePatternBoundPath : public RangePatternBound\n+{\n+  PathInExpression path;\n+\n+  // TODO: should this be refactored so that PathInExpression is a subclass of\n+  // RangePatternBound?\n+\n+public:\n+  RangePatternBoundPath (PathInExpression path) : path (::std::move (path)) {}\n+\n+  ::std::string as_string () const { return path.as_string (); }\n+\n+  Location get_locus () const { return path.get_locus (); }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual RangePatternBoundPath *\n+  clone_range_pattern_bound_impl () const OVERRIDE\n+  {\n+    return new RangePatternBoundPath (*this);\n+  }\n+};\n+\n+// Qualified path-based pattern bound\n+class RangePatternBoundQualPath : public RangePatternBound\n+{\n+  QualifiedPathInExpression path;\n+\n+  /* TODO: should this be refactored so that QualifiedPathInExpression is a\n+   * subclass of RangePatternBound? */\n+\n+public:\n+  RangePatternBoundQualPath (QualifiedPathInExpression path)\n+    : path (::std::move (path))\n+  {}\n+\n+  ::std::string as_string () const { return path.as_string (); }\n+\n+  Location get_locus () const { return path.get_locus (); }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual RangePatternBoundQualPath *\n+  clone_range_pattern_bound_impl () const OVERRIDE\n+  {\n+    return new RangePatternBoundQualPath (*this);\n+  }\n+};\n+\n+// AST node for matching within a certain range (range pattern)\n+class RangePattern : public Pattern\n+{\n+  /*RangePatternBound lower;\n+  RangePatternBound upper;*/\n+  ::std::unique_ptr<RangePatternBound> lower;\n+  ::std::unique_ptr<RangePatternBound> upper;\n+\n+  bool has_ellipsis_syntax;\n+\n+  // location only stored to avoid a dereference - lower pattern should give\n+  // correct location so maybe change in future\n+  Location locus;\n+\n+public:\n+  ::std::string as_string () const;\n+\n+  // Constructor\n+  RangePattern (::std::unique_ptr<RangePatternBound> lower,\n+\t\t::std::unique_ptr<RangePatternBound> upper, Location locus,\n+\t\tbool has_ellipsis_syntax = false)\n+    : lower (::std::move (lower)), upper (::std::move (upper)),\n+      has_ellipsis_syntax (has_ellipsis_syntax), locus (locus)\n+  {}\n+\n+  // Copy constructor with clone\n+  RangePattern (RangePattern const &other)\n+    : lower (other.lower->clone_range_pattern_bound ()),\n+      upper (other.upper->clone_range_pattern_bound ()),\n+      has_ellipsis_syntax (other.has_ellipsis_syntax), locus (other.locus)\n+  {}\n+\n+  // Destructor - define here if required\n+\n+  // Overloaded assignment operator to clone\n+  RangePattern &operator= (RangePattern const &other)\n+  {\n+    lower = other.lower->clone_range_pattern_bound ();\n+    upper = other.upper->clone_range_pattern_bound ();\n+    has_ellipsis_syntax = other.has_ellipsis_syntax;\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  RangePattern (RangePattern &&other) = default;\n+  RangePattern &operator= (RangePattern &&other) = default;\n+\n+  Location get_locus () const { return locus; }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual RangePattern *clone_pattern_impl () const OVERRIDE\n+  {\n+    return new RangePattern (*this);\n+  }\n+};\n+\n+// AST node for pattern based on dereferencing the pointers given\n+class ReferencePattern : public Pattern\n+{\n+  bool has_two_amps;\n+  bool is_mut;\n+  // Pattern* pattern;\n+  ::std::unique_ptr<Pattern> pattern;\n+\n+  Location locus;\n+\n+public:\n+  /*~ReferencePattern() {\n+      delete pattern;\n+  }*/\n+\n+  ::std::string as_string () const;\n+\n+  ReferencePattern (::std::unique_ptr<Pattern> pattern, bool is_mut_reference,\n+\t\t    bool ref_has_two_amps, Location locus)\n+    : has_two_amps (ref_has_two_amps), is_mut (is_mut_reference),\n+      pattern (::std::move (pattern)), locus (locus)\n+  {}\n+\n+  // Copy constructor requires clone\n+  ReferencePattern (ReferencePattern const &other)\n+    : has_two_amps (other.has_two_amps), is_mut (other.is_mut),\n+      pattern (other.pattern->clone_pattern ()), locus (other.locus)\n+  {}\n+\n+  // Destructor - define here if required\n+\n+  // Overload assignment operator to clone\n+  ReferencePattern &operator= (ReferencePattern const &other)\n+  {\n+    pattern = other.pattern->clone_pattern ();\n+    is_mut = other.is_mut;\n+    has_two_amps = other.has_two_amps;\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  ReferencePattern (ReferencePattern &&other) = default;\n+  ReferencePattern &operator= (ReferencePattern &&other) = default;\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual ReferencePattern *clone_pattern_impl () const OVERRIDE\n+  {\n+    return new ReferencePattern (*this);\n+  }\n+};\n+\n+// aka StructPatternEtCetera; potential element in struct pattern\n+struct StructPatternEtc\n+{\n+private:\n+  ::std::vector<Attribute> outer_attrs;\n+\n+  // should this store location data?\n+\n+public:\n+  StructPatternEtc (::std::vector<Attribute> outer_attribs)\n+    : outer_attrs (::std::move (outer_attribs))\n+  {}\n+\n+  // Creates an empty StructPatternEtc\n+  static StructPatternEtc create_empty ()\n+  {\n+    return StructPatternEtc (::std::vector<Attribute> ());\n+  }\n+};\n+\n+// Base class for a single field in a struct pattern - abstract\n+class StructPatternField\n+{\n+  ::std::vector<Attribute> outer_attrs;\n+  /*union {\n+      struct {\n+\t  //TupleIndex index;\n+\t  Pattern tuple_pattern;\n+      } tuple_pattern;\n+      struct {\n+\t  //Identifier ident;\n+\t  Pattern ident_pattern;\n+      } ident_pattern;\n+      struct {\n+\t  bool has_ref;\n+\t  bool has_mut;\n+\t  //Identifier ident;\n+      } ident;\n+  } pattern;*/\n+\n+  Location locus;\n+\n+public:\n+  virtual ~StructPatternField () {}\n+\n+  // Unique pointer custom clone function\n+  ::std::unique_ptr<StructPatternField> clone_struct_pattern_field () const\n+  {\n+    return ::std::unique_ptr<StructPatternField> (\n+      clone_struct_pattern_field_impl ());\n+  }\n+\n+  virtual ::std::string as_string () const;\n+\n+  Location get_locus () const { return locus; }\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+protected:\n+  StructPatternField (::std::vector<Attribute> outer_attribs, Location locus)\n+    : outer_attrs (::std::move (outer_attribs)), locus (locus)\n+  {}\n+\n+  // Clone function implementation as pure virtual method\n+  virtual StructPatternField *clone_struct_pattern_field_impl () const = 0;\n+};\n+\n+// Tuple pattern single field in a struct pattern\n+class StructPatternFieldTuplePat : public StructPatternField\n+{\n+  TupleIndex index;\n+  // Pattern* tuple_pattern;\n+  ::std::unique_ptr<Pattern> tuple_pattern;\n+\n+public:\n+  /*~StructPatternFieldTuplePat() {\n+      delete tuple_pattern;\n+  }*/\n+\n+  StructPatternFieldTuplePat (TupleIndex index,\n+\t\t\t      ::std::unique_ptr<Pattern> tuple_pattern,\n+\t\t\t      ::std::vector<Attribute> outer_attribs,\n+\t\t\t      Location locus)\n+    : StructPatternField (::std::move (outer_attribs), locus), index (index),\n+      tuple_pattern (::std::move (tuple_pattern))\n+  {}\n+\n+  // Copy constructor requires clone\n+  StructPatternFieldTuplePat (StructPatternFieldTuplePat const &other)\n+    : StructPatternField (other), index (other.index),\n+      tuple_pattern (other.tuple_pattern->clone_pattern ())\n+  {}\n+\n+  // Destructor - define here if required\n+\n+  // Overload assignment operator to perform clone\n+  StructPatternFieldTuplePat &\n+  operator= (StructPatternFieldTuplePat const &other)\n+  {\n+    StructPatternField::operator= (other);\n+    tuple_pattern = other.tuple_pattern->clone_pattern ();\n+    index = other.index;\n+    // outer_attrs = other.outer_attrs;\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  StructPatternFieldTuplePat (StructPatternFieldTuplePat &&other) = default;\n+  StructPatternFieldTuplePat &operator= (StructPatternFieldTuplePat &&other)\n+    = default;\n+\n+  ::std::string as_string () const;\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual StructPatternFieldTuplePat *\n+  clone_struct_pattern_field_impl () const OVERRIDE\n+  {\n+    return new StructPatternFieldTuplePat (*this);\n+  }\n+};\n+\n+// Identifier pattern single field in a struct pattern\n+class StructPatternFieldIdentPat : public StructPatternField\n+{\n+  Identifier ident;\n+  // Pattern* ident_pattern;\n+  ::std::unique_ptr<Pattern> ident_pattern;\n+\n+public:\n+  /*~StructPatternFieldIdentPat() {\n+      delete ident_pattern;\n+  }*/\n+\n+  StructPatternFieldIdentPat (Identifier ident,\n+\t\t\t      ::std::unique_ptr<Pattern> ident_pattern,\n+\t\t\t      ::std::vector<Attribute> outer_attrs,\n+\t\t\t      Location locus)\n+    : StructPatternField (::std::move (outer_attrs), locus),\n+      ident (::std::move (ident)), ident_pattern (::std::move (ident_pattern))\n+  {}\n+\n+  // Copy constructor requires clone\n+  StructPatternFieldIdentPat (StructPatternFieldIdentPat const &other)\n+    : StructPatternField (other), ident (other.ident),\n+      ident_pattern (other.ident_pattern->clone_pattern ())\n+  {}\n+\n+  // Destructor - define here if required\n+\n+  // Overload assignment operator to clone\n+  StructPatternFieldIdentPat &\n+  operator= (StructPatternFieldIdentPat const &other)\n+  {\n+    StructPatternField::operator= (other);\n+    ident = other.ident;\n+    ident_pattern = other.ident_pattern->clone_pattern ();\n+    // outer_attrs = other.outer_attrs;\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  StructPatternFieldIdentPat (StructPatternFieldIdentPat &&other) = default;\n+  StructPatternFieldIdentPat &operator= (StructPatternFieldIdentPat &&other)\n+    = default;\n+\n+  ::std::string as_string () const;\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual StructPatternFieldIdentPat *\n+  clone_struct_pattern_field_impl () const OVERRIDE\n+  {\n+    return new StructPatternFieldIdentPat (*this);\n+  }\n+};\n+\n+// Identifier only (with no pattern) single field in a struct pattern\n+class StructPatternFieldIdent : public StructPatternField\n+{\n+  bool has_ref;\n+  bool has_mut;\n+\n+  Identifier ident;\n+\n+public:\n+  StructPatternFieldIdent (Identifier ident, bool is_ref, bool is_mut,\n+\t\t\t   ::std::vector<Attribute> outer_attrs, Location locus)\n+    : StructPatternField (::std::move (outer_attrs), locus), has_ref (is_ref),\n+      has_mut (is_mut), ident (::std::move (ident))\n+  {}\n+\n+  ::std::string as_string () const;\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual StructPatternFieldIdent *\n+  clone_struct_pattern_field_impl () const OVERRIDE\n+  {\n+    return new StructPatternFieldIdent (*this);\n+  }\n+};\n+\n+// Elements of a struct pattern\n+struct StructPatternElements\n+{\n+private:\n+  // bool has_struct_pattern_fields;\n+  //::std::vector<StructPatternField> fields;\n+  ::std::vector< ::std::unique_ptr<StructPatternField> > fields;\n+\n+  bool has_struct_pattern_etc;\n+  StructPatternEtc etc;\n+\n+  // must have at least one of the two and maybe both\n+\n+  // should this store location data?\n+\n+public:\n+  // Returns whether there are any struct pattern fields\n+  inline bool has_struct_pattern_fields () const { return !fields.empty (); }\n+\n+  // Returns whether the struct pattern elements is entirely empty (no fields,\n+  // no etc).\n+  inline bool is_empty () const\n+  {\n+    return !has_struct_pattern_fields () && !has_struct_pattern_etc;\n+  }\n+\n+  // Constructor for StructPatternElements with both (potentially)\n+  StructPatternElements (\n+    ::std::vector< ::std::unique_ptr<StructPatternField> > fields,\n+    StructPatternEtc etc)\n+    : fields (::std::move (fields)), has_struct_pattern_etc (true),\n+      etc (::std::move (etc))\n+  {}\n+\n+  // Constructor for StructPatternElements with no StructPatternEtc\n+  StructPatternElements (\n+    ::std::vector< ::std::unique_ptr<StructPatternField> > fields)\n+    : fields (::std::move (fields)), has_struct_pattern_etc (false),\n+      etc (StructPatternEtc::create_empty ())\n+  {}\n+\n+  // Copy constructor with vector clone\n+  StructPatternElements (StructPatternElements const &other)\n+    : has_struct_pattern_etc (other.has_struct_pattern_etc), etc (other.etc)\n+  {\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    fields.reserve (other.fields.size ());\n+\n+    for (const auto &e : other.fields)\n+      {\n+\tfields.push_back (e->clone_struct_pattern_field ());\n+      }\n+  }\n+\n+  // Overloaded assignment operator with vector clone\n+  StructPatternElements &operator= (StructPatternElements const &other)\n+  {\n+    etc = other.etc;\n+    has_struct_pattern_etc = other.has_struct_pattern_etc;\n+\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    fields.reserve (other.fields.size ());\n+\n+    for (const auto &e : other.fields)\n+      {\n+\tfields.push_back (e->clone_struct_pattern_field ());\n+      }\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  StructPatternElements (StructPatternElements &&other) = default;\n+  StructPatternElements &operator= (StructPatternElements &&other) = default;\n+\n+  // Creates an empty StructPatternElements\n+  static StructPatternElements create_empty ()\n+  {\n+    return StructPatternElements (\n+      ::std::vector< ::std::unique_ptr<StructPatternField> > ());\n+  }\n+\n+  ::std::string as_string () const;\n+};\n+\n+// Struct pattern AST node representation\n+class StructPattern : public Pattern\n+{\n+  PathInExpression path;\n+\n+  // bool has_struct_pattern_elements;\n+  StructPatternElements elems;\n+\n+  // TODO: should this store location data? Accessor uses path location data.\n+\n+public:\n+  ::std::string as_string () const;\n+\n+  // Constructs a struct pattern from specified StructPatternElements\n+  StructPattern (PathInExpression struct_path,\n+\t\t StructPatternElements elems\n+\t\t = StructPatternElements::create_empty ())\n+    : path (::std::move (struct_path)), elems (::std::move (elems))\n+  {}\n+\n+  // TODO: constructor to construct via elements included in\n+  // StructPatternElements\n+\n+  // Returns whether struct pattern has any struct pattern elements (if not, it\n+  // is empty).\n+  inline bool has_struct_pattern_elems () const { return !elems.is_empty (); }\n+\n+  Location get_locus () const { return path.get_locus (); }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual StructPattern *clone_pattern_impl () const OVERRIDE\n+  {\n+    return new StructPattern (*this);\n+  }\n+};\n+\n+// Base abstract class for patterns used in TupleStructPattern\n+class TupleStructItems\n+{\n+public:\n+  virtual ~TupleStructItems () {}\n+\n+  // TODO: should this store location data?\n+\n+  // Unique pointer custom clone function\n+  ::std::unique_ptr<TupleStructItems> clone_tuple_struct_items () const\n+  {\n+    return ::std::unique_ptr<TupleStructItems> (\n+      clone_tuple_struct_items_impl ());\n+  }\n+\n+  virtual ::std::string as_string () const = 0;\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+protected:\n+  // pure virtual clone implementation\n+  virtual TupleStructItems *clone_tuple_struct_items_impl () const = 0;\n+};\n+\n+// Class for non-ranged tuple struct pattern patterns\n+class TupleStructItemsNoRange : public TupleStructItems\n+{\n+  //::std::vector<Pattern> patterns;\n+  ::std::vector< ::std::unique_ptr<Pattern> > patterns;\n+\n+public:\n+  TupleStructItemsNoRange (::std::vector< ::std::unique_ptr<Pattern> > patterns)\n+    : patterns (::std::move (patterns))\n+  {}\n+\n+  // Copy constructor with vector clone\n+  TupleStructItemsNoRange (TupleStructItemsNoRange const &other)\n+  {\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    patterns.reserve (other.patterns.size ());\n+\n+    for (const auto &e : other.patterns)\n+      {\n+\tpatterns.push_back (e->clone_pattern ());\n+      }\n+  }\n+\n+  // Overloaded assignment operator with vector clone\n+  TupleStructItemsNoRange &operator= (TupleStructItemsNoRange const &other)\n+  {\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    patterns.reserve (other.patterns.size ());\n+\n+    for (const auto &e : other.patterns)\n+      {\n+\tpatterns.push_back (e->clone_pattern ());\n+      }\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TupleStructItemsNoRange (TupleStructItemsNoRange &&other) = default;\n+  TupleStructItemsNoRange &operator= (TupleStructItemsNoRange &&other)\n+    = default;\n+\n+  ::std::string as_string () const;\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual TupleStructItemsNoRange *\n+  clone_tuple_struct_items_impl () const OVERRIDE\n+  {\n+    return new TupleStructItemsNoRange (*this);\n+  }\n+};\n+\n+// Class for ranged tuple struct pattern patterns\n+class TupleStructItemsRange : public TupleStructItems\n+{\n+  /*::std::vector<Pattern> lower_patterns;\n+  ::std::vector<Pattern> upper_patterns;*/\n+  ::std::vector< ::std::unique_ptr<Pattern> > lower_patterns;\n+  ::std::vector< ::std::unique_ptr<Pattern> > upper_patterns;\n+\n+public:\n+  TupleStructItemsRange (\n+    ::std::vector< ::std::unique_ptr<Pattern> > lower_patterns,\n+    ::std::vector< ::std::unique_ptr<Pattern> > upper_patterns)\n+    : lower_patterns (::std::move (lower_patterns)),\n+      upper_patterns (::std::move (upper_patterns))\n+  {}\n+\n+  // Copy constructor with vector clone\n+  TupleStructItemsRange (TupleStructItemsRange const &other)\n+  {\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    lower_patterns.reserve (other.lower_patterns.size ());\n+\n+    for (const auto &e : other.lower_patterns)\n+      {\n+\tlower_patterns.push_back (e->clone_pattern ());\n+      }\n+\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    upper_patterns.reserve (other.upper_patterns.size ());\n+\n+    for (const auto &e : other.upper_patterns)\n+      {\n+\tupper_patterns.push_back (e->clone_pattern ());\n+      }\n+  }\n+\n+  // Overloaded assignment operator to clone\n+  TupleStructItemsRange &operator= (TupleStructItemsRange const &other)\n+  {\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    lower_patterns.reserve (other.lower_patterns.size ());\n+\n+    for (const auto &e : other.lower_patterns)\n+      {\n+\tlower_patterns.push_back (e->clone_pattern ());\n+      }\n+\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    upper_patterns.reserve (other.upper_patterns.size ());\n+\n+    for (const auto &e : other.upper_patterns)\n+      {\n+\tupper_patterns.push_back (e->clone_pattern ());\n+      }\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TupleStructItemsRange (TupleStructItemsRange &&other) = default;\n+  TupleStructItemsRange &operator= (TupleStructItemsRange &&other) = default;\n+\n+  ::std::string as_string () const;\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual TupleStructItemsRange *clone_tuple_struct_items_impl () const OVERRIDE\n+  {\n+    return new TupleStructItemsRange (*this);\n+  }\n+};\n+\n+// AST node representing a tuple struct pattern\n+class TupleStructPattern : public Pattern\n+{\n+  PathInExpression path;\n+  // TupleStructItems items;\n+  ::std::unique_ptr<TupleStructItems> items;\n+\n+  // TOOD: should this store location data? current accessor uses path location\n+  // data\n+\n+public:\n+  ::std::string as_string () const;\n+\n+  TupleStructPattern (PathInExpression tuple_struct_path,\n+\t\t      ::std::unique_ptr<TupleStructItems> items)\n+    : path (::std::move (tuple_struct_path)), items (::std::move (items))\n+  {}\n+\n+  // Copy constructor required to clone\n+  TupleStructPattern (TupleStructPattern const &other)\n+    : path (other.path), items (other.items->clone_tuple_struct_items ())\n+  {}\n+\n+  // Destructor - define here if required\n+\n+  // Operator overload assignment operator to clone\n+  TupleStructPattern &operator= (TupleStructPattern const &other)\n+  {\n+    path = other.path;\n+    items = other.items->clone_tuple_struct_items ();\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TupleStructPattern (TupleStructPattern &&other) = default;\n+  TupleStructPattern &operator= (TupleStructPattern &&other) = default;\n+\n+  Location get_locus () const { return path.get_locus (); }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual TupleStructPattern *clone_pattern_impl () const OVERRIDE\n+  {\n+    return new TupleStructPattern (*this);\n+  }\n+};\n+\n+// Base abstract class representing TuplePattern patterns\n+class TuplePatternItems\n+{\n+public:\n+  virtual ~TuplePatternItems () {}\n+\n+  // TODO: should this store location data?\n+\n+  // Unique pointer custom clone function\n+  ::std::unique_ptr<TuplePatternItems> clone_tuple_pattern_items () const\n+  {\n+    return ::std::unique_ptr<TuplePatternItems> (\n+      clone_tuple_pattern_items_impl ());\n+  }\n \n-        // AST node for matching within a certain range (range pattern)\n-        class RangePattern : public Pattern {\n-            /*RangePatternBound lower;\n-            RangePatternBound upper;*/\n-            ::std::unique_ptr<RangePatternBound> lower;\n-            ::std::unique_ptr<RangePatternBound> upper;\n+  virtual ::std::string as_string () const = 0;\n \n-            bool has_ellipsis_syntax;\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n \n-            // location only stored to avoid a dereference - lower pattern should give correct\n-            // location so maybe change in future\n-            Location locus;\n-\n-          public:\n-            ::std::string as_string() const;\n+protected:\n+  // pure virtual clone implementation\n+  virtual TuplePatternItems *clone_tuple_pattern_items_impl () const = 0;\n+};\n \n-            // Constructor\n-            RangePattern(::std::unique_ptr<RangePatternBound> lower,\n-              ::std::unique_ptr<RangePatternBound> upper, Location locus,\n-              bool has_ellipsis_syntax = false) :\n-              lower(::std::move(lower)),\n-              upper(::std::move(upper)), has_ellipsis_syntax(has_ellipsis_syntax), locus(locus) {}\n-\n-            // Copy constructor with clone\n-            RangePattern(RangePattern const& other) :\n-              lower(other.lower->clone_range_pattern_bound()),\n-              upper(other.upper->clone_range_pattern_bound()),\n-              has_ellipsis_syntax(other.has_ellipsis_syntax), locus(other.locus) {}\n-\n-            // Destructor - define here if required\n-\n-            // Overloaded assignment operator to clone\n-            RangePattern& operator=(RangePattern const& other) {\n-                lower = other.lower->clone_range_pattern_bound();\n-                upper = other.upper->clone_range_pattern_bound();\n-                has_ellipsis_syntax = other.has_ellipsis_syntax;\n-                locus = other.locus;\n-\n-                return *this;\n-            }\n-\n-            // default move semantics\n-            RangePattern(RangePattern&& other) = default;\n-            RangePattern& operator=(RangePattern&& other) = default;\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual RangePattern* clone_pattern_impl() const OVERRIDE {\n-                return new RangePattern(*this);\n-            }\n-        };\n-\n-        // AST node for pattern based on dereferencing the pointers given\n-        class ReferencePattern : public Pattern {\n-            bool has_two_amps;\n-            bool is_mut;\n-            // Pattern* pattern;\n-            ::std::unique_ptr<Pattern> pattern;\n-\n-            Location locus;\n-\n-          public:\n-            /*~ReferencePattern() {\n-                delete pattern;\n-            }*/\n-\n-            ::std::string as_string() const;\n-\n-            ReferencePattern(::std::unique_ptr<Pattern> pattern, bool is_mut_reference,\n-              bool ref_has_two_amps, Location locus) :\n-              has_two_amps(ref_has_two_amps),\n-              is_mut(is_mut_reference), pattern(::std::move(pattern)), locus(locus) {}\n-\n-            // Copy constructor requires clone\n-            ReferencePattern(ReferencePattern const& other) :\n-              has_two_amps(other.has_two_amps), is_mut(other.is_mut),\n-              pattern(other.pattern->clone_pattern()), locus(other.locus) {}\n-\n-            // Destructor - define here if required\n-\n-            // Overload assignment operator to clone\n-            ReferencePattern& operator=(ReferencePattern const& other) {\n-                pattern = other.pattern->clone_pattern();\n-                is_mut = other.is_mut;\n-                has_two_amps = other.has_two_amps;\n-                locus = other.locus;\n-\n-                return *this;\n-            }\n-\n-            // default move semantics\n-            ReferencePattern(ReferencePattern&& other) = default;\n-            ReferencePattern& operator=(ReferencePattern&& other) = default;\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual ReferencePattern* clone_pattern_impl() const OVERRIDE {\n-                return new ReferencePattern(*this);\n-            }\n-        };\n-\n-        // aka StructPatternEtCetera; potential element in struct pattern\n-        struct StructPatternEtc {\n-          private:\n-            ::std::vector<Attribute> outer_attrs;\n-\n-            // should this store location data?\n-\n-          public:\n-            StructPatternEtc(::std::vector<Attribute> outer_attribs) :\n-              outer_attrs(::std::move(outer_attribs)) {}\n-\n-            // Creates an empty StructPatternEtc\n-            static StructPatternEtc create_empty() {\n-                return StructPatternEtc(::std::vector<Attribute>());\n-            }\n-        };\n-\n-        // Base class for a single field in a struct pattern - abstract\n-        class StructPatternField {\n-            ::std::vector<Attribute> outer_attrs;\n-            /*union {\n-                struct {\n-                    //TupleIndex index;\n-                    Pattern tuple_pattern;\n-                } tuple_pattern;\n-                struct {\n-                    //Identifier ident;\n-                    Pattern ident_pattern;\n-                } ident_pattern;\n-                struct {\n-                    bool has_ref;\n-                    bool has_mut;\n-                    //Identifier ident;\n-                } ident;\n-            } pattern;*/\n-\n-            Location locus;\n-\n-          public:\n-            virtual ~StructPatternField() {}\n-\n-            // Unique pointer custom clone function\n-            ::std::unique_ptr<StructPatternField> clone_struct_pattern_field() const {\n-                return ::std::unique_ptr<StructPatternField>(clone_struct_pattern_field_impl());\n-            }\n-\n-            virtual ::std::string as_string() const;\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) = 0;\n-\n-          protected:\n-            StructPatternField(::std::vector<Attribute> outer_attribs, Location locus) :\n-              outer_attrs(::std::move(outer_attribs)), locus(locus) {}\n-\n-            // Clone function implementation as pure virtual method\n-            virtual StructPatternField* clone_struct_pattern_field_impl() const = 0;\n-        };\n-\n-        // Tuple pattern single field in a struct pattern\n-        class StructPatternFieldTuplePat : public StructPatternField {\n-            TupleIndex index;\n-            // Pattern* tuple_pattern;\n-            ::std::unique_ptr<Pattern> tuple_pattern;\n-\n-          public:\n-            /*~StructPatternFieldTuplePat() {\n-                delete tuple_pattern;\n-            }*/\n-\n-            StructPatternFieldTuplePat(TupleIndex index, ::std::unique_ptr<Pattern> tuple_pattern,\n-              ::std::vector<Attribute> outer_attribs, Location locus) :\n-              StructPatternField(::std::move(outer_attribs), locus),\n-              index(index), tuple_pattern(::std::move(tuple_pattern)) {}\n-\n-            // Copy constructor requires clone\n-            StructPatternFieldTuplePat(StructPatternFieldTuplePat const& other) :\n-              StructPatternField(other), index(other.index),\n-              tuple_pattern(other.tuple_pattern->clone_pattern()) {}\n-\n-            // Destructor - define here if required\n-\n-            // Overload assignment operator to perform clone\n-            StructPatternFieldTuplePat& operator=(StructPatternFieldTuplePat const& other) {\n-                StructPatternField::operator=(other);\n-                tuple_pattern = other.tuple_pattern->clone_pattern();\n-                index = other.index;\n-                // outer_attrs = other.outer_attrs;\n-\n-                return *this;\n-            }\n-\n-            // default move semantics\n-            StructPatternFieldTuplePat(StructPatternFieldTuplePat&& other) = default;\n-            StructPatternFieldTuplePat& operator=(StructPatternFieldTuplePat&& other) = default;\n-\n-            ::std::string as_string() const;\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual StructPatternFieldTuplePat* clone_struct_pattern_field_impl() const OVERRIDE {\n-                return new StructPatternFieldTuplePat(*this);\n-            }\n-        };\n-\n-        // Identifier pattern single field in a struct pattern\n-        class StructPatternFieldIdentPat : public StructPatternField {\n-            Identifier ident;\n-            // Pattern* ident_pattern;\n-            ::std::unique_ptr<Pattern> ident_pattern;\n-\n-          public:\n-            /*~StructPatternFieldIdentPat() {\n-                delete ident_pattern;\n-            }*/\n-\n-            StructPatternFieldIdentPat(Identifier ident, ::std::unique_ptr<Pattern> ident_pattern,\n-              ::std::vector<Attribute> outer_attrs, Location locus) :\n-              StructPatternField(::std::move(outer_attrs), locus),\n-              ident(::std::move(ident)), ident_pattern(::std::move(ident_pattern)) {}\n-\n-            // Copy constructor requires clone\n-            StructPatternFieldIdentPat(StructPatternFieldIdentPat const& other) :\n-              StructPatternField(other), ident(other.ident),\n-              ident_pattern(other.ident_pattern->clone_pattern()) {}\n-\n-            // Destructor - define here if required\n-\n-            // Overload assignment operator to clone\n-            StructPatternFieldIdentPat& operator=(StructPatternFieldIdentPat const& other) {\n-                StructPatternField::operator=(other);\n-                ident = other.ident;\n-                ident_pattern = other.ident_pattern->clone_pattern();\n-                // outer_attrs = other.outer_attrs;\n-\n-                return *this;\n-            }\n-\n-            // default move semantics\n-            StructPatternFieldIdentPat(StructPatternFieldIdentPat&& other) = default;\n-            StructPatternFieldIdentPat& operator=(StructPatternFieldIdentPat&& other) = default;\n-\n-            ::std::string as_string() const;\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual StructPatternFieldIdentPat* clone_struct_pattern_field_impl() const OVERRIDE {\n-                return new StructPatternFieldIdentPat(*this);\n-            }\n-        };\n-\n-        // Identifier only (with no pattern) single field in a struct pattern\n-        class StructPatternFieldIdent : public StructPatternField {\n-            bool has_ref;\n-            bool has_mut;\n-\n-            Identifier ident;\n-\n-          public:\n-            StructPatternFieldIdent(Identifier ident, bool is_ref, bool is_mut,\n-              ::std::vector<Attribute> outer_attrs, Location locus) :\n-              StructPatternField(::std::move(outer_attrs), locus),\n-              has_ref(is_ref), has_mut(is_mut), ident(::std::move(ident)) {}\n-\n-            ::std::string as_string() const;\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual StructPatternFieldIdent* clone_struct_pattern_field_impl() const OVERRIDE {\n-                return new StructPatternFieldIdent(*this);\n-            }\n-        };\n-\n-        // Elements of a struct pattern\n-        struct StructPatternElements {\n-          private:\n-            // bool has_struct_pattern_fields;\n-            //::std::vector<StructPatternField> fields;\n-            ::std::vector< ::std::unique_ptr<StructPatternField> > fields;\n-\n-            bool has_struct_pattern_etc;\n-            StructPatternEtc etc;\n-\n-            // must have at least one of the two and maybe both\n-\n-            // should this store location data?\n-\n-          public:\n-            // Returns whether there are any struct pattern fields\n-            inline bool has_struct_pattern_fields() const {\n-                return !fields.empty();\n-            }\n-\n-            // Returns whether the struct pattern elements is entirely empty (no fields, no etc).\n-            inline bool is_empty() const {\n-                return !has_struct_pattern_fields() && !has_struct_pattern_etc;\n-            }\n-\n-            // Constructor for StructPatternElements with both (potentially)\n-            StructPatternElements(\n-              ::std::vector< ::std::unique_ptr<StructPatternField> > fields, StructPatternEtc etc) :\n-              fields(::std::move(fields)),\n-              has_struct_pattern_etc(true), etc(::std::move(etc)) {}\n-\n-            // Constructor for StructPatternElements with no StructPatternEtc\n-            StructPatternElements(::std::vector< ::std::unique_ptr<StructPatternField> > fields) :\n-              fields(::std::move(fields)), has_struct_pattern_etc(false),\n-              etc(StructPatternEtc::create_empty()) {}\n-\n-            // Copy constructor with vector clone\n-            StructPatternElements(StructPatternElements const& other) :\n-              has_struct_pattern_etc(other.has_struct_pattern_etc), etc(other.etc) {\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                fields.reserve(other.fields.size());\n-\n-                for (const auto& e : other.fields) {\n-                    fields.push_back(e->clone_struct_pattern_field());\n-                }\n-            }\n-\n-            // Overloaded assignment operator with vector clone\n-            StructPatternElements& operator=(StructPatternElements const& other) {\n-                etc = other.etc;\n-                has_struct_pattern_etc = other.has_struct_pattern_etc;\n-\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                fields.reserve(other.fields.size());\n-\n-                for (const auto& e : other.fields) {\n-                    fields.push_back(e->clone_struct_pattern_field());\n-                }\n-\n-                return *this;\n-            }\n-\n-            // move constructors\n-            StructPatternElements(StructPatternElements&& other) = default;\n-            StructPatternElements& operator=(StructPatternElements&& other) = default;\n-\n-            // Creates an empty StructPatternElements\n-            static StructPatternElements create_empty() {\n-                return StructPatternElements(\n-                  ::std::vector< ::std::unique_ptr<StructPatternField> >());\n-            }\n-\n-            ::std::string as_string() const;\n-        };\n+// Class representing TuplePattern patterns where there is only a single pattern\n+/*class TuplePatternItemsSingle : public TuplePatternItems {\n+    // Pattern pattern;\n+    ::std::unique_ptr<Pattern> pattern;\n \n-        // Struct pattern AST node representation\n-        class StructPattern : public Pattern {\n-            PathInExpression path;\n-\n-            // bool has_struct_pattern_elements;\n-            StructPatternElements elems;\n-\n-            // TODO: should this store location data? Accessor uses path location data.\n-\n-          public:\n-            ::std::string as_string() const;\n-\n-            // Constructs a struct pattern from specified StructPatternElements\n-            StructPattern(PathInExpression struct_path,\n-              StructPatternElements elems = StructPatternElements::create_empty()) :\n-              path(::std::move(struct_path)),\n-              elems(::std::move(elems)) {}\n-\n-            // TODO: constructor to construct via elements included in StructPatternElements\n-\n-            // Returns whether struct pattern has any struct pattern elements (if not, it is empty).\n-            inline bool has_struct_pattern_elems() const {\n-                return !elems.is_empty();\n-            }\n-\n-            Location get_locus() const {\n-                return path.get_locus();\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual StructPattern* clone_pattern_impl() const OVERRIDE {\n-                return new StructPattern(*this);\n-            }\n-        };\n-\n-        // Base abstract class for patterns used in TupleStructPattern\n-        class TupleStructItems {\n-          public:\n-            virtual ~TupleStructItems() {}\n-\n-            // TODO: should this store location data?\n-\n-            // Unique pointer custom clone function\n-            ::std::unique_ptr<TupleStructItems> clone_tuple_struct_items() const {\n-                return ::std::unique_ptr<TupleStructItems>(clone_tuple_struct_items_impl());\n-            }\n-\n-            virtual ::std::string as_string() const = 0;\n-\n-            virtual void accept_vis(ASTVisitor& vis) = 0;\n-\n-          protected:\n-            // pure virtual clone implementation\n-            virtual TupleStructItems* clone_tuple_struct_items_impl() const = 0;\n-        };\n-\n-        // Class for non-ranged tuple struct pattern patterns\n-        class TupleStructItemsNoRange : public TupleStructItems {\n-            //::std::vector<Pattern> patterns;\n-            ::std::vector< ::std::unique_ptr<Pattern> > patterns;\n+  public:\n+    TuplePatternItemsSingle(Pattern* pattern) : pattern(pattern) {}\n \n-          public:\n-            TupleStructItemsNoRange(::std::vector< ::std::unique_ptr<Pattern> > patterns) :\n-              patterns(::std::move(patterns)) {}\n-\n-            // Copy constructor with vector clone\n-            TupleStructItemsNoRange(TupleStructItemsNoRange const& other) {\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                patterns.reserve(other.patterns.size());\n-\n-                for (const auto& e : other.patterns) {\n-                    patterns.push_back(e->clone_pattern());\n-                }\n-            }\n+    // Copy constructor uses clone\n+    TuplePatternItemsSingle(TuplePatternItemsSingle const& other) :\n+      pattern(other.pattern->clone_pattern()) {}\n \n-            // Overloaded assignment operator with vector clone\n-            TupleStructItemsNoRange& operator=(TupleStructItemsNoRange const& other) {\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                patterns.reserve(other.patterns.size());\n+    // Destructor - define here if required\n \n-                for (const auto& e : other.patterns) {\n-                    patterns.push_back(e->clone_pattern());\n-                }\n-\n-                return *this;\n-            }\n-\n-            // move constructors\n-            TupleStructItemsNoRange(TupleStructItemsNoRange&& other) = default;\n-            TupleStructItemsNoRange& operator=(TupleStructItemsNoRange&& other) = default;\n-\n-            ::std::string as_string() const;\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual TupleStructItemsNoRange* clone_tuple_struct_items_impl() const OVERRIDE {\n-                return new TupleStructItemsNoRange(*this);\n-            }\n-        };\n-\n-        // Class for ranged tuple struct pattern patterns\n-        class TupleStructItemsRange : public TupleStructItems {\n-            /*::std::vector<Pattern> lower_patterns;\n-            ::std::vector<Pattern> upper_patterns;*/\n-            ::std::vector< ::std::unique_ptr<Pattern> > lower_patterns;\n-            ::std::vector< ::std::unique_ptr<Pattern> > upper_patterns;\n-\n-          public:\n-            TupleStructItemsRange(::std::vector< ::std::unique_ptr<Pattern> > lower_patterns,\n-              ::std::vector< ::std::unique_ptr<Pattern> > upper_patterns) :\n-              lower_patterns(::std::move(lower_patterns)),\n-              upper_patterns(::std::move(upper_patterns)) {}\n-\n-            // Copy constructor with vector clone\n-            TupleStructItemsRange(TupleStructItemsRange const& other) {\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                lower_patterns.reserve(other.lower_patterns.size());\n-\n-                for (const auto& e : other.lower_patterns) {\n-                    lower_patterns.push_back(e->clone_pattern());\n-                }\n-\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                upper_patterns.reserve(other.upper_patterns.size());\n-\n-                for (const auto& e : other.upper_patterns) {\n-                    upper_patterns.push_back(e->clone_pattern());\n-                }\n-            }\n-\n-            // Overloaded assignment operator to clone\n-            TupleStructItemsRange& operator=(TupleStructItemsRange const& other) {\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                lower_patterns.reserve(other.lower_patterns.size());\n-\n-                for (const auto& e : other.lower_patterns) {\n-                    lower_patterns.push_back(e->clone_pattern());\n-                }\n-\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                upper_patterns.reserve(other.upper_patterns.size());\n-\n-                for (const auto& e : other.upper_patterns) {\n-                    upper_patterns.push_back(e->clone_pattern());\n-                }\n-\n-                return *this;\n-            }\n-\n-            // move constructors\n-            TupleStructItemsRange(TupleStructItemsRange&& other) = default;\n-            TupleStructItemsRange& operator=(TupleStructItemsRange&& other) = default;\n-\n-            ::std::string as_string() const;\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual TupleStructItemsRange* clone_tuple_struct_items_impl() const OVERRIDE {\n-                return new TupleStructItemsRange(*this);\n-            }\n-        };\n-\n-        // AST node representing a tuple struct pattern\n-        class TupleStructPattern : public Pattern {\n-            PathInExpression path;\n-            // TupleStructItems items;\n-            ::std::unique_ptr<TupleStructItems> items;\n-\n-            // TOOD: should this store location data? current accessor uses path location data\n-\n-          public:\n-            ::std::string as_string() const;\n-\n-            TupleStructPattern(\n-              PathInExpression tuple_struct_path, ::std::unique_ptr<TupleStructItems> items) :\n-              path(::std::move(tuple_struct_path)),\n-              items(::std::move(items)) {}\n-\n-            // Copy constructor required to clone\n-            TupleStructPattern(TupleStructPattern const& other) :\n-              path(other.path), items(other.items->clone_tuple_struct_items()) {}\n-\n-            // Destructor - define here if required\n-\n-            // Operator overload assignment operator to clone\n-            TupleStructPattern& operator=(TupleStructPattern const& other) {\n-                path = other.path;\n-                items = other.items->clone_tuple_struct_items();\n-\n-                return *this;\n-            }\n-\n-            // move constructors\n-            TupleStructPattern(TupleStructPattern&& other) = default;\n-            TupleStructPattern& operator=(TupleStructPattern&& other) = default;\n-\n-            Location get_locus() const {\n-                return path.get_locus();\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual TupleStructPattern* clone_pattern_impl() const OVERRIDE {\n-                return new TupleStructPattern(*this);\n-            }\n-        };\n-\n-        // Base abstract class representing TuplePattern patterns\n-        class TuplePatternItems {\n-          public:\n-            virtual ~TuplePatternItems() {}\n-\n-            // TODO: should this store location data?\n-\n-            // Unique pointer custom clone function\n-            ::std::unique_ptr<TuplePatternItems> clone_tuple_pattern_items() const {\n-                return ::std::unique_ptr<TuplePatternItems>(clone_tuple_pattern_items_impl());\n-            }\n-\n-            virtual ::std::string as_string() const = 0;\n-\n-            virtual void accept_vis(ASTVisitor& vis) = 0;\n-\n-          protected:\n-            // pure virtual clone implementation\n-            virtual TuplePatternItems* clone_tuple_pattern_items_impl() const = 0;\n-        };\n-\n-        // Class representing TuplePattern patterns where there is only a single pattern\n-        /*class TuplePatternItemsSingle : public TuplePatternItems {\n-            // Pattern pattern;\n-            ::std::unique_ptr<Pattern> pattern;\n-\n-          public:\n-            TuplePatternItemsSingle(Pattern* pattern) : pattern(pattern) {}\n-\n-            // Copy constructor uses clone\n-            TuplePatternItemsSingle(TuplePatternItemsSingle const& other) :\n-              pattern(other.pattern->clone_pattern()) {}\n-\n-            // Destructor - define here if required\n-\n-            // Overload assignment operator to clone\n-            TuplePatternItemsSingle& operator=(TuplePatternItemsSingle const& other) {\n-                pattern = other.pattern->clone_pattern();\n-\n-                return *this;\n-            }\n-\n-            // move constructors\n-            TuplePatternItemsSingle(TuplePatternItemsSingle&& other) = default;\n-            TuplePatternItemsSingle& operator=(TuplePatternItemsSingle&& other) = default;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual TuplePatternItemsSingle* clone_tuple_pattern_items_impl() const OVERRIDE {\n-                return new TuplePatternItemsSingle(*this);\n-            }\n-        };*/\n-        // removed in favour of single-element TuplePatternItemsMultiple\n-\n-        // Class representing TuplePattern patterns where there are multiple patterns\n-        class TuplePatternItemsMultiple : public TuplePatternItems {\n-            //::std::vector<Pattern> patterns;\n-            ::std::vector< ::std::unique_ptr<Pattern> > patterns;\n-\n-          public:\n-            TuplePatternItemsMultiple(::std::vector< ::std::unique_ptr<Pattern> > patterns) :\n-              patterns(::std::move(patterns)) {}\n-\n-            // Copy constructor with vector clone\n-            TuplePatternItemsMultiple(TuplePatternItemsMultiple const& other) {\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                patterns.reserve(other.patterns.size());\n-\n-                for (const auto& e : other.patterns) {\n-                    patterns.push_back(e->clone_pattern());\n-                }\n-            }\n-\n-            // Overloaded assignment operator to vector clone\n-            TuplePatternItemsMultiple& operator=(TuplePatternItemsMultiple const& other) {\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                patterns.reserve(other.patterns.size());\n-\n-                for (const auto& e : other.patterns) {\n-                    patterns.push_back(e->clone_pattern());\n-                }\n-\n-                return *this;\n-            }\n-\n-            // move constructors\n-            TuplePatternItemsMultiple(TuplePatternItemsMultiple&& other) = default;\n-            TuplePatternItemsMultiple& operator=(TuplePatternItemsMultiple&& other) = default;\n-\n-            ::std::string as_string() const;\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual TuplePatternItemsMultiple* clone_tuple_pattern_items_impl() const OVERRIDE {\n-                return new TuplePatternItemsMultiple(*this);\n-            }\n-        };\n-\n-        // Class representing TuplePattern patterns where there are a range of patterns\n-        class TuplePatternItemsRanged : public TuplePatternItems {\n-            /*::std::vector<Pattern> lower_patterns;\n-            ::std::vector<Pattern> upper_patterns;*/\n-            ::std::vector< ::std::unique_ptr<Pattern> > lower_patterns;\n-            ::std::vector< ::std::unique_ptr<Pattern> > upper_patterns;\n-\n-          public:\n-            TuplePatternItemsRanged(::std::vector< ::std::unique_ptr<Pattern> > lower_patterns,\n-              ::std::vector< ::std::unique_ptr<Pattern> > upper_patterns) :\n-              lower_patterns(::std::move(lower_patterns)),\n-              upper_patterns(::std::move(upper_patterns)) {}\n-\n-            // Copy constructor with vector clone\n-            TuplePatternItemsRanged(TuplePatternItemsRanged const& other) {\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                lower_patterns.reserve(other.lower_patterns.size());\n-\n-                for (const auto& e : other.lower_patterns) {\n-                    lower_patterns.push_back(e->clone_pattern());\n-                }\n-\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                upper_patterns.reserve(other.upper_patterns.size());\n-\n-                for (const auto& e : other.upper_patterns) {\n-                    upper_patterns.push_back(e->clone_pattern());\n-                }\n-            }\n-\n-            // Overloaded assignment operator to clone\n-            TuplePatternItemsRanged& operator=(TuplePatternItemsRanged const& other) {\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                lower_patterns.reserve(other.lower_patterns.size());\n-\n-                for (const auto& e : other.lower_patterns) {\n-                    lower_patterns.push_back(e->clone_pattern());\n-                }\n-\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                upper_patterns.reserve(other.upper_patterns.size());\n-\n-                for (const auto& e : other.upper_patterns) {\n-                    upper_patterns.push_back(e->clone_pattern());\n-                }\n-\n-                return *this;\n-            }\n-\n-            // move constructors\n-            TuplePatternItemsRanged(TuplePatternItemsRanged&& other) = default;\n-            TuplePatternItemsRanged& operator=(TuplePatternItemsRanged&& other) = default;\n-\n-            ::std::string as_string() const;\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual TuplePatternItemsRanged* clone_tuple_pattern_items_impl() const OVERRIDE {\n-                return new TuplePatternItemsRanged(*this);\n-            }\n-        };\n-\n-        // AST node representing a tuple pattern\n-        class TuplePattern : public Pattern {\n-            // bool has_tuple_pattern_items;\n-            // TuplePatternItems items;\n-            ::std::unique_ptr<TuplePatternItems> items;\n-\n-            Location locus;\n-\n-          public:\n-            ::std::string as_string() const;\n-\n-            // Returns true if the tuple pattern has items\n-            inline bool has_tuple_pattern_items() const {\n-                return items != NULL;\n-            }\n-\n-            TuplePattern(::std::unique_ptr<TuplePatternItems> items, Location locus) :\n-              items(::std::move(items)), locus(locus) {}\n-\n-            // Copy constructor requires clone\n-            TuplePattern(TuplePattern const& other) :\n-              items(other.items->clone_tuple_pattern_items()), locus(other.locus) {}\n-\n-            // Destructor - define here if required\n-\n-            // Overload assignment operator to clone\n-            TuplePattern& operator=(TuplePattern const& other) {\n-                items = other.items->clone_tuple_pattern_items();\n-                locus = other.locus;\n-\n-                return *this;\n-            }\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual TuplePattern* clone_pattern_impl() const OVERRIDE {\n-                return new TuplePattern(*this);\n-            }\n-        };\n-\n-        // AST node representing a pattern in parentheses, used to control precedence\n-        class GroupedPattern : public Pattern {\n-            // Pattern pattern_in_parens;\n-            ::std::unique_ptr<Pattern> pattern_in_parens;\n-\n-            Location locus;\n-\n-          public:\n-            ::std::string as_string() const {\n-                return \"(\" + pattern_in_parens->as_string() + \")\";\n-            }\n-\n-            GroupedPattern(::std::unique_ptr<Pattern> pattern_in_parens, Location locus) :\n-              pattern_in_parens(::std::move(pattern_in_parens)), locus(locus) {}\n-\n-            // Copy constructor uses clone\n-            GroupedPattern(GroupedPattern const& other) :\n-              pattern_in_parens(other.pattern_in_parens->clone_pattern()), locus(other.locus) {}\n-\n-            // Destructor - define here if required\n-\n-            // Overload assignment operator to clone\n-            GroupedPattern& operator=(GroupedPattern const& other) {\n-                pattern_in_parens = other.pattern_in_parens->clone_pattern();\n-                locus = other.locus;\n-\n-                return *this;\n-            }\n-\n-            // default move semantics\n-            GroupedPattern(GroupedPattern&& other) = default;\n-            GroupedPattern& operator=(GroupedPattern&& other) = default;\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual GroupedPattern* clone_pattern_impl() const OVERRIDE {\n-                return new GroupedPattern(*this);\n-            }\n-        };\n-\n-        // AST node representing patterns that can match slices and arrays\n-        class SlicePattern : public Pattern {\n-            //::std::vector<Pattern> items;\n-            ::std::vector< ::std::unique_ptr<Pattern> > items;\n-\n-            Location locus;\n-\n-          public:\n-            ::std::string as_string() const;\n-\n-            SlicePattern(::std::vector< ::std::unique_ptr<Pattern> > items, Location locus) :\n-              items(::std::move(items)), locus(locus) {}\n-\n-            // Copy constructor with vector clone\n-            SlicePattern(SlicePattern const& other) : locus(other.locus) {\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                items.reserve(other.items.size());\n-\n-                for (const auto& e : other.items) {\n-                    items.push_back(e->clone_pattern());\n-                }\n-            }\n-\n-            // Overloaded assignment operator to vector clone\n-            SlicePattern& operator=(SlicePattern const& other) {\n-                locus = other.locus;\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                items.reserve(other.items.size());\n-\n-                for (const auto& e : other.items) {\n-                    items.push_back(e->clone_pattern());\n-                }\n-\n-                return *this;\n-            }\n-\n-            // move constructors\n-            SlicePattern(SlicePattern&& other) = default;\n-            SlicePattern& operator=(SlicePattern&& other) = default;\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual SlicePattern* clone_pattern_impl() const OVERRIDE {\n-                return new SlicePattern(*this);\n-            }\n-        };\n-\n-        // forward decl PathExprSegment\n-        // class PathExprSegment;\n-\n-        // Moved definition to rust-path.h\n-        class PathPattern;\n+    // Overload assignment operator to clone\n+    TuplePatternItemsSingle& operator=(TuplePatternItemsSingle const& other) {\n+\tpattern = other.pattern->clone_pattern();\n+\n+\treturn *this;\n+    }\n \n-        // Forward decls for paths (defined in rust-path.h)\n-        class PathInExpression;\n-        class QualifiedPathInExpression;\n+    // move constructors\n+    TuplePatternItemsSingle(TuplePatternItemsSingle&& other) = default;\n+    TuplePatternItemsSingle& operator=(TuplePatternItemsSingle&& other) =\n+default;\n \n-        // Replaced with forward decl - defined in rust-macro.h\n-        class MacroInvocation;\n-        /*class MacroInvocation : public Pattern {\n-          public:\n-            ::std::string as_string() const;\n-        };*/\n+  protected:\n+    // Use covariance to implement clone function as returning this object\n+rather than base virtual TuplePatternItemsSingle*\n+clone_tuple_pattern_items_impl() const OVERRIDE { return new\n+TuplePatternItemsSingle(*this);\n     }\n-}\n+};*/\n+// removed in favour of single-element TuplePatternItemsMultiple\n+\n+// Class representing TuplePattern patterns where there are multiple patterns\n+class TuplePatternItemsMultiple : public TuplePatternItems\n+{\n+  //::std::vector<Pattern> patterns;\n+  ::std::vector< ::std::unique_ptr<Pattern> > patterns;\n+\n+public:\n+  TuplePatternItemsMultiple (\n+    ::std::vector< ::std::unique_ptr<Pattern> > patterns)\n+    : patterns (::std::move (patterns))\n+  {}\n+\n+  // Copy constructor with vector clone\n+  TuplePatternItemsMultiple (TuplePatternItemsMultiple const &other)\n+  {\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    patterns.reserve (other.patterns.size ());\n+\n+    for (const auto &e : other.patterns)\n+      {\n+\tpatterns.push_back (e->clone_pattern ());\n+      }\n+  }\n+\n+  // Overloaded assignment operator to vector clone\n+  TuplePatternItemsMultiple &operator= (TuplePatternItemsMultiple const &other)\n+  {\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    patterns.reserve (other.patterns.size ());\n+\n+    for (const auto &e : other.patterns)\n+      {\n+\tpatterns.push_back (e->clone_pattern ());\n+      }\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TuplePatternItemsMultiple (TuplePatternItemsMultiple &&other) = default;\n+  TuplePatternItemsMultiple &operator= (TuplePatternItemsMultiple &&other)\n+    = default;\n+\n+  ::std::string as_string () const;\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual TuplePatternItemsMultiple *\n+  clone_tuple_pattern_items_impl () const OVERRIDE\n+  {\n+    return new TuplePatternItemsMultiple (*this);\n+  }\n+};\n+\n+// Class representing TuplePattern patterns where there are a range of patterns\n+class TuplePatternItemsRanged : public TuplePatternItems\n+{\n+  /*::std::vector<Pattern> lower_patterns;\n+  ::std::vector<Pattern> upper_patterns;*/\n+  ::std::vector< ::std::unique_ptr<Pattern> > lower_patterns;\n+  ::std::vector< ::std::unique_ptr<Pattern> > upper_patterns;\n+\n+public:\n+  TuplePatternItemsRanged (\n+    ::std::vector< ::std::unique_ptr<Pattern> > lower_patterns,\n+    ::std::vector< ::std::unique_ptr<Pattern> > upper_patterns)\n+    : lower_patterns (::std::move (lower_patterns)),\n+      upper_patterns (::std::move (upper_patterns))\n+  {}\n+\n+  // Copy constructor with vector clone\n+  TuplePatternItemsRanged (TuplePatternItemsRanged const &other)\n+  {\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    lower_patterns.reserve (other.lower_patterns.size ());\n+\n+    for (const auto &e : other.lower_patterns)\n+      {\n+\tlower_patterns.push_back (e->clone_pattern ());\n+      }\n+\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    upper_patterns.reserve (other.upper_patterns.size ());\n+\n+    for (const auto &e : other.upper_patterns)\n+      {\n+\tupper_patterns.push_back (e->clone_pattern ());\n+      }\n+  }\n+\n+  // Overloaded assignment operator to clone\n+  TuplePatternItemsRanged &operator= (TuplePatternItemsRanged const &other)\n+  {\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    lower_patterns.reserve (other.lower_patterns.size ());\n+\n+    for (const auto &e : other.lower_patterns)\n+      {\n+\tlower_patterns.push_back (e->clone_pattern ());\n+      }\n+\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    upper_patterns.reserve (other.upper_patterns.size ());\n+\n+    for (const auto &e : other.upper_patterns)\n+      {\n+\tupper_patterns.push_back (e->clone_pattern ());\n+      }\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TuplePatternItemsRanged (TuplePatternItemsRanged &&other) = default;\n+  TuplePatternItemsRanged &operator= (TuplePatternItemsRanged &&other)\n+    = default;\n+\n+  ::std::string as_string () const;\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual TuplePatternItemsRanged *\n+  clone_tuple_pattern_items_impl () const OVERRIDE\n+  {\n+    return new TuplePatternItemsRanged (*this);\n+  }\n+};\n+\n+// AST node representing a tuple pattern\n+class TuplePattern : public Pattern\n+{\n+  // bool has_tuple_pattern_items;\n+  // TuplePatternItems items;\n+  ::std::unique_ptr<TuplePatternItems> items;\n+\n+  Location locus;\n+\n+public:\n+  ::std::string as_string () const;\n+\n+  // Returns true if the tuple pattern has items\n+  inline bool has_tuple_pattern_items () const { return items != NULL; }\n+\n+  TuplePattern (::std::unique_ptr<TuplePatternItems> items, Location locus)\n+    : items (::std::move (items)), locus (locus)\n+  {}\n+\n+  // Copy constructor requires clone\n+  TuplePattern (TuplePattern const &other)\n+    : items (other.items->clone_tuple_pattern_items ()), locus (other.locus)\n+  {}\n+\n+  // Destructor - define here if required\n+\n+  // Overload assignment operator to clone\n+  TuplePattern &operator= (TuplePattern const &other)\n+  {\n+    items = other.items->clone_tuple_pattern_items ();\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  Location get_locus () const { return locus; }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual TuplePattern *clone_pattern_impl () const OVERRIDE\n+  {\n+    return new TuplePattern (*this);\n+  }\n+};\n+\n+// AST node representing a pattern in parentheses, used to control precedence\n+class GroupedPattern : public Pattern\n+{\n+  // Pattern pattern_in_parens;\n+  ::std::unique_ptr<Pattern> pattern_in_parens;\n+\n+  Location locus;\n+\n+public:\n+  ::std::string as_string () const\n+  {\n+    return \"(\" + pattern_in_parens->as_string () + \")\";\n+  }\n+\n+  GroupedPattern (::std::unique_ptr<Pattern> pattern_in_parens, Location locus)\n+    : pattern_in_parens (::std::move (pattern_in_parens)), locus (locus)\n+  {}\n+\n+  // Copy constructor uses clone\n+  GroupedPattern (GroupedPattern const &other)\n+    : pattern_in_parens (other.pattern_in_parens->clone_pattern ()),\n+      locus (other.locus)\n+  {}\n+\n+  // Destructor - define here if required\n+\n+  // Overload assignment operator to clone\n+  GroupedPattern &operator= (GroupedPattern const &other)\n+  {\n+    pattern_in_parens = other.pattern_in_parens->clone_pattern ();\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  GroupedPattern (GroupedPattern &&other) = default;\n+  GroupedPattern &operator= (GroupedPattern &&other) = default;\n+\n+  Location get_locus () const { return locus; }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual GroupedPattern *clone_pattern_impl () const OVERRIDE\n+  {\n+    return new GroupedPattern (*this);\n+  }\n+};\n+\n+// AST node representing patterns that can match slices and arrays\n+class SlicePattern : public Pattern\n+{\n+  //::std::vector<Pattern> items;\n+  ::std::vector< ::std::unique_ptr<Pattern> > items;\n+\n+  Location locus;\n+\n+public:\n+  ::std::string as_string () const;\n+\n+  SlicePattern (::std::vector< ::std::unique_ptr<Pattern> > items,\n+\t\tLocation locus)\n+    : items (::std::move (items)), locus (locus)\n+  {}\n+\n+  // Copy constructor with vector clone\n+  SlicePattern (SlicePattern const &other) : locus (other.locus)\n+  {\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    items.reserve (other.items.size ());\n+\n+    for (const auto &e : other.items)\n+      {\n+\titems.push_back (e->clone_pattern ());\n+      }\n+  }\n+\n+  // Overloaded assignment operator to vector clone\n+  SlicePattern &operator= (SlicePattern const &other)\n+  {\n+    locus = other.locus;\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    items.reserve (other.items.size ());\n+\n+    for (const auto &e : other.items)\n+      {\n+\titems.push_back (e->clone_pattern ());\n+      }\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  SlicePattern (SlicePattern &&other) = default;\n+  SlicePattern &operator= (SlicePattern &&other) = default;\n+\n+  Location get_locus () const { return locus; }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual SlicePattern *clone_pattern_impl () const OVERRIDE\n+  {\n+    return new SlicePattern (*this);\n+  }\n+};\n+\n+// forward decl PathExprSegment\n+// class PathExprSegment;\n+\n+// Moved definition to rust-path.h\n+class PathPattern;\n+\n+// Forward decls for paths (defined in rust-path.h)\n+class PathInExpression;\n+class QualifiedPathInExpression;\n+\n+// Replaced with forward decl - defined in rust-macro.h\n+class MacroInvocation;\n+/*class MacroInvocation : public Pattern {\n+  public:\n+    ::std::string as_string() const;\n+};*/\n+} // namespace AST\n+} // namespace Rust\n \n #endif"}, {"sha": "08d5ff851596d9a8d3df3e72f5245c259336f2ce", "filename": "gcc/rust/ast/rust-stmt.h", "status": "modified", "additions": 249, "deletions": 235, "changes": 484, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Fast%2Frust-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Fast%2Frust-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-stmt.h?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -6,240 +6,254 @@\n #include \"rust-expr.h\"\n \n namespace Rust {\n-    namespace AST {\n-        // Just a semi-colon, which apparently is a statement.\n-        class EmptyStmt : public Stmt {\n-            Location locus;\n-\n-          public:\n-            ::std::string as_string() const {\n-                return ::std::string(1, ';');\n-            }\n-\n-            EmptyStmt(Location locus) : locus(locus) {}\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual EmptyStmt* clone_stmt_impl() const OVERRIDE {\n-                return new EmptyStmt(*this);\n-            }\n-        };\n-\n-        /* This is syntactically identical to declaring an item inside a module BUT it has block\n-         * scope. Type of \"declaration statement\" as it introduces new name into scope */\n-        /*class ItemStatement : public Statement {\n-            // TODO: put in same params as regular item\n-            // maybe even merge data structure with module item?\n-\n-          public:\n-            ::std::string as_string() const;\n-        };*/\n-        // removed - just made item inherit from statement\n-\n-        /* Variable assignment let statement - type of \"declaration statement\" as it introduces new\n-         * name into scope */\n-        class LetStmt : public Stmt {\n-            // bool has_outer_attrs;\n-            ::std::vector<Attribute> outer_attrs;\n-\n-            // Pattern variables_pattern;\n-            ::std::unique_ptr<Pattern> variables_pattern;\n-\n-            // bool has_type;\n-            // Type type;\n-            ::std::unique_ptr<Type> type;\n-\n-            // bool has_init_expr;\n-            // Expr* init_expr;\n-            ::std::unique_ptr<Expr> init_expr;\n-\n-            Location locus;\n-\n-          public:\n-            // Returns whether let statement has outer attributes.\n-            inline bool has_outer_attrs() const {\n-                return !outer_attrs.empty();\n-            }\n-\n-            // Returns whether let statement has a given return type.\n-            inline bool has_type() const {\n-                return type != NULL;\n-            }\n-\n-            // Returns whether let statement has an initialisation expression.\n-            inline bool has_init_expr() const {\n-                return init_expr != NULL;\n-            }\n-\n-            /*~LetStatement() {\n-                if (has_init_expr) {\n-                    delete init_expr;\n-                }\n-            }*/\n-\n-            ::std::string as_string() const;\n-\n-            LetStmt(::std::unique_ptr<Pattern> variables_pattern, ::std::unique_ptr<Expr> init_expr,\n-              ::std::unique_ptr<Type> type, ::std::vector<Attribute> outer_attrs, Location locus) :\n-              outer_attrs(::std::move(outer_attrs)),\n-              variables_pattern(::std::move(variables_pattern)), type(::std::move(type)),\n-              init_expr(::std::move(init_expr)), locus(locus) {}\n-\n-            // Copy constructor with clone\n-            LetStmt(LetStmt const& other) :\n-              outer_attrs(other.outer_attrs),\n-              variables_pattern(other.variables_pattern->clone_pattern()),\n-              type(other.type->clone_type()), init_expr(other.init_expr->clone_expr()),\n-              locus(other.locus) {}\n-\n-            // Destructor - define here if required\n-\n-            // Overloaded assignment operator to clone\n-            LetStmt& operator=(LetStmt const& other) {\n-                variables_pattern = other.variables_pattern->clone_pattern();\n-                init_expr = other.init_expr->clone_expr();\n-                type = other.type->clone_type();\n-                outer_attrs = other.outer_attrs;\n-                locus = other.locus;\n-\n-                return *this;\n-            }\n-\n-            // move constructors\n-            LetStmt(LetStmt&& other) = default;\n-            LetStmt& operator=(LetStmt&& other) = default;\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual LetStmt* clone_stmt_impl() const OVERRIDE {\n-                return new LetStmt(*this);\n-            }\n-        };\n-\n-        // Abstract base class for expression statements (statements containing an expression)\n-        class ExprStmt : public Stmt {\n-            // TODO: add any useful virtual functions\n-\n-            Location locus;\n-\n-          public:\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-          protected:\n-            ExprStmt(Location locus) : locus(locus) {}\n-        };\n-\n-        /* Statement containing an expression without a block (or, due to technical difficulties, can\n-         * only be guaranteed to hold an expression). */\n-        class ExprStmtWithoutBlock : public ExprStmt {\n-            // ExprWithoutBlock* expr;\n-            /* HACK: cannot ensure type safety of ExprWithoutBlock due to Pratt parsing, so have to\n-             * store more general type of Expr. FIXME: fix this issue somehow or redesign AST. */\n-            //::std::unique_ptr<ExprWithoutBlock> expr;\n-            ::std::unique_ptr<Expr> expr;\n-\n-          public:\n-            /*~ExpressionStatementWithoutBlock() {\n-                delete expr;\n-            }*/\n-\n-            ::std::string as_string() const;\n-\n-            // ExprStmtWithoutBlock(::std::unique_ptr<ExprWithoutBlock> expr) :\n-            // expr(::std::move(expr)) {}\n-            ExprStmtWithoutBlock(::std::unique_ptr<Expr> expr, Location locus) :\n-              ExprStmt(locus), expr(::std::move(expr)) {}\n-\n-            // Copy constructor with clone\n-            ExprStmtWithoutBlock(ExprStmtWithoutBlock const& other) :\n-              ExprStmt(other), expr(other.expr->clone_expr /*_without_block*/ ()) {}\n-\n-            // Destructor - define here if required\n-\n-            // Overloaded assignment operator to clone\n-            ExprStmtWithoutBlock& operator=(ExprStmtWithoutBlock const& other) {\n-                ExprStmt::operator=(other);\n-                expr = other.expr->clone_expr /*_without_block*/ ();\n-\n-                return *this;\n-            }\n-\n-            // move constructors\n-            ExprStmtWithoutBlock(ExprStmtWithoutBlock&& other) = default;\n-            ExprStmtWithoutBlock& operator=(ExprStmtWithoutBlock&& other) = default;\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual ExprStmtWithoutBlock* clone_stmt_impl() const OVERRIDE {\n-                return new ExprStmtWithoutBlock(*this);\n-            }\n-        };\n-\n-        // Statement containing an expression with a block\n-        class ExprStmtWithBlock : public ExprStmt {\n-            // ExprWithBlock* expr;\n-            ::std::unique_ptr<ExprWithBlock> expr;\n-\n-          public:\n-            /*~ExpressionStatementWithBlock() {\n-                delete expr;\n-            }*/\n-\n-            ::std::string as_string() const;\n-\n-            ExprStmtWithBlock(::std::unique_ptr<ExprWithBlock> expr, Location locus) :\n-              ExprStmt(locus), expr(::std::move(expr)) {}\n-\n-            // Copy constructor with clone\n-            ExprStmtWithBlock(ExprStmtWithBlock const& other) :\n-              ExprStmt(other), expr(other.expr->clone_expr_with_block()) {}\n-\n-            // Destructor - define here if required\n-\n-            // Overloaded assignment operator to clone\n-            ExprStmtWithBlock& operator=(ExprStmtWithBlock const& other) {\n-                ExprStmt::operator=(other);\n-                expr = other.expr->clone_expr_with_block();\n-\n-                return *this;\n-            }\n-\n-            // move constructors\n-            ExprStmtWithBlock(ExprStmtWithBlock&& other) = default;\n-            ExprStmtWithBlock& operator=(ExprStmtWithBlock&& other) = default;\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual ExprStmtWithBlock* clone_stmt_impl() const OVERRIDE {\n-                return new ExprStmtWithBlock(*this);\n-            }\n-        };\n-\n-        // Replaced definition of MacroInvocationSemi with forward decl - defined in rust-macro.h\n-        class MacroInvocationSemi;\n-        /*class MacroInvocationSemi : public Statement {\n-          public:\n-            ::std::string as_string() const;\n-        };*/\n-    }\n-}\n+namespace AST {\n+// Just a semi-colon, which apparently is a statement.\n+class EmptyStmt : public Stmt\n+{\n+  Location locus;\n+\n+public:\n+  ::std::string as_string () const { return ::std::string (1, ';'); }\n+\n+  EmptyStmt (Location locus) : locus (locus) {}\n+\n+  Location get_locus () const { return locus; }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual EmptyStmt *clone_stmt_impl () const OVERRIDE\n+  {\n+    return new EmptyStmt (*this);\n+  }\n+};\n+\n+/* This is syntactically identical to declaring an item inside a module BUT it\n+ * has block scope. Type of \"declaration statement\" as it introduces new name\n+ * into scope */\n+/*class ItemStatement : public Statement {\n+    // TODO: put in same params as regular item\n+    // maybe even merge data structure with module item?\n+\n+  public:\n+    ::std::string as_string() const;\n+};*/\n+// removed - just made item inherit from statement\n+\n+/* Variable assignment let statement - type of \"declaration statement\" as it\n+ * introduces new name into scope */\n+class LetStmt : public Stmt\n+{\n+  // bool has_outer_attrs;\n+  ::std::vector<Attribute> outer_attrs;\n+\n+  // Pattern variables_pattern;\n+  ::std::unique_ptr<Pattern> variables_pattern;\n+\n+  // bool has_type;\n+  // Type type;\n+  ::std::unique_ptr<Type> type;\n+\n+  // bool has_init_expr;\n+  // Expr* init_expr;\n+  ::std::unique_ptr<Expr> init_expr;\n+\n+  Location locus;\n+\n+public:\n+  // Returns whether let statement has outer attributes.\n+  inline bool has_outer_attrs () const { return !outer_attrs.empty (); }\n+\n+  // Returns whether let statement has a given return type.\n+  inline bool has_type () const { return type != NULL; }\n+\n+  // Returns whether let statement has an initialisation expression.\n+  inline bool has_init_expr () const { return init_expr != NULL; }\n+\n+  /*~LetStatement() {\n+      if (has_init_expr) {\n+\t  delete init_expr;\n+      }\n+  }*/\n+\n+  ::std::string as_string () const;\n+\n+  LetStmt (::std::unique_ptr<Pattern> variables_pattern,\n+\t   ::std::unique_ptr<Expr> init_expr, ::std::unique_ptr<Type> type,\n+\t   ::std::vector<Attribute> outer_attrs, Location locus)\n+    : outer_attrs (::std::move (outer_attrs)),\n+      variables_pattern (::std::move (variables_pattern)),\n+      type (::std::move (type)), init_expr (::std::move (init_expr)),\n+      locus (locus)\n+  {}\n+\n+  // Copy constructor with clone\n+  LetStmt (LetStmt const &other)\n+    : outer_attrs (other.outer_attrs),\n+      variables_pattern (other.variables_pattern->clone_pattern ()),\n+      type (other.type->clone_type ()),\n+      init_expr (other.init_expr->clone_expr ()), locus (other.locus)\n+  {}\n+\n+  // Destructor - define here if required\n+\n+  // Overloaded assignment operator to clone\n+  LetStmt &operator= (LetStmt const &other)\n+  {\n+    variables_pattern = other.variables_pattern->clone_pattern ();\n+    init_expr = other.init_expr->clone_expr ();\n+    type = other.type->clone_type ();\n+    outer_attrs = other.outer_attrs;\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  LetStmt (LetStmt &&other) = default;\n+  LetStmt &operator= (LetStmt &&other) = default;\n+\n+  Location get_locus () const { return locus; }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual LetStmt *clone_stmt_impl () const OVERRIDE\n+  {\n+    return new LetStmt (*this);\n+  }\n+};\n+\n+// Abstract base class for expression statements (statements containing an\n+// expression)\n+class ExprStmt : public Stmt\n+{\n+  // TODO: add any useful virtual functions\n+\n+  Location locus;\n+\n+public:\n+  Location get_locus () const { return locus; }\n+\n+protected:\n+  ExprStmt (Location locus) : locus (locus) {}\n+};\n+\n+/* Statement containing an expression without a block (or, due to technical\n+ * difficulties, can only be guaranteed to hold an expression). */\n+class ExprStmtWithoutBlock : public ExprStmt\n+{\n+  // ExprWithoutBlock* expr;\n+  /* HACK: cannot ensure type safety of ExprWithoutBlock due to Pratt parsing,\n+   * so have to store more general type of Expr. FIXME: fix this issue somehow\n+   * or redesign AST. */\n+  //::std::unique_ptr<ExprWithoutBlock> expr;\n+  ::std::unique_ptr<Expr> expr;\n+\n+public:\n+  /*~ExpressionStatementWithoutBlock() {\n+      delete expr;\n+  }*/\n+\n+  ::std::string as_string () const;\n+\n+  // ExprStmtWithoutBlock(::std::unique_ptr<ExprWithoutBlock> expr) :\n+  // expr(::std::move(expr)) {}\n+  ExprStmtWithoutBlock (::std::unique_ptr<Expr> expr, Location locus)\n+    : ExprStmt (locus), expr (::std::move (expr))\n+  {}\n+\n+  // Copy constructor with clone\n+  ExprStmtWithoutBlock (ExprStmtWithoutBlock const &other)\n+    : ExprStmt (other), expr (other.expr->clone_expr /*_without_block*/ ())\n+  {}\n+\n+  // Destructor - define here if required\n+\n+  // Overloaded assignment operator to clone\n+  ExprStmtWithoutBlock &operator= (ExprStmtWithoutBlock const &other)\n+  {\n+    ExprStmt::operator= (other);\n+    expr = other.expr->clone_expr /*_without_block*/ ();\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  ExprStmtWithoutBlock (ExprStmtWithoutBlock &&other) = default;\n+  ExprStmtWithoutBlock &operator= (ExprStmtWithoutBlock &&other) = default;\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual ExprStmtWithoutBlock *clone_stmt_impl () const OVERRIDE\n+  {\n+    return new ExprStmtWithoutBlock (*this);\n+  }\n+};\n+\n+// Statement containing an expression with a block\n+class ExprStmtWithBlock : public ExprStmt\n+{\n+  // ExprWithBlock* expr;\n+  ::std::unique_ptr<ExprWithBlock> expr;\n+\n+public:\n+  /*~ExpressionStatementWithBlock() {\n+      delete expr;\n+  }*/\n+\n+  ::std::string as_string () const;\n+\n+  ExprStmtWithBlock (::std::unique_ptr<ExprWithBlock> expr, Location locus)\n+    : ExprStmt (locus), expr (::std::move (expr))\n+  {}\n+\n+  // Copy constructor with clone\n+  ExprStmtWithBlock (ExprStmtWithBlock const &other)\n+    : ExprStmt (other), expr (other.expr->clone_expr_with_block ())\n+  {}\n+\n+  // Destructor - define here if required\n+\n+  // Overloaded assignment operator to clone\n+  ExprStmtWithBlock &operator= (ExprStmtWithBlock const &other)\n+  {\n+    ExprStmt::operator= (other);\n+    expr = other.expr->clone_expr_with_block ();\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  ExprStmtWithBlock (ExprStmtWithBlock &&other) = default;\n+  ExprStmtWithBlock &operator= (ExprStmtWithBlock &&other) = default;\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual ExprStmtWithBlock *clone_stmt_impl () const OVERRIDE\n+  {\n+    return new ExprStmtWithBlock (*this);\n+  }\n+};\n+\n+// Replaced definition of MacroInvocationSemi with forward decl - defined in\n+// rust-macro.h\n+class MacroInvocationSemi;\n+/*class MacroInvocationSemi : public Statement {\n+  public:\n+    ::std::string as_string() const;\n+};*/\n+} // namespace AST\n+} // namespace Rust\n \n #endif"}, {"sha": "cacdd554ccb2206d7987d93e8f15afe24cd8e684", "filename": "gcc/rust/ast/rust-type.h", "status": "modified", "additions": 911, "deletions": 819, "changes": 1730, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Fast%2Frust-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Fast%2Frust-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-type.h?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -5,824 +5,916 @@\n #include \"rust-path.h\"\n \n namespace Rust {\n-    namespace AST {\n-        // definitions moved to rust-ast.h\n-        class TypeParamBound;\n-        class Lifetime;\n-\n-        // A trait bound\n-        class TraitBound : public TypeParamBound {\n-            bool in_parens;\n-            bool opening_question_mark;\n-\n-            // bool has_for_lifetimes;\n-            // LifetimeParams for_lifetimes;\n-            ::std::vector<LifetimeParam> for_lifetimes; // inlined LifetimeParams\n-\n-            TypePath type_path;\n-\n-            Location locus;\n-\n-          public:\n-            // Returns whether trait bound has \"for\" lifetimes\n-            inline bool has_for_lifetimes() const {\n-                return !for_lifetimes.empty();\n-            }\n-\n-            TraitBound(TypePath type_path, Location locus, bool in_parens = false,\n-              bool opening_question_mark = false,\n-              ::std::vector<LifetimeParam> for_lifetimes = ::std::vector<LifetimeParam>()) :\n-              in_parens(in_parens),\n-              opening_question_mark(opening_question_mark), for_lifetimes(::std::move(for_lifetimes)),\n-              type_path(::std::move(type_path)), locus(locus) {}\n-\n-            ::std::string as_string() const;\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Clone function implementation as (not pure) virtual method\n-            virtual TraitBound* clone_type_param_bound_impl() const {\n-                return new TraitBound(*this);\n-            }\n-        };\n-\n-        // definition moved to rust-ast.h\n-        class TypeNoBounds;\n-\n-        // An impl trait? Poor reference material here.\n-        class ImplTraitType : public Type {\n-            // TypeParamBounds type_param_bounds;\n-            ::std::vector< ::std::unique_ptr<TypeParamBound> > type_param_bounds; // inlined form\n-\n-            Location locus;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual ImplTraitType* clone_type_impl() const OVERRIDE {\n-                return new ImplTraitType(*this);\n-            }\n-\n-          public:\n-            ImplTraitType(\n-              ::std::vector< ::std::unique_ptr<TypeParamBound> > type_param_bounds, Location locus) :\n-              type_param_bounds(::std::move(type_param_bounds)),\n-              locus(locus) {}\n-\n-            // copy constructor with vector clone\n-            ImplTraitType(ImplTraitType const& other) : locus(other.locus) {\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                type_param_bounds.reserve(other.type_param_bounds.size());\n-\n-                for (const auto& e : other.type_param_bounds) {\n-                    type_param_bounds.push_back(e->clone_type_param_bound());\n-                }\n-            }\n-\n-            // overloaded assignment operator to clone\n-            ImplTraitType& operator=(ImplTraitType const& other) {\n-                locus = other.locus;\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                type_param_bounds.reserve(other.type_param_bounds.size());\n-\n-                for (const auto& e : other.type_param_bounds) {\n-                    type_param_bounds.push_back(e->clone_type_param_bound());\n-                }\n-\n-                return *this;\n-            }\n-\n-            // move constructors\n-            ImplTraitType(ImplTraitType&& other) = default;\n-            ImplTraitType& operator=(ImplTraitType&& other) = default;\n-\n-            ::std::string as_string() const;\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-        };\n-\n-        // An opaque value of another type that implements a set of traits\n-        class TraitObjectType : public Type {\n-            bool has_dyn;\n-            // TypeParamBounds type_param_bounds;\n-            ::std::vector< ::std::unique_ptr<TypeParamBound> > type_param_bounds; // inlined form\n-\n-            Location locus;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual TraitObjectType* clone_type_impl() const OVERRIDE {\n-                return new TraitObjectType(*this);\n-            }\n-\n-          public:\n-            TraitObjectType(::std::vector< ::std::unique_ptr<TypeParamBound> > type_param_bounds,\n-              Location locus, bool is_dyn_dispatch = false) :\n-              has_dyn(is_dyn_dispatch),\n-              type_param_bounds(::std::move(type_param_bounds)), locus(locus) {}\n-\n-            // copy constructor with vector clone\n-            TraitObjectType(TraitObjectType const& other) :\n-              has_dyn(other.has_dyn), locus(other.locus) {\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                type_param_bounds.reserve(other.type_param_bounds.size());\n-\n-                for (const auto& e : other.type_param_bounds) {\n-                    type_param_bounds.push_back(e->clone_type_param_bound());\n-                }\n-            }\n-\n-            // overloaded assignment operator to clone\n-            TraitObjectType& operator=(TraitObjectType const& other) {\n-                has_dyn = other.has_dyn;\n-                locus = other.locus;\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                type_param_bounds.reserve(other.type_param_bounds.size());\n-\n-                for (const auto& e : other.type_param_bounds) {\n-                    type_param_bounds.push_back(e->clone_type_param_bound());\n-                }\n-\n-                return *this;\n-            }\n-\n-            // move constructors\n-            TraitObjectType(TraitObjectType&& other) = default;\n-            TraitObjectType& operator=(TraitObjectType&& other) = default;\n-\n-            ::std::string as_string() const;\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-        };\n-\n-        // A type with parentheses around it, used to avoid ambiguity.\n-        class ParenthesisedType : public TypeNoBounds {\n-            // Type type_in_parens;\n-            ::std::unique_ptr<Type> type_in_parens;\n-\n-            Location locus;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual ParenthesisedType* clone_type_impl() const OVERRIDE {\n-                return new ParenthesisedType(*this);\n-            }\n-\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual ParenthesisedType* clone_type_no_bounds_impl() const OVERRIDE {\n-                return new ParenthesisedType(*this);\n-            }\n-\n-          public:\n-            // Constructor uses Type pointer for polymorphism\n-            ParenthesisedType(::std::unique_ptr<Type> type_inside_parens, Location locus) :\n-              type_in_parens(::std::move(type_inside_parens)), locus(locus) {}\n-\n-            // Copy constructor uses custom deep copy method for type to preserve polymorphism\n-            ParenthesisedType(ParenthesisedType const& other) :\n-              type_in_parens(other.type_in_parens->clone_type()), locus(other.locus) {}\n-\n-            // define destructor here if required\n-\n-            // overload assignment operator to use custom clone method\n-            ParenthesisedType& operator=(ParenthesisedType const& other) {\n-                type_in_parens = other.type_in_parens->clone_type();\n-                locus = other.locus;\n-                return *this;\n-            }\n-\n-            // default move semantics\n-            ParenthesisedType(ParenthesisedType&& other) = default;\n-            ParenthesisedType& operator=(ParenthesisedType&& other) = default;\n-\n-            ::std::string as_string() const {\n-                return \"(\" + type_in_parens->as_string() + \")\";\n-            }\n-\n-            // Creates a trait bound (clone of this one's trait bound) - HACK\n-            virtual TraitBound* to_trait_bound(bool in_parens ATTRIBUTE_UNUSED) const OVERRIDE {\n-                /* NOTE: obviously it is unknown whether the internal type is a trait bound due to\n-                 * polymorphism, so just let the internal type handle it. As parenthesised type, it\n-                 * must be in parentheses. */\n-                return type_in_parens->to_trait_bound(true);\n-            }\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-        };\n-\n-        // Impl trait with a single bound? Poor reference material here.\n-        class ImplTraitTypeOneBound : public TypeNoBounds {\n-            TraitBound trait_bound;\n-\n-            Location locus;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual ImplTraitTypeOneBound* clone_type_impl() const OVERRIDE {\n-                return new ImplTraitTypeOneBound(*this);\n-            }\n-\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual ImplTraitTypeOneBound* clone_type_no_bounds_impl() const OVERRIDE {\n-                return new ImplTraitTypeOneBound(*this);\n-            }\n-\n-          public:\n-            ImplTraitTypeOneBound(TraitBound trait_bound, Location locus) :\n-              trait_bound(::std::move(trait_bound)), locus(locus) {}\n-\n-            ::std::string as_string() const;\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-        };\n-\n-        /* A trait object with a single trait bound. The \"trait bound\" is really just the trait.\n-         * Basically like using an interface as a type in an OOP language. */\n-        class TraitObjectTypeOneBound : public TypeNoBounds {\n-            bool has_dyn;\n-            TraitBound trait_bound;\n-\n-            Location locus;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual TraitObjectTypeOneBound* clone_type_impl() const OVERRIDE {\n-                return new TraitObjectTypeOneBound(*this);\n-            }\n-\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual TraitObjectTypeOneBound* clone_type_no_bounds_impl() const OVERRIDE {\n-                return new TraitObjectTypeOneBound(*this);\n-            }\n-\n-          public:\n-            TraitObjectTypeOneBound(\n-              TraitBound trait_bound, Location locus, bool is_dyn_dispatch = false) :\n-              has_dyn(is_dyn_dispatch),\n-              trait_bound(::std::move(trait_bound)), locus(locus) {}\n-\n-            ::std::string as_string() const;\n-\n-            // Creates a trait bound (clone of this one's trait bound) - HACK\n-            virtual TraitBound* to_trait_bound(bool in_parens ATTRIBUTE_UNUSED) const OVERRIDE {\n-                /* NOTE: this assumes there is no dynamic dispatch specified- if there was, this\n-                 * cloning would not be required as parsing is unambiguous. */\n-                return new AST::TraitBound(trait_bound);\n-            }\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-        };\n-\n-        class TypePath; // definition moved to \"rust-path.h\"\n-\n-        // A type consisting of the \"product\" of others (the tuple's elements) in a specific order\n-        class TupleType : public TypeNoBounds {\n-            //::std::vector<Type> elems;\n-            ::std::vector< ::std::unique_ptr<Type> > elems;\n-\n-            Location locus;\n-\n-          public:\n-            // Returns whether the tuple type is the unit type, i.e. has no elements.\n-            inline bool is_unit_type() const {\n-                return elems.empty();\n-            }\n-\n-            TupleType(::std::vector< ::std::unique_ptr<Type> > elems, Location locus) :\n-              elems(::std::move(elems)), locus(locus) {}\n-\n-            // copy constructor with vector clone\n-            TupleType(TupleType const& other) : locus(other.locus) {\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                elems.reserve(other.elems.size());\n-\n-                for (const auto& e : other.elems) {\n-                    elems.push_back(e->clone_type());\n-                }\n-            }\n-\n-            // overloaded assignment operator to clone\n-            TupleType& operator=(TupleType const& other) {\n-                locus = other.locus;\n-                // crappy vector unique pointer clone - TODO is there a better way of doing this?\n-                elems.reserve(other.elems.size());\n-\n-                for (const auto& e : other.elems) {\n-                    elems.push_back(e->clone_type());\n-                }\n-\n-                return *this;\n-            }\n-\n-            // move constructors\n-            TupleType(TupleType&& other) = default;\n-            TupleType& operator=(TupleType&& other) = default;\n-\n-            ::std::string as_string() const;\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual TupleType* clone_type_impl() const OVERRIDE {\n-                return new TupleType(*this);\n-            }\n-\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual TupleType* clone_type_no_bounds_impl() const OVERRIDE {\n-                return new TupleType(*this);\n-            }\n-        };\n-\n-        /* A type with no values, representing the result of computations that never complete.\n-         * Expressions of NeverType can be coerced into any other types. Represented as \"!\". */\n-        class NeverType : public TypeNoBounds {\n-            Location locus;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual NeverType* clone_type_impl() const OVERRIDE {\n-                return new NeverType(*this);\n-            }\n-\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual NeverType* clone_type_no_bounds_impl() const OVERRIDE {\n-                return new NeverType(*this);\n-            }\n-\n-          public:\n-            NeverType(Location locus) : locus(locus) {}\n-\n-            ::std::string as_string() const {\n-                return \"! (never type)\";\n-            }\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-        };\n-\n-        // A type consisting of a pointer without safety or liveness guarantees\n-        class RawPointerType : public TypeNoBounds {\n-          public:\n-            enum PointerType { MUT, CONST };\n-\n-          private:\n-            PointerType pointer_type;\n-\n-            // TypeNoBounds type;\n-            ::std::unique_ptr<TypeNoBounds> type;\n-\n-            Location locus;\n-\n-          public:\n-            // Returns whether the pointer is mutable or constant.\n-            inline PointerType get_pointer_type() const {\n-                return pointer_type;\n-            }\n-\n-            // Constructor requires pointer for polymorphism reasons\n-            RawPointerType(PointerType pointer_type, ::std::unique_ptr<TypeNoBounds> type_no_bounds,\n-              Location locus) :\n-              pointer_type(pointer_type),\n-              type(::std::move(type_no_bounds)), locus(locus) {}\n-\n-            // Copy constructor calls custom polymorphic clone function\n-            RawPointerType(RawPointerType const& other) :\n-              pointer_type(other.pointer_type), type(other.type->clone_type_no_bounds()),\n-              locus(other.locus) {}\n-\n-            // no destructor required?\n-\n-            // overload assignment operator to use custom clone method\n-            RawPointerType& operator=(RawPointerType const& other) {\n-                pointer_type = other.pointer_type;\n-                type = other.type->clone_type_no_bounds();\n-                locus = other.locus;\n-                return *this;\n-            }\n-\n-            // default move semantics\n-            RawPointerType(RawPointerType&& other) = default;\n-            RawPointerType& operator=(RawPointerType&& other) = default;\n-\n-            ::std::string as_string() const;\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual RawPointerType* clone_type_impl() const OVERRIDE {\n-                return new RawPointerType(*this);\n-            }\n-\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual RawPointerType* clone_type_no_bounds_impl() const OVERRIDE {\n-                return new RawPointerType(*this);\n-            }\n-        };\n-\n-        // A type pointing to memory owned by another value\n-        class ReferenceType : public TypeNoBounds {\n-            // bool has_lifetime; // TODO: handle in lifetime or something?\n-            Lifetime lifetime;\n-\n-            bool has_mut;\n-\n-            // TypeNoBounds type;\n-            ::std::unique_ptr<TypeNoBounds> type;\n-\n-            Location locus;\n-\n-          public:\n-            // Returns whether the reference is mutable or immutable.\n-            inline bool is_mut() const {\n-                return has_mut;\n-            }\n-\n-            // Returns whether the reference has a lifetime.\n-            inline bool has_lifetime() const {\n-                return !lifetime.is_error();\n-            }\n-\n-            // Constructor\n-            ReferenceType(bool is_mut, ::std::unique_ptr<TypeNoBounds> type_no_bounds, Location locus,\n-              Lifetime lifetime = Lifetime::error()) :\n-              lifetime(::std::move(lifetime)),\n-              has_mut(is_mut), type(::std::move(type_no_bounds)), locus(locus) {}\n-\n-            // Copy constructor with custom clone method\n-            ReferenceType(ReferenceType const& other) :\n-              lifetime(other.lifetime), has_mut(other.has_mut),\n-              type(other.type->clone_type_no_bounds()), locus(other.locus) {}\n-\n-            // Destructor not required?\n-\n-            // Operator overload assignment operator to custom clone the unique pointer\n-            ReferenceType& operator=(ReferenceType const& other) {\n-                lifetime = other.lifetime;\n-                has_mut = other.has_mut;\n-                type = other.type->clone_type_no_bounds();\n-                locus = other.locus;\n-\n-                return *this;\n-            }\n-\n-            // move constructors\n-            ReferenceType(ReferenceType&& other) = default;\n-            ReferenceType& operator=(ReferenceType&& other) = default;\n-\n-            ::std::string as_string() const;\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual ReferenceType* clone_type_impl() const OVERRIDE {\n-                return new ReferenceType(*this);\n-            }\n-\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual ReferenceType* clone_type_no_bounds_impl() const OVERRIDE {\n-                return new ReferenceType(*this);\n-            }\n-        };\n-\n-        // A fixed-size sequence of elements of a specified type\n-        class ArrayType : public TypeNoBounds {\n-            // Type elem_type;\n-            ::std::unique_ptr<Type> elem_type;\n-            // Expr* size;\n-            ::std::unique_ptr<Expr> size;\n-\n-            Location locus;\n-\n-          public:\n-            // Constructor requires pointers for polymorphism\n-            ArrayType(\n-              ::std::unique_ptr<Type> type, ::std::unique_ptr<Expr> array_size, Location locus) :\n-              elem_type(::std::move(type)),\n-              size(::std::move(array_size)), locus(locus) {}\n-\n-            // Copy constructor requires deep copies of both unique pointers\n-            ArrayType(ArrayType const& other) :\n-              elem_type(other.elem_type->clone_type()), size(other.size->clone_expr()),\n-              locus(other.locus) {}\n-\n-            // destructor not required?\n-\n-            // Overload assignment operator to deep copy pointers\n-            ArrayType& operator=(ArrayType const& other) {\n-                elem_type = other.elem_type->clone_type();\n-                size = other.size->clone_expr();\n-                locus = other.locus;\n-                return *this;\n-            }\n-\n-            // move constructors\n-            ArrayType(ArrayType&& other) = default;\n-            ArrayType& operator=(ArrayType&& other) = default;\n-\n-            ::std::string as_string() const;\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-            /*~ArrayType() {\n-                delete size;\n-            }*/\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual ArrayType* clone_type_impl() const OVERRIDE {\n-                return new ArrayType(*this);\n-            }\n-\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual ArrayType* clone_type_no_bounds_impl() const OVERRIDE {\n-                return new ArrayType(*this);\n-            }\n-        };\n-\n-        // A dynamically-sized type representing a \"view\" into a sequence of elements of a type\n-        class SliceType : public TypeNoBounds {\n-            // Type elem_type;\n-            ::std::unique_ptr<Type> elem_type;\n-\n-            Location locus;\n-\n-          public:\n-            // Constructor requires pointer for polymorphism\n-            SliceType(::std::unique_ptr<Type> type, Location locus) :\n-              elem_type(::std::move(type)), locus(locus) {}\n-\n-            // Copy constructor requires deep copy of Type smart pointer\n-            SliceType(SliceType const& other) :\n-              elem_type(other.elem_type->clone_type()), locus(other.locus) {}\n-\n-            // destructor not required?\n-\n-            // Overload assignment operator to deep copy\n-            SliceType& operator=(SliceType const& other) {\n-                elem_type = other.elem_type->clone_type();\n-                locus = other.locus;\n-\n-                return *this;\n-            }\n-\n-            // move constructors\n-            SliceType(SliceType&& other) = default;\n-            SliceType& operator=(SliceType&& other) = default;\n-\n-            ::std::string as_string() const;\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual SliceType* clone_type_impl() const OVERRIDE {\n-                return new SliceType(*this);\n-            }\n-\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual SliceType* clone_type_no_bounds_impl() const OVERRIDE {\n-                return new SliceType(*this);\n-            }\n-        };\n-\n-        // Type used in generic arguments to explicitly request type inference (wildcard pattern)\n-        class InferredType : public TypeNoBounds {\n-            Location locus;\n-\n-            // e.g. Vec<_> = whatever\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual InferredType* clone_type_impl() const OVERRIDE {\n-                return new InferredType(*this);\n-            }\n-\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual InferredType* clone_type_no_bounds_impl() const OVERRIDE {\n-                return new InferredType(*this);\n-            }\n-\n-          public:\n-            InferredType(Location locus) : locus(locus) {}\n-\n-            ::std::string as_string() const;\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-        };\n-\n-        class QualifiedPathInType; // definition moved to \"rust-path.h\"\n-\n-        // A possibly named param used in a BaseFunctionType\n-        struct MaybeNamedParam {\n-          public:\n-            enum ParamKind { UNNAMED, IDENTIFIER, WILDCARD };\n-\n-          private:\n-            // Type param_type;\n-            ::std::unique_ptr<Type> param_type;\n-\n-            ParamKind param_kind;\n-            Identifier name; // technically, can be an identifier or '_'\n-\n-            Location locus;\n-\n-          public:\n-            MaybeNamedParam(Identifier name, ParamKind param_kind, ::std::unique_ptr<Type> param_type,\n-              Location locus) :\n-              param_type(::std::move(param_type)),\n-              param_kind(param_kind), name(::std::move(name)), locus(locus) {}\n-\n-            // Copy constructor with clone\n-            MaybeNamedParam(MaybeNamedParam const& other) :\n-              param_type(other.param_type->clone_type()), param_kind(other.param_kind),\n-              name(other.name), locus(other.locus) {}\n-\n-            ~MaybeNamedParam() = default;\n-\n-            // Overloaded assignment operator with clone\n-            MaybeNamedParam& operator=(MaybeNamedParam const& other) {\n-                name = other.name;\n-                param_kind = other.param_kind;\n-                param_type = other.param_type->clone_type();\n-                locus = other.locus;\n-\n-                return *this;\n-            }\n-\n-            // move constructors\n-            MaybeNamedParam(MaybeNamedParam&& other) = default;\n-            MaybeNamedParam& operator=(MaybeNamedParam&& other) = default;\n-\n-            ::std::string as_string() const;\n-\n-            // Returns whether the param is in an error state.\n-            inline bool is_error() const {\n-                return param_type == NULL;\n-            }\n-\n-            // Creates an error state param.\n-            static MaybeNamedParam create_error() {\n-                return MaybeNamedParam(\"\", UNNAMED, NULL, Location());\n-            }\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-        };\n-\n-        /* A function pointer type - can be created via coercion from function items and non-\n-         * capturing closures. */\n-        class BareFunctionType : public TypeNoBounds {\n-            // bool has_for_lifetimes;\n-            // ForLifetimes for_lifetimes;\n-            ::std::vector<LifetimeParam> for_lifetimes; // inlined version\n-\n-            FunctionQualifiers function_qualifiers;\n-            ::std::vector<MaybeNamedParam> params;\n-            bool is_variadic;\n-\n-            // bool has_return_type;\n-            // BareFunctionReturnType return_type;\n-            ::std::unique_ptr<TypeNoBounds> return_type; // inlined version\n-\n-            Location locus;\n-\n-          public:\n-            // Whether a return type is defined with the function.\n-            inline bool has_return_type() const {\n-                return return_type != NULL;\n-            }\n-\n-            // Whether the function has ForLifetimes.\n-            inline bool has_for_lifetimes() const {\n-                return !for_lifetimes.empty();\n-            }\n-\n-            BareFunctionType(::std::vector<LifetimeParam> lifetime_params,\n-              FunctionQualifiers qualifiers, ::std::vector<MaybeNamedParam> named_params,\n-              bool is_variadic, ::std::unique_ptr<TypeNoBounds> type, Location locus) :\n-              for_lifetimes(::std::move(lifetime_params)),\n-              function_qualifiers(::std::move(qualifiers)), params(::std::move(named_params)),\n-              is_variadic(is_variadic), return_type(::std::move(type)), locus(locus) {}\n-\n-            // Copy constructor with clone\n-            BareFunctionType(BareFunctionType const& other) :\n-              for_lifetimes(other.for_lifetimes), function_qualifiers(other.function_qualifiers),\n-              params(other.params), is_variadic(other.is_variadic),\n-              return_type(other.return_type->clone_type_no_bounds()), locus(other.locus) {}\n-\n-            // destructor - define here if required\n-\n-            // Overload assignment operator to deep copy\n-            BareFunctionType& operator=(BareFunctionType const& other) {\n-                for_lifetimes = other.for_lifetimes;\n-                function_qualifiers = other.function_qualifiers;\n-                params = other.params;\n-                is_variadic = other.is_variadic;\n-                return_type = other.return_type->clone_type_no_bounds();\n-                locus = other.locus;\n-\n-                return *this;\n-            }\n-\n-            // move constructors\n-            BareFunctionType(BareFunctionType&& other) = default;\n-            BareFunctionType& operator=(BareFunctionType&& other) = default;\n-\n-            ::std::string as_string() const;\n-\n-            Location get_locus() const {\n-                return locus;\n-            }\n-\n-            virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n-\n-          protected:\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual BareFunctionType* clone_type_impl() const OVERRIDE {\n-                return new BareFunctionType(*this);\n-            }\n-\n-            // Use covariance to implement clone function as returning this object rather than base\n-            virtual BareFunctionType* clone_type_no_bounds_impl() const OVERRIDE {\n-                return new BareFunctionType(*this);\n-            }\n-        };\n-\n-        // Forward decl - defined in rust-macro.h\n-        class MacroInvocation;\n-\n-        /*// AST node of a macro invocation, which is replaced by the macro result at compile time\n-        class MacroInvocation : public TypeNoBounds, public Pattern, public ExprWithoutBlock {\n-            SimplePath path;\n-            DelimTokenTree token_tree;\n-        };*/\n-\n-        /* TODO: possible types\n-         * struct type?\n-         * \"enum\" (tagged union) type?\n-         * C-like union type?\n-         * function item type?\n-         * closure expression types?\n-         * primitive types (bool, int, float, char, str (the slice))\n-         * Although supposedly TypePaths are used to reference these types (including primitives) */\n-\n-        /* FIXME: Incomplete spec references:\n-         *  anonymous type parameters, aka \"impl Trait in argument position\" - impl then trait bounds\n-         *  abstract return types, aka \"impl Trait in return position\" - impl then trait bounds */\n-    }\n-}\n+namespace AST {\n+// definitions moved to rust-ast.h\n+class TypeParamBound;\n+class Lifetime;\n+\n+// A trait bound\n+class TraitBound : public TypeParamBound\n+{\n+  bool in_parens;\n+  bool opening_question_mark;\n+\n+  // bool has_for_lifetimes;\n+  // LifetimeParams for_lifetimes;\n+  ::std::vector<LifetimeParam> for_lifetimes; // inlined LifetimeParams\n+\n+  TypePath type_path;\n+\n+  Location locus;\n+\n+public:\n+  // Returns whether trait bound has \"for\" lifetimes\n+  inline bool has_for_lifetimes () const { return !for_lifetimes.empty (); }\n+\n+  TraitBound (TypePath type_path, Location locus, bool in_parens = false,\n+\t      bool opening_question_mark = false,\n+\t      ::std::vector<LifetimeParam> for_lifetimes\n+\t      = ::std::vector<LifetimeParam> ())\n+    : in_parens (in_parens), opening_question_mark (opening_question_mark),\n+      for_lifetimes (::std::move (for_lifetimes)),\n+      type_path (::std::move (type_path)), locus (locus)\n+  {}\n+\n+  ::std::string as_string () const;\n+\n+  Location get_locus () const { return locus; }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Clone function implementation as (not pure) virtual method\n+  virtual TraitBound *clone_type_param_bound_impl () const\n+  {\n+    return new TraitBound (*this);\n+  }\n+};\n+\n+// definition moved to rust-ast.h\n+class TypeNoBounds;\n+\n+// An impl trait? Poor reference material here.\n+class ImplTraitType : public Type\n+{\n+  // TypeParamBounds type_param_bounds;\n+  ::std::vector< ::std::unique_ptr<TypeParamBound> >\n+    type_param_bounds; // inlined form\n+\n+  Location locus;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual ImplTraitType *clone_type_impl () const OVERRIDE\n+  {\n+    return new ImplTraitType (*this);\n+  }\n+\n+public:\n+  ImplTraitType (\n+    ::std::vector< ::std::unique_ptr<TypeParamBound> > type_param_bounds,\n+    Location locus)\n+    : type_param_bounds (::std::move (type_param_bounds)), locus (locus)\n+  {}\n+\n+  // copy constructor with vector clone\n+  ImplTraitType (ImplTraitType const &other) : locus (other.locus)\n+  {\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    type_param_bounds.reserve (other.type_param_bounds.size ());\n+\n+    for (const auto &e : other.type_param_bounds)\n+      {\n+\ttype_param_bounds.push_back (e->clone_type_param_bound ());\n+      }\n+  }\n+\n+  // overloaded assignment operator to clone\n+  ImplTraitType &operator= (ImplTraitType const &other)\n+  {\n+    locus = other.locus;\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    type_param_bounds.reserve (other.type_param_bounds.size ());\n+\n+    for (const auto &e : other.type_param_bounds)\n+      {\n+\ttype_param_bounds.push_back (e->clone_type_param_bound ());\n+      }\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  ImplTraitType (ImplTraitType &&other) = default;\n+  ImplTraitType &operator= (ImplTraitType &&other) = default;\n+\n+  ::std::string as_string () const;\n+\n+  Location get_locus () const { return locus; }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+};\n+\n+// An opaque value of another type that implements a set of traits\n+class TraitObjectType : public Type\n+{\n+  bool has_dyn;\n+  // TypeParamBounds type_param_bounds;\n+  ::std::vector< ::std::unique_ptr<TypeParamBound> >\n+    type_param_bounds; // inlined form\n+\n+  Location locus;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual TraitObjectType *clone_type_impl () const OVERRIDE\n+  {\n+    return new TraitObjectType (*this);\n+  }\n+\n+public:\n+  TraitObjectType (\n+    ::std::vector< ::std::unique_ptr<TypeParamBound> > type_param_bounds,\n+    Location locus, bool is_dyn_dispatch = false)\n+    : has_dyn (is_dyn_dispatch),\n+      type_param_bounds (::std::move (type_param_bounds)), locus (locus)\n+  {}\n+\n+  // copy constructor with vector clone\n+  TraitObjectType (TraitObjectType const &other)\n+    : has_dyn (other.has_dyn), locus (other.locus)\n+  {\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    type_param_bounds.reserve (other.type_param_bounds.size ());\n+\n+    for (const auto &e : other.type_param_bounds)\n+      {\n+\ttype_param_bounds.push_back (e->clone_type_param_bound ());\n+      }\n+  }\n+\n+  // overloaded assignment operator to clone\n+  TraitObjectType &operator= (TraitObjectType const &other)\n+  {\n+    has_dyn = other.has_dyn;\n+    locus = other.locus;\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    type_param_bounds.reserve (other.type_param_bounds.size ());\n+\n+    for (const auto &e : other.type_param_bounds)\n+      {\n+\ttype_param_bounds.push_back (e->clone_type_param_bound ());\n+      }\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TraitObjectType (TraitObjectType &&other) = default;\n+  TraitObjectType &operator= (TraitObjectType &&other) = default;\n+\n+  ::std::string as_string () const;\n+\n+  Location get_locus () const { return locus; }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+};\n+\n+// A type with parentheses around it, used to avoid ambiguity.\n+class ParenthesisedType : public TypeNoBounds\n+{\n+  // Type type_in_parens;\n+  ::std::unique_ptr<Type> type_in_parens;\n+\n+  Location locus;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual ParenthesisedType *clone_type_impl () const OVERRIDE\n+  {\n+    return new ParenthesisedType (*this);\n+  }\n+\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual ParenthesisedType *clone_type_no_bounds_impl () const OVERRIDE\n+  {\n+    return new ParenthesisedType (*this);\n+  }\n+\n+public:\n+  // Constructor uses Type pointer for polymorphism\n+  ParenthesisedType (::std::unique_ptr<Type> type_inside_parens, Location locus)\n+    : type_in_parens (::std::move (type_inside_parens)), locus (locus)\n+  {}\n+\n+  // Copy constructor uses custom deep copy method for type to preserve\n+  // polymorphism\n+  ParenthesisedType (ParenthesisedType const &other)\n+    : type_in_parens (other.type_in_parens->clone_type ()), locus (other.locus)\n+  {}\n+\n+  // define destructor here if required\n+\n+  // overload assignment operator to use custom clone method\n+  ParenthesisedType &operator= (ParenthesisedType const &other)\n+  {\n+    type_in_parens = other.type_in_parens->clone_type ();\n+    locus = other.locus;\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  ParenthesisedType (ParenthesisedType &&other) = default;\n+  ParenthesisedType &operator= (ParenthesisedType &&other) = default;\n+\n+  ::std::string as_string () const\n+  {\n+    return \"(\" + type_in_parens->as_string () + \")\";\n+  }\n+\n+  // Creates a trait bound (clone of this one's trait bound) - HACK\n+  virtual TraitBound *\n+  to_trait_bound (bool in_parens ATTRIBUTE_UNUSED) const OVERRIDE\n+  {\n+    /* NOTE: obviously it is unknown whether the internal type is a trait bound\n+     * due to polymorphism, so just let the internal type handle it. As\n+     * parenthesised type, it must be in parentheses. */\n+    return type_in_parens->to_trait_bound (true);\n+  }\n+\n+  Location get_locus () const { return locus; }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+};\n+\n+// Impl trait with a single bound? Poor reference material here.\n+class ImplTraitTypeOneBound : public TypeNoBounds\n+{\n+  TraitBound trait_bound;\n+\n+  Location locus;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual ImplTraitTypeOneBound *clone_type_impl () const OVERRIDE\n+  {\n+    return new ImplTraitTypeOneBound (*this);\n+  }\n+\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual ImplTraitTypeOneBound *clone_type_no_bounds_impl () const OVERRIDE\n+  {\n+    return new ImplTraitTypeOneBound (*this);\n+  }\n+\n+public:\n+  ImplTraitTypeOneBound (TraitBound trait_bound, Location locus)\n+    : trait_bound (::std::move (trait_bound)), locus (locus)\n+  {}\n+\n+  ::std::string as_string () const;\n+\n+  Location get_locus () const { return locus; }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+};\n+\n+/* A trait object with a single trait bound. The \"trait bound\" is really just\n+ * the trait. Basically like using an interface as a type in an OOP language. */\n+class TraitObjectTypeOneBound : public TypeNoBounds\n+{\n+  bool has_dyn;\n+  TraitBound trait_bound;\n+\n+  Location locus;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual TraitObjectTypeOneBound *clone_type_impl () const OVERRIDE\n+  {\n+    return new TraitObjectTypeOneBound (*this);\n+  }\n+\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual TraitObjectTypeOneBound *clone_type_no_bounds_impl () const OVERRIDE\n+  {\n+    return new TraitObjectTypeOneBound (*this);\n+  }\n+\n+public:\n+  TraitObjectTypeOneBound (TraitBound trait_bound, Location locus,\n+\t\t\t   bool is_dyn_dispatch = false)\n+    : has_dyn (is_dyn_dispatch), trait_bound (::std::move (trait_bound)),\n+      locus (locus)\n+  {}\n+\n+  ::std::string as_string () const;\n+\n+  // Creates a trait bound (clone of this one's trait bound) - HACK\n+  virtual TraitBound *\n+  to_trait_bound (bool in_parens ATTRIBUTE_UNUSED) const OVERRIDE\n+  {\n+    /* NOTE: this assumes there is no dynamic dispatch specified- if there was,\n+     * this cloning would not be required as parsing is unambiguous. */\n+    return new AST::TraitBound (trait_bound);\n+  }\n+\n+  Location get_locus () const { return locus; }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+};\n+\n+class TypePath; // definition moved to \"rust-path.h\"\n+\n+// A type consisting of the \"product\" of others (the tuple's elements) in a\n+// specific order\n+class TupleType : public TypeNoBounds\n+{\n+  //::std::vector<Type> elems;\n+  ::std::vector< ::std::unique_ptr<Type> > elems;\n+\n+  Location locus;\n+\n+public:\n+  // Returns whether the tuple type is the unit type, i.e. has no elements.\n+  inline bool is_unit_type () const { return elems.empty (); }\n+\n+  TupleType (::std::vector< ::std::unique_ptr<Type> > elems, Location locus)\n+    : elems (::std::move (elems)), locus (locus)\n+  {}\n+\n+  // copy constructor with vector clone\n+  TupleType (TupleType const &other) : locus (other.locus)\n+  {\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    elems.reserve (other.elems.size ());\n+\n+    for (const auto &e : other.elems)\n+      {\n+\telems.push_back (e->clone_type ());\n+      }\n+  }\n+\n+  // overloaded assignment operator to clone\n+  TupleType &operator= (TupleType const &other)\n+  {\n+    locus = other.locus;\n+    // crappy vector unique pointer clone - TODO is there a better way of doing\n+    // this?\n+    elems.reserve (other.elems.size ());\n+\n+    for (const auto &e : other.elems)\n+      {\n+\telems.push_back (e->clone_type ());\n+      }\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TupleType (TupleType &&other) = default;\n+  TupleType &operator= (TupleType &&other) = default;\n+\n+  ::std::string as_string () const;\n+\n+  Location get_locus () const { return locus; }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual TupleType *clone_type_impl () const OVERRIDE\n+  {\n+    return new TupleType (*this);\n+  }\n+\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual TupleType *clone_type_no_bounds_impl () const OVERRIDE\n+  {\n+    return new TupleType (*this);\n+  }\n+};\n+\n+/* A type with no values, representing the result of computations that never\n+ * complete. Expressions of NeverType can be coerced into any other types.\n+ * Represented as \"!\". */\n+class NeverType : public TypeNoBounds\n+{\n+  Location locus;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual NeverType *clone_type_impl () const OVERRIDE\n+  {\n+    return new NeverType (*this);\n+  }\n+\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual NeverType *clone_type_no_bounds_impl () const OVERRIDE\n+  {\n+    return new NeverType (*this);\n+  }\n+\n+public:\n+  NeverType (Location locus) : locus (locus) {}\n+\n+  ::std::string as_string () const { return \"! (never type)\"; }\n+\n+  Location get_locus () const { return locus; }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+};\n+\n+// A type consisting of a pointer without safety or liveness guarantees\n+class RawPointerType : public TypeNoBounds\n+{\n+public:\n+  enum PointerType\n+  {\n+    MUT,\n+    CONST\n+  };\n+\n+private:\n+  PointerType pointer_type;\n+\n+  // TypeNoBounds type;\n+  ::std::unique_ptr<TypeNoBounds> type;\n+\n+  Location locus;\n+\n+public:\n+  // Returns whether the pointer is mutable or constant.\n+  inline PointerType get_pointer_type () const { return pointer_type; }\n+\n+  // Constructor requires pointer for polymorphism reasons\n+  RawPointerType (PointerType pointer_type,\n+\t\t  ::std::unique_ptr<TypeNoBounds> type_no_bounds,\n+\t\t  Location locus)\n+    : pointer_type (pointer_type), type (::std::move (type_no_bounds)),\n+      locus (locus)\n+  {}\n+\n+  // Copy constructor calls custom polymorphic clone function\n+  RawPointerType (RawPointerType const &other)\n+    : pointer_type (other.pointer_type),\n+      type (other.type->clone_type_no_bounds ()), locus (other.locus)\n+  {}\n+\n+  // no destructor required?\n+\n+  // overload assignment operator to use custom clone method\n+  RawPointerType &operator= (RawPointerType const &other)\n+  {\n+    pointer_type = other.pointer_type;\n+    type = other.type->clone_type_no_bounds ();\n+    locus = other.locus;\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  RawPointerType (RawPointerType &&other) = default;\n+  RawPointerType &operator= (RawPointerType &&other) = default;\n+\n+  ::std::string as_string () const;\n+\n+  Location get_locus () const { return locus; }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual RawPointerType *clone_type_impl () const OVERRIDE\n+  {\n+    return new RawPointerType (*this);\n+  }\n+\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual RawPointerType *clone_type_no_bounds_impl () const OVERRIDE\n+  {\n+    return new RawPointerType (*this);\n+  }\n+};\n+\n+// A type pointing to memory owned by another value\n+class ReferenceType : public TypeNoBounds\n+{\n+  // bool has_lifetime; // TODO: handle in lifetime or something?\n+  Lifetime lifetime;\n+\n+  bool has_mut;\n+\n+  // TypeNoBounds type;\n+  ::std::unique_ptr<TypeNoBounds> type;\n+\n+  Location locus;\n+\n+public:\n+  // Returns whether the reference is mutable or immutable.\n+  inline bool is_mut () const { return has_mut; }\n+\n+  // Returns whether the reference has a lifetime.\n+  inline bool has_lifetime () const { return !lifetime.is_error (); }\n+\n+  // Constructor\n+  ReferenceType (bool is_mut, ::std::unique_ptr<TypeNoBounds> type_no_bounds,\n+\t\t Location locus, Lifetime lifetime = Lifetime::error ())\n+    : lifetime (::std::move (lifetime)), has_mut (is_mut),\n+      type (::std::move (type_no_bounds)), locus (locus)\n+  {}\n+\n+  // Copy constructor with custom clone method\n+  ReferenceType (ReferenceType const &other)\n+    : lifetime (other.lifetime), has_mut (other.has_mut),\n+      type (other.type->clone_type_no_bounds ()), locus (other.locus)\n+  {}\n+\n+  // Destructor not required?\n+\n+  // Operator overload assignment operator to custom clone the unique pointer\n+  ReferenceType &operator= (ReferenceType const &other)\n+  {\n+    lifetime = other.lifetime;\n+    has_mut = other.has_mut;\n+    type = other.type->clone_type_no_bounds ();\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  ReferenceType (ReferenceType &&other) = default;\n+  ReferenceType &operator= (ReferenceType &&other) = default;\n+\n+  ::std::string as_string () const;\n+\n+  Location get_locus () const { return locus; }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual ReferenceType *clone_type_impl () const OVERRIDE\n+  {\n+    return new ReferenceType (*this);\n+  }\n+\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual ReferenceType *clone_type_no_bounds_impl () const OVERRIDE\n+  {\n+    return new ReferenceType (*this);\n+  }\n+};\n+\n+// A fixed-size sequence of elements of a specified type\n+class ArrayType : public TypeNoBounds\n+{\n+  // Type elem_type;\n+  ::std::unique_ptr<Type> elem_type;\n+  // Expr* size;\n+  ::std::unique_ptr<Expr> size;\n+\n+  Location locus;\n+\n+public:\n+  // Constructor requires pointers for polymorphism\n+  ArrayType (::std::unique_ptr<Type> type, ::std::unique_ptr<Expr> array_size,\n+\t     Location locus)\n+    : elem_type (::std::move (type)), size (::std::move (array_size)),\n+      locus (locus)\n+  {}\n+\n+  // Copy constructor requires deep copies of both unique pointers\n+  ArrayType (ArrayType const &other)\n+    : elem_type (other.elem_type->clone_type ()),\n+      size (other.size->clone_expr ()), locus (other.locus)\n+  {}\n+\n+  // destructor not required?\n+\n+  // Overload assignment operator to deep copy pointers\n+  ArrayType &operator= (ArrayType const &other)\n+  {\n+    elem_type = other.elem_type->clone_type ();\n+    size = other.size->clone_expr ();\n+    locus = other.locus;\n+    return *this;\n+  }\n+\n+  // move constructors\n+  ArrayType (ArrayType &&other) = default;\n+  ArrayType &operator= (ArrayType &&other) = default;\n+\n+  ::std::string as_string () const;\n+\n+  Location get_locus () const { return locus; }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+  /*~ArrayType() {\n+      delete size;\n+  }*/\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual ArrayType *clone_type_impl () const OVERRIDE\n+  {\n+    return new ArrayType (*this);\n+  }\n+\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual ArrayType *clone_type_no_bounds_impl () const OVERRIDE\n+  {\n+    return new ArrayType (*this);\n+  }\n+};\n+\n+// A dynamically-sized type representing a \"view\" into a sequence of elements of\n+// a type\n+class SliceType : public TypeNoBounds\n+{\n+  // Type elem_type;\n+  ::std::unique_ptr<Type> elem_type;\n+\n+  Location locus;\n+\n+public:\n+  // Constructor requires pointer for polymorphism\n+  SliceType (::std::unique_ptr<Type> type, Location locus)\n+    : elem_type (::std::move (type)), locus (locus)\n+  {}\n+\n+  // Copy constructor requires deep copy of Type smart pointer\n+  SliceType (SliceType const &other)\n+    : elem_type (other.elem_type->clone_type ()), locus (other.locus)\n+  {}\n+\n+  // destructor not required?\n+\n+  // Overload assignment operator to deep copy\n+  SliceType &operator= (SliceType const &other)\n+  {\n+    elem_type = other.elem_type->clone_type ();\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  SliceType (SliceType &&other) = default;\n+  SliceType &operator= (SliceType &&other) = default;\n+\n+  ::std::string as_string () const;\n+\n+  Location get_locus () const { return locus; }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual SliceType *clone_type_impl () const OVERRIDE\n+  {\n+    return new SliceType (*this);\n+  }\n+\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual SliceType *clone_type_no_bounds_impl () const OVERRIDE\n+  {\n+    return new SliceType (*this);\n+  }\n+};\n+\n+// Type used in generic arguments to explicitly request type inference (wildcard\n+// pattern)\n+class InferredType : public TypeNoBounds\n+{\n+  Location locus;\n+\n+  // e.g. Vec<_> = whatever\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual InferredType *clone_type_impl () const OVERRIDE\n+  {\n+    return new InferredType (*this);\n+  }\n+\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual InferredType *clone_type_no_bounds_impl () const OVERRIDE\n+  {\n+    return new InferredType (*this);\n+  }\n+\n+public:\n+  InferredType (Location locus) : locus (locus) {}\n+\n+  ::std::string as_string () const;\n+\n+  Location get_locus () const { return locus; }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+};\n+\n+class QualifiedPathInType; // definition moved to \"rust-path.h\"\n+\n+// A possibly named param used in a BaseFunctionType\n+struct MaybeNamedParam\n+{\n+public:\n+  enum ParamKind\n+  {\n+    UNNAMED,\n+    IDENTIFIER,\n+    WILDCARD\n+  };\n+\n+private:\n+  // Type param_type;\n+  ::std::unique_ptr<Type> param_type;\n+\n+  ParamKind param_kind;\n+  Identifier name; // technically, can be an identifier or '_'\n+\n+  Location locus;\n+\n+public:\n+  MaybeNamedParam (Identifier name, ParamKind param_kind,\n+\t\t   ::std::unique_ptr<Type> param_type, Location locus)\n+    : param_type (::std::move (param_type)), param_kind (param_kind),\n+      name (::std::move (name)), locus (locus)\n+  {}\n+\n+  // Copy constructor with clone\n+  MaybeNamedParam (MaybeNamedParam const &other)\n+    : param_type (other.param_type->clone_type ()),\n+      param_kind (other.param_kind), name (other.name), locus (other.locus)\n+  {}\n+\n+  ~MaybeNamedParam () = default;\n+\n+  // Overloaded assignment operator with clone\n+  MaybeNamedParam &operator= (MaybeNamedParam const &other)\n+  {\n+    name = other.name;\n+    param_kind = other.param_kind;\n+    param_type = other.param_type->clone_type ();\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  MaybeNamedParam (MaybeNamedParam &&other) = default;\n+  MaybeNamedParam &operator= (MaybeNamedParam &&other) = default;\n+\n+  ::std::string as_string () const;\n+\n+  // Returns whether the param is in an error state.\n+  inline bool is_error () const { return param_type == NULL; }\n+\n+  // Creates an error state param.\n+  static MaybeNamedParam create_error ()\n+  {\n+    return MaybeNamedParam (\"\", UNNAMED, NULL, Location ());\n+  }\n+\n+  Location get_locus () const { return locus; }\n+};\n+\n+/* A function pointer type - can be created via coercion from function items and\n+ * non- capturing closures. */\n+class BareFunctionType : public TypeNoBounds\n+{\n+  // bool has_for_lifetimes;\n+  // ForLifetimes for_lifetimes;\n+  ::std::vector<LifetimeParam> for_lifetimes; // inlined version\n+\n+  FunctionQualifiers function_qualifiers;\n+  ::std::vector<MaybeNamedParam> params;\n+  bool is_variadic;\n+\n+  // bool has_return_type;\n+  // BareFunctionReturnType return_type;\n+  ::std::unique_ptr<TypeNoBounds> return_type; // inlined version\n+\n+  Location locus;\n+\n+public:\n+  // Whether a return type is defined with the function.\n+  inline bool has_return_type () const { return return_type != NULL; }\n+\n+  // Whether the function has ForLifetimes.\n+  inline bool has_for_lifetimes () const { return !for_lifetimes.empty (); }\n+\n+  BareFunctionType (::std::vector<LifetimeParam> lifetime_params,\n+\t\t    FunctionQualifiers qualifiers,\n+\t\t    ::std::vector<MaybeNamedParam> named_params,\n+\t\t    bool is_variadic, ::std::unique_ptr<TypeNoBounds> type,\n+\t\t    Location locus)\n+    : for_lifetimes (::std::move (lifetime_params)),\n+      function_qualifiers (::std::move (qualifiers)),\n+      params (::std::move (named_params)), is_variadic (is_variadic),\n+      return_type (::std::move (type)), locus (locus)\n+  {}\n+\n+  // Copy constructor with clone\n+  BareFunctionType (BareFunctionType const &other)\n+    : for_lifetimes (other.for_lifetimes),\n+      function_qualifiers (other.function_qualifiers), params (other.params),\n+      is_variadic (other.is_variadic),\n+      return_type (other.return_type->clone_type_no_bounds ()),\n+      locus (other.locus)\n+  {}\n+\n+  // destructor - define here if required\n+\n+  // Overload assignment operator to deep copy\n+  BareFunctionType &operator= (BareFunctionType const &other)\n+  {\n+    for_lifetimes = other.for_lifetimes;\n+    function_qualifiers = other.function_qualifiers;\n+    params = other.params;\n+    is_variadic = other.is_variadic;\n+    return_type = other.return_type->clone_type_no_bounds ();\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  BareFunctionType (BareFunctionType &&other) = default;\n+  BareFunctionType &operator= (BareFunctionType &&other) = default;\n+\n+  ::std::string as_string () const;\n+\n+  Location get_locus () const { return locus; }\n+\n+  virtual void accept_vis (ASTVisitor &vis) OVERRIDE;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual BareFunctionType *clone_type_impl () const OVERRIDE\n+  {\n+    return new BareFunctionType (*this);\n+  }\n+\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  virtual BareFunctionType *clone_type_no_bounds_impl () const OVERRIDE\n+  {\n+    return new BareFunctionType (*this);\n+  }\n+};\n+\n+// Forward decl - defined in rust-macro.h\n+class MacroInvocation;\n+\n+/*// AST node of a macro invocation, which is replaced by the macro result at\n+compile time class MacroInvocation : public TypeNoBounds, public Pattern, public\n+ExprWithoutBlock { SimplePath path; DelimTokenTree token_tree;\n+};*/\n+\n+/* TODO: possible types\n+ * struct type?\n+ * \"enum\" (tagged union) type?\n+ * C-like union type?\n+ * function item type?\n+ * closure expression types?\n+ * primitive types (bool, int, float, char, str (the slice))\n+ * Although supposedly TypePaths are used to reference these types (including\n+ * primitives) */\n+\n+/* FIXME: Incomplete spec references:\n+ *  anonymous type parameters, aka \"impl Trait in argument position\" - impl then\n+ * trait bounds abstract return types, aka \"impl Trait in return position\" -\n+ * impl then trait bounds */\n+} // namespace AST\n+} // namespace Rust\n \n #endif"}, {"sha": "5e5f8feee27e6a71a63c451c07526f5889c035ad", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 73, "deletions": 57, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -3,67 +3,83 @@\n // is full really required?\n \n namespace Rust {\n-    void MacroExpander::expand_invoc(::std::unique_ptr<AST::MacroInvocation>& invoc) {\n-        // if current expansion depth > recursion limit, create an error (maybe fatal error) and return\n-\n-        /* switch on type of macro: \n-            - '!' syntax macro (inner switch)\n-                - procedural macro - \"A token-based function-like macro\"\n-                - 'macro_rules' (by example/pattern-match) macro? or not? \"an AST-based function-like macro\"\n-                - else is unreachable\n-            - attribute syntax macro (inner switch)\n-                - procedural macro attribute syntax - \"A token-based attribute macro\"\n-                - legacy macro attribute syntax? - \"an AST-based attribute macro\"\n-                - non-macro attribute: mark known \n-                - else is unreachable\n-            - derive macro (inner switch)\n-                - derive or legacy derive - \"token-based\" vs \"AST-based\"\n-                - else is unreachable\n-            - derive container macro - unreachable*/\n-\n-    }\n-\n-    // Determines whether cfg predicate is true and item with attribute should not be stripped.\n-    bool check_cfg_predicate() {}\n-\n-    // Determines whether cfg predicate is true and item with attribute should not be stripped.\n-    bool check_cfg(AST::Attribute& attr) {\n-\n+void\n+MacroExpander::expand_invoc (::std::unique_ptr<AST::MacroInvocation> &invoc)\n+{\n+  // if current expansion depth > recursion limit, create an error (maybe fatal\n+  // error) and return\n+\n+  /* switch on type of macro:\n+      - '!' syntax macro (inner switch)\n+\t  - procedural macro - \"A token-based function-like macro\"\n+\t  - 'macro_rules' (by example/pattern-match) macro? or not? \"an\n+     AST-based function-like macro\"\n+\t  - else is unreachable\n+      - attribute syntax macro (inner switch)\n+\t  - procedural macro attribute syntax - \"A token-based attribute macro\"\n+\t  - legacy macro attribute syntax? - \"an AST-based attribute macro\"\n+\t  - non-macro attribute: mark known\n+\t  - else is unreachable\n+      - derive macro (inner switch)\n+\t  - derive or legacy derive - \"token-based\" vs \"AST-based\"\n+\t  - else is unreachable\n+      - derive container macro - unreachable*/\n+}\n+\n+// Determines whether cfg predicate is true and item with attribute should not\n+// be stripped.\n+bool\n+check_cfg_predicate ()\n+{}\n+\n+// Determines whether cfg predicate is true and item with attribute should not\n+// be stripped.\n+bool\n+check_cfg (AST::Attribute &attr)\n+{}\n+\n+// Expands cfg_attr attributes.\n+void\n+expand_attrs_cfgattr (::std::vector<AST::Attribute> &attrs)\n+{\n+  for (auto it = attrs.begin (); it != attrs.end ();)\n+    {\n+      auto &attr = *it;\n+      if (attr.get_path () == \"cfg_attr\")\n+\t{\n+\t  if (check_cfg (attr))\n+\t    {\n+\t    }\n+\n+\t  /* do something - if feature (first token in tree) is in fact enabled,\n+\t   * make tokens listed afterwards into attributes. i.e.: for\n+\t   * [cfg_attr(feature = \"wow\", wow1, wow2)], if \"wow\" is true, then add\n+\t   * attributes [wow1] and [wow2] to attribute list. This can also be\n+\t   * recursive, so check for expanded attributes being recursive and\n+\t   * possibly recursively call the expand_attrs? */\n+\t}\n+      else\n+\t{\n+\t  ++it;\n+\t}\n     }\n+}\n \n-    // Expands cfg_attr attributes.\n-    void expand_attrs_cfgattr(::std::vector<AST::Attribute>& attrs) {\n-        for (auto it = attrs.begin(); it != attrs.end(); ) {\n-            auto& attr = *it;\n-            if (attr.get_path() == \"cfg_attr\") {\n-                if (check_cfg(attr)) {}\n+void\n+MacroExpander::expand_crate (AST::Crate &crate)\n+{\n+  // fill macro/decorator map from init list? not sure where init list comes\n+  // from?\n \n-                /* do something - if feature (first token in tree) is in fact enabled, make tokens listed\n-                 * afterwards into attributes. \n-                 * i.e.: for [cfg_attr(feature = \"wow\", wow1, wow2)], if \"wow\" is true, then add attributes\n-                 * [wow1] and [wow2] to attribute list. \n-                 * This can also be recursive, so check for expanded attributes being recursive and \n-                 * possibly recursively call the expand_attrs? */\n-            } else {\n-                ++it;\n-            }\n-        } \n-    }\n-\n-    void MacroExpander::expand_crate(AST::Crate& crate) {\n-        // fill macro/decorator map from init list? not sure where init list comes from?\n-\n-        // expand crate attributes\n-        expand_attrs_cfgattr(crate.inner_attrs);\n+  // expand crate attributes\n+  expand_attrs_cfgattr (crate.inner_attrs);\n \n-        // expand module attributes?\n+  // expand module attributes?\n \n-        // expand module tree recursively\n+  // expand module tree recursively\n \n-        // post-process\n+  // post-process\n \n-        // extract exported macros?\n-\n-\n-    }\n-}\n\\ No newline at end of file\n+  // extract exported macros?\n+}\n+} // namespace Rust"}, {"sha": "543c76f747b01abd03434be3dba2f435af7f9dff", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 41, "deletions": 37, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -6,42 +6,46 @@\n // Provides objects and method prototypes for macro expansion\n \n namespace Rust {\n-    // forward decls for AST\n-    namespace AST {\n-        class MacroInvocation;\n-    }\n-\n-    // Object used to store configuration data for macro expansion.\n-    struct ExpansionCfg {\n-        // features?\n-        unsigned int recursion_limit; // TODO: determine default recursion limit\n-        // trace macros?\n-        // should test?\n-        // more default stuff?\n-    };\n-\n-    // Object used to store shared data (between functions) for macro expansion.\n-    struct MacroExpander {\n-        ExpansionCfg cfg;\n-        unsigned int expansion_depth = 0;\n-\n-        MacroExpander(AST::Crate& crate, ExpansionCfg cfg) : cfg(cfg), crate(crate) {}\n-\n-        ~MacroExpander() = default;\n-\n-        // Expands all macros in the crate passed in.\n-        void expand_crate(AST::Crate& crate);\n-\n-        /* Expands a macro invocation (not macro invocation semi) - possibly make both have similar \n-         * duck-typed interface and use templates?*/\n-        // should this be public or private?\n-        void expand_invoc(::std::unique_ptr<AST::MacroInvocation>& invoc);\n-\n-        // TODO: make it extend ASTVisitor so that individual items can be accessed properly?\n-\n-      private:\n-        AST::Crate& crate;\n-    };\n+// forward decls for AST\n+namespace AST {\n+class MacroInvocation;\n }\n \n-#endif\n\\ No newline at end of file\n+// Object used to store configuration data for macro expansion.\n+struct ExpansionCfg\n+{\n+  // features?\n+  unsigned int recursion_limit; // TODO: determine default recursion limit\n+\t\t\t\t// trace macros?\n+\t\t\t\t// should test?\n+\t\t\t\t// more default stuff?\n+};\n+\n+// Object used to store shared data (between functions) for macro expansion.\n+struct MacroExpander\n+{\n+  ExpansionCfg cfg;\n+  unsigned int expansion_depth = 0;\n+\n+  MacroExpander (AST::Crate &crate, ExpansionCfg cfg) : cfg (cfg), crate (crate)\n+  {}\n+\n+  ~MacroExpander () = default;\n+\n+  // Expands all macros in the crate passed in.\n+  void expand_crate (AST::Crate &crate);\n+\n+  /* Expands a macro invocation (not macro invocation semi) - possibly make both\n+   * have similar duck-typed interface and use templates?*/\n+  // should this be public or private?\n+  void expand_invoc (::std::unique_ptr<AST::MacroInvocation> &invoc);\n+\n+  // TODO: make it extend ASTVisitor so that individual items can be accessed\n+  // properly?\n+\n+private:\n+  AST::Crate &crate;\n+};\n+} // namespace Rust\n+\n+#endif"}, {"sha": "bfd4dda11859fe4b8d503854299d7f9a1c8882fb", "filename": "gcc/rust/lang-specs.h", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flang-specs.h?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -1,21 +1,21 @@\n /* lang-specs.h -- gcc driver specs for Rust frontend.\n-   Copyright (C) 2009-2019 Free Software Foundation, Inc.\n+   Copyright (C) 2009-2020 Free Software Foundation, Inc.\n \n-This file is part of GCC.\n+   This file is part of GCC.\n \n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n \n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n \n /* This is the contribution to the `default_compilers' array in gcc.c\n    for the Rust language.  */"}, {"sha": "0f2e5bd9e1572e8fb23ce048695f8362893d5127", "filename": "gcc/rust/lex/rust-codepoint.h", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Flex%2Frust-codepoint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Flex%2Frust-codepoint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-codepoint.h?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -9,18 +9,19 @@\n #include <string>\n \n namespace Rust {\n-    struct Codepoint {\n-        uint32_t value;\n+struct Codepoint\n+{\n+  uint32_t value;\n \n-        // Creates a zero codepoint.\n-        Codepoint() : value(0) {}\n+  // Creates a zero codepoint.\n+  Codepoint () : value (0) {}\n \n-        // Creates a codepoint from UTF-8 value.\n-        Codepoint(uint32_t value_) : value(value_) {}\n+  // Creates a codepoint from UTF-8 value.\n+  Codepoint (uint32_t value_) : value (value_) {}\n \n-        // Returns a C++ string containing value of codepoint.\n-        ::std::string as_string();\n-    };\n-}\n+  // Returns a C++ string containing value of codepoint.\n+  ::std::string as_string ();\n+};\n+} // namespace Rust\n \n-#endif\n\\ No newline at end of file\n+#endif"}, {"sha": "8dc3e318e04aaed58ff8b15c42b1309778fcbdaa", "filename": "gcc/rust/lex/rust-lex.h", "status": "modified", "additions": 126, "deletions": 122, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Flex%2Frust-lex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Flex%2Frust-lex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.h?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -6,127 +6,131 @@\n #include \"rust-token.h\"\n \n namespace Rust {\n-    class Lexer {\n-      private:\n-        // Request new Location for current column in line_table\n-        Location get_current_location();\n-\n-        // Skips the current input char.\n-        void skip_input();\n-        // Advances current input char to n + 1 chars ahead of current position.\n-        void skip_input(int n);\n-\n-        // Returns char n chars ahead of current position.\n-        int peek_input();\n-        // Peeks the current char.\n-        int peek_input(int n);\n-\n-        // Classifies keyword (i.e. gets id for keyword).\n-        TokenId classify_keyword(const std::string& str);\n-\n-        // Builds a token from the input queue.\n-        TokenPtr build_token();\n-\n-        // ok maybe all these may mean the lexer structure needs to be rethought\n-        /* separated into functions because main method was too long, but they rely on and change\n-         * state in the lexer, so variables must be passed by reference. */\n-        inline void parse_in_decimal(/*char& current_char, */ std::string& str, int& length);\n-        inline void parse_in_exponent_part(/*char& current_char, */ std::string& str, int& length);\n-        inline bool parse_in_type_suffix(\n-          /*char& current_char, */ PrimitiveCoreType& type_hint, int& length);\n-        inline bool parse_ascii_escape(/*char& current_char, */ int& length, char& output_char);\n-        inline bool parse_quote_escape(/*char& current_char, */ int& length, char& output_char);\n-        inline bool parse_unicode_escape(\n-          /*char& current_char, */ int& length, Codepoint& output_char);\n-        inline bool parse_byte_escape(/*char& current_char, */ int& length, char& output_char);\n-        inline bool parse_escape(int& length, char& output_char, char opening_char);\n-        inline bool parse_utf8_escape(int& length, Codepoint& output_char, char opening_char);\n-        inline int test_get_input_codepoint_length();\n-        inline int test_get_input_codepoint_n_length(int n_start_offset);\n-        inline Codepoint test_peek_codepoint_input();\n-        inline Codepoint test_peek_codepoint_input(\n-          int n); // maybe can use get_input_codepoint_length to get starting index\n-        inline void test_skip_codepoint_input();\n-\n-      public:\n-        // Construct lexer with input file and filename provided\n-        Lexer(const char* filename, FILE* input, Linemap* linemap);\n-        ~Lexer();\n-\n-        // Returns token n tokens ahead of current position.\n-        const_TokenPtr peek_token(int n);\n-        // Peeks the current token.\n-        const_TokenPtr peek_token();\n-\n-        // Advances current token to n + 1 tokens ahead of current position.\n-        void skip_token(int n);\n-        // Skips the current token.\n-        void skip_token();\n-\n-        // Replaces the current token with a specified token.\n-        void replace_current_token(TokenPtr replacement);\n-\n-        Linemap* get_line_map() {\n-            return line_map;\n-        }\n-\n-      private:\n-        // File for use as input.\n-        FILE* input;\n-\n-        // Current line number.\n-        int current_line;\n-        // Current column number.\n-        int current_column;\n-        // Line map.\n-        Linemap* line_map;\n-\n-        // Max column number that can be quickly allocated - higher may require allocating new linemap\n-        static const int max_column_hint = 80;\n-\n-        // Input source wrapper thing.\n-        struct InputSource {\n-            // Input source file.\n-            FILE* input;\n-\n-            // Create new input source from file.\n-            InputSource(FILE* input) : input(input) {}\n-\n-            // Overload operator () to return next char from input stream.\n-            int operator()() {\n-                return fgetc(input);\n-            }\n-        };\n-\n-        // The input source for the lexer.\n-        InputSource input_source;\n-        // Input file queue.\n-        buffered_queue<int, InputSource> input_queue;\n-\n-        // Token source wrapper thing.\n-        struct TokenSource {\n-            // The lexer object that will use this TokenSource.\n-            Lexer* lexer;\n-\n-            // Create a new TokenSource with given lexer.\n-            TokenSource(Lexer* parLexer) : lexer(parLexer) {}\n-\n-            // Overload operator () to build token in lexer.\n-            TokenPtr operator()() {\n-                return lexer->build_token();\n-            }\n-        };\n-\n-        // The token source for the lexer.\n-        TokenSource token_source;\n-        // Token stream queue.\n-        buffered_queue<std::shared_ptr<Token>, TokenSource> token_queue;\n-\n-        // START CRAPPY CHANGES\n-        int current_char;\n-\n-        // END CRAPPY CHANGES\n-    };\n-}\n+class Lexer\n+{\n+private:\n+  // Request new Location for current column in line_table\n+  Location get_current_location ();\n+\n+  // Skips the current input char.\n+  void skip_input ();\n+  // Advances current input char to n + 1 chars ahead of current position.\n+  void skip_input (int n);\n+\n+  // Returns char n chars ahead of current position.\n+  int peek_input ();\n+  // Peeks the current char.\n+  int peek_input (int n);\n+\n+  // Classifies keyword (i.e. gets id for keyword).\n+  TokenId classify_keyword (const std::string &str);\n+\n+  // Builds a token from the input queue.\n+  TokenPtr build_token ();\n+\n+  // ok maybe all these may mean the lexer structure needs to be rethought\n+  /* separated into functions because main method was too long, but they rely on\n+   * and change state in the lexer, so variables must be passed by reference. */\n+  inline void parse_in_decimal (/*char& current_char, */ std::string &str,\n+\t\t\t\tint &length);\n+  inline void parse_in_exponent_part (/*char& current_char, */ std::string &str,\n+\t\t\t\t      int &length);\n+  inline bool parse_in_type_suffix (\n+    /*char& current_char, */ PrimitiveCoreType &type_hint, int &length);\n+  inline bool parse_ascii_escape (/*char& current_char, */ int &length,\n+\t\t\t\t  char &output_char);\n+  inline bool parse_quote_escape (/*char& current_char, */ int &length,\n+\t\t\t\t  char &output_char);\n+  inline bool parse_unicode_escape (\n+    /*char& current_char, */ int &length, Codepoint &output_char);\n+  inline bool parse_byte_escape (/*char& current_char, */ int &length,\n+\t\t\t\t char &output_char);\n+  inline bool parse_escape (int &length, char &output_char, char opening_char);\n+  inline bool parse_utf8_escape (int &length, Codepoint &output_char,\n+\t\t\t\t char opening_char);\n+  inline int test_get_input_codepoint_length ();\n+  inline int test_get_input_codepoint_n_length (int n_start_offset);\n+  inline Codepoint test_peek_codepoint_input ();\n+  inline Codepoint test_peek_codepoint_input (\n+    int n); // maybe can use get_input_codepoint_length to get starting index\n+  inline void test_skip_codepoint_input ();\n+\n+public:\n+  // Construct lexer with input file and filename provided\n+  Lexer (const char *filename, FILE *input, Linemap *linemap);\n+  ~Lexer ();\n+\n+  // Returns token n tokens ahead of current position.\n+  const_TokenPtr peek_token (int n);\n+  // Peeks the current token.\n+  const_TokenPtr peek_token ();\n+\n+  // Advances current token to n + 1 tokens ahead of current position.\n+  void skip_token (int n);\n+  // Skips the current token.\n+  void skip_token ();\n+\n+  // Replaces the current token with a specified token.\n+  void replace_current_token (TokenPtr replacement);\n+\n+  Linemap *get_line_map () { return line_map; }\n+\n+private:\n+  // File for use as input.\n+  FILE *input;\n+\n+  // Current line number.\n+  int current_line;\n+  // Current column number.\n+  int current_column;\n+  // Line map.\n+  Linemap *line_map;\n+\n+  // Max column number that can be quickly allocated - higher may require\n+  // allocating new linemap\n+  static const int max_column_hint = 80;\n+\n+  // Input source wrapper thing.\n+  struct InputSource\n+  {\n+    // Input source file.\n+    FILE *input;\n+\n+    // Create new input source from file.\n+    InputSource (FILE *input) : input (input) {}\n+\n+    // Overload operator () to return next char from input stream.\n+    int operator() () { return fgetc (input); }\n+  };\n+\n+  // The input source for the lexer.\n+  InputSource input_source;\n+  // Input file queue.\n+  buffered_queue<int, InputSource> input_queue;\n+\n+  // Token source wrapper thing.\n+  struct TokenSource\n+  {\n+    // The lexer object that will use this TokenSource.\n+    Lexer *lexer;\n+\n+    // Create a new TokenSource with given lexer.\n+    TokenSource (Lexer *parLexer) : lexer (parLexer) {}\n+\n+    // Overload operator () to build token in lexer.\n+    TokenPtr operator() () { return lexer->build_token (); }\n+  };\n+\n+  // The token source for the lexer.\n+  TokenSource token_source;\n+  // Token stream queue.\n+  buffered_queue<std::shared_ptr<Token>, TokenSource> token_queue;\n+\n+  // START CRAPPY CHANGES\n+  int current_char;\n+\n+  // END CRAPPY CHANGES\n+};\n+} // namespace Rust\n \n #endif"}, {"sha": "d8bd661b141c7defc8f6bc0ca1932586df78f786", "filename": "gcc/rust/lex/rust-token.cc", "status": "modified", "additions": 96, "deletions": 80, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Flex%2Frust-token.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Flex%2Frust-token.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-token.cc?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -3,98 +3,114 @@\n #include \"rust-diagnostics.h\" // for error_at\n \n namespace Rust {\n-    // Hackily defined way to get token description for enum value using x-macros\n-    const char* get_token_description(TokenId id) {\n-        switch (id) {\n-#define RS_TOKEN(name, descr) \\\n-    case name:                \\\n-        return descr;\n-#define RS_TOKEN_KEYWORD(x, y) RS_TOKEN(x, y)\n-            RS_TOKEN_LIST\n+// Hackily defined way to get token description for enum value using x-macros\n+const char *\n+get_token_description (TokenId id)\n+{\n+  switch (id)\n+    {\n+#define RS_TOKEN(name, descr)                                                  \\\n+  case name:                                                                   \\\n+    return descr;\n+#define RS_TOKEN_KEYWORD(x, y) RS_TOKEN (x, y)\n+      RS_TOKEN_LIST\n #undef RS_TOKEN_KEYWORD\n #undef RS_TOKEN\n-            default:\n-                gcc_unreachable();\n-        }\n+    default:\n+      gcc_unreachable ();\n     }\n+}\n \n-    // Hackily defined way to get token description as a string for enum value using x-macros\n-    const char* token_id_to_str(TokenId id) {\n-        switch (id) {\n-#define RS_TOKEN(name, _) \\\n-    case name:            \\\n-        return #name;\n-#define RS_TOKEN_KEYWORD(x, y) RS_TOKEN(x, y)\n-            RS_TOKEN_LIST\n+// Hackily defined way to get token description as a string for enum value using\n+// x-macros\n+const char *\n+token_id_to_str (TokenId id)\n+{\n+  switch (id)\n+    {\n+#define RS_TOKEN(name, _)                                                      \\\n+  case name:                                                                   \\\n+    return #name;\n+#define RS_TOKEN_KEYWORD(x, y) RS_TOKEN (x, y)\n+      RS_TOKEN_LIST\n #undef RS_TOKEN_KEYWORD\n #undef RS_TOKEN\n-            default:\n-                gcc_unreachable();\n-        }\n+    default:\n+      gcc_unreachable ();\n     }\n+}\n \n-    const char* get_type_hint_string(PrimitiveCoreType type) {\n-        switch (type) {\n-            case CORETYPE_BOOL:\n-                return \"bool\";\n-            case CORETYPE_CHAR:\n-                return \"char\";\n-            case CORETYPE_STR:\n-                return \"str\";\n-            // case CORETYPE_INT:\n-            case CORETYPE_ISIZE:\n-                return \"isize\";\n-            // case CORETYPE_UINT:\n-            case CORETYPE_USIZE:\n-                return \"usize\";\n-            case CORETYPE_F32:\n-                return \"f32\";\n-            case CORETYPE_F64:\n-                return \"f64\";\n-            case CORETYPE_I8:\n-                return \"i8\";\n-            case CORETYPE_I16:\n-                return \"i16\";\n-            case CORETYPE_I32:\n-                return \"i32\";\n-            case CORETYPE_I64:\n-                return \"i64\";\n-            case CORETYPE_I128:\n-                return \"i128\";\n-            case CORETYPE_U8:\n-                return \"u8\";\n-            case CORETYPE_U16:\n-                return \"u16\";\n-            case CORETYPE_U32:\n-                return \"u32\";\n-            case CORETYPE_U64:\n-                return \"u64\";\n-            case CORETYPE_U128:\n-                return \"u128\";\n-            case CORETYPE_UNKNOWN:\n-            default:\n-                return \"unknown\";\n-        }\n+const char *\n+get_type_hint_string (PrimitiveCoreType type)\n+{\n+  switch (type)\n+    {\n+    case CORETYPE_BOOL:\n+      return \"bool\";\n+    case CORETYPE_CHAR:\n+      return \"char\";\n+    case CORETYPE_STR:\n+      return \"str\";\n+    // case CORETYPE_INT:\n+    case CORETYPE_ISIZE:\n+      return \"isize\";\n+    // case CORETYPE_UINT:\n+    case CORETYPE_USIZE:\n+      return \"usize\";\n+    case CORETYPE_F32:\n+      return \"f32\";\n+    case CORETYPE_F64:\n+      return \"f64\";\n+    case CORETYPE_I8:\n+      return \"i8\";\n+    case CORETYPE_I16:\n+      return \"i16\";\n+    case CORETYPE_I32:\n+      return \"i32\";\n+    case CORETYPE_I64:\n+      return \"i64\";\n+    case CORETYPE_I128:\n+      return \"i128\";\n+    case CORETYPE_U8:\n+      return \"u8\";\n+    case CORETYPE_U16:\n+      return \"u16\";\n+    case CORETYPE_U32:\n+      return \"u32\";\n+    case CORETYPE_U64:\n+      return \"u64\";\n+    case CORETYPE_U128:\n+      return \"u128\";\n+    case CORETYPE_UNKNOWN:\n+    default:\n+      return \"unknown\";\n     }\n+}\n \n-    const char* Token::get_type_hint_str() const {\n-        return get_type_hint_string(type_hint);\n-    }\n+const char *\n+Token::get_type_hint_str () const\n+{\n+  return get_type_hint_string (type_hint);\n+}\n \n-    const ::std::string& Token::get_str() const {\n-        // FIXME: attempt to return null again\n-        // gcc_assert(str != NULL);\n+const ::std::string &\n+Token::get_str () const\n+{\n+  // FIXME: attempt to return null again\n+  // gcc_assert(str != NULL);\n \n-        // HACK: allow referencing an empty string\n-        static const ::std::string empty = \"\";\n+  // HACK: allow referencing an empty string\n+  static const ::std::string empty = \"\";\n \n-        if (str == NULL) {\n-            rust_error_at(get_locus(),\n-              \"attempted to get string for '%s', which has no string. returning empty string \"\n-              \"instead.\",\n-              get_token_description());\n-            return empty;\n-        }\n-        return *str;\n+  if (str == NULL)\n+    {\n+      rust_error_at (get_locus (),\n+\t\t     \"attempted to get string for '%s', which has no string. \"\n+\t\t     \"returning empty string \"\n+\t\t     \"instead.\",\n+\t\t     get_token_description ());\n+      return empty;\n     }\n+  return *str;\n }\n+} // namespace Rust"}, {"sha": "2270fa2ebe8d53e4f8bfecc6baaee2388fc74195", "filename": "gcc/rust/lex/rust-token.h", "status": "modified", "additions": 386, "deletions": 355, "changes": 741, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Flex%2Frust-token.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Flex%2Frust-token.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-token.h?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -16,371 +16,402 @@\n #include \"rust-codepoint.h\"\n \n namespace Rust {\n-    // \"Primitive core types\" in Rust - the different int and float types, as well as some others\n-    enum PrimitiveCoreType {\n-        CORETYPE_UNKNOWN,\n-        // named primitives\n-        CORETYPE_BOOL,\n-        CORETYPE_CHAR,\n-        CORETYPE_STR,\n-        // okay technically int and uint are arch-dependent (pointer size)\n-        CORETYPE_INT,\n-        CORETYPE_UINT,\n-        // numbered number primitives\n-        CORETYPE_F32,\n-        CORETYPE_F64,\n-        CORETYPE_I8,\n-        CORETYPE_I16,\n-        CORETYPE_I32,\n-        CORETYPE_I64,\n-        CORETYPE_I128,\n-        CORETYPE_U8,\n-        CORETYPE_U16,\n-        CORETYPE_U32,\n-        CORETYPE_U64,\n-        CORETYPE_U128,\n-        // arch-dependent pointer sizes\n-        CORETYPE_ISIZE = CORETYPE_INT,\n-        CORETYPE_USIZE = CORETYPE_UINT\n-    };\n+// \"Primitive core types\" in Rust - the different int and float types, as well\n+// as some others\n+enum PrimitiveCoreType\n+{\n+  CORETYPE_UNKNOWN,\n+  // named primitives\n+  CORETYPE_BOOL,\n+  CORETYPE_CHAR,\n+  CORETYPE_STR,\n+  // okay technically int and uint are arch-dependent (pointer size)\n+  CORETYPE_INT,\n+  CORETYPE_UINT,\n+  // numbered number primitives\n+  CORETYPE_F32,\n+  CORETYPE_F64,\n+  CORETYPE_I8,\n+  CORETYPE_I16,\n+  CORETYPE_I32,\n+  CORETYPE_I64,\n+  CORETYPE_I128,\n+  CORETYPE_U8,\n+  CORETYPE_U16,\n+  CORETYPE_U32,\n+  CORETYPE_U64,\n+  CORETYPE_U128,\n+  // arch-dependent pointer sizes\n+  CORETYPE_ISIZE = CORETYPE_INT,\n+  CORETYPE_USIZE = CORETYPE_UINT\n+};\n \n // RS_TOKEN(name, description)\n // RS_TOKEN_KEYWORD(name, identifier)\n //\n // Keep RS_TOKEN_KEYWORD sorted\n \n-// note that abstract, async, become, box, do, final, macro, override, priv, try, typeof, unsized,\n-// virtual, and yield are unused\n+// note that abstract, async, become, box, do, final, macro, override, priv,\n+// try, typeof, unsized, virtual, and yield are unused\n // TODO finish converting to rust keywords\n-#define RS_TOKEN_LIST                                                                         \\\n-    RS_TOKEN(FIRST_TOKEN, \"<first-token-marker>\")                                             \\\n-    RS_TOKEN(END_OF_FILE, \"end of file\")                                                      \\\n-    RS_TOKEN(EXCLAM, \"!\")                                                                     \\\n-    RS_TOKEN(NOT_EQUAL, \"!=\")                                                                 \\\n-    RS_TOKEN(PERCENT, \"%\")                                                                    \\\n-    RS_TOKEN(PERCENT_EQ, \"%=\")                                                                \\\n-    RS_TOKEN(AMP, \"&\")                                                                        \\\n-    RS_TOKEN(AMP_EQ, \"&=\")                                                                    \\\n-    RS_TOKEN(LOGICAL_AND, \"&&\")                                                               \\\n-    RS_TOKEN(ASTERISK, \"*\")                                                                   \\\n-    RS_TOKEN(ASTERISK_EQ, \"*=\")                                                               \\\n-    RS_TOKEN(PLUS, \"+\")                                                                       \\\n-    RS_TOKEN(PLUS_EQ, \"+=\")                                                                   \\\n-    RS_TOKEN(COMMA, \",\")                                                                      \\\n-    RS_TOKEN(MINUS, \"-\")                                                                      \\\n-    RS_TOKEN(MINUS_EQ, \"-=\")                                                                  \\\n-    RS_TOKEN(RETURN_TYPE, \"->\")                                                               \\\n-    RS_TOKEN(DOT, \".\")                                                                        \\\n-    RS_TOKEN(DOT_DOT, \"..\")                                                                   \\\n-    RS_TOKEN(DOT_DOT_EQ, \"..=\")                                                               \\\n-    RS_TOKEN(ELLIPSIS, \"...\")                                                                 \\\n-    RS_TOKEN(DIV, \"/\")                                                                        \\\n-    RS_TOKEN(DIV_EQ, \"/=\")                                                                    \\\n-    RS_TOKEN(COLON, \":\")                                                                      \\\n-    RS_TOKEN(SEMICOLON, \";\")                                                                  \\\n-    RS_TOKEN(LEFT_SHIFT, \"<<\")                                                                \\\n-    RS_TOKEN(LEFT_SHIFT_EQ, \"<<=\")                                                            \\\n-    RS_TOKEN(LEFT_ANGLE, \"<\")                                                                 \\\n-    RS_TOKEN(LESS_OR_EQUAL, \"<=\")                                                             \\\n-    RS_TOKEN(EQUAL, \"=\")                                                                      \\\n-    RS_TOKEN(EQUAL_EQUAL, \"==\")                                                               \\\n-    RS_TOKEN(MATCH_ARROW, \"=>\")                                                               \\\n-    RS_TOKEN(RIGHT_ANGLE, \">\")                                                                \\\n-    RS_TOKEN(GREATER_OR_EQUAL, \">=\")                                                          \\\n-    RS_TOKEN(RIGHT_SHIFT, \">>\")                                                               \\\n-    RS_TOKEN(RIGHT_SHIFT_EQ, \">>=\")                                                           \\\n-    RS_TOKEN(PATTERN_BIND, \"@\")                                                               \\\n-    RS_TOKEN(TILDE, \"~\")                                                                      \\\n-    RS_TOKEN(BACKSLASH, \"\\\\\")                                                                 \\\n-    RS_TOKEN(BACKTICK, \"`\")                                                                   \\\n-    RS_TOKEN(CARET, \"^\")                                                                      \\\n-    RS_TOKEN(CARET_EQ, \"^=\")                                                                  \\\n-    RS_TOKEN(PIPE, \"|\")                                                                       \\\n-    RS_TOKEN(PIPE_EQ, \"|=\")                                                                   \\\n-    RS_TOKEN(OR, \"||\")                                                                        \\\n-    RS_TOKEN(QUESTION_MARK, \"?\")                                                              \\\n-    RS_TOKEN(HASH, \"#\")                                                                       \\\n-    /* from here on, dodgy and may not be correct. not operators and may be symbols */        \\\n-    /* RS_TOKEN(SPACE, \" \") probably too dodgy */                                             \\\n-    /* RS_TOKEN(NEWLINE, \"\\n\")*/                                                              \\\n-    RS_TOKEN(SCOPE_RESOLUTION, \"::\") /* dodgy */                                              \\\n-    RS_TOKEN(SINGLE_QUOTE, \"'\")      /* should i differentiate from lifetime? */              \\\n-    RS_TOKEN(DOUBLE_QUOTE, \"\\\"\")                                                              \\\n-    RS_TOKEN(UNDERSCORE, \"_\") /* TODO: treat as reserved word like mrustc instead? */         \\\n-    RS_TOKEN(IDENTIFIER, \"identifier\")                                                        \\\n-    RS_TOKEN(INT_LITERAL,                                                                     \\\n-      \"integer literal\") /* do different int and float types need different literal types? */ \\\n-    RS_TOKEN(FLOAT_LITERAL, \"float literal\")                                                  \\\n-    RS_TOKEN(STRING_LITERAL, \"string literal\")                                                \\\n-    RS_TOKEN(CHAR_LITERAL, \"character literal\")                                               \\\n-    RS_TOKEN(BYTE_STRING_LITERAL, \"byte string literal\")                                      \\\n-    RS_TOKEN(BYTE_CHAR_LITERAL, \"byte character literal\")                                     \\\n-    RS_TOKEN(LIFETIME, \"lifetime\") /* TODO: improve token type */                             \\\n-    /* Have \"interpolated\" tokens (whatever that means)? identifer, path, type, pattern, */   \\\n-    /* expression, statement, block, meta, item in mrustc (but not directly in lexer). */     \\\n-    RS_TOKEN(LEFT_PAREN, \"(\")                                                                 \\\n-    RS_TOKEN(RIGHT_PAREN, \")\")                                                                \\\n-    RS_TOKEN(LEFT_CURLY, \"{\")                                                                 \\\n-    RS_TOKEN(RIGHT_CURLY, \"}\")                                                                \\\n-    RS_TOKEN(LEFT_SQUARE, \"[\")                                                                \\\n-    RS_TOKEN(RIGHT_SQUARE, \"]\")                                                               \\\n-    /* Macros */                                                                              \\\n-    RS_TOKEN(DOLLAR_SIGN, \"$\")                                                                \\\n-    /* Comments */                                                                            \\\n-    RS_TOKEN(LINE_COMMENT, \"//\")                                                              \\\n-    RS_TOKEN(INNER_LINE_DOC, \"//!\")                                                           \\\n-    RS_TOKEN(OUTER_LINE_DOC, \"///\")                                                           \\\n-    RS_TOKEN(BLOCK_COMMENT_START, \"/*\")                                                       \\\n-    RS_TOKEN(BLOCK_COMMENT_END, \"*/\")                                                         \\\n-    RS_TOKEN(INNER_BLOCK_DOC_START, \"/*!\")                                                    \\\n-    RS_TOKEN(OUTER_BLOCK_DOC_START, \"/**\")  /* have \"weak\" union and 'static keywords? */     \\\n-                                                                                              \\\n-    RS_TOKEN_KEYWORD(ABSTRACT, \"abstract\") /* unused */                                       \\\n-    RS_TOKEN_KEYWORD(AS, \"as\")                                                                \\\n-    RS_TOKEN_KEYWORD(ASYNC, \"async\")   /* unused */                                           \\\n-    RS_TOKEN_KEYWORD(BECOME, \"become\") /* unused */                                           \\\n-    RS_TOKEN_KEYWORD(BOX, \"box\")       /* unused */                                           \\\n-    RS_TOKEN_KEYWORD(BREAK, \"break\")                                                          \\\n-    RS_TOKEN_KEYWORD(CONST, \"const\")                                                          \\\n-    RS_TOKEN_KEYWORD(CONTINUE, \"continue\")                                                    \\\n-    RS_TOKEN_KEYWORD(CRATE, \"crate\")                                                          \\\n-    RS_TOKEN_KEYWORD(DO, \"do\") /* unused */                                                   \\\n-    RS_TOKEN_KEYWORD(DYN, \"dyn\")                                                              \\\n-    RS_TOKEN_KEYWORD(ELSE, \"else\")                                                            \\\n-    RS_TOKEN_KEYWORD(ENUM_TOK, \"enum\")                                                        \\\n-    RS_TOKEN_KEYWORD(EXTERN_TOK, \"extern\")                                                    \\\n-    RS_TOKEN_KEYWORD(FALSE_LITERAL, \"false\")                                                  \\\n-    RS_TOKEN_KEYWORD(FINAL_TOK, \"final\") /* unused */                                         \\\n-    RS_TOKEN_KEYWORD(FN_TOK, \"fn\")                                                            \\\n-    RS_TOKEN_KEYWORD(FOR, \"for\")                                                              \\\n-    RS_TOKEN_KEYWORD(IF, \"if\")                                                                \\\n-    RS_TOKEN_KEYWORD(IMPL, \"impl\")                                                            \\\n-    RS_TOKEN_KEYWORD(IN, \"in\")                                                                \\\n-    RS_TOKEN_KEYWORD(LET, \"let\")                                                              \\\n-    RS_TOKEN_KEYWORD(LOOP, \"loop\")                                                            \\\n-    RS_TOKEN_KEYWORD(MACRO, \"macro\") /* unused */                                             \\\n-    RS_TOKEN_KEYWORD(MATCH_TOK, \"match\")                                                      \\\n-    RS_TOKEN_KEYWORD(MOD, \"mod\")                                                              \\\n-    RS_TOKEN_KEYWORD(MOVE, \"move\")                                                            \\\n-    RS_TOKEN_KEYWORD(MUT, \"mut\")                                                              \\\n-    RS_TOKEN_KEYWORD(OVERRIDE_TOK, \"override\") /* unused */                                   \\\n-    RS_TOKEN_KEYWORD(PRIV, \"priv\")             /* unused */                                   \\\n-    RS_TOKEN_KEYWORD(PUB, \"pub\")                                                              \\\n-    RS_TOKEN_KEYWORD(REF, \"ref\")                                                              \\\n-    RS_TOKEN_KEYWORD(RETURN_TOK, \"return\")                                                    \\\n-    RS_TOKEN_KEYWORD(SELF_ALIAS, \"Self\") /* mrustc does not treat this as a reserved word*/   \\\n-    RS_TOKEN_KEYWORD(SELF, \"self\")                                                            \\\n-    RS_TOKEN_KEYWORD(STATIC_TOK, \"static\")                                                    \\\n-    RS_TOKEN_KEYWORD(STRUCT_TOK, \"struct\")                                                    \\\n-    RS_TOKEN_KEYWORD(SUPER, \"super\")                                                          \\\n-    RS_TOKEN_KEYWORD(TRAIT, \"trait\")                                                          \\\n-    RS_TOKEN_KEYWORD(TRUE_LITERAL, \"true\")                                                    \\\n-    RS_TOKEN_KEYWORD(TRY, \"try\") /* unused */                                                 \\\n-    RS_TOKEN_KEYWORD(TYPE, \"type\")                                                            \\\n-    RS_TOKEN_KEYWORD(TYPEOF, \"typeof\") /* unused */                                           \\\n-    RS_TOKEN_KEYWORD(UNSAFE, \"unsafe\")                                                        \\\n-    RS_TOKEN_KEYWORD(UNSIZED, \"unsized\") /* unused */                                         \\\n-    RS_TOKEN_KEYWORD(USE, \"use\")                                                              \\\n-    RS_TOKEN_KEYWORD(VIRTUAL, \"virtual\") /* unused */                                         \\\n-    RS_TOKEN_KEYWORD(WHERE, \"where\")                                                          \\\n-    RS_TOKEN_KEYWORD(WHILE, \"while\")                                                          \\\n-    RS_TOKEN_KEYWORD(YIELD, \"yield\") /* unused */                                             \\\n-                                                                                              \\\n-    RS_TOKEN(LAST_TOKEN, \"<last-token-marker>\")\n-\n-    // Contains all token types. Crappy implementation via x-macros.\n-    enum TokenId {\n+#define RS_TOKEN_LIST                                                          \\\n+  RS_TOKEN (FIRST_TOKEN, \"<first-token-marker>\")                               \\\n+  RS_TOKEN (END_OF_FILE, \"end of file\")                                        \\\n+  RS_TOKEN (EXCLAM, \"!\")                                                       \\\n+  RS_TOKEN (NOT_EQUAL, \"!=\")                                                   \\\n+  RS_TOKEN (PERCENT, \"%\")                                                      \\\n+  RS_TOKEN (PERCENT_EQ, \"%=\")                                                  \\\n+  RS_TOKEN (AMP, \"&\")                                                          \\\n+  RS_TOKEN (AMP_EQ, \"&=\")                                                      \\\n+  RS_TOKEN (LOGICAL_AND, \"&&\")                                                 \\\n+  RS_TOKEN (ASTERISK, \"*\")                                                     \\\n+  RS_TOKEN (ASTERISK_EQ, \"*=\")                                                 \\\n+  RS_TOKEN (PLUS, \"+\")                                                         \\\n+  RS_TOKEN (PLUS_EQ, \"+=\")                                                     \\\n+  RS_TOKEN (COMMA, \",\")                                                        \\\n+  RS_TOKEN (MINUS, \"-\")                                                        \\\n+  RS_TOKEN (MINUS_EQ, \"-=\")                                                    \\\n+  RS_TOKEN (RETURN_TYPE, \"->\")                                                 \\\n+  RS_TOKEN (DOT, \".\")                                                          \\\n+  RS_TOKEN (DOT_DOT, \"..\")                                                     \\\n+  RS_TOKEN (DOT_DOT_EQ, \"..=\")                                                 \\\n+  RS_TOKEN (ELLIPSIS, \"...\")                                                   \\\n+  RS_TOKEN (DIV, \"/\")                                                          \\\n+  RS_TOKEN (DIV_EQ, \"/=\")                                                      \\\n+  RS_TOKEN (COLON, \":\")                                                        \\\n+  RS_TOKEN (SEMICOLON, \";\")                                                    \\\n+  RS_TOKEN (LEFT_SHIFT, \"<<\")                                                  \\\n+  RS_TOKEN (LEFT_SHIFT_EQ, \"<<=\")                                              \\\n+  RS_TOKEN (LEFT_ANGLE, \"<\")                                                   \\\n+  RS_TOKEN (LESS_OR_EQUAL, \"<=\")                                               \\\n+  RS_TOKEN (EQUAL, \"=\")                                                        \\\n+  RS_TOKEN (EQUAL_EQUAL, \"==\")                                                 \\\n+  RS_TOKEN (MATCH_ARROW, \"=>\")                                                 \\\n+  RS_TOKEN (RIGHT_ANGLE, \">\")                                                  \\\n+  RS_TOKEN (GREATER_OR_EQUAL, \">=\")                                            \\\n+  RS_TOKEN (RIGHT_SHIFT, \">>\")                                                 \\\n+  RS_TOKEN (RIGHT_SHIFT_EQ, \">>=\")                                             \\\n+  RS_TOKEN (PATTERN_BIND, \"@\")                                                 \\\n+  RS_TOKEN (TILDE, \"~\")                                                        \\\n+  RS_TOKEN (BACKSLASH, \"\\\\\")                                                   \\\n+  RS_TOKEN (BACKTICK, \"`\")                                                     \\\n+  RS_TOKEN (CARET, \"^\")                                                        \\\n+  RS_TOKEN (CARET_EQ, \"^=\")                                                    \\\n+  RS_TOKEN (PIPE, \"|\")                                                         \\\n+  RS_TOKEN (PIPE_EQ, \"|=\")                                                     \\\n+  RS_TOKEN (OR, \"||\")                                                          \\\n+  RS_TOKEN (QUESTION_MARK, \"?\")                                                \\\n+  RS_TOKEN (HASH, \"#\")                                                         \\\n+  /* from here on, dodgy and may not be correct. not operators and may be      \\\n+   * symbols */                                                                \\\n+  /* RS_TOKEN(SPACE, \" \") probably too dodgy */                                \\\n+  /* RS_TOKEN(NEWLINE, \"\\n\")*/                                                 \\\n+  RS_TOKEN (SCOPE_RESOLUTION, \"::\") /* dodgy */                                \\\n+  RS_TOKEN (SINGLE_QUOTE, \"'\") /* should i differentiate from lifetime? */     \\\n+  RS_TOKEN (DOUBLE_QUOTE, \"\\\"\")                                                \\\n+  RS_TOKEN (UNDERSCORE,                                                        \\\n+\t    \"_\") /* TODO: treat as reserved word like mrustc instead? */       \\\n+  RS_TOKEN (IDENTIFIER, \"identifier\")                                          \\\n+  RS_TOKEN (INT_LITERAL,                                                       \\\n+\t    \"integer literal\") /* do different int and float types need        \\\n+\t\t\t\t  different literal types? */                  \\\n+  RS_TOKEN (FLOAT_LITERAL, \"float literal\")                                    \\\n+  RS_TOKEN (STRING_LITERAL, \"string literal\")                                  \\\n+  RS_TOKEN (CHAR_LITERAL, \"character literal\")                                 \\\n+  RS_TOKEN (BYTE_STRING_LITERAL, \"byte string literal\")                        \\\n+  RS_TOKEN (BYTE_CHAR_LITERAL, \"byte character literal\")                       \\\n+  RS_TOKEN (LIFETIME, \"lifetime\") /* TODO: improve token type */               \\\n+  /* Have \"interpolated\" tokens (whatever that means)? identifer, path, type,  \\\n+   * pattern, */                                                               \\\n+  /* expression, statement, block, meta, item in mrustc (but not directly in   \\\n+   * lexer). */                                                                \\\n+  RS_TOKEN (LEFT_PAREN, \"(\")                                                   \\\n+  RS_TOKEN (RIGHT_PAREN, \")\")                                                  \\\n+  RS_TOKEN (LEFT_CURLY, \"{\")                                                   \\\n+  RS_TOKEN (RIGHT_CURLY, \"}\")                                                  \\\n+  RS_TOKEN (LEFT_SQUARE, \"[\")                                                  \\\n+  RS_TOKEN (RIGHT_SQUARE, \"]\")                                                 \\\n+  /* Macros */                                                                 \\\n+  RS_TOKEN (DOLLAR_SIGN, \"$\")                                                  \\\n+  /* Comments */                                                               \\\n+  RS_TOKEN (LINE_COMMENT, \"//\")                                                \\\n+  RS_TOKEN (INNER_LINE_DOC, \"//!\")                                             \\\n+  RS_TOKEN (OUTER_LINE_DOC, \"///\")                                             \\\n+  RS_TOKEN (BLOCK_COMMENT_START, \"/*\")                                         \\\n+  RS_TOKEN (BLOCK_COMMENT_END, \"*/\")                                           \\\n+  RS_TOKEN (INNER_BLOCK_DOC_START, \"/*!\")                                      \\\n+  RS_TOKEN (OUTER_BLOCK_DOC_START,                                             \\\n+\t    \"/**\") /* have \"weak\" union and 'static keywords? */               \\\n+                                                                               \\\n+  RS_TOKEN_KEYWORD (ABSTRACT, \"abstract\") /* unused */                         \\\n+  RS_TOKEN_KEYWORD (AS, \"as\")                                                  \\\n+  RS_TOKEN_KEYWORD (ASYNC, \"async\")   /* unused */                             \\\n+  RS_TOKEN_KEYWORD (BECOME, \"become\") /* unused */                             \\\n+  RS_TOKEN_KEYWORD (BOX, \"box\")       /* unused */                             \\\n+  RS_TOKEN_KEYWORD (BREAK, \"break\")                                            \\\n+  RS_TOKEN_KEYWORD (CONST, \"const\")                                            \\\n+  RS_TOKEN_KEYWORD (CONTINUE, \"continue\")                                      \\\n+  RS_TOKEN_KEYWORD (CRATE, \"crate\")                                            \\\n+  RS_TOKEN_KEYWORD (DO, \"do\") /* unused */                                     \\\n+  RS_TOKEN_KEYWORD (DYN, \"dyn\")                                                \\\n+  RS_TOKEN_KEYWORD (ELSE, \"else\")                                              \\\n+  RS_TOKEN_KEYWORD (ENUM_TOK, \"enum\")                                          \\\n+  RS_TOKEN_KEYWORD (EXTERN_TOK, \"extern\")                                      \\\n+  RS_TOKEN_KEYWORD (FALSE_LITERAL, \"false\")                                    \\\n+  RS_TOKEN_KEYWORD (FINAL_TOK, \"final\") /* unused */                           \\\n+  RS_TOKEN_KEYWORD (FN_TOK, \"fn\")                                              \\\n+  RS_TOKEN_KEYWORD (FOR, \"for\")                                                \\\n+  RS_TOKEN_KEYWORD (IF, \"if\")                                                  \\\n+  RS_TOKEN_KEYWORD (IMPL, \"impl\")                                              \\\n+  RS_TOKEN_KEYWORD (IN, \"in\")                                                  \\\n+  RS_TOKEN_KEYWORD (LET, \"let\")                                                \\\n+  RS_TOKEN_KEYWORD (LOOP, \"loop\")                                              \\\n+  RS_TOKEN_KEYWORD (MACRO, \"macro\") /* unused */                               \\\n+  RS_TOKEN_KEYWORD (MATCH_TOK, \"match\")                                        \\\n+  RS_TOKEN_KEYWORD (MOD, \"mod\")                                                \\\n+  RS_TOKEN_KEYWORD (MOVE, \"move\")                                              \\\n+  RS_TOKEN_KEYWORD (MUT, \"mut\")                                                \\\n+  RS_TOKEN_KEYWORD (OVERRIDE_TOK, \"override\") /* unused */                     \\\n+  RS_TOKEN_KEYWORD (PRIV, \"priv\")\t     /* unused */                     \\\n+  RS_TOKEN_KEYWORD (PUB, \"pub\")                                                \\\n+  RS_TOKEN_KEYWORD (REF, \"ref\")                                                \\\n+  RS_TOKEN_KEYWORD (RETURN_TOK, \"return\")                                      \\\n+  RS_TOKEN_KEYWORD (SELF_ALIAS,                                                \\\n+\t\t    \"Self\") /* mrustc does not treat this as a reserved word*/ \\\n+  RS_TOKEN_KEYWORD (SELF, \"self\")                                              \\\n+  RS_TOKEN_KEYWORD (STATIC_TOK, \"static\")                                      \\\n+  RS_TOKEN_KEYWORD (STRUCT_TOK, \"struct\")                                      \\\n+  RS_TOKEN_KEYWORD (SUPER, \"super\")                                            \\\n+  RS_TOKEN_KEYWORD (TRAIT, \"trait\")                                            \\\n+  RS_TOKEN_KEYWORD (TRUE_LITERAL, \"true\")                                      \\\n+  RS_TOKEN_KEYWORD (TRY, \"try\") /* unused */                                   \\\n+  RS_TOKEN_KEYWORD (TYPE, \"type\")                                              \\\n+  RS_TOKEN_KEYWORD (TYPEOF, \"typeof\") /* unused */                             \\\n+  RS_TOKEN_KEYWORD (UNSAFE, \"unsafe\")                                          \\\n+  RS_TOKEN_KEYWORD (UNSIZED, \"unsized\") /* unused */                           \\\n+  RS_TOKEN_KEYWORD (USE, \"use\")                                                \\\n+  RS_TOKEN_KEYWORD (VIRTUAL, \"virtual\") /* unused */                           \\\n+  RS_TOKEN_KEYWORD (WHERE, \"where\")                                            \\\n+  RS_TOKEN_KEYWORD (WHILE, \"while\")                                            \\\n+  RS_TOKEN_KEYWORD (YIELD, \"yield\") /* unused */                               \\\n+                                                                               \\\n+  RS_TOKEN (LAST_TOKEN, \"<last-token-marker>\")\n+\n+// Contains all token types. Crappy implementation via x-macros.\n+enum TokenId\n+{\n #define RS_TOKEN(name, _) name,\n-#define RS_TOKEN_KEYWORD(x, y) RS_TOKEN(x, y)\n-        RS_TOKEN_LIST\n+#define RS_TOKEN_KEYWORD(x, y) RS_TOKEN (x, y)\n+  RS_TOKEN_LIST\n #undef RS_TOKEN_KEYWORD\n #undef RS_TOKEN\n-    };\n-\n-    // dodgy \"TokenPtr\" declaration with Token forward declaration\n-    class Token;\n-    // A smart pointer (shared_ptr) to Token.\n-    typedef ::std::shared_ptr<Token> TokenPtr;\n-    // A smart pointer (shared_ptr) to a constant Token.\n-    typedef ::std::shared_ptr<const Token> const_TokenPtr;\n-\n-    // Hackily defined way to get token description for enum value using x-macros\n-    const char* get_token_description(TokenId id);\n-    // Hackily defined way to get token description as a string for enum value using x-macros\n-    const char* token_id_to_str(TokenId id);\n-    // Get type hint description as a string.\n-    const char* get_type_hint_string(PrimitiveCoreType type);\n-\n-    // Represents a single token. Create using factory static methods.\n-    class Token {\n-      private:\n-        // Token kind.\n-        TokenId token_id;\n-        // Token location.\n-        Location locus;\n-        // Associated text (if any) of token.\n-        ::std::string* str;\n-        // Type hint for token based on lexer data (e.g. type suffix). Does not exist for most tokens.\n-        PrimitiveCoreType type_hint;\n-\n-        // Token constructor from token id and location. Has a null string.\n-        Token(TokenId token_id, Location location) :\n-          token_id(token_id), locus(location), str(NULL), type_hint(CORETYPE_UNKNOWN) {}\n-\n-        // Token constructor from token id, location, and a string.\n-        Token(TokenId token_id, Location location, const ::std::string& paramStr) :\n-          token_id(token_id), locus(location), str(new ::std::string(paramStr)),\n-          type_hint(CORETYPE_UNKNOWN) {}\n-\n-        // Token constructor from token id, location, and a char.\n-        Token(TokenId token_id, Location location, char paramChar) :\n-          token_id(token_id), locus(location), str(new ::std::string(1, paramChar)),\n-          type_hint(CORETYPE_UNKNOWN) {}\n-\n-        // Token constructor from token id, location, and a \"codepoint\".\n-        Token(TokenId token_id, Location location, Codepoint paramCodepoint) :\n-          token_id(token_id), locus(location), str(new ::std::string(paramCodepoint.as_string())),\n-          type_hint(CORETYPE_UNKNOWN) {}\n-\n-        // Token constructor from token id, location, a string, and type hint.\n-        Token(TokenId token_id, Location location, const ::std::string& paramStr,\n-          PrimitiveCoreType parType) :\n-          token_id(token_id),\n-          locus(location), str(new ::std::string(paramStr)), type_hint(parType) {}\n-\n-        // No default initialiser.\n-        Token();\n-        // Do not copy/assign tokens.\n-        Token(const Token&);\n-        Token& operator=(const Token&);\n-\n-      public:\n-        ~Token() {\n-            delete str;\n-        }\n-\n-        // Makes and returns a new TokenPtr (with null string).\n-        static TokenPtr make(TokenId token_id, Location locus) {\n-            return TokenPtr(new Token(token_id, locus));\n-        }\n-\n-        // Makes and returns a new TokenPtr of type IDENTIFIER.\n-        static TokenPtr make_identifier(Location locus, const ::std::string& str) {\n-            return TokenPtr(new Token(IDENTIFIER, locus, str));\n-        }\n-\n-        // Makes and returns a new TokenPtr of type INT_LITERAL.\n-        static TokenPtr make_int(Location locus, const ::std::string& str) {\n-            return TokenPtr(new Token(INT_LITERAL, locus, str));\n-        }\n-\n-        // Makes and returns a new TokenPtr of type INT_LITERAL.\n-        static TokenPtr make_int(\n-          Location locus, const ::std::string& str, PrimitiveCoreType type_hint) {\n-            return TokenPtr(new Token(INT_LITERAL, locus, str, type_hint));\n-        }\n-\n-        // Makes and returns a new TokenPtr of type FLOAT_LITERAL.\n-        static TokenPtr make_float(Location locus, const ::std::string& str) {\n-            return TokenPtr(new Token(FLOAT_LITERAL, locus, str));\n-        }\n-\n-        // Makes and returns a new TokenPtr of type FLOAT_LITERAL.\n-        static TokenPtr make_float(\n-          Location locus, const ::std::string& str, PrimitiveCoreType type_hint) {\n-            return TokenPtr(new Token(FLOAT_LITERAL, locus, str, type_hint));\n-        }\n-\n-        // Makes and returns a new TokenPtr of type STRING_LITERAL.\n-        static TokenPtr make_string(Location locus, const ::std::string& str) {\n-            return TokenPtr(new Token(STRING_LITERAL, locus, str, CORETYPE_STR));\n-        }\n-\n-        // Makes and returns a new TokenPtr of type CHAR_LITERAL (fix).\n-        static TokenPtr make_char(Location locus, Codepoint char_lit) {\n-            return TokenPtr(new Token(CHAR_LITERAL, locus, char_lit));\n-        }\n-\n-        // Makes and returns a new TokenPtr of type BYTE_CHAR_LITERAL (fix).\n-        static TokenPtr make_byte_char(Location locus, char byte_char) {\n-            return TokenPtr(new Token(BYTE_CHAR_LITERAL, locus, byte_char));\n-        }\n-\n-        // Makes and returns a new TokenPtr of type BYTE_STRING_LITERAL (fix).\n-        static TokenPtr make_byte_string(Location locus, const ::std::string& str) {\n-            return TokenPtr(new Token(BYTE_STRING_LITERAL, locus, str));\n-        }\n-\n-        // Makes and returns a new TokenPtr of type LIFETIME.\n-        static TokenPtr make_lifetime(Location locus, const ::std::string& str) {\n-            return TokenPtr(new Token(LIFETIME, locus, str));\n-        }\n-\n-        // Gets id of the token.\n-        TokenId get_id() const {\n-            return token_id;\n-        }\n-\n-        // Gets location of the token.\n-        Location get_locus() const {\n-            return locus;\n-        }\n-\n-        // Gets string description of the token.\n-        const ::std::string& get_str() const; /*{\n-            // FIXME: put in header again when fix null problem\n-            //gcc_assert(str != NULL);\n-            if (str == NULL) {\n-                error_at(get_locus(), \"attempted to get string for '%s', which has no string. returning empty string instead.\", get_token_description());\n-                return \"\";\n-            }\n-            return *str;\n-        }*/\n-\n-        // Gets token's type hint info.\n-        PrimitiveCoreType get_type_hint() const {\n-            return type_hint;\n-        }\n-\n-        // diagnostics (error reporting)\n-        const char* get_token_description() const {\n-            return Rust::get_token_description(token_id);\n-        }\n-\n-        // debugging\n-        const char* token_id_to_str() const {\n-            return Rust::token_id_to_str(token_id);\n-        }\n-\n-        // debugging\n-        const char* get_type_hint_str() const;\n-\n-        /* Returns whether the token is a literal of any type (int, float, char, string, byte char, \n-         * byte string). */\n-        inline bool is_literal() const {\n-            switch (token_id) {\n-                case INT_LITERAL:\n-                case FLOAT_LITERAL:\n-                case CHAR_LITERAL:\n-                case STRING_LITERAL:\n-                case BYTE_CHAR_LITERAL:\n-                case BYTE_STRING_LITERAL:\n-                    return true;\n-                default:\n-                    return false;\n-            }\n-        }\n-\n-        // Returns whether the token actually has a string (regardless of whether it should or not).\n-        inline bool has_str() const {\n-            return str != NULL;\n-        }\n-\n-        // Returns whether the token should have a string.\n-        inline bool should_have_str() const {\n-            return is_literal() || token_id == IDENTIFIER || token_id == LIFETIME;\n-        }\n-    };\n+};\n+\n+// dodgy \"TokenPtr\" declaration with Token forward declaration\n+class Token;\n+// A smart pointer (shared_ptr) to Token.\n+typedef ::std::shared_ptr<Token> TokenPtr;\n+// A smart pointer (shared_ptr) to a constant Token.\n+typedef ::std::shared_ptr<const Token> const_TokenPtr;\n+\n+// Hackily defined way to get token description for enum value using x-macros\n+const char *\n+get_token_description (TokenId id);\n+// Hackily defined way to get token description as a string for enum value using\n+// x-macros\n+const char *\n+token_id_to_str (TokenId id);\n+// Get type hint description as a string.\n+const char *\n+get_type_hint_string (PrimitiveCoreType type);\n+\n+// Represents a single token. Create using factory static methods.\n+class Token\n+{\n+private:\n+  // Token kind.\n+  TokenId token_id;\n+  // Token location.\n+  Location locus;\n+  // Associated text (if any) of token.\n+  ::std::string *str;\n+  // Type hint for token based on lexer data (e.g. type suffix). Does not exist\n+  // for most tokens.\n+  PrimitiveCoreType type_hint;\n+\n+  // Token constructor from token id and location. Has a null string.\n+  Token (TokenId token_id, Location location)\n+    : token_id (token_id), locus (location), str (NULL),\n+      type_hint (CORETYPE_UNKNOWN)\n+  {}\n+\n+  // Token constructor from token id, location, and a string.\n+  Token (TokenId token_id, Location location, const ::std::string &paramStr)\n+    : token_id (token_id), locus (location), str (new ::std::string (paramStr)),\n+      type_hint (CORETYPE_UNKNOWN)\n+  {}\n+\n+  // Token constructor from token id, location, and a char.\n+  Token (TokenId token_id, Location location, char paramChar)\n+    : token_id (token_id), locus (location),\n+      str (new ::std::string (1, paramChar)), type_hint (CORETYPE_UNKNOWN)\n+  {}\n+\n+  // Token constructor from token id, location, and a \"codepoint\".\n+  Token (TokenId token_id, Location location, Codepoint paramCodepoint)\n+    : token_id (token_id), locus (location),\n+      str (new ::std::string (paramCodepoint.as_string ())),\n+      type_hint (CORETYPE_UNKNOWN)\n+  {}\n+\n+  // Token constructor from token id, location, a string, and type hint.\n+  Token (TokenId token_id, Location location, const ::std::string &paramStr,\n+\t PrimitiveCoreType parType)\n+    : token_id (token_id), locus (location), str (new ::std::string (paramStr)),\n+      type_hint (parType)\n+  {}\n+\n+  // No default initialiser.\n+  Token ();\n+  // Do not copy/assign tokens.\n+  Token (const Token &);\n+  Token &operator= (const Token &);\n+\n+public:\n+  ~Token () { delete str; }\n+\n+  // Makes and returns a new TokenPtr (with null string).\n+  static TokenPtr make (TokenId token_id, Location locus)\n+  {\n+    return TokenPtr (new Token (token_id, locus));\n+  }\n+\n+  // Makes and returns a new TokenPtr of type IDENTIFIER.\n+  static TokenPtr make_identifier (Location locus, const ::std::string &str)\n+  {\n+    return TokenPtr (new Token (IDENTIFIER, locus, str));\n+  }\n+\n+  // Makes and returns a new TokenPtr of type INT_LITERAL.\n+  static TokenPtr make_int (Location locus, const ::std::string &str)\n+  {\n+    return TokenPtr (new Token (INT_LITERAL, locus, str));\n+  }\n+\n+  // Makes and returns a new TokenPtr of type INT_LITERAL.\n+  static TokenPtr make_int (Location locus, const ::std::string &str,\n+\t\t\t    PrimitiveCoreType type_hint)\n+  {\n+    return TokenPtr (new Token (INT_LITERAL, locus, str, type_hint));\n+  }\n+\n+  // Makes and returns a new TokenPtr of type FLOAT_LITERAL.\n+  static TokenPtr make_float (Location locus, const ::std::string &str)\n+  {\n+    return TokenPtr (new Token (FLOAT_LITERAL, locus, str));\n+  }\n+\n+  // Makes and returns a new TokenPtr of type FLOAT_LITERAL.\n+  static TokenPtr make_float (Location locus, const ::std::string &str,\n+\t\t\t      PrimitiveCoreType type_hint)\n+  {\n+    return TokenPtr (new Token (FLOAT_LITERAL, locus, str, type_hint));\n+  }\n+\n+  // Makes and returns a new TokenPtr of type STRING_LITERAL.\n+  static TokenPtr make_string (Location locus, const ::std::string &str)\n+  {\n+    return TokenPtr (new Token (STRING_LITERAL, locus, str, CORETYPE_STR));\n+  }\n+\n+  // Makes and returns a new TokenPtr of type CHAR_LITERAL (fix).\n+  static TokenPtr make_char (Location locus, Codepoint char_lit)\n+  {\n+    return TokenPtr (new Token (CHAR_LITERAL, locus, char_lit));\n+  }\n+\n+  // Makes and returns a new TokenPtr of type BYTE_CHAR_LITERAL (fix).\n+  static TokenPtr make_byte_char (Location locus, char byte_char)\n+  {\n+    return TokenPtr (new Token (BYTE_CHAR_LITERAL, locus, byte_char));\n+  }\n+\n+  // Makes and returns a new TokenPtr of type BYTE_STRING_LITERAL (fix).\n+  static TokenPtr make_byte_string (Location locus, const ::std::string &str)\n+  {\n+    return TokenPtr (new Token (BYTE_STRING_LITERAL, locus, str));\n+  }\n+\n+  // Makes and returns a new TokenPtr of type LIFETIME.\n+  static TokenPtr make_lifetime (Location locus, const ::std::string &str)\n+  {\n+    return TokenPtr (new Token (LIFETIME, locus, str));\n+  }\n+\n+  // Gets id of the token.\n+  TokenId get_id () const { return token_id; }\n+\n+  // Gets location of the token.\n+  Location get_locus () const { return locus; }\n+\n+  // Gets string description of the token.\n+  const ::std::string &\n+  get_str () const; /*{\n+// FIXME: put in header again when fix null problem\n+//gcc_assert(str != NULL);\n+if (str == NULL) {\n+error_at(get_locus(), \"attempted to get string for '%s', which has no string.\n+returning empty string instead.\", get_token_description()); return \"\";\n }\n+return *str;\n+}*/\n+\n+  // Gets token's type hint info.\n+  PrimitiveCoreType get_type_hint () const { return type_hint; }\n+\n+  // diagnostics (error reporting)\n+  const char *get_token_description () const\n+  {\n+    return Rust::get_token_description (token_id);\n+  }\n+\n+  // debugging\n+  const char *token_id_to_str () const\n+  {\n+    return Rust::token_id_to_str (token_id);\n+  }\n+\n+  // debugging\n+  const char *get_type_hint_str () const;\n+\n+  /* Returns whether the token is a literal of any type (int, float, char,\n+   * string, byte char, byte string). */\n+  inline bool is_literal () const\n+  {\n+    switch (token_id)\n+      {\n+      case INT_LITERAL:\n+      case FLOAT_LITERAL:\n+      case CHAR_LITERAL:\n+      case STRING_LITERAL:\n+      case BYTE_CHAR_LITERAL:\n+      case BYTE_STRING_LITERAL:\n+\treturn true;\n+      default:\n+\treturn false;\n+      }\n+  }\n+\n+  // Returns whether the token actually has a string (regardless of whether it\n+  // should or not).\n+  inline bool has_str () const { return str != NULL; }\n+\n+  // Returns whether the token should have a string.\n+  inline bool should_have_str () const\n+  {\n+    return is_literal () || token_id == IDENTIFIER || token_id == LIFETIME;\n+  }\n+};\n+} // namespace Rust\n \n #endif"}, {"sha": "49add608c7ae108d8e452607c6f90d3e686f4125", "filename": "gcc/rust/operator.h", "status": "modified", "additions": 49, "deletions": 48, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Foperator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Foperator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Foperator.h?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -9,60 +9,61 @@\n \n // The operators.\n \n-// TODO: Will have to be significantly modified to work with Rust and current setup of gccrs\n+// TODO: Will have to be significantly modified to work with Rust and current\n+// setup of gccrs\n \n enum Operator\n {\n   OPERATOR_INVALID,\n-  OPERATOR_OROR,\t// ||\n-  OPERATOR_ANDAND,\t// &&\n-  OPERATOR_EQEQ,\t// ==\n-  OPERATOR_NOTEQ,\t// !=\n-  OPERATOR_LT,\t\t// <\n-  OPERATOR_LE,\t\t// <=\n-  OPERATOR_GT,\t\t// >\n-  OPERATOR_GE,\t\t// >=\n-  OPERATOR_PLUS,\t// +\n-  OPERATOR_MINUS,\t// -\n-  OPERATOR_OR,\t\t// |\n-  OPERATOR_XOR,\t\t// ^\n-  OPERATOR_MULT,\t// *\n-  OPERATOR_DIV,\t\t// /\n-  OPERATOR_MOD,\t\t// %\n-  OPERATOR_LSHIFT,\t// <<\n-  OPERATOR_RSHIFT,\t// >>\n-  OPERATOR_AND,\t\t// &\n-  OPERATOR_NOT,\t\t// !\n-  OPERATOR_BITCLEAR,\t// &^\n-  OPERATOR_CHANOP,\t// <-\n+  OPERATOR_OROR,     // ||\n+  OPERATOR_ANDAND,   // &&\n+  OPERATOR_EQEQ,     // ==\n+  OPERATOR_NOTEQ,    // !=\n+  OPERATOR_LT,       // <\n+  OPERATOR_LE,       // <=\n+  OPERATOR_GT,       // >\n+  OPERATOR_GE,       // >=\n+  OPERATOR_PLUS,     // +\n+  OPERATOR_MINUS,    // -\n+  OPERATOR_OR,       // |\n+  OPERATOR_XOR,      // ^\n+  OPERATOR_MULT,     // *\n+  OPERATOR_DIV,      // /\n+  OPERATOR_MOD,      // %\n+  OPERATOR_LSHIFT,   // <<\n+  OPERATOR_RSHIFT,   // >>\n+  OPERATOR_AND,      // &\n+  OPERATOR_NOT,      // !\n+  OPERATOR_BITCLEAR, // &^\n+  OPERATOR_CHANOP,   // <-\n \n-  OPERATOR_EQ,\t\t// =\n-  OPERATOR_PLUSEQ,\t// +=\n-  OPERATOR_MINUSEQ,\t// -=\n-  OPERATOR_OREQ,\t// |=\n-  OPERATOR_XOREQ,\t// ^=\n-  OPERATOR_MULTEQ,\t// *=\n-  OPERATOR_DIVEQ,\t// /=\n-  OPERATOR_MODEQ,\t// %=\n-  OPERATOR_LSHIFTEQ,\t// <<=\n-  OPERATOR_RSHIFTEQ,\t// >>=\n-  OPERATOR_ANDEQ,\t// &=\n-  OPERATOR_BITCLEAREQ,\t// &^=\n-  OPERATOR_PLUSPLUS,\t// ++\n-  OPERATOR_MINUSMINUS,\t// --\n+  OPERATOR_EQ,\t // =\n+  OPERATOR_PLUSEQ,     // +=\n+  OPERATOR_MINUSEQ,    // -=\n+  OPERATOR_OREQ,       // |=\n+  OPERATOR_XOREQ,      // ^=\n+  OPERATOR_MULTEQ,     // *=\n+  OPERATOR_DIVEQ,      // /=\n+  OPERATOR_MODEQ,      // %=\n+  OPERATOR_LSHIFTEQ,   // <<=\n+  OPERATOR_RSHIFTEQ,   // >>=\n+  OPERATOR_ANDEQ,      // &=\n+  OPERATOR_BITCLEAREQ, // &^=\n+  OPERATOR_PLUSPLUS,   // ++\n+  OPERATOR_MINUSMINUS, // --\n \n-  OPERATOR_COLON,\t// :\n-  OPERATOR_COLONEQ,\t// :=\n-  OPERATOR_SEMICOLON,\t// ;\n-  OPERATOR_DOT,\t\t// .\n-  OPERATOR_ELLIPSIS,\t// ...\n-  OPERATOR_COMMA,\t// ,\n-  OPERATOR_LPAREN,\t// (\n-  OPERATOR_RPAREN,\t// )\n-  OPERATOR_LCURLY,\t// {\n-  OPERATOR_RCURLY,\t// }\n-  OPERATOR_LSQUARE,\t// [\n-  OPERATOR_RSQUARE\t// ]\n+  OPERATOR_COLON,     // :\n+  OPERATOR_COLONEQ,   // :=\n+  OPERATOR_SEMICOLON, // ;\n+  OPERATOR_DOT,       // .\n+  OPERATOR_ELLIPSIS,  // ...\n+  OPERATOR_COMMA,     // ,\n+  OPERATOR_LPAREN,    // (\n+  OPERATOR_RPAREN,    // )\n+  OPERATOR_LCURLY,    // {\n+  OPERATOR_RCURLY,    // }\n+  OPERATOR_LSQUARE,   // [\n+  OPERATOR_RSQUARE    // ]\n };\n \n #endif // !defined(GO_OPERATOR_H)"}, {"sha": "5bc62d3fbc7004dd283930933f6e171c2dc192c8", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 558, "deletions": 450, "changes": 1008, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -5,455 +5,563 @@\n #include \"rust-ast-full.h\"\n \n namespace Rust {\n-    /* HACK: used to resolve the expression-or-statement problem at the end of a block by allowing\n-     * either to be returned (technically). Tagged union would probably take up the same amount of\n-     * space. */\n-    struct ExprOrStmt {\n-        ::std::unique_ptr<AST::ExprWithoutBlock> expr;\n-        ::std::unique_ptr<AST::Stmt> stmt;\n-\n-        /* I was going to resist the urge to make this a real class and make it POD, but construction\n-         * in steps is too difficult. So it'll just also have a constructor. */\n-\n-        // expression constructor\n-        ExprOrStmt(::std::unique_ptr<AST::ExprWithoutBlock> expr) : expr(::std::move(expr)) {}\n-\n-        // statement constructor\n-        ExprOrStmt(::std::unique_ptr<AST::Stmt> stmt) : stmt(::std::move(stmt)) {}\n-\n-        // Returns whether this object is in an error state.\n-        inline bool is_error() const {\n-            return (expr == NULL && stmt == NULL) || (expr != NULL && stmt != NULL);\n-        }\n-\n-        // Returns an error state object.\n-        static ExprOrStmt create_error() {\n-            return ExprOrStmt(NULL, NULL);\n-        }\n-\n-        ~ExprOrStmt() = default;\n-\n-        // no copy constructors/assignment copy as simple object like this shouldn't require it\n-\n-        // move constructors\n-        ExprOrStmt(ExprOrStmt&& other) = default;\n-        ExprOrStmt& operator=(ExprOrStmt&& other) = default;\n-\n-      private:\n-        // private constructor only used for creating error state expr or stmt objects\n-        ExprOrStmt(AST::ExprWithoutBlock* expr, AST::Stmt* stmt) : expr(expr), stmt(stmt) {}\n-\n-        // make this work: have a disambiguation specifically for known statements (i.e. ';' and\n-        // 'let'). then, have a special \"parse expr or stmt\" function that returns this type. inside\n-        // it, it parses an expression, and then determines whether to return expr or stmt via whether\n-        // the next token is a semicolon. should be able to disambiguate inside that function between\n-        // stmts with blocks and without blocks.\n-    };\n-\n-    /* Restrictions on parsing used to signal that certain ambiguous grammar features should be parsed\n-     * in a certain way.*/\n-    struct ParseRestrictions {\n-        bool can_be_struct_expr = true;\n-        /* Whether the expression was entered from a unary expression - prevents stuff like struct\n-         * exprs being parsed from a dereference. */\n-        bool entered_from_unary = false;\n-    };\n-\n-    // Parser implementation for gccrs.\n-    class Parser {\n-      private:\n-        void skip_after_semicolon();\n-        void skip_after_end();\n-        void skip_after_end_block();\n-        void skip_after_next_block();\n-        void skip_after_end_attribute();\n-\n-        bool skip_token(TokenId t);\n-        const_TokenPtr expect_token(TokenId t);\n-        void unexpected_token(const_TokenPtr t);\n-        bool skip_generics_right_angle();\n-\n-        void parse_statement_seq(bool (Parser::*done)());\n-\n-        // AST-related stuff - maybe move or something?\n-        ::std::vector<AST::Attribute> parse_inner_attributes();\n-        AST::Attribute parse_inner_attribute();\n-        ::std::vector<AST::Attribute> parse_outer_attributes();\n-        AST::Attribute parse_outer_attribute();\n-        AST::Attribute parse_attribute_body();\n-        ::std::unique_ptr<AST::AttrInput> parse_attr_input();\n-\n-        // Path-related\n-        AST::SimplePath parse_simple_path();\n-        AST::SimplePathSegment parse_simple_path_segment();\n-        AST::TypePath parse_type_path();\n-        ::std::unique_ptr<AST::TypePathSegment> parse_type_path_segment();\n-        AST::PathIdentSegment parse_path_ident_segment();\n-        AST::GenericArgs parse_path_generic_args();\n-        AST::GenericArgsBinding parse_generic_args_binding();\n-        AST::TypePathFunction parse_type_path_function();\n-        AST::PathInExpression parse_path_in_expression();\n-        AST::PathExprSegment parse_path_expr_segment();\n-        AST::QualifiedPathInExpression parse_qualified_path_in_expression(bool pratt_parse = false);\n-        AST::QualifiedPathType parse_qualified_path_type(bool pratt_parse = false);\n-        AST::QualifiedPathInType parse_qualified_path_in_type();\n-\n-        // Token tree or macro related\n-        AST::DelimTokenTree parse_delim_token_tree();\n-        ::std::unique_ptr<AST::TokenTree> parse_token_tree();\n-        ::std::unique_ptr<AST::MacroRulesDefinition> parse_macro_rules_def(\n-          ::std::vector<AST::Attribute> outer_attrs);\n-        ::std::unique_ptr<AST::MacroInvocationSemi> parse_macro_invocation_semi(\n-          ::std::vector<AST::Attribute> outer_attrs);\n-        ::std::unique_ptr<AST::MacroInvocation> parse_macro_invocation(\n-          ::std::vector<AST::Attribute> outer_attrs);\n-        AST::MacroRule parse_macro_rule();\n-        AST::MacroMatcher parse_macro_matcher();\n-        ::std::unique_ptr<AST::MacroMatch> parse_macro_match();\n-        ::std::unique_ptr<AST::MacroMatchFragment> parse_macro_match_fragment();\n-        ::std::unique_ptr<AST::MacroMatchRepetition> parse_macro_match_repetition();\n-\n-        // Top-level item-related\n-        ::std::vector< ::std::unique_ptr<AST::Item> > parse_items();\n-        ::std::unique_ptr<AST::Item> parse_item(bool called_from_statement);\n-        ::std::unique_ptr<AST::VisItem> parse_vis_item(::std::vector<AST::Attribute> outer_attrs);\n-        ::std::unique_ptr<AST::MacroItem> parse_macro_item(::std::vector<AST::Attribute> outer_attrs);\n-        AST::Visibility parse_visibility();\n-\n-        // VisItem subclass-related\n-        ::std::unique_ptr<AST::Module> parse_module(\n-          AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-        ::std::unique_ptr<AST::ExternCrate> parse_extern_crate(\n-          AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-        ::std::unique_ptr<AST::UseDeclaration> parse_use_decl(\n-          AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-        ::std::unique_ptr<AST::UseTree> parse_use_tree();\n-        ::std::unique_ptr<AST::Function> parse_function(\n-          AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::FunctionQualifiers parse_function_qualifiers();\n-        ::std::vector< ::std::unique_ptr<AST::GenericParam> > parse_generic_params_in_angles();\n-        ::std::vector< ::std::unique_ptr<AST::GenericParam> > parse_generic_params();\n-        ::std::vector< ::std::unique_ptr<AST::LifetimeParam> > parse_lifetime_params();\n-        ::std::vector<AST::LifetimeParam> parse_lifetime_params_objs();\n-        AST::LifetimeParam parse_lifetime_param();\n-        ::std::vector< ::std::unique_ptr<AST::TypeParam> > parse_type_params();\n-        ::std::unique_ptr<AST::TypeParam> parse_type_param();\n-        ::std::vector<AST::FunctionParam> parse_function_params();\n-        AST::FunctionParam parse_function_param();\n-        ::std::unique_ptr<AST::Type> parse_function_return_type();\n-        AST::WhereClause parse_where_clause();\n-        ::std::unique_ptr<AST::WhereClauseItem> parse_where_clause_item();\n-        ::std::unique_ptr<AST::LifetimeWhereClauseItem> parse_lifetime_where_clause_item();\n-        ::std::unique_ptr<AST::TypeBoundWhereClauseItem> parse_type_bound_where_clause_item();\n-        ::std::vector<AST::LifetimeParam> parse_for_lifetimes();\n-        ::std::vector< ::std::unique_ptr<AST::TypeParamBound> > parse_type_param_bounds();\n-        ::std::unique_ptr<AST::TypeParamBound> parse_type_param_bound();\n-        ::std::unique_ptr<AST::TraitBound> parse_trait_bound();\n-        ::std::vector<AST::Lifetime> parse_lifetime_bounds();\n-        AST::Lifetime parse_lifetime();\n-        ::std::unique_ptr<AST::TypeAlias> parse_type_alias(\n-          AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-        ::std::unique_ptr<AST::Struct> parse_struct(\n-          AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-        ::std::vector<AST::StructField> parse_struct_fields();\n-        AST::StructField parse_struct_field();\n-        ::std::vector<AST::TupleField> parse_tuple_fields();\n-        AST::TupleField parse_tuple_field();\n-        ::std::unique_ptr<AST::Enum> parse_enum(\n-          AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-        ::std::vector< ::std::unique_ptr<AST::EnumItem> > parse_enum_items();\n-        ::std::unique_ptr<AST::EnumItem> parse_enum_item();\n-        ::std::unique_ptr<AST::Union> parse_union(\n-          AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-        ::std::unique_ptr<AST::ConstantItem> parse_const_item(\n-          AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-        ::std::unique_ptr<AST::StaticItem> parse_static_item(\n-          AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-        ::std::unique_ptr<AST::Trait> parse_trait(\n-          AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-        ::std::unique_ptr<AST::TraitItem> parse_trait_item();\n-        ::std::unique_ptr<AST::TraitItemType> parse_trait_type(\n-          ::std::vector<AST::Attribute> outer_attrs);\n-        ::std::unique_ptr<AST::TraitItemConst> parse_trait_const(\n-          ::std::vector<AST::Attribute> outer_attrs);\n-        AST::SelfParam parse_self_param();\n-        ::std::unique_ptr<AST::Impl> parse_impl(\n-          AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-        ::std::unique_ptr<AST::InherentImplItem> parse_inherent_impl_item();\n-        ::std::unique_ptr<AST::InherentImplItem> parse_inherent_impl_function_or_method(\n-          AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-        ::std::unique_ptr<AST::TraitImplItem> parse_trait_impl_item();\n-        ::std::unique_ptr<AST::TraitImplItem> parse_trait_impl_function_or_method(\n-          AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-        ::std::unique_ptr<AST::ExternBlock> parse_extern_block(\n-          AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n-        ::std::unique_ptr<AST::ExternalItem> parse_external_item();\n-        AST::NamedFunctionParam parse_named_function_param();\n-        AST::Method parse_method();\n-\n-        // Expression-related (Pratt parsed)\n-        ::std::unique_ptr<AST::Expr> parse_expr(\n-          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(),\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::Expr> parse_expr(int right_binding_power,\n-          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(),\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::Expr> null_denotation_NEW(const_TokenPtr t,\n-          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(),\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::Expr> left_denotation(const_TokenPtr t,\n-          ::std::unique_ptr<AST::Expr> left,\n-          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(),\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::ArithmeticOrLogicalExpr> parse_binary_plus_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::ArithmeticOrLogicalExpr> parse_binary_minus_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::ArithmeticOrLogicalExpr> parse_binary_mult_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::ArithmeticOrLogicalExpr> parse_binary_div_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::ArithmeticOrLogicalExpr> parse_binary_mod_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::ArithmeticOrLogicalExpr> parse_bitwise_and_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::ArithmeticOrLogicalExpr> parse_bitwise_or_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::ArithmeticOrLogicalExpr> parse_bitwise_xor_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::ArithmeticOrLogicalExpr> parse_left_shift_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::ArithmeticOrLogicalExpr> parse_right_shift_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::ComparisonExpr> parse_binary_equal_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::ComparisonExpr> parse_binary_not_equal_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::ComparisonExpr> parse_binary_greater_than_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::ComparisonExpr> parse_binary_less_than_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::ComparisonExpr> parse_binary_greater_equal_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::ComparisonExpr> parse_binary_less_equal_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::LazyBooleanExpr> parse_lazy_or_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::LazyBooleanExpr> parse_lazy_and_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::TypeCastExpr> parse_type_cast_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> expr_to_cast, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::AssignmentExpr> parse_assig_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::CompoundAssignmentExpr> parse_plus_assig_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::CompoundAssignmentExpr> parse_minus_assig_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::CompoundAssignmentExpr> parse_mult_assig_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::CompoundAssignmentExpr> parse_div_assig_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::CompoundAssignmentExpr> parse_mod_assig_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::CompoundAssignmentExpr> parse_and_assig_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::CompoundAssignmentExpr> parse_or_assig_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::CompoundAssignmentExpr> parse_xor_assig_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::CompoundAssignmentExpr> parse_left_shift_assig_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::CompoundAssignmentExpr> parse_right_shift_assig_expr(\n-          const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n-          ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::AwaitExpr> parse_await_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> expr_to_await, ::std::vector<AST::Attribute> outer_attrs);\n-        ::std::unique_ptr<AST::MethodCallExpr> parse_method_call_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> receiver_expr, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::CallExpr> parse_function_call_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> function_expr, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::RangeExpr> parse_led_range_exclusive_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::RangeExpr> parse_nud_range_exclusive_expr(\n-          const_TokenPtr tok, ::std::vector<AST::Attribute> outer_attrs);\n-        ::std::unique_ptr<AST::RangeFromToInclExpr> parse_range_inclusive_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> left, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::RangeToInclExpr> parse_range_to_inclusive_expr(\n-          const_TokenPtr tok, ::std::vector<AST::Attribute> outer_attrs);\n-        ::std::unique_ptr<AST::TupleIndexExpr> parse_tuple_index_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> tuple_expr, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::FieldAccessExpr> parse_field_access_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> struct_expr, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::ArrayIndexExpr> parse_index_expr(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> array_expr, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-        ::std::unique_ptr<AST::MacroInvocation> parse_macro_invocation_partial(\n-          AST::PathInExpression path, ::std::vector<AST::Attribute> outer_attrs);\n-        ::std::unique_ptr<AST::StructExprStruct> parse_struct_expr_struct_partial(\n-          AST::PathInExpression path, ::std::vector<AST::Attribute> outer_attrs);\n-        ::std::unique_ptr<AST::StructExprTuple> parse_struct_expr_tuple_partial(\n-          AST::PathInExpression path, ::std::vector<AST::Attribute> outer_attrs);\n-        AST::PathInExpression parse_path_in_expression_pratt(const_TokenPtr tok);\n-        ::std::unique_ptr<AST::ClosureExpr> parse_closure_expr_pratt(const_TokenPtr tok,\n-          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>());\n-        ::std::unique_ptr<AST::TupleIndexExpr> parse_tuple_index_expr_float(const_TokenPtr tok,\n-          ::std::unique_ptr<AST::Expr> tuple_expr, ::std::vector<AST::Attribute> outer_attrs,\n-          ParseRestrictions restrictions = ParseRestrictions());\n-\n-        // Expression-related (non-Pratt parsed)\n-        ::std::unique_ptr<AST::ExprWithoutBlock> parse_expr_without_block(\n-          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>());\n-        ::std::unique_ptr<AST::BlockExpr> parse_block_expr(\n-          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(),\n-          bool pratt_parse = false);\n-        ::std::unique_ptr<AST::IfExpr> parse_if_expr(\n-          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>());\n-        ::std::unique_ptr<AST::IfLetExpr> parse_if_let_expr(\n-          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>());\n-        ::std::unique_ptr<AST::LoopExpr> parse_loop_expr(\n-          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(),\n-          AST::LoopLabel label = AST::LoopLabel::error());\n-        ::std::unique_ptr<AST::WhileLoopExpr> parse_while_loop_expr(\n-          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(),\n-          AST::LoopLabel label = AST::LoopLabel::error());\n-        ::std::unique_ptr<AST::WhileLetLoopExpr> parse_while_let_loop_expr(\n-          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(),\n-          AST::LoopLabel label = AST::LoopLabel::error());\n-        ::std::unique_ptr<AST::ForLoopExpr> parse_for_loop_expr(\n-          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(),\n-          AST::LoopLabel label = AST::LoopLabel::error());\n-        ::std::unique_ptr<AST::MatchExpr> parse_match_expr(\n-          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(),\n-          bool pratt_parse = false);\n-        AST::MatchArm parse_match_arm();\n-        ::std::vector< ::std::unique_ptr<AST::Pattern> > parse_match_arm_patterns(\n-          TokenId end_token_id);\n-        ::std::unique_ptr<AST::BaseLoopExpr> parse_labelled_loop_expr(\n-          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>());\n-        AST::LoopLabel parse_loop_label();\n-        ::std::unique_ptr<AST::AsyncBlockExpr> parse_async_block_expr(\n-          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>());\n-        ::std::unique_ptr<AST::UnsafeBlockExpr> parse_unsafe_block_expr(\n-          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>());\n-        ::std::unique_ptr<AST::GroupedExpr> parse_grouped_expr(\n-          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>());\n-        ::std::unique_ptr<AST::ClosureExpr> parse_closure_expr(\n-          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>());\n-        AST::ClosureParam parse_closure_param();\n-        ::std::unique_ptr<AST::LiteralExpr> parse_literal_expr(\n-          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>());\n-        ::std::unique_ptr<AST::ReturnExpr> parse_return_expr(\n-          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(),\n-          bool pratt_parse = false);\n-        ::std::unique_ptr<AST::BreakExpr> parse_break_expr(\n-          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(),\n-          bool pratt_parse = false);\n-        ::std::unique_ptr<AST::ContinueExpr> parse_continue_expr(\n-          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(),\n-          bool pratt_parse = false);\n-        ::std::unique_ptr<AST::ArrayExpr> parse_array_expr(\n-          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(),\n-          bool pratt_parse = false);\n-        ::std::unique_ptr<AST::ExprWithoutBlock> parse_grouped_or_tuple_expr(\n-          ::std::vector<AST::Attribute> outer_attrs = ::std::vector<AST::Attribute>(),\n-          bool pratt_parse = false);\n-        ::std::unique_ptr<AST::StructExprField> parse_struct_expr_field();\n-\n-        // Type-related\n-        ::std::unique_ptr<AST::Type> parse_type();\n-        ::std::unique_ptr<AST::TypeNoBounds> parse_type_no_bounds();\n-        ::std::unique_ptr<AST::TypeNoBounds> parse_slice_or_array_type();\n-        ::std::unique_ptr<AST::RawPointerType> parse_raw_pointer_type();\n-        ::std::unique_ptr<AST::ReferenceType> parse_reference_type();\n-        ::std::unique_ptr<AST::BareFunctionType> parse_bare_function_type(\n-          ::std::vector<AST::LifetimeParam> for_lifetimes);\n-        ::std::unique_ptr<AST::Type> parse_paren_prefixed_type();\n-        ::std::unique_ptr<AST::TypeNoBounds> parse_paren_prefixed_type_no_bounds();\n-        ::std::unique_ptr<AST::Type> parse_for_prefixed_type();\n-        AST::MaybeNamedParam parse_maybe_named_param();\n-\n-        // Statement-related\n-        ::std::unique_ptr<AST::Stmt> parse_stmt();\n-        ::std::unique_ptr<AST::LetStmt> parse_let_stmt(::std::vector<AST::Attribute> outer_attrs);\n-        ::std::unique_ptr<AST::ExprStmt> parse_expr_stmt(::std::vector<AST::Attribute> outer_attrs);\n-        ::std::unique_ptr<AST::ExprStmtWithBlock> parse_expr_stmt_with_block(\n-          ::std::vector<AST::Attribute> outer_attrs);\n-        ::std::unique_ptr<AST::ExprStmtWithoutBlock> parse_expr_stmt_without_block(\n-          ::std::vector<AST::Attribute> outer_attrs);\n-        ExprOrStmt parse_stmt_or_expr_without_block();\n-        ExprOrStmt parse_macro_invocation_maybe_semi(::std::vector<AST::Attribute> outer_attrs);\n-        ExprOrStmt parse_path_based_stmt_or_expr(::std::vector<AST::Attribute> outer_attrs);\n-\n-        // Pattern-related\n-        ::std::unique_ptr<AST::Pattern> parse_pattern();\n-        ::std::unique_ptr<AST::Pattern> parse_literal_or_range_pattern();\n-        ::std::unique_ptr<AST::RangePatternBound> parse_range_pattern_bound();\n-        ::std::unique_ptr<AST::ReferencePattern> parse_reference_pattern();\n-        ::std::unique_ptr<AST::Pattern> parse_grouped_or_tuple_pattern();\n-        ::std::unique_ptr<AST::SlicePattern> parse_slice_pattern();\n-        ::std::unique_ptr<AST::IdentifierPattern> parse_identifier_pattern();\n-        ::std::unique_ptr<AST::Pattern> parse_ident_leading_pattern();\n-        ::std::unique_ptr<AST::TupleStructItems> parse_tuple_struct_items();\n-        AST::StructPatternElements parse_struct_pattern_elems();\n-        ::std::unique_ptr<AST::StructPatternField> parse_struct_pattern_field();\n-\n-        int left_binding_power(const_TokenPtr token);\n-\n-        bool done_end();\n-        bool done_end_or_else();\n-        bool done_end_of_file();\n-\n-      public:\n-        // Construct parser with specified lexer reference.\n-        Parser(Lexer& parLexer) : lexer(parLexer) {}\n-\n-        // Main entry point for parser.\n-        AST::Crate parse_crate();\n-\n-        // Dumps all lexer output.\n-        void debug_dump_lex_output();\n-        void debug_dump_ast_output();\n-\n-      private:\n-        // The lexer associated with the parser.\n-        Lexer& lexer;\n-    };\n-}\n+/* HACK: used to resolve the expression-or-statement problem at the end of a\n+ * block by allowing either to be returned (technically). Tagged union would\n+ * probably take up the same amount of space. */\n+struct ExprOrStmt\n+{\n+  ::std::unique_ptr<AST::ExprWithoutBlock> expr;\n+  ::std::unique_ptr<AST::Stmt> stmt;\n+\n+  /* I was going to resist the urge to make this a real class and make it POD,\n+   * but construction in steps is too difficult. So it'll just also have a\n+   * constructor. */\n+\n+  // expression constructor\n+  ExprOrStmt (::std::unique_ptr<AST::ExprWithoutBlock> expr)\n+    : expr (::std::move (expr))\n+  {}\n+\n+  // statement constructor\n+  ExprOrStmt (::std::unique_ptr<AST::Stmt> stmt) : stmt (::std::move (stmt)) {}\n+\n+  // Returns whether this object is in an error state.\n+  inline bool is_error () const\n+  {\n+    return (expr == NULL && stmt == NULL) || (expr != NULL && stmt != NULL);\n+  }\n+\n+  // Returns an error state object.\n+  static ExprOrStmt create_error () { return ExprOrStmt (NULL, NULL); }\n+\n+  ~ExprOrStmt () = default;\n+\n+  // no copy constructors/assignment copy as simple object like this shouldn't\n+  // require it\n+\n+  // move constructors\n+  ExprOrStmt (ExprOrStmt &&other) = default;\n+  ExprOrStmt &operator= (ExprOrStmt &&other) = default;\n+\n+private:\n+  // private constructor only used for creating error state expr or stmt objects\n+  ExprOrStmt (AST::ExprWithoutBlock *expr, AST::Stmt *stmt)\n+    : expr (expr), stmt (stmt)\n+  {}\n+\n+  // make this work: have a disambiguation specifically for known statements\n+  // (i.e. ';' and 'let'). then, have a special \"parse expr or stmt\" function\n+  // that returns this type. inside it, it parses an expression, and then\n+  // determines whether to return expr or stmt via whether the next token is a\n+  // semicolon. should be able to disambiguate inside that function between\n+  // stmts with blocks and without blocks.\n+};\n+\n+/* Restrictions on parsing used to signal that certain ambiguous grammar\n+ * features should be parsed in a certain way.*/\n+struct ParseRestrictions\n+{\n+  bool can_be_struct_expr = true;\n+  /* Whether the expression was entered from a unary expression - prevents stuff\n+   * like struct exprs being parsed from a dereference. */\n+  bool entered_from_unary = false;\n+};\n+\n+// Parser implementation for gccrs.\n+class Parser\n+{\n+private:\n+  void skip_after_semicolon ();\n+  void skip_after_end ();\n+  void skip_after_end_block ();\n+  void skip_after_next_block ();\n+  void skip_after_end_attribute ();\n+\n+  bool skip_token (TokenId t);\n+  const_TokenPtr expect_token (TokenId t);\n+  void unexpected_token (const_TokenPtr t);\n+  bool skip_generics_right_angle ();\n+\n+  void parse_statement_seq (bool (Parser::*done) ());\n+\n+  // AST-related stuff - maybe move or something?\n+  ::std::vector<AST::Attribute> parse_inner_attributes ();\n+  AST::Attribute parse_inner_attribute ();\n+  ::std::vector<AST::Attribute> parse_outer_attributes ();\n+  AST::Attribute parse_outer_attribute ();\n+  AST::Attribute parse_attribute_body ();\n+  ::std::unique_ptr<AST::AttrInput> parse_attr_input ();\n+\n+  // Path-related\n+  AST::SimplePath parse_simple_path ();\n+  AST::SimplePathSegment parse_simple_path_segment ();\n+  AST::TypePath parse_type_path ();\n+  ::std::unique_ptr<AST::TypePathSegment> parse_type_path_segment ();\n+  AST::PathIdentSegment parse_path_ident_segment ();\n+  AST::GenericArgs parse_path_generic_args ();\n+  AST::GenericArgsBinding parse_generic_args_binding ();\n+  AST::TypePathFunction parse_type_path_function ();\n+  AST::PathInExpression parse_path_in_expression ();\n+  AST::PathExprSegment parse_path_expr_segment ();\n+  AST::QualifiedPathInExpression\n+  parse_qualified_path_in_expression (bool pratt_parse = false);\n+  AST::QualifiedPathType parse_qualified_path_type (bool pratt_parse = false);\n+  AST::QualifiedPathInType parse_qualified_path_in_type ();\n+\n+  // Token tree or macro related\n+  AST::DelimTokenTree parse_delim_token_tree ();\n+  ::std::unique_ptr<AST::TokenTree> parse_token_tree ();\n+  ::std::unique_ptr<AST::MacroRulesDefinition>\n+  parse_macro_rules_def (::std::vector<AST::Attribute> outer_attrs);\n+  ::std::unique_ptr<AST::MacroInvocationSemi>\n+  parse_macro_invocation_semi (::std::vector<AST::Attribute> outer_attrs);\n+  ::std::unique_ptr<AST::MacroInvocation>\n+  parse_macro_invocation (::std::vector<AST::Attribute> outer_attrs);\n+  AST::MacroRule parse_macro_rule ();\n+  AST::MacroMatcher parse_macro_matcher ();\n+  ::std::unique_ptr<AST::MacroMatch> parse_macro_match ();\n+  ::std::unique_ptr<AST::MacroMatchFragment> parse_macro_match_fragment ();\n+  ::std::unique_ptr<AST::MacroMatchRepetition> parse_macro_match_repetition ();\n+\n+  // Top-level item-related\n+  ::std::vector< ::std::unique_ptr<AST::Item> > parse_items ();\n+  ::std::unique_ptr<AST::Item> parse_item (bool called_from_statement);\n+  ::std::unique_ptr<AST::VisItem>\n+  parse_vis_item (::std::vector<AST::Attribute> outer_attrs);\n+  ::std::unique_ptr<AST::MacroItem>\n+  parse_macro_item (::std::vector<AST::Attribute> outer_attrs);\n+  AST::Visibility parse_visibility ();\n+\n+  // VisItem subclass-related\n+  ::std::unique_ptr<AST::Module>\n+  parse_module (AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n+  ::std::unique_ptr<AST::ExternCrate>\n+  parse_extern_crate (AST::Visibility vis,\n+\t\t      ::std::vector<AST::Attribute> outer_attrs);\n+  ::std::unique_ptr<AST::UseDeclaration>\n+  parse_use_decl (AST::Visibility vis,\n+\t\t  ::std::vector<AST::Attribute> outer_attrs);\n+  ::std::unique_ptr<AST::UseTree> parse_use_tree ();\n+  ::std::unique_ptr<AST::Function>\n+  parse_function (AST::Visibility vis,\n+\t\t  ::std::vector<AST::Attribute> outer_attrs);\n+  AST::FunctionQualifiers parse_function_qualifiers ();\n+  ::std::vector< ::std::unique_ptr<AST::GenericParam> >\n+  parse_generic_params_in_angles ();\n+  ::std::vector< ::std::unique_ptr<AST::GenericParam> > parse_generic_params ();\n+  ::std::vector< ::std::unique_ptr<AST::LifetimeParam> >\n+  parse_lifetime_params ();\n+  ::std::vector<AST::LifetimeParam> parse_lifetime_params_objs ();\n+  AST::LifetimeParam parse_lifetime_param ();\n+  ::std::vector< ::std::unique_ptr<AST::TypeParam> > parse_type_params ();\n+  ::std::unique_ptr<AST::TypeParam> parse_type_param ();\n+  ::std::vector<AST::FunctionParam> parse_function_params ();\n+  AST::FunctionParam parse_function_param ();\n+  ::std::unique_ptr<AST::Type> parse_function_return_type ();\n+  AST::WhereClause parse_where_clause ();\n+  ::std::unique_ptr<AST::WhereClauseItem> parse_where_clause_item ();\n+  ::std::unique_ptr<AST::LifetimeWhereClauseItem>\n+  parse_lifetime_where_clause_item ();\n+  ::std::unique_ptr<AST::TypeBoundWhereClauseItem>\n+  parse_type_bound_where_clause_item ();\n+  ::std::vector<AST::LifetimeParam> parse_for_lifetimes ();\n+  ::std::vector< ::std::unique_ptr<AST::TypeParamBound> >\n+  parse_type_param_bounds ();\n+  ::std::unique_ptr<AST::TypeParamBound> parse_type_param_bound ();\n+  ::std::unique_ptr<AST::TraitBound> parse_trait_bound ();\n+  ::std::vector<AST::Lifetime> parse_lifetime_bounds ();\n+  AST::Lifetime parse_lifetime ();\n+  ::std::unique_ptr<AST::TypeAlias>\n+  parse_type_alias (AST::Visibility vis,\n+\t\t    ::std::vector<AST::Attribute> outer_attrs);\n+  ::std::unique_ptr<AST::Struct>\n+  parse_struct (AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n+  ::std::vector<AST::StructField> parse_struct_fields ();\n+  AST::StructField parse_struct_field ();\n+  ::std::vector<AST::TupleField> parse_tuple_fields ();\n+  AST::TupleField parse_tuple_field ();\n+  ::std::unique_ptr<AST::Enum>\n+  parse_enum (AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n+  ::std::vector< ::std::unique_ptr<AST::EnumItem> > parse_enum_items ();\n+  ::std::unique_ptr<AST::EnumItem> parse_enum_item ();\n+  ::std::unique_ptr<AST::Union>\n+  parse_union (AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n+  ::std::unique_ptr<AST::ConstantItem>\n+  parse_const_item (AST::Visibility vis,\n+\t\t    ::std::vector<AST::Attribute> outer_attrs);\n+  ::std::unique_ptr<AST::StaticItem>\n+  parse_static_item (AST::Visibility vis,\n+\t\t     ::std::vector<AST::Attribute> outer_attrs);\n+  ::std::unique_ptr<AST::Trait>\n+  parse_trait (AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n+  ::std::unique_ptr<AST::TraitItem> parse_trait_item ();\n+  ::std::unique_ptr<AST::TraitItemType>\n+  parse_trait_type (::std::vector<AST::Attribute> outer_attrs);\n+  ::std::unique_ptr<AST::TraitItemConst>\n+  parse_trait_const (::std::vector<AST::Attribute> outer_attrs);\n+  AST::SelfParam parse_self_param ();\n+  ::std::unique_ptr<AST::Impl>\n+  parse_impl (AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n+  ::std::unique_ptr<AST::InherentImplItem> parse_inherent_impl_item ();\n+  ::std::unique_ptr<AST::InherentImplItem>\n+  parse_inherent_impl_function_or_method (\n+    AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n+  ::std::unique_ptr<AST::TraitImplItem> parse_trait_impl_item ();\n+  ::std::unique_ptr<AST::TraitImplItem> parse_trait_impl_function_or_method (\n+    AST::Visibility vis, ::std::vector<AST::Attribute> outer_attrs);\n+  ::std::unique_ptr<AST::ExternBlock>\n+  parse_extern_block (AST::Visibility vis,\n+\t\t      ::std::vector<AST::Attribute> outer_attrs);\n+  ::std::unique_ptr<AST::ExternalItem> parse_external_item ();\n+  AST::NamedFunctionParam parse_named_function_param ();\n+  AST::Method parse_method ();\n+\n+  // Expression-related (Pratt parsed)\n+  ::std::unique_ptr<AST::Expr>\n+  parse_expr (::std::vector<AST::Attribute> outer_attrs\n+\t      = ::std::vector<AST::Attribute> (),\n+\t      ParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::Expr>\n+  parse_expr (int right_binding_power,\n+\t      ::std::vector<AST::Attribute> outer_attrs\n+\t      = ::std::vector<AST::Attribute> (),\n+\t      ParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::Expr>\n+  null_denotation_NEW (const_TokenPtr t,\n+\t\t       ::std::vector<AST::Attribute> outer_attrs\n+\t\t       = ::std::vector<AST::Attribute> (),\n+\t\t       ParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::Expr>\n+  left_denotation (const_TokenPtr t, ::std::unique_ptr<AST::Expr> left,\n+\t\t   ::std::vector<AST::Attribute> outer_attrs\n+\t\t   = ::std::vector<AST::Attribute> (),\n+\t\t   ParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n+  parse_binary_plus_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n+\t\t\t  ::std::vector<AST::Attribute> outer_attrs,\n+\t\t\t  ParseRestrictions restrictions\n+\t\t\t  = ParseRestrictions ());\n+  ::std::unique_ptr<AST::ArithmeticOrLogicalExpr> parse_binary_minus_expr (\n+    const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n+    ::std::vector<AST::Attribute> outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n+  parse_binary_mult_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n+\t\t\t  ::std::vector<AST::Attribute> outer_attrs,\n+\t\t\t  ParseRestrictions restrictions\n+\t\t\t  = ParseRestrictions ());\n+  ::std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n+  parse_binary_div_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n+\t\t\t ::std::vector<AST::Attribute> outer_attrs,\n+\t\t\t ParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n+  parse_binary_mod_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n+\t\t\t ::std::vector<AST::Attribute> outer_attrs,\n+\t\t\t ParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n+  parse_bitwise_and_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n+\t\t\t  ::std::vector<AST::Attribute> outer_attrs,\n+\t\t\t  ParseRestrictions restrictions\n+\t\t\t  = ParseRestrictions ());\n+  ::std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n+  parse_bitwise_or_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n+\t\t\t ::std::vector<AST::Attribute> outer_attrs,\n+\t\t\t ParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n+  parse_bitwise_xor_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n+\t\t\t  ::std::vector<AST::Attribute> outer_attrs,\n+\t\t\t  ParseRestrictions restrictions\n+\t\t\t  = ParseRestrictions ());\n+  ::std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n+  parse_left_shift_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n+\t\t\t ::std::vector<AST::Attribute> outer_attrs,\n+\t\t\t ParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n+  parse_right_shift_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n+\t\t\t  ::std::vector<AST::Attribute> outer_attrs,\n+\t\t\t  ParseRestrictions restrictions\n+\t\t\t  = ParseRestrictions ());\n+  ::std::unique_ptr<AST::ComparisonExpr> parse_binary_equal_expr (\n+    const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n+    ::std::vector<AST::Attribute> outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::ComparisonExpr> parse_binary_not_equal_expr (\n+    const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n+    ::std::vector<AST::Attribute> outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::ComparisonExpr> parse_binary_greater_than_expr (\n+    const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n+    ::std::vector<AST::Attribute> outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::ComparisonExpr> parse_binary_less_than_expr (\n+    const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n+    ::std::vector<AST::Attribute> outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::ComparisonExpr> parse_binary_greater_equal_expr (\n+    const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n+    ::std::vector<AST::Attribute> outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::ComparisonExpr> parse_binary_less_equal_expr (\n+    const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n+    ::std::vector<AST::Attribute> outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::LazyBooleanExpr>\n+  parse_lazy_or_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n+\t\t      ::std::vector<AST::Attribute> outer_attrs,\n+\t\t      ParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::LazyBooleanExpr>\n+  parse_lazy_and_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n+\t\t       ::std::vector<AST::Attribute> outer_attrs,\n+\t\t       ParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::TypeCastExpr>\n+  parse_type_cast_expr (const_TokenPtr tok,\n+\t\t\t::std::unique_ptr<AST::Expr> expr_to_cast,\n+\t\t\t::std::vector<AST::Attribute> outer_attrs,\n+\t\t\tParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::AssignmentExpr>\n+  parse_assig_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n+\t\t    ::std::vector<AST::Attribute> outer_attrs,\n+\t\t    ParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::CompoundAssignmentExpr>\n+  parse_plus_assig_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n+\t\t\t ::std::vector<AST::Attribute> outer_attrs,\n+\t\t\t ParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::CompoundAssignmentExpr>\n+  parse_minus_assig_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n+\t\t\t  ::std::vector<AST::Attribute> outer_attrs,\n+\t\t\t  ParseRestrictions restrictions\n+\t\t\t  = ParseRestrictions ());\n+  ::std::unique_ptr<AST::CompoundAssignmentExpr>\n+  parse_mult_assig_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n+\t\t\t ::std::vector<AST::Attribute> outer_attrs,\n+\t\t\t ParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::CompoundAssignmentExpr>\n+  parse_div_assig_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n+\t\t\t::std::vector<AST::Attribute> outer_attrs,\n+\t\t\tParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::CompoundAssignmentExpr>\n+  parse_mod_assig_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n+\t\t\t::std::vector<AST::Attribute> outer_attrs,\n+\t\t\tParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::CompoundAssignmentExpr>\n+  parse_and_assig_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n+\t\t\t::std::vector<AST::Attribute> outer_attrs,\n+\t\t\tParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::CompoundAssignmentExpr>\n+  parse_or_assig_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n+\t\t       ::std::vector<AST::Attribute> outer_attrs,\n+\t\t       ParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::CompoundAssignmentExpr>\n+  parse_xor_assig_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n+\t\t\t::std::vector<AST::Attribute> outer_attrs,\n+\t\t\tParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::CompoundAssignmentExpr> parse_left_shift_assig_expr (\n+    const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n+    ::std::vector<AST::Attribute> outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::CompoundAssignmentExpr> parse_right_shift_assig_expr (\n+    const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n+    ::std::vector<AST::Attribute> outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::AwaitExpr>\n+  parse_await_expr (const_TokenPtr tok,\n+\t\t    ::std::unique_ptr<AST::Expr> expr_to_await,\n+\t\t    ::std::vector<AST::Attribute> outer_attrs);\n+  ::std::unique_ptr<AST::MethodCallExpr> parse_method_call_expr (\n+    const_TokenPtr tok, ::std::unique_ptr<AST::Expr> receiver_expr,\n+    ::std::vector<AST::Attribute> outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::CallExpr> parse_function_call_expr (\n+    const_TokenPtr tok, ::std::unique_ptr<AST::Expr> function_expr,\n+    ::std::vector<AST::Attribute> outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::RangeExpr> parse_led_range_exclusive_expr (\n+    const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n+    ::std::vector<AST::Attribute> outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::RangeExpr>\n+  parse_nud_range_exclusive_expr (const_TokenPtr tok,\n+\t\t\t\t  ::std::vector<AST::Attribute> outer_attrs);\n+  ::std::unique_ptr<AST::RangeFromToInclExpr> parse_range_inclusive_expr (\n+    const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n+    ::std::vector<AST::Attribute> outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::RangeToInclExpr>\n+  parse_range_to_inclusive_expr (const_TokenPtr tok,\n+\t\t\t\t ::std::vector<AST::Attribute> outer_attrs);\n+  ::std::unique_ptr<AST::TupleIndexExpr> parse_tuple_index_expr (\n+    const_TokenPtr tok, ::std::unique_ptr<AST::Expr> tuple_expr,\n+    ::std::vector<AST::Attribute> outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::FieldAccessExpr> parse_field_access_expr (\n+    const_TokenPtr tok, ::std::unique_ptr<AST::Expr> struct_expr,\n+    ::std::vector<AST::Attribute> outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::ArrayIndexExpr>\n+  parse_index_expr (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> array_expr,\n+\t\t    ::std::vector<AST::Attribute> outer_attrs,\n+\t\t    ParseRestrictions restrictions = ParseRestrictions ());\n+  ::std::unique_ptr<AST::MacroInvocation>\n+  parse_macro_invocation_partial (AST::PathInExpression path,\n+\t\t\t\t  ::std::vector<AST::Attribute> outer_attrs);\n+  ::std::unique_ptr<AST::StructExprStruct>\n+  parse_struct_expr_struct_partial (AST::PathInExpression path,\n+\t\t\t\t    ::std::vector<AST::Attribute> outer_attrs);\n+  ::std::unique_ptr<AST::StructExprTuple>\n+  parse_struct_expr_tuple_partial (AST::PathInExpression path,\n+\t\t\t\t   ::std::vector<AST::Attribute> outer_attrs);\n+  AST::PathInExpression parse_path_in_expression_pratt (const_TokenPtr tok);\n+  ::std::unique_ptr<AST::ClosureExpr>\n+  parse_closure_expr_pratt (const_TokenPtr tok,\n+\t\t\t    ::std::vector<AST::Attribute> outer_attrs\n+\t\t\t    = ::std::vector<AST::Attribute> ());\n+  ::std::unique_ptr<AST::TupleIndexExpr> parse_tuple_index_expr_float (\n+    const_TokenPtr tok, ::std::unique_ptr<AST::Expr> tuple_expr,\n+    ::std::vector<AST::Attribute> outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+\n+  // Expression-related (non-Pratt parsed)\n+  ::std::unique_ptr<AST::ExprWithoutBlock>\n+  parse_expr_without_block (::std::vector<AST::Attribute> outer_attrs\n+\t\t\t    = ::std::vector<AST::Attribute> ());\n+  ::std::unique_ptr<AST::BlockExpr>\n+  parse_block_expr (::std::vector<AST::Attribute> outer_attrs\n+\t\t    = ::std::vector<AST::Attribute> (),\n+\t\t    bool pratt_parse = false);\n+  ::std::unique_ptr<AST::IfExpr>\n+  parse_if_expr (::std::vector<AST::Attribute> outer_attrs\n+\t\t = ::std::vector<AST::Attribute> ());\n+  ::std::unique_ptr<AST::IfLetExpr>\n+  parse_if_let_expr (::std::vector<AST::Attribute> outer_attrs\n+\t\t     = ::std::vector<AST::Attribute> ());\n+  ::std::unique_ptr<AST::LoopExpr>\n+  parse_loop_expr (::std::vector<AST::Attribute> outer_attrs\n+\t\t   = ::std::vector<AST::Attribute> (),\n+\t\t   AST::LoopLabel label = AST::LoopLabel::error ());\n+  ::std::unique_ptr<AST::WhileLoopExpr>\n+  parse_while_loop_expr (::std::vector<AST::Attribute> outer_attrs\n+\t\t\t = ::std::vector<AST::Attribute> (),\n+\t\t\t AST::LoopLabel label = AST::LoopLabel::error ());\n+  ::std::unique_ptr<AST::WhileLetLoopExpr>\n+  parse_while_let_loop_expr (::std::vector<AST::Attribute> outer_attrs\n+\t\t\t     = ::std::vector<AST::Attribute> (),\n+\t\t\t     AST::LoopLabel label = AST::LoopLabel::error ());\n+  ::std::unique_ptr<AST::ForLoopExpr>\n+  parse_for_loop_expr (::std::vector<AST::Attribute> outer_attrs\n+\t\t       = ::std::vector<AST::Attribute> (),\n+\t\t       AST::LoopLabel label = AST::LoopLabel::error ());\n+  ::std::unique_ptr<AST::MatchExpr>\n+  parse_match_expr (::std::vector<AST::Attribute> outer_attrs\n+\t\t    = ::std::vector<AST::Attribute> (),\n+\t\t    bool pratt_parse = false);\n+  AST::MatchArm parse_match_arm ();\n+  ::std::vector< ::std::unique_ptr<AST::Pattern> >\n+  parse_match_arm_patterns (TokenId end_token_id);\n+  ::std::unique_ptr<AST::BaseLoopExpr>\n+  parse_labelled_loop_expr (::std::vector<AST::Attribute> outer_attrs\n+\t\t\t    = ::std::vector<AST::Attribute> ());\n+  AST::LoopLabel parse_loop_label ();\n+  ::std::unique_ptr<AST::AsyncBlockExpr>\n+  parse_async_block_expr (::std::vector<AST::Attribute> outer_attrs\n+\t\t\t  = ::std::vector<AST::Attribute> ());\n+  ::std::unique_ptr<AST::UnsafeBlockExpr>\n+  parse_unsafe_block_expr (::std::vector<AST::Attribute> outer_attrs\n+\t\t\t   = ::std::vector<AST::Attribute> ());\n+  ::std::unique_ptr<AST::GroupedExpr>\n+  parse_grouped_expr (::std::vector<AST::Attribute> outer_attrs\n+\t\t      = ::std::vector<AST::Attribute> ());\n+  ::std::unique_ptr<AST::ClosureExpr>\n+  parse_closure_expr (::std::vector<AST::Attribute> outer_attrs\n+\t\t      = ::std::vector<AST::Attribute> ());\n+  AST::ClosureParam parse_closure_param ();\n+  ::std::unique_ptr<AST::LiteralExpr>\n+  parse_literal_expr (::std::vector<AST::Attribute> outer_attrs\n+\t\t      = ::std::vector<AST::Attribute> ());\n+  ::std::unique_ptr<AST::ReturnExpr>\n+  parse_return_expr (::std::vector<AST::Attribute> outer_attrs\n+\t\t     = ::std::vector<AST::Attribute> (),\n+\t\t     bool pratt_parse = false);\n+  ::std::unique_ptr<AST::BreakExpr>\n+  parse_break_expr (::std::vector<AST::Attribute> outer_attrs\n+\t\t    = ::std::vector<AST::Attribute> (),\n+\t\t    bool pratt_parse = false);\n+  ::std::unique_ptr<AST::ContinueExpr>\n+  parse_continue_expr (::std::vector<AST::Attribute> outer_attrs\n+\t\t       = ::std::vector<AST::Attribute> (),\n+\t\t       bool pratt_parse = false);\n+  ::std::unique_ptr<AST::ArrayExpr>\n+  parse_array_expr (::std::vector<AST::Attribute> outer_attrs\n+\t\t    = ::std::vector<AST::Attribute> (),\n+\t\t    bool pratt_parse = false);\n+  ::std::unique_ptr<AST::ExprWithoutBlock>\n+  parse_grouped_or_tuple_expr (::std::vector<AST::Attribute> outer_attrs\n+\t\t\t       = ::std::vector<AST::Attribute> (),\n+\t\t\t       bool pratt_parse = false);\n+  ::std::unique_ptr<AST::StructExprField> parse_struct_expr_field ();\n+\n+  // Type-related\n+  ::std::unique_ptr<AST::Type> parse_type ();\n+  ::std::unique_ptr<AST::TypeNoBounds> parse_type_no_bounds ();\n+  ::std::unique_ptr<AST::TypeNoBounds> parse_slice_or_array_type ();\n+  ::std::unique_ptr<AST::RawPointerType> parse_raw_pointer_type ();\n+  ::std::unique_ptr<AST::ReferenceType> parse_reference_type ();\n+  ::std::unique_ptr<AST::BareFunctionType>\n+  parse_bare_function_type (::std::vector<AST::LifetimeParam> for_lifetimes);\n+  ::std::unique_ptr<AST::Type> parse_paren_prefixed_type ();\n+  ::std::unique_ptr<AST::TypeNoBounds> parse_paren_prefixed_type_no_bounds ();\n+  ::std::unique_ptr<AST::Type> parse_for_prefixed_type ();\n+  AST::MaybeNamedParam parse_maybe_named_param ();\n+\n+  // Statement-related\n+  ::std::unique_ptr<AST::Stmt> parse_stmt ();\n+  ::std::unique_ptr<AST::LetStmt>\n+  parse_let_stmt (::std::vector<AST::Attribute> outer_attrs);\n+  ::std::unique_ptr<AST::ExprStmt>\n+  parse_expr_stmt (::std::vector<AST::Attribute> outer_attrs);\n+  ::std::unique_ptr<AST::ExprStmtWithBlock>\n+  parse_expr_stmt_with_block (::std::vector<AST::Attribute> outer_attrs);\n+  ::std::unique_ptr<AST::ExprStmtWithoutBlock>\n+  parse_expr_stmt_without_block (::std::vector<AST::Attribute> outer_attrs);\n+  ExprOrStmt parse_stmt_or_expr_without_block ();\n+  ExprOrStmt\n+  parse_macro_invocation_maybe_semi (::std::vector<AST::Attribute> outer_attrs);\n+  ExprOrStmt\n+  parse_path_based_stmt_or_expr (::std::vector<AST::Attribute> outer_attrs);\n+\n+  // Pattern-related\n+  ::std::unique_ptr<AST::Pattern> parse_pattern ();\n+  ::std::unique_ptr<AST::Pattern> parse_literal_or_range_pattern ();\n+  ::std::unique_ptr<AST::RangePatternBound> parse_range_pattern_bound ();\n+  ::std::unique_ptr<AST::ReferencePattern> parse_reference_pattern ();\n+  ::std::unique_ptr<AST::Pattern> parse_grouped_or_tuple_pattern ();\n+  ::std::unique_ptr<AST::SlicePattern> parse_slice_pattern ();\n+  ::std::unique_ptr<AST::IdentifierPattern> parse_identifier_pattern ();\n+  ::std::unique_ptr<AST::Pattern> parse_ident_leading_pattern ();\n+  ::std::unique_ptr<AST::TupleStructItems> parse_tuple_struct_items ();\n+  AST::StructPatternElements parse_struct_pattern_elems ();\n+  ::std::unique_ptr<AST::StructPatternField> parse_struct_pattern_field ();\n+\n+  int left_binding_power (const_TokenPtr token);\n+\n+  bool done_end ();\n+  bool done_end_or_else ();\n+  bool done_end_of_file ();\n+\n+public:\n+  // Construct parser with specified lexer reference.\n+  Parser (Lexer &parLexer) : lexer (parLexer) {}\n+\n+  // Main entry point for parser.\n+  AST::Crate parse_crate ();\n+\n+  // Dumps all lexer output.\n+  void debug_dump_lex_output ();\n+  void debug_dump_ast_output ();\n+\n+private:\n+  // The lexer associated with the parser.\n+  Lexer &lexer;\n+};\n+} // namespace Rust\n \n #endif // RUST_PARSE_H"}, {"sha": "49c7ebd72f8596b729f5372fd02f8b7e7ef0b0b7", "filename": "gcc/rust/rust-backend.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Frust-backend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Frust-backend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.c?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -1,21 +1,21 @@\n /* rust-backend.c -- Rust frontend interface to gcc backend.\n-   Copyright (C) 2010-2019 Free Software Foundation, Inc.\n+   Copyright (C) 2010-2020 Free Software Foundation, Inc.\n \n-This file is part of GCC.\n+   This file is part of GCC.\n \n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n \n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -28,7 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"simple-object.h\"\n #include \"stor-layout.h\"\n #include \"intl.h\"\n-#include \"output.h\"\t/* for assemble_string */\n+#include \"output.h\"     /* for assemble_string */\n #include \"common/common-target.h\"\n //#include \"rust-c.h\" // import no longer exists, so hopefully not broken\n \n@@ -110,8 +110,8 @@ rust_write_export_data (const char *bytes, unsigned int size)\n     {\n       gcc_assert (targetm_common.have_named_sections);\n       sec = get_section (RUST_EXPORT_SECTION_NAME,\n-\t\t\t TARGET_AIX ? SECTION_EXCLUDE : SECTION_DEBUG,\n-\t\t\t NULL);\n+                         TARGET_AIX ? SECTION_EXCLUDE : SECTION_DEBUG,\n+                         NULL);\n     }\n \n   switch_to_section (sec);\n@@ -131,7 +131,7 @@ rust_write_export_data (const char *bytes, unsigned int size)\n \n const char *\n rust_read_export_data (int fd, off_t offset, char **pbuf, size_t *plen,\n-\t\t     int *perr)\n+\t\t       int *perr)\n {\n   simple_object_read *sobj;\n   const char *errmsg;\n@@ -145,20 +145,20 @@ rust_read_export_data (int fd, off_t offset, char **pbuf, size_t *plen,\n   *plen = 0;\n \n   sobj = simple_object_start_read (fd, offset, RUST_EXPORT_SEGMENT_NAME,\n-\t\t\t\t   &errmsg, perr);\n+                                   &errmsg, perr);\n   if (sobj == NULL)\n     {\n       /* If we get an error here, just pretend that we didn't find any\n-\t export data.  This is the right thing to do if the error is\n-\t that the file was not recognized as an object file.  This\n-\t will ignore file I/O errors, but it's not too big a deal\n-\t because we will wind up giving some other error later.  */\n+         export data.  This is the right thing to do if the error is\n+         that the file was not recognized as an object file.  This\n+         will ignore file I/O errors, but it's not too big a deal\n+         because we will wind up giving some other error later.  */\n       return NULL;\n     }\n \n   found = simple_object_find_section (sobj, RUST_EXPORT_SECTION_NAME,\n-\t\t\t\t      &sec_offset, &sec_length,\n-\t\t\t\t      &errmsg, perr);\n+                                      &sec_offset, &sec_length,\n+                                      &errmsg, perr);\n   simple_object_release_read (sobj);\n   if (!found)\n     return errmsg;"}, {"sha": "f56aaff8cc5d362c6ea0ebf4091398612ab6004d", "filename": "gcc/rust/rust-buffered-queue.h", "status": "modified", "additions": 135, "deletions": 120, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Frust-buffered-queue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Frust-buffered-queue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-buffered-queue.h?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -8,123 +8,138 @@\n // order: config, system\n \n namespace Rust {\n-    // Buffered queue implementation. Items are of type T, queue source is of type Source.\n-    template<typename T, typename Source>\n-    class buffered_queue {\n-      public:\n-        // Construct empty queue from Source& src.\n-        buffered_queue(Source& src) : source(src), start(0), end(0), buffer() {}\n-\n-        // Returns token at position start + n (i.e. n tokens ahead). \n-        T peek(int n) {\n-            // n should not be behind\n-            gcc_assert(n >= 0);\n-\n-            int num_queued_items = end - start;\n-            int num_items_required = n + 1;\n-\n-            // if required items go past end of queue, add them to queue\n-            if (num_items_required > num_queued_items) {\n-                int num_items_to_read = num_items_required - num_queued_items;\n-\n-                // if queue length + extra items is larger than buffer size, expand buffer\n-                if (end + num_items_to_read > (int)buffer.size()) {\n-                    // Resize the buffer by 1.5x\n-                    int new_size = (buffer.size() + num_items_to_read);\n-                    new_size += (new_size >> 1);\n-\n-                    // create new queue buffer with new size\n-                    std::vector<T> new_queue(new_size);\n-                    std::copy(buffer.begin() + start, buffer.begin() + end, new_queue.begin());\n-                    start = 0;\n-                    end = num_queued_items;\n-\n-                    // swap member buffer and new queue buffer\n-                    std::swap(buffer, new_queue);\n-\n-                    // validate that buffer is large enough now\n-                    gcc_assert(end + num_queued_items < (int)buffer.size());\n-                }\n-\n-                // iterate through buffer and invoke operator () on source on values past original end\n-                for (int i = 0; i < num_items_to_read; i++) {\n-                    buffer[end + i] = source();\n-                }\n-\n-                // move end based on additional items added\n-                end += num_items_to_read;\n-            }\n-\n-            gcc_assert(0 <= start);\n-            gcc_assert(start <= end);\n-            gcc_assert(end <= (int)buffer.size());\n-\n-            gcc_assert(start + n < end);\n-\n-            // return value at start + n in buffer\n-            return buffer[start + n];\n-        }\n-\n-        // TODO: add faster peek current token to remove overhead of conditional branches?\n-\n-        // Advances start by n + 1.\n-        void skip(int n) {\n-            // Call peek to ensure requested n is actually in queue.\n-            peek(n);\n-\n-            // Clear values from start to n (inclusive).\n-            for (int i = 0; i < (n + 1); i++) {\n-                // Clear value at index\n-                buffer[start + i] = T();\n-            }\n-\n-            // Move start forward by n + 1.\n-            start += (n + 1);\n-\n-            // Ensure start is not impossible somehow\n-            gcc_assert(0 <= start);\n-            gcc_assert(start <= end);\n-\n-            // Compact buffer if empty\n-            if (start == end) {\n-                start = end = 0;\n-            }\n-        }\n-\n-        /* Inserts element at front of vector. Really dirty hack with terrible performance, only use \n-         * when really needed. */\n-        void insert_at_front(T elem_to_insert) {\n-            // TODO: test as this may not work properly\n-\n-            // Insert actual element in buffer at start.\n-            buffer.insert(buffer.begin(), 1, elem_to_insert);\n-\n-            // Increase the end number since added element means all others have shifted one along\n-            end++;\n-        }\n-\n-        // Replaces the current value in the buffer. Total HACK.\n-        void replace_current_value(T replacement) {\n-            // call peek to ensure value exists\n-            peek(0);\n-\n-            buffer[start] = replacement;\n-\n-            // don't move start or end\n-        }\n-\n-      private:\n-        // Source of tokens for queue.\n-        Source& source;\n-\n-        // Begin of range in buffer, inclusive.\n-        int start;\n-        // End of range in buffer, exclusive.\n-        int end;\n-\n-        // Queue buffer.\n-        std::vector<T> buffer;\n-    };\n-}\n-\n-#endif\n\\ No newline at end of file\n+// Buffered queue implementation. Items are of type T, queue source is of type\n+// Source.\n+template <typename T, typename Source> class buffered_queue\n+{\n+public:\n+  // Construct empty queue from Source& src.\n+  buffered_queue (Source &src) : source (src), start (0), end (0), buffer () {}\n+\n+  // Returns token at position start + n (i.e. n tokens ahead).\n+  T peek (int n)\n+  {\n+    // n should not be behind\n+    gcc_assert (n >= 0);\n+\n+    int num_queued_items = end - start;\n+    int num_items_required = n + 1;\n+\n+    // if required items go past end of queue, add them to queue\n+    if (num_items_required > num_queued_items)\n+      {\n+\tint num_items_to_read = num_items_required - num_queued_items;\n+\n+\t// if queue length + extra items is larger than buffer size, expand\n+\t// buffer\n+\tif (end + num_items_to_read > (int) buffer.size ())\n+\t  {\n+\t    // Resize the buffer by 1.5x\n+\t    int new_size = (buffer.size () + num_items_to_read);\n+\t    new_size += (new_size >> 1);\n+\n+\t    // create new queue buffer with new size\n+\t    std::vector<T> new_queue (new_size);\n+\t    std::copy (buffer.begin () + start, buffer.begin () + end,\n+\t\t       new_queue.begin ());\n+\t    start = 0;\n+\t    end = num_queued_items;\n+\n+\t    // swap member buffer and new queue buffer\n+\t    std::swap (buffer, new_queue);\n+\n+\t    // validate that buffer is large enough now\n+\t    gcc_assert (end + num_queued_items < (int) buffer.size ());\n+\t  }\n+\n+\t// iterate through buffer and invoke operator () on source on values\n+\t// past original end\n+\tfor (int i = 0; i < num_items_to_read; i++)\n+\t  {\n+\t    buffer[end + i] = source ();\n+\t  }\n+\n+\t// move end based on additional items added\n+\tend += num_items_to_read;\n+      }\n+\n+    gcc_assert (0 <= start);\n+    gcc_assert (start <= end);\n+    gcc_assert (end <= (int) buffer.size ());\n+\n+    gcc_assert (start + n < end);\n+\n+    // return value at start + n in buffer\n+    return buffer[start + n];\n+  }\n+\n+  // TODO: add faster peek current token to remove overhead of conditional\n+  // branches?\n+\n+  // Advances start by n + 1.\n+  void skip (int n)\n+  {\n+    // Call peek to ensure requested n is actually in queue.\n+    peek (n);\n+\n+    // Clear values from start to n (inclusive).\n+    for (int i = 0; i < (n + 1); i++)\n+      {\n+\t// Clear value at index\n+\tbuffer[start + i] = T ();\n+      }\n+\n+    // Move start forward by n + 1.\n+    start += (n + 1);\n+\n+    // Ensure start is not impossible somehow\n+    gcc_assert (0 <= start);\n+    gcc_assert (start <= end);\n+\n+    // Compact buffer if empty\n+    if (start == end)\n+      {\n+\tstart = end = 0;\n+      }\n+  }\n+\n+  /* Inserts element at front of vector. Really dirty hack with terrible\n+   * performance, only use when really needed. */\n+  void insert_at_front (T elem_to_insert)\n+  {\n+    // TODO: test as this may not work properly\n+\n+    // Insert actual element in buffer at start.\n+    buffer.insert (buffer.begin (), 1, elem_to_insert);\n+\n+    // Increase the end number since added element means all others have shifted\n+    // one along\n+    end++;\n+  }\n+\n+  // Replaces the current value in the buffer. Total HACK.\n+  void replace_current_value (T replacement)\n+  {\n+    // call peek to ensure value exists\n+    peek (0);\n+\n+    buffer[start] = replacement;\n+\n+    // don't move start or end\n+  }\n+\n+private:\n+  // Source of tokens for queue.\n+  Source &source;\n+\n+  // Begin of range in buffer, inclusive.\n+  int start;\n+  // End of range in buffer, exclusive.\n+  int end;\n+\n+  // Queue buffer.\n+  std::vector<T> buffer;\n+};\n+} // namespace Rust\n+\n+#endif"}, {"sha": "8e32f78ae3226b00fe637f125966550415dc970e", "filename": "gcc/rust/rust-diagnostics.cc", "status": "modified", "additions": 104, "deletions": 103, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Frust-diagnostics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Frust-diagnostics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-diagnostics.cc?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -1,5 +1,5 @@\n // rust-diagnostics.cc -- GCC implementation of rust diagnostics interface.\n-// Copyright (C) 2016-2019 Free Software Foundation, Inc.\n+// Copyright (C) 2016-2020 Free Software Foundation, Inc.\n // Contributed by Than McIntosh, Google.\n \n // This file is part of GCC.\n@@ -22,194 +22,195 @@\n #include \"rust-diagnostics.h\"\n \n static std::string\n-mformat_value()\n+mformat_value ()\n {\n-  return std::string(xstrerror(errno));\n+  return std::string (xstrerror (errno));\n }\n \n // Rewrite a format string to expand any extensions not\n // supported by sprintf(). See comments in rust-diagnostics.h\n // for list of supported format specifiers.\n \n static std::string\n-expand_format(const char* fmt)\n+expand_format (const char *fmt)\n {\n   std::stringstream ss;\n-  for (const char* c = fmt; *c; ++c)\n+  for (const char *c = fmt; *c; ++c)\n     {\n       if (*c != '%')\n-        {\n-          ss << *c;\n-          continue;\n-        }\n+\t{\n+\t  ss << *c;\n+\t  continue;\n+\t}\n       c++;\n       switch (*c)\n-        {\n-          case '\\0':\n-            {\n-              // malformed format string\n-              rust_unreachable();\n-            }\n-          case '%':\n-            {\n-              ss << \"%\";\n-              break;\n-            }\n-          case 'm':\n-            {\n-              ss << mformat_value();\n-              break;\n-            }\n-          case '<':\n-            {\n-              ss << rust_open_quote();\n-              break;\n-            }\n-          case '>':\n-            {\n-              ss << rust_close_quote();\n-              break;\n-            }\n-          case 'q':\n-            {\n-              ss << rust_open_quote();\n-              c++;\n-              if (*c == 'm')\n-                {\n-                  ss << mformat_value();\n-                }\n-              else\n-                {\n-                  ss << \"%\" << *c;\n-                }\n-              ss << rust_close_quote();\n-              break;\n-            }\n-          default:\n-            {\n-              ss << \"%\" << *c;\n-            }\n-        }\n+\t{\n+\tcase '\\0':\n+\t  {\n+\t    // malformed format string\n+\t    rust_unreachable ();\n+\t  }\n+\tcase '%':\n+\t  {\n+\t    ss << \"%\";\n+\t    break;\n+\t  }\n+\tcase 'm':\n+\t  {\n+\t    ss << mformat_value ();\n+\t    break;\n+\t  }\n+\tcase '<':\n+\t  {\n+\t    ss << rust_open_quote ();\n+\t    break;\n+\t  }\n+\tcase '>':\n+\t  {\n+\t    ss << rust_close_quote ();\n+\t    break;\n+\t  }\n+\tcase 'q':\n+\t  {\n+\t    ss << rust_open_quote ();\n+\t    c++;\n+\t    if (*c == 'm')\n+\t      {\n+\t\tss << mformat_value ();\n+\t      }\n+\t    else\n+\t      {\n+\t\tss << \"%\" << *c;\n+\t      }\n+\t    ss << rust_close_quote ();\n+\t    break;\n+\t  }\n+\tdefault:\n+\t  {\n+\t    ss << \"%\" << *c;\n+\t  }\n+\t}\n     }\n-  return ss.str();\n+  return ss.str ();\n }\n \n // Expand message format specifiers, using a combination of\n // expand_format above to handle extensions (ex: %m, %q) and vasprintf()\n // to handle regular printf-style formatting. A pragma is being used here to\n // suppress this warning:\n //\n-//   warning: function \u2018std::__cxx11::string expand_message(const char*, __va_list_tag*)\u2019 might be a candidate for \u2018gnu_printf\u2019 format attribute [-Wsuggest-attribute=format]\n+//   warning: function \u2018std::__cxx11::string expand_message(const char*,\n+//   __va_list_tag*)\u2019 might be a candidate for \u2018gnu_printf\u2019 format attribute\n+//   [-Wsuggest-attribute=format]\n //\n // What appears to be happening here is that the checker is deciding that\n // because of the call to vasprintf() (which has attribute gnu_printf), the\n // calling function must need to have attribute gnu_printf as well, even\n // though there is already an attribute declaration for it.\n \n static std::string\n-expand_message(const char* fmt, va_list ap) RUST_ATTRIBUTE_GCC_DIAG(1,0);\n+expand_message (const char *fmt, va_list ap) RUST_ATTRIBUTE_GCC_DIAG (1, 0);\n \n #pragma GCC diagnostic push\n #pragma GCC diagnostic ignored \"-Wsuggest-attribute=format\"\n \n static std::string\n-expand_message(const char* fmt, va_list ap)\n+expand_message (const char *fmt, va_list ap)\n {\n-  char* mbuf = 0;\n-  std::string expanded_fmt = expand_format(fmt);\n-  int nwr = vasprintf(&mbuf, expanded_fmt.c_str(), ap);\n+  char *mbuf = 0;\n+  std::string expanded_fmt = expand_format (fmt);\n+  int nwr = vasprintf (&mbuf, expanded_fmt.c_str (), ap);\n   if (nwr == -1)\n     {\n       // memory allocation failed\n-      rust_be_error_at(Linemap::unknown_location(),\n-                     \"memory allocation failed in vasprintf\");\n-      rust_assert(0);\n+      rust_be_error_at (Linemap::unknown_location (),\n+\t\t\t\"memory allocation failed in vasprintf\");\n+      rust_assert (0);\n     }\n-  std::string rval = std::string(mbuf);\n-  free(mbuf);\n+  std::string rval = std::string (mbuf);\n+  free (mbuf);\n   return rval;\n }\n \n #pragma GCC diagnostic pop\n \n-static const char* cached_open_quote = NULL;\n-static const char* cached_close_quote = NULL;\n+static const char *cached_open_quote = NULL;\n+static const char *cached_close_quote = NULL;\n \n-const char*\n-rust_open_quote()\n+const char *\n+rust_open_quote ()\n {\n   if (cached_open_quote == NULL)\n-    rust_be_get_quotechars(&cached_open_quote, &cached_close_quote);\n+    rust_be_get_quotechars (&cached_open_quote, &cached_close_quote);\n   return cached_open_quote;\n }\n \n-const char*\n-rust_close_quote()\n+const char *\n+rust_close_quote ()\n {\n   if (cached_close_quote == NULL)\n-    rust_be_get_quotechars(&cached_open_quote, &cached_close_quote);\n+    rust_be_get_quotechars (&cached_open_quote, &cached_close_quote);\n   return cached_close_quote;\n }\n \n void\n-rust_error_at(const Location location, const char* fmt, ...)\n+rust_error_at (const Location location, const char *fmt, ...)\n {\n   va_list ap;\n \n-  va_start(ap, fmt);\n-  rust_be_error_at(location, expand_message(fmt, ap));\n-  va_end(ap);\n+  va_start (ap, fmt);\n+  rust_be_error_at (location, expand_message (fmt, ap));\n+  va_end (ap);\n }\n \n void\n-rust_warning_at(const Location location, int opt, const char* fmt, ...)\n+rust_warning_at (const Location location, int opt, const char *fmt, ...)\n {\n   va_list ap;\n \n-  va_start(ap, fmt);\n-  rust_be_warning_at(location, opt, expand_message(fmt, ap));\n-  va_end(ap);\n+  va_start (ap, fmt);\n+  rust_be_warning_at (location, opt, expand_message (fmt, ap));\n+  va_end (ap);\n }\n \n void\n-rust_fatal_error(const Location location, const char* fmt, ...)\n+rust_fatal_error (const Location location, const char *fmt, ...)\n {\n   va_list ap;\n \n-  va_start(ap, fmt);\n-  rust_be_fatal_error(location, expand_message(fmt, ap));\n-  va_end(ap);\n+  va_start (ap, fmt);\n+  rust_be_fatal_error (location, expand_message (fmt, ap));\n+  va_end (ap);\n }\n \n void\n-rust_inform(const Location location, const char* fmt, ...)\n+rust_inform (const Location location, const char *fmt, ...)\n {\n   va_list ap;\n \n-  va_start(ap, fmt);\n-  rust_be_inform(location, expand_message(fmt, ap));\n-  va_end(ap);\n+  va_start (ap, fmt);\n+  rust_be_inform (location, expand_message (fmt, ap));\n+  va_end (ap);\n }\n \n // rust_debug uses normal printf formatting, not GCC diagnostic formatting.\n \n void\n-rust_debug(const Location location, const char* fmt, ...)\n+rust_debug (const Location location, const char *fmt, ...)\n {\n   va_list ap;\n \n-  va_start(ap, fmt);\n-  char* mbuf = NULL;\n-  int nwr = vasprintf(&mbuf, fmt, ap);\n-  va_end(ap);\n+  va_start (ap, fmt);\n+  char *mbuf = NULL;\n+  int nwr = vasprintf (&mbuf, fmt, ap);\n+  va_end (ap);\n   if (nwr == -1)\n     {\n-      rust_be_error_at(Linemap::unknown_location(),\n-\t\t     \"memory allocation failed in vasprintf\");\n-      rust_assert(0);\n+      rust_be_error_at (Linemap::unknown_location (),\n+\t\t\t\"memory allocation failed in vasprintf\");\n+      rust_assert (0);\n     }\n-  std::string rval = std::string(mbuf);\n-  free(mbuf);\n-  rust_be_inform(location, rval);\n+  std::string rval = std::string (mbuf);\n+  free (mbuf);\n+  rust_be_inform (location, rval);\n }\n-"}, {"sha": "04d48c8f1253d7e7359388971d6ca6a12b786822", "filename": "gcc/rust/rust-diagnostics.h", "status": "modified", "additions": 30, "deletions": 19, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Frust-diagnostics.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Frust-diagnostics.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-diagnostics.h?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -6,9 +6,11 @@\n #include \"rust-linemap.h\"\n \n #if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 1)\n-#define RUST_ATTRIBUTE_GCC_DIAG(m, n) __attribute__ ((__format__ (__gcc_tdiag__, m, n))) __attribute__ ((__nonnull__ (m)))\n+#define RUST_ATTRIBUTE_GCC_DIAG(m, n)                                          \\\n+  __attribute__ ((__format__ (__gcc_tdiag__, m, n)))                           \\\n+    __attribute__ ((__nonnull__ (m)))\n #else\n-#define RUST_ATTRIBUTE_GCC_DIAG(m,  n)\n+#define RUST_ATTRIBUTE_GCC_DIAG(m, n)\n #endif\n \n // These declarations define the interface through which the frontend\n@@ -28,33 +30,42 @@\n // All other format specifiers are as defined by 'sprintf'. The final resulting\n // message is then sent to the back end via rust_be_error_at/rust_be_warning_at.\n \n-extern void rust_error_at(const Location, const char* fmt, ...)\n-    RUST_ATTRIBUTE_GCC_DIAG(2,3);\n-extern void rust_warning_at(const Location, int opt, const char* fmt, ...)\n-    RUST_ATTRIBUTE_GCC_DIAG(3,4);\n-extern void rust_fatal_error(const Location, const char* fmt, ...)\n-    RUST_ATTRIBUTE_GCC_DIAG(2,3);\n-extern void rust_inform(const Location, const char* fmt, ...)\n-    RUST_ATTRIBUTE_GCC_DIAG(2,3);\n+extern void\n+rust_error_at (const Location, const char *fmt, ...)\n+  RUST_ATTRIBUTE_GCC_DIAG (2, 3);\n+extern void\n+rust_warning_at (const Location, int opt, const char *fmt, ...)\n+  RUST_ATTRIBUTE_GCC_DIAG (3, 4);\n+extern void\n+rust_fatal_error (const Location, const char *fmt, ...)\n+  RUST_ATTRIBUTE_GCC_DIAG (2, 3);\n+extern void\n+rust_inform (const Location, const char *fmt, ...)\n+  RUST_ATTRIBUTE_GCC_DIAG (2, 3);\n \n // These interfaces provide a way for the front end to ask for\n // the open/close quote characters it should use when formatting\n // diagnostics (warnings, errors).\n-extern const char* rust_open_quote();\n-extern const char* rust_close_quote();\n+extern const char *\n+rust_open_quote ();\n+extern const char *\n+rust_close_quote ();\n \n // These interfaces are used by utilities above to pass warnings and\n // errors (once format specifiers have been expanded) to the back end,\n // and to determine quoting style. Avoid calling these routines directly;\n // instead use the equivalent routines above. The back end is required to\n // implement these routines.\n \n-extern void rust_be_error_at(const Location, const std::string& errmsg);\n-extern void rust_be_warning_at(const Location, int opt,\n-                               const std::string& warningmsg);\n-extern void rust_be_fatal_error(const Location, const std::string& errmsg);\n-extern void rust_be_inform(const Location, const std::string& infomsg);\n-extern void rust_be_get_quotechars(const char** open_quote,\n-                                   const char** close_quote);\n+extern void\n+rust_be_error_at (const Location, const std::string &errmsg);\n+extern void\n+rust_be_warning_at (const Location, int opt, const std::string &warningmsg);\n+extern void\n+rust_be_fatal_error (const Location, const std::string &errmsg);\n+extern void\n+rust_be_inform (const Location, const std::string &infomsg);\n+extern void\n+rust_be_get_quotechars (const char **open_quote, const char **close_quote);\n \n #endif // !defined(RUST_DIAGNOSTICS_H)"}, {"sha": "6699b4706463ea7c4daad0873513d4dbe2ccd753", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 292, "deletions": 1, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -1,5 +1,5 @@\n // rust-gcc.cc -- Rust frontend to gcc IR.\n-// Copyright (C) 2011-2019 Free Software Foundation, Inc.\n+// Copyright (C) 2011-2020 Free Software Foundation, Inc.\n // Contributed by Ian Lance Taylor, Google.\n // forked from gccgo\n \n@@ -428,6 +428,7 @@ class Gcc_backend : public Backend\n   tree convert_tree (tree, tree, Location);\n \n private:\n+<<<<<<< HEAD\n   static const int builtin_const = 1 << 0;\n   static const int builtin_noreturn = 1 << 1;\n   static const int builtin_novops = 1 << 2;\n@@ -436,6 +437,13 @@ class Gcc_backend : public Backend\n \t\t       const char *libname, tree fntype, int flags);\n \n   // A mapping of the GCC built-ins exposed to GCCRust.\n+=======\n+  void define_builtin (built_in_function bcode, const char *name,\n+\t\t       const char *libname, tree fntype, bool const_p,\n+\t\t       bool noreturn_p);\n+\n+  // A mapping of the GCC built-ins exposed to GCCGo.\n+>>>>>>> 12e994a7967... Fix indentation\n   std::map<std::string, Bfunction *> builtin_functions_;\n };\n \n@@ -456,84 +464,141 @@ Gcc_backend::Gcc_backend ()\n   tree t = this->integer_type (true, BITS_PER_UNIT)->get_tree ();\n   tree p = build_pointer_type (build_qualified_type (t, TYPE_QUAL_VOLATILE));\n   this->define_builtin (BUILT_IN_SYNC_ADD_AND_FETCH_1, \"__sync_fetch_and_add_1\",\n+<<<<<<< HEAD\n \t\t\tNULL, build_function_type_list (t, p, t, NULL_TREE), 0);\n+=======\n+\t\t\tNULL, build_function_type_list (t, p, t, NULL_TREE),\n+\t\t\tfalse, false);\n+>>>>>>> 12e994a7967... Fix indentation\n \n   t = this->integer_type (true, BITS_PER_UNIT * 2)->get_tree ();\n   p = build_pointer_type (build_qualified_type (t, TYPE_QUAL_VOLATILE));\n   this->define_builtin (BUILT_IN_SYNC_ADD_AND_FETCH_2, \"__sync_fetch_and_add_2\",\n+<<<<<<< HEAD\n \t\t\tNULL, build_function_type_list (t, p, t, NULL_TREE), 0);\n+=======\n+\t\t\tNULL, build_function_type_list (t, p, t, NULL_TREE),\n+\t\t\tfalse, false);\n+>>>>>>> 12e994a7967... Fix indentation\n \n   t = this->integer_type (true, BITS_PER_UNIT * 4)->get_tree ();\n   p = build_pointer_type (build_qualified_type (t, TYPE_QUAL_VOLATILE));\n   this->define_builtin (BUILT_IN_SYNC_ADD_AND_FETCH_4, \"__sync_fetch_and_add_4\",\n+<<<<<<< HEAD\n \t\t\tNULL, build_function_type_list (t, p, t, NULL_TREE), 0);\n+=======\n+\t\t\tNULL, build_function_type_list (t, p, t, NULL_TREE),\n+\t\t\tfalse, false);\n+>>>>>>> 12e994a7967... Fix indentation\n \n   t = this->integer_type (true, BITS_PER_UNIT * 8)->get_tree ();\n   p = build_pointer_type (build_qualified_type (t, TYPE_QUAL_VOLATILE));\n   this->define_builtin (BUILT_IN_SYNC_ADD_AND_FETCH_8, \"__sync_fetch_and_add_8\",\n+<<<<<<< HEAD\n \t\t\tNULL, build_function_type_list (t, p, t, NULL_TREE), 0);\n+=======\n+\t\t\tNULL, build_function_type_list (t, p, t, NULL_TREE),\n+\t\t\tfalse, false);\n+>>>>>>> 12e994a7967... Fix indentation\n \n   // We use __builtin_expect for magic import functions.\n   this->define_builtin (BUILT_IN_EXPECT, \"__builtin_expect\", NULL,\n \t\t\tbuild_function_type_list (long_integer_type_node,\n \t\t\t\t\t\t  long_integer_type_node,\n \t\t\t\t\t\t  long_integer_type_node,\n \t\t\t\t\t\t  NULL_TREE),\n+<<<<<<< HEAD\n \t\t\tbuiltin_const);\n+=======\n+\t\t\ttrue, false);\n+>>>>>>> 12e994a7967... Fix indentation\n \n   // We use __builtin_memcmp for struct comparisons.\n   this->define_builtin (BUILT_IN_MEMCMP, \"__builtin_memcmp\", \"memcmp\",\n \t\t\tbuild_function_type_list (integer_type_node,\n \t\t\t\t\t\t  const_ptr_type_node,\n \t\t\t\t\t\t  const_ptr_type_node,\n \t\t\t\t\t\t  size_type_node, NULL_TREE),\n+<<<<<<< HEAD\n \t\t\t0);\n+=======\n+\t\t\tfalse, false);\n+>>>>>>> 12e994a7967... Fix indentation\n \n   // We use __builtin_memmove for copying data.\n   this->define_builtin (BUILT_IN_MEMMOVE, \"__builtin_memmove\", \"memmove\",\n \t\t\tbuild_function_type_list (void_type_node, ptr_type_node,\n \t\t\t\t\t\t  const_ptr_type_node,\n \t\t\t\t\t\t  size_type_node, NULL_TREE),\n+<<<<<<< HEAD\n \t\t\t0);\n+=======\n+\t\t\tfalse, false);\n+>>>>>>> 12e994a7967... Fix indentation\n \n   // We use __builtin_memset for zeroing data.\n   this->define_builtin (BUILT_IN_MEMSET, \"__builtin_memset\", \"memset\",\n \t\t\tbuild_function_type_list (void_type_node, ptr_type_node,\n \t\t\t\t\t\t  integer_type_node,\n \t\t\t\t\t\t  size_type_node, NULL_TREE),\n+<<<<<<< HEAD\n \t\t\t0);\n+=======\n+\t\t\tfalse, false);\n+>>>>>>> 12e994a7967... Fix indentation\n \n   // Used by runtime/internal/sys and math/bits.\n   this->define_builtin (BUILT_IN_CTZ, \"__builtin_ctz\", \"ctz\",\n \t\t\tbuild_function_type_list (integer_type_node,\n \t\t\t\t\t\t  unsigned_type_node,\n \t\t\t\t\t\t  NULL_TREE),\n+<<<<<<< HEAD\n \t\t\tbuiltin_const);\n+=======\n+\t\t\ttrue, false);\n+>>>>>>> 12e994a7967... Fix indentation\n   this->define_builtin (BUILT_IN_CTZLL, \"__builtin_ctzll\", \"ctzll\",\n \t\t\tbuild_function_type_list (integer_type_node,\n \t\t\t\t\t\t  long_long_unsigned_type_node,\n \t\t\t\t\t\t  NULL_TREE),\n+<<<<<<< HEAD\n \t\t\tbuiltin_const);\n+=======\n+\t\t\ttrue, false);\n+>>>>>>> 12e994a7967... Fix indentation\n   this->define_builtin (BUILT_IN_CLZ, \"__builtin_clz\", \"clz\",\n \t\t\tbuild_function_type_list (integer_type_node,\n \t\t\t\t\t\t  unsigned_type_node,\n \t\t\t\t\t\t  NULL_TREE),\n+<<<<<<< HEAD\n \t\t\tbuiltin_const);\n+=======\n+\t\t\ttrue, false);\n+>>>>>>> 12e994a7967... Fix indentation\n   this->define_builtin (BUILT_IN_CLZLL, \"__builtin_clzll\", \"clzll\",\n \t\t\tbuild_function_type_list (integer_type_node,\n \t\t\t\t\t\t  long_long_unsigned_type_node,\n \t\t\t\t\t\t  NULL_TREE),\n+<<<<<<< HEAD\n \t\t\tbuiltin_const);\n+=======\n+\t\t\ttrue, false);\n+>>>>>>> 12e994a7967... Fix indentation\n   this->define_builtin (BUILT_IN_POPCOUNT, \"__builtin_popcount\", \"popcount\",\n \t\t\tbuild_function_type_list (integer_type_node,\n \t\t\t\t\t\t  unsigned_type_node,\n \t\t\t\t\t\t  NULL_TREE),\n+<<<<<<< HEAD\n \t\t\tbuiltin_const);\n+=======\n+\t\t\ttrue, false);\n+>>>>>>> 12e994a7967... Fix indentation\n   this->define_builtin (BUILT_IN_POPCOUNTLL, \"__builtin_popcountll\",\n \t\t\t\"popcountll\",\n \t\t\tbuild_function_type_list (integer_type_node,\n \t\t\t\t\t\t  long_long_unsigned_type_node,\n \t\t\t\t\t\t  NULL_TREE),\n+<<<<<<< HEAD\n \t\t\tbuiltin_const);\n   this->define_builtin (BUILT_IN_BSWAP16, \"__builtin_bswap16\", \"bswap16\",\n \t\t\tbuild_function_type_list (uint16_type_node,\n@@ -547,6 +612,21 @@ Gcc_backend::Gcc_backend ()\n \t\t\tbuild_function_type_list (uint64_type_node,\n \t\t\t\t\t\t  uint64_type_node, NULL_TREE),\n \t\t\tbuiltin_const);\n+=======\n+\t\t\ttrue, false);\n+  this->define_builtin (BUILT_IN_BSWAP16, \"__builtin_bswap16\", \"bswap16\",\n+\t\t\tbuild_function_type_list (uint16_type_node,\n+\t\t\t\t\t\t  uint16_type_node, NULL_TREE),\n+\t\t\ttrue, false);\n+  this->define_builtin (BUILT_IN_BSWAP32, \"__builtin_bswap32\", \"bswap32\",\n+\t\t\tbuild_function_type_list (uint32_type_node,\n+\t\t\t\t\t\t  uint32_type_node, NULL_TREE),\n+\t\t\ttrue, false);\n+  this->define_builtin (BUILT_IN_BSWAP64, \"__builtin_bswap64\", \"bswap64\",\n+\t\t\tbuild_function_type_list (uint64_type_node,\n+\t\t\t\t\t\t  uint64_type_node, NULL_TREE),\n+\t\t\ttrue, false);\n+>>>>>>> 12e994a7967... Fix indentation\n \n   // We provide some functions for the math library.\n   tree math_function_type\n@@ -561,6 +641,7 @@ Gcc_backend::Gcc_backend ()\n     = build_function_type_list (long_double_type_node, long_double_type_node,\n \t\t\t\tlong_double_type_node, NULL_TREE);\n   this->define_builtin (BUILT_IN_ACOS, \"__builtin_acos\", \"acos\",\n+<<<<<<< HEAD\n \t\t\tmath_function_type, builtin_const);\n   this->define_builtin (BUILT_IN_ACOSL, \"__builtin_acosl\", \"acosl\",\n \t\t\tmath_function_type_long, builtin_const);\n@@ -604,15 +685,65 @@ Gcc_backend::Gcc_backend ()\n \t\t\tmath_function_type_two, builtin_const);\n   this->define_builtin (BUILT_IN_FMODL, \"__builtin_fmodl\", \"fmodl\",\n \t\t\tmath_function_type_long_two, builtin_const);\n+=======\n+\t\t\tmath_function_type, true, false);\n+  this->define_builtin (BUILT_IN_ACOSL, \"__builtin_acosl\", \"acosl\",\n+\t\t\tmath_function_type_long, true, false);\n+  this->define_builtin (BUILT_IN_ASIN, \"__builtin_asin\", \"asin\",\n+\t\t\tmath_function_type, true, false);\n+  this->define_builtin (BUILT_IN_ASINL, \"__builtin_asinl\", \"asinl\",\n+\t\t\tmath_function_type_long, true, false);\n+  this->define_builtin (BUILT_IN_ATAN, \"__builtin_atan\", \"atan\",\n+\t\t\tmath_function_type, true, false);\n+  this->define_builtin (BUILT_IN_ATANL, \"__builtin_atanl\", \"atanl\",\n+\t\t\tmath_function_type_long, true, false);\n+  this->define_builtin (BUILT_IN_ATAN2, \"__builtin_atan2\", \"atan2\",\n+\t\t\tmath_function_type_two, true, false);\n+  this->define_builtin (BUILT_IN_ATAN2L, \"__builtin_atan2l\", \"atan2l\",\n+\t\t\tmath_function_type_long_two, true, false);\n+  this->define_builtin (BUILT_IN_CEIL, \"__builtin_ceil\", \"ceil\",\n+\t\t\tmath_function_type, true, false);\n+  this->define_builtin (BUILT_IN_CEILL, \"__builtin_ceill\", \"ceill\",\n+\t\t\tmath_function_type_long, true, false);\n+  this->define_builtin (BUILT_IN_COS, \"__builtin_cos\", \"cos\",\n+\t\t\tmath_function_type, true, false);\n+  this->define_builtin (BUILT_IN_COSL, \"__builtin_cosl\", \"cosl\",\n+\t\t\tmath_function_type_long, true, false);\n+  this->define_builtin (BUILT_IN_EXP, \"__builtin_exp\", \"exp\",\n+\t\t\tmath_function_type, true, false);\n+  this->define_builtin (BUILT_IN_EXPL, \"__builtin_expl\", \"expl\",\n+\t\t\tmath_function_type_long, true, false);\n+  this->define_builtin (BUILT_IN_EXPM1, \"__builtin_expm1\", \"expm1\",\n+\t\t\tmath_function_type, true, false);\n+  this->define_builtin (BUILT_IN_EXPM1L, \"__builtin_expm1l\", \"expm1l\",\n+\t\t\tmath_function_type_long, true, false);\n+  this->define_builtin (BUILT_IN_FABS, \"__builtin_fabs\", \"fabs\",\n+\t\t\tmath_function_type, true, false);\n+  this->define_builtin (BUILT_IN_FABSL, \"__builtin_fabsl\", \"fabsl\",\n+\t\t\tmath_function_type_long, true, false);\n+  this->define_builtin (BUILT_IN_FLOOR, \"__builtin_floor\", \"floor\",\n+\t\t\tmath_function_type, true, false);\n+  this->define_builtin (BUILT_IN_FLOORL, \"__builtin_floorl\", \"floorl\",\n+\t\t\tmath_function_type_long, true, false);\n+  this->define_builtin (BUILT_IN_FMOD, \"__builtin_fmod\", \"fmod\",\n+\t\t\tmath_function_type_two, true, false);\n+  this->define_builtin (BUILT_IN_FMODL, \"__builtin_fmodl\", \"fmodl\",\n+\t\t\tmath_function_type_long_two, true, false);\n+>>>>>>> 12e994a7967... Fix indentation\n   this->define_builtin (BUILT_IN_LDEXP, \"__builtin_ldexp\", \"ldexp\",\n \t\t\tbuild_function_type_list (double_type_node,\n \t\t\t\t\t\t  double_type_node,\n \t\t\t\t\t\t  integer_type_node, NULL_TREE),\n+<<<<<<< HEAD\n \t\t\tbuiltin_const);\n+=======\n+\t\t\ttrue, false);\n+>>>>>>> 12e994a7967... Fix indentation\n   this->define_builtin (BUILT_IN_LDEXPL, \"__builtin_ldexpl\", \"ldexpl\",\n \t\t\tbuild_function_type_list (long_double_type_node,\n \t\t\t\t\t\t  long_double_type_node,\n \t\t\t\t\t\t  integer_type_node, NULL_TREE),\n+<<<<<<< HEAD\n \t\t\tbuiltin_const);\n   this->define_builtin (BUILT_IN_LOG, \"__builtin_log\", \"log\",\n \t\t\tmath_function_type, builtin_const);\n@@ -646,11 +777,47 @@ Gcc_backend::Gcc_backend ()\n \t\t\tmath_function_type, builtin_const);\n   this->define_builtin (BUILT_IN_TRUNCL, \"__builtin_truncl\", \"truncl\",\n \t\t\tmath_function_type_long, builtin_const);\n+=======\n+\t\t\ttrue, false);\n+  this->define_builtin (BUILT_IN_LOG, \"__builtin_log\", \"log\",\n+\t\t\tmath_function_type, true, false);\n+  this->define_builtin (BUILT_IN_LOGL, \"__builtin_logl\", \"logl\",\n+\t\t\tmath_function_type_long, true, false);\n+  this->define_builtin (BUILT_IN_LOG1P, \"__builtin_log1p\", \"log1p\",\n+\t\t\tmath_function_type, true, false);\n+  this->define_builtin (BUILT_IN_LOG1PL, \"__builtin_log1pl\", \"log1pl\",\n+\t\t\tmath_function_type_long, true, false);\n+  this->define_builtin (BUILT_IN_LOG10, \"__builtin_log10\", \"log10\",\n+\t\t\tmath_function_type, true, false);\n+  this->define_builtin (BUILT_IN_LOG10L, \"__builtin_log10l\", \"log10l\",\n+\t\t\tmath_function_type_long, true, false);\n+  this->define_builtin (BUILT_IN_LOG2, \"__builtin_log2\", \"log2\",\n+\t\t\tmath_function_type, true, false);\n+  this->define_builtin (BUILT_IN_LOG2L, \"__builtin_log2l\", \"log2l\",\n+\t\t\tmath_function_type_long, true, false);\n+  this->define_builtin (BUILT_IN_SIN, \"__builtin_sin\", \"sin\",\n+\t\t\tmath_function_type, true, false);\n+  this->define_builtin (BUILT_IN_SINL, \"__builtin_sinl\", \"sinl\",\n+\t\t\tmath_function_type_long, true, false);\n+  this->define_builtin (BUILT_IN_SQRT, \"__builtin_sqrt\", \"sqrt\",\n+\t\t\tmath_function_type, true, false);\n+  this->define_builtin (BUILT_IN_SQRTL, \"__builtin_sqrtl\", \"sqrtl\",\n+\t\t\tmath_function_type_long, true, false);\n+  this->define_builtin (BUILT_IN_TAN, \"__builtin_tan\", \"tan\",\n+\t\t\tmath_function_type, true, false);\n+  this->define_builtin (BUILT_IN_TANL, \"__builtin_tanl\", \"tanl\",\n+\t\t\tmath_function_type_long, true, false);\n+  this->define_builtin (BUILT_IN_TRUNC, \"__builtin_trunc\", \"trunc\",\n+\t\t\tmath_function_type, true, false);\n+  this->define_builtin (BUILT_IN_TRUNCL, \"__builtin_truncl\", \"truncl\",\n+\t\t\tmath_function_type_long, true, false);\n+>>>>>>> 12e994a7967... Fix indentation\n \n   // We use __builtin_return_address in the thunk we build for\n   // functions which call recover, and for runtime.getcallerpc.\n   t = build_function_type_list (ptr_type_node, unsigned_type_node, NULL_TREE);\n   this->define_builtin (BUILT_IN_RETURN_ADDRESS, \"__builtin_return_address\",\n+<<<<<<< HEAD\n \t\t\tNULL, t, 0);\n \n   // The runtime calls __builtin_dwarf_cfa for runtime.getcallersp.\n@@ -662,94 +829,176 @@ Gcc_backend::Gcc_backend ()\n   this->define_builtin (\n     BUILT_IN_EXTRACT_RETURN_ADDR, \"__builtin_extract_return_addr\", NULL,\n     build_function_type_list (ptr_type_node, ptr_type_node, NULL_TREE), 0);\n+=======\n+\t\t\tNULL, t, false, false);\n+\n+  // The runtime calls __builtin_dwarf_cfa for runtime.getcallersp.\n+  t = build_function_type_list (ptr_type_node, NULL_TREE);\n+  this->define_builtin (BUILT_IN_DWARF_CFA, \"__builtin_dwarf_cfa\", NULL, t,\n+\t\t\tfalse, false);\n+\n+  // The runtime calls __builtin_extract_return_addr when recording\n+  // the address to which a function returns.\n+  this->define_builtin (BUILT_IN_EXTRACT_RETURN_ADDR,\n+\t\t\t\"__builtin_extract_return_addr\", NULL,\n+\t\t\tbuild_function_type_list (ptr_type_node, ptr_type_node,\n+\t\t\t\t\t\t  NULL_TREE),\n+\t\t\tfalse, false);\n+>>>>>>> 12e994a7967... Fix indentation\n \n   // The compiler uses __builtin_trap for some exception handling\n   // cases.\n   this->define_builtin (BUILT_IN_TRAP, \"__builtin_trap\", NULL,\n \t\t\tbuild_function_type (void_type_node, void_list_node),\n+<<<<<<< HEAD\n \t\t\tbuiltin_noreturn);\n+=======\n+\t\t\tfalse, true);\n+>>>>>>> 12e994a7967... Fix indentation\n \n   // The runtime uses __builtin_prefetch.\n   this->define_builtin (BUILT_IN_PREFETCH, \"__builtin_prefetch\", NULL,\n \t\t\tbuild_varargs_function_type_list (void_type_node,\n \t\t\t\t\t\t\t  const_ptr_type_node,\n \t\t\t\t\t\t\t  NULL_TREE),\n+<<<<<<< HEAD\n \t\t\tbuiltin_novops);\n+=======\n+\t\t\tfalse, false);\n+>>>>>>> 12e994a7967... Fix indentation\n \n   // The compiler uses __builtin_unreachable for cases that cannot\n   // occur.\n   this->define_builtin (BUILT_IN_UNREACHABLE, \"__builtin_unreachable\", NULL,\n \t\t\tbuild_function_type (void_type_node, void_list_node),\n+<<<<<<< HEAD\n \t\t\tbuiltin_const | builtin_noreturn);\n+=======\n+\t\t\ttrue, true);\n+>>>>>>> 12e994a7967... Fix indentation\n \n   // We provide some atomic functions.\n   t = build_function_type_list (uint32_type_node, ptr_type_node,\n \t\t\t\tinteger_type_node, NULL_TREE);\n+<<<<<<< HEAD\n   this->define_builtin (BUILT_IN_ATOMIC_LOAD_4, \"__atomic_load_4\", NULL, t, 0);\n \n   t = build_function_type_list (uint64_type_node, ptr_type_node,\n \t\t\t\tinteger_type_node, NULL_TREE);\n   this->define_builtin (BUILT_IN_ATOMIC_LOAD_8, \"__atomic_load_8\", NULL, t, 0);\n+=======\n+  this->define_builtin (BUILT_IN_ATOMIC_LOAD_4, \"__atomic_load_4\", NULL, t,\n+\t\t\tfalse, false);\n+\n+  t = build_function_type_list (uint64_type_node, ptr_type_node,\n+\t\t\t\tinteger_type_node, NULL_TREE);\n+  this->define_builtin (BUILT_IN_ATOMIC_LOAD_8, \"__atomic_load_8\", NULL, t,\n+\t\t\tfalse, false);\n+>>>>>>> 12e994a7967... Fix indentation\n \n   t = build_function_type_list (void_type_node, ptr_type_node, uint32_type_node,\n \t\t\t\tinteger_type_node, NULL_TREE);\n   this->define_builtin (BUILT_IN_ATOMIC_STORE_4, \"__atomic_store_4\", NULL, t,\n+<<<<<<< HEAD\n \t\t\t0);\n+=======\n+\t\t\tfalse, false);\n+>>>>>>> 12e994a7967... Fix indentation\n \n   t = build_function_type_list (void_type_node, ptr_type_node, uint64_type_node,\n \t\t\t\tinteger_type_node, NULL_TREE);\n   this->define_builtin (BUILT_IN_ATOMIC_STORE_8, \"__atomic_store_8\", NULL, t,\n+<<<<<<< HEAD\n \t\t\t0);\n+=======\n+\t\t\tfalse, false);\n+>>>>>>> 12e994a7967... Fix indentation\n \n   t = build_function_type_list (uint32_type_node, ptr_type_node,\n \t\t\t\tuint32_type_node, integer_type_node, NULL_TREE);\n   this->define_builtin (BUILT_IN_ATOMIC_EXCHANGE_4, \"__atomic_exchange_4\", NULL,\n+<<<<<<< HEAD\n \t\t\tt, 0);\n+=======\n+\t\t\tt, false, false);\n+>>>>>>> 12e994a7967... Fix indentation\n \n   t = build_function_type_list (uint64_type_node, ptr_type_node,\n \t\t\t\tuint64_type_node, integer_type_node, NULL_TREE);\n   this->define_builtin (BUILT_IN_ATOMIC_EXCHANGE_8, \"__atomic_exchange_8\", NULL,\n+<<<<<<< HEAD\n \t\t\tt, 0);\n+=======\n+\t\t\tt, false, false);\n+>>>>>>> 12e994a7967... Fix indentation\n \n   t = build_function_type_list (boolean_type_node, ptr_type_node, ptr_type_node,\n \t\t\t\tuint32_type_node, boolean_type_node,\n \t\t\t\tinteger_type_node, integer_type_node,\n \t\t\t\tNULL_TREE);\n   this->define_builtin (BUILT_IN_ATOMIC_COMPARE_EXCHANGE_4,\n+<<<<<<< HEAD\n \t\t\t\"__atomic_compare_exchange_4\", NULL, t, 0);\n+=======\n+\t\t\t\"__atomic_compare_exchange_4\", NULL, t, false, false);\n+>>>>>>> 12e994a7967... Fix indentation\n \n   t = build_function_type_list (boolean_type_node, ptr_type_node, ptr_type_node,\n \t\t\t\tuint64_type_node, boolean_type_node,\n \t\t\t\tinteger_type_node, integer_type_node,\n \t\t\t\tNULL_TREE);\n   this->define_builtin (BUILT_IN_ATOMIC_COMPARE_EXCHANGE_8,\n+<<<<<<< HEAD\n \t\t\t\"__atomic_compare_exchange_8\", NULL, t, 0);\n+=======\n+\t\t\t\"__atomic_compare_exchange_8\", NULL, t, false, false);\n+>>>>>>> 12e994a7967... Fix indentation\n \n   t = build_function_type_list (uint32_type_node, ptr_type_node,\n \t\t\t\tuint32_type_node, integer_type_node, NULL_TREE);\n   this->define_builtin (BUILT_IN_ATOMIC_ADD_FETCH_4, \"__atomic_add_fetch_4\",\n+<<<<<<< HEAD\n \t\t\tNULL, t, 0);\n+=======\n+\t\t\tNULL, t, false, false);\n+>>>>>>> 12e994a7967... Fix indentation\n \n   t = build_function_type_list (uint64_type_node, ptr_type_node,\n \t\t\t\tuint64_type_node, integer_type_node, NULL_TREE);\n   this->define_builtin (BUILT_IN_ATOMIC_ADD_FETCH_8, \"__atomic_add_fetch_8\",\n+<<<<<<< HEAD\n \t\t\tNULL, t, 0);\n+=======\n+\t\t\tNULL, t, false, false);\n+>>>>>>> 12e994a7967... Fix indentation\n \n   t = build_function_type_list (unsigned_char_type_node, ptr_type_node,\n \t\t\t\tunsigned_char_type_node, integer_type_node,\n \t\t\t\tNULL_TREE);\n   this->define_builtin (BUILT_IN_ATOMIC_AND_FETCH_1, \"__atomic_and_fetch_1\",\n+<<<<<<< HEAD\n \t\t\tNULL, t, 0);\n   this->define_builtin (BUILT_IN_ATOMIC_FETCH_AND_1, \"__atomic_fetch_and_1\",\n \t\t\tNULL, t, 0);\n+=======\n+\t\t\tNULL, t, false, false);\n+  this->define_builtin (BUILT_IN_ATOMIC_FETCH_AND_1, \"__atomic_fetch_and_1\",\n+\t\t\tNULL, t, false, false);\n+>>>>>>> 12e994a7967... Fix indentation\n \n   t = build_function_type_list (unsigned_char_type_node, ptr_type_node,\n \t\t\t\tunsigned_char_type_node, integer_type_node,\n \t\t\t\tNULL_TREE);\n   this->define_builtin (BUILT_IN_ATOMIC_OR_FETCH_1, \"__atomic_or_fetch_1\", NULL,\n+<<<<<<< HEAD\n \t\t\tt, 0);\n   this->define_builtin (BUILT_IN_ATOMIC_FETCH_OR_1, \"__atomic_fetch_or_1\", NULL,\n \t\t\tt, 0);\n+=======\n+\t\t\tt, false, false);\n+  this->define_builtin (BUILT_IN_ATOMIC_FETCH_OR_1, \"__atomic_fetch_or_1\", NULL,\n+\t\t\tt, false, false);\n+>>>>>>> 12e994a7967... Fix indentation\n }\n \n // Get an unnamed integer type.\n@@ -1138,7 +1387,11 @@ Gcc_backend::named_type (const std::string &name, Btype *btype,\n \n   // The middle-end expects a basic type to have a name.  In Rust every\n   // basic type will have a name.  The first time we see a basic type,\n+<<<<<<< HEAD\n   // give it whatever Rust name we have at this point.\n+=======\n+  // give it whatever Go name we have at this point.\n+>>>>>>> 12e994a7967... Fix indentation\n   if (TYPE_NAME (type) == NULL_TREE\n       && location.gcc_location () == BUILTINS_LOCATION\n       && (TREE_CODE (type) == INTEGER_TYPE || TREE_CODE (type) == REAL_TYPE\n@@ -1584,7 +1837,11 @@ Gcc_backend::unary_expression (Operator op, Bexpression *expr,\n   enum tree_code code;\n   switch (op)\n     {\n+<<<<<<< HEAD\n+      case OPERATOR_MINUS: {\n+=======\n       case OPERATOR_MINUS: {\n+>>>>>>> 12e994a7967... Fix indentation\n \ttree computed_type = excess_precision_type (type_tree);\n \tif (computed_type != NULL_TREE)\n \t  {\n@@ -1916,8 +2173,13 @@ Gcc_backend::call_expression (Bfunction *, // containing fcn for call\n   // This is to support builtin math functions when using 80387 math.\n   tree excess_type = NULL_TREE;\n   if (optimize && TREE_CODE (fndecl) == FUNCTION_DECL\n+<<<<<<< HEAD\n       && fndecl_built_in_p (fndecl, BUILT_IN_NORMAL)\n       && DECL_IS_UNDECLARED_BUILTIN (fndecl) && nargs > 0\n+=======\n+      && fndecl_built_in_p (fndecl, BUILT_IN_NORMAL) && DECL_IS_BUILTIN (fndecl)\n+      && nargs > 0\n+>>>>>>> 12e994a7967... Fix indentation\n       && ((SCALAR_FLOAT_TYPE_P (rettype)\n \t   && SCALAR_FLOAT_TYPE_P (TREE_TYPE (args[0])))\n \t  || (COMPLEX_FLOAT_TYPE_P (rettype)\n@@ -2420,11 +2682,19 @@ Gcc_backend::non_zero_size_type (tree type)\n \t  DECL_CONTEXT (field) = type;\n \t  TYPE_FIELDS (type) = field;\n \t  layout_type (type);\n+<<<<<<< HEAD\n \t  rust_non_zero_struct = type;\n+=======\n+\t  go_non_zero_struct = type;\n+>>>>>>> 12e994a7967... Fix indentation\n \t}\n       return rust_non_zero_struct;\n \n+<<<<<<< HEAD\n+      case ARRAY_TYPE: {\n+=======\n       case ARRAY_TYPE: {\n+>>>>>>> 12e994a7967... Fix indentation\n \ttree element_type = non_zero_size_type (TREE_TYPE (type));\n \treturn build_array_type_nelts (element_type, 1);\n       }\n@@ -2532,7 +2802,11 @@ Gcc_backend::global_variable_set_init (Bvariable *var, Bexpression *expr)\n   if (symtab_node::get (var_decl)\n       && symtab_node::get (var_decl)->implicit_section)\n     {\n+<<<<<<< HEAD\n       set_decl_section_name (var_decl, (const char *) NULL);\n+=======\n+      set_decl_section_name (var_decl, NULL);\n+>>>>>>> 12e994a7967... Fix indentation\n       resolve_unique_section (var_decl, compute_reloc_for_constant (expr_tree),\n \t\t\t      1);\n     }\n@@ -2647,14 +2921,22 @@ Gcc_backend::temporary_variable (Bfunction *function, Bblock *bblock,\n       else\n \tpush_cfun (DECL_STRUCT_FUNCTION (decl));\n \n+<<<<<<< HEAD\n       var = create_tmp_var (type_tree, \"RUSTTMP\");\n+=======\n+      var = create_tmp_var (type_tree, \"GOTMP\");\n+>>>>>>> 12e994a7967... Fix indentation\n       pop_cfun ();\n     }\n   else\n     {\n       gcc_assert (bblock != NULL);\n       var = build_decl (location.gcc_location (), VAR_DECL,\n+<<<<<<< HEAD\n \t\t\tcreate_tmp_var_name (\"RUSTTMP\"), type_tree);\n+=======\n+\t\t\tcreate_tmp_var_name (\"GOTMP\"), type_tree);\n+>>>>>>> 12e994a7967... Fix indentation\n       DECL_ARTIFICIAL (var) = 1;\n       DECL_IGNORED_P (var) = 1;\n       TREE_USED (var) = 1;\n@@ -3048,15 +3330,24 @@ Gcc_backend::function (Btype *fntype, const std::string &name,\n       if (pos == name.length ())\n \t{\n \t  struct cl_optimization cur_opts;\n+<<<<<<< HEAD\n \t  cl_optimization_save (&cur_opts, &global_options,\n \t\t\t\t&global_options_set);\n+=======\n+\t  cl_optimization_save (&cur_opts, &global_options);\n+>>>>>>> 12e994a7967... Fix indentation\n \t  global_options.x_optimize_size = 1;\n \t  global_options.x_optimize_fast = 0;\n \t  global_options.x_optimize_debug = 0;\n \t  DECL_FUNCTION_SPECIFIC_OPTIMIZATION (decl)\n+<<<<<<< HEAD\n \t    = build_optimization_node (&global_options, &global_options_set);\n \t  cl_optimization_restore (&global_options, &global_options_set,\n \t\t\t\t   &cur_opts);\n+=======\n+\t    = build_optimization_node (&global_options);\n+\t  cl_optimization_restore (&global_options, &cur_opts);\n+>>>>>>> 12e994a7967... Fix indentation\n \t}\n     }\n "}, {"sha": "66895dcc5c05d4175165570e56deff46d9f3dae5", "filename": "gcc/rust/rust-lang.cc", "status": "modified", "additions": 237, "deletions": 181, "changes": 418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Frust-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Frust-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-lang.cc?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -16,27 +16,32 @@\n #include \"common/common-target.h\"\n \n #include <mpfr.h>\n-// note: header files must be in this order or else forward declarations don't work properly. Kinda\n-// dumb system, but have to live with it. clang-format seems to mess it up\n-/* Order: config, system, coretypes, target, tree, gimple-expr, diagnostic, opts, fold-const,\n- * gimplify, stor-layout, debug, convert, langhooks, langhooks-def, common-target */\n+// note: header files must be in this order or else forward declarations don't\n+// work properly. Kinda dumb system, but have to live with it. clang-format\n+// seems to mess it up\n+/* Order: config, system, coretypes, target, tree, gimple-expr, diagnostic,\n+ * opts, fold-const, gimplify, stor-layout, debug, convert, langhooks,\n+ * langhooks-def, common-target */\n \n // FIXME: test saving intellisense\n #include \"options.h\"\n \n // version check to stop compiling if c++ isn't c++11 or higher\n #if __cplusplus < 201103\n-#error \\\n+#error                                                                         \\\n   \"GCC Rust frontend requires C++11 or higher. You can compile the g++ frontend first and then compile the Rust frontend using that.\"\n #endif\n // TODO: is this best way to do it? Is it allowed? (should be)\n \n /* General TODOs:\n- *  - maybe convert all raw pointer-returning/passing functions that conceptually return a unique\n- *    pointer actually return a unique pointer. i.e. parse methods and constructors for AST objects.\n- *    make_unique should probably be avoided to keep C++11 compatibility.\n- *  - convert all copies of expensive-to-copy (deep copy) AST objects into moves, if possible. Don't\n- *    remove clone functionality - it may be required for e.g. HIR conversion. */\n+ *  - maybe convert all raw pointer-returning/passing functions that\n+ * conceptually return a unique pointer actually return a unique pointer. i.e.\n+ * parse methods and constructors for AST objects. make_unique should probably\n+ * be avoided to keep C++11 compatibility.\n+ *  - convert all copies of expensive-to-copy (deep copy) AST objects into\n+ * moves, if possible. Don't\n+ *    remove clone functionality - it may be required for e.g. HIR conversion.\n+ */\n \n #include \"rust-system.h\"\n #include \"rust-parse.h\"\n@@ -45,32 +50,40 @@\n #include \"rust-target.h\"\n \n // Language-dependent contents of a type. GTY() mark used for garbage collector.\n-struct GTY(()) lang_type {\n-    char dummy;\n+struct GTY (()) lang_type\n+{\n+  char dummy;\n };\n \n // Language-dependent contents of a decl.\n-struct GTY(()) lang_decl {\n-    char dummy;\n+struct GTY (()) lang_decl\n+{\n+  char dummy;\n };\n \n-// Language-dependent contents of an identifier.  This must include a tree_identifier.\n-struct GTY(()) lang_identifier {\n-    struct tree_identifier common;\n+// Language-dependent contents of an identifier.  This must include a\n+// tree_identifier.\n+struct GTY (()) lang_identifier\n+{\n+  struct tree_identifier common;\n };\n \n // The resulting tree type.\n-union GTY((desc(\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\"),\n-  chain_next(\n+union GTY ((\n+  desc (\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\"),\n+  chain_next (\n     \"CODE_CONTAINS_STRUCT (TREE_CODE (&%h.generic), \"\n-    \"TS_COMMON) ? ((union lang_tree_node *) TREE_CHAIN (&%h.generic)) : NULL\"))) lang_tree_node {\n-    union tree_node GTY((tag(\"0\"), desc(\"tree_node_structure (&%h)\"))) generic;\n-    struct lang_identifier GTY((tag(\"1\"))) identifier;\n+    \"TS_COMMON) ? ((union lang_tree_node *) TREE_CHAIN (&%h.generic)) : NULL\")))\n+  lang_tree_node\n+{\n+  union tree_node GTY ((tag (\"0\"), desc (\"tree_node_structure (&%h)\"))) generic;\n+  struct lang_identifier GTY ((tag (\"1\"))) identifier;\n };\n \n // We don't use language_function.\n-struct GTY(()) language_function {\n-    int dummy;\n+struct GTY (()) language_function\n+{\n+  int dummy;\n };\n \n // Kinda HACK-ish - store parsing session as static variable\n@@ -84,124 +97,153 @@ void rust_add_target_info(const char* key, const char* value) {\n /* Language hooks.  */\n \n /* Initial lang hook called (possibly), used for initialisation.\n- * Must call build_common_tree_nodes, set_sizetype, build_common_tree_nodes_2, and\n- * build_common_builtin_nodes, as well as set global variable void_list_node. \n- * Apparently called after option handling? */\n-static bool grs_langhook_init(void) {\n-    /* Something to do with this:\n-     This allows the code in d-builtins.cc to not have to worry about\n-     converting (C signed char *) to (D char *) for string arguments of\n-     built-in functions. The parameter (signed_char = false) specifies\n-     whether char is signed.  */\n-    build_common_tree_nodes(false);\n-\n-    // Creates a new TREE_LIST node with purpose NULL_TREE and value void_type_node\n-    void_list_node = build_tree_list(NULL_TREE, void_type_node);\n-\n-    // Builds built-ins for middle-end after all front-end built-ins are already instantiated\n-    build_common_builtin_nodes();\n-\n-    mpfr_set_default_prec(128);\n-    \n-    using_eh_for_cleanups();\n-\n-    // initialise compiler session\n-    session.init();\n-\n-    return true;\n+ * Must call build_common_tree_nodes, set_sizetype, build_common_tree_nodes_2,\n+ * and build_common_builtin_nodes, as well as set global variable\n+ * void_list_node. Apparently called after option handling? */\n+static bool\n+grs_langhook_init (void)\n+{\n+  /* Something to do with this:\n+   This allows the code in d-builtins.cc to not have to worry about\n+   converting (C signed char *) to (D char *) for string arguments of\n+   built-in functions. The parameter (signed_char = false) specifies\n+   whether char is signed.  */\n+  build_common_tree_nodes (false);\n+\n+  // Creates a new TREE_LIST node with purpose NULL_TREE and value\n+  // void_type_node\n+  void_list_node = build_tree_list (NULL_TREE, void_type_node);\n+\n+  // Builds built-ins for middle-end after all front-end built-ins are already\n+  // instantiated\n+  build_common_builtin_nodes ();\n+\n+  mpfr_set_default_prec (128);\n+\n+  using_eh_for_cleanups ();\n+\n+  // initialise compiler session\n+  session.init ();\n+\n+  return true;\n }\n \n-/* The option mask (something to do with options for specific frontends or something). */\n-static unsigned int grs_langhook_option_lang_mask(void) {\n-    return CL_Rust;\n+/* The option mask (something to do with options for specific frontends or\n+ * something). */\n+static unsigned int\n+grs_langhook_option_lang_mask (void)\n+{\n+  return CL_Rust;\n }\n \n /* Initialize the options structure. */\n-static void grs_langhook_init_options_struct(struct gcc_options* opts) {\n-    // nothing yet - used by frontends to change specific options for the language\n-    session.init_options();\n+static void\n+grs_langhook_init_options_struct (struct gcc_options *opts)\n+{\n+  // nothing yet - used by frontends to change specific options for the language\n+  session.init_options ();\n }\n \n-/* Main entry point for front-end, apparently. Finds input file names in global vars in_fnames and\n- * num_in_fnames. From this, frontend can take over and do actual parsing and initial compilation.\n- * This function must create a complete parse tree in a global var, and then return.\n+/* Main entry point for front-end, apparently. Finds input file names in global\n+ * vars in_fnames and num_in_fnames. From this, frontend can take over and do\n+ * actual parsing and initial compilation. This function must create a complete\n+ * parse tree in a global var, and then return.\n  *\n  * Some consider this the \"start of compilation\". */\n-static void grs_langhook_parse_file(void) {\n-    fprintf(stderr, \"Preparing to parse files. \\n\");\n+static void\n+grs_langhook_parse_file (void)\n+{\n+  fprintf (stderr, \"Preparing to parse files. \\n\");\n \n-    // grs_parse_files(num_in_fnames, in_fnames);\n-    session.parse_files(num_in_fnames, in_fnames);\n+  // grs_parse_files(num_in_fnames, in_fnames);\n+  session.parse_files (num_in_fnames, in_fnames);\n }\n \n-/* Seems to get the exact type for a specific type - e.g. for scalar float with 32-bit bitsize, it\n- * returns float, and for 64-bit bitsize, it returns double. Used to map RTL nodes to machine modes or\n- * something like that. */\n-static tree grs_langhook_type_for_mode(machine_mode mode, int unsignedp) {\n-    // TODO: change all this later to match rustc types\n-    if (mode == TYPE_MODE(float_type_node))\n-        return float_type_node;\n-\n-    if (mode == TYPE_MODE(double_type_node))\n-        return double_type_node;\n-\n-    if (mode == TYPE_MODE(intQI_type_node)) // quarter integer mode - single byte treated as integer\n-        return unsignedp ? unsigned_intQI_type_node : intQI_type_node;\n-    if (mode == TYPE_MODE(intHI_type_node)) // half integer mode - two-byte integer\n-        return unsignedp ? unsigned_intHI_type_node : intHI_type_node;\n-    if (mode == TYPE_MODE(intSI_type_node)) // single integer mode - four-byte integer\n-        return unsignedp ? unsigned_intSI_type_node : intSI_type_node;\n-    if (mode == TYPE_MODE(intDI_type_node)) // double integer mode - eight-byte integer\n-        return unsignedp ? unsigned_intDI_type_node : intDI_type_node;\n-    if (mode == TYPE_MODE(intTI_type_node)) // tetra integer mode - 16-byte integer\n-        return unsignedp ? unsigned_intTI_type_node : intTI_type_node;\n-\n-    if (mode == TYPE_MODE(integer_type_node))\n-        return unsignedp ? unsigned_type_node : integer_type_node;\n-\n-    if (mode == TYPE_MODE(long_integer_type_node))\n-        return unsignedp ? long_unsigned_type_node : long_integer_type_node;\n-\n-    if (mode == TYPE_MODE(long_long_integer_type_node))\n-        return unsignedp ? long_long_unsigned_type_node : long_long_integer_type_node;\n-\n-    if (COMPLEX_MODE_P(mode)) {\n-        if (mode == TYPE_MODE(complex_float_type_node))\n-            return complex_float_type_node;\n-        if (mode == TYPE_MODE(complex_double_type_node))\n-            return complex_double_type_node;\n-        if (mode == TYPE_MODE(complex_long_double_type_node))\n-            return complex_long_double_type_node;\n-        if (mode == TYPE_MODE(complex_integer_type_node) && !unsignedp)\n-            return complex_integer_type_node;\n+/* Seems to get the exact type for a specific type - e.g. for scalar float with\n+ * 32-bit bitsize, it returns float, and for 64-bit bitsize, it returns double.\n+ * Used to map RTL nodes to machine modes or something like that. */\n+static tree\n+grs_langhook_type_for_mode (machine_mode mode, int unsignedp)\n+{\n+  // TODO: change all this later to match rustc types\n+  if (mode == TYPE_MODE (float_type_node))\n+    return float_type_node;\n+\n+  if (mode == TYPE_MODE (double_type_node))\n+    return double_type_node;\n+\n+  if (mode == TYPE_MODE (intQI_type_node)) // quarter integer mode - single byte\n+\t\t\t\t\t   // treated as integer\n+    return unsignedp ? unsigned_intQI_type_node : intQI_type_node;\n+  if (mode\n+      == TYPE_MODE (intHI_type_node)) // half integer mode - two-byte integer\n+    return unsignedp ? unsigned_intHI_type_node : intHI_type_node;\n+  if (mode\n+      == TYPE_MODE (intSI_type_node)) // single integer mode - four-byte integer\n+    return unsignedp ? unsigned_intSI_type_node : intSI_type_node;\n+  if (mode\n+      == TYPE_MODE (\n+\t   intDI_type_node)) // double integer mode - eight-byte integer\n+    return unsignedp ? unsigned_intDI_type_node : intDI_type_node;\n+  if (mode\n+      == TYPE_MODE (intTI_type_node)) // tetra integer mode - 16-byte integer\n+    return unsignedp ? unsigned_intTI_type_node : intTI_type_node;\n+\n+  if (mode == TYPE_MODE (integer_type_node))\n+    return unsignedp ? unsigned_type_node : integer_type_node;\n+\n+  if (mode == TYPE_MODE (long_integer_type_node))\n+    return unsignedp ? long_unsigned_type_node : long_integer_type_node;\n+\n+  if (mode == TYPE_MODE (long_long_integer_type_node))\n+    return unsignedp ? long_long_unsigned_type_node\n+\t\t     : long_long_integer_type_node;\n+\n+  if (COMPLEX_MODE_P (mode))\n+    {\n+      if (mode == TYPE_MODE (complex_float_type_node))\n+\treturn complex_float_type_node;\n+      if (mode == TYPE_MODE (complex_double_type_node))\n+\treturn complex_double_type_node;\n+      if (mode == TYPE_MODE (complex_long_double_type_node))\n+\treturn complex_long_double_type_node;\n+      if (mode == TYPE_MODE (complex_integer_type_node) && !unsignedp)\n+\treturn complex_integer_type_node;\n     }\n-    /* gcc_unreachable */\n-    return NULL;\n+  /* gcc_unreachable */\n+  return NULL;\n }\n \n-/* This appears to be used for creating different types for different bit sizes (e.g. int and long).\n- * Also, the Go frontend calls this from type_for_mode to determine the type from a specific bitsize\n- * for integer types.\n- * FIXME: change this when working on AST-GENERIC conversion to allow the full range of Rust type\n- * sizes. */\n-static tree grs_langhook_type_for_size(\n-  unsigned int bits ATTRIBUTE_UNUSED, int unsignedp ATTRIBUTE_UNUSED) {\n-    gcc_unreachable();\n-    return NULL_TREE;\n-    // nothing at the moment, but change later\n+/* This appears to be used for creating different types for different bit sizes\n+ * (e.g. int and long). Also, the Go frontend calls this from type_for_mode to\n+ * determine the type from a specific bitsize for integer types.\n+ * FIXME: change this when working on AST-GENERIC conversion to allow the full\n+ * range of Rust type sizes. */\n+static tree\n+grs_langhook_type_for_size (unsigned int bits ATTRIBUTE_UNUSED,\n+\t\t\t    int unsignedp ATTRIBUTE_UNUSED)\n+{\n+  gcc_unreachable ();\n+  return NULL_TREE;\n+  // nothing at the moment, but change later\n }\n \n // Record a builtin function. We just ignore builtin functions.\n-static tree grs_langhook_builtin_function(tree decl ATTRIBUTE_UNUSED) {\n-    return decl;\n+static tree\n+grs_langhook_builtin_function (tree decl ATTRIBUTE_UNUSED)\n+{\n+  return decl;\n }\n \n-/* Return true if we are in the global binding level (which is never, apparently). */\n-static bool grs_langhook_global_bindings_p(void) {\n-    // return current_function_decl == NULL_TREE;\n-    // gcc_unreachable();\n-    // return true;\n-    return false;\n+/* Return true if we are in the global binding level (which is never,\n+ * apparently). */\n+static bool\n+grs_langhook_global_bindings_p (void)\n+{\n+  // return current_function_decl == NULL_TREE;\n+  // gcc_unreachable();\n+  // return true;\n+  return false;\n }\n \n /* Push a declaration into the current binding level.  We can't\n@@ -210,72 +252,85 @@ static bool grs_langhook_global_bindings_p(void) {\n    this is used is to record a decl which is to be returned by\n    getdecls, and we could implement it for that purpose if\n    necessary.  */\n-static tree grs_langhook_pushdecl(tree decl ATTRIBUTE_UNUSED) {\n-    gcc_unreachable();\n-    return NULL;\n+static tree\n+grs_langhook_pushdecl (tree decl ATTRIBUTE_UNUSED)\n+{\n+  gcc_unreachable ();\n+  return NULL;\n }\n \n /* This hook is used to get the current list of declarations as trees.\n    We don't support that; instead we use the write_globals hook.  This\n    can't simply crash because it is called by -gstabs.  */\n-static tree grs_langhook_getdecls(void) {\n-    // gcc_unreachable();\n-    return NULL;\n+static tree\n+grs_langhook_getdecls (void)\n+{\n+  // gcc_unreachable();\n+  return NULL;\n }\n \n // Handle Rust-specific options. Return false if nothing happened.\n-static bool grs_langhook_handle_option(size_t scode, const char* arg, HOST_WIDE_INT value,\n-  int kind ATTRIBUTE_UNUSED, location_t loc ATTRIBUTE_UNUSED,\n-  const struct cl_option_handlers* handlers ATTRIBUTE_UNUSED) {\n-    // Convert integer code to lang.opt enum codes with names.\n-    enum opt_code code = (enum opt_code)scode;\n-    // used to store whether results of various stuff are successful\n-    // bool ret = true;\n-\n-    // delegate to session manager\n-    return session.handle_option(code, arg, value, kind, loc, handlers);\n-\n-    // Handles options as listed in lang.opt.\n-    /*switch (code) {\n-        case OPT_I:\n-            // TODO: add search path\n-            break;\n-        case OPT_L:\n-            // TODO: add library link path or something\n-            break;\n-        case OPT_frust_dump:\n-            // enable dump and return whether this was successful\n-            ret = rust_enable_dump(arg) ? true : false;\n-            break;\n-        // no option handling for -o\n-        default:\n-            // return 1 to indicate option is valid\n-            break;\n-    }\n-\n-    return ret;*/\n+static bool\n+grs_langhook_handle_option (\n+  size_t scode, const char *arg, HOST_WIDE_INT value, int kind ATTRIBUTE_UNUSED,\n+  location_t loc ATTRIBUTE_UNUSED,\n+  const struct cl_option_handlers *handlers ATTRIBUTE_UNUSED)\n+{\n+  // Convert integer code to lang.opt enum codes with names.\n+  enum opt_code code = (enum opt_code) scode;\n+  // used to store whether results of various stuff are successful\n+  // bool ret = true;\n+\n+  // delegate to session manager\n+  return session.handle_option (code, arg, value, kind, loc, handlers);\n+\n+  // Handles options as listed in lang.opt.\n+  /*switch (code) {\n+      case OPT_I:\n+\t  // TODO: add search path\n+\t  break;\n+      case OPT_L:\n+\t  // TODO: add library link path or something\n+\t  break;\n+      case OPT_frust_dump:\n+\t  // enable dump and return whether this was successful\n+\t  ret = rust_enable_dump(arg) ? true : false;\n+\t  break;\n+      // no option handling for -o\n+      default:\n+\t  // return 1 to indicate option is valid\n+\t  break;\n+  }\n+\n+  return ret;*/\n }\n \n /* Run after parsing options.  */\n-static bool grs_langhook_post_options(const char** pfilename ATTRIBUTE_UNUSED) {\n-    // can be used to override other options if required\n+static bool\n+grs_langhook_post_options (const char **pfilename ATTRIBUTE_UNUSED)\n+{\n+  // can be used to override other options if required\n \n-    // satisfies an assert in init_excess_precision in toplev.c\n-    if (flag_excess_precision/*_cmdline*/ == EXCESS_PRECISION_DEFAULT)\n-        flag_excess_precision/*_cmdline*/ = EXCESS_PRECISION_STANDARD;\n+  // satisfies an assert in init_excess_precision in toplev.c\n+  if (flag_excess_precision /*_cmdline*/ == EXCESS_PRECISION_DEFAULT)\n+    flag_excess_precision /*_cmdline*/ = EXCESS_PRECISION_STANDARD;\n \n-    /* Returning false means that the backend should be used.  */\n-    return false;\n+  /* Returning false means that the backend should be used.  */\n+  return false;\n }\n \n-/* Rust-specific gimplification. May need to gimplify e.g. CALL_EXPR_STATIC_CHAIN */\n-static int grs_langhook_gimplify_expr(tree* expr_p ATTRIBUTE_UNUSED,\n-  gimple_seq* pre_p ATTRIBUTE_UNUSED, gimple_seq* post_p ATTRIBUTE_UNUSED) {\n-    if (TREE_CODE (*expr_p) == CALL_EXPR\n+/* Rust-specific gimplification. May need to gimplify e.g.\n+ * CALL_EXPR_STATIC_CHAIN */\n+static int\n+grs_langhook_gimplify_expr (tree *expr_p ATTRIBUTE_UNUSED,\n+\t\t\t    gimple_seq *pre_p ATTRIBUTE_UNUSED,\n+\t\t\t    gimple_seq *post_p ATTRIBUTE_UNUSED)\n+{\n+  if (TREE_CODE (*expr_p) == CALL_EXPR\n       && CALL_EXPR_STATIC_CHAIN (*expr_p) != NULL_TREE)\n-        gimplify_expr (&CALL_EXPR_STATIC_CHAIN (*expr_p), pre_p, post_p,\n-          is_gimple_val, fb_rvalue);\n-    return GS_UNHANDLED;\n+    gimplify_expr (&CALL_EXPR_STATIC_CHAIN (*expr_p), pre_p, post_p,\n+\t\t   is_gimple_val, fb_rvalue);\n+  return GS_UNHANDLED;\n }\n \n static tree\n@@ -293,8 +348,7 @@ grs_langhook_eh_personality (void)\n tree\n convert (tree type, tree expr)\n {\n-  if (type == error_mark_node\n-      || expr == error_mark_node\n+  if (type == error_mark_node || expr == error_mark_node\n       || TREE_TYPE (expr) == error_mark_node)\n     return error_mark_node;\n \n@@ -327,7 +381,7 @@ convert (tree type, tree expr)\n /* FIXME: This is a hack to preserve trees that we create from the\n    garbage collector.  */\n \n-static GTY(()) tree rust_gc_root;\n+static GTY (()) tree rust_gc_root;\n \n void\n rust_preserve_from_gc (tree t)\n@@ -343,9 +397,9 @@ rust_localize_identifier (const char *ident)\n   return identifier_to_locale (ident);\n }\n \n-/* The language hooks data structure. This is the main interface between the GCC front-end\n- * and the GCC middle-end/back-end. A list of language hooks could be found in\n- * <gcc>/langhooks.h\n+/* The language hooks data structure. This is the main interface between the GCC\n+ * front-end and the GCC middle-end/back-end. A list of language hooks could be\n+ * found in <gcc>/langhooks.h\n  */\n #undef LANG_HOOKS_NAME\n #undef LANG_HOOKS_INIT\n@@ -370,9 +424,11 @@ rust_localize_identifier (const char *ident)\n #define LANG_HOOKS_INIT_OPTIONS_STRUCT grs_langhook_init_options_struct\n #define LANG_HOOKS_HANDLE_OPTION grs_langhook_handle_option\n #define LANG_HOOKS_POST_OPTIONS grs_langhook_post_options\n-/* Main lang-hook, apparently. Finds input file names in global vars in_fnames and num_in_fnames\n- * From this, frontend can take over and do actual parsing and initial compilation.\n- * This hook must create a complete parse tree in a global var, and then return. */\n+/* Main lang-hook, apparently. Finds input file names in global vars in_fnames\n+ * and num_in_fnames From this, frontend can take over and do actual parsing and\n+ * initial compilation.\n+ * This hook must create a complete parse tree in a global var, and then return.\n+ */\n #define LANG_HOOKS_PARSE_FILE grs_langhook_parse_file\n #define LANG_HOOKS_TYPE_FOR_MODE grs_langhook_type_for_mode\n #define LANG_HOOKS_TYPE_FOR_SIZE grs_langhook_type_for_size"}, {"sha": "fef460378a26b22991e9e9c092cf4281f3e3db6e", "filename": "gcc/rust/rust-linemap.cc", "status": "modified", "additions": 45, "deletions": 60, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Frust-linemap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Frust-linemap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-linemap.cc?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -2,83 +2,68 @@\n \n #include \"rust-linemap.h\"\n \n-\n // This class implements the Linemap interface defined by the\n // frontend.\n \n class Gcc_linemap : public Linemap\n {\n- public:\n-  Gcc_linemap()\n-    : Linemap(),\n-      in_file_(false)\n-  { }\n+public:\n+  Gcc_linemap () : Linemap (), in_file_ (false) {}\n \n-  void\n-  start_file(const char* file_name, unsigned int line_begin);\n+  void start_file (const char *file_name, unsigned int line_begin);\n \n-  void\n-  start_line(unsigned int line_number, unsigned int line_size);\n+  void start_line (unsigned int line_number, unsigned int line_size);\n \n-  Location\n-  get_location(unsigned int column);\n+  Location get_location (unsigned int column);\n \n-  void\n-  stop();\n+  void stop ();\n \n-  std::string\n-  to_string(Location);\n+  std::string to_string (Location);\n \n-  std::string\n-  location_file(Location);\n+  std::string location_file (Location);\n \n-  int\n-  location_line(Location);\n+  int location_line (Location);\n \n- protected:\n-  Location\n-  get_predeclared_location();\n+protected:\n+  Location get_predeclared_location ();\n \n-  Location\n-  get_unknown_location();\n+  Location get_unknown_location ();\n \n-  bool\n-  is_predeclared(Location);\n+  bool is_predeclared (Location);\n \n-  bool\n-  is_unknown(Location);\n+  bool is_unknown (Location);\n \n- private:\n+private:\n   // Whether we are currently reading a file.\n   bool in_file_;\n };\n \n-Linemap* Linemap::instance_ = NULL;\n+Linemap *Linemap::instance_ = NULL;\n \n // Start getting locations from a new file.\n \n void\n-Gcc_linemap::start_file(const char *file_name, unsigned line_begin)\n+Gcc_linemap::start_file (const char *file_name, unsigned line_begin)\n {\n   if (this->in_file_)\n-    linemap_add(line_table, LC_LEAVE, 0, NULL, 0);\n-  linemap_add(line_table, LC_ENTER, 0, file_name, line_begin);\n+    linemap_add (line_table, LC_LEAVE, 0, NULL, 0);\n+  linemap_add (line_table, LC_ENTER, 0, file_name, line_begin);\n   this->in_file_ = true;\n }\n \n // Stringify a location\n \n std::string\n-Gcc_linemap::to_string(Location location)\n+Gcc_linemap::to_string (Location location)\n {\n   const line_map_ordinary *lmo;\n   location_t resolved_location;\n \n   // Screen out unknown and predeclared locations; produce output\n   // only for simple file:line locations.\n-  resolved_location =\n-      linemap_resolve_location (line_table, location.gcc_location(),\n-                                LRK_SPELLING_LOCATION, &lmo);\n+  resolved_location\n+    = linemap_resolve_location (line_table, location.gcc_location (),\n+\t\t\t\tLRK_SPELLING_LOCATION, &lmo);\n   if (lmo == NULL || resolved_location < RESERVED_LOCATION_COUNT)\n     return \"\";\n   const char *path = LINEMAP_FILE (lmo);\n@@ -87,87 +72,87 @@ Gcc_linemap::to_string(Location location)\n \n   // Strip the source file down to the base file, to reduce clutter.\n   std::stringstream ss;\n-  ss << lbasename(path) << \":\" << SOURCE_LINE (lmo, location.gcc_location());\n-  return ss.str();\n+  ss << lbasename (path) << \":\" << SOURCE_LINE (lmo, location.gcc_location ());\n+  return ss.str ();\n }\n \n // Return the file name for a given location.\n \n std::string\n-Gcc_linemap::location_file(Location loc)\n+Gcc_linemap::location_file (Location loc)\n {\n-  return LOCATION_FILE(loc.gcc_location());\n+  return LOCATION_FILE (loc.gcc_location ());\n }\n \n // Return the line number for a given location.\n \n int\n-Gcc_linemap::location_line(Location loc)\n+Gcc_linemap::location_line (Location loc)\n {\n-  return LOCATION_LINE(loc.gcc_location());\n+  return LOCATION_LINE (loc.gcc_location ());\n }\n \n // Stop getting locations.\n \n void\n-Gcc_linemap::stop()\n+Gcc_linemap::stop ()\n {\n-  linemap_add(line_table, LC_LEAVE, 0, NULL, 0);\n+  linemap_add (line_table, LC_LEAVE, 0, NULL, 0);\n   this->in_file_ = false;\n }\n \n // Start a new line.\n \n void\n-Gcc_linemap::start_line(unsigned lineno, unsigned linesize)\n+Gcc_linemap::start_line (unsigned lineno, unsigned linesize)\n {\n-  linemap_line_start(line_table, lineno, linesize);\n+  linemap_line_start (line_table, lineno, linesize);\n }\n \n // Get a location.\n \n Location\n-Gcc_linemap::get_location(unsigned column)\n+Gcc_linemap::get_location (unsigned column)\n {\n-  return Location(linemap_position_for_column(line_table, column));\n+  return Location (linemap_position_for_column (line_table, column));\n }\n \n // Get the unknown location.\n \n Location\n-Gcc_linemap::get_unknown_location()\n+Gcc_linemap::get_unknown_location ()\n {\n-  return Location(UNKNOWN_LOCATION);\n+  return Location (UNKNOWN_LOCATION);\n }\n \n // Get the predeclared location.\n \n Location\n-Gcc_linemap::get_predeclared_location()\n+Gcc_linemap::get_predeclared_location ()\n {\n-  return Location(BUILTINS_LOCATION);\n+  return Location (BUILTINS_LOCATION);\n }\n \n // Return whether a location is the predeclared location.\n \n bool\n-Gcc_linemap::is_predeclared(Location loc)\n+Gcc_linemap::is_predeclared (Location loc)\n {\n-  return loc.gcc_location() == BUILTINS_LOCATION;\n+  return loc.gcc_location () == BUILTINS_LOCATION;\n }\n \n // Return whether a location is the unknown location.\n \n bool\n-Gcc_linemap::is_unknown(Location loc)\n+Gcc_linemap::is_unknown (Location loc)\n {\n-  return loc.gcc_location() == UNKNOWN_LOCATION;\n+  return loc.gcc_location () == UNKNOWN_LOCATION;\n }\n \n // Return the Linemap to use for the gcc backend.\n \n-Linemap*\n-rust_get_linemap()\n+Linemap *\n+rust_get_linemap ()\n {\n   return new Gcc_linemap;\n }"}, {"sha": "73e6a0ba501eb56ed7fe88082c60d04527438af1", "filename": "gcc/rust/rust-linemap.h", "status": "modified", "additions": 43, "deletions": 60, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Frust-linemap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Frust-linemap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-linemap.h?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -22,147 +22,130 @@\n // The Linemap class is a pure abstract interface, plus some static\n // convenience functions.  The backend must implement the interface.\n \n-/* TODO: probably better to replace linemap implementation as pure abstract interface with some sort of \n- * compile-time switch (macros or maybe templates if doable without too much extra annoyance) as to the\n- * definition of the methods or whatever. This is to improve performance, as virtual function calls would\n+/* TODO: probably better to replace linemap implementation as pure abstract\n+ * interface with some sort of compile-time switch (macros or maybe templates if\n+ * doable without too much extra annoyance) as to the definition of the methods\n+ * or whatever. This is to improve performance, as virtual function calls would\n  * otherwise have to be made in tight loops like in the lexer. */\n \n class Linemap\n {\n- public:\n-  Linemap()\n+public:\n+  Linemap ()\n   {\n     // Only one instance of Linemap is allowed to exist.\n-    rust_assert(Linemap::instance_ == NULL);\n+    rust_assert (Linemap::instance_ == NULL);\n     Linemap::instance_ = this;\n   }\n \n-  virtual\n-  ~Linemap() { Linemap::instance_ = NULL; }\n+  virtual ~Linemap () { Linemap::instance_ = NULL; }\n \n   // Subsequent Location values will come from the file named\n   // FILE_NAME, starting at LINE_BEGIN.  Normally LINE_BEGIN will be\n   // 0, but it will be non-zero if the Rust source has a //line comment.\n-  virtual void\n-  start_file(const char* file_name, unsigned int line_begin) = 0;\n+  virtual void start_file (const char *file_name, unsigned int line_begin) = 0;\n \n   // Subsequent Location values will come from the line LINE_NUMBER,\n   // in the current file.  LINE_SIZE is the size of the line in bytes.\n   // This will normally be called for every line in a source file.\n-  virtual void\n-  start_line(unsigned int line_number, unsigned int line_size) = 0;\n+  virtual void start_line (unsigned int line_number, unsigned int line_size)\n+    = 0;\n \n   // Get a Location representing column position COLUMN on the current\n   // line in the current file.\n-  virtual Location\n-  get_location(unsigned int column) = 0;\n+  virtual Location get_location (unsigned int column) = 0;\n \n   // Stop generating Location values.  This will be called after all\n   // input files have been read, in case any cleanup is required.\n-  virtual void\n-  stop() = 0;\n+  virtual void stop () = 0;\n \n   // Produce a human-readable description of a Location, e.g.\n   // \"foo.rust:10\". Returns an empty string for predeclared, builtin or\n   // unknown locations.\n-  virtual std::string\n-  to_string(Location) = 0;\n+  virtual std::string to_string (Location) = 0;\n \n   // Return the file name for a given location.\n-  virtual std::string\n-  location_file(Location) = 0;\n+  virtual std::string location_file (Location) = 0;\n \n   // Return the line number for a given location.\n-  virtual int\n-  location_line(Location) = 0;\n+  virtual int location_line (Location) = 0;\n \n- protected:\n+protected:\n   // Return a special Location used for predeclared identifiers.  This\n   // Location should be different from that for any actual source\n   // file.  This location will be used for various different types,\n   // functions, and objects created by the frontend.\n-  virtual Location\n-  get_predeclared_location() = 0;\n+  virtual Location get_predeclared_location () = 0;\n \n   // Return a special Location which indicates that no actual location\n   // is known.  This is used for undefined objects and for errors.\n-  virtual Location\n-  get_unknown_location() = 0;\n+  virtual Location get_unknown_location () = 0;\n \n   // Return whether the argument is the Location returned by\n   // get_predeclared_location.\n-  virtual bool\n-  is_predeclared(Location) = 0;\n+  virtual bool is_predeclared (Location) = 0;\n \n   // Return whether the argument is the Location returned by\n   // get_unknown_location.\n-  virtual bool\n-  is_unknown(Location) = 0;\n+  virtual bool is_unknown (Location) = 0;\n \n   // The single existing instance of Linemap.\n   static Linemap *instance_;\n \n- public:\n+public:\n   // Following are convenience static functions, which allow us to\n   // access some virtual functions without explicitly passing around\n   // an instance of Linemap.\n \n   // Return the special Location used for predeclared identifiers.\n-  static Location\n-  predeclared_location()\n+  static Location predeclared_location ()\n   {\n-    rust_assert(Linemap::instance_ != NULL);\n-    return Linemap::instance_->get_predeclared_location();\n+    rust_assert (Linemap::instance_ != NULL);\n+    return Linemap::instance_->get_predeclared_location ();\n   }\n \n   // Return the special Location used when no location is known.\n-  static Location\n-  unknown_location()\n+  static Location unknown_location ()\n   {\n-    rust_assert(Linemap::instance_ != NULL);\n-    return Linemap::instance_->get_unknown_location();\n+    rust_assert (Linemap::instance_ != NULL);\n+    return Linemap::instance_->get_unknown_location ();\n   }\n \n   // Return whether the argument is the special location used for\n   // predeclared identifiers.\n-  static bool\n-  is_predeclared_location(Location loc)\n+  static bool is_predeclared_location (Location loc)\n   {\n-    rust_assert(Linemap::instance_ != NULL);\n-    return Linemap::instance_->is_predeclared(loc);\n+    rust_assert (Linemap::instance_ != NULL);\n+    return Linemap::instance_->is_predeclared (loc);\n   }\n \n   // Return whether the argument is the special location used when no\n   // location is known.\n-  static bool\n-  is_unknown_location(Location loc)\n+  static bool is_unknown_location (Location loc)\n   {\n-    rust_assert(Linemap::instance_ != NULL);\n-    return Linemap::instance_->is_unknown(loc);\n+    rust_assert (Linemap::instance_ != NULL);\n+    return Linemap::instance_->is_unknown (loc);\n   }\n \n   // Produce a human-readable description of a Location.\n-  static std::string\n-  location_to_string(Location loc)\n+  static std::string location_to_string (Location loc)\n   {\n-    rust_assert(Linemap::instance_ != NULL);\n-    return Linemap::instance_->to_string(loc);\n+    rust_assert (Linemap::instance_ != NULL);\n+    return Linemap::instance_->to_string (loc);\n   }\n \n   // Return the file name of a location.\n-  static std::string\n-  location_to_file(Location loc)\n+  static std::string location_to_file (Location loc)\n   {\n-    rust_assert(Linemap::instance_ != NULL);\n-    return Linemap::instance_->location_file(loc);\n+    rust_assert (Linemap::instance_ != NULL);\n+    return Linemap::instance_->location_file (loc);\n   }\n \n   // Return line number of a location.\n-  static int\n-  location_to_line(Location loc)\n+  static int location_to_line (Location loc)\n   {\n-    rust_assert(Linemap::instance_ != NULL);\n-    return Linemap::instance_->location_line(loc);\n+    rust_assert (Linemap::instance_ != NULL);\n+    return Linemap::instance_->location_line (loc);\n   }\n };\n "}, {"sha": "575fa8335c6b61f8c8ea00381fc36e3680cdfb65", "filename": "gcc/rust/rust-location.h", "status": "modified", "additions": 18, "deletions": 27, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Frust-location.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Frust-location.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-location.h?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -9,63 +9,54 @@\n \n class Location\n {\n- public:\n-  Location()\n-    : gcc_loc_(UNKNOWN_LOCATION)\n-  { }\n+public:\n+  Location () : gcc_loc_ (UNKNOWN_LOCATION) {}\n \n-  explicit Location(location_t loc)\n-    : gcc_loc_(loc)\n-  { }\n+  explicit Location (location_t loc) : gcc_loc_ (loc) {}\n \n-  location_t\n-  gcc_location() const\n-  { return gcc_loc_; }\n+  location_t gcc_location () const { return gcc_loc_; }\n \n-  Location \n-  operator+=(location_t rhs) {\n+  Location operator+= (location_t rhs)\n+  {\n     gcc_loc_ += rhs;\n     return *this;\n   }\n \n-  Location \n-  operator-=(location_t rhs) {\n+  Location operator-= (location_t rhs)\n+  {\n     gcc_loc_ -= rhs;\n     return *this;\n   }\n \n-  bool \n-  operator==(location_t rhs) {\n-    return rhs == gcc_loc_;\n-  }\n+  bool operator== (location_t rhs) { return rhs == gcc_loc_; }\n \n- private:\n+private:\n   location_t gcc_loc_;\n };\n \n // The Rust frontend requires the ability to compare Locations.\n \n inline bool\n-operator<(Location loca, Location locb)\n+operator< (Location loca, Location locb)\n {\n-  return loca.gcc_location() < locb.gcc_location();\n+  return loca.gcc_location () < locb.gcc_location ();\n }\n \n inline bool\n-operator==(Location loca, Location locb)\n+operator== (Location loca, Location locb)\n {\n-  return loca.gcc_location() == locb.gcc_location();\n+  return loca.gcc_location () == locb.gcc_location ();\n }\n \n-inline Location \n-operator+(Location lhs, location_t rhs) \n+inline Location\n+operator+ (Location lhs, location_t rhs)\n {\n   lhs += rhs;\n   return lhs;\n }\n \n-inline Location \n-operator-(Location lhs, location_t rhs) \n+inline Location\n+operator- (Location lhs, location_t rhs)\n {\n   lhs -= rhs;\n   return lhs;"}, {"sha": "e59d3fb09215e82ccf67aced72211d06dd93dd5a", "filename": "gcc/rust/rust-object-export.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Frust-object-export.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Frust-object-export.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-object-export.c?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -1,21 +1,21 @@\n /* rust-backend.c -- Rust frontend interface to gcc backend.\n-   Copyright (C) 2010-2019 Free Software Foundation, Inc.\n+   Copyright (C) 2010-2020 Free Software Foundation, Inc.\n \n-This file is part of GCC.\n+   This file is part of GCC.\n \n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n \n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n \n // FIXME: doesn't this duplicate lots of code from rust-backend.c? Is one meant to be a replacement?\n \n@@ -30,7 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"simple-object.h\"\n #include \"stor-layout.h\"\n #include \"intl.h\"\n-#include \"output.h\"\t/* for assemble_string */\n+#include \"output.h\"     /* for assemble_string */\n #include \"common/common-target.h\"\n \n // satisfy intellisense\n@@ -111,8 +111,8 @@ rust_write_export_data (const char *bytes, unsigned int size)\n     {\n       gcc_assert (targetm_common.have_named_sections);\n       sec = get_section (RUST_EXPORT_SECTION_NAME,\n-\t\t\t TARGET_AIX ? SECTION_EXCLUDE : SECTION_DEBUG,\n-\t\t\t NULL);\n+                         TARGET_AIX ? SECTION_EXCLUDE : SECTION_DEBUG,\n+                         NULL);\n     }\n \n   switch_to_section (sec);\n@@ -132,7 +132,7 @@ rust_write_export_data (const char *bytes, unsigned int size)\n \n const char *\n rust_read_export_data (int fd, off_t offset, char **pbuf, size_t *plen,\n-\t\t     int *perr)\n+\t\t       int *perr)\n {\n   simple_object_read *sobj;\n   const char *errmsg;\n@@ -146,20 +146,20 @@ rust_read_export_data (int fd, off_t offset, char **pbuf, size_t *plen,\n   *plen = 0;\n \n   sobj = simple_object_start_read (fd, offset, RUST_EXPORT_SEGMENT_NAME,\n-\t\t\t\t   &errmsg, perr);\n+                                   &errmsg, perr);\n   if (sobj == NULL)\n     {\n       /* If we get an error here, just pretend that we didn't find any\n-\t export data.  This is the right thing to do if the error is\n-\t that the file was not recognized as an object file.  This\n-\t will ignore file I/O errors, but it's not too big a deal\n-\t because we will wind up giving some other error later.  */\n+         export data.  This is the right thing to do if the error is\n+         that the file was not recognized as an object file.  This\n+         will ignore file I/O errors, but it's not too big a deal\n+         because we will wind up giving some other error later.  */\n       return NULL;\n     }\n \n   found = simple_object_find_section (sobj, RUST_EXPORT_SECTION_NAME,\n-\t\t\t\t      &sec_offset, &sec_length,\n-\t\t\t\t      &errmsg, perr);\n+                                      &sec_offset, &sec_length,\n+                                      &errmsg, perr);\n   simple_object_release_read (sobj);\n   if (!found)\n     return errmsg;"}, {"sha": "5ec63e87f6cf89dcaf6492a41a4de52c846f0785", "filename": "gcc/rust/rust-object-export.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Frust-object-export.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Frust-object-export.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-object-export.h?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -9,4 +9,4 @@ rust_read_export_data (int fd, off_t offset, char **pbuf, size_t *plen,\n extern void\n rust_write_export_data (const char *bytes, unsigned int size);\n \n-#endif // RUST_OBJECT_EXPORT_H\n\\ No newline at end of file\n+#endif // RUST_OBJECT_EXPORT_H"}, {"sha": "224751936041f2034e09968e8ea3a2d261ce0b64", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 750, "deletions": 607, "changes": 1357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -13,656 +13,799 @@\n \n #include <algorithm>\n \n-extern Linemap* rust_get_linemap();\n+extern Linemap *\n+rust_get_linemap ();\n \n namespace Rust {\n-    // Simple wrapper for FILE* that simplifies destruction.\n-    struct RAIIFile {\n-        FILE* file;\n-\n-        RAIIFile(const char* filename) : file(fopen(filename, \"r\")) {}\n-\n-        ~RAIIFile() {\n-            fclose(file);\n-        }\n-    };\n-\n-    // Implicitly enable a target_feature (and recursively enable dependencies).\n-    void Session::implicitly_enable_feature(::std::string feature_name) {\n-        // TODO: is this really required since features added would be complete via target spec?\n-\n-        if (!options.target_data.has_key_value_pair(\"target_data\", feature_name)) {\n-            // if feature has dependencies, enable them\n-            if (feature_name == \"aes\") {\n-                implicitly_enable_feature(\"sse2\");\n-            } else if (feature_name == \"avx\") {\n-                implicitly_enable_feature(\"sse4.2\");\n-            } else if (feature_name == \"avx2\") {\n-                implicitly_enable_feature(\"avx\");\n-            } else if (feature_name == \"fma\") {\n-                implicitly_enable_feature(\"avx\");\n-            } else if (feature_name == \"pclmulqdq\") {\n-                implicitly_enable_feature(\"sse2\");\n-            } else if (feature_name == \"sha\") {\n-                implicitly_enable_feature(\"sse2\");\n-            } else if (feature_name == \"sse2\") {\n-                implicitly_enable_feature(\"sse\");\n-            } else if (feature_name == \"sse3\") {\n-                implicitly_enable_feature(\"sse2\");\n-            } else if (feature_name == \"sse4.1\") {\n-                implicitly_enable_feature(\"sse3\");\n-            } else if (feature_name == \"sse4.2\") {\n-                implicitly_enable_feature(\"sse4.1\");\n-            } else if (feature_name == \"ssse3\") {\n-                implicitly_enable_feature(\"sse3\");\n-            }\n-\n-            options.target_data.insert_key_value_pair(\"target_feature\", ::std::move(feature_name));\n-        }\n+// Simple wrapper for FILE* that simplifies destruction.\n+struct RAIIFile\n+{\n+  FILE *file;\n+\n+  RAIIFile (const char *filename) : file (fopen (filename, \"r\")) {}\n+\n+  ~RAIIFile () { fclose (file); }\n+};\n+\n+// Implicitly enable a target_feature (and recursively enable dependencies).\n+void\n+Session::implicitly_enable_feature (::std::string feature_name)\n+{\n+  // TODO: is this really required since features added would be complete via\n+  // target spec?\n+\n+  if (!options.target_data.has_key_value_pair (\"target_data\", feature_name))\n+    {\n+      // if feature has dependencies, enable them\n+      if (feature_name == \"aes\")\n+\t{\n+\t  implicitly_enable_feature (\"sse2\");\n+\t}\n+      else if (feature_name == \"avx\")\n+\t{\n+\t  implicitly_enable_feature (\"sse4.2\");\n+\t}\n+      else if (feature_name == \"avx2\")\n+\t{\n+\t  implicitly_enable_feature (\"avx\");\n+\t}\n+      else if (feature_name == \"fma\")\n+\t{\n+\t  implicitly_enable_feature (\"avx\");\n+\t}\n+      else if (feature_name == \"pclmulqdq\")\n+\t{\n+\t  implicitly_enable_feature (\"sse2\");\n+\t}\n+      else if (feature_name == \"sha\")\n+\t{\n+\t  implicitly_enable_feature (\"sse2\");\n+\t}\n+      else if (feature_name == \"sse2\")\n+\t{\n+\t  implicitly_enable_feature (\"sse\");\n+\t}\n+      else if (feature_name == \"sse3\")\n+\t{\n+\t  implicitly_enable_feature (\"sse2\");\n+\t}\n+      else if (feature_name == \"sse4.1\")\n+\t{\n+\t  implicitly_enable_feature (\"sse3\");\n+\t}\n+      else if (feature_name == \"sse4.2\")\n+\t{\n+\t  implicitly_enable_feature (\"sse4.1\");\n+\t}\n+      else if (feature_name == \"ssse3\")\n+\t{\n+\t  implicitly_enable_feature (\"sse3\");\n+\t}\n+\n+      options.target_data.insert_key_value_pair (\"target_feature\",\n+\t\t\t\t\t\t ::std::move (feature_name));\n     }\n+}\n \n-    // Meant to enable all target features. As this will be done by target hook, this method's\n-    // deprecated.\n-    void Session::enable_features() {\n-        bool has_target_crt_static = false;\n-        const char* target = \"PLACEHOLDER\";\n-\n-        fprintf(stderr, \"ERROR: Somewhere in call chain Session::enable_features is called.\\n\");\n-\n-        if (has_target_crt_static) {\n-            // enable \"crt-static\" attribute\n-        }\n-\n-        /* TODO: do this via target hook. have one for each target that implicitly enables the\n-         * features for that platform. Would probably have to make custom target hook. */\n-\n-        /*\n-        if (target == \"x86\" || target == \"x86_64\") {\n-            if (TARGET_ISA_AES) {\n-                // enable aes, implicitly enable sse2\n-                implicitly_enable_feature(\"aes\");\n-            }\n-\n-            if (TARGET_ISA_AVX) {\n-                // enable avx, implicitly enable sse4.2\n-                implicitly_enable_feature(\"sse4.2\");\n-            }\n-\n-            if (TARGET_ISA_AVX2) {\n-                // enable avx2, implicitly enable avx\n-                implicitly_enable_feature(\"avx\");\n-            }\n-\n-            if (TARGET_ISA_BMI) {\n-                // enable bmi1\n-                implicitly_enable_feature(\"bmi1\");\n-            }\n-\n-            if (TARGET_ISA_BMI2) {\n-                // enable bmi2\n-                implicitly_enable_feature(\"bmi2\");\n-            }\n-\n-            if (TARGET_ISA_FMA) {\n-                // enable fma, implicitly enable avx\n-                implicitly_enable_feature(\"fma\");\n-            }\n-\n-            if (TARGET_ISA_FXSR) {\n-                // enable fxsr\n-                implicitly_enable_feature(\"fxsr\");\n-            }\n-\n-            if (TARGET_ISA_LZCNT) {\n-                // enable lzcnt\n-                implicitly_enable_feature(\"lzcnt\");\n-            }\n-\n-            if (TARGET_ISA_VPCLMULQDQ) {\n-                // enable pclmulqdq, implicitly enable sse2\n-                implicitly_enable_feature(\"pclmulqdq\");\n-            }\n-\n-            if (TARGET_ISA_POPCNT) {\n-                // enable popcnt\n-                implicitly_enable_feature(\"popcnt\");\n-            }\n-\n-            if (TARGET_ISA_RDRND) {\n-                // enable rdrand\n-                implicitly_enable_feature(\"rdrand\");\n-            }\n-\n-            if (TARGET_ISA_RDSEED) {\n-                // enable rdseed\n-                implicitly_enable_feature(\"rdseed\");\n-            }\n-\n-            if (TARGET_ISA_SHA) {\n-                // enable sha, implicitly enable sse2\n-                implicitly_enable_feature(\"sha\");\n-            }\n-\n-            if (TARGET_ISA_SSE) {\n-                // enable sse\n-                implicitly_enable_feature(\"sse\");\n-            }\n-\n-            if (TARGET_ISA_SSE2) {\n-                // enable sse2, implicitly enable sse\n-                implicitly_enable_feature(\"sse2\");\n-            }\n-\n-            if (TARGET_ISA_SSE3) {\n-                // enable sse3, implicitly enable sse2\n-                implicitly_enable_feature(\"sse3\");\n-            }\n-\n-            if (TARGET_ISA_SSE4_1) {\n-                // enable sse4.1, implicitly enable sse3\n-                implicitly_enable_feature(\"sse4.1\");\n-            }\n-\n-            if (TARGET_ISA_SSE4_2) {\n-                // enable sse4.2, implicitly enable sse4.1\n-                implicitly_enable_feature(\"sse4.2\");\n-            }\n-\n-            if (TARGET_ISA_SSSE3) {\n-                // enable ssse3, implicitly enable sse3\n-                implicitly_enable_feature(\"ssse3\");\n-            }\n-\n-            if (TARGET_ISA_XSAVE) {\n-                // enable xsave\n-                implicitly_enable_feature(\"xsave\");\n-            }\n-\n-            if (TARGET_ISA_XSAVEC) {\n-                // enable xsavec\n-                implicitly_enable_feature(\"xsavec\");\n-            }\n-\n-            if (TARGET_ISA_XSAVEOPT) {\n-                // enable xsaveopt\n-                implicitly_enable_feature(\"xsaveopt\");\n-            }\n-\n-            if (TARGET_ISA_XSAVES) {\n-                // enable xsaves\n-                implicitly_enable_feature(\"xsaves\");\n-            }\n-        }\n-        options.target_data.features.shrink_to_fit();\n-        ::std::sort(options.target_data.features.begin(), options.target_data.features.end());*/\n+// Meant to enable all target features. As this will be done by target hook,\n+// this method's deprecated.\n+void\n+Session::enable_features ()\n+{\n+  bool has_target_crt_static = false;\n+  const char *target = \"PLACEHOLDER\";\n+\n+  fprintf (\n+    stderr,\n+    \"ERROR: Somewhere in call chain Session::enable_features is called.\\n\");\n+\n+  if (has_target_crt_static)\n+    {\n+      // enable \"crt-static\" attribute\n     }\n \n-    void Session::init() {\n-# define builtin_rust_info(KEY, VALUE) rust_add_target_info (KEY, VALUE)\n+  /* TODO: do this via target hook. have one for each target that implicitly\n+   * enables the\n+   * features for that platform. Would probably have to make custom target hook.\n+   */\n+\n+  /*\n+  if (target == \"x86\" || target == \"x86_64\") {\n+      if (TARGET_ISA_AES) {\n+\t  // enable aes, implicitly enable sse2\n+\t  implicitly_enable_feature(\"aes\");\n+      }\n+\n+      if (TARGET_ISA_AVX) {\n+\t  // enable avx, implicitly enable sse4.2\n+\t  implicitly_enable_feature(\"sse4.2\");\n+      }\n+\n+      if (TARGET_ISA_AVX2) {\n+\t  // enable avx2, implicitly enable avx\n+\t  implicitly_enable_feature(\"avx\");\n+      }\n+\n+      if (TARGET_ISA_BMI) {\n+\t  // enable bmi1\n+\t  implicitly_enable_feature(\"bmi1\");\n+      }\n+\n+      if (TARGET_ISA_BMI2) {\n+\t  // enable bmi2\n+\t  implicitly_enable_feature(\"bmi2\");\n+      }\n+\n+      if (TARGET_ISA_FMA) {\n+\t  // enable fma, implicitly enable avx\n+\t  implicitly_enable_feature(\"fma\");\n+      }\n+\n+      if (TARGET_ISA_FXSR) {\n+\t  // enable fxsr\n+\t  implicitly_enable_feature(\"fxsr\");\n+      }\n+\n+      if (TARGET_ISA_LZCNT) {\n+\t  // enable lzcnt\n+\t  implicitly_enable_feature(\"lzcnt\");\n+      }\n+\n+      if (TARGET_ISA_VPCLMULQDQ) {\n+\t  // enable pclmulqdq, implicitly enable sse2\n+\t  implicitly_enable_feature(\"pclmulqdq\");\n+      }\n+\n+      if (TARGET_ISA_POPCNT) {\n+\t  // enable popcnt\n+\t  implicitly_enable_feature(\"popcnt\");\n+      }\n+\n+      if (TARGET_ISA_RDRND) {\n+\t  // enable rdrand\n+\t  implicitly_enable_feature(\"rdrand\");\n+      }\n+\n+      if (TARGET_ISA_RDSEED) {\n+\t  // enable rdseed\n+\t  implicitly_enable_feature(\"rdseed\");\n+      }\n+\n+      if (TARGET_ISA_SHA) {\n+\t  // enable sha, implicitly enable sse2\n+\t  implicitly_enable_feature(\"sha\");\n+      }\n+\n+      if (TARGET_ISA_SSE) {\n+\t  // enable sse\n+\t  implicitly_enable_feature(\"sse\");\n+      }\n+\n+      if (TARGET_ISA_SSE2) {\n+\t  // enable sse2, implicitly enable sse\n+\t  implicitly_enable_feature(\"sse2\");\n+      }\n+\n+      if (TARGET_ISA_SSE3) {\n+\t  // enable sse3, implicitly enable sse2\n+\t  implicitly_enable_feature(\"sse3\");\n+      }\n+\n+      if (TARGET_ISA_SSE4_1) {\n+\t  // enable sse4.1, implicitly enable sse3\n+\t  implicitly_enable_feature(\"sse4.1\");\n+      }\n+\n+      if (TARGET_ISA_SSE4_2) {\n+\t  // enable sse4.2, implicitly enable sse4.1\n+\t  implicitly_enable_feature(\"sse4.2\");\n+      }\n+\n+      if (TARGET_ISA_SSSE3) {\n+\t  // enable ssse3, implicitly enable sse3\n+\t  implicitly_enable_feature(\"ssse3\");\n+      }\n+\n+      if (TARGET_ISA_XSAVE) {\n+\t  // enable xsave\n+\t  implicitly_enable_feature(\"xsave\");\n+      }\n+\n+      if (TARGET_ISA_XSAVEC) {\n+\t  // enable xsavec\n+\t  implicitly_enable_feature(\"xsavec\");\n+      }\n+\n+      if (TARGET_ISA_XSAVEOPT) {\n+\t  // enable xsaveopt\n+\t  implicitly_enable_feature(\"xsaveopt\");\n+      }\n+\n+      if (TARGET_ISA_XSAVES) {\n+\t  // enable xsaves\n+\t  implicitly_enable_feature(\"xsaves\");\n+      }\n+  }\n+  options.target_data.features.shrink_to_fit();\n+  ::std::sort(options.target_data.features.begin(),\n+  options.target_data.features.end());*/\n+}\n+\n+void\n+Session::init ()\n+{\n+  // nothing yet\n+}\n+\n+// Initialise default options. Actually called before handle_option, unlike init\n+// itself.\n+void\n+Session::init_options ()\n+{\n+  options.dump_option = CompileOptions::NO_DUMP;\n+}\n \n-        // initialise target hooks\n-        targetrustm.rust_cpu_info();\n-        targetrustm.rust_os_info();\n-        \n-#undef builtin_rust_info\n+// Handle option selection.\n+bool\n+Session::handle_option (\n+  enum opt_code code, const char *arg, HOST_WIDE_INT value ATTRIBUTE_UNUSED,\n+  int kind ATTRIBUTE_UNUSED, location_t loc ATTRIBUTE_UNUSED,\n+  const struct cl_option_handlers *handlers ATTRIBUTE_UNUSED)\n+{\n+  // used to store whether results of various stuff are successful\n+  bool ret = true;\n+\n+  // Handles options as listed in lang.opt.\n+  switch (code)\n+    {\n+    case OPT_I:\n+      // TODO: add search path\n+      break;\n+    case OPT_L:\n+      // TODO: add library link path or something\n+      break;\n+    case OPT_frust_dump_:\n+      // enable dump and return whether this was successful\n+      if (arg != NULL)\n+\t{\n+\t  ret = enable_dump (::std::string (arg));\n+\t}\n+      else\n+\t{\n+\t  ret = false;\n+\t}\n+      break;\n+    // no option handling for -o\n+    default:\n+      // return 1 to indicate option is valid\n+      break;\n     }\n \n-    // Initialise default options. Actually called before handle_option, unlike init itself.\n-    void Session::init_options() {\n-        options.dump_option = CompileOptions::NO_DUMP;\n+  return ret;\n+}\n+\n+/* Enables a certain dump depending on the name passed in. Returns true if name\n+ * is valid, false otherwise. */\n+bool\n+Session::enable_dump (::std::string arg)\n+{\n+  // FIXME: change dumping algorithm when new non-inhibiting dump system is\n+  // created\n+  if (arg == \"all\")\n+    {\n+      error_at (\n+\tUNKNOWN_LOCATION,\n+\t\"dumping all is not supported as of now. choose 'lex' or 'parse'\");\n+      return false;\n+    }\n+  else if (arg == \"lex\")\n+    {\n+      options.dump_option = CompileOptions::LEXER_DUMP;\n+    }\n+  else if (arg == \"parse\")\n+    {\n+      options.dump_option = CompileOptions::PARSER_AST_DUMP;\n+    }\n+  else if (arg == \"register_plugins\")\n+    {\n+      options.dump_option = CompileOptions::REGISTER_PLUGINS_DUMP;\n+    }\n+  else if (arg == \"injection\")\n+    {\n+      options.dump_option = CompileOptions::INJECTION_DUMP;\n     }\n+  else if (arg == \"expansion\")\n+    {\n+      options.dump_option = CompileOptions::EXPANSION_DUMP;\n+    }\n+  else if (arg == \"name_resolution\")\n+    {\n+      options.dump_option = CompileOptions::NAME_RESOLUTION_DUMP;\n+    }\n+  else if (arg == \"\")\n+    {\n+      error_at (UNKNOWN_LOCATION,\n+\t\t\"dump option was not given a name. choose 'lex' or 'parse'\");\n+      return false;\n+    }\n+  else\n+    {\n+      error_at (UNKNOWN_LOCATION,\n+\t\t\"dump option '%s' was unrecognised. choose 'lex' or 'parse'\",\n+\t\targ.c_str ());\n+      return false;\n+    }\n+  return true;\n+}\n \n-    // Handle option selection.\n-    bool Session::handle_option(enum opt_code code, const char* arg,\n-      HOST_WIDE_INT value ATTRIBUTE_UNUSED, int kind ATTRIBUTE_UNUSED,\n-      location_t loc ATTRIBUTE_UNUSED, const struct cl_option_handlers* handlers ATTRIBUTE_UNUSED) {\n-        // used to store whether results of various stuff are successful\n-        bool ret = true;\n-\n-        // Handles options as listed in lang.opt.\n-        switch (code) {\n-            case OPT_I:\n-                // TODO: add search path\n-                break;\n-            case OPT_L:\n-                // TODO: add library link path or something\n-                break;\n-            case OPT_frust_dump_:\n-                // enable dump and return whether this was successful\n-                if (arg != NULL) {\n-                    ret = enable_dump(::std::string(arg));\n-                } else {\n-                    ret = false;\n-                }\n-                break;\n-            // no option handling for -o\n-            default:\n-                // return 1 to indicate option is valid\n-                break;\n-        }\n-\n-        return ret;\n+/* Actual main entry point for front-end. Called from langhook to parse files.\n+ */\n+void\n+Session::parse_files (int num_files, const char **files)\n+{\n+  for (int i = 0; i < num_files; i++)\n+    {\n+      parse_file (files[i]);\n     }\n+  // TODO: should semantic analysis be dealed with here? or per file? for now,\n+  // per-file.\n+}\n \n-    /* Enables a certain dump depending on the name passed in. Returns true if name is valid, false\n-     * otherwise. */\n-    bool Session::enable_dump(::std::string arg) {\n-        // FIXME: change dumping algorithm when new non-inhibiting dump system is created\n-        if (arg == \"all\") {\n-            error_at(\n-              UNKNOWN_LOCATION, \"dumping all is not supported as of now. choose 'lex' or 'parse'\");\n-            return false;\n-        } else if (arg == \"lex\") {\n-            options.dump_option = CompileOptions::LEXER_DUMP;\n-        } else if (arg == \"parse\") {\n-            options.dump_option = CompileOptions::PARSER_AST_DUMP;\n-        } else if (arg == \"register_plugins\") {\n-            options.dump_option = CompileOptions::REGISTER_PLUGINS_DUMP;\n-        } else if (arg == \"injection\") {\n-            options.dump_option = CompileOptions::INJECTION_DUMP;\n-        } else if (arg == \"expansion\") {\n-            options.dump_option = CompileOptions::EXPANSION_DUMP;\n-        } else if (arg == \"name_resolution\") {\n-            options.dump_option = CompileOptions::NAME_RESOLUTION_DUMP;\n-        } else if (arg == \"\") {\n-            error_at(UNKNOWN_LOCATION, \"dump option was not given a name. choose 'lex' or 'parse'\");\n-            return false;\n-        } else {\n-            error_at(UNKNOWN_LOCATION, \"dump option '%s' was unrecognised. choose 'lex' or 'parse'\",\n-              arg.c_str());\n-            return false;\n-        }\n-        return true;\n+// Parses a single file with filename filename.\n+void\n+Session::parse_file (const char *filename)\n+{\n+  RAIIFile file_wrap (filename);\n+\n+  if (file_wrap.file == NULL)\n+    {\n+      fatal_error (UNKNOWN_LOCATION, \"cannot open filename %s: %m\", filename);\n     }\n \n-    /* Actual main entry point for front-end. Called from langhook to parse files. */\n-    void Session::parse_files(int num_files, const char** files) {\n-        for (int i = 0; i < num_files; i++) {\n-            parse_file(files[i]);\n-        }\n-        // TODO: should semantic analysis be dealed with here? or per file? for now, per-file.\n+  // parse file here\n+  // create lexer and parser - these are file-specific and so aren't instance\n+  // variables\n+  Rust::Lexer lex (filename, file_wrap.file, rust_get_linemap ());\n+  Rust::Parser parser (lex);\n+\n+  // determine parsing method from options\n+  /* FIXME: currently, the dump means that full compilation will not occur as of\n+   * present. In future, dumps should not inhibit full compilation. */\n+  switch (options.dump_option)\n+    {\n+    case CompileOptions::NO_DUMP:\n+      fatal_error (UNKNOWN_LOCATION,\n+\t\t   \"no-dump parsing has not been enabled yet\");\n+      return;\n+    case CompileOptions::LEXER_DUMP:\n+      parser.debug_dump_lex_output ();\n+      return;\n+    case CompileOptions::PARSER_AST_DUMP:\n+      parser.debug_dump_ast_output ();\n+      return;\n+    case CompileOptions::REGISTER_PLUGINS_DUMP:\n+    case CompileOptions::INJECTION_DUMP:\n+    case CompileOptions::EXPANSION_DUMP:\n+    case CompileOptions::NAME_RESOLUTION_DUMP:\n+      // will break later after more stages\n+      break;\n+    // semantic analysis when completed\n+    default:\n+      fatal_error (UNKNOWN_LOCATION, \"unrecognised dump option: '%u'\",\n+\t\t   options.dump_option);\n+      return;\n     }\n \n-    // Parses a single file with filename filename.\n-    void Session::parse_file(const char* filename) {\n-        RAIIFile file_wrap(filename);\n-\n-        if (file_wrap.file == NULL) {\n-            fatal_error(UNKNOWN_LOCATION, \"cannot open filename %s: %m\", filename);\n-        }\n-\n-        // parse file here\n-        // create lexer and parser - these are file-specific and so aren't instance variables\n-        Rust::Lexer lex(filename, file_wrap.file, rust_get_linemap());\n-        Rust::Parser parser(lex);\n-\n-        // determine parsing method from options\n-        /* FIXME: currently, the dump means that full compilation will not occur as of present. In\n-         * future, dumps should not inhibit full compilation. */\n-        switch (options.dump_option) {\n-            case CompileOptions::NO_DUMP:\n-                fatal_error(UNKNOWN_LOCATION, \"no-dump parsing has not been enabled yet\");\n-                return;\n-            case CompileOptions::LEXER_DUMP:\n-                parser.debug_dump_lex_output();\n-                return;\n-            case CompileOptions::PARSER_AST_DUMP:\n-                parser.debug_dump_ast_output();\n-                return;\n-            case CompileOptions::REGISTER_PLUGINS_DUMP:\n-            case CompileOptions::INJECTION_DUMP:\n-            case CompileOptions::EXPANSION_DUMP:\n-            case CompileOptions::NAME_RESOLUTION_DUMP:\n-                // will break later after more stages\n-                break;\n-            // semantic analysis when completed\n-            default:\n-                fatal_error(UNKNOWN_LOCATION, \"unrecognised dump option: '%u'\", options.dump_option);\n-                return;\n-        }\n-\n-        /* basic pipeline:\n-         *  - lex\n-         *  - parse\n-         *  - register plugins (dummy stage for now) - attribute injection? what is this?\n-         *    (attribute injection is injecting attributes specified in command line into crate root)\n-         *  - injection (some lint checks or dummy, register builtin macros, crate injection)\n-         *  - expansion (expands all macros, maybe build test harness, AST validation, maybe macro\n-         * crate)\n-         *  - name resolution (name resolution, maybe feature checking, maybe buffered lints)\n-         *  TODO not done */\n-\n-        // generate crate from parser\n-        AST::Crate parsed_crate = parser.parse_crate();\n-\n-        fprintf(stderr, \"\\033[0;31mSUCCESSFULLY PARSED CRATE \\n\\033[0m\");\n-\n-        // register plugins pipeline stage\n-        register_plugins(parsed_crate);\n-        fprintf(stderr, \"\\033[0;31mSUCCESSFULLY REGISTERED PLUGINS \\n\\033[0m\");\n-\n-        if (options.dump_option == CompileOptions::REGISTER_PLUGINS_DUMP) {\n-            // TODO: what do I dump here?\n-            return;\n-        }\n-\n-        // injection pipeline stage\n-        injection(parsed_crate);\n-        fprintf(stderr, \"\\033[0;31mSUCCESSFULLY FINISHED INJECTION \\n\\033[0m\");\n-\n-        if (options.dump_option == CompileOptions::INJECTION_DUMP) {\n-            // TODO: what do I dump here? injected crate names?\n-            return;\n-        }\n-\n-        // expansion pipeline stage\n-        expansion(parsed_crate);\n-        fprintf(stderr, \"\\033[0;31mSUCCESSFULLY FINISHED EXPANSION \\n\\033[0m\");\n-\n-        if (options.dump_option == CompileOptions::EXPANSION_DUMP) {\n-            // TODO: what do I dump here? expanded macros? AST with expanded macros?\n-            return;\n-        }\n-\n-        // name resolution pipeline stage\n-        name_resolution(parsed_crate);\n-        fprintf(stderr, \"\\033[0;31mSUCCESSFULLY FINISHED NAME RESOLUTION \\n\\033[0m\");\n-\n-        if (options.dump_option == CompileOptions::NAME_RESOLUTION_DUMP) {\n-            // TODO: what do I dump here? resolved names? AST with resolved names?\n-            return;\n-        }\n+  /* basic pipeline:\n+   *  - lex\n+   *  - parse\n+   *  - register plugins (dummy stage for now) - attribute injection? what is\n+   * this? (attribute injection is injecting attributes specified in command\n+   * line into crate root)\n+   *  - injection (some lint checks or dummy, register builtin macros, crate\n+   * injection)\n+   *  - expansion (expands all macros, maybe build test harness, AST validation,\n+   * maybe macro crate)\n+   *  - name resolution (name resolution, maybe feature checking, maybe buffered\n+   * lints)\n+   *  TODO not done */\n+\n+  // generate crate from parser\n+  AST::Crate parsed_crate = parser.parse_crate ();\n+\n+  fprintf (stderr, \"\\033[0;31mSUCCESSFULLY PARSED CRATE \\n\\033[0m\");\n+\n+  // register plugins pipeline stage\n+  register_plugins (parsed_crate);\n+  fprintf (stderr, \"\\033[0;31mSUCCESSFULLY REGISTERED PLUGINS \\n\\033[0m\");\n+\n+  if (options.dump_option == CompileOptions::REGISTER_PLUGINS_DUMP)\n+    {\n+      // TODO: what do I dump here?\n+      return;\n     }\n \n-    // Checks whether 'cfg' attribute prevents compilation.\n-    bool check_cfg(const AST::Attribute& attr ATTRIBUTE_UNUSED) {\n-        // if \"has sub items\", and if 'cfg' attr, recursively call this on sub items?\n+  // injection pipeline stage\n+  injection (parsed_crate);\n+  fprintf (stderr, \"\\033[0;31mSUCCESSFULLY FINISHED INJECTION \\n\\033[0m\");\n+\n+  if (options.dump_option == CompileOptions::INJECTION_DUMP)\n+    {\n+      // TODO: what do I dump here? injected crate names?\n+      return;\n+    }\n \n-        // TODO: actually implement. assume true for now\n+  // expansion pipeline stage\n+  expansion (parsed_crate);\n+  fprintf (stderr, \"\\033[0;31mSUCCESSFULLY FINISHED EXPANSION \\n\\033[0m\");\n \n-        return true;\n+  if (options.dump_option == CompileOptions::EXPANSION_DUMP)\n+    {\n+      // TODO: what do I dump here? expanded macros? AST with expanded macros?\n+      return;\n     }\n-    // TODO: deprecated - don't use\n \n-    // Checks whether any 'cfg' attribute on the item prevents compilation of that item.\n-    bool check_item_cfg(::std::vector<AST::Attribute> attrs) {\n-        for (const auto& attr : attrs) {\n-            if (attr.get_path() == \"cfg\" && !check_cfg(attr)) {\n-                return false;\n-            }\n-        }\n+  // name resolution pipeline stage\n+  name_resolution (parsed_crate);\n+  fprintf (stderr, \"\\033[0;31mSUCCESSFULLY FINISHED NAME RESOLUTION \\n\\033[0m\");\n \n-        return true;\n+  if (options.dump_option == CompileOptions::NAME_RESOLUTION_DUMP)\n+    {\n+      // TODO: what do I dump here? resolved names? AST with resolved names?\n+      return;\n     }\n-    // TODO: deprecated - don't use\n-\n-    // TODO: actually implement method\n-    void load_extern_crate(::std::string crate_name ATTRIBUTE_UNUSED) {}\n-    // TODO: deprecated - don't use\n-\n-    // Parses up to the \"load (external) crates\" part of the frontend.\n-    // TODO: lots of this code is probably actually useful outside of dumping, so maybe split off\n-    // function\n-    void Session::debug_dump_load_crates(Parser& parser) {\n-        // parse crate as AST\n-        AST::Crate crate = parser.parse_crate();\n-\n-        /* TODO: search through inner attrs and see whether any of those attr paths contain \"no_core\",\n-         * \"no_std\", \"compiler_builtins\". If so/not, save certain crate names. In these names, insert\n-         * items at beginning of crate items. This is crate injection. Also, inject prelude use decl\n-         * at beginning (first name is assumed to be prelude - prelude is a use decl automatically\n-         * generated to enable using Option and Copy without qualifying it or importing it via 'use'\n-         * manually) */\n-\n-        ::std::vector< ::std::string> crate_names;\n-        for (const auto& item : crate.items) {\n-            // if item is extern crate, add name? to list of stuff ONLY IF config is checked\n-            // if item is module, iterate this loop inside it as well (recursive?) ONLY IF config is\n-            // checked\n-\n-            // TODO: actually do the checks somewhere - probably in the items\n-\n-            item->add_crate_name(crate_names);\n-        }\n-\n-        /* loop through list of crate names/paths/whatever, attempting to load each one. save loaded\n-         * crates to a Session variable? Or save to current AST::Crate? */\n-        for (const auto& name : crate_names) {\n-            load_extern_crate(name /*, basename = \"\"?*/);\n-        }\n-        //  for each loaded crate, load dependencies of it as well\n+}\n+\n+// Checks whether 'cfg' attribute prevents compilation.\n+bool\n+check_cfg (const AST::Attribute &attr ATTRIBUTE_UNUSED)\n+{\n+  // if \"has sub items\", and if 'cfg' attr, recursively call this on sub items?\n+\n+  // TODO: actually implement. assume true for now\n+\n+  return true;\n+}\n+// TODO: deprecated - don't use\n+\n+// Checks whether any 'cfg' attribute on the item prevents compilation of that\n+// item.\n+bool\n+check_item_cfg (::std::vector<AST::Attribute> attrs)\n+{\n+  for (const auto &attr : attrs)\n+    {\n+      if (attr.get_path () == \"cfg\" && !check_cfg (attr))\n+\t{\n+\t  return false;\n+\t}\n+    }\n+\n+  return true;\n+}\n+// TODO: deprecated - don't use\n+\n+// TODO: actually implement method\n+void\n+load_extern_crate (::std::string crate_name ATTRIBUTE_UNUSED)\n+{}\n+// TODO: deprecated - don't use\n+\n+// Parses up to the \"load (external) crates\" part of the frontend.\n+// TODO: lots of this code is probably actually useful outside of dumping, so\n+// maybe split off function\n+void\n+Session::debug_dump_load_crates (Parser &parser)\n+{\n+  // parse crate as AST\n+  AST::Crate crate = parser.parse_crate ();\n+\n+  /* TODO: search through inner attrs and see whether any of those attr paths\n+   * contain \"no_core\", \"no_std\", \"compiler_builtins\". If so/not, save certain\n+   * crate names. In these names, insert items at beginning of crate items. This\n+   * is crate injection. Also, inject prelude use decl at beginning (first name\n+   * is assumed to be prelude - prelude is a use decl automatically generated to\n+   * enable using Option and Copy without qualifying it or importing it via\n+   * 'use' manually) */\n+\n+  ::std::vector< ::std::string> crate_names;\n+  for (const auto &item : crate.items)\n+    {\n+      // if item is extern crate, add name? to list of stuff ONLY IF config is\n+      // checked if item is module, iterate this loop inside it as well\n+      // (recursive?) ONLY IF config is checked\n+\n+      // TODO: actually do the checks somewhere - probably in the items\n+\n+      item->add_crate_name (crate_names);\n+    }\n+\n+  /* loop through list of crate names/paths/whatever, attempting to load each\n+   * one. save loaded crates to a Session variable? Or save to current\n+   * AST::Crate? */\n+  for (const auto &name : crate_names)\n+    {\n+      load_extern_crate (name /*, basename = \"\"?*/);\n+    }\n+  //  for each loaded crate, load dependencies of it as well\n+}\n+// TODO: deprecated - don't use\n+\n+void\n+Session::register_plugins (AST::Crate &crate ATTRIBUTE_UNUSED)\n+{\n+  fprintf (stderr, \"ran register_plugins (with no body)\\n\");\n+}\n+\n+// TODO: move somewhere else\n+bool\n+contains_name (::std::vector<AST::Attribute> attrs, ::std::string name)\n+{\n+  for (const auto &attr : attrs)\n+    {\n+      if (attr.get_path () == name)\n+\t{\n+\t  return true;\n+\t}\n     }\n-    // TODO: deprecated - don't use\n \n-    void Session::register_plugins(AST::Crate& crate ATTRIBUTE_UNUSED) {\n-        fprintf(stderr, \"ran register_plugins (with no body)\\n\");\n+  return false;\n+}\n+\n+void\n+Session::injection (AST::Crate &crate)\n+{\n+  fprintf (stderr, \"started injection\\n\");\n+\n+  // lint checks in future maybe?\n+\n+  // register builtin macros\n+  /* In rustc, builtin macros are divided into 3 categories depending on use -\n+   * \"bang\" macros, \"attr\" macros, and \"derive\" macros. I think the meanings of\n+   * these categories should be fairly obvious to anyone who has used rust.\n+   * Builtin macro list by category: Bang\n+   *      - asm\n+   *      - assert\n+   *      - cfg\n+   *      - column\n+   *      - compile_error\n+   *      - concat_idents\n+   *      - concat\n+   *      - env\n+   *      - file\n+   *      - format_args_nl\n+   *      - format_args\n+   *      - global_asm\n+   *      - include_bytes\n+   *      - include_str\n+   *      - include\n+   *      - line\n+   *      - log_syntax\n+   *      - module_path\n+   *      - option_env\n+   *      - stringify\n+   *      - trace_macros\n+   *  Attr\n+   *      - bench\n+   *      - global_allocator\n+   *      - test\n+   *      - test_case\n+   *  Derive\n+   *      - Clone\n+   *      - Copy\n+   *      - Debug\n+   *      - Default\n+   *      - Eq\n+   *      - Hash\n+   *      - Ord\n+   *      - PartialEq\n+   *      - PartialOrd\n+   *      - RustcDecodable\n+   *      - RustcEncodable\n+   * rustc also has a \"quote\" macro that is defined differently and is\n+   * supposedly not stable so eh. */\n+  /* TODO: actually implement injection of these macros. In particular, derive\n+   * macros, cfg, and\n+   * test should be prioritised since they seem to be used the most. */\n+\n+  // crate injection\n+  ::std::vector< ::std::string> names;\n+  if (contains_name (crate.inner_attrs, \"no_core\"))\n+    {\n+      // no prelude\n+      injected_crate_name = \"\";\n     }\n+  else if (contains_name (crate.inner_attrs, \"no_std\"))\n+    {\n+      names.push_back (\"core\");\n \n-    // TODO: move somewhere else\n-    bool contains_name(const std::vector<AST::Attribute>& attrs, std::string name) {\n-        for (const auto& attr : attrs) {\n-            if (attr.get_path() == name) {\n-                return true;\n-            }\n-        }\n+      if (!contains_name (crate.inner_attrs, \"compiler_builtins\"))\n+\t{\n+\t  names.push_back (\"compiler_builtins\");\n+\t}\n \n-        return false;\n+      injected_crate_name = \"core\";\n     }\n+  else\n+    {\n+      names.push_back (\"std\");\n \n-    void Session::injection(AST::Crate& crate) {\n-        fprintf(stderr, \"started injection\\n\");\n-\n-        // lint checks in future maybe?\n-\n-        // register builtin macros\n-        /* In rustc, builtin macros are divided into 3 categories depending on use - \"bang\" macros,\n-         * \"attr\" macros, and \"derive\" macros. I think the meanings of these categories should be\n-         * fairly obvious to anyone who has used rust. Builtin macro list by category: Bang\n-         *      - asm\n-         *      - assert\n-         *      - cfg\n-         *      - column\n-         *      - compile_error\n-         *      - concat_idents\n-         *      - concat\n-         *      - env\n-         *      - file\n-         *      - format_args_nl\n-         *      - format_args\n-         *      - global_asm\n-         *      - include_bytes\n-         *      - include_str\n-         *      - include\n-         *      - line\n-         *      - log_syntax\n-         *      - module_path\n-         *      - option_env\n-         *      - stringify\n-         *      - trace_macros\n-         *  Attr\n-         *      - bench\n-         *      - global_allocator\n-         *      - test\n-         *      - test_case\n-         *  Derive\n-         *      - Clone\n-         *      - Copy\n-         *      - Debug\n-         *      - Default\n-         *      - Eq\n-         *      - Hash\n-         *      - Ord\n-         *      - PartialEq\n-         *      - PartialOrd\n-         *      - RustcDecodable\n-         *      - RustcEncodable\n-         * rustc also has a \"quote\" macro that is defined differently and is supposedly not stable so\n-         * eh. */\n-        /* TODO: actually implement injection of these macros. In particular, derive macros, cfg, and\n-         * test should be prioritised since they seem to be used the most. */\n-\n-        // crate injection\n-        ::std::vector< ::std::string> names;\n-        if (contains_name(crate.inner_attrs, \"no_core\")) {\n-            // no prelude\n-            injected_crate_name = \"\";\n-        } else if (contains_name(crate.inner_attrs, \"no_std\")) {\n-            names.push_back(\"core\");\n-\n-            if (!contains_name(crate.inner_attrs, \"compiler_builtins\")) {\n-                names.push_back(\"compiler_builtins\");\n-            }\n-\n-            injected_crate_name = \"core\";\n-        } else {\n-            names.push_back(\"std\");\n-\n-            injected_crate_name = \"std\";\n-        }\n-\n-        // reverse iterate through names to insert crate items in \"forward\" order at beginning of\n-        // crate\n-        for (auto it = names.rbegin(); it != names.rend(); ++it) {\n-            // create \"macro use\" attribute for use on extern crate item to enable loading macros from\n-            // it\n-            AST::Attribute attr(AST::SimplePath::from_str(\"macro_use\"), NULL);\n-\n-            // create \"extern crate\" item with the name\n-            ::std::unique_ptr<AST::ExternCrate> extern_crate(\n-              new AST::ExternCrate(*it, AST::Visibility::create_error(), { ::std::move(attr) },\n-              Linemap::unknown_location()));\n-\n-            // insert at beginning\n-            crate.items.insert(crate.items.begin(), ::std::move(extern_crate));\n-        }\n-\n-        // create use tree path\n-        // prelude is injected_crate_name\n-        ::std::vector<AST::SimplePathSegment> segments\n-          = { AST::SimplePathSegment(injected_crate_name), AST::SimplePathSegment(\"prelude\"),\n-                AST::SimplePathSegment(\"v1\") };\n-        // create use tree and decl\n-        ::std::unique_ptr<AST::UseTreeGlob> use_tree(new AST::UseTreeGlob(\n-          AST::UseTreeGlob::PATH_PREFIXED, AST::SimplePath(::std::move(segments)), Location()));\n-        AST::Attribute prelude_attr(AST::SimplePath::from_str(\"prelude_import\"), NULL);\n-        ::std::unique_ptr<AST::UseDeclaration> use_decl(new AST::UseDeclaration(::std::move(use_tree),\n-          AST::Visibility::create_error(), { ::std::move(prelude_attr) }, Location()));\n-\n-        crate.items.insert(crate.items.begin(), ::std::move(use_decl));\n-\n-        /* TODO: potentially add checking attribute crate type? I can't figure out what this does\n-         * currently comment says \"Unconditionally collect crate types from attributes to make them\n-         * used\", which presumably refers to checking the linkage info by \"crate_type\". It also seems\n-         * to ensure that an invalid crate type is not specified, so maybe just do that. Valid crate\n-         * types: bin lib dylib staticlib cdylib rlib proc-macro */\n-\n-        fprintf(stderr, \"finished injection\\n\");\n+      injected_crate_name = \"std\";\n     }\n \n-    void Session::expansion(AST::Crate& crate ATTRIBUTE_UNUSED) {\n-        fprintf(stderr, \"started expansion\\n\");\n+  // reverse iterate through names to insert crate items in \"forward\" order\n+  // at beginning of crate\n+  for (auto it = names.rbegin (); it != names.rend (); ++it)\n+    {\n+      // create \"macro use\" attribute for use on extern crate item to enable\n+      // loading macros from it\n+      AST::Attribute attr (AST::SimplePath::from_str (\"macro_use\"), NULL);\n+\n+      // create \"extern crate\" item with the name\n+      ::std::unique_ptr<AST::ExternCrate> extern_crate (\n+\tnew AST::ExternCrate (*it, AST::Visibility::create_error (),\n+\t\t\t      {::std::move (attr)},\n+\t\t\t      Linemap::unknown_location ()));\n+\n+      // insert at beginning\n+      crate.items.insert (crate.items.begin (), ::std::move (extern_crate));\n+    }\n \n-        // rustc has a modification to windows PATH temporarily here, which may end up being required\n+  // create use tree path\n+  // prelude is injected_crate_name\n+  ::std::vector<AST::SimplePathSegment> segments\n+    = {AST::SimplePathSegment (injected_crate_name),\n+       AST::SimplePathSegment (\"prelude\"), AST::SimplePathSegment (\"v1\")};\n+  // create use tree and decl\n+  ::std::unique_ptr<AST::UseTreeGlob> use_tree (\n+    new AST::UseTreeGlob (AST::UseTreeGlob::PATH_PREFIXED,\n+\t\t\t  AST::SimplePath (::std::move (segments)),\n+\t\t\t  Location ()));\n+  AST::Attribute prelude_attr (AST::SimplePath::from_str (\"prelude_import\"),\n+\t\t\t       NULL);\n+  ::std::unique_ptr<AST::UseDeclaration> use_decl (\n+    new AST::UseDeclaration (::std::move (use_tree),\n+\t\t\t     AST::Visibility::create_error (),\n+\t\t\t     {::std::move (prelude_attr)}, Location ()));\n+\n+  crate.items.insert (crate.items.begin (), ::std::move (use_decl));\n+\n+  /* TODO: potentially add checking attribute crate type? I can't figure out\n+   * what this does currently comment says \"Unconditionally collect crate\n+   * types from attributes to make them used\", which presumably refers to\n+   * checking the linkage info by \"crate_type\". It also seems to ensure that\n+   * an invalid crate type is not specified, so maybe just do that. Valid\n+   * crate types: bin lib dylib staticlib cdylib rlib proc-macro */\n+\n+  fprintf (stderr, \"finished injection\\n\");\n+}\n \n-        // create macro expansion config?\n-        // if not, would at least have to configure recursion_limit\n+void\n+Session::expansion (AST::Crate &crate ATTRIBUTE_UNUSED)\n+{\n+  fprintf (stderr, \"started expansion\\n\");\n \n-        // create extctxt? from parse session, cfg, and resolver?\n-        // expand by calling cxtctxt object's monotonic_expander's expand_crate method.\n+  // rustc has a modification to windows PATH temporarily here, which may end\n+  // up being required\n \n-        // error reporting - check unused macros, get missing fragment specifiers\n+  // create macro expansion config?\n+  // if not, would at least have to configure recursion_limit\n \n-        // build test harness\n+  // create extctxt? from parse session, cfg, and resolver?\n+  // expand by calling cxtctxt object's monotonic_expander's expand_crate\n+  // method.\n \n-        // ast validation (also with proc macro decls)\n+  // error reporting - check unused macros, get missing fragment specifiers\n \n-        // maybe create macro crate if not rustdoc\n+  // build test harness\n \n-        fprintf(stderr, \"finished expansion\\n\");\n-    }\n+  // ast validation (also with proc macro decls)\n \n-    void Session::name_resolution(AST::Crate& crate ATTRIBUTE_UNUSED) {\n-        fprintf(stderr, \"started name resolution\\n\");\n+  // maybe create macro crate if not rustdoc\n \n-        fprintf(stderr, \"finished name resolution\\n\");\n-    }\n+  fprintf (stderr, \"finished expansion\\n\");\n+}\n \n-    // NOTEs:\n-    /* mrustc compile pipeline:\n-     *  - target load (pass target spec to parser?)\n-     *  - parse (convert source to AST)\n-     *  - load crates (load any explicitly mentioned extern crates [not all of them])\n-     *  - expand (AST transformations from attributes and macros, loads remaining extern crates\n-     * [std/core and any triggered by macro expansion])\n-     *  - implicit crates (test harness, allocator crate, panic crate)\n-     *  - resolve use (annotate every 'use' item with source [supposedly handles nasty recursion])\n-     *  - resolve index (generate index of visible items for every module [avoids recursion in next\n-     * pass])\n-     *  - resolve absolute (resolve all paths into either variable names [types/values] or absolute\n-     * paths)\n-     *  - HIR lower (convert modified AST to simpler HIR [both expressions and module tree])\n-     *  - resolve type aliases (replace any usages of type aliases with actual type [except associated\n-     *    types])\n-     *  - resolve bind (iterate HIR tree and set binding annotations on all concrete types [avoids\n-     * path lookups later])\n-     *  - resolve HIR markings (generate \"markings\" [e.g. for Copy/Send/Sync/...] for all types\n-     *  - sort impls (small pass - sort impls into groups)\n-     *  - resolve UFCS outer (determine source trait for all top-level <T>::Type [qualified] paths)\n-     *  - resolve UFCS paths (do the same, but include for exprs this time. also normalises results of\n-     *    previous pass [expanding known associated types])\n-     *  - constant evaluate (evaluate all constants)\n-     *  - typecheck outer (checks impls are sane)\n-     *  - typecheck expressions (resolve and check types for all exprs)\n-     *  - expand HIR annotate (annotate how exprs are used - used for closure extractions and\n-     * reborrows)\n-     *  - expand HIR closures (extract closures into structs implementing Fn* traits)\n-     *  - expand HIR vtables (generate vtables for types with dyn dispatch)\n-     *  - expand HIR calls (converts method and callable calls into explicit function calls)\n-     *  - expand HIR reborrows (apply reborrow rules [taking '&mut *v' instead of 'v'])\n-     *  - expand HIR erasedtype (replace all erased types 'impl Trait' with the true type)\n-     *  - typecheck expressions (validate - double check that previous passes haven't broke type\n-     * system rules)\n-     *  - lower MIR (convert HIR exprs into a control-flow graph [MIR])\n-     *  - MIR validate (check that the generated MIR is consistent)\n-     *  - MIR cleanup (perform various transformations on MIR - replace reads of const items with the\n-     * item itself; convert casts to unsized types into 'MakeDst' operations)\n-     *  - MIR optimise (perform various simple optimisations on the MIR - constant propagation, dead\n-     * code elimination, borrow elimination, some inlining)\n-     *  - MIR validate PO (re-validate the MIR)\n-     *  - MIR validate full (optionally: perform expensive state-tracking validation on MIR)\n-     *  - trans enumerate (enumerate all items needed for code generation, primarily types used for\n-     * generics)\n-     *  - trans auto impls (create magic trait impls as enumerated in previous pass)\n-     *  - trans monomorph (generate monomorphised copies of all functions [with generics replaced with\n-     * real types])\n-     *  - MIR optimise inline (run optimisation again, this time with full type info [primarily for\n-     * inlining])\n-     *  - HIR serialise (write out HIR dump [module tree and generic/inline MIR])\n-     *  - trans codegen (generate final output file: emit C source file and call C compiler) */\n-\n-    /* rustc compile pipeline (basic, in way less detail):\n-     *  - parse input (parse .rs to AST)\n-     *  - name resolution, macro expansion, and configuration (process AST recursively, resolving\n-     * paths, expanding macros, processing #[cfg] nodes [i.e. maybe stripping stuff from AST])\n-     *  - lower to HIR\n-     *  - type check and other analyses (e.g. privacy checking)\n-     *  - lower to MIR and post-processing (and do stuff like borrow checking)\n-     *  - translation to LLVM IR and LLVM optimisations (produce the .o files)\n-     *  - linking (link together .o files) */\n-\n-    /* Pierced-together rustc compile pipeline (from source):\n-     *  - parse input (parse file to crate)\n-     *  - register plugins (attributes injection, set various options, register lints, load plugins)\n-     *  - expansion/configure and expand (initial 'cfg' processing, 'loading compiler plugins',\n-     *    syntax expansion, secondary 'cfg' expansion, synthesis of a test harness if required,\n-     * injection of any std lib dependency and prelude, and name resolution) - actually documented\n-     * inline\n-     *      - seeming pierced-together order: pre-AST expansion lint checks, registering builtin\n-     * macros, crate injection, then expand all macros, then maybe build test harness, AST validation,\n-     *        maybe create a macro crate (if not rustdoc), name resolution, complete gated feature\n-     * checking, add all buffered lints\n-     *  - create global context (lower to HIR)\n-     *  - analysis on global context (HIR optimisations? create MIR?)\n-     *  - code generation\n-     *  - link */\n+void\n+Session::name_resolution (AST::Crate &crate ATTRIBUTE_UNUSED)\n+{\n+  fprintf (stderr, \"started name resolution\\n\");\n+\n+  fprintf (stderr, \"finished name resolution\\n\");\n }\n+\n+// NOTEs:\n+/* mrustc compile pipeline:\n+ *  - target load (pass target spec to parser?)\n+ *  - parse (convert source to AST)\n+ *  - load crates (load any explicitly mentioned extern crates [not all of\n+ * them])\n+ *  - expand (AST transformations from attributes and macros, loads remaining\n+ * extern crates [std/core and any triggered by macro expansion])\n+ *  - implicit crates (test harness, allocator crate, panic crate)\n+ *  - resolve use (annotate every 'use' item with source [supposedly handles\n+ * nasty recursion])\n+ *  - resolve index (generate index of visible items for every module [avoids\n+ * recursion in next pass])\n+ *  - resolve absolute (resolve all paths into either variable names\n+ * [types/values] or absolute paths)\n+ *  - HIR lower (convert modified AST to simpler HIR [both expressions and\n+ * module tree])\n+ *  - resolve type aliases (replace any usages of type aliases with actual\n+ * type [except associated types])\n+ *  - resolve bind (iterate HIR tree and set binding annotations on all\n+ * concrete types [avoids path lookups later])\n+ *  - resolve HIR markings (generate \"markings\" [e.g. for Copy/Send/Sync/...]\n+ * for all types\n+ *  - sort impls (small pass - sort impls into groups)\n+ *  - resolve UFCS outer (determine source trait for all top-level <T>::Type\n+ * [qualified] paths)\n+ *  - resolve UFCS paths (do the same, but include for exprs this time. also\n+ * normalises results of previous pass [expanding known associated types])\n+ *  - constant evaluate (evaluate all constants)\n+ *  - typecheck outer (checks impls are sane)\n+ *  - typecheck expressions (resolve and check types for all exprs)\n+ *  - expand HIR annotate (annotate how exprs are used - used for closure\n+ * extractions and reborrows)\n+ *  - expand HIR closures (extract closures into structs implementing Fn*\n+ * traits)\n+ *  - expand HIR vtables (generate vtables for types with dyn dispatch)\n+ *  - expand HIR calls (converts method and callable calls into explicit\n+ * function calls)\n+ *  - expand HIR reborrows (apply reborrow rules [taking '&mut *v' instead of\n+ * 'v'])\n+ *  - expand HIR erasedtype (replace all erased types 'impl Trait' with the\n+ * true type)\n+ *  - typecheck expressions (validate - double check that previous passes\n+ * haven't broke type system rules)\n+ *  - lower MIR (convert HIR exprs into a control-flow graph [MIR])\n+ *  - MIR validate (check that the generated MIR is consistent)\n+ *  - MIR cleanup (perform various transformations on MIR - replace reads of\n+ * const items with the item itself; convert casts to unsized types into\n+ * 'MakeDst' operations)\n+ *  - MIR optimise (perform various simple optimisations on the MIR - constant\n+ * propagation, dead code elimination, borrow elimination, some inlining)\n+ *  - MIR validate PO (re-validate the MIR)\n+ *  - MIR validate full (optionally: perform expensive state-tracking\n+ * validation on MIR)\n+ *  - trans enumerate (enumerate all items needed for code generation,\n+ * primarily types used for generics)\n+ *  - trans auto impls (create magic trait impls as enumerated in previous\n+ * pass)\n+ *  - trans monomorph (generate monomorphised copies of all functions [with\n+ * generics replaced with real types])\n+ *  - MIR optimise inline (run optimisation again, this time with full type\n+ * info [primarily for inlining])\n+ *  - HIR serialise (write out HIR dump [module tree and generic/inline MIR])\n+ *  - trans codegen (generate final output file: emit C source file and call C\n+ * compiler) */\n+\n+/* rustc compile pipeline (basic, in way less detail):\n+ *  - parse input (parse .rs to AST)\n+ *  - name resolution, macro expansion, and configuration (process AST\n+ * recursively, resolving paths, expanding macros, processing #[cfg] nodes\n+ * [i.e. maybe stripping stuff from AST])\n+ *  - lower to HIR\n+ *  - type check and other analyses (e.g. privacy checking)\n+ *  - lower to MIR and post-processing (and do stuff like borrow checking)\n+ *  - translation to LLVM IR and LLVM optimisations (produce the .o files)\n+ *  - linking (link together .o files) */\n+\n+/* Pierced-together rustc compile pipeline (from source):\n+ *  - parse input (parse file to crate)\n+ *  - register plugins (attributes injection, set various options, register\n+ * lints, load plugins)\n+ *  - expansion/configure and expand (initial 'cfg' processing, 'loading\n+ * compiler plugins', syntax expansion, secondary 'cfg' expansion, synthesis\n+ * of a test harness if required, injection of any std lib dependency and\n+ * prelude, and name resolution) - actually documented inline\n+ *      - seeming pierced-together order: pre-AST expansion lint checks,\n+ * registering builtin macros, crate injection, then expand all macros, then\n+ * maybe build test harness, AST validation, maybe create a macro crate (if\n+ * not rustdoc), name resolution, complete gated feature checking, add all\n+ * buffered lints\n+ *  - create global context (lower to HIR)\n+ *  - analysis on global context (HIR optimisations? create MIR?)\n+ *  - code generation\n+ *  - link */\n+} // namespace Rust"}, {"sha": "1ce3a92974325922541742c9a118fe4fc17ed43d", "filename": "gcc/rust/rust-session-manager.h", "status": "modified", "additions": 200, "deletions": 168, "changes": 368, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Frust-session-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Frust-session-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.h?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -18,174 +18,206 @@\n #include <utility>\n \n namespace Rust {\n-    // parser forward decl\n-    class Parser;\n-    // crate forward decl\n-    namespace AST {\n-        struct Crate;\n-    }\n-\n-    // Data related to target, most useful for conditional compilation and whatever.\n-    struct TargetOptions {\n-        // TODO: maybe make private and access through helpers to allow changes to impl\n-        std::unordered_map<std::string, std::unordered_set<std::string>> features;\n-\n-      public:\n-        // Returns whether a key is defined in the feature set.\n-        bool has_key(std::string key) const {\n-            return features.find(key) != features.end();\n-        }\n-\n-        // Returns whether a key exists with the given value in the feature set.\n-        bool has_key_value_pair(std::string key, std::string value) const {\n-            auto it = features.find(key);\n-            if (it != features.end()) {\n-                auto set = it->second;\n-                auto it2 = set.find(value);\n-                if (it2 != set.end())\n-                    return true;\n-            }\n-            return false;\n-        }\n-\n-        // Returns the singular value from the key, or if the key has multiple, an empty string.\n-        std::string get_singular_value(std::string key) const {\n-            auto it = features.find(key);\n-            if (it != features.end()) {\n-                auto set = it->second;\n-                if (set.size() == 1)\n-                    return *set.begin();\n-            }\n-            return \"\";\n-        }\n-\n-        // Returns all values associated with a key (including none), or an empty set if no key is found.\n-        std::unordered_set< ::std::string> get_values_for_key(std::string key) const {\n-            auto it = features.find(key);\n-            if (it != features.end()) {\n-                return it->second;\n-            }\n-            return {};\n-        }\n-\n-        /* Inserts a key (no value) into the feature set. This will do nothing if the key already exists. \n-         * This returns whether the insertion was successful (i.e. whether key already existed). */\n-        bool insert_key(std::string key) {\n-            return features.insert(std::make_pair(key, std::unordered_set<std::string>())).second;\n-        }\n-\n-        // Inserts a key-value pair into the feature set. \n-        void insert_key_value_pair(std::string key, std::string value) {\n-            auto existing_set = get_values_for_key(key);\n-            existing_set.insert(std::move(value));\n-            features[std::move(key)] = std::move(existing_set);\n-        }\n-\n-        /* According to reference, Rust uses either multi-map key-values or just values (although\n-         * values may be aliases for a key-value value). This seems like overkill. Thus, depending on\n-         * whether the attributes used in cfg are fixed or not, I think I'll either put each\n-         * non-multimap \"key-value\" as a separate field and have the multimap \"key-values\" in a\n-         * regular map for that one key, or actually use a multimap.\n-         *\n-         * rustc itself uses a set of key-value tuples where the second tuple element is optional.\n-         * This gets rid of the requirement to make a multi-map, I guess, but seems like it might make\n-         * search slow (unless all \"is defined\"-only ones have empty string as second element). */\n-        /* cfg attributes:\n-         * - target_arch: single value\n-         * - target_feature: multiple values possible\n-         * - target_os: single value\n-         * - target_family: single value (or no value?)\n-         * - unix: set when target_family = \"unix\"\n-         * - windows: set when target_family = \"windows\"\n-         *  - if these are just syntactic sugar, then maybe have a separate set or map for this kind\n-         * of stuff\n-         * - target_env: set when needed for disambiguation about ABI - usually empty string for GNU,\n-         * complicated\n-         *  - seems to be a single value (if any)\n-         * - target_endian: single value; \"little\" or \"big\"\n-         * - target_pointer_width: single value, \"32\" for 32-bit pointers, etc.\n-         * - target_vendor, single value\n-         * - test: set when testing is being done\n-         *  - again, seems similar to a \"is defined\" rather than \"is equal to\" like unix\n-         * - debug_assertions: seems to \"is defined\"\n-         * - proc_macro: no idea, bad docs. seems to be boolean, so maybe \"is defined\" */\n-    };\n-\n-    // Defines compiler options (e.g. dump, etc.).\n-    struct CompileOptions {\n-        // TODO: use bitfield for smaller memory requirements?\n-\n-        // FIXME: this is set up for \"instead of\" dumping - in future, dumps should not inhibit\n-        // compilation\n-        enum DumpOptions {\n-            NO_DUMP,\n-            LEXER_DUMP,\n-            PARSER_AST_DUMP,\n-            REGISTER_PLUGINS_DUMP,\n-            INJECTION_DUMP,\n-            EXPANSION_DUMP,\n-            NAME_RESOLUTION_DUMP,\n-            // TODO: add more?\n-        } dump_option;\n-\n-        // configuration options - actually useful for conditional compilation and whatever\n-        // data related to target arch, features, os, family, env, endian, pointer width, vendor\n-        TargetOptions target_data;\n-        bool enable_test = false;\n-        bool debug_assertions = false;\n-        bool proc_macro = false;\n-    };\n-\n-    /* Defines a compiler session. This is for a single compiler invocation, so potentially includes\n-     * parsing multiple crates. */\n-    struct Session {\n-        CompileOptions options;\n-        // This should really be in a per-crate storage area but it is wiped with every file so eh.\n-        ::std::string injected_crate_name;\n-\n-        // backend wrapper to GCC GENERIC\n-        Backend* backend;\n-\n-        // backend linemap\n-        Linemap* linemap;\n-\n-        // TODO: replace raw pointers with smart pointers?\n-\n-      public:\n-        /* Initialise compiler session. Corresponds to langhook grs_langhook_init(). Note that this is\n-         * called after option handling. */\n-        void init();\n-        bool handle_option(enum opt_code code, const char* arg, HOST_WIDE_INT value, int kind,\n-          location_t loc, const struct cl_option_handlers* handlers);\n-        void parse_files(int num_files, const char** files);\n-        void init_options();\n-\n-      private:\n-        // TODO: should this be private or public?\n-        void parse_file(const char* filename);\n-        bool enable_dump(::std::string arg);\n-\n-        void debug_dump_load_crates(Parser& parser);\n-\n-        void implicitly_enable_feature(::std::string feature_name);\n-        void enable_features();\n-\n-        // pipeline stages - TODO maybe move?\n-        /* Register plugins pipeline stage. TODO maybe move to another object? Currently dummy stage.\n-         * In future will handle attribute injection (top-level inner attribute creation from command\n-         * line arguments), setting options maybe, registering lints maybe, loading plugins maybe. */\n-        void register_plugins(AST::Crate& crate);\n-        /* Injection pipeline stage. TODO maybe move to another object? Maybe have some lint checks\n-         * (in future, obviously), register builtin macros, crate injection. */\n-        void injection(AST::Crate& crate);\n-        /* Expansion pipeline stage. TODO maybe move to another object? Expands all macros, maybe\n-         * build test harness in future, AST validation, maybe create macro crate (if not rustdoc).*/\n-        void expansion(AST::Crate& crate);\n-        /* Name resolution pipeline stage. TODO maybe move to another object. Performs name\n-         * resolution, maybe complete gated feature checking, maybe create buffered lints in future.\n-         */\n-        void name_resolution(AST::Crate& crate);\n-    };\n+// parser forward decl\n+class Parser;\n+// crate forward decl\n+namespace AST {\n+struct Crate;\n }\n \n+// Data related to target, most useful for conditional compilation and whatever.\n+struct TargetOptions\n+{\n+  // TODO: maybe make private and access through helpers to allow changes to\n+  // impl\n+  std::unordered_map<std::string, std::unordered_set<std::string> > features;\n+\n+public:\n+  // Returns whether a key is defined in the feature set.\n+  bool has_key (std::string key) const\n+  {\n+    return features.find (key) != features.end ();\n+  }\n+\n+  // Returns whether a key exists with the given value in the feature set.\n+  bool has_key_value_pair (std::string key, std::string value) const\n+  {\n+    auto it = features.find (key);\n+    if (it != features.end ())\n+      {\n+\tauto set = it->second;\n+\tauto it2 = set.find (value);\n+\tif (it2 != set.end ())\n+\t  return true;\n+      }\n+    return false;\n+  }\n+\n+  // Returns the singular value from the key, or if the key has multiple, an\n+  // empty string.\n+  std::string get_singular_value (std::string key) const\n+  {\n+    auto it = features.find (key);\n+    if (it != features.end ())\n+      {\n+\tauto set = it->second;\n+\tif (set.size () == 1)\n+\t  return *set.begin ();\n+      }\n+    return \"\";\n+  }\n+\n+  // Returns all values associated with a key (including none), or an empty set\n+  // if no key is found.\n+  std::unordered_set< ::std::string> get_values_for_key (std::string key) const\n+  {\n+    auto it = features.find (key);\n+    if (it != features.end ())\n+      {\n+\treturn it->second;\n+      }\n+    return {};\n+  }\n+\n+  /* Inserts a key (no value) into the feature set. This will do nothing if the\n+   * key already exists.\n+   * This returns whether the insertion was successful (i.e. whether key already\n+   * existed). */\n+  bool insert_key (std::string key)\n+  {\n+    return features\n+      .insert (std::make_pair (key, std::unordered_set<std::string> ()))\n+      .second;\n+  }\n+\n+  // Inserts a key-value pair into the feature set.\n+  void insert_key_value_pair (std::string key, std::string value)\n+  {\n+    auto existing_set = get_values_for_key (key);\n+    existing_set.insert (std::move (value));\n+    features[std::move (key)] = std::move (existing_set);\n+  }\n+\n+  /* According to reference, Rust uses either multi-map key-values or just\n+   * values (although values may be aliases for a key-value value). This seems\n+   * like overkill. Thus, depending on whether the attributes used in cfg are\n+   * fixed or not, I think I'll either put each non-multimap \"key-value\" as a\n+   * separate field and have the multimap \"key-values\" in a regular map for that\n+   * one key, or actually use a multimap.\n+   *\n+   * rustc itself uses a set of key-value tuples where the second tuple element\n+   * is optional. This gets rid of the requirement to make a multi-map, I guess,\n+   * but seems like it might make\n+   * search slow (unless all \"is defined\"-only ones have empty string as second\n+   * element). */\n+  /* cfg attributes:\n+   * - target_arch: single value\n+   * - target_feature: multiple values possible\n+   * - target_os: single value\n+   * - target_family: single value (or no value?)\n+   * - unix: set when target_family = \"unix\"\n+   * - windows: set when target_family = \"windows\"\n+   *  - if these are just syntactic sugar, then maybe have a separate set or map\n+   * for this kind of stuff\n+   * - target_env: set when needed for disambiguation about ABI - usually empty\n+   * string for GNU, complicated\n+   *  - seems to be a single value (if any)\n+   * - target_endian: single value; \"little\" or \"big\"\n+   * - target_pointer_width: single value, \"32\" for 32-bit pointers, etc.\n+   * - target_vendor, single value\n+   * - test: set when testing is being done\n+   *  - again, seems similar to a \"is defined\" rather than \"is equal to\" like\n+   * unix\n+   * - debug_assertions: seems to \"is defined\"\n+   * - proc_macro: no idea, bad docs. seems to be boolean, so maybe \"is defined\"\n+   */\n+};\n+\n+// Defines compiler options (e.g. dump, etc.).\n+struct CompileOptions\n+{\n+  // TODO: use bitfield for smaller memory requirements?\n+\n+  // FIXME: this is set up for \"instead of\" dumping - in future, dumps should\n+  // not inhibit compilation\n+  enum DumpOptions\n+  {\n+    NO_DUMP,\n+    LEXER_DUMP,\n+    PARSER_AST_DUMP,\n+    REGISTER_PLUGINS_DUMP,\n+    INJECTION_DUMP,\n+    EXPANSION_DUMP,\n+    NAME_RESOLUTION_DUMP,\n+    // TODO: add more?\n+  } dump_option;\n+\n+  // configuration options - actually useful for conditional compilation and\n+  // whatever data related to target arch, features, os, family, env, endian,\n+  // pointer width, vendor\n+  TargetOptions target_data;\n+  bool enable_test = false;\n+  bool debug_assertions = false;\n+  bool proc_macro = false;\n+};\n+\n+/* Defines a compiler session. This is for a single compiler invocation, so\n+ * potentially includes parsing multiple crates. */\n+struct Session\n+{\n+  CompileOptions options;\n+  // This should really be in a per-crate storage area but it is wiped with\n+  // every file so eh.\n+  ::std::string injected_crate_name;\n+\n+  // backend wrapper to GCC GENERIC\n+  Backend *backend;\n+\n+  // backend linemap\n+  Linemap *linemap;\n+\n+  // TODO: replace raw pointers with smart pointers?\n+\n+public:\n+  /* Initialise compiler session. Corresponds to langhook grs_langhook_init().\n+   * Note that this is called after option handling. */\n+  void init ();\n+  bool handle_option (enum opt_code code, const char *arg, HOST_WIDE_INT value,\n+\t\t      int kind, location_t loc,\n+\t\t      const struct cl_option_handlers *handlers);\n+  void parse_files (int num_files, const char **files);\n+  void init_options ();\n+\n+private:\n+  // TODO: should this be private or public?\n+  void parse_file (const char *filename);\n+  bool enable_dump (::std::string arg);\n+\n+  void debug_dump_load_crates (Parser &parser);\n+\n+  void implicitly_enable_feature (::std::string feature_name);\n+  void enable_features ();\n+\n+  // pipeline stages - TODO maybe move?\n+  /* Register plugins pipeline stage. TODO maybe move to another object?\n+   * Currently dummy stage. In future will handle attribute injection (top-level\n+   * inner attribute creation from command line arguments), setting options\n+   * maybe, registering lints maybe, loading plugins maybe. */\n+  void register_plugins (AST::Crate &crate);\n+  /* Injection pipeline stage. TODO maybe move to another object? Maybe have\n+   * some lint checks (in future, obviously), register builtin macros, crate\n+   * injection. */\n+  void injection (AST::Crate &crate);\n+  /* Expansion pipeline stage. TODO maybe move to another object? Expands all\n+   * macros, maybe build test harness in future, AST validation, maybe create\n+   * macro crate (if not rustdoc).*/\n+  void expansion (AST::Crate &crate);\n+  /* Name resolution pipeline stage. TODO maybe move to another object. Performs\n+   * name resolution, maybe complete gated feature checking, maybe create\n+   * buffered lints in future.\n+   */\n+  void name_resolution (AST::Crate &crate);\n+};\n+} // namespace Rust\n+\n #endif"}, {"sha": "da2454a1d92baed874f8319dcada75de35d732ea", "filename": "gcc/rust/rust-system.h", "status": "modified", "additions": 50, "deletions": 58, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Frust-system.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Frust-system.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-system.h?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -1,5 +1,5 @@\n // rust-system.h -- Rust frontend inclusion of gcc header files   -*- C++ -*-\n-// Copyright (C) 2009-2019 Free Software Foundation, Inc.\n+// Copyright (C) 2009-2020 Free Software Foundation, Inc.\n \n // This file is part of GCC.\n \n@@ -41,94 +41,84 @@\n #include <deque>\n #include <functional>\n \n-/* TODO: strictly speaking, as AST move semantics make frontend C++11-and-up only, unordered map should\n- * always be definable (i.e. don't have to resort to tr1 like in C++03), so don't need to have this\n- * macro switch - just include <unordered_map> and <unordered_set>. */\n+/* TODO: strictly speaking, as AST move semantics make frontend C++11-and-up\n+ * only, unordered map should always be definable (i.e. don't have to resort to\n+ * tr1 like in C++03), so don't need to have this macro switch - just include\n+ * <unordered_map> and <unordered_set>. */\n #if defined(HAVE_UNORDERED_MAP)\n \n-# include <unordered_map>\n-# include <unordered_set>\n+#include <unordered_map>\n+#include <unordered_set>\n \n-# define Unordered_map(KEYTYPE, VALTYPE) \\\n-\tstd::unordered_map<KEYTYPE, VALTYPE>\n+#define Unordered_map(KEYTYPE, VALTYPE) std::unordered_map<KEYTYPE, VALTYPE>\n \n-# define Unordered_map_hash(KEYTYPE, VALTYPE, HASHFN, EQFN) \\\n-\tstd::unordered_map<KEYTYPE, VALTYPE, HASHFN, EQFN>\n+#define Unordered_map_hash(KEYTYPE, VALTYPE, HASHFN, EQFN)                     \\\n+  std::unordered_map<KEYTYPE, VALTYPE, HASHFN, EQFN>\n \n-# define Unordered_set(KEYTYPE) \\\n-\tstd::unordered_set<KEYTYPE>\n+#define Unordered_set(KEYTYPE) std::unordered_set<KEYTYPE>\n \n-# define Unordered_set_hash(KEYTYPE, HASHFN, EQFN) \\\n-\tstd::unordered_set<KEYTYPE, HASHFN, EQFN>\n+#define Unordered_set_hash(KEYTYPE, HASHFN, EQFN)                              \\\n+  std::unordered_set<KEYTYPE, HASHFN, EQFN>\n \n #elif defined(HAVE_TR1_UNORDERED_MAP)\n \n-# include <tr1/unordered_map>\n-# include <tr1/unordered_set>\n+#include <tr1/unordered_map>\n+#include <tr1/unordered_set>\n \n-# define Unordered_map(KEYTYPE, VALTYPE) \\\n-\tstd::tr1::unordered_map<KEYTYPE, VALTYPE>\n+#define Unordered_map(KEYTYPE, VALTYPE)                                        \\\n+  std::tr1::unordered_map<KEYTYPE, VALTYPE>\n \n-# define Unordered_map_hash(KEYTYPE, VALTYPE, HASHFN, EQFN) \\\n-\tstd::tr1::unordered_map<KEYTYPE, VALTYPE, HASHFN, EQFN>\n+#define Unordered_map_hash(KEYTYPE, VALTYPE, HASHFN, EQFN)                     \\\n+  std::tr1::unordered_map<KEYTYPE, VALTYPE, HASHFN, EQFN>\n \n-# define Unordered_set(KEYTYPE) \\\n-\tstd::tr1::unordered_set<KEYTYPE>\n+#define Unordered_set(KEYTYPE) std::tr1::unordered_set<KEYTYPE>\n \n-# define Unordered_set_hash(KEYTYPE, HASHFN, EQFN) \\\n-\tstd::tr1::unordered_set<KEYTYPE, HASHFN, EQFN>\n+#define Unordered_set_hash(KEYTYPE, HASHFN, EQFN)                              \\\n+  std::tr1::unordered_set<KEYTYPE, HASHFN, EQFN>\n \n #elif defined(HAVE_EXT_HASH_MAP)\n \n-# include <ext/hash_map>\n-# include <ext/hash_set>\n+#include <ext/hash_map>\n+#include <ext/hash_set>\n \n-# define Unordered_map(KEYTYPE, VALTYPE) \\\n-\t__gnu_cxx::hash_map<KEYTYPE, VALTYPE>\n+#define Unordered_map(KEYTYPE, VALTYPE) __gnu_cxx::hash_map<KEYTYPE, VALTYPE>\n \n-# define Unordered_map_hash(KEYTYPE, VALTYPE, HASHFN, EQFN) \\\n-\t__gnu_cxx::hash_map<KEYTYPE, VALTYPE, HASHFN, EQFN>\n+#define Unordered_map_hash(KEYTYPE, VALTYPE, HASHFN, EQFN)                     \\\n+  __gnu_cxx::hash_map<KEYTYPE, VALTYPE, HASHFN, EQFN>\n \n-# define Unordered_set(KEYTYPE) \\\n-\t__gnu_cxx::hash_set<KEYTYPE>\n+#define Unordered_set(KEYTYPE) __gnu_cxx::hash_set<KEYTYPE>\n \n-# define Unordered_set_hash(KEYTYPE, HASHFN, EQFN) \\\n-\t__gnu_cxx::hash_set<KEYTYPE, HASHFN, EQFN>\n+#define Unordered_set_hash(KEYTYPE, HASHFN, EQFN)                              \\\n+  __gnu_cxx::hash_set<KEYTYPE, HASHFN, EQFN>\n \n // Provide hash functions for strings and pointers.\n \n-namespace __gnu_cxx\n-{\n+namespace __gnu_cxx {\n \n-template<>\n-struct hash<std::string>\n+template <> struct hash<std::string>\n {\n-  size_t\n-  operator()(std::string s) const\n-  { return __stl_hash_string(s.c_str()); }\n+  size_t operator() (std::string s) const\n+  {\n+    return __stl_hash_string (s.c_str ());\n+  }\n };\n \n-template<typename T>\n-struct hash<T*>\n+template <typename T> struct hash<T *>\n {\n-  size_t\n-  operator()(T* p) const\n-  { return reinterpret_cast<size_t>(p); }\n+  size_t operator() (T *p) const { return reinterpret_cast<size_t> (p); }\n };\n \n-}\n+} // namespace __gnu_cxx\n \n #else\n \n-# define Unordered_map(KEYTYPE, VALTYPE) \\\n-\tstd::map<KEYTYPE, VALTYPE>\n+#define Unordered_map(KEYTYPE, VALTYPE) std::map<KEYTYPE, VALTYPE>\n \n-# define Unordered_set(KEYTYPE) \\\n-\tstd::set<KEYTYPE>\n+#define Unordered_set(KEYTYPE) std::set<KEYTYPE>\n \n // We could make this work by writing an adapter class which\n // implemented operator< in terms of the hash function.\n-# error \"requires hash table type\"\n+#error \"requires hash table type\"\n \n #endif\n \n@@ -142,17 +132,19 @@ struct hash<T*>\n #include \"ansidecl.h\"\n #include \"coretypes.h\"\n \n-#include \"diagnostic-core.h\"\t/* For error_at and friends.  */\n-#include \"intl.h\"\t\t/* For _().  */\n+#include \"diagnostic-core.h\" /* For error_at and friends.  */\n+#include \"intl.h\"\t    /* For _().  */\n \n // When using gcc, rust_assert is just gcc_assert.\n-#define rust_assert(EXPR) gcc_assert(EXPR)\n+#define rust_assert(EXPR) gcc_assert (EXPR)\n \n // When using gcc, rust_unreachable is just gcc_unreachable.\n-#define rust_unreachable() gcc_unreachable()\n+#define rust_unreachable() gcc_unreachable ()\n \n-extern void rust_preserve_from_gc (tree t);\n+extern void\n+rust_preserve_from_gc (tree t);\n \n-extern const char* rust_localize_identifier (const char *ident);\n+extern const char *\n+rust_localize_identifier (const char *ident);\n \n #endif // !defined(RUST_SYSTEM_H)"}, {"sha": "28c2d9a38fe0369563ace694741faeb5b63450d3", "filename": "gcc/rust/rustspec.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Frustspec.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7266d66d2321562ef74daf90ffb1ad70d081d890/gcc%2Frust%2Frustspec.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustspec.cc?ref=7266d66d2321562ef74daf90ffb1ad70d081d890", "patch": "@@ -1,5 +1,5 @@\n /* rustspec.c -- Specific flags and argument handling of the gcc Go front end.\n-   Copyright (C) 2009-2019 Free Software Foundation, Inc.\n+   Copyright (C) 2009-2020 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -340,7 +340,7 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n   if (library > 0)\n     {\n       // generate_option (OPT_l, LIBGOBEGIN, 1, CL_DRIVER,\n-      //   \t       &new_decoded_options[j]);\n+      //               &new_decoded_options[j]);\n       // added_libraries++;\n       // j++;\n "}]}