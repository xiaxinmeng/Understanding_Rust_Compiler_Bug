{"sha": "7f6cd86bef0d942ca6e4d7a38f942cd38daaff95", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Y2Y2Q4NmJlZjBkOTQyY2E2ZTRkN2EzOGY5NDJjZDM4ZGFhZmY5NQ==", "commit": {"author": {"name": "Chung-Ju Wu", "email": "jasonwucj@gmail.com", "date": "2014-09-03T09:55:28Z"}, "committer": {"name": "Chung-Ju Wu", "email": "jasonwucj@gcc.gnu.org", "date": "2014-09-03T09:55:28Z"}, "message": "[NDS32] Deal with nameless arguments in nds32_function_arg and nds32_function_arg_advance.\n\n  1. We have caller prepare nameless arguments in the way of calling a normal function.\n\n     e.g. Assume a function: void va_test (int n, ...);\n          When calling \"va_test (6, 11, 22, 33, 44, 55, 66);\",\n               r0    <- 6\n               r1    <- 11\n               r2    <- 22\n               r3    <- 33\n               r4    <- 44\n               r5    <- 55\n            [sp + 0] <- 66\n\n  2. Note that we DO NOT handle it for TARGET_HARD_FLOAT case.\n     The TARGET_HARD_FLOAT should push all the nameless arguments into\n     stack and GCC is able to take care of them itself.\n     In addition, we have not implemented hard float on trunk yet.\n\n\t* config/nds32/nds32.c (nds32_function_arg): Deal with nameless\n\targuments.\n\t(nds32_function_arg_advance): Deal with nameless arguments.\n\t* config/nds32/nds32.h (NDS32_ARG_PASS_IN_REG_P): Split it into ...\n\t(NDS32_ARG_ENTIRE_IN_GPR_REG_P): ... this one and ...\n\t(NDS32_ARG_PARTIAL_IN_GPR_REG_P): ... this one.\n\nFrom-SVN: r214865", "tree": {"sha": "84c7d09e05d0df11d11b81726f282263ee893fbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84c7d09e05d0df11d11b81726f282263ee893fbf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f6cd86bef0d942ca6e4d7a38f942cd38daaff95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f6cd86bef0d942ca6e4d7a38f942cd38daaff95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f6cd86bef0d942ca6e4d7a38f942cd38daaff95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f6cd86bef0d942ca6e4d7a38f942cd38daaff95/comments", "author": {"login": "jasonwucj", "id": 5520732, "node_id": "MDQ6VXNlcjU1MjA3MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/5520732?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jasonwucj", "html_url": "https://github.com/jasonwucj", "followers_url": "https://api.github.com/users/jasonwucj/followers", "following_url": "https://api.github.com/users/jasonwucj/following{/other_user}", "gists_url": "https://api.github.com/users/jasonwucj/gists{/gist_id}", "starred_url": "https://api.github.com/users/jasonwucj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jasonwucj/subscriptions", "organizations_url": "https://api.github.com/users/jasonwucj/orgs", "repos_url": "https://api.github.com/users/jasonwucj/repos", "events_url": "https://api.github.com/users/jasonwucj/events{/privacy}", "received_events_url": "https://api.github.com/users/jasonwucj/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "52e4630c51f511137b0018fe9f5661182fd5e668", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52e4630c51f511137b0018fe9f5661182fd5e668", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52e4630c51f511137b0018fe9f5661182fd5e668"}], "stats": {"total": 122, "additions": 99, "deletions": 23}, "files": [{"sha": "d91d826c97579eb3546547ca6f30ccea49a996e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f6cd86bef0d942ca6e4d7a38f942cd38daaff95/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f6cd86bef0d942ca6e4d7a38f942cd38daaff95/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7f6cd86bef0d942ca6e4d7a38f942cd38daaff95", "patch": "@@ -1,3 +1,12 @@\n+2014-09-03  Chung-Ju Wu  <jasonwucj@gmail.com>\n+\n+\t* config/nds32/nds32.c (nds32_function_arg): Deal with nameless\n+\targuments.\n+\t(nds32_function_arg_advance): Deal with nameless arguments.\n+\t* config/nds32/nds32.h (NDS32_ARG_PASS_IN_REG_P): Split it into ...\n+\t(NDS32_ARG_ENTIRE_IN_GPR_REG_P): ... this one and ...\n+\t(NDS32_ARG_PARTIAL_IN_GPR_REG_P): ... this one.\n+\n 2014-09-03  Richard Biener  <rguenther@suse.de>\n \n \t* tree-ssa-pre.c (alloc_expression_id): Use quick_grow_cleared."}, {"sha": "509b4a5bfc519ab142cd71d2a609bf7126866963", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 77, "deletions": 18, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f6cd86bef0d942ca6e4d7a38f942cd38daaff95/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f6cd86bef0d942ca6e4d7a38f942cd38daaff95/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=7f6cd86bef0d942ca6e4d7a38f942cd38daaff95", "patch": "@@ -1294,48 +1294,107 @@ static rtx\n nds32_function_arg (cumulative_args_t ca, enum machine_mode mode,\n \t\t    const_tree type, bool named)\n {\n+  unsigned int regno;\n   CUMULATIVE_ARGS *cum = get_cumulative_args (ca);\n \n   /* The last time this hook is called,\n      it is called with MODE == VOIDmode.  */\n   if (mode == VOIDmode)\n     return NULL_RTX;\n \n-  /* For nameless arguments, they are passed on the stack.  */\n+  /* For nameless arguments, we need to take care it individually.  */\n   if (!named)\n-    return NULL_RTX;\n-\n-  /* If there are still registers available, return it.  */\n-  if (NDS32_ARG_PASS_IN_REG_P (cum->gpr_offset, mode, type))\n     {\n-      /* Pick up the next available register number.  */\n-      unsigned int regno;\n+      /* If we are under hard float abi, we have arguments passed on the\n+         stack and all situation can be handled by GCC itself.  */\n+      if (TARGET_HARD_FLOAT)\n+\treturn NULL_RTX;\n+\n+      if (NDS32_ARG_PARTIAL_IN_GPR_REG_P (cum->gpr_offset, mode, type))\n+\t{\n+\t  /* If we still have enough registers to pass argument, pick up\n+\t     next available register number.  */\n+\t  regno\n+\t    = NDS32_AVAILABLE_REGNUM_FOR_GPR_ARG (cum->gpr_offset, mode, type);\n+\t  return gen_rtx_REG (mode, regno);\n+\t}\n \n-      regno = NDS32_AVAILABLE_REGNUM_FOR_GPR_ARG (cum->gpr_offset, mode, type);\n-      return gen_rtx_REG (mode, regno);\n-    }\n-  else\n-    {\n       /* No register available, return NULL_RTX.\n          The compiler will use stack to pass argument instead.  */\n       return NULL_RTX;\n     }\n+\n+  /* The following is to handle named argument.\n+     Note that the strategies of TARGET_HARD_FLOAT and !TARGET_HARD_FLOAT\n+     are different.  */\n+  if (TARGET_HARD_FLOAT)\n+    {\n+      /* Currently we have not implemented hard float yet.  */\n+      gcc_unreachable ();\n+    }\n+  else\n+    {\n+      /* For !TARGET_HARD_FLOAT calling convention, we always use GPR to pass\n+         argument.  Since we allow to pass argument partially in registers,\n+         we can just return it if there are still registers available.  */\n+      if (NDS32_ARG_PARTIAL_IN_GPR_REG_P (cum->gpr_offset, mode, type))\n+\t{\n+\t  /* Pick up the next available register number.  */\n+\t  regno\n+\t    = NDS32_AVAILABLE_REGNUM_FOR_GPR_ARG (cum->gpr_offset, mode, type);\n+\t  return gen_rtx_REG (mode, regno);\n+\t}\n+\n+    }\n+\n+  /* No register available, return NULL_RTX.\n+     The compiler will use stack to pass argument instead.  */\n+  return NULL_RTX;\n }\n \n static void\n nds32_function_arg_advance (cumulative_args_t ca, enum machine_mode mode,\n \t\t\t    const_tree type, bool named)\n {\n+  enum machine_mode sub_mode;\n   CUMULATIVE_ARGS *cum = get_cumulative_args (ca);\n \n-  /* Advance next register for use.\n-     Only named argument could be advanced.  */\n   if (named)\n     {\n-      cum->gpr_offset\n-\t= NDS32_AVAILABLE_REGNUM_FOR_GPR_ARG (cum->gpr_offset, mode, type)\n-\t  - NDS32_GPR_ARG_FIRST_REGNUM\n-\t  + NDS32_NEED_N_REGS_FOR_ARG (mode, type);\n+      /* We need to further check TYPE and MODE so that we can determine\n+         which kind of register we shall advance.  */\n+      if (type && TREE_CODE (type) == COMPLEX_TYPE)\n+\tsub_mode = TYPE_MODE (TREE_TYPE (type));\n+      else\n+\tsub_mode = mode;\n+\n+      /* Under hard float abi, we may advance FPR registers.  */\n+      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (sub_mode) == MODE_FLOAT)\n+\t{\n+\t  /* Currently we have not implemented hard float yet.  */\n+\t  gcc_unreachable ();\n+\t}\n+      else\n+\t{\n+\t  cum->gpr_offset\n+\t    = NDS32_AVAILABLE_REGNUM_FOR_GPR_ARG (cum->gpr_offset, mode, type)\n+\t      - NDS32_GPR_ARG_FIRST_REGNUM\n+\t      + NDS32_NEED_N_REGS_FOR_ARG (mode, type);\n+\t}\n+    }\n+  else\n+    {\n+      /* If this nameless argument is NOT under TARGET_HARD_FLOAT,\n+         we can advance next register as well so that caller is\n+         able to pass arguments in registers and callee must be\n+         in charge of pushing all of them into stack.  */\n+      if (!TARGET_HARD_FLOAT)\n+\t{\n+\t  cum->gpr_offset\n+\t    = NDS32_AVAILABLE_REGNUM_FOR_GPR_ARG (cum->gpr_offset, mode, type)\n+\t      - NDS32_GPR_ARG_FIRST_REGNUM\n+\t      + NDS32_NEED_N_REGS_FOR_ARG (mode, type);\n+\t}\n     }\n }\n "}, {"sha": "920b992b1ca9e0ba19c42213193e57dc5a45ad0e", "filename": "gcc/config/nds32/nds32.h", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f6cd86bef0d942ca6e4d7a38f942cd38daaff95/gcc%2Fconfig%2Fnds32%2Fnds32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f6cd86bef0d942ca6e4d7a38f942cd38daaff95/gcc%2Fconfig%2Fnds32%2Fnds32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.h?ref=7f6cd86bef0d942ca6e4d7a38f942cd38daaff95", "patch": "@@ -166,11 +166,19 @@ enum nds32_16bit_address_type\n    : ((reg_offset) + NDS32_GPR_ARG_FIRST_REGNUM))\n \n /* This macro is to check if there are still available registers\n-   for passing argument.  */\n-#define NDS32_ARG_PASS_IN_REG_P(reg_offset, mode, type)      \\\n-  (((reg_offset) < NDS32_MAX_GPR_REGS_FOR_ARGS)              \\\n-   && ((reg_offset) + NDS32_NEED_N_REGS_FOR_ARG (mode, type) \\\n-       <= NDS32_MAX_GPR_REGS_FOR_ARGS))\n+   for passing argument, which must be entirely in registers.  */\n+#define NDS32_ARG_ENTIRE_IN_GPR_REG_P(reg_offset, mode, type)   \\\n+  ((NDS32_AVAILABLE_REGNUM_FOR_GPR_ARG (reg_offset, mode, type) \\\n+    + NDS32_NEED_N_REGS_FOR_ARG (mode, type))                   \\\n+   <= (NDS32_GPR_ARG_FIRST_REGNUM                               \\\n+       + NDS32_MAX_GPR_REGS_FOR_ARGS))\n+\n+/* This macro is to check if there are still available registers\n+   for passing argument, either entirely in registers or partially\n+   in registers.  */\n+#define NDS32_ARG_PARTIAL_IN_GPR_REG_P(reg_offset, mode, type) \\\n+  (NDS32_AVAILABLE_REGNUM_FOR_GPR_ARG (reg_offset, mode, type) \\\n+   < NDS32_GPR_ARG_FIRST_REGNUM + NDS32_MAX_GPR_REGS_FOR_ARGS)\n \n /* This macro is to check if the register is required to be saved on stack.\n    If call_used_regs[regno] == 0, regno is the callee-saved register."}]}