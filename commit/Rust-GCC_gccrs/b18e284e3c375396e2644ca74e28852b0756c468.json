{"sha": "b18e284e3c375396e2644ca74e28852b0756c468", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE4ZTI4NGUzYzM3NTM5NmUyNjQ0Y2E3NGUyODg1MmIwNzU2YzQ2OA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2007-06-12T14:35:13Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2007-06-12T14:35:13Z"}, "message": "bfin.md (UNSPEC_NOP): New constant.\n\n\t* config/bfin/bfin.md (UNSPEC_NOP): New constant.\n\t(forced_nop): New pattern.\n\t* config/bfin/bfin.c: Include \"df.h\".\n\t(add_to_reg): Use df_regs_ever_live_p instead of regs_ever_live.\n\t(bfin_discover_loop): Use df_get_live_in instead of\n\tglobal_live_at_start.\n\t(bfin_reorder_loops): Pass 0 to cfg_layout_initialize.  Call\n\tdf_analyze when done.\n\t(gen_one_bundle): Don't generate SEQUENCE insns, just put modes on\n\tthe insns.  Use QImode for the final insn in a bundle.  Call\n\tdf_insn_rescan on generated NOPs; use gen_forced_nop instead of\n\tgen_nop.\n\t(reorder_var_tracking_notes): New function.\n\t(bfin_reorg): Pass no argument to split_all_insns.  Don't call\n\tupdate_life_info.  Call df_analyze after scheduling and bundle\n\tgeneration.  Call reorder_var_tracking_notes if generating these notes.\n\tCall df_finish_pass at the end.\n\nFrom-SVN: r125648", "tree": {"sha": "82730146ed366479bd3a679168528be660164548", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82730146ed366479bd3a679168528be660164548"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b18e284e3c375396e2644ca74e28852b0756c468", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b18e284e3c375396e2644ca74e28852b0756c468", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b18e284e3c375396e2644ca74e28852b0756c468", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b18e284e3c375396e2644ca74e28852b0756c468/comments", "author": null, "committer": null, "parents": [{"sha": "8c8fa92702f267ebb54c4351b9dfd91977fddd46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c8fa92702f267ebb54c4351b9dfd91977fddd46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c8fa92702f267ebb54c4351b9dfd91977fddd46"}], "stats": {"total": 123, "additions": 102, "deletions": 21}, "files": [{"sha": "8d476fd81ad89aa0340be9a236053aa9ddba4bd6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b18e284e3c375396e2644ca74e28852b0756c468/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b18e284e3c375396e2644ca74e28852b0756c468/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b18e284e3c375396e2644ca74e28852b0756c468", "patch": "@@ -1,3 +1,23 @@\n+2007-06-12  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\t* config/bfin/bfin.md (UNSPEC_NOP): New constant.\n+\t(forced_nop): New pattern.\n+\t* config/bfin/bfin.c: Include \"df.h\".\n+\t(add_to_reg): Use df_regs_ever_live_p instead of regs_ever_live.\n+\t(bfin_discover_loop): Use df_get_live_in instead of\n+\tglobal_live_at_start.\n+\t(bfin_reorder_loops): Pass 0 to cfg_layout_initialize.  Call\n+\tdf_analyze when done.\n+\t(gen_one_bundle): Don't generate SEQUENCE insns, just put modes on\n+\tthe insns.  Use QImode for the final insn in a bundle.  Call\n+\tdf_insn_rescan on generated NOPs; use gen_forced_nop instead of\n+\tgen_nop.\n+\t(reorder_var_tracking_notes): New function.\n+\t(bfin_reorg): Pass no argument to split_all_insns.  Don't call\n+\tupdate_life_info.  Call df_analyze after scheduling and bundle\n+\tgeneration.  Call reorder_var_tracking_notes if generating these notes.\n+\tCall df_finish_pass at the end.\n+\n 2007-06-12  Dirk Mueller  <dmueller@suse.de>\n \n \t* trans-stmt.c (gfc_trans_call): fix gcc_assert to"}, {"sha": "968735f2a173f02be86545cd6f8aae4ec1859959", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 74, "deletions": 20, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b18e284e3c375396e2644ca74e28852b0756c468/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b18e284e3c375396e2644ca74e28852b0756c468/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=b18e284e3c375396e2644ca74e28852b0756c468", "patch": "@@ -54,6 +54,7 @@\n #include \"basic-block.h\"\n #include \"cfglayout.h\"\n #include \"timevar.h\"\n+#include \"df.h\"\n \n /* A C structure for machine-specific, per-function data.\n    This is added to the cfun structure.  */\n@@ -604,7 +605,7 @@ add_to_reg (rtx reg, HOST_WIDE_INT value, int frame, int epilogue_p)\n \t{\n \t  int i;\n \t  for (i = REG_P0; i <= REG_P5; i++)\n-\t    if ((regs_ever_live[i] && ! call_used_regs[i])\n+\t    if ((df_regs_ever_live_p (i) && ! call_used_regs[i])\n \t\t|| (!TARGET_FDPIC\n \t\t    && i == PIC_OFFSET_TABLE_REGNUM\n \t\t    && (current_function_uses_pic_offset_table\n@@ -3745,7 +3746,7 @@ bfin_discover_loop (loop_info loop, basic_block tail_bb, rtx tail_insn)\n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    {\n \t      basic_block succ = EDGE_SUCC (bb, ei.index)->dest;\n-\t      if (!REGNO_REG_SET_P (succ->il.rtl->global_live_at_start,\n+\t      if (!REGNO_REG_SET_P (df_get_live_in (succ),\n \t\t\t\t    REGNO (loop->iter_reg)))\n \t\tcontinue;\n \t      if (!VEC_space (basic_block, works, 1))\n@@ -3974,7 +3975,7 @@ bfin_reorder_loops (loop_info loops, FILE *dump_file)\n \n   FOR_EACH_BB (bb)\n     bb->aux = NULL;\n-  cfg_layout_initialize (CLEANUP_UPDATE_LIFE);\n+  cfg_layout_initialize (0);\n \n   for (loop = loops; loop; loop = loop->next)\n     {\n@@ -4026,6 +4027,7 @@ bfin_reorder_loops (loop_info loops, FILE *dump_file)\n \tbb->aux = NULL;\n     }\n   cfg_layout_finalize ();\n+  df_analyze ();\n }\n \n /* Run from machine_dependent_reorg, this pass looks for doloop_end insns\n@@ -4087,7 +4089,7 @@ bfin_reorg_loops (FILE *dump_file)\n static bool\n gen_one_bundle (rtx slot[3])\n {\n-  rtx bundle;\n+  rtx bundle, insn;\n \n   gcc_assert (slot[1] != NULL_RTX);\n \n@@ -4116,9 +4118,15 @@ gen_one_bundle (rtx slot[3])\n     }\n \n   if (slot[0] == NULL_RTX)\n-    slot[0] = emit_insn_before (gen_mnop (), slot[1]);\n+    {\n+      slot[0] = emit_insn_before (gen_mnop (), slot[1]);\n+      df_insn_rescan (slot[0]);\n+    }\n   if (slot[2] == NULL_RTX)\n-    slot[2] = emit_insn_after (gen_nop (), slot[1]);\n+    {\n+      slot[2] = emit_insn_after (gen_forced_nop (), slot[1]);\n+      df_insn_rescan (slot[2]);\n+    }\n \n   /* Avoid line number information being printed inside one bundle.  */\n   if (INSN_LOCATOR (slot[1])\n@@ -4131,17 +4139,8 @@ gen_one_bundle (rtx slot[3])\n   /* Terminate them with \"|| \" instead of \";\" in the output.  */\n   PUT_MODE (slot[0], SImode);\n   PUT_MODE (slot[1], SImode);\n-\n-  /* This is a cheat to avoid emit_insn's special handling of SEQUENCEs.\n-     Generating a PARALLEL first and changing its code later is the\n-     easiest way to emit a SEQUENCE insn.  */\n-  bundle = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (3, slot[0], slot[1], slot[2]));\n-  emit_insn_before (bundle, slot[0]);\n-  remove_insn (slot[0]);\n-  remove_insn (slot[1]);\n-  remove_insn (slot[2]);\n-  PUT_CODE (bundle, SEQUENCE);\n-  \n+  /* Terminate the bundle, for the benefit of reorder_var_tracking_notes.  */\n+  PUT_MODE (slot[2], QImode);\n   return true;\n }\n \n@@ -4199,6 +4198,7 @@ bfin_gen_bundles (void)\n \t\t    {\n \t\t      SET_SRC (pat) = XVECEXP (SET_SRC (pat), 0, 0);\n \t\t      INSN_CODE (slot[0]) = -1;\n+\t\t      df_insn_rescan (slot[0]);\n \t\t    }\n \t\t}\n \t      n_filled = 0;\n@@ -4209,6 +4209,58 @@ bfin_gen_bundles (void)\n \t}\n     }\n }\n+\n+/* Ensure that no var tracking notes are emitted in the middle of a\n+   three-instruction bundle.  */\n+\n+static void\n+reorder_var_tracking_notes (void)\n+{\n+  basic_block bb;\n+  FOR_EACH_BB (bb)\n+    {\n+      rtx insn, next;\n+      rtx queue = NULL_RTX;\n+      bool in_bundle = false;\n+\n+      for (insn = BB_HEAD (bb); insn != BB_END (bb); insn = next)\n+\t{\n+\t  next = NEXT_INSN (insn);\n+\n+\t  if (INSN_P (insn))\n+\t    {\n+\t      /* Emit queued up notes at the last instruction of a bundle.  */\n+\t      if (GET_MODE (insn) == QImode)\n+\t\t{\n+\t\t  while (queue)\n+\t\t    {\n+\t\t      rtx next_queue = PREV_INSN (queue);\n+\t\t      PREV_INSN (NEXT_INSN (insn)) = queue;\n+\t\t      NEXT_INSN (queue) = NEXT_INSN (insn);\n+\t\t      NEXT_INSN (insn) = queue;\n+\t\t      PREV_INSN (queue) = insn;\n+\t\t      queue = next_queue;\n+\t\t    }\n+\t\t  in_bundle = false;\n+\t\t}\n+\t      else if (GET_MODE (insn) == SImode)\n+\t\tin_bundle = true;\n+\t    }\n+\t  else if (NOTE_P (insn) && NOTE_KIND (insn) == NOTE_INSN_VAR_LOCATION)\n+\t    {\n+\t      if (in_bundle)\n+\t\t{\n+\t\t  rtx prev = PREV_INSN (insn);\n+\t\t  PREV_INSN (next) = prev;\n+\t\t  NEXT_INSN (prev) = next;\n+\n+\t\t  PREV_INSN (insn) = queue;\n+\t\t  queue = insn;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n \f\n /* Return an insn type for INSN that can be used by the caller for anomaly\n    workarounds.  This differs from plain get_attr_type in that it handles\n@@ -4290,11 +4342,9 @@ bfin_reorg (void)\n   if (bfin_flag_schedule_insns2)\n     {\n       splitting_for_sched = 1;\n-      split_all_insns (0);\n+      split_all_insns ();\n       splitting_for_sched = 0;\n \n-      update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES, PROP_DEATH_NOTES);\n-\n       timevar_push (TV_SCHED2);\n       schedule_insns ();\n       timevar_pop (TV_SCHED2);\n@@ -4304,6 +4354,8 @@ bfin_reorg (void)\n       bfin_gen_bundles ();\n     }\n \n+  df_analyze ();\n+\n   /* Doloop optimization */\n   if (cfun->machine->has_hardware_loops)\n     bfin_reorg_loops (dump_file);\n@@ -4451,8 +4503,10 @@ bfin_reorg (void)\n     {\n       timevar_push (TV_VAR_TRACKING);\n       variable_tracking_main ();\n+      reorder_var_tracking_notes ();\n       timevar_pop (TV_VAR_TRACKING);\n     }\n+  df_finish_pass ();\n }\n \f\n /* Handle interrupt_handler, exception_handler and nmi_handler function"}, {"sha": "1fafa881f7863de8eae649f3fedfee285b2338b3", "filename": "gcc/config/bfin/bfin.md", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b18e284e3c375396e2644ca74e28852b0756c468/gcc%2Fconfig%2Fbfin%2Fbfin.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b18e284e3c375396e2644ca74e28852b0756c468/gcc%2Fconfig%2Fbfin%2Fbfin.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.md?ref=b18e284e3c375396e2644ca74e28852b0756c468", "patch": "@@ -137,7 +137,8 @@\n    (UNSPEC_FUNCDESC_GOT17M4 9)\n    (UNSPEC_LSETUP_END 10)\n    ;; Distinguish a 32-bit version of an insn from a 16-bit version.\n-   (UNSPEC_32BIT 11)])\n+   (UNSPEC_32BIT 11)\n+   (UNSPEC_NOP 12)])\n \n (define_constants\n   [(UNSPEC_VOLATILE_EH_RETURN 0)\n@@ -2595,6 +2596,12 @@\n   \"\"\n   \"nop;\")\n \n+;; A nop which stays there when emitted.\n+(define_insn \"forced_nop\"\n+  [(unspec [(const_int 0)] UNSPEC_NOP)]\n+  \"\"\n+  \"nop;\")\n+\n (define_insn \"mnop\"\n   [(unspec [(const_int 0)] UNSPEC_32BIT)]\n   \"\""}]}