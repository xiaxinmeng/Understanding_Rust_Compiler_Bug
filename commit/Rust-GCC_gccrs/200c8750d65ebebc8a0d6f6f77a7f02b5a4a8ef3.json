{"sha": "200c8750d65ebebc8a0d6f6f77a7f02b5a4a8ef3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjAwYzg3NTBkNjVlYmViYzhhMGQ2ZjZmNzdhN2YwMmI1YTRhOGVmMw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-10-14T14:14:44Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-10-14T14:14:44Z"}, "message": "lto-symtab.c (lto_symtab_compatible): Fold in ...\n\n2009-10-14  Richard Guenther  <rguenther@suse.de>\n\n\t* lto-symtab.c (lto_symtab_compatible): Fold in ...\n\t(lto_symtab_merge): ... here.  Rewrite both to take the\n\tprevailing and a to-be-merged entry and to queue diagnostics\n\tproperly.\n\t(lto_symtab_resolve_replaceable_p): New predicate for\n\tsymbol resolution.\n\t(lto_symtab_resolve_can_prevail_p): Likewise.\n\t(lto_symtab_resolve_symbols): Rewrite.  Fold in code that\n\thandles merging commons by choosing the largest decl.  Fold\n\tin code that gives ODR errors.\n\t(lto_symtab_merge_decls_2): Simplify a lot.  Emit queued\n\tdiagnostics here.\n\t(lto_symtab_merge_decls_1): Re-structure.  Deal with the\n\tcase of no prevailing decl here.  Diagnose mismatches\n\tin object types here.  Drop all but the prevailing decls.\n\t(lto_symtab_prevailing_decl): Return the single prevailing decl.\n\t* lto-streamer-in.c (lto_input_tree_ref): Deal with\n\tVIEW_CONVERT_EXPRs in decl slots.  Unshare the tree in this case.\n\n\tlto/\n\t* lto.c (lto_fixup_tree): In case the prevailing decl is not\n\tcompatible with the one we replace wrap it around a\n\tVIEW_CONVERT_EXPR.\n\nFrom-SVN: r152768", "tree": {"sha": "3d83178500a3538048d92b6df95e7c2182d671f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d83178500a3538048d92b6df95e7c2182d671f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/200c8750d65ebebc8a0d6f6f77a7f02b5a4a8ef3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/200c8750d65ebebc8a0d6f6f77a7f02b5a4a8ef3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/200c8750d65ebebc8a0d6f6f77a7f02b5a4a8ef3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/200c8750d65ebebc8a0d6f6f77a7f02b5a4a8ef3/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "77ce724c6b608989a50dd9ae86264ee0eec1b46a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77ce724c6b608989a50dd9ae86264ee0eec1b46a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77ce724c6b608989a50dd9ae86264ee0eec1b46a"}], "stats": {"total": 804, "additions": 408, "deletions": 396}, "files": [{"sha": "db71cc7621420ae1ba0a7532d3198c4ef660c05e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200c8750d65ebebc8a0d6f6f77a7f02b5a4a8ef3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200c8750d65ebebc8a0d6f6f77a7f02b5a4a8ef3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=200c8750d65ebebc8a0d6f6f77a7f02b5a4a8ef3", "patch": "@@ -1,3 +1,24 @@\n+2009-10-14  Richard Guenther  <rguenther@suse.de>\n+\n+\t* lto-symtab.c (lto_symtab_compatible): Fold in ...\n+\t(lto_symtab_merge): ... here.  Rewrite both to take the\n+\tprevailing and a to-be-merged entry and to queue diagnostics\n+\tproperly.\n+\t(lto_symtab_resolve_replaceable_p): New predicate for\n+\tsymbol resolution.\n+\t(lto_symtab_resolve_can_prevail_p): Likewise.\n+\t(lto_symtab_resolve_symbols): Rewrite.  Fold in code that\n+\thandles merging commons by choosing the largest decl.  Fold\n+\tin code that gives ODR errors.\n+\t(lto_symtab_merge_decls_2): Simplify a lot.  Emit queued\n+\tdiagnostics here.\n+\t(lto_symtab_merge_decls_1): Re-structure.  Deal with the\n+\tcase of no prevailing decl here.  Diagnose mismatches\n+\tin object types here.  Drop all but the prevailing decls.\n+\t(lto_symtab_prevailing_decl): Return the single prevailing decl.\n+\t* lto-streamer-in.c (lto_input_tree_ref): Deal with\n+\tVIEW_CONVERT_EXPRs in decl slots.  Unshare the tree in this case.\n+\n 2009-10-14  Richard Guenther  <rguenther@suse.de>\n \n \tPR lto/41521"}, {"sha": "14b0c137f18543fce19d47bad95c3610ed399bb0", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200c8750d65ebebc8a0d6f6f77a7f02b5a4a8ef3/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200c8750d65ebebc8a0d6f6f77a7f02b5a4a8ef3/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=200c8750d65ebebc8a0d6f6f77a7f02b5a4a8ef3", "patch": "@@ -353,7 +353,16 @@ lto_input_tree_ref (struct lto_input_block *ib, struct data_in *data_in,\n       ix_u = lto_input_uleb128 (ib);\n       result = lto_file_decl_data_get_var_decl (data_in->file_data, ix_u);\n       if (tag == LTO_global_decl_ref)\n-\tvarpool_mark_needed_node (varpool_node (result));\n+\t{\n+\t  if (TREE_CODE (result) == VIEW_CONVERT_EXPR)\n+\t    {\n+\t      tree decl = TREE_OPERAND (result, 0);\n+\t      varpool_mark_needed_node (varpool_node (decl));\n+\t      result = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (result), decl);\n+\t    }\n+\t  else\n+\t    varpool_mark_needed_node (varpool_node (result));\n+\t}\n       break;\n \n     default:"}, {"sha": "b2fb9629943d943f02fac639530967e49d4e0e42", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 362, "deletions": 394, "changes": 756, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200c8750d65ebebc8a0d6f6f77a7f02b5a4a8ef3/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200c8750d65ebebc8a0d6f6f77a7f02b5a4a8ef3/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=200c8750d65ebebc8a0d6f6f77a7f02b5a4a8ef3", "patch": "@@ -109,6 +109,79 @@ lto_symtab_maybe_init_hash_table (void)\n \t\t     lto_symtab_entry_eq, NULL);\n }\n \n+/* Registers DECL with the LTO symbol table as having resolution RESOLUTION\n+   and read from FILE_DATA. */\n+\n+void\n+lto_symtab_register_decl (tree decl,\n+\t\t\t  ld_plugin_symbol_resolution_t resolution,\n+\t\t\t  struct lto_file_decl_data *file_data)\n+{\n+  lto_symtab_entry_t new_entry;\n+  void **slot;\n+\n+  /* Check that declarations reaching this function do not have\n+     properties inconsistent with having external linkage.  If any of\n+     these asertions fail, then the object file reader has failed to\n+     detect these cases and issue appropriate error messages.  */\n+  gcc_assert (decl\n+\t      && TREE_PUBLIC (decl)\n+\t      && (TREE_CODE (decl) == VAR_DECL\n+\t\t  || TREE_CODE (decl) == FUNCTION_DECL)\n+\t      && DECL_ASSEMBLER_NAME_SET_P (decl));\n+  if (TREE_CODE (decl) == VAR_DECL\n+      && DECL_INITIAL (decl))\n+    gcc_assert (!DECL_EXTERNAL (decl)\n+\t\t|| (TREE_STATIC (decl) && TREE_READONLY (decl)));\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    gcc_assert (!DECL_ABSTRACT (decl));\n+\n+  new_entry = GGC_CNEW (struct lto_symtab_entry_def);\n+  new_entry->id = DECL_ASSEMBLER_NAME (decl);\n+  new_entry->decl = decl;\n+  new_entry->resolution = resolution;\n+  new_entry->file_data = file_data;\n+\n+  lto_symtab_maybe_init_hash_table ();\n+  slot = htab_find_slot (lto_symtab_identifiers, new_entry, INSERT);\n+  new_entry->next = (lto_symtab_entry_t) *slot;\n+  *slot = new_entry;\n+}\n+\n+/* Get the lto_symtab_entry_def struct associated with ID\n+   if there is one.  */\n+\n+static lto_symtab_entry_t\n+lto_symtab_get (tree id)\n+{\n+  struct lto_symtab_entry_def temp;\n+  void **slot;\n+\n+  lto_symtab_maybe_init_hash_table ();\n+  temp.id = id;\n+  slot = htab_find_slot (lto_symtab_identifiers, &temp, NO_INSERT);\n+  return slot ? (lto_symtab_entry_t) *slot : NULL;\n+}\n+\n+/* Get the linker resolution for DECL.  */\n+\n+enum ld_plugin_symbol_resolution\n+lto_symtab_get_resolution (tree decl)\n+{\n+  lto_symtab_entry_t e;\n+\n+  gcc_assert (DECL_ASSEMBLER_NAME_SET_P (decl));\n+\n+  e = lto_symtab_get (DECL_ASSEMBLER_NAME (decl));\n+  while (e && e->decl != decl)\n+    e = e->next;\n+  if (!e)\n+    return LDPR_UNKNOWN;\n+\n+  return e->resolution;\n+}\n+\n+\n static bool maybe_merge_incomplete_and_complete_type (tree, tree);\n \n /* Try to merge an incomplete type INCOMPLETE with a complete type\n@@ -160,42 +233,75 @@ maybe_merge_incomplete_and_complete_type (tree type1, tree type2)\n   return res;\n }\n \n-/* Check if OLD_DECL and NEW_DECL are compatible. */\n+/* Replace the cgraph node NODE with PREVAILING_NODE in the cgraph, merging\n+   all edges and removing the old node.  */\n \n-static bool\n-lto_symtab_compatible (tree old_decl, tree new_decl)\n+static void\n+lto_cgraph_replace_node (struct cgraph_node *node,\n+\t\t\t struct cgraph_node *prevailing_node)\n {\n-  tree old_type, new_type;\n+  struct cgraph_edge *e, *next;\n \n-  if (TREE_CODE (old_decl) != TREE_CODE (new_decl))\n+  /* Merge node flags.  */\n+  if (node->needed)\n+    cgraph_mark_needed_node (prevailing_node);\n+  if (node->reachable)\n+    cgraph_mark_reachable_node (prevailing_node);\n+  if (node->address_taken)\n     {\n-      switch (TREE_CODE (new_decl))\n-\t{\n-\tcase VAR_DECL:\n-\t  gcc_assert (TREE_CODE (old_decl) == FUNCTION_DECL);\n-\t  error_at (DECL_SOURCE_LOCATION (new_decl),\n-\t\t    \"function %qD redeclared as variable\", new_decl);\n-\t  inform (DECL_SOURCE_LOCATION (old_decl),\n-\t\t  \"previously declared here\");\n-\t  return false;\n+      gcc_assert (!prevailing_node->global.inlined_to);\n+      cgraph_mark_address_taken_node (prevailing_node);\n+    }\n \n-\tcase FUNCTION_DECL:\n-\t  gcc_assert (TREE_CODE (old_decl) == VAR_DECL);\n-\t  error_at (DECL_SOURCE_LOCATION (new_decl),\n-\t\t    \"variable %qD redeclared as function\", new_decl);\n-\t  inform (DECL_SOURCE_LOCATION (old_decl),\n-\t\t  \"previously declared here\");\n-\t  return false;\n+  /* Redirect all incoming edges.  */\n+  for (e = node->callers; e; e = next)\n+    {\n+      next = e->next_caller;\n+      cgraph_redirect_edge_callee (e, prevailing_node);\n+    }\n \n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n+  /* There are not supposed to be any outgoing edges from a node we\n+     replace.  Still this can happen for multiple instances of weak\n+     functions.  */\n+  for (e = node->callees; e; e = next)\n+    {\n+      next = e->next_callee;\n+      cgraph_remove_edge (e);\n     }\n \n-  if (TREE_CODE (new_decl) == FUNCTION_DECL)\n+  /* Finally remove the replaced node.  */\n+  cgraph_remove_node (node);\n+}\n+\n+/* Merge two variable or function symbol table entries PREVAILING and ENTRY.\n+   Return false if the symbols are not fully compatible and a diagnostic\n+   should be emitted.  */\n+\n+static bool\n+lto_symtab_merge (lto_symtab_entry_t prevailing, lto_symtab_entry_t entry)\n+{\n+  tree prevailing_decl = prevailing->decl;\n+  tree decl = entry->decl;\n+  tree prevailing_type, type;\n+  struct cgraph_node *node;\n+\n+  /* Merge decl state in both directions, we may still end up using\n+     the new decl.  */\n+  TREE_ADDRESSABLE (prevailing_decl) |= TREE_ADDRESSABLE (decl);\n+  TREE_ADDRESSABLE (decl) |= TREE_ADDRESSABLE (prevailing_decl);\n+\n+  /* Replace a cgraph node of entry with the prevailing one.  */\n+  if (TREE_CODE (decl) == FUNCTION_DECL\n+      && (node = cgraph_get_node (decl)) != NULL)\n+    lto_cgraph_replace_node (node, cgraph_get_node (prevailing_decl));\n+\n+  /* The linker may ask us to combine two incompatible symbols.\n+     Detect this case and notify the caller of required diagnostics.  */\n+\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n-      if (!gimple_types_compatible_p (TREE_TYPE (old_decl),\n-\t\t\t\t      TREE_TYPE (new_decl)))\n+      if (!gimple_types_compatible_p (TREE_TYPE (prevailing_decl),\n+\t\t\t\t      TREE_TYPE (decl)))\n \t/* If we don't have a merged type yet...sigh.  The linker\n \t   wouldn't complain if the types were mismatched, so we\n \t   probably shouldn't either.  Just use the type from\n@@ -214,70 +320,27 @@ lto_symtab_compatible (tree old_decl, tree new_decl)\n      ???  In principle all types involved in the two decls should\n      be merged forcefully, for example without considering type or\n      field names.  */\n-  old_type = TREE_TYPE (old_decl);\n-  new_type = TREE_TYPE (new_decl);\n-\n-  if (DECL_EXTERNAL (old_decl) || DECL_EXTERNAL (new_decl))\n-    maybe_merge_incomplete_and_complete_type (old_type, new_type);\n-  else if (POINTER_TYPE_P (old_type)\n-\t   && POINTER_TYPE_P (new_type))\n-    maybe_merge_incomplete_and_complete_type (TREE_TYPE (old_type),\n-\t\t\t\t\t      TREE_TYPE (new_type));\n-\n-  /* For array types we have to accept external declarations with\n-     different sizes than the actual definition (164.gzip).\n-     ???  We could emit a warning here.  */\n-  if (TREE_CODE (old_type) == TREE_CODE (new_type)\n-      && TREE_CODE (old_type) == ARRAY_TYPE\n-      && COMPLETE_TYPE_P (old_type)\n-      && COMPLETE_TYPE_P (new_type)\n-      && tree_int_cst_compare (TYPE_SIZE (old_type),\n-\t\t\t       TYPE_SIZE (new_type)) != 0\n-      && gimple_types_compatible_p (TREE_TYPE (old_type),\n-\t\t\t\t    TREE_TYPE (new_type)))\n-    {\n-      /* If only one is external use the type of the non-external decl.\n-\t Else use the larger one and also adjust the decl size.\n-\t ???  Directional merging would allow us to simply pick the\n-\t larger one instead of rewriting it.  */\n-      if (DECL_EXTERNAL (old_decl) ^ DECL_EXTERNAL (new_decl))\n-\t{\n-\t  if (DECL_EXTERNAL (old_decl))\n-\t    TREE_TYPE (old_decl) = new_type;\n-\t  else if (DECL_EXTERNAL (new_decl))\n-\t    TREE_TYPE (new_decl) = old_type;\n-\t}\n-      else\n-\t{\n-\t  if (tree_int_cst_compare (TYPE_SIZE (old_type),\n-\t\t\t\t    TYPE_SIZE (new_type)) < 0)\n-\t    {\n-\t      TREE_TYPE (old_decl) = new_type;\n-\t      DECL_SIZE (old_decl) = DECL_SIZE (new_decl);\n-\t      DECL_SIZE_UNIT (old_decl) = DECL_SIZE_UNIT (new_decl);\n-\t    }\n-\t  else\n-\t    {\n-\t      TREE_TYPE (new_decl) = old_type;\n-\t      DECL_SIZE (new_decl) = DECL_SIZE (old_decl);\n-\t      DECL_SIZE_UNIT (new_decl) = DECL_SIZE_UNIT (old_decl);\n-\t    }\n-\t}\n-    }\n+  prevailing_type = TREE_TYPE (prevailing_decl);\n+  type = TREE_TYPE (decl);\n+\n+  /* If the types are structurally equivalent we can use the knowledge\n+     that both bind to the same symbol to complete incomplete types\n+     of external declarations or of pointer targets.\n+     ???  We should apply this recursively to aggregate members here\n+     and get rid of the completion in gimple_types_compatible_p.  */\n+  if (DECL_EXTERNAL (prevailing_decl) || DECL_EXTERNAL (decl))\n+    maybe_merge_incomplete_and_complete_type (prevailing_type, type);\n+  else if (POINTER_TYPE_P (prevailing_type)\n+\t   && POINTER_TYPE_P (type))\n+    maybe_merge_incomplete_and_complete_type (TREE_TYPE (prevailing_type),\n+\t\t\t\t\t      TREE_TYPE (type));\n \n   /* We can tolerate differences in type qualification, the\n      qualification of the prevailing definition will prevail.  */\n-  old_type = TYPE_MAIN_VARIANT (TREE_TYPE (old_decl));\n-  new_type = TYPE_MAIN_VARIANT (TREE_TYPE (new_decl));\n-  if (!gimple_types_compatible_p (old_type, new_type))\n-    {\n-      if (warning_at (DECL_SOURCE_LOCATION (new_decl), 0,\n-\t\t      \"type of %qD does not match original declaration\",\n-\t\t      new_decl))\n-\tinform (DECL_SOURCE_LOCATION (old_decl),\n-\t\t\"previously declared here\");\n-      return false;\n-    }\n+  prevailing_type = TYPE_MAIN_VARIANT (TREE_TYPE (prevailing_decl));\n+  type = TYPE_MAIN_VARIANT (TREE_TYPE (decl));\n+  if (!gimple_types_compatible_p (prevailing_type, type))\n+    return false;\n \n   /* ???  We might want to emit a warning here if type qualification\n      differences were spotted.  Do not do this unconditionally though.  */\n@@ -290,213 +353,55 @@ lto_symtab_compatible (tree old_decl, tree new_decl)\n      mode the linker wouldn't complain either.  Just emit warnings.  */\n \n   /* Report a warning if user-specified alignments do not match.  */\n-  if ((DECL_USER_ALIGN (old_decl) && DECL_USER_ALIGN (new_decl))\n-      && DECL_ALIGN (old_decl) != DECL_ALIGN (new_decl))\n-    {\n-      warning_at (DECL_SOURCE_LOCATION (new_decl), 0,\n-\t\t  \"alignment of %qD does not match original declaration\",\n-\t\t  new_decl);\n-      inform (DECL_SOURCE_LOCATION (old_decl), \"previously declared here\");\n-      return false;\n-    }\n+  if ((DECL_USER_ALIGN (prevailing_decl) && DECL_USER_ALIGN (decl))\n+      && DECL_ALIGN (prevailing_decl) < DECL_ALIGN (decl))\n+    return false;\n \n   return true;\n }\n \n-/* Registers DECL with the LTO symbol table as having resolution RESOLUTION\n-   and read from FILE_DATA. */\n-\n-void\n-lto_symtab_register_decl (tree decl,\n-\t\t\t  ld_plugin_symbol_resolution_t resolution,\n-\t\t\t  struct lto_file_decl_data *file_data)\n-{\n-  lto_symtab_entry_t new_entry;\n-  void **slot;\n-\n-  /* Check that declarations reaching this function do not have\n-     properties inconsistent with having external linkage.  If any of\n-     these asertions fail, then the object file reader has failed to\n-     detect these cases and issue appropriate error messages.  */\n-  gcc_assert (decl\n-\t      && TREE_PUBLIC (decl)\n-\t      && (TREE_CODE (decl) == VAR_DECL\n-\t\t  || TREE_CODE (decl) == FUNCTION_DECL)\n-\t      && DECL_ASSEMBLER_NAME_SET_P (decl));\n-  if (TREE_CODE (decl) == VAR_DECL\n-      && DECL_INITIAL (decl))\n-    gcc_assert (!DECL_EXTERNAL (decl)\n-\t\t|| (TREE_STATIC (decl) && TREE_READONLY (decl)));\n-  if (TREE_CODE (decl) == FUNCTION_DECL)\n-    gcc_assert (!DECL_ABSTRACT (decl));\n-\n-  new_entry = GGC_CNEW (struct lto_symtab_entry_def);\n-  new_entry->id = DECL_ASSEMBLER_NAME (decl);\n-  new_entry->decl = decl;\n-  new_entry->resolution = resolution;\n-  new_entry->file_data = file_data;\n-  \n-  lto_symtab_maybe_init_hash_table ();\n-  slot = htab_find_slot (lto_symtab_identifiers, new_entry, INSERT);\n-  new_entry->next = (lto_symtab_entry_t) *slot;\n-  *slot = new_entry;\n-}\n-\n-/* Get the lto_symtab_entry_def struct associated with ID\n-   if there is one.  */\n+/* Return true if the symtab entry E can be replaced by another symtab\n+   entry.  */\n \n-static lto_symtab_entry_t\n-lto_symtab_get (tree id)\n+static bool\n+lto_symtab_resolve_replaceable_p (lto_symtab_entry_t e)\n {\n-  struct lto_symtab_entry_def temp;\n-  void **slot;\n-\n-  lto_symtab_maybe_init_hash_table ();\n-  temp.id = id;\n-  slot = htab_find_slot (lto_symtab_identifiers, &temp, NO_INSERT);\n-  return slot ? (lto_symtab_entry_t) *slot : NULL;\n-}\n+  if (DECL_EXTERNAL (e->decl)\n+      || DECL_COMDAT (e->decl)\n+      || DECL_WEAK (e->decl))\n+    return true;\n \n-/* Get the linker resolution for DECL.  */\n+  if (TREE_CODE (e->decl) == VAR_DECL)\n+    return (DECL_COMMON (e->decl)\n+\t    || (!flag_no_common && !DECL_INITIAL (e->decl)));\n \n-enum ld_plugin_symbol_resolution\n-lto_symtab_get_resolution (tree decl)\n-{\n-  lto_symtab_entry_t e;\n-\n-  gcc_assert (DECL_ASSEMBLER_NAME_SET_P (decl));\n-\n-  e = lto_symtab_get (DECL_ASSEMBLER_NAME (decl));\n-  while (e && e->decl != decl)\n-    e = e->next;\n-  if (!e)\n-    return LDPR_UNKNOWN;\n-\n-  return e->resolution;\n+  return false;\n }\n \n-/* Replace the cgraph node OLD_NODE with NEW_NODE in the cgraph, merging\n-   all edges and removing the old node.  */\n+/* Return true if the symtab entry E can be the prevailing one.  */\n \n-static void\n-lto_cgraph_replace_node (struct cgraph_node *old_node,\n-\t\t\t struct cgraph_node *new_node)\n+static bool\n+lto_symtab_resolve_can_prevail_p (lto_symtab_entry_t e)\n {\n-  struct cgraph_edge *e, *next;\n-\n-  /* Merge node flags.  */\n-  if (old_node->needed)\n-    cgraph_mark_needed_node (new_node);\n-  if (old_node->reachable)\n-    cgraph_mark_reachable_node (new_node);\n-  if (old_node->address_taken)\n-    {\n-      gcc_assert (!new_node->global.inlined_to);\n-      cgraph_mark_address_taken_node (new_node);\n-    }\n-\n-  /* Redirect all incoming edges.  */\n-  for (e = old_node->callers; e; e = next)\n-    {\n-      next = e->next_caller;\n-      cgraph_redirect_edge_callee (e, new_node);\n-    }\n-\n-  /* There are not supposed to be any outgoing edges from a node we\n-     replace.  Still this can happen for multiple instances of weak\n-     functions.\n-     ???  For now do what the old code did.  Do not create edges for them.  */\n-  for (e = old_node->callees; e; e = next)\n-    {\n-      next = e->next_callee;\n-      cgraph_remove_edge (e);\n-    }\n-\n-  /* Finally remove the replaced node.  */\n-  cgraph_remove_node (old_node);\n-}\n-\n-/* Merge two variable or function symbol table entries ENTRY1 and ENTRY2.\n-   Return the prevailing one or NULL if a merge is not possible.  */\n+  struct cgraph_node *node;\n \n-static lto_symtab_entry_t\n-lto_symtab_merge (lto_symtab_entry_t entry1, lto_symtab_entry_t entry2)\n-{\n-  tree old_decl = entry1->decl;\n-  tree new_decl = entry2->decl;\n-  ld_plugin_symbol_resolution_t old_resolution = entry1->resolution;\n-  ld_plugin_symbol_resolution_t new_resolution = entry2->resolution;\n-  struct cgraph_node *old_node = NULL;\n-  struct cgraph_node *new_node = NULL;\n-\n-  /* Give ODR violation errors.  */\n-  if (new_resolution == LDPR_PREVAILING_DEF\n-      || new_resolution == LDPR_PREVAILING_DEF_IRONLY)\n-    {\n-      if ((old_resolution == LDPR_PREVAILING_DEF\n-\t   || old_resolution == LDPR_PREVAILING_DEF_IRONLY)\n-\t  && (old_resolution != new_resolution || flag_no_common))\n-\t{\n-\t  error_at (DECL_SOURCE_LOCATION (new_decl),\n-\t\t    \"%qD has already been defined\", new_decl);\n-\t  inform (DECL_SOURCE_LOCATION (old_decl),\n-\t\t  \"previously defined here\");\n-\t  return NULL;\n-\t}\n-    }\n-\n-  /* The linker may ask us to combine two incompatible symbols.  */\n-  if (!lto_symtab_compatible (old_decl, new_decl))\n-    return NULL;\n-\n-  if (TREE_CODE (old_decl) == FUNCTION_DECL)\n-    old_node = cgraph_get_node (old_decl);\n-  if (TREE_CODE (new_decl) == FUNCTION_DECL)\n-    new_node = cgraph_get_node (new_decl);\n-\n-  /* Merge decl state in both directions, we may still end up using\n-     the new decl.  */\n-  TREE_ADDRESSABLE (old_decl) |= TREE_ADDRESSABLE (new_decl);\n-  TREE_ADDRESSABLE (new_decl) |= TREE_ADDRESSABLE (old_decl);\n+  if (!TREE_STATIC (e->decl))\n+    return false;\n \n-  gcc_assert (new_resolution != LDPR_UNKNOWN\n-\t      && new_resolution != LDPR_UNDEF\n-\t      && old_resolution != LDPR_UNKNOWN\n-\t      && old_resolution != LDPR_UNDEF);\n+  /* For functions we need a non-discarded body.  */\n+  if (TREE_CODE (e->decl) == FUNCTION_DECL)\n+    return ((node = cgraph_get_node (e->decl))\n+\t    && node->analyzed);\n \n-  if (new_resolution == LDPR_PREVAILING_DEF\n-      || new_resolution == LDPR_PREVAILING_DEF_IRONLY\n-      || (!old_node && new_node))\n-    {\n-      gcc_assert ((!old_node && new_node)\n-\t\t  || old_resolution == LDPR_PREEMPTED_IR\n-\t\t  || old_resolution ==  LDPR_RESOLVED_IR\n-\t\t  || (old_resolution == new_resolution && !flag_no_common));\n-      if (old_node)\n-\tlto_cgraph_replace_node (old_node, new_node);\n-      /* Choose new_decl, entry2.  */\n-      return entry2;\n-    }\n+  /* A variable should have a size.  */\n+  else if (TREE_CODE (e->decl) == VAR_DECL)\n+    return (DECL_SIZE (e->decl) != NULL_TREE\n+\t    /* The C++ frontend retains TREE_STATIC on the declaration\n+\t       of foo_ in struct Foo { static Foo *foo_; }; but it is\n+\t       not a definition.  g++.dg/lto/20090315_0.C.  */\n+\t    && !DECL_EXTERNAL (e->decl));\n \n-  if (new_resolution == LDPR_PREEMPTED_REG\n-      || new_resolution == LDPR_RESOLVED_EXEC\n-      || new_resolution == LDPR_RESOLVED_DYN)\n-    gcc_assert (old_resolution == LDPR_PREEMPTED_REG\n-\t\t|| old_resolution == LDPR_RESOLVED_EXEC\n-\t\t|| old_resolution == LDPR_RESOLVED_DYN);\n-\n-  if (new_resolution == LDPR_PREEMPTED_IR\n-      || new_resolution == LDPR_RESOLVED_IR)\n-    gcc_assert (old_resolution == LDPR_PREVAILING_DEF\n-\t\t|| old_resolution == LDPR_PREVAILING_DEF_IRONLY\n-\t\t|| old_resolution == LDPR_PREEMPTED_IR\n-\t\t|| old_resolution == LDPR_RESOLVED_IR);\n-\n-  if (new_node)\n-    lto_cgraph_replace_node (new_node, old_node);\n-\n-  /* Choose old_decl, entry1.  */\n-  return entry1;\n+  gcc_unreachable ();\n }\n \n /* Resolve the symbol with the candidates in the chain *SLOT and store\n@@ -506,148 +411,225 @@ static void\n lto_symtab_resolve_symbols (void **slot)\n {\n   lto_symtab_entry_t e = (lto_symtab_entry_t) *slot;\n+  lto_symtab_entry_t prevailing = NULL;\n \n   /* If the chain is already resolved there is nothing to do.  */\n   if (e->resolution != LDPR_UNKNOWN)\n     return;\n \n-  /* This is a poor mans resolver.  */\n+  /* Find the single non-replaceable prevailing symbol and\n+     diagnose ODR violations.  */\n   for (; e; e = e->next)\n     {\n-      gcc_assert (e->resolution == LDPR_UNKNOWN);\n-      if (DECL_EXTERNAL (e->decl)\n-\t  || (TREE_CODE (e->decl) == FUNCTION_DECL\n-\t      && !cgraph_get_node (e->decl)))\n-\te->resolution = LDPR_RESOLVED_IR;\n-      else\n+      if (!lto_symtab_resolve_can_prevail_p (e))\n+\t{\n+\t  e->resolution = LDPR_RESOLVED_IR;\n+\t  continue;\n+\t}\n+\n+      /* Set a default resolution - the final prevailing one will get\n+         adjusted later.  */\n+      e->resolution = LDPR_PREEMPTED_IR;\n+      if (!lto_symtab_resolve_replaceable_p (e))\n+\t{\n+\t  if (prevailing)\n+\t    {\n+\t      error_at (DECL_SOURCE_LOCATION (e->decl),\n+\t\t\t\"%qD has already been defined\", e->decl);\n+\t      inform (DECL_SOURCE_LOCATION (prevailing->decl),\n+\t\t      \"previously defined here\");\n+\t    }\n+\t  prevailing = e;\n+\t}\n+    }\n+  if (prevailing)\n+    goto found;\n+\n+  /* Do a second round choosing one from the replaceable prevailing decls.  */\n+  for (e = (lto_symtab_entry_t) *slot; e; e = e->next)\n+    {\n+      if (e->resolution != LDPR_PREEMPTED_IR)\n+\tcontinue;\n+\n+      /* Choose the first function that can prevail as prevailing.  */\n+      if (TREE_CODE (e->decl) == FUNCTION_DECL)\n \t{\n-\t  if (TREE_READONLY (e->decl))\n-\t    e->resolution = LDPR_PREVAILING_DEF_IRONLY;\n-\t  else\n-\t    e->resolution = LDPR_PREVAILING_DEF;\n+\t  prevailing = e;\n+\t  break;\n \t}\n+\n+      /* From variables that can prevail choose the largest one.  */\n+      if (!prevailing\n+\t  || tree_int_cst_lt (DECL_SIZE (prevailing->decl),\n+\t\t\t      DECL_SIZE (e->decl)))\n+\tprevailing = e;\n     }\n+\n+  if (!prevailing)\n+    return;\n+\n+found:\n+  if (TREE_CODE (prevailing->decl) == VAR_DECL\n+      && TREE_READONLY (prevailing->decl))\n+    prevailing->resolution = LDPR_PREVAILING_DEF_IRONLY;\n+  else\n+    prevailing->resolution = LDPR_PREVAILING_DEF;\n }\n \n-/* Merge one symbol table chain to a (set of) prevailing decls.  */\n+/* Merge all decls in the symbol table chain to the prevailing decl and\n+   issue diagnostics about type mismatches.  */\n \n static void\n lto_symtab_merge_decls_2 (void **slot)\n {\n-  lto_symtab_entry_t e2, e1;\n+  lto_symtab_entry_t prevailing, e;\n+  VEC(tree, heap) *mismatches = NULL;\n+  unsigned i;\n+  tree decl;\n+  bool diagnosed_p = false;\n \n   /* Nothing to do for a single entry.  */\n-  e1 = (lto_symtab_entry_t) *slot;\n-  if (!e1->next)\n+  prevailing = (lto_symtab_entry_t) *slot;\n+  if (!prevailing->next)\n     return;\n \n-  /* Try to merge each entry with each other entry.  In case of a\n-     single prevailing decl this is linear.  */\n-restart:\n-  for (; e1; e1 = e1->next)\n-    for (e2 = e1->next; e2; e2 = e2->next)\n-      {\n-\tlto_symtab_entry_t prevailing = lto_symtab_merge (e1, e2);\n-\tif (prevailing == e1)\n-\t  {\n-\t    lto_symtab_entry_t tmp = prevailing;\n-\t    while (tmp->next != e2)\n-\t      tmp = tmp->next;\n-\t    tmp->next = e2->next;\n-\t    e2->next = NULL;\n-\t    e2 = tmp;\n-\t  }\n-\telse if (prevailing == e2)\n-\t  {\n-\t    lto_symtab_entry_t tmp = (lto_symtab_entry_t) *slot;\n-\t    if (tmp == e1)\n-\t      {\n-\t\t*slot = e1->next;\n-\t\ttmp = e1->next;\n-\t      }\n-\t    else\n-\t      {\n-\t\twhile (tmp->next != e1)\n-\t\t  tmp = tmp->next;\n-\t\ttmp->next = e1->next;\n-\t      }\n-\t    e1->next = NULL;\n-\t    e1 = tmp;\n-\t    goto restart;\n-\t  }\n-      }\n-}\n-\n-/* Fixup the chain of prevailing variable decls *SLOT that are commonized\n-   during link-time.  */\n+  /* Try to merge each entry with the prevailing one.  */\n+  for (e = prevailing->next; e; e = e->next)\n+    {\n+      if (!lto_symtab_merge (prevailing, e))\n+\tVEC_safe_push (tree, heap, mismatches, e->decl);\n+    }\n+  if (VEC_empty (tree, mismatches))\n+    return;\n \n-static void\n-lto_symtab_fixup_var_decls (void **slot)\n-{\n-  lto_symtab_entry_t e = (lto_symtab_entry_t) *slot;\n-  tree size = bitsize_zero_node;\n-\n-  /* Find the largest prevailing decl and move it to the front of the chain.\n-     This is the decl we will output as representative for the common\n-     section.  */\n-  size = bitsize_zero_node;\n-  if (e->resolution == LDPR_PREVAILING_DEF_IRONLY\n-      || e->resolution == LDPR_PREVAILING_DEF)\n-    size = DECL_SIZE (e->decl);\n-  for (; e->next;)\n+  /* Diagnose all mismatched re-declarations.  */\n+  for (i = 0; VEC_iterate (tree, mismatches, i, decl); ++i)\n     {\n-      lto_symtab_entry_t next = e->next;\n-      if ((next->resolution == LDPR_PREVAILING_DEF_IRONLY\n-\t   || next->resolution == LDPR_PREVAILING_DEF)\n-\t  && tree_int_cst_lt (size, DECL_SIZE (next->decl)))\n+      if (!gimple_types_compatible_p (TREE_TYPE (prevailing->decl),\n+\t\t\t\t      TREE_TYPE (decl)))\n+\tdiagnosed_p |= warning_at (DECL_SOURCE_LOCATION (decl), 0,\n+\t\t\t\t   \"type of %qD does not match original \"\n+\t\t\t\t   \"declaration\", decl);\n+\n+      else if ((DECL_USER_ALIGN (prevailing->decl) && DECL_USER_ALIGN (decl))\n+\t       && DECL_ALIGN (prevailing->decl) < DECL_ALIGN (decl))\n \t{\n-\t  size = DECL_SIZE (next->decl);\n-\t  e->next = next->next;\n-\t  next->next = (lto_symtab_entry_t) *slot;\n-\t  *slot = next;\n+\t  diagnosed_p |= warning_at (DECL_SOURCE_LOCATION (decl), 0,\n+\t\t\t\t     \"alignment of %qD is bigger than \"\n+\t\t\t\t     \"original declaration\", decl);\n \t}\n-      else\n-\te = next;\n     }\n+  if (diagnosed_p)\n+    inform (DECL_SOURCE_LOCATION (prevailing->decl),\n+\t    \"previously declared here\");\n \n-  /* Mark everything apart from the first var as written out.  */\n-  e = (lto_symtab_entry_t) *slot;\n-  for (e = e->next; e; e = e->next)\n-    TREE_ASM_WRITTEN (e->decl) = true;\n+  VEC_free (tree, heap, mismatches);\n }\n \n /* Helper to process the decl chain for the symbol table entry *SLOT.  */\n \n static int\n lto_symtab_merge_decls_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n {\n-  lto_symtab_entry_t e;\n+  lto_symtab_entry_t e, prevailing;\n+  bool diagnosed_p = false;\n \n-  /* Compute the symbol resolutions.  */\n+  /* Compute the symbol resolutions.  This is a no-op when using the\n+     linker plugin.  */\n   lto_symtab_resolve_symbols (slot);\n \n-  /* Register and adjust types of the entries.  */\n-  for (e = (lto_symtab_entry_t) *slot; e; e = e->next)\n-    TREE_TYPE (e->decl) = gimple_register_type (TREE_TYPE (e->decl));\n+  /* Find the prevailing decl.  */\n+  for (prevailing = (lto_symtab_entry_t) *slot;\n+       prevailing\n+       && prevailing->resolution != LDPR_PREVAILING_DEF_IRONLY\n+       && prevailing->resolution != LDPR_PREVAILING_DEF;\n+       prevailing = prevailing->next)\n+    ;\n+\n+  /* Assert it's the only one.  */\n+  if (prevailing)\n+    for (e = prevailing->next; e; e = e->next)\n+      gcc_assert (e->resolution != LDPR_PREVAILING_DEF_IRONLY\n+\t\t  && e->resolution != LDPR_PREVAILING_DEF);\n+\n+  /* If there's not a prevailing symbol yet it's an external reference.\n+     Happens a lot during ltrans.  Choose the first symbol with a\n+     cgraph or a varpool node.  */\n+  if (!prevailing)\n+    {\n+      prevailing = (lto_symtab_entry_t) *slot;\n+      /* For functions choose one with a cgraph node.  */\n+      if (TREE_CODE (prevailing->decl) == FUNCTION_DECL)\n+\twhile (!cgraph_get_node (prevailing->decl)\n+\t       && prevailing->next)\n+\t  prevailing = prevailing->next;\n+      /* We do not stream varpool nodes, so the first decl has to\n+\t be good enough for now.\n+\t ???  For QOI choose a variable with readonly initializer\n+\t if there is one.  This matches C++\n+\t struct Foo { static const int i = 1; }; without a real\n+\t definition.  */\n+      if (TREE_CODE (prevailing->decl) == VAR_DECL)\n+\twhile (!(TREE_READONLY (prevailing->decl)\n+\t\t && DECL_INITIAL (prevailing->decl))\n+\t       && prevailing->next)\n+\t  prevailing = prevailing->next;\n+    }\n \n-  /* Merge the chain to a (hopefully) single prevailing decl.  */\n-  lto_symtab_merge_decls_2 (slot);\n+  /* Move it first in the list.  */\n+  if ((lto_symtab_entry_t) *slot != prevailing)\n+    {\n+      for (e = (lto_symtab_entry_t) *slot; e->next != prevailing; e = e->next)\n+\t;\n+      e->next = prevailing->next;\n+      prevailing->next = (lto_symtab_entry_t) *slot;\n+      *slot = (void *) prevailing;\n+    }\n \n-  /* ???  Ideally we should delay all diagnostics until this point to\n-     avoid duplicates.  */\n+  /* Record the prevailing variable.  */\n+  if (TREE_CODE (prevailing->decl) == VAR_DECL)\n+    VEC_safe_push (tree, gc, lto_global_var_decls, prevailing->decl);\n \n-  /* All done for FUNCTION_DECLs.  */\n-  e = (lto_symtab_entry_t) *slot;\n-  if (TREE_CODE (e->decl) == FUNCTION_DECL)\n-    return 1;\n+  /* Diagnose mismatched objects.  */\n+  for (e = prevailing->next; e; e = e->next)\n+    {\n+      if (TREE_CODE (prevailing->decl) == TREE_CODE (e->decl))\n+\tcontinue;\n+\n+      switch (TREE_CODE (prevailing->decl))\n+\t{\n+\tcase VAR_DECL:\n+\t  gcc_assert (TREE_CODE (e->decl) == FUNCTION_DECL);\n+\t  error_at (DECL_SOURCE_LOCATION (e->decl),\n+\t\t    \"variable %qD redeclared as function\", prevailing->decl);\n+\t  break;\n \n-  /* Fixup variables in case there are multiple prevailing ones.  */\n-  if (e->next)\n-    lto_symtab_fixup_var_decls (slot);\n+\tcase FUNCTION_DECL:\n+\t  gcc_assert (TREE_CODE (e->decl) == VAR_DECL);\n+\t  error_at (DECL_SOURCE_LOCATION (e->decl),\n+\t\t    \"function %qD redeclared as variable\", prevailing->decl);\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n \n-  /* Insert all variable decls into the global variable decl vector.  */\n+      diagnosed_p = true;\n+    }\n+  if (diagnosed_p)\n+      inform (DECL_SOURCE_LOCATION (prevailing->decl),\n+\t      \"previously declared here\");\n+\n+  /* Register and adjust types of the entries.  */\n   for (e = (lto_symtab_entry_t) *slot; e; e = e->next)\n-    VEC_safe_push (tree, gc, lto_global_var_decls, e->decl);\n+    TREE_TYPE (e->decl) = gimple_register_type (TREE_TYPE (e->decl));\n+\n+  /* Merge the chain to the single prevailing decl and diagnose\n+     mismatches.  */\n+  lto_symtab_merge_decls_2 (slot);\n+\n+  /* Drop all but the prevailing decl from the symtab.  */\n+  prevailing->next = NULL;\n \n   return 1;\n }\n@@ -685,21 +667,7 @@ lto_symtab_prevailing_decl (tree decl)\n   if (!ret)\n     return NULL_TREE;\n \n-  /* If there is only one candidate return it.  */\n-  if (ret->next == NULL)\n-    return ret->decl;\n-\n-  /* If there are multiple decls to choose from find the one we merged\n-     with and return that.  */\n-  while (ret)\n-    {\n-      if (gimple_types_compatible_p (TREE_TYPE (decl), TREE_TYPE (ret->decl)))\n-\treturn ret->decl;\n-\n-      ret = ret->next;\n-    }\n-\n-  gcc_unreachable ();\n+  return ret->decl;\n }\n \n /* Remove any storage used to store resolution of DECL.  */"}, {"sha": "e6f3e39315148374a86e21fc43712098a20fdf50", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200c8750d65ebebc8a0d6f6f77a7f02b5a4a8ef3/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200c8750d65ebebc8a0d6f6f77a7f02b5a4a8ef3/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=200c8750d65ebebc8a0d6f6f77a7f02b5a4a8ef3", "patch": "@@ -1,3 +1,9 @@\n+2009-10-14  Richard Guenther  <rguenther@suse.de>\n+\n+\t* lto.c (lto_fixup_tree): In case the prevailing decl is not\n+\tcompatible with the one we replace wrap it around a\n+\tVIEW_CONVERT_EXPR.\n+\n 2009-10-09  Richard Guenther  <rguenther@suse.de>\n \n \tPR lto/41635"}, {"sha": "daca784b0bbd98373acf9813dd6d0b4f6c609c1c", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200c8750d65ebebc8a0d6f6f77a7f02b5a4a8ef3/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200c8750d65ebebc8a0d6f6f77a7f02b5a4a8ef3/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=200c8750d65ebebc8a0d6f6f77a7f02b5a4a8ef3", "patch": "@@ -1530,10 +1530,18 @@ lto_fixup_tree (tree *tp, int *walk_subtrees, void *data)\n \n \t  pointer_set_insert (fixup_data->free_list, t);\n \n+\t  /* Replace the decl.  If it is a not compatible VAR_DECL wrap\n+\t     it inside a VIEW_CONVERT_EXPR.  */\n+\t  if (TREE_CODE (*tp) == VAR_DECL\n+\t      && !useless_type_conversion_p (TREE_TYPE (*tp),\n+\t\t\t\t\t     TREE_TYPE (prevailing)))\n+\t    *tp = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (*tp), prevailing);\n+\t  else\n+\t    *tp = prevailing;\n+\n \t   /* Also replace t with prevailing defintion.  We don't want to\n \t      insert the other defintion in the seen set as we want to\n \t      replace all instances of it.  */\n-\t  *tp = prevailing;\n \t  t = prevailing;\n \t}\n     }"}]}