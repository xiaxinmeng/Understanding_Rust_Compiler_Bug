{"sha": "9124bbe1857f0d3a3015d6461d5f8d04f07cab85", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTEyNGJiZTE4NTdmMGQzYTMwMTVkNjQ2MWQ1ZjhkMDRmMDdjYWI4NQ==", "commit": {"author": {"name": "Sebastian Huber", "email": "sebastian.huber@embedded-brains.de", "date": "2020-11-14T12:51:09Z"}, "committer": {"name": "Sebastian Huber", "email": "sebastian.huber@embedded-brains.de", "date": "2021-08-06T05:28:26Z"}, "message": "gcov: Add __gcov_info_to_gdca()\n\nAdd __gcov_info_to_gcda() to libgcov to get the gcda data for a gcda info in a\nfreestanding environment.  It is intended to be used with the\n-fprofile-info-section option.  A crude test program which doesn't use a linker\nscript is (use \"gcc -coverage -fprofile-info-section -lgcov test.c\" to compile\nit):\n\n  #include <gcov.h>\n  #include <stdio.h>\n  #include <stdlib.h>\n\n  extern const struct gcov_info *my_info;\n\n  static void\n  filename (const char *f, void *arg)\n  {\n    printf(\"filename: %s\\n\", f);\n  }\n\n  static void\n  dump (const void *d, unsigned n, void *arg)\n  {\n    const unsigned char *c = d;\n\n    for (unsigned i = 0; i < n; ++i)\n      printf (\"%02x\", c[i]);\n  }\n\n  static void *\n  allocate (unsigned length, void *arg)\n  {\n    return malloc (length);\n  }\n\n  int main()\n  {\n    __asm__ volatile (\".set my_info, .LPBX2\");\n    __gcov_info_to_gcda (my_info, filename, dump, allocate, NULL);\n    return 0;\n  }\n\nWith this patch, <stdint.h> is included in libgcov-driver.c even if\ninhibit_libc is defined.  This header file should be also available for\nfreestanding environments.  If this is not the case, then we have to define\nintptr_t somehow.\n\nThe patch removes one use of memset() which makes the <string.h> include\nsuperfluous.\n\ngcc/\n\n\t* gcov-io.h (gcov_write): Declare.\n\t* gcov-io.c (gcov_write): New.\n\t(gcov_write_counter): Remove.\n\t(gcov_write_tag_length): Likewise.\n\t(gcov_write_summary): Replace gcov_write_tag_length() with calls to\n\tgcov_write_unsigned().\n\t* doc/invoke.texi (fprofile-info-section): Mention\n\t__gcov_info_to_gdca().\n\ngcc/testsuite/\n\n\t* gcc.dg/gcov-info-to-gcda.c: New test.\n\nlibgcc/\n\n\t* Makefile.in (LIBGCOV_DRIVER): Add _gcov_info_to_gcda.\n\t* gcov.h (gcov_info): Declare.\n\t(__gcov_info_to_gdca): Likewise.\n\t* libgcov.h (gcov_write_counter): Remove.\n\t(gcov_write_tag_length): Likewise.\n\t* libgcov-driver.c (#include <stdint.h>): New.\n\t(#include <string.h>): Remove.\n\t(NEED_L_GCOV): Conditionally define.\n\t(NEED_L_GCOV_INFO_TO_GCDA): Likewise.\n\t(are_all_counters_zero): New.\n\t(gcov_dump_handler): Likewise.\n\t(gcov_allocate_handler): Likewise.\n\t(dump_unsigned): Likewise.\n\t(dump_counter): Likewise.\n\t(write_topn_counters): Add dump_fn, allocate_fn, and arg parameters.\n\tUse dump_unsigned() and dump_counter().\n\t(write_one_data): Add dump_fn, allocate_fn, and arg parameters.  Use\n\tdump_unsigned(), dump_counter(), and are_all_counters_zero().\n\t(__gcov_info_to_gcda): New.", "tree": {"sha": "7da449bf5bade4e861d82257bf12350cfa7a9dba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7da449bf5bade4e861d82257bf12350cfa7a9dba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9124bbe1857f0d3a3015d6461d5f8d04f07cab85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9124bbe1857f0d3a3015d6461d5f8d04f07cab85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9124bbe1857f0d3a3015d6461d5f8d04f07cab85", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9124bbe1857f0d3a3015d6461d5f8d04f07cab85/comments", "author": {"login": "sebhub", "id": 932056, "node_id": "MDQ6VXNlcjkzMjA1Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/932056?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebhub", "html_url": "https://github.com/sebhub", "followers_url": "https://api.github.com/users/sebhub/followers", "following_url": "https://api.github.com/users/sebhub/following{/other_user}", "gists_url": "https://api.github.com/users/sebhub/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebhub/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebhub/subscriptions", "organizations_url": "https://api.github.com/users/sebhub/orgs", "repos_url": "https://api.github.com/users/sebhub/repos", "events_url": "https://api.github.com/users/sebhub/events{/privacy}", "received_events_url": "https://api.github.com/users/sebhub/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sebhub", "id": 932056, "node_id": "MDQ6VXNlcjkzMjA1Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/932056?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebhub", "html_url": "https://github.com/sebhub", "followers_url": "https://api.github.com/users/sebhub/followers", "following_url": "https://api.github.com/users/sebhub/following{/other_user}", "gists_url": "https://api.github.com/users/sebhub/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebhub/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebhub/subscriptions", "organizations_url": "https://api.github.com/users/sebhub/orgs", "repos_url": "https://api.github.com/users/sebhub/repos", "events_url": "https://api.github.com/users/sebhub/events{/privacy}", "received_events_url": "https://api.github.com/users/sebhub/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3d3e8c362c2d850543eb2e2631128e1efc368f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3d3e8c362c2d850543eb2e2631128e1efc368f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3d3e8c362c2d850543eb2e2631128e1efc368f0"}], "stats": {"total": 388, "additions": 302, "deletions": 86}, "files": [{"sha": "a64cec5387e94c6f2137c7c71f368f7df89dd4bd", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 69, "deletions": 11, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9124bbe1857f0d3a3015d6461d5f8d04f07cab85/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9124bbe1857f0d3a3015d6461d5f8d04f07cab85/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=9124bbe1857f0d3a3015d6461d5f8d04f07cab85", "patch": "@@ -14801,17 +14801,17 @@ To optimize the program based on the collected profile information, use\n Register the profile information in the specified section instead of using a\n constructor/destructor.  The section name is @var{name} if it is specified,\n otherwise the section name defaults to @code{.gcov_info}.  A pointer to the\n-profile information generated by @option{-fprofile-arcs} or\n-@option{-ftest-coverage} is placed in the specified section for each\n-translation unit.  This option disables the profile information registration\n-through a constructor and it disables the profile information processing\n-through a destructor.  This option is not intended to be used in hosted\n-environments such as GNU/Linux.  It targets systems with limited resources\n-which do not support constructors and destructors.  The linker could collect\n-the input sections in a continuous memory block and define start and end\n-symbols.  The runtime support could dump the profiling information registered\n-in this linker set during program termination to a serial line for example.  A\n-GNU linker script example which defines a linker output section follows:\n+profile information generated by @option{-fprofile-arcs} is placed in the\n+specified section for each translation unit.  This option disables the profile\n+information registration through a constructor and it disables the profile\n+information processing through a destructor.  This option is not intended to be\n+used in hosted environments such as GNU/Linux.  It targets free-standing\n+environments (for example embedded systems) with limited resources which do not\n+support constructors/destructors or the C library file I/O.\n+\n+The linker could collect the input sections in a continuous memory block and\n+define start and end symbols.  A GNU linker script example which defines a\n+linker output section follows:\n \n @smallexample\n   .gcov_info      :\n@@ -14822,6 +14822,64 @@ GNU linker script example which defines a linker output section follows:\n   @}\n @end smallexample\n \n+The program could dump the profiling information registered in this linker set\n+for example like this:\n+\n+@smallexample\n+#include <gcov.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+extern const struct gcov_info *__gcov_info_start[];\n+extern const struct gcov_info *__gcov_info_end[];\n+\n+static void\n+filename (const char *f, void *arg)\n+@{\n+  puts (f);\n+@}\n+\n+static void\n+dump (const void *d, unsigned n, void *arg)\n+@{\n+  const unsigned char *c = d;\n+\n+  for (unsigned i = 0; i < n; ++i)\n+    printf (\"%02x\", c[i]);\n+@}\n+\n+static void *\n+allocate (unsigned length, void *arg)\n+@{\n+  return malloc (length);\n+@}\n+\n+static void\n+dump_gcov_info (void)\n+@{\n+  const struct gcov_info **info = __gcov_info_start;\n+  const struct gcov_info **end = __gcov_info_end;\n+\n+  /* Obfuscate variable to prevent compiler optimizations.  */\n+  __asm__ (\"\" : \"+r\" (info));\n+\n+  while (info != end)\n+  @{\n+    void *arg = NULL;\n+    __gcov_info_to_gcda (*info, filename, dump, allocate, arg);\n+    putchar ('\\n');\n+    ++info;\n+  @}\n+@}\n+\n+int\n+main()\n+@{\n+  dump_gcov_info();\n+  return 0;\n+@}\n+@end smallexample\n+\n @item -fprofile-note=@var{path}\n @opindex fprofile-note\n "}, {"sha": "d3e56afb0a5d45b28059e9083e823bffbeff49c9", "filename": "gcc/gcov-io.c", "status": "modified", "additions": 11, "deletions": 25, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9124bbe1857f0d3a3015d6461d5f8d04f07cab85/gcc%2Fgcov-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9124bbe1857f0d3a3015d6461d5f8d04f07cab85/gcc%2Fgcov-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.c?ref=9124bbe1857f0d3a3015d6461d5f8d04f07cab85", "patch": "@@ -229,30 +229,25 @@ gcov_magic (gcov_unsigned_t magic, gcov_unsigned_t expected)\n #endif\n \n #if !IN_GCOV\n-/* Write unsigned VALUE to coverage file.  */\n+/* Write DATA of LENGTH characters to coverage file.  */\n \n GCOV_LINKAGE void\n-gcov_write_unsigned (gcov_unsigned_t value)\n+gcov_write (const void *data, unsigned length)\n {\n-  gcov_unsigned_t r = fwrite (&value, sizeof (value), 1, gcov_var.file);\n+  gcov_unsigned_t r = fwrite (data, length, 1, gcov_var.file);\n   if (r != 1)\n     gcov_var.error = 1;\n }\n \n-/* Write counter VALUE to coverage file.  Sets error flag\n-   appropriately.  */\n+/* Write unsigned VALUE to coverage file.  */\n \n-#if IN_LIBGCOV\n GCOV_LINKAGE void\n-gcov_write_counter (gcov_type value)\n+gcov_write_unsigned (gcov_unsigned_t value)\n {\n-  gcov_write_unsigned ((gcov_unsigned_t) value);\n-  if (sizeof (value) > sizeof (gcov_unsigned_t))\n-    gcov_write_unsigned ((gcov_unsigned_t) (value >> 32));\n-  else\n-    gcov_write_unsigned (0);\n+  gcov_unsigned_t r = fwrite (&value, sizeof (value), 1, gcov_var.file);\n+  if (r != 1)\n+    gcov_var.error = 1;\n }\n-#endif /* IN_LIBGCOV */\n \n #if !IN_LIBGCOV\n /* Write STRING to coverage file.  Sets error flag on file\n@@ -349,22 +344,13 @@ gcov_write_length (gcov_position_t position)\n \n #else /* IN_LIBGCOV */\n \n-/* Write a tag TAG and length LENGTH.  */\n-\n-GCOV_LINKAGE void\n-gcov_write_tag_length (gcov_unsigned_t tag, gcov_unsigned_t length)\n-{\n-  gcov_write_unsigned (tag);\n-  gcov_write_unsigned (length);\n-}\n-\n-/* Write a summary structure to the gcov file.  Return nonzero on\n-   overflow.  */\n+/* Write a summary structure to the gcov file.  */\n \n GCOV_LINKAGE void\n gcov_write_summary (gcov_unsigned_t tag, const struct gcov_summary *summary)\n {\n-  gcov_write_tag_length (tag, GCOV_TAG_SUMMARY_LENGTH);\n+  gcov_write_unsigned (tag);\n+  gcov_write_unsigned (GCOV_TAG_SUMMARY_LENGTH);\n   gcov_write_unsigned (summary->runs);\n   gcov_write_unsigned (summary->sum_max);\n }"}, {"sha": "99e1964c1094553ac2dee1db77751a624d252ca9", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9124bbe1857f0d3a3015d6461d5f8d04f07cab85/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9124bbe1857f0d3a3015d6461d5f8d04f07cab85/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=9124bbe1857f0d3a3015d6461d5f8d04f07cab85", "patch": "@@ -367,6 +367,7 @@ char *mangle_path (char const *base);\n \n #if !IN_GCOV\n /* Available outside gcov */\n+GCOV_LINKAGE void gcov_write (const void *, unsigned) ATTRIBUTE_HIDDEN;\n GCOV_LINKAGE void gcov_write_unsigned (gcov_unsigned_t) ATTRIBUTE_HIDDEN;\n #endif\n "}, {"sha": "a42a768326ca02a01a47743bb6c86ec87db8ab88", "filename": "gcc/testsuite/gcc.dg/gcov-info-to-gcda.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9124bbe1857f0d3a3015d6461d5f8d04f07cab85/gcc%2Ftestsuite%2Fgcc.dg%2Fgcov-info-to-gcda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9124bbe1857f0d3a3015d6461d5f8d04f07cab85/gcc%2Ftestsuite%2Fgcc.dg%2Fgcov-info-to-gcda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgcov-info-to-gcda.c?ref=9124bbe1857f0d3a3015d6461d5f8d04f07cab85", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-do run } */\n+/* { dg-skip-if \"profile-info-section\" { powerpc-ibm-aix* } } */\n+/* { dg-options \"-fprofile-arcs -fprofile-info-section\" } */\n+\n+#define assert(expr)                                            \\\n+  ((expr)                                                       \\\n+   ? (void)0                                                    \\\n+   : (__builtin_printf (\"%s:%i: Assertion `%s' failed.\\n\",      \\\n+                        __FILE__, __LINE__, #expr),             \\\n+      __builtin_abort ()))\n+\n+struct gcov_info;\n+\n+extern void\n+__gcov_info_to_gcda (const struct gcov_info *__info,\n+\t\t     void (*__filename_fn) (const char *, void *),\n+\t\t     void (*__dump_fn) (const void *, unsigned, void *),\n+\t\t     void *(*__allocate_fn) (unsigned, void *),\n+\t\t     void *__arg);\n+\n+extern const struct gcov_info *my_info;\n+\n+static unsigned counter;\n+\n+static void\n+filename (const char *f, void *arg)\n+{\n+  assert (arg == &counter);\n+  assert (__builtin_strstr (f, \"gcov-info-to-gcda.c\") == 0);\n+}\n+\n+static void\n+dump (const void *d, unsigned n, void *arg)\n+{\n+  unsigned *m = (unsigned *)arg;\n+  assert (arg == &counter);\n+\n+  if (*m == 0)\n+  {\n+    const unsigned *u = d;\n+    assert (*u == 0x67636461);\n+  }\n+\n+  *m += n;\n+}\n+\n+static void *\n+allocate (unsigned length, void *arg)\n+{\n+  assert (arg == &counter);\n+  return __builtin_malloc (length);\n+}\n+\n+int main()\n+{\n+  __asm__ volatile (\".set my_info, .LPBX2\");\n+  __gcov_info_to_gcda (my_info, filename, dump, allocate, &counter);\n+  assert (counter > 4);\n+  return 0;\n+}"}, {"sha": "7ec975845544589eefb21528b8e1a2b2122cbe86", "filename": "libgcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9124bbe1857f0d3a3015d6461d5f8d04f07cab85/libgcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9124bbe1857f0d3a3015d6461d5f8d04f07cab85/libgcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FMakefile.in?ref=9124bbe1857f0d3a3015d6461d5f8d04f07cab85", "patch": "@@ -908,7 +908,7 @@ LIBGCOV_INTERFACE = _gcov_dump _gcov_fork\t\t\t\t\\\n \t_gcov_execl _gcov_execlp\t\t\t\t\t\\\n \t_gcov_execle _gcov_execv _gcov_execvp _gcov_execve _gcov_reset  \\\n \t_gcov_lock_unlock\n-LIBGCOV_DRIVER = _gcov\n+LIBGCOV_DRIVER = _gcov _gcov_info_to_gcda\n \n libgcov-merge-objects = $(patsubst %,%$(objext),$(LIBGCOV_MERGE))\n libgcov-profiler-objects = $(patsubst %,%$(objext),$(LIBGCOV_PROFILER))"}, {"sha": "66d03bf4e5d466255a6caa0abe33d14cd3ce7452", "filename": "libgcc/gcov.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9124bbe1857f0d3a3015d6461d5f8d04f07cab85/libgcc%2Fgcov.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9124bbe1857f0d3a3015d6461d5f8d04f07cab85/libgcc%2Fgcov.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fgcov.h?ref=9124bbe1857f0d3a3015d6461d5f8d04f07cab85", "patch": "@@ -25,6 +25,8 @@\n #ifndef GCC_GCOV_H\n #define GCC_GCOV_H\n \n+struct gcov_info;\n+\n /* Set all counters to zero.  */\n \n extern void __gcov_reset (void);\n@@ -33,4 +35,21 @@ extern void __gcov_reset (void);\n \n extern void __gcov_dump (void);\n \n+/* Convert the gcov information referenced by INFO to a gcda data stream.\n+   The FILENAME_FN callback is called exactly once with the filename associated\n+   with the gcov information.  The filename may be NULL.  Afterwards, the\n+   DUMP_FN callback is subsequently called with chunks (the begin and length of\n+   the chunk are passed as the first two callback parameters) of the gcda data\n+   stream.  The ALLOCATE_FN callback shall allocate memory with a size in\n+   characters specified by the first callback parameter.  The ARG parameter is\n+   a user-provided argument passed as the last argument to the callback\n+   functions.  */\n+\n+extern void\n+__gcov_info_to_gcda (const struct gcov_info *__info,\n+\t\t     void (*__filename_fn) (const char *, void *),\n+\t\t     void (*__dump_fn) (const void *, unsigned, void *),\n+\t\t     void *(*__allocate_fn) (unsigned, void *),\n+\t\t     void *__arg);\n+\n #endif /* GCC_GCOV_H */"}, {"sha": "9d7bc9c7995051183faa39fc910e000d75b58d3d", "filename": "libgcc/libgcov-driver.c", "status": "modified", "additions": 141, "deletions": 44, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9124bbe1857f0d3a3015d6461d5f8d04f07cab85/libgcc%2Flibgcov-driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9124bbe1857f0d3a3015d6461d5f8d04f07cab85/libgcc%2Flibgcov-driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-driver.c?ref=9124bbe1857f0d3a3015d6461d5f8d04f07cab85", "patch": "@@ -26,6 +26,20 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgcov.h\"\n #include \"gcov-io.h\"\n \n+#include <stdint.h>\n+\n+/* Return 1, if all counter values are zero, otherwise 0. */\n+\n+static inline int\n+are_all_counters_zero (const struct gcov_ctr_info *ci_ptr)\n+{\n+  for (unsigned i = 0; i < ci_ptr->num; i++)\n+    if (ci_ptr->values[i] != 0)\n+      return 0;\n+\n+  return 1;\n+}\n+\n #if defined(inhibit_libc)\n /* If libc and its header files are not available, provide dummy functions.  */\n \n@@ -35,8 +49,6 @@ void __gcov_init (struct gcov_info *p __attribute__ ((unused))) {}\n \n #else /* inhibit_libc */\n \n-#include <string.h>\n-\n #if GCOV_LOCKED\n #include <fcntl.h>\n #include <errno.h>\n@@ -51,8 +63,17 @@ void __gcov_init (struct gcov_info *p __attribute__ ((unused))) {}\n #include <sys/mman.h>\n #endif\n \n-#ifdef L_gcov\n+#endif /* inhibit_libc */\n+\n+#if defined(L_gcov) && !defined(inhibit_libc)\n+#define NEED_L_GCOV\n+#endif\n+\n+#if defined(L_gcov_info_to_gcda) && !IN_GCOV_TOOL\n+#define NEED_L_GCOV_INFO_TO_GCDA\n+#endif\n \n+#ifdef NEED_L_GCOV\n /* A utility function for outputting errors.  */\n static int gcov_error (const char *, ...);\n \n@@ -343,14 +364,62 @@ merge_one_data (const char *filename,\n   return -1;\n }\n \n+/* Write the DATA of LENGTH characters to the gcov file.  */\n+\n+static void\n+gcov_dump_handler (const void *data,\n+\t\t   unsigned length,\n+\t\t   void *arg ATTRIBUTE_UNUSED)\n+{\n+  gcov_write (data, length);\n+}\n+\n+/* Allocate SIZE characters and return the address of the allocated memory.  */\n+\n+static void *\n+gcov_allocate_handler (unsigned size, void *arg ATTRIBUTE_UNUSED)\n+{\n+  return xmalloc (size);\n+}\n+#endif /* NEED_L_GCOV */\n+\n+#if defined(NEED_L_GCOV) || defined(NEED_L_GCOV_INFO_TO_GCDA)\n+/* Dump the WORD using the DUMP handler called with ARG.  */\n+\n+static inline void\n+dump_unsigned (gcov_unsigned_t word,\n+\t       void (*dump_fn) (const void *, unsigned, void *),\n+\t       void *arg)\n+{\n+  (*dump_fn) (&word, sizeof (word), arg);\n+}\n+\n+/* Dump the COUNTER using the DUMP handler called with ARG.  */\n+\n+static inline void\n+dump_counter (gcov_type counter,\n+\t      void (*dump_fn) (const void *, unsigned, void *),\n+\t      void *arg)\n+{\n+  dump_unsigned ((gcov_unsigned_t)counter, dump_fn, arg);\n+\n+  if (sizeof (counter) > sizeof (gcov_unsigned_t))\n+    dump_unsigned ((gcov_unsigned_t)(counter >> 32), dump_fn, arg);\n+  else\n+    dump_unsigned (0, dump_fn, arg);\n+}\n+\n #define MAX(X,Y) ((X) > (Y) ? (X) : (Y))\n \n /* Store all TOP N counters where each has a dynamic length.  */\n \n static void\n write_topn_counters (const struct gcov_ctr_info *ci_ptr,\n \t\t     unsigned t_ix,\n-\t\t     gcov_unsigned_t n_counts)\n+\t\t     gcov_unsigned_t n_counts,\n+\t\t     void (*dump_fn) (const void *, unsigned, void *),\n+\t\t     void *(*allocate_fn)(unsigned, void *),\n+\t\t     void *arg)\n {\n   unsigned counters = n_counts / GCOV_TOPN_MEM_COUNTERS;\n   gcc_assert (n_counts % GCOV_TOPN_MEM_COUNTERS == 0);\n@@ -365,46 +434,49 @@ write_topn_counters (const struct gcov_ctr_info *ci_ptr,\n   if (list_sizes == NULL || counters > list_size_length)\n     {\n       list_size_length = MAX (LIST_SIZE_MIN_LENGTH, 2 * counters);\n-#if HAVE_SYS_MMAN_H\n+#if !defined(inhibit_libc) && HAVE_SYS_MMAN_H\n       list_sizes\n \t= (unsigned *)malloc_mmap (list_size_length * sizeof (unsigned));\n #endif\n \n       /* Malloc fallback.  */\n       if (list_sizes == NULL)\n-\tlist_sizes = (unsigned *)xmalloc (list_size_length * sizeof (unsigned));\n+\tlist_sizes =\n+\t  (unsigned *)(*allocate_fn) (list_size_length * sizeof (unsigned),\n+\t\t\t\t      arg);\n     }\n \n-  memset (list_sizes, 0, counters * sizeof (unsigned));\n   unsigned pair_total = 0;\n \n   for (unsigned i = 0; i < counters; i++)\n     {\n       gcov_type start = ci_ptr->values[GCOV_TOPN_MEM_COUNTERS * i + 2];\n+      unsigned sizes = 0;\n+\n       for (struct gcov_kvp *node = (struct gcov_kvp *)(intptr_t)start;\n \t   node != NULL; node = node->next)\n-\t{\n-\t  ++pair_total;\n-\t  ++list_sizes[i];\n-\t}\n+\t++sizes;\n+\n+      pair_total += sizes;\n+      list_sizes[i] = sizes;\n     }\n \n   unsigned disk_size = GCOV_TOPN_DISK_COUNTERS * counters + 2 * pair_total;\n-  gcov_write_tag_length (GCOV_TAG_FOR_COUNTER (t_ix),\n-\t\t\t GCOV_TAG_COUNTER_LENGTH (disk_size));\n+  dump_unsigned (GCOV_TAG_FOR_COUNTER (t_ix), dump_fn, arg),\n+  dump_unsigned (GCOV_TAG_COUNTER_LENGTH (disk_size), dump_fn, arg);\n \n   for (unsigned i = 0; i < counters; i++)\n     {\n-      gcov_write_counter (ci_ptr->values[GCOV_TOPN_MEM_COUNTERS * i]);\n-      gcov_write_counter (list_sizes[i]);\n+      dump_counter (ci_ptr->values[GCOV_TOPN_MEM_COUNTERS * i], dump_fn, arg);\n+      dump_counter (list_sizes[i], dump_fn, arg);\n       gcov_type start = ci_ptr->values[GCOV_TOPN_MEM_COUNTERS * i + 2];\n \n       unsigned j = 0;\n       for (struct gcov_kvp *node = (struct gcov_kvp *)(intptr_t)start;\n \t   j < list_sizes[i]; node = node->next, j++)\n \t{\n-\t  gcov_write_counter (node->value);\n-\t  gcov_write_counter (node->count);\n+\t  dump_counter (node->value, dump_fn, arg);\n+\t  dump_counter (node->count, dump_fn, arg);\n \t}\n     }\n }\n@@ -415,25 +487,34 @@ write_topn_counters (const struct gcov_ctr_info *ci_ptr,\n \n static void\n write_one_data (const struct gcov_info *gi_ptr,\n-\t\tconst struct gcov_summary *prg_p)\n+\t\tconst struct gcov_summary *prg_p ATTRIBUTE_UNUSED,\n+\t\tvoid (*dump_fn) (const void *, unsigned, void *),\n+\t\tvoid *(*allocate_fn) (unsigned, void *),\n+\t\tvoid *arg)\n {\n   unsigned f_ix;\n \n-  gcov_write_tag_length (GCOV_DATA_MAGIC, GCOV_VERSION);\n-  gcov_write_unsigned (gi_ptr->stamp);\n+  dump_unsigned (GCOV_DATA_MAGIC, dump_fn, arg);\n+  dump_unsigned (GCOV_VERSION, dump_fn, arg);\n+  dump_unsigned (gi_ptr->stamp, dump_fn, arg);\n \n+#ifdef NEED_L_GCOV\n   /* Generate whole program statistics.  */\n   gcov_write_summary (GCOV_TAG_OBJECT_SUMMARY, prg_p);\n+#endif\n \n   /* Write execution counts for each function.  */\n   for (f_ix = 0; f_ix != gi_ptr->n_functions; f_ix++)\n     {\n+#ifdef NEED_L_GCOV\n       unsigned buffered = 0;\n+#endif\n       const struct gcov_fn_info *gfi_ptr;\n       const struct gcov_ctr_info *ci_ptr;\n       gcov_unsigned_t length;\n       unsigned t_ix;\n \n+#ifdef NEED_L_GCOV\n       if (fn_buffer && fn_buffer->fn_ix == f_ix)\n         {\n           /* Buffered data from another program.  */\n@@ -442,6 +523,7 @@ write_one_data (const struct gcov_info *gi_ptr,\n           length = GCOV_TAG_FUNCTION_LENGTH;\n         }\n       else\n+#endif\n         {\n           gfi_ptr = gi_ptr->functions[f_ix];\n           if (gfi_ptr && gfi_ptr->key == gi_ptr)\n@@ -450,13 +532,14 @@ write_one_data (const struct gcov_info *gi_ptr,\n                 length = 0;\n         }\n \n-      gcov_write_tag_length (GCOV_TAG_FUNCTION, length);\n+      dump_unsigned (GCOV_TAG_FUNCTION, dump_fn, arg);\n+      dump_unsigned (length, dump_fn, arg);\n       if (!length)\n         continue;\n \n-      gcov_write_unsigned (gfi_ptr->ident);\n-      gcov_write_unsigned (gfi_ptr->lineno_checksum);\n-      gcov_write_unsigned (gfi_ptr->cfg_checksum);\n+      dump_unsigned (gfi_ptr->ident, dump_fn, arg);\n+      dump_unsigned (gfi_ptr->lineno_checksum, dump_fn, arg);\n+      dump_unsigned (gfi_ptr->cfg_checksum, dump_fn, arg);\n \n       ci_ptr = gfi_ptr->ctrs;\n       for (t_ix = 0; t_ix < GCOV_COUNTERS; t_ix++)\n@@ -469,39 +552,37 @@ write_one_data (const struct gcov_info *gi_ptr,\n \t  n_counts = ci_ptr->num;\n \n \t  if (t_ix == GCOV_COUNTER_V_TOPN || t_ix == GCOV_COUNTER_V_INDIR)\n-\t    write_topn_counters (ci_ptr, t_ix, n_counts);\n+\t    write_topn_counters (ci_ptr, t_ix, n_counts, dump_fn, allocate_fn,\n+\t\t\t\t arg);\n \t  else\n \t    {\n-\t      /* Do not stream when all counters are zero.  */\n-\t      int all_zeros = 1;\n-\t      for (unsigned i = 0; i < n_counts; i++)\n-\t\tif (ci_ptr->values[i] != 0)\n-\t\t  {\n-\t\t    all_zeros = 0;\n-\t\t    break;\n-\t\t  }\n-\n-\t      if (all_zeros)\n-\t\tgcov_write_tag_length (GCOV_TAG_FOR_COUNTER (t_ix),\n-\t\t\t\t       GCOV_TAG_COUNTER_LENGTH (-n_counts));\n+\t      dump_unsigned (GCOV_TAG_FOR_COUNTER (t_ix), dump_fn, arg);\n+\t      if (are_all_counters_zero (ci_ptr))\n+\t\t/* Do not stream when all counters are zero.  */\n+\t\tdump_unsigned (GCOV_TAG_COUNTER_LENGTH (-n_counts),\n+\t\t\t       dump_fn, arg);\n \t      else\n \t\t{\n-\t\t  gcov_write_tag_length (GCOV_TAG_FOR_COUNTER (t_ix),\n-\t\t\t\t\t GCOV_TAG_COUNTER_LENGTH (n_counts));\n+\t\t  dump_unsigned (GCOV_TAG_COUNTER_LENGTH (n_counts),\n+\t\t\t\t dump_fn, arg);\n \t\t  for (unsigned i = 0; i < n_counts; i++)\n-\t\t    gcov_write_counter (ci_ptr->values[i]);\n+\t\t    dump_counter (ci_ptr->values[i], dump_fn, arg);\n \t\t}\n \t    }\n \n \t  ci_ptr++;\n \t}\n+#ifdef NEED_L_GCOV\n       if (buffered)\n         fn_buffer = free_fn_data (gi_ptr, fn_buffer, GCOV_COUNTERS);\n+#endif\n     }\n \n-  gcov_write_unsigned (0);\n+  dump_unsigned (0, dump_fn, arg);\n }\n+#endif /* NEED_L_GCOV || NEED_L_GCOV_INFO_TO_GCDA */\n \n+#ifdef NEED_L_GCOV\n /* Dump the coverage counts for one gcov_info object. We merge with existing\n    counts when possible, to avoid growing the .da files ad infinitum. We use\n    this program's checksum to make sure we only accumulate whole program\n@@ -550,7 +631,8 @@ dump_one_gcov (struct gcov_info *gi_ptr, struct gcov_filename *gf,\n   summary = gi_ptr->summary;\n #endif\n \n-  write_one_data (gi_ptr, &summary);\n+  write_one_data (gi_ptr, &summary, gcov_dump_handler, gcov_allocate_handler,\n+\t\t  NULL);\n   /* fall through */\n \n read_fatal:;\n@@ -680,5 +762,20 @@ __gcov_init (struct gcov_info *info)\n     }\n }\n #endif /* !IN_GCOV_TOOL */\n-#endif /* L_gcov */\n-#endif /* inhibit_libc */\n+#endif /* NEED_L_GCOV */\n+\n+#ifdef NEED_L_GCOV_INFO_TO_GCDA\n+/* Convert the gcov info to a gcda data stream.  It is intended for\n+   free-standing environments which do not support the C library file I/O.  */\n+\n+void\n+__gcov_info_to_gcda (const struct gcov_info *gi_ptr,\n+\t\t     void (*filename_fn) (const char *, void *),\n+\t\t     void (*dump_fn) (const void *, unsigned, void *),\n+\t\t     void *(*allocate_fn) (unsigned, void *),\n+\t\t     void *arg)\n+{\n+  (*filename_fn) (gi_ptr->filename, arg);\n+  write_one_data (gi_ptr, NULL, dump_fn, allocate_fn, arg);\n+}\n+#endif /* NEED_L_GCOV_INFO_TO_GCDA */"}, {"sha": "9c537253293f02b4b514a64a8bb84318ef70e934", "filename": "libgcc/libgcov.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9124bbe1857f0d3a3015d6461d5f8d04f07cab85/libgcc%2Flibgcov.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9124bbe1857f0d3a3015d6461d5f8d04f07cab85/libgcc%2Flibgcov.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov.h?ref=9124bbe1857f0d3a3015d6461d5f8d04f07cab85", "patch": "@@ -114,13 +114,11 @@ typedef unsigned gcov_type_unsigned __attribute__ ((mode (QI)));\n #define gcov_var __gcov_var\n #define gcov_open __gcov_open\n #define gcov_close __gcov_close\n-#define gcov_write_tag_length __gcov_write_tag_length\n #define gcov_position __gcov_position\n #define gcov_seek __gcov_seek\n #define gcov_rewrite __gcov_rewrite\n #define gcov_is_error __gcov_is_error\n #define gcov_write_unsigned __gcov_write_unsigned\n-#define gcov_write_counter __gcov_write_counter\n #define gcov_write_summary __gcov_write_summary\n #define gcov_read_unsigned __gcov_read_unsigned\n #define gcov_read_counter __gcov_read_counter\n@@ -345,9 +343,6 @@ extern int __gcov_execve (const char *, char  *const [], char *const [])\n \n /* Functions that only available in libgcov.  */\n GCOV_LINKAGE int gcov_open (const char */*name*/) ATTRIBUTE_HIDDEN;\n-GCOV_LINKAGE void gcov_write_counter (gcov_type) ATTRIBUTE_HIDDEN;\n-GCOV_LINKAGE void gcov_write_tag_length (gcov_unsigned_t, gcov_unsigned_t)\n-    ATTRIBUTE_HIDDEN;\n GCOV_LINKAGE void gcov_write_summary (gcov_unsigned_t /*tag*/,\n                                       const struct gcov_summary *)\n     ATTRIBUTE_HIDDEN;"}]}