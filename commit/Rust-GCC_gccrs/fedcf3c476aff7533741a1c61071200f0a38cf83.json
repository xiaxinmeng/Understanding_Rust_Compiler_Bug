{"sha": "fedcf3c476aff7533741a1c61071200f0a38cf83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmVkY2YzYzQ3NmFmZjc1MzM3NDFhMWM2MTA3MTIwMGYwYTM4Y2Y4Mw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-07-08T07:52:49Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-07-12T14:47:45Z"}, "message": "tree-optimization/101373 - avoid PRE across externally throwing call\n\nPRE already tries to avoid hoisting possibly trapping expressions\nacross calls that might not return normally but fails to consider\nconst calls that throw externally.  The following fixes that and\nalso plugs the hole of trapping references not pruned in case\nthey are not catched by the actuall call clobbering it.\n\nAt -Os we hit the same issue in RTL PRE and postreload-gcse has\neven more incomplete checks so the patch adjusts both of those\nas well.\n\n2021-07-08  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/101373\n\t* tree-ssa-pre.c (prune_clobbered_mems): Also prune trapping\n\treferences when the BB may not return.\n\t(compute_avail): Pass in the function we're working on and\n\treplace cfun references with it.  Externally throwing\n\tconst calls also possibly terminate the function.\n\t(pass_pre::execute): Pass down the function we're working on.\n\t* gcse.c (compute_hash_table_work): Externally throwing\n\tconst/pure calls also need record_last_mem_set_info.\n\t* postreload-gcse.c (record_opr_changes): Looping or externally\n\tthrowing const/pure calls also need record_last_mem_set_info.\n\n\t* g++.dg/torture/pr101373.C: New testcase, XFAILed.\n\t* gnat.dg/opt95.adb: Likewise.", "tree": {"sha": "129cb5cb4d560a1bbfe468aa3684f0a9c2f4991a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/129cb5cb4d560a1bbfe468aa3684f0a9c2f4991a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fedcf3c476aff7533741a1c61071200f0a38cf83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fedcf3c476aff7533741a1c61071200f0a38cf83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fedcf3c476aff7533741a1c61071200f0a38cf83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fedcf3c476aff7533741a1c61071200f0a38cf83/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe610051a803131822bd02a8842a67b573b8e46a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe610051a803131822bd02a8842a67b573b8e46a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe610051a803131822bd02a8842a67b573b8e46a"}], "stats": {"total": 114, "additions": 99, "deletions": 15}, "files": [{"sha": "ccd33664af535b36c8a331b0678f9bd49c98692b", "filename": "gcc/gcse.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fedcf3c476aff7533741a1c61071200f0a38cf83/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fedcf3c476aff7533741a1c61071200f0a38cf83/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=fedcf3c476aff7533741a1c61071200f0a38cf83", "patch": "@@ -1537,7 +1537,8 @@ compute_hash_table_work (struct gcse_hash_table_d *table)\n \t\trecord_last_reg_set_info (insn, regno);\n \n \t      if (! RTL_CONST_OR_PURE_CALL_P (insn)\n-\t\t  || RTL_LOOPING_CONST_OR_PURE_CALL_P (insn))\n+\t\t  || RTL_LOOPING_CONST_OR_PURE_CALL_P (insn)\n+\t\t  || can_throw_external (insn))\n \t\trecord_last_mem_set_info (insn);\n \t    }\n "}, {"sha": "6c95d09a1e5af400125e91969a4ff385beb32a94", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fedcf3c476aff7533741a1c61071200f0a38cf83/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fedcf3c476aff7533741a1c61071200f0a38cf83/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=fedcf3c476aff7533741a1c61071200f0a38cf83", "patch": "@@ -779,7 +779,9 @@ record_opr_changes (rtx_insn *insn)\n       EXECUTE_IF_SET_IN_HARD_REG_SET (callee_clobbers, 0, regno, hrsi)\n \trecord_last_reg_set_info_regno (insn, regno);\n \n-      if (! RTL_CONST_OR_PURE_CALL_P (insn))\n+      if (! RTL_CONST_OR_PURE_CALL_P (insn)\n+\t  || RTL_LOOPING_CONST_OR_PURE_CALL_P (insn)\n+\t  || can_throw_external (insn))\n \trecord_last_mem_set_info (insn);\n     }\n }"}, {"sha": "f8c809739e2d46a8ffba978b0907210d99392a8a", "filename": "gcc/testsuite/g++.dg/torture/pr101373.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fedcf3c476aff7533741a1c61071200f0a38cf83/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr101373.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fedcf3c476aff7533741a1c61071200f0a38cf83/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr101373.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr101373.C?ref=fedcf3c476aff7533741a1c61071200f0a38cf83", "patch": "@@ -0,0 +1,33 @@\n+// { dg-do run }\n+// { dg-xfail-run-if \"PR100409\" { *-*-* } }\n+\n+int __attribute__((const,noipa)) foo (int j)\n+{\n+  if (j != 0)\n+    throw 1;\n+  return 0;\n+}\n+\n+int __attribute__((noipa)) bar (int *p, int n)\n+{\n+  int ret = 0;\n+  if (n)\n+    {\n+       foo (n);\n+       ret = *p;\n+    }\n+  ret += *p;\n+  return ret;\n+}\n+\n+int main()\n+{\n+  try\n+    {\n+      return bar (nullptr, 1);\n+    }\n+  catch (...)\n+    {\n+      return 0;\n+    }\n+}"}, {"sha": "2c72582b3f179cfc4335ebc263e7446939468e99", "filename": "gcc/testsuite/gnat.dg/opt95.adb", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fedcf3c476aff7533741a1c61071200f0a38cf83/gcc%2Ftestsuite%2Fgnat.dg%2Fopt95.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fedcf3c476aff7533741a1c61071200f0a38cf83/gcc%2Ftestsuite%2Fgnat.dg%2Fopt95.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt95.adb?ref=fedcf3c476aff7533741a1c61071200f0a38cf83", "patch": "@@ -0,0 +1,40 @@\n+-- { dg-do run }\n+-- { dg-options \"-O2 -gnatp\" }\n+\n+procedure Opt95 is\n+\n+  function Foo (J : Integer) return Integer;\n+  pragma Pure_Function (Foo);\n+  pragma Machine_Attribute (Foo, \"noipa\");\n+\n+  function Foo (J : Integer) return Integer is\n+  begin\n+    if J /= 0 then\n+      raise Constraint_Error;\n+    end if;\n+    return 0;\n+  end;\n+\n+  function Bar (A : access Integer; N : Integer) return Integer;\n+  pragma Machine_Attribute (Bar, \"noipa\");\n+\n+  function Bar (A : access Integer; N : Integer) return Integer is\n+    Ret : Integer := 0;\n+    Ret2 : Integer := 0;\n+  begin\n+    if N /= 0 then\n+      Ret2 := Foo (N);\n+      Ret := A.all;\n+    end if;\n+    Ret := Ret + A.all;\n+    return Ret + Ret2;\n+  end;\n+\n+  V : Integer;\n+  pragma Volatile (V);\n+\n+begin\n+  V := Bar (null, 1);\n+exception\n+  when Constraint_Error => null;\n+end;"}, {"sha": "aa5244e678cd0f1414924026d07f78f796e67089", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fedcf3c476aff7533741a1c61071200f0a38cf83/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fedcf3c476aff7533741a1c61071200f0a38cf83/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=fedcf3c476aff7533741a1c61071200f0a38cf83", "patch": "@@ -2071,6 +2071,13 @@ prune_clobbered_mems (bitmap_set_t set, basic_block block)\n \t\t\t  && value_dies_in_block_x (expr, block))))\n \t\tto_remove = i;\n \t    }\n+\t  /* If the REFERENCE may trap make sure the block does not contain\n+\t     a possible exit point.\n+\t     ???  This is overly conservative if we translate AVAIL_OUT\n+\t     as the available expression might be after the exit point.  */\n+\t  if (BB_MAY_NOTRETURN (block)\n+\t      && vn_reference_may_trap (ref))\n+\t    to_remove = i;\n \t}\n       else if (expr->kind == NARY)\n \t{\n@@ -3860,7 +3867,7 @@ insert (void)\n    AVAIL_OUT[BLOCK] = AVAIL_IN[BLOCK] U PHI_GEN[BLOCK] U TMP_GEN[BLOCK].  */\n \n static void\n-compute_avail (void)\n+compute_avail (function *fun)\n {\n \n   basic_block block, son;\n@@ -3871,7 +3878,7 @@ compute_avail (void)\n \n   /* We pretend that default definitions are defined in the entry block.\n      This includes function arguments and the static chain decl.  */\n-  FOR_EACH_SSA_NAME (i, name, cfun)\n+  FOR_EACH_SSA_NAME (i, name, fun)\n     {\n       pre_expr e;\n       if (!SSA_NAME_IS_DEFAULT_DEF (name)\n@@ -3881,31 +3888,31 @@ compute_avail (void)\n \n       e = get_or_alloc_expr_for_name (name);\n       add_to_value (get_expr_value_id (e), e);\n-      bitmap_insert_into_set (TMP_GEN (ENTRY_BLOCK_PTR_FOR_FN (cfun)), e);\n-      bitmap_value_insert_into_set (AVAIL_OUT (ENTRY_BLOCK_PTR_FOR_FN (cfun)),\n+      bitmap_insert_into_set (TMP_GEN (ENTRY_BLOCK_PTR_FOR_FN (fun)), e);\n+      bitmap_value_insert_into_set (AVAIL_OUT (ENTRY_BLOCK_PTR_FOR_FN (fun)),\n \t\t\t\t    e);\n     }\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      print_bitmap_set (dump_file, TMP_GEN (ENTRY_BLOCK_PTR_FOR_FN (cfun)),\n+      print_bitmap_set (dump_file, TMP_GEN (ENTRY_BLOCK_PTR_FOR_FN (fun)),\n \t\t\t\"tmp_gen\", ENTRY_BLOCK);\n-      print_bitmap_set (dump_file, AVAIL_OUT (ENTRY_BLOCK_PTR_FOR_FN (cfun)),\n+      print_bitmap_set (dump_file, AVAIL_OUT (ENTRY_BLOCK_PTR_FOR_FN (fun)),\n \t\t\t\"avail_out\", ENTRY_BLOCK);\n     }\n \n   /* Allocate the worklist.  */\n-  worklist = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));\n+  worklist = XNEWVEC (basic_block, n_basic_blocks_for_fn (fun));\n \n   /* Seed the algorithm by putting the dominator children of the entry\n      block on the worklist.  */\n-  for (son = first_dom_son (CDI_DOMINATORS, ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+  for (son = first_dom_son (CDI_DOMINATORS, ENTRY_BLOCK_PTR_FOR_FN (fun));\n        son;\n        son = next_dom_son (CDI_DOMINATORS, son))\n     worklist[sp++] = son;\n \n-  BB_LIVE_VOP_ON_EXIT (ENTRY_BLOCK_PTR_FOR_FN (cfun))\n-    = ssa_default_def (cfun, gimple_vop (cfun));\n+  BB_LIVE_VOP_ON_EXIT (ENTRY_BLOCK_PTR_FOR_FN (fun))\n+    = ssa_default_def (fun, gimple_vop (fun));\n \n   /* Loop until the worklist is empty.  */\n   while (sp)\n@@ -3970,7 +3977,8 @@ compute_avail (void)\n \t\t before it.  */\n \t      int flags = gimple_call_flags (stmt);\n \t      if (!(flags & ECF_CONST)\n-\t\t  || (flags & ECF_LOOPING_CONST_OR_PURE))\n+\t\t  || (flags & ECF_LOOPING_CONST_OR_PURE)\n+\t\t  || stmt_can_throw_external (fun, stmt))\n \t\tBB_MAY_NOTRETURN (block) = 1;\n \t    }\n \n@@ -3987,7 +3995,7 @@ compute_avail (void)\n \t    BB_LIVE_VOP_ON_EXIT (block) = gimple_vdef (stmt);\n \n \t  if (gimple_has_side_effects (stmt)\n-\t      || stmt_could_throw_p (cfun, stmt)\n+\t      || stmt_could_throw_p (fun, stmt)\n \t      || is_gimple_debug (stmt))\n \t    continue;\n \n@@ -4384,7 +4392,7 @@ pass_pre::execute (function *fun)\n      we require AVAIL.  */\n   if (n_basic_blocks_for_fn (fun) < 4000)\n     {\n-      compute_avail ();\n+      compute_avail (fun);\n       compute_antic ();\n       insert ();\n     }"}]}