{"sha": "1e5f1716392c7915c55d95329ae59d1acce8592a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU1ZjE3MTYzOTJjNzkxNWM1NWQ5NTMyOWFlNTlkMWFjY2U4NTkyYQ==", "commit": {"author": {"name": "Andrew Pinski", "email": "pinskia@physics.uc.edu", "date": "2004-08-13T15:34:00Z"}, "committer": {"name": "Andrew Pinski", "email": "pinskia@gcc.gnu.org", "date": "2004-08-13T15:34:00Z"}, "message": "darwin-c.c (find_subframework_file): Fix spelling of cannot.\n\n2004-08-12  Andrew Pinski  <pinskia@physics.uc.edu>\n\n        * config/darwin-c.c (find_subframework_file): Fix spelling of cannot.\n        * config/libgloss.h: Likewise.\n        * config/arm/arm.c (arm_gen_load_multiple): Likewise.\n        * c4x/c4x-modes.def: Likewise.\n        * config/c4x/c4x.c (c4x_hard_regno_rename_ok): Likewise.\n        (c4x_rptb_nop_p): Likewise.\n        (c4x_rptb_valid_p): Likewise.\n        (c4x_rptb_insert): Likewise.\n        (c4x_address_conflict): Likewise.\n        * config/c4x/c4x.md: Likewise.\n        * config/frv/frv.md: Likewise.\n        * config/i386/athlon.md: Likewise.\n        * config/i386/i386.md: Likewise.\n        * config/i386/predicates.md: Likewise.\n        * config/ia64/ia64.c: Likewise.\n        * config/ia64/itanium1.md: Likewise.\n        * config/ia64/itanium2.md: Likewise.\n        * config/iq2000/iq2000.md: Likewise.\n        * config/mcore/mcore.c: Likewise.\n        * config/mips/mips.c: Likewise.\n        * config/mips/r3900.h: Likewise.\n        * config/mips/sb1.md: Likewise.\n        * config/pa/milli64.S: Likewise.\n        * config/pa/pa.c: Likewise.\n        * config/pa/pa.h: Likewise.\n        * config/rs6000/8540.md: Likewise.\n\nFrom-SVN: r85944", "tree": {"sha": "878c3b36634b01083dbdab85167d3a3f2f7de154", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/878c3b36634b01083dbdab85167d3a3f2f7de154"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e5f1716392c7915c55d95329ae59d1acce8592a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e5f1716392c7915c55d95329ae59d1acce8592a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e5f1716392c7915c55d95329ae59d1acce8592a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e5f1716392c7915c55d95329ae59d1acce8592a/comments", "author": null, "committer": null, "parents": [{"sha": "9bcc9490cb4ac565b9226625aa1132b65eab0250", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bcc9490cb4ac565b9226625aa1132b65eab0250", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bcc9490cb4ac565b9226625aa1132b65eab0250"}], "stats": {"total": 167, "additions": 98, "deletions": 69}, "files": [{"sha": "6ef44ff2e889f6f9013df640f5422fbebee3f655", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1e5f1716392c7915c55d95329ae59d1acce8592a", "patch": "@@ -1,3 +1,32 @@\n+2004-08-12  Andrew Pinski  <pinskia@physics.uc.edu>\n+\n+\t* config/darwin-c.c (find_subframework_file): Fix spelling of cannot.\n+\t* config/libgloss.h: Likewise.\n+\t* config/arm/arm.c (arm_gen_load_multiple): Likewise.\n+\t* c4x/c4x-modes.def: Likewise.\n+\t* config/c4x/c4x.c (c4x_hard_regno_rename_ok): Likewise.\n+\t(c4x_rptb_nop_p): Likewise.\n+\t(c4x_rptb_valid_p): Likewise.\n+\t(c4x_rptb_insert): Likewise.\n+\t(c4x_address_conflict): Likewise.\n+\t* config/c4x/c4x.md: Likewise.\n+\t* config/frv/frv.md: Likewise.\n+\t* config/i386/athlon.md: Likewise.\n+\t* config/i386/i386.md: Likewise.\n+\t* config/i386/predicates.md: Likewise.\n+\t* config/ia64/ia64.c: Likewise.\n+\t* config/ia64/itanium1.md: Likewise.\n+\t* config/ia64/itanium2.md: Likewise.\n+\t* config/iq2000/iq2000.md: Likewise.\n+\t* config/mcore/mcore.c: Likewise.\n+\t* config/mips/mips.c: Likewise.\n+\t* config/mips/r3900.h: Likewise.\n+\t* config/mips/sb1.md: Likewise.\n+\t* config/pa/milli64.S: Likewise.\n+\t* config/pa/pa.c: Likewise.\n+\t* config/pa/pa.h: Likewise.\n+\t* config/rs6000/8540.md: Likewise.\n+\n 2004-08-13  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* Makefile.in (BOOT_CFLAGS): Remove accidental addition of -dU."}, {"sha": "c12ea5285dd482a25f9cc9784f4b0bb5a27aeb45", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=1e5f1716392c7915c55d95329ae59d1acce8592a", "patch": "@@ -5903,7 +5903,7 @@ arm_gen_load_multiple (int base_regno, int count, rtx from, int up,\n   rtx mem;\n \n   /* XScale has load-store double instructions, but they have stricter\n-     alignment requirements than load-store multiple, so we can not\n+     alignment requirements than load-store multiple, so we cannot\n      use them.\n \n      For XScale ldm requires 2 + NREGS cycles to complete and blocks"}, {"sha": "34faaa3041e92c8ef2bd03096b7903f13226fac0", "filename": "gcc/config/c4x/c4x-modes.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fc4x%2Fc4x-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fc4x%2Fc4x-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x-modes.def?ref=1e5f1716392c7915c55d95329ae59d1acce8592a", "patch": "@@ -102,7 +102,7 @@ RESET_FLOAT_FORMAT (DF, 0);  /* not used */\n    Thus (GE (MINUS (0x80000000) (0x7fffffff) (0x00000000))) sets the N\n    flag but (GE (0x00000001)) does not set the N flag.\n \n-   The upshot is that we can not use signed branch and conditional\n+   The upshot is that we cannot use signed branch and conditional\n    load instructions after an add, subtract, neg, abs or multiply.\n    We must emit a compare insn to check the result against 0.  */\n "}, {"sha": "6adf0bd98d93c768240cf448ae0f582c8090ed51", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=1e5f1716392c7915c55d95329ae59d1acce8592a", "patch": "@@ -467,7 +467,7 @@ c4x_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n int\n c4x_hard_regno_rename_ok (unsigned int regno1, unsigned int regno2)\n {\n-  /* We can not copy call saved registers from mode QI into QF or from\n+  /* We cannot copy call saved registers from mode QI into QF or from\n      mode QF into QI.  */\n   if (IS_FLOAT_CALL_SAVED_REGNO (regno1) && IS_INT_CALL_SAVED_REGNO (regno2))\n     return 0;\n@@ -2260,7 +2260,7 @@ c4x_rptb_nop_p (rtx insn)\n   Before we can create a repeat block looping instruction we have to\n   verify that there are no jumps outside the loop and no jumps outside\n   the loop go into this loop. This can happen in the basic blocks reorder\n-  pass. The C4x cpu can not handle this.  */\n+  pass. The C4x cpu cannot handle this.  */\n \n static int\n c4x_label_ref_used_p (rtx x, rtx code_label)\n@@ -2305,7 +2305,7 @@ c4x_rptb_valid_p (rtx insn, rtx start_label)\n     if (insn == start_label)\n       break;\n \n-  /* Note found then we can not use a rptb or rpts.  The label was\n+  /* Note found then we cannot use a rptb or rpts.  The label was\n      probably moved by the basic block reorder pass.  */\n   if (! insn)\n     return 0;\n@@ -2374,7 +2374,7 @@ c4x_rptb_insert (rtx insn)\n   \n   if (! c4x_rptb_valid_p (insn, start_label))\n     {\n-      /* We can not use the rptb insn.  Replace it so reorg can use\n+      /* We cannot use the rptb insn.  Replace it so reorg can use\n          the delay slots of the jump insn.  */\n       emit_insn_before (gen_addqi3 (count_reg, count_reg, constm1_rtx), insn);\n       emit_insn_before (gen_cmpqi (count_reg, const0_rtx), insn);\n@@ -3548,7 +3548,7 @@ c4x_address_conflict (rtx op0, rtx op1, int store0, int store1)\n   if (! TARGET_DEVEL && base0 == base1 && (incdec0 || incdec1))\n     return 1;\n \n-  /* We can not optimize the case where op1 and op2 refer to the same\n+  /* We cannot optimize the case where op1 and op2 refer to the same\n      address.  */\n   if (base0 == base1 && disp0 == disp1 && index0 == index1)\n     return 1;"}, {"sha": "edab060adf2a95a1c00de807afb96194b550a6f9", "filename": "gcc/config/c4x/c4x.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fc4x%2Fc4x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fc4x%2Fc4x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.md?ref=1e5f1716392c7915c55d95329ae59d1acce8592a", "patch": "@@ -320,8 +320,8 @@\n ;        op3             fetch executed\n ; This means that we can allow any instruction in the last delay slot\n ; and only instructions which modify registers in the first two. \n-; lda can not be executed in the first delay slot \n-; and ldpk can not be executed in the first two delay slots.\n+; lda cannot be executed in the first delay slot \n+; and ldpk cannot be executed in the first two delay slots.\n \n (define_attr \"onlyreg\" \"false,true\"\n        (cond [(eq_attr \"type\" \"unary,unarycc\")\n@@ -5909,7 +5909,7 @@\n  \"push\\\\t%0\"\n  [(set_attr \"type\" \"push\")])\n \n-; we can not use this because the popf will destroy the low 8 bits\n+; we cannot use this because the popf will destroy the low 8 bits\n ;(define_insn \"pophf\"\n ;  [(set (match_operand:HF 0 \"reg_operand\" \"=h\")\n ;        (mem:HF (post_dec:QI (reg:QI 20))))"}, {"sha": "e8b188f5056e89f1f68255b0158d84e74b7be935", "filename": "gcc/config/darwin-c.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fdarwin-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fdarwin-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin-c.c?ref=1e5f1716392c7915c55d95329ae59d1acce8592a", "patch": "@@ -319,7 +319,7 @@ find_subframework_file (const char *fname, const char *pname)\n   bufptr = strstr (pname, dot_framework);\n \n   /* If the parent header is not of any framework, then this header\n-     can not be part of any subframework.  */\n+     cannot be part of any subframework.  */\n   if (!bufptr)\n     return 0;\n "}, {"sha": "9c788986f0e7ae2e1197350b265bee4629ada3e6", "filename": "gcc/config/frv/frv.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Ffrv%2Ffrv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Ffrv%2Ffrv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.md?ref=1e5f1716392c7915c55d95329ae59d1acce8592a", "patch": "@@ -405,29 +405,29 @@\n      DEFINE_AUTOMATON).\n \n      All define_reservations and define_cpu_units should have unique\n-     names which can not be \"nothing\".\n+     names which cannot be \"nothing\".\n \n    o (exclusion_set string string) means that each CPU function unit\n-     in the first string can not be reserved simultaneously with each\n+     in the first string cannot be reserved simultaneously with each\n      unit whose name is in the second string and vise versa.  CPU\n      units in the string are separated by commas. For example, it is\n      useful for description CPU with fully pipelined floating point\n      functional unit which can execute simultaneously only single\n      floating point insns or only double floating point insns.\n \n    o (presence_set string string) means that each CPU function unit in\n-     the first string can not be reserved unless at least one of units\n+     the first string cannot be reserved unless at least one of units\n      whose names are in the second string is reserved.  This is an\n      asymmetric relation.  CPU units in the string are separated by\n      commas.  For example, it is useful for description that slot1 is\n      reserved after slot0 reservation for a VLIW processor.\n \n    o (absence_set string string) means that each CPU function unit in\n-     the first string can not be reserved only if each unit whose name\n+     the first string cannot be reserved only if each unit whose name\n      is in the second string is not reserved.  This is an asymmetric\n      relation (actually exclusion set is analogous to this one but it\n      is symmetric).  CPU units in the string are separated by commas.\n-     For example, it is useful for description that slot0 can not be\n+     For example, it is useful for description that slot0 cannot be\n      reserved after slot1 or slot2 reservation for a VLIW processor.\n \n    o (define_bypass number out_insn_names in_insn_names) names bypass with\n@@ -450,7 +450,7 @@\n      case, you describe common part and use one its name (the 1st\n      parameter) in regular expression in define_insn_reservation.  All\n      define_reservations, define results and define_cpu_units should\n-     have unique names which can not be \"nothing\".\n+     have unique names which cannot be \"nothing\".\n \n    o (define_insn_reservation name default_latency condition regexpr)\n      describes reservation of cpu functional units (the 3nd operand)"}, {"sha": "6cec395483c77ca2c5ba584f9cd36155dac9cd25", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=1e5f1716392c7915c55d95329ae59d1acce8592a", "patch": "@@ -1288,7 +1288,7 @@ bit_operand (rtx op, enum machine_mode mode)\n     return 1;\n \n   /* Accept any mem during RTL generation.  Otherwise, the code that does\n-     insv and extzv will think that we can not handle memory.  However,\n+     insv and extzv will think that we cannot handle memory.  However,\n      to avoid reload problems, we only accept 'U' MEM operands after RTL\n      generation.  This means that any named pattern which uses this predicate\n      must force its operands to match 'U' before emitting RTL.  */"}, {"sha": "79c9e023fa6bd8e0a4a613f85884ddc5e2d29d7d", "filename": "gcc/config/i386/athlon.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fi386%2Fathlon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fi386%2Fathlon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fathlon.md?ref=1e5f1716392c7915c55d95329ae59d1acce8592a", "patch": "@@ -203,7 +203,7 @@\n \t\t\t\t   (eq_attr \"memory\" \"load,both\")))\n \t\t\t \"athlon-vector,athlon-load,athlon-ieu,athlon-mult,athlon-ieu\")\n \n-;; Idiv can not execute in parallel with other instructions.  Dealing with it\n+;; Idiv cannot execute in parallel with other instructions.  Dealing with it\n ;; as with short latency vector instruction is good approximation avoiding\n ;; scheduler from trying too hard to can hide it's latency by overlap with\n ;; other instructions."}, {"sha": "54ee11e9d4a936caf3b501fe6cc8ddba1e044aad", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=1e5f1716392c7915c55d95329ae59d1acce8592a", "patch": "@@ -7790,7 +7790,7 @@\n   [(set_attr \"type\" \"idiv\")\n    (set_attr \"mode\" \"HI\")])\n \n-;; We can not use div/idiv for double division, because it causes\n+;; We cannot use div/idiv for double division, because it causes\n ;; \"division by zero\" on the overflow and that's not what we expect\n ;; from truncate.  Because true (non truncating) double division is\n ;; never generated, we can't create this insn anyway.\n@@ -18727,7 +18727,7 @@\n ;; Don't split NOTs with a displacement operand, because resulting XOR\n ;; will not be pairable anyway.\n ;;\n-;; On AMD K6, NOT is vector decoded with memory operand that can not be\n+;; On AMD K6, NOT is vector decoded with memory operand that cannot be\n ;; represented using a modRM byte.  The XOR replacement is long decoded,\n ;; so this split helps here as well.\n ;;\n@@ -20715,7 +20715,7 @@\n ;;                      TImode, since backend insist on eliminating casts\n ;;                      on memory operands\n ;; sse_andti3_sf_1 - the operation taking SF scalar operands.\n-;;                   We can not accept memory operand here as instruction reads\n+;;                   We cannot accept memory operand here as instruction reads\n ;;\t\t     whole scalar.  This is generated only post reload by GCC\n ;;\t\t     scalar float operations that expands to logicals (fabs)\n ;; sse_andti3_sf_2 - the operation taking SF scalar input and TImode"}, {"sha": "58a7dbc0c8317f58b8c352bfdcc8c96dc7d51786", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=1e5f1716392c7915c55d95329ae59d1acce8592a", "patch": "@@ -654,7 +654,7 @@\n   return parts.disp != NULL_RTX;\n })\n \n-;; Returns 1 if OP is memory operand that can not be represented\n+;; Returns 1 if OP is memory operand that cannot be represented\n ;; by the modRM array.\n (define_predicate \"long_memory_operand\"\n   (and (match_operand 0 \"memory_operand\")"}, {"sha": "0f7e689f24528bc1e383b8ff4ed6fede77698467", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=1e5f1716392c7915c55d95329ae59d1acce8592a", "patch": "@@ -4735,7 +4735,7 @@ rtx_needs_barrier (rtx x, struct reg_flags flags, int pred)\n \t}\n \n       /* For all ASM_OPERANDS, we must traverse the vector of input operands.\n-\t We can not just fall through here since then we would be confused\n+\t We cannot just fall through here since then we would be confused\n \t by the ASM_INPUT rtx inside ASM_OPERANDS, which do not indicate\n \t traditional asms unlike their normal usage.  */\n \n@@ -5727,7 +5727,7 @@ ia64_first_cycle_multipass_dfa_lookahead_guard (rtx insn)\n \n static rtx dfa_pre_cycle_insn;\n \n-/* We are about to being issuing INSN.  Return nonzero if we can not\n+/* We are about to being issuing INSN.  Return nonzero if we cannot\n    issue it on given cycle CLOCK and return zero if we should not sort\n    the ready queue on the next clock start.  */\n \n@@ -6276,7 +6276,7 @@ get_next_important_insn (rtx insn, rtx tail)\n    by structure bundle_state (see above).  If we generate the same\n    bundle state (key is automaton state after issuing the insns and\n    nops for it), we reuse already generated one.  As consequence we\n-   reject some decisions which can not improve the solution and\n+   reject some decisions which cannot improve the solution and\n    reduce memory for the algorithm.\n \n    When we reach the end of EBB (extended basic block), we choose the"}, {"sha": "695b43355f91e91bb777b810f2942563122c7cc5", "filename": "gcc/config/ia64/itanium1.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fia64%2Fitanium1.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fia64%2Fitanium1.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fitanium1.md?ref=1e5f1716392c7915c55d95329ae59d1acce8592a", "patch": "@@ -33,18 +33,18 @@\n      DEFINE_AUTOMATON).\n \n      All define_reservations and define_cpu_units should have unique\n-     names which can not be \"nothing\".\n+     names which cannot be \"nothing\".\n \n    o (exclusion_set string string) means that each CPU function unit\n-     in the first string can not be reserved simultaneously with each\n+     in the first string cannot be reserved simultaneously with each\n      unit whose name is in the second string and vise versa.  CPU\n      units in the string are separated by commas. For example, it is\n      useful for description CPU with fully pipelined floating point\n      functional unit which can execute simultaneously only single\n      floating point insns or only double floating point insns.\n \n    o (presence_set string string) means that each CPU function unit in\n-     the first string can not be reserved unless at least one of\n+     the first string cannot be reserved unless at least one of\n      pattern of units whose names are in the second string is\n      reserved.  This is an asymmetric relation.  CPU units or unit\n      patterns in the strings are separated by commas.  Pattern is one\n@@ -92,13 +92,13 @@\n      string are separated by commas.  Pattern is one unit name or unit\n      names separated by white-spaces.\n \n-     For example, it is useful for description that slot0 can not be\n+     For example, it is useful for description that slot0 cannot be\n      reserved after slot1 or slot2 reservation for a VLIW processor.\n      We could describe it by the following construction\n \n         (absence_set \"slot2\" \"slot0, slot1\")\n \n-     Or slot2 can not be reserved if slot0 and unit b0 are reserved or\n+     Or slot2 cannot be reserved if slot0 and unit b0 are reserved or\n      slot1 and unit b1 are reserved .  In this case we could write\n \n         (absence_set \"slot2\" \"slot0 b0, slot1 b1\")\n@@ -140,7 +140,7 @@\n      case, you describe common part and use one its name (the 1st\n      parameter) in regular expression in define_insn_reservation.  All\n      define_reservations, define results and define_cpu_units should\n-     have unique names which can not be \"nothing\".\n+     have unique names which cannot be \"nothing\".\n \n    o (define_insn_reservation name default_latency condition regexpr)\n      describes reservation of cpu functional units (the 3nd operand)"}, {"sha": "b591287950b8dccf339a47382d4640fa1a504861", "filename": "gcc/config/ia64/itanium2.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fia64%2Fitanium2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fia64%2Fitanium2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fitanium2.md?ref=1e5f1716392c7915c55d95329ae59d1acce8592a", "patch": "@@ -31,18 +31,18 @@\n      DEFINE_AUTOMATON).\n \n      All define_reservations and define_cpu_units should have unique\n-     names which can not be \"nothing\".\n+     names which cannot be \"nothing\".\n \n    o (exclusion_set string string) means that each CPU function unit\n-     in the first string can not be reserved simultaneously with each\n+     in the first string cannot be reserved simultaneously with each\n      unit whose name is in the second string and vise versa.  CPU\n      units in the string are separated by commas. For example, it is\n      useful for description CPU with fully pipelined floating point\n      functional unit which can execute simultaneously only single\n      floating point insns or only double floating point insns.\n \n    o (presence_set string string) means that each CPU function unit in\n-     the first string can not be reserved unless at least one of\n+     the first string cannot be reserved unless at least one of\n      pattern of units whose names are in the second string is\n      reserved.  This is an asymmetric relation.  CPU units or unit\n      patterns in the strings are separated by commas.  Pattern is one\n@@ -90,13 +90,13 @@\n      string are separated by commas.  Pattern is one unit name or unit\n      names separated by white-spaces.\n \n-     For example, it is useful for description that slot0 can not be\n+     For example, it is useful for description that slot0 cannot be\n      reserved after slot1 or slot2 reservation for a VLIW processor.\n      We could describe it by the following construction\n \n         (absence_set \"slot2\" \"slot0, slot1\")\n \n-     Or slot2 can not be reserved if slot0 and unit b0 are reserved or\n+     Or slot2 cannot be reserved if slot0 and unit b0 are reserved or\n      slot1 and unit b1 are reserved .  In this case we could write\n \n         (absence_set \"slot2\" \"slot0 b0, slot1 b1\")\n@@ -138,7 +138,7 @@\n      case, you describe common part and use one its name (the 1st\n      parameter) in regular expression in define_insn_reservation.  All\n      define_reservations, define results and define_cpu_units should\n-     have unique names which can not be \"nothing\".\n+     have unique names which cannot be \"nothing\".\n \n    o (define_insn_reservation name default_latency condition regexpr)\n      describes reservation of cpu functional units (the 3nd operand)\n@@ -398,7 +398,7 @@\n    \"2_stop\")\n \n ;;   The issue logic can reorder M slot insns between different subtypes\n-;; but can not reorder insn within the same subtypes.  The following\n+;; but cannot reorder insn within the same subtypes.  The following\n ;; constraint is enough to describe this.\n (final_presence_set \"2_um1\" \"2_um0\")\n (final_presence_set \"2_um3\" \"2_um2\")\n@@ -1274,7 +1274,7 @@\n    \"2b_stop\")\n \n ;;   The issue logic can reorder M slot insns between different subtypes\n-;; but can not reorder insn within the same subtypes.  The following\n+;; but cannot reorder insn within the same subtypes.  The following\n ;; constraint is enough to describe this.\n (final_presence_set \"2b_um1\" \"2b_um0\")\n (final_presence_set \"2b_um3\" \"2b_um2\")"}, {"sha": "6e6c0767ba369d359633db6dbee2935251886a3d", "filename": "gcc/config/iq2000/iq2000.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fiq2000%2Fiq2000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fiq2000%2Fiq2000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.md?ref=1e5f1716392c7915c55d95329ae59d1acce8592a", "patch": "@@ -2112,7 +2112,7 @@\n \n \f\n ;; For the rare case where we need to load an address into a register\n-;; that can not be recognized by the normal movsi/addsi instructions.\n+;; that cannot be recognized by the normal movsi/addsi instructions.\n ;; I have no idea how many insns this can actually generate.  It should\n ;; be rare, so over-estimating as 10 instructions should not have any\n ;; real performance impact."}, {"sha": "9abb4d6d278bb74f3d0fe0e4e30ce79384919b12", "filename": "gcc/config/libgloss.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Flibgloss.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Flibgloss.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flibgloss.h?ref=1e5f1716392c7915c55d95329ae59d1acce8592a", "patch": "@@ -29,7 +29,7 @@ Boston, MA 02111-1307, USA.  */\n \n /* This file used to force LINK_SPEC to be the null string, but that is not\n    correct.  LINK_SPEC is used to pass machine specific arguments to the\n-   linker and hence can not be redefined here.  LINK_SPEC is never used to\n+   linker and hence cannot be redefined here.  LINK_SPEC is never used to\n    specify startup files or libraries, so it should never conflict with\n    libgloss.  */\n "}, {"sha": "a29a25f81b74aa189164c6b776a517eee7a365de", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=1e5f1716392c7915c55d95329ae59d1acce8592a", "patch": "@@ -915,7 +915,7 @@ mcore_is_dead (rtx first, rtx reg)\n \t}\n     }\n \n-  /* No conclusive evidence either way, we can not take the chance\n+  /* No conclusive evidence either way, we cannot take the chance\n      that control flow hid the use from us -- \"I'm not dead yet\".  */\n   return 0;\n }"}, {"sha": "f0003ba2d6bbe1c3851a8a5caf223a35e15d4dd3", "filename": "gcc/config/mips/7000.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fmips%2F7000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fmips%2F7000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2F7000.md?ref=1e5f1716392c7915c55d95329ae59d1acce8592a", "patch": "@@ -60,7 +60,7 @@\n (exclusion_set \"fxuf_add\"\t\"fxuf_mpy,fxuf_divsqrt\")\n (exclusion_set \"fxuf_mpy\"\t\"fxuf_divsqrt\")\n \n-;; After branch any insn can not be issued.\n+;; After branch any insn cannot be issued.\n (absence_set \"rm7_iss0,rm7_iss1\" \"ixuf_branch\")\n \n ;;"}, {"sha": "3fe9d4d24d735b65f01b955f5cd43bab65c4860a", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=1e5f1716392c7915c55d95329ae59d1acce8592a", "patch": "@@ -4482,7 +4482,7 @@ override_options (void)\n   if (optimize > 2 && (target_flags_explicit & MASK_VR4130_ALIGN) == 0)\n     target_flags |= MASK_VR4130_ALIGN;\n \n-  /* When compiling for the mips16, we can not use floating point.  We\n+  /* When compiling for the mips16, we cannot use floating point.  We\n      record the original hard float value in mips16_hard_float.  */\n   if (TARGET_MIPS16)\n     {\n@@ -7470,7 +7470,7 @@ build_mips16_function_stub (FILE *file)\n   ASM_OUTPUT_ALIGN (file, floor_log2 (FUNCTION_BOUNDARY / BITS_PER_UNIT));\n \n   /* ??? If FUNCTION_NAME_ALREADY_DECLARED is defined, then we are\n-     within a .ent, and we can not emit another .ent.  */\n+     within a .ent, and we cannot emit another .ent.  */\n   if (!FUNCTION_NAME_ALREADY_DECLARED)\n     {\n       fputs (\"\\t.ent\\t\", file);\n@@ -7803,7 +7803,7 @@ build_mips16_call_stub (rtx retval, rtx fn, rtx arg_size, int fp_code)\n      Fortunately, this case is illegal, since it means that a function\n      was declared in two different ways in a single compilation.  */\n   if (fpret && ! l->fpret)\n-    error (\"can not handle inconsistent calls to `%s'\", fnname);\n+    error (\"cannot handle inconsistent calls to `%s'\", fnname);\n \n   /* If we are calling a stub which handles a floating point return\n      value, we need to arrange to save $18 in the prologue.  We do"}, {"sha": "840e0729af7ce36a146b769110da85384c95e551", "filename": "gcc/config/mips/r3900.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fmips%2Fr3900.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fmips%2Fr3900.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fr3900.h?ref=1e5f1716392c7915c55d95329ae59d1acce8592a", "patch": "@@ -34,4 +34,4 @@ Boston, MA 02111-1307, USA.  */\n #define SUBTARGET_CC1_SPEC \"\\\n %{mhard-float:%e-mhard-float not supported} \\\n %{msingle-float:%{msoft-float: \\\n-  %e-msingle-float and -msoft-float can not both be specified}}\"\n+  %e-msingle-float and -msoft-float cannot both be specified}}\""}, {"sha": "aff645baffa3a2415c5221a89ad4169e9b3da09c", "filename": "gcc/config/mips/sb1.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fmips%2Fsb1.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fmips%2Fsb1.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fsb1.md?ref=1e5f1716392c7915c55d95329ae59d1acce8592a", "patch": "@@ -207,7 +207,7 @@\n ;; unit has a latency of 5 cycles when the results goes to a LS unit (excluding\n ;; store data), otherwise a latency of 1 cycle.\n \n-;; ??? We can not handle latencies properly for simple alu instructions\n+;; ??? We cannot handle latencies properly for simple alu instructions\n ;; within the DFA pipeline model.  Latencies can be defined only from one\n ;; insn reservation to another.  We can't make them depend on which function\n ;; unit was used.  This isn't a DFA flaw.  There is a conflict here, as we"}, {"sha": "eb8fed105e038ecaf87505ea149860a25e8647f5", "filename": "gcc/config/pa/milli64.S", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fpa%2Fmilli64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fpa%2Fmilli64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fmilli64.S?ref=1e5f1716392c7915c55d95329ae59d1acce8592a", "patch": "@@ -1300,14 +1300,14 @@ GSYM($$divI_3)\n \t.export\t\t$$divI_3,millicode\n \tcomb,<,N\tx2,0,LREF(neg3)\n \n-\taddi\t\t1,x2,x2\t\t/* this can not overflow\t*/\n+\taddi\t\t1,x2,x2\t\t/* this cannot overflow\t*/\n \textru\t\tx2,1,2,x1\t/* multiply by 5 to get started */\n \tsh2add\t\tx2,x2,x2\n \tb\t\tLREF(pos)\n \taddc\t\tx1,0,x1\n \n LSYM(neg3)\n-\tsubi\t\t1,x2,x2\t\t/* this can not overflow\t*/\n+\tsubi\t\t1,x2,x2\t\t/* this cannot overflow\t*/\n \textru\t\tx2,1,2,x1\t/* multiply by 5 to get started */\n \tsh2add\t\tx2,x2,x2\n \tb\t\tLREF(neg)\n@@ -1328,14 +1328,14 @@ GSYM($$divI_5)\n \t.export\t\t$$divI_5,millicode\n \tcomb,<,N\tx2,0,LREF(neg5)\n \n-\taddi\t\t3,x2,t1\t\t/* this can not overflow\t*/\n+\taddi\t\t3,x2,t1\t\t/* this cannot overflow\t*/\n \tsh1add\t\tx2,t1,x2\t/* multiply by 3 to get started */\n \tb\t\tLREF(pos)\n \taddc\t\t0,0,x1\n \n LSYM(neg5)\n \tsub\t\t0,x2,x2\t\t/* negate x2\t\t\t*/\n-\taddi\t\t1,x2,x2\t\t/* this can not overflow\t*/\n+\taddi\t\t1,x2,x2\t\t/* this cannot overflow\t*/\n \tshd\t\t0,x2,31,x1\t/* get top bit (can be 1)\t*/\n \tsh1add\t\tx2,x2,x2\t/* multiply by 3 to get started */\n \tb\t\tLREF(neg)\n@@ -1373,7 +1373,7 @@ LSYM(neg6)\n GSYM($$divU_6)\n \t.export\t\t$$divU_6,millicode\n \textru\t\tx2,30,31,x2\t/* divide by 2 */\n-\taddi\t\t1,x2,x2\t\t/* can not carry */\n+\taddi\t\t1,x2,x2\t\t/* cannot carry */\n \tshd\t\t0,x2,30,x1\t/* multiply by 5 to get started */\n \tsh2add\t\tx2,x2,x2\n \tb\t\tLREF(pos)\n@@ -1408,7 +1408,7 @@ GSYM($$divI_10)\n \tcomb,<\t\tx2,0,LREF(neg10)\n \tcopy\t\t0,x1\n \textru\t\tx2,30,31,x2\t/* divide by 2 */\n-\taddib,TR\t1,x2,LREF(pos)\t/* add 1 (can not overflow)     */\n+\taddib,TR\t1,x2,LREF(pos)\t/* add 1 (cannot overflow)     */\n \tsh1add\t\tx2,x2,x2\t/* multiply by 3 to get started */\n \n LSYM(neg10)\n@@ -1455,7 +1455,7 @@ LSYM(neg12)\n GSYM($$divU_12)\n \t.export\t\t$$divU_12,millicode\n \textru\t\tx2,29,30,x2\t/* divide by 4   */\n-\taddi\t\t5,x2,t1\t\t/* can not carry */\n+\taddi\t\t5,x2,t1\t\t/* cannot carry */\n \tsh2add\t\tx2,t1,x2\t/* multiply by 5 to get started */\n \tb\t\tLREF(pos)\n \taddc\t\t0,0,x1\n@@ -1482,15 +1482,15 @@ GSYM($$divU_15)\n GSYM($$divI_17)\n \t.export\t\t$$divI_17,millicode\n \tcomb,<,n\tx2,0,LREF(neg17)\n-\taddi\t\t1,x2,x2\t\t/* this can not overflow */\n+\taddi\t\t1,x2,x2\t\t/* this cannot overflow */\n \tshd\t\t0,x2,28,t1\t/* multiply by 0xf to get started */\n \tshd\t\tx2,0,28,t2\n \tsub\t\tt2,x2,x2\n \tb\t\tLREF(pos_for_17)\n \tsubb\t\tt1,0,x1\n \n LSYM(neg17)\n-\tsubi\t\t1,x2,x2\t\t/* this can not overflow */\n+\tsubi\t\t1,x2,x2\t\t/* this cannot overflow */\n \tshd\t\t0,x2,28,t1\t/* multiply by 0xf to get started */\n \tshd\t\tx2,0,28,t2\n \tsub\t\tt2,x2,x2\n@@ -1540,7 +1540,7 @@ GSYM($$divI_7)\n \t.export\t\t$$divI_7,millicode\n \tcomb,<,n\tx2,0,LREF(neg7)\n LSYM(7)\n-\taddi\t\t1,x2,x2\t\t/* can not overflow */\n+\taddi\t\t1,x2,x2\t\t/* cannot overflow */\n \tshd\t\t0,x2,29,x1\n \tsh3add\t\tx2,x2,x2\n \taddc\t\tx1,0,x1\n@@ -1615,7 +1615,7 @@ GSYM($$divU_7)\n GSYM($$divI_9)\n \t.export\t\t$$divI_9,millicode\n \tcomb,<,n\tx2,0,LREF(neg9)\n-\taddi\t\t1,x2,x2\t\t/* can not overflow */\n+\taddi\t\t1,x2,x2\t\t/* cannot overflow */\n \tshd\t\t0,x2,29,t1\n \tshd\t\tx2,0,29,t2\n \tsub\t\tt2,x2,x2"}, {"sha": "e89be830b705cd90e778bc56a32cf35b6178af19", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=1e5f1716392c7915c55d95329ae59d1acce8592a", "patch": "@@ -1091,7 +1091,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n \n    This is for CSE to find several similar references, and only use one Z.\n \n-   X can either be a SYMBOL_REF or REG, but because combine can not\n+   X can either be a SYMBOL_REF or REG, but because combine cannot\n    perform a 4->2 combination we do nothing for SYMBOL_REF + D where\n    D will not fit in 14 bits.\n \n@@ -8108,13 +8108,13 @@ fmpyaddoperands (rtx *operands)\n       && ! rtx_equal_p (operands[3], operands[5]))\n     return 0;\n \n-  /* Inout operand of add can not conflict with any operands from multiply.  */\n+  /* Inout operand of add cannot conflict with any operands from multiply.  */\n   if (rtx_equal_p (operands[3], operands[0])\n      || rtx_equal_p (operands[3], operands[1])\n      || rtx_equal_p (operands[3], operands[2]))\n     return 0;\n \n-  /* multiply can not feed into addition operands.  */\n+  /* multiply cannot feed into addition operands.  */\n   if (rtx_equal_p (operands[4], operands[0])\n       || rtx_equal_p (operands[5], operands[0]))\n     return 0;\n@@ -8274,11 +8274,11 @@ fmpysuboperands (rtx *operands)\n   if (! rtx_equal_p (operands[3], operands[4]))\n     return 0;\n \n-  /* multiply can not feed into subtraction.  */\n+  /* multiply cannot feed into subtraction.  */\n   if (rtx_equal_p (operands[5], operands[0]))\n     return 0;\n \n-  /* Inout operand of sub can not conflict with any operands from multiply.  */\n+  /* Inout operand of sub cannot conflict with any operands from multiply.  */\n   if (rtx_equal_p (operands[3], operands[0])\n      || rtx_equal_p (operands[3], operands[1])\n      || rtx_equal_p (operands[3], operands[2]))\n@@ -8938,7 +8938,7 @@ pa_can_combine_p (rtx new, rtx anchor, rtx floater, int reversed, rtx dest,\n    delay slot of the millicode call -- thus they act more like traditional\n    CALL_INSNs.\n \n-   Note we can not consider side effects of the insn to be delayed because\n+   Note we cannot consider side effects of the insn to be delayed because\n    the branch and link insn will clobber the return pointer.  If we happened\n    to use the return pointer in the delay slot of the call, then we lose.\n "}, {"sha": "588b8059364aa17c68ae6f2bdc96436e14583d36", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=1e5f1716392c7915c55d95329ae59d1acce8592a", "patch": "@@ -1796,7 +1796,7 @@ do { \t\t\t\t\t\t\t\t\t\\\n    delay slot of the millicode call -- thus they act more like traditional\n    CALL_INSNs.\n \n-   Note we can not consider side effects of the insn to be delayed because\n+   Note we cannot consider side effects of the insn to be delayed because\n    the branch and link insn will clobber the return pointer.  If we happened\n    to use the return pointer in the delay slot of the call, then we lose.\n "}, {"sha": "662aa3bd65c004053dc713d4cf5964c1965a6ebf", "filename": "gcc/config/rs6000/8540.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Frs6000%2F8540.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e5f1716392c7915c55d95329ae59d1acce8592a/gcc%2Fconfig%2Frs6000%2F8540.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2F8540.md?ref=1e5f1716392c7915c55d95329ae59d1acce8592a", "patch": "@@ -22,7 +22,7 @@\n (define_cpu_unit \"ppc8540_decode_0,ppc8540_decode_1\" \"ppc8540_most\")\n \n ;; We don't simulate general issue queue (GIC).  If we have SU insn\n-;; and then SU1 insn, they can not be issued on the same cycle\n+;; and then SU1 insn, they cannot be issued on the same cycle\n ;; (although SU1 insn and then SU insn can be issued) because the SU\n ;; insn will go to SU1 from GIC0 entry.  Fortunately, the first cycle\n ;; multipass insn scheduling will find the situation and issue the SU1\n@@ -31,7 +31,7 @@\n \n ;; We could describe completion buffers slots in combination with the\n ;; retirement units and the order of completion but the result\n-;; automaton would behave in the same way because we can not describe\n+;; automaton would behave in the same way because we cannot describe\n ;; real latency time with taking in order completion into account.\n ;; Actually we could define the real latency time by querying reserved\n ;; automaton units but the current scheduler uses latency time before"}]}