{"sha": "7f6dd1ca73bc6675a1d5c2ce919c105138579a89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Y2ZGQxY2E3M2JjNjY3NWExZDVjMmNlOTE5YzEwNTEzODU3OWE4OQ==", "commit": {"author": {"name": "Gawain Bolton", "email": "gbolton@free.fr", "date": "2003-07-04T20:37:01Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2003-07-04T20:37:01Z"}, "message": "stl_tree.h: Performance and memory usage improvements.\n\n\n2003-07-04  Gawain Bolton  <gbolton@free.fr>\n\n\t* include/bits/stl_tree.h: Performance and memory usage\n\timprovements.\n\nFrom-SVN: r68936", "tree": {"sha": "8a81436075505f2ada01e5989c6acbbb43c9c006", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a81436075505f2ada01e5989c6acbbb43c9c006"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f6dd1ca73bc6675a1d5c2ce919c105138579a89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f6dd1ca73bc6675a1d5c2ce919c105138579a89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f6dd1ca73bc6675a1d5c2ce919c105138579a89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f6dd1ca73bc6675a1d5c2ce919c105138579a89/comments", "author": null, "committer": null, "parents": [{"sha": "c3b3975a546350aa2b908b9e4acf41dc0d798890", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3b3975a546350aa2b908b9e4acf41dc0d798890", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3b3975a546350aa2b908b9e4acf41dc0d798890"}], "stats": {"total": 170, "additions": 104, "deletions": 66}, "files": [{"sha": "75b511dab878bb6860d1f5ee528090476e332776", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f6dd1ca73bc6675a1d5c2ce919c105138579a89/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f6dd1ca73bc6675a1d5c2ce919c105138579a89/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=7f6dd1ca73bc6675a1d5c2ce919c105138579a89", "patch": "@@ -1,3 +1,8 @@\n+2003-07-04  Gawain Bolton  <gbolton@free.fr>\n+\n+\t* include/bits/stl_tree.h: Performance and memory usage\n+\timprovements.\n+\n 2003-07-04  H.J. Lu <hongjiu.lu@intel.com>\n \n \t* Makefile.am: Replace PWD with PWD_COMMAND."}, {"sha": "33c8ebd7915e89947b3d0f83a0fb149c3728caf9", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 99, "deletions": 66, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f6dd1ca73bc6675a1d5c2ce919c105138579a89/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f6dd1ca73bc6675a1d5c2ce919c105138579a89/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=7f6dd1ca73bc6675a1d5c2ce919c105138579a89", "patch": "@@ -192,7 +192,7 @@ namespace std\n       typedef _Rb_tree_node<_Val>* _Link_type;\n       \n       _Rb_tree_iterator() {}\n-      _Rb_tree_iterator(_Link_type __x) { _M_node = __x; }\n+      _Rb_tree_iterator(_Rb_tree_node_base* __x) { _M_node = __x; }\n       _Rb_tree_iterator(const iterator& __it) { _M_node = __it._M_node; }\n \n       reference \n@@ -528,13 +528,13 @@ namespace std\n       get_allocator() const { return _M_node_allocator; }\n \n       _Rb_tree_alloc_base(const allocator_type& __a)\n-      : _M_node_allocator(__a), _M_header(0) {}\n+      : _M_node_allocator(__a) {}\n \n     protected:\n       typename _Alloc_traits<_Rb_tree_node<_Tp>, _Alloc>::allocator_type\n       _M_node_allocator;\n \n-      _Rb_tree_node<_Tp>* _M_header;\n+      _Rb_tree_node_base _M_header;\n       \n       _Rb_tree_node<_Tp>* \n       _M_get_node()  { return _M_node_allocator.allocate(1); }\n@@ -552,10 +552,10 @@ namespace std\n     typedef typename _Alloc_traits<_Tp, _Alloc>::allocator_type allocator_type;\n       allocator_type get_allocator() const { return allocator_type(); }\n \n-      _Rb_tree_alloc_base(const allocator_type&) : _M_header(0) {}\n+      _Rb_tree_alloc_base(const allocator_type&) {}\n \n     protected:\n-      _Rb_tree_node<_Tp>* _M_header;\n+      _Rb_tree_node_base _M_header;\n       \n       typedef typename _Alloc_traits<_Rb_tree_node<_Tp>, _Alloc>::_Alloc_type\n       _Alloc_type;\n@@ -576,8 +576,7 @@ namespace std\n       typedef typename _Base::allocator_type allocator_type;\n \n       _Rb_tree_base(const allocator_type& __a) \n-      : _Base(__a) { this->_M_header = _M_get_node(); }\n-      ~_Rb_tree_base() { _M_put_node(this->_M_header); }\n+      : _Base(__a) {}\n     };\n \n \n@@ -645,14 +644,17 @@ namespace std\n       _Compare _M_key_compare;\n \n       _Link_type& \n-      _M_root() const { return (_Link_type&) this->_M_header->_M_parent; }\n+      _M_root() const { return (_Link_type&) this->_M_header._M_parent; }\n \n       _Link_type& \n-      _M_leftmost() const { return (_Link_type&) this->_M_header->_M_left; }\n+      _M_leftmost() const { return (_Link_type&) this->_M_header._M_left; }\n \n       _Link_type& \n-      _M_rightmost() const { return (_Link_type&) this->_M_header->_M_right; }\n+      _M_rightmost() const { return (_Link_type&) this->_M_header._M_right; }\n \n+      _Link_type\n+      _M_end() const { return (_Link_type) &this->_M_header; }\n+      \n       static _Link_type& \n       _S_left(_Link_type __x) { return (_Link_type&)(__x->_M_left); }\n \n@@ -668,9 +670,6 @@ namespace std\n       static const _Key& \n       _S_key(_Link_type __x) { return _KeyOfValue()(_S_value(__x)); }\n \n-      static _Rb_tree_color& \n-      _S_color(_Link_type __x) { return __x->_M_color; }\n-\n       static _Link_type& \n       _S_left(_Base_ptr __x) { return (_Link_type&)(__x->_M_left); }\n \n@@ -687,7 +686,7 @@ namespace std\n       _S_key(_Base_ptr __x) { return _KeyOfValue()(_S_value(_Link_type(__x)));} \n \n       static _Rb_tree_color&\n-      _S_color(_Base_ptr __x) { return (_Link_type(__x)->_M_color); }\n+      _S_color(_Base_ptr __x) { return __x->_M_color; }\n \n       static _Link_type \n       _S_minimum(_Link_type __x) \n@@ -737,8 +736,8 @@ namespace std\n \t  _M_empty_initialize();\n \telse \n \t  {\n-\t    _S_color(this->_M_header) = _S_red;\n-\t    _M_root() = _M_copy(__x._M_root(), this->_M_header);\n+\t    _S_color(&this->_M_header) = _S_red;\n+\t    _M_root() = _M_copy(__x._M_root(), _M_end());\n \t    _M_leftmost() = _S_minimum(_M_root());\n \t    _M_rightmost() = _S_maximum(_M_root());\n \t  }\n@@ -753,11 +752,11 @@ namespace std\n     private:\n       void _M_empty_initialize() \n       {\n-\t_S_color(this->_M_header) = _S_red; // used to distinguish header from \n-\t// __root, in iterator.operator++\n+\t// Used to distinguish header from __root, in iterator.operator++.\n+\t_S_color(&this->_M_header) = _S_red; \n \t_M_root() = 0;\n-\t_M_leftmost() = this->_M_header;\n-\t_M_rightmost() = this->_M_header;\n+\t_M_leftmost() = _M_end();\n+\t_M_rightmost() = _M_end();\n       }\n \n     public:    \n@@ -772,10 +771,10 @@ namespace std\n       begin() const { return _M_leftmost(); }\n \n       iterator \n-      end() { return this->_M_header; }\n+      end() { return &this->_M_header; }\n \n-      const_iterator \n-      end() const { return this->_M_header; }\n+      const_iterator\n+      end() const { return const_cast<_Base_ptr>(&this->_M_header); }\n \n       reverse_iterator \n       rbegin() { return reverse_iterator(end()); }\n@@ -799,12 +798,7 @@ namespace std\n       max_size() const { return size_type(-1); }\n \n       void \n-      swap(_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __t) \n-      {\n-\tstd::swap(this->_M_header, __t._M_header);\n-\tstd::swap(_M_node_count, __t._M_node_count);\n-\tstd::swap(_M_key_compare, __t._M_key_compare);\n-      }\n+      swap(_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __t);\n     \n       // Insert/erase.\n       pair<iterator,bool> \n@@ -845,9 +839,9 @@ namespace std\n \tif (_M_node_count != 0) \n \t  {\n \t    _M_erase(_M_root());\n-\t    _M_leftmost() = this->_M_header;\n+\t    _M_leftmost() = _M_end();\n \t    _M_root() = 0;\n-\t    _M_rightmost() = this->_M_header;\n+\t    _M_rightmost() = _M_end();\n \t    _M_node_count = 0;\n \t  }\n       }      \n@@ -955,12 +949,12 @@ namespace std\n \t  if (__x._M_root() == 0) \n \t    {\n \t      _M_root() = 0;\n-\t      _M_leftmost() = this->_M_header;\n-\t      _M_rightmost() = this->_M_header;\n+\t      _M_leftmost() = _M_end();\n+\t      _M_rightmost() = _M_end();\n \t    }\n \t  else \n \t    {\n-\t      _M_root() = _M_copy(__x._M_root(), this->_M_header);\n+\t      _M_root() = _M_copy(__x._M_root(), _M_end());\n \t      _M_leftmost() = _S_minimum(_M_root());\n \t      _M_rightmost() = _S_maximum(_M_root());\n \t      _M_node_count = __x._M_node_count;\n@@ -979,13 +973,13 @@ namespace std\n       _Link_type __y = (_Link_type) __y_;\n       _Link_type __z;\n       \n-      if (__y == this->_M_header || __x != 0 || \n+      if (__y == &this->_M_header || __x != 0 || \n \t  _M_key_compare(_KeyOfValue()(__v), _S_key(__y))) \n \t{\n \t  __z = _M_create_node(__v);\n \t  _S_left(__y) = __z;               // also makes _M_leftmost() = __z \n-\t  //    when __y == _M_header\n-\t  if (__y == this->_M_header) \n+\t  //    when __y == &_M_header\n+\t  if (__y == &this->_M_header) \n \t    {\n \t      _M_root() = __z;\n \t      _M_rightmost() = __z;\n@@ -1004,7 +998,7 @@ namespace std\n       _S_parent(__z) = __y;\n       _S_left(__z) = 0;\n       _S_right(__z) = 0;\n-      _Rb_tree_rebalance(__z, this->_M_header->_M_parent);\n+      _Rb_tree_rebalance(__z, this->_M_header._M_parent);\n       ++_M_node_count;\n       return iterator(__z);\n     }\n@@ -1015,7 +1009,7 @@ namespace std\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     insert_equal(const _Val& __v)\n     {\n-      _Link_type __y = this->_M_header;\n+      _Link_type __y = _M_end();\n       _Link_type __x = _M_root();\n       while (__x != 0) \n \t{\n@@ -1026,14 +1020,59 @@ namespace std\n       return _M_insert(__x, __y, __v);\n     }\n \n+  template<typename _Key, typename _Val, typename _KeyOfValue, \n+           typename _Compare, typename _Alloc>\n+    void\n+    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n+    swap(_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __t)\n+    {\n+      if (_M_root() == 0)\n+      {\n+\tif (__t._M_root() != 0)\n+\t{\n+\t  _M_root() = __t._M_root();\n+\t  _M_leftmost() = __t._M_leftmost();\n+\t  _M_rightmost() = __t._M_rightmost();\n+          _M_root()->_M_parent = _M_end();\n+\n+\t  __t._M_root() = 0;\n+\t  __t._M_leftmost() = __t._M_end();\n+\t  __t._M_rightmost() = __t._M_end();\n+\t}\n+      }\n+      else if (__t._M_root() == 0)\n+      {\n+\t__t._M_root() = _M_root();\n+\t__t._M_leftmost() = _M_leftmost();\n+\t__t._M_rightmost() = _M_rightmost();\n+        __t._M_root()->_M_parent = __t._M_end();\n+\n+\t_M_root() = 0;\n+\t_M_leftmost() = _M_end();\n+\t_M_rightmost() = _M_end();\n+      }\n+      else\n+      {\n+\tstd::swap(_M_root(),__t._M_root());\n+\tstd::swap(_M_leftmost(),__t._M_leftmost());\n+\tstd::swap(_M_rightmost(),__t._M_rightmost());\n+\n+\t_M_root()->_M_parent = _M_end();\n+\t__t._M_root()->_M_parent = __t._M_end();\n+      }\n+      // No need to swap header's color as it does not change.\n+      std::swap(this->_M_node_count, __t._M_node_count);\n+      std::swap(this->_M_key_compare, __t._M_key_compare);\n+    }\n+\n   template<typename _Key, typename _Val, typename _KeyOfValue, \n            typename _Compare, typename _Alloc>\n     pair<typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator, \n     bool>\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     insert_unique(const _Val& __v)\n     {\n-      _Link_type __y = this->_M_header;\n+      _Link_type __y = _M_end();\n       _Link_type __x = _M_root();\n       bool __comp = true;\n       while (__x != 0) \n@@ -1060,7 +1099,7 @@ namespace std\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n     insert_unique(iterator __position, const _Val& __v)\n     {\n-      if (__position._M_node == this->_M_header->_M_left) \n+      if (__position._M_node == this->_M_header._M_left) \n \t{ \n \t  // begin()\n \t  if (size() > 0 && \n@@ -1070,7 +1109,7 @@ namespace std\n \t  else\n \t    return insert_unique(__v).first;\n \t} \n-      else if (__position._M_node == this->_M_header) \n+      else if (__position._M_node == &this->_M_header) \n \t{ \n \t  // end()\n \t  if (_M_key_compare(_S_key(_M_rightmost()), _KeyOfValue()(__v)))\n@@ -1102,7 +1141,7 @@ namespace std\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     insert_equal(iterator __position, const _Val& __v)\n     {\n-      if (__position._M_node == this->_M_header->_M_left) \n+      if (__position._M_node == this->_M_header._M_left) \n \t{ \n \t  // begin()\n \t  if (size() > 0 && \n@@ -1112,7 +1151,7 @@ namespace std\n \t  else\n \t    return insert_equal(__v);\n \t} \n-      else if (__position._M_node == this->_M_header) \n+      else if (__position._M_node == &this->_M_header) \n \t{\n \t  // end()\n \t  if (!_M_key_compare(_KeyOfValue()(__v), _S_key(_M_rightmost())))\n@@ -1168,9 +1207,9 @@ namespace std\n     {\n       _Link_type __y = \n \t(_Link_type) _Rb_tree_rebalance_for_erase(__position._M_node,\n-\t\t\t\t\t\t  this->_M_header->_M_parent,\n-\t\t\t\t\t\t  this->_M_header->_M_left,\n-\t\t\t\t\t\t  this->_M_header->_M_right);\n+\t\t\t\t\t\t  this->_M_header._M_parent,\n+\t\t\t\t\t\t  this->_M_header._M_left,\n+\t\t\t\t\t\t  this->_M_header._M_right);\n       destroy_node(__y);\n       --_M_node_count;\n     }\n@@ -1264,9 +1303,8 @@ namespace std\n     typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator \n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::find(const _Key& __k)\n     {\n-      _Link_type __y\n-\t= this->_M_header;  // Last node which is not less than __k. \n-      _Link_type __x = _M_root();  // Current node. \n+      _Link_type __y = _M_end(); // Last node which is not less than __k. \n+      _Link_type __x = _M_root(); // Current node. \n       \n       while (__x != 0) \n \tif (!_M_key_compare(_S_key(__x), __k))\n@@ -1285,8 +1323,7 @@ namespace std\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     find(const _Key& __k) const\n     {\n-      _Link_type __y\n-\t= this->_M_header; // Last node which is not less than __k. \n+      _Link_type __y = _M_end(); // Last node which is not less than __k. \n       _Link_type __x = _M_root(); // Current node. \n  \n      while (__x != 0) \n@@ -1318,9 +1355,8 @@ namespace std\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     lower_bound(const _Key& __k)\n     {\n-      _Link_type __y\n-\t= this->_M_header; /* Last node which is not less than __k. */\n-      _Link_type __x = _M_root(); /* Current node. */\n+      _Link_type __y = _M_end(); // Last node which is not less than __k\n+      _Link_type __x = _M_root(); // Current node.\n       \n       while (__x != 0) \n \tif (!_M_key_compare(_S_key(__x), __k))\n@@ -1337,9 +1373,8 @@ namespace std\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     lower_bound(const _Key& __k) const\n     {\n-      _Link_type __y\n-\t= this->_M_header; /* Last node which is not less than __k. */\n-      _Link_type __x = _M_root(); /* Current node. */\n+      _Link_type __y = _M_end(); // Last node which is not less than __k.\n+      _Link_type __x = _M_root(); // Current node.\n       \n       while (__x != 0) \n \tif (!_M_key_compare(_S_key(__x), __k))\n@@ -1356,9 +1391,8 @@ namespace std\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     upper_bound(const _Key& __k)\n     {\n-      _Link_type __y\n-\t= this->_M_header; /* Last node which is greater than __k. */\n-      _Link_type __x = _M_root(); /* Current node. */\n+      _Link_type __y = _M_end(); // Last node which is greater than __k.\n+      _Link_type __x = _M_root(); // Current node.\n       \n       while (__x != 0) \n \tif (_M_key_compare(__k, _S_key(__x)))\n@@ -1375,9 +1409,8 @@ namespace std\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     upper_bound(const _Key& __k) const\n     {\n-      _Link_type __y\n-\t= this->_M_header; /* Last node which is greater than __k. */\n-      _Link_type __x = _M_root(); /* Current node. */\n+      _Link_type __y = _M_end(); // Last node which is greater than __k.\n+      _Link_type __x = _M_root(); // Current node.\n       \n       while (__x != 0) \n \tif (_M_key_compare(__k, _S_key(__x)))\n@@ -1434,8 +1467,8 @@ namespace std\n     {\n     if (_M_node_count == 0 || begin() == end())\n       return _M_node_count == 0 && begin() == end() &&\n-\tthis->_M_header->_M_left == this->_M_header\n-\t&& this->_M_header->_M_right == this->_M_header;\n+\tthis->_M_header._M_left == &this->_M_header &&\n+\tthis->_M_header._M_right == &this->_M_header;\n   \n     int __len = __black_count(_M_leftmost(), _M_root());\n     for (const_iterator __it = begin(); __it != end(); ++__it) "}]}