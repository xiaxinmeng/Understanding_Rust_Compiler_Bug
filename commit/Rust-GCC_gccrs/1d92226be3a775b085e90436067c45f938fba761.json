{"sha": "1d92226be3a775b085e90436067c45f938fba761", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQ5MjIyNmJlM2E3NzViMDg1ZTkwNDM2MDY3YzQ1ZjkzOGZiYTc2MQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2011-02-14T15:34:44Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-02-14T15:34:44Z"}, "message": "re PR fortran/47642 (real(kind=16) - libquadmath - segfault on amd64 FreeBSD)\n\n\tPR fortran/47642\n\t* libquadmath.texi (quadmath_snprintf): Document.\n\t(quadmath_flt128tostr): Remove.\n\t* Makefile.am (libquadmath_la_SOURCES): Add printf/*.c.\n\tRemove  quadmath_io.c, gdtoa/gdtoa.c, gdtoa/g__fmt.c,\n\tgdtoa/g_Qfmt.c, gdtoa/dmisc.c and gdtoa/ulp.c.\n\t* quadmath.h (quadmath_snprintf): New prototype.\n\t(quadmath_flt128tostr): Remove.\n\t* quadmath_weak.h (quadmath_snprintf): Add.\n\t(quadmath_flt128tostr): Remove.\n\t* configure.ac: New AC_CHECK_HEADERS headers: langinfo.h, wchar.h,\n\twctype.h, limits.h, ctype.h, printf.h, errno.h.\n\t(AC_USE_SYSTEM_EXTENSIONS): Add.\n\t(HAVE_HIDDEN_VISIBILITY, HAVE_PRINTF_HOOKS,\n\tUSE_LOCALE_SUPPORT, USE_I18N_NUMBER_H): New checks.\n\t* quadmath.map (QUADMATH_1.0): Add quadmath_snprintf.  Remove\n\tquadmath_flt128tostr.\n\t* printf/printf_fphex.c: New file.\n\t* printf/_itowa.h: New file.\n\t* printf/mul_n.c: New file.\n\t* printf/quadmath-printf.h: New file.\n\t* printf/submul_1.c: New file.\n\t* printf/quadmath-printf.c: New file.\n\t* printf/gmp-impl.h: New file.\n\t* printf/lshift.c: New file.\n\t* printf/fpioconst.h: New file.\n\t* printf/add_n.c: New file.\n\t* printf/cmp.c: New file.\n\t* printf/sub_n.c: New file.\n\t* printf/mul.c: New file.\n\t* printf/divrem.c: New file.\n\t* printf/addmul_1.c: New file.\n\t* printf/printf_fp.c: New file.\n\t* printf/_itoa.h: New file.\n\t* printf/fpioconst.c: New file.\n\t* printf/_i18n_number.h: New file.\n\t* printf/flt1282mpn.c: New file.\n\t* printf/rshift.c: New file.\n\t* printf/mul_1.c: New file.\n\t* quadmath_io.c: Removed.\n\t* gdtoa/gdtoa.c: Removed.\n\t* gdtoa/g__fmt.c: Removed.\n\t* gdtoa/g_Qfmt.c: Removed.\n\t* gdtoa/dmisc.c: Removed.\n\t* gdtoa/ulp.c: Removed.\n\t* config.h.in: Regenerated.\n\t* configure: Regenerated.\n\t* Makefile.in: Regenerated.\n\n\t* io/write_float.def (DTOAQ): Use quadmath_snprintf instead of\n\tquadmath_flt128tostr.\n\t* io/transfer128.c (tmp2): Initialize to quadmath_snprintf instead\n\tof quadmath_flt128tostr.\n\nFrom-SVN: r170135", "tree": {"sha": "a69f03ba3c677008fe5633e1a0886cffc77d95b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a69f03ba3c677008fe5633e1a0886cffc77d95b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d92226be3a775b085e90436067c45f938fba761", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d92226be3a775b085e90436067c45f938fba761", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d92226be3a775b085e90436067c45f938fba761", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d92226be3a775b085e90436067c45f938fba761/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "944f4bb398aaf3d25c71a5b12ca9626d2c5f5e99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/944f4bb398aaf3d25c71a5b12ca9626d2c5f5e99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/944f4bb398aaf3d25c71a5b12ca9626d2c5f5e99"}], "stats": {"total": 10197, "additions": 6937, "deletions": 3260}, "files": [{"sha": "71a6329562c9ee1b0b6a15c5488b0127909933d7", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -1,3 +1,11 @@\n+2011-02-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/47642\n+\t* io/write_float.def (DTOAQ): Use quadmath_snprintf instead of\n+\tquadmath_flt128tostr.\n+\t* io/transfer128.c (tmp2): Initialize to quadmath_snprintf instead\n+\tof quadmath_flt128tostr.\n+\n 2011-02-13  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \t* Makefile.in: Regenerate."}, {"sha": "d94ccacc0bb3dbe5825b10699b3f8b5be9b1a650", "filename": "libgfortran/io/transfer128.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libgfortran%2Fio%2Ftransfer128.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libgfortran%2Fio%2Ftransfer128.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer128.c?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2010\n+/* Copyright (C) 2010, 2011\n    Free Software Foundation, Inc.\n \n This file is part of the GNU Fortran runtime library (libgfortran).\n@@ -62,12 +62,12 @@ export_proto(transfer_complex128_write);\n \n \n /* Make sure that libquadmath is pulled in. The functions strtoflt128\n-   and quadmath_flt128tostr are weakly referrenced in convert_real and\n+   and quadmath_snprintf are weakly referrenced in convert_real and\n    write_float; the pointer assignment with USED attribute make sure\n    that there is a non-weakref dependence if the quadmath functions\n    are used. That avoids segfault when libquadmath is statically linked.  */\n static void __attribute__((used)) *tmp1 = strtoflt128;\n-static void __attribute__((used)) *tmp2 = quadmath_flt128tostr;\n+static void __attribute__((used)) *tmp2 = quadmath_snprintf;\n \n void\n transfer_real128 (st_parameter_dt *dtp, void *p, int kind)"}, {"sha": "29b8f1f16811ca61b65c0414e97118dd97d27d5d", "filename": "libgfortran/io/write_float.def", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libgfortran%2Fio%2Fwrite_float.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libgfortran%2Fio%2Fwrite_float.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite_float.def?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n+/* Copyright (C) 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n    Write float code factoring to this file by Jerry DeLisle   \n    F2003 I/O support contributed by Jerry DeLisle\n@@ -1000,7 +1000,9 @@ sprintf (buffer, \"%+-#\" STR(MIN_FIELD_WIDTH) \".*\" \\\n \n #if defined(GFC_REAL_16_IS_FLOAT128)\n #define DTOAQ \\\n-__qmath_(quadmath_flt128tostr) (buffer, size, ndigits - 1, tmp);\n+__qmath_(quadmath_snprintf) (buffer, sizeof buffer, \\\n+\t\t\t     \"%+-#\" STR(MIN_FIELD_WIDTH) \".*\" \\\n+\t\t\t     \"Qe\", ndigits - 1, tmp);\n #endif\n \n #define WRITE_FLOAT(x,y)\\"}, {"sha": "c17753c8528ace5795f38b21fd45e3e10f5ecbcc", "filename": "libquadmath/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2FChangeLog?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -1,3 +1,54 @@\n+2011-02-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/47642\n+\t* libquadmath.texi (quadmath_snprintf): Document.\n+\t(quadmath_flt128tostr): Remove.\n+\t* Makefile.am (libquadmath_la_SOURCES): Add printf/*.c.\n+\tRemove  quadmath_io.c, gdtoa/gdtoa.c, gdtoa/g__fmt.c,\n+\tgdtoa/g_Qfmt.c, gdtoa/dmisc.c and gdtoa/ulp.c.\n+\t* quadmath.h (quadmath_snprintf): New prototype.\n+\t(quadmath_flt128tostr): Remove.\n+\t* quadmath_weak.h (quadmath_snprintf): Add.\n+\t(quadmath_flt128tostr): Remove.\n+\t* configure.ac: New AC_CHECK_HEADERS headers: langinfo.h, wchar.h,\n+\twctype.h, limits.h, ctype.h, printf.h, errno.h.\n+\t(AC_USE_SYSTEM_EXTENSIONS): Add.\n+\t(HAVE_HIDDEN_VISIBILITY, HAVE_PRINTF_HOOKS,\n+\tUSE_LOCALE_SUPPORT, USE_I18N_NUMBER_H): New checks.\n+\t* quadmath.map (QUADMATH_1.0): Add quadmath_snprintf.  Remove\n+\tquadmath_flt128tostr.\n+\t* printf/printf_fphex.c: New file.\n+\t* printf/_itowa.h: New file.\n+\t* printf/mul_n.c: New file.\n+\t* printf/quadmath-printf.h: New file.\n+\t* printf/submul_1.c: New file.\n+\t* printf/quadmath-printf.c: New file.\n+\t* printf/gmp-impl.h: New file.\n+\t* printf/lshift.c: New file.\n+\t* printf/fpioconst.h: New file.\n+\t* printf/add_n.c: New file.\n+\t* printf/cmp.c: New file.\n+\t* printf/sub_n.c: New file.\n+\t* printf/mul.c: New file.\n+\t* printf/divrem.c: New file.\n+\t* printf/addmul_1.c: New file.\n+\t* printf/printf_fp.c: New file.\n+\t* printf/_itoa.h: New file.\n+\t* printf/fpioconst.c: New file.\n+\t* printf/_i18n_number.h: New file.\n+\t* printf/flt1282mpn.c: New file.\n+\t* printf/rshift.c: New file.\n+\t* printf/mul_1.c: New file.\n+\t* quadmath_io.c: Removed.\n+\t* gdtoa/gdtoa.c: Removed.\n+\t* gdtoa/g__fmt.c: Removed.\n+\t* gdtoa/g_Qfmt.c: Removed.\n+\t* gdtoa/dmisc.c: Removed.\n+\t* gdtoa/ulp.c: Removed.\n+\t* config.h.in: Regenerated.\n+\t* configure: Regenerated.\n+\t* Makefile.in: Regenerated.\n+\n 2011-02-13  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \t* Makefile.in: Regenerate."}, {"sha": "411720d64ccaca7e8782295c0245efaad9d29cb4", "filename": "libquadmath/Makefile.am", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2FMakefile.am?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -45,10 +45,9 @@ libsubincludedir = $(libdir)/gcc/$(target_alias)/$(gcc_version)/include\n libquadmath_la_SOURCES = \\\n   gdtoa/arith.h gdtoa/gdtoa_fltrnds.h gdtoa/gd_qnan.h gdtoa/gdtoaimp.h \\\n   gdtoa/gdtoa.h quadmath-imp.h \\\n-  gdtoa/dmisc.c gdtoa/gdtoa.c gdtoa/hd_init.c gdtoa/smisc.c gdtoa/sum.c \\\n-  gdtoa/g_Qfmt.c gdtoa/gethex.c gdtoa/hexnan.c gdtoa/strtodg.c \\\n-  gdtoa/ulp.c gdtoa/g__fmt.c gdtoa/gmisc.c gdtoa/misc.c gdtoa/strtopQ.c \\\n-  quadmath_io.c \\\n+  gdtoa/hd_init.c gdtoa/smisc.c gdtoa/sum.c \\\n+  gdtoa/gethex.c gdtoa/hexnan.c gdtoa/strtodg.c \\\n+  gdtoa/gmisc.c gdtoa/misc.c gdtoa/strtopQ.c \\\n   math/acoshq.c math/fmodq.c math/acosq.c math/frexpq.c \\\n   math/rem_pio2q.c math/asinhq.c math/hypotq.c math/remainderq.c \\\n   math/asinq.c math/rintq.c math/atan2q.c math/isinfq.c \\\n@@ -65,7 +64,11 @@ libquadmath_la_SOURCES = \\\n   math/cacoshq.c math/cacosq.c math/casinhq.c math/casinq.c \\\n   math/catanhq.c math/catanq.c math/cimagq.c math/conjq.c math/cprojq.c \\\n   math/crealq.c math/fdimq.c math/fmaxq.c math/fminq.c math/ilogbq.c \\\n-  math/llrintq.c math/log2q.c math/lrintq.c math/nearbyintq.c math/remquoq.c\n+  math/llrintq.c math/log2q.c math/lrintq.c math/nearbyintq.c math/remquoq.c \\\n+  printf/addmul_1.c printf/add_n.c printf/cmp.c printf/divrem.c \\\n+  printf/flt1282mpn.c printf/fpioconst.c printf/lshift.c printf/mul_1.c \\\n+  printf/mul_n.c printf/mul.c printf/printf_fphex.c printf/printf_fp.c \\\n+  printf/quadmath-printf.c printf/rshift.c printf/submul_1.c printf/sub_n.c\n \n \n # Work around what appears to be a GNU make bug handling MAKEFLAGS"}, {"sha": "a70179ddc8f8463c9bc8099b4807a42f131e7327", "filename": "libquadmath/Makefile.in", "status": "modified", "additions": 111, "deletions": 36, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2FMakefile.in?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -87,14 +87,11 @@ am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(infodir)\" \\\n \t\"$(DESTDIR)$(libsubincludedir)\"\n LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n am__dirstamp = $(am__leading_dot)dirstamp\n-@BUILD_LIBQUADMATH_TRUE@am_libquadmath_la_OBJECTS = gdtoa/dmisc.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tgdtoa/gdtoa.lo gdtoa/hd_init.lo \\\n+@BUILD_LIBQUADMATH_TRUE@am_libquadmath_la_OBJECTS = gdtoa/hd_init.lo \\\n @BUILD_LIBQUADMATH_TRUE@\tgdtoa/smisc.lo gdtoa/sum.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tgdtoa/g_Qfmt.lo gdtoa/gethex.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tgdtoa/hexnan.lo gdtoa/strtodg.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tgdtoa/ulp.lo gdtoa/g__fmt.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tgdtoa/gmisc.lo gdtoa/misc.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tgdtoa/strtopQ.lo quadmath_io.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tgdtoa/gethex.lo gdtoa/hexnan.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tgdtoa/strtodg.lo gdtoa/gmisc.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tgdtoa/misc.lo gdtoa/strtopQ.lo \\\n @BUILD_LIBQUADMATH_TRUE@\tmath/acoshq.lo math/fmodq.lo \\\n @BUILD_LIBQUADMATH_TRUE@\tmath/acosq.lo math/frexpq.lo \\\n @BUILD_LIBQUADMATH_TRUE@\tmath/rem_pio2q.lo math/asinhq.lo \\\n@@ -133,7 +130,16 @@ am__dirstamp = $(am__leading_dot)dirstamp\n @BUILD_LIBQUADMATH_TRUE@\tmath/fminq.lo math/ilogbq.lo \\\n @BUILD_LIBQUADMATH_TRUE@\tmath/llrintq.lo math/log2q.lo \\\n @BUILD_LIBQUADMATH_TRUE@\tmath/lrintq.lo math/nearbyintq.lo \\\n-@BUILD_LIBQUADMATH_TRUE@\tmath/remquoq.lo\n+@BUILD_LIBQUADMATH_TRUE@\tmath/remquoq.lo printf/addmul_1.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tprintf/add_n.lo printf/cmp.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tprintf/divrem.lo printf/flt1282mpn.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tprintf/fpioconst.lo printf/lshift.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tprintf/mul_1.lo printf/mul_n.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tprintf/mul.lo printf/printf_fphex.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tprintf/printf_fp.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tprintf/quadmath-printf.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tprintf/rshift.lo printf/submul_1.lo \\\n+@BUILD_LIBQUADMATH_TRUE@\tprintf/sub_n.lo\n libquadmath_la_OBJECTS = $(am_libquadmath_la_OBJECTS)\n libquadmath_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \\\n \t$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \\\n@@ -319,10 +325,9 @@ AUTOMAKE_OPTIONS = 1.8 foreign\n @BUILD_LIBQUADMATH_TRUE@libquadmath_la_SOURCES = \\\n @BUILD_LIBQUADMATH_TRUE@  gdtoa/arith.h gdtoa/gdtoa_fltrnds.h gdtoa/gd_qnan.h gdtoa/gdtoaimp.h \\\n @BUILD_LIBQUADMATH_TRUE@  gdtoa/gdtoa.h quadmath-imp.h \\\n-@BUILD_LIBQUADMATH_TRUE@  gdtoa/dmisc.c gdtoa/gdtoa.c gdtoa/hd_init.c gdtoa/smisc.c gdtoa/sum.c \\\n-@BUILD_LIBQUADMATH_TRUE@  gdtoa/g_Qfmt.c gdtoa/gethex.c gdtoa/hexnan.c gdtoa/strtodg.c \\\n-@BUILD_LIBQUADMATH_TRUE@  gdtoa/ulp.c gdtoa/g__fmt.c gdtoa/gmisc.c gdtoa/misc.c gdtoa/strtopQ.c \\\n-@BUILD_LIBQUADMATH_TRUE@  quadmath_io.c \\\n+@BUILD_LIBQUADMATH_TRUE@  gdtoa/hd_init.c gdtoa/smisc.c gdtoa/sum.c \\\n+@BUILD_LIBQUADMATH_TRUE@  gdtoa/gethex.c gdtoa/hexnan.c gdtoa/strtodg.c \\\n+@BUILD_LIBQUADMATH_TRUE@  gdtoa/gmisc.c gdtoa/misc.c gdtoa/strtopQ.c \\\n @BUILD_LIBQUADMATH_TRUE@  math/acoshq.c math/fmodq.c math/acosq.c math/frexpq.c \\\n @BUILD_LIBQUADMATH_TRUE@  math/rem_pio2q.c math/asinhq.c math/hypotq.c math/remainderq.c \\\n @BUILD_LIBQUADMATH_TRUE@  math/asinq.c math/rintq.c math/atan2q.c math/isinfq.c \\\n@@ -339,7 +344,11 @@ AUTOMAKE_OPTIONS = 1.8 foreign\n @BUILD_LIBQUADMATH_TRUE@  math/cacoshq.c math/cacosq.c math/casinhq.c math/casinq.c \\\n @BUILD_LIBQUADMATH_TRUE@  math/catanhq.c math/catanq.c math/cimagq.c math/conjq.c math/cprojq.c \\\n @BUILD_LIBQUADMATH_TRUE@  math/crealq.c math/fdimq.c math/fmaxq.c math/fminq.c math/ilogbq.c \\\n-@BUILD_LIBQUADMATH_TRUE@  math/llrintq.c math/log2q.c math/lrintq.c math/nearbyintq.c math/remquoq.c\n+@BUILD_LIBQUADMATH_TRUE@  math/llrintq.c math/log2q.c math/lrintq.c math/nearbyintq.c math/remquoq.c \\\n+@BUILD_LIBQUADMATH_TRUE@  printf/addmul_1.c printf/add_n.c printf/cmp.c printf/divrem.c \\\n+@BUILD_LIBQUADMATH_TRUE@  printf/flt1282mpn.c printf/fpioconst.c printf/lshift.c printf/mul_1.c \\\n+@BUILD_LIBQUADMATH_TRUE@  printf/mul_n.c printf/mul.c printf/printf_fphex.c printf/printf_fp.c \\\n+@BUILD_LIBQUADMATH_TRUE@  printf/quadmath-printf.c printf/rshift.c printf/submul_1.c printf/sub_n.c\n \n \n # Work around what appears to be a GNU make bug handling MAKEFLAGS\n@@ -498,19 +507,14 @@ gdtoa/$(am__dirstamp):\n gdtoa/$(DEPDIR)/$(am__dirstamp):\n \t@$(MKDIR_P) gdtoa/$(DEPDIR)\n \t@: > gdtoa/$(DEPDIR)/$(am__dirstamp)\n-gdtoa/dmisc.lo: gdtoa/$(am__dirstamp) gdtoa/$(DEPDIR)/$(am__dirstamp)\n-gdtoa/gdtoa.lo: gdtoa/$(am__dirstamp) gdtoa/$(DEPDIR)/$(am__dirstamp)\n gdtoa/hd_init.lo: gdtoa/$(am__dirstamp) \\\n \tgdtoa/$(DEPDIR)/$(am__dirstamp)\n gdtoa/smisc.lo: gdtoa/$(am__dirstamp) gdtoa/$(DEPDIR)/$(am__dirstamp)\n gdtoa/sum.lo: gdtoa/$(am__dirstamp) gdtoa/$(DEPDIR)/$(am__dirstamp)\n-gdtoa/g_Qfmt.lo: gdtoa/$(am__dirstamp) gdtoa/$(DEPDIR)/$(am__dirstamp)\n gdtoa/gethex.lo: gdtoa/$(am__dirstamp) gdtoa/$(DEPDIR)/$(am__dirstamp)\n gdtoa/hexnan.lo: gdtoa/$(am__dirstamp) gdtoa/$(DEPDIR)/$(am__dirstamp)\n gdtoa/strtodg.lo: gdtoa/$(am__dirstamp) \\\n \tgdtoa/$(DEPDIR)/$(am__dirstamp)\n-gdtoa/ulp.lo: gdtoa/$(am__dirstamp) gdtoa/$(DEPDIR)/$(am__dirstamp)\n-gdtoa/g__fmt.lo: gdtoa/$(am__dirstamp) gdtoa/$(DEPDIR)/$(am__dirstamp)\n gdtoa/gmisc.lo: gdtoa/$(am__dirstamp) gdtoa/$(DEPDIR)/$(am__dirstamp)\n gdtoa/misc.lo: gdtoa/$(am__dirstamp) gdtoa/$(DEPDIR)/$(am__dirstamp)\n gdtoa/strtopQ.lo: gdtoa/$(am__dirstamp) \\\n@@ -605,19 +609,47 @@ math/lrintq.lo: math/$(am__dirstamp) math/$(DEPDIR)/$(am__dirstamp)\n math/nearbyintq.lo: math/$(am__dirstamp) \\\n \tmath/$(DEPDIR)/$(am__dirstamp)\n math/remquoq.lo: math/$(am__dirstamp) math/$(DEPDIR)/$(am__dirstamp)\n+printf/$(am__dirstamp):\n+\t@$(MKDIR_P) printf\n+\t@: > printf/$(am__dirstamp)\n+printf/$(DEPDIR)/$(am__dirstamp):\n+\t@$(MKDIR_P) printf/$(DEPDIR)\n+\t@: > printf/$(DEPDIR)/$(am__dirstamp)\n+printf/addmul_1.lo: printf/$(am__dirstamp) \\\n+\tprintf/$(DEPDIR)/$(am__dirstamp)\n+printf/add_n.lo: printf/$(am__dirstamp) \\\n+\tprintf/$(DEPDIR)/$(am__dirstamp)\n+printf/cmp.lo: printf/$(am__dirstamp) printf/$(DEPDIR)/$(am__dirstamp)\n+printf/divrem.lo: printf/$(am__dirstamp) \\\n+\tprintf/$(DEPDIR)/$(am__dirstamp)\n+printf/flt1282mpn.lo: printf/$(am__dirstamp) \\\n+\tprintf/$(DEPDIR)/$(am__dirstamp)\n+printf/fpioconst.lo: printf/$(am__dirstamp) \\\n+\tprintf/$(DEPDIR)/$(am__dirstamp)\n+printf/lshift.lo: printf/$(am__dirstamp) \\\n+\tprintf/$(DEPDIR)/$(am__dirstamp)\n+printf/mul_1.lo: printf/$(am__dirstamp) \\\n+\tprintf/$(DEPDIR)/$(am__dirstamp)\n+printf/mul_n.lo: printf/$(am__dirstamp) \\\n+\tprintf/$(DEPDIR)/$(am__dirstamp)\n+printf/mul.lo: printf/$(am__dirstamp) printf/$(DEPDIR)/$(am__dirstamp)\n+printf/printf_fphex.lo: printf/$(am__dirstamp) \\\n+\tprintf/$(DEPDIR)/$(am__dirstamp)\n+printf/printf_fp.lo: printf/$(am__dirstamp) \\\n+\tprintf/$(DEPDIR)/$(am__dirstamp)\n+printf/quadmath-printf.lo: printf/$(am__dirstamp) \\\n+\tprintf/$(DEPDIR)/$(am__dirstamp)\n+printf/rshift.lo: printf/$(am__dirstamp) \\\n+\tprintf/$(DEPDIR)/$(am__dirstamp)\n+printf/submul_1.lo: printf/$(am__dirstamp) \\\n+\tprintf/$(DEPDIR)/$(am__dirstamp)\n+printf/sub_n.lo: printf/$(am__dirstamp) \\\n+\tprintf/$(DEPDIR)/$(am__dirstamp)\n libquadmath.la: $(libquadmath_la_OBJECTS) $(libquadmath_la_DEPENDENCIES) \n \t$(libquadmath_la_LINK) $(am_libquadmath_la_rpath) $(libquadmath_la_OBJECTS) $(libquadmath_la_LIBADD) $(LIBS)\n \n mostlyclean-compile:\n \t-rm -f *.$(OBJEXT)\n-\t-rm -f gdtoa/dmisc.$(OBJEXT)\n-\t-rm -f gdtoa/dmisc.lo\n-\t-rm -f gdtoa/g_Qfmt.$(OBJEXT)\n-\t-rm -f gdtoa/g_Qfmt.lo\n-\t-rm -f gdtoa/g__fmt.$(OBJEXT)\n-\t-rm -f gdtoa/g__fmt.lo\n-\t-rm -f gdtoa/gdtoa.$(OBJEXT)\n-\t-rm -f gdtoa/gdtoa.lo\n \t-rm -f gdtoa/gethex.$(OBJEXT)\n \t-rm -f gdtoa/gethex.lo\n \t-rm -f gdtoa/gmisc.$(OBJEXT)\n@@ -636,8 +668,6 @@ mostlyclean-compile:\n \t-rm -f gdtoa/strtopQ.lo\n \t-rm -f gdtoa/sum.$(OBJEXT)\n \t-rm -f gdtoa/sum.lo\n-\t-rm -f gdtoa/ulp.$(OBJEXT)\n-\t-rm -f gdtoa/ulp.lo\n \t-rm -f math/acoshq.$(OBJEXT)\n \t-rm -f math/acoshq.lo\n \t-rm -f math/acosq.$(OBJEXT)\n@@ -792,15 +822,42 @@ mostlyclean-compile:\n \t-rm -f math/tgammaq.lo\n \t-rm -f math/truncq.$(OBJEXT)\n \t-rm -f math/truncq.lo\n+\t-rm -f printf/add_n.$(OBJEXT)\n+\t-rm -f printf/add_n.lo\n+\t-rm -f printf/addmul_1.$(OBJEXT)\n+\t-rm -f printf/addmul_1.lo\n+\t-rm -f printf/cmp.$(OBJEXT)\n+\t-rm -f printf/cmp.lo\n+\t-rm -f printf/divrem.$(OBJEXT)\n+\t-rm -f printf/divrem.lo\n+\t-rm -f printf/flt1282mpn.$(OBJEXT)\n+\t-rm -f printf/flt1282mpn.lo\n+\t-rm -f printf/fpioconst.$(OBJEXT)\n+\t-rm -f printf/fpioconst.lo\n+\t-rm -f printf/lshift.$(OBJEXT)\n+\t-rm -f printf/lshift.lo\n+\t-rm -f printf/mul.$(OBJEXT)\n+\t-rm -f printf/mul.lo\n+\t-rm -f printf/mul_1.$(OBJEXT)\n+\t-rm -f printf/mul_1.lo\n+\t-rm -f printf/mul_n.$(OBJEXT)\n+\t-rm -f printf/mul_n.lo\n+\t-rm -f printf/printf_fp.$(OBJEXT)\n+\t-rm -f printf/printf_fp.lo\n+\t-rm -f printf/printf_fphex.$(OBJEXT)\n+\t-rm -f printf/printf_fphex.lo\n+\t-rm -f printf/quadmath-printf.$(OBJEXT)\n+\t-rm -f printf/quadmath-printf.lo\n+\t-rm -f printf/rshift.$(OBJEXT)\n+\t-rm -f printf/rshift.lo\n+\t-rm -f printf/sub_n.$(OBJEXT)\n+\t-rm -f printf/sub_n.lo\n+\t-rm -f printf/submul_1.$(OBJEXT)\n+\t-rm -f printf/submul_1.lo\n \n distclean-compile:\n \t-rm -f *.tab.c\n \n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/quadmath_io.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@gdtoa/$(DEPDIR)/dmisc.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@gdtoa/$(DEPDIR)/g_Qfmt.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@gdtoa/$(DEPDIR)/g__fmt.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@gdtoa/$(DEPDIR)/gdtoa.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gdtoa/$(DEPDIR)/gethex.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gdtoa/$(DEPDIR)/gmisc.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gdtoa/$(DEPDIR)/hd_init.Plo@am__quote@\n@@ -810,7 +867,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@gdtoa/$(DEPDIR)/strtodg.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gdtoa/$(DEPDIR)/strtopQ.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gdtoa/$(DEPDIR)/sum.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@gdtoa/$(DEPDIR)/ulp.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/acoshq.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/acosq.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/asinhq.Plo@am__quote@\n@@ -888,6 +944,22 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/tanq.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/tgammaq.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@math/$(DEPDIR)/truncq.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@printf/$(DEPDIR)/add_n.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@printf/$(DEPDIR)/addmul_1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@printf/$(DEPDIR)/cmp.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@printf/$(DEPDIR)/divrem.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@printf/$(DEPDIR)/flt1282mpn.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@printf/$(DEPDIR)/fpioconst.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@printf/$(DEPDIR)/lshift.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@printf/$(DEPDIR)/mul.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@printf/$(DEPDIR)/mul_1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@printf/$(DEPDIR)/mul_n.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@printf/$(DEPDIR)/printf_fp.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@printf/$(DEPDIR)/printf_fphex.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@printf/$(DEPDIR)/quadmath-printf.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@printf/$(DEPDIR)/rshift.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@printf/$(DEPDIR)/sub_n.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@printf/$(DEPDIR)/submul_1.Plo@am__quote@\n \n .c.o:\n @am__fastdepCC_TRUE@\tdepbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\\.o$$||'`;\\\n@@ -920,6 +992,7 @@ clean-libtool:\n \t-rm -rf .libs _libs\n \t-rm -rf gdtoa/.libs gdtoa/_libs\n \t-rm -rf math/.libs math/_libs\n+\t-rm -rf printf/.libs printf/_libs\n \n distclean-libtool:\n \t-rm -f libtool config.lt\n@@ -1170,6 +1243,8 @@ distclean-generic:\n \t-rm -f gdtoa/$(am__dirstamp)\n \t-rm -f math/$(DEPDIR)/$(am__dirstamp)\n \t-rm -f math/$(am__dirstamp)\n+\t-rm -f printf/$(DEPDIR)/$(am__dirstamp)\n+\t-rm -f printf/$(am__dirstamp)\n \n maintainer-clean-generic:\n \t@echo \"This command is intended for maintainers to use\"\n@@ -1182,7 +1257,7 @@ clean-am: clean-aminfo clean-generic clean-libtool \\\n \n distclean: distclean-am distclean-multi\n \t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n-\t-rm -rf ./$(DEPDIR) gdtoa/$(DEPDIR) math/$(DEPDIR)\n+\t-rm -rf gdtoa/$(DEPDIR) math/$(DEPDIR) printf/$(DEPDIR)\n \t-rm -f Makefile\n distclean-am: clean-am distclean-compile distclean-generic \\\n \tdistclean-hdr distclean-libtool distclean-tags\n@@ -1306,7 +1381,7 @@ installcheck-am:\n maintainer-clean: maintainer-clean-am maintainer-clean-multi\n \t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n \t-rm -rf $(top_srcdir)/autom4te.cache\n-\t-rm -rf ./$(DEPDIR) gdtoa/$(DEPDIR) math/$(DEPDIR)\n+\t-rm -rf gdtoa/$(DEPDIR) math/$(DEPDIR) printf/$(DEPDIR)\n \t-rm -f Makefile\n maintainer-clean-am: distclean-am maintainer-clean-aminfo \\\n \tmaintainer-clean-generic"}, {"sha": "307da27df4914c1bbc11dd76fa9a93798ae326ad", "filename": "libquadmath/config.h.in", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fconfig.h.in?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -3,9 +3,15 @@\n /* libm includes cbrtl */\n #undef HAVE_CBRTL\n \n+/* Define to 1 if you have the <ctype.h> header file. */\n+#undef HAVE_CTYPE_H\n+\n /* Define to 1 if you have the <dlfcn.h> header file. */\n #undef HAVE_DLFCN_H\n \n+/* Define to 1 if you have the <errno.h> header file. */\n+#undef HAVE_ERRNO_H\n+\n /* libm includes feholdexcept */\n #undef HAVE_FEHOLDEXCEPT\n \n@@ -24,12 +30,27 @@\n /* libm includes feupdateenv */\n #undef HAVE_FEUPDATEENV\n \n+/* __attribute__((visibility (\"hidden\"))) supported */\n+#undef HAVE_HIDDEN_VISIBILITY\n+\n /* Define to 1 if you have the <inttypes.h> header file. */\n #undef HAVE_INTTYPES_H\n \n+/* Define to 1 if you have the <langinfo.h> header file. */\n+#undef HAVE_LANGINFO_H\n+\n+/* Define to 1 if you have the <limits.h> header file. */\n+#undef HAVE_LIMITS_H\n+\n /* Define to 1 if you have the <memory.h> header file. */\n #undef HAVE_MEMORY_H\n \n+/* Define to 1 if you have the <printf.h> header file. */\n+#undef HAVE_PRINTF_H\n+\n+/* GNU C Library stype printf hooks supported */\n+#undef HAVE_PRINTF_HOOKS\n+\n /* libm includes sqrtl */\n #undef HAVE_SQRTL\n \n@@ -54,6 +75,12 @@\n /* Define to 1 if you have the <unistd.h> header file. */\n #undef HAVE_UNISTD_H\n \n+/* Define to 1 if you have the <wchar.h> header file. */\n+#undef HAVE_WCHAR_H\n+\n+/* Define to 1 if you have the <wctype.h> header file. */\n+#undef HAVE_WCTYPE_H\n+\n /* Define to the sub-directory in which libtool stores uninstalled libraries.\n    */\n #undef LT_OBJDIR\n@@ -85,5 +112,43 @@\n /* Define to 1 if you have the ANSI C header files. */\n #undef STDC_HEADERS\n \n+/* whether i18n number rewriting can be supported */\n+#undef USE_I18N_NUMBER_H\n+\n+/* whether nl_langinfo is sufficiently supported */\n+#undef USE_LOCALE_SUPPORT\n+\n+/* Enable extensions on AIX 3, Interix.  */\n+#ifndef _ALL_SOURCE\n+# undef _ALL_SOURCE\n+#endif\n+/* Enable GNU extensions on systems that have them.  */\n+#ifndef _GNU_SOURCE\n+# undef _GNU_SOURCE\n+#endif\n+/* Enable threading extensions on Solaris.  */\n+#ifndef _POSIX_PTHREAD_SEMANTICS\n+# undef _POSIX_PTHREAD_SEMANTICS\n+#endif\n+/* Enable extensions on HP NonStop.  */\n+#ifndef _TANDEM_SOURCE\n+# undef _TANDEM_SOURCE\n+#endif\n+/* Enable general extensions on Solaris.  */\n+#ifndef __EXTENSIONS__\n+# undef __EXTENSIONS__\n+#endif\n+\n+\n /* Version number of package */\n #undef VERSION\n+\n+/* Define to 1 if on MINIX. */\n+#undef _MINIX\n+\n+/* Define to 2 if the system does not provide POSIX.1 features except with\n+   this defined. */\n+#undef _POSIX_1_SOURCE\n+\n+/* Define to 1 if you need to in order for `stat' and other things to work. */\n+#undef _POSIX_SOURCE"}, {"sha": "fa825ce8cc673549d956dff2b4cec97090a15a6a", "filename": "libquadmath/configure", "status": "modified", "additions": 2002, "deletions": 1783, "changes": 3785, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fconfigure?ref=1d92226be3a775b085e90436067c45f938fba761"}, {"sha": "4bde6ed50fa0bdcf9a4c4ff3319768e96775eb40", "filename": "libquadmath/configure.ac", "status": "modified", "additions": 82, "deletions": 1, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fconfigure.ac?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -42,6 +42,8 @@ AC_MSG_RESULT($version_specific_libs)\n \n GCC_NO_EXECUTABLES\n \n+AC_USE_SYSTEM_EXTENSIONS\n+\n # See if makeinfo has been installed and is modern enough\n # that we can use it.\n ACX_CHECK_PROG_VER([MAKEINFO], [makeinfo], [--version],\n@@ -110,7 +112,7 @@ esac\n AC_SUBST(toolexecdir)\n AC_SUBST(toolexeclibdir)\n \n-AC_CHECK_HEADERS(fenv.h)\n+AC_CHECK_HEADERS(fenv.h langinfo.h wchar.h wctype.h limits.h ctype.h printf.h errno.h)\n \n # If available, sqrtl and cbrtl speed up the calculation -\n # but they are not required\n@@ -146,6 +148,16 @@ else\n   fi\n fi\n \n+# Check for hidden visibility (copied from libssp).\n+AC_MSG_CHECKING([whether hidden visibility is supported])\n+AC_TRY_COMPILE([\n+void __attribute__((visibility (\"hidden\"))) bar (void) {}],,\n+[quadmath_hidden=yes],[quadmath_hidden=no])\n+AC_MSG_RESULT($quadmath_hidden)\n+if test x$quadmath_hidden = xyes; then\n+  AC_DEFINE([HAVE_HIDDEN_VISIBILITY],[1],[__attribute__((visibility (\"hidden\"))) supported])\n+fi\n+\n # Check for symbol versioning (copied from libssp).\n AC_MSG_CHECKING([whether symbol versioning is supported])\n if test x$gcc_no_link = xyes; then\n@@ -213,6 +225,75 @@ AC_CACHE_CHECK([whether __float128 is supported], [libquad_cv_have_float128],\n ])])\n AM_CONDITIONAL(BUILD_LIBQUADMATH, [test \"x$libquad_cv_have_float128\" = xyes])\n \n+# Check for printf hook support.\n+AC_MSG_CHECKING([whether printf hooks are supported])\n+AC_TRY_COMPILE([\n+#include <printf.h>\n+#include <stdarg.h>\n+#include <stdlib.h>\n+extern void flt128_va (void *, va_list *);\n+extern int flt128_ais (const struct printf_info *, size_t, int *, int *);\n+extern int flt128_printf_fp (FILE *, const struct printf_info *, const void *const *);\n+],[\n+int pa_flt128 = register_printf_type (flt128_va);\n+int mod_Q = register_printf_modifier (L\"Q\");\n+int res = register_printf_specifier ('f', flt128_printf_fp, flt128_ais);\n+],\n+[quadmath_printf_hooks=yes],[quadmath_printf_hooks=no])\n+AC_MSG_RESULT($quadmath_printf_hooks)\n+if test x$quadmath_printf_hooks = xyes; then\n+  AC_DEFINE([HAVE_PRINTF_HOOKS],[1],[GNU C Library stype printf hooks supported])\n+fi\n+\n+# Check for whether locale support for quadmath_snprintf or Q printf hooks\n+# should be provided.\n+AC_MSG_CHECKING([whether locale support for quadmath_snprintf should be added])\n+AC_TRY_COMPILE([#include <langinfo.h>],[\n+const char *s;\n+s = nl_langinfo (DECIMAL_POINT);\n+s = nl_langinfo (MON_DECIMAL_POINT);\n+s = nl_langinfo (GROUPING);\n+s = nl_langinfo (MON_GROUPING);\n+s = nl_langinfo (THOUSANDS_SEP);\n+s = nl_langinfo (MON_THOUSANDS_SEP);\n+s = nl_langinfo (_NL_NUMERIC_DECIMAL_POINT_WC);\n+s = nl_langinfo (_NL_MONETARY_DECIMAL_POINT_WC);\n+s = nl_langinfo (_NL_NUMERIC_THOUSANDS_SEP_WC);\n+s = nl_langinfo (_NL_MONETARY_THOUSANDS_SEP_WC);\n+s = nl_langinfo (_NL_CTYPE_MB_CUR_MAX);\n+(void) s;\n+],\n+[quadmath_use_locale_support=yes],[quadmath_use_locale_support=no])\n+AC_MSG_RESULT($quadmath_use_locale_support)\n+if test x$quadmath_use_locale_support = xyes; then\n+  AC_DEFINE([USE_LOCALE_SUPPORT],[1],[whether nl_langinfo is sufficiently supported])\n+fi\n+\n+# Check for whether i18n number rewriting support for quadmath_snprintf\n+# or Q printf hooks should be provided.\n+AC_MSG_CHECKING([whether i18n number rewriting support for quadmath_snprintf should be added])\n+AC_TRY_COMPILE([#include <langinfo.h>\n+#include <limits.h>\n+#include <string.h>\n+#include <wchar.h>\n+#include <wctype.h>],[\n+const char *s;\n+char decimal[MB_LEN_MAX];\n+wctrans_t map = wctrans (\"to_outpunct\");\n+wint_t wdecimal = towctrans (L'.', map);\n+mbstate_t state;\n+memset (&state, '\\0', sizeof (state));\n+wcrtomb (decimal, wdecimal, &state);\n+s = nl_langinfo (_NL_CTYPE_OUTDIGIT0_MB);\n+s = nl_langinfo (_NL_CTYPE_OUTDIGIT0_WC);\n+(void) s;\n+],\n+[quadmath_use_i18n_number_h=yes],[quadmath_use_i18n_number_h=no])\n+AC_MSG_RESULT($quadmath_use_i18n_number_h)\n+if test x$quadmath_use_i18n_number_h = xyes; then\n+  AC_DEFINE([USE_I18N_NUMBER_H],[1],[whether i18n number rewriting can be supported])\n+fi\n+\n AC_CACHE_SAVE\n \n if test ${multilib} = yes; then"}, {"sha": "ce170c733bf723cdd9ab4e4801a4f35ac2010bcc", "filename": "libquadmath/gdtoa/dmisc.c", "status": "removed", "additions": 0, "deletions": 216, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944f4bb398aaf3d25c71a5b12ca9626d2c5f5e99/libquadmath%2Fgdtoa%2Fdmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944f4bb398aaf3d25c71a5b12ca9626d2c5f5e99/libquadmath%2Fgdtoa%2Fdmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fgdtoa%2Fdmisc.c?ref=944f4bb398aaf3d25c71a5b12ca9626d2c5f5e99", "patch": "@@ -1,216 +0,0 @@\n-/****************************************************************\n-\n-The author of this software is David M. Gay.\n-\n-Copyright (C) 1998 by Lucent Technologies\n-All Rights Reserved\n-\n-Permission to use, copy, modify, and distribute this software and\n-its documentation for any purpose and without fee is hereby\n-granted, provided that the above copyright notice appear in all\n-copies and that both that the copyright notice and this\n-permission notice and warranty disclaimer appear in supporting\n-documentation, and that the name of Lucent or any of its entities\n-not be used in advertising or publicity pertaining to\n-distribution of the software without specific, written prior\n-permission.\n-\n-LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n-INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\n-IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\n-SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n-WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\n-IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\n-ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n-THIS SOFTWARE.\n-\n-****************************************************************/\n-\n-/* Please send bug reports to David M. Gay (dmg at acm dot org,\n- * with \" at \" changed at \"@\" and \" dot \" changed to \".\").\t*/\n-\n-#include \"gdtoaimp.h\"\n-\n-#ifndef MULTIPLE_THREADS\n- char *dtoa_result;\n-#endif\n-\n- char *\n-#ifdef KR_headers\n-rv_alloc(i) int i;\n-#else\n-rv_alloc(int i)\n-#endif\n-{\n-\tint j, k, *r;\n-\n-\tj = sizeof(ULong);\n-\tfor(k = 0;\n-\t\tsizeof(Bigint) - sizeof(ULong) - sizeof(int) + j <= i;\n-\t\tj <<= 1)\n-\t\t\tk++;\n-\tr = (int*)Balloc(k);\n-\t*r = k;\n-\treturn\n-#ifndef MULTIPLE_THREADS\n-\tdtoa_result =\n-#endif\n-\t\t(char *)(r+1);\n-\t}\n-\n- char *\n-#ifdef KR_headers\n-nrv_alloc(s, rve, n) char *s, **rve; int n;\n-#else\n-nrv_alloc(char *s, char **rve, int n)\n-#endif\n-{\n-\tchar *rv, *t;\n-\n-\tt = rv = rv_alloc(n);\n-\twhile((*t = *s++) !=0)\n-\t\tt++;\n-\tif (rve)\n-\t\t*rve = t;\n-\treturn rv;\n-\t}\n-\n-/* freedtoa(s) must be used to free values s returned by dtoa\n- * when MULTIPLE_THREADS is #defined.  It should be used in all cases,\n- * but for consistency with earlier versions of dtoa, it is optional\n- * when MULTIPLE_THREADS is not defined.\n- */\n-\n- void\n-#ifdef KR_headers\n-freedtoa(s) char *s;\n-#else\n-freedtoa(char *s)\n-#endif\n-{\n-\tBigint *b = (Bigint *)((int *)s - 1);\n-\tb->maxwds = 1 << (b->k = *(int*)b);\n-\tBfree(b);\n-#ifndef MULTIPLE_THREADS\n-\tif (s == dtoa_result)\n-\t\tdtoa_result = 0;\n-#endif\n-\t}\n-\n- int\n-quorem\n-#ifdef KR_headers\n-\t(b, S) Bigint *b, *S;\n-#else\n-\t(Bigint *b, Bigint *S)\n-#endif\n-{\n-\tint n;\n-\tULong *bx, *bxe, q, *sx, *sxe;\n-#ifdef ULLong\n-\tULLong borrow, carry, y, ys;\n-#else\n-\tULong borrow, carry, y, ys;\n-#ifdef Pack_32\n-\tULong si, z, zs;\n-#endif\n-#endif\n-\n-\tn = S->wds;\n-#ifdef DEBUG\n-\t/*debug*/ if (b->wds > n)\n-\t/*debug*/\tBug(\"oversize b in quorem\");\n-#endif\n-\tif (b->wds < n)\n-\t\treturn 0;\n-\tsx = S->x;\n-\tsxe = sx + --n;\n-\tbx = b->x;\n-\tbxe = bx + n;\n-\tq = *bxe / (*sxe + 1);\t/* ensure q <= true quotient */\n-#ifdef DEBUG\n-\t/*debug*/ if (q > 9)\n-\t/*debug*/\tBug(\"oversized quotient in quorem\");\n-#endif\n-\tif (q) {\n-\t\tborrow = 0;\n-\t\tcarry = 0;\n-\t\tdo {\n-#ifdef ULLong\n-\t\t\tys = *sx++ * (ULLong)q + carry;\n-\t\t\tcarry = ys >> 32;\n-\t\t\ty = *bx - (ys & 0xffffffffUL) - borrow;\n-\t\t\tborrow = y >> 32 & 1UL;\n-\t\t\t*bx++ = y & 0xffffffffUL;\n-#else\n-#ifdef Pack_32\n-\t\t\tsi = *sx++;\n-\t\t\tys = (si & 0xffff) * q + carry;\n-\t\t\tzs = (si >> 16) * q + (ys >> 16);\n-\t\t\tcarry = zs >> 16;\n-\t\t\ty = (*bx & 0xffff) - (ys & 0xffff) - borrow;\n-\t\t\tborrow = (y & 0x10000) >> 16;\n-\t\t\tz = (*bx >> 16) - (zs & 0xffff) - borrow;\n-\t\t\tborrow = (z & 0x10000) >> 16;\n-\t\t\tStoreinc(bx, z, y);\n-#else\n-\t\t\tys = *sx++ * q + carry;\n-\t\t\tcarry = ys >> 16;\n-\t\t\ty = *bx - (ys & 0xffff) - borrow;\n-\t\t\tborrow = (y & 0x10000) >> 16;\n-\t\t\t*bx++ = y & 0xffff;\n-#endif\n-#endif\n-\t\t\t}\n-\t\t\twhile(sx <= sxe);\n-\t\tif (!*bxe) {\n-\t\t\tbx = b->x;\n-\t\t\twhile(--bxe > bx && !*bxe)\n-\t\t\t\t--n;\n-\t\t\tb->wds = n;\n-\t\t\t}\n-\t\t}\n-\tif (cmp(b, S) >= 0) {\n-\t\tq++;\n-\t\tborrow = 0;\n-\t\tcarry = 0;\n-\t\tbx = b->x;\n-\t\tsx = S->x;\n-\t\tdo {\n-#ifdef ULLong\n-\t\t\tys = *sx++ + carry;\n-\t\t\tcarry = ys >> 32;\n-\t\t\ty = *bx - (ys & 0xffffffffUL) - borrow;\n-\t\t\tborrow = y >> 32 & 1UL;\n-\t\t\t*bx++ = y & 0xffffffffUL;\n-#else\n-#ifdef Pack_32\n-\t\t\tsi = *sx++;\n-\t\t\tys = (si & 0xffff) + carry;\n-\t\t\tzs = (si >> 16) + (ys >> 16);\n-\t\t\tcarry = zs >> 16;\n-\t\t\ty = (*bx & 0xffff) - (ys & 0xffff) - borrow;\n-\t\t\tborrow = (y & 0x10000) >> 16;\n-\t\t\tz = (*bx >> 16) - (zs & 0xffff) - borrow;\n-\t\t\tborrow = (z & 0x10000) >> 16;\n-\t\t\tStoreinc(bx, z, y);\n-#else\n-\t\t\tys = *sx++ + carry;\n-\t\t\tcarry = ys >> 16;\n-\t\t\ty = *bx - (ys & 0xffff) - borrow;\n-\t\t\tborrow = (y & 0x10000) >> 16;\n-\t\t\t*bx++ = y & 0xffff;\n-#endif\n-#endif\n-\t\t\t}\n-\t\t\twhile(sx <= sxe);\n-\t\tbx = b->x;\n-\t\tbxe = bx + n;\n-\t\tif (!*bxe) {\n-\t\t\twhile(--bxe > bx && !*bxe)\n-\t\t\t\t--n;\n-\t\t\tb->wds = n;\n-\t\t\t}\n-\t\t}\n-\treturn q;\n-\t}"}, {"sha": "426c598cfc806fcbd9fc5dd146858a2fc7370cad", "filename": "libquadmath/gdtoa/g_Qfmt.c", "status": "removed", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944f4bb398aaf3d25c71a5b12ca9626d2c5f5e99/libquadmath%2Fgdtoa%2Fg_Qfmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944f4bb398aaf3d25c71a5b12ca9626d2c5f5e99/libquadmath%2Fgdtoa%2Fg_Qfmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fgdtoa%2Fg_Qfmt.c?ref=944f4bb398aaf3d25c71a5b12ca9626d2c5f5e99", "patch": "@@ -1,125 +0,0 @@\n-/****************************************************************\n-\n-The author of this software is David M. Gay.\n-\n-Copyright (C) 1998, 2000 by Lucent Technologies\n-All Rights Reserved\n-\n-Permission to use, copy, modify, and distribute this software and\n-its documentation for any purpose and without fee is hereby\n-granted, provided that the above copyright notice appear in all\n-copies and that both that the copyright notice and this\n-permission notice and warranty disclaimer appear in supporting\n-documentation, and that the name of Lucent or any of its entities\n-not be used in advertising or publicity pertaining to\n-distribution of the software without specific, written prior\n-permission.\n-\n-LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n-INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\n-IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\n-SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n-WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\n-IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\n-ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n-THIS SOFTWARE.\n-\n-****************************************************************/\n-\n-/* Please send bug reports to David M. Gay (dmg at acm dot org,\n- * with \" at \" changed at \"@\" and \" dot \" changed to \".\").\t*/\n-\n-#include \"gdtoaimp.h\"\n-\n-#undef _0\n-#undef _1\n-\n-/* one or the other of IEEE_MC68k or IEEE_8087 should be #defined */\n-\n-#ifdef IEEE_MC68k\n-#define _0 0\n-#define _1 1\n-#define _2 2\n-#define _3 3\n-#endif\n-#ifdef IEEE_8087\n-#define _0 3\n-#define _1 2\n-#define _2 1\n-#define _3 0\n-#endif\n-\n- char*\n-#ifdef KR_headers\n-g_Qfmt(buf, V, ndig, bufsize) char *buf; char *V; int ndig; size_t bufsize;\n-#else\n-g_Qfmt(char *buf, void *V, int ndig, size_t bufsize)\n-#endif\n-{\n-\tstatic FPI fpi0 = { 113, 1-16383-113+1, 32766 - 16383 - 113 + 1, 1, 0 };\n-\tchar *b, *s, *se;\n-\tULong bits[4], *L, sign;\n-\tint decpt, ex, i, mode;\n-#ifdef Honor_FLT_ROUNDS\n-#include \"gdtoa_fltrnds.h\"\n-#else\n-#define fpi &fpi0\n-#endif\n-\n-\tif (ndig < 0)\n-\t\tndig = 0;\n-\tif (bufsize < ndig + 10)\n-\t\treturn 0;\n-\n-\tL = (ULong*)V;\n-\tsign = L[_0] & 0x80000000L;\n-\tbits[3] = L[_0] & 0xffff;\n-\tbits[2] = L[_1];\n-\tbits[1] = L[_2];\n-\tbits[0] = L[_3];\n-\tb = buf;\n-\tif ( (ex = (L[_0] & 0x7fff0000L) >> 16) !=0) {\n-\t\tif (ex == 0x7fff) {\n-\t\t\t/* Infinity or NaN */\n-\t\t\tif (bits[0] | bits[1] | bits[2] | bits[3])\n-\t\t\t\tb = strcpy(b, \"NaN\");\n-\t\t\telse {\n-\t\t\t\tb = buf;\n-\t\t\t\tif (sign)\n-\t\t\t\t\t*b++ = '-';\n-\t\t\t\tb = strcpy(b, \"Infinity\");\n-\t\t\t\t}\n-\t\t\treturn b;\n-\t\t\t}\n-\t\ti = STRTOG_Normal;\n-\t\tbits[3] |= 0x10000;\n-\t\t}\n-\telse if (bits[0] | bits[1] | bits[2] | bits[3]) {\n-\t\ti = STRTOG_Denormal;\n-\t\tex = 1;\n-\t\t}\n-\telse {\n-#ifndef IGNORE_ZERO_SIGN\n-\t\tif (sign)\n-\t\t\t*b++ = '-';\n-#endif\n-\t\t*b++ = '0';\n-\t\t*b = 0;\n-\t\treturn b;\n-\t\t}\n-\tex -= 0x3fff + 112;\n-\tmode = 2;\n-\tif (ndig <= 0) {\n-\t\tif (bufsize < 48)\n-\t\t\treturn 0;\n-\t\tmode = 0;\n-\t\t}\n-\ts = gdtoa(fpi, ex, bits, &i, mode, ndig, &decpt, &se);\n-\n-\t// FXC -- modifications\n-\t\n-\n-\n-\treturn g__fmt(buf, s, se, decpt, sign, bufsize);\n-\t// FXC -- end of modifications\n-\t}"}, {"sha": "6c4b3d26fb2a9ca054ec2b657a324be9dc589bf1", "filename": "libquadmath/gdtoa/g__fmt.c", "status": "removed", "additions": 0, "deletions": 147, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944f4bb398aaf3d25c71a5b12ca9626d2c5f5e99/libquadmath%2Fgdtoa%2Fg__fmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944f4bb398aaf3d25c71a5b12ca9626d2c5f5e99/libquadmath%2Fgdtoa%2Fg__fmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fgdtoa%2Fg__fmt.c?ref=944f4bb398aaf3d25c71a5b12ca9626d2c5f5e99", "patch": "@@ -1,147 +0,0 @@\n-/****************************************************************\n-\n-The author of this software is David M. Gay.\n-\n-Copyright (C) 1998 by Lucent Technologies\n-All Rights Reserved\n-\n-Permission to use, copy, modify, and distribute this software and\n-its documentation for any purpose and without fee is hereby\n-granted, provided that the above copyright notice appear in all\n-copies and that both that the copyright notice and this\n-permission notice and warranty disclaimer appear in supporting\n-documentation, and that the name of Lucent or any of its entities\n-not be used in advertising or publicity pertaining to\n-distribution of the software without specific, written prior\n-permission.\n-\n-LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n-INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\n-IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\n-SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n-WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\n-IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\n-ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n-THIS SOFTWARE.\n-\n-****************************************************************/\n-\n-/* Please send bug reports to David M. Gay (dmg at acm dot org,\n- * with \" at \" changed at \"@\" and \" dot \" changed to \".\").\t*/\n-\n-#include \"gdtoaimp.h\"\n-\n-#ifdef USE_LOCALE\n-#include \"locale.h\"\n-#endif\n-\n- char *\n-#ifdef KR_headers\n-g__fmt(b, s, se, decpt, sign, blen) char *b; char *s; char *se; int decpt; ULong sign; size_t blen;\n-#else\n-g__fmt(char *b, char *s, char *se, int decpt, ULong sign, size_t blen)\n-#endif\n-{\n-\tint i, j, k;\n-\tchar *be, *s0;\n-\tsize_t len;\n-#ifdef USE_LOCALE\n-#ifdef NO_LOCALE_CACHE\n-\tchar *decimalpoint = localeconv()->decimal_point;\n-\tsize_t dlen = strlen(decimalpoint);\n-#else\n-\tchar *decimalpoint;\n-\tstatic char *decimalpoint_cache;\n-\tstatic size_t dlen;\n-\tif (!(s0 = decimalpoint_cache)) {\n-\t\ts0 = localeconv()->decimal_point;\n-\t\tdlen = strlen(s0);\n-\t\tif ((decimalpoint_cache = (char*)MALLOC(strlen(s0) + 1))) {\n-\t\t\tstrcpy(decimalpoint_cache, s0);\n-\t\t\ts0 = decimalpoint_cache;\n-\t\t\t}\n-\t\t}\n-\tdecimalpoint = s0;\n-#endif\n-#else\n-#define dlen 0\n-#endif\n-\ts0 = s;\n-\tlen = (se-s) + dlen + 6; /* 6 = sign + e+dd + trailing null */\n-\tif (blen < len)\n-\t\tgoto ret0;\n-\tbe = b + blen - 1;\n-\tif (sign)\n-\t\t*b++ = '-';\n-\tif (decpt <= -4 || decpt > se - s + 5) {\n-\t\t*b++ = *s++;\n-\t\tif (*s) {\n-#ifdef USE_LOCALE\n-\t\t\twhile((*b = *decimalpoint++))\n-\t\t\t\t++b;\n-#else\n-\t\t\t*b++ = '.';\n-#endif\n-\t\t\twhile((*b = *s++) !=0)\n-\t\t\t\tb++;\n-\t\t\t}\n-\t\t*b++ = 'e';\n-\t\t/* sprintf(b, \"%+.2d\", decpt - 1); */\n-\t\tif (--decpt < 0) {\n-\t\t\t*b++ = '-';\n-\t\t\tdecpt = -decpt;\n-\t\t\t}\n-\t\telse\n-\t\t\t*b++ = '+';\n-\t\tfor(j = 2, k = 10; 10*k <= decpt; j++, k *= 10){}\n-\t\tfor(;;) {\n-\t\t\ti = decpt / k;\n-\t\t\tif (b >= be)\n-\t\t\t\tgoto ret0;\n-\t\t\t*b++ = i + '0';\n-\t\t\tif (--j <= 0)\n-\t\t\t\tbreak;\n-\t\t\tdecpt -= i*k;\n-\t\t\tdecpt *= 10;\n-\t\t\t}\n-\t\t*b = 0;\n-\t\t}\n-\telse if (decpt <= 0) {\n-#ifdef USE_LOCALE\n-\t\twhile((*b = *decimalpoint++))\n-\t\t\t++b;\n-#else\n-\t\t*b++ = '.';\n-#endif\n-\t\tif (be < b - decpt + (se - s))\n-\t\t\tgoto ret0;\n-\t\tfor(; decpt < 0; decpt++)\n-\t\t\t*b++ = '0';\n-\t\twhile((*b = *s++) != 0)\n-\t\t\tb++;\n-\t\t}\n-\telse {\n-\t\twhile((*b = *s++) != 0) {\n-\t\t\tb++;\n-\t\t\tif (--decpt == 0 && *s) {\n-#ifdef USE_LOCALE\n-\t\t\t\twhile(*b = *decimalpoint++)\n-\t\t\t\t\t++b;\n-#else\n-\t\t\t\t*b++ = '.';\n-#endif\n-\t\t\t\t}\n-\t\t\t}\n-\t\tif (b + decpt > be) {\n- ret0:\n-\t\t\tb = 0;\n-\t\t\tgoto ret;\n-\t\t\t}\n-\t\tfor(; decpt > 0; decpt--)\n-\t\t\t*b++ = '0';\n-\t\t*b = 0;\n-\t\t}\n- ret:\n-\tfreedtoa(s0);\n-\treturn b;\n- \t}"}, {"sha": "4ebdf41a6a31517ac09bafca5a6ea704cfef6462", "filename": "libquadmath/gdtoa/gdtoa.c", "status": "removed", "additions": 0, "deletions": 745, "changes": 745, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944f4bb398aaf3d25c71a5b12ca9626d2c5f5e99/libquadmath%2Fgdtoa%2Fgdtoa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944f4bb398aaf3d25c71a5b12ca9626d2c5f5e99/libquadmath%2Fgdtoa%2Fgdtoa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fgdtoa%2Fgdtoa.c?ref=944f4bb398aaf3d25c71a5b12ca9626d2c5f5e99", "patch": "@@ -1,745 +0,0 @@\n-/****************************************************************\n-\n-The author of this software is David M. Gay.\n-\n-Copyright (C) 1998, 1999 by Lucent Technologies\n-All Rights Reserved\n-\n-Permission to use, copy, modify, and distribute this software and\n-its documentation for any purpose and without fee is hereby\n-granted, provided that the above copyright notice appear in all\n-copies and that both that the copyright notice and this\n-permission notice and warranty disclaimer appear in supporting\n-documentation, and that the name of Lucent or any of its entities\n-not be used in advertising or publicity pertaining to\n-distribution of the software without specific, written prior\n-permission.\n-\n-LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n-INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\n-IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\n-SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n-WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\n-IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\n-ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n-THIS SOFTWARE.\n-\n-****************************************************************/\n-\n-/* Please send bug reports to David M. Gay (dmg at acm dot org,\n- * with \" at \" changed at \"@\" and \" dot \" changed to \".\").\t*/\n-\n-#include \"gdtoaimp.h\"\n-\n- static Bigint *\n-#ifdef KR_headers\n-bitstob(bits, nbits, bbits) ULong *bits; int nbits; int *bbits;\n-#else\n-bitstob(ULong *bits, int nbits, int *bbits)\n-#endif\n-{\n-\tint i, k;\n-\tBigint *b;\n-\tULong *be, *x, *x0;\n-\n-\ti = ULbits;\n-\tk = 0;\n-\twhile(i < nbits) {\n-\t\ti <<= 1;\n-\t\tk++;\n-\t\t}\n-#ifndef Pack_32\n-\tif (!k)\n-\t\tk = 1;\n-#endif\n-\tb = Balloc(k);\n-\tbe = bits + ((nbits - 1) >> kshift);\n-\tx = x0 = b->x;\n-\tdo {\n-\t\t*x++ = *bits & ALL_ON;\n-#ifdef Pack_16\n-\t\t*x++ = (*bits >> 16) & ALL_ON;\n-#endif\n-\t\t} while(++bits <= be);\n-\ti = x - x0;\n-\twhile(!x0[--i])\n-\t\tif (!i) {\n-\t\t\tb->wds = 0;\n-\t\t\t*bbits = 0;\n-\t\t\tgoto ret;\n-\t\t\t}\n-\tb->wds = i + 1;\n-\t*bbits = i*ULbits + 32 - hi0bits(b->x[i]);\n- ret:\n-\treturn b;\n-\t}\n-\n-/* dtoa for IEEE arithmetic (dmg): convert double to ASCII string.\n- *\n- * Inspired by \"How to Print Floating-Point Numbers Accurately\" by\n- * Guy L. Steele, Jr. and Jon L. White [Proc. ACM SIGPLAN '90, pp. 112-126].\n- *\n- * Modifications:\n- *\t1. Rather than iterating, we use a simple numeric overestimate\n- *\t   to determine k = floor(log10(d)).  We scale relevant\n- *\t   quantities using O(log2(k)) rather than O(k) multiplications.\n- *\t2. For some modes > 2 (corresponding to ecvt and fcvt), we don't\n- *\t   try to generate digits strictly left to right.  Instead, we\n- *\t   compute with fewer bits and propagate the carry if necessary\n- *\t   when rounding the final digit up.  This is often faster.\n- *\t3. Under the assumption that input will be rounded nearest,\n- *\t   mode 0 renders 1e23 as 1e23 rather than 9.999999999999999e22.\n- *\t   That is, we allow equality in stopping tests when the\n- *\t   round-nearest rule will give the same floating-point value\n- *\t   as would satisfaction of the stopping test with strict\n- *\t   inequality.\n- *\t4. We remove common factors of powers of 2 from relevant\n- *\t   quantities.\n- *\t5. When converting floating-point integers less than 1e16,\n- *\t   we use floating-point arithmetic rather than resorting\n- *\t   to multiple-precision integers.\n- *\t6. When asked to produce fewer than 15 digits, we first try\n- *\t   to get by with floating-point arithmetic; we resort to\n- *\t   multiple-precision integer arithmetic only if we cannot\n- *\t   guarantee that the floating-point calculation has given\n- *\t   the correctly rounded result.  For k requested digits and\n- *\t   \"uniformly\" distributed input, the probability is\n- *\t   something like 10^(k-15) that we must resort to the Long\n- *\t   calculation.\n- */\n-\n- char *\n-gdtoa\n-#ifdef KR_headers\n-\t(fpi, be, bits, kindp, mode, ndigits, decpt, rve)\n-\tFPI *fpi; int be; ULong *bits;\n-\tint *kindp, mode, ndigits, *decpt; char **rve;\n-#else\n-\t(FPI *fpi, int be, ULong *bits, int *kindp, int mode, int ndigits, int *decpt, char **rve)\n-#endif\n-{\n- /*\tArguments ndigits and decpt are similar to the second and third\n-\targuments of ecvt and fcvt; trailing zeros are suppressed from\n-\tthe returned string.  If not null, *rve is set to point\n-\tto the end of the return value.  If d is +-Infinity or NaN,\n-\tthen *decpt is set to 9999.\n-\n-\tmode:\n-\t\t0 ==> shortest string that yields d when read in\n-\t\t\tand rounded to nearest.\n-\t\t1 ==> like 0, but with Steele & White stopping rule;\n-\t\t\te.g. with IEEE P754 arithmetic , mode 0 gives\n-\t\t\t1e23 whereas mode 1 gives 9.999999999999999e22.\n-\t\t2 ==> max(1,ndigits) significant digits.  This gives a\n-\t\t\treturn value similar to that of ecvt, except\n-\t\t\tthat trailing zeros are suppressed.\n-\t\t3 ==> through ndigits past the decimal point.  This\n-\t\t\tgives a return value similar to that from fcvt,\n-\t\t\texcept that trailing zeros are suppressed, and\n-\t\t\tndigits can be negative.\n-\t\t4-9 should give the same return values as 2-3, i.e.,\n-\t\t\t4 <= mode <= 9 ==> same return as mode\n-\t\t\t2 + (mode & 1).  These modes are mainly for\n-\t\t\tdebugging; often they run slower but sometimes\n-\t\t\tfaster than modes 2-3.\n-\t\t4,5,8,9 ==> left-to-right digit generation.\n-\t\t6-9 ==> don't try fast floating-point estimate\n-\t\t\t(if applicable).\n-\n-\t\tValues of mode other than 0-9 are treated as mode 0.\n-\n-\t\tSufficient space is allocated to the return value\n-\t\tto hold the suppressed trailing zeros.\n-\t*/\n-\n-\tint bbits, b2, b5, be0, dig, i, ieps, ilim, ilim0, ilim1, inex;\n-\tint j, j1, k, k0, k_check, kind, leftright, m2, m5, nbits;\n-\tint rdir, s2, s5, spec_case, try_quick;\n-\tLong L;\n-\tBigint *b, *b1, *delta, *mlo, *mhi, *mhi1, *S;\n-\tdouble d2, ds;\n-\tchar *s, *s0;\n-\tU d, eps;\n-\n-#ifndef MULTIPLE_THREADS\n-\tif (dtoa_result) {\n-\t\tfreedtoa(dtoa_result);\n-\t\tdtoa_result = 0;\n-\t\t}\n-#endif\n-\tinex = 0;\n-\tkind = *kindp &= ~STRTOG_Inexact;\n-\tswitch(kind & STRTOG_Retmask) {\n-\t  case STRTOG_Zero:\n-\t\tgoto ret_zero;\n-\t  case STRTOG_Normal:\n-\t  case STRTOG_Denormal:\n-\t\tbreak;\n-\t  case STRTOG_Infinite:\n-\t\t*decpt = -32768;\n-\t\treturn nrv_alloc(\"Infinity\", rve, 8);\n-\t  case STRTOG_NaN:\n-\t\t*decpt = -32768;\n-\t\treturn nrv_alloc(\"NaN\", rve, 3);\n-\t  default:\n-\t\treturn 0;\n-\t  }\n-\tb = bitstob(bits, nbits = fpi->nbits, &bbits);\n-\tbe0 = be;\n-\tif ( (i = trailz(b)) !=0) {\n-\t\trshift(b, i);\n-\t\tbe += i;\n-\t\tbbits -= i;\n-\t\t}\n-\tif (!b->wds) {\n-\t\tBfree(b);\n- ret_zero:\n-\t\t*decpt = 1;\n-\t\treturn nrv_alloc(\"0\", rve, 1);\n-\t\t}\n-\n-\tdval(&d) = b2d(b, &i);\n-\ti = be + bbits - 1;\n-\tword0(&d) &= Frac_mask1;\n-\tword0(&d) |= Exp_11;\n-#ifdef IBM\n-\tif ( (j = 11 - hi0bits(word0(&d) & Frac_mask)) !=0)\n-\t\tdval(&d) /= 1 << j;\n-#endif\n-\n-\t/* log(x)\t~=~ log(1.5) + (x-1.5)/1.5\n-\t * log10(x)\t =  log(x) / log(10)\n-\t *\t\t~=~ log(1.5)/log(10) + (x-1.5)/(1.5*log(10))\n-\t * log10(&d) = (i-Bias)*log(2)/log(10) + log10(d2)\n-\t *\n-\t * This suggests computing an approximation k to log10(&d) by\n-\t *\n-\t * k = (i - Bias)*0.301029995663981\n-\t *\t+ ( (d2-1.5)*0.289529654602168 + 0.176091259055681 );\n-\t *\n-\t * We want k to be too large rather than too small.\n-\t * The error in the first-order Taylor series approximation\n-\t * is in our favor, so we just round up the constant enough\n-\t * to compensate for any error in the multiplication of\n-\t * (i - Bias) by 0.301029995663981; since |i - Bias| <= 1077,\n-\t * and 1077 * 0.30103 * 2^-52 ~=~ 7.2e-14,\n-\t * adding 1e-13 to the constant term more than suffices.\n-\t * Hence we adjust the constant term to 0.1760912590558.\n-\t * (We could get a more accurate k by invoking log10,\n-\t *  but this is probably not worthwhile.)\n-\t */\n-#ifdef IBM\n-\ti <<= 2;\n-\ti += j;\n-#endif\n-\tds = (dval(&d)-1.5)*0.289529654602168 + 0.1760912590558 + i*0.301029995663981;\n-\n-\t/* correct assumption about exponent range */\n-\tif ((j = i) < 0)\n-\t\tj = -j;\n-\tif ((j -= 1077) > 0)\n-\t\tds += j * 7e-17;\n-\n-\tk = (int)ds;\n-\tif (ds < 0. && ds != k)\n-\t\tk--;\t/* want k = floor(ds) */\n-\tk_check = 1;\n-#ifdef IBM\n-\tj = be + bbits - 1;\n-\tif ( (j1 = j & 3) !=0)\n-\t\tdval(&d) *= 1 << j1;\n-\tword0(&d) += j << Exp_shift - 2 & Exp_mask;\n-#else\n-\tword0(&d) += (be + bbits - 1) << Exp_shift;\n-#endif\n-\tif (k >= 0 && k <= Ten_pmax) {\n-\t\tif (dval(&d) < tens[k])\n-\t\t\tk--;\n-\t\tk_check = 0;\n-\t\t}\n-\tj = bbits - i - 1;\n-\tif (j >= 0) {\n-\t\tb2 = 0;\n-\t\ts2 = j;\n-\t\t}\n-\telse {\n-\t\tb2 = -j;\n-\t\ts2 = 0;\n-\t\t}\n-\tif (k >= 0) {\n-\t\tb5 = 0;\n-\t\ts5 = k;\n-\t\ts2 += k;\n-\t\t}\n-\telse {\n-\t\tb2 -= k;\n-\t\tb5 = -k;\n-\t\ts5 = 0;\n-\t\t}\n-\tif (mode < 0 || mode > 9)\n-\t\tmode = 0;\n-\ttry_quick = 1;\n-\tif (mode > 5) {\n-\t\tmode -= 4;\n-\t\ttry_quick = 0;\n-\t\t}\n-\tleftright = 1;\n-\tilim = ilim1 = -1;\t/* Values for cases 0 and 1; done here to */\n-\t\t\t\t/* silence erroneous \"gcc -Wall\" warning. */\n-\tswitch(mode) {\n-\t\tcase 0:\n-\t\tcase 1:\n-\t\t\ti = (int)(nbits * .30103) + 3;\n-\t\t\tndigits = 0;\n-\t\t\tbreak;\n-\t\tcase 2:\n-\t\t\tleftright = 0;\n-\t\t\t/* no break */\n-\t\tcase 4:\n-\t\t\tif (ndigits <= 0)\n-\t\t\t\tndigits = 1;\n-\t\t\tilim = ilim1 = i = ndigits;\n-\t\t\tbreak;\n-\t\tcase 3:\n-\t\t\tleftright = 0;\n-\t\t\t/* no break */\n-\t\tcase 5:\n-\t\t\ti = ndigits + k + 1;\n-\t\t\tilim = i;\n-\t\t\tilim1 = i - 1;\n-\t\t\tif (i <= 0)\n-\t\t\t\ti = 1;\n-\t\t}\n-\ts = s0 = rv_alloc(i);\n-\n-\tif ( (rdir = fpi->rounding - 1) !=0) {\n-\t\tif (rdir < 0)\n-\t\t\trdir = 2;\n-\t\tif (kind & STRTOG_Neg)\n-\t\t\trdir = 3 - rdir;\n-\t\t}\n-\n-\t/* Now rdir = 0 ==> round near, 1 ==> round up, 2 ==> round down. */\n-\n-\tif (ilim >= 0 && ilim <= Quick_max && try_quick && !rdir\n-#ifndef IMPRECISE_INEXACT\n-\t\t&& k == 0\n-#endif\n-\t\t\t\t\t\t\t\t) {\n-\n-\t\t/* Try to get by with floating-point arithmetic. */\n-\n-\t\ti = 0;\n-\t\td2 = dval(&d);\n-#ifdef IBM\n-\t\tif ( (j = 11 - hi0bits(word0(&d) & Frac_mask)) !=0)\n-\t\t\tdval(&d) /= 1 << j;\n-#endif\n-\t\tk0 = k;\n-\t\tilim0 = ilim;\n-\t\tieps = 2; /* conservative */\n-\t\tif (k > 0) {\n-\t\t\tds = tens[k&0xf];\n-\t\t\tj = k >> 4;\n-\t\t\tif (j & Bletch) {\n-\t\t\t\t/* prevent overflows */\n-\t\t\t\tj &= Bletch - 1;\n-\t\t\t\tdval(&d) /= bigtens[n_bigtens-1];\n-\t\t\t\tieps++;\n-\t\t\t\t}\n-\t\t\tfor(; j; j >>= 1, i++)\n-\t\t\t\tif (j & 1) {\n-\t\t\t\t\tieps++;\n-\t\t\t\t\tds *= bigtens[i];\n-\t\t\t\t\t}\n-\t\t\t}\n-\t\telse  {\n-\t\t\tds = 1.;\n-\t\t\tif ( (j1 = -k) !=0) {\n-\t\t\t\tdval(&d) *= tens[j1 & 0xf];\n-\t\t\t\tfor(j = j1 >> 4; j; j >>= 1, i++)\n-\t\t\t\t\tif (j & 1) {\n-\t\t\t\t\t\tieps++;\n-\t\t\t\t\t\tdval(&d) *= bigtens[i];\n-\t\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\tif (k_check && dval(&d) < 1. && ilim > 0) {\n-\t\t\tif (ilim1 <= 0)\n-\t\t\t\tgoto fast_failed;\n-\t\t\tilim = ilim1;\n-\t\t\tk--;\n-\t\t\tdval(&d) *= 10.;\n-\t\t\tieps++;\n-\t\t\t}\n-\t\tdval(&eps) = ieps*dval(&d) + 7.;\n-\t\tword0(&eps) -= (P-1)*Exp_msk1;\n-\t\tif (ilim == 0) {\n-\t\t\tS = mhi = 0;\n-\t\t\tdval(&d) -= 5.;\n-\t\t\tif (dval(&d) > dval(&eps))\n-\t\t\t\tgoto one_digit;\n-\t\t\tif (dval(&d) < -dval(&eps))\n-\t\t\t\tgoto no_digits;\n-\t\t\tgoto fast_failed;\n-\t\t\t}\n-#ifndef No_leftright\n-\t\tif (leftright) {\n-\t\t\t/* Use Steele & White method of only\n-\t\t\t * generating digits needed.\n-\t\t\t */\n-\t\t\tdval(&eps) = ds*0.5/tens[ilim-1] - dval(&eps);\n-\t\t\tfor(i = 0;;) {\n-\t\t\t\tL = (Long)(dval(&d)/ds);\n-\t\t\t\tdval(&d) -= L*ds;\n-\t\t\t\t*s++ = '0' + (int)L;\n-\t\t\t\tif (dval(&d) < dval(&eps)) {\n-\t\t\t\t\tif (dval(&d))\n-\t\t\t\t\t\tinex = STRTOG_Inexlo;\n-\t\t\t\t\tgoto ret1;\n-\t\t\t\t\t}\n-\t\t\t\tif (ds - dval(&d) < dval(&eps))\n-\t\t\t\t\tgoto bump_up;\n-\t\t\t\tif (++i >= ilim)\n-\t\t\t\t\tbreak;\n-\t\t\t\tdval(&eps) *= 10.;\n-\t\t\t\tdval(&d) *= 10.;\n-\t\t\t\t}\n-\t\t\t}\n-\t\telse {\n-#endif\n-\t\t\t/* Generate ilim digits, then fix them up. */\n-\t\t\tdval(&eps) *= tens[ilim-1];\n-\t\t\tfor(i = 1;; i++, dval(&d) *= 10.) {\n-\t\t\t\tif ( (L = (Long)(dval(&d)/ds)) !=0)\n-\t\t\t\t\tdval(&d) -= L*ds;\n-\t\t\t\t*s++ = '0' + (int)L;\n-\t\t\t\tif (i == ilim) {\n-\t\t\t\t\tds *= 0.5;\n-\t\t\t\t\tif (dval(&d) > ds + dval(&eps))\n-\t\t\t\t\t\tgoto bump_up;\n-\t\t\t\t\telse if (dval(&d) < ds - dval(&eps)) {\n-\t\t\t\t\t\tif (dval(&d))\n-\t\t\t\t\t\t\tinex = STRTOG_Inexlo;\n-\t\t\t\t\t\tgoto clear_trailing0;\n-\t\t\t\t\t\t}\n-\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-#ifndef No_leftright\n-\t\t\t}\n-#endif\n- fast_failed:\n-\t\ts = s0;\n-\t\tdval(&d) = d2;\n-\t\tk = k0;\n-\t\tilim = ilim0;\n-\t\t}\n-\n-\t/* Do we have a \"small\" integer? */\n-\n-\tif (be >= 0 && k <= Int_max) {\n-\t\t/* Yes. */\n-\t\tds = tens[k];\n-\t\tif (ndigits < 0 && ilim <= 0) {\n-\t\t\tS = mhi = 0;\n-\t\t\tif (ilim < 0 || dval(&d) <= 5*ds)\n-\t\t\t\tgoto no_digits;\n-\t\t\tgoto one_digit;\n-\t\t\t}\n-\t\tfor(i = 1;; i++, dval(&d) *= 10.) {\n-\t\t\tL = dval(&d) / ds;\n-\t\t\tdval(&d) -= L*ds;\n-#ifdef Check_FLT_ROUNDS\n-\t\t\t/* If FLT_ROUNDS == 2, L will usually be high by 1 */\n-\t\t\tif (dval(&d) < 0) {\n-\t\t\t\tL--;\n-\t\t\t\tdval(&d) += ds;\n-\t\t\t\t}\n-#endif\n-\t\t\t*s++ = '0' + (int)L;\n-\t\t\tif (dval(&d) == 0.)\n-\t\t\t\tbreak;\n-\t\t\tif (i == ilim) {\n-\t\t\t\tif (rdir) {\n-\t\t\t\t\tif (rdir == 1)\n-\t\t\t\t\t\tgoto bump_up;\n-\t\t\t\t\tinex = STRTOG_Inexlo;\n-\t\t\t\t\tgoto ret1;\n-\t\t\t\t\t}\n-\t\t\t\tdval(&d) += dval(&d);\n-\t\t\t\tif (dval(&d) > ds || (dval(&d) == ds && L & 1)) {\n- bump_up:\n-\t\t\t\t\tinex = STRTOG_Inexhi;\n-\t\t\t\t\twhile(*--s == '9')\n-\t\t\t\t\t\tif (s == s0) {\n-\t\t\t\t\t\t\tk++;\n-\t\t\t\t\t\t\t*s = '0';\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t++*s++;\n-\t\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tinex = STRTOG_Inexlo;\n- clear_trailing0:\n-\t\t\t\t\twhile(*--s == '0'){}\n-\t\t\t\t\t++s;\n-\t\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n-\t\tgoto ret1;\n-\t\t}\n-\n-\tm2 = b2;\n-\tm5 = b5;\n-\tmhi = mlo = 0;\n-\tif (leftright) {\n-\t\tif (mode < 2) {\n-\t\t\ti = nbits - bbits;\n-\t\t\tif (be - i++ < fpi->emin)\n-\t\t\t\t/* denormal */\n-\t\t\t\ti = be - fpi->emin + 1;\n-\t\t\t}\n-\t\telse {\n-\t\t\tj = ilim - 1;\n-\t\t\tif (m5 >= j)\n-\t\t\t\tm5 -= j;\n-\t\t\telse {\n-\t\t\t\ts5 += j -= m5;\n-\t\t\t\tb5 += j;\n-\t\t\t\tm5 = 0;\n-\t\t\t\t}\n-\t\t\tif ((i = ilim) < 0) {\n-\t\t\t\tm2 -= i;\n-\t\t\t\ti = 0;\n-\t\t\t\t}\n-\t\t\t}\n-\t\tb2 += i;\n-\t\ts2 += i;\n-\t\tmhi = i2b(1);\n-\t\t}\n-\tif (m2 > 0 && s2 > 0) {\n-\t\ti = m2 < s2 ? m2 : s2;\n-\t\tb2 -= i;\n-\t\tm2 -= i;\n-\t\ts2 -= i;\n-\t\t}\n-\tif (b5 > 0) {\n-\t\tif (leftright) {\n-\t\t\tif (m5 > 0) {\n-\t\t\t\tmhi = pow5mult(mhi, m5);\n-\t\t\t\tb1 = mult(mhi, b);\n-\t\t\t\tBfree(b);\n-\t\t\t\tb = b1;\n-\t\t\t\t}\n-\t\t\tif ( (j = b5 - m5) !=0)\n-\t\t\t\tb = pow5mult(b, j);\n-\t\t\t}\n-\t\telse\n-\t\t\tb = pow5mult(b, b5);\n-\t\t}\n-\tS = i2b(1);\n-\tif (s5 > 0)\n-\t\tS = pow5mult(S, s5);\n-\n-\t/* Check for special case that d is a normalized power of 2. */\n-\n-\tspec_case = 0;\n-\tif (mode < 2) {\n-\t\tif (bbits == 1 && be0 > fpi->emin + 1) {\n-\t\t\t/* The special case */\n-\t\t\tb2++;\n-\t\t\ts2++;\n-\t\t\tspec_case = 1;\n-\t\t\t}\n-\t\t}\n-\n-\t/* Arrange for convenient computation of quotients:\n-\t * shift left if necessary so divisor has 4 leading 0 bits.\n-\t *\n-\t * Perhaps we should just compute leading 28 bits of S once\n-\t * and for all and pass them and a shift to quorem, so it\n-\t * can do shifts and ors to compute the numerator for q.\n-\t */\n-\ti = ((s5 ? hi0bits(S->x[S->wds-1]) : ULbits - 1) - s2 - 4) & kmask;\n-\tm2 += i;\n-\tif ((b2 += i) > 0)\n-\t\tb = lshift(b, b2);\n-\tif ((s2 += i) > 0)\n-\t\tS = lshift(S, s2);\n-\tif (k_check) {\n-\t\tif (cmp(b,S) < 0) {\n-\t\t\tk--;\n-\t\t\tb = multadd(b, 10, 0);\t/* we botched the k estimate */\n-\t\t\tif (leftright)\n-\t\t\t\tmhi = multadd(mhi, 10, 0);\n-\t\t\tilim = ilim1;\n-\t\t\t}\n-\t\t}\n-\tif (ilim <= 0 && mode > 2) {\n-\t\tif (ilim < 0 || cmp(b,S = multadd(S,5,0)) <= 0) {\n-\t\t\t/* no digits, fcvt style */\n- no_digits:\n-\t\t\tk = -1 - ndigits;\n-\t\t\tinex = STRTOG_Inexlo;\n-\t\t\tgoto ret;\n-\t\t\t}\n- one_digit:\n-\t\tinex = STRTOG_Inexhi;\n-\t\t*s++ = '1';\n-\t\tk++;\n-\t\tgoto ret;\n-\t\t}\n-\tif (leftright) {\n-\t\tif (m2 > 0)\n-\t\t\tmhi = lshift(mhi, m2);\n-\n-\t\t/* Compute mlo -- check for special case\n-\t\t * that d is a normalized power of 2.\n-\t\t */\n-\n-\t\tmlo = mhi;\n-\t\tif (spec_case) {\n-\t\t\tmhi = Balloc(mhi->k);\n-\t\t\tBcopy(mhi, mlo);\n-\t\t\tmhi = lshift(mhi, 1);\n-\t\t\t}\n-\n-\t\tfor(i = 1;;i++) {\n-\t\t\tdig = quorem(b,S) + '0';\n-\t\t\t/* Do we yet have the shortest decimal string\n-\t\t\t * that will round to d?\n-\t\t\t */\n-\t\t\tj = cmp(b, mlo);\n-\t\t\tdelta = diff(S, mhi);\n-\t\t\tj1 = delta->sign ? 1 : cmp(b, delta);\n-\t\t\tBfree(delta);\n-#ifndef ROUND_BIASED\n-\t\t\tif (j1 == 0 && !mode && !(bits[0] & 1) && !rdir) {\n-\t\t\t\tif (dig == '9')\n-\t\t\t\t\tgoto round_9_up;\n-\t\t\t\tif (j <= 0) {\n-\t\t\t\t\tif (b->wds > 1 || b->x[0])\n-\t\t\t\t\t\tinex = STRTOG_Inexlo;\n-\t\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tdig++;\n-\t\t\t\t\tinex = STRTOG_Inexhi;\n-\t\t\t\t\t}\n-\t\t\t\t*s++ = dig;\n-\t\t\t\tgoto ret;\n-\t\t\t\t}\n-#endif\n-\t\t\tif (j < 0 || (j == 0 && !mode\n-#ifndef ROUND_BIASED\n-\t\t\t\t\t\t\t&& !(bits[0] & 1)\n-#endif\n-\t\t\t\t\t)) {\n-\t\t\t\tif (rdir && (b->wds > 1 || b->x[0])) {\n-\t\t\t\t\tif (rdir == 2) {\n-\t\t\t\t\t\tinex = STRTOG_Inexlo;\n-\t\t\t\t\t\tgoto accept;\n-\t\t\t\t\t\t}\n-\t\t\t\t\twhile (cmp(S,mhi) > 0) {\n-\t\t\t\t\t\t*s++ = dig;\n-\t\t\t\t\t\tmhi1 = multadd(mhi, 10, 0);\n-\t\t\t\t\t\tif (mlo == mhi)\n-\t\t\t\t\t\t\tmlo = mhi1;\n-\t\t\t\t\t\tmhi = mhi1;\n-\t\t\t\t\t\tb = multadd(b, 10, 0);\n-\t\t\t\t\t\tdig = quorem(b,S) + '0';\n-\t\t\t\t\t\t}\n-\t\t\t\t\tif (dig++ == '9')\n-\t\t\t\t\t\tgoto round_9_up;\n-\t\t\t\t\tinex = STRTOG_Inexhi;\n-\t\t\t\t\tgoto accept;\n-\t\t\t\t\t}\n-\t\t\t\tif (j1 > 0) {\n-\t\t\t\t\tb = lshift(b, 1);\n-\t\t\t\t\tj1 = cmp(b, S);\n-\t\t\t\t\tif ((j1 > 0 || (j1 == 0 && dig & 1))\n-\t\t\t\t\t&& dig++ == '9')\n-\t\t\t\t\t\tgoto round_9_up;\n-\t\t\t\t\tinex = STRTOG_Inexhi;\n-\t\t\t\t\t}\n-\t\t\t\tif (b->wds > 1 || b->x[0])\n-\t\t\t\t\tinex = STRTOG_Inexlo;\n- accept:\n-\t\t\t\t*s++ = dig;\n-\t\t\t\tgoto ret;\n-\t\t\t\t}\n-\t\t\tif (j1 > 0 && rdir != 2) {\n-\t\t\t\tif (dig == '9') { /* possible if i == 1 */\n- round_9_up:\n-\t\t\t\t\t*s++ = '9';\n-\t\t\t\t\tinex = STRTOG_Inexhi;\n-\t\t\t\t\tgoto roundoff;\n-\t\t\t\t\t}\n-\t\t\t\tinex = STRTOG_Inexhi;\n-\t\t\t\t*s++ = dig + 1;\n-\t\t\t\tgoto ret;\n-\t\t\t\t}\n-\t\t\t*s++ = dig;\n-\t\t\tif (i == ilim)\n-\t\t\t\tbreak;\n-\t\t\tb = multadd(b, 10, 0);\n-\t\t\tif (mlo == mhi)\n-\t\t\t\tmlo = mhi = multadd(mhi, 10, 0);\n-\t\t\telse {\n-\t\t\t\tmlo = multadd(mlo, 10, 0);\n-\t\t\t\tmhi = multadd(mhi, 10, 0);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\telse\n-\t\tfor(i = 1;; i++) {\n-\t\t\t*s++ = dig = quorem(b,S) + '0';\n-\t\t\tif (i >= ilim)\n-\t\t\t\tbreak;\n-\t\t\tb = multadd(b, 10, 0);\n-\t\t\t}\n-\n-\t/* Round off last digit */\n-\n-\tif (rdir) {\n-\t\tif (rdir == 2 || (b->wds <= 1 && !b->x[0]))\n-\t\t\tgoto chopzeros;\n-\t\tgoto roundoff;\n-\t\t}\n-\tb = lshift(b, 1);\n-\tj = cmp(b, S);\n-\tif (j > 0 || (j == 0 && dig & 1)) {\n- roundoff:\n-\t\tinex = STRTOG_Inexhi;\n-\t\twhile(*--s == '9')\n-\t\t\tif (s == s0) {\n-\t\t\t\tk++;\n-\t\t\t\t*s++ = '1';\n-\t\t\t\tgoto ret;\n-\t\t\t\t}\n-\t\t++*s++;\n-\t\t}\n-\telse {\n- chopzeros:\n-\t\tif (b->wds > 1 || b->x[0])\n-\t\t\tinex = STRTOG_Inexlo;\n-\t\twhile(*--s == '0'){}\n-\t\t++s;\n-\t\t}\n- ret:\n-\tBfree(S);\n-\tif (mhi) {\n-\t\tif (mlo && mlo != mhi)\n-\t\t\tBfree(mlo);\n-\t\tBfree(mhi);\n-\t\t}\n- ret1:\n-\tBfree(b);\n-\t*s = 0;\n-\t*decpt = k + 1;\n-\tif (rve)\n-\t\t*rve = s;\n-\t*kindp |= inex;\n-\treturn s0;\n-\t}"}, {"sha": "17e9f862c44331485ef40bbae5a43ff9374ed67b", "filename": "libquadmath/gdtoa/ulp.c", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944f4bb398aaf3d25c71a5b12ca9626d2c5f5e99/libquadmath%2Fgdtoa%2Fulp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944f4bb398aaf3d25c71a5b12ca9626d2c5f5e99/libquadmath%2Fgdtoa%2Fulp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fgdtoa%2Fulp.c?ref=944f4bb398aaf3d25c71a5b12ca9626d2c5f5e99", "patch": "@@ -1,70 +0,0 @@\n-/****************************************************************\n-\n-The author of this software is David M. Gay.\n-\n-Copyright (C) 1998, 1999 by Lucent Technologies\n-All Rights Reserved\n-\n-Permission to use, copy, modify, and distribute this software and\n-its documentation for any purpose and without fee is hereby\n-granted, provided that the above copyright notice appear in all\n-copies and that both that the copyright notice and this\n-permission notice and warranty disclaimer appear in supporting\n-documentation, and that the name of Lucent or any of its entities\n-not be used in advertising or publicity pertaining to\n-distribution of the software without specific, written prior\n-permission.\n-\n-LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n-INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\n-IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\n-SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n-WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\n-IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\n-ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n-THIS SOFTWARE.\n-\n-****************************************************************/\n-\n-/* Please send bug reports to David M. Gay (dmg at acm dot org,\n- * with \" at \" changed at \"@\" and \" dot \" changed to \".\").\t*/\n-\n-#include \"gdtoaimp.h\"\n-\n- double\n-ulp\n-#ifdef KR_headers\n-\t(x) U *x;\n-#else\n-\t(U *x)\n-#endif\n-{\n-\tLong L;\n-\tU a;\n-\n-\tL = (word0(x) & Exp_mask) - (P-1)*Exp_msk1;\n-#ifndef Sudden_Underflow\n-\tif (L > 0) {\n-#endif\n-#ifdef IBM\n-\t\tL |= Exp_msk1 >> 4;\n-#endif\n-\t\tword0(&a) = L;\n-\t\tword1(&a) = 0;\n-#ifndef Sudden_Underflow\n-\t\t}\n-\telse {\n-\t\tL = -L >> Exp_shift;\n-\t\tif (L < Exp_shift) {\n-\t\t\tword0(&a) = 0x80000 >> L;\n-\t\t\tword1(&a) = 0;\n-\t\t\t}\n-\t\telse {\n-\t\t\tword0(&a) = 0;\n-\t\t\tL -= Exp_shift;\n-\t\t\tword1(&a) = L >= 31 ? 1 : 1 << (31 - L);\n-\t\t\t}\n-\t\t}\n-#endif\n-\treturn dval(&a);\n-\t}"}, {"sha": "f361ea934f3703a454f92267da28a1b46e2b7c8a", "filename": "libquadmath/libquadmath.texi", "status": "modified", "additions": 43, "deletions": 13, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Flibquadmath.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Flibquadmath.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Flibquadmath.texi?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -246,7 +246,7 @@ The following mathematical functions are available:\n \n @menu\n * @code{strtoflt128}:          strtoflt128,          Convert from string\n-* @code{quadmath_flt128tostr}: quadmath_flt128tostr, Convert to string\n+* @code{quadmath_snprintf}:    quadmath_snprintf,    Convert to string\n @end menu\n \n \n@@ -289,43 +289,73 @@ int main ()\n @end table\n \n \n-@node quadmath_flt128tostr\n-@section @code{quadmath_flt128tostr} --- Convert to string\n+@node quadmath_snprintf\n+@section @code{quadmath_snprintf} --- Convert to string\n \n-The function @code{quadmath_flt128tostr} converts a @code{__float128} floating-point\n-number into a string.\n+The function @code{quadmath_snprintf} converts a @code{__float128} floating-point\n+number into a string.  It is a specialized alternative to @code{snprintf}, where\n+the format string is restricted to a single conversion specifier with @code{Q}\n+modifier and conversion specifier @code{e}, @code{E}, @code{f}, @code{F}, @code{g},\n+@code{G}, @code{a} or @code{A}, with no extra characters before or after the\n+conversion specifier.  The @code{%m$} or @code{*m$} style must not be used in\n+the format.\n \n @table @asis\n @item Syntax\n-@code{void quadmath_flt128tostr (char *s, size_t size, size_t n, __float128 x)}\n+@code{int quadmath_snprintf (char *s, size_t size, const char *format, ...)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n @item @var{s}    @tab output string\n @item @var{size} @tab byte size of the string, including tailing NUL\n-@item @var{n}    @tab number of digits after the decimal point\n-@item @var{x}    @tab the number to be converted\n+@item @var{format} @tab conversion specifier string\n @end multitable\n \n @item Example\n @smallexample\n #include <quadmath.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n \n int main ()\n @{\n   __float128 r;\n-  char str[200];\n+  int prec = 20;\n+  int width = 46;\n+  char buf[128];\n \n   r = 2.0q;\n-  r = sqrtq(r);\n-  quadmath_flt128tostr (str, sizeof (str), 20, r);\n-  printf(\"%s\\n\", str);\n-  /* Prints: +1.41421356237309504880e+00 */\n+  r = sqrtq (r);\n+  int n = quadmath_snprintf (buf, sizeof buf, \"%+-#*.20Qe\", width, r);\n+  if ((size_t) n < sizeof buf)\n+    printf (\"%s\\n\", buf);\n+    /* Prints: +1.41421356237309504880e+00 */\n+  quadmath_snprintf (buf, sizeof buf, \"%Qa\", r);\n+  if ((size_t) n < sizeof buf)\n+    printf (\"%s\\n\", buf);\n+    /* Prints: 0x1.6a09e667f3bcc908b2fb1366ea96p+0 */\n+  n = quadmath_snprintf (NULL, 0, \"%+-#46.*Qe\", prec, r);\n+  if (n > -1)\n+    @{\n+      char *str = malloc (n + 1);\n+      if (str)\n+        @{\n+          quadmath_snprintf (str, n + 1, \"%+-#46.*Qe\", prec, r);\n+          printf (\"%s\\n\", str);\n+          /* Prints: +1.41421356237309504880e+00 */\n+        @}\n+      free (str);\n+    @}\n   return 0;\n @}\n @end smallexample\n+\n @end table\n \n+On some targets when supported by the C library hooks are installed\n+for @code{printf} family of functions, so that @code{printf (\"%Qe\", 1.2Q);}\n+etc.@: works too.\n+\n \n @c ---------------------------------------------------------------------\n @c GNU Free Documentation License"}, {"sha": "80065d88b136f25a7b3f35096900918b8678165b", "filename": "libquadmath/printf/_i18n_number.h", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2F_i18n_number.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2F_i18n_number.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2F_i18n_number.h?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -0,0 +1,139 @@\n+/* Copyright (C) 2000, 2004, 2008 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Ulrich Drepper <drepper@gnu.org>, 2000.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+   02111-1307 USA.  */\n+\n+/* Look up the value of the next multibyte character and return its numerical\n+   value if it is one of the digits known in the locale.  If *DECIDED is\n+   -1 this means it is not yet decided which form it is and we have to\n+   search through all available digits.  Otherwise we know which script\n+   the digits are from.  */\n+static inline char *\n+outdigit_value (char *s, int n)\n+{\n+  const char *outdigit;\n+  size_t dlen;\n+\n+  assert (0 <= n && n <= 9);\n+  outdigit = nl_langinfo (_NL_CTYPE_OUTDIGIT0_MB + n);\n+  dlen = strlen (outdigit);\n+\n+  s -= dlen;\n+  while (dlen-- > 0)\n+    s[dlen] = outdigit[dlen];\n+\n+  return s;\n+}\n+\n+/* Look up the value of the next multibyte character and return its numerical\n+   value if it is one of the digits known in the locale.  If *DECIDED is\n+   -1 this means it is not yet decided which form it is and we have to\n+   search through all available digits.  Otherwise we know which script\n+   the digits are from.  */\n+static inline wchar_t\n+outdigitwc_value (int n)\n+{\n+  assert (0 <= n && n <= 9);\n+\n+  return nl_langinfo_wc (_NL_CTYPE_OUTDIGIT0_WC + n);\n+}\n+\n+static char *\n+_i18n_number_rewrite (char *w, char *rear_ptr, char *end)\n+{\n+  char decimal[MB_LEN_MAX + 1];\n+  char thousands[MB_LEN_MAX + 1];\n+\n+  /* \"to_outpunct\" is a map from ASCII decimal point and thousands-sep\n+     to their equivalent in locale. This is defined for locales which\n+     use extra decimal point and thousands-sep.  */\n+  wctrans_t map = wctrans (\"to_outpunct\");\n+  wint_t wdecimal = towctrans (L_('.'), map);\n+  wint_t wthousands = towctrans (L_(','), map);\n+\n+  if (__builtin_expect (map != NULL, 0))\n+    {\n+      mbstate_t state;\n+      memset (&state, '\\0', sizeof (state));\n+\n+      size_t n = wcrtomb (decimal, wdecimal, &state);\n+      if (n == (size_t) -1)\n+\tmemcpy (decimal, \".\", 2);\n+      else\n+\tdecimal[n] = '\\0';\n+\n+      memset (&state, '\\0', sizeof (state));\n+\n+      n = wcrtomb (thousands, wthousands, &state);\n+      if (n == (size_t) -1)\n+\tmemcpy (thousands, \",\", 2);\n+      else\n+\tthousands[n] = '\\0';\n+    }\n+\n+  /* Copy existing string so that nothing gets overwritten.  */\n+  char *src;\n+  int use_alloca = (rear_ptr - w) < 4096;\n+  if (__builtin_expect (use_alloca, 1))\n+    src = (char *) alloca (rear_ptr - w);\n+  else\n+    {\n+      src = (char *) malloc (rear_ptr - w);\n+      if (src == NULL)\n+\t/* If we cannot allocate the memory don't rewrite the string.\n+\t   It is better than nothing.  */\n+\treturn w;\n+    }\n+\n+  memcpy (src, w, rear_ptr - w);\n+  char *s = src + (rear_ptr - w);\n+\n+  w = end;\n+\n+  /* Process all characters in the string.  */\n+  while (--s >= src)\n+    {\n+      if (*s >= '0' && *s <= '9')\n+\t{\n+\t  if (sizeof (char) == 1)\n+\t    w = (char *) outdigit_value ((char *) w, *s - '0');\n+\t  else\n+\t    *--w = (char) outdigitwc_value (*s - '0');\n+\t}\n+      else if (__builtin_expect (map == NULL, 1) || (*s != '.' && *s != ','))\n+\t*--w = *s;\n+      else\n+\t{\n+\t  if (sizeof (char) == 1)\n+\t    {\n+\t      const char *outpunct = *s == '.' ? decimal : thousands;\n+\t      size_t dlen = strlen (outpunct);\n+\n+\t      w -= dlen;\n+\t      while (dlen-- > 0)\n+\t\tw[dlen] = outpunct[dlen];\n+\t    }\n+\t  else\n+\t    *--w = *s == '.' ? (char) wdecimal : (char) wthousands;\n+\t}\n+    }\n+\n+  if (! use_alloca)\n+    free (src);\n+\n+  return w;\n+}"}, {"sha": "a0cd2b05ca4be93cb5fd239c6e8c134848164618", "filename": "libquadmath/printf/_itoa.h", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2F_itoa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2F_itoa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2F_itoa.h?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -0,0 +1,77 @@\n+/* Internal function for converting integers to ASCII.\n+   Copyright (C) 1994-1999,2002,2003,2007 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+   02111-1307 USA.  */\n+\n+#ifndef _ITOA_H\n+#define _ITOA_H\n+\n+/* Convert VALUE into ASCII in base BASE (2..16).\n+   Write backwards starting the character just before BUFLIM.\n+   Return the address of the first (left-to-right) character in the number.\n+   Use upper case letters iff UPPER_CASE is nonzero.  */\n+\n+static const char _itoa_lower_digits[16] = \"0123456789abcdef\";\n+static const char _itoa_upper_digits[16] = \"0123456789ABCDEF\";\n+\n+static inline char * __attribute__ ((unused, always_inline))\n+_itoa_word (unsigned long value, char *buflim,\n+\t    unsigned int base, int upper_case)\n+{\n+  const char *digits = (upper_case ? _itoa_upper_digits : _itoa_lower_digits);\n+\n+  switch (base)\n+    {\n+# define SPECIAL(Base)\t\t\t\t\t\t\t      \\\n+    case Base:\t\t\t\t\t\t\t\t      \\\n+      do\t\t\t\t\t\t\t\t      \\\n+\t*--buflim = digits[value % Base];\t\t\t\t      \\\n+      while ((value /= Base) != 0);\t\t\t\t\t      \\\n+      break\n+\n+      SPECIAL (10);\n+      SPECIAL (16);\n+      SPECIAL (8);\n+    default:\n+      do\n+\t*--buflim = digits[value % base];\n+      while ((value /= base) != 0);\n+    }\n+  return buflim;\n+}\n+\n+static inline char * __attribute__ ((unused, always_inline))\n+_itoa (uint64_t value, char *buflim,\n+       unsigned int base, int upper_case)\n+{\n+  const char *digits = (upper_case ? _itoa_upper_digits : _itoa_lower_digits);\n+\n+  switch (base)\n+    {\n+      SPECIAL (10);\n+      SPECIAL (16);\n+      SPECIAL (8);\n+    default:\n+      do\n+\t*--buflim = digits[value % base];\n+      while ((value /= base) != 0);\n+    }\n+  return buflim;\n+}\n+# undef SPECIAL\n+\n+#endif\t/* itoa.h */"}, {"sha": "4717b5c654d78f37bb2fc8fc54bd7c77664502de", "filename": "libquadmath/printf/_itowa.h", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2F_itowa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2F_itowa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2F_itowa.h?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -0,0 +1,83 @@\n+/* Internal function for converting integers to ASCII.\n+   Copyright (C) 1994,95,96,97,98,99,2002,2003 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+   02111-1307 USA.  */\n+\n+#ifndef _ITOWA_H\n+#define _ITOWA_H\t1\n+\n+/* Convert VALUE into ASCII in base BASE (2..16).\n+   Write backwards starting the character just before BUFLIM.\n+   Return the address of the first (left-to-right) character in the number.\n+   Use upper case letters iff UPPER_CASE is nonzero.  */\n+\n+static const wchar_t _itowa_lower_digits[16] = L_(\"0123456789abcdef\");\n+static const wchar_t _itowa_upper_digits[16] = L_(\"0123456789ABCDEF\");\n+\n+static inline wchar_t *\n+__attribute__ ((unused, always_inline))\n+_itowa_word (unsigned long value, wchar_t *buflim,\n+\t     unsigned int base, int upper_case)\n+{\n+  const wchar_t *digits = (upper_case\n+\t\t\t   ? _itowa_upper_digits : _itowa_lower_digits);\n+  wchar_t *bp = buflim;\n+\n+  switch (base)\n+    {\n+#define SPECIAL(Base)\t\t\t\t\t\t\t      \\\n+    case Base:\t\t\t\t\t\t\t\t      \\\n+      do\t\t\t\t\t\t\t\t      \\\n+\t*--bp = digits[value % Base];\t\t\t\t\t      \\\n+      while ((value /= Base) != 0);\t\t\t\t\t      \\\n+      break\n+\n+      SPECIAL (10);\n+      SPECIAL (16);\n+      SPECIAL (8);\n+    default:\n+      do\n+\t*--bp = digits[value % base];\n+      while ((value /= base) != 0);\n+    }\n+  return bp;\n+}\n+\n+static inline wchar_t *\n+__attribute__ ((unused, always_inline))\n+_itowa (uint64_t value, wchar_t *buflim,\n+\tunsigned int base, int upper_case)\n+{\n+  const wchar_t *digits = (upper_case\n+\t\t\t   ? _itowa_upper_digits : _itowa_lower_digits);\n+  wchar_t *bp = buflim;\n+\n+  switch (base)\n+    {\n+      SPECIAL (10);\n+      SPECIAL (16);\n+      SPECIAL (8);\n+    default:\n+      do\n+\t*--bp = digits[value % base];\n+      while ((value /= base) != 0);\n+    }\n+  return bp;\n+}\n+#undef SPECIAL\n+\n+#endif\t/* itowa.h */"}, {"sha": "cf3ab9fdd37ea6baf775c79ca67bf95932e76e3c", "filename": "libquadmath/printf/add_n.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Fadd_n.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Fadd_n.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Fadd_n.c?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -0,0 +1,61 @@\n+/* mpn_add_n -- Add two limb vectors of equal, non-zero length.\n+\n+Copyright (C) 1992, 1993, 1994, 1996 Free Software Foundation, Inc.\n+\n+This file is part of the GNU MP Library.\n+\n+The GNU MP Library is free software; you can redistribute it and/or modify\n+it under the terms of the GNU Lesser General Public License as published by\n+the Free Software Foundation; either version 2.1 of the License, or (at your\n+option) any later version.\n+\n+The GNU MP Library is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public\n+License for more details.\n+\n+You should have received a copy of the GNU Lesser General Public License\n+along with the GNU MP Library; see the file COPYING.LIB.  If not, write to\n+the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,\n+MA 02111-1307, USA. */\n+\n+#include \"gmp-impl.h\"\n+\n+mp_limb_t\n+#if __STDC__\n+mpn_add_n (mp_ptr res_ptr, mp_srcptr s1_ptr, mp_srcptr s2_ptr, mp_size_t size)\n+#else\n+mpn_add_n (res_ptr, s1_ptr, s2_ptr, size)\n+     register mp_ptr res_ptr;\n+     register mp_srcptr s1_ptr;\n+     register mp_srcptr s2_ptr;\n+     mp_size_t size;\n+#endif\n+{\n+  register mp_limb_t x, y, cy;\n+  register mp_size_t j;\n+\n+  /* The loop counter and index J goes from -SIZE to -1.  This way\n+     the loop becomes faster.  */\n+  j = -size;\n+\n+  /* Offset the base pointers to compensate for the negative indices.  */\n+  s1_ptr -= j;\n+  s2_ptr -= j;\n+  res_ptr -= j;\n+\n+  cy = 0;\n+  do\n+    {\n+      y = s2_ptr[j];\n+      x = s1_ptr[j];\n+      y += cy;\t\t\t/* add previous carry to one addend */\n+      cy = (y < cy);\t\t/* get out carry from that addition */\n+      y = x + y;\t\t/* add other addend */\n+      cy = (y < x) + cy;\t/* get out carry from that add, combine */\n+      res_ptr[j] = y;\n+    }\n+  while (++j != 0);\n+\n+  return cy;\n+}"}, {"sha": "41408d5316be85fb090b877da45a415580007f87", "filename": "libquadmath/printf/addmul_1.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Faddmul_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Faddmul_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Faddmul_1.c?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -0,0 +1,63 @@\n+/* mpn_addmul_1 -- multiply the S1_SIZE long limb vector pointed to by S1_PTR\n+   by S2_LIMB, add the S1_SIZE least significant limbs of the product to the\n+   limb vector pointed to by RES_PTR.  Return the most significant limb of\n+   the product, adjusted for carry-out from the addition.\n+\n+Copyright (C) 1992, 1993, 1994, 1996 Free Software Foundation, Inc.\n+\n+This file is part of the GNU MP Library.\n+\n+The GNU MP Library is free software; you can redistribute it and/or modify\n+it under the terms of the GNU Lesser General Public License as published by\n+the Free Software Foundation; either version 2.1 of the License, or (at your\n+option) any later version.\n+\n+The GNU MP Library is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public\n+License for more details.\n+\n+You should have received a copy of the GNU Lesser General Public License\n+along with the GNU MP Library; see the file COPYING.LIB.  If not, write to\n+the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,\n+MA 02111-1307, USA. */\n+\n+#include \"gmp-impl.h\"\n+\n+mp_limb_t\n+mpn_addmul_1 (res_ptr, s1_ptr, s1_size, s2_limb)\n+     register mp_ptr res_ptr;\n+     register mp_srcptr s1_ptr;\n+     mp_size_t s1_size;\n+     register mp_limb_t s2_limb;\n+{\n+  register mp_limb_t cy_limb;\n+  register mp_size_t j;\n+  register mp_limb_t prod_high, prod_low;\n+  register mp_limb_t x;\n+\n+  /* The loop counter and index J goes from -SIZE to -1.  This way\n+     the loop becomes faster.  */\n+  j = -s1_size;\n+\n+  /* Offset the base pointers to compensate for the negative indices.  */\n+  res_ptr -= j;\n+  s1_ptr -= j;\n+\n+  cy_limb = 0;\n+  do\n+    {\n+      umul_ppmm (prod_high, prod_low, s1_ptr[j], s2_limb);\n+\n+      prod_low += cy_limb;\n+      cy_limb = (prod_low < cy_limb) + prod_high;\n+\n+      x = res_ptr[j];\n+      prod_low = x + prod_low;\n+      cy_limb += (prod_low < x);\n+      res_ptr[j] = prod_low;\n+    }\n+  while (++j != 0);\n+\n+  return cy_limb;\n+}"}, {"sha": "d033d19651b0ae5c42afb1efab98b4e3447bd550", "filename": "libquadmath/printf/cmp.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Fcmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Fcmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Fcmp.c?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -0,0 +1,55 @@\n+/* mpn_cmp -- Compare two low-level natural-number integers.\n+\n+Copyright (C) 1991, 1993, 1994, 1996 Free Software Foundation, Inc.\n+\n+This file is part of the GNU MP Library.\n+\n+The GNU MP Library is free software; you can redistribute it and/or modify\n+it under the terms of the GNU Lesser General Public License as published by\n+the Free Software Foundation; either version 2.1 of the License, or (at your\n+option) any later version.\n+\n+The GNU MP Library is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public\n+License for more details.\n+\n+You should have received a copy of the GNU Lesser General Public License\n+along with the GNU MP Library; see the file COPYING.LIB.  If not, write to\n+the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,\n+MA 02111-1307, USA. */\n+\n+#include \"gmp-impl.h\"\n+\n+/* Compare OP1_PTR/OP1_SIZE with OP2_PTR/OP2_SIZE.\n+   There are no restrictions on the relative sizes of\n+   the two arguments.\n+   Return 1 if OP1 > OP2, 0 if they are equal, and -1 if OP1 < OP2.  */\n+\n+int\n+#if __STDC__\n+mpn_cmp (mp_srcptr op1_ptr, mp_srcptr op2_ptr, mp_size_t size)\n+#else\n+mpn_cmp (op1_ptr, op2_ptr, size)\n+     mp_srcptr op1_ptr;\n+     mp_srcptr op2_ptr;\n+     mp_size_t size;\n+#endif\n+{\n+  mp_size_t i;\n+  mp_limb_t op1_word, op2_word;\n+\n+  for (i = size - 1; i >= 0; i--)\n+    {\n+      op1_word = op1_ptr[i];\n+      op2_word = op2_ptr[i];\n+      if (op1_word != op2_word)\n+\tgoto diff;\n+    }\n+  return 0;\n+ diff:\n+  /* This can *not* be simplified to\n+\top2_word - op2_word\n+     since that expression might give signed overflow.  */\n+  return (op1_word > op2_word) ? 1 : -1;\n+}"}, {"sha": "723ea34d1172e1ea0f65cf25d1d2413959c5474b", "filename": "libquadmath/printf/divrem.c", "status": "added", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Fdivrem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Fdivrem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Fdivrem.c?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -0,0 +1,243 @@\n+/* mpn_divrem -- Divide natural numbers, producing both remainder and\n+   quotient.\n+\n+Copyright (C) 1993, 1994, 1995, 1996 Free Software Foundation, Inc.\n+\n+This file is part of the GNU MP Library.\n+\n+The GNU MP Library is free software; you can redistribute it and/or modify\n+it under the terms of the GNU Lesser General Public License as published by\n+the Free Software Foundation; either version 2.1 of the License, or (at your\n+option) any later version.\n+\n+The GNU MP Library is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public\n+License for more details.\n+\n+You should have received a copy of the GNU Lesser General Public License\n+along with the GNU MP Library; see the file COPYING.LIB.  If not, write to\n+the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,\n+MA 02111-1307, USA. */\n+\n+#include \"gmp-impl.h\"\n+\n+/* Divide num (NP/NSIZE) by den (DP/DSIZE) and write\n+   the NSIZE-DSIZE least significant quotient limbs at QP\n+   and the DSIZE long remainder at NP.  If QEXTRA_LIMBS is\n+   non-zero, generate that many fraction bits and append them after the\n+   other quotient limbs.\n+   Return the most significant limb of the quotient, this is always 0 or 1.\n+\n+   Preconditions:\n+   0. NSIZE >= DSIZE.\n+   1. The most significant bit of the divisor must be set.\n+   2. QP must either not overlap with the input operands at all, or\n+      QP + DSIZE >= NP must hold true.  (This means that it's\n+      possible to put the quotient in the high part of NUM, right after the\n+      remainder in NUM.\n+   3. NSIZE >= DSIZE, even if QEXTRA_LIMBS is non-zero.  */\n+\n+mp_limb_t\n+#if __STDC__\n+mpn_divrem (mp_ptr qp, mp_size_t qextra_limbs,\n+\t    mp_ptr np, mp_size_t nsize,\n+\t    mp_srcptr dp, mp_size_t dsize)\n+#else\n+mpn_divrem (qp, qextra_limbs, np, nsize, dp, dsize)\n+     mp_ptr qp;\n+     mp_size_t qextra_limbs;\n+     mp_ptr np;\n+     mp_size_t nsize;\n+     mp_srcptr dp;\n+     mp_size_t dsize;\n+#endif\n+{\n+  mp_limb_t most_significant_q_limb = 0;\n+\n+  switch (dsize)\n+    {\n+    case 0:\n+      /* We are asked to divide by zero, so go ahead and do it!  (To make\n+\t the compiler not remove this statement, return the value.)  */\n+      return 1 / dsize;\n+\n+    case 1:\n+      {\n+\tmp_size_t i;\n+\tmp_limb_t n1;\n+\tmp_limb_t d;\n+\n+\td = dp[0];\n+\tn1 = np[nsize - 1];\n+\n+\tif (n1 >= d)\n+\t  {\n+\t    n1 -= d;\n+\t    most_significant_q_limb = 1;\n+\t  }\n+\n+\tqp += qextra_limbs;\n+\tfor (i = nsize - 2; i >= 0; i--)\n+\t  udiv_qrnnd (qp[i], n1, n1, np[i], d);\n+\tqp -= qextra_limbs;\n+\n+\tfor (i = qextra_limbs - 1; i >= 0; i--)\n+\t  udiv_qrnnd (qp[i], n1, n1, 0, d);\n+\n+\tnp[0] = n1;\n+      }\n+      break;\n+\n+    case 2:\n+      {\n+\tmp_size_t i;\n+\tmp_limb_t n1, n0, n2;\n+\tmp_limb_t d1, d0;\n+\n+\tnp += nsize - 2;\n+\td1 = dp[1];\n+\td0 = dp[0];\n+\tn1 = np[1];\n+\tn0 = np[0];\n+\n+\tif (n1 >= d1 && (n1 > d1 || n0 >= d0))\n+\t  {\n+\t    sub_ddmmss (n1, n0, n1, n0, d1, d0);\n+\t    most_significant_q_limb = 1;\n+\t  }\n+\n+\tfor (i = qextra_limbs + nsize - 2 - 1; i >= 0; i--)\n+\t  {\n+\t    mp_limb_t q;\n+\t    mp_limb_t r;\n+\n+\t    if (i >= qextra_limbs)\n+\t      np--;\n+\t    else\n+\t      np[0] = 0;\n+\n+\t    if (n1 == d1)\n+\t      {\n+\t\t/* Q should be either 111..111 or 111..110.  Need special\n+\t\t   treatment of this rare case as normal division would\n+\t\t   give overflow.  */\n+\t\tq = ~(mp_limb_t) 0;\n+\n+\t\tr = n0 + d1;\n+\t\tif (r < d1)\t/* Carry in the addition? */\n+\t\t  {\n+\t\t    add_ssaaaa (n1, n0, r - d0, np[0], 0, d0);\n+\t\t    qp[i] = q;\n+\t\t    continue;\n+\t\t  }\n+\t\tn1 = d0 - (d0 != 0);\n+\t\tn0 = -d0;\n+\t      }\n+\t    else\n+\t      {\n+\t\tudiv_qrnnd (q, r, n1, n0, d1);\n+\t\tumul_ppmm (n1, n0, d0, q);\n+\t      }\n+\n+\t    n2 = np[0];\n+\t  q_test:\n+\t    if (n1 > r || (n1 == r && n0 > n2))\n+\t      {\n+\t\t/* The estimated Q was too large.  */\n+\t\tq--;\n+\n+\t\tsub_ddmmss (n1, n0, n1, n0, 0, d0);\n+\t\tr += d1;\n+\t\tif (r >= d1)\t/* If not carry, test Q again.  */\n+\t\t  goto q_test;\n+\t      }\n+\n+\t    qp[i] = q;\n+\t    sub_ddmmss (n1, n0, r, n2, n1, n0);\n+\t  }\n+\tnp[1] = n1;\n+\tnp[0] = n0;\n+      }\n+      break;\n+\n+    default:\n+      {\n+\tmp_size_t i;\n+\tmp_limb_t dX, d1, n0;\n+\n+\tnp += nsize - dsize;\n+\tdX = dp[dsize - 1];\n+\td1 = dp[dsize - 2];\n+\tn0 = np[dsize - 1];\n+\n+\tif (n0 >= dX)\n+\t  {\n+\t    if (n0 > dX || mpn_cmp (np, dp, dsize - 1) >= 0)\n+\t      {\n+\t\tmpn_sub_n (np, np, dp, dsize);\n+\t\tn0 = np[dsize - 1];\n+\t\tmost_significant_q_limb = 1;\n+\t      }\n+\t  }\n+\n+\tfor (i = qextra_limbs + nsize - dsize - 1; i >= 0; i--)\n+\t  {\n+\t    mp_limb_t q;\n+\t    mp_limb_t n1, n2;\n+\t    mp_limb_t cy_limb;\n+\n+\t    if (i >= qextra_limbs)\n+\t      {\n+\t\tnp--;\n+\t\tn2 = np[dsize];\n+\t      }\n+\t    else\n+\t      {\n+\t\tn2 = np[dsize - 1];\n+\t\tMPN_COPY_DECR (np + 1, np, dsize);\n+\t\tnp[0] = 0;\n+\t      }\n+\n+\t    if (n0 == dX)\n+\t      /* This might over-estimate q, but it's probably not worth\n+\t\t the extra code here to find out.  */\n+\t      q = ~(mp_limb_t) 0;\n+\t    else\n+\t      {\n+\t\tmp_limb_t r;\n+\n+\t\tudiv_qrnnd (q, r, n0, np[dsize - 1], dX);\n+\t\tumul_ppmm (n1, n0, d1, q);\n+\n+\t\twhile (n1 > r || (n1 == r && n0 > np[dsize - 2]))\n+\t\t  {\n+\t\t    q--;\n+\t\t    r += dX;\n+\t\t    if (r < dX)\t/* I.e. \"carry in previous addition?\"  */\n+\t\t      break;\n+\t\t    n1 -= n0 < d1;\n+\t\t    n0 -= d1;\n+\t\t  }\n+\t      }\n+\n+\t    /* Possible optimization: We already have (q * n0) and (1 * n1)\n+\t       after the calculation of q.  Taking advantage of that, we\n+\t       could make this loop make two iterations less.  */\n+\n+\t    cy_limb = mpn_submul_1 (np, dp, dsize, q);\n+\n+\t    if (n2 != cy_limb)\n+\t      {\n+\t\tmpn_add_n (np, np, dp, dsize);\n+\t\tq--;\n+\t      }\n+\n+\t    qp[i] = q;\n+\t    n0 = np[dsize - 1];\n+\t  }\n+      }\n+    }\n+\n+  return most_significant_q_limb;\n+}"}, {"sha": "0105314ef3a8cbcb37878ec047dcf37fefc49047", "filename": "libquadmath/printf/flt1282mpn.c", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Fflt1282mpn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Fflt1282mpn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Fflt1282mpn.c?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -0,0 +1,136 @@\n+/* Copyright (C) 1995,1996,1997,1998,1999,2002,2003\n+\tFree Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+   02111-1307 USA.  */\n+\n+#include <float.h>\n+#include <math.h>\n+#include <stdlib.h>\n+#include \"gmp-impl.h\"\n+\n+/* Convert a `__float128' in IEEE854 quad-precision format to a\n+   multi-precision integer representing the significand scaled up by its\n+   number of bits (113 for long double) and an integral power of two\n+   (MPN frexpl). */\n+\n+mp_size_t\n+mpn_extract_flt128 (mp_ptr res_ptr, mp_size_t size,\n+\t\t      int *expt, int *is_neg,\n+\t\t      __float128 value)\n+{\n+  ieee854_float128 u;\n+  u.value = value;\n+\n+  *is_neg = u.ieee.negative;\n+  *expt = (int) u.ieee.exponent - IEEE854_FLOAT128_BIAS;\n+\n+#if BITS_PER_MP_LIMB == 32\n+  res_ptr[0] = u.ieee.mant_low; /* Low-order 32 bits of fraction.  */\n+  res_ptr[1] = (u.ieee.mant_low >> 32);\n+  res_ptr[2] = u.ieee.mant_high;\n+  res_ptr[3] = (u.ieee.mant_high >> 32); /* High-order 32 bits.  */\n+  #define N 4\n+#elif BITS_PER_MP_LIMB == 64\n+  res_ptr[0] = u.ieee.mant_low;\n+  res_ptr[1] = u.ieee.mant_high;\n+  #define N 2\n+#else\n+  #error \"mp_limb size \" BITS_PER_MP_LIMB \"not accounted for\"\n+#endif\n+/* The format does not fill the last limb.  There are some zeros.  */\n+#define NUM_LEADING_ZEROS (BITS_PER_MP_LIMB \\\n+\t\t\t   - (FLT128_MANT_DIG - ((N - 1) * BITS_PER_MP_LIMB)))\n+\n+  if (u.ieee.exponent == 0)\n+    {\n+      /* A biased exponent of zero is a special case.\n+\t Either it is a zero or it is a denormal number.  */\n+      if (res_ptr[0] == 0 && res_ptr[1] == 0\n+\t  && res_ptr[N - 2] == 0 && res_ptr[N - 1] == 0) /* Assumes N<=4.  */\n+\t/* It's zero.  */\n+\t*expt = 0;\n+      else\n+\t{\n+\t  /* It is a denormal number, meaning it has no implicit leading\n+  \t     one bit, and its exponent is in fact the format minimum.  */\n+\t  int cnt;\n+\n+#if N == 2\n+\t  if (res_ptr[N - 1] != 0)\n+\t    {\n+\t      count_leading_zeros (cnt, res_ptr[N - 1]);\n+\t      cnt -= NUM_LEADING_ZEROS;\n+\t      res_ptr[N - 1] = res_ptr[N - 1] << cnt\n+\t\t\t       | (res_ptr[0] >> (BITS_PER_MP_LIMB - cnt));\n+\t      res_ptr[0] <<= cnt;\n+\t      *expt = FLT128_MIN_EXP - 1 - cnt;\n+\t    }\n+\t  else\n+\t    {\n+\t      count_leading_zeros (cnt, res_ptr[0]);\n+\t      if (cnt >= NUM_LEADING_ZEROS)\n+\t\t{\n+\t\t  res_ptr[N - 1] = res_ptr[0] << (cnt - NUM_LEADING_ZEROS);\n+\t\t  res_ptr[0] = 0;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  res_ptr[N - 1] = res_ptr[0] >> (NUM_LEADING_ZEROS - cnt);\n+\t\t  res_ptr[0] <<= BITS_PER_MP_LIMB - (NUM_LEADING_ZEROS - cnt);\n+\t\t}\n+\t      *expt = FLT128_MIN_EXP - 1\n+\t\t- (BITS_PER_MP_LIMB - NUM_LEADING_ZEROS) - cnt;\n+\t    }\n+#else\n+\t  int j, k, l;\n+\n+\t  for (j = N - 1; j > 0; j--)\n+\t    if (res_ptr[j] != 0)\n+\t      break;\n+\n+\t  count_leading_zeros (cnt, res_ptr[j]);\n+\t  cnt -= NUM_LEADING_ZEROS;\n+\t  l = N - 1 - j;\n+\t  if (cnt < 0)\n+\t    {\n+\t      cnt += BITS_PER_MP_LIMB;\n+\t      l--;\n+\t    }\n+\t  if (!cnt)\n+\t    for (k = N - 1; k >= l; k--)\n+\t      res_ptr[k] = res_ptr[k-l];\n+\t  else\n+\t    {\n+\t      for (k = N - 1; k > l; k--)\n+\t\tres_ptr[k] = res_ptr[k-l] << cnt\n+\t\t\t     | res_ptr[k-l-1] >> (BITS_PER_MP_LIMB - cnt);\n+\t      res_ptr[k--] = res_ptr[0] << cnt;\n+\t    }\n+\n+\t  for (; k >= 0; k--)\n+\t    res_ptr[k] = 0;\n+\t  *expt = FLT128_MIN_EXP - 1 - l * BITS_PER_MP_LIMB - cnt;\n+#endif\n+\t}\n+    }\n+  else\n+    /* Add the implicit leading one bit for a normalized number.  */\n+    res_ptr[N - 1] |= (mp_limb_t) 1 << (FLT128_MANT_DIG - 1\n+\t\t\t\t\t- ((N - 1) * BITS_PER_MP_LIMB));\n+\n+  return N;\n+}"}, {"sha": "7306770c092e267badf3fac7bd5120f1908f8d6f", "filename": "libquadmath/printf/fpioconst.c", "status": "added", "additions": 462, "deletions": 0, "changes": 462, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Ffpioconst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Ffpioconst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Ffpioconst.c?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -0,0 +1,462 @@\n+/* Table of MP integer constants 10^(2^i), used for floating point <-> decimal.\n+   Copyright (C) 1995, 1996, 1997, 1998, 1999, 2002, 2003\n+   Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+   02111-1307 USA.  */\n+\n+#include \"gmp-impl.h\"\t\t/* This defines BITS_PER_MP_LIMB.  */\n+#include \"fpioconst.h\"\n+\n+/* First page\t: 32-bit limbs\n+   Second page\t: 64-bit limbs\n+   Last page\t: table of pointers\n+ */\n+\n+#if BITS_PER_MP_LIMB == 32\n+\n+/* Table with constants of 10^(2^i), i=0..12 for 32-bit limbs.\t*/\n+\n+const mp_limb_t __tens[] =\n+{\n+#define TENS_P0_IDX\t0\n+#define TENS_P0_SIZE\t3\n+  [TENS_P0_IDX] = 0x00000000, 0x00000000, 0x0000000a,\n+\n+#define TENS_P1_IDX\t(TENS_P0_IDX + TENS_P0_SIZE)\n+#define TENS_P1_SIZE\t3\n+  [TENS_P1_IDX] = 0x00000000, 0x00000000, 0x00000064,\n+\n+#define TENS_P2_IDX\t(TENS_P1_IDX + TENS_P1_SIZE)\n+#define TENS_P2_SIZE\t3\n+  [TENS_P2_IDX] = 0x00000000, 0x00000000, 0x00002710,\n+\n+#define TENS_P3_IDX\t(TENS_P2_IDX + TENS_P2_SIZE)\n+#define TENS_P3_SIZE\t3\n+  [TENS_P3_IDX] = 0x00000000, 0x00000000, 0x05f5e100,\n+\n+#define TENS_P4_IDX\t(TENS_P3_IDX + TENS_P3_SIZE)\n+#define TENS_P4_SIZE\t4\n+  [TENS_P4_IDX] = 0x00000000, 0x00000000, 0x6fc10000, 0x002386f2,\n+\n+#define TENS_P5_IDX\t(TENS_P4_IDX + TENS_P4_SIZE)\n+#define TENS_P5_SIZE\t6\n+  [TENS_P5_IDX] = 0x00000000, 0x00000000, 0x00000000, 0x85acef81, 0x2d6d415b,\n+  0x000004ee,\n+\n+#define TENS_P6_IDX\t(TENS_P5_IDX + TENS_P5_SIZE)\n+#define TENS_P6_SIZE\t9\n+  [TENS_P6_IDX] = 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xbf6a1f01,\n+  0x6e38ed64, 0xdaa797ed, 0xe93ff9f4, 0x00184f03,\n+\n+#define TENS_P7_IDX\t(TENS_P6_IDX + TENS_P6_SIZE)\n+#define TENS_P7_SIZE\t16\n+  [TENS_P7_IDX] = 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x2e953e01, 0x03df9909, 0x0f1538fd, 0x2374e42f, 0xd3cff5ec,\n+  0xc404dc08, 0xbccdb0da, 0xa6337f19, 0xe91f2603, 0x0000024e,\n+\n+#define TENS_P8_IDX\t(TENS_P7_IDX + TENS_P7_SIZE)\n+#define TENS_P8_SIZE\t29\n+  [TENS_P8_IDX] = 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x982e7c01,\n+  0xbed3875b, 0xd8d99f72, 0x12152f87, 0x6bde50c6, 0xcf4a6e70, 0xd595d80f,\n+  0x26b2716e, 0xadc666b0, 0x1d153624, 0x3c42d35a, 0x63ff540e, 0xcc5573c0,\n+  0x65f9ef17, 0x55bc28f2, 0x80dcc7f7, 0xf46eeddc, 0x5fdcefce, 0x000553f7,\n+\n+#ifndef __NO_LONG_DOUBLE_MATH\n+# define TENS_P9_IDX\t(TENS_P8_IDX + TENS_P8_SIZE)\n+# define TENS_P9_SIZE\t56\n+  [TENS_P9_IDX] = 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0xfc6cf801, 0x77f27267, 0x8f9546dc, 0x5d96976f, 0xb83a8a97,\n+  0xc31e1ad9, 0x46c40513, 0x94e65747, 0xc88976c1, 0x4475b579, 0x28f8733b,\n+  0xaa1da1bf, 0x703ed321, 0x1e25cfea, 0xb21a2f22, 0xbc51fb2e, 0x96e14f5d,\n+  0xbfa3edac, 0x329c57ae, 0xe7fc7153, 0xc3fc0695, 0x85a91924, 0xf95f635e,\n+  0xb2908ee0, 0x93abade4, 0x1366732a, 0x9449775c, 0x69be5b0e, 0x7343afac,\n+  0xb099bc81, 0x45a71d46, 0xa2699748, 0x8cb07303, 0x8a0b1f13, 0x8cab8a97,\n+  0xc1d238d9, 0x633415d4, 0x0000001c,\n+\n+# define TENS_P10_IDX\t(TENS_P9_IDX + TENS_P9_SIZE)\n+# define TENS_P10_SIZE\t109\n+  [TENS_P10_IDX] = 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x2919f001,\n+  0xf55b2b72, 0x6e7c215b, 0x1ec29f86, 0x991c4e87, 0x15c51a88, 0x140ac535,\n+  0x4c7d1e1a, 0xcc2cd819, 0x0ed1440e, 0x896634ee, 0x7de16cfb, 0x1e43f61f,\n+  0x9fce837d, 0x231d2b9c, 0x233e55c7, 0x65dc60d7, 0xf451218b, 0x1c5cd134,\n+  0xc9635986, 0x922bbb9f, 0xa7e89431, 0x9f9f2a07, 0x62be695a, 0x8e1042c4,\n+  0x045b7a74, 0x1abe1de3, 0x8ad822a5, 0xba34c411, 0xd814b505, 0xbf3fdeb3,\n+  0x8fc51a16, 0xb1b896bc, 0xf56deeec, 0x31fb6bfd, 0xb6f4654b, 0x101a3616,\n+  0x6b7595fb, 0xdc1a47fe, 0x80d98089, 0x80bda5a5, 0x9a202882, 0x31eb0f66,\n+  0xfc8f1f90, 0x976a3310, 0xe26a7b7e, 0xdf68368a, 0x3ce3a0b8, 0x8e4262ce,\n+  0x75a351a2, 0x6cb0b6c9, 0x44597583, 0x31b5653f, 0xc356e38a, 0x35faaba6,\n+  0x0190fba0, 0x9fc4ed52, 0x88bc491b, 0x1640114a, 0x005b8041, 0xf4f3235e,\n+  0x1e8d4649, 0x36a8de06, 0x73c55349, 0xa7e6bd2a, 0xc1a6970c, 0x47187094,\n+  0xd2db49ef, 0x926c3f5b, 0xae6209d4, 0x2d433949, 0x34f4a3c6, 0xd4305d94,\n+  0xd9d61a05, 0x00000325,\n+\n+# define TENS_P11_IDX\t(TENS_P10_IDX + TENS_P10_SIZE)\n+# define TENS_P11_SIZE\t215\n+  [TENS_P11_IDX] = 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x1333e001, 0xe3096865, 0xb27d4d3f, 0x49e28dcf, 0xec2e4721,\n+  0xee87e354, 0xb6067584, 0x368b8abb, 0xa5e5a191, 0x2ed56d55, 0xfd827773,\n+  0xea50d142, 0x51b78db2, 0x98342c9e, 0xc850dabc, 0x866ed6f1, 0x19342c12,\n+  0x92794987, 0xd2f869c2, 0x66912e4a, 0x71c7fd8f, 0x57a7842d, 0x235552eb,\n+  0xfb7fedcc, 0xf3861ce0, 0x38209ce1, 0x9713b449, 0x34c10134, 0x8c6c54de,\n+  0xa7a8289c, 0x2dbb6643, 0xe3cb64f3, 0x8074ff01, 0xe3892ee9, 0x10c17f94,\n+  0xa8f16f92, 0xa8281ed6, 0x967abbb3, 0x5a151440, 0x9952fbed, 0x13b41e44,\n+  0xafe609c3, 0xa2bca416, 0xf111821f, 0xfb1264b4, 0x91bac974, 0xd6c7d6ab,\n+  0x8e48ff35, 0x4419bd43, 0xc4a65665, 0x685e5510, 0x33554c36, 0xab498697,\n+  0x0dbd21fe, 0x3cfe491d, 0x982da466, 0xcbea4ca7, 0x9e110c7b, 0x79c56b8a,\n+  0x5fc5a047, 0x84d80e2e, 0x1aa9f444, 0x730f203c, 0x6a57b1ab, 0xd752f7a6,\n+  0x87a7dc62, 0x944545ff, 0x40660460, 0x77c1a42f, 0xc9ac375d, 0xe866d7ef,\n+  0x744695f0, 0x81428c85, 0xa1fc6b96, 0xd7917c7b, 0x7bf03c19, 0x5b33eb41,\n+  0x5715f791, 0x8f6cae5f, 0xdb0708fd, 0xb125ac8e, 0x785ce6b7, 0x56c6815b,\n+  0x6f46eadb, 0x4eeebeee, 0x195355d8, 0xa244de3c, 0x9d7389c0, 0x53761abd,\n+  0xcf99d019, 0xde9ec24b, 0x0d76ce39, 0x70beb181, 0x2e55ecee, 0xd5f86079,\n+  0xf56d9d4b, 0xfb8886fb, 0x13ef5a83, 0x408f43c5, 0x3f3389a4, 0xfad37943,\n+  0x58ccf45c, 0xf82df846, 0x415c7f3e, 0x2915e818, 0x8b3d5cf4, 0x6a445f27,\n+  0xf8dbb57a, 0xca8f0070, 0x8ad803ec, 0xb2e87c34, 0x038f9245, 0xbedd8a6c,\n+  0xc7c9dee0, 0x0eac7d56, 0x2ad3fa14, 0xe0de0840, 0xf775677c, 0xf1bd0ad5,\n+  0x92be221e, 0x87fa1fb9, 0xce9d04a4, 0xd2c36fa9, 0x3f6f7024, 0xb028af62,\n+  0x907855ee, 0xd83e49d6, 0x4efac5dc, 0xe7151aab, 0x77cd8c6b, 0x0a753b7d,\n+  0x0af908b4, 0x8c983623, 0xe50f3027, 0x94222771, 0x1d08e2d6, 0xf7e928e6,\n+  0xf2ee5ca6, 0x1b61b93c, 0x11eb962b, 0x9648b21c, 0xce2bcba1, 0x34f77154,\n+  0x7bbebe30, 0xe526a319, 0x8ce329ac, 0xde4a74d2, 0xb5dc53d5, 0x0009e8b3,\n+\n+# define TENS_P12_IDX\t(TENS_P11_IDX + TENS_P11_SIZE)\n+# define TENS_P12_SIZE\t428\n+  [TENS_P12_IDX] = 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n+  0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x2a67c001,\n+  0xd4724e8d, 0x8efe7ae7, 0xf89a1e90, 0xef084117, 0x54e05154, 0x13b1bb51,\n+  0x506be829, 0xfb29b172, 0xe599574e, 0xf0da6146, 0x806c0ed3, 0xb86ae5be,\n+  0x45155e93, 0xc0591cc2, 0x7e1e7c34, 0x7c4823da, 0x1d1f4cce, 0x9b8ba1e8,\n+  0xd6bfdf75, 0xe341be10, 0xc2dfae78, 0x016b67b2, 0x0f237f1a, 0x3dbeabcd,\n+  0xaf6a2574, 0xcab3e6d7, 0x142e0e80, 0x61959127, 0x2c234811, 0x87009701,\n+  0xcb4bf982, 0xf8169c84, 0x88052f8c, 0x68dde6d4, 0xbc131761, 0xff0b0905,\n+  0x54ab9c41, 0x7613b224, 0x1a1c304e, 0x3bfe167b, 0x441c2d47, 0x4f6cea9c,\n+  0x78f06181, 0xeb659fb8, 0x30c7ae41, 0x947e0d0e, 0xa1ebcad7, 0xd97d9556,\n+  0x2130504d, 0x1a8309cb, 0xf2acd507, 0x3f8ec72a, 0xfd82373a, 0x95a842bc,\n+  0x280f4d32, 0xf3618ac0, 0x811a4f04, 0x6dc3a5b4, 0xd3967a1b, 0x15b8c898,\n+  0xdcfe388f, 0x454eb2a0, 0x8738b909, 0x10c4e996, 0x2bd9cc11, 0x3297cd0c,\n+  0x655fec30, 0xae0725b1, 0xf4090ee8, 0x037d19ee, 0x398c6fed, 0x3b9af26b,\n+  0xc994a450, 0xb5341743, 0x75a697b2, 0xac50b9c1, 0x3ccb5b92, 0xffe06205,\n+  0xa8329761, 0xdfea5242, 0xeb83cadb, 0xe79dadf7, 0x3c20ee69, 0x1e0a6817,\n+  0x7021b97a, 0x743074fa, 0x176ca776, 0x77fb8af6, 0xeca19beb, 0x92baf1de,\n+  0xaf63b712, 0xde35c88b, 0xa4eb8f8c, 0xe137d5e9, 0x40b464a0, 0x87d1cde8,\n+  0x42923bbd, 0xcd8f62ff, 0x2e2690f3, 0x095edc16, 0x59c89f1b, 0x1fa8fd5d,\n+  0x5138753d, 0x390a2b29, 0x80152f18, 0x2dd8d925, 0xf984d83e, 0x7a872e74,\n+  0xc19e1faf, 0xed4d542d, 0xecf9b5d0, 0x9462ea75, 0xc53c0adf, 0x0caea134,\n+  0x37a2d439, 0xc8fa2e8a, 0x2181327e, 0x6e7bb827, 0x2d240820, 0x50be10e0,\n+  0x5893d4b8, 0xab312bb9, 0x1f2b2322, 0x440b3f25, 0xbf627ede, 0x72dac789,\n+  0xb608b895, 0x78787e2a, 0x86deb3f0, 0x6fee7aab, 0xbb9373f4, 0x27ecf57b,\n+  0xf7d8b57e, 0xfca26a9f, 0x3d04e8d2, 0xc9df13cb, 0x3172826a, 0xcd9e8d7c,\n+  0xa8fcd8e0, 0xb2c39497, 0x307641d9, 0x1cc939c1, 0x2608c4cf, 0xb6d1c7bf,\n+  0x3d326a7e, 0xeeaf19e6, 0x8e13e25f, 0xee63302b, 0x2dfe6d97, 0x25971d58,\n+  0xe41d3cc4, 0x0a80627c, 0xab8db59a, 0x9eea37c8, 0xe90afb77, 0x90ca19cf,\n+  0x9ee3352c, 0x3613c850, 0xfe78d682, 0x788f6e50, 0x5b060904, 0xb71bd1a4,\n+  0x3fecb534, 0xb32c450c, 0x20c33857, 0xa6e9cfda, 0x0239f4ce, 0x48497187,\n+  0xa19adb95, 0xb492ed8a, 0x95aca6a8, 0x4dcd6cd9, 0xcf1b2350, 0xfbe8b12a,\n+  0x1a67778c, 0x38eb3acc, 0xc32da383, 0xfb126ab1, 0xa03f40a8, 0xed5bf546,\n+  0xe9ce4724, 0x4c4a74fd, 0x73a130d8, 0xd9960e2d, 0xa2ebd6c1, 0x94ab6feb,\n+  0x6f233b7c, 0x49126080, 0x8e7b9a73, 0x4b8c9091, 0xd298f999, 0x35e836b5,\n+  0xa96ddeff, 0x96119b31, 0x6b0dd9bc, 0xc6cc3f8d, 0x282566fb, 0x72b882e7,\n+  0xd6769f3b, 0xa674343d, 0x00fc509b, 0xdcbf7789, 0xd6266a3f, 0xae9641fd,\n+  0x4e89541b, 0x11953407, 0x53400d03, 0x8e0dd75a, 0xe5b53345, 0x108f19ad,\n+  0x108b89bc, 0x41a4c954, 0xe03b2b63, 0x437b3d7f, 0x97aced8e, 0xcbd66670,\n+  0x2c5508c2, 0x650ebc69, 0x5c4f2ef0, 0x904ff6bf, 0x9985a2df, 0x9faddd9e,\n+  0x5ed8d239, 0x25585832, 0xe3e51cb9, 0x0ff4f1d4, 0x56c02d9a, 0x8c4ef804,\n+  0xc1a08a13, 0x13fd01c8, 0xe6d27671, 0xa7c234f4, 0x9d0176cc, 0xd0d73df2,\n+  0x4d8bfa89, 0x544f10cd, 0x2b17e0b2, 0xb70a5c7d, 0xfd86fe49, 0xdf373f41,\n+  0x214495bb, 0x84e857fd, 0x00d313d5, 0x0496fcbe, 0xa4ba4744, 0xe8cac982,\n+  0xaec29e6e, 0x87ec7038, 0x7000a519, 0xaeee333b, 0xff66e42c, 0x8afd6b25,\n+  0x03b4f63b, 0xbd7991dc, 0x5ab8d9c7, 0x2ed4684e, 0x48741a6c, 0xaf06940d,\n+  0x2fdc6349, 0xb03d7ecd, 0xe974996f, 0xac7867f9, 0x52ec8721, 0xbcdd9d4a,\n+  0x8edd2d00, 0x3557de06, 0x41c759f8, 0x3956d4b9, 0xa75409f2, 0x123cd8a1,\n+  0xb6100fab, 0x3e7b21e2, 0x2e8d623b, 0x92959da2, 0xbca35f77, 0x200c03a5,\n+  0x35fcb457, 0x1bb6c6e4, 0xf74eb928, 0x3d5d0b54, 0x87cc1d21, 0x4964046f,\n+  0x18ae4240, 0xd868b275, 0x8bd2b496, 0x1c5563f4, 0xc234d8f5, 0xf868e970,\n+  0xf9151fff, 0xae7be4a2, 0x271133ee, 0xbb0fd922, 0x25254932, 0xa60a9fc0,\n+  0x104bcd64, 0x30290145, 0x00000062\n+#endif\t/* !__NO_LONG_DOUBLE_MATH */\n+};\n+\f\n+#elif BITS_PER_MP_LIMB == 64\n+\n+/* Table with constants of 10^(2^i), i=0..12 for 64-bit limbs.\t*/\n+\n+const mp_limb_t __tens[] =\n+{\n+#define TENS_P0_IDX\t0\n+#define TENS_P0_SIZE\t2\n+  [TENS_P0_IDX] = 0x0000000000000000ull, 0x000000000000000aull,\n+\n+#define TENS_P1_IDX\t(TENS_P0_IDX + TENS_P0_SIZE)\n+#define TENS_P1_SIZE\t2\n+  [TENS_P1_IDX] = 0x0000000000000000ull, 0x0000000000000064ull,\n+\n+#define TENS_P2_IDX\t(TENS_P1_IDX + TENS_P1_SIZE)\n+#define TENS_P2_SIZE\t2\n+  [TENS_P2_IDX] = 0x0000000000000000ull, 0x0000000000002710ull,\n+\n+#define TENS_P3_IDX\t(TENS_P2_IDX + TENS_P2_SIZE)\n+#define TENS_P3_SIZE\t2\n+  [TENS_P3_IDX] = 0x0000000000000000ull, 0x0000000005f5e100ull,\n+\n+#define TENS_P4_IDX\t(TENS_P3_IDX + TENS_P3_SIZE)\n+#define TENS_P4_SIZE\t2\n+  [TENS_P4_IDX] = 0x0000000000000000ull, 0x002386f26fc10000ull,\n+\n+#define TENS_P5_IDX\t(TENS_P4_IDX + TENS_P4_SIZE)\n+#define TENS_P5_SIZE\t3\n+  [TENS_P5_IDX] = 0x0000000000000000ull, 0x85acef8100000000ull,\n+  0x000004ee2d6d415bull,\n+\n+#define TENS_P6_IDX\t(TENS_P5_IDX + TENS_P5_SIZE)\n+#define TENS_P6_SIZE\t5\n+  [TENS_P6_IDX] = 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x6e38ed64bf6a1f01ull, 0xe93ff9f4daa797edull, 0x0000000000184f03ull,\n+\n+#define TENS_P7_IDX\t(TENS_P6_IDX + TENS_P6_SIZE)\n+#define TENS_P7_SIZE\t8\n+  [TENS_P7_IDX] = 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x03df99092e953e01ull, 0x2374e42f0f1538fdull,\n+  0xc404dc08d3cff5ecull, 0xa6337f19bccdb0daull, 0x0000024ee91f2603ull,\n+\n+#define TENS_P8_IDX\t(TENS_P7_IDX + TENS_P7_SIZE)\n+#define TENS_P8_SIZE\t15\n+  [TENS_P8_IDX] = 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0xbed3875b982e7c01ull, 0x12152f87d8d99f72ull, 0xcf4a6e706bde50c6ull,\n+  0x26b2716ed595d80full, 0x1d153624adc666b0ull, 0x63ff540e3c42d35aull,\n+  0x65f9ef17cc5573c0ull, 0x80dcc7f755bc28f2ull, 0x5fdcefcef46eeddcull,\n+  0x00000000000553f7ull,\n+#if FLT128_MAX_EXP > 1024\n+# define TENS_P9_IDX\t(TENS_P8_IDX + TENS_P8_SIZE)\n+# define TENS_P9_SIZE\t28\n+  [TENS_P9_IDX] = 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x77f27267fc6cf801ull, 0x5d96976f8f9546dcull,\n+  0xc31e1ad9b83a8a97ull, 0x94e6574746c40513ull, 0x4475b579c88976c1ull,\n+  0xaa1da1bf28f8733bull, 0x1e25cfea703ed321ull, 0xbc51fb2eb21a2f22ull,\n+  0xbfa3edac96e14f5dull, 0xe7fc7153329c57aeull, 0x85a91924c3fc0695ull,\n+  0xb2908ee0f95f635eull, 0x1366732a93abade4ull, 0x69be5b0e9449775cull,\n+  0xb099bc817343afacull, 0xa269974845a71d46ull, 0x8a0b1f138cb07303ull,\n+  0xc1d238d98cab8a97ull, 0x0000001c633415d4ull,\n+\n+# define TENS_P10_IDX\t(TENS_P9_IDX + TENS_P9_SIZE)\n+# define TENS_P10_SIZE\t55\n+  [TENS_P10_IDX] = 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0xf55b2b722919f001ull, 0x1ec29f866e7c215bull, 0x15c51a88991c4e87ull,\n+  0x4c7d1e1a140ac535ull, 0x0ed1440ecc2cd819ull, 0x7de16cfb896634eeull,\n+  0x9fce837d1e43f61full, 0x233e55c7231d2b9cull, 0xf451218b65dc60d7ull,\n+  0xc96359861c5cd134ull, 0xa7e89431922bbb9full, 0x62be695a9f9f2a07ull,\n+  0x045b7a748e1042c4ull, 0x8ad822a51abe1de3ull, 0xd814b505ba34c411ull,\n+  0x8fc51a16bf3fdeb3ull, 0xf56deeecb1b896bcull, 0xb6f4654b31fb6bfdull,\n+  0x6b7595fb101a3616ull, 0x80d98089dc1a47feull, 0x9a20288280bda5a5ull,\n+  0xfc8f1f9031eb0f66ull, 0xe26a7b7e976a3310ull, 0x3ce3a0b8df68368aull,\n+  0x75a351a28e4262ceull, 0x445975836cb0b6c9ull, 0xc356e38a31b5653full,\n+  0x0190fba035faaba6ull, 0x88bc491b9fc4ed52ull, 0x005b80411640114aull,\n+  0x1e8d4649f4f3235eull, 0x73c5534936a8de06ull, 0xc1a6970ca7e6bd2aull,\n+  0xd2db49ef47187094ull, 0xae6209d4926c3f5bull, 0x34f4a3c62d433949ull,\n+  0xd9d61a05d4305d94ull, 0x0000000000000325ull,\n+\n+# define TENS_P11_IDX\t(TENS_P10_IDX + TENS_P10_SIZE)\n+# define TENS_P11_SIZE\t108\n+  [TENS_P11_IDX] = 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0xe30968651333e001ull, 0x49e28dcfb27d4d3full,\n+  0xee87e354ec2e4721ull, 0x368b8abbb6067584ull, 0x2ed56d55a5e5a191ull,\n+  0xea50d142fd827773ull, 0x98342c9e51b78db2ull, 0x866ed6f1c850dabcull,\n+  0x9279498719342c12ull, 0x66912e4ad2f869c2ull, 0x57a7842d71c7fd8full,\n+  0xfb7fedcc235552ebull, 0x38209ce1f3861ce0ull, 0x34c101349713b449ull,\n+  0xa7a8289c8c6c54deull, 0xe3cb64f32dbb6643ull, 0xe3892ee98074ff01ull,\n+  0xa8f16f9210c17f94ull, 0x967abbb3a8281ed6ull, 0x9952fbed5a151440ull,\n+  0xafe609c313b41e44ull, 0xf111821fa2bca416ull, 0x91bac974fb1264b4ull,\n+  0x8e48ff35d6c7d6abull, 0xc4a656654419bd43ull, 0x33554c36685e5510ull,\n+  0x0dbd21feab498697ull, 0x982da4663cfe491dull, 0x9e110c7bcbea4ca7ull,\n+  0x5fc5a04779c56b8aull, 0x1aa9f44484d80e2eull, 0x6a57b1ab730f203cull,\n+  0x87a7dc62d752f7a6ull, 0x40660460944545ffull, 0xc9ac375d77c1a42full,\n+  0x744695f0e866d7efull, 0xa1fc6b9681428c85ull, 0x7bf03c19d7917c7bull,\n+  0x5715f7915b33eb41ull, 0xdb0708fd8f6cae5full, 0x785ce6b7b125ac8eull,\n+  0x6f46eadb56c6815bull, 0x195355d84eeebeeeull, 0x9d7389c0a244de3cull,\n+  0xcf99d01953761abdull, 0x0d76ce39de9ec24bull, 0x2e55ecee70beb181ull,\n+  0xf56d9d4bd5f86079ull, 0x13ef5a83fb8886fbull, 0x3f3389a4408f43c5ull,\n+  0x58ccf45cfad37943ull, 0x415c7f3ef82df846ull, 0x8b3d5cf42915e818ull,\n+  0xf8dbb57a6a445f27ull, 0x8ad803ecca8f0070ull, 0x038f9245b2e87c34ull,\n+  0xc7c9dee0bedd8a6cull, 0x2ad3fa140eac7d56ull, 0xf775677ce0de0840ull,\n+  0x92be221ef1bd0ad5ull, 0xce9d04a487fa1fb9ull, 0x3f6f7024d2c36fa9ull,\n+  0x907855eeb028af62ull, 0x4efac5dcd83e49d6ull, 0x77cd8c6be7151aabull,\n+  0x0af908b40a753b7dull, 0xe50f30278c983623ull, 0x1d08e2d694222771ull,\n+  0xf2ee5ca6f7e928e6ull, 0x11eb962b1b61b93cull, 0xce2bcba19648b21cull,\n+  0x7bbebe3034f77154ull, 0x8ce329ace526a319ull, 0xb5dc53d5de4a74d2ull,\n+  0x000000000009e8b3ull,\n+\n+# define TENS_P12_IDX\t(TENS_P11_IDX + TENS_P11_SIZE)\n+# define TENS_P12_SIZE\t214\n+  [TENS_P12_IDX] = 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0x0000000000000000ull, 0x0000000000000000ull, 0x0000000000000000ull,\n+  0xd4724e8d2a67c001ull, 0xf89a1e908efe7ae7ull, 0x54e05154ef084117ull,\n+  0x506be82913b1bb51ull, 0xe599574efb29b172ull, 0x806c0ed3f0da6146ull,\n+  0x45155e93b86ae5beull, 0x7e1e7c34c0591cc2ull, 0x1d1f4cce7c4823daull,\n+  0xd6bfdf759b8ba1e8ull, 0xc2dfae78e341be10ull, 0x0f237f1a016b67b2ull,\n+  0xaf6a25743dbeabcdull, 0x142e0e80cab3e6d7ull, 0x2c23481161959127ull,\n+  0xcb4bf98287009701ull, 0x88052f8cf8169c84ull, 0xbc13176168dde6d4ull,\n+  0x54ab9c41ff0b0905ull, 0x1a1c304e7613b224ull, 0x441c2d473bfe167bull,\n+  0x78f061814f6cea9cull, 0x30c7ae41eb659fb8ull, 0xa1ebcad7947e0d0eull,\n+  0x2130504dd97d9556ull, 0xf2acd5071a8309cbull, 0xfd82373a3f8ec72aull,\n+  0x280f4d3295a842bcull, 0x811a4f04f3618ac0ull, 0xd3967a1b6dc3a5b4ull,\n+  0xdcfe388f15b8c898ull, 0x8738b909454eb2a0ull, 0x2bd9cc1110c4e996ull,\n+  0x655fec303297cd0cull, 0xf4090ee8ae0725b1ull, 0x398c6fed037d19eeull,\n+  0xc994a4503b9af26bull, 0x75a697b2b5341743ull, 0x3ccb5b92ac50b9c1ull,\n+  0xa8329761ffe06205ull, 0xeb83cadbdfea5242ull, 0x3c20ee69e79dadf7ull,\n+  0x7021b97a1e0a6817ull, 0x176ca776743074faull, 0xeca19beb77fb8af6ull,\n+  0xaf63b71292baf1deull, 0xa4eb8f8cde35c88bull, 0x40b464a0e137d5e9ull,\n+  0x42923bbd87d1cde8ull, 0x2e2690f3cd8f62ffull, 0x59c89f1b095edc16ull,\n+  0x5138753d1fa8fd5dull, 0x80152f18390a2b29ull, 0xf984d83e2dd8d925ull,\n+  0xc19e1faf7a872e74ull, 0xecf9b5d0ed4d542dull, 0xc53c0adf9462ea75ull,\n+  0x37a2d4390caea134ull, 0x2181327ec8fa2e8aull, 0x2d2408206e7bb827ull,\n+  0x5893d4b850be10e0ull, 0x1f2b2322ab312bb9ull, 0xbf627ede440b3f25ull,\n+  0xb608b89572dac789ull, 0x86deb3f078787e2aull, 0xbb9373f46fee7aabull,\n+  0xf7d8b57e27ecf57bull, 0x3d04e8d2fca26a9full, 0x3172826ac9df13cbull,\n+  0xa8fcd8e0cd9e8d7cull, 0x307641d9b2c39497ull, 0x2608c4cf1cc939c1ull,\n+  0x3d326a7eb6d1c7bfull, 0x8e13e25feeaf19e6ull, 0x2dfe6d97ee63302bull,\n+  0xe41d3cc425971d58ull, 0xab8db59a0a80627cull, 0xe90afb779eea37c8ull,\n+  0x9ee3352c90ca19cfull, 0xfe78d6823613c850ull, 0x5b060904788f6e50ull,\n+  0x3fecb534b71bd1a4ull, 0x20c33857b32c450cull, 0x0239f4cea6e9cfdaull,\n+  0xa19adb9548497187ull, 0x95aca6a8b492ed8aull, 0xcf1b23504dcd6cd9ull,\n+  0x1a67778cfbe8b12aull, 0xc32da38338eb3accull, 0xa03f40a8fb126ab1ull,\n+  0xe9ce4724ed5bf546ull, 0x73a130d84c4a74fdull, 0xa2ebd6c1d9960e2dull,\n+  0x6f233b7c94ab6febull, 0x8e7b9a7349126080ull, 0xd298f9994b8c9091ull,\n+  0xa96ddeff35e836b5ull, 0x6b0dd9bc96119b31ull, 0x282566fbc6cc3f8dull,\n+  0xd6769f3b72b882e7ull, 0x00fc509ba674343dull, 0xd6266a3fdcbf7789ull,\n+  0x4e89541bae9641fdull, 0x53400d0311953407ull, 0xe5b533458e0dd75aull,\n+  0x108b89bc108f19adull, 0xe03b2b6341a4c954ull, 0x97aced8e437b3d7full,\n+  0x2c5508c2cbd66670ull, 0x5c4f2ef0650ebc69ull, 0x9985a2df904ff6bfull,\n+  0x5ed8d2399faddd9eull, 0xe3e51cb925585832ull, 0x56c02d9a0ff4f1d4ull,\n+  0xc1a08a138c4ef804ull, 0xe6d2767113fd01c8ull, 0x9d0176cca7c234f4ull,\n+  0x4d8bfa89d0d73df2ull, 0x2b17e0b2544f10cdull, 0xfd86fe49b70a5c7dull,\n+  0x214495bbdf373f41ull, 0x00d313d584e857fdull, 0xa4ba47440496fcbeull,\n+  0xaec29e6ee8cac982ull, 0x7000a51987ec7038ull, 0xff66e42caeee333bull,\n+  0x03b4f63b8afd6b25ull, 0x5ab8d9c7bd7991dcull, 0x48741a6c2ed4684eull,\n+  0x2fdc6349af06940dull, 0xe974996fb03d7ecdull, 0x52ec8721ac7867f9ull,\n+  0x8edd2d00bcdd9d4aull, 0x41c759f83557de06ull, 0xa75409f23956d4b9ull,\n+  0xb6100fab123cd8a1ull, 0x2e8d623b3e7b21e2ull, 0xbca35f7792959da2ull,\n+  0x35fcb457200c03a5ull, 0xf74eb9281bb6c6e4ull, 0x87cc1d213d5d0b54ull,\n+  0x18ae42404964046full, 0x8bd2b496d868b275ull, 0xc234d8f51c5563f4ull,\n+  0xf9151ffff868e970ull, 0x271133eeae7be4a2ull, 0x25254932bb0fd922ull,\n+  0x104bcd64a60a9fc0ull, 0x0000006230290145ull\n+#endif\n+};\n+\f\n+#else\n+# error \"mp_limb_t size \" BITS_PER_MP_LIMB \"not accounted for\"\n+#endif\n+\n+/* Each of array variable above defines one mpn integer which is a power of 10.\n+   This table points to those variables, indexed by the exponent.  */\n+\n+const struct mp_power _fpioconst_pow10[FLT128_MAX_10_EXP_LOG + 1] =\n+{\n+  { TENS_P0_IDX, TENS_P0_SIZE,\t\t4,\t     },\n+  { TENS_P1_IDX, TENS_P1_SIZE,\t\t7,\t   4 },\n+  { TENS_P2_IDX, TENS_P2_SIZE,\t\t14,\t  10 },\n+  { TENS_P3_IDX, TENS_P3_SIZE,\t\t27,\t  24 },\n+  { TENS_P4_IDX, TENS_P4_SIZE,\t\t54,\t  50 },\n+  { TENS_P5_IDX, TENS_P5_SIZE,\t\t107,\t 103 },\n+  { TENS_P6_IDX, TENS_P6_SIZE,\t\t213,\t 210 },\n+  { TENS_P7_IDX, TENS_P7_SIZE,\t\t426,\t 422 },\n+  { TENS_P8_IDX, TENS_P8_SIZE,  \t851,\t 848 },\n+#if FLT128_MAX_EXP > 1024\n+  { TENS_P9_IDX, TENS_P9_SIZE,\t \t1701,\t1698 },\n+  { TENS_P10_IDX, TENS_P10_SIZE,\t3402,\t3399 },\n+  { TENS_P11_IDX, TENS_P11_SIZE,\t6804,\t6800 },\n+  { TENS_P12_IDX, TENS_P12_SIZE, \t13607, 13604 }\n+#endif\n+};\n+\n+#if LAST_POW10 > _LAST_POW10\n+# error \"Need to expand 10^(2^i) table for i up to\" LAST_POW10\n+#endif"}, {"sha": "41875554708f0f8e4d3069b33aef7dcbd6062fb5", "filename": "libquadmath/printf/fpioconst.h", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Ffpioconst.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Ffpioconst.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Ffpioconst.h?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -0,0 +1,64 @@\n+/* Header file for constants used in floating point <-> decimal conversions.\n+   Copyright (C) 1995, 1996, 1997, 1998, 1999, 2002, 2003\n+   Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+   02111-1307 USA.  */\n+\n+#ifndef _FPIOCONST_H\n+#define\t_FPIOCONST_H\n+\n+#include <float.h>\n+#include <math.h>\n+\n+\n+/* These values are used by __printf_fp, where they are noncritical (if the\n+   value is not large enough, it will just be slower); and by\n+   strtof/strtod/strtold, where it is critical (it's used for overflow\n+   detection).\n+\n+   XXX These should be defined in <float.h>.  For the time being, we have the\n+   IEEE754 values here.  */\n+\n+#define FLT128_MAX_10_EXP_LOG\t12 /* = floor(log_2(FLT128_MAX_10_EXP)) */\n+\n+\n+/* The array with the number representation. */\n+#define __tens __quadmath_tens\n+extern const mp_limb_t __tens[] attribute_hidden;\n+\n+/* Table of powers of ten.  This is used by __printf_fp and by\n+   strtof/strtod/strtold.  */\n+struct mp_power\n+  {\n+    size_t arrayoff;\t\t/* Offset in `__tens'.  */\n+    mp_size_t arraysize;\t/* Size of the array.  */\n+    int p_expo;\t\t\t/* Exponent of the number 10^(2^i).  */\n+    int m_expo;\t\t\t/* Exponent of the number 10^-(2^i-1).  */\n+  };\n+#define _fpioconst_pow10 __quadmath_fpioconst_pow10\n+extern const struct mp_power _fpioconst_pow10[FLT128_MAX_10_EXP_LOG + 1]\n+     attribute_hidden;\n+\n+/* The constants in the array `_fpioconst_pow10' have an offset.  */\n+#if BITS_PER_MP_LIMB == 32\n+# define _FPIO_CONST_OFFSET\t2\n+#else\n+# define _FPIO_CONST_OFFSET\t1\n+#endif\n+\n+\n+#endif\t/* fpioconst.h */"}, {"sha": "4ced3bd076f7f63720b3215bf46e6a008fe86f40", "filename": "libquadmath/printf/gmp-impl.h", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Fgmp-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Fgmp-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Fgmp-impl.h?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -0,0 +1,177 @@\n+/* Include file for internal GNU MP types and definitions.\n+\n+Copyright (C) 1991, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.\n+\n+This file is part of the GNU MP Library.\n+\n+The GNU MP Library is free software; you can redistribute it and/or modify\n+it under the terms of the GNU Lesser General Public License as published by\n+the Free Software Foundation; either version 2.1 of the License, or (at your\n+option) any later version.\n+\n+The GNU MP Library is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public\n+License for more details.\n+\n+You should have received a copy of the GNU Lesser General Public License\n+along with the GNU MP Library; see the file COPYING.LIB.  If not, write to\n+the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,\n+MA 02111-1307, USA. */\n+\n+#include <stdlib.h>\n+#include \"quadmath-imp.h\"\n+\n+#undef alloca\n+#define alloca __builtin_alloca\n+\n+#define ABS(x) (x >= 0 ? x : -x)\n+#ifndef MIN\n+#define MIN(l,o) ((l) < (o) ? (l) : (o))\n+#endif\n+#ifndef MAX\n+#define MAX(h,i) ((h) > (i) ? (h) : (i))\n+#endif\n+\n+#define BITS_PER_MP_LIMB (__SIZEOF_LONG__ * __CHAR_BIT__)\n+#define BYTES_PER_MP_LIMB (BITS_PER_MP_LIMB / __CHAR_BIT__)\n+typedef unsigned long int\tmp_limb_t;\n+typedef long int\t\tmp_limb_signed_t;\n+\n+typedef mp_limb_t *             mp_ptr;\n+typedef const mp_limb_t *\tmp_srcptr;\n+typedef long int                mp_size_t;\n+typedef long int                mp_exp_t;\n+\n+/* Define stuff for longlong.h.  */\n+typedef unsigned int UQItype\t__attribute__ ((mode (QI)));\n+typedef \t int SItype\t__attribute__ ((mode (SI)));\n+typedef unsigned int USItype\t__attribute__ ((mode (SI)));\n+typedef\t\t int DItype\t__attribute__ ((mode (DI)));\n+typedef unsigned int UDItype\t__attribute__ ((mode (DI)));\n+\n+typedef mp_limb_t UWtype;\n+typedef unsigned int UHWtype;\n+#define W_TYPE_SIZE BITS_PER_MP_LIMB\n+\n+#ifdef HAVE_HIDDEN_VISIBILITY\n+#define attribute_hidden __attribute__((__visibility__ (\"hidden\")))\n+#else\n+#define attribute_hidden\n+#endif\n+\n+#include \"../../gcc/longlong.h\"\n+\n+/* Copy NLIMBS *limbs* from SRC to DST.  */\n+#define MPN_COPY_INCR(DST, SRC, NLIMBS) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    mp_size_t __i;\t\t\t\t\t\t\t\\\n+    for (__i = 0; __i < (NLIMBS); __i++)\t\t\t\t\\\n+      (DST)[__i] = (SRC)[__i];\t\t\t\t\t\t\\\n+  } while (0)\n+#define MPN_COPY_DECR(DST, SRC, NLIMBS) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    mp_size_t __i;\t\t\t\t\t\t\t\\\n+    for (__i = (NLIMBS) - 1; __i >= 0; __i--)\t\t\t\t\\\n+      (DST)[__i] = (SRC)[__i];\t\t\t\t\t\t\\\n+  } while (0)\n+#define MPN_COPY MPN_COPY_INCR\n+\n+/* Zero NLIMBS *limbs* AT DST.  */\n+#define MPN_ZERO(DST, NLIMBS) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    mp_size_t __i;\t\t\t\t\t\t\t\\\n+    for (__i = 0; __i < (NLIMBS); __i++)\t\t\t\t\\\n+      (DST)[__i] = 0;\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define MPN_MUL_N_RECURSE(prodp, up, vp, size, tspace) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if ((size) < KARATSUBA_THRESHOLD)\t\t\t\t\t\\\n+      impn_mul_n_basecase (prodp, up, vp, size);\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      impn_mul_n (prodp, up, vp, size, tspace);\t\t\t\\\n+  } while (0);\n+\n+#define __MPN(x) __quadmath_mpn_##x\n+\n+/* Internal mpn calls */\n+#define impn_mul_n_basecase\t__MPN(impn_mul_n_basecase)\n+#define impn_mul_n\t\t__MPN(impn_mul_n)\n+\n+/* Prototypes for internal mpn calls.  */\n+void impn_mul_n_basecase (mp_ptr prodp, mp_srcptr up, mp_srcptr vp,\n+\t\t\t  mp_size_t size) attribute_hidden;\n+void impn_mul_n (mp_ptr prodp, mp_srcptr up, mp_srcptr vp, mp_size_t size,\n+\t\t mp_ptr tspace) attribute_hidden;\n+\n+#define mpn_add_n\t\t__MPN(add_n)\n+#define mpn_addmul_1\t\t__MPN(addmul_1)\n+#define mpn_cmp\t\t\t__MPN(cmp)\n+#define mpn_divrem\t\t__MPN(divrem)\n+#define mpn_lshift\t\t__MPN(lshift)\n+#define mpn_mul\t\t\t__MPN(mul)\n+#define mpn_mul_1\t\t__MPN(mul_1)\n+#define mpn_rshift\t\t__MPN(rshift)\n+#define mpn_sub_n\t\t__MPN(sub_n)\n+#define mpn_submul_1\t\t__MPN(submul_1)\n+\n+mp_limb_t mpn_add_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)\n+     attribute_hidden;\n+mp_limb_t mpn_addmul_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)\n+     attribute_hidden;\n+int mpn_cmp (mp_srcptr, mp_srcptr, mp_size_t) attribute_hidden;\n+mp_limb_t mpn_divrem (mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_srcptr,\n+\t\t      mp_size_t) attribute_hidden;\n+mp_limb_t mpn_lshift (mp_ptr, mp_srcptr, mp_size_t, unsigned int)\n+     attribute_hidden;\n+mp_limb_t mpn_mul (mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t)\n+     attribute_hidden;\n+mp_limb_t mpn_mul_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)\n+     attribute_hidden;\n+mp_limb_t mpn_rshift (mp_ptr, mp_srcptr, mp_size_t, unsigned int)\n+     attribute_hidden;\n+mp_limb_t mpn_sub_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)\n+     attribute_hidden;\n+mp_limb_t mpn_submul_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)\n+     attribute_hidden;\n+\n+#define mpn_extract_flt128 __MPN(extract_flt128)\n+mp_size_t mpn_extract_flt128 (mp_ptr res_ptr, mp_size_t size, int *expt,\n+\t\t\t      int *is_neg, __float128 value) attribute_hidden;\n+\n+#define mpn_divmod(qp,np,nsize,dp,dsize) mpn_divrem (qp,0,np,nsize,dp,dsize)\n+\n+static inline mp_limb_t\n+mpn_add_1 (register mp_ptr res_ptr,\n+\t   register mp_srcptr s1_ptr,\n+\t   register mp_size_t s1_size,\n+\t   register mp_limb_t s2_limb)\n+{\n+  register mp_limb_t x;\n+\n+  x = *s1_ptr++;\n+  s2_limb = x + s2_limb;\n+  *res_ptr++ = s2_limb;\n+  if (s2_limb < x)\n+    {\n+      while (--s1_size != 0)\n+\t{\n+\t  x = *s1_ptr++ + 1;\n+\t  *res_ptr++ = x;\n+\t  if (x != 0)\n+\t    goto fin;\n+\t}\n+\n+      return 1;\n+    }\n+\n+ fin:\n+  if (res_ptr != s1_ptr)\n+    {\n+      mp_size_t i;\n+      for (i = 0; i < s1_size - 1; i++)\n+\tres_ptr[i] = s1_ptr[i];\n+    }\n+  return 0;\n+}"}, {"sha": "b00be87e7df5d8a38a2e17b057b3d20c47a93f3f", "filename": "libquadmath/printf/lshift.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Flshift.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Flshift.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Flshift.c?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -0,0 +1,86 @@\n+/* mpn_lshift -- Shift left low level.\n+\n+Copyright (C) 1991, 1993, 1994, 1996 Free Software Foundation, Inc.\n+\n+This file is part of the GNU MP Library.\n+\n+The GNU MP Library is free software; you can redistribute it and/or modify\n+it under the terms of the GNU Lesser General Public License as published by\n+the Free Software Foundation; either version 2.1 of the License, or (at your\n+option) any later version.\n+\n+The GNU MP Library is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public\n+License for more details.\n+\n+You should have received a copy of the GNU Lesser General Public License\n+along with the GNU MP Library; see the file COPYING.LIB.  If not, write to\n+the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,\n+MA 02111-1307, USA. */\n+\n+#include \"gmp-impl.h\"\n+\n+/* Shift U (pointed to by UP and USIZE digits long) CNT bits to the left\n+   and store the USIZE least significant digits of the result at WP.\n+   Return the bits shifted out from the most significant digit.\n+\n+   Argument constraints:\n+   1. 0 < CNT < BITS_PER_MP_LIMB\n+   2. If the result is to be written over the input, WP must be >= UP.\n+*/\n+\n+mp_limb_t\n+#if __STDC__\n+mpn_lshift (register mp_ptr wp,\n+\t    register mp_srcptr up, mp_size_t usize,\n+\t    register unsigned int cnt)\n+#else\n+mpn_lshift (wp, up, usize, cnt)\n+     register mp_ptr wp;\n+     register mp_srcptr up;\n+     mp_size_t usize;\n+     register unsigned int cnt;\n+#endif\n+{\n+  register mp_limb_t high_limb, low_limb;\n+  register unsigned sh_1, sh_2;\n+  register mp_size_t i;\n+  mp_limb_t retval;\n+\n+#ifdef DEBUG\n+  if (usize == 0 || cnt == 0)\n+    abort ();\n+#endif\n+\n+  sh_1 = cnt;\n+#if 0\n+  if (sh_1 == 0)\n+    {\n+      if (wp != up)\n+\t{\n+\t  /* Copy from high end to low end, to allow specified input/output\n+\t     overlapping.  */\n+\t  for (i = usize - 1; i >= 0; i--)\n+\t    wp[i] = up[i];\n+\t}\n+      return 0;\n+    }\n+#endif\n+\n+  wp += 1;\n+  sh_2 = BITS_PER_MP_LIMB - sh_1;\n+  i = usize - 1;\n+  low_limb = up[i];\n+  retval = low_limb >> sh_2;\n+  high_limb = low_limb;\n+  while (--i >= 0)\n+    {\n+      low_limb = up[i];\n+      wp[i] = (high_limb << sh_1) | (low_limb >> sh_2);\n+      high_limb = low_limb;\n+    }\n+  wp[i] = high_limb << sh_1;\n+\n+  return retval;\n+}"}, {"sha": "8ecbff21cb1ae5bc76cee4388e0d8609a73654b1", "filename": "libquadmath/printf/mul.c", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Fmul.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Fmul.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Fmul.c?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -0,0 +1,147 @@\n+/* mpn_mul -- Multiply two natural numbers.\n+\n+Copyright (C) 1991, 1993, 1994, 1996 Free Software Foundation, Inc.\n+\n+This file is part of the GNU MP Library.\n+\n+The GNU MP Library is free software; you can redistribute it and/or modify\n+it under the terms of the GNU Lesser General Public License as published by\n+the Free Software Foundation; either version 2.1 of the License, or (at your\n+option) any later version.\n+\n+The GNU MP Library is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public\n+License for more details.\n+\n+You should have received a copy of the GNU Lesser General Public License\n+along with the GNU MP Library; see the file COPYING.LIB.  If not, write to\n+the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,\n+MA 02111-1307, USA. */\n+\n+#include \"gmp-impl.h\"\n+\n+/* Multiply the natural numbers u (pointed to by UP, with USIZE limbs)\n+   and v (pointed to by VP, with VSIZE limbs), and store the result at\n+   PRODP.  USIZE + VSIZE limbs are always stored, but if the input\n+   operands are normalized.  Return the most significant limb of the\n+   result.\n+\n+   NOTE: The space pointed to by PRODP is overwritten before finished\n+   with U and V, so overlap is an error.\n+\n+   Argument constraints:\n+   1. USIZE >= VSIZE.\n+   2. PRODP != UP and PRODP != VP, i.e. the destination\n+      must be distinct from the multiplier and the multiplicand.  */\n+\n+/* If KARATSUBA_THRESHOLD is not already defined, define it to a\n+   value which is good on most machines.  */\n+#ifndef KARATSUBA_THRESHOLD\n+#define KARATSUBA_THRESHOLD 32\n+#endif\n+\n+mp_limb_t\n+#if __STDC__\n+mpn_mul (mp_ptr prodp,\n+\t mp_srcptr up, mp_size_t usize,\n+\t mp_srcptr vp, mp_size_t vsize)\n+#else\n+mpn_mul (prodp, up, usize, vp, vsize)\n+     mp_ptr prodp;\n+     mp_srcptr up;\n+     mp_size_t usize;\n+     mp_srcptr vp;\n+     mp_size_t vsize;\n+#endif\n+{\n+  mp_ptr prod_endp = prodp + usize + vsize - 1;\n+  mp_limb_t cy;\n+  mp_ptr tspace;\n+\n+  if (vsize < KARATSUBA_THRESHOLD)\n+    {\n+      /* Handle simple cases with traditional multiplication.\n+\n+\t This is the most critical code of the entire function.  All\n+\t multiplies rely on this, both small and huge.  Small ones arrive\n+\t here immediately.  Huge ones arrive here as this is the base case\n+\t for Karatsuba's recursive algorithm below.  */\n+      mp_size_t i;\n+      mp_limb_t cy_limb;\n+      mp_limb_t v_limb;\n+\n+      if (vsize == 0)\n+\treturn 0;\n+\n+      /* Multiply by the first limb in V separately, as the result can be\n+\t stored (not added) to PROD.  We also avoid a loop for zeroing.  */\n+      v_limb = vp[0];\n+      if (v_limb <= 1)\n+\t{\n+\t  if (v_limb == 1)\n+\t    MPN_COPY (prodp, up, usize);\n+\t  else\n+\t    MPN_ZERO (prodp, usize);\n+\t  cy_limb = 0;\n+\t}\n+      else\n+\tcy_limb = mpn_mul_1 (prodp, up, usize, v_limb);\n+\n+      prodp[usize] = cy_limb;\n+      prodp++;\n+\n+      /* For each iteration in the outer loop, multiply one limb from\n+\t U with one limb from V, and add it to PROD.  */\n+      for (i = 1; i < vsize; i++)\n+\t{\n+\t  v_limb = vp[i];\n+\t  if (v_limb <= 1)\n+\t    {\n+\t      cy_limb = 0;\n+\t      if (v_limb == 1)\n+\t\tcy_limb = mpn_add_n (prodp, prodp, up, usize);\n+\t    }\n+\t  else\n+\t    cy_limb = mpn_addmul_1 (prodp, up, usize, v_limb);\n+\n+\t  prodp[usize] = cy_limb;\n+\t  prodp++;\n+\t}\n+      return cy_limb;\n+    }\n+\n+  tspace = (mp_ptr) alloca (2 * vsize * BYTES_PER_MP_LIMB);\n+  MPN_MUL_N_RECURSE (prodp, up, vp, vsize, tspace);\n+\n+  prodp += vsize;\n+  up += vsize;\n+  usize -= vsize;\n+  if (usize >= vsize)\n+    {\n+      mp_ptr tp = (mp_ptr) alloca (2 * vsize * BYTES_PER_MP_LIMB);\n+      do\n+\t{\n+\t  MPN_MUL_N_RECURSE (tp, up, vp, vsize, tspace);\n+\t  cy = mpn_add_n (prodp, prodp, tp, vsize);\n+\t  mpn_add_1 (prodp + vsize, tp + vsize, vsize, cy);\n+\t  prodp += vsize;\n+\t  up += vsize;\n+\t  usize -= vsize;\n+\t}\n+      while (usize >= vsize);\n+    }\n+\n+  /* True: usize < vsize.  */\n+\n+  /* Make life simple: Recurse.  */\n+\n+  if (usize != 0)\n+    {\n+      mpn_mul (tspace, vp, vsize, up, usize);\n+      cy = mpn_add_n (prodp, prodp, tspace, vsize);\n+      mpn_add_1 (prodp + vsize, tspace + vsize, usize, cy);\n+    }\n+\n+  return *prod_endp;\n+}"}, {"sha": "bc363f7241b7dc1c5243c9f698408d14d43fc371", "filename": "libquadmath/printf/mul_1.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Fmul_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Fmul_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Fmul_1.c?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -0,0 +1,57 @@\n+/* mpn_mul_1 -- Multiply a limb vector with a single limb and\n+   store the product in a second limb vector.\n+\n+Copyright (C) 1991, 1992, 1993, 1994, 1996 Free Software Foundation, Inc.\n+\n+This file is part of the GNU MP Library.\n+\n+The GNU MP Library is free software; you can redistribute it and/or modify\n+it under the terms of the GNU Lesser General Public License as published by\n+the Free Software Foundation; either version 2.1 of the License, or (at your\n+option) any later version.\n+\n+The GNU MP Library is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public\n+License for more details.\n+\n+You should have received a copy of the GNU Lesser General Public License\n+along with the GNU MP Library; see the file COPYING.LIB.  If not, write to\n+the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,\n+MA 02111-1307, USA. */\n+\n+#include \"gmp-impl.h\"\n+\n+mp_limb_t\n+mpn_mul_1 (res_ptr, s1_ptr, s1_size, s2_limb)\n+     register mp_ptr res_ptr;\n+     register mp_srcptr s1_ptr;\n+     mp_size_t s1_size;\n+     register mp_limb_t s2_limb;\n+{\n+  register mp_limb_t cy_limb;\n+  register mp_size_t j;\n+  register mp_limb_t prod_high, prod_low;\n+\n+  /* The loop counter and index J goes from -S1_SIZE to -1.  This way\n+     the loop becomes faster.  */\n+  j = -s1_size;\n+\n+  /* Offset the base pointers to compensate for the negative indices.  */\n+  s1_ptr -= j;\n+  res_ptr -= j;\n+\n+  cy_limb = 0;\n+  do\n+    {\n+      umul_ppmm (prod_high, prod_low, s1_ptr[j], s2_limb);\n+\n+      prod_low += cy_limb;\n+      cy_limb = (prod_low < cy_limb) + prod_high;\n+\n+      res_ptr[j] = prod_low;\n+    }\n+  while (++j != 0);\n+\n+  return cy_limb;\n+}"}, {"sha": "21b7b8ce09201b17a92095da66a75868e6be4383", "filename": "libquadmath/printf/mul_n.c", "status": "added", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Fmul_n.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Fmul_n.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Fmul_n.c?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -0,0 +1,219 @@\n+/* mpn_mul_n -- Multiply two natural numbers of length n.\n+\n+Copyright (C) 1991, 1992, 1993, 1994, 1996 Free Software Foundation, Inc.\n+\n+This file is part of the GNU MP Library.\n+\n+The GNU MP Library is free software; you can redistribute it and/or modify\n+it under the terms of the GNU Lesser General Public License as published by\n+the Free Software Foundation; either version 2.1 of the License, or (at your\n+option) any later version.\n+\n+The GNU MP Library is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public\n+License for more details.\n+\n+You should have received a copy of the GNU Lesser General Public License\n+along with the GNU MP Library; see the file COPYING.LIB.  If not, write to\n+the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,\n+MA 02111-1307, USA. */\n+\n+#include \"gmp-impl.h\"\n+\n+/* Multiply the natural numbers u (pointed to by UP) and v (pointed to by VP),\n+   both with SIZE limbs, and store the result at PRODP.  2 * SIZE limbs are\n+   always stored.  Return the most significant limb.\n+\n+   Argument constraints:\n+   1. PRODP != UP and PRODP != VP, i.e. the destination\n+      must be distinct from the multiplier and the multiplicand.  */\n+\n+/* If KARATSUBA_THRESHOLD is not already defined, define it to a\n+   value which is good on most machines.  */\n+#ifndef KARATSUBA_THRESHOLD\n+#define KARATSUBA_THRESHOLD 32\n+#endif\n+\n+/* The code can't handle KARATSUBA_THRESHOLD smaller than 2.  */\n+#if KARATSUBA_THRESHOLD < 2\n+#undef KARATSUBA_THRESHOLD\n+#define KARATSUBA_THRESHOLD 2\n+#endif\n+\n+/* Handle simple cases with traditional multiplication.\n+\n+   This is the most critical code of multiplication.  All multiplies rely\n+   on this, both small and huge.  Small ones arrive here immediately.  Huge\n+   ones arrive here as this is the base case for Karatsuba's recursive\n+   algorithm below.  */\n+\n+void\n+#if __STDC__\n+impn_mul_n_basecase (mp_ptr prodp, mp_srcptr up, mp_srcptr vp, mp_size_t size)\n+#else\n+impn_mul_n_basecase (prodp, up, vp, size)\n+     mp_ptr prodp;\n+     mp_srcptr up;\n+     mp_srcptr vp;\n+     mp_size_t size;\n+#endif\n+{\n+  mp_size_t i;\n+  mp_limb_t cy_limb;\n+  mp_limb_t v_limb;\n+\n+  /* Multiply by the first limb in V separately, as the result can be\n+     stored (not added) to PROD.  We also avoid a loop for zeroing.  */\n+  v_limb = vp[0];\n+  if (v_limb <= 1)\n+    {\n+      if (v_limb == 1)\n+\tMPN_COPY (prodp, up, size);\n+      else\n+\tMPN_ZERO (prodp, size);\n+      cy_limb = 0;\n+    }\n+  else\n+    cy_limb = mpn_mul_1 (prodp, up, size, v_limb);\n+\n+  prodp[size] = cy_limb;\n+  prodp++;\n+\n+  /* For each iteration in the outer loop, multiply one limb from\n+     U with one limb from V, and add it to PROD.  */\n+  for (i = 1; i < size; i++)\n+    {\n+      v_limb = vp[i];\n+      if (v_limb <= 1)\n+\t{\n+\t  cy_limb = 0;\n+\t  if (v_limb == 1)\n+\t    cy_limb = mpn_add_n (prodp, prodp, up, size);\n+\t}\n+      else\n+\tcy_limb = mpn_addmul_1 (prodp, up, size, v_limb);\n+\n+      prodp[size] = cy_limb;\n+      prodp++;\n+    }\n+}\n+\n+void\n+#if __STDC__\n+impn_mul_n (mp_ptr prodp,\n+\t     mp_srcptr up, mp_srcptr vp, mp_size_t size, mp_ptr tspace)\n+#else\n+impn_mul_n (prodp, up, vp, size, tspace)\n+     mp_ptr prodp;\n+     mp_srcptr up;\n+     mp_srcptr vp;\n+     mp_size_t size;\n+     mp_ptr tspace;\n+#endif\n+{\n+  if ((size & 1) != 0)\n+    {\n+      /* The size is odd, the code code below doesn't handle that.\n+\t Multiply the least significant (size - 1) limbs with a recursive\n+\t call, and handle the most significant limb of S1 and S2\n+\t separately.  */\n+      /* A slightly faster way to do this would be to make the Karatsuba\n+\t code below behave as if the size were even, and let it check for\n+\t odd size in the end.  I.e., in essence move this code to the end.\n+\t Doing so would save us a recursive call, and potentially make the\n+\t stack grow a lot less.  */\n+\n+      mp_size_t esize = size - 1;\t/* even size */\n+      mp_limb_t cy_limb;\n+\n+      MPN_MUL_N_RECURSE (prodp, up, vp, esize, tspace);\n+      cy_limb = mpn_addmul_1 (prodp + esize, up, esize, vp[esize]);\n+      prodp[esize + esize] = cy_limb;\n+      cy_limb = mpn_addmul_1 (prodp + esize, vp, size, up[esize]);\n+\n+      prodp[esize + size] = cy_limb;\n+    }\n+  else\n+    {\n+      /* Anatolij Alekseevich Karatsuba's divide-and-conquer algorithm.\n+\n+\t Split U in two pieces, U1 and U0, such that\n+\t U = U0 + U1*(B**n),\n+\t and V in V1 and V0, such that\n+\t V = V0 + V1*(B**n).\n+\n+\t UV is then computed recursively using the identity\n+\n+\t\t2n   n          n                     n\n+\t UV = (B  + B )U V  +  B (U -U )(V -V )  +  (B + 1)U V\n+\t\t\t1 1        1  0   0  1              0 0\n+\n+\t Where B = 2**BITS_PER_MP_LIMB.  */\n+\n+      mp_size_t hsize = size >> 1;\n+      mp_limb_t cy;\n+      int negflg;\n+\n+      /*** Product H.\t ________________  ________________\n+\t\t\t|_____U1 x V1____||____U0 x V0_____|  */\n+      /* Put result in upper part of PROD and pass low part of TSPACE\n+\t as new TSPACE.  */\n+      MPN_MUL_N_RECURSE (prodp + size, up + hsize, vp + hsize, hsize, tspace);\n+\n+      /*** Product M.\t ________________\n+\t\t\t|_(U1-U0)(V0-V1)_|  */\n+      if (mpn_cmp (up + hsize, up, hsize) >= 0)\n+\t{\n+\t  mpn_sub_n (prodp, up + hsize, up, hsize);\n+\t  negflg = 0;\n+\t}\n+      else\n+\t{\n+\t  mpn_sub_n (prodp, up, up + hsize, hsize);\n+\t  negflg = 1;\n+\t}\n+      if (mpn_cmp (vp + hsize, vp, hsize) >= 0)\n+\t{\n+\t  mpn_sub_n (prodp + hsize, vp + hsize, vp, hsize);\n+\t  negflg ^= 1;\n+\t}\n+      else\n+\t{\n+\t  mpn_sub_n (prodp + hsize, vp, vp + hsize, hsize);\n+\t  /* No change of NEGFLG.  */\n+\t}\n+      /* Read temporary operands from low part of PROD.\n+\t Put result in low part of TSPACE using upper part of TSPACE\n+\t as new TSPACE.  */\n+      MPN_MUL_N_RECURSE (tspace, prodp, prodp + hsize, hsize, tspace + size);\n+\n+      /*** Add/copy product H.  */\n+      MPN_COPY (prodp + hsize, prodp + size, hsize);\n+      cy = mpn_add_n (prodp + size, prodp + size, prodp + size + hsize, hsize);\n+\n+      /*** Add product M (if NEGFLG M is a negative number).  */\n+      if (negflg)\n+\tcy -= mpn_sub_n (prodp + hsize, prodp + hsize, tspace, size);\n+      else\n+\tcy += mpn_add_n (prodp + hsize, prodp + hsize, tspace, size);\n+\n+      /*** Product L.\t ________________  ________________\n+\t\t\t|________________||____U0 x V0_____|  */\n+      /* Read temporary operands from low part of PROD.\n+\t Put result in low part of TSPACE using upper part of TSPACE\n+\t as new TSPACE.  */\n+      MPN_MUL_N_RECURSE (tspace, up, vp, hsize, tspace + size);\n+\n+      /*** Add/copy Product L (twice).  */\n+\n+      cy += mpn_add_n (prodp + hsize, prodp + hsize, tspace, size);\n+      if (cy)\n+\tmpn_add_1 (prodp + hsize + size, prodp + hsize + size, hsize, cy);\n+\n+      MPN_COPY (prodp, tspace, hsize);\n+      cy = mpn_add_n (prodp + hsize, prodp + hsize, tspace + hsize, hsize);\n+      if (cy)\n+\tmpn_add_1 (prodp + size, prodp + size, size, 1);\n+    }\n+}"}, {"sha": "d3063ebf490d026be26859aeb8f8e2c4d0c7d4b0", "filename": "libquadmath/printf/printf_fp.c", "status": "added", "additions": 1244, "deletions": 0, "changes": 1244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Fprintf_fp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Fprintf_fp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Fprintf_fp.c?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -0,0 +1,1244 @@\n+/* Floating point output for `printf'.\n+   Copyright (C) 1995-2003, 2006-2008, 2011 Free Software Foundation, Inc.\n+\n+   This file is part of the GNU C Library.\n+   Written by Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1995.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+   02111-1307 USA.  */\n+\n+#include <config.h>\n+#include <alloca.h>\n+#include <float.h>\n+#include <math.h>\n+#include <string.h>\n+#include <unistd.h>\n+#include <stdlib.h>\n+#define NDEBUG\n+#include <assert.h>\n+#ifdef HAVE_ERRNO_H\n+#include <errno.h>\n+#endif\n+#include <stdio.h>\n+#include <stdarg.h>\n+#include \"quadmath-printf.h\"\n+#include \"fpioconst.h\"\n+\n+#ifdef USE_I18N_NUMBER_H\n+#include \"_i18n_number.h\"\n+#else\n+#define USE_I18N_NUMBER_H 0\n+#endif\n+\n+\f\n+/* Macros for doing the actual output.  */\n+\n+#define outchar(ch)\t\t\t\t\t\t\t      \\\n+  do\t\t\t\t\t\t\t\t\t      \\\n+    {\t\t\t\t\t\t\t\t\t      \\\n+      register const int outc = (ch);\t\t\t\t\t      \\\n+      if (PUTC (outc, fp) == EOF)\t\t\t\t\t      \\\n+\t{\t\t\t\t\t\t\t\t      \\\n+\t  if (buffer_malloced)\t\t\t\t\t\t      \\\n+\t    free (wbuffer);\t\t\t\t\t\t      \\\n+\t  return -1;\t\t\t\t\t\t\t      \\\n+\t}\t\t\t\t\t\t\t\t      \\\n+      ++done;\t\t\t\t\t\t\t\t      \\\n+    } while (0)\n+\n+#define PRINT(ptr, wptr, len)\t\t\t\t\t\t      \\\n+  do\t\t\t\t\t\t\t\t\t      \\\n+    {\t\t\t\t\t\t\t\t\t      \\\n+      register size_t outlen = (len);\t\t\t\t\t      \\\n+      if (len > 20)\t\t\t\t\t\t\t      \\\n+\t{\t\t\t\t\t\t\t\t      \\\n+\t  if (PUT (fp, wide ? (const char *) wptr : ptr, outlen) != outlen)   \\\n+\t    {\t\t\t\t\t\t\t\t      \\\n+\t      if (buffer_malloced)\t\t\t\t\t      \\\n+\t\tfree (wbuffer);\t\t\t\t\t\t      \\\n+\t      return -1;\t\t\t\t\t\t      \\\n+\t    }\t\t\t\t\t\t\t\t      \\\n+\t  ptr += outlen;\t\t\t\t\t\t      \\\n+\t  done += outlen;\t\t\t\t\t\t      \\\n+\t}\t\t\t\t\t\t\t\t      \\\n+      else\t\t\t\t\t\t\t\t      \\\n+\t{\t\t\t\t\t\t\t\t      \\\n+\t  if (wide)\t\t\t\t\t\t\t      \\\n+\t    while (outlen-- > 0)\t\t\t\t\t      \\\n+\t      outchar (*wptr++);\t\t\t\t\t      \\\n+\t  else\t\t\t\t\t\t\t\t      \\\n+\t    while (outlen-- > 0)\t\t\t\t\t      \\\n+\t      outchar (*ptr++);\t\t\t\t\t\t      \\\n+\t}\t\t\t\t\t\t\t\t      \\\n+    } while (0)\n+\n+#define PADN(ch, len)\t\t\t\t\t\t\t      \\\n+  do\t\t\t\t\t\t\t\t\t      \\\n+    {\t\t\t\t\t\t\t\t\t      \\\n+      if (PAD (fp, ch, len) != len)\t\t\t\t\t      \\\n+\t{\t\t\t\t\t\t\t\t      \\\n+\t  if (buffer_malloced)\t\t\t\t\t\t      \\\n+\t    free (wbuffer);\t\t\t\t\t\t      \\\n+\t  return -1;\t\t\t\t\t\t\t      \\\n+\t}\t\t\t\t\t\t\t\t      \\\n+      done += len;\t\t\t\t\t\t\t      \\\n+    }\t\t\t\t\t\t\t\t\t      \\\n+  while (0)\n+\n+\f\n+/* We use the GNU MP library to handle large numbers.\n+\n+   An MP variable occupies a varying number of entries in its array.  We keep\n+   track of this number for efficiency reasons.  Otherwise we would always\n+   have to process the whole array.  */\n+#define MPN_VAR(name) mp_limb_t *name; mp_size_t name##size\n+\n+#define MPN_ASSIGN(dst,src)\t\t\t\t\t\t      \\\n+  memcpy (dst, src, (dst##size = src##size) * sizeof (mp_limb_t))\n+#define MPN_GE(u,v) \\\n+  (u##size > v##size || (u##size == v##size && mpn_cmp (u, v, u##size) >= 0))\n+\n+extern mp_size_t mpn_extract_flt128 (mp_ptr res_ptr, mp_size_t size,\n+\t\t\t\t     int *expt, int *is_neg,\n+\t\t\t\t     __float128 value) attribute_hidden;\n+static unsigned int guess_grouping (unsigned int intdig_max,\n+\t\t\t\t    const char *grouping);\n+\n+\n+static wchar_t *group_number (wchar_t *buf, wchar_t *bufend,\n+\t\t\t      unsigned int intdig_no, const char *grouping,\n+\t\t\t      wchar_t thousands_sep, int ngroups);\n+\n+\n+int\n+__quadmath_printf_fp (struct __quadmath_printf_file *fp,\n+\t\t      const struct printf_info *info,\n+\t\t      const void *const *args)\n+{\n+  /* The floating-point value to output.  */\n+  __float128 fpnum;\n+\n+  /* Locale-dependent representation of decimal point.\t*/\n+  const char *decimal;\n+  wchar_t decimalwc;\n+\n+  /* Locale-dependent thousands separator and grouping specification.  */\n+  const char *thousands_sep = NULL;\n+  wchar_t thousands_sepwc = L_('\\0');\n+  const char *grouping;\n+\n+  /* \"NaN\" or \"Inf\" for the special cases.  */\n+  const char *special = NULL;\n+  const wchar_t *wspecial = NULL;\n+\n+  /* We need just a few limbs for the input before shifting to the right\n+     position.\t*/\n+  mp_limb_t fp_input[(FLT128_MANT_DIG + BITS_PER_MP_LIMB - 1) / BITS_PER_MP_LIMB];\n+  /* We need to shift the contents of fp_input by this amount of bits.\t*/\n+  int to_shift = 0;\n+\n+  /* The fraction of the floting-point value in question  */\n+  MPN_VAR(frac);\n+  /* and the exponent.\t*/\n+  int exponent;\n+  /* Sign of the exponent.  */\n+  int expsign = 0;\n+  /* Sign of float number.  */\n+  int is_neg = 0;\n+\n+  /* Scaling factor.  */\n+  MPN_VAR(scale);\n+\n+  /* Temporary bignum value.  */\n+  MPN_VAR(tmp);\n+\n+  /* Digit which is result of last hack_digit() call.  */\n+  wchar_t digit;\n+\n+  /* The type of output format that will be used: 'e'/'E' or 'f'.  */\n+  int type;\n+\n+  /* Counter for number of written characters.\t*/\n+  int done = 0;\n+\n+  /* General helper (carry limb).  */\n+  mp_limb_t cy;\n+\n+  /* Nonzero if this is output on a wide character stream.  */\n+  int wide = info->wide;\n+\n+  /* Buffer in which we produce the output.  */\n+  wchar_t *wbuffer = NULL;\n+  /* Flag whether wbuffer is malloc'ed or not.  */\n+  int buffer_malloced = 0;\n+\n+  auto wchar_t hack_digit (void);\n+\n+  wchar_t hack_digit (void)\n+    {\n+      mp_limb_t hi;\n+\n+      if (expsign != 0 && type == 'f' && exponent-- > 0)\n+\thi = 0;\n+      else if (scalesize == 0)\n+\t{\n+\t  hi = frac[fracsize - 1];\n+\t  frac[fracsize - 1] = mpn_mul_1 (frac, frac, fracsize - 1, 10);\n+\t}\n+      else\n+\t{\n+\t  if (fracsize < scalesize)\n+\t    hi = 0;\n+\t  else\n+\t    {\n+\t      hi = mpn_divmod (tmp, frac, fracsize, scale, scalesize);\n+\t      tmp[fracsize - scalesize] = hi;\n+\t      hi = tmp[0];\n+\n+\t      fracsize = scalesize;\n+\t      while (fracsize != 0 && frac[fracsize - 1] == 0)\n+\t\t--fracsize;\n+\t      if (fracsize == 0)\n+\t\t{\n+\t\t  /* We're not prepared for an mpn variable with zero\n+\t\t     limbs.  */\n+\t\t  fracsize = 1;\n+\t\t  return L_('0') + hi;\n+\t\t}\n+\t    }\n+\n+\t  mp_limb_t _cy = mpn_mul_1 (frac, frac, fracsize, 10);\n+\t  if (_cy != 0)\n+\t    frac[fracsize++] = _cy;\n+\t}\n+\n+      return L_('0') + hi;\n+    }\n+\n+  /* Figure out the decimal point character.  */\n+#ifdef USE_LOCALE_SUPPORT\n+  if (info->extra == 0)\n+    {\n+      decimal = nl_langinfo (DECIMAL_POINT);\n+      decimalwc = nl_langinfo_wc (_NL_NUMERIC_DECIMAL_POINT_WC);\n+    }\n+  else\n+    {\n+      decimal = nl_langinfo (MON_DECIMAL_POINT);\n+      if (*decimal == '\\0')\n+\tdecimal = nl_langinfo (DECIMAL_POINT);\n+      decimalwc = nl_langinfo_wc (_NL_MONETARY_DECIMAL_POINT_WC);\n+      if (decimalwc == L_('\\0'))\n+\tdecimalwc = nl_langinfo_wc (_NL_NUMERIC_DECIMAL_POINT_WC);\n+    }\n+  /* The decimal point character must not be zero.  */\n+  assert (*decimal != '\\0');\n+  assert (decimalwc != L_('\\0'));\n+#else\n+  decimal = \".\";\n+  decimalwc = L_('.');\n+#endif\n+\n+#ifdef USE_LOCALE_SUPPORT\n+  if (info->group)\n+    {\n+      if (info->extra == 0)\n+\tgrouping = nl_langinfo (GROUPING);\n+      else\n+\tgrouping = nl_langinfo (MON_GROUPING);\n+\n+      if (*grouping <= 0 || *grouping == CHAR_MAX)\n+\tgrouping = NULL;\n+      else\n+\t{\n+\t  /* Figure out the thousands separator character.  */\n+\t  if (wide)\n+\t    {\n+\t      if (info->extra == 0)\n+\t\tthousands_sepwc = nl_langinfo_wc (_NL_NUMERIC_THOUSANDS_SEP_WC);\n+\t      else\n+\t\tthousands_sepwc = nl_langinfo_wc (_NL_MONETARY_THOUSANDS_SEP_WC);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (info->extra == 0)\n+\t\tthousands_sep = nl_langinfo (THOUSANDS_SEP);\n+\t      else\n+\t\tthousands_sep = nl_langinfo (MON_THOUSANDS_SEP);\n+\t    }\n+\n+\t  if ((wide && thousands_sepwc == L_('\\0'))\n+\t      || (! wide && *thousands_sep == '\\0'))\n+\t    grouping = NULL;\n+\t  else if (thousands_sepwc == L_('\\0'))\n+\t    /* If we are printing multibyte characters and there is a\n+\t       multibyte representation for the thousands separator,\n+\t       we must ensure the wide character thousands separator\n+\t       is available, even if it is fake.  */\n+\t    thousands_sepwc = (wchar_t) 0xfffffffe;\n+\t}\n+    }\n+  else\n+#endif\n+    grouping = NULL;\n+\n+  /* Fetch the argument value.\t*/\n+    {\n+      fpnum = **(const __float128 **) args[0];\n+\n+      /* Check for special values: not a number or infinity.  */\n+      if (isnanq (fpnum))\n+\t{\n+\t  ieee854_float128 u = { .value = fpnum };\n+\t  is_neg = u.ieee.negative != 0;\n+\t  if (isupper (info->spec))\n+\t    {\n+\t      special = \"NAN\";\n+\t      wspecial = L_(\"NAN\");\n+\t    }\n+\t    else\n+\t      {\n+\t\tspecial = \"nan\";\n+\t\twspecial = L_(\"nan\");\n+\t      }\n+\t}\n+      else if (isinfq (fpnum))\n+\t{\n+\t  is_neg = fpnum < 0;\n+\t  if (isupper (info->spec))\n+\t    {\n+\t      special = \"INF\";\n+\t      wspecial = L_(\"INF\");\n+\t    }\n+\t  else\n+\t    {\n+\t      special = \"inf\";\n+\t      wspecial = L_(\"inf\");\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  fracsize = mpn_extract_flt128 (fp_input,\n+\t\t\t\t\t (sizeof (fp_input) /\n+\t\t\t\t\t  sizeof (fp_input[0])),\n+\t\t\t\t\t &exponent, &is_neg, fpnum);\n+\t  to_shift = 1 + fracsize * BITS_PER_MP_LIMB - FLT128_MANT_DIG;\n+\t}\n+    }\n+\n+  if (special)\n+    {\n+      int width = info->width;\n+\n+      if (is_neg || info->showsign || info->space)\n+\t--width;\n+      width -= 3;\n+\n+      if (!info->left && width > 0)\n+\tPADN (' ', width);\n+\n+      if (is_neg)\n+\toutchar ('-');\n+      else if (info->showsign)\n+\toutchar ('+');\n+      else if (info->space)\n+\toutchar (' ');\n+\n+      PRINT (special, wspecial, 3);\n+\n+      if (info->left && width > 0)\n+\tPADN (' ', width);\n+\n+      return done;\n+    }\n+\n+\n+  /* We need three multiprecision variables.  Now that we have the exponent\n+     of the number we can allocate the needed memory.  It would be more\n+     efficient to use variables of the fixed maximum size but because this\n+     would be really big it could lead to memory problems.  */\n+  {\n+    mp_size_t bignum_size = ((ABS (exponent) + BITS_PER_MP_LIMB - 1)\n+\t\t\t     / BITS_PER_MP_LIMB\n+\t\t\t     + (FLT128_MANT_DIG / BITS_PER_MP_LIMB > 2 ? 8 : 4))\n+\t\t\t    * sizeof (mp_limb_t);\n+    frac = (mp_limb_t *) alloca (bignum_size);\n+    tmp = (mp_limb_t *) alloca (bignum_size);\n+    scale = (mp_limb_t *) alloca (bignum_size);\n+  }\n+\n+  /* We now have to distinguish between numbers with positive and negative\n+     exponents because the method used for the one is not applicable/efficient\n+     for the other.  */\n+  scalesize = 0;\n+  if (exponent > 2)\n+    {\n+      /* |FP| >= 8.0.  */\n+      int scaleexpo = 0;\n+      int explog = FLT128_MAX_10_EXP_LOG;\n+      int exp10 = 0;\n+      const struct mp_power *powers = &_fpioconst_pow10[explog + 1];\n+      int cnt_h, cnt_l, i;\n+\n+      if ((exponent + to_shift) % BITS_PER_MP_LIMB == 0)\n+\t{\n+\t  MPN_COPY_DECR (frac + (exponent + to_shift) / BITS_PER_MP_LIMB,\n+\t\t\t fp_input, fracsize);\n+\t  fracsize += (exponent + to_shift) / BITS_PER_MP_LIMB;\n+\t}\n+      else\n+\t{\n+\t  cy = mpn_lshift (frac + (exponent + to_shift) / BITS_PER_MP_LIMB,\n+\t\t\t   fp_input, fracsize,\n+\t\t\t   (exponent + to_shift) % BITS_PER_MP_LIMB);\n+\t  fracsize += (exponent + to_shift) / BITS_PER_MP_LIMB;\n+\t  if (cy)\n+\t    frac[fracsize++] = cy;\n+\t}\n+      MPN_ZERO (frac, (exponent + to_shift) / BITS_PER_MP_LIMB);\n+\n+      assert (powers > &_fpioconst_pow10[0]);\n+      do\n+\t{\n+\t  --powers;\n+\n+\t  /* The number of the product of two binary numbers with n and m\n+\t     bits respectively has m+n or m+n-1 bits.\t*/\n+\t  if (exponent >= scaleexpo + powers->p_expo - 1)\n+\t    {\n+\t      if (scalesize == 0)\n+\t\t{\n+\t\t  if (FLT128_MANT_DIG > _FPIO_CONST_OFFSET * BITS_PER_MP_LIMB)\n+\t\t    {\n+#define _FPIO_CONST_SHIFT \\\n+  (((FLT128_MANT_DIG + BITS_PER_MP_LIMB - 1) / BITS_PER_MP_LIMB) \\\n+   - _FPIO_CONST_OFFSET)\n+\t\t      /* 64bit const offset is not enough for\n+\t\t\t IEEE quad long double.  */\n+\t\t      tmpsize = powers->arraysize + _FPIO_CONST_SHIFT;\n+\t\t      memcpy (tmp + _FPIO_CONST_SHIFT,\n+\t\t\t      &__tens[powers->arrayoff],\n+\t\t\t      tmpsize * sizeof (mp_limb_t));\n+\t\t      MPN_ZERO (tmp, _FPIO_CONST_SHIFT);\n+\t\t      /* Adjust exponent, as scaleexpo will be this much\n+\t\t\t bigger too.  */\n+\t\t      exponent += _FPIO_CONST_SHIFT * BITS_PER_MP_LIMB;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      tmpsize = powers->arraysize;\n+\t\t      memcpy (tmp, &__tens[powers->arrayoff],\n+\t\t\t      tmpsize * sizeof (mp_limb_t));\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  cy = mpn_mul (tmp, scale, scalesize,\n+\t\t\t\t&__tens[powers->arrayoff\n+\t\t\t\t\t+ _FPIO_CONST_OFFSET],\n+\t\t\t\tpowers->arraysize - _FPIO_CONST_OFFSET);\n+\t\t  tmpsize = scalesize + powers->arraysize - _FPIO_CONST_OFFSET;\n+\t\t  if (cy == 0)\n+\t\t    --tmpsize;\n+\t\t}\n+\n+\t      if (MPN_GE (frac, tmp))\n+\t\t{\n+\t\t  int cnt;\n+\t\t  MPN_ASSIGN (scale, tmp);\n+\t\t  count_leading_zeros (cnt, scale[scalesize - 1]);\n+\t\t  scaleexpo = (scalesize - 2) * BITS_PER_MP_LIMB - cnt - 1;\n+\t\t  exp10 |= 1 << explog;\n+\t\t}\n+\t    }\n+\t  --explog;\n+\t}\n+      while (powers > &_fpioconst_pow10[0]);\n+      exponent = exp10;\n+\n+      /* Optimize number representations.  We want to represent the numbers\n+\t with the lowest number of bytes possible without losing any\n+\t bytes. Also the highest bit in the scaling factor has to be set\n+\t (this is a requirement of the MPN division routines).  */\n+      if (scalesize > 0)\n+\t{\n+\t  /* Determine minimum number of zero bits at the end of\n+\t     both numbers.  */\n+\t  for (i = 0; scale[i] == 0 && frac[i] == 0; i++)\n+\t    ;\n+\n+\t  /* Determine number of bits the scaling factor is misplaced.\t*/\n+\t  count_leading_zeros (cnt_h, scale[scalesize - 1]);\n+\n+\t  if (cnt_h == 0)\n+\t    {\n+\t      /* The highest bit of the scaling factor is already set.\tSo\n+\t\t we only have to remove the trailing empty limbs.  */\n+\t      if (i > 0)\n+\t\t{\n+\t\t  MPN_COPY_INCR (scale, scale + i, scalesize - i);\n+\t\t  scalesize -= i;\n+\t\t  MPN_COPY_INCR (frac, frac + i, fracsize - i);\n+\t\t  fracsize -= i;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      if (scale[i] != 0)\n+\t\t{\n+\t\t  count_trailing_zeros (cnt_l, scale[i]);\n+\t\t  if (frac[i] != 0)\n+\t\t    {\n+\t\t      int cnt_l2;\n+\t\t      count_trailing_zeros (cnt_l2, frac[i]);\n+\t\t      if (cnt_l2 < cnt_l)\n+\t\t\tcnt_l = cnt_l2;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\tcount_trailing_zeros (cnt_l, frac[i]);\n+\n+\t      /* Now shift the numbers to their optimal position.  */\n+\t      if (i == 0 && BITS_PER_MP_LIMB - cnt_h > cnt_l)\n+\t\t{\n+\t\t  /* We cannot save any memory.\t So just roll both numbers\n+\t\t     so that the scaling factor has its highest bit set.  */\n+\n+\t\t  (void) mpn_lshift (scale, scale, scalesize, cnt_h);\n+\t\t  cy = mpn_lshift (frac, frac, fracsize, cnt_h);\n+\t\t  if (cy != 0)\n+\t\t    frac[fracsize++] = cy;\n+\t\t}\n+\t      else if (BITS_PER_MP_LIMB - cnt_h <= cnt_l)\n+\t\t{\n+\t\t  /* We can save memory by removing the trailing zero limbs\n+\t\t     and by packing the non-zero limbs which gain another\n+\t\t     free one. */\n+\n+\t\t  (void) mpn_rshift (scale, scale + i, scalesize - i,\n+\t\t\t\t     BITS_PER_MP_LIMB - cnt_h);\n+\t\t  scalesize -= i + 1;\n+\t\t  (void) mpn_rshift (frac, frac + i, fracsize - i,\n+\t\t\t\t     BITS_PER_MP_LIMB - cnt_h);\n+\t\t  fracsize -= frac[fracsize - i - 1] == 0 ? i + 1 : i;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* We can only save the memory of the limbs which are zero.\n+\t\t     The non-zero parts occupy the same number of limbs.  */\n+\n+\t\t  (void) mpn_rshift (scale, scale + (i - 1),\n+\t\t\t\t     scalesize - (i - 1),\n+\t\t\t\t     BITS_PER_MP_LIMB - cnt_h);\n+\t\t  scalesize -= i;\n+\t\t  (void) mpn_rshift (frac, frac + (i - 1),\n+\t\t\t\t     fracsize - (i - 1),\n+\t\t\t\t     BITS_PER_MP_LIMB - cnt_h);\n+\t\t  fracsize -= frac[fracsize - (i - 1) - 1] == 0 ? i : i - 1;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  else if (exponent < 0)\n+    {\n+      /* |FP| < 1.0.  */\n+      int exp10 = 0;\n+      int explog = FLT128_MAX_10_EXP_LOG;\n+      const struct mp_power *powers = &_fpioconst_pow10[explog + 1];\n+\n+      /* Now shift the input value to its right place.\t*/\n+      cy = mpn_lshift (frac, fp_input, fracsize, to_shift);\n+      frac[fracsize++] = cy;\n+      assert (cy == 1 || (frac[fracsize - 2] == 0 && frac[0] == 0));\n+\n+      expsign = 1;\n+      exponent = -exponent;\n+\n+      assert (powers != &_fpioconst_pow10[0]);\n+      do\n+\t{\n+\t  --powers;\n+\n+\t  if (exponent >= powers->m_expo)\n+\t    {\n+\t      int i, incr, cnt_h, cnt_l;\n+\t      mp_limb_t topval[2];\n+\n+\t      /* The mpn_mul function expects the first argument to be\n+\t\t bigger than the second.  */\n+\t      if (fracsize < powers->arraysize - _FPIO_CONST_OFFSET)\n+\t\tcy = mpn_mul (tmp, &__tens[powers->arrayoff\n+\t\t\t\t\t   + _FPIO_CONST_OFFSET],\n+\t\t\t      powers->arraysize - _FPIO_CONST_OFFSET,\n+\t\t\t      frac, fracsize);\n+\t      else\n+\t\tcy = mpn_mul (tmp, frac, fracsize,\n+\t\t\t      &__tens[powers->arrayoff + _FPIO_CONST_OFFSET],\n+\t\t\t      powers->arraysize - _FPIO_CONST_OFFSET);\n+\t      tmpsize = fracsize + powers->arraysize - _FPIO_CONST_OFFSET;\n+\t      if (cy == 0)\n+\t\t--tmpsize;\n+\n+\t      count_leading_zeros (cnt_h, tmp[tmpsize - 1]);\n+\t      incr = (tmpsize - fracsize) * BITS_PER_MP_LIMB\n+\t\t     + BITS_PER_MP_LIMB - 1 - cnt_h;\n+\n+\t      assert (incr <= powers->p_expo);\n+\n+\t      /* If we increased the exponent by exactly 3 we have to test\n+\t\t for overflow.\tThis is done by comparing with 10 shifted\n+\t\t to the right position.\t */\n+\t      if (incr == exponent + 3)\n+\t\t{\n+\t\t  if (cnt_h <= BITS_PER_MP_LIMB - 4)\n+\t\t    {\n+\t\t      topval[0] = 0;\n+\t\t      topval[1]\n+\t\t\t= ((mp_limb_t) 10) << (BITS_PER_MP_LIMB - 4 - cnt_h);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      topval[0] = ((mp_limb_t) 10) << (BITS_PER_MP_LIMB - 4);\n+\t\t      topval[1] = 0;\n+\t\t      (void) mpn_lshift (topval, topval, 2,\n+\t\t\t\t\t BITS_PER_MP_LIMB - cnt_h);\n+\t\t    }\n+\t\t}\n+\n+\t      /* We have to be careful when multiplying the last factor.\n+\t\t If the result is greater than 1.0 be have to test it\n+\t\t against 10.0.  If it is greater or equal to 10.0 the\n+\t\t multiplication was not valid.  This is because we cannot\n+\t\t determine the number of bits in the result in advance.  */\n+\t      if (incr < exponent + 3\n+\t\t  || (incr == exponent + 3 &&\n+\t\t      (tmp[tmpsize - 1] < topval[1]\n+\t\t       || (tmp[tmpsize - 1] == topval[1]\n+\t\t\t   && tmp[tmpsize - 2] < topval[0]))))\n+\t\t{\n+\t\t  /* The factor is right.  Adapt binary and decimal\n+\t\t     exponents.\t */\n+\t\t  exponent -= incr;\n+\t\t  exp10 |= 1 << explog;\n+\n+\t\t  /* If this factor yields a number greater or equal to\n+\t\t     1.0, we must not shift the non-fractional digits down. */\n+\t\t  if (exponent < 0)\n+\t\t    cnt_h += -exponent;\n+\n+\t\t  /* Now we optimize the number representation.\t */\n+\t\t  for (i = 0; tmp[i] == 0; ++i);\n+\t\t  if (cnt_h == BITS_PER_MP_LIMB - 1)\n+\t\t    {\n+\t\t      MPN_COPY (frac, tmp + i, tmpsize - i);\n+\t\t      fracsize = tmpsize - i;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      count_trailing_zeros (cnt_l, tmp[i]);\n+\n+\t\t      /* Now shift the numbers to their optimal position.  */\n+\t\t      if (i == 0 && BITS_PER_MP_LIMB - 1 - cnt_h > cnt_l)\n+\t\t\t{\n+\t\t\t  /* We cannot save any memory.\t Just roll the\n+\t\t\t     number so that the leading digit is in a\n+\t\t\t     separate limb.  */\n+\n+\t\t\t  cy = mpn_lshift (frac, tmp, tmpsize, cnt_h + 1);\n+\t\t\t  fracsize = tmpsize + 1;\n+\t\t\t  frac[fracsize - 1] = cy;\n+\t\t\t}\n+\t\t      else if (BITS_PER_MP_LIMB - 1 - cnt_h <= cnt_l)\n+\t\t\t{\n+\t\t\t  (void) mpn_rshift (frac, tmp + i, tmpsize - i,\n+\t\t\t\t\t     BITS_PER_MP_LIMB - 1 - cnt_h);\n+\t\t\t  fracsize = tmpsize - i;\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  /* We can only save the memory of the limbs which\n+\t\t\t     are zero.\tThe non-zero parts occupy the same\n+\t\t\t     number of limbs.  */\n+\n+\t\t\t  (void) mpn_rshift (frac, tmp + (i - 1),\n+\t\t\t\t\t     tmpsize - (i - 1),\n+\t\t\t\t\t     BITS_PER_MP_LIMB - 1 - cnt_h);\n+\t\t\t  fracsize = tmpsize - (i - 1);\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  --explog;\n+\t}\n+      while (powers != &_fpioconst_pow10[1] && exponent > 0);\n+      /* All factors but 10^-1 are tested now.\t*/\n+      if (exponent > 0)\n+\t{\n+\t  int cnt_l;\n+\n+\t  cy = mpn_mul_1 (tmp, frac, fracsize, 10);\n+\t  tmpsize = fracsize;\n+\t  assert (cy == 0 || tmp[tmpsize - 1] < 20);\n+\n+\t  count_trailing_zeros (cnt_l, tmp[0]);\n+\t  if (cnt_l < MIN (4, exponent))\n+\t    {\n+\t      cy = mpn_lshift (frac, tmp, tmpsize,\n+\t\t\t       BITS_PER_MP_LIMB - MIN (4, exponent));\n+\t      if (cy != 0)\n+\t\tfrac[tmpsize++] = cy;\n+\t    }\n+\t  else\n+\t    (void) mpn_rshift (frac, tmp, tmpsize, MIN (4, exponent));\n+\t  fracsize = tmpsize;\n+\t  exp10 |= 1;\n+\t  assert (frac[fracsize - 1] < 10);\n+\t}\n+      exponent = exp10;\n+    }\n+  else\n+    {\n+      /* This is a special case.  We don't need a factor because the\n+\t numbers are in the range of 1.0 <= |fp| < 8.0.  We simply\n+\t shift it to the right place and divide it by 1.0 to get the\n+\t leading digit.\t (Of course this division is not really made.)\t*/\n+      assert (0 <= exponent && exponent < 3 &&\n+\t      exponent + to_shift < BITS_PER_MP_LIMB);\n+\n+      /* Now shift the input value to its right place.\t*/\n+      cy = mpn_lshift (frac, fp_input, fracsize, (exponent + to_shift));\n+      frac[fracsize++] = cy;\n+      exponent = 0;\n+    }\n+\n+  {\n+    int width = info->width;\n+    wchar_t *wstartp, *wcp;\n+    size_t chars_needed;\n+    int expscale;\n+    int intdig_max, intdig_no = 0;\n+    int fracdig_min;\n+    int fracdig_max;\n+    int dig_max;\n+    int significant;\n+    int ngroups = 0;\n+    char spec = tolower (info->spec);\n+\n+    if (spec == 'e')\n+      {\n+\ttype = info->spec;\n+\tintdig_max = 1;\n+\tfracdig_min = fracdig_max = info->prec < 0 ? 6 : info->prec;\n+\tchars_needed = 1 + 1 + (size_t) fracdig_max + 1 + 1 + 4;\n+\t/*\t       d   .\t ddd\t     e\t +-  ddd  */\n+\tdig_max = __INT_MAX__;\t\t/* Unlimited.  */\n+\tsignificant = 1;\t\t/* Does not matter here.  */\n+      }\n+    else if (spec == 'f')\n+      {\n+\ttype = 'f';\n+\tfracdig_min = fracdig_max = info->prec < 0 ? 6 : info->prec;\n+\tdig_max = __INT_MAX__;\t\t/* Unlimited.  */\n+\tsignificant = 1;\t\t/* Does not matter here.  */\n+\tif (expsign == 0)\n+\t  {\n+\t    intdig_max = exponent + 1;\n+\t    /* This can be really big!\t*/  /* XXX Maybe malloc if too big? */\n+\t    chars_needed = (size_t) exponent + 1 + 1 + (size_t) fracdig_max;\n+\t  }\n+\telse\n+\t  {\n+\t    intdig_max = 1;\n+\t    chars_needed = 1 + 1 + (size_t) fracdig_max;\n+\t  }\n+      }\n+    else\n+      {\n+\tdig_max = info->prec < 0 ? 6 : (info->prec == 0 ? 1 : info->prec);\n+\tif ((expsign == 0 && exponent >= dig_max)\n+\t    || (expsign != 0 && exponent > 4))\n+\t  {\n+\t    if ('g' - 'G' == 'e' - 'E')\n+\t      type = 'E' + (info->spec - 'G');\n+\t    else\n+\t      type = isupper (info->spec) ? 'E' : 'e';\n+\t    fracdig_max = dig_max - 1;\n+\t    intdig_max = 1;\n+\t    chars_needed = 1 + 1 + (size_t) fracdig_max + 1 + 1 + 4;\n+\t  }\n+\telse\n+\t  {\n+\t    type = 'f';\n+\t    intdig_max = expsign == 0 ? exponent + 1 : 0;\n+\t    fracdig_max = dig_max - intdig_max;\n+\t    /* We need space for the significant digits and perhaps\n+\t       for leading zeros when < 1.0.  The number of leading\n+\t       zeros can be as many as would be required for\n+\t       exponential notation with a negative two-digit\n+\t       exponent, which is 4.  */\n+\t    chars_needed = (size_t) dig_max + 1 + 4;\n+\t  }\n+\tfracdig_min = info->alt ? fracdig_max : 0;\n+\tsignificant = 0;\t\t/* We count significant digits.\t */\n+      }\n+\n+    if (grouping)\n+      {\n+\t/* Guess the number of groups we will make, and thus how\n+\t   many spaces we need for separator characters.  */\n+\tngroups = guess_grouping (intdig_max, grouping);\n+\t/* Allocate one more character in case rounding increases the\n+\t   number of groups.  */\n+\tchars_needed += ngroups + 1;\n+      }\n+\n+    /* Allocate buffer for output.  We need two more because while rounding\n+       it is possible that we need two more characters in front of all the\n+       other output.  If the amount of memory we have to allocate is too\n+       large use `malloc' instead of `alloca'.  */\n+    if (__builtin_expect (chars_needed >= (size_t) -1 / sizeof (wchar_t) - 2\n+\t\t\t  || chars_needed < fracdig_max, 0))\n+      {\n+\t/* Some overflow occurred.  */\n+#if defined HAVE_ERRNO_H && defined ERANGE\n+\terrno = ERANGE;\n+#endif\n+\treturn -1;\n+      }\n+    size_t wbuffer_to_alloc = (2 + chars_needed) * sizeof (wchar_t);\n+    buffer_malloced = wbuffer_to_alloc >= 4096;\n+    if (__builtin_expect (buffer_malloced, 0))\n+      {\n+\twbuffer = (wchar_t *) malloc (wbuffer_to_alloc);\n+\tif (wbuffer == NULL)\n+\t  /* Signal an error to the caller.  */\n+\t  return -1;\n+      }\n+    else\n+      wbuffer = (wchar_t *) alloca (wbuffer_to_alloc);\n+    wcp = wstartp = wbuffer + 2;\t/* Let room for rounding.  */\n+\n+    /* Do the real work: put digits in allocated buffer.  */\n+    if (expsign == 0 || type != 'f')\n+      {\n+\tassert (expsign == 0 || intdig_max == 1);\n+\twhile (intdig_no < intdig_max)\n+\t  {\n+\t    ++intdig_no;\n+\t    *wcp++ = hack_digit ();\n+\t  }\n+\tsignificant = 1;\n+\tif (info->alt\n+\t    || fracdig_min > 0\n+\t    || (fracdig_max > 0 && (fracsize > 1 || frac[0] != 0)))\n+\t  *wcp++ = decimalwc;\n+      }\n+    else\n+      {\n+\t/* |fp| < 1.0 and the selected type is 'f', so put \"0.\"\n+\t   in the buffer.  */\n+\t*wcp++ = L_('0');\n+\t--exponent;\n+\t*wcp++ = decimalwc;\n+      }\n+\n+    /* Generate the needed number of fractional digits.\t */\n+    int fracdig_no = 0;\n+    int added_zeros = 0;\n+    while (fracdig_no < fracdig_min + added_zeros\n+\t   || (fracdig_no < fracdig_max && (fracsize > 1 || frac[0] != 0)))\n+      {\n+\t++fracdig_no;\n+\t*wcp = hack_digit ();\n+\tif (*wcp++ != L_('0'))\n+\t  significant = 1;\n+\telse if (significant == 0)\n+\t  {\n+\t    ++fracdig_max;\n+\t    if (fracdig_min > 0)\n+\t      ++added_zeros;\n+\t  }\n+      }\n+\n+    /* Do rounding.  */\n+    digit = hack_digit ();\n+    if (digit > L_('4'))\n+      {\n+\twchar_t *wtp = wcp;\n+\n+\tif (digit == L_('5')\n+\t    && ((*(wcp - 1) != decimalwc && (*(wcp - 1) & 1) == 0)\n+\t\t|| ((*(wcp - 1) == decimalwc && (*(wcp - 2) & 1) == 0))))\n+\t  {\n+\t    /* This is the critical case.\t */\n+\t    if (fracsize == 1 && frac[0] == 0)\n+\t      /* Rest of the number is zero -> round to even.\n+\t\t (IEEE 754-1985 4.1 says this is the default rounding.)  */\n+\t      goto do_expo;\n+\t    else if (scalesize == 0)\n+\t      {\n+\t\t/* Here we have to see whether all limbs are zero since no\n+\t\t   normalization happened.  */\n+\t\tsize_t lcnt = fracsize;\n+\t\twhile (lcnt >= 1 && frac[lcnt - 1] == 0)\n+\t\t  --lcnt;\n+\t\tif (lcnt == 0)\n+\t\t  /* Rest of the number is zero -> round to even.\n+\t\t     (IEEE 754-1985 4.1 says this is the default rounding.)  */\n+\t\t  goto do_expo;\n+\t      }\n+\t  }\n+\n+\tif (fracdig_no > 0)\n+\t  {\n+\t    /* Process fractional digits.  Terminate if not rounded or\n+\t       radix character is reached.  */\n+\t    int removed = 0;\n+\t    while (*--wtp != decimalwc && *wtp == L_('9'))\n+\t      {\n+\t\t*wtp = L_('0');\n+\t\t++removed;\n+\t      }\n+\t    if (removed == fracdig_min && added_zeros > 0)\n+\t      --added_zeros;\n+\t    if (*wtp != decimalwc)\n+\t      /* Round up.  */\n+\t      (*wtp)++;\n+\t    else if (__builtin_expect (spec == 'g' && type == 'f' && info->alt\n+\t\t\t\t       && wtp == wstartp + 1\n+\t\t\t\t       && wstartp[0] == L_('0'),\n+\t\t\t\t       0))\n+\t      /* This is a special case: the rounded number is 1.0,\n+\t\t the format is 'g' or 'G', and the alternative format\n+\t\t is selected.  This means the result must be \"1.\".  */\n+\t      --added_zeros;\n+\t  }\n+\n+\tif (fracdig_no == 0 || *wtp == decimalwc)\n+\t  {\n+\t    /* Round the integer digits.  */\n+\t    if (*(wtp - 1) == decimalwc)\n+\t      --wtp;\n+\n+\t    while (--wtp >= wstartp && *wtp == L_('9'))\n+\t      *wtp = L_('0');\n+\n+\t    if (wtp >= wstartp)\n+\t      /* Round up.  */\n+\t      (*wtp)++;\n+\t    else\n+\t      /* It is more critical.  All digits were 9's.  */\n+\t      {\n+\t\tif (type != 'f')\n+\t\t  {\n+\t\t    *wstartp = '1';\n+\t\t    exponent += expsign == 0 ? 1 : -1;\n+\n+\t\t    /* The above exponent adjustment could lead to 1.0e-00,\n+\t\t       e.g. for 0.999999999.  Make sure exponent 0 always\n+\t\t       uses + sign.  */\n+\t\t    if (exponent == 0)\n+\t\t      expsign = 0;\n+\t\t  }\n+\t\telse if (intdig_no == dig_max)\n+\t\t  {\n+\t\t    /* This is the case where for type %g the number fits\n+\t\t       really in the range for %f output but after rounding\n+\t\t       the number of digits is too big.\t */\n+\t\t    *--wstartp = decimalwc;\n+\t\t    *--wstartp = L_('1');\n+\n+\t\t    if (info->alt || fracdig_no > 0)\n+\t\t      {\n+\t\t\t/* Overwrite the old radix character.  */\n+\t\t\twstartp[intdig_no + 2] = L_('0');\n+\t\t\t++fracdig_no;\n+\t\t      }\n+\n+\t\t    fracdig_no += intdig_no;\n+\t\t    intdig_no = 1;\n+\t\t    fracdig_max = intdig_max - intdig_no;\n+\t\t    ++exponent;\n+\t\t    /* Now we must print the exponent.\t*/\n+\t\t    type = isupper (info->spec) ? 'E' : 'e';\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    /* We can simply add another another digit before the\n+\t\t       radix.  */\n+\t\t    *--wstartp = L_('1');\n+\t\t    ++intdig_no;\n+\t\t  }\n+\n+\t\t/* While rounding the number of digits can change.\n+\t\t   If the number now exceeds the limits remove some\n+\t\t   fractional digits.  */\n+\t\tif (intdig_no + fracdig_no > dig_max)\n+\t\t  {\n+\t\t    wcp -= intdig_no + fracdig_no - dig_max;\n+\t\t    fracdig_no -= intdig_no + fracdig_no - dig_max;\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n+\n+  do_expo:\n+    /* Now remove unnecessary '0' at the end of the string.  */\n+    while (fracdig_no > fracdig_min + added_zeros && *(wcp - 1) == L_('0'))\n+      {\n+\t--wcp;\n+\t--fracdig_no;\n+      }\n+    /* If we eliminate all fractional digits we perhaps also can remove\n+       the radix character.  */\n+    if (fracdig_no == 0 && !info->alt && *(wcp - 1) == decimalwc)\n+      --wcp;\n+\n+    if (grouping)\n+      {\n+\t/* Rounding might have changed the number of groups.  We allocated\n+\t   enough memory but we need here the correct number of groups.  */\n+\tif (intdig_no != intdig_max)\n+\t  ngroups = guess_grouping (intdig_no, grouping);\n+\n+\t/* Add in separator characters, overwriting the same buffer.  */\n+\twcp = group_number (wstartp, wcp, intdig_no, grouping, thousands_sepwc,\n+\t\t\t    ngroups);\n+      }\n+\n+    /* Write the exponent if it is needed.  */\n+    if (type != 'f')\n+      {\n+\tif (__builtin_expect (expsign != 0 && exponent == 4 && spec == 'g', 0))\n+\t  {\n+\t    /* This is another special case.  The exponent of the number is\n+\t       really smaller than -4, which requires the 'e'/'E' format.\n+\t       But after rounding the number has an exponent of -4.  */\n+\t    assert (wcp >= wstartp + 1);\n+\t    assert (wstartp[0] == L_('1'));\n+\t    memcpy (wstartp, L_(\"0.0001\"), 6 * sizeof (wchar_t));\n+\t    wstartp[1] = decimalwc;\n+\t    if (wcp >= wstartp + 2)\n+\t      {\n+\t\tsize_t cnt;\n+\t\tfor (cnt = 0; cnt < wcp - (wstartp + 2); cnt++)\n+\t\t  wstartp[6 + cnt] = L_('0');\n+\t\twcp += 4;\n+\t      }\n+\t    else\n+\t      wcp += 5;\n+\t  }\n+\telse\n+\t  {\n+\t    *wcp++ = (wchar_t) type;\n+\t    *wcp++ = expsign ? L_('-') : L_('+');\n+\n+\t    /* Find the magnitude of the exponent.\t*/\n+\t    expscale = 10;\n+\t    while (expscale <= exponent)\n+\t      expscale *= 10;\n+\n+\t    if (exponent < 10)\n+\t      /* Exponent always has at least two digits.  */\n+\t      *wcp++ = L_('0');\n+\t    else\n+\t      do\n+\t\t{\n+\t\t  expscale /= 10;\n+\t\t  *wcp++ = L_('0') + (exponent / expscale);\n+\t\t  exponent %= expscale;\n+\t\t}\n+\t      while (expscale > 10);\n+\t    *wcp++ = L_('0') + exponent;\n+\t  }\n+      }\n+\n+    /* Compute number of characters which must be filled with the padding\n+       character.  */\n+    if (is_neg || info->showsign || info->space)\n+      --width;\n+    width -= wcp - wstartp;\n+\n+    if (!info->left && info->pad != '0' && width > 0)\n+      PADN (info->pad, width);\n+\n+    if (is_neg)\n+      outchar ('-');\n+    else if (info->showsign)\n+      outchar ('+');\n+    else if (info->space)\n+      outchar (' ');\n+\n+    if (!info->left && info->pad == '0' && width > 0)\n+      PADN ('0', width);\n+\n+    {\n+      char *buffer = NULL;\n+      char *buffer_end __attribute__((__unused__)) = NULL;\n+      char *cp = NULL;\n+      char *tmpptr;\n+\n+      if (! wide)\n+\t{\n+\t  /* Create the single byte string.  */\n+\t  size_t decimal_len;\n+\t  size_t thousands_sep_len;\n+\t  wchar_t *copywc;\n+#ifdef USE_LOCALE_SUPPORT\n+\t  size_t factor = ((info->i18n && USE_I18N_NUMBER_H)\n+\t\t\t   ? nl_langinfo_wc (_NL_CTYPE_MB_CUR_MAX)\n+\t\t\t   : 1);\n+#else\n+\t  size_t factor = 1;\n+#endif\n+\n+\t  decimal_len = strlen (decimal);\n+\n+\t  if (thousands_sep == NULL)\n+\t    thousands_sep_len = 0;\n+\t  else\n+\t    thousands_sep_len = strlen (thousands_sep);\n+\n+\t  size_t nbuffer = (2 + chars_needed * factor + decimal_len\n+\t\t\t    + ngroups * thousands_sep_len);\n+\t  if (__builtin_expect (buffer_malloced, 0))\n+\t    {\n+\t      buffer = (char *) malloc (nbuffer);\n+\t      if (buffer == NULL)\n+\t\t{\n+\t\t  /* Signal an error to the caller.  */\n+\t\t  free (wbuffer);\n+\t\t  return -1;\n+\t\t}\n+\t    }\n+\t  else\n+\t    buffer = (char *) alloca (nbuffer);\n+\t  buffer_end = buffer + nbuffer;\n+\n+\t  /* Now copy the wide character string.  Since the character\n+\t     (except for the decimal point and thousands separator) must\n+\t     be coming from the ASCII range we can esily convert the\n+\t     string without mapping tables.  */\n+\t  for (cp = buffer, copywc = wstartp; copywc < wcp; ++copywc)\n+\t    if (*copywc == decimalwc)\n+\t      memcpy (cp, decimal, decimal_len), cp += decimal_len;\n+\t    else if (*copywc == thousands_sepwc)\n+\t      mempcpy (cp, thousands_sep, thousands_sep_len), cp += thousands_sep_len;\n+\t    else\n+\t      *cp++ = (char) *copywc;\n+\t}\n+\n+      tmpptr = buffer;\n+#if USE_I18N_NUMBER_H\n+      if (__builtin_expect (info->i18n, 0))\n+\t{\n+\t  tmpptr = _i18n_number_rewrite (tmpptr, cp, buffer_end);\n+\t  cp = buffer_end;\n+\t  assert ((uintptr_t) buffer <= (uintptr_t) tmpptr);\n+\t  assert ((uintptr_t) tmpptr < (uintptr_t) buffer_end);\n+\t}\n+#endif\n+\n+      PRINT (tmpptr, wstartp, wide ? wcp - wstartp : cp - tmpptr);\n+\n+      /* Free the memory if necessary.  */\n+      if (__builtin_expect (buffer_malloced, 0))\n+\t{\n+\t  free (buffer);\n+\t  free (wbuffer);\n+\t}\n+    }\n+\n+    if (info->left && width > 0)\n+      PADN (info->pad, width);\n+  }\n+  return done;\n+}\n+\f\n+/* Return the number of extra grouping characters that will be inserted\n+   into a number with INTDIG_MAX integer digits.  */\n+\n+static unsigned int\n+guess_grouping (unsigned int intdig_max, const char *grouping)\n+{\n+  unsigned int groups;\n+\n+  /* We treat all negative values like CHAR_MAX.  */\n+\n+  if (*grouping == CHAR_MAX || *grouping <= 0)\n+    /* No grouping should be done.  */\n+    return 0;\n+\n+  groups = 0;\n+  while (intdig_max > (unsigned int) *grouping)\n+    {\n+      ++groups;\n+      intdig_max -= *grouping++;\n+\n+      if (*grouping == 0)\n+\t{\n+\t  /* Same grouping repeats.  */\n+\t  groups += (intdig_max - 1) / grouping[-1];\n+\t  break;\n+\t}\n+      else if (*grouping == CHAR_MAX || *grouping <= 0)\n+\t/* No more grouping should be done.  */\n+\tbreak;\n+    }\n+\n+  return groups;\n+}\n+\n+/* Group the INTDIG_NO integer digits of the number in [BUF,BUFEND).\n+   There is guaranteed enough space past BUFEND to extend it.\n+   Return the new end of buffer.  */\n+\n+static wchar_t *\n+group_number (wchar_t *buf, wchar_t *bufend, unsigned int intdig_no,\n+\t      const char *grouping, wchar_t thousands_sep, int ngroups)\n+{\n+  wchar_t *p;\n+\n+  if (ngroups == 0)\n+    return bufend;\n+\n+  /* Move the fractional part down.  */\n+  memmove (buf + intdig_no + ngroups, buf + intdig_no,\n+\t   (bufend - (buf + intdig_no)) * sizeof (wchar_t));\n+\n+  p = buf + intdig_no + ngroups - 1;\n+  do\n+    {\n+      unsigned int len = *grouping++;\n+      do\n+\t*p-- = buf[--intdig_no];\n+      while (--len > 0);\n+      *p-- = thousands_sep;\n+\n+      if (*grouping == 0)\n+\t/* Same grouping repeats.  */\n+\t--grouping;\n+      else if (*grouping == CHAR_MAX || *grouping <= 0)\n+\t/* No more grouping should be done.  */\n+\tbreak;\n+    } while (intdig_no > (unsigned int) *grouping);\n+\n+  /* Copy the remaining ungrouped digits.  */\n+  do\n+    *p-- = buf[--intdig_no];\n+  while (p > buf);\n+\n+  return bufend + ngroups;\n+}"}, {"sha": "44900f49cc5dfa91400ec4d7cd2ff3cb35d1e7ee", "filename": "libquadmath/printf/printf_fphex.c", "status": "added", "additions": 444, "deletions": 0, "changes": 444, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Fprintf_fphex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Fprintf_fphex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Fprintf_fphex.c?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -0,0 +1,444 @@\n+/* Print floating point number in hexadecimal notation according to ISO C99.\n+   Copyright (C) 1997-2002,2004,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+   02111-1307 USA.  */\n+\n+#include <config.h>\n+#include <math.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+#define NDEBUG\n+#include <assert.h>\n+#include \"quadmath-printf.h\"\n+#include \"_itoa.h\"\n+#include \"_itowa.h\"\n+\n+\f\n+/* Macros for doing the actual output.  */\n+\n+#define outchar(ch)\t\t\t\t\t\t\t      \\\n+  do\t\t\t\t\t\t\t\t\t      \\\n+    {\t\t\t\t\t\t\t\t\t      \\\n+      register const int outc = (ch);\t\t\t\t\t      \\\n+      if (PUTC (outc, fp) == EOF)\t\t\t\t\t      \\\n+\treturn -1;\t\t\t\t\t\t\t      \\\n+      ++done;\t\t\t\t\t\t\t\t      \\\n+    } while (0)\n+\n+#define PRINT(ptr, wptr, len)\t\t\t\t\t\t      \\\n+  do\t\t\t\t\t\t\t\t\t      \\\n+    {\t\t\t\t\t\t\t\t\t      \\\n+      register size_t outlen = (len);\t\t\t\t\t      \\\n+      if (wide)\t\t\t\t\t\t\t\t      \\\n+\twhile (outlen-- > 0)\t\t\t\t\t\t      \\\n+\t  outchar (*wptr++);\t\t\t\t\t\t      \\\n+      else\t\t\t\t\t\t\t\t      \\\n+\twhile (outlen-- > 0)\t\t\t\t\t\t      \\\n+\t  outchar (*ptr++);\t\t\t\t\t\t      \\\n+    } while (0)\n+\n+#define PADN(ch, len)\t\t\t\t\t\t\t      \\\n+  do\t\t\t\t\t\t\t\t\t      \\\n+    {\t\t\t\t\t\t\t\t\t      \\\n+      if (PAD (fp, ch, len) != len)\t\t\t\t\t      \\\n+\treturn -1;\t\t\t\t\t\t\t      \\\n+      done += len;\t\t\t\t\t\t\t      \\\n+    }\t\t\t\t\t\t\t\t\t      \\\n+  while (0)\n+\n+\f\n+\n+int\n+__quadmath_printf_fphex (struct __quadmath_printf_file *fp,\n+\t\t\t const struct printf_info *info,\n+\t\t\t const void *const *args)\n+{\n+  /* The floating-point value to output.  */\n+  ieee854_float128 fpnum;\n+\n+  /* Locale-dependent representation of decimal point.\t*/\n+  const char *decimal;\n+  wchar_t decimalwc;\n+\n+  /* \"NaN\" or \"Inf\" for the special cases.  */\n+  const char *special = NULL;\n+  const wchar_t *wspecial = NULL;\n+\n+  /* Buffer for the generated number string for the mantissa.  The\n+     maximal size for the mantissa is 128 bits.  */\n+  char numbuf[32];\n+  char *numstr;\n+  char *numend;\n+  wchar_t wnumbuf[32];\n+  wchar_t *wnumstr;\n+  wchar_t *wnumend;\n+  int negative;\n+\n+  /* The maximal exponent of two in decimal notation has 5 digits.  */\n+  char expbuf[5];\n+  char *expstr;\n+  wchar_t wexpbuf[5];\n+  wchar_t *wexpstr;\n+  int expnegative;\n+  int exponent;\n+\n+  /* Non-zero is mantissa is zero.  */\n+  int zero_mantissa;\n+\n+  /* The leading digit before the decimal point.  */\n+  char leading;\n+\n+  /* Precision.  */\n+  int precision = info->prec;\n+\n+  /* Width.  */\n+  int width = info->width;\n+\n+  /* Number of characters written.  */\n+  int done = 0;\n+\n+  /* Nonzero if this is output on a wide character stream.  */\n+  int wide = info->wide;\n+\n+  /* Figure out the decimal point character.  */\n+#ifdef USE_LOCALE_SUPPORT\n+  if (info->extra == 0)\n+    {\n+      decimal = nl_langinfo (DECIMAL_POINT);\n+      decimalwc = nl_langinfo_wc (_NL_NUMERIC_DECIMAL_POINT_WC);\n+    }\n+  else\n+    {\n+      decimal = nl_langinfo (MON_DECIMAL_POINT);\n+      if (*decimal == '\\0')\n+\tdecimal = nl_langinfo (DECIMAL_POINT);\n+      decimalwc = nl_langinfo_wc (_NL_MONETARY_DECIMAL_POINT_WC);\n+      if (decimalwc == L'\\0')\n+\tdecimalwc = nl_langinfo_wc (_NL_NUMERIC_DECIMAL_POINT_WC);\n+    }\n+  /* The decimal point character must never be zero.  */\n+  assert (*decimal != '\\0' && decimalwc != L'\\0');\n+#else\n+  decimal = \".\";\n+  decimalwc = L_('.');\n+#endif\n+\n+  /* Fetch the argument value.\t*/\n+    {\n+      fpnum.value = **(const __float128 **) args[0];\n+\n+      /* Check for special values: not a number or infinity.  */\n+      if (isnanq (fpnum.value))\n+\t{\n+\t  negative = fpnum.ieee.negative != 0;\n+\t  if (isupper (info->spec))\n+\t    {\n+\t      special = \"NAN\";\n+\t      wspecial = L_(\"NAN\");\n+\t    }\n+\t  else\n+\t    {\n+\t      special = \"nan\";\n+\t      wspecial = L_(\"nan\");\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (isinfq (fpnum.value))\n+\t    {\n+\t      if (isupper (info->spec))\n+\t\t{\n+\t\t  special = \"INF\";\n+\t\t  wspecial = L_(\"INF\");\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  special = \"inf\";\n+\t\t  wspecial = L_(\"inf\");\n+\t\t}\n+\t    }\n+\n+\t  negative = signbitq (fpnum.value);\n+\t}\n+    }\n+\n+  if (special)\n+    {\n+      int width = info->width;\n+\n+      if (negative || info->showsign || info->space)\n+\t--width;\n+      width -= 3;\n+\n+      if (!info->left && width > 0)\n+\tPADN (' ', width);\n+\n+      if (negative)\n+\toutchar ('-');\n+      else if (info->showsign)\n+\toutchar ('+');\n+      else if (info->space)\n+\toutchar (' ');\n+\n+      PRINT (special, wspecial, 3);\n+\n+      if (info->left && width > 0)\n+\tPADN (' ', width);\n+\n+      return done;\n+    }\n+\n+    {\n+      /* We have 112 bits of mantissa plus one implicit digit.  Since\n+\t 112 bits are representable without rest using hexadecimal\n+\t digits we use only the implicit digits for the number before\n+\t the decimal point.  */\n+      uint64_t num0, num1;\n+\n+      assert (sizeof (long double) == 16);\n+\n+      num0 = fpnum.ieee.mant_high;\n+      num1 = fpnum.ieee.mant_low;\n+\n+      zero_mantissa = (num0|num1) == 0;\n+\n+      if (sizeof (unsigned long int) > 6)\n+\t{\n+\t  numstr = _itoa_word (num1, numbuf + sizeof numbuf, 16,\n+\t\t\t       info->spec == 'A');\n+\t  wnumstr = _itowa_word (num1,\n+\t\t\t\t wnumbuf + sizeof (wnumbuf) / sizeof (wchar_t),\n+\t\t\t\t 16, info->spec == 'A');\n+\t}\n+      else\n+\t{\n+\t  numstr = _itoa (num1, numbuf + sizeof numbuf, 16,\n+\t\t\t  info->spec == 'A');\n+\t  wnumstr = _itowa (num1,\n+\t\t\t    wnumbuf + sizeof (wnumbuf) / sizeof (wchar_t),\n+\t\t\t    16, info->spec == 'A');\n+\t}\n+\n+      while (numstr > numbuf + (sizeof numbuf - 64 / 4))\n+\t{\n+\t  *--numstr = '0';\n+\t  *--wnumstr = L_('0');\n+\t}\n+\n+      if (sizeof (unsigned long int) > 6)\n+\t{\n+\t  numstr = _itoa_word (num0, numstr, 16, info->spec == 'A');\n+\t  wnumstr = _itowa_word (num0, wnumstr, 16, info->spec == 'A');\n+\t}\n+      else\n+\t{\n+\t  numstr = _itoa (num0, numstr, 16, info->spec == 'A');\n+\t  wnumstr = _itowa (num0, wnumstr, 16, info->spec == 'A');\n+\t}\n+\n+      /* Fill with zeroes.  */\n+      while (numstr > numbuf + (sizeof numbuf - 112 / 4))\n+\t{\n+\t  *--numstr = '0';\n+\t  *--wnumstr = L_('0');\n+\t}\n+\n+      leading = fpnum.ieee.exponent == 0 ? '0' : '1';\n+\n+      exponent = fpnum.ieee.exponent;\n+\n+      if (exponent == 0)\n+\t{\n+\t  if (zero_mantissa)\n+\t    expnegative = 0;\n+\t  else\n+\t    {\n+\t      /* This is a denormalized number.  */\n+\t      expnegative = 1;\n+\t      exponent = IEEE854_FLOAT128_BIAS - 1;\n+\t    }\n+\t}\n+      else if (exponent >= IEEE854_FLOAT128_BIAS)\n+\t{\n+\t  expnegative = 0;\n+\t  exponent -= IEEE854_FLOAT128_BIAS;\n+\t}\n+      else\n+\t{\n+\t  expnegative = 1;\n+\t  exponent = -(exponent - IEEE854_FLOAT128_BIAS);\n+\t}\n+    }\n+\n+  /* Look for trailing zeroes.  */\n+  if (! zero_mantissa)\n+    {\n+      wnumend = &wnumbuf[sizeof wnumbuf / sizeof wnumbuf[0]];\n+      numend = &numbuf[sizeof numbuf / sizeof numbuf[0]];\n+      while (wnumend[-1] == L_('0'))\n+\t{\n+\t  --wnumend;\n+\t  --numend;\n+\t}\n+\n+      if (precision == -1)\n+\tprecision = numend - numstr;\n+      else if (precision < numend - numstr\n+\t       && (numstr[precision] > '8'\n+\t\t   || (('A' < '0' || 'a' < '0')\n+\t\t       && numstr[precision] < '0')\n+\t\t   || (numstr[precision] == '8'\n+\t\t       && (precision + 1 < numend - numstr\n+\t\t\t   /* Round to even.  */\n+\t\t\t   || (precision > 0\n+\t\t\t       && ((numstr[precision - 1] & 1)\n+\t\t\t\t   ^ (isdigit (numstr[precision - 1]) == 0)))\n+\t\t\t   || (precision == 0\n+\t\t\t       && ((leading & 1)\n+\t\t\t\t   ^ (isdigit (leading) == 0)))))))\n+\t{\n+\t  /* Round up.  */\n+\t  int cnt = precision;\n+\t  while (--cnt >= 0)\n+\t    {\n+\t      char ch = numstr[cnt];\n+\t      /* We assume that the digits and the letters are ordered\n+\t\t like in ASCII.  This is true for the rest of GNU, too.  */\n+\t      if (ch == '9')\n+\t\t{\n+\t\t  wnumstr[cnt] = (wchar_t) info->spec;\n+\t\t  numstr[cnt] = info->spec;\t/* This is tricky,\n+\t\t  \t\t\t\t   think about it!  */\n+\t\t  break;\n+\t\t}\n+\t      else if (tolower (ch) < 'f')\n+\t\t{\n+\t\t  ++numstr[cnt];\n+\t\t  ++wnumstr[cnt];\n+\t\t  break;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  numstr[cnt] = '0';\n+\t\t  wnumstr[cnt] = L_('0');\n+\t\t}\n+\t    }\n+\t  if (cnt < 0)\n+\t    {\n+\t      /* The mantissa so far was fff...f  Now increment the\n+\t\t leading digit.  Here it is again possible that we\n+\t\t get an overflow.  */\n+\t      if (leading == '9')\n+\t\tleading = info->spec;\n+\t      else if (tolower (leading) < 'f')\n+\t\t++leading;\n+\t      else\n+\t\t{\n+\t\t  leading = '1';\n+\t\t  if (expnegative)\n+\t\t    {\n+\t\t      exponent -= 4;\n+\t\t      if (exponent <= 0)\n+\t\t\t{\n+\t\t\t  exponent = -exponent;\n+\t\t\t  expnegative = 0;\n+\t\t\t}\n+\t\t    }\n+\t\t  else\n+\t\t    exponent += 4;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      if (precision == -1)\n+\tprecision = 0;\n+      numend = numstr;\n+      wnumend = wnumstr;\n+    }\n+\n+  /* Now we can compute the exponent string.  */\n+  expstr = _itoa_word (exponent, expbuf + sizeof expbuf, 10, 0);\n+  wexpstr = _itowa_word (exponent,\n+\t\t\t wexpbuf + sizeof wexpbuf / sizeof (wchar_t), 10, 0);\n+\n+  /* Now we have all information to compute the size.  */\n+  width -= ((negative || info->showsign || info->space)\n+\t    /* Sign.  */\n+\t    + 2    + 1 + 0 + precision + 1 + 1\n+\t    /* 0x    h   .   hhh         P   ExpoSign.  */\n+\t    + ((expbuf + sizeof expbuf) - expstr));\n+\t    /* Exponent.  */\n+\n+  /* Count the decimal point.\n+     A special case when the mantissa or the precision is zero and the `#'\n+     is not given.  In this case we must not print the decimal point.  */\n+  if (precision > 0 || info->alt)\n+    width -= wide ? 1 : strlen (decimal);\n+\n+  if (!info->left && info->pad != '0' && width > 0)\n+    PADN (' ', width);\n+\n+  if (negative)\n+    outchar ('-');\n+  else if (info->showsign)\n+    outchar ('+');\n+  else if (info->space)\n+    outchar (' ');\n+\n+  outchar ('0');\n+  if ('X' - 'A' == 'x' - 'a')\n+    outchar (info->spec + ('x' - 'a'));\n+  else\n+    outchar (info->spec == 'A' ? 'X' : 'x');\n+\n+  if (!info->left && info->pad == '0' && width > 0)\n+    PADN ('0', width);\n+\n+  outchar (leading);\n+\n+  if (precision > 0 || info->alt)\n+    {\n+      const wchar_t *wtmp = &decimalwc;\n+      PRINT (decimal, wtmp, wide ? 1 : strlen (decimal));\n+    }\n+\n+  if (precision > 0)\n+    {\n+      ssize_t tofill = precision - (numend - numstr);\n+      PRINT (numstr, wnumstr, MIN (numend - numstr, precision));\n+      if (tofill > 0)\n+\tPADN ('0', tofill);\n+    }\n+\n+  if ('P' - 'A' == 'p' - 'a')\n+    outchar (info->spec + ('p' - 'a'));\n+  else\n+    outchar (info->spec == 'A' ? 'P' : 'p');\n+\n+  outchar (expnegative ? '-' : '+');\n+\n+  PRINT (expstr, wexpstr, (expbuf + sizeof expbuf) - expstr);\n+\n+  if (info->left && info->pad != '0' && width > 0)\n+    PADN (info->pad, width);\n+\n+  return done;\n+}"}, {"sha": "6d17200e3ad9216f61d9440e23b1ca7bbd426204", "filename": "libquadmath/printf/quadmath-printf.c", "status": "added", "additions": 421, "deletions": 0, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Fquadmath-printf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Fquadmath-printf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Fquadmath-printf.c?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -0,0 +1,421 @@\n+/* GCC Quad-Precision Math Library\n+   Copyright (C) 2011 Free Software Foundation, Inc.\n+   Written by Jakub Jelinek  <jakub@redhat.com>\n+\n+This file is part of the libquadmath library.\n+Libquadmath is free software; you can redistribute it and/or\n+modify it under the terms of the GNU Library General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+Libquadmath is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+Library General Public License for more details.\n+\n+You should have received a copy of the GNU Library General Public\n+License along with libquadmath; see the file COPYING.LIB.  If\n+not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include <config.h>\n+#include <stdarg.h>\n+#include <string.h>\n+#include <stdio.h>\n+#include \"quadmath-printf.h\"\n+\n+/* Read a simple integer from a string and update the string pointer.\n+   It is assumed that the first character is a digit.  */\n+static unsigned int\n+read_int (const char **pstr)\n+{\n+  unsigned int retval = (unsigned char) **pstr - '0';\n+\n+  while (isdigit ((unsigned char) *++(*pstr)))\n+    {\n+      retval *= 10;\n+      retval += (unsigned char) **pstr - '0';\n+    }\n+\n+  return retval;\n+}\n+\n+#define PADSIZE 16\n+static char const blanks[PADSIZE] =\n+{' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '};\n+static char const zeroes[PADSIZE] =\n+{'0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0'};\n+static wchar_t const wblanks[PADSIZE] =\n+{\n+  L_(' '), L_(' '), L_(' '), L_(' '), L_(' '), L_(' '), L_(' '), L_(' '),\n+  L_(' '), L_(' '), L_(' '), L_(' '), L_(' '), L_(' '), L_(' '), L_(' ')\n+};\n+static wchar_t const wzeroes[PADSIZE] =\n+{\n+  L_('0'), L_('0'), L_('0'), L_('0'), L_('0'), L_('0'), L_('0'), L_('0'),\n+  L_('0'), L_('0'), L_('0'), L_('0'), L_('0'), L_('0'), L_('0'), L_('0')\n+};\n+\n+attribute_hidden size_t\n+__quadmath_do_pad (struct __quadmath_printf_file *fp, int wide, int c,\n+\t\t   size_t n)\n+{\n+  ssize_t i;\n+  char padbuf[PADSIZE];\n+  wchar_t wpadbuf[PADSIZE];\n+  const char *padstr;\n+  size_t w, written = 0;\n+  if (wide)\n+    {\n+      if (c == ' ')\n+\tpadstr = (const char *) wblanks;\n+      else if (c == '0')\n+\tpadstr = (const char *) wzeroes;\n+      else\n+\t{\n+\t  padstr = (const char *) wpadbuf;\n+\t  for (i = 0; i < PADSIZE; i++)\n+\t    wpadbuf[i] = c;\n+\t}\n+    }\n+  else\n+    {\n+      if (c == ' ')\n+\tpadstr = blanks;\n+      else if (c == '0')\n+\tpadstr = zeroes;\n+      else\n+\t{\n+\t  padstr = (const char *) padbuf;\n+\t  for (i = 0; i < PADSIZE; i++)\n+\t    padbuf[i] = c;\n+\t}\n+    }\n+  for (i = n; i >= PADSIZE; i -= PADSIZE)\n+    {\n+      w = PUT (fp, (char *) padstr, PADSIZE);\n+      written += w;\n+      if (w != PADSIZE)\n+\treturn written;\n+    }\n+  if (i > 0)\n+    {\n+      w = PUT (fp, (char *) padstr, i);\n+      written += w;\n+    }\n+  return written;\n+}\n+\n+/* This is a stripped down version of snprintf, which just handles\n+   a single %eEfFgGaA format entry with Q modifier.  % has to be\n+   the first character of the format string, no $ can be used.  */\n+int\n+quadmath_snprintf (char *str, size_t size, const char *format, ...)\n+{\n+  struct printf_info info;\n+  va_list ap;\n+  __float128 fpnum, *fpnum_addr = &fpnum, **fpnum_addr2 = &fpnum_addr;\n+  struct __quadmath_printf_file qfp;\n+\n+  if (*format++ != '%')\n+    return -1;\n+\n+  /* Clear information structure.  */\n+  info.alt = 0;\n+  info.space = 0;\n+  info.left = 0;\n+  info.showsign = 0;\n+  info.group = 0;\n+  info.i18n = 0;\n+  info.extra = 0;\n+  info.pad = ' ';\n+  info.wide = 0;\n+\n+  /* Check for spec modifiers.  */\n+  do\n+    {\n+      switch (*format)\n+\t{\n+\tcase ' ':\n+\t  /* Output a space in place of a sign, when there is no sign.  */\n+\t  info.space = 1;\n+\t  continue;\n+\tcase '+':\n+\t  /* Always output + or - for numbers.  */\n+\t  info.showsign = 1;\n+\t  continue;\n+\tcase '-':\n+\t  /* Left-justify things.  */\n+\t  info.left = 1;\n+\t  continue;\n+\tcase '#':\n+\t  /* Use the \"alternate form\":\n+\t     Hex has 0x or 0X, FP always has a decimal point.  */\n+\t  info.alt = 1;\n+\t  continue;\n+\tcase '0':\n+\t  /* Pad with 0s.  */\n+\t  info.pad = '0';\n+\t  continue;\n+\tcase '\\'':\n+\t  /* Show grouping in numbers if the locale information\n+\t     indicates any.  */\n+\t  info.group = 1;\n+\t  continue;\n+\tcase 'I':\n+\t  /* Use the internationalized form of the output.  Currently\n+\t     means to use the `outdigits' of the current locale.  */\n+\t  info.i18n = 1;\n+\t  continue;\n+\tdefault:\n+\t  break;\n+\t}\n+      break;\n+    }\n+  while (*++format);\n+\n+  if (info.left)\n+    info.pad = ' ';\n+\n+  va_start (ap, format);\n+\n+  /* Get the field width.  */\n+  info.width = 0;\n+  if (*format == '*')\n+    {\n+      /* The field width is given in an argument.\n+\t A negative field width indicates left justification.  */\n+      ++format;\n+      info.width = va_arg (ap, int);\n+    }\n+  else if (isdigit (*format))\n+    /* Constant width specification.  */\n+    info.width = read_int (&format);\n+\n+  /* Get the precision.  */\n+  /* -1 means none given; 0 means explicit 0.  */\n+  info.prec = -1;\n+  if (*format == '.')\n+    {\n+      ++format;\n+      if (*format == '*')\n+\t{\n+\t  /* The precision is given in an argument.  */\n+\t  ++format;\n+\n+\t  info.prec = va_arg (ap, int);\n+\t}\n+      else if (isdigit (*format))\n+\tinfo.prec = read_int (&format);\n+      else\n+\t/* \"%.?\" is treated like \"%.0?\".  */\n+\tinfo.prec = 0;\n+    }\n+\n+  /* Check for type modifiers.  */\n+  info.is_long_double = 0;\n+  info.is_short = 0;\n+  info.is_long = 0;\n+  info.is_char = 0;\n+  info.user = -1;\n+\n+  /* We require Q modifier.  */\n+  if (*format++ != 'Q')\n+    {\n+      va_end (ap);\n+      return -1;\n+    }\n+\n+  /* Get the format specification.  */\n+  info.spec = (wchar_t) *format++;\n+  if (info.spec == L_('\\0') || *format != '\\0')\n+    {\n+      va_end (ap);\n+      return -1;\n+    }\n+\n+  switch (info.spec)\n+    {\n+    case L_('e'):\n+    case L_('E'):\n+    case L_('f'):\n+    case L_('F'):\n+    case L_('g'):\n+    case L_('G'):\n+    case L_('a'):\n+    case L_('A'):\n+      break;\n+    default:\n+      va_end (ap);\n+      return -1;\n+    }\n+\n+  fpnum = va_arg (ap, __float128);\n+  va_end (ap);\n+\n+  qfp.fp = NULL;\n+  qfp.str = str;\n+  qfp.size = size;\n+  qfp.len = 0;\n+  qfp.file_p = 0;\n+\n+  if (info.spec == L_('a') || info.spec == L_('A'))\n+    __quadmath_printf_fphex (&qfp, &info, (const void *const *)&fpnum_addr2);\n+  else\n+    __quadmath_printf_fp (&qfp, &info, (const void *const *)&fpnum_addr2);\n+\n+  if (qfp.size)\n+    *qfp.str = '\\0';\n+\n+  return qfp.len;\n+}\n+\n+#ifdef HAVE_PRINTF_HOOKS\n+static int pa_flt128;\n+int mod_Q attribute_hidden;\n+\n+static void\n+flt128_va (void *mem, va_list *ap)\n+{ \n+  __float128 d = va_arg (*ap, __float128);\n+  memcpy (mem, &d, sizeof (d));\n+}\n+\n+static int\n+flt128_ais (const struct printf_info *info, size_t n __attribute__ ((unused)),\n+\t    int *argtype, int *size)\n+{\n+  if (info->user & mod_Q)\n+    {\n+      argtype[0] = pa_flt128;\n+      size[0] = sizeof (__float128);\n+      return 1;\n+    }\n+#if __GLIBC_MINOR__ <= 13\n+  /* Workaround bug in glibc printf hook handling.  */\n+  size[0] = -1;\n+  switch (info->spec)\n+    {\n+    case L_('i'):\n+    case L_('d'):\n+    case L_('u'):\n+    case L_('o'):\n+    case L_('X'):\n+    case L_('x'):\n+#if __LONG_MAX__ != __LONG_LONG_MAX__\n+      if (info->is_long_double)\n+\targtype[0] = PA_INT|PA_FLAG_LONG_LONG;\n+      else\n+#endif\n+      if (info->is_long)\n+\targtype[0] = PA_INT|PA_FLAG_LONG;\n+      else if (info->is_short)\n+\targtype[0] = PA_INT|PA_FLAG_SHORT;\n+      else if (info->is_char)\n+\targtype[0] = PA_CHAR;\n+      else\n+\targtype[0] = PA_INT;\n+      return 1;\n+    case L_('e'):\n+    case L_('E'):\n+    case L_('f'):\n+    case L_('F'):\n+    case L_('g'):\n+    case L_('G'):\n+    case L_('a'):\n+    case L_('A'):\n+      if (info->is_long_double)\n+\targtype[0] = PA_DOUBLE|PA_FLAG_LONG_DOUBLE;\n+      else\n+\targtype[0] = PA_DOUBLE;\n+      return 1;\n+    case L_('c'):\n+      argtype[0] = PA_CHAR;\n+      return 1;\n+    case L_('C'):\n+      argtype[0] = PA_WCHAR;\n+      return 1;\n+    case L_('s'):\n+      argtype[0] = PA_STRING;\n+      return 1;\n+    case L_('S'):\n+      argtype[0] = PA_WSTRING;\n+      return 1;\n+    case L_('p'):\n+      argtype[0] = PA_POINTER;\n+      return 1;\n+    case L_('n'):\n+      argtype[0] = PA_INT|PA_FLAG_PTR;\n+      return 1;\n+\n+    case L_('m'):\n+    default:\n+      /* An unknown spec will consume no args.  */\n+      return 0;\n+    }\n+#endif\n+  return -1;\n+}\n+\n+static int\n+flt128_printf_fp (FILE *fp, const struct printf_info *info,\n+\t\t  const void *const *args)\n+{\n+  struct __quadmath_printf_file qpf\n+    = { .fp = fp, .str = NULL, .size = 0, .len = 0, .file_p = 1 };\n+\n+  if ((info->user & mod_Q) == 0)\n+    return -2;\n+\n+  return __quadmath_printf_fp (&qpf, info, args);\n+}\n+\n+static int\n+flt128_printf_fphex (FILE *fp, const struct printf_info *info,\n+\t\t     const void *const *args)\n+{\n+  struct __quadmath_printf_file qpf\n+    = { .fp = fp, .str = NULL, .size = 0, .len = 0, .file_p = 1 };\n+\n+  if ((info->user & mod_Q) == 0)\n+    return -2;\n+\n+  return __quadmath_printf_fphex (&qpf, info, args);\n+}\n+\n+__attribute__((constructor)) static void\n+register_printf_flt128 (void)\n+{\n+  pa_flt128 = register_printf_type (flt128_va);\n+  if (pa_flt128 == -1)\n+    return;\n+  mod_Q = register_printf_modifier (L_(\"Q\"));\n+  if (mod_Q == -1)\n+    return;\n+  register_printf_specifier ('f', flt128_printf_fp, flt128_ais);\n+  register_printf_specifier ('F', flt128_printf_fp, flt128_ais);\n+  register_printf_specifier ('e', flt128_printf_fp, flt128_ais);\n+  register_printf_specifier ('E', flt128_printf_fp, flt128_ais);\n+  register_printf_specifier ('g', flt128_printf_fp, flt128_ais);\n+  register_printf_specifier ('G', flt128_printf_fp, flt128_ais);\n+  register_printf_specifier ('a', flt128_printf_fphex, flt128_ais);\n+  register_printf_specifier ('A', flt128_printf_fphex, flt128_ais);\n+}\n+\n+__attribute__((destructor)) static void\n+unregister_printf_flt128 (void)\n+{\n+  /* No way to unregister printf type and modifier currently,\n+     and only one printf specifier can be registered right now.  */\n+  if (pa_flt128 == -1 || mod_Q == -1)\n+    return;\n+  register_printf_specifier ('f', NULL, NULL);\n+  register_printf_specifier ('F', NULL, NULL);\n+  register_printf_specifier ('e', NULL, NULL);\n+  register_printf_specifier ('E', NULL, NULL);\n+  register_printf_specifier ('g', NULL, NULL);\n+  register_printf_specifier ('G', NULL, NULL);\n+  register_printf_specifier ('a', NULL, NULL);\n+  register_printf_specifier ('A', NULL, NULL);\n+}\n+#endif"}, {"sha": "16092bfe1bc1538a32a0bfcffb123f0513adc78f", "filename": "libquadmath/printf/quadmath-printf.h", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Fquadmath-printf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Fquadmath-printf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Fquadmath-printf.h?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -0,0 +1,167 @@\n+/* GCC Quad-Precision Math Library\n+   Copyright (C) 2011 Free Software Foundation, Inc.\n+   Written by Jakub Jelinek  <jakub@redhat.com>\n+\n+This file is part of the libquadmath library.\n+Libquadmath is free software; you can redistribute it and/or\n+modify it under the terms of the GNU Library General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+Libquadmath is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+Library General Public License for more details.\n+\n+You should have received a copy of the GNU Library General Public\n+License along with libquadmath; see the file COPYING.LIB.  If\n+not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+#ifdef HAVE_LIMITS_H\n+#include <limits.h>\n+#endif\n+#ifdef HAVE_LANGINFO_H\n+#include <langinfo.h>\n+#endif\n+#ifdef HAVE_CTYPE_H\n+#include <ctype.h>\n+#endif\n+#ifdef HAVE_WCHAR_H\n+#include <wchar.h>\n+#endif\n+#ifdef HAVE_WCTYPE_H\n+#include <wctype.h>\n+#endif\n+#ifdef HAVE_PRINTF_HOOKS\n+#include <printf.h>\n+#endif\n+#include \"quadmath-imp.h\"\n+#include \"gmp-impl.h\"\n+\n+#ifdef HAVE_WCHAR_H\n+#define L_(x) L##x\n+#else\n+#define L_(x) x\n+#undef wchar_t\n+#undef wint_t\n+#undef putwc\n+#undef WEOF\n+#define wchar_t char\n+#define wint_t int\n+#define putwc(c,f) putc(c,f)\n+#define WEOF EOF\n+#endif\n+\n+#ifndef HAVE_CTYPE_H\n+/* Won't work for EBCDIC.  */\n+#undef isupper\n+#undef isdigit\n+#undef tolower\n+#define isupper(x) ((x) >= 'A' && (x) <= 'Z')\n+#define isdigit(x) ((x) >= '0' && (x) <= '9')\n+#define tolower(x) (isupper (x) ? (x) - 'A' + 'a' : (x))\n+#endif\n+\n+#ifndef CHAR_MAX\n+#ifdef __CHAR_UNSIGNED__\n+#define CHAR_MAX (2 * __SCHAR_MAX__ + 1)\n+#else\n+#define CHAR_MAX __SCHAR_MAX__\n+#endif\n+#endif\n+\n+#ifndef HAVE_PRINTF_HOOKS\n+#define printf_info __quadmath_printf_info\n+struct printf_info\n+{\n+  int prec;\t\t\t/* Precision.  */\n+  int width;\t\t\t/* Width.  */\n+  wchar_t spec;\t\t\t/* Format letter.  */\n+  unsigned int is_long_double:1;/* L flag.  */\n+  unsigned int is_short:1;\t/* h flag.  */\n+  unsigned int is_long:1;\t/* l flag.  */\n+  unsigned int alt:1;\t\t/* # flag.  */\n+  unsigned int space:1;\t\t/* Space flag.  */\n+  unsigned int left:1;\t\t/* - flag.  */\n+  unsigned int showsign:1;\t/* + flag.  */\n+  unsigned int group:1;\t\t/* ' flag.  */\n+  unsigned int extra:1;\t\t/* For special use.  */\n+  unsigned int is_char:1;\t/* hh flag.  */\n+  unsigned int wide:1;\t\t/* Nonzero for wide character streams.  */\n+  unsigned int i18n:1;\t\t/* I flag.  */\n+  unsigned short int user;\t/* Bits for user-installed modifiers.  */\n+  wchar_t pad;\t\t\t/* Padding character.  */\n+};\n+#endif\n+\n+struct __quadmath_printf_file\n+{\n+  FILE *fp;\n+  char *str;\n+  size_t size;\n+  size_t len;\n+  int file_p;\n+};\n+\n+int\n+__quadmath_printf_fp (struct __quadmath_printf_file *fp,\n+\t\t      const struct printf_info *info,\n+\t\t      const void *const *args) attribute_hidden;\n+int\n+__quadmath_printf_fphex (struct __quadmath_printf_file *fp,\n+\t\t\t const struct printf_info *info,\n+\t\t\t const void *const *args) attribute_hidden;\n+\n+size_t __quadmath_do_pad (struct __quadmath_printf_file *fp, int wide,\n+\t\t\t  int c, size_t n) attribute_hidden;\n+\n+static inline __attribute__((__unused__)) size_t\n+__quadmath_do_put (struct __quadmath_printf_file *fp, int wide,\n+\t\t   const char *s, size_t n)\n+{\n+  size_t len;\n+  if (fp->file_p)\n+    {\n+      if (wide)\n+\t{\n+\t  size_t cnt;\n+\t  const wchar_t *ls = (const wchar_t *) s;\n+\t  for (cnt = 0; cnt < n; cnt++)\n+\t    if (putwc (ls[cnt], fp->fp) == WEOF)\n+\t      break;\n+\t  return cnt;\n+\t}\n+      return fwrite (s, 1, n, fp->fp);\n+    }\n+  len = MIN (fp->size, n);\n+  memcpy (fp->str, s, len);\n+  fp->str += len;\n+  fp->size -= len;\n+  fp->len += n;\n+  return n;\n+}\n+\n+static inline __attribute__((__unused__)) int\n+__quadmath_do_putc (struct __quadmath_printf_file *fp, int wide,\n+\t\t    wchar_t c)\n+{\n+  if (fp->file_p)\n+    return wide ? (int) putwc (c, fp->fp) : putc (c, fp->fp);\n+  if (fp->size)\n+    {\n+      *(fp->str++) = c;\n+      fp->size--;\n+    }\n+  fp->len++;\n+  return (unsigned char) c;\n+}\n+\n+#define PUT(f, s, n) __quadmath_do_put (f, wide, s, n)\n+#define PAD(f, c, n) __quadmath_do_pad (f, wide, c, n)\n+#define PUTC(c, f) __quadmath_do_putc (f, wide, c)\n+\n+#define nl_langinfo_wc(x) \\\n+  ({ union { const char *mb; wchar_t wc; } u; u.mb = nl_langinfo (x); u.wc; })"}, {"sha": "508bc586e34a2452a030be58c276b8d51daae5f3", "filename": "libquadmath/printf/rshift.c", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Frshift.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Frshift.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Frshift.c?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -0,0 +1,87 @@\n+/* mpn_rshift -- Shift right a low-level natural-number integer.\n+\n+Copyright (C) 1991, 1993, 1994, 1996 Free Software Foundation, Inc.\n+\n+This file is part of the GNU MP Library.\n+\n+The GNU MP Library is free software; you can redistribute it and/or modify\n+it under the terms of the GNU Lesser General Public License as published by\n+the Free Software Foundation; either version 2.1 of the License, or (at your\n+option) any later version.\n+\n+The GNU MP Library is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public\n+License for more details.\n+\n+You should have received a copy of the GNU Lesser General Public License\n+along with the GNU MP Library; see the file COPYING.LIB.  If not, write to\n+the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,\n+MA 02111-1307, USA. */\n+\n+#include \"gmp-impl.h\"\n+\n+/* Shift U (pointed to by UP and USIZE limbs long) CNT bits to the right\n+   and store the USIZE least significant limbs of the result at WP.\n+   The bits shifted out to the right are returned.\n+\n+   Argument constraints:\n+   1. 0 < CNT < BITS_PER_MP_LIMB\n+   2. If the result is to be written over the input, WP must be <= UP.\n+*/\n+\n+mp_limb_t\n+#if __STDC__\n+mpn_rshift (register mp_ptr wp,\n+\t    register mp_srcptr up, mp_size_t usize,\n+\t    register unsigned int cnt)\n+#else\n+mpn_rshift (wp, up, usize, cnt)\n+     register mp_ptr wp;\n+     register mp_srcptr up;\n+     mp_size_t usize;\n+     register unsigned int cnt;\n+#endif\n+{\n+  register mp_limb_t high_limb, low_limb;\n+  register unsigned sh_1, sh_2;\n+  register mp_size_t i;\n+  mp_limb_t retval;\n+\n+#ifdef DEBUG\n+  if (usize == 0 || cnt == 0)\n+    abort ();\n+#endif\n+\n+  sh_1 = cnt;\n+\n+#if 0\n+  if (sh_1 == 0)\n+    {\n+      if (wp != up)\n+\t{\n+\t  /* Copy from low end to high end, to allow specified input/output\n+\t     overlapping.  */\n+\t  for (i = 0; i < usize; i++)\n+\t    wp[i] = up[i];\n+\t}\n+      return usize;\n+    }\n+#endif\n+\n+  wp -= 1;\n+  sh_2 = BITS_PER_MP_LIMB - sh_1;\n+  high_limb = up[0];\n+  retval = high_limb << sh_2;\n+  low_limb = high_limb;\n+\n+  for (i = 1; i < usize; i++)\n+    {\n+      high_limb = up[i];\n+      wp[i] = (low_limb >> sh_1) | (high_limb << sh_2);\n+      low_limb = high_limb;\n+    }\n+  wp[i] = low_limb >> sh_1;\n+\n+  return retval;\n+}"}, {"sha": "c833abc6eec275402c1b3d98fb9be1023ce71c87", "filename": "libquadmath/printf/sub_n.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Fsub_n.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Fsub_n.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Fsub_n.c?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -0,0 +1,61 @@\n+/* mpn_sub_n -- Subtract two limb vectors of equal, non-zero length.\n+\n+Copyright (C) 1992, 1993, 1994, 1996 Free Software Foundation, Inc.\n+\n+This file is part of the GNU MP Library.\n+\n+The GNU MP Library is free software; you can redistribute it and/or modify\n+it under the terms of the GNU Lesser General Public License as published by\n+the Free Software Foundation; either version 2.1 of the License, or (at your\n+option) any later version.\n+\n+The GNU MP Library is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public\n+License for more details.\n+\n+You should have received a copy of the GNU Lesser General Public License\n+along with the GNU MP Library; see the file COPYING.LIB.  If not, write to\n+the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,\n+MA 02111-1307, USA. */\n+\n+#include \"gmp-impl.h\"\n+\n+mp_limb_t\n+#if __STDC__\n+mpn_sub_n (mp_ptr res_ptr, mp_srcptr s1_ptr, mp_srcptr s2_ptr, mp_size_t size)\n+#else\n+mpn_sub_n (res_ptr, s1_ptr, s2_ptr, size)\n+     register mp_ptr res_ptr;\n+     register mp_srcptr s1_ptr;\n+     register mp_srcptr s2_ptr;\n+     mp_size_t size;\n+#endif\n+{\n+  register mp_limb_t x, y, cy;\n+  register mp_size_t j;\n+\n+  /* The loop counter and index J goes from -SIZE to -1.  This way\n+     the loop becomes faster.  */\n+  j = -size;\n+\n+  /* Offset the base pointers to compensate for the negative indices.  */\n+  s1_ptr -= j;\n+  s2_ptr -= j;\n+  res_ptr -= j;\n+\n+  cy = 0;\n+  do\n+    {\n+      y = s2_ptr[j];\n+      x = s1_ptr[j];\n+      y += cy;\t\t\t/* add previous carry to subtrahend */\n+      cy = (y < cy);\t\t/* get out carry from that addition */\n+      y = x - y;\t\t/* main subtract */\n+      cy = (y > x) + cy;\t/* get out carry from the subtract, combine */\n+      res_ptr[j] = y;\n+    }\n+  while (++j != 0);\n+\n+  return cy;\n+}"}, {"sha": "97607e8098554e280906aa9d31538e492b02fd9c", "filename": "libquadmath/printf/submul_1.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Fsubmul_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fprintf%2Fsubmul_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fprintf%2Fsubmul_1.c?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -0,0 +1,63 @@\n+/* mpn_submul_1 -- multiply the S1_SIZE long limb vector pointed to by S1_PTR\n+   by S2_LIMB, subtract the S1_SIZE least significant limbs of the product\n+   from the limb vector pointed to by RES_PTR.  Return the most significant\n+   limb of the product, adjusted for carry-out from the subtraction.\n+\n+Copyright (C) 1992, 1993, 1994, 1996, 2005 Free Software Foundation, Inc.\n+\n+This file is part of the GNU MP Library.\n+\n+The GNU MP Library is free software; you can redistribute it and/or modify\n+it under the terms of the GNU Lesser General Public License as published by\n+the Free Software Foundation; either version 2.1 of the License, or (at your\n+option) any later version.\n+\n+The GNU MP Library is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public\n+License for more details.\n+\n+You should have received a copy of the GNU Lesser General Public License\n+along with the GNU MP Library; see the file COPYING.LIB.  If not, write to\n+the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,\n+MA 02111-1307, USA. */\n+\n+#include \"gmp-impl.h\"\n+\n+mp_limb_t\n+mpn_submul_1 (res_ptr, s1_ptr, s1_size, s2_limb)\n+     register mp_ptr res_ptr;\n+     register mp_srcptr s1_ptr;\n+     mp_size_t s1_size;\n+     register mp_limb_t s2_limb;\n+{\n+  register mp_limb_t cy_limb;\n+  register mp_size_t j;\n+  register mp_limb_t prod_high, prod_low;\n+  register mp_limb_t x;\n+\n+  /* The loop counter and index J goes from -SIZE to -1.  This way\n+     the loop becomes faster.  */\n+  j = -s1_size;\n+\n+  /* Offset the base pointers to compensate for the negative indices.  */\n+  res_ptr -= j;\n+  s1_ptr -= j;\n+\n+  cy_limb = 0;\n+  do\n+    {\n+      umul_ppmm (prod_high, prod_low, s1_ptr[j], s2_limb);\n+\n+      prod_low += cy_limb;\n+      cy_limb = (prod_low < cy_limb) + prod_high;\n+\n+      x = res_ptr[j];\n+      prod_low = x - prod_low;\n+      cy_limb += (prod_low > x);\n+      res_ptr[j] = prod_low;\n+    }\n+  while (++j != 0);\n+\n+  return cy_limb;\n+}"}, {"sha": "3359a69f7bdc5d4eac0c0c0ddaba3fa50c5e3f9a", "filename": "libquadmath/quadmath.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fquadmath.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fquadmath.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fquadmath.h?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -132,8 +132,8 @@ extern __complex128 ctanhq (__complex128) __quadmath_throw;\n \n /* Prototypes for string <-> __float128 conversion functions */\n extern __float128 strtoflt128 (const char *, char **) __quadmath_throw;\n-extern void quadmath_flt128tostr (char *, size_t, size_t, __float128)\n-  __quadmath_throw;\n+extern int quadmath_snprintf (char *str, size_t size,\n+\t\t\t      const char *format, ...) __quadmath_throw;\n \n \n /* Macros */"}, {"sha": "2d20280229e369b4d7109854ae3f5ae73659e536", "filename": "libquadmath/quadmath.map", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fquadmath.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fquadmath.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fquadmath.map?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -92,7 +92,7 @@ QUADMATH_1.0 {\n     ctanhq;\n \n     strtoflt128;\n-    quadmath_flt128tostr;\n+    quadmath_snprintf;\n   local:\n     *;\n };"}, {"sha": "ccd023c3c5a78eb2570e522f377bf1a75ed3c170", "filename": "libquadmath/quadmath_io.c", "status": "removed", "additions": 0, "deletions": 110, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944f4bb398aaf3d25c71a5b12ca9626d2c5f5e99/libquadmath%2Fquadmath_io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944f4bb398aaf3d25c71a5b12ca9626d2c5f5e99/libquadmath%2Fquadmath_io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fquadmath_io.c?ref=944f4bb398aaf3d25c71a5b12ca9626d2c5f5e99", "patch": "@@ -1,110 +0,0 @@\n-/* GCC Quad-Precision Math Library\n-   Copyright (C) 2010, 2011 Free Software Foundation, Inc.\n-   Written by Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n-\n-This file is part of the libquadmath library.\n-Libquadmath is free software; you can redistribute it and/or\n-modify it under the terms of the GNU Library General Public\n-License as published by the Free Software Foundation; either\n-version 2 of the License, or (at your option) any later version.\n-\n-Libquadmath is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-Library General Public License for more details.\n-\n-You should have received a copy of the GNU Library General Public\n-License along with libquadmath; see the file COPYING.LIB.  If\n-not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor,\n-Boston, MA 02110-1301, USA.  */\n-\n-#include \"quadmath.h\"\n-#include <stdio.h>\n-#include <string.h>\n-\n-#define ABS(x) ((x) >= 0 ? (x) : -(x))\n-\n-\n-\n-static void\n-format (char * res, const __float128 x, size_t n)\n-{\n-  char buffer[1024];\n-  char *p;\n-\n-  memset (buffer, 0, sizeof(buffer));\n-\n-  g_Qfmt (buffer, &x, n + 1, sizeof(buffer) - 3);\n-  p = buffer + (*buffer == '-' ? 1 : 0);\n-\n-  /* The sign is the easiest part.  */\n-  res[0] = (signbitq (x) ? '-' : '+');\n-\n-  if (*p == '.')\n-  {\n-    /* We have a number smaller than 1, without exponent.  */\n-    int exp = 0;\n-    char *c;\n-\n-    for (c = p+1; *c == '0'; c++)\n-      exp++;\n-\n-    /* We move the string \"exp\" characters left.  */\n-    size_t l = strlen (p+1+exp);\n-    memcpy (res + 2, p + 1 + exp, l);\n-    memset (res + 2 + l, '0', n - l + 1);\n-    sprintf (res + n + 3, \"e-%02d\", exp + 1);\n-\n-    res[1] = res[2];\n-    res[2] = '.';\n-\n-    return;\n-  }\n-\n-  /* Now, do we already have an exponent.  */\n-  char *c;\n-  for (c = p; *c && *c != 'e'; c++)\n-    ;\n-  if (*c)\n-  {\n-    int exp = strtol (c + 1, NULL, 10);\n-\n-    size_t l = c - p;\n-\n-    memcpy (res + 1, p, l);\n-    if (l <= n + 1)\n-      memset (res + 1 + l, '0', (int) n - l + 2);\n-\n-    sprintf (res + n + 3, \"e%c%02d\", exp >= 0 ? '+' : '-', ABS(exp));\n-\n-    return;\n-  }\n-  else\n-  {\n-    /* If we have no exponent, normalize and add the exponent.  */\n-    for (c = p; *c && *c != '.'; c++)\n-      ;\n-\n-    res[1] = *p;\n-    res[2] = '.';\n-\n-    size_t l = c - p;\n-    memcpy (res + 3, p + 1, l);\n-    size_t l2 = strlen (c + 1);\n-    memcpy (res + 2 + l, c + 1, l2);\n-    memset (res + 2 + l + l2, '0', n - (l + l2) + 1);\n-    sprintf (res + n + 3, \"e+%02d\", l - 1);\n-\n-    return;\n-  }\n-}\n-\n-\n-void\n-quadmath_flt128tostr (char *s, size_t size, size_t n, __float128 x)\n-{\n-  char buffer[1024];\n-  memset (buffer, 0, sizeof(buffer));\n-  format (buffer, x, n);\n-  memcpy (s, buffer, size);\n-}"}, {"sha": "986079abc406921d353c3dd8c35a21a0fccecf05", "filename": "libquadmath/quadmath_weak.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fquadmath_weak.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d92226be3a775b085e90436067c45f938fba761/libquadmath%2Fquadmath_weak.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libquadmath%2Fquadmath_weak.h?ref=1d92226be3a775b085e90436067c45f938fba761", "patch": "@@ -132,6 +132,6 @@ __qmath3 (ctanhq)\n \n /* Prototypes for string <-> flt128 conversion functions.  */\n __qmath3 (strtoflt128)\n-__qmath3 (quadmath_flt128tostr)\n+__qmath3 (quadmath_snprintf)\n \n #endif"}]}