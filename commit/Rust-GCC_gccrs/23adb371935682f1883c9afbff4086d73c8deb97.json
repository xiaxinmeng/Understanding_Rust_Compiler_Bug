{"sha": "23adb371935682f1883c9afbff4086d73c8deb97", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjNhZGIzNzE5MzU2ODJmMTg4M2M5YWZiZmY0MDg2ZDczYzhkZWI5Nw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-05-15T09:48:58Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-05-15T09:48:58Z"}, "message": "[multiple changes]\n\n2012-05-15  Tristan Gingold  <gingold@adacore.com>\n\n\t* exp_ch7.adb (Build_Exception_Handler): Save current\n\toccurrence only if -gnateE.\n\t(Build_Object_Declaration): Declare E_Id only if -gnateE.\n\t(Build_Raise_Statement): Call Raise_From_Controlled_Operation only if\n\t-gnateE (else raise PE).\n\t* s-soflin.adb (Save_Library_Occurrence): Handle null occurrence\n\taccess.\n\t* a-except-2005.adb (Reraise_Library_Exception_If_Any): Call\n\tRaise_From_Controlled_Operation only if the saved occurrence is\n\tnot null, otherwise raise PE.\n\n2012-05-15  Yannick Moy  <moy@adacore.com>\n\n\t* exp_alfa.ads: Add comments describing the Alfa mode.\n\nFrom-SVN: r187514", "tree": {"sha": "3c72a329b1ee07250517a96a07e36dca186dffe9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c72a329b1ee07250517a96a07e36dca186dffe9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23adb371935682f1883c9afbff4086d73c8deb97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23adb371935682f1883c9afbff4086d73c8deb97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23adb371935682f1883c9afbff4086d73c8deb97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23adb371935682f1883c9afbff4086d73c8deb97/comments", "author": null, "committer": null, "parents": [{"sha": "e5a222431f2c38c283040296d398a95e47708b0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5a222431f2c38c283040296d398a95e47708b0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5a222431f2c38c283040296d398a95e47708b0d"}], "stats": {"total": 267, "additions": 189, "deletions": 78}, "files": [{"sha": "cf335cac045a852eaefa2930e8cd58e8a22ae06b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23adb371935682f1883c9afbff4086d73c8deb97/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23adb371935682f1883c9afbff4086d73c8deb97/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=23adb371935682f1883c9afbff4086d73c8deb97", "patch": "@@ -1,3 +1,20 @@\n+2012-05-15  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* exp_ch7.adb (Build_Exception_Handler): Save current\n+\toccurrence only if -gnateE.\n+\t(Build_Object_Declaration): Declare E_Id only if -gnateE.\n+\t(Build_Raise_Statement): Call Raise_From_Controlled_Operation only if\n+\t-gnateE (else raise PE).\n+\t* s-soflin.adb (Save_Library_Occurrence): Handle null occurrence\n+\taccess.\n+\t* a-except-2005.adb (Reraise_Library_Exception_If_Any): Call\n+\tRaise_From_Controlled_Operation only if the saved occurrence is\n+\tnot null, otherwise raise PE.\n+\n+2012-05-15  Yannick Moy  <moy@adacore.com>\n+\n+\t* exp_alfa.ads: Add comments describing the Alfa mode.\n+\n 2012-05-15  Tristan Gingold  <gingold@adacore.com>\n \n \t* s-soflin.ads, s-soflin.adb (Save_Library_Occurrence): Parameter"}, {"sha": "179a0bddddad299b5a473db52ed8d24c09fda798", "filename": "gcc/ada/a-except-2005.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23adb371935682f1883c9afbff4086d73c8deb97/gcc%2Fada%2Fa-except-2005.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23adb371935682f1883c9afbff4086d73c8deb97/gcc%2Fada%2Fa-except-2005.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except-2005.adb?ref=23adb371935682f1883c9afbff4086d73c8deb97", "patch": "@@ -1296,7 +1296,13 @@ package body Ada.Exceptions is\n    begin\n       if Library_Exception_Set then\n          LE := Library_Exception;\n-         Raise_From_Controlled_Operation (LE);\n+         if LE.Id = Null_Id then\n+            Raise_Exception_No_Defer\n+              (E       => Program_Error'Identity,\n+               Message => \"finalize/adjust raised exception\");\n+         else\n+            Raise_From_Controlled_Operation (LE);\n+         end if;\n       end if;\n    end Reraise_Library_Exception_If_Any;\n "}, {"sha": "7b67c8d3cc4160460eefef5c9e7fa23c9f196610", "filename": "gcc/ada/exp_alfa.ads", "status": "modified", "additions": 40, "deletions": 6, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23adb371935682f1883c9afbff4086d73c8deb97/gcc%2Fada%2Fexp_alfa.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23adb371935682f1883c9afbff4086d73c8deb97/gcc%2Fada%2Fexp_alfa.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_alfa.ads?ref=23adb371935682f1883c9afbff4086d73c8deb97", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2011, Free Software Foundation, Inc.           --\n+--          Copyright (C) 2011-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -24,25 +24,59 @@\n ------------------------------------------------------------------------------\n \n --  This package implements a light expansion which is used in formal\n---  verification mode. Instead of a complete expansion of nodes for code\n---  generation, this Alfa expansion targets generation of intermediate code\n---  for formal verification.\n+--  verification mode (Alfa_Mode = True). Instead of a complete expansion\n+--  of nodes for code generation, this Alfa expansion targets generation\n+--  of intermediate code for formal verification.\n \n --  Expand_Alfa is called directly by Expander.Expand.\n \n --  Alfa expansion has three main objectives:\n \n --    1. Perform limited expansion to explicit some Ada rules and constructs\n --       (translate 'Old and 'Result, replace renamings by renamed, insert\n---        conversions, expand actuals in calls to introduce temporaries)\n+--        conversions, expand actuals in calls to introduce temporaries, expand\n+--        generics instantiations)\n \n --    2. Facilitate treatment for the formal verification back-end (fully\n---       qualify names, set membership)\n+--       qualify names, expand set membership, compute data dependences)\n \n --    3. Avoid the introduction of low-level code that is difficult to analyze\n --       formally, as typically done in the full expansion for high-level\n --       constructs (tasking, dispatching)\n \n+--  To fulfill objective 1, Expand_Alfa selectively expands some constructs.\n+\n+--  To fulfill objective 2, the tree after Alfa expansion should be fully\n+--  analyzed semantically. In particular, all expression must have their proper\n+--  type, and semantic links should be set between tree nodes (partial to full\n+--  view, etc.) Some kinds of nodes should be either absent, or can be ignored\n+--  by the formal verification backend:\n+\n+--      N_Object_Renaming_Declaration: can be ignored safely\n+--      N_Expression_Function:         absent (rewitten)\n+--      N_Expression_With_Actions:     absent (not generated)\n+\n+--  Alfa cross-references are generated from the regular cross-references (used\n+--  for browsing and code understanding) and additional references collected\n+--  during semantic analysis, in particular on all dereferences. These Alfa\n+--  cross-references are output in a separate section of ALI files, as\n+--  described in alfa.adb. They are the basis for the computation of data\n+--  dependences in the formal verification backend. This implies that all\n+--  cross-references should be generated in this mode, even those that would\n+--  not make sense from a user point-of-view, and that cross-references that do\n+--  not lead to data dependences for subprograms can be safely ignored.\n+\n+--  To support the formal verification of units parameterized by data, the\n+--  value of deferred constants should not be considered as a compile-time\n+--  constant at program locations where the full view is not visible.\n+\n+--  To fulfill objective 3, Expand_Alfa does not expand features that are not\n+--  formally analyzed (tasking), or for which formal analysis relies on the\n+--  source level representation (dispatching, aspects, pragmas). However, these\n+--  should be semantically analyzed, which sometimes requires the insertion of\n+--  semantic pre-analysis, for example for subprogram contracts and pragma\n+--  check/assert.\n+\n with Types; use Types;\n \n package Exp_Alfa is"}, {"sha": "3d3df50645d2b60c68b9b00ba4fb6e89c1fde4f0", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 121, "deletions": 70, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23adb371935682f1883c9afbff4086d73c8deb97/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23adb371935682f1883c9afbff4086d73c8deb97/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=23adb371935682f1883c9afbff4086d73c8deb97", "patch": "@@ -717,63 +717,95 @@ package body Exp_Ch7 is\n       Actuals      : List_Id;\n       Proc_To_Call : Entity_Id;\n       Except       : Node_Id;\n+      Stmts        : List_Id;\n \n    begin\n-      pragma Assert (Present (Data.E_Id));\n       pragma Assert (Present (Data.Raised_Id));\n \n-      --  Generate:\n+      if Exception_Extra_Info\n+        or else (For_Library and then not Restricted_Profile)\n+      then\n+         if Exception_Extra_Info then\n+            --  Generate:\n \n-      --    Get_Current_Excep.all\n+            --    Get_Current_Excep.all\n \n-      Except :=\n-        Make_Function_Call (Data.Loc,\n-          Name =>\n-            Make_Explicit_Dereference (Data.Loc,\n-              Prefix =>\n-                New_Reference_To (RTE (RE_Get_Current_Excep), Data.Loc)));\n+            Except :=\n+              Make_Function_Call (Data.Loc,\n+                Name =>\n+                  Make_Explicit_Dereference (Data.Loc,\n+                    Prefix =>\n+                      New_Reference_To (RTE (RE_Get_Current_Excep),\n+                                        Data.Loc)));\n+         else\n+            --  Generate:\n \n-      if For_Library and not Restricted_Profile then\n-         Proc_To_Call := RTE (RE_Save_Library_Occurrence);\n-         Actuals := New_List (Except);\n-      else\n-         Proc_To_Call := RTE (RE_Save_Occurrence);\n-         Actuals :=\n-           New_List\n-             (New_Reference_To (Data.E_Id, Data.Loc),\n+            --    null\n+\n+            Except := Make_Null (Data.Loc);\n+         end if;\n+\n+         if For_Library and then not Restricted_Profile then\n+            Proc_To_Call := RTE (RE_Save_Library_Occurrence);\n+            Actuals := New_List (Except);\n+         else\n+            Proc_To_Call := RTE (RE_Save_Occurrence);\n+\n+            --  The dereference occurs only when Exception_Extra_Info is true,\n+            --  and therefore Except is not null.\n+\n+            Actuals := New_List (\n+              New_Reference_To (Data.E_Id, Data.Loc),\n               Make_Explicit_Dereference (Data.Loc, Except));\n+         end if;\n+\n+         --  Generate:\n+\n+         --    when others =>\n+         --       if not Raised_Id then\n+         --          Raised_Id := True;\n+\n+         --          Save_Occurrence (E_Id, Get_Current_Excep.all.all);\n+         --            or\n+         --          Save_Library_Occurrence (Get_Current_Excep.all);\n+         --       end if;\n+\n+         Stmts :=\n+           New_List (\n+             Make_If_Statement (Data.Loc,\n+               Condition       =>\n+                 Make_Op_Not (Data.Loc,\n+                   Right_Opnd => New_Reference_To (Data.Raised_Id, Data.Loc)),\n+\n+               Then_Statements => New_List (\n+                 Make_Assignment_Statement (Data.Loc,\n+                   Name       => New_Reference_To (Data.Raised_Id, Data.Loc),\n+                   Expression => New_Reference_To (Standard_True, Data.Loc)),\n+\n+                 Make_Procedure_Call_Statement (Data.Loc,\n+                   Name                   =>\n+                     New_Reference_To (Proc_To_Call, Data.Loc),\n+                   Parameter_Associations => Actuals))));\n+\n+      else\n+         --  Generate:\n+\n+         --    Raised_Id := True;\n+\n+         Stmts := New_List (\n+           Make_Assignment_Statement (Data.Loc,\n+             Name       => New_Reference_To (Data.Raised_Id, Data.Loc),\n+             Expression => New_Reference_To (Standard_True, Data.Loc)));\n       end if;\n \n       --  Generate:\n \n       --    when others =>\n-      --       if not Raised_Id then\n-      --          Raised_Id := True;\n-\n-      --          Save_Occurrence (E_Id, Get_Current_Excep.all.all);\n-      --            or\n-      --          Save_Library_Occurrence (Get_Current_Excep.all);\n-      --       end if;\n \n       return\n         Make_Exception_Handler (Data.Loc,\n-          Exception_Choices =>\n-            New_List (Make_Others_Choice (Data.Loc)),\n-          Statements => New_List (\n-            Make_If_Statement (Data.Loc,\n-              Condition       =>\n-                Make_Op_Not (Data.Loc,\n-                  Right_Opnd => New_Reference_To (Data.Raised_Id, Data.Loc)),\n-\n-              Then_Statements => New_List (\n-                Make_Assignment_Statement (Data.Loc,\n-                  Name       => New_Reference_To (Data.Raised_Id, Data.Loc),\n-                  Expression => New_Reference_To (Standard_True, Data.Loc)),\n-\n-                Make_Procedure_Call_Statement (Data.Loc,\n-                  Name                   =>\n-                    New_Reference_To (Proc_To_Call, Data.Loc),\n-                  Parameter_Associations => Actuals)))));\n+          Exception_Choices => New_List (Make_Others_Choice (Data.Loc)),\n+          Statements        => Stmts);\n    end Build_Exception_Handler;\n \n    -------------------------------\n@@ -2998,8 +3030,6 @@ package body Exp_Ch7 is\n          return;\n       end if;\n \n-      Data.Abort_Id  := Make_Temporary (Loc, 'A');\n-      Data.E_Id      := Make_Temporary (Loc, 'E');\n       Data.Raised_Id := Make_Temporary (Loc, 'R');\n \n       --  In certain scenarios, finalization can be triggered by an abort. If\n@@ -3019,35 +3049,44 @@ package body Exp_Ch7 is\n         and then VM_Target = No_VM\n         and then not For_Package\n       then\n+         Data.Abort_Id  := Make_Temporary (Loc, 'A');\n+\n          A_Expr := New_Reference_To (RTE (RE_Triggered_By_Abort), Loc);\n \n-      --  No abort, .NET/JVM or library-level finalizers\n+         --  Generate:\n+         --    Abort_Id : constant Boolean := <A_Expr>;\n+\n+         Append_To (Decls,\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Data.Abort_Id,\n+             Constant_Present    => True,\n+             Object_Definition   => New_Reference_To (Standard_Boolean, Loc),\n+             Expression          => A_Expr));\n \n       else\n-         A_Expr := New_Reference_To (Standard_False, Loc);\n+         --  No abort, .NET/JVM or library-level finalizers\n+\n+         Data.Abort_Id  := Empty;\n       end if;\n \n-      --  Generate:\n-      --    Abort_Id : constant Boolean := <A_Expr>;\n+      if Exception_Extra_Info then\n+         Data.E_Id      := Make_Temporary (Loc, 'E');\n \n-      Append_To (Decls,\n-        Make_Object_Declaration (Loc,\n-          Defining_Identifier => Data.Abort_Id,\n-          Constant_Present    => True,\n-          Object_Definition   => New_Reference_To (Standard_Boolean, Loc),\n-          Expression          => A_Expr));\n+         --  Generate:\n+         --    E_Id : Exception_Occurrence;\n \n-      --  Generate:\n-      --    E_Id : Exception_Occurrence;\n+         E_Decl :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Data.E_Id,\n+             Object_Definition   =>\n+               New_Reference_To (RTE (RE_Exception_Occurrence), Loc));\n+         Set_No_Initialization (E_Decl);\n \n-      E_Decl :=\n-        Make_Object_Declaration (Loc,\n-          Defining_Identifier => Data.E_Id,\n-          Object_Definition   =>\n-            New_Reference_To (RTE (RE_Exception_Occurrence), Loc));\n-      Set_No_Initialization (E_Decl);\n+         Append_To (Decls, E_Decl);\n \n-      Append_To (Decls, E_Decl);\n+      else\n+         Data.E_Id      := Empty;\n+      end if;\n \n       --  Generate:\n       --    Raised_Id : Boolean := False;\n@@ -3067,12 +3106,15 @@ package body Exp_Ch7 is\n      (Data : Finalization_Exception_Data) return Node_Id\n    is\n       Stmt : Node_Id;\n+      Expr : Node_Id;\n \n    begin\n       --  Standard run-time and .NET/JVM targets use the specialized routine\n       --  Raise_From_Controlled_Operation.\n \n-      if RTE_Available (RE_Raise_From_Controlled_Operation) then\n+      if Exception_Extra_Info\n+        and then RTE_Available (RE_Raise_From_Controlled_Operation)\n+      then\n          Stmt :=\n            Make_Procedure_Call_Statement (Data.Loc,\n               Name                   =>\n@@ -3091,6 +3133,21 @@ package body Exp_Ch7 is\n              Reason => PE_Finalize_Raised_Exception);\n       end if;\n \n+      --  Generate:\n+      --    Raised_Id and then not Abort_Id\n+      --      <or>\n+      --    Raised_Id\n+\n+      Expr := New_Reference_To (Data.Raised_Id, Data.Loc);\n+\n+      if Present (Data.Abort_Id) then\n+         Expr := Make_And_Then (Data.Loc,\n+           Left_Opnd  => Expr,\n+           Right_Opnd =>\n+             Make_Op_Not (Data.Loc,\n+               Right_Opnd => New_Reference_To (Data.Abort_Id, Data.Loc)));\n+      end if;\n+\n       --  Generate:\n       --    if Raised_Id and then not Abort_Id then\n       --       Raise_From_Controlled_Operation (E_Id);\n@@ -3100,13 +3157,7 @@ package body Exp_Ch7 is\n \n       return\n         Make_If_Statement (Data.Loc,\n-          Condition       =>\n-            Make_And_Then (Data.Loc,\n-              Left_Opnd  => New_Reference_To (Data.Raised_Id, Data.Loc),\n-              Right_Opnd =>\n-                Make_Op_Not (Data.Loc,\n-                  Right_Opnd => New_Reference_To (Data.Abort_Id, Data.Loc))),\n-\n+          Condition       => Expr,\n           Then_Statements => New_List (Stmt));\n    end Build_Raise_Statement;\n "}, {"sha": "1da838eba4f7d096dc5166cdcbe71980b6881bfe", "filename": "gcc/ada/s-soflin.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23adb371935682f1883c9afbff4086d73c8deb97/gcc%2Fada%2Fs-soflin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23adb371935682f1883c9afbff4086d73c8deb97/gcc%2Fada%2Fs-soflin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-soflin.adb?ref=23adb371935682f1883c9afbff4086d73c8deb97", "patch": "@@ -224,10 +224,13 @@ package body System.Soft_Links is\n    -----------------------------\n \n    procedure Save_Library_Occurrence (E : EOA) is\n+      use Ada.Exceptions;\n    begin\n       if not Library_Exception_Set then\n          Library_Exception_Set := True;\n-         Ada.Exceptions.Save_Occurrence (Library_Exception, E.all);\n+         if E /= null then\n+            Ada.Exceptions.Save_Occurrence (Library_Exception, E.all);\n+         end if;\n       end if;\n    end Save_Library_Occurrence;\n "}]}