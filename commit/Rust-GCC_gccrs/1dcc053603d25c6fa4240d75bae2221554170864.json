{"sha": "1dcc053603d25c6fa4240d75bae2221554170864", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWRjYzA1MzYwM2QyNWM2ZmE0MjQwZDc1YmFlMjIyMTU1NDE3MDg2NA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-05-19T23:35:34Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-05-19T23:35:34Z"}, "message": "BufferedWriter.java: Merged with Classpath.\n\n\t* java/io/BufferedWriter.java: Merged with Classpath.\n\t* java/io/BufferedOutputStream.java: Merged with Classpath.\n\nFrom-SVN: r34041", "tree": {"sha": "5e6ac6f16cce7cd5f73b4e17c92a9fdb2a931f0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e6ac6f16cce7cd5f73b4e17c92a9fdb2a931f0e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1dcc053603d25c6fa4240d75bae2221554170864", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dcc053603d25c6fa4240d75bae2221554170864", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1dcc053603d25c6fa4240d75bae2221554170864", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dcc053603d25c6fa4240d75bae2221554170864/comments", "author": null, "committer": null, "parents": [{"sha": "a55583e90977b5445ab295de13f82010f2e1bf82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a55583e90977b5445ab295de13f82010f2e1bf82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a55583e90977b5445ab295de13f82010f2e1bf82"}], "stats": {"total": 397, "additions": 320, "deletions": 77}, "files": [{"sha": "7ff63e227e82e13681ca15791128787c8a66e715", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dcc053603d25c6fa4240d75bae2221554170864/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dcc053603d25c6fa4240d75bae2221554170864/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=1dcc053603d25c6fa4240d75bae2221554170864", "patch": "@@ -1,3 +1,8 @@\n+2000-05-19  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* java/io/BufferedWriter.java: Merged with Classpath.\n+\t* java/io/BufferedOutputStream.java: Merged with Classpath.\n+\n 2000-05-16  Andrew Haley  <aph@cygnus.com>\n \n \t* sysdep/ia64.c (ia64_backtrace_helper): Pass NULL pointer to"}, {"sha": "09e0db822d058f05f2b269ec496f3b739ed2f86b", "filename": "libjava/java/io/BufferedOutputStream.java", "status": "modified", "additions": 209, "deletions": 66, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dcc053603d25c6fa4240d75bae2221554170864/libjava%2Fjava%2Fio%2FBufferedOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dcc053603d25c6fa4240d75bae2221554170864/libjava%2Fjava%2Fio%2FBufferedOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FBufferedOutputStream.java?ref=1dcc053603d25c6fa4240d75bae2221554170864", "patch": "@@ -1,79 +1,222 @@\n-// BufferedOutputStream.java - A buffered stream\n+/* BufferedOutputStream.java -- Buffer output into large blocks before writing\n+   Copyright (C) 1998, 2000 Free Software Foundation, Inc.\n \n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+This file is part of GNU Classpath.\n \n-   This file is part of libgcj.\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.io;\n \n /**\n- * @author Tom Tromey <tromey@cygnus.com>\n- * @date September 24, 1998 \n+  * This class accumulates bytes written in a buffer instead of immediately\n+  * writing the data to the underlying output sink. The bytes are instead\n+  * as one large block when the buffer is filled, or when the stream is\n+  * closed or explicitly flushed. This mode operation can provide a more\n+  * efficient mechanism for writing versus doing numerous small unbuffered\n+  * writes.\n+  *\n+  * @version 0.0\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public class BufferedOutputStream extends FilterOutputStream\n+{\n+\n+/*************************************************************************/\n+\n+/*\n+ * Class Variables\n  */\n \n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * Status:  Complete to version 1.1.\n+/**\n+  * This is the default buffer size\n+  */\n+private static final int DEFAULT_BUFFER_SIZE = 512;\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Variables\n  */\n \n-public class BufferedOutputStream extends FilterOutputStream\n+/**\n+  * This is the internal byte array used for buffering output before\n+  * writing it.\n+  */\n+protected byte[] buf;\n+\n+/**\n+  * This is the number of bytes that are currently in the buffer and\n+  * are waiting to be written to the underlying stream.  It always points to\n+  * the index into the buffer where the next byte of data will be stored\n+  */\n+protected int count;\n+\n+/*************************************************************************/\n+\n+/*\n+ * Constructors\n+ */\n+\n+/**\n+  * This method initializes a new <code>BufferedOutputStream</code> instance\n+  * that will write to the specified subordinate <code>OutputStream</code>\n+  * and which will use a default buffer size of 512 bytes.\n+  *\n+  * @param out The underlying <code>OutputStream</code> to write data to\n+  */\n+public\n+BufferedOutputStream(OutputStream out)\n+{\n+  this(out, DEFAULT_BUFFER_SIZE);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method initializes a new <code>BufferedOutputStream</code> instance\n+  * that will write to the specified subordinate <code>OutputStream</code>\n+  * and which will use the specified buffer size\n+  *\n+  * @param out The underlying <code>OutputStream</code> to write data to\n+  * @param size The size of the internal buffer\n+  */\n+public\n+BufferedOutputStream(OutputStream out, int size)\n+{\n+  super(out);\n+\n+  buf = new byte[size];\n+}\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Methods\n+ */\n+\n+/**\n+  * This method causes any currently buffered bytes to be immediately\n+  * written to the underlying output stream.\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public synchronized void\n+flush() throws IOException\n+{\n+  if (count == 0)\n+    return;\n+\n+  out.write(buf, 0, count);\n+  count = 0;\n+}\n+\n+/*************************************************************************/\n+\n+/*\n+  * This method flushes any remaining buffered bytes then closes the \n+  * underlying output stream.  Any further attempts to write to this stream\n+  * may throw an exception\n+  *\n+public synchronized void\n+close() throws IOException\n+{\n+  flush();\n+  out.close();\n+}\n+*/\n+\n+/*************************************************************************/\n+\n+/*\n+  * This method runs when the object is garbage collected.  It is \n+  * responsible for ensuring that all buffered bytes are written and\n+  * for closing the underlying stream.\n+  *\n+  * @exception IOException If an error occurs (ignored by the Java runtime)\n+  *\n+protected void\n+finalize() throws IOException\n {\n-  public BufferedOutputStream (OutputStream ox)\n-  {\n-    this (ox, 512);\n-  }\n-\n-  public BufferedOutputStream (OutputStream ox, int size)\n-  {\n-    super (ox);\n-    buf = new byte[size];\n-  }\n-\n-  public synchronized void flush () throws IOException\n-  {\n-    out.write(buf, 0, count);\n-    count = 0;\n-    out.flush();\n-  }\n-\n-  public synchronized void write (int b) throws IOException\n-  {\n-    // Flush output on overflow though JDK (1.2) doc may infer to flush on fill.\n-    if (count < buf.length)\n-      buf[count++] = (byte) b;\n-    else\n-      {\n-\tout.write(buf, 0, count);\n-\tcount = 0;\n-\tout.write(b);\n-      }\n-  }\n-\n-  public synchronized void write (byte[] b, int off, int len)\n-    throws IOException, NullPointerException, IndexOutOfBoundsException\n-  {\n-    // Flush output on overflow though JDK (1.2) doc may infer to flush on fill.\n-\n-    // If LEN < 0 then the downstream write will fail for us.\n-    if (len >= 0 && count + len <= buf.length)\n-      {\n-\tSystem.arraycopy(b, off, buf, count, len);\n-\tcount += len;\n-      }\n-    else\n-      {\n-\tout.write(buf, 0, count);\n-\tcount = 0;\n-\tout.write(b, off, len);\n-      }\n-  }\n-\n-  // The buffer.\n-  protected byte[] buf;\n-  // Number of valid bytes in BUF.\n-  protected int count;\n+  close();\n+}\n+*/\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method writes a single byte of data.  This will be written to the\n+  * buffer instead of the underlying data source.  However, if the buffer\n+  * is filled as a result of this write request, it will be flushed to the\n+  * underlying output stream.\n+  *\n+  * @param b The byte of data to be written, passed as an int\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public synchronized void\n+write(int b) throws IOException\n+{\n+  buf[count] = (byte)(b & 0xFF);\n+\n+  ++count;\n+  if (count == buf.length)\n+    flush();\n }\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method writes <code>len</code> bytes from the byte array \n+  * <code>buf</code> starting at position <code>offset</code> in the buffer. \n+  * These bytes will be written to the internal buffer.  However, if this\n+  * write operation fills the buffer, the buffer will be flushed to the\n+  * underlying output stream.\n+  *\n+  * @param buf The array of bytes to write.\n+  * @param offset The index into the byte array to start writing from.\n+  * @param len The number of bytes to write.\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public synchronized void\n+write(byte[] buf, int offset, int len) throws IOException\n+{\n+  // Buffer can hold everything.  Note that the case where LEN < 0\n+  // is automatically handled by the downstream write.\n+  if (len < (this.buf.length - count))\n+    {\n+      System.arraycopy(buf, offset, this.buf, count, len);\n+      count += len;\n+    }\n+  else\n+    {\n+      // The write was too big.  So flush the buffer and write the new\n+      // bytes directly to the underlying stream, per the JDK 1.2\n+      // docs.\n+      flush();\n+      out.write (buf, offset, len);\n+    }\n+}\n+\n+} // class BufferedOutputStream "}, {"sha": "f31dc28a0d21cd3fdb0457716a695240e21791c1", "filename": "libjava/java/io/BufferedWriter.java", "status": "modified", "additions": 106, "deletions": 11, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dcc053603d25c6fa4240d75bae2221554170864/libjava%2Fjava%2Fio%2FBufferedWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dcc053603d25c6fa4240d75bae2221554170864/libjava%2Fjava%2Fio%2FBufferedWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FBufferedWriter.java?ref=1dcc053603d25c6fa4240d75bae2221554170864", "patch": "@@ -1,6 +1,6 @@\n // BufferedWriter.java - Filtered character output stream.\n \n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -10,24 +10,48 @@\n \n package java.io;\n \n-/**\n- * @author Tom Tromey <tromey@cygnus.com>\n- * @date September 25, 1998 \n- */\n-\n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n  * \"The Java Language Specification\", ISBN 0-201-63451-1\n  * Status:  Complete to version 1.1.\n  */\n \n-// Why not extend FilterWriter?\n+/**\n+  * This class accumulates chars written in a buffer instead of immediately\n+  * writing the data to the underlying output sink. The chars are instead\n+  * as one large block when the buffer is filled, or when the stream is\n+  * closed or explicitly flushed. This mode operation can provide a more\n+  * efficient mechanism for writing versus doing numerous small unbuffered\n+  * writes.\n+  *\n+  * @version 0.0\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  * @author Tom Tromey <tromey@cygnus.com>\n+  * @date September 25, 1998 \n+  */\n+\n public class BufferedWriter extends Writer\n {\n+  /**\n+   * This method initializes a new <code>BufferedWriter</code> instance\n+   * that will write to the specified subordinate <code>Writer</code>\n+   * and which will use a default buffer size of 512 chars.\n+   *\n+   * @param out The underlying <code>Writer</code> to write data to\n+   */\n   public BufferedWriter (Writer out)\n   {\n-    this (out, 8192);\n+    this (out, DEFAULT_BUFFER_SIZE);\n   }\n \n+  /**\n+   * This method initializes a new <code>BufferedWriter</code> instance\n+   * that will write to the specified subordinate <code>Writer</code>\n+   * and which will use the specified buffer size\n+   *\n+   * @param out The underlying <code>Writer</code> to write data to\n+   * @param size The size of the internal buffer\n+   */\n   public BufferedWriter (Writer ox, int size)\n   {\n     super (ox);\n@@ -36,23 +60,51 @@ public BufferedWriter (Writer ox, int size)\n     count = 0;\n   }\n \n+  /**\n+   * This method flushes any remaining buffered chars then closes the \n+   * underlying output stream.  Any further attempts to write to this stream\n+   * may throw an exception\n+   */\n   public void close () throws IOException\n   {\n     localFlush ();\n     out.close();\n   }\n \n+  /**\n+   * This method causes any currently buffered chars to be immediately\n+   * written to the underlying output stream.\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public void flush () throws IOException\n   {\n     localFlush ();\n     out.flush();\n   }\n \n+  /**\n+   * This method writes out a system depedent line separator sequence.  The\n+   * actual value written is detemined from the <xmp>line.separator</xmp>\n+   * system property.\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public void newLine () throws IOException\n   {\n     write (System.getProperty(\"line.separator\"));\n   }\n \n+  /**\n+   * This method writes a single char of data.  This will be written to the\n+   * buffer instead of the underlying data source.  However, if the buffer\n+   * is filled as a result of this write request, it will be flushed to the\n+   * underlying output stream.\n+   *\n+   * @param b The char of data to be written, passed as an int\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public void write (int oneChar) throws IOException\n   {\n     synchronized (lock)\n@@ -63,6 +115,19 @@ public void write (int oneChar) throws IOException\n       }\n   }\n \n+  /**\n+   * This method writes <code>len</code> chars from the char array \n+   * <code>buf</code> starting at position <code>offset</code> in the buffer. \n+   * These chars will be written to the internal buffer.  However, if this\n+   * write operation fills the buffer, the buffer will be flushed to the\n+   * underlying output stream.\n+   *\n+   * @param buf The array of chars to write.\n+   * @param offset The index into the char array to start writing from.\n+   * @param len The number of chars to write.\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public void write (char[] buf, int offset, int len) throws IOException\n   {\n     if (offset < 0 || len < 0 || offset + len > buf.length)\n@@ -86,6 +151,19 @@ public void write (char[] buf, int offset, int len) throws IOException\n       }\n   }\n \n+  /**\n+   * This method writes <code>len</code> chars from the <code>String</code>\n+   * <code>str</code> starting at position <code>offset</code> in the string. \n+   * These chars will be written to the internal buffer.  However, if this\n+   * write operation fills the buffer, the buffer will be flushed to the\n+   * underlying output stream.\n+   *\n+   * @param str The <code>String</code> to write.\n+   * @param offset The index into the string to start writing from.\n+   * @param len The number of chars to write.\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public void write (String str, int offset, int len) throws IOException\n   {\n     if (offset < 0 || len < 0 || offset + len < str.length())\n@@ -120,10 +198,27 @@ private final void localFlush () throws IOException\n       }\n   }\n \n-  // The downstream writer.\n+  /**\n+   * This is the underlying <code>Writer</code> to which this object\n+   * sends its output.\n+   */\n   private Writer out;\n-  // The character buffer.\n+\n+  /**\n+   * This is the internal char array used for buffering output before\n+   * writing it.\n+   */\n   char[] buffer;\n-  // Number of valid chars in buffer.\n+\n+  /**\n+   * This is the number of chars that are currently in the buffer and\n+   * are waiting to be written to the underlying stream.  It always points to\n+   * the index into the buffer where the next char of data will be stored\n+   */\n   int count;\n+\n+  /**\n+   * This is the default buffer size\n+   */\n+  private static final int DEFAULT_BUFFER_SIZE = 8192;\n }"}]}