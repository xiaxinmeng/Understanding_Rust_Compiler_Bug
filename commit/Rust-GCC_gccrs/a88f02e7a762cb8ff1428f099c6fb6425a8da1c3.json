{"sha": "a88f02e7a762cb8ff1428f099c6fb6425a8da1c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTg4ZjAyZTdhNzYyY2I4ZmYxNDI4ZjA5OWM2ZmI2NDI1YThkYTFjMw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.co.uk", "date": "2000-12-02T10:47:42Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2000-12-02T10:47:42Z"}, "message": "Haifa cleanup, part 1\n\nFrom-SVN: r37949", "tree": {"sha": "c6bf401420885fa60b8efc052dbc52d3ea5af8d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6bf401420885fa60b8efc052dbc52d3ea5af8d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a88f02e7a762cb8ff1428f099c6fb6425a8da1c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a88f02e7a762cb8ff1428f099c6fb6425a8da1c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a88f02e7a762cb8ff1428f099c6fb6425a8da1c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a88f02e7a762cb8ff1428f099c6fb6425a8da1c3/comments", "author": null, "committer": null, "parents": [{"sha": "692344cfed8b78fc1e636b77145ed12a03400e01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/692344cfed8b78fc1e636b77145ed12a03400e01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/692344cfed8b78fc1e636b77145ed12a03400e01"}], "stats": {"total": 488, "additions": 284, "deletions": 204}, "files": [{"sha": "deeb1c4220b051a2e335c0a046404c0936ba898a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a88f02e7a762cb8ff1428f099c6fb6425a8da1c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a88f02e7a762cb8ff1428f099c6fb6425a8da1c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a88f02e7a762cb8ff1428f099c6fb6425a8da1c3", "patch": "@@ -1,3 +1,14 @@\n+2000-12-02  Bernd Schmidt  <bernds@redhat.co.uk>\n+\n+\t* haifa-sched.c (sched_dump): Renamed from dump.  All users changed.\n+\t(old_max_uid): New variable.\n+\t(compute_forward_dependences): Renamed from\n+\tcompute_block_forward_dependences; changed to accept block head and\n+\ttail instead of block number.  Caller changed.\n+\t(free_deps, init_dependency_caches, free_dependency_caches,\n+\tinit_regions, sched_init): New functions, split out from\n+\tschedule_insns and compute_block_backward_dependences.\n+\n 2000-12-02  Neil Booth  <neilb@earthling.net>\n \n         * cppexp.c (parse_number): Update diagnostic test."}, {"sha": "4a1230a15cb446d50510fcfefb179eadb5e87e98", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 273, "deletions": 204, "changes": 477, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a88f02e7a762cb8ff1428f099c6fb6425a8da1c3/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a88f02e7a762cb8ff1428f099c6fb6425a8da1c3/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=a88f02e7a762cb8ff1428f099c6fb6425a8da1c3", "patch": "@@ -215,7 +215,10 @@ static int nr_inter, nr_spec;\n \n /* Debugging file.  All printouts are sent to dump, which is always set,\n    either to stderr, or to the dump listing file (-dRS).  */\n-static FILE *dump = 0;\n+static FILE *sched_dump = 0;\n+\n+/* Highest uid before scheduling.  */\n+static int old_max_uid;\n \n /* fix_sched_param() is called from toplev.c upon detection\n    of the -fsched-verbose=N option.  */\n@@ -749,7 +752,7 @@ static int is_prisky PARAMS ((rtx, int, int));\n static int is_exception_free PARAMS ((rtx, int, int));\n \n static char find_insn_mem_list PARAMS ((rtx, rtx, rtx, rtx));\n-static void compute_block_forward_dependences PARAMS ((int));\n+static void compute_forward_dependences PARAMS ((rtx, rtx));\n static void add_branch_dependences PARAMS ((rtx, rtx));\n static void compute_block_backward_dependences PARAMS ((int));\n void debug_dependencies PARAMS ((void));\n@@ -816,6 +819,11 @@ static rtx move_insn PARAMS ((rtx, rtx));\n static rtx group_leader PARAMS ((rtx));\n static int set_priorities PARAMS ((int));\n static void init_deps PARAMS ((struct deps *));\n+static void free_deps PARAMS ((struct deps *));\n+static void init_dependency_caches PARAMS ((int));\n+static void free_dependency_caches PARAMS ((void));\n+static void init_regions PARAMS ((void));\n+static void sched_init PARAMS ((FILE *));\n static void schedule_region PARAMS ((int));\n static void propagate_deps PARAMS ((int, struct deps *, int));\n \n@@ -1074,6 +1082,53 @@ set_sched_group_p (insn)\n   for (link = LOG_LINKS (prev); link; link = XEXP (link, 1))\n     add_dependence (insn, XEXP (link, 0), REG_NOTE_KIND (link));\n }\n+\n+/* If it is profitable to use them, initialize caches for tracking\n+   dependency informatino.  LUID is the number of insns to be scheduled,\n+   it is used in the estimate of profitability.  */\n+static void\n+init_dependency_caches (luid)\n+     int luid;\n+{\n+  /* ?!? We could save some memory by computing a per-region luid mapping\n+     which could reduce both the number of vectors in the cache and the size\n+     of each vector.  Instead we just avoid the cache entirely unless the\n+     average number of instructions in a basic block is very high.  See\n+     the comment before the declaration of true_dependency_cache for\n+     what we consider \"very high\".  */\n+  if (luid / n_basic_blocks > 100 * 5)\n+    {\n+      true_dependency_cache = sbitmap_vector_alloc (luid, luid);\n+      sbitmap_vector_zero (true_dependency_cache, luid);\n+      anti_dependency_cache = sbitmap_vector_alloc (luid, luid);\n+      sbitmap_vector_zero (anti_dependency_cache, luid);\n+      output_dependency_cache = sbitmap_vector_alloc (luid, luid);\n+      sbitmap_vector_zero (output_dependency_cache, luid);\n+#ifdef ENABLE_CHECKING\n+      forward_dependency_cache = sbitmap_vector_alloc (luid, luid);\n+      sbitmap_vector_zero (forward_dependency_cache, luid);\n+#endif\n+    }\n+}\n+\n+/* Free the caches allocated in init_dependency_caches.  */\n+static void\n+free_dependency_caches ()\n+{\n+  if (true_dependency_cache)\n+    {\n+      free (true_dependency_cache);\n+      true_dependency_cache = NULL;\n+      free (anti_dependency_cache);\n+      anti_dependency_cache = NULL;\n+      free (output_dependency_cache);\n+      output_dependency_cache = NULL;\n+#ifdef ENABLE_CHECKING\n+      free (forward_dependency_cache);\n+      forward_dependency_cache = NULL;\n+#endif\n+    }\n+}\n \f\n #ifndef INSN_SCHEDULING\n void\n@@ -1391,12 +1446,12 @@ debug_regions ()\n {\n   int rgn, bb;\n \n-  fprintf (dump, \"\\n;;   ------------ REGIONS ----------\\n\\n\");\n+  fprintf (sched_dump, \"\\n;;   ------------ REGIONS ----------\\n\\n\");\n   for (rgn = 0; rgn < nr_regions; rgn++)\n     {\n-      fprintf (dump, \";;\\trgn %d nr_blocks %d:\\n\", rgn,\n+      fprintf (sched_dump, \";;\\trgn %d nr_blocks %d:\\n\", rgn,\n \t       rgn_table[rgn].rgn_nr_blocks);\n-      fprintf (dump, \";;\\tbb/block: \");\n+      fprintf (sched_dump, \";;\\tbb/block: \");\n \n       for (bb = 0; bb < rgn_table[rgn].rgn_nr_blocks; bb++)\n \t{\n@@ -1405,10 +1460,10 @@ debug_regions ()\n \t  if (bb != BLOCK_TO_BB (BB_TO_BLOCK (bb)))\n \t    abort ();\n \n-\t  fprintf (dump, \" %d/%d \", bb, BB_TO_BLOCK (bb));\n+\t  fprintf (sched_dump, \" %d/%d \", bb, BB_TO_BLOCK (bb));\n \t}\n \n-      fprintf (dump, \"\\n\\n\");\n+      fprintf (sched_dump, \"\\n\\n\");\n     }\n }\n \n@@ -1992,7 +2047,7 @@ compute_dom_prob_ps (bb)\n   BITSET_DIFFER (pot_split[bb], ancestor_edges[bb], edgeset_size);\n \n   if (sched_verbose >= 2)\n-    fprintf (dump, \";;  bb_prob(%d, %d) = %3d\\n\", bb, BB_TO_BLOCK (bb),\n+    fprintf (sched_dump, \";;  bb_prob(%d, %d) = %3d\\n\", bb, BB_TO_BLOCK (bb),\n \t     (int) (100.0 * prob[bb]));\n }\n \n@@ -2130,29 +2185,29 @@ debug_candidate (i)\n   if (candidate_table[i].is_speculative)\n     {\n       int j;\n-      fprintf (dump, \"src b %d bb %d speculative \\n\", BB_TO_BLOCK (i), i);\n+      fprintf (sched_dump, \"src b %d bb %d speculative \\n\", BB_TO_BLOCK (i), i);\n \n-      fprintf (dump, \"split path: \");\n+      fprintf (sched_dump, \"split path: \");\n       for (j = 0; j < candidate_table[i].split_bbs.nr_members; j++)\n \t{\n \t  int b = candidate_table[i].split_bbs.first_member[j];\n \n-\t  fprintf (dump, \" %d \", b);\n+\t  fprintf (sched_dump, \" %d \", b);\n \t}\n-      fprintf (dump, \"\\n\");\n+      fprintf (sched_dump, \"\\n\");\n \n-      fprintf (dump, \"update path: \");\n+      fprintf (sched_dump, \"update path: \");\n       for (j = 0; j < candidate_table[i].update_bbs.nr_members; j++)\n \t{\n \t  int b = candidate_table[i].update_bbs.first_member[j];\n \n-\t  fprintf (dump, \" %d \", b);\n+\t  fprintf (sched_dump, \" %d \", b);\n \t}\n-      fprintf (dump, \"\\n\");\n+      fprintf (sched_dump, \"\\n\");\n     }\n   else\n     {\n-      fprintf (dump, \" src %d equivalent\\n\", BB_TO_BLOCK (i));\n+      fprintf (sched_dump, \" src %d equivalent\\n\", BB_TO_BLOCK (i));\n     }\n }\n \n@@ -2164,7 +2219,7 @@ debug_candidates (trg)\n {\n   int i;\n \n-  fprintf (dump, \"----------- candidate table: target: b=%d bb=%d ---\\n\",\n+  fprintf (sched_dump, \"----------- candidate table: target: b=%d bb=%d ---\\n\",\n \t   BB_TO_BLOCK (trg), trg);\n   for (i = trg + 1; i < current_nr_blocks; i++)\n     debug_candidate (i);\n@@ -4229,12 +4284,12 @@ queue_insn (insn, n_cycles)\n \n   if (sched_verbose >= 2)\n     {\n-      fprintf (dump, \";;\\t\\tReady-->Q: insn %d: \", INSN_UID (insn));\n+      fprintf (sched_dump, \";;\\t\\tReady-->Q: insn %d: \", INSN_UID (insn));\n \n       if (INSN_BB (insn) != target_bb)\n-\tfprintf (dump, \"(b%d) \", BLOCK_NUM (insn));\n+\tfprintf (sched_dump, \"(b%d) \", BLOCK_NUM (insn));\n \n-      fprintf (dump, \"queued for %d cycles.\\n\", n_cycles);\n+      fprintf (sched_dump, \"queued for %d cycles.\\n\", n_cycles);\n     }\n }\n \n@@ -4339,10 +4394,10 @@ schedule_insn (insn, ready, clock)\n \n   if (sched_verbose >= 2)\n     {\n-      fprintf (dump, \";;\\t\\t--> scheduling insn <<<%d>>> on unit \",\n+      fprintf (sched_dump, \";;\\t\\t--> scheduling insn <<<%d>>> on unit \",\n \t       INSN_UID (insn));\n       insn_print_units (insn);\n-      fprintf (dump, \"\\n\");\n+      fprintf (sched_dump, \"\\n\");\n     }\n \n   if (sched_verbose && unit == -1)\n@@ -4378,16 +4433,16 @@ schedule_insn (insn, ready, clock)\n \n \t  if (sched_verbose >= 2)\n \t    {\n-\t      fprintf (dump, \";;\\t\\tdependences resolved: insn %d \",\n+\t      fprintf (sched_dump, \";;\\t\\tdependences resolved: insn %d \",\n \t\t       INSN_UID (next));\n \n \t      if (current_nr_blocks > 1 && INSN_BB (next) != target_bb)\n-\t\tfprintf (dump, \"/b%d \", BLOCK_NUM (next));\n+\t\tfprintf (sched_dump, \"/b%d \", BLOCK_NUM (next));\n \n \t      if (effective_cost < 1)\n-\t\tfprintf (dump, \"into ready\\n\");\n+\t\tfprintf (sched_dump, \"into ready\\n\");\n \t      else\n-\t\tfprintf (dump, \"into queue with cost=%d\\n\", effective_cost);\n+\t\tfprintf (sched_dump, \"into queue with cost=%d\\n\", effective_cost);\n \t    }\n \n \t  /* Adjust the priority of NEXT and either put it on the ready\n@@ -4660,7 +4715,7 @@ restore_line_notes (bb)\n \t  }\n       }\n   if (sched_verbose && added_notes)\n-    fprintf (dump, \";; added %d line-number notes\\n\", added_notes);\n+    fprintf (sched_dump, \";; added %d line-number notes\\n\", added_notes);\n }\n \n /* After scheduling the function, delete redundant line notes from the\n@@ -4709,7 +4764,7 @@ rm_redundant_line_notes ()\n       active_insn++;\n \n   if (sched_verbose && notes)\n-    fprintf (dump, \";; deleted %d line-number notes\\n\", notes);\n+    fprintf (sched_dump, \";; deleted %d line-number notes\\n\", notes);\n }\n \n /* Delete notes between head and tail and put them in the chain\n@@ -4823,14 +4878,14 @@ queue_to_ready (ready)\n       q_size -= 1;\n \n       if (sched_verbose >= 2)\n-\tfprintf (dump, \";;\\t\\tQ-->Ready: insn %d: \", INSN_UID (insn));\n+\tfprintf (sched_dump, \";;\\t\\tQ-->Ready: insn %d: \", INSN_UID (insn));\n \n       if (sched_verbose >= 2 && INSN_BB (insn) != target_bb)\n-\tfprintf (dump, \"(b%d) \", BLOCK_NUM (insn));\n+\tfprintf (sched_dump, \"(b%d) \", BLOCK_NUM (insn));\n \n       ready_add (ready, insn);\n       if (sched_verbose >= 2)\n-\tfprintf (dump, \"moving to ready without stalls\\n\");\n+\tfprintf (sched_dump, \"moving to ready without stalls\\n\");\n     }\n   insn_queue[q_ptr] = 0;\n \n@@ -4850,15 +4905,15 @@ queue_to_ready (ready)\n \t\t  q_size -= 1;\n \n \t\t  if (sched_verbose >= 2)\n-\t\t    fprintf (dump, \";;\\t\\tQ-->Ready: insn %d: \",\n+\t\t    fprintf (sched_dump, \";;\\t\\tQ-->Ready: insn %d: \",\n \t\t\t     INSN_UID (insn));\n \n \t\t  if (sched_verbose >= 2 && INSN_BB (insn) != target_bb)\n-\t\t    fprintf (dump, \"(b%d) \", BLOCK_NUM (insn));\n+\t\t    fprintf (sched_dump, \"(b%d) \", BLOCK_NUM (insn));\n \n \t\t  ready_add (ready, insn);\n \t\t  if (sched_verbose >= 2)\n-\t\t    fprintf (dump, \"moving to ready with %d stalls\\n\", stalls);\n+\t\t    fprintf (sched_dump, \"moving to ready with %d stalls\\n\", stalls);\n \t\t}\n \t      insn_queue[NEXT_Q_AFTER (q_ptr, stalls)] = 0;\n \n@@ -4889,11 +4944,11 @@ debug_ready_list (ready)\n   p = ready_lastpos (ready);\n   for (i = 0; i < ready->n_ready; i++)\n     {\n-      fprintf (dump, \"  %d\", INSN_UID (p[i]));\n+      fprintf (sched_dump, \"  %d\", INSN_UID (p[i]));\n       if (current_nr_blocks > 1 && INSN_BB (p[i]) != target_bb)\n-\tfprintf (dump, \"/b%d\", BLOCK_NUM (p[i]));\n+\tfprintf (sched_dump, \"/b%d\", BLOCK_NUM (p[i]));\n     }\n-  fprintf (dump, \"\\n\");\n+  fprintf (sched_dump, \"\\n\");\n }\n \n /* Print names of units on which insn can/should execute, for debugging.  */\n@@ -4906,20 +4961,20 @@ insn_print_units (insn)\n   int unit = insn_unit (insn);\n \n   if (unit == -1)\n-    fprintf (dump, \"none\");\n+    fprintf (sched_dump, \"none\");\n   else if (unit >= 0)\n-    fprintf (dump, \"%s\", function_units[unit].name);\n+    fprintf (sched_dump, \"%s\", function_units[unit].name);\n   else\n     {\n-      fprintf (dump, \"[\");\n+      fprintf (sched_dump, \"[\");\n       for (i = 0, unit = ~unit; unit; i++, unit >>= 1)\n \tif (unit & 1)\n \t  {\n-\t    fprintf (dump, \"%s\", function_units[i].name);\n+\t    fprintf (sched_dump, \"%s\", function_units[i].name);\n \t    if (unit != 1)\n-\t      fprintf (dump, \" \");\n+\t      fprintf (sched_dump, \" \");\n \t  }\n-      fprintf (dump, \"]\");\n+      fprintf (sched_dump, \"]\");\n     }\n }\n \n@@ -5663,25 +5718,25 @@ print_block_visualization (b, s)\n   int unit, i;\n \n   /* Print header.  */\n-  fprintf (dump, \"\\n;;   ==================== scheduling visualization for block %d %s \\n\", b, s);\n+  fprintf (sched_dump, \"\\n;;   ==================== scheduling visualization for block %d %s \\n\", b, s);\n \n   /* Print names of units.  */\n-  fprintf (dump, \";;   %-8s\", \"clock\");\n+  fprintf (sched_dump, \";;   %-8s\", \"clock\");\n   for (unit = 0; unit < FUNCTION_UNITS_SIZE; unit++)\n     if (function_units[unit].bitmask & target_units)\n       for (i = 0; i < function_units[unit].multiplicity; i++)\n-\tfprintf (dump, \"  %-33s\", function_units[unit].name);\n-  fprintf (dump, \"  %-8s\\n\", \"no-unit\");\n+\tfprintf (sched_dump, \"  %-33s\", function_units[unit].name);\n+  fprintf (sched_dump, \"  %-8s\\n\", \"no-unit\");\n \n-  fprintf (dump, \";;   %-8s\", \"=====\");\n+  fprintf (sched_dump, \";;   %-8s\", \"=====\");\n   for (unit = 0; unit < FUNCTION_UNITS_SIZE; unit++)\n     if (function_units[unit].bitmask & target_units)\n       for (i = 0; i < function_units[unit].multiplicity; i++)\n-\tfprintf (dump, \"  %-33s\", \"==============================\");\n-  fprintf (dump, \"  %-8s\\n\", \"=======\");\n+\tfprintf (sched_dump, \"  %-33s\", \"==============================\");\n+  fprintf (sched_dump, \"  %-8s\\n\", \"=======\");\n \n   /* Print insns in each cycle.  */\n-  fprintf (dump, \"%s\\n\", visual_tbl);\n+  fprintf (sched_dump, \"%s\\n\", visual_tbl);\n }\n \n /* Print insns in the 'no_unit' column of visualization.  */\n@@ -5976,13 +6031,13 @@ schedule_block (bb, rgn_n_insns)\n   /* Debug info.  */\n   if (sched_verbose)\n     {\n-      fprintf (dump, \";;   ======================================================\\n\");\n-      fprintf (dump,\n+      fprintf (sched_dump, \";;   ======================================================\\n\");\n+      fprintf (sched_dump,\n \t       \";;   -- basic block %d from %d to %d -- %s reload\\n\",\n \t       b, INSN_UID (BLOCK_HEAD (b)), INSN_UID (BLOCK_END (b)),\n \t       (reload_completed ? \"after\" : \"before\"));\n-      fprintf (dump, \";;   ======================================================\\n\");\n-      fprintf (dump, \"\\n\");\n+      fprintf (sched_dump, \";;   ======================================================\\n\");\n+      fprintf (sched_dump, \"\\n\");\n \n       visual_tbl = (char *) alloca (get_visual_tbl_length ());\n       init_block_visualization ();\n@@ -6090,7 +6145,7 @@ schedule_block (bb, rgn_n_insns)\n       }\n \n #ifdef MD_SCHED_INIT\n-  MD_SCHED_INIT (dump, sched_verbose);\n+  MD_SCHED_INIT (sched_dump, sched_verbose);\n #endif\n \n   /* No insns scheduled in this block yet.  */\n@@ -6130,7 +6185,7 @@ schedule_block (bb, rgn_n_insns)\n \n       if (sched_verbose >= 2)\n \t{\n-\t  fprintf (dump, \";;\\t\\tReady list after queue_to_ready:  \");\n+\t  fprintf (sched_dump, \";;\\t\\tReady list after queue_to_ready:  \");\n \t  debug_ready_list (&ready);\n \t}\n \n@@ -6140,15 +6195,15 @@ schedule_block (bb, rgn_n_insns)\n       /* Allow the target to reorder the list, typically for\n \t better instruction bundling.  */\n #ifdef MD_SCHED_REORDER\n-      MD_SCHED_REORDER (dump, sched_verbose, ready_lastpos (&ready),\n+      MD_SCHED_REORDER (sched_dump, sched_verbose, ready_lastpos (&ready),\n \t\t\tready.n_ready, clock_var, can_issue_more);\n #else\n       can_issue_more = issue_rate;\n #endif\n \n       if (sched_verbose)\n \t{\n-\t  fprintf (dump, \"\\n;;\\tReady list (t =%3d):  \", clock_var);\n+\t  fprintf (sched_dump, \"\\n;;\\tReady list (t =%3d):  \", clock_var);\n \t  debug_ready_list (&ready);\n \t}\n \n@@ -6231,7 +6286,7 @@ schedule_block (bb, rgn_n_insns)\n \t  sched_n_insns++;\n \n #ifdef MD_SCHED_VARIABLE_ISSUE\n-\t  MD_SCHED_VARIABLE_ISSUE (dump, sched_verbose, insn,\n+\t  MD_SCHED_VARIABLE_ISSUE (sched_dump, sched_verbose, insn,\n \t\t\t\t   can_issue_more);\n #else\n \t  can_issue_more--;\n@@ -6252,7 +6307,7 @@ schedule_block (bb, rgn_n_insns)\n   /* Debug info.  */\n   if (sched_verbose)\n     {\n-      fprintf (dump, \";;\\tReady list (final):  \");\n+      fprintf (sched_dump, \";;\\tReady list (final):  \");\n       debug_ready_list (&ready);\n       print_block_visualization (b, \"\");\n     }\n@@ -6296,9 +6351,9 @@ schedule_block (bb, rgn_n_insns)\n   /* Debugging.  */\n   if (sched_verbose)\n     {\n-      fprintf (dump, \";;   total time = %d\\n;;   new basic block head = %d\\n\",\n+      fprintf (sched_dump, \";;   total time = %d\\n;;   new basic block head = %d\\n\",\n \t       clock_var, INSN_UID (BLOCK_HEAD (b)));\n-      fprintf (dump, \";;   new basic block end = %d\\n\\n\",\n+      fprintf (sched_dump, \";;   new basic block end = %d\\n\\n\",\n \t       INSN_UID (BLOCK_END (b)));\n     }\n \n@@ -6324,25 +6379,24 @@ debug_reg_vector (s)\n \n   EXECUTE_IF_SET_IN_REG_SET (s, 0, regno,\n \t\t\t     {\n-\t\t\t       fprintf (dump, \" %d\", regno);\n+\t\t\t       fprintf (sched_dump, \" %d\", regno);\n \t\t\t     });\n \n-  fprintf (dump, \"\\n\");\n+  fprintf (sched_dump, \"\\n\");\n }\n \n-/* Use the backward dependences from LOG_LINKS to build\n-   forward dependences in INSN_DEPEND.  */\n+/* Examine insns in the range [ HEAD, TAIL ] and Use the backward\n+   dependences from LOG_LINKS to build forward dependences in\n+   INSN_DEPEND.  */\n \n static void\n-compute_block_forward_dependences (bb)\n-     int bb;\n+compute_forward_dependences (head, tail)\n+     rtx head, tail;\n {\n   rtx insn, link;\n-  rtx tail, head;\n   rtx next_tail;\n   enum reg_note dep_type;\n \n-  get_bb_head_tail (bb, &head, &tail);\n   next_tail = NEXT_INSN (tail);\n   for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n     {\n@@ -6417,6 +6471,31 @@ init_deps (deps)\n   LOG_LINKS (deps->sched_before_next_call) = 0;\n }\n \n+/* Free insn lists found in DEPS.  */\n+\n+static void\n+free_deps (deps)\n+     struct deps *deps;\n+{\n+  int max_reg = max_reg_num ();\n+  int i;\n+\n+  /* Note this loop is executed max_reg * nr_regions times.  It's first\n+     implementation accounted for over 90% of the calls to free_INSN_LIST_list.\n+     The list was empty for the vast majority of those calls.  On the PA, not\n+     calling free_INSN_LIST_list in those cases improves -O2 compile times by\n+     3-5% on average.  */\n+  for (i = 0; i < max_reg; ++i)\n+    {\n+      if (deps->reg_last_clobbers[i])\n+\tfree_INSN_LIST_list (&deps->reg_last_clobbers[i]);\n+      if (deps->reg_last_sets[i])\n+\tfree_INSN_LIST_list (&deps->reg_last_sets[i]);\n+      if (deps->reg_last_uses[i])\n+\tfree_INSN_LIST_list (&deps->reg_last_uses[i]);\n+    }\n+}\n+\n /* Add dependences so that branches are scheduled to run last in their\n    block.  */\n \n@@ -6668,7 +6747,6 @@ static void\n compute_block_backward_dependences (bb)\n      int bb;\n {\n-  int i;\n   rtx head, tail;\n   int max_reg = max_reg_num ();\n   struct deps tmp_deps;\n@@ -6683,22 +6761,8 @@ compute_block_backward_dependences (bb)\n   if (current_nr_blocks > 1)\n     propagate_deps (bb, &tmp_deps, max_reg);\n \n-  /* Free up the INSN_LISTs.\n-\n-     Note this loop is executed max_reg * nr_regions times.  It's first\n-     implementation accounted for over 90% of the calls to free_INSN_LIST_list.\n-     The list was empty for the vast majority of those calls.  On the PA, not\n-     calling free_INSN_LIST_list in those cases improves -O2 compile times by\n-     3-5% on average.  */\n-  for (i = 0; i < max_reg; ++i)\n-    {\n-      if (tmp_deps.reg_last_clobbers[i])\n-\tfree_INSN_LIST_list (&tmp_deps.reg_last_clobbers[i]);\n-      if (tmp_deps.reg_last_sets[i])\n-\tfree_INSN_LIST_list (&tmp_deps.reg_last_sets[i]);\n-      if (tmp_deps.reg_last_uses[i])\n-\tfree_INSN_LIST_list (&tmp_deps.reg_last_uses[i]);\n-    }\n+  /* Free up the INSN_LISTs.  */\n+  free_deps (&tmp_deps);\n \n   /* Assert that we won't need bb_reg_last_* for this block anymore.  */\n   free (bb_deps[bb].reg_last_uses);\n@@ -6716,7 +6780,7 @@ debug_dependencies ()\n {\n   int bb;\n \n-  fprintf (dump, \";;   --------------- forward dependences: ------------ \\n\");\n+  fprintf (sched_dump, \";;   --------------- forward dependences: ------------ \\n\");\n   for (bb = 0; bb < current_nr_blocks; bb++)\n     {\n       if (1)\n@@ -6727,12 +6791,12 @@ debug_dependencies ()\n \n \t  get_bb_head_tail (bb, &head, &tail);\n \t  next_tail = NEXT_INSN (tail);\n-\t  fprintf (dump, \"\\n;;   --- Region Dependences --- b %d bb %d \\n\",\n+\t  fprintf (sched_dump, \"\\n;;   --- Region Dependences --- b %d bb %d \\n\",\n \t\t   BB_TO_BLOCK (bb), bb);\n \n-\t  fprintf (dump, \";;   %7s%6s%6s%6s%6s%6s%11s%6s\\n\",\n+\t  fprintf (sched_dump, \";;   %7s%6s%6s%6s%6s%6s%11s%6s\\n\",\n \t  \"insn\", \"code\", \"bb\", \"dep\", \"prio\", \"cost\", \"blockage\", \"units\");\n-\t  fprintf (dump, \";;   %7s%6s%6s%6s%6s%6s%11s%6s\\n\",\n+\t  fprintf (sched_dump, \";;   %7s%6s%6s%6s%6s%6s%11s%6s\\n\",\n \t  \"----\", \"----\", \"--\", \"---\", \"----\", \"----\", \"--------\", \"-----\");\n \t  for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n \t    {\n@@ -6742,26 +6806,26 @@ debug_dependencies ()\n \t      if (! INSN_P (insn))\n \t\t{\n \t\t  int n;\n-\t\t  fprintf (dump, \";;   %6d \", INSN_UID (insn));\n+\t\t  fprintf (sched_dump, \";;   %6d \", INSN_UID (insn));\n \t\t  if (GET_CODE (insn) == NOTE)\n \t\t    {\n \t\t      n = NOTE_LINE_NUMBER (insn);\n \t\t      if (n < 0)\n-\t\t\tfprintf (dump, \"%s\\n\", GET_NOTE_INSN_NAME (n));\n+\t\t\tfprintf (sched_dump, \"%s\\n\", GET_NOTE_INSN_NAME (n));\n \t\t      else\n-\t\t\tfprintf (dump, \"line %d, file %s\\n\", n,\n+\t\t\tfprintf (sched_dump, \"line %d, file %s\\n\", n,\n \t\t\t\t NOTE_SOURCE_FILE (insn));\n \t\t    }\n \t\t  else\n-\t\t    fprintf (dump, \" {%s}\\n\", GET_RTX_NAME (GET_CODE (insn)));\n+\t\t    fprintf (sched_dump, \" {%s}\\n\", GET_RTX_NAME (GET_CODE (insn)));\n \t\t  continue;\n \t\t}\n \n \t      unit = insn_unit (insn);\n \t      range = (unit < 0\n \t\t || function_units[unit].blockage_range_function == 0) ? 0 :\n \t\tfunction_units[unit].blockage_range_function (insn);\n-\t      fprintf (dump,\n+\t      fprintf (sched_dump,\n \t\t       \";;   %s%5d%6d%6d%6d%6d%6d  %3d -%3d   \",\n \t\t       (SCHED_GROUP_P (insn) ? \"+\" : \" \"),\n \t\t       INSN_UID (insn),\n@@ -6773,14 +6837,14 @@ debug_dependencies ()\n \t\t       (int) MIN_BLOCKAGE_COST (range),\n \t\t       (int) MAX_BLOCKAGE_COST (range));\n \t      insn_print_units (insn);\n-\t      fprintf (dump, \"\\t: \");\n+\t      fprintf (sched_dump, \"\\t: \");\n \t      for (link = INSN_DEPEND (insn); link; link = XEXP (link, 1))\n-\t\tfprintf (dump, \"%d \", INSN_UID (XEXP (link, 0)));\n-\t      fprintf (dump, \"\\n\");\n+\t\tfprintf (sched_dump, \"%d \", INSN_UID (XEXP (link, 0)));\n+\t      fprintf (sched_dump, \"\\n\");\n \t    }\n \t}\n     }\n-  fprintf (dump, \"\\n\");\n+  fprintf (sched_dump, \"\\n\");\n }\n \n /* Set_priorities: compute priority of each insn in the block.  */\n@@ -6850,7 +6914,12 @@ schedule_region (rgn)\n \n   /* Compute INSN_DEPEND.  */\n   for (bb = current_nr_blocks - 1; bb >= 0; bb--)\n-    compute_block_forward_dependences (bb);\n+    {\n+      rtx head, tail;\n+      get_bb_head_tail (bb, &head, &tail);\n+\n+      compute_forward_dependences (head, tail);\n+    }\n \n   /* Delete line notes and set priorities.  */\n   for (bb = 0; bb < current_nr_blocks; bb++)\n@@ -6950,42 +7019,29 @@ schedule_region (rgn)\n     }\n }\n \n-/* The one entry point in this file.  DUMP_FILE is the dump file for\n-   this pass.  */\n+/* Initialize some global state for the scheduler.  DUMP_FILE is to be used\n+   for debugging output.  */\n \n-void\n-schedule_insns (dump_file)\n+static void\n+sched_init (dump_file)\n      FILE *dump_file;\n {\n-  int *deaths_in_region;\n-  sbitmap blocks, large_region_blocks;\n-  int max_uid;\n-  int b;\n+  int luid, b;\n   rtx insn;\n-  int rgn;\n-  int luid;\n-  int any_large_regions;\n \n   /* Disable speculative loads in their presence if cc0 defined.  */\n #ifdef HAVE_cc0\n   flag_schedule_speculative_load = 0;\n #endif\n \n-  /* Taking care of this degenerate case makes the rest of\n-     this code simpler.  */\n-  if (n_basic_blocks == 0)\n-    return;\n-\n   /* Set dump and sched_verbose for the desired debugging output.  If no\n      dump-file was specified, but -fsched-verbose=N (any N), print to stderr.\n      For -fsched-verbose=N, N>=10, print everything to stderr.  */\n   sched_verbose = sched_verbose_param;\n   if (sched_verbose_param == 0 && dump_file)\n     sched_verbose = 1;\n-  dump = ((sched_verbose_param >= 10 || !dump_file) ? stderr : dump_file);\n-\n-  nr_inter = 0;\n-  nr_spec = 0;\n+  sched_dump = ((sched_verbose_param >= 10 || !dump_file)\n+\t\t? stderr : dump_file);\n \n   /* Initialize issue_rate.  */\n   issue_rate = ISSUE_RATE;\n@@ -6994,9 +7050,9 @@ schedule_insns (dump_file)\n \n   /* We use LUID 0 for the fake insn (UID 0) which holds dependencies for\n      pseudos which do not cross calls.  */\n-  max_uid = get_max_uid () + 1;\n+  old_max_uid = get_max_uid () + 1;\n \n-  h_i_d = (struct haifa_insn_data *) xcalloc (max_uid, sizeof (*h_i_d));\n+  h_i_d = (struct haifa_insn_data *) xcalloc (old_max_uid, sizeof (*h_i_d));\n \n   h_i_d[0].luid = 0;\n   luid = 1;\n@@ -7017,36 +7073,75 @@ schedule_insns (dump_file)\n \t  break;\n       }\n \n-  /* ?!? We could save some memory by computing a per-region luid mapping\n-     which could reduce both the number of vectors in the cache and the size\n-     of each vector.  Instead we just avoid the cache entirely unless the\n-     average number of instructions in a basic block is very high.  See\n-     the comment before the declaration of true_dependency_cache for\n-     what we consider \"very high\".  */\n-  if (luid / n_basic_blocks > 100 * 5)\n+  init_dependency_caches (luid);\n+\n+  compute_bb_for_insn (old_max_uid);\n+\n+  init_alias_analysis ();\n+\n+  if (write_symbols != NO_DEBUG)\n     {\n-      true_dependency_cache = sbitmap_vector_alloc (luid, luid);\n-      sbitmap_vector_zero (true_dependency_cache, luid);\n-      anti_dependency_cache = sbitmap_vector_alloc (luid, luid);\n-      sbitmap_vector_zero (anti_dependency_cache, luid);\n-      output_dependency_cache = sbitmap_vector_alloc (luid, luid);\n-      sbitmap_vector_zero (output_dependency_cache, luid);\n-#ifdef ENABLE_CHECKING\n-      forward_dependency_cache = sbitmap_vector_alloc (luid, luid);\n-      sbitmap_vector_zero (forward_dependency_cache, luid);\n-#endif\n+      rtx line;\n+\n+      line_note_head = (rtx *) xcalloc (n_basic_blocks, sizeof (rtx));\n+\n+      /* Save-line-note-head:\n+         Determine the line-number at the start of each basic block.\n+         This must be computed and saved now, because after a basic block's\n+         predecessor has been scheduled, it is impossible to accurately\n+         determine the correct line number for the first insn of the block.  */\n+\n+      for (b = 0; b < n_basic_blocks; b++)\n+\tfor (line = BLOCK_HEAD (b); line; line = PREV_INSN (line))\n+\t  if (GET_CODE (line) == NOTE && NOTE_LINE_NUMBER (line) > 0)\n+\t    {\n+\t      line_note_head[b] = line;\n+\t      break;\n+\t    }\n     }\n \n+  /* Find units used in this fuction, for visualization.  */\n+  if (sched_verbose)\n+    init_target_units ();\n+\n+  /* ??? Add a NOTE after the last insn of the last basic block.  It is not\n+     known why this is done.  */\n+\n+  insn = BLOCK_END (n_basic_blocks - 1);\n+  if (NEXT_INSN (insn) == 0\n+      || (GET_CODE (insn) != NOTE\n+\t  && GET_CODE (insn) != CODE_LABEL\n+\t  /* Don't emit a NOTE if it would end up between an unconditional\n+\t     jump and a BARRIER.  */\n+\t  && !(GET_CODE (insn) == JUMP_INSN\n+\t       && GET_CODE (NEXT_INSN (insn)) == BARRIER)))\n+    emit_note_after (NOTE_INSN_DELETED, BLOCK_END (n_basic_blocks - 1));\n+\n+  /* Compute INSN_REG_WEIGHT for all blocks.  We must do this before\n+     removing death notes.  */\n+  for (b = n_basic_blocks - 1; b >= 0; b--)\n+    find_insn_reg_weight (b);\n+}\n+\n+/* Indexed by region, holds the number of death notes found in that region.\n+   Used for consistency checks.  */\n+static int *deaths_in_region;\n+\n+/* Initialize data structures for region scheduling.  */\n+\n+static void\n+init_regions ()\n+{\n+  sbitmap blocks;\n+  int rgn;\n+\n   nr_regions = 0;\n   rgn_table = (region *) xmalloc ((n_basic_blocks) * sizeof (region));\n   rgn_bb_table = (int *) xmalloc ((n_basic_blocks) * sizeof (int));\n   block_to_bb = (int *) xmalloc ((n_basic_blocks) * sizeof (int));\n   containing_rgn = (int *) xmalloc ((n_basic_blocks) * sizeof (int));\n \n   blocks = sbitmap_alloc (n_basic_blocks);\n-  large_region_blocks = sbitmap_alloc (n_basic_blocks);\n-\n-  compute_bb_for_insn (max_uid);\n \n   /* Compute regions for scheduling.  */\n   if (reload_completed\n@@ -7107,60 +7202,43 @@ schedule_insns (dump_file)\n \n   deaths_in_region = (int *) xmalloc (sizeof (int) * nr_regions);\n \n-  init_alias_analysis ();\n-\n-  if (write_symbols != NO_DEBUG)\n+  /* Remove all death notes from the subroutine.  */\n+  for (rgn = 0; rgn < nr_regions; rgn++)\n     {\n-      rtx line;\n-\n-      line_note_head = (rtx *) xcalloc (n_basic_blocks, sizeof (rtx));\n+      int b;\n \n-      /* Save-line-note-head:\n-         Determine the line-number at the start of each basic block.\n-         This must be computed and saved now, because after a basic block's\n-         predecessor has been scheduled, it is impossible to accurately\n-         determine the correct line number for the first insn of the block.  */\n+      sbitmap_zero (blocks);\n+      for (b = RGN_NR_BLOCKS (rgn) - 1; b >= 0; --b)\n+\tSET_BIT (blocks, rgn_bb_table[RGN_BLOCKS (rgn) + b]);\n \n-      for (b = 0; b < n_basic_blocks; b++)\n-\tfor (line = BLOCK_HEAD (b); line; line = PREV_INSN (line))\n-\t  if (GET_CODE (line) == NOTE && NOTE_LINE_NUMBER (line) > 0)\n-\t    {\n-\t      line_note_head[b] = line;\n-\t      break;\n-\t    }\n+      deaths_in_region[rgn] = count_or_remove_death_notes (blocks, 1);\n     }\n \n-  /* Find units used in this fuction, for visualization.  */\n-  if (sched_verbose)\n-    init_target_units ();\n+  sbitmap_free (blocks);\n+}\n \n-  /* ??? Add a NOTE after the last insn of the last basic block.  It is not\n-     known why this is done.  */\n+/* The one entry point in this file.  DUMP_FILE is the dump file for\n+   this pass.  */\n \n-  insn = BLOCK_END (n_basic_blocks - 1);\n-  if (NEXT_INSN (insn) == 0\n-      || (GET_CODE (insn) != NOTE\n-\t  && GET_CODE (insn) != CODE_LABEL\n-\t  /* Don't emit a NOTE if it would end up between an unconditional\n-\t     jump and a BARRIER.  */\n-\t  && !(GET_CODE (insn) == JUMP_INSN\n-\t       && GET_CODE (NEXT_INSN (insn)) == BARRIER)))\n-    emit_note_after (NOTE_INSN_DELETED, BLOCK_END (n_basic_blocks - 1));\n+void\n+schedule_insns (dump_file)\n+     FILE *dump_file;\n+{\n+  sbitmap large_region_blocks, blocks;\n+  int rgn;\n+  int any_large_regions;\n \n-  /* Compute INSN_REG_WEIGHT for all blocks.  We must do this before\n-     removing death notes.  */\n-  for (b = n_basic_blocks - 1; b >= 0; b--)\n-    find_insn_reg_weight (b);\n+  /* Taking care of this degenerate case makes the rest of\n+     this code simpler.  */\n+  if (n_basic_blocks == 0)\n+    return;\n \n-  /* Remove all death notes from the subroutine.  */\n-  for (rgn = 0; rgn < nr_regions; rgn++)\n-    {\n-      sbitmap_zero (blocks);\n-      for (b = RGN_NR_BLOCKS (rgn) - 1; b >= 0; --b)\n-\tSET_BIT (blocks, rgn_bb_table[RGN_BLOCKS (rgn) + b]);\n+  nr_inter = 0;\n+  nr_spec = 0;\n \n-      deaths_in_region[rgn] = count_or_remove_death_notes (blocks, 1);\n-    }\n+  sched_init (dump_file);\n+\n+  init_regions ();\n \n   /* Schedule every region in the subroutine.  */\n   for (rgn = 0; rgn < nr_regions; rgn++)\n@@ -7180,11 +7258,14 @@ schedule_insns (dump_file)\n      best way to test for this kind of thing...  */\n \n   allocate_reg_life_data ();\n-  compute_bb_for_insn (max_uid);\n+  compute_bb_for_insn (old_max_uid);\n \n   any_large_regions = 0;\n+  large_region_blocks = sbitmap_alloc (n_basic_blocks);\n   sbitmap_ones (large_region_blocks);\n \n+  blocks = sbitmap_alloc (n_basic_blocks);\n+\n   for (rgn = 0; rgn < nr_regions; rgn++)\n     if (RGN_NR_BLOCKS (rgn) > 1)\n       any_large_regions = 1;\n@@ -7230,7 +7311,7 @@ schedule_insns (dump_file)\n     {\n       if (reload_completed == 0 && flag_schedule_interblock)\n \t{\n-\t  fprintf (dump,\n+\t  fprintf (sched_dump,\n \t\t   \"\\n;; Procedure interblock/speculative motions == %d/%d \\n\",\n \t\t   nr_inter, nr_spec);\n \t}\n@@ -7239,25 +7320,13 @@ schedule_insns (dump_file)\n \t  if (nr_inter > 0)\n \t    abort ();\n \t}\n-      fprintf (dump, \"\\n\\n\");\n+      fprintf (sched_dump, \"\\n\\n\");\n     }\n \n   /* Clean up.  */\n   end_alias_analysis ();\n \n-  if (true_dependency_cache)\n-    {\n-      free (true_dependency_cache);\n-      true_dependency_cache = NULL;\n-      free (anti_dependency_cache);\n-      anti_dependency_cache = NULL;\n-      free (output_dependency_cache);\n-      output_dependency_cache = NULL;\n-#ifdef ENABLE_CHECKING\n-      free (forward_dependency_cache);\n-      forward_dependency_cache = NULL;\n-#endif\n-    }\n+  free_dependency_caches ();\n   free (rgn_table);\n   free (rgn_bb_table);\n   free (block_to_bb);"}]}