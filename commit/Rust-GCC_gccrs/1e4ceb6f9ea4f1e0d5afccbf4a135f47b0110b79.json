{"sha": "1e4ceb6f9ea4f1e0d5afccbf4a135f47b0110b79", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU0Y2ViNmY5ZWE0ZjFlMGQ1YWZjY2JmNGExMzVmNDdiMDExMGI3OQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-11-18T17:50:56Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-11-18T17:50:56Z"}, "message": "except.h (struct eh_entry): Add goto_entry_p.\n\n\t* except.h (struct eh_entry): Add goto_entry_p.\n\t(eh_region_from_symbol): Remove prototype.\n\t* except.c (find_func_region_from_symbol): New function.\n\t(emit_cleanup_handler): Likewise.\n\t(eh_region_from_symbol): Make it static.\n\t(add_new_handler): Verify the argument.\n\t(find_func_region): Update comment.\n\t(expand_eh_region_end): Expand handlers here, rater than waiting\n\tuntil expand_leftover_cleanups or start_all_catch.\n\t(expand_leftover_cleanups): Don't expand here.\n\t(expand_start_all_catch): Or here.\n\t(expand_rethrow): Check the return value from find_func_region.\n\t* function.c (expand_function_end): Emit the catch_clauses.\n\nFrom-SVN: r30576", "tree": {"sha": "1e51c7da99a24a8b91dc684f56f9817dae2fb778", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e51c7da99a24a8b91dc684f56f9817dae2fb778"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e4ceb6f9ea4f1e0d5afccbf4a135f47b0110b79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e4ceb6f9ea4f1e0d5afccbf4a135f47b0110b79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e4ceb6f9ea4f1e0d5afccbf4a135f47b0110b79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e4ceb6f9ea4f1e0d5afccbf4a135f47b0110b79/comments", "author": null, "committer": null, "parents": [{"sha": "0e6b2107ca04f7ea045bf9456a12178d2133fbfe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e6b2107ca04f7ea045bf9456a12178d2133fbfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e6b2107ca04f7ea045bf9456a12178d2133fbfe"}], "stats": {"total": 209, "additions": 129, "deletions": 80}, "files": [{"sha": "f8fe6c575cd0e469f1553bb3026462338ab6abd3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e4ceb6f9ea4f1e0d5afccbf4a135f47b0110b79/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e4ceb6f9ea4f1e0d5afccbf4a135f47b0110b79/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1e4ceb6f9ea4f1e0d5afccbf4a135f47b0110b79", "patch": "@@ -1,3 +1,19 @@\n+1999-11-17  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* except.h (struct eh_entry): Add goto_entry_p.\n+\t(eh_region_from_symbol): Remove prototype.\n+\t* except.c (find_func_region_from_symbol): New function.\n+\t(emit_cleanup_handler): Likewise.\n+\t(eh_region_from_symbol): Make it static.\n+\t(add_new_handler): Verify the argument.\n+\t(find_func_region): Update comment.\n+\t(expand_eh_region_end): Expand handlers here, rater than waiting\n+\tuntil expand_leftover_cleanups or start_all_catch.\n+\t(expand_leftover_cleanups): Don't expand here.\n+\t(expand_start_all_catch): Or here.\n+\t(expand_rethrow): Check the return value from find_func_region.\n+\t* function.c (expand_function_end): Emit the catch_clauses.\n+\t\n 1999-11-18  Gavin Romig-Koch  <gavin@cygnus.com>\n \n \t* integrate.c (expand_inline_function): Add necessary check for NULL."}, {"sha": "4b294769f120b1735a92662b0eb2fe07bcf12a2f", "filename": "gcc/except.c", "status": "modified", "additions": 104, "deletions": 67, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e4ceb6f9ea4f1e0d5afccbf4a135f47b0110b79/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e4ceb6f9ea4f1e0d5afccbf4a135f47b0110b79/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=1e4ceb6f9ea4f1e0d5afccbf4a135f47b0110b79", "patch": "@@ -479,10 +479,14 @@ static void push_entry\t\tPROTO ((struct eh_stack *, struct eh_entry*));\n static void receive_exception_label PROTO ((rtx));\n static int new_eh_region_entry\tPROTO ((int, rtx));\n static int find_func_region\tPROTO ((int));\n+static int find_func_region_from_symbol PROTO ((rtx));\n static void clear_function_eh_region PROTO ((void));\n static void process_nestinfo\tPROTO ((int, eh_nesting_info *, int *));\n \n rtx expand_builtin_return_addr\tPROTO((enum built_in_function, int, rtx));\n+static void emit_cleanup_handler PROTO ((struct eh_entry *));\n+static int eh_region_from_symbol PROTO((rtx));\n+\n \f\n /* Various support routines to manipulate the various data structures\n    used by the exception handling code.  */\n@@ -590,6 +594,7 @@ push_eh_entry (stack)\n   else\n     entry->outer_context = create_rethrow_ref (CODE_LABEL_NUMBER (rlab));\n   entry->rethrow_label = entry->outer_context;\n+  entry->goto_entry_p = 0;\n \n   node->entry = entry;\n   node->chain = stack->top;\n@@ -705,10 +710,8 @@ static int current_func_eh_entry = 0;\n \n #define SIZE_FUNC_EH(X)   (sizeof (struct func_eh_entry) * X)\n \n-/* Add a new eh_entry for this function, and base it off of the information\n-   in the EH_ENTRY parameter. A NULL parameter is invalid. \n-   OUTER_CONTEXT is a label which is used for rethrowing. The number\n-   returned is an number which uniquely identifies this exception range. */\n+/* Add a new eh_entry for this function.  The number returned is an\n+   number which uniquely identifies this exception range. */\n \n static int \n new_eh_region_entry (note_eh_region, rethrow) \n@@ -755,6 +758,12 @@ add_new_handler (region, newhandler)\n {\n   struct handler_info *last;\n \n+  /* If find_func_region returns -1, callers might attempt to pass us\n+     this region number.  If that happens, something has gone wrong;\n+     -1 is never a valid region.  */\n+  if (region == -1)\n+    abort ();\n+\n   newhandler->next = NULL;\n   last = function_eh_regions[region].handlers;\n   if (last == NULL)\n@@ -883,7 +892,7 @@ get_new_handler (handler, typeinfo)\n \n \n /* Find the index in function_eh_regions associated with a NOTE region. If\n-   the region cannot be found, a -1 is returned. This should never happen! */\n+   the region cannot be found, a -1 is returned.  */\n \n static int \n find_func_region (insn_region)\n@@ -960,7 +969,7 @@ duplicate_eh_handlers (old_note_eh_region, new_note_eh_region, map)\n \n \n /* Given a rethrow symbol, find the EH region number this is for. */\n-int \n+static int \n eh_region_from_symbol (sym)\n      rtx sym;\n {\n@@ -973,6 +982,14 @@ eh_region_from_symbol (sym)\n   return -1;\n }\n \n+/* Like find_func_region, but using the rethrow symbol for the region\n+   rather than the region number itself.  */\n+static int\n+find_func_region_from_symbol (sym)\n+     rtx sym;\n+{\n+  return find_func_region (eh_region_from_symbol (sym));\n+}\n \n /* When inlining/unrolling, we have to map the symbols passed to\n    __rethrow as well. This performs the remap. If a symbol isn't foiund,\n@@ -1475,6 +1492,7 @@ expand_eh_region_end (handler)\n      tree handler;\n {\n   struct eh_entry *entry;\n+  struct eh_node *node;\n   rtx note;\n   int ret, r;\n \n@@ -1523,6 +1541,21 @@ expand_eh_region_end (handler)\n \n       expand_end_bindings (NULL_TREE, 0, 0);\n     }\n+\n+  /* Go through the goto handlers in the queue, emitting their\n+     handlers if we now have enough information to do so.  */\n+  for (node = ehqueue.head; node; node = node->chain)\n+    if (node->entry->goto_entry_p \n+\t&& node->entry->outer_context == entry->rethrow_label)\n+      emit_cleanup_handler (node->entry);\n+\n+  /* We can't emit handlers for goto entries until their scopes are\n+     complete because we don't know where they need to rethrow to,\n+     yet.  */\n+  if (entry->finalization != integer_zero_node \n+      && (!entry->goto_entry_p \n+\t  || find_func_region_from_symbol (entry->outer_context) != -1))\n+    emit_cleanup_handler (entry);\n }\n \n /* End the EH region for a goto fixup.  We only need them in the region-based\n@@ -1535,6 +1568,8 @@ expand_fixup_region_start ()\n     return;\n \n   expand_eh_region_start ();\n+  /* Mark this entry as the entry for a goto.  */\n+  ehstack.top->entry->goto_entry_p = 1;\n }\n \n /* End the EH region for a goto fixup.  CLEANUP is the cleanup we just\n@@ -1636,33 +1671,14 @@ expand_leftover_cleanups ()\n {\n   struct eh_entry *entry;\n \n-  while ((entry = dequeue_eh_entry (&ehqueue)) != 0)\n+  for (entry = dequeue_eh_entry (&ehqueue); \n+       entry;\n+       entry = dequeue_eh_entry (&ehqueue))\n     {\n-      rtx prev;\n-\n-      /* A leftover try block. Shouldn't be one here.  */\n+      /* A leftover try bock.  Shouldn't be one here.  */\n       if (entry->finalization == integer_zero_node)\n \tabort ();\n \n-      /* Output the label for the start of the exception handler.  */\n-\n-      receive_exception_label (entry->exception_handler_label);\n-\n-      /* register a handler for this cleanup region */\n-      add_new_handler (\n-        find_func_region (CODE_LABEL_NUMBER (entry->exception_handler_label)), \n-        get_new_handler (entry->exception_handler_label, NULL));\n-\n-      /* And now generate the insns for the handler.  */\n-      expand_expr (entry->finalization, const0_rtx, VOIDmode, 0);\n-\n-      prev = get_last_insn ();\n-      if (prev == NULL || GET_CODE (prev) != BARRIER)\n-\t/* Emit code to throw to the outer context if we fall off\n-\t   the end of the handler.  */\n-\texpand_rethrow (entry->outer_context);\n-\n-      do_pending_stack_adjust ();\n       free (entry);\n     }\n }\n@@ -1764,6 +1780,56 @@ end_catch_handler ()\n   catchstack.top->entry->false_label = NULL_RTX;\n }\n \n+/* Emit the handler specified by ENTRY.  */\n+\n+static void\n+emit_cleanup_handler (entry)\n+  struct eh_entry *entry;\n+{\n+  rtx prev;\n+  rtx handler_insns;\n+\n+  /* Put these handler instructions in a sequence.  */\n+  do_pending_stack_adjust ();\n+  start_sequence ();\n+\n+  /* Emit the label for the cleanup handler for this region, and\n+     expand the code for the handler.\n+     \n+     Note that a catch region is handled as a side-effect here; for a\n+     try block, entry->finalization will contain integer_zero_node, so\n+     no code will be generated in the expand_expr call below. But, the\n+     label for the handler will still be emitted, so any code emitted\n+     after this point will end up being the handler.  */\n+      \n+  receive_exception_label (entry->exception_handler_label);\n+\n+  /* register a handler for this cleanup region */\n+  add_new_handler (find_func_region (CODE_LABEL_NUMBER (entry->exception_handler_label)), \n+\t\t   get_new_handler (entry->exception_handler_label, NULL));\n+\n+  /* And now generate the insns for the cleanup handler.  */\n+  expand_expr (entry->finalization, const0_rtx, VOIDmode, 0);\n+\n+  prev = get_last_insn ();\n+  if (prev == NULL || GET_CODE (prev) != BARRIER)\n+    /* Code to throw out to outer context when we fall off end of the\n+       handler. We can't do this here for catch blocks, so it's done\n+       in expand_end_all_catch instead.  */\n+    expand_rethrow (entry->outer_context);\n+\n+  /* Finish this sequence.  */\n+  do_pending_stack_adjust ();\n+  handler_insns = get_insns ();\n+  end_sequence ();\n+\n+  /* And add it to the CATCH_CLAUSES.  */\n+  push_to_sequence (catch_clauses);\n+  emit_insns (handler_insns);\n+  catch_clauses = get_insns ();\n+  end_sequence ();\n+}\n+\n /* Generate RTL for the start of a group of catch clauses. \n \n    It is responsible for starting a new instruction sequence for the\n@@ -1802,48 +1868,15 @@ expand_start_all_catch ()\n      the handlers in this handler-seq.  */\n   start_sequence ();\n \n-  entry = dequeue_eh_entry (&ehqueue);\n-  for ( ; entry->finalization != integer_zero_node;\n-                                 entry = dequeue_eh_entry (&ehqueue))\n-    {\n-      rtx prev;\n-\n-      /* Emit the label for the cleanup handler for this region, and\n-\t expand the code for the handler. \n-\n-\t Note that a catch region is handled as a side-effect here;\n-\t for a try block, entry->finalization will contain\n-\t integer_zero_node, so no code will be generated in the\n-\t expand_expr call below. But, the label for the handler will\n-\t still be emitted, so any code emitted after this point will\n-\t end up being the handler.  */\n-      \n-      receive_exception_label (entry->exception_handler_label);\n-\n-      /* register a handler for this cleanup region */\n-      add_new_handler (\n-        find_func_region (CODE_LABEL_NUMBER (entry->exception_handler_label)), \n-        get_new_handler (entry->exception_handler_label, NULL));\n-\n-      /* And now generate the insns for the cleanup handler.  */\n-      expand_expr (entry->finalization, const0_rtx, VOIDmode, 0);\n-\n-      prev = get_last_insn ();\n-      if (prev == NULL || GET_CODE (prev) != BARRIER)\n-\t/* Code to throw out to outer context when we fall off end\n-\t   of the handler. We can't do this here for catch blocks,\n-\t   so it's done in expand_end_all_catch instead.  */\n-\texpand_rethrow (entry->outer_context);\n-\n-      do_pending_stack_adjust ();\n-      free (entry);\n-    }\n+  for (entry = dequeue_eh_entry (&ehqueue); \n+       entry->finalization != integer_zero_node;\n+       entry = dequeue_eh_entry (&ehqueue))\n+    free (entry);\n \n   /* At this point, all the cleanups are done, and the ehqueue now has\n      the current exception region at its head. We dequeue it, and put it\n      on the catch stack. */\n-\n-    push_entry (&catchstack, entry);\n+  push_entry (&catchstack, entry);\n \n   /* If we are not doing setjmp/longjmp EH, because we are reordered\n      out of line, we arrange to rethrow in the outer context.  We need to\n@@ -1935,6 +1968,10 @@ expand_rethrow (label)\n \t  label = last_rethrow_symbol;\n \temit_library_call (rethrow_libfunc, 0, VOIDmode, 1, label, Pmode);\n \tregion = find_func_region (eh_region_from_symbol (label));\n+\t/* If the region is -1, it doesn't exist yet.  We should be\n+\t   trying to rethrow there yet.  */\n+\tif (region == -1)\n+\t  abort ();\n \tfunction_eh_regions[region].rethrow_ref = 1;\n \n \t/* Search backwards for the actual call insn.  */"}, {"sha": "eafeaa942cdb96af27ed62768e58c18ea9e7ae59", "filename": "gcc/except.h", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e4ceb6f9ea4f1e0d5afccbf4a135f47b0110b79/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e4ceb6f9ea4f1e0d5afccbf4a135f47b0110b79/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=1e4ceb6f9ea4f1e0d5afccbf4a135f47b0110b79", "patch": "@@ -62,6 +62,9 @@ struct eh_entry {\n   int label_used;\n   rtx false_label;\n   rtx rethrow_label;\n+  /* If non-zero, this entry is for a handler created when we left an\n+     exception-region via goto.  */\n+  unsigned goto_entry_p : 1;\n };\n #else\n struct label_node;\n@@ -108,16 +111,10 @@ struct eh_status\n   /* This stack is used to represent what the current eh region is\n      for the catch blocks beings processed */\n   struct eh_stack x_catchstack;\n-  /* A queue used for tracking which exception regions have closed but\n-     whose handlers have not yet been expanded. Regions are emitted in\n-     groups in an attempt to improve paging performance.\n-\n+  /* A queue used for tracking which exception regions have closed.\n      As we exit a region, we enqueue a new entry. The entries are then\n-     dequeued during expand_leftover_cleanups and expand_start_all_catch,\n-\n-     We should redo things so that we either take RTL for the handler,\n-     or we expand the handler expressed as a tree immediately at region\n-     end time.  */\n+     dequeued during expand_leftover_cleanups and\n+     expand_start_all_catch.  */\n   struct eh_queue x_ehqueue;\n   /* Insns for all of the exception handlers for the current function.\n      They are currently emitted by the frontend code.  */\n@@ -271,10 +268,6 @@ int rethrow_used                                PROTO((int));\n \n void update_rethrow_references\t\t\tPROTO((void));\n \n-/* Return the region number a this is the rethrow label for. */\n-\n-int eh_region_from_symbol                       PROTO((rtx));\n-\n /* Get a pointer to the first handler in an exception region's list. */\n \n struct handler_info *get_first_handler          PROTO((int));"}, {"sha": "7014a8b1b6c9d43126aa5af31a4c711a65f34ed7", "filename": "gcc/function.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e4ceb6f9ea4f1e0d5afccbf4a135f47b0110b79/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e4ceb6f9ea4f1e0d5afccbf4a135f47b0110b79/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=1e4ceb6f9ea4f1e0d5afccbf4a135f47b0110b79", "patch": "@@ -6436,6 +6436,9 @@ expand_function_end (filename, line, end_bindings)\n \n     expand_leftover_cleanups ();\n \n+    /* If there are any catch_clauses remaining, output them now.  */\n+    emit_insns (catch_clauses);\n+    catch_clauses = NULL_RTX;\n     /* If the above emitted any code, may sure we jump around it.  */\n     if (last != get_last_insn ())\n       {"}]}