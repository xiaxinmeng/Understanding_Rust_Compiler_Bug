{"sha": "4e46365be1d700724ebf25f3f86ac069a4b32915", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU0NjM2NWJlMWQ3MDA3MjRlYmYyNWYzZjg2YWMwNjlhNGIzMjkxNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-04-14T10:13:19Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-04-14T10:13:19Z"}, "message": "alpha.c (aligned_memory_operand): Recognize the output of LEGITIMIZE_RELOAD_ADDRESS.\n\n        * alpha.c (aligned_memory_operand): Recognize the output of\n        LEGITIMIZE_RELOAD_ADDRESS.  Examine reg_equiv_memory_loc in\n        the event of a pseudo.\n        (unaligned_memory_operand): Likewise.  Don't otherwise accept\n        completely illegal addresses.\n        (normal_memory_operand): Likewise.  Handle subregs of pseudos.\n        (get_aligned_mem): Revert previous change.  Abort if we don't have a\n        mem.  During reload, call find_replacement on all illegal memories.\n        (get_unaligned_address): Likewise.\n        * alpha.h (SECONDARY_INPUT_RELOAD_CLASS): Use !aligned_memory_operand\n        instead of unaligned_memory_operand.\n        * alpha.md: Revert extra argument to get_aligned_mem.\n        (reload_inqi): Use any_memory_operand in constraints.  Abort if\n        we're not given some sort of mem.\n        (reload_inhi): Likewise.\n        (reload_outqi, reload_outhi): Likewise.\n\nFrom-SVN: r26445", "tree": {"sha": "38db47013a9a47a146cb0ff9b6f8a1b5a629979a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38db47013a9a47a146cb0ff9b6f8a1b5a629979a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e46365be1d700724ebf25f3f86ac069a4b32915", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e46365be1d700724ebf25f3f86ac069a4b32915", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e46365be1d700724ebf25f3f86ac069a4b32915", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e46365be1d700724ebf25f3f86ac069a4b32915/comments", "author": null, "committer": null, "parents": [{"sha": "4eea1672584f6ff384865ccf3e93194a85b3eb99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4eea1672584f6ff384865ccf3e93194a85b3eb99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4eea1672584f6ff384865ccf3e93194a85b3eb99"}], "stats": {"total": 271, "additions": 132, "deletions": 139}, "files": [{"sha": "7c87db75add81710be9cf9c596b5bb11a720c413", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e46365be1d700724ebf25f3f86ac069a4b32915/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e46365be1d700724ebf25f3f86ac069a4b32915/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4e46365be1d700724ebf25f3f86ac069a4b32915", "patch": "@@ -3,6 +3,23 @@ Wed Apr 14 09:59:38 1999  Richard Henderson  <rth@cygnus.com>\n \t* reload1.c (emit_reload_insns): Also find equivalent mems\n \tfor subregs of pseudos.\n \n+\t* alpha.c (aligned_memory_operand): Recognize the output of\n+\tLEGITIMIZE_RELOAD_ADDRESS.  Examine reg_equiv_memory_loc in\n+\tthe event of a pseudo.\n+\t(unaligned_memory_operand): Likewise.  Don't otherwise accept\n+\tcompletely illegal addresses.\n+\t(normal_memory_operand): Likewise.  Handle subregs of pseudos.\n+\t(get_aligned_mem): Revert previous change.  Abort if we don't have a\n+\tmem.  During reload, call find_replacement on all illegal memories.\n+\t(get_unaligned_address): Likewise.\n+\t* alpha.h (SECONDARY_INPUT_RELOAD_CLASS): Use !aligned_memory_operand\n+\tinstead of unaligned_memory_operand.\n+\t* alpha.md: Revert extra argument to get_aligned_mem.\n+\t(reload_inqi): Use any_memory_operand in constraints.  Abort if\n+\twe're not given some sort of mem.\n+\t(reload_inhi): Likewise.\n+\t(reload_outqi, reload_outhi): Likewise.\n+\n Wed Apr 14 09:39:20 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* i386.md (neghi): Use the whole register when widening the op."}, {"sha": "e2a4dffde7b3af34dd052d7e453ac029427ddccb", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 84, "deletions": 114, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e46365be1d700724ebf25f3f86ac069a4b32915/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e46365be1d700724ebf25f3f86ac069a4b32915/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=4e46365be1d700724ebf25f3f86ac069a4b32915", "patch": "@@ -735,36 +735,42 @@ aligned_memory_operand (op, mode)\n      register rtx op;\n      enum machine_mode mode;\n {\n-  if (GET_CODE (op) == SUBREG)\n-    {\n-      if (GET_MODE (op) != mode)\n-\treturn 0;\n-      op = SUBREG_REG (op);\n-      mode = GET_MODE (op);\n-    }\n+  rtx base;\n \n   if (reload_in_progress)\n     {\n-      /* This is a stack slot.  The stack pointer is always aligned.\n-\t We may have to jump through hoops to get a valid address,\n-\t but we can do it.  */\n-      if (GET_CODE (op) == REG\n-          && REGNO (op) >= FIRST_PSEUDO_REGISTER)\n-\treturn 1;\n+      rtx tmp = op;\n+      if (GET_CODE (tmp) == SUBREG)\n+\ttmp = SUBREG_REG (tmp);\n+      if (GET_CODE (tmp) == REG\n+\t  && REGNO (tmp) >= FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  op = reg_equiv_memory_loc[REGNO (tmp)];\n+\t  if (op == 0)\n+\t    return 0;\n+\t}\n     }\n \n   if (GET_CODE (op) != MEM\n-      || GET_MODE (op) != mode\n-      || ! memory_address_p (mode, XEXP (op, 0)))\n+      || GET_MODE (op) != mode)\n     return 0;\n-\n   op = XEXP (op, 0);\n \n-  if (GET_CODE (op) == PLUS)\n-    op = XEXP (op, 0);\n+  /* LEGITIMIZE_RELOAD_ADDRESS creates (plus (plus reg const_hi) const_lo)\n+     sorts of constructs.  Dig for the real base register.  */\n+  if (reload_in_progress\n+      && GET_CODE (op) == PLUS\n+      && GET_CODE (XEXP (op, 0)) == PLUS)\n+    base = XEXP (XEXP (op, 0), 0);\n+  else\n+    {\n+      if (! memory_address_p (mode, op))\n+\treturn 0;\n+      base = (GET_CODE (op) == PLUS ? XEXP (op, 0) : op);\n+    }\n \n-  return (GET_CODE (op) == REG\n-\t  && REGNO_POINTER_ALIGN (REGNO (op)) >= 4);\n+  return (GET_CODE (base) == REG\n+\t  && REGNO_POINTER_ALIGN (REGNO (base)) >= 4);\n }\n \n /* Similar, but return 1 if OP is a MEM which is not alignable.  */\n@@ -774,31 +780,42 @@ unaligned_memory_operand (op, mode)\n      register rtx op;\n      enum machine_mode mode;\n {\n-  if (GET_CODE (op) == SUBREG)\n+  rtx base;\n+\n+  if (reload_in_progress)\n     {\n-      if (GET_MODE (op) != mode)\n-\treturn 0;\n-      op = SUBREG_REG (op);\n-      mode = GET_MODE (op);\n+      rtx tmp = op;\n+      if (GET_CODE (tmp) == SUBREG)\n+\ttmp = SUBREG_REG (tmp);\n+      if (GET_CODE (tmp) == REG\n+\t  && REGNO (tmp) >= FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  op = reg_equiv_memory_loc[REGNO (tmp)];\n+\t  if (op == 0)\n+\t    return 0;\n+\t}\n     }\n \n-  if (reload_in_progress && GET_CODE (op) == REG\n-      && REGNO (op) >= FIRST_PSEUDO_REGISTER)\n-    op = reg_equiv_mem[REGNO (op)];\n-\n-  if (GET_CODE (op) != MEM || GET_MODE (op) != mode)\n+  if (GET_CODE (op) != MEM\n+      || GET_MODE (op) != mode)\n     return 0;\n-\n   op = XEXP (op, 0);\n \n-  if (! memory_address_p (mode, op))\n-    return 1;\n-\n-  if (GET_CODE (op) == PLUS)\n-    op = XEXP (op, 0);\n+  /* LEGITIMIZE_RELOAD_ADDRESS creates (plus (plus reg const_hi) const_lo)\n+     sorts of constructs.  Dig for the real base register.  */\n+  if (reload_in_progress\n+      && GET_CODE (op) == PLUS\n+      && GET_CODE (XEXP (op, 0)) == PLUS)\n+    base = XEXP (XEXP (op, 0), 0);\n+  else\n+    {\n+      if (! memory_address_p (mode, op))\n+\treturn 0;\n+      base = (GET_CODE (op) == PLUS ? XEXP (op, 0) : op);\n+    }\n \n-  return (GET_CODE (op) != REG\n-\t  || REGNO_POINTER_ALIGN (REGNO (op)) < 4);\n+  return (GET_CODE (base) == REG\n+\t  && REGNO_POINTER_ALIGN (REGNO (base)) < 4);\n }\n \n /* Return 1 if OP is either a register or an unaligned memory location.  */\n@@ -861,15 +878,21 @@ normal_memory_operand (op, mode)\n      register rtx op;\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n-  if (reload_in_progress && GET_CODE (op) == REG\n-      && REGNO (op) >= FIRST_PSEUDO_REGISTER)\n+  if (reload_in_progress)\n     {\n-      op = reg_equiv_mem[REGNO (op)];\n+      rtx tmp = op;\n+      if (GET_CODE (tmp) == SUBREG)\n+\ttmp = SUBREG_REG (tmp);\n+      if (GET_CODE (tmp) == REG\n+\t  && REGNO (tmp) >= FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  op = reg_equiv_memory_loc[REGNO (tmp)];\n \n-      /* This may not have been assigned an equivalent address if it will\n-\t be eliminated.  In that case, it doesn't matter what we do.  */\n-      if (op == 0)\n-\treturn 1;\n+\t  /* This may not have been assigned an equivalent address if it will\n+\t     be eliminated.  In that case, it doesn't matter what we do.  */\n+\t  if (op == 0)\n+\t    return 1;\n+\t}\n     }\n \n   return GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) != AND;\n@@ -906,63 +929,26 @@ direct_return ()\n    of range stack slots.  */\n \n void\n-get_aligned_mem (ref, scratch, paligned_mem, pbitnum)\n-     rtx ref, scratch;\n+get_aligned_mem (ref, paligned_mem, pbitnum)\n+     rtx ref;\n      rtx *paligned_mem, *pbitnum;\n {\n   rtx base;\n   HOST_WIDE_INT offset = 0;\n \n-  if (GET_CODE (ref) == SUBREG)\n-    {\n-      offset = SUBREG_WORD (ref) * UNITS_PER_WORD;\n-      if (BYTES_BIG_ENDIAN)\n-\toffset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (ref)))\n-\t\t   - MIN (UNITS_PER_WORD,\n-\t\t\t  GET_MODE_SIZE (GET_MODE (SUBREG_REG (ref)))));\n-      ref = SUBREG_REG (ref);\n-    }\n+  if (GET_CODE (ref) != MEM)\n+    abort ();\n \n-  if (reload_in_progress)\n+  if (reload_in_progress\n+      && ! memory_address_p (GET_MODE (ref), XEXP (ref, 0)))\n     {\n-      if (GET_CODE (ref) == REG)\n-\t{\n-\t  /* The \"simple\" case is where the stack slot is in range.  */\n-\t  if (reg_equiv_mem[REGNO (ref)])\n-\t    {\n-\t      ref = reg_equiv_mem[REGNO (ref)];\n-\t      base = find_replacement (&XEXP (ref, 0));\n-\t    }\n-\t  else\n-\t    {\n-\t      /* The stack slot isn't in range.  Fix it up as needed.  */\n-\t      HOST_WIDE_INT hi, lo;\n-\n-\t      base = reg_equiv_address[REGNO (ref)];\n-\t      if (GET_CODE (base) != PLUS)\n-\t\tabort ();\n-\t      offset += INTVAL (XEXP (base, 1));\n-\t      base = XEXP (base, 0);\n-\n-\t      lo = ((offset & 0xFFFF) ^ 0x8000) - 0x8000;\n-\t      hi = (((offset - lo) & 0xFFFFFFFF) ^ 0x80000000) - 0x80000000;\n-\t      if (hi + lo != offset)\n-\t\tabort ();\n-\t      if (scratch == NULL)\n-\t\tabort ();\n+      base = find_replacement (&XEXP (ref, 0));\n \n-\t      emit_insn (gen_adddi3 (scratch, base, GEN_INT (hi)));\n-\t      base = scratch;\n-\t      offset = lo;\n-\t    }\n-\t}\n-      else\n-\tbase = find_replacement (&XEXP (ref, 0));\n+      if (! memory_address_p (GET_MODE (ref), base))\n+\tabort ();\n     }\n   else\n     {\n-      if (GET_CODE (ref) != MEM)\n-\tabort ();\n       base = XEXP (ref, 0);\n     }\n \n@@ -991,35 +977,19 @@ get_unaligned_address (ref, extra_offset)\n   rtx base;\n   HOST_WIDE_INT offset = 0;\n \n-  if (GET_CODE (ref) == SUBREG)\n-    {\n-      offset = SUBREG_WORD (ref) * UNITS_PER_WORD;\n-      if (BYTES_BIG_ENDIAN)\n-\toffset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (ref)))\n-\t\t   - MIN (UNITS_PER_WORD,\n-\t\t\t  GET_MODE_SIZE (GET_MODE (SUBREG_REG (ref)))));\n-      ref = SUBREG_REG (ref);\n-    }\n+  if (GET_CODE (ref) != MEM)\n+    abort ();\n \n-  if (reload_in_progress)\n+  if (reload_in_progress\n+      && ! memory_address_p (GET_MODE (ref), XEXP (ref, 0)))\n     {\n-      if (GET_CODE (ref) == REG)\n-\t{\n-\t  if (reg_equiv_mem[REGNO (ref)])\n-            ref = reg_equiv_mem[REGNO (ref)];\n-\t  else\n-\t    {\n-\t      /* The stack slot is out of range.  We should have handled\n-\t\t this as an aligned access -- I wonder why we didn't? */\n-\t      abort ();\n-\t    }\n-\t}\n       base = find_replacement (&XEXP (ref, 0));\n+\n+      if (! memory_address_p (GET_MODE (ref), base))\n+\tabort ();\n     }\n   else\n     {\n-      if (GET_CODE (ref) != MEM)\n-\tabort ();\n       base = XEXP (ref, 0);\n     }\n "}, {"sha": "fe31dc3be0b1586d2992c9b4a33fbc7afd3d6216", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e46365be1d700724ebf25f3f86ac069a4b32915/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e46365be1d700724ebf25f3f86ac069a4b32915/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=4e46365be1d700724ebf25f3f86ac069a4b32915", "patch": "@@ -820,7 +820,7 @@ extern int normal_memory_operand ();\n   && (((CLASS) == FLOAT_REGS\t\t\t\t\t\t\\\n        && ((MODE) == SImode || (MODE) == HImode || (MODE) == QImode))\t\\\n       || (((MODE) == QImode || (MODE) == HImode)\t\t\t\\\n-\t  && ! TARGET_BWX && unaligned_memory_operand (IN, MODE)))) \\\n+\t  && ! TARGET_BWX && ! aligned_memory_operand (IN, MODE))))\t\\\n  ? GENERAL_REGS\t\t\t\t\t\t\t\t\\\n  : ((CLASS) == FLOAT_REGS && GET_CODE (IN) == MEM\t\t\t\\\n     && GET_CODE (XEXP (IN, 0)) == AND) ? GENERAL_REGS\t\t\t\\"}, {"sha": "f4943a2963556c173b155275d015e68993e10bfe", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 30, "deletions": 24, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e46365be1d700724ebf25f3f86ac069a4b32915/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e46365be1d700724ebf25f3f86ac069a4b32915/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=4e46365be1d700724ebf25f3f86ac069a4b32915", "patch": "@@ -4522,7 +4522,7 @@\n \t\t\t ? gen_rtx_REG (SImode, REGNO (operands[0]))\n \t\t\t : gen_reg_rtx (SImode));\n \n-\t  get_aligned_mem (operands[1], scratch, &aligned_mem, &bitnum);\n+\t  get_aligned_mem (operands[1], &aligned_mem, &bitnum);\n \n \t  emit_insn (gen_aligned_loadqi (operands[0], aligned_mem, bitnum,\n \t\t\t\t\t scratch));\n@@ -4562,7 +4562,7 @@\n \t  rtx temp1 = gen_reg_rtx (SImode);\n \t  rtx temp2 = gen_reg_rtx (SImode);\n \n-\t  get_aligned_mem (operands[0], NULL_RTX, &aligned_mem, &bitnum);\n+\t  get_aligned_mem (operands[0], &aligned_mem, &bitnum);\n \n \t  emit_insn (gen_aligned_store (aligned_mem, operands[1], bitnum,\n \t\t\t\t\ttemp1, temp2));\n@@ -4574,7 +4574,7 @@\n \t  rtx temp3 = gen_reg_rtx (DImode);\n \t  rtx seq\n \t    = gen_unaligned_storeqi (get_unaligned_address (operands[0], 0),\n-\t\t\t\t\t   operands[1], temp1, temp2, temp3);\n+\t\t\t\t     operands[1], temp1, temp2, temp3);\n \n \t  alpha_set_memflags (seq, operands[0]);\n \t  emit_insn (seq);\n@@ -4633,7 +4633,7 @@\n \t\t\t ? gen_rtx_REG (SImode, REGNO (operands[0]))\n \t\t\t : gen_reg_rtx (SImode));\n \n-\t  get_aligned_mem (operands[1], scratch, &aligned_mem, &bitnum);\n+\t  get_aligned_mem (operands[1], &aligned_mem, &bitnum);\n \n \t  emit_insn (gen_aligned_loadhi (operands[0], aligned_mem, bitnum,\n \t\t\t\t\t scratch));\n@@ -4673,7 +4673,7 @@\n \t  rtx temp1 = gen_reg_rtx (SImode);\n \t  rtx temp2 = gen_reg_rtx (SImode);\n \n-\t  get_aligned_mem (operands[0], NULL_RTX, &aligned_mem, &bitnum);\n+\t  get_aligned_mem (operands[0], &aligned_mem, &bitnum);\n \n \t  emit_insn (gen_aligned_store (aligned_mem, operands[1], bitnum,\n \t\t\t\t\ttemp1, temp2));\n@@ -4702,20 +4702,21 @@\n \n (define_expand \"reload_inqi\"\n   [(parallel [(match_operand:QI 0 \"register_operand\" \"=r\")\n-\t      (match_operand:QI 1 \"unaligned_memory_operand\" \"m\")\n+\t      (match_operand:QI 1 \"any_memory_operand\" \"m\")\n \t      (match_operand:TI 2 \"register_operand\" \"=&r\")])]\n   \"! TARGET_BWX\"\n   \"\n {\n   rtx scratch, seq;\n \n+  if (GET_CODE (operands[1]) != MEM)\n+    abort ();\n+\n   if (aligned_memory_operand (operands[1], QImode))\n     {\n       rtx aligned_mem, bitnum;\n \n-      get_aligned_mem (operands[1],\n-\t\t       gen_rtx_REG (DImode, REGNO (operands[2]) + 1),\n-\t\t       &aligned_mem, &bitnum);\n+      get_aligned_mem (operands[1], &aligned_mem, &bitnum);\n       seq = gen_aligned_loadqi (operands[0], aligned_mem, bitnum,\n \t\t\t\tgen_rtx_REG (SImode, REGNO (operands[2])));\n     }\n@@ -4724,18 +4725,18 @@\n       rtx addr;\n \n       /* It is possible that one of the registers we got for operands[2]\n-         might coincide with that of operands[0] (which is why we made\n-         it TImode).  Pick the other one to use as our scratch.  */\n+\t might coincide with that of operands[0] (which is why we made\n+\t it TImode).  Pick the other one to use as our scratch.  */\n       if (REGNO (operands[0]) == REGNO (operands[2]))\n \tscratch = gen_rtx_REG (DImode, REGNO (operands[2]) + 1);\n       else\n \tscratch = gen_rtx_REG (DImode, REGNO (operands[2]));\n \n       addr = get_unaligned_address (operands[1], 0);\n       seq = gen_unaligned_loadqi (operands[0], addr, scratch,\n-\t\t\t\t  gen_rtx_REG (DImode, REGNO (operands[0])));\n+\t\t\t  gen_rtx_REG (DImode, REGNO (operands[0])));\n+      alpha_set_memflags (seq, operands[1]);\n     }\n-  alpha_set_memflags (seq, operands[1]);\n   emit_insn (seq);\n   DONE;\n }\")\n@@ -4749,13 +4750,14 @@\n {\n   rtx scratch, seq;\n \n+  if (GET_CODE (operands[1]) != MEM)\n+    abort ();\n+\n   if (aligned_memory_operand (operands[1], HImode))\n     {\n       rtx aligned_mem, bitnum;\n \n-      get_aligned_mem (operands[1],\n-\t\t       gen_rtx_REG (DImode, REGNO (operands[2]) + 1),\n-\t\t       &aligned_mem, &bitnum);\n+      get_aligned_mem (operands[1], &aligned_mem, &bitnum);\n       seq = gen_aligned_loadhi (operands[0], aligned_mem, bitnum,\n \t\t\t\tgen_rtx_REG (SImode, REGNO (operands[2])));\n     }\n@@ -4764,18 +4766,18 @@\n       rtx addr;\n \n       /* It is possible that one of the registers we got for operands[2]\n-         might coincide with that of operands[0] (which is why we made\n-         it TImode).  Pick the other one to use as our scratch.  */\n+\t might coincide with that of operands[0] (which is why we made\n+\t it TImode).  Pick the other one to use as our scratch.  */\n       if (REGNO (operands[0]) == REGNO (operands[2]))\n \tscratch = gen_rtx_REG (DImode, REGNO (operands[2]) + 1);\n       else\n \tscratch = gen_rtx_REG (DImode, REGNO (operands[2]));\n \n       addr = get_unaligned_address (operands[1], 0);\n       seq = gen_unaligned_loadhi (operands[0], addr, scratch,\n-\t\t\t\t  gen_rtx_REG (DImode, REGNO (operands[0])));\n+\t\t\t  gen_rtx_REG (DImode, REGNO (operands[0])));\n+      alpha_set_memflags (seq, operands[1]);\n     }\n-  alpha_set_memflags (seq, operands[1]);\n   emit_insn (seq);\n   DONE;\n }\")\n@@ -4787,11 +4789,14 @@\n   \"! TARGET_BWX\"\n   \"\n {\n+  if (GET_CODE (operands[0]) != MEM)\n+    abort ();\n+\n   if (aligned_memory_operand (operands[0], QImode))\n     {\n       rtx aligned_mem, bitnum;\n \n-      get_aligned_mem (operands[0], NULL_RTX, &aligned_mem, &bitnum);\n+      get_aligned_mem (operands[0], &aligned_mem, &bitnum);\n \n       emit_insn (gen_aligned_store (aligned_mem, operands[1], bitnum,\n \t\t\t\t    gen_rtx_REG (SImode, REGNO (operands[2])),\n@@ -4814,7 +4819,6 @@\n       alpha_set_memflags (seq, operands[0]);\n       emit_insn (seq);\n     }\n-\n   DONE;\n }\")\n \n@@ -4825,11 +4829,14 @@\n   \"! TARGET_BWX\"\n   \"\n {\n+  if (GET_CODE (operands[0]) != MEM)\n+    abort ();\n+\n   if (aligned_memory_operand (operands[0], HImode))\n     {\n       rtx aligned_mem, bitnum;\n \n-      get_aligned_mem (operands[0], NULL_RTX, &aligned_mem, &bitnum);\n+      get_aligned_mem (operands[0], &aligned_mem, &bitnum);\n \n       emit_insn (gen_aligned_store (aligned_mem, operands[1], bitnum,\n \t\t\t\t    gen_rtx_REG (SImode, REGNO (operands[2])),\n@@ -4852,7 +4859,6 @@\n       alpha_set_memflags (seq, operands[0]);\n       emit_insn (seq);\n     }\n-\n   DONE;\n }\")\n \f"}]}