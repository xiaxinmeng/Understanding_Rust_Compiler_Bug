{"sha": "ebb1b59ac046c73a55541f5c6d7acc65c6e284b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJiMWI1OWFjMDQ2YzczYTU1NTQxZjVjNmQ3YWNjNjVjNmUyODRiOQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.co.uk", "date": "2000-09-17T12:45:51Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "2000-09-17T12:45:51Z"}, "message": "Bring back equal forms for libcalls\n\nFrom-SVN: r36469", "tree": {"sha": "278cde0ad17613ffacff0e59525f96e19d129f9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/278cde0ad17613ffacff0e59525f96e19d129f9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebb1b59ac046c73a55541f5c6d7acc65c6e284b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebb1b59ac046c73a55541f5c6d7acc65c6e284b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebb1b59ac046c73a55541f5c6d7acc65c6e284b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebb1b59ac046c73a55541f5c6d7acc65c6e284b9/comments", "author": null, "committer": null, "parents": [{"sha": "e85427f984beadddb4bcd2b1948454f1b872c1f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e85427f984beadddb4bcd2b1948454f1b872c1f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e85427f984beadddb4bcd2b1948454f1b872c1f5"}], "stats": {"total": 253, "additions": 162, "deletions": 91}, "files": [{"sha": "13fa24de13bfce50553f701e95df7d132115c67b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb1b59ac046c73a55541f5c6d7acc65c6e284b9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb1b59ac046c73a55541f5c6d7acc65c6e284b9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ebb1b59ac046c73a55541f5c6d7acc65c6e284b9", "patch": "@@ -1,3 +1,16 @@\n+2000-09-17  Bernd Schmidt  <bernds@redhat.co.uk>\n+\n+        * expr.h (emit_library_call, emit_library_call_value): Delete\n+\tdeclarations.\n+\t* rtl.h (enum libcall_type): New.\n+\t(emit_library_call, emit_library_call_value): Change fn_type arg to\n+        be of type enum libcall_type.\n+\t* calls.c: Likewise for the function definitions.  Several callers\n+\tthroughout changed to use the new enumeration appropriately.\n+\t(emit_library_call_value_1): Likewise.  Put back code to make libcall\n+        blocks of equal form, but only use it for the two new higher\n+\tenumeration values.\n+\n 2000-09-16  Mark Mitchell  <mark@codesourcery.com>\n \n \tConvert the C front-end to use function-at-a-time mode."}, {"sha": "2983b2bdbcc40e82a2a32aad5995310255f90667", "filename": "gcc/builtins.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb1b59ac046c73a55541f5c6d7acc65c6e284b9/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb1b59ac046c73a55541f5c6d7acc65c6e284b9/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=ebb1b59ac046c73a55541f5c6d7acc65c6e284b9", "patch": "@@ -1388,8 +1388,8 @@ expand_builtin_strlen (exp, target, mode)\n \n       /* Check the string is readable and has an end.  */\n       if (current_function_check_memory_usage)\n-\temit_library_call (chkr_check_str_libfunc, 1, VOIDmode, 2,\n-\t\t\t   src_reg, Pmode,\n+\temit_library_call (chkr_check_str_libfunc, LCT_CONST_MAKE_BLOCK,\n+\t\t\t   VOIDmode, 2, src_reg, Pmode,\n \t\t\t   GEN_INT (MEMORY_USE_RO),\n \t\t\t   TYPE_MODE (integer_type_node));\n \n@@ -1468,8 +1468,8 @@ expand_builtin_memcpy (arglist)\n \n       /* Just copy the rights of SRC to the rights of DEST.  */\n       if (current_function_check_memory_usage)\n-\temit_library_call (chkr_copy_bitmap_libfunc, 1, VOIDmode, 3,\n-\t\t\t   XEXP (dest_mem, 0), Pmode,\n+\temit_library_call (chkr_copy_bitmap_libfunc, LCT_CONST_MAKE_BLOCK,\n+\t\t\t   VOIDmode, 3, XEXP (dest_mem, 0), Pmode,\n \t\t\t   XEXP (src_mem, 0), Pmode,\n \t\t\t   len_rtx, TYPE_MODE (sizetype));\n \n@@ -1574,8 +1574,8 @@ expand_builtin_memset (exp)\n \t   \n       /* Just check DST is writable and mark it as readable.  */\n       if (current_function_check_memory_usage)\n-\temit_library_call (chkr_check_addr_libfunc, 1, VOIDmode, 3,\n-\t\t\t   XEXP (dest_mem, 0), Pmode,\n+\temit_library_call (chkr_check_addr_libfunc, LCT_CONST_MAKE_BLOCK,\n+\t\t\t   VOIDmode, 3, XEXP (dest_mem, 0), Pmode,\n \t\t\t   len_rtx, TYPE_MODE (sizetype),\n \t\t\t   GEN_INT (MEMORY_USE_WO),\n \t\t\t   TYPE_MODE (integer_type_node));\n@@ -1687,7 +1687,7 @@ expand_builtin_memcmp (exp, arglist, target)\n     if (insn)\n       emit_insn (insn);\n     else\n-      emit_library_call_value (memcmp_libfunc, result, 2,\n+      emit_library_call_value (memcmp_libfunc, result, LCT_PURE_MAKE_BLOCK,\n \t\t\t       TYPE_MODE (integer_type_node), 3,\n \t\t\t       XEXP (arg1_rtx, 0), Pmode,\n \t\t\t       XEXP (arg2_rtx, 0), Pmode,"}, {"sha": "2163e51ebda5fd49d8731b9a027e616e2204f4b1", "filename": "gcc/calls.c", "status": "modified", "additions": 58, "deletions": 13, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb1b59ac046c73a55541f5c6d7acc65c6e284b9/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb1b59ac046c73a55541f5c6d7acc65c6e284b9/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=ebb1b59ac046c73a55541f5c6d7acc65c6e284b9", "patch": "@@ -219,7 +219,8 @@ static rtx rtx_for_function_call\t\tPARAMS ((tree, tree));\n static void load_register_parameters\t\tPARAMS ((struct arg_data *,\n \t\t\t\t\t\t\t int, rtx *, int));\n static int libfunc_nothrow\t\t\tPARAMS ((rtx));\n-static rtx emit_library_call_value_1 \t\tPARAMS ((int, rtx, rtx, int,\n+static rtx emit_library_call_value_1 \t\tPARAMS ((int, rtx, rtx,\n+\t\t\t\t\t\t\t enum libcall_type,\n \t\t\t\t\t\t\t enum machine_mode,\n \t\t\t\t\t\t\t int, va_list));\n static int special_function_p\t\t\tPARAMS ((tree, int));\n@@ -1678,9 +1679,8 @@ rtx_for_function_call (fndecl, exp)\n \t     that this seems safer.  */\n \t  funaddr = convert_memory_address (Pmode, funexp);\n #endif\n-\t  emit_library_call (chkr_check_exec_libfunc, 1,\n-\t\t\t     VOIDmode, 1,\n-\t\t\t     funaddr, Pmode);\n+\t  emit_library_call (chkr_check_exec_libfunc, LCT_CONST_MAKE_BLOCK,\n+\t\t\t     VOIDmode, 1, funaddr, Pmode);\n \t}\n       emit_queue ();\n     }\n@@ -3026,7 +3026,7 @@ expand_call (exp, target, ignore)\n \n \t  /* Mark the memory for the aggregate as write-only.  */\n \t  if (current_function_check_memory_usage)\n-\t    emit_library_call (chkr_set_right_libfunc, 1,\n+\t    emit_library_call (chkr_set_right_libfunc, LCT_CONST_MAKE_BLOCK,\n \t\t\t       VOIDmode, 3,\n \t\t\t       structure_value_addr, ptr_mode,\n \t\t\t       GEN_INT (struct_value_size),\n@@ -3465,7 +3465,7 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n      int retval;\n      rtx orgfun;\n      rtx value;\n-     int fn_type;\n+     enum libcall_type fn_type;\n      enum machine_mode outmode;\n      int nargs;\n      va_list p;\n@@ -3521,9 +3521,9 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n #endif\n #endif\n \n-  if (fn_type == 1)\n+  if (fn_type == LCT_CONST_MAKE_BLOCK)\n     flags |= ECF_CONST;\n-  else if (fn_type == 2)\n+  else if (fn_type == LCT_PURE_MAKE_BLOCK)\n     flags |= ECF_PURE;\n   fun = orgfun;\n \n@@ -3580,6 +3580,11 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n \n   count = 0;\n \n+  /* Now we are about to start emitting insns that can be deleted\n+     if a libcall is deleted.  */\n+  if (flags & (ECF_CONST | ECF_PURE))\n+    start_sequence ();\n+\n   push_temp_slots ();\n \n   /* If there's a structure value address to be passed,\n@@ -4017,6 +4022,45 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n   /* Now restore inhibit_defer_pop to its actual original value.  */\n   OK_DEFER_POP;\n \n+  /* If call is cse'able, make appropriate pair of reg-notes around it.\n+     Test valreg so we don't crash; may safely ignore `const'\n+     if return type is void.  Disable for PARALLEL return values, because\n+     we have no way to move such values into a pseudo register.  */\n+  if ((flags & (ECF_CONST | ECF_PURE))\n+      && valreg != 0 && GET_CODE (valreg) != PARALLEL)\n+    {\n+      rtx note = 0;\n+      rtx temp = gen_reg_rtx (GET_MODE (valreg));\n+      rtx insns;\n+      int i;\n+\n+      /* Construct an \"equal form\" for the value which mentions all the\n+\t arguments in order as well as the function name.  */\n+      for (i = 0; i < nargs; i++)\n+\tnote = gen_rtx_EXPR_LIST (VOIDmode, argvec[i].value, note);\n+      note = gen_rtx_EXPR_LIST (VOIDmode, fun, note);\n+\n+      insns = get_insns ();\n+      end_sequence ();\n+\n+      if (flags & ECF_PURE)\n+\tnote = gen_rtx_EXPR_LIST (VOIDmode,\n+\t   gen_rtx_USE (VOIDmode,\n+\t\t\tgen_rtx_MEM (BLKmode,\n+\t\t\t\t     gen_rtx_SCRATCH (VOIDmode))), note);\n+\n+      emit_libcall_block (insns, temp, valreg, note);\n+\n+      valreg = temp;\n+    }\n+  else if (flags & (ECF_CONST | ECF_PURE))\n+    {\n+      /* Otherwise, just write out the sequence without a note.  */\n+      rtx insns = get_insns ();\n+\n+      end_sequence ();\n+      emit_insns (insns);\n+    }\n   pop_temp_slots ();\n \n   /* Copy the value to the right place.  */\n@@ -4098,8 +4142,8 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n    (use (memory (scratch)).  */\n \n void\n-emit_library_call VPARAMS((rtx orgfun, int fn_type, enum machine_mode outmode,\n-\t\t\t   int nargs, ...))\n+emit_library_call VPARAMS((rtx orgfun, enum libcall_type fn_type,\n+\t\t\t   enum machine_mode outmode, int nargs, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   rtx orgfun;\n@@ -4132,7 +4176,8 @@ emit_library_call VPARAMS((rtx orgfun, int fn_type, enum machine_mode outmode,\n    If VALUE is nonzero, VALUE is returned.  */\n \n rtx\n-emit_library_call_value VPARAMS((rtx orgfun, rtx value, int fn_type,\n+emit_library_call_value VPARAMS((rtx orgfun, rtx value,\n+\t\t\t\t enum libcall_type fn_type,\n \t\t\t\t enum machine_mode outmode, int nargs, ...))\n {\n #ifndef ANSI_PROTOTYPES\n@@ -4376,8 +4421,8 @@ store_one_arg (arg, argblock, flags, variable_size, reg_parm_stack_space)\n       /* If the value is already in the stack slot, we are done.  */\n       if (current_function_check_memory_usage && GET_CODE (arg->stack) == MEM)\n \t{\n-\t  emit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n-\t\t\t     XEXP (arg->stack, 0), Pmode,\n+\t  emit_library_call (chkr_set_right_libfunc, LCT_CONST_MAKE_BLOCK,\n+\t\t\t     VOIDmode, 3, XEXP (arg->stack, 0), Pmode,\n \t\t\t     ARGS_SIZE_RTX (arg->size),\n \t\t\t     TYPE_MODE (sizetype),\n \t\t\t     GEN_INT (MEMORY_USE_RW),"}, {"sha": "fb697a845e703ba0eac123a58850f01605a964ce", "filename": "gcc/except.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb1b59ac046c73a55541f5c6d7acc65c6e284b9/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb1b59ac046c73a55541f5c6d7acc65c6e284b9/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=ebb1b59ac046c73a55541f5c6d7acc65c6e284b9", "patch": "@@ -1363,7 +1363,7 @@ start_dynamic_handler ()\n   buf = plus_constant (XEXP (arg, 0), GET_MODE_SIZE (Pmode)*2);\n \n #ifdef DONT_USE_BUILTIN_SETJMP\n-  x = emit_library_call_value (setjmp_libfunc, NULL_RTX, 1,\n+  x = emit_library_call_value (setjmp_libfunc, NULL_RTX, LCT_CONST,\n \t\t\t       TYPE_MODE (integer_type_node), 1,\n \t\t\t       buf, Pmode);\n   /* If we come back here for a catch, transfer control to the handler.  */\n@@ -1761,7 +1761,8 @@ start_catch_handler (rtime)\n \n       /* Now issue the call, and branch around handler if needed */\n       call_rtx = emit_library_call_value (eh_rtime_match_libfunc, NULL_RTX, \n-                                          0, TYPE_MODE (integer_type_node),\n+                                          LCT_NORMAL,\n+\t\t\t\t\t  TYPE_MODE (integer_type_node),\n \t\t\t\t          1, rtime_address, Pmode);\n \n       /* Did the function return true? */"}, {"sha": "39199cc19d40a87fc988934eef98b5b9c97531fa", "filename": "gcc/expr.c", "status": "modified", "additions": 46, "deletions": 41, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb1b59ac046c73a55541f5c6d7acc65c6e284b9/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb1b59ac046c73a55541f5c6d7acc65c6e284b9/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ebb1b59ac046c73a55541f5c6d7acc65c6e284b9", "patch": "@@ -812,7 +812,7 @@ convert_move (to, from, unsignedp)\n \tabort ();\n \n       start_sequence ();\n-      value = emit_library_call_value (libcall, NULL_RTX, 1, to_mode,\n+      value = emit_library_call_value (libcall, NULL_RTX, LCT_CONST, to_mode,\n \t\t\t\t       1, from, from_mode);\n       insns = get_insns ();\n       end_sequence ();\n@@ -1785,7 +1785,7 @@ emit_block_move (x, y, size, align)\n \n       retval = expand_expr (call_expr, NULL_RTX, VOIDmode, 0);\n #else\n-      emit_library_call (bcopy_libfunc, 0,\n+      emit_library_call (bcopy_libfunc, LCT_NORMAL,\n \t\t\t VOIDmode, 3, y, Pmode, x, Pmode,\n \t\t\t convert_to_mode (TYPE_MODE (integer_type_node), size,\n \t\t\t\t\t  TREE_UNSIGNED (integer_type_node)),\n@@ -2556,7 +2556,7 @@ clear_storage (object, size, align)\n \n \t  retval = expand_expr (call_expr, NULL_RTX, VOIDmode, 0);\n #else\n-\t  emit_library_call (bzero_libfunc, 0,\n+\t  emit_library_call (bzero_libfunc, LCT_NORMAL,\n \t\t\t     VOIDmode, 2, object, Pmode, size,\n \t\t\t     TYPE_MODE (integer_type_node));\n #endif\n@@ -3060,15 +3060,15 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t      in_check_memory_usage = 1;\n \t      temp = get_push_address (INTVAL (size) - used);\n \t      if (GET_CODE (x) == MEM && type && AGGREGATE_TYPE_P (type))\n-\t\temit_library_call (chkr_copy_bitmap_libfunc, 1, VOIDmode, 3,\n-\t\t\t\t   temp, Pmode,\n-\t\t\t\t   XEXP (xinner, 0), Pmode,\n+\t\temit_library_call (chkr_copy_bitmap_libfunc,\n+\t\t\t\t   LCT_CONST_MAKE_BLOCK, VOIDmode, 3, temp,\n+\t\t\t\t   Pmode, XEXP (xinner, 0), Pmode,\n \t\t\t\t   GEN_INT (INTVAL (size) - used),\n \t\t\t\t   TYPE_MODE (sizetype));\n \t      else\n-\t\temit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n-\t\t\t\t   temp, Pmode,\n-\t\t\t \t   GEN_INT (INTVAL (size) - used),\n+\t\temit_library_call (chkr_set_right_libfunc,\n+\t\t\t\t   LCT_CONST_MAKE_BLOCK, VOIDmode, 3, temp,\n+\t\t\t\t   Pmode, GEN_INT (INTVAL (size) - used),\n \t\t\t\t   TYPE_MODE (sizetype),\n \t\t\t\t   GEN_INT (MEMORY_USE_RW),\n \t\t\t\t   TYPE_MODE (integer_type_node));\n@@ -3117,12 +3117,14 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t      in_check_memory_usage = 1;\n \t      target = copy_to_reg (temp);\n \t      if (GET_CODE (x) == MEM && type && AGGREGATE_TYPE_P (type))\n-\t\temit_library_call (chkr_copy_bitmap_libfunc, 1, VOIDmode, 3,\n+\t\temit_library_call (chkr_copy_bitmap_libfunc,\n+\t\t\t\t   LCT_CONST_MAKE_BLOCK, VOIDmode, 3,\n \t\t\t\t   target, Pmode,\n \t\t\t\t   XEXP (xinner, 0), Pmode,\n \t\t\t\t   size, TYPE_MODE (sizetype));\n \t      else\n-\t        emit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n+\t        emit_library_call (chkr_set_right_libfunc,\n+\t\t\t\t   LCT_CONST_MAKE_BLOCK, VOIDmode, 3,\n \t\t\t\t   target, Pmode,\n \t\t\t \t   size, TYPE_MODE (sizetype),\n \t\t\t\t   GEN_INT (MEMORY_USE_RW),\n@@ -3209,13 +3211,13 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t     to force it to pop the bcopy-arguments right away.  */\n \t  NO_DEFER_POP;\n #ifdef TARGET_MEM_FUNCTIONS\n-\t  emit_library_call (memcpy_libfunc, 0,\n+\t  emit_library_call (memcpy_libfunc, LCT_NORMAL,\n \t\t\t     VOIDmode, 3, temp, Pmode, XEXP (xinner, 0), Pmode,\n \t\t\t     convert_to_mode (TYPE_MODE (sizetype),\n \t\t\t\t\t      size, TREE_UNSIGNED (sizetype)),\n \t\t\t     TYPE_MODE (sizetype));\n #else\n-\t  emit_library_call (bcopy_libfunc, 0,\n+\t  emit_library_call (bcopy_libfunc, LCT_NORMAL,\n \t\t\t     VOIDmode, 3, XEXP (xinner, 0), Pmode, temp, Pmode,\n \t\t\t     convert_to_mode (TYPE_MODE (integer_type_node),\n \t\t\t\t\t      size,\n@@ -3339,15 +3341,15 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t    target = get_push_address (GET_MODE_SIZE (mode));\n \n \t  if (GET_CODE (x) == MEM && type && AGGREGATE_TYPE_P (type))\n-\t    emit_library_call (chkr_copy_bitmap_libfunc, 1, VOIDmode, 3,\n-\t\t\t       target, Pmode,\n-\t\t\t       XEXP (x, 0), Pmode,\n+\t    emit_library_call (chkr_copy_bitmap_libfunc,\n+\t\t\t       LCT_CONST_MAKE_BLOCK, VOIDmode, 3, target,\n+\t\t\t       Pmode, XEXP (x, 0), Pmode,\n \t\t\t       GEN_INT (GET_MODE_SIZE (mode)),\n \t\t\t       TYPE_MODE (sizetype));\n \t  else\n-\t    emit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n-\t\t\t       target, Pmode,\n-\t\t\t       GEN_INT (GET_MODE_SIZE (mode)),\n+\t    emit_library_call (chkr_set_right_libfunc,\n+\t\t\t       LCT_CONST_MAKE_BLOCK, VOIDmode, 3, target,\n+\t\t\t       Pmode, GEN_INT (GET_MODE_SIZE (mode)),\n \t\t\t       TYPE_MODE (sizetype),\n \t\t\t       GEN_INT (MEMORY_USE_RW),\n \t\t\t       TYPE_MODE (integer_type_node));\n@@ -3548,8 +3550,8 @@ expand_assignment (to, from, want_value, suggest_reg)\n \t  /* Check the access right of the pointer.  */\n \t  in_check_memory_usage = 1;\n \t  if (size)\n-\t    emit_library_call (chkr_check_addr_libfunc, 1, VOIDmode, 3,\n-\t\t\t       to_addr, Pmode,\n+\t    emit_library_call (chkr_check_addr_libfunc, LCT_CONST_MAKE_BLOCK,\n+\t\t\t       VOIDmode, 3, to_addr, Pmode,\n \t\t\t       GEN_INT (size), TYPE_MODE (sizetype),\n \t\t\t       GEN_INT (MEMORY_USE_WO),\n \t\t\t       TYPE_MODE (integer_type_node));\n@@ -3692,22 +3694,22 @@ expand_assignment (to, from, want_value, suggest_reg)\n \n       /* Copy the rights of the bitmap.  */\n       if (current_function_check_memory_usage)\n-\temit_library_call (chkr_copy_bitmap_libfunc, 1, VOIDmode, 3,\n-\t\t\t   XEXP (to_rtx, 0), Pmode,\n+\temit_library_call (chkr_copy_bitmap_libfunc, LCT_CONST_MAKE_BLOCK,\n+\t\t\t   VOIDmode, 3, XEXP (to_rtx, 0), Pmode,\n \t\t\t   XEXP (from_rtx, 0), Pmode,\n \t\t\t   convert_to_mode (TYPE_MODE (sizetype),\n \t\t\t\t\t    size, TREE_UNSIGNED (sizetype)),\n \t\t\t   TYPE_MODE (sizetype));\n \n #ifdef TARGET_MEM_FUNCTIONS\n-      emit_library_call (memcpy_libfunc, 0,\n+      emit_library_call (memcpy_libfunc, LCT_NORMAL,\n \t\t\t VOIDmode, 3, XEXP (to_rtx, 0), Pmode,\n \t\t\t XEXP (from_rtx, 0), Pmode,\n \t\t\t convert_to_mode (TYPE_MODE (sizetype),\n \t\t\t\t\t  size, TREE_UNSIGNED (sizetype)),\n \t\t\t TYPE_MODE (sizetype));\n #else\n-      emit_library_call (bcopy_libfunc, 0,\n+      emit_library_call (bcopy_libfunc, LCT_NORMAL,\n \t\t\t VOIDmode, 3, XEXP (from_rtx, 0), Pmode,\n \t\t\t XEXP (to_rtx, 0), Pmode,\n \t\t\t convert_to_mode (TYPE_MODE (integer_type_node),\n@@ -3932,13 +3934,13 @@ store_expr (exp, target, want_value)\n     {\n       in_check_memory_usage = 1;\n       if (GET_CODE (temp) == MEM)\n-\temit_library_call (chkr_copy_bitmap_libfunc, 1, VOIDmode, 3,\n-\t\t\t   XEXP (target, 0), Pmode,\n+\temit_library_call (chkr_copy_bitmap_libfunc, LCT_CONST_MAKE_BLOCK,\n+\t\t\t   VOIDmode, 3, XEXP (target, 0), Pmode,\n \t\t\t   XEXP (temp, 0), Pmode,\n \t\t\t   expr_size (exp), TYPE_MODE (sizetype));\n       else\n-\temit_library_call (chkr_check_addr_libfunc, 1, VOIDmode, 3,\n-\t\t\t   XEXP (target, 0), Pmode,\n+\temit_library_call (chkr_check_addr_libfunc, LCT_CONST_MAKE_BLOCK,\n+\t\t\t   VOIDmode, 3, XEXP (target, 0), Pmode,\n \t\t\t   expr_size (exp), TYPE_MODE (sizetype),\n \t\t\t   GEN_INT (MEMORY_USE_WO),\n \t\t\t   TYPE_MODE (integer_type_node));\n@@ -4052,7 +4054,8 @@ store_expr (exp, target, want_value)\n \t\t  /* Be sure we can write on ADDR.  */\n \t\t  in_check_memory_usage = 1;\n \t\t  if (current_function_check_memory_usage)\n-\t\t    emit_library_call (chkr_check_addr_libfunc, 1, VOIDmode, 3,\n+\t\t    emit_library_call (chkr_check_addr_libfunc,\n+\t\t\t\t       LCT_CONST_MAKE_BLOCK, VOIDmode, 3,\n \t\t\t\t       addr, Pmode,\n \t\t\t\t       size, TYPE_MODE (sizetype),\n  \t\t\t\t       GEN_INT (MEMORY_USE_WO),\n@@ -4795,7 +4798,7 @@ store_constructor (exp, target, align, cleared, size)\n \t      && (startb = TREE_INT_CST_LOW (startbit)) % BITS_PER_UNIT == 0\n \t      && (endb = TREE_INT_CST_LOW (endbit) + 1) % BITS_PER_UNIT == 0)\n \t    {\n-\t      emit_library_call (memset_libfunc, 0,\n+\t      emit_library_call (memset_libfunc, LCT_NORMAL,\n \t\t\t\t VOIDmode, 3,\n \t\t\t\t plus_constant (XEXP (targetx, 0),\n \t\t\t\t\t\tstartb / BITS_PER_UNIT),\n@@ -4807,8 +4810,8 @@ store_constructor (exp, target, align, cleared, size)\n \t  else\n #endif\n \t    emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__setbits\"),\n-\t\t\t       0, VOIDmode, 4, XEXP (targetx, 0), Pmode,\n-\t\t\t       bitlength_rtx, TYPE_MODE (sizetype),\n+\t\t\t       LCT_NORMAL, VOIDmode, 4, XEXP (targetx, 0),\n+\t\t\t       Pmode, bitlength_rtx, TYPE_MODE (sizetype),\n \t\t\t       startbit_rtx, TYPE_MODE (sizetype),\n \t\t\t       endbit_rtx, TYPE_MODE (sizetype));\n \n@@ -6006,7 +6009,8 @@ expand_expr (exp, target, tmode, modifier)\n \n \t  in_check_memory_usage = 1;\n \t  if (memory_usage != MEMORY_USE_DONT)\n-\t    emit_library_call (chkr_check_addr_libfunc, 1, VOIDmode, 3,\n+\t    emit_library_call (chkr_check_addr_libfunc,\n+\t\t\t       LCT_CONST_MAKE_BLOCK, VOIDmode, 3,\n \t\t\t       XEXP (DECL_RTL (exp), 0), Pmode,\n \t\t\t       GEN_INT (int_size_in_bytes (type)),\n \t\t\t       TYPE_MODE (sizetype),\n@@ -6524,9 +6528,9 @@ expand_expr (exp, target, tmode, modifier)\n             if (memory_usage != MEMORY_USE_DONT)\n \t      {\n \t\tin_check_memory_usage = 1;\n-\t\temit_library_call (chkr_check_addr_libfunc, 1, VOIDmode, 3,\n-\t\t\t\t   op0, Pmode,\n-\t\t\t\t   GEN_INT (int_size_in_bytes (type)),\n+\t\temit_library_call (chkr_check_addr_libfunc,\n+\t\t\t\t   LCT_CONST_MAKE_BLOCK, VOIDmode, 3, op0,\n+\t\t\t\t   Pmode, GEN_INT (int_size_in_bytes (type)),\n \t\t\t\t   TYPE_MODE (sizetype),\n \t\t\t\t   GEN_INT (memory_usage),\n \t\t\t\t   TYPE_MODE (integer_type_node));\n@@ -6837,9 +6841,9 @@ expand_expr (exp, target, tmode, modifier)\n         \t/* Check the access right of the pointer.  */\n \t\tin_check_memory_usage = 1;\n \t\tif (size > BITS_PER_UNIT)\n-\t\t  emit_library_call (chkr_check_addr_libfunc, 1, VOIDmode, 3,\n-\t\t\t\t     to, Pmode,\n-\t\t\t\t     GEN_INT (size / BITS_PER_UNIT),\n+\t\t  emit_library_call (chkr_check_addr_libfunc,\n+\t\t\t\t     LCT_CONST_MAKE_BLOCK, VOIDmode, 3, to,\n+\t\t\t\t     Pmode, GEN_INT (size / BITS_PER_UNIT),\n \t\t\t\t     TYPE_MODE (sizetype),\n \t\t\t\t     GEN_INT (memory_usage),\n \t\t\t\t     TYPE_MODE (integer_type_node));\n@@ -8805,7 +8809,8 @@ expand_expr_unaligned (exp, palign)\n \t    /* Check the access right of the pointer.  */\n \t    in_check_memory_usage = 1;\n \t    if (size > BITS_PER_UNIT)\n-\t      emit_library_call (chkr_check_addr_libfunc, 1, VOIDmode, 3,\n+\t      emit_library_call (chkr_check_addr_libfunc,\n+\t\t\t\t LCT_CONST_MAKE_BLOCK, VOIDmode, 3,\n \t\t\t\t to, ptr_mode, GEN_INT (size / BITS_PER_UNIT),\n \t\t\t\t TYPE_MODE (sizetype),\n \t\t\t\t GEN_INT (MEMORY_USE_RO),"}, {"sha": "ffa7d86ad95659b85c57a91bde0a4e055d922c3f", "filename": "gcc/expr.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb1b59ac046c73a55541f5c6d7acc65c6e284b9/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb1b59ac046c73a55541f5c6d7acc65c6e284b9/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=ebb1b59ac046c73a55541f5c6d7acc65c6e284b9", "patch": "@@ -1017,11 +1017,6 @@ extern void emit_push_insn PARAMS ((rtx, enum machine_mode, tree, rtx,\n \t\t\t\t    unsigned int, int, rtx, int, rtx, rtx,\n \t\t\t\t    int, rtx));\n \n-/* Emit library call.  */\n-extern void emit_library_call PARAMS ((rtx, int, enum machine_mode, int, ...));\n-extern rtx emit_library_call_value PARAMS ((rtx, rtx, int, enum machine_mode,\n-\t\t\t\t\t    int, ...));\n-\n /* Expand an assignment that stores the value of FROM into TO. */\n extern rtx expand_assignment PARAMS ((tree, tree, int, int));\n "}, {"sha": "6a9bdc922f7c3cf9189b088165421b7c032b6d6b", "filename": "gcc/function.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb1b59ac046c73a55541f5c6d7acc65c6e284b9/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb1b59ac046c73a55541f5c6d7acc65c6e284b9/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=ebb1b59ac046c73a55541f5c6d7acc65c6e284b9", "patch": "@@ -1453,8 +1453,8 @@ put_var_into_stack (decl)\n     return;\n \n   if (current_function_check_memory_usage)\n-    emit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n-\t\t       XEXP (reg, 0), Pmode,\n+    emit_library_call (chkr_set_right_libfunc, LCT_CONST_MAKE_BLOCK, VOIDmode,\n+\t\t       3, XEXP (reg, 0), Pmode,\n \t\t       GEN_INT (GET_MODE_SIZE (GET_MODE (reg))),\n \t\t       TYPE_MODE (sizetype),\n \t\t       GEN_INT (MEMORY_USE_RW),\n@@ -4684,7 +4684,8 @@ assign_parms (fndecl)\n \t      store_expr (parm, copy, 0);\n \t      emit_move_insn (parmreg, XEXP (copy, 0));\n \t      if (current_function_check_memory_usage)\n-\t\temit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n+\t\temit_library_call (chkr_set_right_libfunc,\n+\t\t\t\t   LCT_CONST_MAKE_BLOCK, VOIDmode, 3,\n \t\t\t\t   XEXP (copy, 0), Pmode,\n \t\t\t\t   GEN_INT (int_size_in_bytes (type)),\n \t\t\t\t   TYPE_MODE (sizetype),\n@@ -4848,8 +4849,8 @@ assign_parms (fndecl)\n \t  if (current_function_check_memory_usage)\n \t    {\n \t      push_to_sequence (conversion_insns);\n-\t      emit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n-\t\t\t\t XEXP (stack_parm, 0), Pmode,\n+\t      emit_library_call (chkr_set_right_libfunc, LCT_CONST_MAKE_BLOCK,\n+\t\t\t\t VOIDmode, 3, XEXP (stack_parm, 0), Pmode,\n \t\t\t\t GEN_INT (GET_MODE_SIZE (GET_MODE\n \t\t\t\t\t\t\t (entry_parm))),\n \t\t\t\t TYPE_MODE (sizetype),"}, {"sha": "8468fbed523ec8d1664fb87b2aaa45d2f779a404", "filename": "gcc/optabs.c", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb1b59ac046c73a55541f5c6d7acc65c6e284b9/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb1b59ac046c73a55541f5c6d7acc65c6e284b9/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=ebb1b59ac046c73a55541f5c6d7acc65c6e284b9", "patch": "@@ -1692,7 +1692,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n       /* Pass 1 for NO_QUEUE so we don't lose any increments\n \t if the libcall is cse'd or moved.  */\n       value = emit_library_call_value (binoptab->handlers[(int) mode].libfunc,\n-\t\t\t\t       NULL_RTX, 1, mode, 2,\n+\t\t\t\t       NULL_RTX, LCT_CONST, mode, 2,\n \t\t\t\t       op0, mode, op1x, op1_mode);\n \n       insns = get_insns ();\n@@ -2175,7 +2175,7 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n       /* Pass 1 for NO_QUEUE so we don't lose any increments\n \t if the libcall is cse'd or moved.  */\n       value = emit_library_call_value (unoptab->handlers[(int) mode].libfunc,\n-\t\t\t\t       NULL_RTX, 1, mode, 1, op0, mode);\n+\t\t\t\t       NULL_RTX, LCT_CONST, mode, 1, op0, mode);\n       insns = get_insns ();\n       end_sequence ();\n \n@@ -2493,7 +2493,7 @@ expand_complex_abs (mode, op0, target, unsignedp)\n       /* Pass 1 for NO_QUEUE so we don't lose any increments\n \t if the libcall is cse'd or moved.  */\n       value = emit_library_call_value (abs_optab->handlers[(int) mode].libfunc,\n-\t\t\t\t       NULL_RTX, 1, submode, 1, op0, mode);\n+\t\t\t\t       NULL_RTX, LCT_CONST, submode, 1, op0, mode);\n       insns = get_insns ();\n       end_sequence ();\n \n@@ -3033,14 +3033,14 @@ prepare_cmp_insn (px, py, pcomparison, size, pmode, punsignedp, align,\n #endif\n \t{\n #ifdef TARGET_MEM_FUNCTIONS\n-\t  emit_library_call (memcmp_libfunc, 2,\n+\t  emit_library_call (memcmp_libfunc, LCT_PURE_MAKE_BLOCK,\n \t\t\t     TYPE_MODE (integer_type_node), 3,\n \t\t\t     XEXP (x, 0), Pmode, XEXP (y, 0), Pmode,\n \t\t\t     convert_to_mode (TYPE_MODE (sizetype), size,\n \t\t\t\t\t      TREE_UNSIGNED (sizetype)),\n \t\t\t     TYPE_MODE (sizetype));\n #else\n-\t  emit_library_call (bcmp_libfunc, 2,\n+\t  emit_library_call (bcmp_libfunc, LCT_PURE_MAKE_BLOCK,\n \t\t\t     TYPE_MODE (integer_type_node), 3,\n \t\t\t     XEXP (x, 0), Pmode, XEXP (y, 0), Pmode,\n \t\t\t     convert_to_mode (TYPE_MODE (integer_type_node),\n@@ -3487,7 +3487,8 @@ prepare_float_lib_cmp (px, py, pcomparison, pmode, punsignedp)\n   if (libfunc == 0)\n     abort ();\n \n-  emit_library_call (libfunc, 1, word_mode, 2, x, mode, y, mode);\n+  emit_library_call (libfunc, LCT_CONST_MAKE_BLOCK, word_mode, 2, x, mode, y,\n+\t\t     mode);\n \n   /* Immediately move the result of the libcall into a pseudo\n      register so reload doesn't clobber the value if it needs\n@@ -4111,9 +4112,9 @@ expand_float (to, from, unsignedp)\n \n       start_sequence ();\n \n-      value = emit_library_call_value (libfcn, NULL_RTX, 1,\n-\t\t\t\t       GET_MODE (to),\n-\t\t\t\t       1, from, GET_MODE (from));\n+      value = emit_library_call_value (libfcn, NULL_RTX, LCT_CONST,\n+\t\t\t\t       GET_MODE (to), 1, from,\n+\t\t\t\t       GET_MODE (from));\n       insns = get_insns ();\n       end_sequence ();\n \n@@ -4345,9 +4346,9 @@ expand_fix (to, from, unsignedp)\n \n       start_sequence ();\n \n-      value = emit_library_call_value (libfcn, NULL_RTX, 1, GET_MODE (to),\n-\n-\t\t\t\t       1, from, GET_MODE (from));\n+      value = emit_library_call_value (libfcn, NULL_RTX, LCT_CONST,\n+\t\t\t\t       GET_MODE (to), 1, from,\n+\t\t\t\t       GET_MODE (from));\n       insns = get_insns ();\n       end_sequence ();\n "}, {"sha": "a866595d23c231fdfb955e56f46d0a06fc1cbcc9", "filename": "gcc/rtl.h", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb1b59ac046c73a55541f5c6d7acc65c6e284b9/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb1b59ac046c73a55541f5c6d7acc65c6e284b9/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=ebb1b59ac046c73a55541f5c6d7acc65c6e284b9", "patch": "@@ -1913,11 +1913,21 @@ extern void rrotate_double\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t\t HOST_WIDE_INT *));\n \n /* In calls.c */\n-extern void emit_library_call\t\tPARAMS ((rtx, int, enum machine_mode,\n-\t\t\t\t\t\t  int, ...));\n-extern rtx emit_library_call_value\tPARAMS ((rtx, rtx, int,\n-\t\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t\t int, ...));\n+enum libcall_type\n+{\n+  LCT_NORMAL = 0,\n+  LCT_CONST = 1,\n+  LCT_PURE = 2,\n+  LCT_CONST_MAKE_BLOCK = 3,\n+  LCT_PURE_MAKE_BLOCK = 4\n+};\n+\n+extern void emit_library_call\t\tPARAMS ((rtx, enum libcall_type,\n+\t\t\t\t\t\t enum machine_mode, int,\n+\t\t\t\t\t\t ...));\n+extern rtx emit_library_call_value\tPARAMS ((rtx, rtx, enum libcall_type,\n+\t\t\t\t\t\t enum machine_mode, int,\n+\t\t\t\t\t\t ...));\n \n /* In unroll.c */\n extern int set_dominates_use\t\tPARAMS ((int, int, int, rtx, rtx));"}, {"sha": "11a713225e0b8b4e4efb402590b4dad69672553a", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb1b59ac046c73a55541f5c6d7acc65c6e284b9/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb1b59ac046c73a55541f5c6d7acc65c6e284b9/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=ebb1b59ac046c73a55541f5c6d7acc65c6e284b9", "patch": "@@ -713,7 +713,7 @@ expand_computed_goto (exp)\n   emit_queue ();\n   /* Be sure the function is executable.  */\n   if (current_function_check_memory_usage)\n-    emit_library_call (chkr_check_exec_libfunc, 1,\n+    emit_library_call (chkr_check_exec_libfunc, LCT_CONST_MAKE_BLOCK,\n \t\t       VOIDmode, 1, x, ptr_mode);\n \n   do_pending_stack_adjust ();"}]}