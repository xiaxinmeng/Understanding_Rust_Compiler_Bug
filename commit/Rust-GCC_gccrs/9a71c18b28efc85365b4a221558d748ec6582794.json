{"sha": "9a71c18b28efc85365b4a221558d748ec6582794", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWE3MWMxOGIyOGVmYzg1MzY1YjRhMjIxNTU4ZDc0OGVjNjU4Mjc5NA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-04-03T03:41:20Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-04-03T03:41:20Z"}, "message": "Re-implement allocation of base class subobjects.\n\n\t* tree.c (unshare_base_binfos): New fn.\n\t(layout_basetypes): Use it.  Now handles offsets of both virtual and\n\tnon-virtual bases, after layout_type.\n\t(layout_vbasetypes): Remove.\n\t(build_base_fields): Generate FIELD_DECLs for each non-virtual base.\n\t(build_vbase_pointer_fields): Split out from old layout_basetypes.\n\t* class.c (finish_base_struct): Lose offset handling code.\n\tMove nonvdtor warning here.  Don't mess with t_binfo anymore.\n\t(finish_struct_1): Don't mess with t_binfo anymore.  Use fns above.\n\t* cp-tree.h: Adjust.\n\nFrom-SVN: r18973", "tree": {"sha": "0866e543e8c42660af1ccddc0502574d3c33cf14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0866e543e8c42660af1ccddc0502574d3c33cf14"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a71c18b28efc85365b4a221558d748ec6582794", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a71c18b28efc85365b4a221558d748ec6582794", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a71c18b28efc85365b4a221558d748ec6582794", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a71c18b28efc85365b4a221558d748ec6582794/comments", "author": null, "committer": null, "parents": [{"sha": "516c23423ecba82c46ba633870014dac2db0dd91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/516c23423ecba82c46ba633870014dac2db0dd91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/516c23423ecba82c46ba633870014dac2db0dd91"}], "stats": {"total": 414, "additions": 187, "deletions": 227}, "files": [{"sha": "76101855e08e2c0a7e1c9203b722bc0d47e31138", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a71c18b28efc85365b4a221558d748ec6582794/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a71c18b28efc85365b4a221558d748ec6582794/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9a71c18b28efc85365b4a221558d748ec6582794", "patch": "@@ -1,3 +1,17 @@\n+Fri Apr  3 02:22:59 1998  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\tRe-implement allocation of base class subobjects.\n+\t* tree.c (unshare_base_binfos): New fn.\n+\t(layout_basetypes): Use it.  Now handles offsets of both virtual and\n+\tnon-virtual bases, after layout_type.\n+\t(layout_vbasetypes): Remove.\n+\t(build_base_fields): Generate FIELD_DECLs for each non-virtual base.\n+\t(build_vbase_pointer_fields): Split out from old layout_basetypes.\n+\t* class.c (finish_base_struct): Lose offset handling code.\n+\tMove nonvdtor warning here.  Don't mess with t_binfo anymore.\n+\t(finish_struct_1): Don't mess with t_binfo anymore.  Use fns above.\n+\t* cp-tree.h: Adjust.\n+\n Thu Apr  2 14:25:13 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* cp-tree.h: Lose CLASSTYPE_VBASE_SIZE, some unused stuff.\n@@ -12,7 +26,7 @@ Wed Apr  1 18:22:25 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* class.c, Make sure system.h is included just after config.h.\n \tDelete lingering stdio and errno references too.\n-\t* decl.c, errfn.c, parse.y, ptree.c search.c, xrefc.: Likewwise.\n+\t* decl.c, errfn.c, parse.y, ptree.c search.c, xref.c: Likewise.\n \t\n Wed Apr  1 15:38:36 1998  Jason Merrill  <jason@yorick.cygnus.com>\n "}, {"sha": "c39caac5b119db1e21d689e1f6c716f2aa157bc3", "filename": "gcc/cp/class.c", "status": "modified", "additions": 38, "deletions": 86, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a71c18b28efc85365b4a221558d748ec6582794/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a71c18b28efc85365b4a221558d748ec6582794/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=9a71c18b28efc85365b4a221558d748ec6582794", "patch": "@@ -124,7 +124,7 @@ static void modify_all_direct_vtables PROTO((tree, int, tree, tree,\n static void modify_all_indirect_vtables PROTO((tree, int, int, tree,\n \t\t\t\t\t       tree, tree));\n static void build_class_init_list PROTO((tree));\n-static int finish_base_struct PROTO((tree, struct base_info *, tree));\n+static int finish_base_struct PROTO((tree, struct base_info *));\n \n /* Way of stacking language names.  */\n tree *current_lang_base, *current_lang_stack;\n@@ -1526,17 +1526,14 @@ struct base_info\n    offsets include that offset in theirs.\n \n    Returns the index of the first base class to have virtual functions,\n-   or -1 if no such base class.\n-\n-   Note that at this point TYPE_BINFO (t) != t_binfo.  */\n+   or -1 if no such base class.  */\n \n static int\n-finish_base_struct (t, b, t_binfo)\n+finish_base_struct (t, b)\n      tree t;\n      struct base_info *b;\n-     tree t_binfo;\n {\n-  tree binfos = BINFO_BASETYPES (t_binfo);\n+  tree binfos = TYPE_BINFO_BASETYPES (t);\n   int i, n_baseclasses = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n   int first_vfn_base_index = -1;\n   bzero ((char *) b, sizeof (struct base_info));\n@@ -1546,6 +1543,13 @@ finish_base_struct (t, b, t_binfo)\n       tree base_binfo = TREE_VEC_ELT (binfos, i);\n       tree basetype = BINFO_TYPE (base_binfo);\n \n+      /* Effective C++ rule 14.  We only need to check TYPE_VIRTUAL_P\n+\t here because the case of virtual functions but non-virtual\n+\t dtor is handled in finish_struct_1.  */\n+      if (warn_ecpp && ! TYPE_VIRTUAL_P (basetype)\n+\t  && TYPE_HAS_DESTRUCTOR (basetype))\n+\tcp_warning (\"base class `%#T' has a non-virtual destructor\", basetype);\n+\n       /* If the type of basetype is incomplete, then\n \t we already complained about that fact\n \t (and we should have fixed it up as well).  */\n@@ -1592,36 +1596,6 @@ finish_base_struct (t, b, t_binfo)\n       TYPE_OVERLOADS_ARRAY_REF (t) |= TYPE_OVERLOADS_ARRAY_REF (basetype);\n       TYPE_OVERLOADS_ARROW (t) |= TYPE_OVERLOADS_ARROW (basetype);\n \n-      if (! TREE_VIA_VIRTUAL (base_binfo)\n-\t  && BINFO_BASETYPES (base_binfo))\n-\t{\n-\t  tree base_binfos = BINFO_BASETYPES (base_binfo);\n-\t  tree chain = NULL_TREE;\n-\t  int j;\n-\n-\t  /* Now unshare the structure beneath BASE_BINFO.  */\n-\t  for (j = TREE_VEC_LENGTH (base_binfos)-1;\n-\t       j >= 0; j--)\n-\t    {\n-\t      tree base_base_binfo = TREE_VEC_ELT (base_binfos, j);\n-\t      if (! TREE_VIA_VIRTUAL (base_base_binfo))\n-\t\tTREE_VEC_ELT (base_binfos, j)\n-\t\t  = make_binfo (BINFO_OFFSET (base_base_binfo),\n-\t\t\t\tbase_base_binfo,\n-\t\t\t\tBINFO_VTABLE (base_base_binfo),\n-\t\t\t\tBINFO_VIRTUALS (base_base_binfo),\n-\t\t\t\tchain);\n-\t      chain = TREE_VEC_ELT (base_binfos, j);\n-\t      TREE_VIA_PUBLIC (chain) = TREE_VIA_PUBLIC (base_base_binfo);\n-\t      TREE_VIA_PROTECTED (chain) = TREE_VIA_PROTECTED (base_base_binfo);\n-\t      BINFO_INHERITANCE_CHAIN (chain) = base_binfo;\n-\t    }\n-\n-\t  /* Completely unshare potentially shared data, and\n-\t     update what is ours.  */\n-\t  propagate_binfo_offsets (base_binfo, BINFO_OFFSET (base_binfo));\n-\t}\n-\n       if (! TREE_VIA_VIRTUAL (base_binfo))\n \tCLASSTYPE_N_SUPERCLASSES (t) += 1;\n \n@@ -1644,8 +1618,8 @@ finish_base_struct (t, b, t_binfo)\n \t      /* Update these two, now that we know what vtable we are\n \t\t going to extend.  This is so that we can add virtual\n \t\t functions, and override them properly.  */\n-\t      BINFO_VTABLE (t_binfo) = TYPE_BINFO_VTABLE (basetype);\n-\t      BINFO_VIRTUALS (t_binfo) = TYPE_BINFO_VIRTUALS (basetype);\n+\t      TYPE_BINFO_VTABLE (t) = TYPE_BINFO_VTABLE (basetype);\n+\t      TYPE_BINFO_VIRTUALS (t) = TYPE_BINFO_VIRTUALS (basetype);\n \t      b->has_virtual = CLASSTYPE_VSIZE (basetype);\n \t      b->vfield = CLASSTYPE_VFIELD (basetype);\n \t      b->vfields = copy_list (CLASSTYPE_VFIELDS (basetype));\n@@ -1693,8 +1667,8 @@ finish_base_struct (t, b, t_binfo)\n \t\t  /* Update these two, now that we know what vtable we are\n \t\t     going to extend.  This is so that we can add virtual\n \t\t     functions, and override them properly.  */\n-\t\t  BINFO_VTABLE (t_binfo) = TYPE_BINFO_VTABLE (basetype);\n-\t\t  BINFO_VIRTUALS (t_binfo) = TYPE_BINFO_VIRTUALS (basetype);\n+\t\t  TYPE_BINFO_VTABLE (t) = TYPE_BINFO_VTABLE (basetype);\n+\t\t  TYPE_BINFO_VIRTUALS (t) = TYPE_BINFO_VIRTUALS (basetype);\n \t\t  b->has_virtual = CLASSTYPE_VSIZE (basetype);\n \t\t  b->vfield = CLASSTYPE_VFIELD (basetype);\n \t\t  CLASSTYPE_VFIELD (t) = b->vfield;\n@@ -1720,25 +1694,27 @@ finish_base_struct (t, b, t_binfo)\n \t}\n     }\n \n-  /* Must come after offsets are fixed for all bases.  */\n+  /* This comment said \"Must come after offsets are fixed for all bases.\"\n+     Well, now this happens before the offsets are fixed, but it seems to\n+     work fine.  Guess we'll see...  */\n   for (i = 0; i < n_baseclasses; i++)\n     {\n       tree base_binfo = TREE_VEC_ELT (binfos, i);\n       tree basetype = BINFO_TYPE (base_binfo);\n \n-      if (get_base_distance (basetype, t_binfo, 0, (tree*)0) == -2)\n+      if (get_base_distance (basetype, t, 0, (tree*)0) == -2)\n \t{\n \t  cp_warning (\"direct base `%T' inaccessible in `%T' due to ambiguity\",\n \t\t      basetype, t);\n \t}\n     }\n   {\n-    tree v = get_vbase_types (t_binfo);\n+    tree v = get_vbase_types (t);\n \n     for (; v; v = TREE_CHAIN (v))\n       {\n \ttree basetype = BINFO_TYPE (v);\n-\tif (get_base_distance (basetype, t_binfo, 0, (tree*)0) == -2)\n+\tif (get_base_distance (basetype, t, 0, (tree*)0) == -2)\n \t  {\n \t    if (extra_warnings)\n \t      cp_warning (\"virtual base `%T' inaccessible in `%T' due to ambiguity\",\n@@ -3088,7 +3064,6 @@ finish_struct_1 (t, warn_anon)\n   int const_sans_init = 0;\n   int ref_sans_init = 0;\n   int nonprivate_method = 0;\n-  tree t_binfo = TYPE_BINFO (t);\n   tree access_decls = NULL_TREE;\n   int aggregate = 1;\n   int empty = 1;\n@@ -3125,13 +3100,6 @@ finish_struct_1 (t, warn_anon)\n     }\n #endif\n \n-#if 0\n-  if (flag_rtti)\n-    build_t_desc (t, 0);\n-#endif\n-\n-  TYPE_BINFO (t) = NULL_TREE;\n-\n   old = suspend_momentary ();\n \n   /* Install struct as DECL_FIELD_CONTEXT of each field decl.\n@@ -3141,22 +3109,16 @@ finish_struct_1 (t, warn_anon)\n      Store 0 there, except for \": 0\" fields (so we can find them\n      and delete them, below).  */\n \n-  if (t_binfo && BINFO_BASETYPES (t_binfo))\n-    n_baseclasses = TREE_VEC_LENGTH (BINFO_BASETYPES (t_binfo));\n+  if (TYPE_BINFO_BASETYPES (t))\n+    n_baseclasses = TREE_VEC_LENGTH (TYPE_BINFO_BASETYPES (t));\n   else\n     n_baseclasses = 0;\n \n   if (n_baseclasses > 0)\n     {\n       struct base_info base_info;\n \n-      /* If using multiple inheritance, this may cause variants of our\n-\t basetypes to be used (instead of their canonical forms).  */\n-      tree vf = layout_basetypes (t, BINFO_BASETYPES (t_binfo));\n-      last_x = tree_last (vf);\n-      fields = chainon (vf, fields);\n-\n-      first_vfn_base_index = finish_base_struct (t, &base_info, t_binfo);\n+      first_vfn_base_index = finish_base_struct (t, &base_info);\n       /* Remember where we got our vfield from.  */\n       CLASSTYPE_VFIELD_PARENT (t) = first_vfn_base_index;\n       has_virtual = base_info.has_virtual;\n@@ -3168,8 +3130,8 @@ finish_struct_1 (t, warn_anon)\n       cant_have_default_ctor = base_info.cant_have_default_ctor;\n       cant_have_const_ctor = base_info.cant_have_const_ctor;\n       no_const_asn_ref = base_info.no_const_asn_ref;\n-      n_baseclasses = TREE_VEC_LENGTH (BINFO_BASETYPES (t_binfo));\n       aggregate = 0;\n+      empty = 0;\n     }\n   else\n     {\n@@ -3179,7 +3141,6 @@ finish_struct_1 (t, warn_anon)\n       vfield = NULL_TREE;\n       vfields = NULL_TREE;\n       CLASSTYPE_RTTI (t) = NULL_TREE;\n-      last_x = NULL_TREE;\n       cant_have_default_ctor = 0;\n       cant_have_const_ctor = 0;\n       no_const_asn_ref = 0;\n@@ -3198,8 +3159,6 @@ finish_struct_1 (t, warn_anon)\n   /* The three of these are approximations which may later be\n      modified.  Needed at this point to make add_virtual_function\n      and modify_vtable_entries work.  */\n-  TREE_CHAIN (t_binfo) = TYPE_BINFO (t);\n-  TYPE_BINFO (t) = t_binfo;\n   CLASSTYPE_VFIELDS (t) = vfields;\n   CLASSTYPE_VFIELD (t) = vfield;\n \n@@ -3250,7 +3209,8 @@ finish_struct_1 (t, warn_anon)\n \t}\n     }\n \n-  for (x = TYPE_FIELDS (t); x; x = TREE_CHAIN (x))\n+  last_x = NULL_TREE;\n+  for (x = fields; x; x = TREE_CHAIN (x))\n     {\n       GNU_xref_member (current_class_name, x);\n \n@@ -3797,6 +3757,9 @@ finish_struct_1 (t, warn_anon)\n     \n   }\n \n+  if (n_baseclasses)\n+    fields = chainon (build_vbase_pointer_fields (t), fields);\n+\n   if (vfield == NULL_TREE && has_virtual)\n     {\n       /* We build this decl with ptr_type_node, and\n@@ -3888,21 +3851,8 @@ finish_struct_1 (t, warn_anon)\n \n   TYPE_FIELDS (t) = fields;\n \n-  /* Pass layout information about base classes to layout_type, if any.  */\n   if (n_baseclasses)\n-    {\n-      tree pseudo_basetype = TREE_TYPE (base_layout_decl);\n-\n-      TREE_CHAIN (base_layout_decl) = TYPE_FIELDS (t);\n-      TYPE_FIELDS (t) = base_layout_decl;\n-\n-      TYPE_SIZE (pseudo_basetype) = CLASSTYPE_SIZE (t);\n-      TYPE_MODE (pseudo_basetype) = TYPE_MODE (t);\n-      TYPE_ALIGN (pseudo_basetype) = CLASSTYPE_ALIGN (t);\n-      DECL_ALIGN (base_layout_decl) = TYPE_ALIGN (pseudo_basetype);\n-      /* Don't re-use old size.  */\n-      DECL_SIZE (base_layout_decl) = NULL_TREE;\n-    }\n+    TYPE_FIELDS (t) = chainon (build_base_fields (t), fields);\n   else if (empty)\n     {\n       /* C++: do not let empty structures exist.  */\n@@ -3914,16 +3864,13 @@ finish_struct_1 (t, warn_anon)\n \n   layout_type (t);\n \n-  /* Remember the size, mode and alignment of the class before adding\n+  /* Remember the size and alignment of the class before adding\n      the virtual bases.  */\n   CLASSTYPE_SIZE (t) = TYPE_SIZE (t);\n   CLASSTYPE_ALIGN (t) = TYPE_ALIGN (t);\n \n   finish_struct_anon (t);\n \n-  if (n_baseclasses || empty)\n-    TYPE_FIELDS (t) = TREE_CHAIN (TYPE_FIELDS (t));\n-\n   /* Set the TYPE_DECL for this type to contain the right\n      value for DECL_OFFSET, so that we can use it as part\n      of a COMPONENT_REF for multiple inheritance.  */\n@@ -3935,11 +3882,16 @@ finish_struct_1 (t, warn_anon)\n      virtual function table.  */\n   pending_hard_virtuals = nreverse (pending_hard_virtuals);\n \n+  if (n_baseclasses)\n+    /* layout_basetypes will remove the base subobject fields.  */\n+    max_has_virtual = layout_basetypes (t, max_has_virtual);\n+  else if (empty)\n+    TYPE_FIELDS (t) = fields;\n+\n   if (TYPE_USES_VIRTUAL_BASECLASSES (t))\n     {\n       tree vbases;\n \n-      max_has_virtual = layout_vbasetypes (t, max_has_virtual);\n       vbases = CLASSTYPE_VBASECLASSES (t);\n       CLASSTYPE_N_VBASECLASSES (t) = list_length (vbases);\n "}, {"sha": "c62fe082a97b9f657d6c95108d2b555d066d3b8f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a71c18b28efc85365b4a221558d748ec6582794/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a71c18b28efc85365b4a221558d748ec6582794/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9a71c18b28efc85365b4a221558d748ec6582794", "patch": "@@ -728,13 +728,7 @@ struct lang_type\n #define CLASSTYPE_MTABLE_ENTRY(NODE) (TYPE_LANG_SPECIFIC(NODE)->memoized_table_entry)\n \n /* These are the size, mode and alignment of the type without its\n-   virtual base classes, for when we use this type as a base itself.\n-\n-   CLASSTYPE_SIZE is also used during finish_struct_1 to remember the total\n-   size of the baseclasses defined for the type.  We do this because it is\n-   desirable to layout such information before beginning to process the\n-   class itself, and we don't want to compute it second time when actually\n-   laying out the type for real.  */\n+   virtual base classes, for when we use this type as a base itself.  */\n #define CLASSTYPE_SIZE(NODE) (TYPE_LANG_SPECIFIC(NODE)->size)\n #define CLASSTYPE_ALIGN(NODE) (TYPE_LANG_SPECIFIC(NODE)->align)\n \n@@ -2591,9 +2585,9 @@ extern tree break_out_calls\t\t\tPROTO((tree));\n extern tree build_cplus_method_type\t\tPROTO((tree, tree, tree));\n extern tree build_cplus_staticfn_type\t\tPROTO((tree, tree, tree));\n extern tree build_cplus_array_type\t\tPROTO((tree, tree));\n-extern void propagate_binfo_offsets\t\tPROTO((tree, tree));\n-extern int layout_vbasetypes\t\t\tPROTO((tree, int));\n-extern tree layout_basetypes\t\t\tPROTO((tree, tree));\n+extern int layout_basetypes\t\t\tPROTO((tree, int));\n+extern tree build_vbase_pointer_fields\t\tPROTO((tree));\n+extern tree build_base_fields\t\t\tPROTO((tree));\n extern tree hash_tree_cons\t\t\tPROTO((int, int, int, tree, tree, tree));\n extern tree hash_tree_chain\t\t\tPROTO((tree, tree));\n extern tree hash_chainon\t\t\tPROTO((tree, tree));"}, {"sha": "8f4d02d70ffa8cd1a3e6d4fdd3a107d41db70801", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 130, "deletions": 130, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a71c18b28efc85365b4a221558d748ec6582794/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a71c18b28efc85365b4a221558d748ec6582794/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=9a71c18b28efc85365b4a221558d748ec6582794", "patch": "@@ -42,6 +42,8 @@ static void list_hash_add PROTO((int, tree));\n static int list_hash PROTO((tree, tree, tree));\n static tree list_hash_lookup PROTO((int, int, int, int, tree, tree,\n \t\t\t\t    tree));\n+static void propagate_binfo_offsets PROTO((tree, tree));\n+static void unshare_base_binfos PROTO((tree));\n \n #define CEIL(x,y) (((x) + (y) - 1) / (y))\n \n@@ -548,7 +550,7 @@ cp_build_type_variant (type, constp, volatilep)\n    Note that we don't have to worry about having two paths to the\n    same base type, since this type owns its association list.  */\n \n-void\n+static void\n propagate_binfo_offsets (binfo, offset)\n      tree binfo;\n      tree offset;\n@@ -588,31 +590,8 @@ propagate_binfo_offsets (binfo, offset)\n #else\n \t  BINFO_OFFSET (base_binfo) = offset;\n #endif\n-\t  if (base_binfos)\n-\t    {\n-\t      int k;\n-\t      tree chain = NULL_TREE;\n-\n-\t      /* Now unshare the structure beneath BASE_BINFO.  */\n-\t      for (k = TREE_VEC_LENGTH (base_binfos)-1;\n-\t\t   k >= 0; k--)\n-\t\t{\n-\t\t  tree base_base_binfo = TREE_VEC_ELT (base_binfos, k);\n-\t\t  if (! TREE_VIA_VIRTUAL (base_base_binfo))\n-\t\t    TREE_VEC_ELT (base_binfos, k)\n-\t\t      = make_binfo (BINFO_OFFSET (base_base_binfo),\n-\t\t\t\t    base_base_binfo,\n-\t\t\t\t    BINFO_VTABLE (base_base_binfo),\n-\t\t\t\t    BINFO_VIRTUALS (base_base_binfo),\n-\t\t\t\t    chain);\n-\t\t  chain = TREE_VEC_ELT (base_binfos, k);\n-\t\t  TREE_VIA_PUBLIC (chain) = TREE_VIA_PUBLIC (base_base_binfo);\n-\t\t  TREE_VIA_PROTECTED (chain) = TREE_VIA_PROTECTED (base_base_binfo);\n-\t\t  BINFO_INHERITANCE_CHAIN (chain) = base_binfo;\n-\t\t}\n-\t      /* Now propagate the offset to the base types.  */\n-\t      propagate_binfo_offsets (base_binfo, offset);\n-\t    }\n+\n+\t  unshare_base_binfos (base_binfo);\n \n \t  /* Go to our next class that counts for offset propagation.  */\n \t  i = j;\n@@ -622,19 +601,59 @@ propagate_binfo_offsets (binfo, offset)\n     }\n }\n \n-/* Compute the actual offsets that our virtual base classes\n-   will have *for this type*.  This must be performed after\n-   the fields are laid out, since virtual baseclasses must\n-   lay down at the end of the record.\n+/* Makes new binfos for the indirect bases under BASE_BINFO, and updates\n+   BINFO_OFFSET for them and their bases.  */\n \n-   Returns the maximum number of virtual functions any of the virtual\n+static void\n+unshare_base_binfos (base_binfo)\n+     tree base_binfo;\n+{\n+  if (BINFO_BASETYPES (base_binfo))\n+    {\n+      tree base_binfos = BINFO_BASETYPES (base_binfo);\n+      tree chain = NULL_TREE;\n+      int j;\n+\n+      /* Now unshare the structure beneath BASE_BINFO.  */\n+      for (j = TREE_VEC_LENGTH (base_binfos)-1;\n+\t   j >= 0; j--)\n+\t{\n+\t  tree base_base_binfo = TREE_VEC_ELT (base_binfos, j);\n+\t  if (! TREE_VIA_VIRTUAL (base_base_binfo))\n+\t    TREE_VEC_ELT (base_binfos, j)\n+\t      = make_binfo (BINFO_OFFSET (base_base_binfo),\n+\t\t\t    base_base_binfo,\n+\t\t\t    BINFO_VTABLE (base_base_binfo),\n+\t\t\t    BINFO_VIRTUALS (base_base_binfo),\n+\t\t\t    chain);\n+\t  chain = TREE_VEC_ELT (base_binfos, j);\n+\t  TREE_VIA_PUBLIC (chain) = TREE_VIA_PUBLIC (base_base_binfo);\n+\t  TREE_VIA_PROTECTED (chain) = TREE_VIA_PROTECTED (base_base_binfo);\n+\t  BINFO_INHERITANCE_CHAIN (chain) = base_binfo;\n+\t}\n+\n+      /* Completely unshare potentially shared data, and\n+\t update what is ours.  */\n+      propagate_binfo_offsets (base_binfo, BINFO_OFFSET (base_binfo));\n+    }\n+}\n+\n+/* Finish the work of layout_record, now taking virtual bases into account.\n+   Also compute the actual offsets that our base classes will have.\n+   This must be performed after the fields are laid out, since virtual\n+   baseclasses must lay down at the end of the record.\n+\n+   Returns the maximum number of virtual functions any of the\n    baseclasses provide.  */\n \n int\n-layout_vbasetypes (rec, max)\n+layout_basetypes (rec, max)\n      tree rec;\n      int max;\n {\n+  tree binfos = TYPE_BINFO_BASETYPES (rec);\n+  int i, n_baseclasses = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n+\n   /* Get all the virtual base types that this type uses.\n      The TREE_VALUE slot holds the virtual baseclass type.  */\n   tree vbase_types = get_vbase_types (rec);\n@@ -672,8 +691,7 @@ layout_vbasetypes (rec, max)\n       else\n \t{\n \t  /* Give each virtual base type the alignment it wants.  */\n-\t  const_size = CEIL (const_size, TYPE_ALIGN (basetype))\n-\t    * TYPE_ALIGN (basetype);\n+\t  const_size = CEIL (const_size, desired_align) * desired_align;\n \t  offset = size_int (CEIL (const_size, BITS_PER_UNIT));\n \t}\n \n@@ -704,85 +722,106 @@ layout_vbasetypes (rec, max)\n   if (const_size != nonvirtual_const_size)\n     TYPE_SIZE (rec) = size_int (const_size);\n \n-  /* Now propagate offset information throughout the lattice\n-     under the vbase type.  */\n-  for (vbase_types = CLASSTYPE_VBASECLASSES (rec); vbase_types;\n-       vbase_types = TREE_CHAIN (vbase_types))\n+  /* Now propagate offset information throughout the lattice.  */\n+  for (i = 0; i < n_baseclasses; i++)\n     {\n-      tree base_binfos = BINFO_BASETYPES (vbase_types);\n-\n-      BINFO_INHERITANCE_CHAIN (vbase_types) = TYPE_BINFO (rec);\n+      register tree base_binfo = TREE_VEC_ELT (binfos, i);\n+      register tree basetype = BINFO_TYPE (base_binfo);\n+      tree field = TYPE_FIELDS (rec);\n \n-      if (base_binfos)\n-\t{\n-\t  tree chain = NULL_TREE;\n-\t  int j;\n-\t  /* Now unshare the structure beneath BASE_BINFO.  */\n+      if (TREE_VIA_VIRTUAL (base_binfo))\n+\tcontinue;\n \n-\t  for (j = TREE_VEC_LENGTH (base_binfos)-1;\n-\t       j >= 0; j--)\n-\t    {\n-\t      tree base_base_binfo = TREE_VEC_ELT (base_binfos, j);\n-\t      if (! TREE_VIA_VIRTUAL (base_base_binfo))\n-\t\tTREE_VEC_ELT (base_binfos, j)\n-\t\t  = make_binfo (BINFO_OFFSET (base_base_binfo),\n-\t\t\t\tbase_base_binfo,\n-\t\t\t\tBINFO_VTABLE (base_base_binfo),\n-\t\t\t\tBINFO_VIRTUALS (base_base_binfo),\n-\t\t\t\tchain);\n-\t      chain = TREE_VEC_ELT (base_binfos, j);\n-\t      TREE_VIA_PUBLIC (chain) = TREE_VIA_PUBLIC (base_base_binfo);\n-\t      TREE_VIA_PROTECTED (chain) = TREE_VIA_PROTECTED (base_base_binfo);\n-\t      BINFO_INHERITANCE_CHAIN (chain) = vbase_types;\n-\t    }\n+      my_friendly_assert (TREE_TYPE (field) == basetype, 23897);\n+      BINFO_OFFSET (base_binfo)\n+\t= size_int (CEIL (TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field)),\n+\t\t\t  BITS_PER_UNIT));\n+      unshare_base_binfos (base_binfo);\n+      TYPE_FIELDS (rec) = TREE_CHAIN (field);\n+    }\n \n-\t  propagate_binfo_offsets (vbase_types, BINFO_OFFSET (vbase_types));\n-\t}\n+  for (vbase_types = CLASSTYPE_VBASECLASSES (rec); vbase_types;\n+       vbase_types = TREE_CHAIN (vbase_types))\n+    {\n+      BINFO_INHERITANCE_CHAIN (vbase_types) = TYPE_BINFO (rec);\n+      unshare_base_binfos (vbase_types);\n     }\n \n   return max;\n }\n \n-/* Lay out the base types of a record type, REC.\n-   Tentatively set the size and alignment of REC\n-   according to the base types alone.\n+/* Returns a list of fields to stand in for the base class subobjects\n+   of REC.  These fields are later removed by layout_basetypes.  */\n+\n+tree\n+build_base_fields (rec)\n+     tree rec;\n+{\n+  /* Chain to hold all the new FIELD_DECLs which stand in for base class\n+     subobjects.  */\n+  tree base_decls = NULL_TREE;\n+  tree binfos = TYPE_BINFO_BASETYPES (rec);\n+  int n_baseclasses = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n+  tree decl;\n+  int i;\n+  unsigned int base_align = 0;\n+\n+  for (i = 0; i < n_baseclasses; ++i)\n+    {\n+      register tree base_binfo = TREE_VEC_ELT (binfos, i);\n+      register tree basetype = BINFO_TYPE (base_binfo);\n \n-   Offsets for immediate nonvirtual baseclasses are also computed here.\n+      if (TYPE_SIZE (basetype) == 0)\n+\t/* This error is now reported in xref_tag, thus giving better\n+\t   location information.  */\n+\tcontinue;\n \n-   TYPE_BINFO (REC) should be NULL_TREE on entry, and this routine\n-   creates a list of base_binfos in TYPE_BINFO (REC) from BINFOS.\n+      if (TREE_VIA_VIRTUAL (base_binfo))\n+\tcontinue;\n \n-   Returns list of virtual base class pointers in a FIELD_DECL chain.  */\n+      decl = build_lang_field_decl (FIELD_DECL, NULL_TREE, basetype);\n+      DECL_ARTIFICIAL (decl) = 1;\n+      DECL_FIELD_CONTEXT (decl) = DECL_CLASS_CONTEXT (decl) = rec;\n+      DECL_SIZE (decl) = CLASSTYPE_SIZE (basetype);\n+      DECL_ALIGN (decl) = CLASSTYPE_ALIGN (basetype);\n+      TREE_CHAIN (decl) = base_decls;\n+      base_decls = decl;\n+\n+      /* Brain damage for backwards compatibility.  For no good reason, the\n+\t old layout_basetypes made every base at least as large as the\n+\t alignment for the bases up to that point, gratuitously wasting\n+\t space.  So we do the same thing here.  */\n+      base_align = MAX (base_align, DECL_ALIGN (decl));\n+      DECL_SIZE (decl) = size_int (MAX (TREE_INT_CST_LOW (DECL_SIZE (decl)),\n+\t\t\t\t\tbase_align));\n+    }\n+\n+  /* Reverse the list of fields so we allocate the bases in the proper\n+     order.  */\n+  return nreverse (base_decls);\n+}\n+\n+/* Returns list of virtual base class pointers in a FIELD_DECL chain.  */\n \n tree\n-layout_basetypes (rec, binfos)\n-     tree rec, binfos;\n+build_vbase_pointer_fields (rec)\n+     tree rec;\n {\n   /* Chain to hold all the new FIELD_DECLs which point at virtual\n      base classes.  */\n   tree vbase_decls = NULL_TREE;\n-  unsigned record_align = MAX (BITS_PER_UNIT, TYPE_ALIGN (rec));\n-\n-  /* Record size so far is CONST_SIZE bits, where CONST_SIZE is an integer.  */\n-  register unsigned const_size = 0;\n-  int i, n_baseclasses = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-\n-#ifdef STRUCTURE_SIZE_BOUNDARY\n-  /* Packed structures don't need to have minimum size.  */\n-  if (! TYPE_PACKED (rec))\n-    record_align = MAX (record_align, STRUCTURE_SIZE_BOUNDARY);\n-#endif\n+  tree binfos = TYPE_BINFO_BASETYPES (rec);\n+  int n_baseclasses = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n+  tree decl;\n+  int i;\n \n   /* Handle basetypes almost like fields, but record their\n      offsets differently.  */\n \n   for (i = 0; i < n_baseclasses; i++)\n     {\n-      int inc;\n-      unsigned int desired_align;\n       register tree base_binfo = TREE_VEC_ELT (binfos, i);\n       register tree basetype = BINFO_TYPE (base_binfo);\n-      tree decl, offset;\n \n       if (TYPE_SIZE (basetype) == 0)\n \t/* This error is now reported in xref_tag, thus giving better\n@@ -811,7 +850,9 @@ layout_basetypes (rec, binfos)\n \t      tree other_base_binfo = TREE_VEC_ELT (binfos, j);\n \t      if (! TREE_VIA_VIRTUAL (other_base_binfo)\n \t\t  && binfo_member (basetype,\n-\t\t\t\t   CLASSTYPE_VBASECLASSES (BINFO_TYPE (other_base_binfo))))\n+\t\t\t\t   CLASSTYPE_VBASECLASSES (BINFO_TYPE\n+\t\t\t\t\t\t\t   (other_base_binfo))\n+\t\t\t\t   ))\n \t\tgoto got_it;\n \t    }\n \t  sprintf (name, VBASE_NAME_FORMAT, TYPE_NAME_STRING (basetype));\n@@ -835,51 +876,10 @@ layout_basetypes (rec, binfos)\n \n \tgot_it:\n \t  /* The space this decl occupies has already been accounted for.  */\n-\t  continue;\n-\t}\n-\n-      /* Effective C++ rule 14.  We only need to check TYPE_VIRTUAL_P\n-\t here because the case of virtual functions but non-virtual\n-\t dtor is handled in finish_struct_1.  */\n-      if (warn_ecpp && ! TYPE_VIRTUAL_P (basetype)\n-\t  && TYPE_HAS_DESTRUCTOR (basetype))\n-\tcp_warning (\"base class `%#T' has a non-virtual destructor\", basetype);\n-\n-      if (const_size == 0)\n-\toffset = integer_zero_node;\n-      else\n-\t{\n-\t  /* Give each base type the alignment it wants.  */\n-\t  const_size = CEIL (const_size, TYPE_ALIGN (basetype))\n-\t    * TYPE_ALIGN (basetype);\n-\t  offset = size_int ((const_size + BITS_PER_UNIT - 1) / BITS_PER_UNIT);\n+\t  ;\n \t}\n-      BINFO_OFFSET (base_binfo) = offset;\n-      if (CLASSTYPE_VSIZE (basetype))\n-\t{\n-\t  BINFO_VTABLE (base_binfo) = TYPE_BINFO_VTABLE (basetype);\n-\t  BINFO_VIRTUALS (base_binfo) = TYPE_BINFO_VIRTUALS (basetype);\n-\t}\n-      TREE_CHAIN (base_binfo) = TYPE_BINFO (rec);\n-      TYPE_BINFO (rec) = base_binfo;\n-\n-      /* Add only the amount of storage not present in\n-\t the virtual baseclasses.  */\n-      inc = MAX (record_align, TREE_INT_CST_LOW (CLASSTYPE_SIZE (basetype)));\n-\n-      /* Record must have at least as much alignment as any field.  */\n-      desired_align = TYPE_ALIGN (basetype);\n-      record_align = MAX (record_align, desired_align);\n-\n-      const_size += inc;\n     }\n \n-  if (const_size)\n-    CLASSTYPE_SIZE (rec) = size_int (const_size);\n-  else\n-    CLASSTYPE_SIZE (rec) = integer_zero_node;\n-  CLASSTYPE_ALIGN (rec) = record_align;\n-\n   return vbase_decls;\n }\n \f"}]}