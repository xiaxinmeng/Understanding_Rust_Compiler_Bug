{"sha": "c0a78a1786eb537af1169e7a96a3e03ae780e11f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzBhNzhhMTc4NmViNTM3YWYxMTY5ZTdhOTZhM2UwM2FlNzgwZTExZg==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2007-03-23T23:06:52Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2007-03-23T23:06:52Z"}, "message": "Remove the patch from ChangeLog\n\nFrom-SVN: r123168", "tree": {"sha": "932c7a5a1cbc968727f632441e852ac457b80f9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/932c7a5a1cbc968727f632441e852ac457b80f9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0a78a1786eb537af1169e7a96a3e03ae780e11f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0a78a1786eb537af1169e7a96a3e03ae780e11f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0a78a1786eb537af1169e7a96a3e03ae780e11f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0a78a1786eb537af1169e7a96a3e03ae780e11f/comments", "author": null, "committer": null, "parents": [{"sha": "ad21dab7f7977e9741b7bdace4645ae365f45b01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad21dab7f7977e9741b7bdace4645ae365f45b01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad21dab7f7977e9741b7bdace4645ae365f45b01"}], "stats": {"total": 466, "additions": 0, "deletions": 466}, "files": [{"sha": "1c034ea519259ddabce24340b2860cfd7b08cfe2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 0, "deletions": 466, "changes": 466, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0a78a1786eb537af1169e7a96a3e03ae780e11f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0a78a1786eb537af1169e7a96a3e03ae780e11f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c0a78a1786eb537af1169e7a96a3e03ae780e11f", "patch": "@@ -34,472 +34,6 @@\n \t(relink_block_chain): New prototype.\n \t* passes.c (pass_outof_cfg_layout_mode): Move after cse2.\n \n-Index: tracer.c\n-===================================================================\n---- tracer.c\t(revision 122857)\n-+++ tracer.c\t(working copy)\n-@@ -357,24 +357,25 @@ layout_superblocks (void)\n-     }\n- }\n- \n--/* Main entry point to this file.  FLAGS is the set of flags to pass\n--   to cfg_layout_initialize().  */\n-+/* Main entry point to this file.  */\n- \n- void\n--tracer (unsigned int flags)\n-+tracer (void)\n- {\n-+  gcc_assert (current_ir_type () == IR_RTL_CFGLAYOUT);\n-+\n-   if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1)\n-     return;\n- \n--  cfg_layout_initialize (flags);\n-   mark_dfs_back_edges ();\n-   if (dump_file)\n-     dump_flow_info (dump_file, dump_flags);\n-   tail_duplicate ();\n-   layout_superblocks ();\n-+  relink_block_chain (/*stay_in_cfglayout_mode=*/true);\n-+  \n-   if (dump_file)\n-     dump_flow_info (dump_file, dump_flags);\n--  cfg_layout_finalize ();\n- \n-   /* Merge basic blocks in duplicated traces.  */\n-   cleanup_cfg (CLEANUP_EXPENSIVE);\n-@@ -392,7 +393,7 @@ rest_of_handle_tracer (void)\n- {\n-   if (dump_file)\n-     dump_flow_info (dump_file, dump_flags);\n--  tracer (0);\n-+  tracer ();\n-   reg_scan (get_insns (), max_reg_num ());\n-   return 0;\n- }\n-Index: loop-init.c\n-===================================================================\n---- loop-init.c\t(revision 122857)\n-+++ loop-init.c\t(working copy)\n-@@ -171,12 +171,11 @@ struct tree_opt_pass pass_loop2 =\n- static unsigned int\n- rtl_loop_init (void)\n- {\n-+  gcc_assert (current_ir_type () == IR_RTL_CFGLAYOUT);\n-+  \n-   if (dump_file)\n-     dump_flow_info (dump_file, dump_flags);\n- \n--  /* Initialize structures for layout changes.  */\n--  cfg_layout_initialize (0);\n--\n-   loop_optimizer_init (LOOPS_NORMAL);\n-   return 0;\n- }\n-@@ -204,17 +203,9 @@ struct tree_opt_pass pass_rtl_loop_init \n- static unsigned int\n- rtl_loop_done (void)\n- {\n--  basic_block bb;\n--\n-   loop_optimizer_finalize ();\n-   free_dominance_info (CDI_DOMINATORS);\n- \n--  /* Finalize layout changes.  */\n--  FOR_EACH_BB (bb)\n--    if (bb->next_bb != EXIT_BLOCK_PTR)\n--      bb->aux = bb->next_bb;\n--  cfg_layout_finalize ();\n--\n-   cleanup_cfg (CLEANUP_EXPENSIVE);\n-   delete_trivially_dead_insns (get_insns (), max_reg_num ());\n-   reg_scan (get_insns (), max_reg_num ());\n-Index: cfglayout.c\n-===================================================================\n---- cfglayout.c\t(revision 122858)\n-+++ cfglayout.c\t(working copy)\n-@@ -634,13 +634,83 @@ reemit_insn_block_notes (void)\n-   reorder_blocks ();\n- }\n- \f\n-+\n-+/* Link the basic blocks in the correct order, compacting the basic\n-+   block queue while at it.  This also clears the visited flag on\n-+   all basic blocks.  If STAY_IN_CFGLAYOUT_MODE is false, this function\n-+   also clears the basic block header and footer fields.\n-+\n-+   This function is usually called after a pass (e.g. tracer) finishes\n-+   some transformations while in cfglayout mode.  The required sequence\n-+   of the basic blocks is in a linked list along the bb->aux field.\n-+   This functions re-links the basic block prev_bb and next_bb pointers\n-+   accordingly, and it compacts and renumbers the blocks.  */\n-+\n-+void\n-+relink_block_chain (bool stay_in_cfglayout_mode)\n-+{\n-+  basic_block bb, prev_bb;\n-+  int index;\n-+\n-+  /* Maybe dump the re-ordered sequence.  */\n-+  if (dump_file)\n-+    {\n-+      fprintf (dump_file, \"Reordered sequence:\\n\");\n-+      for (bb = ENTRY_BLOCK_PTR->next_bb, index = NUM_FIXED_BLOCKS;\n-+\t   bb;\n-+\t   bb = bb->aux, index++)\n-+\t{\n-+\t  fprintf (dump_file, \" %i \", index);\n-+\t  if (get_bb_original (bb))\n-+\t    fprintf (dump_file, \"duplicate of %i \",\n-+\t\t     get_bb_original (bb)->index);\n-+\t  else if (forwarder_block_p (bb)\n-+\t\t   && !LABEL_P (BB_HEAD (bb)))\n-+\t    fprintf (dump_file, \"compensation \");\n-+\t  else\n-+\t    fprintf (dump_file, \"bb %i \", bb->index);\n-+\t  fprintf (dump_file, \" [%i]\\n\", bb->frequency);\n-+\t}\n-+    }\n-+\n-+  /* Now reorder the blocks.  */\n-+  prev_bb = ENTRY_BLOCK_PTR;\n-+  bb = ENTRY_BLOCK_PTR->next_bb;\n-+  for (; bb; prev_bb = bb, bb = bb->aux)\n-+    {\n-+      bb->prev_bb = prev_bb;\n-+      prev_bb->next_bb = bb;\n-+    }\n-+  prev_bb->next_bb = EXIT_BLOCK_PTR;\n-+  EXIT_BLOCK_PTR->prev_bb = prev_bb;\n-+\n-+  /* Then, clean up the aux and visited fields.  */\n-+  FOR_ALL_BB (bb)\n-+    {\n-+      bb->aux = NULL;\n-+      bb->il.rtl->visited = 0;\n-+      if (!stay_in_cfglayout_mode)\n-+\tbb->il.rtl->header = bb->il.rtl->footer = NULL;\n-+    }\n-+\n-+  /* Maybe reset the original copy tables, they are not valid anymore\n-+     when we renumber the basic blocks in compact_blocks.  If we are\n-+     are going out of cfglayout mode, don't re-allocate the tables.  */\n-+  free_original_copy_tables ();\n-+  if (stay_in_cfglayout_mode)\n-+    initialize_original_copy_tables ();\n-+  \n-+  /* Finally, put basic_block_info in the new order.  */\n-+  compact_blocks ();\n-+}\n-+\f\n-+\n- /* Given a reorder chain, rearrange the code to match.  */\n- \n- static void\n- fixup_reorder_chain (void)\n- {\n--  basic_block bb, prev_bb;\n--  int index;\n-+  basic_block bb;\n-   rtx insn = NULL;\n- \n-   if (cfg_layout_function_header)\n-@@ -654,9 +724,7 @@ fixup_reorder_chain (void)\n-   /* First do the bulk reordering -- rechain the blocks without regard to\n-      the needed changes to jumps and labels.  */\n- \n--  for (bb = ENTRY_BLOCK_PTR->next_bb, index = NUM_FIXED_BLOCKS;\n--       bb != 0;\n--       bb = bb->aux, index++)\n-+  for (bb = ENTRY_BLOCK_PTR->next_bb; bb; bb = bb->aux)\n-     {\n-       if (bb->il.rtl->header)\n- \t{\n-@@ -684,8 +752,6 @@ fixup_reorder_chain (void)\n- \t}\n-     }\n- \n--  gcc_assert (index == n_basic_blocks);\n--\n-   NEXT_INSN (insn) = cfg_layout_function_footer;\n-   if (cfg_layout_function_footer)\n-     PREV_INSN (cfg_layout_function_footer) = insn;\n-@@ -838,42 +904,7 @@ fixup_reorder_chain (void)\n- \t}\n-     }\n- \n--  /* Put basic_block_info in the new order.  */\n--\n--  if (dump_file)\n--    {\n--      fprintf (dump_file, \"Reordered sequence:\\n\");\n--      for (bb = ENTRY_BLOCK_PTR->next_bb, index = NUM_FIXED_BLOCKS;\n--\t   bb;\n--\t   bb = bb->aux, index++)\n--\t{\n--\t  fprintf (dump_file, \" %i \", index);\n--\t  if (get_bb_original (bb))\n--\t    fprintf (dump_file, \"duplicate of %i \",\n--\t\t     get_bb_original (bb)->index);\n--\t  else if (forwarder_block_p (bb)\n--\t\t   && !LABEL_P (BB_HEAD (bb)))\n--\t    fprintf (dump_file, \"compensation \");\n--\t  else\n--\t    fprintf (dump_file, \"bb %i \", bb->index);\n--\t  fprintf (dump_file, \" [%i]\\n\", bb->frequency);\n--\t}\n--    }\n--\n--  prev_bb = ENTRY_BLOCK_PTR;\n--  bb = ENTRY_BLOCK_PTR->next_bb;\n--  index = NUM_FIXED_BLOCKS;\n--\n--  for (; bb; prev_bb = bb, bb = bb->aux, index ++)\n--    {\n--      bb->index = index;\n--      SET_BASIC_BLOCK (index, bb);\n--\n--      bb->prev_bb = prev_bb;\n--      prev_bb->next_bb = bb;\n--    }\n--  prev_bb->next_bb = EXIT_BLOCK_PTR;\n--  EXIT_BLOCK_PTR->prev_bb = prev_bb;\n-+  relink_block_chain (/*stay_in_cfglayout_mode=*/false);\n- \n-   /* Annoying special case - jump around dead jumptables left in the code.  */\n-   FOR_EACH_BB (bb)\n-@@ -1179,8 +1210,6 @@ break_superblocks (void)\n- void\n- cfg_layout_finalize (void)\n- {\n--  basic_block bb;\n--\n- #ifdef ENABLE_CHECKING\n-   verify_flow_info ();\n- #endif\n-@@ -1195,19 +1224,8 @@ cfg_layout_finalize (void)\n- \n- #ifdef ENABLE_CHECKING\n-   verify_insn_chain ();\n--#endif\n--  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n--  {\n--    bb->il.rtl->header = bb->il.rtl->footer = NULL;\n--    bb->aux = NULL;\n--    bb->il.rtl->visited = 0;\n--  }\n--\n--#ifdef ENABLE_CHECKING\n-   verify_flow_info ();\n- #endif\n--\n--  free_original_copy_tables ();\n- }\n- \n- /* Checks whether all N blocks in BBS array can be copied.  */\n-Index: rtl.h\n-===================================================================\n---- rtl.h\t(revision 122857)\n-+++ rtl.h\t(working copy)\n-@@ -2259,7 +2259,7 @@ extern bool expensive_function_p (int);\n- /* In cfgexpand.c */\n- extern void add_reg_br_prob_note (rtx last, int probability);\n- /* In tracer.c */\n--extern void tracer (unsigned int);\n-+extern void tracer (void);\n- \n- /* In var-tracking.c */\n- extern unsigned int variable_tracking_main (void);\n-Index: bb-reorder.c\n-===================================================================\n---- bb-reorder.c\t(revision 122857)\n-+++ bb-reorder.c\t(working copy)\n-@@ -1889,20 +1889,17 @@ verify_hot_cold_block_grouping (void)\n-    the set of flags to pass to cfg_layout_initialize().  */\n- \n- void\n--reorder_basic_blocks (unsigned int flags)\n-+reorder_basic_blocks (void)\n- {\n-   int n_traces;\n-   int i;\n-   struct trace *traces;\n- \n--  if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1)\n--    return;\n-+  gcc_assert (current_ir_type () == IR_RTL_CFGLAYOUT);\n- \n--  if (targetm.cannot_modify_jumps_p ())\n-+  if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1)\n-     return;\n- \n--  cfg_layout_initialize (flags);\n--\n-   set_edge_can_fallthru_flag ();\n-   mark_dfs_back_edges ();\n- \n-@@ -1930,10 +1927,11 @@ reorder_basic_blocks (unsigned int flags\n-   FREE (traces);\n-   FREE (bbd);\n- \n-+  relink_block_chain (/*stay_in_cfglayout_mode=*/true);\n-+\n-   if (dump_file)\n-     dump_flow_info (dump_file, dump_flags);\n- \n--  cfg_layout_finalize ();\n-   if (flag_reorder_blocks_and_partition)\n-     verify_hot_cold_block_grouping ();\n- }\n-@@ -1976,6 +1974,8 @@ insert_section_boundary_note (void)\n- static bool\n- gate_duplicate_computed_gotos (void)\n- {\n-+  if (targetm.cannot_modify_jumps_p ())\n-+    return false;\n-   return (optimize > 0 && flag_expensive_optimizations && !optimize_size);\n- }\n- \n-@@ -1990,9 +1990,6 @@ duplicate_computed_gotos (void)\n-   if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1)\n-     return 0;\n- \n--  if (targetm.cannot_modify_jumps_p ())\n--    return 0;\n--\n-   cfg_layout_initialize (0);\n- \n-   /* We are estimating the length of uncond jump insn only once\n-@@ -2198,6 +2195,8 @@ partition_hot_cold_basic_blocks (void)\n- static bool\n- gate_handle_reorder_blocks (void)\n- {\n-+  if (targetm.cannot_modify_jumps_p ())\n-+    return false;\n-   return (optimize > 0);\n- }\n- \n-@@ -2206,34 +2205,39 @@ gate_handle_reorder_blocks (void)\n- static unsigned int\n- rest_of_handle_reorder_blocks (void)\n- {\n--  bool changed;\n-   unsigned int liveness_flags;\n-+  basic_block bb;\n- \n-   /* Last attempt to optimize CFG, as scheduling, peepholing and insn\n-      splitting possibly introduced more crossjumping opportunities.  */\n-   liveness_flags = (!HAVE_conditional_execution ? CLEANUP_UPDATE_LIFE : 0);\n--  changed = cleanup_cfg (CLEANUP_EXPENSIVE | liveness_flags);\n-+  cfg_layout_initialize (CLEANUP_EXPENSIVE | liveness_flags);\n- \n-   if (flag_sched2_use_traces && flag_schedule_insns_after_reload)\n-     {\n-       timevar_push (TV_TRACER);\n--      tracer (liveness_flags);\n-+      tracer ();\n-       timevar_pop (TV_TRACER);\n-     }\n- \n-   if (flag_reorder_blocks || flag_reorder_blocks_and_partition)\n--    reorder_basic_blocks (liveness_flags);\n-+    reorder_basic_blocks ();\n-   if (flag_reorder_blocks || flag_reorder_blocks_and_partition\n-       || (flag_sched2_use_traces && flag_schedule_insns_after_reload))\n--    changed |= cleanup_cfg (CLEANUP_EXPENSIVE | liveness_flags);\n-+    cleanup_cfg (CLEANUP_EXPENSIVE | liveness_flags);\n- \n-   /* On conditional execution targets we can not update the life cheaply, so\n-      we deffer the updating to after both cleanups.  This may lose some cases\n-      but should not be terribly bad.  */\n--  if (changed && HAVE_conditional_execution)\n-+  if (HAVE_conditional_execution)\n-     update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES,\n- \t\t      PROP_DEATH_NOTES);\n- \n-+  FOR_EACH_BB (bb)\n-+    if (bb->next_bb != EXIT_BLOCK_PTR)\n-+      bb->aux = bb->next_bb;\n-+  cfg_layout_finalize ();\n-+\n-   /* Add NOTE_INSN_SWITCH_TEXT_SECTIONS notes.  */\n-   insert_section_boundary_note ();\n-   return 0;\n-Index: reg-stack.c\n-===================================================================\n---- reg-stack.c\t(revision 122857)\n-+++ reg-stack.c\t(working copy)\n-@@ -167,6 +167,7 @@\n- #include \"recog.h\"\n- #include \"output.h\"\n- #include \"basic-block.h\"\n-+#include \"cfglayout.h\"\n- #include \"varray.h\"\n- #include \"reload.h\"\n- #include \"ggc.h\"\n-@@ -3197,8 +3198,17 @@ rest_of_handle_stack_regs (void)\n-                        | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0))\n-           && (flag_reorder_blocks || flag_reorder_blocks_and_partition))\n-         {\n--          reorder_basic_blocks (0);\n--          cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK);\n-+\t  basic_block bb;\n-+\n-+\t  cfg_layout_initialize (0);\n-+\n-+\t  reorder_basic_blocks ();\n-+\t  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK);\n-+\n-+\t  FOR_EACH_BB (bb)\n-+\t    if (bb->next_bb != EXIT_BLOCK_PTR)\n-+\t      bb->aux = bb->next_bb;\n-+\t  cfg_layout_finalize ();\n-         }\n-     }\n-   else \n-Index: basic-block.h\n-===================================================================\n---- basic-block.h\t(revision 122857)\n-+++ basic-block.h\t(working copy)\n-@@ -929,7 +929,7 @@ extern bool control_flow_insn_p (rtx);\n- extern rtx get_last_bb_insn (basic_block);\n- \n- /* In bb-reorder.c */\n--extern void reorder_basic_blocks (unsigned int);\n-+extern void reorder_basic_blocks (void);\n- \n- /* In dominance.c */\n- \n-@@ -976,6 +976,7 @@ unsigned bb_dom_dfs_out (enum cdi_direct\n- \n- extern edge try_redirect_by_replacing_jump (edge, basic_block, bool);\n- extern void break_superblocks (void);\n-+extern void relink_block_chain (bool);\n- extern void check_bb_profile (basic_block, FILE *);\n- extern void update_bb_profile_for_threading (basic_block, int, gcov_type, edge);\n- extern void init_rtl_bb_info (basic_block);\n-Index: passes.c\n-===================================================================\n---- passes.c\t(revision 122858)\n-+++ passes.c\t(working copy)\n-@@ -666,7 +666,6 @@ init_optimization_passes (void)\n-       NEXT_PASS (pass_gcse);\n-       NEXT_PASS (pass_jump_bypass);\n-       NEXT_PASS (pass_rtl_ifcvt);\n--      NEXT_PASS (pass_outof_cfg_layout_mode);\n-       NEXT_PASS (pass_tracer);\n-       /* Perform loop optimizations.  It might be better to do them a bit\n- \t sooner, but we want the profile feedback to work more\n-@@ -685,6 +684,7 @@ init_optimization_passes (void)\n-       NEXT_PASS (pass_web);\n-       NEXT_PASS (pass_cse2);\n-       NEXT_PASS (pass_rtl_fwprop_addr);\n-+      NEXT_PASS (pass_outof_cfg_layout_mode);\n-       NEXT_PASS (pass_life);\n-       NEXT_PASS (pass_combine);\n-       NEXT_PASS (pass_if_after_combine);\n-\n 2007-03-23  Joseph Myers  <joseph@codesourcery.com>\n \n \t* config/mips/mips.md (type, hazard, *movdi_32bit,"}]}