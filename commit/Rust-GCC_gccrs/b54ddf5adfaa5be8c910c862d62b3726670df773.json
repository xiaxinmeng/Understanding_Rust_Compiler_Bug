{"sha": "b54ddf5adfaa5be8c910c862d62b3726670df773", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjU0ZGRmNWFkZmFhNWJlOGM5MTBjODYyZDYyYjM3MjY2NzBkZjc3Mw==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2007-08-31T10:23:37Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-31T10:23:37Z"}, "message": "par-ch4.adb (P_Simple_Expression): Fold long sequences of concatenations of string literals into a single literal...\n\n2007-08-31  Bob Duff  <duff@adacore.com>\n\n\t* par-ch4.adb (P_Simple_Expression): Fold long sequences of\n\tconcatenations of string literals into a single literal, in order to\n\tavoid very deep recursion in the front end, which was causing stack\n\toverflow.\n\n\t* sem_eval.adb (Eval_Concatenation): If the left operand is the empty\n\tstring, and the right operand is a string literal (the case of \"\" &\n\t\"...\"), optimize by avoiding copying the right operand -- just use the\n\tvalue of the right operand directly.\n\n\t* stringt.adb (Store_String_Chars): Optimize by growing the\n\tString_Chars table all at once, rather than appending characters one by\n\tone.\n\t(Write_String_Table_Entry): If the string to be printed is very long,\n\tjust print the first few characters, followed by the length. Otherwise,\n\tdoing \"pn(n)\" in the debugger can take an extremely long time.\n\n\t* sem_prag.adb (Process_Interface_Name): Replace loop doing\n\tStore_String_Char with Store_String_Chars.\n\nFrom-SVN: r127977", "tree": {"sha": "198081394ea01406fbc6cf4d9510dc38574a8add", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/198081394ea01406fbc6cf4d9510dc38574a8add"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b54ddf5adfaa5be8c910c862d62b3726670df773", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b54ddf5adfaa5be8c910c862d62b3726670df773", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b54ddf5adfaa5be8c910c862d62b3726670df773", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b54ddf5adfaa5be8c910c862d62b3726670df773/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b90cfacd5f804816323d230bd3d7fc4d62569d5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b90cfacd5f804816323d230bd3d7fc4d62569d5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b90cfacd5f804816323d230bd3d7fc4d62569d5b"}], "stats": {"total": 208, "additions": 174, "deletions": 34}, "files": [{"sha": "8956e8654f8b726d1f28737b36763587ef6521c7", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 117, "deletions": 11, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54ddf5adfaa5be8c910c862d62b3726670df773/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54ddf5adfaa5be8c910c862d62b3726670df773/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=b54ddf5adfaa5be8c910c862d62b3726670df773", "patch": "@@ -28,6 +28,8 @@ pragma Style_Checks (All_Checks);\n --  Turn off subprogram body ordering check. Subprograms are in order\n --  by RM section rather than alphabetical\n \n+with Stringt; use Stringt;\n+\n separate (Par)\n package body Ch4 is\n \n@@ -1870,18 +1872,122 @@ package body Ch4 is\n             Node1 := P_Term;\n          end if;\n \n-         --  Scan out sequence of terms separated by binary adding operators\n+         --  In the following, we special-case a sequence of concatentations of\n+         --  string literals, such as \"aaa\" & \"bbb\" & ... & \"ccc\", with nothing\n+         --  else mixed in. For such a sequence, we return a tree representing\n+         --  \"\" & \"aaabbb...ccc\" (a single concatenation). This is done only if\n+         --  the number of concatenations is large. If semantic analysis\n+         --  resolves the \"&\" to a predefined one, then this folding gives the\n+         --  right answer. Otherwise, semantic analysis will complain about a\n+         --  capacity-exceeded error. The purpose of this trick is to avoid\n+         --  creating a deeply nested tree, which would cause deep recursion\n+         --  during semantics, causing stack overflow. This way, we can handle\n+         --  enormous concatenations in the normal case of predefined \"&\".  We\n+         --  first build up the normal tree, and then rewrite it if\n+         --  appropriate.\n \n-         loop\n-            exit when Token not in Token_Class_Binary_Addop;\n-            Tokptr := Token_Ptr;\n-            Node2 := New_Node (P_Binary_Adding_Operator, Tokptr);\n-            Scan; -- past operator\n-            Set_Left_Opnd (Node2, Node1);\n-            Set_Right_Opnd (Node2, P_Term);\n-            Set_Op_Name (Node2);\n-            Node1 := Node2;\n-         end loop;\n+         declare\n+            Num_Concats_Threshold : constant Positive := 1000;\n+            --  Arbitrary threshold value to enable optimization\n+\n+            First_Node : constant Node_Id := Node1;\n+            Is_Strlit_Concat : Boolean;\n+            --  True iff we've parsed a sequence of concatenations of string\n+            --  literals, with nothing else mixed in.\n+\n+            Num_Concats : Natural;\n+            --  Number of \"&\" operators if Is_Strlit_Concat is True\n+\n+         begin\n+            Is_Strlit_Concat :=\n+              Nkind (Node1) = N_String_Literal\n+                and then Token = Tok_Ampersand;\n+            Num_Concats := 0;\n+\n+            --  Scan out sequence of terms separated by binary adding operators\n+\n+            loop\n+               exit when Token not in Token_Class_Binary_Addop;\n+               Tokptr := Token_Ptr;\n+               Node2 := New_Node (P_Binary_Adding_Operator, Tokptr);\n+               Scan; -- past operator\n+               Set_Left_Opnd (Node2, Node1);\n+               Node1 := P_Term;\n+               Set_Right_Opnd (Node2, Node1);\n+               Set_Op_Name (Node2);\n+\n+               --  Check if we're still concatenating string literals\n+\n+               Is_Strlit_Concat :=\n+                 Is_Strlit_Concat\n+                   and then Nkind (Node2) = N_Op_Concat\n+                 and then Nkind (Node1) = N_String_Literal;\n+\n+               if Is_Strlit_Concat then\n+                  Num_Concats := Num_Concats + 1;\n+               end if;\n+\n+               Node1 := Node2;\n+            end loop;\n+\n+            --  If we have an enormous series of concatenations of string\n+            --  literals, rewrite as explained above. The Is_Folded_In_Parser\n+            --  flag tells semantic analysis that if the \"&\" is not predefined,\n+            --  the folded value is wrong.\n+\n+            if Is_Strlit_Concat\n+              and then Num_Concats >= Num_Concats_Threshold\n+            then\n+               declare\n+                  Empty_String_Val : String_Id;\n+                  --  String_Id for \"\"\n+\n+                  Strlit_Concat_Val : String_Id;\n+                  --  Contains the folded value (which will be correct if the\n+                  --  \"&\" operators are the predefined ones).\n+\n+                  Cur_Node : Node_Id;\n+                  --  For walking up the tree\n+\n+                  New_Node : Node_Id;\n+                  --  Folded node to replace Node1\n+\n+                  Loc : constant Source_Ptr := Sloc (First_Node);\n+\n+               begin\n+                  --  Walk up the tree starting at the leftmost string literal\n+                  --  (First_Node), building up the Strlit_Concat_Val as we\n+                  --  go. Note that we do not use recursion here -- the whole\n+                  --  point is to avoid recursively walking that enormous tree.\n+\n+                  Start_String;\n+                  Store_String_Chars (Strval (First_Node));\n+\n+                  Cur_Node := Parent (First_Node);\n+                  while Present (Cur_Node) loop\n+                     pragma Assert (Nkind (Cur_Node) = N_Op_Concat and then\n+                        Nkind (Right_Opnd (Cur_Node)) = N_String_Literal);\n+\n+                     Store_String_Chars (Strval (Right_Opnd (Cur_Node)));\n+                     Cur_Node := Parent (Cur_Node);\n+                  end loop;\n+\n+                  Strlit_Concat_Val := End_String;\n+\n+                  --  Create new folded node, and rewrite result with a concat-\n+                  --  enation of an empty string literal and the folded node.\n+\n+                  Start_String;\n+                  Empty_String_Val := End_String;\n+                  New_Node :=\n+                    Make_Op_Concat (Loc,\n+                      Make_String_Literal (Loc, Empty_String_Val),\n+                      Make_String_Literal (Loc, Strlit_Concat_Val,\n+                        Is_Folded_In_Parser => True));\n+                  Rewrite (Node1, New_Node);\n+               end;\n+            end if;\n+         end;\n \n          --  All done, we clearly do not have name or numeric literal so this\n          --  is a case of a simple expression which is some other possibility."}, {"sha": "465a86a3d58bd37690a16213f58ec288c95d78a0", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54ddf5adfaa5be8c910c862d62b3726670df773/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54ddf5adfaa5be8c910c862d62b3726670df773/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=b54ddf5adfaa5be8c910c862d62b3726670df773", "patch": "@@ -1451,9 +1451,10 @@ package body Sem_Eval is\n       --  concatenations with such aggregates.\n \n       declare\n-         Left_Str  : constant Node_Id := Get_String_Val (Left);\n-         Left_Len  : Nat;\n-         Right_Str : constant Node_Id := Get_String_Val (Right);\n+         Left_Str   : constant Node_Id := Get_String_Val (Left);\n+         Left_Len   : Nat;\n+         Right_Str  : constant Node_Id := Get_String_Val (Right);\n+         Folded_Val : String_Id;\n \n       begin\n          --  Establish new string literal, and store left operand. We make\n@@ -1465,26 +1466,36 @@ package body Sem_Eval is\n \n          if Nkind (Left_Str) = N_String_Literal then\n             Left_Len :=  String_Length (Strval (Left_Str));\n-            Start_String (Strval (Left_Str));\n+\n+            --  If the left operand is the empty string, and the right operand\n+            --  is a string literal (the case of \"\" & \"...\"), the result is the\n+            --  value of the right operand. This optimization is important when\n+            --  Is_Folded_In_Parser, to avoid copying an enormous right\n+            --  operand.\n+\n+            if Left_Len = 0 and then Nkind (Right_Str) = N_String_Literal then\n+               Folded_Val := Strval (Right_Str);\n+            else\n+               Start_String (Strval (Left_Str));\n+            end if;\n+\n          else\n             Start_String;\n             Store_String_Char (UI_To_CC (Char_Literal_Value (Left_Str)));\n             Left_Len := 1;\n          end if;\n \n-         --  Now append the characters of the right operand\n+         --  Now append the characters of the right operand, unless we\n+         --  optimized the \"\" & \"...\" case above.\n \n          if Nkind (Right_Str) = N_String_Literal then\n-            declare\n-               S : constant String_Id := Strval (Right_Str);\n-\n-            begin\n-               for J in 1 .. String_Length (S) loop\n-                  Store_String_Char (Get_String_Char (S, J));\n-               end loop;\n-            end;\n+            if Left_Len /= 0 then\n+               Store_String_Chars (Strval (Right_Str));\n+               Folded_Val := End_String;\n+            end if;\n          else\n             Store_String_Char (UI_To_CC (Char_Literal_Value (Right_Str)));\n+            Folded_Val := End_String;\n          end if;\n \n          Set_Is_Static_Expression (N, Stat);\n@@ -1501,7 +1512,7 @@ package body Sem_Eval is\n                Set_Etype (N, Etype (Right));\n             end if;\n \n-            Fold_Str (N, End_String, Static => True);\n+            Fold_Str (N, Folded_Val, Static => True);\n          end if;\n       end;\n    end Eval_Concatenation;"}, {"sha": "1e54ac629f7fcd0e1c091ea3cf8f79d63e6ed971", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54ddf5adfaa5be8c910c862d62b3726670df773/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54ddf5adfaa5be8c910c862d62b3726670df773/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=b54ddf5adfaa5be8c910c862d62b3726670df773", "patch": "@@ -3736,13 +3736,10 @@ package body Sem_Prag is\n             end if;\n \n             String_Val := Strval (Expr_Value_S (Link_Nam));\n-\n-            for J in 1 .. String_Length (String_Val) loop\n-               Store_String_Char (Get_String_Char (String_Val, J));\n-            end loop;\n-\n+            Store_String_Chars (String_Val);\n             Link_Nam :=\n-              Make_String_Literal (Sloc (Link_Nam), End_String);\n+              Make_String_Literal (Sloc (Link_Nam),\n+                Strval => End_String);\n          end if;\n \n          Set_Encoded_Interface_Name"}, {"sha": "88b72e056dd11770c2e34b1fceb9f5aae288e8b2", "filename": "gcc/ada/stringt.adb", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54ddf5adfaa5be8c910c862d62b3726670df773/gcc%2Fada%2Fstringt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54ddf5adfaa5be8c910c862d62b3726670df773/gcc%2Fada%2Fstringt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstringt.adb?ref=b54ddf5adfaa5be8c910c862d62b3726670df773", "patch": "@@ -202,10 +202,27 @@ package body Stringt is\n    end Store_String_Chars;\n \n    procedure Store_String_Chars (S : String_Id) is\n+\n+      --  We are essentially doing this:\n+\n+      --   for J in 1 .. String_Length (S) loop\n+      --      Store_String_Char (Get_String_Char (S, J));\n+      --   end loop;\n+\n+      --  but when the string is long it's more efficient to grow the\n+      --  String_Chars table all at once.\n+\n+      S_First  : constant Int := Strings.Table (S).String_Index;\n+      S_Len    : constant Int := String_Length (S);\n+      Old_Last : constant Int := String_Chars.Last;\n+      New_Last : constant Int := Old_Last + S_Len;\n+\n    begin\n-      for J in 1 .. String_Length (S) loop\n-         Store_String_Char (Get_String_Char (S, J));\n-      end loop;\n+      String_Chars.Set_Last (New_Last);\n+      String_Chars.Table (Old_Last + 1 .. New_Last) :=\n+        String_Chars.Table (S_First .. S_First + S_Len - 1);\n+      Strings.Table (Strings.Last).Length :=\n+        Strings.Table (Strings.Last).Length + S_Len;\n    end Store_String_Chars;\n \n    ----------------------\n@@ -417,6 +434,15 @@ package body Stringt is\n             else\n                Write_Char_Code (C);\n             end if;\n+\n+            --  If string is very long, quit\n+\n+            if J >= 1000 then  --  arbitrary limit\n+               Write_Str (\"\"\"...etc (length = \");\n+               Write_Int (String_Length (Id));\n+               Write_Str (\")\");\n+               return;\n+            end if;\n          end loop;\n \n          Write_Char ('\"');"}]}