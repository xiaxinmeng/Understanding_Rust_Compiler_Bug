{"sha": "4bae115bfd2c10fc975547b0d4ef9e9a98d51fa4", "node_id": "C_kwDOANBUbNoAKDRiYWUxMTViZmQyYzEwZmM5NzU1NDdiMGQ0ZWY5ZTlhOThkNTFmYTQ", "commit": {"author": {"name": "Faisal Abbas", "email": "90.abbasfaisal@gmail.com", "date": "2022-06-27T15:05:49Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-25T11:40:23Z"}, "message": "gccrs const folding port: continue porting potential_constant_expression_1()\n\nThis changeset ports cp_global_trees structure which is used throughout the\ncp constexpr.cc code. I am not sure what it's purpose is but it seems it is used\nto add and manipulate tree information during the c++ compilation process.\nIt is possible this is not needed in the Rust code and may be taken out later.\nAlso, the initialization function isn't being called from anywhere yet, so\nwe will need to find a suitable point for it.\n\nSigned-off-by: Faisal Abbas <90.abbasfaisal@gmail.com>", "tree": {"sha": "726f2db08fcd705515b731984191070459fccfcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/726f2db08fcd705515b731984191070459fccfcc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4bae115bfd2c10fc975547b0d4ef9e9a98d51fa4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bae115bfd2c10fc975547b0d4ef9e9a98d51fa4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bae115bfd2c10fc975547b0d4ef9e9a98d51fa4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bae115bfd2c10fc975547b0d4ef9e9a98d51fa4/comments", "author": {"login": "abbasfaisal", "id": 9428333, "node_id": "MDQ6VXNlcjk0MjgzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/9428333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abbasfaisal", "html_url": "https://github.com/abbasfaisal", "followers_url": "https://api.github.com/users/abbasfaisal/followers", "following_url": "https://api.github.com/users/abbasfaisal/following{/other_user}", "gists_url": "https://api.github.com/users/abbasfaisal/gists{/gist_id}", "starred_url": "https://api.github.com/users/abbasfaisal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abbasfaisal/subscriptions", "organizations_url": "https://api.github.com/users/abbasfaisal/orgs", "repos_url": "https://api.github.com/users/abbasfaisal/repos", "events_url": "https://api.github.com/users/abbasfaisal/events{/privacy}", "received_events_url": "https://api.github.com/users/abbasfaisal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3cf195ab46d7effe806990aa6b7a409bf8e46df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3cf195ab46d7effe806990aa6b7a409bf8e46df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3cf195ab46d7effe806990aa6b7a409bf8e46df"}], "stats": {"total": 373, "additions": 373, "deletions": 0}, "files": [{"sha": "38c762b76d7595014ad9846579aa27987a9c2b0e", "filename": "gcc/rust/backend/rust-tree.cc", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bae115bfd2c10fc975547b0d4ef9e9a98d51fa4/gcc%2Frust%2Fbackend%2Frust-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bae115bfd2c10fc975547b0d4ef9e9a98d51fa4/gcc%2Frust%2Fbackend%2Frust-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.cc?ref=4bae115bfd2c10fc975547b0d4ef9e9a98d51fa4", "patch": "@@ -955,4 +955,97 @@ rs_type_quals (const_tree type)\n   return quals;\n }\n \n+// forked from gcc/cp/decl.cc cp_global_trees\n+\n+/* The following symbols are subsumed in the cp_global_trees array, and\n+   listed here individually for documentation purposes.\n+\n+   C++ extensions\n+\ttree wchar_decl_node;\n+\n+\ttree vtable_entry_type;\n+\ttree delta_type_node;\n+\ttree __t_desc_type_node;\n+\n+\ttree class_type_node;\n+\ttree unknown_type_node;\n+\n+   Array type `vtable_entry_type[]'\n+\n+\ttree vtbl_type_node;\n+\ttree vtbl_ptr_type_node;\n+\n+   Namespaces,\n+\n+\ttree std_node;\n+\ttree abi_node;\n+\n+   A FUNCTION_DECL which can call `abort'.  Not necessarily the\n+   one that the user will declare, but sufficient to be called\n+   by routines that want to abort the program.\n+\n+\ttree abort_fndecl;\n+\n+   Used by RTTI\n+\ttree type_info_type_node, tinfo_decl_id, tinfo_decl_type;\n+\ttree tinfo_var_id;  */\n+\n+tree cp_global_trees[CPTI_MAX];\n+\n+// forked from gcc/cp/module.cc fixed_trees\n+\n+static GTY (()) vec<tree, va_gc> *fixed_trees;\n+\n+// forked from gcc/cp/module.cc maybe_add_global\n+\n+/* VAL is a global tree, add it to the global vec if it is\n+   interesting.  Add some of its targets, if they too are\n+   interesting.  We do not add identifiers, as they can be re-found\n+   via the identifier hash table.  There is a cost to the number of\n+   global trees.  */\n+\n+static int\n+maybe_add_global (tree val, unsigned &crc)\n+{\n+  int v = 0;\n+\n+  if (val && !(TREE_CODE (val) == IDENTIFIER_NODE || TREE_VISITED (val)))\n+    {\n+      TREE_VISITED (val) = true;\n+      crc = crc32_unsigned (crc, fixed_trees->length ());\n+      vec_safe_push (fixed_trees, val);\n+      v++;\n+\n+      if (CODE_CONTAINS_STRUCT (TREE_CODE (val), TS_TYPED))\n+\tv += maybe_add_global (TREE_TYPE (val), crc);\n+      if (CODE_CONTAINS_STRUCT (TREE_CODE (val), TS_TYPE_COMMON))\n+\tv += maybe_add_global (TYPE_NAME (val), crc);\n+    }\n+\n+  return v;\n+}\n+\n+// forked from gcc/cp/module.cc global_tree_arys\n+\n+/* Global trees.  */\n+static const std::pair<tree *, unsigned> global_tree_arys[] = {\n+  std::pair<tree *, unsigned> (cp_global_trees, CPTI_MODULE_HWM),\n+};\n+\n+// forked from gcc/cp/module.cc init_modules\n+\n+void\n+init_modules ()\n+{\n+  unsigned crc = 0;\n+  vec_alloc (fixed_trees, 200);\n+\n+  const tree *ptr = global_tree_arys[0].first;\n+  unsigned limit = global_tree_arys[0].second;\n+  for (unsigned ix = 0; ix != limit; ix++, ptr++)\n+    {\n+      maybe_add_global (*ptr, crc);\n+    }\n+}\n+\n } // namespace Rust"}, {"sha": "f65d3ea2b7ec44cc770483117f71a5057d3fa7da", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 280, "deletions": 0, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bae115bfd2c10fc975547b0d4ef9e9a98d51fa4/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bae115bfd2c10fc975547b0d4ef9e9a98d51fa4/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=4bae115bfd2c10fc975547b0d4ef9e9a98d51fa4", "patch": "@@ -156,6 +156,283 @@\n #define VAR_OR_FUNCTION_DECL_CHECK(NODE)                                       \\\n   TREE_CHECK2 (NODE, VAR_DECL, FUNCTION_DECL)\n \n+// forked from gcc/cp/cp-tree.h cp_tree_index\n+\n+enum cp_tree_index\n+{\n+  CPTI_WCHAR_DECL,\n+  CPTI_VTABLE_ENTRY_TYPE,\n+  CPTI_DELTA_TYPE,\n+  CPTI_VTABLE_INDEX_TYPE,\n+  CPTI_CLEANUP_TYPE,\n+  CPTI_VTT_PARM_TYPE,\n+\n+  CPTI_CLASS_TYPE,\n+  CPTI_UNKNOWN_TYPE,\n+  CPTI_INIT_LIST_TYPE,\n+  CPTI_EXPLICIT_VOID_LIST,\n+  CPTI_VTBL_TYPE,\n+  CPTI_VTBL_PTR_TYPE,\n+  CPTI_GLOBAL,\n+  CPTI_ABORT_FNDECL,\n+  CPTI_AGGR_TAG,\n+  CPTI_CONV_OP_MARKER,\n+\n+  CPTI_CTOR_IDENTIFIER,\n+  CPTI_COMPLETE_CTOR_IDENTIFIER,\n+  CPTI_BASE_CTOR_IDENTIFIER,\n+  CPTI_DTOR_IDENTIFIER,\n+  CPTI_COMPLETE_DTOR_IDENTIFIER,\n+  CPTI_BASE_DTOR_IDENTIFIER,\n+  CPTI_DELETING_DTOR_IDENTIFIER,\n+  CPTI_CONV_OP_IDENTIFIER,\n+  CPTI_DELTA_IDENTIFIER,\n+  CPTI_IN_CHARGE_IDENTIFIER,\n+  CPTI_VTT_PARM_IDENTIFIER,\n+  CPTI_AS_BASE_IDENTIFIER,\n+  CPTI_THIS_IDENTIFIER,\n+  CPTI_PFN_IDENTIFIER,\n+  CPTI_VPTR_IDENTIFIER,\n+  CPTI_GLOBAL_IDENTIFIER,\n+  CPTI_ANON_IDENTIFIER,\n+  CPTI_AUTO_IDENTIFIER,\n+  CPTI_DECLTYPE_AUTO_IDENTIFIER,\n+  CPTI_INIT_LIST_IDENTIFIER,\n+  CPTI_FOR_RANGE__IDENTIFIER,\n+  CPTI_FOR_BEGIN__IDENTIFIER,\n+  CPTI_FOR_END__IDENTIFIER,\n+  CPTI_FOR_RANGE_IDENTIFIER,\n+  CPTI_FOR_BEGIN_IDENTIFIER,\n+  CPTI_FOR_END_IDENTIFIER,\n+  CPTI_ABI_TAG_IDENTIFIER,\n+  CPTI_ALIGNED_IDENTIFIER,\n+  CPTI_BEGIN_IDENTIFIER,\n+  CPTI_END_IDENTIFIER,\n+  CPTI_GET_IDENTIFIER,\n+  CPTI_GNU_IDENTIFIER,\n+  CPTI_TUPLE_ELEMENT_IDENTIFIER,\n+  CPTI_TUPLE_SIZE_IDENTIFIER,\n+  CPTI_TYPE_IDENTIFIER,\n+  CPTI_VALUE_IDENTIFIER,\n+  CPTI_FUN_IDENTIFIER,\n+  CPTI_CLOSURE_IDENTIFIER,\n+  CPTI_HEAP_UNINIT_IDENTIFIER,\n+  CPTI_HEAP_IDENTIFIER,\n+  CPTI_HEAP_DELETED_IDENTIFIER,\n+  CPTI_HEAP_VEC_UNINIT_IDENTIFIER,\n+  CPTI_HEAP_VEC_IDENTIFIER,\n+  CPTI_OMP_IDENTIFIER,\n+\n+  CPTI_LANG_NAME_C,\n+  CPTI_LANG_NAME_CPLUSPLUS,\n+\n+  CPTI_EMPTY_EXCEPT_SPEC,\n+  CPTI_NOEXCEPT_TRUE_SPEC,\n+  CPTI_NOEXCEPT_FALSE_SPEC,\n+  CPTI_NOEXCEPT_DEFERRED_SPEC,\n+\n+  CPTI_NULLPTR,\n+  CPTI_NULLPTR_TYPE,\n+\n+  CPTI_ANY_TARG,\n+\n+  CPTI_MODULE_HWM,\n+  /* Nodes after here change during compilation, or should not be in\n+     the module's global tree table.  Such nodes must be locatable\n+     via name lookup or type-construction, as those are the only\n+     cross-TU matching capabilities remaining.  */\n+\n+  /* We must find these via the global namespace.  */\n+  CPTI_STD,\n+  CPTI_ABI,\n+\n+  /* These are created at init time, but the library/headers provide\n+     definitions.  */\n+  CPTI_ALIGN_TYPE,\n+  CPTI_TERMINATE_FN,\n+  CPTI_CALL_UNEXPECTED_FN,\n+\n+  /* These are lazily inited.  */\n+  CPTI_CONST_TYPE_INFO_TYPE,\n+  CPTI_GET_EXCEPTION_PTR_FN,\n+  CPTI_BEGIN_CATCH_FN,\n+  CPTI_END_CATCH_FN,\n+  CPTI_ALLOCATE_EXCEPTION_FN,\n+  CPTI_FREE_EXCEPTION_FN,\n+  CPTI_THROW_FN,\n+  CPTI_RETHROW_FN,\n+  CPTI_ATEXIT_FN_PTR_TYPE,\n+  CPTI_ATEXIT,\n+  CPTI_DSO_HANDLE,\n+  CPTI_DCAST,\n+\n+  CPTI_SOURCE_LOCATION_IMPL,\n+\n+  CPTI_FALLBACK_DFLOAT32_TYPE,\n+  CPTI_FALLBACK_DFLOAT64_TYPE,\n+  CPTI_FALLBACK_DFLOAT128_TYPE,\n+\n+  CPTI_MAX\n+};\n+\n+// forked from gcc/cp/cp-tree.h cp_global_trees\n+\n+extern GTY (()) tree cp_global_trees[CPTI_MAX];\n+\n+#define wchar_decl_node cp_global_trees[CPTI_WCHAR_DECL]\n+#define vtable_entry_type cp_global_trees[CPTI_VTABLE_ENTRY_TYPE]\n+/* The type used to represent an offset by which to adjust the `this'\n+   pointer in pointer-to-member types.  */\n+#define delta_type_node cp_global_trees[CPTI_DELTA_TYPE]\n+/* The type used to represent an index into the vtable.  */\n+#define vtable_index_type cp_global_trees[CPTI_VTABLE_INDEX_TYPE]\n+\n+#define class_type_node cp_global_trees[CPTI_CLASS_TYPE]\n+#define unknown_type_node cp_global_trees[CPTI_UNKNOWN_TYPE]\n+#define init_list_type_node cp_global_trees[CPTI_INIT_LIST_TYPE]\n+#define explicit_void_list_node cp_global_trees[CPTI_EXPLICIT_VOID_LIST]\n+#define vtbl_type_node cp_global_trees[CPTI_VTBL_TYPE]\n+#define vtbl_ptr_type_node cp_global_trees[CPTI_VTBL_PTR_TYPE]\n+#define std_node cp_global_trees[CPTI_STD]\n+#define abi_node cp_global_trees[CPTI_ABI]\n+#define global_namespace cp_global_trees[CPTI_GLOBAL]\n+#define const_type_info_type_node cp_global_trees[CPTI_CONST_TYPE_INFO_TYPE]\n+#define conv_op_marker cp_global_trees[CPTI_CONV_OP_MARKER]\n+#define abort_fndecl cp_global_trees[CPTI_ABORT_FNDECL]\n+#define current_aggr cp_global_trees[CPTI_AGGR_TAG]\n+#define nullptr_node cp_global_trees[CPTI_NULLPTR]\n+#define nullptr_type_node cp_global_trees[CPTI_NULLPTR_TYPE]\n+/* std::align_val_t */\n+#define align_type_node cp_global_trees[CPTI_ALIGN_TYPE]\n+\n+/* We cache these tree nodes so as to call get_identifier less frequently.\n+   For identifiers for functions, including special member functions such\n+   as ctors and assignment operators, the nodes can be used (among other\n+   things) to iterate over their overloads defined by/for a type.  For\n+   example:\n+\n+     tree ovlid = assign_op_identifier;\n+     tree overloads = get_class_binding (type, ovlid);\n+     for (ovl_iterator it (overloads); it; ++it) { ... }\n+\n+   iterates over the set of implicitly and explicitly defined overloads\n+   of the assignment operator for type (including the copy and move\n+   assignment operators, whether deleted or not).  */\n+\n+/* The name of a constructor that takes an in-charge parameter to\n+   decide whether or not to construct virtual base classes.  */\n+#define ctor_identifier cp_global_trees[CPTI_CTOR_IDENTIFIER]\n+/* The name of a constructor that constructs virtual base classes.  */\n+#define complete_ctor_identifier cp_global_trees[CPTI_COMPLETE_CTOR_IDENTIFIER]\n+/* The name of a constructor that does not construct virtual base classes.  */\n+#define base_ctor_identifier cp_global_trees[CPTI_BASE_CTOR_IDENTIFIER]\n+/* The name of a destructor that takes an in-charge parameter to\n+   decide whether or not to destroy virtual base classes and whether\n+   or not to delete the object.  */\n+#define dtor_identifier cp_global_trees[CPTI_DTOR_IDENTIFIER]\n+/* The name of a destructor that destroys virtual base classes.  */\n+#define complete_dtor_identifier cp_global_trees[CPTI_COMPLETE_DTOR_IDENTIFIER]\n+/* The name of a destructor that does not destroy virtual base\n+   classes.  */\n+#define base_dtor_identifier cp_global_trees[CPTI_BASE_DTOR_IDENTIFIER]\n+/* The name of a destructor that destroys virtual base classes, and\n+   then deletes the entire object.  */\n+#define deleting_dtor_identifier cp_global_trees[CPTI_DELETING_DTOR_IDENTIFIER]\n+\n+/* The name used for conversion operators -- but note that actual\n+   conversion functions use special identifiers outside the identifier\n+   table.  */\n+#define conv_op_identifier cp_global_trees[CPTI_CONV_OP_IDENTIFIER]\n+\n+#define delta_identifier cp_global_trees[CPTI_DELTA_IDENTIFIER]\n+#define in_charge_identifier cp_global_trees[CPTI_IN_CHARGE_IDENTIFIER]\n+/* The name of the parameter that contains a pointer to the VTT to use\n+   for this subobject constructor or destructor.  */\n+#define vtt_parm_identifier cp_global_trees[CPTI_VTT_PARM_IDENTIFIER]\n+#define as_base_identifier cp_global_trees[CPTI_AS_BASE_IDENTIFIER]\n+#define this_identifier cp_global_trees[CPTI_THIS_IDENTIFIER]\n+#define pfn_identifier cp_global_trees[CPTI_PFN_IDENTIFIER]\n+#define vptr_identifier cp_global_trees[CPTI_VPTR_IDENTIFIER]\n+/* The name of the ::, std & anon namespaces.  */\n+#define global_identifier cp_global_trees[CPTI_GLOBAL_IDENTIFIER]\n+#define anon_identifier cp_global_trees[CPTI_ANON_IDENTIFIER]\n+/* auto and declspec(auto) identifiers.  */\n+#define auto_identifier cp_global_trees[CPTI_AUTO_IDENTIFIER]\n+#define decltype_auto_identifier cp_global_trees[CPTI_DECLTYPE_AUTO_IDENTIFIER]\n+#define init_list_identifier cp_global_trees[CPTI_INIT_LIST_IDENTIFIER]\n+#define for_range__identifier cp_global_trees[CPTI_FOR_RANGE__IDENTIFIER]\n+#define for_begin__identifier cp_global_trees[CPTI_FOR_BEGIN__IDENTIFIER]\n+#define for_end__identifier cp_global_trees[CPTI_FOR_END__IDENTIFIER]\n+#define for_range_identifier cp_global_trees[CPTI_FOR_RANGE_IDENTIFIER]\n+#define for_begin_identifier cp_global_trees[CPTI_FOR_BEGIN_IDENTIFIER]\n+#define for_end_identifier cp_global_trees[CPTI_FOR_END_IDENTIFIER]\n+#define abi_tag_identifier cp_global_trees[CPTI_ABI_TAG_IDENTIFIER]\n+#define aligned_identifier cp_global_trees[CPTI_ALIGNED_IDENTIFIER]\n+#define begin_identifier cp_global_trees[CPTI_BEGIN_IDENTIFIER]\n+#define end_identifier cp_global_trees[CPTI_END_IDENTIFIER]\n+#define get__identifier cp_global_trees[CPTI_GET_IDENTIFIER]\n+#define gnu_identifier cp_global_trees[CPTI_GNU_IDENTIFIER]\n+#define tuple_element_identifier cp_global_trees[CPTI_TUPLE_ELEMENT_IDENTIFIER]\n+#define tuple_size_identifier cp_global_trees[CPTI_TUPLE_SIZE_IDENTIFIER]\n+#define type_identifier cp_global_trees[CPTI_TYPE_IDENTIFIER]\n+#define value_identifier cp_global_trees[CPTI_VALUE_IDENTIFIER]\n+#define fun_identifier cp_global_trees[CPTI_FUN_IDENTIFIER]\n+#define closure_identifier cp_global_trees[CPTI_CLOSURE_IDENTIFIER]\n+#define heap_uninit_identifier cp_global_trees[CPTI_HEAP_UNINIT_IDENTIFIER]\n+#define heap_identifier cp_global_trees[CPTI_HEAP_IDENTIFIER]\n+#define heap_deleted_identifier cp_global_trees[CPTI_HEAP_DELETED_IDENTIFIER]\n+#define heap_vec_uninit_identifier                                             \\\n+  cp_global_trees[CPTI_HEAP_VEC_UNINIT_IDENTIFIER]\n+#define heap_vec_identifier cp_global_trees[CPTI_HEAP_VEC_IDENTIFIER]\n+#define omp_identifier cp_global_trees[CPTI_OMP_IDENTIFIER]\n+#define lang_name_c cp_global_trees[CPTI_LANG_NAME_C]\n+#define lang_name_cplusplus cp_global_trees[CPTI_LANG_NAME_CPLUSPLUS]\n+\n+/* Exception specifiers used for throw(), noexcept(true),\n+   noexcept(false) and deferred noexcept.  We rely on these being\n+   uncloned.  */\n+#define empty_except_spec cp_global_trees[CPTI_EMPTY_EXCEPT_SPEC]\n+#define noexcept_true_spec cp_global_trees[CPTI_NOEXCEPT_TRUE_SPEC]\n+#define noexcept_false_spec cp_global_trees[CPTI_NOEXCEPT_FALSE_SPEC]\n+#define noexcept_deferred_spec cp_global_trees[CPTI_NOEXCEPT_DEFERRED_SPEC]\n+\n+/* Exception handling function declarations.  */\n+#define terminate_fn cp_global_trees[CPTI_TERMINATE_FN]\n+#define call_unexpected_fn cp_global_trees[CPTI_CALL_UNEXPECTED_FN]\n+#define get_exception_ptr_fn cp_global_trees[CPTI_GET_EXCEPTION_PTR_FN]\n+#define begin_catch_fn cp_global_trees[CPTI_BEGIN_CATCH_FN]\n+#define end_catch_fn cp_global_trees[CPTI_END_CATCH_FN]\n+#define allocate_exception_fn cp_global_trees[CPTI_ALLOCATE_EXCEPTION_FN]\n+#define free_exception_fn cp_global_trees[CPTI_FREE_EXCEPTION_FN]\n+#define throw_fn cp_global_trees[CPTI_THROW_FN]\n+#define rethrow_fn cp_global_trees[CPTI_RETHROW_FN]\n+\n+/* The type of the function-pointer argument to \"__cxa_atexit\" (or\n+   \"std::atexit\", if \"__cxa_atexit\" is not being used).  */\n+#define atexit_fn_ptr_type_node cp_global_trees[CPTI_ATEXIT_FN_PTR_TYPE]\n+\n+/* A pointer to `std::atexit'.  */\n+#define atexit_node cp_global_trees[CPTI_ATEXIT]\n+\n+/* A pointer to `__dso_handle'.  */\n+#define dso_handle_node cp_global_trees[CPTI_DSO_HANDLE]\n+\n+/* The declaration of the dynamic_cast runtime.  */\n+#define dynamic_cast_node cp_global_trees[CPTI_DCAST]\n+\n+/* The type of a destructor.  */\n+#define cleanup_type cp_global_trees[CPTI_CLEANUP_TYPE]\n+\n+/* The type of the vtt parameter passed to subobject constructors and\n+   destructors.  */\n+#define vtt_parm_type cp_global_trees[CPTI_VTT_PARM_TYPE]\n+\n+/* A node which matches any template argument.  */\n+#define any_targ_node cp_global_trees[CPTI_ANY_TARG]\n+\n+/* std::source_location::__impl class.  */\n+#define source_location_impl cp_global_trees[CPTI_SOURCE_LOCATION_IMPL]\n+\n // Below macros are copied from gcc/c-family/c-common.h\n \n /* In a FIELD_DECL, nonzero if the decl was originally a bitfield.  */\n@@ -477,6 +754,9 @@ rs_type_quals (const_tree type);\n \n extern bool decl_maybe_constant_var_p (tree);\n \n+extern void\n+init_modules ();\n+\n extern tree\n rs_walk_subtrees (tree *, int *, walk_tree_fn, void *, hash_set<tree> *);\n #define rs_walk_tree(tp, func, data, pset)                                     \\"}]}