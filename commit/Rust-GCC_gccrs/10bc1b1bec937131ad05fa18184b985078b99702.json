{"sha": "10bc1b1bec937131ad05fa18184b985078b99702", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBiYzFiMWJlYzkzNzEzMWFkMDVmYTE4MTg0Yjk4NTA3OGI5OTcwMg==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm@polyomino.org.uk", "date": "2004-06-06T15:21:59Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2004-06-06T15:21:59Z"}, "message": "re PR c/13519 (typeof(nonconst+const) is const)\n\n\tPR c/13519\n\t* c-typeck.c (composite_type, common_pointer_type): New functions.\n\t(common_type): Split parts into composite_type and\n\tcommon_pointer_type.  Ensure that arithmetic operations return\n\tunqualified types without attributes.  Don't make composite type\n\tof signed enum and compatible integer be unsigned.\n\t(build_conditional_expr, build_binary_op): Use\n\tcommon_pointer_type.\n\t* c-decl.c (merge_decls): Use composite_type.\n\t* c-tree.h (composite_type): Declare.\n\ntestsuite:\n\t* gcc.c-torture/enum-3.c, gcc.dg/pr13519-1.c: New tests.\n\nFrom-SVN: r82671", "tree": {"sha": "b8c296e8aca98162130737ac16548bd0553c78f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8c296e8aca98162130737ac16548bd0553c78f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10bc1b1bec937131ad05fa18184b985078b99702", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10bc1b1bec937131ad05fa18184b985078b99702", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10bc1b1bec937131ad05fa18184b985078b99702", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10bc1b1bec937131ad05fa18184b985078b99702/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff24b82044cde0c0ff5dd68f45bc9f2bfbcfb3cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff24b82044cde0c0ff5dd68f45bc9f2bfbcfb3cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff24b82044cde0c0ff5dd68f45bc9f2bfbcfb3cf"}], "stats": {"total": 434, "additions": 295, "deletions": 139}, "files": [{"sha": "f3f622e7ba6183f83f289e88d66d9136af278c1d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10bc1b1bec937131ad05fa18184b985078b99702/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10bc1b1bec937131ad05fa18184b985078b99702/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=10bc1b1bec937131ad05fa18184b985078b99702", "patch": "@@ -1,3 +1,16 @@\n+2004-06-06  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\tPR c/13519\n+\t* c-typeck.c (composite_type, common_pointer_type): New functions.\n+\t(common_type): Split parts into composite_type and\n+\tcommon_pointer_type.  Ensure that arithmetic operations return\n+\tunqualified types without attributes.  Don't make composite type\n+\tof signed enum and compatible integer be unsigned.\n+\t(build_conditional_expr, build_binary_op): Use\n+\tcommon_pointer_type.\n+\t* c-decl.c (merge_decls): Use composite_type.\n+\t* c-tree.h (composite_type): Declare.\n+\n 2004-06-06  Stephane Carrez  <stcarrez@nerim.fr>\n \n \tPR target/14457"}, {"sha": "ee09afaff0df34ddf190f55534523d337e25f8c6", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10bc1b1bec937131ad05fa18184b985078b99702/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10bc1b1bec937131ad05fa18184b985078b99702/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=10bc1b1bec937131ad05fa18184b985078b99702", "patch": "@@ -1452,7 +1452,7 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n   /* Merge the data types specified in the two decls.  */\n   TREE_TYPE (newdecl)\n     = TREE_TYPE (olddecl)\n-    = common_type (newtype, oldtype);\n+    = composite_type (newtype, oldtype);\n \n   /* Lay the type out, unless already done.  */\n   if (oldtype != TREE_TYPE (newdecl))"}, {"sha": "e698c871a12e5148aacb4419881ca35bebdf9086", "filename": "gcc/c-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10bc1b1bec937131ad05fa18184b985078b99702/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10bc1b1bec937131ad05fa18184b985078b99702/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=10bc1b1bec937131ad05fa18184b985078b99702", "patch": "@@ -226,6 +226,7 @@ extern tree c_size_in_bytes (tree);\n extern bool c_mark_addressable (tree);\n extern void c_incomplete_type_error (tree, tree);\n extern tree c_type_promotes_to (tree);\n+extern tree composite_type (tree, tree);\n extern tree build_component_ref (tree, tree);\n extern tree build_indirect_ref (tree, const char *);\n extern tree build_array_ref (tree, tree);"}, {"sha": "bdbb58b3f828046f4ce8a6ef870c0569516160d1", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 204, "deletions": 138, "changes": 342, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10bc1b1bec937131ad05fa18184b985078b99702/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10bc1b1bec937131ad05fa18184b985078b99702/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=10bc1b1bec937131ad05fa18184b985078b99702", "patch": "@@ -199,19 +199,14 @@ qualify_type (tree type, tree like)\n \t\t\t\t TYPE_QUALS (type) | TYPE_QUALS (like));\n }\n \f\n-/* Return the composite type of two compatible types, or the common\n-   type for two arithmetic types under the usual arithmetic\n-   conversions.\n+/* Return the composite type of two compatible types.\n \n-   Unless both types are arithmetic types, we assume that comptypes\n-   has already been done and returned 1; if that isn't so, this may\n-   crash.  In particular, we assume that qualifiers match.\n-\n-   This is the type for the result of most arithmetic operations\n-   if the operands have the given two types.  */\n+   We assume that comptypes has already been done and returned\n+   nonzero; if that isn't so, this may crash.  In particular, we\n+   assume that qualifiers match.  */\n \n tree\n-common_type (tree t1, tree t2)\n+composite_type (tree t1, tree t2)\n {\n   enum tree_code code1;\n   enum tree_code code2;\n@@ -227,145 +222,40 @@ common_type (tree t1, tree t2)\n   if (t2 == error_mark_node)\n     return t1;\n \n+  code1 = TREE_CODE (t1);\n+  code2 = TREE_CODE (t2);\n+\n   /* Merge the attributes.  */\n   attributes = targetm.merge_type_attributes (t1, t2);\n \n-  /* Treat an enum type as the unsigned integer type of the same width.  */\n-\n-  if (TREE_CODE (t1) == ENUMERAL_TYPE)\n-    t1 = c_common_type_for_size (TYPE_PRECISION (t1), 1);\n-  if (TREE_CODE (t2) == ENUMERAL_TYPE)\n-    t2 = c_common_type_for_size (TYPE_PRECISION (t2), 1);\n-\n-  code1 = TREE_CODE (t1);\n-  code2 = TREE_CODE (t2);\n+  /* If one is an enumerated type and the other is the compatible\n+     integer type, the composite type might be either of the two\n+     (DR#013 question 3).  For consistency, use the enumerated type as\n+     the composite type.  */\n \n-  /* If one type is complex, form the common type of the non-complex\n-     components, then make that complex.  Use T1 or T2 if it is the\n-     required type.  */\n-  if (code1 == COMPLEX_TYPE || code2 == COMPLEX_TYPE)\n-    {\n-      tree subtype1 = code1 == COMPLEX_TYPE ? TREE_TYPE (t1) : t1;\n-      tree subtype2 = code2 == COMPLEX_TYPE ? TREE_TYPE (t2) : t2;\n-      tree subtype = common_type (subtype1, subtype2);\n+  if (code1 == ENUMERAL_TYPE && code2 == INTEGER_TYPE)\n+    return t1;\n+  if (code2 == ENUMERAL_TYPE && code1 == INTEGER_TYPE)\n+    return t2;\n \n-      if (code1 == COMPLEX_TYPE && TREE_TYPE (t1) == subtype)\n-\treturn build_type_attribute_variant (t1, attributes);\n-      else if (code2 == COMPLEX_TYPE && TREE_TYPE (t2) == subtype)\n-\treturn build_type_attribute_variant (t2, attributes);\n-      else\n-\treturn build_type_attribute_variant (build_complex_type (subtype),\n-\t\t\t\t\t     attributes);\n-    }\n+  if (code1 != code2)\n+    abort ();\n \n   switch (code1)\n     {\n-    case INTEGER_TYPE:\n-    case REAL_TYPE:\n-      /* If only one is real, use it as the result.  */\n-\n-      if (code1 == REAL_TYPE && code2 != REAL_TYPE)\n-\treturn build_type_attribute_variant (t1, attributes);\n-\n-      if (code2 == REAL_TYPE && code1 != REAL_TYPE)\n-\treturn build_type_attribute_variant (t2, attributes);\n-\n-      /* Both real or both integers; use the one with greater precision.  */\n-\n-      if (TYPE_PRECISION (t1) > TYPE_PRECISION (t2))\n-\treturn build_type_attribute_variant (t1, attributes);\n-      else if (TYPE_PRECISION (t2) > TYPE_PRECISION (t1))\n-\treturn build_type_attribute_variant (t2, attributes);\n-\n-      /* Same precision.  Prefer long longs to longs to ints when the\n-\t same precision, following the C99 rules on integer type rank\n-\t (which are equivalent to the C90 rules for C90 types).\n-\t Make sure that we don't lose the type qualifications when\n-\t creating the new variant.  */\n-\n-      if (TYPE_MAIN_VARIANT (t1) == long_long_unsigned_type_node\n-\t  || TYPE_MAIN_VARIANT (t2) == long_long_unsigned_type_node)\n-\t{\n-\t  t1 = build_qualified_type (long_long_unsigned_type_node,\n-\t\t\t\t     TYPE_QUALS (t1));\n-\t  return build_type_attribute_variant (t1, attributes);\n-\t}\n-\n-      if (TYPE_MAIN_VARIANT (t1) == long_long_integer_type_node\n-\t  || TYPE_MAIN_VARIANT (t2) == long_long_integer_type_node)\n-\t{\n-\t  tree ntype;\n-\n-\t  if (TYPE_UNSIGNED (t1) || TYPE_UNSIGNED (t2))\n-\t     ntype = long_long_unsigned_type_node;\n-\t  else\n-\t     ntype = long_long_integer_type_node;\n-\n-\t  ntype = build_qualified_type (ntype, TYPE_QUALS (t1));\n-\t  return build_type_attribute_variant (ntype, attributes);\n-\t}\n-\n-      if (TYPE_MAIN_VARIANT (t1) == long_unsigned_type_node\n-\t  || TYPE_MAIN_VARIANT (t2) == long_unsigned_type_node)\n-\t{\n-\t  t1 = build_qualified_type (long_unsigned_type_node,\n-\t\t\t\t     TYPE_QUALS (t1));\n-\t  return build_type_attribute_variant (t1, attributes);\n-\t}\n-\n-      if (TYPE_MAIN_VARIANT (t1) == long_integer_type_node\n-\t  || TYPE_MAIN_VARIANT (t2) == long_integer_type_node)\n-\t{\n-\t  tree ntype;\n-\n-\t  /* But preserve unsignedness from the other type,\n-\t     since long cannot hold all the values of an unsigned int.  */\n-\t  if (TYPE_UNSIGNED (t1) || TYPE_UNSIGNED (t2))\n-\t     ntype = long_unsigned_type_node;\n-\t  else\n-\t     ntype = long_integer_type_node;\n-\n-\t  ntype = build_qualified_type (ntype, TYPE_QUALS (t1));\n-\t  return build_type_attribute_variant (ntype, attributes);\n-\t}\n-\n-      /* Likewise, prefer long double to double even if same size.  */\n-      if (TYPE_MAIN_VARIANT (t1) == long_double_type_node\n-\t  || TYPE_MAIN_VARIANT (t2) == long_double_type_node)\n-\t{\n-\t  t1 = build_qualified_type (long_double_type_node,\n-\t\t\t\t     TYPE_QUALS (t1));\n-\t  return build_type_attribute_variant (t1, attributes);\n-\t}\n-\n-      /* Otherwise prefer the unsigned one.  */\n-\n-      if (TYPE_UNSIGNED (t1))\n-\treturn build_type_attribute_variant (t1, attributes);\n-      else\n-\treturn build_type_attribute_variant (t2, attributes);\n-\n     case POINTER_TYPE:\n-      /* For two pointers, do this recursively on the target type,\n-\t and combine the qualifiers of the two types' targets.  */\n-      /* This code was turned off; I don't know why.\n-\t But ANSI C specifies doing this with the qualifiers.\n-\t So I turned it on again.  */\n+      /* For two pointers, do this recursively on the target type.  */\n       {\n \ttree pointed_to_1 = TREE_TYPE (t1);\n \ttree pointed_to_2 = TREE_TYPE (t2);\n-\ttree target = common_type (TYPE_MAIN_VARIANT (pointed_to_1),\n-\t\t\t\t   TYPE_MAIN_VARIANT (pointed_to_2));\n-\tt1 = build_pointer_type (c_build_qualified_type\n-\t\t\t\t (target,\n-\t\t\t\t  TYPE_QUALS (pointed_to_1) |\n-\t\t\t\t  TYPE_QUALS (pointed_to_2)));\n+\ttree target = composite_type (pointed_to_1, pointed_to_2);\n+\tt1 = build_pointer_type (target);\n \treturn build_type_attribute_variant (t1, attributes);\n       }\n \n     case ARRAY_TYPE:\n       {\n-\ttree elt = common_type (TREE_TYPE (t1), TREE_TYPE (t2));\n+\ttree elt = composite_type (TREE_TYPE (t1), TREE_TYPE (t2));\n \t/* Save space: see if the result is identical to one of the args.  */\n \tif (elt == TREE_TYPE (t1) && TYPE_DOMAIN (t1))\n \t  return build_type_attribute_variant (t1, attributes);\n@@ -380,7 +270,7 @@ common_type (tree t1, tree t2)\n       /* Function types: prefer the one that specified arg types.\n \t If both do, merge the arg types.  Also merge the return types.  */\n       {\n-\ttree valtype = common_type (TREE_TYPE (t1), TREE_TYPE (t2));\n+\ttree valtype = composite_type (TREE_TYPE (t1), TREE_TYPE (t2));\n \ttree p1 = TYPE_ARG_TYPES (t1);\n \ttree p2 = TYPE_ARG_TYPES (t2);\n \tint len;\n@@ -468,7 +358,7 @@ common_type (tree t1, tree t2)\n \t\t      goto parm_done;\n \t\t    }\n \t      }\n-\t    TREE_VALUE (n) = common_type (TREE_VALUE (p1), TREE_VALUE (p2));\n+\t    TREE_VALUE (n) = composite_type (TREE_VALUE (p1), TREE_VALUE (p2));\n \t  parm_done: ;\n \t  }\n \n@@ -482,6 +372,182 @@ common_type (tree t1, tree t2)\n     }\n \n }\n+\n+/* Return the type of a conditional expression between pointers to\n+   possibly differently qualified versions of compatible types.\n+\n+   We assume that comp_target_types has already been done and returned\n+   nonzero; if that isn't so, this may crash.  */\n+\n+static tree\n+common_pointer_type (tree t1, tree t2)\n+{\n+  tree attributes;\n+  tree pointed_to_1;\n+  tree pointed_to_2;\n+  tree target;\n+\n+  /* Save time if the two types are the same.  */\n+\n+  if (t1 == t2) return t1;\n+\n+  /* If one type is nonsense, use the other.  */\n+  if (t1 == error_mark_node)\n+    return t2;\n+  if (t2 == error_mark_node)\n+    return t1;\n+\n+  if (TREE_CODE (t1) != POINTER_TYPE || TREE_CODE (t2) != POINTER_TYPE)\n+    abort ();\n+\n+  /* Merge the attributes.  */\n+  attributes = targetm.merge_type_attributes (t1, t2);\n+\n+  /* Find the composite type of the target types, and combine the\n+     qualifiers of the two types' targets.  */\n+  pointed_to_1 = TREE_TYPE (t1);\n+  pointed_to_2 = TREE_TYPE (t2);\n+  target = composite_type (TYPE_MAIN_VARIANT (pointed_to_1),\n+\t\t\t   TYPE_MAIN_VARIANT (pointed_to_2));\n+  t1 = build_pointer_type (c_build_qualified_type\n+\t\t\t   (target,\n+\t\t\t    TYPE_QUALS (pointed_to_1) |\n+\t\t\t    TYPE_QUALS (pointed_to_2)));\n+  return build_type_attribute_variant (t1, attributes);\n+}\n+\n+/* Return the common type for two arithmetic types under the usual\n+   arithmetic conversions.  The default conversions have already been\n+   applied, and enumerated types converted to their compatible integer\n+   types.  The resulting type is unqualified and has no attributes.\n+\n+   This is the type for the result of most arithmetic operations\n+   if the operands have the given two types.  */\n+\n+tree\n+common_type (tree t1, tree t2)\n+{\n+  enum tree_code code1;\n+  enum tree_code code2;\n+\n+  /* If one type is nonsense, use the other.  */\n+  if (t1 == error_mark_node)\n+    return t2;\n+  if (t2 == error_mark_node)\n+    return t1;\n+\n+  if (TYPE_QUALS (t1) != TYPE_UNQUALIFIED)\n+    t1 = TYPE_MAIN_VARIANT (t1);\n+\n+  if (TYPE_QUALS (t2) != TYPE_UNQUALIFIED)\n+    t2 = TYPE_MAIN_VARIANT (t2);\n+\n+  if (TYPE_ATTRIBUTES (t1) != NULL_TREE)\n+    t1 = build_type_attribute_variant (t1, NULL_TREE);\n+\n+  if (TYPE_ATTRIBUTES (t2) != NULL_TREE)\n+    t2 = build_type_attribute_variant (t2, NULL_TREE);\n+\n+  /* Save time if the two types are the same.  */\n+\n+  if (t1 == t2) return t1;\n+\n+  code1 = TREE_CODE (t1);\n+  code2 = TREE_CODE (t2);\n+\n+  if (code1 != VECTOR_TYPE && code1 != COMPLEX_TYPE\n+      && code1 != REAL_TYPE && code1 != INTEGER_TYPE)\n+    abort ();\n+\n+  if (code2 != VECTOR_TYPE && code2 != COMPLEX_TYPE\n+      && code2 != REAL_TYPE && code2 != INTEGER_TYPE)\n+    abort ();\n+\n+  /* If one type is a vector type, return that type.  (How the usual\n+     arithmetic conversions apply to the vector types extension is not\n+     precisely specified.)  */\n+  if (code1 == VECTOR_TYPE)\n+    return t1;\n+\n+  if (code2 == VECTOR_TYPE)\n+    return t2;\n+\n+  /* If one type is complex, form the common type of the non-complex\n+     components, then make that complex.  Use T1 or T2 if it is the\n+     required type.  */\n+  if (code1 == COMPLEX_TYPE || code2 == COMPLEX_TYPE)\n+    {\n+      tree subtype1 = code1 == COMPLEX_TYPE ? TREE_TYPE (t1) : t1;\n+      tree subtype2 = code2 == COMPLEX_TYPE ? TREE_TYPE (t2) : t2;\n+      tree subtype = common_type (subtype1, subtype2);\n+\n+      if (code1 == COMPLEX_TYPE && TREE_TYPE (t1) == subtype)\n+\treturn t1;\n+      else if (code2 == COMPLEX_TYPE && TREE_TYPE (t2) == subtype)\n+\treturn t2;\n+      else\n+\treturn build_complex_type (subtype);\n+    }\n+\n+  /* If only one is real, use it as the result.  */\n+\n+  if (code1 == REAL_TYPE && code2 != REAL_TYPE)\n+    return t1;\n+\n+  if (code2 == REAL_TYPE && code1 != REAL_TYPE)\n+    return t2;\n+\n+  /* Both real or both integers; use the one with greater precision.  */\n+\n+  if (TYPE_PRECISION (t1) > TYPE_PRECISION (t2))\n+    return t1;\n+  else if (TYPE_PRECISION (t2) > TYPE_PRECISION (t1))\n+    return t2;\n+\n+  /* Same precision.  Prefer long longs to longs to ints when the\n+     same precision, following the C99 rules on integer type rank\n+     (which are equivalent to the C90 rules for C90 types).  */\n+\n+  if (TYPE_MAIN_VARIANT (t1) == long_long_unsigned_type_node\n+      || TYPE_MAIN_VARIANT (t2) == long_long_unsigned_type_node)\n+    return long_long_unsigned_type_node;\n+\n+  if (TYPE_MAIN_VARIANT (t1) == long_long_integer_type_node\n+      || TYPE_MAIN_VARIANT (t2) == long_long_integer_type_node)\n+    {\n+      if (TYPE_UNSIGNED (t1) || TYPE_UNSIGNED (t2))\n+\treturn long_long_unsigned_type_node;\n+      else\n+        return long_long_integer_type_node;\n+    }\n+\n+  if (TYPE_MAIN_VARIANT (t1) == long_unsigned_type_node\n+      || TYPE_MAIN_VARIANT (t2) == long_unsigned_type_node)\n+    return long_unsigned_type_node;\n+\n+  if (TYPE_MAIN_VARIANT (t1) == long_integer_type_node\n+      || TYPE_MAIN_VARIANT (t2) == long_integer_type_node)\n+    {\n+      /* But preserve unsignedness from the other type,\n+\t since long cannot hold all the values of an unsigned int.  */\n+      if (TYPE_UNSIGNED (t1) || TYPE_UNSIGNED (t2))\n+\treturn long_unsigned_type_node;\n+      else\n+\treturn long_integer_type_node;\n+    }\n+\n+  /* Likewise, prefer long double to double even if same size.  */\n+  if (TYPE_MAIN_VARIANT (t1) == long_double_type_node\n+      || TYPE_MAIN_VARIANT (t2) == long_double_type_node)\n+    return long_double_type_node;\n+\n+  /* Otherwise prefer the unsigned one.  */\n+\n+  if (TYPE_UNSIGNED (t1))\n+    return t1;\n+  else\n+    return t2;\n+}\n \f\n /* Return 1 if TYPE1 and TYPE2 are compatible types for assignment\n    or various other operations.  Return 2 if they are compatible\n@@ -2760,7 +2826,7 @@ build_conditional_expr (tree ifexp, tree op1, tree op2)\n   else if (code1 == POINTER_TYPE && code2 == POINTER_TYPE)\n     {\n       if (comp_target_types (type1, type2, 1))\n-\tresult_type = common_type (type1, type2);\n+\tresult_type = common_pointer_type (type1, type2);\n       else if (integer_zerop (op1) && TREE_TYPE (type1) == void_type_node\n \t       && TREE_CODE (orig_op1) != NOP_EXPR)\n \tresult_type = qualify_type (type2, type1);\n@@ -6704,7 +6770,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t     Otherwise, the targets must be compatible\n \t     and both must be object or both incomplete.  */\n \t  if (comp_target_types (type0, type1, 1))\n-\t    result_type = common_type (type0, type1);\n+\t    result_type = common_pointer_type (type0, type1);\n \t  else if (VOID_TYPE_P (tt0))\n \t    {\n \t      /* op0 != orig_op0 detects the case of something\n@@ -6752,7 +6818,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t{\n \t  if (comp_target_types (type0, type1, 1))\n \t    {\n-\t      result_type = common_type (type0, type1);\n+\t      result_type = common_pointer_type (type0, type1);\n \t      if (pedantic\n \t\t  && TREE_CODE (TREE_TYPE (type0)) == FUNCTION_TYPE)\n \t\tpedwarn (\"ISO C forbids ordered comparisons of pointers to functions\");\n@@ -6777,7 +6843,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t{\n \t  if (comp_target_types (type0, type1, 1))\n \t    {\n-\t      result_type = common_type (type0, type1);\n+\t      result_type = common_pointer_type (type0, type1);\n \t      if (!COMPLETE_TYPE_P (TREE_TYPE (type0))\n \t\t  != !COMPLETE_TYPE_P (TREE_TYPE (type1)))\n \t\tpedwarn (\"comparison of complete and incomplete pointers\");"}, {"sha": "17871dd339e7df06cf960636cfe74f0099d5b4a9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10bc1b1bec937131ad05fa18184b985078b99702/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10bc1b1bec937131ad05fa18184b985078b99702/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=10bc1b1bec937131ad05fa18184b985078b99702", "patch": "@@ -1,3 +1,8 @@\n+2004-06-06  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\tPR c/13519\n+\t* gcc.c-torture/enum-3.c, gcc.dg/pr13519-1.c: New tests.\n+\n 2004-06-06  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n \n \tPR c++/15503"}, {"sha": "f57bc7f7838b1f7580b99c0b70bd0976e250db7d", "filename": "gcc/testsuite/gcc.c-torture/execute/enum-3.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10bc1b1bec937131ad05fa18184b985078b99702/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fenum-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10bc1b1bec937131ad05fa18184b985078b99702/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fenum-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fenum-3.c?ref=10bc1b1bec937131ad05fa18184b985078b99702", "patch": "@@ -0,0 +1,24 @@\n+/* The composite type of int and an enum compatible with int might be\n+   either of the two types, but it isn't an unsigned type.  */\n+/* Origin: Joseph Myers <jsm@polyomino.org.uk> */\n+\n+#include <limits.h>\n+\n+#include <stdio.h>\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+enum e { a = INT_MIN };\n+\n+int *p;\n+enum e *q;\n+int\n+main (void)\n+{\n+  enum e x = a;\n+  q = &x;\n+  if (*(1 ? q : p) > 0)\n+    abort ();\n+  exit (0);\n+}"}, {"sha": "907165f5f8ec0e4227643e0231ee525862f7b5fe", "filename": "gcc/testsuite/gcc.dg/pr13519-1.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10bc1b1bec937131ad05fa18184b985078b99702/gcc%2Ftestsuite%2Fgcc.dg%2Fpr13519-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10bc1b1bec937131ad05fa18184b985078b99702/gcc%2Ftestsuite%2Fgcc.dg%2Fpr13519-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr13519-1.c?ref=10bc1b1bec937131ad05fa18184b985078b99702", "patch": "@@ -0,0 +1,47 @@\n+/* typeof applied to const+nonconst should be nonconst, as should\n+   typeof applied to other arithmetic expressions.  Bug 13519.  */\n+/* Origin: Debian bug report 208981\n+   from Kalle Olavi Niemitalo <kon@iki.fi>, adapted to a testcase by\n+   Joseph Myers <jsm@polyomino.org.uk>.  */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+void fn(void)\n+{\n+  int n;\n+  const int c;\n+\n+  { __typeof__(n) a1; a1=0; }\n+  { __typeof__(c) a2; a2=0; } /* { dg-error \"read-only\" \"correct error\" } */\n+  { __typeof__((int)n) a3; a3=0; }\n+  { __typeof__((int)c) a4; a4=0; } /* { dg-bogus \"read-only\" \"bogus error\" { xfail *-*-* } } */\n+  { __typeof__((const int)n) a5; a5=0; } /* { dg-error \"read-only\" \"correct error\" { xfail *-*-* } } */\n+  { __typeof__((const int)c) a6; a6=0; } /* { dg-error \"read-only\" \"correct error\" } */\n+  { __typeof__(0) a7; a7=0; }\n+  { __typeof__(1) a8; a8=0; }\n+\n+  { __typeof__(n+n) b0; b0=0; }\n+  { __typeof__(n+c) b1; b1=0; }\n+  { __typeof__(c+n) b2; b2=0; }\n+  { __typeof__(c+c) b3; b3=0; }\n+\n+  { __typeof__(0+n) c0; c0=0; }\n+  { __typeof__(0+c) c1; c1=0; }\n+  { __typeof__(n+0) c2; c2=0; }\n+  { __typeof__(c+0) c3; c3=0; }\n+\n+  { __typeof__(1+n) d0; d0=0; }\n+  { __typeof__(1+c) d1; d1=0; }\n+  { __typeof__(n+1) d2; d2=0; }\n+  { __typeof__(c+1) d3; d3=0; }\n+\n+  { __typeof__(((int)n)+((int)n)) e0; e0=0; }\n+  { __typeof__(((int)n)+((int)c)) e1; e1=0; }\n+  { __typeof__(((int)c)+((int)n)) e2; e2=0; }\n+  { __typeof__(((int)c)+((int)c)) e3; e3=0; }\n+\n+  { __typeof__(((const int)n)+((const int)n)) f0; f0=0; }\n+  { __typeof__(((const int)n)+((const int)c)) f1; f1=0; }\n+  { __typeof__(((const int)c)+((const int)n)) f2; f2=0; }\n+  { __typeof__(((const int)c)+((const int)c)) f3; f3=0; }\n+}"}]}