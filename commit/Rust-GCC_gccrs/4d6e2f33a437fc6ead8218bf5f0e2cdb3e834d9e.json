{"sha": "4d6e2f33a437fc6ead8218bf5f0e2cdb3e834d9e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ2ZTJmMzNhNDM3ZmM2ZWFkODIxOGJmNWYwZTJjZGIzZTgzNGQ5ZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-09-22T13:16:21Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-09-22T13:16:21Z"}, "message": "graphite-isl-ast-to-gimple.c (graphite_verify): Inline into single caller.\n\n2017-09-22  Richard Biener  <rguenther@suse.de>\n\n\t* graphite-isl-ast-to-gimple.c (graphite_verify): Inline into\n\tsingle caller.\n\t(graphite_regenerate_ast_isl): Do not reset SCEV.  Move debug\n\tprint of no dependency loops ...\n\t* graphite.c (graphite_transform_loops): ... here.\n\t(canonicalize_loop_closed_ssa_form): Work from inner to outer\n\tloops.\n\t(same_close_phi_node, remove_duplicate_close_phi,\n\tmake_close_phi_nodes_unique, defined_in_loop_p): Fold into ...\n\t(canonicalize_loop_closed_ssa): ... here and simplify.\n\t* graphite-optimize-isl.c: Include tree-vectorizer.h.\n\t(optimize_isl): Use dump_printf_loc to tell when we stopped\n\toptimizing because of an ISL timeout.\n\n\t* gcc.dg/graphite/scop-24.c: New testcase.\n\nFrom-SVN: r253094", "tree": {"sha": "bd7aa309b1e9ebd76aaef48e163ddf24e3f686ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd7aa309b1e9ebd76aaef48e163ddf24e3f686ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d6e2f33a437fc6ead8218bf5f0e2cdb3e834d9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d6e2f33a437fc6ead8218bf5f0e2cdb3e834d9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d6e2f33a437fc6ead8218bf5f0e2cdb3e834d9e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d6e2f33a437fc6ead8218bf5f0e2cdb3e834d9e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2402ffb6711e01619f6fff7dc6f55be650ef2e23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2402ffb6711e01619f6fff7dc6f55be650ef2e23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2402ffb6711e01619f6fff7dc6f55be650ef2e23"}], "stats": {"total": 213, "additions": 101, "deletions": 112}, "files": [{"sha": "b4fc20be09aefb4f43e3dc45855680f77f161544", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6e2f33a437fc6ead8218bf5f0e2cdb3e834d9e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6e2f33a437fc6ead8218bf5f0e2cdb3e834d9e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d6e2f33a437fc6ead8218bf5f0e2cdb3e834d9e", "patch": "@@ -1,3 +1,19 @@\n+2017-09-22  Richard Biener  <rguenther@suse.de>\n+\n+\t* graphite-isl-ast-to-gimple.c (graphite_verify): Inline into\n+\tsingle caller.\n+\t(graphite_regenerate_ast_isl): Do not reset SCEV.  Move debug\n+\tprint of no dependency loops ...\n+\t* graphite.c (graphite_transform_loops): ... here.\n+\t(canonicalize_loop_closed_ssa_form): Work from inner to outer\n+\tloops.\n+\t(same_close_phi_node, remove_duplicate_close_phi,\n+\tmake_close_phi_nodes_unique, defined_in_loop_p): Fold into ...\n+\t(canonicalize_loop_closed_ssa): ... here and simplify.\n+\t* graphite-optimize-isl.c: Include tree-vectorizer.h.\n+\t(optimize_isl): Use dump_printf_loc to tell when we stopped\n+\toptimizing because of an ISL timeout.\n+\n 2017-09-22  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/82291"}, {"sha": "8c5645b6f341a763978fc291daef20b956895502", "filename": "gcc/graphite-isl-ast-to-gimple.c", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6e2f33a437fc6ead8218bf5f0e2cdb3e834d9e/gcc%2Fgraphite-isl-ast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6e2f33a437fc6ead8218bf5f0e2cdb3e834d9e/gcc%2Fgraphite-isl-ast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-isl-ast-to-gimple.c?ref=4d6e2f33a437fc6ead8218bf5f0e2cdb3e834d9e", "patch": "@@ -73,15 +73,6 @@ struct ast_build_info\n   bool is_parallelizable;\n };\n \n-/* Verifies properties that GRAPHITE should maintain during translation.  */\n-\n-static inline void\n-graphite_verify (void)\n-{\n-  checking_verify_loop_structure ();\n-  checking_verify_loop_closed_ssa (true);\n-}\n-\n /* IVS_PARAMS maps isl's scattering and parameter identifiers\n    to corresponding trees.  */\n \n@@ -2997,8 +2988,9 @@ graphite_regenerate_ast_isl (scop_p scop)\n \t  delete_loop (loop);\n     }\n \n-  graphite_verify ();\n-  scev_reset ();\n+  /* Verifies properties that GRAPHITE should maintain during translation.  */\n+  checking_verify_loop_structure ();\n+  checking_verify_loop_closed_ssa (true);\n \n   free (if_region->true_region);\n   free (if_region->region);\n@@ -3008,19 +3000,6 @@ graphite_regenerate_ast_isl (scop_p scop)\n   isl_ast_node_free (root_node);\n   timevar_pop (TV_GRAPHITE_CODE_GEN);\n \n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      loop_p loop;\n-      int num_no_dependency = 0;\n-\n-      FOR_EACH_LOOP (loop, 0)\n-\tif (loop->can_be_parallel)\n-\t  num_no_dependency++;\n-\n-      fprintf (dump_file, \"%d loops carried no dependency.\\n\",\n-\t       num_no_dependency);\n-    }\n-\n   return !t.codegen_error_p ();\n }\n "}, {"sha": "ef41e55e173082bb76340998ac0771f360a59b3a", "filename": "gcc/graphite-optimize-isl.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6e2f33a437fc6ead8218bf5f0e2cdb3e834d9e/gcc%2Fgraphite-optimize-isl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6e2f33a437fc6ead8218bf5f0e2cdb3e834d9e/gcc%2Fgraphite-optimize-isl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-optimize-isl.c?ref=4d6e2f33a437fc6ead8218bf5f0e2cdb3e834d9e", "patch": "@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-data-ref.h\"\n #include \"params.h\"\n #include \"dumpfile.h\"\n+#include \"tree-vectorizer.h\"\n #include \"graphite.h\"\n \n \n@@ -156,9 +157,12 @@ optimize_isl (scop_p scop)\n   if (!scop->transformed_schedule\n       || isl_ctx_last_error (scop->isl_context) == isl_error_quota)\n     {\n-      if (dump_file && dump_flags)\n-\tfprintf (dump_file, \"isl timed out --param max-isl-operations=%d\\n\",\n-\t\t max_operations);\n+      location_t loc = find_loop_location\n+\t(scop->scop_info->region.entry->dest->loop_father);\n+      dump_printf_loc (MSG_MISSED_OPTIMIZATION, loc,\n+\t\t       \"loop nest not optimized, optimization timed out \"\n+\t\t       \"after %d operations [--param max-isl-operations]\\n\",\n+\t\t       max_operations);\n       return false;\n     }\n "}, {"sha": "a5a31c2c07446845998cf788cada2bc32e8b751d", "filename": "gcc/graphite.c", "status": "modified", "additions": 42, "deletions": 85, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6e2f33a437fc6ead8218bf5f0e2cdb3e834d9e/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6e2f33a437fc6ead8218bf5f0e2cdb3e834d9e/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=4d6e2f33a437fc6ead8218bf5f0e2cdb3e834d9e", "patch": "@@ -293,107 +293,29 @@ free_scops (vec<scop_p> scops)\n   scops.release ();\n }\n \n-/* Returns true when P1 and P2 are close phis with the same\n-   argument.  */\n-\n-static inline bool\n-same_close_phi_node (gphi *p1, gphi *p2)\n-{\n-  return (types_compatible_p (TREE_TYPE (gimple_phi_result (p1)),\n-\t\t\t      TREE_TYPE (gimple_phi_result (p2)))\n-\t  && operand_equal_p (gimple_phi_arg_def (p1, 0),\n-\t\t\t      gimple_phi_arg_def (p2, 0), 0));\n-}\n-\n-static void make_close_phi_nodes_unique (basic_block bb);\n-\n-/* Remove the close phi node at GSI and replace its rhs with the rhs\n-   of PHI.  */\n-\n-static void\n-remove_duplicate_close_phi (gphi *phi, gphi_iterator *gsi)\n-{\n-  gimple *use_stmt;\n-  use_operand_p use_p;\n-  imm_use_iterator imm_iter;\n-  tree res = gimple_phi_result (phi);\n-  tree def = gimple_phi_result (gsi->phi ());\n-\n-  gcc_assert (same_close_phi_node (phi, gsi->phi ()));\n-\n-  FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, def)\n-    {\n-      FOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n-\tSET_USE (use_p, res);\n-\n-      update_stmt (use_stmt);\n-\n-      /* It is possible that we just created a duplicate close-phi\n-\t for an already-processed containing loop.  Check for this\n-\t case and clean it up.  */\n-      if (gimple_code (use_stmt) == GIMPLE_PHI\n-\t  && gimple_phi_num_args (use_stmt) == 1)\n-\tmake_close_phi_nodes_unique (gimple_bb (use_stmt));\n-    }\n-\n-  remove_phi_node (gsi, true);\n-}\n-\n-/* Removes all the close phi duplicates from BB.  */\n-\n-static void\n-make_close_phi_nodes_unique (basic_block bb)\n-{\n-  gphi_iterator psi;\n-\n-  for (psi = gsi_start_phis (bb); !gsi_end_p (psi); gsi_next (&psi))\n-    {\n-      gphi_iterator gsi = psi;\n-      gphi *phi = psi.phi ();\n-\n-      /* At this point, PHI should be a close phi in normal form.  */\n-      gcc_assert (gimple_phi_num_args (phi) == 1);\n-\n-      /* Iterate over the next phis and remove duplicates.  */\n-      gsi_next (&gsi);\n-      while (!gsi_end_p (gsi))\n-\tif (same_close_phi_node (phi, gsi.phi ()))\n-\t  remove_duplicate_close_phi (phi, &gsi);\n-\telse\n-\t  gsi_next (&gsi);\n-    }\n-}\n-\n-/* Return true when NAME is defined in LOOP.  */\n-\n-static bool\n-defined_in_loop_p (tree name, loop_p loop)\n-{\n-  gcc_assert (TREE_CODE (name) == SSA_NAME);\n-  return loop == loop_containing_stmt (SSA_NAME_DEF_STMT (name));\n-}\n-\n /* Transforms LOOP to the canonical loop closed SSA form.  */\n \n static void\n canonicalize_loop_closed_ssa (loop_p loop)\n {\n   edge e = single_exit (loop);\n   basic_block bb;\n+  gphi_iterator psi;\n \n   if (!e || (e->flags & EDGE_COMPLEX))\n     return;\n \n   bb = e->dest;\n \n+  /* Make the loop-close PHI node BB contain only PHIs and have a\n+     single predecessor.  */\n   if (single_pred_p (bb))\n     {\n       e = split_block_after_labels (bb);\n-      make_close_phi_nodes_unique (e->src);\n+      bb = e->src;\n     }\n   else\n     {\n-      gphi_iterator psi;\n       basic_block close = split_edge (e);\n       e = single_succ_edge (close);\n       for (psi = gsi_start_phis (bb); !gsi_end_p (psi); gsi_next (&psi))\n@@ -404,7 +326,7 @@ canonicalize_loop_closed_ssa (loop_p loop)\n \n \t  /* Only add close phi nodes for SSA_NAMEs defined in LOOP.  */\n \t  if (TREE_CODE (arg) != SSA_NAME\n-\t      || !defined_in_loop_p (arg, loop))\n+\t      || loop_containing_stmt (SSA_NAME_DEF_STMT (arg)) != loop)\n \t    continue;\n \n \t  tree res = copy_ssa_name (arg);\n@@ -413,8 +335,30 @@ canonicalize_loop_closed_ssa (loop_p loop)\n \t\t       UNKNOWN_LOCATION);\n \t  SET_USE (use_p, res);\n \t}\n+      bb = close;\n+    }\n+\n+  /* Eliminate duplicates.  This relies on processing loops from\n+     innermost to outer.  */\n+  for (psi = gsi_start_phis (bb); !gsi_end_p (psi); gsi_next (&psi))\n+    {\n+      gphi_iterator gsi = psi;\n+      gphi *phi = psi.phi ();\n+\n+      /* At this point, PHI should be a close phi in normal form.  */\n+      gcc_assert (gimple_phi_num_args (phi) == 1);\n \n-      make_close_phi_nodes_unique (close);\n+      /* Iterate over the next phis and remove duplicates.  */\n+      gsi_next (&gsi);\n+      while (!gsi_end_p (gsi))\n+\tif (gimple_phi_arg_def (phi, 0) == gimple_phi_arg_def (gsi.phi (), 0))\n+\t  {\n+\t    replace_uses_by (gimple_phi_result (gsi.phi ()),\n+\t\t\t     gimple_phi_result (phi));\n+\t    remove_phi_node (&gsi, true);\n+\t  }\n+\telse\n+\t  gsi_next (&gsi);\n     }\n }\n \n@@ -443,7 +387,7 @@ static void\n canonicalize_loop_closed_ssa_form (void)\n {\n   loop_p loop;\n-  FOR_EACH_LOOP (loop, 0)\n+  FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n     canonicalize_loop_closed_ssa (loop);\n \n   checking_verify_loop_closed_ssa (true);\n@@ -509,6 +453,19 @@ graphite_transform_loops (void)\n \t\t\t   \"loop nest optimized\\n\");\n       }\n \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      loop_p loop;\n+      int num_no_dependency = 0;\n+\n+      FOR_EACH_LOOP (loop, 0)\n+\tif (loop->can_be_parallel)\n+\t  num_no_dependency++;\n+\n+      fprintf (dump_file, \"%d loops carried no dependency.\\n\",\n+\t       num_no_dependency);\n+    }\n+\n   free_scops (scops);\n   graphite_finalize (need_cfg_cleanup_p);\n   the_isl_ctx = NULL;"}, {"sha": "161c1bde1ed10665ea585cae1914df70e9bd577d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6e2f33a437fc6ead8218bf5f0e2cdb3e834d9e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6e2f33a437fc6ead8218bf5f0e2cdb3e834d9e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4d6e2f33a437fc6ead8218bf5f0e2cdb3e834d9e", "patch": "@@ -1,3 +1,7 @@\n+2017-09-22  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/graphite/scop-24.c: New testcase.\n+\n 2017-09-22  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/82291"}, {"sha": "a051a11983d1529d0eaad136f7a90b3135af618c", "filename": "gcc/testsuite/gcc.dg/graphite/scop-24.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6e2f33a437fc6ead8218bf5f0e2cdb3e834d9e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6e2f33a437fc6ead8218bf5f0e2cdb3e834d9e/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-24.c?ref=4d6e2f33a437fc6ead8218bf5f0e2cdb3e834d9e", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Ofast -floop-nest-optimize\" } */\n+\n+typedef struct _IO_FILE FILE;\n+extern struct _IO_FILE *stderr;\n+typedef float real;\n+typedef real rvec[3];\n+int rgbset (int);\n+void ps_box (int, int);\n+void plot_phi(char *fn,rvec box,int natoms,rvec x[],real phi[])\n+{\n+  real phi_max,rr,gg,bb,fac,dx,x0,y0;\n+  int i;\n+  for(i=0; (i<natoms); i++) \n+    phi_max=((phi_max > __builtin_fabs(phi[i]))\n+\t     ? phi_max : __builtin_fabs(phi[i]));\n+  if (__builtin_fabs(phi_max)<1.2e-38)\n+      __builtin_fprintf(stderr, \"X\");\n+  ps_box((real)(fac*box[0]-1),(real)(fac*box[1]-1));\n+  for(i=0; (i<natoms); i++)\n+    {\n+      rr=gg=bb=1.0;\n+      if (phi[i] < 0)\n+\tgg=bb=(1.0+(phi[i]/phi_max));\n+      else\n+\trr=gg=(1.0-(phi[i]/phi_max));\n+      rr=rgbset(rr);\n+    }\n+}"}]}