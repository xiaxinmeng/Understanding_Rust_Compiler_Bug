{"sha": "99303ae4ccc37e6c90d94c0adace40e7e36d5b75", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTkzMDNhZTRjY2MzN2U2YzkwZDk0YzBhZGFjZTQwZTdlMzZkNWI3NQ==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@cam.ac.uk", "date": "2000-09-18T16:27:16Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2000-09-18T16:27:16Z"}, "message": "c-common.c (check_format_types): Reorganise and clean up...\n\n\t* c-common.c (check_format_types): Reorganise and clean up,\n\tchecking earlier for ERROR_MARKs and making cur_type into its\n\tTYPE_MAIN_VARIANT where convenient.\n\nFrom-SVN: r36490", "tree": {"sha": "2979203819616393d8ac201db842b482368091eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2979203819616393d8ac201db842b482368091eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99303ae4ccc37e6c90d94c0adace40e7e36d5b75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99303ae4ccc37e6c90d94c0adace40e7e36d5b75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99303ae4ccc37e6c90d94c0adace40e7e36d5b75", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99303ae4ccc37e6c90d94c0adace40e7e36d5b75/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9231abf2edf23048f7f8e2e5028cc60f378e8de6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9231abf2edf23048f7f8e2e5028cc60f378e8de6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9231abf2edf23048f7f8e2e5028cc60f378e8de6"}], "stats": {"total": 195, "additions": 106, "deletions": 89}, "files": [{"sha": "7de3eddb77db323f0191bb86038642614d949171", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99303ae4ccc37e6c90d94c0adace40e7e36d5b75/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99303ae4ccc37e6c90d94c0adace40e7e36d5b75/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=99303ae4ccc37e6c90d94c0adace40e7e36d5b75", "patch": "@@ -1,3 +1,9 @@\n+2000-09-18  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* c-common.c (check_format_types): Reorganise and clean up,\n+\tchecking earlier for ERROR_MARKs and making cur_type into its\n+\tTYPE_MAIN_VARIANT where convenient.\n+\n 2000-09-18  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* gcc.c (cpp_options): Add specs for __STDC_HOSTED__."}, {"sha": "292d946edeb9faf390bb5a61f8588ab06abd0795", "filename": "gcc/c-common.c", "status": "modified", "additions": 100, "deletions": 89, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99303ae4ccc37e6c90d94c0adace40e7e36d5b75/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99303ae4ccc37e6c90d94c0adace40e7e36d5b75/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=99303ae4ccc37e6c90d94c0adace40e7e36d5b75", "patch": "@@ -2514,16 +2514,25 @@ check_format_types (types)\n     {\n       tree cur_param;\n       tree cur_type;\n+      tree orig_cur_type;\n       tree wanted_type;\n       int arg_num;\n       int i;\n       int char_type_flag;\n       cur_param = types->param;\n       cur_type = TREE_TYPE (cur_param);\n+      if (TREE_CODE (cur_type) == ERROR_MARK)\n+\tcontinue;\n       char_type_flag = 0;\n       wanted_type = types->wanted_type;\n       arg_num = types->arg_num;\n \n+      /* The following should not occur here.  */\n+      if (wanted_type == 0)\n+\tabort ();\n+      if (wanted_type == void_type_node && types->pointer_count == 0)\n+\tabort ();\n+\n       STRIP_NOPS (cur_param);\n \n       /* Check the types of any additional pointer arguments\n@@ -2533,6 +2542,8 @@ check_format_types (types)\n \t  if (TREE_CODE (cur_type) == POINTER_TYPE)\n \t    {\n \t      cur_type = TREE_TYPE (cur_type);\n+\t      if (TREE_CODE (cur_type) == ERROR_MARK)\n+\t\tbreak;\n \n \t      if (cur_param != 0 && TREE_CODE (cur_param) == ADDR_EXPR)\n \t\tcur_param = TREE_OPERAND (cur_param, 0);\n@@ -2546,7 +2557,6 @@ check_format_types (types)\n \t\t const void ** is simply passing an incompatible type.  */\n \t      if (types->writing_in_flag\n \t\t  && i == 0\n-\t\t  && TREE_CODE (cur_type) != ERROR_MARK\n \t\t  && (TYPE_READONLY (cur_type)\n \t\t      || (cur_param != 0\n \t\t\t  && (TREE_CODE_CLASS (TREE_CODE (cur_param)) == 'c'\n@@ -2559,117 +2569,118 @@ check_format_types (types)\n \t\t incompatible.  */\n \t      if (i > 0\n \t\t  && pedantic\n-\t\t  && TREE_CODE (cur_type) != ERROR_MARK\n \t\t  && (TYPE_READONLY (cur_type)\n \t\t      || TYPE_VOLATILE (cur_type)\n \t\t      || TYPE_RESTRICT (cur_type)))\n \t\twarning (\"extra type qualifiers in format argument (arg %d)\",\n \t\t\t arg_num);\n \n-\t      continue;\n \t    }\n-\t  if (TREE_CODE (cur_type) != ERROR_MARK)\n+\t  else\n \t    {\n \t      if (types->pointer_count == 1)\n \t\twarning (\"format argument is not a pointer (arg %d)\", arg_num);\n \t      else\n \t\twarning (\"format argument is not a pointer to a pointer (arg %d)\", arg_num);\n+\t      break;\n \t    }\n-\t  break;\n \t}\n \n+      if (i < types->pointer_count)\n+\tcontinue;\n+\n+      orig_cur_type = cur_type;\n+      cur_type = TYPE_MAIN_VARIANT (cur_type);\n+\n       /* Check whether the argument type is a character type.  This leniency\n \t only applies to certain formats, flagged with 'c'.\n       */\n-      if (TREE_CODE (cur_type) != ERROR_MARK && types->char_lenient_flag)\n-\tchar_type_flag = (TYPE_MAIN_VARIANT (cur_type) == char_type_node\n-\t\t\t  || TYPE_MAIN_VARIANT (cur_type) == signed_char_type_node\n-\t\t\t  || TYPE_MAIN_VARIANT (cur_type) == unsigned_char_type_node);\n+      if (types->char_lenient_flag)\n+\tchar_type_flag = (cur_type == char_type_node\n+\t\t\t  || cur_type == signed_char_type_node\n+\t\t\t  || cur_type == unsigned_char_type_node);\n \n       /* Check the type of the \"real\" argument, if there's a type we want.  */\n-      if (i == types->pointer_count && wanted_type != 0\n-\t  && TREE_CODE (cur_type) != ERROR_MARK\n-\t  && wanted_type != TYPE_MAIN_VARIANT (cur_type)\n-\t  /* If we want `void *', allow any pointer type.\n-\t     (Anything else would already have got a warning.)\n-\t     With -pedantic, only allow pointers to void and to character\n-\t     types.\n-\t  */\n-\t  && ! (wanted_type == void_type_node\n-\t\t&& types->pointer_count > 0\n-\t\t&& (! pedantic\n-\t\t    || TYPE_MAIN_VARIANT (cur_type) == void_type_node\n-\t\t    || (i == 1 && char_type_flag)))\n-\t  /* Don't warn about differences merely in signedness, unless\n-\t     -pedantic.  With -pedantic, warn if the type is a pointer\n-\t     target and not a character type, and for character types at\n-\t     a second level of indirection.\n-\t  */\n-\t  && !(TREE_CODE (wanted_type) == INTEGER_TYPE\n-\t       && TREE_CODE (TYPE_MAIN_VARIANT (cur_type)) == INTEGER_TYPE\n-\t       && (! pedantic || i == 0 || (i == 1 && char_type_flag))\n-\t       && (TREE_UNSIGNED (wanted_type)\n-\t\t   ? wanted_type == (cur_type = unsigned_type (cur_type))\n-\t\t   : wanted_type == (cur_type = signed_type (cur_type))))\n-\t  /* Likewise, \"signed char\", \"unsigned char\" and \"char\" are\n-\t     equivalent but the above test won't consider them equivalent.  */\n-\t  && ! (wanted_type == char_type_node\n-\t\t&& (! pedantic || i < 2)\n-\t\t&& char_type_flag))\n-\t{\n-\t  register const char *this;\n-\t  register const char *that;\n-\n-\t  this = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (wanted_type)));\n-\t  that = 0;\n-\t  if (TREE_CODE (cur_type) != ERROR_MARK\n-\t      && TYPE_NAME (cur_type) != 0\n-\t      && TREE_CODE (cur_type) != INTEGER_TYPE\n-\t      && !(TREE_CODE (cur_type) == POINTER_TYPE\n-\t\t   && TREE_CODE (TREE_TYPE (cur_type)) == INTEGER_TYPE))\n-\t    {\n-\t      if (TREE_CODE (TYPE_NAME (cur_type)) == TYPE_DECL\n-\t\t  && DECL_NAME (TYPE_NAME (cur_type)) != 0)\n-\t\tthat = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (cur_type)));\n-\t      else\n-\t\tthat = IDENTIFIER_POINTER (TYPE_NAME (cur_type));\n-\t    }\n+      if (wanted_type == cur_type)\n+\tcontinue;\n+      /* If we want `void *', allow any pointer type.\n+\t (Anything else would already have got a warning.)\n+\t With -pedantic, only allow pointers to void and to character\n+\t types.  */\n+      if (wanted_type == void_type_node\n+\t  && (!pedantic || (i == 1 && char_type_flag)))\n+\tcontinue;\n+      /* Don't warn about differences merely in signedness, unless\n+\t -pedantic.  With -pedantic, warn if the type is a pointer\n+\t target and not a character type, and for character types at\n+\t a second level of indirection.  */\n+      if (TREE_CODE (wanted_type) == INTEGER_TYPE\n+\t  && TREE_CODE (cur_type) == INTEGER_TYPE\n+\t  && (! pedantic || i == 0 || (i == 1 && char_type_flag))\n+\t  && (TREE_UNSIGNED (wanted_type)\n+\t      ? wanted_type == unsigned_type (cur_type)\n+\t      : wanted_type == signed_type (cur_type)))\n+\tcontinue;\n+      /* Likewise, \"signed char\", \"unsigned char\" and \"char\" are\n+\t equivalent but the above test won't consider them equivalent.  */\n+      if (wanted_type == char_type_node\n+\t  && (! pedantic || i < 2)\n+\t  && char_type_flag)\n+\tcontinue;\n+      /* Now we have a type mismatch.  */\n+      {\n+\tregister const char *this;\n+\tregister const char *that;\n+\n+\tthis = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (wanted_type)));\n+\tthat = 0;\n+\tif (TYPE_NAME (orig_cur_type) != 0\n+\t    && TREE_CODE (orig_cur_type) != INTEGER_TYPE\n+\t    && !(TREE_CODE (orig_cur_type) == POINTER_TYPE\n+\t\t && TREE_CODE (TREE_TYPE (orig_cur_type)) == INTEGER_TYPE))\n+\t  {\n+\t    if (TREE_CODE (TYPE_NAME (orig_cur_type)) == TYPE_DECL\n+\t\t&& DECL_NAME (TYPE_NAME (orig_cur_type)) != 0)\n+\t      that = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (orig_cur_type)));\n+\t    else\n+\t      that = IDENTIFIER_POINTER (TYPE_NAME (orig_cur_type));\n+\t  }\n \n-\t  /* A nameless type can't possibly match what the format wants.\n-\t     So there will be a warning for it.\n-\t     Make up a string to describe vaguely what it is.  */\n-\t  if (that == 0)\n-\t    {\n-\t      if (TREE_CODE (cur_type) == POINTER_TYPE)\n-\t\tthat = \"pointer\";\n-\t      else\n-\t\tthat = \"different type\";\n-\t    }\n+\t/* A nameless type can't possibly match what the format wants.\n+\t   So there will be a warning for it.\n+\t   Make up a string to describe vaguely what it is.  */\n+\tif (that == 0)\n+\t  {\n+\t    if (TREE_CODE (orig_cur_type) == POINTER_TYPE)\n+\t      that = \"pointer\";\n+\t    else\n+\t      that = \"different type\";\n+\t  }\n \n-\t  /* Make the warning better in case of mismatch of int vs long.  */\n-\t  if (TREE_CODE (cur_type) == INTEGER_TYPE\n-\t      && TREE_CODE (wanted_type) == INTEGER_TYPE\n-\t      && TYPE_PRECISION (cur_type) == TYPE_PRECISION (wanted_type)\n-\t      && TYPE_NAME (cur_type) != 0\n-\t      && TREE_CODE (TYPE_NAME (cur_type)) == TYPE_DECL)\n-\t    that = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (cur_type)));\n+\t/* Make the warning better in case of mismatch of int vs long.  */\n+\tif (TREE_CODE (orig_cur_type) == INTEGER_TYPE\n+\t    && TREE_CODE (wanted_type) == INTEGER_TYPE\n+\t    && TYPE_PRECISION (orig_cur_type) == TYPE_PRECISION (wanted_type)\n+\t    && TYPE_NAME (orig_cur_type) != 0\n+\t    && TREE_CODE (TYPE_NAME (orig_cur_type)) == TYPE_DECL)\n+\t  that = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (orig_cur_type)));\n \n-\t  if (strcmp (this, that) != 0)\n-\t    {\n-\t      /* There may be a better name for the format, e.g. size_t,\n-\t\t but we should allow for programs with a perverse typedef\n-\t\t making size_t something other than what the compiler\n-\t\t thinks.  */\n-\t      if (types->wanted_type_name != 0\n-\t\t  && strcmp (types->wanted_type_name, that) != 0)\n-\t\tthis = types->wanted_type_name;\n-\t      if (types->name != 0)\n-\t\twarning (\"%s is not type %s (arg %d)\", types->name, this,\n-\t\t\t arg_num);\n-\t      else\n-\t\twarning (\"%s format, %s arg (arg %d)\", this, that, arg_num);\n-\t    }\n-\t}\n+\tif (strcmp (this, that) != 0)\n+\t  {\n+\t    /* There may be a better name for the format, e.g. size_t,\n+\t       but we should allow for programs with a perverse typedef\n+\t       making size_t something other than what the compiler\n+\t       thinks.  */\n+\t    if (types->wanted_type_name != 0\n+\t\t&& strcmp (types->wanted_type_name, that) != 0)\n+\t      this = types->wanted_type_name;\n+\t    if (types->name != 0)\n+\t      warning (\"%s is not type %s (arg %d)\", types->name, this,\n+\t\t       arg_num);\n+\t    else\n+\t      warning (\"%s format, %s arg (arg %d)\", this, that, arg_num);\n+\t  }\n+      }\n     }\n }\n \f"}]}