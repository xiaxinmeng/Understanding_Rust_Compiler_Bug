{"sha": "3e636daf67f5bc544fa620a8d2b460207ec37536", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2U2MzZkYWY2N2Y1YmM1NDRmYTYyMGE4ZDJiNDYwMjA3ZWMzNzUzNg==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2015-11-14T12:31:45Z"}, "committer": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2015-11-14T12:31:45Z"}, "message": "c-decl.c: Use RECORD_OR_UNION_TYPE_P throughout.\n\n\t* c-decl.c: Use RECORD_OR_UNION_TYPE_P throughout.\n\t* c-typeck.c: Likewise.\n\nFrom-SVN: r230375", "tree": {"sha": "31ad5ee8e1e919a154b8371620c992a591b369b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31ad5ee8e1e919a154b8371620c992a591b369b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e636daf67f5bc544fa620a8d2b460207ec37536", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e636daf67f5bc544fa620a8d2b460207ec37536", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e636daf67f5bc544fa620a8d2b460207ec37536", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e636daf67f5bc544fa620a8d2b460207ec37536/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9bd6766df1578d7f149786a809802badf4873ef6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bd6766df1578d7f149786a809802badf4873ef6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bd6766df1578d7f149786a809802badf4873ef6"}], "stats": {"total": 124, "additions": 45, "deletions": 79}, "files": [{"sha": "04fe64da2770276c299e7f45b59cbc9718a30db8", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e636daf67f5bc544fa620a8d2b460207ec37536/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e636daf67f5bc544fa620a8d2b460207ec37536/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=3e636daf67f5bc544fa620a8d2b460207ec37536", "patch": "@@ -1,3 +1,8 @@\n+2015-11-14  Marek Polacek  <polacek@redhat.com>\n+\n+\t* c-decl.c: Use RECORD_OR_UNION_TYPE_P throughout.\n+\t* c-typeck.c: Likewise.\n+\n 2015-11-13  David Malcolm  <dmalcolm@redhat.com>\n \n \t* c-decl.c (warn_defaults_to): Pass line_table to"}, {"sha": "7b9ab8ae6466d923d220ee67c9dd47bd579b332e", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 13, "deletions": 25, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e636daf67f5bc544fa620a8d2b460207ec37536/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e636daf67f5bc544fa620a8d2b460207ec37536/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=3e636daf67f5bc544fa620a8d2b460207ec37536", "patch": "@@ -3048,8 +3048,7 @@ pushdecl (tree x)\n \telement = TREE_TYPE (element);\n       element = TYPE_MAIN_VARIANT (element);\n \n-      if ((TREE_CODE (element) == RECORD_TYPE\n-\t   || TREE_CODE (element) == UNION_TYPE)\n+      if (RECORD_OR_UNION_TYPE_P (element)\n \t  && (TREE_CODE (x) != TYPE_DECL\n \t      || TREE_CODE (TREE_TYPE (x)) == ARRAY_TYPE)\n \t  && !COMPLETE_TYPE_P (element))\n@@ -4643,8 +4642,7 @@ diagnose_uninitialized_cst_member (tree decl, tree type)\n \t  inform (DECL_SOURCE_LOCATION (field), \"%qD should be initialized\", field);\n \t}\n \n-      if (TREE_CODE (field_type) == RECORD_TYPE\n-\t  || TREE_CODE (field_type) == UNION_TYPE)\n+      if (RECORD_OR_UNION_TYPE_P (field_type))\n \tdiagnose_uninitialized_cst_member (decl, field_type);\n     }\n }\n@@ -4966,8 +4964,7 @@ finish_decl (tree decl, location_t init_loc, tree init,\n       if (TREE_READONLY (decl))\n \twarning_at (DECL_SOURCE_LOCATION (decl), OPT_Wc___compat,\n \t\t    \"uninitialized const %qD is invalid in C++\", decl);\n-      else if ((TREE_CODE (type) == RECORD_TYPE\n-\t      \t|| TREE_CODE (type) == UNION_TYPE)\n+      else if (RECORD_OR_UNION_TYPE_P (type)\n \t       && C_TYPE_FIELDS_READONLY (type))\n \tdiagnose_uninitialized_cst_member (decl, type);\n     }\n@@ -6726,8 +6723,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t&& VAR_P (decl)\n \t&& TREE_PUBLIC (decl)\n \t&& TREE_STATIC (decl)\n-\t&& (TREE_CODE (TREE_TYPE (decl)) == RECORD_TYPE\n-\t    || TREE_CODE (TREE_TYPE (decl)) == UNION_TYPE\n+\t&& (RECORD_OR_UNION_TYPE_P (TREE_TYPE (decl))\n \t    || TREE_CODE (TREE_TYPE (decl)) == ENUMERAL_TYPE)\n \t&& TYPE_NAME (TREE_TYPE (decl)) == NULL_TREE)\n       warning_at (DECL_SOURCE_LOCATION (decl), OPT_Wc___compat,\n@@ -7282,8 +7278,7 @@ grokfield (location_t loc,\n \t that took root before someone noticed the bug...  */\n \n       tree type = declspecs->type;\n-      bool type_ok = (TREE_CODE (type) == RECORD_TYPE\n-\t\t      || TREE_CODE (type) == UNION_TYPE);\n+      bool type_ok = RECORD_OR_UNION_TYPE_P (type);\n       bool ok = false;\n \n       if (type_ok\n@@ -7359,7 +7354,7 @@ is_duplicate_field (tree x, tree y)\n       xt = TREE_TYPE (x);\n       if (DECL_NAME (x) != NULL_TREE)\n \txn = DECL_NAME (x);\n-      else if ((TREE_CODE (xt) == RECORD_TYPE || TREE_CODE (xt) == UNION_TYPE)\n+      else if (RECORD_OR_UNION_TYPE_P (xt)\n \t       && TYPE_NAME (xt) != NULL_TREE\n \t       && TREE_CODE (TYPE_NAME (xt)) == TYPE_DECL)\n \txn = DECL_NAME (TYPE_NAME (xt));\n@@ -7369,7 +7364,7 @@ is_duplicate_field (tree x, tree y)\n       yt = TREE_TYPE (y);\n       if (DECL_NAME (y) != NULL_TREE)\n \tyn = DECL_NAME (y);\n-      else if ((TREE_CODE (yt) == RECORD_TYPE || TREE_CODE (yt) == UNION_TYPE)\n+      else if (RECORD_OR_UNION_TYPE_P (yt)\n \t       && TYPE_NAME (yt) != NULL_TREE\n \t       && TREE_CODE (TYPE_NAME (yt)) == TYPE_DECL)\n \tyn = DECL_NAME (TYPE_NAME (yt));\n@@ -7404,8 +7399,7 @@ detect_field_duplicates_hash (tree fieldlist,\n \t  }\n \t*slot = y;\n       }\n-    else if (TREE_CODE (TREE_TYPE (x)) == RECORD_TYPE\n-\t     || TREE_CODE (TREE_TYPE (x)) == UNION_TYPE)\n+    else if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (x)))\n       {\n \tdetect_field_duplicates_hash (TYPE_FIELDS (TREE_TYPE (x)), htab);\n \n@@ -7456,8 +7450,7 @@ detect_field_duplicates (tree fieldlist)\n   do {\n     timeout--;\n     if (DECL_NAME (x) == NULL_TREE\n-\t&& (TREE_CODE (TREE_TYPE (x)) == RECORD_TYPE\n-\t    || TREE_CODE (TREE_TYPE (x)) == UNION_TYPE))\n+\t&& RECORD_OR_UNION_TYPE_P (TREE_TYPE (x)))\n       timeout = 0;\n     x = DECL_CHAIN (x);\n   } while (timeout > 0 && x);\n@@ -7473,8 +7466,7 @@ detect_field_duplicates (tree fieldlist)\n \tif (DECL_NAME (x)\n \t    || (flag_plan9_extensions\n \t\t&& DECL_NAME (x) == NULL_TREE\n-\t\t&& (TREE_CODE (TREE_TYPE (x)) == RECORD_TYPE\n-\t\t    || TREE_CODE (TREE_TYPE (x)) == UNION_TYPE)\n+\t\t&& RECORD_OR_UNION_TYPE_P (TREE_TYPE (x))\n \t\t&& TYPE_NAME (TREE_TYPE (x)) != NULL_TREE\n \t\t&& TREE_CODE (TYPE_NAME (TREE_TYPE (x))) == TYPE_DECL))\n \t  {\n@@ -7587,9 +7579,7 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n \t{\n \t  if (DECL_NAME (x) != 0)\n \t    break;\n-\t  if (flag_isoc11\n-\t      && (TREE_CODE (TREE_TYPE (x)) == RECORD_TYPE\n-\t\t  || TREE_CODE (TREE_TYPE (x)) == UNION_TYPE))\n+\t  if (flag_isoc11 && RECORD_OR_UNION_TYPE_P (TREE_TYPE (x)))\n \t    break;\n \t}\n \n@@ -7634,8 +7624,7 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n \t{\n \t  /* A field that is pseudo-const makes the structure likewise.  */\n \t  tree t1 = strip_array_types (TREE_TYPE (x));\n-\t  if ((TREE_CODE (t1) == RECORD_TYPE || TREE_CODE (t1) == UNION_TYPE)\n-\t      && C_TYPE_FIELDS_READONLY (t1))\n+\t  if (RECORD_OR_UNION_TYPE_P (t1) && C_TYPE_FIELDS_READONLY (t1))\n \t    C_TYPE_FIELDS_READONLY (t) = 1;\n \t}\n \n@@ -7693,8 +7682,7 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n \t\t \"invalid use of structure with flexible array member\");\n \n       if (DECL_NAME (x)\n-\t  || TREE_CODE (TREE_TYPE (x)) == RECORD_TYPE\n-\t  || TREE_CODE (TREE_TYPE (x)) == UNION_TYPE)\n+\t  || RECORD_OR_UNION_TYPE_P (TREE_TYPE (x)))\n \tsaw_named_field = 1;\n     }\n "}, {"sha": "0215edac3c53ae0525c8d9848b15ffcfdfaca9f4", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 27, "deletions": 54, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e636daf67f5bc544fa620a8d2b460207ec37536/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e636daf67f5bc544fa620a8d2b460207ec37536/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=3e636daf67f5bc544fa620a8d2b460207ec37536", "patch": "@@ -2166,8 +2166,7 @@ lookup_field (tree type, tree component)\n \t      while (DECL_NAME (field_array[bot]) == NULL_TREE)\n \t\t{\n \t\t  field = field_array[bot++];\n-\t\t  if (TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE\n-\t\t      || TREE_CODE (TREE_TYPE (field)) == UNION_TYPE)\n+\t\t  if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (field)))\n \t\t    {\n \t\t      tree anon = lookup_field (TREE_TYPE (field), component);\n \n@@ -2213,8 +2212,7 @@ lookup_field (tree type, tree component)\n       for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n \t{\n \t  if (DECL_NAME (field) == NULL_TREE\n-\t      && (TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE\n-\t\t  || TREE_CODE (TREE_TYPE (field)) == UNION_TYPE))\n+\t      && RECORD_OR_UNION_TYPE_P (TREE_TYPE (field)))\n \t    {\n \t      tree anon = lookup_field (TREE_TYPE (field), component);\n \n@@ -2253,13 +2251,9 @@ lookup_field_fuzzy_find_candidates (tree type, tree component,\n   for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n     {\n       if (DECL_NAME (field) == NULL_TREE\n-\t  && (TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE\n-\t      || TREE_CODE (TREE_TYPE (field)) == UNION_TYPE))\n-\t{\n-\t  lookup_field_fuzzy_find_candidates (TREE_TYPE (field),\n-\t\t\t\t\t      component,\n-\t\t\t\t\t      candidates);\n-\t}\n+\t  && RECORD_OR_UNION_TYPE_P (TREE_TYPE (field)))\n+\tlookup_field_fuzzy_find_candidates (TREE_TYPE (field), component,\n+\t\t\t\t\t    candidates);\n \n       if (DECL_NAME (field))\n \tcandidates->safe_push (DECL_NAME (field));\n@@ -5131,8 +5125,7 @@ build_c_cast (location_t loc, tree type, tree expr)\n \n   if (type == TYPE_MAIN_VARIANT (TREE_TYPE (value)))\n     {\n-      if (TREE_CODE (type) == RECORD_TYPE\n-\t  || TREE_CODE (type) == UNION_TYPE)\n+      if (RECORD_OR_UNION_TYPE_P (type))\n \tpedwarn (loc, OPT_Wpedantic,\n \t\t \"ISO C forbids casting nonscalar to the same type\");\n \n@@ -5224,8 +5217,7 @@ build_c_cast (location_t loc, tree type, tree expr)\n \t  && TREE_CODE (TREE_TYPE (otype)) != FUNCTION_TYPE\n \t  /* Don't warn about opaque types, where the actual alignment\n \t     restriction is unknown.  */\n-\t  && !((TREE_CODE (TREE_TYPE (otype)) == UNION_TYPE\n-\t\t|| TREE_CODE (TREE_TYPE (otype)) == RECORD_TYPE)\n+\t  && !(RECORD_OR_UNION_TYPE_P (TREE_TYPE (otype))\n \t       && TYPE_MODE (TREE_TYPE (otype)) == VOIDmode)\n \t  && TYPE_ALIGN (TREE_TYPE (type)) > TYPE_ALIGN (TREE_TYPE (otype)))\n \twarning_at (loc, OPT_Wcast_align,\n@@ -5484,8 +5476,7 @@ build_modify_expr (location_t location, tree lhs, tree lhs_origtype,\n   /* Give an error for storing in something that is 'const'.  */\n \n   if (TYPE_READONLY (lhstype)\n-      || ((TREE_CODE (lhstype) == RECORD_TYPE\n-\t   || TREE_CODE (lhstype) == UNION_TYPE)\n+      || (RECORD_OR_UNION_TYPE_P (lhstype)\n \t  && C_TYPE_FIELDS_READONLY (lhstype)))\n     {\n       readonly_error (location, lhs, lv_assign);\n@@ -5611,8 +5602,7 @@ find_anonymous_field_with_type (tree struct_type, tree type)\n   tree field;\n   bool found;\n \n-  gcc_assert (TREE_CODE (struct_type) == RECORD_TYPE\n-\t      || TREE_CODE (struct_type) == UNION_TYPE);\n+  gcc_assert (RECORD_OR_UNION_TYPE_P (struct_type));\n   found = false;\n   for (field = TYPE_FIELDS (struct_type);\n        field != NULL_TREE;\n@@ -5630,8 +5620,7 @@ find_anonymous_field_with_type (tree struct_type, tree type)\n \t  found = true;\n \t}\n       else if (DECL_NAME (field) == NULL\n-\t       && (TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE\n-\t\t   || TREE_CODE (TREE_TYPE (field)) == UNION_TYPE)\n+\t       && RECORD_OR_UNION_TYPE_P (TREE_TYPE (field))\n \t       && find_anonymous_field_with_type (TREE_TYPE (field), type))\n \t{\n \t  if (found)\n@@ -5657,8 +5646,7 @@ convert_to_anonymous_field (location_t location, tree type, tree rhs)\n \n   gcc_assert (POINTER_TYPE_P (TREE_TYPE (rhs)));\n   rhs_struct_type = TREE_TYPE (TREE_TYPE (rhs));\n-  gcc_assert (TREE_CODE (rhs_struct_type) == RECORD_TYPE\n-\t      || TREE_CODE (rhs_struct_type) == UNION_TYPE);\n+  gcc_assert (RECORD_OR_UNION_TYPE_P (rhs_struct_type));\n \n   gcc_assert (POINTER_TYPE_P (type));\n   lhs_main_type = (TYPE_ATOMIC (TREE_TYPE (type))\n@@ -5673,8 +5661,7 @@ convert_to_anonymous_field (location_t location, tree type, tree rhs)\n        field = TREE_CHAIN (field))\n     {\n       if (DECL_NAME (field) != NULL_TREE\n-\t  || (TREE_CODE (TREE_TYPE (field)) != RECORD_TYPE\n-\t      && TREE_CODE (TREE_TYPE (field)) != UNION_TYPE))\n+\t  || !RECORD_OR_UNION_TYPE_P (TREE_TYPE (field)))\n \tcontinue;\n       tree fieldtype = (TYPE_ATOMIC (TREE_TYPE (field))\n \t\t\t? c_build_qualified_type (TREE_TYPE (field),\n@@ -6211,8 +6198,8 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \t automatically converted into a pointer to an anonymous field\n \t within the struct.  */\n       if (flag_plan9_extensions\n-\t  && (TREE_CODE (mvl) == RECORD_TYPE || TREE_CODE(mvl) == UNION_TYPE)\n-\t  && (TREE_CODE (mvr) == RECORD_TYPE || TREE_CODE(mvr) == UNION_TYPE)\n+\t  && RECORD_OR_UNION_TYPE_P (mvl)\n+\t  && RECORD_OR_UNION_TYPE_P (mvr)\n \t  && mvl != mvr)\n \t{\n \t  tree new_rhs = convert_to_anonymous_field (location, type, rhs);\n@@ -7367,8 +7354,7 @@ really_start_incremental_init (tree type)\n   designator_depth = 0;\n   designator_erroneous = 0;\n \n-  if (TREE_CODE (constructor_type) == RECORD_TYPE\n-      || TREE_CODE (constructor_type) == UNION_TYPE)\n+  if (RECORD_OR_UNION_TYPE_P (constructor_type))\n     {\n       constructor_fields = TYPE_FIELDS (constructor_type);\n       /* Skip any nameless bit fields at the beginning.  */\n@@ -7448,8 +7434,7 @@ push_init_level (location_t loc, int implicit,\n     {\n       while (constructor_stack->implicit)\n \t{\n-\t  if ((TREE_CODE (constructor_type) == RECORD_TYPE\n-\t       || TREE_CODE (constructor_type) == UNION_TYPE)\n+\t  if (RECORD_OR_UNION_TYPE_P (constructor_type)\n \t      && constructor_fields == 0)\n \t    process_init_element (input_location,\n \t\t\t\t  pop_init_level (loc, 1, braced_init_obstack),\n@@ -7470,9 +7455,7 @@ push_init_level (location_t loc, int implicit,\n      content if any.  */\n   if (implicit)\n     {\n-      if ((TREE_CODE (constructor_type) == RECORD_TYPE\n-\t   || TREE_CODE (constructor_type) == UNION_TYPE)\n-\t  && constructor_fields)\n+      if (RECORD_OR_UNION_TYPE_P (constructor_type) && constructor_fields)\n \tvalue = find_init_member (constructor_fields, braced_init_obstack);\n       else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n \tvalue = find_init_member (constructor_index, braced_init_obstack);\n@@ -7525,8 +7508,7 @@ push_init_level (location_t loc, int implicit,\n      in the containing level.  */\n   if (constructor_type == 0)\n     ;\n-  else if (TREE_CODE (constructor_type) == RECORD_TYPE\n-\t   || TREE_CODE (constructor_type) == UNION_TYPE)\n+  else if (RECORD_OR_UNION_TYPE_P (constructor_type))\n     {\n       /* Don't die if there are extra init elts at the end.  */\n       if (constructor_fields == 0)\n@@ -7571,8 +7553,7 @@ push_init_level (location_t loc, int implicit,\n   if (implicit == 1)\n     found_missing_braces = 1;\n \n-  if (TREE_CODE (constructor_type) == RECORD_TYPE\n-\t   || TREE_CODE (constructor_type) == UNION_TYPE)\n+  if (RECORD_OR_UNION_TYPE_P (constructor_type))\n     {\n       constructor_fields = TYPE_FIELDS (constructor_type);\n       /* Skip any nameless bit fields at the beginning.  */\n@@ -7760,8 +7741,7 @@ pop_init_level (location_t loc, int implicit,\n     ret = p->replacement_value;\n   else if (constructor_type == 0)\n     ;\n-  else if (TREE_CODE (constructor_type) != RECORD_TYPE\n-\t   && TREE_CODE (constructor_type) != UNION_TYPE\n+  else if (!RECORD_OR_UNION_TYPE_P (constructor_type)\n \t   && TREE_CODE (constructor_type) != ARRAY_TYPE\n \t   && !VECTOR_TYPE_P (constructor_type))\n     {\n@@ -8028,8 +8008,7 @@ set_init_label (location_t loc, tree fieldname,\n \n   designator_erroneous = 1;\n \n-  if (TREE_CODE (constructor_type) != RECORD_TYPE\n-      && TREE_CODE (constructor_type) != UNION_TYPE)\n+  if (!RECORD_OR_UNION_TYPE_P (constructor_type))\n     {\n       error_init (loc, \"field name not in record or union initializer\");\n       return;\n@@ -8544,8 +8523,7 @@ output_init_element (location_t loc, tree value, tree origtype,\n \t\t\t\t\t  AGGREGATE_TYPE_P (constructor_type)\n \t\t\t\t\t  && TYPE_REVERSE_STORAGE_ORDER\n \t\t\t\t\t     (constructor_type))\n-\t   || ((TREE_CODE (constructor_type) == RECORD_TYPE\n-\t\t|| TREE_CODE (constructor_type) == UNION_TYPE)\n+\t   || (RECORD_OR_UNION_TYPE_P (constructor_type)\n \t       && DECL_C_BIT_FIELD (field)\n \t       && TREE_CODE (value) != INTEGER_CST))\n     constructor_simple = 0;\n@@ -8766,8 +8744,7 @@ output_pending_init_elements (int all, struct obstack * braced_init_obstack)\n \t\t}\n \t    }\n \t}\n-      else if (TREE_CODE (constructor_type) == RECORD_TYPE\n-\t       || TREE_CODE (constructor_type) == UNION_TYPE)\n+      else if (RECORD_OR_UNION_TYPE_P (constructor_type))\n \t{\n \t  tree ctor_unfilled_bitpos, elt_bitpos;\n \n@@ -8831,8 +8808,7 @@ output_pending_init_elements (int all, struct obstack * braced_init_obstack)\n \n   /* If it's not incremental, just skip over the gap, so that after\n      jumping to retry we will output the next successive element.  */\n-  if (TREE_CODE (constructor_type) == RECORD_TYPE\n-      || TREE_CODE (constructor_type) == UNION_TYPE)\n+  if (RECORD_OR_UNION_TYPE_P (constructor_type))\n     constructor_unfilled_fields = next;\n   else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n     constructor_unfilled_index = next;\n@@ -8909,8 +8885,7 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n      pop them now.  */\n   while (constructor_stack->implicit)\n     {\n-      if ((TREE_CODE (constructor_type) == RECORD_TYPE\n-\t   || TREE_CODE (constructor_type) == UNION_TYPE)\n+      if (RECORD_OR_UNION_TYPE_P (constructor_type)\n \t  && constructor_fields == 0)\n \tprocess_init_element (loc,\n \t\t\t      pop_init_level (loc, 1, braced_init_obstack),\n@@ -9357,8 +9332,7 @@ build_asm_expr (location_t loc, tree string, tree outputs, tree inputs,\n       if (output != error_mark_node\n \t  && (TREE_READONLY (output)\n \t      || TYPE_READONLY (TREE_TYPE (output))\n-\t      || ((TREE_CODE (TREE_TYPE (output)) == RECORD_TYPE\n-\t\t   || TREE_CODE (TREE_TYPE (output)) == UNION_TYPE)\n+\t      || (RECORD_OR_UNION_TYPE_P (TREE_TYPE (output))\n \t\t  && C_TYPE_FIELDS_READONLY (TREE_TYPE (output)))))\n \treadonly_error (loc, output, lv_asm);\n \n@@ -13376,8 +13350,7 @@ c_build_qualified_type (tree type, int type_quals)\n   tree var_type = build_qualified_type (type, type_quals);\n   /* A variant type does not inherit the list of incomplete vars from the\n      type main variant.  */\n-  if (TREE_CODE (var_type) == RECORD_TYPE\n-      || TREE_CODE (var_type) == UNION_TYPE)\n+  if (RECORD_OR_UNION_TYPE_P (var_type))\n     C_TYPE_INCOMPLETE_VARS (var_type) = 0;\n   return var_type;\n }"}]}