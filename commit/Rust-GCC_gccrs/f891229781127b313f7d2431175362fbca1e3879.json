{"sha": "f891229781127b313f7d2431175362fbca1e3879", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjg5MTIyOTc4MTEyN2IzMTNmN2QyNDMxMTc1MzYyZmJjYTFlMzg3OQ==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1997-10-30T20:34:59Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-10-30T20:34:59Z"}, "message": "mn10300.c (const_8bit_operand): New function.\n\n        * mn10300.c (const_8bit_operand): New function.\n        (mask_ok_for_mem_btst): New funtion.\n        * mn10300.md (btst patterns with mem operands): Use new functions\n        to avoid creating btst instructions with invalid operands.\n\nFrom-SVN: r16236", "tree": {"sha": "b0a50279581c9c24ce476f9c45f602ae5bf5eba1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0a50279581c9c24ce476f9c45f602ae5bf5eba1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f891229781127b313f7d2431175362fbca1e3879", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f891229781127b313f7d2431175362fbca1e3879", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f891229781127b313f7d2431175362fbca1e3879", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f891229781127b313f7d2431175362fbca1e3879/comments", "author": null, "committer": null, "parents": [{"sha": "5da07ba3ac82ad71597205a0357aede7dd897ff8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5da07ba3ac82ad71597205a0357aede7dd897ff8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5da07ba3ac82ad71597205a0357aede7dd897ff8"}], "stats": {"total": 62, "additions": 60, "deletions": 2}, "files": [{"sha": "4af977e8f9ec3ca8805cbf28bf2b2b7fe957b862", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f891229781127b313f7d2431175362fbca1e3879/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f891229781127b313f7d2431175362fbca1e3879/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f891229781127b313f7d2431175362fbca1e3879", "patch": "@@ -1,3 +1,10 @@\n+Thu Oct 30 13:26:12 1997  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* mn10300.c (const_8bit_operand): New function.\n+\t(mask_ok_for_mem_btst): New funtion.\n+\t* mn10300.md (btst patterns with mem operands): Use new functions\n+\tto avoid creating btst instructions with invalid operands.\n+\n Wed Oct 29 16:57:19 1997  Michael Meissner  <meissner@cygnus.com>\n \n \t* rs6000/xm-sysv4.h: Include xm-linux.h instead of xm-svr4.h if we"}, {"sha": "201b51d1df22037e0661007a8ca2f7366aa7a12e", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f891229781127b313f7d2431175362fbca1e3879/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f891229781127b313f7d2431175362fbca1e3879/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=f891229781127b313f7d2431175362fbca1e3879", "patch": "@@ -990,6 +990,42 @@ impossible_plus_operand (op, mode)\n   return 0;\n }\n \n+/* Return 1 if X is a CONST_INT that is only 8 bits wide.  This is used\n+   for the btst insn which may examine memory or a register (the memory\n+   variant only allows an unsigned 8 bit integer).  */\n+int\n+const_8bit_operand (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == CONST_INT\n+\t  && INTVAL (op) >= 0\n+\t  && INTVAL (op) < 256);\n+}\n+\n+/* Similarly, but when using a zero_extract pattern for a btst where\n+   the source operand might end up in memory.  */\n+int\n+mask_ok_for_mem_btst (len, bit)\n+     int len;\n+     int bit;\n+{\n+  int mask = 0;\n+\n+  while (len > 0)\n+    {\n+      mask |= (1 << bit);\n+      bit++;\n+      len--;\n+    }\n+\n+  /* MASK must bit into an 8bit value.  */\n+  return (((mask & 0xff) == mask)\n+\t  || ((mask & 0xff00) == mask)\n+\t  || ((mask & 0xff0000) == mask)\n+\t  || ((mask & 0xff000000) == mask));\n+}\n+\n /* Return 1 if X contains a symbolic expression.  We know these\n    expressions will have one of a few well defined forms, so\n    we need only check those forms.  */"}, {"sha": "1547ad01323d4a059e9a1c86f985d3c79b161e42", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f891229781127b313f7d2431175362fbca1e3879/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f891229781127b313f7d2431175362fbca1e3879/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=f891229781127b313f7d2431175362fbca1e3879", "patch": "@@ -927,7 +927,7 @@\n      (zero_extract:SI (match_operand:QI 0 \"general_operand\" \"R,d\")\n \t\t      (match_operand 1 \"const_int_operand\" \"\")\n \t\t      (match_operand 2 \"const_int_operand\" \"\")))]\n-  \"INTVAL (operands[1]) <= 8 && INTVAL (operands[2]) <= 7\"\n+  \"mask_ok_for_mem_btst (INTVAL (operands[1]), INTVAL (operands[2]))\"\n   \"*\n {\n   int len = INTVAL (operands[1]);\n@@ -942,6 +942,21 @@\n       len--;\n     }\n \n+  /* If the source operand is not a reg (ie it is memory), then extract the\n+     bits from mask that we actually want to test.  Note that the mask will\n+     never cross a byte boundary.  */\n+  if (!REG_P (operands[0]))\n+    {\n+      if (mask & 0xff)\n+\tmask = mask & 0xff;\n+      else if (mask & 0xff00)\n+\tmask = (mask >> 8) & 0xff;\n+      else if (mask & 0xff0000)\n+\tmask = (mask >> 16) & 0xff;\n+      else if (mask & 0xff000000)\n+\tmask = (mask >> 24) & 0xff;\n+    }\n+  \n   xoperands[0] = operands[0];\n   xoperands[1] = GEN_INT (mask);\n   if (GET_CODE (operands[0]) == REG)\n@@ -963,7 +978,7 @@\n   [(set (cc0)\n      (and:SI\n        (subreg:SI (match_operand:QI 0 \"general_operand\" \"R,d\") 0)\n-       (match_operand:SI 1 \"const_int_operand\" \"\")))]\n+       (match_operand:SI 1 \"const_8bit_operand\" \"\")))]\n   \"\"\n   \"@\n   btst %1,%A0"}]}