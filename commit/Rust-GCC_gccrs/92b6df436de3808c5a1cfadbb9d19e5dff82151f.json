{"sha": "92b6df436de3808c5a1cfadbb9d19e5dff82151f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTJiNmRmNDM2ZGUzODA4YzVhMWNmYWRiYjlkMTllNWRmZjgyMTUxZg==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2018-08-30T21:02:37Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@gcc.gnu.org", "date": "2018-08-30T21:02:37Z"}, "message": "target.def (custom_function_descriptors): Improve documentation.\n\n2018-08-30  Sandra Loosemore  <sandra@codesourcery.com>\n\n\tgcc/\n\t* target.def (custom_function_descriptors): Improve documentation.\n\t* doc/tm.texi.in (Trampolines): Expand discussion of function\n\tdescriptors and move TARGET_CUSTOM_FUNCTION_DESCRIPTORS to the\n\tbeginning of the section.\n\t* doc/tm.texi: Regenerated.\n\nFrom-SVN: r263999", "tree": {"sha": "f75ee5dccc771d25ce52e114100eaf16a66e4e3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f75ee5dccc771d25ce52e114100eaf16a66e4e3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92b6df436de3808c5a1cfadbb9d19e5dff82151f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92b6df436de3808c5a1cfadbb9d19e5dff82151f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92b6df436de3808c5a1cfadbb9d19e5dff82151f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92b6df436de3808c5a1cfadbb9d19e5dff82151f/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "429331b676df82e99c02bce1b65fa5376b48cf93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/429331b676df82e99c02bce1b65fa5376b48cf93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/429331b676df82e99c02bce1b65fa5376b48cf93"}], "stats": {"total": 216, "additions": 148, "deletions": 68}, "files": [{"sha": "363a80f3db9294dd9382430a9bde8b7c6d20d912", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92b6df436de3808c5a1cfadbb9d19e5dff82151f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92b6df436de3808c5a1cfadbb9d19e5dff82151f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=92b6df436de3808c5a1cfadbb9d19e5dff82151f", "patch": "@@ -1,3 +1,11 @@\n+2018-08-30  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\t* target.def (custom_function_descriptors): Improve documentation.\n+\t* doc/tm.texi.in (Trampolines): Expand discussion of function\n+\tdescriptors and move TARGET_CUSTOM_FUNCTION_DESCRIPTORS to the\n+\tbeginning of the section.\n+\t* doc/tm.texi: Regenerated.\n+\n 2018-08-30  Jose E. Marchesi  <jose.marchesi@oracle.com>\n \n \t* cfg.h (class auto_edge_flag): Spell out the template-id of the"}, {"sha": "551dc229c0b2dcb61aa9f7c29cc7dfa243f26905", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 71, "deletions": 35, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92b6df436de3808c5a1cfadbb9d19e5dff82151f/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92b6df436de3808c5a1cfadbb9d19e5dff82151f/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=92b6df436de3808c5a1cfadbb9d19e5dff82151f", "patch": "@@ -5267,24 +5267,78 @@ into the stack.  Arguments meaning is similar to\n @end deftypefn\n \n @node Trampolines\n-@section Trampolines for Nested Functions\n+@section Support for Nested Functions\n+@cindex support for nested functions\n @cindex trampolines for nested functions\n-@cindex nested functions, trampolines for\n-\n-A @dfn{trampoline} is a small piece of code that is created at run time\n-when the address of a nested function is taken.  It normally resides on\n-the stack, in the stack frame of the containing function.  These macros\n-tell GCC how to generate code to allocate and initialize a\n-trampoline.\n-\n-The instructions in the trampoline must do two things: load a constant\n-address into the static chain register, and jump to the real address of\n-the nested function.  On CISC machines such as the m68k, this requires\n-two instructions, a move immediate and a jump.  Then the two addresses\n-exist in the trampoline as word-long immediate operands.  On RISC\n-machines, it is often necessary to load each address into a register in\n-two parts.  Then pieces of each address form separate immediate\n-operands.\n+@cindex descriptors for nested functions\n+@cindex nested functions, support for\n+\n+Taking the address of a nested function requires special compiler\n+handling to ensure that the static chain register is loaded when\n+the function is invoked via an indirect call.\n+\n+GCC has traditionally supported nested functions by creating an\n+executable @dfn{trampoline} at run time when the address of a nested\n+function is taken.  This is a small piece of code which normally\n+resides on the stack, in the stack frame of the containing function.\n+The trampoline loads the static chain register and then jumps to the\n+real address of the nested function.\n+\n+The use of trampolines requires an executable stack, which is a\n+security risk.  To avoid this problem, GCC also supports another\n+strategy: using descriptors for nested functions.  Under this model,\n+taking the address of a nested function results in a pointer to a\n+non-executable function descriptor object.  Initializing the static chain\n+from the descriptor is handled at indirect call sites.\n+\n+On some targets, including HPPA and IA-64, function descriptors may be\n+mandated by the ABI or be otherwise handled in a target-specific way\n+by the back end in its code generation strategy for indirect calls.\n+GCC also provides its own generic descriptor implementation to support the\n+@option{-fno-trampolines} option.  In this case runtime detection of\n+function descriptors at indirect call sites relies on descriptor\n+pointers being tagged with a bit that is never set in bare function\n+addresses.  Since GCC's generic function descriptors are\n+not ABI-compliant, this option is typically used only on a\n+per-language basis (notably by Ada) or when it can otherwise be\n+applied to the whole program.\n+\n+Define the following hook if your backend either implements ABI-specified\n+descriptor support, or can use GCC's generic descriptor implementation\n+for nested functions.\n+\n+@deftypevr {Target Hook} int TARGET_CUSTOM_FUNCTION_DESCRIPTORS\n+If the target can use GCC's generic descriptor mechanism for nested\n+functions, define this hook to a power of 2 representing an unused bit\n+in function pointers which can be used to differentiate descriptors at\n+run time.  This value gives the number of bytes by which descriptor\n+pointers are misaligned compared to function pointers.  For example, on\n+targets that require functions to be aligned to a 4-byte boundary, a\n+value of either 1 or 2 is appropriate unless the architecture already\n+reserves the bit for another purpose, such as on ARM.\n+\n+Define this hook to 0 if the target implements ABI support for\n+function descriptors in its standard calling sequence, like for example\n+HPPA or IA-64.\n+\n+Using descriptors for nested functions\n+eliminates the need for trampolines that reside on the stack and require\n+it to be made executable.\n+@end deftypevr\n+\n+The following macros tell GCC how to generate code to allocate and\n+initialize an executable trampoline.  You can also use this interface\n+if your back end needs to create ABI-specified non-executable descriptors; in\n+this case the \"trampoline\" created is the descriptor containing data only.\n+\n+The instructions in an executable trampoline must do two things: load\n+a constant address into the static chain register, and jump to the real\n+address of the nested function.  On CISC machines such as the m68k,\n+this requires two instructions, a move immediate and a jump.  Then the\n+two addresses exist in the trampoline as word-long immediate operands.\n+On RISC machines, it is often necessary to load each address into a\n+register in two parts.  Then pieces of each address form separate\n+immediate operands.\n \n The code generated to initialize the trampoline must store the variable\n parts---the static chain value and the function address---into the\n@@ -5351,24 +5405,6 @@ be returned; otherwise @var{addr} should be returned unchanged.\n If this hook is not defined, @var{addr} will be used for function calls.\n @end deftypefn\n \n-@deftypevr {Target Hook} int TARGET_CUSTOM_FUNCTION_DESCRIPTORS\n-This hook should be defined to a power of 2 if the target will benefit\n-from the use of custom descriptors for nested functions instead of the\n-standard trampolines.  Such descriptors are created at run time on the\n-stack and made up of data only, but they are non-standard so the generated\n-code must be prepared to deal with them.  This hook should be defined to 0\n-if the target uses function descriptors for its standard calling sequence,\n-like for example HP-PA or IA-64.  Using descriptors for nested functions\n-eliminates the need for trampolines that reside on the stack and require\n-it to be made executable.\n-\n-The value of the macro is used to parameterize the run-time identification\n-scheme implemented to distinguish descriptors from function addresses: it\n-gives the number of bytes by which their address is misaligned compared\n-with function addresses.  The value of 1 will generally work, unless it is\n-already reserved by the target for another purpose, like for example on ARM.\n-@end deftypevr\n-\n Implementing trampolines is difficult on many machines because they have\n separate instruction and data caches.  Writing into a stack location\n fails to clear the memory in the instruction cache, so when the program"}, {"sha": "81a9adb55db9a0a8ab333a515a8ce8d127c46d04", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 54, "deletions": 19, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92b6df436de3808c5a1cfadbb9d19e5dff82151f/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92b6df436de3808c5a1cfadbb9d19e5dff82151f/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=92b6df436de3808c5a1cfadbb9d19e5dff82151f", "patch": "@@ -3766,24 +3766,61 @@ These machine description macros help implement varargs:\n @hook TARGET_SETUP_INCOMING_VARARG_BOUNDS\n \n @node Trampolines\n-@section Trampolines for Nested Functions\n+@section Support for Nested Functions\n+@cindex support for nested functions\n @cindex trampolines for nested functions\n-@cindex nested functions, trampolines for\n-\n-A @dfn{trampoline} is a small piece of code that is created at run time\n-when the address of a nested function is taken.  It normally resides on\n-the stack, in the stack frame of the containing function.  These macros\n-tell GCC how to generate code to allocate and initialize a\n-trampoline.\n-\n-The instructions in the trampoline must do two things: load a constant\n-address into the static chain register, and jump to the real address of\n-the nested function.  On CISC machines such as the m68k, this requires\n-two instructions, a move immediate and a jump.  Then the two addresses\n-exist in the trampoline as word-long immediate operands.  On RISC\n-machines, it is often necessary to load each address into a register in\n-two parts.  Then pieces of each address form separate immediate\n-operands.\n+@cindex descriptors for nested functions\n+@cindex nested functions, support for\n+\n+Taking the address of a nested function requires special compiler\n+handling to ensure that the static chain register is loaded when\n+the function is invoked via an indirect call.\n+\n+GCC has traditionally supported nested functions by creating an\n+executable @dfn{trampoline} at run time when the address of a nested\n+function is taken.  This is a small piece of code which normally\n+resides on the stack, in the stack frame of the containing function.\n+The trampoline loads the static chain register and then jumps to the\n+real address of the nested function.\n+\n+The use of trampolines requires an executable stack, which is a\n+security risk.  To avoid this problem, GCC also supports another\n+strategy: using descriptors for nested functions.  Under this model,\n+taking the address of a nested function results in a pointer to a\n+non-executable function descriptor object.  Initializing the static chain\n+from the descriptor is handled at indirect call sites.\n+\n+On some targets, including HPPA and IA-64, function descriptors may be\n+mandated by the ABI or be otherwise handled in a target-specific way\n+by the back end in its code generation strategy for indirect calls.\n+GCC also provides its own generic descriptor implementation to support the\n+@option{-fno-trampolines} option.  In this case runtime detection of\n+function descriptors at indirect call sites relies on descriptor\n+pointers being tagged with a bit that is never set in bare function\n+addresses.  Since GCC's generic function descriptors are\n+not ABI-compliant, this option is typically used only on a\n+per-language basis (notably by Ada) or when it can otherwise be\n+applied to the whole program.\n+\n+Define the following hook if your backend either implements ABI-specified\n+descriptor support, or can use GCC's generic descriptor implementation\n+for nested functions.\n+\n+@hook TARGET_CUSTOM_FUNCTION_DESCRIPTORS\n+\n+The following macros tell GCC how to generate code to allocate and\n+initialize an executable trampoline.  You can also use this interface\n+if your back end needs to create ABI-specified non-executable descriptors; in\n+this case the \"trampoline\" created is the descriptor containing data only.\n+\n+The instructions in an executable trampoline must do two things: load\n+a constant address into the static chain register, and jump to the real\n+address of the nested function.  On CISC machines such as the m68k,\n+this requires two instructions, a move immediate and a jump.  Then the\n+two addresses exist in the trampoline as word-long immediate operands.\n+On RISC machines, it is often necessary to load each address into a\n+register in two parts.  Then pieces of each address form separate\n+immediate operands.\n \n The code generated to initialize the trampoline must store the variable\n parts---the static chain value and the function address---into the\n@@ -3815,8 +3852,6 @@ is used for aligning trampolines.\n \n @hook TARGET_TRAMPOLINE_ADJUST_ADDRESS\n \n-@hook TARGET_CUSTOM_FUNCTION_DESCRIPTORS\n-\n Implementing trampolines is difficult on many machines because they have\n separate instruction and data caches.  Writing into a stack location\n fails to clear the memory in the instruction cache, so when the program"}, {"sha": "9e22423d466ca0744652a37611ee0b7e215f1d1b", "filename": "gcc/target.def", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92b6df436de3808c5a1cfadbb9d19e5dff82151f/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92b6df436de3808c5a1cfadbb9d19e5dff82151f/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=92b6df436de3808c5a1cfadbb9d19e5dff82151f", "patch": "@@ -4985,21 +4985,22 @@ If this hook is not defined, @var{addr} will be used for function calls.\",\n \n DEFHOOKPOD\n (custom_function_descriptors,\n- \"This hook should be defined to a power of 2 if the target will benefit\\n\\\n-from the use of custom descriptors for nested functions instead of the\\n\\\n-standard trampolines.  Such descriptors are created at run time on the\\n\\\n-stack and made up of data only, but they are non-standard so the generated\\n\\\n-code must be prepared to deal with them.  This hook should be defined to 0\\n\\\n-if the target uses function descriptors for its standard calling sequence,\\n\\\n-like for example HP-PA or IA-64.  Using descriptors for nested functions\\n\\\n+ \"If the target can use GCC's generic descriptor mechanism for nested\\n\\\n+functions, define this hook to a power of 2 representing an unused bit\\n\\\n+in function pointers which can be used to differentiate descriptors at\\n\\\n+run time.  This value gives the number of bytes by which descriptor\\n\\\n+pointers are misaligned compared to function pointers.  For example, on\\n\\\n+targets that require functions to be aligned to a 4-byte boundary, a\\n\\\n+value of either 1 or 2 is appropriate unless the architecture already\\n\\\n+reserves the bit for another purpose, such as on ARM.\\n\\\n+\\n\\\n+Define this hook to 0 if the target implements ABI support for\\n\\\n+function descriptors in its standard calling sequence, like for example\\n\\\n+HPPA or IA-64.\\n\\\n+\\n\\\n+Using descriptors for nested functions\\n\\\n eliminates the need for trampolines that reside on the stack and require\\n\\\n-it to be made executable.\\n\\\n-\\n\\\n-The value of the macro is used to parameterize the run-time identification\\n\\\n-scheme implemented to distinguish descriptors from function addresses: it\\n\\\n-gives the number of bytes by which their address is misaligned compared\\n\\\n-with function addresses.  The value of 1 will generally work, unless it is\\n\\\n-already reserved by the target for another purpose, like for example on ARM.\",\\\n+it to be made executable.\",\\\n  int, -1)\n \n /* Return the number of bytes of its own arguments that a function"}]}