{"sha": "4c2b647d427e98f8b5e283e4011aa286d2d4a956", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGMyYjY0N2Q0MjdlOThmOGI1ZTI4M2U0MDExYWEyODZkMmQ0YTk1Ng==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-11-11T13:19:01Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-11-11T13:19:01Z"}, "message": "Remove CPP_PLACEMARKERs\n\n\t* cppexp.c (lex): Don't handle CPP_PLACEMARKER.\n\t* cpplex.c (_cpp_lex_token): Rename skip_newlines to next_bol\n\t* cpplib.c (skip_rest_of_line, check_eol, cpp_push_buffer):\n\t           Similarly.\n\t* cpplib.h: Remove CPP_PLACEMARKER.\n\t(struct lexer_state): Rename skip_newlines to next_bol.\n\t* cppmacro.c (stringify_arg): Don't handle CPP_PLACEMARKER.\n\tSimplify prev_white handling as a result.\n\t(paste_all_tokens): Don't worry about CPP_PLACEMARKERs.\n\t(parse_arg): Empty arguments are now empty, not CPP_PLACEMARKERs.\n\t(parse_args): Similarly.  Update argument count tests.\n\t(enter_macro_context): Return 2 to indicate an empty macro.\n\t(replace_args): Don't bother pre-expanding an empty argument.\n\tHandle placemarkers and ## extension during pre-expansion.\n\t(cpp_get_token): Handle empty macro expansions.  Don't worry\n\tabout CPP_PLACEMARKERs.\n\t(_cpp_create_definition): Empty macros are now empty.\n\t(cpp_macro_defintion): Don't special case empty macros.\n\t* scan-decls.c: Don't bother with CPP_PLACEMARKERs.\n\t* c-lex.c: Similarly.\n\nFrom-SVN: r37385", "tree": {"sha": "7323fe5e1674d601cd12b49ff890f231326528ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7323fe5e1674d601cd12b49ff890f231326528ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c2b647d427e98f8b5e283e4011aa286d2d4a956", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c2b647d427e98f8b5e283e4011aa286d2d4a956", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c2b647d427e98f8b5e283e4011aa286d2d4a956", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c2b647d427e98f8b5e283e4011aa286d2d4a956/comments", "author": null, "committer": null, "parents": [{"sha": "1e8ba2a38cd259556340a4143716e7ee96b3f56c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e8ba2a38cd259556340a4143716e7ee96b3f56c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e8ba2a38cd259556340a4143716e7ee96b3f56c"}], "stats": {"total": 294, "additions": 147, "deletions": 147}, "files": [{"sha": "9d0b53552f37fb845b9f3eaa692559a6cce77c83", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2b647d427e98f8b5e283e4011aa286d2d4a956/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2b647d427e98f8b5e283e4011aa286d2d4a956/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4c2b647d427e98f8b5e283e4011aa286d2d4a956", "patch": "@@ -1,3 +1,28 @@\n+2000-11-11  Neil Booth  <neilb@earthling.net>\n+\n+\tRemove CPP_PLACEMARKERs.\n+\n+\t* cppexp.c (lex): Don't handle CPP_PLACEMARKER.\n+\t* cpplex.c (_cpp_lex_token): Rename skip_newlines to next_bol\n+\t* cpplib.c (skip_rest_of_line, check_eol, cpp_push_buffer):\n+\t           Similarly.\n+\t* cpplib.h: Remove CPP_PLACEMARKER.\n+\t(struct lexer_state): Rename skip_newlines to next_bol.\n+\t* cppmacro.c (stringify_arg): Don't handle CPP_PLACEMARKER.\n+\tSimplify prev_white handling as a result.\n+\t(paste_all_tokens): Don't worry about CPP_PLACEMARKERs.\n+\t(parse_arg): Empty arguments are now empty, not CPP_PLACEMARKERs.\n+\t(parse_args): Similarly.  Update argument count tests.\n+\t(enter_macro_context): Return 2 to indicate an empty macro.\n+\t(replace_args): Don't bother pre-expanding an empty argument.\n+\tHandle placemarkers and ## extension during pre-expansion.\n+\t(cpp_get_token): Handle empty macro expansions.  Don't worry\n+\tabout CPP_PLACEMARKERs.\n+\t(_cpp_create_definition): Empty macros are now empty.\n+\t(cpp_macro_defintion): Don't special case empty macros.\n+\t* scan-decls.c: Don't bother with CPP_PLACEMARKERs.\n+\t* c-lex.c: Similarly.\n+\n 2000-11-11  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* gcc.texi, invoke.texi: Add new section discussing language"}, {"sha": "0c4fa916558f0d6a7a83f0a9b3131884760b0cc2", "filename": "gcc/c-lex.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2b647d427e98f8b5e283e4011aa286d2d4a956/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2b647d427e98f8b5e283e4011aa286d2d4a956/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=4c2b647d427e98f8b5e283e4011aa286d2d4a956", "patch": "@@ -1475,7 +1475,6 @@ c_lex (value)\n     case CPP_HEADER_NAME:\n     case CPP_COMMENT:\n     case CPP_MACRO_ARG:\n-    case CPP_PLACEMARKER:\n       abort ();\n \n     default: break;"}, {"sha": "4814868e2dab998ceb19d899983b775aecf9fb34", "filename": "gcc/cppexp.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2b647d427e98f8b5e283e4011aa286d2d4a956/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2b647d427e98f8b5e283e4011aa286d2d4a956/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=4c2b647d427e98f8b5e283e4011aa286d2d4a956", "patch": "@@ -378,14 +378,10 @@ lex (pfile, skip_evaluation, token)\n {\n   struct op op;\n \n- retry:\n   _cpp_get_token (pfile, token);\n \n   switch (token->type)\n     {\n-    case CPP_PLACEMARKER:\n-      goto retry;\n-\n     case CPP_INT:\n     case CPP_NUMBER:\n       return parse_number (pfile, token);"}, {"sha": "5c7edcd40febcea6a5c60e19901ae3c77ca70ce9", "filename": "gcc/cpplex.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2b647d427e98f8b5e283e4011aa286d2d4a956/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2b647d427e98f8b5e283e4011aa286d2d4a956/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=4c2b647d427e98f8b5e283e4011aa286d2d4a956", "patch": "@@ -846,11 +846,11 @@ _cpp_lex_token (pfile, result)\n   cppchar_t c;\n   cpp_buffer *buffer;\n   const unsigned char *comment_start;\n-  unsigned char bol = pfile->state.skip_newlines;\n+  unsigned char bol = pfile->state.next_bol;\n \n  done_directive:\n   buffer = pfile->buffer;\n-  pfile->state.skip_newlines = 0;\n+  pfile->state.next_bol = 0;\n   result->flags = 0;\n  next_char:\n   pfile->lexer_pos.line = buffer->lineno;\n@@ -873,7 +873,7 @@ _cpp_lex_token (pfile, result)\n \t line and _Pragma buffers.  */\n       if (pfile->lexer_pos.col != 0 && !buffer->from_stage3)\n \tcpp_pedwarn (pfile, \"no newline at end of file\");\n-      pfile->state.skip_newlines = 1;\n+      pfile->state.next_bol = 1;\n       result->type = CPP_EOF;\n       break;\n \n@@ -900,7 +900,7 @@ _cpp_lex_token (pfile, result)\n \n       /* Don't let directives spill over to the next line.  */\n       buffer->read_ahead = c;\n-      pfile->state.skip_newlines = 1;\n+      pfile->state.next_bol = 1;\n       result->type = CPP_EOF;\n       break;\n \n@@ -1186,7 +1186,7 @@ _cpp_lex_token (pfile, result)\n \t      /* Put a '#' in lookahead, return CPP_EOF for parse_arg.  */\n \t      buffer->extra_char = buffer->read_ahead;\n \t      buffer->read_ahead = '#';\n-\t      pfile->state.skip_newlines = 1;\n+\t      pfile->state.next_bol = 1;\n \t      result->type = CPP_EOF;\n \n \t      /* Get whitespace right - newline_in_args sets it.  */"}, {"sha": "d70e6ec2b3f85b72d8045fd4401c871a13f50bf6", "filename": "gcc/cpplib.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2b647d427e98f8b5e283e4011aa286d2d4a956/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2b647d427e98f8b5e283e4011aa286d2d4a956/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=4c2b647d427e98f8b5e283e4011aa286d2d4a956", "patch": "@@ -194,7 +194,7 @@ skip_rest_of_line (pfile)\n      because they may be saving tokens prior to this directive for an\n      external client.  So we use _cpp_get_token, with macros disabled.  */\n   pfile->state.prevent_expansion++;\n-  while (!pfile->state.skip_newlines)\n+  while (!pfile->state.next_bol)\n     _cpp_get_token (pfile, &token);\n   pfile->state.prevent_expansion--;\n }\n@@ -204,7 +204,7 @@ static void\n check_eol (pfile)\n      cpp_reader *pfile;\n {\n-  if (!pfile->state.skip_newlines)\n+  if (!pfile->state.next_bol)\n     {\n       cpp_token token;\n \n@@ -1728,7 +1728,7 @@ cpp_push_buffer (pfile, buffer, length)\n   /* No read ahead or extra char initially.  */\n   new->read_ahead = EOF;\n   new->extra_char = EOF;\n-  pfile->state.skip_newlines = 1;\n+  pfile->state.next_bol = 1;\n \n   CPP_BUFFER (pfile) = new;\n   return new;"}, {"sha": "d677396e43ff65759b727fdbdd5eca5137297f6c", "filename": "gcc/cpplib.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2b647d427e98f8b5e283e4011aa286d2d4a956/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2b647d427e98f8b5e283e4011aa286d2d4a956/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=4c2b647d427e98f8b5e283e4011aa286d2d4a956", "patch": "@@ -140,7 +140,6 @@ struct htab;\n \\\n   TK(CPP_COMMENT,\tSPELL_STRING)\t/* Only if output comments.  */ \\\n   TK(CPP_MACRO_ARG,\tSPELL_NONE)\t/* Macro argument.  */\t\t\\\n-  TK(CPP_PLACEMARKER,\tSPELL_NONE)\t/* Placemarker token.  */\t\\\n   OP(CPP_EOF,\t\t\"EOL\")\t\t/* End of line or file.  */\n \n #define OP(e, s) e,\n@@ -488,8 +487,8 @@ struct lexer_state\n      all directives apart from #define.  */\n   unsigned char save_comments;\n \n-  /* If nonzero the lexer skips newlines.  Internal to the lexer.  */\n-  unsigned char skip_newlines;\n+  /* If nonzero the next token is at the beginning of the line.  */\n+  unsigned char next_bol;\n \n   /* Nonzero if we're mid-comment.  */\n   unsigned char lexing_comment;"}, {"sha": "43a9010f141a63a40bb6b4d5f72d58e6591620cd", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 112, "deletions": 130, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2b647d427e98f8b5e283e4011aa286d2d4a956/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2b647d427e98f8b5e283e4011aa286d2d4a956/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=4c2b647d427e98f8b5e283e4011aa286d2d4a956", "patch": "@@ -337,7 +337,6 @@ stringify_arg (pfile, arg)\n   cpp_pool *pool = pfile->string_pool;\n   unsigned char *start = POOL_FRONT (pool);\n   unsigned int i, escape_it, total_len = 0, backslash_count = 0;\n-  unsigned int prev_white = 0;\n \n   /* Loop, reading in the argument's tokens.  */\n   for (i = 0; i < arg->count; i++)\n@@ -362,17 +361,9 @@ stringify_arg (pfile, arg)\n \t  dest = &start[total_len];\n \t}\n \n-      prev_white |= token->flags & PREV_WHITE;\n-      if (token->type == CPP_PLACEMARKER)\n-\tcontinue;\n-\n       /* No leading white space.  */\n-      if (prev_white)\n-\t{\n-\t  prev_white = 0;\n-\t  if (total_len > 0)\n-\t    *dest++ = ' ';\n-\t}\n+      if (token->flags & PREV_WHITE && total_len > 0)\n+\t*dest++ = ' ';\n \n       if (escape_it)\n \t{\n@@ -424,6 +415,9 @@ paste_all_tokens (pfile, lhs)\n \n   do\n     {\n+      int digraph = 0;\n+      enum cpp_ttype type;\n+\n       /* Take the token directly from the current context.  We can do\n \t this, because we are in the replacement list of either an\n \t object-like macro, or a function-like macro with arguments\n@@ -432,63 +426,37 @@ paste_all_tokens (pfile, lhs)\n \t become placemarkers).  */\n       rhs = pfile->context->list.first++;\n \n-      if (rhs->type == CPP_PLACEMARKER)\n+      type = cpp_can_paste (pfile, lhs, rhs, &digraph);\n+      if (type == CPP_EOF)\n \t{\n-\t  /* GCC has special extended semantics for , ## b where b is\n-\t     a varargs parameter: the comma disappears if b was given\n-\t     no actual arguments (not merely if b is an empty\n-\t     argument).  */\n-\t  if (lhs->type == CPP_COMMA && (rhs->flags & VARARGS_FIRST))\n-\t    lhs->type = CPP_PLACEMARKER;\n+\t  if (CPP_OPTION (pfile, warn_paste))\n+\t    cpp_warning (pfile,\n+\t \"pasting \\\"%s\\\" and \\\"%s\\\" does not give a valid preprocessing token\",\n+\t\t\t cpp_token_as_text (pfile, lhs),\n+\t\t\t cpp_token_as_text (pfile, rhs));\n+\n+\t  /* The standard states that behaviour is undefined.  By the\n+\t     principle of least surpise, we step back before the RHS,\n+\t     and mark it to prevent macro expansion.  Tests in the\n+\t     testsuite rely on clearing PREV_WHITE here, though you\n+\t     could argue we should actually set it.  */\n+\t  rhs->flags &= ~PREV_WHITE;\n+\t  rhs->flags |= NO_EXPAND;\n+\n+\t  /* Step back so we read the RHS in next.  */\n+\t  pfile->context->list.first--;\n+\t  break;\n \t}\n-      else if (lhs->type == CPP_PLACEMARKER)\n-\t*lhs = *rhs;\n-      else\n-\t{\n-\t  int digraph = 0;\n-\t  enum cpp_ttype type = cpp_can_paste (pfile, lhs, rhs, &digraph);\n-\n-\t  if (type == CPP_EOF)\n-\t    {\n-\t      /* Do nothing special about , ## <whatever> if\n-\t\t <whatever> came from a variable argument, because the\n-\t\t author probably intended the ## to trigger the\n-\t\t special extended semantics (see above).  */\n-\t      if (lhs->type == CPP_COMMA && (rhs->flags & VARARGS_FIRST))\n-\t\t/* nothing */;\n-\t      else\n-\t\t{\n-\t\t  if (CPP_OPTION (pfile, warn_paste))\n-\t\t    cpp_warning (pfile,\n-\t\t \"pasting \\\"%s\\\" and \\\"%s\\\" does not give a valid preprocessing token\",\n-\t\t\t\t cpp_token_as_text (pfile, lhs),\n-\t\t\t\t cpp_token_as_text (pfile, rhs));\n-\n-\t\t  /* The standard states that behaviour is undefined.\n-\t\t     By the principle of least surpise, we step back\n-\t\t     before the RHS, and mark it to prevent macro\n-\t\t     expansion.  Tests in the testsuite rely on\n-\t\t     clearing PREV_WHITE here, though you could argue\n-\t\t     we should actually set it.  */\n-\t\t  rhs->flags &= ~PREV_WHITE;\n-\t\t  rhs->flags |= NO_EXPAND;\n-\t\t}\n-\n-\t      /* Step back so we read the RHS in next.  */\n-\t      pfile->context->list.first--;\n-\t      break;\n-\t    }\n \n-\t  lhs->type = type;\n-\t  lhs->flags &= ~DIGRAPH;\n-\t  if (digraph)\n-\t    lhs->flags |= DIGRAPH;\n+      lhs->type = type;\n+      lhs->flags &= ~DIGRAPH;\n+      if (digraph)\n+\tlhs->flags |= DIGRAPH;\n \n-\t  if (type == CPP_NAME || type == CPP_NUMBER)\n-\t    paste_payloads (pfile, lhs, rhs);\n-\t  else if (type == CPP_WCHAR || type == CPP_WSTRING)\n-\t    lhs->val.str = rhs->val.str;\n-\t}\n+      if (type == CPP_NAME || type == CPP_NUMBER)\n+\tpaste_payloads (pfile, lhs, rhs);\n+      else if (type == CPP_WCHAR || type == CPP_WSTRING)\n+\tlhs->val.str = rhs->val.str;\n     }\n   while (rhs->flags & PASTE_LEFT);\n \n@@ -498,10 +466,9 @@ paste_all_tokens (pfile, lhs)\n   lhs->flags |= orig_flags & PREV_WHITE;\n }\n \n-/* Reads the unexpanded tokens of a macro argument into ARG.  Empty\n-   arguments are saved as a single CPP_PLACEMARKER token.  VAR_ARGS is\n-   non-zero if this is a variable argument.  Returns the type of the\n-   token that caused reading to finish.  */\n+/* Reads the unexpanded tokens of a macro argument into ARG.  VAR_ARGS\n+   is non-zero if this is a variable argument.  Returns the type of\n+   the token that caused reading to finish.  */\n static enum cpp_ttype\n parse_arg (pfile, arg, var_args)\n      cpp_reader *pfile;\n@@ -536,13 +503,6 @@ parse_arg (pfile, arg, var_args)\n \tbreak;\t\t/* Error reported by caller.  */\n     }\n \n-  /* Empty arguments become a single placemarker token.  */\n-  if (arg->count == 0)\n-    {\n-      arg->first->type = CPP_PLACEMARKER;\n-      arg->count = 1;\n-    }\n-\n   /* Commit the memory used to store the arguments.  */\n   POOL_COMMIT (&pfile->argument_pool, arg->count * sizeof (cpp_token));\n \n@@ -595,13 +555,6 @@ parse_args (pfile, node)\n \n       if (argc + 1 == macro->paramc && macro->var_args)\n \t{\n-\t  /* parse_arg ensured there was space for the closing\n-\t     parenthesis.  Use this space to store a placemarker.  */\n-\t  args[argc].first = (cpp_token *) POOL_FRONT (&pfile->argument_pool);\n-\t  args[argc].first->type = CPP_PLACEMARKER;\n-\t  args[argc].count = 1;\n-\t  POOL_COMMIT (&pfile->argument_pool, sizeof (cpp_token));\n-\n \t  if (CPP_OPTION (pfile, c99) && CPP_PEDANTIC (pfile))\n \t    cpp_pedwarn (pfile, \"ISO C99 requires rest arguments to be used\");\n \t}\n@@ -615,8 +568,8 @@ parse_args (pfile, node)\n     }\n   else if (argc > macro->paramc)\n     {\n-      /* An empty argument to an empty function-like macro is fine.  */\n-      if (argc != 1 || args[0].first->type != CPP_PLACEMARKER)\n+      /* Empty argument to a macro taking no arguments is OK.  */\n+      if (argc != 1 || cur->count)\n \t{\n \t  cpp_error (pfile,\n \t\t     \"macro \\\"%s\\\" passed %u arguments, but takes just %u\",\n@@ -709,15 +662,19 @@ enter_macro_context (pfile, token)\n       return 0;\n     }\n \n-  /* Now push its context.  */\n-  context = next_context (pfile);\n   if (macro->paramc == 0)\n     {\n-      context->list.first = macro->expansion;\n-      context->list.limit = macro->expansion + macro->count;\n+      list.first = macro->expansion;\n+      list.limit = macro->expansion + macro->count;\n     }\n-  else\n-    context->list = list;\n+\n+  /* Temporary kludge.  */\n+  if (list.first == list.limit)\n+    return 2;\n+\n+  /* Now push its context.  */\n+  context = next_context (pfile);\n+  context->list = list;\n   context->macro = macro;\n \n   /* The first expansion token inherits the PREV_WHITE of TOKEN.  */\n@@ -776,6 +733,7 @@ replace_args (pfile, macro, args, list)\n \t/* We have an argument.  If it is not being stringified or\n \t   pasted it is macro-replaced before insertion.  */\n \targ = &args[src->val.arg_no - 1];\n+\n \tif (src->flags & STRINGIFY_ARG)\n \t  {\n \t    if (!arg->stringified)\n@@ -787,15 +745,18 @@ replace_args (pfile, macro, args, list)\n \telse\n \t  {\n \t    if (!arg->expanded)\n-\t      expand_arg (pfile, arg);\n+\t      {\n+\t\targ->expanded_count = 0;\n+\t\tif (arg->count)\n+\t\t  expand_arg (pfile, arg);\n+\t      }\n \t    total += arg->expanded_count - 1;\n \t  }\n       }\n \n   dest = (cpp_token *) _cpp_pool_alloc (&pfile->argument_pool,\n \t\t\t\t\ttotal * sizeof (cpp_token));\n   list->first = dest;\n-  list->limit = list->first + total;\n \n   for (src = macro->expansion; src < limit; src++)\n     if (src->type == CPP_MACRO_ARG)\n@@ -806,28 +767,54 @@ replace_args (pfile, macro, args, list)\n \targ = &args[src->val.arg_no - 1];\n \tif (src->flags & STRINGIFY_ARG)\n \t  from = arg->stringified, count = 1;\n-\telse if ((src->flags & PASTE_LEFT)\n-\t\t || (src > macro->expansion && (src[-1].flags & PASTE_LEFT)))\n+\telse if (src->flags & PASTE_LEFT)\n \t  count = arg->count, from = arg->first;\n+\telse if (src > macro->expansion && (src[-1].flags & PASTE_LEFT))\n+\t  {\n+\t    count = arg->count, from = arg->first;\n+\t    if (dest != list->first)\n+\t      {\n+\t\t/* GCC has special semantics for , ## b where b is a\n+\t\t   varargs parameter: the comma disappears if b was\n+\t\t   given no actual arguments (not merely if b is an\n+\t\t   empty argument); otherwise pasting is turned off.  */\n+\t\tif (dest[-1].type == CPP_COMMA\n+\t\t    && macro->var_args\n+\t\t    && src->val.arg_no == macro->paramc)\n+\t\t  {\n+\t\t    if (count == 0)\n+\t\t      dest--;\n+\t\t    else\n+\t\t      dest[-1].flags &= ~PASTE_LEFT;\n+\t\t  }\n+\t\t/* Count == 0 is the RHS a placemarker case.  */\n+\t\telse if (count == 0)\n+\t\t  dest[-1].flags &= ~PASTE_LEFT;\n+\t      }\n+\t  }\n \telse\n \t  count = arg->expanded_count, from = arg->expanded;\n-\tmemcpy (dest, from, count * sizeof (cpp_token));\n \n-\t/* The first token gets PREV_WHITE of the CPP_MACRO_ARG.  If\n-           it is a variable argument, it is also flagged.  */\n-\tdest->flags &= ~PREV_WHITE;\n-\tdest->flags |= src->flags & PREV_WHITE;\n-\tif (macro->var_args && src->val.arg_no == macro->paramc)\n-\t  dest->flags |= VARARGS_FIRST;\n+\t/* Count == 0 is the LHS a placemarker case.  */\n+\tif (count)\n+\t  {\n+\t    memcpy (dest, from, count * sizeof (cpp_token));\n+\n+\t    /* The first token gets PREV_WHITE of the CPP_MACRO_ARG.  */\n+\t    dest->flags &= ~PREV_WHITE;\n+\t    dest->flags |= src->flags & PREV_WHITE;\n \n-\t/* The last token gets the PASTE_LEFT of the CPP_MACRO_ARG.  */\n-\tdest[count - 1].flags |= src->flags & PASTE_LEFT;\n+\t    /* The last token gets the PASTE_LEFT of the CPP_MACRO_ARG.  */\n+\t    dest[count - 1].flags |= src->flags & PASTE_LEFT;\n \n-\tdest += count;\n+\t    dest += count;\n+\t  }\n       }\n     else\n       *dest++ = *src;\n \n+  list->limit = dest;\n+\n   /* Free the expanded arguments.  */\n   for (i = 0; i < macro->paramc; i++)\n     {\n@@ -863,7 +850,6 @@ expand_arg (pfile, arg)\n \n   /* Loop, reading in the arguments.  */\n   arg->expanded = (cpp_token *) xmalloc (capacity * sizeof (cpp_token));\n-  arg->expanded_count = 0;\n \n   push_arg_context (pfile, arg);\n   do\n@@ -904,8 +890,7 @@ _cpp_pop_context (pfile)\n /* Internal routine to return a token, either from an in-progress\n    macro expansion, or from the source file as appropriate.\n    Transparently enters included files.  Handles macros, so tokens\n-   returned are post-expansion.  Does not filter CPP_PLACEMARKER\n-   tokens.  Returns CPP_EOF at EOL and EOF.  */\n+   returned are post-expansion.  Returns CPP_EOF at EOL and EOF.  */\n void\n _cpp_get_token (pfile, token)\n      cpp_reader *pfile;\n@@ -958,6 +943,8 @@ _cpp_get_token (pfile, token)\n \t  && !pfile->state.prevent_expansion\n \t  && !(token->flags & NO_EXPAND))\n \t{\n+\t  int m;\n+\n \t  /* Macros invalidate controlling macros.  */\n \t  pfile->mi_state = MI_FAILED;\n \n@@ -967,8 +954,11 @@ _cpp_get_token (pfile, token)\n \t      break;\n \t    }\n \n-\t  if (enter_macro_context (pfile, token))\n+\t  m = enter_macro_context (pfile, token);\n+\t  if (m == 1)\n \t    continue;\n+\t  if (m == 2)\n+\t    goto next_token;\n \t}\n \n       if (token->val.node != pfile->spec_nodes.n__Pragma)\n@@ -1001,9 +991,7 @@ cpp_get_token (pfile, token)\n \n       if (token->type == CPP_EOF)\n \tbreak;\n-      /* We are not merging the PREV_WHITE of CPP_PLACEMARKERS.  I\n-         don't think it really matters.  */\n-      else if (pfile->skipping || token->type == CPP_PLACEMARKER)\n+      else if (pfile->skipping)\n \tcontinue;\n \n       /* Non-comment tokens invalidate any controlling macros.  */\n@@ -1463,11 +1451,8 @@ _cpp_create_definition (pfile, node)\n       token = lex_expansion_token (pfile, macro);\n     }\n \n-  /* Don't count the CPP_EOF.  Empty macros become a place marker.  */\n-  if (macro->count > 1)\n-    macro->count--;\n-  else\n-    macro->expansion[0].type = CPP_PLACEMARKER;\n+  /* Don't count the CPP_EOF.  */\n+  macro->count--;\n \n   /* Clear the whitespace flag from the leading token.  */\n   macro->expansion[0].flags &= ~PREV_WHITE;\n@@ -1589,21 +1574,18 @@ cpp_macro_definition (pfile, node)\n \tlen += macro->params[i]->length + 2; /* \", \" */\n     }\n \n-  if (macro->count > 1 || macro->expansion[0].type != CPP_PLACEMARKER)\n+  for (i = 0; i < macro->count; i++)\n     {\n-      for (i = 0; i < macro->count; i++)\n-\t{\n-\t  cpp_token *token = &macro->expansion[i];\n+      cpp_token *token = &macro->expansion[i];\n \n-\t  if (token->type == CPP_MACRO_ARG)\n-\t    len += macro->params[token->val.arg_no - 1]->length;\n-\t  else\n-\t    len += cpp_token_len (token); /* Includes room for ' '.  */\n-\t  if (token->flags & STRINGIFY_ARG)\n-\t    len++;\t\t\t/* \"#\" */\n-\t  if (token->flags & PASTE_LEFT)\n-\t    len += 3;\t\t/* \" ##\" */\n-\t}\n+      if (token->type == CPP_MACRO_ARG)\n+\tlen += macro->params[token->val.arg_no - 1]->length;\n+      else\n+\tlen += cpp_token_len (token); /* Includes room for ' '.  */\n+      if (token->flags & STRINGIFY_ARG)\n+\tlen++;\t\t\t/* \"#\" */\n+      if (token->flags & PASTE_LEFT)\n+\tlen += 3;\t\t/* \" ##\" */\n     }\n \n   if (len > pfile->macro_buffer_len)\n@@ -1633,7 +1615,7 @@ cpp_macro_definition (pfile, node)\n     }\n \n   /* Expansion tokens.  */\n-  if (macro->count > 1 || macro->expansion[0].type != CPP_PLACEMARKER)\n+  if (macro->count)\n     {\n       *buffer++ = ' ';\n       for (i = 0; i < macro->count; i++)"}, {"sha": "ba0a00c8fc4856a58080f77898bf877fbc87f545", "filename": "gcc/scan-decls.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2b647d427e98f8b5e283e4011aa286d2d4a956/gcc%2Fscan-decls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2b647d427e98f8b5e283e4011aa286d2d4a956/gcc%2Fscan-decls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fscan-decls.c?ref=4c2b647d427e98f8b5e283e4011aa286d2d4a956", "patch": "@@ -133,7 +133,6 @@ scan_decls (pfile, argc, argv)\n \t  goto handle_statement;\n \tcase CPP_MULT:\n \tcase CPP_AND:\n-\tcase CPP_PLACEMARKER:\n \t  /* skip */\n \t  break;\n "}]}