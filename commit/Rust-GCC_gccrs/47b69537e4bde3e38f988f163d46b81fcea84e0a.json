{"sha": "47b69537e4bde3e38f988f163d46b81fcea84e0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdiNjk1MzdlNGJkZTNlMzhmOTg4ZjE2M2Q0NmI4MWZjZWE4NGUwYQ==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@codesourcery.com", "date": "2002-06-05T19:35:45Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2002-06-05T19:35:45Z"}, "message": "toplev.h (report_error_function): Remove.\n\n\t* toplev.h (report_error_function): Remove.\n\n\t* diagnostic.h (location_t): New datatype.\n\t(text_info): Likewise.\n\t(diagnostic_info): Likewise.\n\t(output_prefix): New macro.\n\t(diagnostic_last_function_changed): Likewise.\n\t(diagnostic_set_last_function): Likewise.\n\t(diagnostic_last_module_changed): Likewise.\n\t(diagnostic_set_last_module): Likewise.\n\t(report_diagnostic): Now macro.\n\t(diagnostic_set_info): Declare.\n\n\t* diagnostic.c (report_problematic_module): Rename to\n\tdiagnostic_repor_current_module.\n\t(set_diagnostic_context): Remove.\n\t(count_error): Rename to diagnostic_error_count.\n\t(error_function_changed): Remove.\n\t(record_last_error_function): Likewise.\n\t(error_module_changed): Likewise.\n\t(record_last_error_module): Likewise.\n\t(context_as_prefix): Rename to diagnostic_build_prefix.\n\t(flush_diagnostic_buffer): Rename to diagnostic_flush_buffer.\n\t(diagnostic_set_info): New function.\n\n\t* objc/objc-act.c: #include diagnostic.h\n\t(error_with_ivar): Adjust call to count_error.\n\t(warn_with_method): Likewise.\n\t* objc/Make-lang.in (objc-act.o): Depend on diagnostic.h\n\ncp/\n2002-06-04  Gabriel Dos Reis  <gdr@codesourcery.com>\n\n\t* error.c (cp_diagnostic_starter): Adjust call.\n\t(maybe_print_instantiation_context): Change prototype to take a\n\t'diagnostic_info *'.\n\t(print_instantiation_full_context): Likewise.\n\t(print_instantiation_partial_context): Likewise.\n\t(cp_diagnostic_starter): Likewise.\n\t(cp_diagnostic_finalizer): Likewise.\n\t(cp_print_error_function): Likewise.\n\t(cp_printer): Take a secondary parameter as a 'text_info *'.\n\tRemove output_state savings.  Adjust calls.\n\nf/\n2002-06-04  Gabriel Dos Reis  <gdr@codesourcery.com>\n\n\t* bad.c (ffebad_start_): Adjust call to count_error.\n\t* Make-lang.in (f/bad.o): Depend on diagnostic.h\n\t* bad.c: #include diagnostic.h\n\nFrom-SVN: r54291", "tree": {"sha": "c3ef54e07296b12dc1226be91d252727972d938c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3ef54e07296b12dc1226be91d252727972d938c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47b69537e4bde3e38f988f163d46b81fcea84e0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47b69537e4bde3e38f988f163d46b81fcea84e0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47b69537e4bde3e38f988f163d46b81fcea84e0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47b69537e4bde3e38f988f163d46b81fcea84e0a/comments", "author": null, "committer": null, "parents": [{"sha": "304a3a85de8f845dd77315e30430e256926c1660", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/304a3a85de8f845dd77315e30430e256926c1660", "html_url": "https://github.com/Rust-GCC/gccrs/commit/304a3a85de8f845dd77315e30430e256926c1660"}], "stats": {"total": 1256, "additions": 581, "deletions": 675}, "files": [{"sha": "2ece7300ea8b5b3509d22a2117e3460a57274dba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b69537e4bde3e38f988f163d46b81fcea84e0a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b69537e4bde3e38f988f163d46b81fcea84e0a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=47b69537e4bde3e38f988f163d46b81fcea84e0a", "patch": "@@ -1,3 +1,35 @@\n+2002-06-05  Gabriel Dos Reis  <gdr@codesourcery.com>\n+\n+\t* toplev.h (report_error_function): Remove.\n+\n+\t* diagnostic.h (location_t): New datatype.\n+\t(text_info): Likewise.\n+\t(diagnostic_info): Likewise.\n+\t(output_prefix): New macro.\n+\t(diagnostic_last_function_changed): Likewise.\n+\t(diagnostic_set_last_function): Likewise.\n+\t(diagnostic_last_module_changed): Likewise.\n+\t(diagnostic_set_last_module): Likewise.\n+\t(report_diagnostic): Now macro.\n+\t(diagnostic_set_info): Declare.\n+\n+\t* diagnostic.c (report_problematic_module): Rename to\n+\tdiagnostic_repor_current_module. \n+\t(set_diagnostic_context): Remove.\n+\t(count_error): Rename to diagnostic_error_count.\n+\t(error_function_changed): Remove.\n+\t(record_last_error_function): Likewise.\n+\t(error_module_changed): Likewise.\n+\t(record_last_error_module): Likewise.\n+\t(context_as_prefix): Rename to diagnostic_build_prefix.\n+\t(flush_diagnostic_buffer): Rename to diagnostic_flush_buffer.\n+\t(diagnostic_set_info): New function.\n+\n+\t* objc/objc-act.c: #include diagnostic.h\n+\t(error_with_ivar): Adjust call to count_error.\n+\t(warn_with_method): Likewise.\n+\t* objc/Make-lang.in (objc-act.o): Depend on diagnostic.h\n+\n 2002-06-05  Bob Wilson  <bob.wilson@acm.org>\n \n \t* config/xtensa/xtensa.c (xtensa_build_va_list): Use"}, {"sha": "1bd52a8ed6fd90382e23c2c6b9cc570525efafc4", "filename": "gcc/c-errors.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b69537e4bde3e38f988f163d46b81fcea84e0a/gcc%2Fc-errors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b69537e4bde3e38f988f163d46b81fcea84e0a/gcc%2Fc-errors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-errors.c?ref=47b69537e4bde3e38f988f163d46b81fcea84e0a", "patch": "@@ -32,13 +32,12 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n void\n pedwarn_c99 VPARAMS ((const char *msgid, ...))\n {\n-  diagnostic_context dc;\n-\n+  diagnostic_info diagnostic;\n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  set_diagnostic_context (&dc, msgid, &ap, input_filename, lineno,\n-                          !flag_isoc99 || !flag_pedantic_errors);\n-  report_diagnostic (&dc);\n+  diagnostic_set_info (&diagnostic, msgid, &ap, input_filename, lineno,\n+                       flag_isoc99 ? pedantic_error_kind () : DK_WARNING);\n+  report_diagnostic (&diagnostic);\n   VA_CLOSE (ap);\n }"}, {"sha": "99892f93206089a5808348d29600fb721f024f53", "filename": "gcc/c-format.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b69537e4bde3e38f988f163d46b81fcea84e0a/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b69537e4bde3e38f988f163d46b81fcea84e0a/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=47b69537e4bde3e38f988f163d46b81fcea84e0a", "patch": "@@ -1025,7 +1025,7 @@ check_function_format (status, attrs, params)\n static void\n status_warning VPARAMS ((int *status, const char *msgid, ...))\n {\n-  diagnostic_context dc;\n+  diagnostic_info diagnostic ;\n \n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, int *, status);\n@@ -1036,9 +1036,9 @@ status_warning VPARAMS ((int *status, const char *msgid, ...))\n   else\n     {\n       /* This duplicates the warning function behavior.  */\n-      set_diagnostic_context\n-\t(&dc, msgid, &ap, input_filename, lineno, /* warn = */ 1);\n-      report_diagnostic (&dc);\n+      diagnostic_set_info (&diagnostic, _(msgid), &ap, input_filename, lineno,\n+                           DK_WARNING);\n+      report_diagnostic (&diagnostic);\n     }\n \n   VA_CLOSE (ap);"}, {"sha": "f5e9579312ef644eb2f23bc1224857992c521c7b", "filename": "gcc/c-objc-common.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b69537e4bde3e38f988f163d46b81fcea84e0a/gcc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b69537e4bde3e38f988f163d46b81fcea84e0a/gcc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.c?ref=47b69537e4bde3e38f988f163d46b81fcea84e0a", "patch": "@@ -35,7 +35,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"ggc.h\"\n #include \"langhooks.h\"\n \n-static int c_tree_printer PARAMS ((output_buffer *));\n+static bool c_tree_printer PARAMS ((output_buffer *, text_info *));\n static tree inline_forbidden_p PARAMS ((tree *, int *, void *));\n static void expand_deferred_fns PARAMS ((void));\n static tree start_cdtor\tPARAMS ((int));\n@@ -389,13 +389,14 @@ c_objc_common_finish_file ()\n    by the C++ front-end.\n    Please notice when called, the `%' part was already skipped by the\n    diagnostic machinery.  */\n-static int\n-c_tree_printer (buffer)\n+static bool\n+c_tree_printer (buffer, text)\n      output_buffer *buffer;\n+     text_info *text;\n {\n-  tree t = va_arg (output_buffer_format_args (buffer), tree);\n+  tree t = va_arg (*text->args_ptr, tree);\n \n-  switch (*output_buffer_text_cursor (buffer))\n+  switch (*text->format_spec)\n     {\n     case 'D':\n     case 'F':\n@@ -406,10 +407,10 @@ c_tree_printer (buffer)\n           : \"({anonymous})\";\n         output_add_string (buffer, n);\n       }\n-      return 1;\n+      return true;\n \n     default:\n-      return 0;\n+      return false;\n     }\n }\n "}, {"sha": "79beafca53982062b3665738b5e83d8b13cecd57", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b69537e4bde3e38f988f163d46b81fcea84e0a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b69537e4bde3e38f988f163d46b81fcea84e0a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=47b69537e4bde3e38f988f163d46b81fcea84e0a", "patch": "@@ -1,3 +1,16 @@\n+2002-06-04  Gabriel Dos Reis  <gdr@codesourcery.com>\n+\n+\t* error.c (cp_diagnostic_starter): Adjust call.\n+\t(maybe_print_instantiation_context): Change prototype to take a\n+\t'diagnostic_info *'.\n+\t(print_instantiation_full_context): Likewise.\n+\t(print_instantiation_partial_context): Likewise.\n+\t(cp_diagnostic_starter): Likewise.\n+\t(cp_diagnostic_finalizer): Likewise.\n+\t(cp_print_error_function): Likewise.\n+\t(cp_printer): Take a secondary parameter as a 'text_info *'.\n+\tRemove output_state savings.  Adjust calls.\n+\n 2002-06-03  Geoffrey Keating  <geoffk@redhat.com>\n \n \t* pt.c (inline_parm_levels): Mark for GC."}, {"sha": "1b24fb0e5e3f16f2bd0d77dd3cb886f8b8d0e881", "filename": "gcc/cp/error.c", "status": "modified", "additions": 84, "deletions": 92, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b69537e4bde3e38f988f163d46b81fcea84e0a/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b69537e4bde3e38f988f163d46b81fcea84e0a/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=47b69537e4bde3e38f988f163d46b81fcea84e0a", "patch": "@@ -105,18 +105,19 @@ static void dump_scope PARAMS ((tree, int));\n static void dump_template_parms PARAMS ((tree, int, int));\n \n static const char *function_category PARAMS ((tree));\n-static void maybe_print_instantiation_context PARAMS ((output_buffer *));\n-static void print_instantiation_full_context PARAMS ((output_buffer *));\n-static void print_instantiation_partial_context PARAMS ((output_buffer *, tree,\n+static void maybe_print_instantiation_context PARAMS ((diagnostic_context *));\n+static void print_instantiation_full_context PARAMS ((diagnostic_context *));\n+static void print_instantiation_partial_context PARAMS ((diagnostic_context *,\n+                                                         tree,\n                                                          const char *, int));\n-static void cp_diagnostic_starter PARAMS ((output_buffer *,\n-                                           diagnostic_context *));\n-static void cp_diagnostic_finalizer PARAMS ((output_buffer *,\n-                                             diagnostic_context *));\n-static void cp_print_error_function PARAMS ((output_buffer *,\n-                                             diagnostic_context *));\n-\n-static int cp_printer PARAMS ((output_buffer *));\n+static void cp_diagnostic_starter PARAMS ((diagnostic_context *,\n+                                           diagnostic_info *));\n+static void cp_diagnostic_finalizer PARAMS ((diagnostic_context *,\n+                                             diagnostic_info *));\n+static void cp_print_error_function PARAMS ((diagnostic_context *,\n+                                             diagnostic_info *));\n+\n+static bool cp_printer PARAMS ((output_buffer *, text_info *));\n static void print_non_consecutive_character PARAMS ((output_buffer *, int));\n static void print_integer PARAMS ((output_buffer *, HOST_WIDE_INT));\n static tree locate_error PARAMS ((const char *, va_list));\n@@ -2379,65 +2380,57 @@ cxx_print_error_function (context, file)\n      diagnostic_context *context;\n      const char *file;\n {\n-  output_state os;\n-\n   lhd_print_error_function (context, file);\n-  os = diagnostic_state (context);\n-  output_set_prefix ((output_buffer *)context, file);\n-  maybe_print_instantiation_context ((output_buffer *)context);\n-  diagnostic_state (context) = os;\n+  output_set_prefix (&context->buffer, file);\n+  maybe_print_instantiation_context (context);\n }\n \n static void\n-cp_diagnostic_starter (buffer, dc)\n-     output_buffer *buffer;\n-     diagnostic_context *dc;\n+cp_diagnostic_starter (context, diagnostic)\n+     diagnostic_context *context;\n+     diagnostic_info *diagnostic;\n {\n-  report_problematic_module (buffer);\n-  cp_print_error_function (buffer, dc);\n-  maybe_print_instantiation_context (buffer);\n-  output_set_prefix (buffer,\n-                     context_as_prefix (diagnostic_file_location (dc),\n-                                        diagnostic_line_location (dc),\n-                                        diagnostic_is_warning (dc)));\n+  diagnostic_report_current_module (context);\n+  cp_print_error_function (context, diagnostic);\n+  maybe_print_instantiation_context (context);\n+  output_set_prefix (&context->buffer, diagnostic_build_prefix (diagnostic));\n }\n \n static void\n-cp_diagnostic_finalizer (buffer, dc)\n-     output_buffer *buffer;\n-     diagnostic_context *dc __attribute__ ((__unused__));\n+cp_diagnostic_finalizer (context, diagnostic)\n+     diagnostic_context *context;\n+     diagnostic_info *diagnostic __attribute__((unused));\n {\n-  output_destroy_prefix (buffer);\n+  output_destroy_prefix (&context->buffer);\n }\n \n /* Print current function onto BUFFER, in the process of reporting\n    a diagnostic message.  Called from cp_diagnostic_starter.  */\n static void\n-cp_print_error_function (buffer, dc)\n-     output_buffer *buffer;\n-     diagnostic_context *dc;\n+cp_print_error_function (context, diagnostic)\n+     diagnostic_context *context;\n+     diagnostic_info *diagnostic;\n {\n-  if (error_function_changed ())\n+  if (diagnostic_last_function_changed (context))\n     {\n-      char *prefix = diagnostic_file_location (dc)\n-        ? file_name_as_prefix (diagnostic_file_location (dc))\n+      const char *old_prefix = output_prefix (&context->buffer);\n+      char *new_prefix = diagnostic->location.file\n+        ? file_name_as_prefix (diagnostic->location.file)\n         : NULL;\n-      output_state os;\n \n-      os = output_buffer_state (buffer);\n-      output_set_prefix (buffer, prefix);\n+      output_set_prefix (&context->buffer, new_prefix);\n \n       if (current_function_decl == NULL)\n-        output_add_string (buffer, \"At global scope:\");\n+        output_add_string (&context->buffer, \"At global scope:\");\n       else\n-        output_printf\n-          (buffer, \"In %s `%s':\", function_category (current_function_decl),\n-           cxx_printable_name (current_function_decl, 2));\n-      output_add_newline (buffer);\n-\n-      record_last_error_function ();\n-      output_destroy_prefix (buffer);\n-      output_buffer_state (buffer) = os;\n+        output_printf (&context->buffer, \"In %s `%s':\",\n+                       function_category (current_function_decl),\n+                       cxx_printable_name (current_function_decl, 2));\n+      output_add_newline (&context->buffer);\n+\n+      diagnostic_set_last_function (context);\n+      output_destroy_prefix (&context->buffer);\n+      context->buffer.state.prefix = old_prefix;\n     }\n }\n \n@@ -2466,8 +2459,8 @@ function_category (fn)\n /* Report the full context of a current template instantiation,\n    onto BUFFER.  */\n static void\n-print_instantiation_full_context (buffer)\n-     output_buffer *buffer;\n+print_instantiation_full_context (context)\n+     diagnostic_context *context;\n {\n   tree p = current_instantiation ();\n   int line = lineno;\n@@ -2486,7 +2479,8 @@ print_instantiation_full_context (buffer)\n \t  if (current_function_decl == TINST_DECL (p))\n \t    /* Avoid redundancy with the the \"In function\" line.  */;\n \t  else\n-\t    output_verbatim (buffer, \"%s: In instantiation of `%s':\\n\", file,\n+\t    output_verbatim (&context->buffer,\n+                             \"%s: In instantiation of `%s':\\n\", file,\n                              decl_as_string (TINST_DECL (p),\n                                              TFF_DECL_SPECIFIERS | TFF_RETURN_TYPE));\n \n@@ -2496,47 +2490,47 @@ print_instantiation_full_context (buffer)\n \t}\n     }\n \n-  print_instantiation_partial_context (buffer, p, file, line);\n+  print_instantiation_partial_context (context, p, file, line);\n }\n \n /* Same as above but less verbose.  */\n static void\n-print_instantiation_partial_context (buffer, t, file, line)\n-     output_buffer *buffer;\n+print_instantiation_partial_context (context, t, file, line)\n+     diagnostic_context *context;\n      tree t;\n      const char *file;\n      int line;\n {\n   for (; t; t = TREE_CHAIN (t))\n     {\n       output_verbatim\n-        (buffer, \"%s:%d:   instantiated from `%s'\\n\", file, line,\n+        (&context->buffer, \"%s:%d:   instantiated from `%s'\\n\", file, line,\n          decl_as_string (TINST_DECL (t), TFF_DECL_SPECIFIERS | TFF_RETURN_TYPE));\n       line = TINST_LINE (t);\n       file = TINST_FILE (t);\n     }\n-  output_verbatim (buffer, \"%s:%d:   instantiated from here\\n\", file, line);\n+  output_verbatim (&context->buffer, \"%s:%d:   instantiated from here\\n\", file, line);\n }\n \n /* Called from cp_thing to print the template context for an error.  */\n static void\n-maybe_print_instantiation_context (buffer)\n-     output_buffer *buffer;\n+maybe_print_instantiation_context (context)\n+     diagnostic_context *context;\n {\n   if (!problematic_instantiation_changed () || current_instantiation () == 0)\n     return;\n \n   record_last_problematic_instantiation ();\n-  print_instantiation_full_context (buffer);\n+  print_instantiation_full_context (context);\n }\n \n /* Report the bare minimum context of a template instantiation.  */\n void\n print_instantiation_context ()\n {\n   print_instantiation_partial_context\n-    (diagnostic_buffer, current_instantiation (), input_filename, lineno);\n-  flush_diagnostic_buffer ();\n+    (global_dc, current_instantiation (), input_filename, lineno);\n+  diagnostic_flush_buffer (global_dc);\n }\n \f\n /* Called from output_format -- during diagnostic message processing --\n@@ -2552,26 +2546,27 @@ print_instantiation_context ()\n    %Q\tassignment operator.\n    %T   type.\n    %V   cv-qualifier.  */\n-static int\n-cp_printer (buffer)\n+static bool\n+cp_printer (buffer, text)\n      output_buffer *buffer;\n+     text_info *text;\n {\n   int verbose = 0;\n   const char *result;\n-#define next_tree    va_arg (output_buffer_format_args (buffer), tree)\n-#define next_tcode   va_arg (output_buffer_format_args (buffer), enum tree_code)\n-#define next_lang    va_arg (output_buffer_format_args (buffer), enum languages)\n-#define next_int     va_arg (output_buffer_format_args (buffer), int)\n-\n-  if (*output_buffer_text_cursor (buffer) == '+')\n-    ++output_buffer_text_cursor (buffer);\n-  if (*output_buffer_text_cursor (buffer) == '#')\n+#define next_tree    va_arg (*text->args_ptr, tree)\n+#define next_tcode   va_arg (*text->args_ptr, enum tree_code)\n+#define next_lang    va_arg (*text->args_ptr, enum languages)\n+#define next_int     va_arg (*text->args_ptr, int)\n+\n+  if (*text->format_spec == '+')\n+    ++text->format_spec;\n+  if (*text->format_spec == '#')\n     {\n       verbose = 1;\n-      ++output_buffer_text_cursor (buffer);\n+      ++text->format_spec;\n     }\n \n-  switch (*output_buffer_text_cursor (buffer))\n+  switch (*text->format_spec)\n     {\n     case 'A': result = args_to_string (next_tree, verbose);\tbreak;\n     case 'C': result = code_to_string (next_tcode, verbose);\tbreak;\n@@ -2586,11 +2581,11 @@ cp_printer (buffer)\n     case 'V': result = cv_to_string (next_tree, verbose);\tbreak;\n  \n     default:\n-      return 0;\n+      return false;\n     }\n \n   output_add_string (buffer, result);\n-  return 1;\n+  return true;\n #undef next_tree\n #undef next_tcode\n #undef next_lang\n@@ -2684,7 +2679,7 @@ void\n cp_error_at VPARAMS ((const char *msgid, ...))\n {\n   tree here;\n-  diagnostic_context dc;\n+  diagnostic_info diagnostic;\n \n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, const char *, msgid);\n@@ -2694,18 +2689,17 @@ cp_error_at VPARAMS ((const char *msgid, ...))\n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  set_diagnostic_context (&dc, msgid, &ap,\n-\t\t\t  cp_file_of (here),\n-\t\t\t  cp_line_of (here), /* warning = */ 0);\n-  report_diagnostic (&dc);\n+  diagnostic_set_info (&diagnostic, msgid, &ap,\n+                       cp_file_of (here), cp_line_of (here), DK_WARNING);\n+  report_diagnostic (&diagnostic);\n   VA_CLOSE (ap);\n }\n \n void\n cp_warning_at VPARAMS ((const char *msgid, ...))\n {\n   tree here;\n-  diagnostic_context dc;\n+  diagnostic_info diagnostic;\n \n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, const char *, msgid);\n@@ -2715,18 +2709,17 @@ cp_warning_at VPARAMS ((const char *msgid, ...))\n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  set_diagnostic_context (&dc, msgid, &ap,\n-\t\t\t  cp_file_of (here),\n-\t\t\t  cp_line_of (here), /* warning = */ 1);\n-  report_diagnostic (&dc);\n+  diagnostic_set_info (&diagnostic, msgid, &ap,\n+                       cp_file_of (here), cp_line_of (here), DK_WARNING);\n+  report_diagnostic (&diagnostic);\n   VA_CLOSE (ap);\n }\n \n void\n cp_pedwarn_at VPARAMS ((const char *msgid, ...))\n {\n   tree here;\n-  diagnostic_context dc;\n+  diagnostic_info diagnostic;\n \n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, const char *, msgid);\n@@ -2736,10 +2729,9 @@ cp_pedwarn_at VPARAMS ((const char *msgid, ...))\n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  set_diagnostic_context (&dc, msgid, &ap,\n-\t\t\t  cp_file_of (here),\n-\t\t\t  cp_line_of (here),\n-\t\t\t  /* warning = */ !flag_pedantic_errors);\n-  report_diagnostic (&dc);\n+  diagnostic_set_info (&diagnostic, msgid, &ap,\n+                       cp_file_of (here), cp_line_of (here),\n+                       pedantic_error_kind());\n+  report_diagnostic (&diagnostic);\n   VA_CLOSE (ap);\n }"}, {"sha": "2669da1b67a8ca07d2456a76d122f872b5126224", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 307, "deletions": 455, "changes": 762, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b69537e4bde3e38f988f163d46b81fcea84e0a/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b69537e4bde3e38f988f163d46b81fcea84e0a/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=47b69537e4bde3e38f988f163d46b81fcea84e0a", "patch": "@@ -1,4 +1,4 @@\n-/* Language-independent diagnostic subroutines for the GNU C compiler\n+/* Language-independent diagnostic subroutines for the GNU Compiler Collection\n    Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n    Contributed by Gabriel Dos Reis <gdr@codesourcery.com>\n \n@@ -50,30 +50,22 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #define output_text_length(BUFFER) (BUFFER)->line_length\n #define is_starting_newline(BUFFER) (output_text_length (BUFFER) == 0)\n-#define output_prefix(BUFFER) (BUFFER)->state.prefix\n #define line_wrap_cutoff(BUFFER) (BUFFER)->state.maximum_length\n #define prefix_was_emitted_for(BUFFER) (BUFFER)->state.emitted_prefix_p\n-#define output_buffer_ptr_to_format_args(BUFFER) (BUFFER)->state.format_args\n-\n-#define diagnostic_args output_buffer_ptr_to_format_args (diagnostic_buffer)\n-#define diagnostic_msg output_buffer_text_cursor (diagnostic_buffer)\n \n /* Prototypes.  */\n static void output_flush PARAMS ((output_buffer *));\n-static void output_do_verbatim PARAMS ((output_buffer *,\n-\t\t\t\t\tconst char *, va_list *));\n+static void output_do_verbatim PARAMS ((output_buffer *, text_info *));\n static void output_buffer_to_stream PARAMS ((output_buffer *));\n-static void output_format PARAMS ((output_buffer *));\n+static void output_format PARAMS ((output_buffer *, text_info *));\n static void output_indent PARAMS ((output_buffer *));\n \n static char *vbuild_message_string PARAMS ((const char *, va_list))\n      ATTRIBUTE_PRINTF (1, 0);\n static char *build_message_string PARAMS ((const char *, ...))\n      ATTRIBUTE_PRINTF_1;\n-static void output_do_printf PARAMS ((output_buffer *, const char *))\n-     ATTRIBUTE_PRINTF (2, 0);\n-static void format_with_decl PARAMS ((output_buffer *, tree));\n-static void diagnostic_for_decl PARAMS ((tree, const char *, va_list *, int));\n+static void format_with_decl PARAMS ((output_buffer *, text_info *, tree));\n+static void diagnostic_for_decl PARAMS ((diagnostic_info *, tree));\n static void set_real_maximum_length PARAMS ((output_buffer *));\n \n static void output_unsigned_decimal PARAMS ((output_buffer *, unsigned int));\n@@ -91,12 +83,12 @@ static void maybe_wrap_text PARAMS ((output_buffer *, const char *,\n \t\t\t\t     const char *));\n static void output_clear_data PARAMS ((output_buffer *));\n \n-static void default_diagnostic_starter PARAMS ((output_buffer *,\n-\t\t\t\t\t\tdiagnostic_context *));\n-static void default_diagnostic_finalizer PARAMS ((output_buffer *,\n-\t\t\t\t\t\t  diagnostic_context *));\n+static void default_diagnostic_starter PARAMS ((diagnostic_context *,\n+                                                diagnostic_info *));\n+static void default_diagnostic_finalizer PARAMS ((diagnostic_context *,\n+                                                  diagnostic_info *));\n \n-static void error_recursion PARAMS ((void)) ATTRIBUTE_NORETURN;\n+static void error_recursion PARAMS ((diagnostic_context *)) ATTRIBUTE_NORETURN;\n \n extern int rtl_dump_and_exit;\n extern int warnings_are_errors;\n@@ -105,107 +97,24 @@ extern int warnings_are_errors;\n static diagnostic_context global_diagnostic_context;\n diagnostic_context *global_dc = &global_diagnostic_context;\n \n-/* Function of last error message;\n-   more generally, function such that if next error message is in it\n-   then we don't have to mention the function name.  */\n-static tree last_error_function = NULL;\n-\n-/* Used to detect when input_file_stack has changed since last described.  */\n-static int last_error_tick;\n-\n-/* Prevent recursion into the error handler.  */\n-static int diagnostic_lock;\n-\n \f\n-/* Return truthvalue if current input file is different from the most recent\n-   file involved in a diagnostic message.  */\n-\n-int\n-error_module_changed ()\n-{\n-  return last_error_tick != input_file_stack_tick;\n-}\n-\n-/* Remember current file as being the most recent file involved in a\n-   diagnostic message.  */\n-\n-void\n-record_last_error_module ()\n-{\n-  last_error_tick = input_file_stack_tick;\n-}\n-\n-/* Same as error_module_changed, but for function.  */\n-\n-int\n-error_function_changed ()\n-{\n-  return last_error_function != current_function_decl;\n-}\n-\n-/* Same as record_last_error_module, but for function.  */\n-\n-void\n-record_last_error_function ()\n-{\n-  last_error_function = current_function_decl;\n-}\n-\n-/* Initialize the diagnostic message outputting machinery.  */\n-\n-void\n-diagnostic_initialize (context)\n-     diagnostic_context *context;\n-{\n-  memset (context, 0, sizeof *context);\n-  obstack_init (&context->buffer.obstack);\n-\n-  /* By default, diagnostics are sent to stderr.  */\n-  output_buffer_attached_stream (&context->buffer) = stderr;\n-\n-  /* By default, we emit prefixes once per message.  */\n-  diagnostic_prefixing_rule (context) = DIAGNOSTICS_SHOW_PREFIX_ONCE;\n-\n-  diagnostic_starter (context) = default_diagnostic_starter;\n-  diagnostic_finalizer (context) = default_diagnostic_finalizer;\n-}\n-\n-/* Returns true if BUFFER is in line-wrapping mode.  */\n-\n-int\n-output_is_line_wrapping (buffer)\n-     output_buffer *buffer;\n-{\n-  return output_line_cutoff (buffer) > 0;\n-}\n-\n-/* Return BUFFER's prefix.  */\n-\n-const char *\n-output_get_prefix (buffer)\n-     const output_buffer *buffer;\n-{\n-  return output_prefix (buffer);\n-}\n-\n /* Subroutine of output_set_maximum_length.  Set up BUFFER's\n    internal maximum characters per line.  */\n-\n static void\n set_real_maximum_length (buffer)\n      output_buffer *buffer;\n {\n   /* If we're told not to wrap lines then do the obvious thing.  In case\n    we'll emit prefix only once per diagnostic message, it is appropriate\n   not to increase unnecessarily the line-length cut-off.  */\n-  if (! output_is_line_wrapping (buffer)\n+  if (!output_is_line_wrapping (buffer)\n       || output_prefixing_rule (buffer) == DIAGNOSTICS_SHOW_PREFIX_ONCE\n       || output_prefixing_rule (buffer) == DIAGNOSTICS_SHOW_PREFIX_NEVER)\n     line_wrap_cutoff (buffer) = output_line_cutoff (buffer);\n   else\n     {\n-      int prefix_length =\n-\toutput_prefix (buffer) ? strlen (output_prefix (buffer)) : 0;\n+      int prefix_length = buffer->state.prefix ?\n+        strlen (buffer->state.prefix) : 0;\n       /* If the prefix is ridiculously too long, output at least\n          32 characters.  */\n       if (output_line_cutoff (buffer) - prefix_length < 32)\n@@ -217,7 +126,6 @@ set_real_maximum_length (buffer)\n \n /* Sets the number of maximum characters per line BUFFER can output\n    in line-wrapping mode.  A LENGTH value 0 suppresses line-wrapping.  */\n-\n void\n output_set_maximum_length (buffer, length)\n      output_buffer *buffer;\n@@ -228,15 +136,14 @@ output_set_maximum_length (buffer, length)\n }\n \n /* Sets BUFFER's PREFIX.  */\n-\n void\n output_set_prefix (buffer, prefix)\n      output_buffer *buffer;\n      const char *prefix;\n {\n-  output_prefix (buffer) = prefix;\n+  buffer->state.prefix = prefix;\n   set_real_maximum_length (buffer);\n-  prefix_was_emitted_for (buffer) = 0;\n+  prefix_was_emitted_for (buffer) = false;\n   output_indentation (buffer) = 0;\n }\n \n@@ -254,20 +161,18 @@ output_last_position (buffer)\n }\n \n /* Free BUFFER's prefix, a previously malloc'd string.  */\n-\n void\n output_destroy_prefix (buffer)\n      output_buffer *buffer;\n {\n-  if (output_prefix (buffer) != NULL)\n+  if (buffer->state.prefix != NULL)\n     {\n-      free ((char *) output_prefix (buffer));\n-      output_prefix (buffer) = NULL;\n+      free ((char *) buffer->state.prefix);\n+      buffer->state.prefix = NULL;\n     }\n }\n \n /* Zero out any text output so far in BUFFER.  */\n-\n void\n output_clear_message_text (buffer)\n      output_buffer *buffer;\n@@ -277,20 +182,16 @@ output_clear_message_text (buffer)\n }\n \n /* Zero out any formatting data used so far by BUFFER.  */\n-\n static void\n output_clear_data (buffer)\n      output_buffer *buffer;\n {\n-  output_buffer_text_cursor (buffer) = NULL;\n-  output_buffer_ptr_to_format_args (buffer) = NULL;\n   prefix_was_emitted_for (buffer) = false;\n   output_indentation (buffer) = 0;\n }\n \n /* Construct an output BUFFER with PREFIX and of MAXIMUM_LENGTH\n    characters per line.  */\n-\n void\n init_output_buffer (buffer, prefix, maximum_length)\n      output_buffer *buffer;\n@@ -308,7 +209,6 @@ init_output_buffer (buffer, prefix, maximum_length)\n }\n \n /* Reinitialize BUFFER.  */\n-\n void\n output_clear (buffer)\n      output_buffer *buffer;\n@@ -319,7 +219,6 @@ output_clear (buffer)\n \n /* Finishes constructing a NULL-terminated character string representing\n    the BUFFERed message.  */\n-\n const char *\n output_finalize_message (buffer)\n      output_buffer *buffer;\n@@ -328,16 +227,8 @@ output_finalize_message (buffer)\n   return output_message_text (buffer);\n }\n \n-void\n-flush_diagnostic_buffer ()\n-{\n-  output_buffer_to_stream (diagnostic_buffer);\n-  fflush (output_buffer_attached_stream (diagnostic_buffer));\n-}\n-\n /* Return the amount of characters BUFFER can accept to\n    make a full line.  */\n-\n int\n output_space_left (buffer)\n      const output_buffer *buffer;\n@@ -346,12 +237,11 @@ output_space_left (buffer)\n }\n \n /* Write out BUFFER's prefix.  */\n-\n void\n output_emit_prefix (buffer)\n      output_buffer *buffer;\n {\n-  if (output_prefix (buffer) != NULL)\n+  if (buffer->state.prefix != NULL)\n     {\n       switch (output_prefixing_rule (buffer))\n \t{\n@@ -370,17 +260,16 @@ output_emit_prefix (buffer)\n \n \tcase DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE:\n \t  {\n-\t    int prefix_length = strlen (output_prefix (buffer));\n-\t    output_append_r (buffer, output_prefix (buffer), prefix_length);\n-\t    prefix_was_emitted_for (buffer) = 1;\n+\t    int prefix_length = strlen (buffer->state.prefix);\n+\t    output_append_r (buffer, buffer->state.prefix, prefix_length);\n+\t    prefix_was_emitted_for (buffer) = true;\n \t  }\n \t  break;\n \t}\n     }\n }\n \n /* Have BUFFER start a new line.  */\n-\n void\n output_add_newline (buffer)\n      output_buffer *buffer;\n@@ -390,7 +279,6 @@ output_add_newline (buffer)\n }\n \n /* Appends a character to BUFFER.  */\n-\n void\n output_add_character (buffer, c)\n      output_buffer *buffer;\n@@ -403,7 +291,6 @@ output_add_character (buffer, c)\n }\n \n /* Adds a space to BUFFER.  */\n-\n void\n output_add_space (buffer)\n      output_buffer *buffer;\n@@ -419,7 +306,6 @@ output_add_space (buffer)\n \n /* These functions format an INTEGER into BUFFER as suggested by their\n    names.  */\n-\n void\n output_decimal (buffer, i)\n      output_buffer *buffer;\n@@ -486,7 +372,6 @@ output_long_hexadecimal (buffer, i)\n \n /* Append to BUFFER a string specified by its STARTING character\n    and LENGTH.  */\n-\n static void\n output_append_r (buffer, start, length)\n      output_buffer *buffer;\n@@ -498,10 +383,9 @@ output_append_r (buffer, start, length)\n }\n \n /* Append a string deliminated by START and END to BUFFER.  No wrapping is\n-   done.  However, if beginning a new line then emit output_prefix (BUFFER)\n+   done.  However, if beginning a new line then emit BUFFER->state.prefix\n    and skip any leading whitespace if appropriate.  The caller must ensure\n    that it is safe to do so.  */\n-\n void\n output_append (buffer, start, end)\n      output_buffer *buffer;\n@@ -531,14 +415,13 @@ output_indent (buffer)\n }\n \n /* Wrap a text delimited by START and END into BUFFER.  */\n-\n static void\n wrap_text (buffer, start, end)\n      output_buffer *buffer;\n      const char *start;\n      const char *end;\n {\n-  int is_wrapping = output_is_line_wrapping (buffer);\n+  bool is_wrapping = output_is_line_wrapping (buffer);\n \n   while (start != end)\n     {\n@@ -567,7 +450,6 @@ wrap_text (buffer, start, end)\n }\n \n /* Same as wrap_text but wrap text only when in line-wrapping mode.  */\n-\n static void\n maybe_wrap_text (buffer, start, end)\n      output_buffer *buffer;\n@@ -583,7 +465,6 @@ maybe_wrap_text (buffer, start, end)\n \n /* Append a STRING to BUFFER; the STRING might be line-wrapped if in\n    appropriate mode.  */\n-\n void\n output_add_string (buffer, str)\n      output_buffer *buffer;\n@@ -604,9 +485,8 @@ output_buffer_to_stream (buffer)\n   output_clear_message_text (buffer);\n }\n \n-/* Format a message pointed to by output_buffer_text_cursor (BUFFER) using\n-   output_buffer_format_args (BUFFER) as appropriate.  The following format\n-   specifiers are recognized as being language independent:\n+/* Format a message pointed to by TEXT.  The following format specifiers are\n+   recognized as being language independent:\n    %d, %i: (signed) integer in base ten.\n    %u: unsigned integer in base ten.\n    %o: unsigned integer in base eight.\n@@ -616,93 +496,80 @@ output_buffer_to_stream (buffer)\n    %s: string.\n    %%: `%'.\n    %*.s: a substring the length of which is specified by an integer.  */\n-\n static void\n-output_format (buffer)\n+output_format (buffer, text)\n      output_buffer *buffer;\n+     text_info *text;\n {\n-  for (; *output_buffer_text_cursor (buffer);\n-       ++output_buffer_text_cursor (buffer))\n+  for (; *text->format_spec; ++text->format_spec)\n     {\n-      int long_integer = 0;\n+      bool long_integer = 0;\n \n       /* Ignore text.  */\n       {\n-\tconst char *p = output_buffer_text_cursor (buffer);\n+\tconst char *p = text->format_spec;\n \twhile (*p && *p != '%')\n \t  ++p;\n-\twrap_text (buffer, output_buffer_text_cursor (buffer), p);\n-\toutput_buffer_text_cursor (buffer) = p;\n+\twrap_text (buffer, text->format_spec, p);\n+        text->format_spec = p;\n       }\n \n-      if (!*output_buffer_text_cursor (buffer))\n+      if (*text->format_spec == '\\0')\n \tbreak;\n \n       /* We got a '%'.  Let's see what happens. Record whether we're\n          parsing a long integer format specifier.  */\n-      if (*++output_buffer_text_cursor (buffer) == 'l')\n+      if (*++text->format_spec == 'l')\n \t{\n-\t  long_integer = 1;\n-\t  ++output_buffer_text_cursor (buffer);\n+\t  long_integer = true;\n+\t  ++text->format_spec;\n \t}\n \n       /* Handle %c, %d, %i, %ld, %li, %lo, %lu, %lx, %o, %s, %u,\n          %x, %.*s; %%.  And nothing else.  Front-ends should install\n          printers to grok language specific format specifiers.  */\n-      switch (*output_buffer_text_cursor (buffer))\n+      switch (*text->format_spec)\n \t{\n \tcase 'c':\n-\t  output_add_character\n-\t    (buffer, va_arg (output_buffer_format_args (buffer), int));\n+\t  output_add_character (buffer, va_arg (*text->args_ptr, int));\n \t  break;\n \n \tcase 'd':\n \tcase 'i':\n \t  if (long_integer)\n-\t    output_long_decimal\n-\t      (buffer, va_arg (output_buffer_format_args (buffer), long int));\n+\t    output_long_decimal (buffer, va_arg (*text->args_ptr, long int));\n \t  else\n-\t    output_decimal\n-\t      (buffer, va_arg (output_buffer_format_args (buffer), int));\n+\t    output_decimal (buffer, va_arg (*text->args_ptr, int));\n \t  break;\n \n \tcase 'o':\n \t  if (long_integer)\n \t    output_long_octal (buffer,\n-\t\t\t       va_arg (output_buffer_format_args (buffer),\n-\t\t\t\t       unsigned long int));\n+\t\t\t       va_arg (*text->args_ptr, unsigned long int));\n \t  else\n-\t    output_octal (buffer,\n-\t\t\t  va_arg (output_buffer_format_args (buffer),\n-\t\t\t\t  unsigned int));\n+\t    output_octal (buffer, va_arg (*text->args_ptr, unsigned int));\n \t  break;\n \n \tcase 's':\n-\t  output_add_string (buffer,\n-\t\t\t     va_arg (output_buffer_format_args (buffer),\n-\t\t\t\t     const char *));\n+\t  output_add_string (buffer, va_arg (*text->args_ptr, const char *));\n \t  break;\n \n \tcase 'u':\n \t  if (long_integer)\n \t    output_long_unsigned_decimal\n-\t      (buffer, va_arg (output_buffer_format_args (buffer),\n-\t\t\t       long unsigned int));\n+\t      (buffer, va_arg (*text->args_ptr, long unsigned int));\n \t  else\n \t    output_unsigned_decimal\n-\t      (buffer, va_arg (output_buffer_format_args (buffer),\n-\t\t\t       unsigned int));\n+\t      (buffer, va_arg (*text->args_ptr, unsigned int));\n \t  break;\n \n \tcase 'x':\n \t  if (long_integer)\n \t    output_long_hexadecimal\n-\t      (buffer, va_arg (output_buffer_format_args (buffer),\n-\t\t\t       unsigned long int));\n+\t      (buffer, va_arg (*text->args_ptr, unsigned long int));\n \t  else\n \t    output_hexadecimal\n-\t      (buffer, va_arg (output_buffer_format_args (buffer),\n-\t\t\t       unsigned int));\n+              (buffer, va_arg (*text->args_ptr, unsigned int));\n \t  break;\n \n \tcase '%':\n@@ -714,18 +581,19 @@ output_format (buffer)\n \t    int n;\n \t    const char *s;\n \t    /* We handle no precision specifier but `%.*s'.  */\n-\t    if (*++output_buffer_text_cursor (buffer) != '*')\n+\t    if (*++text->format_spec != '*')\n \t      abort ();\n-\t    else if (*++output_buffer_text_cursor (buffer) != 's')\n+\t    else if (*++text->format_spec != 's')\n \t      abort ();\n-\t    n = va_arg (output_buffer_format_args (buffer), int);\n-\t    s = va_arg (output_buffer_format_args (buffer), const char *);\n+\t    n = va_arg (*text->args_ptr, int);\n+\t    s = va_arg (*text->args_ptr, const char *);\n \t    output_append (buffer, s, s + n);\n \t  }\n \t  break;\n \n \tdefault:\n-\t  if (!buffer->format_decoder || !(*buffer->format_decoder) (buffer))\n+\t  if (!buffer->format_decoder\n+              || !(*buffer->format_decoder) (buffer, text))\n \t    {\n \t      /* Hmmm.  The front-end failed to install a format translator\n                  but called us with an unrecognized format.  Sorry.  */\n@@ -748,7 +616,6 @@ vbuild_message_string (msg, ap)\n \n /*  Return a malloc'd string containing MSG formatted a la\n     printf.  The caller is responsible for freeing the memory.  */\n-\n static char *\n build_message_string VPARAMS ((const char *msg, ...))\n {\n@@ -764,86 +631,42 @@ build_message_string VPARAMS ((const char *msg, ...))\n   return str;\n }\n \n-/* Return a malloc'd string describing a location.  The caller is\n-   responsible for freeing the memory.  */\n-\n-char *\n-context_as_prefix (file, line, warn)\n-     const char *file;\n-     int line;\n-     int warn;\n-{\n-  if (file)\n-    {\n-      if (warn)\n-\treturn build_message_string (_(\"%s:%d: warning: \"), file, line);\n-      else\n-\treturn build_message_string (\"%s:%d: \", file, line);\n-    }\n-  else\n-    {\n-      if (warn)\n-\treturn build_message_string (_(\"%s: warning: \"), progname);\n-      else\n-\treturn build_message_string (\"%s: \", progname);\n-    }\n-}\n-\n-/* Same as context_as_prefix, but only the source FILE is given.  */\n-\n+/* Same as diagnsotic_build_prefix, but only the source FILE is given.  */\n char *\n file_name_as_prefix (f)\n      const char *f;\n {\n   return build_message_string (\"%s: \", f);\n }\n \n-/* Format a MESSAGE into BUFFER.  Automatically wrap lines.  */\n-\n-static void\n-output_do_printf (buffer, msg)\n-     output_buffer *buffer;\n-     const char *msg;\n-{\n-  char *message = vbuild_message_string (msg,\n-\t\t\t\t\t output_buffer_format_args (buffer));\n-\n-  wrap_text (buffer, message, message + strlen (message));\n-  free (message);\n-}\n-\n-\n /* Format a message into BUFFER a la printf.  */\n-\n void\n output_printf VPARAMS ((struct output_buffer *buffer, const char *msgid, ...))\n {\n-  va_list *old_args;\n-\n+  text_info text;\n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, output_buffer *, buffer);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  old_args = output_buffer_ptr_to_format_args (buffer);\n-  output_buffer_ptr_to_format_args (buffer) = &ap;\n-  output_do_printf (buffer, _(msgid));\n-  output_buffer_ptr_to_format_args (buffer) = old_args;\n+  text.args_ptr = &ap;\n+  text.format_spec = _(msgid);\n+  output_format (buffer, &text);\n   VA_CLOSE (ap);\n }\n \n /* Print a message relevant to the given DECL.  */\n-\n static void\n-format_with_decl (buffer, decl)\n+format_with_decl (buffer, text, decl)\n      output_buffer *buffer;\n+     text_info *text;\n      tree decl;\n {\n   const char *p;\n \n   /* Do magic to get around lack of varargs support for insertion\n      of arguments into existing list.  We know that the decl is first;\n      we ass_u_me that it will be printed with \"%s\".  */\n-  for (p = output_buffer_text_cursor (buffer); *p; ++p)\n+  for (p = text->format_spec; *p; ++p)\n     {\n       if (*p == '%')\n \t{\n@@ -857,7 +680,7 @@ format_with_decl (buffer, decl)\n     }\n \n   /* Print the left-hand substring.  */\n-  maybe_wrap_text (buffer, output_buffer_text_cursor (buffer), p);\n+  maybe_wrap_text (buffer, text->format_spec, p);\n \n   if (*p == '%')\t\t/* Print the name.  */\n     {\n@@ -875,48 +698,12 @@ format_with_decl (buffer, decl)\n \n   if (*p)\t\t\t/* Print the rest of the message.  */\n     {\n-      output_buffer_text_cursor (buffer) = p;\n-      output_format (buffer);\n+      text->format_spec = p;\n+      output_format (buffer, text);\n     }\n }\n \n-\n-/* Report a diagnostic MESSAGE at the declaration DECL.\n-   MSG is a format string which uses %s to substitute the declaration\n-   name; subsequent substitutions are a la output_format.  */\n-\n-static void\n-diagnostic_for_decl (decl, msgid, args_ptr, warn)\n-     tree decl;\n-     const char *msgid;\n-     va_list *args_ptr;\n-     int warn;\n-{\n-  output_state os;\n-\n-  if (diagnostic_lock++)\n-    error_recursion ();\n-\n-  if (count_error (warn))\n-    {\n-      os = output_buffer_state (diagnostic_buffer);\n-      report_error_function (DECL_SOURCE_FILE (decl));\n-      output_set_prefix\n-\t(diagnostic_buffer, context_as_prefix\n-\t (DECL_SOURCE_FILE (decl), DECL_SOURCE_LINE (decl), warn));\n-      output_buffer_ptr_to_format_args (diagnostic_buffer) = args_ptr;\n-      output_buffer_text_cursor (diagnostic_buffer) = _(msgid);\n-      format_with_decl (diagnostic_buffer, decl);\n-      output_flush (&global_dc->buffer);\n-      output_destroy_prefix (diagnostic_buffer);\n-\n-      output_buffer_state (diagnostic_buffer) = os;\n-    }\n-  diagnostic_lock--;\n-}\n-\n /* Flush the content of BUFFER onto the attached stream.  */\n-\n static void\n output_flush (buffer)\n      output_buffer *buffer;\n@@ -929,67 +716,161 @@ output_flush (buffer)\n \n /* Helper subroutine of output_verbatim and verbatim. Do the appropriate\n    settings needed by BUFFER for a verbatim formatting.  */\n-\n static void\n-output_do_verbatim (buffer, msgid, args_ptr)\n+output_do_verbatim (buffer, text)\n      output_buffer *buffer;\n-     const char *msgid;\n-     va_list *args_ptr;\n+     text_info *text;\n {\n-  output_state os;\n+  diagnostic_prefixing_rule_t rule = output_prefixing_rule (buffer);\n+  int line_cutoff = output_line_cutoff (buffer);\n \n-  os = output_buffer_state (buffer);\n-  output_prefix (buffer) = NULL;\n+  /* Set verbatim mode.  */\n   output_prefixing_rule (buffer) = DIAGNOSTICS_SHOW_PREFIX_NEVER;\n-  output_buffer_text_cursor (buffer) = _(msgid);\n-  output_buffer_ptr_to_format_args (buffer) = args_ptr;\n-  output_set_maximum_length (buffer, 0);\n-  output_format (buffer);\n-  output_buffer_state (buffer) = os;\n+  output_line_cutoff (buffer) = 0;\n+  /* Do the actual formatting.  */\n+  output_format (buffer, text);\n+  /* Restore previous settings.  */\n+  output_prefixing_rule (buffer) = rule;\n+  output_line_cutoff (buffer) = line_cutoff;\n }\n \n /* Output MESSAGE verbatim into BUFFER.  */\n-\n void\n output_verbatim VPARAMS ((output_buffer *buffer, const char *msgid, ...))\n {\n+  text_info text;\n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, output_buffer *, buffer);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  output_do_verbatim (buffer, msgid, &ap);\n+  text.format_spec = msgid;\n+  text.args_ptr = &ap;\n+  output_do_verbatim (buffer, &text);\n   VA_CLOSE (ap);\n }\n+\n \f\n-/* Count an error or warning.  Return 1 if the message should be printed.  */\n+/* Initialize the diagnostic message outputting machinery.  */\n+void\n+diagnostic_initialize (context)\n+     diagnostic_context *context;\n+{\n+  memset (context, 0, sizeof *context);\n+  obstack_init (&context->buffer.obstack);\n \n-int\n-count_error (warningp)\n-     int warningp;\n+  /* By default, diagnostics are sent to stderr.  */\n+  output_buffer_attached_stream (&context->buffer) = stderr;\n+\n+  /* By default, we emit prefixes once per message.  */\n+  diagnostic_prefixing_rule (context) = DIAGNOSTICS_SHOW_PREFIX_ONCE;\n+\n+  diagnostic_starter (context) = default_diagnostic_starter;\n+  diagnostic_finalizer (context) = default_diagnostic_finalizer;\n+}\n+\n+void\n+diagnostic_set_info (diagnostic, msgid, args, file, line, kind)\n+     diagnostic_info *diagnostic;\n+     const char *msgid;\n+     va_list *args;\n+     const char *file;\n+     int line;\n+     diagnostic_t kind;\n+{\n+  diagnostic->message.format_spec = msgid;\n+  diagnostic->message.args_ptr = args;\n+  diagnostic->location.file = file;\n+  diagnostic->location.line = line;\n+  diagnostic->kind = kind;\n+}\n+\n+/* Return a malloc'd string describing a location.  The caller is\n+   responsible for freeing the memory.  */\n+char *\n+diagnostic_build_prefix (diagnostic)\n+     diagnostic_info *diagnostic;\n+{\n+  if (diagnostic->location.file)\n+    {\n+      if (diagnostic->kind == DK_WARNING)\n+\treturn build_message_string (_(\"%s:%d: warning: \"),\n+                                     diagnostic->location.file,\n+                                     diagnostic->location.line);\n+      else\n+\treturn build_message_string (\"%s:%d: \",\n+                                     diagnostic->location.file,\n+                                     diagnostic->location.line);\n+    }\n+  else\n+    {\n+      if (diagnostic->kind == DK_WARNING)\n+\treturn build_message_string (_(\"%s: warning: \"), progname);\n+      else\n+\treturn build_message_string (\"%s: \", progname);\n+    }\n+}\n+\n+/* Report a diagnostic MESSAGE at the declaration DECL.\n+   MSG is a format string which uses %s to substitute the declaration\n+   name; subsequent substitutions are a la output_format.  */\n+static void\n+diagnostic_for_decl (diagnostic, decl)\n+     diagnostic_info *diagnostic;\n+     tree decl;\n {\n-  if (warningp && !diagnostic_report_warnings_p ())\n-    return 0;\n+  if (global_dc->lock++)\n+    error_recursion (global_dc);\n \n-  if (warningp && !warnings_are_errors)\n-    warningcount++;\n+  if (diagnostic_count_error (global_dc, diagnostic->kind))\n+    {\n+      diagnostic_report_current_function (global_dc);\n+      output_set_prefix\n+\t(&global_dc->buffer, diagnostic_build_prefix (diagnostic));\n+      format_with_decl (&global_dc->buffer, &diagnostic->message, decl);\n+      output_flush (&global_dc->buffer);\n+      output_destroy_prefix (&global_dc->buffer);\n+    }\n+  global_dc->lock--;\n+}\n+\n+void\n+diagnostic_flush_buffer (context)\n+     diagnostic_context *context;\n+{\n+  output_buffer_to_stream (&context->buffer);\n+  fflush (output_buffer_attached_stream (&context->buffer));\n+}\n+\n+/* Count an error or warning.  Return true if the message should be\n+   printed.  */\n+bool\n+diagnostic_count_error (context, kind)\n+    diagnostic_context *context;\n+    diagnostic_t kind;\n+{\n+  if (kind == DK_WARNING && !diagnostic_report_warnings_p ())\n+    return false;\n+\n+  if (kind == DK_WARNING && !warnings_are_errors)\n+    ++diagnostic_kind_count (context, DK_WARNING);\n   else\n     {\n-      static int warning_message = 0;\n+      static bool warning_message = false;\n \n-      if (warningp && !warning_message)\n+      if (kind == DK_WARNING && !warning_message)\n \t{\n-\t  verbatim (\"%s: warnings being treated as errors\\n\", progname);\n-\t  warning_message = 1;\n+\t  output_verbatim (&context->buffer,\n+                           \"%s: warnings being treated as errors\\n\", progname);\n+\t  warning_message = true;\n \t}\n-      errorcount++;\n+      ++diagnostic_kind_count (context, DK_ERROR);\n     }\n \n-  return 1;\n+  return true;\n }\n \n /* Print a diagnostic MSGID on FILE.  This is just fprintf, except it\n    runs its second argument through gettext.  */\n-\n void\n fnotice VPARAMS ((FILE *file, const char *msgid, ...))\n {\n@@ -1004,159 +885,149 @@ fnotice VPARAMS ((FILE *file, const char *msgid, ...))\n \n /* Print a fatal I/O error message.  Argument are like printf.\n    Also include a system error message based on `errno'.  */\n-\n void\n fatal_io_error VPARAMS ((const char *msgid, ...))\n {\n-  output_state os;\n-\n+  text_info text;\n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  os = output_buffer_state (diagnostic_buffer);\n-\n-  output_printf (diagnostic_buffer, \"%s: %s: \", progname, xstrerror (errno));\n-  output_buffer_ptr_to_format_args (diagnostic_buffer) = &ap;\n-  output_buffer_text_cursor (diagnostic_buffer) = _(msgid);\n-  output_format (diagnostic_buffer);\n+  text.format_spec = _(msgid);\n+  text.args_ptr = &ap;\n+  output_printf (&global_dc->buffer, \"%s: %s: \", progname, xstrerror (errno));\n+  output_format (&global_dc->buffer, &text);\n   output_flush (&global_dc->buffer);\n-  output_buffer_state (diagnostic_buffer) = os;\n   VA_CLOSE (ap);\n   exit (FATAL_EXIT_CODE);\n }\n \n /* Issue a pedantic warning MSGID.  */\n-\n void\n pedwarn VPARAMS ((const char *msgid, ...))\n {\n-  diagnostic_context dc;\n-\n+  diagnostic_info diagnostic;\n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  set_diagnostic_context\n-    (&dc, msgid, &ap, input_filename, lineno, !flag_pedantic_errors);\n-  report_diagnostic (&dc);\n+  diagnostic_set_info (&diagnostic, _(msgid), &ap, input_filename, lineno,\n+                       pedantic_error_kind ());\n+  report_diagnostic (&diagnostic);\n   VA_CLOSE (ap);\n }\n \n /* Issue a pedantic warning about DECL.  */\n-\n void\n pedwarn_with_decl VPARAMS ((tree decl, const char *msgid, ...))\n {\n+  diagnostic_info diagnostic;\n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, tree, decl);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n+  diagnostic_set_info (&diagnostic, _(msgid), &ap,\n+                       DECL_SOURCE_FILE (decl), DECL_SOURCE_LINE (decl),\n+                       pedantic_error_kind ());\n+\n   /* We don't want -pedantic-errors to cause the compilation to fail from\n      \"errors\" in system header files.  Sometimes fixincludes can't fix what's\n      broken (eg: unsigned char bitfields - fixing it may change the alignment\n      which will cause programs to mysteriously fail because the C library\n      or kernel uses the original layout).  There's no point in issuing a\n      warning either, it's just unnecessary noise.  */\n   if (!DECL_IN_SYSTEM_HEADER (decl))\n-    diagnostic_for_decl (decl, msgid, &ap, !flag_pedantic_errors);\n+    diagnostic_for_decl (&diagnostic, decl);\n   VA_CLOSE (ap);\n }\n \n /* Same as above but within the context FILE and LINE.  */\n-\n void\n pedwarn_with_file_and_line VPARAMS ((const char *file, int line,\n \t\t\t\t     const char *msgid, ...))\n {\n-  diagnostic_context dc;\n-\n+  diagnostic_info diagnostic;\n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, const char *, file);\n   VA_FIXEDARG (ap, int, line);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  set_diagnostic_context (&dc, msgid, &ap, file, line, !flag_pedantic_errors);\n-  report_diagnostic (&dc);\n+  diagnostic_set_info (&diagnostic, _(msgid), &ap, file, line,\n+                       pedantic_error_kind ());\n+  report_diagnostic (&diagnostic);\n   VA_CLOSE (ap);\n }\n \n /* Just apologize with MSGID.  */\n-\n void\n sorry VPARAMS ((const char *msgid, ...))\n {\n-  output_state os;\n+  diagnostic_info diagnostic;\n \n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n   ++sorrycount;\n-  os = output_buffer_state (diagnostic_buffer);\n+  diagnostic_set_info (&diagnostic, _(msgid), &ap,\n+                       input_filename, lineno, DK_SORRY);\n \n   output_set_prefix\n-    (diagnostic_buffer, context_as_prefix (input_filename, lineno, 0));\n-  output_printf (diagnostic_buffer, \"sorry, not implemented: \");\n-  output_buffer_ptr_to_format_args (diagnostic_buffer) = &ap;\n-  output_buffer_text_cursor (diagnostic_buffer) = _(msgid);\n-  output_format (diagnostic_buffer);\n+    (&global_dc->buffer, diagnostic_build_prefix (&diagnostic));\n+  output_printf (&global_dc->buffer, \"sorry, not implemented: \");\n+  output_format (&global_dc->buffer, &diagnostic.message);\n   output_flush (&global_dc->buffer);\n-  output_buffer_state (diagnostic_buffer) = os;\n   VA_CLOSE (ap);\n }\n \n /* Called when the start of a function definition is parsed,\n    this function prints on stderr the name of the function.  */\n-\n void\n announce_function (decl)\n      tree decl;\n {\n-  if (! quiet_flag)\n+  if (!quiet_flag)\n     {\n       if (rtl_dump_and_exit)\n \tverbatim (\"%s \", IDENTIFIER_POINTER (DECL_NAME (decl)));\n       else\n \tverbatim (\" %s\", (*lang_hooks.decl_printable_name) (decl, 2));\n       fflush (stderr);\n-      output_needs_newline (diagnostic_buffer) = 1;\n-      record_last_error_function ();\n+      output_needs_newline (&global_dc->buffer) = true;\n+      diagnostic_set_last_function (global_dc);\n     }\n }\n \n /* The default function to print out name of current function that caused\n    an error.  */\n-\n void\n lhd_print_error_function (context, file)\n      diagnostic_context *context;\n      const char *file;\n {\n-  if (error_function_changed ())\n+  if (diagnostic_last_function_changed (context))\n     {\n-      char *prefix = file ? build_message_string (\"%s: \", file) : NULL;\n-      output_state os;\n+      const char *old_prefix = output_prefix (&context->buffer);\n+      char *new_prefix = file ? build_message_string (\"%s: \", file) : NULL;\n \n-      os = diagnostic_state (context);\n-      output_set_prefix ((output_buffer *) context, prefix);\n+      output_set_prefix (&context->buffer, new_prefix);\n \n       if (current_function_decl == NULL)\n-\toutput_add_string ((output_buffer *) context, _(\"At top level:\"));\n+\toutput_add_string (&context->buffer, _(\"At top level:\"));\n       else\n \t{\n \t  if (TREE_CODE (TREE_TYPE (current_function_decl)) == METHOD_TYPE)\n \t    output_printf\n-\t      ((output_buffer *) context, \"In member function `%s':\",\n+\t      (&context->buffer, \"In member function `%s':\",\n \t       (*lang_hooks.decl_printable_name) (current_function_decl, 2));\n \t  else\n \t    output_printf\n-\t      ((output_buffer *) context, \"In function `%s':\",\n+\t      (&context->buffer, \"In function `%s':\",\n \t       (*lang_hooks.decl_printable_name) (current_function_decl, 2));\n \t}\n-      output_add_newline ((output_buffer *) context);\n+      output_add_newline (&context->buffer);\n \n-      record_last_error_function ();\n-      output_buffer_to_stream ((output_buffer *) context);\n-      diagnostic_state (context) = os;\n-      free ((char*) prefix);\n+      diagnostic_set_last_function (context);\n+      output_buffer_to_stream (&context->buffer);\n+      context->buffer.state.prefix = old_prefix;\n+      free ((char*) new_prefix);\n     }\n }\n \n@@ -1165,37 +1036,41 @@ lhd_print_error_function (context, file)\n   We ignore the FILE parameter, as it cannot be relied upon.  */\n \n void\n-report_error_function (file)\n-  const char *file ATTRIBUTE_UNUSED;\n+diagnostic_report_current_function (context)\n+     diagnostic_context *context;\n {\n-  report_problematic_module ((output_buffer *) global_dc);\n-  (*lang_hooks.print_error_function) (global_dc, input_filename);\n+  diagnostic_report_current_module (context);\n+  (*lang_hooks.print_error_function) (context, input_filename);\n }\n \n void\n error_with_file_and_line VPARAMS ((const char *file, int line,\n \t\t\t\t   const char *msgid, ...))\n {\n-  diagnostic_context dc;\n+  diagnostic_info diagnostic;\n \n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, const char *, file);\n   VA_FIXEDARG (ap, int, line);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  set_diagnostic_context (&dc, msgid, &ap, file, line, /* warn = */ 0);\n-  report_diagnostic (&dc);\n+  diagnostic_set_info (&diagnostic, msgid, &ap, file, line, DK_ERROR);\n+  report_diagnostic (&diagnostic);\n   VA_CLOSE (ap);\n }\n \n void\n error_with_decl VPARAMS ((tree decl, const char *msgid, ...))\n {\n+  diagnostic_info diagnostic;\n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, tree, decl);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  diagnostic_for_decl (decl, msgid, &ap, /* warn = */ 0);\n+  diagnostic_set_info (&diagnostic, msgid, &ap,\n+                       DECL_SOURCE_FILE (decl), DECL_SOURCE_LINE (decl),\n+                       DK_ERROR);\n+  diagnostic_for_decl (&diagnostic, decl);\n   VA_CLOSE (ap);\n }\n \n@@ -1205,14 +1080,14 @@ error_with_decl VPARAMS ((tree decl, const char *msgid, ...))\n void\n error VPARAMS ((const char *msgid, ...))\n {\n-  diagnostic_context dc;\n+  diagnostic_info diagnostic;\n \n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  set_diagnostic_context\n-    (&dc, msgid, &ap, input_filename, lineno, /* warn = */ 0);\n-  report_diagnostic (&dc);\n+  diagnostic_set_info (&diagnostic, msgid, &ap, input_filename, lineno,\n+                       DK_ERROR);\n+  report_diagnostic (&diagnostic);\n   VA_CLOSE (ap);\n }\n \n@@ -1222,14 +1097,14 @@ error VPARAMS ((const char *msgid, ...))\n void\n fatal_error VPARAMS ((const char *msgid, ...))\n {\n-  diagnostic_context dc;\n+  diagnostic_info diagnostic;\n \n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  set_diagnostic_context\n-    (&dc, msgid, &ap, input_filename, lineno, /* warn = */ 0);\n-  report_diagnostic (&dc);\n+  diagnostic_set_info (&diagnostic, msgid, &ap, input_filename, lineno,\n+                       DK_FATAL);\n+  report_diagnostic (&diagnostic);\n   VA_CLOSE (ap);\n \n   fnotice (stderr, \"compilation terminated.\\n\");\n@@ -1239,13 +1114,13 @@ fatal_error VPARAMS ((const char *msgid, ...))\n void\n internal_error VPARAMS ((const char *msgid, ...))\n {\n-  diagnostic_context dc;\n+  diagnostic_info diagnostic;\n \n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  if (diagnostic_lock)\n-    error_recursion ();\n+  if (global_dc->lock)\n+    error_recursion (global_dc);\n \n #ifndef ENABLE_CHECKING\n   if (errorcount > 0 || sorrycount > 0)\n@@ -1259,9 +1134,9 @@ internal_error VPARAMS ((const char *msgid, ...))\n   if (global_dc->internal_error != 0)\n     (*global_dc->internal_error) (_(msgid), &ap);\n \n-  set_diagnostic_context\n-    (&dc, msgid, &ap, input_filename, lineno, /* warn = */0);\n-  report_diagnostic (&dc);\n+  diagnostic_set_info (&diagnostic, msgid, &ap, input_filename, lineno,\n+                       DK_ICE);\n+  report_diagnostic (&diagnostic);\n   VA_CLOSE (ap);\n \n   fnotice (stderr,\n@@ -1275,40 +1150,44 @@ void\n warning_with_file_and_line VPARAMS ((const char *file, int line,\n \t\t\t\t     const char *msgid, ...))\n {\n-  diagnostic_context dc;\n+  diagnostic_info diagnostic;\n \n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, const char *, file);\n   VA_FIXEDARG (ap, int, line);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  set_diagnostic_context (&dc, msgid, &ap, file, line, /* warn = */ 1);\n-  report_diagnostic (&dc);\n+  diagnostic_set_info (&diagnostic, msgid, &ap, file, line, DK_WARNING);\n+  report_diagnostic (&diagnostic);\n   VA_CLOSE (ap);\n }\n \n void\n warning_with_decl VPARAMS ((tree decl, const char *msgid, ...))\n {\n+  diagnostic_info diagnostic;\n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, tree, decl);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  diagnostic_for_decl (decl, msgid, &ap, /* warn = */ 1);\n+  diagnostic_set_info (&diagnostic, msgid, &ap,\n+                       DECL_SOURCE_FILE (decl), DECL_SOURCE_LINE (decl),\n+                       DK_WARNING);\n+  diagnostic_for_decl (&diagnostic, decl);\n   VA_CLOSE (ap);\n }\n \n void\n warning VPARAMS ((const char *msgid, ...))\n {\n-  diagnostic_context dc;\n+  diagnostic_info diagnostic;\n \n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  set_diagnostic_context\n-    (&dc, msgid, &ap, input_filename, lineno, /* warn = */ 1);\n-  report_diagnostic (&dc);\n+  diagnostic_set_info (&diagnostic, msgid, &ap, input_filename, lineno,\n+                       DK_WARNING);\n+  report_diagnostic (&diagnostic);\n   VA_CLOSE (ap);\n }\n \n@@ -1318,11 +1197,14 @@ warning VPARAMS ((const char *msgid, ...))\n void\n verbatim VPARAMS ((const char *msgid, ...))\n {\n+  text_info text;\n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  output_do_verbatim (diagnostic_buffer, msgid, &ap);\n-  output_buffer_to_stream (diagnostic_buffer);\n+  text.format_spec = _(msgid);\n+  text.args_ptr = &ap;\n+  output_do_verbatim (&global_dc->buffer, &text);\n+  output_buffer_to_stream (&global_dc->buffer);\n   VA_CLOSE (ap);\n }\n \n@@ -1333,27 +1215,22 @@ verbatim VPARAMS ((const char *msgid, ...))\n    in the documentation of output_format.  */\n \n void\n-report_diagnostic (dc)\n-     diagnostic_context *dc;\n+diagnostic_report_diagnostic (context, diagnostic)\n+     diagnostic_context *context;\n+     diagnostic_info *diagnostic;\n {\n-  output_state os;\n-\n-  if (diagnostic_lock++)\n-    error_recursion ();\n+  if (context->lock++)\n+    error_recursion (context);\n \n-  if (count_error (diagnostic_is_warning (dc)))\n+  if (diagnostic_count_error (context, diagnostic->kind))\n     {\n-      os = output_buffer_state (diagnostic_buffer);\n-      diagnostic_msg = diagnostic_message (dc);\n-      diagnostic_args = diagnostic_argument_list (dc);\n-      (*diagnostic_starter (dc)) (diagnostic_buffer, dc);\n-      output_format (diagnostic_buffer);\n-      (*diagnostic_finalizer (dc)) (diagnostic_buffer, dc);\n-      output_flush (&global_dc->buffer);\n-      output_buffer_state (diagnostic_buffer) = os;\n+      (*diagnostic_starter (context)) (context, diagnostic);\n+      output_format (&context->buffer, &diagnostic->message);\n+      (*diagnostic_finalizer (context)) (context, diagnostic);\n+      output_flush (&context->buffer);\n     }\n \n-  diagnostic_lock--;\n+  --context->lock;\n }\n \n /* Inform the user that an error occurred while trying to report some\n@@ -1362,10 +1239,11 @@ report_diagnostic (dc)\n    This mustn't use internal_error, that will cause infinite recursion.  */\n \n static void\n-error_recursion ()\n+error_recursion (context)\n+     diagnostic_context *context;\n {\n-  if (diagnostic_lock < 3)\n-    output_flush (&global_dc->buffer);\n+  if (context->lock < 3)\n+    output_flush (&context->buffer);\n \n   fnotice (stderr,\n \t   \"Internal compiler error: Error reporting routines re-entered.\\n\");\n@@ -1434,74 +1312,48 @@ fancy_abort (file, line, function)\n \t\t  function, trim_filename (file), line);\n }\n \n-/* Setup DC for reporting a diagnostic MESSAGE (an error or a WARNING),\n-   using arguments pointed to by ARGS_PTR, issued at a location specified\n-   by FILE and LINE.  */\n-\n-void\n-set_diagnostic_context (dc, msgid, args_ptr, file, line, warn)\n-     diagnostic_context *dc;\n-     const char *msgid;\n-     va_list *args_ptr;\n-     const char *file;\n-     int line;\n-     int warn;\n-{\n-  memset (dc, 0, sizeof (diagnostic_context));\n-  diagnostic_message (dc) = _(msgid);\n-  diagnostic_argument_list (dc) = args_ptr;\n-  diagnostic_file_location (dc) = file;\n-  diagnostic_line_location (dc) = line;\n-  diagnostic_is_warning (dc) = warn;\n-  diagnostic_starter (dc) = diagnostic_starter (global_dc);\n-  diagnostic_finalizer (dc) = diagnostic_finalizer (global_dc);\n-}\n-\n void\n-report_problematic_module (buffer)\n-     output_buffer *buffer;\n+diagnostic_report_current_module (context)\n+     diagnostic_context *context;\n {\n   struct file_stack *p;\n \n-  if (output_needs_newline (buffer))\n+  if (output_needs_newline (&context->buffer))\n     {\n-      output_add_newline (buffer);\n-      output_needs_newline (buffer) = 0;\n+      output_add_newline (&context->buffer);\n+      output_needs_newline (&context->buffer) = false;\n     }\n \n   if (input_file_stack && input_file_stack->next != 0\n-      && error_module_changed ())\n+      && diagnostic_last_module_changed (context))\n     {\n       for (p = input_file_stack->next; p; p = p->next)\n \tif (p == input_file_stack->next)\n-\t  output_verbatim\n-\t    (buffer, \"In file included from %s:%d\", p->name, p->line);\n+\t  output_verbatim (&context->buffer,\n+                           \"In file included from %s:%d\", p->name, p->line);\n \telse\n-\t  output_verbatim\n-\t    (buffer, \",\\n                 from %s:%d\", p->name, p->line);\n-      output_verbatim (buffer, \":\\n\");\n-      record_last_error_module ();\n+\t  output_verbatim (&context->buffer,\n+                           \",\\n                 from %s:%d\", p->name, p->line);\n+      output_verbatim (&context->buffer, \":\\n\");\n+      diagnostic_set_last_module (context);\n     }\n }\n \n static void\n-default_diagnostic_starter (buffer, dc)\n-     output_buffer *buffer;\n-     diagnostic_context *dc;\n+default_diagnostic_starter (context, diagnostic)\n+     diagnostic_context *context;\n+     diagnostic_info *diagnostic;\n {\n-  report_error_function (diagnostic_file_location (dc));\n-  output_set_prefix (buffer,\n-\t\t     context_as_prefix (diagnostic_file_location (dc),\n-\t\t\t\t\tdiagnostic_line_location (dc),\n-\t\t\t\t\tdiagnostic_is_warning (dc)));\n+  diagnostic_report_current_function (context);\n+  output_set_prefix (&context->buffer, diagnostic_build_prefix (diagnostic));\n }\n \n static void\n-default_diagnostic_finalizer (buffer, dc)\n-     output_buffer *buffer;\n-     diagnostic_context *dc __attribute__((__unused__));\n+default_diagnostic_finalizer (context, diagnostic)\n+     diagnostic_context *context;\n+     diagnostic_info *diagnostic __attribute__((unused));\n {\n-  output_destroy_prefix (buffer);\n+  output_destroy_prefix (&context->buffer);\n }\n \n void"}, {"sha": "bbc8e079ac59b0afe2aba2bf64bd164158767eb1", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 100, "deletions": 91, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b69537e4bde3e38f988f163d46b81fcea84e0a/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b69537e4bde3e38f988f163d46b81fcea84e0a/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=47b69537e4bde3e38f988f163d46b81fcea84e0a", "patch": "@@ -24,13 +24,15 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #include \"obstack.h\"\n \n-/*  Forward declarations.  */\n-typedef struct output_buffer output_buffer;\n-typedef struct diagnostic_context diagnostic_context;\n-typedef void (*diagnostic_starter_fn) PARAMS ((output_buffer *,\n-                                               diagnostic_context *));\n-typedef diagnostic_starter_fn diagnostic_finalizer_fn;\n+/* The type of a text to be formatted according a format specification\n+   along with a list of things.  */\n+typedef struct\n+{\n+  const char *format_spec;\n+  va_list *args_ptr;\n+} text_info;\n \n+/* Contants used to discreminate diagnostics.  */\n typedef enum\n {\n #define DEFINE_DIAGNOSTIC_KIND(K, M) K,  \n@@ -39,6 +41,27 @@ typedef enum\n   DK_LAST_DIAGNOSTIC_KIND\n } diagnostic_t;\n \n+/* The data structure used to record the location of a diagnostic.  */\n+typedef struct\n+{\n+  /* The name of the source file involved in the diagnostic.  */     \n+  const char *file;\n+\n+  /* The line-location in the source file.  */\n+  int line;\n+} location_t;\n+\n+/* A diagnostic is described by the MESSAGE to send, the FILE and LINE of\n+   its context and its KIND (ice, error, warning, note, ...)  See complete\n+   list in diagnostic.def.  */\n+typedef struct\n+{\n+  text_info message;\n+  location_t location;\n+  /* The kind of diagnostic it is about.  */\n+  diagnostic_t kind;\n+} diagnostic_info;\n+\n #define pedantic_error_kind() (flag_pedantic_errors ? DK_ERROR : DK_WARNING)\n \n /* How often diagnostics are prefixed by their locations:\n@@ -53,11 +76,6 @@ typedef enum\n   DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE = 0x2\n } diagnostic_prefixing_rule_t;\n \n-/* The type of front-end specific hook that formats trees into an\n-   output_buffer.  A language specific printer returns a truth value if\n-   everything goes well.  */\n-typedef int (*printer_fn) PARAMS ((output_buffer *));\n-\n /* This data structure encapsulates an output_buffer's state.  */\n typedef struct\n {\n@@ -83,15 +101,14 @@ typedef struct\n \n   /* Current prefixing rule.  */\n   diagnostic_prefixing_rule_t prefixing_rule;\n-\n-  /* The current char to output.  Updated by front-end (*format_map) when\n-     it is called to report front-end printer for a specified format.  */  \n-  const char *cursor;\n-\n-  /* A pointer to the variable argument-list for formatting.  */  \n-  va_list *format_args;\n } output_state;\n \n+/* The type of a hook that formats client-specific data (trees mostly) into\n+   an output_buffer.  A client-supplied formatter returns true if everything\n+   goes well.  */\n+typedef struct output_buffer output_buffer;\n+typedef bool (*printer_fn) PARAMS ((output_buffer *, text_info *));\n+\n /* The output buffer datatype.  This is best seen as an abstract datatype\n    whose fields should not be accessed directly by clients.  */\n struct output_buffer\n@@ -112,35 +129,23 @@ struct output_buffer\n      floating-point value.  */\n   char digit_buffer[128];\n \n-/* If non-NULL, this function formats data in the BUFFER. When called,\n-   output_buffer_text_cursor (BUFFER) points to a format code.\n-   FORMAT_DECODER should call output_add_string (and related functions)\n-   to add data to the BUFFER.  FORMAT_DECODER can read arguments from\n-   output_buffer_format_args (BUFFER) using VA_ARG.  If the BUFFER needs\n-   additional characters from the format string, it should advance\n-   the output_buffer_text_cursor (BUFFER) as it goes.  When FORMAT_DECODER\n-   returns, output_buffer_text_cursor (BUFFER) should point to the last\n-   character processed.  */\n-\n+  /* If non-NULL, this function formats a TEXT into the BUFFER. When called,\n+     TEXT->format_spec points to a format code.  FORMAT_DECODER should call\n+     output_add_string (and related functions) to add data to the BUFFER.\n+     FORMAT_DECODER can read arguments from *TEXT->args_pts using VA_ARG.\n+     If the BUFFER needs additional characters from the format string, it\n+     should advance the TEXT->format_spec as it goes.  When FORMAT_DECODER\n+     returns, TEXT->format_spec should point to the last character processed.\n+  */\n   printer_fn format_decoder;\n-};\n+} ;\n \n-/* Current state of an output_buffer.  */\n-#define output_buffer_state(BUFFER) (BUFFER)->state\n+#define output_prefix(BUFFER) (BUFFER)->state.prefix\n \n /* The stream attached to the output_buffer, where the formatted\n    diagnostics will ultimately go.  Works only on `output_buffer *'.  */\n #define output_buffer_attached_stream(BUFFER) (BUFFER)->stream\n \n-/* This points to the beginning of the rest of the diagnostic message\n-   to be formatted.  Accepts only `output_buffer *'s.  */\n-#define output_buffer_text_cursor(BUFFER) (BUFFER)->state.cursor\n-\n-/* The rest of the `variable argument list' not yet processed.\n-   This macro works on both `output_state *' and `output_buffer *'.  */\n-#define output_buffer_format_args(BUFFER) \\\n-   *(((output_state *)(BUFFER))->format_args)\n-\n /* In line-wrapping mode, whether we should start a new line.  */\n #define output_needs_newline(BUFFER) (BUFFER)->state.need_newline_p\n \n@@ -161,6 +166,15 @@ struct output_buffer\n    Zero means don't wrap lines.  */\n #define output_line_cutoff(BUFFER)  (BUFFER)->state.ideal_maximum_length\n \n+/* True if BUFFER is in line-wrapping mode.  */\n+#define output_is_line_wrapping(BUFFER) (output_line_cutoff (BUFFER) > 0)\n+\n+/*  Forward declarations.  */\n+typedef struct diagnostic_context diagnostic_context;\n+typedef void (*diagnostic_starter_fn) PARAMS ((diagnostic_context *,\n+                                               diagnostic_info *));\n+typedef diagnostic_starter_fn diagnostic_finalizer_fn;\n+\n /* This data structure bundles altogether any information relevant to\n    the context of a diagnostic message.  */\n struct diagnostic_context\n@@ -170,22 +184,6 @@ struct diagnostic_context\n      output_buffer.  */\n   output_buffer buffer;\n \n-  /* The diagnostic message to output.  */\n-  const char *message;\n-\n-  /* A pointer to a variable list of the arguments necessary for the\n-     purpose of message formatting.  */\n-  va_list *args_ptr;\n-\n-  /* The name of the source file involved in the diagnostic.  */     \n-  const char *file;\n-\n-  /* The line-location in the source file.  */\n-  int line;\n-\n-  /* Is this message a warning?  */\n-  int warn;\n-\n   /* The number of times we have issued diagnostics.  */\n   int diagnostic_count[DK_LAST_DIAGNOSTIC_KIND];\n \n@@ -196,34 +194,28 @@ struct diagnostic_context\n                       from \"/home/gdr/src/nifty_printer.h:56:\n                       ...\n   */\n-  void (*begin_diagnostic) PARAMS ((output_buffer *, diagnostic_context *));\n+  diagnostic_starter_fn begin_diagnostic;\n \n   /* This function is called after the diagnostic message is printed.  */\n-  void (*end_diagnostic) PARAMS ((output_buffer *, diagnostic_context *));\n+  diagnostic_finalizer_fn end_diagnostic;\n \n   /* Client hook to report an internal error.  */\n   void (*internal_error) PARAMS ((const char *, va_list *));\n \n+  /* Function of last diagnostic message; more generally, function such that\n+     if next diagnostic message is in it then we don't have to mention the\n+     function name.  */\n+  tree last_function;\n+\n+  /* Used to detect when input_file_stack has changed since last described.  */\n+  int last_module;\n+\n+  int lock;\n+  \n   /* Hook for front-end extensions.  */\n   void *x_data;\n };\n \n-/* The diagnostic message being formatted.  */\n-#define diagnostic_message(DC) (DC)->message\n-\n-/* A pointer to the variable argument list used in a call\n-   to a diagonstic routine.  */   \n-#define diagnostic_argument_list(DC) (DC)->args_ptr\n-\n-/* The program file to which the diagnostic is referring to.  */\n-#define diagnostic_file_location(DC) (DC)->file\n-\n-/* The program source line referred to in the diagnostic message.  */\n-#define diagnostic_line_location(DC) (DC)->line\n-\n-/* Tell whether the diagnostic message is to be treated as a warning.  */\n-#define diagnostic_is_warning(DC) (DC)->warn\n-\n /* Client supplied function to announce a diagnostic.  */\n #define diagnostic_starter(DC) (DC)->begin_diagnostic\n \n@@ -244,10 +236,25 @@ struct diagnostic_context\n    Zero means don't wrap lines.  */\n #define diagnostic_line_cutoff(DC) output_line_cutoff (&(DC)->buffer)\n \n-/* Same as output_buffer_state, but works on 'diagnostic_context *'.  */\n-#define diagnostic_state(DC)  output_buffer_state (&(DC)->buffer)\n+/* True if the last function in which a diagnostic was reported is\n+   different from the current one.  */\n+#define diagnostic_last_function_changed(DC) \\\n+  ((DC)->last_function != current_function_decl)\n+\n+/* Remember the current function as being the last one in which we report\n+   a diagnostic.  */\n+#define diagnostic_set_last_function(DC) \\\n+  (DC)->last_function = current_function_decl\n+\n+/* True if the last module or file in which a diagnostic was reported is\n+   different from the current one.  */\n+#define diagnostic_last_module_changed(DC) \\\n+  ((DC)->last_module != input_file_stack_tick)\n \n-#define diagnostic_buffer (&global_dc->buffer)\n+/* Remember the current module or file as being the last one in which we\n+   report a diagnostic.  */\n+#define diagnostic_set_last_module(DC) \\\n+  (DC)->last_module = input_file_stack_tick\n \n /* This diagnostic_context is used by front-ends that directly output\n    diagnostic messages without going through `error', `warning',\n@@ -270,18 +277,27 @@ extern diagnostic_context *global_dc;\n   (!inhibit_warnings\t\t\t\t\t\\\n    && !(in_system_header && !warn_system_headers))\n \n+#define report_diagnostic(D) diagnostic_report_diagnostic (global_dc, D)\n \n-/* Prototypes */\n-extern void set_diagnostic_context\tPARAMS ((diagnostic_context *,\n-\t\t\t\t\t\t const char *, va_list *,\n-\t\t\t\t\t\t const char *, int, int));\n-extern void report_diagnostic\t\tPARAMS ((diagnostic_context *));\n+/* Dignostic related functions.  */\n extern void diagnostic_initialize\tPARAMS ((diagnostic_context *));\n+extern void diagnostic_report_current_module PARAMS ((diagnostic_context *));\n+extern void diagnostic_report_current_function PARAMS ((diagnostic_context *));\n+extern void diagnostic_flush_buffer\tPARAMS ((diagnostic_context *));\n+extern bool diagnostic_count_error      PARAMS ((diagnostic_context *,\n+                                                 diagnostic_t));\n+extern void diagnostic_report_diagnostic PARAMS ((diagnostic_context *,\n+                                                 diagnostic_info *));\n+extern void diagnostic_set_info         PARAMS ((diagnostic_info *,\n+                                                 const char *, va_list *,\n+                                                 const char *, int,\n+                                                 diagnostic_t));\n+extern char *diagnostic_build_prefix    PARAMS ((diagnostic_info *));\n+\n+/* Pure text formatting support functions.  */\n extern void init_output_buffer\t\tPARAMS ((output_buffer *,\n \t\t\t\t\t\t const char *, int));\n-extern void flush_diagnostic_buffer\tPARAMS ((void));\n extern void output_clear\t\tPARAMS ((output_buffer *));\n-extern const char *output_get_prefix\tPARAMS ((const output_buffer *));\n extern const char *output_last_position PARAMS ((const output_buffer *));\n extern void output_set_prefix\t\tPARAMS ((output_buffer *,\n \t\t\t\t\t\t const char *));\n@@ -301,17 +317,10 @@ extern const char *output_finalize_message PARAMS ((output_buffer *));\n extern void output_clear_message_text\tPARAMS ((output_buffer *));\n extern void output_printf\t\tPARAMS ((output_buffer *, const char *,\n \t\t\t\t\t\t ...)) ATTRIBUTE_PRINTF_2;\n-extern int output_is_line_wrapping\tPARAMS ((output_buffer *));\n extern void output_verbatim\t\tPARAMS ((output_buffer *, const char *,\n \t\t\t\t\t\t ...)) ATTRIBUTE_PRINTF_2;\n extern void verbatim\t\t\tPARAMS ((const char *, ...))\n      ATTRIBUTE_PRINTF_1;\n-extern char *context_as_prefix\t\tPARAMS ((const char *, int, int));\n extern char *file_name_as_prefix\tPARAMS ((const char *));\n-extern int error_module_changed         PARAMS ((void));\n-extern void record_last_error_module\tPARAMS ((void));\n-extern int error_function_changed\tPARAMS ((void));\n-extern void record_last_error_function\tPARAMS ((void));\n-extern void report_problematic_module\tPARAMS ((output_buffer *));     \n \n #endif /* ! GCC_DIAGNOSTIC_H */"}, {"sha": "ecb8ff41c5ea02f0ac543ec6da871ff43da20ac8", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b69537e4bde3e38f988f163d46b81fcea84e0a/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b69537e4bde3e38f988f163d46b81fcea84e0a/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=47b69537e4bde3e38f988f163d46b81fcea84e0a", "patch": "@@ -1,3 +1,9 @@\n+2002-06-04  Gabriel Dos Reis  <gdr@codesourcery.com>\n+\n+\t* bad.c (ffebad_start_): Adjust call to count_error.\n+\t* Make-lang.in (f/bad.o): Depend on diagnostic.h\n+\t* bad.c: #include diagnostic.h\n+\n 2002-06-03  Geoffrey Keating  <geoffk@redhat.com>\n \n \t* Make-lang.in (f/com.o): Depend on debug.h."}, {"sha": "a64890bde9d571bc8be85e8425f2b38538035eab", "filename": "gcc/f/Make-lang.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b69537e4bde3e38f988f163d46b81fcea84e0a/gcc%2Ff%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b69537e4bde3e38f988f163d46b81fcea84e0a/gcc%2Ff%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FMake-lang.in?ref=47b69537e4bde3e38f988f163d46b81fcea84e0a", "patch": "@@ -352,7 +352,8 @@ f/bad.o: f/bad.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/bad.h f/bad.def f/where.h \\\n  glimits.h f/top.h f/malloc.h flags.h f/com.h f/com-rt.def $(TREE_H) f/bld.h \\\n  f/bld-op.def f/bit.h f/info.h f/info-b.def f/info-k.def f/info-w.def \\\n  f/target.h f/lex.h f/type.h f/intrin.h f/intrin.def f/lab.h f/symbol.h \\\n- f/symbol.def f/equiv.h f/storag.h f/global.h f/name.h toplev.h intl.h\n+ f/symbol.def f/equiv.h f/storag.h f/global.h f/name.h toplev.h intl.h \\\n+ diagnostic.h\n f/bit.o: f/bit.c f/proj.h $(CONFIG_H) $(SYSTEM_H) glimits.h f/bit.h \\\n  f/malloc.h\n f/bld.o: f/bld.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/bld.h f/bld-op.def f/bit.h \\"}, {"sha": "e30101f1e4ae9d2a7636849651a7f4a17d0b6208", "filename": "gcc/f/bad.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b69537e4bde3e38f988f163d46b81fcea84e0a/gcc%2Ff%2Fbad.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b69537e4bde3e38f988f163d46b81fcea84e0a/gcc%2Ff%2Fbad.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fbad.c?ref=47b69537e4bde3e38f988f163d46b81fcea84e0a", "patch": "@@ -43,6 +43,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"toplev.h\"\n #include \"where.h\"\n #include \"intl.h\"\n+#include \"diagnostic.h\"\n \n /* Externals defined here. */\n \n@@ -202,7 +203,7 @@ ffebad_start_ (bool lex_override, ffebad errnum, ffebadSeverity sev,\n       if ((ffebad_severity_ != FFEBAD_severityPEDANTIC)\n \t  || !flag_pedantic_errors)\n \t{\n-\t  if (count_error (1) == 0)\n+\t  if (!diagnostic_count_error (global_dc, DK_WARNING))\n \t    {\t\t\t/* User wants no warnings. */\n \t      ffebad_is_temp_inhibited_ = TRUE;\n \t      return FALSE;\n@@ -214,7 +215,7 @@ ffebad_start_ (bool lex_override, ffebad errnum, ffebadSeverity sev,\n     case FFEBAD_severityWEIRD:\n     case FFEBAD_severitySEVERE:\n     case FFEBAD_severityDISASTER:\n-      count_error (0);\n+      diagnostic_count_error (global_dc, DK_ERROR);\n       break;\n \n     default:\n@@ -420,7 +421,7 @@ ffebad_finish ()\n \t{\n \t  if (bi != 0)\n \t    fputc ('\\n', stderr);\n-\t  report_error_function (fn);\n+\t  diagnostic_report_current_function (global_dc);\n \t  fprintf (stderr,\n \t\t   /* the trailing space on the <file>:<line>: line\n \t\t      fools emacs19 compilation mode into finding the"}, {"sha": "efb11b022eae1469e93f892822c3513c366d8dcf", "filename": "gcc/objc/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b69537e4bde3e38f988f163d46b81fcea84e0a/gcc%2Fobjc%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b69537e4bde3e38f988f163d46b81fcea84e0a/gcc%2Fobjc%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FMake-lang.in?ref=47b69537e4bde3e38f988f163d46b81fcea84e0a", "patch": "@@ -90,7 +90,7 @@ $(srcdir)/objc/objc-parse.y: $(srcdir)/c-parse.in\n \n objc-act.o : $(srcdir)/objc/objc-act.c \\\n    $(CONFIG_H) $(TREE_H) $(RTL_H) $(SYSTEM_H) $(EXPR_H) $(TARGET_H) \\\n-   $(C_COMMON_H) $(srcdir)/c-tree.h \\\n+   $(C_COMMON_H) $(srcdir)/c-tree.h $(srcdir)/diagnostic.h \\\n    $(srcdir)/toplev.h $(srcdir)/flags.h $(srcdir)/objc/objc-act.h \\\n    $(srcdir)/input.h $(srcdir)/function.h $(srcdir)/output.h $(srcdir)/debug.h \\\n    $(srcdir)/langhooks.h $(LANGHOOKS_DEF_H) gtype-objc.h"}, {"sha": "cc4f67b29a5d789c241fa85894f5a2b700dfdb9b", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b69537e4bde3e38f988f163d46b81fcea84e0a/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b69537e4bde3e38f988f163d46b81fcea84e0a/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=47b69537e4bde3e38f988f163d46b81fcea84e0a", "patch": "@@ -56,6 +56,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"ggc.h\"\n #include \"debug.h\"\n #include \"target.h\"\n+#include \"diagnostic.h\"\n \n /* This is the default way of generating a method name.  */\n /* I am not sure it is really correct.\n@@ -3415,9 +3416,9 @@ error_with_ivar (message, decl, rawdecl)\n      tree decl;\n      tree rawdecl;\n {\n-  count_error (0);\n+  diagnostic_count_error (global_dc, DK_ERROR);\n \n-  report_error_function (DECL_SOURCE_FILE (decl));\n+  diagnostic_report_current_function (global_dc);\n \n   error_with_file_and_line (DECL_SOURCE_FILE (decl),\n \t\t\t    DECL_SOURCE_LINE (decl),\n@@ -6894,10 +6895,10 @@ warn_with_method (message, mtype, method)\n      int mtype;\n      tree method;\n {\n-  if (count_error (1) == 0)\n+  if (!diagnostic_count_error (global_dc, DK_WARNING))\n     return;\n \n-  report_error_function (DECL_SOURCE_FILE (method));\n+  diagnostic_report_current_function (global_dc);\n \n   /* Add a readable method name to the warning.  */\n   warning_with_file_and_line (DECL_SOURCE_FILE (method),"}, {"sha": "2b660c94fb7b1f9008b4378c3fd02702e3541b36", "filename": "gcc/rtl-error.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b69537e4bde3e38f988f163d46b81fcea84e0a/gcc%2Frtl-error.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b69537e4bde3e38f988f163d46b81fcea84e0a/gcc%2Frtl-error.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-error.c?ref=47b69537e4bde3e38f988f163d46b81fcea84e0a", "patch": "@@ -32,7 +32,8 @@ Boston, MA 02111-1307, USA.  */\n #include \"diagnostic.h\"\n \n static void file_and_line_for_asm PARAMS ((rtx, const char **, int *));\n-static void diagnostic_for_asm PARAMS ((rtx, const char *, va_list *, int));\n+static void diagnostic_for_asm PARAMS ((rtx, const char *, va_list *,\n+                                        diagnostic_t));\n \n /* Figure file and line of the given INSN.  */\n static void\n@@ -74,18 +75,18 @@ file_and_line_for_asm (insn, pfile, pline)\n    of the insn INSN.  This is used only when INSN is an `asm' with operands,\n    and each ASM_OPERANDS records its own source file and line.  */\n static void\n-diagnostic_for_asm (insn, msg, args_ptr, warn)\n+diagnostic_for_asm (insn, msg, args_ptr, kind)\n      rtx insn;\n      const char *msg;\n      va_list *args_ptr;\n-     int warn;\n+     diagnostic_t kind;\n {\n-  diagnostic_context dc;\n+  diagnostic_info diagnostic;\n \n-  set_diagnostic_context (&dc, msg, args_ptr, NULL, 0, warn);\n-  file_and_line_for_asm (insn, &diagnostic_file_location (&dc),\n-\t\t\t &diagnostic_line_location (&dc));\n-  report_diagnostic (&dc);\n+  diagnostic_set_info (&diagnostic, msg, args_ptr, NULL, 0, kind);\n+  file_and_line_for_asm (insn, &diagnostic.location.file,\n+                         &diagnostic.location.line);\n+  report_diagnostic (&diagnostic);\n }\n \n void\n@@ -95,7 +96,7 @@ error_for_asm VPARAMS ((rtx insn, const char *msgid, ...))\n   VA_FIXEDARG (ap, rtx, insn);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  diagnostic_for_asm (insn, msgid, &ap, /* warn = */ 0);\n+  diagnostic_for_asm (insn, msgid, &ap, DK_ERROR);\n   VA_CLOSE (ap);\n }\n \n@@ -106,7 +107,7 @@ warning_for_asm VPARAMS ((rtx insn, const char *msgid, ...))\n   VA_FIXEDARG (ap, rtx, insn);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  diagnostic_for_asm (insn, msgid, &ap, /* warn = */ 1);\n+  diagnostic_for_asm (insn, msgid, &ap, DK_WARNING);\n   VA_CLOSE (ap);\n }\n "}, {"sha": "24deaaee8ec3859128fef3b748caaa2d41feda6d", "filename": "gcc/toplev.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b69537e4bde3e38f988f163d46b81fcea84e0a/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b69537e4bde3e38f988f163d46b81fcea84e0a/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=47b69537e4bde3e38f988f163d46b81fcea84e0a", "patch": "@@ -29,7 +29,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n extern int toplev_main\t\t\tPARAMS ((int, char **));\n extern int read_integral_parameter\tPARAMS ((const char *, const char *,\n \t\t\t\t\t\tconst int));\n-extern int count_error\t\t\tPARAMS ((int));\n extern void strip_off_ending\t\tPARAMS ((char *, int));\n extern void print_time\t\t\tPARAMS ((const char *, long));\n extern const char *trim_filename\tPARAMS ((const char *));\n@@ -67,7 +66,6 @@ extern void warning_with_file_and_line\tPARAMS ((const char *, int,\n extern void error_with_file_and_line\tPARAMS ((const char *, int,\n \t\t\t\t\t\t const char *, ...));\n extern void sorry\t\t\tPARAMS ((const char *, ...));\n-extern void report_error_function\tPARAMS ((const char *));\n \n extern void rest_of_decl_compilation\tPARAMS ((union tree_node *,\n \t\t\t\t\t\tconst char *, int, int));"}]}