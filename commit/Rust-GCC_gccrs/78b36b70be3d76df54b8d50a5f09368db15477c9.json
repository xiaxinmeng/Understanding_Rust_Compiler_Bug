{"sha": "78b36b70be3d76df54b8d50a5f09368db15477c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhiMzZiNzBiZTNkNzZkZjU0YjhkNTBhNWYwOTM2OGRiMTU0NzdjOQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2007-10-04T15:12:34Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2007-10-04T15:12:34Z"}, "message": "[multiple changes]\n\n2007-10-04  Paolo Carlini  <pcarlini@suse.de>\n\n\t* testsuite/23_containers/vector/requirements/dr438/assign_neg.cc:\n\tAdjust dg-error line number.\n\t* testsuite/23_containers/vector/requirements/dr438/insert_neg.cc:\n\tLikewise.\n\t* testsuite/23_containers/vector/requirements/dr438/\n\tconstructor_1_neg.cc: Likewise.\n\t* testsuite/23_containers/vector/requirements/dr438/\n\tconstructor_2_neg.cc: Likewise.\n\t* testsuite/23_containers/deque/requirements/dr438/assign_neg.cc:\n\tAdjust dg-error line number.\n\t* testsuite/23_containers/deque/requirements/dr438/insert_neg.cc:\n\tLikewise.\n\t* testsuite/23_containers/deque/requirements/dr438/\n\tconstructor_1_neg.cc: Likewise.\n\t* testsuite/23_containers/deque/requirements/dr438/\n\tconstructor_2_neg.cc: Likewise.\n\t* testsuite/23_containers/list/requirements/dr438/assign_neg.cc:\n\tAdjust dg-error line number.\n\t* testsuite/23_containers/list/requirements/dr438/insert_neg.cc:\n\tLikewise.\n\t* testsuite/23_containers/list/requirements/dr438/\n\tconstructor_1_neg.cc: Likewise.\n\t* testsuite/23_containers/list/requirements/dr438/\n\tconstructor_2_neg.cc: Likewise.\n\n2007-10-04  Chris Jefferson  <chris@bubblescope.net>\n\t    Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/stl_list.h (list<>::list(list&&),\n\tlist<>::operator=(list&&)): Add.\n\t(list<>::swap): Adjust.\n\t(swap(list&&, list& __y), swap(list&, list&& __y)): Add.\n\t* include/bits/stl_vector.h (vector<>::vector(vector&&),\n\tvector<>::operator=(vector&&)): Add.\n\t(vector<>::swap): Adjust.\n\t(swap(vector&&, vector& __y), swap(vector&, vector&& __y)): Add.\n\t* include/bits/stl_bvector.h (vector<>::vector(vector&&),\n\tvector<>::operator=(vector&&)): Add.\n\t(vector<>::swap): Adjust.\n\t* include/bits/stl_deque.h (deque<>::deque(deque&&),\n\tdeque<>::operator=(deque&&)): Add.\n\t(deque<>::swap): Adjust.\n\t(swap(deque&&, deque& __y), swap(deque&, deque&& __y)): Add.\n\t* include/bits/stl_set.h (set<>::set(set&&),\n\tset<>::operator=(set&&)): Add.\n\t(set<>::swap): Adjust.\n\t(swap(set&&, set& __y), swap(set&, set&& __y)): Add.\n\t* include/bits/stl_map.h (map<>::map(map&&),\n\tmap<>::operator=(map&&)): Add.\n\t(map<>::swap): Adjust.\n\t(swap(map&&, map& __y), swap(map&, map&& __y)): Add.\n\t* include/bits/stl_multiset.h (multiset<>::multiset(multiset&&),\n\tmultiset<>::operator=(multiset&&)): Add.\n\t(smultiet<>::swap): Adjust.\n\t(swap(multiset&&, multiset& __y),\n\tswap(multiset&, multiset&& __y)): Add.\n\t* include/bits/stl_multimap.h (multimap<>::multimap(multimap&&),\n\tmultimap<>::operator=(multimap&&)): Add.\n\t(multimap<>::swap): Adjust.\n\t(swap(multimap&&, multimap& __y),\n\tswap(multimap&, multimap&& __y)): Add.\n\n2007-10-04  Paolo Carlini  <pcarlini@suse.de>\n\n\tAvoid copying some allocator objects.\n\t* include/bits/stl_list.h (_List_impl::_List_impl(),\n\t_List_base::_List_base(), list<>::list()): Add.\n\t* include/bits/stl_vector.h  (_Vector_impl::_Vector_impl(),\n\t_Vector_base::_Vector_base(), vector<>::vector()): Add.\n\t* include/bits/stl_bvector.h (_Bvector_impl::_Bvector_impl(),\n\t_Bvector_base::_Bvector_base(), vector<>::vector()): Add.\n\t* include/bits/stl_deque.h  (_Deque_impl::_Deque_impl(),\n\t_Deque_base::_Deque_base(), deque<>::deque()): Add.\n\t* include/bits/stl_tree.h (_Rb_tree_impl<>::_Rb_tree_impl(),\n\t_Rb_tree_impl<>::_M_initialize): Add.\n\t(_Rb_tree<>::_Rb_tree(const _Compare&, const allocator_type&),\n\t_Rb_tree(const _Rb_tree&)): Adjust.\n\t* include/bits/stl_set.h (set<>::set(),\n\tset(_InputIterator, _InputIterator)): Use _M_t default constructor. \n\t* include/bits/stl_map.h (map<>::map(), set(_InputIterator,\n\t_InputIterator)): Use _M_t default constructor. \n\t* include/bits/stl_multiset.h (multiset<>::multiset(),\n\tmultiset(_InputIterator, _InputIterator)): Use _M_t default\n\tconstructor. \n\t* include/bits/stl_multimap.h (multimap<>::multimap(),\n\tmultimap(_InputIterator, _InputIterator)): Use _M_t default\n\tconstructor.\n\nFrom-SVN: r129013", "tree": {"sha": "069a64e945b585943cd42f5fb19ab939aaf5ee19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/069a64e945b585943cd42f5fb19ab939aaf5ee19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78b36b70be3d76df54b8d50a5f09368db15477c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78b36b70be3d76df54b8d50a5f09368db15477c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78b36b70be3d76df54b8d50a5f09368db15477c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78b36b70be3d76df54b8d50a5f09368db15477c9/comments", "author": null, "committer": null, "parents": [{"sha": "187de1ed2b3bc56e13db1fda4751d2dd86caf38c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/187de1ed2b3bc56e13db1fda4751d2dd86caf38c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/187de1ed2b3bc56e13db1fda4751d2dd86caf38c"}], "stats": {"total": 834, "additions": 680, "deletions": 154}, "files": [{"sha": "d02e6026ede1a224955a8029e8459936fc5c7f15", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=78b36b70be3d76df54b8d50a5f09368db15477c9", "patch": "@@ -1,3 +1,93 @@\n+2007-10-04  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* testsuite/23_containers/vector/requirements/dr438/assign_neg.cc:\n+\tAdjust dg-error line number.\n+\t* testsuite/23_containers/vector/requirements/dr438/insert_neg.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/vector/requirements/dr438/\n+\tconstructor_1_neg.cc: Likewise.\n+\t* testsuite/23_containers/vector/requirements/dr438/\n+\tconstructor_2_neg.cc: Likewise.\n+\t* testsuite/23_containers/deque/requirements/dr438/assign_neg.cc:\n+\tAdjust dg-error line number.\n+\t* testsuite/23_containers/deque/requirements/dr438/insert_neg.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/deque/requirements/dr438/\n+\tconstructor_1_neg.cc: Likewise.\n+\t* testsuite/23_containers/deque/requirements/dr438/\n+\tconstructor_2_neg.cc: Likewise.\n+\t* testsuite/23_containers/list/requirements/dr438/assign_neg.cc:\n+\tAdjust dg-error line number.\n+\t* testsuite/23_containers/list/requirements/dr438/insert_neg.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/list/requirements/dr438/\n+\tconstructor_1_neg.cc: Likewise.\n+\t* testsuite/23_containers/list/requirements/dr438/\n+\tconstructor_2_neg.cc: Likewise.\n+\n+2007-10-04  Chris Jefferson  <chris@bubblescope.net>\n+\t    Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/stl_list.h (list<>::list(list&&),\n+\tlist<>::operator=(list&&)): Add.\n+\t(list<>::swap): Adjust.\n+\t(swap(list&&, list& __y), swap(list&, list&& __y)): Add.\n+\t* include/bits/stl_vector.h (vector<>::vector(vector&&),\n+\tvector<>::operator=(vector&&)): Add.\n+\t(vector<>::swap): Adjust.\n+\t(swap(vector&&, vector& __y), swap(vector&, vector&& __y)): Add.\n+\t* include/bits/stl_bvector.h (vector<>::vector(vector&&),\n+\tvector<>::operator=(vector&&)): Add.\n+\t(vector<>::swap): Adjust.\n+\t* include/bits/stl_deque.h (deque<>::deque(deque&&),\n+\tdeque<>::operator=(deque&&)): Add.\n+\t(deque<>::swap): Adjust.\n+\t(swap(deque&&, deque& __y), swap(deque&, deque&& __y)): Add.\n+\t* include/bits/stl_set.h (set<>::set(set&&),\n+\tset<>::operator=(set&&)): Add.\n+\t(set<>::swap): Adjust.\n+\t(swap(set&&, set& __y), swap(set&, set&& __y)): Add.\n+\t* include/bits/stl_map.h (map<>::map(map&&),\n+\tmap<>::operator=(map&&)): Add.\n+\t(map<>::swap): Adjust.\n+\t(swap(map&&, map& __y), swap(map&, map&& __y)): Add.\n+\t* include/bits/stl_multiset.h (multiset<>::multiset(multiset&&),\n+\tmultiset<>::operator=(multiset&&)): Add.\n+\t(smultiet<>::swap): Adjust.\n+\t(swap(multiset&&, multiset& __y),\n+\tswap(multiset&, multiset&& __y)): Add.\n+\t* include/bits/stl_multimap.h (multimap<>::multimap(multimap&&),\n+\tmultimap<>::operator=(multimap&&)): Add.\n+\t(multimap<>::swap): Adjust.\n+\t(swap(multimap&&, multimap& __y),\n+\tswap(multimap&, multimap&& __y)): Add.\n+\n+2007-10-04  Paolo Carlini  <pcarlini@suse.de>\n+\n+\tAvoid copying some allocator objects.\n+\t* include/bits/stl_list.h (_List_impl::_List_impl(),\n+\t_List_base::_List_base(), list<>::list()): Add.\n+\t* include/bits/stl_vector.h  (_Vector_impl::_Vector_impl(),\n+\t_Vector_base::_Vector_base(), vector<>::vector()): Add.\n+\t* include/bits/stl_bvector.h (_Bvector_impl::_Bvector_impl(),\n+\t_Bvector_base::_Bvector_base(), vector<>::vector()): Add.\n+\t* include/bits/stl_deque.h  (_Deque_impl::_Deque_impl(),\n+\t_Deque_base::_Deque_base(), deque<>::deque()): Add.\n+\t* include/bits/stl_tree.h (_Rb_tree_impl<>::_Rb_tree_impl(),\n+\t_Rb_tree_impl<>::_M_initialize): Add.\n+\t(_Rb_tree<>::_Rb_tree(const _Compare&, const allocator_type&),\n+\t_Rb_tree(const _Rb_tree&)): Adjust.\n+\t* include/bits/stl_set.h (set<>::set(),\n+\tset(_InputIterator, _InputIterator)): Use _M_t default constructor. \n+\t* include/bits/stl_map.h (map<>::map(), set(_InputIterator,\n+\t_InputIterator)): Use _M_t default constructor. \n+\t* include/bits/stl_multiset.h (multiset<>::multiset(),\n+\tmultiset(_InputIterator, _InputIterator)): Use _M_t default\n+\tconstructor. \n+\t* include/bits/stl_multimap.h (multimap<>::multimap(),\n+\tmultimap(_InputIterator, _InputIterator)): Use _M_t default\n+\tconstructor.\n+\n 2007-10-03  Chris Jefferson  <chris@bubblescope.net>\n \t    Benjamin Kosnik  <bkoz@redhat.com>\n "}, {"sha": "db9061b90fb528562617ce5220c082ba0c82f8cd", "filename": "libstdc++-v3/include/bits/stl_bvector.h", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h?ref=78b36b70be3d76df54b8d50a5f09368db15477c9", "patch": "@@ -385,6 +385,11 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \t_Bit_iterator \t_M_start;\n \t_Bit_iterator \t_M_finish;\n \t_Bit_type* \t_M_end_of_storage;\n+\n+\t_Bvector_impl()\n+\t: _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage(0)\n+\t{ }\n+ \n \t_Bvector_impl(const _Bit_alloc_type& __a)\n \t: _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0)\n \t{ }\n@@ -405,7 +410,11 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       get_allocator() const\n       { return allocator_type(_M_get_Bit_allocator()); }\n \n-      _Bvector_base(const allocator_type& __a) : _M_impl(__a) { }\n+      _Bvector_base()\n+      : _M_impl() { }\n+      \n+      _Bvector_base(const allocator_type& __a)\n+      : _M_impl(__a) { }\n \n       ~_Bvector_base()\n       { this->_M_deallocate(); }\n@@ -480,8 +489,11 @@ template<typename _Alloc>\n     using _Base::_M_get_Bit_allocator;\n \n   public:\n+    vector()\n+    : _Base() { }\n+\n     explicit\n-    vector(const allocator_type& __a = allocator_type())\n+    vector(const allocator_type& __a)\n     : _Base(__a) { }\n \n     explicit\n@@ -501,6 +513,12 @@ template<typename _Alloc>\n       _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);\n     }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+    vector(vector&& __x)\n+    : _Base(__x._M_get_Bit_allocator())\n+    { this->swap(__x); }\n+#endif\n+\n     template<typename _InputIterator>\n       vector(_InputIterator __first, _InputIterator __last,\n \t     const allocator_type& __a = allocator_type())\n@@ -527,6 +545,15 @@ template<typename _Alloc>\n       return *this;\n     }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+    vector&\n+    operator=(vector&& __x)\n+    { \n+      this->swap(__x); \n+      return *this;\n+    }\n+#endif\n+\n     // assign(), a generalized assignment member function.  Two\n     // versions: one that takes a count, and one that takes a range.\n     // The range version is a member template, so we dispatch on whether\n@@ -681,7 +708,11 @@ template<typename _Alloc>\n     }\n \n     void\n-    swap(vector<bool, _Alloc>& __x)\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+    swap(vector&& __x)\n+#else\n+    swap(vector& __x)\n+#endif\n     {\n       std::swap(this->_M_impl._M_start, __x._M_impl._M_start);\n       std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);"}, {"sha": "7a7b86e2d38ee6e5bb8852d8c88f991a184ad454", "filename": "libstdc++-v3/include/bits/stl_deque.h", "status": "modified", "additions": 70, "deletions": 6, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h?ref=78b36b70be3d76df54b8d50a5f09368db15477c9", "patch": "@@ -123,13 +123,14 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \n       _Deque_iterator(_Tp* __x, _Map_pointer __y)\n       : _M_cur(__x), _M_first(*__y),\n-        _M_last(*__y + _S_buffer_size()), _M_node(__y) {}\n+        _M_last(*__y + _S_buffer_size()), _M_node(__y) { }\n \n-      _Deque_iterator() : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) {}\n+      _Deque_iterator()\n+      : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) { }\n \n       _Deque_iterator(const iterator& __x)\n       : _M_cur(__x._M_cur), _M_first(__x._M_first),\n-        _M_last(__x._M_last), _M_node(__x._M_node) {}\n+        _M_last(__x._M_last), _M_node(__x._M_node) { }\n \n       reference\n       operator*() const\n@@ -380,6 +381,10 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       typedef _Deque_iterator<_Tp, _Tp&, _Tp*>             iterator;\n       typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;\n \n+      _Deque_base()\n+      : _M_impl()\n+      { _M_initialize_map(0); }\n+\n       _Deque_base(const allocator_type& __a, size_t __num_elements)\n       : _M_impl(__a)\n       { _M_initialize_map(__num_elements); }\n@@ -406,6 +411,11 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \titerator _M_start;\n \titerator _M_finish;\n \n+\t_Deque_impl()\n+\t: _Tp_alloc_type(), _M_map(0), _M_map_size(0),\n+\t  _M_start(), _M_finish()\n+\t{ }\n+\n \t_Deque_impl(const _Tp_alloc_type& __a)\n \t: _Tp_alloc_type(__a), _M_map(0), _M_map_size(0),\n \t  _M_start(), _M_finish()\n@@ -679,14 +689,22 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       /**\n        *  @brief  Default constructor creates no elements.\n        */\n+      deque()\n+      : _Base() { }\n+\n+      /**\n+       *  @brief  Creates a %deque with no elements.\n+       *  @param  a  An allocator object.\n+       */\n       explicit\n-      deque(const allocator_type& __a = allocator_type())\n-      : _Base(__a, 0) {}\n+      deque(const allocator_type& __a)\n+      : _Base(__a, 0) { }\n \n       /**\n-       *  @brief  Create a %deque with copies of an exemplar element.\n+       *  @brief  Creates a %deque with copies of an exemplar element.\n        *  @param  n  The number of elements to initially create.\n        *  @param  value  An element to copy.\n+       *  @param  a  An allocator.\n        *\n        *  This constructor fills the %deque with @a n copies of @a value.\n        */\n@@ -709,10 +727,24 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \t\t\t\t    this->_M_impl._M_start,\n \t\t\t\t    _M_get_Tp_allocator()); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      /**\n+       *  @brief  %Deque move constructor.\n+       *  @param  x  A %deque of identical element and allocator types.\n+       *\n+       *  The newly-created %deque contains the exact contents of @a x.\n+       *  The contents of @a x are a valid, but unspecified %deque.\n+       */\n+      deque(deque&&  __x)\n+      : _Base(__x._M_get_Tp_allocator(), 0)\n+      { this->swap(__x); }\n+#endif\n+\n       /**\n        *  @brief  Builds a %deque from a range.\n        *  @param  first  An input iterator.\n        *  @param  last  An input iterator.\n+       *  @param  a  An allocator object.\n        *\n        *  Create a %deque consisting of copies of the elements from [first,\n        *  last).\n@@ -751,6 +783,22 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       deque&\n       operator=(const deque& __x);\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      /**\n+       *  @brief  %Deque move assignment operator.\n+       *  @param  x  A %deque of identical element and allocator types.\n+       *\n+       *  The contents of @a x are moved into this deque (without copying).\n+       *  @a x is a valid, but unspecified %deque.\n+       */\n+      deque&\n+      operator=(deque&& __x)\n+      {\n+\tthis->swap(__x); \n+\treturn *this;\n+      }\n+#endif\n+\n       /**\n        *  @brief  Assigns a given value to a %deque.\n        *  @param  n  Number of elements to be assigned.\n@@ -1194,7 +1242,11 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n        *  std::swap(d1,d2) will feed to this function.\n        */\n       void\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      swap(deque&& __x)\n+#else\n       swap(deque& __x)\n+#endif\n       {\n \tstd::swap(this->_M_impl._M_start, __x._M_impl._M_start);\n \tstd::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);\n@@ -1598,6 +1650,18 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n     swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y)\n     { __x.swap(__y); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+  template<typename _Tp, typename _Alloc>\n+    inline void\n+    swap(deque<_Tp,_Alloc>&& __x, deque<_Tp,_Alloc>& __y)\n+    { __x.swap(__y); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline void\n+    swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>&& __y)\n+    { __x.swap(__y); }\n+#endif\n+\n _GLIBCXX_END_NESTED_NAMESPACE\n \n #endif /* _STL_DEQUE_H */"}, {"sha": "2b690eb54867dbf8a4cbd2a50278fb2eb24cde17", "filename": "libstdc++-v3/include/bits/stl_list.h", "status": "modified", "additions": 64, "deletions": 3, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h?ref=78b36b70be3d76df54b8d50a5f09368db15477c9", "patch": "@@ -305,6 +305,10 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       {\n \t_List_node_base _M_node;\n \n+\t_List_impl()\n+\t: _Node_alloc_type(), _M_node()\n+\t{ }\n+\n \t_List_impl(const _Node_alloc_type& __a)\n \t: _Node_alloc_type(__a), _M_node()\n \t{ }\n@@ -339,6 +343,10 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       get_allocator() const\n       { return allocator_type(_M_get_Node_allocator()); }\n \n+      _List_base()\n+      : _M_impl()\n+      { _M_init(); }\n+\n       _List_base(const allocator_type& __a)\n       : _M_impl(__a)\n       { _M_init(); }\n@@ -468,14 +476,22 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       /**\n        *  @brief  Default constructor creates no elements.\n        */\n+      list()\n+      : _Base() { }\n+\n+      /**\n+       *  @brief  Creates a %list with no elements.\n+       *  @param  a  An allocator object.\n+       */\n       explicit\n-      list(const allocator_type& __a = allocator_type())\n+      list(const allocator_type& __a)\n       : _Base(__a) { }\n \n       /**\n-       *  @brief  Create a %list with copies of an exemplar element.\n+       *  @brief  Creates a %list with copies of an exemplar element.\n        *  @param  n  The number of elements to initially create.\n        *  @param  value  An element to copy.\n+       *  @param  a  An allocator object.\n        *\n        *  This constructor fills the %list with @a n copies of @a value.\n        */\n@@ -496,10 +512,24 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       : _Base(__x._M_get_Node_allocator())\n       { _M_initialize_dispatch(__x.begin(), __x.end(), __false_type()); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      /**\n+       *  @brief  %List move constructor.\n+       *  @param  x  A %list of identical element and allocator types.\n+       *\n+       *  The newly-created %list contains the exact contents of @a x.\n+       *  The contents of @a x are a valid, but unspecified %list.\n+       */\n+      list(list&& __x)\n+      : _Base(__x._M_get_Node_allocator())\n+      { this->swap(__x); }\n+#endif\n+\n       /**\n        *  @brief  Builds a %list from a range.\n        *  @param  first  An input iterator.\n        *  @param  last  An input iterator.\n+       *  @param  a  An allocator object.\n        *\n        *  Create a %list consisting of copies of the elements from\n        *  [@a first,@a last).  This is linear in N (where N is\n@@ -533,6 +563,22 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       list&\n       operator=(const list& __x);\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      /**\n+       *  @brief  %List move assignment operator.\n+       *  @param  x  A %list of identical element and allocator types.\n+       *\n+       *  The contents of @a x are moved into this %list (without copying).\n+       *  @a x is a valid, but unspecified %list\n+       */\n+      list&\n+      operator=(list&& __x)\n+      {\n+\tthis->swap(__x); \n+\treturn *this;\n+      }\n+#endif\n+\n       /**\n        *  @brief  Assigns a given value to a %list.\n        *  @param  n  Number of elements to be assigned.\n@@ -887,7 +933,11 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n        *  function.\n        */\n       void\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      swap(list&& __x)\n+#else\n       swap(list& __x)\n+#endif\n       {\n \t_List_node_base::swap(this->_M_impl._M_node, __x._M_impl._M_node);\n \n@@ -1256,7 +1306,18 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n     swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)\n     { __x.swap(__y); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+  template<typename _Tp, typename _Alloc>\n+    inline void\n+    swap(list<_Tp, _Alloc>&& __x, list<_Tp, _Alloc>& __y)\n+    { __x.swap(__y); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline void\n+    swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>&& __y)\n+    { __x.swap(__y); }\n+#endif\n+\n _GLIBCXX_END_NESTED_NAMESPACE\n \n #endif /* _STL_LIST_H */\n-"}, {"sha": "f4545a02d4e0df0d445d1bcc46c68a7db24589b2", "filename": "libstdc++-v3/include/bits/stl_map.h", "status": "modified", "additions": 77, "deletions": 26, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h?ref=78b36b70be3d76df54b8d50a5f09368db15477c9", "patch": "@@ -155,26 +155,42 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n        *  @brief  Default constructor creates no elements.\n        */\n       map()\n-      : _M_t(_Compare(), allocator_type()) { }\n+      : _M_t() { }\n \n-      // for some reason this was made a separate function\n       /**\n-       *  @brief  Default constructor creates no elements.\n+       *  @brief  Creates a %map with no elements.\n+       *  @param  comp  A comparison object.\n+       *  @param  a  An allocator object.\n        */\n       explicit\n-      map(const _Compare& __comp, const allocator_type& __a = allocator_type())\n+      map(const _Compare& __comp,\n+\t  const allocator_type& __a = allocator_type())\n       : _M_t(__comp, __a) { }\n \n       /**\n-       *  @brief  Map copy constructor.\n+       *  @brief  %Map copy constructor.\n        *  @param  x  A %map of identical element and allocator types.\n        *\n-       *  The newly-created %map uses a copy of the allocation object used\n-       *  by @a x.\n+       *  The newly-created %map uses a copy of the allocation object\n+       *  used by @a x.\n        */\n       map(const map& __x)\n       : _M_t(__x._M_t) { }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      /**\n+       *  @brief  %Map move constructor.\n+       *  @param  x  A %map of identical element and allocator types.\n+       *\n+       *  The newly-created %map contains the exact contents of @a x.\n+       *  The contents of @a x are a valid, but unspecified %map.\n+       */\n+      map(map&& __x)\n+      : _M_t(__x._M_t.key_comp(),\n+\t     __x._M_t._M_get_Node_allocator())\n+      { this->swap(__x); }\n+#endif\n+\n       /**\n        *  @brief  Builds a %map from a range.\n        *  @param  first  An input iterator.\n@@ -184,9 +200,9 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n        *  This is linear in N if the range is already sorted, and NlogN\n        *  otherwise (where N is distance(first,last)).\n        */\n-      template <typename _InputIterator>\n+      template<typename _InputIterator>\n         map(_InputIterator __first, _InputIterator __last)\n-\t: _M_t(_Compare(), allocator_type())\n+\t: _M_t()\n         { _M_t._M_insert_unique(__first, __last); }\n \n       /**\n@@ -200,9 +216,10 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n        *  This is linear in N if the range is already sorted, and NlogN\n        *  otherwise (where N is distance(first,last)).\n        */\n-      template <typename _InputIterator>\n+      template<typename _InputIterator>\n         map(_InputIterator __first, _InputIterator __last,\n-\t    const _Compare& __comp, const allocator_type& __a = allocator_type())\n+\t    const _Compare& __comp,\n+\t    const allocator_type& __a = allocator_type())\n \t: _M_t(__comp, __a)\n         { _M_t._M_insert_unique(__first, __last); }\n \n@@ -216,7 +233,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n        */\n \n       /**\n-       *  @brief  Map assignment operator.\n+       *  @brief  %Map assignment operator.\n        *  @param  x  A %map of identical element and allocator types.\n        *\n        *  All the elements of @a x are copied, but unlike the copy constructor,\n@@ -229,6 +246,22 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \treturn *this;\n       }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      /**\n+       *  @brief  %Map move assignment operator.\n+       *  @param  x  A %map of identical element and allocator types.\n+       *\n+       *  The contents of @a x are moved into this map (without copying).\n+       *  @a x is a valid, but unspecified %map.\n+       */\n+      map&\n+      operator=(map&& __x)\n+      {\n+\tthis->swap(__x); \n+\treturn *this;\n+      }\n+#endif\n+\n       /// Get a copy of the memory allocation object.\n       allocator_type\n       get_allocator() const\n@@ -434,7 +467,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n        *\n        *  Complexity similar to that of the range constructor.\n        */\n-      template <typename _InputIterator>\n+      template<typename _InputIterator>\n         void\n         insert(_InputIterator __first, _InputIterator __last)\n         { _M_t._M_insert_unique(__first, __last); }\n@@ -495,7 +528,11 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n        *  that std::swap(m1,m2) will feed to this function.\n        */\n       void\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      swap(map&& __x)\n+#else\n       swap(map& __x)\n+#endif\n       { _M_t.swap(__x._M_t); }\n \n       /**\n@@ -656,15 +693,15 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       equal_range(const key_type& __x) const\n       { return _M_t.equal_range(__x); }\n \n-      template <typename _K1, typename _T1, typename _C1, typename _A1>\n+      template<typename _K1, typename _T1, typename _C1, typename _A1>\n         friend bool\n-        operator== (const map<_K1, _T1, _C1, _A1>&,\n-\t\t    const map<_K1, _T1, _C1, _A1>&);\n+        operator==(const map<_K1, _T1, _C1, _A1>&,\n+\t\t   const map<_K1, _T1, _C1, _A1>&);\n \n-      template <typename _K1, typename _T1, typename _C1, typename _A1>\n+      template<typename _K1, typename _T1, typename _C1, typename _A1>\n         friend bool\n-        operator< (const map<_K1, _T1, _C1, _A1>&,\n-\t\t   const map<_K1, _T1, _C1, _A1>&);\n+        operator<(const map<_K1, _T1, _C1, _A1>&,\n+\t\t  const map<_K1, _T1, _C1, _A1>&);\n     };\n \n   /**\n@@ -677,7 +714,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n    *  maps.  Maps are considered equivalent if their sizes are equal,\n    *  and if corresponding elements compare equal.\n   */\n-  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n                const map<_Key, _Tp, _Compare, _Alloc>& __y)\n@@ -694,47 +731,61 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n    *\n    *  See std::lexicographical_compare() for how the determination is made.\n   */\n-  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator<(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n               const map<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return __x._M_t < __y._M_t; }\n \n   /// Based on operator==\n-  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator!=(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n                const map<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return !(__x == __y); }\n \n   /// Based on operator<\n-  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n               const map<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return __y < __x; }\n \n   /// Based on operator<\n-  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator<=(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n                const map<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return !(__y < __x); }\n \n   /// Based on operator<\n-  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator>=(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n                const map<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return !(__x < __y); }\n \n   /// See std::map::swap().\n-  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline void\n     swap(map<_Key, _Tp, _Compare, _Alloc>& __x,\n \t map<_Key, _Tp, _Compare, _Alloc>& __y)\n     { __x.swap(__y); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+    inline void\n+    swap(map<_Key, _Tp, _Compare, _Alloc>&& __x,\n+\t map<_Key, _Tp, _Compare, _Alloc>& __y)\n+    { __x.swap(__y); }\n+\n+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+    inline void\n+    swap(map<_Key, _Tp, _Compare, _Alloc>& __x,\n+\t map<_Key, _Tp, _Compare, _Alloc>&& __y)\n+    { __x.swap(__y); }\n+#endif\n+\n _GLIBCXX_END_NESTED_NAMESPACE\n \n #endif /* _STL_MAP_H */"}, {"sha": "864f4b21bbe8140113469df5d2c8cee4a67899a6", "filename": "libstdc++-v3/include/bits/stl_multimap.h", "status": "modified", "additions": 72, "deletions": 23, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h?ref=78b36b70be3d76df54b8d50a5f09368db15477c9", "patch": "@@ -153,11 +153,12 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n        *  @brief  Default constructor creates no elements.\n        */\n       multimap()\n-      : _M_t(_Compare(), allocator_type()) { }\n+      : _M_t() { }\n \n-      // for some reason this was made a separate function\n       /**\n-       *  @brief  Default constructor creates no elements.\n+       *  @brief  Creates a %multimap with no elements.\n+       *  @param  comp  A comparison object.\n+       *  @param  a  An allocator object.\n        */\n       explicit\n       multimap(const _Compare& __comp,\n@@ -168,12 +169,26 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n        *  @brief  %Multimap copy constructor.\n        *  @param  x  A %multimap of identical element and allocator types.\n        *\n-       *  The newly-created %multimap uses a copy of the allocation object used\n-       *  by @a x.\n+       *  The newly-created %multimap uses a copy of the allocation object\n+       *  used by @a x.\n        */\n       multimap(const multimap& __x)\n       : _M_t(__x._M_t) { }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      /**\n+       *  @brief  %Multimap move constructor.\n+       *  @param   x  A %multimap of identical element and allocator types.\n+       *\n+       *  The newly-created %multimap contains the exact contents of @a x.\n+       *  The contents of @a x are a valid, but unspecified %multimap.\n+       */\n+      multimap(multimap&& __x)\n+      : _M_t(__x._M_t.key_comp(),\n+\t     __x._M_t._M_get_Node_allocator())\n+      { this->swap(__x); }\n+#endif\n+\n       /**\n        *  @brief  Builds a %multimap from a range.\n        *  @param  first  An input iterator.\n@@ -183,10 +198,10 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n        *  [first,last).  This is linear in N if the range is already sorted,\n        *  and NlogN otherwise (where N is distance(first,last)).\n        */\n-      template <typename _InputIterator>\n+      template<typename _InputIterator>\n         multimap(_InputIterator __first, _InputIterator __last)\n-\t: _M_t(_Compare(), allocator_type())\n-        { _M_t._M_insert_equal(__first, __last); }\n+\t: _M_t()\n+        { _M_t._M_insert_unique(__first, __last); }\n \n       /**\n        *  @brief  Builds a %multimap from a range.\n@@ -199,7 +214,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n        *  [first,last).  This is linear in N if the range is already sorted,\n        *  and NlogN otherwise (where N is distance(first,last)).\n        */\n-      template <typename _InputIterator>\n+      template<typename _InputIterator>\n         multimap(_InputIterator __first, _InputIterator __last,\n \t\t const _Compare& __comp,\n \t\t const allocator_type& __a = allocator_type())\n@@ -229,6 +244,22 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \treturn *this;\n       }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      /**\n+       *  @brief  %Multimap move assignment operator.\n+       *  @param  x  A %multimap of identical element and allocator types.\n+       *\n+       *  The contents of @a x are moved into this multimap (without copying).\n+       *  @a x is a valid, but unspecified multimap.\n+       */\n+      multimap&\n+      operator=(multimap&& __x)\n+      {\n+\tthis->swap(__x); \n+\treturn *this;\n+      }\n+#endif\n+\n       /// Get a copy of the memory allocation object.\n       allocator_type\n       get_allocator() const\n@@ -372,7 +403,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n        *\n        *  Complexity similar to that of the range constructor.\n        */\n-      template <typename _InputIterator>\n+      template<typename _InputIterator>\n         void\n         insert(_InputIterator __first, _InputIterator __last)\n         { _M_t._M_insert_equal(__first, __last); }\n@@ -433,7 +464,11 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n        *  std::swap(m1,m2) will feed to this function.\n        */\n       void\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      swap(multimap&& __x)\n+#else\n       swap(multimap& __x)\n+#endif\n       { _M_t.swap(__x._M_t); }\n \n       /**\n@@ -587,15 +622,15 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       equal_range(const key_type& __x) const\n       { return _M_t.equal_range(__x); }\n \n-      template <typename _K1, typename _T1, typename _C1, typename _A1>\n+      template<typename _K1, typename _T1, typename _C1, typename _A1>\n         friend bool\n-        operator== (const multimap<_K1, _T1, _C1, _A1>&,\n-\t\t    const multimap<_K1, _T1, _C1, _A1>&);\n+        operator==(const multimap<_K1, _T1, _C1, _A1>&,\n+\t\t   const multimap<_K1, _T1, _C1, _A1>&);\n \n-      template <typename _K1, typename _T1, typename _C1, typename _A1>\n+      template<typename _K1, typename _T1, typename _C1, typename _A1>\n         friend bool\n-        operator< (const multimap<_K1, _T1, _C1, _A1>&,\n-\t\t   const multimap<_K1, _T1, _C1, _A1>&);\n+        operator<(const multimap<_K1, _T1, _C1, _A1>&,\n+\t\t  const multimap<_K1, _T1, _C1, _A1>&);\n   };\n \n   /**\n@@ -608,7 +643,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n    *  multimaps.  Multimaps are considered equivalent if their sizes are equal,\n    *  and if corresponding elements compare equal.\n   */\n-  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator==(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n                const multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n@@ -625,47 +660,61 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n    *\n    *  See std::lexicographical_compare() for how the determination is made.\n   */\n-  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator<(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return __x._M_t < __y._M_t; }\n \n   /// Based on operator==\n-  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator!=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n                const multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return !(__x == __y); }\n \n   /// Based on operator<\n-  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator>(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return __y < __x; }\n \n   /// Based on operator<\n-  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator<=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n                const multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return !(__y < __x); }\n \n   /// Based on operator<\n-  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator>=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n                const multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return !(__x < __y); }\n \n   /// See std::multimap::swap().\n-  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline void\n     swap(multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n          multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n     { __x.swap(__y); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+    inline void\n+    swap(multimap<_Key, _Tp, _Compare, _Alloc>&& __x,\n+         multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n+    { __x.swap(__y); }\n+\n+  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+    inline void\n+    swap(multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n+         multimap<_Key, _Tp, _Compare, _Alloc>&& __y)\n+    { __x.swap(__y); }\n+#endif\n+\n _GLIBCXX_END_NESTED_NAMESPACE\n \n #endif /* _STL_MULTIMAP_H */"}, {"sha": "6e45b8fbcb4c094f236709b4afe0917cd4d53308", "filename": "libstdc++-v3/include/bits/stl_multiset.h", "status": "modified", "additions": 75, "deletions": 23, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h?ref=78b36b70be3d76df54b8d50a5f09368db15477c9", "patch": "@@ -86,8 +86,8 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n    *  called (*_unique versus *_equal, same as the standard).\n    *  @endif\n   */\n-  template <class _Key, class _Compare = std::less<_Key>,\n-\t    class _Alloc = std::allocator<_Key> >\n+  template <typename _Key, typename _Compare = std::less<_Key>,\n+\t    typename _Alloc = std::allocator<_Key> >\n     class multiset\n     {\n       // concept requirements\n@@ -130,13 +130,17 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       typedef typename _Rep_type::difference_type           difference_type;\n \n       // allocation/deallocation\n-\n       /**\n        *  @brief  Default constructor creates no elements.\n        */\n       multiset()\n-      : _M_t(_Compare(), allocator_type()) { }\n+      : _M_t() { }\n \n+      /**\n+       *  @brief  Creates a %multiset with no elements.\n+       *  @param  comp  Comparator to use.\n+       *  @param  a  An allocator object.\n+       */\n       explicit\n       multiset(const _Compare& __comp,\n \t       const allocator_type& __a = allocator_type())\n@@ -151,9 +155,9 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n        *  [first,last).  This is linear in N if the range is already sorted,\n        *  and NlogN otherwise (where N is distance(first,last)).\n        */\n-      template <class _InputIterator>\n+      template<typename _InputIterator>\n         multiset(_InputIterator __first, _InputIterator __last)\n-\t: _M_t(_Compare(), allocator_type())\n+\t: _M_t()\n         { _M_t._M_insert_equal(__first, __last); }\n \n       /**\n@@ -167,7 +171,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n        *  [first,last).  This is linear in N if the range is already sorted,\n        *  and NlogN otherwise (where N is distance(first,last)).\n        */\n-      template <class _InputIterator>\n+      template<typename _InputIterator>\n         multiset(_InputIterator __first, _InputIterator __last,\n \t\t const _Compare& __comp,\n \t\t const allocator_type& __a = allocator_type())\n@@ -181,23 +185,53 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n        *  The newly-created %multiset uses a copy of the allocation object used\n        *  by @a x.\n        */\n-      multiset(const multiset<_Key,_Compare,_Alloc>& __x)\n+      multiset(const multiset& __x)\n       : _M_t(__x._M_t) { }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+     /**\n+       *  @brief  %Multiset move constructor.\n+       *  @param  x  A %multiset of identical element and allocator types.\n+       *\n+       *  The newly-created %multiset contains the exact contents of @a x.\n+       *  The contents of @a x are a valid, but unspecified %multiset.\n+       */\n+      multiset(multiset&& __x)\n+      : _M_t(__x._M_t.key_comp(),\n+\t     __x._M_t._M_get_Node_allocator())\n+      { this->swap(__x); }\n+#endif\n+\n       /**\n        *  @brief  %Multiset assignment operator.\n        *  @param  x  A %multiset of identical element and allocator types.\n        *\n        *  All the elements of @a x are copied, but unlike the copy constructor,\n        *  the allocator object is not copied.\n        */\n-      multiset<_Key,_Compare,_Alloc>&\n-      operator=(const multiset<_Key,_Compare,_Alloc>& __x)\n+      multiset&\n+      operator=(const multiset& __x)\n       {\n \t_M_t = __x._M_t;\n \treturn *this;\n       }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      /**\n+       *  @brief  %Multiset move assignment operator.\n+       *  @param  x  A %multiset of identical element and allocator types.\n+       *\n+       *  The contents of @a x are moved into this %multiset (without copying).\n+       *  @a x is a valid, but unspecified %multiset.\n+       */\n+      multiset&\n+      operator=(multiset&& __x)\n+      {\n+\tthis->swap(__x); \n+\treturn *this;\n+      }\n+#endif\n+\n       // accessors:\n \n       ///  Returns the comparison object.\n@@ -276,7 +310,11 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n        *  std::swap(s1,s2) will feed to this function.\n        */\n       void\n-      swap(multiset<_Key, _Compare, _Alloc>& __x)\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      swap(multiset&& __x)\n+#else\n+      swap(multiset& __x)\n+#endif\n       { _M_t.swap(__x._M_t); }\n \n       // insert/erase\n@@ -327,7 +365,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n        *\n        *  Complexity similar to that of the range constructor.\n        */\n-      template <class _InputIterator>\n+      template<typename _InputIterator>\n         void\n         insert(_InputIterator __first, _InputIterator __last)\n         { _M_t._M_insert_equal(__first, __last); }\n@@ -481,12 +519,12 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       equal_range(const key_type& __x) const\n       { return _M_t.equal_range(__x); }\n \n-      template <class _K1, class _C1, class _A1>\n+      template<typename _K1, typename _C1, typename _A1>\n         friend bool\n-        operator== (const multiset<_K1, _C1, _A1>&,\n-\t\t    const multiset<_K1, _C1, _A1>&);\n+        operator==(const multiset<_K1, _C1, _A1>&,\n+\t\t   const multiset<_K1, _C1, _A1>&);\n \n-      template <class _K1, class _C1, class _A1>\n+      template<typename _K1, typename _C1, typename _A1>\n         friend bool\n         operator< (const multiset<_K1, _C1, _A1>&,\n \t\t   const multiset<_K1, _C1, _A1>&);\n@@ -503,7 +541,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n    *  Multisets are considered equivalent if their sizes are equal, and if\n    *  corresponding elements compare equal.\n   */\n-  template <class _Key, class _Compare, class _Alloc>\n+  template<typename _Key, typename _Compare, typename _Alloc>\n     inline bool\n     operator==(const multiset<_Key, _Compare, _Alloc>& __x,\n \t       const multiset<_Key, _Compare, _Alloc>& __y)\n@@ -520,47 +558,61 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n    *\n    *  See std::lexicographical_compare() for how the determination is made.\n   */\n-  template <class _Key, class _Compare, class _Alloc>\n+  template<typename _Key, typename _Compare, typename _Alloc>\n     inline bool\n     operator<(const multiset<_Key, _Compare, _Alloc>& __x,\n \t      const multiset<_Key, _Compare, _Alloc>& __y)\n     { return __x._M_t < __y._M_t; }\n \n   ///  Returns !(x == y).\n-  template <class _Key, class _Compare, class _Alloc>\n+  template<typename _Key, typename _Compare, typename _Alloc>\n     inline bool\n     operator!=(const multiset<_Key, _Compare, _Alloc>& __x,\n \t       const multiset<_Key, _Compare, _Alloc>& __y)\n     { return !(__x == __y); }\n \n   ///  Returns y < x.\n-  template <class _Key, class _Compare, class _Alloc>\n+  template<typename _Key, typename _Compare, typename _Alloc>\n     inline bool\n     operator>(const multiset<_Key,_Compare,_Alloc>& __x,\n \t      const multiset<_Key,_Compare,_Alloc>& __y)\n     { return __y < __x; }\n \n   ///  Returns !(y < x)\n-  template <class _Key, class _Compare, class _Alloc>\n+  template<typename _Key, typename _Compare, typename _Alloc>\n     inline bool\n     operator<=(const multiset<_Key, _Compare, _Alloc>& __x,\n \t       const multiset<_Key, _Compare, _Alloc>& __y)\n     { return !(__y < __x); }\n \n   ///  Returns !(x < y)\n-  template <class _Key, class _Compare, class _Alloc>\n+  template<typename _Key, typename _Compare, typename _Alloc>\n     inline bool\n     operator>=(const multiset<_Key, _Compare, _Alloc>& __x,\n \t       const multiset<_Key, _Compare, _Alloc>& __y)\n     { return !(__x < __y); }\n \n   /// See std::multiset::swap().\n-  template <class _Key, class _Compare, class _Alloc>\n+  template<typename _Key, typename _Compare, typename _Alloc>\n     inline void\n     swap(multiset<_Key, _Compare, _Alloc>& __x,\n \t multiset<_Key, _Compare, _Alloc>& __y)\n     { __x.swap(__y); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+  template<typename _Key, typename _Compare, typename _Alloc>\n+    inline void\n+    swap(multiset<_Key, _Compare, _Alloc>&& __x,\n+\t multiset<_Key, _Compare, _Alloc>& __y)\n+    { __x.swap(__y); }\n+\n+  template<typename _Key, typename _Compare, typename _Alloc>\n+    inline void\n+    swap(multiset<_Key, _Compare, _Alloc>& __x,\n+\t multiset<_Key, _Compare, _Alloc>&& __y)\n+    { __x.swap(__y); }\n+#endif\n+\n _GLIBCXX_END_NESTED_NAMESPACE\n \n #endif /* _STL_MULTISET_H */"}, {"sha": "2b51bfaa9700f208ed6e3f6110efef75cca85799", "filename": "libstdc++-v3/include/bits/stl_set.h", "status": "modified", "additions": 77, "deletions": 30, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h?ref=78b36b70be3d76df54b8d50a5f09368db15477c9", "patch": "@@ -89,8 +89,8 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n    *  called (*_unique versus *_equal, same as the standard).\n    *  @endif\n   */\n-  template<class _Key, class _Compare = std::less<_Key>,\n-\t   class _Alloc = std::allocator<_Key> >\n+  template<typename _Key, typename _Compare = std::less<_Key>,\n+\t   typename _Alloc = std::allocator<_Key> >\n     class set\n     {\n       // concept requirements\n@@ -137,20 +137,21 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       //@}\n \n       // allocation/deallocation\n-      ///  Default constructor creates no elements.\n+      /**\n+       *  @brief  Default constructor creates no elements.\n+       */\n       set()\n-      : _M_t(_Compare(), allocator_type()) {}\n+      : _M_t() { }\n \n       /**\n-       *  @brief  Default constructor creates no elements.\n-       *\n+       *  @brief  Creates a %set with no elements.\n        *  @param  comp  Comparator to use.\n-       *  @param  a  Allocator to use.\n+       *  @param  a  An allocator object.\n        */\n       explicit\n       set(const _Compare& __comp,\n \t  const allocator_type& __a = allocator_type())\n-      : _M_t(__comp, __a) {}\n+      : _M_t(__comp, __a) { }\n \n       /**\n        *  @brief  Builds a %set from a range.\n@@ -161,9 +162,9 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n        *  This is linear in N if the range is already sorted, and NlogN\n        *  otherwise (where N is distance(first,last)).\n        */\n-      template<class _InputIterator>\n+      template<typename _InputIterator>\n         set(_InputIterator __first, _InputIterator __last)\n-        : _M_t(_Compare(), allocator_type())\n+\t: _M_t()\n         { _M_t._M_insert_unique(__first, __last); }\n \n       /**\n@@ -177,37 +178,67 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n        *  This is linear in N if the range is already sorted, and NlogN\n        *  otherwise (where N is distance(first,last)).\n        */\n-      template<class _InputIterator>\n+      template<typename _InputIterator>\n         set(_InputIterator __first, _InputIterator __last,\n \t    const _Compare& __comp,\n \t    const allocator_type& __a = allocator_type())\n \t: _M_t(__comp, __a)\n         { _M_t._M_insert_unique(__first, __last); }\n \n       /**\n-       *  @brief  Set copy constructor.\n+       *  @brief  %Set copy constructor.\n        *  @param  x  A %set of identical element and allocator types.\n        *\n        *  The newly-created %set uses a copy of the allocation object used\n        *  by @a x.\n        */\n-      set(const set<_Key,_Compare,_Alloc>& __x)\n+      set(const set& __x)\n       : _M_t(__x._M_t) { }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+     /**\n+       *  @brief %Set move constructor\n+       *  @param x  A %set of identical element and allocator types.\n+       *\n+       *  The newly-created %set contains the exact contents of @a x.\n+       *  The contents of @a x are a valid, but unspecified %set.\n+       */\n+      set(set&& __x)\n+      : _M_t(__x._M_t.key_comp(),\n+\t     __x._M_t._M_get_Node_allocator())\n+      { this->swap(__x); }\n+#endif\n+\n       /**\n-       *  @brief  Set assignment operator.\n+       *  @brief  %Set assignment operator.\n        *  @param  x  A %set of identical element and allocator types.\n        *\n        *  All the elements of @a x are copied, but unlike the copy constructor,\n        *  the allocator object is not copied.\n        */\n-      set<_Key,_Compare,_Alloc>&\n-      operator=(const set<_Key, _Compare, _Alloc>& __x)\n+      set&\n+      operator=(const set& __x)\n       {\n \t_M_t = __x._M_t;\n \treturn *this;\n       }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      /**\n+       *  @brief %Set move assignment operator.\n+       *  @param x  A %set of identical element and allocator types.\n+       *\n+       *  The contents of @a x are moved into this %set (without copying).\n+       *  @a x is a valid, but unspecified %set.\n+       */\n+      set&\n+      operator=(set&& __x)\n+      {\n+\tthis->swap(__x); \n+\treturn *this;\n+      }\n+#endif\n+\n       // accessors:\n \n       ///  Returns the comparison object with which the %set was constructed.\n@@ -284,7 +315,11 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n        *  std::swap(s1,s2) will feed to this function.\n        */\n       void\n-      swap(set<_Key,_Compare,_Alloc>& __x)\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      swap(set&& __x)\n+#else\n+      swap(set& __x)\t\n+#endif\n       { _M_t.swap(__x._M_t); }\n \n       // insert/erase\n@@ -301,7 +336,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n        *\n        *  Insertion requires logarithmic time.\n        */\n-      std::pair<iterator,bool>\n+      std::pair<iterator, bool>\n       insert(const value_type& __x)\n       {\n \tstd::pair<typename _Rep_type::iterator, bool> __p =\n@@ -340,7 +375,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n        *\n        *  Complexity similar to that of the range constructor.\n        */\n-      template<class _InputIterator>\n+      template<typename _InputIterator>\n         void\n         insert(_InputIterator __first, _InputIterator __last)\n         { _M_t._M_insert_unique(__first, __last); }\n@@ -497,13 +532,13 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       { return _M_t.equal_range(__x); }\n       //@}\n \n-      template<class _K1, class _C1, class _A1>\n+      template<typename _K1, typename _C1, typename _A1>\n         friend bool\n-        operator== (const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);\n+        operator==(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);\n \n-      template<class _K1, class _C1, class _A1>\n+      template<typename _K1, typename _C1, typename _A1>\n         friend bool\n-        operator< (const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);\n+        operator<(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);\n     };\n \n \n@@ -517,7 +552,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n    *  Sets are considered equivalent if their sizes are equal, and if\n    *  corresponding elements compare equal.\n   */\n-  template<class _Key, class _Compare, class _Alloc>\n+  template<typename _Key, typename _Compare, typename _Alloc>\n     inline bool\n     operator==(const set<_Key, _Compare, _Alloc>& __x,\n \t       const set<_Key, _Compare, _Alloc>& __y)\n@@ -534,46 +569,58 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n    *\n    *  See std::lexicographical_compare() for how the determination is made.\n   */\n-  template<class _Key, class _Compare, class _Alloc>\n+  template<typename _Key, typename _Compare, typename _Alloc>\n     inline bool\n     operator<(const set<_Key, _Compare, _Alloc>& __x,\n \t      const set<_Key, _Compare, _Alloc>& __y)\n     { return __x._M_t < __y._M_t; }\n \n   ///  Returns !(x == y).\n-  template<class _Key, class _Compare, class _Alloc>\n+  template<typename _Key, typename _Compare, typename _Alloc>\n     inline bool\n     operator!=(const set<_Key, _Compare, _Alloc>& __x,\n \t       const set<_Key, _Compare, _Alloc>& __y)\n     { return !(__x == __y); }\n \n   ///  Returns y < x.\n-  template<class _Key, class _Compare, class _Alloc>\n+  template<typename _Key, typename _Compare, typename _Alloc>\n     inline bool\n     operator>(const set<_Key, _Compare, _Alloc>& __x,\n \t      const set<_Key, _Compare, _Alloc>& __y)\n     { return __y < __x; }\n \n   ///  Returns !(y < x)\n-  template<class _Key, class _Compare, class _Alloc>\n+  template<typename _Key, typename _Compare, typename _Alloc>\n     inline bool\n     operator<=(const set<_Key, _Compare, _Alloc>& __x,\n \t       const set<_Key, _Compare, _Alloc>& __y)\n     { return !(__y < __x); }\n \n   ///  Returns !(x < y)\n-  template<class _Key, class _Compare, class _Alloc>\n+  template<typename _Key, typename _Compare, typename _Alloc>\n     inline bool\n     operator>=(const set<_Key, _Compare, _Alloc>& __x,\n \t       const set<_Key, _Compare, _Alloc>& __y)\n     { return !(__x < __y); }\n \n   /// See std::set::swap().\n-  template<class _Key, class _Compare, class _Alloc>\n+  template<typename _Key, typename _Compare, typename _Alloc>\n     inline void\n     swap(set<_Key, _Compare, _Alloc>& __x, set<_Key, _Compare, _Alloc>& __y)\n     { __x.swap(__y); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+  template<typename _Key, typename _Compare, typename _Alloc>\n+    inline void\n+    swap(set<_Key, _Compare, _Alloc>&& __x, set<_Key, _Compare, _Alloc>& __y)\n+    { __x.swap(__y); }\n+\n+  template<typename _Key, typename _Compare, typename _Alloc>\n+    inline void\n+    swap(set<_Key, _Compare, _Alloc>& __x, set<_Key, _Compare, _Alloc>&& __y)\n+    { __x.swap(__y); }\n+#endif\n+\n _GLIBCXX_END_NESTED_NAMESPACE\n \n #endif /* _STL_SET_H */"}, {"sha": "1b9743f1b4ef7f86bd9214075d0e8c82ead8e8ac", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 43, "deletions": 22, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=78b36b70be3d76df54b8d50a5f09368db15477c9", "patch": "@@ -400,16 +400,25 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t  _Rb_tree_node_base \t_M_header;\n \t  size_type \t\t_M_node_count; // Keeps track of size of tree.\n \n-\t  _Rb_tree_impl(const _Node_allocator& __a = _Node_allocator(),\n-\t\t\tconst _Key_compare& __comp = _Key_compare())\n-\t  : _Node_allocator(__a), _M_key_compare(__comp), _M_header(), \n+\t  _Rb_tree_impl()\n+\t  : _Node_allocator(), _M_key_compare(), _M_header(),\n \t    _M_node_count(0)\n+\t  { _M_initialize(); }\n+\n+\t  _Rb_tree_impl(const _Key_compare& __comp, const _Node_allocator& __a)\n+\t  : _Node_allocator(__a), _M_key_compare(__comp), _M_header(),\n+\t    _M_node_count(0)\n+\t  { _M_initialize(); }\n+\n+\tprivate:\n+\t  void\n+\t  _M_initialize()\n \t  {\n \t    this->_M_header._M_color = _S_red;\n \t    this->_M_header._M_parent = 0;\n \t    this->_M_header._M_left = &this->_M_header;\n \t    this->_M_header._M_right = &this->_M_header;\n-\t  }\n+\t  }\t    \n \t};\n \n       // Specialization for _Comparison types that are not capable of\n@@ -421,16 +430,25 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t  _Rb_tree_node_base \t_M_header;\n \t  size_type \t\t_M_node_count; // Keeps track of size of tree.\n \n-\t  _Rb_tree_impl(const _Node_allocator& __a = _Node_allocator(),\n-\t\t\tconst _Key_compare& __comp = _Key_compare())\n+\t  _Rb_tree_impl()\n+\t  : _Node_allocator(), _M_key_compare(), _M_header(),\n+\t    _M_node_count(0)\n+\t  { _M_initialize(); }\n+\n+\t  _Rb_tree_impl(const _Key_compare& __comp, const _Node_allocator& __a)\n \t  : _Node_allocator(__a), _M_key_compare(__comp), _M_header(),\n \t    _M_node_count(0)\n-\t  { \n+\t  { _M_initialize(); }\n+\n+\tprivate:\n+\t  void\n+\t  _M_initialize()\n+\t  {\n \t    this->_M_header._M_color = _S_red;\n \t    this->_M_header._M_parent = 0;\n \t    this->_M_header._M_left = &this->_M_header;\n \t    this->_M_header._M_right = &this->_M_header;\n-\t  }\n+\t  }\t    \n \t};\n \n       _Rb_tree_impl<_Compare> _M_impl;\n@@ -571,19 +589,14 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n     public:\n       // allocation/deallocation\n-      _Rb_tree()\n-      { }\n+      _Rb_tree() { }\n \n-      _Rb_tree(const _Compare& __comp)\n-      : _M_impl(allocator_type(), __comp)\n-      { }\n+      _Rb_tree(const _Compare& __comp,\n+\t       const allocator_type& __a = allocator_type())\n+      : _M_impl(__comp, __a) { }\n \n-      _Rb_tree(const _Compare& __comp, const allocator_type& __a)\n-      : _M_impl(__a, __comp)\n-      { }\n-\n-      _Rb_tree(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x)\n-      : _M_impl(__x._M_get_Node_allocator(), __x._M_impl._M_key_compare)\n+      _Rb_tree(const _Rb_tree& __x)\n+      : _M_impl(__x._M_impl._M_key_compare, __x._M_get_Node_allocator())\n       {\n \tif (__x._M_root() != 0)\n \t  {\n@@ -597,8 +610,8 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       ~_Rb_tree()\n       { _M_erase(_M_begin()); }\n \n-      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&\n-      operator=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x);\n+      _Rb_tree&\n+      operator=(const _Rb_tree& __x);\n \n       // Accessors.\n       _Compare\n@@ -659,7 +672,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       { return get_allocator().max_size(); }\n \n       void\n-      swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __t);\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      swap(_Rb_tree&& __t);\n+#else\n+      swap(_Rb_tree& __t);      \n+#endif\n \n       // Insert/erase.\n       pair<iterator, bool>\n@@ -1060,7 +1077,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n            typename _Compare, typename _Alloc>\n     void\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&& __t)\n+#else\n     swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __t)\n+#endif\n     {\n       if (_M_root() == 0)\n \t{"}, {"sha": "2f3384d8cc11c712fdb8136bd20603e6c4fb8fdc", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 66, "deletions": 6, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=78b36b70be3d76df54b8d50a5f09368db15477c9", "patch": "@@ -84,6 +84,11 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \t_Tp*           _M_start;\n \t_Tp*           _M_finish;\n \t_Tp*           _M_end_of_storage;\n+\n+\t_Vector_impl()\n+\t: _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)\n+\t{ }\n+\n \t_Vector_impl(_Tp_alloc_type const& __a)\n \t: _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)\n \t{ }\n@@ -104,9 +109,11 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       get_allocator() const\n       { return allocator_type(_M_get_Tp_allocator()); }\n \n+      _Vector_base()\n+      : _M_impl() { }\n+\n       _Vector_base(const allocator_type& __a)\n-      : _M_impl(__a)\n-      { }\n+      : _M_impl(__a) { }\n \n       _Vector_base(size_t __n, const allocator_type& __a)\n       : _M_impl(__a)\n@@ -194,15 +201,22 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       /**\n        *  @brief  Default constructor creates no elements.\n        */\n+      vector()\n+      : _Base() { }\n+\n+      /**\n+       *  @brief  Creates a %vector with no elements.\n+       *  @param  a  An allocator object.\n+       */\n       explicit\n-      vector(const allocator_type& __a = allocator_type())\n-      : _Base(__a)\n-      { }\n+      vector(const allocator_type& __a)\n+      : _Base(__a) { }\n \n       /**\n-       *  @brief  Create a %vector with copies of an exemplar element.\n+       *  @brief  Creates a %vector with copies of an exemplar element.\n        *  @param  n  The number of elements to initially create.\n        *  @param  value  An element to copy.\n+       *  @param  a  An allocator.\n        *\n        *  This constructor fills the %vector with @a n copies of @a value.\n        */\n@@ -229,10 +243,24 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \t\t\t\t      _M_get_Tp_allocator());\n       }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      /**\n+       *  @brief  %Vector move constructor.\n+       *  @param  x  A %vector of identical element and allocator types.\n+       *\n+       *  The newly-created %vector contains the exact contents of @a x.\n+       *  The contents of @a x are a valid, but unspecified %vector.\n+       */\n+      vector(vector&& __x)\n+      : _Base(__x._M_get_Tp_allocator())\n+      { this->swap(__x); }\n+#endif\n+\n       /**\n        *  @brief  Builds a %vector from a range.\n        *  @param  first  An input iterator.\n        *  @param  last  An input iterator.\n+       *  @param  a  An allocator.\n        *\n        *  Create a %vector consisting of copies of the elements from\n        *  [first,last).\n@@ -275,6 +303,22 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       vector&\n       operator=(const vector& __x);\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      /**\n+       *  @brief  %Vector move assignment operator.\n+       *  @param  x  A %vector of identical element and allocator types.\n+       *\n+       *  The contents of @a x are moved into this %vector (without copying).\n+       *  @a x is a valid, but unspecified %vector.\n+       */\n+      vector&\n+      operator=(vector&& __x)\n+      { \n+\tthis->swap(__x); \n+\treturn *this;\n+      }\n+#endif\n+\n       /**\n        *  @brief  Assigns a given value to a %vector.\n        *  @param  n  Number of elements to be assigned.\n@@ -721,7 +765,11 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n        *  std::swap(v1,v2) will feed to this function.\n        */\n       void\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      swap(vector&& __x)\n+#else\n       swap(vector& __x)\n+#endif\n       {\n \tstd::swap(this->_M_impl._M_start, __x._M_impl._M_start);\n \tstd::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);\n@@ -1006,6 +1054,18 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n     swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)\n     { __x.swap(__y); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+  template<typename _Tp, typename _Alloc>\n+    inline void\n+    swap(vector<_Tp, _Alloc>&& __x, vector<_Tp, _Alloc>& __y)\n+    { __x.swap(__y); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline void\n+    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>&& __y)\n+    { __x.swap(__y); }\n+#endif\n+\n _GLIBCXX_END_NESTED_NAMESPACE\n \n #endif /* _STL_VECTOR_H */"}, {"sha": "8fde473dc7ac47b4f12a7fd217828b935462be00", "filename": "libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/assign_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Frequirements%2Fdr438%2Fassign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Frequirements%2Fdr438%2Fassign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Frequirements%2Fdr438%2Fassign_neg.cc?ref=78b36b70be3d76df54b8d50a5f09368db15477c9", "patch": "@@ -19,7 +19,7 @@\n // USA.\n \n // { dg-do compile }\n-// { dg-error \"no matching\" \"\" { target *-*-* } 1297 }\n+// { dg-error \"no matching\" \"\" { target *-*-* } 1349 }\n // { dg-excess-errors \"\" }\n \n #include <deque>"}, {"sha": "3124e19af270d76f02a87a199bd87712f16e4b27", "filename": "libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/constructor_1_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Frequirements%2Fdr438%2Fconstructor_1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Frequirements%2Fdr438%2Fconstructor_1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Frequirements%2Fdr438%2Fconstructor_1_neg.cc?ref=78b36b70be3d76df54b8d50a5f09368db15477c9", "patch": "@@ -19,7 +19,7 @@\n // USA.\n \n // { dg-do compile }\n-// { dg-error \"no matching\" \"\" { target *-*-* } 1232 }\n+// { dg-error \"no matching\" \"\" { target *-*-* } 1284 }\n // { dg-excess-errors \"\" }\n \n #include <deque>"}, {"sha": "1f6115c5d3ceddaa7a04c6ad89a4fd5b678371a2", "filename": "libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/constructor_2_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Frequirements%2Fdr438%2Fconstructor_2_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Frequirements%2Fdr438%2Fconstructor_2_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Frequirements%2Fdr438%2Fconstructor_2_neg.cc?ref=78b36b70be3d76df54b8d50a5f09368db15477c9", "patch": "@@ -19,7 +19,7 @@\n // USA.\n \n // { dg-do compile }\n-// { dg-error \"no matching\" \"\" { target *-*-* } 1232 }\n+// { dg-error \"no matching\" \"\" { target *-*-* } 1284 }\n // { dg-excess-errors \"\" }\n \n #include <deque>"}, {"sha": "9d6365932dd62827a752dd119fa01aa998e26e52", "filename": "libstdc++-v3/testsuite/23_containers/deque/requirements/dr438/insert_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Frequirements%2Fdr438%2Finsert_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Frequirements%2Fdr438%2Finsert_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Frequirements%2Fdr438%2Finsert_neg.cc?ref=78b36b70be3d76df54b8d50a5f09368db15477c9", "patch": "@@ -19,7 +19,7 @@\n // USA.\n \n // { dg-do compile }\n-// { dg-error \"no matching\" \"\" { target *-*-* } 1377 }\n+// { dg-error \"no matching\" \"\" { target *-*-* } 1429 }\n // { dg-excess-errors \"\" }\n \n #include <deque>"}, {"sha": "ccabf384ead5407ed8effa386f12df44a85df56c", "filename": "libstdc++-v3/testsuite/23_containers/list/requirements/dr438/assign_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Frequirements%2Fdr438%2Fassign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Frequirements%2Fdr438%2Fassign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Frequirements%2Fdr438%2Fassign_neg.cc?ref=78b36b70be3d76df54b8d50a5f09368db15477c9", "patch": "@@ -19,7 +19,7 @@\n // USA.\n \n // { dg-do compile }\n-// { dg-error \"no matching\" \"\" { target *-*-* } 1138 }\n+// { dg-error \"no matching\" \"\" { target *-*-* } 1188 }\n // { dg-excess-errors \"\" }\n \n #include <list>"}, {"sha": "0711505092fd31970b746f31245049dea883e0ea", "filename": "libstdc++-v3/testsuite/23_containers/list/requirements/dr438/constructor_1_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Frequirements%2Fdr438%2Fconstructor_1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Frequirements%2Fdr438%2Fconstructor_1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Frequirements%2Fdr438%2Fconstructor_1_neg.cc?ref=78b36b70be3d76df54b8d50a5f09368db15477c9", "patch": "@@ -19,7 +19,7 @@\n // USA.\n \n // { dg-do compile }\n-// { dg-error \"no matching\" \"\" { target *-*-* } 1107 }\n+// { dg-error \"no matching\" \"\" { target *-*-* } 1157 }\n // { dg-excess-errors \"\" }\n \n #include <list>"}, {"sha": "1e02ca8913ef576cef7b9f9dfb7d7b8f2cf58275", "filename": "libstdc++-v3/testsuite/23_containers/list/requirements/dr438/constructor_2_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Frequirements%2Fdr438%2Fconstructor_2_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Frequirements%2Fdr438%2Fconstructor_2_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Frequirements%2Fdr438%2Fconstructor_2_neg.cc?ref=78b36b70be3d76df54b8d50a5f09368db15477c9", "patch": "@@ -19,7 +19,7 @@\n // USA.\n \n // { dg-do compile }\n-// { dg-error \"no matching\" \"\" { target *-*-* } 1107 }\n+// { dg-error \"no matching\" \"\" { target *-*-* } 1157 }\n // { dg-excess-errors \"\" }\n \n #include <list>"}, {"sha": "04b3c2b95c207083c85cb65f07b08ed85e133dde", "filename": "libstdc++-v3/testsuite/23_containers/list/requirements/dr438/insert_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Frequirements%2Fdr438%2Finsert_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Frequirements%2Fdr438%2Finsert_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Frequirements%2Fdr438%2Finsert_neg.cc?ref=78b36b70be3d76df54b8d50a5f09368db15477c9", "patch": "@@ -19,7 +19,7 @@\n // USA.\n \n // { dg-do compile }\n-// { dg-error \"no matching\" \"\" { target *-*-* } 1107 }\n+// { dg-error \"no matching\" \"\" { target *-*-* } 1157 }\n // { dg-excess-errors \"\" }\n \n #include <list>"}, {"sha": "4239d4df3c55da648747809729f01fecf53077ce", "filename": "libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/assign_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Fassign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Fassign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Fassign_neg.cc?ref=78b36b70be3d76df54b8d50a5f09368db15477c9", "patch": "@@ -19,7 +19,7 @@\n // USA.\n \n // { dg-do compile }\n-// { dg-error \"no matching\" \"\" { target *-*-* } 847 }\n+// { dg-error \"no matching\" \"\" { target *-*-* } 895 }\n // { dg-excess-errors \"\" }\n \n #include <vector>"}, {"sha": "7faf1e2feb6e419d16420beb1d5cc6de9df5fc07", "filename": "libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/constructor_1_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Fconstructor_1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Fconstructor_1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Fconstructor_1_neg.cc?ref=78b36b70be3d76df54b8d50a5f09368db15477c9", "patch": "@@ -19,7 +19,7 @@\n // USA.\n \n // { dg-do compile }\n-// { dg-error \"no matching\" \"\" { target *-*-* } 787 }\n+// { dg-error \"no matching\" \"\" { target *-*-* } 835 }\n // { dg-excess-errors \"\" }\n \n #include <vector>"}, {"sha": "66c0206044e47cdfa3e8be2a1922b3cb13aa0424", "filename": "libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/constructor_2_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Fconstructor_2_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Fconstructor_2_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Fconstructor_2_neg.cc?ref=78b36b70be3d76df54b8d50a5f09368db15477c9", "patch": "@@ -19,7 +19,7 @@\n // USA.\n \n // { dg-do compile }\n-// { dg-error \"no matching\" \"\" { target *-*-* } 787 }\n+// { dg-error \"no matching\" \"\" { target *-*-* } 835 }\n // { dg-excess-errors \"\" }\n \n #include <vector>"}, {"sha": "6aae607479f1684656aae01cf570aebb6f21b66e", "filename": "libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/insert_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Finsert_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78b36b70be3d76df54b8d50a5f09368db15477c9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Finsert_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Finsert_neg.cc?ref=78b36b70be3d76df54b8d50a5f09368db15477c9", "patch": "@@ -19,7 +19,7 @@\n // USA.\n \n // { dg-do compile }\n-// { dg-error \"no matching\" \"\" { target *-*-* } 888 }\n+// { dg-error \"no matching\" \"\" { target *-*-* } 936 }\n // { dg-excess-errors \"\" }\n \n #include <vector>"}]}