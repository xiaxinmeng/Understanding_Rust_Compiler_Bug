{"sha": "f54e3b3ba01ced7ecda3caed51b42f707d489c77", "node_id": "C_kwDOANBUbNoAKGY1NGUzYjNiYTAxY2VkN2VjZGEzY2FlZDUxYjQyZjcwN2Q0ODljNzc", "commit": {"author": {"name": "Alexandre Oliva", "email": "oliva@adacore.com", "date": "2023-01-12T03:29:33Z"}, "committer": {"name": "Alexandre Oliva", "email": "oliva@gnu.org", "date": "2023-01-12T03:29:33Z"}, "message": "check hash table counts at expand\n\nAdd cheap verification of element and deleted entry counts during\nexpand and hash verify.\n\n\nfor  gcc/ChangeLog\n\n\t* hash-table.h (expand): Check elements and deleted counts.\n\t(verify): Likewise.", "tree": {"sha": "b45116c55d4ba1b78c433ae3aa3c80c6ca2b4b5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b45116c55d4ba1b78c433ae3aa3c80c6ca2b4b5e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f54e3b3ba01ced7ecda3caed51b42f707d489c77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f54e3b3ba01ced7ecda3caed51b42f707d489c77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f54e3b3ba01ced7ecda3caed51b42f707d489c77", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f54e3b3ba01ced7ecda3caed51b42f707d489c77/comments", "author": null, "committer": null, "parents": [{"sha": "81ed98bc57c3dbd89f26c13987119bf843a5e8f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81ed98bc57c3dbd89f26c13987119bf843a5e8f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81ed98bc57c3dbd89f26c13987119bf843a5e8f0"}], "stats": {"total": 35, "additions": 28, "deletions": 7}, "files": [{"sha": "1d3166504c38e46eae8bc550d273a0068b772731", "filename": "gcc/hash-table.h", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54e3b3ba01ced7ecda3caed51b42f707d489c77/gcc%2Fhash-table.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54e3b3ba01ced7ecda3caed51b42f707d489c77/gcc%2Fhash-table.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-table.h?ref=f54e3b3ba01ced7ecda3caed51b42f707d489c77", "patch": "@@ -849,19 +849,28 @@ hash_table<Descriptor, Lazy, Allocator>::expand ()\n     hash_table_usage ().release_instance_overhead (this, sizeof (value_type)\n \t\t\t\t\t\t    * osize);\n \n+  size_t n_deleted = m_n_deleted;\n+\n   m_entries = nentries;\n   m_size = nsize;\n   m_size_prime_index = nindex;\n   m_n_elements -= m_n_deleted;\n   m_n_deleted = 0;\n \n+  size_t n_elements = m_n_elements;\n+\n   value_type *p = oentries;\n   do\n     {\n       value_type &x = *p;\n \n-      if (!is_empty (x) && !is_deleted (x))\n+      if (is_empty (x))\n+\t;\n+      else if (is_deleted (x))\n+\tn_deleted--;\n+      else\n         {\n+\t  n_elements--;\n           value_type *q = find_empty_slot_for_expand (Descriptor::hash (x));\n \t  new ((void*) q) value_type (std::move (x));\n \t  /* After the resources of 'x' have been moved to a new object at 'q',\n@@ -873,6 +882,8 @@ hash_table<Descriptor, Lazy, Allocator>::expand ()\n     }\n   while (p < olimit);\n \n+  gcc_checking_assert (!n_elements && !n_deleted);\n+\n   if (!m_ggc)\n     Allocator <value_type> ::data_free (oentries);\n   else\n@@ -1070,23 +1081,33 @@ ::find_slot_with_hash (const compare_type &comparable, hashval_t hash,\n   return check_insert_slot (&m_entries[index]);\n }\n \n-/* Verify that all existing elements in th hash table which are\n-   equal to COMPARABLE have an equal HASH value provided as argument.  */\n+/* Verify that all existing elements in the hash table which are\n+   equal to COMPARABLE have an equal HASH value provided as argument.\n+   Also check that the hash table element counts are correct.  */\n \n template<typename Descriptor, bool Lazy,\n \t template<typename Type> class Allocator>\n void\n hash_table<Descriptor, Lazy, Allocator>\n ::verify (const compare_type &comparable, hashval_t hash)\n {\n+  size_t n_elements = m_n_elements;\n+  size_t n_deleted = m_n_deleted;\n   for (size_t i = 0; i < MIN (hash_table_sanitize_eq_limit, m_size); i++)\n     {\n       value_type *entry = &m_entries[i];\n-      if (!is_empty (*entry) && !is_deleted (*entry)\n-\t  && hash != Descriptor::hash (*entry)\n-\t  && Descriptor::equal (*entry, comparable))\n-\thashtab_chk_error ();\n+      if (!is_empty (*entry))\n+\t{\n+\t  n_elements--;\n+\t  if (is_deleted (*entry))\n+\t    n_deleted--;\n+\t  else if (hash != Descriptor::hash (*entry)\n+\t\t   && Descriptor::equal (*entry, comparable))\n+\t    hashtab_chk_error ();\n+\t}\n     }\n+  if (hash_table_sanitize_eq_limit >= m_size)\n+    gcc_checking_assert (!n_elements && !n_deleted);\n }\n \n /* This function deletes an element with the given COMPARABLE value"}]}