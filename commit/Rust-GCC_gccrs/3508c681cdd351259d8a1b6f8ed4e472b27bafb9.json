{"sha": "3508c681cdd351259d8a1b6f8ed4e472b27bafb9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzUwOGM2ODFjZGQzNTEyNTlkOGExYjZmOGVkNGU0NzJiMjdiYWZiOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2000-04-23T12:28:50Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2000-04-23T12:28:50Z"}, "message": "loop.c (maybe_eliminate_biv_1): Use GET_CODE (x) == CONST_INT instead of CONSTANT_P for mult_val...\n\n\t* loop.c (maybe_eliminate_biv_1): Use GET_CODE (x) == CONST_INT instead\n\tof CONSTANT_P for mult_val; always use validate_change to update insn.\n\nFrom-SVN: r33353", "tree": {"sha": "b4cb713d9c27cb66aed3775a3ac8116d7487cd8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4cb713d9c27cb66aed3775a3ac8116d7487cd8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3508c681cdd351259d8a1b6f8ed4e472b27bafb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3508c681cdd351259d8a1b6f8ed4e472b27bafb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3508c681cdd351259d8a1b6f8ed4e472b27bafb9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3508c681cdd351259d8a1b6f8ed4e472b27bafb9/comments", "author": null, "committer": null, "parents": [{"sha": "e0add67ff04f88ea5d6139423db7b0b9ab14545c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0add67ff04f88ea5d6139423db7b0b9ab14545c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0add67ff04f88ea5d6139423db7b0b9ab14545c"}], "stats": {"total": 46, "additions": 26, "deletions": 20}, "files": [{"sha": "6fe6d37877ce570b618dc939fffbba0420037218", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3508c681cdd351259d8a1b6f8ed4e472b27bafb9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3508c681cdd351259d8a1b6f8ed4e472b27bafb9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3508c681cdd351259d8a1b6f8ed4e472b27bafb9", "patch": "@@ -1,3 +1,8 @@\n+Sun Apr 23 14:27:44 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n+\n+\t* loop.c (maybe_eliminate_biv_1): Use GET_CODE (x) == CONST_INT instead\n+\tof CONSTANT_P for mult_val; always use validate_change to update insn.\n+\n 2000-04-22  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* cpphash.c (trad_stringify, add_pat): New functions."}, {"sha": "e2adbd50f0921c9a387c2fd8016ef48b0b8428f4", "filename": "gcc/loop.c", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3508c681cdd351259d8a1b6f8ed4e472b27bafb9/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3508c681cdd351259d8a1b6f8ed4e472b27bafb9/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=3508c681cdd351259d8a1b6f8ed4e472b27bafb9", "patch": "@@ -8529,7 +8529,7 @@ maybe_eliminate_biv_1 (loop, x, insn, bl, eliminate_p, where)\n \t     overflows.  */\n \n \t  for (v = bl->giv; v; v = v->next_iv)\n-\t    if (CONSTANT_P (v->mult_val) && v->mult_val != const0_rtx\n+\t    if (GET_CODE (v->mult_val) == CONST_INT && v->mult_val != const0_rtx\n \t\t&& v->add_val == const0_rtx\n \t\t&& ! v->ignore && ! v->maybe_dead && v->always_computable\n \t\t&& v->mode == mode\n@@ -8561,7 +8561,7 @@ maybe_eliminate_biv_1 (loop, x, insn, bl, eliminate_p, where)\n \t     overflow problem.  */\n \n \t  for (v = bl->giv; v; v = v->next_iv)\n-\t    if (CONSTANT_P (v->mult_val) && v->mult_val != const0_rtx\n+\t    if (GET_CODE (v->mult_val) == CONST_INT && v->mult_val != const0_rtx\n \t\t&& ! v->ignore && ! v->maybe_dead && v->always_computable\n \t\t&& v->mode == mode\n \t\t&& (GET_CODE (v->add_val) == SYMBOL_REF\n@@ -8626,7 +8626,7 @@ maybe_eliminate_biv_1 (loop, x, insn, bl, eliminate_p, where)\n \t     negative mult_val, but it seems complex to do it in general.  */\n \n \t  for (v = bl->giv; v; v = v->next_iv)\n-\t    if (CONSTANT_P (v->mult_val) && INTVAL (v->mult_val) > 0\n+\t    if (GET_CODE (v->mult_val) == CONST_INT && INTVAL (v->mult_val) > 0\n \t\t&& (GET_CODE (v->add_val) == SYMBOL_REF\n \t\t    || GET_CODE (v->add_val) == LABEL_REF\n \t\t    || GET_CODE (v->add_val) == CONST\n@@ -8642,36 +8642,37 @@ maybe_eliminate_biv_1 (loop, x, insn, bl, eliminate_p, where)\n \t\t  return 1;\n \n \t\t/* Replace biv with the giv's reduced reg.  */\n-\t\tXEXP (x, 1-arg_operand) = v->new_reg;\n+\t\tvalidate_change (insn, &XEXP (x, 1-arg_operand), v->new_reg, 1);\n \n \t\t/* If all constants are actually constant integers and\n \t\t   the derived constant can be directly placed in the COMPARE,\n \t\t   do so.  */\n \t\tif (GET_CODE (arg) == CONST_INT\n \t\t    && GET_CODE (v->mult_val) == CONST_INT\n-\t\t    && GET_CODE (v->add_val) == CONST_INT\n-\t\t    && validate_change (insn, &XEXP (x, arg_operand),\n-\t\t\t\t\tGEN_INT (INTVAL (arg)\n-\t\t\t\t\t\t * INTVAL (v->mult_val)\n-\t\t\t\t\t\t + INTVAL (v->add_val)), 0))\n-\t\t  return 1;\n-\n-\t\t/* Otherwise, load it into a register.  */\n-\t\ttem = gen_reg_rtx (mode);\n-\t\temit_iv_add_mult (arg, v->mult_val, v->add_val, tem, where);\n-\t\tif (validate_change (insn, &XEXP (x, arg_operand), tem, 0))\n+\t\t    && GET_CODE (v->add_val) == CONST_INT)\n+\t\t  {\n+\t\t    validate_change (insn, &XEXP (x, arg_operand),\n+\t\t\t\t     GEN_INT (INTVAL (arg)\n+\t\t\t\t\t     * INTVAL (v->mult_val)\n+\t\t\t\t\t     + INTVAL (v->add_val)), 1);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    /* Otherwise, load it into a register.  */\n+\t\t    tem = gen_reg_rtx (mode);\n+\t\t    emit_iv_add_mult (arg, v->mult_val, v->add_val, tem, where);\n+\t\t    validate_change (insn, &XEXP (x, arg_operand), tem, 1);\n+\t\t  }\n+\t\tif (apply_change_group ())\n \t\t  return 1;\n-\n-\t\t/* If that failed, put back the change we made above.  */\n-\t\tXEXP (x, 1-arg_operand) = reg;\n \t      }\n \t  \n \t  /* Look for giv with positive constant mult_val and nonconst add_val.\n \t     Insert insns to calculate new compare value.  \n \t     ??? Turn this off due to possible overflow.  */\n \n \t  for (v = bl->giv; v; v = v->next_iv)\n-\t    if (CONSTANT_P (v->mult_val) && INTVAL (v->mult_val) > 0\n+\t    if (GET_CODE (v->mult_val) == CONST_INT && INTVAL (v->mult_val) > 0\n \t\t&& ! v->ignore && ! v->maybe_dead && v->always_computable\n \t\t&& v->mode == mode\n \t\t&& 0)\n@@ -8707,7 +8708,7 @@ maybe_eliminate_biv_1 (loop, x, insn, bl, eliminate_p, where)\n \t\t ??? Turn this off due to possible overflow.  */\n \n \t      for (v = bl->giv; v; v = v->next_iv)\n-\t\tif (CONSTANT_P (v->mult_val) && INTVAL (v->mult_val) > 0\n+\t\tif (GET_CODE (v->mult_val) == CONST_INT && INTVAL (v->mult_val) > 0\n \t\t    && ! v->ignore && ! v->maybe_dead && v->always_computable\n \t\t    && v->mode == mode\n \t\t    && 0)"}]}