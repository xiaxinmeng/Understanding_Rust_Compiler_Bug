{"sha": "84096498a7bd788599d4a7ca63543fc7c297645e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQwOTY0OThhN2JkNzg4NTk5ZDRhN2NhNjM1NDNmYzdjMjk3NjQ1ZQ==", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "eddyb@lyken.rs", "date": "2020-11-13T18:55:45Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-11-13T18:59:09Z"}, "message": "libiberty: Support the new (\"v0\") mangling scheme in rust-demangle\n\nThis is the libiberty (mainly for binutils/gdb) counterpart of\nhttps://github.com/alexcrichton/rustc-demangle/pull/23.\n\nRelevant links for the new Rust mangling scheme (aka \"v0\"):\n* Rust RFC: https://github.com/rust-lang/rfcs/pull/2603\n* tracking issue: https://github.com/rust-lang/rust/issues/60705\n* implementation: https://github.com/rust-lang/rust/pull/57967\n\nThis implementation includes full support for UTF-8 identifiers\nvia punycode, so I've included a testcase for that as well.\n\nlibiberty/ChangeLog:\n\t* rust-demangle.c (struct rust_demangler): Add\n\tskipping_printing and bound_lifetime_depth fields.\n\t(eat): Add (v0-only).\n\t(parse_integer_62): Add (v0-only).\n\t(parse_opt_integer_62): Add (v0-only).\n\t(parse_disambiguator): Add (v0-only).\n\t(struct rust_mangled_ident): Add punycode{,_len} fields.\n\t(parse_ident): Support v0 identifiers.\n\t(print_str): Respect skipping_printing.\n\t(print_uint64): Add (v0-only).\n\t(print_uint64_hex): Add (v0-only).\n\t(print_ident): Respect skipping_printing,\n\tSupport v0 identifiers.\n\t(print_lifetime_from_index): Add (v0-only).\n\t(demangle_binder): Add (v0-only).\n\t(demangle_path): Add (v0-only).\n\t(demangle_generic_arg): Add (v0-only).\n\t(demangle_type): Add (v0-only).\n\t(demangle_path_maybe_open_generics): Add (v0-only).\n\t(demangle_dyn_trait): Add (v0-only).\n\t(demangle_const): Add (v0-only).\n\t(demangle_const_uint): Add (v0-only).\n\t(basic_type): Add (v0-only).\n\t(rust_demangle_callback): Support v0 symbols.\n\t* testsuite/rust-demangle-expected: Add v0 testcases.", "tree": {"sha": "a3186f3bef31f1cee7f33615a618a722f2a540db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3186f3bef31f1cee7f33615a618a722f2a540db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84096498a7bd788599d4a7ca63543fc7c297645e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84096498a7bd788599d4a7ca63543fc7c297645e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84096498a7bd788599d4a7ca63543fc7c297645e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84096498a7bd788599d4a7ca63543fc7c297645e/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16b00dc63f6106fe0964716ddca9af8a29fbf453", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16b00dc63f6106fe0964716ddca9af8a29fbf453", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16b00dc63f6106fe0964716ddca9af8a29fbf453"}], "stats": {"total": 1144, "additions": 1133, "deletions": 11}, "files": [{"sha": "08c615f6d8bbcf5c52c22bceb941fcc9f26bc770", "filename": "libiberty/rust-demangle.c", "status": "modified", "additions": 1000, "deletions": 10, "changes": 1010, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84096498a7bd788599d4a7ca63543fc7c297645e/libiberty%2Frust-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84096498a7bd788599d4a7ca63543fc7c297645e/libiberty%2Frust-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Frust-demangle.c?ref=84096498a7bd788599d4a7ca63543fc7c297645e", "patch": "@@ -1,6 +1,7 @@\n /* Demangler for the Rust programming language\n    Copyright (C) 2016-2020 Free Software Foundation, Inc.\n    Written by David Tolnay (dtolnay@gmail.com).\n+   Rewritten by Eduard-Mihai Burtescu (eddyb@lyken.rs) for v0 support.\n \n This file is part of the libiberty library.\n Libiberty is free software; you can redistribute it and/or\n@@ -64,11 +65,16 @@ struct rust_demangler\n   /* Non-zero if any error occurred. */\n   int errored;\n \n+  /* Non-zero if nothing should be printed. */\n+  int skipping_printing;\n+\n   /* Non-zero if printing should be verbose (e.g. include hashes). */\n   int verbose;\n \n   /* Rust mangling version, with legacy mangling being -1. */\n   int version;\n+\n+  uint64_t bound_lifetime_depth;\n };\n \n /* Parsing functions. */\n@@ -81,6 +87,18 @@ peek (const struct rust_demangler *rdm)\n   return 0;\n }\n \n+static int\n+eat (struct rust_demangler *rdm, char c)\n+{\n+  if (peek (rdm) == c)\n+    {\n+      rdm->next++;\n+      return 1;\n+    }\n+  else\n+    return 0;\n+}\n+\n static char\n next (struct rust_demangler *rdm)\n {\n@@ -92,22 +110,104 @@ next (struct rust_demangler *rdm)\n   return c;\n }\n \n+static uint64_t\n+parse_integer_62 (struct rust_demangler *rdm)\n+{\n+  char c;\n+  uint64_t x;\n+\n+  if (eat (rdm, '_'))\n+    return 0;\n+\n+  x = 0;\n+  while (!eat (rdm, '_'))\n+    {\n+      c = next (rdm);\n+      x *= 62;\n+      if (ISDIGIT (c))\n+        x += c - '0';\n+      else if (ISLOWER (c))\n+        x += 10 + (c - 'a');\n+      else if (ISUPPER (c))\n+        x += 10 + 26 + (c - 'A');\n+      else\n+        {\n+          rdm->errored = 1;\n+          return 0;\n+        }\n+    }\n+  return x + 1;\n+}\n+\n+static uint64_t\n+parse_opt_integer_62 (struct rust_demangler *rdm, char tag)\n+{\n+  if (!eat (rdm, tag))\n+    return 0;\n+  return 1 + parse_integer_62 (rdm);\n+}\n+\n+static uint64_t\n+parse_disambiguator (struct rust_demangler *rdm)\n+{\n+  return parse_opt_integer_62 (rdm, 's');\n+}\n+\n+static size_t\n+parse_hex_nibbles (struct rust_demangler *rdm, uint64_t *value)\n+{\n+  char c;\n+  size_t hex_len;\n+\n+  hex_len = 0;\n+  *value = 0;\n+\n+  while (!eat (rdm, '_'))\n+    {\n+      *value <<= 4;\n+\n+      c = next (rdm);\n+      if (ISDIGIT (c))\n+        *value |= c - '0';\n+      else if (c >= 'a' && c <= 'f')\n+        *value |= 10 + (c - 'a');\n+      else\n+        {\n+          rdm->errored = 1;\n+          return 0;\n+        }\n+      hex_len++;\n+    }\n+\n+  return hex_len;\n+}\n+\n struct rust_mangled_ident\n {\n   /* ASCII part of the identifier. */\n   const char *ascii;\n   size_t ascii_len;\n+\n+  /* Punycode insertion codes for Unicode codepoints, if any. */\n+  const char *punycode;\n+  size_t punycode_len;\n };\n \n static struct rust_mangled_ident\n parse_ident (struct rust_demangler *rdm)\n {\n   char c;\n   size_t start, len;\n+  int is_punycode = 0;\n   struct rust_mangled_ident ident;\n \n   ident.ascii = NULL;\n   ident.ascii_len = 0;\n+  ident.punycode = NULL;\n+  ident.punycode_len = 0;\n+\n+  if (rdm->version != -1)\n+    is_punycode = eat (rdm, 'u');\n \n   c = next (rdm);\n   if (!ISDIGIT (c))\n@@ -121,6 +221,10 @@ parse_ident (struct rust_demangler *rdm)\n     while (ISDIGIT (peek (rdm)))\n       len = len * 10 + (next (rdm) - '0');\n \n+  /* Skip past the optional `_` separator (v0). */\n+  if (rdm->version != -1)\n+    eat (rdm, '_');\n+\n   start = rdm->next;\n   rdm->next += len;\n   /* Check for overflows. */\n@@ -133,6 +237,27 @@ parse_ident (struct rust_demangler *rdm)\n   ident.ascii = rdm->sym + start;\n   ident.ascii_len = len;\n \n+  if (is_punycode)\n+    {\n+      ident.punycode_len = 0;\n+      while (ident.ascii_len > 0)\n+        {\n+          ident.ascii_len--;\n+\n+          /* The last '_' is a separator between ascii & punycode. */\n+          if (ident.ascii[ident.ascii_len] == '_')\n+            break;\n+\n+          ident.punycode_len++;\n+        }\n+      if (!ident.punycode_len)\n+        {\n+          rdm->errored = 1;\n+          return ident;\n+        }\n+      ident.punycode = ident.ascii + (len - ident.punycode_len);\n+    }\n+\n   if (ident.ascii_len == 0)\n     ident.ascii = NULL;\n \n@@ -144,12 +269,28 @@ parse_ident (struct rust_demangler *rdm)\n static void\n print_str (struct rust_demangler *rdm, const char *data, size_t len)\n {\n-  if (!rdm->errored)\n+  if (!rdm->errored && !rdm->skipping_printing)\n     rdm->callback (data, len, rdm->callback_opaque);\n }\n \n #define PRINT(s) print_str (rdm, s, strlen (s))\n \n+static void\n+print_uint64 (struct rust_demangler *rdm, uint64_t x)\n+{\n+  char s[21];\n+  snprintf (s, 21, \"%\" PRIu64, x);\n+  PRINT (s);\n+}\n+\n+static void\n+print_uint64_hex (struct rust_demangler *rdm, uint64_t x)\n+{\n+  char s[17];\n+  snprintf (s, 17, \"%\" PRIx64, x);\n+  PRINT (s);\n+}\n+\n /* Return a 0x0-0xf value if the char is 0-9a-f, and -1 otherwise. */\n static int\n decode_lower_hex_nibble (char nibble)\n@@ -230,9 +371,14 @@ static void\n print_ident (struct rust_demangler *rdm, struct rust_mangled_ident ident)\n {\n   char unescaped;\n-  size_t len;\n-\n-  if (rdm->errored)\n+  uint8_t *out, *p, d;\n+  size_t len, cap, punycode_pos, j;\n+  /* Punycode parameters and state. */\n+  uint32_t c;\n+  size_t base, t_min, t_max, skew, damp, bias, i;\n+  size_t delta, w, k, t;\n+\n+  if (rdm->errored || rdm->skipping_printing)\n     return;\n \n   if (rdm->version == -1)\n@@ -273,8 +419,7 @@ print_ident (struct rust_demangler *rdm, struct rust_mangled_ident ident)\n                 }\n               else\n                 {\n-                  /* \".\" becomes \"-\" */\n-                  PRINT (\"-\");\n+                  PRINT (\".\");\n                   len = 1;\n                 }\n             }\n@@ -294,6 +439,830 @@ print_ident (struct rust_demangler *rdm, struct rust_mangled_ident ident)\n \n       return;\n     }\n+\n+  if (!ident.punycode)\n+    {\n+      print_str (rdm, ident.ascii, ident.ascii_len);\n+      return;\n+    }\n+\n+  len = 0;\n+  cap = 4;\n+  while (cap < ident.ascii_len)\n+    {\n+      cap *= 2;\n+      /* Check for overflows. */\n+      if ((cap * 4) / 4 != cap)\n+        {\n+          rdm->errored = 1;\n+          return;\n+        }\n+    }\n+\n+  /* Store the output codepoints as groups of 4 UTF-8 bytes. */\n+  out = (uint8_t *)malloc (cap * 4);\n+  if (!out)\n+    {\n+      rdm->errored = 1;\n+      return;\n+    }\n+\n+  /* Populate initial output from ASCII fragment. */\n+  for (len = 0; len < ident.ascii_len; len++)\n+    {\n+      p = out + 4 * len;\n+      p[0] = 0;\n+      p[1] = 0;\n+      p[2] = 0;\n+      p[3] = ident.ascii[len];\n+    }\n+\n+  /* Punycode parameters and initial state. */\n+  base = 36;\n+  t_min = 1;\n+  t_max = 26;\n+  skew = 38;\n+  damp = 700;\n+  bias = 72;\n+  i = 0;\n+  c = 0x80;\n+\n+  punycode_pos = 0;\n+  while (punycode_pos < ident.punycode_len)\n+    {\n+      /* Read one delta value. */\n+      delta = 0;\n+      w = 1;\n+      k = 0;\n+      do\n+        {\n+          k += base;\n+          t = k < bias ? 0 : (k - bias);\n+          if (t < t_min)\n+            t = t_min;\n+          if (t > t_max)\n+            t = t_max;\n+\n+          if (punycode_pos >= ident.punycode_len)\n+            goto cleanup;\n+          d = ident.punycode[punycode_pos++];\n+\n+          if (ISLOWER (d))\n+            d = d - 'a';\n+          else if (ISDIGIT (d))\n+            d = 26 + (d - '0');\n+          else\n+            {\n+              rdm->errored = 1;\n+              goto cleanup;\n+            }\n+\n+          delta += d * w;\n+          w *= base - t;\n+        }\n+      while (d >= t);\n+\n+      /* Compute the new insert position and character. */\n+      len++;\n+      i += delta;\n+      c += i / len;\n+      i %= len;\n+\n+      /* Ensure enough space is available. */\n+      if (cap < len)\n+        {\n+          cap *= 2;\n+          /* Check for overflows. */\n+          if ((cap * 4) / 4 != cap || cap < len)\n+            {\n+              rdm->errored = 1;\n+              goto cleanup;\n+            }\n+        }\n+      p = (uint8_t *)realloc (out, cap * 4);\n+      if (!p)\n+        {\n+          rdm->errored = 1;\n+          goto cleanup;\n+        }\n+      out = p;\n+\n+      /* Move the characters after the insert position. */\n+      p = out + i * 4;\n+      memmove (p + 4, p, (len - i - 1) * 4);\n+\n+      /* Insert the new character, as UTF-8 bytes. */\n+      p[0] = c >= 0x10000 ? 0xf0 | (c >> 18) : 0;\n+      p[1] = c >= 0x800 ? (c < 0x10000 ? 0xe0 : 0x80) | ((c >> 12) & 0x3f) : 0;\n+      p[2] = (c < 0x800 ? 0xc0 : 0x80) | ((c >> 6) & 0x3f);\n+      p[3] = 0x80 | (c & 0x3f);\n+\n+      /* If there are no more deltas, decoding is complete. */\n+      if (punycode_pos == ident.punycode_len)\n+        break;\n+\n+      i++;\n+\n+      /* Perform bias adaptation. */\n+      delta /= damp;\n+      damp = 2;\n+\n+      delta += delta / len;\n+      k = 0;\n+      while (delta > ((base - t_min) * t_max) / 2)\n+        {\n+          delta /= base - t_min;\n+          k += base;\n+        }\n+      bias = k + ((base - t_min + 1) * delta) / (delta + skew);\n+    }\n+\n+  /* Remove all the 0 bytes to leave behind an UTF-8 string. */\n+  for (i = 0, j = 0; i < len * 4; i++)\n+    if (out[i] != 0)\n+      out[j++] = out[i];\n+\n+  print_str (rdm, (const char *)out, j);\n+\n+cleanup:\n+  free (out);\n+}\n+\n+/* Print the lifetime according to the previously decoded index.\n+   An index of `0` always refers to `'_`, but starting with `1`,\n+   indices refer to late-bound lifetimes introduced by a binder. */\n+static void\n+print_lifetime_from_index (struct rust_demangler *rdm, uint64_t lt)\n+{\n+  char c;\n+  uint64_t depth;\n+\n+  PRINT (\"'\");\n+  if (lt == 0)\n+    {\n+      PRINT (\"_\");\n+      return;\n+    }\n+\n+  depth = rdm->bound_lifetime_depth - lt;\n+  /* Try to print lifetimes alphabetically first. */\n+  if (depth < 26)\n+    {\n+      c = 'a' + depth;\n+      print_str (rdm, &c, 1);\n+    }\n+  else\n+    {\n+      /* Use `'_123` after running out of letters. */\n+      PRINT (\"_\");\n+      print_uint64 (rdm, depth);\n+    }\n+}\n+\n+/* Demangling functions. */\n+\n+static void demangle_binder (struct rust_demangler *rdm);\n+static void demangle_path (struct rust_demangler *rdm, int in_value);\n+static void demangle_generic_arg (struct rust_demangler *rdm);\n+static void demangle_type (struct rust_demangler *rdm);\n+static int demangle_path_maybe_open_generics (struct rust_demangler *rdm);\n+static void demangle_dyn_trait (struct rust_demangler *rdm);\n+static void demangle_const (struct rust_demangler *rdm);\n+static void demangle_const_uint (struct rust_demangler *rdm);\n+static void demangle_const_int (struct rust_demangler *rdm);\n+static void demangle_const_bool (struct rust_demangler *rdm);\n+static void demangle_const_char (struct rust_demangler *rdm);\n+\n+/* Optionally enter a binder ('G') for late-bound lifetimes,\n+   printing e.g. `for<'a, 'b> `, and make those lifetimes visible\n+   to the caller (via depth level, which the caller should reset). */\n+static void\n+demangle_binder (struct rust_demangler *rdm)\n+{\n+  uint64_t i, bound_lifetimes;\n+\n+  if (rdm->errored)\n+    return;\n+\n+  bound_lifetimes = parse_opt_integer_62 (rdm, 'G');\n+  if (bound_lifetimes > 0)\n+    {\n+      PRINT (\"for<\");\n+      for (i = 0; i < bound_lifetimes; i++)\n+        {\n+          if (i > 0)\n+            PRINT (\", \");\n+          rdm->bound_lifetime_depth++;\n+          print_lifetime_from_index (rdm, 1);\n+        }\n+      PRINT (\"> \");\n+    }\n+}\n+\n+static void\n+demangle_path (struct rust_demangler *rdm, int in_value)\n+{\n+  char tag, ns;\n+  int was_skipping_printing;\n+  size_t i, backref, old_next;\n+  uint64_t dis;\n+  struct rust_mangled_ident name;\n+\n+  if (rdm->errored)\n+    return;\n+\n+  switch (tag = next (rdm))\n+    {\n+    case 'C':\n+      dis = parse_disambiguator (rdm);\n+      name = parse_ident (rdm);\n+\n+      print_ident (rdm, name);\n+      if (rdm->verbose)\n+        {\n+          PRINT (\"[\");\n+          print_uint64_hex (rdm, dis);\n+          PRINT (\"]\");\n+        }\n+      break;\n+    case 'N':\n+      ns = next (rdm);\n+      if (!ISLOWER (ns) && !ISUPPER (ns))\n+        {\n+          rdm->errored = 1;\n+          return;\n+        }\n+\n+      demangle_path (rdm, in_value);\n+\n+      dis = parse_disambiguator (rdm);\n+      name = parse_ident (rdm);\n+\n+      if (ISUPPER (ns))\n+        {\n+          /* Special namespaces, like closures and shims. */\n+          PRINT (\"::{\");\n+          switch (ns)\n+            {\n+            case 'C':\n+              PRINT (\"closure\");\n+              break;\n+            case 'S':\n+              PRINT (\"shim\");\n+              break;\n+            default:\n+              print_str (rdm, &ns, 1);\n+            }\n+          if (name.ascii || name.punycode)\n+            {\n+              PRINT (\":\");\n+              print_ident (rdm, name);\n+            }\n+          PRINT (\"#\");\n+          print_uint64 (rdm, dis);\n+          PRINT (\"}\");\n+        }\n+      else\n+        {\n+          /* Implementation-specific/unspecified namespaces. */\n+\n+          if (name.ascii || name.punycode)\n+            {\n+              PRINT (\"::\");\n+              print_ident (rdm, name);\n+            }\n+        }\n+      break;\n+    case 'M':\n+    case 'X':\n+      /* Ignore the `impl`'s own path.*/\n+      parse_disambiguator (rdm);\n+      was_skipping_printing = rdm->skipping_printing;\n+      rdm->skipping_printing = 1;\n+      demangle_path (rdm, in_value);\n+      rdm->skipping_printing = was_skipping_printing;\n+      /* fallthrough */\n+    case 'Y':\n+      PRINT (\"<\");\n+      demangle_type (rdm);\n+      if (tag != 'M')\n+        {\n+          PRINT (\" as \");\n+          demangle_path (rdm, 0);\n+        }\n+      PRINT (\">\");\n+      break;\n+    case 'I':\n+      demangle_path (rdm, in_value);\n+      if (in_value)\n+        PRINT (\"::\");\n+      PRINT (\"<\");\n+      for (i = 0; !rdm->errored && !eat (rdm, 'E'); i++)\n+        {\n+          if (i > 0)\n+            PRINT (\", \");\n+          demangle_generic_arg (rdm);\n+        }\n+      PRINT (\">\");\n+      break;\n+    case 'B':\n+      backref = parse_integer_62 (rdm);\n+      if (!rdm->skipping_printing)\n+        {\n+          old_next = rdm->next;\n+          rdm->next = backref;\n+          demangle_path (rdm, in_value);\n+          rdm->next = old_next;\n+        }\n+      break;\n+    default:\n+      rdm->errored = 1;\n+      return;\n+    }\n+}\n+\n+static void\n+demangle_generic_arg (struct rust_demangler *rdm)\n+{\n+  uint64_t lt;\n+  if (eat (rdm, 'L'))\n+    {\n+      lt = parse_integer_62 (rdm);\n+      print_lifetime_from_index (rdm, lt);\n+    }\n+  else if (eat (rdm, 'K'))\n+    demangle_const (rdm);\n+  else\n+    demangle_type (rdm);\n+}\n+\n+static const char *\n+basic_type (char tag)\n+{\n+  switch (tag)\n+    {\n+    case 'b':\n+      return \"bool\";\n+    case 'c':\n+      return \"char\";\n+    case 'e':\n+      return \"str\";\n+    case 'u':\n+      return \"()\";\n+    case 'a':\n+      return \"i8\";\n+    case 's':\n+      return \"i16\";\n+    case 'l':\n+      return \"i32\";\n+    case 'x':\n+      return \"i64\";\n+    case 'n':\n+      return \"i128\";\n+    case 'i':\n+      return \"isize\";\n+    case 'h':\n+      return \"u8\";\n+    case 't':\n+      return \"u16\";\n+    case 'm':\n+      return \"u32\";\n+    case 'y':\n+      return \"u64\";\n+    case 'o':\n+      return \"u128\";\n+    case 'j':\n+      return \"usize\";\n+    case 'f':\n+      return \"f32\";\n+    case 'd':\n+      return \"f64\";\n+    case 'z':\n+      return \"!\";\n+    case 'p':\n+      return \"_\";\n+    case 'v':\n+      return \"...\";\n+\n+    default:\n+      return NULL;\n+    }\n+}\n+\n+static void\n+demangle_type (struct rust_demangler *rdm)\n+{\n+  char tag;\n+  size_t i, old_next, backref;\n+  uint64_t lt, old_bound_lifetime_depth;\n+  const char *basic;\n+  struct rust_mangled_ident abi;\n+\n+  if (rdm->errored)\n+    return;\n+\n+  tag = next (rdm);\n+\n+  basic = basic_type (tag);\n+  if (basic)\n+    {\n+      PRINT (basic);\n+      return;\n+    }\n+\n+  switch (tag)\n+    {\n+    case 'R':\n+    case 'Q':\n+      PRINT (\"&\");\n+      if (eat (rdm, 'L'))\n+        {\n+          lt = parse_integer_62 (rdm);\n+          if (lt)\n+            {\n+              print_lifetime_from_index (rdm, lt);\n+              PRINT (\" \");\n+            }\n+        }\n+      if (tag != 'R')\n+        PRINT (\"mut \");\n+      demangle_type (rdm);\n+      break;\n+    case 'P':\n+    case 'O':\n+      PRINT (\"*\");\n+      if (tag != 'P')\n+        PRINT (\"mut \");\n+      else\n+        PRINT (\"const \");\n+      demangle_type (rdm);\n+      break;\n+    case 'A':\n+    case 'S':\n+      PRINT (\"[\");\n+      demangle_type (rdm);\n+      if (tag == 'A')\n+        {\n+          PRINT (\"; \");\n+          demangle_const (rdm);\n+        }\n+      PRINT (\"]\");\n+      break;\n+    case 'T':\n+      PRINT (\"(\");\n+      for (i = 0; !rdm->errored && !eat (rdm, 'E'); i++)\n+        {\n+          if (i > 0)\n+            PRINT (\", \");\n+          demangle_type (rdm);\n+        }\n+      if (i == 1)\n+        PRINT (\",\");\n+      PRINT (\")\");\n+      break;\n+    case 'F':\n+      old_bound_lifetime_depth = rdm->bound_lifetime_depth;\n+      demangle_binder (rdm);\n+\n+      if (eat (rdm, 'U'))\n+        PRINT (\"unsafe \");\n+\n+      if (eat (rdm, 'K'))\n+        {\n+          if (eat (rdm, 'C'))\n+            {\n+              abi.ascii = \"C\";\n+              abi.ascii_len = 1;\n+            }\n+          else\n+            {\n+              abi = parse_ident (rdm);\n+              if (!abi.ascii || abi.punycode)\n+                {\n+                  rdm->errored = 1;\n+                  goto restore;\n+                }\n+            }\n+\n+          PRINT (\"extern \\\"\");\n+\n+          /* If the ABI had any `-`, they were replaced with `_`,\n+             so the parts between `_` have to be re-joined with `-`. */\n+          for (i = 0; i < abi.ascii_len; i++)\n+            {\n+              if (abi.ascii[i] == '_')\n+                {\n+                  print_str (rdm, abi.ascii, i);\n+                  PRINT (\"-\");\n+                  abi.ascii += i + 1;\n+                  abi.ascii_len -= i + 1;\n+                  i = 0;\n+                }\n+            }\n+          print_str (rdm, abi.ascii, abi.ascii_len);\n+\n+          PRINT (\"\\\" \");\n+        }\n+\n+      PRINT (\"fn(\");\n+      for (i = 0; !rdm->errored && !eat (rdm, 'E'); i++)\n+        {\n+          if (i > 0)\n+            PRINT (\", \");\n+          demangle_type (rdm);\n+        }\n+      PRINT (\")\");\n+\n+      if (eat (rdm, 'u'))\n+        {\n+          /* Skip printing the return type if it's 'u', i.e. `()`. */\n+        }\n+      else\n+        {\n+          PRINT (\" -> \");\n+          demangle_type (rdm);\n+        }\n+\n+    /* Restore `bound_lifetime_depth` to outside the binder. */\n+    restore:\n+      rdm->bound_lifetime_depth = old_bound_lifetime_depth;\n+      break;\n+    case 'D':\n+      PRINT (\"dyn \");\n+\n+      old_bound_lifetime_depth = rdm->bound_lifetime_depth;\n+      demangle_binder (rdm);\n+\n+      for (i = 0; !rdm->errored && !eat (rdm, 'E'); i++)\n+        {\n+          if (i > 0)\n+            PRINT (\" + \");\n+          demangle_dyn_trait (rdm);\n+        }\n+\n+      /* Restore `bound_lifetime_depth` to outside the binder. */\n+      rdm->bound_lifetime_depth = old_bound_lifetime_depth;\n+\n+      if (!eat (rdm, 'L'))\n+        {\n+          rdm->errored = 1;\n+          return;\n+        }\n+      lt = parse_integer_62 (rdm);\n+      if (lt)\n+        {\n+          PRINT (\" + \");\n+          print_lifetime_from_index (rdm, lt);\n+        }\n+      break;\n+    case 'B':\n+      backref = parse_integer_62 (rdm);\n+      if (!rdm->skipping_printing)\n+        {\n+          old_next = rdm->next;\n+          rdm->next = backref;\n+          demangle_type (rdm);\n+          rdm->next = old_next;\n+        }\n+      break;\n+    default:\n+      /* Go back to the tag, so `demangle_path` also sees it. */\n+      rdm->next--;\n+      demangle_path (rdm, 0);\n+    }\n+}\n+\n+/* A trait in a trait object may have some \"existential projections\"\n+   (i.e. associated type bindings) after it, which should be printed\n+   in the `<...>` of the trait, e.g. `dyn Trait<T, U, Assoc=X>`.\n+   To this end, this method will keep the `<...>` of an 'I' path\n+   open, by omitting the `>`, and return `Ok(true)` in that case. */\n+static int\n+demangle_path_maybe_open_generics (struct rust_demangler *rdm)\n+{\n+  int open;\n+  size_t i, old_next, backref;\n+\n+  open = 0;\n+\n+  if (rdm->errored)\n+    return open;\n+\n+  if (eat (rdm, 'B'))\n+    {\n+      backref = parse_integer_62 (rdm);\n+      if (!rdm->skipping_printing)\n+        {\n+          old_next = rdm->next;\n+          rdm->next = backref;\n+          open = demangle_path_maybe_open_generics (rdm);\n+          rdm->next = old_next;\n+        }\n+    }\n+  else if (eat (rdm, 'I'))\n+    {\n+      demangle_path (rdm, 0);\n+      PRINT (\"<\");\n+      open = 1;\n+      for (i = 0; !rdm->errored && !eat (rdm, 'E'); i++)\n+        {\n+          if (i > 0)\n+            PRINT (\", \");\n+          demangle_generic_arg (rdm);\n+        }\n+    }\n+  else\n+    demangle_path (rdm, 0);\n+  return open;\n+}\n+\n+static void\n+demangle_dyn_trait (struct rust_demangler *rdm)\n+{\n+  int open;\n+  struct rust_mangled_ident name;\n+\n+  if (rdm->errored)\n+    return;\n+\n+  open = demangle_path_maybe_open_generics (rdm);\n+\n+  while (eat (rdm, 'p'))\n+    {\n+      if (!open)\n+        PRINT (\"<\");\n+      else\n+        PRINT (\", \");\n+      open = 1;\n+\n+      name = parse_ident (rdm);\n+      print_ident (rdm, name);\n+      PRINT (\" = \");\n+      demangle_type (rdm);\n+    }\n+\n+  if (open)\n+    PRINT (\">\");\n+}\n+\n+static void\n+demangle_const (struct rust_demangler *rdm)\n+{\n+  char ty_tag;\n+  size_t old_next, backref;\n+\n+  if (rdm->errored)\n+    return;\n+\n+  if (eat (rdm, 'B'))\n+    {\n+      backref = parse_integer_62 (rdm);\n+      if (!rdm->skipping_printing)\n+        {\n+          old_next = rdm->next;\n+          rdm->next = backref;\n+          demangle_const (rdm);\n+          rdm->next = old_next;\n+        }\n+      return;\n+    }\n+\n+  ty_tag = next (rdm);\n+  switch (ty_tag)\n+    {\n+    /* Placeholder. */\n+    case 'p':\n+      PRINT (\"_\");\n+      return;\n+\n+    /* Unsigned integer types. */\n+    case 'h':\n+    case 't':\n+    case 'm':\n+    case 'y':\n+    case 'o':\n+    case 'j':\n+      demangle_const_uint (rdm);\n+      break;\n+\n+    /* Signed integer types. */\n+    case 'a':\n+    case 's':\n+    case 'l':\n+    case 'x':\n+    case 'n':\n+    case 'i':\n+      demangle_const_int (rdm);\n+      break;\n+\n+    /* Boolean. */\n+    case 'b':\n+      demangle_const_bool (rdm);\n+      break;\n+\n+    /* Character. */\n+    case 'c':\n+      demangle_const_char (rdm);\n+      break;\n+\n+    default:\n+      rdm->errored = 1;\n+      return;\n+    }\n+\n+  if (rdm->errored)\n+    return;\n+\n+  if (rdm->verbose)\n+    {\n+      PRINT (\": \");\n+      PRINT (basic_type (ty_tag));\n+    }\n+}\n+\n+static void\n+demangle_const_uint (struct rust_demangler *rdm)\n+{\n+  size_t hex_len;\n+  uint64_t value;\n+\n+  if (rdm->errored)\n+    return;\n+\n+  hex_len = parse_hex_nibbles (rdm, &value);\n+\n+  if (hex_len > 16)\n+    {\n+      /* Print anything that doesn't fit in `uint64_t` verbatim. */\n+      PRINT (\"0x\");\n+      print_str (rdm, rdm->sym + (rdm->next - hex_len), hex_len);\n+    }\n+  else if (hex_len > 0)\n+    print_uint64 (rdm, value);\n+  else\n+    rdm->errored = 1;\n+}\n+\n+static void\n+demangle_const_int (struct rust_demangler *rdm)\n+{\n+  if (eat (rdm, 'n'))\n+    PRINT (\"-\");\n+  demangle_const_uint (rdm);\n+}\n+\n+static void\n+demangle_const_bool (struct rust_demangler *rdm)\n+{\n+  uint64_t value;\n+\n+  if (parse_hex_nibbles (rdm, &value) != 1)\n+    {\n+      rdm->errored = 1;\n+      return;\n+    }\n+\n+  if (value == 0)\n+    PRINT (\"false\");\n+  else if (value == 1)\n+    PRINT (\"true\");\n+  else\n+    rdm->errored = 1;\n+}\n+\n+static void\n+demangle_const_char (struct rust_demangler *rdm)\n+{\n+  size_t hex_len;\n+  uint64_t value;\n+\n+  hex_len = parse_hex_nibbles (rdm, &value);\n+\n+  if (hex_len == 0 || hex_len > 8)\n+    {\n+      rdm->errored = 1;\n+      return;\n+    }\n+\n+  /* Match Rust's character \"debug\" output as best as we can. */\n+  PRINT (\"'\");\n+  if (value == '\\t')\n+    PRINT (\"\\\\t\");\n+  else if (value == '\\r')\n+    PRINT (\"\\\\r\");\n+  else if (value == '\\n')\n+    PRINT (\"\\\\n\");\n+  else if (value > ' ' && value < '~')\n+    /* Rust also considers many non-ASCII codepoints to be printable, but\n+       that logic is not easily ported to C. */\n+    print_str (rdm, (char *) &value, 1);\n+  else\n+    {\n+      PRINT (\"\\\\u{\");\n+      print_uint64_hex (rdm, value);\n+      PRINT (\"}\");\n+    }\n+  PRINT (\"'\");\n }\n \n /* A legacy hash is the prefix \"h\" followed by 16 lowercase hex digits.\n@@ -345,26 +1314,35 @@ rust_demangle_callback (const char *mangled, int options,\n \n   rdm.next = 0;\n   rdm.errored = 0;\n+  rdm.skipping_printing = 0;\n   rdm.verbose = (options & DMGL_VERBOSE) != 0;\n   rdm.version = 0;\n+  rdm.bound_lifetime_depth = 0;\n \n-  /* Rust symbols always start with _ZN (legacy). */\n-  if (rdm.sym[0] == '_' && rdm.sym[1] == 'Z' && rdm.sym[2] == 'N')\n+  /* Rust symbols always start with _R (v0) or _ZN (legacy). */\n+  if (rdm.sym[0] == '_' && rdm.sym[1] == 'R')\n+    rdm.sym += 2;\n+  else if (rdm.sym[0] == '_' && rdm.sym[1] == 'Z' && rdm.sym[2] == 'N')\n     {\n       rdm.sym += 3;\n       rdm.version = -1;\n     }\n   else\n     return 0;\n \n-  /* Legacy Rust symbols use only [_0-9a-zA-Z.:$] characters. */\n+  /* Paths (v0) always start with uppercase characters. */\n+  if (rdm.version != -1 && !ISUPPER (rdm.sym[0]))\n+    return 0;\n+\n+  /* Rust symbols (v0) use only [_0-9a-zA-Z] characters. */\n   for (p = rdm.sym; *p; p++)\n     {\n       rdm.sym_len++;\n \n       if (*p == '_' || ISALNUM (*p))\n         continue;\n \n+      /* Legacy Rust symbols can also contain [.:$] characters. */\n       if (rdm.version == -1 && (*p == '$' || *p == '.' || *p == ':'))\n         continue;\n \n@@ -418,7 +1396,19 @@ rust_demangle_callback (const char *mangled, int options,\n       while (rdm.next < rdm.sym_len);\n     }\n   else\n-    return 0;\n+    {\n+      demangle_path (&rdm, 1);\n+\n+      /* Skip instantiating crate. */\n+      if (!rdm.errored && rdm.next < rdm.sym_len)\n+        {\n+          rdm.skipping_printing = 1;\n+          demangle_path (&rdm, 0);\n+        }\n+\n+      /* It's an error to not reach the end. */\n+      rdm.errored |= rdm.next != rdm.sym_len;\n+    }\n \n   return !rdm.errored;\n }"}, {"sha": "7dca315d0054801636f1563c19f42da517ad67e0", "filename": "libiberty/testsuite/rust-demangle-expected", "status": "modified", "additions": 133, "deletions": 1, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84096498a7bd788599d4a7ca63543fc7c297645e/libiberty%2Ftestsuite%2Frust-demangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84096498a7bd788599d4a7ca63543fc7c297645e/libiberty%2Ftestsuite%2Frust-demangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Frust-demangle-expected?ref=84096498a7bd788599d4a7ca63543fc7c297645e", "patch": "@@ -11,7 +11,7 @@\n #\n ############\n #\n-# Coverage Tests\n+# Coverage Tests (legacy)\n #\n #\n # Demangles as rust symbol.\n@@ -163,3 +163,135 @@ _ZN63_$LT$core..ptr..Unique$LT$T$GT$$u20$as$u20$core..ops..Deref$GT$5deref17h19f\n --format=rust\n _ZN11issue_609253foo37Foo$LT$issue_60925..llv$u6d$..Foo$GT$3foo17h059a991a004536adE\n issue_60925::foo::Foo<issue_60925::llvm::Foo>::foo\n+--format=rust\n+_ZN4core3ops8function6FnOnce40call_once$u7b$$u7b$vtable.shim$u7d$$u7d$17h000b1ad6c4f30bd6E\n+core::ops::function::FnOnce::call_once{{vtable.shim}}\n+#\n+############\n+#\n+# Coverage Tests (v0)\n+#\n+#\n+# Crate with a leading digit.\n+--format=rust\n+_RNvC6_123foo3bar\n+123foo::bar\n+# UTF-8 identifiers.\n+--format=rust\n+_RNqCs4fqI2P2rA04_11utf8_identsu30____7hkackfecea1cbdathfdh9hlq6y\n+utf8_idents::\u10e1\u10d0\u10ed\u10db\u10d4\u10da\u10d0\u10d3_\u10d2\u10d4\u10db\u10e0\u10d8\u10d4\u10da\u10d8_\u10e1\u10d0\u10d3\u10d8\u10da\u10d8\n+# Closure path elements.\n+--format=rust\n+_RNCNCNgCs6DXkGYLi8lr_2cc5spawn00B5_\n+cc::spawn::{closure#0}::{closure#0}\n+#\n+--format=rust\n+_RNCINkXs25_NgCsbmNqQUJIY6D_4core5sliceINyB9_4IterhENuNgNoBb_4iter8iterator8Iterator9rpositionNCNgNpB9_6memchr7memrchrs_0E0Bb_\n+<core::slice::Iter<u8> as core::iter::iterator::Iterator>::rposition::<core::slice::memchr::memrchr::{closure#1}>::{closure#0}\n+# dyn Trait (\"trait object\") types.\n+--format=rust\n+_RINbNbCskIICzLVDPPb_5alloc5alloc8box_freeDINbNiB4_5boxed5FnBoxuEp6OutputuEL_ECs1iopQbuBiw2_3std\n+alloc::alloc::box_free::<dyn alloc::boxed::FnBox<(), Output = ()>>\n+# Types with const generics parameters.\n+--format=rust\n+_RNvMC0INtC8arrayvec8ArrayVechKj7b_E3new\n+<arrayvec::ArrayVec<u8, 123>>::new\n+#\n+--format=rust\n+_RMCs4fqI2P2rA04_13const_genericINtB0_8UnsignedKhb_E\n+<const_generic::Unsigned<11>>\n+#\n+--format=rust\n+_RMCs4fqI2P2rA04_13const_genericINtB0_6SignedKs98_E\n+<const_generic::Signed<152>>\n+#\n+--format=rust\n+_RMCs4fqI2P2rA04_13const_genericINtB0_6SignedKanb_E\n+<const_generic::Signed<-11>>\n+#\n+--format=rust\n+_RMCs4fqI2P2rA04_13const_genericINtB0_4BoolKb0_E\n+<const_generic::Bool<false>>\n+#\n+--format=rust\n+_RMCs4fqI2P2rA04_13const_genericINtB0_4BoolKb1_E\n+<const_generic::Bool<true>>\n+#\n+--format=rust\n+_RMCs4fqI2P2rA04_13const_genericINtB0_4CharKc76_E\n+<const_generic::Char<'v'>>\n+#\n+--format=rust\n+_RMCs4fqI2P2rA04_13const_genericINtB0_4CharKca_E\n+<const_generic::Char<'\\n'>>\n+#\n+--format=rust\n+_RMCs4fqI2P2rA04_13const_genericINtB0_4CharKc2202_E\n+<const_generic::Char<'\\u{2202}'>>\n+#\n+--format=rust\n+_RNvNvMCs4fqI2P2rA04_13const_genericINtB4_3FooKpE3foo3FOO\n+<const_generic::Foo<_>>::foo::FOO\n+#\n+# All of the tests above but in auto mode instead:\n+#\n+# Crate with a leading digit.\n+--format=auto\n+_RNvC6_123foo3bar\n+123foo::bar\n+# UTF-8 identifiers.\n+--format=auto\n+_RNqCs4fqI2P2rA04_11utf8_identsu30____7hkackfecea1cbdathfdh9hlq6y\n+utf8_idents::\u10e1\u10d0\u10ed\u10db\u10d4\u10da\u10d0\u10d3_\u10d2\u10d4\u10db\u10e0\u10d8\u10d4\u10da\u10d8_\u10e1\u10d0\u10d3\u10d8\u10da\u10d8\n+# Closure path elements.\n+--format=auto\n+_RNCNCNgCs6DXkGYLi8lr_2cc5spawn00B5_\n+cc::spawn::{closure#0}::{closure#0}\n+#\n+--format=auto\n+_RNCINkXs25_NgCsbmNqQUJIY6D_4core5sliceINyB9_4IterhENuNgNoBb_4iter8iterator8Iterator9rpositionNCNgNpB9_6memchr7memrchrs_0E0Bb_\n+<core::slice::Iter<u8> as core::iter::iterator::Iterator>::rposition::<core::slice::memchr::memrchr::{closure#1}>::{closure#0}\n+# dyn Trait (\"trait object\") types.\n+--format=auto\n+_RINbNbCskIICzLVDPPb_5alloc5alloc8box_freeDINbNiB4_5boxed5FnBoxuEp6OutputuEL_ECs1iopQbuBiw2_3std\n+alloc::alloc::box_free::<dyn alloc::boxed::FnBox<(), Output = ()>>\n+# Types with const generics parameters.\n+--format=auto\n+_RNvMC0INtC8arrayvec8ArrayVechKj7b_E3new\n+<arrayvec::ArrayVec<u8, 123>>::new\n+#\n+--format=auto\n+_RMCs4fqI2P2rA04_13const_genericINtB0_8UnsignedKhb_E\n+<const_generic::Unsigned<11>>\n+#\n+--format=auto\n+_RMCs4fqI2P2rA04_13const_genericINtB0_6SignedKs98_E\n+<const_generic::Signed<152>>\n+#\n+--format=auto\n+_RMCs4fqI2P2rA04_13const_genericINtB0_6SignedKanb_E\n+<const_generic::Signed<-11>>\n+#\n+--format=auto\n+_RMCs4fqI2P2rA04_13const_genericINtB0_4BoolKb0_E\n+<const_generic::Bool<false>>\n+#\n+--format=auto\n+_RMCs4fqI2P2rA04_13const_genericINtB0_4BoolKb1_E\n+<const_generic::Bool<true>>\n+#\n+--format=auto\n+_RMCs4fqI2P2rA04_13const_genericINtB0_4CharKc76_E\n+<const_generic::Char<'v'>>\n+#\n+--format=auto\n+_RMCs4fqI2P2rA04_13const_genericINtB0_4CharKca_E\n+<const_generic::Char<'\\n'>>\n+#\n+--format=auto\n+_RMCs4fqI2P2rA04_13const_genericINtB0_4CharKc2202_E\n+<const_generic::Char<'\\u{2202}'>>\n+#\n+--format=auto\n+_RNvNvMCs4fqI2P2rA04_13const_genericINtB4_3FooKpE3foo3FOO\n+<const_generic::Foo<_>>::foo::FOO"}]}