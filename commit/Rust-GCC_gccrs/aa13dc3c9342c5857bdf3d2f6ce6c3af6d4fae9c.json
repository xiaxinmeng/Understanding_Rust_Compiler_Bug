{"sha": "aa13dc3c9342c5857bdf3d2f6ce6c3af6d4fae9c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWExM2RjM2M5MzQyYzU4NTdiZGYzZDJmNmNlNmMzYWY2ZDRmYWU5Yw==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2011-08-25T16:27:39Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2011-08-25T16:27:39Z"}, "message": "trans-array.c (gfc_conv_descriptor_token): Add assert.\n\n2011-08-25  Tobias Burnus  <burnus@net-b.de>\n\n        * trans-array.c (gfc_conv_descriptor_token): Add assert.\n        * trans-decl.c (gfc_build_qualified_array,\n        create_function_arglist): Handle assumed-shape arrays.\n        * trans-expr.c (gfc_conv_procedure_call): Ditto.\n        * trans-types.c (gfc_get_array_descriptor_base): Ditto, don't\n        add \"caf_token\" to assumed-shape descriptors, new akind argument.\n        (gfc_get_array_type_bounds): Pass akind.\n        * trans.h (lang_decl): New elements caf_offset and token.\n        (GFC_DECL_TOKEN, GFC_DECL_CAF_OFFSET): New macros.\n\n2011-08-25  Tobias Burnus  <burnus@net-b.de>\n\n        * gfortran.dg/coarray_lib_token_4.f90: New.\n\nFrom-SVN: r178069", "tree": {"sha": "622a3bfb407021c942c4f703515478d5bc9ece18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/622a3bfb407021c942c4f703515478d5bc9ece18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa13dc3c9342c5857bdf3d2f6ce6c3af6d4fae9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa13dc3c9342c5857bdf3d2f6ce6c3af6d4fae9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa13dc3c9342c5857bdf3d2f6ce6c3af6d4fae9c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa13dc3c9342c5857bdf3d2f6ce6c3af6d4fae9c/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "241e79cfc4264dec4eaf1e8af890da3527c99193", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/241e79cfc4264dec4eaf1e8af890da3527c99193", "html_url": "https://github.com/Rust-GCC/gccrs/commit/241e79cfc4264dec4eaf1e8af890da3527c99193"}], "stats": {"total": 156, "additions": 136, "deletions": 20}, "files": [{"sha": "5cab38d5c8582c597a59a0652c2fe2ccf5f3686a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa13dc3c9342c5857bdf3d2f6ce6c3af6d4fae9c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa13dc3c9342c5857bdf3d2f6ce6c3af6d4fae9c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=aa13dc3c9342c5857bdf3d2f6ce6c3af6d4fae9c", "patch": "@@ -1,3 +1,15 @@\n+2011-08-25  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* trans-array.c (gfc_conv_descriptor_token): Add assert.\n+\t* trans-decl.c (gfc_build_qualified_array,\n+\tcreate_function_arglist): Handle assumed-shape arrays.\n+\t* trans-expr.c (gfc_conv_procedure_call): Ditto.\n+\t* trans-types.c (gfc_get_array_descriptor_base): Ditto, don't\n+\tadd \"caf_token\" to assumed-shape descriptors, new akind argument.\n+\t(gfc_get_array_type_bounds): Pass akind.\n+\t* trans.h (lang_decl): New elements caf_offset and token.\n+\t(GFC_DECL_TOKEN, GFC_DECL_CAF_OFFSET): New macros.\n+\n 2011-08-25  Tobias Burnus  <burnus@net-b.de>\n \n \t* trans-array.c (structure_alloc_comps): Fix for allocatable"}, {"sha": "6dc1e17a7d41ef37fe2448c116b31d9913f3a8c6", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa13dc3c9342c5857bdf3d2f6ce6c3af6d4fae9c/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa13dc3c9342c5857bdf3d2f6ce6c3af6d4fae9c/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=aa13dc3c9342c5857bdf3d2f6ce6c3af6d4fae9c", "patch": "@@ -277,6 +277,7 @@ gfc_conv_descriptor_token (tree desc)\n \n   type = TREE_TYPE (desc);\n   gcc_assert (GFC_DESCRIPTOR_TYPE_P (type));\n+  gcc_assert (GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ALLOCATABLE);\n   gcc_assert (gfc_option.coarray == GFC_FCOARRAY_LIB);\n   field = gfc_advance_chain (TYPE_FIELDS (type), CAF_TOKEN_FIELD);\n   gcc_assert (field != NULL_TREE && TREE_TYPE (field) == prvoid_type_node);"}, {"sha": "1059a42f8abbc191887b6bfb1e8e93c893570b19", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 29, "deletions": 8, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa13dc3c9342c5857bdf3d2f6ce6c3af6d4fae9c/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa13dc3c9342c5857bdf3d2f6ce6c3af6d4fae9c/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=aa13dc3c9342c5857bdf3d2f6ce6c3af6d4fae9c", "patch": "@@ -755,6 +755,7 @@ gfc_build_qualified_array (tree decl, gfc_symbol * sym)\n \t && !sym->attr.contained;\n \n   if (sym->attr.codimension && gfc_option.coarray == GFC_FCOARRAY_LIB\n+      && sym->as->type != AS_ASSUMED_SHAPE\n       && GFC_TYPE_ARRAY_CAF_TOKEN (type) == NULL_TREE)\n     {\n       tree token;\n@@ -2104,12 +2105,11 @@ create_function_arglist (gfc_symbol * sym)\n \n       f->sym->backend_decl = parm;\n \n-      /* Coarrays which do not use a descriptor pass with -fcoarray=lib the\n-\t token and the offset as hidden arguments.  */\n+      /* Coarrays which are descriptorless or assumed-shape pass with\n+\t -fcoarray=lib the token and the offset as hidden arguments.  */\n       if (f->sym->attr.codimension\n \t  && gfc_option.coarray == GFC_FCOARRAY_LIB\n-\t  && !f->sym->attr.allocatable\n-\t  && f->sym->as->type != AS_ASSUMED_SHAPE)\n+\t  && !f->sym->attr.allocatable)\n \t{\n \t  tree caf_type;\n \t  tree token;\n@@ -2119,25 +2119,46 @@ create_function_arglist (gfc_symbol * sym)\n \t\t      && !sym->attr.is_bind_c);\n \t  caf_type = TREE_TYPE (f->sym->backend_decl);\n \n-\t  gcc_assert (GFC_TYPE_ARRAY_CAF_TOKEN (caf_type) == NULL_TREE);\n \t  token = build_decl (input_location, PARM_DECL,\n \t\t\t      create_tmp_var_name (\"caf_token\"),\n \t\t\t      build_qualified_type (pvoid_type_node,\n \t\t\t\t\t\t    TYPE_QUAL_RESTRICT));\n-\t  GFC_TYPE_ARRAY_CAF_TOKEN (caf_type) = token;\n+\t  if (f->sym->as->type == AS_ASSUMED_SHAPE)\n+\t    {\n+\t      gcc_assert (DECL_LANG_SPECIFIC (f->sym->backend_decl) == NULL\n+\t\t\t  || GFC_DECL_TOKEN (f->sym->backend_decl) == NULL_TREE);\n+\t      if (DECL_LANG_SPECIFIC (f->sym->backend_decl) == NULL)\n+\t\tgfc_allocate_lang_decl (f->sym->backend_decl);\n+\t      GFC_DECL_TOKEN (f->sym->backend_decl) = token;\n+\t    }\n+          else\n+\t    {\n+\t      gcc_assert (GFC_TYPE_ARRAY_CAF_TOKEN (caf_type) == NULL_TREE);\n+\t      GFC_TYPE_ARRAY_CAF_TOKEN (caf_type) = token;\n+\t    }\n+\t    \n \t  DECL_CONTEXT (token) = fndecl;\n \t  DECL_ARTIFICIAL (token) = 1;\n \t  DECL_ARG_TYPE (token) = TREE_VALUE (typelist);\n \t  TREE_READONLY (token) = 1;\n \t  hidden_arglist = chainon (hidden_arglist, token);\n \t  gfc_finish_decl (token);\n \n-\t  gcc_assert (GFC_TYPE_ARRAY_CAF_OFFSET (caf_type) == NULL_TREE);\n \t  offset = build_decl (input_location, PARM_DECL,\n \t\t\t       create_tmp_var_name (\"caf_offset\"),\n \t\t\t       gfc_array_index_type);\n \n-\t  GFC_TYPE_ARRAY_CAF_OFFSET (caf_type) = offset;\n+\t  if (f->sym->as->type == AS_ASSUMED_SHAPE)\n+\t    {\n+\t      gcc_assert (GFC_DECL_CAF_OFFSET (f->sym->backend_decl)\n+\t\t\t\t\t       == NULL_TREE);\n+\t      GFC_DECL_CAF_OFFSET (f->sym->backend_decl) = offset;\n+\t    }\n+\t  else\n+\t    {\n+\t      gcc_assert (GFC_TYPE_ARRAY_CAF_OFFSET (caf_type) == NULL_TREE);\n+\t      GFC_TYPE_ARRAY_CAF_OFFSET (caf_type) = offset;\n+\t    }\n \t  DECL_CONTEXT (offset) = fndecl;\n \t  DECL_ARTIFICIAL (offset) = 1;\n \t  DECL_ARG_TYPE (offset) = TREE_VALUE (typelist);"}, {"sha": "628930a340dcda47014cfd20eac1cf08239ebaae", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa13dc3c9342c5857bdf3d2f6ce6c3af6d4fae9c/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa13dc3c9342c5857bdf3d2f6ce6c3af6d4fae9c/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=aa13dc3c9342c5857bdf3d2f6ce6c3af6d4fae9c", "patch": "@@ -3391,11 +3391,11 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n       if (parmse.string_length != NULL_TREE && !sym->attr.is_bind_c)\n \tVEC_safe_push (tree, gc, stringargs, parmse.string_length);\n \n-      /* For descriptorless coarrays, we pass the token and the offset\n-\t as additional arguments.  */\n+      /* For descriptorless coarrays and assumed-shape coarray dummies, we\n+\t pass the token and the offset as additional arguments.  */\n       if (fsym && fsym->attr.codimension\n \t  && gfc_option.coarray == GFC_FCOARRAY_LIB\n-\t  && !fsym->attr.allocatable && fsym->as->type != AS_ASSUMED_SHAPE\n+\t  && !fsym->attr.allocatable\n \t  && e == NULL)\n \t{\n \t  /* Token and offset. */\n@@ -3405,7 +3405,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  gcc_assert (fsym->attr.optional);\n \t}\n       else if (fsym && fsym->attr.codimension\n-\t       && !fsym->attr.allocatable && fsym->as->type != AS_ASSUMED_SHAPE\n+\t       && !fsym->attr.allocatable\n \t       && gfc_option.coarray == GFC_FCOARRAY_LIB)\n \t{\n \t  tree caf_decl, caf_type;\n@@ -3414,8 +3414,12 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  caf_decl = get_tree_for_caf_expr (e);\n \t  caf_type = TREE_TYPE (caf_decl);\n \n-\t  if (GFC_DESCRIPTOR_TYPE_P (caf_type))\n+\t  if (GFC_DESCRIPTOR_TYPE_P (caf_type)\n+\t      && GFC_TYPE_ARRAY_AKIND (caf_type) == GFC_ARRAY_ALLOCATABLE)\n \t    tmp = gfc_conv_descriptor_token (caf_decl);\n+\t  else if (DECL_LANG_SPECIFIC (caf_decl)\n+\t\t   && GFC_DECL_TOKEN (caf_decl) != NULL_TREE)\n+\t    tmp = GFC_DECL_TOKEN (caf_decl);\n \t  else\n \t    {\n \t      gcc_assert (GFC_ARRAY_TYPE_P (caf_type)\n@@ -3425,8 +3429,12 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  \n \t  VEC_safe_push (tree, gc, stringargs, tmp);\n \n-\t  if (GFC_DESCRIPTOR_TYPE_P (caf_type))\n+\t  if (GFC_DESCRIPTOR_TYPE_P (caf_type)\n+\t      && GFC_TYPE_ARRAY_AKIND (caf_type) == GFC_ARRAY_ALLOCATABLE)\n \t    offset = build_int_cst (gfc_array_index_type, 0);\n+\t  else if (DECL_LANG_SPECIFIC (caf_decl)\n+\t\t   && GFC_DECL_CAF_OFFSET (caf_decl) != NULL_TREE)\n+\t    offset = GFC_DECL_CAF_OFFSET (caf_decl);\n \t  else if (GFC_TYPE_ARRAY_CAF_OFFSET (caf_type) != NULL_TREE)\n \t    offset = GFC_TYPE_ARRAY_CAF_OFFSET (caf_type);\n \t  else\n@@ -3440,7 +3448,15 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t      tmp = caf_decl;\n \t    }\n \n-\t  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (parmse.expr)))\n+          if (fsym->as->type == AS_ASSUMED_SHAPE)\n+\t    {\n+\t      gcc_assert (POINTER_TYPE_P (TREE_TYPE (parmse.expr)));\n+\t      gcc_assert (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE\n+\t\t\t\t\t\t   (TREE_TYPE (parmse.expr))));\n+\t      tmp2 = build_fold_indirect_ref_loc (input_location, parmse.expr);\n+\t      tmp2 = gfc_conv_descriptor_data_get (tmp2);\n+\t    }\n+\t  else if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (parmse.expr)))\n \t    tmp2 = gfc_conv_descriptor_data_get (parmse.expr);\n \t  else\n \t    {"}, {"sha": "f66878a1c89573cd63c99311b4cdfc8387e5c9e1", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa13dc3c9342c5857bdf3d2f6ce6c3af6d4fae9c/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa13dc3c9342c5857bdf3d2f6ce6c3af6d4fae9c/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=aa13dc3c9342c5857bdf3d2f6ce6c3af6d4fae9c", "patch": "@@ -1614,10 +1614,12 @@ gfc_get_nodesc_array_type (tree etype, gfc_array_spec * as, gfc_packed packed,\n   return type;\n }\n \n+\n /* Return or create the base type for an array descriptor.  */\n \n static tree\n-gfc_get_array_descriptor_base (int dimen, int codimen, bool restricted)\n+gfc_get_array_descriptor_base (int dimen, int codimen, bool restricted,\n+\t\t\t       enum gfc_array_kind akind)\n {\n   tree fat_type, decl, arraytype, *chain = NULL;\n   char name[16 + 2*GFC_RANK_DIGITS + 1 + 1];\n@@ -1671,7 +1673,8 @@ gfc_get_array_descriptor_base (int dimen, int codimen, bool restricted)\n \t\t\t\t    arraytype, &chain);\n   TREE_NO_WARNING (decl) = 1;\n \n-  if (gfc_option.coarray == GFC_FCOARRAY_LIB && codimen)\n+  if (gfc_option.coarray == GFC_FCOARRAY_LIB && codimen\n+      && akind == GFC_ARRAY_ALLOCATABLE)\n     {\n       decl = gfc_add_field_to_struct_1 (fat_type,\n \t\t\t\t\tget_identifier (\"token\"),\n@@ -1683,14 +1686,16 @@ gfc_get_array_descriptor_base (int dimen, int codimen, bool restricted)\n   gfc_finish_type (fat_type);\n   TYPE_DECL_SUPPRESS_DEBUG (TYPE_STUB_DECL (fat_type)) = 1;\n \n-  if (gfc_option.coarray == GFC_FCOARRAY_LIB && codimen)\n+  if (gfc_option.coarray == GFC_FCOARRAY_LIB && codimen\n+      && akind == GFC_ARRAY_ALLOCATABLE)\n     gfc_array_descriptor_base_caf[idx] = fat_type;\n   else\n     gfc_array_descriptor_base[idx] = fat_type;\n \n   return fat_type;\n }\n \n+\n /* Build an array (descriptor) type with given bounds.  */\n \n tree\n@@ -1703,11 +1708,11 @@ gfc_get_array_type_bounds (tree etype, int dimen, int codimen, tree * lbound,\n   const char *type_name;\n   int n;\n \n-  base_type = gfc_get_array_descriptor_base (dimen, codimen, restricted);\n+  base_type = gfc_get_array_descriptor_base (dimen, codimen, restricted, akind);\n   fat_type = build_distinct_type_copy (base_type);\n   /* Make sure that nontarget and target array type have the same canonical\n      type (and same stub decl for debug info).  */\n-  base_type = gfc_get_array_descriptor_base (dimen, codimen, false);\n+  base_type = gfc_get_array_descriptor_base (dimen, codimen, false, akind);\n   TYPE_CANONICAL (fat_type) = base_type;\n   TYPE_STUB_DECL (fat_type) = TYPE_STUB_DECL (base_type);\n "}, {"sha": "0c249a6736a7a61017128719e33a1cf35d0290a3", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa13dc3c9342c5857bdf3d2f6ce6c3af6d4fae9c/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa13dc3c9342c5857bdf3d2f6ce6c3af6d4fae9c/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=aa13dc3c9342c5857bdf3d2f6ce6c3af6d4fae9c", "patch": "@@ -750,12 +750,16 @@ struct GTY((variable_size)) lang_decl {\n   tree stringlen;\n   tree addr;\n   tree span;\n+  /* For assumed-shape coarrays.  */\n+  tree token, caf_offset;\n };\n \n \n #define GFC_DECL_ASSIGN_ADDR(node) DECL_LANG_SPECIFIC(node)->addr\n #define GFC_DECL_STRING_LEN(node) DECL_LANG_SPECIFIC(node)->stringlen\n #define GFC_DECL_SPAN(node) DECL_LANG_SPECIFIC(node)->span\n+#define GFC_DECL_TOKEN(node) DECL_LANG_SPECIFIC(node)->token\n+#define GFC_DECL_CAF_OFFSET(node) DECL_LANG_SPECIFIC(node)->caf_offset\n #define GFC_DECL_SAVED_DESCRIPTOR(node) \\\n   (DECL_LANG_SPECIFIC(node)->saved_descriptor)\n #define GFC_DECL_PACKED_ARRAY(node) DECL_LANG_FLAG_0(node)"}, {"sha": "c904def866d846b3bb5bcbd531f0002a02e0e36d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa13dc3c9342c5857bdf3d2f6ce6c3af6d4fae9c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa13dc3c9342c5857bdf3d2f6ce6c3af6d4fae9c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=aa13dc3c9342c5857bdf3d2f6ce6c3af6d4fae9c", "patch": "@@ -1,3 +1,7 @@\n+2011-08-25  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* gfortran.dg/coarray_lib_token_4.f90: New.\n+\n 2011-08-25  Tobias Burnus  <burnus@net-b.de>\n \n \t* gfortran.dg/coarray/alloc_comp_1.f90: New."}, {"sha": "2616d257d98dd6443d2ca37416b39f0124d14498", "filename": "gcc/testsuite/gfortran.dg/coarray_lib_token_4.f90", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa13dc3c9342c5857bdf3d2f6ce6c3af6d4fae9c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_token_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa13dc3c9342c5857bdf3d2f6ce6c3af6d4fae9c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_token_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_token_4.f90?ref=aa13dc3c9342c5857bdf3d2f6ce6c3af6d4fae9c", "patch": "@@ -0,0 +1,53 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=lib -fdump-tree-original\" }\n+!\n+! Check argument passing with assumed-shape coarray dummies\n+!\n+program test_caf\n+  implicit none\n+  integer, allocatable :: A(:)[:]\n+  integer, save :: B(3)[*]\n+  integer :: i\n+\n+  allocate (A(3)[*])\n+  A = [1, 2, 3 ] \n+  B = [9, 7, 4 ]\n+  call foo (A, A, test=1)\n+  call foo (A(2:3), B, test=2)\n+  call foo (B, A, test=3)\n+contains\n+  subroutine foo(x, y, test)\n+    integer :: x(:)[*]\n+    integer, contiguous :: y(:)[*]\n+    integer :: test\n+    call bar (x)\n+    call expl (y)\n+  end subroutine foo\n+\n+  subroutine bar(y)\n+    integer :: y(:)[*]\n+  end subroutine bar\n+\n+  subroutine expl(z)\n+    integer :: z(*)[*]\n+  end subroutine expl\n+end program test_caf\n+\n+! { dg-final { scan-tree-dump-times \"expl \\\\(integer\\\\(kind=4\\\\).0:. . restrict z, void . restrict caf_token.\\[0-9\\]+, integer\\\\(kind=.\\\\) caf_offset.\\[0-9\\]+\\\\)\" 1 \"original\" } }\n+!\n+! { dg-final { scan-tree-dump-times \"bar \\\\(struct array2_integer\\\\(kind=4\\\\) & restrict y, void . restrict caf_token.\\[0-9\\]+, integer\\\\(kind=.\\\\) caf_offset.\\[0-9\\]+\\\\)\" 1 \"original\" } }\n+!\n+! { dg-final { scan-tree-dump-times \"foo \\\\(struct array2_integer\\\\(kind=4\\\\) & restrict x, struct array2_integer\\\\(kind=4\\\\) & restrict y, integer\\\\(kind=4\\\\) & restrict test, void . restrict caf_token.\\[0-9\\]+, integer\\\\(kind=.\\\\) caf_offset.\\[0-9\\]+, void . restrict caf_token.\\[0-9\\]+, integer\\\\(kind=.\\\\) caf_offset.\\[0-9\\]+\\\\)\" 1 \"original\" } }\n+!\n+! { dg-final { scan-tree-dump-times \"bar \\\\(&parm.\\[0-9\\]+, caf_token.\\[0-9\\]+, \\\\(\\\\(integer\\\\(kind=.\\\\)\\\\) parm.\\[0-9\\]+.data - \\\\(integer\\\\(kind=.\\\\)\\\\) x.\\[0-9\\]+\\\\) \\\\+ caf_offset.\\[0-9\\]+\\\\);\" 1 \"original\" } }\n+! { d_g-final { scan-tree-dump-times \"bar \\\\(&parm.\\[0-9\\]+, caf_token.\\[0-9\\]+, \\\\(\\\\(integer\\\\(kind=.\\\\) parm.\\[0-9\\]+.data - \\\\(integer\\\\(kind=.\\\\)\\\\) x.\\[0-9\\]+\\\\) \\\\+ caf_offset.\\[0-9\\]+\\\\);\" 1 \"original\" } }\n+!\n+! { dg-final { scan-tree-dump-times \"expl \\\\(\\\\(integer\\\\(kind=4\\\\).0:. .\\\\) parm.\\[0-9\\]+.data, caf_token.\\[0-9\\]+, \\\\(\\\\(integer\\\\(kind=.\\\\)\\\\) parm.\\[0-9\\]+.data - \\\\(\\\\(integer\\\\(kind=.\\\\)\\\\) y.\\[0-9\\]+\\\\) \\\\+ caf_offset.\\[0-9\\]+\\\\);\" 0 \"original\" } }\n+!\n+! { dg-final { scan-tree-dump-times \"foo \\\\(&a, &a, &C.\\[0-9\\]+, a.token, 0, a.token, 0\\\\);\" 1 \"original\" } }\n+!\n+! { dg-final { scan-tree-dump-times \"foo \\\\(&parm.\\[0-9\\]+, &parm.\\[0-9\\]+, &C.\\[0-9\\]+, a.token, \\\\(integer\\\\(kind=.\\\\)\\\\) parm.\\[0-9\\]+.data - \\\\(integer\\\\(kind=.\\\\)\\\\) a.data, caf_token.\\[0-9\\]+, \\\\(integer\\\\(kind=.\\\\)\\\\) parm.\\[0-9\\]+.data - \\\\(integer\\\\(kind=.\\\\)\\\\) b\\\\);\" 1 \"original\" } }\n+!\n+! { dg-final { scan-tree-dump-times \"foo \\\\(&parm.\\[0-9\\]+, &a, &C.\\[0-9\\]+, caf_token.\\[0-9\\]+, \\\\(integer\\\\(kind=.\\\\)\\\\) parm.\\[0-9\\]+.data - \\\\(integer\\\\(kind=.\\\\)\\\\) b, a.token, 0\\\\);\" 1 \"original\" } }\n+!\n+! { dg-final { cleanup-tree-dump \"original\" } }"}]}