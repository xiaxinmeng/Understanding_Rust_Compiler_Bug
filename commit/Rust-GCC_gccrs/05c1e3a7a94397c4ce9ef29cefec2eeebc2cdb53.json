{"sha": "05c1e3a7a94397c4ce9ef29cefec2eeebc2cdb53", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDVjMWUzYTdhOTQzOTdjNGNlOWVmMjljZWZlYzJlZWViYzJjZGI1Mw==", "commit": {"author": {"name": "Bernhard Fischer", "email": "aldot@gcc.gnu.org", "date": "2006-09-30T19:10:54Z"}, "committer": {"name": "Bernhard Reutner-Fischer", "email": "aldot@gcc.gnu.org", "date": "2006-09-30T19:10:54Z"}, "message": "resolve.c: Fix commentary typo.\n\n2006-09-30  Bernhard Fischer  <aldot@gcc.gnu.org>\n\n\t* resolve.c: Fix commentary typo.  Fix whitespace.\n\nFrom-SVN: r117332", "tree": {"sha": "e8023efe6e5c752cf182c3e8eb77aa5339568761", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8023efe6e5c752cf182c3e8eb77aa5339568761"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05c1e3a7a94397c4ce9ef29cefec2eeebc2cdb53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05c1e3a7a94397c4ce9ef29cefec2eeebc2cdb53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05c1e3a7a94397c4ce9ef29cefec2eeebc2cdb53", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05c1e3a7a94397c4ce9ef29cefec2eeebc2cdb53/comments", "author": null, "committer": null, "parents": [{"sha": "2d7224235688114edd75330c61527621c3731ee8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d7224235688114edd75330c61527621c3731ee8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d7224235688114edd75330c61527621c3731ee8"}], "stats": {"total": 58, "additions": 31, "deletions": 27}, "files": [{"sha": "e1d8420bd125f57389083db4cfdd8888daadcebc", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05c1e3a7a94397c4ce9ef29cefec2eeebc2cdb53/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05c1e3a7a94397c4ce9ef29cefec2eeebc2cdb53/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=05c1e3a7a94397c4ce9ef29cefec2eeebc2cdb53", "patch": "@@ -1,3 +1,7 @@\n+2006-09-30  Bernhard Fischer  <aldot@gcc.gnu.org>\n+\n+\t* resolve.c: Fix commentary typo.  Fix whitespace.\n+\n 2006-09-28  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tfortran/29147"}, {"sha": "c9af0c01b745ffe9c39a1280abcb45e3ce8b7d49", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05c1e3a7a94397c4ce9ef29cefec2eeebc2cdb53/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05c1e3a7a94397c4ce9ef29cefec2eeebc2cdb53/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=05c1e3a7a94397c4ce9ef29cefec2eeebc2cdb53", "patch": "@@ -275,7 +275,7 @@ static void\n resolve_contained_fntype (gfc_symbol * sym, gfc_namespace * ns)\n {\n   try t;\n-  \n+\n   /* If this namespace is not a function, ignore it.  */\n   if (! sym\n       || !(sym->attr.function\n@@ -325,7 +325,7 @@ merge_argument_lists (gfc_symbol *proc, gfc_formal_arglist *new_args)\n   for (; new_args != NULL; new_args = new_args->next)\n     {\n       new_sym = new_args->sym;\n-      /* See if ths arg is already in the formal argument list.  */\n+      /* See if this arg is already in the formal argument list.  */\n       for (f = proc->formal; f; f = f->next)\n \t{\n \t  if (new_sym == f->sym)\n@@ -372,7 +372,7 @@ resolve_entries (gfc_namespace * ns)\n \n   /* If this isn't a procedure something has gone horribly wrong.  */\n   gcc_assert (ns->proc_name->attr.flavor == FL_PROCEDURE);\n-  \n+\n   /* Remember the current namespace.  */\n   old_ns = gfc_current_ns;\n \n@@ -564,7 +564,7 @@ resolve_contained_functions (gfc_namespace * ns)\n   for (child = ns->contained; child; child = child->sibling)\n     {\n       /* Resolve alternate entry points first.  */\n-      resolve_entries (child); \n+      resolve_entries (child);\n \n       /* Then check function return types.  */\n       resolve_contained_fntype (child->proc_name, child);\n@@ -1021,7 +1021,7 @@ resolve_elemental_actual (gfc_expr *expr, gfc_code *c)\n \t    && formal_optional\n \t    && arg->expr->rank\n \t    && (set_by_optional || arg->expr->rank != rank)\n-\t    && !(isym && isym->generic_id == GFC_ISYM_CONVERSION)) \n+\t    && !(isym && isym->generic_id == GFC_ISYM_CONVERSION))\n \t{\n \t  gfc_warning (\"'%s' at %L is an array and OPTIONAL; IF IT IS \"\n \t\t       \"MISSING, it cannot be the actual argument of an \"\n@@ -1082,7 +1082,7 @@ find_noncopying_intrinsics (gfc_symbol * fnsym, gfc_actual_arglist * actual)\n    77 and 95 standards.  It checks for a gsymbol for the name, making\n    one if it does not already exist.  If it already exists, then the\n    reference being resolved must correspond to the type of gsymbol.\n-   Otherwise, the new symbol is equipped with the attributes of the \n+   Otherwise, the new symbol is equipped with the attributes of the\n    reference.  The corresponding code that is called in creating\n    global entities is parse.c.  */\n \n@@ -1489,13 +1489,13 @@ resolve_function (gfc_expr * expr)\n       int inquiry;\n       inquiry = expr->value.function.isym->generic_id == GFC_ISYM_UBOUND\n \t\t  || expr->value.function.isym->generic_id == GFC_ISYM_SIZE;\n-\t    \n+\n       for (arg = expr->value.function.actual; arg; arg = arg->next)\n \t{\n \t  if (inquiry && arg->next != NULL && arg->next->expr\n \t\t&& arg->next->expr->expr_type != EXPR_CONSTANT)\n \t    break;\n-\t  \n+\n \t  if (arg->expr != NULL\n \t\t&& arg->expr->rank > 0\n \t\t&& resolve_assumed_size_actual (arg->expr))\n@@ -1551,7 +1551,7 @@ resolve_function (gfc_expr * expr)\n      symbols not referenced from the current program unit otherwise.  Make sure\n      those symbols are marked as referenced.  */\n \n-  if (expr->ts.type == BT_CHARACTER && expr->value.function.esym \n+  if (expr->ts.type == BT_CHARACTER && expr->value.function.esym\n       && expr->value.function.esym->attr.use_assoc)\n     {\n       gfc_expr_set_symbols_referenced (expr->ts.cl->length);\n@@ -1874,7 +1874,7 @@ compare_shapes (gfc_expr * op1, gfc_expr * op2)\n   int i;\n \n   t = SUCCESS;\n-\t\t  \n+\n   if (op1->shape != NULL && op2->shape != NULL)\n     {\n       for (i = 0; i < op1->rank; i++)\n@@ -2270,7 +2270,7 @@ compute_last_value_for_triplet (gfc_expr * start, gfc_expr * end,\n       mpz_set (last, end->value.integer);\n       return 1;\n     }\n-  \n+\n   if (compare_bound_int (stride, 0) == CMP_GT)\n     {\n       /* Stride is positive */\n@@ -2473,7 +2473,7 @@ gfc_resolve_dim_arg (gfc_expr *dim)\n     {\n       gfc_error (\"Argument dim at %L must be scalar\", &dim->where);\n       return FAILURE;\n-  \n+\n     }\n   if (dim->ts.type != BT_INTEGER)\n     {\n@@ -3332,7 +3332,7 @@ expr_to_initialize (gfc_expr * e)\n         for (i = 0; i < ref->u.ar.dimen; i++)\n           ref->u.ar.start[i] = ref->u.ar.end[i] = ref->u.ar.stride[i] = NULL;\n \n-        result->rank = ref->u.ar.dimen; \n+        result->rank = ref->u.ar.dimen;\n         break;\n       }\n \n@@ -3790,7 +3790,7 @@ resolve_select (gfc_code * code)\n \t      if (cp->low == NULL && cp->high == NULL)\n \t\tcontinue;\n \n-\t      /* Unreachable case ranges are discarded, so ignore.  */\t\n+\t      /* Unreachable case ranges are discarded, so ignore.  */\n \t      if (cp->low != NULL && cp->high != NULL\n \t\t  && cp->low != cp->high\n \t\t  && gfc_compare_expr (cp->low, cp->high) > 0)\n@@ -3803,7 +3803,7 @@ resolve_select (gfc_code * code)\n \n \t      if (cp->high != NULL\n \t\t  && case_expr->ts.kind != gfc_kind_max(case_expr, cp->high))\n- \t\tgfc_convert_type_warn (case_expr, &cp->high->ts, 2, 0);\n+\t\tgfc_convert_type_warn (case_expr, &cp->high->ts, 2, 0);\n \t    }\n \t }\n     }\n@@ -4788,7 +4788,7 @@ resolve_code (gfc_code * code, gfc_namespace * ns)\n           if (t == SUCCESS\n \t      && (code->expr->expr_type != EXPR_VARIABLE\n \t\t  || code->expr->symtree->n.sym->ts.type != BT_INTEGER\n-\t\t  || code->expr->symtree->n.sym->ts.kind \n+\t\t  || code->expr->symtree->n.sym->ts.kind\n \t\t        != gfc_default_integer_kind\n \t\t  || code->expr->symtree->n.sym->as != NULL))\n \t    gfc_error (\"ASSIGN statement at %L requires a scalar \"\n@@ -5431,7 +5431,7 @@ resolve_fl_derived (gfc_symbol *sym)\n \t    }\n \t}\n     }\n-    \n+\n   /* Add derived type to the derived type list.  */\n   for (dt_list = sym->ns->derived_types; dt_list; dt_list = dt_list->next)\n     if (sym == dt_list->derived)\n@@ -5630,7 +5630,7 @@ resolve_symbol (gfc_symbol * sym)\n     }\n \n   /* Assumed size arrays and assumed shape arrays must be dummy\n-     arguments.  */ \n+     arguments.  */\n \n   if (sym->as != NULL\n       && (sym->as->type == AS_ASSUMED_SIZE\n@@ -6242,7 +6242,7 @@ resolve_equivalence_derived (gfc_symbol *derived, gfc_symbol *sym, gfc_expr *e)\n       d = c->ts.derived;\n       if (d && (resolve_equivalence_derived (c->ts.derived, sym, e) == FAILURE))\n         return FAILURE;\n-        \n+\n       /* Shall not be an object of sequence derived type containing a pointer\n          in the structure.  */\n       if (c->pointer)\n@@ -6382,7 +6382,7 @@ resolve_equivalence (gfc_equiv *eq)\n \t}\n \n       /* Shall not equivalence common block variables in a PURE procedure.  */\n-      if (sym->ns->proc_name \n+      if (sym->ns->proc_name\n \t    && sym->ns->proc_name->attr.pure\n \t    && sym->attr.in_common)\n         {\n@@ -6391,8 +6391,8 @@ resolve_equivalence (gfc_equiv *eq)\n \t\t     sym->name, &e->where, sym->ns->proc_name->name);\n           break;\n         }\n- \n-      /* Shall not be a named constant.  */      \n+\n+      /* Shall not be a named constant.  */\n       if (e->expr_type == EXPR_CONSTANT)\n         {\n           gfc_error (\"Named constant '%s' at %L cannot be an EQUIVALENCE \"\n@@ -6503,8 +6503,8 @@ resolve_equivalence (gfc_equiv *eq)\n \t    }\n \t  r = r->next;\n \t}\n-    }    \n-}      \n+    }\n+}\n \n \n /* Resolve function and ENTRY types, issue diagnostics if needed. */\n@@ -6582,9 +6582,9 @@ gfc_resolve_uops(gfc_symtree *symtree)\n   gfc_symbol *sym;\n   gfc_formal_arglist *formal;\n \n-  if (symtree == NULL) \n-    return; \n- \n+  if (symtree == NULL)\n+    return;\n+\n   gfc_resolve_uops (symtree->left);\n   gfc_resolve_uops (symtree->right);\n "}]}