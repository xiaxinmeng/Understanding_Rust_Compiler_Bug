{"sha": "bed575d525be3438bc5f4deb04d28c81fa009320", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmVkNTc1ZDUyNWJlMzQzOGJjNWY0ZGViMDRkMjhjODFmYTAwOTMyMA==", "commit": {"author": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2006-04-15T03:24:23Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2006-04-15T03:24:23Z"}, "message": "tree-cfg.c (make_edges, [...]): Reinstate RTH's changes from r112935 that were accidentally reverted by r112959.\n\n\n\t* tree-cfg.c (make_edges, make_omp_sections_edges, move_stmt_r,\n\tis_ctrl_altering_stmt): Reinstate RTH's changes from r112935 that\n\twere accidentally reverted by r112959.\n\nFrom-SVN: r112966", "tree": {"sha": "4af2b4c4b74d9284ef13d7b78f868b3585337e8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4af2b4c4b74d9284ef13d7b78f868b3585337e8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bed575d525be3438bc5f4deb04d28c81fa009320", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bed575d525be3438bc5f4deb04d28c81fa009320", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bed575d525be3438bc5f4deb04d28c81fa009320", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bed575d525be3438bc5f4deb04d28c81fa009320/comments", "author": null, "committer": null, "parents": [{"sha": "8ba0097ac433a9ca262daf0550807787c912937b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ba0097ac433a9ca262daf0550807787c912937b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ba0097ac433a9ca262daf0550807787c912937b"}], "stats": {"total": 100, "additions": 59, "deletions": 41}, "files": [{"sha": "0cb7d56922889e76ad2da3e0d570557de0ed5691", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bed575d525be3438bc5f4deb04d28c81fa009320/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bed575d525be3438bc5f4deb04d28c81fa009320/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bed575d525be3438bc5f4deb04d28c81fa009320", "patch": "@@ -1,3 +1,9 @@\n+2006-04-14  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* tree-cfg.c (make_edges, make_omp_sections_edges, move_stmt_r,\n+\tis_ctrl_altering_stmt): Reinstate RTH's changes from r112935 that\n+\twere accidentally reverted by r112959.\n+\n 2006-04-15  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/26823\n@@ -60,7 +66,7 @@\n \n 2006-04-13  Richard Henderson  <rth@redhat.com>\n \n-\tPR 26651\n+\tPR libgomp/26651\n \t* gimple-low.c (lower_omp_directive): Remove dead code.\n \t(lower_stmt): Do nothing except for openmp, except for OMP_PARALLEL.\n \t* gimplify.c (gimplify_expr): Update for OMP_RETURN, OMP_CONTINUE."}, {"sha": "7913e5288053949fe382a66df42d921b7b0ed05a", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 52, "deletions": 40, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bed575d525be3438bc5f4deb04d28c81fa009320/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bed575d525be3438bc5f4deb04d28c81fa009320/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=bed575d525be3438bc5f4deb04d28c81fa009320", "patch": "@@ -103,7 +103,6 @@ static void make_edges (void);\n static void make_cond_expr_edges (basic_block);\n static void make_switch_expr_edges (basic_block);\n static void make_goto_expr_edges (basic_block);\n-static void make_omp_sections_edges (basic_block);\n static edge tree_redirect_edge_and_branch (edge, basic_block);\n static edge tree_try_redirect_by_replacing_jump (edge, basic_block);\n static unsigned int split_critical_edges (void);\n@@ -447,6 +446,7 @@ static void\n make_edges (void)\n {\n   basic_block bb;\n+  struct omp_region *cur_region = NULL;\n \n   /* Create an edge from entry to the first block with executable\n      statements in it.  */\n@@ -460,7 +460,8 @@ make_edges (void)\n \n       if (last)\n \t{\n-\t  switch (TREE_CODE (last))\n+\t  enum tree_code code = TREE_CODE (last);\n+\t  switch (code)\n \t    {\n \t    case GOTO_EXPR:\n \t      make_goto_expr_edges (bb);\n@@ -522,20 +523,55 @@ make_edges (void)\n \t    case OMP_ORDERED:\n \t    case OMP_CRITICAL:\n \t    case OMP_SECTION:\n+\t      cur_region = new_omp_region (bb, code, cur_region);\n \t      fallthru = true;\n \t      break;\n \n-\t    case OMP_RETURN_EXPR:\n-\t      /* In the case of an OMP_SECTION, we may have already made\n-\t\t an edge in make_omp_sections_edges.  */\n-\t      fallthru = EDGE_COUNT (bb->succs) == 0;\n-\t      break;\n-\n \t    case OMP_SECTIONS:\n-\t      make_omp_sections_edges (bb);\n+\t      cur_region = new_omp_region (bb, code, cur_region);\n \t      fallthru = false;\n \t      break;\n \n+\t    case OMP_RETURN:\n+\t      /* In the case of an OMP_SECTION, the edge will go somewhere\n+\t\t other than the next block.  This will be created later.  */\n+\t      cur_region->exit = bb;\n+\t      fallthru = cur_region->type != OMP_SECTION;\n+\t      cur_region = cur_region->outer;\n+\t      break;\n+\n+\t    case OMP_CONTINUE:\n+\t      cur_region->cont = bb;\n+\t      switch (cur_region->type)\n+\t\t{\n+\t\tcase OMP_FOR:\n+\t\t  /* ??? Technically there should be a some sort of loopback\n+\t\t     edge here, but it goes to a block that doesn't exist yet,\n+\t\t     and without it, updating the ssa form would be a real\n+\t\t     bear.  Fortunately, we don't yet do ssa before expanding\n+\t\t     these nodes.  */\n+\t\t  break;\n+\n+\t\tcase OMP_SECTIONS:\n+\t\t  /* Wire up the edges into and out of the nested sections.  */\n+\t\t  /* ??? Similarly wrt loopback.  */\n+\t\t  {\n+\t\t    struct omp_region *i;\n+\t\t    for (i = cur_region->inner; i ; i = i->next)\n+\t\t      {\n+\t\t\tgcc_assert (i->type == OMP_SECTION);\n+\t\t\tmake_edge (cur_region->entry, i->entry, 0);\n+\t\t\tmake_edge (i->exit, bb, EDGE_FALLTHRU);\n+\t\t      }\n+\t\t  }\n+\t\t  break;\n+\t\t     \n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t\t}\n+\t      fallthru = true;\n+\t      break;\n+\n \t    default:\n \t      gcc_assert (!stmt_ends_bb_p (last));\n \t      fallthru = true;\n@@ -548,6 +584,9 @@ make_edges (void)\n \tmake_edge (bb, bb->next_bb, EDGE_FALLTHRU);\n     }\n \n+  if (root_omp_region)\n+    free_omp_regions ();\n+\n   /* Fold COND_EXPR_COND of each COND_EXPR.  */\n   fold_cond_expr_cond ();\n \n@@ -556,35 +595,6 @@ make_edges (void)\n }\n \n \n-/* Link an OMP_SECTIONS block to all the OMP_SECTION blocks in its body.  */\n-\n-static void\n-make_omp_sections_edges (basic_block bb)\n-{\n-  basic_block exit_bb;\n-  size_t i, n;\n-  tree vec, stmt;\n-\n-  stmt = last_stmt (bb);\n-  vec = OMP_SECTIONS_SECTIONS (stmt);\n-  n = TREE_VEC_LENGTH (vec);\n-  exit_bb = bb_for_stmt (TREE_VEC_ELT (vec, n - 1));\n-\n-  for (i = 0; i < n - 1; i += 2)\n-    {\n-      basic_block start_bb = bb_for_stmt (TREE_VEC_ELT (vec, i));\n-      basic_block end_bb = bb_for_stmt (TREE_VEC_ELT (vec, i + 1));\n-      make_edge (bb, start_bb, 0);\n-      make_edge (end_bb, exit_bb, EDGE_FALLTHRU);\n-    }\n-\n-  /* Once the CFG has been built, the vector of sections is no longer\n-     useful.  The region can be easily obtained with build_omp_regions.\n-     Furthermore, this sharing of tree expressions is not allowed by the\n-     statement verifier.  */\n-  OMP_SECTIONS_SECTIONS (stmt) = NULL_TREE;\n-}\n-\n /* Create the edges for a COND_EXPR starting at block BB.\n    At this point, both clauses must contain only simple gotos.  */\n \n@@ -2498,7 +2508,7 @@ is_ctrl_altering_stmt (tree t)\n     }\n \n   /* OpenMP directives alter control flow.  */\n-  if (flag_openmp && OMP_DIRECTIVE_P (t))\n+  if (OMP_DIRECTIVE_P (t))\n     return true;\n \n   /* If a statement can throw, it alters control flow.  */\n@@ -4549,7 +4559,9 @@ move_stmt_r (tree *tp, int *walk_subtrees, void *data)\n   if (p->block && IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (t))))\n     TREE_BLOCK (t) = p->block;\n \n-  if (OMP_DIRECTIVE_P (t) && TREE_CODE (t) != OMP_RETURN_EXPR)\n+  if (OMP_DIRECTIVE_P (t)\n+      && TREE_CODE (t) != OMP_RETURN\n+      && TREE_CODE (t) != OMP_CONTINUE)\n     {\n       /* Do not remap variables inside OMP directives.  Variables\n \t referenced in clauses and directive header belong to the"}]}