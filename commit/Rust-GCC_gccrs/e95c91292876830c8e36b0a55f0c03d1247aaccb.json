{"sha": "e95c91292876830c8e36b0a55f0c03d1247aaccb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTk1YzkxMjkyODc2ODMwYzhlMzZiMGE1NWYwYzAzZDEyNDdhYWNjYg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2017-10-12T17:29:15Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2017-10-12T17:29:15Z"}, "message": "C++: avoid partial duplicate implementation of cp_parser_error\n\nIn r251026 (aka 3fe34694f0990d1d649711ede0326497f8a849dc,\n\"C/C++: show pertinent open token when missing a close token\")\nI copied part of cp_parser_error into cp_parser_required_error,\nleading to duplication of code.\n\nThis patch eliminates this duplication by merging the two copies of the\ncode into a new cp_parser_error_1 subroutine.\n\nDoing so removes an indentation level, making the patch appear to have\nmore churn than it really does.\n\nThe patch also undoes the change to g++.dg/parse/pragma2.C, as the\nold behavior is restored.\n\nFrom-SVN: r253686", "tree": {"sha": "ebedc33278fd940d2f13db951d60f5634e8eaf83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ebedc33278fd940d2f13db951d60f5634e8eaf83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e95c91292876830c8e36b0a55f0c03d1247aaccb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e95c91292876830c8e36b0a55f0c03d1247aaccb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e95c91292876830c8e36b0a55f0c03d1247aaccb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e95c91292876830c8e36b0a55f0c03d1247aaccb/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2c79bfcfc985e116ad1ef85579168428f14f0538", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c79bfcfc985e116ad1ef85579168428f14f0538", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c79bfcfc985e116ad1ef85579168428f14f0538"}], "stats": {"total": 188, "additions": 112, "deletions": 76}, "files": [{"sha": "4c78cc0a01b0a981fbc92111ffda454f7a9458f9", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95c91292876830c8e36b0a55f0c03d1247aaccb/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95c91292876830c8e36b0a55f0c03d1247aaccb/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e95c91292876830c8e36b0a55f0c03d1247aaccb", "patch": "@@ -1,3 +1,13 @@\n+2017-10-12  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* parser.c (get_matching_symbol): Move to before...\n+\t(cp_parser_error): Split out into...\n+\t(cp_parser_error_1): ...this new function, merging in content\n+\tfrom...\n+\t(cp_parser_required_error): ...here.  Eliminate partial duplicate\n+\tof body of cp_parser_error in favor of a call to the new\n+\tcp_parser_error_1 helper function.\n+\n 2017-10-11  Nathan Sidwell  <nathan@acm.org>\n \n \t* decl2.c (struct mangled_decl_hash): Use DECL_ASSEMBLER_NAME_RAW."}, {"sha": "b668b59d9ae1aba3b5cf7b2500432e770faff761", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 95, "deletions": 74, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95c91292876830c8e36b0a55f0c03d1247aaccb/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95c91292876830c8e36b0a55f0c03d1247aaccb/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=e95c91292876830c8e36b0a55f0c03d1247aaccb", "patch": "@@ -2770,53 +2770,116 @@ cp_lexer_peek_conflict_marker (cp_lexer *lexer, enum cpp_ttype tok1_kind,\n   return true;\n }\n \n-/* If not parsing tentatively, issue a diagnostic of the form\n+/* Get a description of the matching symbol to TOKEN_DESC e.g. \"(\" for\n+   RT_CLOSE_PAREN.  */\n+\n+static const char *\n+get_matching_symbol (required_token token_desc)\n+{\n+  switch (token_desc)\n+    {\n+    default:\n+      gcc_unreachable ();\n+      return \"\";\n+    case RT_CLOSE_BRACE:\n+      return \"{\";\n+    case RT_CLOSE_PAREN:\n+      return \"(\";\n+    }\n+}\n+\n+/* Subroutine of cp_parser_error and cp_parser_required_error.\n+\n+   Issue a diagnostic of the form\n       FILE:LINE: MESSAGE before TOKEN\n    where TOKEN is the next token in the input stream.  MESSAGE\n    (specified by the caller) is usually of the form \"expected\n-   OTHER-TOKEN\".  */\n+   OTHER-TOKEN\".\n+\n+   This bypasses the check for tentative passing, and potentially\n+   adds material needed by cp_parser_required_error.\n+\n+   If MISSING_TOKEN_DESC is not RT_NONE, and MATCHING_LOCATION is not\n+   UNKNOWN_LOCATION, then we have an unmatched symbol at\n+   MATCHING_LOCATION; highlight this secondary location.  */\n \n static void\n-cp_parser_error (cp_parser* parser, const char* gmsgid)\n+cp_parser_error_1 (cp_parser* parser, const char* gmsgid,\n+\t\t   required_token missing_token_desc,\n+\t\t   location_t matching_location)\n {\n-  if (!cp_parser_simulate_error (parser))\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+  /* This diagnostic makes more sense if it is tagged to the line\n+     of the token we just peeked at.  */\n+  cp_lexer_set_source_position_from_token (token);\n+\n+  if (token->type == CPP_PRAGMA)\n     {\n-      cp_token *token = cp_lexer_peek_token (parser->lexer);\n-      /* This diagnostic makes more sense if it is tagged to the line\n-\t of the token we just peeked at.  */\n-      cp_lexer_set_source_position_from_token (token);\n+      error_at (token->location,\n+\t\t\"%<#pragma%> is not allowed here\");\n+      cp_parser_skip_to_pragma_eol (parser, token);\n+      return;\n+    }\n \n-      if (token->type == CPP_PRAGMA)\n+  /* If this is actually a conflict marker, report it as such.  */\n+  if (token->type == CPP_LSHIFT\n+      || token->type == CPP_RSHIFT\n+      || token->type == CPP_EQ_EQ)\n+    {\n+      location_t loc;\n+      if (cp_lexer_peek_conflict_marker (parser->lexer, token->type, &loc))\n \t{\n-\t  error_at (token->location,\n-\t\t    \"%<#pragma%> is not allowed here\");\n-\t  cp_parser_skip_to_pragma_eol (parser, token);\n+\t  error_at (loc, \"version control conflict marker in file\");\n \t  return;\n \t}\n+    }\n \n-      /* If this is actually a conflict marker, report it as such.  */\n-      if (token->type == CPP_LSHIFT\n-\t  || token->type == CPP_RSHIFT\n-\t  || token->type == CPP_EQ_EQ)\n-\t{\n-\t  location_t loc;\n-\t  if (cp_lexer_peek_conflict_marker (parser->lexer, token->type, &loc))\n-\t    {\n-\t      error_at (loc, \"version control conflict marker in file\");\n-\t      return;\n-\t    }\n-\t}\n+  gcc_rich_location richloc (input_location);\n+\n+  bool added_matching_location = false;\n+\n+  if (missing_token_desc != RT_NONE)\n+    {\n+      /* If matching_location != UNKNOWN_LOCATION, highlight it.\n+\t Attempt to consolidate diagnostics by printing it as a\n+\tsecondary range within the main diagnostic.  */\n+      if (matching_location != UNKNOWN_LOCATION)\n+\tadded_matching_location\n+\t  = richloc.add_location_if_nearby (matching_location);\n+    }\n+\n+  /* Actually emit the error.  */\n+  c_parse_error (gmsgid,\n+\t\t /* Because c_parser_error does not understand\n+\t\t    CPP_KEYWORD, keywords are treated like\n+\t\t    identifiers.  */\n+\t\t (token->type == CPP_KEYWORD ? CPP_NAME : token->type),\n+\t\t token->u.value, token->flags, &richloc);\n \n-      rich_location richloc (line_table, input_location);\n-      c_parse_error (gmsgid,\n-\t\t     /* Because c_parser_error does not understand\n-\t\t\tCPP_KEYWORD, keywords are treated like\n-\t\t\tidentifiers.  */\n-\t\t     (token->type == CPP_KEYWORD ? CPP_NAME : token->type),\n-\t\t     token->u.value, token->flags, &richloc);\n+  if (missing_token_desc != RT_NONE)\n+    {\n+      /* If we weren't able to consolidate matching_location, then\n+\t print it as a secondary diagnostic.  */\n+      if (matching_location != UNKNOWN_LOCATION\n+\t  && !added_matching_location)\n+\tinform (matching_location, \"to match this %qs\",\n+\t\tget_matching_symbol (missing_token_desc));\n     }\n }\n \n+/* If not parsing tentatively, issue a diagnostic of the form\n+      FILE:LINE: MESSAGE before TOKEN\n+   where TOKEN is the next token in the input stream.  MESSAGE\n+   (specified by the caller) is usually of the form \"expected\n+   OTHER-TOKEN\".  */\n+\n+static void\n+cp_parser_error (cp_parser* parser, const char* gmsgid)\n+{\n+  if (!cp_parser_simulate_error (parser))\n+    cp_parser_error_1 (parser, gmsgid, RT_NONE, UNKNOWN_LOCATION);\n+}\n+\n /* Issue an error about name-lookup failing.  NAME is the\n    IDENTIFIER_NODE DECL is the result of\n    the lookup (as returned from cp_parser_lookup_name).  DESIRED is\n@@ -28081,24 +28144,6 @@ cp_parser_friend_p (const cp_decl_specifier_seq *decl_specifiers)\n   return decl_spec_seq_has_spec_p (decl_specifiers, ds_friend);\n }\n \n-/* Get a description of the matching symbol to TOKEN_DESC e.g. \"(\" for\n-   RT_CLOSE_PAREN.  */\n-\n-static const char *\n-get_matching_symbol (required_token token_desc)\n-{\n-  switch (token_desc)\n-    {\n-    default:\n-      gcc_unreachable ();\n-      return \"\";\n-    case RT_CLOSE_BRACE:\n-      return \"{\";\n-    case RT_CLOSE_PAREN:\n-      return \"(\";\n-    }\n-}\n-\n /* Issue an error message indicating that TOKEN_DESC was expected.\n    If KEYWORD is true, it indicated this function is called by\n    cp_parser_require_keword and the required token can only be\n@@ -28276,31 +28321,7 @@ cp_parser_required_error (cp_parser *parser,\n     }\n \n   if (gmsgid)\n-    {\n-      /* Emulate rest of cp_parser_error.  */\n-      cp_token *token = cp_lexer_peek_token (parser->lexer);\n-      cp_lexer_set_source_position_from_token (token);\n-\n-      gcc_rich_location richloc (input_location);\n-\n-      /* If matching_location != UNKNOWN_LOCATION, highlight it.\n-\t Attempt to consolidate diagnostics by printing it as a\n-\tsecondary range within the main diagnostic.  */\n-      bool added_matching_location = false;\n-      if (matching_location != UNKNOWN_LOCATION)\n-\tadded_matching_location\n-\t  = richloc.add_location_if_nearby (matching_location);\n-\n-      c_parse_error (gmsgid,\n-\t\t     (token->type == CPP_KEYWORD ? CPP_NAME : token->type),\n-\t\t     token->u.value, token->flags, &richloc);\n-\n-      /* If we weren't able to consolidate matching_location, then\n-\t print it as a secondary diagnostic.  */\n-      if (matching_location != UNKNOWN_LOCATION && !added_matching_location)\n-\tinform (matching_location, \"to match this %qs\",\n-\t\tget_matching_symbol (token_desc));\n-    }\n+    cp_parser_error_1 (parser, gmsgid, token_desc, matching_location);\n }\n \n "}, {"sha": "47b3f78c9a3a7243cc7d982ab5145affde89657f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95c91292876830c8e36b0a55f0c03d1247aaccb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95c91292876830c8e36b0a55f0c03d1247aaccb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e95c91292876830c8e36b0a55f0c03d1247aaccb", "patch": "@@ -1,3 +1,8 @@\n+2017-10-12  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* g++.dg/parse/pragma2.C: Update to reflect reinstatement of the\n+\t\"#pragma is not allowed here\" error.\n+\n 2017-10-12  Bin Cheng  <bin.cheng@arm.com>\n \n \t* gcc.dg/tree-ssa/ldist-28.c: New test."}, {"sha": "c5616ff74f53e49d2141e8a71a7eda4a32fae2c2", "filename": "gcc/testsuite/g++.dg/parse/pragma2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95c91292876830c8e36b0a55f0c03d1247aaccb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fpragma2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95c91292876830c8e36b0a55f0c03d1247aaccb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fpragma2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fpragma2.C?ref=e95c91292876830c8e36b0a55f0c03d1247aaccb", "patch": "@@ -4,5 +4,5 @@\n // does not.\n int f(int x,\n #pragma interface  // { dg-error \"not allowed here\" }\n-      // { dg-bogus \"expected identifier\" \"\" { xfail *-*-* } .-1 }\n-      int y);\n+      // The parser gets confused and issues an error on the next line.\n+      int y); // { dg-bogus \"\" \"\" { xfail *-*-* } } "}]}