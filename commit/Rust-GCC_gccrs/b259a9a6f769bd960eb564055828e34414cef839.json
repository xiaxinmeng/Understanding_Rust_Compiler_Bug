{"sha": "b259a9a6f769bd960eb564055828e34414cef839", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI1OWE5YTZmNzY5YmQ5NjBlYjU2NDA1NTgyOGUzNDQxNGNlZjgzOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2003-05-03T08:10:17Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2003-05-03T08:10:17Z"}, "message": "mips.c (mips_integer_op): New structure.\n\n\t* config/mips/mips.c (mips_integer_op): New structure.\n\t(MIPS_MAX_INTEGER_OPS): Define.\n\t(mips_const_insns): Use mips_build_integer to determine the number\n\tof instructions needed to load a CONST_INT.\n\t(move_operand): Reject compound CONST_INTs.\n\t(mips_build_shift, mips_build_lower, mips_build_integer): New fns.\n\t(mips_move_integer): New fn.\n\t(mips_legitimize_const_move): Pass CONST_INTs to mips_move_integer.\n\t(mips_legitimize_move): Only legitimize constants when moving\n\tword or subword values.\n\nFrom-SVN: r66419", "tree": {"sha": "ba7a4dab8a0d9dfbc4136b4be20a1621c1d3e3b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba7a4dab8a0d9dfbc4136b4be20a1621c1d3e3b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b259a9a6f769bd960eb564055828e34414cef839", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b259a9a6f769bd960eb564055828e34414cef839", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b259a9a6f769bd960eb564055828e34414cef839", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b259a9a6f769bd960eb564055828e34414cef839/comments", "author": null, "committer": null, "parents": [{"sha": "d4c67b6ee3f0b8b3da21a2233397512805d93264", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4c67b6ee3f0b8b3da21a2233397512805d93264", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4c67b6ee3f0b8b3da21a2233397512805d93264"}], "stats": {"total": 209, "additions": 199, "deletions": 10}, "files": [{"sha": "956692822ef5653a58b467ef3bcf379fc22f6dcd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b259a9a6f769bd960eb564055828e34414cef839/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b259a9a6f769bd960eb564055828e34414cef839/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b259a9a6f769bd960eb564055828e34414cef839", "patch": "@@ -1,3 +1,16 @@\n+2003-05-03  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips.c (mips_integer_op): New structure.\n+\t(MIPS_MAX_INTEGER_OPS): Define.\n+\t(mips_const_insns): Use mips_build_integer to determine the number\n+\tof instructions needed to load a CONST_INT.\n+\t(move_operand): Reject compound CONST_INTs.\n+\t(mips_build_shift, mips_build_lower, mips_build_integer): New fns.\n+\t(mips_move_integer): New fn.\n+\t(mips_legitimize_const_move): Pass CONST_INTs to mips_move_integer.\n+\t(mips_legitimize_move): Only legitimize constants when moving\n+\tword or subword values.\n+\n 2003-05-02  Matt Kraai  <kraai@alumni.cmu.edu>\n \n \t* Makefile.in (gcov-iov.h): Use move-if-change and a stamp."}, {"sha": "45802fbd3d59e7e92140504d17d08233f2e5b3cc", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 186, "deletions": 10, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b259a9a6f769bd960eb564055828e34414cef839/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b259a9a6f769bd960eb564055828e34414cef839/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=b259a9a6f769bd960eb564055828e34414cef839", "patch": "@@ -179,6 +179,7 @@ struct constant;\n struct mips_arg_info;\n struct mips_constant_info;\n struct mips_address_info;\n+struct mips_integer_op;\n static enum mips_constant_type mips_classify_constant\n \t\t\t\tPARAMS ((struct mips_constant_info *, rtx));\n static enum mips_symbol_type mips_classify_symbol\n@@ -209,6 +210,13 @@ static rtx mips_emit_high\t\t\tPARAMS ((rtx, rtx));\n static bool mips_legitimize_symbol\t\tPARAMS ((rtx, rtx *, int));\n static rtx mips_reloc\t\t\t\tPARAMS ((rtx, int));\n static rtx mips_lui_reloc\t\t\tPARAMS ((rtx, int));\n+static unsigned int mips_build_shift\tPARAMS ((struct mips_integer_op *,\n+\t\t\t\t\t\t HOST_WIDE_INT));\n+static unsigned int mips_build_lower\tPARAMS ((struct mips_integer_op *,\n+\t\t\t\t\t\t unsigned HOST_WIDE_INT));\n+static unsigned int mips_build_integer\tPARAMS ((struct mips_integer_op *,\n+\t\t\t\t\t\t unsigned HOST_WIDE_INT));\n+static void mips_move_integer\t\tPARAMS ((rtx, unsigned HOST_WIDE_INT));\n static void mips_legitimize_const_move\t\tPARAMS ((enum machine_mode,\n \t\t\t\t\t\t\t rtx, rtx));\n static int m16_check_op\t\t\t\tPARAMS ((rtx, int, int, int));\n@@ -395,6 +403,29 @@ struct mips_address_info\n };\n \n \n+/* One stage in a constant building sequence.  These sequences have\n+   the form:\n+\n+\tA = VALUE[0]\n+\tA = A CODE[1] VALUE[1]\n+\tA = A CODE[2] VALUE[2]\n+\t...\n+\n+   where A is an accumulator, each CODE[i] is a binary rtl operation\n+   and each VALUE[i] is a constant integer.  */\n+struct mips_integer_op {\n+  enum rtx_code code;\n+  unsigned HOST_WIDE_INT value;\n+};\n+\n+\n+/* The largest number of operations needed to load an integer constant.\n+   The worst accepted case for 64-bit constants is LUI,ORI,SLL,ORI,SLL,ORI.\n+   When the lowest bit is clear, we can try, but reject a sequence with\n+   an extra SLL at the end.  */\n+#define MIPS_MAX_INTEGER_OPS 7\n+\n+\n /* Global variables for machine-dependent things.  */\n \n /* Threshold for data being put into the small data/bss area, instead\n@@ -1255,6 +1286,7 @@ mips_const_insns (x)\n      rtx x;\n {\n   struct mips_constant_info c;\n+  struct mips_integer_op codes[MIPS_MAX_INTEGER_OPS];\n \n   switch (GET_CODE (x))\n     {\n@@ -1274,15 +1306,7 @@ mips_const_insns (x)\n \t\t: SMALL_OPERAND_UNSIGNED (-INTVAL (x)) ? 3\n \t\t: 0);\n \n-      /* Return 1 for constants that can be loaded using ORI, ADDIU,\n-\t or LUI.  Return 2 for constants that can be loaded using\n-\t LUI followed by ORI.  Assume the worst case for all others.\n-\t (The worst case is: LUI, ORI, SLL, ORI, SLL, ORI.)  */\n-      return (SMALL_OPERAND (INTVAL (x)) ? 1\n-\t      : SMALL_OPERAND_UNSIGNED (INTVAL (x)) ? 1\n-\t      : LUI_OPERAND (INTVAL (x)) ? 1\n-\t      : LUI_OPERAND (INTVAL (x) & ~(unsigned HOST_WIDE_INT) 0xffff) ? 2\n-\t      : 6);\n+      return mips_build_integer (codes, INTVAL (x));\n \n     case CONST_DOUBLE:\n       return (!TARGET_MIPS16 && x == CONST0_RTX (GET_MODE (x)) ? 1 : 0);\n@@ -1610,6 +1634,8 @@ move_operand (op, mode)\n \n   if (GET_CODE (op) == HIGH && TARGET_ABICALLS)\n     return false;\n+  if (GET_CODE (op) == CONST_INT && !TARGET_MIPS16)\n+    return (SMALL_INT (op) || SMALL_INT_UNSIGNED (op) || LUI_INT (op));\n   if (mips_classify_constant (&c, op) == CONSTANT_SYMBOLIC)\n     return mips_symbolic_address_p (c.symbol, c.offset, word_mode, 1);\n   return general_operand (op, mode);\n@@ -1938,6 +1964,144 @@ mips_legitimize_address (xloc, mode)\n }\n \n \n+/* Subroutine of mips_build_integer (with the same interface).\n+   Assume that the final action in the sequence should be a left shift.  */\n+\n+static unsigned int\n+mips_build_shift (codes, value)\n+     struct mips_integer_op *codes;\n+     HOST_WIDE_INT value;\n+{\n+  unsigned int i, shift;\n+\n+  /* Shift VALUE right until its lowest bit is set.  Shift arithmetically\n+     since signed numbers are easier to load than unsigned ones.  */\n+  shift = 0;\n+  while ((value & 1) == 0)\n+    value /= 2, shift++;\n+\n+  i = mips_build_integer (codes, value);\n+  codes[i].code = ASHIFT;\n+  codes[i].value = shift;\n+  return i + 1;\n+}\n+\n+\n+/* As for mips_build_shift, but assume that the final action will be\n+   an IOR or PLUS operation.  */\n+\n+static unsigned int\n+mips_build_lower (codes, value)\n+     struct mips_integer_op *codes;\n+     unsigned HOST_WIDE_INT value;\n+{\n+  unsigned HOST_WIDE_INT high;\n+  unsigned int i;\n+\n+  high = value & ~(unsigned HOST_WIDE_INT) 0xffff;\n+  if (!LUI_OPERAND (high) && (value & 0x18000) == 0x18000)\n+    {\n+      /* The constant is too complex to load with a simple lui/ori pair\n+\t so our goal is to clear as many trailing zeros as possible.\n+\t In this case, we know bit 16 is set and that the low 16 bits\n+\t form a negative number.  If we subtract that number from VALUE,\n+\t we will clear at least the lowest 17 bits, maybe more.  */\n+      i = mips_build_integer (codes, CONST_HIGH_PART (value));\n+      codes[i].code = PLUS;\n+      codes[i].value = CONST_LOW_PART (value);\n+    }\n+  else\n+    {\n+      i = mips_build_integer (codes, high);\n+      codes[i].code = IOR;\n+      codes[i].value = value & 0xffff;\n+    }\n+  return i + 1;\n+}\n+\n+\n+/* Fill CODES with a sequence of rtl operations to load VALUE.\n+   Return the number of operations needed.  */\n+\n+static unsigned int\n+mips_build_integer (codes, value)\n+     struct mips_integer_op *codes;\n+     unsigned HOST_WIDE_INT value;\n+{\n+  if (SMALL_OPERAND (value)\n+      || SMALL_OPERAND_UNSIGNED (value)\n+      || LUI_OPERAND (value))\n+    {\n+      /* The value can be loaded with a single instruction.  */\n+      codes[0].code = NIL;\n+      codes[0].value = value;\n+      return 1;\n+    }\n+  else if ((value & 1) != 0 || LUI_OPERAND (CONST_HIGH_PART (value)))\n+    {\n+      /* Either the constant is a simple LUI/ORI combination or its\n+\t lowest bit is set.  We don't want to shift in this case.  */\n+      return mips_build_lower (codes, value);\n+    }\n+  else if ((value & 0xffff) == 0)\n+    {\n+      /* The constant will need at least three actions.  The lowest\n+\t 16 bits are clear, so the final action will be a shift.  */\n+      return mips_build_shift (codes, value);\n+    }\n+  else\n+    {\n+      /* The final action could be a shift, add or inclusive OR.\n+\t Rather than use a complex condition to select the best\n+\t approach, try both mips_build_shift and mips_build_lower\n+\t and pick the one that gives the shortest sequence.\n+\t Note that this case is only used once per constant.  */\n+      struct mips_integer_op alt_codes[MIPS_MAX_INTEGER_OPS];\n+      unsigned int cost, alt_cost;\n+\n+      cost = mips_build_shift (codes, value);\n+      alt_cost = mips_build_lower (alt_codes, value);\n+      if (alt_cost < cost)\n+\t{\n+\t  memcpy (codes, alt_codes, alt_cost * sizeof (codes[0]));\n+\t  cost = alt_cost;\n+\t}\n+      return cost;\n+    }\n+}\n+\n+\n+/* Move VALUE into register DEST.  */\n+\n+static void\n+mips_move_integer (dest, value)\n+     rtx dest;\n+     unsigned HOST_WIDE_INT value;\n+{\n+  struct mips_integer_op codes[MIPS_MAX_INTEGER_OPS];\n+  enum machine_mode mode;\n+  unsigned int i, cost;\n+  rtx x;\n+\n+  mode = GET_MODE (dest);\n+  cost = mips_build_integer (codes, value);\n+\n+  /* Apply each binary operation to X.  Invariant: X is a legitimate\n+     source operand for a SET pattern.  */\n+  x = GEN_INT (codes[0].value);\n+  for (i = 1; i < cost; i++)\n+    {\n+      if (no_new_pseudos)\n+\temit_move_insn (dest, x), x = dest;\n+      else\n+\tx = force_reg (mode, x);\n+      x = gen_rtx_fmt_ee (codes[i].code, mode, x, GEN_INT (codes[i].value));\n+    }\n+\n+  emit_insn (gen_rtx_SET (VOIDmode, dest, x));\n+}\n+\n+\n /* Subroutine of mips_legitimize_move.  Move constant SRC into register\n    DEST given that SRC satisfies immediate_operand but doesn't satisfy\n    move_operand.  */\n@@ -1958,6 +2122,12 @@ mips_legitimize_const_move (mode, dest, src)\n       return;\n     }\n \n+  if (GET_CODE (src) == CONST_INT && !TARGET_MIPS16)\n+    {\n+      mips_move_integer (dest, INTVAL (src));\n+      return;\n+    }\n+\n   /* Fetch global symbols from the GOT.  */\n   if (TARGET_EXPLICIT_RELOCS\n       && GET_CODE (src) == SYMBOL_REF\n@@ -2007,7 +2177,13 @@ mips_legitimize_move (mode, dest, src)\n       return true;\n     }\n \n-  if (CONSTANT_P (src) && !move_operand (src, mode))\n+  /* The source of an SImode move must be a move_operand.  Likewise\n+     DImode moves on 64-bit targets.  We need to deal with constants\n+     that would be legitimate immediate_operands but not legitimate\n+     move_operands.  */\n+  if (GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n+      && CONSTANT_P (src)\n+      && !move_operand (src, mode))\n     {\n       mips_legitimize_const_move (mode, dest, src);\n       set_unique_reg_note (get_last_insn (), REG_EQUAL, copy_rtx (src));"}]}