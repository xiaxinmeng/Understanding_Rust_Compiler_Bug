{"sha": "4700dd70e183e91a3ff6014ddcd59f68c526d02b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDcwMGRkNzBlMTgzZTkxYTNmZjYwMTRkZGNkNTlmNjhjNTI2ZDAyYg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2012-09-05T13:37:12Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-09-05T13:37:12Z"}, "message": "bb-reorder.c: Clarify a few points in the head comment and fix long lines in other comments.\n\n\t* bb-reorder.c: Clarify a few points in the head comment and fix\n\tlong lines in other comments.\n\t(find_traces): Fix long line.\n\t(find_traces_1_round): Likewise.\n\t(better_edge_p): Likewise.\n\t(connect_traces): Likewise.\n\t(duplicate_computed_gotos): Likewise.\n\t(find_rarely_executed_basic_blocks_and_cr): Remove trailing spaces.\n\t(fix_up_fall_thru_edges): Fix formatting.\n\nFrom-SVN: r190979", "tree": {"sha": "492cbf4a6468ce4bef99a344893050ab90f5bbc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/492cbf4a6468ce4bef99a344893050ab90f5bbc0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4700dd70e183e91a3ff6014ddcd59f68c526d02b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4700dd70e183e91a3ff6014ddcd59f68c526d02b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4700dd70e183e91a3ff6014ddcd59f68c526d02b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4700dd70e183e91a3ff6014ddcd59f68c526d02b/comments", "author": null, "committer": null, "parents": [{"sha": "18eb76ebfa25806dab9a23e726f1d8f914c51630", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18eb76ebfa25806dab9a23e726f1d8f914c51630", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18eb76ebfa25806dab9a23e726f1d8f914c51630"}], "stats": {"total": 134, "additions": 76, "deletions": 58}, "files": [{"sha": "be43602d4c54e392cfbadb8f940ebbf54ec3b70f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4700dd70e183e91a3ff6014ddcd59f68c526d02b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4700dd70e183e91a3ff6014ddcd59f68c526d02b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4700dd70e183e91a3ff6014ddcd59f68c526d02b", "patch": "@@ -1,3 +1,15 @@\n+2012-09-05  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* bb-reorder.c: Clarify a few points in the head comment and fix\n+\tlong lines in other comments.\n+\t(find_traces): Fix long line.\n+\t(find_traces_1_round): Likewise.\n+\t(better_edge_p): Likewise.\n+\t(connect_traces): Likewise.\n+\t(duplicate_computed_gotos): Likewise.\n+\t(find_rarely_executed_basic_blocks_and_cr): Remove trailing spaces.\n+\t(fix_up_fall_thru_edges): Fix formatting.\n+\n 2012-09-05  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/46590"}, {"sha": "055c67b704e21b7d8797c0d6ca6c676b5cd865ca", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 64, "deletions": 58, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4700dd70e183e91a3ff6014ddcd59f68c526d02b/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4700dd70e183e91a3ff6014ddcd59f68c526d02b/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=4700dd70e183e91a3ff6014ddcd59f68c526d02b", "patch": "@@ -20,41 +20,41 @@\n \n /* This (greedy) algorithm constructs traces in several rounds.\n    The construction starts from \"seeds\".  The seed for the first round\n-   is the entry point of function.  When there are more than one seed\n-   that one is selected first that has the lowest key in the heap\n-   (see function bb_to_key).  Then the algorithm repeatedly adds the most\n-   probable successor to the end of a trace.  Finally it connects the traces.\n+   is the entry point of the function.  When there are more than one seed,\n+   the one with the lowest key in the heap is selected first (see bb_to_key).\n+   Then the algorithm repeatedly adds the most probable successor to the end\n+   of a trace.  Finally it connects the traces.\n \n    There are two parameters: Branch Threshold and Exec Threshold.\n-   If the edge to a successor of the actual basic block is lower than\n-   Branch Threshold or the frequency of the successor is lower than\n-   Exec Threshold the successor will be the seed in one of the next rounds.\n+   If the probability of an edge to a successor of the current basic block is\n+   lower than Branch Threshold or its frequency is lower than Exec Threshold,\n+   then the successor will be the seed in one of the next rounds.\n    Each round has these parameters lower than the previous one.\n-   The last round has to have these parameters set to zero\n-   so that the remaining blocks are picked up.\n+   The last round has to have these parameters set to zero so that the\n+   remaining blocks are picked up.\n \n    The algorithm selects the most probable successor from all unvisited\n    successors and successors that have been added to this trace.\n    The other successors (that has not been \"sent\" to the next round) will be\n-   other seeds for this round and the secondary traces will start in them.\n-   If the successor has not been visited in this trace it is added to the trace\n-   (however, there is some heuristic for simple branches).\n-   If the successor has been visited in this trace the loop has been found.\n-   If the loop has many iterations the loop is rotated so that the\n-   source block of the most probable edge going out from the loop\n-   is the last block of the trace.\n+   other seeds for this round and the secondary traces will start from them.\n+   If the successor has not been visited in this trace, it is added to the\n+   trace (however, there is some heuristic for simple branches).\n+   If the successor has been visited in this trace, a loop has been found.\n+   If the loop has many iterations, the loop is rotated so that the source\n+   block of the most probable edge going out of the loop is the last block\n+   of the trace.\n    If the loop has few iterations and there is no edge from the last block of\n-   the loop going out from loop the loop header is duplicated.\n-   Finally, the construction of the trace is terminated.\n+   the loop going out of the loop, the loop header is duplicated.\n \n-   When connecting traces it first checks whether there is an edge from the\n-   last block of one trace to the first block of another trace.\n+   When connecting traces, the algorithm first checks whether there is an edge\n+   from the last block of a trace to the first block of another trace.\n    When there are still some unconnected traces it checks whether there exists\n-   a basic block BB such that BB is a successor of the last bb of one trace\n-   and BB is a predecessor of the first block of another trace. In this case,\n-   BB is duplicated and the traces are connected through this duplicate.\n+   a basic block BB such that BB is a successor of the last block of a trace\n+   and BB is a predecessor of the first block of another trace.  In this case,\n+   BB is duplicated, added at the end of the first trace and the traces are\n+   connected through it.\n    The rest of traces are simply connected so there will be a jump to the\n-   beginning of the rest of trace.\n+   beginning of the rest of traces.\n \n \n    References:\n@@ -89,11 +89,11 @@\n \n /* The number of rounds.  In most cases there will only be 4 rounds, but\n    when partitioning hot and cold basic blocks into separate sections of\n-   the .o file there will be an extra round.*/\n+   the object file there will be an extra round.  */\n #define N_ROUNDS 5\n \n /* Stubs in case we don't have a return insn.\n-   We have to check at runtime too, not only compiletime.  */\n+   We have to check at run time too, not only compile time.  */\n \n #ifndef HAVE_return\n #define HAVE_return 0\n@@ -122,10 +122,10 @@ static int exec_threshold[N_ROUNDS] = {500, 200, 50, 0, 0};\n /* Structure to hold needed information for each basic block.  */\n typedef struct bbro_basic_block_data_def\n {\n-  /* Which trace is the bb start of (-1 means it is not a start of a trace).  */\n+  /* Which trace is the bb start of (-1 means it is not a start of any).  */\n   int start_of_trace;\n \n-  /* Which trace is the bb end of (-1 means it is not an end of a trace).  */\n+  /* Which trace is the bb end of (-1 means it is not an end of any).  */\n   int end_of_trace;\n \n   /* Which trace is the bb in?  */\n@@ -179,7 +179,8 @@ static void find_traces_1_round (int, int, gcov_type, struct trace *, int *,\n \t\t\t\t int, fibheap_t *, int);\n static basic_block copy_bb (basic_block, edge, basic_block, int);\n static fibheapkey_t bb_to_key (basic_block);\n-static bool better_edge_p (const_basic_block, const_edge, int, int, int, int, const_edge);\n+static bool better_edge_p (const_basic_block, const_edge, int, int, int, int,\n+\t\t\t   const_edge);\n static void connect_traces (int, struct trace *);\n static bool copy_bb_p (const_basic_block, int);\n static bool push_to_next_round_p (const_basic_block, int, int, int, gcov_type);\n@@ -296,7 +297,9 @@ find_traces (int *n_traces, struct trace *traces)\n \t  basic_block bb;\n \t  fprintf (dump_file, \"Trace %d (round %d):  \", i + 1,\n \t\t   traces[i].round + 1);\n-\t  for (bb = traces[i].first; bb != traces[i].last; bb = (basic_block) bb->aux)\n+\t  for (bb = traces[i].first;\n+\t       bb != traces[i].last;\n+\t       bb = (basic_block) bb->aux)\n \t    fprintf (dump_file, \"%d [%d] \", bb->index, bb->frequency);\n \t  fprintf (dump_file, \"%d [%d]\\n\", bb->index, bb->frequency);\n \t}\n@@ -421,13 +424,13 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n   return best_bb;\n }\n \n-/* One round of finding traces. Find traces for BRANCH_TH and EXEC_TH i.e. do\n-   not include basic blocks their probability is lower than BRANCH_TH or their\n-   frequency is lower than EXEC_TH into traces (or count is lower than\n-   COUNT_TH).  It stores the new traces into TRACES and modifies the number of\n-   traces *N_TRACES. Sets the round (which the trace belongs to) to ROUND. It\n-   expects that starting basic blocks are in *HEAP and at the end it deletes\n-   *HEAP and stores starting points for the next round into new *HEAP.  */\n+/* One round of finding traces.  Find traces for BRANCH_TH and EXEC_TH i.e. do\n+   not include basic blocks whose probability is lower than BRANCH_TH or whose\n+   frequency is lower than EXEC_TH into traces (or whose count is lower than\n+   COUNT_TH).  Store the new traces into TRACES and modify the number of\n+   traces *N_TRACES.  Set the round (which the trace belongs to) to ROUND.\n+   The function expects starting basic blocks to be in *HEAP and will delete\n+   *HEAP and store starting points for the next round into new *HEAP.  */\n \n static void\n find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n@@ -453,7 +456,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n       if (dump_file)\n \tfprintf (dump_file, \"Getting bb %d\\n\", bb->index);\n \n-      /* If the BB's frequency is too low send BB to the next round.  When\n+      /* If the BB's frequency is too low, send BB to the next round.  When\n \t partitioning hot/cold blocks into separate sections, make sure all\n \t the cold blocks (and ONLY the cold blocks) go into the (extra) final\n \t round.  */\n@@ -653,7 +656,8 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \n \t\t\t  if (single_succ_p (bb)\n \t\t\t      && copy_bb_p (best_edge->dest,\n-\t\t\t      \t\t    optimize_edge_for_speed_p (best_edge)))\n+\t\t\t      \t\t    optimize_edge_for_speed_p\n+\t\t\t      \t\t    (best_edge)))\n \t\t\t    {\n \t\t\t      bb = copy_bb (best_edge->dest, best_edge, bb,\n \t\t\t\t\t    *n_traces);\n@@ -843,6 +847,7 @@ bb_to_key (basic_block bb)\n   if (priority)\n     /* The block with priority should have significantly lower key.  */\n     return -(100 * BB_FREQ_MAX + 100 * priority + bb->frequency);\n+\n   return -bb->frequency;\n }\n \n@@ -854,8 +859,8 @@ bb_to_key (basic_block bb)\n    BEST_PROB; similarly for frequency.  */\n \n static bool\n-better_edge_p (const_basic_block bb, const_edge e, int prob, int freq, int best_prob,\n-\t       int best_freq, const_edge cur_best_edge)\n+better_edge_p (const_basic_block bb, const_edge e, int prob, int freq,\n+\t       int best_prob, int best_freq, const_edge cur_best_edge)\n {\n   bool is_better_edge;\n \n@@ -1081,9 +1086,9 @@ connect_traces (int n_traces, struct trace *traces)\n \t\t\t\t&& !(e2->flags & EDGE_COMPLEX)\n \t\t\t\t&& bbd[di].start_of_trace >= 0\n \t\t\t\t&& !connected[bbd[di].start_of_trace]\n-\t\t\t\t&& (BB_PARTITION (e2->dest) == current_partition)\n-\t\t\t\t&& (EDGE_FREQUENCY (e2) >= freq_threshold)\n-\t\t\t\t&& (e2->count >= count_threshold)\n+\t\t\t\t&& BB_PARTITION (e2->dest) == current_partition\n+\t\t\t\t&& EDGE_FREQUENCY (e2) >= freq_threshold\n+\t\t\t\t&& e2->count >= count_threshold\n \t\t\t\t&& (!best2\n \t\t\t\t    || e2->probability > best2->probability\n \t\t\t\t    || (e2->probability == best2->probability\n@@ -1361,7 +1366,7 @@ find_rarely_executed_basic_blocks_and_crossing_edges (void)\n     FOR_EACH_EDGE (e, ei, bb->succs)\n       {\n \tunsigned int flags = e->flags;\n-      \n+\n         /* We should never have EDGE_CROSSING set yet.  */\n \tgcc_checking_assert ((flags & EDGE_CROSSING) == 0);\n \n@@ -1591,13 +1596,13 @@ fix_up_fall_thru_edges (void)\n \t\t     block are crossing edges. Here we will fix up the\n \t\t     fall through edge. The jump edge will be taken care\n \t\t     of later.  The EDGE_CROSSING flag of fall_thru edge\n-                     is unset before the call to force_nonfallthru\n-                     function because if a new basic-block is created\n-                     this edge remains in the current section boundary\n-                     while the edge between new_bb and the fall_thru->dest\n-                     becomes EDGE_CROSSING.  */\n+\t\t     is unset before the call to force_nonfallthru\n+\t\t     function because if a new basic-block is created\n+\t\t     this edge remains in the current section boundary\n+\t\t     while the edge between new_bb and the fall_thru->dest\n+\t\t     becomes EDGE_CROSSING.  */\n \n-                  fall_thru->flags &= ~EDGE_CROSSING;\n+\t\t  fall_thru->flags &= ~EDGE_CROSSING;\n \t\t  new_bb = force_nonfallthru (fall_thru);\n \n \t\t  if (new_bb)\n@@ -1611,12 +1616,12 @@ fix_up_fall_thru_edges (void)\n \t\t      BB_COPY_PARTITION (new_bb, cur_bb);\n \t\t      single_succ_edge (new_bb)->flags |= EDGE_CROSSING;\n \t\t    }\n-                  else\n-                    {\n-                      /* If a new basic-block was not created; restore\n-                         the EDGE_CROSSING flag.  */\n-                      fall_thru->flags |= EDGE_CROSSING;\n-                    }\n+\t\t  else\n+\t\t    {\n+\t\t      /* If a new basic-block was not created; restore\n+\t\t\t the EDGE_CROSSING flag.  */\n+\t\t      fall_thru->flags |= EDGE_CROSSING;\n+\t\t    }\n \n \t\t  /* Add barrier after new jump */\n \t\t  emit_barrier_after_bb (new_bb ? new_bb : cur_bb);\n@@ -2132,7 +2137,8 @@ duplicate_computed_gotos (void)\n   if (uncond_jump_length == 0)\n     uncond_jump_length = get_uncond_jump_length ();\n \n-  max_size = uncond_jump_length * PARAM_VALUE (PARAM_MAX_GOTO_DUPLICATION_INSNS);\n+  max_size\n+    = uncond_jump_length * PARAM_VALUE (PARAM_MAX_GOTO_DUPLICATION_INSNS);\n   candidates = BITMAP_ALLOC (NULL);\n \n   /* Look for blocks that end in a computed jump, and see if such blocks"}]}