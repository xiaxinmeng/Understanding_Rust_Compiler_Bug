{"sha": "36a9255b1b6683bb060021c637997de396445049", "node_id": "C_kwDOANBUbNoAKDM2YTkyNTViMWI2NjgzYmIwNjAwMjFjNjM3OTk3ZGUzOTY0NDUwNDk", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-22T14:54:14Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-23T13:06:40Z"}, "message": "Refactor our casts to follow the Rustc implemention\n\nThis gets rid of our old visitor system for cast type checking. Casts\ndepend on type coercions as they are meant to attempt a type coercion\nbefore trying a simple cast. This explicitly defines the rules which should\nbe allowed for simple casts. In rustc they use match expressions to write\na list of casts which should not be allowed. We have likely missed some\nrules of what should be allowed but this is at least the start of how\nto implement this.\n\nFixes #1496", "tree": {"sha": "64543a9781cb47d426120f92ea05720256089395", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/64543a9781cb47d426120f92ea05720256089395"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36a9255b1b6683bb060021c637997de396445049", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36a9255b1b6683bb060021c637997de396445049", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36a9255b1b6683bb060021c637997de396445049", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36a9255b1b6683bb060021c637997de396445049/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f4ec11e8c2399ca20f80b4006e294794f9b2e0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f4ec11e8c2399ca20f80b4006e294794f9b2e0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f4ec11e8c2399ca20f80b4006e294794f9b2e0f"}], "stats": {"total": 2292, "additions": 600, "deletions": 1692}, "files": [{"sha": "f687cc2f667595a263595136650df3cc690bd154", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a9255b1b6683bb060021c637997de396445049/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a9255b1b6683bb060021c637997de396445049/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=36a9255b1b6683bb060021c637997de396445049", "patch": "@@ -122,6 +122,7 @@ GRS_OBJS = \\\n     rust/rust-hir-type-check-implitem.o \\\n     rust/rust-hir-dot-operator.o \\\n     rust/rust-coercion.o \\\n+    rust/rust-casts.o \\\n     rust/rust-hir-type-check-base.o \\\n     rust/rust-autoderef.o \\\n     rust/rust-substitution-mapper.o \\"}, {"sha": "865ad250f2cbbe47484555493cd2c66bab8a5c11", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a9255b1b6683bb060021c637997de396445049/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a9255b1b6683bb060021c637997de396445049/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=36a9255b1b6683bb060021c637997de396445049", "patch": "@@ -237,16 +237,34 @@ CompileExpr::visit (HIR::LazyBooleanExpr &expr)\n void\n CompileExpr::visit (HIR::TypeCastExpr &expr)\n {\n-  TyTy::BaseType *tyty = nullptr;\n+  TyTy::BaseType *type_to_cast_to_ty = nullptr;\n   if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n-\t\t\t\t       &tyty))\n+\t\t\t\t       &type_to_cast_to_ty))\n     {\n       translated = error_mark_node;\n       return;\n     }\n \n-  auto type_to_cast_to = TyTyResolveCompile::compile (ctx, tyty);\n+  TyTy::BaseType *casted_tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (\n+\texpr.get_casted_expr ()->get_mappings ().get_hirid (), &casted_tyty))\n+    {\n+      translated = error_mark_node;\n+      return;\n+    }\n+\n+  auto type_to_cast_to = TyTyResolveCompile::compile (ctx, type_to_cast_to_ty);\n   auto casted_expr = CompileExpr::Compile (expr.get_casted_expr ().get (), ctx);\n+\n+  std::vector<Resolver::Adjustment> *adjustments = nullptr;\n+  bool ok = ctx->get_tyctx ()->lookup_cast_autoderef_mappings (\n+    expr.get_mappings ().get_hirid (), &adjustments);\n+  if (ok)\n+    {\n+      casted_expr\n+\t= resolve_adjustements (*adjustments, casted_expr, expr.get_locus ());\n+    }\n+\n   translated\n     = type_cast_expression (type_to_cast_to, casted_expr, expr.get_locus ());\n }"}, {"sha": "61004dfabc379ddfc542e561b262f89888377367", "filename": "gcc/rust/typecheck/rust-casts.cc", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a9255b1b6683bb060021c637997de396445049/gcc%2Frust%2Ftypecheck%2Frust-casts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a9255b1b6683bb060021c637997de396445049/gcc%2Frust%2Ftypecheck%2Frust-casts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-casts.cc?ref=36a9255b1b6683bb060021c637997de396445049", "patch": "@@ -0,0 +1,292 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-casts.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+TypeCastRules::TypeCastRules (Location locus, TyTy::TyWithLocation from,\n+\t\t\t      TyTy::TyWithLocation to)\n+  : locus (locus), from (from), to (to)\n+{}\n+\n+TypeCoercionRules::CoercionResult\n+TypeCastRules::resolve (Location locus, TyTy::TyWithLocation from,\n+\t\t\tTyTy::TyWithLocation to)\n+{\n+  TypeCastRules cast_rules (locus, from, to);\n+  return cast_rules.check ();\n+}\n+\n+TypeCoercionRules::CoercionResult\n+TypeCastRules::check ()\n+{\n+  // https://github.com/rust-lang/rust/blob/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/compiler/rustc_typeck/src/check/cast.rs#L565-L582\n+  auto possible_coercion\n+    = TypeCoercionRules::TryCoerce (from.get_ty (), to.get_ty (), locus);\n+  if (!possible_coercion.is_error ())\n+    return possible_coercion;\n+\n+  // try the simple cast rules\n+  auto simple_cast = cast_rules ();\n+  if (!simple_cast.is_error ())\n+    return simple_cast;\n+\n+  // failed to cast\n+  emit_cast_error ();\n+  return TypeCoercionRules::CoercionResult::get_error ();\n+}\n+\n+TypeCoercionRules::CoercionResult\n+TypeCastRules::cast_rules ()\n+{\n+  // https://github.com/rust-lang/rust/blob/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/compiler/rustc_typeck/src/check/cast.rs#L596\n+  // https://github.com/rust-lang/rust/blob/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/compiler/rustc_typeck/src/check/cast.rs#L654\n+\n+  rust_debug (\"cast_rules from={%s} to={%s}\",\n+\t      from.get_ty ()->debug_str ().c_str (),\n+\t      to.get_ty ()->debug_str ().c_str ());\n+\n+  switch (from.get_ty ()->get_kind ())\n+    {\n+      case TyTy::TypeKind::INFER: {\n+\tTyTy::InferType *from_infer\n+\t  = static_cast<TyTy::InferType *> (from.get_ty ());\n+\tswitch (from_infer->get_infer_kind ())\n+\t  {\n+\t  case TyTy::InferType::InferTypeKind::GENERAL:\n+\t    return TypeCoercionRules::CoercionResult{{},\n+\t\t\t\t\t\t     to.get_ty ()->clone ()};\n+\n+\t  case TyTy::InferType::InferTypeKind::INTEGRAL:\n+\t    switch (to.get_ty ()->get_kind ())\n+\t      {\n+\t      case TyTy::TypeKind::CHAR:\n+\t      case TyTy::TypeKind::BOOL:\n+\t      case TyTy::TypeKind::USIZE:\n+\t      case TyTy::TypeKind::ISIZE:\n+\t      case TyTy::TypeKind::UINT:\n+\t      case TyTy::TypeKind::INT:\n+\t      case TyTy::TypeKind::POINTER:\n+\t\treturn TypeCoercionRules::CoercionResult{\n+\t\t  {}, to.get_ty ()->clone ()};\n+\n+\t\tcase TyTy::TypeKind::INFER: {\n+\t\t  TyTy::InferType *to_infer\n+\t\t    = static_cast<TyTy::InferType *> (to.get_ty ());\n+\n+\t\t  switch (to_infer->get_infer_kind ())\n+\t\t    {\n+\t\t    case TyTy::InferType::InferTypeKind::GENERAL:\n+\t\t    case TyTy::InferType::InferTypeKind::INTEGRAL:\n+\t\t      return TypeCoercionRules::CoercionResult{\n+\t\t\t{}, to.get_ty ()->clone ()};\n+\n+\t\t    default:\n+\t\t      return TypeCoercionRules::CoercionResult::get_error ();\n+\t\t    }\n+\t\t}\n+\t\tbreak;\n+\n+\t      default:\n+\t\treturn TypeCoercionRules::CoercionResult::get_error ();\n+\t      }\n+\t    break;\n+\n+\t  case TyTy::InferType::InferTypeKind::FLOAT:\n+\t    switch (to.get_ty ()->get_kind ())\n+\t      {\n+\t      case TyTy::TypeKind::USIZE:\n+\t      case TyTy::TypeKind::ISIZE:\n+\t      case TyTy::TypeKind::UINT:\n+\t      case TyTy::TypeKind::INT:\n+\t\treturn TypeCoercionRules::CoercionResult{\n+\t\t  {}, to.get_ty ()->clone ()};\n+\n+\t\tcase TyTy::TypeKind::INFER: {\n+\t\t  TyTy::InferType *to_infer\n+\t\t    = static_cast<TyTy::InferType *> (to.get_ty ());\n+\n+\t\t  switch (to_infer->get_infer_kind ())\n+\t\t    {\n+\t\t    case TyTy::InferType::InferTypeKind::GENERAL:\n+\t\t    case TyTy::InferType::InferTypeKind::FLOAT:\n+\t\t      return TypeCoercionRules::CoercionResult{\n+\t\t\t{}, to.get_ty ()->clone ()};\n+\n+\t\t    default:\n+\t\t      return TypeCoercionRules::CoercionResult::get_error ();\n+\t\t    }\n+\t\t}\n+\t\tbreak;\n+\n+\t      default:\n+\t\treturn TypeCoercionRules::CoercionResult::get_error ();\n+\t      }\n+\t    break;\n+\t  }\n+      }\n+      break;\n+\n+    case TyTy::TypeKind::BOOL:\n+      switch (to.get_ty ()->get_kind ())\n+\t{\n+\tcase TyTy::TypeKind::INFER:\n+\tcase TyTy::TypeKind::USIZE:\n+\tcase TyTy::TypeKind::ISIZE:\n+\tcase TyTy::TypeKind::UINT:\n+\tcase TyTy::TypeKind::INT:\n+\t  return TypeCoercionRules::CoercionResult{{}, to.get_ty ()->clone ()};\n+\n+\tdefault:\n+\t  return TypeCoercionRules::CoercionResult::get_error ();\n+\t}\n+      break;\n+\n+    case TyTy::TypeKind::CHAR:\n+    case TyTy::TypeKind::USIZE:\n+    case TyTy::TypeKind::ISIZE:\n+    case TyTy::TypeKind::UINT:\n+    case TyTy::TypeKind::INT:\n+      switch (to.get_ty ()->get_kind ())\n+\t{\n+\t  case TyTy::TypeKind::CHAR: {\n+\t    // only u8 and char\n+\t    bool was_uint = from.get_ty ()->get_kind () == TyTy::TypeKind::UINT;\n+\t    bool was_u8 = was_uint\n+\t\t\t  && (static_cast<TyTy::UintType *> (from.get_ty ())\n+\t\t\t\t->get_uint_kind ()\n+\t\t\t      == TyTy::UintType::UintKind::U8);\n+\t    if (was_u8)\n+\t      return TypeCoercionRules::CoercionResult{{},\n+\t\t\t\t\t\t       to.get_ty ()->clone ()};\n+\t  }\n+\t  break;\n+\n+\tcase TyTy::TypeKind::INFER:\n+\tcase TyTy::TypeKind::USIZE:\n+\tcase TyTy::TypeKind::ISIZE:\n+\tcase TyTy::TypeKind::UINT:\n+\tcase TyTy::TypeKind::INT:\n+\t  return TypeCoercionRules::CoercionResult{{}, to.get_ty ()->clone ()};\n+\n+\tdefault:\n+\t  return TypeCoercionRules::CoercionResult::get_error ();\n+\t}\n+      break;\n+\n+    case TyTy::TypeKind::FLOAT:\n+      switch (to.get_ty ()->get_kind ())\n+\t{\n+\tcase TyTy::TypeKind::FLOAT:\n+\t  return TypeCoercionRules::CoercionResult{{}, to.get_ty ()->clone ()};\n+\n+\t  case TyTy::TypeKind::INFER: {\n+\t    TyTy::InferType *to_infer\n+\t      = static_cast<TyTy::InferType *> (to.get_ty ());\n+\n+\t    switch (to_infer->get_infer_kind ())\n+\t      {\n+\t      case TyTy::InferType::InferTypeKind::GENERAL:\n+\t      case TyTy::InferType::InferTypeKind::FLOAT:\n+\t\treturn TypeCoercionRules::CoercionResult{\n+\t\t  {}, to.get_ty ()->clone ()};\n+\n+\t      default:\n+\t\treturn TypeCoercionRules::CoercionResult::get_error ();\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  return TypeCoercionRules::CoercionResult::get_error ();\n+\t}\n+      break;\n+\n+    case TyTy::TypeKind::REF:\n+    case TyTy::TypeKind::POINTER:\n+      switch (to.get_ty ()->get_kind ())\n+\t{\n+\tcase TyTy::TypeKind::REF:\n+\tcase TyTy::TypeKind::POINTER:\n+\t  return check_ptr_ptr_cast ();\n+\n+\t  // FIXME can you cast a pointer to a integral type?\n+\n+\tdefault:\n+\t  return TypeCoercionRules::CoercionResult::get_error ();\n+\t}\n+      break;\n+\n+    default:\n+      return TypeCoercionRules::CoercionResult::get_error ();\n+    }\n+\n+  return TypeCoercionRules::CoercionResult::get_error ();\n+}\n+\n+TypeCoercionRules::CoercionResult\n+TypeCastRules::check_ptr_ptr_cast ()\n+{\n+  rust_debug (\"check_ptr_ptr_cast from={%s} to={%s}\",\n+\t      from.get_ty ()->debug_str ().c_str (),\n+\t      to.get_ty ()->debug_str ().c_str ());\n+\n+  bool from_is_ref = from.get_ty ()->get_kind () == TyTy::TypeKind::REF;\n+  bool to_is_ref = to.get_ty ()->get_kind () == TyTy::TypeKind::REF;\n+  bool from_is_ptr = from.get_ty ()->get_kind () == TyTy::TypeKind::POINTER;\n+  bool to_is_ptr = to.get_ty ()->get_kind () == TyTy::TypeKind::POINTER;\n+\n+  if (from_is_ptr && to_is_ptr)\n+    {\n+      // mutability is ignored here as all pointer usage requires unsafe\n+      return TypeCoercionRules::CoercionResult{{}, to.get_ty ()->clone ()};\n+    }\n+  else if (from_is_ref && to_is_ref)\n+    {\n+      // mutability must be coercedable\n+      TyTy::ReferenceType &f\n+\t= static_cast<TyTy::ReferenceType &> (*from.get_ty ());\n+      TyTy::ReferenceType &t\n+\t= static_cast<TyTy::ReferenceType &> (*to.get_ty ());\n+\n+      if (TypeCoercionRules::coerceable_mutability (f.mutability (),\n+\t\t\t\t\t\t    t.mutability ()))\n+\t{\n+\t  return TypeCoercionRules::CoercionResult{{}, to.get_ty ()->clone ()};\n+\t}\n+    }\n+\n+  return TypeCoercionRules::CoercionResult::get_error ();\n+}\n+\n+void\n+TypeCastRules::emit_cast_error () const\n+{\n+  // error[E0604]\n+  RichLocation r (locus);\n+  r.add_range (from.get_locus ());\n+  r.add_range (to.get_locus ());\n+  rust_error_at (r, \"invalid cast %<%s%> to %<%s%>\",\n+\t\t from.get_ty ()->get_name ().c_str (),\n+\t\t to.get_ty ()->get_name ().c_str ());\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "e908f49b6563ad35da73c4389b51217d303bd860", "filename": "gcc/rust/typecheck/rust-casts.h", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a9255b1b6683bb060021c637997de396445049/gcc%2Frust%2Ftypecheck%2Frust-casts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a9255b1b6683bb060021c637997de396445049/gcc%2Frust%2Ftypecheck%2Frust-casts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-casts.h?ref=36a9255b1b6683bb060021c637997de396445049", "patch": "@@ -0,0 +1,53 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_CASTS\n+#define RUST_CASTS\n+\n+#include \"rust-tyty.h\"\n+#include \"rust-coercion.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeCastRules\n+{\n+public:\n+  static TypeCoercionRules::CoercionResult\n+  resolve (Location locus, TyTy::TyWithLocation from, TyTy::TyWithLocation to);\n+\n+protected:\n+  TypeCoercionRules::CoercionResult check ();\n+  TypeCoercionRules::CoercionResult cast_rules ();\n+  TypeCoercionRules::CoercionResult check_ptr_ptr_cast ();\n+\n+  void emit_cast_error () const;\n+\n+protected:\n+  TypeCastRules (Location locus, TyTy::TyWithLocation from,\n+\t\t TyTy::TyWithLocation to);\n+\n+  Location locus;\n+  TyTy::TyWithLocation from;\n+  TyTy::TyWithLocation to;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_CASTS"}, {"sha": "2ad2b8007ff5289fa8db409efbbd1ab184b59458", "filename": "gcc/rust/typecheck/rust-coercion.cc", "status": "modified", "additions": 54, "deletions": 35, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a9255b1b6683bb060021c637997de396445049/gcc%2Frust%2Ftypecheck%2Frust-coercion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a9255b1b6683bb060021c637997de396445049/gcc%2Frust%2Ftypecheck%2Frust-coercion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-coercion.cc?ref=36a9255b1b6683bb060021c637997de396445049", "patch": "@@ -21,24 +21,33 @@\n namespace Rust {\n namespace Resolver {\n \n-AutoderefTypeCoercion::CoercionResult\n-AutoderefTypeCoercion::Coerce (TyTy::BaseType *receiver,\n-\t\t\t       TyTy::BaseType *expected, Location locus)\n+TypeCoercionRules::CoercionResult\n+TypeCoercionRules::Coerce (TyTy::BaseType *receiver, TyTy::BaseType *expected,\n+\t\t\t   Location locus)\n {\n-  AutoderefTypeCoercion resolver (expected, locus);\n+  TypeCoercionRules resolver (expected, locus, true);\n   bool ok = resolver.do_coercion (receiver);\n   return ok ? resolver.try_result : CoercionResult::get_error ();\n }\n \n-AutoderefTypeCoercion::AutoderefTypeCoercion (TyTy::BaseType *expected,\n-\t\t\t\t\t      Location locus)\n+TypeCoercionRules::CoercionResult\n+TypeCoercionRules::TryCoerce (TyTy::BaseType *receiver,\n+\t\t\t      TyTy::BaseType *expected, Location locus)\n+{\n+  TypeCoercionRules resolver (expected, locus, false);\n+  bool ok = resolver.do_coercion (receiver);\n+  return ok ? resolver.try_result : CoercionResult::get_error ();\n+}\n+\n+TypeCoercionRules::TypeCoercionRules (TyTy::BaseType *expected, Location locus,\n+\t\t\t\t      bool emit_errors)\n   : AutoderefCycle (false), mappings (Analysis::Mappings::get ()),\n     context (TypeCheckContext::get ()), expected (expected), locus (locus),\n-    try_result (CoercionResult::get_error ())\n+    try_result (CoercionResult::get_error ()), emit_errors (emit_errors)\n {}\n \n bool\n-AutoderefTypeCoercion::do_coercion (TyTy::BaseType *receiver)\n+TypeCoercionRules::do_coercion (TyTy::BaseType *receiver)\n {\n   // FIXME this is not finished and might be super simplified\n   // see:\n@@ -87,10 +96,10 @@ AutoderefTypeCoercion::do_coercion (TyTy::BaseType *receiver)\n   return !try_result.is_error ();\n }\n \n-AutoderefTypeCoercion::CoercionResult\n-AutoderefTypeCoercion::coerce_unsafe_ptr (TyTy::BaseType *receiver,\n-\t\t\t\t\t  TyTy::PointerType *expected,\n-\t\t\t\t\t  Mutability to_mutbl)\n+TypeCoercionRules::CoercionResult\n+TypeCoercionRules::coerce_unsafe_ptr (TyTy::BaseType *receiver,\n+\t\t\t\t      TyTy::PointerType *expected,\n+\t\t\t\t      Mutability to_mutbl)\n {\n   rust_debug (\"coerce_unsafe_ptr(a={%s}, b={%s})\",\n \t      receiver->debug_str ().c_str (), expected->debug_str ().c_str ());\n@@ -115,8 +124,10 @@ AutoderefTypeCoercion::coerce_unsafe_ptr (TyTy::BaseType *receiver,\n       break;\n \n       default: {\n-\tTyTy::BaseType *result = receiver->unify (expected);\n-\treturn CoercionResult{{}, result};\n+\tif (receiver->can_eq (expected, false))\n+\t  return CoercionResult{{}, expected->clone ()};\n+\n+\treturn CoercionResult::get_error ();\n       }\n     }\n \n@@ -125,22 +136,25 @@ AutoderefTypeCoercion::coerce_unsafe_ptr (TyTy::BaseType *receiver,\n       Location lhs = mappings->lookup_location (receiver->get_ref ());\n       Location rhs = mappings->lookup_location (expected->get_ref ());\n       mismatched_mutability_error (locus, lhs, rhs);\n-      return AutoderefTypeCoercion::CoercionResult::get_error ();\n+      return TypeCoercionRules::CoercionResult::get_error ();\n     }\n \n   TyTy::PointerType *result\n     = new TyTy::PointerType (receiver->get_ref (),\n \t\t\t     TyTy::TyVar (element->get_ref ()), to_mutbl);\n+  if (!result->can_eq (expected, false))\n+    return CoercionResult::get_error ();\n+\n   return CoercionResult{{}, result};\n }\n \n /// Reborrows `&mut A` to `&mut B` and `&(mut) A` to `&B`.\n /// To match `A` with `B`, autoderef will be performed,\n /// calling `deref`/`deref_mut` where necessary.\n-AutoderefTypeCoercion::CoercionResult\n-AutoderefTypeCoercion::coerce_borrowed_pointer (TyTy::BaseType *receiver,\n-\t\t\t\t\t\tTyTy::ReferenceType *expected,\n-\t\t\t\t\t\tMutability to_mutbl)\n+TypeCoercionRules::CoercionResult\n+TypeCoercionRules::coerce_borrowed_pointer (TyTy::BaseType *receiver,\n+\t\t\t\t\t    TyTy::ReferenceType *expected,\n+\t\t\t\t\t    Mutability to_mutbl)\n {\n   rust_debug (\"coerce_borrowed_pointer(a={%s}, b={%s})\",\n \t      receiver->debug_str ().c_str (), expected->debug_str ().c_str ());\n@@ -166,7 +180,7 @@ AutoderefTypeCoercion::coerce_borrowed_pointer (TyTy::BaseType *receiver,\n       Location lhs = mappings->lookup_location (receiver->get_ref ());\n       Location rhs = mappings->lookup_location (expected->get_ref ());\n       mismatched_mutability_error (locus, lhs, rhs);\n-      return AutoderefTypeCoercion::CoercionResult::get_error ();\n+      return TypeCoercionRules::CoercionResult::get_error ();\n     }\n \n   AutoderefCycle::cycle (receiver);\n@@ -176,10 +190,9 @@ AutoderefTypeCoercion::coerce_borrowed_pointer (TyTy::BaseType *receiver,\n // &[T; n] or &mut [T; n] -> &[T]\n // or &mut [T; n] -> &mut [T]\n // or &Concrete -> &Trait, etc.\n-AutoderefTypeCoercion::CoercionResult\n-AutoderefTypeCoercion::coerce_unsized (TyTy::BaseType *source,\n-\t\t\t\t       TyTy::BaseType *target,\n-\t\t\t\t       bool &unsafe_error)\n+TypeCoercionRules::CoercionResult\n+TypeCoercionRules::coerce_unsized (TyTy::BaseType *source,\n+\t\t\t\t   TyTy::BaseType *target, bool &unsafe_error)\n {\n   rust_debug (\"coerce_unsized(source={%s}, target={%s})\",\n \t      source->debug_str ().c_str (), target->debug_str ().c_str ());\n@@ -207,7 +220,7 @@ AutoderefTypeCoercion::coerce_unsized (TyTy::BaseType *source,\n \t  Location lhs = mappings->lookup_location (source->get_ref ());\n \t  Location rhs = mappings->lookup_location (target->get_ref ());\n \t  mismatched_mutability_error (locus, lhs, rhs);\n-\t  return AutoderefTypeCoercion::CoercionResult::get_error ();\n+\t  return TypeCoercionRules::CoercionResult::get_error ();\n \t}\n \n       ty_a = source_ref->get_base ();\n@@ -232,7 +245,7 @@ AutoderefTypeCoercion::coerce_unsized (TyTy::BaseType *source,\n \t  Location lhs = mappings->lookup_location (source->get_ref ());\n \t  Location rhs = mappings->lookup_location (target->get_ref ());\n \t  mismatched_mutability_error (locus, lhs, rhs);\n-\t  return AutoderefTypeCoercion::CoercionResult::get_error ();\n+\t  return TypeCoercionRules::CoercionResult::get_error ();\n \t}\n \n       ty_a = source_ref->get_base ();\n@@ -262,7 +275,7 @@ AutoderefTypeCoercion::coerce_unsized (TyTy::BaseType *source,\n       if (!bounds_compatible)\n \t{\n \t  unsafe_error = true;\n-\t  return AutoderefTypeCoercion::CoercionResult::get_error ();\n+\t  return TypeCoercionRules::CoercionResult::get_error ();\n \t}\n \n       // return the unsize coercion\n@@ -291,11 +304,11 @@ AutoderefTypeCoercion::coerce_unsized (TyTy::BaseType *source,\n     }\n \n   adjustments.clear ();\n-  return AutoderefTypeCoercion::CoercionResult::get_error ();\n+  return TypeCoercionRules::CoercionResult::get_error ();\n }\n \n bool\n-AutoderefTypeCoercion::select (const TyTy::BaseType &autoderefed)\n+TypeCoercionRules::select (const TyTy::BaseType &autoderefed)\n {\n   if (autoderefed.can_eq (expected, false))\n     {\n@@ -308,26 +321,32 @@ AutoderefTypeCoercion::select (const TyTy::BaseType &autoderefed)\n /// Coercing a mutable reference to an immutable works, while\n /// coercing `&T` to `&mut T` should be forbidden.\n bool\n-AutoderefTypeCoercion::coerceable_mutability (Mutability from_mutbl,\n-\t\t\t\t\t      Mutability to_mutbl)\n+TypeCoercionRules::coerceable_mutability (Mutability from_mutbl,\n+\t\t\t\t\t  Mutability to_mutbl)\n {\n   return to_mutbl == Mutability::Imm || (from_mutbl == to_mutbl);\n }\n \n void\n-AutoderefTypeCoercion::mismatched_mutability_error (Location expr_locus,\n-\t\t\t\t\t\t    Location lhs, Location rhs)\n+TypeCoercionRules::mismatched_mutability_error (Location expr_locus,\n+\t\t\t\t\t\tLocation lhs, Location rhs)\n {\n+  if (!emit_errors)\n+    return;\n+\n   RichLocation r (expr_locus);\n   r.add_range (lhs);\n   r.add_range (rhs);\n   rust_error_at (r, \"mismatched mutability\");\n }\n \n void\n-AutoderefTypeCoercion::object_unsafe_error (Location expr_locus, Location lhs,\n-\t\t\t\t\t    Location rhs)\n+TypeCoercionRules::object_unsafe_error (Location expr_locus, Location lhs,\n+\t\t\t\t\tLocation rhs)\n {\n+  if (!emit_errors)\n+    return;\n+\n   RichLocation r (expr_locus);\n   r.add_range (lhs);\n   r.add_range (rhs);"}, {"sha": "da28c7c5e1b2f3f38966017b3e8d3dfed7442ea0", "filename": "gcc/rust/typecheck/rust-coercion.h", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a9255b1b6683bb060021c637997de396445049/gcc%2Frust%2Ftypecheck%2Frust-coercion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a9255b1b6683bb060021c637997de396445049/gcc%2Frust%2Ftypecheck%2Frust-coercion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-coercion.h?ref=36a9255b1b6683bb060021c637997de396445049", "patch": "@@ -25,7 +25,7 @@\n namespace Rust {\n namespace Resolver {\n \n-class AutoderefTypeCoercion : protected AutoderefCycle\n+class TypeCoercionRules : protected AutoderefCycle\n {\n public:\n   struct CoercionResult\n@@ -44,6 +44,9 @@ class AutoderefTypeCoercion : protected AutoderefCycle\n   static CoercionResult Coerce (TyTy::BaseType *receiver,\n \t\t\t\tTyTy::BaseType *expected, Location locus);\n \n+  static CoercionResult TryCoerce (TyTy::BaseType *receiver,\n+\t\t\t\t   TyTy::BaseType *expected, Location locus);\n+\n   CoercionResult coerce_unsafe_ptr (TyTy::BaseType *receiver,\n \t\t\t\t    TyTy::PointerType *expected,\n \t\t\t\t    Mutability mutability);\n@@ -58,13 +61,13 @@ class AutoderefTypeCoercion : protected AutoderefCycle\n   static bool coerceable_mutability (Mutability from_mutbl,\n \t\t\t\t     Mutability to_mutbl);\n \n-  static void mismatched_mutability_error (Location expr_locus, Location lhs,\n-\t\t\t\t\t   Location rhs);\n-  static void object_unsafe_error (Location expr_locus, Location lhs,\n-\t\t\t\t   Location rhs);\n+  void mismatched_mutability_error (Location expr_locus, Location lhs,\n+\t\t\t\t    Location rhs);\n+  void object_unsafe_error (Location expr_locus, Location lhs, Location rhs);\n \n protected:\n-  AutoderefTypeCoercion (TyTy::BaseType *expected, Location locus);\n+  TypeCoercionRules (TyTy::BaseType *expected, Location locus,\n+\t\t     bool emit_errors);\n \n   bool select (const TyTy::BaseType &autoderefed) override;\n \n@@ -81,6 +84,7 @@ class AutoderefTypeCoercion : protected AutoderefCycle\n \n   // mutable fields\n   CoercionResult try_result;\n+  bool emit_errors;\n };\n \n } // namespace Resolver"}, {"sha": "ac5c3b974759d57628585b181f2e423212734788", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.cc", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a9255b1b6683bb060021c637997de396445049/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a9255b1b6683bb060021c637997de396445049/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc?ref=36a9255b1b6683bb060021c637997de396445049", "patch": "@@ -20,6 +20,7 @@\n #include \"rust-hir-type-check-type.h\"\n #include \"rust-hir-type-check-expr.h\"\n #include \"rust-coercion.h\"\n+#include \"rust-casts.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -343,7 +344,7 @@ TypeCheckBase::coercion_site (HirId id, TyTy::BaseType *expected,\n     return expr;\n \n   // can we autoderef it?\n-  auto result = AutoderefTypeCoercion::Coerce (expr, expected, locus);\n+  auto result = TypeCoercionRules::Coerce (expr, expected, locus);\n \n   // the result needs to be unified\n   TyTy::BaseType *receiver = expr;\n@@ -359,6 +360,36 @@ TypeCheckBase::coercion_site (HirId id, TyTy::BaseType *expected,\n   return coerced;\n }\n \n+TyTy::BaseType *\n+TypeCheckBase::cast_site (HirId id, TyTy::TyWithLocation from,\n+\t\t\t  TyTy::TyWithLocation to, Location cast_locus)\n+{\n+  rust_debug (\"cast_site id={%u} from={%s} to={%s}\", id,\n+\t      from.get_ty ()->debug_str ().c_str (),\n+\t      to.get_ty ()->debug_str ().c_str ());\n+\n+  auto context = TypeCheckContext::get ();\n+  if (from.get_ty ()->get_kind () == TyTy::TypeKind::ERROR\n+      || to.get_ty ()->get_kind () == TyTy::TypeKind::ERROR)\n+    return to.get_ty ();\n+\n+  // do the cast\n+  auto result = TypeCastRules::resolve (cast_locus, from, to);\n+\n+  // we assume error has already been emitted\n+  if (result.is_error ())\n+    return to.get_ty ();\n+\n+  // the result needs to be unified\n+  TyTy::BaseType *casted_result = result.tyty;\n+  rust_debug (\"cast_default_unify(a={%s}, b={%s})\",\n+\t      casted_result->debug_str ().c_str (),\n+\t      to.get_ty ()->debug_str ().c_str ());\n+  TyTy::BaseType *casted = to.get_ty ()->unify (casted_result);\n+  context->insert_cast_autoderef_mappings (id, std::move (result.adjustments));\n+  return casted;\n+}\n+\n void\n TypeCheckBase::resolve_generic_params (\n   const std::vector<std::unique_ptr<HIR::GenericParam>> &generic_params,"}, {"sha": "aa42d9d6dfd9feadc6b05b62d436f872c7d68b3f", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a9255b1b6683bb060021c637997de396445049/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a9255b1b6683bb060021c637997de396445049/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h?ref=36a9255b1b6683bb060021c637997de396445049", "patch": "@@ -36,7 +36,12 @@ class TypeCheckBase\n   virtual ~TypeCheckBase () {}\n \n   static TyTy::BaseType *coercion_site (HirId id, TyTy::BaseType *lhs,\n-\t\t\t\t\tTyTy::BaseType *rhs, Location locus);\n+\t\t\t\t\tTyTy::BaseType *rhs,\n+\t\t\t\t\tLocation coercion_locus);\n+\n+  static TyTy::BaseType *cast_site (HirId id, TyTy::TyWithLocation from,\n+\t\t\t\t    TyTy::TyWithLocation to,\n+\t\t\t\t    Location cast_locus);\n \n protected:\n   TypeCheckBase ()"}, {"sha": "4371f5a59a5dd9a7d052424d08b9147b75ef8c06", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.cc", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a9255b1b6683bb060021c637997de396445049/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a9255b1b6683bb060021c637997de396445049/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc?ref=36a9255b1b6683bb060021c637997de396445049", "patch": "@@ -296,8 +296,12 @@ TypeCheckExpr::visit (HIR::ArithmeticOrLogicalExpr &expr)\n   switch (expr.get_expr_type ())\n     {\n     case ArithmeticOrLogicalOperator::LEFT_SHIFT:\n-    case ArithmeticOrLogicalOperator::RIGHT_SHIFT:\n-      infered = rhs->cast (lhs);\n+      case ArithmeticOrLogicalOperator::RIGHT_SHIFT: {\n+\tTyTy::TyWithLocation from (rhs, expr.get_rhs ()->get_locus ());\n+\tTyTy::TyWithLocation to (lhs, expr.get_lhs ()->get_locus ());\n+\tinfered = cast_site (expr.get_mappings ().get_hirid (), from, to,\n+\t\t\t     expr.get_locus ());\n+      }\n       break;\n \n     default:\n@@ -1264,7 +1268,12 @@ TypeCheckExpr::visit (HIR::TypeCastExpr &expr)\n   TyTy::BaseType *tyty_to_convert_to\n     = TypeCheckType::Resolve (expr.get_type_to_convert_to ().get ());\n \n-  infered = expr_to_convert->cast (tyty_to_convert_to);\n+  TyTy::TyWithLocation from (expr_to_convert,\n+\t\t\t     expr.get_casted_expr ()->get_locus ());\n+  TyTy::TyWithLocation to (tyty_to_convert_to,\n+\t\t\t   expr.get_type_to_convert_to ()->get_locus ());\n+  infered = cast_site (expr.get_mappings ().get_hirid (), from, to,\n+\t\t       expr.get_locus ());\n }\n \n void"}, {"sha": "21694dd302bf1fc1e5a8305ea331ac1c5fdda6c7", "filename": "gcc/rust/typecheck/rust-hir-type-check.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a9255b1b6683bb060021c637997de396445049/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a9255b1b6683bb060021c637997de396445049/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h?ref=36a9255b1b6683bb060021c637997de396445049", "patch": "@@ -282,6 +282,25 @@ class TypeCheckContext\n     return true;\n   }\n \n+  void insert_cast_autoderef_mappings (HirId id,\n+\t\t\t\t       std::vector<Adjustment> &&adjustments)\n+  {\n+    rust_assert (cast_autoderef_mappings.find (id)\n+\t\t == cast_autoderef_mappings.end ());\n+    cast_autoderef_mappings.emplace (id, std::move (adjustments));\n+  }\n+\n+  bool lookup_cast_autoderef_mappings (HirId id,\n+\t\t\t\t       std::vector<Adjustment> **adjustments)\n+  {\n+    auto it = cast_autoderef_mappings.find (id);\n+    if (it == cast_autoderef_mappings.end ())\n+      return false;\n+\n+    *adjustments = &it->second;\n+    return true;\n+  }\n+\n   void insert_variant_definition (HirId id, HirId variant)\n   {\n     auto it = variants.find (id);\n@@ -339,6 +358,7 @@ class TypeCheckContext\n \n   // adjustment mappings\n   std::map<HirId, std::vector<Adjustment>> autoderef_mappings;\n+  std::map<HirId, std::vector<Adjustment>> cast_autoderef_mappings;\n \n   // operator overloads\n   std::map<HirId, TyTy::FnType *> operator_overloads;"}, {"sha": "5ca68d07aa2d8f215f1a9e448598e39a7b589425", "filename": "gcc/rust/typecheck/rust-tyty-cast.h", "status": "removed", "additions": 0, "deletions": 1425, "changes": 1425, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f4ec11e8c2399ca20f80b4006e294794f9b2e0f/gcc%2Frust%2Ftypecheck%2Frust-tyty-cast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f4ec11e8c2399ca20f80b4006e294794f9b2e0f/gcc%2Frust%2Ftypecheck%2Frust-tyty-cast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cast.h?ref=0f4ec11e8c2399ca20f80b4006e294794f9b2e0f", "patch": "@@ -1,1425 +0,0 @@\n-// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-// This file is part of GCC.\n-\n-// GCC is free software; you can redistribute it and/or modify it under\n-// the terms of the GNU General Public License as published by the Free\n-// Software Foundation; either version 3, or (at your option) any later\n-// version.\n-\n-// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-// for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GCC; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-#ifndef RUST_TYTY_CAST_RULES\n-#define RUST_TYTY_CAST_RULES\n-\n-#include \"rust-diagnostics.h\"\n-#include \"rust-tyty.h\"\n-#include \"rust-tyty-visitor.h\"\n-#include \"rust-hir-map.h\"\n-#include \"rust-hir-type-check.h\"\n-\n-extern ::Backend *\n-rust_get_backend ();\n-\n-namespace Rust {\n-namespace TyTy {\n-\n-class BaseCastRules : public TyVisitor\n-{\n-public:\n-  virtual ~BaseCastRules () {}\n-\n-  virtual BaseType *cast (BaseType *other)\n-  {\n-    if (other->get_kind () == TypeKind::PARAM)\n-      {\n-\tParamType *p = static_cast<ParamType *> (other);\n-\tif (p->can_resolve ())\n-\t  {\n-\t    other = p->resolve ();\n-\t  }\n-      }\n-\n-    other->accept_vis (*this);\n-    if (resolved->get_kind () == TyTy::TypeKind::ERROR)\n-      return resolved;\n-\n-    resolved->append_reference (get_base ()->get_ref ());\n-    resolved->append_reference (other->get_ref ());\n-    for (auto ref : get_base ()->get_combined_refs ())\n-      resolved->append_reference (ref);\n-    for (auto ref : other->get_combined_refs ())\n-      resolved->append_reference (ref);\n-\n-    bool result_resolved = resolved->get_kind () != TyTy::TypeKind::INFER;\n-    bool result_is_infer_var = resolved->get_kind () == TyTy::TypeKind::INFER;\n-    bool results_is_non_general_infer_var\n-      = (result_is_infer_var\n-\t && (static_cast<InferType *> (resolved))->get_infer_kind ()\n-\t      != TyTy::InferType::GENERAL);\n-    if (result_resolved || results_is_non_general_infer_var)\n-      {\n-\tfor (auto &ref : resolved->get_combined_refs ())\n-\t  {\n-\t    TyTy::BaseType *ref_tyty = nullptr;\n-\t    bool ok = context->lookup_type (ref, &ref_tyty);\n-\t    if (!ok)\n-\t      continue;\n-\n-\t    // if any of the types are inference variables lets fix them\n-\t    if (ref_tyty->get_kind () == TyTy::TypeKind::INFER)\n-\t      {\n-\t\tcontext->insert_type (\n-\t\t  Analysis::NodeMapping (mappings->get_current_crate (),\n-\t\t\t\t\t UNKNOWN_NODEID, ref,\n-\t\t\t\t\t UNKNOWN_LOCAL_DEFID),\n-\t\t  resolved->clone ());\n-\t      }\n-\t  }\n-      }\n-    return resolved;\n-  }\n-\n-  virtual void visit (TupleType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (ADTType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (InferType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (FnType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (FnPtr &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (ArrayType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (SliceType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (BoolType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (IntType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (UintType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (USizeType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (ISizeType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (FloatType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (ErrorType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (CharType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (ReferenceType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (PointerType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (ParamType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (StrType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (NeverType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (PlaceholderType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (ProjectionType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (DynamicObjectType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-  virtual void visit (ClosureType &type) override\n-  {\n-    Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n-    RichLocation r (ref_locus);\n-    r.add_range (base_locus);\n-    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n-\t\t   get_base ()->as_string ().c_str (),\n-\t\t   type.as_string ().c_str ());\n-  }\n-\n-protected:\n-  BaseCastRules (BaseType *base)\n-    : mappings (Analysis::Mappings::get ()),\n-      context (Resolver::TypeCheckContext::get ()),\n-      resolved (new ErrorType (base->get_ref (), base->get_ref ()))\n-  {}\n-\n-  Analysis::Mappings *mappings;\n-  Resolver::TypeCheckContext *context;\n-\n-  /* Temporary storage for the result of a unification.\n-     We could return the result directly instead of storing it in the rule\n-     object, but that involves modifying the visitor pattern to accommodate\n-     the return value, which is too complex. */\n-  BaseType *resolved;\n-\n-private:\n-  /* Returns a pointer to the ty that created this rule. */\n-  virtual BaseType *get_base () = 0;\n-};\n-\n-class InferCastRules : public BaseCastRules\n-{\n-  using Rust::TyTy::BaseCastRules::visit;\n-\n-public:\n-  InferCastRules (InferType *base) : BaseCastRules (base), base (base) {}\n-\n-  void visit (BoolType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseCastRules::visit (type);\n-  }\n-\n-  void visit (IntType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n-\t|| (base->get_infer_kind ()\n-\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseCastRules::visit (type);\n-  }\n-\n-  void visit (UintType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n-\t|| (base->get_infer_kind ()\n-\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseCastRules::visit (type);\n-  }\n-\n-  void visit (USizeType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n-\t|| (base->get_infer_kind ()\n-\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseCastRules::visit (type);\n-  }\n-\n-  void visit (ISizeType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n-\t|| (base->get_infer_kind ()\n-\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseCastRules::visit (type);\n-  }\n-\n-  void visit (FloatType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::INTEGRAL)\n-\t|| (base->get_infer_kind () == TyTy::InferType::InferTypeKind::FLOAT);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseCastRules::visit (type);\n-  }\n-\n-  void visit (ArrayType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseCastRules::visit (type);\n-  }\n-\n-  void visit (SliceType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseCastRules::visit (type);\n-  }\n-\n-  void visit (ADTType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseCastRules::visit (type);\n-  }\n-\n-  void visit (TupleType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseCastRules::visit (type);\n-  }\n-\n-  void visit (InferType &type) override\n-  {\n-    switch (base->get_infer_kind ())\n-      {\n-      case InferType::InferTypeKind::GENERAL:\n-\tresolved = type.clone ();\n-\treturn;\n-\n-\tcase InferType::InferTypeKind::INTEGRAL: {\n-\t  if (type.get_infer_kind () == InferType::InferTypeKind::INTEGRAL)\n-\t    {\n-\t      resolved = type.clone ();\n-\t      return;\n-\t    }\n-\t  else if (type.get_infer_kind () == InferType::InferTypeKind::GENERAL)\n-\t    {\n-\t      resolved = base->clone ();\n-\t      return;\n-\t    }\n-\t}\n-\tbreak;\n-\n-\tcase InferType::InferTypeKind::FLOAT: {\n-\t  if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n-\t    {\n-\t      resolved = type.clone ();\n-\t      return;\n-\t    }\n-\t  else if (type.get_infer_kind () == InferType::InferTypeKind::GENERAL)\n-\t    {\n-\t      resolved = base->clone ();\n-\t      return;\n-\t    }\n-\t}\n-\tbreak;\n-      }\n-\n-    BaseCastRules::visit (type);\n-  }\n-\n-  void visit (CharType &type) override\n-  {\n-    {\n-      bool is_valid\n-\t= (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-      if (is_valid)\n-\t{\n-\t  resolved = type.clone ();\n-\t  return;\n-\t}\n-\n-      BaseCastRules::visit (type);\n-    }\n-  }\n-\n-  void visit (ReferenceType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseCastRules::visit (type);\n-  }\n-\n-  void visit (PointerType &type) override\n-  {\n-    bool is_general_infer_var\n-      = base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL;\n-    bool is_integral_infer_var\n-      = base->get_infer_kind () == TyTy::InferType::InferTypeKind::INTEGRAL;\n-    bool is_valid = is_general_infer_var || is_integral_infer_var;\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseCastRules::visit (type);\n-  }\n-\n-  void visit (ParamType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseCastRules::visit (type);\n-  }\n-\n-  void visit (DynamicObjectType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseCastRules::visit (type);\n-  }\n-\n-  void visit (ClosureType &type) override\n-  {\n-    bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n-    if (is_valid)\n-      {\n-\tresolved = type.clone ();\n-\treturn;\n-      }\n-\n-    BaseCastRules::visit (type);\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  InferType *base;\n-};\n-\n-class FnCastRules : public BaseCastRules\n-{\n-  using Rust::TyTy::BaseCastRules::visit;\n-\n-public:\n-  FnCastRules (FnType *base) : BaseCastRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseCastRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (FnType &type) override\n-  {\n-    if (base->num_params () != type.num_params ())\n-      {\n-\tBaseCastRules::visit (type);\n-\treturn;\n-      }\n-\n-    for (size_t i = 0; i < base->num_params (); i++)\n-      {\n-\tauto a = base->param_at (i).second;\n-\tauto b = type.param_at (i).second;\n-\n-\tauto unified_param = a->unify (b);\n-\tif (unified_param == nullptr)\n-\t  {\n-\t    BaseCastRules::visit (type);\n-\t    return;\n-\t  }\n-      }\n-\n-    auto unified_return\n-      = base->get_return_type ()->unify (type.get_return_type ());\n-    if (unified_return == nullptr)\n-      {\n-\tBaseCastRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  FnType *base;\n-};\n-\n-class FnptrCastRules : public BaseCastRules\n-{\n-  using Rust::TyTy::BaseCastRules::visit;\n-\n-public:\n-  FnptrCastRules (FnPtr *base) : BaseCastRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseCastRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (FnPtr &type) override\n-  {\n-    auto this_ret_type = base->get_return_type ();\n-    auto other_ret_type = type.get_return_type ();\n-    auto unified_result = this_ret_type->unify (other_ret_type);\n-    if (unified_result == nullptr\n-\t|| unified_result->get_kind () == TypeKind::ERROR)\n-      {\n-\tBaseCastRules::visit (type);\n-\treturn;\n-      }\n-\n-    if (base->num_params () != type.num_params ())\n-      {\n-\tBaseCastRules::visit (type);\n-\treturn;\n-      }\n-\n-    for (size_t i = 0; i < base->num_params (); i++)\n-      {\n-\tauto this_param = base->param_at (i);\n-\tauto other_param = type.param_at (i);\n-\tauto unified_param = this_param->unify (other_param);\n-\tif (unified_param == nullptr\n-\t    || unified_param->get_kind () == TypeKind::ERROR)\n-\t  {\n-\t    BaseCastRules::visit (type);\n-\t    return;\n-\t  }\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (FnType &type) override\n-  {\n-    auto this_ret_type = base->get_return_type ();\n-    auto other_ret_type = type.get_return_type ();\n-    auto unified_result = this_ret_type->unify (other_ret_type);\n-    if (unified_result == nullptr\n-\t|| unified_result->get_kind () == TypeKind::ERROR)\n-      {\n-\tBaseCastRules::visit (type);\n-\treturn;\n-      }\n-\n-    if (base->num_params () != type.num_params ())\n-      {\n-\tBaseCastRules::visit (type);\n-\treturn;\n-      }\n-\n-    for (size_t i = 0; i < base->num_params (); i++)\n-      {\n-\tauto this_param = base->param_at (i);\n-\tauto other_param = type.param_at (i).second;\n-\tauto unified_param = this_param->unify (other_param);\n-\tif (unified_param == nullptr\n-\t    || unified_param->get_kind () == TypeKind::ERROR)\n-\t  {\n-\t    BaseCastRules::visit (type);\n-\t    return;\n-\t  }\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  FnPtr *base;\n-};\n-\n-class ClosureCastRules : public BaseCastRules\n-{\n-  using Rust::TyTy::BaseCastRules::visit;\n-\n-public:\n-  ClosureCastRules (ClosureType *base) : BaseCastRules (base), base (base) {}\n-\n-  // TODO\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  ClosureType *base;\n-};\n-\n-class ArrayCastRules : public BaseCastRules\n-{\n-  using Rust::TyTy::BaseCastRules::visit;\n-\n-public:\n-  ArrayCastRules (ArrayType *base) : BaseCastRules (base), base (base) {}\n-\n-  void visit (ArrayType &type) override\n-  {\n-    // check base type\n-    auto base_resolved\n-      = base->get_element_type ()->unify (type.get_element_type ());\n-    if (base_resolved == nullptr)\n-      {\n-\tBaseCastRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved\n-      = new ArrayType (type.get_ref (), type.get_ty_ref (),\n-\t\t       type.get_ident ().locus, type.get_capacity_expr (),\n-\t\t       TyVar (base_resolved->get_ref ()));\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  ArrayType *base;\n-};\n-\n-class SliceCastRules : public BaseCastRules\n-{\n-  using Rust::TyTy::BaseCastRules::visit;\n-\n-public:\n-  SliceCastRules (SliceType *base) : BaseCastRules (base), base (base) {}\n-\n-  void visit (SliceType &type) override\n-  {\n-    // check base type\n-    auto base_resolved\n-      = base->get_element_type ()->unify (type.get_element_type ());\n-    if (base_resolved == nullptr)\n-      {\n-\tBaseCastRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = new SliceType (type.get_ref (), type.get_ty_ref (),\n-\t\t\t      type.get_ident ().locus,\n-\t\t\t      TyVar (base_resolved->get_ref ()));\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  SliceType *base;\n-};\n-\n-class BoolCastRules : public BaseCastRules\n-{\n-  using Rust::TyTy::BaseCastRules::visit;\n-\n-public:\n-  BoolCastRules (BoolType *base) : BaseCastRules (base), base (base) {}\n-\n-  void visit (BoolType &type) override\n-  {\n-    resolved = new BoolType (type.get_ref (), type.get_ty_ref ());\n-  }\n-\n-  void visit (InferType &type) override\n-  {\n-    switch (type.get_infer_kind ())\n-      {\n-      case InferType::InferTypeKind::GENERAL:\n-\tresolved = base->clone ();\n-\tbreak;\n-\n-      default:\n-\tBaseCastRules::visit (type);\n-\tbreak;\n-      }\n-  }\n-\n-  /* bools can be cast to any integer type (but not floats or chars).  */\n-  void visit (IntType &type) override { resolved = type.clone (); }\n-  void visit (UintType &type) override { resolved = type.clone (); }\n-  void visit (USizeType &type) override { resolved = type.clone (); }\n-  void visit (ISizeType &type) override { resolved = type.clone (); }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  BoolType *base;\n-};\n-\n-class IntCastRules : public BaseCastRules\n-{\n-  using Rust::TyTy::BaseCastRules::visit;\n-\n-public:\n-  IntCastRules (IntType *base) : BaseCastRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    // cant assign a float inference variable\n-    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n-      {\n-\tBaseCastRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (IntType &type) override { resolved = type.clone (); }\n-\n-  void visit (UintType &type) override { resolved = type.clone (); }\n-\n-  void visit (FloatType &type) override { resolved = type.clone (); }\n-\n-  void visit (USizeType &type) override { resolved = type.clone (); }\n-\n-  void visit (ISizeType &type) override { resolved = type.clone (); }\n-\n-  void visit (PointerType &type) override { resolved = type.clone (); }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  IntType *base;\n-};\n-\n-class UintCastRules : public BaseCastRules\n-{\n-  using Rust::TyTy::BaseCastRules::visit;\n-\n-public:\n-  UintCastRules (UintType *base) : BaseCastRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    // cant assign a float inference variable\n-    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n-      {\n-\tBaseCastRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (IntType &type) override { resolved = type.clone (); }\n-\n-  void visit (UintType &type) override { resolved = type.clone (); }\n-\n-  void visit (FloatType &type) override { resolved = type.clone (); }\n-\n-  void visit (USizeType &type) override { resolved = type.clone (); }\n-\n-  void visit (ISizeType &type) override { resolved = type.clone (); }\n-\n-  void visit (PointerType &type) override { resolved = type.clone (); }\n-\n-  void visit (CharType &type) override\n-  {\n-    // error[E0604]: only `u8` can be cast as `char`, not `i32`\n-    if (base->get_uint_kind () != UintType::UintKind::U8)\n-      {\n-\tBaseCastRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = type.clone ();\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  UintType *base;\n-};\n-\n-class FloatCastRules : public BaseCastRules\n-{\n-  using Rust::TyTy::BaseCastRules::visit;\n-\n-public:\n-  FloatCastRules (FloatType *base) : BaseCastRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () == InferType::InferTypeKind::INTEGRAL)\n-      {\n-\tBaseCastRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (IntType &type) override { resolved = type.clone (); }\n-\n-  void visit (UintType &type) override { resolved = type.clone (); }\n-\n-  void visit (FloatType &type) override { resolved = type.clone (); }\n-\n-  void visit (USizeType &type) override { resolved = type.clone (); }\n-\n-  void visit (ISizeType &type) override { resolved = type.clone (); }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  FloatType *base;\n-};\n-\n-class ADTCastRules : public BaseCastRules\n-{\n-  using Rust::TyTy::BaseCastRules::visit;\n-\n-public:\n-  ADTCastRules (ADTType *base) : BaseCastRules (base), base (base) {}\n-\n-  void visit (ADTType &type) override\n-  {\n-    if (base->get_adt_kind () != type.get_adt_kind ())\n-      {\n-\tBaseCastRules::visit (type);\n-\treturn;\n-      }\n-\n-    if (base->get_identifier ().compare (type.get_identifier ()) != 0)\n-      {\n-\tBaseCastRules::visit (type);\n-\treturn;\n-      }\n-\n-    if (base->number_of_variants () != type.number_of_variants ())\n-      {\n-\tBaseCastRules::visit (type);\n-\treturn;\n-      }\n-\n-    for (size_t i = 0; i < type.number_of_variants (); ++i)\n-      {\n-\tTyTy::VariantDef *a = base->get_variants ().at (i);\n-\tTyTy::VariantDef *b = type.get_variants ().at (i);\n-\n-\tif (a->num_fields () != b->num_fields ())\n-\t  {\n-\t    BaseCastRules::visit (type);\n-\t    return;\n-\t  }\n-\n-\tfor (size_t j = 0; j < a->num_fields (); j++)\n-\t  {\n-\t    TyTy::StructFieldType *base_field = a->get_field_at_index (i);\n-\t    TyTy::StructFieldType *other_field = b->get_field_at_index (i);\n-\n-\t    TyTy::BaseType *this_field_ty = base_field->get_field_type ();\n-\t    TyTy::BaseType *other_field_ty = other_field->get_field_type ();\n-\n-\t    BaseType *unified_ty = this_field_ty->unify (other_field_ty);\n-\t    if (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n-\t      return;\n-\t  }\n-      }\n-\n-    resolved = type.clone ();\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  ADTType *base;\n-};\n-\n-class TupleCastRules : public BaseCastRules\n-{\n-  using Rust::TyTy::BaseCastRules::visit;\n-\n-public:\n-  TupleCastRules (TupleType *base) : BaseCastRules (base), base (base) {}\n-\n-  void visit (TupleType &type) override\n-  {\n-    if (base->num_fields () != type.num_fields ())\n-      {\n-\tBaseCastRules::visit (type);\n-\treturn;\n-      }\n-\n-    std::vector<TyVar> fields;\n-    for (size_t i = 0; i < base->num_fields (); i++)\n-      {\n-\tBaseType *bo = base->get_field (i);\n-\tBaseType *fo = type.get_field (i);\n-\n-\tBaseType *unified_ty = bo->unify (fo);\n-\tif (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n-\t  return;\n-\n-\tfields.push_back (TyVar (unified_ty->get_ref ()));\n-      }\n-\n-    resolved = new TyTy::TupleType (type.get_ref (), type.get_ty_ref (),\n-\t\t\t\t    type.get_ident ().locus, fields);\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  TupleType *base;\n-};\n-\n-class USizeCastRules : public BaseCastRules\n-{\n-  using Rust::TyTy::BaseCastRules::visit;\n-\n-public:\n-  USizeCastRules (USizeType *base) : BaseCastRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    // cant assign a float inference variable\n-    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n-      {\n-\tBaseCastRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (IntType &type) override { resolved = type.clone (); }\n-\n-  void visit (UintType &type) override { resolved = type.clone (); }\n-\n-  void visit (FloatType &type) override { resolved = type.clone (); }\n-\n-  void visit (USizeType &type) override { resolved = type.clone (); }\n-\n-  void visit (ISizeType &type) override { resolved = type.clone (); }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  USizeType *base;\n-};\n-\n-class ISizeCastRules : public BaseCastRules\n-{\n-  using Rust::TyTy::BaseCastRules::visit;\n-\n-public:\n-  ISizeCastRules (ISizeType *base) : BaseCastRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    // cant assign a float inference variable\n-    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n-      {\n-\tBaseCastRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (IntType &type) override { resolved = type.clone (); }\n-\n-  void visit (UintType &type) override { resolved = type.clone (); }\n-\n-  void visit (FloatType &type) override { resolved = type.clone (); }\n-\n-  void visit (USizeType &type) override { resolved = type.clone (); }\n-\n-  void visit (ISizeType &type) override { resolved = type.clone (); }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  ISizeType *base;\n-};\n-\n-class CharCastRules : public BaseCastRules\n-{\n-  using Rust::TyTy::BaseCastRules::visit;\n-\n-public:\n-  CharCastRules (CharType *base) : BaseCastRules (base), base (base) {}\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseCastRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-    resolved->set_ref (type.get_ref ());\n-  }\n-\n-  void visit (CharType &type) override { resolved = type.clone (); }\n-\n-  /* chars can be cast to any integer type (but not floats or bools).  */\n-  void visit (IntType &type) override { resolved = type.clone (); }\n-  void visit (UintType &type) override { resolved = type.clone (); }\n-  void visit (USizeType &type) override { resolved = type.clone (); }\n-  void visit (ISizeType &type) override { resolved = type.clone (); }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  CharType *base;\n-};\n-\n-class ReferenceCastRules : public BaseCastRules\n-{\n-  using Rust::TyTy::BaseCastRules::visit;\n-\n-public:\n-  ReferenceCastRules (ReferenceType *base) : BaseCastRules (base), base (base)\n-  {}\n-\n-  void visit (ReferenceType &type) override { resolved = type.clone (); }\n-\n-  void visit (PointerType &type) override\n-  {\n-    auto base_type = base->get_base ();\n-    auto other_base_type = type.get_base ();\n-\n-    TyTy::BaseType *base_resolved = base_type->unify (other_base_type);\n-    if (base_resolved == nullptr\n-\t|| base_resolved->get_kind () == TypeKind::ERROR)\n-      {\n-\tBaseCastRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = type.clone ();\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  ReferenceType *base;\n-};\n-\n-class PointerCastRules : public BaseCastRules\n-{\n-  using Rust::TyTy::BaseCastRules::visit;\n-\n-public:\n-  PointerCastRules (PointerType *base) : BaseCastRules (base), base (base) {}\n-\n-  void visit (ReferenceType &type) override\n-  {\n-    auto base_type = base->get_base ();\n-    auto other_base_type = type.get_base ();\n-\n-    TyTy::BaseType *base_resolved = base_type->unify (other_base_type);\n-    if (base_resolved == nullptr\n-\t|| base_resolved->get_kind () == TypeKind::ERROR)\n-      {\n-\tBaseCastRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = type.clone ();\n-  }\n-\n-  void visit (PointerType &type) override { resolved = type.clone (); }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  PointerType *base;\n-};\n-\n-class ParamCastRules : public BaseCastRules\n-{\n-  using Rust::TyTy::BaseCastRules::visit;\n-\n-public:\n-  ParamCastRules (ParamType *base) : BaseCastRules (base), base (base) {}\n-\n-  // param types are a placeholder we shouldn't have cases where we unify\n-  // against it. eg: struct foo<T> { a: T }; When we invoke it we can do either:\n-  //\n-  // foo<i32>{ a: 123 }.\n-  // Then this enforces the i32 type to be referenced on the\n-  // field via an hirid.\n-  //\n-  // rust also allows for a = foo{a:123}; Where we can use an Inference Variable\n-  // to handle the typing of the struct\n-  BaseType *cast (BaseType *other) override final\n-  {\n-    if (base->get_ref () == base->get_ty_ref ())\n-      return BaseCastRules::cast (other);\n-\n-    auto context = Resolver::TypeCheckContext::get ();\n-    BaseType *lookup = nullptr;\n-    bool ok = context->lookup_type (base->get_ty_ref (), &lookup);\n-    rust_assert (ok);\n-\n-    return lookup->unify (other);\n-  }\n-\n-  void visit (ParamType &type) override\n-  {\n-    if (base->get_symbol ().compare (type.get_symbol ()) != 0)\n-      {\n-\tBaseCastRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = type.clone ();\n-  }\n-\n-  void visit (InferType &type) override\n-  {\n-    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n-      {\n-\tBaseCastRules::visit (type);\n-\treturn;\n-      }\n-\n-    resolved = base->clone ();\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  ParamType *base;\n-};\n-\n-class StrCastRules : public BaseCastRules\n-{\n-  // FIXME we will need a enum for the StrType like ByteBuf etc..\n-  using Rust::TyTy::BaseCastRules::visit;\n-\n-public:\n-  StrCastRules (StrType *base) : BaseCastRules (base), base (base) {}\n-\n-  void visit (StrType &type) override { resolved = type.clone (); }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  StrType *base;\n-};\n-\n-class NeverCastRules : public BaseCastRules\n-{\n-  using Rust::TyTy::BaseCastRules::visit;\n-\n-public:\n-  NeverCastRules (NeverType *base) : BaseCastRules (base), base (base) {}\n-\n-  virtual void visit (NeverType &type) override { resolved = type.clone (); }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  NeverType *base;\n-};\n-\n-class PlaceholderCastRules : public BaseCastRules\n-{\n-  using Rust::TyTy::BaseCastRules::visit;\n-\n-public:\n-  PlaceholderCastRules (PlaceholderType *base)\n-    : BaseCastRules (base), base (base)\n-  {}\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  PlaceholderType *base;\n-};\n-\n-class DynamicCastRules : public BaseCastRules\n-{\n-  using Rust::TyTy::BaseCastRules::visit;\n-\n-public:\n-  DynamicCastRules (DynamicObjectType *base) : BaseCastRules (base), base (base)\n-  {}\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  DynamicObjectType *base;\n-};\n-\n-} // namespace TyTy\n-} // namespace Rust\n-\n-#endif // RUST_TYTY_CAST_RULES"}, {"sha": "3c2c6786940186ca16dc173a3b593a0c43688d68", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 10, "deletions": 168, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a9255b1b6683bb060021c637997de396445049/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a9255b1b6683bb060021c637997de396445049/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=36a9255b1b6683bb060021c637997de396445049", "patch": "@@ -23,7 +23,6 @@\n #include \"rust-hir-type-check-type.h\"\n #include \"rust-tyty-rules.h\"\n #include \"rust-tyty-cmp.h\"\n-#include \"rust-tyty-cast.h\"\n #include \"rust-hir-map.h\"\n #include \"rust-substitution-mapper.h\"\n #include \"rust-hir-trait-ref.h\"\n@@ -376,6 +375,16 @@ TyVar::monomorphized_clone () const\n   return TyVar (c->get_ref ());\n }\n \n+TyWithLocation::TyWithLocation (BaseType *ty, Location locus)\n+  : ty (ty), locus (locus)\n+{}\n+\n+TyWithLocation::TyWithLocation (BaseType *ty) : ty (ty)\n+{\n+  auto mappings = Analysis::Mappings::get ();\n+  locus = mappings->lookup_location (ty->get_ref ());\n+}\n+\n void\n InferType::accept_vis (TyVisitor &vis)\n {\n@@ -417,13 +426,6 @@ InferType::can_eq (const BaseType *other, bool emit_errors) const\n   return r.can_eq (other);\n }\n \n-BaseType *\n-InferType::cast (BaseType *other)\n-{\n-  InferCastRules r (this);\n-  return r.cast (other);\n-}\n-\n BaseType *\n InferType::clone () const\n {\n@@ -518,12 +520,6 @@ ErrorType::can_eq (const BaseType *other, bool emit_errors) const\n   return get_kind () == other->get_kind ();\n }\n \n-BaseType *\n-ErrorType::cast (BaseType *other)\n-{\n-  return this;\n-}\n-\n BaseType *\n ErrorType::clone () const\n {\n@@ -984,13 +980,6 @@ ADTType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-ADTType::cast (BaseType *other)\n-{\n-  ADTCastRules r (this);\n-  return r.cast (other);\n-}\n-\n bool\n ADTType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1191,13 +1180,6 @@ TupleType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-TupleType::cast (BaseType *other)\n-{\n-  TupleCastRules r (this);\n-  return r.cast (other);\n-}\n-\n bool\n TupleType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1305,13 +1287,6 @@ FnType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-FnType::cast (BaseType *other)\n-{\n-  FnCastRules r (this);\n-  return r.cast (other);\n-}\n-\n bool\n FnType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1543,13 +1518,6 @@ FnPtr::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-FnPtr::cast (BaseType *other)\n-{\n-  FnptrCastRules r (this);\n-  return r.cast (other);\n-}\n-\n bool\n FnPtr::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1636,14 +1604,6 @@ ClosureType::can_eq (const BaseType *other, bool emit_errors) const\n   return r.can_eq (other);\n }\n \n-BaseType *\n-ClosureType::cast (BaseType *other)\n-{\n-  // FIXME\n-  gcc_unreachable ();\n-  return nullptr;\n-}\n-\n bool\n ClosureType::is_equal (const BaseType &other) const\n {\n@@ -1696,13 +1656,6 @@ ArrayType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-ArrayType::cast (BaseType *other)\n-{\n-  ArrayCastRules r (this);\n-  return r.cast (other);\n-}\n-\n bool\n ArrayType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1786,13 +1739,6 @@ SliceType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-SliceType::cast (BaseType *other)\n-{\n-  SliceCastRules r (this);\n-  return r.cast (other);\n-}\n-\n bool\n SliceType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1876,13 +1822,6 @@ BoolType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-BoolType::cast (BaseType *other)\n-{\n-  BoolCastRules r (this);\n-  return r.cast (other);\n-}\n-\n bool\n BoolType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1941,13 +1880,6 @@ IntType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-IntType::cast (BaseType *other)\n-{\n-  IntCastRules r (this);\n-  return r.cast (other);\n-}\n-\n bool\n IntType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2017,13 +1949,6 @@ UintType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-UintType::cast (BaseType *other)\n-{\n-  UintCastRules r (this);\n-  return r.cast (other);\n-}\n-\n bool\n UintType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2087,13 +2012,6 @@ FloatType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-FloatType::cast (BaseType *other)\n-{\n-  FloatCastRules r (this);\n-  return r.cast (other);\n-}\n-\n bool\n FloatType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2149,13 +2067,6 @@ USizeType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-USizeType::cast (BaseType *other)\n-{\n-  USizeCastRules r (this);\n-  return r.cast (other);\n-}\n-\n bool\n USizeType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2200,13 +2111,6 @@ ISizeType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-ISizeType::cast (BaseType *other)\n-{\n-  ISizeCastRules r (this);\n-  return r.cast (other);\n-}\n-\n bool\n ISizeType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2251,13 +2155,6 @@ CharType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-CharType::cast (BaseType *other)\n-{\n-  CharCastRules r (this);\n-  return r.cast (other);\n-}\n-\n bool\n CharType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2303,13 +2200,6 @@ ReferenceType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-ReferenceType::cast (BaseType *other)\n-{\n-  ReferenceCastRules r (this);\n-  return r.cast (other);\n-}\n-\n bool\n ReferenceType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2393,13 +2283,6 @@ PointerType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-PointerType::cast (BaseType *other)\n-{\n-  PointerCastRules r (this);\n-  return r.cast (other);\n-}\n-\n bool\n PointerType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2497,13 +2380,6 @@ ParamType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-ParamType::cast (BaseType *other)\n-{\n-  ParamCastRules r (this);\n-  return r.cast (other);\n-}\n-\n bool\n ParamType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2636,13 +2512,6 @@ StrType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-StrType::cast (BaseType *other)\n-{\n-  StrCastRules r (this);\n-  return r.cast (other);\n-}\n-\n bool\n StrType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2681,13 +2550,6 @@ NeverType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-NeverType::cast (BaseType *other)\n-{\n-  NeverCastRules r (this);\n-  return r.cast (other);\n-}\n-\n bool\n NeverType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2735,13 +2597,6 @@ PlaceholderType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n-BaseType *\n-PlaceholderType::cast (BaseType *other)\n-{\n-  PlaceholderCastRules r (this);\n-  return r.cast (other);\n-}\n-\n bool\n PlaceholderType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2839,12 +2694,6 @@ ProjectionType::unify (BaseType *other)\n   return base->unify (other);\n }\n \n-BaseType *\n-ProjectionType::cast (BaseType *other)\n-{\n-  return base->cast (other);\n-}\n-\n bool\n ProjectionType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -2969,13 +2818,6 @@ DynamicObjectType::can_eq (const BaseType *other, bool emit_errors) const\n   return r.can_eq (other);\n }\n \n-BaseType *\n-DynamicObjectType::cast (BaseType *other)\n-{\n-  DynamicCastRules r (this);\n-  return r.cast (other);\n-}\n-\n BaseType *\n DynamicObjectType::clone () const\n {"}, {"sha": "c47921d44d71a9f63bbe7ba90f4cf6d1b95fd70e", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 14, "deletions": 50, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a9255b1b6683bb060021c637997de396445049/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a9255b1b6683bb060021c637997de396445049/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=36a9255b1b6683bb060021c637997de396445049", "patch": "@@ -180,9 +180,6 @@ class BaseType : public TypeBoundsMappings\n   // checks\n   virtual bool can_eq (const BaseType *other, bool emit_errors) const = 0;\n \n-  // this is the cast interface for TypeCastExpr\n-  virtual BaseType *cast (BaseType *other) = 0;\n-\n   // Check value equality between two ty. Type inference rules are ignored. Two\n   //   ty are considered equal if they're of the same kind, and\n   //     1. (For ADTs, arrays, tuples, refs) have the same underlying ty\n@@ -314,6 +311,20 @@ class TyVar\n   HirId ref;\n };\n \n+class TyWithLocation\n+{\n+public:\n+  TyWithLocation (BaseType *ty, Location locus);\n+  TyWithLocation (BaseType *ty);\n+\n+  BaseType *get_ty () const { return ty; }\n+  Location get_locus () const { return locus; }\n+\n+private:\n+  BaseType *ty;\n+  Location locus;\n+};\n+\n class InferType : public BaseType\n {\n public:\n@@ -347,8 +358,6 @@ class InferType : public BaseType\n \n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n-  BaseType *cast (BaseType *other) override;\n-\n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n \n@@ -387,8 +396,6 @@ class ErrorType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n-  BaseType *cast (BaseType *other) override;\n-\n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n \n@@ -431,8 +438,6 @@ class ParamType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n-  BaseType *cast (BaseType *other) override;\n-\n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n \n@@ -531,8 +536,6 @@ class TupleType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n-  BaseType *cast (BaseType *other) override;\n-\n   bool is_equal (const BaseType &other) const override;\n \n   size_t num_fields () const { return fields.size (); }\n@@ -1360,8 +1363,6 @@ class ADTType : public BaseType, public SubstitutionRef\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n-  BaseType *cast (BaseType *other) override;\n-\n   bool is_equal (const BaseType &other) const override;\n \n   std::string get_identifier () const { return identifier; }\n@@ -1497,8 +1498,6 @@ class FnType : public BaseType, public SubstitutionRef\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n-  BaseType *cast (BaseType *other) override;\n-\n   bool is_equal (const BaseType &other) const override;\n \n   size_t num_params () const { return params.size (); }\n@@ -1619,8 +1618,6 @@ class FnPtr : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n-  BaseType *cast (BaseType *other) override;\n-\n   bool is_equal (const BaseType &other) const override;\n \n   BaseType *clone () const final override;\n@@ -1693,8 +1690,6 @@ class ClosureType : public BaseType, public SubstitutionRef\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n-  BaseType *cast (BaseType *other) override;\n-\n   bool is_equal (const BaseType &other) const override;\n \n   BaseType *clone () const final override;\n@@ -1759,8 +1754,6 @@ class ArrayType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n-  BaseType *cast (BaseType *other) override;\n-\n   bool is_equal (const BaseType &other) const override;\n \n   BaseType *get_element_type () const;\n@@ -1809,8 +1802,6 @@ class SliceType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n-  BaseType *cast (BaseType *other) override;\n-\n   bool is_equal (const BaseType &other) const override;\n \n   BaseType *get_element_type () const;\n@@ -1856,8 +1847,6 @@ class BoolType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n-  BaseType *cast (BaseType *other) override;\n-\n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n   bool is_concrete () const override final { return true; }\n@@ -1902,8 +1891,6 @@ class IntType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n-  BaseType *cast (BaseType *other) override;\n-\n   IntKind get_int_kind () const { return int_kind; }\n \n   BaseType *clone () const final override;\n@@ -1955,8 +1942,6 @@ class UintType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n-  BaseType *cast (BaseType *other) override;\n-\n   UintKind get_uint_kind () const { return uint_kind; }\n \n   BaseType *clone () const final override;\n@@ -2006,8 +1991,6 @@ class FloatType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n-  BaseType *cast (BaseType *other) override;\n-\n   FloatKind get_float_kind () const { return float_kind; }\n \n   BaseType *clone () const final override;\n@@ -2047,8 +2030,6 @@ class USizeType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n-  BaseType *cast (BaseType *other) override;\n-\n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n   bool is_concrete () const override final { return true; }\n@@ -2081,8 +2062,6 @@ class ISizeType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n-  BaseType *cast (BaseType *other) override;\n-\n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n   bool is_concrete () const override final { return true; }\n@@ -2115,8 +2094,6 @@ class CharType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n-  BaseType *cast (BaseType *other) override;\n-\n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n   bool is_concrete () const override final { return true; }\n@@ -2149,8 +2126,6 @@ class StrType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n-  BaseType *cast (BaseType *other) override;\n-\n   bool is_equal (const BaseType &other) const override;\n \n   BaseType *clone () const final override;\n@@ -2194,8 +2169,6 @@ class ReferenceType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n-  BaseType *cast (BaseType *other) override;\n-\n   bool is_equal (const BaseType &other) const override;\n \n   BaseType *clone () const final override;\n@@ -2282,8 +2255,6 @@ class PointerType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n-  BaseType *cast (BaseType *other) override;\n-\n   bool is_equal (const BaseType &other) const override;\n \n   BaseType *clone () const final override;\n@@ -2371,8 +2342,6 @@ class NeverType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n-  BaseType *cast (BaseType *other) override;\n-\n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n \n@@ -2413,8 +2382,6 @@ class PlaceholderType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n-  BaseType *cast (BaseType *other) override;\n-\n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n \n@@ -2489,8 +2456,6 @@ class ProjectionType : public BaseType, public SubstitutionRef\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n-  BaseType *cast (BaseType *other) override;\n-\n   BaseType *clone () const final override;\n   BaseType *monomorphized_clone () const final override;\n \n@@ -2547,7 +2512,6 @@ class DynamicObjectType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n-  BaseType *cast (BaseType *other) override;\n   bool is_equal (const BaseType &other) const override;\n \n   BaseType *clone () const final override;"}, {"sha": "9f08b2ae98acd43b84c7697f7206eca1e5acbee6", "filename": "gcc/testsuite/rust/execute/torture/issue-1496.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a9255b1b6683bb060021c637997de396445049/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-1496.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a9255b1b6683bb060021c637997de396445049/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-1496.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-1496.rs?ref=36a9255b1b6683bb060021c637997de396445049", "patch": "@@ -0,0 +1,75 @@\n+/* { dg-output \"foo_deref\\nimm_deref\\n123\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+#[lang = \"deref\"]\n+pub trait Deref {\n+    type Target;\n+\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+impl<T> Deref for &T {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        unsafe {\n+            let a = \"imm_deref\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+\n+        *self\n+    }\n+}\n+\n+impl<T> Deref for &mut T {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        unsafe {\n+            let a = \"mut_deref\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+\n+        *self\n+    }\n+}\n+\n+struct Foo<T>(T);\n+impl<T> Deref for Foo<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &Self::Target {\n+        unsafe {\n+            let a = \"foo_deref\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+\n+        &self.0\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let foo = Foo(123);\n+    let bar = &foo as &i32;\n+\n+    unsafe {\n+        let a = \"%i\\n\\0\";\n+        let b = a as *const str;\n+        let c = b as *const i8;\n+\n+        printf(c, *bar);\n+    }\n+\n+    0\n+}"}]}