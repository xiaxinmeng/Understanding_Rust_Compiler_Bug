{"sha": "ebea352be590cd4d63acd2e68a9c5b3153473021", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJlYTM1MmJlNTkwY2Q0ZDYzYWNkMmU2OGE5YzViMzE1MzQ3MzAyMQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-08-20T19:33:41Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-08-20T19:33:41Z"}, "message": "(not_qsort): New function.\n\nFrom-SVN: r1914", "tree": {"sha": "08b7c4aa48a62972504b65540ae0d7a869e81449", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08b7c4aa48a62972504b65540ae0d7a869e81449"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebea352be590cd4d63acd2e68a9c5b3153473021", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebea352be590cd4d63acd2e68a9c5b3153473021", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebea352be590cd4d63acd2e68a9c5b3153473021", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebea352be590cd4d63acd2e68a9c5b3153473021/comments", "author": null, "committer": null, "parents": [{"sha": "5ac3f0f448487f214429f35fb6880991214fbfe2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ac3f0f448487f214429f35fb6880991214fbfe2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ac3f0f448487f214429f35fb6880991214fbfe2"}], "stats": {"total": 89, "additions": 89, "deletions": 0}, "files": [{"sha": "14f98e423742833a04f08c24d32d5b02506ca22e", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebea352be590cd4d63acd2e68a9c5b3153473021/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebea352be590cd4d63acd2e68a9c5b3153473021/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=ebea352be590cd4d63acd2e68a9c5b3153473021", "patch": "@@ -577,3 +577,92 @@ vax_rtx_cost (x)\n     }\n   return c;\n }\n+\f\n+#ifdef VMS\n+/* Additional support code for VMS. */\n+\n+#ifdef QSORT_WORKAROUND\n+  /*\n+\tDo not use VAXCRTL's qsort() due to a severe bug:  once you've\n+\tsorted something which has a size that's an exact multiple of 4\n+\tand is longword aligned, you cannot safely sort anything which\n+\tis either not a multiple of 4 in size or not longword aligned.\n+\tA static \"move-by-longword\" optimization flag inside qsort() is\n+\tnever reset.  This is known of affect VMS V4.6 through VMS V5.5-1.\n+\n+\tIn this work-around an insertion sort is used for simplicity.\n+\tThe qsort code from glibc should probably be used instead.\n+   */\n+void\n+not_qsort (array, count, size, compare)\n+     void *array;\n+     unsigned count, size;\n+     int (*compare)();\n+{\n+\n+  if (size == sizeof (short))\n+    {\n+      register int i;\n+      register short *next, *prev;\n+      short tmp, *base = array;\n+\n+      for (next = base, i = count - 1; i > 0; i--)\n+\t{\n+\t  prev = next++;\n+\t  if ((*compare)(next, prev) < 0)\n+\t    {\n+\t      tmp = *next;\n+\t      do  *(prev + 1) = *prev;\n+\t\twhile (--prev >= base ? (*compare)(&tmp, prev) < 0 : 0);\n+\t      *(prev + 1) = tmp;\n+\t    }\n+\t}\n+    }\n+  else if (size == sizeof (long))\n+    {\n+      register int i;\n+      register long *next, *prev;\n+      long tmp, *base = array;\n+\n+      for (next = base, i = count - 1; i > 0; i--)\n+\t{\n+\t  prev = next++;\n+\t  if ((*compare)(next, prev) < 0)\n+\t    {\n+\t      tmp = *next;\n+\t      do  *(prev + 1) = *prev;\n+\t\twhile (--prev >= base ? (*compare)(&tmp, prev) < 0 : 0);\n+\t      *(prev + 1) = tmp;\n+\t    }\n+\t}\n+    }\n+  else  /* arbitrary size */\n+    {\n+#ifdef USE_C_ALLOCA\n+      extern void *alloca ();\n+#endif\n+      register int i;\n+      register char *next, *prev, *tmp = alloca (size), *base = array;\n+\n+      for (next = base, i = count - 1; i > 0; i--)\n+\t{   /* count-1 forward iterations */\n+\t  prev = next,  next += size;\t\t/* increment front pointer */\n+\t  if ((*compare)(next, prev) < 0)\n+\t    {\t/* found element out of order; move others up then re-insert */\n+\t      memcpy (tmp, next, size);\t\t/* save smaller element */\n+\t      do { memcpy (prev + size, prev, size); /* move larger elem. up */\n+\t\t   prev -= size;\t\t/* decrement back pointer */\n+\t\t } while (prev >= base ? (*compare)(tmp, prev) < 0 : 0);\n+\t      memcpy (prev + size, tmp, size);\t/* restore small element */\n+\t    }\n+\t}\n+#ifdef USE_C_ALLOCA\n+      alloca (0);\n+#endif\n+    }\n+\n+  return;\n+}\n+#endif /* QSORT_WORKAROUND */\n+\n+#endif /* VMS */"}]}