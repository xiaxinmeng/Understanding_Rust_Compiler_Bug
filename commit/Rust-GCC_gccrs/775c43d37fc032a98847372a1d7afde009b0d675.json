{"sha": "775c43d37fc032a98847372a1d7afde009b0d675", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc1YzQzZDM3ZmMwMzJhOTg4NDczNzJhMWQ3YWZkZTAwOWIwZDY3NQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-08-25T19:06:00Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-08-25T19:06:00Z"}, "message": "config/s390: Use rtx_insn and rtx_code_label\n\ngcc/\n\t* config/s390/s390-protos.h (s390_match_ccmode): Strengthen param\n\t1 from rtx to rtx_insn *.\n\t(s390_emit_jump): Likewise for return type.\n\t(s390_emit_call): Likewise.\n\t(s390_load_got): Likewise.\n\n\t* config/s390/s390.c (last_scheduled_insn): Likewise for this\n\tvariable.\n\t(s390_match_ccmode): Likewise for param \"insn\".\n\t(s390_emit_jump): Likewise for return type.\n\t(s390_split_branches): Likewise for local \"label\".\n\t(struct constant): Strengthen field \"label\" from rtx to\n\trtx_code_label *.\n\t(struct constant_pool): Likewise for field \"label\".  Strengthen\n\tfields \"first_insn\", \"pool_insn\", \"emit_pool_after\" from rtx to\n\trtx_insn *.\n\t(s390_alloc_pool): Replace NULL_RTX with NULL when dealing with\n\tinsns.\n\t(s390_start_pool): Strengthen param \"insn\" from rtx to rtx_insn *.\n\t(s390_end_pool): Likewise.\n\t(s390_dump_pool): Likewise for local \"insn\".\n\t(s390_mainpool_start): Likewise.\n\t(s390_chunkify_start): Likewise.\n\t(s390_chunkify_start): Replace NULL_RTX with NULL when dealing\n\twith insns.  Strengthen locals \"label\", \"jump\", \"barrier\", \"next\",\n\t\"prev\", \"vec_insn\", \"insn\" from rtx to rtx_insn *.\n\t(s390_chunkify_finish): Strengthen local \"insn\" from rtx to\n\trtx_insn *.\n\t(s390_chunkify_cancel): Likewise for locals \"insn\", \"barrier\",\n\t\"jump\", \"label\", \"next_insn\".\n\t(s390_regs_ever_clobbered): Likewise for local \"cur_insn\".\n\t(s390_optimize_nonescaping_tx): Likewise for locals \"insn\",\n\t\"tbegin_insn\".\n\t(s390_load_got): Likewise for return type and local \"insns\".\n\t(s390_save_gprs_to_fprs): Likewise for local \"insn\".\n\t(s390_restore_gprs_from_fprs): Likewise.\n\t(pass_s390_early_mach::execute): Likewise.\n\t(s390_emit_prologue): Likewise for local \"insns\".\n\t(s390_expand_tbegin): Strengthen local \"leave_label\" from rtx to\n\trtx_code_label *.\n\t(s390_emit_call): Strengthen return type and local \"insn\" from\n\trtx to rtx_insn *.\n\t(s390_emit_tpf_eh_return): Likewise for local \"insn\".\n\t(s390_optimize_prologue): Likewise for locals \"insn\", \"new_insn\",\n\t\"next_insn\", introducing locals \"s_pat\", \"rpat\" to allow this.\n\t(s390_fix_long_loop_prediction): Likewise for param \"insn\" and\n\tlocal \"cur_insn\".\n\t(s390_non_addr_reg_read_p): Likewise for param \"insn\".\n\t(find_cond_jump): Likewise for return type and param \"insn\".\n\t(s390_swap_cmp): Likewise for param \"insn\".\n\t(s390_z10_optimize_cmp): Likewise for param \"insn\" and locals\n\t\"prev_insn\", \"next_insn\".\n\t(s390_reorg): Likewise for locals \"insn\", \"target\".\n\t(s390_z10_prevent_earlyload_conflicts): Likewise for local \"insn\".\n\t(s390_sched_variable_issue): For now, rename param \"insn\" to\n\t\"uncast_insn\", introducing a checked cast.\n\t(s390_sched_init): Replace NULL_RTX with NULL when dealing with\n\tinsn.\n\t(s390_loop_unroll_adjust): Strengthen local \"insn\" from rtx to\n\trtx_insn *.  Use for_each_rtx_in_insn rather than for_each_rtx.\n\nFrom-SVN: r214456", "tree": {"sha": "0071340a96a6d9a7e748ff4749704f4f45172e5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0071340a96a6d9a7e748ff4749704f4f45172e5a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/775c43d37fc032a98847372a1d7afde009b0d675", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/775c43d37fc032a98847372a1d7afde009b0d675", "html_url": "https://github.com/Rust-GCC/gccrs/commit/775c43d37fc032a98847372a1d7afde009b0d675", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/775c43d37fc032a98847372a1d7afde009b0d675/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3df4ecc207bec6cb1d570790b5325b9aa2d5ee30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3df4ecc207bec6cb1d570790b5325b9aa2d5ee30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3df4ecc207bec6cb1d570790b5325b9aa2d5ee30"}], "stats": {"total": 203, "additions": 135, "deletions": 68}, "files": [{"sha": "a9d70245e4baa5f0a0a92f7b3f85df04e9169f2c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/775c43d37fc032a98847372a1d7afde009b0d675/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/775c43d37fc032a98847372a1d7afde009b0d675/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=775c43d37fc032a98847372a1d7afde009b0d675", "patch": "@@ -1,3 +1,66 @@\n+2014-08-25  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* config/s390/s390-protos.h (s390_match_ccmode): Strengthen param\n+\t1 from rtx to rtx_insn *.\n+\t(s390_emit_jump): Likewise for return type.\n+\t(s390_emit_call): Likewise.\n+\t(s390_load_got): Likewise.\n+\n+\t* config/s390/s390.c (last_scheduled_insn): Likewise for this\n+\tvariable.\n+\t(s390_match_ccmode): Likewise for param \"insn\".\n+\t(s390_emit_jump): Likewise for return type.\n+\t(s390_split_branches): Likewise for local \"label\".\n+\t(struct constant): Strengthen field \"label\" from rtx to\n+\trtx_code_label *.\n+\t(struct constant_pool): Likewise for field \"label\".  Strengthen\n+\tfields \"first_insn\", \"pool_insn\", \"emit_pool_after\" from rtx to\n+\trtx_insn *.\n+\t(s390_alloc_pool): Replace NULL_RTX with NULL when dealing with\n+\tinsns.\n+\t(s390_start_pool): Strengthen param \"insn\" from rtx to rtx_insn *.\n+\t(s390_end_pool): Likewise.\n+\t(s390_dump_pool): Likewise for local \"insn\".\n+\t(s390_mainpool_start): Likewise.\n+\t(s390_chunkify_start): Likewise.\n+\t(s390_chunkify_start): Replace NULL_RTX with NULL when dealing\n+\twith insns.  Strengthen locals \"label\", \"jump\", \"barrier\", \"next\",\n+\t\"prev\", \"vec_insn\", \"insn\" from rtx to rtx_insn *.\n+\t(s390_chunkify_finish): Strengthen local \"insn\" from rtx to\n+\trtx_insn *.\n+\t(s390_chunkify_cancel): Likewise for locals \"insn\", \"barrier\",\n+\t\"jump\", \"label\", \"next_insn\".\n+\t(s390_regs_ever_clobbered): Likewise for local \"cur_insn\".\n+\t(s390_optimize_nonescaping_tx): Likewise for locals \"insn\",\n+\t\"tbegin_insn\".\n+\t(s390_load_got): Likewise for return type and local \"insns\".\n+\t(s390_save_gprs_to_fprs): Likewise for local \"insn\".\n+\t(s390_restore_gprs_from_fprs): Likewise.\n+\t(pass_s390_early_mach::execute): Likewise.\n+\t(s390_emit_prologue): Likewise for local \"insns\".\n+\t(s390_expand_tbegin): Strengthen local \"leave_label\" from rtx to\n+\trtx_code_label *.\n+\t(s390_emit_call): Strengthen return type and local \"insn\" from\n+\trtx to rtx_insn *.\n+\t(s390_emit_tpf_eh_return): Likewise for local \"insn\".\n+\t(s390_optimize_prologue): Likewise for locals \"insn\", \"new_insn\",\n+\t\"next_insn\", introducing locals \"s_pat\", \"rpat\" to allow this.\n+\t(s390_fix_long_loop_prediction): Likewise for param \"insn\" and\n+\tlocal \"cur_insn\".\n+\t(s390_non_addr_reg_read_p): Likewise for param \"insn\".\n+\t(find_cond_jump): Likewise for return type and param \"insn\".\n+\t(s390_swap_cmp): Likewise for param \"insn\".\n+\t(s390_z10_optimize_cmp): Likewise for param \"insn\" and locals\n+\t\"prev_insn\", \"next_insn\".\n+\t(s390_reorg): Likewise for locals \"insn\", \"target\".\n+\t(s390_z10_prevent_earlyload_conflicts): Likewise for local \"insn\".\n+\t(s390_sched_variable_issue): For now, rename param \"insn\" to\n+\t\"uncast_insn\", introducing a checked cast.\n+\t(s390_sched_init): Replace NULL_RTX with NULL when dealing with\n+\tinsn.\n+\t(s390_loop_unroll_adjust): Strengthen local \"insn\" from rtx to\n+\trtx_insn *.  Use for_each_rtx_in_insn rather than for_each_rtx.\n+\n 2014-08-25  David Malcolm  <dmalcolm@redhat.com>\n \n \t* config/rx/rx-protos.h (rx_adjust_insn_length): Strengthen first"}, {"sha": "dca26d89caba6b8bb5d51a0b667329fb012e9587", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/775c43d37fc032a98847372a1d7afde009b0d675/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/775c43d37fc032a98847372a1d7afde009b0d675/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=775c43d37fc032a98847372a1d7afde009b0d675", "patch": "@@ -56,11 +56,11 @@ extern bool s390_overlap_p (rtx, rtx, HOST_WIDE_INT);\n extern bool s390_offset_p (rtx, rtx, rtx);\n extern int tls_symbolic_operand (rtx);\n \n-extern bool s390_match_ccmode (rtx, enum machine_mode);\n+extern bool s390_match_ccmode (rtx_insn *, enum machine_mode);\n extern enum machine_mode s390_tm_ccmode (rtx, rtx, bool);\n extern enum machine_mode s390_select_ccmode (enum rtx_code, rtx, rtx);\n extern rtx s390_emit_compare (enum rtx_code, rtx, rtx);\n-extern rtx s390_emit_jump (rtx, rtx);\n+extern rtx_insn *s390_emit_jump (rtx, rtx);\n extern bool symbolic_reference_mentioned_p (rtx);\n extern bool tls_symbolic_reference_mentioned_p (rtx);\n extern bool legitimate_la_operand_p (rtx);\n@@ -92,7 +92,7 @@ extern void s390_expand_atomic (enum machine_mode, enum rtx_code,\n extern void s390_expand_tbegin (rtx, rtx, rtx, bool);\n extern rtx s390_return_addr_rtx (int, rtx);\n extern rtx s390_back_chain_rtx (void);\n-extern rtx s390_emit_call (rtx, rtx, rtx, rtx);\n+extern rtx_insn *s390_emit_call (rtx, rtx, rtx, rtx);\n extern void s390_expand_logical_operator (enum rtx_code,\n \t\t\t\t\t  enum machine_mode, rtx *);\n extern bool s390_logical_operator_ok_p (rtx *);\n@@ -104,7 +104,7 @@ extern void print_operand (FILE *, rtx, int);\n extern void s390_output_pool_entry (rtx, enum machine_mode, unsigned int);\n extern int s390_label_align (rtx);\n extern int s390_agen_dep_p (rtx, rtx);\n-extern rtx s390_load_got (void);\n+extern rtx_insn *s390_load_got (void);\n extern rtx s390_get_thread_pointer (void);\n extern void s390_emit_tpf_eh_return (rtx);\n extern bool s390_legitimate_address_without_index_p (rtx);"}, {"sha": "49c88d21980194083c08332b37f6c83c75f9965c", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 68, "deletions": 64, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/775c43d37fc032a98847372a1d7afde009b0d675/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/775c43d37fc032a98847372a1d7afde009b0d675/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=775c43d37fc032a98847372a1d7afde009b0d675", "patch": "@@ -305,7 +305,7 @@ struct processor_costs zEC12_cost =\n extern int reload_completed;\n \n /* Kept up to date using the SCHED_VARIABLE_ISSUE hook.  */\n-static rtx last_scheduled_insn;\n+static rtx_insn *last_scheduled_insn;\n \n /* Structure used to hold the components of a S/390 memory\n    address.  A legitimate address on S/390 is of the general\n@@ -652,7 +652,7 @@ s390_match_ccmode_set (rtx set, enum machine_mode req_mode)\n    If REQ_MODE is VOIDmode, always return false.  */\n \n bool\n-s390_match_ccmode (rtx insn, enum machine_mode req_mode)\n+s390_match_ccmode (rtx_insn *insn, enum machine_mode req_mode)\n {\n   int i;\n \n@@ -1047,7 +1047,7 @@ s390_emit_compare_and_swap (enum rtx_code code, rtx old, rtx mem,\n    NULL_RTX, emit an unconditional jump, else a conditional jump under\n    condition COND.  */\n \n-rtx\n+rtx_insn *\n s390_emit_jump (rtx target, rtx cond)\n {\n   rtx insn;\n@@ -6029,7 +6029,8 @@ s390_split_branches (void)\n {\n   rtx temp_reg = gen_rtx_REG (Pmode, RETURN_REGNUM);\n   int new_literal = 0, ret;\n-  rtx insn, pat, tmp, target;\n+  rtx_insn *insn;\n+  rtx pat, tmp, target;\n   rtx *label;\n \n   /* We need correct insn addresses.  */\n@@ -6291,20 +6292,20 @@ struct constant\n {\n   struct constant *next;\n   rtx value;\n-  rtx label;\n+  rtx_code_label *label;\n };\n \n struct constant_pool\n {\n   struct constant_pool *next;\n-  rtx first_insn;\n-  rtx pool_insn;\n+  rtx_insn *first_insn;\n+  rtx_insn *pool_insn;\n   bitmap insns;\n-  rtx emit_pool_after;\n+  rtx_insn *emit_pool_after;\n \n   struct constant *constants[NR_C_MODES];\n   struct constant *execute;\n-  rtx label;\n+  rtx_code_label *label;\n   int size;\n };\n \n@@ -6323,11 +6324,11 @@ s390_alloc_pool (void)\n \n   pool->execute = NULL;\n   pool->label = gen_label_rtx ();\n-  pool->first_insn = NULL_RTX;\n-  pool->pool_insn = NULL_RTX;\n+  pool->first_insn = NULL;\n+  pool->pool_insn = NULL;\n   pool->insns = BITMAP_ALLOC (NULL);\n   pool->size = 0;\n-  pool->emit_pool_after = NULL_RTX;\n+  pool->emit_pool_after = NULL;\n \n   return pool;\n }\n@@ -6336,7 +6337,7 @@ s390_alloc_pool (void)\n    and chain it to the end of POOL_LIST.  */\n \n static struct constant_pool *\n-s390_start_pool (struct constant_pool **pool_list, rtx insn)\n+s390_start_pool (struct constant_pool **pool_list, rtx_insn *insn)\n {\n   struct constant_pool *pool, **prev;\n \n@@ -6354,7 +6355,7 @@ s390_start_pool (struct constant_pool **pool_list, rtx insn)\n    placeholder insn representing the pool.  */\n \n static void\n-s390_end_pool (struct constant_pool *pool, rtx insn)\n+s390_end_pool (struct constant_pool *pool, rtx_insn *insn)\n {\n   rtx pool_size = GEN_INT (pool->size + 8 /* alignment slop */);\n \n@@ -6552,7 +6553,7 @@ static void\n s390_dump_pool (struct constant_pool *pool, bool remote_label)\n {\n   struct constant *c;\n-  rtx insn = pool->pool_insn;\n+  rtx_insn *insn = pool->pool_insn;\n   int i;\n \n   /* Switch to rodata section.  */\n@@ -6659,7 +6660,7 @@ static struct constant_pool *\n s390_mainpool_start (void)\n {\n   struct constant_pool *pool;\n-  rtx insn;\n+  rtx_insn *insn;\n \n   pool = s390_alloc_pool ();\n \n@@ -6875,7 +6876,7 @@ s390_chunkify_start (void)\n   int extra_size = 0;\n   bitmap far_labels;\n   rtx pending_ltrel = NULL_RTX;\n-  rtx insn;\n+  rtx_insn *insn;\n \n   rtx (*gen_reload_base) (rtx, rtx) =\n     TARGET_CPU_ZARCH? gen_reload_base_64 : gen_reload_base_31;\n@@ -6968,7 +6969,7 @@ s390_chunkify_start (void)\n \t  if (curr_pool->size < S390_POOL_CHUNK_MAX)\n \t    continue;\n \n-\t  s390_end_pool (curr_pool, NULL_RTX);\n+\t  s390_end_pool (curr_pool, NULL);\n \t  curr_pool = NULL;\n \t}\n       else\n@@ -7002,7 +7003,7 @@ s390_chunkify_start (void)\n \t           || curr_pool->size > S390_POOL_CHUNK_MAX\n \t\t   || section_switch_p)\n \t    {\n-\t      rtx label, jump, barrier, next, prev;\n+\t      rtx_insn *label, *jump, *barrier, *next, *prev;\n \n \t      if (!section_switch_p)\n \t\t{\n@@ -7062,7 +7063,7 @@ s390_chunkify_start (void)\n     }\n \n   if (curr_pool)\n-    s390_end_pool (curr_pool, NULL_RTX);\n+    s390_end_pool (curr_pool, NULL);\n   gcc_assert (!pending_ltrel);\n \n   /* Find all labels that are branched into\n@@ -7084,7 +7085,7 @@ s390_chunkify_start (void)\n       if (LABEL_P (insn)\n \t  && (LABEL_PRESERVE_P (insn) || LABEL_NAME (insn)))\n \t{\n-\t  rtx vec_insn = NEXT_INSN (insn);\n+\t  rtx_insn *vec_insn = NEXT_INSN (insn);\n \t  if (! vec_insn || ! JUMP_TABLE_DATA_P (vec_insn))\n \t    bitmap_set_bit (far_labels, CODE_LABEL_NUMBER (insn));\n \t}\n@@ -7131,7 +7132,7 @@ s390_chunkify_start (void)\n     {\n       rtx new_insn = gen_reload_base (cfun->machine->base_reg,\n \t\t\t\t      curr_pool->label);\n-      rtx insn = curr_pool->first_insn;\n+      rtx_insn *insn = curr_pool->first_insn;\n       INSN_ADDRESSES_NEW (emit_insn_before (new_insn, insn), -1);\n     }\n \n@@ -7170,7 +7171,7 @@ static void\n s390_chunkify_finish (struct constant_pool *pool_list)\n {\n   struct constant_pool *curr_pool = NULL;\n-  rtx insn;\n+  rtx_insn *insn;\n \n \n   /* Replace all literal pool references.  */\n@@ -7226,16 +7227,16 @@ static void\n s390_chunkify_cancel (struct constant_pool *pool_list)\n {\n   struct constant_pool *curr_pool = NULL;\n-  rtx insn;\n+  rtx_insn *insn;\n \n   /* Remove all pool placeholder insns.  */\n \n   for (curr_pool = pool_list; curr_pool; curr_pool = curr_pool->next)\n     {\n       /* Did we insert an extra barrier?  Remove it.  */\n-      rtx barrier = PREV_INSN (curr_pool->pool_insn);\n-      rtx jump = barrier? PREV_INSN (barrier) : NULL_RTX;\n-      rtx label = NEXT_INSN (curr_pool->pool_insn);\n+      rtx_insn *barrier = PREV_INSN (curr_pool->pool_insn);\n+      rtx_insn *jump = barrier? PREV_INSN (barrier) : NULL;\n+      rtx_insn *label = NEXT_INSN (curr_pool->pool_insn);\n \n       if (jump && JUMP_P (jump)\n \t  && barrier && BARRIER_P (barrier)\n@@ -7257,7 +7258,7 @@ s390_chunkify_cancel (struct constant_pool *pool_list)\n \n   for (insn = get_insns (); insn; )\n     {\n-      rtx next_insn = NEXT_INSN (insn);\n+      rtx_insn *next_insn = NEXT_INSN (insn);\n \n       if (NONJUMP_INSN_P (insn)\n \t  && GET_CODE (PATTERN (insn)) == SET\n@@ -7418,7 +7419,7 @@ static void\n s390_regs_ever_clobbered (char regs_ever_clobbered[])\n {\n   basic_block cur_bb;\n-  rtx cur_insn;\n+  rtx_insn *cur_insn;\n   unsigned int i;\n \n   memset (regs_ever_clobbered, 0, 32);\n@@ -7967,10 +7968,10 @@ s390_optimize_nonescaping_tx (void)\n   basic_block tbegin_bb = NULL;\n   basic_block tend_bb = NULL;\n   basic_block bb;\n-  rtx insn;\n+  rtx_insn *insn;\n   bool result = true;\n   int bb_index;\n-  rtx tbegin_insn = NULL_RTX;\n+  rtx_insn *tbegin_insn = NULL;\n \n   if (!cfun->machine->tbegin_p)\n     return;\n@@ -8517,10 +8518,10 @@ restore_gprs (rtx base, int offset, int first, int last)\n /* Return insn sequence to load the GOT register.  */\n \n static GTY(()) rtx got_symbol;\n-rtx\n+rtx_insn *\n s390_load_got (void)\n {\n-  rtx insns;\n+  rtx_insn *insns;\n \n   /* We cannot use pic_offset_table_rtx here since we use this\n      function also for non-pic if __tls_get_offset is called and in\n@@ -8589,7 +8590,7 @@ s390_save_gprs_to_fprs (void)\n     {\n       if (FP_REGNO_P (cfun_gpr_save_slot (i)))\n \t{\n-\t  rtx insn =\n+\t  rtx_insn *insn =\n \t    emit_move_insn (gen_rtx_REG (DImode, cfun_gpr_save_slot (i)),\n \t\t\t    gen_rtx_REG (DImode, i));\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n@@ -8611,7 +8612,7 @@ s390_restore_gprs_from_fprs (void)\n     {\n       if (FP_REGNO_P (cfun_gpr_save_slot (i)))\n \t{\n-\t  rtx insn =\n+\t  rtx_insn *insn =\n \t    emit_move_insn (gen_rtx_REG (DImode, i),\n \t\t\t    gen_rtx_REG (DImode, cfun_gpr_save_slot (i)));\n \t  df_set_regs_ever_live (i, true);\n@@ -8659,7 +8660,7 @@ class pass_s390_early_mach : public rtl_opt_pass\n unsigned int\n pass_s390_early_mach::execute (function *fun)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n   /* Try to get rid of the FPR clobbers.  */\n   s390_optimize_nonescaping_tx ();\n@@ -8952,7 +8953,7 @@ s390_emit_prologue (void)\n \n   if (flag_pic && df_regs_ever_live_p (PIC_OFFSET_TABLE_REGNUM))\n     {\n-      rtx insns = s390_load_got ();\n+      rtx_insn *insns = s390_load_got ();\n \n       for (insn = insns; insn; insn = NEXT_INSN (insn))\n \tannotate_constant_pool_refs (&PATTERN (insn));\n@@ -9931,7 +9932,7 @@ s390_expand_tbegin (rtx dest, rtx tdb, rtx retry, bool clobber_fprs_p)\n       const int CC3 = 1 << 0;\n       rtx jump;\n       rtx count = gen_reg_rtx (SImode);\n-      rtx leave_label = gen_label_rtx ();\n+      rtx_code_label *leave_label = gen_label_rtx ();\n \n       /* Exit for success and permanent failures.  */\n       jump = s390_emit_jump (leave_label,\n@@ -10714,12 +10715,12 @@ s390_fixed_condition_code_regs (unsigned int *p1, unsigned int *p2)\n                If this parameter is NULL_RTX the call is considered\n                to be a sibling call.  */\n \n-rtx\n+rtx_insn *\n s390_emit_call (rtx addr_location, rtx tls_call, rtx result_reg,\n \t\trtx retaddr_reg)\n {\n   bool plt_call = false;\n-  rtx insn;\n+  rtx_insn *insn;\n   rtx call;\n   rtx clobber;\n   rtvec vec;\n@@ -10849,7 +10850,8 @@ static GTY(()) rtx s390_tpf_eh_return_symbol;\n void\n s390_emit_tpf_eh_return (rtx target)\n {\n-  rtx insn, reg, orig_ra;\n+  rtx_insn *insn;\n+  rtx reg, orig_ra;\n \n   if (!s390_tpf_eh_return_symbol)\n     s390_tpf_eh_return_symbol = gen_rtx_SYMBOL_REF (Pmode, \"__tpf_eh_return\");\n@@ -10873,7 +10875,7 @@ s390_emit_tpf_eh_return (rtx target)\n static void\n s390_optimize_prologue (void)\n {\n-  rtx insn, new_insn, next_insn;\n+  rtx_insn *insn, *new_insn, *next_insn;\n \n   /* Do a final recompute of the frame-related data.  */\n   s390_optimize_register_info ();\n@@ -10963,12 +10965,12 @@ s390_optimize_prologue (void)\n \n \t  if (cfun_frame_layout.first_save_gpr != -1)\n \t    {\n-\t      new_insn \t= save_gprs (base,\n+\t      rtx s_pat = save_gprs (base,\n \t\t\t\t     off + (cfun_frame_layout.first_save_gpr\n \t\t\t\t\t    - first) * UNITS_PER_LONG,\n \t\t\t\t     cfun_frame_layout.first_save_gpr,\n \t\t\t\t     cfun_frame_layout.last_save_gpr);\n-\t      new_insn = emit_insn_before (new_insn, insn);\n+\t      new_insn = emit_insn_before (s_pat, insn);\n \t      INSN_ADDRESSES_NEW (new_insn, -1);\n \t    }\n \n@@ -11022,23 +11024,23 @@ s390_optimize_prologue (void)\n \n \t  if (cfun_frame_layout.first_restore_gpr != -1)\n \t    {\n-\t      new_insn = restore_gprs (base,\n+\t      rtx rpat = restore_gprs (base,\n \t\t\t\t       off + (cfun_frame_layout.first_restore_gpr\n \t\t\t\t\t      - first) * UNITS_PER_LONG,\n \t\t\t\t       cfun_frame_layout.first_restore_gpr,\n \t\t\t\t       cfun_frame_layout.last_restore_gpr);\n \n \t      /* Remove REG_CFA_RESTOREs for registers that we no\n \t\t longer need to save.  */\n-\t      REG_NOTES (new_insn) = REG_NOTES (insn);\n-\t      for (rtx *ptr = &REG_NOTES (new_insn); *ptr; )\n+\t      REG_NOTES (rpat) = REG_NOTES (insn);\n+\t      for (rtx *ptr = &REG_NOTES (rpat); *ptr; )\n \t\tif (REG_NOTE_KIND (*ptr) == REG_CFA_RESTORE\n \t\t    && ((int) REGNO (XEXP (*ptr, 0))\n \t\t\t< cfun_frame_layout.first_restore_gpr))\n \t\t  *ptr = XEXP (*ptr, 1);\n \t\telse\n \t\t  ptr = &XEXP (*ptr, 1);\n-\t      new_insn = emit_insn_before (new_insn, insn);\n+\t      new_insn = emit_insn_before (rpat, insn);\n \t      RTX_FRAME_RELATED_P (new_insn) = 1;\n \t      INSN_ADDRESSES_NEW (new_insn, -1);\n \t    }\n@@ -11077,12 +11079,12 @@ s390_optimize_prologue (void)\n    branch in a way which makes the static prediction always correct.\n    The function returns true if it added an instruction.  */\n static bool\n-s390_fix_long_loop_prediction (rtx insn)\n+s390_fix_long_loop_prediction (rtx_insn *insn)\n {\n   rtx set = single_set (insn);\n   rtx code_label, label_ref, new_label;\n   rtx uncond_jump;\n-  rtx cur_insn;\n+  rtx_insn *cur_insn;\n   rtx tmp;\n   int distance;\n \n@@ -11139,7 +11141,7 @@ s390_fix_long_loop_prediction (rtx insn)\n /* Returns 1 if INSN reads the value of REG for purposes not related\n    to addressing of memory, and 0 otherwise.  */\n static int\n-s390_non_addr_reg_read_p (rtx reg, rtx insn)\n+s390_non_addr_reg_read_p (rtx reg, rtx_insn *insn)\n {\n   return reg_referenced_p (reg, PATTERN (insn))\n     && !reg_used_in_mem_p (REGNO (reg), PATTERN (insn));\n@@ -11148,8 +11150,8 @@ s390_non_addr_reg_read_p (rtx reg, rtx insn)\n /* Starting from INSN find_cond_jump looks downwards in the insn\n    stream for a single jump insn which is the last user of the\n    condition code set in INSN.  */\n-static rtx\n-find_cond_jump (rtx insn)\n+static rtx_insn *\n+find_cond_jump (rtx_insn *insn)\n {\n   for (; insn; insn = NEXT_INSN (insn))\n     {\n@@ -11184,14 +11186,14 @@ find_cond_jump (rtx insn)\n       break;\n     }\n \n-  return NULL_RTX;\n+  return NULL;\n }\n \n /* Swap the condition in COND and the operands in OP0 and OP1 so that\n    the semantics does not change.  If NULL_RTX is passed as COND the\n    function tries to find the conditional jump starting with INSN.  */\n static void\n-s390_swap_cmp (rtx cond, rtx *op0, rtx *op1, rtx insn)\n+s390_swap_cmp (rtx cond, rtx *op0, rtx *op1, rtx_insn *insn)\n {\n   rtx tmp = *op0;\n \n@@ -11221,9 +11223,9 @@ s390_swap_cmp (rtx cond, rtx *op0, rtx *op1, rtx insn)\n    operands of the compare.  The function return true whenever it\n    added an insn.  */\n static bool\n-s390_z10_optimize_cmp (rtx insn)\n+s390_z10_optimize_cmp (rtx_insn *insn)\n {\n-  rtx prev_insn, next_insn;\n+  rtx_insn *prev_insn, *next_insn;\n   bool insn_added_p = false;\n   rtx cond, *op0, *op1;\n \n@@ -11391,7 +11393,8 @@ s390_reorg (void)\n   /* Generate out-of-pool execute target insns.  */\n   if (TARGET_CPU_ZARCH)\n     {\n-      rtx insn, label, target;\n+      rtx_insn *insn, *target;\n+      rtx label;\n \n       for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n \t{\n@@ -11417,7 +11420,7 @@ s390_reorg (void)\n       || s390_tune == PROCESSOR_2817_Z196\n       || s390_tune == PROCESSOR_2827_ZEC12)\n     {\n-      rtx insn;\n+      rtx_insn *insn;\n       bool insn_added_p = false;\n \n       /* The insn lengths and addresses have to be up to date for the\n@@ -11485,7 +11488,7 @@ s390_z10_prevent_earlyload_conflicts (rtx *ready, int *nready_p)\n   int nready = *nready_p;\n   rtx tmp;\n   int i;\n-  rtx insn;\n+  rtx_insn *insn;\n   rtx set;\n   enum attr_type flag;\n   int distance;\n@@ -11709,8 +11712,9 @@ s390_sched_reorder (FILE *file, int verbose,\n    last_scheduled_insn in order to make it available for\n    s390_sched_reorder.  */\n static int\n-s390_sched_variable_issue (FILE *file, int verbose, rtx insn, int more)\n+s390_sched_variable_issue (FILE *file, int verbose, rtx uncast_insn, int more)\n {\n+  rtx_insn *insn = as_a <rtx_insn *> (uncast_insn);\n   last_scheduled_insn = insn;\n \n   if (s390_tune == PROCESSOR_2827_ZEC12\n@@ -11772,7 +11776,7 @@ s390_sched_init (FILE *file ATTRIBUTE_UNUSED,\n \t\t int verbose ATTRIBUTE_UNUSED,\n \t\t int max_ready ATTRIBUTE_UNUSED)\n {\n-  last_scheduled_insn = NULL_RTX;\n+  last_scheduled_insn = NULL;\n   s390_sched_state = 0;\n }\n \n@@ -11800,7 +11804,7 @@ static unsigned\n s390_loop_unroll_adjust (unsigned nunroll, struct loop *loop)\n {\n   basic_block *bbs;\n-  rtx insn;\n+  rtx_insn *insn;\n   unsigned i;\n   unsigned mem_count = 0;\n \n@@ -11815,7 +11819,7 @@ s390_loop_unroll_adjust (unsigned nunroll, struct loop *loop)\n     {\n       for (insn = BB_HEAD (bbs[i]); insn != BB_END (bbs[i]); insn = NEXT_INSN (insn))\n \tif (INSN_P (insn) && INSN_CODE (insn) != -1)\n-            for_each_rtx (&insn, (rtx_function) check_dpu, &mem_count);\n+            for_each_rtx_in_insn (&insn, (rtx_function) check_dpu, &mem_count);\n     }\n   free (bbs);\n "}]}