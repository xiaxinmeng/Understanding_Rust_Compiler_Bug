{"sha": "726b7aa004d6885388a76521222602b8552a41ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzI2YjdhYTAwNGQ2ODg1Mzg4YTc2NTIxMjIyNjAyYjg1NTJhNDFlZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2021-01-28T01:55:50Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2021-01-29T19:04:55Z"}, "message": "libgo: update to Go1.16rc1\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/287493", "tree": {"sha": "5179037ef840a43dcea0f3be4e07dbcbcfcb2c4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5179037ef840a43dcea0f3be4e07dbcbcfcb2c4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/726b7aa004d6885388a76521222602b8552a41ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/726b7aa004d6885388a76521222602b8552a41ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/726b7aa004d6885388a76521222602b8552a41ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/726b7aa004d6885388a76521222602b8552a41ee/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91a95ad2ae0e0f2fa953fafe55ff2ec32c8277d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91a95ad2ae0e0f2fa953fafe55ff2ec32c8277d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91a95ad2ae0e0f2fa953fafe55ff2ec32c8277d5"}], "stats": {"total": 20487, "additions": 10374, "deletions": 10113}, "files": [{"sha": "366fcf02885ab5682c64d9b8aea0facf69deb42b", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -1,4 +1,4 @@\n-83eea1930671ce2bba863582a67f2609bc4f9f36\n+2663206528a6d46cbde60dbccf84c8288707ab8d\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "b2fc633f06cfb530b2ae3cc72a2276094158aa43", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -1,4 +1,4 @@\n-2ff33f5e443165e55a080f3a649e4c070c4096d1\n+3e06467282c6d5678a6273747658c04314e013ef\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "7be90a564fe7497b23cddfddacf5facdcd1fde75", "filename": "libgo/Makefile.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -656,7 +656,7 @@ noinst_DATA += zdefaultcc.go\n \n # Generate the list of go std packages that were included in libgo\n zstdpkglist.go: s-zstdpkglist; @true\n-s-zstdpkglist: Makefile\n+s-zstdpkglist: Makefile libgo-packages.txt\n \trm -f zstdpkglist.go.tmp\n \techo 'package goroot' > zstdpkglist.go.tmp\n \techo \"\" >> zstdpkglist.go.tmp"}, {"sha": "c52723b6d883df50635d39e13ce05746921a6669", "filename": "libgo/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -2828,7 +2828,7 @@ s-runtime-inc: runtime.lo mkruntimeinc.sh Makefile\n \n # Generate the list of go std packages that were included in libgo\n zstdpkglist.go: s-zstdpkglist; @true\n-s-zstdpkglist: Makefile\n+s-zstdpkglist: Makefile libgo-packages.txt\n \trm -f zstdpkglist.go.tmp\n \techo 'package goroot' > zstdpkglist.go.tmp\n \techo \"\" >> zstdpkglist.go.tmp"}, {"sha": "a19294250b3652ca9af6a0e6c4b257982a4d6268", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -1 +1 @@\n-go1.16beta1\n+go1.16rc1"}, {"sha": "1e549cae4b0fa7e3d57f0a808d2458a77a19cfe0", "filename": "libgo/check-packages.txt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fcheck-packages.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fcheck-packages.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fcheck-packages.txt?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -80,6 +80,7 @@ flag\n fmt\n go/ast\n go/build\n+go/build/constraint\n go/constant\n go/doc\n go/format\n@@ -107,6 +108,7 @@ image/jpeg\n image/png\n index/suffixarray\n internal/cpu\n+internal/execabs\n internal/fmtsort\n internal/poll\n internal/profile"}, {"sha": "6d0a40380828454bfe1563416a934f5482db0693", "filename": "libgo/go/archive/tar/strconv.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Farchive%2Ftar%2Fstrconv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Farchive%2Ftar%2Fstrconv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fstrconv.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -28,7 +28,7 @@ func isASCII(s string) bool {\n }\n \n // toASCII converts the input to an ASCII C-style string.\n-// This a best effort conversion, so invalid characters are dropped.\n+// This is a best effort conversion, so invalid characters are dropped.\n func toASCII(s string) string {\n \tif isASCII(s) {\n \t\treturn s"}, {"sha": "fa24567d9bc32f00b959f4bd3df393781dd70558", "filename": "libgo/go/cmd/cgo/gcc.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -1567,7 +1567,14 @@ func (p *Package) gccBaseCmd() []string {\n func (p *Package) gccMachine() []string {\n \tswitch goarch {\n \tcase \"amd64\":\n+\t\tif goos == \"darwin\" {\n+\t\t\treturn []string{\"-arch\", \"x86_64\", \"-m64\"}\n+\t\t}\n \t\treturn []string{\"-m64\"}\n+\tcase \"arm64\":\n+\t\tif goos == \"darwin\" {\n+\t\t\treturn []string{\"-arch\", \"arm64\"}\n+\t\t}\n \tcase \"386\":\n \t\treturn []string{\"-m32\"}\n \tcase \"arm\":"}, {"sha": "b469b5fe06a089410f5d626845c5b867a477b0bb", "filename": "libgo/go/cmd/cgo/out.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -14,10 +14,10 @@ import (\n \t\"go/ast\"\n \t\"go/printer\"\n \t\"go/token\"\n+\texec \"internal/execabs\"\n \t\"internal/xcoff\"\n \t\"io\"\n \t\"os\"\n-\t\"os/exec\"\n \t\"path/filepath\"\n \t\"regexp\"\n \t\"sort\"\n@@ -958,9 +958,9 @@ func (p *Package) writeExports(fgo2, fm, fgcc, fgcch io.Writer) {\n \t\t// Build the wrapper function compiled by gcc.\n \t\tgccExport := \"\"\n \t\tif goos == \"windows\" {\n-\t\t\tgccExport = \"__declspec(dllexport)\"\n+\t\t\tgccExport = \"__declspec(dllexport) \"\n \t\t}\n-\t\ts := fmt.Sprintf(\"%s %s %s(\", gccExport, gccResult, exp.ExpName)\n+\t\ts := fmt.Sprintf(\"%s%s %s(\", gccExport, gccResult, exp.ExpName)\n \t\tif fn.Recv != nil {\n \t\t\ts += p.cgoType(fn.Recv.List[0].Type).C.String()\n \t\t\ts += \" recv\""}, {"sha": "00d931b98a0c1e8416d5bb14334946dbd9a56304", "filename": "libgo/go/cmd/cgo/util.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fcgo%2Futil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fcgo%2Futil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Futil.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -8,9 +8,9 @@ import (\n \t\"bytes\"\n \t\"fmt\"\n \t\"go/token\"\n+\texec \"internal/execabs\"\n \t\"io/ioutil\"\n \t\"os\"\n-\t\"os/exec\"\n )\n \n // run runs the command argv, feeding in stdin on standard input.\n@@ -63,7 +63,7 @@ func run(stdin []byte, argv []string) (stdout, stderr []byte, ok bool) {\n \tp.Env = append(os.Environ(), \"TERM=dumb\")\n \terr := p.Run()\n \tif _, ok := err.(*exec.ExitError); err != nil && !ok {\n-\t\tfatalf(\"%s\", err)\n+\t\tfatalf(\"exec %s: %s\", argv[0], err)\n \t}\n \tok = p.ProcessState.Success()\n \tstdout, stderr = bout.Bytes(), berr.Bytes()\n@@ -88,7 +88,7 @@ func fatalf(msg string, args ...interface{}) {\n \t// If we've already printed other errors, they might have\n \t// caused the fatal condition. Assume they're enough.\n \tif nerrors == 0 {\n-\t\tfmt.Fprintf(os.Stderr, msg+\"\\n\", args...)\n+\t\tfmt.Fprintf(os.Stderr, \"cgo: \"+msg+\"\\n\", args...)\n \t}\n \tos.Exit(2)\n }"}, {"sha": "235e28f64f3e264637fa8a7d0b8e5cc0704c421c", "filename": "libgo/go/cmd/go.mod", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo.mod?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -6,7 +6,7 @@ require (\n \tgithub.com/google/pprof v0.0.0-20201203190320-1bf35d6f28c2\n \tgolang.org/x/arch v0.0.0-20201008161808-52c3e6f60cff\n \tgolang.org/x/crypto v0.0.0-20201016220609-9e8e0b390897\n-\tgolang.org/x/mod v0.4.0\n+\tgolang.org/x/mod v0.4.1\n \tgolang.org/x/sys v0.0.0-20201204225414-ed752295db88 // indirect\n-\tgolang.org/x/tools v0.0.0-20201211025543-abf6a1d87e11\n+\tgolang.org/x/tools v0.0.0-20210107193943-4ed967dd8eff\n )"}, {"sha": "49d390297cdc508135437283e4670e9824c86cd4", "filename": "libgo/go/cmd/go/alldocs.go", "status": "modified", "additions": 127, "deletions": 736, "changes": 863, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -153,7 +153,10 @@\n // \t\tcreated with -buildmode=shared.\n // \t-mod mode\n // \t\tmodule download mode to use: readonly, vendor, or mod.\n-// \t\tSee 'go help modules' for more.\n+// \t\tBy default, if a vendor directory is present and the go version in go.mod\n+// \t\tis 1.14 or higher, the go command acts as if -mod=vendor were set.\n+// \t\tOtherwise, the go command acts as if -mod=readonly were set.\n+// \t\tSee https://golang.org/ref/mod#build-commands for details.\n // \t-modcacherw\n // \t\tleave newly-created directories in the module cache read-write\n // \t\tinstead of making them read-only.\n@@ -492,15 +495,6 @@\n // (gofmt), a fully qualified path (/usr/you/bin/mytool), or a\n // command alias, described below.\n //\n-// To convey to humans and machine tools that code is generated,\n-// generated source should have a line that matches the following\n-// regular expression (in Go syntax):\n-//\n-// \t^// Code generated .* DO NOT EDIT\\.$\n-//\n-// The line may appear anywhere in the file, but is typically\n-// placed near the beginning so it is easy to find.\n-//\n // Note that go generate does not parse the file, so lines that look\n // like directives in comments or multiline strings will be treated\n // as directives.\n@@ -512,6 +506,15 @@\n // Quoted strings use Go syntax and are evaluated before execution; a\n // quoted string appears as a single argument to the generator.\n //\n+// To convey to humans and machine tools that code is generated,\n+// generated source should have a line that matches the following\n+// regular expression (in Go syntax):\n+//\n+// \t^// Code generated .* DO NOT EDIT\\.$\n+//\n+// This line must appear before the first non-comment, non-blank\n+// text in the file.\n+//\n // Go generate sets several variables when it runs the generator:\n //\n // \t$GOARCH\n@@ -595,85 +598,49 @@\n //\n // \tgo get [-d] [-t] [-u] [-v] [-insecure] [build flags] [packages]\n //\n-// Get resolves and adds dependencies to the current development module\n-// and then builds and installs them.\n-//\n-// The first step is to resolve which dependencies to add.\n-//\n-// For each named package or package pattern, get must decide which version of\n-// the corresponding module to use. By default, get looks up the latest tagged\n-// release version, such as v0.4.5 or v1.2.3. If there are no tagged release\n-// versions, get looks up the latest tagged pre-release version, such as\n-// v0.0.1-pre1. If there are no tagged versions at all, get looks up the latest\n-// known commit. If the module is not already required at a later version\n-// (for example, a pre-release newer than the latest release), get will use\n-// the version it looked up. Otherwise, get will use the currently\n-// required version.\n-//\n-// This default version selection can be overridden by adding an @version\n-// suffix to the package argument, as in 'go get golang.org/x/text@v0.3.0'.\n-// The version may be a prefix: @v1 denotes the latest available version starting\n-// with v1. See 'go help modules' under the heading 'Module queries' for the\n-// full query syntax.\n-//\n-// For modules stored in source control repositories, the version suffix can\n-// also be a commit hash, branch identifier, or other syntax known to the\n-// source control system, as in 'go get golang.org/x/text@master'. Note that\n-// branches with names that overlap with other module query syntax cannot be\n-// selected explicitly. For example, the suffix @v2 means the latest version\n-// starting with v2, not the branch named v2.\n-//\n-// If a module under consideration is already a dependency of the current\n-// development module, then get will update the required version.\n-// Specifying a version earlier than the current required version is valid and\n-// downgrades the dependency. The version suffix @none indicates that the\n-// dependency should be removed entirely, downgrading or removing modules\n-// depending on it as needed.\n-//\n-// The version suffix @latest explicitly requests the latest minor release of\n-// the module named by the given path. The suffix @upgrade is like @latest but\n-// will not downgrade a module if it is already required at a revision or\n-// pre-release version newer than the latest released version. The suffix\n-// @patch requests the latest patch release: the latest released version\n-// with the same major and minor version numbers as the currently required\n-// version. Like @upgrade, @patch will not downgrade a module already required\n-// at a newer version. If the path is not already required, @upgrade is\n-// equivalent to @latest, and @patch is disallowed.\n-//\n-// Although get defaults to using the latest version of the module containing\n-// a named package, it does not use the latest version of that module's\n-// dependencies. Instead it prefers to use the specific dependency versions\n-// requested by that module. For example, if the latest A requires module\n-// B v1.2.3, while B v1.2.4 and v1.3.1 are also available, then 'go get A'\n-// will use the latest A but then use B v1.2.3, as requested by A. (If there\n-// are competing requirements for a particular module, then 'go get' resolves\n-// those requirements by taking the maximum requested version.)\n+// Get resolves its command-line arguments to packages at specific module versions,\n+// updates go.mod to require those versions, downloads source code into the\n+// module cache, then builds and installs the named packages.\n+//\n+// To add a dependency for a package or upgrade it to its latest version:\n+//\n+// \tgo get example.com/pkg\n+//\n+// To upgrade or downgrade a package to a specific version:\n+//\n+// \tgo get example.com/pkg@v1.2.3\n+//\n+// To remove a dependency on a module and downgrade modules that require it:\n+//\n+// \tgo get example.com/mod@none\n+//\n+// See https://golang.org/ref/mod#go-get for details.\n+//\n+// The 'go install' command may be used to build and install packages. When a\n+// version is specified, 'go install' runs in module-aware mode and ignores\n+// the go.mod file in the current directory. For example:\n+//\n+// \tgo install example.com/pkg@v1.2.3\n+// \tgo install example.com/pkg@latest\n+//\n+// See 'go help install' or https://golang.org/ref/mod#go-install for details.\n+//\n+// In addition to build flags (listed in 'go help build') 'go get' accepts the\n+// following flags.\n //\n // The -t flag instructs get to consider modules needed to build tests of\n // packages specified on the command line.\n //\n // The -u flag instructs get to update modules providing dependencies\n // of packages named on the command line to use newer minor or patch\n-// releases when available. Continuing the previous example, 'go get -u A'\n-// will use the latest A with B v1.3.1 (not B v1.2.3). If B requires module C,\n-// but C does not provide any packages needed to build packages in A\n-// (not including tests), then C will not be updated.\n+// releases when available.\n //\n // The -u=patch flag (not -u patch) also instructs get to update dependencies,\n // but changes the default to select patch releases.\n-// Continuing the previous example,\n-// 'go get -u=patch A@latest' will use the latest A with B v1.2.4 (not B v1.2.3),\n-// while 'go get -u=patch A' will use a patch release of A instead.\n //\n // When the -t and -u flags are used together, get will update\n // test dependencies as well.\n //\n-// In general, adding a new dependency may require upgrading\n-// existing dependencies to keep a working build, and 'go get' does\n-// this automatically. Similarly, downgrading one dependency may\n-// require downgrading other dependencies, and 'go get' does\n-// this automatically as well.\n-//\n // The -insecure flag permits fetching from repositories and resolving\n // custom domains using insecure schemes such as HTTP, and also bypassess\n // module sum validation using the checksum database. Use with caution.\n@@ -682,12 +649,8 @@\n // variable instead. To bypass module sum validation, use GOPRIVATE or\n // GONOSUMDB. See 'go help environment' for details.\n //\n-// The second step is to download (if needed), build, and install\n-// the named packages.\n-//\n-// The -d flag instructs get to skip this step, downloading source code\n-// needed to build the named packages and their dependencies, but not\n-// building or installing.\n+// The -d flag instructs get not to build or install packages. get will only\n+// update go.mod and download source code needed to build packages.\n //\n // Building and installing packages with get is deprecated. In a future release,\n // the -d flag will be enabled by default, and 'go get' will be only be used to\n@@ -696,31 +659,14 @@\n // ignoring the current module, use 'go install' with an @version suffix like\n // \"@latest\" after each argument.\n //\n-// If an argument names a module but not a package (because there is no\n-// Go source code in the module's root directory), then the install step\n-// is skipped for that argument, instead of causing a build failure.\n-// For example 'go get golang.org/x/perf' succeeds even though there\n-// is no code corresponding to that import path.\n-//\n-// Note that package patterns are allowed and are expanded after resolving\n-// the module versions. For example, 'go get golang.org/x/perf/cmd/...'\n-// adds the latest golang.org/x/perf and then installs the commands in that\n-// latest version.\n-//\n-// With no package arguments, 'go get' applies to Go package in the\n-// current directory, if any. In particular, 'go get -u' and\n-// 'go get -u=patch' update all the dependencies of that package.\n-// With no package arguments and also without -u, 'go get' is not much more\n-// than 'go install', and 'go get -d' not much more than 'go list'.\n-//\n-// For more about modules, see 'go help modules'.\n+// For more about modules, see https://golang.org/ref/mod.\n //\n // For more about specifying packages, see 'go help packages'.\n //\n // This text describes the behavior of get using modules to manage source\n // code and dependencies. If instead the go command is running in GOPATH\n // mode, the details of get's flags and effects change, as does 'go help get'.\n-// See 'go help modules' and 'go help gopath-get'.\n+// See 'go help gopath-get'.\n //\n // See also: go build, go install, go clean, go mod.\n //\n@@ -840,6 +786,14 @@\n //         TestGoFiles     []string   // _test.go files in package\n //         XTestGoFiles    []string   // _test.go files outside package\n //\n+//         // Embedded files\n+//         EmbedPatterns      []string // //go:embed patterns\n+//         EmbedFiles         []string // files matched by EmbedPatterns\n+//         TestEmbedPatterns  []string // //go:embed patterns in TestGoFiles\n+//         TestEmbedFiles     []string // files matched by TestEmbedPatterns\n+//         XTestEmbedPatterns []string // //go:embed patterns in XTestGoFiles\n+//         XTestEmbedFiles    []string // files matched by XTestEmbedPatterns\n+//\n //         // Cgo directives\n //         CgoCFLAGS    []string // cgo: flags for C compiler\n //         CgoCPPFLAGS  []string // cgo: flags for C preprocessor\n@@ -1051,7 +1005,7 @@\n //\n // For more about specifying packages, see 'go help packages'.\n //\n-// For more about modules, see 'go help modules'.\n+// For more about modules, see https://golang.org/ref/mod.\n //\n //\n // Module maintenance\n@@ -1116,7 +1070,9 @@\n //\n // The -x flag causes download to print the commands download executes.\n //\n-// See 'go help modules' for more about module queries.\n+// See https://golang.org/ref/mod#go-mod-download for more about 'go mod download'.\n+//\n+// See https://golang.org/ref/mod#version-queries for more about version queries.\n //\n //\n // Edit go.mod from tools or scripts\n@@ -1192,6 +1148,7 @@\n // \t\tRequire []Require\n // \t\tExclude []Module\n // \t\tReplace []Replace\n+// \t\tRetract []Retract\n // \t}\n //\n // \ttype Require struct {\n@@ -1218,9 +1175,7 @@\n // referred to indirectly. For the full set of modules available to a build,\n // use 'go list -m -json all'.\n //\n-// For example, a tool can obtain the go.mod as a data structure by\n-// parsing the output of 'go mod edit -json' and can then make changes\n-// by invoking 'go mod edit' with -require, -exclude, and so on.\n+// See https://golang.org/ref/mod#go-mod-edit for more about 'go mod edit'.\n //\n //\n // Print module requirement graph\n@@ -1234,6 +1189,8 @@\n // and one of its requirements. Each module is identified as a string of the form\n // path@version, except for the main module, which has no @version suffix.\n //\n+// See https://golang.org/ref/mod#go-mod-graph for more about 'go mod graph'.\n+//\n //\n // Initialize new module in current directory\n //\n@@ -1253,6 +1210,8 @@\n // If a configuration file for a vendoring tool is present, init will attempt to\n // import module requirements from it.\n //\n+// See https://golang.org/ref/mod#go-mod-init for more about 'go mod init'.\n+//\n //\n // Add missing and remove unused modules\n //\n@@ -1272,6 +1231,8 @@\n // The -e flag causes tidy to attempt to proceed despite errors\n // encountered while loading packages.\n //\n+// See https://golang.org/ref/mod#go-mod-tidy for more about 'go mod tidy'.\n+//\n //\n // Make vendored copy of dependencies\n //\n@@ -1289,6 +1250,8 @@\n // The -e flag causes vendor to attempt to proceed despite errors\n // encountered while loading packages.\n //\n+// See https://golang.org/ref/mod#go-mod-vendor for more about 'go mod vendor'.\n+//\n //\n // Verify dependencies have expected content\n //\n@@ -1303,6 +1266,8 @@\n // modules have been changed and causes 'go mod' to exit with a\n // non-zero status.\n //\n+// See https://golang.org/ref/mod#go-mod-verify for more about 'go mod verify'.\n+//\n //\n // Explain why packages or modules are needed\n //\n@@ -1339,6 +1304,8 @@\n // \t(main module does not need package golang.org/x/text/encoding)\n // \t$\n //\n+// See https://golang.org/ref/mod#go-mod-why for more about 'go mod why'.\n+//\n //\n // Compile and run Go program\n //\n@@ -1783,6 +1750,10 @@\n //\n // General-purpose environment variables:\n //\n+// \tGO111MODULE\n+// \t\tControls whether the go command runs in module-aware mode or GOPATH mode.\n+// \t\tMay be \"off\", \"on\", or \"auto\".\n+// \t\tSee https://golang.org/ref/mod#mod-commands.\n // \tGCCGO\n // \t\tThe gccgo command to run for 'go build -compiler=gccgo'.\n // \tGOARCH\n@@ -1821,20 +1792,24 @@\n // \tGOPATH\n // \t\tFor more details see: 'go help gopath'.\n // \tGOPROXY\n-// \t\tURL of Go module proxy. See 'go help modules'.\n+// \t\tURL of Go module proxy. See https://golang.org/ref/mod#environment-variables\n+// \t\tand https://golang.org/ref/mod#module-proxy for details.\n // \tGOPRIVATE, GONOPROXY, GONOSUMDB\n // \t\tComma-separated list of glob patterns (in the syntax of Go's path.Match)\n // \t\tof module path prefixes that should always be fetched directly\n // \t\tor that should not be compared against the checksum database.\n-// \t\tSee 'go help private'.\n+// \t\tSee https://golang.org/ref/mod#private-modules.\n // \tGOROOT\n // \t\tThe root of the go tree.\n // \tGOSUMDB\n // \t\tThe name of checksum database to use and optionally its public key and\n-// \t\tURL. See 'go help module-auth'.\n+// \t\tURL. See https://golang.org/ref/mod#authenticating.\n // \tGOTMPDIR\n // \t\tThe directory where the go command will write\n // \t\ttemporary source files, packages, and binaries.\n+// \tGOVCS\n+// \t  Lists version control commands that may be used with matching servers.\n+// \t\tSee 'go help vcs'.\n //\n // Environment variables for use with cgo:\n //\n@@ -1979,88 +1954,23 @@\n // directory and then successive parent directories to find the go.mod\n // marking the root of the main (current) module.\n //\n-// The go.mod file itself is line-oriented, with // comments but\n-// no /* */ comments. Each line holds a single directive, made up of a\n-// verb followed by arguments. For example:\n-//\n-// \tmodule my/thing\n-// \tgo 1.12\n-// \trequire other/thing v1.0.2\n-// \trequire new/thing/v2 v2.3.4\n-// \texclude old/thing v1.2.3\n-// \treplace bad/thing v1.4.5 => good/thing v1.4.5\n-// \tretract v1.5.6\n-//\n-// The verbs are\n-// \tmodule, to define the module path;\n-// \tgo, to set the expected language version;\n-// \trequire, to require a particular module at a given version or later;\n-// \texclude, to exclude a particular module version from use;\n-// \treplace, to replace a module version with a different module version; and\n-// \tretract, to indicate a previously released version should not be used.\n-// Exclude and replace apply only in the main module's go.mod and are ignored\n-// in dependencies.  See https://golang.org/ref/mod for details.\n-//\n-// The leading verb can be factored out of adjacent lines to create a block,\n-// like in Go imports:\n-//\n-// \trequire (\n-// \t\tnew/thing/v2 v2.3.4\n-// \t\told/thing v1.2.3\n-// \t)\n-//\n-// The go.mod file is designed both to be edited directly and to be\n-// easily updated by tools. The 'go mod edit' command can be used to\n-// parse and edit the go.mod file from programs and tools.\n-// See 'go help mod edit'.\n-//\n-// The go command automatically updates go.mod each time it uses the\n-// module graph, to make sure go.mod always accurately reflects reality\n-// and is properly formatted. For example, consider this go.mod file:\n-//\n-//         module M\n-//\n-//         require (\n-//                 A v1\n-//                 B v1.0.0\n-//                 C v1.0.0\n-//                 D v1.2.3\n-//                 E dev\n-//         )\n-//\n-//         exclude D v1.2.3\n-//\n-// The update rewrites non-canonical version identifiers to semver form,\n-// so A's v1 becomes v1.0.0 and E's dev becomes the pseudo-version for the\n-// latest commit on the dev branch, perhaps v0.0.0-20180523231146-b3f5c0f6e5f1.\n-//\n-// The update modifies requirements to respect exclusions, so the\n-// requirement on the excluded D v1.2.3 is updated to use the next\n-// available version of D, perhaps D v1.2.4 or D v1.3.0.\n-//\n-// The update removes redundant or misleading requirements.\n-// For example, if A v1.0.0 itself requires B v1.2.0 and C v1.0.0,\n-// then go.mod's requirement of B v1.0.0 is misleading (superseded by\n-// A's need for v1.2.0), and its requirement of C v1.0.0 is redundant\n-// (implied by A's need for the same version), so both will be removed.\n-// If module M contains packages that directly import packages from B or\n-// C, then the requirements will be kept but updated to the actual\n-// versions being used.\n-//\n-// Finally, the update reformats the go.mod in a canonical formatting, so\n-// that future mechanical changes will result in minimal diffs.\n-//\n-// Because the module graph defines the meaning of import statements, any\n-// commands that load packages also use and therefore update go.mod,\n-// including go build, go get, go install, go list, go test, go mod graph,\n-// go mod tidy, and go mod why.\n-//\n-// The expected language version, set by the go directive, determines\n-// which language features are available when compiling the module.\n-// Language features available in that version will be available for use.\n-// Language features removed in earlier versions, or added in later versions,\n-// will not be available. Note that the language version does not affect\n-// build tags, which are determined by the Go release being used.\n+// The go.mod file format is described in detail at\n+// https://golang.org/ref/mod#go-mod-file.\n+//\n+// To create a new go.mod file, use 'go help init'. For details see\n+// 'go help mod init' or https://golang.org/ref/mod#go-mod-init.\n+//\n+// To add missing module requirements or remove unneeded requirements,\n+// use 'go mod tidy'. For details, see 'go help mod tidy' or\n+// https://golang.org/ref/mod#go-mod-tidy.\n+//\n+// To add, upgrade, downgrade, or remove a specific module requirement, use\n+// 'go get'. For details, see 'go help module-get' or\n+// https://golang.org/ref/mod#go-get.\n+//\n+// To make other changes or to parse go.mod as JSON for use by other tools,\n+// use 'go mod edit'. See 'go help mod edit' or\n+// https://golang.org/ref/mod#go-mod-edit.\n //\n //\n // GOPATH environment variable\n@@ -2295,65 +2205,8 @@\n // a site serving from a fixed file system (including a file:/// URL)\n // can be a module proxy.\n //\n-// The GET requests sent to a Go module proxy are:\n-//\n-// GET $GOPROXY/<module>/@v/list returns a list of known versions of the given\n-// module, one per line.\n-//\n-// GET $GOPROXY/<module>/@v/<version>.info returns JSON-formatted metadata\n-// about that version of the given module.\n-//\n-// GET $GOPROXY/<module>/@v/<version>.mod returns the go.mod file\n-// for that version of the given module.\n-//\n-// GET $GOPROXY/<module>/@v/<version>.zip returns the zip archive\n-// for that version of the given module.\n-//\n-// GET $GOPROXY/<module>/@latest returns JSON-formatted metadata about the\n-// latest known version of the given module in the same format as\n-// <module>/@v/<version>.info. The latest version should be the version of\n-// the module the go command may use if <module>/@v/list is empty or no\n-// listed version is suitable. <module>/@latest is optional and may not\n-// be implemented by a module proxy.\n-//\n-// When resolving the latest version of a module, the go command will request\n-// <module>/@v/list, then, if no suitable versions are found, <module>/@latest.\n-// The go command prefers, in order: the semantically highest release version,\n-// the semantically highest pre-release version, and the chronologically\n-// most recent pseudo-version. In Go 1.12 and earlier, the go command considered\n-// pseudo-versions in <module>/@v/list to be pre-release versions, but this is\n-// no longer true since Go 1.13.\n-//\n-// To avoid problems when serving from case-sensitive file systems,\n-// the <module> and <version> elements are case-encoded, replacing every\n-// uppercase letter with an exclamation mark followed by the corresponding\n-// lower-case letter: github.com/Azure encodes as github.com/!azure.\n-//\n-// The JSON-formatted metadata about a given module corresponds to\n-// this Go data structure, which may be expanded in the future:\n-//\n-//     type Info struct {\n-//         Version string    // version string\n-//         Time    time.Time // commit time\n-//     }\n-//\n-// The zip archive for a specific version of a given module is a\n-// standard zip file that contains the file tree corresponding\n-// to the module's source code and related files. The archive uses\n-// slash-separated paths, and every file path in the archive must\n-// begin with <module>@<version>/, where the module and version are\n-// substituted directly, not case-encoded. The root of the module\n-// file tree corresponds to the <module>@<version>/ prefix in the\n-// archive.\n-//\n-// Even when downloading directly from version control systems,\n-// the go command synthesizes explicit info, mod, and zip files\n-// and stores them in its local cache, $GOPATH/pkg/mod/cache/download,\n-// the same as if it had downloaded them directly from a proxy.\n-// The cache layout is the same as the proxy URL space, so\n-// serving $GOPATH/pkg/mod/cache/download at (or copying it to)\n-// https://example.com/proxy would let other users access those\n-// cached module versions with GOPROXY=https://example.com/proxy.\n+// For details on the GOPROXY protocol, see\n+// https://golang.org/ref/mod#goproxy-protocol.\n //\n //\n // Import path syntax\n@@ -2504,7 +2357,7 @@\n // (See 'go help gopath-get' and 'go help gopath'.)\n //\n // When using modules, downloaded packages are stored in the module cache.\n-// (See 'go help module-get' and 'go help goproxy'.)\n+// See https://golang.org/ref/mod#module-cache.\n //\n // When using modules, an additional variant of the go-import meta tag is\n // recognized and is preferred over those listing version control systems.\n@@ -2514,7 +2367,8 @@\n //\n // This tag means to fetch modules with paths beginning with example.org\n // from the module proxy available at the URL https://code.org/moduleproxy.\n-// See 'go help goproxy' for details about the proxy protocol.\n+// See https://golang.org/ref/mod#goproxy-protocol for details about the\n+// proxy protocol.\n //\n // Import path checking\n //\n@@ -2545,483 +2399,28 @@\n //\n // Modules, module versions, and more\n //\n-// A module is a collection of related Go packages.\n-// Modules are the unit of source code interchange and versioning.\n-// The go command has direct support for working with modules,\n-// including recording and resolving dependencies on other modules.\n-// Modules replace the old GOPATH-based approach to specifying\n-// which source files are used in a given build.\n-//\n-// Module support\n-//\n-// The go command includes support for Go modules. Module-aware mode is active\n-// by default whenever a go.mod file is found in the current directory or in\n-// any parent directory.\n-//\n-// The quickest way to take advantage of module support is to check out your\n-// repository, create a go.mod file (described in the next section) there, and run\n-// go commands from within that file tree.\n-//\n-// For more fine-grained control, the go command continues to respect\n-// a temporary environment variable, GO111MODULE, which can be set to one\n-// of three string values: off, on, or auto (the default).\n-// If GO111MODULE=on, then the go command requires the use of modules,\n-// never consulting GOPATH. We refer to this as the command\n-// being module-aware or running in \"module-aware mode\".\n-// If GO111MODULE=off, then the go command never uses\n-// module support. Instead it looks in vendor directories and GOPATH\n-// to find dependencies; we now refer to this as \"GOPATH mode.\"\n-// If GO111MODULE=auto or is unset, then the go command enables or disables\n-// module support based on the current directory.\n-// Module support is enabled only when the current directory contains a\n-// go.mod file or is below a directory containing a go.mod file.\n-//\n-// In module-aware mode, GOPATH no longer defines the meaning of imports\n-// during a build, but it still stores downloaded dependencies (in GOPATH/pkg/mod)\n-// and installed commands (in GOPATH/bin, unless GOBIN is set).\n-//\n-// Defining a module\n-//\n-// A module is defined by a tree of Go source files with a go.mod file\n-// in the tree's root directory. The directory containing the go.mod file\n-// is called the module root. Typically the module root will also correspond\n-// to a source code repository root (but in general it need not).\n-// The module is the set of all Go packages in the module root and its\n-// subdirectories, but excluding subtrees with their own go.mod files.\n-//\n-// The \"module path\" is the import path prefix corresponding to the module root.\n-// The go.mod file defines the module path and lists the specific versions\n-// of other modules that should be used when resolving imports during a build,\n-// by giving their module paths and versions.\n-//\n-// For example, this go.mod declares that the directory containing it is the root\n-// of the module with path example.com/m, and it also declares that the module\n-// depends on specific versions of golang.org/x/text and gopkg.in/yaml.v2:\n-//\n-// \tmodule example.com/m\n-//\n-// \trequire (\n-// \t\tgolang.org/x/text v0.3.0\n-// \t\tgopkg.in/yaml.v2 v2.1.0\n-// \t)\n-//\n-// The go.mod file can also specify replacements and excluded versions\n-// that only apply when building the module directly; they are ignored\n-// when the module is incorporated into a larger build.\n-// For more about the go.mod file, see 'go help go.mod'.\n-//\n-// To start a new module, simply create a go.mod file in the root of the\n-// module's directory tree, containing only a module statement.\n-// The 'go mod init' command can be used to do this:\n-//\n-// \tgo mod init example.com/m\n-//\n-// In a project already using an existing dependency management tool like\n-// godep, glide, or dep, 'go mod init' will also add require statements\n-// matching the existing configuration.\n-//\n-// Once the go.mod file exists, no additional steps are required:\n-// go commands like 'go build', 'go test', or even 'go list' will automatically\n-// add new dependencies as needed to satisfy imports.\n-//\n-// The main module and the build list\n-//\n-// The \"main module\" is the module containing the directory where the go command\n-// is run. The go command finds the module root by looking for a go.mod in the\n-// current directory, or else the current directory's parent directory,\n-// or else the parent's parent directory, and so on.\n-//\n-// The main module's go.mod file defines the precise set of packages available\n-// for use by the go command, through require, replace, and exclude statements.\n-// Dependency modules, found by following require statements, also contribute\n-// to the definition of that set of packages, but only through their go.mod\n-// files' require statements: any replace and exclude statements in dependency\n-// modules are ignored. The replace and exclude statements therefore allow the\n-// main module complete control over its own build, without also being subject\n-// to complete control by dependencies.\n-//\n-// The set of modules providing packages to builds is called the \"build list\".\n-// The build list initially contains only the main module. Then the go command\n-// adds to the list the exact module versions required by modules already\n-// on the list, recursively, until there is nothing left to add to the list.\n-// If multiple versions of a particular module are added to the list,\n-// then at the end only the latest version (according to semantic version\n-// ordering) is kept for use in the build.\n-//\n-// The 'go list' command provides information about the main module\n-// and the build list. For example:\n-//\n-// \tgo list -m              # print path of main module\n-// \tgo list -m -f={{.Dir}}  # print root directory of main module\n-// \tgo list -m all          # print build list\n-//\n-// Maintaining module requirements\n-//\n-// The go.mod file is meant to be readable and editable by both programmers and\n-// tools. Most updates to dependencies can be performed using \"go get\" and\n-// \"go mod tidy\". Other module-aware build commands may be invoked using the\n-// -mod=mod flag to automatically add missing requirements and fix inconsistencies.\n-//\n-// The \"go get\" command updates go.mod to change the module versions used in a\n-// build. An upgrade of one module may imply upgrading others, and similarly a\n-// downgrade of one module may imply downgrading others. The \"go get\" command\n-// makes these implied changes as well. See \"go help module-get\".\n-//\n-// The \"go mod\" command provides other functionality for use in maintaining\n-// and understanding modules and go.mod files. See \"go help mod\", particularly\n-// \"go help mod tidy\" and \"go help mod edit\".\n-//\n-// As part of maintaining the require statements in go.mod, the go command\n-// tracks which ones provide packages imported directly by the current module\n-// and which ones provide packages only used indirectly by other module\n-// dependencies. Requirements needed only for indirect uses are marked with a\n-// \"// indirect\" comment in the go.mod file. Indirect requirements may be\n-// automatically removed from the go.mod file once they are implied by other\n-// direct requirements. Indirect requirements only arise when using modules\n-// that fail to state some of their own dependencies or when explicitly\n-// upgrading a module's dependencies ahead of its own stated requirements.\n-//\n-// The -mod build flag provides additional control over the updating and use of\n-// go.mod for commands that build packages like \"go build\" and \"go test\".\n-//\n-// If invoked with -mod=readonly (the default in most situations), the go command\n-// reports an error if a package named on the command line or an imported package\n-// is not provided by any module in the build list computed from the main module's\n-// requirements. The go command also reports an error if a module's checksum is\n-// missing from go.sum (see Module downloading and verification). Either go.mod or\n-// go.sum must be updated in these situations.\n-//\n-// If invoked with -mod=mod, the go command automatically updates go.mod and\n-// go.sum, fixing inconsistencies and adding missing requirements and checksums\n-// as needed. If the go command finds an unfamiliar import, it looks up the\n-// module containing that import and adds a requirement for the latest version\n-// of that module to go.mod. In most cases, therefore, one may add an import to\n-// source code and run \"go build\", \"go test\", or even \"go list\" with -mod=mod:\n-// as part of analyzing the package, the go command will resolve the import and\n-// update the go.mod file.\n-//\n-// If invoked with -mod=vendor, the go command loads packages from the main\n-// module's vendor directory instead of downloading modules to and loading packages\n-// from the module cache. The go command assumes the vendor directory holds\n-// correct copies of dependencies, and it does not compute the set of required\n-// module versions from go.mod files. However, the go command does check that\n-// vendor/modules.txt (generated by \"go mod vendor\") contains metadata consistent\n-// with go.mod.\n-//\n-// If the go command is not invoked with a -mod flag, and the vendor directory\n-// is present, and the \"go\" version in go.mod is 1.14 or higher, the go command\n-// will act as if it were invoked with -mod=vendor. Otherwise, the -mod flag\n-// defaults to -mod=readonly.\n-//\n-// Note that neither \"go get\" nor the \"go mod\" subcommands accept the -mod flag.\n-//\n-// Pseudo-versions\n-//\n-// The go.mod file and the go command more generally use semantic versions as\n-// the standard form for describing module versions, so that versions can be\n-// compared to determine which should be considered earlier or later than another.\n-// A module version like v1.2.3 is introduced by tagging a revision in the\n-// underlying source repository. Untagged revisions can be referred to\n-// using a \"pseudo-version\" like v0.0.0-yyyymmddhhmmss-abcdefabcdef,\n-// where the time is the commit time in UTC and the final suffix is the prefix\n-// of the commit hash. The time portion ensures that two pseudo-versions can\n-// be compared to determine which happened later, the commit hash identifes\n-// the underlying commit, and the prefix (v0.0.0- in this example) is derived from\n-// the most recent tagged version in the commit graph before this commit.\n-//\n-// There are three pseudo-version forms:\n-//\n-// vX.0.0-yyyymmddhhmmss-abcdefabcdef is used when there is no earlier\n-// versioned commit with an appropriate major version before the target commit.\n-// (This was originally the only form, so some older go.mod files use this form\n-// even for commits that do follow tags.)\n-//\n-// vX.Y.Z-pre.0.yyyymmddhhmmss-abcdefabcdef is used when the most\n-// recent versioned commit before the target commit is vX.Y.Z-pre.\n-//\n-// vX.Y.(Z+1)-0.yyyymmddhhmmss-abcdefabcdef is used when the most\n-// recent versioned commit before the target commit is vX.Y.Z.\n-//\n-// Pseudo-versions never need to be typed by hand: the go command will accept\n-// the plain commit hash and translate it into a pseudo-version (or a tagged\n-// version if available) automatically. This conversion is an example of a\n-// module query.\n-//\n-// Module queries\n-//\n-// The go command accepts a \"module query\" in place of a module version\n-// both on the command line and in the main module's go.mod file.\n-// (After evaluating a query found in the main module's go.mod file,\n-// the go command updates the file to replace the query with its result.)\n-//\n-// A fully-specified semantic version, such as \"v1.2.3\",\n-// evaluates to that specific version.\n-//\n-// A semantic version prefix, such as \"v1\" or \"v1.2\",\n-// evaluates to the latest available tagged version with that prefix.\n-//\n-// A semantic version comparison, such as \"<v1.2.3\" or \">=v1.5.6\",\n-// evaluates to the available tagged version nearest to the comparison target\n-// (the latest version for < and <=, the earliest version for > and >=).\n-//\n-// The string \"latest\" matches the latest available tagged version,\n-// or else the underlying source repository's latest untagged revision.\n-//\n-// The string \"upgrade\" is like \"latest\", but if the module is\n-// currently required at a later version than the version \"latest\"\n-// would select (for example, a newer pre-release version), \"upgrade\"\n-// will select the later version instead.\n-//\n-// The string \"patch\" matches the latest available tagged version\n-// of a module with the same major and minor version numbers as the\n-// currently required version. If no version is currently required,\n-// \"patch\" is equivalent to \"latest\".\n-//\n-// A revision identifier for the underlying source repository, such as\n-// a commit hash prefix, revision tag, or branch name, selects that\n-// specific code revision. If the revision is also tagged with a\n-// semantic version, the query evaluates to that semantic version.\n-// Otherwise the query evaluates to a pseudo-version for the commit.\n-// Note that branches and tags with names that are matched by other\n-// query syntax cannot be selected this way. For example, the query\n-// \"v2\" means the latest version starting with \"v2\", not the branch\n-// named \"v2\".\n-//\n-// All queries prefer release versions to pre-release versions.\n-// For example, \"<v1.2.3\" will prefer to return \"v1.2.2\"\n-// instead of \"v1.2.3-pre1\", even though \"v1.2.3-pre1\" is nearer\n-// to the comparison target.\n-//\n-// Module versions disallowed by exclude statements in the\n-// main module's go.mod are considered unavailable and cannot\n-// be returned by queries.\n-//\n-// For example, these commands are all valid:\n-//\n-// \tgo get github.com/gorilla/mux@latest    # same (@latest is default for 'go get')\n-// \tgo get github.com/gorilla/mux@v1.6.2    # records v1.6.2\n-// \tgo get github.com/gorilla/mux@e3702bed2 # records v1.6.2\n-// \tgo get github.com/gorilla/mux@c856192   # records v0.0.0-20180517173623-c85619274f5d\n-// \tgo get github.com/gorilla/mux@master    # records current meaning of master\n-//\n-// Module compatibility and semantic versioning\n-//\n-// The go command requires that modules use semantic versions and expects that\n-// the versions accurately describe compatibility: it assumes that v1.5.4 is a\n-// backwards-compatible replacement for v1.5.3, v1.4.0, and even v1.0.0.\n-// More generally the go command expects that packages follow the\n-// \"import compatibility rule\", which says:\n-//\n-// \"If an old package and a new package have the same import path,\n-// the new package must be backwards compatible with the old package.\"\n-//\n-// Because the go command assumes the import compatibility rule,\n-// a module definition can only set the minimum required version of one\n-// of its dependencies: it cannot set a maximum or exclude selected versions.\n-// Still, the import compatibility rule is not a guarantee: it may be that\n-// v1.5.4 is buggy and not a backwards-compatible replacement for v1.5.3.\n-// Because of this, the go command never updates from an older version\n-// to a newer version of a module unasked.\n-//\n-// In semantic versioning, changing the major version number indicates a lack\n-// of backwards compatibility with earlier versions. To preserve import\n-// compatibility, the go command requires that modules with major version v2\n-// or later use a module path with that major version as the final element.\n-// For example, version v2.0.0 of example.com/m must instead use module path\n-// example.com/m/v2, and packages in that module would use that path as\n-// their import path prefix, as in example.com/m/v2/sub/pkg. Including the\n-// major version number in the module path and import paths in this way is\n-// called \"semantic import versioning\". Pseudo-versions for modules with major\n-// version v2 and later begin with that major version instead of v0, as in\n-// v2.0.0-20180326061214-4fc5987536ef.\n-//\n-// As a special case, module paths beginning with gopkg.in/ continue to use the\n-// conventions established on that system: the major version is always present,\n-// and it is preceded by a dot instead of a slash: gopkg.in/yaml.v1\n-// and gopkg.in/yaml.v2, not gopkg.in/yaml and gopkg.in/yaml/v2.\n-//\n-// The go command treats modules with different module paths as unrelated:\n-// it makes no connection between example.com/m and example.com/m/v2.\n-// Modules with different major versions can be used together in a build\n-// and are kept separate by the fact that their packages use different\n-// import paths.\n-//\n-// In semantic versioning, major version v0 is for initial development,\n-// indicating no expectations of stability or backwards compatibility.\n-// Major version v0 does not appear in the module path, because those\n-// versions are preparation for v1.0.0, and v1 does not appear in the\n-// module path either.\n-//\n-// Code written before the semantic import versioning convention\n-// was introduced may use major versions v2 and later to describe\n-// the same set of unversioned import paths as used in v0 and v1.\n-// To accommodate such code, if a source code repository has a\n-// v2.0.0 or later tag for a file tree with no go.mod, the version is\n-// considered to be part of the v1 module's available versions\n-// and is given an +incompatible suffix when converted to a module\n-// version, as in v2.0.0+incompatible. The +incompatible tag is also\n-// applied to pseudo-versions derived from such versions, as in\n-// v2.0.1-0.yyyymmddhhmmss-abcdefabcdef+incompatible.\n-//\n-// In general, having a dependency in the build list (as reported by 'go list -m all')\n-// on a v0 version, pre-release version, pseudo-version, or +incompatible version\n-// is an indication that problems are more likely when upgrading that\n-// dependency, since there is no expectation of compatibility for those.\n-//\n-// See https://research.swtch.com/vgo-import for more information about\n-// semantic import versioning, and see https://semver.org/ for more about\n-// semantic versioning.\n-//\n-// Module code layout\n-//\n-// For now, see https://research.swtch.com/vgo-module for information\n-// about how source code in version control systems is mapped to\n-// module file trees.\n-//\n-// Module downloading and verification\n-//\n-// The go command can fetch modules from a proxy or connect to source control\n-// servers directly, according to the setting of the GOPROXY environment\n-// variable (see 'go help env'). The default setting for GOPROXY is\n-// \"https://proxy.golang.org,direct\", which means to try the\n-// Go module mirror run by Google and fall back to a direct connection\n-// if the proxy reports that it does not have the module (HTTP error 404 or 410).\n-// See https://proxy.golang.org/privacy for the service's privacy policy.\n-//\n-// If GOPROXY is set to the string \"direct\", downloads use a direct connection to\n-// source control servers. Setting GOPROXY to \"off\" disallows downloading modules\n-// from any source. Otherwise, GOPROXY is expected to be list of module proxy URLs\n-// separated by either comma (,) or pipe (|) characters, which control error\n-// fallback behavior. For each request, the go command tries each proxy in\n-// sequence. If there is an error, the go command will try the next proxy in the\n-// list if the error is a 404 or 410 HTTP response or if the current proxy is\n-// followed by a pipe character, indicating it is safe to fall back on any error.\n-//\n-// The GOPRIVATE and GONOPROXY environment variables allow bypassing\n-// the proxy for selected modules. See 'go help private' for details.\n-//\n-// No matter the source of the modules, the go command checks downloads against\n-// known checksums, to detect unexpected changes in the content of any specific\n-// module version from one day to the next. This check first consults the current\n-// module's go.sum file but falls back to the Go checksum database, controlled by\n-// the GOSUMDB and GONOSUMDB environment variables. See 'go help module-auth'\n-// for details.\n-//\n-// See 'go help goproxy' for details about the proxy protocol and also\n-// the format of the cached downloaded packages.\n-//\n-// Modules and vendoring\n-//\n-// When using modules, the go command typically satisfies dependencies by\n-// downloading modules from their sources and using those downloaded copies\n-// (after verification, as described in the previous section). Vendoring may\n-// be used to allow interoperation with older versions of Go, or to ensure\n-// that all files used for a build are stored together in a single file tree.\n-//\n-// The command 'go mod vendor' constructs a directory named vendor in the main\n-// module's root directory that contains copies of all packages needed to support\n-// builds and tests of packages in the main module. 'go mod vendor' also\n-// creates the file vendor/modules.txt that contains metadata about vendored\n-// packages and module versions. This file should be kept consistent with go.mod:\n-// when vendoring is used, 'go mod vendor' should be run after go.mod is updated.\n-//\n-// If the vendor directory is present in the main module's root directory, it will\n-// be used automatically if the \"go\" version in the main module's go.mod file is\n-// 1.14 or higher. Build commands like 'go build' and 'go test' will load packages\n-// from the vendor directory instead of accessing the network or the local module\n-// cache. To explicitly enable vendoring, invoke the go command with the flag\n-// -mod=vendor. To disable vendoring, use the flag -mod=mod.\n-//\n-// Unlike vendoring in GOPATH, the go command ignores vendor directories in\n-// locations other than the main module's root directory.\n+// Modules are how Go manages dependencies.\n+//\n+// A module is a collection of packages that are released, versioned, and\n+// distributed together. Modules may be downloaded directly from version control\n+// repositories or from module proxy servers.\n+//\n+// For a series of tutorials on modules, see\n+// https://golang.org/doc/tutorial/create-module.\n+//\n+// For a detailed reference on modules, see https://golang.org/ref/mod.\n //\n //\n // Module authentication using go.sum\n //\n-// The go command tries to authenticate every downloaded module,\n-// checking that the bits downloaded for a specific module version today\n-// match bits downloaded yesterday. This ensures repeatable builds\n-// and detects introduction of unexpected changes, malicious or not.\n-//\n-// In each module's root, alongside go.mod, the go command maintains\n-// a file named go.sum containing the cryptographic checksums of the\n-// module's dependencies.\n-//\n-// The form of each line in go.sum is three fields:\n-//\n-// \t<module> <version>[/go.mod] <hash>\n-//\n-// Each known module version results in two lines in the go.sum file.\n-// The first line gives the hash of the module version's file tree.\n-// The second line appends \"/go.mod\" to the version and gives the hash\n-// of only the module version's (possibly synthesized) go.mod file.\n-// The go.mod-only hash allows downloading and authenticating a\n-// module version's go.mod file, which is needed to compute the\n-// dependency graph, without also downloading all the module's source code.\n-//\n-// The hash begins with an algorithm prefix of the form \"h<N>:\".\n-// The only defined algorithm prefix is \"h1:\", which uses SHA-256.\n-//\n-// Module authentication failures\n-//\n-// The go command maintains a cache of downloaded packages and computes\n-// and records the cryptographic checksum of each package at download time.\n-// In normal operation, the go command checks the main module's go.sum file\n-// against these precomputed checksums instead of recomputing them on\n-// each command invocation. The 'go mod verify' command checks that\n-// the cached copies of module downloads still match both their recorded\n-// checksums and the entries in go.sum.\n-//\n-// In day-to-day development, the checksum of a given module version\n-// should never change. Each time a dependency is used by a given main\n-// module, the go command checks its local cached copy, freshly\n-// downloaded or not, against the main module's go.sum. If the checksums\n-// don't match, the go command reports the mismatch as a security error\n-// and refuses to run the build. When this happens, proceed with caution:\n-// code changing unexpectedly means today's build will not match\n-// yesterday's, and the unexpected change may not be beneficial.\n-//\n-// If the go command reports a mismatch in go.sum, the downloaded code\n-// for the reported module version does not match the one used in a\n-// previous build of the main module. It is important at that point\n-// to find out what the right checksum should be, to decide whether\n-// go.sum is wrong or the downloaded code is wrong. Usually go.sum is right:\n-// you want to use the same code you used yesterday.\n-//\n-// If a downloaded module is not yet included in go.sum and it is a publicly\n-// available module, the go command consults the Go checksum database to fetch\n-// the expected go.sum lines. If the downloaded code does not match those\n-// lines, the go command reports the mismatch and exits. Note that the\n-// database is not consulted for module versions already listed in go.sum.\n-//\n-// If a go.sum mismatch is reported, it is always worth investigating why\n-// the code downloaded today differs from what was downloaded yesterday.\n-//\n-// The GOSUMDB environment variable identifies the name of checksum database\n-// to use and optionally its public key and URL, as in:\n-//\n-// \tGOSUMDB=\"sum.golang.org\"\n-// \tGOSUMDB=\"sum.golang.org+<publickey>\"\n-// \tGOSUMDB=\"sum.golang.org+<publickey> https://sum.golang.org\"\n-//\n-// The go command knows the public key of sum.golang.org, and also that the name\n-// sum.golang.google.cn (available inside mainland China) connects to the\n-// sum.golang.org checksum database; use of any other database requires giving\n-// the public key explicitly.\n-// The URL defaults to \"https://\" followed by the database name.\n-//\n-// GOSUMDB defaults to \"sum.golang.org\", the Go checksum database run by Google.\n-// See https://sum.golang.org/privacy for the service's privacy policy.\n-//\n-// If GOSUMDB is set to \"off\", or if \"go get\" is invoked with the -insecure flag,\n-// the checksum database is not consulted, and all unrecognized modules are\n-// accepted, at the cost of giving up the security guarantee of verified repeatable\n-// downloads for all modules. A better way to bypass the checksum database\n-// for specific modules is to use the GOPRIVATE or GONOSUMDB environment\n-// variables. See 'go help private' for details.\n+// When the go command downloads a module zip file or go.mod file into the\n+// module cache, it computes a cryptographic hash and compares it with a known\n+// value to verify the file hasn't changed since it was first downloaded. Known\n+// hashes are stored in a file in the module root directory named go.sum. Hashes\n+// may also be downloaded from the checksum database depending on the values of\n+// GOSUMDB, GOPRIVATE, and GONOSUMDB.\n //\n-// The 'go env -w' command (see 'go help env') can be used to set these variables\n-// for future go command invocations.\n+// For details, see https://golang.org/ref/mod#authenticating.\n //\n //\n // Package lists and patterns\n@@ -3116,8 +2515,8 @@\n // These defaults work well for publicly available source code.\n //\n // The GOPRIVATE environment variable controls which modules the go command\n-// considers to be private (not available publicly) and should therefore not use the\n-// proxy or checksum database. The variable is a comma-separated list of\n+// considers to be private (not available publicly) and should therefore not use\n+// the proxy or checksum database. The variable is a comma-separated list of\n // glob patterns (in the syntax of Go's path.Match) of module path prefixes.\n // For example,\n //\n@@ -3127,10 +2526,6 @@\n // matching either pattern, including git.corp.example.com/xyzzy, rsc.io/private,\n // and rsc.io/private/quux.\n //\n-// The GOPRIVATE environment variable may be used by other tools as well to\n-// identify non-public modules. For example, an editor could use GOPRIVATE\n-// to decide whether to hyperlink a package import to a godoc.org page.\n-//\n // For fine-grained control over module download and validation, the GONOPROXY\n // and GONOSUMDB environment variables accept the same kind of glob list\n // and override GOPRIVATE for the specific decision of whether to use the proxy\n@@ -3143,12 +2538,6 @@\n // \tGOPROXY=proxy.example.com\n // \tGONOPROXY=none\n //\n-// This would tell the go command and other tools that modules beginning with\n-// a corp.example.com subdomain are private but that the company proxy should\n-// be used for downloading both public and private modules, because\n-// GONOPROXY has been set to a pattern that won't match any modules,\n-// overriding GOPRIVATE.\n-//\n // The GOPRIVATE variable is also used to define the \"public\" and \"private\"\n // patterns for the GOVCS variable; see 'go help vcs'. For that usage,\n // GOPRIVATE applies even in GOPATH mode. In that case, it matches import paths\n@@ -3157,6 +2546,8 @@\n // The 'go env -w' command (see 'go help env') can be used to set these variables\n // for future go command invocations.\n //\n+// For more details, see https://golang.org/ref/mod#private-modules.\n+//\n //\n // Testing flags\n //"}, {"sha": "3ce32388d05dd8785ed94e074b4dc1ef47a2c128", "filename": "libgo/go/cmd/go/go_test.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -216,6 +216,7 @@ func TestMain(m *testing.M) {\n \t}\n \t// Don't let these environment variables confuse the test.\n \tos.Setenv(\"GOENV\", \"off\")\n+\tos.Unsetenv(\"GOFLAGS\")\n \tos.Unsetenv(\"GOBIN\")\n \tos.Unsetenv(\"GOPATH\")\n \tos.Unsetenv(\"GIT_ALLOW_PROTOCOL\")\n@@ -2655,12 +2656,12 @@ func TestBadCommandLines(t *testing.T) {\n \ttg.tempFile(\"src/@x/x.go\", \"package x\\n\")\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n \ttg.runFail(\"build\", \"@x\")\n-\ttg.grepStderr(\"invalid input directory name \\\"@x\\\"|cannot use path@version syntax\", \"did not reject @x directory\")\n+\ttg.grepStderr(\"invalid input directory name \\\"@x\\\"|can only use path@version syntax with 'go get' and 'go install' in module-aware mode\", \"did not reject @x directory\")\n \n \ttg.tempFile(\"src/@x/y/y.go\", \"package y\\n\")\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n \ttg.runFail(\"build\", \"@x/y\")\n-\ttg.grepStderr(\"invalid import path \\\"@x/y\\\"|cannot use path@version syntax\", \"did not reject @x/y import path\")\n+\ttg.grepStderr(\"invalid import path \\\"@x/y\\\"|can only use path@version syntax with 'go get' and 'go install' in module-aware mode\", \"did not reject @x/y import path\")\n \n \ttg.tempFile(\"src/-x/x.go\", \"package x\\n\")\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))"}, {"sha": "954ce47a9899325014b4e99b5b6a1875a4120f30", "filename": "libgo/go/cmd/go/internal/base/base.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fbase.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fbase.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fbase.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -10,9 +10,9 @@ import (\n \t\"context\"\n \t\"flag\"\n \t\"fmt\"\n+\texec \"internal/execabs\"\n \t\"log\"\n \t\"os\"\n-\t\"os/exec\"\n \t\"strings\"\n \t\"sync\"\n "}, {"sha": "4aa08b4ff6ea7ab988daa86f3243b12948f0b64f", "filename": "libgo/go/cmd/go/internal/bug/bug.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbug%2Fbug.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbug%2Fbug.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbug%2Fbug.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -9,10 +9,10 @@ import (\n \t\"bytes\"\n \t\"context\"\n \t\"fmt\"\n+\texec \"internal/execabs\"\n \t\"io\"\n \turlpkg \"net/url\"\n \t\"os\"\n-\t\"os/exec\"\n \t\"path/filepath\"\n \t\"regexp\"\n \t\"runtime\""}, {"sha": "6b98f0ccd31865c937def4ac99b22597ca2b52e3", "filename": "libgo/go/cmd/go/internal/fmtcmd/fmt.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffmtcmd%2Ffmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffmtcmd%2Ffmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffmtcmd%2Ffmt.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -75,7 +75,8 @@ func runFmt(ctx context.Context, cmd *base.Command, args []string) {\n \t\t}\n \t\tif pkg.Error != nil {\n \t\t\tvar nogo *load.NoGoError\n-\t\t\tif errors.As(pkg.Error, &nogo) && len(pkg.InternalAllGoFiles()) > 0 {\n+\t\t\tvar embed *load.EmbedError\n+\t\t\tif (errors.As(pkg.Error, &nogo) || errors.As(pkg.Error, &embed)) && len(pkg.InternalAllGoFiles()) > 0 {\n \t\t\t\t// Skip this error, as we will format\n \t\t\t\t// all files regardless.\n \t\t\t} else {"}, {"sha": "a48311d51b09b7a2a356e1e567abfcaa1af60b7b", "filename": "libgo/go/cmd/go/internal/generate/generate.go", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -12,10 +12,10 @@ import (\n \t\"fmt\"\n \t\"go/parser\"\n \t\"go/token\"\n+\texec \"internal/execabs\"\n \t\"io\"\n \t\"log\"\n \t\"os\"\n-\t\"os/exec\"\n \t\"path/filepath\"\n \t\"regexp\"\n \t\"strconv\"\n@@ -52,15 +52,6 @@ that can be run locally. It must either be in the shell path\n (gofmt), a fully qualified path (/usr/you/bin/mytool), or a\n command alias, described below.\n \n-To convey to humans and machine tools that code is generated,\n-generated source should have a line that matches the following\n-regular expression (in Go syntax):\n-\n-\t^// Code generated .* DO NOT EDIT\\.$\n-\n-The line may appear anywhere in the file, but is typically\n-placed near the beginning so it is easy to find.\n-\n Note that go generate does not parse the file, so lines that look\n like directives in comments or multiline strings will be treated\n as directives.\n@@ -72,6 +63,15 @@ arguments when it is run.\n Quoted strings use Go syntax and are evaluated before execution; a\n quoted string appears as a single argument to the generator.\n \n+To convey to humans and machine tools that code is generated,\n+generated source should have a line that matches the following\n+regular expression (in Go syntax):\n+\n+\t^// Code generated .* DO NOT EDIT\\.$\n+\n+This line must appear before the first non-comment, non-blank\n+text in the file.\n+\n Go generate sets several variables when it runs the generator:\n \n \t$GOARCH"}, {"sha": "38ff3823f22b521f46682841e02564afd6de923d", "filename": "libgo/go/cmd/go/internal/get/get.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -202,7 +202,7 @@ func runGet(ctx context.Context, cmd *base.Command, args []string) {\n func downloadPaths(patterns []string) []string {\n \tfor _, arg := range patterns {\n \t\tif strings.Contains(arg, \"@\") {\n-\t\t\tbase.Fatalf(\"go: cannot use path@version syntax in GOPATH mode\")\n+\t\t\tbase.Fatalf(\"go: can only use path@version syntax with 'go get' and 'go install' in module-aware mode\")\n \t\t\tcontinue\n \t\t}\n "}, {"sha": "e07ad0e1db10b102d4f494016e049f179f5a65a1", "filename": "libgo/go/cmd/go/internal/help/helpdoc.go", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -266,7 +266,7 @@ listed in the GOPATH environment variable.\n (See 'go help gopath-get' and 'go help gopath'.)\n \n When using modules, downloaded packages are stored in the module cache.\n-(See 'go help module-get' and 'go help goproxy'.)\n+See https://golang.org/ref/mod#module-cache.\n \n When using modules, an additional variant of the go-import meta tag is\n recognized and is preferred over those listing version control systems.\n@@ -276,7 +276,8 @@ That variant uses \"mod\" as the vcs in the content value, as in:\n \n This tag means to fetch modules with paths beginning with example.org\n from the module proxy available at the URL https://code.org/moduleproxy.\n-See 'go help goproxy' for details about the proxy protocol.\n+See https://golang.org/ref/mod#goproxy-protocol for details about the\n+proxy protocol.\n \n Import path checking\n \n@@ -483,6 +484,10 @@ See 'go help env' for details.\n \n General-purpose environment variables:\n \n+\tGO111MODULE\n+\t\tControls whether the go command runs in module-aware mode or GOPATH mode.\n+\t\tMay be \"off\", \"on\", or \"auto\".\n+\t\tSee https://golang.org/ref/mod#mod-commands.\n \tGCCGO\n \t\tThe gccgo command to run for 'go build -compiler=gccgo'.\n \tGOARCH\n@@ -521,20 +526,24 @@ General-purpose environment variables:\n \tGOPATH\n \t\tFor more details see: 'go help gopath'.\n \tGOPROXY\n-\t\tURL of Go module proxy. See 'go help modules'.\n+\t\tURL of Go module proxy. See https://golang.org/ref/mod#environment-variables\n+\t\tand https://golang.org/ref/mod#module-proxy for details.\n \tGOPRIVATE, GONOPROXY, GONOSUMDB\n \t\tComma-separated list of glob patterns (in the syntax of Go's path.Match)\n \t\tof module path prefixes that should always be fetched directly\n \t\tor that should not be compared against the checksum database.\n-\t\tSee 'go help private'.\n+\t\tSee https://golang.org/ref/mod#private-modules.\n \tGOROOT\n \t\tThe root of the go tree.\n \tGOSUMDB\n \t\tThe name of checksum database to use and optionally its public key and\n-\t\tURL. See 'go help module-auth'.\n+\t\tURL. See https://golang.org/ref/mod#authenticating.\n \tGOTMPDIR\n \t\tThe directory where the go command will write\n \t\ttemporary source files, packages, and binaries.\n+\tGOVCS\n+\t  Lists version control commands that may be used with matching servers.\n+\t\tSee 'go help vcs'.\n \n Environment variables for use with cgo:\n "}, {"sha": "b4d82d9f8ccc97cb4e9400b15774958d4b4ce921", "filename": "libgo/go/cmd/go/internal/list/list.go", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -89,6 +89,14 @@ to -f '{{.ImportPath}}'. The struct being passed to the template is:\n         TestGoFiles     []string   // _test.go files in package\n         XTestGoFiles    []string   // _test.go files outside package\n \n+        // Embedded files\n+        EmbedPatterns      []string // //go:embed patterns\n+        EmbedFiles         []string // files matched by EmbedPatterns\n+        TestEmbedPatterns  []string // //go:embed patterns in TestGoFiles\n+        TestEmbedFiles     []string // files matched by TestEmbedPatterns\n+        XTestEmbedPatterns []string // //go:embed patterns in XTestGoFiles\n+        XTestEmbedFiles    []string // files matched by XTestEmbedPatterns\n+\n         // Cgo directives\n         CgoCFLAGS    []string // cgo: flags for C compiler\n         CgoCPPFLAGS  []string // cgo: flags for C preprocessor\n@@ -300,7 +308,7 @@ For more about build flags, see 'go help build'.\n \n For more about specifying packages, see 'go help packages'.\n \n-For more about modules, see 'go help modules'.\n+For more about modules, see https://golang.org/ref/mod.\n \t`,\n }\n \n@@ -577,8 +585,6 @@ func runList(ctx context.Context, cmd *base.Command, args []string) {\n \t\t// Show vendor-expanded paths in listing\n \t\tp.TestImports = p.Resolve(p.TestImports)\n \t\tp.XTestImports = p.Resolve(p.XTestImports)\n-\t\tp.TestEmbedFiles = p.ResolveEmbed(p.TestEmbedPatterns)\n-\t\tp.XTestEmbedFiles = p.ResolveEmbed(p.XTestEmbedPatterns)\n \t\tp.DepOnly = !cmdline[p]\n \n \t\tif *listCompiled {"}, {"sha": "8757d666fb234b4bb5af717a68eca7527e0404dd", "filename": "libgo/go/cmd/go/internal/load/pkg.go", "status": "modified", "additions": 85, "deletions": 49, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -96,7 +96,7 @@ type PackagePublic struct {\n \n \t// Embedded files\n \tEmbedPatterns []string `json:\",omitempty\"` // //go:embed patterns\n-\tEmbedFiles    []string `json:\",omitempty\"` // files and directories matched by EmbedPatterns\n+\tEmbedFiles    []string `json:\",omitempty\"` // files matched by EmbedPatterns\n \n \t// Cgo directives\n \tCgoCFLAGS    []string `json:\",omitempty\"` // cgo: flags for C compiler\n@@ -122,11 +122,11 @@ type PackagePublic struct {\n \tTestGoFiles        []string `json:\",omitempty\"` // _test.go files in package\n \tTestImports        []string `json:\",omitempty\"` // imports from TestGoFiles\n \tTestEmbedPatterns  []string `json:\",omitempty\"` // //go:embed patterns\n-\tTestEmbedFiles     []string `json:\",omitempty\"` // //files matched by EmbedPatterns\n+\tTestEmbedFiles     []string `json:\",omitempty\"` // files matched by TestEmbedPatterns\n \tXTestGoFiles       []string `json:\",omitempty\"` // _test.go files outside package\n \tXTestImports       []string `json:\",omitempty\"` // imports from XTestGoFiles\n \tXTestEmbedPatterns []string `json:\",omitempty\"` // //go:embed patterns\n-\tXTestEmbedFiles    []string `json:\",omitempty\"` // //files matched by EmbedPatterns\n+\tXTestEmbedFiles    []string `json:\",omitempty\"` // files matched by XTestEmbedPatterns\n }\n \n // AllFiles returns the names of all the files considered for the package.\n@@ -304,7 +304,7 @@ func (p *Package) setLoadPackageDataError(err error, path string, stk *ImportSta\n \t}\n \n \tif path != stk.Top() {\n-\t\tp = setErrorPos(p, importPos)\n+\t\tp.Error.setPos(importPos)\n \t}\n }\n \n@@ -412,6 +412,9 @@ type PackageError struct {\n }\n \n func (p *PackageError) Error() string {\n+\t// TODO(#43696): decide when to print the stack or the position based on\n+\t// the error type and whether the package is in the main module.\n+\t// Document the rationale.\n \tif p.Pos != \"\" && (len(p.ImportStack) == 0 || !p.alwaysPrintStack) {\n \t\t// Omit import stack. The full path to the file where the error\n \t\t// is the most important thing.\n@@ -447,6 +450,15 @@ func (p *PackageError) MarshalJSON() ([]byte, error) {\n \treturn json.Marshal(perr)\n }\n \n+func (p *PackageError) setPos(posList []token.Position) {\n+\tif len(posList) == 0 {\n+\t\treturn\n+\t}\n+\tpos := posList[0]\n+\tpos.Filename = base.ShortPath(pos.Filename)\n+\tp.Pos = pos.String()\n+}\n+\n // ImportPathError is a type of error that prevents a package from being loaded\n // for a given import path. When such a package is loaded, a *Package is\n // returned with Err wrapping an ImportPathError: the error is attached to\n@@ -695,17 +707,19 @@ func loadImport(ctx context.Context, pre *preload, path, srcDir string, parent *\n \t\t\t\tErr:         ImportErrorf(path, \"non-canonical import path %q: should be %q\", path, pathpkg.Clean(path)),\n \t\t\t}\n \t\t\tp.Incomplete = true\n-\t\t\tsetErrorPos(p, importPos)\n+\t\t\tp.Error.setPos(importPos)\n \t\t}\n \t}\n \n \t// Checked on every import because the rules depend on the code doing the importing.\n \tif perr := disallowInternal(srcDir, parent, parentPath, p, stk); perr != p {\n-\t\treturn setErrorPos(perr, importPos)\n+\t\tperr.Error.setPos(importPos)\n+\t\treturn perr\n \t}\n \tif mode&ResolveImport != 0 {\n \t\tif perr := disallowVendor(srcDir, path, parentPath, p, stk); perr != p {\n-\t\t\treturn setErrorPos(perr, importPos)\n+\t\t\tperr.Error.setPos(importPos)\n+\t\t\treturn perr\n \t\t}\n \t}\n \n@@ -715,7 +729,8 @@ func loadImport(ctx context.Context, pre *preload, path, srcDir string, parent *\n \t\t\tImportStack: stk.Copy(),\n \t\t\tErr:         ImportErrorf(path, \"import %q is a program, not an importable package\", path),\n \t\t}\n-\t\treturn setErrorPos(&perr, importPos)\n+\t\tperr.Error.setPos(importPos)\n+\t\treturn &perr\n \t}\n \n \tif p.Internal.Local && parent != nil && !parent.Internal.Local {\n@@ -730,21 +745,13 @@ func loadImport(ctx context.Context, pre *preload, path, srcDir string, parent *\n \t\t\tImportStack: stk.Copy(),\n \t\t\tErr:         err,\n \t\t}\n-\t\treturn setErrorPos(&perr, importPos)\n+\t\tperr.Error.setPos(importPos)\n+\t\treturn &perr\n \t}\n \n \treturn p\n }\n \n-func setErrorPos(p *Package, importPos []token.Position) *Package {\n-\tif len(importPos) > 0 {\n-\t\tpos := importPos[0]\n-\t\tpos.Filename = base.ShortPath(pos.Filename)\n-\t\tp.Error.Pos = pos.String()\n-\t}\n-\treturn p\n-}\n-\n // loadPackageData loads information needed to construct a *Package. The result\n // is cached, and later calls to loadPackageData for the same package will return\n // the same data.\n@@ -769,11 +776,7 @@ func loadPackageData(path, parentPath, parentDir, parentRoot string, parentIsStd\n \t}\n \n \tif strings.Contains(path, \"@\") {\n-\t\tif cfg.ModulesEnabled {\n-\t\t\treturn nil, false, errors.New(\"can only use path@version syntax with 'go get'\")\n-\t\t} else {\n-\t\t\treturn nil, false, errors.New(\"cannot use path@version syntax in GOPATH mode\")\n-\t\t}\n+\t\treturn nil, false, errors.New(\"can only use path@version syntax with 'go get' and 'go install' in module-aware mode\")\n \t}\n \n \t// Determine canonical package path and directory.\n@@ -1659,7 +1662,7 @@ func (p *Package) load(ctx context.Context, path string, stk *ImportStack, impor\n \t\t\t// must be either in an explicit command-line argument,\n \t\t\t// or on the importer side (indicated by a non-empty importPos).\n \t\t\tif path != stk.Top() && len(importPos) > 0 {\n-\t\t\t\tp = setErrorPos(p, importPos)\n+\t\t\t\tp.Error.setPos(importPos)\n \t\t\t}\n \t\t}\n \t}\n@@ -1669,11 +1672,6 @@ func (p *Package) load(ctx context.Context, path string, stk *ImportStack, impor\n \t\tp.setLoadPackageDataError(err, path, stk, importPos)\n \t}\n \n-\tp.EmbedFiles, p.Internal.Embed, err = p.resolveEmbed(p.EmbedPatterns)\n-\tif err != nil {\n-\t\tsetError(err)\n-\t}\n-\n \tuseBindir := p.Name == \"main\"\n \tif !p.Standard {\n \t\tswitch cfg.BuildBuildmode {\n@@ -1809,9 +1807,20 @@ func (p *Package) load(ctx context.Context, path string, stk *ImportStack, impor\n \t\treturn\n \t}\n \n+\t// Errors after this point are caused by this package, not the importing\n+\t// package. Pushing the path here prevents us from reporting the error\n+\t// with the position of the import declaration.\n \tstk.Push(path)\n \tdefer stk.Pop()\n \n+\tp.EmbedFiles, p.Internal.Embed, err = resolveEmbed(p.Dir, p.EmbedPatterns)\n+\tif err != nil {\n+\t\tp.Incomplete = true\n+\t\tsetError(err)\n+\t\tembedErr := err.(*EmbedError)\n+\t\tp.Error.setPos(p.Internal.Build.EmbedPatternPos[embedErr.Pattern])\n+\t}\n+\n \t// Check for case-insensitive collision of input files.\n \t// To avoid problems on case-insensitive files, we reject any package\n \t// where two different input files have equal names under a case-insensitive\n@@ -1915,35 +1924,62 @@ func (p *Package) load(ctx context.Context, path string, stk *ImportStack, impor\n \t}\n }\n \n+// An EmbedError indicates a problem with a go:embed directive.\n+type EmbedError struct {\n+\tPattern string\n+\tErr     error\n+}\n+\n+func (e *EmbedError) Error() string {\n+\treturn fmt.Sprintf(\"pattern %s: %v\", e.Pattern, e.Err)\n+}\n+\n+func (e *EmbedError) Unwrap() error {\n+\treturn e.Err\n+}\n+\n // ResolveEmbed resolves //go:embed patterns and returns only the file list.\n-// For use by go list to compute p.TestEmbedFiles and p.XTestEmbedFiles.\n-func (p *Package) ResolveEmbed(patterns []string) []string {\n-\tfiles, _, _ := p.resolveEmbed(patterns)\n-\treturn files\n+// For use by go mod vendor to find embedded files it should copy into the\n+// vendor directory.\n+// TODO(#42504): Once go mod vendor uses load.PackagesAndErrors, just\n+// call (*Package).ResolveEmbed\n+func ResolveEmbed(dir string, patterns []string) ([]string, error) {\n+\tfiles, _, err := resolveEmbed(dir, patterns)\n+\treturn files, err\n }\n \n // resolveEmbed resolves //go:embed patterns to precise file lists.\n // It sets files to the list of unique files matched (for go list),\n // and it sets pmap to the more precise mapping from\n // patterns to files.\n-// TODO(rsc): All these messages need position information for better error reports.\n-func (p *Package) resolveEmbed(patterns []string) (files []string, pmap map[string][]string, err error) {\n+func resolveEmbed(pkgdir string, patterns []string) (files []string, pmap map[string][]string, err error) {\n+\tvar pattern string\n+\tdefer func() {\n+\t\tif err != nil {\n+\t\t\terr = &EmbedError{\n+\t\t\t\tPattern: pattern,\n+\t\t\t\tErr:     err,\n+\t\t\t}\n+\t\t}\n+\t}()\n+\n+\t// TODO(rsc): All these messages need position information for better error reports.\n \tpmap = make(map[string][]string)\n \thave := make(map[string]int)\n \tdirOK := make(map[string]bool)\n \tpid := 0 // pattern ID, to allow reuse of have map\n-\tfor _, pattern := range patterns {\n+\tfor _, pattern = range patterns {\n \t\tpid++\n \n \t\t// Check pattern is valid for //go:embed.\n \t\tif _, err := path.Match(pattern, \"\"); err != nil || !validEmbedPattern(pattern) {\n-\t\t\treturn nil, nil, fmt.Errorf(\"pattern %s: invalid pattern syntax\", pattern)\n+\t\t\treturn nil, nil, fmt.Errorf(\"invalid pattern syntax\")\n \t\t}\n \n \t\t// Glob to find matches.\n-\t\tmatch, err := fsys.Glob(p.Dir + string(filepath.Separator) + filepath.FromSlash(pattern))\n+\t\tmatch, err := fsys.Glob(pkgdir + string(filepath.Separator) + filepath.FromSlash(pattern))\n \t\tif err != nil {\n-\t\t\treturn nil, nil, fmt.Errorf(\"pattern %s: %v\", pattern, err)\n+\t\t\treturn nil, nil, err\n \t\t}\n \n \t\t// Filter list of matches down to the ones that will still exist when\n@@ -1952,7 +1988,7 @@ func (p *Package) resolveEmbed(patterns []string) (files []string, pmap map[stri\n \t\t// then there may be other things lying around, like symbolic links or .git directories.)\n \t\tvar list []string\n \t\tfor _, file := range match {\n-\t\t\trel := filepath.ToSlash(file[len(p.Dir)+1:]) // file, relative to p.Dir\n+\t\t\trel := filepath.ToSlash(file[len(pkgdir)+1:]) // file, relative to p.Dir\n \n \t\t\twhat := \"file\"\n \t\t\tinfo, err := fsys.Lstat(file)\n@@ -1965,28 +2001,28 @@ func (p *Package) resolveEmbed(patterns []string) (files []string, pmap map[stri\n \n \t\t\t// Check that directories along path do not begin a new module\n \t\t\t// (do not contain a go.mod).\n-\t\t\tfor dir := file; len(dir) > len(p.Dir)+1 && !dirOK[dir]; dir = filepath.Dir(dir) {\n+\t\t\tfor dir := file; len(dir) > len(pkgdir)+1 && !dirOK[dir]; dir = filepath.Dir(dir) {\n \t\t\t\tif _, err := fsys.Stat(filepath.Join(dir, \"go.mod\")); err == nil {\n-\t\t\t\t\treturn nil, nil, fmt.Errorf(\"pattern %s: cannot embed %s %s: in different module\", pattern, what, rel)\n+\t\t\t\t\treturn nil, nil, fmt.Errorf(\"cannot embed %s %s: in different module\", what, rel)\n \t\t\t\t}\n \t\t\t\tif dir != file {\n \t\t\t\t\tif info, err := fsys.Lstat(dir); err == nil && !info.IsDir() {\n-\t\t\t\t\t\treturn nil, nil, fmt.Errorf(\"pattern %s: cannot embed %s %s: in non-directory %s\", pattern, what, rel, dir[len(p.Dir)+1:])\n+\t\t\t\t\t\treturn nil, nil, fmt.Errorf(\"cannot embed %s %s: in non-directory %s\", what, rel, dir[len(pkgdir)+1:])\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tdirOK[dir] = true\n \t\t\t\tif elem := filepath.Base(dir); isBadEmbedName(elem) {\n \t\t\t\t\tif dir == file {\n-\t\t\t\t\t\treturn nil, nil, fmt.Errorf(\"pattern %s: cannot embed %s %s: invalid name %s\", pattern, what, rel, elem)\n+\t\t\t\t\t\treturn nil, nil, fmt.Errorf(\"cannot embed %s %s: invalid name %s\", what, rel, elem)\n \t\t\t\t\t} else {\n-\t\t\t\t\t\treturn nil, nil, fmt.Errorf(\"pattern %s: cannot embed %s %s: in invalid directory %s\", pattern, what, rel, elem)\n+\t\t\t\t\t\treturn nil, nil, fmt.Errorf(\"cannot embed %s %s: in invalid directory %s\", what, rel, elem)\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tswitch {\n \t\t\tdefault:\n-\t\t\t\treturn nil, nil, fmt.Errorf(\"pattern %s: cannot embed irregular file %s\", pattern, rel)\n+\t\t\t\treturn nil, nil, fmt.Errorf(\"cannot embed irregular file %s\", rel)\n \n \t\t\tcase info.Mode().IsRegular():\n \t\t\t\tif have[rel] != pid {\n@@ -2002,7 +2038,7 @@ func (p *Package) resolveEmbed(patterns []string) (files []string, pmap map[stri\n \t\t\t\t\tif err != nil {\n \t\t\t\t\t\treturn err\n \t\t\t\t\t}\n-\t\t\t\t\trel := filepath.ToSlash(path[len(p.Dir)+1:])\n+\t\t\t\t\trel := filepath.ToSlash(path[len(pkgdir)+1:])\n \t\t\t\t\tname := info.Name()\n \t\t\t\t\tif path != file && (isBadEmbedName(name) || name[0] == '.' || name[0] == '_') {\n \t\t\t\t\t\t// Ignore bad names, assuming they won't go into modules.\n@@ -2033,13 +2069,13 @@ func (p *Package) resolveEmbed(patterns []string) (files []string, pmap map[stri\n \t\t\t\t\treturn nil, nil, err\n \t\t\t\t}\n \t\t\t\tif count == 0 {\n-\t\t\t\t\treturn nil, nil, fmt.Errorf(\"pattern %s: cannot embed directory %s: contains no embeddable files\", pattern, rel)\n+\t\t\t\t\treturn nil, nil, fmt.Errorf(\"cannot embed directory %s: contains no embeddable files\", rel)\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif len(list) == 0 {\n-\t\t\treturn nil, nil, fmt.Errorf(\"pattern %s: no matching files found\", pattern)\n+\t\t\treturn nil, nil, fmt.Errorf(\"no matching files found\")\n \t\t}\n \t\tsort.Strings(list)\n \t\tpmap[pattern] = list"}, {"sha": "eb8aef3ee28126d289e39a91f57ca285051e339e", "filename": "libgo/go/cmd/go/internal/load/test.go", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -124,12 +124,14 @@ func TestPackagesAndErrors(ctx context.Context, p *Package, cover *TestCover) (p\n \t\timports = append(imports, p1)\n \t}\n \tvar err error\n-\tp.TestEmbedFiles, testEmbed, err = p.resolveEmbed(p.TestEmbedPatterns)\n+\tp.TestEmbedFiles, testEmbed, err = resolveEmbed(p.Dir, p.TestEmbedPatterns)\n \tif err != nil && ptestErr == nil {\n \t\tptestErr = &PackageError{\n \t\t\tImportStack: stk.Copy(),\n \t\t\tErr:         err,\n \t\t}\n+\t\tembedErr := err.(*EmbedError)\n+\t\tptestErr.setPos(p.Internal.Build.TestEmbedPatternPos[embedErr.Pattern])\n \t}\n \tstk.Pop()\n \n@@ -145,12 +147,14 @@ func TestPackagesAndErrors(ctx context.Context, p *Package, cover *TestCover) (p\n \t\t}\n \t\tp.XTestImports[i] = p1.ImportPath\n \t}\n-\tp.XTestEmbedFiles, xtestEmbed, err = p.resolveEmbed(p.XTestEmbedPatterns)\n+\tp.XTestEmbedFiles, xtestEmbed, err = resolveEmbed(p.Dir, p.XTestEmbedPatterns)\n \tif err != nil && pxtestErr == nil {\n \t\tpxtestErr = &PackageError{\n \t\t\tImportStack: stk.Copy(),\n \t\t\tErr:         err,\n \t\t}\n+\t\tembedErr := err.(*EmbedError)\n+\t\tpxtestErr.setPos(p.Internal.Build.XTestEmbedPatternPos[embedErr.Pattern])\n \t}\n \tstk.Pop()\n "}, {"sha": "e7d3d869cbcf0e0de5d951979f746565c18191ce", "filename": "libgo/go/cmd/go/internal/modcmd/download.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -52,7 +52,9 @@ corresponding to this Go struct:\n \n The -x flag causes download to print the commands download executes.\n \n-See 'go help modules' for more about module queries.\n+See https://golang.org/ref/mod#go-mod-download for more about 'go mod download'.\n+\n+See https://golang.org/ref/mod#version-queries for more about version queries.\n \t`,\n }\n "}, {"sha": "1df104eb1dd54954a9670c5ee86a3372a2417067", "filename": "libgo/go/cmd/go/internal/modcmd/edit.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fedit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fedit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fedit.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -95,6 +95,7 @@ writing it back to go.mod. The JSON output corresponds to these Go types:\n \t\tRequire []Require\n \t\tExclude []Module\n \t\tReplace []Replace\n+\t\tRetract []Retract\n \t}\n \n \ttype Require struct {\n@@ -121,9 +122,7 @@ Note that this only describes the go.mod file itself, not other modules\n referred to indirectly. For the full set of modules available to a build,\n use 'go list -m -json all'.\n \n-For example, a tool can obtain the go.mod as a data structure by\n-parsing the output of 'go mod edit -json' and can then make changes\n-by invoking 'go mod edit' with -require, -exclude, and so on.\n+See https://golang.org/ref/mod#go-mod-edit for more about 'go mod edit'.\n \t`,\n }\n "}, {"sha": "a88e9ef4557ad3459cfe9db87f8af3fc63b2f591", "filename": "libgo/go/cmd/go/internal/modcmd/graph.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fgraph.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fgraph.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fgraph.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -26,6 +26,8 @@ Graph prints the module requirement graph (with replacements applied)\n in text form. Each line in the output has two space-separated fields: a module\n and one of its requirements. Each module is identified as a string of the form\n path@version, except for the main module, which has no @version suffix.\n+\n+See https://golang.org/ref/mod#go-mod-graph for more about 'go mod graph'.\n \t`,\n \tRun: runGraph,\n }"}, {"sha": "73cc282d81408a18dee2f405891fbc68813a7dc0", "filename": "libgo/go/cmd/go/internal/modcmd/init.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Finit.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -27,6 +27,8 @@ Gopkg.lock), and the current directory (if in GOPATH).\n \n If a configuration file for a vendoring tool is present, init will attempt to\n import module requirements from it.\n+\n+See https://golang.org/ref/mod#go-mod-init for more about 'go mod init'.\n `,\n \tRun: runInit,\n }"}, {"sha": "3b83d87a8eb6fecf5693a49891c33fdf16bb672f", "filename": "libgo/go/cmd/go/internal/modcmd/tidy.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Ftidy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Ftidy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Ftidy.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -29,6 +29,8 @@ to standard error.\n \n The -e flag causes tidy to attempt to proceed despite errors\n encountered while loading packages.\n+\n+See https://golang.org/ref/mod#go-mod-tidy for more about 'go mod tidy'.\n \t`,\n \tRun: runTidy,\n }"}, {"sha": "d3ed9e00e229a2021c4d7a4c3ea8a544d0ad654f", "filename": "libgo/go/cmd/go/internal/modcmd/vendor.go", "status": "modified", "additions": 72, "deletions": 6, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fvendor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fvendor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fvendor.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -7,7 +7,9 @@ package modcmd\n import (\n \t\"bytes\"\n \t\"context\"\n+\t\"errors\"\n \t\"fmt\"\n+\t\"go/build\"\n \t\"io\"\n \t\"io/fs\"\n \t\"os\"\n@@ -19,7 +21,9 @@ import (\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/fsys\"\n \t\"cmd/go/internal/imports\"\n+\t\"cmd/go/internal/load\"\n \t\"cmd/go/internal/modload\"\n+\t\"cmd/go/internal/str\"\n \n \t\"golang.org/x/mod/module\"\n \t\"golang.org/x/mod/semver\"\n@@ -38,6 +42,8 @@ modules and packages to standard error.\n \n The -e flag causes vendor to attempt to proceed despite errors\n encountered while loading packages.\n+\n+See https://golang.org/ref/mod#go-mod-vendor for more about 'go mod vendor'.\n \t`,\n \tRun: runVendor,\n }\n@@ -180,19 +186,76 @@ func moduleLine(m, r module.Version) string {\n }\n \n func vendorPkg(vdir, pkg string) {\n+\t// TODO(#42504): Instead of calling modload.ImportMap then build.ImportDir,\n+\t// just call load.PackagesAndErrors. To do that, we need to add a good way\n+\t// to ignore build constraints.\n \trealPath := modload.ImportMap(pkg)\n \tif realPath != pkg && modload.ImportMap(realPath) != \"\" {\n \t\tfmt.Fprintf(os.Stderr, \"warning: %s imported as both %s and %s; making two copies.\\n\", realPath, realPath, pkg)\n \t}\n \n+\tcopiedFiles := make(map[string]bool)\n \tdst := filepath.Join(vdir, pkg)\n \tsrc := modload.PackageDir(realPath)\n \tif src == \"\" {\n \t\tfmt.Fprintf(os.Stderr, \"internal error: no pkg for %s -> %s\\n\", pkg, realPath)\n \t}\n-\tcopyDir(dst, src, matchPotentialSourceFile)\n+\tcopyDir(dst, src, matchPotentialSourceFile, copiedFiles)\n \tif m := modload.PackageModule(realPath); m.Path != \"\" {\n-\t\tcopyMetadata(m.Path, realPath, dst, src)\n+\t\tcopyMetadata(m.Path, realPath, dst, src, copiedFiles)\n+\t}\n+\n+\tctx := build.Default\n+\tctx.UseAllFiles = true\n+\tbp, err := ctx.ImportDir(src, build.IgnoreVendor)\n+\t// Because UseAllFiles is set on the build.Context, it's possible ta get\n+\t// a MultiplePackageError on an otherwise valid package: the package could\n+\t// have different names for GOOS=windows and GOOS=mac for example. On the\n+\t// other hand if there's a NoGoError, the package might have source files\n+\t// specifying \"// +build ignore\" those packages should be skipped because\n+\t// embeds from ignored files can't be used.\n+\t// TODO(#42504): Find a better way to avoid errors from ImportDir. We'll\n+\t// need to figure this out when we switch to PackagesAndErrors as per the\n+\t// TODO above.\n+\tvar multiplePackageError *build.MultiplePackageError\n+\tvar noGoError *build.NoGoError\n+\tif err != nil {\n+\t\tif errors.As(err, &noGoError) {\n+\t\t\treturn // No source files in this package are built. Skip embeds in ignored files.\n+\t\t} else if !errors.As(err, &multiplePackageError) { // multiplePackgeErrors are okay, but others are not.\n+\t\t\tbase.Fatalf(\"internal error: failed to find embedded files of %s: %v\\n\", pkg, err)\n+\t\t}\n+\t}\n+\tembedPatterns := str.StringList(bp.EmbedPatterns, bp.TestEmbedPatterns, bp.XTestEmbedPatterns)\n+\tembeds, err := load.ResolveEmbed(bp.Dir, embedPatterns)\n+\tif err != nil {\n+\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n+\t}\n+\tfor _, embed := range embeds {\n+\t\tembedDst := filepath.Join(dst, embed)\n+\t\tif copiedFiles[embedDst] {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Copy the file as is done by copyDir below.\n+\t\tr, err := os.Open(filepath.Join(src, embed))\n+\t\tif err != nil {\n+\t\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n+\t\t}\n+\t\tif err := os.MkdirAll(filepath.Dir(embedDst), 0777); err != nil {\n+\t\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n+\t\t}\n+\t\tw, err := os.Create(embedDst)\n+\t\tif err != nil {\n+\t\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n+\t\t}\n+\t\tif _, err := io.Copy(w, r); err != nil {\n+\t\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n+\t\t}\n+\t\tr.Close()\n+\t\tif err := w.Close(); err != nil {\n+\t\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n+\t\t}\n \t}\n }\n \n@@ -205,14 +268,14 @@ var copiedMetadata = make(map[metakey]bool)\n \n // copyMetadata copies metadata files from parents of src to parents of dst,\n // stopping after processing the src parent for modPath.\n-func copyMetadata(modPath, pkg, dst, src string) {\n+func copyMetadata(modPath, pkg, dst, src string, copiedFiles map[string]bool) {\n \tfor parent := 0; ; parent++ {\n \t\tif copiedMetadata[metakey{modPath, dst}] {\n \t\t\tbreak\n \t\t}\n \t\tcopiedMetadata[metakey{modPath, dst}] = true\n \t\tif parent > 0 {\n-\t\t\tcopyDir(dst, src, matchMetadata)\n+\t\t\tcopyDir(dst, src, matchMetadata, copiedFiles)\n \t\t}\n \t\tif modPath == pkg {\n \t\t\tbreak\n@@ -280,7 +343,7 @@ func matchPotentialSourceFile(dir string, info fs.DirEntry) bool {\n }\n \n // copyDir copies all regular files satisfying match(info) from src to dst.\n-func copyDir(dst, src string, match func(dir string, info fs.DirEntry) bool) {\n+func copyDir(dst, src string, match func(dir string, info fs.DirEntry) bool, copiedFiles map[string]bool) {\n \tfiles, err := os.ReadDir(src)\n \tif err != nil {\n \t\tbase.Fatalf(\"go mod vendor: %v\", err)\n@@ -292,11 +355,14 @@ func copyDir(dst, src string, match func(dir string, info fs.DirEntry) bool) {\n \t\tif file.IsDir() || !file.Type().IsRegular() || !match(src, file) {\n \t\t\tcontinue\n \t\t}\n+\t\tcopiedFiles[file.Name()] = true\n \t\tr, err := os.Open(filepath.Join(src, file.Name()))\n \t\tif err != nil {\n \t\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n \t\t}\n-\t\tw, err := os.Create(filepath.Join(dst, file.Name()))\n+\t\tdstPath := filepath.Join(dst, file.Name())\n+\t\tcopiedFiles[dstPath] = true\n+\t\tw, err := os.Create(dstPath)\n \t\tif err != nil {\n \t\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n \t\t}"}, {"sha": "832142913108976469a87a5ec4688b1ce9ae611a", "filename": "libgo/go/cmd/go/internal/modcmd/verify.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fverify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fverify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fverify.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -31,6 +31,8 @@ modified since being downloaded. If all the modules are unmodified,\n verify prints \"all modules verified.\" Otherwise it reports which\n modules have been changed and causes 'go mod' to exit with a\n non-zero status.\n+\n+See https://golang.org/ref/mod#go-mod-verify for more about 'go mod verify'.\n \t`,\n \tRun: runVerify,\n }"}, {"sha": "a5f3e8afcbe3a52072e7265eecb7e117f9dabc78", "filename": "libgo/go/cmd/go/internal/modcmd/why.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fwhy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fwhy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fwhy.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -48,6 +48,8 @@ For example:\n \t# golang.org/x/text/encoding\n \t(main module does not need package golang.org/x/text/encoding)\n \t$\n+\n+See https://golang.org/ref/mod#go-mod-why for more about 'go mod why'.\n \t`,\n }\n "}, {"sha": "378fbae34f9530378ced67a8298f797891af9e72", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/codehost.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fcodehost.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fcodehost.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fcodehost.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -10,10 +10,10 @@ import (\n \t\"bytes\"\n \t\"crypto/sha256\"\n \t\"fmt\"\n+\texec \"internal/execabs\"\n \t\"io\"\n \t\"io/fs\"\n \t\"os\"\n-\t\"os/exec\"\n \t\"path/filepath\"\n \t\"strings\"\n \t\"sync\""}, {"sha": "72005e27d5eb83e75d56053dae51e64eb8ea63c8", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/git.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -8,11 +8,11 @@ import (\n \t\"bytes\"\n \t\"errors\"\n \t\"fmt\"\n+\texec \"internal/execabs\"\n \t\"io\"\n \t\"io/fs\"\n \t\"net/url\"\n \t\"os\"\n-\t\"os/exec\"\n \t\"path/filepath\"\n \t\"sort\"\n \t\"strconv\""}, {"sha": "c55c3cf2534bfe116f3005231b002e56e6959a0f", "filename": "libgo/go/cmd/go/internal/modfetch/fetch.go", "status": "modified", "additions": 12, "deletions": 96, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -768,90 +768,14 @@ var HelpModuleAuth = &base.Command{\n \tUsageLine: \"module-auth\",\n \tShort:     \"module authentication using go.sum\",\n \tLong: `\n-The go command tries to authenticate every downloaded module,\n-checking that the bits downloaded for a specific module version today\n-match bits downloaded yesterday. This ensures repeatable builds\n-and detects introduction of unexpected changes, malicious or not.\n-\n-In each module's root, alongside go.mod, the go command maintains\n-a file named go.sum containing the cryptographic checksums of the\n-module's dependencies.\n-\n-The form of each line in go.sum is three fields:\n-\n-\t<module> <version>[/go.mod] <hash>\n-\n-Each known module version results in two lines in the go.sum file.\n-The first line gives the hash of the module version's file tree.\n-The second line appends \"/go.mod\" to the version and gives the hash\n-of only the module version's (possibly synthesized) go.mod file.\n-The go.mod-only hash allows downloading and authenticating a\n-module version's go.mod file, which is needed to compute the\n-dependency graph, without also downloading all the module's source code.\n-\n-The hash begins with an algorithm prefix of the form \"h<N>:\".\n-The only defined algorithm prefix is \"h1:\", which uses SHA-256.\n-\n-Module authentication failures\n-\n-The go command maintains a cache of downloaded packages and computes\n-and records the cryptographic checksum of each package at download time.\n-In normal operation, the go command checks the main module's go.sum file\n-against these precomputed checksums instead of recomputing them on\n-each command invocation. The 'go mod verify' command checks that\n-the cached copies of module downloads still match both their recorded\n-checksums and the entries in go.sum.\n-\n-In day-to-day development, the checksum of a given module version\n-should never change. Each time a dependency is used by a given main\n-module, the go command checks its local cached copy, freshly\n-downloaded or not, against the main module's go.sum. If the checksums\n-don't match, the go command reports the mismatch as a security error\n-and refuses to run the build. When this happens, proceed with caution:\n-code changing unexpectedly means today's build will not match\n-yesterday's, and the unexpected change may not be beneficial.\n-\n-If the go command reports a mismatch in go.sum, the downloaded code\n-for the reported module version does not match the one used in a\n-previous build of the main module. It is important at that point\n-to find out what the right checksum should be, to decide whether\n-go.sum is wrong or the downloaded code is wrong. Usually go.sum is right:\n-you want to use the same code you used yesterday.\n-\n-If a downloaded module is not yet included in go.sum and it is a publicly\n-available module, the go command consults the Go checksum database to fetch\n-the expected go.sum lines. If the downloaded code does not match those\n-lines, the go command reports the mismatch and exits. Note that the\n-database is not consulted for module versions already listed in go.sum.\n-\n-If a go.sum mismatch is reported, it is always worth investigating why\n-the code downloaded today differs from what was downloaded yesterday.\n-\n-The GOSUMDB environment variable identifies the name of checksum database\n-to use and optionally its public key and URL, as in:\n-\n-\tGOSUMDB=\"sum.golang.org\"\n-\tGOSUMDB=\"sum.golang.org+<publickey>\"\n-\tGOSUMDB=\"sum.golang.org+<publickey> https://sum.golang.org\"\n-\n-The go command knows the public key of sum.golang.org, and also that the name\n-sum.golang.google.cn (available inside mainland China) connects to the\n-sum.golang.org checksum database; use of any other database requires giving\n-the public key explicitly.\n-The URL defaults to \"https://\" followed by the database name.\n-\n-GOSUMDB defaults to \"sum.golang.org\", the Go checksum database run by Google.\n-See https://sum.golang.org/privacy for the service's privacy policy.\n-\n-If GOSUMDB is set to \"off\", or if \"go get\" is invoked with the -insecure flag,\n-the checksum database is not consulted, and all unrecognized modules are\n-accepted, at the cost of giving up the security guarantee of verified repeatable\n-downloads for all modules. A better way to bypass the checksum database\n-for specific modules is to use the GOPRIVATE or GONOSUMDB environment\n-variables. See 'go help private' for details.\n-\n-The 'go env -w' command (see 'go help env') can be used to set these variables\n-for future go command invocations.\n+When the go command downloads a module zip file or go.mod file into the\n+module cache, it computes a cryptographic hash and compares it with a known\n+value to verify the file hasn't changed since it was first downloaded. Known\n+hashes are stored in a file in the module root directory named go.sum. Hashes\n+may also be downloaded from the checksum database depending on the values of\n+GOSUMDB, GOPRIVATE, and GONOSUMDB.\n+\n+For details, see https://golang.org/ref/mod#authenticating.\n `,\n }\n \n@@ -865,8 +789,8 @@ regardless of source, against the public Go checksum database at sum.golang.org.\n These defaults work well for publicly available source code.\n \n The GOPRIVATE environment variable controls which modules the go command\n-considers to be private (not available publicly) and should therefore not use the\n-proxy or checksum database. The variable is a comma-separated list of\n+considers to be private (not available publicly) and should therefore not use\n+the proxy or checksum database. The variable is a comma-separated list of\n glob patterns (in the syntax of Go's path.Match) of module path prefixes.\n For example,\n \n@@ -876,10 +800,6 @@ causes the go command to treat as private any module with a path prefix\n matching either pattern, including git.corp.example.com/xyzzy, rsc.io/private,\n and rsc.io/private/quux.\n \n-The GOPRIVATE environment variable may be used by other tools as well to\n-identify non-public modules. For example, an editor could use GOPRIVATE\n-to decide whether to hyperlink a package import to a godoc.org page.\n-\n For fine-grained control over module download and validation, the GONOPROXY\n and GONOSUMDB environment variables accept the same kind of glob list\n and override GOPRIVATE for the specific decision of whether to use the proxy\n@@ -892,18 +812,14 @@ users would configure go using:\n \tGOPROXY=proxy.example.com\n \tGONOPROXY=none\n \n-This would tell the go command and other tools that modules beginning with\n-a corp.example.com subdomain are private but that the company proxy should\n-be used for downloading both public and private modules, because\n-GONOPROXY has been set to a pattern that won't match any modules,\n-overriding GOPRIVATE.\n-\n The GOPRIVATE variable is also used to define the \"public\" and \"private\"\n patterns for the GOVCS variable; see 'go help vcs'. For that usage,\n GOPRIVATE applies even in GOPATH mode. In that case, it matches import paths\n instead of module paths.\n \n The 'go env -w' command (see 'go help env') can be used to set these variables\n for future go command invocations.\n+\n+For more details, see https://golang.org/ref/mod#private-modules.\n `,\n }"}, {"sha": "6c86d8d786d94a161f509a66fffcfbc9bb00189c", "filename": "libgo/go/cmd/go/internal/modfetch/proxy.go", "status": "modified", "additions": 2, "deletions": 59, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fproxy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fproxy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fproxy.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -36,65 +36,8 @@ URLs of a specified form. The requests have no query parameters, so even\n a site serving from a fixed file system (including a file:/// URL)\n can be a module proxy.\n \n-The GET requests sent to a Go module proxy are:\n-\n-GET $GOPROXY/<module>/@v/list returns a list of known versions of the given\n-module, one per line.\n-\n-GET $GOPROXY/<module>/@v/<version>.info returns JSON-formatted metadata\n-about that version of the given module.\n-\n-GET $GOPROXY/<module>/@v/<version>.mod returns the go.mod file\n-for that version of the given module.\n-\n-GET $GOPROXY/<module>/@v/<version>.zip returns the zip archive\n-for that version of the given module.\n-\n-GET $GOPROXY/<module>/@latest returns JSON-formatted metadata about the\n-latest known version of the given module in the same format as\n-<module>/@v/<version>.info. The latest version should be the version of\n-the module the go command may use if <module>/@v/list is empty or no\n-listed version is suitable. <module>/@latest is optional and may not\n-be implemented by a module proxy.\n-\n-When resolving the latest version of a module, the go command will request\n-<module>/@v/list, then, if no suitable versions are found, <module>/@latest.\n-The go command prefers, in order: the semantically highest release version,\n-the semantically highest pre-release version, and the chronologically\n-most recent pseudo-version. In Go 1.12 and earlier, the go command considered\n-pseudo-versions in <module>/@v/list to be pre-release versions, but this is\n-no longer true since Go 1.13.\n-\n-To avoid problems when serving from case-sensitive file systems,\n-the <module> and <version> elements are case-encoded, replacing every\n-uppercase letter with an exclamation mark followed by the corresponding\n-lower-case letter: github.com/Azure encodes as github.com/!azure.\n-\n-The JSON-formatted metadata about a given module corresponds to\n-this Go data structure, which may be expanded in the future:\n-\n-    type Info struct {\n-        Version string    // version string\n-        Time    time.Time // commit time\n-    }\n-\n-The zip archive for a specific version of a given module is a\n-standard zip file that contains the file tree corresponding\n-to the module's source code and related files. The archive uses\n-slash-separated paths, and every file path in the archive must\n-begin with <module>@<version>/, where the module and version are\n-substituted directly, not case-encoded. The root of the module\n-file tree corresponds to the <module>@<version>/ prefix in the\n-archive.\n-\n-Even when downloading directly from version control systems,\n-the go command synthesizes explicit info, mod, and zip files\n-and stores them in its local cache, $GOPATH/pkg/mod/cache/download,\n-the same as if it had downloaded them directly from a proxy.\n-The cache layout is the same as the proxy URL space, so\n-serving $GOPATH/pkg/mod/cache/download at (or copying it to)\n-https://example.com/proxy would let other users access those\n-cached module versions with GOPROXY=https://example.com/proxy.\n+For details on the GOPROXY protocol, see\n+https://golang.org/ref/mod#goproxy-protocol.\n `,\n }\n "}, {"sha": "574f3e194d168ed6c2cda6c9d2a64b2cd2fb98ed", "filename": "libgo/go/cmd/go/internal/modget/get.go", "status": "modified", "additions": 35, "deletions": 92, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fget.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fget.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fget.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -56,85 +56,49 @@ var CmdGet = &base.Command{\n \tUsageLine: \"go get [-d] [-t] [-u] [-v] [-insecure] [build flags] [packages]\",\n \tShort:     \"add dependencies to current module and install them\",\n \tLong: `\n-Get resolves and adds dependencies to the current development module\n-and then builds and installs them.\n-\n-The first step is to resolve which dependencies to add.\n-\n-For each named package or package pattern, get must decide which version of\n-the corresponding module to use. By default, get looks up the latest tagged\n-release version, such as v0.4.5 or v1.2.3. If there are no tagged release\n-versions, get looks up the latest tagged pre-release version, such as\n-v0.0.1-pre1. If there are no tagged versions at all, get looks up the latest\n-known commit. If the module is not already required at a later version\n-(for example, a pre-release newer than the latest release), get will use\n-the version it looked up. Otherwise, get will use the currently\n-required version.\n-\n-This default version selection can be overridden by adding an @version\n-suffix to the package argument, as in 'go get golang.org/x/text@v0.3.0'.\n-The version may be a prefix: @v1 denotes the latest available version starting\n-with v1. See 'go help modules' under the heading 'Module queries' for the\n-full query syntax.\n-\n-For modules stored in source control repositories, the version suffix can\n-also be a commit hash, branch identifier, or other syntax known to the\n-source control system, as in 'go get golang.org/x/text@master'. Note that\n-branches with names that overlap with other module query syntax cannot be\n-selected explicitly. For example, the suffix @v2 means the latest version\n-starting with v2, not the branch named v2.\n-\n-If a module under consideration is already a dependency of the current\n-development module, then get will update the required version.\n-Specifying a version earlier than the current required version is valid and\n-downgrades the dependency. The version suffix @none indicates that the\n-dependency should be removed entirely, downgrading or removing modules\n-depending on it as needed.\n-\n-The version suffix @latest explicitly requests the latest minor release of\n-the module named by the given path. The suffix @upgrade is like @latest but\n-will not downgrade a module if it is already required at a revision or\n-pre-release version newer than the latest released version. The suffix\n-@patch requests the latest patch release: the latest released version\n-with the same major and minor version numbers as the currently required\n-version. Like @upgrade, @patch will not downgrade a module already required\n-at a newer version. If the path is not already required, @upgrade is\n-equivalent to @latest, and @patch is disallowed.\n-\n-Although get defaults to using the latest version of the module containing\n-a named package, it does not use the latest version of that module's\n-dependencies. Instead it prefers to use the specific dependency versions\n-requested by that module. For example, if the latest A requires module\n-B v1.2.3, while B v1.2.4 and v1.3.1 are also available, then 'go get A'\n-will use the latest A but then use B v1.2.3, as requested by A. (If there\n-are competing requirements for a particular module, then 'go get' resolves\n-those requirements by taking the maximum requested version.)\n+Get resolves its command-line arguments to packages at specific module versions,\n+updates go.mod to require those versions, downloads source code into the\n+module cache, then builds and installs the named packages.\n+\n+To add a dependency for a package or upgrade it to its latest version:\n+\n+\tgo get example.com/pkg\n+\n+To upgrade or downgrade a package to a specific version:\n+\n+\tgo get example.com/pkg@v1.2.3\n+\n+To remove a dependency on a module and downgrade modules that require it:\n+\n+\tgo get example.com/mod@none\n+\n+See https://golang.org/ref/mod#go-get for details.\n+\n+The 'go install' command may be used to build and install packages. When a\n+version is specified, 'go install' runs in module-aware mode and ignores\n+the go.mod file in the current directory. For example:\n+\n+\tgo install example.com/pkg@v1.2.3\n+\tgo install example.com/pkg@latest\n+\n+See 'go help install' or https://golang.org/ref/mod#go-install for details.\n+\n+In addition to build flags (listed in 'go help build') 'go get' accepts the\n+following flags.\n \n The -t flag instructs get to consider modules needed to build tests of\n packages specified on the command line.\n \n The -u flag instructs get to update modules providing dependencies\n of packages named on the command line to use newer minor or patch\n-releases when available. Continuing the previous example, 'go get -u A'\n-will use the latest A with B v1.3.1 (not B v1.2.3). If B requires module C,\n-but C does not provide any packages needed to build packages in A\n-(not including tests), then C will not be updated.\n+releases when available.\n \n The -u=patch flag (not -u patch) also instructs get to update dependencies,\n but changes the default to select patch releases.\n-Continuing the previous example,\n-'go get -u=patch A@latest' will use the latest A with B v1.2.4 (not B v1.2.3),\n-while 'go get -u=patch A' will use a patch release of A instead.\n \n When the -t and -u flags are used together, get will update\n test dependencies as well.\n \n-In general, adding a new dependency may require upgrading\n-existing dependencies to keep a working build, and 'go get' does\n-this automatically. Similarly, downgrading one dependency may\n-require downgrading other dependencies, and 'go get' does\n-this automatically as well.\n-\n The -insecure flag permits fetching from repositories and resolving\n custom domains using insecure schemes such as HTTP, and also bypassess\n module sum validation using the checksum database. Use with caution.\n@@ -143,12 +107,8 @@ To permit the use of insecure schemes, use the GOINSECURE environment\n variable instead. To bypass module sum validation, use GOPRIVATE or\n GONOSUMDB. See 'go help environment' for details.\n \n-The second step is to download (if needed), build, and install\n-the named packages.\n-\n-The -d flag instructs get to skip this step, downloading source code\n-needed to build the named packages and their dependencies, but not\n-building or installing.\n+The -d flag instructs get not to build or install packages. get will only\n+update go.mod and download source code needed to build packages.\n \n Building and installing packages with get is deprecated. In a future release,\n the -d flag will be enabled by default, and 'go get' will be only be used to\n@@ -157,31 +117,14 @@ dependencies from the current module, use 'go install'. To install a package\n ignoring the current module, use 'go install' with an @version suffix like\n \"@latest\" after each argument.\n \n-If an argument names a module but not a package (because there is no\n-Go source code in the module's root directory), then the install step\n-is skipped for that argument, instead of causing a build failure.\n-For example 'go get golang.org/x/perf' succeeds even though there\n-is no code corresponding to that import path.\n-\n-Note that package patterns are allowed and are expanded after resolving\n-the module versions. For example, 'go get golang.org/x/perf/cmd/...'\n-adds the latest golang.org/x/perf and then installs the commands in that\n-latest version.\n-\n-With no package arguments, 'go get' applies to Go package in the\n-current directory, if any. In particular, 'go get -u' and\n-'go get -u=patch' update all the dependencies of that package.\n-With no package arguments and also without -u, 'go get' is not much more\n-than 'go install', and 'go get -d' not much more than 'go list'.\n-\n-For more about modules, see 'go help modules'.\n+For more about modules, see https://golang.org/ref/mod.\n \n For more about specifying packages, see 'go help packages'.\n \n This text describes the behavior of get using modules to manage source\n code and dependencies. If instead the go command is running in GOPATH\n mode, the details of get's flags and effects change, as does 'go help get'.\n-See 'go help modules' and 'go help gopath-get'.\n+See 'go help gopath-get'.\n \n See also: go build, go install, go clean, go mod.\n \t`,\n@@ -1558,7 +1501,7 @@ func (r *resolver) checkPackagesAndRetractions(ctx context.Context, pkgPatterns\n \t\t}\n \t}\n \tif retractPath != \"\" {\n-\t\tfmt.Fprintf(os.Stderr, \"go: run 'go get %s@latest' to switch to the latest unretracted version\\n\", retractPath)\n+\t\tfmt.Fprintf(os.Stderr, \"go: to switch to the latest unretracted version, run:\\n\\tgo get %s@latest\", retractPath)\n \t}\n }\n "}, {"sha": "d8364c8c0d3a3cac5c96105770632961e83a4b4b", "filename": "libgo/go/cmd/go/internal/modget/query.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fquery.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fquery.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fquery.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -281,14 +281,14 @@ func reportError(q *query, err error) {\n \t// TODO(bcmills): Use errors.As to unpack these errors instead of parsing\n \t// strings with regular expressions.\n \n-\tpatternRE := regexp.MustCompile(\"(?m)(?:[ \\t(\\\"`]|^)\" + regexp.QuoteMeta(q.pattern) + \"(?:[ @:)\\\"`]|$)\")\n+\tpatternRE := regexp.MustCompile(\"(?m)(?:[ \\t(\\\"`]|^)\" + regexp.QuoteMeta(q.pattern) + \"(?:[ @:;)\\\"`]|$)\")\n \tif patternRE.MatchString(errStr) {\n \t\tif q.rawVersion == \"\" {\n \t\t\tbase.Errorf(\"go get: %s\", errStr)\n \t\t\treturn\n \t\t}\n \n-\t\tversionRE := regexp.MustCompile(\"(?m)(?:[ @(\\\"`]|^)\" + regexp.QuoteMeta(q.version) + \"(?:[ :)\\\"`]|$)\")\n+\t\tversionRE := regexp.MustCompile(\"(?m)(?:[ @(\\\"`]|^)\" + regexp.QuoteMeta(q.version) + \"(?:[ :;)\\\"`]|$)\")\n \t\tif versionRE.MatchString(errStr) {\n \t\t\tbase.Errorf(\"go get: %s\", errStr)\n \t\t\treturn"}, {"sha": "45f220a6ee6946b510a6bb67cb06b21971d31576", "filename": "libgo/go/cmd/go/internal/modload/buildlist.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuildlist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuildlist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuildlist.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -28,6 +28,11 @@ import (\n //\n var buildList []module.Version\n \n+// additionalExplicitRequirements is a list of modules paths for which\n+// WriteGoMod should record explicit requirements, even if they would be\n+// selected without those requirements. Each path must also appear in buildList.\n+var additionalExplicitRequirements []string\n+\n // capVersionSlice returns s with its cap reduced to its length.\n func capVersionSlice(s []module.Version) []module.Version {\n \treturn s[:len(s):len(s)]\n@@ -121,6 +126,12 @@ func EditBuildList(ctx context.Context, add, mustSelect []module.Version) error\n \n \tif !inconsistent {\n \t\tbuildList = final\n+\t\tadditionalExplicitRequirements = make([]string, 0, len(mustSelect))\n+\t\tfor _, m := range mustSelect {\n+\t\t\tif m.Version != \"none\" {\n+\t\t\t\tadditionalExplicitRequirements = append(additionalExplicitRequirements, m.Path)\n+\t\t\t}\n+\t\t}\n \t\treturn nil\n \t}\n "}, {"sha": "1cb58961bed43f6bffd61fbe6f65bea18ced9b7c", "filename": "libgo/go/cmd/go/internal/modload/help.go", "status": "modified", "additions": 20, "deletions": 464, "changes": 484, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -12,395 +12,16 @@ var HelpModules = &base.Command{\n \tUsageLine: \"modules\",\n \tShort:     \"modules, module versions, and more\",\n \tLong: `\n-A module is a collection of related Go packages.\n-Modules are the unit of source code interchange and versioning.\n-The go command has direct support for working with modules,\n-including recording and resolving dependencies on other modules.\n-Modules replace the old GOPATH-based approach to specifying\n-which source files are used in a given build.\n+Modules are how Go manages dependencies.\n \n-Module support\n+A module is a collection of packages that are released, versioned, and\n+distributed together. Modules may be downloaded directly from version control\n+repositories or from module proxy servers.\n \n-The go command includes support for Go modules. Module-aware mode is active\n-by default whenever a go.mod file is found in the current directory or in\n-any parent directory.\n+For a series of tutorials on modules, see\n+https://golang.org/doc/tutorial/create-module.\n \n-The quickest way to take advantage of module support is to check out your\n-repository, create a go.mod file (described in the next section) there, and run\n-go commands from within that file tree.\n-\n-For more fine-grained control, the go command continues to respect\n-a temporary environment variable, GO111MODULE, which can be set to one\n-of three string values: off, on, or auto (the default).\n-If GO111MODULE=on, then the go command requires the use of modules,\n-never consulting GOPATH. We refer to this as the command\n-being module-aware or running in \"module-aware mode\".\n-If GO111MODULE=off, then the go command never uses\n-module support. Instead it looks in vendor directories and GOPATH\n-to find dependencies; we now refer to this as \"GOPATH mode.\"\n-If GO111MODULE=auto or is unset, then the go command enables or disables\n-module support based on the current directory.\n-Module support is enabled only when the current directory contains a\n-go.mod file or is below a directory containing a go.mod file.\n-\n-In module-aware mode, GOPATH no longer defines the meaning of imports\n-during a build, but it still stores downloaded dependencies (in GOPATH/pkg/mod)\n-and installed commands (in GOPATH/bin, unless GOBIN is set).\n-\n-Defining a module\n-\n-A module is defined by a tree of Go source files with a go.mod file\n-in the tree's root directory. The directory containing the go.mod file\n-is called the module root. Typically the module root will also correspond\n-to a source code repository root (but in general it need not).\n-The module is the set of all Go packages in the module root and its\n-subdirectories, but excluding subtrees with their own go.mod files.\n-\n-The \"module path\" is the import path prefix corresponding to the module root.\n-The go.mod file defines the module path and lists the specific versions\n-of other modules that should be used when resolving imports during a build,\n-by giving their module paths and versions.\n-\n-For example, this go.mod declares that the directory containing it is the root\n-of the module with path example.com/m, and it also declares that the module\n-depends on specific versions of golang.org/x/text and gopkg.in/yaml.v2:\n-\n-\tmodule example.com/m\n-\n-\trequire (\n-\t\tgolang.org/x/text v0.3.0\n-\t\tgopkg.in/yaml.v2 v2.1.0\n-\t)\n-\n-The go.mod file can also specify replacements and excluded versions\n-that only apply when building the module directly; they are ignored\n-when the module is incorporated into a larger build.\n-For more about the go.mod file, see 'go help go.mod'.\n-\n-To start a new module, simply create a go.mod file in the root of the\n-module's directory tree, containing only a module statement.\n-The 'go mod init' command can be used to do this:\n-\n-\tgo mod init example.com/m\n-\n-In a project already using an existing dependency management tool like\n-godep, glide, or dep, 'go mod init' will also add require statements\n-matching the existing configuration.\n-\n-Once the go.mod file exists, no additional steps are required:\n-go commands like 'go build', 'go test', or even 'go list' will automatically\n-add new dependencies as needed to satisfy imports.\n-\n-The main module and the build list\n-\n-The \"main module\" is the module containing the directory where the go command\n-is run. The go command finds the module root by looking for a go.mod in the\n-current directory, or else the current directory's parent directory,\n-or else the parent's parent directory, and so on.\n-\n-The main module's go.mod file defines the precise set of packages available\n-for use by the go command, through require, replace, and exclude statements.\n-Dependency modules, found by following require statements, also contribute\n-to the definition of that set of packages, but only through their go.mod\n-files' require statements: any replace and exclude statements in dependency\n-modules are ignored. The replace and exclude statements therefore allow the\n-main module complete control over its own build, without also being subject\n-to complete control by dependencies.\n-\n-The set of modules providing packages to builds is called the \"build list\".\n-The build list initially contains only the main module. Then the go command\n-adds to the list the exact module versions required by modules already\n-on the list, recursively, until there is nothing left to add to the list.\n-If multiple versions of a particular module are added to the list,\n-then at the end only the latest version (according to semantic version\n-ordering) is kept for use in the build.\n-\n-The 'go list' command provides information about the main module\n-and the build list. For example:\n-\n-\tgo list -m              # print path of main module\n-\tgo list -m -f={{.Dir}}  # print root directory of main module\n-\tgo list -m all          # print build list\n-\n-Maintaining module requirements\n-\n-The go.mod file is meant to be readable and editable by both programmers and\n-tools. Most updates to dependencies can be performed using \"go get\" and\n-\"go mod tidy\". Other module-aware build commands may be invoked using the\n--mod=mod flag to automatically add missing requirements and fix inconsistencies.\n-\n-The \"go get\" command updates go.mod to change the module versions used in a\n-build. An upgrade of one module may imply upgrading others, and similarly a\n-downgrade of one module may imply downgrading others. The \"go get\" command\n-makes these implied changes as well. See \"go help module-get\".\n-\n-The \"go mod\" command provides other functionality for use in maintaining\n-and understanding modules and go.mod files. See \"go help mod\", particularly\n-\"go help mod tidy\" and \"go help mod edit\".\n-\n-As part of maintaining the require statements in go.mod, the go command\n-tracks which ones provide packages imported directly by the current module\n-and which ones provide packages only used indirectly by other module\n-dependencies. Requirements needed only for indirect uses are marked with a\n-\"// indirect\" comment in the go.mod file. Indirect requirements may be\n-automatically removed from the go.mod file once they are implied by other\n-direct requirements. Indirect requirements only arise when using modules\n-that fail to state some of their own dependencies or when explicitly\n-upgrading a module's dependencies ahead of its own stated requirements.\n-\n-The -mod build flag provides additional control over the updating and use of\n-go.mod for commands that build packages like \"go build\" and \"go test\".\n-\n-If invoked with -mod=readonly (the default in most situations), the go command\n-reports an error if a package named on the command line or an imported package\n-is not provided by any module in the build list computed from the main module's\n-requirements. The go command also reports an error if a module's checksum is\n-missing from go.sum (see Module downloading and verification). Either go.mod or\n-go.sum must be updated in these situations.\n-\n-If invoked with -mod=mod, the go command automatically updates go.mod and\n-go.sum, fixing inconsistencies and adding missing requirements and checksums\n-as needed. If the go command finds an unfamiliar import, it looks up the\n-module containing that import and adds a requirement for the latest version\n-of that module to go.mod. In most cases, therefore, one may add an import to\n-source code and run \"go build\", \"go test\", or even \"go list\" with -mod=mod:\n-as part of analyzing the package, the go command will resolve the import and\n-update the go.mod file.\n-\n-If invoked with -mod=vendor, the go command loads packages from the main\n-module's vendor directory instead of downloading modules to and loading packages\n-from the module cache. The go command assumes the vendor directory holds\n-correct copies of dependencies, and it does not compute the set of required\n-module versions from go.mod files. However, the go command does check that\n-vendor/modules.txt (generated by \"go mod vendor\") contains metadata consistent\n-with go.mod.\n-\n-If the go command is not invoked with a -mod flag, and the vendor directory\n-is present, and the \"go\" version in go.mod is 1.14 or higher, the go command\n-will act as if it were invoked with -mod=vendor. Otherwise, the -mod flag\n-defaults to -mod=readonly.\n-\n-Note that neither \"go get\" nor the \"go mod\" subcommands accept the -mod flag.\n-\n-Pseudo-versions\n-\n-The go.mod file and the go command more generally use semantic versions as\n-the standard form for describing module versions, so that versions can be\n-compared to determine which should be considered earlier or later than another.\n-A module version like v1.2.3 is introduced by tagging a revision in the\n-underlying source repository. Untagged revisions can be referred to\n-using a \"pseudo-version\" like v0.0.0-yyyymmddhhmmss-abcdefabcdef,\n-where the time is the commit time in UTC and the final suffix is the prefix\n-of the commit hash. The time portion ensures that two pseudo-versions can\n-be compared to determine which happened later, the commit hash identifes\n-the underlying commit, and the prefix (v0.0.0- in this example) is derived from\n-the most recent tagged version in the commit graph before this commit.\n-\n-There are three pseudo-version forms:\n-\n-vX.0.0-yyyymmddhhmmss-abcdefabcdef is used when there is no earlier\n-versioned commit with an appropriate major version before the target commit.\n-(This was originally the only form, so some older go.mod files use this form\n-even for commits that do follow tags.)\n-\n-vX.Y.Z-pre.0.yyyymmddhhmmss-abcdefabcdef is used when the most\n-recent versioned commit before the target commit is vX.Y.Z-pre.\n-\n-vX.Y.(Z+1)-0.yyyymmddhhmmss-abcdefabcdef is used when the most\n-recent versioned commit before the target commit is vX.Y.Z.\n-\n-Pseudo-versions never need to be typed by hand: the go command will accept\n-the plain commit hash and translate it into a pseudo-version (or a tagged\n-version if available) automatically. This conversion is an example of a\n-module query.\n-\n-Module queries\n-\n-The go command accepts a \"module query\" in place of a module version\n-both on the command line and in the main module's go.mod file.\n-(After evaluating a query found in the main module's go.mod file,\n-the go command updates the file to replace the query with its result.)\n-\n-A fully-specified semantic version, such as \"v1.2.3\",\n-evaluates to that specific version.\n-\n-A semantic version prefix, such as \"v1\" or \"v1.2\",\n-evaluates to the latest available tagged version with that prefix.\n-\n-A semantic version comparison, such as \"<v1.2.3\" or \">=v1.5.6\",\n-evaluates to the available tagged version nearest to the comparison target\n-(the latest version for < and <=, the earliest version for > and >=).\n-\n-The string \"latest\" matches the latest available tagged version,\n-or else the underlying source repository's latest untagged revision.\n-\n-The string \"upgrade\" is like \"latest\", but if the module is\n-currently required at a later version than the version \"latest\"\n-would select (for example, a newer pre-release version), \"upgrade\"\n-will select the later version instead.\n-\n-The string \"patch\" matches the latest available tagged version\n-of a module with the same major and minor version numbers as the\n-currently required version. If no version is currently required,\n-\"patch\" is equivalent to \"latest\".\n-\n-A revision identifier for the underlying source repository, such as\n-a commit hash prefix, revision tag, or branch name, selects that\n-specific code revision. If the revision is also tagged with a\n-semantic version, the query evaluates to that semantic version.\n-Otherwise the query evaluates to a pseudo-version for the commit.\n-Note that branches and tags with names that are matched by other\n-query syntax cannot be selected this way. For example, the query\n-\"v2\" means the latest version starting with \"v2\", not the branch\n-named \"v2\".\n-\n-All queries prefer release versions to pre-release versions.\n-For example, \"<v1.2.3\" will prefer to return \"v1.2.2\"\n-instead of \"v1.2.3-pre1\", even though \"v1.2.3-pre1\" is nearer\n-to the comparison target.\n-\n-Module versions disallowed by exclude statements in the\n-main module's go.mod are considered unavailable and cannot\n-be returned by queries.\n-\n-For example, these commands are all valid:\n-\n-\tgo get github.com/gorilla/mux@latest    # same (@latest is default for 'go get')\n-\tgo get github.com/gorilla/mux@v1.6.2    # records v1.6.2\n-\tgo get github.com/gorilla/mux@e3702bed2 # records v1.6.2\n-\tgo get github.com/gorilla/mux@c856192   # records v0.0.0-20180517173623-c85619274f5d\n-\tgo get github.com/gorilla/mux@master    # records current meaning of master\n-\n-Module compatibility and semantic versioning\n-\n-The go command requires that modules use semantic versions and expects that\n-the versions accurately describe compatibility: it assumes that v1.5.4 is a\n-backwards-compatible replacement for v1.5.3, v1.4.0, and even v1.0.0.\n-More generally the go command expects that packages follow the\n-\"import compatibility rule\", which says:\n-\n-\"If an old package and a new package have the same import path,\n-the new package must be backwards compatible with the old package.\"\n-\n-Because the go command assumes the import compatibility rule,\n-a module definition can only set the minimum required version of one\n-of its dependencies: it cannot set a maximum or exclude selected versions.\n-Still, the import compatibility rule is not a guarantee: it may be that\n-v1.5.4 is buggy and not a backwards-compatible replacement for v1.5.3.\n-Because of this, the go command never updates from an older version\n-to a newer version of a module unasked.\n-\n-In semantic versioning, changing the major version number indicates a lack\n-of backwards compatibility with earlier versions. To preserve import\n-compatibility, the go command requires that modules with major version v2\n-or later use a module path with that major version as the final element.\n-For example, version v2.0.0 of example.com/m must instead use module path\n-example.com/m/v2, and packages in that module would use that path as\n-their import path prefix, as in example.com/m/v2/sub/pkg. Including the\n-major version number in the module path and import paths in this way is\n-called \"semantic import versioning\". Pseudo-versions for modules with major\n-version v2 and later begin with that major version instead of v0, as in\n-v2.0.0-20180326061214-4fc5987536ef.\n-\n-As a special case, module paths beginning with gopkg.in/ continue to use the\n-conventions established on that system: the major version is always present,\n-and it is preceded by a dot instead of a slash: gopkg.in/yaml.v1\n-and gopkg.in/yaml.v2, not gopkg.in/yaml and gopkg.in/yaml/v2.\n-\n-The go command treats modules with different module paths as unrelated:\n-it makes no connection between example.com/m and example.com/m/v2.\n-Modules with different major versions can be used together in a build\n-and are kept separate by the fact that their packages use different\n-import paths.\n-\n-In semantic versioning, major version v0 is for initial development,\n-indicating no expectations of stability or backwards compatibility.\n-Major version v0 does not appear in the module path, because those\n-versions are preparation for v1.0.0, and v1 does not appear in the\n-module path either.\n-\n-Code written before the semantic import versioning convention\n-was introduced may use major versions v2 and later to describe\n-the same set of unversioned import paths as used in v0 and v1.\n-To accommodate such code, if a source code repository has a\n-v2.0.0 or later tag for a file tree with no go.mod, the version is\n-considered to be part of the v1 module's available versions\n-and is given an +incompatible suffix when converted to a module\n-version, as in v2.0.0+incompatible. The +incompatible tag is also\n-applied to pseudo-versions derived from such versions, as in\n-v2.0.1-0.yyyymmddhhmmss-abcdefabcdef+incompatible.\n-\n-In general, having a dependency in the build list (as reported by 'go list -m all')\n-on a v0 version, pre-release version, pseudo-version, or +incompatible version\n-is an indication that problems are more likely when upgrading that\n-dependency, since there is no expectation of compatibility for those.\n-\n-See https://research.swtch.com/vgo-import for more information about\n-semantic import versioning, and see https://semver.org/ for more about\n-semantic versioning.\n-\n-Module code layout\n-\n-For now, see https://research.swtch.com/vgo-module for information\n-about how source code in version control systems is mapped to\n-module file trees.\n-\n-Module downloading and verification\n-\n-The go command can fetch modules from a proxy or connect to source control\n-servers directly, according to the setting of the GOPROXY environment\n-variable (see 'go help env'). The default setting for GOPROXY is\n-\"https://proxy.golang.org,direct\", which means to try the\n-Go module mirror run by Google and fall back to a direct connection\n-if the proxy reports that it does not have the module (HTTP error 404 or 410).\n-See https://proxy.golang.org/privacy for the service's privacy policy.\n-\n-If GOPROXY is set to the string \"direct\", downloads use a direct connection to\n-source control servers. Setting GOPROXY to \"off\" disallows downloading modules\n-from any source. Otherwise, GOPROXY is expected to be list of module proxy URLs\n-separated by either comma (,) or pipe (|) characters, which control error\n-fallback behavior. For each request, the go command tries each proxy in\n-sequence. If there is an error, the go command will try the next proxy in the\n-list if the error is a 404 or 410 HTTP response or if the current proxy is\n-followed by a pipe character, indicating it is safe to fall back on any error.\n-\n-The GOPRIVATE and GONOPROXY environment variables allow bypassing\n-the proxy for selected modules. See 'go help private' for details.\n-\n-No matter the source of the modules, the go command checks downloads against\n-known checksums, to detect unexpected changes in the content of any specific\n-module version from one day to the next. This check first consults the current\n-module's go.sum file but falls back to the Go checksum database, controlled by\n-the GOSUMDB and GONOSUMDB environment variables. See 'go help module-auth'\n-for details.\n-\n-See 'go help goproxy' for details about the proxy protocol and also\n-the format of the cached downloaded packages.\n-\n-Modules and vendoring\n-\n-When using modules, the go command typically satisfies dependencies by\n-downloading modules from their sources and using those downloaded copies\n-(after verification, as described in the previous section). Vendoring may\n-be used to allow interoperation with older versions of Go, or to ensure\n-that all files used for a build are stored together in a single file tree.\n-\n-The command 'go mod vendor' constructs a directory named vendor in the main\n-module's root directory that contains copies of all packages needed to support\n-builds and tests of packages in the main module. 'go mod vendor' also\n-creates the file vendor/modules.txt that contains metadata about vendored\n-packages and module versions. This file should be kept consistent with go.mod:\n-when vendoring is used, 'go mod vendor' should be run after go.mod is updated.\n-\n-If the vendor directory is present in the main module's root directory, it will\n-be used automatically if the \"go\" version in the main module's go.mod file is\n-1.14 or higher. Build commands like 'go build' and 'go test' will load packages\n-from the vendor directory instead of accessing the network or the local module\n-cache. To explicitly enable vendoring, invoke the go command with the flag\n--mod=vendor. To disable vendoring, use the flag -mod=mod.\n-\n-Unlike vendoring in GOPATH, the go command ignores vendor directories in\n-locations other than the main module's root directory.\n+For a detailed reference on modules, see https://golang.org/ref/mod.\n \t`,\n }\n \n@@ -413,87 +34,22 @@ file in its root. When the go command is run, it looks in the current\n directory and then successive parent directories to find the go.mod\n marking the root of the main (current) module.\n \n-The go.mod file itself is line-oriented, with // comments but\n-no /* */ comments. Each line holds a single directive, made up of a\n-verb followed by arguments. For example:\n-\n-\tmodule my/thing\n-\tgo 1.12\n-\trequire other/thing v1.0.2\n-\trequire new/thing/v2 v2.3.4\n-\texclude old/thing v1.2.3\n-\treplace bad/thing v1.4.5 => good/thing v1.4.5\n-\tretract v1.5.6\n-\n-The verbs are\n-\tmodule, to define the module path;\n-\tgo, to set the expected language version;\n-\trequire, to require a particular module at a given version or later;\n-\texclude, to exclude a particular module version from use;\n-\treplace, to replace a module version with a different module version; and\n-\tretract, to indicate a previously released version should not be used.\n-Exclude and replace apply only in the main module's go.mod and are ignored\n-in dependencies.  See https://golang.org/ref/mod for details.\n-\n-The leading verb can be factored out of adjacent lines to create a block,\n-like in Go imports:\n-\n-\trequire (\n-\t\tnew/thing/v2 v2.3.4\n-\t\told/thing v1.2.3\n-\t)\n-\n-The go.mod file is designed both to be edited directly and to be\n-easily updated by tools. The 'go mod edit' command can be used to\n-parse and edit the go.mod file from programs and tools.\n-See 'go help mod edit'.\n-\n-The go command automatically updates go.mod each time it uses the\n-module graph, to make sure go.mod always accurately reflects reality\n-and is properly formatted. For example, consider this go.mod file:\n-\n-        module M\n-\n-        require (\n-                A v1\n-                B v1.0.0\n-                C v1.0.0\n-                D v1.2.3\n-                E dev\n-        )\n-\n-        exclude D v1.2.3\n-\n-The update rewrites non-canonical version identifiers to semver form,\n-so A's v1 becomes v1.0.0 and E's dev becomes the pseudo-version for the\n-latest commit on the dev branch, perhaps v0.0.0-20180523231146-b3f5c0f6e5f1.\n-\n-The update modifies requirements to respect exclusions, so the\n-requirement on the excluded D v1.2.3 is updated to use the next\n-available version of D, perhaps D v1.2.4 or D v1.3.0.\n+The go.mod file format is described in detail at\n+https://golang.org/ref/mod#go-mod-file.\n \n-The update removes redundant or misleading requirements.\n-For example, if A v1.0.0 itself requires B v1.2.0 and C v1.0.0,\n-then go.mod's requirement of B v1.0.0 is misleading (superseded by\n-A's need for v1.2.0), and its requirement of C v1.0.0 is redundant\n-(implied by A's need for the same version), so both will be removed.\n-If module M contains packages that directly import packages from B or\n-C, then the requirements will be kept but updated to the actual\n-versions being used.\n+To create a new go.mod file, use 'go help init'. For details see\n+'go help mod init' or https://golang.org/ref/mod#go-mod-init.\n \n-Finally, the update reformats the go.mod in a canonical formatting, so\n-that future mechanical changes will result in minimal diffs.\n+To add missing module requirements or remove unneeded requirements,\n+use 'go mod tidy'. For details, see 'go help mod tidy' or\n+https://golang.org/ref/mod#go-mod-tidy.\n \n-Because the module graph defines the meaning of import statements, any\n-commands that load packages also use and therefore update go.mod,\n-including go build, go get, go install, go list, go test, go mod graph,\n-go mod tidy, and go mod why.\n+To add, upgrade, downgrade, or remove a specific module requirement, use\n+'go get'. For details, see 'go help module-get' or\n+https://golang.org/ref/mod#go-get.\n \n-The expected language version, set by the go directive, determines\n-which language features are available when compiling the module.\n-Language features available in that version will be available for use.\n-Language features removed in earlier versions, or added in later versions,\n-will not be available. Note that the language version does not affect\n-build tags, which are determined by the Go release being used.\n+To make other changes or to parse go.mod as JSON for use by other tools,\n+use 'go mod edit'. See 'go help mod edit' or\n+https://golang.org/ref/mod#go-mod-edit.\n \t`,\n }"}, {"sha": "182429aee41b95121da18f25cc8ed7a46df1b38e", "filename": "libgo/go/cmd/go/internal/modload/import.go", "status": "modified", "additions": 57, "deletions": 25, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -31,10 +31,6 @@ type ImportMissingError struct {\n \tModule   module.Version\n \tQueryErr error\n \n-\t// inAll indicates whether Path is in the \"all\" package pattern,\n-\t// and thus would be added by 'go mod tidy'.\n-\tinAll bool\n-\n \t// isStd indicates whether we would expect to find the package in the standard\n \t// library. This is normally true for all dotless import paths, but replace\n \t// directives can cause us to treat the replaced paths as also being in\n@@ -58,7 +54,7 @@ func (e *ImportMissingError) Error() string {\n \t\tif e.QueryErr != nil {\n \t\t\treturn fmt.Sprintf(\"cannot find module providing package %s: %v\", e.Path, e.QueryErr)\n \t\t}\n-\t\tif cfg.BuildMod == \"mod\" {\n+\t\tif cfg.BuildMod == \"mod\" || (cfg.BuildMod == \"readonly\" && allowMissingModuleImports) {\n \t\t\treturn \"cannot find module providing package \" + e.Path\n \t\t}\n \n@@ -67,16 +63,14 @@ func (e *ImportMissingError) Error() string {\n \t\t\tif !modfetch.IsZeroPseudoVersion(e.replaced.Version) {\n \t\t\t\tsuggestArg = e.replaced.String()\n \t\t\t}\n-\t\t\treturn fmt.Sprintf(\"module %s provides package %s and is replaced but not required; try 'go get -d %s' to add it\", e.replaced.Path, e.Path, suggestArg)\n+\t\t\treturn fmt.Sprintf(\"module %s provides package %s and is replaced but not required; to add it:\\n\\tgo get %s\", e.replaced.Path, e.Path, suggestArg)\n \t\t}\n \n \t\tsuggestion := \"\"\n \t\tif !HasModRoot() {\n \t\t\tsuggestion = \": working directory is not part of a module\"\n-\t\t} else if e.inAll {\n-\t\t\tsuggestion = \"; try 'go mod tidy' to add it\"\n \t\t} else {\n-\t\t\tsuggestion = fmt.Sprintf(\"; try 'go get -d %s' to add it\", e.Path)\n+\t\t\tsuggestion = fmt.Sprintf(\"; to add it:\\n\\tgo get %s\", e.Path)\n \t\t}\n \t\treturn fmt.Sprintf(\"no required module provides package %s%s\", e.Path, suggestion)\n \t}\n@@ -136,24 +130,57 @@ func (e *AmbiguousImportError) Error() string {\n }\n \n // ImportMissingSumError is reported in readonly mode when we need to check\n-// if a module in the build list contains a package, but we don't have a sum\n-// for its .zip file.\n+// if a module contains a package, but we don't have a sum for its .zip file.\n+// We might need sums for multiple modules to verify the package is unique.\n+//\n+// TODO(#43653): consolidate multiple errors of this type into a single error\n+// that suggests a 'go get' command for root packages that transtively import\n+// packages from modules with missing sums. load.CheckPackageErrors would be\n+// a good place to consolidate errors, but we'll need to attach the import\n+// stack here.\n type ImportMissingSumError struct {\n-\timportPath   string\n-\tfound, inAll bool\n+\timportPath                string\n+\tfound                     bool\n+\tmods                      []module.Version\n+\timporter, importerVersion string // optional, but used for additional context\n+\timporterIsTest            bool\n }\n \n func (e *ImportMissingSumError) Error() string {\n+\tvar importParen string\n+\tif e.importer != \"\" {\n+\t\timportParen = fmt.Sprintf(\" (imported by %s)\", e.importer)\n+\t}\n \tvar message string\n \tif e.found {\n-\t\tmessage = fmt.Sprintf(\"missing go.sum entry needed to verify package %s is provided by exactly one module\", e.importPath)\n+\t\tmessage = fmt.Sprintf(\"missing go.sum entry needed to verify package %s%s is provided by exactly one module\", e.importPath, importParen)\n \t} else {\n-\t\tmessage = fmt.Sprintf(\"missing go.sum entry for module providing package %s\", e.importPath)\n+\t\tmessage = fmt.Sprintf(\"missing go.sum entry for module providing package %s%s\", e.importPath, importParen)\n \t}\n-\tif e.inAll {\n-\t\treturn message + \"; try 'go mod tidy' to add it\"\n+\tvar hint string\n+\tif e.importer == \"\" {\n+\t\t// Importing package is unknown, or the missing package was named on the\n+\t\t// command line. Recommend 'go mod download' for the modules that could\n+\t\t// provide the package, since that shouldn't change go.mod.\n+\t\targs := make([]string, len(e.mods))\n+\t\tfor i, mod := range e.mods {\n+\t\t\targs[i] = mod.Path\n+\t\t}\n+\t\thint = fmt.Sprintf(\"; to add:\\n\\tgo mod download %s\", strings.Join(args, \" \"))\n+\t} else {\n+\t\t// Importing package is known (common case). Recommend 'go get' on the\n+\t\t// current version of the importing package.\n+\t\ttFlag := \"\"\n+\t\tif e.importerIsTest {\n+\t\t\ttFlag = \" -t\"\n+\t\t}\n+\t\tversion := \"\"\n+\t\tif e.importerVersion != \"\" {\n+\t\t\tversion = \"@\" + e.importerVersion\n+\t\t}\n+\t\thint = fmt.Sprintf(\"; to add:\\n\\tgo get%s %s%s\", tFlag, e.importer, version)\n \t}\n-\treturn message\n+\treturn message + hint\n }\n \n func (e *ImportMissingSumError) ImportPath() string {\n@@ -244,7 +271,7 @@ func importFromBuildList(ctx context.Context, path string, buildList []module.Ve\n \t// Check each module on the build list.\n \tvar dirs []string\n \tvar mods []module.Version\n-\thaveSumErr := false\n+\tvar sumErrMods []module.Version\n \tfor _, m := range buildList {\n \t\tif !maybeInModule(path, m.Path) {\n \t\t\t// Avoid possibly downloading irrelevant modules.\n@@ -257,8 +284,9 @@ func importFromBuildList(ctx context.Context, path string, buildList []module.Ve\n \t\t\t\t// We are missing a sum needed to fetch a module in the build list.\n \t\t\t\t// We can't verify that the package is unique, and we may not find\n \t\t\t\t// the package at all. Keep checking other modules to decide which\n-\t\t\t\t// error to report.\n-\t\t\t\thaveSumErr = true\n+\t\t\t\t// error to report. Multiple sums may be missing if we need to look in\n+\t\t\t\t// multiple nested modules to resolve the import.\n+\t\t\t\tsumErrMods = append(sumErrMods, m)\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\t// Report fetch error.\n@@ -279,8 +307,12 @@ func importFromBuildList(ctx context.Context, path string, buildList []module.Ve\n \tif len(mods) > 1 {\n \t\treturn module.Version{}, \"\", &AmbiguousImportError{importPath: path, Dirs: dirs, Modules: mods}\n \t}\n-\tif haveSumErr {\n-\t\treturn module.Version{}, \"\", &ImportMissingSumError{importPath: path, found: len(mods) > 0}\n+\tif len(sumErrMods) > 0 {\n+\t\treturn module.Version{}, \"\", &ImportMissingSumError{\n+\t\t\timportPath: path,\n+\t\t\tmods:       sumErrMods,\n+\t\t\tfound:      len(mods) > 0,\n+\t\t}\n \t}\n \tif len(mods) == 1 {\n \t\treturn mods[0], dirs[0], nil\n@@ -365,7 +397,7 @@ func queryImport(ctx context.Context, path string) (module.Version, error) {\n \t\treturn module.Version{}, &ImportMissingError{Path: path, isStd: true}\n \t}\n \n-\tif cfg.BuildMod == \"readonly\" {\n+\tif cfg.BuildMod == \"readonly\" && !allowMissingModuleImports {\n \t\t// In readonly mode, we can't write go.mod, so we shouldn't try to look up\n \t\t// the module. If readonly mode was enabled explicitly, include that in\n \t\t// the error message.\n@@ -547,7 +579,7 @@ func fetch(ctx context.Context, mod module.Version, needSum bool) (dir string, i\n \t\tmod = r\n \t}\n \n-\tif cfg.BuildMod == \"readonly\" && needSum && !modfetch.HaveSum(mod) {\n+\tif HasModRoot() && cfg.BuildMod == \"readonly\" && needSum && !modfetch.HaveSum(mod) {\n \t\treturn \"\", false, module.VersionError(mod, &sumMissingError{})\n \t}\n "}, {"sha": "9420dc56460d1060b7723d6763c66e816956408b", "filename": "libgo/go/cmd/go/internal/modload/import_test.go", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -58,10 +58,15 @@ var importTests = []struct {\n func TestQueryImport(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n \ttestenv.MustHaveExecPath(t, \"git\")\n-\tdefer func(old bool) {\n-\t\tallowMissingModuleImports = old\n-\t}(allowMissingModuleImports)\n-\tAllowMissingModuleImports()\n+\n+\toldAllowMissingModuleImports := allowMissingModuleImports\n+\toldRootMode := RootMode\n+\tdefer func() {\n+\t\tallowMissingModuleImports = oldAllowMissingModuleImports\n+\t\tRootMode = oldRootMode\n+\t}()\n+\tallowMissingModuleImports = true\n+\tRootMode = NoRoot\n \n \tctx := context.Background()\n "}, {"sha": "bc8d17e0a5fb5934d93a09025a186d21a0cccb6b", "filename": "libgo/go/cmd/go/internal/modload/init.go", "status": "modified", "additions": 42, "deletions": 39, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -15,6 +15,7 @@ import (\n \t\"os\"\n \t\"path\"\n \t\"path/filepath\"\n+\t\"sort\"\n \t\"strconv\"\n \t\"strings\"\n \t\"sync\"\n@@ -27,6 +28,7 @@ import (\n \t\"cmd/go/internal/modfetch\"\n \t\"cmd/go/internal/mvs\"\n \t\"cmd/go/internal/search\"\n+\t\"cmd/go/internal/str\"\n \n \t\"golang.org/x/mod/modfile\"\n \t\"golang.org/x/mod/module\"\n@@ -200,6 +202,8 @@ func Init() {\n \t}\n \n \t// We're in module mode. Set any global variables that need to be set.\n+\tcfg.ModulesEnabled = true\n+\tsetDefaultBuildMod()\n \tlist := filepath.SplitList(cfg.BuildContext.GOPATH)\n \tif len(list) == 0 || list[0] == \"\" {\n \t\tbase.Fatalf(\"missing $GOPATH\")\n@@ -209,8 +213,6 @@ func Init() {\n \t\tbase.Fatalf(\"$GOPATH/go.mod exists but should not\")\n \t}\n \n-\tcfg.ModulesEnabled = true\n-\n \tif modRoot == \"\" {\n \t\t// We're in module mode, but not inside a module.\n \t\t//\n@@ -346,8 +348,8 @@ func die() {\n // ensuring requirements are consistent. WriteGoMod should be called later to\n // write changes out to disk or report errors in readonly mode.\n //\n-// As a side-effect, LoadModFile sets a default for cfg.BuildMod if it does not\n-// already have an explicit value.\n+// As a side-effect, LoadModFile may change cfg.BuildMod to \"vendor\" if\n+// -mod wasn't set explicitly and automatic vendoring should be enabled.\n func LoadModFile(ctx context.Context) {\n \tif len(buildList) > 0 {\n \t\treturn\n@@ -378,14 +380,14 @@ func LoadModFile(ctx context.Context) {\n \n \tif f.Module == nil {\n \t\t// No module declaration. Must add module path.\n-\t\tbase.Fatalf(\"go: no module declaration in go.mod.\\n\\tRun 'go mod edit -module=example.com/mod' to specify the module path.\")\n+\t\tbase.Fatalf(\"go: no module declaration in go.mod. To specify the module path:\\n\\tgo mod edit -module=example.com/mod\")\n \t}\n \n \tif err := checkModulePathLax(f.Module.Mod.Path); err != nil {\n \t\tbase.Fatalf(\"go: %v\", err)\n \t}\n \n-\tsetDefaultBuildMod()\n+\tsetDefaultBuildMod() // possibly enable automatic vendoring\n \tmodFileToBuildList()\n \tif cfg.BuildMod == \"vendor\" {\n \t\treadVendorList()\n@@ -456,7 +458,7 @@ func CreateModFile(ctx context.Context, modPath string) {\n \t\t}\n \t}\n \tif !empty {\n-\t\tfmt.Fprintf(os.Stderr, \"go: run 'go mod tidy' to add module requirements and sums\\n\")\n+\t\tfmt.Fprintf(os.Stderr, \"go: to add module requirements and sums:\\n\\tgo mod tidy\\n\")\n \t}\n }\n \n@@ -584,8 +586,8 @@ func modFileToBuildList() {\n \tbuildList = list\n }\n \n-// setDefaultBuildMod sets a default value for cfg.BuildMod\n-// if it is currently empty.\n+// setDefaultBuildMod sets a default value for cfg.BuildMod if the -mod flag\n+// wasn't provided. setDefaultBuildMod may be called multiple times.\n func setDefaultBuildMod() {\n \tif cfg.BuildModExplicit {\n \t\t// Don't override an explicit '-mod=' argument.\n@@ -606,7 +608,7 @@ func setDefaultBuildMod() {\n \n \tif fi, err := fsys.Stat(filepath.Join(modRoot, \"vendor\")); err == nil && fi.IsDir() {\n \t\tmodGo := \"unspecified\"\n-\t\tif index.goVersionV != \"\" {\n+\t\tif index != nil && index.goVersionV != \"\" {\n \t\t\tif semver.Compare(index.goVersionV, \"v1.14\") >= 0 {\n \t\t\t\t// The Go version is at least 1.14, and a vendor directory exists.\n \t\t\t\t// Set -mod=vendor by default.\n@@ -845,13 +847,15 @@ func AllowWriteGoMod() {\n // MinReqs returns a Reqs with minimal additional dependencies of Target,\n // as will be written to go.mod.\n func MinReqs() mvs.Reqs {\n-\tvar retain []string\n+\tretain := append([]string{}, additionalExplicitRequirements...)\n \tfor _, m := range buildList[1:] {\n \t\t_, explicit := index.require[m]\n \t\tif explicit || loaded.direct[m.Path] {\n \t\t\tretain = append(retain, m.Path)\n \t\t}\n \t}\n+\tsort.Strings(retain)\n+\tstr.Uniq(&retain)\n \tmin, err := mvs.Req(Target, retain, &mvsReqs{buildList: buildList})\n \tif err != nil {\n \t\tbase.Fatalf(\"go: %v\", err)\n@@ -903,7 +907,7 @@ func WriteGoMod() {\n \t\t} else if cfg.BuildModReason != \"\" {\n \t\t\tbase.Fatalf(\"go: updates to go.mod needed, disabled by -mod=readonly\\n\\t(%s)\", cfg.BuildModReason)\n \t\t} else {\n-\t\t\tbase.Fatalf(\"go: updates to go.mod needed; try 'go mod tidy' first\")\n+\t\t\tbase.Fatalf(\"go: updates to go.mod needed; to update it:\\n\\tgo mod tidy\")\n \t\t}\n \t}\n \n@@ -972,9 +976,12 @@ func WriteGoMod() {\n // It also contains entries for go.mod files needed for MVS (the version\n // of these entries ends with \"/go.mod\").\n //\n-// If addDirect is true, the set also includes sums for modules directly\n-// required by go.mod, as represented by the index, with replacements applied.\n-func keepSums(addDirect bool) map[module.Version]bool {\n+// If keepBuildListZips is true, the set also includes sums for zip files for\n+// all modules in the build list with replacements applied. 'go get' and\n+// 'go mod download' may add sums to this set when adding a requirement on a\n+// module without a root package or when downloading a direct or indirect\n+// dependency.\n+func keepSums(keepBuildListZips bool) map[module.Version]bool {\n \t// Re-derive the build list using the current list of direct requirements.\n \t// Keep the sum for the go.mod of each visited module version (or its\n \t// replacement).\n@@ -1003,19 +1010,20 @@ func keepSums(addDirect bool) map[module.Version]bool {\n \t\tpanic(fmt.Sprintf(\"unexpected error reloading build list: %v\", err))\n \t}\n \n+\tactualMods := make(map[string]module.Version)\n+\tfor _, m := range buildList[1:] {\n+\t\tif r := Replacement(m); r.Path != \"\" {\n+\t\t\tactualMods[m.Path] = r\n+\t\t} else {\n+\t\t\tactualMods[m.Path] = m\n+\t\t}\n+\t}\n+\n \t// Add entries for modules in the build list with paths that are prefixes of\n \t// paths of loaded packages. We need to retain sums for modules needed to\n \t// report ambiguous import errors. We use our re-derived build list,\n \t// since the global build list may have been tidied.\n \tif loaded != nil {\n-\t\tactualMods := make(map[string]module.Version)\n-\t\tfor _, m := range buildList[1:] {\n-\t\t\tif r := Replacement(m); r.Path != \"\" {\n-\t\t\t\tactualMods[m.Path] = r\n-\t\t\t} else {\n-\t\t\t\tactualMods[m.Path] = m\n-\t\t\t}\n-\t\t}\n \t\tfor _, pkg := range loaded.pkgs {\n \t\t\tif pkg.testOf != nil || pkg.inStd || module.CheckImportPath(pkg.path) != nil {\n \t\t\t\tcontinue\n@@ -1028,17 +1036,13 @@ func keepSums(addDirect bool) map[module.Version]bool {\n \t\t}\n \t}\n \n-\t// Add entries for modules directly required by go.mod.\n-\tif addDirect {\n-\t\tfor m := range index.require {\n-\t\t\tvar kept module.Version\n-\t\t\tif r := Replacement(m); r.Path != \"\" {\n-\t\t\t\tkept = r\n-\t\t\t} else {\n-\t\t\t\tkept = m\n-\t\t\t}\n-\t\t\tkeep[kept] = true\n-\t\t\tkeep[module.Version{Path: kept.Path, Version: kept.Version + \"/go.mod\"}] = true\n+\t// Add entries for the zip of each module in the build list.\n+\t// We might not need all of these (tidy does not add them), but they may be\n+\t// added by a specific 'go get' or 'go mod download' command to resolve\n+\t// missing import sum errors.\n+\tif keepBuildListZips {\n+\t\tfor _, m := range actualMods {\n+\t\t\tkeep[m] = true\n \t\t}\n \t}\n \n@@ -1058,9 +1062,8 @@ func (r *keepSumReqs) Required(m module.Version) ([]module.Version, error) {\n }\n \n func TrimGoSum() {\n-\t// Don't retain sums for direct requirements in go.mod. When TrimGoSum is\n-\t// called, go.mod has not been updated, and it may contain requirements on\n-\t// modules deleted from the build list.\n-\taddDirect := false\n-\tmodfetch.TrimGoSum(keepSums(addDirect))\n+\t// Don't retain sums for the zip file of every module in the build list.\n+\t// We may not need them all to build the main module's packages.\n+\tkeepBuildListZips := false\n+\tmodfetch.TrimGoSum(keepSums(keepBuildListZips))\n }"}, {"sha": "6d87acc6d3b7c9371cdb62e08339b585dd149833", "filename": "libgo/go/cmd/go/internal/modload/load.go", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -280,11 +280,11 @@ func LoadPackages(ctx context.Context, opts PackageOpts, patterns ...string) (ma\n \tcheckMultiplePaths()\n \tfor _, pkg := range loaded.pkgs {\n \t\tif pkg.err != nil {\n-\t\t\tif pkg.flags.has(pkgInAll) {\n-\t\t\t\tif imErr := (*ImportMissingError)(nil); errors.As(pkg.err, &imErr) {\n-\t\t\t\t\timErr.inAll = true\n-\t\t\t\t} else if sumErr := (*ImportMissingSumError)(nil); errors.As(pkg.err, &sumErr) {\n-\t\t\t\t\tsumErr.inAll = true\n+\t\t\tif sumErr := (*ImportMissingSumError)(nil); errors.As(pkg.err, &sumErr) {\n+\t\t\t\tif importer := pkg.stack; importer != nil {\n+\t\t\t\t\tsumErr.importer = importer.path\n+\t\t\t\t\tsumErr.importerVersion = importer.mod.Version\n+\t\t\t\t\tsumErr.importerIsTest = importer.testOf != nil\n \t\t\t\t}\n \t\t\t}\n \n@@ -863,12 +863,21 @@ func loadFromRoots(params loaderParams) *loader {\n \tfor _, pkg := range ld.pkgs {\n \t\tif pkg.mod == Target {\n \t\t\tfor _, dep := range pkg.imports {\n-\t\t\t\tif dep.mod.Path != \"\" {\n+\t\t\t\tif dep.mod.Path != \"\" && dep.mod.Path != Target.Path && index != nil {\n+\t\t\t\t\t_, explicit := index.require[dep.mod]\n+\t\t\t\t\tif allowWriteGoMod && cfg.BuildMod == \"readonly\" && !explicit {\n+\t\t\t\t\t\t// TODO(#40775): attach error to package instead of using\n+\t\t\t\t\t\t// base.Errorf. Ideally, 'go list' should not fail because of this,\n+\t\t\t\t\t\t// but today, LoadPackages calls WriteGoMod unconditionally, which\n+\t\t\t\t\t\t// would fail with a less clear message.\n+\t\t\t\t\t\tbase.Errorf(\"go: %[1]s: package %[2]s imported from implicitly required module; to add missing requirements, run:\\n\\tgo get %[2]s@%[3]s\", pkg.path, dep.path, dep.mod.Version)\n+\t\t\t\t\t}\n \t\t\t\t\tld.direct[dep.mod.Path] = true\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n+\tbase.ExitIfErrors()\n \n \t// If we didn't scan all of the imports from the main module, or didn't use\n \t// imports.AnyTags, then we didn't necessarily load every package that"}, {"sha": "c6667d0bf7944b2dcae558005363d648a05c4c5f", "filename": "libgo/go/cmd/go/internal/modload/modfile.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmodfile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmodfile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmodfile.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -446,10 +446,10 @@ func goModSummary(m module.Version) (*modFileSummary, error) {\n \tif actual.Path == \"\" {\n \t\tactual = m\n \t}\n-\tif cfg.BuildMod == \"readonly\" && actual.Version != \"\" {\n+\tif HasModRoot() && cfg.BuildMod == \"readonly\" && actual.Version != \"\" {\n \t\tkey := module.Version{Path: actual.Path, Version: actual.Version + \"/go.mod\"}\n \t\tif !modfetch.HaveSum(key) {\n-\t\t\tsuggestion := fmt.Sprintf(\"; try 'go mod download %s' to add it\", m.Path)\n+\t\t\tsuggestion := fmt.Sprintf(\"; to add it:\\n\\tgo mod download %s\", m.Path)\n \t\t\treturn nil, module.VersionError(actual, &sumMissingError{suggestion: suggestion})\n \t\t}\n \t}"}, {"sha": "31015194f9a0192b055615bd8619b0b7a6249c7e", "filename": "libgo/go/cmd/go/internal/modload/mvs.go", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmvs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmvs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmvs.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -111,19 +111,3 @@ func (*mvsReqs) Previous(m module.Version) (module.Version, error) {\n \t}\n \treturn module.Version{Path: m.Path, Version: \"none\"}, nil\n }\n-\n-// next returns the next version of m.Path after m.Version.\n-// It is only used by the exclusion processing in the Required method,\n-// not called directly by MVS.\n-func (*mvsReqs) next(m module.Version) (module.Version, error) {\n-\t// TODO(golang.org/issue/38714): thread tracing context through MVS.\n-\tlist, err := versions(context.TODO(), m.Path, CheckAllowed)\n-\tif err != nil {\n-\t\treturn module.Version{}, err\n-\t}\n-\ti := sort.Search(len(list), func(i int) bool { return semver.Compare(list[i], m.Version) > 0 })\n-\tif i < len(list) {\n-\t\treturn module.Version{Path: m.Path, Version: list[i]}, nil\n-\t}\n-\treturn module.Version{Path: m.Path, Version: \"none\"}, nil\n-}"}, {"sha": "8affd179bb2e9c0b1d51fec1b3b2bd80e2254017", "filename": "libgo/go/cmd/go/internal/modload/query.go", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -21,6 +21,7 @@ import (\n \t\"cmd/go/internal/imports\"\n \t\"cmd/go/internal/modfetch\"\n \t\"cmd/go/internal/search\"\n+\t\"cmd/go/internal/str\"\n \t\"cmd/go/internal/trace\"\n \n \t\"golang.org/x/mod/module\"\n@@ -1005,13 +1006,8 @@ func (rr *replacementRepo) Versions(prefix string) ([]string, error) {\n \tsort.Slice(versions, func(i, j int) bool {\n \t\treturn semver.Compare(versions[i], versions[j]) < 0\n \t})\n-\tuniq := versions[:1]\n-\tfor _, v := range versions {\n-\t\tif v != uniq[len(uniq)-1] {\n-\t\t\tuniq = append(uniq, v)\n-\t\t}\n-\t}\n-\treturn uniq, nil\n+\tstr.Uniq(&versions)\n+\treturn versions, nil\n }\n \n func (rr *replacementRepo) Stat(rev string) (*modfetch.RevInfo, error) {"}, {"sha": "d8fd91f1fea2b20339b4c2f61a1a77f5da6ab15f", "filename": "libgo/go/cmd/go/internal/modload/vendor.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fvendor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fvendor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fvendor.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -214,6 +214,6 @@ func checkVendorConsistency() {\n \t}\n \n \tif vendErrors.Len() > 0 {\n-\t\tbase.Fatalf(\"go: inconsistent vendoring in %s:%s\\n\\nrun 'go mod vendor' to sync, or use -mod=mod or -mod=readonly to ignore the vendor directory\", modRoot, vendErrors)\n+\t\tbase.Fatalf(\"go: inconsistent vendoring in %s:%s\\n\\n\\tTo ignore the vendor directory, use -mod=readonly or -mod=mod.\\n\\tTo sync the vendor directory, run:\\n\\t\\tgo mod vendor\", modRoot, vendErrors)\n \t}\n }"}, {"sha": "9106ebf74d5e31cb04e7deddf26e1a72ff6e9c74", "filename": "libgo/go/cmd/go/internal/str/str.go", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fstr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fstr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fstr.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -96,6 +96,20 @@ func Contains(x []string, s string) bool {\n \treturn false\n }\n \n+// Uniq removes consecutive duplicate strings from ss.\n+func Uniq(ss *[]string) {\n+\tif len(*ss) <= 1 {\n+\t\treturn\n+\t}\n+\tuniq := (*ss)[:1]\n+\tfor _, s := range *ss {\n+\t\tif s != uniq[len(uniq)-1] {\n+\t\t\tuniq = append(uniq, s)\n+\t\t}\n+\t}\n+\t*ss = uniq\n+}\n+\n func isSpaceByte(c byte) bool {\n \treturn c == ' ' || c == '\\t' || c == '\\n' || c == '\\r'\n }"}, {"sha": "30334b0f305ce495cc0475a43f6c08da063c90be", "filename": "libgo/go/cmd/go/internal/test/genflags.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fgenflags.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fgenflags.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fgenflags.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -9,9 +9,9 @@ package main\n import (\n \t\"bytes\"\n \t\"flag\"\n+\texec \"internal/execabs\"\n \t\"log\"\n \t\"os\"\n-\t\"os/exec\"\n \t\"strings\"\n \t\"testing\"\n \t\"text/template\""}, {"sha": "7fc9e8fbdcda1afb5837d5b2932329890b49b6a2", "filename": "libgo/go/cmd/go/internal/test/test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -11,10 +11,10 @@ import (\n \t\"errors\"\n \t\"fmt\"\n \t\"go/build\"\n+\texec \"internal/execabs\"\n \t\"io\"\n \t\"io/fs\"\n \t\"os\"\n-\t\"os/exec\"\n \t\"path\"\n \t\"path/filepath\"\n \t\"regexp\""}, {"sha": "10e6604da5f44b3b1c41f56f0653a667b7019196", "filename": "libgo/go/cmd/go/internal/test/testflag.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -325,7 +325,7 @@ func testFlags(args []string) (packageNames, passToTest []string) {\n \t\tif !testC {\n \t\t\tbuildFlag = \"-i\"\n \t\t}\n-\t\tfmt.Fprintf(os.Stderr, \"flag %s is not a 'go test' flag (unknown flags cannot be used with %s)\\n\", firstUnknownFlag, buildFlag)\n+\t\tfmt.Fprintf(os.Stderr, \"go test: unknown flag %s cannot be used with %s\\n\", firstUnknownFlag, buildFlag)\n \t\texitWithUsage()\n \t}\n "}, {"sha": "95c90ea7c8da4a3f5121af3d78db4b80d8b18f65", "filename": "libgo/go/cmd/go/internal/tool/tool.go", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftool%2Ftool.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftool%2Ftool.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftool%2Ftool.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -8,8 +8,9 @@ package tool\n import (\n \t\"context\"\n \t\"fmt\"\n+\texec \"internal/execabs\"\n \t\"os\"\n-\t\"os/exec\"\n+\t\"os/signal\"\n \t\"sort\"\n \t\"strings\"\n \n@@ -85,7 +86,19 @@ func runTool(ctx context.Context, cmd *base.Command, args []string) {\n \t\tStdout: os.Stdout,\n \t\tStderr: os.Stderr,\n \t}\n-\terr := toolCmd.Run()\n+\terr := toolCmd.Start()\n+\tif err == nil {\n+\t\tc := make(chan os.Signal, 100)\n+\t\tsignal.Notify(c)\n+\t\tgo func() {\n+\t\t\tfor sig := range c {\n+\t\t\t\ttoolCmd.Process.Signal(sig)\n+\t\t\t}\n+\t\t}()\n+\t\terr = toolCmd.Wait()\n+\t\tsignal.Stop(c)\n+\t\tclose(c)\n+\t}\n \tif err != nil {\n \t\t// Only print about the exit status if the command\n \t\t// didn't even run (not an ExitError) or it didn't exit cleanly"}, {"sha": "9feffe07656e84fa7fc821e5b52250d85077bedf", "filename": "libgo/go/cmd/go/internal/vcs/vcs.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvcs%2Fvcs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvcs%2Fvcs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvcs%2Fvcs.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -8,13 +8,13 @@ import (\n \t\"encoding/json\"\n \t\"errors\"\n \t\"fmt\"\n+\texec \"internal/execabs\"\n \t\"internal/lazyregexp\"\n \t\"internal/singleflight\"\n \t\"io/fs\"\n \t\"log\"\n \turlpkg \"net/url\"\n \t\"os\"\n-\t\"os/exec\"\n \t\"path/filepath\"\n \t\"regexp\"\n \t\"strings\"\n@@ -729,7 +729,7 @@ func checkGOVCS(vcs *Cmd, root string) error {\n \t\tif private {\n \t\t\twhat = \"private\"\n \t\t}\n-\t\treturn fmt.Errorf(\"GOVCS disallows using %s for %s %s\", vcs.Cmd, what, root)\n+\t\treturn fmt.Errorf(\"GOVCS disallows using %s for %s %s; see 'go help vcs'\", vcs.Cmd, what, root)\n \t}\n \n \treturn nil"}, {"sha": "5bf5cf44467f144f27df7a267203c9745e1645e5", "filename": "libgo/go/cmd/go/internal/vet/vetflag.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvetflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvetflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvetflag.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -10,9 +10,9 @@ import (\n \t\"errors\"\n \t\"flag\"\n \t\"fmt\"\n+\texec \"internal/execabs\"\n \t\"log\"\n \t\"os\"\n-\t\"os/exec\"\n \t\"path/filepath\"\n \t\"strings\"\n "}, {"sha": "780d639c5d9f3e16cdc8e6b1bfbbc34245145617", "filename": "libgo/go/cmd/go/internal/work/build.go", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -9,9 +9,9 @@ import (\n \t\"errors\"\n \t\"fmt\"\n \t\"go/build\"\n+\texec \"internal/execabs\"\n \t\"internal/goroot\"\n \t\"os\"\n-\t\"os/exec\"\n \t\"path\"\n \t\"path/filepath\"\n \t\"runtime\"\n@@ -113,7 +113,10 @@ and test commands:\n \t\tcreated with -buildmode=shared.\n \t-mod mode\n \t\tmodule download mode to use: readonly, vendor, or mod.\n-\t\tSee 'go help modules' for more.\n+\t\tBy default, if a vendor directory is present and the go version in go.mod\n+\t\tis 1.14 or higher, the go command acts as if -mod=vendor were set.\n+\t\tOtherwise, the go command acts as if -mod=readonly were set.\n+\t\tSee https://golang.org/ref/mod#build-commands for details.\n \t-modcacherw\n \t\tleave newly-created directories in the module cache read-write\n \t\tinstead of making them read-only."}, {"sha": "c555d4a9f1ed036367fbfc0a0ed4d4e748919e09", "filename": "libgo/go/cmd/go/internal/work/buildid.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -7,8 +7,8 @@ package work\n import (\n \t\"bytes\"\n \t\"fmt\"\n+\texec \"internal/execabs\"\n \t\"os\"\n-\t\"os/exec\"\n \t\"strings\"\n \n \t\"cmd/go/internal/base\""}, {"sha": "f354f3086e4b71dab7a8c35e0f9b2bc30d994eac", "filename": "libgo/go/cmd/go/internal/work/exec.go", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -13,13 +13,13 @@ import (\n \t\"encoding/json\"\n \t\"errors\"\n \t\"fmt\"\n+\texec \"internal/execabs\"\n \t\"internal/lazyregexp\"\n \t\"io\"\n \t\"io/fs\"\n \t\"log\"\n \t\"math/rand\"\n \t\"os\"\n-\t\"os/exec\"\n \t\"path/filepath\"\n \t\"regexp\"\n \t\"runtime\"\n@@ -1166,6 +1166,7 @@ func (b *Builder) vet(ctx context.Context, a *Action) error {\n \t\treturn err\n \t}\n \n+\t// TODO(rsc): Why do we pass $GCCGO to go vet?\n \tenv := b.cCompilerEnv()\n \tif cfg.BuildToolchainName == \"gccgo\" {\n \t\tenv = append(env, \"GCCGO=\"+BuildToolchain.compiler())\n@@ -2046,6 +2047,9 @@ func (b *Builder) runOut(a *Action, dir string, env []string, cmdargs ...interfa\n \n \tvar buf bytes.Buffer\n \tcmd := exec.Command(cmdline[0], cmdline[1:]...)\n+\tif cmd.Path != \"\" {\n+\t\tcmd.Args[0] = cmd.Path\n+\t}\n \tcmd.Stdout = &buf\n \tcmd.Stderr = &buf\n \tcleanup := passLongArgsInResponseFiles(cmd)\n@@ -2437,7 +2441,7 @@ func (b *Builder) fcExe() []string {\n func (b *Builder) compilerExe(envValue string, def string) []string {\n \tcompiler := strings.Fields(envValue)\n \tif len(compiler) == 0 {\n-\t\tcompiler = []string{def}\n+\t\tcompiler = strings.Fields(def)\n \t}\n \treturn compiler\n }\n@@ -2589,7 +2593,14 @@ func (b *Builder) gccArchArgs() []string {\n \tcase \"386\":\n \t\treturn []string{\"-m32\"}\n \tcase \"amd64\":\n+\t\tif cfg.Goos == \"darwin\" {\n+\t\t\treturn []string{\"-arch\", \"x86_64\", \"-m64\"}\n+\t\t}\n \t\treturn []string{\"-m64\"}\n+\tcase \"arm64\":\n+\t\tif cfg.Goos == \"darwin\" {\n+\t\t\treturn []string{\"-arch\", \"arm64\"}\n+\t\t}\n \tcase \"arm\":\n \t\treturn []string{\"-marm\"} // not thumb\n \tcase \"s390x\":\n@@ -2721,7 +2732,7 @@ func (b *Builder) cgo(a *Action, cgoExe, objdir string, pcCFLAGS, pcLDFLAGS, cgo\n \t\tfor i, f := range cgoLDFLAGS {\n \t\t\tflags[i] = strconv.Quote(f)\n \t\t}\n-\t\tcgoenv = []string{\"CGO_LDFLAGS=\" + strings.Join(flags, \" \")}\n+\t\tcgoenv = append(cgoenv, \"CGO_LDFLAGS=\"+strings.Join(flags, \" \"))\n \t}\n \n \tif cfg.BuildToolchainName == \"gccgo\" {"}, {"sha": "36b3f4b05a02d8ef3c531b25315b3d48a812bf04", "filename": "libgo/go/cmd/go/internal/work/gccgo.go", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgccgo.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -6,8 +6,8 @@ package work\n \n import (\n \t\"fmt\"\n+\texec \"internal/execabs\"\n \t\"os\"\n-\t\"os/exec\"\n \t\"path/filepath\"\n \t\"strings\"\n \t\"sync\"\n@@ -93,6 +93,12 @@ func (tools gccgoToolchain) gc(b *Builder, a *Action, archive string, importcfg,\n \t\t\targs = append(args, \"-I\", root)\n \t\t}\n \t}\n+\tif embedcfg != nil && b.gccSupportsFlag(args[:1], \"-fgo-embedcfg=/dev/null\") {\n+\t\tif err := b.writeFile(objdir+\"embedcfg\", embedcfg); err != nil {\n+\t\t\treturn \"\", nil, err\n+\t\t}\n+\t\targs = append(args, \"-fgo-embedcfg=\"+objdir+\"embedcfg\")\n+\t}\n \n \tif b.gccSupportsFlag(args[:1], \"-ffile-prefix-map=a=b\") {\n \t\tif cfg.BuildTrimpath {"}, {"sha": "09fc8e713bcbcfbc9ad226567369df1f2387d446", "filename": "libgo/go/cmd/go/testdata/addmod.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Faddmod.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Faddmod.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Faddmod.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -25,7 +25,7 @@ import (\n \t\"io/fs\"\n \t\"log\"\n \t\"os\"\n-\t\"os/exec\"\n+\texec \"internal/execabs\"\n \t\"path/filepath\"\n \t\"strings\"\n "}, {"sha": "8a8cb4aa8c20f045a0c1e7c077bc950c35f95136", "filename": "libgo/go/cmd/go/testdata/script/link_syso_issue33139.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flink_syso_issue33139.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flink_syso_issue33139.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flink_syso_issue33139.txt?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -2,7 +2,7 @@\n # embedded in a package, that is referenced by a Go assembly function.\n # See issue 33139.\n [!gc] skip\n-[!exec:cc] skip\n+[!cgo] skip\n \n # External linking is not supported on linux/ppc64.\n # See: https://github.com/golang/go/issues/8912"}, {"sha": "7a270d0f07cac7fa76a670037dbb6678536db7d6", "filename": "libgo/go/cmd/go/testdata/script/mod_bad_domain.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_bad_domain.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_bad_domain.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_bad_domain.txt?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -19,7 +19,7 @@ stderr 'malformed module path \"x/y.z\": missing dot in first path element'\n ! go build ./useappengine\n stderr '^useappengine[/\\\\]x.go:2:8: cannot find package$'\n ! go build ./usenonexistent\n-stderr '^usenonexistent[/\\\\]x.go:2:8: no required module provides package nonexistent.rsc.io; try ''go mod tidy'' to add it$'\n+stderr '^usenonexistent[/\\\\]x.go:2:8: no required module provides package nonexistent.rsc.io; to add it:\\n\\tgo get nonexistent.rsc.io$'\n \n \n # 'get -d' should be similarly definitive"}, {"sha": "d7e681e831397b56160bd2aab4f668712abe400f", "filename": "libgo/go/cmd/go/testdata/script/mod_edit.txt", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_edit.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_edit.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_edit.txt?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -21,6 +21,12 @@ cmpenv go.mod $WORK/go.mod.edit1\n go mod edit -droprequire=x.1 -dropexclude=x.1@v1.2.1 -dropreplace=x.1@v1.3.0 -require=x.3@v1.99.0 -dropretract=v1.0.0 -dropretract=[v1.1.0,v1.2.0]\n cmpenv go.mod $WORK/go.mod.edit2\n \n+# -exclude and -retract reject invalid versions.\n+! go mod edit -exclude=example.com/m@bad\n+stderr '^go mod: -exclude=example.com/m@bad: version \"bad\" invalid: must be of the form v1.2.3$'\n+! go mod edit -retract=bad\n+stderr '^go mod: -retract=bad: version \"bad\" invalid: must be of the form v1.2.3$'\n+\n # go mod edit -json\n go mod edit -json\n cmpenv stdout $WORK/go.mod.json"}, {"sha": "9733fa366bea57eb19370d6cb125c87933f845f9", "filename": "libgo/go/cmd/go/testdata/script/mod_get_fallback.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_fallback.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_fallback.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_fallback.txt?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -6,5 +6,5 @@ env GOPROXY=https://proxy.golang.org,direct\n env GOSUMDB=off\n \n go get -x -v -d golang.org/x/tools/cmd/goimports\n-stderr '# get https://proxy.golang.org/golang.org/x/tools/@latest'\n+stderr '# get https://proxy.golang.org/golang.org/x/tools/@v/list'\n ! stderr '# get https://golang.org'"}, {"sha": "c13ae844b56739d1a265d3cc60b1ee39b2d926ac", "filename": "libgo/go/cmd/go/testdata/script/mod_gobuild_import.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_gobuild_import.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_gobuild_import.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_gobuild_import.txt?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -19,7 +19,7 @@ exec $WORK/testimport$GOEXE other/x/y/z/w .\n stdout w2.go\n \n ! exec $WORK/testimport$GOEXE gobuild.example.com/x/y/z/w .\n-stderr 'no required module provides package gobuild.example.com/x/y/z/w; try ''go get -d gobuild.example.com/x/y/z/w'' to add it'\n+stderr 'no required module provides package gobuild.example.com/x/y/z/w; to add it:\\n\\tgo get gobuild.example.com/x/y/z/w'\n \n cd z\n exec $WORK/testimport$GOEXE other/x/y/z/w ."}, {"sha": "b128408a612a4163ed58d9470e1f63a929b28063", "filename": "libgo/go/cmd/go/testdata/script/mod_list_bad_import.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_bad_import.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_bad_import.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_bad_import.txt?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -39,7 +39,7 @@ stdout example.com/notfound\n \n # Listing the missing dependency directly should fail outright...\n ! go list -f '{{if .Error}}error{{end}} {{if .Incomplete}}incomplete{{end}}' example.com/notfound\n-stderr 'no required module provides package example.com/notfound; try ''go get -d example.com/notfound'' to add it'\n+stderr 'no required module provides package example.com/notfound; to add it:\\n\\tgo get example.com/notfound'\n ! stdout error\n ! stdout incomplete\n "}, {"sha": "176be7296794a7ebf38b1be8c8f1188840ec2a80", "filename": "libgo/go/cmd/go/testdata/script/mod_readonly.txt", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_readonly.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_readonly.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_readonly.txt?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -13,7 +13,7 @@ cmp go.mod go.mod.empty\n # -mod=readonly should be set by default.\n env GOFLAGS=\n ! go list all\n-stderr '^x.go:2:8: no required module provides package rsc\\.io/quote; try ''go mod tidy'' to add it$'\n+stderr '^x.go:2:8: no required module provides package rsc\\.io/quote; to add it:\\n\\tgo get rsc\\.io/quote$'\n cmp go.mod go.mod.empty\n \n env GOFLAGS=-mod=readonly\n@@ -51,7 +51,7 @@ cmp go.mod go.mod.inconsistent\n # We get a different message when -mod=readonly is used by default.\n env GOFLAGS=\n ! go list\n-stderr '^go: updates to go.mod needed; try ''go mod tidy'' first$'\n+stderr '^go: updates to go.mod needed; to update it:\\n\\tgo mod tidy'\n \n # However, it should not reject files missing a 'go' directive,\n # since that was not always required.\n@@ -75,15 +75,15 @@ cmp go.mod go.mod.indirect\n \n cp go.mod.untidy go.mod\n ! go list all\n-stderr '^x.go:2:8: no required module provides package rsc.io/quote; try ''go mod tidy'' to add it$'\n+stderr '^x.go:2:8: no required module provides package rsc.io/quote; to add it:\\n\\tgo get rsc.io/quote$'\n \n ! go list -deps .\n-stderr '^x.go:2:8: no required module provides package rsc.io/quote; try ''go mod tidy'' to add it$'\n+stderr '^x.go:2:8: no required module provides package rsc.io/quote; to add it:\\n\\tgo get rsc.io/quote$'\n \n # However, if we didn't see an import from the main module, we should suggest\n # 'go get -d' instead, because we don't know whether 'go mod tidy' would add it.\n ! go list rsc.io/quote\n-stderr '^no required module provides package rsc.io/quote; try ''go get -d rsc.io/quote'' to add it$'\n+stderr '^no required module provides package rsc.io/quote; to add it:\\n\\tgo get rsc.io/quote$'\n \n \n -- go.mod --"}, {"sha": "b0ea907206a44902b6001a8df73bd80d283f7893", "filename": "libgo/go/cmd/go/testdata/script/mod_vendor_auto.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor_auto.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor_auto.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor_auto.txt?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -66,7 +66,7 @@ stderr '^go: inconsistent vendoring in '$WORK[/\\\\]auto':$'\n stderr '^\\texample.com/printversion@v1.0.0: is explicitly required in go.mod, but not marked as explicit in vendor/modules.txt'\n stderr '^\\texample.com/unused: is replaced in go.mod, but not marked as replaced in vendor/modules.txt'\n stderr '^\\texample.com/version@v1.2.0: is replaced in go.mod, but not marked as replaced in vendor/modules.txt'\n-stderr '\\n\\nrun .go mod vendor. to sync, or use -mod=mod or -mod=readonly to ignore the vendor directory$'\n+stderr '^\\tTo ignore the vendor directory, use -mod=readonly or -mod=mod.\\n\\tTo sync the vendor directory, run:\\n\\t\\tgo mod vendor$'\n \n # Module-specific subcommands should continue to load the full module graph.\n go mod graph\n@@ -135,7 +135,7 @@ stderr '^go: inconsistent vendoring in '$WORK[/\\\\]auto':$'\n stderr '^\\texample.com/printversion@v1.0.0: is explicitly required in go.mod, but not marked as explicit in vendor/modules.txt'\n stderr '^\\texample.com/unused: is replaced in go.mod, but not marked as replaced in vendor/modules.txt'\n stderr '^\\texample.com/version@v1.2.0: is replaced in go.mod, but not marked as replaced in vendor/modules.txt'\n-stderr '\\n\\nrun .go mod vendor. to sync, or use -mod=mod or -mod=readonly to ignore the vendor directory$'\n+stderr '^\\tTo ignore the vendor directory, use -mod=readonly or -mod=mod.\\n\\tTo sync the vendor directory, run:\\n\\t\\tgo mod vendor$'\n \n # If -mod=vendor is set, limited consistency checks should apply even when\n # the go version is 1.13 or earlier.\n@@ -151,7 +151,7 @@ cp $WORK/modules-bad-1.13.txt vendor/modules.txt\n ! go list -mod=vendor -f {{.Dir}} -tags tools all\n stderr '^go: inconsistent vendoring in '$WORK[/\\\\]auto':$'\n stderr '^\\texample.com/printversion@v1.0.0: is explicitly required in go.mod, but vendor/modules.txt indicates example.com/printversion@v1.1.0$'\n-stderr '\\n\\nrun .go mod vendor. to sync, or use -mod=mod or -mod=readonly to ignore the vendor directory$'\n+stderr '^\\tTo ignore the vendor directory, use -mod=readonly or -mod=mod.\\n\\tTo sync the vendor directory, run:\\n\\t\\tgo mod vendor$'\n \n # If the go version is still 1.13, 'go mod vendor' should write a\n # matching vendor/modules.txt containing the corrected 1.13 data."}, {"sha": "9e6322bae117f778289477642521666befe32ab4", "filename": "libgo/go/cmd/go/testdata/script/mod_versions.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_versions.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_versions.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_versions.txt?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -1,14 +1,14 @@\n # Test rejection of pkg@version in GOPATH mode.\n env GO111MODULE=off\n ! go get rsc.io/quote@v1.5.1\n-stderr 'cannot use path@version syntax in GOPATH mode'\n+stderr '^go: can only use path@version syntax with ''go get'' and ''go install'' in module-aware mode$'\n ! go build rsc.io/quote@v1.5.1\n-stderr 'cannot use path@version syntax in GOPATH mode'\n+stderr '^package rsc.io/quote@v1.5.1: can only use path@version syntax with ''go get'' and ''go install'' in module-aware mode$'\n \n env GO111MODULE=on\n cd x\n ! go build rsc.io/quote@v1.5.1\n-stderr 'can only use path@version syntax with ''go get'''\n+stderr '^package rsc.io/quote@v1.5.1: can only use path@version syntax with ''go get'' and ''go install'' in module-aware mode$'\n \n -- x/go.mod --\n module x"}, {"sha": "577d31789f19afcb768e847cd69d2714e4d48b06", "filename": "libgo/go/cmd/internal/browser/browser.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Finternal%2Fbrowser%2Fbrowser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Finternal%2Fbrowser%2Fbrowser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fbrowser%2Fbrowser.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -6,8 +6,8 @@\n package browser\n \n import (\n+\texec \"internal/execabs\"\n \t\"os\"\n-\t\"os/exec\"\n \t\"runtime\"\n \t\"time\"\n )"}, {"sha": "fdf681a8ffe564cc07715b7c218b789345446d27", "filename": "libgo/go/cmd/test2json/main.go", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Ftest2json%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Ftest2json%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Ftest2json%2Fmain.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -6,7 +6,7 @@\n //\n // Usage:\n //\n-//\tgo tool test2json [-p pkg] [-t] [./pkg.test -test.v]\n+//\tgo tool test2json [-p pkg] [-t] [./pkg.test -test.v [-test.paniconexit0]]\n //\n // Test2json runs the given test command and converts its output to JSON;\n // with no command specified, test2json expects test output on standard input.\n@@ -18,6 +18,10 @@\n //\n // The -t flag requests that time stamps be added to each test event.\n //\n+// The test must be invoked with -test.v. Additionally passing\n+// -test.paniconexit0 will cause test2json to exit with a non-zero\n+// status if one of the tests being run calls os.Exit(0).\n+//\n // Note that test2json is only intended for converting a single test\n // binary's output. To convert the output of a \"go test\" command,\n // use \"go test -json\" instead of invoking test2json directly.\n@@ -82,9 +86,9 @@ package main\n import (\n \t\"flag\"\n \t\"fmt\"\n+\texec \"internal/execabs\"\n \t\"io\"\n \t\"os\"\n-\t\"os/exec\"\n \n \t\"cmd/internal/test2json\"\n )"}, {"sha": "e033984956bbc87667807daf5d22979ec8519e40", "filename": "libgo/go/cmd/vendor/modules.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fvendor%2Fmodules.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcmd%2Fvendor%2Fmodules.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvendor%2Fmodules.txt?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -28,7 +28,7 @@ golang.org/x/arch/x86/x86asm\n golang.org/x/crypto/ed25519\n golang.org/x/crypto/ed25519/internal/edwards25519\n golang.org/x/crypto/ssh/terminal\n-# golang.org/x/mod v0.4.0\n+# golang.org/x/mod v0.4.1\n ## explicit\n golang.org/x/mod/internal/lazyregexp\n golang.org/x/mod/modfile\n@@ -44,7 +44,7 @@ golang.org/x/mod/zip\n golang.org/x/sys/internal/unsafeheader\n golang.org/x/sys/unix\n golang.org/x/sys/windows\n-# golang.org/x/tools v0.0.0-20201211025543-abf6a1d87e11\n+# golang.org/x/tools v0.0.0-20210107193943-4ed967dd8eff\n ## explicit\n golang.org/x/tools/go/analysis\n golang.org/x/tools/go/analysis/internal/analysisflags"}, {"sha": "8c76021464207f4f78a1bd0a7bc3d7d8e7bbb20e", "filename": "libgo/go/crypto/elliptic/p224.go", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -386,21 +386,25 @@ func p224Invert(out, in *p224FieldElement) {\n // p224Contract converts a FieldElement to its unique, minimal form.\n //\n // On entry, in[i] < 2**29\n-// On exit, in[i] < 2**28\n+// On exit, out[i] < 2**28 and out < p\n func p224Contract(out, in *p224FieldElement) {\n \tcopy(out[:], in[:])\n \n+\t// First, carry the bits above 28 to the higher limb.\n \tfor i := 0; i < 7; i++ {\n \t\tout[i+1] += out[i] >> 28\n \t\tout[i] &= bottom28Bits\n \t}\n \ttop := out[7] >> 28\n \tout[7] &= bottom28Bits\n \n+\t// Use the reduction identity to carry the overflow.\n+\t//\n+\t//   a + top * 2\u00b2\u00b2\u2074 = a + top * 2\u2079\u2076 - top\n \tout[0] -= top\n \tout[3] += top << 12\n \n-\t// We may just have made out[i] negative. So we carry down. If we made\n+\t// We may just have made out[0] negative. So we carry down. If we made\n \t// out[0] negative then we know that out[3] is sufficiently positive\n \t// because we just added to it.\n \tfor i := 0; i < 3; i++ {\n@@ -425,13 +429,12 @@ func p224Contract(out, in *p224FieldElement) {\n \t// There are two cases to consider for out[3]:\n \t//   1) The first time that we eliminated top, we didn't push out[3] over\n \t//      2**28. In this case, the partial carry chain didn't change any values\n-\t//      and top is zero.\n+\t//      and top is now zero.\n \t//   2) We did push out[3] over 2**28 the first time that we eliminated top.\n-\t//      The first value of top was in [0..16), therefore, prior to eliminating\n-\t//      the first top, 0xfff1000 <= out[3] <= 0xfffffff. Therefore, after\n-\t//      overflowing and being reduced by the second carry chain, out[3] <=\n-\t//      0xf000. Thus it cannot have overflowed when we eliminated top for the\n-\t//      second time.\n+\t//      The first value of top was in [0..2], therefore, after overflowing\n+\t//      and being reduced by the second carry chain, out[3] <= 2<<12 - 1.\n+\t// In both cases, out[3] cannot have overflowed when we eliminated top for\n+\t// the second time.\n \n \t// Again, we may just have made out[0] negative, so do the same carry down.\n \t// As before, if we made out[0] negative then we know that out[3] is\n@@ -470,12 +473,11 @@ func p224Contract(out, in *p224FieldElement) {\n \tbottom3NonZero |= bottom3NonZero >> 1\n \tbottom3NonZero = uint32(int32(bottom3NonZero<<31) >> 31)\n \n-\t// Everything depends on the value of out[3].\n-\t//    If it's > 0xffff000 and top4AllOnes != 0 then the whole value is >= p\n-\t//    If it's = 0xffff000 and top4AllOnes != 0 and bottom3NonZero != 0,\n-\t//      then the whole value is >= p\n+\t// Assuming top4AllOnes != 0, everything depends on the value of out[3].\n+\t//    If it's > 0xffff000 then the whole value is > p\n+\t//    If it's = 0xffff000 and bottom3NonZero != 0, then the whole value is >= p\n \t//    If it's < 0xffff000, then the whole value is < p\n-\tn := out[3] - 0xffff000\n+\tn := 0xffff000 - out[3]\n \tout3Equal := n\n \tout3Equal |= out3Equal >> 16\n \tout3Equal |= out3Equal >> 8\n@@ -484,8 +486,8 @@ func p224Contract(out, in *p224FieldElement) {\n \tout3Equal |= out3Equal >> 1\n \tout3Equal = ^uint32(int32(out3Equal<<31) >> 31)\n \n-\t// If out[3] > 0xffff000 then n's MSB will be zero.\n-\tout3GT := ^uint32(int32(n) >> 31)\n+\t// If out[3] > 0xffff000 then n's MSB will be one.\n+\tout3GT := uint32(int32(n) >> 31)\n \n \tmask := top4AllOnes & ((out3Equal & bottom3NonZero) | out3GT)\n \tout[0] -= 1 & mask\n@@ -494,6 +496,15 @@ func p224Contract(out, in *p224FieldElement) {\n \tout[5] -= 0xfffffff & mask\n \tout[6] -= 0xfffffff & mask\n \tout[7] -= 0xfffffff & mask\n+\n+\t// Do one final carry down, in case we made out[0] negative. One of\n+\t// out[0..3] needs to be positive and able to absorb the -1 or the value\n+\t// would have been < p, and the subtraction wouldn't have happened.\n+\tfor i := 0; i < 3; i++ {\n+\t\tmask := uint32(int32(out[i]) >> 31)\n+\t\tout[i] += (1 << 28) & mask\n+\t\tout[i+1] -= 1 & mask\n+\t}\n }\n \n // Group element functions."}, {"sha": "c3141b6ab4de0b00ec7382cff55b2d47b8ab1d0d", "filename": "libgo/go/crypto/elliptic/p224_test.go", "status": "modified", "additions": 272, "deletions": 5, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -6,7 +6,11 @@ package elliptic\n \n import (\n \t\"math/big\"\n+\t\"math/bits\"\n+\t\"math/rand\"\n+\t\"reflect\"\n \t\"testing\"\n+\t\"testing/quick\"\n )\n \n var toFromBigTests = []string{\n@@ -21,16 +25,16 @@ func p224AlternativeToBig(in *p224FieldElement) *big.Int {\n \tret := new(big.Int)\n \ttmp := new(big.Int)\n \n-\tfor i := uint(0); i < 8; i++ {\n+\tfor i := len(in) - 1; i >= 0; i-- {\n+\t\tret.Lsh(ret, 28)\n \t\ttmp.SetInt64(int64(in[i]))\n-\t\ttmp.Lsh(tmp, 28*i)\n \t\tret.Add(ret, tmp)\n \t}\n-\tret.Mod(ret, p224.P)\n+\tret.Mod(ret, P224().Params().P)\n \treturn ret\n }\n \n-func TestToFromBig(t *testing.T) {\n+func TestP224ToFromBig(t *testing.T) {\n \tfor i, test := range toFromBigTests {\n \t\tn, _ := new(big.Int).SetString(test, 16)\n \t\tvar x p224FieldElement\n@@ -41,7 +45,270 @@ func TestToFromBig(t *testing.T) {\n \t\t}\n \t\tq := p224AlternativeToBig(&x)\n \t\tif n.Cmp(q) != 0 {\n-\t\t\tt.Errorf(\"#%d: %x != %x (alternative)\", i, n, m)\n+\t\t\tt.Errorf(\"#%d: %x != %x (alternative)\", i, n, q)\n \t\t}\n \t}\n }\n+\n+// quickCheckConfig32 will make each quickcheck test run (32 * -quickchecks)\n+// times. The default value of -quickchecks is 100.\n+var quickCheckConfig32 = &quick.Config{MaxCountScale: 32}\n+\n+// weirdLimbs can be combined to generate a range of edge-case field elements.\n+var weirdLimbs = [...]uint32{\n+\t0, 1, (1 << 29) - 1,\n+\t(1 << 12), (1 << 12) - 1,\n+\t(1 << 28), (1 << 28) - 1,\n+}\n+\n+func generateLimb(rand *rand.Rand) uint32 {\n+\tconst bottom29Bits = 0x1fffffff\n+\tn := rand.Intn(len(weirdLimbs) + 3)\n+\tswitch n {\n+\tcase len(weirdLimbs):\n+\t\t// Random value.\n+\t\treturn uint32(rand.Int31n(1 << 29))\n+\tcase len(weirdLimbs) + 1:\n+\t\t// Sum of two values.\n+\t\tk := generateLimb(rand) + generateLimb(rand)\n+\t\treturn k & bottom29Bits\n+\tcase len(weirdLimbs) + 2:\n+\t\t// Difference of two values.\n+\t\tk := generateLimb(rand) - generateLimb(rand)\n+\t\treturn k & bottom29Bits\n+\tdefault:\n+\t\treturn weirdLimbs[n]\n+\t}\n+}\n+\n+func (p224FieldElement) Generate(rand *rand.Rand, size int) reflect.Value {\n+\treturn reflect.ValueOf(p224FieldElement{\n+\t\tgenerateLimb(rand),\n+\t\tgenerateLimb(rand),\n+\t\tgenerateLimb(rand),\n+\t\tgenerateLimb(rand),\n+\t\tgenerateLimb(rand),\n+\t\tgenerateLimb(rand),\n+\t\tgenerateLimb(rand),\n+\t\tgenerateLimb(rand),\n+\t})\n+}\n+\n+func isInBounds(x *p224FieldElement) bool {\n+\treturn bits.Len32(x[0]) <= 29 &&\n+\t\tbits.Len32(x[1]) <= 29 &&\n+\t\tbits.Len32(x[2]) <= 29 &&\n+\t\tbits.Len32(x[3]) <= 29 &&\n+\t\tbits.Len32(x[4]) <= 29 &&\n+\t\tbits.Len32(x[5]) <= 29 &&\n+\t\tbits.Len32(x[6]) <= 29 &&\n+\t\tbits.Len32(x[7]) <= 29\n+}\n+\n+func TestP224Mul(t *testing.T) {\n+\tmulMatchesBigInt := func(a, b, out p224FieldElement) bool {\n+\t\tvar tmp p224LargeFieldElement\n+\t\tp224Mul(&out, &a, &b, &tmp)\n+\n+\t\texp := new(big.Int).Mul(p224AlternativeToBig(&a), p224AlternativeToBig(&b))\n+\t\texp.Mod(exp, P224().Params().P)\n+\t\tgot := p224AlternativeToBig(&out)\n+\t\tif exp.Cmp(got) != 0 || !isInBounds(&out) {\n+\t\t\tt.Logf(\"a = %x\", a)\n+\t\t\tt.Logf(\"b = %x\", b)\n+\t\t\tt.Logf(\"p224Mul(a, b) = %x = %v\", out, got)\n+\t\t\tt.Logf(\"a * b = %v\", exp)\n+\t\t\treturn false\n+\t\t}\n+\n+\t\treturn true\n+\t}\n+\n+\ta := p224FieldElement{0xfffffff, 0xfffffff, 0xf00ffff, 0x20f, 0x0, 0x0, 0x0, 0x0}\n+\tb := p224FieldElement{1, 0, 0, 0, 0, 0, 0, 0}\n+\tif !mulMatchesBigInt(a, b, p224FieldElement{}) {\n+\t\tt.Fail()\n+\t}\n+\n+\tif err := quick.Check(mulMatchesBigInt, quickCheckConfig32); err != nil {\n+\t\tt.Error(err)\n+\t}\n+}\n+\n+func TestP224Square(t *testing.T) {\n+\tsquareMatchesBigInt := func(a, out p224FieldElement) bool {\n+\t\tvar tmp p224LargeFieldElement\n+\t\tp224Square(&out, &a, &tmp)\n+\n+\t\texp := p224AlternativeToBig(&a)\n+\t\texp.Mul(exp, exp)\n+\t\texp.Mod(exp, P224().Params().P)\n+\t\tgot := p224AlternativeToBig(&out)\n+\t\tif exp.Cmp(got) != 0 || !isInBounds(&out) {\n+\t\t\tt.Logf(\"a = %x\", a)\n+\t\t\tt.Logf(\"p224Square(a, b) = %x = %v\", out, got)\n+\t\t\tt.Logf(\"a * a = %v\", exp)\n+\t\t\treturn false\n+\t\t}\n+\n+\t\treturn true\n+\t}\n+\n+\tif err := quick.Check(squareMatchesBigInt, quickCheckConfig32); err != nil {\n+\t\tt.Error(err)\n+\t}\n+}\n+\n+func TestP224Add(t *testing.T) {\n+\taddMatchesBigInt := func(a, b, out p224FieldElement) bool {\n+\t\tp224Add(&out, &a, &b)\n+\n+\t\texp := new(big.Int).Add(p224AlternativeToBig(&a), p224AlternativeToBig(&b))\n+\t\texp.Mod(exp, P224().Params().P)\n+\t\tgot := p224AlternativeToBig(&out)\n+\t\tif exp.Cmp(got) != 0 {\n+\t\t\tt.Logf(\"a = %x\", a)\n+\t\t\tt.Logf(\"b = %x\", b)\n+\t\t\tt.Logf(\"p224Add(a, b) = %x = %v\", out, got)\n+\t\t\tt.Logf(\"a + b = %v\", exp)\n+\t\t\treturn false\n+\t\t}\n+\n+\t\treturn true\n+\t}\n+\n+\tif err := quick.Check(addMatchesBigInt, quickCheckConfig32); err != nil {\n+\t\tt.Error(err)\n+\t}\n+}\n+\n+func TestP224Reduce(t *testing.T) {\n+\treduceMatchesBigInt := func(a p224FieldElement) bool {\n+\t\tout := a\n+\t\t// TODO: generate higher values for functions like p224Reduce that are\n+\t\t// expected to work with higher input bounds.\n+\t\tp224Reduce(&out)\n+\n+\t\texp := p224AlternativeToBig(&a)\n+\t\tgot := p224AlternativeToBig(&out)\n+\t\tif exp.Cmp(got) != 0 || !isInBounds(&out) {\n+\t\t\tt.Logf(\"a = %x = %v\", a, exp)\n+\t\t\tt.Logf(\"p224Reduce(a) = %x = %v\", out, got)\n+\t\t\treturn false\n+\t\t}\n+\n+\t\treturn true\n+\t}\n+\n+\tif err := quick.Check(reduceMatchesBigInt, quickCheckConfig32); err != nil {\n+\t\tt.Error(err)\n+\t}\n+}\n+\n+func TestP224Contract(t *testing.T) {\n+\tcontractMatchesBigInt := func(a, out p224FieldElement) bool {\n+\t\tp224Contract(&out, &a)\n+\n+\t\texp := p224AlternativeToBig(&a)\n+\t\tgot := p224AlternativeToBig(&out)\n+\t\tif exp.Cmp(got) != 0 {\n+\t\t\tt.Logf(\"a = %x = %v\", a, exp)\n+\t\t\tt.Logf(\"p224Contract(a) = %x = %v\", out, got)\n+\t\t\treturn false\n+\t\t}\n+\n+\t\t// Check that out < P.\n+\t\tfor i := range p224P {\n+\t\t\tk := 8 - i - 1\n+\t\t\tif out[k] > p224P[k] {\n+\t\t\t\tt.Logf(\"p224Contract(a) = %x\", out)\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\tif out[k] < p224P[k] {\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t}\n+\t\tt.Logf(\"p224Contract(a) = %x\", out)\n+\t\treturn false\n+\t}\n+\n+\tif !contractMatchesBigInt(p224P, p224FieldElement{}) {\n+\t\tt.Error(\"p224Contract(p) is broken\")\n+\t}\n+\tpMinus1 := p224FieldElement{0, 0, 0, 0xffff000, 0xfffffff, 0xfffffff, 0xfffffff, 0xfffffff}\n+\tif !contractMatchesBigInt(pMinus1, p224FieldElement{}) {\n+\t\tt.Error(\"p224Contract(p - 1) is broken\")\n+\t}\n+\t// Check that we can handle input above p, but lowest limb zero.\n+\ta := p224FieldElement{0, 1, 0, 0xffff000, 0xfffffff, 0xfffffff, 0xfffffff, 0xfffffff}\n+\tif !contractMatchesBigInt(a, p224FieldElement{}) {\n+\t\tt.Error(\"p224Contract(p + 2\u00b2\u2078) is broken\")\n+\t}\n+\t// Check that we can handle input above p, but lowest three limbs zero.\n+\tb := p224FieldElement{0, 0, 0, 0xffff001, 0xfffffff, 0xfffffff, 0xfffffff, 0xfffffff}\n+\tif !contractMatchesBigInt(b, p224FieldElement{}) {\n+\t\tt.Error(\"p224Contract(p + 2\u2078\u2074) is broken\")\n+\t}\n+\n+\tif err := quick.Check(contractMatchesBigInt, quickCheckConfig32); err != nil {\n+\t\tt.Error(err)\n+\t}\n+}\n+\n+func TestP224IsZero(t *testing.T) {\n+\tif got := p224IsZero(&p224FieldElement{}); got != 1 {\n+\t\tt.Errorf(\"p224IsZero(0) = %d, expected 1\", got)\n+\t}\n+\tif got := p224IsZero((*p224FieldElement)(&p224P)); got != 1 {\n+\t\tt.Errorf(\"p224IsZero(p) = %d, expected 1\", got)\n+\t}\n+\tif got := p224IsZero(&p224FieldElement{1}); got != 0 {\n+\t\tt.Errorf(\"p224IsZero(1) = %d, expected 0\", got)\n+\t}\n+\n+\tisZeroMatchesBigInt := func(a p224FieldElement) bool {\n+\t\tisZero := p224IsZero(&a)\n+\n+\t\tbig := p224AlternativeToBig(&a)\n+\t\tif big.Sign() == 0 && isZero != 1 {\n+\t\t\treturn false\n+\t\t}\n+\t\tif big.Sign() != 0 && isZero != 0 {\n+\t\t\treturn false\n+\t\t}\n+\t\treturn true\n+\t}\n+\n+\tif err := quick.Check(isZeroMatchesBigInt, quickCheckConfig32); err != nil {\n+\t\tt.Error(err)\n+\t}\n+}\n+\n+func TestP224Invert(t *testing.T) {\n+\tvar out p224FieldElement\n+\n+\tp224Invert(&out, &p224FieldElement{})\n+\tif got := p224IsZero(&out); got != 1 {\n+\t\tt.Errorf(\"p224Invert(0) = %x, expected 0\", out)\n+\t}\n+\n+\tp224Invert(&out, (*p224FieldElement)(&p224P))\n+\tif got := p224IsZero(&out); got != 1 {\n+\t\tt.Errorf(\"p224Invert(p) = %x, expected 0\", out)\n+\t}\n+\n+\tp224Invert(&out, &p224FieldElement{1})\n+\tp224Contract(&out, &out)\n+\tif out != (p224FieldElement{1}) {\n+\t\tt.Errorf(\"p224Invert(1) = %x, expected 1\", out)\n+\t}\n+\n+\tvar tmp p224LargeFieldElement\n+\ta := p224FieldElement{1, 2, 3, 4, 5, 6, 7, 8}\n+\tp224Invert(&out, &a)\n+\tp224Mul(&out, &out, &a, &tmp)\n+\tp224Contract(&out, &out)\n+\tif out != (p224FieldElement{1}) {\n+\t\tt.Errorf(\"p224Invert(a) * a = %x, expected 1\", out)\n+\t}\n+}"}, {"sha": "7379f1489adbf13bb41598f56c745b9e03fccd6d", "filename": "libgo/go/crypto/rand/rand_windows.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcrypto%2Frand%2Frand_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcrypto%2Frand%2Frand_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_windows.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -8,8 +8,8 @@\n package rand\n \n import (\n+\t\"internal/syscall/windows\"\n \t\"os\"\n-\t\"syscall\"\n )\n \n func init() { Reader = &rngReader{} }\n@@ -24,7 +24,7 @@ func (r *rngReader) Read(b []byte) (n int, err error) {\n \t\treturn 0, nil\n \t}\n \n-\terr = syscall.RtlGenRandom(&b[0], inputLen)\n+\terr = windows.RtlGenRandom(b)\n \tif err != nil {\n \t\treturn 0, os.NewSyscallError(\"RtlGenRandom\", err)\n \t}"}, {"sha": "eec6e1ebbd9060559637c9d2476046b2665a4bed", "filename": "libgo/go/crypto/tls/common.go", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -7,7 +7,6 @@ package tls\n import (\n \t\"bytes\"\n \t\"container/list\"\n-\t\"context\"\n \t\"crypto\"\n \t\"crypto/ecdsa\"\n \t\"crypto/ed25519\"\n@@ -444,16 +443,6 @@ type ClientHelloInfo struct {\n \t// config is embedded by the GetCertificate or GetConfigForClient caller,\n \t// for use with SupportsCertificate.\n \tconfig *Config\n-\n-\t// ctx is the context of the handshake that is in progress.\n-\tctx context.Context\n-}\n-\n-// Context returns the context of the handshake that is in progress.\n-// This context is a child of the context passed to HandshakeContext,\n-// if any, and is canceled when the handshake concludes.\n-func (c *ClientHelloInfo) Context() context.Context {\n-\treturn c.ctx\n }\n \n // CertificateRequestInfo contains information from a server's\n@@ -472,16 +461,6 @@ type CertificateRequestInfo struct {\n \n \t// Version is the TLS version that was negotiated for this connection.\n \tVersion uint16\n-\n-\t// ctx is the context of the handshake that is in progress.\n-\tctx context.Context\n-}\n-\n-// Context returns the context of the handshake that is in progress.\n-// This context is a child of the context passed to HandshakeContext,\n-// if any, and is canceled when the handshake concludes.\n-func (c *CertificateRequestInfo) Context() context.Context {\n-\treturn c.ctx\n }\n \n // RenegotiationSupport enumerates the different levels of support for TLS"}, {"sha": "72ad52c194baf49c988baf83340573ed0e54cd01", "filename": "libgo/go/crypto/tls/conn.go", "status": "modified", "additions": 4, "deletions": 58, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -8,7 +8,6 @@ package tls\n \n import (\n \t\"bytes\"\n-\t\"context\"\n \t\"crypto/cipher\"\n \t\"crypto/subtle\"\n \t\"crypto/x509\"\n@@ -28,7 +27,7 @@ type Conn struct {\n \t// constant\n \tconn        net.Conn\n \tisClient    bool\n-\thandshakeFn func(context.Context) error // (*Conn).clientHandshake or serverHandshake\n+\thandshakeFn func() error // (*Conn).clientHandshake or serverHandshake\n \n \t// handshakeStatus is 1 if the connection is currently transferring\n \t// application data (i.e. is not currently processing a handshake).\n@@ -1191,7 +1190,7 @@ func (c *Conn) handleRenegotiation() error {\n \tdefer c.handshakeMutex.Unlock()\n \n \tatomic.StoreUint32(&c.handshakeStatus, 0)\n-\tif c.handshakeErr = c.clientHandshake(context.Background()); c.handshakeErr == nil {\n+\tif c.handshakeErr = c.clientHandshake(); c.handshakeErr == nil {\n \t\tc.handshakes++\n \t}\n \treturn c.handshakeErr\n@@ -1374,61 +1373,8 @@ func (c *Conn) closeNotify() error {\n // first Read or Write will call it automatically.\n //\n // For control over canceling or setting a timeout on a handshake, use\n-// HandshakeContext or the Dialer's DialContext method instead.\n+// the Dialer's DialContext method.\n func (c *Conn) Handshake() error {\n-\treturn c.HandshakeContext(context.Background())\n-}\n-\n-// HandshakeContext runs the client or server handshake\n-// protocol if it has not yet been run.\n-//\n-// The provided Context must be non-nil. If the context is canceled before\n-// the handshake is complete, the handshake is interrupted and an error is returned.\n-// Once the handshake has completed, cancellation of the context will not affect the\n-// connection.\n-//\n-// Most uses of this package need not call HandshakeContext explicitly: the\n-// first Read or Write will call it automatically.\n-func (c *Conn) HandshakeContext(ctx context.Context) error {\n-\t// Delegate to unexported method for named return\n-\t// without confusing documented signature.\n-\treturn c.handshakeContext(ctx)\n-}\n-\n-func (c *Conn) handshakeContext(ctx context.Context) (ret error) {\n-\thandshakeCtx, cancel := context.WithCancel(ctx)\n-\t// Note: defer this before starting the \"interrupter\" goroutine\n-\t// so that we can tell the difference between the input being canceled and\n-\t// this cancellation. In the former case, we need to close the connection.\n-\tdefer cancel()\n-\n-\t// Start the \"interrupter\" goroutine, if this context might be canceled.\n-\t// (The background context cannot).\n-\t//\n-\t// The interrupter goroutine waits for the input context to be done and\n-\t// closes the connection if this happens before the function returns.\n-\tif ctx.Done() != nil {\n-\t\tdone := make(chan struct{})\n-\t\tinterruptRes := make(chan error, 1)\n-\t\tdefer func() {\n-\t\t\tclose(done)\n-\t\t\tif ctxErr := <-interruptRes; ctxErr != nil {\n-\t\t\t\t// Return context error to user.\n-\t\t\t\tret = ctxErr\n-\t\t\t}\n-\t\t}()\n-\t\tgo func() {\n-\t\t\tselect {\n-\t\t\tcase <-handshakeCtx.Done():\n-\t\t\t\t// Close the connection, discarding the error\n-\t\t\t\t_ = c.conn.Close()\n-\t\t\t\tinterruptRes <- handshakeCtx.Err()\n-\t\t\tcase <-done:\n-\t\t\t\tinterruptRes <- nil\n-\t\t\t}\n-\t\t}()\n-\t}\n-\n \tc.handshakeMutex.Lock()\n \tdefer c.handshakeMutex.Unlock()\n \n@@ -1442,7 +1388,7 @@ func (c *Conn) handshakeContext(ctx context.Context) (ret error) {\n \tc.in.Lock()\n \tdefer c.in.Unlock()\n \n-\tc.handshakeErr = c.handshakeFn(handshakeCtx)\n+\tc.handshakeErr = c.handshakeFn()\n \tif c.handshakeErr == nil {\n \t\tc.handshakes++\n \t} else {"}, {"sha": "e684b21d527223e850e8a74d802e9ac0521e9753", "filename": "libgo/go/crypto/tls/handshake_client.go", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -6,7 +6,6 @@ package tls\n \n import (\n \t\"bytes\"\n-\t\"context\"\n \t\"crypto\"\n \t\"crypto/ecdsa\"\n \t\"crypto/ed25519\"\n@@ -25,7 +24,6 @@ import (\n \n type clientHandshakeState struct {\n \tc            *Conn\n-\tctx          context.Context\n \tserverHello  *serverHelloMsg\n \thello        *clientHelloMsg\n \tsuite        *cipherSuite\n@@ -136,7 +134,7 @@ func (c *Conn) makeClientHello() (*clientHelloMsg, ecdheParameters, error) {\n \treturn hello, params, nil\n }\n \n-func (c *Conn) clientHandshake(ctx context.Context) (err error) {\n+func (c *Conn) clientHandshake() (err error) {\n \tif c.config == nil {\n \t\tc.config = defaultConfig()\n \t}\n@@ -200,7 +198,6 @@ func (c *Conn) clientHandshake(ctx context.Context) (err error) {\n \tif c.vers == VersionTLS13 {\n \t\ths := &clientHandshakeStateTLS13{\n \t\t\tc:           c,\n-\t\t\tctx:         ctx,\n \t\t\tserverHello: serverHello,\n \t\t\thello:       hello,\n \t\t\tecdheParams: ecdheParams,\n@@ -215,7 +212,6 @@ func (c *Conn) clientHandshake(ctx context.Context) (err error) {\n \n \ths := &clientHandshakeState{\n \t\tc:           c,\n-\t\tctx:         ctx,\n \t\tserverHello: serverHello,\n \t\thello:       hello,\n \t\tsession:     session,\n@@ -544,7 +540,7 @@ func (hs *clientHandshakeState) doFullHandshake() error {\n \t\tcertRequested = true\n \t\ths.finishedHash.Write(certReq.marshal())\n \n-\t\tcri := certificateRequestInfoFromMsg(hs.ctx, c.vers, certReq)\n+\t\tcri := certificateRequestInfoFromMsg(c.vers, certReq)\n \t\tif chainToSend, err = c.getClientCertificate(cri); err != nil {\n \t\t\tc.sendAlert(alertInternalError)\n \t\t\treturn err\n@@ -884,11 +880,10 @@ func (c *Conn) verifyServerCertificate(certificates [][]byte) error {\n \n // certificateRequestInfoFromMsg generates a CertificateRequestInfo from a TLS\n // <= 1.2 CertificateRequest, making an effort to fill in missing information.\n-func certificateRequestInfoFromMsg(ctx context.Context, vers uint16, certReq *certificateRequestMsg) *CertificateRequestInfo {\n+func certificateRequestInfoFromMsg(vers uint16, certReq *certificateRequestMsg) *CertificateRequestInfo {\n \tcri := &CertificateRequestInfo{\n \t\tAcceptableCAs: certReq.certificateAuthorities,\n \t\tVersion:       vers,\n-\t\tctx:           ctx,\n \t}\n \n \tvar rsaAvail, ecAvail bool"}, {"sha": "12b0254123e938a71dd6b8c0592db9cf235bf255", "filename": "libgo/go/crypto/tls/handshake_client_test.go", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -6,7 +6,6 @@ package tls\n \n import (\n \t\"bytes\"\n-\t\"context\"\n \t\"crypto/rsa\"\n \t\"crypto/x509\"\n \t\"encoding/base64\"\n@@ -21,7 +20,6 @@ import (\n \t\"os/exec\"\n \t\"path/filepath\"\n \t\"reflect\"\n-\t\"runtime\"\n \t\"strconv\"\n \t\"strings\"\n \t\"testing\"\n@@ -2513,37 +2511,3 @@ func testResumptionKeepsOCSPAndSCT(t *testing.T, ver uint16) {\n \t\t\tserverConfig.Certificates[0].SignedCertificateTimestamps, ccs.SignedCertificateTimestamps)\n \t}\n }\n-\n-func TestClientHandshakeContextCancellation(t *testing.T) {\n-\tc, s := localPipe(t)\n-\tserverConfig := testConfig.Clone()\n-\tserverErr := make(chan error, 1)\n-\tctx, cancel := context.WithCancel(context.Background())\n-\tdefer cancel()\n-\tgo func() {\n-\t\tdefer close(serverErr)\n-\t\tdefer s.Close()\n-\t\tconn := Server(s, serverConfig)\n-\t\t_, err := conn.readClientHello(ctx)\n-\t\tcancel()\n-\t\tserverErr <- err\n-\t}()\n-\tcli := Client(c, testConfig)\n-\terr := cli.HandshakeContext(ctx)\n-\tif err == nil {\n-\t\tt.Fatal(\"Client handshake did not error when the context was canceled\")\n-\t}\n-\tif err != context.Canceled {\n-\t\tt.Errorf(\"Unexpected client handshake error: %v\", err)\n-\t}\n-\tif err := <-serverErr; err != nil {\n-\t\tt.Errorf(\"Unexpected server error: %v\", err)\n-\t}\n-\tif runtime.GOARCH == \"wasm\" {\n-\t\tt.Skip(\"conn.Close does not error as expected when called multiple times on WASM\")\n-\t}\n-\terr = cli.Close()\n-\tif err == nil {\n-\t\tt.Error(\"Client connection was not closed when the context was canceled\")\n-\t}\n-}"}, {"sha": "daa5d97fd35548c4871a2f7f7ffa3b6e5da013a7", "filename": "libgo/go/crypto/tls/handshake_client_tls13.go", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_tls13.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_tls13.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_tls13.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -6,7 +6,6 @@ package tls\n \n import (\n \t\"bytes\"\n-\t\"context\"\n \t\"crypto\"\n \t\"crypto/hmac\"\n \t\"crypto/rsa\"\n@@ -18,7 +17,6 @@ import (\n \n type clientHandshakeStateTLS13 struct {\n \tc           *Conn\n-\tctx         context.Context\n \tserverHello *serverHelloMsg\n \thello       *clientHelloMsg\n \tecdheParams ecdheParameters\n@@ -557,7 +555,6 @@ func (hs *clientHandshakeStateTLS13) sendClientCertificate() error {\n \t\tAcceptableCAs:    hs.certReq.certificateAuthorities,\n \t\tSignatureSchemes: hs.certReq.supportedSignatureAlgorithms,\n \t\tVersion:          c.vers,\n-\t\tctx:              hs.ctx,\n \t})\n \tif err != nil {\n \t\treturn err"}, {"sha": "9c3e0f636ea7b548776ad75bf7ff112c65e7c571", "filename": "libgo/go/crypto/tls/handshake_server.go", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -5,7 +5,6 @@\n package tls\n \n import (\n-\t\"context\"\n \t\"crypto\"\n \t\"crypto/ecdsa\"\n \t\"crypto/ed25519\"\n@@ -24,7 +23,6 @@ import (\n // It's discarded once the handshake has completed.\n type serverHandshakeState struct {\n \tc            *Conn\n-\tctx          context.Context\n \tclientHello  *clientHelloMsg\n \thello        *serverHelloMsg\n \tsuite        *cipherSuite\n@@ -39,24 +37,22 @@ type serverHandshakeState struct {\n }\n \n // serverHandshake performs a TLS handshake as a server.\n-func (c *Conn) serverHandshake(ctx context.Context) error {\n-\tclientHello, err := c.readClientHello(ctx)\n+func (c *Conn) serverHandshake() error {\n+\tclientHello, err := c.readClientHello()\n \tif err != nil {\n \t\treturn err\n \t}\n \n \tif c.vers == VersionTLS13 {\n \t\ths := serverHandshakeStateTLS13{\n \t\t\tc:           c,\n-\t\t\tctx:         ctx,\n \t\t\tclientHello: clientHello,\n \t\t}\n \t\treturn hs.handshake()\n \t}\n \n \ths := serverHandshakeState{\n \t\tc:           c,\n-\t\tctx:         ctx,\n \t\tclientHello: clientHello,\n \t}\n \treturn hs.handshake()\n@@ -128,7 +124,7 @@ func (hs *serverHandshakeState) handshake() error {\n }\n \n // readClientHello reads a ClientHello message and selects the protocol version.\n-func (c *Conn) readClientHello(ctx context.Context) (*clientHelloMsg, error) {\n+func (c *Conn) readClientHello() (*clientHelloMsg, error) {\n \tmsg, err := c.readHandshake()\n \tif err != nil {\n \t\treturn nil, err\n@@ -142,7 +138,7 @@ func (c *Conn) readClientHello(ctx context.Context) (*clientHelloMsg, error) {\n \tvar configForClient *Config\n \toriginalConfig := c.config\n \tif c.config.GetConfigForClient != nil {\n-\t\tchi := clientHelloInfo(ctx, c, clientHello)\n+\t\tchi := clientHelloInfo(c, clientHello)\n \t\tif configForClient, err = c.config.GetConfigForClient(chi); err != nil {\n \t\t\tc.sendAlert(alertInternalError)\n \t\t\treturn nil, err\n@@ -224,7 +220,7 @@ func (hs *serverHandshakeState) processClientHello() error {\n \t\t}\n \t}\n \n-\ths.cert, err = c.config.getCertificate(clientHelloInfo(hs.ctx, c, hs.clientHello))\n+\ths.cert, err = c.config.getCertificate(clientHelloInfo(c, hs.clientHello))\n \tif err != nil {\n \t\tif err == errNoCertificates {\n \t\t\tc.sendAlert(alertUnrecognizedName)\n@@ -832,7 +828,7 @@ func (c *Conn) processCertsFromClient(certificate Certificate) error {\n \treturn nil\n }\n \n-func clientHelloInfo(ctx context.Context, c *Conn, clientHello *clientHelloMsg) *ClientHelloInfo {\n+func clientHelloInfo(c *Conn, clientHello *clientHelloMsg) *ClientHelloInfo {\n \tsupportedVersions := clientHello.supportedVersions\n \tif len(clientHello.supportedVersions) == 0 {\n \t\tsupportedVersions = supportedVersionsFromMax(clientHello.vers)\n@@ -848,6 +844,5 @@ func clientHelloInfo(ctx context.Context, c *Conn, clientHello *clientHelloMsg)\n \t\tSupportedVersions: supportedVersions,\n \t\tConn:              c.conn,\n \t\tconfig:            c.config,\n-\t\tctx:               ctx,\n \t}\n }"}, {"sha": "d6bf9e439b01c3e50b509085675ddf2a5953e60a", "filename": "libgo/go/crypto/tls/handshake_server_test.go", "status": "modified", "additions": 2, "deletions": 48, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -6,7 +6,6 @@ package tls\n \n import (\n \t\"bytes\"\n-\t\"context\"\n \t\"crypto\"\n \t\"crypto/elliptic\"\n \t\"crypto/x509\"\n@@ -18,7 +17,6 @@ import (\n \t\"os\"\n \t\"os/exec\"\n \t\"path/filepath\"\n-\t\"runtime\"\n \t\"strings\"\n \t\"testing\"\n \t\"time\"\n@@ -40,12 +38,10 @@ func testClientHelloFailure(t *testing.T, serverConfig *Config, m handshakeMessa\n \t\tcli.writeRecord(recordTypeHandshake, m.marshal())\n \t\tc.Close()\n \t}()\n-\tctx := context.Background()\n \tconn := Server(s, serverConfig)\n-\tch, err := conn.readClientHello(ctx)\n+\tch, err := conn.readClientHello()\n \ths := serverHandshakeState{\n \t\tc:           conn,\n-\t\tctx:         ctx,\n \t\tclientHello: ch,\n \t}\n \tif err == nil {\n@@ -1425,11 +1421,9 @@ func TestSNIGivenOnFailure(t *testing.T) {\n \t\tc.Close()\n \t}()\n \tconn := Server(s, serverConfig)\n-\tctx := context.Background()\n-\tch, err := conn.readClientHello(ctx)\n+\tch, err := conn.readClientHello()\n \ths := serverHandshakeState{\n \t\tc:           conn,\n-\t\tctx:         ctx,\n \t\tclientHello: ch,\n \t}\n \tif err == nil {\n@@ -1683,46 +1677,6 @@ func TestMultipleCertificates(t *testing.T) {\n \t}\n }\n \n-func TestServerHandshakeContextCancellation(t *testing.T) {\n-\tc, s := localPipe(t)\n-\tclientConfig := testConfig.Clone()\n-\tclientErr := make(chan error, 1)\n-\tctx, cancel := context.WithCancel(context.Background())\n-\tdefer cancel()\n-\tgo func() {\n-\t\tdefer close(clientErr)\n-\t\tdefer c.Close()\n-\t\tclientHello := &clientHelloMsg{\n-\t\t\tvers:               VersionTLS10,\n-\t\t\trandom:             make([]byte, 32),\n-\t\t\tcipherSuites:       []uint16{TLS_RSA_WITH_RC4_128_SHA},\n-\t\t\tcompressionMethods: []uint8{compressionNone},\n-\t\t}\n-\t\tcli := Client(c, clientConfig)\n-\t\t_, err := cli.writeRecord(recordTypeHandshake, clientHello.marshal())\n-\t\tcancel()\n-\t\tclientErr <- err\n-\t}()\n-\tconn := Server(s, testConfig)\n-\terr := conn.HandshakeContext(ctx)\n-\tif err == nil {\n-\t\tt.Fatal(\"Server handshake did not error when the context was canceled\")\n-\t}\n-\tif err != context.Canceled {\n-\t\tt.Errorf(\"Unexpected server handshake error: %v\", err)\n-\t}\n-\tif err := <-clientErr; err != nil {\n-\t\tt.Errorf(\"Unexpected client error: %v\", err)\n-\t}\n-\tif runtime.GOARCH == \"wasm\" {\n-\t\tt.Skip(\"conn.Close does not error as expected when called multiple times on WASM\")\n-\t}\n-\terr = conn.Close()\n-\tif err == nil {\n-\t\tt.Error(\"Server connection was not closed when the context was canceled\")\n-\t}\n-}\n-\n func TestAESCipherReordering(t *testing.T) {\n \tcurrentAESSupport := hasAESGCMHardwareSupport\n \tdefer func() { hasAESGCMHardwareSupport = currentAESSupport; initDefaultCipherSuites() }()"}, {"sha": "c2c288aed4325b280f435fcb26239d0d9f49780e", "filename": "libgo/go/crypto/tls/handshake_server_tls13.go", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_tls13.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_tls13.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_tls13.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -6,7 +6,6 @@ package tls\n \n import (\n \t\"bytes\"\n-\t\"context\"\n \t\"crypto\"\n \t\"crypto/hmac\"\n \t\"crypto/rsa\"\n@@ -24,7 +23,6 @@ const maxClientPSKIdentities = 5\n \n type serverHandshakeStateTLS13 struct {\n \tc               *Conn\n-\tctx             context.Context\n \tclientHello     *clientHelloMsg\n \thello           *serverHelloMsg\n \tsentDummyCCS    bool\n@@ -376,7 +374,7 @@ func (hs *serverHandshakeStateTLS13) pickCertificate() error {\n \t\treturn c.sendAlert(alertMissingExtension)\n \t}\n \n-\tcertificate, err := c.config.getCertificate(clientHelloInfo(hs.ctx, c, hs.clientHello))\n+\tcertificate, err := c.config.getCertificate(clientHelloInfo(c, hs.clientHello))\n \tif err != nil {\n \t\tif err == errNoCertificates {\n \t\t\tc.sendAlert(alertUnrecognizedName)"}, {"sha": "a389873d32ed1156ab1b03802aec73c59c2a1d85", "filename": "libgo/go/crypto/tls/tls.go", "status": "modified", "additions": 46, "deletions": 9, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -25,6 +25,7 @@ import (\n \t\"net\"\n \t\"os\"\n \t\"strings\"\n+\t\"time\"\n )\n \n // Server returns a new TLS server side connection\n@@ -115,16 +116,28 @@ func DialWithDialer(dialer *net.Dialer, network, addr string, config *Config) (*\n }\n \n func dial(ctx context.Context, netDialer *net.Dialer, network, addr string, config *Config) (*Conn, error) {\n-\tif netDialer.Timeout != 0 {\n-\t\tvar cancel context.CancelFunc\n-\t\tctx, cancel = context.WithTimeout(ctx, netDialer.Timeout)\n-\t\tdefer cancel()\n-\t}\n+\t// We want the Timeout and Deadline values from dialer to cover the\n+\t// whole process: TCP connection and TLS handshake. This means that we\n+\t// also need to start our own timers now.\n+\ttimeout := netDialer.Timeout\n \n \tif !netDialer.Deadline.IsZero() {\n-\t\tvar cancel context.CancelFunc\n-\t\tctx, cancel = context.WithDeadline(ctx, netDialer.Deadline)\n-\t\tdefer cancel()\n+\t\tdeadlineTimeout := time.Until(netDialer.Deadline)\n+\t\tif timeout == 0 || deadlineTimeout < timeout {\n+\t\t\ttimeout = deadlineTimeout\n+\t\t}\n+\t}\n+\n+\t// hsErrCh is non-nil if we might not wait for Handshake to complete.\n+\tvar hsErrCh chan error\n+\tif timeout != 0 || ctx.Done() != nil {\n+\t\thsErrCh = make(chan error, 2)\n+\t}\n+\tif timeout != 0 {\n+\t\ttimer := time.AfterFunc(timeout, func() {\n+\t\t\thsErrCh <- timeoutError{}\n+\t\t})\n+\t\tdefer timer.Stop()\n \t}\n \n \trawConn, err := netDialer.DialContext(ctx, network, addr)\n@@ -151,10 +164,34 @@ func dial(ctx context.Context, netDialer *net.Dialer, network, addr string, conf\n \t}\n \n \tconn := Client(rawConn, config)\n-\tif err := conn.HandshakeContext(ctx); err != nil {\n+\n+\tif hsErrCh == nil {\n+\t\terr = conn.Handshake()\n+\t} else {\n+\t\tgo func() {\n+\t\t\thsErrCh <- conn.Handshake()\n+\t\t}()\n+\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\t\terr = ctx.Err()\n+\t\tcase err = <-hsErrCh:\n+\t\t\tif err != nil {\n+\t\t\t\t// If the error was due to the context\n+\t\t\t\t// closing, prefer the context's error, rather\n+\t\t\t\t// than some random network teardown error.\n+\t\t\t\tif e := ctx.Err(); e != nil {\n+\t\t\t\t\terr = e\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif err != nil {\n \t\trawConn.Close()\n \t\treturn nil, err\n \t}\n+\n \treturn conn, nil\n }\n "}, {"sha": "cc53f7aefcabcbe8229c13e42d44d6707af99812", "filename": "libgo/go/crypto/x509/root.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcrypto%2Fx509%2Froot.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcrypto%2Fx509%2Froot.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -4,7 +4,11 @@\n \n package x509\n \n-//go:generate go run root_ios_gen.go -version 55161.140.3\n+// To update the embedded iOS root store, update the -version\n+// argument to the latest security_certificates version from\n+// https://opensource.apple.com/source/security_certificates/\n+// and run \"go generate\". See https://golang.org/issue/38843.\n+//go:generate go run root_ios_gen.go -version 55188.40.9\n \n import \"sync\"\n "}, {"sha": "d2dfb62b77c6a9ab56300c2fd9b60ab44b8f280a", "filename": "libgo/go/crypto/x509/root_ios.go", "status": "modified", "additions": 1, "deletions": 279, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_ios.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_ios.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_ios.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -1,4 +1,4 @@\n-// Code generated by root_ios_gen.go -version 55161.140.3; DO NOT EDIT.\n+// Code generated by root_ios_gen.go -version 55188.40.9; DO NOT EDIT.\n // Update the version in root.go and regenerate with \"go generate\".\n \n // +build ios\n@@ -116,61 +116,6 @@ ZCzJJ7VLkn5l/9Mt4blOvH+kQSGQQXemOR/qnuOf0GZvBeyqdn6/axag67XH/JJU\n LysRJyU3eExRarDzzFhdFPFqSBX/wge2sY0PjlxQRrM9vwGYT7JZVEc+NHt4bVaT\n LnPqZih4zR0Uv6CPLy64Lo7yFIrM6bV8+2ydDKXhlg==\n -----END CERTIFICATE-----\n-# \"AddTrust Class 1 CA Root\"\n-# 8C 72 09 27 9A C0 4E 27 5E 16 D0 7F D3 B7 75 E8\n-# 01 54 B5 96 80 46 E3 1F 52 DD 25 76 63 24 E9 A7\n------BEGIN CERTIFICATE-----\n-MIIEGDCCAwCgAwIBAgIBATANBgkqhkiG9w0BAQUFADBlMQswCQYDVQQGEwJTRTEU\n-MBIGA1UEChMLQWRkVHJ1c3QgQUIxHTAbBgNVBAsTFEFkZFRydXN0IFRUUCBOZXR3\n-b3JrMSEwHwYDVQQDExhBZGRUcnVzdCBDbGFzcyAxIENBIFJvb3QwHhcNMDAwNTMw\n-MTAzODMxWhcNMjAwNTMwMTAzODMxWjBlMQswCQYDVQQGEwJTRTEUMBIGA1UEChML\n-QWRkVHJ1c3QgQUIxHTAbBgNVBAsTFEFkZFRydXN0IFRUUCBOZXR3b3JrMSEwHwYD\n-VQQDExhBZGRUcnVzdCBDbGFzcyAxIENBIFJvb3QwggEiMA0GCSqGSIb3DQEBAQUA\n-A4IBDwAwggEKAoIBAQCWltQhSWDia+hBBwzexODcEyPNwTXH+9ZOEQpnXvUGW2ul\n-CDtbKRY654eyNAbFvAWlA3yCyykQruGIgb3WntP+LVbBFc7jJp0VLhD7Bo8wBN6n\n-tGO0/7Gcrjyvd7ZWxbWroulpOj0OM3kyP3CCkplhbY0wCI9xP6ZIVxn4JdxLZlyl\n-dI+Yrsj5wAYi56xz36Uu+1LcsRVlIPo1Zmne3yzxbrww2ywkEtvrNTVokMsAsJch\n-PXQhI2U0K7t4WaPW4XY5mqRJjox0r26kmqPZm9I4XJuiGMx1I4S+6+JNM3GOGvDC\n-+Mcdoq0Dlyz4zyXG9rgkMbFjXZJ/Y/AlyVMuH79NAgMBAAGjgdIwgc8wHQYDVR0O\n-BBYEFJWxtPCUtr3H2tERCSG+wa9J/RB7MAsGA1UdDwQEAwIBBjAPBgNVHRMBAf8E\n-BTADAQH/MIGPBgNVHSMEgYcwgYSAFJWxtPCUtr3H2tERCSG+wa9J/RB7oWmkZzBl\n-MQswCQYDVQQGEwJTRTEUMBIGA1UEChMLQWRkVHJ1c3QgQUIxHTAbBgNVBAsTFEFk\n-ZFRydXN0IFRUUCBOZXR3b3JrMSEwHwYDVQQDExhBZGRUcnVzdCBDbGFzcyAxIENB\n-IFJvb3SCAQEwDQYJKoZIhvcNAQEFBQADggEBACxtZBsfzQ3duQH6lmM0MkhHma6X\n-7f1yFqZzR1r0693p9db7RcwpiURdv0Y5PejuvE1Uhh4dbOMXJ0PhiVYrqW9yTkkz\n-43J8KiOavD7/KCrto/8cI7pDVwlnTUtiBi34/2ydYB7YHEt9tTEv2dB8Xfjea4MY\n-eDdXL+gzB2ffHsdrKpV2ro9Xo/D0UrSpUwjP4E/TelOL/bscVjby/rK25Xa71SJl\n-pz/+0WatC7xrmYbvP33zGDLKe8bjq2RGlfgmadlVg3sslgf/WSxEo8bl6ancoWOA\n-WiFeIc9TVPC6b4nbqKqVz4vjccweGyBECMB6tkD9xOQ14R0WHNC8K47Wcdk=\n------END CERTIFICATE-----\n-# \"AddTrust External CA Root\"\n-# 68 7F A4 51 38 22 78 FF F0 C8 B1 1F 8D 43 D5 76\n-# 67 1C 6E B2 BC EA B4 13 FB 83 D9 65 D0 6D 2F F2\n------BEGIN CERTIFICATE-----\n-MIIENjCCAx6gAwIBAgIBATANBgkqhkiG9w0BAQUFADBvMQswCQYDVQQGEwJTRTEU\n-MBIGA1UEChMLQWRkVHJ1c3QgQUIxJjAkBgNVBAsTHUFkZFRydXN0IEV4dGVybmFs\n-IFRUUCBOZXR3b3JrMSIwIAYDVQQDExlBZGRUcnVzdCBFeHRlcm5hbCBDQSBSb290\n-MB4XDTAwMDUzMDEwNDgzOFoXDTIwMDUzMDEwNDgzOFowbzELMAkGA1UEBhMCU0Ux\n-FDASBgNVBAoTC0FkZFRydXN0IEFCMSYwJAYDVQQLEx1BZGRUcnVzdCBFeHRlcm5h\n-bCBUVFAgTmV0d29yazEiMCAGA1UEAxMZQWRkVHJ1c3QgRXh0ZXJuYWwgQ0EgUm9v\n-dDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALf3GjPm8gAELTngTlvt\n-H7xsD821+iO2zt6bETOXpClMfZOfvUq8k+0DGuOPz+VtUFrWlymUWoCwSXrbLpX9\n-uMq/NzgtHj6RQa1wVsfwTz/oMp50ysiQVOnGXw94nZpAPA6sYapeFI+eh6FqUNzX\n-mk6vBbOmcZSccbNQYArHE504B4YCqOmoaSYYkKtMsE8jqzpPhNjfzp/haW+710LX\n-a0Tkx63ubUFfclpxCDezeWWkWaCUN/cALw3CknLa0Dhy2xSoRcRdKn23tNbE7qzN\n-E0S3ySvdQwAl+mG5aWpYIxG3pzOPVnVZ9c0p10a3CitlttNCbxWyuHv77+ldU9U0\n-WicCAwEAAaOB3DCB2TAdBgNVHQ4EFgQUrb2YejS0Jvf6xCZU7wO94CTLVBowCwYD\n-VR0PBAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wgZkGA1UdIwSBkTCBjoAUrb2YejS0\n-Jvf6xCZU7wO94CTLVBqhc6RxMG8xCzAJBgNVBAYTAlNFMRQwEgYDVQQKEwtBZGRU\n-cnVzdCBBQjEmMCQGA1UECxMdQWRkVHJ1c3QgRXh0ZXJuYWwgVFRQIE5ldHdvcmsx\n-IjAgBgNVBAMTGUFkZFRydXN0IEV4dGVybmFsIENBIFJvb3SCAQEwDQYJKoZIhvcN\n-AQEFBQADggEBALCb4IUlwtYj4g+WBpKdQZic2YR5gdkeWxQHIzZlj7DYd7usQWxH\n-YINRsPkyPef89iYTx4AWpb9a/IfPeHmJIZriTAcKhjW88t5RxNKWt9x+Tu5w/Rw5\n-6wwCURQtjr0W4MHfRnXnJK3s9EK0hZNwEGe6nQY1ShjTK3rMUUKhemPR5ruhxSvC\n-Nr4TDea9Y355e6cJDUCrat2PisP29owaQgVR1EX1n6diIWgVIEM8med8vSTYqZEX\n-c4g/VhsxOBi0cQ+azcgOno4uG+GMmIPLHzHxREzGBHNJdmAPx/i9F4BrLunMTA5a\n-mnkPIAou1Z5jJh5VkpTYghdae9C8x49OhgQ=\n------END CERTIFICATE-----\n # \"Admin-Root-CA\"\n # A3 1F 09 30 53 BD 12 C1 F5 C3 C6 EF D4 98 02 3F\n # D2 91 4D 77 58 D0 5D 69 8C E0 84 B5 06 26 E0 E5\n@@ -1249,31 +1194,6 @@ Bvt9YAretIpjsJyp8qS5UwGH0GikJ3+r/+n6yUA4iGe0OcaEb1fJU9u6ju7AQ7L4\n CYNu/2bPPu8Xs1gYJQk0XuPL1hS27PKSb3TkL4Eq1ZKR4OCXPDJoBYVL0fdX4lId\n kxpUnwVwwEpxYB5DC2Ae/qPOgRnhCzU=\n -----END CERTIFICATE-----\n-# \"Class 2 Primary CA\"\n-# 0F 99 3C 8A EF 97 BA AF 56 87 14 0E D5 9A D1 82\n-# 1B B4 AF AC F0 AA 9A 58 B5 D5 7A 33 8A 3A FB CB\n------BEGIN CERTIFICATE-----\n-MIIDkjCCAnqgAwIBAgIRAIW9S/PY2uNp9pTXX8OlRCMwDQYJKoZIhvcNAQEFBQAw\n-PTELMAkGA1UEBhMCRlIxETAPBgNVBAoTCENlcnRwbHVzMRswGQYDVQQDExJDbGFz\n-cyAyIFByaW1hcnkgQ0EwHhcNOTkwNzA3MTcwNTAwWhcNMTkwNzA2MjM1OTU5WjA9\n-MQswCQYDVQQGEwJGUjERMA8GA1UEChMIQ2VydHBsdXMxGzAZBgNVBAMTEkNsYXNz\n-IDIgUHJpbWFyeSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBANxQ\n-ltAS+DXSCHh6tlJw/W/uz7kRy1134ezpfgSN1sxvc0NXYKwzCkTsA18cgCSR5aiR\n-VhKC9+Ar9NuuYS6JEI1rbLqzAr3VNsVINyPi8Fo3UjMXEuLRYE2+L0ER4/YXJQyL\n-kcAbmXuZVg2v7tK8R1fjeUl7NIknJITesezpWE7+Tt9avkGtrAjFGA7v0lPubNCd\n-EgETjdyAYveVqUSISnFOYFWe2yMZeVYHDD9jC1yw4r5+FfyUM1hBOHTE4Y+L3yas\n-H7WLO7dDWWuwJKZtkIvEcupdM5i3y95ee++U8Rs+yskhwcWYAqqi9lt3m/V+llU0\n-HGdpwPFC40es/CgcZlUCAwEAAaOBjDCBiTAPBgNVHRMECDAGAQH/AgEKMAsGA1Ud\n-DwQEAwIBBjAdBgNVHQ4EFgQU43Mt38sOKAze3bOkynm4jrvoMIkwEQYJYIZIAYb4\n-QgEBBAQDAgEGMDcGA1UdHwQwMC4wLKAqoCiGJmh0dHA6Ly93d3cuY2VydHBsdXMu\n-Y29tL0NSTC9jbGFzczIuY3JsMA0GCSqGSIb3DQEBBQUAA4IBAQCnVM+IRBnL39R/\n-AN9WM2K191EBkOvDP9GIROkkXe/nFL0gt5o8AP5tn9uQ3Nf0YtaLcF3n5QRIqWh8\n-yfFC82x/xXp8HVGIutIKPidd3i1RTtMTZGnkLuPT55sJmabglZvOGtd/vjzOUrMR\n-FcEPF80Du5wlFbqidon8BvEY0JNLDnyCt6X09l/+7UCmnYR0ObncHoUW2ikbhiMA\n-ybuJfm6AiB4vFLQDJKgybwOaRywwvlbGp0ICcBvqQNi6BQNwB6SW//1IMwrh3KWB\n-kJtN3X3n57LNXMhqlfil9o3EXXgIvnsG1knPGTZQIy4I5p4FTUcY1Rbpsda2ENW7\n-l7+ijrRU\n------END CERTIFICATE-----\n # \"COMODO Certification Authority\"\n # 0C 2C D6 3D F7 80 6F A3 99 ED E8 09 11 6B 57 5B\n # F8 79 89 F0 65 18 F9 80 8C 86 05 03 17 8B AF 66\n@@ -1529,31 +1449,6 @@ CSuGdXzfX2lXANtu2KZyIktQ1HWYVt+3GP9DQ1CuekR78HlR10M9p9OB0/DJT7na\n xpeG0ILD5EJt/rDiZE4OJudANCa1CInXCGNjOCd1HjPqbqjdn5lPdE2BiYBL3ZqX\n KVwvvoFBuYz/6n1gBp7N1z3TLqMVvKjmJuVvw9y4AyHqnxbxLFS1\n -----END CERTIFICATE-----\n-# \"Deutsche Telekom Root CA 2\"\n-# B6 19 1A 50 D0 C3 97 7F 7D A9 9B CD AA C8 6A 22\n-# 7D AE B9 67 9E C7 0B A3 B0 C9 D9 22 71 C1 70 D3\n------BEGIN CERTIFICATE-----\n-MIIDnzCCAoegAwIBAgIBJjANBgkqhkiG9w0BAQUFADBxMQswCQYDVQQGEwJERTEc\n-MBoGA1UEChMTRGV1dHNjaGUgVGVsZWtvbSBBRzEfMB0GA1UECxMWVC1UZWxlU2Vj\n-IFRydXN0IENlbnRlcjEjMCEGA1UEAxMaRGV1dHNjaGUgVGVsZWtvbSBSb290IENB\n-IDIwHhcNOTkwNzA5MTIxMTAwWhcNMTkwNzA5MjM1OTAwWjBxMQswCQYDVQQGEwJE\n-RTEcMBoGA1UEChMTRGV1dHNjaGUgVGVsZWtvbSBBRzEfMB0GA1UECxMWVC1UZWxl\n-U2VjIFRydXN0IENlbnRlcjEjMCEGA1UEAxMaRGV1dHNjaGUgVGVsZWtvbSBSb290\n-IENBIDIwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCrC6M14IspFLEU\n-ha88EOQ5bzVdSq7d6mGNlUn0b2SjGmBmpKlAIoTZ1KXleJMOaAGtuU1cOs7TuKhC\n-QN/Po7qCWWqSG6wcmtoIKyUn+WkjR/Hg6yx6m/UTAtB+NHzCnjwAWav12gz1Mjwr\n-rFDa1sPeg5TKqAyZMg4ISFZbavva4VhYAUlfckE8FQYBjl2tqriTtM2e66foai1S\n-NNs671x1Udrb8zH57nGYMsRUFUQM+ZtV7a3fGAigo4aKSe5TBY8ZTNXeWHmb0moc\n-QqvF1afPaA+W5OFhmHZhyJF81j4A4pFQh+GdCuatl9Idxjp9y7zaAzTVjlsB9WoH\n-txa2bkp/AgMBAAGjQjBAMB0GA1UdDgQWBBQxw3kbuvVT1xfgiXotF2wKsyudMzAP\n-BgNVHRMECDAGAQH/AgEFMA4GA1UdDwEB/wQEAwIBBjANBgkqhkiG9w0BAQUFAAOC\n-AQEAlGRZrTlk5ynrE/5aw4sTV8gEJPB0d8Bg42f76Ymmg7+Wgnxu1MM9756Abrsp\n-tJh6sTtU6zkXR34ajgv8HzFZMQSyzhfzLMdiNlXiItiJVbSYSKpk+tYcNthEeFpa\n-IzpXl/V6ME+un2pMSyuOoAPjPuCp1NJ70rOo4nI8rZ7/gFnkm0W09juwzTkZmDLl\n-6iFhkOQxIY40sfcvNUqFENrnijchvllj4PKFiDFT1FQUhXB59C4Gdyd1Lx+4ivn+\n-xbrYNuSD7Odlt79jWvNGr4GUN9RBjNYj1h7P9WgbRGOiWrqnNVmh5XAFmw4jV5mU\n-Cm26OWMohpLzGITY+9HPBVZkVw==\n------END CERTIFICATE-----\n # \"Developer ID Certification Authority\"\n # 7A FC 9D 01 A6 2F 03 A2 DE 96 37 93 6D 4A FE 68\n # 09 0D 2D E1 8D 03 F2 9C 88 CF B0 B1 BA 63 58 7F\n@@ -1801,29 +1696,6 @@ R8srzJmwN0jP41ZL9c8PDHIyh8bwRLtTcm1D9SZImlJnt1ir/md2cXjbDaJWFBM5\n JDGFoqgCWjBH4d1QB7wCCZAA62RjYJsWvIjJEubSfZGL+T0yjWW06XyxV3bqxbYo\n Ob8VZRzI9neWagqNdwvYkQsEjgfbKbYK7p2CNTUQ\n -----END CERTIFICATE-----\n-# \"DST Root CA X4\"\n-# 9A 73 92 9A 50 0F 1A 0B F4 9D CB 04 6E 80 39 16\n-# 96 96 55 73 45 E9 F8 13 F1 0F F9 38 0D B2 26 95\n------BEGIN CERTIFICATE-----\n-MIIDOzCCAiOgAwIBAgIRANAeRlAAACmMAAAAAgAAAAIwDQYJKoZIhvcNAQEFBQAw\n-PzEkMCIGA1UEChMbRGlnaXRhbCBTaWduYXR1cmUgVHJ1c3QgQ28uMRcwFQYDVQQD\n-Ew5EU1QgUm9vdCBDQSBYNDAeFw0wMDA5MTMwNjIyNTBaFw0yMDA5MTMwNjIyNTBa\n-MD8xJDAiBgNVBAoTG0RpZ2l0YWwgU2lnbmF0dXJlIFRydXN0IENvLjEXMBUGA1UE\n-AxMORFNUIFJvb3QgQ0EgWDQwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIB\n-AQCthX3OFEYY8gSeIYur0O4ypOT68HnDrjLfIutL5PZHRwQGjzCPb9PFo/ihboJ8\n-RvfGhBAqpQCo47zwYEhpWm1jB+L/OE/dBBiyn98krfU2NiBKSom2J58RBeAwHGEy\n-cO+lewyjVvbDDLUy4CheY059vfMjPAftCRXjqSZIolQb9FdPcAoa90mFwB7rKniE\n-J7vppdrUScSS0+eBrHSUPLdvwyn4RGp+lSwbWYcbg5EpSpE0GRJdchic0YDjvIoC\n-YHpe7Rkj93PYRTQyU4bhC88ck8tMqbvRYqMRqR+vobbkrj5LLCOQCHV5WEoxWh+0\n-E2SpIFe7RkV++MmpIAc0h1tZAgMBAAGjMjAwMA8GA1UdEwEB/wQFMAMBAf8wHQYD\n-VR0OBBYEFPCD6nPIP1ubWzdf9UyPWvf0hki9MA0GCSqGSIb3DQEBBQUAA4IBAQCE\n-G85wl5eEWd7adH6XW/ikGN5salvpq/Fix6yVTzE6CrhlP5LBdkf6kx1bSPL18M45\n-g0rw2zA/MWOhJ3+S6U+BE0zPGCuu8YQaZibR7snm3HiHUaZNMu5c8D0x0bcMxDjY\n-AVVcHCoNiL53Q4PLW27nbY6wwG0ffFKmgV3blxrYWfuUDgGpyPwHwkfVFvz9qjaV\n-mf12VJffL6W8omBPtgteb6UaT/k1oJ7YI0ldGf+ngpVbRhD+LC3cUtT6GO/BEPZu\n-8YTV/hbiDH5v3khVqMIeKT6o8IuXGG7F6a6vKwP1F1FwTXf4UC/ivhme7vdUH7B/\n-Vv4AEbT8dNfEeFxrkDbh\n------END CERTIFICATE-----\n # \"E-Tugra Certification Authority\"\n # B0 BF D5 2B B0 D7 D9 BD 92 BF 5D 4D C1 3D A2 55\n # C0 2C 54 2F 37 83 65 EA 89 39 11 F5 5E 55 F2 3C\n@@ -2671,39 +2543,6 @@ EhTkYY2sEJCehFC78JZvRZ+K88psT/oROhUVRsPNH4NbLUES7VBnQRM9IauUiqpO\n fMGx+6fWtScvl6tu4B3i0RwsH0Ti/L6RoZz71ilTc4afU9hDDl3WY4JxHYB0yvbi\n AmvZWg==\n -----END CERTIFICATE-----\n-# \"I.CA - Qualified Certification Authority, 09/2009\"\n-# C0 C0 5A 8D 8D A5 5E AF 27 AA 9B 91 0B 0A 6E F0\n-# D8 BB DE D3 46 92 8D B8 72 E1 82 C2 07 3E 98 02\n------BEGIN CERTIFICATE-----\n-MIIFHjCCBAagAwIBAgIEAKA3oDANBgkqhkiG9w0BAQsFADCBtzELMAkGA1UEBhMC\n-Q1oxOjA4BgNVBAMMMUkuQ0EgLSBRdWFsaWZpZWQgQ2VydGlmaWNhdGlvbiBBdXRo\n-b3JpdHksIDA5LzIwMDkxLTArBgNVBAoMJFBydm7DrSBjZXJ0aWZpa2HEjW7DrSBh\n-dXRvcml0YSwgYS5zLjE9MDsGA1UECww0SS5DQSAtIEFjY3JlZGl0ZWQgUHJvdmlk\n-ZXIgb2YgQ2VydGlmaWNhdGlvbiBTZXJ2aWNlczAeFw0wOTA5MDEwMDAwMDBaFw0x\n-OTA5MDEwMDAwMDBaMIG3MQswCQYDVQQGEwJDWjE6MDgGA1UEAwwxSS5DQSAtIFF1\n-YWxpZmllZCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSwgMDkvMjAwOTEtMCsGA1UE\n-CgwkUHJ2bsOtIGNlcnRpZmlrYcSNbsOtIGF1dG9yaXRhLCBhLnMuMT0wOwYDVQQL\n-DDRJLkNBIC0gQWNjcmVkaXRlZCBQcm92aWRlciBvZiBDZXJ0aWZpY2F0aW9uIFNl\n-cnZpY2VzMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtTaEy0KC8M9l\n-4lSaWHMs4+sVV1LwzyJYiIQNeCrv1HHm/YpGIdY/Z640ceankjQvIX7m23BK4OSC\n-6KO8kZYA3zopOz6GFCOKV2PvLukbc+c2imF6kLHEv6qNA8WxhPbR3xKwlHDwB2yh\n-Wzo7V3QVgDRG83sugqQntKYC3LnlTGbJpNP+Az72gpO9AHUn/IBhFk4ksc8lYS2L\n-9GCy9CsmdKSBP78p9w8Lx7vDLqkDgt1/zBrcUWmSSb7AE/BPEeMryQV1IdI6nlGn\n-BhWkXOYf6GSdayJw86btuxC7viDKNrbp44HjQRaSxnp6O3eto1x4DfiYdw/YbJFe\n-7EjkxSQBywIDAQABo4IBLjCCASowDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8E\n-BAMCAQYwgecGA1UdIASB3zCB3DCB2QYEVR0gADCB0DCBzQYIKwYBBQUHAgIwgcAa\n-gb1UZW50byBjZXJ0aWZpa2F0IGplIHZ5ZGFuIGpha28ga3ZhbGlmaWtvdmFueSBz\n-eXN0ZW1vdnkgY2VydGlmaWthdCBwb2RsZSB6YWtvbmEgYy4gMjI3LzIwMDAgU2Iu\n-IHYgcGxhdG5lbSB6bmVuaS9UaGlzIGlzIHF1YWxpZmllZCBzeXN0ZW0gY2VydGlm\n-aWNhdGUgYWNjb3JkaW5nIHRvIEN6ZWNoIEFjdCBOby4gMjI3LzIwMDAgQ29sbC4w\n-HQYDVR0OBBYEFHnL0CPpOmdwkXRP01Hi4CD94Sj7MA0GCSqGSIb3DQEBCwUAA4IB\n-AQB9laU214hYaBHPZftbDS/2dIGLWdmdSbj1OZbJ8LIPBMxYjPoEMqzAR74tw96T\n-i6aWRa5WdOWaS6I/qibEKFZhJAVXX5mkx2ewGFLJ+0Go+eTxnjLOnhVF2V2s+57b\n-m8c8j6/bS6Ij6DspcHEYpfjjh64hE2r0aSpZDjGzKFM6YpqsCJN8qYe2X1qmGMLQ\n-wvNdjG+nPzCJOOuUEypIWt555ZDLXqS5F7ZjBjlfyDZjEfS2Es9Idok8alf563Mi\n-9/o+Ba46wMYOkk3P1IlU0RqCajdbliioACKDztAqubONU1guZVzV8tuMASVzbJeL\n-/GAB7ECTwe1RuKrLYtglMKI9\n------END CERTIFICATE-----\n # \"IdenTrust Commercial Root CA 1\"\n # 5D 56 49 9B E4 D2 E0 8B CF CA D0 8A 3E 38 72 3D\n # 50 50 3B DE 70 69 48 E4 2F 55 60 30 19 E5 28 AE\n@@ -4722,123 +4561,6 @@ VXyNWQKV3WKdwrnuWih0hKWbt5DHDAff9Yk2dDLWKMGwsAvgnEzDHNb842m1R0aB\n L6KCq9NjRHDEjf8tM7qtj3u1cIiuPhnPQCjY/MiQu12ZIvVS5ljFH4gxQ+6IHdfG\n jjxDah2nGN59PRbxYvnKkKj9\n -----END CERTIFICATE-----\n-# \"UTN - DATACorp SGC\"\n-# 85 FB 2F 91 DD 12 27 5A 01 45 B6 36 53 4F 84 02\n-# 4A D6 8B 69 B8 EE 88 68 4F F7 11 37 58 05 B3 48\n------BEGIN CERTIFICATE-----\n-MIIEXjCCA0agAwIBAgIQRL4Mi1AAIbQR0ypoBqmtaTANBgkqhkiG9w0BAQUFADCB\n-kzELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAlVUMRcwFQYDVQQHEw5TYWx0IExha2Ug\n-Q2l0eTEeMBwGA1UEChMVVGhlIFVTRVJUUlVTVCBOZXR3b3JrMSEwHwYDVQQLExho\n-dHRwOi8vd3d3LnVzZXJ0cnVzdC5jb20xGzAZBgNVBAMTElVUTiAtIERBVEFDb3Jw\n-IFNHQzAeFw05OTA2MjQxODU3MjFaFw0xOTA2MjQxOTA2MzBaMIGTMQswCQYDVQQG\n-EwJVUzELMAkGA1UECBMCVVQxFzAVBgNVBAcTDlNhbHQgTGFrZSBDaXR5MR4wHAYD\n-VQQKExVUaGUgVVNFUlRSVVNUIE5ldHdvcmsxITAfBgNVBAsTGGh0dHA6Ly93d3cu\n-dXNlcnRydXN0LmNvbTEbMBkGA1UEAxMSVVROIC0gREFUQUNvcnAgU0dDMIIBIjAN\n-BgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA3+5YEKIrblXEjr8uRgnn4AgPLit6\n-E5Qbvfa2gI5lBZMAHryv4g+OGQ0SR+ysraP6LnD43m77VkIVni5c7yPeIbkFdicZ\n-D0/Ww5y0vpQZY/KmEQrrU0icvvIpOxboGqBMpsn0GFlowHDyUwDAXlCCpVZvNvlK\n-4ESGoE1O1kduSUrLZ9emxAW5jh70/P/N5zbgnAVssjMiFdC04MwXwLLA9P4yPykq\n-lXvY8qdOD1R8oQ2AswkDwf9c3V6aPryuvEeKaq5xyh+xKrhfQgUL7EYw0XILyulW\n-bfXv33i+Ybqypa4ETLyorGkVl73v67SMvzX41MPRKA5cOp9wGDMgd8SirwIDAQAB\n-o4GrMIGoMAsGA1UdDwQEAwIBxjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBRT\n-MtGzz3/64PGgXYVOktKeRR20TzA9BgNVHR8ENjA0MDKgMKAuhixodHRwOi8vY3Js\n-LnVzZXJ0cnVzdC5jb20vVVROLURBVEFDb3JwU0dDLmNybDAqBgNVHSUEIzAhBggr\n-BgEFBQcDAQYKKwYBBAGCNwoDAwYJYIZIAYb4QgQBMA0GCSqGSIb3DQEBBQUAA4IB\n-AQAnNZcAiosovcYzMB4p/OL31ZjUQLtgyr+rFywJNn9Q+kHcrpY6CiM+iVnJowft\n-Gzet/Hy+UUla3joKVAgWRcKZsYfNjGjgaQPpxE6YsjuMFrMOoAyYUJuTqXAJyCyj\n-j98C5OBxOvG0I3KgqgHf35g+FFCgMSa9KOlaMCZ1+XtgHI3zzVAmbQQnmt/VDUVH\n-KWss5nbZqSl9Mt3JNjy9rjXxEZ4du5A/EkdOjtd+D2JzHVImOBwYSf0wdJrE5SIv\n-2MCN7ZF6TACPcn9d2t0bi0Vr591pl6jFVkwPDPafepE39peC4N1xaf92P2BNPM/3\n-mfnGV/TJVTl4uix5yaaIK/QI\n------END CERTIFICATE-----\n-# \"UTN-USERFirst-Client Authentication and Email\"\n-# 43 F2 57 41 2D 44 0D 62 74 76 97 4F 87 7D A8 F1\n-# FC 24 44 56 5A 36 7A E6 0E DD C2 7A 41 25 31 AE\n------BEGIN CERTIFICATE-----\n-MIIEojCCA4qgAwIBAgIQRL4Mi1AAJLQR0zYlJWfJiTANBgkqhkiG9w0BAQUFADCB\n-rjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAlVUMRcwFQYDVQQHEw5TYWx0IExha2Ug\n-Q2l0eTEeMBwGA1UEChMVVGhlIFVTRVJUUlVTVCBOZXR3b3JrMSEwHwYDVQQLExho\n-dHRwOi8vd3d3LnVzZXJ0cnVzdC5jb20xNjA0BgNVBAMTLVVUTi1VU0VSRmlyc3Qt\n-Q2xpZW50IEF1dGhlbnRpY2F0aW9uIGFuZCBFbWFpbDAeFw05OTA3MDkxNzI4NTBa\n-Fw0xOTA3MDkxNzM2NThaMIGuMQswCQYDVQQGEwJVUzELMAkGA1UECBMCVVQxFzAV\n-BgNVBAcTDlNhbHQgTGFrZSBDaXR5MR4wHAYDVQQKExVUaGUgVVNFUlRSVVNUIE5l\n-dHdvcmsxITAfBgNVBAsTGGh0dHA6Ly93d3cudXNlcnRydXN0LmNvbTE2MDQGA1UE\n-AxMtVVROLVVTRVJGaXJzdC1DbGllbnQgQXV0aGVudGljYXRpb24gYW5kIEVtYWls\n-MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsjmFpPJ9q0E7YkY3rs3B\n-YHW8OWX5ShpHornMSMxqmNVNNRm5pELlzkniii8efNIxB8dOtINknS4p1aJkxIW9\n-hVE1eaROaJB7HHqkkqgX8pgV8pPMyaQylbsMTzC9mKALi+VuG6JG+ni8om+rWV6l\n-L8/K2m2qL+usobNqqrcuZzWLeeEeaYji5kbNoKXqvgvOdjp6Dpvq/NonWz1zHyLm\n-SGHGTPNpsaguG7bUMSAsvIKKjqQOpdeJQ/wWWq8dcdcRWdq6hw2v+vPhwvCkxWeM\n-1tZUOt4KpLoDd7NlyP0e03RiqhjKaJMeoYV+9Udly/hNVyh00jT/MLbu9mIwFIws\n-6wIDAQABo4G5MIG2MAsGA1UdDwQEAwIBxjAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud\n-DgQWBBSJgmd9xJ0mcABLtFBIfN49rgRufTBYBgNVHR8EUTBPME2gS6BJhkdodHRw\n-Oi8vY3JsLnVzZXJ0cnVzdC5jb20vVVROLVVTRVJGaXJzdC1DbGllbnRBdXRoZW50\n-aWNhdGlvbmFuZEVtYWlsLmNybDAdBgNVHSUEFjAUBggrBgEFBQcDAgYIKwYBBQUH\n-AwQwDQYJKoZIhvcNAQEFBQADggEBALFtYV2mGn98q0rkMPxTbyUkxsrt4jFcKw7u\n-7mFVbwQ+zznexRtJlOTrIEy05p5QLnLZjfWqo7NK2lYcYJeA3IKirUq9iiv/Cwm0\n-xtcgBEXkzYABurorbs6q15L+5K/r9CYdFip/bDCVNy8zEqx/3cfREYxRmLLQo5HQ\n-rfafnoOTHh1CuEava2bwm3/q4wMC5QJRwarVNZ1yQAOJujEdxRBoUp7fooXFXAim\n-eOZTT7Hot9MUnpOmw2TjrH5xzbyf6QMbzPvprDHBr3wVdAKZw7JHpsIyYdfHb0gk\n-USeh1YdV8nuPmD0Wnu51tvjQjvLzxq4oW6fw8zYX/MMF08oDSlQ=\n------END CERTIFICATE-----\n-# \"UTN-USERFirst-Hardware\"\n-# 6E A5 47 41 D0 04 66 7E ED 1B 48 16 63 4A A3 A7\n-# 9E 6E 4B 96 95 0F 82 79 DA FC 8D 9B D8 81 21 37\n------BEGIN CERTIFICATE-----\n-MIIEdDCCA1ygAwIBAgIQRL4Mi1AAJLQR0zYq/mUK/TANBgkqhkiG9w0BAQUFADCB\n-lzELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAlVUMRcwFQYDVQQHEw5TYWx0IExha2Ug\n-Q2l0eTEeMBwGA1UEChMVVGhlIFVTRVJUUlVTVCBOZXR3b3JrMSEwHwYDVQQLExho\n-dHRwOi8vd3d3LnVzZXJ0cnVzdC5jb20xHzAdBgNVBAMTFlVUTi1VU0VSRmlyc3Qt\n-SGFyZHdhcmUwHhcNOTkwNzA5MTgxMDQyWhcNMTkwNzA5MTgxOTIyWjCBlzELMAkG\n-A1UEBhMCVVMxCzAJBgNVBAgTAlVUMRcwFQYDVQQHEw5TYWx0IExha2UgQ2l0eTEe\n-MBwGA1UEChMVVGhlIFVTRVJUUlVTVCBOZXR3b3JrMSEwHwYDVQQLExhodHRwOi8v\n-d3d3LnVzZXJ0cnVzdC5jb20xHzAdBgNVBAMTFlVUTi1VU0VSRmlyc3QtSGFyZHdh\n-cmUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCx98M4P7Sof885glFn\n-0G2f0v9Y8+efK+wNiVSZuTiZFvfgIXlIwrthdBKWHTxqctU8EGc6Oe0rE81m65UJ\n-M6Rsl7HoxuzBdXmcRl6Nq9Bq/bkqVRcQVLMZ8Jr28bFdtqdt++BxF2uiiPsA3/4a\n-MXcMmgF6sTLjKwEHOG7DpV4jvEWbe1DByTCP2+UretNb+zNAHqDVmBe8i4fDidNd\n-oI6yqqr2jmmIBsX6iSHzCJ1pLgkzmykNRg+MzEk0sGlRvfkGzWitZky8PqxhvQqI\n-DsjfPe58BEydCl5rkdbux+0ojatNh4lz0G6k0B4WixThdkQDf2Os5M1JnMWS9Ksy\n-oUhbAgMBAAGjgbkwgbYwCwYDVR0PBAQDAgHGMA8GA1UdEwEB/wQFMAMBAf8wHQYD\n-VR0OBBYEFKFyXyYbKJhDlV0HN9WFlp1L0sNFMEQGA1UdHwQ9MDswOaA3oDWGM2h0\n-dHA6Ly9jcmwudXNlcnRydXN0LmNvbS9VVE4tVVNFUkZpcnN0LUhhcmR3YXJlLmNy\n-bDAxBgNVHSUEKjAoBggrBgEFBQcDAQYIKwYBBQUHAwUGCCsGAQUFBwMGBggrBgEF\n-BQcDBzANBgkqhkiG9w0BAQUFAAOCAQEARxkP3nTGmZev/K0oXnWO6y1n7k57K9cM\n-//bey1WiCuFMVGWTYGufEpytXoMs61quwOQt9ABjHbjAbPLPSbtNk28Gpgoiskli\n-CE7/yMgUsogWXecB5BKV5UU0s4tpvc+0hY91UZ59Ojg6FEgSxvunOxqNDYJAB+gE\n-CJChicsZUN/KHAG8HQQZexB2lzvukJDKxA4fFm517zP4029bHpbj4HR3dHuKom4t\n-3XbWOTCC8KucUvIqx69JXn7HaOWCgchqJ/kniCrVWFCVH/A7HFe7fRQ5YiuayZSS\n-KqMiDP+JJn1fIytH1xUdqWqeUQ0qUZ6B+dQ7XnASfxAynB67nfhmqA==\n------END CERTIFICATE-----\n-# \"UTN-USERFirst-Object\"\n-# 6F FF 78 E4 00 A7 0C 11 01 1C D8 59 77 C4 59 FB\n-# 5A F9 6A 3D F0 54 08 20 D0 F4 B8 60 78 75 E5 8F\n------BEGIN CERTIFICATE-----\n-MIIEZjCCA06gAwIBAgIQRL4Mi1AAJLQR0zYt4LNfGzANBgkqhkiG9w0BAQUFADCB\n-lTELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAlVUMRcwFQYDVQQHEw5TYWx0IExha2Ug\n-Q2l0eTEeMBwGA1UEChMVVGhlIFVTRVJUUlVTVCBOZXR3b3JrMSEwHwYDVQQLExho\n-dHRwOi8vd3d3LnVzZXJ0cnVzdC5jb20xHTAbBgNVBAMTFFVUTi1VU0VSRmlyc3Qt\n-T2JqZWN0MB4XDTk5MDcwOTE4MzEyMFoXDTE5MDcwOTE4NDAzNlowgZUxCzAJBgNV\n-BAYTAlVTMQswCQYDVQQIEwJVVDEXMBUGA1UEBxMOU2FsdCBMYWtlIENpdHkxHjAc\n-BgNVBAoTFVRoZSBVU0VSVFJVU1QgTmV0d29yazEhMB8GA1UECxMYaHR0cDovL3d3\n-dy51c2VydHJ1c3QuY29tMR0wGwYDVQQDExRVVE4tVVNFUkZpcnN0LU9iamVjdDCC\n-ASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAM6qgT+jo2F4qjEAVZURnicP\n-HxzfOpuCaDDASmEd8S8O+r5596Uj71VRloTN2+O5bj4x2AogZ8f02b+U60cEPgLO\n-KqJdhwQJ9jCdGIqXsqoc/EHSoTbL+z2RuufZcDX65OeQw5ujm9M89RKZd7G3CeBo\n-5hy485RjiGpq/gt2yb70IuRnuasaXnfBhQfdDWy/7gbHd2pBnqcP1/vulBe3/IW+\n-pKvEHDHd17bR5PDv3xaPslKT16HUiaEHLr/hARJCHhrh2JU022R5KP+6LhHC5ehb\n-kkj7RwvCbNqtMoNB86XlQXD9ZZBt+vpRxPm9lisZBCzTbafc8H9vg2XiaquHhnUC\n-AwEAAaOBrzCBrDALBgNVHQ8EBAMCAcYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4E\n-FgQU2u1kdBScFDyr3ZmpvVsoTYs8ydgwQgYDVR0fBDswOTA3oDWgM4YxaHR0cDov\n-L2NybC51c2VydHJ1c3QuY29tL1VUTi1VU0VSRmlyc3QtT2JqZWN0LmNybDApBgNV\n-HSUEIjAgBggrBgEFBQcDAwYIKwYBBQUHAwgGCisGAQQBgjcKAwQwDQYJKoZIhvcN\n-AQEFBQADggEBAAgfUrE3RHjb/c652pWWmKpVZIC1WkDdIaXFwfNfLEzIR1pp6ujw\n-NTX00CXzyKakh0q9G7FzCL3Uw8q2NbtZhncxzaeAFK4T7/yxSPlrJSUtUbYsbUXB\n-mMiKVl0+7kNOPmsnjtA6S4ULX9Ptaqd1y9Fahy85dRNacrACgZ++8A+EVCBibGnU\n-4U3GDZlDAQ0Slox4nb9QorFEqmrPF3rPbw/U+CRVX/A0FklmPlBGyWNxODFiuGK5\n-81OtbLUrohKqGU8J2l7nk8aOFAj+8DCAGKCGhU3IfdeLA/5u1fedFqySLKAj5ZyR\n-Uh+U3xeUc8OzwcFxBSAAeL0TUh2oPs0AH8g=\n------END CERTIFICATE-----\n # \"VeriSign Class 1 Public Primary Certification Authority - G3\"\n # CB B5 AF 18 5E 94 2A 24 02 F9 EA CB C0 ED 5B B8\n # 76 EE A3 C1 22 36 23 D0 04 47 E4 F3 BA 55 4B 65"}, {"sha": "8c0299b11e9b5ad606591c38304cc8f2c3684437", "filename": "libgo/go/crypto/x509/x509.go", "status": "modified", "additions": 0, "deletions": 108, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -1997,49 +1997,6 @@ func buildCSRExtensions(template *CertificateRequest) ([]pkix.Extension, error)\n \t\t})\n \t}\n \n-\tif template.KeyUsage != 0 &&\n-\t\t!oidInExtensions(oidExtensionKeyUsage, template.ExtraExtensions) {\n-\t\text, err := marshalKeyUsage(template.KeyUsage)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tret = append(ret, ext)\n-\t}\n-\n-\tif (len(template.ExtKeyUsage) > 0 || len(template.UnknownExtKeyUsage) > 0) &&\n-\t\t!oidInExtensions(oidExtensionExtendedKeyUsage, template.ExtraExtensions) {\n-\t\text, err := marshalExtKeyUsage(template.ExtKeyUsage, template.UnknownExtKeyUsage)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tret = append(ret, ext)\n-\t}\n-\n-\tif template.BasicConstraintsValid && !oidInExtensions(oidExtensionBasicConstraints, template.ExtraExtensions) {\n-\t\text, err := marshalBasicConstraints(template.IsCA, template.MaxPathLen, template.MaxPathLenZero)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tret = append(ret, ext)\n-\t}\n-\n-\tif len(template.SubjectKeyId) > 0 && !oidInExtensions(oidExtensionSubjectKeyId, template.ExtraExtensions) {\n-\t\tskidBytes, err := asn1.Marshal(template.SubjectKeyId)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tret = append(ret, pkix.Extension{Id: oidExtensionSubjectKeyId, Value: skidBytes})\n-\t}\n-\n-\tif len(template.PolicyIdentifiers) > 0 &&\n-\t\t!oidInExtensions(oidExtensionCertificatePolicies, template.ExtraExtensions) {\n-\t\text, err := marshalCertificatePolicies(template.PolicyIdentifiers)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tret = append(ret, ext)\n-\t}\n-\n \treturn append(ret, template.ExtraExtensions...), nil\n }\n \n@@ -2405,7 +2362,6 @@ type CertificateRequest struct {\n \tVersion            int\n \tSignature          []byte\n \tSignatureAlgorithm SignatureAlgorithm\n-\tKeyUsage           KeyUsage\n \n \tPublicKeyAlgorithm PublicKeyAlgorithm\n \tPublicKey          interface{}\n@@ -2438,37 +2394,6 @@ type CertificateRequest struct {\n \tEmailAddresses []string\n \tIPAddresses    []net.IP\n \tURIs           []*url.URL\n-\n-\tExtKeyUsage        []ExtKeyUsage           // Sequence of extended key usages.\n-\tUnknownExtKeyUsage []asn1.ObjectIdentifier // Encountered extended key usages unknown to this package.\n-\n-\t// BasicConstraintsValid indicates whether IsCA, MaxPathLen,\n-\t// and MaxPathLenZero are valid.\n-\tBasicConstraintsValid bool\n-\tIsCA                  bool\n-\n-\t// MaxPathLen and MaxPathLenZero indicate the presence and\n-\t// value of the BasicConstraints' \"pathLenConstraint\".\n-\t//\n-\t// When parsing a certificate, a positive non-zero MaxPathLen\n-\t// means that the field was specified, -1 means it was unset,\n-\t// and MaxPathLenZero being true mean that the field was\n-\t// explicitly set to zero. The case of MaxPathLen==0 with MaxPathLenZero==false\n-\t// should be treated equivalent to -1 (unset).\n-\t//\n-\t// When generating a certificate, an unset pathLenConstraint\n-\t// can be requested with either MaxPathLen == -1 or using the\n-\t// zero value for both MaxPathLen and MaxPathLenZero.\n-\tMaxPathLen int\n-\t// MaxPathLenZero indicates that BasicConstraintsValid==true\n-\t// and MaxPathLen==0 should be interpreted as an actual\n-\t// maximum path length of zero. Otherwise, that combination is\n-\t// interpreted as MaxPathLen not being set.\n-\tMaxPathLenZero bool\n-\n-\tSubjectKeyId []byte\n-\n-\tPolicyIdentifiers []asn1.ObjectIdentifier\n }\n \n // These structures reflect the ASN.1 structure of X.509 certificate\n@@ -2566,15 +2491,6 @@ func parseCSRExtensions(rawAttributes []asn1.RawValue) ([]pkix.Extension, error)\n //  - EmailAddresses\n //  - IPAddresses\n //  - URIs\n-//  - KeyUsage\n-//  - ExtKeyUsage\n-//  - UnknownExtKeyUsage\n-//  - BasicConstraintsValid\n-//  - IsCA\n-//  - MaxPathLen\n-//  - MaxPathLenZero\n-//  - SubjectKeyId\n-//  - PolicyIdentifiers\n //  - ExtraExtensions\n //  - Attributes (deprecated)\n //\n@@ -2799,30 +2715,6 @@ func parseCertificateRequest(in *certificateRequest) (*CertificateRequest, error\n \t\t\tif err != nil {\n \t\t\t\treturn nil, err\n \t\t\t}\n-\t\tcase extension.Id.Equal(oidExtensionKeyUsage):\n-\t\t\tout.KeyUsage, err = parseKeyUsageExtension(extension.Value)\n-\t\tcase extension.Id.Equal(oidExtensionExtendedKeyUsage):\n-\t\t\tout.ExtKeyUsage, out.UnknownExtKeyUsage, err = parseExtKeyUsageExtension(extension.Value)\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\tcase extension.Id.Equal(oidExtensionBasicConstraints):\n-\t\t\tout.IsCA, out.MaxPathLen, err = parseBasicConstraintsExtension(extension.Value)\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\t\tout.BasicConstraintsValid = true\n-\t\t\tout.MaxPathLenZero = out.MaxPathLen == 0\n-\t\tcase extension.Id.Equal(oidExtensionSubjectKeyId):\n-\t\t\tout.SubjectKeyId, err = parseSubjectKeyIdExtension(extension.Value)\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\tcase extension.Id.Equal(oidExtensionCertificatePolicies):\n-\t\t\tout.PolicyIdentifiers, err = parseCertificatePoliciesExtension(extension.Value)\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n \t\t}\n \t}\n "}, {"sha": "51dda16815b0bb13d7bb6eb9c817ef203edd1c75", "filename": "libgo/go/crypto/x509/x509_test.go", "status": "modified", "additions": 22, "deletions": 32, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -2964,44 +2964,34 @@ func certPoolEqual(a, b *CertPool) bool {\n }\n \n func TestCertificateRequestRoundtripFields(t *testing.T) {\n+\turlA, err := url.Parse(\"https://example.com/_\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\turlB, err := url.Parse(\"https://example.org/_\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n \tin := &CertificateRequest{\n-\t\tKeyUsage:              KeyUsageCertSign,\n-\t\tExtKeyUsage:           []ExtKeyUsage{ExtKeyUsageAny},\n-\t\tUnknownExtKeyUsage:    []asn1.ObjectIdentifier{{1, 2, 3}},\n-\t\tBasicConstraintsValid: true,\n-\t\tIsCA:                  true,\n-\t\tMaxPathLen:            0,\n-\t\tMaxPathLenZero:        true,\n-\t\tSubjectKeyId:          []byte{1, 2, 3},\n-\t\tPolicyIdentifiers:     []asn1.ObjectIdentifier{{1, 2, 3}},\n+\t\tDNSNames:       []string{\"example.com\", \"example.org\"},\n+\t\tEmailAddresses: []string{\"a@example.com\", \"b@example.com\"},\n+\t\tIPAddresses:    []net.IP{net.IPv4(192, 0, 2, 0), net.IPv6loopback},\n+\t\tURIs:           []*url.URL{urlA, urlB},\n \t}\n \tout := marshalAndParseCSR(t, in)\n \n-\tif in.KeyUsage != out.KeyUsage {\n-\t\tt.Fatalf(\"Unexpected KeyUsage: got %v, want %v\", out.KeyUsage, in.KeyUsage)\n-\t}\n-\tif !reflect.DeepEqual(in.ExtKeyUsage, out.ExtKeyUsage) {\n-\t\tt.Fatalf(\"Unexpected ExtKeyUsage: got %v, want %v\", out.ExtKeyUsage, in.ExtKeyUsage)\n-\t}\n-\tif !reflect.DeepEqual(in.UnknownExtKeyUsage, out.UnknownExtKeyUsage) {\n-\t\tt.Fatalf(\"Unexpected UnknownExtKeyUsage: got %v, want %v\", out.UnknownExtKeyUsage, in.UnknownExtKeyUsage)\n-\t}\n-\tif in.BasicConstraintsValid != out.BasicConstraintsValid {\n-\t\tt.Fatalf(\"Unexpected BasicConstraintsValid: got %v, want %v\", out.BasicConstraintsValid, in.BasicConstraintsValid)\n-\t}\n-\tif in.IsCA != out.IsCA {\n-\t\tt.Fatalf(\"Unexpected IsCA: got %v, want %v\", out.IsCA, in.IsCA)\n-\t}\n-\tif in.MaxPathLen != out.MaxPathLen {\n-\t\tt.Fatalf(\"Unexpected MaxPathLen: got %v, want %v\", out.MaxPathLen, in.MaxPathLen)\n+\tif !reflect.DeepEqual(in.DNSNames, out.DNSNames) {\n+\t\tt.Fatalf(\"Unexpected DNSNames: got %v, want %v\", out.DNSNames, in.DNSNames)\n \t}\n-\tif in.MaxPathLenZero != out.MaxPathLenZero {\n-\t\tt.Fatalf(\"Unexpected MaxPathLenZero: got %v, want %v\", out.MaxPathLenZero, in.MaxPathLenZero)\n+\tif !reflect.DeepEqual(in.EmailAddresses, out.EmailAddresses) {\n+\t\tt.Fatalf(\"Unexpected EmailAddresses: got %v, want %v\", out.EmailAddresses, in.EmailAddresses)\n \t}\n-\tif !reflect.DeepEqual(in.SubjectKeyId, out.SubjectKeyId) {\n-\t\tt.Fatalf(\"Unexpected SubjectKeyId: got %v, want %v\", out.SubjectKeyId, in.SubjectKeyId)\n+\tif len(in.IPAddresses) != len(out.IPAddresses) ||\n+\t\t!in.IPAddresses[0].Equal(out.IPAddresses[0]) ||\n+\t\t!in.IPAddresses[1].Equal(out.IPAddresses[1]) {\n+\t\tt.Fatalf(\"Unexpected IPAddresses: got %v, want %v\", out.IPAddresses, in.IPAddresses)\n \t}\n-\tif !reflect.DeepEqual(in.PolicyIdentifiers, out.PolicyIdentifiers) {\n-\t\tt.Fatalf(\"Unexpected PolicyIdentifiers: got %v, want %v\", out.PolicyIdentifiers, in.PolicyIdentifiers)\n+\tif !reflect.DeepEqual(in.URIs, out.URIs) {\n+\t\tt.Fatalf(\"Unexpected URIs: got %v, want %v\", out.URIs, in.URIs)\n \t}\n }"}, {"sha": "cc6855e6a5b0cc740a5893d12d045a761a061756", "filename": "libgo/go/embed/embed.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fembed%2Fembed.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fembed%2Fembed.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fembed%2Fembed.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -244,6 +244,9 @@ func (f FS) lookup(name string) *file {\n \tif name == \".\" {\n \t\treturn dotFile\n \t}\n+\tif f.files == nil {\n+\t\treturn nil\n+\t}\n \n \t// Binary search to find where name would be in the list,\n \t// and then check if name is at that position.\n@@ -261,6 +264,9 @@ func (f FS) lookup(name string) *file {\n \n // readDir returns the list of files corresponding to the directory dir.\n func (f FS) readDir(dir string) []file {\n+\tif f.files == nil {\n+\t\treturn nil\n+\t}\n \t// Binary search to find where dir starts and ends in the list\n \t// and then return that slice of the list.\n \tfiles := *f.files"}, {"sha": "43ae5c7e0569c87e3f9b08db68e24501a2c72ca1", "filename": "libgo/go/embed/internal/embedtest/embed_test.go", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fembed%2Finternal%2Fembedtest%2Fembed_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fembed%2Finternal%2Fembedtest%2Fembed_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fembed%2Finternal%2Fembedtest%2Fembed_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -73,24 +73,11 @@ func TestGlobal(t *testing.T) {\n \ttestString(t, string(glass), \"glass\", \"I can eat glass and it doesn't hurt me.\\n\")\n }\n \n-func TestLocal(t *testing.T) {\n-\t//go:embed testdata/k*.txt\n-\tvar local embed.FS\n-\ttestFiles(t, local, \"testdata/ken.txt\", \"If a program is too slow, it must have a loop.\\n\")\n-\n-\t//go:embed testdata/k*.txt\n-\tvar s string\n-\ttestString(t, s, \"local variable s\", \"If a program is too slow, it must have a loop.\\n\")\n-\n-\t//go:embed testdata/h*.txt\n-\tvar b []byte\n-\ttestString(t, string(b), \"local variable b\", \"hello, world\\n\")\n-}\n+//go:embed testdata\n+var testDirAll embed.FS\n \n func TestDir(t *testing.T) {\n-\t//go:embed testdata\n-\tvar all embed.FS\n-\n+\tall := testDirAll\n \ttestFiles(t, all, \"testdata/hello.txt\", \"hello, world\\n\")\n \ttestFiles(t, all, \"testdata/i/i18n.txt\", \"internationalization\\n\")\n \ttestFiles(t, all, \"testdata/i/j/k/k8s.txt\", \"kubernetes\\n\")\n@@ -102,12 +89,15 @@ func TestDir(t *testing.T) {\n \ttestDir(t, all, \"testdata/i/j/k\", \"k8s.txt\")\n }\n \n-func TestHidden(t *testing.T) {\n-\t//go:embed testdata\n-\tvar dir embed.FS\n+//go:embed testdata\n+var testHiddenDir embed.FS\n \n-\t//go:embed testdata/*\n-\tvar star embed.FS\n+//go:embed testdata/*\n+var testHiddenStar embed.FS\n+\n+func TestHidden(t *testing.T) {\n+\tdir := testHiddenDir\n+\tstar := testHiddenStar\n \n \tt.Logf(\"//go:embed testdata\")\n \n@@ -122,3 +112,20 @@ func TestHidden(t *testing.T) {\n \ttestDir(t, star, \"testdata/.hidden\",\n \t\t\"fortune.txt\", \"more/\") // but not .more or _more\n }\n+\n+func TestUninitialized(t *testing.T) {\n+\tvar uninitialized embed.FS\n+\ttestDir(t, uninitialized, \".\")\n+\tf, err := uninitialized.Open(\".\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer f.Close()\n+\tfi, err := f.Stat()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif !fi.IsDir() {\n+\t\tt.Errorf(\"in uninitialized embed.FS, . is not a directory\")\n+\t}\n+}"}, {"sha": "27fa11614e9268ea19149cb5c4cabd9faa374407", "filename": "libgo/go/embed/internal/embedtest/embedx_test.go", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fembed%2Finternal%2Fembedtest%2Fembedx_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fembed%2Finternal%2Fembedtest%2Fembedx_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fembed%2Finternal%2Fembedtest%2Fembedx_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -90,17 +90,3 @@ func TestXGlobal(t *testing.T) {\n \t}\n \tbbig[0] = old\n }\n-\n-func TestXLocal(t *testing.T) {\n-\t//go:embed testdata/*o.txt\n-\tvar local embed.FS\n-\ttestFiles(t, local, \"testdata/hello.txt\", \"hello, world\\n\")\n-\n-\t//go:embed testdata/k*.txt\n-\tvar s string\n-\ttestString(t, s, \"local variable s\", \"If a program is too slow, it must have a loop.\\n\")\n-\n-\t//go:embed testdata/h*.txt\n-\tvar b []byte\n-\ttestString(t, string(b), \"local variable b\", \"hello, world\\n\")\n-}"}, {"sha": "f9b9cb4930e9890aaf90ab83522d7bf69982509b", "filename": "libgo/go/encoding/asn1/asn1.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -1067,6 +1067,15 @@ func setDefaultValue(v reflect.Value, params fieldParameters) (ok bool) {\n //\tset         causes a SET, rather than a SEQUENCE type to be expected\n //\ttag:x       specifies the ASN.1 tag number; implies ASN.1 CONTEXT SPECIFIC\n //\n+// When decoding an ASN.1 value with an IMPLICIT tag into a string field,\n+// Unmarshal will default to a PrintableString, which doesn't support\n+// characters such as '@' and '&'. To force other encodings, use the following\n+// tags:\n+//\n+//\tia5     causes strings to be unmarshaled as ASN.1 IA5String values\n+//\tnumeric causes strings to be unmarshaled as ASN.1 NumericString values\n+//\tutf8    causes strings to be unmarshaled as ASN.1 UTF8String values\n+//\n // If the type of the first field of a structure is RawContent then the raw\n // ASN1 contents of the struct will be stored in it.\n //"}, {"sha": "3007cef435130f66ec150da1c7dd941acaac29ed", "filename": "libgo/go/go/build/build.go", "status": "modified", "additions": 41, "deletions": 29, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -11,13 +11,13 @@ import (\n \t\"go/ast\"\n \t\"go/doc\"\n \t\"go/token\"\n+\texec \"internal/execabs\"\n \t\"internal/goroot\"\n \t\"internal/goversion\"\n \t\"io\"\n \t\"io/fs\"\n \t\"io/ioutil\"\n \t\"os\"\n-\t\"os/exec\"\n \tpathpkg \"path\"\n \t\"path/filepath\"\n \t\"runtime\"\n@@ -451,9 +451,12 @@ type Package struct {\n \t//\t//go:embed a* b.c\n \t// then the list will contain those two strings as separate entries.\n \t// (See package embed for more details about //go:embed.)\n-\tEmbedPatterns      []string // patterns from GoFiles, CgoFiles\n-\tTestEmbedPatterns  []string // patterns from TestGoFiles\n-\tXTestEmbedPatterns []string // patterns from XTestGoFiles\n+\tEmbedPatterns        []string                    // patterns from GoFiles, CgoFiles\n+\tEmbedPatternPos      map[string][]token.Position // line information for EmbedPatterns\n+\tTestEmbedPatterns    []string                    // patterns from TestGoFiles\n+\tTestEmbedPatternPos  map[string][]token.Position // line information for TestEmbedPatterns\n+\tXTestEmbedPatterns   []string                    // patterns from XTestGoFiles\n+\tXTestEmbedPatternPos map[string][]token.Position // line information for XTestEmbedPatternPos\n }\n \n // IsCommand reports whether the package is considered a\n@@ -796,10 +799,12 @@ Found:\n \tvar badGoError error\n \tvar Sfiles []string // files with \".S\"(capital S)/.sx(capital s equivalent for case insensitive filesystems)\n \tvar firstFile, firstCommentFile string\n-\tvar embeds, testEmbeds, xTestEmbeds []string\n-\timported := make(map[string][]token.Position)\n-\ttestImported := make(map[string][]token.Position)\n-\txTestImported := make(map[string][]token.Position)\n+\tembedPos := make(map[string][]token.Position)\n+\ttestEmbedPos := make(map[string][]token.Position)\n+\txTestEmbedPos := make(map[string][]token.Position)\n+\timportPos := make(map[string][]token.Position)\n+\ttestImportPos := make(map[string][]token.Position)\n+\txTestImportPos := make(map[string][]token.Position)\n \tallTags := make(map[string]bool)\n \tfset := token.NewFileSet()\n \tfor _, d := range dirs {\n@@ -922,40 +927,42 @@ Found:\n \t\t\t}\n \t\t}\n \n-\t\tvar fileList, embedList *[]string\n-\t\tvar importMap map[string][]token.Position\n+\t\tvar fileList *[]string\n+\t\tvar importMap, embedMap map[string][]token.Position\n \t\tswitch {\n \t\tcase isCgo:\n \t\t\tallTags[\"cgo\"] = true\n \t\t\tif ctxt.CgoEnabled {\n \t\t\t\tfileList = &p.CgoFiles\n-\t\t\t\timportMap = imported\n-\t\t\t\tembedList = &embeds\n+\t\t\t\timportMap = importPos\n+\t\t\t\tembedMap = embedPos\n \t\t\t} else {\n-\t\t\t\t// Ignore imports from cgo files if cgo is disabled.\n+\t\t\t\t// Ignore imports and embeds from cgo files if cgo is disabled.\n \t\t\t\tfileList = &p.IgnoredGoFiles\n \t\t\t}\n \t\tcase isXTest:\n \t\t\tfileList = &p.XTestGoFiles\n-\t\t\timportMap = xTestImported\n-\t\t\tembedList = &xTestEmbeds\n+\t\t\timportMap = xTestImportPos\n+\t\t\tembedMap = xTestEmbedPos\n \t\tcase isTest:\n \t\t\tfileList = &p.TestGoFiles\n-\t\t\timportMap = testImported\n-\t\t\tembedList = &testEmbeds\n+\t\t\timportMap = testImportPos\n+\t\t\tembedMap = testEmbedPos\n \t\tdefault:\n \t\t\tfileList = &p.GoFiles\n-\t\t\timportMap = imported\n-\t\t\tembedList = &embeds\n+\t\t\timportMap = importPos\n+\t\t\tembedMap = embedPos\n \t\t}\n \t\t*fileList = append(*fileList, name)\n \t\tif importMap != nil {\n \t\t\tfor _, imp := range info.imports {\n \t\t\t\timportMap[imp.path] = append(importMap[imp.path], fset.Position(imp.pos))\n \t\t\t}\n \t\t}\n-\t\tif embedList != nil {\n-\t\t\t*embedList = append(*embedList, info.embeds...)\n+\t\tif embedMap != nil {\n+\t\t\tfor _, emb := range info.embeds {\n+\t\t\t\tembedMap[emb.pattern] = append(embedMap[emb.pattern], emb.pos)\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -964,13 +971,13 @@ Found:\n \t}\n \tsort.Strings(p.AllTags)\n \n-\tp.EmbedPatterns = uniq(embeds)\n-\tp.TestEmbedPatterns = uniq(testEmbeds)\n-\tp.XTestEmbedPatterns = uniq(xTestEmbeds)\n+\tp.EmbedPatterns, p.EmbedPatternPos = cleanDecls(embedPos)\n+\tp.TestEmbedPatterns, p.TestEmbedPatternPos = cleanDecls(testEmbedPos)\n+\tp.XTestEmbedPatterns, p.XTestEmbedPatternPos = cleanDecls(xTestEmbedPos)\n \n-\tp.Imports, p.ImportPos = cleanImports(imported)\n-\tp.TestImports, p.TestImportPos = cleanImports(testImported)\n-\tp.XTestImports, p.XTestImportPos = cleanImports(xTestImported)\n+\tp.Imports, p.ImportPos = cleanDecls(importPos)\n+\tp.TestImports, p.TestImportPos = cleanDecls(testImportPos)\n+\tp.XTestImports, p.XTestImportPos = cleanDecls(xTestImportPos)\n \n \t// add the .S/.sx files only if we are using cgo\n \t// (which means gcc will compile them).\n@@ -1342,7 +1349,7 @@ type fileInfo struct {\n \tparsed   *ast.File\n \tparseErr error\n \timports  []fileImport\n-\tembeds   []string\n+\tembeds   []fileEmbed\n \tembedErr error\n }\n \n@@ -1352,6 +1359,11 @@ type fileImport struct {\n \tdoc  *ast.CommentGroup\n }\n \n+type fileEmbed struct {\n+\tpattern string\n+\tpos     token.Position\n+}\n+\n // matchFile determines whether the file with the given name in the given directory\n // should be included in the package being constructed.\n // If the file should be included, matchFile returns a non-nil *fileInfo (and a nil error).\n@@ -1426,7 +1438,7 @@ func (ctxt *Context) matchFile(dir, name string, allTags map[string]bool, binary\n \treturn info, nil\n }\n \n-func cleanImports(m map[string][]token.Position) ([]string, map[string][]token.Position) {\n+func cleanDecls(m map[string][]token.Position) ([]string, map[string][]token.Position) {\n \tall := make([]string, 0, len(m))\n \tfor path := range m {\n \t\tall = append(all, path)"}, {"sha": "490c212642cf5b9f52db495164a2bb3a5d0f2988", "filename": "libgo/go/go/build/build_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -28,6 +28,7 @@ func TestMatch(t *testing.T) {\n \tctxt := Default\n \twhat := \"default\"\n \tmatch := func(tag string, want map[string]bool) {\n+\t\tt.Helper()\n \t\tm := make(map[string]bool)\n \t\tif !ctxt.match(tag, m) {\n \t\t\tt.Errorf(\"%s context should match %s, does not\", what, tag)\n@@ -37,6 +38,7 @@ func TestMatch(t *testing.T) {\n \t\t}\n \t}\n \tnomatch := func(tag string, want map[string]bool) {\n+\t\tt.Helper()\n \t\tm := make(map[string]bool)\n \t\tif ctxt.match(tag, m) {\n \t\t\tt.Errorf(\"%s context should NOT match %s, does\", what, tag)\n@@ -57,7 +59,6 @@ func TestMatch(t *testing.T) {\n \tnomatch(runtime.GOOS+\",\"+runtime.GOARCH+\",!foo\", map[string]bool{runtime.GOOS: true, runtime.GOARCH: true, \"foo\": true})\n \tmatch(runtime.GOOS+\",\"+runtime.GOARCH+\",!bar\", map[string]bool{runtime.GOOS: true, runtime.GOARCH: true, \"bar\": true})\n \tnomatch(runtime.GOOS+\",\"+runtime.GOARCH+\",bar\", map[string]bool{runtime.GOOS: true, runtime.GOARCH: true, \"bar\": true})\n-\tnomatch(\"!\", map[string]bool{})\n }\n \n func TestDotSlashImport(t *testing.T) {"}, {"sha": "3b278702f808b3346e2734ae7aa91480d542825e", "filename": "libgo/go/go/build/constraint/expr.go", "status": "added", "additions": 574, "deletions": 0, "changes": 574, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgo%2Fbuild%2Fconstraint%2Fexpr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgo%2Fbuild%2Fconstraint%2Fexpr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fconstraint%2Fexpr.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -0,0 +1,574 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package constraint implements parsing and evaluation of build constraint lines.\n+// See https://golang.org/cmd/go/#hdr-Build_constraints for documentation about build constraints themselves.\n+//\n+// This package parses both the original \u201c// +build\u201d syntax and the \u201c//go:build\u201d syntax that will be added in Go 1.17.\n+// The parser is being included in Go 1.16 to allow tools that need to process Go 1.17 source code\n+// to still be built against the Go 1.16 release.\n+// See https://golang.org/design/draft-gobuild for details about the \u201c//go:build\u201d syntax.\n+package constraint\n+\n+import (\n+\t\"errors\"\n+\t\"strings\"\n+\t\"unicode\"\n+\t\"unicode/utf8\"\n+)\n+\n+// An Expr is a build tag constraint expression.\n+// The underlying concrete type is *AndExpr, *OrExpr, *NotExpr, or *TagExpr.\n+type Expr interface {\n+\t// String returns the string form of the expression,\n+\t// using the boolean syntax used in //go:build lines.\n+\tString() string\n+\n+\t// Eval reports whether the expression evaluates to true.\n+\t// It calls ok(tag) as needed to find out whether a given build tag\n+\t// is satisfied by the current build configuration.\n+\tEval(ok func(tag string) bool) bool\n+\n+\t// The presence of an isExpr method explicitly marks the type as an Expr.\n+\t// Only implementations in this package should be used as Exprs.\n+\tisExpr()\n+}\n+\n+// A TagExpr is an Expr for the single tag Tag.\n+type TagExpr struct {\n+\tTag string // for example, \u201clinux\u201d or \u201ccgo\u201d\n+}\n+\n+func (x *TagExpr) isExpr() {}\n+\n+func (x *TagExpr) Eval(ok func(tag string) bool) bool {\n+\treturn ok(x.Tag)\n+}\n+\n+func (x *TagExpr) String() string {\n+\treturn x.Tag\n+}\n+\n+func tag(tag string) Expr { return &TagExpr{tag} }\n+\n+// A NotExpr represents the expression !X (the negation of X).\n+type NotExpr struct {\n+\tX Expr\n+}\n+\n+func (x *NotExpr) isExpr() {}\n+\n+func (x *NotExpr) Eval(ok func(tag string) bool) bool {\n+\treturn !x.X.Eval(ok)\n+}\n+\n+func (x *NotExpr) String() string {\n+\ts := x.X.String()\n+\tswitch x.X.(type) {\n+\tcase *AndExpr, *OrExpr:\n+\t\ts = \"(\" + s + \")\"\n+\t}\n+\treturn \"!\" + s\n+}\n+\n+func not(x Expr) Expr { return &NotExpr{x} }\n+\n+// An AndExpr represents the expression X && Y.\n+type AndExpr struct {\n+\tX, Y Expr\n+}\n+\n+func (x *AndExpr) isExpr() {}\n+\n+func (x *AndExpr) Eval(ok func(tag string) bool) bool {\n+\t// Note: Eval both, to make sure ok func observes all tags.\n+\txok := x.X.Eval(ok)\n+\tyok := x.Y.Eval(ok)\n+\treturn xok && yok\n+}\n+\n+func (x *AndExpr) String() string {\n+\treturn andArg(x.X) + \" && \" + andArg(x.Y)\n+}\n+\n+func andArg(x Expr) string {\n+\ts := x.String()\n+\tif _, ok := x.(*OrExpr); ok {\n+\t\ts = \"(\" + s + \")\"\n+\t}\n+\treturn s\n+}\n+\n+func and(x, y Expr) Expr {\n+\treturn &AndExpr{x, y}\n+}\n+\n+// An OrExpr represents the expression X || Y.\n+type OrExpr struct {\n+\tX, Y Expr\n+}\n+\n+func (x *OrExpr) isExpr() {}\n+\n+func (x *OrExpr) Eval(ok func(tag string) bool) bool {\n+\t// Note: Eval both, to make sure ok func observes all tags.\n+\txok := x.X.Eval(ok)\n+\tyok := x.Y.Eval(ok)\n+\treturn xok || yok\n+}\n+\n+func (x *OrExpr) String() string {\n+\treturn orArg(x.X) + \" || \" + orArg(x.Y)\n+}\n+\n+func orArg(x Expr) string {\n+\ts := x.String()\n+\tif _, ok := x.(*AndExpr); ok {\n+\t\ts = \"(\" + s + \")\"\n+\t}\n+\treturn s\n+}\n+\n+func or(x, y Expr) Expr {\n+\treturn &OrExpr{x, y}\n+}\n+\n+// A SyntaxError reports a syntax error in a parsed build expression.\n+type SyntaxError struct {\n+\tOffset int    // byte offset in input where error was detected\n+\tErr    string // description of error\n+}\n+\n+func (e *SyntaxError) Error() string {\n+\treturn e.Err\n+}\n+\n+var errNotConstraint = errors.New(\"not a build constraint\")\n+\n+// Parse parses a single build constraint line of the form \u201c//go:build ...\u201d or \u201c// +build ...\u201d\n+// and returns the corresponding boolean expression.\n+func Parse(line string) (Expr, error) {\n+\tif text, ok := splitGoBuild(line); ok {\n+\t\treturn parseExpr(text)\n+\t}\n+\tif text, ok := splitPlusBuild(line); ok {\n+\t\treturn parsePlusBuildExpr(text), nil\n+\t}\n+\treturn nil, errNotConstraint\n+}\n+\n+// IsGoBuild reports whether the line of text is a \u201c//go:build\u201d constraint.\n+// It only checks the prefix of the text, not that the expression itself parses.\n+func IsGoBuild(line string) bool {\n+\t_, ok := splitGoBuild(line)\n+\treturn ok\n+}\n+\n+// splitGoBuild splits apart the leading //go:build prefix in line from the build expression itself.\n+// It returns \"\", false if the input is not a //go:build line or if the input contains multiple lines.\n+func splitGoBuild(line string) (expr string, ok bool) {\n+\t// A single trailing newline is OK; otherwise multiple lines are not.\n+\tif len(line) > 0 && line[len(line)-1] == '\\n' {\n+\t\tline = line[:len(line)-1]\n+\t}\n+\tif strings.Contains(line, \"\\n\") {\n+\t\treturn \"\", false\n+\t}\n+\n+\tif !strings.HasPrefix(line, \"//go:build\") {\n+\t\treturn \"\", false\n+\t}\n+\n+\tline = strings.TrimSpace(line)\n+\tline = line[len(\"//go:build\"):]\n+\n+\t// If strings.TrimSpace finds more to trim after removing the //go:build prefix,\n+\t// it means that the prefix was followed by a space, making this a //go:build line\n+\t// (as opposed to a //go:buildsomethingelse line).\n+\t// If line is empty, we had \"//go:build\" by itself, which also counts.\n+\ttrim := strings.TrimSpace(line)\n+\tif len(line) == len(trim) && line != \"\" {\n+\t\treturn \"\", false\n+\t}\n+\n+\treturn trim, true\n+}\n+\n+// An exprParser holds state for parsing a build expression.\n+type exprParser struct {\n+\ts string // input string\n+\ti int    // next read location in s\n+\n+\ttok   string // last token read\n+\tisTag bool\n+\tpos   int // position (start) of last token\n+}\n+\n+// parseExpr parses a boolean build tag expression.\n+func parseExpr(text string) (x Expr, err error) {\n+\tdefer func() {\n+\t\tif e := recover(); e != nil {\n+\t\t\tif e, ok := e.(*SyntaxError); ok {\n+\t\t\t\terr = e\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tpanic(e) // unreachable unless parser has a bug\n+\t\t}\n+\t}()\n+\n+\tp := &exprParser{s: text}\n+\tx = p.or()\n+\tif p.tok != \"\" {\n+\t\tpanic(&SyntaxError{Offset: p.pos, Err: \"unexpected token \" + p.tok})\n+\t}\n+\treturn x, nil\n+}\n+\n+// or parses a sequence of || expressions.\n+// On entry, the next input token has not yet been lexed.\n+// On exit, the next input token has been lexed and is in p.tok.\n+func (p *exprParser) or() Expr {\n+\tx := p.and()\n+\tfor p.tok == \"||\" {\n+\t\tx = or(x, p.and())\n+\t}\n+\treturn x\n+}\n+\n+// and parses a sequence of && expressions.\n+// On entry, the next input token has not yet been lexed.\n+// On exit, the next input token has been lexed and is in p.tok.\n+func (p *exprParser) and() Expr {\n+\tx := p.not()\n+\tfor p.tok == \"&&\" {\n+\t\tx = and(x, p.not())\n+\t}\n+\treturn x\n+}\n+\n+// not parses a ! expression.\n+// On entry, the next input token has not yet been lexed.\n+// On exit, the next input token has been lexed and is in p.tok.\n+func (p *exprParser) not() Expr {\n+\tp.lex()\n+\tif p.tok == \"!\" {\n+\t\tp.lex()\n+\t\tif p.tok == \"!\" {\n+\t\t\tpanic(&SyntaxError{Offset: p.pos, Err: \"double negation not allowed\"})\n+\t\t}\n+\t\treturn not(p.atom())\n+\t}\n+\treturn p.atom()\n+}\n+\n+// atom parses a tag or a parenthesized expression.\n+// On entry, the next input token HAS been lexed.\n+// On exit, the next input token has been lexed and is in p.tok.\n+func (p *exprParser) atom() Expr {\n+\t// first token already in p.tok\n+\tif p.tok == \"(\" {\n+\t\tpos := p.pos\n+\t\tdefer func() {\n+\t\t\tif e := recover(); e != nil {\n+\t\t\t\tif e, ok := e.(*SyntaxError); ok && e.Err == \"unexpected end of expression\" {\n+\t\t\t\t\te.Err = \"missing close paren\"\n+\t\t\t\t}\n+\t\t\t\tpanic(e)\n+\t\t\t}\n+\t\t}()\n+\t\tx := p.or()\n+\t\tif p.tok != \")\" {\n+\t\t\tpanic(&SyntaxError{Offset: pos, Err: \"missing close paren\"})\n+\t\t}\n+\t\tp.lex()\n+\t\treturn x\n+\t}\n+\n+\tif !p.isTag {\n+\t\tif p.tok == \"\" {\n+\t\t\tpanic(&SyntaxError{Offset: p.pos, Err: \"unexpected end of expression\"})\n+\t\t}\n+\t\tpanic(&SyntaxError{Offset: p.pos, Err: \"unexpected token \" + p.tok})\n+\t}\n+\ttok := p.tok\n+\tp.lex()\n+\treturn tag(tok)\n+}\n+\n+// lex finds and consumes the next token in the input stream.\n+// On return, p.tok is set to the token text,\n+// p.isTag reports whether the token was a tag,\n+// and p.pos records the byte offset of the start of the token in the input stream.\n+// If lex reaches the end of the input, p.tok is set to the empty string.\n+// For any other syntax error, lex panics with a SyntaxError.\n+func (p *exprParser) lex() {\n+\tp.isTag = false\n+\tfor p.i < len(p.s) && (p.s[p.i] == ' ' || p.s[p.i] == '\\t') {\n+\t\tp.i++\n+\t}\n+\tif p.i >= len(p.s) {\n+\t\tp.tok = \"\"\n+\t\tp.pos = p.i\n+\t\treturn\n+\t}\n+\tswitch p.s[p.i] {\n+\tcase '(', ')', '!':\n+\t\tp.pos = p.i\n+\t\tp.i++\n+\t\tp.tok = p.s[p.pos:p.i]\n+\t\treturn\n+\n+\tcase '&', '|':\n+\t\tif p.i+1 >= len(p.s) || p.s[p.i+1] != p.s[p.i] {\n+\t\t\tpanic(&SyntaxError{Offset: p.i, Err: \"invalid syntax at \" + string(rune(p.s[p.i]))})\n+\t\t}\n+\t\tp.pos = p.i\n+\t\tp.i += 2\n+\t\tp.tok = p.s[p.pos:p.i]\n+\t\treturn\n+\t}\n+\n+\ttag := p.s[p.i:]\n+\tfor i, c := range tag {\n+\t\tif !unicode.IsLetter(c) && !unicode.IsDigit(c) && c != '_' && c != '.' {\n+\t\t\ttag = tag[:i]\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tif tag == \"\" {\n+\t\tc, _ := utf8.DecodeRuneInString(p.s[p.i:])\n+\t\tpanic(&SyntaxError{Offset: p.i, Err: \"invalid syntax at \" + string(c)})\n+\t}\n+\n+\tp.pos = p.i\n+\tp.i += len(tag)\n+\tp.tok = p.s[p.pos:p.i]\n+\tp.isTag = true\n+\treturn\n+}\n+\n+// IsPlusBuild reports whether the line of text is a \u201c// +build\u201d constraint.\n+// It only checks the prefix of the text, not that the expression itself parses.\n+func IsPlusBuild(line string) bool {\n+\t_, ok := splitPlusBuild(line)\n+\treturn ok\n+}\n+\n+// splitGoBuild splits apart the leading //go:build prefix in line from the build expression itself.\n+// It returns \"\", false if the input is not a //go:build line or if the input contains multiple lines.\n+func splitPlusBuild(line string) (expr string, ok bool) {\n+\t// A single trailing newline is OK; otherwise multiple lines are not.\n+\tif len(line) > 0 && line[len(line)-1] == '\\n' {\n+\t\tline = line[:len(line)-1]\n+\t}\n+\tif strings.Contains(line, \"\\n\") {\n+\t\treturn \"\", false\n+\t}\n+\n+\tif !strings.HasPrefix(line, \"//\") {\n+\t\treturn \"\", false\n+\t}\n+\tline = line[len(\"//\"):]\n+\t// Note the space is optional; \"//+build\" is recognized too.\n+\tline = strings.TrimSpace(line)\n+\n+\tif !strings.HasPrefix(line, \"+build\") {\n+\t\treturn \"\", false\n+\t}\n+\tline = line[len(\"+build\"):]\n+\n+\t// If strings.TrimSpace finds more to trim after removing the +build prefix,\n+\t// it means that the prefix was followed by a space, making this a +build line\n+\t// (as opposed to a +buildsomethingelse line).\n+\t// If line is empty, we had \"// +build\" by itself, which also counts.\n+\ttrim := strings.TrimSpace(line)\n+\tif len(line) == len(trim) && line != \"\" {\n+\t\treturn \"\", false\n+\t}\n+\n+\treturn trim, true\n+}\n+\n+// parsePlusBuildExpr parses a legacy build tag expression (as used with \u201c// +build\u201d).\n+func parsePlusBuildExpr(text string) Expr {\n+\tvar x Expr\n+\tfor _, clause := range strings.Fields(text) {\n+\t\tvar y Expr\n+\t\tfor _, lit := range strings.Split(clause, \",\") {\n+\t\t\tvar z Expr\n+\t\t\tvar neg bool\n+\t\t\tif strings.HasPrefix(lit, \"!!\") || lit == \"!\" {\n+\t\t\t\tz = tag(\"ignore\")\n+\t\t\t} else {\n+\t\t\t\tif strings.HasPrefix(lit, \"!\") {\n+\t\t\t\t\tneg = true\n+\t\t\t\t\tlit = lit[len(\"!\"):]\n+\t\t\t\t}\n+\t\t\t\tif isValidTag(lit) {\n+\t\t\t\t\tz = tag(lit)\n+\t\t\t\t} else {\n+\t\t\t\t\tz = tag(\"ignore\")\n+\t\t\t\t}\n+\t\t\t\tif neg {\n+\t\t\t\t\tz = not(z)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif y == nil {\n+\t\t\t\ty = z\n+\t\t\t} else {\n+\t\t\t\ty = and(y, z)\n+\t\t\t}\n+\t\t}\n+\t\tif x == nil {\n+\t\t\tx = y\n+\t\t} else {\n+\t\t\tx = or(x, y)\n+\t\t}\n+\t}\n+\treturn x\n+}\n+\n+// isValidTag reports whether the word is a valid build tag.\n+// Tags must be letters, digits, underscores or dots.\n+// Unlike in Go identifiers, all digits are fine (e.g., \"386\").\n+func isValidTag(word string) bool {\n+\tif word == \"\" {\n+\t\treturn false\n+\t}\n+\tfor _, c := range word {\n+\t\tif !unicode.IsLetter(c) && !unicode.IsDigit(c) && c != '_' && c != '.' {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+var errComplex = errors.New(\"expression too complex for // +build lines\")\n+\n+// PlusBuildLines returns a sequence of \u201c// +build\u201d lines that evaluate to the build expression x.\n+// If the expression is too complex to convert directly to \u201c// +build\u201d lines, PlusBuildLines returns an error.\n+func PlusBuildLines(x Expr) ([]string, error) {\n+\t// Push all NOTs to the expression leaves, so that //go:build !(x && y) can be treated as !x || !y.\n+\t// This rewrite is both efficient and commonly needed, so it's worth doing.\n+\t// Essentially all other possible rewrites are too expensive and too rarely needed.\n+\tx = pushNot(x, false)\n+\n+\t// Split into AND of ORs of ANDs of literals (tag or NOT tag).\n+\tvar split [][][]Expr\n+\tfor _, or := range appendSplitAnd(nil, x) {\n+\t\tvar ands [][]Expr\n+\t\tfor _, and := range appendSplitOr(nil, or) {\n+\t\t\tvar lits []Expr\n+\t\t\tfor _, lit := range appendSplitAnd(nil, and) {\n+\t\t\t\tswitch lit.(type) {\n+\t\t\t\tcase *TagExpr, *NotExpr:\n+\t\t\t\t\tlits = append(lits, lit)\n+\t\t\t\tdefault:\n+\t\t\t\t\treturn nil, errComplex\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tands = append(ands, lits)\n+\t\t}\n+\t\tsplit = append(split, ands)\n+\t}\n+\n+\t// If all the ORs have length 1 (no actual OR'ing going on),\n+\t// push the top-level ANDs to the bottom level, so that we get\n+\t// one // +build line instead of many.\n+\tmaxOr := 0\n+\tfor _, or := range split {\n+\t\tif maxOr < len(or) {\n+\t\t\tmaxOr = len(or)\n+\t\t}\n+\t}\n+\tif maxOr == 1 {\n+\t\tvar lits []Expr\n+\t\tfor _, or := range split {\n+\t\t\tlits = append(lits, or[0]...)\n+\t\t}\n+\t\tsplit = [][][]Expr{{lits}}\n+\t}\n+\n+\t// Prepare the +build lines.\n+\tvar lines []string\n+\tfor _, or := range split {\n+\t\tline := \"// +build\"\n+\t\tfor _, and := range or {\n+\t\t\tclause := \"\"\n+\t\t\tfor i, lit := range and {\n+\t\t\t\tif i > 0 {\n+\t\t\t\t\tclause += \",\"\n+\t\t\t\t}\n+\t\t\t\tclause += lit.String()\n+\t\t\t}\n+\t\t\tline += \" \" + clause\n+\t\t}\n+\t\tlines = append(lines, line)\n+\t}\n+\n+\treturn lines, nil\n+}\n+\n+// pushNot applies DeMorgan's law to push negations down the expression,\n+// so that only tags are negated in the result.\n+// (It applies the rewrites !(X && Y) => (!X || !Y) and !(X || Y) => (!X && !Y).)\n+func pushNot(x Expr, not bool) Expr {\n+\tswitch x := x.(type) {\n+\tdefault:\n+\t\t// unreachable\n+\t\treturn x\n+\tcase *NotExpr:\n+\t\tif _, ok := x.X.(*TagExpr); ok && !not {\n+\t\t\treturn x\n+\t\t}\n+\t\treturn pushNot(x.X, !not)\n+\tcase *TagExpr:\n+\t\tif not {\n+\t\t\treturn &NotExpr{X: x}\n+\t\t}\n+\t\treturn x\n+\tcase *AndExpr:\n+\t\tx1 := pushNot(x.X, not)\n+\t\ty1 := pushNot(x.Y, not)\n+\t\tif not {\n+\t\t\treturn or(x1, y1)\n+\t\t}\n+\t\tif x1 == x.X && y1 == x.Y {\n+\t\t\treturn x\n+\t\t}\n+\t\treturn and(x1, y1)\n+\tcase *OrExpr:\n+\t\tx1 := pushNot(x.X, not)\n+\t\ty1 := pushNot(x.Y, not)\n+\t\tif not {\n+\t\t\treturn and(x1, y1)\n+\t\t}\n+\t\tif x1 == x.X && y1 == x.Y {\n+\t\t\treturn x\n+\t\t}\n+\t\treturn or(x1, y1)\n+\t}\n+}\n+\n+// appendSplitAnd appends x to list while splitting apart any top-level && expressions.\n+// For example, appendSplitAnd({W}, X && Y && Z) = {W, X, Y, Z}.\n+func appendSplitAnd(list []Expr, x Expr) []Expr {\n+\tif x, ok := x.(*AndExpr); ok {\n+\t\tlist = appendSplitAnd(list, x.X)\n+\t\tlist = appendSplitAnd(list, x.Y)\n+\t\treturn list\n+\t}\n+\treturn append(list, x)\n+}\n+\n+// appendSplitOr appends x to list while splitting apart any top-level || expressions.\n+// For example, appendSplitOr({W}, X || Y || Z) = {W, X, Y, Z}.\n+func appendSplitOr(list []Expr, x Expr) []Expr {\n+\tif x, ok := x.(*OrExpr); ok {\n+\t\tlist = appendSplitOr(list, x.X)\n+\t\tlist = appendSplitOr(list, x.Y)\n+\t\treturn list\n+\t}\n+\treturn append(list, x)\n+}"}, {"sha": "4979f8b5f28978e8e891b818e5df709b3eccf17a", "filename": "libgo/go/go/build/constraint/expr_test.go", "status": "added", "additions": 317, "deletions": 0, "changes": 317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgo%2Fbuild%2Fconstraint%2Fexpr_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgo%2Fbuild%2Fconstraint%2Fexpr_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fconstraint%2Fexpr_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -0,0 +1,317 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package constraint\n+\n+import (\n+\t\"fmt\"\n+\t\"reflect\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+var exprStringTests = []struct {\n+\tx   Expr\n+\tout string\n+}{\n+\t{\n+\t\tx:   tag(\"abc\"),\n+\t\tout: \"abc\",\n+\t},\n+\t{\n+\t\tx:   not(tag(\"abc\")),\n+\t\tout: \"!abc\",\n+\t},\n+\t{\n+\t\tx:   not(and(tag(\"abc\"), tag(\"def\"))),\n+\t\tout: \"!(abc && def)\",\n+\t},\n+\t{\n+\t\tx:   and(tag(\"abc\"), or(tag(\"def\"), tag(\"ghi\"))),\n+\t\tout: \"abc && (def || ghi)\",\n+\t},\n+\t{\n+\t\tx:   or(and(tag(\"abc\"), tag(\"def\")), tag(\"ghi\")),\n+\t\tout: \"(abc && def) || ghi\",\n+\t},\n+}\n+\n+func TestExprString(t *testing.T) {\n+\tfor i, tt := range exprStringTests {\n+\t\tt.Run(fmt.Sprint(i), func(t *testing.T) {\n+\t\t\ts := tt.x.String()\n+\t\t\tif s != tt.out {\n+\t\t\t\tt.Errorf(\"String() mismatch:\\nhave %s\\nwant %s\", s, tt.out)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+var lexTests = []struct {\n+\tin  string\n+\tout string\n+}{\n+\t{\"\", \"\"},\n+\t{\"x\", \"x\"},\n+\t{\"x.y\", \"x.y\"},\n+\t{\"x_y\", \"x_y\"},\n+\t{\"\u03b1x\", \"\u03b1x\"},\n+\t{\"\u03b1x\u00b2\", \"\u03b1x err: invalid syntax at \u00b2\"},\n+\t{\"go1.2\", \"go1.2\"},\n+\t{\"x y\", \"x y\"},\n+\t{\"x!y\", \"x ! y\"},\n+\t{\"&&||!()xy yx \", \"&& || ! ( ) xy yx\"},\n+\t{\"x~\", \"x err: invalid syntax at ~\"},\n+\t{\"x ~\", \"x err: invalid syntax at ~\"},\n+\t{\"x &\", \"x err: invalid syntax at &\"},\n+\t{\"x &y\", \"x err: invalid syntax at &\"},\n+}\n+\n+func TestLex(t *testing.T) {\n+\tfor i, tt := range lexTests {\n+\t\tt.Run(fmt.Sprint(i), func(t *testing.T) {\n+\t\t\tp := &exprParser{s: tt.in}\n+\t\t\tout := \"\"\n+\t\t\tfor {\n+\t\t\t\ttok, err := lexHelp(p)\n+\t\t\t\tif tok == \"\" && err == nil {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tif out != \"\" {\n+\t\t\t\t\tout += \" \"\n+\t\t\t\t}\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tout += \"err: \" + err.Error()\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tout += tok\n+\t\t\t}\n+\t\t\tif out != tt.out {\n+\t\t\t\tt.Errorf(\"lex(%q):\\nhave %s\\nwant %s\", tt.in, out, tt.out)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func lexHelp(p *exprParser) (tok string, err error) {\n+\tdefer func() {\n+\t\tif e := recover(); e != nil {\n+\t\t\tif e, ok := e.(*SyntaxError); ok {\n+\t\t\t\terr = e\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tpanic(e)\n+\t\t}\n+\t}()\n+\n+\tp.lex()\n+\treturn p.tok, nil\n+}\n+\n+var parseExprTests = []struct {\n+\tin string\n+\tx  Expr\n+}{\n+\t{\"x\", tag(\"x\")},\n+\t{\"x&&y\", and(tag(\"x\"), tag(\"y\"))},\n+\t{\"x||y\", or(tag(\"x\"), tag(\"y\"))},\n+\t{\"(x)\", tag(\"x\")},\n+\t{\"x||y&&z\", or(tag(\"x\"), and(tag(\"y\"), tag(\"z\")))},\n+\t{\"x&&y||z\", or(and(tag(\"x\"), tag(\"y\")), tag(\"z\"))},\n+\t{\"x&&(y||z)\", and(tag(\"x\"), or(tag(\"y\"), tag(\"z\")))},\n+\t{\"(x||y)&&z\", and(or(tag(\"x\"), tag(\"y\")), tag(\"z\"))},\n+\t{\"!(x&&y)\", not(and(tag(\"x\"), tag(\"y\")))},\n+}\n+\n+func TestParseExpr(t *testing.T) {\n+\tfor i, tt := range parseExprTests {\n+\t\tt.Run(fmt.Sprint(i), func(t *testing.T) {\n+\t\t\tx, err := parseExpr(tt.in)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tif x.String() != tt.x.String() {\n+\t\t\t\tt.Errorf(\"parseExpr(%q):\\nhave %s\\nwant %s\", tt.in, x, tt.x)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+var parseExprErrorTests = []struct {\n+\tin  string\n+\terr error\n+}{\n+\t{\"x && \", &SyntaxError{Offset: 5, Err: \"unexpected end of expression\"}},\n+\t{\"x && (\", &SyntaxError{Offset: 6, Err: \"missing close paren\"}},\n+\t{\"x && ||\", &SyntaxError{Offset: 5, Err: \"unexpected token ||\"}},\n+\t{\"x && !\", &SyntaxError{Offset: 6, Err: \"unexpected end of expression\"}},\n+\t{\"x && !!\", &SyntaxError{Offset: 6, Err: \"double negation not allowed\"}},\n+\t{\"x !\", &SyntaxError{Offset: 2, Err: \"unexpected token !\"}},\n+\t{\"x && (y\", &SyntaxError{Offset: 5, Err: \"missing close paren\"}},\n+}\n+\n+func TestParseError(t *testing.T) {\n+\tfor i, tt := range parseExprErrorTests {\n+\t\tt.Run(fmt.Sprint(i), func(t *testing.T) {\n+\t\t\tx, err := parseExpr(tt.in)\n+\t\t\tif err == nil {\n+\t\t\t\tt.Fatalf(\"parseExpr(%q) = %v, want error\", tt.in, x)\n+\t\t\t}\n+\t\t\tif !reflect.DeepEqual(err, tt.err) {\n+\t\t\t\tt.Fatalf(\"parseExpr(%q): wrong error:\\nhave %#v\\nwant %#v\", tt.in, err, tt.err)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+var exprEvalTests = []struct {\n+\tin   string\n+\tok   bool\n+\ttags string\n+}{\n+\t{\"x\", false, \"x\"},\n+\t{\"x && y\", false, \"x y\"},\n+\t{\"x || y\", false, \"x y\"},\n+\t{\"!x && yes\", true, \"x yes\"},\n+\t{\"yes || y\", true, \"y yes\"},\n+}\n+\n+func TestExprEval(t *testing.T) {\n+\tfor i, tt := range exprEvalTests {\n+\t\tt.Run(fmt.Sprint(i), func(t *testing.T) {\n+\t\t\tx, err := parseExpr(tt.in)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\ttags := make(map[string]bool)\n+\t\t\twantTags := make(map[string]bool)\n+\t\t\tfor _, tag := range strings.Fields(tt.tags) {\n+\t\t\t\twantTags[tag] = true\n+\t\t\t}\n+\t\t\thasTag := func(tag string) bool {\n+\t\t\t\ttags[tag] = true\n+\t\t\t\treturn tag == \"yes\"\n+\t\t\t}\n+\t\t\tok := x.Eval(hasTag)\n+\t\t\tif ok != tt.ok || !reflect.DeepEqual(tags, wantTags) {\n+\t\t\t\tt.Errorf(\"Eval(%#q):\\nhave ok=%v, tags=%v\\nwant ok=%v, tags=%v\",\n+\t\t\t\t\ttt.in, ok, tags, tt.ok, wantTags)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+var parsePlusBuildExprTests = []struct {\n+\tin string\n+\tx  Expr\n+}{\n+\t{\"x\", tag(\"x\")},\n+\t{\"x,y\", and(tag(\"x\"), tag(\"y\"))},\n+\t{\"x y\", or(tag(\"x\"), tag(\"y\"))},\n+\t{\"x y,z\", or(tag(\"x\"), and(tag(\"y\"), tag(\"z\")))},\n+\t{\"x,y z\", or(and(tag(\"x\"), tag(\"y\")), tag(\"z\"))},\n+\t{\"x,!y !z\", or(and(tag(\"x\"), not(tag(\"y\"))), not(tag(\"z\")))},\n+\t{\"!! x\", or(tag(\"ignore\"), tag(\"x\"))},\n+\t{\"!!x\", tag(\"ignore\")},\n+\t{\"!x\", not(tag(\"x\"))},\n+\t{\"!\", tag(\"ignore\")},\n+}\n+\n+func TestParsePlusBuildExpr(t *testing.T) {\n+\tfor i, tt := range parsePlusBuildExprTests {\n+\t\tt.Run(fmt.Sprint(i), func(t *testing.T) {\n+\t\t\tx := parsePlusBuildExpr(tt.in)\n+\t\t\tif x.String() != tt.x.String() {\n+\t\t\t\tt.Errorf(\"parsePlusBuildExpr(%q):\\nhave %v\\nwant %v\", tt.in, x, tt.x)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+var constraintTests = []struct {\n+\tin  string\n+\tx   Expr\n+\terr error\n+}{\n+\t{\"//+build x y\", or(tag(\"x\"), tag(\"y\")), nil},\n+\t{\"// +build x y \\n\", or(tag(\"x\"), tag(\"y\")), nil},\n+\t{\"// +build x y \\n \", nil, errNotConstraint},\n+\t{\"// +build x y \\nmore\", nil, errNotConstraint},\n+\t{\" //+build x y\", nil, errNotConstraint},\n+\n+\t{\"//go:build x && y\", and(tag(\"x\"), tag(\"y\")), nil},\n+\t{\"//go:build x && y\\n\", and(tag(\"x\"), tag(\"y\")), nil},\n+\t{\"//go:build x && y\\n \", nil, errNotConstraint},\n+\t{\"//go:build x && y\\nmore\", nil, errNotConstraint},\n+\t{\" //go:build x && y\", nil, errNotConstraint},\n+}\n+\n+func TestParse(t *testing.T) {\n+\tfor i, tt := range constraintTests {\n+\t\tt.Run(fmt.Sprint(i), func(t *testing.T) {\n+\t\t\tx, err := Parse(tt.in)\n+\t\t\tif err != nil {\n+\t\t\t\tif tt.err == nil {\n+\t\t\t\t\tt.Errorf(\"Constraint(%q): unexpected error: %v\", tt.in, err)\n+\t\t\t\t} else if tt.err != err {\n+\t\t\t\t\tt.Errorf(\"Constraint(%q): error %v, want %v\", tt.in, err, tt.err)\n+\t\t\t\t}\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif tt.err != nil {\n+\t\t\t\tt.Errorf(\"Constraint(%q) = %v, want error %v\", tt.in, x, tt.err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif x.String() != tt.x.String() {\n+\t\t\t\tt.Errorf(\"Constraint(%q):\\nhave %v\\nwant %v\", tt.in, x, tt.x)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+var plusBuildLinesTests = []struct {\n+\tin  string\n+\tout []string\n+\terr error\n+}{\n+\t{\"x\", []string{\"x\"}, nil},\n+\t{\"x && !y\", []string{\"x,!y\"}, nil},\n+\t{\"x || y\", []string{\"x y\"}, nil},\n+\t{\"x && (y || z)\", []string{\"x\", \"y z\"}, nil},\n+\t{\"!(x && y)\", []string{\"!x !y\"}, nil},\n+\t{\"x || (y && z)\", []string{\"x y,z\"}, nil},\n+\t{\"w && (x || (y && z))\", []string{\"w\", \"x y,z\"}, nil},\n+\t{\"v || (w && (x || (y && z)))\", nil, errComplex},\n+}\n+\n+func TestPlusBuildLines(t *testing.T) {\n+\tfor i, tt := range plusBuildLinesTests {\n+\t\tt.Run(fmt.Sprint(i), func(t *testing.T) {\n+\t\t\tx, err := parseExpr(tt.in)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tlines, err := PlusBuildLines(x)\n+\t\t\tif err != nil {\n+\t\t\t\tif tt.err == nil {\n+\t\t\t\t\tt.Errorf(\"PlusBuildLines(%q): unexpected error: %v\", tt.in, err)\n+\t\t\t\t} else if tt.err != err {\n+\t\t\t\t\tt.Errorf(\"PlusBuildLines(%q): error %v, want %v\", tt.in, err, tt.err)\n+\t\t\t\t}\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif tt.err != nil {\n+\t\t\t\tt.Errorf(\"PlusBuildLines(%q) = %v, want error %v\", tt.in, lines, tt.err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tvar want []string\n+\t\t\tfor _, line := range tt.out {\n+\t\t\t\twant = append(want, \"// +build \"+line)\n+\t\t\t}\n+\t\t\tif !reflect.DeepEqual(lines, want) {\n+\t\t\t\tt.Errorf(\"PlusBuildLines(%q):\\nhave %q\\nwant %q\", tt.in, lines, want)\n+\t\t\t}\n+\t\t})\n+\t}\n+}"}, {"sha": "f0bbe4e876544905cf9698822900b11168f91011", "filename": "libgo/go/go/build/deps_test.go", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -10,6 +10,7 @@ package build\n import (\n \t\"bytes\"\n \t\"fmt\"\n+\t\"go/token\"\n \t\"internal/testenv\"\n \t\"io/fs\"\n \t\"os\"\n@@ -162,6 +163,9 @@ var depsRules = `\n \t< os\n \t< os/signal;\n \n+\tio/fs\n+\t< embed;\n+\n \tunicode, fmt !< os, os/signal;\n \n \tos/signal, STR\n@@ -174,7 +178,7 @@ var depsRules = `\n \treflect !< OS;\n \n \tOS\n-\t< golang.org/x/sys/cpu, internal/goroot;\n+\t< golang.org/x/sys/cpu;\n \n \t# FMT is OS (which includes string routines) plus reflect and fmt.\n \t# It does not include package log, which should be avoided in core packages.\n@@ -190,6 +194,12 @@ var depsRules = `\n \n \tlog !< FMT;\n \n+\tOS, FMT\n+\t< internal/execabs;\n+\n+\tOS, internal/execabs\n+\t< internal/goroot;\n+\n \t# Misc packages needing only FMT.\n \tFMT\n \t< flag,\n@@ -278,6 +288,9 @@ var depsRules = `\n \tcontainer/heap, go/constant, go/parser\n \t< go/types;\n \n+\tFMT\n+\t< go/build/constraint;\n+\n \tgo/doc, go/parser, internal/goroot, internal/goversion\n \t< go/build;\n \n@@ -602,6 +615,7 @@ func findImports(pkg string) ([]string, error) {\n \t}\n \tvar imports []string\n \tvar haveImport = map[string]bool{}\n+\tfset := token.NewFileSet()\n \tfor _, file := range files {\n \t\tname := file.Name()\n \t\tif name == \"slice_go14.go\" || name == \"slice_go18.go\" {\n@@ -611,8 +625,10 @@ func findImports(pkg string) ([]string, error) {\n \t\tif !strings.HasSuffix(name, \".go\") || strings.HasSuffix(name, \"_test.go\") {\n \t\t\tcontinue\n \t\t}\n-\t\tvar info fileInfo\n-\t\tinfo.name = filepath.Join(dir, name)\n+\t\tinfo := fileInfo{\n+\t\t\tname: filepath.Join(dir, name),\n+\t\t\tfset: fset,\n+\t\t}\n \t\tf, err := os.Open(info.name)\n \t\tif err != nil {\n \t\t\treturn nil, err\n@@ -840,3 +856,28 @@ func TestStdlibLowercase(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+// TestFindImports tests that findImports works.  See #43249.\n+func TestFindImports(t *testing.T) {\n+\tif !testenv.HasSrc() {\n+\t\t// Tests run in a limited file system and we do not\n+\t\t// provide access to every source file.\n+\t\tt.Skipf(\"skipping on %s/%s, missing full GOROOT\", runtime.GOOS, runtime.GOARCH)\n+\t}\n+\n+\timports, err := findImports(\"go/build\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tt.Logf(\"go/build imports %q\", imports)\n+\twant := []string{\"bytes\", \"os\", \"path/filepath\", \"strings\"}\n+wantLoop:\n+\tfor _, w := range want {\n+\t\tfor _, imp := range imports {\n+\t\t\tif imp == w {\n+\t\t\t\tcontinue wantLoop\n+\t\t\t}\n+\t\t}\n+\t\tt.Errorf(\"expected to find %q in import list\", w)\n+\t}\n+}"}, {"sha": "aa7c6ee59eb6d3350e262b3bb6f928646d40d10c", "filename": "libgo/go/go/build/read.go", "status": "modified", "additions": 90, "deletions": 19, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgo%2Fbuild%2Fread.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgo%2Fbuild%2Fread.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fread.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -10,6 +10,7 @@ import (\n \t\"fmt\"\n \t\"go/ast\"\n \t\"go/parser\"\n+\t\"go/token\"\n \t\"io\"\n \t\"strconv\"\n \t\"strings\"\n@@ -24,6 +25,18 @@ type importReader struct {\n \terr  error\n \teof  bool\n \tnerr int\n+\tpos  token.Position\n+}\n+\n+func newImportReader(name string, r io.Reader) *importReader {\n+\treturn &importReader{\n+\t\tb: bufio.NewReader(r),\n+\t\tpos: token.Position{\n+\t\t\tFilename: name,\n+\t\t\tLine:     1,\n+\t\t\tColumn:   1,\n+\t\t},\n+\t}\n }\n \n func isIdent(c byte) bool {\n@@ -66,22 +79,32 @@ func (r *importReader) readByte() byte {\n // readByteNoBuf is like readByte but doesn't buffer the byte.\n // It exhausts r.buf before reading from r.b.\n func (r *importReader) readByteNoBuf() byte {\n+\tvar c byte\n+\tvar err error\n \tif len(r.buf) > 0 {\n-\t\tc := r.buf[0]\n+\t\tc = r.buf[0]\n \t\tr.buf = r.buf[1:]\n-\t\treturn c\n-\t}\n-\tc, err := r.b.ReadByte()\n-\tif err == nil && c == 0 {\n-\t\terr = errNUL\n+\t} else {\n+\t\tc, err = r.b.ReadByte()\n+\t\tif err == nil && c == 0 {\n+\t\t\terr = errNUL\n+\t\t}\n \t}\n+\n \tif err != nil {\n \t\tif err == io.EOF {\n \t\t\tr.eof = true\n \t\t} else if r.err == nil {\n \t\t\tr.err = err\n \t\t}\n-\t\tc = 0\n+\t\treturn 0\n+\t}\n+\tr.pos.Offset++\n+\tif c == '\\n' {\n+\t\tr.pos.Line++\n+\t\tr.pos.Column = 1\n+\t} else {\n+\t\tr.pos.Column++\n \t}\n \treturn c\n }\n@@ -171,6 +194,41 @@ func (r *importReader) findEmbed(first bool) bool {\n \t\tcase ' ', '\\t':\n \t\t\t// leave startLine alone\n \n+\t\tcase '\"':\n+\t\t\tstartLine = false\n+\t\t\tfor r.err == nil {\n+\t\t\t\tif r.eof {\n+\t\t\t\t\tr.syntaxError()\n+\t\t\t\t}\n+\t\t\t\tc = r.readByteNoBuf()\n+\t\t\t\tif c == '\\\\' {\n+\t\t\t\t\tr.readByteNoBuf()\n+\t\t\t\t\tif r.err != nil {\n+\t\t\t\t\t\tr.syntaxError()\n+\t\t\t\t\t\treturn false\n+\t\t\t\t\t}\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tif c == '\"' {\n+\t\t\t\t\tc = r.readByteNoBuf()\n+\t\t\t\t\tgoto Reswitch\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tgoto Reswitch\n+\n+\t\tcase '`':\n+\t\t\tstartLine = false\n+\t\t\tfor r.err == nil {\n+\t\t\t\tif r.eof {\n+\t\t\t\t\tr.syntaxError()\n+\t\t\t\t}\n+\t\t\t\tc = r.readByteNoBuf()\n+\t\t\t\tif c == '`' {\n+\t\t\t\t\tc = r.readByteNoBuf()\n+\t\t\t\t\tgoto Reswitch\n+\t\t\t\t}\n+\t\t\t}\n+\n \t\tcase '/':\n \t\t\tc = r.readByteNoBuf()\n \t\t\tswitch c {\n@@ -288,7 +346,7 @@ func (r *importReader) readImport() {\n // readComments is like io.ReadAll, except that it only reads the leading\n // block of comments in the file.\n func readComments(f io.Reader) ([]byte, error) {\n-\tr := &importReader{b: bufio.NewReader(f)}\n+\tr := newImportReader(\"\", f)\n \tr.peekByte(true)\n \tif r.err == nil && !r.eof {\n \t\t// Didn't reach EOF, so must have found a non-space byte. Remove it.\n@@ -305,7 +363,7 @@ func readComments(f io.Reader) ([]byte, error) {\n // It only returns an error if there are problems reading the file,\n // not for syntax errors in the file itself.\n func readGoInfo(f io.Reader, info *fileInfo) error {\n-\tr := &importReader{b: bufio.NewReader(f)}\n+\tr := newImportReader(info.name, f)\n \n \tr.readKeyword(\"package\")\n \tr.readIdent()\n@@ -393,6 +451,7 @@ func readGoInfo(f io.Reader, info *fileInfo) error {\n \t\tvar line []byte\n \t\tfor first := true; r.findEmbed(first); first = false {\n \t\t\tline = line[:0]\n+\t\t\tpos := r.pos\n \t\t\tfor {\n \t\t\t\tc := r.readByteNoBuf()\n \t\t\t\tif c == '\\n' || r.err != nil || r.eof {\n@@ -403,9 +462,9 @@ func readGoInfo(f io.Reader, info *fileInfo) error {\n \t\t\t// Add args if line is well-formed.\n \t\t\t// Ignore badly-formed lines - the compiler will report them when it finds them,\n \t\t\t// and we can pretend they are not there to help go list succeed with what it knows.\n-\t\t\targs, err := parseGoEmbed(string(line))\n+\t\t\tembs, err := parseGoEmbed(string(line), pos)\n \t\t\tif err == nil {\n-\t\t\t\tinfo.embeds = append(info.embeds, args...)\n+\t\t\t\tinfo.embeds = append(info.embeds, embs...)\n \t\t\t}\n \t\t}\n \t}\n@@ -415,11 +474,23 @@ func readGoInfo(f io.Reader, info *fileInfo) error {\n \n // parseGoEmbed parses the text following \"//go:embed\" to extract the glob patterns.\n // It accepts unquoted space-separated patterns as well as double-quoted and back-quoted Go strings.\n-// There is a copy of this code in cmd/compile/internal/gc/noder.go as well.\n-func parseGoEmbed(args string) ([]string, error) {\n-\tvar list []string\n-\tfor args = strings.TrimSpace(args); args != \"\"; args = strings.TrimSpace(args) {\n+// This is based on a similar function in cmd/compile/internal/gc/noder.go;\n+// this version calculates position information as well.\n+func parseGoEmbed(args string, pos token.Position) ([]fileEmbed, error) {\n+\ttrimBytes := func(n int) {\n+\t\tpos.Offset += n\n+\t\tpos.Column += utf8.RuneCountInString(args[:n])\n+\t\targs = args[n:]\n+\t}\n+\ttrimSpace := func() {\n+\t\ttrim := strings.TrimLeftFunc(args, unicode.IsSpace)\n+\t\ttrimBytes(len(args) - len(trim))\n+\t}\n+\n+\tvar list []fileEmbed\n+\tfor trimSpace(); args != \"\"; trimSpace() {\n \t\tvar path string\n+\t\tpathPos := pos\n \tSwitch:\n \t\tswitch args[0] {\n \t\tdefault:\n@@ -431,15 +502,15 @@ func parseGoEmbed(args string) ([]string, error) {\n \t\t\t\t}\n \t\t\t}\n \t\t\tpath = args[:i]\n-\t\t\targs = args[i:]\n+\t\t\ttrimBytes(i)\n \n \t\tcase '`':\n \t\t\ti := strings.Index(args[1:], \"`\")\n \t\t\tif i < 0 {\n \t\t\t\treturn nil, fmt.Errorf(\"invalid quoted string in //go:embed: %s\", args)\n \t\t\t}\n \t\t\tpath = args[1 : 1+i]\n-\t\t\targs = args[1+i+1:]\n+\t\t\ttrimBytes(1 + i + 1)\n \n \t\tcase '\"':\n \t\t\ti := 1\n@@ -454,7 +525,7 @@ func parseGoEmbed(args string) ([]string, error) {\n \t\t\t\t\t\treturn nil, fmt.Errorf(\"invalid quoted string in //go:embed: %s\", args[:i+1])\n \t\t\t\t\t}\n \t\t\t\t\tpath = q\n-\t\t\t\t\targs = args[i+1:]\n+\t\t\t\t\ttrimBytes(i + 1)\n \t\t\t\t\tbreak Switch\n \t\t\t\t}\n \t\t\t}\n@@ -469,7 +540,7 @@ func parseGoEmbed(args string) ([]string, error) {\n \t\t\t\treturn nil, fmt.Errorf(\"invalid quoted string in //go:embed: %s\", args)\n \t\t\t}\n \t\t}\n-\t\tlist = append(list, path)\n+\t\tlist = append(list, fileEmbed{path, pathPos})\n \t}\n \treturn list, nil\n }"}, {"sha": "32e6bae008841bb4db5b7fb456729f3e6267828e", "filename": "libgo/go/go/build/read_test.go", "status": "modified", "additions": 54, "deletions": 15, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgo%2Fbuild%2Fread_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgo%2Fbuild%2Fread_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fread_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -5,9 +5,9 @@\n package build\n \n import (\n+\t\"fmt\"\n \t\"go/token\"\n \t\"io\"\n-\t\"reflect\"\n \t\"strings\"\n \t\"testing\"\n )\n@@ -228,55 +228,94 @@ func TestReadFailuresIgnored(t *testing.T) {\n }\n \n var readEmbedTests = []struct {\n-\tin  string\n-\tout []string\n+\tin, out string\n }{\n \t{\n \t\t\"package p\\n\",\n-\t\tnil,\n+\t\t\"\",\n \t},\n \t{\n \t\t\"package p\\nimport \\\"embed\\\"\\nvar i int\\n//go:embed x y z\\nvar files embed.FS\",\n-\t\t[]string{\"x\", \"y\", \"z\"},\n+\t\t`test:4:12:x\n+\t\t test:4:14:y\n+\t\t test:4:16:z`,\n \t},\n \t{\n \t\t\"package p\\nimport \\\"embed\\\"\\nvar i int\\n//go:embed x \\\"\\\\x79\\\" `z`\\nvar files embed.FS\",\n-\t\t[]string{\"x\", \"y\", \"z\"},\n+\t\t`test:4:12:x\n+\t\t test:4:14:y\n+\t\t test:4:21:z`,\n \t},\n \t{\n \t\t\"package p\\nimport \\\"embed\\\"\\nvar i int\\n//go:embed x y\\n//go:embed z\\nvar files embed.FS\",\n-\t\t[]string{\"x\", \"y\", \"z\"},\n+\t\t`test:4:12:x\n+\t\t test:4:14:y\n+\t\t test:5:12:z`,\n \t},\n \t{\n \t\t\"package p\\nimport \\\"embed\\\"\\nvar i int\\n\\t //go:embed x y\\n\\t //go:embed z\\n\\t var files embed.FS\",\n-\t\t[]string{\"x\", \"y\", \"z\"},\n+\t\t`test:4:14:x\n+\t\t test:4:16:y\n+\t\t test:5:14:z`,\n \t},\n \t{\n \t\t\"package p\\nimport \\\"embed\\\"\\n//go:embed x y z\\nvar files embed.FS\",\n-\t\t[]string{\"x\", \"y\", \"z\"},\n+\t\t`test:3:12:x\n+\t\t test:3:14:y\n+\t\t test:3:16:z`,\n+\t},\n+\t{\n+\t\t\"package p\\nimport \\\"embed\\\"\\nvar s = \\\"/*\\\"\\n//go:embed x\\nvar files embed.FS\",\n+\t\t`test:4:12:x`,\n+\t},\n+\t{\n+\t\t`package p\n+\t\t import \"embed\"\n+\t\t var s = \"\\\"\\\\\\\\\"\n+\t\t //go:embed x\n+\t\t var files embed.FS`,\n+\t\t`test:4:15:x`,\n+\t},\n+\t{\n+\t\t\"package p\\nimport \\\"embed\\\"\\nvar s = `/*`\\n//go:embed x\\nvar files embed.FS\",\n+\t\t`test:4:12:x`,\n+\t},\n+\t{\n+\t\t\"package p\\nimport \\\"embed\\\"\\nvar s = z/ *y\\n//go:embed pointer\\nvar pointer embed.FS\",\n+\t\t\"test:4:12:pointer\",\n \t},\n \t{\n \t\t\"package p\\n//go:embed x y z\\n\", // no import, no scan\n-\t\tnil,\n+\t\t\"\",\n \t},\n \t{\n \t\t\"package p\\n//go:embed x y z\\nvar files embed.FS\", // no import, no scan\n-\t\tnil,\n+\t\t\"\",\n \t},\n }\n \n func TestReadEmbed(t *testing.T) {\n \tfset := token.NewFileSet()\n \tfor i, tt := range readEmbedTests {\n-\t\tvar info fileInfo\n-\t\tinfo.fset = fset\n+\t\tinfo := fileInfo{\n+\t\t\tname: \"test\",\n+\t\t\tfset: fset,\n+\t\t}\n \t\terr := readGoInfo(strings.NewReader(tt.in), &info)\n \t\tif err != nil {\n \t\t\tt.Errorf(\"#%d: %v\", i, err)\n \t\t\tcontinue\n \t\t}\n-\t\tif !reflect.DeepEqual(info.embeds, tt.out) {\n-\t\t\tt.Errorf(\"#%d: embeds=%v, want %v\", i, info.embeds, tt.out)\n+\t\tb := &strings.Builder{}\n+\t\tsep := \"\"\n+\t\tfor _, emb := range info.embeds {\n+\t\t\tfmt.Fprintf(b, \"%s%v:%s\", sep, emb.pos, emb.pattern)\n+\t\t\tsep = \"\\n\"\n+\t\t}\n+\t\tgot := b.String()\n+\t\twant := strings.Join(strings.Fields(tt.out), \"\\n\")\n+\t\tif got != want {\n+\t\t\tt.Errorf(\"#%d: embeds:\\n%s\\nwant:\\n%s\", i, got, want)\n \t\t}\n \t}\n }"}, {"sha": "142fb423f66d15815b3e37fdc570ef5a70f9b5a1", "filename": "libgo/go/go/build/testdata/withvendor/src/a/vendor/c/d/d.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgo%2Fbuild%2Ftestdata%2Fwithvendor%2Fsrc%2Fa%2Fvendor%2Fc%2Fd%2Fd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgo%2Fbuild%2Ftestdata%2Fwithvendor%2Fsrc%2Fa%2Fvendor%2Fc%2Fd%2Fd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Ftestdata%2Fwithvendor%2Fsrc%2Fa%2Fvendor%2Fc%2Fd%2Fd.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "previous_filename": "libgo/go/go/build/testdata/withvendor/src/a/c/d/d.go"}, {"sha": "e90a3cc0b0a343e601bc2fe6389e43a160c713b9", "filename": "libgo/go/go/internal/gccgoimporter/gccgoinstallation.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fgccgoinstallation.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fgccgoinstallation.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fgccgoinstallation.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -7,8 +7,8 @@ package gccgoimporter\n import (\n \t\"bufio\"\n \t\"go/types\"\n+\texec \"internal/execabs\"\n \t\"os\"\n-\t\"os/exec\"\n \t\"path/filepath\"\n \t\"strings\"\n )"}, {"sha": "863b672bd5955f60fa12e6897f034da3c5481c0c", "filename": "libgo/go/go/internal/srcimporter/srcimporter.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgo%2Finternal%2Fsrcimporter%2Fsrcimporter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgo%2Finternal%2Fsrcimporter%2Fsrcimporter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fsrcimporter%2Fsrcimporter.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -13,9 +13,9 @@ import (\n \t\"go/parser\"\n \t\"go/token\"\n \t\"go/types\"\n+\texec \"internal/execabs\"\n \t\"io\"\n \t\"os\"\n-\t\"os/exec\"\n \t\"path/filepath\"\n \t\"strings\"\n \t\"sync\""}, {"sha": "208311e557f373e1af3cb91d231a2c1d9dd365cc", "filename": "libgo/go/go/types/stdlib_test.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgo%2Ftypes%2Fstdlib_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgo%2Ftypes%2Fstdlib_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fstdlib_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -157,6 +157,8 @@ func TestStdTest(t *testing.T) {\n \ttestTestDir(t, filepath.Join(runtime.GOROOT(), \"test\"),\n \t\t\"cmplxdivide.go\", // also needs file cmplxdivide1.go - ignore\n \t\t\"directive.go\",   // tests compiler rejection of bad directive placement - ignore\n+\t\t\"embedfunc.go\",   // tests //go:embed\n+\t\t\"embedvers.go\",   // tests //go:embed\n \t)\n }\n "}, {"sha": "c6a189dbe049d843811236ec7b7265038c0afc8d", "filename": "libgo/go/golang.org/x/mod/modfile/rule.go", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgolang.org%2Fx%2Fmod%2Fmodfile%2Frule.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgolang.org%2Fx%2Fmod%2Fmodfile%2Frule.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgolang.org%2Fx%2Fmod%2Fmodfile%2Frule.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -832,7 +832,16 @@ func (f *File) DropRequire(path string) error {\n \treturn nil\n }\n \n+// AddExclude adds a exclude statement to the mod file. Errors if the provided\n+// version is not a canonical version string\n func (f *File) AddExclude(path, vers string) error {\n+\tif !isCanonicalVersion(vers) {\n+\t\treturn &module.InvalidVersionError{\n+\t\t\tVersion: vers,\n+\t\t\tErr:     errors.New(\"must be of the form v1.2.3\"),\n+\t\t}\n+\t}\n+\n \tvar hint *Line\n \tfor _, x := range f.Exclude {\n \t\tif x.Mod.Path == path && x.Mod.Version == vers {\n@@ -904,7 +913,22 @@ func (f *File) DropReplace(oldPath, oldVers string) error {\n \treturn nil\n }\n \n+// AddRetract adds a retract statement to the mod file. Errors if the provided\n+// version interval does not consist of canonical version strings\n func (f *File) AddRetract(vi VersionInterval, rationale string) error {\n+\tif !isCanonicalVersion(vi.High) {\n+\t\treturn &module.InvalidVersionError{\n+\t\t\tVersion: vi.High,\n+\t\t\tErr:     errors.New(\"must be of the form v1.2.3\"),\n+\t\t}\n+\t}\n+\tif !isCanonicalVersion(vi.Low) {\n+\t\treturn &module.InvalidVersionError{\n+\t\t\tVersion: vi.Low,\n+\t\t\tErr:     errors.New(\"must be of the form v1.2.3\"),\n+\t\t}\n+\t}\n+\n \tr := &Retract{\n \t\tVersionInterval: vi,\n \t}\n@@ -1061,3 +1085,9 @@ func lineRetractLess(li, lj *Line) bool {\n \t}\n \treturn semver.Compare(vii.High, vij.High) > 0\n }\n+\n+// isCanonicalVersion tests if the provided version string represents a valid\n+// canonical version.\n+func isCanonicalVersion(vers string) bool {\n+\treturn vers != \"\" && semver.Canonical(vers) == vers\n+}"}, {"sha": "d11505a165c86ee7b56f902cbcc74a5cb8f3f5a3", "filename": "libgo/go/golang.org/x/tools/go/analysis/analysis.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Fanalysis.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Fanalysis.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Fanalysis.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -1,3 +1,7 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n package analysis\n \n import ("}, {"sha": "cd462a0cb554458b8b63d2fd2118c58a8b116777", "filename": "libgo/go/golang.org/x/tools/go/analysis/diagnostic.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Fdiagnostic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Fdiagnostic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Fdiagnostic.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -1,3 +1,7 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n package analysis\n \n import \"go/token\""}, {"sha": "94a3bd5d07cac01576bf5444ded4af58212ec95f", "filename": "libgo/go/golang.org/x/tools/go/analysis/doc.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Fdoc.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -1,3 +1,7 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n /*\n \n Package analysis defines the interface between a modular static"}, {"sha": "ce92892c817690f5139f5b00f02355500e66b497", "filename": "libgo/go/golang.org/x/tools/go/analysis/internal/analysisflags/help.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Finternal%2Fanalysisflags%2Fhelp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Finternal%2Fanalysisflags%2Fhelp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Finternal%2Fanalysisflags%2Fhelp.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -1,3 +1,7 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n package analysisflags\n \n import ("}, {"sha": "ac37e4784e146be5c75c29694ce2b7daab54e0f5", "filename": "libgo/go/golang.org/x/tools/go/analysis/passes/internal/analysisutil/util.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Fpasses%2Finternal%2Fanalysisutil%2Futil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Fpasses%2Finternal%2Fanalysisutil%2Futil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Fpasses%2Finternal%2Fanalysisutil%2Futil.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -1,3 +1,7 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n // Package analysisutil defines various helper functions\n // used by two or more packages beneath go/analysis.\n package analysisutil"}, {"sha": "6a5fae44f469f30c81939ca951e8d8980ea6d775", "filename": "libgo/go/golang.org/x/tools/go/analysis/passes/printf/types.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Fpasses%2Fprintf%2Ftypes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Fpasses%2Fprintf%2Ftypes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Fpasses%2Fprintf%2Ftypes.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -1,3 +1,7 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n package printf\n \n import ("}, {"sha": "f0b15051c52eacc1cc5fd6912bfa03dcb3ea7558", "filename": "libgo/go/golang.org/x/tools/go/analysis/passes/structtag/structtag.go", "status": "modified", "additions": 38, "deletions": 56, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Fpasses%2Fstructtag%2Fstructtag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Fpasses%2Fstructtag%2Fstructtag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Fpasses%2Fstructtag%2Fstructtag.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -207,12 +207,12 @@ var (\n )\n \n // validateStructTag parses the struct tag and returns an error if it is not\n-// in the canonical format, as defined by reflect.StructTag.\n+// in the canonical format, which is a space-separated list of key:\"value\"\n+// settings. The value may contain spaces.\n func validateStructTag(tag string) error {\n \t// This code is based on the StructTag.Get code in package reflect.\n \n \tn := 0\n-\tvar keys []string\n \tfor ; tag != \"\"; n++ {\n \t\tif n > 0 && tag != \"\" && tag[0] != ' ' {\n \t\t\t// More restrictive than reflect, but catches likely mistakes\n@@ -240,27 +240,14 @@ func validateStructTag(tag string) error {\n \t\tif i == 0 {\n \t\t\treturn errTagKeySyntax\n \t\t}\n-\t\tif i+1 >= len(tag) || tag[i] < ' ' || tag[i] == 0x7f {\n+\t\tif i+1 >= len(tag) || tag[i] != ':' {\n \t\t\treturn errTagSyntax\n \t\t}\n-\t\tkey := tag[:i]\n-\t\tkeys = append(keys, key)\n-\t\ttag = tag[i:]\n-\n-\t\t// If we found a space char here - assume that we have a tag with\n-\t\t// multiple keys.\n-\t\tif tag[0] == ' ' {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\t// Spaces were filtered above so we assume that here we have\n-\t\t// only valid tag value started with `:\"`.\n-\t\tif tag[0] != ':' || tag[1] != '\"' {\n+\t\tif tag[i+1] != '\"' {\n \t\t\treturn errTagValueSyntax\n \t\t}\n-\n-\t\t// Remove the colon leaving tag at the start of the quoted string.\n-\t\ttag = tag[1:]\n+\t\tkey := tag[:i]\n+\t\ttag = tag[i+1:]\n \n \t\t// Scan quoted string to find value.\n \t\ti = 1\n@@ -276,56 +263,51 @@ func validateStructTag(tag string) error {\n \t\tqvalue := tag[:i+1]\n \t\ttag = tag[i+1:]\n \n-\t\twholeValue, err := strconv.Unquote(qvalue)\n+\t\tvalue, err := strconv.Unquote(qvalue)\n \t\tif err != nil {\n \t\t\treturn errTagValueSyntax\n \t\t}\n \n-\t\tfor _, key := range keys {\n-\t\t\tif !checkTagSpaces[key] {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\n-\t\t\tvalue := wholeValue\n-\t\t\tswitch key {\n-\t\t\tcase \"xml\":\n-\t\t\t\t// If the first or last character in the XML tag is a space, it is\n-\t\t\t\t// suspicious.\n-\t\t\t\tif strings.Trim(value, \" \") != value {\n-\t\t\t\t\treturn errTagValueSpace\n-\t\t\t\t}\n+\t\tif !checkTagSpaces[key] {\n+\t\t\tcontinue\n+\t\t}\n \n-\t\t\t\t// If there are multiple spaces, they are suspicious.\n-\t\t\t\tif strings.Count(value, \" \") > 1 {\n-\t\t\t\t\treturn errTagValueSpace\n-\t\t\t\t}\n+\t\tswitch key {\n+\t\tcase \"xml\":\n+\t\t\t// If the first or last character in the XML tag is a space, it is\n+\t\t\t// suspicious.\n+\t\t\tif strings.Trim(value, \" \") != value {\n+\t\t\t\treturn errTagValueSpace\n+\t\t\t}\n \n-\t\t\t\t// If there is no comma, skip the rest of the checks.\n-\t\t\t\tcomma := strings.IndexRune(value, ',')\n-\t\t\t\tif comma < 0 {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n+\t\t\t// If there are multiple spaces, they are suspicious.\n+\t\t\tif strings.Count(value, \" \") > 1 {\n+\t\t\t\treturn errTagValueSpace\n+\t\t\t}\n \n-\t\t\t\t// If the character before a comma is a space, this is suspicious.\n-\t\t\t\tif comma > 0 && value[comma-1] == ' ' {\n-\t\t\t\t\treturn errTagValueSpace\n-\t\t\t\t}\n-\t\t\t\tvalue = value[comma+1:]\n-\t\t\tcase \"json\":\n-\t\t\t\t// JSON allows using spaces in the name, so skip it.\n-\t\t\t\tcomma := strings.IndexRune(value, ',')\n-\t\t\t\tif comma < 0 {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t\tvalue = value[comma+1:]\n+\t\t\t// If there is no comma, skip the rest of the checks.\n+\t\t\tcomma := strings.IndexRune(value, ',')\n+\t\t\tif comma < 0 {\n+\t\t\t\tcontinue\n \t\t\t}\n \n-\t\t\tif strings.IndexByte(value, ' ') >= 0 {\n+\t\t\t// If the character before a comma is a space, this is suspicious.\n+\t\t\tif comma > 0 && value[comma-1] == ' ' {\n \t\t\t\treturn errTagValueSpace\n \t\t\t}\n+\t\t\tvalue = value[comma+1:]\n+\t\tcase \"json\":\n+\t\t\t// JSON allows using spaces in the name, so skip it.\n+\t\t\tcomma := strings.IndexRune(value, ',')\n+\t\t\tif comma < 0 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tvalue = value[comma+1:]\n \t\t}\n \n-\t\tkeys = keys[:0]\n+\t\tif strings.IndexByte(value, ' ') >= 0 {\n+\t\t\treturn errTagValueSpace\n+\t\t}\n \t}\n \treturn nil\n }"}, {"sha": "9051456e396ffcfb865b04c8f68bef4568ee509c", "filename": "libgo/go/golang.org/x/tools/go/analysis/unitchecker/unitchecker112.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Funitchecker%2Funitchecker112.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Funitchecker%2Funitchecker112.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Funitchecker%2Funitchecker112.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -1,3 +1,7 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n // +build go1.12\n \n package unitchecker"}, {"sha": "23e57bf02b66ad3f07b131d05637489c3e15f7e7", "filename": "libgo/go/golang.org/x/tools/go/analysis/validate.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Fvalidate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Fvalidate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Fvalidate.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -1,3 +1,7 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n package analysis\n \n import ("}, {"sha": "919d5305ab422eb19f91d06d6d04fbad62f40650", "filename": "libgo/go/golang.org/x/tools/go/ast/astutil/util.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fast%2Fastutil%2Futil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fast%2Fastutil%2Futil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fast%2Fastutil%2Futil.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -1,3 +1,7 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n package astutil\n \n import \"go/ast\""}, {"sha": "b6b00cf2e1e377ee30c870d0532e73c9d3716a89", "filename": "libgo/go/golang.org/x/tools/go/ast/inspector/typeof.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fast%2Finspector%2Ftypeof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fast%2Finspector%2Ftypeof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fast%2Finspector%2Ftypeof.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -1,3 +1,7 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n package inspector\n \n // This file defines func typeOf(ast.Node) uint64."}, {"sha": "7d1bef1782a9cc0be2a97179acb080a5ab7afad3", "filename": "libgo/go/html/template/exec_test.go", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fhtml%2Ftemplate%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fhtml%2Ftemplate%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fexec_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -1720,6 +1720,8 @@ var v = \"v\";\n `\n \n func TestEscapeRace(t *testing.T) {\n+\tt.Skip(\"this test currently fails with -race; see issue #39807\")\n+\n \ttmpl := New(\"\")\n \t_, err := tmpl.New(\"templ.html\").Parse(raceText)\n \tif err != nil {\n@@ -1776,3 +1778,56 @@ func TestRecursiveExecute(t *testing.T) {\n \t\tt.Fatal(err)\n \t}\n }\n+\n+// recursiveInvoker is for TestRecursiveExecuteViaMethod.\n+type recursiveInvoker struct {\n+\tt    *testing.T\n+\ttmpl *Template\n+}\n+\n+func (r *recursiveInvoker) Recur() (string, error) {\n+\tvar sb strings.Builder\n+\tif err := r.tmpl.ExecuteTemplate(&sb, \"subroutine\", nil); err != nil {\n+\t\tr.t.Fatal(err)\n+\t}\n+\treturn sb.String(), nil\n+}\n+\n+func TestRecursiveExecuteViaMethod(t *testing.T) {\n+\ttmpl := New(\"\")\n+\ttop, err := tmpl.New(\"x.html\").Parse(`{{.Recur}}`)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\t_, err = tmpl.New(\"subroutine\").Parse(`<a href=\"/x?p={{\"'a<b'\"}}\">`)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tr := &recursiveInvoker{\n+\t\tt:    t,\n+\t\ttmpl: tmpl,\n+\t}\n+\tif err := top.Execute(io.Discard, r); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+}\n+\n+// Issue 43295.\n+func TestTemplateFuncsAfterClone(t *testing.T) {\n+\ts := `{{ f . }}`\n+\twant := \"test\"\n+\torig := New(\"orig\").Funcs(map[string]interface{}{\n+\t\t\"f\": func(in string) string {\n+\t\t\treturn in\n+\t\t},\n+\t}).New(\"child\")\n+\n+\toverviewTmpl := Must(Must(orig.Clone()).Parse(s))\n+\tvar out strings.Builder\n+\tif err := overviewTmpl.Execute(&out, want); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif got := out.String(); got != want {\n+\t\tt.Fatalf(\"got %q; want %q\", got, want)\n+\t}\n+}"}, {"sha": "69312d36fdb361ec73b66a712840f902e778a962", "filename": "libgo/go/html/template/template.go", "status": "modified", "additions": 13, "deletions": 77, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftemplate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftemplate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Ftemplate.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -11,7 +11,6 @@ import (\n \t\"os\"\n \t\"path\"\n \t\"path/filepath\"\n-\t\"reflect\"\n \t\"sync\"\n \t\"text/template\"\n \t\"text/template/parse\"\n@@ -27,9 +26,7 @@ type Template struct {\n \t// template's in sync.\n \ttext *template.Template\n \t// The underlying template's parse tree, updated to be HTML-safe.\n-\tTree *parse.Tree\n-\t// The original functions, before wrapping.\n-\tfuncMap    FuncMap\n+\tTree       *parse.Tree\n \t*nameSpace // common to all associated templates\n }\n \n@@ -38,7 +35,7 @@ var escapeOK = fmt.Errorf(\"template escaped correctly\")\n \n // nameSpace is the data structure shared by all templates in an association.\n type nameSpace struct {\n-\tmu      sync.RWMutex\n+\tmu      sync.Mutex\n \tset     map[string]*Template\n \tescaped bool\n \tesc     escaper\n@@ -48,8 +45,8 @@ type nameSpace struct {\n // itself.\n func (t *Template) Templates() []*Template {\n \tns := t.nameSpace\n-\tns.mu.RLock()\n-\tdefer ns.mu.RUnlock()\n+\tns.mu.Lock()\n+\tdefer ns.mu.Unlock()\n \t// Return a slice so we don't expose the map.\n \tm := make([]*Template, 0, len(ns.set))\n \tfor _, v := range ns.set {\n@@ -87,8 +84,8 @@ func (t *Template) checkCanParse() error {\n \tif t == nil {\n \t\treturn nil\n \t}\n-\tt.nameSpace.mu.RLock()\n-\tdefer t.nameSpace.mu.RUnlock()\n+\tt.nameSpace.mu.Lock()\n+\tdefer t.nameSpace.mu.Unlock()\n \tif t.nameSpace.escaped {\n \t\treturn fmt.Errorf(\"html/template: cannot Parse after Execute\")\n \t}\n@@ -97,16 +94,6 @@ func (t *Template) checkCanParse() error {\n \n // escape escapes all associated templates.\n func (t *Template) escape() error {\n-\tt.nameSpace.mu.RLock()\n-\tescapeErr := t.escapeErr\n-\tt.nameSpace.mu.RUnlock()\n-\tif escapeErr != nil {\n-\t\tif escapeErr == escapeOK {\n-\t\t\treturn nil\n-\t\t}\n-\t\treturn escapeErr\n-\t}\n-\n \tt.nameSpace.mu.Lock()\n \tdefer t.nameSpace.mu.Unlock()\n \tt.nameSpace.escaped = true\n@@ -134,8 +121,6 @@ func (t *Template) Execute(wr io.Writer, data interface{}) error {\n \tif err := t.escape(); err != nil {\n \t\treturn err\n \t}\n-\tt.nameSpace.mu.RLock()\n-\tdefer t.nameSpace.mu.RUnlock()\n \treturn t.text.Execute(wr, data)\n }\n \n@@ -151,36 +136,20 @@ func (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{})\n \tif err != nil {\n \t\treturn err\n \t}\n-\tt.nameSpace.mu.RLock()\n-\tdefer t.nameSpace.mu.RUnlock()\n \treturn tmpl.text.Execute(wr, data)\n }\n \n // lookupAndEscapeTemplate guarantees that the template with the given name\n // is escaped, or returns an error if it cannot be. It returns the named\n // template.\n func (t *Template) lookupAndEscapeTemplate(name string) (tmpl *Template, err error) {\n-\tt.nameSpace.mu.RLock()\n+\tt.nameSpace.mu.Lock()\n+\tdefer t.nameSpace.mu.Unlock()\n+\tt.nameSpace.escaped = true\n \ttmpl = t.set[name]\n-\tvar escapeErr error\n-\tif tmpl != nil {\n-\t\tescapeErr = tmpl.escapeErr\n-\t}\n-\tt.nameSpace.mu.RUnlock()\n-\n \tif tmpl == nil {\n \t\treturn nil, fmt.Errorf(\"html/template: %q is undefined\", name)\n \t}\n-\tif escapeErr != nil {\n-\t\tif escapeErr != escapeOK {\n-\t\t\treturn nil, escapeErr\n-\t\t}\n-\t\treturn tmpl, nil\n-\t}\n-\n-\tt.nameSpace.mu.Lock()\n-\tdefer t.nameSpace.mu.Unlock()\n-\tt.nameSpace.escaped = true\n \tif tmpl.escapeErr != nil && tmpl.escapeErr != escapeOK {\n \t\treturn nil, tmpl.escapeErr\n \t}\n@@ -260,7 +229,6 @@ func (t *Template) AddParseTree(name string, tree *parse.Tree) (*Template, error\n \t\tnil,\n \t\ttext,\n \t\ttext.Tree,\n-\t\tnil,\n \t\tt.nameSpace,\n \t}\n \tt.set[name] = ret\n@@ -291,10 +259,8 @@ func (t *Template) Clone() (*Template, error) {\n \t\tnil,\n \t\ttextClone,\n \t\ttextClone.Tree,\n-\t\tt.funcMap,\n \t\tns,\n \t}\n-\tret.wrapFuncs()\n \tret.set[ret.Name()] = ret\n \tfor _, x := range textClone.Templates() {\n \t\tname := x.Name()\n@@ -303,15 +269,12 @@ func (t *Template) Clone() (*Template, error) {\n \t\t\treturn nil, fmt.Errorf(\"html/template: cannot Clone %q after it has executed\", t.Name())\n \t\t}\n \t\tx.Tree = x.Tree.Copy()\n-\t\ttc := &Template{\n+\t\tret.set[name] = &Template{\n \t\t\tnil,\n \t\t\tx,\n \t\t\tx.Tree,\n-\t\t\tsrc.funcMap,\n \t\t\tret.nameSpace,\n \t\t}\n-\t\ttc.wrapFuncs()\n-\t\tret.set[name] = tc\n \t}\n \t// Return the template associated with the name of this template.\n \treturn ret.set[ret.Name()], nil\n@@ -325,7 +288,6 @@ func New(name string) *Template {\n \t\tnil,\n \t\ttemplate.New(name),\n \t\tnil,\n-\t\tnil,\n \t\tns,\n \t}\n \ttmpl.set[name] = tmpl\n@@ -351,7 +313,6 @@ func (t *Template) new(name string) *Template {\n \t\tnil,\n \t\tt.text.New(name),\n \t\tnil,\n-\t\tnil,\n \t\tt.nameSpace,\n \t}\n \tif existing, ok := tmpl.set[name]; ok {\n@@ -382,35 +343,10 @@ type FuncMap map[string]interface{}\n // type. However, it is legal to overwrite elements of the map. The return\n // value is the template, so calls can be chained.\n func (t *Template) Funcs(funcMap FuncMap) *Template {\n-\tt.funcMap = funcMap\n-\tt.wrapFuncs()\n+\tt.text.Funcs(template.FuncMap(funcMap))\n \treturn t\n }\n \n-// wrapFuncs records the functions with text/template. We wrap them to\n-// unlock the nameSpace. See TestRecursiveExecute for a test case.\n-func (t *Template) wrapFuncs() {\n-\tif len(t.funcMap) == 0 {\n-\t\treturn\n-\t}\n-\ttfuncs := make(template.FuncMap, len(t.funcMap))\n-\tfor name, fn := range t.funcMap {\n-\t\tfnv := reflect.ValueOf(fn)\n-\t\twrapper := func(args []reflect.Value) []reflect.Value {\n-\t\t\tt.nameSpace.mu.RUnlock()\n-\t\t\tdefer t.nameSpace.mu.RLock()\n-\t\t\tif fnv.Type().IsVariadic() {\n-\t\t\t\treturn fnv.CallSlice(args)\n-\t\t\t} else {\n-\t\t\t\treturn fnv.Call(args)\n-\t\t\t}\n-\t\t}\n-\t\twrapped := reflect.MakeFunc(fnv.Type(), wrapper)\n-\t\ttfuncs[name] = wrapped.Interface()\n-\t}\n-\tt.text.Funcs(tfuncs)\n-}\n-\n // Delims sets the action delimiters to the specified strings, to be used in\n // subsequent calls to Parse, ParseFiles, or ParseGlob. Nested template\n // definitions will inherit the settings. An empty delimiter stands for the\n@@ -424,8 +360,8 @@ func (t *Template) Delims(left, right string) *Template {\n // Lookup returns the template with the given name that is associated with t,\n // or nil if there is no such template.\n func (t *Template) Lookup(name string) *Template {\n-\tt.nameSpace.mu.RLock()\n-\tdefer t.nameSpace.mu.RUnlock()\n+\tt.nameSpace.mu.Lock()\n+\tdefer t.nameSpace.mu.Unlock()\n \treturn t.set[name]\n }\n "}, {"sha": "9a05d971dadb9e49f632ba7622f88371e1b3a27d", "filename": "libgo/go/internal/execabs/execabs.go", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Finternal%2Fexecabs%2Fexecabs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Finternal%2Fexecabs%2Fexecabs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fexecabs%2Fexecabs.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -0,0 +1,70 @@\n+// Copyright 2021 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package execabs is a drop-in replacement for os/exec\n+// that requires PATH lookups to find absolute paths.\n+// That is, execabs.Command(\"cmd\") runs the same PATH lookup\n+// as exec.Command(\"cmd\"), but if the result is a path\n+// which is relative, the Run and Start methods will report\n+// an error instead of running the executable.\n+package execabs\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"reflect\"\n+\t\"unsafe\"\n+)\n+\n+var ErrNotFound = exec.ErrNotFound\n+\n+type (\n+\tCmd       = exec.Cmd\n+\tError     = exec.Error\n+\tExitError = exec.ExitError\n+)\n+\n+func relError(file, path string) error {\n+\treturn fmt.Errorf(\"%s resolves to executable relative to current directory (.%c%s)\", file, filepath.Separator, path)\n+}\n+\n+func LookPath(file string) (string, error) {\n+\tpath, err := exec.LookPath(file)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tif filepath.Base(file) == file && !filepath.IsAbs(path) {\n+\t\treturn \"\", relError(file, path)\n+\t}\n+\treturn path, nil\n+}\n+\n+func fixCmd(name string, cmd *exec.Cmd) {\n+\tif filepath.Base(name) == name && !filepath.IsAbs(cmd.Path) {\n+\t\t// exec.Command was called with a bare binary name and\n+\t\t// exec.LookPath returned a path which is not absolute.\n+\t\t// Set cmd.lookPathErr and clear cmd.Path so that it\n+\t\t// cannot be run.\n+\t\tlookPathErr := (*error)(unsafe.Pointer(reflect.ValueOf(cmd).Elem().FieldByName(\"lookPathErr\").Addr().Pointer()))\n+\t\tif *lookPathErr == nil {\n+\t\t\t*lookPathErr = relError(name, cmd.Path)\n+\t\t}\n+\t\tcmd.Path = \"\"\n+\t}\n+}\n+\n+func CommandContext(ctx context.Context, name string, arg ...string) *exec.Cmd {\n+\tcmd := exec.CommandContext(ctx, name, arg...)\n+\tfixCmd(name, cmd)\n+\treturn cmd\n+\n+}\n+\n+func Command(name string, arg ...string) *exec.Cmd {\n+\tcmd := exec.Command(name, arg...)\n+\tfixCmd(name, cmd)\n+\treturn cmd\n+}"}, {"sha": "b71458587c5e847db83c45f0528a0a8841155e14", "filename": "libgo/go/internal/execabs/execabs_test.go", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Finternal%2Fexecabs%2Fexecabs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Finternal%2Fexecabs%2Fexecabs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fexecabs%2Fexecabs_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package execabs\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"internal/testenv\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"runtime\"\n+\t\"testing\"\n+)\n+\n+func TestFixCmd(t *testing.T) {\n+\tcmd := &exec.Cmd{Path: \"hello\"}\n+\tfixCmd(\"hello\", cmd)\n+\tif cmd.Path != \"\" {\n+\t\tt.Error(\"fixCmd didn't clear cmd.Path\")\n+\t}\n+\texpectedErr := fmt.Sprintf(\"hello resolves to executable relative to current directory (.%chello)\", filepath.Separator)\n+\tif err := cmd.Run(); err == nil {\n+\t\tt.Fatal(\"Command.Run didn't fail\")\n+\t} else if err.Error() != expectedErr {\n+\t\tt.Fatalf(\"Command.Run returned unexpected error: want %q, got %q\", expectedErr, err.Error())\n+\t}\n+}\n+\n+func TestCommand(t *testing.T) {\n+\ttestenv.MustHaveExec(t)\n+\n+\tfor _, cmd := range []func(string) *Cmd{\n+\t\tfunc(s string) *Cmd { return Command(s) },\n+\t\tfunc(s string) *Cmd { return CommandContext(context.Background(), s) },\n+\t} {\n+\t\ttmpDir := t.TempDir()\n+\t\texecutable := \"execabs-test\"\n+\t\tif runtime.GOOS == \"windows\" {\n+\t\t\texecutable += \".exe\"\n+\t\t}\n+\t\tif err := ioutil.WriteFile(filepath.Join(tmpDir, executable), []byte{1, 2, 3}, 0111); err != nil {\n+\t\t\tt.Fatalf(\"ioutil.WriteFile failed: %s\", err)\n+\t\t}\n+\t\tcwd, err := os.Getwd()\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"os.Getwd failed: %s\", err)\n+\t\t}\n+\t\tdefer os.Chdir(cwd)\n+\t\tif err = os.Chdir(tmpDir); err != nil {\n+\t\t\tt.Fatalf(\"os.Chdir failed: %s\", err)\n+\t\t}\n+\t\tif runtime.GOOS != \"windows\" {\n+\t\t\t// add \".\" to PATH so that exec.LookPath looks in the current directory on\n+\t\t\t// non-windows platforms as well\n+\t\t\torigPath := os.Getenv(\"PATH\")\n+\t\t\tdefer os.Setenv(\"PATH\", origPath)\n+\t\t\tos.Setenv(\"PATH\", fmt.Sprintf(\".:%s\", origPath))\n+\t\t}\n+\t\texpectedErr := fmt.Sprintf(\"execabs-test resolves to executable relative to current directory (.%c%s)\", filepath.Separator, executable)\n+\t\tif err = cmd(\"execabs-test\").Run(); err == nil {\n+\t\t\tt.Fatalf(\"Command.Run didn't fail when exec.LookPath returned a relative path\")\n+\t\t} else if err.Error() != expectedErr {\n+\t\t\tt.Errorf(\"Command.Run returned unexpected error: want %q, got %q\", expectedErr, err.Error())\n+\t\t}\n+\t}\n+}\n+\n+func TestLookPath(t *testing.T) {\n+\ttestenv.MustHaveExec(t)\n+\n+\ttmpDir := t.TempDir()\n+\texecutable := \"execabs-test\"\n+\tif runtime.GOOS == \"windows\" {\n+\t\texecutable += \".exe\"\n+\t}\n+\tif err := ioutil.WriteFile(filepath.Join(tmpDir, executable), []byte{1, 2, 3}, 0111); err != nil {\n+\t\tt.Fatalf(\"ioutil.WriteFile failed: %s\", err)\n+\t}\n+\tcwd, err := os.Getwd()\n+\tif err != nil {\n+\t\tt.Fatalf(\"os.Getwd failed: %s\", err)\n+\t}\n+\tdefer os.Chdir(cwd)\n+\tif err = os.Chdir(tmpDir); err != nil {\n+\t\tt.Fatalf(\"os.Chdir failed: %s\", err)\n+\t}\n+\tif runtime.GOOS != \"windows\" {\n+\t\t// add \".\" to PATH so that exec.LookPath looks in the current directory on\n+\t\t// non-windows platforms as well\n+\t\torigPath := os.Getenv(\"PATH\")\n+\t\tdefer os.Setenv(\"PATH\", origPath)\n+\t\tos.Setenv(\"PATH\", fmt.Sprintf(\".:%s\", origPath))\n+\t}\n+\texpectedErr := fmt.Sprintf(\"execabs-test resolves to executable relative to current directory (.%c%s)\", filepath.Separator, executable)\n+\tif _, err := LookPath(\"execabs-test\"); err == nil {\n+\t\tt.Fatalf(\"LookPath didn't fail when finding a non-relative path\")\n+\t} else if err.Error() != expectedErr {\n+\t\tt.Errorf(\"LookPath returned unexpected error: want %q, got %q\", expectedErr, err.Error())\n+\t}\n+}"}, {"sha": "ce72bc389656a43681504ee97feff50b60526f1a", "filename": "libgo/go/internal/goroot/gc.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Finternal%2Fgoroot%2Fgc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Finternal%2Fgoroot%2Fgc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fgoroot%2Fgc.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -7,8 +7,8 @@\n package goroot\n \n import (\n+\texec \"internal/execabs\"\n \t\"os\"\n-\t\"os/exec\"\n \t\"path/filepath\"\n \t\"strings\"\n \t\"sync\""}, {"sha": "f8965d0bab175de81d8f0355794ded7ff253ea9d", "filename": "libgo/go/internal/syscall/windows/syscall_windows.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Finternal%2Fsyscall%2Fwindows%2Fsyscall_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Finternal%2Fsyscall%2Fwindows%2Fsyscall_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fsyscall%2Fwindows%2Fsyscall_windows.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -342,3 +342,5 @@ func LoadGetFinalPathNameByHandle() error {\n \n //sys\tCreateEnvironmentBlock(block **uint16, token syscall.Token, inheritExisting bool) (err error) = userenv.CreateEnvironmentBlock\n //sys\tDestroyEnvironmentBlock(block *uint16) (err error) = userenv.DestroyEnvironmentBlock\n+\n+//sys\tRtlGenRandom(buf []byte) (err error) = advapi32.SystemFunction036"}, {"sha": "aaad4a5b94b7e5f7a277c021790a2d94dbb09bf9", "filename": "libgo/go/internal/syscall/windows/zsyscall_windows.go", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Finternal%2Fsyscall%2Fwindows%2Fzsyscall_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Finternal%2Fsyscall%2Fwindows%2Fzsyscall_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fsyscall%2Fwindows%2Fzsyscall_windows.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -52,6 +52,7 @@ var (\n \tprocOpenThreadToken              = modadvapi32.NewProc(\"OpenThreadToken\")\n \tprocRevertToSelf                 = modadvapi32.NewProc(\"RevertToSelf\")\n \tprocSetTokenInformation          = modadvapi32.NewProc(\"SetTokenInformation\")\n+\tprocSystemFunction036            = modadvapi32.NewProc(\"SystemFunction036\")\n \tprocGetAdaptersAddresses         = modiphlpapi.NewProc(\"GetAdaptersAddresses\")\n \tprocGetACP                       = modkernel32.NewProc(\"GetACP\")\n \tprocGetComputerNameExW           = modkernel32.NewProc(\"GetComputerNameExW\")\n@@ -140,6 +141,18 @@ func SetTokenInformation(tokenHandle syscall.Token, tokenInformationClass uint32\n \treturn\n }\n \n+func RtlGenRandom(buf []byte) (err error) {\n+\tvar _p0 *byte\n+\tif len(buf) > 0 {\n+\t\t_p0 = &buf[0]\n+\t}\n+\tr1, _, e1 := syscall.Syscall(procSystemFunction036.Addr(), 2, uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), 0)\n+\tif r1 == 0 {\n+\t\terr = errnoErr(e1)\n+\t}\n+\treturn\n+}\n+\n func GetAdaptersAddresses(family uint32, flags uint32, reserved uintptr, adapterAddresses *IpAdapterAddresses, sizePointer *uint32) (errcode error) {\n \tr0, _, _ := syscall.Syscall6(procGetAdaptersAddresses.Addr(), 5, uintptr(family), uintptr(flags), uintptr(reserved), uintptr(unsafe.Pointer(adapterAddresses)), uintptr(unsafe.Pointer(sizePointer)), 0)\n \tif r0 != 0 {"}, {"sha": "549f217542967500bf6f8a96599a234da49bb13a", "filename": "libgo/go/io/fs/glob.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fio%2Ffs%2Fglob.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fio%2Ffs%2Fglob.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Ffs%2Fglob.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n+// Copyright 2020 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -22,7 +22,7 @@ type GlobFS interface {\n // Glob returns the names of all files matching pattern or nil\n // if there is no matching file. The syntax of patterns is the same\n // as in path.Match. The pattern may describe hierarchical names such as\n-// /usr/*/bin/ed (assuming the Separator is '/').\n+// usr/*/bin/ed.\n //\n // Glob ignores file system errors such as I/O errors reading directories.\n // The only possible returned error is path.ErrBadPattern, reporting that"}, {"sha": "440ebd6bf4bd93bf9a2df3de2b001c1e1f20840f", "filename": "libgo/go/io/fs/glob_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fio%2Ffs%2Fglob_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fio%2Ffs%2Fglob_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Ffs%2Fglob_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n+// Copyright 2020 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n "}, {"sha": "534876bad342051d31bed119f35d45a707ba3a5f", "filename": "libgo/go/io/fs/walk.go", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fio%2Ffs%2Fwalk.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fio%2Ffs%2Fwalk.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Ffs%2Fwalk.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -15,18 +15,13 @@ import (\n var SkipDir = errors.New(\"skip this directory\")\n \n // WalkDirFunc is the type of the function called by WalkDir to visit\n-// each each file or directory.\n+// each file or directory.\n //\n-// The path argument contains the argument to Walk as a prefix.\n-// That is, if Walk is called with root argument \"dir\" and finds a file\n+// The path argument contains the argument to WalkDir as a prefix.\n+// That is, if WalkDir is called with root argument \"dir\" and finds a file\n // named \"a\" in that directory, the walk function will be called with\n // argument \"dir/a\".\n //\n-// The directory and file are joined with Join, which may clean the\n-// directory name: if Walk is called with the root argument \"x/../dir\"\n-// and finds a file named \"a\" in that directory, the walk function will\n-// be called with argument \"dir/a\", not \"x/../dir/a\".\n-//\n // The d argument is the fs.DirEntry for the named path.\n //\n // The error result returned by the function controls how WalkDir\n@@ -42,9 +37,9 @@ var SkipDir = errors.New(\"skip this directory\")\n //\n // WalkDir calls the function with a non-nil err argument in two cases.\n //\n-// First, if the initial os.Lstat on the root directory fails, WalkDir\n+// First, if the initial fs.Stat on the root directory fails, WalkDir\n // calls the function with path set to root, d set to nil, and err set to\n-// the error from os.Lstat.\n+// the error from fs.Stat.\n //\n // Second, if a directory's ReadDir method fails, WalkDir calls the\n // function with path set to the directory's path, d set to an"}, {"sha": "ebc4e50fb319deaa05241ab84a04266742a0d08e", "filename": "libgo/go/io/fs/walk_test.go", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fio%2Ffs%2Fwalk_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fio%2Ffs%2Fwalk_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Ffs%2Fwalk_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -9,7 +9,6 @@ import (\n \t\"io/ioutil\"\n \t\"os\"\n \tpathpkg \"path\"\n-\t\"runtime\"\n \t\"testing\"\n \t\"testing/fstest\"\n )\n@@ -96,32 +95,7 @@ func mark(entry DirEntry, err error, errors *[]error, clear bool) error {\n \treturn nil\n }\n \n-func chtmpdir(t *testing.T) (restore func()) {\n-\toldwd, err := os.Getwd()\n-\tif err != nil {\n-\t\tt.Fatalf(\"chtmpdir: %v\", err)\n-\t}\n-\td, err := ioutil.TempDir(\"\", \"test\")\n-\tif err != nil {\n-\t\tt.Fatalf(\"chtmpdir: %v\", err)\n-\t}\n-\tif err := os.Chdir(d); err != nil {\n-\t\tt.Fatalf(\"chtmpdir: %v\", err)\n-\t}\n-\treturn func() {\n-\t\tif err := os.Chdir(oldwd); err != nil {\n-\t\t\tt.Fatalf(\"chtmpdir: %v\", err)\n-\t\t}\n-\t\tos.RemoveAll(d)\n-\t}\n-}\n-\n func TestWalkDir(t *testing.T) {\n-\tif runtime.GOOS == \"darwin\" && runtime.GOARCH == \"arm64\" {\n-\t\trestore := chtmpdir(t)\n-\t\tdefer restore()\n-\t}\n-\n \ttmpDir, err := ioutil.TempDir(\"\", \"TestWalk\")\n \tif err != nil {\n \t\tt.Fatal(\"creating temp dir:\", err)"}, {"sha": "78b0730c652a31e8c8a0d3742ab78d2d37fa675a", "filename": "libgo/go/io/ioutil/example_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fio%2Fioutil%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fio%2Fioutil%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fioutil%2Fexample_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -125,7 +125,7 @@ func ExampleReadFile() {\n \n func ExampleWriteFile() {\n \tmessage := []byte(\"Hello, Gophers!\")\n-\terr := ioutil.WriteFile(\"testdata/hello\", message, 0644)\n+\terr := ioutil.WriteFile(\"hello\", message, 0644)\n \tif err != nil {\n \t\tlog.Fatal(err)\n \t}"}, {"sha": "0afc10d727ecd11e122cca61d6bd9d769bfd8572", "filename": "libgo/go/math/rand/gen_cooked.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fmath%2Frand%2Fgen_cooked.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fmath%2Frand%2Fgen_cooked.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Frand%2Fgen_cooked.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -4,7 +4,7 @@\n \n // +build ignore\n \n-// This program computes the value of rng_cooked in rng.go,\n+// This program computes the value of rngCooked in rng.go,\n // which is used for seeding all instances of rand.Source.\n // a 64bit and a 63bit version of the array is printed to\n // the standard output."}, {"sha": "2533972f26d3232f9704c5f3e7ae8674f50cb280", "filename": "libgo/go/math/sqrt.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fmath%2Fsqrt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fmath%2Fsqrt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fsqrt.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -74,7 +74,7 @@ func Sqrt(x float64) float64 {\n //\n //      One may easily use induction to prove (4) and (5).\n //      Note. Since the left hand side of (3) contain only i+2 bits,\n-//            it does not necessary to do a full (53-bit) comparison\n+//            it is not necessary to do a full (53-bit) comparison\n //            in (3).\n //   3. Final rounding\n //      After generating the 53 bits result, we compute one more bit."}, {"sha": "756722ba1412a2dcc4e55a2f6e1e6ea4772d3ef6", "filename": "libgo/go/net/http/fcgi/child.go", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fnet%2Fhttp%2Ffcgi%2Fchild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fnet%2Fhttp%2Ffcgi%2Fchild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ffcgi%2Fchild.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -171,12 +171,9 @@ func (c *child) serve() {\n \tdefer c.cleanUp()\n \tvar rec record\n \tfor {\n-\t\tc.conn.mutex.Lock()\n \t\tif err := rec.read(c.conn.rwc); err != nil {\n-\t\t\tc.conn.mutex.Unlock()\n \t\t\treturn\n \t\t}\n-\t\tc.conn.mutex.Unlock()\n \t\tif err := c.handleRecord(&rec); err != nil {\n \t\t\treturn\n \t\t}"}, {"sha": "b58111de208dee2e05f8f46096bddba1f1a7ec74", "filename": "libgo/go/net/http/fcgi/fcgi_test.go", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fnet%2Fhttp%2Ffcgi%2Ffcgi_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fnet%2Fhttp%2Ffcgi%2Ffcgi_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ffcgi%2Ffcgi_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -221,7 +221,11 @@ var cleanUpTests = []struct {\n }\n \n type nopWriteCloser struct {\n-\tio.ReadWriter\n+\tio.Reader\n+}\n+\n+func (nopWriteCloser) Write(buf []byte) (int, error) {\n+\treturn len(buf), nil\n }\n \n func (nopWriteCloser) Close() error {\n@@ -235,7 +239,7 @@ func TestChildServeCleansUp(t *testing.T) {\n \tfor _, tt := range cleanUpTests {\n \t\tinput := make([]byte, len(tt.input))\n \t\tcopy(input, tt.input)\n-\t\trc := nopWriteCloser{bytes.NewBuffer(input)}\n+\t\trc := nopWriteCloser{bytes.NewReader(input)}\n \t\tdone := make(chan bool)\n \t\tc := newChild(rc, http.HandlerFunc(func(\n \t\t\tw http.ResponseWriter,\n@@ -325,7 +329,7 @@ func TestChildServeReadsEnvVars(t *testing.T) {\n \tfor _, tt := range envVarTests {\n \t\tinput := make([]byte, len(tt.input))\n \t\tcopy(input, tt.input)\n-\t\trc := nopWriteCloser{bytes.NewBuffer(input)}\n+\t\trc := nopWriteCloser{bytes.NewReader(input)}\n \t\tdone := make(chan bool)\n \t\tc := newChild(rc, http.HandlerFunc(func(\n \t\t\tw http.ResponseWriter,\n@@ -375,7 +379,7 @@ func TestResponseWriterSniffsContentType(t *testing.T) {\n \t\tt.Run(tt.name, func(t *testing.T) {\n \t\t\tinput := make([]byte, len(streamFullRequestStdin))\n \t\t\tcopy(input, streamFullRequestStdin)\n-\t\t\trc := nopWriteCloser{bytes.NewBuffer(input)}\n+\t\t\trc := nopWriteCloser{bytes.NewReader(input)}\n \t\t\tdone := make(chan bool)\n \t\t\tvar resp *response\n \t\t\tc := newChild(rc, http.HandlerFunc(func("}, {"sha": "2948f27e5d5c58b4b93a7b3452b56b7062264406", "filename": "libgo/go/net/http/httputil/dump.go", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fdump.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fdump.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fdump.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -138,6 +138,8 @@ func DumpRequestOut(req *http.Request, body bool) ([]byte, error) {\n \t\tselect {\n \t\tcase dr.c <- strings.NewReader(\"HTTP/1.1 204 No Content\\r\\nConnection: close\\r\\n\\r\\n\"):\n \t\tcase <-quitReadCh:\n+\t\t\t// Ensure delegateReader.Read doesn't block forever if we get an error.\n+\t\t\tclose(dr.c)\n \t\t}\n \t}()\n \n@@ -146,7 +148,8 @@ func DumpRequestOut(req *http.Request, body bool) ([]byte, error) {\n \treq.Body = save\n \tif err != nil {\n \t\tpw.Close()\n-\t\tquitReadCh <- struct{}{}\n+\t\tdr.err = err\n+\t\tclose(quitReadCh)\n \t\treturn nil, err\n \t}\n \tdump := buf.Bytes()\n@@ -167,13 +170,17 @@ func DumpRequestOut(req *http.Request, body bool) ([]byte, error) {\n // delegateReader is a reader that delegates to another reader,\n // once it arrives on a channel.\n type delegateReader struct {\n-\tc chan io.Reader\n-\tr io.Reader // nil until received from c\n+\tc   chan io.Reader\n+\terr error     // only used if r is nil and c is closed.\n+\tr   io.Reader // nil until received from c\n }\n \n func (r *delegateReader) Read(p []byte) (int, error) {\n \tif r.r == nil {\n-\t\tr.r = <-r.c\n+\t\tvar ok bool\n+\t\tif r.r, ok = <-r.c; !ok {\n+\t\t\treturn 0, r.err\n+\t\t}\n \t}\n \treturn r.r.Read(p)\n }"}, {"sha": "8168b2ebc05d0d633a43226f37e5e7d03b51fb4e", "filename": "libgo/go/net/http/httputil/dump_test.go", "status": "modified", "additions": 76, "deletions": 4, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fdump_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fdump_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fdump_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -7,13 +7,17 @@ package httputil\n import (\n \t\"bufio\"\n \t\"bytes\"\n+\t\"context\"\n \t\"fmt\"\n \t\"io\"\n+\t\"math/rand\"\n \t\"net/http\"\n \t\"net/url\"\n \t\"runtime\"\n+\t\"runtime/pprof\"\n \t\"strings\"\n \t\"testing\"\n+\t\"time\"\n )\n \n type eofReader struct{}\n@@ -311,11 +315,39 @@ func TestDumpRequest(t *testing.T) {\n \t\t\t}\n \t\t}\n \t}\n-\tif dg := runtime.NumGoroutine() - numg0; dg > 4 {\n-\t\tbuf := make([]byte, 4096)\n-\t\tbuf = buf[:runtime.Stack(buf, true)]\n-\t\tt.Errorf(\"Unexpectedly large number of new goroutines: %d new: %s\", dg, buf)\n+\n+\t// Validate we haven't leaked any goroutines.\n+\tvar dg int\n+\tdl := deadline(t, 5*time.Second, time.Second)\n+\tfor time.Now().Before(dl) {\n+\t\tif dg = runtime.NumGoroutine() - numg0; dg <= 4 {\n+\t\t\t// No unexpected goroutines.\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// Allow goroutines to schedule and die off.\n+\t\truntime.Gosched()\n+\t}\n+\n+\tbuf := make([]byte, 4096)\n+\tbuf = buf[:runtime.Stack(buf, true)]\n+\tt.Errorf(\"Unexpectedly large number of new goroutines: %d new: %s\", dg, buf)\n+}\n+\n+// deadline returns the time which is needed before t.Deadline()\n+// if one is configured and it is s greater than needed in the future,\n+// otherwise defaultDelay from the current time.\n+func deadline(t *testing.T, defaultDelay, needed time.Duration) time.Time {\n+\tif dl, ok := t.Deadline(); ok {\n+\t\tif dl = dl.Add(-needed); dl.After(time.Now()) {\n+\t\t\t// Allow an arbitrarily long delay.\n+\t\t\treturn dl\n+\t\t}\n \t}\n+\n+\t// No deadline configured or its closer than needed from now\n+\t// so just use the default.\n+\treturn time.Now().Add(defaultDelay)\n }\n \n func chunk(s string) string {\n@@ -445,3 +477,43 @@ func TestDumpResponse(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+// Issue 38352: Check for deadlock on cancelled requests.\n+func TestDumpRequestOutIssue38352(t *testing.T) {\n+\tif testing.Short() {\n+\t\treturn\n+\t}\n+\tt.Parallel()\n+\n+\ttimeout := 10 * time.Second\n+\tif deadline, ok := t.Deadline(); ok {\n+\t\ttimeout = time.Until(deadline)\n+\t\ttimeout -= time.Second * 2 // Leave 2 seconds to report failures.\n+\t}\n+\tfor i := 0; i < 1000; i++ {\n+\t\tdelay := time.Duration(rand.Intn(5)) * time.Millisecond\n+\t\tctx, cancel := context.WithTimeout(context.Background(), delay)\n+\t\tdefer cancel()\n+\n+\t\tr := bytes.NewBuffer(make([]byte, 10000))\n+\t\treq, err := http.NewRequestWithContext(ctx, http.MethodPost, \"http://example.com\", r)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\n+\t\tout := make(chan error)\n+\t\tgo func() {\n+\t\t\t_, err = DumpRequestOut(req, true)\n+\t\t\tout <- err\n+\t\t}()\n+\n+\t\tselect {\n+\t\tcase <-out:\n+\t\tcase <-time.After(timeout):\n+\t\t\tb := &bytes.Buffer{}\n+\t\t\tfmt.Fprintf(b, \"deadlock detected on iteration %d after %s with delay: %v\\n\", i, timeout, delay)\n+\t\t\tpprof.Lookup(\"goroutine\").WriteTo(b, 1)\n+\t\t\tt.Fatal(b.String())\n+\t\t}\n+\t}\n+}"}, {"sha": "f8687416fe96c019a80e7e2ae58740f2dd7508db", "filename": "libgo/go/net/http/serve_test.go", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -6460,13 +6460,15 @@ func TestDisableKeepAliveUpgrade(t *testing.T) {\n \t\tw.Header().Set(\"Connection\", \"Upgrade\")\n \t\tw.Header().Set(\"Upgrade\", \"someProto\")\n \t\tw.WriteHeader(StatusSwitchingProtocols)\n-\t\tc, _, err := w.(Hijacker).Hijack()\n+\t\tc, buf, err := w.(Hijacker).Hijack()\n \t\tif err != nil {\n \t\t\treturn\n \t\t}\n \t\tdefer c.Close()\n \n-\t\tio.Copy(c, c)\n+\t\t// Copy from the *bufio.ReadWriter, which may contain buffered data.\n+\t\t// Copy to the net.Conn, to avoid buffering the output.\n+\t\tio.Copy(c, buf)\n \t}))\n \ts.Config.SetKeepAlivesEnabled(false)\n \ts.Start()"}, {"sha": "33aadd6c2a9ce0a47136e32b6193d2b4e557c3de", "filename": "libgo/go/net/http/server.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -1842,7 +1842,7 @@ func (c *conn) serve(ctx context.Context) {\n \t\tif d := c.server.WriteTimeout; d != 0 {\n \t\t\tc.rwc.SetWriteDeadline(time.Now().Add(d))\n \t\t}\n-\t\tif err := tlsConn.HandshakeContext(ctx); err != nil {\n+\t\tif err := tlsConn.Handshake(); err != nil {\n \t\t\t// If the handshake failed due to the client not speaking\n \t\t\t// TLS, assume they're speaking plaintext HTTP and write a\n \t\t\t// 400 response on the TLS conn's underlying net.Conn."}, {"sha": "0aa48273dd385848bc04166027a5d4548494f47b", "filename": "libgo/go/net/http/transport.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -1505,7 +1505,7 @@ func (t *Transport) decConnsPerHost(key connectMethodKey) {\n // Add TLS to a persistent connection, i.e. negotiate a TLS session. If pconn is already a TLS\n // tunnel, this function establishes a nested TLS session inside the encrypted channel.\n // The remote endpoint's name may be overridden by TLSClientConfig.ServerName.\n-func (pconn *persistConn) addTLS(ctx context.Context, name string, trace *httptrace.ClientTrace) error {\n+func (pconn *persistConn) addTLS(name string, trace *httptrace.ClientTrace) error {\n \t// Initiate TLS and check remote host name against certificate.\n \tcfg := cloneTLSConfig(pconn.t.TLSClientConfig)\n \tif cfg.ServerName == \"\" {\n@@ -1527,7 +1527,7 @@ func (pconn *persistConn) addTLS(ctx context.Context, name string, trace *httptr\n \t\tif trace != nil && trace.TLSHandshakeStart != nil {\n \t\t\ttrace.TLSHandshakeStart()\n \t\t}\n-\t\terr := tlsConn.HandshakeContext(ctx)\n+\t\terr := tlsConn.Handshake()\n \t\tif timer != nil {\n \t\t\ttimer.Stop()\n \t\t}\n@@ -1583,7 +1583,7 @@ func (t *Transport) dialConn(ctx context.Context, cm connectMethod) (pconn *pers\n \t\t\tif trace != nil && trace.TLSHandshakeStart != nil {\n \t\t\t\ttrace.TLSHandshakeStart()\n \t\t\t}\n-\t\t\tif err := tc.HandshakeContext(ctx); err != nil {\n+\t\t\tif err := tc.Handshake(); err != nil {\n \t\t\t\tgo pconn.conn.Close()\n \t\t\t\tif trace != nil && trace.TLSHandshakeDone != nil {\n \t\t\t\t\ttrace.TLSHandshakeDone(tls.ConnectionState{}, err)\n@@ -1607,7 +1607,7 @@ func (t *Transport) dialConn(ctx context.Context, cm connectMethod) (pconn *pers\n \t\t\tif firstTLSHost, _, err = net.SplitHostPort(cm.addr()); err != nil {\n \t\t\t\treturn nil, wrapErr(err)\n \t\t\t}\n-\t\t\tif err = pconn.addTLS(ctx, firstTLSHost, trace); err != nil {\n+\t\t\tif err = pconn.addTLS(firstTLSHost, trace); err != nil {\n \t\t\t\treturn nil, wrapErr(err)\n \t\t\t}\n \t\t}\n@@ -1721,7 +1721,7 @@ func (t *Transport) dialConn(ctx context.Context, cm connectMethod) (pconn *pers\n \t}\n \n \tif cm.proxyURL != nil && cm.targetScheme == \"https\" {\n-\t\tif err := pconn.addTLS(ctx, cm.tlsHost(), trace); err != nil {\n+\t\tif err := pconn.addTLS(cm.tlsHost(), trace); err != nil {\n \t\t\treturn nil, err\n \t\t}\n \t}"}, {"sha": "cf1f5110da0fb00e380658a907cee403203bd5ab", "filename": "libgo/go/net/http/transport_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -3738,7 +3738,7 @@ func TestTransportDialTLSContext(t *testing.T) {\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\t\treturn c, c.HandshakeContext(ctx)\n+\t\treturn c, c.Handshake()\n \t}\n \n \treq, err := NewRequest(\"GET\", ts.URL, nil)"}, {"sha": "80a17b2853ae45bbec72c2944e10f95ba05e47b6", "filename": "libgo/go/net/mail/message_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fnet%2Fmail%2Fmessage_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fnet%2Fmail%2Fmessage_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fmail%2Fmessage_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -107,8 +107,8 @@ func TestDateParsing(t *testing.T) {\n \t\t\ttime.Date(1997, 11, 20, 9, 55, 6, 0, time.FixedZone(\"\", -6*60*60)),\n \t\t},\n \t\t{\n-\t\t\t\"Thu, 20 Nov 1997 09:55:06 MDT (MDT)\",\n-\t\t\ttime.Date(1997, 11, 20, 9, 55, 6, 0, time.FixedZone(\"MDT\", 0)),\n+\t\t\t\"Thu, 20 Nov 1997 09:55:06 GMT (GMT)\",\n+\t\t\ttime.Date(1997, 11, 20, 9, 55, 6, 0, time.UTC),\n \t\t},\n \t\t{\n \t\t\t\"Fri, 21 Nov 1997 09:55:06 +1300 (TOT)\",\n@@ -278,8 +278,8 @@ func TestDateParsingCFWS(t *testing.T) {\n \t\t\ttrue,\n \t\t},\n \t\t{\n-\t\t\t\"Fri, 21 Nov 1997 09:55:06 MDT (MDT)\",\n-\t\t\ttime.Date(1997, 11, 21, 9, 55, 6, 0, time.FixedZone(\"MDT\", 0)),\n+\t\t\t\"Fri, 21 Nov 1997 09:55:06 GMT (GMT)\",\n+\t\t\ttime.Date(1997, 11, 21, 9, 55, 6, 0, time.UTC),\n \t\t\ttrue,\n \t\t},\n \t}"}, {"sha": "4f384e9211061d526dd6c3ca736572e79389235d", "filename": "libgo/go/os/file_plan9.go", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fos%2Ffile_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fos%2Ffile_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_plan9.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -336,16 +336,6 @@ func hasPrefix(s, prefix string) bool {\n \treturn len(s) >= len(prefix) && s[0:len(prefix)] == prefix\n }\n \n-// LastIndexByte from the strings package.\n-func lastIndex(s string, sep byte) int {\n-\tfor i := len(s) - 1; i >= 0; i-- {\n-\t\tif s[i] == sep {\n-\t\t\treturn i\n-\t\t}\n-\t}\n-\treturn -1\n-}\n-\n func rename(oldname, newname string) error {\n \tdirname := oldname[:lastIndex(oldname, '/')+1]\n \tif hasPrefix(newname, dirname) {"}, {"sha": "5888d48f8193c357d756a3a71379f4fe4320bf0d", "filename": "libgo/go/os/file_unix.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fos%2Ffile_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fos%2Ffile_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_unix.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -66,6 +66,10 @@ type file struct {\n // making it invalid; see runtime.SetFinalizer for more information on when\n // a finalizer might be run. On Unix systems this will cause the SetDeadline\n // methods to stop working.\n+// Because file descriptors can be reused, the returned file descriptor may\n+// only be closed through the Close method of f, or by its finalizer during\n+// garbage collection. Otherwise, during garbage collection the finalizer\n+// may close an unrelated file descriptor with the same (reused) number.\n //\n // As an alternative, see the f.SyscallConn method.\n func (f *File) Fd() uintptr {\n@@ -90,6 +94,10 @@ func (f *File) Fd() uintptr {\n // descriptor. On Unix systems, if the file descriptor is in\n // non-blocking mode, NewFile will attempt to return a pollable File\n // (one for which the SetDeadline methods work).\n+//\n+// After passing it to NewFile, fd may become invalid under the same\n+// conditions described in the comments of the Fd method, and the same\n+// constraints apply.\n func NewFile(fd uintptr, name string) *File {\n \tkind := kindNewFile\n \tif nb, err := unix.IsNonblock(int(fd)); err == nil && nb {"}, {"sha": "40ba05697b679efb42f0d62c2cd0bbce2e06048a", "filename": "libgo/go/os/os_test.go", "status": "modified", "additions": 37, "deletions": 8, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fos%2Fos_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fos%2Fos_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fos_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -11,6 +11,7 @@ import (\n \t\"fmt\"\n \t\"internal/testenv\"\n \t\"io\"\n+\t\"io/fs\"\n \t\"os\"\n \t. \"os\"\n \tosexec \"os/exec\"\n@@ -2300,21 +2301,23 @@ func TestLongPath(t *testing.T) {\n \n func testKillProcess(t *testing.T, processKiller func(p *Process)) {\n \ttestenv.MustHaveExec(t)\n+\tt.Parallel()\n \n \t// Re-exec the test binary itself to emulate \"sleep 1\".\n \tcmd := osexec.Command(Args[0], \"-test.run\", \"TestSleep\")\n \terr := cmd.Start()\n \tif err != nil {\n \t\tt.Fatalf(\"Failed to start test process: %v\", err)\n \t}\n-\tgo func() {\n-\t\ttime.Sleep(100 * time.Millisecond)\n-\t\tprocessKiller(cmd.Process)\n+\n+\tdefer func() {\n+\t\tif err := cmd.Wait(); err == nil {\n+\t\t\tt.Errorf(\"Test process succeeded, but expected to fail\")\n+\t\t}\n \t}()\n-\terr = cmd.Wait()\n-\tif err == nil {\n-\t\tt.Errorf(\"Test process succeeded, but expected to fail\")\n-\t}\n+\n+\ttime.Sleep(100 * time.Millisecond)\n+\tprocessKiller(cmd.Process)\n }\n \n // TestSleep emulates \"sleep 1\". It is a helper for testKillProcess, so we\n@@ -2689,7 +2692,33 @@ func TestOpenFileKeepsPermissions(t *testing.T) {\n }\n \n func TestDirFS(t *testing.T) {\n-\tif err := fstest.TestFS(DirFS(\"./signal\"), \"signal.go\", \"internal/pty/pty.go\"); err != nil {\n+\t// On Windows, we force the MFT to update by reading the actual metadata from GetFileInformationByHandle and then\n+\t// explicitly setting that. Otherwise it might get out of sync with FindFirstFile. See golang.org/issues/42637.\n+\tif runtime.GOOS == \"windows\" {\n+\t\tif err := filepath.WalkDir(\"./testdata/dirfs\", func(path string, d fs.DirEntry, err error) error {\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tinfo, err := d.Info()\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tstat, err := Stat(path) // This uses GetFileInformationByHandle internally.\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tif stat.ModTime() == info.ModTime() {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t\tif err := Chtimes(path, stat.ModTime(), stat.ModTime()); err != nil {\n+\t\t\t\tt.Log(err) // We only log, not die, in case the test directory is not writable.\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t}); err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t}\n+\tif err := fstest.TestFS(DirFS(\"./testdata/dirfs\"), \"a\", \"b\", \"dir/x\"); err != nil {\n \t\tt.Fatal(err)\n \t}\n }"}, {"sha": "b0929b4f3085a5532e7b0ce5dc75ac9953804110", "filename": "libgo/go/os/os_windows_test.go", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fos%2Fos_windows_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fos%2Fos_windows_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fos_windows_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -692,7 +692,16 @@ func TestReadStdin(t *testing.T) {\n \t\tpoll.ReadConsole = old\n \t}()\n \n-\ttestConsole := os.NewConsoleFile(syscall.Stdin, \"test\")\n+\tp, err := syscall.GetCurrentProcess()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Unable to get handle to current process: %v\", err)\n+\t}\n+\tvar stdinDuplicate syscall.Handle\n+\terr = syscall.DuplicateHandle(p, syscall.Handle(syscall.Stdin), p, &stdinDuplicate, 0, false, syscall.DUPLICATE_SAME_ACCESS)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Unable to duplicate stdin: %v\", err)\n+\t}\n+\ttestConsole := os.NewConsoleFile(stdinDuplicate, \"test\")\n \n \tvar tests = []string{\n \t\t\"abc\","}, {"sha": "2e553d0b0f0c763427e8dbd6e72d74f6e8cd3a32", "filename": "libgo/go/os/signal/signal_linux_test.go", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fos%2Fsignal%2Fsignal_linux_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fos%2Fsignal%2Fsignal_linux_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fsignal%2Fsignal_linux_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build linux\n+\n+package signal\n+\n+import (\n+\t\"os\"\n+\t\"syscall\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+const prSetKeepCaps = 8\n+\n+// This test validates that syscall.AllThreadsSyscall() can reliably\n+// reach all 'm' (threads) of the nocgo runtime even when one thread\n+// is blocked waiting to receive signals from the kernel. This monitors\n+// for a regression vs. the fix for #43149.\n+func TestAllThreadsSyscallSignals(t *testing.T) {\n+\tif _, _, err := syscall.AllThreadsSyscall(syscall.SYS_PRCTL, prSetKeepCaps, 0, 0); err == syscall.ENOTSUP {\n+\t\tt.Skip(\"AllThreadsSyscall disabled with cgo\")\n+\t}\n+\n+\tsig := make(chan os.Signal, 1)\n+\tNotify(sig, os.Interrupt)\n+\n+\tfor i := 0; i <= 100; i++ {\n+\t\tif _, _, errno := syscall.AllThreadsSyscall(syscall.SYS_PRCTL, prSetKeepCaps, uintptr(i&1), 0); errno != 0 {\n+\t\t\tt.Fatalf(\"[%d] failed to set KEEP_CAPS=%d: %v\", i, i&1, errno)\n+\t\t}\n+\t}\n+\n+\tselect {\n+\tcase <-time.After(10 * time.Millisecond):\n+\tcase <-sig:\n+\t\tt.Fatal(\"unexpected signal\")\n+\t}\n+\tStop(sig)\n+}"}, {"sha": "db947568dcae0dc354b75d05035b38f0f1f3c7df", "filename": "libgo/go/os/signal/signal_test.go", "status": "modified", "additions": 60, "deletions": 42, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fos%2Fsignal%2Fsignal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fos%2Fsignal%2Fsignal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fsignal%2Fsignal_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -675,22 +675,68 @@ func TestTime(t *testing.T) {\n \t<-done\n }\n \n-func TestNotifyContext(t *testing.T) {\n-\tc, stop := NotifyContext(context.Background(), syscall.SIGINT)\n-\tdefer stop()\n-\n-\tif want, got := \"signal.NotifyContext(context.Background, [interrupt])\", fmt.Sprint(c); want != got {\n-\t\tt.Errorf(\"c.String() = %q, want %q\", got, want)\n-\t}\n+var (\n+\tcheckNotifyContext = flag.Bool(\"check_notify_ctx\", false, \"if true, TestNotifyContext will fail if SIGINT is not received.\")\n+\tctxNotifyTimes     = flag.Int(\"ctx_notify_times\", 1, \"number of times a SIGINT signal should be received\")\n+)\n \n-\tsyscall.Kill(syscall.Getpid(), syscall.SIGINT)\n-\tselect {\n-\tcase <-c.Done():\n-\t\tif got := c.Err(); got != context.Canceled {\n-\t\t\tt.Errorf(\"c.Err() = %q, want %q\", got, context.Canceled)\n+func TestNotifyContextNotifications(t *testing.T) {\n+\tif *checkNotifyContext {\n+\t\tctx, _ := NotifyContext(context.Background(), syscall.SIGINT)\n+\t\t// We want to make sure not to be calling Stop() internally on NotifyContext() when processing a received signal.\n+\t\t// Being able to wait for a number of received system signals allows us to do so.\n+\t\tvar wg sync.WaitGroup\n+\t\tn := *ctxNotifyTimes\n+\t\twg.Add(n)\n+\t\tfor i := 0; i < n; i++ {\n+\t\t\tgo func() {\n+\t\t\t\tsyscall.Kill(syscall.Getpid(), syscall.SIGINT)\n+\t\t\t\twg.Done()\n+\t\t\t}()\n \t\t}\n-\tcase <-time.After(time.Second):\n-\t\tt.Errorf(\"timed out waiting for context to be done after SIGINT\")\n+\t\twg.Wait()\n+\t\t<-ctx.Done()\n+\t\tfmt.Print(\"received SIGINT\")\n+\t\t// Sleep to give time to simultaneous signals to reach the process.\n+\t\t// These signals must be ignored given stop() is not called on this code.\n+\t\t// We want to guarantee a SIGINT doesn't cause a premature termination of the program.\n+\t\ttime.Sleep(settleTime)\n+\t\treturn\n+\t}\n+\n+\tt.Parallel()\n+\ttestCases := []struct {\n+\t\tname string\n+\t\tn    int // number of times a SIGINT should be notified.\n+\t}{\n+\t\t{\"once\", 1},\n+\t\t{\"multiple\", 10},\n+\t}\n+\tfor _, tc := range testCases {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\tvar subTimeout time.Duration\n+\t\t\tif deadline, ok := t.Deadline(); ok {\n+\t\t\t\tsubTimeout := time.Until(deadline)\n+\t\t\t\tsubTimeout -= subTimeout / 10 // Leave 10% headroom for cleaning up subprocess.\n+\t\t\t}\n+\n+\t\t\targs := []string{\n+\t\t\t\t\"-test.v\",\n+\t\t\t\t\"-test.run=TestNotifyContextNotifications$\",\n+\t\t\t\t\"-check_notify_ctx\",\n+\t\t\t\tfmt.Sprintf(\"-ctx_notify_times=%d\", tc.n),\n+\t\t\t}\n+\t\t\tif subTimeout != 0 {\n+\t\t\t\targs = append(args, fmt.Sprintf(\"-test.timeout=%v\", subTimeout))\n+\t\t\t}\n+\t\t\tout, err := exec.Command(os.Args[0], args...).CombinedOutput()\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"ran test with -check_notify_ctx_notification and it failed with %v.\\nOutput:\\n%s\", err, out)\n+\t\t\t}\n+\t\t\tif want := []byte(\"received SIGINT\"); !bytes.Contains(out, want) {\n+\t\t\t\tt.Errorf(\"got %q, wanted %q\", out, want)\n+\t\t\t}\n+\t\t})\n \t}\n }\n \n@@ -768,34 +814,6 @@ func TestNotifyContextPrematureCancelParent(t *testing.T) {\n \t}\n }\n \n-func TestNotifyContextSimultaneousNotifications(t *testing.T) {\n-\tc, stop := NotifyContext(context.Background(), syscall.SIGINT)\n-\tdefer stop()\n-\n-\tif want, got := \"signal.NotifyContext(context.Background, [interrupt])\", fmt.Sprint(c); want != got {\n-\t\tt.Errorf(\"c.String() = %q, want %q\", got, want)\n-\t}\n-\n-\tvar wg sync.WaitGroup\n-\tn := 10\n-\twg.Add(n)\n-\tfor i := 0; i < n; i++ {\n-\t\tgo func() {\n-\t\t\tsyscall.Kill(syscall.Getpid(), syscall.SIGINT)\n-\t\t\twg.Done()\n-\t\t}()\n-\t}\n-\twg.Wait()\n-\tselect {\n-\tcase <-c.Done():\n-\t\tif got := c.Err(); got != context.Canceled {\n-\t\t\tt.Errorf(\"c.Err() = %q, want %q\", got, context.Canceled)\n-\t\t}\n-\tcase <-time.After(time.Second):\n-\t\tt.Errorf(\"expected context to be canceled\")\n-\t}\n-}\n-\n func TestNotifyContextSimultaneousStop(t *testing.T) {\n \tc, stop := NotifyContext(context.Background(), syscall.SIGINT)\n \tdefer stop()"}, {"sha": "1ad44f1163fa58b90eca41cf9b49d55270cd60da", "filename": "libgo/go/os/tempfile.go", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fos%2Ftempfile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fos%2Ftempfile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ftempfile.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -4,10 +4,7 @@\n \n package os\n \n-import (\n-\t\"errors\"\n-\t\"strings\"\n-)\n+import \"errors\"\n \n // fastrand provided by runtime.\n // We generate random temporary file names so that there's a good\n@@ -23,7 +20,7 @@ func nextRandom() string {\n // opens the file for reading and writing, and returns the resulting file.\n // The filename is generated by taking pattern and adding a random string to the end.\n // If pattern includes a \"*\", the random string replaces the last \"*\".\n-// If dir is the empty string, TempFile uses the default directory for temporary files, as returned by TempDir.\n+// If dir is the empty string, CreateTemp uses the default directory for temporary files, as returned by TempDir.\n // Multiple programs or goroutines calling CreateTemp simultaneously will not choose the same file.\n // The caller can use the file's Name method to find the pathname of the file.\n // It is the caller's responsibility to remove the file when it is no longer needed.\n@@ -62,7 +59,7 @@ func prefixAndSuffix(pattern string) (prefix, suffix string, err error) {\n \t\t\treturn \"\", \"\", errPatternHasSeparator\n \t\t}\n \t}\n-\tif pos := strings.LastIndex(pattern, \"*\"); pos != -1 {\n+\tif pos := lastIndex(pattern, '*'); pos != -1 {\n \t\tprefix, suffix = pattern[:pos], pattern[pos+1:]\n \t} else {\n \t\tprefix = pattern\n@@ -74,7 +71,7 @@ func prefixAndSuffix(pattern string) (prefix, suffix string, err error) {\n // and returns the pathname of the new directory.\n // The new directory's name is generated by adding a random string to the end of pattern.\n // If pattern includes a \"*\", the random string replaces the last \"*\" instead.\n-// If dir is the empty string, TempFile uses the default directory for temporary files, as returned by TempDir.\n+// If dir is the empty string, MkdirTemp uses the default directory for temporary files, as returned by TempDir.\n // Multiple programs or goroutines calling MkdirTemp simultaneously will not choose the same directory.\n // It is the caller's responsibility to remove the directory when it is no longer needed.\n func MkdirTemp(dir, pattern string) (string, error) {\n@@ -116,3 +113,13 @@ func joinPath(dir, name string) string {\n \t}\n \treturn dir + string(PathSeparator) + name\n }\n+\n+// LastIndexByte from the strings package.\n+func lastIndex(s string, sep byte) int {\n+\tfor i := len(s) - 1; i >= 0; i-- {\n+\t\tif s[i] == sep {\n+\t\t\treturn i\n+\t\t}\n+\t}\n+\treturn -1\n+}"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libgo/go/os/testdata/dirfs/a", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fos%2Ftestdata%2Fdirfs%2Fa", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fos%2Ftestdata%2Fdirfs%2Fa", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ftestdata%2Fdirfs%2Fa?ref=726b7aa004d6885388a76521222602b8552a41ee"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libgo/go/os/testdata/dirfs/b", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fos%2Ftestdata%2Fdirfs%2Fb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fos%2Ftestdata%2Fdirfs%2Fb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ftestdata%2Fdirfs%2Fb?ref=726b7aa004d6885388a76521222602b8552a41ee"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libgo/go/os/testdata/dirfs/dir/x", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fos%2Ftestdata%2Fdirfs%2Fdir%2Fx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fos%2Ftestdata%2Fdirfs%2Fdir%2Fx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ftestdata%2Fdirfs%2Fdir%2Fx?ref=726b7aa004d6885388a76521222602b8552a41ee"}, {"sha": "c73ef471e55d15a869393586f5d20700e167deda", "filename": "libgo/go/reflect/all_test.go", "status": "modified", "additions": 0, "deletions": 170, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Freflect%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Freflect%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fall_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -7204,176 +7204,6 @@ func TestMapIterDelete1(t *testing.T) {\n \t}\n }\n \n-func TestStructTagLookup(t *testing.T) {\n-\tvar tests = []struct {\n-\t\ttag           StructTag\n-\t\tkey           string\n-\t\texpectedValue string\n-\t\texpectedOK    bool\n-\t}{\n-\t\t{\n-\t\t\ttag:           `json:\"json_value_1\"`,\n-\t\t\tkey:           \"json\",\n-\t\t\texpectedValue: \"json_value_1\",\n-\t\t\texpectedOK:    true,\n-\t\t},\n-\t\t{\n-\t\t\ttag:           `json:\"json_value_2\" xml:\"xml_value_2\"`,\n-\t\t\tkey:           \"json\",\n-\t\t\texpectedValue: \"json_value_2\",\n-\t\t\texpectedOK:    true,\n-\t\t},\n-\t\t{\n-\t\t\ttag:           `json:\"json_value_3\" xml:\"xml_value_3\"`,\n-\t\t\tkey:           \"xml\",\n-\t\t\texpectedValue: \"xml_value_3\",\n-\t\t\texpectedOK:    true,\n-\t\t},\n-\t\t{\n-\t\t\ttag:           `bson json:\"shared_value_4\"`,\n-\t\t\tkey:           \"json\",\n-\t\t\texpectedValue: \"shared_value_4\",\n-\t\t\texpectedOK:    true,\n-\t\t},\n-\t\t{\n-\t\t\ttag:           `bson json:\"shared_value_5\"`,\n-\t\t\tkey:           \"bson\",\n-\t\t\texpectedValue: \"shared_value_5\",\n-\t\t\texpectedOK:    true,\n-\t\t},\n-\t\t{\n-\t\t\ttag:           `json bson xml form:\"field_1,omitempty\" other:\"value_1\"`,\n-\t\t\tkey:           \"xml\",\n-\t\t\texpectedValue: \"field_1,omitempty\",\n-\t\t\texpectedOK:    true,\n-\t\t},\n-\t\t{\n-\t\t\ttag:           `json bson xml form:\"field_2,omitempty\" other:\"value_2\"`,\n-\t\t\tkey:           \"form\",\n-\t\t\texpectedValue: \"field_2,omitempty\",\n-\t\t\texpectedOK:    true,\n-\t\t},\n-\t\t{\n-\t\t\ttag:           `json bson xml form:\"field_3,omitempty\" other:\"value_3\"`,\n-\t\t\tkey:           \"other\",\n-\t\t\texpectedValue: \"value_3\",\n-\t\t\texpectedOK:    true,\n-\t\t},\n-\t\t{\n-\t\t\ttag:           `json    bson    xml    form:\"field_4\" other:\"value_4\"`,\n-\t\t\tkey:           \"json\",\n-\t\t\texpectedValue: \"field_4\",\n-\t\t\texpectedOK:    true,\n-\t\t},\n-\t\t{\n-\t\t\ttag:           `json    bson    xml    form:\"field_5\" other:\"value_5\"`,\n-\t\t\tkey:           \"non_existing\",\n-\t\t\texpectedValue: \"\",\n-\t\t\texpectedOK:    false,\n-\t\t},\n-\t\t{\n-\t\t\ttag:           `json \"json_6\"`,\n-\t\t\tkey:           \"json\",\n-\t\t\texpectedValue: \"\",\n-\t\t\texpectedOK:    false,\n-\t\t},\n-\t\t{\n-\t\t\ttag:           `json:\"json_7\" bson \"bson_7\"`,\n-\t\t\tkey:           \"json\",\n-\t\t\texpectedValue: \"json_7\",\n-\t\t\texpectedOK:    true,\n-\t\t},\n-\t\t{\n-\t\t\ttag:           `json:\"json_8\" xml \"xml_8\"`,\n-\t\t\tkey:           \"xml\",\n-\t\t\texpectedValue: \"\",\n-\t\t\texpectedOK:    false,\n-\t\t},\n-\t\t{\n-\t\t\ttag:           `json    bson    xml    form \"form_9\" other:\"value_9\"`,\n-\t\t\tkey:           \"bson\",\n-\t\t\texpectedValue: \"\",\n-\t\t\texpectedOK:    false,\n-\t\t},\n-\t\t{\n-\t\t\ttag:           `json bson xml form \"form_10\" other:\"value_10\"`,\n-\t\t\tkey:           \"other\",\n-\t\t\texpectedValue: \"\",\n-\t\t\texpectedOK:    false,\n-\t\t},\n-\t\t{\n-\t\t\ttag:           `json bson xml form:\"form_11\" other \"value_11\"`,\n-\t\t\tkey:           \"json\",\n-\t\t\texpectedValue: \"form_11\",\n-\t\t\texpectedOK:    true,\n-\t\t},\n-\t\t{\n-\t\t\ttag:           `tag1`,\n-\t\t\tkey:           \"tag1\",\n-\t\t\texpectedValue: \"\",\n-\t\t\texpectedOK:    false,\n-\t\t},\n-\t\t{\n-\t\t\ttag:           `tag2 :\"hello_2\"`,\n-\t\t\tkey:           \"tag2\",\n-\t\t\texpectedValue: \"\",\n-\t\t\texpectedOK:    false,\n-\t\t},\n-\t\t{\n-\t\t\ttag:           `tag3: \"hello_3\"`,\n-\t\t\tkey:           \"tag3\",\n-\t\t\texpectedValue: \"\",\n-\t\t\texpectedOK:    false,\n-\t\t},\n-\t\t{\n-\t\t\ttag:           \"json\\x7fbson: \\\"hello_4\\\"\",\n-\t\t\tkey:           \"json\",\n-\t\t\texpectedValue: \"\",\n-\t\t\texpectedOK:    false,\n-\t\t},\n-\t\t{\n-\t\t\ttag:           \"json\\x7fbson: \\\"hello_5\\\"\",\n-\t\t\tkey:           \"bson\",\n-\t\t\texpectedValue: \"\",\n-\t\t\texpectedOK:    false,\n-\t\t},\n-\t\t{\n-\t\t\ttag:           \"json bson:\\x7f\\\"hello_6\\\"\",\n-\t\t\tkey:           \"json\",\n-\t\t\texpectedValue: \"\",\n-\t\t\texpectedOK:    false,\n-\t\t},\n-\t\t{\n-\t\t\ttag:           \"json bson:\\x7f\\\"hello_7\\\"\",\n-\t\t\tkey:           \"bson\",\n-\t\t\texpectedValue: \"\",\n-\t\t\texpectedOK:    false,\n-\t\t},\n-\t\t{\n-\t\t\ttag:           \"json\\x09bson:\\\"hello_8\\\"\",\n-\t\t\tkey:           \"json\",\n-\t\t\texpectedValue: \"\",\n-\t\t\texpectedOK:    false,\n-\t\t},\n-\t\t{\n-\t\t\ttag:           \"a\\x7fb json:\\\"val\\\"\",\n-\t\t\tkey:           \"json\",\n-\t\t\texpectedValue: \"\",\n-\t\t\texpectedOK:    false,\n-\t\t},\n-\t}\n-\n-\tfor _, test := range tests {\n-\t\tv, ok := test.tag.Lookup(test.key)\n-\t\tif v != test.expectedValue {\n-\t\t\tt.Errorf(\"struct tag lookup failed, got %s, want %s\", v, test.expectedValue)\n-\t\t}\n-\t\tif ok != test.expectedOK {\n-\t\t\tt.Errorf(\"struct tag lookup failed, got %t, want %t\", ok, test.expectedOK)\n-\t\t}\n-\t}\n-}\n-\n // iterateToString returns the set of elements\n // returned by an iterator in readable form.\n func iterateToString(it *MapIter) string {"}, {"sha": "c05ec6872edc381d365d1a7e63180fff8cc58bda", "filename": "libgo/go/reflect/type.go", "status": "modified", "additions": 9, "deletions": 34, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Freflect%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Freflect%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Ftype.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -842,16 +842,12 @@ type StructField struct {\n \n // A StructTag is the tag string in a struct field.\n //\n-// By convention, tag strings are a mapping of keys to values.\n-// The format is key:\"value\". Each key is a non-empty string consisting\n-// of non-control characters other than space (U+0020 ' '),\n-// quote (U+0022 '\"'), and colon (U+003A ':'). Each value is quoted\n-// using U+0022 '\"' characters and Go string literal syntax.\n-// Multiple key-value mappings are separated by zero or more spaces, as in\n-//   key1:\"value1\" key2:\"value2\"\n-// Multiple keys may map to a single shared value by separating the keys\n-// with spaces, as in\n-//   key1 key2:\"value\"\n+// By convention, tag strings are a concatenation of\n+// optionally space-separated key:\"value\" pairs.\n+// Each key is a non-empty string consisting of non-control\n+// characters other than space (U+0020 ' '), quote (U+0022 '\"'),\n+// and colon (U+003A ':').  Each value is quoted using U+0022 '\"'\n+// characters and Go string literal syntax.\n type StructTag string\n \n // Get returns the value associated with key in the tag string.\n@@ -874,9 +870,6 @@ func (tag StructTag) Lookup(key string) (value string, ok bool) {\n \t// When modifying this code, also update the validateStructTag code\n \t// in cmd/vet/structtag.go.\n \n-\t// keyFound indicates that such key on the left side has already been found.\n-\tvar keyFound bool\n-\n \tfor tag != \"\" {\n \t\t// Skip leading space.\n \t\ti := 0\n@@ -896,29 +889,11 @@ func (tag StructTag) Lookup(key string) (value string, ok bool) {\n \t\tfor i < len(tag) && tag[i] > ' ' && tag[i] != ':' && tag[i] != '\"' && tag[i] != 0x7f {\n \t\t\ti++\n \t\t}\n-\t\tif i == 0 || i+1 >= len(tag) || tag[i] < ' ' || tag[i] == 0x7f {\n+\t\tif i == 0 || i+1 >= len(tag) || tag[i] != ':' || tag[i+1] != '\"' {\n \t\t\tbreak\n \t\t}\n \t\tname := string(tag[:i])\n-\t\ttag = tag[i:]\n-\n-\t\t// If we found a space char here - assume that we have a tag with\n-\t\t// multiple keys.\n-\t\tif tag[0] == ' ' {\n-\t\t\tif name == key {\n-\t\t\t\tkeyFound = true\n-\t\t\t}\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\t// Spaces were filtered above so we assume that here we have\n-\t\t// only valid tag value started with `:\"`.\n-\t\tif tag[0] != ':' || tag[1] != '\"' {\n-\t\t\tbreak\n-\t\t}\n-\n-\t\t// Remove the colon leaving tag at the start of the quoted string.\n-\t\ttag = tag[1:]\n+\t\ttag = tag[i+1:]\n \n \t\t// Scan quoted string to find value.\n \t\ti = 1\n@@ -934,7 +909,7 @@ func (tag StructTag) Lookup(key string) (value string, ok bool) {\n \t\tqvalue := string(tag[:i+1])\n \t\ttag = tag[i+1:]\n \n-\t\tif key == name || keyFound {\n+\t\tif key == name {\n \t\t\tvalue, err := strconv.Unquote(qvalue)\n \t\t\tif err != nil {\n \t\t\t\tbreak"}, {"sha": "102b1a5f476ee892bee72733cddb423ed67bc6bf", "filename": "libgo/go/runtime/crash_test.go", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fcrash_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fcrash_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcrash_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -297,6 +297,18 @@ func TestRecursivePanic4(t *testing.T) {\n \n }\n \n+func TestRecursivePanic5(t *testing.T) {\n+\toutput := runTestProg(t, \"testprog\", \"RecursivePanic5\")\n+\twant := `first panic\n+second panic\n+panic: third panic\n+`\n+\tif !strings.HasPrefix(output, want) {\n+\t\tt.Fatalf(\"output does not start with %q:\\n%s\", want, output)\n+\t}\n+\n+}\n+\n func TestGoexitCrash(t *testing.T) {\n \t// External linking brings in cgo, causing deadlock detection not working.\n \ttestenv.MustInternalLink(t)"}, {"sha": "9a40ea19842faf029d6a2502c38c15fedddb1f52", "filename": "libgo/go/runtime/defer_test.go", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fdefer_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fdefer_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fdefer_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -410,3 +410,31 @@ func rec1(max int) {\n \t\trec1(max - 1)\n \t}\n }\n+\n+func TestIssue43921(t *testing.T) {\n+\tdefer func() {\n+\t\texpect(t, 1, recover())\n+\t}()\n+\tfunc() {\n+\t\t// Prevent open-coded defers\n+\t\tfor {\n+\t\t\tdefer func() {}()\n+\t\t\tbreak\n+\t\t}\n+\n+\t\tdefer func() {\n+\t\t\tdefer func() {\n+\t\t\t\texpect(t, 4, recover())\n+\t\t\t}()\n+\t\t\tpanic(4)\n+\t\t}()\n+\t\tpanic(1)\n+\n+\t}()\n+}\n+\n+func expect(t *testing.T, n int, err interface{}) {\n+\tif n != err {\n+\t\tt.Fatalf(\"have %v, want %v\", err, n)\n+\t}\n+}"}, {"sha": "1455c2247d8a295d5b022f0f28655df695014119", "filename": "libgo/go/runtime/export_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fexport_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -1195,12 +1195,12 @@ type TimeHistogram timeHistogram\n \n // Counts returns the counts for the given bucket, subBucket indices.\n // Returns true if the bucket was valid, otherwise returns the counts\n-// for the overflow bucket and false.\n+// for the underflow bucket and false.\n func (th *TimeHistogram) Count(bucket, subBucket uint) (uint64, bool) {\n \tt := (*timeHistogram)(th)\n \ti := bucket*TimeHistNumSubBuckets + subBucket\n \tif i >= uint(len(t.counts)) {\n-\t\treturn t.overflow, false\n+\t\treturn t.underflow, false\n \t}\n \treturn t.counts[i], true\n }"}, {"sha": "42baa6c5e2c0df3765e21e307bfdc4c1c808a92d", "filename": "libgo/go/runtime/histogram.go", "status": "modified", "additions": 42, "deletions": 18, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fhistogram.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fhistogram.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fhistogram.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -7,6 +7,7 @@ package runtime\n import (\n \t\"runtime/internal/atomic\"\n \t\"runtime/internal/sys\"\n+\t\"unsafe\"\n )\n \n const (\n@@ -69,17 +70,21 @@ const (\n // for concurrent use. It is also safe to read all the values\n // atomically.\n type timeHistogram struct {\n-\tcounts   [timeHistNumSuperBuckets * timeHistNumSubBuckets]uint64\n-\toverflow uint64\n+\tcounts [timeHistNumSuperBuckets * timeHistNumSubBuckets]uint64\n+\n+\t// underflow counts all the times we got a negative duration\n+\t// sample. Because of how time works on some platforms, it's\n+\t// possible to measure negative durations. We could ignore them,\n+\t// but we record them anyway because it's better to have some\n+\t// signal that it's happening than just missing samples.\n+\tunderflow uint64\n }\n \n // record adds the given duration to the distribution.\n-//\n-// Although the duration is an int64 to facilitate ease-of-use\n-// with e.g. nanotime, the duration must be non-negative.\n func (h *timeHistogram) record(duration int64) {\n \tif duration < 0 {\n-\t\tthrow(\"timeHistogram encountered negative duration\")\n+\t\tatomic.Xadd64(&h.underflow, 1)\n+\t\treturn\n \t}\n \t// The index of the exponential bucket is just the index\n \t// of the highest set bit adjusted for how many bits we\n@@ -92,29 +97,47 @@ func (h *timeHistogram) record(duration int64) {\n \t\tsuperBucket = uint(sys.Len64(uint64(duration))) - timeHistSubBucketBits\n \t\tif superBucket*timeHistNumSubBuckets >= uint(len(h.counts)) {\n \t\t\t// The bucket index we got is larger than what we support, so\n-\t\t\t// add into the special overflow bucket.\n-\t\t\tatomic.Xadd64(&h.overflow, 1)\n-\t\t\treturn\n+\t\t\t// include this count in the highest bucket, which extends to\n+\t\t\t// infinity.\n+\t\t\tsuperBucket = timeHistNumSuperBuckets - 1\n+\t\t\tsubBucket = timeHistNumSubBuckets - 1\n+\t\t} else {\n+\t\t\t// The linear subbucket index is just the timeHistSubBucketsBits\n+\t\t\t// bits after the top bit. To extract that value, shift down\n+\t\t\t// the duration such that we leave the top bit and the next bits\n+\t\t\t// intact, then extract the index.\n+\t\t\tsubBucket = uint((duration >> (superBucket - 1)) % timeHistNumSubBuckets)\n \t\t}\n-\t\t// The linear subbucket index is just the timeHistSubBucketsBits\n-\t\t// bits after the top bit. To extract that value, shift down\n-\t\t// the duration such that we leave the top bit and the next bits\n-\t\t// intact, then extract the index.\n-\t\tsubBucket = uint((duration >> (superBucket - 1)) % timeHistNumSubBuckets)\n \t} else {\n \t\tsubBucket = uint(duration)\n \t}\n \tatomic.Xadd64(&h.counts[superBucket*timeHistNumSubBuckets+subBucket], 1)\n }\n \n+const (\n+\tfInf    = 0x7FF0000000000000\n+\tfNegInf = 0xFFF0000000000000\n+)\n+\n+func float64Inf() float64 {\n+\tinf := uint64(fInf)\n+\treturn *(*float64)(unsafe.Pointer(&inf))\n+}\n+\n+func float64NegInf() float64 {\n+\tinf := uint64(fNegInf)\n+\treturn *(*float64)(unsafe.Pointer(&inf))\n+}\n+\n // timeHistogramMetricsBuckets generates a slice of boundaries for\n // the timeHistogram. These boundaries are represented in seconds,\n // not nanoseconds like the timeHistogram represents durations.\n func timeHistogramMetricsBuckets() []float64 {\n-\tb := make([]float64, timeHistTotalBuckets-1)\n+\tb := make([]float64, timeHistTotalBuckets+1)\n+\tb[0] = float64NegInf()\n \tfor i := 0; i < timeHistNumSuperBuckets; i++ {\n \t\tsuperBucketMin := uint64(0)\n-\t\t// The (inclusive) minimum for the first bucket is 0.\n+\t\t// The (inclusive) minimum for the first non-negative bucket is 0.\n \t\tif i > 0 {\n \t\t\t// The minimum for the second bucket will be\n \t\t\t// 1 << timeHistSubBucketBits, indicating that all\n@@ -128,7 +151,7 @@ func timeHistogramMetricsBuckets() []float64 {\n \t\t// index to combine it with the bucketMin.\n \t\tsubBucketShift := uint(0)\n \t\tif i > 1 {\n-\t\t\t// The first two buckets are exact with respect to integers,\n+\t\t\t// The first two super buckets are exact with respect to integers,\n \t\t\t// so we'll never have to shift the sub-bucket index. Thereafter,\n \t\t\t// we shift up by 1 with each subsequent bucket.\n \t\t\tsubBucketShift = uint(i - 2)\n@@ -141,8 +164,9 @@ func timeHistogramMetricsBuckets() []float64 {\n \n \t\t\t// Convert the subBucketMin which is in nanoseconds to a float64 seconds value.\n \t\t\t// These values will all be exactly representable by a float64.\n-\t\t\tb[i*timeHistNumSubBuckets+j] = float64(subBucketMin) / 1e9\n+\t\t\tb[i*timeHistNumSubBuckets+j+1] = float64(subBucketMin) / 1e9\n \t\t}\n \t}\n+\tb[len(b)-1] = float64Inf()\n \treturn b\n }"}, {"sha": "dbc64fa5592407bc728a5f0c1d70d30048e2b0b6", "filename": "libgo/go/runtime/histogram_test.go", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fhistogram_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fhistogram_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fhistogram_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -5,6 +5,7 @@\n package runtime_test\n \n import (\n+\t\"math\"\n \t. \"runtime\"\n \t\"testing\"\n )\n@@ -32,27 +33,38 @@ func TestTimeHistogram(t *testing.T) {\n \t\t\th.Record(base + v)\n \t\t}\n \t}\n-\t// Hit the overflow bucket.\n-\th.Record(int64(^uint64(0) >> 1))\n+\t// Hit the underflow bucket.\n+\th.Record(int64(-1))\n \n \t// Check to make sure there's exactly one count in each\n \t// bucket.\n \tfor i := uint(0); i < TimeHistNumSuperBuckets; i++ {\n \t\tfor j := uint(0); j < TimeHistNumSubBuckets; j++ {\n \t\t\tc, ok := h.Count(i, j)\n \t\t\tif !ok {\n-\t\t\t\tt.Errorf(\"hit overflow bucket unexpectedly: (%d, %d)\", i, j)\n+\t\t\t\tt.Errorf(\"hit underflow bucket unexpectedly: (%d, %d)\", i, j)\n \t\t\t} else if c != 1 {\n \t\t\t\tt.Errorf(\"bucket (%d, %d) has count that is not 1: %d\", i, j, c)\n \t\t\t}\n \t\t}\n \t}\n \tc, ok := h.Count(TimeHistNumSuperBuckets, 0)\n \tif ok {\n-\t\tt.Errorf(\"expected to hit overflow bucket: (%d, %d)\", TimeHistNumSuperBuckets, 0)\n+\t\tt.Errorf(\"expected to hit underflow bucket: (%d, %d)\", TimeHistNumSuperBuckets, 0)\n \t}\n \tif c != 1 {\n-\t\tt.Errorf(\"overflow bucket has count that is not 1: %d\", c)\n+\t\tt.Errorf(\"underflow bucket has count that is not 1: %d\", c)\n \t}\n+\n+\t// Check overflow behavior.\n+\t// By hitting a high value, we should just be adding into the highest bucket.\n+\th.Record(math.MaxInt64)\n+\tc, ok = h.Count(TimeHistNumSuperBuckets-1, TimeHistNumSubBuckets-1)\n+\tif !ok {\n+\t\tt.Error(\"hit underflow bucket in highest bucket unexpectedly\")\n+\t} else if c != 2 {\n+\t\tt.Errorf(\"highest has count that is not 2: %d\", c)\n+\t}\n+\n \tdummyTimeHistogram = TimeHistogram{}\n }"}, {"sha": "e1f1db2dba32dfe53b58bc3de6f9d98cc1a6bfff", "filename": "libgo/go/runtime/metrics.go", "status": "modified", "additions": 39, "deletions": 14, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fmetrics.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fmetrics.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmetrics.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -41,10 +41,28 @@ func initMetrics() {\n \tif metricsInit {\n \t\treturn\n \t}\n-\tsizeClassBuckets = make([]float64, _NumSizeClasses)\n-\tfor i := range sizeClassBuckets {\n-\t\tsizeClassBuckets[i] = float64(class_to_size[i])\n+\n+\tsizeClassBuckets = make([]float64, _NumSizeClasses, _NumSizeClasses+1)\n+\t// Skip size class 0 which is a stand-in for large objects, but large\n+\t// objects are tracked separately (and they actually get placed in\n+\t// the last bucket, not the first).\n+\tsizeClassBuckets[0] = 1 // The smallest allocation is 1 byte in size.\n+\tfor i := 1; i < _NumSizeClasses; i++ {\n+\t\t// Size classes have an inclusive upper-bound\n+\t\t// and exclusive lower bound (e.g. 48-byte size class is\n+\t\t// (32, 48]) whereas we want and inclusive lower-bound\n+\t\t// and exclusive upper-bound (e.g. 48-byte size class is\n+\t\t// [33, 49). We can achieve this by shifting all bucket\n+\t\t// boundaries up by 1.\n+\t\t//\n+\t\t// Also, a float64 can precisely represent integers with\n+\t\t// value up to 2^53 and size classes are relatively small\n+\t\t// (nowhere near 2^48 even) so this will give us exact\n+\t\t// boundaries.\n+\t\tsizeClassBuckets[i] = float64(class_to_size[i] + 1)\n \t}\n+\tsizeClassBuckets = append(sizeClassBuckets, float64Inf())\n+\n \ttimeHistBuckets = timeHistogramMetricsBuckets()\n \tmetrics = map[string]metricData{\n \t\t\"/gc/cycles/automatic:gc-cycles\": {\n@@ -68,23 +86,27 @@ func initMetrics() {\n \t\t\t\tout.scalar = in.sysStats.gcCyclesDone\n \t\t\t},\n \t\t},\n-\t\t\"/gc/heap/allocs-by-size:objects\": {\n+\t\t\"/gc/heap/allocs-by-size:bytes\": {\n \t\t\tdeps: makeStatDepSet(heapStatsDep),\n \t\t\tcompute: func(in *statAggregate, out *metricValue) {\n \t\t\t\thist := out.float64HistOrInit(sizeClassBuckets)\n \t\t\t\thist.counts[len(hist.counts)-1] = uint64(in.heapStats.largeAllocCount)\n-\t\t\t\tfor i := range hist.buckets {\n-\t\t\t\t\thist.counts[i] = uint64(in.heapStats.smallAllocCount[i])\n+\t\t\t\t// Cut off the first index which is ostensibly for size class 0,\n+\t\t\t\t// but large objects are tracked separately so it's actually unused.\n+\t\t\t\tfor i, count := range in.heapStats.smallAllocCount[1:] {\n+\t\t\t\t\thist.counts[i] = uint64(count)\n \t\t\t\t}\n \t\t\t},\n \t\t},\n-\t\t\"/gc/heap/frees-by-size:objects\": {\n+\t\t\"/gc/heap/frees-by-size:bytes\": {\n \t\t\tdeps: makeStatDepSet(heapStatsDep),\n \t\t\tcompute: func(in *statAggregate, out *metricValue) {\n \t\t\t\thist := out.float64HistOrInit(sizeClassBuckets)\n \t\t\t\thist.counts[len(hist.counts)-1] = uint64(in.heapStats.largeFreeCount)\n-\t\t\t\tfor i := range hist.buckets {\n-\t\t\t\t\thist.counts[i] = uint64(in.heapStats.smallFreeCount[i])\n+\t\t\t\t// Cut off the first index which is ostensibly for size class 0,\n+\t\t\t\t// but large objects are tracked separately so it's actually unused.\n+\t\t\t\tfor i, count := range in.heapStats.smallFreeCount[1:] {\n+\t\t\t\t\thist.counts[i] = uint64(count)\n \t\t\t\t}\n \t\t\t},\n \t\t},\n@@ -105,9 +127,12 @@ func initMetrics() {\n \t\t\"/gc/pauses:seconds\": {\n \t\t\tcompute: func(_ *statAggregate, out *metricValue) {\n \t\t\t\thist := out.float64HistOrInit(timeHistBuckets)\n-\t\t\t\thist.counts[len(hist.counts)-1] = atomic.Load64(&memstats.gcPauseDist.overflow)\n-\t\t\t\tfor i := range hist.buckets {\n-\t\t\t\t\thist.counts[i] = atomic.Load64(&memstats.gcPauseDist.counts[i])\n+\t\t\t\t// The bottom-most bucket, containing negative values, is tracked\n+\t\t\t\t// as a separately as underflow, so fill that in manually and then\n+\t\t\t\t// iterate over the rest.\n+\t\t\t\thist.counts[0] = atomic.Load64(&memstats.gcPauseDist.underflow)\n+\t\t\t\tfor i := range memstats.gcPauseDist.counts {\n+\t\t\t\t\thist.counts[i+1] = atomic.Load64(&memstats.gcPauseDist.counts[i])\n \t\t\t\t}\n \t\t\t},\n \t\t},\n@@ -426,8 +451,8 @@ func (v *metricValue) float64HistOrInit(buckets []float64) *metricFloat64Histogr\n \t\tv.pointer = unsafe.Pointer(hist)\n \t}\n \thist.buckets = buckets\n-\tif len(hist.counts) != len(hist.buckets)+1 {\n-\t\thist.counts = make([]uint64, len(buckets)+1)\n+\tif len(hist.counts) != len(hist.buckets)-1 {\n+\t\thist.counts = make([]uint64, len(buckets)-1)\n \t}\n \treturn hist\n }"}, {"sha": "117515610436f2a27145a79f589400d8076e14b3", "filename": "libgo/go/runtime/metrics/description.go", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fmetrics%2Fdescription.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fmetrics%2Fdescription.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmetrics%2Fdescription.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -23,6 +23,11 @@ type Description struct {\n \t// Examples of units might be \"seconds\", \"bytes\", \"bytes/second\", \"cpu-seconds\",\n \t// \"byte*cpu-seconds\", and \"bytes/second/second\".\n \t//\n+\t// For histograms, multiple units may apply. For instance, the units of the buckets and\n+\t// the count. By convention, for histograms, the units of the count are always \"samples\"\n+\t// with the type of sample evident by the metric's name, while the unit in the name\n+\t// specifies the buckets' unit.\n+\t//\n \t// A complete name might look like \"/memory/heap/free:bytes\".\n \tName string\n \n@@ -41,10 +46,6 @@ type Description struct {\n \t//\n \t// This flag thus indicates whether or not it's useful to compute a rate from this value.\n \tCumulative bool\n-\n-\t// StopTheWorld is whether or not the metric requires a stop-the-world\n-\t// event in order to collect it.\n-\tStopTheWorld bool\n }\n \n // The English language descriptions below must be kept in sync with the\n@@ -69,14 +70,16 @@ var allDesc = []Description{\n \t\tCumulative:  true,\n \t},\n \t{\n-\t\tName:        \"/gc/heap/allocs-by-size:objects\",\n+\t\tName:        \"/gc/heap/allocs-by-size:bytes\",\n \t\tDescription: \"Distribution of all objects allocated by approximate size.\",\n \t\tKind:        KindFloat64Histogram,\n+\t\tCumulative:  true,\n \t},\n \t{\n-\t\tName:        \"/gc/heap/frees-by-size:objects\",\n+\t\tName:        \"/gc/heap/frees-by-size:bytes\",\n \t\tDescription: \"Distribution of all objects freed by approximate size.\",\n \t\tKind:        KindFloat64Histogram,\n+\t\tCumulative:  true,\n \t},\n \t{\n \t\tName:        \"/gc/heap/goal:bytes\",\n@@ -92,6 +95,7 @@ var allDesc = []Description{\n \t\tName:        \"/gc/pauses:seconds\",\n \t\tDescription: \"Distribution individual GC-related stop-the-world pause latencies.\",\n \t\tKind:        KindFloat64Histogram,\n+\t\tCumulative:  true,\n \t},\n \t{\n \t\tName: \"/memory/classes/heap/free:bytes\","}, {"sha": "021a0bddcaf3527b85a60a6e35bd807ad33f6c5e", "filename": "libgo/go/runtime/metrics/doc.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fmetrics%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fmetrics%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmetrics%2Fdoc.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -61,10 +61,10 @@ Below is the full list of supported metrics, ordered lexicographically.\n \t/gc/cycles/total:gc-cycles\n \t\tCount of all completed GC cycles.\n \n-\t/gc/heap/allocs-by-size:objects\n+\t/gc/heap/allocs-by-size:bytes\n \t\tDistribution of all objects allocated by approximate size.\n \n-\t/gc/heap/frees-by-size:objects\n+\t/gc/heap/frees-by-size:bytes\n \t\tDistribution of all objects freed by approximate size.\n \n \t/gc/heap/goal:bytes"}, {"sha": "cade0c38bfde62c046d3e7c9332cff9163b4c23b", "filename": "libgo/go/runtime/metrics/example_test.go", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fmetrics%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fmetrics%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmetrics%2Fexample_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -0,0 +1,96 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package metrics_test\n+\n+import (\n+\t\"fmt\"\n+\t\"runtime/metrics\"\n+)\n+\n+func ExampleRead_readingOneMetric() {\n+\t// Name of the metric we want to read.\n+\tconst myMetric = \"/memory/classes/heap/free:bytes\"\n+\n+\t// Create a sample for the metric.\n+\tsample := make([]metrics.Sample, 1)\n+\tsample[0].Name = myMetric\n+\n+\t// Sample the metric.\n+\tmetrics.Read(sample)\n+\n+\t// Check if the metric is actually supported.\n+\t// If it's not, the resulting value will always have\n+\t// kind KindBad.\n+\tif sample[0].Value.Kind() == metrics.KindBad {\n+\t\tpanic(fmt.Sprintf(\"metric %q no longer supported\", myMetric))\n+\t}\n+\n+\t// Handle the result.\n+\t//\n+\t// It's OK to assume a particular Kind for a metric;\n+\t// they're guaranteed not to change.\n+\tfreeBytes := sample[0].Value.Uint64()\n+\n+\tfmt.Printf(\"free but not released memory: %d\\n\", freeBytes)\n+}\n+\n+func ExampleRead_readingAllMetrics() {\n+\t// Get descriptions for all supported metrics.\n+\tdescs := metrics.All()\n+\n+\t// Create a sample for each metric.\n+\tsamples := make([]metrics.Sample, len(descs))\n+\tfor i := range samples {\n+\t\tsamples[i].Name = descs[i].Name\n+\t}\n+\n+\t// Sample the metrics. Re-use the samples slice if you can!\n+\tmetrics.Read(samples)\n+\n+\t// Iterate over all results.\n+\tfor _, sample := range samples {\n+\t\t// Pull out the name and value.\n+\t\tname, value := sample.Name, sample.Value\n+\n+\t\t// Handle each sample.\n+\t\tswitch value.Kind() {\n+\t\tcase metrics.KindUint64:\n+\t\t\tfmt.Printf(\"%s: %d\\n\", name, value.Uint64())\n+\t\tcase metrics.KindFloat64:\n+\t\t\tfmt.Printf(\"%s: %f\\n\", name, value.Float64())\n+\t\tcase metrics.KindFloat64Histogram:\n+\t\t\t// The histogram may be quite large, so let's just pull out\n+\t\t\t// a crude estimate for the median for the sake of this example.\n+\t\t\tfmt.Printf(\"%s: %f\\n\", name, medianBucket(value.Float64Histogram()))\n+\t\tcase metrics.KindBad:\n+\t\t\t// This should never happen because all metrics are supported\n+\t\t\t// by construction.\n+\t\t\tpanic(\"bug in runtime/metrics package!\")\n+\t\tdefault:\n+\t\t\t// This may happen as new metrics get added.\n+\t\t\t//\n+\t\t\t// The safest thing to do here is to simply log it somewhere\n+\t\t\t// as something to look into, but ignore it for now.\n+\t\t\t// In the worst case, you might temporarily miss out on a new metric.\n+\t\t\tfmt.Printf(\"%s: unexpected metric Kind: %v\\n\", name, value.Kind())\n+\t\t}\n+\t}\n+}\n+\n+func medianBucket(h *metrics.Float64Histogram) float64 {\n+\ttotal := uint64(0)\n+\tfor _, count := range h.Counts {\n+\t\ttotal += count\n+\t}\n+\tthresh := total / 2\n+\ttotal = 0\n+\tfor i, count := range h.Counts {\n+\t\ttotal += count\n+\t\tif total > thresh {\n+\t\t\treturn h.Buckets[i]\n+\t\t}\n+\t}\n+\tpanic(\"should not happen\")\n+}"}, {"sha": "956422bf84ea250d6c3c5c533d6be5b3990685c5", "filename": "libgo/go/runtime/metrics/histogram.go", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fmetrics%2Fhistogram.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fmetrics%2Fhistogram.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmetrics%2Fhistogram.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -6,25 +6,28 @@ package metrics\n \n // Float64Histogram represents a distribution of float64 values.\n type Float64Histogram struct {\n-\t// Counts contains the weights for each histogram bucket. The length of\n-\t// Counts is equal to the length of Buckets (in the metric description)\n-\t// plus one to account for the implicit minimum bucket.\n+\t// Counts contains the weights for each histogram bucket.\n \t//\n-\t// Given N buckets, the following is the mathematical relationship between\n-\t// Counts and Buckets.\n-\t// count[0] is the weight of the range (-inf, bucket[0])\n-\t// count[n] is the weight of the range [bucket[n], bucket[n+1]), for 0 < n < N-1\n-\t// count[N-1] is the weight of the range [bucket[N-1], inf)\n+\t// Given N buckets, Count[n] is the weight of the range\n+\t// [bucket[n], bucket[n+1]), for 0 <= n < N.\n \tCounts []uint64\n \n-\t// Buckets contains the boundaries between histogram buckets, in increasing order.\n+\t// Buckets contains the boundaries of the histogram buckets, in increasing order.\n \t//\n-\t// Because this slice contains boundaries, there are len(Buckets)+1 counts:\n-\t// a count for all values less than the first boundary, a count covering each\n-\t// [slice[i], slice[i+1]) interval, and a count for all values greater than or\n-\t// equal to the last boundary.\n+\t// Buckets[0] is the inclusive lower bound of the minimum bucket while\n+\t// Buckets[len(Buckets)-1] is the exclusive upper bound of the maximum bucket.\n+\t// Hence, there are len(Buckets)-1 counts. Furthermore, len(Buckets) != 1, always,\n+\t// since at least two boundaries are required to describe one bucket (and 0\n+\t// boundaries are used to describe 0 buckets).\n+\t//\n+\t// Buckets[0] is permitted to have value -Inf and Buckets[len(Buckets)-1] is\n+\t// permitted to have value Inf.\n \t//\n \t// For a given metric name, the value of Buckets is guaranteed not to change\n \t// between calls until program exit.\n+\t//\n+\t// This slice value is permitted to alias with other Float64Histograms' Buckets\n+\t// fields, so the values within should only ever be read. If they need to be\n+\t// modified, the user must make a copy.\n \tBuckets []float64\n }"}, {"sha": "61e8a192a30d424b6cf57ddd58e73b769f073c2e", "filename": "libgo/go/runtime/metrics/value.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fmetrics%2Fvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fmetrics%2Fvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmetrics%2Fvalue.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -63,7 +63,7 @@ func (v Value) Float64() float64 {\n // If v.Kind() != KindFloat64Histogram, this method panics.\n func (v Value) Float64Histogram() *Float64Histogram {\n \tif v.kind != KindFloat64Histogram {\n-\t\tpanic(\"called Float64 on non-float64 metric value\")\n+\t\tpanic(\"called Float64Histogram on non-Float64Histogram metric value\")\n \t}\n \treturn (*Float64Histogram)(v.pointer)\n }"}, {"sha": "8a3cf019bdb474155b6daee86eee14d9cad00b39", "filename": "libgo/go/runtime/metrics_test.go", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fmetrics_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fmetrics_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmetrics_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -70,6 +70,34 @@ func TestReadMetrics(t *testing.T) {\n \t\t\tcheckUint64(t, name, samples[i].Value.Uint64(), mstats.BuckHashSys)\n \t\tcase \"/memory/classes/total:bytes\":\n \t\t\tcheckUint64(t, name, samples[i].Value.Uint64(), mstats.Sys)\n+\t\tcase \"/gc/heap/allocs-by-size:bytes\":\n+\t\t\thist := samples[i].Value.Float64Histogram()\n+\t\t\t// Skip size class 0 in BySize, because it's always empty and not represented\n+\t\t\t// in the histogram.\n+\t\t\tfor i, sc := range mstats.BySize[1:] {\n+\t\t\t\tif b, s := hist.Buckets[i+1], float64(sc.Size+1); b != s {\n+\t\t\t\t\tt.Errorf(\"bucket does not match size class: got %f, want %f\", b, s)\n+\t\t\t\t\t// The rest of the checks aren't expected to work anyway.\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tif c, m := hist.Counts[i], sc.Mallocs; c != m {\n+\t\t\t\t\tt.Errorf(\"histogram counts do not much BySize for class %d: got %d, want %d\", i, c, m)\n+\t\t\t\t}\n+\t\t\t}\n+\t\tcase \"/gc/heap/frees-by-size:bytes\":\n+\t\t\thist := samples[i].Value.Float64Histogram()\n+\t\t\t// Skip size class 0 in BySize, because it's always empty and not represented\n+\t\t\t// in the histogram.\n+\t\t\tfor i, sc := range mstats.BySize[1:] {\n+\t\t\t\tif b, s := hist.Buckets[i+1], float64(sc.Size+1); b != s {\n+\t\t\t\t\tt.Errorf(\"bucket does not match size class: got %f, want %f\", b, s)\n+\t\t\t\t\t// The rest of the checks aren't expected to work anyway.\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tif c, f := hist.Counts[i], sc.Frees; c != f {\n+\t\t\t\t\tt.Errorf(\"histogram counts do not much BySize for class %d: got %d, want %d\", i, c, f)\n+\t\t\t\t}\n+\t\t\t}\n \t\tcase \"/gc/heap/objects:objects\":\n \t\t\tcheckUint64(t, name, samples[i].Value.Uint64(), mstats.HeapObjects)\n \t\tcase \"/gc/heap/goal:bytes\":\n@@ -133,9 +161,9 @@ func TestReadMetricsConsistency(t *testing.T) {\n \t\t\ttotalVirtual.got = samples[i].Value.Uint64()\n \t\tcase \"/gc/heap/objects:objects\":\n \t\t\tobjects.total = samples[i].Value.Uint64()\n-\t\tcase \"/gc/heap/allocs-by-size:objects\":\n+\t\tcase \"/gc/heap/allocs-by-size:bytes\":\n \t\t\tobjects.alloc = samples[i].Value.Float64Histogram()\n-\t\tcase \"/gc/heap/frees-by-size:objects\":\n+\t\tcase \"/gc/heap/frees-by-size:bytes\":\n \t\t\tobjects.free = samples[i].Value.Float64Histogram()\n \t\tcase \"/gc/cycles:gc-cycles\":\n \t\t\tgc.numGC = samples[i].Value.Uint64()\n@@ -154,6 +182,12 @@ func TestReadMetricsConsistency(t *testing.T) {\n \tif totalVirtual.got != totalVirtual.want {\n \t\tt.Errorf(`\"/memory/classes/total:bytes\" does not match sum of /memory/classes/**: got %d, want %d`, totalVirtual.got, totalVirtual.want)\n \t}\n+\tif b, c := len(objects.alloc.Buckets), len(objects.alloc.Counts); b != c+1 {\n+\t\tt.Errorf(\"allocs-by-size has wrong bucket or counts length: %d buckets, %d counts\", b, c)\n+\t}\n+\tif b, c := len(objects.free.Buckets), len(objects.free.Counts); b != c+1 {\n+\t\tt.Errorf(\"frees-by-size has wrong bucket or counts length: %d buckets, %d counts\", b, c)\n+\t}\n \tif len(objects.alloc.Buckets) != len(objects.free.Buckets) {\n \t\tt.Error(\"allocs-by-size and frees-by-size buckets don't match in length\")\n \t} else if len(objects.alloc.Counts) != len(objects.free.Counts) {"}, {"sha": "e5581255bb9acb0c6f00ccf0795b06623c4a05b4", "filename": "libgo/go/runtime/mgcmark.go", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fmgcmark.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fmgcmark.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmgcmark.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -87,8 +87,7 @@ func gcMarkRootPrepare() {\n \t// Gs may be created after this point, but it's okay that we\n \t// ignore them because they begin life without any roots, so\n \t// there's nothing to scan, and any roots they create during\n-\t// the concurrent phase will be scanned during mark\n-\t// termination.\n+\t// the concurrent phase will be caught by the write barrier.\n \twork.nStackRoots = int(atomic.Loaduintptr(&allglen))\n \n \twork.markrootNext = 0\n@@ -119,7 +118,6 @@ fail:\n \tprintln(\"gp\", gp, \"goid\", gp.goid,\n \t\t\"status\", readgstatus(gp),\n \t\t\"gcscandone\", gp.gcscandone)\n-\tunlock(&allglock) // Avoid self-deadlock with traceback.\n \tthrow(\"scan missed a g\")\n }\n "}, {"sha": "da5be70344a2c48cbb736ffba0c09b932c3525bb", "filename": "libgo/go/runtime/mgcscavenge.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fmgcscavenge.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fmgcscavenge.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmgcscavenge.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -564,7 +564,7 @@ func (p *pageAlloc) scavengeUnreserve(r addrRange, gen uint32) {\n func (p *pageAlloc) scavengeOne(work addrRange, max uintptr, mayUnlock bool) (uintptr, addrRange) {\n \tassertLockHeld(p.mheapLock)\n \n-\t// Defensively check if we've recieved an empty address range.\n+\t// Defensively check if we've received an empty address range.\n \t// If so, just return.\n \tif work.size() == 0 {\n \t\t// Nothing to do."}, {"sha": "374d13f30b516978a1154ea7e932f55a9d1af492", "filename": "libgo/go/runtime/msan0.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fmsan0.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fmsan0.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmsan0.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -16,7 +16,8 @@ const msanenabled = false\n \n // Because msanenabled is false, none of these functions should be called.\n \n-func msanread(addr unsafe.Pointer, sz uintptr)   { throw(\"msan\") }\n-func msanwrite(addr unsafe.Pointer, sz uintptr)  { throw(\"msan\") }\n-func msanmalloc(addr unsafe.Pointer, sz uintptr) { throw(\"msan\") }\n-func msanfree(addr unsafe.Pointer, sz uintptr)   { throw(\"msan\") }\n+func msanread(addr unsafe.Pointer, sz uintptr)     { throw(\"msan\") }\n+func msanwrite(addr unsafe.Pointer, sz uintptr)    { throw(\"msan\") }\n+func msanmalloc(addr unsafe.Pointer, sz uintptr)   { throw(\"msan\") }\n+func msanfree(addr unsafe.Pointer, sz uintptr)     { throw(\"msan\") }\n+func msanmove(dst, src unsafe.Pointer, sz uintptr) { throw(\"msan\") }"}, {"sha": "9c683661862eb17efaa4e65e9970df13f323befa", "filename": "libgo/go/runtime/os_freebsd.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fos_freebsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fos_freebsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_freebsd.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -143,7 +143,7 @@ func futexsleep1(addr *uint32, val uint32, ns int64) {\n \t\tutp = &ut\n \t}\n \tret := sys_umtx_op(addr, _UMTX_OP_WAIT_UINT_PRIVATE, val, unsafe.Sizeof(*utp), utp)\n-\tif ret >= 0 || ret == -_EINTR {\n+\tif ret >= 0 || ret == -_EINTR || ret == -_ETIMEDOUT {\n \t\treturn\n \t}\n \tprint(\"umtx_wait addr=\", addr, \" val=\", val, \" ret=\", ret, \"\\n\")"}, {"sha": "65d7aef165a94c4ce515019d14efa3c25487c1d8", "filename": "libgo/go/runtime/os_gccgo.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fos_gccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fos_gccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_gccgo.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -37,6 +37,11 @@ func unminit() {\n \tunminitSignals()\n }\n \n+// Called from exitm, but not from drop, to undo the effect of thread-owned\n+// resources in minit, semacreate, or elsewhere. Do not take locks after calling this.\n+func mdestroy(mp *m) {\n+}\n+\n var urandom_dev = []byte(\"/dev/urandom\\x00\")\n \n func getRandomData(r []byte) {"}, {"sha": "24261e88a2060310ea155375c1e17673ebc9c9c3", "filename": "libgo/go/runtime/os_js.go", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fos_js.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fos_js.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_js.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -72,7 +72,7 @@ func clearSignalHandlers() {\n }\n \n //go:nosplit\n-func sigblock() {\n+func sigblock(exiting bool) {\n }\n \n // Called to initialize a new m (including the bootstrap m).\n@@ -84,6 +84,11 @@ func minit() {\n func unminit() {\n }\n \n+// Called from exitm, but not from drop, to undo the effect of thread-owned\n+// resources in minit, semacreate, or elsewhere. Do not take locks after calling this.\n+func mdestroy(mp *m) {\n+}\n+\n func osinit() {\n \tncpu = 1\n \tgetg().m.procid = 2"}, {"sha": "50f0480048a9153c475162bcb4d89ffb73fd5879", "filename": "libgo/go/runtime/os_openbsd.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fos_openbsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fos_openbsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_openbsd.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -6,7 +6,6 @@ package runtime\n \n import (\n \t\"runtime/internal/atomic\"\n-\t\"runtime/internal/sys\"\n \t\"unsafe\"\n )\n "}, {"sha": "eec44db19190f26d877189027d65406a2732df1f", "filename": "libgo/go/runtime/proc.go", "status": "modified", "additions": 70, "deletions": 9, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -505,8 +505,29 @@ func lockedOSThread() bool {\n }\n \n var (\n-\tallgs    []*g\n+\t// allgs contains all Gs ever created (including dead Gs), and thus\n+\t// never shrinks.\n+\t//\n+\t// Access via the slice is protected by allglock or stop-the-world.\n+\t// Readers that cannot take the lock may (carefully!) use the atomic\n+\t// variables below.\n \tallglock mutex\n+\tallgs    []*g\n+\n+\t// allglen and allgptr are atomic variables that contain len(allg) and\n+\t// &allg[0] respectively. Proper ordering depends on totally-ordered\n+\t// loads and stores. Writes are protected by allglock.\n+\t//\n+\t// allgptr is updated before allglen. Readers should read allglen\n+\t// before allgptr to ensure that allglen is always <= len(allgptr). New\n+\t// Gs appended during the race can be missed. For a consistent view of\n+\t// all Gs, allglock must be held.\n+\t//\n+\t// allgptr copies should always be stored as a concrete type or\n+\t// unsafe.Pointer, not uintptr, to ensure that GC can still reach it\n+\t// even if it points to a stale array.\n+\tallglen uintptr\n+\tallgptr **g\n )\n \n func allgadd(gp *g) {\n@@ -516,10 +537,25 @@ func allgadd(gp *g) {\n \n \tlock(&allglock)\n \tallgs = append(allgs, gp)\n-\tallglen = uintptr(len(allgs))\n+\tif &allgs[0] != allgptr {\n+\t\tatomicstorep(unsafe.Pointer(&allgptr), unsafe.Pointer(&allgs[0]))\n+\t}\n+\tatomic.Storeuintptr(&allglen, uintptr(len(allgs)))\n \tunlock(&allglock)\n }\n \n+// atomicAllG returns &allgs[0] and len(allgs) for use with atomicAllGIndex.\n+func atomicAllG() (**g, uintptr) {\n+\tlength := atomic.Loaduintptr(&allglen)\n+\tptr := (**g)(atomic.Loadp(unsafe.Pointer(&allgptr)))\n+\treturn ptr, length\n+}\n+\n+// atomicAllGIndex returns ptr[i] with the allgptr returned from atomicAllG.\n+func atomicAllGIndex(ptr **g, i uintptr) *g {\n+\treturn *(**g)(add(unsafe.Pointer(ptr), i*sys.PtrSize))\n+}\n+\n const (\n \t// Number of goroutine ids to grab from sched.goidgen to local per-P cache at once.\n \t// 16 seems to provide enough amortization, but other than that it's mostly arbitrary number.\n@@ -1293,7 +1329,7 @@ func mexit(osStack bool) {\n \t\tthrow(\"locked m0 woke up\")\n \t}\n \n-\tsigblock()\n+\tsigblock(true)\n \tunminit()\n \n \t// Free the gsignal stack.\n@@ -1351,6 +1387,10 @@ found:\n \t\t}\n \t}\n \n+\t// Destroy all allocated resources. After this is called, we may no\n+\t// longer take any locks.\n+\tmdestroy(m)\n+\n \tif osStack {\n \t\t// Return from mstart and let the system thread\n \t\t// library free the g0 stack and terminate the thread.\n@@ -1596,7 +1636,7 @@ func needm() {\n \t// starting a new m to run Go code via newosproc.\n \tvar sigmask sigset\n \tsigsave(&sigmask)\n-\tsigblock()\n+\tsigblock(false)\n \n \t// Lock extra list, take head, unlock popped list.\n \t// nilokay=false is safe here because of the invariant above,\n@@ -1735,7 +1775,7 @@ func dropm() {\n \t// Setg(nil) clears g, which is the signal handler's cue not to run Go handlers.\n \t// It's important not to try to handle a signal between those two steps.\n \tsigmask := mp.sigmask\n-\tsigblock()\n+\tsigblock(false)\n \tunminit()\n \n \t// gccgo sets the stack to Gdead here, because the splitstack\n@@ -2692,7 +2732,9 @@ func wakeNetPoller(when int64) {\n \t} else {\n \t\t// There are no threads in the network poller, try to get\n \t\t// one there so it can handle new timers.\n-\t\twakep()\n+\t\tif GOOS != \"plan9\" { // Temporary workaround - see issue #42303.\n+\t\t\twakep()\n+\t\t}\n \t}\n }\n \n@@ -3526,7 +3568,7 @@ func beforefork() {\n \t// group. See issue #18600.\n \tgp.m.locks++\n \tsigsave(&gp.m.sigmask)\n-\tsigblock()\n+\tsigblock(false)\n }\n \n // Called from syscall package before fork.\n@@ -3936,7 +3978,7 @@ func badunlockosthread() {\n }\n \n func gcount() int32 {\n-\tn := int32(allglen) - sched.gFree.n - int32(atomic.Load(&sched.ngsys))\n+\tn := int32(atomic.Loaduintptr(&allglen)) - sched.gFree.n - int32(atomic.Load(&sched.ngsys))\n \tfor _, _p_ := range allp {\n \t\tn -= _p_.gFree.n\n \t}\n@@ -4596,7 +4638,6 @@ func checkdead() {\n \t\tcase _Grunnable,\n \t\t\t_Grunning,\n \t\t\t_Gsyscall:\n-\t\t\tunlock(&allglock)\n \t\t\tprint(\"runtime: checkdead: find g \", gp.goid, \" in status \", s, \"\\n\")\n \t\t\tthrow(\"checkdead: runnable g\")\n \t\t}\n@@ -4757,6 +4798,26 @@ func sysmon() {\n \t\t\t}\n \t\t}\n \t\tmDoFixup()\n+\t\tif GOOS == \"netbsd\" {\n+\t\t\t// netpoll is responsible for waiting for timer\n+\t\t\t// expiration, so we typically don't have to worry\n+\t\t\t// about starting an M to service timers. (Note that\n+\t\t\t// sleep for timeSleepUntil above simply ensures sysmon\n+\t\t\t// starts running again when that timer expiration may\n+\t\t\t// cause Go code to run again).\n+\t\t\t//\n+\t\t\t// However, netbsd has a kernel bug that sometimes\n+\t\t\t// misses netpollBreak wake-ups, which can lead to\n+\t\t\t// unbounded delays servicing timers. If we detect this\n+\t\t\t// overrun, then startm to get something to handle the\n+\t\t\t// timer.\n+\t\t\t//\n+\t\t\t// See issue 42515 and\n+\t\t\t// https://gnats.netbsd.org/cgi-bin/query-pr-single.pl?number=50094.\n+\t\t\tif next, _ := timeSleepUntil(); next < now {\n+\t\t\t\tstartm(nil, false)\n+\t\t\t}\n+\t\t}\n \t\tif atomic.Load(&scavenge.sysmonWake) != 0 {\n \t\t\t// Kick the scavenger awake if someone requested it.\n \t\t\twakeScavenger()"}, {"sha": "4b13cfc012374b800d8fa89ce7508fbbc2e7c0e2", "filename": "libgo/go/runtime/runtime2.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fruntime2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fruntime2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime2.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -1070,7 +1070,6 @@ func (w waitReason) String() string {\n }\n \n var (\n-\tallglen    uintptr\n \tallm       *m\n \tgomaxprocs int32\n \tncpu       int32"}, {"sha": "e85136af7d19948c9c98bcf4d8c1d3e4012f44b3", "filename": "libgo/go/runtime/signal_unix.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fsignal_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fsignal_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsignal_unix.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -988,15 +988,16 @@ func msigrestore(sigmask sigset) {\n \tsigprocmask(_SIG_SETMASK, &sigmask, nil)\n }\n \n-// sigblock blocks all signals in the current thread's signal mask.\n+// sigblock blocks signals in the current thread's signal mask.\n // This is used to block signals while setting up and tearing down g\n-// when a non-Go thread calls a Go function.\n-// The OS-specific code is expected to define sigset_all.\n+// when a non-Go thread calls a Go function. When a thread is exiting\n+// we use the sigsetAllExiting value, otherwise the OS specific\n+// definition of sigset_all is used.\n // This is nosplit and nowritebarrierrec because it is called by needm\n // which may be called on a non-Go thread with no g available.\n //go:nosplit\n //go:nowritebarrierrec\n-func sigblock() {\n+func sigblock(exiting bool) {\n \tvar set sigset\n \tsigfillset(&set)\n \tsigprocmask(_SIG_SETMASK, &set, nil)"}, {"sha": "33a9b92ee73f1f51b9ca265ed3be6c1587e67331", "filename": "libgo/go/runtime/signal_windows_test.go", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fsignal_windows_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fsignal_windows_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsignal_windows_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -11,6 +11,7 @@ import (\n \t\"os/exec\"\n \t\"path/filepath\"\n \t\"runtime\"\n+\t\"strconv\"\n \t\"strings\"\n \t\"syscall\"\n \t\"testing\"\n@@ -79,6 +80,69 @@ func sendCtrlBreak(pid int) error {\n \treturn nil\n }\n \n+// TestCtrlHandler tests that Go can gracefully handle closing the console window.\n+// See https://golang.org/issues/41884.\n+func TestCtrlHandler(t *testing.T) {\n+\ttestenv.MustHaveGoBuild(t)\n+\tt.Parallel()\n+\n+\t// build go program\n+\texe := filepath.Join(t.TempDir(), \"test.exe\")\n+\tcmd := exec.Command(testenv.GoToolPath(t), \"build\", \"-o\", exe, \"testdata/testwinsignal/main.go\")\n+\tout, err := testenv.CleanCmdEnv(cmd).CombinedOutput()\n+\tif err != nil {\n+\t\tt.Fatalf(\"failed to build go exe: %v\\n%s\", err, out)\n+\t}\n+\n+\t// run test program\n+\tcmd = exec.Command(exe)\n+\tvar stderr bytes.Buffer\n+\tcmd.Stderr = &stderr\n+\toutPipe, err := cmd.StdoutPipe()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create stdout pipe: %v\", err)\n+\t}\n+\toutReader := bufio.NewReader(outPipe)\n+\n+\t// in a new command window\n+\tconst _CREATE_NEW_CONSOLE = 0x00000010\n+\tcmd.SysProcAttr = &syscall.SysProcAttr{\n+\t\tCreationFlags: _CREATE_NEW_CONSOLE,\n+\t\tHideWindow:    true,\n+\t}\n+\tif err := cmd.Start(); err != nil {\n+\t\tt.Fatalf(\"Start failed: %v\", err)\n+\t}\n+\tdefer func() {\n+\t\tcmd.Process.Kill()\n+\t\tcmd.Wait()\n+\t}()\n+\n+\t// wait for child to be ready to receive signals\n+\tif line, err := outReader.ReadString('\\n'); err != nil {\n+\t\tt.Fatalf(\"could not read stdout: %v\", err)\n+\t} else if strings.TrimSpace(line) != \"ready\" {\n+\t\tt.Fatalf(\"unexpected message: %s\", line)\n+\t}\n+\n+\t// gracefully kill pid, this closes the command window\n+\tif err := exec.Command(\"taskkill.exe\", \"/pid\", strconv.Itoa(cmd.Process.Pid)).Run(); err != nil {\n+\t\tt.Fatalf(\"failed to kill: %v\", err)\n+\t}\n+\n+\t// check child received, handled SIGTERM\n+\tif line, err := outReader.ReadString('\\n'); err != nil {\n+\t\tt.Fatalf(\"could not read stdout: %v\", err)\n+\t} else if expected, got := syscall.SIGTERM.String(), strings.TrimSpace(line); expected != got {\n+\t\tt.Fatalf(\"Expected '%s' got: %s\", expected, got)\n+\t}\n+\n+\t// check child exited gracefully, did not timeout\n+\tif err := cmd.Wait(); err != nil {\n+\t\tt.Fatalf(\"Program exited with error: %v\\n%s\", err, &stderr)\n+\t}\n+}\n+\n // TestLibraryCtrlHandler tests that Go DLL allows calling program to handle console control events.\n // See https://golang.org/issues/35965.\n func TestLibraryCtrlHandler(t *testing.T) {"}, {"sha": "ca41b0552d551f35b2d48259c6ea29df292d8435", "filename": "libgo/go/runtime/sigqueue.go", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fsigqueue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fsigqueue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsigqueue.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -12,12 +12,16 @@\n // sigsend is called by the signal handler to queue a new signal.\n // signal_recv is called by the Go program to receive a newly queued signal.\n // Synchronization between sigsend and signal_recv is based on the sig.state\n-// variable. It can be in 3 states: sigIdle, sigReceiving and sigSending.\n+// variable. It can be in 4 states: sigIdle, sigReceiving, sigSending and sigFixup.\n // sigReceiving means that signal_recv is blocked on sig.Note and there are no\n // new pending signals.\n // sigSending means that sig.mask *may* contain new pending signals,\n // signal_recv can't be blocked in this state.\n // sigIdle means that there are no new pending signals and signal_recv is not blocked.\n+// sigFixup is a transient state that can only exist as a short\n+// transition from sigReceiving and then on to sigIdle: it is\n+// used to ensure the AllThreadsSyscall()'s mDoFixup() operation\n+// occurs on the sleeping m, waiting to receive a signal.\n // Transitions between states are done atomically with CAS.\n // When signal_recv is unblocked, it resets sig.Note and rechecks sig.mask.\n // If several sigsends and signal_recv execute concurrently, it can lead to\n@@ -59,6 +63,7 @@ const (\n \tsigIdle = iota\n \tsigReceiving\n \tsigSending\n+\tsigFixup\n )\n \n // sigsend delivers a signal from sighandler to the internal signal delivery queue.\n@@ -112,13 +117,29 @@ Send:\n \t\t\t\tnotewakeup(&sig.note)\n \t\t\t\tbreak Send\n \t\t\t}\n+\t\tcase sigFixup:\n+\t\t\t// nothing to do - we need to wait for sigIdle.\n+\t\t\tosyield()\n \t\t}\n \t}\n \n \tatomic.Xadd(&sig.delivering, -1)\n \treturn true\n }\n \n+// sigRecvPrepareForFixup is used to temporarily wake up the\n+// signal_recv() running thread while it is blocked waiting for the\n+// arrival of a signal. If it causes the thread to wake up, the\n+// sig.state travels through this sequence: sigReceiving -> sigFixup\n+// -> sigIdle -> sigReceiving and resumes. (This is only called while\n+// GC is disabled.)\n+//go:nosplit\n+func sigRecvPrepareForFixup() {\n+\tif atomic.Cas(&sig.state, sigReceiving, sigFixup) {\n+\t\tnotewakeup(&sig.note)\n+\t}\n+}\n+\n // Called to receive the next queued signal.\n // Must only be called from a single goroutine at a time.\n //go:linkname signal_recv os_1signal.signal__recv\n@@ -146,7 +167,16 @@ func signal_recv() uint32 {\n \t\t\t\t\t}\n \t\t\t\t\tnotetsleepg(&sig.note, -1)\n \t\t\t\t\tnoteclear(&sig.note)\n-\t\t\t\t\tbreak Receive\n+\t\t\t\t\tif !atomic.Cas(&sig.state, sigFixup, sigIdle) {\n+\t\t\t\t\t\tbreak Receive\n+\t\t\t\t\t}\n+\t\t\t\t\t// Getting here, the code will\n+\t\t\t\t\t// loop around again to sleep\n+\t\t\t\t\t// in state sigReceiving. This\n+\t\t\t\t\t// path is taken when\n+\t\t\t\t\t// sigRecvPrepareForFixup()\n+\t\t\t\t\t// has been called by another\n+\t\t\t\t\t// thread.\n \t\t\t\t}\n \t\t\tcase sigSending:\n \t\t\t\tif atomic.Cas(&sig.state, sigSending, sigIdle) {"}, {"sha": "93ff56618801282e136cb0c6381386bbd45d71fa", "filename": "libgo/go/runtime/stubs2.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fstubs2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Fstubs2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fstubs2.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -2,9 +2,9 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build !js\n // +build !plan9\n // +build !windows\n-// +build !js\n \n package runtime\n "}, {"sha": "781acbd7706ac68627f3962bfd9d11f6c8953f41", "filename": "libgo/go/runtime/testdata/testprog/deadlock.go", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprog%2Fdeadlock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprog%2Fdeadlock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprog%2Fdeadlock.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -25,6 +25,7 @@ func init() {\n \tregister(\"RecursivePanic2\", RecursivePanic2)\n \tregister(\"RecursivePanic3\", RecursivePanic3)\n \tregister(\"RecursivePanic4\", RecursivePanic4)\n+\tregister(\"RecursivePanic5\", RecursivePanic5)\n \tregister(\"GoexitExit\", GoexitExit)\n \tregister(\"GoNil\", GoNil)\n \tregister(\"MainGoroutineID\", MainGoroutineID)\n@@ -160,6 +161,44 @@ func RecursivePanic4() {\n \tpanic(\"first panic\")\n }\n \n+// Test case where we have an open-coded defer higher up the stack (in two), and\n+// in the current function (three) we recover in a defer while we still have\n+// another defer to be processed.\n+func RecursivePanic5() {\n+\tone()\n+\tpanic(\"third panic\")\n+}\n+\n+//go:noinline\n+func one() {\n+\ttwo()\n+}\n+\n+//go:noinline\n+func two() {\n+\tdefer func() {\n+\t}()\n+\n+\tthree()\n+}\n+\n+//go:noinline\n+func three() {\n+\tdefer func() {\n+\t}()\n+\n+\tdefer func() {\n+\t\tfmt.Println(recover())\n+\t}()\n+\n+\tdefer func() {\n+\t\tfmt.Println(recover())\n+\t\tpanic(\"second panic\")\n+\t}()\n+\n+\tpanic(\"first panic\")\n+}\n+\n func GoexitExit() {\n \tprintln(\"t1\")\n \tgo func() {"}, {"sha": "1e7c9475fd663153b941f1075ed8828feb791fb7", "filename": "libgo/go/runtime/testdata/testwinsignal/main.go", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestwinsignal%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestwinsignal%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestwinsignal%2Fmain.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -0,0 +1,19 @@\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\t\"os/signal\"\n+\t\"time\"\n+)\n+\n+func main() {\n+\tc := make(chan os.Signal, 1)\n+\tsignal.Notify(c)\n+\n+\tfmt.Println(\"ready\")\n+\tsig := <-c\n+\n+\ttime.Sleep(time.Second)\n+\tfmt.Println(sig)\n+}"}, {"sha": "a69db993c9d78138c4dc2d971fda2fcc1166d405", "filename": "libgo/go/runtime/time.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Ftime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Ftime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftime.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -608,8 +608,14 @@ func moveTimers(pp *p, timers []*timer) {\n \t\tfor {\n \t\t\tswitch s := atomic.Load(&t.status); s {\n \t\t\tcase timerWaiting:\n+\t\t\t\tif !atomic.Cas(&t.status, s, timerMoving) {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n \t\t\t\tt.pp = 0\n \t\t\t\tdoaddtimer(pp, t)\n+\t\t\t\tif !atomic.Cas(&t.status, timerMoving, timerWaiting) {\n+\t\t\t\t\tbadTimer()\n+\t\t\t\t}\n \t\t\t\tbreak loop\n \t\t\tcase timerModifiedEarlier, timerModifiedLater:\n \t\t\t\tif !atomic.Cas(&t.status, s, timerMoving) {"}, {"sha": "f691388c7293df4ca19893c7c373bbd695ee6c94", "filename": "libgo/go/runtime/timestub2.go", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Ftimestub2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fruntime%2Ftimestub2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftimestub2.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -2,10 +2,6 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build !darwin\n-// +build !windows\n-// +build !freebsd\n-\n package runtime\n \n func walltime1() (sec int64, nsec int32)"}, {"sha": "f035d555535609a98b1e8ca9f60ca12212666620", "filename": "libgo/go/syscall/exec_darwin.go", "status": "removed", "additions": 0, "deletions": 259, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91a95ad2ae0e0f2fa953fafe55ff2ec32c8277d5/libgo%2Fgo%2Fsyscall%2Fexec_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91a95ad2ae0e0f2fa953fafe55ff2ec32c8277d5/libgo%2Fgo%2Fsyscall%2Fexec_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_darwin.go?ref=91a95ad2ae0e0f2fa953fafe55ff2ec32c8277d5", "patch": "@@ -1,259 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package syscall\n-\n-import (\n-\t\"unsafe\"\n-)\n-\n-type SysProcAttr struct {\n-\tChroot     string      // Chroot.\n-\tCredential *Credential // Credential.\n-\tPtrace     bool        // Enable tracing.\n-\tSetsid     bool        // Create session.\n-\t// Setpgid sets the process group ID of the child to Pgid,\n-\t// or, if Pgid == 0, to the new child's process ID.\n-\tSetpgid bool\n-\t// Setctty sets the controlling terminal of the child to\n-\t// file descriptor Ctty. Ctty must be a descriptor number\n-\t// in the child process: an index into ProcAttr.Files.\n-\t// This is only meaningful if Setsid is true.\n-\tSetctty bool\n-\tNoctty  bool // Detach fd 0 from controlling terminal\n-\tCtty    int  // Controlling TTY fd\n-\t// Foreground places the child process group in the foreground.\n-\t// This implies Setpgid. The Ctty field must be set to\n-\t// the descriptor of the controlling TTY.\n-\t// Unlike Setctty, in this case Ctty must be a descriptor\n-\t// number in the parent process.\n-\tForeground bool\n-\tPgid       int // Child's process group ID if Setpgid.\n-}\n-\n-// Implemented in runtime package.\n-func runtime_BeforeFork()\n-func runtime_AfterFork()\n-func runtime_AfterForkInChild()\n-\n-// Fork, dup fd onto 0..len(fd), and exec(argv0, argvv, envv) in child.\n-// If a dup or exec fails, write the errno error to pipe.\n-// (Pipe is close-on-exec so if exec succeeds, it will be closed.)\n-// In the child, this function must not acquire any locks, because\n-// they might have been locked at the time of the fork. This means\n-// no rescheduling, no malloc calls, and no new stack segments.\n-// For the same reason compiler does not race instrument it.\n-// The calls to rawSyscall are okay because they are assembly\n-// functions that do not grow the stack.\n-//go:norace\n-func forkAndExecInChild(argv0 *byte, argv, envv []*byte, chroot, dir *byte, attr *ProcAttr, sys *SysProcAttr, pipe int) (pid int, err Errno) {\n-\t// Declare all variables at top in case any\n-\t// declarations require heap allocation (e.g., err1).\n-\tvar (\n-\t\tr1     uintptr\n-\t\terr1   Errno\n-\t\tnextfd int\n-\t\ti      int\n-\t)\n-\n-\t// guard against side effects of shuffling fds below.\n-\t// Make sure that nextfd is beyond any currently open files so\n-\t// that we can't run the risk of overwriting any of them.\n-\tfd := make([]int, len(attr.Files))\n-\tnextfd = len(attr.Files)\n-\tfor i, ufd := range attr.Files {\n-\t\tif nextfd < int(ufd) {\n-\t\t\tnextfd = int(ufd)\n-\t\t}\n-\t\tfd[i] = int(ufd)\n-\t}\n-\tnextfd++\n-\n-\t// About to call fork.\n-\t// No more allocation or calls of non-assembly functions.\n-\truntime_BeforeFork()\n-\tr1, _, err1 = rawSyscall(funcPC(libc_fork_trampoline), 0, 0, 0)\n-\tif err1 != 0 {\n-\t\truntime_AfterFork()\n-\t\treturn 0, err1\n-\t}\n-\n-\tif r1 != 0 {\n-\t\t// parent; return PID\n-\t\truntime_AfterFork()\n-\t\treturn int(r1), 0\n-\t}\n-\n-\t// Fork succeeded, now in child.\n-\n-\truntime_AfterForkInChild()\n-\n-\t// Enable tracing if requested.\n-\tif sys.Ptrace {\n-\t\tif err := ptrace(PTRACE_TRACEME, 0, 0, 0); err != nil {\n-\t\t\terr1 = err.(Errno)\n-\t\t\tgoto childerror\n-\t\t}\n-\t}\n-\n-\t// Session ID\n-\tif sys.Setsid {\n-\t\t_, _, err1 = rawSyscall(funcPC(libc_setsid_trampoline), 0, 0, 0)\n-\t\tif err1 != 0 {\n-\t\t\tgoto childerror\n-\t\t}\n-\t}\n-\n-\t// Set process group\n-\tif sys.Setpgid || sys.Foreground {\n-\t\t// Place child in process group.\n-\t\t_, _, err1 = rawSyscall(funcPC(libc_setpgid_trampoline), 0, uintptr(sys.Pgid), 0)\n-\t\tif err1 != 0 {\n-\t\t\tgoto childerror\n-\t\t}\n-\t}\n-\n-\tif sys.Foreground {\n-\t\tpgrp := sys.Pgid\n-\t\tif pgrp == 0 {\n-\t\t\tr1, _, err1 = rawSyscall(funcPC(libc_getpid_trampoline), 0, 0, 0)\n-\t\t\tif err1 != 0 {\n-\t\t\t\tgoto childerror\n-\t\t\t}\n-\n-\t\t\tpgrp = int(r1)\n-\t\t}\n-\n-\t\t// Place process group in foreground.\n-\t\t_, _, err1 = rawSyscall(funcPC(libc_ioctl_trampoline), uintptr(sys.Ctty), uintptr(TIOCSPGRP), uintptr(unsafe.Pointer(&pgrp)))\n-\t\tif err1 != 0 {\n-\t\t\tgoto childerror\n-\t\t}\n-\t}\n-\n-\t// Chroot\n-\tif chroot != nil {\n-\t\t_, _, err1 = rawSyscall(funcPC(libc_chroot_trampoline), uintptr(unsafe.Pointer(chroot)), 0, 0)\n-\t\tif err1 != 0 {\n-\t\t\tgoto childerror\n-\t\t}\n-\t}\n-\n-\t// User and groups\n-\tif cred := sys.Credential; cred != nil {\n-\t\tngroups := uintptr(len(cred.Groups))\n-\t\tgroups := uintptr(0)\n-\t\tif ngroups > 0 {\n-\t\t\tgroups = uintptr(unsafe.Pointer(&cred.Groups[0]))\n-\t\t}\n-\t\tif !cred.NoSetGroups {\n-\t\t\t_, _, err1 = rawSyscall(funcPC(libc_setgroups_trampoline), ngroups, groups, 0)\n-\t\t\tif err1 != 0 {\n-\t\t\t\tgoto childerror\n-\t\t\t}\n-\t\t}\n-\t\t_, _, err1 = rawSyscall(funcPC(libc_setgid_trampoline), uintptr(cred.Gid), 0, 0)\n-\t\tif err1 != 0 {\n-\t\t\tgoto childerror\n-\t\t}\n-\t\t_, _, err1 = rawSyscall(funcPC(libc_setuid_trampoline), uintptr(cred.Uid), 0, 0)\n-\t\tif err1 != 0 {\n-\t\t\tgoto childerror\n-\t\t}\n-\t}\n-\n-\t// Chdir\n-\tif dir != nil {\n-\t\t_, _, err1 = rawSyscall(funcPC(libc_chdir_trampoline), uintptr(unsafe.Pointer(dir)), 0, 0)\n-\t\tif err1 != 0 {\n-\t\t\tgoto childerror\n-\t\t}\n-\t}\n-\n-\t// Pass 1: look for fd[i] < i and move those up above len(fd)\n-\t// so that pass 2 won't stomp on an fd it needs later.\n-\tif pipe < nextfd {\n-\t\t_, _, err1 = rawSyscall(funcPC(libc_dup2_trampoline), uintptr(pipe), uintptr(nextfd), 0)\n-\t\tif err1 != 0 {\n-\t\t\tgoto childerror\n-\t\t}\n-\t\trawSyscall(funcPC(libc_fcntl_trampoline), uintptr(nextfd), F_SETFD, FD_CLOEXEC)\n-\t\tpipe = nextfd\n-\t\tnextfd++\n-\t}\n-\tfor i = 0; i < len(fd); i++ {\n-\t\tif fd[i] >= 0 && fd[i] < int(i) {\n-\t\t\tif nextfd == pipe { // don't stomp on pipe\n-\t\t\t\tnextfd++\n-\t\t\t}\n-\t\t\t_, _, err1 = rawSyscall(funcPC(libc_dup2_trampoline), uintptr(fd[i]), uintptr(nextfd), 0)\n-\t\t\tif err1 != 0 {\n-\t\t\t\tgoto childerror\n-\t\t\t}\n-\t\t\trawSyscall(funcPC(libc_fcntl_trampoline), uintptr(nextfd), F_SETFD, FD_CLOEXEC)\n-\t\t\tfd[i] = nextfd\n-\t\t\tnextfd++\n-\t\t}\n-\t}\n-\n-\t// Pass 2: dup fd[i] down onto i.\n-\tfor i = 0; i < len(fd); i++ {\n-\t\tif fd[i] == -1 {\n-\t\t\trawSyscall(funcPC(libc_close_trampoline), uintptr(i), 0, 0)\n-\t\t\tcontinue\n-\t\t}\n-\t\tif fd[i] == int(i) {\n-\t\t\t// dup2(i, i) won't clear close-on-exec flag on Linux,\n-\t\t\t// probably not elsewhere either.\n-\t\t\t_, _, err1 = rawSyscall(funcPC(libc_fcntl_trampoline), uintptr(fd[i]), F_SETFD, 0)\n-\t\t\tif err1 != 0 {\n-\t\t\t\tgoto childerror\n-\t\t\t}\n-\t\t\tcontinue\n-\t\t}\n-\t\t// The new fd is created NOT close-on-exec,\n-\t\t// which is exactly what we want.\n-\t\t_, _, err1 = rawSyscall(funcPC(libc_dup2_trampoline), uintptr(fd[i]), uintptr(i), 0)\n-\t\tif err1 != 0 {\n-\t\t\tgoto childerror\n-\t\t}\n-\t}\n-\n-\t// By convention, we don't close-on-exec the fds we are\n-\t// started with, so if len(fd) < 3, close 0, 1, 2 as needed.\n-\t// Programs that know they inherit fds >= 3 will need\n-\t// to set them close-on-exec.\n-\tfor i = len(fd); i < 3; i++ {\n-\t\trawSyscall(funcPC(libc_close_trampoline), uintptr(i), 0, 0)\n-\t}\n-\n-\t// Detach fd 0 from tty\n-\tif sys.Noctty {\n-\t\t_, _, err1 = rawSyscall(funcPC(libc_ioctl_trampoline), 0, uintptr(TIOCNOTTY), 0)\n-\t\tif err1 != 0 {\n-\t\t\tgoto childerror\n-\t\t}\n-\t}\n-\n-\t// Set the controlling TTY to Ctty\n-\tif sys.Setctty {\n-\t\t_, _, err1 = rawSyscall(funcPC(libc_ioctl_trampoline), uintptr(sys.Ctty), uintptr(TIOCSCTTY), 0)\n-\t\tif err1 != 0 {\n-\t\t\tgoto childerror\n-\t\t}\n-\t}\n-\n-\t// Time to exec.\n-\t_, _, err1 = rawSyscall(funcPC(libc_execve_trampoline),\n-\t\tuintptr(unsafe.Pointer(argv0)),\n-\t\tuintptr(unsafe.Pointer(&argv[0])),\n-\t\tuintptr(unsafe.Pointer(&envv[0])))\n-\n-childerror:\n-\t// send error code on pipe\n-\trawSyscall(funcPC(libc_write_trampoline), uintptr(pipe), uintptr(unsafe.Pointer(&err1)), unsafe.Sizeof(err1))\n-\tfor {\n-\t\trawSyscall(funcPC(libc_exit_trampoline), 253, 0, 0)\n-\t}\n-}"}, {"sha": "d89bf3867660fc0c8f8d71d0970f4013d03aab09", "filename": "libgo/go/syscall/exec_unix.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fsyscall%2Fexec_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fsyscall%2Fexec_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_unix.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -328,6 +328,7 @@ func runtime_AfterExec()\n // execveLibc is non-nil on OS using libc syscall, set to execve in exec_libc.go; this\n // avoids a build dependency for other platforms.\n var execveDarwin func(path *byte, argv **byte, envp **byte) error\n+var execveOpenBSD func(path *byte, argv **byte, envp **byte) error\n \n // Exec invokes the execve(2) system call.\n func Exec(argv0 string, argv []string, envv []string) (err error) {\n@@ -352,6 +353,9 @@ func Exec(argv0 string, argv []string, envv []string) (err error) {\n \t} else if runtime.GOOS == \"darwin\" || runtime.GOOS == \"ios\" {\n \t\t// Similarly on Darwin.\n \t\terr1 = execveDarwin(argv0p, &argvp[0], &envvp[0])\n+\t} else if runtime.GOOS == \"openbsd\" && runtime.GOARCH == \"amd64\" {\n+\t\t// Similarly on OpenBSD.\n+\t\terr1 = execveOpenBSD(argv0p, &argvp[0], &envvp[0])\n \t} else {\n \t\t_, _, err1 = RawSyscall(SYS_EXECVE,\n \t\t\tuintptr(unsafe.Pointer(argv0p)),"}, {"sha": "2ebaf8d3513e53b2cedb20f85fdcb07cff2c1f17", "filename": "libgo/go/syscall/mkasm.go", "status": "renamed", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fsyscall%2Fmkasm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fsyscall%2Fmkasm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fmkasm.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -4,8 +4,8 @@\n \n // +build ignore\n \n-// mkasm_darwin.go generates assembly trampolines to call libSystem routines from Go.\n-//This program must be run after mksyscall.pl.\n+// mkasm.go generates assembly trampolines to call library routines from Go.\n+// This program must be run after mksyscall.pl.\n package main\n \n import (\n@@ -17,26 +17,33 @@ import (\n )\n \n func main() {\n-\tin1, err := os.ReadFile(\"syscall_darwin.go\")\n+\tif len(os.Args) != 3 {\n+\t\tlog.Fatalf(\"Usage: %s <goos> <arch>\", os.Args[0])\n+\t}\n+\tgoos, arch := os.Args[1], os.Args[2]\n+\n+\tsyscallFilename := fmt.Sprintf(\"syscall_%s.go\", goos)\n+\tsyscallArchFilename := fmt.Sprintf(\"syscall_%s_%s.go\", goos, arch)\n+\n+\tin1, err := os.ReadFile(syscallFilename)\n \tif err != nil {\n-\t\tlog.Fatalf(\"can't open syscall_darwin.go: %s\", err)\n+\t\tlog.Fatalf(\"can't open syscall file: %s\", err)\n \t}\n-\tarch := os.Args[1]\n-\tin2, err := os.ReadFile(fmt.Sprintf(\"syscall_darwin_%s.go\", arch))\n+\tin2, err := os.ReadFile(syscallArchFilename)\n \tif err != nil {\n-\t\tlog.Fatalf(\"can't open syscall_darwin_%s.go: %s\", arch, err)\n+\t\tlog.Fatalf(\"can't open syscall file: %s\", err)\n \t}\n-\tin3, err := os.ReadFile(fmt.Sprintf(\"zsyscall_darwin_%s.go\", arch))\n+\tin3, err := os.ReadFile(\"z\" + syscallArchFilename)\n \tif err != nil {\n-\t\tlog.Fatalf(\"can't open zsyscall_darwin_%s.go: %s\", arch, err)\n+\t\tlog.Fatalf(\"can't open syscall file: %s\", err)\n \t}\n \tin := string(in1) + string(in2) + string(in3)\n \n \ttrampolines := map[string]bool{}\n \n \tvar out bytes.Buffer\n \n-\tfmt.Fprintf(&out, \"// go run mkasm_darwin.go %s\\n\", strings.Join(os.Args[1:], \" \"))\n+\tfmt.Fprintf(&out, \"// go run mkasm.go %s\\n\", strings.Join(os.Args[1:], \" \"))\n \tfmt.Fprintf(&out, \"// Code generated by the command above; DO NOT EDIT.\\n\")\n \tfmt.Fprintf(&out, \"#include \\\"textflag.h\\\"\\n\")\n \tfor _, line := range strings.Split(in, \"\\n\") {\n@@ -50,8 +57,8 @@ func main() {\n \t\t\tfmt.Fprintf(&out, \"\\tJMP\\t%s(SB)\\n\", fn)\n \t\t}\n \t}\n-\terr = os.WriteFile(fmt.Sprintf(\"zsyscall_darwin_%s.s\", arch), out.Bytes(), 0644)\n+\terr = os.WriteFile(fmt.Sprintf(\"zsyscall_%s_%s.s\", goos, arch), out.Bytes(), 0644)\n \tif err != nil {\n-\t\tlog.Fatalf(\"can't write zsyscall_darwin_%s.s: %s\", arch, err)\n+\t\tlog.Fatalf(\"can't write syscall file: %s\", err)\n \t}\n }", "previous_filename": "libgo/go/syscall/mkasm_darwin.go"}, {"sha": "28b4eb4f19fa08eace1a4765006bd7f7d933e863", "filename": "libgo/go/syscall/syscall_linux_test.go", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fsyscall%2Fsyscall_linux_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Fsyscall%2Fsyscall_linux_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsyscall_linux_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -601,6 +601,14 @@ func compareStatus(filter, expect string) error {\n \treturn nil\n }\n \n+// killAThread locks the goroutine to an OS thread and exits; this\n+// causes an OS thread to terminate.\n+func killAThread(c <-chan struct{}) {\n+\truntime.LockOSThread()\n+\t<-c\n+\treturn\n+}\n+\n // TestSetuidEtc performs tests on all of the wrapped system calls\n // that mirror to the 9 glibc syscalls with POSIX semantics. The test\n // here is considered authoritative and should compile and run\n@@ -651,6 +659,11 @@ func TestSetuidEtc(t *testing.T) {\n \t}\n \n \tfor i, v := range vs {\n+\t\t// Generate some thread churn as we execute the tests.\n+\t\tc := make(chan struct{})\n+\t\tgo killAThread(c)\n+\t\tclose(c)\n+\n \t\tif err := v.fn(); err != nil {\n \t\t\tt.Errorf(\"[%d] %q failed: %v\", i, v.call, err)\n \t\t\tcontinue"}, {"sha": "a7f8007333e310eef526c61e667b789b2f125301", "filename": "libgo/go/testing/fstest/testfs.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Ftesting%2Ffstest%2Ftestfs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Ftesting%2Ffstest%2Ftestfs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Ffstest%2Ftestfs.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -24,6 +24,7 @@ import (\n // It also checks that the file system contains at least the expected files.\n // As a special case, if no expected files are listed, fsys must be empty.\n // Otherwise, fsys must only contain at least the listed files: it can also contain others.\n+// The contents of fsys must not change concurrently with TestFS.\n //\n // If TestFS finds any misbehaviors, it returns an error reporting all of them.\n // The error text spans multiple lines, one per detected misbehavior.\n@@ -121,7 +122,7 @@ func (t *fsTester) openDir(dir string) fs.ReadDirFile {\n \td, ok := f.(fs.ReadDirFile)\n \tif !ok {\n \t\tf.Close()\n-\t\tt.errorf(\"%s: Open returned File type %T, not a io.ReadDirFile\", dir, f)\n+\t\tt.errorf(\"%s: Open returned File type %T, not a fs.ReadDirFile\", dir, f)\n \t\treturn nil\n \t}\n \treturn d"}, {"sha": "4f4579941469cd978ef39c0b01e0f281e3ed39f3", "filename": "libgo/go/time/sleep.go", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Ftime%2Fsleep.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Ftime%2Fsleep.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fsleep.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -101,7 +101,9 @@ func NewTimer(d Duration) *Timer {\n // It returns true if the timer had been active, false if the timer had\n // expired or been stopped.\n //\n-// Reset should be invoked only on stopped or expired timers with drained channels.\n+// For a Timer created with NewTimer, Reset should be invoked only on\n+// stopped or expired timers with drained channels.\n+//\n // If a program has already received a value from t.C, the timer is known\n // to have expired and the channel drained, so t.Reset can be used directly.\n // If a program has not yet received a value from t.C, however,\n@@ -120,6 +122,15 @@ func NewTimer(d Duration) *Timer {\n // is a race condition between draining the channel and the new timer expiring.\n // Reset should always be invoked on stopped or expired channels, as described above.\n // The return value exists to preserve compatibility with existing programs.\n+//\n+// For a Timer created with AfterFunc(d, f), Reset either reschedules\n+// when f will run, in which case Reset returns true, or schedules f\n+// to run again, in which case it returns false.\n+// When Reset returns false, Reset neither waits for the prior f to\n+// complete before returning nor does it guarantee that the subsequent\n+// goroutine running f does not run concurrently with the prior\n+// one. If the caller needs to know whether the prior execution of\n+// f is completed, it must coordinate with f explicitly.\n func (t *Timer) Reset(d Duration) bool {\n \tif t.r.f == nil {\n \t\tpanic(\"time: Reset called on uninitialized Timer\")"}, {"sha": "03b59720e27eb9b3add26ed883138bf3e200cb8b", "filename": "libgo/go/time/tzdata/zipdata.go", "status": "modified", "additions": 6862, "deletions": 6832, "changes": 13694, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Ftime%2Ftzdata%2Fzipdata.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fgo%2Ftime%2Ftzdata%2Fzipdata.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftzdata%2Fzipdata.go?ref=726b7aa004d6885388a76521222602b8552a41ee"}, {"sha": "707def56de700cebf0b8747d67e120c6461924f6", "filename": "libgo/libgo-packages.txt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Flibgo-packages.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Flibgo-packages.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Flibgo-packages.txt?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -61,6 +61,7 @@ flag\n fmt\n go/ast\n go/build\n+go/build/constraint\n go/constant\n go/doc\n go/format\n@@ -112,6 +113,7 @@ index/suffixarray\n internal/bytealg\n internal/cfg\n internal/cpu\n+internal/execabs\n internal/fmtsort\n internal/goroot\n internal/goversion"}, {"sha": "5bec1b935520d1bdab1e26c46f3a289d4543b32c", "filename": "libgo/merge.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fmerge.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fmerge.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmerge.sh?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -163,7 +163,7 @@ done\n (cd ${NEWDIR}/src && find . -name 'modules.txt' -print) | while read f; do\n   oldfile=${OLDDIR}/src/$f\n   newfile=${NEWDIR}/src/$f\n-  libgofile=go/`echo $f | sed -e 's|cmd/vendor/|/|' | sed -e 's|/vendor/|/|'`\n+  libgofile=go/$f\n   merge $f ${oldfile} ${newfile} ${libgofile}\n done\n "}, {"sha": "94abaa03e8d4b98cd679bcb69f5a3c38c6110ef6", "filename": "libgo/misc/cgo/test/pkg_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fmisc%2Fcgo%2Ftest%2Fpkg_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fmisc%2Fcgo%2Ftest%2Fpkg_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fpkg_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -30,7 +30,7 @@ func TestCrossPackageTests(t *testing.T) {\n \tswitch runtime.GOOS {\n \tcase \"android\":\n \t\tt.Skip(\"Can't exec cmd/go subprocess on Android.\")\n-\tcase \"darwin\", \"ios\":\n+\tcase \"ios\":\n \t\tswitch runtime.GOARCH {\n \t\tcase \"arm64\":\n \t\t\tt.Skip(\"Can't exec cmd/go subprocess on iOS.\")"}, {"sha": "b67cb2e0cd0db7df43b03a3c0bc86c00426eb12c", "filename": "libgo/misc/cgo/testcarchive/carchive_test.go", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fcarchive_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726b7aa004d6885388a76521222602b8552a41ee/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fcarchive_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fcarchive_test.go?ref=726b7aa004d6885388a76521222602b8552a41ee", "patch": "@@ -118,11 +118,6 @@ func testMain(m *testing.M) int {\n \t\tcc = append(cc, s[start:])\n \t}\n \n-\tif GOOS == \"darwin\" || GOOS == \"ios\" {\n-\t\t// For Darwin/ARM.\n-\t\t// TODO: do we still need this?\n-\t\tcc = append(cc, []string{\"-framework\", \"CoreFoundation\", \"-framework\", \"Foundation\"}...)\n-\t}\n \tif GOOS == \"aix\" {\n \t\t// -Wl,-bnoobjreorder is mandatory to keep the same layout\n \t\t// in .text section."}]}