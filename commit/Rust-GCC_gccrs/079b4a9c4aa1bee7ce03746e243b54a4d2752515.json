{"sha": "079b4a9c4aa1bee7ce03746e243b54a4d2752515", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDc5YjRhOWM0YWExYmVlN2NlMDM3NDZlMjQzYjU0YTRkMjc1MjUxNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-21T07:03:03Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-21T07:03:03Z"}, "message": "poly_int: prune_runtime_alias_test_list\n\nThis patch makes prune_runtime_alias_test_list take the iteration\nfactor as a poly_int and tracks polynomial offsets internally\nas well.\n\n2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree-data-ref.h (prune_runtime_alias_test_list): Take the\n\tfactor as a poly_uint64 rather than an unsigned HOST_WIDE_INT.\n\t* tree-data-ref.c (prune_runtime_alias_test_list): Likewise.\n\tTrack polynomial offsets.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255936", "tree": {"sha": "0349bf5aeb3a994ccd5d84ffd5b9900bbc0aeba5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0349bf5aeb3a994ccd5d84ffd5b9900bbc0aeba5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/079b4a9c4aa1bee7ce03746e243b54a4d2752515", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/079b4a9c4aa1bee7ce03746e243b54a4d2752515", "html_url": "https://github.com/Rust-GCC/gccrs/commit/079b4a9c4aa1bee7ce03746e243b54a4d2752515", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/079b4a9c4aa1bee7ce03746e243b54a4d2752515/comments", "author": null, "committer": null, "parents": [{"sha": "8944b5b36e04894f7a0768440e3253400c3c7857", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8944b5b36e04894f7a0768440e3253400c3c7857", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8944b5b36e04894f7a0768440e3253400c3c7857"}], "stats": {"total": 120, "additions": 68, "deletions": 52}, "files": [{"sha": "5efc48aec8569a90fcb6919b30b7f0598c35f4f7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079b4a9c4aa1bee7ce03746e243b54a4d2752515/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079b4a9c4aa1bee7ce03746e243b54a4d2752515/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=079b4a9c4aa1bee7ce03746e243b54a4d2752515", "patch": "@@ -1,3 +1,12 @@\n+2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree-data-ref.h (prune_runtime_alias_test_list): Take the\n+\tfactor as a poly_uint64 rather than an unsigned HOST_WIDE_INT.\n+\t* tree-data-ref.c (prune_runtime_alias_test_list): Likewise.\n+\tTrack polynomial offsets.\n+\n 2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "954f26206178894479e79721094a1e0fb6aa7cfd", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 58, "deletions": 51, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079b4a9c4aa1bee7ce03746e243b54a4d2752515/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079b4a9c4aa1bee7ce03746e243b54a4d2752515/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=079b4a9c4aa1bee7ce03746e243b54a4d2752515", "patch": "@@ -1417,7 +1417,7 @@ comp_dr_with_seg_len_pair (const void *pa_, const void *pb_)\n \n void\n prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *alias_pairs,\n-\t\t\t       unsigned HOST_WIDE_INT factor)\n+\t\t\t       poly_uint64 factor)\n {\n   /* Sort the collected data ref pairs so that we can scan them once to\n      combine all possible aliasing checks.  */\n@@ -1462,51 +1462,63 @@ prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *alias_pairs,\n \t      std::swap (dr_a2, dr_b2);\n \t    }\n \n+\t  poly_int64 init_a1, init_a2;\n \t  if (!operand_equal_p (DR_BASE_ADDRESS (dr_a1->dr),\n \t\t\t\tDR_BASE_ADDRESS (dr_a2->dr), 0)\n \t      || !operand_equal_p (DR_OFFSET (dr_a1->dr),\n \t\t\t\t   DR_OFFSET (dr_a2->dr), 0)\n-\t      || !tree_fits_shwi_p (DR_INIT (dr_a1->dr))\n-\t      || !tree_fits_shwi_p (DR_INIT (dr_a2->dr)))\n+\t      || !poly_int_tree_p (DR_INIT (dr_a1->dr), &init_a1)\n+\t      || !poly_int_tree_p (DR_INIT (dr_a2->dr), &init_a2))\n \t    continue;\n \n+\t  /* Don't combine if we can't tell which one comes first.  */\n+\t  if (!ordered_p (init_a1, init_a2))\n+\t    continue;\n+\n+\t  /* Make sure dr_a1 starts left of dr_a2.  */\n+\t  if (maybe_gt (init_a1, init_a2))\n+\t    {\n+\t      std::swap (*dr_a1, *dr_a2);\n+\t      std::swap (init_a1, init_a2);\n+\t    }\n+\n \t  /* Only merge const step data references.  */\n-\t  if (TREE_CODE (DR_STEP (dr_a1->dr)) != INTEGER_CST\n-\t      || TREE_CODE (DR_STEP (dr_a2->dr)) != INTEGER_CST)\n+\t  poly_int64 step_a1, step_a2;\n+\t  if (!poly_int_tree_p (DR_STEP (dr_a1->dr), &step_a1)\n+\t      || !poly_int_tree_p (DR_STEP (dr_a2->dr), &step_a2))\n \t    continue;\n \n-\t  /* DR_A1 and DR_A2 must goes in the same direction.  */\n-\t  if (tree_int_cst_compare (DR_STEP (dr_a1->dr), size_zero_node)\n-\t      != tree_int_cst_compare (DR_STEP (dr_a2->dr), size_zero_node))\n+\t  bool neg_step = maybe_lt (step_a1, 0) || maybe_lt (step_a2, 0);\n+\n+\t  /* DR_A1 and DR_A2 must go in the same direction.  */\n+\t  if (neg_step && (maybe_gt (step_a1, 0) || maybe_gt (step_a2, 0)))\n \t    continue;\n \n-\t  bool neg_step\n-\t    = (tree_int_cst_compare (DR_STEP (dr_a1->dr), size_zero_node) < 0);\n+\t  poly_uint64 seg_len_a1 = 0, seg_len_a2 = 0;\n+\t  bool const_seg_len_a1 = poly_int_tree_p (dr_a1->seg_len,\n+\t\t\t\t\t\t   &seg_len_a1);\n+\t  bool const_seg_len_a2 = poly_int_tree_p (dr_a2->seg_len,\n+\t\t\t\t\t\t   &seg_len_a2);\n \n \t  /* We need to compute merged segment length at compilation time for\n \t     dr_a1 and dr_a2, which is impossible if either one has non-const\n \t     segment length.  */\n-\t  if ((!tree_fits_uhwi_p (dr_a1->seg_len)\n-\t       || !tree_fits_uhwi_p (dr_a2->seg_len))\n-\t      && tree_int_cst_compare (DR_STEP (dr_a1->dr),\n-\t\t\t\t       DR_STEP (dr_a2->dr)) != 0)\n+\t  if ((!const_seg_len_a1 || !const_seg_len_a2)\n+\t      && maybe_ne (step_a1, step_a2))\n \t    continue;\n \n-\t  /* Make sure dr_a1 starts left of dr_a2.  */\n-\t  if (tree_int_cst_lt (DR_INIT (dr_a2->dr), DR_INIT (dr_a1->dr)))\n-\t    std::swap (*dr_a1, *dr_a2);\n-\n \t  bool do_remove = false;\n-\t  wide_int diff = (wi::to_wide (DR_INIT (dr_a2->dr))\n-\t\t\t   - wi::to_wide (DR_INIT (dr_a1->dr)));\n-\t  wide_int min_seg_len_b;\n+\t  poly_uint64 diff = init_a2 - init_a1;\n+\t  poly_uint64 min_seg_len_b;\n \t  tree new_seg_len;\n \n-\t  if (TREE_CODE (dr_b1->seg_len) == INTEGER_CST)\n-\t    min_seg_len_b = wi::abs (wi::to_wide (dr_b1->seg_len));\n-\t  else\n-\t    min_seg_len_b\n-\t      = factor * wi::abs (wi::to_wide (DR_STEP (dr_b1->dr)));\n+\t  if (!poly_int_tree_p (dr_b1->seg_len, &min_seg_len_b))\n+\t    {\n+\t      tree step_b = DR_STEP (dr_b1->dr);\n+\t      if (!tree_fits_shwi_p (step_b))\n+\t\tcontinue;\n+\t      min_seg_len_b = factor * abs_hwi (tree_to_shwi (step_b));\n+\t    }\n \n \t  /* Now we try to merge alias check dr_a1 & dr_b and dr_a2 & dr_b.\n \n@@ -1543,26 +1555,24 @@ prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *alias_pairs,\n \t  if (neg_step)\n \t    {\n \t      /* Adjust diff according to access size of both references.  */\n-\t      tree size_a1 = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr_a1->dr)));\n-\t      tree size_a2 = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr_a2->dr)));\n-\t      diff += wi::to_wide (size_a2) - wi::to_wide (size_a1);\n+\t      diff += tree_to_poly_uint64\n+\t\t(TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr_a2->dr))));\n+\t      diff -= tree_to_poly_uint64\n+\t\t(TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr_a1->dr))));\n \t      /* Case A.1.  */\n-\t      if (wi::leu_p (diff, min_seg_len_b)\n+\t      if (known_le (diff, min_seg_len_b)\n \t\t  /* Case A.2 and B combined.  */\n-\t\t  || (tree_fits_uhwi_p (dr_a2->seg_len)))\n+\t\t  || const_seg_len_a2)\n \t\t{\n-\t\t  if (tree_fits_uhwi_p (dr_a1->seg_len)\n-\t\t      && tree_fits_uhwi_p (dr_a2->seg_len))\n-\t\t    {\n-\t\t      wide_int min_len\n-\t\t\t= wi::umin (wi::to_wide (dr_a1->seg_len) - diff,\n-\t\t\t\t    wi::to_wide (dr_a2->seg_len));\n-\t\t      new_seg_len = wide_int_to_tree (sizetype, min_len);\n-\t\t    }\n+\t\t  if (const_seg_len_a1 || const_seg_len_a2)\n+\t\t    new_seg_len\n+\t\t      = build_int_cstu (sizetype,\n+\t\t\t\t\tlower_bound (seg_len_a1 - diff,\n+\t\t\t\t\t\t     seg_len_a2));\n \t\t  else\n \t\t    new_seg_len\n \t\t      = size_binop (MINUS_EXPR, dr_a2->seg_len,\n-\t\t\t\t    wide_int_to_tree (sizetype, diff));\n+\t\t\t\t    build_int_cstu (sizetype, diff));\n \n \t\t  dr_a2->seg_len = new_seg_len;\n \t\t  do_remove = true;\n@@ -1571,22 +1581,19 @@ prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *alias_pairs,\n \t  else\n \t    {\n \t      /* Case A.1.  */\n-\t      if (wi::leu_p (diff, min_seg_len_b)\n+\t      if (known_le (diff, min_seg_len_b)\n \t\t  /* Case A.2 and B combined.  */\n-\t\t  || (tree_fits_uhwi_p (dr_a1->seg_len)))\n+\t\t  || const_seg_len_a1)\n \t\t{\n-\t\t  if (tree_fits_uhwi_p (dr_a1->seg_len)\n-\t\t      && tree_fits_uhwi_p (dr_a2->seg_len))\n-\t\t    {\n-\t\t      wide_int max_len\n-\t\t\t= wi::umax (wi::to_wide (dr_a2->seg_len) + diff,\n-\t\t\t\t    wi::to_wide (dr_a1->seg_len));\n-\t\t      new_seg_len = wide_int_to_tree (sizetype, max_len);\n-\t\t    }\n+\t\t  if (const_seg_len_a1 && const_seg_len_a2)\n+\t\t    new_seg_len\n+\t\t      = build_int_cstu (sizetype,\n+\t\t\t\t\tupper_bound (seg_len_a2 + diff,\n+\t\t\t\t\t\t     seg_len_a1));\n \t\t  else\n \t\t    new_seg_len\n \t\t      = size_binop (PLUS_EXPR, dr_a2->seg_len,\n-\t\t\t\t    wide_int_to_tree (sizetype, diff));\n+\t\t\t\t    build_int_cstu (sizetype, diff));\n \n \t\t  dr_a1->seg_len = new_seg_len;\n \t\t  do_remove = true;"}, {"sha": "00a8ec3582caec3cc9752e53011db3da612d07c3", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/079b4a9c4aa1bee7ce03746e243b54a4d2752515/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/079b4a9c4aa1bee7ce03746e243b54a4d2752515/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=079b4a9c4aa1bee7ce03746e243b54a4d2752515", "patch": "@@ -472,7 +472,7 @@ extern bool dr_equal_offsets_p (struct data_reference *,\n extern bool runtime_alias_check_p (ddr_p, struct loop *, bool);\n extern int data_ref_compare_tree (tree, tree);\n extern void prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *,\n-\t\t\t\t\t   unsigned HOST_WIDE_INT);\n+\t\t\t\t\t   poly_uint64);\n extern void create_runtime_alias_checks (struct loop *,\n \t\t\t\t\t vec<dr_with_seg_len_pair_t> *, tree*);\n /* Return true when the base objects of data references A and B are"}]}