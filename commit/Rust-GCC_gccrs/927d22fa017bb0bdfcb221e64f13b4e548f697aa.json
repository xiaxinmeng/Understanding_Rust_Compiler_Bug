{"sha": "927d22fa017bb0bdfcb221e64f13b4e548f697aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTI3ZDIyZmEwMTdiYjBiZGZjYjIyMWU2NGYxM2I0ZTU0OGY2OTdhYQ==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2016-05-10T12:53:44Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2016-05-10T12:53:44Z"}, "message": "Add rudimentary support for atomics on RX.\n\nAdd rudimentary support for atomics on RX.  It is implemented by flipping\ninterrupts off/on around the atomic sequences.\n\ngcc/\n\t* config/rx/rx-protos.h (is_interrupt_func, is_fast_interrupt_func):\n\tForward declare.\n\t(rx_atomic_sequence): New class.\n\t* config/rx/rx.c (rx_print_operand): Use symbolic names for PSW bits.\n\t(is_interrupt_func, is_fast_interrupt_func): Make non-static and\n\tnon-inline.\n\t(rx_atomic_sequence::rx_atomic_sequence,\n\trx_atomic_sequence::~rx_atomic_sequence): New functions.\n\t* config/rx/rx.md (CTRLREG_PSW, CTRLREG_USP, CTRLREG_FPSW, CTRLREG_CPEN,\n\tCTRLREG_BPSW, CTRLREG_BPC, CTRLREG_ISP, CTRLREG_FINTV,\n\tCTRLREG_INTB): New constants.\n\t(FETCHOP): New code iterator.\n\t(fethcop_name, fetchop_name2): New iterator code attributes.\n\t(QIHI): New mode iterator.\n\t(atomic_exchange<mode>, atomic_exchangesi, xchg_mem<mode>,\n\tatomic_fetch_<fetchop_name>si, atomic_fetch_nandsi,\n\tatomic_<fetchop_name>_fetchsi, atomic_nand_fetchsi): New patterns.\n\nFrom-SVN: r236075", "tree": {"sha": "c432cf8fb7ca9ee255f31db97e9b4f6a76084676", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c432cf8fb7ca9ee255f31db97e9b4f6a76084676"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/927d22fa017bb0bdfcb221e64f13b4e548f697aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/927d22fa017bb0bdfcb221e64f13b4e548f697aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/927d22fa017bb0bdfcb221e64f13b4e548f697aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/927d22fa017bb0bdfcb221e64f13b4e548f697aa/comments", "author": null, "committer": null, "parents": [{"sha": "6f0800d418dd4d27936202543d3b4775527d204b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f0800d418dd4d27936202543d3b4775527d204b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f0800d418dd4d27936202543d3b4775527d204b"}], "stats": {"total": 229, "additions": 217, "deletions": 12}, "files": [{"sha": "fa23868f340d00d071b19aba116f0c69b0c98b6d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/927d22fa017bb0bdfcb221e64f13b4e548f697aa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/927d22fa017bb0bdfcb221e64f13b4e548f697aa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=927d22fa017bb0bdfcb221e64f13b4e548f697aa", "patch": "@@ -1,3 +1,23 @@\n+2016-05-10  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\t* config/rx/rx-protos.h (is_interrupt_func, is_fast_interrupt_func):\n+\tForward declare.\n+\t(rx_atomic_sequence): New class.\n+\t* config/rx/rx.c (rx_print_operand): Use symbolic names for PSW bits.\n+\t(is_interrupt_func, is_fast_interrupt_func): Make non-static and\n+\tnon-inline.\n+\t(rx_atomic_sequence::rx_atomic_sequence,\n+\trx_atomic_sequence::~rx_atomic_sequence): New functions.\n+\t* config/rx/rx.md (CTRLREG_PSW, CTRLREG_USP, CTRLREG_FPSW, CTRLREG_CPEN,\n+\tCTRLREG_BPSW, CTRLREG_BPC, CTRLREG_ISP, CTRLREG_FINTV,\n+\tCTRLREG_INTB): New constants.\n+\t(FETCHOP): New code iterator.\n+\t(fethcop_name, fetchop_name2): New iterator code attributes.\n+\t(QIHI): New mode iterator.\n+\t(atomic_exchange<mode>, atomic_exchangesi, xchg_mem<mode>,\n+\tatomic_fetch_<fetchop_name>si, atomic_fetch_nandsi,\n+\tatomic_<fetchop_name>_fetchsi, atomic_nand_fetchsi): New patterns.\n+\n 2016-05-10  Martin Liska  <mliska@suse.cz>\n \n \t* tree-inline.c (remap_dependence_clique): Do not remap"}, {"sha": "771528b3dd55cf5da4a6e9760a369de898ba1d64", "filename": "gcc/config/rx/rx-protos.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/927d22fa017bb0bdfcb221e64f13b4e548f697aa/gcc%2Fconfig%2Frx%2Frx-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/927d22fa017bb0bdfcb221e64f13b4e548f697aa/gcc%2Fconfig%2Frx%2Frx-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx-protos.h?ref=927d22fa017bb0bdfcb221e64f13b4e548f697aa", "patch": "@@ -26,6 +26,28 @@ extern void\t\trx_expand_epilogue (bool);\n extern void\t\trx_expand_prologue (void);\n extern int\t\trx_initial_elimination_offset (int, int);\n \n+bool is_interrupt_func (const_tree decl);\n+bool is_fast_interrupt_func (const_tree decl);\n+\n+/* rx_atomic_sequence is used to emit the header and footer\n+   of an atomic sequence.  It's supposed to be used in a scope.\n+   When constructed, it will emit the atomic sequence header insns.\n+   When destructred (goes out of scope), it will emit the\n+   corresponding atomic sequence footer insns.  */\n+class rx_atomic_sequence\n+{\n+public:\n+  rx_atomic_sequence (const_tree fun_decl);\n+  ~rx_atomic_sequence (void);\n+\n+private:\n+  rx_atomic_sequence (void);\n+  rx_atomic_sequence (const rx_atomic_sequence&);\n+  rx_atomic_sequence& operator = (const rx_atomic_sequence&);\n+\n+  rtx m_prev_psw_reg;\n+};\n+\n #ifdef RTX_CODE\n extern int\t\trx_adjust_insn_length (rtx_insn *, int);\n extern int \t\trx_align_for_label (rtx, int);"}, {"sha": "8dfc8856abe542cd554169a7bb5d0dababbd2cb9", "filename": "gcc/config/rx/rx.c", "status": "modified", "additions": 34, "deletions": 11, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/927d22fa017bb0bdfcb221e64f13b4e548f697aa/gcc%2Fconfig%2Frx%2Frx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/927d22fa017bb0bdfcb221e64f13b4e548f697aa/gcc%2Fconfig%2Frx%2Frx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.c?ref=927d22fa017bb0bdfcb221e64f13b4e548f697aa", "patch": "@@ -630,15 +630,15 @@ rx_print_operand (FILE * file, rtx op, int letter)\n       gcc_assert (CONST_INT_P (op));\n       switch (INTVAL (op))\n \t{\n-\tcase 0:   fprintf (file, \"psw\"); break;\n-\tcase 2:   fprintf (file, \"usp\"); break;\n-\tcase 3:   fprintf (file, \"fpsw\"); break;\n-\tcase 4:   fprintf (file, \"cpen\"); break;\n-\tcase 8:   fprintf (file, \"bpsw\"); break;\n-\tcase 9:   fprintf (file, \"bpc\"); break;\n-\tcase 0xa: fprintf (file, \"isp\"); break;\n-\tcase 0xb: fprintf (file, \"fintv\"); break;\n-\tcase 0xc: fprintf (file, \"intb\"); break;\n+\tcase CTRLREG_PSW:   fprintf (file, \"psw\"); break;\n+\tcase CTRLREG_USP:   fprintf (file, \"usp\"); break;\n+\tcase CTRLREG_FPSW:  fprintf (file, \"fpsw\"); break;\n+\tcase CTRLREG_CPEN:  fprintf (file, \"cpen\"); break;\n+\tcase CTRLREG_BPSW:  fprintf (file, \"bpsw\"); break;\n+\tcase CTRLREG_BPC:   fprintf (file, \"bpc\"); break;\n+\tcase CTRLREG_ISP:   fprintf (file, \"isp\"); break;\n+\tcase CTRLREG_FINTV: fprintf (file, \"fintv\"); break;\n+\tcase CTRLREG_INTB:  fprintf (file, \"intb\"); break;\n \tdefault:\n \t  warning (0, \"unrecognized control register number: %d - using 'psw'\",\n \t\t   (int) INTVAL (op));\n@@ -1216,15 +1216,15 @@ has_func_attr (const_tree decl, const char * func_attr)\n \n /* Returns true if the provided function has the \"fast_interrupt\" attribute.  */\n \n-static inline bool\n+bool\n is_fast_interrupt_func (const_tree decl)\n {\n   return has_func_attr (decl, \"fast_interrupt\");\n }\n \n /* Returns true if the provided function has the \"interrupt\" attribute.  */\n \n-static inline bool\n+bool\n is_interrupt_func (const_tree decl)\n {\n   return has_func_attr (decl, \"interrupt\");\n@@ -3409,6 +3409,29 @@ rx_enable_lra (void)\n   return TARGET_ENABLE_LRA;\n }\n \n+rx_atomic_sequence::rx_atomic_sequence (const_tree fun_decl)\n+{\n+  if (is_fast_interrupt_func (fun_decl) || is_interrupt_func (fun_decl))\n+    {\n+      /* If we are inside an interrupt handler, assume that interrupts are\n+\t off -- which is the default hardware behavior.  In this case, there\n+\t is no need to disable the interrupts.  */\n+      m_prev_psw_reg = NULL;\n+    }\n+  else\n+    {\n+      m_prev_psw_reg = gen_reg_rtx (SImode);\n+      emit_insn (gen_mvfc (m_prev_psw_reg, GEN_INT (CTRLREG_PSW)));\n+      emit_insn (gen_clrpsw (GEN_INT ('I')));\n+    }\n+}\n+\n+rx_atomic_sequence::~rx_atomic_sequence (void)\n+{\n+  if (m_prev_psw_reg != NULL)\n+    emit_insn (gen_mvtc (GEN_INT (CTRLREG_PSW), m_prev_psw_reg));\n+}\n+\n \f\n #undef  TARGET_NARROW_VOLATILE_BITFIELD\n #define TARGET_NARROW_VOLATILE_BITFIELD\t\trx_narrow_volatile_bitfield"}, {"sha": "9af16828b8cb29142895d2597613f3c727fa5180", "filename": "gcc/config/rx/rx.md", "status": "modified", "additions": 141, "deletions": 1, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/927d22fa017bb0bdfcb221e64f13b4e548f697aa/gcc%2Fconfig%2Frx%2Frx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/927d22fa017bb0bdfcb221e64f13b4e548f697aa/gcc%2Fconfig%2Frx%2Frx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.md?ref=927d22fa017bb0bdfcb221e64f13b4e548f697aa", "patch": "@@ -75,6 +75,16 @@\n    (UNSPEC_BUILTIN_WAIT\t   51)\n \n    (UNSPEC_PID_ADDR\t   52)\n+\n+   (CTRLREG_PSW\t\t    0)\n+   (CTRLREG_USP\t\t    2)\n+   (CTRLREG_FPSW\t    3)\n+   (CTRLREG_CPEN\t    4)\n+   (CTRLREG_BPSW\t    8)\n+   (CTRLREG_BPC\t\t    9)\n+   (CTRLREG_ISP\t\t   10)\n+   (CTRLREG_FINTV\t   11)\n+   (CTRLREG_INTB\t   12)\n   ]\n )\n \n@@ -2145,7 +2155,17 @@\n     FAIL;\n })\n \f\n-;; Atomic exchange operation.\n+;; Atomic operations.\n+\n+(define_code_iterator FETCHOP [plus minus ior xor and])\n+\n+(define_code_attr fetchop_name\n+  [(plus \"add\") (minus \"sub\") (ior \"or\") (xor \"xor\") (and \"and\")])\n+\n+(define_code_attr fetchop_name2\n+  [(plus \"add\") (minus \"sub\") (ior \"ior\") (xor \"xor\") (and \"and\")])\n+\n+(define_mode_iterator QIHI [QI HI])\n \n (define_insn \"sync_lock_test_and_setsi\"\n   [(set (match_operand:SI 0 \"register_operand\"   \"=r,r\")\n@@ -2157,6 +2177,126 @@\n   [(set_attr \"length\" \"3,6\")\n    (set_attr \"timings\" \"22\")]\n )\n+\n+(define_expand \"atomic_exchange<mode>\"\n+  [(match_operand:QIHI 0 \"register_operand\")\t\t;; oldval output\n+   (match_operand:QIHI 1 \"rx_restricted_mem_operand\")\t;; memory\n+   (match_operand:QIHI 2 \"register_operand\")\t\t;; newval input\n+   (match_operand:QIHI 3 \"const_int_operand\")]\t\t;; memory model\n+  \"\"\n+{\n+  emit_insn (gen_xchg_mem<mode> (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"atomic_exchangesi\"\n+  [(match_operand:SI 0 \"register_operand\")\t\t;; oldval output\n+   (match_operand:SI 1 \"rx_restricted_mem_operand\")\t;; memory\n+   (match_operand:SI 2 \"register_operand\")\t\t;; newval input\n+   (match_operand:SI 3 \"const_int_operand\")]\t\t;; memory model\n+  \"\"\n+{\n+  emit_insn (gen_sync_lock_test_and_setsi (operands[0], operands[1],\n+\t\t\t\t\t   operands[2]));\n+  DONE;\n+})\n+\n+(define_insn \"xchg_mem<mode>\"\n+  [(set (match_operand:QIHI 0 \"register_operand\"   \"=r\")\n+\t(match_operand:QIHI 1 \"rx_compare_operand\" \"=Q\"))\n+   (set (match_dup 1)\n+\t(match_operand:QIHI 2 \"register_operand\"    \"0\"))]\n+  \"\"\n+  \"xchg\\t%1, %0\"\n+  [(set_attr \"length\" \"6\")\n+   (set_attr \"timings\" \"22\")]\n+)\n+\n+;; read - modify - write - return old value\n+(define_expand \"atomic_fetch_<fetchop_name>si\"\n+  [(set (match_operand:SI 0 \"register_operand\")\n+\t(match_operand:SI 1 \"memory_operand\"))\n+   (set (match_dup 1)\n+\t(FETCHOP:SI (match_dup 1) (match_operand:SI 2 \"rx_source_operand\")))\n+   (match_operand:SI 3 \"const_int_operand\")]\t\t;; memory model\n+  \"\"\n+{\n+  {\n+    rx_atomic_sequence seq (current_function_decl);\n+\n+    emit_move_insn (operands[0], operands[1]);\n+\n+    rtx tmp = gen_reg_rtx (SImode);\n+    emit_insn (gen_<fetchop_name2>si3 (tmp, operands[0], operands[2]));\n+\n+    emit_move_insn (operands[1], tmp);\n+  }\n+  DONE;\n+})\n+\n+(define_expand \"atomic_fetch_nandsi\"\n+  [(set (match_operand:SI 0 \"register_operand\")\n+\t(match_operand:SI 1 \"memory_operand\"))\n+   (set (match_dup 1)\n+\t(not:SI (and:SI (match_dup 1)\n+\t\t\t(match_operand:SI 2 \"rx_source_operand\"))))\n+   (match_operand:SI 3 \"const_int_operand\")]\t\t;; memory model\n+  \"\"\n+{\n+  {\n+    rx_atomic_sequence seq (current_function_decl);\n+\n+    emit_move_insn (operands[0], operands[1]);\n+\n+    rtx tmp = gen_reg_rtx (SImode);\n+    emit_insn (gen_andsi3 (tmp, operands[0], operands[2]));\n+    emit_insn (gen_one_cmplsi2 (tmp, tmp));\n+\n+    emit_move_insn (operands[1], tmp);\n+  }\n+  DONE;\n+})\n+\n+;; read - modify - write - return new value\n+(define_expand \"atomic_<fetchop_name>_fetchsi\"\n+  [(set (match_operand:SI 0 \"register_operand\")\n+\t(FETCHOP:SI (match_operand:SI 1 \"rx_restricted_mem_operand\")\n+\t\t    (match_operand:SI 2 \"register_operand\")))\n+   (set (match_dup 1)\n+\t(FETCHOP:SI (match_dup 1) (match_dup 2)))\n+   (match_operand:SI 3 \"const_int_operand\")]\t\t;; memory model\n+  \"\"\n+{\n+  {\n+    rx_atomic_sequence seq (current_function_decl);\n+\n+    emit_move_insn (operands[0], operands[2]);\n+    emit_insn (gen_<fetchop_name2>si3 (operands[0], operands[0], operands[1]));\n+    emit_move_insn (operands[1], operands[0]);\n+  }\n+  DONE;\n+})\n+\n+(define_expand \"atomic_nand_fetchsi\"\n+  [(set (match_operand:SI 0 \"register_operand\")\n+\t(not:SI (and:SI (match_operand:SI 1 \"rx_restricted_mem_operand\")\n+\t\t\t(match_operand:SI 2 \"register_operand\"))))\n+   (set (match_dup 1)\n+\t(not:SI (and:SI (match_dup 1) (match_dup 2))))\n+   (match_operand:SI 3 \"const_int_operand\")]\t\t;; memory model\n+  \"\"\n+{\n+  {\n+    rx_atomic_sequence seq (current_function_decl);\n+\n+    emit_move_insn (operands[0], operands[2]);\n+    emit_insn (gen_andsi3 (operands[0], operands[0], operands[1]));\n+    emit_insn (gen_one_cmplsi2 (operands[0], operands[0]));\n+    emit_move_insn (operands[1], operands[0]);\n+  }\n+  DONE;\n+});\n+\n \f\n ;; Block move functions.\n "}]}