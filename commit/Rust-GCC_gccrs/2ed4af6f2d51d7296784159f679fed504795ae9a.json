{"sha": "2ed4af6f2d51d7296784159f679fed504795ae9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVkNGFmNmYyZDUxZDcyOTY3ODQxNTlmNjc5ZmVkNTA0Nzk1YWU5YQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-09-24T23:58:24Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-09-24T23:58:24Z"}, "message": "ia64-protos.h: Update.\n\n        * config/ia64/ia64-protos.h: Update.\n        * config/ia64/ia64.c (call_multiple_values_operation): Remove.\n        (ia64_expand_call): New.\n        (ia64_expand_prologue): Emit an alloc if we need extra input\n        registers.\n        (ia64_expand_epilogue): New arg sibcall_p; don't emit the return\n        instruction if true.\n        (struct reg_flags): Add is_sibcall.\n        (rtx_needs_barrier): A sibcall does not use CFM et al.  Ignore USEs.\n        (emit_insn_group_barriers): Set flags.is_sibcall.  Remove hacks\n        for CODE_FOR_gr_spill_internal/CODE_FOR_gr_restore_internal.\n        * config/ia64/ia64.h (PREDICATE_CODES): Update.\n        * config/ia64/ia64.md (call): Use ia64_expand_call.\n        (call_value): Likewise.\n        (sibcall, sibcall_value): New.\n        (call patterns): Remove extra expanders; tidy.\n        (sibcall_epilogue): New.\n        (set_bsp): Remove the extra USE.  Put the operand inside the UNSPEC.\n\nFrom-SVN: r36597", "tree": {"sha": "0c89694b8d0f83f1d9acd7a8f89b00224260f6c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c89694b8d0f83f1d9acd7a8f89b00224260f6c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ed4af6f2d51d7296784159f679fed504795ae9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ed4af6f2d51d7296784159f679fed504795ae9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ed4af6f2d51d7296784159f679fed504795ae9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ed4af6f2d51d7296784159f679fed504795ae9a/comments", "author": null, "committer": null, "parents": [{"sha": "fd442cef30223941cf09068241580e3d8f3fb7ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd442cef30223941cf09068241580e3d8f3fb7ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd442cef30223941cf09068241580e3d8f3fb7ae"}], "stats": {"total": 516, "additions": 212, "deletions": 304}, "files": [{"sha": "aa4a660fd41072bede02a564324730d338acbf95", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed4af6f2d51d7296784159f679fed504795ae9a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed4af6f2d51d7296784159f679fed504795ae9a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2ed4af6f2d51d7296784159f679fed504795ae9a", "patch": "@@ -1,3 +1,24 @@\n+2000-09-24  Richard Henderson  <rth@cygnus.com>\n+\n+\t* config/ia64/ia64-protos.h: Update.\n+\t* config/ia64/ia64.c (call_multiple_values_operation): Remove.\n+\t(ia64_expand_call): New.\n+\t(ia64_expand_prologue): Emit an alloc if we need extra input\n+\tregisters.\n+\t(ia64_expand_epilogue): New arg sibcall_p; don't emit the return\n+\tinstruction if true.\n+\t(struct reg_flags): Add is_sibcall.\n+\t(rtx_needs_barrier): A sibcall does not use CFM et al.  Ignore USEs.\n+\t(emit_insn_group_barriers): Set flags.is_sibcall.  Remove hacks\n+\tfor CODE_FOR_gr_spill_internal/CODE_FOR_gr_restore_internal.\n+\t* config/ia64/ia64.h (PREDICATE_CODES): Update.\n+\t* config/ia64/ia64.md (call): Use ia64_expand_call.\n+\t(call_value): Likewise.\n+\t(sibcall, sibcall_value): New.\n+\t(call patterns): Remove extra expanders; tidy.\n+\t(sibcall_epilogue): New.\n+\t(set_bsp): Remove the extra USE.  Put the operand inside the UNSPEC.\n+\n 2000-09-24  Richard Henderson  <rth@cygnus.com>\n \n \t* emit-rtl.c (gen_lowpart_common): Use trunc_int_for_mode."}, {"sha": "839648cdf2cf72e2854a4f68b3ad2dcee3a31d3f", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed4af6f2d51d7296784159f679fed504795ae9a/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed4af6f2d51d7296784159f679fed504795ae9a/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=2ed4af6f2d51d7296784159f679fed504795ae9a", "patch": "@@ -57,7 +57,6 @@ extern int fr_reg_or_fp01_operand PARAMS((rtx, enum machine_mode));\n extern int normal_comparison_operator PARAMS((rtx, enum machine_mode));\n extern int adjusted_comparison_operator PARAMS((rtx, enum machine_mode));\n extern int signed_inequality_operator PARAMS((rtx, enum machine_mode));\n-extern int call_multiple_values_operation PARAMS((rtx, enum machine_mode));\n extern int destination_operand PARAMS((rtx, enum machine_mode));\n extern int not_postinc_memory_operand PARAMS((rtx, enum machine_mode));\n extern int predicate_operator PARAMS((rtx, enum machine_mode));\n@@ -73,10 +72,11 @@ extern rtx ia64_gp_save_reg PARAMS((int));\n extern rtx ia64_split_timode PARAMS((rtx[], rtx, rtx));\n extern rtx spill_tfmode_operand PARAMS((rtx, int));\n extern rtx ia64_expand_compare PARAMS((enum rtx_code, enum machine_mode));\n+extern void ia64_expand_call PARAMS((rtx, rtx, rtx, int));\n \n extern HOST_WIDE_INT ia64_initial_elimination_offset PARAMS((int, int));\n extern void ia64_expand_prologue PARAMS((void));\n-extern void ia64_expand_epilogue PARAMS((void));\n+extern void ia64_expand_epilogue PARAMS((int));\n extern void ia64_function_prologue PARAMS((FILE *, int));\n extern void ia64_function_epilogue PARAMS((FILE *, int));\n "}, {"sha": "a6de7843dfb8699e793d192e5ea237263bed5f18", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 103, "deletions": 58, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed4af6f2d51d7296784159f679fed504795ae9a/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed4af6f2d51d7296784159f679fed504795ae9a/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=2ed4af6f2d51d7296784159f679fed504795ae9a", "patch": "@@ -676,41 +676,6 @@ signed_inequality_operator (op, mode)\n \t      || code == LE || code == LT));\n }\n \n-/* Return 1 if OP is a call returning an HFA.  It is known to be a PARALLEL\n-   and the first section has already been tested.  */\n-\n-int\n-call_multiple_values_operation (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  int count = XVECLEN (op, 0) - 2;\n-  int i;\n-  unsigned int dest_regno;\n-\n-  /* Perform a quick check so we don't block up below.  */\n-  if (count <= 1\n-      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n-      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != REG\n-      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != CALL)\n-    return 0;\n-\n-  dest_regno = REGNO (SET_DEST (XVECEXP (op, 0, 0)));\n-\n-  for (i = 1; i < count; i++)\n-    {\n-      rtx elt = XVECEXP (op, 0, i + 2);\n-\n-      if (GET_CODE (elt) != SET\n-\t  || GET_CODE (SET_SRC (elt)) != CALL\n-\t  || GET_CODE (SET_DEST (elt)) != REG\n-\t  || REGNO (SET_DEST (elt)) != dest_regno + i)\n-\treturn 0;\n-    }\n-\n-  return 1;\n-}\n-\n /* Return 1 if this operator is valid for predication.  */\n \n int\n@@ -1044,6 +1009,98 @@ ia64_expand_compare (code, mode)\n \n   return gen_rtx_fmt_ee (code, mode, cmp, const0_rtx);\n }\n+\n+/* Emit the appropriate sequence for a call.  */\n+\n+void\n+ia64_expand_call (retval, addr, nextarg, sibcall_p)\n+     rtx retval;\n+     rtx addr;\n+     rtx nextarg;\n+     int sibcall_p;\n+{\n+  rtx insn, b0, gp_save, narg_rtx;\n+  int narg;\n+\n+  addr = XEXP (addr, 0);\n+  b0 = gen_rtx_REG (DImode, R_BR (0));\n+\n+  if (! nextarg)\n+    narg = 0;\n+  else if (IN_REGNO_P (REGNO (nextarg)))\n+    narg = REGNO (nextarg) - IN_REG (0);\n+  else\n+    narg = REGNO (nextarg) - OUT_REG (0);\n+  narg_rtx = GEN_INT (narg);\n+\n+  if (TARGET_NO_PIC || TARGET_AUTO_PIC)\n+    {\n+      if (sibcall_p)\n+\tinsn = gen_sibcall_nopic (addr, narg_rtx, b0);\n+      else if (! retval)\n+\tinsn = gen_call_nopic (addr, narg_rtx, b0);\n+      else\n+\tinsn = gen_call_value_nopic (retval, addr, narg_rtx, b0);\n+      emit_call_insn (insn);\n+      return;\n+    }\n+\n+  if (sibcall_p)\n+    gp_save = NULL_RTX;\n+  else\n+    gp_save = ia64_gp_save_reg (setjmp_operand (addr, VOIDmode));\n+\n+  /* If this is an indirect call, then we have the address of a descriptor.  */\n+  if (! symbolic_operand (addr, VOIDmode))\n+    {\n+      rtx dest;\n+\n+      if (! sibcall_p)\n+\temit_move_insn (gp_save, pic_offset_table_rtx);\n+\n+      dest = force_reg (DImode, gen_rtx_MEM (DImode, addr));\n+      emit_move_insn (pic_offset_table_rtx,\n+\t\t      gen_rtx_MEM (DImode, plus_constant (addr, 8)));\n+\n+      if (sibcall_p)\n+\tinsn = gen_sibcall_pic (dest, narg_rtx, b0);\n+      else if (! retval)\n+\tinsn = gen_call_pic (dest, narg_rtx, b0);\n+      else\n+\tinsn = gen_call_value_pic (retval, dest, narg_rtx, b0);\n+      emit_call_insn (insn);\n+\n+      if (! sibcall_p)\n+\temit_move_insn (pic_offset_table_rtx, gp_save);\n+    }\n+  else if (TARGET_CONST_GP)\n+    {\n+      if (sibcall_p)\n+\tinsn = gen_sibcall_nopic (addr, narg_rtx, b0);\n+      else if (! retval)\n+\tinsn = gen_call_nopic (addr, narg_rtx, b0);\n+      else\n+\tinsn = gen_call_value_nopic (retval, addr, narg_rtx, b0);\n+      emit_call_insn (insn);\n+    }\n+  else\n+    {\n+      if (sibcall_p)\n+\temit_call_insn (gen_sibcall_pic (addr, narg_rtx, b0));\n+      else\n+\t{\n+\t  emit_move_insn (gp_save, pic_offset_table_rtx);\n+\n+\t  if (! retval)\n+\t    insn = gen_call_pic (addr, narg_rtx, b0);\n+\t  else\n+\t    insn = gen_call_value_pic (retval, addr, narg_rtx, b0);\n+\t  emit_call_insn (insn);\n+\n+\t  emit_move_insn (pic_offset_table_rtx, gp_save);\n+\t}\n+    }\n+}\n \f\n /* Begin the assembly file.  */\n \n@@ -1819,7 +1876,8 @@ ia64_expand_prologue ()\n \n   /* We don't need an alloc instruction if we've used no outputs or locals.  */\n   if (current_frame_info.n_local_regs == 0\n-      && current_frame_info.n_output_regs == 0)\n+      && current_frame_info.n_output_regs == 0\n+      && current_frame_info.n_input_regs <= current_function_args_info.words)\n     {\n       /* If there is no alloc, but there are input registers used, then we\n \t need a .regstk directive.  */\n@@ -2090,7 +2148,8 @@ ia64_expand_prologue ()\n    insn to prevent such scheduling.  */\n \n void\n-ia64_expand_epilogue ()\n+ia64_expand_epilogue (sibcall_p)\n+     int sibcall_p;\n {\n   rtx insn, reg, alt_reg, ar_unat_save_reg;\n   int regno, alt_regno, cfa_off;\n@@ -2303,7 +2362,8 @@ ia64_expand_epilogue ()\n   if (cfun->machine->ia64_eh_epilogue_bsp)\n     emit_insn (gen_set_bsp (cfun->machine->ia64_eh_epilogue_bsp));\n  \n-  emit_jump_insn (gen_return_internal (gen_rtx_REG (DImode, BR_REG (0))));\n+  if (! sibcall_p)\n+    emit_jump_insn (gen_return_internal (gen_rtx_REG (DImode, BR_REG (0))));\n }\n \n /* Return 1 if br.ret can do all the work required to return from a\n@@ -3642,6 +3702,7 @@ struct reg_flags\n   unsigned int is_branch : 1;\t/* Is register used as part of a branch?  */\n   unsigned int is_and : 1;\t/* Is register used as part of and.orcm?  */\n   unsigned int is_or : 1;\t/* Is register used as part of or.andcm?  */\n+  unsigned int is_sibcall : 1;\t/* Is this a sibling or normal call?  */\n };\n \n static void rws_update PARAMS ((struct reg_write_state *, int,\n@@ -3935,9 +3996,7 @@ rtx_needs_barrier (x, flags, pred)\n \n       /* Avoid multiple register writes, in case this is a pattern with\n \t multiple CALL rtx.  This avoids an abort in rws_access_reg.  */\n-      /* ??? This assumes that no rtx other than CALL/RETURN sets REG_AR_CFM,\n-\t and that we don't have predicated calls/returns.  */\n-      if (! rws_insn[REG_AR_CFM].write_count)\n+      if (! flags.is_sibcall && ! rws_insn[REG_AR_CFM].write_count)\n \t{\n \t  new_flags.is_write = 1;\n \t  need_barrier |= rws_access_regno (REG_RP, new_flags, pred);\n@@ -3968,12 +4027,7 @@ rtx_needs_barrier (x, flags, pred)\n       return need_barrier;\n \n     case CLOBBER:\n-#if 0\n     case USE:\n-      /* We must handle USE here in case it occurs within a PARALLEL.\n-\t For instance, the mov ar.pfs= instruction has a USE which requires\n-\t a barrier between it and an immediately preceeding alloc.  */\n-#endif\n       /* Clobber & use are for earlier compiler-phases only.  */\n       break;\n \n@@ -4096,6 +4150,7 @@ rtx_needs_barrier (x, flags, pred)\n \t  break;\n \n \tcase 7: /* pred_rel_mutex */\n+\tcase 9: /* pic call */\n         case 12: /* mf */\n         case 19: /* fetchadd_acq */\n \tcase 20: /* mov = ar.bsp */\n@@ -4185,6 +4240,7 @@ rtx_needs_barrier (x, flags, pred)\n \t  default:\n \t    abort ();\n \t  }\n+      break;\n     }\n   return need_barrier;\n }\n@@ -4229,6 +4285,7 @@ emit_insn_group_barriers (insns)\n \n \tcase CALL_INSN:\n \t  flags.is_branch = 1;\n+\t  flags.is_sibcall = SIBLING_CALL_P (insn);\n \t  memset (rws_insn, 0, sizeof (rws_insn));\n \t  need_barrier = rtx_needs_barrier (PATTERN (insn), flags, 0);\n \n@@ -4300,18 +4357,6 @@ emit_insn_group_barriers (insns)\n \t\t  pat = XVECEXP (pat, 0, 1);\n \t\t  break;\n \n-\t\t  /* We include ar.unat in the rtl pattern so that sched2\n-\t\t     does not move the ar.unat save/restore after/before\n-\t\t     a gr spill/fill.  However, we special case these\n-\t\t     insns based on their unspec number so as to model\n-\t\t     their precise ar.unat bit operations.  If we pass on\n-\t\t     the use/clobber of the whole ar.unat register we'll\n-\t\t     waste this effort.  */\n-\t\tcase CODE_FOR_gr_spill_internal:\n-\t\tcase CODE_FOR_gr_restore_internal:\n-\t\t  pat = XVECEXP (pat, 0, 0);\n-\t\t  break;\n-\n \t\t  /* Doesn't generate code.  */\n \t\tcase CODE_FOR_pred_rel_mutex:\n \t\t  continue;"}, {"sha": "6126fa65debab5931fae55989a4b5bcae7677e42", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed4af6f2d51d7296784159f679fed504795ae9a/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed4af6f2d51d7296784159f679fed504795ae9a/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=2ed4af6f2d51d7296784159f679fed504795ae9a", "patch": "@@ -2697,7 +2697,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n { \"normal_comparison_operator\", {EQ, NE, GT, LE, GTU, LEU}},\t\t\\\n { \"adjusted_comparison_operator\", {LT, GE, LTU, GEU}},\t\t\t\\\n { \"signed_inequality_operator\", {GE, GT, LE, LT}},\t\t\t\\\n-{ \"call_multiple_values_operation\", {PARALLEL}},\t\t\t\\\n { \"predicate_operator\", {NE, EQ}},\t\t\t\t\t\\\n { \"ar_lc_reg_operand\", {REG}},\t\t\t\t\t\t\\\n { \"ar_ccv_reg_operand\", {REG}},\t\t\t\t\t\t\\"}, {"sha": "11b14c01fe03d48556746bcdeaae2c7ff6de699a", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 86, "deletions": 243, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed4af6f2d51d7296784159f679fed504795ae9a/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed4af6f2d51d7296784159f679fed504795ae9a/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=2ed4af6f2d51d7296784159f679fed504795ae9a", "patch": "@@ -62,6 +62,7 @@\n ;;\t5\trecip_approx\n ;;\t7\tpred_rel_mutex\n ;;\t8\tpopcnt\n+;;\t9\tpic call\n ;;\t12\tmf\n ;;\t13\tcmpxchg_acq\n ;;\t19\tfetchadd_acq\n@@ -4708,82 +4709,27 @@\n   \"\"\n   \"\n {\n-  /* ??? Stripping off the MEM isn't correct.  Will lose alias info.  */\n-  rtx addr = XEXP (operands[0], 0);\n-  enum machine_mode mode = GET_MODE (addr);\n-\n-  if (TARGET_NO_PIC || TARGET_AUTO_PIC)\n-    emit_call_insn (gen_call_internal (addr, operands[1],\n-\t\t\t\t       gen_rtx_REG (DImode, R_BR (0))));\n-\n-  /* If this is an indirect call, then we have the address of a descriptor.  */\n-  else if (! symbolic_operand (addr, mode))\n-    emit_insn (gen_indirect_call_pic (addr, operands[1]));\n-  else if (TARGET_CONST_GP)\n-    emit_call_insn (gen_call_internal (addr, operands[1],\n-\t\t\t\t       gen_rtx_REG (DImode, R_BR (0))));\n-  else\n-    emit_insn (gen_call_pic (addr, operands[1]));\n-\n+  ia64_expand_call (NULL_RTX, operands[0], operands[2], 0);\n   DONE;\n }\")\n \n-(define_expand \"indirect_call_pic\"\n-  [(set (match_dup 2) (reg:DI 1))\n-   (set (match_dup 3) (mem:DI (match_operand 0 \"\" \"\")))\n-   (set (match_dup 4) (plus:DI (match_dup 0) (const_int 8)))\n-   (set (reg:DI 1) (mem:DI (match_dup 4)))\n-   (parallel [(call (mem:DI (match_dup 3)) (match_operand 1 \"\" \"\"))\n-\t      (use (reg:DI 1))\n-\t      (clobber (reg:DI 320))])\n-   (set (reg:DI 1) (match_dup 2))]\n-  \"\"\n-  \"\n-{\n-  operands[2] = ia64_gp_save_reg (0);\n-  operands[3] = gen_reg_rtx (DImode);\n-  operands[4] = gen_reg_rtx (DImode);\n-}\")\n-\n-;; ??? Saving/restoring the GP register is not needed if we are calling\n-;; a function in the same module.\n-\n-(define_expand \"call_pic\"\n-  [(set (match_dup 2) (reg:DI 1))\n-   (parallel [(call (mem:DI (match_operand 0 \"\" \"\")) (match_operand 1 \"\" \"\"))\n-\t      (use (reg:DI 1))\n-\t      (clobber (reg:DI 320))])\n-   (set (reg:DI 1) (match_dup 2))]\n+(define_expand \"sibcall\"\n+  [(use (match_operand:DI 0 \"\" \"\"))\n+   (use (match_operand 1 \"\" \"\"))\n+   (use (match_operand 2 \"\" \"\"))\n+   (use (match_operand 3 \"\" \"\"))]\n   \"\"\n   \"\n {\n-  /* ??? Using setjmp_operand is an unsatisfying solution.  Should rethink.  */\n-  operands[2] = ia64_gp_save_reg (setjmp_operand (XEXP (operands[0], 0),\n-\t\t\t\t\t\t  VOIDmode));\n+  ia64_expand_call (NULL_RTX, operands[0], operands[2], 1);\n+  DONE;\n }\")\n \n-(define_insn \"call_internal\"\n-  [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"bi\"))\n-\t (match_operand 1 \"\" \"\"))\n-   (clobber (match_operand:DI 2 \"register_operand\" \"=b\"))]\n-  \"\"\n-  \"br.call%+.many %2 = %0\"\n-  [(set_attr \"type\" \"B\")])\n-\n-(define_insn \"*call_internal1\"\n-  [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"bi\"))\n-\t (match_operand 1 \"\" \"\"))\n-   (use (reg:DI 1))\n-   (clobber (match_operand:DI 2 \"register_operand\" \"=b\"))]\n-  \"\"\n-  \"br.call%+.many %2 = %0\"\n-  [(set_attr \"type\" \"B\")])\n-\n ;; Subroutine call instruction returning a value.  Operand 0 is the hard\n-;; register in which the value is returned.  There are three more operands, the\n-;; same as the three operands of the `call' instruction (but with numbers\n+;; register in which the value is returned.  There are three more operands,\n+;; the same as the three operands of the `call' instruction (but with numbers\n ;; increased by one).\n-\n+;;\n ;; Subroutines that return `BLKmode' objects use the `call' insn.\n \n (define_expand \"call_value\"\n@@ -4795,187 +4741,23 @@\n   \"\"\n   \"\n {\n-  /* ??? Stripping off the MEM isn't correct.  Will lose alias info.  */\n-  rtx addr = XEXP (operands[1], 0);\n-  enum machine_mode mode = GET_MODE (addr);\n-\n-  if (TARGET_NO_PIC || TARGET_AUTO_PIC)\n-    emit_call_insn (gen_call_value_internal (operands[0], addr, operands[2],\n-\t\t\t\t\t     gen_rtx_REG (DImode, R_BR (0))));\n-\n-  /* If this is an indirect call, then we have the address of a descriptor.  */\n-  else if (! symbolic_operand (addr, mode))\n-    {\n-      /* This is for HFA returns.  */\n-      if (GET_CODE (operands[0]) == PARALLEL)\n-\temit_insn (gen_indirect_call_multiple_values_pic (operands[0], addr,\n-\t\t\t\t\t\t\t  operands[2]));\n-      else\n-\temit_insn (gen_indirect_call_value_pic (operands[0], addr,\n-\t\t\t\t\t\toperands[2]));\n-    }\n-  else if (TARGET_CONST_GP)\n-    emit_call_insn (gen_call_value_internal (operands[0], addr, operands[2],\n-\t\t\t\t\t     gen_rtx_REG (DImode, R_BR (0))));\n-  /* This is for HFA returns.  */\n-  else if (GET_CODE (operands[0]) == PARALLEL)\n-    emit_insn (gen_call_multiple_values_pic (operands[0], addr, operands[2]));\n-  else\n-    emit_insn (gen_call_value_pic (operands[0], addr, operands[2]));\n-\n+  ia64_expand_call (operands[0], operands[1], operands[3], 0);\n   DONE;\n }\")\n \n-(define_expand \"indirect_call_value_pic\"\n-  [(set (match_dup 3) (reg:DI 1))\n-   (set (match_dup 4) (mem:DI (match_operand 1 \"\" \"\")))\n-   (set (match_dup 5) (plus:DI (match_dup 1) (const_int 8)))\n-   (set (reg:DI 1) (mem:DI (match_dup 5)))\n-   (parallel [(set (match_operand 0 \"\" \"\")\n-\t\t   (call (mem:DI (match_dup 4)) (match_operand 2 \"\" \"\")))\n-\t      (use (reg:DI 1))\n-\t      (clobber (reg:DI 320))])\n-   (set (reg:DI 1) (match_dup 3))]\n-  \"\"\n-  \"\n-{\n-  operands[3] = ia64_gp_save_reg (0);\n-  operands[4] = gen_reg_rtx (DImode);\n-  operands[5] = gen_reg_rtx (DImode);\n-}\")\n-\n-(define_expand \"indirect_call_multiple_values_pic\"\n-  [(set (match_dup 3) (reg:DI 1))\n-   (set (match_dup 4) (mem:DI (match_operand 1 \"\" \"\")))\n-   (set (match_dup 5) (plus:DI (match_dup 1) (const_int 8)))\n-   (set (reg:DI 1) (mem:DI (match_dup 5)))\n-   (match_par_dup 6 [(set (match_operand 0 \"\" \"\")\n-\t\t\t  (call (mem:DI (match_dup 4))\n-\t\t\t\t(match_operand 2 \"\" \"\")))\n-\t\t     (use (reg:DI 1))\n-\t\t     (clobber (reg:DI 320))])\n-   (set (reg:DI 1) (match_dup 3))]\n-  \"\"\n-  \"\n-{\n-  int count;\n-  int i;\n-  rtx call;\n-\n-  operands[3] = ia64_gp_save_reg (0);\n-  operands[4] = gen_reg_rtx (DImode);\n-  operands[5] = gen_reg_rtx (DImode);\n-\n-  /* This code is the same as the code in call_multiple_values_pic, except\n-     that op3 was replaced with op6 and op1 was replaced with op4.  */\n-  call = gen_rtx_CALL (VOIDmode, gen_rtx_MEM (DImode, operands[4]),\n-\t\t       operands[2]);\n-\n-  count = XVECLEN (operands[0], 0);\n-  operands[6] = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count + 2));\n-  \n-  XVECEXP (operands[6], 0, 0)\n-    = gen_rtx_SET (VOIDmode, XEXP (XVECEXP (operands[0], 0, 0), 0), call);\n-\n-  XVECEXP (operands[6], 0, 1)\n-    = gen_rtx_USE (DImode, gen_rtx_REG (DImode, GR_REG (1)));\n-  XVECEXP (operands[6], 0, 2)\n-    = gen_rtx_CLOBBER (DImode, gen_rtx_REG (DImode, BR_REG (0)));\n-\n-  for (i = 1; i < count; i++)\n-    XVECEXP (operands[6], 0, i + 2)\n-      = gen_rtx_SET (VOIDmode, XEXP (XVECEXP (operands[0], 0, i), 0), call);\n-\n-}\")\n-\n-;; ??? Saving/restoring the GP register is not needed if we are calling\n-;; a function in the same module.\n-\n-(define_expand \"call_value_pic\"\n-  [(set (match_dup 3) (reg:DI 1))\n-   (parallel [(set (match_operand 0 \"\" \"\")\n-\t\t   (call (mem:DI (match_operand 1 \"\" \"\"))\n-\t\t\t (match_operand 2 \"\" \"\")))\n-\t      (use (reg:DI 1))\n-\t      (clobber (reg:DI 320))])\n-   (set (reg:DI 1) (match_dup 3))]\n-  \"\"\n-  \"\n-{\n-  /* ??? Using setjmp_operand is an unsatisfying solution.  Should rethink.  */\n-  operands[3] = ia64_gp_save_reg (setjmp_operand (XEXP (operands[1], 0),\n-\t\t\t\t\t\t  VOIDmode));\n-}\")\n-\n-;; ??? Saving/restoring the GP register is not needed if we are calling\n-;; a function in the same module.\n-\n-(define_expand \"call_multiple_values_pic\"\n-  [(set (match_dup 4) (reg:DI 1))\n-   (match_par_dup 3 [(set (match_operand 0 \"\" \"\")\n-\t\t\t  (call (mem:DI (match_operand 1 \"\" \"\"))\n-\t\t\t\t(match_operand 2 \"\" \"\")))\n-\t\t     (use (reg:DI 1))\n-\t\t     (clobber (reg:DI 320))])\n-   (set (reg:DI 1) (match_dup 4))]\n+(define_expand \"sibcall_value\"\n+  [(use (match_operand 0 \"\" \"\"))\n+   (use (match_operand:DI 1 \"\" \"\"))\n+   (use (match_operand 2 \"\" \"\"))\n+   (use (match_operand 3 \"\" \"\"))\n+   (use (match_operand 4 \"\" \"\"))]\n   \"\"\n   \"\n {\n-  int count;\n-  int i;\n-  rtx call;\n-\n-  operands[4] = ia64_gp_save_reg (0);\n-\n-  call = gen_rtx_CALL (VOIDmode, gen_rtx_MEM (DImode, operands[1]),\n-\t\t       operands[2]);\n-\n-  count = XVECLEN (operands[0], 0);\n-  operands[3] = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count + 2));\n-  \n-  XVECEXP (operands[3], 0, 0)\n-    = gen_rtx_SET (VOIDmode, XEXP (XVECEXP (operands[0], 0, 0), 0), call);\n-\n-  XVECEXP (operands[3], 0, 1)\n-    = gen_rtx_USE (DImode, gen_rtx_REG (DImode, GR_REG (1)));\n-  XVECEXP (operands[3], 0, 2)\n-    = gen_rtx_CLOBBER (DImode, gen_rtx_REG (DImode, BR_REG (0)));\n-\n-  for (i = 1; i < count; i++)\n-    XVECEXP (operands[3], 0, i + 2)\n-      = gen_rtx_SET (VOIDmode, XEXP (XVECEXP (operands[0], 0, i), 0), call);\n+  ia64_expand_call (operands[0], operands[1], operands[3], 1);\n+  DONE;\n }\")\n \n-(define_insn \"call_value_internal\"\n-  [(set (match_operand 0 \"register_operand\" \"=rf\")\n-\t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"bi\"))\n-\t      (match_operand 2 \"\" \"\")))\n-   (clobber (match_operand:DI 3 \"register_operand\" \"=b\"))]\n-  \"\"\n-  \"br.call%+.many %3 = %1\"\n-  [(set_attr \"type\" \"B\")])\n-\n-(define_insn \"*call_value_internal1\"\n-  [(set (match_operand 0 \"register_operand\" \"=rf\")\n-\t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"bi\"))\n-\t      (match_operand 2 \"\" \"\")))\n-   (use (reg:DI 1))\n-   (clobber (match_operand:DI 3 \"register_operand\" \"=b\"))]\n-  \"\"\n-  \"br.call%+.many %3 = %1\"\n-  [(set_attr \"type\" \"B\")])\n-\n-(define_insn \"*call_multiple_values_internal1\"\n-  [(match_parallel 0 \"call_multiple_values_operation\"\n-\t\t   [(set (match_operand 1 \"register_operand\" \"=rf\")\n-\t\t\t (call (mem:DI (match_operand:DI 2 \"call_operand\" \"bi\"))\n-\t\t\t       (match_operand 3 \"\" \"\")))\n-\t\t    (use (reg:DI 1))\n-\t\t    (clobber (match_operand:DI 4 \"register_operand\" \"=b\"))])]\n-  \"\"\n-  \"br.call%+.many %4 = %2\"\n-  [(set_attr \"type\" \"B\")])\n-\n ;; Call subroutine returning any type.\n \n (define_expand \"untyped_call\"\n@@ -5005,6 +4787,59 @@\n   DONE;\n }\")\n \n+(define_insn \"call_nopic\"\n+  [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"bi\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (clobber (match_operand:DI 2 \"register_operand\" \"=b\"))]\n+  \"\"\n+  \"br.call%+.many %2 = %0\"\n+  [(set_attr \"type\" \"B\")])\n+\n+(define_insn \"call_value_nopic\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"bi\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (clobber (match_operand:DI 3 \"register_operand\" \"=b\"))]\n+  \"\"\n+  \"br.call%+.many %3 = %1\"\n+  [(set_attr \"type\" \"B\")])\n+\n+(define_insn \"sibcall_nopic\"\n+  [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"bi\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (use (match_operand:DI 2 \"register_operand\" \"=b\"))]\n+  \"\"\n+  \"br%+.many %0\"\n+  [(set_attr \"type\" \"B\")])\n+\n+(define_insn \"call_pic\"\n+  [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"bi\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (use (unspec [(reg:DI 1)] 9))\n+   (clobber (match_operand:DI 2 \"register_operand\" \"=b\"))]\n+  \"\"\n+  \"br.call%+.many %2 = %0\"\n+  [(set_attr \"type\" \"B\")])\n+\n+(define_insn \"call_value_pic\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"bi\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (use (unspec [(reg:DI 1)] 9))\n+   (clobber (match_operand:DI 3 \"register_operand\" \"=b\"))]\n+  \"\"\n+  \"br.call%+.many %3 = %1\"\n+  [(set_attr \"type\" \"B\")])\n+\n+(define_insn \"sibcall_pic\"\n+  [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"bi\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (use (unspec [(reg:DI 1)] 9))\n+   (use (match_operand:DI 2 \"register_operand\" \"=b\"))]\n+  \"\"\n+  \"br%+.many %0\"\n+  [(set_attr \"type\" \"B\")])\n+\n (define_insn \"return_internal\"\n   [(return)\n    (use (match_operand:DI 0 \"register_operand\" \"b\"))]\n@@ -5093,11 +4928,20 @@\n }\")\n \n (define_expand \"epilogue\"\n-  [(const_int 2)]\n+  [(return)]\n+  \"\"\n+  \"\n+{\n+  ia64_expand_epilogue (0);\n+  DONE;\n+}\")\n+\n+(define_expand \"sibcall_epilogue\"\n+  [(return)]\n   \"\"\n   \"\n {\n-  ia64_expand_epilogue ();\n+  ia64_expand_epilogue (1);\n   DONE;\n }\")\n \n@@ -5200,8 +5044,7 @@\n   [(set_attr \"type\" \"I\")])\n \n (define_insn \"set_bsp\"\n-  [(unspec_volatile [(const_int 0)] 5)\n-   (use (match_operand:DI 0 \"register_operand\" \"r\"))]\n+  [(unspec_volatile [(match_operand:DI 0 \"register_operand\" \"r\")] 5)]\n   \"\"\n   \"flushrs\\;mov r19=ar.rsc\\;;;\\;and r19=0x1c,r19\\;;;\\;mov ar.rsc=r19\\;;;\\;mov ar.bspstore=%0\\;;;\\;or r19=0x3,r19\\;;;\\;loadrs\\;invala\\;;;\\;mov ar.rsc=r19\"\n   [(set_attr \"type\" \"unknown\")"}]}