{"sha": "9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU4NzhjZjFiYWU3ZWJhM2EwOTdkYmI2YjA0ZDBiYmNhNWJkYjBlNA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2017-10-19T15:58:05Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2017-10-19T15:58:05Z"}, "message": "asan.c (handle_builtin_alloca): Deal with all alloca variants.\n\n\t* asan.c (handle_builtin_alloca): Deal with all alloca variants.\n\t(get_mem_refs_of_builtin_call): Likewise.\n\t* builtins.c (expand_builtin_apply): Adjust call to\n\tallocate_dynamic_stack_space.\n\t(expand_builtin_alloca): For __builtin_alloca_with_align_and_max, pass\n\tthe third argument to allocate_dynamic_stack_space, otherwise -1.\n\t(expand_builtin): Deal with all alloca variants.\n\t(is_inexpensive_builtin): Likewise.\n\t* builtins.def (BUILT_IN_ALLOCA_WITH_ALIGN_AND_MAX): New.\n\t* calls.c (special_function_p): Deal with all alloca variants.\n\t(initialize_argument_information): Adjust call to\n\tallocate_dynamic_stack_space.\n\t(expand_call): Likewise.\n\t* cfgexpand.c (expand_call_stmt): Deal with all alloca variants.\n\t* doc/extend.texi (Built-ins): Add __builtin_alloca_with_align_and_max\n\t* explow.c (allocate_dynamic_stack_space): Add MAX_SIZE parameter and\n\tuse it for the stack usage computation.\n\t* explow.h (allocate_dynamic_stack_space): Adjust prototype.\n\t* function.c (gimplify_parameters): Turn BUILT_IN_ALLOCA_WITH_ALIGN\n\tinto BUILT_IN_ALLOCA_WITH_ALIGN_AND_MAX and pass maximum size.\n\t* gimple-ssa-warn-alloca.c (alloca_call_type): Simplify control flow.\n\tTake into account 3rd argument of __builtin_alloca_with_align_and_max.\n\t(in_loop_p): Remove first argument and useless check.\n\t(pass_walloca::execute): Remove useless test and adjust call to above.\n\t* gimple.c (gimple_build_call_from_tree): Deal with all alloc variants\n\t* gimplify.c (gimplify_vla_decl): Turn BUILT_IN_ALLOCA_WITH_ALIGN into\n\tBUILT_IN_ALLOCA_WITH_ALIGN_AND_MAX and pass maximum size.\n\t(gimplify_call_expr): Deal with all alloca variants.\n\t* hsa-gen.c (gen_hsa_alloca): Likewise.\n\t(gen_hsa_insns_for_call): Likewise.\n\t* ipa-pure-const.c (special_builtin_state): Likewise.\n\t* tree-chkp.c (chkp_build_returned_bound): Likewise.\n\t* tree-object-size.c (alloc_object_size): Likewise.\n\t* tree-ssa-alias.c (ref_maybe_used_by_call_p_1): Likewise.\n\t(call_may_clobber_ref_p_1): Likewise.\n\t* tree-ssa-ccp.c (evaluate_stmt): Likewise.\n\t(ccp_fold_stmt): Likewise.\n\t(optimize_stack_restore): Likewise.\n\t* tree-ssa-dce.c (mark_stmt_if_obviously_necessary): Likewise.\n\t(mark_all_reaching_defs_necessary_1): Likewise.\n\t(propagate_necessity): Likewise.\n\t(eliminate_unnecessary_stmts): Likewise.\n\t* tree.c (build_common_builtin_nodes): Build\n\tBUILT_IN_ALLOCA_WITH_ALIGN_AND_MAX.\n\t* tree.h (ALLOCA_FUNCTION_CODE_P): New macro.\n\t(CASE_BUILT_IN_ALLOCA): Likewise.\n\t* varasm.c (incorporeal_function_p): Deal with all alloca variants.\nc-family/\n\t* c-common.c (check_builtin_function_arguments): Also check arguments\n\tof __builtin_alloca_with_align_and_max.\n\nFrom-SVN: r253901", "tree": {"sha": "220024bc6525d567df9a66f538a7903a174bcadc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/220024bc6525d567df9a66f538a7903a174bcadc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/comments", "author": null, "committer": null, "parents": [{"sha": "d969783705f55506c111e4f4d0342b09ef301ea2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d969783705f55506c111e4f4d0342b09ef301ea2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d969783705f55506c111e4f4d0342b09ef301ea2"}], "stats": {"total": 425, "additions": 288, "deletions": 137}, "files": [{"sha": "c63d73424a73343e228a795748e87664ed33aed1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "patch": "@@ -1,3 +1,53 @@\n+2017-10-19  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* asan.c (handle_builtin_alloca): Deal with all alloca variants.\n+\t(get_mem_refs_of_builtin_call): Likewise.\n+\t* builtins.c (expand_builtin_apply): Adjust call to\n+\tallocate_dynamic_stack_space.\n+\t(expand_builtin_alloca): For __builtin_alloca_with_align_and_max, pass\n+\tthe third argument to allocate_dynamic_stack_space, otherwise -1.\n+\t(expand_builtin): Deal with all alloca variants.\n+\t(is_inexpensive_builtin): Likewise.\n+\t* builtins.def (BUILT_IN_ALLOCA_WITH_ALIGN_AND_MAX): New.\n+\t* calls.c (special_function_p): Deal with all alloca variants.\n+\t(initialize_argument_information): Adjust call to\n+\tallocate_dynamic_stack_space.\n+\t(expand_call): Likewise.\n+\t* cfgexpand.c (expand_call_stmt): Deal with all alloca variants.\n+\t* doc/extend.texi (Built-ins): Add __builtin_alloca_with_align_and_max\n+\t* explow.c (allocate_dynamic_stack_space): Add MAX_SIZE parameter and\n+\tuse it for the stack usage computation.\n+\t* explow.h (allocate_dynamic_stack_space): Adjust prototype.\n+\t* function.c (gimplify_parameters): Turn BUILT_IN_ALLOCA_WITH_ALIGN\n+\tinto BUILT_IN_ALLOCA_WITH_ALIGN_AND_MAX and pass maximum size.\n+\t* gimple-ssa-warn-alloca.c (alloca_call_type): Simplify control flow.\n+\tTake into account 3rd argument of __builtin_alloca_with_align_and_max.\n+\t(in_loop_p): Remove first argument and useless check.\n+\t(pass_walloca::execute): Remove useless test and adjust call to above.\n+\t* gimple.c (gimple_build_call_from_tree): Deal with all alloc variants\n+\t* gimplify.c (gimplify_vla_decl): Turn BUILT_IN_ALLOCA_WITH_ALIGN into\n+\tBUILT_IN_ALLOCA_WITH_ALIGN_AND_MAX and pass maximum size.\n+\t(gimplify_call_expr): Deal with all alloca variants.\n+\t* hsa-gen.c (gen_hsa_alloca): Likewise.\n+\t(gen_hsa_insns_for_call): Likewise.\n+\t* ipa-pure-const.c (special_builtin_state): Likewise.\n+\t* tree-chkp.c (chkp_build_returned_bound): Likewise.\n+\t* tree-object-size.c (alloc_object_size): Likewise.\n+\t* tree-ssa-alias.c (ref_maybe_used_by_call_p_1): Likewise.\n+\t(call_may_clobber_ref_p_1): Likewise.\n+\t* tree-ssa-ccp.c (evaluate_stmt): Likewise.\n+\t(ccp_fold_stmt): Likewise.\n+\t(optimize_stack_restore): Likewise.\n+\t* tree-ssa-dce.c (mark_stmt_if_obviously_necessary): Likewise.\n+\t(mark_all_reaching_defs_necessary_1): Likewise.\n+\t(propagate_necessity): Likewise.\n+\t(eliminate_unnecessary_stmts): Likewise.\n+\t* tree.c (build_common_builtin_nodes): Build\n+\tBUILT_IN_ALLOCA_WITH_ALIGN_AND_MAX.\n+\t* tree.h (ALLOCA_FUNCTION_CODE_P): New macro.\n+\t(CASE_BUILT_IN_ALLOCA): Likewise.\n+\t* varasm.c (incorporeal_function_p): Deal with all alloca variants.\n+\n 2017-10-19  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR debug/82509"}, {"sha": "be8b79e3554fcd3581b7fcc238aa81693a210d23", "filename": "gcc/asan.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "patch": "@@ -628,10 +628,9 @@ handle_builtin_alloca (gcall *call, gimple_stmt_iterator *iter)\n   tree ptr_type = gimple_call_lhs (call) ? TREE_TYPE (gimple_call_lhs (call))\n \t\t\t\t\t : ptr_type_node;\n   tree partial_size = NULL_TREE;\n-  bool alloca_with_align\n-    = DECL_FUNCTION_CODE (callee) == BUILT_IN_ALLOCA_WITH_ALIGN;\n   unsigned int align\n-    = alloca_with_align ? tree_to_uhwi (gimple_call_arg (call, 1)) : 0;\n+    = DECL_FUNCTION_CODE (callee) == BUILT_IN_ALLOCA\n+      ? 0 : tree_to_uhwi (gimple_call_arg (call, 1));\n \n   /* If ALIGN > ASAN_RED_ZONE_SIZE, we embed left redzone into first ALIGN\n      bytes of allocated space.  Otherwise, align alloca to ASAN_RED_ZONE_SIZE\n@@ -793,8 +792,7 @@ get_mem_refs_of_builtin_call (gcall *call,\n       handle_builtin_stack_restore (call, iter);\n       break;\n \n-    case BUILT_IN_ALLOCA_WITH_ALIGN:\n-    case BUILT_IN_ALLOCA:\n+    CASE_BUILT_IN_ALLOCA:\n       handle_builtin_alloca (call, iter);\n       break;\n     /* And now the __atomic* and __sync builtins."}, {"sha": "d3498bb16c47995e68a0d6406ecf6f3d227ce74e", "filename": "gcc/builtins.c", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "patch": "@@ -1609,7 +1609,7 @@ expand_builtin_apply (rtx function, rtx arguments, rtx argsize)\n      arguments to the outgoing arguments address.  We can pass TRUE\n      as the 4th argument because we just saved the stack pointer\n      and will restore it right after the call.  */\n-  allocate_dynamic_stack_space (argsize, 0, BIGGEST_ALIGNMENT, true);\n+  allocate_dynamic_stack_space (argsize, 0, BIGGEST_ALIGNMENT, -1, true);\n \n   /* Set DRAP flag to true, even though allocate_dynamic_stack_space\n      may have already set current_function_calls_alloca to true.\n@@ -4858,19 +4858,22 @@ expand_builtin_alloca (tree exp)\n   rtx result;\n   unsigned int align;\n   tree fndecl = get_callee_fndecl (exp);\n-  bool alloca_with_align = (DECL_FUNCTION_CODE (fndecl)\n-\t\t\t    == BUILT_IN_ALLOCA_WITH_ALIGN);\n+  HOST_WIDE_INT max_size;\n+  enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n   bool alloca_for_var = CALL_ALLOCA_FOR_VAR_P (exp);\n   bool valid_arglist\n-    = (alloca_with_align\n-       ? validate_arglist (exp, INTEGER_TYPE, INTEGER_TYPE, VOID_TYPE)\n-       : validate_arglist (exp, INTEGER_TYPE, VOID_TYPE));\n+    = (fcode == BUILT_IN_ALLOCA_WITH_ALIGN_AND_MAX\n+       ? validate_arglist (exp, INTEGER_TYPE, INTEGER_TYPE, INTEGER_TYPE,\n+\t\t\t   VOID_TYPE)\n+       : fcode == BUILT_IN_ALLOCA_WITH_ALIGN\n+\t ? validate_arglist (exp, INTEGER_TYPE, INTEGER_TYPE, VOID_TYPE)\n+\t : validate_arglist (exp, INTEGER_TYPE, VOID_TYPE));\n \n   if (!valid_arglist)\n     return NULL_RTX;\n \n-  if ((alloca_with_align && !warn_vla_limit)\n-      || (!alloca_with_align && !warn_alloca_limit))\n+  if ((alloca_for_var && !warn_vla_limit)\n+      || (!alloca_for_var && !warn_alloca_limit))\n     {\n       /* -Walloca-larger-than and -Wvla-larger-than settings override\n \t the more general -Walloc-size-larger-than so unless either of\n@@ -4885,13 +4888,19 @@ expand_builtin_alloca (tree exp)\n   op0 = expand_normal (CALL_EXPR_ARG (exp, 0));\n \n   /* Compute the alignment.  */\n-  align = (alloca_with_align\n-\t   ? TREE_INT_CST_LOW (CALL_EXPR_ARG (exp, 1))\n-\t   : BIGGEST_ALIGNMENT);\n+  align = (fcode == BUILT_IN_ALLOCA\n+\t   ? BIGGEST_ALIGNMENT\n+\t   : TREE_INT_CST_LOW (CALL_EXPR_ARG (exp, 1)));\n+\n+  /* Compute the maximum size.  */\n+  max_size = (fcode == BUILT_IN_ALLOCA_WITH_ALIGN_AND_MAX\n+              ? TREE_INT_CST_LOW (CALL_EXPR_ARG (exp, 2))\n+              : -1);\n \n   /* Allocate the desired space.  If the allocation stems from the declaration\n      of a variable-sized object, it cannot accumulate.  */\n-  result = allocate_dynamic_stack_space (op0, 0, align, alloca_for_var);\n+  result\n+    = allocate_dynamic_stack_space (op0, 0, align, max_size, alloca_for_var);\n   result = convert_memory_address (ptr_mode, result);\n \n   return result;\n@@ -6482,8 +6491,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n       && fcode != BUILT_IN_EXECLE\n       && fcode != BUILT_IN_EXECVP\n       && fcode != BUILT_IN_EXECVE\n-      && fcode != BUILT_IN_ALLOCA\n-      && fcode != BUILT_IN_ALLOCA_WITH_ALIGN\n+      && !ALLOCA_FUNCTION_CODE_P (fcode)\n       && fcode != BUILT_IN_FREE\n       && fcode != BUILT_IN_CHKP_SET_PTR_BOUNDS\n       && fcode != BUILT_IN_CHKP_INIT_PTR_BOUNDS\n@@ -6712,8 +6720,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n       else\n \treturn XEXP (DECL_RTL (DECL_RESULT (current_function_decl)), 0);\n \n-    case BUILT_IN_ALLOCA:\n-    case BUILT_IN_ALLOCA_WITH_ALIGN:\n+    CASE_BUILT_IN_ALLOCA:\n       target = expand_builtin_alloca (exp);\n       if (target)\n \treturn target;\n@@ -10425,8 +10432,7 @@ is_inexpensive_builtin (tree decl)\n     switch (DECL_FUNCTION_CODE (decl))\n       {\n       case BUILT_IN_ABS:\n-      case BUILT_IN_ALLOCA:\n-      case BUILT_IN_ALLOCA_WITH_ALIGN:\n+      CASE_BUILT_IN_ALLOCA:\n       case BUILT_IN_BSWAP16:\n       case BUILT_IN_BSWAP32:\n       case BUILT_IN_BSWAP64:"}, {"sha": "880259422065734604ea82cf27e9753ee8b1c996", "filename": "gcc/builtins.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "patch": "@@ -921,6 +921,7 @@ DEF_BUILTIN_STUB (BUILT_IN_SETJMP_RECEIVER, \"__builtin_setjmp_receiver\")\n DEF_BUILTIN_STUB (BUILT_IN_STACK_SAVE, \"__builtin_stack_save\")\n DEF_BUILTIN_STUB (BUILT_IN_STACK_RESTORE, \"__builtin_stack_restore\")\n DEF_BUILTIN_STUB (BUILT_IN_ALLOCA_WITH_ALIGN, \"__builtin_alloca_with_align\")\n+DEF_BUILTIN_STUB (BUILT_IN_ALLOCA_WITH_ALIGN_AND_MAX, \"__builtin_alloca_with_align_and_max\")\n \n /* An internal version of memcmp, used when the result is only tested for\n    equality with zero.  */"}, {"sha": "963c79a7e2b95296d83feee37f69fb8522bd7820", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "patch": "@@ -1,3 +1,8 @@\n+2017-10-19  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* c-common.c (check_builtin_function_arguments): Also check arguments\n+\tof __builtin_alloca_with_align_and_max.\n+\n 2017-10-17  David Malcolm  <dmalcolm@redhat.com>\n \n \t* c-format.c (format_warning_at_char): Pass UNKNOWN_LOCATION"}, {"sha": "8f36c77967faaa942808549264fc6721fa940d5a", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "patch": "@@ -5695,6 +5695,16 @@ check_builtin_function_arguments (location_t loc, vec<location_t> arg_loc,\n \n   switch (DECL_FUNCTION_CODE (fndecl))\n     {\n+    case BUILT_IN_ALLOCA_WITH_ALIGN_AND_MAX:\n+      if (!tree_fits_uhwi_p (args[2]))\n+\t{\n+\t  error_at (ARG_LOCATION (2),\n+\t\t    \"third argument to function %qE must be a constant integer\",\n+\t\t    fndecl);\n+\t  return false;\n+\t}\n+      /* fall through */\n+\n     case BUILT_IN_ALLOCA_WITH_ALIGN:\n       {\n \t/* Get the requested alignment (in bits) if it's a constant"}, {"sha": "3730f43c7a9640de804683aea6cb72383b61f7ec", "filename": "gcc/calls.c", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "patch": "@@ -607,16 +607,9 @@ special_function_p (const_tree fndecl, int flags)\n \tflags |= ECF_RETURNS_TWICE;\n     }\n \n-  if (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n-    switch (DECL_FUNCTION_CODE (fndecl))\n-      {\n-      case BUILT_IN_ALLOCA:\n-      case BUILT_IN_ALLOCA_WITH_ALIGN:\n-\tflags |= ECF_MAY_BE_ALLOCA;\n-\tbreak;\n-      default:\n-\tbreak;\n-      }\n+  if (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n+      && ALLOCA_FUNCTION_CODE_P (DECL_FUNCTION_CODE (fndecl)))\n+    flags |= ECF_MAY_BE_ALLOCA;\n \n   return flags;\n }\n@@ -698,8 +691,7 @@ gimple_alloca_call_p (const gimple *stmt)\n   if (fndecl && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n     switch (DECL_FUNCTION_CODE (fndecl))\n       {\n-      case BUILT_IN_ALLOCA:\n-      case BUILT_IN_ALLOCA_WITH_ALIGN:\n+      CASE_BUILT_IN_ALLOCA:\n         return true;\n       default:\n \tbreak;\n@@ -719,8 +711,7 @@ alloca_call_p (const_tree exp)\n       && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n     switch (DECL_FUNCTION_CODE (fndecl))\n       {\n-      case BUILT_IN_ALLOCA:\n-      case BUILT_IN_ALLOCA_WITH_ALIGN:\n+      CASE_BUILT_IN_ALLOCA:\n         return true;\n       default:\n \tbreak;\n@@ -1819,6 +1810,8 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t\t  copy = allocate_dynamic_stack_space (size_rtx,\n \t\t\t\t\t\t       TYPE_ALIGN (type),\n \t\t\t\t\t\t       TYPE_ALIGN (type),\n+\t\t\t\t\t\t       max_int_size_in_bytes\n+\t\t\t\t\t\t       (type),\n \t\t\t\t\t\t       true);\n \t\t  copy = gen_rtx_MEM (BLKmode, copy);\n \t\t  set_mem_attributes (copy, type, 1);\n@@ -3638,8 +3631,8 @@ expand_call (tree exp, rtx target, int ignore)\n \t      /* We can pass TRUE as the 4th argument because we just\n \t\t saved the stack pointer and will restore it right after\n \t\t the call.  */\n-\t      allocate_dynamic_stack_space (push_size, 0,\n-\t\t\t\t\t    BIGGEST_ALIGNMENT, true);\n+\t      allocate_dynamic_stack_space (push_size, 0, BIGGEST_ALIGNMENT,\n+\t\t\t\t\t    -1, true);\n \t    }\n \n \t  /* If argument evaluation might modify the stack pointer,"}, {"sha": "df60f80491ca5b66a363b6b568edb2960cc53f33", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "patch": "@@ -2634,8 +2634,7 @@ expand_call_stmt (gcall *stmt)\n   CALL_EXPR_RETURN_SLOT_OPT (exp) = gimple_call_return_slot_opt_p (stmt);\n   if (decl\n       && DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL\n-      && (DECL_FUNCTION_CODE (decl) == BUILT_IN_ALLOCA\n-\t  || DECL_FUNCTION_CODE (decl) == BUILT_IN_ALLOCA_WITH_ALIGN))\n+      && ALLOCA_FUNCTION_CODE_P (DECL_FUNCTION_CODE (decl)))\n     CALL_ALLOCA_FOR_VAR_P (exp) = gimple_call_alloca_for_var_p (stmt);\n   else\n     CALL_FROM_THUNK_P (exp) = gimple_call_from_thunk_p (stmt);"}, {"sha": "768751f58a1ec7a98ec2af86fdc1f3e00b67ea2f", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "patch": "@@ -10869,6 +10869,7 @@ in the Cilk Plus language manual which can be found at\n @cindex built-in functions\n @findex __builtin_alloca\n @findex __builtin_alloca_with_align\n+@findex __builtin_alloca_with_align_and_max\n @findex __builtin_call_with_static_chain\n @findex __builtin_fpclassify\n @findex __builtin_isfinite\n@@ -11516,6 +11517,16 @@ an extension.  @xref{Variable Length}, for details.\n \n @end deftypefn\n \n+@deftypefn {Built-in Function} void *__builtin_alloca_with_align_and_max (size_t size, size_t alignment, size_t max_size)\n+Similar to @code{__builtin_alloca_with_align} but takes an extra argument\n+specifying an upper bound for @var{size} in case its value cannot be computed\n+at compile time, for use by @option{-fstack-usage}, @option{-Wstack-usage}\n+and @option{-Walloca-larger-than}.  @var{max_size} must be a constant integer\n+expression, it has no effect on code generation and no attempt is made to\n+check its compatibility with @var{size}.\n+\n+@end deftypefn\n+\n @deftypefn {Built-in Function} int __builtin_types_compatible_p (@var{type1}, @var{type2})\n \n You can use the built-in function @code{__builtin_types_compatible_p} to"}, {"sha": "662865d2808beceafd28ce72def65c5964037a0b", "filename": "gcc/explow.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "patch": "@@ -1322,6 +1322,9 @@ get_stack_check_protect (void)\n    REQUIRED_ALIGN is the alignment (in bits) required for the region\n    of memory.\n \n+   MAX_SIZE is an upper bound for SIZE, if SIZE is not constant, or -1 if\n+   no such upper bound is known.\n+\n    If CANNOT_ACCUMULATE is set to TRUE, the caller guarantees that the\n    stack space allocated by the generated code cannot be added with itself\n    in the course of the execution of the function.  It is always safe to\n@@ -1331,7 +1334,9 @@ get_stack_check_protect (void)\n \n rtx\n allocate_dynamic_stack_space (rtx size, unsigned size_align,\n-\t\t\t      unsigned required_align, bool cannot_accumulate)\n+\t\t\t      unsigned required_align,\n+\t\t\t      HOST_WIDE_INT max_size,\n+\t\t\t      bool cannot_accumulate)\n {\n   HOST_WIDE_INT stack_usage_size = -1;\n   rtx_code_label *final_label;\n@@ -1370,8 +1375,12 @@ allocate_dynamic_stack_space (rtx size, unsigned size_align,\n \t    }\n \t}\n \n-      /* If the size is not constant, we can't say anything.  */\n-      if (stack_usage_size == -1)\n+      /* If the size is not constant, try the maximum size.  */\n+      if (stack_usage_size < 0)\n+\tstack_usage_size = max_size;\n+\n+      /* If the size is still not constant, we can't say anything.  */\n+      if (stack_usage_size < 0)\n \t{\n \t  current_function_has_unbounded_dynamic_stack_size = 1;\n \t  stack_usage_size = 0;"}, {"sha": "8eca20b2fd28f6061ee96d8688c370a04fe86549", "filename": "gcc/explow.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Fexplow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Fexplow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.h?ref=9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "patch": "@@ -94,7 +94,8 @@ extern void update_nonlocal_goto_save_area (void);\n extern void record_new_stack_level (void);\n \n /* Allocate some space on the stack dynamically and return its address.  */\n-extern rtx allocate_dynamic_stack_space (rtx, unsigned, unsigned, bool);\n+extern rtx allocate_dynamic_stack_space (rtx, unsigned, unsigned,\n+\t\t\t\t\t HOST_WIDE_INT, bool);\n \n /* Calculate the necessary size of a constant dynamic stack allocation from the\n    size of the variable area.  */"}, {"sha": "10bcefb2cfe617ae8012b0f1a70bceec7aeca53d", "filename": "gcc/function.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "patch": "@@ -4049,10 +4049,9 @@ gimplify_parameters (void)\n \t\t  DECL_IGNORED_P (addr) = 0;\n \t\t  local = build_fold_indirect_ref (addr);\n \n-\t\t  t = builtin_decl_explicit (BUILT_IN_ALLOCA_WITH_ALIGN);\n-\t\t  t = build_call_expr (t, 2, DECL_SIZE_UNIT (parm),\n-\t\t\t\t       size_int (DECL_ALIGN (parm)));\n-\n+\t\t  t = build_alloca_call_expr (DECL_SIZE_UNIT (parm),\n+\t\t\t\t\t      DECL_ALIGN (parm),\n+\t\t\t\t\t      max_int_size_in_bytes (type));\n \t\t  /* The call has been built for a variable-sized object.  */\n \t\t  CALL_ALLOCA_FOR_VAR_P (t) = 1;\n \t\t  t = fold_convert (ptr_type, t);"}, {"sha": "08c2195575a0302de13a045ac5dd711090a713c2", "filename": "gcc/gimple-ssa-warn-alloca.c", "status": "modified", "additions": 39, "deletions": 46, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Fgimple-ssa-warn-alloca.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Fgimple-ssa-warn-alloca.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-alloca.c?ref=9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "patch": "@@ -264,7 +264,7 @@ is_max (tree x, wide_int max)\n \n // Analyze the alloca call in STMT and return the alloca type with its\n // corresponding limit (if applicable).  IS_VLA is set if the alloca\n-// call is really a BUILT_IN_ALLOCA_WITH_ALIGN, signifying a VLA.\n+// call was created by the gimplifier for a VLA.\n //\n // If the alloca call may be too large because of a cast from a signed\n // type to an unsigned type, set *INVALID_CASTED_TYPE to the\n@@ -278,7 +278,8 @@ alloca_call_type (gimple *stmt, bool is_vla, tree *invalid_casted_type)\n   tree len = gimple_call_arg (stmt, 0);\n   tree len_casted = NULL;\n   wide_int min, max;\n-  struct alloca_type_and_limit ret = alloca_type_and_limit (ALLOCA_UNBOUNDED);\n+  edge_iterator ei;\n+  edge e;\n \n   gcc_assert (!is_vla || (unsigned HOST_WIDE_INT) warn_vla_limit > 0);\n   gcc_assert (is_vla || (unsigned HOST_WIDE_INT) warn_alloca_limit > 0);\n@@ -299,16 +300,18 @@ alloca_call_type (gimple *stmt, bool is_vla, tree *invalid_casted_type)\n \t\t\t\t      wi::to_wide (len));\n       if (integer_zerop (len))\n \treturn alloca_type_and_limit (ALLOCA_ARG_IS_ZERO);\n-      ret = alloca_type_and_limit (ALLOCA_OK);\n+\n+      return alloca_type_and_limit (ALLOCA_OK);\n     }\n+\n   // Check the range info if available.\n-  else if (TREE_CODE (len) == SSA_NAME)\n+  if (TREE_CODE (len) == SSA_NAME)\n     {\n       value_range_type range_type = get_range_info (len, &min, &max);\n       if (range_type == VR_RANGE)\n \t{\n \t  if (wi::leu_p (max, max_size))\n-\t    ret = alloca_type_and_limit (ALLOCA_OK);\n+\t    return alloca_type_and_limit (ALLOCA_OK);\n \t  else\n \t    {\n \t      // A cast may have created a range we don't care\n@@ -391,52 +394,41 @@ alloca_call_type (gimple *stmt, bool is_vla, tree *invalid_casted_type)\n   // If we couldn't find anything, try a few heuristics for things we\n   // can easily determine.  Check these misc cases but only accept\n   // them if all predecessors have a known bound.\n-  basic_block bb = gimple_bb (stmt);\n-  if (ret.type == ALLOCA_UNBOUNDED)\n+  struct alloca_type_and_limit ret = alloca_type_and_limit (ALLOCA_OK);\n+  FOR_EACH_EDGE (e, ei, gimple_bb (stmt)->preds)\n     {\n-      ret.type = ALLOCA_OK;\n-      for (unsigned ix = 0; ix < EDGE_COUNT (bb->preds); ix++)\n-\t{\n-\t  gcc_assert (!len_casted || TYPE_UNSIGNED (TREE_TYPE (len_casted)));\n-\t  ret = alloca_call_type_by_arg (len, len_casted,\n-\t\t\t\t\t EDGE_PRED (bb, ix), max_size);\n-\t  if (ret.type != ALLOCA_OK)\n-\t    break;\n-\t}\n+      gcc_assert (!len_casted || TYPE_UNSIGNED (TREE_TYPE (len_casted)));\n+      ret = alloca_call_type_by_arg (len, len_casted, e, max_size);\n+      if (ret.type != ALLOCA_OK)\n+\tbreak;\n+    }\n+\n+  if (ret.type != ALLOCA_OK && tentative_cast_from_signed)\n+    ret = alloca_type_and_limit (ALLOCA_CAST_FROM_SIGNED);\n+\n+  // If we have a declared maximum size, we can take it into account.\n+  if (ret.type != ALLOCA_OK\n+      && gimple_call_builtin_p (stmt, BUILT_IN_ALLOCA_WITH_ALIGN_AND_MAX))\n+    {\n+      tree arg = gimple_call_arg (stmt, 2);\n+      if (compare_tree_int (arg, max_size) <= 0)\n+\tret = alloca_type_and_limit (ALLOCA_OK);\n+      else\n+\tret = alloca_type_and_limit (ALLOCA_BOUND_MAYBE_LARGE,\n+\t\t\t\t     wi::to_wide (arg));\n     }\n \n-  if (tentative_cast_from_signed && ret.type != ALLOCA_OK)\n-    return alloca_type_and_limit (ALLOCA_CAST_FROM_SIGNED);\n   return ret;\n }\n \n-// Return TRUE if the alloca call in STMT is in a loop, otherwise\n-// return FALSE. As an exception, ignore alloca calls for VLAs that\n-// occur in a loop since those will be cleaned up when they go out of\n-// scope.\n+// Return TRUE if STMT is in a loop, otherwise return FALSE.\n \n static bool\n-in_loop_p (bool is_vla, gimple *stmt)\n+in_loop_p (gimple *stmt)\n {\n   basic_block bb = gimple_bb (stmt);\n-  if (bb->loop_father\n-      && bb->loop_father->header != ENTRY_BLOCK_PTR_FOR_FN (cfun))\n-    {\n-      // Do not warn on VLAs occurring in a loop, since VLAs are\n-      // guaranteed to be cleaned up when they go out of scope.\n-      // That is, there is a corresponding __builtin_stack_restore\n-      // at the end of the scope in which the VLA occurs.\n-      tree fndecl = gimple_call_fn (stmt);\n-      while (TREE_CODE (fndecl) == ADDR_EXPR)\n-\tfndecl = TREE_OPERAND (fndecl, 0);\n-      if (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n-\t  && is_vla\n-\t  && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_ALLOCA_WITH_ALIGN)\n-\treturn false;\n-\n-      return true;\n-    }\n-  return false;\n+  return\n+    bb->loop_father && bb->loop_father->header != ENTRY_BLOCK_PTR_FOR_FN (cfun);\n }\n \n unsigned int\n@@ -455,8 +447,8 @@ pass_walloca::execute (function *fun)\n \t    continue;\n \t  gcc_assert (gimple_call_num_args (stmt) >= 1);\n \n-\t  bool is_vla = gimple_alloca_call_p (stmt)\n-\t    && gimple_call_alloca_for_var_p (as_a <gcall *> (stmt));\n+\t  const bool is_vla\n+\t    = gimple_call_alloca_for_var_p (as_a <gcall *> (stmt));\n \n \t  // Strict mode whining for VLAs is handled by the front-end,\n \t  // so we can safely ignore this case.  Also, ignore VLAs if\n@@ -476,9 +468,10 @@ pass_walloca::execute (function *fun)\n \t  struct alloca_type_and_limit t\n \t    = alloca_call_type (stmt, is_vla, &invalid_casted_type);\n \n-\t  // Even if we think the alloca call is OK, make sure it's\n-\t  // not in a loop.\n-\t  if (t.type == ALLOCA_OK && in_loop_p (is_vla, stmt))\n+\t  // Even if we think the alloca call is OK, make sure it's not in a\n+\t  // loop, except for a VLA, since VLAs are guaranteed to be cleaned\n+\t  // up when they go out of scope, including in a loop.\n+\t  if (t.type == ALLOCA_OK && !is_vla && in_loop_p (stmt))\n \t    t = alloca_type_and_limit (ALLOCA_IN_LOOP);\n \n \t  enum opt_code wcode"}, {"sha": "aaf1cc2060fcee5b824e2afceca89feed9adfabc", "filename": "gcc/gimple.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "patch": "@@ -369,8 +369,7 @@ gimple_build_call_from_tree (tree t)\n   gimple_call_set_return_slot_opt (call, CALL_EXPR_RETURN_SLOT_OPT (t));\n   if (fndecl\n       && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n-      && (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_ALLOCA\n-\t  || DECL_FUNCTION_CODE (fndecl) == BUILT_IN_ALLOCA_WITH_ALIGN))\n+      && ALLOCA_FUNCTION_CODE_P (DECL_FUNCTION_CODE (fndecl)))\n     gimple_call_set_alloca_for_var (call, CALL_ALLOCA_FOR_VAR_P (t));\n   else\n     gimple_call_set_from_thunk (call, CALL_FROM_THUNK_P (t));"}, {"sha": "2c1ec852210a413f4565951bb398604c7ffb864b", "filename": "gcc/gimplify.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "patch": "@@ -1574,9 +1574,8 @@ gimplify_vla_decl (tree decl, gimple_seq *seq_p)\n   SET_DECL_VALUE_EXPR (decl, t);\n   DECL_HAS_VALUE_EXPR_P (decl) = 1;\n \n-  t = builtin_decl_explicit (BUILT_IN_ALLOCA_WITH_ALIGN);\n-  t = build_call_expr (t, 2, DECL_SIZE_UNIT (decl),\n-\t\t       size_int (DECL_ALIGN (decl)));\n+  t = build_alloca_call_expr (DECL_SIZE_UNIT (decl), DECL_ALIGN (decl),\n+\t\t\t      max_int_size_in_bytes (TREE_TYPE (decl)));\n   /* The call has been built for a variable-sized object.  */\n   CALL_ALLOCA_FOR_VAR_P (t) = 1;\n   t = fold_convert (ptr_type, t);\n@@ -3174,8 +3173,7 @@ gimplify_call_expr (tree *expr_p, gimple_seq *pre_p, bool want_value)\n       && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n     switch (DECL_FUNCTION_CODE (fndecl))\n       {\n-      case BUILT_IN_ALLOCA:\n-      case BUILT_IN_ALLOCA_WITH_ALIGN:\n+      CASE_BUILT_IN_ALLOCA:\n \t/* If the call has been built for a variable-sized object, then we\n \t   want to restore the stack level when the enclosing BIND_EXPR is\n \t   exited to reclaim the allocated space; otherwise, we precisely"}, {"sha": "d89d12084eb269b719fbd8e5c4ad8e3e8ddc7758", "filename": "gcc/hsa-gen.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Fhsa-gen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Fhsa-gen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-gen.c?ref=9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "patch": "@@ -4238,12 +4238,11 @@ gen_hsa_alloca (gcall *call, hsa_bb *hbb)\n \n   built_in_function fn = DECL_FUNCTION_CODE (gimple_call_fndecl (call));\n \n-  gcc_checking_assert (fn == BUILT_IN_ALLOCA\n-\t\t       || fn == BUILT_IN_ALLOCA_WITH_ALIGN);\n+  gcc_checking_assert (ALLOCA_FUNCTION_CODE_P (fn));\n \n   unsigned bit_alignment = 0;\n \n-  if (fn == BUILT_IN_ALLOCA_WITH_ALIGN)\n+  if (fn != BUILT_IN_ALLOCA)\n     {\n       tree alignment_tree = gimple_call_arg (call, 1);\n       if (TREE_CODE (alignment_tree) != INTEGER_CST)\n@@ -5656,8 +5655,7 @@ gen_hsa_insns_for_call (gimple *stmt, hsa_bb *hbb)\n \n \tbreak;\n       }\n-    case BUILT_IN_ALLOCA:\n-    case BUILT_IN_ALLOCA_WITH_ALIGN:\n+    CASE_BUILT_IN_ALLOCA:\n       {\n \tgen_hsa_alloca (call, hbb);\n \tbreak;"}, {"sha": "3c06e2d303328343be557e66a0f9dc32098fbef7", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "patch": "@@ -518,8 +518,7 @@ special_builtin_state (enum pure_const_state_e *state, bool *looping,\n       {\n \tcase BUILT_IN_RETURN:\n \tcase BUILT_IN_UNREACHABLE:\n-\tcase BUILT_IN_ALLOCA:\n-\tcase BUILT_IN_ALLOCA_WITH_ALIGN:\n+\tCASE_BUILT_IN_ALLOCA:\n \tcase BUILT_IN_STACK_SAVE:\n \tcase BUILT_IN_STACK_RESTORE:\n \tcase BUILT_IN_EH_POINTER:"}, {"sha": "138899afb8211ec8ddf81aa9e0b706b6a9bb8f36", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "patch": "@@ -1,3 +1,9 @@\n+2017-10-19  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.dg/Walloca-15.c: New test.\n+\t* gnat.dg/stack_usage4.adb: Likewise.\n+\t* gnat.dg/stack_usage4_pkg.ads: New helper.\n+\n 2017-10-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/82600"}, {"sha": "f34ffd98b617d4ed87caea013dd28eaeef84a099", "filename": "gcc/testsuite/gcc.dg/Walloca-15.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-15.c?ref=9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target alloca } */\n+/* { dg-options \"-Walloca-larger-than=128 -O2\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+void bar (void*);\n+\n+void foo1 (size_t len)\n+{\n+  bar (__builtin_alloca_with_align_and_max (len, 8, 128));\n+}\n+\n+void foo2 (size_t len)\n+{\n+  bar (__builtin_alloca_with_align_and_max (len, 8, 256)); /* { dg-warning \"may be too large\" } */\n+}"}, {"sha": "24cd1a75bf062fac3ce9b9f11f54aa46a54b28ab", "filename": "gcc/testsuite/gnat.dg/stack_usage4.adb", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Ftestsuite%2Fgnat.dg%2Fstack_usage4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Ftestsuite%2Fgnat.dg%2Fstack_usage4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fstack_usage4.adb?ref=9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "patch": "@@ -0,0 +1,11 @@\n+-- { dg-do compile }\n+-- { dg-options \"-Wstack-usage=512\" }\n+\n+with Stack_Usage4_Pkg; use Stack_Usage4_Pkg;\n+\n+procedure Stack_Usage4 is\n+   BS : Bounded_String := Get;\n+   S : String := BS.Data (BS.Data'First .. BS.Len);\n+begin\n+   null;\n+end;"}, {"sha": "9bad62776cd025a6c770dd0b38c1ddb3d7f875d3", "filename": "gcc/testsuite/gnat.dg/stack_usage4_pkg.ads", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Ftestsuite%2Fgnat.dg%2Fstack_usage4_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Ftestsuite%2Fgnat.dg%2Fstack_usage4_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fstack_usage4_pkg.ads?ref=9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "patch": "@@ -0,0 +1,12 @@\n+package Stack_Usage4_Pkg is\n+\n+   subtype Name_Index_Type is Natural range 1 .. 63;\n+\n+   type Bounded_String is record\n+      Len  : Name_Index_Type;\n+      Data : String (Name_Index_Type'Range);\n+   end record;\n+\n+   function Get return Bounded_String;\n+\n+end Stack_Usage4_Pkg;"}, {"sha": "025155aca72b854e7377b5b0965f03538dd158f2", "filename": "gcc/tree-chkp.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Ftree-chkp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Ftree-chkp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chkp.c?ref=9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "patch": "@@ -2276,8 +2276,7 @@ chkp_build_returned_bound (gcall *call)\n      it separately.  */\n   if (fndecl\n       && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n-      && (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_ALLOCA\n-\t  || DECL_FUNCTION_CODE (fndecl) == BUILT_IN_ALLOCA_WITH_ALIGN))\n+      && ALLOCA_FUNCTION_CODE_P (DECL_FUNCTION_CODE (fndecl)))\n     {\n       tree size = gimple_call_arg (call, 0);\n       gimple_stmt_iterator iter = gsi_for_stmt (call);"}, {"sha": "d45f50d4173e6f040840949750aba1a7a96724e1", "filename": "gcc/tree-object-size.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Ftree-object-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Ftree-object-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.c?ref=9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "patch": "@@ -430,8 +430,7 @@ alloc_object_size (const gcall *call, int object_size_type)\n \targ2 = 1;\n \t/* fall through */\n       case BUILT_IN_MALLOC:\n-      case BUILT_IN_ALLOCA:\n-      case BUILT_IN_ALLOCA_WITH_ALIGN:\n+      CASE_BUILT_IN_ALLOCA:\n \targ1 = 0;\n       default:\n \tbreak;"}, {"sha": "5340fd350bc434fdf7b7b13ec5a5d8d9b0c7481a", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "patch": "@@ -1779,8 +1779,7 @@ ref_maybe_used_by_call_p_1 (gcall *call, ao_ref *ref)\n \tcase BUILT_IN_POSIX_MEMALIGN:\n \tcase BUILT_IN_ALIGNED_ALLOC:\n \tcase BUILT_IN_CALLOC:\n-\tcase BUILT_IN_ALLOCA:\n-\tcase BUILT_IN_ALLOCA_WITH_ALIGN:\n+\tCASE_BUILT_IN_ALLOCA:\n \tcase BUILT_IN_STACK_SAVE:\n \tcase BUILT_IN_STACK_RESTORE:\n \tcase BUILT_IN_MEMSET:\n@@ -2118,8 +2117,7 @@ call_may_clobber_ref_p_1 (gcall *call, ao_ref *ref)\n \t    return true;\n \t  return false;\n \tcase BUILT_IN_STACK_SAVE:\n-\tcase BUILT_IN_ALLOCA:\n-\tcase BUILT_IN_ALLOCA_WITH_ALIGN:\n+\tCASE_BUILT_IN_ALLOCA:\n \tcase BUILT_IN_ASSUME_ALIGNED:\n \t  return false;\n \t/* But posix_memalign stores a pointer into the memory pointed to"}, {"sha": "569b057094171c900b5b75ae9dc57f5bb8c8ae4f", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "patch": "@@ -1886,11 +1886,10 @@ evaluate_stmt (gimple *stmt)\n \t\t\t   / BITS_PER_UNIT - 1);\n \t      break;\n \n-\t    case BUILT_IN_ALLOCA:\n-\t    case BUILT_IN_ALLOCA_WITH_ALIGN:\n-\t      align = (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_ALLOCA_WITH_ALIGN\n-\t\t       ? TREE_INT_CST_LOW (gimple_call_arg (stmt, 1))\n-\t\t       : BIGGEST_ALIGNMENT);\n+\t    CASE_BUILT_IN_ALLOCA:\n+\t      align = (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_ALLOCA\n+\t\t       ? BIGGEST_ALIGNMENT\n+\t\t       : TREE_INT_CST_LOW (gimple_call_arg (stmt, 1)));\n \t      val.lattice_val = CONSTANT;\n \t      val.value = build_int_cst (TREE_TYPE (gimple_get_lhs (stmt)), 0);\n \t      val.mask = ~((HOST_WIDE_INT) align / BITS_PER_UNIT - 1);\n@@ -2243,7 +2242,8 @@ ccp_fold_stmt (gimple_stmt_iterator *gsi)\n         /* The heuristic of fold_builtin_alloca_with_align differs before and\n \t   after inlining, so we don't require the arg to be changed into a\n \t   constant for folding, but just to be constant.  */\n-        if (gimple_call_builtin_p (stmt, BUILT_IN_ALLOCA_WITH_ALIGN))\n+        if (gimple_call_builtin_p (stmt, BUILT_IN_ALLOCA_WITH_ALIGN)\n+\t    || gimple_call_builtin_p (stmt, BUILT_IN_ALLOCA_WITH_ALIGN_AND_MAX))\n           {\n             tree new_rhs = fold_builtin_alloca_with_align (stmt);\n             if (new_rhs)\n@@ -2535,8 +2535,7 @@ optimize_stack_restore (gimple_stmt_iterator i)\n       if (!callee\n \t  || DECL_BUILT_IN_CLASS (callee) != BUILT_IN_NORMAL\n \t  /* All regular builtins are ok, just obviously not alloca.  */\n-\t  || DECL_FUNCTION_CODE (callee) == BUILT_IN_ALLOCA\n-\t  || DECL_FUNCTION_CODE (callee) == BUILT_IN_ALLOCA_WITH_ALIGN)\n+\t  || ALLOCA_FUNCTION_CODE_P (DECL_FUNCTION_CODE (callee)))\n \treturn NULL_TREE;\n \n       if (DECL_FUNCTION_CODE (callee) == BUILT_IN_STACK_RESTORE)"}, {"sha": "59dd3f3038a86e573dc3ce9df7394082a11cc03e", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "patch": "@@ -231,8 +231,7 @@ mark_stmt_if_obviously_necessary (gimple *stmt, bool aggressive)\n \t    case BUILT_IN_MALLOC:\n \t    case BUILT_IN_ALIGNED_ALLOC:\n \t    case BUILT_IN_CALLOC:\n-\t    case BUILT_IN_ALLOCA:\n-\t    case BUILT_IN_ALLOCA_WITH_ALIGN:\n+\t    CASE_BUILT_IN_ALLOCA:\n \t    case BUILT_IN_STRDUP:\n \t    case BUILT_IN_STRNDUP:\n \t      return;\n@@ -576,8 +575,7 @@ mark_all_reaching_defs_necessary_1 (ao_ref *ref ATTRIBUTE_UNUSED,\n \t  case BUILT_IN_MALLOC:\n \t  case BUILT_IN_ALIGNED_ALLOC:\n \t  case BUILT_IN_CALLOC:\n-\t  case BUILT_IN_ALLOCA:\n-\t  case BUILT_IN_ALLOCA_WITH_ALIGN:\n+\t  CASE_BUILT_IN_ALLOCA:\n \t  case BUILT_IN_FREE:\n \t    return false;\n \n@@ -845,9 +843,7 @@ propagate_necessity (bool aggressive)\n \t\t      || DECL_FUNCTION_CODE (callee) == BUILT_IN_CALLOC\n \t\t      || DECL_FUNCTION_CODE (callee) == BUILT_IN_FREE\n \t\t      || DECL_FUNCTION_CODE (callee) == BUILT_IN_VA_END\n-\t\t      || DECL_FUNCTION_CODE (callee) == BUILT_IN_ALLOCA\n-\t\t      || (DECL_FUNCTION_CODE (callee)\n-\t\t\t  == BUILT_IN_ALLOCA_WITH_ALIGN)\n+\t\t      || ALLOCA_FUNCTION_CODE_P (DECL_FUNCTION_CODE (callee))\n \t\t      || DECL_FUNCTION_CODE (callee) == BUILT_IN_STACK_SAVE\n \t\t      || DECL_FUNCTION_CODE (callee) == BUILT_IN_STACK_RESTORE\n \t\t      || DECL_FUNCTION_CODE (callee) == BUILT_IN_ASSUME_ALIGNED))\n@@ -1348,9 +1344,8 @@ eliminate_unnecessary_stmts (void)\n \t\t      || (DECL_FUNCTION_CODE (call) != BUILT_IN_ALIGNED_ALLOC\n \t\t\t  && DECL_FUNCTION_CODE (call) != BUILT_IN_MALLOC\n \t\t\t  && DECL_FUNCTION_CODE (call) != BUILT_IN_CALLOC\n-\t\t\t  && DECL_FUNCTION_CODE (call) != BUILT_IN_ALLOCA\n-\t\t\t  && (DECL_FUNCTION_CODE (call)\n-\t\t\t      != BUILT_IN_ALLOCA_WITH_ALIGN)))\n+\t\t\t  && !ALLOCA_FUNCTION_CODE_P\n+\t\t\t      (DECL_FUNCTION_CODE (call))))\n \t\t  /* Avoid doing so for bndret calls for the same reason.  */\n \t\t  && !chkp_gimple_call_builtin_p (stmt, BUILT_IN_CHKP_BNDRET))\n \t\t{"}, {"sha": "1b20ad6e9e8aeb25dc939227e8dee6fcaa99636f", "filename": "gcc/tree.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "patch": "@@ -9975,6 +9975,13 @@ build_common_builtin_nodes (void)\n \t\t\t\"__builtin_alloca_with_align\",\n \t\t\talloca_flags);\n \n+  ftype = build_function_type_list (ptr_type_node, size_type_node,\n+\t\t\t\t    size_type_node, size_type_node, NULL_TREE);\n+  local_define_builtin (\"__builtin_alloca_with_align_and_max\", ftype,\n+\t\t\tBUILT_IN_ALLOCA_WITH_ALIGN_AND_MAX,\n+\t\t\t\"__builtin_alloca_with_align_and_max\",\n+\t\t\talloca_flags);\n+\n   ftype = build_function_type_list (void_type_node,\n \t\t\t\t    ptr_type_node, ptr_type_node,\n \t\t\t\t    ptr_type_node, NULL_TREE);\n@@ -10716,6 +10723,33 @@ maybe_build_call_expr_loc (location_t loc, combined_fn fn, tree type,\n     }\n }\n \n+/* Return a function call to the appropriate builtin alloca variant.\n+\n+   SIZE is the size to be allocated.  ALIGN, if non-zero, is the requested\n+   alignment of the allocated area.  MAX_SIZE, if non-negative, is an upper\n+   bound for SIZE in case it is not a fixed value.  */\n+\n+tree\n+build_alloca_call_expr (tree size, unsigned int align, HOST_WIDE_INT max_size)\n+{\n+  if (max_size >= 0)\n+    {\n+      tree t = builtin_decl_explicit (BUILT_IN_ALLOCA_WITH_ALIGN_AND_MAX);\n+      return\n+\tbuild_call_expr (t, 3, size, size_int (align), size_int (max_size));\n+    }\n+  else if (align > 0)\n+    {\n+      tree t = builtin_decl_explicit (BUILT_IN_ALLOCA_WITH_ALIGN);\n+      return build_call_expr (t, 2, size, size_int (align));\n+    }\n+  else\n+    {\n+      tree t = builtin_decl_explicit (BUILT_IN_ALLOCA);\n+      return build_call_expr (t, 1, size);\n+    }\n+}\n+\n /* Create a new constant string literal and return a char* pointer to it.\n    The STRING_CST value is the LEN characters at STR.  */\n tree"}, {"sha": "7214ae2275c9741232b7d0dff0510bfb452ca975", "filename": "gcc/tree.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "patch": "@@ -2396,6 +2396,18 @@ extern machine_mode vector_type_mode (const_tree);\n #define DECL_FUNCTION_CODE(NODE) \\\n   (FUNCTION_DECL_CHECK (NODE)->function_decl.function_code)\n \n+/* Test if FCODE is a function code for an alloca operation.  */\n+#define ALLOCA_FUNCTION_CODE_P(FCODE)\t\t\t\t\\\n+  ((FCODE) == BUILT_IN_ALLOCA\t\t\t\t\t\\\n+   || (FCODE) == BUILT_IN_ALLOCA_WITH_ALIGN\t\t\t\\\n+   || (FCODE) == BUILT_IN_ALLOCA_WITH_ALIGN_AND_MAX)\n+\n+/* Generate case for an alloca operation.  */\n+#define CASE_BUILT_IN_ALLOCA\t\t\t\\\n+  case BUILT_IN_ALLOCA:\t\t\t\t\\\n+  case BUILT_IN_ALLOCA_WITH_ALIGN:\t\t\\\n+  case BUILT_IN_ALLOCA_WITH_ALIGN_AND_MAX\n+\n #define DECL_FUNCTION_PERSONALITY(NODE) \\\n   (FUNCTION_DECL_CHECK (NODE)->function_decl.personality)\n \n@@ -4050,6 +4062,7 @@ extern tree build_call_expr_internal_loc_array (location_t, enum internal_fn,\n \t\t\t\t\t\ttree, int, const tree *);\n extern tree maybe_build_call_expr_loc (location_t, combined_fn, tree,\n \t\t\t\t       int, ...);\n+extern tree build_alloca_call_expr (tree, unsigned int, HOST_WIDE_INT);\n extern tree build_string_literal (int, const char *);\n \n /* Construct various nodes representing data types.  */"}, {"sha": "d324ca034fbf844af717a4b1b4f302e7dadbba72", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=9e878cf1bae7eba3a097dbb6b04d0bbca5bdb0e4", "patch": "@@ -2399,8 +2399,7 @@ incorporeal_function_p (tree decl)\n       const char *name;\n \n       if (DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL\n-\t  && (DECL_FUNCTION_CODE (decl) == BUILT_IN_ALLOCA\n-\t      || DECL_FUNCTION_CODE (decl) == BUILT_IN_ALLOCA_WITH_ALIGN))\n+\t  && ALLOCA_FUNCTION_CODE_P (DECL_FUNCTION_CODE (decl)))\n \treturn true;\n \n       name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));"}]}