{"sha": "a252a471df552cf2c0a688a3472094fe234b7ab6", "node_id": "C_kwDOANBUbNoAKGEyNTJhNDcxZGY1NTJjZjJjMGE2ODhhMzQ3MjA5NGZlMjM0YjdhYjY", "commit": {"author": {"name": "Justin Squirek", "email": "squirek@adacore.com", "date": "2022-01-18T09:46:23Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-05-09T09:27:38Z"}, "message": "[Ada] Fix invalid memory access on finalization of class-wide type\n\nThis patch corrects issues in the compiler whereby finalization of a\nheap- allocated class-wide type may cause an invalid memory read at\nruntime when the type in question contains a component whose type has a\nlarge alignment.\n\ngcc/ada/\n\n\t* exp_attr.adb (Expand_N_Attribute_Reference) <Attribute_Tag>:\n\tDeal specifically wth class-wide equivalent types without a\n\tparent.\n\t* exp_util.adb (Build_Allocate_Deallocate_Proc): Extract\n\tallocator node for calculation of alignment actual and modify\n\talignment for allocators of class-wide types with associated\n\texpressions.\n\t(Make_CW_Equivalent_Type): Handle interface types differently\n\twhen generating the equivalent record.\n\t* sem_aux.adb (First_Tag_Component): Accept class-wide\n\tequivalent types too.", "tree": {"sha": "d2a5c715ee359862469384ce368c2e5876f41cc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2a5c715ee359862469384ce368c2e5876f41cc7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a252a471df552cf2c0a688a3472094fe234b7ab6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a252a471df552cf2c0a688a3472094fe234b7ab6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a252a471df552cf2c0a688a3472094fe234b7ab6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a252a471df552cf2c0a688a3472094fe234b7ab6/comments", "author": {"login": "AdaDoom3", "id": 3445599, "node_id": "MDQ6VXNlcjM0NDU1OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/3445599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AdaDoom3", "html_url": "https://github.com/AdaDoom3", "followers_url": "https://api.github.com/users/AdaDoom3/followers", "following_url": "https://api.github.com/users/AdaDoom3/following{/other_user}", "gists_url": "https://api.github.com/users/AdaDoom3/gists{/gist_id}", "starred_url": "https://api.github.com/users/AdaDoom3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AdaDoom3/subscriptions", "organizations_url": "https://api.github.com/users/AdaDoom3/orgs", "repos_url": "https://api.github.com/users/AdaDoom3/repos", "events_url": "https://api.github.com/users/AdaDoom3/events{/privacy}", "received_events_url": "https://api.github.com/users/AdaDoom3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ebbe48015e6070b0f020fa57c7eb7fce554e71d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebbe48015e6070b0f020fa57c7eb7fce554e71d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebbe48015e6070b0f020fa57c7eb7fce554e71d4"}], "stats": {"total": 123, "additions": 106, "deletions": 17}, "files": [{"sha": "7b36daec9aee8bfc112a43c2834a6cd0109542ae", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a252a471df552cf2c0a688a3472094fe234b7ab6/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a252a471df552cf2c0a688a3472094fe234b7ab6/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=a252a471df552cf2c0a688a3472094fe234b7ab6", "patch": "@@ -6704,7 +6704,21 @@ package body Exp_Attr is\n             Prefix_Is_Type := False;\n          end if;\n \n-         if Is_Class_Wide_Type (Ttyp) then\n+         --  In the case of a class-wide equivalent type without a parent,\n+         --  the _Tag component has been built in Make_CW_Equivalent_Type\n+         --  manually and must be referenced directly.\n+\n+         if Ekind (Ttyp) = E_Class_Wide_Subtype\n+           and then Present (Equivalent_Type (Ttyp))\n+           and then No (Parent_Subtype (Equivalent_Type (Ttyp)))\n+         then\n+            Ttyp := Equivalent_Type (Ttyp);\n+\n+         --  In all the other cases of class-wide type, including an equivalent\n+         --  type with a parent, the _Tag component ultimately present is that\n+         --  of the root type.\n+\n+         elsif Is_Class_Wide_Type (Ttyp) then\n             Ttyp := Root_Type (Ttyp);\n          end if;\n "}, {"sha": "30c293c3465a6eeb6237f7e0e75645f981f540bc", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 88, "deletions": 15, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a252a471df552cf2c0a688a3472094fe234b7ab6/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a252a471df552cf2c0a688a3472094fe234b7ab6/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=a252a471df552cf2c0a688a3472094fe234b7ab6", "patch": "@@ -890,13 +890,45 @@ package body Exp_Util is\n          Size_Id : constant Entity_Id := Make_Temporary (Loc, 'S');\n \n          Actuals      : List_Id;\n+         Alloc_Nod    : Node_Id := Empty;\n+         Alloc_Expr   : Node_Id := Empty;\n          Fin_Addr_Id  : Entity_Id;\n          Fin_Mas_Act  : Node_Id;\n          Fin_Mas_Id   : Entity_Id;\n          Proc_To_Call : Entity_Id;\n          Subpool      : Node_Id := Empty;\n \n       begin\n+         --  When we are building an allocator procedure, extract the allocator\n+         --  node for later processing and calculation of alignment.\n+\n+         if Is_Allocate then\n+\n+            if Nkind (Expr) = N_Allocator then\n+               Alloc_Nod := Expr;\n+\n+            --  When Expr is an object declaration we have to examine its\n+            --  expression.\n+\n+            elsif Nkind (Expr) = N_Object_Declaration\n+              and then Nkind (Expression (Expr)) = N_Allocator\n+            then\n+               Alloc_Nod := Expression (Expr);\n+\n+            --  Otherwise, we raise an error because we should have found one\n+\n+            else\n+               raise Program_Error;\n+            end if;\n+\n+            --  Extract the qualified expression if there is one from the\n+            --  allocator.\n+\n+            if Nkind (Expression (Alloc_Nod)) = N_Qualified_Expression then\n+               Alloc_Expr := Expression (Alloc_Nod);\n+            end if;\n+         end if;\n+\n          --  Step 1: Construct all the actuals for the call to library routine\n          --  Allocate_Any_Controlled / Deallocate_Any_Controlled.\n \n@@ -967,19 +999,27 @@ package body Exp_Util is\n          Append_To (Actuals, New_Occurrence_Of (Addr_Id, Loc));\n          Append_To (Actuals, New_Occurrence_Of (Size_Id, Loc));\n \n-         if (Is_Allocate or else not Is_Class_Wide_Type (Desig_Typ))\n+         --  Class-wide allocations without expressions and non-class-wide\n+         --  allocations can be performed without getting the alignment from\n+         --  the type's Type Specific Record.\n+\n+         if ((Is_Allocate and then No (Alloc_Expr))\n+               or else\n+             not Is_Class_Wide_Type (Desig_Typ))\n            and then not Use_Secondary_Stack_Pool\n          then\n             Append_To (Actuals, New_Occurrence_Of (Alig_Id, Loc));\n \n-         --  For deallocation of class-wide types we obtain the value of\n-         --  alignment from the Type Specific Record of the deallocated object.\n+         --  For operations on class-wide types we obtain the value of\n+         --  alignment from the Type Specific Record of the relevant object.\n          --  This is needed because the frontend expansion of class-wide types\n          --  into equivalent types confuses the back end.\n \n          else\n             --  Generate:\n             --     Obj.all'Alignment\n+            --   or\n+            --     Alloc_Expr'Alignment\n \n             --  ... because 'Alignment applied to class-wide types is expanded\n             --  into the code that reads the value of alignment from the TSD\n@@ -992,7 +1032,10 @@ package body Exp_Util is\n               Unchecked_Convert_To (RTE (RE_Storage_Offset),\n                 Make_Attribute_Reference (Loc,\n                   Prefix         =>\n-                    Make_Explicit_Dereference (Loc, Relocate_Node (Expr)),\n+                    (if No (Alloc_Expr) then\n+                       Make_Explicit_Dereference (Loc, Relocate_Node (Expr))\n+                     else\n+                       Relocate_Node (Expression (Alloc_Expr))),\n                   Attribute_Name => Name_Alignment)));\n          end if;\n \n@@ -9480,8 +9523,8 @@ package body Exp_Util is\n    --     Ext__50 : Storage_Array (1 .. (Exp'size - Typ'object_size)/8);\n    --   end Equiv_T;\n    --\n-   --  ??? Note that this type does not guarantee same alignment as all\n-   --  derived types\n+   --  Note that this type does not guarantee same alignment as all derived\n+   --  types.\n    --\n    --  Note: for the freezing circuitry, this looks like a record extension,\n    --  and so we need to make sure that the scalar storage order is the same\n@@ -9539,7 +9582,8 @@ package body Exp_Util is\n       if not Is_Interface (Root_Typ) then\n \n          --  subtype rg__xx is\n-         --    Storage_Offset range 1 .. (Expr'size - typ'size) / Storage_Unit\n+         --    Storage_Offset range 1 .. (Expr'size - typ'object_size)\n+         --                                / Storage_Unit\n \n          Sizexpr :=\n            Make_Op_Subtract (Loc,\n@@ -9554,13 +9598,20 @@ package body Exp_Util is\n                  Attribute_Name => Name_Object_Size));\n       else\n          --  subtype rg__xx is\n-         --    Storage_Offset range 1 .. Expr'size / Storage_Unit\n+         --    Storage_Offset range 1 .. (Expr'size - Ada.Tags.Tag'object_size)\n+         --                                / Storage_Unit\n \n          Sizexpr :=\n-           Make_Attribute_Reference (Loc,\n-             Prefix =>\n-               OK_Convert_To (T, Duplicate_Subexpr_No_Checks (E)),\n-             Attribute_Name => Name_Size);\n+           Make_Op_Subtract (Loc,\n+             Left_Opnd =>\n+               Make_Attribute_Reference (Loc,\n+                 Prefix =>\n+                   OK_Convert_To (T, Duplicate_Subexpr_No_Checks (E)),\n+                 Attribute_Name => Name_Size),\n+             Right_Opnd =>\n+               Make_Attribute_Reference (Loc,\n+                 Prefix => New_Occurrence_Of (RTE (RE_Tag), Loc),\n+                 Attribute_Name => Name_Object_Size));\n       end if;\n \n       Set_Paren_Count (Sizexpr, 1);\n@@ -9596,13 +9647,17 @@ package body Exp_Util is\n                     New_List (New_Occurrence_Of (Range_Type, Loc))))));\n \n       --  type Equiv_T is record\n-      --    [ _parent : Tnn; ]\n-      --    E : Str_Type;\n+      --    _Parent : Snn;          -- not interface\n+      --    _Tag    : Ada.Tags.Tag  -- interface\n+      --    Cnn     : Str_Type;\n       --  end Equiv_T;\n \n       Equiv_Type := Make_Temporary (Loc, 'T');\n       Mutate_Ekind (Equiv_Type, E_Record_Type);\n-      Set_Parent_Subtype (Equiv_Type, Constr_Root);\n+\n+      if not Is_Interface (Root_Typ) then\n+         Set_Parent_Subtype (Equiv_Type, Constr_Root);\n+      end if;\n \n       --  Set Is_Class_Wide_Equivalent_Type very early to trigger the special\n       --  treatment for this type. In particular, even though _parent's type\n@@ -9630,6 +9685,17 @@ package body Exp_Util is\n            (Equiv_Type, Reverse_Storage_Order (Base_Type (Root_Utyp)));\n          Set_Reverse_Bit_Order\n            (Equiv_Type, Reverse_Bit_Order (Base_Type (Root_Utyp)));\n+\n+      else\n+         Append_To (Comp_List,\n+           Make_Component_Declaration (Loc,\n+             Defining_Identifier  =>\n+               Make_Defining_Identifier (Loc, Name_uTag),\n+             Component_Definition =>\n+               Make_Component_Definition (Loc,\n+                 Aliased_Present    => False,\n+                 Subtype_Indication =>\n+                   New_Occurrence_Of (RTE (RE_Tag), Loc))));\n       end if;\n \n       Append_To (Comp_List,\n@@ -9654,6 +9720,13 @@ package body Exp_Util is\n       --  the generation of spurious warnings under ZFP run-time.\n \n       Insert_Actions (E, List_Def, Suppress => All_Checks);\n+\n+      --  In the case of an interface type mark the tag for First_Tag_Component\n+\n+      if Is_Interface (Root_Typ) then\n+         Set_Is_Tag (First_Entity (Equiv_Type));\n+      end if;\n+\n       return Equiv_Type;\n    end Make_CW_Equivalent_Type;\n "}, {"sha": "88948f73473515b6da1fb4491ef2a359caa071ca", "filename": "gcc/ada/sem_aux.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a252a471df552cf2c0a688a3472094fe234b7ab6/gcc%2Fada%2Fsem_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a252a471df552cf2c0a688a3472094fe234b7ab6/gcc%2Fada%2Fsem_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.adb?ref=a252a471df552cf2c0a688a3472094fe234b7ab6", "patch": "@@ -410,8 +410,10 @@ package body Sem_Aux is\n       Ctyp : Entity_Id;\n \n    begin\n+      pragma Assert (Is_Tagged_Type (Typ)\n+        or else Is_Class_Wide_Equivalent_Type (Typ));\n+\n       Ctyp := Typ;\n-      pragma Assert (Is_Tagged_Type (Ctyp));\n \n       if Is_Class_Wide_Type (Ctyp) then\n          Ctyp := Root_Type (Ctyp);"}]}