{"sha": "b57b79f767ad7d4ff784a597494be221700333cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjU3Yjc5Zjc2N2FkN2Q0ZmY3ODRhNTk3NDk0YmUyMjE3MDAzMzNjYw==", "commit": {"author": {"name": "Nathanael Nerode", "email": "neroden@gcc.gnu.org", "date": "2003-06-16T21:04:12Z"}, "committer": {"name": "Nathanael Nerode", "email": "neroden@gcc.gnu.org", "date": "2003-06-16T21:04:12Z"}, "message": "* tree.c: Convert to ISO C.\n\nFrom-SVN: r68040", "tree": {"sha": "6fea1722712f98f04d033e887724a673a2c61d5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6fea1722712f98f04d033e887724a673a2c61d5d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b57b79f767ad7d4ff784a597494be221700333cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b57b79f767ad7d4ff784a597494be221700333cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b57b79f767ad7d4ff784a597494be221700333cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b57b79f767ad7d4ff784a597494be221700333cc/comments", "author": null, "committer": null, "parents": [{"sha": "799ab2c7133895e3e4db410cd68b53bfca0b84f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/799ab2c7133895e3e4db410cd68b53bfca0b84f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/799ab2c7133895e3e4db410cd68b53bfca0b84f5"}], "stats": {"total": 398, "additions": 147, "deletions": 251}, "files": [{"sha": "6f81c807a030536a73561e4e1df108b503772b5d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b57b79f767ad7d4ff784a597494be221700333cc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b57b79f767ad7d4ff784a597494be221700333cc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b57b79f767ad7d4ff784a597494be221700333cc", "patch": "@@ -1,3 +1,7 @@\n+2003-06-16  Nathanael Nerode  <neroden@gcc.gnu.org>\n+\n+\t* tree.c: Convert to ISO C.\n+\n 2003-06-16  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* cp-tree.h: Follow spelling conventions."}, {"sha": "64aa2db5d8eac5889e264619c81998724c6f3a5d", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 143, "deletions": 251, "changes": 394, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b57b79f767ad7d4ff784a597494be221700333cc/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b57b79f767ad7d4ff784a597494be221700333cc/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=b57b79f767ad7d4ff784a597494be221700333cc", "patch": "@@ -35,34 +35,33 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree-inline.h\"\n #include \"target.h\"\n \n-static tree bot_manip PARAMS ((tree *, int *, void *));\n-static tree bot_replace PARAMS ((tree *, int *, void *));\n-static tree build_cplus_array_type_1 PARAMS ((tree, tree));\n-static int list_hash_eq PARAMS ((const void *, const void *));\n-static hashval_t list_hash_pieces PARAMS ((tree, tree, tree));\n-static hashval_t list_hash PARAMS ((const void *));\n-static cp_lvalue_kind lvalue_p_1 PARAMS ((tree, int, int));\n-static tree no_linkage_helper PARAMS ((tree *, int *, void *));\n-static tree mark_local_for_remap_r PARAMS ((tree *, int *, void *));\n-static tree cp_unsave_r PARAMS ((tree *, int *, void *));\n-static tree build_target_expr PARAMS ((tree, tree));\n-static tree count_trees_r PARAMS ((tree *, int *, void *));\n-static tree verify_stmt_tree_r PARAMS ((tree *, int *, void *));\n-static tree find_tree_r PARAMS ((tree *, int *, void *));\n-\n-static tree handle_java_interface_attribute PARAMS ((tree *, tree, tree, int, bool *));\n-static tree handle_com_interface_attribute PARAMS ((tree *, tree, tree, int, bool *));\n-static tree handle_init_priority_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static tree bot_manip (tree *, int *, void *);\n+static tree bot_replace (tree *, int *, void *);\n+static tree build_cplus_array_type_1 (tree, tree);\n+static int list_hash_eq (const void *, const void *);\n+static hashval_t list_hash_pieces (tree, tree, tree);\n+static hashval_t list_hash (const void *);\n+static cp_lvalue_kind lvalue_p_1 (tree, int, int);\n+static tree no_linkage_helper (tree *, int *, void *);\n+static tree mark_local_for_remap_r (tree *, int *, void *);\n+static tree cp_unsave_r (tree *, int *, void *);\n+static tree build_target_expr (tree, tree);\n+static tree count_trees_r (tree *, int *, void *);\n+static tree verify_stmt_tree_r (tree *, int *, void *);\n+static tree find_tree_r (tree *, int *, void *);\n+\n+static tree handle_java_interface_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_com_interface_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_init_priority_attribute (tree *, tree, tree, int, bool *);\n \n /* If REF is an lvalue, returns the kind of lvalue that REF is.\n    Otherwise, returns clk_none.  If TREAT_CLASS_RVALUES_AS_LVALUES is\n    nonzero, rvalues of class type are considered lvalues.  */\n \n static cp_lvalue_kind\n-lvalue_p_1 (ref, treat_class_rvalues_as_lvalues, allow_cast_as_lvalue)\n-     tree ref;\n-     int treat_class_rvalues_as_lvalues;\n-     int allow_cast_as_lvalue;\n+lvalue_p_1 (tree ref, \n+            int treat_class_rvalues_as_lvalues, \n+            int allow_cast_as_lvalue)\n {\n   cp_lvalue_kind op1_lvalue_kind = clk_none;\n   cp_lvalue_kind op2_lvalue_kind = clk_none;\n@@ -204,8 +203,7 @@ lvalue_p_1 (ref, treat_class_rvalues_as_lvalues, allow_cast_as_lvalue)\n    have their address taken, unless they have DECL_REGISTER.  */\n \n cp_lvalue_kind\n-real_lvalue_p (ref)\n-     tree ref;\n+real_lvalue_p (tree ref)\n {\n   return lvalue_p_1 (ref, /*treat_class_rvalues_as_lvalues=*/ 0, /*cast*/ 1);\n }\n@@ -226,16 +224,14 @@ real_non_cast_lvalue_p (tree ref)\n    considered lvalues.  */\n \n int\n-lvalue_p (ref)\n-     tree ref;\n+lvalue_p (tree ref)\n {\n   return \n     (lvalue_p_1 (ref, /*class rvalue ok*/ 1, /*cast*/ 1) != clk_none);\n }\n \n int\n-non_cast_lvalue_p (ref)\n-     tree ref;\n+non_cast_lvalue_p (tree ref)\n {\n   return \n     (lvalue_p_1 (ref, /*class rvalue ok*/ 1, /*cast*/ 0) != clk_none);\n@@ -245,9 +241,7 @@ non_cast_lvalue_p (ref)\n    otherwise, print an error message and return zero.  */\n \n int\n-lvalue_or_else (ref, string)\n-     tree ref;\n-     const char *string;\n+lvalue_or_else (tree ref, const char* string)\n {\n   int ret = lvalue_p_1 (ref, /* class rvalue ok */ 1, /* cast ok */ 1);\n   int win = (ret != clk_none);\n@@ -257,9 +251,7 @@ lvalue_or_else (ref, string)\n }\n \n int\n-non_cast_lvalue_or_else (ref, string)\n-     tree ref;\n-     const char *string;\n+non_cast_lvalue_or_else (tree ref, const char* string)\n {\n   int ret = lvalue_p_1 (ref, /* class rvalue ok */ 1, /* cast ok */ 0);\n   int win = (ret != clk_none);\n@@ -271,9 +263,7 @@ non_cast_lvalue_or_else (ref, string)\n /* Build a TARGET_EXPR, initializing the DECL with the VALUE.  */\n \n static tree\n-build_target_expr (decl, value)\n-     tree decl;\n-     tree value;\n+build_target_expr (tree decl, tree value)\n {\n   tree t;\n \n@@ -296,9 +286,7 @@ build_target_expr (decl, value)\n    and language-specific expression expanders.  */\n \n tree\n-build_cplus_new (type, init)\n-     tree type;\n-     tree init;\n+build_cplus_new (tree type, tree init)\n {\n   tree fn;\n   tree slot;\n@@ -351,9 +339,7 @@ build_cplus_new (type, init)\n    indicated TYPE.  */\n \n tree\n-build_target_expr_with_type (init, type)\n-     tree init;\n-     tree type;\n+build_target_expr_with_type (tree init, tree type)\n {\n   tree slot;\n   tree rval;\n@@ -373,8 +359,7 @@ build_target_expr_with_type (init, type)\n /* Like build_target_expr_with_type, but use the type of INIT.  */\n \n tree\n-get_target_expr (init)\n-     tree init;\n+get_target_expr (tree init)\n {\n   return build_target_expr_with_type (init, TREE_TYPE (init));\n }\n@@ -384,8 +369,7 @@ get_target_expr (init)\n    containing CALL_EXPRs.  */\n \n tree\n-break_out_calls (exp)\n-     tree exp;\n+break_out_calls (tree exp)\n {\n   register tree t1, t2 = NULL_TREE;\n   register enum tree_code code;\n@@ -466,8 +450,7 @@ break_out_calls (exp)\n    are described by RETTYPE.  If each type exists already, reuse it.  */\n \n tree\n-build_cplus_method_type (basetype, rettype, argtypes)\n-     tree basetype, rettype, argtypes;\n+build_cplus_method_type (tree basetype, tree rettype, tree argtypes)\n {\n   register tree t;\n   tree ptype;\n@@ -500,9 +483,7 @@ build_cplus_method_type (basetype, rettype, argtypes)\n }\n \n static tree\n-build_cplus_array_type_1 (elt_type, index_type)\n-     tree elt_type;\n-     tree index_type;\n+build_cplus_array_type_1 (tree elt_type, tree index_type)\n {\n   tree t;\n \n@@ -535,9 +516,7 @@ build_cplus_array_type_1 (elt_type, index_type)\n }\n \n tree\n-build_cplus_array_type (elt_type, index_type)\n-     tree elt_type;\n-     tree index_type;\n+build_cplus_array_type (tree elt_type, tree index_type)\n {\n   tree t;\n   int type_quals = cp_type_quals (elt_type);\n@@ -576,10 +555,9 @@ build_cplus_array_type (elt_type, index_type)\n    in a similar manner for restricting non-pointer types.  */\n  \n tree\n-cp_build_qualified_type_real (type, type_quals, complain)\n-     tree type;\n-     int type_quals;\n-     tsubst_flags_t complain;\n+cp_build_qualified_type_real (tree type, \n+                              int type_quals, \n+                              tsubst_flags_t complain)\n {\n   tree result;\n   int bad_quals = TYPE_UNQUALIFIED;\n@@ -718,8 +696,7 @@ cp_build_qualified_type_real (type, type_quals, complain)\n    compatible types.  */\n \n tree\n-canonical_type_variant (t)\n-     tree t;\n+canonical_type_variant (tree t)\n {\n   return cp_build_qualified_type (TYPE_MAIN_VARIANT (t), cp_type_quals (t));\n }\n@@ -739,8 +716,7 @@ canonical_type_variant (t)\n    dependent bases in non-instantiated templates).  */\n \n tree\n-copy_base_binfos (binfo, t, prev)\n-     tree binfo, t, prev;\n+copy_base_binfos (tree binfo, tree t, tree prev)\n {\n   tree binfos = BINFO_BASETYPES (binfo);\n   int n, ix;\n@@ -824,9 +800,7 @@ struct list_proxy\n    for a node we are thinking about adding).  */\n \n static int\n-list_hash_eq (entry, data)\n-     const void *entry;\n-     const void *data;\n+list_hash_eq (const void* entry, const void* data)\n {\n   tree t = (tree) entry;\n   struct list_proxy *proxy = (struct list_proxy *) data;\n@@ -841,10 +815,7 @@ list_hash_eq (entry, data)\n    TREE_COMMON slots), by adding the hash codes of the individual entries.  */\n \n static hashval_t\n-list_hash_pieces (purpose, value, chain)\n-     tree purpose;\n-     tree value;\n-     tree chain;\n+list_hash_pieces (tree purpose, tree value, tree chain)\n {\n   hashval_t hashcode = 0;\n   \n@@ -865,8 +836,7 @@ list_hash_pieces (purpose, value, chain)\n /* Hash an already existing TREE_LIST.  */\n \n static hashval_t\n-list_hash (p)\n-     const void *p;\n+list_hash (const void* p)\n {\n   tree t = (tree) p;\n   return list_hash_pieces (TREE_PURPOSE (t), \n@@ -879,8 +849,7 @@ list_hash (p)\n    new one, and record it as the canonical object.  */\n \n tree\n-hash_tree_cons (purpose, value, chain)\n-     tree purpose, value, chain;\n+hash_tree_cons (tree purpose, tree value, tree chain)\n {\n   int hashcode = 0;\n   PTR* slot;\n@@ -905,17 +874,15 @@ hash_tree_cons (purpose, value, chain)\n /* Constructor for hashed lists.  */\n \n tree\n-hash_tree_chain (value, chain)\n-     tree value, chain;\n+hash_tree_chain (tree value, tree chain)\n {\n   return hash_tree_cons (NULL_TREE, value, chain);\n }\n \n /* Similar, but used for concatenating two lists.  */\n \n tree\n-hash_chainon (list1, list2)\n-     tree list1, list2;\n+hash_chainon (tree list1, tree list2)\n {\n   if (list2 == 0)\n     return list1;\n@@ -943,9 +910,7 @@ hash_chainon (list1, list2)\n    VIRTUALS are the virtual functions sitting in VTABLE.  */\n \n tree\n-make_binfo (offset, binfo, vtable, virtuals)\n-     tree offset, binfo;\n-     tree vtable, virtuals;\n+make_binfo (tree offset, tree binfo, tree vtable, tree virtuals)\n {\n   tree new_binfo = make_tree_vec (BINFO_LANG_ELTS);\n   tree type;\n@@ -978,8 +943,7 @@ make_binfo (offset, binfo, vtable, virtuals)\n }\n \n void\n-debug_binfo (elem)\n-     tree elem;\n+debug_binfo (tree elem)\n {\n   HOST_WIDE_INT n;\n   tree virtuals;\n@@ -1010,8 +974,7 @@ debug_binfo (elem)\n }\n \n int\n-count_functions (t)\n-     tree t;\n+count_functions (tree t)\n {\n   int i;\n   if (TREE_CODE (t) == FUNCTION_DECL)\n@@ -1028,8 +991,7 @@ count_functions (t)\n }\n \n int\n-is_overloaded_fn (x)\n-     tree x;\n+is_overloaded_fn (tree x)\n {\n   /* A baselink is also considered an overloaded function.  */\n   if (TREE_CODE (x) == OFFSET_REF)\n@@ -1043,8 +1005,7 @@ is_overloaded_fn (x)\n }\n \n int\n-really_overloaded_fn (x)\n-     tree x;\n+really_overloaded_fn (tree x)\n {     \n   /* A baselink is also considered an overloaded function.  */\n   if (TREE_CODE (x) == OFFSET_REF)\n@@ -1058,8 +1019,7 @@ really_overloaded_fn (x)\n }\n \n tree\n-get_first_fn (from)\n-     tree from;\n+get_first_fn (tree from)\n {\n   my_friendly_assert (is_overloaded_fn (from), 9);\n   /* A baselink is also considered an overloaded function.  */\n@@ -1072,8 +1032,7 @@ get_first_fn (from)\n    member function.  */\n \n int\n-bound_pmf_p (t)\n-     tree t;\n+bound_pmf_p (tree t)\n {\n   return (TREE_CODE (t) == OFFSET_REF\n \t  && TYPE_PTRMEMFUNC_P (TREE_TYPE (TREE_OPERAND (t, 1))));\n@@ -1082,9 +1041,7 @@ bound_pmf_p (t)\n /* Return a new OVL node, concatenating it with the old one.  */\n \n tree\n-ovl_cons (decl, chain)\n-     tree decl;\n-     tree chain;\n+ovl_cons (tree decl, tree chain)\n {\n   tree result = make_node (OVERLOAD);\n   TREE_TYPE (result) = unknown_type_node;\n@@ -1098,9 +1055,7 @@ ovl_cons (decl, chain)\n    just return it; otherwise, ovl_cons the _DECLs */\n \n tree\n-build_overload (decl, chain)\n-     tree decl;\n-     tree chain;\n+build_overload (tree decl, tree chain)\n {\n   if (! chain && TREE_CODE (decl) != TEMPLATE_DECL)\n     return decl;\n@@ -1110,8 +1065,7 @@ build_overload (decl, chain)\n }\n \n int\n-is_aggr_type_2 (t1, t2)\n-     tree t1, t2;\n+is_aggr_type_2 (tree t1, tree t2)\n {\n   if (TREE_CODE (t1) != TREE_CODE (t2))\n     return 0;\n@@ -1121,9 +1075,7 @@ is_aggr_type_2 (t1, t2)\n #define PRINT_RING_SIZE 4\n \n const char *\n-cxx_printable_name (decl, v)\n-     tree decl;\n-     int v;\n+cxx_printable_name (tree decl, int v)\n {\n   static tree decl_ring[PRINT_RING_SIZE];\n   static char *print_ring[PRINT_RING_SIZE];\n@@ -1167,9 +1119,7 @@ cxx_printable_name (decl, v)\n    listed in RAISES.  */\n \n tree\n-build_exception_variant (type, raises)\n-     tree type;\n-     tree raises;\n+build_exception_variant (tree type, tree raises)\n {\n   tree v = TYPE_MAIN_VARIANT (type);\n   int type_quals = TYPE_QUALS (type);\n@@ -1190,9 +1140,7 @@ build_exception_variant (type, raises)\n    arguments.  */\n \n tree\n-bind_template_template_parm (t, newargs)\n-     tree t;\n-     tree newargs;\n+bind_template_template_parm (tree t, tree newargs)\n {\n   tree decl = TYPE_NAME (t);\n   tree t2;\n@@ -1219,10 +1167,9 @@ bind_template_template_parm (t, newargs)\n /* Called from count_trees via walk_tree.  */\n \n static tree\n-count_trees_r (tp, walk_subtrees, data)\n-     tree *tp ATTRIBUTE_UNUSED;\n-     int *walk_subtrees ATTRIBUTE_UNUSED;\n-     void *data;\n+count_trees_r (tree* tp ATTRIBUTE_UNUSED , \n+               int* walk_subtrees ATTRIBUTE_UNUSED , \n+               void* data)\n {\n   ++ *((int*) data);\n   return NULL_TREE;\n@@ -1232,8 +1179,7 @@ count_trees_r (tp, walk_subtrees, data)\n    representation.  */\n \n int\n-count_trees (t)\n-     tree t;\n+count_trees (tree t)\n {\n   int n_trees = 0;\n   walk_tree_without_duplicates (&t, count_trees_r, &n_trees);\n@@ -1243,10 +1189,9 @@ count_trees (t)\n /* Called from verify_stmt_tree via walk_tree.  */\n \n static tree\n-verify_stmt_tree_r (tp, walk_subtrees, data)\n-     tree *tp;\n-     int *walk_subtrees ATTRIBUTE_UNUSED;\n-     void *data;\n+verify_stmt_tree_r (tree* tp, \n+                    int* walk_subtrees ATTRIBUTE_UNUSED , \n+                    void* data)\n {\n   tree t = *tp;\n   htab_t *statements = (htab_t *) data;\n@@ -1271,8 +1216,7 @@ verify_stmt_tree_r (tp, walk_subtrees, data)\n    circularities.  */\n \n void\n-verify_stmt_tree (t)\n-     tree t;\n+verify_stmt_tree (tree t)\n {\n   htab_t statements;\n   statements = htab_create (37, htab_hash_pointer, htab_eq_pointer, NULL);\n@@ -1283,10 +1227,9 @@ verify_stmt_tree (t)\n /* Called from find_tree via walk_tree.  */\n \n static tree\n-find_tree_r (tp, walk_subtrees, data)\n-     tree *tp;\n-     int *walk_subtrees ATTRIBUTE_UNUSED;\n-     void *data;\n+find_tree_r (tree* tp, \n+             int* walk_subtrees ATTRIBUTE_UNUSED , \n+             void* data)\n {\n   if (*tp == (tree) data)\n     return (tree) data;\n@@ -1297,20 +1240,17 @@ find_tree_r (tp, walk_subtrees, data)\n /* Returns X if X appears in the tree structure rooted at T.  */\n \n tree\n-find_tree (t, x)\n-     tree t;\n-     tree x;\n+find_tree (tree t, tree x)\n {\n   return walk_tree_without_duplicates (&t, find_tree_r, x);\n }\n \n /* Passed to walk_tree.  Checks for the use of types with no linkage.  */\n \n static tree\n-no_linkage_helper (tp, walk_subtrees, data)\n-     tree *tp;\n-     int *walk_subtrees ATTRIBUTE_UNUSED;\n-     void *data ATTRIBUTE_UNUSED;\n+no_linkage_helper (tree* tp, \n+                   int* walk_subtrees ATTRIBUTE_UNUSED , \n+                   void* data ATTRIBUTE_UNUSED )\n {\n   tree t = *tp;\n \n@@ -1326,8 +1266,7 @@ no_linkage_helper (tp, walk_subtrees, data)\n    it.  */\n \n tree\n-no_linkage_check (t)\n-     tree t;\n+no_linkage_check (tree t)\n {\n   /* There's no point in checking linkage on template functions; we\n      can't know their complete types.  */\n@@ -1345,7 +1284,7 @@ extern int depth_reached;\n #endif\n \n void\n-cxx_print_statistics ()\n+cxx_print_statistics (void)\n {\n   print_search_statistics ();\n   print_class_statistics ();\n@@ -1360,8 +1299,7 @@ cxx_print_statistics ()\n    array.  */\n \n tree\n-array_type_nelts_top (type)\n-     tree type;\n+array_type_nelts_top (tree type)\n {\n   return fold (build (PLUS_EXPR, sizetype,\n \t\t      array_type_nelts (type),\n@@ -1373,8 +1311,7 @@ array_type_nelts_top (type)\n    ARRAY_TYPEs that are clumped together.  */\n \n tree\n-array_type_nelts_total (type)\n-     tree type;\n+array_type_nelts_total (tree type)\n {\n   tree sz = array_type_nelts_top (type);\n   type = TREE_TYPE (type);\n@@ -1390,10 +1327,7 @@ array_type_nelts_total (type)\n /* Called from break_out_target_exprs via mapcar.  */\n \n static tree\n-bot_manip (tp, walk_subtrees, data)\n-     tree *tp;\n-     int *walk_subtrees;\n-     void *data;\n+bot_manip (tree* tp, int* walk_subtrees, void* data)\n {\n   splay_tree target_remap = ((splay_tree) data);\n   tree t = *tp;\n@@ -1447,10 +1381,9 @@ bot_manip (tp, walk_subtrees, data)\n    variables.  */\n \n static tree\n-bot_replace (t, walk_subtrees, data)\n-     tree *t;\n-     int *walk_subtrees ATTRIBUTE_UNUSED;\n-     void *data;\n+bot_replace (tree* t, \n+             int* walk_subtrees ATTRIBUTE_UNUSED , \n+             void* data)\n {\n   splay_tree target_remap = ((splay_tree) data);\n \n@@ -1471,8 +1404,7 @@ bot_replace (t, walk_subtrees, data)\n    we must replace the temporaries with appropriate local versions.  */\n \n tree\n-break_out_target_exprs (t)\n-     tree t;\n+break_out_target_exprs (tree t)\n {\n   static int target_remap_count;\n   static splay_tree target_remap;\n@@ -1559,8 +1491,7 @@ build_min (enum tree_code code, tree tt, ...)\n static GTY(()) tree shared_int_cache[256];\n \n tree\n-build_shared_int_cst (i)\n-     int i;\n+build_shared_int_cst (int i)\n {\n   if (i >= 256)\n     return build_int_2 (i, 0);\n@@ -1572,8 +1503,7 @@ build_shared_int_cst (i)\n }\n \n tree\n-get_type_decl (t)\n-     tree t;\n+get_type_decl (tree t)\n {\n   if (TREE_CODE (t) == TYPE_DECL)\n     return t;\n@@ -1592,8 +1522,7 @@ get_type_decl (t)\n    Return 0 if ELEM is not in VEC.  VEC may be NULL_TREE.  */\n \n tree\n-vec_binfo_member (elem, vec)\n-     tree elem, vec;\n+vec_binfo_member (tree elem, tree vec)\n {\n   int i;\n \n@@ -1609,8 +1538,7 @@ vec_binfo_member (elem, vec)\n    indirectly.  */\n \n tree\n-decl_namespace_context (decl)\n-     tree decl;\n+decl_namespace_context (tree decl)\n {\n   while (1)\n     {\n@@ -1630,8 +1558,7 @@ decl_namespace_context (decl)\n    this function.  */\n \n int\n-cp_tree_equal (t1, t2)\n-     tree t1, t2;\n+cp_tree_equal (tree t1, tree t2)\n {\n   register enum tree_code code1, code2;\n   int cmp;\n@@ -1791,8 +1718,7 @@ cp_tree_equal (t1, t2)\n    tree.  */\n \n tree\n-build_zc_wrapper (ptr)\n-     struct z_candidate *ptr;\n+build_zc_wrapper (struct z_candidate* ptr)\n {\n   tree t = make_node (WRAPPER);\n   WRAPPER_ZC (t) = ptr;\n@@ -1802,8 +1728,7 @@ build_zc_wrapper (ptr)\n /* The type of ARG when used as an lvalue.  */\n \n tree\n-lvalue_type (arg)\n-     tree arg;\n+lvalue_type (tree arg)\n {\n   tree type = TREE_TYPE (arg);\n   if (TREE_CODE (arg) == OVERLOAD)\n@@ -1815,8 +1740,7 @@ lvalue_type (arg)\n    reference types.  */\n \n tree\n-error_type (arg)\n-     tree arg;\n+error_type (tree arg)\n {\n   tree type = TREE_TYPE (arg);\n   if (TREE_CODE (type) == ARRAY_TYPE)\n@@ -1832,8 +1756,7 @@ error_type (arg)\n /* Does FUNCTION use a variable-length argument list?  */\n \n int\n-varargs_function_p (function)\n-     tree function;\n+varargs_function_p (tree function)\n {\n   tree parm = TYPE_ARG_TYPES (TREE_TYPE (function));\n   for (; parm; parm = TREE_CHAIN (parm))\n@@ -1845,8 +1768,7 @@ varargs_function_p (function)\n /* Returns 1 if decl is a member of a class.  */\n \n int\n-member_p (decl)\n-     tree decl;\n+member_p (tree decl)\n {\n   const tree ctx = DECL_CONTEXT (decl);\n   return (ctx && TYPE_P (ctx));\n@@ -1856,8 +1778,7 @@ member_p (decl)\n    object that the access is against.  */\n \n tree\n-build_dummy_object (type)\n-     tree type;\n+build_dummy_object (tree type)\n {\n   tree decl = build1 (NOP_EXPR, build_pointer_type (type), void_zero_node);\n   return build_indirect_ref (decl, NULL);\n@@ -1868,9 +1789,7 @@ build_dummy_object (type)\n    binfo path from current_class_type to TYPE, or 0.  */\n \n tree\n-maybe_dummy_object (type, binfop)\n-     tree type;\n-     tree *binfop;\n+maybe_dummy_object (tree type, tree* binfop)\n {\n   tree decl, context;\n   tree binfo;\n@@ -1905,8 +1824,7 @@ maybe_dummy_object (type, binfop)\n /* Returns 1 if OB is a placeholder object, or a pointer to one.  */\n \n int\n-is_dummy_object (ob)\n-     tree ob;\n+is_dummy_object (tree ob)\n {\n   if (TREE_CODE (ob) == INDIRECT_REF)\n     ob = TREE_OPERAND (ob, 0);\n@@ -1917,8 +1835,7 @@ is_dummy_object (ob)\n /* Returns 1 iff type T is a POD type, as defined in [basic.types].  */\n \n int\n-pod_type_p (t)\n-     tree t;\n+pod_type_p (tree t)\n {\n   t = strip_array_types (t);\n \n@@ -1946,8 +1863,7 @@ pod_type_p (t)\n    zeros in it.  */\n \n int\n-zero_init_p (t)\n-     tree t;\n+zero_init_p (tree t)\n {\n   t = strip_array_types (t);\n \n@@ -1979,12 +1895,11 @@ const struct attribute_spec cxx_attribute_table[] =\n /* Handle a \"java_interface\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n static tree\n-handle_java_interface_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags;\n-     bool *no_add_attrs;\n+handle_java_interface_attribute (tree* node, \n+                                 tree name, \n+                                 tree args ATTRIBUTE_UNUSED , \n+                                 int flags, \n+                                 bool* no_add_attrs)\n {\n   if (DECL_P (*node)\n       || !CLASS_TYPE_P (*node)\n@@ -2005,12 +1920,11 @@ handle_java_interface_attribute (node, name, args, flags, no_add_attrs)\n /* Handle a \"com_interface\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n static tree\n-handle_com_interface_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+handle_com_interface_attribute (tree* node, \n+                                tree name, \n+                                tree args ATTRIBUTE_UNUSED , \n+                                int flags ATTRIBUTE_UNUSED , \n+                                bool* no_add_attrs)\n {\n   static int warned;\n \n@@ -2035,12 +1949,11 @@ handle_com_interface_attribute (node, name, args, flags, no_add_attrs)\n /* Handle an \"init_priority\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n static tree\n-handle_init_priority_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+handle_init_priority_attribute (tree* node, \n+                                tree name, \n+                                tree args, \n+                                int flags ATTRIBUTE_UNUSED , \n+                                bool* no_add_attrs)\n {\n   tree initp_expr = TREE_VALUE (args);\n   tree decl = *node;\n@@ -2111,9 +2024,7 @@ handle_init_priority_attribute (node, name, args, flags, no_add_attrs)\n    thing pointed to by the constant.  */\n \n tree\n-make_ptrmem_cst (type, member)\n-     tree type;\n-     tree member;\n+make_ptrmem_cst (tree type, tree member)\n {\n   tree ptrmem_cst = make_node (PTRMEM_CST);\n   /* If would seem a great convenience if make_node would set\n@@ -2128,12 +2039,11 @@ make_ptrmem_cst (type, member)\n    traversal.  Called from walk_tree().  */\n \n tree \n-cp_walk_subtrees (tp, walk_subtrees_p, func, data, htab)\n-     tree *tp;\n-     int *walk_subtrees_p;\n-     walk_tree_fn func;\n-     void *data;\n-     void *htab;\n+cp_walk_subtrees (tree* tp, \n+                  int* walk_subtrees_p, \n+                  walk_tree_fn func, \n+                  void* data, \n+                  void* htab)\n {\n   enum tree_code code = TREE_CODE (*tp);\n   tree result;\n@@ -2199,8 +2109,7 @@ cp_walk_subtrees (tp, walk_subtrees_p, func, data, htab)\n    function as a tree.  */\n \n int\n-cp_cannot_inline_tree_fn (fnp)\n-     tree *fnp;\n+cp_cannot_inline_tree_fn (tree* fnp)\n {\n   tree fn = *fnp;\n \n@@ -2251,9 +2160,7 @@ cp_cannot_inline_tree_fn (fnp)\n    return the latest function added to the array, PREV_FN.  */\n \n tree\n-cp_add_pending_fn_decls (fns_p, prev_fn)\n-     void *fns_p;\n-     tree prev_fn;\n+cp_add_pending_fn_decls (void* fns_p, tree prev_fn)\n {\n   varray_type *fnsp = (varray_type *)fns_p;\n   struct saved_scope *s;\n@@ -2273,8 +2180,7 @@ cp_add_pending_fn_decls (fns_p, prev_fn)\n    function.  */\n \n int\n-cp_is_overload_p (t)\n-     tree t;\n+cp_is_overload_p (tree t)\n {\n   return TREE_CODE (t) == OVERLOAD;\n }\n@@ -2283,8 +2189,7 @@ cp_is_overload_p (t)\n    function FN.  */\n \n int\n-cp_auto_var_in_fn_p (var, fn)\n-     tree var, fn;\n+cp_auto_var_in_fn_p (tree var, tree fn)\n {\n   return (DECL_P (var) && DECL_CONTEXT (var) == fn\n \t  && nonstatic_local_decl_p (var));\n@@ -2295,12 +2200,12 @@ cp_auto_var_in_fn_p (var, fn)\n    to be used.  */\n \n tree\n-cp_copy_res_decl_for_inlining (result, fn, caller, decl_map_,\n-\t\t\t       need_decl, return_slot_addr)\n-     tree result, fn, caller;\n-     void *decl_map_;\n-     int *need_decl;\n-     tree return_slot_addr;\n+cp_copy_res_decl_for_inlining (tree result, \n+                               tree fn, \n+                               tree caller, \n+                               void* decl_map_,\n+                               int* need_decl, \n+                               tree return_slot_addr)\n {\n   splay_tree decl_map = (splay_tree)decl_map_;\n   tree var;\n@@ -2362,8 +2267,7 @@ cp_copy_res_decl_for_inlining (result, fn, caller, decl_map_,\n    that's OK.  Used for lang_hooks.tree_inlining.start_inlining.  */\n \n int\n-cp_start_inlining (fn)\n-     tree fn;\n+cp_start_inlining (tree fn)\n {\n   if (DECL_TEMPLATE_INSTANTIATION (fn))\n     return push_tinst_level (fn);\n@@ -2375,8 +2279,7 @@ cp_start_inlining (fn)\n    lang_hooks.tree_inlining.end_inlining.  */\n \n void\n-cp_end_inlining (fn)\n-     tree fn ATTRIBUTE_UNUSED;\n+cp_end_inlining (tree fn ATTRIBUTE_UNUSED )\n {\n   if (DECL_TEMPLATE_INSTANTIATION (fn))\n     pop_tinst_level ();\n@@ -2385,7 +2288,7 @@ cp_end_inlining (fn)\n /* Initialize tree.c.  */\n \n void\n-init_tree ()\n+init_tree (void)\n {\n   list_hash_table = htab_create_ggc (31, list_hash, list_hash_eq, NULL);\n }\n@@ -2395,10 +2298,9 @@ init_tree ()\n    pointed to by DATA (which is really a `splay_tree *').  */\n \n static tree\n-mark_local_for_remap_r (tp, walk_subtrees, data)\n-     tree *tp;\n-     int *walk_subtrees ATTRIBUTE_UNUSED;\n-     void *data;\n+mark_local_for_remap_r (tree* tp, \n+                        int* walk_subtrees ATTRIBUTE_UNUSED , \n+                        void* data)\n {\n   tree t = *tp;\n   splay_tree st = (splay_tree) data;\n@@ -2441,10 +2343,9 @@ mark_local_for_remap_r (tp, walk_subtrees, data)\n    remaps all local declarations to appropriate replacements.  */\n \n static tree\n-cp_unsave_r (tp, walk_subtrees, data)\n-     tree *tp;\n-     int *walk_subtrees;\n-     void *data;\n+cp_unsave_r (tree* tp, \n+             int* walk_subtrees, \n+             void* data)\n {\n   splay_tree st = (splay_tree) data;\n   splay_tree_node n;\n@@ -2476,8 +2377,7 @@ cp_unsave_r (tp, walk_subtrees, data)\n /* Called whenever an expression needs to be unsaved.  */\n \n tree\n-cxx_unsave_expr_now (tp)\n-     tree tp;\n+cxx_unsave_expr_now (tree tp)\n {\n   splay_tree st;\n \n@@ -2502,8 +2402,7 @@ cxx_unsave_expr_now (tp)\n    predicate to test whether or not DECL is a special function.  */\n \n special_function_kind\n-special_function_p (decl)\n-     tree decl;\n+special_function_p (tree decl)\n {\n   /* Rather than doing all this stuff with magic names, we should\n      probably have a field of type `special_function_kind' in\n@@ -2547,8 +2446,7 @@ name_p (tree node)\n /* Returns nonzero if TYPE is a character type, including wchar_t.  */\n \n int\n-char_type_p (type)\n-     tree type;\n+char_type_p (tree type)\n {\n   return (same_type_p (type, char_type_node)\n \t  || same_type_p (type, unsigned_char_type_node)\n@@ -2564,8 +2462,7 @@ char_type_p (type)\n    as a global symbol when you run `nm' on the resulting object file.  */\n \n linkage_kind\n-decl_linkage (decl)\n-     tree decl;\n+decl_linkage (tree decl)\n {\n   /* This function doesn't attempt to calculate the linkage from first\n      principles as given in [basic.link].  Instead, it makes use of\n@@ -2604,9 +2501,7 @@ decl_linkage (decl)\n    expression to use the precalculated result.  */\n \n tree\n-stabilize_expr (exp, initp)\n-     tree exp;\n-     tree *initp;\n+stabilize_expr (tree exp, tree* initp)\n {\n   tree init_expr;\n \n@@ -2637,10 +2532,7 @@ stabilize_expr (exp, initp)\n    node has been accessed improperly.  */\n \n void\n-lang_check_failed (file, line, function)\n-     const char *file;\n-     int line;\n-     const char *function;\n+lang_check_failed (const char* file, int line, const char* function)\n {\n   internal_error (\"lang_* check: failed in %s, at %s:%d\",\n \t\t  function, trim_filename (file), line);"}]}