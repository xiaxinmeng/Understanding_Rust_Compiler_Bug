{"sha": "d824aea207d38cb67dcafd992c9ce3fd46afb7d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDgyNGFlYTIwN2QzOGNiNjdkY2FmZDk5MmM5Y2UzZmQ0NmFmYjdkOQ==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2010-11-16T14:19:43Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2010-11-16T14:19:43Z"}, "message": "expr.c (alignment_for_piecewise_move): New function.\n\n\t* expr.c (alignment_for_piecewise_move): New function.\n\t(widest_int_mode_for_size): New function.\n\t(move_by_pieces, move_by_pieces_ninsns): Call them.\n\t(can_store_by_pieces, store_by_pieces_1): Likewise.\n\nFrom-SVN: r166802", "tree": {"sha": "009d184c66e63f2861848fdff7492820d9952dc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/009d184c66e63f2861848fdff7492820d9952dc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d824aea207d38cb67dcafd992c9ce3fd46afb7d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d824aea207d38cb67dcafd992c9ce3fd46afb7d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d824aea207d38cb67dcafd992c9ce3fd46afb7d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d824aea207d38cb67dcafd992c9ce3fd46afb7d9/comments", "author": null, "committer": null, "parents": [{"sha": "69d540bdc7418ff3fc91f5de114c40a1b99cb454", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69d540bdc7418ff3fc91f5de114c40a1b99cb454", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69d540bdc7418ff3fc91f5de114c40a1b99cb454"}], "stats": {"total": 167, "additions": 71, "deletions": 96}, "files": [{"sha": "5f9d267cbd459a0c5b32194f4024e18dac5c1d51", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d824aea207d38cb67dcafd992c9ce3fd46afb7d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d824aea207d38cb67dcafd992c9ce3fd46afb7d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d824aea207d38cb67dcafd992c9ce3fd46afb7d9", "patch": "@@ -1,3 +1,10 @@\n+2010-11-16  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* expr.c (alignment_for_piecewise_move): New function.\n+\t(widest_int_mode_for_size): New function.\n+\t(move_by_pieces, move_by_pieces_ninsns): Call them.\n+\t(can_store_by_pieces, store_by_pieces_1): Likewise.\n+\n 2010-11-16  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* gcc.c (char_p): Define.  Define a VEC of it."}, {"sha": "889c34ef6d04ec426ae1b41722055414de7ae0cb", "filename": "gcc/expr.c", "status": "modified", "additions": 64, "deletions": 96, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d824aea207d38cb67dcafd992c9ce3fd46afb7d9/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d824aea207d38cb67dcafd992c9ce3fd46afb7d9/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=d824aea207d38cb67dcafd992c9ce3fd46afb7d9", "patch": "@@ -792,6 +792,50 @@ convert_modes (enum machine_mode mode, enum machine_mode oldmode, rtx x, int uns\n   return temp;\n }\n \f\n+/* Return the largest alignment we can use for doing a move (or store)\n+   of MAX_PIECES.  ALIGN is the largest alignment we could use.  */\n+\n+static unsigned int\n+alignment_for_piecewise_move (unsigned int max_pieces, unsigned int align)\n+{\n+  enum machine_mode tmode;\n+\n+  tmode = mode_for_size (max_pieces * BITS_PER_UNIT, MODE_INT, 1);\n+  if (align >= GET_MODE_ALIGNMENT (tmode))\n+    align = GET_MODE_ALIGNMENT (tmode);\n+  else\n+    {\n+      enum machine_mode tmode, xmode;\n+\n+      for (tmode = GET_CLASS_NARROWEST_MODE (MODE_INT), xmode = tmode;\n+\t   tmode != VOIDmode;\n+\t   xmode = tmode, tmode = GET_MODE_WIDER_MODE (tmode))\n+\tif (GET_MODE_SIZE (tmode) > max_pieces\n+\t    || SLOW_UNALIGNED_ACCESS (tmode, align))\n+\t  break;\n+\n+      align = MAX (align, GET_MODE_ALIGNMENT (xmode));\n+    }\n+\n+  return align;\n+}\n+\n+/* Return the widest integer mode no wider than SIZE.  If no such mode\n+   can be found, return VOIDmode.  */\n+\n+static enum machine_mode\n+widest_int_mode_for_size (unsigned int size)\n+{\n+  enum machine_mode tmode, mode = VOIDmode;\n+\n+  for (tmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n+       tmode != VOIDmode; tmode = GET_MODE_WIDER_MODE (tmode))\n+    if (GET_MODE_SIZE (tmode) < size)\n+      mode = tmode;\n+\n+  return mode;\n+}\n+\n /* STORE_MAX_PIECES is the number of bytes at a time that we can\n    store efficiently.  Due to internal GCC limitations, this is\n    MOVE_MAX_PIECES limited by the number of bytes GCC can represent\n@@ -831,7 +875,6 @@ move_by_pieces (rtx to, rtx from, unsigned HOST_WIDE_INT len,\n     = targetm.addr_space.address_mode (MEM_ADDR_SPACE (from));\n   rtx to_addr, from_addr = XEXP (from, 0);\n   unsigned int max_size = MOVE_MAX_PIECES + 1;\n-  enum machine_mode mode = VOIDmode, tmode;\n   enum insn_code icode;\n \n   align = MIN (to ? MEM_ALIGN (to) : align, MEM_ALIGN (from));\n@@ -879,11 +922,11 @@ move_by_pieces (rtx to, rtx from, unsigned HOST_WIDE_INT len,\n   if (!(data.autinc_from && data.autinc_to)\n       && move_by_pieces_ninsns (len, align, max_size) > 2)\n     {\n-      /* Find the mode of the largest move...  */\n-      for (tmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-\t   tmode != VOIDmode; tmode = GET_MODE_WIDER_MODE (tmode))\n-\tif (GET_MODE_SIZE (tmode) < max_size)\n-\t  mode = tmode;\n+      /* Find the mode of the largest move...\n+\t MODE might not be used depending on the definitions of the\n+\t USE_* macros below.  */\n+      enum machine_mode mode ATTRIBUTE_UNUSED\n+\t= widest_int_mode_for_size (max_size);\n \n       if (USE_LOAD_PRE_DECREMENT (mode) && data.reverse && ! data.autinc_from)\n \t{\n@@ -917,32 +960,14 @@ move_by_pieces (rtx to, rtx from, unsigned HOST_WIDE_INT len,\n \tdata.to_addr = copy_to_mode_reg (to_addr_mode, to_addr);\n     }\n \n-  tmode = mode_for_size (MOVE_MAX_PIECES * BITS_PER_UNIT, MODE_INT, 1);\n-  if (align >= GET_MODE_ALIGNMENT (tmode))\n-    align = GET_MODE_ALIGNMENT (tmode);\n-  else\n-    {\n-      enum machine_mode xmode;\n-\n-      for (tmode = GET_CLASS_NARROWEST_MODE (MODE_INT), xmode = tmode;\n-\t   tmode != VOIDmode;\n-\t   xmode = tmode, tmode = GET_MODE_WIDER_MODE (tmode))\n-\tif (GET_MODE_SIZE (tmode) > MOVE_MAX_PIECES\n-\t    || SLOW_UNALIGNED_ACCESS (tmode, align))\n-\t  break;\n-\n-      align = MAX (align, GET_MODE_ALIGNMENT (xmode));\n-    }\n+  align = alignment_for_piecewise_move (MOVE_MAX_PIECES, align);\n \n   /* First move what we can in the largest integer mode, then go to\n      successively smaller modes.  */\n \n   while (max_size > 1)\n     {\n-      for (tmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-\t   tmode != VOIDmode; tmode = GET_MODE_WIDER_MODE (tmode))\n-\tif (GET_MODE_SIZE (tmode) < max_size)\n-\t  mode = tmode;\n+      enum machine_mode mode = widest_int_mode_for_size (max_size);\n \n       if (mode == VOIDmode)\n \tbreak;\n@@ -996,34 +1021,15 @@ move_by_pieces_ninsns (unsigned HOST_WIDE_INT l, unsigned int align,\n \t\t       unsigned int max_size)\n {\n   unsigned HOST_WIDE_INT n_insns = 0;\n-  enum machine_mode tmode;\n \n-  tmode = mode_for_size (MOVE_MAX_PIECES * BITS_PER_UNIT, MODE_INT, 1);\n-  if (align >= GET_MODE_ALIGNMENT (tmode))\n-    align = GET_MODE_ALIGNMENT (tmode);\n-  else\n-    {\n-      enum machine_mode tmode, xmode;\n-\n-      for (tmode = GET_CLASS_NARROWEST_MODE (MODE_INT), xmode = tmode;\n-\t   tmode != VOIDmode;\n-\t   xmode = tmode, tmode = GET_MODE_WIDER_MODE (tmode))\n-\tif (GET_MODE_SIZE (tmode) > MOVE_MAX_PIECES\n-\t    || SLOW_UNALIGNED_ACCESS (tmode, align))\n-\t  break;\n-\n-      align = MAX (align, GET_MODE_ALIGNMENT (xmode));\n-    }\n+  align = alignment_for_piecewise_move (MOVE_MAX_PIECES, align);\n \n   while (max_size > 1)\n     {\n-      enum machine_mode mode = VOIDmode;\n+      enum machine_mode mode;\n       enum insn_code icode;\n \n-      for (tmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-\t   tmode != VOIDmode; tmode = GET_MODE_WIDER_MODE (tmode))\n-\tif (GET_MODE_SIZE (tmode) < max_size)\n-\t  mode = tmode;\n+      mode = widest_int_mode_for_size (max_size);\n \n       if (mode == VOIDmode)\n \tbreak;\n@@ -2258,7 +2264,7 @@ can_store_by_pieces (unsigned HOST_WIDE_INT len,\n   unsigned HOST_WIDE_INT l;\n   unsigned int max_size;\n   HOST_WIDE_INT offset = 0;\n-  enum machine_mode mode, tmode;\n+  enum machine_mode mode;\n   enum insn_code icode;\n   int reverse;\n   /* cst is set but not used if LEGITIMATE_CONSTANT doesn't use it.  */\n@@ -2272,22 +2278,7 @@ can_store_by_pieces (unsigned HOST_WIDE_INT len,\n \t : STORE_BY_PIECES_P (len, align)))\n     return 0;\n \n-  tmode = mode_for_size (STORE_MAX_PIECES * BITS_PER_UNIT, MODE_INT, 1);\n-  if (align >= GET_MODE_ALIGNMENT (tmode))\n-    align = GET_MODE_ALIGNMENT (tmode);\n-  else\n-    {\n-      enum machine_mode xmode;\n-\n-      for (tmode = GET_CLASS_NARROWEST_MODE (MODE_INT), xmode = tmode;\n-\t   tmode != VOIDmode;\n-\t   xmode = tmode, tmode = GET_MODE_WIDER_MODE (tmode))\n-\tif (GET_MODE_SIZE (tmode) > STORE_MAX_PIECES\n-\t    || SLOW_UNALIGNED_ACCESS (tmode, align))\n-\t  break;\n-\n-      align = MAX (align, GET_MODE_ALIGNMENT (xmode));\n-    }\n+  align = alignment_for_piecewise_move (STORE_MAX_PIECES, align);\n \n   /* We would first store what we can in the largest integer mode, then go to\n      successively smaller modes.  */\n@@ -2297,14 +2288,10 @@ can_store_by_pieces (unsigned HOST_WIDE_INT len,\n        reverse++)\n     {\n       l = len;\n-      mode = VOIDmode;\n       max_size = STORE_MAX_PIECES + 1;\n       while (max_size > 1)\n \t{\n-\t  for (tmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-\t       tmode != VOIDmode; tmode = GET_MODE_WIDER_MODE (tmode))\n-\t    if (GET_MODE_SIZE (tmode) < max_size)\n-\t      mode = tmode;\n+\t  mode = widest_int_mode_for_size (max_size);\n \n \t  if (mode == VOIDmode)\n \t    break;\n@@ -2445,7 +2432,6 @@ store_by_pieces_1 (struct store_by_pieces_d *data ATTRIBUTE_UNUSED,\n     = targetm.addr_space.address_mode (MEM_ADDR_SPACE (data->to));\n   rtx to_addr = XEXP (data->to, 0);\n   unsigned int max_size = STORE_MAX_PIECES + 1;\n-  enum machine_mode mode = VOIDmode, tmode;\n   enum insn_code icode;\n \n   data->offset = 0;\n@@ -2466,11 +2452,11 @@ store_by_pieces_1 (struct store_by_pieces_d *data ATTRIBUTE_UNUSED,\n   if (!data->autinc_to\n       && move_by_pieces_ninsns (data->len, align, max_size) > 2)\n     {\n-      /* Determine the main mode we'll be using.  */\n-      for (tmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-\t   tmode != VOIDmode; tmode = GET_MODE_WIDER_MODE (tmode))\n-\tif (GET_MODE_SIZE (tmode) < max_size)\n-\t  mode = tmode;\n+      /* Determine the main mode we'll be using.\n+\t MODE might not be used depending on the definitions of the\n+\t USE_* macros below.  */\n+      enum machine_mode mode ATTRIBUTE_UNUSED\n+\t= widest_int_mode_for_size (max_size);\n \n       if (USE_STORE_PRE_DECREMENT (mode) && data->reverse && ! data->autinc_to)\n \t{\n@@ -2492,32 +2478,14 @@ store_by_pieces_1 (struct store_by_pieces_d *data ATTRIBUTE_UNUSED,\n \tdata->to_addr = copy_to_mode_reg (to_addr_mode, to_addr);\n     }\n \n-  tmode = mode_for_size (STORE_MAX_PIECES * BITS_PER_UNIT, MODE_INT, 1);\n-  if (align >= GET_MODE_ALIGNMENT (tmode))\n-    align = GET_MODE_ALIGNMENT (tmode);\n-  else\n-    {\n-      enum machine_mode xmode;\n-\n-      for (tmode = GET_CLASS_NARROWEST_MODE (MODE_INT), xmode = tmode;\n-\t   tmode != VOIDmode;\n-\t   xmode = tmode, tmode = GET_MODE_WIDER_MODE (tmode))\n-\tif (GET_MODE_SIZE (tmode) > STORE_MAX_PIECES\n-\t    || SLOW_UNALIGNED_ACCESS (tmode, align))\n-\t  break;\n-\n-      align = MAX (align, GET_MODE_ALIGNMENT (xmode));\n-    }\n+  align = alignment_for_piecewise_move (STORE_MAX_PIECES, align);\n \n   /* First store what we can in the largest integer mode, then go to\n      successively smaller modes.  */\n \n   while (max_size > 1)\n     {\n-      for (tmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-\t   tmode != VOIDmode; tmode = GET_MODE_WIDER_MODE (tmode))\n-\tif (GET_MODE_SIZE (tmode) < max_size)\n-\t  mode = tmode;\n+      enum machine_mode mode = widest_int_mode_for_size (max_size);\n \n       if (mode == VOIDmode)\n \tbreak;"}]}