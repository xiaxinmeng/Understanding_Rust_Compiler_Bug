{"sha": "97816be433afedd0a407672b6f2fad23d179447b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTc4MTZiZTQzM2FmZWRkMGE0MDc2NzJiNmYyZmFkMjNkMTc5NDQ3Yg==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2016-06-17T09:05:05Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2016-06-17T09:05:05Z"}, "message": "tree-vectorizer.h (struct dr_with_seg_len): Remove class member OFFSET.\n\n\t* tree-vectorizer.h (struct dr_with_seg_len): Remove class\n\tmember OFFSET.\n\t* tree-vect-data-refs.c (operator ==): Handle DR_OFFSET directly,\n\trather than OFFSET.\n\t(comp_dr_with_seg_len_pair): Ditto.\n\t(vect_prune_runtime_alias_test_list): Ditto.  Also Canonicalize\n\tstruct dr_with_seg_len_pair against DR_OFFSET.\n\t* tree-vect-loop-manip.c (vect_create_cond_for_alias_checks): Handle\n\tDR_OFFSET directly.\n\n\t* gcc.dg/vect/vect-alias-check-1.c: New test.\n\nFrom-SVN: r237549", "tree": {"sha": "201086e3720f21a3b75bfb89f8db7b84f7824354", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/201086e3720f21a3b75bfb89f8db7b84f7824354"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/97816be433afedd0a407672b6f2fad23d179447b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97816be433afedd0a407672b6f2fad23d179447b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97816be433afedd0a407672b6f2fad23d179447b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97816be433afedd0a407672b6f2fad23d179447b/comments", "author": null, "committer": null, "parents": [{"sha": "7c80a459b96715dfb44708b7cef9f2813a7ff0ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c80a459b96715dfb44708b7cef9f2813a7ff0ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c80a459b96715dfb44708b7cef9f2813a7ff0ef"}], "stats": {"total": 121, "additions": 81, "deletions": 40}, "files": [{"sha": "d0699e2c3979ac68bc61569d1d580a18d63d8393", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97816be433afedd0a407672b6f2fad23d179447b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97816be433afedd0a407672b6f2fad23d179447b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=97816be433afedd0a407672b6f2fad23d179447b", "patch": "@@ -1,3 +1,15 @@\n+2016-06-17  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-vectorizer.h (struct dr_with_seg_len): Remove class\n+\tmember OFFSET.\n+\t* tree-vect-data-refs.c (operator ==): Handle DR_OFFSET directly,\n+\trather than OFFSET.\n+\t(comp_dr_with_seg_len_pair): Ditto.\n+\t(vect_prune_runtime_alias_test_list): Ditto.  Also Canonicalize\n+\tstruct dr_with_seg_len_pair against DR_OFFSET.\n+\t* tree-vect-loop-manip.c (vect_create_cond_for_alias_checks): Handle\n+\tDR_OFFSET directly.\n+\n 2016-06-17  Szabolcs Nagy  <szabolcs.nagy@arm.com>\n \n \t* config/aarch64/geniterators.sh: Handle parenthesised conditions."}, {"sha": "936e17a0125612d83d1a5060746ba50d4931e296", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97816be433afedd0a407672b6f2fad23d179447b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97816be433afedd0a407672b6f2fad23d179447b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=97816be433afedd0a407672b6f2fad23d179447b", "patch": "@@ -1,3 +1,7 @@\n+2016-06-17  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* gcc.dg/vect/vect-alias-check-1.c: New test.\n+\n 2016-06-16  Senthil Kumar Selvaraj  <senthil_kumar.selvaraj@atmel.com>\n \n \t* gcc.target/avr/pr71151-1.c: New test."}, {"sha": "c2b1c7730470ebc5983f78bfbae17c95cb035aaa", "filename": "gcc/testsuite/gcc.dg/vect/vect-alias-check-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97816be433afedd0a407672b6f2fad23d179447b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97816be433afedd0a407672b6f2fad23d179447b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-1.c?ref=97816be433afedd0a407672b6f2fad23d179447b", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-additional-options \"-Ofast\" } */\n+\n+int b, c = 1;\n+int a[6][5] = { {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 1, 0, 0, 0} };\n+\n+void\n+fn1 ()\n+{\n+  int d;\n+  for (b = 0; b < 5; b++)\n+    for (d = 4; d; d--)\n+      a[c + 1][b] = a[d + 1][d];\n+}\n+\n+/* { dg-final { scan-tree-dump \"improved number of alias checks from \\[0-9\\]* to 1\" \"vect\" } } */"}, {"sha": "5ac34bebb074d5f4f71aa4e189db40c48f013580", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 35, "deletions": 28, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97816be433afedd0a407672b6f2fad23d179447b/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97816be433afedd0a407672b6f2fad23d179447b/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=97816be433afedd0a407672b6f2fad23d179447b", "patch": "@@ -2851,7 +2851,8 @@ operator == (const dr_with_seg_len& d1,\n {\n   return operand_equal_p (DR_BASE_ADDRESS (d1.dr),\n \t\t\t  DR_BASE_ADDRESS (d2.dr), 0)\n-\t   && compare_tree (d1.offset, d2.offset) == 0\n+\t   && compare_tree (DR_OFFSET (d1.dr), DR_OFFSET (d2.dr)) == 0\n+\t   && compare_tree (DR_INIT (d1.dr), DR_INIT (d2.dr)) == 0\n \t   && compare_tree (d1.seg_len, d2.seg_len) == 0;\n }\n \n@@ -2861,35 +2862,36 @@ operator == (const dr_with_seg_len& d1,\n    so that we can combine aliasing checks in one scan.  */\n \n static int\n-comp_dr_with_seg_len_pair (const void *p1_, const void *p2_)\n+comp_dr_with_seg_len_pair (const void *pa_, const void *pb_)\n {\n-  const dr_with_seg_len_pair_t* p1 = (const dr_with_seg_len_pair_t *) p1_;\n-  const dr_with_seg_len_pair_t* p2 = (const dr_with_seg_len_pair_t *) p2_;\n-\n-  const dr_with_seg_len &p11 = p1->first,\n-\t\t\t&p12 = p1->second,\n-\t\t\t&p21 = p2->first,\n-\t\t\t&p22 = p2->second;\n+  const dr_with_seg_len_pair_t* pa = (const dr_with_seg_len_pair_t *) pa_;\n+  const dr_with_seg_len_pair_t* pb = (const dr_with_seg_len_pair_t *) pb_;\n+  const dr_with_seg_len &a1 = pa->first, &a2 = pa->second;\n+  const dr_with_seg_len &b1 = pb->first, &b2 = pb->second;\n \n   /* For DR pairs (a, b) and (c, d), we only consider to merge the alias checks\n      if a and c have the same basic address snd step, and b and d have the same\n      address and step.  Therefore, if any a&c or b&d don't have the same address\n      and step, we don't care the order of those two pairs after sorting.  */\n   int comp_res;\n \n-  if ((comp_res = compare_tree (DR_BASE_ADDRESS (p11.dr),\n-\t\t\t\tDR_BASE_ADDRESS (p21.dr))) != 0)\n+  if ((comp_res = compare_tree (DR_BASE_ADDRESS (a1.dr),\n+\t\t\t\tDR_BASE_ADDRESS (b1.dr))) != 0)\n+    return comp_res;\n+  if ((comp_res = compare_tree (DR_BASE_ADDRESS (a2.dr),\n+\t\t\t\tDR_BASE_ADDRESS (b2.dr))) != 0)\n     return comp_res;\n-  if ((comp_res = compare_tree (DR_BASE_ADDRESS (p12.dr),\n-\t\t\t\tDR_BASE_ADDRESS (p22.dr))) != 0)\n+  if ((comp_res = compare_tree (DR_STEP (a1.dr), DR_STEP (b1.dr))) != 0)\n     return comp_res;\n-  if ((comp_res = compare_tree (DR_STEP (p11.dr), DR_STEP (p21.dr))) != 0)\n+  if ((comp_res = compare_tree (DR_STEP (a2.dr), DR_STEP (b2.dr))) != 0)\n     return comp_res;\n-  if ((comp_res = compare_tree (DR_STEP (p12.dr), DR_STEP (p22.dr))) != 0)\n+  if ((comp_res = compare_tree (DR_OFFSET (a1.dr), DR_OFFSET (b1.dr))) != 0)\n     return comp_res;\n-  if ((comp_res = compare_tree (p11.offset, p21.offset)) != 0)\n+  if ((comp_res = compare_tree (DR_INIT (a1.dr), DR_INIT (b1.dr))) != 0)\n     return comp_res;\n-  if ((comp_res = compare_tree (p12.offset, p22.offset)) != 0)\n+  if ((comp_res = compare_tree (DR_OFFSET (a2.dr), DR_OFFSET (b2.dr))) != 0)\n+    return comp_res;\n+  if ((comp_res = compare_tree (DR_INIT (a2.dr), DR_INIT (b2.dr))) != 0)\n     return comp_res;\n \n   return 0;\n@@ -2992,6 +2994,7 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n   /* First, we collect all data ref pairs for aliasing checks.  */\n   FOR_EACH_VEC_ELT (may_alias_ddrs, i, ddr)\n     {\n+      int comp_res;\n       struct data_reference *dr_a, *dr_b;\n       gimple *dr_group_first_a, *dr_group_first_b;\n       tree segment_length_a, segment_length_b;\n@@ -3026,7 +3029,11 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \t  (dr_with_seg_len (dr_a, segment_length_a),\n \t   dr_with_seg_len (dr_b, segment_length_b));\n \n-      if (compare_tree (DR_BASE_ADDRESS (dr_a), DR_BASE_ADDRESS (dr_b)) > 0)\n+      /* Canonicalize pairs by sorting the two DR members.  */\n+      comp_res = compare_tree (DR_BASE_ADDRESS (dr_a), DR_BASE_ADDRESS (dr_b));\n+      if (comp_res > 0\n+          || (comp_res == 0\n+              && compare_tree (DR_OFFSET (dr_a), DR_OFFSET (dr_b)) > 0))\n \tstd::swap (dr_with_seg_len_pair.first, dr_with_seg_len_pair.second);\n \n       comp_alias_ddrs.safe_push (dr_with_seg_len_pair);\n@@ -3082,21 +3089,21 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \t    }\n \n \t  if (!operand_equal_p (DR_BASE_ADDRESS (dr_a1->dr),\n-\t\t\t\tDR_BASE_ADDRESS (dr_a2->dr),\n-\t\t\t\t0)\n-\t      || !tree_fits_shwi_p (dr_a1->offset)\n-\t      || !tree_fits_shwi_p (dr_a2->offset))\n+\t\t\t\tDR_BASE_ADDRESS (dr_a2->dr), 0)\n+\t      || !operand_equal_p (DR_OFFSET (dr_a1->dr),\n+\t\t\t\t   DR_OFFSET (dr_a2->dr), 0)\n+\t      || !tree_fits_shwi_p (DR_INIT (dr_a1->dr))\n+\t      || !tree_fits_shwi_p (DR_INIT (dr_a2->dr)))\n \t    continue;\n \n \t  /* Make sure dr_a1 starts left of dr_a2.  */\n-\t  if (tree_int_cst_lt (dr_a2->offset, dr_a1->offset))\n+\t  if (tree_int_cst_lt (DR_INIT (dr_a2->dr), DR_INIT (dr_a1->dr)))\n \t    std::swap (*dr_a1, *dr_a2);\n \n-\t  unsigned HOST_WIDE_INT diff\n-\t    = tree_to_shwi (dr_a2->offset) - tree_to_shwi (dr_a1->offset);\n-\n-\n \t  bool do_remove = false;\n+\t  unsigned HOST_WIDE_INT diff\n+\t    = (tree_to_shwi (DR_INIT (dr_a2->dr))\n+               - tree_to_shwi (DR_INIT (dr_a1->dr)));\n \n \t  /* If the left segment does not extend beyond the start of the\n \t     right segment the new segment length is that of the right\n@@ -3124,7 +3131,7 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \n \t     DIFF - SEGMENT_LENGTH_A < SEGMENT_LENGTH_B\n \n-\t     where DIFF = DR_A2->OFFSET - DR_A1->OFFSET.  However,\n+\t     where DIFF = DR_A2_INIT - DR_A1_INIT.  However,\n \t     SEGMENT_LENGTH_A or SEGMENT_LENGTH_B may not be constant so we\n \t     have to make a best estimation.  We can get the minimum value\n \t     of SEGMENT_LENGTH_B as a constant, represented by MIN_SEG_LEN_B,"}, {"sha": "93b29b72fd5fc373b440b7d79ace73033843062f", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97816be433afedd0a407672b6f2fad23d179447b/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97816be433afedd0a407672b6f2fad23d179447b/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=97816be433afedd0a407672b6f2fad23d179447b", "patch": "@@ -2238,11 +2238,16 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo, tree * cond_expr)\n       const dr_with_seg_len& dr_b = comp_alias_ddrs[i].second;\n       tree segment_length_a = dr_a.seg_len;\n       tree segment_length_b = dr_b.seg_len;\n-\n-      tree addr_base_a\n-\t= fold_build_pointer_plus (DR_BASE_ADDRESS (dr_a.dr), dr_a.offset);\n-      tree addr_base_b\n-\t= fold_build_pointer_plus (DR_BASE_ADDRESS (dr_b.dr), dr_b.offset);\n+      tree addr_base_a = DR_BASE_ADDRESS (dr_a.dr);\n+      tree addr_base_b = DR_BASE_ADDRESS (dr_b.dr);\n+      tree offset_a = DR_OFFSET (dr_a.dr), offset_b = DR_OFFSET (dr_b.dr);\n+\n+      offset_a = fold_build2 (PLUS_EXPR, TREE_TYPE (offset_a),\n+\t\t\t      offset_a, DR_INIT (dr_a.dr));\n+      offset_b = fold_build2 (PLUS_EXPR, TREE_TYPE (offset_b),\n+\t\t\t      offset_b, DR_INIT (dr_b.dr));\n+      addr_base_a = fold_build_pointer_plus (addr_base_a, offset_a);\n+      addr_base_b = fold_build_pointer_plus (addr_base_b, offset_b);\n \n       if (dump_enabled_p ())\n \t{"}, {"sha": "f15672ffa325891bb1651baaa6abc3e46e085d5d", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97816be433afedd0a407672b6f2fad23d179447b/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97816be433afedd0a407672b6f2fad23d179447b/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=97816be433afedd0a407672b6f2fad23d179447b", "patch": "@@ -146,19 +146,15 @@ typedef struct _slp_instance {\n \n \n /* This struct is used to store the information of a data reference,\n-   including the data ref itself, the access offset (calculated by summing its\n-   offset and init) and the segment length for aliasing checks.\n-   This is used to merge alias checks.  */\n+   including the data ref itself and the segment length for aliasing\n+   checks.  This is used to merge alias checks.  */\n \n struct dr_with_seg_len\n {\n   dr_with_seg_len (data_reference_p d, tree len)\n-    : dr (d),\n-      offset (size_binop (PLUS_EXPR, DR_OFFSET (d), DR_INIT (d))),\n-      seg_len (len) {}\n+    : dr (d), seg_len (len) {}\n \n   data_reference_p dr;\n-  tree offset;\n   tree seg_len;\n };\n "}]}