{"sha": "fdcddcb1dfa6263074cf7a949f2f670719323fd9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRjZGRjYjFkZmE2MjYzMDc0Y2Y3YTk0OWYyZjY3MDcxOTMyM2ZkOQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-04-07T08:01:36Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-04-07T08:01:36Z"}, "message": "Initial revision\n\nFrom-SVN: r26251", "tree": {"sha": "208103f69fd87ffe57ab80c1fde690e90e378f46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/208103f69fd87ffe57ab80c1fde690e90e378f46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fdcddcb1dfa6263074cf7a949f2f670719323fd9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdcddcb1dfa6263074cf7a949f2f670719323fd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdcddcb1dfa6263074cf7a949f2f670719323fd9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdcddcb1dfa6263074cf7a949f2f670719323fd9/comments", "author": null, "committer": null, "parents": [{"sha": "21a6f56df7b24544f14eb428244d89112f4caf38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21a6f56df7b24544f14eb428244d89112f4caf38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21a6f56df7b24544f14eb428244d89112f4caf38"}], "stats": {"total": 698, "additions": 698, "deletions": 0}, "files": [{"sha": "09c8ca8196c865c4ee975329c045ad7ea49956fb", "filename": "boehm-gc/gc.h", "status": "added", "additions": 698, "deletions": 0, "changes": 698, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdcddcb1dfa6263074cf7a949f2f670719323fd9/boehm-gc%2Fgc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdcddcb1dfa6263074cf7a949f2f670719323fd9/boehm-gc%2Fgc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc.h?ref=fdcddcb1dfa6263074cf7a949f2f670719323fd9", "patch": "@@ -0,0 +1,698 @@\n+/* \n+ * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n+ * Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved.\n+ * Copyright 1996 by Silicon Graphics.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+\n+/*\n+ * Note that this defines a large number of tuning hooks, which can\n+ * safely be ignored in nearly all cases.  For normal use it suffices\n+ * to call only GC_MALLOC and perhaps GC_REALLOC.\n+ * For better performance, also look at GC_MALLOC_ATOMIC, and\n+ * GC_enable_incremental.  If you need an action to be performed\n+ * immediately before an object is collected, look at GC_register_finalizer.\n+ * If you are using Solaris threads, look at the end of this file.\n+ * Everything else is best ignored unless you encounter performance\n+ * problems.\n+ */\n+ \n+#ifndef _GC_H\n+\n+# define _GC_H\n+# define __GC\n+# include <stddef.h>\n+\n+#if defined(__CYGWIN32__) && defined(GC_USE_DLL)\n+#include \"libgc_globals.h\"\n+#endif\n+\n+#if defined(_MSC_VER) && defined(_DLL)\n+#ifdef GC_BUILD\n+#define GC_API __declspec(dllexport)\n+#else\n+#define GC_API __declspec(dllimport)\n+#endif\n+#endif\n+\n+#ifndef GC_API\n+#define GC_API extern\n+#endif\n+\n+# if defined(__STDC__) || defined(__cplusplus)\n+#   define GC_PROTO(args) args\n+    typedef void * GC_PTR;\n+# else\n+#   define GC_PROTO(args) ()\n+    typedef char * GC_PTR;\n+#  endif\n+\n+# ifdef __cplusplus\n+    extern \"C\" {\n+# endif\n+\n+\n+/* Define word and signed_word to be unsigned and signed types of the \t*/\n+/* size as char * or void *.  There seems to be no way to do this\t*/\n+/* even semi-portably.  The following is probably no better/worse \t*/\n+/* than almost anything else.\t\t\t\t\t\t*/\n+/* The ANSI standard suggests that size_t and ptr_diff_t might be \t*/\n+/* better choices.  But those appear to have incorrect definitions\t*/\n+/* on may systems.  Notably \"typedef int size_t\" seems to be both\t*/\n+/* frequent and WRONG.\t\t\t\t\t\t\t*/\n+typedef unsigned long GC_word;\n+typedef long GC_signed_word;\n+\n+/* Public read-only variables */\n+\n+GC_API GC_word GC_gc_no;/* Counter incremented per collection.  \t*/\n+\t\t\t/* Includes empty GCs at startup.\t\t*/\n+\t\t\t\n+\n+/* Public R/W variables */\n+\n+GC_API GC_PTR (*GC_oom_fn) GC_PROTO((size_t bytes_requested));\n+\t\t\t/* When there is insufficient memory to satisfy */\n+\t\t\t/* an allocation request, we return\t\t*/\n+\t\t\t/* (*GC_oom_fn)().  By default this just\t*/\n+\t\t\t/* returns 0.\t\t\t\t\t*/\n+\t\t\t/* If it returns, it must return 0 or a valid\t*/\n+\t\t\t/* pointer to a previously allocated heap \t*/\n+\t\t\t/* object.\t\t\t\t\t*/\n+\n+GC_API int GC_quiet;\t/* Disable statistics output.  Only matters if\t*/\n+\t\t\t/* collector has been compiled with statistics\t*/\n+\t\t\t/* enabled.  This involves a performance cost,\t*/\n+\t\t\t/* and is thus not the default.\t\t\t*/\n+\n+GC_API int GC_dont_gc;\t/* Dont collect unless explicitly requested, e.g. */\n+\t\t\t/* because it's not safe.\t\t\t  */\n+\n+GC_API int GC_dont_expand;\n+\t\t\t/* Dont expand heap unless explicitly requested */\n+\t\t\t/* or forced to.\t\t\t\t*/\n+\n+GC_API int GC_full_freq;    /* Number of partial collections between\t*/\n+\t\t\t    /* full collections.  Matters only if\t*/\n+\t\t\t    /* GC_incremental is set.\t\t\t*/\n+\t\t\t\n+GC_API GC_word GC_non_gc_bytes;\n+\t\t\t/* Bytes not considered candidates for collection. */\n+\t\t\t/* Used only to control scheduling of collections. */\n+\n+GC_API GC_word GC_free_space_divisor;\n+\t\t\t/* We try to make sure that we allocate at \t*/\n+\t\t\t/* least N/GC_free_space_divisor bytes between\t*/\n+\t\t\t/* collections, where N is the heap size plus\t*/\n+\t\t\t/* a rough estimate of the root set size.\t*/\n+\t\t\t/* Initially, GC_free_space_divisor = 4.\t*/\n+\t\t\t/* Increasing its value will use less space\t*/\n+\t\t\t/* but more collection time.  Decreasing it\t*/\n+\t\t\t/* will appreciably decrease collection time\t*/\n+\t\t\t/* at the expense of space.\t\t\t*/\n+\t\t\t/* GC_free_space_divisor = 1 will effectively\t*/\n+\t\t\t/* disable collections.\t\t\t\t*/\n+\n+GC_API GC_word GC_max_retries;\n+\t\t\t/* The maximum number of GCs attempted before\t*/\n+\t\t\t/* reporting out of memory after heap\t\t*/\n+\t\t\t/* expansion fails.  Initially 0.\t\t*/\n+\t\t\t\n+\t\t\t\n+/* Public procedures */\n+/*\n+ * general purpose allocation routines, with roughly malloc calling conv.\n+ * The atomic versions promise that no relevant pointers are contained\n+ * in the object.  The nonatomic versions guarantee that the new object\n+ * is cleared.  GC_malloc_stubborn promises that no changes to the object\n+ * will occur after GC_end_stubborn_change has been called on the\n+ * result of GC_malloc_stubborn. GC_malloc_uncollectable allocates an object\n+ * that is scanned for pointers to collectable objects, but is not itself\n+ * collectable.  GC_malloc_uncollectable and GC_free called on the resulting\n+ * object implicitly update GC_non_gc_bytes appropriately.\n+ */\n+GC_API GC_PTR GC_malloc GC_PROTO((size_t size_in_bytes));\n+GC_API GC_PTR GC_malloc_atomic GC_PROTO((size_t size_in_bytes));\n+GC_API GC_PTR GC_malloc_uncollectable GC_PROTO((size_t size_in_bytes));\n+GC_API GC_PTR GC_malloc_stubborn GC_PROTO((size_t size_in_bytes));\n+\n+/* The following is only defined if the library has been suitably\t*/\n+/* compiled:\t\t\t\t\t\t\t\t*/\n+GC_API GC_PTR GC_malloc_atomic_uncollectable GC_PROTO((size_t size_in_bytes));\n+\n+/* Explicitly deallocate an object.  Dangerous if used incorrectly.     */\n+/* Requires a pointer to the base of an object.\t\t\t\t*/\n+/* If the argument is stubborn, it should not be changeable when freed. */\n+/* An object should not be enable for finalization when it is \t\t*/\n+/* explicitly deallocated.\t\t\t\t\t\t*/\n+/* GC_free(0) is a no-op, as required by ANSI C for free.\t\t*/\n+GC_API void GC_free GC_PROTO((GC_PTR object_addr));\n+\n+/*\n+ * Stubborn objects may be changed only if the collector is explicitly informed.\n+ * The collector is implicitly informed of coming change when such\n+ * an object is first allocated.  The following routines inform the\n+ * collector that an object will no longer be changed, or that it will\n+ * once again be changed.  Only nonNIL pointer stores into the object\n+ * are considered to be changes.  The argument to GC_end_stubborn_change\n+ * must be exacly the value returned by GC_malloc_stubborn or passed to\n+ * GC_change_stubborn.  (In the second case it may be an interior pointer\n+ * within 512 bytes of the beginning of the objects.)\n+ * There is a performance penalty for allowing more than\n+ * one stubborn object to be changed at once, but it is acceptable to\n+ * do so.  The same applies to dropping stubborn objects that are still\n+ * changeable.\n+ */\n+GC_API void GC_change_stubborn GC_PROTO((GC_PTR));\n+GC_API void GC_end_stubborn_change GC_PROTO((GC_PTR));\n+\n+/* Return a pointer to the base (lowest address) of an object given\t*/\n+/* a pointer to a location within the object.\t\t\t\t*/\n+/* Return 0 if displaced_pointer doesn't point to within a valid\t*/\n+/* object.\t\t\t\t\t\t\t\t*/\n+GC_API GC_PTR GC_base GC_PROTO((GC_PTR displaced_pointer));\n+\n+/* Given a pointer to the base of an object, return its size in bytes.\t*/\n+/* The returned size may be slightly larger than what was originally\t*/\n+/* requested.\t\t\t\t\t\t\t\t*/\n+GC_API size_t GC_size GC_PROTO((GC_PTR object_addr));\n+\n+/* For compatibility with C library.  This is occasionally faster than\t*/\n+/* a malloc followed by a bcopy.  But if you rely on that, either here\t*/\n+/* or with the standard C library, your code is broken.  In my\t\t*/\n+/* opinion, it shouldn't have been invented, but now we're stuck. -HB\t*/\n+/* The resulting object has the same kind as the original.\t\t*/\n+/* If the argument is stubborn, the result will have changes enabled.\t*/\n+/* It is an error to have changes enabled for the original object.\t*/\n+/* Follows ANSI comventions for NULL old_object.\t\t\t*/\n+GC_API GC_PTR GC_realloc GC_PROTO((GC_PTR old_object,\n+\t\t\t\t   size_t new_size_in_bytes));\n+\t\t\t\t   \n+/* Explicitly increase the heap size.\t*/\n+/* Returns 0 on failure, 1 on success.  */\n+GC_API int GC_expand_hp GC_PROTO((size_t number_of_bytes));\n+\n+/* Limit the heap size to n bytes.  Useful when you're debugging, \t*/\n+/* especially on systems that don't handle running out of memory well.\t*/\n+/* n == 0 ==> unbounded.  This is the default.\t\t\t\t*/\n+GC_API void GC_set_max_heap_size GC_PROTO((GC_word n));\n+\n+/* Inform the collector that a certain section of statically allocated\t*/\n+/* memory contains no pointers to garbage collected memory.  Thus it \t*/\n+/* need not be scanned.  This is sometimes important if the application */\n+/* maps large read/write files into the address space, which could be\t*/\n+/* mistaken for dynamic library data segments on some systems.\t\t*/\n+GC_API void GC_exclude_static_roots GC_PROTO((GC_PTR start, GC_PTR finish));\n+\n+/* Clear the set of root segments.  Wizards only. */\n+GC_API void GC_clear_roots GC_PROTO((void));\n+\n+/* Add a root segment.  Wizards only. */\n+GC_API void GC_add_roots GC_PROTO((char * low_address,\n+\t\t\t\t   char * high_address_plus_1));\n+\n+/* Add a displacement to the set of those considered valid by the\t*/\n+/* collector.  GC_register_displacement(n) means that if p was returned */\n+/* by GC_malloc, then (char *)p + n will be considered to be a valid\t*/\n+/* pointer to n.  N must be small and less than the size of p.\t\t*/\n+/* (All pointers to the interior of objects from the stack are\t\t*/\n+/* considered valid in any case.  This applies to heap objects and\t*/\n+/* static data.)\t\t\t\t\t\t\t*/\n+/* Preferably, this should be called before any other GC procedures.\t*/\n+/* Calling it later adds to the probability of excess memory\t\t*/\n+/* retention.\t\t\t\t\t\t\t\t*/\n+/* This is a no-op if the collector was compiled with recognition of\t*/\n+/* arbitrary interior pointers enabled, which is now the default.\t*/\n+GC_API void GC_register_displacement GC_PROTO((GC_word n));\n+\n+/* The following version should be used if any debugging allocation is\t*/\n+/* being done.\t\t\t\t\t\t\t\t*/\n+GC_API void GC_debug_register_displacement GC_PROTO((GC_word n));\n+\n+/* Explicitly trigger a full, world-stop collection. \t*/\n+GC_API void GC_gcollect GC_PROTO((void));\n+\n+/* Trigger a full world-stopped collection.  Abort the collection if \t*/\n+/* and when stop_func returns a nonzero value.  Stop_func will be \t*/\n+/* called frequently, and should be reasonably fast.  This works even\t*/\n+/* if virtual dirty bits, and hence incremental collection is not \t*/\n+/* available for this architecture.  Collections can be aborted faster\t*/\n+/* than normal pause times for incremental collection.  However,\t*/\n+/* aborted collections do no useful work; the next collection needs\t*/\n+/* to start from the beginning.\t\t\t\t\t\t*/\n+typedef int (* GC_stop_func) GC_PROTO((void));\n+GC_API int GC_try_to_collect GC_PROTO((GC_stop_func stop_func));\n+\n+/* Return the number of bytes in the heap.  Excludes collector private\t*/\n+/* data structures.  Includes empty blocks and fragmentation loss.\t*/\n+/* Includes some pages that were allocated but never written.\t\t*/\n+GC_API size_t GC_get_heap_size GC_PROTO((void));\n+\n+/* Return the number of bytes allocated since the last collection.\t*/\n+GC_API size_t GC_get_bytes_since_gc GC_PROTO((void));\n+\n+/* Enable incremental/generational collection.\t*/\n+/* Not advisable unless dirty bits are \t\t*/\n+/* available or most heap objects are\t\t*/\n+/* pointerfree(atomic) or immutable.\t\t*/\n+/* Don't use in leak finding mode.\t\t*/\n+/* Ignored if GC_dont_gc is true.\t\t*/\n+GC_API void GC_enable_incremental GC_PROTO((void));\n+\n+/* Perform some garbage collection work, if appropriate.\t*/\n+/* Return 0 if there is no more work to be done.\t\t*/\n+/* Typically performs an amount of work corresponding roughly\t*/\n+/* to marking from one page.  May do more work if further\t*/\n+/* progress requires it, e.g. if incremental collection is\t*/\n+/* disabled.  It is reasonable to call this in a wait loop\t*/\n+/* until it returns 0.\t\t\t\t\t\t*/\n+GC_API int GC_collect_a_little GC_PROTO((void));\n+\n+/* Allocate an object of size lb bytes.  The client guarantees that\t*/\n+/* as long as the object is live, it will be referenced by a pointer\t*/\n+/* that points to somewhere within the first 256 bytes of the object.\t*/\n+/* (This should normally be declared volatile to prevent the compiler\t*/\n+/* from invalidating this assertion.)  This routine is only useful\t*/\n+/* if a large array is being allocated.  It reduces the chance of \t*/\n+/* accidentally retaining such an array as a result of scanning an\t*/\n+/* integer that happens to be an address inside the array.  (Actually,\t*/\n+/* it reduces the chance of the allocator not finding space for such\t*/\n+/* an array, since it will try hard to avoid introducing such a false\t*/\n+/* reference.)  On a SunOS 4.X or MS Windows system this is recommended */\n+/* for arrays likely to be larger than 100K or so.  For other systems,\t*/\n+/* or if the collector is not configured to recognize all interior\t*/\n+/* pointers, the threshold is normally much higher.\t\t\t*/\n+GC_API GC_PTR GC_malloc_ignore_off_page GC_PROTO((size_t lb));\n+GC_API GC_PTR GC_malloc_atomic_ignore_off_page GC_PROTO((size_t lb));\n+\n+#if defined(__sgi) && !defined(__GNUC__) && _COMPILER_VERSION >= 720\n+#   define GC_ADD_CALLER\n+#   define GC_RETURN_ADDR (GC_word)__return_address\n+#endif\n+\n+#ifdef GC_ADD_CALLER\n+#  define GC_EXTRAS GC_RETURN_ADDR, __FILE__, __LINE__\n+#  define GC_EXTRA_PARAMS GC_word ra, char * descr_string, int descr_int\n+#else\n+#  define GC_EXTRAS __FILE__, __LINE__\n+#  define GC_EXTRA_PARAMS char * descr_string, int descr_int\n+#endif\n+\n+/* Debugging (annotated) allocation.  GC_gcollect will check \t\t*/\n+/* objects allocated in this way for overwrites, etc.\t\t\t*/\n+GC_API GC_PTR GC_debug_malloc\n+\tGC_PROTO((size_t size_in_bytes, GC_EXTRA_PARAMS));\n+GC_API GC_PTR GC_debug_malloc_atomic\n+\tGC_PROTO((size_t size_in_bytes, GC_EXTRA_PARAMS));\n+GC_API GC_PTR GC_debug_malloc_uncollectable\n+\tGC_PROTO((size_t size_in_bytes, GC_EXTRA_PARAMS));\n+GC_API GC_PTR GC_debug_malloc_stubborn\n+\tGC_PROTO((size_t size_in_bytes, GC_EXTRA_PARAMS));\n+GC_API void GC_debug_free GC_PROTO((GC_PTR object_addr));\n+GC_API GC_PTR GC_debug_realloc\n+\tGC_PROTO((GC_PTR old_object, size_t new_size_in_bytes,\n+  \t\t  GC_EXTRA_PARAMS));\n+  \t\t\t \t \n+GC_API void GC_debug_change_stubborn GC_PROTO((GC_PTR));\n+GC_API void GC_debug_end_stubborn_change GC_PROTO((GC_PTR));\n+# ifdef GC_DEBUG\n+#   define GC_MALLOC(sz) GC_debug_malloc(sz, GC_EXTRAS)\n+#   define GC_MALLOC_ATOMIC(sz) GC_debug_malloc_atomic(sz, GC_EXTRAS)\n+#   define GC_MALLOC_UNCOLLECTABLE(sz) GC_debug_malloc_uncollectable(sz, \\\n+\t\t\t\t\t\t\tGC_EXTRAS)\n+#   define GC_REALLOC(old, sz) GC_debug_realloc(old, sz, GC_EXTRAS)\n+#   define GC_FREE(p) GC_debug_free(p)\n+#   define GC_REGISTER_FINALIZER(p, f, d, of, od) \\\n+\tGC_debug_register_finalizer(p, f, d, of, od)\n+#   define GC_REGISTER_FINALIZER_IGNORE_SELF(p, f, d, of, od) \\\n+\tGC_debug_register_finalizer_ignore_self(p, f, d, of, od)\n+#   define GC_MALLOC_STUBBORN(sz) GC_debug_malloc_stubborn(sz, GC_EXTRAS);\n+#   define GC_CHANGE_STUBBORN(p) GC_debug_change_stubborn(p)\n+#   define GC_END_STUBBORN_CHANGE(p) GC_debug_end_stubborn_change(p)\n+#   define GC_GENERAL_REGISTER_DISAPPEARING_LINK(link, obj) \\\n+\tGC_general_register_disappearing_link(link, GC_base(obj))\n+#   define GC_REGISTER_DISPLACEMENT(n) GC_debug_register_displacement(n)\n+# else\n+#   define GC_MALLOC(sz) GC_malloc(sz)\n+#   define GC_MALLOC_ATOMIC(sz) GC_malloc_atomic(sz)\n+#   define GC_MALLOC_UNCOLLECTABLE(sz) GC_malloc_uncollectable(sz)\n+#   define GC_REALLOC(old, sz) GC_realloc(old, sz)\n+#   define GC_FREE(p) GC_free(p)\n+#   define GC_REGISTER_FINALIZER(p, f, d, of, od) \\\n+\tGC_register_finalizer(p, f, d, of, od)\n+#   define GC_REGISTER_FINALIZER_IGNORE_SELF(p, f, d, of, od) \\\n+\tGC_register_finalizer_ignore_self(p, f, d, of, od)\n+#   define GC_MALLOC_STUBBORN(sz) GC_malloc_stubborn(sz)\n+#   define GC_CHANGE_STUBBORN(p) GC_change_stubborn(p)\n+#   define GC_END_STUBBORN_CHANGE(p) GC_end_stubborn_change(p)\n+#   define GC_GENERAL_REGISTER_DISAPPEARING_LINK(link, obj) \\\n+\tGC_general_register_disappearing_link(link, obj)\n+#   define GC_REGISTER_DISPLACEMENT(n) GC_register_displacement(n)\n+# endif\n+/* The following are included because they are often convenient, and\t*/\n+/* reduce the chance for a misspecifed size argument.  But calls may\t*/\n+/* expand to something syntactically incorrect if t is a complicated\t*/\n+/* type expression.  \t\t\t\t\t\t\t*/\n+# define GC_NEW(t) (t *)GC_MALLOC(sizeof (t))\n+# define GC_NEW_ATOMIC(t) (t *)GC_MALLOC_ATOMIC(sizeof (t))\n+# define GC_NEW_STUBBORN(t) (t *)GC_MALLOC_STUBBORN(sizeof (t))\n+# define GC_NEW_UNCOLLECTABLE(t) (t *)GC_MALLOC_UNCOLLECTABLE(sizeof (t))\n+\n+/* Finalization.  Some of these primitives are grossly unsafe.\t\t*/\n+/* The idea is to make them both cheap, and sufficient to build\t\t*/\n+/* a safer layer, closer to PCedar finalization.\t\t\t*/\n+/* The interface represents my conclusions from a long discussion\t*/\n+/* with Alan Demers, Dan Greene, Carl Hauser, Barry Hayes, \t\t*/\n+/* Christian Jacobi, and Russ Atkinson.  It's not perfect, and\t\t*/\n+/* probably nobody else agrees with it.\t    Hans-J. Boehm  3/13/92\t*/\n+typedef void (*GC_finalization_proc)\n+  \tGC_PROTO((GC_PTR obj, GC_PTR client_data));\n+\n+GC_API void GC_register_finalizer\n+    \tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n+\t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n+GC_API void GC_debug_register_finalizer\n+    \tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n+\t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n+\t/* When obj is no longer accessible, invoke\t\t*/\n+\t/* (*fn)(obj, cd).  If a and b are inaccessible, and\t*/\n+\t/* a points to b (after disappearing links have been\t*/\n+\t/* made to disappear), then only a will be\t\t*/\n+\t/* finalized.  (If this does not create any new\t\t*/\n+\t/* pointers to b, then b will be finalized after the\t*/\n+\t/* next collection.)  Any finalizable object that\t*/\n+\t/* is reachable from itself by following one or more\t*/\n+\t/* pointers will not be finalized (or collected).\t*/\n+\t/* Thus cycles involving finalizable objects should\t*/\n+\t/* be avoided, or broken by disappearing links.\t\t*/\n+\t/* All but the last finalizer registered for an object  */\n+\t/* is ignored.\t\t\t\t\t\t*/\n+\t/* Finalization may be removed by passing 0 as fn.\t*/\n+\t/* Finalizers are implicitly unregistered just before   */\n+\t/* they are invoked.\t\t\t\t\t*/\n+\t/* The old finalizer and client data are stored in\t*/\n+\t/* *ofn and *ocd.\t\t\t\t\t*/ \n+\t/* Fn is never invoked on an accessible object,\t\t*/\n+\t/* provided hidden pointers are converted to real \t*/\n+\t/* pointers only if the allocation lock is held, and\t*/\n+\t/* such conversions are not performed by finalization\t*/\n+\t/* routines.\t\t\t\t\t\t*/\n+\t/* If GC_register_finalizer is aborted as a result of\t*/\n+\t/* a signal, the object may be left with no\t\t*/\n+\t/* finalization, even if neither the old nor new\t*/\n+\t/* finalizer were NULL.\t\t\t\t\t*/\n+\t/* Obj should be the nonNULL starting address of an \t*/\n+\t/* object allocated by GC_malloc or friends.\t\t*/\n+\t/* Note that any garbage collectable object referenced\t*/\n+\t/* by cd will be considered accessible until the\t*/\n+\t/* finalizer is invoked.\t\t\t\t*/\n+\n+/* Another versions of the above follow.  It ignores\t\t*/\n+/* self-cycles, i.e. pointers from a finalizable object to\t*/\n+/* itself.  There is a stylistic argument that this is wrong,\t*/\n+/* but it's unavoidable for C++, since the compiler may\t\t*/\n+/* silently introduce these.  It's also benign in that specific\t*/\n+/* case.\t\t\t\t\t\t\t*/\n+GC_API void GC_register_finalizer_ignore_self\n+\tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n+\t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n+GC_API void GC_debug_register_finalizer_ignore_self\n+\tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n+\t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n+\n+/* The following routine may be used to break cycles between\t*/\n+/* finalizable objects, thus causing cyclic finalizable\t\t*/\n+/* objects to be finalized in the correct order.  Standard\t*/\n+/* use involves calling GC_register_disappearing_link(&p),\t*/\n+/* where p is a pointer that is not followed by finalization\t*/\n+/* code, and should not be considered in determining \t\t*/\n+/* finalization order.\t\t\t\t\t\t*/\n+GC_API int GC_register_disappearing_link GC_PROTO((GC_PTR * /* link */));\n+\t/* Link should point to a field of a heap allocated \t*/\n+\t/* object obj.  *link will be cleared when obj is\t*/\n+\t/* found to be inaccessible.  This happens BEFORE any\t*/\n+\t/* finalization code is invoked, and BEFORE any\t\t*/\n+\t/* decisions about finalization order are made.\t\t*/\n+\t/* This is useful in telling the finalizer that \t*/\n+\t/* some pointers are not essential for proper\t\t*/\n+\t/* finalization.  This may avoid finalization cycles.\t*/\n+\t/* Note that obj may be resurrected by another\t\t*/\n+\t/* finalizer, and thus the clearing of *link may\t*/\n+\t/* be visible to non-finalization code.  \t\t*/\n+\t/* There's an argument that an arbitrary action should  */\n+\t/* be allowed here, instead of just clearing a pointer. */\n+\t/* But this causes problems if that action alters, or \t*/\n+\t/* examines connectivity.\t\t\t\t*/\n+\t/* Returns 1 if link was already registered, 0\t\t*/\n+\t/* otherwise.\t\t\t\t\t\t*/\n+\t/* Only exists for backward compatibility.  See below:\t*/\n+\t\n+GC_API int GC_general_register_disappearing_link\n+\tGC_PROTO((GC_PTR * /* link */, GC_PTR obj));\n+\t/* A slight generalization of the above. *link is\t*/\n+\t/* cleared when obj first becomes inaccessible.  This\t*/\n+\t/* can be used to implement weak pointers easily and\t*/\n+\t/* safely. Typically link will point to a location\t*/\n+\t/* holding a disguised pointer to obj.  (A pointer \t*/\n+\t/* inside an \"atomic\" object is effectively  \t\t*/\n+\t/* disguised.)   In this way soft\t\t\t*/\n+\t/* pointers are broken before any object\t\t*/\n+\t/* reachable from them are finalized.  Each link\t*/\n+\t/* May be registered only once, i.e. with one obj\t*/\n+\t/* value.  This was added after a long email discussion */\n+\t/* with John Ellis.\t\t\t\t\t*/\n+\t/* Obj must be a pointer to the first word of an object */\n+\t/* we allocated.  It is unsafe to explicitly deallocate */\n+\t/* the object containing link.  Explicitly deallocating */\n+\t/* obj may or may not cause link to eventually be\t*/\n+\t/* cleared.\t\t\t\t\t\t*/\n+GC_API int GC_unregister_disappearing_link GC_PROTO((GC_PTR * /* link */));\n+\t/* Returns 0 if link was not actually registered.\t*/\n+\t/* Undoes a registration by either of the above two\t*/\n+\t/* routines.\t\t\t\t\t\t*/\n+\n+/* Auxiliary fns to make finalization work correctly with displaced\t*/\n+/* pointers introduced by the debugging allocators.\t\t\t*/\n+GC_API GC_PTR GC_make_closure GC_PROTO((GC_finalization_proc fn, GC_PTR data));\n+GC_API void GC_debug_invoke_finalizer GC_PROTO((GC_PTR obj, GC_PTR data));\n+\n+GC_API int GC_invoke_finalizers GC_PROTO((void));\n+\t/* Run finalizers for all objects that are ready to\t*/\n+\t/* be finalized.  Return the number of finalizers\t*/\n+\t/* that were run.  Normally this is also called\t\t*/\n+\t/* implicitly during some allocations.\tIf\t\t*/\n+\t/* FINALIZE_ON_DEMAND is defined, it must be called\t*/\n+\t/* explicitly.\t\t\t\t\t\t*/\n+\n+/* GC_set_warn_proc can be used to redirect or filter warning messages.\t*/\n+/* p may not be a NULL pointer.\t\t\t\t\t\t*/\n+typedef void (*GC_warn_proc) GC_PROTO((char *msg, GC_word arg));\n+GC_API GC_warn_proc GC_set_warn_proc GC_PROTO((GC_warn_proc p));\n+    /* Returns old warning procedure.\t*/\n+\t\n+/* The following is intended to be used by a higher level\t*/\n+/* (e.g. cedar-like) finalization facility.  It is expected\t*/\n+/* that finalization code will arrange for hidden pointers to\t*/\n+/* disappear.  Otherwise objects can be accessed after they\t*/\n+/* have been collected.\t\t\t\t\t\t*/\n+/* Note that putting pointers in atomic objects or in \t\t*/\n+/* nonpointer slots of \"typed\" objects is equivalent to \t*/\n+/* disguising them in this way, and may have other advantages.\t*/\n+# if defined(I_HIDE_POINTERS) || defined(GC_I_HIDE_POINTERS)\n+    typedef GC_word GC_hidden_pointer;\n+#   define HIDE_POINTER(p) (~(GC_hidden_pointer)(p))\n+#   define REVEAL_POINTER(p) ((GC_PTR)(HIDE_POINTER(p)))\n+    /* Converting a hidden pointer to a real pointer requires verifying\t*/\n+    /* that the object still exists.  This involves acquiring the  \t*/\n+    /* allocator lock to avoid a race with the collector.\t\t*/\n+# endif /* I_HIDE_POINTERS */\n+\n+typedef GC_PTR (*GC_fn_type) GC_PROTO((GC_PTR client_data));\n+GC_API GC_PTR GC_call_with_alloc_lock\n+        \tGC_PROTO((GC_fn_type fn, GC_PTR client_data));\n+\n+/* Check that p and q point to the same object.  \t\t*/\n+/* Fail conspicuously if they don't.\t\t\t\t*/\n+/* Returns the first argument.  \t\t\t\t*/\n+/* Succeeds if neither p nor q points to the heap.\t\t*/\n+/* May succeed if both p and q point to between heap objects.\t*/\n+GC_API GC_PTR GC_same_obj GC_PROTO((GC_PTR p, GC_PTR q));\n+\n+/* Checked pointer pre- and post- increment operations.  Note that\t*/\n+/* the second argument is in units of bytes, not multiples of the\t*/\n+/* object size.  This should either be invoked from a macro, or the\t*/\n+/* call should be automatically generated.\t\t\t\t*/\n+GC_API GC_PTR GC_pre_incr GC_PROTO((GC_PTR *p, size_t how_much));\n+GC_API GC_PTR GC_post_incr GC_PROTO((GC_PTR *p, size_t how_much));\n+\n+/* Check that p is visible\t\t\t\t\t\t*/\n+/* to the collector as a possibly pointer containing location.\t\t*/\n+/* If it isn't fail conspicuously.\t\t\t\t\t*/\n+/* Returns the argument in all cases.  May erroneously succeed\t\t*/\n+/* in hard cases.  (This is intended for debugging use with\t\t*/\n+/* untyped allocations.  The idea is that it should be possible, though\t*/\n+/* slow, to add such a call to all indirect pointer stores.)\t\t*/\n+/* Currently useless for multithreaded worlds.\t\t\t\t*/\n+GC_API GC_PTR GC_is_visible GC_PROTO((GC_PTR p));\n+\n+/* Check that if p is a pointer to a heap page, then it points to\t*/\n+/* a valid displacement within a heap object.\t\t\t\t*/\n+/* Fail conspicuously if this property does not hold.\t\t\t*/\n+/* Uninteresting with ALL_INTERIOR_POINTERS.\t\t\t\t*/\n+/* Always returns its argument.\t\t\t\t\t\t*/\n+GC_API GC_PTR GC_is_valid_displacement GC_PROTO((GC_PTR\tp));\n+\n+/* Safer, but slow, pointer addition.  Probably useful mainly with \t*/\n+/* a preprocessor.  Useful only for heap pointers.\t\t\t*/\n+#ifdef GC_DEBUG\n+#   define GC_PTR_ADD3(x, n, type_of_result) \\\n+\t((type_of_result)GC_same_obj((x)+(n), (x)))\n+#   define GC_PRE_INCR3(x, n, type_of_result) \\\n+\t((type_of_result)GC_pre_incr(&(x), (n)*sizeof(*x))\n+#   define GC_POST_INCR2(x, type_of_result) \\\n+\t((type_of_result)GC_post_incr(&(x), sizeof(*x))\n+#   ifdef __GNUC__\n+#       define GC_PTR_ADD(x, n) \\\n+\t    GC_PTR_ADD3(x, n, typeof(x))\n+#   define GC_PRE_INCR(x, n) \\\n+\t    GC_PRE_INCR3(x, n, typeof(x))\n+#   define GC_POST_INCR(x, n) \\\n+\t    GC_POST_INCR3(x, typeof(x))\n+#   else\n+\t/* We can't do this right without typeof, which ANSI\t*/\n+\t/* decided was not sufficiently useful.  Repeatedly\t*/\n+\t/* mentioning the arguments seems too dangerous to be\t*/\n+\t/* useful.  So does not casting the result.\t\t*/\n+#   \tdefine GC_PTR_ADD(x, n) ((x)+(n))\n+#   endif\n+#else\t/* !GC_DEBUG */\n+#   define GC_PTR_ADD3(x, n, type_of_result) ((x)+(n))\n+#   define GC_PTR_ADD(x, n) ((x)+(n))\n+#   define GC_PRE_INCR3(x, n, type_of_result) ((x) += (n))\n+#   define GC_PRE_INCR(x, n) ((x) += (n))\n+#   define GC_POST_INCR2(x, n, type_of_result) ((x)++)\n+#   define GC_POST_INCR(x, n) ((x)++)\n+#endif\n+\n+/* Safer assignment of a pointer to a nonstack location.\t*/\n+#ifdef GC_DEBUG\n+# ifdef __STDC__\n+#   define GC_PTR_STORE(p, q) \\\n+\t(*(void **)GC_is_visible(p) = GC_is_valid_displacement(q))\n+# else\n+#   define GC_PTR_STORE(p, q) \\\n+\t(*(char **)GC_is_visible(p) = GC_is_valid_displacement(q))\n+# endif\n+#else /* !GC_DEBUG */\n+#   define GC_PTR_STORE(p, q) *((p) = (q))\n+#endif\n+\n+/* Fynctions called to report pointer checking errors */\n+GC_API void (*GC_same_obj_print_proc) GC_PROTO((GC_PTR p, GC_PTR q));\n+\n+GC_API void (*GC_is_valid_displacement_print_proc)\n+\tGC_PROTO((GC_PTR p));\n+\n+GC_API void (*GC_is_visible_print_proc)\n+\tGC_PROTO((GC_PTR p));\n+\n+#ifdef SOLARIS_THREADS\n+/* We need to intercept calls to many of the threads primitives, so \t*/\n+/* that we can locate thread stacks and stop the world.\t\t\t*/\n+/* Note also that the collector cannot see thread specific data.\t*/\n+/* Thread specific data should generally consist of pointers to\t\t*/\n+/* uncollectable objects, which are deallocated using the destructor\t*/\n+/* facility in thr_keycreate.\t\t\t\t\t\t*/\n+# include <thread.h>\n+# include <signal.h>\n+  int GC_thr_create(void *stack_base, size_t stack_size,\n+                    void *(*start_routine)(void *), void *arg, long flags,\n+                    thread_t *new_thread);\n+  int GC_thr_join(thread_t wait_for, thread_t *departed, void **status);\n+  int GC_thr_suspend(thread_t target_thread);\n+  int GC_thr_continue(thread_t target_thread);\n+  void * GC_dlopen(const char *path, int mode);\n+\n+# ifdef _SOLARIS_PTHREADS\n+#   include <pthread.h>\n+    extern int GC_pthread_create(pthread_t *new_thread,\n+    \t\t\t         const pthread_attr_t *attr,\n+          \t\t\t void * (*thread_execp)(void *), void *arg);\n+    extern int GC_pthread_join(pthread_t wait_for, void **status);\n+\n+#   undef thread_t\n+\n+#   define pthread_join GC_pthread_join\n+#   define pthread_create GC_pthread_create\n+#endif\n+\n+# define thr_create GC_thr_create\n+# define thr_join GC_thr_join\n+# define thr_suspend GC_thr_suspend\n+# define thr_continue GC_thr_continue\n+# define dlopen GC_dlopen\n+\n+# endif /* SOLARIS_THREADS */\n+\n+\n+#if defined(IRIX_THREADS) || defined(LINUX_THREADS)\n+/* We treat these similarly. */\n+# include <pthread.h>\n+# include <signal.h>\n+\n+  int GC_pthread_create(pthread_t *new_thread,\n+                        const pthread_attr_t *attr,\n+\t\t        void *(*start_routine)(void *), void *arg);\n+  int GC_pthread_sigmask(int how, const sigset_t *set, sigset_t *oset);\n+  int GC_pthread_join(pthread_t thread, void **retval);\n+\n+# define pthread_create GC_pthread_create\n+# define pthread_sigmask GC_pthread_sigmask\n+# define pthread_join GC_pthread_join\n+\n+#endif /* IRIX_THREADS || LINUX_THREADS */\n+\n+#if defined(THREADS) && !defined(SRC_M3)\n+/* This returns a list of objects, linked through their first\t\t*/\n+/* word.  Its use can greatly reduce lock contention problems, since\t*/\n+/* the allocation lock can be acquired and released many fewer times.\t*/\n+GC_PTR GC_malloc_many(size_t lb);\n+#define GC_NEXT(p) (*(GC_PTR *)(p)) \t/* Retrieve the next element\t*/\n+\t\t\t\t\t/* in returned list.\t\t*/\n+extern void GC_thr_init();\t/* Needed for Solaris/X86\t*/\n+\n+#endif /* THREADS && !SRC_M3 */\n+\n+/*\n+ * If you are planning on putting\n+ * the collector in a SunOS 5 dynamic library, you need to call GC_INIT()\n+ * from the statically loaded program section.\n+ * This circumvents a Solaris 2.X (X<=4) linker bug.\n+ */\n+#if defined(sparc) || defined(__sparc)\n+#   define GC_INIT() { extern end, etext; \\\n+\t\t       GC_noop(&end, &etext); }\n+#else\n+# if defined(__CYGWIN32__) && defined(GC_USE_DLL)\n+    /*\n+     * Similarly gnu-win32 DLLs need explicit initialization\n+     */\n+#   define GC_INIT() { GC_add_roots(DATASTART, DATAEND); }\n+# else\n+#   define GC_INIT()\n+# endif\n+#endif\n+\n+#ifdef __cplusplus\n+    }  /* end of extern \"C\" */\n+#endif\n+\n+#endif /* _GC_H */"}]}