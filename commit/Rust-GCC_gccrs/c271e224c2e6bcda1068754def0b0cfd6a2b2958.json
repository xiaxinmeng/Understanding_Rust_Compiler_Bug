{"sha": "c271e224c2e6bcda1068754def0b0cfd6a2b2958", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI3MWUyMjRjMmU2YmNkYTEwNjg3NTRkZWYwYjBjZmQ2YTJiMjk1OA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2015-03-06T16:19:05Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2015-03-06T16:19:05Z"}, "message": "libgo: Upgrade to Go 1.4.2 release.\n\nFrom-SVN: r221245", "tree": {"sha": "122e64d46042099f2d5b39e31532f3d0358b5ad3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/122e64d46042099f2d5b39e31532f3d0358b5ad3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c271e224c2e6bcda1068754def0b0cfd6a2b2958", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c271e224c2e6bcda1068754def0b0cfd6a2b2958", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c271e224c2e6bcda1068754def0b0cfd6a2b2958", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c271e224c2e6bcda1068754def0b0cfd6a2b2958/comments", "author": null, "committer": null, "parents": [{"sha": "81b0d9065c3c832af6621e79e9d9b3c2bc684122", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81b0d9065c3c832af6621e79e9d9b3c2bc684122", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81b0d9065c3c832af6621e79e9d9b3c2bc684122"}], "stats": {"total": 236, "additions": 170, "deletions": 66}, "files": [{"sha": "260f8cf8e5980906d098a34490e4961b820e7a7d", "filename": "libgo/MERGE", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=c271e224c2e6bcda1068754def0b0cfd6a2b2958", "patch": "@@ -1,4 +1,4 @@\n-14854533dcc7\n+883bc6ed0ea815293fe6309d66f967ea60630e87\n \n-The first line of this file holds the Mercurial revision number of the\n+The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "bcab27e8d3e70ed7a07e5eda1a62df377075d852", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=c271e224c2e6bcda1068754def0b0cfd6a2b2958", "patch": "@@ -1 +1 @@\n-go1.4\n\\ No newline at end of file\n+go1.4.2\n\\ No newline at end of file"}, {"sha": "7191ee0f3a9f8e99629f8f0f9512ea9574f58689", "filename": "libgo/go/cmd/go/doc.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2Fgo%2Fcmd%2Fgo%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2Fgo%2Fcmd%2Fgo%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fdoc.go?ref=c271e224c2e6bcda1068754def0b0cfd6a2b2958", "patch": "@@ -308,6 +308,7 @@ The generator is run in the package's source directory.\n Go generate accepts one specific flag:\n \n \t-run=\"\"\n+\t\tTODO: This flag is unimplemented.\n \t\tif non-empty, specifies a regular expression to\n \t\tselect directives whose command matches the expression.\n "}, {"sha": "3c0af8760b5eeeb00b17c7dedfea877303ce2eac", "filename": "libgo/go/cmd/go/generate.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2Fgo%2Fcmd%2Fgo%2Fgenerate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2Fgo%2Fcmd%2Fgo%2Fgenerate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgenerate.go?ref=c271e224c2e6bcda1068754def0b0cfd6a2b2958", "patch": "@@ -106,6 +106,7 @@ The generator is run in the package's source directory.\n Go generate accepts one specific flag:\n \n \t-run=\"\"\n+\t\tTODO: This flag is unimplemented.\n \t\tif non-empty, specifies a regular expression to\n \t\tselect directives whose command matches the expression.\n \n@@ -255,6 +256,10 @@ func (g *Generator) split(line string) []string {\n \t// Parse line, obeying quoted strings.\n \tvar words []string\n \tline = line[len(\"//go:generate \") : len(line)-1] // Drop preamble and final newline.\n+\t// There may still be a carriage return.\n+\tif len(line) > 0 && line[len(line)-1] == '\\r' {\n+\t\tline = line[:len(line)-1]\n+\t}\n \t// One (possibly quoted) word per iteration.\n Words:\n \tfor {"}, {"sha": "2ec548630acc095d3847de3723d48a70d35a8a38", "filename": "libgo/go/cmd/go/generate_test.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2Fgo%2Fcmd%2Fgo%2Fgenerate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2Fgo%2Fcmd%2Fgo%2Fgenerate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgenerate_test.go?ref=c271e224c2e6bcda1068754def0b0cfd6a2b2958", "patch": "@@ -40,9 +40,15 @@ func TestGenerateCommandParse(t *testing.T) {\n \t}\n \tg.setShorthand([]string{\"-command\", \"yacc\", \"go\", \"tool\", \"yacc\"})\n \tfor _, test := range splitTests {\n+\t\t// First with newlines.\n \t\tgot := g.split(\"//go:generate \" + test.in + \"\\n\")\n \t\tif !reflect.DeepEqual(got, test.out) {\n \t\t\tt.Errorf(\"split(%q): got %q expected %q\", test.in, got, test.out)\n \t\t}\n+\t\t// Then with CRLFs, thank you Windows.\n+\t\tgot = g.split(\"//go:generate \" + test.in + \"\\r\\n\")\n+\t\tif !reflect.DeepEqual(got, test.out) {\n+\t\t\tt.Errorf(\"split(%q): got %q expected %q\", test.in, got, test.out)\n+\t\t}\n \t}\n }"}, {"sha": "50e0ca93bf42053466b83543c63cccf45bae90e4", "filename": "libgo/go/cmd/go/get.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2Fgo%2Fcmd%2Fgo%2Fget.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2Fgo%2Fcmd%2Fgo%2Fget.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fget.go?ref=c271e224c2e6bcda1068754def0b0cfd6a2b2958", "patch": "@@ -290,7 +290,7 @@ func downloadPackage(p *Package) error {\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tif remote != repo {\n-\t\t\t\t\t\treturn fmt.Errorf(\"%s is from %s, should be from %s\", dir, remote, repo)\n+\t\t\t\t\t\treturn fmt.Errorf(\"%s is a custom import path for %s, but %s is checked out from %s\", rr.root, repo, dir, remote)\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}"}, {"sha": "ade5c2fc8cddb151b07e731b280e93500292d0b6", "filename": "libgo/go/math/big/int.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2Fgo%2Fmath%2Fbig%2Fint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2Fgo%2Fmath%2Fbig%2Fint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fint.go?ref=c271e224c2e6bcda1068754def0b0cfd6a2b2958", "patch": "@@ -887,7 +887,7 @@ func (z *Int) AndNot(x, y *Int) *Int {\n \t}\n \n \t// x &^ (-y) == x &^ ^(y-1) == x & (y-1)\n-\ty1 := nat(nil).add(y.abs, natOne)\n+\ty1 := nat(nil).sub(y.abs, natOne)\n \tz.abs = z.abs.and(x.abs, y1)\n \tz.neg = false\n \treturn z"}, {"sha": "2d762dbc89f49db4e33e7746792eea7605364179", "filename": "libgo/go/math/big/int_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2Fgo%2Fmath%2Fbig%2Fint_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2Fgo%2Fmath%2Fbig%2Fint_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fint_test.go?ref=c271e224c2e6bcda1068754def0b0cfd6a2b2958", "patch": "@@ -1201,6 +1201,7 @@ var bitwiseTests = []struct {\n \t{\"-0x01\", \"-0x01\", \"-0x01\", \"-0x01\", \"0x00\", \"0x00\"},\n \t{\"0x07\", \"0x08\", \"0x00\", \"0x0f\", \"0x0f\", \"0x07\"},\n \t{\"0x05\", \"0x0f\", \"0x05\", \"0x0f\", \"0x0a\", \"0x00\"},\n+\t{\"0xff\", \"-0x0a\", \"0xf6\", \"-0x01\", \"-0xf7\", \"0x09\"},\n \t{\"0x013ff6\", \"0x9a4e\", \"0x1a46\", \"0x01bffe\", \"0x01a5b8\", \"0x0125b0\"},\n \t{\"-0x013ff6\", \"0x9a4e\", \"0x800a\", \"-0x0125b2\", \"-0x01a5bc\", \"-0x01c000\"},\n \t{\"-0x013ff6\", \"-0x9a4e\", \"-0x01bffe\", \"-0x1a46\", \"0x01a5b8\", \"0x8008\"},"}, {"sha": "5cbf7e577a3338c883b9402ec47fdbe9c77eb436", "filename": "libgo/go/reflect/type.go", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2Fgo%2Freflect%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2Fgo%2Freflect%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Ftype.go?ref=c271e224c2e6bcda1068754def0b0cfd6a2b2958", "patch": "@@ -248,12 +248,12 @@ const (\n // with a unique tag like `reflect:\"array\"` or `reflect:\"ptr\"`\n // so that code cannot convert from, say, *arrayType to *ptrType.\n type rtype struct {\n-\tkind       uint8   // enumeration for C\n-\talign      int8    // alignment of variable with this type\n-\tfieldAlign uint8   // alignment of struct field with this type\n-\t_          uint8   // unused/padding\n+\tkind       uint8 // enumeration for C\n+\talign      int8  // alignment of variable with this type\n+\tfieldAlign uint8 // alignment of struct field with this type\n+\t_          uint8 // unused/padding\n \tsize       uintptr\n-\thash       uint32  // hash of type; avoids computation in hash tables\n+\thash       uint32 // hash of type; avoids computation in hash tables\n \n \thashfn  uintptr // hash function code\n \tequalfn uintptr // equality function code\n@@ -1582,8 +1582,9 @@ func MapOf(key, elem Type) Type {\n \n // gcProg is a helper type for generatation of GC pointer info.\n type gcProg struct {\n-\tgc   []byte\n-\tsize uintptr // size of type in bytes\n+\tgc     []byte\n+\tsize   uintptr // size of type in bytes\n+\thasPtr bool\n }\n \n func (gc *gcProg) append(v byte) {\n@@ -1644,11 +1645,14 @@ func (gc *gcProg) appendWord(v byte) {\n \tgc.gc[nptr/2] &= ^(3 << ((nptr%2)*4 + 2))\n \tgc.gc[nptr/2] |= v << ((nptr%2)*4 + 2)\n \tgc.size += ptrsize\n+\tif v == bitsPointer {\n+\t\tgc.hasPtr = true\n+\t}\n }\n \n-func (gc *gcProg) finalize() unsafe.Pointer {\n+func (gc *gcProg) finalize() (unsafe.Pointer, bool) {\n \tif gc.size == 0 {\n-\t\treturn nil\n+\t\treturn nil, false\n \t}\n \tptrsize := unsafe.Sizeof(uintptr(0))\n \tgc.align(ptrsize)\n@@ -1663,7 +1667,7 @@ func (gc *gcProg) finalize() unsafe.Pointer {\n \t\t\tgc.appendWord(extractGCWord(gc.gc, i))\n \t\t}\n \t}\n-\treturn unsafe.Pointer(&gc.gc[0])\n+\treturn unsafe.Pointer(&gc.gc[0]), gc.hasPtr\n }\n \n func extractGCWord(gc []byte, i uintptr) byte {\n@@ -1708,10 +1712,6 @@ func bucketOf(ktyp, etyp *rtype) *rtype {\n \tfor i := 0; i < int(bucketSize*unsafe.Sizeof(uint8(0))/ptrsize); i++ {\n \t\tgc.append(bitsScalar)\n \t}\n-\tgc.append(bitsPointer) // overflow\n-\tif runtime.GOARCH == \"amd64p32\" {\n-\t\tgc.append(bitsScalar)\n-\t}\n \t// keys\n \tfor i := 0; i < bucketSize; i++ {\n \t\tgc.appendProg(ktyp)\n@@ -1720,10 +1720,15 @@ func bucketOf(ktyp, etyp *rtype) *rtype {\n \tfor i := 0; i < bucketSize; i++ {\n \t\tgc.appendProg(etyp)\n \t}\n+\t// overflow\n+\tgc.append(bitsPointer)\n+\tif runtime.GOARCH == \"amd64p32\" {\n+\t\tgc.append(bitsScalar)\n+\t}\n \n \tb := new(rtype)\n \tb.size = gc.size\n-\t// b.gc[0] = gc.finalize()\n+\t// b.gc[0], _ = gc.finalize()\n \tb.kind |= kindGCProg\n \ts := \"bucket(\" + *ktyp.string + \",\" + *etyp.string + \")\"\n \tb.string = &s"}, {"sha": "29f90fa36d27fc521c008ad71b923b103334bd52", "filename": "libgo/go/runtime/crash_cgo_test.go", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2Fgo%2Fruntime%2Fcrash_cgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2Fgo%2Fruntime%2Fcrash_cgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcrash_cgo_test.go?ref=c271e224c2e6bcda1068754def0b0cfd6a2b2958", "patch": "@@ -7,6 +7,7 @@\n package runtime_test\n \n import (\n+\t\"os/exec\"\n \t\"runtime\"\n \t\"strings\"\n \t\"testing\"\n@@ -50,6 +51,30 @@ func TestCgoExternalThreadPanic(t *testing.T) {\n \t}\n }\n \n+func TestCgoExternalThreadSIGPROF(t *testing.T) {\n+\t// issue 9456.\n+\tswitch runtime.GOOS {\n+\tcase \"plan9\", \"windows\":\n+\t\tt.Skipf(\"no pthreads on %s\", runtime.GOOS)\n+\tcase \"darwin\":\n+\t\t// static constructor needs external linking, but we don't support\n+\t\t// external linking on OS X 10.6.\n+\t\tout, err := exec.Command(\"uname\", \"-r\").Output()\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"uname -r failed: %v\", err)\n+\t\t}\n+\t\t// OS X 10.6 == Darwin 10.x\n+\t\tif strings.HasPrefix(string(out), \"10.\") {\n+\t\t\tt.Skipf(\"no external linking on OS X 10.6\")\n+\t\t}\n+\t}\n+\tgot := executeTest(t, cgoExternalThreadSIGPROFSource, nil)\n+\twant := \"OK\\n\"\n+\tif got != want {\n+\t\tt.Fatalf(\"expected %q, but got %q\", want, got)\n+\t}\n+}\n+\n const cgoSignalDeadlockSource = `\n package main\n \n@@ -194,3 +219,46 @@ start(void)\n \t\tprintf(\"_beginthreadex failed\\n\");\n }\n `\n+\n+const cgoExternalThreadSIGPROFSource = `\n+package main\n+\n+/*\n+#include <stdint.h>\n+#include <signal.h>\n+#include <pthread.h>\n+\n+volatile int32_t spinlock;\n+\n+static void *thread1(void *p) {\n+\t(void)p;\n+\twhile (spinlock == 0)\n+\t\t;\n+\tpthread_kill(pthread_self(), SIGPROF);\n+\tspinlock = 0;\n+\treturn NULL;\n+}\n+__attribute__((constructor)) void issue9456() {\n+\tpthread_t tid;\n+\tpthread_create(&tid, 0, thread1, NULL);\n+}\n+*/\n+import \"C\"\n+\n+import (\n+\t\"runtime\"\n+\t\"sync/atomic\"\n+\t\"unsafe\"\n+)\n+\n+func main() {\n+\t// This test intends to test that sending SIGPROF to foreign threads\n+\t// before we make any cgo call will not abort the whole process, so\n+\t// we cannot make any cgo call here. See http://golang.org/issue/9456.\n+\tatomic.StoreInt32((*int32)(unsafe.Pointer(&C.spinlock)), 1)\n+\tfor atomic.LoadInt32((*int32)(unsafe.Pointer(&C.spinlock))) == 1 {\n+\t\truntime.Gosched()\n+\t}\n+\tprintln(\"OK\")\n+}\n+`"}, {"sha": "791af8cf36a7b3512be85c5c352b6df7e9b0a1f6", "filename": "libgo/go/runtime/hashmap.go", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2Fgo%2Fruntime%2Fhashmap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2Fgo%2Fruntime%2Fhashmap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fhashmap.go?ref=c271e224c2e6bcda1068754def0b0cfd6a2b2958", "patch": "@@ -117,12 +117,12 @@ type hmap struct {\n \n // A bucket for a Go map.\n type bmap struct {\n-\ttophash  [bucketCnt]uint8\n-\toverflow *bmap\n+\ttophash [bucketCnt]uint8\n \t// Followed by bucketCnt keys and then bucketCnt values.\n \t// NOTE: packing all the keys together and then all the values together makes the\n \t// code a bit more complicated than alternating key/value/key/value/... but it allows\n \t// us to eliminate padding which would be needed for, e.g., map[int64]int8.\n+\t// Followed by an overflow pointer.\n }\n \n // A hash iteration structure.\n@@ -149,6 +149,13 @@ func evacuated(b *bmap) bool {\n \treturn h > empty && h < minTopHash\n }\n \n+func (b *bmap) overflow(t *maptype) *bmap {\n+\treturn *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-regSize))\n+}\n+func (b *bmap) setoverflow(t *maptype, ovf *bmap) {\n+\t*(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-regSize)) = ovf\n+}\n+\n func makemap(t *maptype, hint int64) *hmap {\n \tif sz := unsafe.Sizeof(hmap{}); sz > 48 || sz != uintptr(t.hmap.size) {\n \t\tgothrow(\"bad hmap size\")\n@@ -275,7 +282,7 @@ func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {\n \t\t\t\treturn v\n \t\t\t}\n \t\t}\n-\t\tb = b.overflow\n+\t\tb = b.overflow(t)\n \t\tif b == nil {\n \t\t\treturn unsafe.Pointer(t.elem.zero)\n \t\t}\n@@ -323,7 +330,7 @@ func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool)\n \t\t\t\treturn v, true\n \t\t\t}\n \t\t}\n-\t\tb = b.overflow\n+\t\tb = b.overflow(t)\n \t\tif b == nil {\n \t\t\treturn unsafe.Pointer(t.elem.zero), false\n \t\t}\n@@ -366,7 +373,7 @@ func mapaccessK(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, unsafe\n \t\t\t\treturn k, v\n \t\t\t}\n \t\t}\n-\t\tb = b.overflow\n+\t\tb = b.overflow(t)\n \t\tif b == nil {\n \t\t\treturn nil, nil\n \t\t}\n@@ -437,10 +444,11 @@ again:\n \t\t\tmemmove(v2, val, uintptr(t.elem.size))\n \t\t\treturn\n \t\t}\n-\t\tif b.overflow == nil {\n+\t\tovf := b.overflow(t)\n+\t\tif ovf == nil {\n \t\t\tbreak\n \t\t}\n-\t\tb = b.overflow\n+\t\tb = ovf\n \t}\n \n \t// did not find mapping for key.  Allocate new cell & add entry.\n@@ -455,7 +463,7 @@ again:\n \t\t\tmemstats.next_gc = memstats.heap_alloc\n \t\t}\n \t\tnewb := (*bmap)(newobject(t.bucket))\n-\t\tb.overflow = newb\n+\t\tb.setoverflow(t, newb)\n \t\tinserti = &newb.tophash[0]\n \t\tinsertk = add(unsafe.Pointer(newb), dataOffset)\n \t\tinsertv = add(insertk, bucketCnt*uintptr(t.keysize))\n@@ -525,7 +533,7 @@ func mapdelete(t *maptype, h *hmap, key unsafe.Pointer) {\n \t\t\th.count--\n \t\t\treturn\n \t\t}\n-\t\tb = b.overflow\n+\t\tb = b.overflow(t)\n \t\tif b == nil {\n \t\t\treturn\n \t\t}\n@@ -720,7 +728,7 @@ next:\n \t\t\treturn\n \t\t}\n \t}\n-\tb = b.overflow\n+\tb = b.overflow(t)\n \ti = 0\n \tgoto next\n }\n@@ -778,7 +786,7 @@ func evacuate(t *maptype, h *hmap, oldbucket uintptr) {\n \t\tyk := add(unsafe.Pointer(y), dataOffset)\n \t\txv := add(xk, bucketCnt*uintptr(t.keysize))\n \t\tyv := add(yk, bucketCnt*uintptr(t.keysize))\n-\t\tfor ; b != nil; b = b.overflow {\n+\t\tfor ; b != nil; b = b.overflow(t) {\n \t\t\tk := add(unsafe.Pointer(b), dataOffset)\n \t\t\tv := add(k, bucketCnt*uintptr(t.keysize))\n \t\t\tfor i := 0; i < bucketCnt; i, k, v = i+1, add(k, uintptr(t.keysize)), add(v, uintptr(t.valuesize)) {\n@@ -828,7 +836,7 @@ func evacuate(t *maptype, h *hmap, oldbucket uintptr) {\n \t\t\t\t\t\t\tmemstats.next_gc = memstats.heap_alloc\n \t\t\t\t\t\t}\n \t\t\t\t\t\tnewx := (*bmap)(newobject(t.bucket))\n-\t\t\t\t\t\tx.overflow = newx\n+\t\t\t\t\t\tx.setoverflow(t, newx)\n \t\t\t\t\t\tx = newx\n \t\t\t\t\t\txi = 0\n \t\t\t\t\t\txk = add(unsafe.Pointer(x), dataOffset)\n@@ -855,7 +863,7 @@ func evacuate(t *maptype, h *hmap, oldbucket uintptr) {\n \t\t\t\t\t\t\tmemstats.next_gc = memstats.heap_alloc\n \t\t\t\t\t\t}\n \t\t\t\t\t\tnewy := (*bmap)(newobject(t.bucket))\n-\t\t\t\t\t\ty.overflow = newy\n+\t\t\t\t\t\ty.setoverflow(t, newy)\n \t\t\t\t\t\ty = newy\n \t\t\t\t\t\tyi = 0\n \t\t\t\t\t\tyk = add(unsafe.Pointer(y), dataOffset)\n@@ -881,7 +889,6 @@ func evacuate(t *maptype, h *hmap, oldbucket uintptr) {\n \t\t// Unlink the overflow buckets & clear key/value to help GC.\n \t\tif h.flags&oldIterator == 0 {\n \t\t\tb = (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize)))\n-\t\t\tb.overflow = nil\n \t\t\tmemclr(add(unsafe.Pointer(b), dataOffset), uintptr(t.bucketsize)-dataOffset)\n \t\t}\n \t}"}, {"sha": "afa6ecc99a9fd5f9e581fe7603ac4b781460e9d9", "filename": "libgo/go/runtime/hashmap_fast.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2Fgo%2Fruntime%2Fhashmap_fast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2Fgo%2Fruntime%2Fhashmap_fast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fhashmap_fast.go?ref=c271e224c2e6bcda1068754def0b0cfd6a2b2958", "patch": "@@ -43,7 +43,7 @@ func mapaccess1_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer {\n \t\t\t}\n \t\t\treturn add(unsafe.Pointer(b), dataOffset+bucketCnt*4+i*uintptr(t.valuesize))\n \t\t}\n-\t\tb = b.overflow\n+\t\tb = b.overflow(t)\n \t\tif b == nil {\n \t\t\treturn unsafe.Pointer(t.elem.zero)\n \t\t}\n@@ -85,7 +85,7 @@ func mapaccess2_fast32(t *maptype, h *hmap, key uint32) (unsafe.Pointer, bool) {\n \t\t\t}\n \t\t\treturn add(unsafe.Pointer(b), dataOffset+bucketCnt*4+i*uintptr(t.valuesize)), true\n \t\t}\n-\t\tb = b.overflow\n+\t\tb = b.overflow(t)\n \t\tif b == nil {\n \t\t\treturn unsafe.Pointer(t.elem.zero), false\n \t\t}\n@@ -127,7 +127,7 @@ func mapaccess1_fast64(t *maptype, h *hmap, key uint64) unsafe.Pointer {\n \t\t\t}\n \t\t\treturn add(unsafe.Pointer(b), dataOffset+bucketCnt*8+i*uintptr(t.valuesize))\n \t\t}\n-\t\tb = b.overflow\n+\t\tb = b.overflow(t)\n \t\tif b == nil {\n \t\t\treturn unsafe.Pointer(t.elem.zero)\n \t\t}\n@@ -169,7 +169,7 @@ func mapaccess2_fast64(t *maptype, h *hmap, key uint64) (unsafe.Pointer, bool) {\n \t\t\t}\n \t\t\treturn add(unsafe.Pointer(b), dataOffset+bucketCnt*8+i*uintptr(t.valuesize)), true\n \t\t}\n-\t\tb = b.overflow\n+\t\tb = b.overflow(t)\n \t\tif b == nil {\n \t\t\treturn unsafe.Pointer(t.elem.zero), false\n \t\t}\n@@ -271,7 +271,7 @@ dohash:\n \t\t\t\treturn add(unsafe.Pointer(b), dataOffset+bucketCnt*2*ptrSize+i*uintptr(t.valuesize))\n \t\t\t}\n \t\t}\n-\t\tb = b.overflow\n+\t\tb = b.overflow(t)\n \t\tif b == nil {\n \t\t\treturn unsafe.Pointer(t.elem.zero)\n \t\t}\n@@ -371,7 +371,7 @@ dohash:\n \t\t\t\treturn add(unsafe.Pointer(b), dataOffset+bucketCnt*2*ptrSize+i*uintptr(t.valuesize)), true\n \t\t\t}\n \t\t}\n-\t\tb = b.overflow\n+\t\tb = b.overflow(t)\n \t\tif b == nil {\n \t\t\treturn unsafe.Pointer(t.elem.zero), false\n \t\t}"}, {"sha": "f4da45f5c307d51894645e6c4623c412b5f04167", "filename": "libgo/go/runtime/mprof.go", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2Fgo%2Fruntime%2Fmprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2Fgo%2Fruntime%2Fmprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmprof.go?ref=c271e224c2e6bcda1068754def0b0cfd6a2b2958", "patch": "@@ -575,20 +575,16 @@ func saveg(pc, sp uintptr, gp *g, r *StackRecord) {\n // If all is true, Stack formats stack traces of all other goroutines\n // into buf after the trace for the current goroutine.\n func Stack(buf []byte, all bool) int {\n-\tmp := acquirem()\n-\tgp := mp.curg\n \tif all {\n \t\tsemacquire(&worldsema, false)\n-\t\tmp.gcing = 1\n-\t\treleasem(mp)\n+\t\tgp := getg()\n+\t\tgp.m.gcing = 1\n \t\tonM(stoptheworld)\n-\t\tif mp != acquirem() {\n-\t\t\tgothrow(\"Stack: rescheduled\")\n-\t\t}\n \t}\n \n \tn := 0\n \tif len(buf) > 0 {\n+\t\tgp := getg()\n \t\tsp := getcallersp(unsafe.Pointer(&buf))\n \t\tpc := getcallerpc(unsafe.Pointer(&buf))\n \t\tonM(func() {\n@@ -605,11 +601,11 @@ func Stack(buf []byte, all bool) int {\n \t}\n \n \tif all {\n-\t\tmp.gcing = 0\n+\t\tgp := getg()\n+\t\tgp.m.gcing = 0\n \t\tsemrelease(&worldsema)\n \t\tonM(starttheworld)\n \t}\n-\treleasem(mp)\n \treturn n\n }\n "}, {"sha": "10e5531ecc82eb811cbae018b3a8a71542901c1e", "filename": "libgo/go/runtime/os_plan9.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2Fgo%2Fruntime%2Fos_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2Fgo%2Fruntime%2Fos_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_plan9.go?ref=c271e224c2e6bcda1068754def0b0cfd6a2b2958", "patch": "@@ -6,6 +6,8 @@ package runtime\n \n import \"unsafe\"\n \n+const _SIGPROF = 0 // dummy value for badsignal\n+\n func pread(fd int32, buf unsafe.Pointer, nbytes int32, offset int64) int32\n func pwrite(fd int32, buf unsafe.Pointer, nbytes int32, offset int64) int32\n func seek(fd int32, offset int64, whence int32) int64"}, {"sha": "fed4560fe3399c8df93c51f3043d71f758e47795", "filename": "libgo/go/runtime/sigqueue.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2Fgo%2Fruntime%2Fsigqueue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2Fgo%2Fruntime%2Fsigqueue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsigqueue.go?ref=c271e224c2e6bcda1068754def0b0cfd6a2b2958", "patch": "@@ -154,6 +154,15 @@ func signal_disable(s uint32) {\n // This runs on a foreign stack, without an m or a g.  No stack split.\n //go:nosplit\n func badsignal(sig uintptr) {\n+\t// Some external libraries, for example, OpenBLAS, create worker threads in\n+\t// a global constructor. If we're doing cpu profiling, and the SIGPROF signal\n+\t// comes to one of the foreign threads before we make our first cgo call, the\n+\t// call to cgocallback below will bring down the whole process.\n+\t// It's better to miss a few SIGPROF signals than to abort in this case.\n+\t// See http://golang.org/issue/9456.\n+\tif _SIGPROF != 0 && sig == _SIGPROF && needextram != 0 {\n+\t\treturn\n+\t}\n \tcgocallback(unsafe.Pointer(funcPC(sigsend)), noescape(unsafe.Pointer(&sig)), unsafe.Sizeof(sig))\n }\n "}, {"sha": "51004b78a0271a5ce535568c26f5a11756a2f9ee", "filename": "libgo/go/runtime/syscall_windows.go", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2Fgo%2Fruntime%2Fsyscall_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2Fgo%2Fruntime%2Fsyscall_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsyscall_windows.go?ref=c271e224c2e6bcda1068754def0b0cfd6a2b2958", "patch": "@@ -8,6 +8,8 @@ import (\n \t\"unsafe\"\n )\n \n+const _SIGPROF = 0 // dummy value for badsignal\n+\n type callbacks struct {\n \tlock mutex\n \tctxt [cb_max]*wincallbackcontext\n@@ -52,11 +54,13 @@ func compileCallback(fn eface, cleanstack bool) (code uintptr) {\n \t\tpanic(\"compilecallback: output parameter size is wrong\")\n \t}\n \targsize := uintptr(0)\n-\tfor _, t := range (*[1024](*_type))(unsafe.Pointer(&ft.in[0]))[:len(ft.in)] {\n-\t\tif (*t).size > uintptrSize {\n-\t\t\tpanic(\"compilecallback: input parameter size is wrong\")\n+\tif len(ft.in) > 0 {\n+\t\tfor _, t := range (*[1024](*_type))(unsafe.Pointer(&ft.in[0]))[:len(ft.in)] {\n+\t\t\tif (*t).size > uintptrSize {\n+\t\t\t\tpanic(\"compilecallback: input parameter size is wrong\")\n+\t\t\t}\n+\t\t\targsize += uintptrSize\n \t\t}\n-\t\targsize += uintptrSize\n \t}\n \n \tlock(&cbs.lock)"}, {"sha": "e5086400c5d40b9f2779f84233268502ff72edba", "filename": "libgo/go/syscall/route_openbsd.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2Fgo%2Fsyscall%2Froute_openbsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2Fgo%2Fsyscall%2Froute_openbsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Froute_openbsd.go?ref=c271e224c2e6bcda1068754def0b0cfd6a2b2958", "patch": "@@ -12,16 +12,16 @@ func (any *anyMessage) toRoutingMessage(b []byte) RoutingMessage {\n \tswitch any.Type {\n \tcase RTM_ADD, RTM_DELETE, RTM_CHANGE, RTM_GET, RTM_LOSING, RTM_REDIRECT, RTM_MISS, RTM_LOCK, RTM_RESOLVE:\n \t\tp := (*RouteMessage)(unsafe.Pointer(any))\n-\t\treturn &RouteMessage{Header: p.Header, Data: b[SizeofRtMsghdr:any.Msglen]}\n+\t\treturn &RouteMessage{Header: p.Header, Data: b[p.Header.Hdrlen:any.Msglen]}\n \tcase RTM_IFINFO:\n \t\tp := (*InterfaceMessage)(unsafe.Pointer(any))\n-\t\treturn &InterfaceMessage{Header: p.Header, Data: b[SizeofIfMsghdr:any.Msglen]}\n+\t\treturn &InterfaceMessage{Header: p.Header, Data: b[p.Header.Hdrlen:any.Msglen]}\n \tcase RTM_IFANNOUNCE:\n \t\tp := (*InterfaceAnnounceMessage)(unsafe.Pointer(any))\n \t\treturn &InterfaceAnnounceMessage{Header: p.Header}\n \tcase RTM_NEWADDR, RTM_DELADDR:\n \t\tp := (*InterfaceAddrMessage)(unsafe.Pointer(any))\n-\t\treturn &InterfaceAddrMessage{Header: p.Header, Data: b[SizeofIfaMsghdr:any.Msglen]}\n+\t\treturn &InterfaceAddrMessage{Header: p.Header, Data: b[p.Header.Hdrlen:any.Msglen]}\n \t}\n \treturn nil\n }"}, {"sha": "c79f7596dcaa8cbb13496223b7d25dfb218c6d9d", "filename": "libgo/merge.sh", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2Fmerge.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c271e224c2e6bcda1068754def0b0cfd6a2b2958/libgo%2Fmerge.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmerge.sh?ref=c271e224c2e6bcda1068754def0b0cfd6a2b2958", "patch": "@@ -40,12 +40,14 @@ repository=$1\n old_rev=`sed 1q MERGE`\n \n rm -rf ${OLDDIR}\n-hg clone -r ${old_rev} ${repository} ${OLDDIR}\n+git clone ${repository} ${OLDDIR}\n+(cd ${OLDDIR} && git checkout ${old_rev})\n \n rm -rf ${NEWDIR}\n-hg clone -u ${rev} ${repository} ${NEWDIR}\n+git clone ${repository} ${NEWDIR}\n+(cd ${NEWDIR} && git checkout ${rev})\n \n-new_rev=`cd ${NEWDIR} && hg log -r ${rev} | sed 1q | sed -e 's/.*://'`\n+new_rev=`cd ${NEWDIR} && git log | sed 1q | sed -e 's/commit //'`\n \n merge() {\n   name=$1\n@@ -69,7 +71,7 @@ merge() {\n   elif test -f ${old}; then\n     # The file exists in the old version.\n     if ! test -f ${libgo}; then\n-      echo \"merge.sh: $name: skipping: exists in old and new hg, but not in libgo\"\n+      echo \"merge.sh: $name: skipping: exists in old and new git, but not in libgo\"\n       continue\n     fi\n     if cmp -s ${old} ${libgo}; then\n@@ -160,11 +162,10 @@ done\n   if ! test -d ${oldtd}; then\n     continue\n   fi\n-  (cd ${oldtd} && hg status -A .) | while read f; do\n-    if test \"`basename $f`\" = \".hgignore\"; then\n+  (cd ${oldtd} && git ls-files .) | while read f; do\n+    if test \"`basename $f`\" = \".gitignore\"; then\n       continue\n     fi\n-    f=`echo $f | sed -e 's/^..//'`\n     name=$d/$f\n     oldfile=${oldtd}/$f\n     newfile=${newtd}/$f\n@@ -189,11 +190,10 @@ for c in $cmdlist; do\n     if ! test -d ${oldtd}; then\n       continue\n     fi\n-    (cd ${oldtd} && hg status -A .) | while read f; do\n-      if test \"`basename $f`\" = \".hgignore\"; then\n+    (cd ${oldtd} && git ls-files .) | while read f; do\n+      if test \"`basename $f`\" = \".gitignore\"; then\n         continue\n       fi\n-      f=`echo $f | sed -e 's/^..//'`\n       name=$d/$f\n       oldfile=${oldtd}/$f\n       newfile=${newtd}/$f"}]}