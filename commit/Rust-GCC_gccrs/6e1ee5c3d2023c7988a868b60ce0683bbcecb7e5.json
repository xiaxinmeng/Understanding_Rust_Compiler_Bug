{"sha": "6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmUxZWU1YzNkMjAyM2M3OTg4YTg2OGI2MGNlMDY4M2JiY2VjYjdlNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-23T12:44:34Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-23T12:44:34Z"}, "message": "[multiple changes]\n\n2010-06-23  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_attr.adb (Expand_Access_To_Protected_Op): When rewriting a\n\treference to a protected subprogram outside of the protected's scope,\n\tensure the corresponding external subprogram is frozen before the\n\treference.\n\n2010-06-23  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_prag.adb: Fix typo in error message.\n\t* sem.adb: Refine previous change.\n\n2010-06-23  Robert Dewar  <dewar@adacore.com>\n\n\t* impunit.adb, a-suewen.adb, a-suewen.ads, a-suenco.adb, a-suenco.ads,\n\ta-suezen.adb, a-suezen.ads, a-stuten.adb, a-stuten.ads, Makefile.rtl:\n\tImplement Ada 2012 string encoding packages.\n\n2010-06-23  Arnaud Charlet  <charlet@adacore.com>\n\n\t* a-stwiun-shared.adb, a-stwiun-shared.ads, a-stzunb-shared.adb,\n\ta-stzunb-shared.ads, a-swunau-shared.adb, a-swuwti-shared.adb,\n\ta-szunau-shared.adb, a-szuzti-shared.adb: New files.\n\t* gcc-interface/Makefile.in: Enable use of above files.\n\nFrom-SVN: r161277", "tree": {"sha": "1ce6fa5db63816fd6ff6b576aff227f6b37f6c4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ce6fa5db63816fd6ff6b576aff227f6b37f6c4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/comments", "author": null, "committer": null, "parents": [{"sha": "f52d94aad096e7762646e0f6e0b7f9243ea6a7ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f52d94aad096e7762646e0f6e0b7f9243ea6a7ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f52d94aad096e7762646e0f6e0b7f9243ea6a7ea"}], "stats": {"total": 8413, "additions": 7319, "deletions": 1094}, "files": [{"sha": "6e7d4eba44a0762a311aa9f2c019bab97aade5e9", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5", "patch": "@@ -226,6 +226,9 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-stzsea$(objext) \\\n   a-stzsup$(objext) \\\n   a-stzunb$(objext) \\\n+  a-suenco$(objext) \\\n+  a-suewen$(objext) \\\n+  a-suezen$(objext) \\\n   a-suteio$(objext) \\\n   a-swbwha$(objext) \\\n   a-swfwha$(objext) \\"}, {"sha": "fc669b56ee431c0bc136fa34ffc2672bd18d85c5", "filename": "gcc/ada/a-stuten.adb", "status": "modified", "additions": 123, "deletions": 946, "changes": 1069, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fa-stuten.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fa-stuten.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stuten.adb?ref=6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5", "patch": "@@ -27,1006 +27,183 @@\n -- GNAT was originally developed  by the GNAT team at  New York University. --\n -- Extensive contributions were provided by Ada Core Technologies Inc.      --\n --                                                                          --\n--------------------------------------------------------------------------------\n-with Interfaces; use Interfaces;\n-with Unchecked_Conversion;\n+------------------------------------------------------------------------------\n \n package body Ada.Strings.UTF_Encoding is\n+   use Interfaces;\n \n-   function To_Unsigned_8 is new\n-     Unchecked_Conversion (Character, Unsigned_8);\n-\n-   function To_Unsigned_16 is new\n-     Unchecked_Conversion (Wide_Character, Unsigned_16);\n-\n-   function To_Unsigned_32 is new\n-     Unchecked_Conversion (Wide_Wide_Character, Unsigned_32);\n-\n-   --  Local subprograms\n-\n-   procedure Raise_Encoding_Error;\n-   --  Called if an invalid input encoding sequence is found by Decode\n-\n-   function Decode_UTF_8 (Item : String) return Wide_String;\n-   --  Equivalent to Decode (Item, UTF_8), but smaller and faster\n-\n-   function Decode_UTF_8 (Item : String) return Wide_Wide_String;\n-   --  Equivalent to Decode (Item, UTF_8), but smaller and faster\n-\n-   function Encode_UTF_8 (Item : Wide_String) return String;\n-   --  Equivalent to Encode (Item, UTF_8) but smaller and faster\n-\n-   function Encode_UTF_8 (Item : Wide_Wide_String) return String;\n-   --  Equivalent to Encode (Item, UTF_8) but smaller and faster\n-\n-   function Decode_UTF_16 (Item : Wide_String) return Wide_String;\n-   --  Equivalent to Decode (Item, UTF_16)\n-\n-   function Decode_UTF_16 (Item : Wide_String) return Wide_Wide_String;\n-   --  Equivalent to Decode (Item, UTF_16)\n-\n-   function Encode_UTF_16 (Item : Wide_String) return Wide_String;\n-   --  Equivalent to Encode (Item, UTF_16)\n-\n-   function Encode_UTF_16 (Item : Wide_Wide_String) return Wide_String;\n-   --  Equivalent to Encode (Item, UTF_16)\n-\n-   ------------\n-   -- Decode --\n-   ------------\n-\n-   --  String input with Wide_String output (short encodings)\n-\n-   function Decode\n-     (Item   : String;\n-      Scheme : Short_Encoding := UTF_8) return Wide_String\n-   is\n-   begin\n-      --  UTF-8 encoding case\n-\n-      if Scheme = UTF_8 then\n-         return Decode_UTF_8 (Item);\n-\n-      --  Case of UTF_16LE or UTF_16BE\n-\n-      else\n-         UTF16_XE : declare\n-            Input_UTF16 : Wide_String (1 .. Item'Length / 2);\n-            --  UTF_16 input string\n-\n-            Iptr : Natural;\n-            --  Pointer to next location to store in Input_UTF16\n-\n-            Ptr : Natural;\n-            --  Input string pointer\n-\n-            H, L : Natural range 0 .. 1;\n-            --  Offset for high and low order bytes\n-\n-         begin\n-            --  In both cases, the input string must be even in length, since\n-            --  we have two input characters for each input code in UTF_16.\n-\n-            if Item'Length mod 2 /= 0 then\n-               Raise_Encoding_Error;\n-            end if;\n-\n-            --  We first assemble the UTF_16 string from the input. Set offsets\n-            --  for the two bytes. For UTF_16LE we have low order/high order.\n-            --  For UTF_16BE we have high order/low order.\n-\n-            if Scheme = UTF_16LE then\n-               L := 0;\n-               H := 1;\n-            else\n-               L := 1;\n-               H := 0;\n-            end if;\n-\n-            --  Loop to convert input to UTF_16 form\n-\n-            Iptr := 1;\n-            Ptr := Item'First;\n-            while Ptr < Item'Last loop\n-               Input_UTF16 (Iptr) :=\n-                 Wide_Character'Val\n-                   (Unsigned_16 (To_Unsigned_8 (Item (Ptr + L)))\n-                     or\n-                    Shift_Left\n-                      (Unsigned_16 (To_Unsigned_8 (Item (Ptr + H))), 8));\n-               Iptr := Iptr + 1;\n-               Ptr := Ptr + 2;\n-            end loop;\n-\n-            --  Result is obtained by converting this UTF_16 input. Note that\n-            --  we rely on this nested call to Decode to skip any BOM present.\n-\n-            return Decode (Input_UTF16);\n-         end UTF16_XE;\n-      end if;\n-   end Decode;\n-\n-   --  String input with Wide_Wide_String output (short encodings)\n+   --------------\n+   -- Encoding --\n+   --------------\n \n-   function Decode\n-     (Item   : String;\n-      Scheme : Short_Encoding := UTF_8) return Wide_Wide_String\n+   function Encoding\n+     (Item    : UTF_String;\n+      Default : Encoding_Scheme := UTF_8) return Encoding_Scheme\n    is\n    begin\n-      --  UTF-8 encoding case\n-\n-      if Scheme = UTF_8 then\n-         return Decode_UTF_8 (Item);\n-\n-      --  Case of UTF_16LE or UTF_16BE\n-\n-      else\n-         UTF16_XE : declare\n-            Input_UTF16 : Wide_String (1 .. Item'Length / 2);\n-            --  UTF_16 input string\n-\n-            Iptr : Natural;\n-            --  Pointer to next location to store in Input_UTF16\n-\n-            Ptr : Natural;\n-            --  Input string pointer\n-\n-            H, L : Integer range 0 .. 1;\n-            --  Offset for high and low order bytes\n-\n-         begin\n-            --  In both cases, the input string must be even in length, since\n-            --  we have two input characters for each input code in UTF_16.\n-\n-            if Item'Length mod 2 /= 0 then\n-               Raise_Encoding_Error;\n-            end if;\n-\n-            --  We first assemble the UTF_16 string from the input. Set offsets\n-            --  for the two bytes. For UTF_16LE we have low order/high order.\n-            --  For UTF_16BE we have high order/low order.\n-\n-            if Scheme = UTF_16LE then\n-               L := 0;\n-               H := 1;\n-            else\n-               L := 1;\n-               H := 0;\n-            end if;\n-\n-            --  Loop to convert input to UTF_16 form\n-\n-            Ptr := Item'First;\n-            Iptr := 1;\n-            while Ptr < Item'Last loop\n-               Input_UTF16 (Iptr) :=\n-                 Wide_Character'Val\n-                   (Unsigned_16 (To_Unsigned_8 (Item (Ptr + L)))\n-                      or\n-                    Shift_Left\n-                      (Unsigned_16 (To_Unsigned_8 (Item (Ptr + H))), 8));\n-               Iptr := Iptr + 1;\n-               Ptr := Ptr + 2;\n-            end loop;\n+      if Item'Length >= 2 then\n+         if Item (Item'First .. Item'First + 1) = BOM_16BE then\n+            return UTF_16BE;\n \n-            --  Result is obtained by converting this UTF_16 input. Note that\n-            --  we rely on this nested call to Decode to skip any BOM present.\n+         elsif Item (Item'First .. Item'First + 1) = BOM_16LE then\n+            return UTF_16LE;\n \n-            return Decode_UTF_16 (Input_UTF16);\n-         end UTF16_XE;\n+         elsif Item'Length >= 3\n+           and then Item (Item'First .. Item'First + 2) = BOM_8\n+         then\n+            return UTF_8;\n+         end if;\n       end if;\n-   end Decode;\n \n-   --  Wide_String input with Wide_Wide_String output (long encodings)\n-\n-   function Decode\n-     (Item   : Wide_String;\n-      Scheme : Long_Encoding := UTF_16) return Wide_String\n-   is\n-      pragma Unreferenced (Scheme);\n-   begin\n-      return Decode_UTF_16 (Item);\n-   end Decode;\n+      return Default;\n+   end Encoding;\n \n-   --  Wide_String input with Wide_Wide_String output (long encodings)\n+   -----------------\n+   -- From_UTF_16 --\n+   -----------------\n \n-   function Decode\n-     (Item   : Wide_String;\n-      Scheme : Long_Encoding := UTF_16) return Wide_Wide_String\n+   function From_UTF_16\n+     (Item          : UTF_16_Wide_String;\n+      Output_Scheme : UTF_XE_Encoding;\n+      Output_BOM    : Boolean := False) return UTF_String\n    is\n-      pragma Unreferenced (Scheme);\n-   begin\n-      return Decode_UTF_16 (Item);\n-   end Decode;\n-\n-   -------------------\n-   -- Decode_UTF_16 --\n-   -------------------\n-\n-   --  Version returning Wide_String result\n-\n-   function Decode_UTF_16 (Item : Wide_String) return Wide_String is\n-      Result : Wide_String (1 .. Item'Length);\n-      --  Result is same length as input (possibly minus 1 if BOM present)\n-\n-      Len : Natural := 0;\n-      --  Length of result\n-\n-      Cod : Unsigned_16;\n-      J   : Positive;\n+      BSpace : constant Natural := 2 * Boolean'Pos (Output_BOM);\n+      Result : UTF_String (1 .. 2 * Item'Length + BSpace);\n+      Len    : Natural;\n+      C      : Unsigned_16;\n+      Iptr   : Natural;\n \n    begin\n-      --  Skip UTF-16 BOM at start\n-\n-      J := Item'First;\n-\n-      if J <= Item'Last and then Item (J) = BOM_16 (1) then\n-         J := J + 1;\n+      if Output_BOM then\n+         Result (1 .. 2) :=\n+           (if Output_Scheme = UTF_16BE then BOM_16BE else BOM_16LE);\n+         Len := 2;\n+      else\n+         Len := 0;\n       end if;\n \n-      --  Loop through input characters\n-\n-      while J <= Item'Last loop\n-         Cod := To_Unsigned_16 (Item (J));\n-\n-         --  Codes in the range 16#0000#..16#D7FF# or 16#E000#..16#FFFF#\n-         --  represent their own value.\n-\n-         if Cod <= 16#D7FF# or else Cod >= 16#E000# then\n-            Len := Len + 1;\n-            Result (Len) := Wide_Character'Val (Cod);\n-\n-         --  Codes in the range 16#D800#..16#DBFF# represent the first of the\n-         --  two surrogates used to encode the range 16#01_000#..16#10_FFFF\".\n-         --  Such codes are out of range for 16-bit output.\n+      --  Skip input BOM\n \n-         --  The remaining case of input in the range 16#DC00#..16#DFFF# must\n-         --  never occur, since it means we have a second surrogate character\n-         --  with no corresponding first surrogate.\n+      Iptr := Item'First;\n \n-         --  Thus all remaining codes are invalid\n-\n-         else\n-            Raise_Encoding_Error;\n-         end if;\n-\n-         J := J + 1;\n-      end loop;\n-\n-      return Result (1 .. Len);\n-   end Decode_UTF_16;\n-\n-   --  Version returning Wide_Wide_String result\n-\n-   function Decode_UTF_16 (Item : Wide_String) return Wide_Wide_String is\n-      Result : Wide_Wide_String (1 .. Item'Length);\n-      --  Result cannot be longer than the input string\n-\n-      Len : Natural := 0;\n-      --  Length of result\n-\n-      Cod  : Unsigned_16;\n-      J    : Positive;\n-      Rcod : Unsigned_32;\n-\n-   begin\n-      --  Skip UTF-16 BOM at start\n-\n-      J := Item'First;\n-\n-      if J <= Item'Last and then Item (J) = BOM_16 (1) then\n-         J := J + 1;\n+      if Iptr <= Item'Last and then Item (Iptr) = BOM_16 (1) then\n+         Iptr := Iptr + 1;\n       end if;\n \n-      --  Loop through input characters\n-\n-      while J <= Item'Last loop\n-         Cod := To_Unsigned_16 (Item (J));\n-\n-         --  Codes in the range 16#0000#..16#D7FF# or 16#E000#..16#FFFF#\n-         --  represent their own value.\n-\n-         if Cod <= 16#D7FF# or else Cod >= 16#E000# then\n-            Len := Len + 1;\n-            Result (Len) := Wide_Wide_Character'Val (Cod);\n-\n-         --  Codes in the range 16#D800#..16#DBFF# represent the first of the\n-         --  two surrogates used to encode the range 16#01_000#..16#10_FFFF\".\n-\n-         elsif Cod <= 16#DBFF# then\n-            Rcod := (Unsigned_32 (Cod) - 16#D800#) * 2 ** 10;\n-\n-            --  Error if at end of string\n-\n-            if J = Item'Last then\n-               Raise_Encoding_Error;\n+      --  UTF-16BE case\n \n-            --  Otherwise next character must be valid low order surrogate\n+      if Output_Scheme = UTF_16BE then\n+         while Iptr <= Item'Last loop\n+            C := To_Unsigned_16 (Item (Iptr));\n+            Result (Len + 1) := Character'Val (Shift_Right (C, 8));\n+            Result (Len + 2) := Character'Val (C and 16#00_FF#);\n+            Len := Len + 2;\n+            Iptr := Iptr + 1;\n+         end loop;\n \n-            else\n-               J := J + 1;\n-               Cod := To_Unsigned_16 (Item (J));\n-\n-               if Cod < 16#DC00# or else Cod > 16#DFFF# then\n-                  Raise_Encoding_Error;\n-\n-               else\n-                  Rcod := Rcod + (Unsigned_32 (Cod) mod 2 ** 10) + 16#01_0000#;\n-                  Len := Len + 1;\n-                  Result (Len) := Wide_Wide_Character'Val (Rcod);\n-               end if;\n-            end if;\n-\n-         --  If input is in the range 16#DC00#..16#DFFF#, we have a second\n-         --  surrogate character with no corresponding first surrogate.\n+      --  UTF-16LE case\n \n-         else\n-            Raise_Encoding_Error;\n-         end if;\n-\n-         J := J + 1;\n-      end loop;\n+      else\n+         while Iptr <= Item'Last loop\n+            C := To_Unsigned_16 (Item (Iptr));\n+            Result (Len + 1) := Character'Val (C and 16#00_FF#);\n+            Result (Len + 2) := Character'Val (Shift_Right (C, 8));\n+            Len := Len + 2;\n+            Iptr := Iptr + 1;\n+         end loop;\n+      end if;\n \n       return Result (1 .. Len);\n-   end Decode_UTF_16;\n-\n-   ------------------\n-   -- Decode_UTF_8 --\n-   ------------------\n-\n-   --  Version returning Wide_String result\n+   end From_UTF_16;\n \n-   function Decode_UTF_8 (Item : String) return Wide_String is\n-      Result : Wide_String (1 .. Item'Length);\n-      --  Result string (worst case is same length as input)\n-\n-      Len : Natural := 0;\n-      --  Length of result stored so far\n-\n-      Ptr : Natural;\n-      --  Input string pointer\n-\n-      C : Unsigned_8;\n-      R : Unsigned_16;\n-\n-      procedure Get_Continuation;\n-      --  Reads a continuation byte of the form 10xxxxxx, shifts R left\n-      --  by 6 bits, and or's in the xxxxxx to the low order 6 bits. On\n-      --  return Ptr is incremented. Raises exceptioon if continuation\n-      --  byte does not exist or is invalid.\n-\n-      ----------------------\n-      -- Get_Continuation --\n-      ----------------------\n-\n-      procedure Get_Continuation is\n-      begin\n-         if Ptr > Item'Last then\n-            Raise_Encoding_Error;\n-\n-         else\n-            C := To_Unsigned_8 (Item (Ptr));\n-            Ptr := Ptr + 1;\n+   --------------------------\n+   -- Raise_Encoding_Error --\n+   --------------------------\n \n-            if C < 2#10_000000# or else C > 2#10_111111# then\n-               Raise_Encoding_Error;\n+   procedure Raise_Encoding_Error (Index : Natural) is\n+      Val : constant String := Index'Img;\n+   begin\n+      raise Encoding_Error with\n+        \"bad input at Item (\" & Val (Val'First + 1 .. Val'Last) & ')';\n+   end Raise_Encoding_Error;\n \n-            else\n-               R := Shift_Left (R, 6) or\n-                      Unsigned_16 (C and 2#00_111111#);\n-            end if;\n-         end if;\n-      end Get_Continuation;\n+   ---------------\n+   -- To_UTF_16 --\n+   ---------------\n \n-   --  Start of processing for Decode_UTF_8\n+   function To_UTF_16\n+     (Item         : UTF_String;\n+      Input_Scheme : UTF_XE_Encoding;\n+      Output_BOM   : Boolean := False) return UTF_16_Wide_String\n+   is\n+      Result : UTF_16_Wide_String (1 .. Item'Length / 2 + 1);\n+      Len    : Natural;\n+      Iptr   : Natural;\n \n    begin\n-      Ptr := Item'First;\n-\n-      --  Skip BOM at start\n-\n-      if Ptr + 2 <= Item'Last\n-        and then Item (Ptr .. Ptr + 2) = BOM_8\n-      then\n-         Ptr := Ptr + 3;\n+      if Item'Length mod 2 /= 0 then\n+         raise Encoding_Error with \"UTF-16BE/LE string has odd length\";\n       end if;\n \n-      --  Loop through input characters\n-\n-      while Ptr <= Item'Last loop\n-         C := To_Unsigned_8 (Item (Ptr));\n-         Ptr := Ptr + 1;\n-\n-         --  Codes in the range 16#00# - 16#7F# are represented as\n-         --    0xxxxxxx\n-\n-         if C <= 16#7F# then\n-            R := Unsigned_16 (C);\n-\n-         --  No initial code can be of the form 10xxxxxx. Such codes are used\n-         --  only for continuations.\n-\n-         elsif C <= 2#10_111111# then\n-            Raise_Encoding_Error;\n-\n-         --  Codes in the range 16#80# - 16#7FF# are represented as\n-         --    110yyyxx 10xxxxxx\n-\n-         elsif C <= 2#110_11111# then\n-            R := Unsigned_16 (C and 2#000_11111#);\n-            Get_Continuation;\n-\n-         --  Codes in the range 16#800# - 16#FFFF# are represented as\n-         --    1110yyyy 10yyyyxx 10xxxxxx\n-\n-         elsif C <= 2#1110_1111# then\n-            R := Unsigned_16 (C and 2#0000_1111#);\n-            Get_Continuation;\n-            Get_Continuation;\n-\n-         --  Codes in the range 16#10000# - 16#10FFFF# are represented as\n-         --    11110zzz 10zzyyyy 10yyyyxx 10xxxxxx\n-\n-         --  Such codes are out of range for Wide_String output\n-\n-         else\n-            Raise_Encoding_Error;\n-         end if;\n-\n-         Len := Len + 1;\n-         Result (Len) := Wide_Character'Val (R);\n-      end loop;\n-\n-      return Result (1 .. Len);\n-   end Decode_UTF_8;\n-\n-   --  Version returning Wide_Wide_String result\n-\n-   function Decode_UTF_8 (Item : String) return Wide_Wide_String is\n-      Result : Wide_Wide_String (1 .. Item'Length);\n-      --  Result string (worst case is same length as input)\n-\n-      Len : Natural := 0;\n-      --  Length of result stored so far\n-\n-      Ptr : Natural;\n-      --  Input string pointer\n-\n-      C : Unsigned_8;\n-      R : Unsigned_32;\n+      --  Deal with input BOM, skip if OK, error if bad BOM\n \n-      procedure Get_Continuation;\n-      --  Reads a continuation byte of the form 10xxxxxx, shifts R left\n-      --  by 6 bits, and or's in the xxxxxx to the low order 6 bits. On\n-      --  return Ptr is incremented. Raises exceptioon if continuation\n-      --  byte does not exist or is invalid.\n-\n-      ----------------------\n-      -- Get_Continuation --\n-      ----------------------\n-\n-      procedure Get_Continuation is\n-      begin\n-         if Ptr > Item'Last then\n-            raise Encoding_Error with\n-              \"incomplete UTF-8 encoding sequence\";\n-\n-         else\n-            C := To_Unsigned_8 (Item (Ptr));\n-            Ptr := Ptr + 1;\n-\n-            if C < 2#10_000000# or else C > 2#10_111111# then\n-               Raise_Encoding_Error;\n+      Iptr := Item'First;\n \n+      if Item'Length >= 2 then\n+         if Item (Iptr .. Iptr + 1) = BOM_16BE then\n+            if Input_Scheme = UTF_16BE then\n+               Iptr := Iptr + 2;\n             else\n-               R := Shift_Left (R, 6) or\n-                 Unsigned_32 (C and 2#00_111111#);\n+               Raise_Encoding_Error (Iptr);\n             end if;\n-         end if;\n-      end Get_Continuation;\n-\n-   --  Start of processing for UTF8_Decode\n-\n-   begin\n-      Ptr := Item'First;\n-\n-      --  Skip BOM at start\n-\n-      if Ptr + 2 <= Item'Last\n-        and then Item (Ptr .. Ptr + 2) = BOM_8\n-      then\n-         Ptr := Ptr + 3;\n-      end if;\n-\n-      --  Loop through input characters\n-\n-      while Ptr <= Item'Last loop\n-         C := To_Unsigned_8 (Item (Ptr));\n-         Ptr := Ptr + 1;\n-\n-         --  Codes in the range 16#00# - 16#7F# are represented as\n-         --    0xxxxxxx\n \n-         if C <= 16#7F# then\n-            R := Unsigned_32 (C);\n-\n-         --  No initial code can be of the form 10xxxxxx. Such codes are used\n-         --  only for continuations.\n-\n-         elsif C <= 2#10_111111# then\n-            Raise_Encoding_Error;\n-\n-         --  Codes in the range 16#80# - 16#7FF# are represented as\n-         --    110yyyxx 10xxxxxx\n-\n-         elsif C <= 2#110_11111# then\n-            R := Unsigned_32 (C and 2#000_11111#);\n-            Get_Continuation;\n-\n-         --  Codes in the range 16#800# - 16#FFFF# are represented as\n-         --    1110yyyy 10yyyyxx 10xxxxxx\n-\n-         elsif C <= 2#1110_1111# then\n-            R := Unsigned_32 (C and 2#0000_1111#);\n-            Get_Continuation;\n-            Get_Continuation;\n-\n-         --  Codes in the range 16#10000# - 16#10FFFF# are represented as\n-         --    11110zzz 10zzyyyy 10yyyyxx 10xxxxxx\n-\n-         elsif C <= 2#11110_111# then\n-            R := Unsigned_32 (C and 2#00000_111#);\n-            Get_Continuation;\n-            Get_Continuation;\n-            Get_Continuation;\n-\n-         --  Any other code is an error\n-\n-         else\n-            Raise_Encoding_Error;\n-         end if;\n-\n-         Len := Len + 1;\n-         Result (Len) := Wide_Wide_Character'Val (R);\n-      end loop;\n-\n-      return Result (1 .. Len);\n-   end Decode_UTF_8;\n-\n-   ------------\n-   -- Encode --\n-   ------------\n-\n-   --  Version with Wide_String input returning encoded String\n-\n-   function Encode\n-     (Item   : Wide_String;\n-      Scheme : Short_Encoding := UTF_8) return String\n-   is\n-   begin\n-      --  Case of UTF_8\n-\n-      if Scheme = UTF_8 then\n-         return Encode_UTF_8 (Item);\n-\n-      --  Case of UTF_16LE or UTF_16BE\n-\n-      else\n-         UTF16XE_Encode : declare\n-            UTF16_Str : constant Wide_String := Encode_UTF_16 (Item);\n-            Result    : String (1 .. 2 * UTF16_Str'Last);\n-\n-            H, L : Integer range -1 .. 0;\n-            --  Offset for high and low order bytes\n-\n-            C : Unsigned_16;\n-            --  One UTF_16 output value\n-\n-         begin\n-            --  Set proper byte offsets\n-\n-            --  Set the byte order for the two bytes of each UTF_16 input code.\n-            --  For UTF_16LE we have low order/high order. For UTF_16BE we have\n-            --  high order/low order.\n-\n-            if Scheme = UTF_16LE then\n-               L := -1;\n-               H := 0;\n+         elsif Item (Iptr .. Iptr + 1) = BOM_16LE then\n+            if Input_Scheme = UTF_16LE then\n+               Iptr := Iptr + 2;\n             else\n-               L := 0;\n-               H := -1;\n+               Raise_Encoding_Error (Iptr);\n             end if;\n \n-            --  Now copy the UTF_16 string to the result string\n-\n-            pragma Warnings (Off);\n-            for J in 1 .. UTF16_Str'Last loop\n-               C := To_Unsigned_16 (UTF16_Str (J));\n-               Result (2 * J + L) := Character'Val (C and 16#FF#);\n-               Result (2 * J + H) := Character'Val (Shift_Right (C, 8));\n-            end loop;\n-\n-            return Result;\n-         end UTF16XE_Encode;\n+         elsif Item'Length >= 3 and then Item (Iptr .. Iptr + 2) = BOM_8 then\n+            Raise_Encoding_Error (Iptr);\n+         end if;\n       end if;\n-   end Encode;\n \n-   --  Version with Wide_Wide_String input returning String\n-\n-   function Encode\n-     (Item   : Wide_Wide_String;\n-      Scheme : Short_Encoding := UTF_8) return String\n-   is\n-   begin\n-      --  Case of UTF_8\n-\n-      if Scheme = UTF_8 then\n-         return Encode_UTF_8 (Item);\n-\n-      --  Case of UTF_16LE or UTF_16BE\n+      --  Output BOM if specified\n \n+      if Output_BOM then\n+         Result (1) := BOM_16 (1);\n+         Len := 1;\n       else\n-         UTF16XE_Encode : declare\n-            UTF16_Str : constant Wide_String := Encode (Item, UTF_16);\n-            Result    : String (1 .. 2 * UTF16_Str'Last);\n-\n-            H, L : Integer range -1 .. 0;\n-            --  Offset for high and low order bytes\n-\n-            C : Unsigned_16;\n-            --  One UTF_16 output value\n-\n-         begin\n-            --  Set proper byte offsets\n-\n-            --  Set the byte order for the two bytes of each UTF_16 input code.\n-            --  For UTF_16LE we have low order/high order. For UTF_16BE we have\n-            --  high order/low order.\n-\n-            if Scheme = UTF_16LE then\n-               L := -1;\n-               H := 0;\n-            else\n-               L := 0;\n-               H := -1;\n-            end if;\n-\n-            --  Now copy the UTF_16 string to the result string\n-\n-            for J in 1 .. UTF16_Str'Last loop\n-               C := To_Unsigned_16 (UTF16_Str (J));\n-               Result (2 * J + L) := Character'Val (C and 16#FF#);\n-               Result (2 * J + H) := Character'Val (Shift_Right (C, 8));\n-            end loop;\n-\n-            return Result;\n-         end UTF16XE_Encode;\n+         Len := 0;\n       end if;\n-   end Encode;\n-\n-   --  Wide_String input returning encoded Wide_String (long encodings)\n-\n-   function Encode\n-     (Item   : Wide_String;\n-      Scheme : Long_Encoding := UTF_16) return Wide_String\n-   is\n-      pragma Unreferenced (Scheme);\n-   begin\n-      return Encode_UTF_16 (Item);\n-   end Encode;\n-\n-   --  Wide_Wide_String input returning Wide_String (long encodings)\n-\n-   function Encode\n-     (Item   : Wide_Wide_String;\n-      Scheme : Long_Encoding := UTF_16) return Wide_String\n-   is\n-      pragma Unreferenced (Scheme);\n-   begin\n-      return Encode_UTF_16 (Item);\n-   end Encode;\n-\n-   -------------------\n-   -- Encode_UTF_16 --\n-   -------------------\n-\n-   --  Wide_String input with UTF-16 encoded Wide_String output\n-\n-   function Encode_UTF_16 (Item : Wide_String) return Wide_String is\n-      Result : Wide_String (1 .. Item'Length);\n-      --  Output is same length as input (we do not add a BOM!)\n-\n-      Len : Integer := 0;\n-      --  Length of output string\n-\n-      Cod : Unsigned_16;\n-\n-   begin\n-      --  Loop through input characters encoding them\n-\n-      for J in Item'Range loop\n-         Cod := To_Unsigned_16 (Item (J));\n-\n-         --  Codes in the range 16#0000#..16#D7FF# are output unchanged\n-\n-         if Cod <= 16#D7FF# then\n-            Len := Len + 1;\n-            Result (Len) := Wide_Character'Val (Cod);\n-\n-         --  Codes in tne range 16#D800#..16#DFFF# should never appear in the\n-         --  input, since no valid Unicode characters are in this range (which\n-         --  would conflict with the UTF-16 surrogate encodings).\n-\n-         elsif Cod <= 16#DFFF# then\n-            raise Constraint_Error with\n-              \"Wide_Character in range 16#D800# .. 16#DFFF#\";\n-\n-         --  Codes in the range 16#E000#..16#FFFF# are output unchanged\n-\n-         else\n-            Len := Len + 1;\n-            Result (Len) := Wide_Character'Val (Cod);\n-         end if;\n-      end loop;\n-\n-      return Result (1 .. Len);\n-   end Encode_UTF_16;\n-\n-   --  Wide_Wide_String input with UTF-16 encoded Wide_String output\n-\n-   function Encode_UTF_16 (Item : Wide_Wide_String) return Wide_String is\n-      Result : Wide_String (1 .. 2 * Item'Length);\n-      --  Worst case is each input character generates two output characters\n-\n-      Len : Integer := 0;\n-      --  Length of output string\n-\n-      Cod : Unsigned_32;\n-\n-   begin\n-      --  Loop through input characters encoding them\n-\n-      for J in Item'Range loop\n-         Cod := To_Unsigned_32 (Item (J));\n-\n-         --  Codes in the range 16#00_0000#..16#00_D7FF# are output unchanged\n-\n-         if Cod <= 16#00_D7FF# then\n-            Len := Len + 1;\n-            Result (Len) := Wide_Character'Val (Cod);\n-\n-         --  Codes in tne range 16#00_D800#..16#00_DFFF# should never appear\n-         --  in the input, since no valid Unicode characters are in this range\n-         --  (which would conflict with the UTF-16 surrogate encodings).\n-\n-         elsif Cod <= 16#00_DFFF# then\n-            raise Constraint_Error with\n-              \"Wide_Wide_Character in range 16#00_D800# .. 16#00_DFFF#\";\n \n-         --  Codes in the range 16#00_E000#..16#00_FFFF# are output unchanged\n+      --  UTF-16BE case\n \n-         elsif Cod <= 16#00_FFFF# then\n+      if Input_Scheme = UTF_16BE then\n+         while Iptr < Item'Last loop\n             Len := Len + 1;\n-            Result (Len) := Wide_Character'Val (Cod);\n+            Result (Len) :=\n+              Wide_Character'Val\n+                (Character'Pos (Item (Iptr)) * 256 +\n+                   Character'Pos (Item (Iptr + 1)));\n+            Iptr := Iptr + 2;\n+         end loop;\n \n-         --  Codes in the range 16#01_0000#..16#10_FFFF# are output using two\n-         --  surrogate characters. First 16#1_0000# is subtracted from the code\n-         --  point to give a 20-bit value. This is then split into two separate\n-         --  10-bit values each of which is represented as a surrogate with the\n-         --  most significant half placed in the first surrogate. To allow safe\n-         --  use of simple word-oriented string processing, separate ranges of\n-         --  values are used for the two surrogates: 16#D800#-16#DBFF# for the\n-         --  first, most significant surrogate and 16#DC00#-16#DFFF# for the\n-         --  second, least significant surrogate.\n+      --  UTF-16LE case\n \n-         elsif Cod <= 16#10_FFFF# then\n-            Cod := Cod - 16#1_0000#;\n-\n-            Len := Len + 1;\n-            Result (Len) := Wide_Character'Val (16#D800# + Cod / 2 ** 10);\n-\n-            Len := Len + 1;\n-            Result (Len) := Wide_Character'Val (16#DC00# + Cod mod 2 ** 10);\n-\n-         --  Codes larger than 16#10_FFFF# are invalid\n-\n-         else\n-            raise Constraint_Error with\n-              \"Wide_Wide_Character exceeds maximum value of 16#10_FFFF#\";\n-         end if;\n-      end loop;\n-\n-      return Result (1 .. Len);\n-   end Encode_UTF_16;\n-\n-   ------------------\n-   -- Encode_UTF_8 --\n-   ------------------\n-\n-   --  Wide_String input with UTF_8 encoded String output\n-\n-   function Encode_UTF_8 (Item : Wide_String) return String is\n-      Result : String (1 .. 3 * Item'Length);\n-      --  Worst case is three bytes per input byte\n-\n-      N : Natural := 0;\n-      --  Number of output codes stored in Result\n-\n-      C : Unsigned_16;\n-      --  Single input character\n-\n-      procedure Store (C : Unsigned_16);\n-      pragma Inline (Store);\n-      --  Store one output code, C is in the range 0 .. 255\n-\n-      -----------\n-      -- Store --\n-      -----------\n-\n-      procedure Store (C : Unsigned_16) is\n-      begin\n-         N := N + 1;\n-         Result (N) := Character'Val (C);\n-      end Store;\n-\n-   --  Start of processing for UTF8_Encode\n-\n-   begin\n-      --  Loop through characters of input\n-\n-      for J in Item'Range loop\n-         C := To_Unsigned_16 (Item (J));\n-\n-         --  Codes in the range 16#00# - 16#7F# are represented as\n-         --    0xxxxxxx\n-\n-         if C <= 16#7F# then\n-            Store (C);\n-\n-         --  Codes in the range 16#80# - 16#7FF# are represented as\n-         --    110yyyxx 10xxxxxx\n-\n-         elsif C <= 16#7FF# then\n-            Store (2#110_00000# or Shift_Right (C, 6));\n-            Store (2#10_000000# or (C and 2#00_111111#));\n-\n-         --  Codes in the range 16#800# - 16#FFFF# are represented as\n-         --    1110yyyy 10yyyyxx 10xxxxxx\n-\n-         else\n-            Store (2#1110_0000# or Shift_Right (C, 12));\n-            Store (2#10_000000# or\n-                     Shift_Right (C and 2#111111_000000#, 6));\n-            Store (2#10_000000# or (C and 2#00_111111#));\n-         end if;\n-      end loop;\n-\n-      return Result (1 .. N);\n-   end Encode_UTF_8;\n-\n-   --  Wide_Wide_String input with UTF_8 encoded String output\n-\n-   function Encode_UTF_8 (Item : Wide_Wide_String) return String is\n-      Result : String (1 .. 4 * Item'Length);\n-      --  Worst case is four bytes per input byte\n-\n-      N  : Natural := 0;\n-      --  Number of output codes stored in Result\n-\n-      C : Unsigned_32;\n-      --  Single input character\n-\n-      procedure Store (C : Unsigned_32);\n-      pragma Inline (Store);\n-      --  Store one output code (input is in range 0 .. 255)\n-\n-      -----------\n-      -- Store --\n-      -----------\n-\n-      procedure Store (C : Unsigned_32) is\n-      begin\n-         N := N + 1;\n-         Result (N) := Character'Val (C);\n-      end Store;\n-\n-   --  Start of processing for UTF8_Encode\n-\n-   begin\n-      --  Loop through characters of input\n-\n-      for J in Item'Range loop\n-         C := To_Unsigned_32 (Item (J));\n-\n-         --  Codes in the range 16#00# - 16#7F# are represented as\n-         --    0xxxxxxx\n-\n-         if C <= 16#7F# then\n-            Store (C);\n-\n-         --  Codes in the range 16#80# - 16#7FF# are represented as\n-         --    110yyyxx 10xxxxxx\n-\n-         elsif C <= 16#7FF# then\n-            Store (2#110_00000# or Shift_Right (C, 6));\n-            Store (2#10_000000# or (C and 2#00_111111#));\n-\n-         --  Codes in the range 16#800# - 16#FFFF# are represented as\n-         --    1110yyyy 10yyyyxx 10xxxxxx\n-\n-         elsif C <= 16#FFFF# then\n-            Store (2#1110_0000# or Shift_Right (C, 12));\n-            Store (2#10_000000# or\n-                     Shift_Right (C and 2#111111_000000#, 6));\n-            Store (2#10_000000# or (C and 2#00_111111#));\n-\n-         --  Codes in the range 16#10000# - 16#10FFFF# are represented as\n-         --    11110zzz 10zzyyyy 10yyyyxx 10xxxxxx\n-\n-         elsif C <= 16#10_FFFF# then\n-            Store (2#11110_000# or Shift_Right (C, 18));\n-            Store (2#10_000000# or\n-                     Shift_Right (C and 2#111111_000000_000000#, 12));\n-            Store (2#10_000000#\n-                   or Shift_Right (C and 2#111111_000000#, 6));\n-            Store (2#10_000000# or (C and 2#00_111111#));\n-\n-         --  Codes higher than 16#10_FFFF# should not appear\n-\n-         else\n-            raise Constraint_Error with\n-              \"out of range invalid value in Encode input\";\n-         end if;\n-      end loop;\n-\n-      return Result (1 .. N);\n-   end Encode_UTF_8;\n-\n-   --------------\n-   -- Encoding --\n-   --------------\n-\n-   --  Version taking String input\n-\n-   function Encoding (Item : String) return Encoding_Scheme is\n-   begin\n-      if Item'Length >= 2 then\n-         if Item (Item'First .. Item'First + 1) = BOM_16BE then\n-            return UTF_16BE;\n-\n-         elsif Item (Item'First .. Item'First + 1) = BOM_16LE then\n-            return UTF_16LE;\n-\n-         elsif Item'Length >= 3\n-           and then Item (Item'First .. Item'First + 2) = BOM_8\n-         then\n-            return UTF_8;\n-         end if;\n-      end if;\n-\n-      return UTF_None;\n-   end Encoding;\n-\n-   --  Version taking Wide_String input\n-\n-   function Encoding (Item : Wide_String) return Encoding_Scheme is\n-   begin\n-      if Item'Length >= 1\n-        and then Item (Item'First .. Item'First) = BOM_16\n-      then\n-         return UTF_16;\n       else\n-         return UTF_None;\n+         while Iptr < Item'Last loop\n+            Len := Len + 1;\n+            Result (Len) :=\n+              Wide_Character'Val\n+                (Character'Pos (Item (Iptr)) +\n+                 Character'Pos (Item (Iptr + 1)) * 256);\n+            Iptr := Iptr + 2;\n+         end loop;\n       end if;\n-   end Encoding;\n \n-   ------------------------\n-   -- Raise_Encoding_Error --\n-   ------------------------\n-\n-   procedure Raise_Encoding_Error is\n-   begin\n-      raise Encoding_Error with \"invalid input encoding sequence\";\n-   end Raise_Encoding_Error;\n+      return Result (1 .. Len);\n+   end To_UTF_16;\n \n end Ada.Strings.UTF_Encoding;"}, {"sha": "5299c6f88e238a0dae5a1744c27f75d0f7e8902b", "filename": "gcc/ada/a-stuten.ads", "status": "modified", "additions": 110, "deletions": 81, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fa-stuten.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fa-stuten.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stuten.ads?ref=6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5", "patch": "@@ -7,111 +7,140 @@\n --                                 S p e c                                  --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT.  In accordance with the copyright of that document, you can freely --\n--- copy and modify this specification,  provided that if you redistribute a --\n--- modified version,  any changes that you have made are clearly indicated. --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is the Ada 2012 package defined in AI05-0137-1. It is used for\n---  encoding strings using UTF encodings (UTF-8, UTF-16LE, UTF-16BE, UTF-16).\n-\n---  Compared with version 05 of the AI, we have added routines for UTF-16\n---  encoding and decoding of wide strings, which seems missing from the AI,\n---  added comments, and reordered the declarations.\n+--  This is one of the Ada 2012 package defined in AI05-0137-1. It is a parent\n+--  package that contains declarations used in the child packages for handling\n+--  UTF encoded strings. Note: this package is consistent with Ada 95, and may\n+--  be used in Ada 95 or Ada 2005 mode.\n \n---  Note: although this is an Ada 2012 package, the earlier versions of the\n---  language permit the addition of new grandchildren of Ada, so we are able\n---  to add this package unconditionally for use in Ada 2005 mode. We cannot\n---  allow it in earlier versions, since it requires Wide_Wide_Character/String.\n+with Interfaces;\n+with Unchecked_Conversion;\n \n package Ada.Strings.UTF_Encoding is\n    pragma Pure (UTF_Encoding);\n \n-   type Encoding_Scheme is (UTF_None, UTF_8, UTF_16BE, UTF_16LE, UTF_16);\n+   subtype UTF_String is String;\n+   --  Used to represent a string of 8-bit values containing a sequence of\n+   --  values encoded in one of three ways (UTF-8, UTF-16BE, or UTF-16LE).\n+   --  Typically used in connection with a Scheme parameter indicating which\n+   --  of the encodings applies. This is not strictly a String value in the\n+   --  sense defined in the Ada RM, but in practice type String accomodates\n+   --  all possible 256 codes, and can be used to hold any sequence of 8-bit\n+   --  codes. We use String directly rather than create a new type so that\n+   --  all existing facilities for manipulating type String (e.g. the child\n+   --  packages of Ada.Strings) are available for manipulation of UTF_Strings.\n+\n+   type Encoding_Scheme is (UTF_8, UTF_16BE, UTF_16LE);\n+   --  Used to specify which of three possible encodings apply to a UTF_String\n+\n+   subtype UTF_8_String is String;\n+   --  Similar to UTF_String but specifically represents a UTF-8 encoded string\n+\n+   subtype UTF_16_Wide_String is Wide_String;\n+   --  This is similar to UTF_8_String but is used to represent a Wide_String\n+   --  value which is a sequence of 16-bit values encoded using UTF-16. Again\n+   --  this is not strictly a Wide_String in the sense of the Ada RM, but the\n+   --  type Wide_String can be used to represent a sequence of arbitrary 16-bit\n+   --  values, and it is more convenient to use Wide_String than a new type.\n \n-   subtype Short_Encoding is Encoding_Scheme range UTF_8 .. UTF_16LE;\n-   subtype Long_Encoding  is Encoding_Scheme range UTF_16 .. UTF_16;\n+   Encoding_Error : exception;\n+   --  This exception is raised in the following situations:\n+   --    a) A UTF encoded string contains an invalid encoding sequence\n+   --    b) A UTF-16BE or UTF-16LE input string has an odd length\n+   --    c) An incorrect character value is present in the Input string\n+   --    d) The result for a Wide_Character output exceeds 16#FFFF#\n+   --  The exception message has the index value where the error occurred.\n \n    --  The BOM (BYTE_ORDER_MARK) values defined here are used at the start of\n    --  a string to indicate the encoding. The convention in this package is\n-   --  that decoding routines ignore a BOM, and output of encoding routines\n-   --  does not include a BOM. If you want to include a BOM in the output,\n-   --  you simply concatenate the appropriate value at the start of the string.\n+   --  that on input a correct BOM is ignored and an incorrect BOM causes an\n+   --  Encoding_Error exception. On output, the output string may or may not\n+   --  include a BOM depending on the setting of Output_BOM.\n \n-   BOM_8    : constant String :=\n+   BOM_8    : constant UTF_8_String :=\n                 Character'Val (16#EF#) &\n                 Character'Val (16#BB#) &\n                 Character'Val (16#BF#);\n \n-   BOM_16BE : constant String :=\n+   BOM_16BE : constant UTF_String :=\n                 Character'Val (16#FE#) &\n                 Character'Val (16#FF#);\n \n-   BOM_16LE : constant String :=\n+   BOM_16LE : constant UTF_String :=\n                 Character'Val (16#FF#) &\n                 Character'Val (16#FE#);\n \n-   BOM_16   : constant Wide_String :=\n+   BOM_16   : constant UTF_16_Wide_String :=\n                 (1 => Wide_Character'Val (16#FEFF#));\n \n-   --  The encoding routines take a wide string or wide wide string as input\n-   --  and encode the result using the specified UTF encoding method. For\n-   --  UTF-16, the output is returned as a Wide_String, this is not a normal\n-   --  Wide_String, since the codes in it may represent UTF-16 surrogate\n-   --  characters used to encode large values. Similarly for UTF-8, UTF-16LE,\n-   --  and UTF-16BE, the output is returned in a String, and again this String\n-   --  is not a standard format string, since it may include UTF-8 surrogates.\n-   --  As previously noted, the returned value does NOT start with a BOM.\n-\n-   --  Note: invalid codes in calls to one of the Encode routines represent\n-   --  invalid values in the sense that they are not defined. For example, the\n-   --  code 16#DC03# is not a valid wide character value. Such values result\n-   --  in undefined behavior. For GNAT, Constraint_Error is raised with an\n-   --  appropriate exception message.\n-\n-   function Encode\n-     (Item   : Wide_String;\n-      Scheme : Short_Encoding := UTF_8) return String;\n-   function Encode\n-     (Item   : Wide_Wide_String;\n-      Scheme : Short_Encoding := UTF_8) return String;\n-\n-   function Encode\n-     (Item   : Wide_String;\n-      Scheme : Long_Encoding := UTF_16) return Wide_String;\n-   function Encode\n-     (Item   : Wide_Wide_String;\n-      Scheme : Long_Encoding := UTF_16) return Wide_String;\n-\n-   --  The decoding routines take a String or Wide_String input which is an\n-   --  encoded string using the specified encoding. The output is a normal\n-   --  Ada Wide_String or Wide_Wide_String value representing the decoded\n-   --  values. Note that a BOM in the input matching the encoding is skipped.\n-\n-   Encoding_Error : exception;\n-   --  Exception raised if an invalid encoding sequence is encountered by\n-   --  one of the Decode routines.\n-\n-   function Decode\n-     (Item   : String;\n-      Scheme : Short_Encoding := UTF_8) return Wide_String;\n-   function Decode\n-     (Item   : String;\n-      Scheme : Short_Encoding := UTF_8) return Wide_Wide_String;\n-\n-   function Decode\n-     (Item   : Wide_String;\n-      Scheme : Long_Encoding := UTF_16) return Wide_String;\n-   function Decode\n-     (Item   : Wide_String;\n-      Scheme : Long_Encoding := UTF_16) return Wide_Wide_String;\n-\n-   --  The Encoding functions inspect an encoded string or wide_string and\n-   --  determine if a BOM is present. If so, the appropriate Encoding_Scheme\n-   --  is returned. If not, then UTF_None is returned.\n-\n-   function Encoding (Item : String)      return Encoding_Scheme;\n-   function Encoding (Item : Wide_String) return Encoding_Scheme;\n+   function Encoding\n+     (Item    : UTF_String;\n+      Default : Encoding_Scheme := UTF_8) return Encoding_Scheme;\n+   --  This function inspects a UTF_String value to determine whether it\n+   --  starts with a BOM for UTF-8, UTF-16BE, or UTF_16LE. If so, the result\n+   --  is the scheme corresponding to the BOM. If no valid BOM is present\n+   --  then the result is the specified Default value.\n+\n+private\n+   function To_Unsigned_8 is new\n+     Unchecked_Conversion (Character, Interfaces.Unsigned_8);\n+\n+   function To_Unsigned_16 is new\n+     Unchecked_Conversion (Wide_Character, Interfaces.Unsigned_16);\n+\n+   function To_Unsigned_32 is new\n+     Unchecked_Conversion (Wide_Wide_Character, Interfaces.Unsigned_32);\n+\n+   subtype UTF_XE_Encoding is Encoding_Scheme range UTF_16BE .. UTF_16LE;\n+   --  Subtype containing only UTF_16BE and UTF_16LE entries\n+\n+   --  Utility routines for converting between UTF-16 and UTF-16LE/BE\n+\n+   function From_UTF_16\n+     (Item          : UTF_16_Wide_String;\n+      Output_Scheme : UTF_XE_Encoding;\n+      Output_BOM    : Boolean := False) return UTF_String;\n+   --  The input string Item is encoded in UTF-16. The output is encoded using\n+   --  Output_Scheme (which is either UTF-16LE or UTF-16BE). There are no error\n+   --  cases. The output starts with BOM_16BE/LE if Output_BOM is True.\n+\n+   function To_UTF_16\n+     (Item          : UTF_String;\n+      Input_Scheme  : UTF_XE_Encoding;\n+      Output_BOM    : Boolean := False) return UTF_16_Wide_String;\n+   --  The input string Item is encoded using Input_Scheme which is either\n+   --  UTF-16LE or UTF-16BE. The output is the corresponding UTF_16 wide\n+   --  string. Encoding error is raised if the length of the input is odd.\n+   --  The output starts with BOM_16 if Output_BOM is True.\n+\n+   procedure Raise_Encoding_Error (Index : Natural);\n+   pragma No_Return (Raise_Encoding_Error);\n+   --  Raise Encoding_Error exception for bad encoding in input item. The\n+   --  parameter Index is the index of the location in Item for the error.\n \n end Ada.Strings.UTF_Encoding;"}, {"sha": "fb7ae76d34ec901536f9efa1ec05665fcfbd4dba", "filename": "gcc/ada/a-stwiun-shared.adb", "status": "added", "additions": 2106, "deletions": 0, "changes": 2106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fa-stwiun-shared.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fa-stwiun-shared.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stwiun-shared.adb?ref=6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5", "patch": "@@ -0,0 +1,2106 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--           A D A . S T R I N G S . W I D E _ U N B O U N D E D            --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Strings.Wide_Search;\n+with Ada.Unchecked_Deallocation;\n+\n+package body Ada.Strings.Wide_Unbounded is\n+\n+   use Ada.Strings.Wide_Maps;\n+\n+   Growth_Factor : constant := 32;\n+   --  The growth factor controls how much extra space is allocated when\n+   --  we have to increase the size of an allocated unbounded string. By\n+   --  allocating extra space, we avoid the need to reallocate on every\n+   --  append, particularly important when a string is built up by repeated\n+   --  append operations of small pieces. This is expressed as a factor so\n+   --  32 means add 1/32 of the length of the string as growth space.\n+\n+   Min_Mul_Alloc : constant := Standard'Maximum_Alignment;\n+   --  Allocation will be done by a multiple of Min_Mul_Alloc. This causes\n+   --  no memory loss as most (all?) malloc implementations are obliged to\n+   --  align the returned memory on the maximum alignment as malloc does not\n+   --  know the target alignment.\n+\n+   procedure Sync_Add_And_Fetch\n+     (Ptr   : access Interfaces.Unsigned_32;\n+      Value : Interfaces.Unsigned_32);\n+   pragma Import (Intrinsic, Sync_Add_And_Fetch, \"__sync_add_and_fetch_4\");\n+\n+   function Sync_Sub_And_Fetch\n+     (Ptr   : access Interfaces.Unsigned_32;\n+      Value : Interfaces.Unsigned_32) return Interfaces.Unsigned_32;\n+   pragma Import (Intrinsic, Sync_Sub_And_Fetch, \"__sync_sub_and_fetch_4\");\n+\n+   function Aligned_Max_Length (Max_Length : Natural) return Natural;\n+   --  Returns recommended length of the shared string which is greater or\n+   --  equal to specified length. Calculation take in sense alignment of\n+   --  the allocated memory segments to use memory effectively by\n+   --  Append/Insert/etc operations.\n+\n+   ---------\n+   -- \"&\" --\n+   ---------\n+\n+   function \"&\"\n+     (Left  : Unbounded_Wide_String;\n+      Right : Unbounded_Wide_String) return Unbounded_Wide_String\n+   is\n+      LR : constant Shared_Wide_String_Access := Left.Reference;\n+      RR : constant Shared_Wide_String_Access := Right.Reference;\n+      DL : constant Natural := LR.Last + RR.Last;\n+      DR : Shared_Wide_String_Access;\n+\n+   begin\n+      --  Result is an empty string, reuse shared empty string.\n+\n+      if DL = 0 then\n+         Reference (Empty_Shared_Wide_String'Access);\n+         DR := Empty_Shared_Wide_String'Access;\n+\n+      --  Left string is empty, return Rigth string.\n+\n+      elsif LR.Last = 0 then\n+         Reference (RR);\n+         DR := RR;\n+\n+      --  Right string is empty, return Left string.\n+\n+      elsif RR.Last = 0 then\n+         Reference (LR);\n+         DR := LR;\n+\n+      --  Overwise, allocate new shared string and fill data.\n+\n+      else\n+         DR := Allocate (LR.Last + RR.Last);\n+         DR.Data (1 .. LR.Last) := LR.Data (1 .. LR.Last);\n+         DR.Data (LR.Last + 1 .. DL) := RR.Data (1 .. RR.Last);\n+         DR.Last := DL;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end \"&\";\n+\n+   function \"&\"\n+     (Left  : Unbounded_Wide_String;\n+      Right : Wide_String) return Unbounded_Wide_String\n+   is\n+      LR : constant Shared_Wide_String_Access := Left.Reference;\n+      DL : constant Natural := LR.Last + Right'Length;\n+      DR : Shared_Wide_String_Access;\n+\n+   begin\n+      --  Result is an empty string, reuse shared empty string.\n+\n+      if DL = 0 then\n+         Reference (Empty_Shared_Wide_String'Access);\n+         DR := Empty_Shared_Wide_String'Access;\n+\n+      --  Right is an empty string, return Left string.\n+\n+      elsif Right'Length = 0 then\n+         Reference (LR);\n+         DR := LR;\n+\n+      --  Otherwise, allocate new shared string and fill it.\n+\n+      else\n+         DR := Allocate (DL);\n+         DR.Data (1 .. LR.Last) := LR.Data (1 .. LR.Last);\n+         DR.Data (LR.Last + 1 .. DL) := Right;\n+         DR.Last := DL;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end \"&\";\n+\n+   function \"&\"\n+     (Left  : Wide_String;\n+      Right : Unbounded_Wide_String) return Unbounded_Wide_String\n+   is\n+      RR : constant Shared_Wide_String_Access := Right.Reference;\n+      DL : constant Natural := Left'Length + RR.Last;\n+      DR : Shared_Wide_String_Access;\n+\n+   begin\n+      --  Result is an empty string, reuse shared one.\n+\n+      if DL = 0 then\n+         Reference (Empty_Shared_Wide_String'Access);\n+         DR := Empty_Shared_Wide_String'Access;\n+\n+      --  Left is empty string, return Right string.\n+\n+      elsif Left'Length = 0 then\n+         Reference (RR);\n+         DR := RR;\n+\n+      --  Otherwise, allocate new shared string and fill it.\n+\n+      else\n+         DR := Allocate (DL);\n+         DR.Data (1 .. Left'Length) := Left;\n+         DR.Data (Left'Length + 1 .. DL) := RR.Data (1 .. RR.Last);\n+         DR.Last := DL;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end \"&\";\n+\n+   function \"&\"\n+     (Left  : Unbounded_Wide_String;\n+      Right : Wide_Character) return Unbounded_Wide_String\n+   is\n+      LR : constant Shared_Wide_String_Access := Left.Reference;\n+      DL : constant Natural := LR.Last + 1;\n+      DR : Shared_Wide_String_Access;\n+\n+   begin\n+      DR := Allocate (DL);\n+      DR.Data (1 .. LR.Last) := LR.Data (1 .. LR.Last);\n+      DR.Data (DL) := Right;\n+      DR.Last := DL;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end \"&\";\n+\n+   function \"&\"\n+     (Left  : Wide_Character;\n+      Right : Unbounded_Wide_String) return Unbounded_Wide_String\n+   is\n+      RR : constant Shared_Wide_String_Access := Right.Reference;\n+      DL : constant Natural := 1 + RR.Last;\n+      DR : Shared_Wide_String_Access;\n+\n+   begin\n+      DR := Allocate (DL);\n+      DR.Data (1) := Left;\n+      DR.Data (2 .. DL) := RR.Data (1 .. RR.Last);\n+      DR.Last := DL;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end \"&\";\n+\n+   ---------\n+   -- \"*\" --\n+   ---------\n+\n+   function \"*\"\n+     (Left  : Natural;\n+      Right : Wide_Character) return Unbounded_Wide_String\n+   is\n+      DR : Shared_Wide_String_Access;\n+\n+   begin\n+      --  Result is an empty string, reuse shared empty string.\n+\n+      if Left = 0 then\n+         Reference (Empty_Shared_Wide_String'Access);\n+         DR := Empty_Shared_Wide_String'Access;\n+\n+      --  Otherwise, allocate new shared string and fill it.\n+\n+      else\n+         DR := Allocate (Left);\n+\n+         for J in 1 .. Left loop\n+            DR.Data (J) := Right;\n+         end loop;\n+\n+         DR.Last := Left;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end \"*\";\n+\n+   function \"*\"\n+     (Left  : Natural;\n+      Right : Wide_String) return Unbounded_Wide_String\n+   is\n+      DL : constant Natural := Left * Right'Length;\n+      DR : Shared_Wide_String_Access;\n+      K  : Positive;\n+\n+   begin\n+      --  Result is an empty string, reuse shared empty string.\n+\n+      if DL = 0 then\n+         Reference (Empty_Shared_Wide_String'Access);\n+         DR := Empty_Shared_Wide_String'Access;\n+\n+      --  Otherwise, allocate new shared string and fill it.\n+\n+      else\n+         DR := Allocate (DL);\n+         K := 1;\n+\n+         for J in 1 .. Left loop\n+            DR.Data (K .. K + Right'Length - 1) := Right;\n+            K := K + Right'Length;\n+         end loop;\n+\n+         DR.Last := DL;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end \"*\";\n+\n+   function \"*\"\n+     (Left  : Natural;\n+      Right : Unbounded_Wide_String) return Unbounded_Wide_String\n+   is\n+      RR : constant Shared_Wide_String_Access := Right.Reference;\n+      DL : constant Natural := Left * RR.Last;\n+      DR : Shared_Wide_String_Access;\n+      K  : Positive;\n+\n+   begin\n+      --  Result is an empty string, reuse shared empty string.\n+\n+      if DL = 0 then\n+         Reference (Empty_Shared_Wide_String'Access);\n+         DR := Empty_Shared_Wide_String'Access;\n+\n+      --  Coefficient is one, just return string itself.\n+\n+      elsif Left = 1 then\n+         Reference (RR);\n+         DR := RR;\n+\n+      --  Otherwise, allocate new shared string and fill it.\n+\n+      else\n+         DR := Allocate (DL);\n+         K := 1;\n+\n+         for J in 1 .. Left loop\n+            DR.Data (K .. K + RR.Last - 1) := RR.Data (1 .. RR.Last);\n+            K := K + RR.Last;\n+         end loop;\n+\n+         DR.Last := DL;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end \"*\";\n+\n+   ---------\n+   -- \"<\" --\n+   ---------\n+\n+   function \"<\"\n+     (Left  : Unbounded_Wide_String;\n+      Right : Unbounded_Wide_String) return Boolean\n+   is\n+      LR : constant Shared_Wide_String_Access := Left.Reference;\n+      RR : constant Shared_Wide_String_Access := Right.Reference;\n+   begin\n+      return LR.Data (1 .. LR.Last) < RR.Data (1 .. RR.Last);\n+   end \"<\";\n+\n+   function \"<\"\n+     (Left  : Unbounded_Wide_String;\n+      Right : Wide_String) return Boolean\n+   is\n+      LR : constant Shared_Wide_String_Access := Left.Reference;\n+   begin\n+      return LR.Data (1 .. LR.Last) < Right;\n+   end \"<\";\n+\n+   function \"<\"\n+     (Left  : Wide_String;\n+      Right : Unbounded_Wide_String) return Boolean\n+   is\n+      RR : constant Shared_Wide_String_Access := Right.Reference;\n+   begin\n+      return Left < RR.Data (1 .. RR.Last);\n+   end \"<\";\n+\n+   ----------\n+   -- \"<=\" --\n+   ----------\n+\n+   function \"<=\"\n+     (Left  : Unbounded_Wide_String;\n+      Right : Unbounded_Wide_String) return Boolean\n+   is\n+      LR : constant Shared_Wide_String_Access := Left.Reference;\n+      RR : constant Shared_Wide_String_Access := Right.Reference;\n+\n+   begin\n+      --  LR = RR means two strings shares shared string, thus they are equal\n+\n+      return LR = RR or else LR.Data (1 .. LR.Last) <= RR.Data (1 .. RR.Last);\n+   end \"<=\";\n+\n+   function \"<=\"\n+     (Left  : Unbounded_Wide_String;\n+      Right : Wide_String) return Boolean\n+   is\n+      LR : constant Shared_Wide_String_Access := Left.Reference;\n+   begin\n+      return LR.Data (1 .. LR.Last) <= Right;\n+   end \"<=\";\n+\n+   function \"<=\"\n+     (Left  : Wide_String;\n+      Right : Unbounded_Wide_String) return Boolean\n+   is\n+      RR : constant Shared_Wide_String_Access := Right.Reference;\n+   begin\n+      return Left <= RR.Data (1 .. RR.Last);\n+   end \"<=\";\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\"\n+     (Left  : Unbounded_Wide_String;\n+      Right : Unbounded_Wide_String) return Boolean\n+   is\n+      LR : constant Shared_Wide_String_Access := Left.Reference;\n+      RR : constant Shared_Wide_String_Access := Right.Reference;\n+\n+   begin\n+      return LR = RR or else LR.Data (1 .. LR.Last) = RR.Data (1 .. RR.Last);\n+      --  LR = RR means two strings shares shared string, thus they are equal.\n+   end \"=\";\n+\n+   function \"=\"\n+     (Left  : Unbounded_Wide_String;\n+      Right : Wide_String) return Boolean\n+   is\n+      LR : constant Shared_Wide_String_Access := Left.Reference;\n+   begin\n+      return LR.Data (1 .. LR.Last) = Right;\n+   end \"=\";\n+\n+   function \"=\"\n+     (Left  : Wide_String;\n+      Right : Unbounded_Wide_String) return Boolean\n+   is\n+      RR : constant Shared_Wide_String_Access := Right.Reference;\n+   begin\n+      return Left = RR.Data (1 .. RR.Last);\n+   end \"=\";\n+\n+   ---------\n+   -- \">\" --\n+   ---------\n+\n+   function \">\"\n+     (Left  : Unbounded_Wide_String;\n+      Right : Unbounded_Wide_String) return Boolean\n+   is\n+      LR : constant Shared_Wide_String_Access := Left.Reference;\n+      RR : constant Shared_Wide_String_Access := Right.Reference;\n+   begin\n+      return LR.Data (1 .. LR.Last) > RR.Data (1 .. RR.Last);\n+   end \">\";\n+\n+   function \">\"\n+     (Left  : Unbounded_Wide_String;\n+      Right : Wide_String) return Boolean\n+   is\n+      LR : constant Shared_Wide_String_Access := Left.Reference;\n+   begin\n+      return LR.Data (1 .. LR.Last) > Right;\n+   end \">\";\n+\n+   function \">\"\n+     (Left  : Wide_String;\n+      Right : Unbounded_Wide_String) return Boolean\n+   is\n+      RR : constant Shared_Wide_String_Access := Right.Reference;\n+   begin\n+      return Left > RR.Data (1 .. RR.Last);\n+   end \">\";\n+\n+   ----------\n+   -- \">=\" --\n+   ----------\n+\n+   function \">=\"\n+     (Left  : Unbounded_Wide_String;\n+      Right : Unbounded_Wide_String) return Boolean\n+   is\n+      LR : constant Shared_Wide_String_Access := Left.Reference;\n+      RR : constant Shared_Wide_String_Access := Right.Reference;\n+\n+   begin\n+      --  LR = RR means two strings shares shared string, thus they are equal\n+\n+      return LR = RR or else LR.Data (1 .. LR.Last) >= RR.Data (1 .. RR.Last);\n+   end \">=\";\n+\n+   function \">=\"\n+     (Left  : Unbounded_Wide_String;\n+      Right : Wide_String) return Boolean\n+   is\n+      LR : constant Shared_Wide_String_Access := Left.Reference;\n+   begin\n+      return LR.Data (1 .. LR.Last) >= Right;\n+   end \">=\";\n+\n+   function \">=\"\n+     (Left  : Wide_String;\n+      Right : Unbounded_Wide_String) return Boolean\n+   is\n+      RR : constant Shared_Wide_String_Access := Right.Reference;\n+   begin\n+      return Left >= RR.Data (1 .. RR.Last);\n+   end \">=\";\n+\n+   ------------\n+   -- Adjust --\n+   ------------\n+\n+   procedure Adjust (Object : in out Unbounded_Wide_String) is\n+   begin\n+      Reference (Object.Reference);\n+   end Adjust;\n+\n+   ------------------------\n+   -- Aligned_Max_Length --\n+   ------------------------\n+\n+   function Aligned_Max_Length (Max_Length : Natural) return Natural is\n+      Static_Size  : constant Natural :=\n+                       Empty_Shared_Wide_String'Size / Standard'Storage_Unit;\n+      --  Total size of all static components\n+\n+      Element_Size : constant Natural :=\n+                       Wide_Character'Size / Standard'Storage_Unit;\n+\n+   begin\n+      return\n+        (((Static_Size + Max_Length * Element_Size - 1) / Min_Mul_Alloc + 2)\n+          * Min_Mul_Alloc - Static_Size) / Element_Size;\n+   end Aligned_Max_Length;\n+\n+   --------------\n+   -- Allocate --\n+   --------------\n+\n+   function Allocate (Max_Length : Natural) return Shared_Wide_String_Access is\n+   begin\n+      --  Empty string requested, return shared empty string\n+\n+      if Max_Length = 0 then\n+         Reference (Empty_Shared_Wide_String'Access);\n+         return Empty_Shared_Wide_String'Access;\n+\n+      --  Otherwise, allocate requested space (and probably some more room)\n+\n+      else\n+         return new Shared_Wide_String (Aligned_Max_Length (Max_Length));\n+      end if;\n+   end Allocate;\n+\n+   ------------\n+   -- Append --\n+   ------------\n+\n+   procedure Append\n+     (Source   : in out Unbounded_Wide_String;\n+      New_Item : Unbounded_Wide_String)\n+   is\n+      SR  : constant Shared_Wide_String_Access := Source.Reference;\n+      NR  : constant Shared_Wide_String_Access := New_Item.Reference;\n+      DL  : constant Natural                   := SR.Last + NR.Last;\n+      DR  : Shared_Wide_String_Access;\n+\n+   begin\n+      --  Source is an empty string, reuse New_Item data\n+\n+      if SR.Last = 0 then\n+         Reference (NR);\n+         Source.Reference := NR;\n+         Unreference (SR);\n+\n+      --  New_Item is empty string, nothing to do\n+\n+      elsif NR.Last = 0 then\n+         null;\n+\n+      --  Try to reuse existent shared string\n+\n+      elsif Can_Be_Reused (SR, DL) then\n+         SR.Data (SR.Last + 1 .. DL) := NR.Data (1 .. NR.Last);\n+         SR.Last := DL;\n+\n+      --  Otherwise, allocate new one and fill it\n+\n+      else\n+         DR := Allocate (DL + DL / Growth_Factor);\n+         DR.Data (1 .. SR.Last) := SR.Data (1 .. SR.Last);\n+         DR.Data (SR.Last + 1 .. DL) := NR.Data (1 .. NR.Last);\n+         DR.Last := DL;\n+         Source.Reference := DR;\n+         Unreference (SR);\n+      end if;\n+   end Append;\n+\n+   procedure Append\n+     (Source   : in out Unbounded_Wide_String;\n+      New_Item : Wide_String)\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+      DL : constant Natural                   := SR.Last + New_Item'Length;\n+      DR : Shared_Wide_String_Access;\n+\n+   begin\n+      --  New_Item is an empty string, nothing to do\n+\n+      if New_Item'Length = 0 then\n+         null;\n+\n+      --  Try to reuse existing shared string\n+\n+      elsif Can_Be_Reused (SR, DL) then\n+         SR.Data (SR.Last + 1 .. DL) := New_Item;\n+         SR.Last := DL;\n+\n+      --  Otherwise, allocate new one and fill it\n+\n+      else\n+         DR := Allocate (DL + DL / Growth_Factor);\n+         DR.Data (1 .. SR.Last) := SR.Data (1 .. SR.Last);\n+         DR.Data (SR.Last + 1 .. DL) := New_Item;\n+         DR.Last := DL;\n+         Source.Reference := DR;\n+         Unreference (SR);\n+      end if;\n+   end Append;\n+\n+   procedure Append\n+     (Source   : in out Unbounded_Wide_String;\n+      New_Item : Wide_Character)\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+      DL : constant Natural := SR.Last + 1;\n+      DR : Shared_Wide_String_Access;\n+\n+   begin\n+      --  Try to reuse existing shared string\n+\n+      if Can_Be_Reused (SR, SR.Last + 1) then\n+         SR.Data (SR.Last + 1) := New_Item;\n+         SR.Last := SR.Last + 1;\n+\n+      --  Otherwise, allocate new one and fill it\n+\n+      else\n+         DR := Allocate (DL + DL / Growth_Factor);\n+         DR.Data (1 .. SR.Last) := SR.Data (1 .. SR.Last);\n+         DR.Data (DL) := New_Item;\n+         DR.Last := DL;\n+         Source.Reference := DR;\n+         Unreference (SR);\n+      end if;\n+   end Append;\n+\n+   -------------------\n+   -- Can_Be_Reused --\n+   -------------------\n+\n+   function Can_Be_Reused\n+     (Item   : Shared_Wide_String_Access;\n+      Length : Natural) return Boolean\n+   is\n+      use Interfaces;\n+   begin\n+      return\n+        Item.Counter = 1\n+          and then Item.Max_Length >= Length\n+          and then Item.Max_Length <=\n+                     Aligned_Max_Length (Length + Length / Growth_Factor);\n+   end Can_Be_Reused;\n+\n+   -----------\n+   -- Count --\n+   -----------\n+\n+   function Count\n+     (Source  : Unbounded_Wide_String;\n+      Pattern : Wide_String;\n+      Mapping : Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n+      return Natural\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+   begin\n+      return Wide_Search.Count (SR.Data (1 .. SR.Last), Pattern, Mapping);\n+   end Count;\n+\n+   function Count\n+     (Source  : Unbounded_Wide_String;\n+      Pattern : Wide_String;\n+      Mapping : Wide_Maps.Wide_Character_Mapping_Function) return Natural\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+   begin\n+      return Wide_Search.Count (SR.Data (1 .. SR.Last), Pattern, Mapping);\n+   end Count;\n+\n+   function Count\n+     (Source : Unbounded_Wide_String;\n+      Set    : Wide_Maps.Wide_Character_Set) return Natural\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+   begin\n+      return Wide_Search.Count (SR.Data (1 .. SR.Last), Set);\n+   end Count;\n+\n+   ------------\n+   -- Delete --\n+   ------------\n+\n+   function Delete\n+     (Source  : Unbounded_Wide_String;\n+      From    : Positive;\n+      Through : Natural) return Unbounded_Wide_String\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+      DL : Natural;\n+      DR : Shared_Wide_String_Access;\n+\n+   begin\n+      --  Empty slice is deleted, use the same shared string\n+\n+      if From > Through then\n+         Reference (SR);\n+         DR := SR;\n+\n+      --  Index is out of range\n+\n+      elsif Through > SR.Last then\n+         raise Index_Error;\n+\n+      --  Compute size of the result\n+\n+      else\n+         DL := SR.Last - (Through - From + 1);\n+\n+         --  Result is an empty string, reuse shared empty string\n+\n+         if DL = 0 then\n+            Reference (Empty_Shared_Wide_String'Access);\n+            DR := Empty_Shared_Wide_String'Access;\n+\n+         --  Otherwise, allocate new shared string and fill it\n+\n+         else\n+            DR := Allocate (DL);\n+            DR.Data (1 .. From - 1) := SR.Data (1 .. From - 1);\n+            DR.Data (From .. DL) := SR.Data (Through + 1 .. SR.Last);\n+            DR.Last := DL;\n+         end if;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end Delete;\n+\n+   procedure Delete\n+     (Source  : in out Unbounded_Wide_String;\n+      From    : Positive;\n+      Through : Natural)\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+      DL : Natural;\n+      DR : Shared_Wide_String_Access;\n+\n+   begin\n+      --  Nothing changed, return\n+\n+      if From > Through then\n+         null;\n+\n+      --  Through is outside of the range\n+\n+      elsif Through > SR.Last then\n+         raise Index_Error;\n+\n+      else\n+         DL := SR.Last - (Through - From + 1);\n+\n+         --  Result is empty, reuse shared empty string\n+\n+         if DL = 0 then\n+            Reference (Empty_Shared_Wide_String'Access);\n+            Source.Reference := Empty_Shared_Wide_String'Access;\n+            Unreference (SR);\n+\n+         --  Try to reuse existent shared string\n+\n+         elsif Can_Be_Reused (SR, DL) then\n+            SR.Data (From .. DL) := SR.Data (Through + 1 .. SR.Last);\n+            SR.Last := DL;\n+\n+         --  Otherwise, allocate new shared string\n+\n+         else\n+            DR := Allocate (DL);\n+            DR.Data (1 .. From - 1) := SR.Data (1 .. From - 1);\n+            DR.Data (From .. DL) := SR.Data (Through + 1 .. SR.Last);\n+            DR.Last := DL;\n+            Source.Reference := DR;\n+            Unreference (SR);\n+         end if;\n+      end if;\n+   end Delete;\n+\n+   -------------\n+   -- Element --\n+   -------------\n+\n+   function Element\n+     (Source : Unbounded_Wide_String;\n+      Index  : Positive) return Wide_Character\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+   begin\n+      if Index <= SR.Last then\n+         return SR.Data (Index);\n+      else\n+         raise Index_Error;\n+      end if;\n+   end Element;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (Object : in out Unbounded_Wide_String) is\n+      SR : constant Shared_Wide_String_Access := Object.Reference;\n+\n+   begin\n+      if SR /= null then\n+\n+         --  The same controlled object can be finalized several times for\n+         --  some reason. As per 7.6.1(24) this should have no ill effect,\n+         --  so we need to add a guard for the case of finalizing the same\n+         --  object twice.\n+\n+         Object.Reference := null;\n+         Unreference (SR);\n+      end if;\n+   end Finalize;\n+\n+   ----------------\n+   -- Find_Token --\n+   ----------------\n+\n+   procedure Find_Token\n+     (Source : Unbounded_Wide_String;\n+      Set    : Wide_Maps.Wide_Character_Set;\n+      Test   : Strings.Membership;\n+      First  : out Positive;\n+      Last   : out Natural)\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+   begin\n+      Wide_Search.Find_Token (SR.Data (1 .. SR.Last), Set, Test, First, Last);\n+   end Find_Token;\n+\n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free (X : in out Wide_String_Access) is\n+      procedure Deallocate is\n+         new Ada.Unchecked_Deallocation (Wide_String, Wide_String_Access);\n+   begin\n+      Deallocate (X);\n+   end Free;\n+\n+   ----------\n+   -- Head --\n+   ----------\n+\n+   function Head\n+     (Source : Unbounded_Wide_String;\n+      Count  : Natural;\n+      Pad    : Wide_Character := Wide_Space) return Unbounded_Wide_String\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+      DR : Shared_Wide_String_Access;\n+\n+   begin\n+      --  Result is empty, reuse shared empty string\n+\n+      if Count = 0 then\n+         Reference (Empty_Shared_Wide_String'Access);\n+         DR := Empty_Shared_Wide_String'Access;\n+\n+      --  Length of the string is the same as requested, reuse source shared\n+      --  string.\n+\n+      elsif Count = SR.Last then\n+         Reference (SR);\n+         DR := SR;\n+\n+      --  Otherwise, allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (Count);\n+\n+         --  Length of the source string is more than requested, copy\n+         --  corresponding slice.\n+\n+         if Count < SR.Last then\n+            DR.Data (1 .. Count) := SR.Data (1 .. Count);\n+\n+         --  Length of the source string is less then requested, copy all\n+         --  contents and fill others by Pad character.\n+\n+         else\n+            DR.Data (1 .. SR.Last) := SR.Data (1 .. SR.Last);\n+\n+            for J in SR.Last + 1 .. Count loop\n+               DR.Data (J) := Pad;\n+            end loop;\n+         end if;\n+\n+         DR.Last := Count;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end Head;\n+\n+   procedure Head\n+     (Source : in out Unbounded_Wide_String;\n+      Count  : Natural;\n+      Pad    : Wide_Character := Wide_Space)\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+      DR : Shared_Wide_String_Access;\n+\n+   begin\n+      --  Result is empty, reuse empty shared string\n+\n+      if Count = 0 then\n+         Reference (Empty_Shared_Wide_String'Access);\n+         Source.Reference := Empty_Shared_Wide_String'Access;\n+         Unreference (SR);\n+\n+      --  Result is same with source string, reuse source shared string\n+\n+      elsif Count = SR.Last then\n+         null;\n+\n+      --  Try to reuse existent shared string\n+\n+      elsif Can_Be_Reused (SR, Count) then\n+         if Count > SR.Last then\n+            for J in SR.Last + 1 .. Count loop\n+               SR.Data (J) := Pad;\n+            end loop;\n+         end if;\n+\n+         SR.Last := Count;\n+\n+      --  Otherwise, allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (Count);\n+\n+         --  Length of the source string is greater then requested, copy\n+         --  corresponding slice.\n+\n+         if Count < SR.Last then\n+            DR.Data (1 .. Count) := SR.Data (1 .. Count);\n+\n+         --  Length of the source string is less the requested, copy all\n+         --  exists data and fill others by Pad character.\n+\n+         else\n+            DR.Data (1 .. SR.Last) := SR.Data (1 .. SR.Last);\n+\n+            for J in SR.Last + 1 .. Count loop\n+               DR.Data (J) := Pad;\n+            end loop;\n+         end if;\n+\n+         DR.Last := Count;\n+         Source.Reference := DR;\n+         Unreference (SR);\n+      end if;\n+   end Head;\n+\n+   -----------\n+   -- Index --\n+   -----------\n+\n+   function Index\n+     (Source  : Unbounded_Wide_String;\n+      Pattern : Wide_String;\n+      Going   : Strings.Direction := Strings.Forward;\n+      Mapping : Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n+      return Natural\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+   begin\n+      return Wide_Search.Index\n+        (SR.Data (1 .. SR.Last), Pattern, Going, Mapping);\n+   end Index;\n+\n+   function Index\n+     (Source  : Unbounded_Wide_String;\n+      Pattern : Wide_String;\n+      Going   : Direction := Forward;\n+      Mapping : Wide_Maps.Wide_Character_Mapping_Function) return Natural\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+   begin\n+      return Wide_Search.Index\n+        (SR.Data (1 .. SR.Last), Pattern, Going, Mapping);\n+   end Index;\n+\n+   function Index\n+     (Source : Unbounded_Wide_String;\n+      Set    : Wide_Maps.Wide_Character_Set;\n+      Test   : Strings.Membership := Strings.Inside;\n+      Going  : Strings.Direction  := Strings.Forward) return Natural\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+   begin\n+      return Wide_Search.Index (SR.Data (1 .. SR.Last), Set, Test, Going);\n+   end Index;\n+\n+   function Index\n+     (Source  : Unbounded_Wide_String;\n+      Pattern : Wide_String;\n+      From    : Positive;\n+      Going   : Direction := Forward;\n+      Mapping : Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n+      return Natural\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+   begin\n+      return Wide_Search.Index\n+        (SR.Data (1 .. SR.Last), Pattern, From, Going, Mapping);\n+   end Index;\n+\n+   function Index\n+     (Source  : Unbounded_Wide_String;\n+      Pattern : Wide_String;\n+      From    : Positive;\n+      Going   : Direction := Forward;\n+      Mapping : Wide_Maps.Wide_Character_Mapping_Function) return Natural\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+   begin\n+      return Wide_Search.Index\n+        (SR.Data (1 .. SR.Last), Pattern, From, Going, Mapping);\n+   end Index;\n+\n+   function Index\n+     (Source  : Unbounded_Wide_String;\n+      Set     : Wide_Maps.Wide_Character_Set;\n+      From    : Positive;\n+      Test    : Membership := Inside;\n+      Going   : Direction := Forward) return Natural\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+   begin\n+      return Wide_Search.Index\n+        (SR.Data (1 .. SR.Last), Set, From, Test, Going);\n+   end Index;\n+\n+   ---------------------\n+   -- Index_Non_Blank --\n+   ---------------------\n+\n+   function Index_Non_Blank\n+     (Source : Unbounded_Wide_String;\n+      Going  : Strings.Direction := Strings.Forward) return Natural\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+   begin\n+      return Wide_Search.Index_Non_Blank (SR.Data (1 .. SR.Last), Going);\n+   end Index_Non_Blank;\n+\n+   function Index_Non_Blank\n+     (Source : Unbounded_Wide_String;\n+      From   : Positive;\n+      Going  : Direction := Forward) return Natural\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+   begin\n+      return Wide_Search.Index_Non_Blank\n+        (SR.Data (1 .. SR.Last), From, Going);\n+   end Index_Non_Blank;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (Object : in out Unbounded_Wide_String) is\n+   begin\n+      Reference (Object.Reference);\n+   end Initialize;\n+\n+   ------------\n+   -- Insert --\n+   ------------\n+\n+   function Insert\n+     (Source   : Unbounded_Wide_String;\n+      Before   : Positive;\n+      New_Item : Wide_String) return Unbounded_Wide_String\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+      DL : constant Natural := SR.Last + New_Item'Length;\n+      DR : Shared_Wide_String_Access;\n+\n+   begin\n+      --  Check index first\n+\n+      if Before > SR.Last + 1 then\n+         raise Index_Error;\n+      end if;\n+\n+      --  Result is empty, reuse empty shared string\n+\n+      if DL = 0 then\n+         Reference (Empty_Shared_Wide_String'Access);\n+         DR := Empty_Shared_Wide_String'Access;\n+\n+      --  Inserted string is empty, reuse source shared string\n+\n+      elsif New_Item'Length = 0 then\n+         Reference (SR);\n+         DR := SR;\n+\n+      --  Otherwise, allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (DL + DL / Growth_Factor);\n+         DR.Data (1 .. Before - 1) := SR.Data (1 .. Before - 1);\n+         DR.Data (Before .. Before + New_Item'Length - 1) := New_Item;\n+         DR.Data (Before + New_Item'Length .. DL) :=\n+           SR.Data (Before .. SR.Last);\n+         DR.Last := DL;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end Insert;\n+\n+   procedure Insert\n+     (Source   : in out Unbounded_Wide_String;\n+      Before   : Positive;\n+      New_Item : Wide_String)\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+      DL : constant Natural                   := SR.Last + New_Item'Length;\n+      DR : Shared_Wide_String_Access;\n+\n+   begin\n+      --  Check bounds\n+\n+      if Before > SR.Last + 1 then\n+         raise Index_Error;\n+      end if;\n+\n+      --  Result is empty string, reuse empty shared string\n+\n+      if DL = 0 then\n+         Reference (Empty_Shared_Wide_String'Access);\n+         Source.Reference := Empty_Shared_Wide_String'Access;\n+         Unreference (SR);\n+\n+      --  Inserted string is empty, nothing to do\n+\n+      elsif New_Item'Length = 0 then\n+         null;\n+\n+      --  Try to reuse existent shared string first\n+\n+      elsif Can_Be_Reused (SR, DL) then\n+         SR.Data (Before + New_Item'Length .. DL) :=\n+           SR.Data (Before .. SR.Last);\n+         SR.Data (Before .. Before + New_Item'Length - 1) := New_Item;\n+         SR.Last := DL;\n+\n+      --  Otherwise, allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (DL + DL / Growth_Factor);\n+         DR.Data (1 .. Before - 1) := SR.Data (1 .. Before - 1);\n+         DR.Data (Before .. Before + New_Item'Length - 1) := New_Item;\n+         DR.Data (Before + New_Item'Length .. DL) :=\n+           SR.Data (Before .. SR.Last);\n+         DR.Last := DL;\n+         Source.Reference := DR;\n+         Unreference (SR);\n+      end if;\n+   end Insert;\n+\n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (Source : Unbounded_Wide_String) return Natural is\n+   begin\n+      return Source.Reference.Last;\n+   end Length;\n+\n+   ---------------\n+   -- Overwrite --\n+   ---------------\n+\n+   function Overwrite\n+     (Source   : Unbounded_Wide_String;\n+      Position : Positive;\n+      New_Item : Wide_String) return Unbounded_Wide_String\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+      DL : Natural;\n+      DR : Shared_Wide_String_Access;\n+\n+   begin\n+      --  Check bounds\n+\n+      if Position > SR.Last + 1 then\n+         raise Index_Error;\n+      end if;\n+\n+      DL := Integer'Max (SR.Last, Position + New_Item'Length - 1);\n+\n+      --  Result is empty string, reuse empty shared string\n+\n+      if DL = 0 then\n+         Reference (Empty_Shared_Wide_String'Access);\n+         DR := Empty_Shared_Wide_String'Access;\n+\n+      --  Result is same with source string, reuse source shared string\n+\n+      elsif New_Item'Length = 0 then\n+         Reference (SR);\n+         DR := SR;\n+\n+      --  Otherwise, allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (DL);\n+         DR.Data (1 .. Position - 1) := SR.Data (1 .. Position - 1);\n+         DR.Data (Position .. Position + New_Item'Length - 1) := New_Item;\n+         DR.Data (Position + New_Item'Length .. DL) :=\n+           SR.Data (Position + New_Item'Length .. SR.Last);\n+         DR.Last := DL;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end Overwrite;\n+\n+   procedure Overwrite\n+     (Source    : in out Unbounded_Wide_String;\n+      Position  : Positive;\n+      New_Item  : Wide_String)\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+      DL : Natural;\n+      DR : Shared_Wide_String_Access;\n+\n+   begin\n+      --  Bounds check\n+\n+      if Position > SR.Last + 1 then\n+         raise Index_Error;\n+      end if;\n+\n+      DL := Integer'Max (SR.Last, Position + New_Item'Length - 1);\n+\n+      --  Result is empty string, reuse empty shared string\n+\n+      if DL = 0 then\n+         Reference (Empty_Shared_Wide_String'Access);\n+         Source.Reference := Empty_Shared_Wide_String'Access;\n+         Unreference (SR);\n+\n+      --  String unchanged, nothing to do\n+\n+      elsif New_Item'Length = 0 then\n+         null;\n+\n+      --  Try to reuse existent shared string\n+\n+      elsif Can_Be_Reused (SR, DL) then\n+         SR.Data (Position .. Position + New_Item'Length - 1) := New_Item;\n+         SR.Last := DL;\n+\n+      --  Otherwise allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (DL);\n+         DR.Data (1 .. Position - 1) := SR.Data (1 .. Position - 1);\n+         DR.Data (Position .. Position + New_Item'Length - 1) := New_Item;\n+         DR.Data (Position + New_Item'Length .. DL) :=\n+           SR.Data (Position + New_Item'Length .. SR.Last);\n+         DR.Last := DL;\n+         Source.Reference := DR;\n+         Unreference (SR);\n+      end if;\n+   end Overwrite;\n+\n+   ---------------\n+   -- Reference --\n+   ---------------\n+\n+   procedure Reference (Item : not null Shared_Wide_String_Access) is\n+   begin\n+      Sync_Add_And_Fetch (Item.Counter'Access, 1);\n+   end Reference;\n+\n+   ---------------------\n+   -- Replace_Element --\n+   ---------------------\n+\n+   procedure Replace_Element\n+     (Source : in out Unbounded_Wide_String;\n+      Index  : Positive;\n+      By     : Wide_Character)\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+      DR : Shared_Wide_String_Access;\n+\n+   begin\n+      --  Bounds check.\n+\n+      if Index <= SR.Last then\n+\n+         --  Try to reuse existent shared string\n+\n+         if Can_Be_Reused (SR, SR.Last) then\n+            SR.Data (Index) := By;\n+\n+         --  Otherwise allocate new shared string and fill it\n+\n+         else\n+            DR := Allocate (SR.Last);\n+            DR.Data (1 .. SR.Last) := SR.Data (1 .. SR.Last);\n+            DR.Data (Index) := By;\n+            DR.Last := SR.Last;\n+            Source.Reference := DR;\n+            Unreference (SR);\n+         end if;\n+\n+      else\n+         raise Index_Error;\n+      end if;\n+   end Replace_Element;\n+\n+   -------------------\n+   -- Replace_Slice --\n+   -------------------\n+\n+   function Replace_Slice\n+     (Source : Unbounded_Wide_String;\n+      Low    : Positive;\n+      High   : Natural;\n+      By     : Wide_String) return Unbounded_Wide_String\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+      DL : Natural;\n+      DR : Shared_Wide_String_Access;\n+\n+   begin\n+      --  Check bounds\n+\n+      if Low > SR.Last + 1 then\n+         raise Index_Error;\n+      end if;\n+\n+      --  Do replace operation when removed slice is not empty\n+\n+      if High >= Low then\n+         DL := By'Length + SR.Last + Low - High - 1;\n+\n+         --  Result is empty string, reuse empty shared string\n+\n+         if DL = 0 then\n+            Reference (Empty_Shared_Wide_String'Access);\n+            DR := Empty_Shared_Wide_String'Access;\n+\n+         --  Otherwise allocate new shared string and fill it\n+\n+         else\n+            DR := Allocate (DL);\n+            DR.Data (1 .. Low - 1) := SR.Data (1 .. Low - 1);\n+            DR.Data (Low .. Low + By'Length - 1) := By;\n+            DR.Data (Low + By'Length .. DL) := SR.Data (High + 1 .. SR.Last);\n+            DR.Last := DL;\n+         end if;\n+\n+         return (AF.Controlled with Reference => DR);\n+\n+      --  Otherwise just insert string\n+\n+      else\n+         return Insert (Source, Low, By);\n+      end if;\n+   end Replace_Slice;\n+\n+   procedure Replace_Slice\n+     (Source : in out Unbounded_Wide_String;\n+      Low    : Positive;\n+      High   : Natural;\n+      By     : Wide_String)\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+      DL : Natural;\n+      DR : Shared_Wide_String_Access;\n+\n+   begin\n+      --  Bounds check\n+\n+      if Low > SR.Last + 1 then\n+         raise Index_Error;\n+      end if;\n+\n+      --  Do replace operation only when replaced slice is not empty\n+\n+      if High >= Low then\n+         DL := By'Length + SR.Last + Low - High - 1;\n+\n+         --  Result is empty string, reuse empty shared string\n+\n+         if DL = 0 then\n+            Reference (Empty_Shared_Wide_String'Access);\n+            Source.Reference := Empty_Shared_Wide_String'Access;\n+            Unreference (SR);\n+\n+         --  Try to reuse existent shared string\n+\n+         elsif Can_Be_Reused (SR, DL) then\n+            SR.Data (Low + By'Length .. DL) := SR.Data (High + 1 .. SR.Last);\n+            SR.Data (Low .. Low + By'Length - 1) := By;\n+            SR.Last := DL;\n+\n+         --  Otherwise allocate new shared string and fill it\n+\n+         else\n+            DR := Allocate (DL);\n+            DR.Data (1 .. Low - 1) := SR.Data (1 .. Low - 1);\n+            DR.Data (Low .. Low + By'Length - 1) := By;\n+            DR.Data (Low + By'Length .. DL) := SR.Data (High + 1 .. SR.Last);\n+            DR.Last := DL;\n+            Source.Reference := DR;\n+            Unreference (SR);\n+         end if;\n+\n+      --  Otherwise just insert item\n+\n+      else\n+         Insert (Source, Low, By);\n+      end if;\n+   end Replace_Slice;\n+\n+   -------------------------------\n+   -- Set_Unbounded_Wide_String --\n+   -------------------------------\n+\n+   procedure Set_Unbounded_Wide_String\n+     (Target : out Unbounded_Wide_String;\n+      Source : Wide_String)\n+   is\n+      TR : constant Shared_Wide_String_Access := Target.Reference;\n+      DR : Shared_Wide_String_Access;\n+\n+   begin\n+      --  In case of empty string, reuse empty shared string\n+\n+      if Source'Length = 0 then\n+         Reference (Empty_Shared_Wide_String'Access);\n+         Target.Reference := Empty_Shared_Wide_String'Access;\n+\n+      else\n+         --  Try to reuse existent shared string\n+\n+         if Can_Be_Reused (TR, Source'Length) then\n+            Reference (TR);\n+            DR := TR;\n+\n+         --  Otherwise allocate new shared string\n+\n+         else\n+            DR := Allocate (Source'Length);\n+            Target.Reference := DR;\n+         end if;\n+\n+         DR.Data (1 .. Source'Length) := Source;\n+         DR.Last := Source'Length;\n+      end if;\n+\n+      Unreference (TR);\n+   end Set_Unbounded_Wide_String;\n+\n+   -----------\n+   -- Slice --\n+   -----------\n+\n+   function Slice\n+     (Source : Unbounded_Wide_String;\n+      Low    : Positive;\n+      High   : Natural) return Wide_String\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+\n+   begin\n+      --  Note: test of High > Length is in accordance with AI95-00128\n+\n+      if Low > SR.Last + 1 or else High > SR.Last then\n+         raise Index_Error;\n+\n+      else\n+         return SR.Data (Low .. High);\n+      end if;\n+   end Slice;\n+\n+   ----------\n+   -- Tail --\n+   ----------\n+\n+   function Tail\n+     (Source : Unbounded_Wide_String;\n+      Count  : Natural;\n+      Pad    : Wide_Character := Wide_Space) return Unbounded_Wide_String\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+      DR : Shared_Wide_String_Access;\n+\n+   begin\n+      --  For empty result reuse empty shared string\n+\n+      if Count = 0 then\n+         Reference (Empty_Shared_Wide_String'Access);\n+         DR := Empty_Shared_Wide_String'Access;\n+\n+      --  Result is hole source string, reuse source shared string\n+\n+      elsif Count = SR.Last then\n+         Reference (SR);\n+         DR := SR;\n+\n+      --  Otherwise allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (Count);\n+\n+         if Count < SR.Last then\n+            DR.Data (1 .. Count) := SR.Data (SR.Last - Count + 1 .. SR.Last);\n+\n+         else\n+            for J in 1 .. Count - SR.Last loop\n+               DR.Data (J) := Pad;\n+            end loop;\n+\n+            DR.Data (Count - SR.Last + 1 .. Count) := SR.Data (1 .. SR.Last);\n+         end if;\n+\n+         DR.Last := Count;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end Tail;\n+\n+   procedure Tail\n+     (Source : in out Unbounded_Wide_String;\n+      Count  : Natural;\n+      Pad    : Wide_Character := Wide_Space)\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+      DR : Shared_Wide_String_Access;\n+\n+      procedure Common\n+        (SR    : Shared_Wide_String_Access;\n+         DR    : Shared_Wide_String_Access;\n+         Count : Natural);\n+      --  Common code of tail computation. SR/DR can point to the same object\n+\n+      ------------\n+      -- Common --\n+      ------------\n+\n+      procedure Common\n+        (SR    : Shared_Wide_String_Access;\n+         DR    : Shared_Wide_String_Access;\n+         Count : Natural) is\n+      begin\n+         if Count < SR.Last then\n+            DR.Data (1 .. Count) := SR.Data (SR.Last - Count + 1 .. SR.Last);\n+\n+         else\n+            DR.Data (Count - SR.Last + 1 .. Count) := SR.Data (1 .. SR.Last);\n+\n+            for J in 1 .. Count - SR.Last loop\n+               DR.Data (J) := Pad;\n+            end loop;\n+         end if;\n+\n+         DR.Last := Count;\n+      end Common;\n+\n+   begin\n+      --  Result is empty string, reuse empty shared string\n+\n+      if Count = 0 then\n+         Reference (Empty_Shared_Wide_String'Access);\n+         Source.Reference := Empty_Shared_Wide_String'Access;\n+         Unreference (SR);\n+\n+      --  Length of the result is the same with length of the source string,\n+      --  reuse source shared string.\n+\n+      elsif Count = SR.Last then\n+         null;\n+\n+      --  Try to reuse existent shared string\n+\n+      elsif Can_Be_Reused (SR, Count) then\n+         Common (SR, SR, Count);\n+\n+      --  Otherwise allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (Count);\n+         Common (SR, DR, Count);\n+         Source.Reference := DR;\n+         Unreference (SR);\n+      end if;\n+   end Tail;\n+\n+   --------------------\n+   -- To_Wide_String --\n+   --------------------\n+\n+   function To_Wide_String\n+     (Source : Unbounded_Wide_String) return Wide_String is\n+   begin\n+      return Source.Reference.Data (1 .. Source.Reference.Last);\n+   end To_Wide_String;\n+\n+   ------------------------------\n+   -- To_Unbounded_Wide_String --\n+   ------------------------------\n+\n+   function To_Unbounded_Wide_String\n+     (Source : Wide_String) return Unbounded_Wide_String\n+   is\n+      DR : constant Shared_Wide_String_Access := Allocate (Source'Length);\n+   begin\n+      DR.Data (1 .. Source'Length) := Source;\n+      DR.Last := Source'Length;\n+      return (AF.Controlled with Reference => DR);\n+   end To_Unbounded_Wide_String;\n+\n+   function To_Unbounded_Wide_String\n+     (Length : Natural) return Unbounded_Wide_String\n+   is\n+      DR : constant Shared_Wide_String_Access := Allocate (Length);\n+   begin\n+      DR.Last := Length;\n+      return (AF.Controlled with Reference => DR);\n+   end To_Unbounded_Wide_String;\n+\n+   ---------------\n+   -- Translate --\n+   ---------------\n+\n+   function Translate\n+     (Source  : Unbounded_Wide_String;\n+      Mapping : Wide_Maps.Wide_Character_Mapping) return Unbounded_Wide_String\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+      DR : Shared_Wide_String_Access;\n+\n+   begin\n+      --  Nothing to translate, reuse empty shared string\n+\n+      if SR.Last = 0 then\n+         Reference (Empty_Shared_Wide_String'Access);\n+         DR := Empty_Shared_Wide_String'Access;\n+\n+      --  Otherwise, allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (SR.Last);\n+\n+         for J in 1 .. SR.Last loop\n+            DR.Data (J) := Value (Mapping, SR.Data (J));\n+         end loop;\n+\n+         DR.Last := SR.Last;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end Translate;\n+\n+   procedure Translate\n+     (Source  : in out Unbounded_Wide_String;\n+      Mapping : Wide_Maps.Wide_Character_Mapping)\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+      DR : Shared_Wide_String_Access;\n+\n+   begin\n+      --  Nothing to translate\n+\n+      if SR.Last = 0 then\n+         null;\n+\n+      --  Try to reuse shared string\n+\n+      elsif Can_Be_Reused (SR, SR.Last) then\n+         for J in 1 .. SR.Last loop\n+            SR.Data (J) := Value (Mapping, SR.Data (J));\n+         end loop;\n+\n+      --  Otherwise, allocate new shared string\n+\n+      else\n+         DR := Allocate (SR.Last);\n+\n+         for J in 1 .. SR.Last loop\n+            DR.Data (J) := Value (Mapping, SR.Data (J));\n+         end loop;\n+\n+         DR.Last := SR.Last;\n+         Source.Reference := DR;\n+         Unreference (SR);\n+      end if;\n+   end Translate;\n+\n+   function Translate\n+     (Source  : Unbounded_Wide_String;\n+      Mapping : Wide_Maps.Wide_Character_Mapping_Function)\n+      return Unbounded_Wide_String\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+      DR : Shared_Wide_String_Access;\n+\n+   begin\n+      --  Nothing to translate, reuse empty shared string\n+\n+      if SR.Last = 0 then\n+         Reference (Empty_Shared_Wide_String'Access);\n+         DR := Empty_Shared_Wide_String'Access;\n+\n+      --  Otherwise, allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (SR.Last);\n+\n+         for J in 1 .. SR.Last loop\n+            DR.Data (J) := Mapping.all (SR.Data (J));\n+         end loop;\n+\n+         DR.Last := SR.Last;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+\n+   exception\n+      when others =>\n+         Unreference (DR);\n+\n+         raise;\n+   end Translate;\n+\n+   procedure Translate\n+     (Source  : in out Unbounded_Wide_String;\n+      Mapping : Wide_Maps.Wide_Character_Mapping_Function)\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+      DR : Shared_Wide_String_Access;\n+\n+   begin\n+      --  Nothing to translate\n+\n+      if SR.Last = 0 then\n+         null;\n+\n+      --  Try to reuse shared string\n+\n+      elsif Can_Be_Reused (SR, SR.Last) then\n+         for J in 1 .. SR.Last loop\n+            SR.Data (J) := Mapping.all (SR.Data (J));\n+         end loop;\n+\n+      --  Otherwise allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (SR.Last);\n+\n+         for J in 1 .. SR.Last loop\n+            DR.Data (J) := Mapping.all (SR.Data (J));\n+         end loop;\n+\n+         DR.Last := SR.Last;\n+         Source.Reference := DR;\n+         Unreference (SR);\n+      end if;\n+\n+   exception\n+      when others =>\n+         if DR /= null then\n+            Unreference (DR);\n+         end if;\n+\n+         raise;\n+   end Translate;\n+\n+   ----------\n+   -- Trim --\n+   ----------\n+\n+   function Trim\n+     (Source : Unbounded_Wide_String;\n+      Side   : Trim_End) return Unbounded_Wide_String\n+   is\n+      SR   : constant Shared_Wide_String_Access := Source.Reference;\n+      DL   : Natural;\n+      DR   : Shared_Wide_String_Access;\n+      Low  : Natural;\n+      High : Natural;\n+\n+   begin\n+      Low := Index_Non_Blank (Source, Forward);\n+\n+      --  All blanks, reuse empty shared string\n+\n+      if Low = 0 then\n+         Reference (Empty_Shared_Wide_String'Access);\n+         DR := Empty_Shared_Wide_String'Access;\n+\n+      else\n+         case Side is\n+            when Left =>\n+               High := SR.Last;\n+               DL   := SR.Last - Low + 1;\n+\n+            when Right =>\n+               Low  := 1;\n+               High := Index_Non_Blank (Source, Backward);\n+               DL   := High;\n+\n+            when Both =>\n+               High := Index_Non_Blank (Source, Backward);\n+               DL   := High - Low + 1;\n+         end case;\n+\n+         --  Length of the result is the same as length of the source string,\n+         --  reuse source shared string.\n+\n+         if DL = SR.Last then\n+            Reference (SR);\n+            DR := SR;\n+\n+         --  Otherwise, allocate new shared string\n+\n+         else\n+            DR := Allocate (DL);\n+            DR.Data (1 .. DL) := SR.Data (Low .. High);\n+            DR.Last := DL;\n+         end if;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end Trim;\n+\n+   procedure Trim\n+     (Source : in out Unbounded_Wide_String;\n+      Side   : Trim_End)\n+   is\n+      SR   : constant Shared_Wide_String_Access := Source.Reference;\n+      DL   : Natural;\n+      DR   : Shared_Wide_String_Access;\n+      Low  : Natural;\n+      High : Natural;\n+\n+   begin\n+      Low := Index_Non_Blank (Source, Forward);\n+\n+      --  All blanks, reuse empty shared string\n+\n+      if Low = 0 then\n+         Reference (Empty_Shared_Wide_String'Access);\n+         Source.Reference := Empty_Shared_Wide_String'Access;\n+         Unreference (SR);\n+\n+      else\n+         case Side is\n+            when Left =>\n+               High := SR.Last;\n+               DL   := SR.Last - Low + 1;\n+\n+            when Right =>\n+               Low  := 1;\n+               High := Index_Non_Blank (Source, Backward);\n+               DL   := High;\n+\n+            when Both =>\n+               High := Index_Non_Blank (Source, Backward);\n+               DL   := High - Low + 1;\n+         end case;\n+\n+         --  Length of the result is the same as length of the source string,\n+         --  nothing to do.\n+\n+         if DL = SR.Last then\n+            null;\n+\n+         --  Try to reuse existent shared string\n+\n+         elsif Can_Be_Reused (SR, DL) then\n+            SR.Data (1 .. DL) := SR.Data (Low .. High);\n+            SR.Last := DL;\n+\n+         --  Otherwise, allocate new shared string\n+\n+         else\n+            DR := Allocate (DL);\n+            DR.Data (1 .. DL) := SR.Data (Low .. High);\n+            DR.Last := DL;\n+            Source.Reference := DR;\n+            Unreference (SR);\n+         end if;\n+      end if;\n+   end Trim;\n+\n+   function Trim\n+     (Source : Unbounded_Wide_String;\n+      Left   : Wide_Maps.Wide_Character_Set;\n+      Right  : Wide_Maps.Wide_Character_Set) return Unbounded_Wide_String\n+   is\n+      SR   : constant Shared_Wide_String_Access := Source.Reference;\n+      DL   : Natural;\n+      DR   : Shared_Wide_String_Access;\n+      Low  : Natural;\n+      High : Natural;\n+\n+   begin\n+      Low := Index (Source, Left, Outside, Forward);\n+\n+      --  Source includes only characters from Left set, reuse empty shared\n+      --  string.\n+\n+      if Low = 0 then\n+         Reference (Empty_Shared_Wide_String'Access);\n+         DR := Empty_Shared_Wide_String'Access;\n+\n+      else\n+         High := Index (Source, Right, Outside, Backward);\n+         DL   := Integer'Max (0, High - Low + 1);\n+\n+         --  Source includes only characters from Right set or result string\n+         --  is empty, reuse empty shared string.\n+\n+         if High = 0 or else DL = 0 then\n+            Reference (Empty_Shared_Wide_String'Access);\n+            DR := Empty_Shared_Wide_String'Access;\n+\n+         --  Otherwise, allocate new shared string and fill it\n+\n+         else\n+            DR := Allocate (DL);\n+            DR.Data (1 .. DL) := SR.Data (Low .. High);\n+            DR.Last := DL;\n+         end if;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end Trim;\n+\n+   procedure Trim\n+     (Source : in out Unbounded_Wide_String;\n+      Left   : Wide_Maps.Wide_Character_Set;\n+      Right  : Wide_Maps.Wide_Character_Set)\n+   is\n+      SR   : constant Shared_Wide_String_Access := Source.Reference;\n+      DL   : Natural;\n+      DR   : Shared_Wide_String_Access;\n+      Low  : Natural;\n+      High : Natural;\n+\n+   begin\n+      Low := Index (Source, Left, Outside, Forward);\n+\n+      --  Source includes only characters from Left set, reuse empty shared\n+      --  string.\n+\n+      if Low = 0 then\n+         Reference (Empty_Shared_Wide_String'Access);\n+         Source.Reference := Empty_Shared_Wide_String'Access;\n+         Unreference (SR);\n+\n+      else\n+         High := Index (Source, Right, Outside, Backward);\n+         DL   := Integer'Max (0, High - Low + 1);\n+\n+         --  Source includes only characters from Right set or result string\n+         --  is empty, reuse empty shared string.\n+\n+         if High = 0 or else DL = 0 then\n+            Reference (Empty_Shared_Wide_String'Access);\n+            Source.Reference := Empty_Shared_Wide_String'Access;\n+            Unreference (SR);\n+\n+         --  Try to reuse existent shared string\n+\n+         elsif Can_Be_Reused (SR, DL) then\n+            SR.Data (1 .. DL) := SR.Data (Low .. High);\n+            SR.Last := DL;\n+\n+         --  Otherwise, allocate new shared string and fill it\n+\n+         else\n+            DR := Allocate (DL);\n+            DR.Data (1 .. DL) := SR.Data (Low .. High);\n+            DR.Last := DL;\n+            Source.Reference := DR;\n+            Unreference (SR);\n+         end if;\n+      end if;\n+   end Trim;\n+\n+   ---------------------\n+   -- Unbounded_Slice --\n+   ---------------------\n+\n+   function Unbounded_Slice\n+     (Source : Unbounded_Wide_String;\n+      Low    : Positive;\n+      High   : Natural) return Unbounded_Wide_String\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+      DL : Natural;\n+      DR : Shared_Wide_String_Access;\n+\n+   begin\n+      --  Check bounds\n+\n+      if Low > SR.Last + 1 or else High > SR.Last then\n+         raise Index_Error;\n+\n+      --  Result is empty slice, reuse empty shared string\n+\n+      elsif Low > High then\n+         Reference (Empty_Shared_Wide_String'Access);\n+         DR := Empty_Shared_Wide_String'Access;\n+\n+      --  Otherwise, allocate new shared string and fill it\n+\n+      else\n+         DL := High - Low + 1;\n+         DR := Allocate (DL);\n+         DR.Data (1 .. DL) := SR.Data (Low .. High);\n+         DR.Last := DL;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end Unbounded_Slice;\n+\n+   procedure Unbounded_Slice\n+     (Source : Unbounded_Wide_String;\n+      Target : out Unbounded_Wide_String;\n+      Low    : Positive;\n+      High   : Natural)\n+   is\n+      SR : constant Shared_Wide_String_Access := Source.Reference;\n+      TR : constant Shared_Wide_String_Access := Target.Reference;\n+      DL : Natural;\n+      DR : Shared_Wide_String_Access;\n+\n+   begin\n+      --  Check bounds\n+\n+      if Low > SR.Last + 1 or else High > SR.Last then\n+         raise Index_Error;\n+\n+      --  Result is empty slice, reuse empty shared string\n+\n+      elsif Low > High then\n+         Reference (Empty_Shared_Wide_String'Access);\n+         Target.Reference := Empty_Shared_Wide_String'Access;\n+         Unreference (TR);\n+\n+      else\n+         DL := High - Low + 1;\n+\n+         --  Try to reuse existent shared string\n+\n+         if Can_Be_Reused (TR, DL) then\n+            TR.Data (1 .. DL) := SR.Data (Low .. High);\n+            TR.Last := DL;\n+\n+         --  Otherwise, allocate new shared string and fill it\n+\n+         else\n+            DR := Allocate (DL);\n+            DR.Data (1 .. DL) := SR.Data (Low .. High);\n+            DR.Last := DL;\n+            Target.Reference := DR;\n+            Unreference (TR);\n+         end if;\n+      end if;\n+   end Unbounded_Slice;\n+\n+   -----------------\n+   -- Unreference --\n+   -----------------\n+\n+   procedure Unreference (Item : not null Shared_Wide_String_Access) is\n+      use Interfaces;\n+\n+      procedure Free is\n+        new Ada.Unchecked_Deallocation\n+              (Shared_Wide_String, Shared_Wide_String_Access);\n+\n+      Aux : Shared_Wide_String_Access := Item;\n+\n+   begin\n+      if Sync_Sub_And_Fetch (Aux.Counter'Access, 1) = 0 then\n+\n+         --  Reference counter of Empty_Shared_Wide_String must never reach\n+         --  zero.\n+\n+         pragma Assert (Aux /= Empty_Shared_Wide_String'Access);\n+\n+         Free (Aux);\n+      end if;\n+   end Unreference;\n+\n+end Ada.Strings.Wide_Unbounded;"}, {"sha": "a438258c908c448e459380d0e7f4108a76d5c714", "filename": "gcc/ada/a-stwiun-shared.ads", "status": "added", "additions": 483, "deletions": 0, "changes": 483, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fa-stwiun-shared.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fa-stwiun-shared.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stwiun-shared.ads?ref=6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5", "patch": "@@ -0,0 +1,483 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--           A D A . S T R I N G S . W I D E _ U N B O U N D E D            --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This version is supported on:\n+--    - all Alpha platforms\n+--    - all ia64 platforms\n+--    - all PowerPC platforms\n+--    - all SPARC V9 platforms\n+--    - all x86_64 platforms\n+\n+with Ada.Strings.Wide_Maps;\n+private with Ada.Finalization;\n+private with Interfaces;\n+\n+package Ada.Strings.Wide_Unbounded is\n+   pragma Preelaborate;\n+\n+   type Unbounded_Wide_String is private;\n+   pragma Preelaborable_Initialization (Unbounded_Wide_String);\n+\n+   Null_Unbounded_Wide_String : constant Unbounded_Wide_String;\n+\n+   function Length (Source : Unbounded_Wide_String) return Natural;\n+\n+   type Wide_String_Access is access all Wide_String;\n+\n+   procedure Free (X : in out Wide_String_Access);\n+\n+   --------------------------------------------------------\n+   -- Conversion, Concatenation, and Selection Functions --\n+   --------------------------------------------------------\n+\n+   function To_Unbounded_Wide_String\n+     (Source : Wide_String) return Unbounded_Wide_String;\n+\n+   function To_Unbounded_Wide_String\n+     (Length : Natural) return Unbounded_Wide_String;\n+\n+   function To_Wide_String\n+     (Source : Unbounded_Wide_String) return Wide_String;\n+\n+   procedure Set_Unbounded_Wide_String\n+     (Target : out Unbounded_Wide_String;\n+      Source : Wide_String);\n+   pragma Ada_05 (Set_Unbounded_Wide_String);\n+\n+   procedure Append\n+     (Source   : in out Unbounded_Wide_String;\n+      New_Item : Unbounded_Wide_String);\n+\n+   procedure Append\n+     (Source   : in out Unbounded_Wide_String;\n+      New_Item : Wide_String);\n+\n+   procedure Append\n+     (Source   : in out Unbounded_Wide_String;\n+      New_Item : Wide_Character);\n+\n+   function \"&\"\n+     (Left  : Unbounded_Wide_String;\n+      Right : Unbounded_Wide_String) return Unbounded_Wide_String;\n+\n+   function \"&\"\n+     (Left  : Unbounded_Wide_String;\n+      Right : Wide_String) return Unbounded_Wide_String;\n+\n+   function \"&\"\n+     (Left  : Wide_String;\n+      Right : Unbounded_Wide_String) return Unbounded_Wide_String;\n+\n+   function \"&\"\n+     (Left  : Unbounded_Wide_String;\n+      Right : Wide_Character) return Unbounded_Wide_String;\n+\n+   function \"&\"\n+     (Left  : Wide_Character;\n+      Right : Unbounded_Wide_String) return Unbounded_Wide_String;\n+\n+   function Element\n+     (Source : Unbounded_Wide_String;\n+      Index  : Positive) return Wide_Character;\n+\n+   procedure Replace_Element\n+     (Source : in out Unbounded_Wide_String;\n+      Index  : Positive;\n+      By     : Wide_Character);\n+\n+   function Slice\n+     (Source : Unbounded_Wide_String;\n+      Low    : Positive;\n+      High   : Natural) return Wide_String;\n+\n+   function Unbounded_Slice\n+     (Source : Unbounded_Wide_String;\n+      Low    : Positive;\n+      High   : Natural) return Unbounded_Wide_String;\n+   pragma Ada_05 (Unbounded_Slice);\n+\n+   procedure Unbounded_Slice\n+     (Source : Unbounded_Wide_String;\n+      Target : out Unbounded_Wide_String;\n+      Low    : Positive;\n+      High   : Natural);\n+   pragma Ada_05 (Unbounded_Slice);\n+\n+   function \"=\"\n+     (Left  : Unbounded_Wide_String;\n+      Right : Unbounded_Wide_String) return Boolean;\n+\n+   function \"=\"\n+     (Left  : Unbounded_Wide_String;\n+      Right : Wide_String) return Boolean;\n+\n+   function \"=\"\n+     (Left  : Wide_String;\n+      Right : Unbounded_Wide_String) return Boolean;\n+\n+   function \"<\"\n+     (Left  : Unbounded_Wide_String;\n+      Right : Unbounded_Wide_String) return Boolean;\n+\n+   function \"<\"\n+     (Left  : Unbounded_Wide_String;\n+      Right : Wide_String) return Boolean;\n+\n+   function \"<\"\n+     (Left  : Wide_String;\n+      Right : Unbounded_Wide_String) return Boolean;\n+\n+   function \"<=\"\n+     (Left  : Unbounded_Wide_String;\n+      Right : Unbounded_Wide_String) return Boolean;\n+\n+   function \"<=\"\n+     (Left  : Unbounded_Wide_String;\n+      Right : Wide_String) return Boolean;\n+\n+   function \"<=\"\n+     (Left  : Wide_String;\n+      Right : Unbounded_Wide_String) return Boolean;\n+\n+   function \">\"\n+     (Left  : Unbounded_Wide_String;\n+      Right : Unbounded_Wide_String) return Boolean;\n+\n+   function \">\"\n+     (Left  : Unbounded_Wide_String;\n+      Right : Wide_String) return Boolean;\n+\n+   function \">\"\n+     (Left  : Wide_String;\n+      Right : Unbounded_Wide_String) return Boolean;\n+\n+   function \">=\"\n+     (Left  : Unbounded_Wide_String;\n+      Right : Unbounded_Wide_String) return Boolean;\n+\n+   function \">=\"\n+     (Left  : Unbounded_Wide_String;\n+      Right : Wide_String) return Boolean;\n+\n+   function \">=\"\n+     (Left  : Wide_String;\n+      Right : Unbounded_Wide_String) return Boolean;\n+\n+   ------------------------\n+   -- Search Subprograms --\n+   ------------------------\n+\n+   function Index\n+     (Source  : Unbounded_Wide_String;\n+      Pattern : Wide_String;\n+      Going   : Direction := Forward;\n+      Mapping : Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n+      return Natural;\n+\n+   function Index\n+     (Source  : Unbounded_Wide_String;\n+      Pattern : Wide_String;\n+      Going   : Direction := Forward;\n+      Mapping : Wide_Maps.Wide_Character_Mapping_Function) return Natural;\n+\n+   function Index\n+     (Source : Unbounded_Wide_String;\n+      Set    : Wide_Maps.Wide_Character_Set;\n+      Test   : Membership := Inside;\n+      Going  : Direction  := Forward) return Natural;\n+\n+   function Index\n+     (Source  : Unbounded_Wide_String;\n+      Pattern : Wide_String;\n+      From    : Positive;\n+      Going   : Direction := Forward;\n+      Mapping : Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n+      return Natural;\n+   pragma Ada_05 (Index);\n+\n+   function Index\n+     (Source  : Unbounded_Wide_String;\n+      Pattern : Wide_String;\n+      From    : Positive;\n+      Going   : Direction := Forward;\n+      Mapping : Wide_Maps.Wide_Character_Mapping_Function) return Natural;\n+   pragma Ada_05 (Index);\n+\n+   function Index\n+     (Source  : Unbounded_Wide_String;\n+      Set     : Wide_Maps.Wide_Character_Set;\n+      From    : Positive;\n+      Test    : Membership := Inside;\n+      Going   : Direction := Forward) return Natural;\n+   pragma Ada_05 (Index);\n+\n+   function Index_Non_Blank\n+     (Source : Unbounded_Wide_String;\n+      Going  : Direction := Forward) return Natural;\n+\n+   function Index_Non_Blank\n+     (Source : Unbounded_Wide_String;\n+      From   : Positive;\n+      Going  : Direction := Forward) return Natural;\n+   pragma Ada_05 (Index_Non_Blank);\n+\n+   function Count\n+     (Source  : Unbounded_Wide_String;\n+      Pattern : Wide_String;\n+      Mapping : Wide_Maps.Wide_Character_Mapping := Wide_Maps.Identity)\n+      return Natural;\n+\n+   function Count\n+     (Source  : Unbounded_Wide_String;\n+      Pattern : Wide_String;\n+      Mapping : Wide_Maps.Wide_Character_Mapping_Function) return Natural;\n+\n+   function Count\n+     (Source : Unbounded_Wide_String;\n+      Set    : Wide_Maps.Wide_Character_Set) return Natural;\n+\n+   procedure Find_Token\n+     (Source : Unbounded_Wide_String;\n+      Set    : Wide_Maps.Wide_Character_Set;\n+      Test   : Membership;\n+      First  : out Positive;\n+      Last   : out Natural);\n+\n+   ------------------------------------\n+   -- String Translation Subprograms --\n+   ------------------------------------\n+\n+   function Translate\n+     (Source  : Unbounded_Wide_String;\n+      Mapping : Wide_Maps.Wide_Character_Mapping)\n+      return Unbounded_Wide_String;\n+\n+   procedure Translate\n+     (Source  : in out Unbounded_Wide_String;\n+      Mapping : Wide_Maps.Wide_Character_Mapping);\n+\n+   function Translate\n+     (Source  : Unbounded_Wide_String;\n+      Mapping : Wide_Maps.Wide_Character_Mapping_Function)\n+      return Unbounded_Wide_String;\n+\n+   procedure Translate\n+     (Source  : in out Unbounded_Wide_String;\n+      Mapping : Wide_Maps.Wide_Character_Mapping_Function);\n+\n+   ---------------------------------------\n+   -- String Transformation Subprograms --\n+   ---------------------------------------\n+\n+   function Replace_Slice\n+     (Source : Unbounded_Wide_String;\n+      Low    : Positive;\n+      High   : Natural;\n+      By     : Wide_String) return Unbounded_Wide_String;\n+\n+   procedure Replace_Slice\n+     (Source : in out Unbounded_Wide_String;\n+      Low    : Positive;\n+      High   : Natural;\n+      By     : Wide_String);\n+\n+   function Insert\n+     (Source   : Unbounded_Wide_String;\n+      Before   : Positive;\n+      New_Item : Wide_String) return Unbounded_Wide_String;\n+\n+   procedure Insert\n+     (Source   : in out Unbounded_Wide_String;\n+      Before   : Positive;\n+      New_Item : Wide_String);\n+\n+   function Overwrite\n+     (Source   : Unbounded_Wide_String;\n+      Position : Positive;\n+      New_Item : Wide_String) return Unbounded_Wide_String;\n+\n+   procedure Overwrite\n+     (Source   : in out Unbounded_Wide_String;\n+      Position : Positive;\n+      New_Item : Wide_String);\n+\n+   function Delete\n+     (Source  : Unbounded_Wide_String;\n+      From    : Positive;\n+      Through : Natural) return Unbounded_Wide_String;\n+\n+   procedure Delete\n+     (Source  : in out Unbounded_Wide_String;\n+      From    : Positive;\n+      Through : Natural);\n+\n+   function Trim\n+     (Source : Unbounded_Wide_String;\n+      Side   : Trim_End) return Unbounded_Wide_String;\n+\n+   procedure Trim\n+     (Source : in out Unbounded_Wide_String;\n+      Side   : Trim_End);\n+\n+   function Trim\n+     (Source : Unbounded_Wide_String;\n+      Left   : Wide_Maps.Wide_Character_Set;\n+      Right  : Wide_Maps.Wide_Character_Set) return Unbounded_Wide_String;\n+\n+   procedure Trim\n+     (Source : in out Unbounded_Wide_String;\n+      Left   : Wide_Maps.Wide_Character_Set;\n+      Right  : Wide_Maps.Wide_Character_Set);\n+\n+   function Head\n+     (Source : Unbounded_Wide_String;\n+      Count  : Natural;\n+      Pad    : Wide_Character := Wide_Space) return Unbounded_Wide_String;\n+\n+   procedure Head\n+     (Source : in out Unbounded_Wide_String;\n+      Count  : Natural;\n+      Pad    : Wide_Character := Wide_Space);\n+\n+   function Tail\n+     (Source : Unbounded_Wide_String;\n+      Count  : Natural;\n+      Pad    : Wide_Character := Wide_Space) return Unbounded_Wide_String;\n+\n+   procedure Tail\n+     (Source : in out Unbounded_Wide_String;\n+      Count  : Natural;\n+      Pad    : Wide_Character := Wide_Space);\n+\n+   function \"*\"\n+     (Left  : Natural;\n+      Right : Wide_Character) return Unbounded_Wide_String;\n+\n+   function \"*\"\n+     (Left  : Natural;\n+      Right : Wide_String) return Unbounded_Wide_String;\n+\n+   function \"*\"\n+     (Left  : Natural;\n+      Right : Unbounded_Wide_String) return Unbounded_Wide_String;\n+\n+private\n+   pragma Inline (Length);\n+\n+   package AF renames Ada.Finalization;\n+\n+   type Shared_Wide_String (Max_Length : Natural) is limited record\n+      Counter : aliased Interfaces.Unsigned_32 := 1;\n+      --  Reference counter.\n+\n+      Last    : Natural                        := 0;\n+      Data    : Wide_String (1 .. Max_Length);\n+      --  Last is the index of last significant element of the Data. All\n+      --  elements with larger indecies are just an extra room.\n+   end record;\n+\n+   type Shared_Wide_String_Access is access all Shared_Wide_String;\n+\n+   procedure Reference (Item : not null Shared_Wide_String_Access);\n+   --  Increment reference counter.\n+\n+   procedure Unreference (Item : not null Shared_Wide_String_Access);\n+   --  Decrement reference counter. Deallocate Item when reference counter is\n+   --  zero.\n+\n+   function Can_Be_Reused\n+     (Item   : Shared_Wide_String_Access;\n+      Length : Natural) return Boolean;\n+   --  Returns True if Shared_Wide_String can be reused. There are two criteria\n+   --  when Shared_Wide_String can be reused: its reference counter must be one\n+   --  (thus Shared_Wide_String is owned exclusively) and its size is\n+   --  sufficient to store string with specified length effectively.\n+\n+   function Allocate (Max_Length : Natural) return Shared_Wide_String_Access;\n+   --  Allocates new Shared_Wide_String with at least specified maximum length.\n+   --  Actual maximum length of the allocated Shared_Wide_String can be sligtly\n+   --  greater. Returns reference to Empty_Shared_Wide_String when requested\n+   --  length is zero.\n+\n+   Empty_Shared_Wide_String : aliased Shared_Wide_String (0);\n+\n+   function To_Unbounded (S : Wide_String) return Unbounded_Wide_String\n+     renames To_Unbounded_Wide_String;\n+   --  This renames are here only to be used in the pragma Stream_Convert.\n+\n+   type Unbounded_Wide_String is new AF.Controlled with record\n+      Reference : Shared_Wide_String_Access := Empty_Shared_Wide_String'Access;\n+   end record;\n+\n+   --  The Unbounded_Wide_String uses several techniques to increasy speed of\n+   --  the application:\n+   --   - implicit sharing or copy-on-write. Unbounded_Wide_String contains\n+   --     only the reference to the data which is shared between several\n+   --     instances. The shared data is reallocated only when its value is\n+   --     changed and the object mutation can't be used or it is unefficient to\n+   --     use it;\n+   --   - object mutation. Shared data object can be reused without memory\n+   --     reallocation when all of the following requirements are meat:\n+   --      - shared data object don't used anywhere longer;\n+   --      - its size is sufficient to store new value;\n+   --      - the gap after reuse is less then some threashold.\n+   --   - memory preallocation. Most of used memory allocation algorithms\n+   --     alligns allocated segment on the some boundary, thus some amount of\n+   --     additional memory can be preallocated without any impact. Such\n+   --     preallocated memory can used later by Append/Insert operations\n+   --     without reallocation.\n+   --\n+   --  Reference counting uses GCC builtin atomic operations, which allows to\n+   --  safely share internal data between Ada tasks. Nevertheless, this not\n+   --  make objects of Unbounded_Wide_String thread-safe, so each instance\n+   --  can't be accessed by several tasks simulatenously.\n+\n+   pragma Stream_Convert (Unbounded_Wide_String, To_Unbounded, To_Wide_String);\n+   --  Provide stream routines without dragging in Ada.Streams\n+\n+   pragma Finalize_Storage_Only (Unbounded_Wide_String);\n+   --  Finalization is required only for freeing storage\n+\n+   overriding procedure Initialize (Object : in out Unbounded_Wide_String);\n+   overriding procedure Adjust     (Object : in out Unbounded_Wide_String);\n+   overriding procedure Finalize   (Object : in out Unbounded_Wide_String);\n+\n+   Null_Unbounded_Wide_String : constant Unbounded_Wide_String :=\n+                             (AF.Controlled with\n+                                Reference => Empty_Shared_Wide_String'Access);\n+\n+end Ada.Strings.Wide_Unbounded;"}, {"sha": "401783941312a476cc9be876f55705f0eb2bd4e8", "filename": "gcc/ada/a-stzunb-shared.adb", "status": "added", "additions": 2120, "deletions": 0, "changes": 2120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fa-stzunb-shared.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fa-stzunb-shared.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stzunb-shared.adb?ref=6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5", "patch": "@@ -0,0 +1,2120 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--      A D A . S T R I N G S . W I D E _ W I D E _ U N B O U N D E D       --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Strings.Wide_Wide_Search;\n+with Ada.Unchecked_Deallocation;\n+\n+package body Ada.Strings.Wide_Wide_Unbounded is\n+\n+   use Ada.Strings.Wide_Wide_Maps;\n+\n+   Growth_Factor : constant := 32;\n+   --  The growth factor controls how much extra space is allocated when\n+   --  we have to increase the size of an allocated unbounded string. By\n+   --  allocating extra space, we avoid the need to reallocate on every\n+   --  append, particularly important when a string is built up by repeated\n+   --  append operations of small pieces. This is expressed as a factor so\n+   --  32 means add 1/32 of the length of the string as growth space.\n+\n+   Min_Mul_Alloc : constant := Standard'Maximum_Alignment;\n+   --  Allocation will be done by a multiple of Min_Mul_Alloc. This causes\n+   --  no memory loss as most (all?) malloc implementations are obliged to\n+   --  align the returned memory on the maximum alignment as malloc does not\n+   --  know the target alignment.\n+\n+   procedure Sync_Add_And_Fetch\n+     (Ptr   : access Interfaces.Unsigned_32;\n+      Value : Interfaces.Unsigned_32);\n+   pragma Import (Intrinsic, Sync_Add_And_Fetch, \"__sync_add_and_fetch_4\");\n+\n+   function Sync_Sub_And_Fetch\n+     (Ptr   : access Interfaces.Unsigned_32;\n+      Value : Interfaces.Unsigned_32) return Interfaces.Unsigned_32;\n+   pragma Import (Intrinsic, Sync_Sub_And_Fetch, \"__sync_sub_and_fetch_4\");\n+\n+   function Aligned_Max_Length (Max_Length : Natural) return Natural;\n+   --  Returns recommended length of the shared string which is greater or\n+   --  equal to specified length. Calculation take in sense alignment of\n+   --  the allocated memory segments to use memory effectively by\n+   --  Append/Insert/etc operations.\n+\n+   ---------\n+   -- \"&\" --\n+   ---------\n+\n+   function \"&\"\n+     (Left  : Unbounded_Wide_Wide_String;\n+      Right : Unbounded_Wide_Wide_String) return Unbounded_Wide_Wide_String\n+   is\n+      LR : constant Shared_Wide_Wide_String_Access := Left.Reference;\n+      RR : constant Shared_Wide_Wide_String_Access := Right.Reference;\n+      DL : constant Natural := LR.Last + RR.Last;\n+      DR : Shared_Wide_Wide_String_Access;\n+\n+   begin\n+      --  Result is an empty string, reuse shared empty string.\n+\n+      if DL = 0 then\n+         Reference (Empty_Shared_Wide_Wide_String'Access);\n+         DR := Empty_Shared_Wide_Wide_String'Access;\n+\n+      --  Left string is empty, return Rigth string.\n+\n+      elsif LR.Last = 0 then\n+         Reference (RR);\n+         DR := RR;\n+\n+      --  Right string is empty, return Left string.\n+\n+      elsif RR.Last = 0 then\n+         Reference (LR);\n+         DR := LR;\n+\n+      --  Overwise, allocate new shared string and fill data.\n+\n+      else\n+         DR := Allocate (LR.Last + RR.Last);\n+         DR.Data (1 .. LR.Last) := LR.Data (1 .. LR.Last);\n+         DR.Data (LR.Last + 1 .. DL) := RR.Data (1 .. RR.Last);\n+         DR.Last := DL;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end \"&\";\n+\n+   function \"&\"\n+     (Left  : Unbounded_Wide_Wide_String;\n+      Right : Wide_Wide_String) return Unbounded_Wide_Wide_String\n+   is\n+      LR : constant Shared_Wide_Wide_String_Access := Left.Reference;\n+      DL : constant Natural := LR.Last + Right'Length;\n+      DR : Shared_Wide_Wide_String_Access;\n+\n+   begin\n+      --  Result is an empty string, reuse shared empty string.\n+\n+      if DL = 0 then\n+         Reference (Empty_Shared_Wide_Wide_String'Access);\n+         DR := Empty_Shared_Wide_Wide_String'Access;\n+\n+      --  Right is an empty string, return Left string.\n+\n+      elsif Right'Length = 0 then\n+         Reference (LR);\n+         DR := LR;\n+\n+      --  Otherwise, allocate new shared string and fill it.\n+\n+      else\n+         DR := Allocate (DL);\n+         DR.Data (1 .. LR.Last) := LR.Data (1 .. LR.Last);\n+         DR.Data (LR.Last + 1 .. DL) := Right;\n+         DR.Last := DL;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end \"&\";\n+\n+   function \"&\"\n+     (Left  : Wide_Wide_String;\n+      Right : Unbounded_Wide_Wide_String) return Unbounded_Wide_Wide_String\n+   is\n+      RR : constant Shared_Wide_Wide_String_Access := Right.Reference;\n+      DL : constant Natural := Left'Length + RR.Last;\n+      DR : Shared_Wide_Wide_String_Access;\n+\n+   begin\n+      --  Result is an empty string, reuse shared one.\n+\n+      if DL = 0 then\n+         Reference (Empty_Shared_Wide_Wide_String'Access);\n+         DR := Empty_Shared_Wide_Wide_String'Access;\n+\n+      --  Left is empty string, return Right string.\n+\n+      elsif Left'Length = 0 then\n+         Reference (RR);\n+         DR := RR;\n+\n+      --  Otherwise, allocate new shared string and fill it.\n+\n+      else\n+         DR := Allocate (DL);\n+         DR.Data (1 .. Left'Length) := Left;\n+         DR.Data (Left'Length + 1 .. DL) := RR.Data (1 .. RR.Last);\n+         DR.Last := DL;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end \"&\";\n+\n+   function \"&\"\n+     (Left  : Unbounded_Wide_Wide_String;\n+      Right : Wide_Wide_Character) return Unbounded_Wide_Wide_String\n+   is\n+      LR : constant Shared_Wide_Wide_String_Access := Left.Reference;\n+      DL : constant Natural := LR.Last + 1;\n+      DR : Shared_Wide_Wide_String_Access;\n+\n+   begin\n+      DR := Allocate (DL);\n+      DR.Data (1 .. LR.Last) := LR.Data (1 .. LR.Last);\n+      DR.Data (DL) := Right;\n+      DR.Last := DL;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end \"&\";\n+\n+   function \"&\"\n+     (Left  : Wide_Wide_Character;\n+      Right : Unbounded_Wide_Wide_String) return Unbounded_Wide_Wide_String\n+   is\n+      RR : constant Shared_Wide_Wide_String_Access := Right.Reference;\n+      DL : constant Natural := 1 + RR.Last;\n+      DR : Shared_Wide_Wide_String_Access;\n+\n+   begin\n+      DR := Allocate (DL);\n+      DR.Data (1) := Left;\n+      DR.Data (2 .. DL) := RR.Data (1 .. RR.Last);\n+      DR.Last := DL;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end \"&\";\n+\n+   ---------\n+   -- \"*\" --\n+   ---------\n+\n+   function \"*\"\n+     (Left  : Natural;\n+      Right : Wide_Wide_Character) return Unbounded_Wide_Wide_String\n+   is\n+      DR : Shared_Wide_Wide_String_Access;\n+\n+   begin\n+      --  Result is an empty string, reuse shared empty string.\n+\n+      if Left = 0 then\n+         Reference (Empty_Shared_Wide_Wide_String'Access);\n+         DR := Empty_Shared_Wide_Wide_String'Access;\n+\n+      --  Otherwise, allocate new shared string and fill it.\n+\n+      else\n+         DR := Allocate (Left);\n+\n+         for J in 1 .. Left loop\n+            DR.Data (J) := Right;\n+         end loop;\n+\n+         DR.Last := Left;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end \"*\";\n+\n+   function \"*\"\n+     (Left  : Natural;\n+      Right : Wide_Wide_String) return Unbounded_Wide_Wide_String\n+   is\n+      DL : constant Natural := Left * Right'Length;\n+      DR : Shared_Wide_Wide_String_Access;\n+      K  : Positive;\n+\n+   begin\n+      --  Result is an empty string, reuse shared empty string.\n+\n+      if DL = 0 then\n+         Reference (Empty_Shared_Wide_Wide_String'Access);\n+         DR := Empty_Shared_Wide_Wide_String'Access;\n+\n+      --  Otherwise, allocate new shared string and fill it.\n+\n+      else\n+         DR := Allocate (DL);\n+         K := 1;\n+\n+         for J in 1 .. Left loop\n+            DR.Data (K .. K + Right'Length - 1) := Right;\n+            K := K + Right'Length;\n+         end loop;\n+\n+         DR.Last := DL;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end \"*\";\n+\n+   function \"*\"\n+     (Left  : Natural;\n+      Right : Unbounded_Wide_Wide_String) return Unbounded_Wide_Wide_String\n+   is\n+      RR : constant Shared_Wide_Wide_String_Access := Right.Reference;\n+      DL : constant Natural := Left * RR.Last;\n+      DR : Shared_Wide_Wide_String_Access;\n+      K  : Positive;\n+\n+   begin\n+      --  Result is an empty string, reuse shared empty string.\n+\n+      if DL = 0 then\n+         Reference (Empty_Shared_Wide_Wide_String'Access);\n+         DR := Empty_Shared_Wide_Wide_String'Access;\n+\n+      --  Coefficient is one, just return string itself.\n+\n+      elsif Left = 1 then\n+         Reference (RR);\n+         DR := RR;\n+\n+      --  Otherwise, allocate new shared string and fill it.\n+\n+      else\n+         DR := Allocate (DL);\n+         K := 1;\n+\n+         for J in 1 .. Left loop\n+            DR.Data (K .. K + RR.Last - 1) := RR.Data (1 .. RR.Last);\n+            K := K + RR.Last;\n+         end loop;\n+\n+         DR.Last := DL;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end \"*\";\n+\n+   ---------\n+   -- \"<\" --\n+   ---------\n+\n+   function \"<\"\n+     (Left  : Unbounded_Wide_Wide_String;\n+      Right : Unbounded_Wide_Wide_String) return Boolean\n+   is\n+      LR : constant Shared_Wide_Wide_String_Access := Left.Reference;\n+      RR : constant Shared_Wide_Wide_String_Access := Right.Reference;\n+   begin\n+      return LR.Data (1 .. LR.Last) < RR.Data (1 .. RR.Last);\n+   end \"<\";\n+\n+   function \"<\"\n+     (Left  : Unbounded_Wide_Wide_String;\n+      Right : Wide_Wide_String) return Boolean\n+   is\n+      LR : constant Shared_Wide_Wide_String_Access := Left.Reference;\n+   begin\n+      return LR.Data (1 .. LR.Last) < Right;\n+   end \"<\";\n+\n+   function \"<\"\n+     (Left  : Wide_Wide_String;\n+      Right : Unbounded_Wide_Wide_String) return Boolean\n+   is\n+      RR : constant Shared_Wide_Wide_String_Access := Right.Reference;\n+   begin\n+      return Left < RR.Data (1 .. RR.Last);\n+   end \"<\";\n+\n+   ----------\n+   -- \"<=\" --\n+   ----------\n+\n+   function \"<=\"\n+     (Left  : Unbounded_Wide_Wide_String;\n+      Right : Unbounded_Wide_Wide_String) return Boolean\n+   is\n+      LR : constant Shared_Wide_Wide_String_Access := Left.Reference;\n+      RR : constant Shared_Wide_Wide_String_Access := Right.Reference;\n+\n+   begin\n+      --  LR = RR means two strings shares shared string, thus they are equal\n+\n+      return LR = RR or else LR.Data (1 .. LR.Last) <= RR.Data (1 .. RR.Last);\n+   end \"<=\";\n+\n+   function \"<=\"\n+     (Left  : Unbounded_Wide_Wide_String;\n+      Right : Wide_Wide_String) return Boolean\n+   is\n+      LR : constant Shared_Wide_Wide_String_Access := Left.Reference;\n+   begin\n+      return LR.Data (1 .. LR.Last) <= Right;\n+   end \"<=\";\n+\n+   function \"<=\"\n+     (Left  : Wide_Wide_String;\n+      Right : Unbounded_Wide_Wide_String) return Boolean\n+   is\n+      RR : constant Shared_Wide_Wide_String_Access := Right.Reference;\n+   begin\n+      return Left <= RR.Data (1 .. RR.Last);\n+   end \"<=\";\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\"\n+     (Left  : Unbounded_Wide_Wide_String;\n+      Right : Unbounded_Wide_Wide_String) return Boolean\n+   is\n+      LR : constant Shared_Wide_Wide_String_Access := Left.Reference;\n+      RR : constant Shared_Wide_Wide_String_Access := Right.Reference;\n+\n+   begin\n+      return LR = RR or else LR.Data (1 .. LR.Last) = RR.Data (1 .. RR.Last);\n+      --  LR = RR means two strings shares shared string, thus they are equal.\n+   end \"=\";\n+\n+   function \"=\"\n+     (Left  : Unbounded_Wide_Wide_String;\n+      Right : Wide_Wide_String) return Boolean\n+   is\n+      LR : constant Shared_Wide_Wide_String_Access := Left.Reference;\n+   begin\n+      return LR.Data (1 .. LR.Last) = Right;\n+   end \"=\";\n+\n+   function \"=\"\n+     (Left  : Wide_Wide_String;\n+      Right : Unbounded_Wide_Wide_String) return Boolean\n+   is\n+      RR : constant Shared_Wide_Wide_String_Access := Right.Reference;\n+   begin\n+      return Left = RR.Data (1 .. RR.Last);\n+   end \"=\";\n+\n+   ---------\n+   -- \">\" --\n+   ---------\n+\n+   function \">\"\n+     (Left  : Unbounded_Wide_Wide_String;\n+      Right : Unbounded_Wide_Wide_String) return Boolean\n+   is\n+      LR : constant Shared_Wide_Wide_String_Access := Left.Reference;\n+      RR : constant Shared_Wide_Wide_String_Access := Right.Reference;\n+   begin\n+      return LR.Data (1 .. LR.Last) > RR.Data (1 .. RR.Last);\n+   end \">\";\n+\n+   function \">\"\n+     (Left  : Unbounded_Wide_Wide_String;\n+      Right : Wide_Wide_String) return Boolean\n+   is\n+      LR : constant Shared_Wide_Wide_String_Access := Left.Reference;\n+   begin\n+      return LR.Data (1 .. LR.Last) > Right;\n+   end \">\";\n+\n+   function \">\"\n+     (Left  : Wide_Wide_String;\n+      Right : Unbounded_Wide_Wide_String) return Boolean\n+   is\n+      RR : constant Shared_Wide_Wide_String_Access := Right.Reference;\n+   begin\n+      return Left > RR.Data (1 .. RR.Last);\n+   end \">\";\n+\n+   ----------\n+   -- \">=\" --\n+   ----------\n+\n+   function \">=\"\n+     (Left  : Unbounded_Wide_Wide_String;\n+      Right : Unbounded_Wide_Wide_String) return Boolean\n+   is\n+      LR : constant Shared_Wide_Wide_String_Access := Left.Reference;\n+      RR : constant Shared_Wide_Wide_String_Access := Right.Reference;\n+\n+   begin\n+      --  LR = RR means two strings shares shared string, thus they are equal\n+\n+      return LR = RR or else LR.Data (1 .. LR.Last) >= RR.Data (1 .. RR.Last);\n+   end \">=\";\n+\n+   function \">=\"\n+     (Left  : Unbounded_Wide_Wide_String;\n+      Right : Wide_Wide_String) return Boolean\n+   is\n+      LR : constant Shared_Wide_Wide_String_Access := Left.Reference;\n+   begin\n+      return LR.Data (1 .. LR.Last) >= Right;\n+   end \">=\";\n+\n+   function \">=\"\n+     (Left  : Wide_Wide_String;\n+      Right : Unbounded_Wide_Wide_String) return Boolean\n+   is\n+      RR : constant Shared_Wide_Wide_String_Access := Right.Reference;\n+   begin\n+      return Left >= RR.Data (1 .. RR.Last);\n+   end \">=\";\n+\n+   ------------\n+   -- Adjust --\n+   ------------\n+\n+   procedure Adjust (Object : in out Unbounded_Wide_Wide_String) is\n+   begin\n+      Reference (Object.Reference);\n+   end Adjust;\n+\n+   ------------------------\n+   -- Aligned_Max_Length --\n+   ------------------------\n+\n+   function Aligned_Max_Length (Max_Length : Natural) return Natural is\n+      Static_Size  : constant Natural :=\n+                       Empty_Shared_Wide_Wide_String'Size\n+                         / Standard'Storage_Unit;\n+      --  Total size of all static components\n+\n+      Element_Size : constant Natural :=\n+                       Wide_Wide_Character'Size / Standard'Storage_Unit;\n+\n+   begin\n+      return\n+        (((Static_Size + Max_Length * Element_Size - 1) / Min_Mul_Alloc + 2)\n+          * Min_Mul_Alloc - Static_Size) / Element_Size;\n+   end Aligned_Max_Length;\n+\n+   --------------\n+   -- Allocate --\n+   --------------\n+\n+   function Allocate\n+     (Max_Length : Natural) return Shared_Wide_Wide_String_Access is\n+   begin\n+      --  Empty string requested, return shared empty string\n+\n+      if Max_Length = 0 then\n+         Reference (Empty_Shared_Wide_Wide_String'Access);\n+         return Empty_Shared_Wide_Wide_String'Access;\n+\n+      --  Otherwise, allocate requested space (and probably some more room)\n+\n+      else\n+         return new Shared_Wide_Wide_String (Aligned_Max_Length (Max_Length));\n+      end if;\n+   end Allocate;\n+\n+   ------------\n+   -- Append --\n+   ------------\n+\n+   procedure Append\n+     (Source   : in out Unbounded_Wide_Wide_String;\n+      New_Item : Unbounded_Wide_Wide_String)\n+   is\n+      SR  : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+      NR  : constant Shared_Wide_Wide_String_Access := New_Item.Reference;\n+      DL  : constant Natural              := SR.Last + NR.Last;\n+      DR  : Shared_Wide_Wide_String_Access;\n+\n+   begin\n+      --  Source is an empty string, reuse New_Item data\n+\n+      if SR.Last = 0 then\n+         Reference (NR);\n+         Source.Reference := NR;\n+         Unreference (SR);\n+\n+      --  New_Item is empty string, nothing to do\n+\n+      elsif NR.Last = 0 then\n+         null;\n+\n+      --  Try to reuse existent shared string\n+\n+      elsif Can_Be_Reused (SR, DL) then\n+         SR.Data (SR.Last + 1 .. DL) := NR.Data (1 .. NR.Last);\n+         SR.Last := DL;\n+\n+      --  Otherwise, allocate new one and fill it\n+\n+      else\n+         DR := Allocate (DL + DL / Growth_Factor);\n+         DR.Data (1 .. SR.Last) := SR.Data (1 .. SR.Last);\n+         DR.Data (SR.Last + 1 .. DL) := NR.Data (1 .. NR.Last);\n+         DR.Last := DL;\n+         Source.Reference := DR;\n+         Unreference (SR);\n+      end if;\n+   end Append;\n+\n+   procedure Append\n+     (Source   : in out Unbounded_Wide_Wide_String;\n+      New_Item : Wide_Wide_String)\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+      DL : constant Natural := SR.Last + New_Item'Length;\n+      DR : Shared_Wide_Wide_String_Access;\n+\n+   begin\n+      --  New_Item is an empty string, nothing to do\n+\n+      if New_Item'Length = 0 then\n+         null;\n+\n+      --  Try to reuse existing shared string\n+\n+      elsif Can_Be_Reused (SR, DL) then\n+         SR.Data (SR.Last + 1 .. DL) := New_Item;\n+         SR.Last := DL;\n+\n+      --  Otherwise, allocate new one and fill it\n+\n+      else\n+         DR := Allocate (DL + DL / Growth_Factor);\n+         DR.Data (1 .. SR.Last) := SR.Data (1 .. SR.Last);\n+         DR.Data (SR.Last + 1 .. DL) := New_Item;\n+         DR.Last := DL;\n+         Source.Reference := DR;\n+         Unreference (SR);\n+      end if;\n+   end Append;\n+\n+   procedure Append\n+     (Source   : in out Unbounded_Wide_Wide_String;\n+      New_Item : Wide_Wide_Character)\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+      DL : constant Natural := SR.Last + 1;\n+      DR : Shared_Wide_Wide_String_Access;\n+\n+   begin\n+      --  Try to reuse existing shared string\n+\n+      if Can_Be_Reused (SR, SR.Last + 1) then\n+         SR.Data (SR.Last + 1) := New_Item;\n+         SR.Last := SR.Last + 1;\n+\n+      --  Otherwise, allocate new one and fill it\n+\n+      else\n+         DR := Allocate (DL + DL / Growth_Factor);\n+         DR.Data (1 .. SR.Last) := SR.Data (1 .. SR.Last);\n+         DR.Data (DL) := New_Item;\n+         DR.Last := DL;\n+         Source.Reference := DR;\n+         Unreference (SR);\n+      end if;\n+   end Append;\n+\n+   -------------------\n+   -- Can_Be_Reused --\n+   -------------------\n+\n+   function Can_Be_Reused\n+     (Item   : Shared_Wide_Wide_String_Access;\n+      Length : Natural) return Boolean\n+   is\n+      use Interfaces;\n+   begin\n+      return\n+        Item.Counter = 1\n+          and then Item.Max_Length >= Length\n+          and then Item.Max_Length <=\n+                     Aligned_Max_Length (Length + Length / Growth_Factor);\n+   end Can_Be_Reused;\n+\n+   -----------\n+   -- Count --\n+   -----------\n+\n+   function Count\n+     (Source  : Unbounded_Wide_Wide_String;\n+      Pattern : Wide_Wide_String;\n+      Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping :=\n+                  Wide_Wide_Maps.Identity)\n+      return Natural\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+   begin\n+      return Wide_Wide_Search.Count (SR.Data (1 .. SR.Last), Pattern, Mapping);\n+   end Count;\n+\n+   function Count\n+     (Source  : Unbounded_Wide_Wide_String;\n+      Pattern : Wide_Wide_String;\n+      Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping_Function)\n+      return Natural\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+   begin\n+      return Wide_Wide_Search.Count (SR.Data (1 .. SR.Last), Pattern, Mapping);\n+   end Count;\n+\n+   function Count\n+     (Source : Unbounded_Wide_Wide_String;\n+      Set    : Wide_Wide_Maps.Wide_Wide_Character_Set) return Natural\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+   begin\n+      return Wide_Wide_Search.Count (SR.Data (1 .. SR.Last), Set);\n+   end Count;\n+\n+   ------------\n+   -- Delete --\n+   ------------\n+\n+   function Delete\n+     (Source  : Unbounded_Wide_Wide_String;\n+      From    : Positive;\n+      Through : Natural) return Unbounded_Wide_Wide_String\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+      DL : Natural;\n+      DR : Shared_Wide_Wide_String_Access;\n+\n+   begin\n+      --  Empty slice is deleted, use the same shared string\n+\n+      if From > Through then\n+         Reference (SR);\n+         DR := SR;\n+\n+      --  Index is out of range\n+\n+      elsif Through > SR.Last then\n+         raise Index_Error;\n+\n+      --  Compute size of the result\n+\n+      else\n+         DL := SR.Last - (Through - From + 1);\n+\n+         --  Result is an empty string, reuse shared empty string\n+\n+         if DL = 0 then\n+            Reference (Empty_Shared_Wide_Wide_String'Access);\n+            DR := Empty_Shared_Wide_Wide_String'Access;\n+\n+         --  Otherwise, allocate new shared string and fill it\n+\n+         else\n+            DR := Allocate (DL);\n+            DR.Data (1 .. From - 1) := SR.Data (1 .. From - 1);\n+            DR.Data (From .. DL) := SR.Data (Through + 1 .. SR.Last);\n+            DR.Last := DL;\n+         end if;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end Delete;\n+\n+   procedure Delete\n+     (Source  : in out Unbounded_Wide_Wide_String;\n+      From    : Positive;\n+      Through : Natural)\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+      DL : Natural;\n+      DR : Shared_Wide_Wide_String_Access;\n+\n+   begin\n+      --  Nothing changed, return\n+\n+      if From > Through then\n+         null;\n+\n+      --  Through is outside of the range\n+\n+      elsif Through > SR.Last then\n+         raise Index_Error;\n+\n+      else\n+         DL := SR.Last - (Through - From + 1);\n+\n+         --  Result is empty, reuse shared empty string\n+\n+         if DL = 0 then\n+            Reference (Empty_Shared_Wide_Wide_String'Access);\n+            Source.Reference := Empty_Shared_Wide_Wide_String'Access;\n+            Unreference (SR);\n+\n+         --  Try to reuse existent shared string\n+\n+         elsif Can_Be_Reused (SR, DL) then\n+            SR.Data (From .. DL) := SR.Data (Through + 1 .. SR.Last);\n+            SR.Last := DL;\n+\n+         --  Otherwise, allocate new shared string\n+\n+         else\n+            DR := Allocate (DL);\n+            DR.Data (1 .. From - 1) := SR.Data (1 .. From - 1);\n+            DR.Data (From .. DL) := SR.Data (Through + 1 .. SR.Last);\n+            DR.Last := DL;\n+            Source.Reference := DR;\n+            Unreference (SR);\n+         end if;\n+      end if;\n+   end Delete;\n+\n+   -------------\n+   -- Element --\n+   -------------\n+\n+   function Element\n+     (Source : Unbounded_Wide_Wide_String;\n+      Index  : Positive) return Wide_Wide_Character\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+   begin\n+      if Index <= SR.Last then\n+         return SR.Data (Index);\n+      else\n+         raise Index_Error;\n+      end if;\n+   end Element;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (Object : in out Unbounded_Wide_Wide_String) is\n+      SR : constant Shared_Wide_Wide_String_Access := Object.Reference;\n+\n+   begin\n+      if SR /= null then\n+\n+         --  The same controlled object can be finalized several times for\n+         --  some reason. As per 7.6.1(24) this should have no ill effect,\n+         --  so we need to add a guard for the case of finalizing the same\n+         --  object twice.\n+\n+         Object.Reference := null;\n+         Unreference (SR);\n+      end if;\n+   end Finalize;\n+\n+   ----------------\n+   -- Find_Token --\n+   ----------------\n+\n+   procedure Find_Token\n+     (Source : Unbounded_Wide_Wide_String;\n+      Set    : Wide_Wide_Maps.Wide_Wide_Character_Set;\n+      Test   : Strings.Membership;\n+      First  : out Positive;\n+      Last   : out Natural)\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+   begin\n+      Wide_Wide_Search.Find_Token\n+        (SR.Data (1 .. SR.Last), Set, Test, First, Last);\n+   end Find_Token;\n+\n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free (X : in out Wide_Wide_String_Access) is\n+      procedure Deallocate is\n+         new Ada.Unchecked_Deallocation\n+               (Wide_Wide_String, Wide_Wide_String_Access);\n+   begin\n+      Deallocate (X);\n+   end Free;\n+\n+   ----------\n+   -- Head --\n+   ----------\n+\n+   function Head\n+     (Source : Unbounded_Wide_Wide_String;\n+      Count  : Natural;\n+      Pad    : Wide_Wide_Character := Wide_Wide_Space)\n+      return Unbounded_Wide_Wide_String\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+      DR : Shared_Wide_Wide_String_Access;\n+\n+   begin\n+      --  Result is empty, reuse shared empty string\n+\n+      if Count = 0 then\n+         Reference (Empty_Shared_Wide_Wide_String'Access);\n+         DR := Empty_Shared_Wide_Wide_String'Access;\n+\n+      --  Length of the string is the same as requested, reuse source shared\n+      --  string.\n+\n+      elsif Count = SR.Last then\n+         Reference (SR);\n+         DR := SR;\n+\n+      --  Otherwise, allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (Count);\n+\n+         --  Length of the source string is more than requested, copy\n+         --  corresponding slice.\n+\n+         if Count < SR.Last then\n+            DR.Data (1 .. Count) := SR.Data (1 .. Count);\n+\n+         --  Length of the source string is less then requested, copy all\n+         --  contents and fill others by Pad character.\n+\n+         else\n+            DR.Data (1 .. SR.Last) := SR.Data (1 .. SR.Last);\n+\n+            for J in SR.Last + 1 .. Count loop\n+               DR.Data (J) := Pad;\n+            end loop;\n+         end if;\n+\n+         DR.Last := Count;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end Head;\n+\n+   procedure Head\n+     (Source : in out Unbounded_Wide_Wide_String;\n+      Count  : Natural;\n+      Pad    : Wide_Wide_Character := Wide_Wide_Space)\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+      DR : Shared_Wide_Wide_String_Access;\n+\n+   begin\n+      --  Result is empty, reuse empty shared string\n+\n+      if Count = 0 then\n+         Reference (Empty_Shared_Wide_Wide_String'Access);\n+         Source.Reference := Empty_Shared_Wide_Wide_String'Access;\n+         Unreference (SR);\n+\n+      --  Result is same with source string, reuse source shared string\n+\n+      elsif Count = SR.Last then\n+         null;\n+\n+      --  Try to reuse existent shared string\n+\n+      elsif Can_Be_Reused (SR, Count) then\n+         if Count > SR.Last then\n+            for J in SR.Last + 1 .. Count loop\n+               SR.Data (J) := Pad;\n+            end loop;\n+         end if;\n+\n+         SR.Last := Count;\n+\n+      --  Otherwise, allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (Count);\n+\n+         --  Length of the source string is greater then requested, copy\n+         --  corresponding slice.\n+\n+         if Count < SR.Last then\n+            DR.Data (1 .. Count) := SR.Data (1 .. Count);\n+\n+         --  Length of the source string is less the requested, copy all\n+         --  exists data and fill others by Pad character.\n+\n+         else\n+            DR.Data (1 .. SR.Last) := SR.Data (1 .. SR.Last);\n+\n+            for J in SR.Last + 1 .. Count loop\n+               DR.Data (J) := Pad;\n+            end loop;\n+         end if;\n+\n+         DR.Last := Count;\n+         Source.Reference := DR;\n+         Unreference (SR);\n+      end if;\n+   end Head;\n+\n+   -----------\n+   -- Index --\n+   -----------\n+\n+   function Index\n+     (Source  : Unbounded_Wide_Wide_String;\n+      Pattern : Wide_Wide_String;\n+      Going   : Strings.Direction := Strings.Forward;\n+      Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping :=\n+                  Wide_Wide_Maps.Identity)\n+      return Natural\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+   begin\n+      return Wide_Wide_Search.Index\n+        (SR.Data (1 .. SR.Last), Pattern, Going, Mapping);\n+   end Index;\n+\n+   function Index\n+     (Source  : Unbounded_Wide_Wide_String;\n+      Pattern : Wide_Wide_String;\n+      Going   : Direction := Forward;\n+      Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping_Function)\n+      return Natural\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+   begin\n+      return Wide_Wide_Search.Index\n+        (SR.Data (1 .. SR.Last), Pattern, Going, Mapping);\n+   end Index;\n+\n+   function Index\n+     (Source : Unbounded_Wide_Wide_String;\n+      Set    : Wide_Wide_Maps.Wide_Wide_Character_Set;\n+      Test   : Strings.Membership := Strings.Inside;\n+      Going  : Strings.Direction  := Strings.Forward) return Natural\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+   begin\n+      return Wide_Wide_Search.Index (SR.Data (1 .. SR.Last), Set, Test, Going);\n+   end Index;\n+\n+   function Index\n+     (Source  : Unbounded_Wide_Wide_String;\n+      Pattern : Wide_Wide_String;\n+      From    : Positive;\n+      Going   : Direction := Forward;\n+      Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping :=\n+                  Wide_Wide_Maps.Identity)\n+      return Natural\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+   begin\n+      return Wide_Wide_Search.Index\n+        (SR.Data (1 .. SR.Last), Pattern, From, Going, Mapping);\n+   end Index;\n+\n+   function Index\n+     (Source  : Unbounded_Wide_Wide_String;\n+      Pattern : Wide_Wide_String;\n+      From    : Positive;\n+      Going   : Direction := Forward;\n+      Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping_Function)\n+      return Natural\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+   begin\n+      return Wide_Wide_Search.Index\n+        (SR.Data (1 .. SR.Last), Pattern, From, Going, Mapping);\n+   end Index;\n+\n+   function Index\n+     (Source  : Unbounded_Wide_Wide_String;\n+      Set     : Wide_Wide_Maps.Wide_Wide_Character_Set;\n+      From    : Positive;\n+      Test    : Membership := Inside;\n+      Going   : Direction := Forward) return Natural\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+   begin\n+      return Wide_Wide_Search.Index\n+        (SR.Data (1 .. SR.Last), Set, From, Test, Going);\n+   end Index;\n+\n+   ---------------------\n+   -- Index_Non_Blank --\n+   ---------------------\n+\n+   function Index_Non_Blank\n+     (Source : Unbounded_Wide_Wide_String;\n+      Going  : Strings.Direction := Strings.Forward) return Natural\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+   begin\n+      return Wide_Wide_Search.Index_Non_Blank (SR.Data (1 .. SR.Last), Going);\n+   end Index_Non_Blank;\n+\n+   function Index_Non_Blank\n+     (Source : Unbounded_Wide_Wide_String;\n+      From   : Positive;\n+      Going  : Direction := Forward) return Natural\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+   begin\n+      return Wide_Wide_Search.Index_Non_Blank\n+        (SR.Data (1 .. SR.Last), From, Going);\n+   end Index_Non_Blank;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (Object : in out Unbounded_Wide_Wide_String) is\n+   begin\n+      Reference (Object.Reference);\n+   end Initialize;\n+\n+   ------------\n+   -- Insert --\n+   ------------\n+\n+   function Insert\n+     (Source   : Unbounded_Wide_Wide_String;\n+      Before   : Positive;\n+      New_Item : Wide_Wide_String) return Unbounded_Wide_Wide_String\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+      DL : constant Natural := SR.Last + New_Item'Length;\n+      DR : Shared_Wide_Wide_String_Access;\n+\n+   begin\n+      --  Check index first\n+\n+      if Before > SR.Last + 1 then\n+         raise Index_Error;\n+      end if;\n+\n+      --  Result is empty, reuse empty shared string\n+\n+      if DL = 0 then\n+         Reference (Empty_Shared_Wide_Wide_String'Access);\n+         DR := Empty_Shared_Wide_Wide_String'Access;\n+\n+      --  Inserted string is empty, reuse source shared string\n+\n+      elsif New_Item'Length = 0 then\n+         Reference (SR);\n+         DR := SR;\n+\n+      --  Otherwise, allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (DL + DL / Growth_Factor);\n+         DR.Data (1 .. Before - 1) := SR.Data (1 .. Before - 1);\n+         DR.Data (Before .. Before + New_Item'Length - 1) := New_Item;\n+         DR.Data (Before + New_Item'Length .. DL) :=\n+           SR.Data (Before .. SR.Last);\n+         DR.Last := DL;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end Insert;\n+\n+   procedure Insert\n+     (Source   : in out Unbounded_Wide_Wide_String;\n+      Before   : Positive;\n+      New_Item : Wide_Wide_String)\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+      DL : constant Natural := SR.Last + New_Item'Length;\n+      DR : Shared_Wide_Wide_String_Access;\n+\n+   begin\n+      --  Check bounds\n+\n+      if Before > SR.Last + 1 then\n+         raise Index_Error;\n+      end if;\n+\n+      --  Result is empty string, reuse empty shared string\n+\n+      if DL = 0 then\n+         Reference (Empty_Shared_Wide_Wide_String'Access);\n+         Source.Reference := Empty_Shared_Wide_Wide_String'Access;\n+         Unreference (SR);\n+\n+      --  Inserted string is empty, nothing to do\n+\n+      elsif New_Item'Length = 0 then\n+         null;\n+\n+      --  Try to reuse existent shared string first\n+\n+      elsif Can_Be_Reused (SR, DL) then\n+         SR.Data (Before + New_Item'Length .. DL) :=\n+           SR.Data (Before .. SR.Last);\n+         SR.Data (Before .. Before + New_Item'Length - 1) := New_Item;\n+         SR.Last := DL;\n+\n+      --  Otherwise, allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (DL + DL / Growth_Factor);\n+         DR.Data (1 .. Before - 1) := SR.Data (1 .. Before - 1);\n+         DR.Data (Before .. Before + New_Item'Length - 1) := New_Item;\n+         DR.Data (Before + New_Item'Length .. DL) :=\n+           SR.Data (Before .. SR.Last);\n+         DR.Last := DL;\n+         Source.Reference := DR;\n+         Unreference (SR);\n+      end if;\n+   end Insert;\n+\n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (Source : Unbounded_Wide_Wide_String) return Natural is\n+   begin\n+      return Source.Reference.Last;\n+   end Length;\n+\n+   ---------------\n+   -- Overwrite --\n+   ---------------\n+\n+   function Overwrite\n+     (Source   : Unbounded_Wide_Wide_String;\n+      Position : Positive;\n+      New_Item : Wide_Wide_String) return Unbounded_Wide_Wide_String\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+      DL : Natural;\n+      DR : Shared_Wide_Wide_String_Access;\n+\n+   begin\n+      --  Check bounds\n+\n+      if Position > SR.Last + 1 then\n+         raise Index_Error;\n+      end if;\n+\n+      DL := Integer'Max (SR.Last, Position + New_Item'Length - 1);\n+\n+      --  Result is empty string, reuse empty shared string\n+\n+      if DL = 0 then\n+         Reference (Empty_Shared_Wide_Wide_String'Access);\n+         DR := Empty_Shared_Wide_Wide_String'Access;\n+\n+      --  Result is same with source string, reuse source shared string\n+\n+      elsif New_Item'Length = 0 then\n+         Reference (SR);\n+         DR := SR;\n+\n+      --  Otherwise, allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (DL);\n+         DR.Data (1 .. Position - 1) := SR.Data (1 .. Position - 1);\n+         DR.Data (Position .. Position + New_Item'Length - 1) := New_Item;\n+         DR.Data (Position + New_Item'Length .. DL) :=\n+           SR.Data (Position + New_Item'Length .. SR.Last);\n+         DR.Last := DL;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end Overwrite;\n+\n+   procedure Overwrite\n+     (Source    : in out Unbounded_Wide_Wide_String;\n+      Position  : Positive;\n+      New_Item  : Wide_Wide_String)\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+      DL : Natural;\n+      DR : Shared_Wide_Wide_String_Access;\n+\n+   begin\n+      --  Bounds check\n+\n+      if Position > SR.Last + 1 then\n+         raise Index_Error;\n+      end if;\n+\n+      DL := Integer'Max (SR.Last, Position + New_Item'Length - 1);\n+\n+      --  Result is empty string, reuse empty shared string\n+\n+      if DL = 0 then\n+         Reference (Empty_Shared_Wide_Wide_String'Access);\n+         Source.Reference := Empty_Shared_Wide_Wide_String'Access;\n+         Unreference (SR);\n+\n+      --  String unchanged, nothing to do\n+\n+      elsif New_Item'Length = 0 then\n+         null;\n+\n+      --  Try to reuse existent shared string\n+\n+      elsif Can_Be_Reused (SR, DL) then\n+         SR.Data (Position .. Position + New_Item'Length - 1) := New_Item;\n+         SR.Last := DL;\n+\n+      --  Otherwise allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (DL);\n+         DR.Data (1 .. Position - 1) := SR.Data (1 .. Position - 1);\n+         DR.Data (Position .. Position + New_Item'Length - 1) := New_Item;\n+         DR.Data (Position + New_Item'Length .. DL) :=\n+           SR.Data (Position + New_Item'Length .. SR.Last);\n+         DR.Last := DL;\n+         Source.Reference := DR;\n+         Unreference (SR);\n+      end if;\n+   end Overwrite;\n+\n+   ---------------\n+   -- Reference --\n+   ---------------\n+\n+   procedure Reference (Item : not null Shared_Wide_Wide_String_Access) is\n+   begin\n+      Sync_Add_And_Fetch (Item.Counter'Access, 1);\n+   end Reference;\n+\n+   ---------------------\n+   -- Replace_Element --\n+   ---------------------\n+\n+   procedure Replace_Element\n+     (Source : in out Unbounded_Wide_Wide_String;\n+      Index  : Positive;\n+      By     : Wide_Wide_Character)\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+      DR : Shared_Wide_Wide_String_Access;\n+\n+   begin\n+      --  Bounds check.\n+\n+      if Index <= SR.Last then\n+\n+         --  Try to reuse existent shared string\n+\n+         if Can_Be_Reused (SR, SR.Last) then\n+            SR.Data (Index) := By;\n+\n+         --  Otherwise allocate new shared string and fill it\n+\n+         else\n+            DR := Allocate (SR.Last);\n+            DR.Data (1 .. SR.Last) := SR.Data (1 .. SR.Last);\n+            DR.Data (Index) := By;\n+            DR.Last := SR.Last;\n+            Source.Reference := DR;\n+            Unreference (SR);\n+         end if;\n+\n+      else\n+         raise Index_Error;\n+      end if;\n+   end Replace_Element;\n+\n+   -------------------\n+   -- Replace_Slice --\n+   -------------------\n+\n+   function Replace_Slice\n+     (Source : Unbounded_Wide_Wide_String;\n+      Low    : Positive;\n+      High   : Natural;\n+      By     : Wide_Wide_String) return Unbounded_Wide_Wide_String\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+      DL : Natural;\n+      DR : Shared_Wide_Wide_String_Access;\n+\n+   begin\n+      --  Check bounds\n+\n+      if Low > SR.Last + 1 then\n+         raise Index_Error;\n+      end if;\n+\n+      --  Do replace operation when removed slice is not empty\n+\n+      if High >= Low then\n+         DL := By'Length + SR.Last + Low - High - 1;\n+\n+         --  Result is empty string, reuse empty shared string\n+\n+         if DL = 0 then\n+            Reference (Empty_Shared_Wide_Wide_String'Access);\n+            DR := Empty_Shared_Wide_Wide_String'Access;\n+\n+         --  Otherwise allocate new shared string and fill it\n+\n+         else\n+            DR := Allocate (DL);\n+            DR.Data (1 .. Low - 1) := SR.Data (1 .. Low - 1);\n+            DR.Data (Low .. Low + By'Length - 1) := By;\n+            DR.Data (Low + By'Length .. DL) := SR.Data (High + 1 .. SR.Last);\n+            DR.Last := DL;\n+         end if;\n+\n+         return (AF.Controlled with Reference => DR);\n+\n+      --  Otherwise just insert string\n+\n+      else\n+         return Insert (Source, Low, By);\n+      end if;\n+   end Replace_Slice;\n+\n+   procedure Replace_Slice\n+     (Source : in out Unbounded_Wide_Wide_String;\n+      Low    : Positive;\n+      High   : Natural;\n+      By     : Wide_Wide_String)\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+      DL : Natural;\n+      DR : Shared_Wide_Wide_String_Access;\n+\n+   begin\n+      --  Bounds check\n+\n+      if Low > SR.Last + 1 then\n+         raise Index_Error;\n+      end if;\n+\n+      --  Do replace operation only when replaced slice is not empty\n+\n+      if High >= Low then\n+         DL := By'Length + SR.Last + Low - High - 1;\n+\n+         --  Result is empty string, reuse empty shared string\n+\n+         if DL = 0 then\n+            Reference (Empty_Shared_Wide_Wide_String'Access);\n+            Source.Reference := Empty_Shared_Wide_Wide_String'Access;\n+            Unreference (SR);\n+\n+         --  Try to reuse existent shared string\n+\n+         elsif Can_Be_Reused (SR, DL) then\n+            SR.Data (Low + By'Length .. DL) := SR.Data (High + 1 .. SR.Last);\n+            SR.Data (Low .. Low + By'Length - 1) := By;\n+            SR.Last := DL;\n+\n+         --  Otherwise allocate new shared string and fill it\n+\n+         else\n+            DR := Allocate (DL);\n+            DR.Data (1 .. Low - 1) := SR.Data (1 .. Low - 1);\n+            DR.Data (Low .. Low + By'Length - 1) := By;\n+            DR.Data (Low + By'Length .. DL) := SR.Data (High + 1 .. SR.Last);\n+            DR.Last := DL;\n+            Source.Reference := DR;\n+            Unreference (SR);\n+         end if;\n+\n+      --  Otherwise just insert item\n+\n+      else\n+         Insert (Source, Low, By);\n+      end if;\n+   end Replace_Slice;\n+\n+   -------------------------------\n+   -- Set_Unbounded_Wide_Wide_String --\n+   -------------------------------\n+\n+   procedure Set_Unbounded_Wide_Wide_String\n+     (Target : out Unbounded_Wide_Wide_String;\n+      Source : Wide_Wide_String)\n+   is\n+      TR : constant Shared_Wide_Wide_String_Access := Target.Reference;\n+      DR : Shared_Wide_Wide_String_Access;\n+\n+   begin\n+      --  In case of empty string, reuse empty shared string\n+\n+      if Source'Length = 0 then\n+         Reference (Empty_Shared_Wide_Wide_String'Access);\n+         Target.Reference := Empty_Shared_Wide_Wide_String'Access;\n+\n+      else\n+         --  Try to reuse existent shared string\n+\n+         if Can_Be_Reused (TR, Source'Length) then\n+            Reference (TR);\n+            DR := TR;\n+\n+         --  Otherwise allocate new shared string\n+\n+         else\n+            DR := Allocate (Source'Length);\n+            Target.Reference := DR;\n+         end if;\n+\n+         DR.Data (1 .. Source'Length) := Source;\n+         DR.Last := Source'Length;\n+      end if;\n+\n+      Unreference (TR);\n+   end Set_Unbounded_Wide_Wide_String;\n+\n+   -----------\n+   -- Slice --\n+   -----------\n+\n+   function Slice\n+     (Source : Unbounded_Wide_Wide_String;\n+      Low    : Positive;\n+      High   : Natural) return Wide_Wide_String\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+\n+   begin\n+      --  Note: test of High > Length is in accordance with AI95-00128\n+\n+      if Low > SR.Last + 1 or else High > SR.Last then\n+         raise Index_Error;\n+\n+      else\n+         return SR.Data (Low .. High);\n+      end if;\n+   end Slice;\n+\n+   ----------\n+   -- Tail --\n+   ----------\n+\n+   function Tail\n+     (Source : Unbounded_Wide_Wide_String;\n+      Count  : Natural;\n+      Pad    : Wide_Wide_Character := Wide_Wide_Space)\n+      return Unbounded_Wide_Wide_String\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+      DR : Shared_Wide_Wide_String_Access;\n+\n+   begin\n+      --  For empty result reuse empty shared string\n+\n+      if Count = 0 then\n+         Reference (Empty_Shared_Wide_Wide_String'Access);\n+         DR := Empty_Shared_Wide_Wide_String'Access;\n+\n+      --  Result is hole source string, reuse source shared string\n+\n+      elsif Count = SR.Last then\n+         Reference (SR);\n+         DR := SR;\n+\n+      --  Otherwise allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (Count);\n+\n+         if Count < SR.Last then\n+            DR.Data (1 .. Count) := SR.Data (SR.Last - Count + 1 .. SR.Last);\n+\n+         else\n+            for J in 1 .. Count - SR.Last loop\n+               DR.Data (J) := Pad;\n+            end loop;\n+\n+            DR.Data (Count - SR.Last + 1 .. Count) := SR.Data (1 .. SR.Last);\n+         end if;\n+\n+         DR.Last := Count;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end Tail;\n+\n+   procedure Tail\n+     (Source : in out Unbounded_Wide_Wide_String;\n+      Count  : Natural;\n+      Pad    : Wide_Wide_Character := Wide_Wide_Space)\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+      DR : Shared_Wide_Wide_String_Access;\n+\n+      procedure Common\n+        (SR    : Shared_Wide_Wide_String_Access;\n+         DR    : Shared_Wide_Wide_String_Access;\n+         Count : Natural);\n+      --  Common code of tail computation. SR/DR can point to the same object\n+\n+      ------------\n+      -- Common --\n+      ------------\n+\n+      procedure Common\n+        (SR    : Shared_Wide_Wide_String_Access;\n+         DR    : Shared_Wide_Wide_String_Access;\n+         Count : Natural) is\n+      begin\n+         if Count < SR.Last then\n+            DR.Data (1 .. Count) := SR.Data (SR.Last - Count + 1 .. SR.Last);\n+\n+         else\n+            DR.Data (Count - SR.Last + 1 .. Count) := SR.Data (1 .. SR.Last);\n+\n+            for J in 1 .. Count - SR.Last loop\n+               DR.Data (J) := Pad;\n+            end loop;\n+         end if;\n+\n+         DR.Last := Count;\n+      end Common;\n+\n+   begin\n+      --  Result is empty string, reuse empty shared string\n+\n+      if Count = 0 then\n+         Reference (Empty_Shared_Wide_Wide_String'Access);\n+         Source.Reference := Empty_Shared_Wide_Wide_String'Access;\n+         Unreference (SR);\n+\n+      --  Length of the result is the same with length of the source string,\n+      --  reuse source shared string.\n+\n+      elsif Count = SR.Last then\n+         null;\n+\n+      --  Try to reuse existent shared string\n+\n+      elsif Can_Be_Reused (SR, Count) then\n+         Common (SR, SR, Count);\n+\n+      --  Otherwise allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (Count);\n+         Common (SR, DR, Count);\n+         Source.Reference := DR;\n+         Unreference (SR);\n+      end if;\n+   end Tail;\n+\n+   --------------------\n+   -- To_Wide_Wide_String --\n+   --------------------\n+\n+   function To_Wide_Wide_String\n+     (Source : Unbounded_Wide_Wide_String) return Wide_Wide_String is\n+   begin\n+      return Source.Reference.Data (1 .. Source.Reference.Last);\n+   end To_Wide_Wide_String;\n+\n+   ------------------------------\n+   -- To_Unbounded_Wide_Wide_String --\n+   ------------------------------\n+\n+   function To_Unbounded_Wide_Wide_String\n+     (Source : Wide_Wide_String) return Unbounded_Wide_Wide_String\n+   is\n+      DR : constant Shared_Wide_Wide_String_Access := Allocate (Source'Length);\n+   begin\n+      DR.Data (1 .. Source'Length) := Source;\n+      DR.Last := Source'Length;\n+      return (AF.Controlled with Reference => DR);\n+   end To_Unbounded_Wide_Wide_String;\n+\n+   function To_Unbounded_Wide_Wide_String\n+     (Length : Natural) return Unbounded_Wide_Wide_String\n+   is\n+      DR : constant Shared_Wide_Wide_String_Access := Allocate (Length);\n+   begin\n+      DR.Last := Length;\n+      return (AF.Controlled with Reference => DR);\n+   end To_Unbounded_Wide_Wide_String;\n+\n+   ---------------\n+   -- Translate --\n+   ---------------\n+\n+   function Translate\n+     (Source  : Unbounded_Wide_Wide_String;\n+      Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping)\n+      return Unbounded_Wide_Wide_String\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+      DR : Shared_Wide_Wide_String_Access;\n+\n+   begin\n+      --  Nothing to translate, reuse empty shared string\n+\n+      if SR.Last = 0 then\n+         Reference (Empty_Shared_Wide_Wide_String'Access);\n+         DR := Empty_Shared_Wide_Wide_String'Access;\n+\n+      --  Otherwise, allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (SR.Last);\n+\n+         for J in 1 .. SR.Last loop\n+            DR.Data (J) := Value (Mapping, SR.Data (J));\n+         end loop;\n+\n+         DR.Last := SR.Last;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end Translate;\n+\n+   procedure Translate\n+     (Source  : in out Unbounded_Wide_Wide_String;\n+      Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping)\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+      DR : Shared_Wide_Wide_String_Access;\n+\n+   begin\n+      --  Nothing to translate\n+\n+      if SR.Last = 0 then\n+         null;\n+\n+      --  Try to reuse shared string\n+\n+      elsif Can_Be_Reused (SR, SR.Last) then\n+         for J in 1 .. SR.Last loop\n+            SR.Data (J) := Value (Mapping, SR.Data (J));\n+         end loop;\n+\n+      --  Otherwise, allocate new shared string\n+\n+      else\n+         DR := Allocate (SR.Last);\n+\n+         for J in 1 .. SR.Last loop\n+            DR.Data (J) := Value (Mapping, SR.Data (J));\n+         end loop;\n+\n+         DR.Last := SR.Last;\n+         Source.Reference := DR;\n+         Unreference (SR);\n+      end if;\n+   end Translate;\n+\n+   function Translate\n+     (Source  : Unbounded_Wide_Wide_String;\n+      Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping_Function)\n+      return Unbounded_Wide_Wide_String\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+      DR : Shared_Wide_Wide_String_Access;\n+\n+   begin\n+      --  Nothing to translate, reuse empty shared string\n+\n+      if SR.Last = 0 then\n+         Reference (Empty_Shared_Wide_Wide_String'Access);\n+         DR := Empty_Shared_Wide_Wide_String'Access;\n+\n+      --  Otherwise, allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (SR.Last);\n+\n+         for J in 1 .. SR.Last loop\n+            DR.Data (J) := Mapping.all (SR.Data (J));\n+         end loop;\n+\n+         DR.Last := SR.Last;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+\n+   exception\n+      when others =>\n+         Unreference (DR);\n+\n+         raise;\n+   end Translate;\n+\n+   procedure Translate\n+     (Source  : in out Unbounded_Wide_Wide_String;\n+      Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping_Function)\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+      DR : Shared_Wide_Wide_String_Access;\n+\n+   begin\n+      --  Nothing to translate\n+\n+      if SR.Last = 0 then\n+         null;\n+\n+      --  Try to reuse shared string\n+\n+      elsif Can_Be_Reused (SR, SR.Last) then\n+         for J in 1 .. SR.Last loop\n+            SR.Data (J) := Mapping.all (SR.Data (J));\n+         end loop;\n+\n+      --  Otherwise allocate new shared string and fill it\n+\n+      else\n+         DR := Allocate (SR.Last);\n+\n+         for J in 1 .. SR.Last loop\n+            DR.Data (J) := Mapping.all (SR.Data (J));\n+         end loop;\n+\n+         DR.Last := SR.Last;\n+         Source.Reference := DR;\n+         Unreference (SR);\n+      end if;\n+\n+   exception\n+      when others =>\n+         if DR /= null then\n+            Unreference (DR);\n+         end if;\n+\n+         raise;\n+   end Translate;\n+\n+   ----------\n+   -- Trim --\n+   ----------\n+\n+   function Trim\n+     (Source : Unbounded_Wide_Wide_String;\n+      Side   : Trim_End) return Unbounded_Wide_Wide_String\n+   is\n+      SR   : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+      DL   : Natural;\n+      DR   : Shared_Wide_Wide_String_Access;\n+      Low  : Natural;\n+      High : Natural;\n+\n+   begin\n+      Low := Index_Non_Blank (Source, Forward);\n+\n+      --  All blanks, reuse empty shared string\n+\n+      if Low = 0 then\n+         Reference (Empty_Shared_Wide_Wide_String'Access);\n+         DR := Empty_Shared_Wide_Wide_String'Access;\n+\n+      else\n+         case Side is\n+            when Left =>\n+               High := SR.Last;\n+               DL   := SR.Last - Low + 1;\n+\n+            when Right =>\n+               Low  := 1;\n+               High := Index_Non_Blank (Source, Backward);\n+               DL   := High;\n+\n+            when Both =>\n+               High := Index_Non_Blank (Source, Backward);\n+               DL   := High - Low + 1;\n+         end case;\n+\n+         --  Length of the result is the same as length of the source string,\n+         --  reuse source shared string.\n+\n+         if DL = SR.Last then\n+            Reference (SR);\n+            DR := SR;\n+\n+         --  Otherwise, allocate new shared string\n+\n+         else\n+            DR := Allocate (DL);\n+            DR.Data (1 .. DL) := SR.Data (Low .. High);\n+            DR.Last := DL;\n+         end if;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end Trim;\n+\n+   procedure Trim\n+     (Source : in out Unbounded_Wide_Wide_String;\n+      Side   : Trim_End)\n+   is\n+      SR   : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+      DL   : Natural;\n+      DR   : Shared_Wide_Wide_String_Access;\n+      Low  : Natural;\n+      High : Natural;\n+\n+   begin\n+      Low := Index_Non_Blank (Source, Forward);\n+\n+      --  All blanks, reuse empty shared string\n+\n+      if Low = 0 then\n+         Reference (Empty_Shared_Wide_Wide_String'Access);\n+         Source.Reference := Empty_Shared_Wide_Wide_String'Access;\n+         Unreference (SR);\n+\n+      else\n+         case Side is\n+            when Left =>\n+               High := SR.Last;\n+               DL   := SR.Last - Low + 1;\n+\n+            when Right =>\n+               Low  := 1;\n+               High := Index_Non_Blank (Source, Backward);\n+               DL   := High;\n+\n+            when Both =>\n+               High := Index_Non_Blank (Source, Backward);\n+               DL   := High - Low + 1;\n+         end case;\n+\n+         --  Length of the result is the same as length of the source string,\n+         --  nothing to do.\n+\n+         if DL = SR.Last then\n+            null;\n+\n+         --  Try to reuse existent shared string\n+\n+         elsif Can_Be_Reused (SR, DL) then\n+            SR.Data (1 .. DL) := SR.Data (Low .. High);\n+            SR.Last := DL;\n+\n+         --  Otherwise, allocate new shared string\n+\n+         else\n+            DR := Allocate (DL);\n+            DR.Data (1 .. DL) := SR.Data (Low .. High);\n+            DR.Last := DL;\n+            Source.Reference := DR;\n+            Unreference (SR);\n+         end if;\n+      end if;\n+   end Trim;\n+\n+   function Trim\n+     (Source : Unbounded_Wide_Wide_String;\n+      Left   : Wide_Wide_Maps.Wide_Wide_Character_Set;\n+      Right  : Wide_Wide_Maps.Wide_Wide_Character_Set)\n+      return Unbounded_Wide_Wide_String\n+   is\n+      SR   : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+      DL   : Natural;\n+      DR   : Shared_Wide_Wide_String_Access;\n+      Low  : Natural;\n+      High : Natural;\n+\n+   begin\n+      Low := Index (Source, Left, Outside, Forward);\n+\n+      --  Source includes only characters from Left set, reuse empty shared\n+      --  string.\n+\n+      if Low = 0 then\n+         Reference (Empty_Shared_Wide_Wide_String'Access);\n+         DR := Empty_Shared_Wide_Wide_String'Access;\n+\n+      else\n+         High := Index (Source, Right, Outside, Backward);\n+         DL   := Integer'Max (0, High - Low + 1);\n+\n+         --  Source includes only characters from Right set or result string\n+         --  is empty, reuse empty shared string.\n+\n+         if High = 0 or else DL = 0 then\n+            Reference (Empty_Shared_Wide_Wide_String'Access);\n+            DR := Empty_Shared_Wide_Wide_String'Access;\n+\n+         --  Otherwise, allocate new shared string and fill it\n+\n+         else\n+            DR := Allocate (DL);\n+            DR.Data (1 .. DL) := SR.Data (Low .. High);\n+            DR.Last := DL;\n+         end if;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end Trim;\n+\n+   procedure Trim\n+     (Source : in out Unbounded_Wide_Wide_String;\n+      Left   : Wide_Wide_Maps.Wide_Wide_Character_Set;\n+      Right  : Wide_Wide_Maps.Wide_Wide_Character_Set)\n+   is\n+      SR   : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+      DL   : Natural;\n+      DR   : Shared_Wide_Wide_String_Access;\n+      Low  : Natural;\n+      High : Natural;\n+\n+   begin\n+      Low := Index (Source, Left, Outside, Forward);\n+\n+      --  Source includes only characters from Left set, reuse empty shared\n+      --  string.\n+\n+      if Low = 0 then\n+         Reference (Empty_Shared_Wide_Wide_String'Access);\n+         Source.Reference := Empty_Shared_Wide_Wide_String'Access;\n+         Unreference (SR);\n+\n+      else\n+         High := Index (Source, Right, Outside, Backward);\n+         DL   := Integer'Max (0, High - Low + 1);\n+\n+         --  Source includes only characters from Right set or result string\n+         --  is empty, reuse empty shared string.\n+\n+         if High = 0 or else DL = 0 then\n+            Reference (Empty_Shared_Wide_Wide_String'Access);\n+            Source.Reference := Empty_Shared_Wide_Wide_String'Access;\n+            Unreference (SR);\n+\n+         --  Try to reuse existent shared string\n+\n+         elsif Can_Be_Reused (SR, DL) then\n+            SR.Data (1 .. DL) := SR.Data (Low .. High);\n+            SR.Last := DL;\n+\n+         --  Otherwise, allocate new shared string and fill it\n+\n+         else\n+            DR := Allocate (DL);\n+            DR.Data (1 .. DL) := SR.Data (Low .. High);\n+            DR.Last := DL;\n+            Source.Reference := DR;\n+            Unreference (SR);\n+         end if;\n+      end if;\n+   end Trim;\n+\n+   ---------------------\n+   -- Unbounded_Slice --\n+   ---------------------\n+\n+   function Unbounded_Slice\n+     (Source : Unbounded_Wide_Wide_String;\n+      Low    : Positive;\n+      High   : Natural) return Unbounded_Wide_Wide_String\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+      DL : Natural;\n+      DR : Shared_Wide_Wide_String_Access;\n+\n+   begin\n+      --  Check bounds\n+\n+      if Low > SR.Last + 1 or else High > SR.Last then\n+         raise Index_Error;\n+\n+      --  Result is empty slice, reuse empty shared string\n+\n+      elsif Low > High then\n+         Reference (Empty_Shared_Wide_Wide_String'Access);\n+         DR := Empty_Shared_Wide_Wide_String'Access;\n+\n+      --  Otherwise, allocate new shared string and fill it\n+\n+      else\n+         DL := High - Low + 1;\n+         DR := Allocate (DL);\n+         DR.Data (1 .. DL) := SR.Data (Low .. High);\n+         DR.Last := DL;\n+      end if;\n+\n+      return (AF.Controlled with Reference => DR);\n+   end Unbounded_Slice;\n+\n+   procedure Unbounded_Slice\n+     (Source : Unbounded_Wide_Wide_String;\n+      Target : out Unbounded_Wide_Wide_String;\n+      Low    : Positive;\n+      High   : Natural)\n+   is\n+      SR : constant Shared_Wide_Wide_String_Access := Source.Reference;\n+      TR : constant Shared_Wide_Wide_String_Access := Target.Reference;\n+      DL : Natural;\n+      DR : Shared_Wide_Wide_String_Access;\n+\n+   begin\n+      --  Check bounds\n+\n+      if Low > SR.Last + 1 or else High > SR.Last then\n+         raise Index_Error;\n+\n+      --  Result is empty slice, reuse empty shared string\n+\n+      elsif Low > High then\n+         Reference (Empty_Shared_Wide_Wide_String'Access);\n+         Target.Reference := Empty_Shared_Wide_Wide_String'Access;\n+         Unreference (TR);\n+\n+      else\n+         DL := High - Low + 1;\n+\n+         --  Try to reuse existent shared string\n+\n+         if Can_Be_Reused (TR, DL) then\n+            TR.Data (1 .. DL) := SR.Data (Low .. High);\n+            TR.Last := DL;\n+\n+         --  Otherwise, allocate new shared string and fill it\n+\n+         else\n+            DR := Allocate (DL);\n+            DR.Data (1 .. DL) := SR.Data (Low .. High);\n+            DR.Last := DL;\n+            Target.Reference := DR;\n+            Unreference (TR);\n+         end if;\n+      end if;\n+   end Unbounded_Slice;\n+\n+   -----------------\n+   -- Unreference --\n+   -----------------\n+\n+   procedure Unreference (Item : not null Shared_Wide_Wide_String_Access) is\n+      use Interfaces;\n+\n+      procedure Free is\n+        new Ada.Unchecked_Deallocation\n+              (Shared_Wide_Wide_String, Shared_Wide_Wide_String_Access);\n+\n+      Aux : Shared_Wide_Wide_String_Access := Item;\n+\n+   begin\n+      if Sync_Sub_And_Fetch (Aux.Counter'Access, 1) = 0 then\n+\n+         --  Reference counter of Empty_Shared_Wide_Wide_String must never\n+         --  reach zero.\n+\n+         pragma Assert (Aux /= Empty_Shared_Wide_Wide_String'Access);\n+\n+         Free (Aux);\n+      end if;\n+   end Unreference;\n+\n+end Ada.Strings.Wide_Wide_Unbounded;"}, {"sha": "4617f56fdc237522b9fb3683fe251573bc11b211", "filename": "gcc/ada/a-stzunb-shared.ads", "status": "added", "additions": 501, "deletions": 0, "changes": 501, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fa-stzunb-shared.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fa-stzunb-shared.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stzunb-shared.ads?ref=6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5", "patch": "@@ -0,0 +1,501 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--      A D A . S T R I N G S . W I D E _ W I D E _ U N B O U N D E D       --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This version is supported on:\n+--    - all Alpha platforms\n+--    - all ia64 platforms\n+--    - all PowerPC platforms\n+--    - all SPARC V9 platforms\n+--    - all x86_64 platforms\n+\n+with Ada.Strings.Wide_Wide_Maps;\n+private with Ada.Finalization;\n+private with Interfaces;\n+\n+package Ada.Strings.Wide_Wide_Unbounded is\n+   pragma Preelaborate;\n+\n+   type Unbounded_Wide_Wide_String is private;\n+   pragma Preelaborable_Initialization (Unbounded_Wide_Wide_String);\n+\n+   Null_Unbounded_Wide_Wide_String : constant Unbounded_Wide_Wide_String;\n+\n+   function Length (Source : Unbounded_Wide_Wide_String) return Natural;\n+\n+   type Wide_Wide_String_Access is access all Wide_Wide_String;\n+\n+   procedure Free (X : in out Wide_Wide_String_Access);\n+\n+   --------------------------------------------------------\n+   -- Conversion, Concatenation, and Selection Functions --\n+   --------------------------------------------------------\n+\n+   function To_Unbounded_Wide_Wide_String\n+     (Source : Wide_Wide_String) return Unbounded_Wide_Wide_String;\n+\n+   function To_Unbounded_Wide_Wide_String\n+     (Length : Natural) return Unbounded_Wide_Wide_String;\n+\n+   function To_Wide_Wide_String\n+     (Source : Unbounded_Wide_Wide_String) return Wide_Wide_String;\n+\n+   procedure Set_Unbounded_Wide_Wide_String\n+     (Target : out Unbounded_Wide_Wide_String;\n+      Source : Wide_Wide_String);\n+   pragma Ada_05 (Set_Unbounded_Wide_Wide_String);\n+\n+   procedure Append\n+     (Source   : in out Unbounded_Wide_Wide_String;\n+      New_Item : Unbounded_Wide_Wide_String);\n+\n+   procedure Append\n+     (Source   : in out Unbounded_Wide_Wide_String;\n+      New_Item : Wide_Wide_String);\n+\n+   procedure Append\n+     (Source   : in out Unbounded_Wide_Wide_String;\n+      New_Item : Wide_Wide_Character);\n+\n+   function \"&\"\n+     (Left  : Unbounded_Wide_Wide_String;\n+      Right : Unbounded_Wide_Wide_String) return Unbounded_Wide_Wide_String;\n+\n+   function \"&\"\n+     (Left  : Unbounded_Wide_Wide_String;\n+      Right : Wide_Wide_String) return Unbounded_Wide_Wide_String;\n+\n+   function \"&\"\n+     (Left  : Wide_Wide_String;\n+      Right : Unbounded_Wide_Wide_String) return Unbounded_Wide_Wide_String;\n+\n+   function \"&\"\n+     (Left  : Unbounded_Wide_Wide_String;\n+      Right : Wide_Wide_Character) return Unbounded_Wide_Wide_String;\n+\n+   function \"&\"\n+     (Left  : Wide_Wide_Character;\n+      Right : Unbounded_Wide_Wide_String) return Unbounded_Wide_Wide_String;\n+\n+   function Element\n+     (Source : Unbounded_Wide_Wide_String;\n+      Index  : Positive) return Wide_Wide_Character;\n+\n+   procedure Replace_Element\n+     (Source : in out Unbounded_Wide_Wide_String;\n+      Index  : Positive;\n+      By     : Wide_Wide_Character);\n+\n+   function Slice\n+     (Source : Unbounded_Wide_Wide_String;\n+      Low    : Positive;\n+      High   : Natural) return Wide_Wide_String;\n+\n+   function Unbounded_Slice\n+     (Source : Unbounded_Wide_Wide_String;\n+      Low    : Positive;\n+      High   : Natural) return Unbounded_Wide_Wide_String;\n+   pragma Ada_05 (Unbounded_Slice);\n+\n+   procedure Unbounded_Slice\n+     (Source : Unbounded_Wide_Wide_String;\n+      Target : out Unbounded_Wide_Wide_String;\n+      Low    : Positive;\n+      High   : Natural);\n+   pragma Ada_05 (Unbounded_Slice);\n+\n+   function \"=\"\n+     (Left  : Unbounded_Wide_Wide_String;\n+      Right : Unbounded_Wide_Wide_String) return Boolean;\n+\n+   function \"=\"\n+     (Left  : Unbounded_Wide_Wide_String;\n+      Right : Wide_Wide_String) return Boolean;\n+\n+   function \"=\"\n+     (Left  : Wide_Wide_String;\n+      Right : Unbounded_Wide_Wide_String) return Boolean;\n+\n+   function \"<\"\n+     (Left  : Unbounded_Wide_Wide_String;\n+      Right : Unbounded_Wide_Wide_String) return Boolean;\n+\n+   function \"<\"\n+     (Left  : Unbounded_Wide_Wide_String;\n+      Right : Wide_Wide_String) return Boolean;\n+\n+   function \"<\"\n+     (Left  : Wide_Wide_String;\n+      Right : Unbounded_Wide_Wide_String) return Boolean;\n+\n+   function \"<=\"\n+     (Left  : Unbounded_Wide_Wide_String;\n+      Right : Unbounded_Wide_Wide_String) return Boolean;\n+\n+   function \"<=\"\n+     (Left  : Unbounded_Wide_Wide_String;\n+      Right : Wide_Wide_String) return Boolean;\n+\n+   function \"<=\"\n+     (Left  : Wide_Wide_String;\n+      Right : Unbounded_Wide_Wide_String) return Boolean;\n+\n+   function \">\"\n+     (Left  : Unbounded_Wide_Wide_String;\n+      Right : Unbounded_Wide_Wide_String) return Boolean;\n+\n+   function \">\"\n+     (Left  : Unbounded_Wide_Wide_String;\n+      Right : Wide_Wide_String) return Boolean;\n+\n+   function \">\"\n+     (Left  : Wide_Wide_String;\n+      Right : Unbounded_Wide_Wide_String) return Boolean;\n+\n+   function \">=\"\n+     (Left  : Unbounded_Wide_Wide_String;\n+      Right : Unbounded_Wide_Wide_String) return Boolean;\n+\n+   function \">=\"\n+     (Left  : Unbounded_Wide_Wide_String;\n+      Right : Wide_Wide_String) return Boolean;\n+\n+   function \">=\"\n+     (Left  : Wide_Wide_String;\n+      Right : Unbounded_Wide_Wide_String) return Boolean;\n+\n+   ------------------------\n+   -- Search Subprograms --\n+   ------------------------\n+\n+   function Index\n+     (Source  : Unbounded_Wide_Wide_String;\n+      Pattern : Wide_Wide_String;\n+      Going   : Direction := Forward;\n+      Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping :=\n+                  Wide_Wide_Maps.Identity)\n+      return Natural;\n+\n+   function Index\n+     (Source  : Unbounded_Wide_Wide_String;\n+      Pattern : Wide_Wide_String;\n+      Going   : Direction := Forward;\n+      Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping_Function)\n+      return Natural;\n+\n+   function Index\n+     (Source : Unbounded_Wide_Wide_String;\n+      Set    : Wide_Wide_Maps.Wide_Wide_Character_Set;\n+      Test   : Membership := Inside;\n+      Going  : Direction  := Forward) return Natural;\n+\n+   function Index\n+     (Source  : Unbounded_Wide_Wide_String;\n+      Pattern : Wide_Wide_String;\n+      From    : Positive;\n+      Going   : Direction := Forward;\n+      Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping :=\n+                  Wide_Wide_Maps.Identity)\n+      return Natural;\n+   pragma Ada_05 (Index);\n+\n+   function Index\n+     (Source  : Unbounded_Wide_Wide_String;\n+      Pattern : Wide_Wide_String;\n+      From    : Positive;\n+      Going   : Direction := Forward;\n+      Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping_Function)\n+      return Natural;\n+   pragma Ada_05 (Index);\n+\n+   function Index\n+     (Source  : Unbounded_Wide_Wide_String;\n+      Set     : Wide_Wide_Maps.Wide_Wide_Character_Set;\n+      From    : Positive;\n+      Test    : Membership := Inside;\n+      Going   : Direction := Forward) return Natural;\n+   pragma Ada_05 (Index);\n+\n+   function Index_Non_Blank\n+     (Source : Unbounded_Wide_Wide_String;\n+      Going  : Direction := Forward) return Natural;\n+\n+   function Index_Non_Blank\n+     (Source : Unbounded_Wide_Wide_String;\n+      From   : Positive;\n+      Going  : Direction := Forward) return Natural;\n+   pragma Ada_05 (Index_Non_Blank);\n+\n+   function Count\n+     (Source  : Unbounded_Wide_Wide_String;\n+      Pattern : Wide_Wide_String;\n+      Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping :=\n+                  Wide_Wide_Maps.Identity)\n+      return Natural;\n+\n+   function Count\n+     (Source  : Unbounded_Wide_Wide_String;\n+      Pattern : Wide_Wide_String;\n+      Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping_Function)\n+      return Natural;\n+\n+   function Count\n+     (Source : Unbounded_Wide_Wide_String;\n+      Set    : Wide_Wide_Maps.Wide_Wide_Character_Set) return Natural;\n+\n+   procedure Find_Token\n+     (Source : Unbounded_Wide_Wide_String;\n+      Set    : Wide_Wide_Maps.Wide_Wide_Character_Set;\n+      Test   : Membership;\n+      First  : out Positive;\n+      Last   : out Natural);\n+\n+   ------------------------------------\n+   -- String Translation Subprograms --\n+   ------------------------------------\n+\n+   function Translate\n+     (Source  : Unbounded_Wide_Wide_String;\n+      Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping)\n+      return Unbounded_Wide_Wide_String;\n+\n+   procedure Translate\n+     (Source  : in out Unbounded_Wide_Wide_String;\n+      Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping);\n+\n+   function Translate\n+     (Source  : Unbounded_Wide_Wide_String;\n+      Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping_Function)\n+      return Unbounded_Wide_Wide_String;\n+\n+   procedure Translate\n+     (Source  : in out Unbounded_Wide_Wide_String;\n+      Mapping : Wide_Wide_Maps.Wide_Wide_Character_Mapping_Function);\n+\n+   ---------------------------------------\n+   -- String Transformation Subprograms --\n+   ---------------------------------------\n+\n+   function Replace_Slice\n+     (Source : Unbounded_Wide_Wide_String;\n+      Low    : Positive;\n+      High   : Natural;\n+      By     : Wide_Wide_String) return Unbounded_Wide_Wide_String;\n+\n+   procedure Replace_Slice\n+     (Source : in out Unbounded_Wide_Wide_String;\n+      Low    : Positive;\n+      High   : Natural;\n+      By     : Wide_Wide_String);\n+\n+   function Insert\n+     (Source   : Unbounded_Wide_Wide_String;\n+      Before   : Positive;\n+      New_Item : Wide_Wide_String) return Unbounded_Wide_Wide_String;\n+\n+   procedure Insert\n+     (Source   : in out Unbounded_Wide_Wide_String;\n+      Before   : Positive;\n+      New_Item : Wide_Wide_String);\n+\n+   function Overwrite\n+     (Source   : Unbounded_Wide_Wide_String;\n+      Position : Positive;\n+      New_Item : Wide_Wide_String) return Unbounded_Wide_Wide_String;\n+\n+   procedure Overwrite\n+     (Source   : in out Unbounded_Wide_Wide_String;\n+      Position : Positive;\n+      New_Item : Wide_Wide_String);\n+\n+   function Delete\n+     (Source  : Unbounded_Wide_Wide_String;\n+      From    : Positive;\n+      Through : Natural) return Unbounded_Wide_Wide_String;\n+\n+   procedure Delete\n+     (Source  : in out Unbounded_Wide_Wide_String;\n+      From    : Positive;\n+      Through : Natural);\n+\n+   function Trim\n+     (Source : Unbounded_Wide_Wide_String;\n+      Side   : Trim_End) return Unbounded_Wide_Wide_String;\n+\n+   procedure Trim\n+     (Source : in out Unbounded_Wide_Wide_String;\n+      Side   : Trim_End);\n+\n+   function Trim\n+     (Source : Unbounded_Wide_Wide_String;\n+      Left   : Wide_Wide_Maps.Wide_Wide_Character_Set;\n+      Right  : Wide_Wide_Maps.Wide_Wide_Character_Set)\n+      return Unbounded_Wide_Wide_String;\n+\n+   procedure Trim\n+     (Source : in out Unbounded_Wide_Wide_String;\n+      Left   : Wide_Wide_Maps.Wide_Wide_Character_Set;\n+      Right  : Wide_Wide_Maps.Wide_Wide_Character_Set);\n+\n+   function Head\n+     (Source : Unbounded_Wide_Wide_String;\n+      Count  : Natural;\n+      Pad    : Wide_Wide_Character := Wide_Wide_Space)\n+      return Unbounded_Wide_Wide_String;\n+\n+   procedure Head\n+     (Source : in out Unbounded_Wide_Wide_String;\n+      Count  : Natural;\n+      Pad    : Wide_Wide_Character := Wide_Wide_Space);\n+\n+   function Tail\n+     (Source : Unbounded_Wide_Wide_String;\n+      Count  : Natural;\n+      Pad    : Wide_Wide_Character := Wide_Wide_Space)\n+      return Unbounded_Wide_Wide_String;\n+\n+   procedure Tail\n+     (Source : in out Unbounded_Wide_Wide_String;\n+      Count  : Natural;\n+      Pad    : Wide_Wide_Character := Wide_Wide_Space);\n+\n+   function \"*\"\n+     (Left  : Natural;\n+      Right : Wide_Wide_Character) return Unbounded_Wide_Wide_String;\n+\n+   function \"*\"\n+     (Left  : Natural;\n+      Right : Wide_Wide_String) return Unbounded_Wide_Wide_String;\n+\n+   function \"*\"\n+     (Left  : Natural;\n+      Right : Unbounded_Wide_Wide_String) return Unbounded_Wide_Wide_String;\n+\n+private\n+   pragma Inline (Length);\n+\n+   package AF renames Ada.Finalization;\n+\n+   type Shared_Wide_Wide_String (Max_Length : Natural) is limited record\n+      Counter : aliased Interfaces.Unsigned_32 := 1;\n+      --  Reference counter.\n+\n+      Last    : Natural                        := 0;\n+      Data    : Wide_Wide_String (1 .. Max_Length);\n+      --  Last is the index of last significant element of the Data. All\n+      --  elements with larger indecies are just an extra room.\n+   end record;\n+\n+   type Shared_Wide_Wide_String_Access is access all Shared_Wide_Wide_String;\n+\n+   procedure Reference (Item : not null Shared_Wide_Wide_String_Access);\n+   --  Increment reference counter.\n+\n+   procedure Unreference (Item : not null Shared_Wide_Wide_String_Access);\n+   --  Decrement reference counter. Deallocate Item when reference counter is\n+   --  zero.\n+\n+   function Can_Be_Reused\n+     (Item   : Shared_Wide_Wide_String_Access;\n+      Length : Natural) return Boolean;\n+   --  Returns True if Shared_Wide_Wide_String can be reused. There are two\n+   --  criteria when Shared_Wide_Wide_String can be reused: its reference\n+   --  counter must be one (thus Shared_Wide_Wide_String is owned exclusively)\n+   --  and its size is sufficient to store string with specified length\n+   --  effectively.\n+\n+   function Allocate\n+     (Max_Length : Natural) return Shared_Wide_Wide_String_Access;\n+   --  Allocates new Shared_Wide_Wide_String with at least specified maximum\n+   --  length. Actual maximum length of the allocated Shared_Wide_Wide_String\n+   --  can be sligtly greater. Returns reference to\n+   --  Empty_Shared_Wide_Wide_String when requested length is zero.\n+\n+   Empty_Shared_Wide_Wide_String : aliased Shared_Wide_Wide_String (0);\n+\n+   function To_Unbounded\n+     (S : Wide_Wide_String) return Unbounded_Wide_Wide_String\n+     renames To_Unbounded_Wide_Wide_String;\n+   --  This renames are here only to be used in the pragma Stream_Convert.\n+\n+   type Unbounded_Wide_Wide_String is new AF.Controlled with record\n+      Reference : Shared_Wide_Wide_String_Access :=\n+                    Empty_Shared_Wide_Wide_String'Access;\n+   end record;\n+\n+   --  The Unbounded_Wide_Wide_String uses several techniques to increasy speed\n+   --  of the application:\n+   --   - implicit sharing or copy-on-write. Unbounded_Wide_Wide_String\n+   --     contains only the reference to the data which is shared between\n+   --     several instances. The shared data is reallocated only when its value\n+   --     is changed and the object mutation can't be used or it is unefficient\n+   --     to use it;\n+   --   - object mutation. Shared data object can be reused without memory\n+   --     reallocation when all of the following requirements are meat:\n+   --      - shared data object don't used anywhere longer;\n+   --      - its size is sufficient to store new value;\n+   --      - the gap after reuse is less then some threashold.\n+   --   - memory preallocation. Most of used memory allocation algorithms\n+   --     alligns allocated segment on the some boundary, thus some amount of\n+   --     additional memory can be preallocated without any impact. Such\n+   --     preallocated memory can used later by Append/Insert operations\n+   --     without reallocation.\n+   --\n+   --  Reference counting uses GCC builtin atomic operations, which allows to\n+   --  safely share internal data between Ada tasks. Nevertheless, this not\n+   --  make objects of Unbounded_Wide_Wide_String thread-safe, so each instance\n+   --  can't be accessed by several tasks simulatenously.\n+\n+   pragma Stream_Convert\n+     (Unbounded_Wide_Wide_String, To_Unbounded, To_Wide_Wide_String);\n+   --  Provide stream routines without dragging in Ada.Streams\n+\n+   pragma Finalize_Storage_Only (Unbounded_Wide_Wide_String);\n+   --  Finalization is required only for freeing storage\n+\n+   overriding procedure Initialize\n+     (Object : in out Unbounded_Wide_Wide_String);\n+   overriding procedure Adjust\n+     (Object : in out Unbounded_Wide_Wide_String);\n+   overriding procedure Finalize\n+     (Object : in out Unbounded_Wide_Wide_String);\n+\n+   Null_Unbounded_Wide_Wide_String : constant Unbounded_Wide_Wide_String :=\n+                             (AF.Controlled with\n+                                Reference =>\n+                                  Empty_Shared_Wide_Wide_String'Access);\n+\n+end Ada.Strings.Wide_Wide_Unbounded;"}, {"sha": "42b7f719a5ba5669038bf0ea0f3cf8943fbba88f", "filename": "gcc/ada/a-suenco.adb", "status": "added", "additions": 390, "deletions": 0, "changes": 390, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fa-suenco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fa-suenco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-suenco.adb?ref=6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5", "patch": "@@ -0,0 +1,390 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                   ADA.STRINGS.UTF_ENCODING.CONVERSIONS                   --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2010, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body Ada.Strings.UTF_Encoding.Conversions is\n+   use Interfaces;\n+\n+   --  Version convertion from UTF-8/UTF-16BE/LE to UTF-8/UTF-16BE/LE\n+\n+   function Convert\n+     (Item          : UTF_String;\n+      Input_Scheme  : Encoding_Scheme;\n+      Output_Scheme : Encoding_Scheme;\n+      Output_BOM    : Boolean := False) return UTF_String\n+   is\n+   begin\n+      --  Nothing to do if identical schemes\n+\n+      if Input_Scheme = Output_Scheme then\n+         return Item;\n+\n+      --  For remaining cases, one or other of the operands is UTF-16BE/LE\n+      --  encoded, so go through UTF-16 intermediate.\n+\n+      else\n+         return Convert (UTF_16_Wide_String'(Convert (Item, Input_Scheme)),\n+                         Output_Scheme, Output_BOM);\n+      end if;\n+   end Convert;\n+\n+   --  Version converting UTF-8/UTF-16BE/LE to UTF-16\n+\n+   function Convert\n+     (Item          : UTF_String;\n+      Input_Scheme  : Encoding_Scheme;\n+      Output_BOM    : Boolean := False) return UTF_16_Wide_String\n+   is\n+   begin\n+      if Input_Scheme = UTF_8 then\n+         return Convert (Item, Output_BOM);\n+      else\n+         return To_UTF_16 (Item, Input_Scheme, Output_BOM);\n+      end if;\n+   end Convert;\n+\n+   --  Version converting UTF-8 to UTF-16\n+\n+   function Convert\n+     (Item       : UTF_8_String;\n+      Output_BOM : Boolean := False) return UTF_16_Wide_String\n+   is\n+      Result : UTF_16_Wide_String (1 .. Item'Length + 1);\n+      --  Maximum length of result, including possible BOM\n+\n+      Len : Natural := 0;\n+      --  Number of characters stored so far in Result\n+\n+      Iptr : Natural;\n+      --  Next character to process in Item\n+\n+      C : Unsigned_8;\n+      --  Input UTF-8 code\n+\n+      R : Unsigned_16;\n+      --  Output UTF-16 code\n+\n+      procedure Get_Continuation;\n+      --  Reads a continuation byte of the form 10xxxxxx, shifts R left\n+      --  by 6 bits, and or's in the xxxxxx to the low order 6 bits. On\n+      --  return Ptr is incremented. Raises exceptioon if continuation\n+      --  byte does not exist or is invalid.\n+\n+      ----------------------\n+      -- Get_Continuation --\n+      ----------------------\n+\n+      procedure Get_Continuation is\n+      begin\n+         if Iptr > Item'Last then\n+            Raise_Encoding_Error (Iptr - 1);\n+\n+         else\n+            C := To_Unsigned_8 (Item (Iptr));\n+            Iptr := Iptr + 1;\n+\n+            if C < 2#10_000000# or else C > 2#10_111111# then\n+               Raise_Encoding_Error (Iptr - 1);\n+\n+            else\n+               R := Shift_Left (R, 6) or\n+                 Unsigned_16 (C and 2#00_111111#);\n+            end if;\n+         end if;\n+      end Get_Continuation;\n+\n+   --  Start of processing for Convert\n+\n+   begin\n+      --  Output BOM if required\n+\n+      if Output_BOM then\n+         Len := Len + 1;\n+         Result (Len) := BOM_16 (1);\n+      end if;\n+\n+      --  Skip OK BOM\n+\n+      Iptr := Item'First;\n+\n+      if Item'Length >= 3 and then Item (Iptr .. Iptr + 2) = BOM_8 then\n+         Iptr := Iptr + 3;\n+\n+      --  Error if bad BOM\n+\n+      elsif Item'Length >= 2\n+        and then (Item (Iptr .. Iptr + 1) = BOM_16BE\n+                    or else\n+                  Item (Iptr .. Iptr + 1) = BOM_16LE)\n+      then\n+         Raise_Encoding_Error (Iptr);\n+\n+      --  No BOM present\n+\n+      else\n+         Iptr := Item'First;\n+      end if;\n+\n+      while Iptr <= Item'Last loop\n+         C := To_Unsigned_8 (Item (Iptr));\n+         Iptr := Iptr + 1;\n+\n+         --  Codes in the range 16#00# - 16#7F#\n+         --    UTF-8:  0xxxxxxx\n+         --    UTF-16: 00000000_0xxxxxxx\n+\n+         if C <= 16#7F# then\n+            Len := Len + 1;\n+            Result (Len) := Wide_Character'Val (C);\n+\n+         --  No initial code can be of the form 10xxxxxx. Such codes are used\n+         --  only for continuations.\n+\n+         elsif C <= 2#10_111111# then\n+            Raise_Encoding_Error (Iptr - 1);\n+\n+         --  Codes in the range 16#80# - 16#7FF#\n+         --    UTF-8:  110yyyxx 10xxxxxx\n+         --    UTF-16: 00000yyy_xxxxxxxx\n+\n+         elsif C <= 2#110_11111# then\n+            R := Unsigned_16 (C and 2#000_11111#);\n+            Get_Continuation;\n+            Len := Len + 1;\n+            Result (Len) := Wide_Character'Val (R);\n+\n+         --  Codes in the range 16#800# - 16#FFFF#\n+         --    UTF-8:  1110yyyy 10yyyyxx 10xxxxxx\n+         --    UTF-16: yyyyyyyy_xxxxxxxx\n+\n+         elsif C <= 2#1110_1111# then\n+            R := Unsigned_16 (C and 2#0000_1111#);\n+            Get_Continuation;\n+            Get_Continuation;\n+            Len := Len + 1;\n+            Result (Len) := Wide_Character'Val (R);\n+\n+            --  Make sure that we don't have a result in the forbidden range\n+            --  reserved for UTF-16 surrogate characters.\n+\n+            if R in 16#D800# .. 16#DF00# then\n+               Raise_Encoding_Error (Iptr - 3);\n+            end if;\n+\n+         --  Codes in the range 16#10000# - 16#10FFFF#\n+         --    UTF-8:  11110zzz 10zzyyyy 10yyyyxx 10xxxxxx\n+         --    UTF-16: 110110zz_zzyyyyyy 110111yy_xxxxxxxx\n+         --    Note: zzzz in the output is input zzzzz - 1\n+\n+         elsif C <= 2#11110_111# then\n+            R := Unsigned_16 (C and 2#00000_111#);\n+            Get_Continuation;\n+\n+            --  R now has zzzzzyyyy\n+\n+            R := R - 2#0000_1_0000#;\n+\n+            --  R now has zzzzyyyy (zzzz minus one for the output)\n+\n+            Get_Continuation;\n+\n+            --  R now has zzzzyyyyyyyyxx\n+\n+            Len := Len + 1;\n+            Result (Len) :=\n+              Wide_Character'Val\n+                (2#110110_00_0000_0000# or Shift_Right (R, 4));\n+\n+            R := R and 2#1111#;\n+            Get_Continuation;\n+            Len := Len + 1;\n+            Result (Len) :=\n+              Wide_Character'Val (2#110111_00_0000_0000# or R);\n+\n+         --  Any other code is an error\n+\n+         else\n+            Raise_Encoding_Error (Iptr - 1);\n+         end if;\n+      end loop;\n+\n+      return Result (1 .. Len);\n+   end Convert;\n+\n+   --  Convert from UTF-16 to UTF-8/UTF-16-BE/LE\n+\n+   function Convert\n+     (Item          : UTF_16_Wide_String;\n+      Output_Scheme : Encoding_Scheme;\n+      Output_BOM    : Boolean := False) return UTF_String\n+   is\n+   begin\n+      if Output_Scheme = UTF_8 then\n+         return Convert (Item, Output_BOM);\n+      else\n+         return From_UTF_16 (Item, Output_Scheme, Output_BOM);\n+      end if;\n+   end Convert;\n+\n+   --  Convert from UTF-16 to UTF-8\n+\n+   function Convert\n+     (Item          : UTF_16_Wide_String;\n+      Output_BOM    : Boolean := False) return UTF_8_String\n+   is\n+      Result : UTF_8_String (1 .. 3 * Item'Length + 3);\n+      --  Worst case is 3 output codes for each input code + BOM space\n+\n+      Len : Natural;\n+      --  Number of result codes stored\n+\n+      Iptr : Natural;\n+      --  Pointer to next input character\n+\n+      C1, C2 : Unsigned_16;\n+\n+      zzzzz    : Unsigned_16;\n+      yyyyyyyy : Unsigned_16;\n+      xxxxxxxx : Unsigned_16;\n+      --  Components of double length case\n+\n+   begin\n+      Iptr := Item'First;\n+\n+      --  Skip BOM at start of input\n+\n+      if Item'Length > 0 and then Item (Iptr) = BOM_16 (1) then\n+         Iptr := Iptr + 1;\n+      end if;\n+\n+      --  Generate output BOM if required\n+\n+      if Output_BOM then\n+         Result (1 .. 3) := BOM_8;\n+         Len := 3;\n+      else\n+         Len := 0;\n+      end if;\n+\n+      --  Loop through input\n+\n+      while Iptr <= Item'Last loop\n+         C1 := To_Unsigned_16 (Item (Iptr));\n+         Iptr := Iptr + 1;\n+\n+         --  Codes in the range 16#0000# - 16#007F#\n+         --    UTF-16: 000000000xxxxxxx\n+         --    UTF-8:  0xxxxxxx\n+\n+         if C1 <= 16#007F# then\n+            Result (Len + 1) := Character'Val (C1);\n+            Len := Len + 1;\n+\n+         --  Codes in the range 16#80# - 16#7FF#\n+         --    UTF-16: 00000yyyxxxxxxxx\n+         --    UTF-8:  110yyyxx 10xxxxxx\n+\n+         elsif C1 <= 16#07FF# then\n+            Result (Len + 1) :=\n+              Character'Val\n+                (2#110_000000# or Shift_Right (C1, 6));\n+            Result (Len + 2) :=\n+              Character'Val\n+                (2#10_000000# or (C1 and 2#00_111111#));\n+            Len := Len + 2;\n+\n+         --  Codes in the range 16#800# - 16#D7FF# or 16#E000# - 16#FFFF#\n+         --    UTF-16: yyyyyyyyxxxxxxxx\n+         --    UTF-8:  1110yyyy 10yyyyxx 10xxxxxx\n+\n+         elsif C1 <= 16#D7FF# or else C1 >= 16#E000# then\n+            Result (Len + 1) :=\n+              Character'Val\n+                (2#1110_0000# or Shift_Right (C1, 12));\n+            Result (Len + 2) :=\n+              Character'Val\n+                (2#10_000000# or (Shift_Right (C1, 6) and 2#00_111111#));\n+            Result (Len + 3) :=\n+              Character'Val\n+                (2#10_000000# or (C1 and 2#00_111111#));\n+            Len := Len + 3;\n+\n+         --  Codes in the range 16#10000# - 16#10FFFF#\n+         --    UTF-16: 110110zzzzyyyyyy 110111yyxxxxxxxx\n+         --    UTF-8:  11110zzz 10zzyyyy 10yyyyxx 10xxxxxx\n+         --    Note: zzzzz in the output is input zzzz + 1\n+\n+         elsif C1 <= 2#110110_11_11111111# then\n+            if Iptr > Item'Last then\n+               Raise_Encoding_Error (Iptr - 1);\n+            else\n+               C2 := To_Unsigned_16 (Item (Iptr));\n+               Iptr := Iptr + 1;\n+            end if;\n+\n+            if (C2 and 2#111111_00_00000000#) /= 2#110111_00_00000000# then\n+               Raise_Encoding_Error (Iptr - 1);\n+            end if;\n+\n+            zzzzz    := (Shift_Right (C1, 6) and 2#1111#) + 1;\n+            yyyyyyyy := ((Shift_Left (C1, 2) and 2#111111_00#)\n+                            or\n+                         (Shift_Right (C2, 8) and 2#000000_11#));\n+            xxxxxxxx := C2 and 2#11111111#;\n+\n+            Result (Len + 1) :=\n+              Character'Val\n+                (2#11110_000# or (Shift_Right (zzzzz, 2)));\n+            Result (Len + 2) :=\n+              Character'Val\n+                (2#10_000000# or Shift_Left (zzzzz and 2#11#, 4)\n+                              or Shift_Right (yyyyyyyy, 4));\n+            Result (Len + 3) :=\n+              Character'Val\n+                (2#10_000000# or Shift_Left (yyyyyyyy and 2#1111#, 4)\n+                              or Shift_Right (xxxxxxxx, 6));\n+            Result (Len + 4) :=\n+              Character'Val\n+                (2#10_000000# or (xxxxxxxx and 2#00_111111#));\n+            Len := Len + 4;\n+\n+         --  Error if input in 16#DC00# - 16#DFFF# (2nd surrogate with no 1st)\n+\n+         else\n+            Raise_Encoding_Error (Iptr - 2);\n+         end if;\n+      end loop;\n+\n+      return Result (1 .. Len);\n+   end Convert;\n+\n+end Ada.Strings.UTF_Encoding.Conversions;"}, {"sha": "0aa4f88b20f59accd1dc2da11d0cd7f2bf736b00", "filename": "gcc/ada/a-suenco.ads", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fa-suenco.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fa-suenco.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-suenco.ads?ref=6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5", "patch": "@@ -0,0 +1,61 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                   ADA.STRINGS.UTF_ENCODING.CONVERSIONS                   --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is an Ada 2012 package defined in AI05-0137-1. It provides conversions\n+--  from one UTF encoding method to another. Note: this package is consistent\n+--  with Ada 95, and may be used in Ada 95 or Ada 2005 mode.\n+\n+package Ada.Strings.UTF_Encoding.Conversions is\n+   pragma Pure (Conversions);\n+\n+   --  In the following conversion routines, a BOM in the input that matches\n+   --  the encoding scheme is ignored, an incorrect BOM causes Encoding_Error\n+   --  to be raised. A BOM is present in the output if the Output_BOM parameter\n+   --  is set to True.\n+\n+   function Convert\n+     (Item          : UTF_String;\n+      Input_Scheme  : Encoding_Scheme;\n+      Output_Scheme : Encoding_Scheme;\n+      Output_BOM    : Boolean := False) return UTF_String;\n+   --  Convert from input encoded in UTF-8, UTF-16LE, or UTF-16BE as specified\n+   --  by the Input_Scheme argument, and generate an output encoded in one of\n+   --  these three schemes as specified by the Output_Scheme argument.\n+\n+   function Convert\n+     (Item          : UTF_String;\n+      Input_Scheme  : Encoding_Scheme;\n+      Output_BOM    : Boolean := False) return UTF_16_Wide_String;\n+   --  Convert from input encoded in UTF-8, UTF-16LE, or UTF-16BE as specified\n+   --  by the Input_Scheme argument, and generate an output encoded in UTF-16.\n+\n+   function Convert\n+     (Item          : UTF_8_String;\n+      Output_BOM    : Boolean := False) return UTF_16_Wide_String;\n+   --  Convert from UTF-8 to UTF-16\n+\n+   function Convert\n+     (Item          : UTF_16_Wide_String;\n+      Output_Scheme : Encoding_Scheme;\n+      Output_BOM    : Boolean := False) return UTF_String;\n+   --  Convert from UTF-16 to UTF-8, UTF-16LE, or UTF-16BE as specified by\n+   --  the Output_Scheme argument.\n+\n+   function Convert\n+     (Item          : UTF_16_Wide_String;\n+      Output_BOM    : Boolean := False) return UTF_8_String;\n+   --  Convert from UTF-16 to UTF-8\n+\n+end Ada.Strings.UTF_Encoding.Conversions;"}, {"sha": "3cbebc83d3a8300ff7569b210335ae24b138d2d4", "filename": "gcc/ada/a-suewen.adb", "status": "added", "additions": 371, "deletions": 0, "changes": 371, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fa-suewen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fa-suewen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-suewen.adb?ref=6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5", "patch": "@@ -0,0 +1,371 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                  ADA.STRINGS.UTF_ENCODING.WIDE_ENCODING                  --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2010, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS  FOR A PARTICULAR PURPOSE. See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body Ada.Strings.UTF_Encoding.Wide_Encoding is\n+   use Interfaces;\n+\n+   ------------\n+   -- Decode --\n+   ------------\n+\n+   --  Version to decode UTF-8/UTF-16BE/UTF-16LE input to Wide_String\n+\n+   function Decode\n+     (Item         : UTF_String;\n+      Input_Scheme : Encoding_Scheme) return Wide_String\n+   is\n+   begin\n+      if Input_Scheme = UTF_8 then\n+         return Decode (Item);\n+      else\n+         return Decode (To_UTF_16 (Item, Input_Scheme));\n+      end if;\n+   end Decode;\n+\n+   --  Decode UTF-8 input to Wide_String\n+\n+   function Decode (Item : UTF_8_String) return Wide_String is\n+      Result : Wide_String (1 .. Item'Length);\n+      --  Result string (worst case is same length as input)\n+\n+      Len : Natural := 0;\n+      --  Length of result stored so far\n+\n+      Iptr : Natural;\n+      --  Input Item pointer\n+\n+      C : Unsigned_8;\n+      R : Unsigned_16;\n+\n+      procedure Get_Continuation;\n+      --  Reads a continuation byte of the form 10xxxxxx, shifts R left\n+      --  by 6 bits, and or's in the xxxxxx to the low order 6 bits. On\n+      --  return Ptr is incremented. Raises exceptioon if continuation\n+      --  byte does not exist or is invalid.\n+\n+      ----------------------\n+      -- Get_Continuation --\n+      ----------------------\n+\n+      procedure Get_Continuation is\n+      begin\n+         if Iptr > Item'Last then\n+            Raise_Encoding_Error (Iptr - 1);\n+\n+         else\n+            C := To_Unsigned_8 (Item (Iptr));\n+            Iptr := Iptr + 1;\n+\n+            if C not in 2#10_000000# .. 2#10_111111# then\n+               Raise_Encoding_Error (Iptr - 1);\n+            else\n+               R := Shift_Left (R, 6) or Unsigned_16 (C and 2#00_111111#);\n+            end if;\n+         end if;\n+      end Get_Continuation;\n+\n+   --  Start of processing for Decode\n+\n+   begin\n+      Iptr := Item'First;\n+\n+      --  Skip BOM at start\n+\n+      if Item'Length >= 3\n+        and then Item (Iptr .. Iptr + 2) = BOM_8\n+      then\n+         Iptr := Iptr + 3;\n+\n+      --  Error if bad BOM\n+\n+      elsif Item'Length >= 2\n+        and then (Item (Iptr .. Iptr + 1) = BOM_16BE\n+                    or else\n+                  Item (Iptr .. Iptr + 1) = BOM_16LE)\n+      then\n+         Raise_Encoding_Error (Iptr);\n+      end if;\n+\n+      while Iptr <= Item'Last loop\n+         C := To_Unsigned_8 (Item (Iptr));\n+         Iptr := Iptr + 1;\n+\n+         --  Codes in the range 16#00# - 16#7F# are represented as\n+         --    0xxxxxxx\n+\n+         if C <= 16#7F# then\n+            R := Unsigned_16 (C);\n+\n+         --  No initial code can be of the form 10xxxxxx. Such codes are used\n+         --  only for continuations.\n+\n+         elsif C <= 2#10_111111# then\n+            Raise_Encoding_Error (Iptr - 1);\n+\n+         --  Codes in the range 16#80# - 16#7FF# are represented as\n+         --    110yyyxx 10xxxxxx\n+\n+         elsif C <= 2#110_11111# then\n+            R := Unsigned_16 (C and 2#000_11111#);\n+            Get_Continuation;\n+\n+         --  Codes in the range 16#800# - 16#FFFF# are represented as\n+         --    1110yyyy 10yyyyxx 10xxxxxx\n+\n+         elsif C <= 2#1110_1111# then\n+            R := Unsigned_16 (C and 2#0000_1111#);\n+            Get_Continuation;\n+            Get_Continuation;\n+\n+         --  Codes in the range 16#10000# - 16#10FFFF# are represented as\n+         --    11110zzz 10zzyyyy 10yyyyxx 10xxxxxx\n+\n+         --  Such codes are out of range for Wide_String output\n+\n+         else\n+            Raise_Encoding_Error (Iptr - 1);\n+         end if;\n+\n+         Len := Len + 1;\n+         Result (Len) := Wide_Character'Val (R);\n+      end loop;\n+\n+      return Result (1 .. Len);\n+   end Decode;\n+\n+   --  Decode UTF-16 input to Wide_String\n+\n+   function Decode (Item : UTF_16_Wide_String) return Wide_String is\n+      Result : Wide_String (1 .. Item'Length);\n+      --  Result is same length as input (possibly minus 1 if BOM present)\n+\n+      Len : Natural := 0;\n+      --  Length of result\n+\n+      Iptr : Natural;\n+      --  Index of next Item element\n+\n+      C : Unsigned_16;\n+\n+   begin\n+      --  Skip UTF-16 BOM at start\n+\n+      Iptr := Item'First;\n+\n+      if Item'Length > 0 and then Item (Iptr) = BOM_16 (1) then\n+         Iptr := Iptr + 1;\n+      end if;\n+\n+      --  Loop through input characters\n+\n+      while Iptr <= Item'Last loop\n+         C := To_Unsigned_16 (Item (Iptr));\n+         Iptr := Iptr + 1;\n+\n+         --  Codes in the range 16#0000#..16#D7FF# or 16#E000#..16#FFFD#\n+         --  represent their own value.\n+\n+         if C <= 16#D7FF# or else C in 16#E000# .. 16#FFFD# then\n+            Len := Len + 1;\n+            Result (Len) := Wide_Character'Val (C);\n+\n+         --  Codes in the range 16#D800#..16#DBFF# represent the first of the\n+         --  two surrogates used to encode the range 16#01_000#..16#10_FFFF\".\n+         --  Such codes are out of range for 16-bit output.\n+\n+         --  The case of input in the range 16#DC00#..16#DFFF# must never\n+         --  occur, since it means we have a second surrogate character with\n+         --  no corresponding first surrogate.\n+\n+         --  Codes in the range 16#FFFE# .. 16#FFFF# are also invalid since\n+         --  they conflict with codes used for BOM values.\n+\n+         --  Thus all remaining codes are invalid\n+\n+         else\n+            Raise_Encoding_Error (Iptr - 1);\n+         end if;\n+      end loop;\n+\n+      return Result (1 .. Len);\n+   end Decode;\n+\n+   ------------\n+   -- Encode --\n+   ------------\n+\n+   --  Encode Wide_String in UTF-8, UTF-16BE or UTF-16LE\n+\n+   function Encode\n+     (Item          : Wide_String;\n+      Output_Scheme : Encoding_Scheme;\n+      Output_BOM    : Boolean  := False) return UTF_String\n+   is\n+   begin\n+      --  Case of UTF_8\n+\n+      if Output_Scheme = UTF_8 then\n+         return Encode (Item, Output_BOM);\n+\n+      --  Case of UTF_16LE or UTF_16BE, use UTF-16 intermediary\n+\n+      else\n+         return From_UTF_16 (UTF_16_Wide_String'(Encode (Item)),\n+                             Output_Scheme, Output_BOM);\n+      end if;\n+   end Encode;\n+\n+   --  Encode Wide_String in UTF-8\n+\n+   function Encode\n+     (Item       : Wide_String;\n+      Output_BOM : Boolean  := False) return UTF_8_String\n+   is\n+      Result : UTF_8_String (1 .. 3 * Item'Length + 3);\n+      --  Worst case is three bytes per input byte + space for BOM\n+\n+      Len : Natural;\n+      --  Number of output codes stored in Result\n+\n+      C : Unsigned_16;\n+      --  Single input character\n+\n+      procedure Store (C : Unsigned_16);\n+      pragma Inline (Store);\n+      --  Store one output code, C is in the range 0 .. 255\n+\n+      -----------\n+      -- Store --\n+      -----------\n+\n+      procedure Store (C : Unsigned_16) is\n+      begin\n+         Len := Len + 1;\n+         Result (Len) := Character'Val (C);\n+      end Store;\n+\n+   --  Start of processing for UTF8_Encode\n+\n+   begin\n+      --  Output BOM if required\n+\n+      if Output_BOM then\n+         Result (1 .. 3) := BOM_8;\n+         Len := 3;\n+      else\n+         Len := 0;\n+      end if;\n+\n+      --  Loop through characters of input\n+\n+      for J in Item'Range loop\n+         C := To_Unsigned_16 (Item (J));\n+\n+         --  Codes in the range 16#00# - 16#7F# are represented as\n+         --    0xxxxxxx\n+\n+         if C <= 16#7F# then\n+            Store (C);\n+\n+         --  Codes in the range 16#80# - 16#7FF# are represented as\n+         --    110yyyxx 10xxxxxx\n+\n+         elsif C <= 16#7FF# then\n+            Store (2#110_00000# or Shift_Right (C, 6));\n+            Store (2#10_000000# or (C and 2#00_111111#));\n+\n+         --  Codes in the range 16#800# - 16#FFFF# are represented as\n+         --    1110yyyy 10yyyyxx 10xxxxxx\n+\n+         else\n+            Store (2#1110_0000# or Shift_Right (C, 12));\n+            Store (2#10_000000# or\n+                     Shift_Right (C and 2#111111_000000#, 6));\n+            Store (2#10_000000# or (C and 2#00_111111#));\n+         end if;\n+      end loop;\n+\n+      return Result (1 .. Len);\n+   end Encode;\n+\n+   --  Encode Wide_String in UTF-16\n+\n+   function Encode\n+     (Item       : Wide_String;\n+      Output_BOM : Boolean  := False) return UTF_16_Wide_String\n+   is\n+      Result : Wide_String (1 .. Item'Length + Boolean'Pos (Output_BOM));\n+      --  Output is same length as input + possible BOM\n+\n+      Len : Integer;\n+      --  Length of output string\n+\n+      C : Unsigned_16;\n+\n+   begin\n+      --  Output BOM if required\n+\n+      if Output_BOM then\n+         Result (1) := BOM_16 (1);\n+         Len := 1;\n+      else\n+         Len := 0;\n+      end if;\n+\n+      --  Loop through input characters encoding them\n+\n+      for Iptr in Item'Range loop\n+         C := To_Unsigned_16 (Item (Iptr));\n+\n+         --  Codes in the range 16#0000#..16#D7FF# or 16#E000#..16#FFFD# are\n+         --  output unchaned.\n+\n+         if C <= 16#D7FF# or else C in 16#E000# .. 16#FFFD# then\n+            Len := Len + 1;\n+            Result (Len) := Wide_Character'Val (C);\n+\n+         --  Codes in tne range 16#D800#..16#DFFF# should never appear in the\n+         --  input, since no valid Unicode characters are in this range (which\n+         --  would conflict with the UTF-16 surrogate encodings). Similarly\n+         --  codes in the range 16#FFFE#..16#FFFF conflict with BOM codes.\n+         --  Thus all remaining codes are illegal.\n+\n+         else\n+            Raise_Encoding_Error (Iptr);\n+         end if;\n+      end loop;\n+\n+      return Result;\n+   end Encode;\n+\n+end Ada.Strings.UTF_Encoding.Wide_Encoding;"}, {"sha": "bae9e14844797bd02ef05975d96639791ff90164", "filename": "gcc/ada/a-suewen.ads", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fa-suewen.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fa-suewen.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-suewen.ads?ref=6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5", "patch": "@@ -0,0 +1,67 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                  ADA.STRINGS.UTF_ENCODING.WIDE_ENCODING                  --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is an Ada 2012 package defined in AI05-0137-1. It is used for encoding\n+--  and decoding Wide_String values using UTF encodings. Note: this package is\n+--  consistent with Ada 95, and may be included in Ada 95 implementations.\n+\n+package Ada.Strings.UTF_Encoding.Wide_Encoding is\n+   pragma Pure (Wide_Encoding);\n+\n+   --  The encoding routines take a Wide_String as input and encode the result\n+   --  using the specified UTF encoding method. The result includes a BOM if\n+   --  the Output_BOM argument is set to True. Encoding_Error is raised if an\n+   --  invalid character appears in the input. In particular the characters\n+   --  in the range 16#D800# .. 16#DFFF# are invalid because they conflict\n+   --  with UTF-16 surrogate encodings, and the characters 16#FFFE# and\n+   --  16#FFFF# are also invalid because they conflict with BOM codes.\n+\n+   function Encode\n+     (Item          : Wide_String;\n+      Output_Scheme : Encoding_Scheme;\n+      Output_BOM    : Boolean  := False) return UTF_String;\n+   --  Encode Wide_String using UTF-8, UTF-16LE or UTF-16BE encoding as\n+   --  specified by the Output_Scheme parameter.\n+\n+   function Encode\n+     (Item       : Wide_String;\n+      Output_BOM : Boolean  := False) return UTF_8_String;\n+   --  Encode Wide_String using UTF-8 encoding\n+\n+   function Encode\n+     (Item       : Wide_String;\n+      Output_BOM : Boolean  := False) return UTF_16_Wide_String;\n+   --  Encode Wide_String using UTF_16 encoding\n+\n+   --  The decoding routines take a UTF String as input, and return a decoded\n+   --  Wide_String. If the UTF String starts with a BOM that matches the\n+   --  encoding method, it is ignored. An incorrect BOM raises Encoding_Error.\n+\n+   function Decode\n+     (Item         : UTF_String;\n+      Input_Scheme : Encoding_Scheme) return Wide_String;\n+   --  The input is encoded in UTF_8, UTF_16LE or UTF_16BE as specified by the\n+   --  Input_Scheme parameter. It is decoded and returned as a Wide_String\n+   --  value. Note: a convenient form for scheme may be Encoding (UTF_String).\n+\n+   function Decode\n+     (Item : UTF_8_String) return Wide_String;\n+   --  The input is encoded in UTF-8 and returned as a Wide_String value\n+\n+   function Decode\n+     (Item : UTF_16_Wide_String) return Wide_String;\n+   --  The input is encoded in UTF-16 and returned as a Wide_String value\n+\n+end Ada.Strings.UTF_Encoding.Wide_Encoding;"}, {"sha": "972fbf061e8b4b8f84c0f22f97b14c76a03a8050", "filename": "gcc/ada/a-suezen.adb", "status": "added", "additions": 431, "deletions": 0, "changes": 431, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fa-suezen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fa-suezen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-suezen.adb?ref=6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5", "patch": "@@ -0,0 +1,431 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--               ADA.STRINGS.UTF_ENCODING.WIDE_WIDE_ENCODING                --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2010, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS  FOR A PARTICULAR PURPOSE. See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body Ada.Strings.UTF_Encoding.Wide_Wide_Encoding is\n+   use Interfaces;\n+\n+   ------------\n+   -- Decode --\n+   ------------\n+\n+   --  Version to decode UTF-8/UTF-16BE/UTF-16LE input to Wide_Wide_String\n+\n+   function Decode\n+     (Item         : UTF_String;\n+      Input_Scheme : Encoding_Scheme) return Wide_Wide_String\n+   is\n+   begin\n+      if Input_Scheme = UTF_8 then\n+         return Decode (Item);\n+      else\n+         return Decode (To_UTF_16 (Item, Input_Scheme));\n+      end if;\n+   end Decode;\n+\n+   --  Decode UTF-8 input to Wide_Wide_String\n+\n+   function Decode (Item : UTF_8_String) return Wide_Wide_String is\n+      Result : Wide_Wide_String (1 .. Item'Length);\n+      --  Result string (worst case is same length as input)\n+\n+      Len : Natural := 0;\n+      --  Length of result stored so far\n+\n+      Iptr : Natural;\n+      --  Input string pointer\n+\n+      C : Unsigned_8;\n+      R : Unsigned_32;\n+\n+      procedure Get_Continuation;\n+      --  Reads a continuation byte of the form 10xxxxxx, shifts R left\n+      --  by 6 bits, and or's in the xxxxxx to the low order 6 bits. On\n+      --  return Ptr is incremented. Raises exceptioon if continuation\n+      --  byte does not exist or is invalid.\n+\n+      ----------------------\n+      -- Get_Continuation --\n+      ----------------------\n+\n+      procedure Get_Continuation is\n+      begin\n+         if Iptr > Item'Last then\n+            Raise_Encoding_Error (Iptr - 1);\n+\n+         else\n+            C := To_Unsigned_8 (Item (Iptr));\n+            Iptr := Iptr + 1;\n+\n+            if C not in 2#10_000000# .. 2#10_111111# then\n+               Raise_Encoding_Error (Iptr - 1);\n+            else\n+               R := Shift_Left (R, 6) or Unsigned_32 (C and 2#00_111111#);\n+            end if;\n+         end if;\n+      end Get_Continuation;\n+\n+   --  Start of processing for Decode\n+\n+   begin\n+      Iptr := Item'First;\n+\n+      --  Skip BOM at start\n+\n+      if Item'Length >= 3\n+        and then Item (Iptr .. Iptr + 2) = BOM_8\n+      then\n+         Iptr := Iptr + 3;\n+\n+      --  Error if bad BOM\n+\n+      elsif Item'Length >= 2\n+        and then (Item (Iptr .. Iptr + 1) = BOM_16BE\n+                    or else\n+                  Item (Iptr .. Iptr + 1) = BOM_16LE)\n+      then\n+         Raise_Encoding_Error (Iptr);\n+      end if;\n+\n+      --  Loop through input characters\n+\n+      while Iptr <= Item'Last loop\n+         C := To_Unsigned_8 (Item (Iptr));\n+         Iptr := Iptr + 1;\n+\n+         --  Codes in the range 16#00# - 16#7F# are represented as\n+         --    0xxxxxxx\n+\n+         if C <= 16#7F# then\n+            R := Unsigned_32 (C);\n+\n+         --  No initial code can be of the form 10xxxxxx. Such codes are used\n+         --  only for continuations.\n+\n+         elsif C <= 2#10_111111# then\n+            Raise_Encoding_Error (Iptr - 1);\n+\n+         --  Codes in the range 16#80# - 16#7FF# are represented as\n+         --    110yyyxx 10xxxxxx\n+\n+         elsif C <= 2#110_11111# then\n+            R := Unsigned_32 (C and 2#000_11111#);\n+            Get_Continuation;\n+\n+         --  Codes in the range 16#800# - 16#FFFF# are represented as\n+         --    1110yyyy 10yyyyxx 10xxxxxx\n+\n+         elsif C <= 2#1110_1111# then\n+            R := Unsigned_32 (C and 2#0000_1111#);\n+            Get_Continuation;\n+            Get_Continuation;\n+\n+         --  Codes in the range 16#10000# - 16#10FFFF# are represented as\n+         --    11110zzz 10zzyyyy 10yyyyxx 10xxxxxx\n+\n+         elsif C <= 2#11110_111# then\n+            R := Unsigned_32 (C and 2#00000_111#);\n+            Get_Continuation;\n+            Get_Continuation;\n+            Get_Continuation;\n+\n+         --  Any other code is an error\n+\n+         else\n+            Raise_Encoding_Error (Iptr - 1);\n+         end if;\n+\n+         Len := Len + 1;\n+         Result (Len) := Wide_Wide_Character'Val (R);\n+      end loop;\n+\n+      return Result (1 .. Len);\n+   end Decode;\n+\n+   --  Decode UTF-16 input to Wide_Wide_String\n+\n+   function Decode (Item : UTF_16_Wide_String) return Wide_Wide_String is\n+      Result : Wide_Wide_String (1 .. Item'Length);\n+      --  Result cannot be longer than the input string\n+\n+      Len : Natural := 0;\n+      --  Length of result\n+\n+      Iptr : Natural;\n+      --  Pointer to next element in Item\n+\n+      C : Unsigned_16;\n+      R : Unsigned_32;\n+\n+   begin\n+      --  Skip UTF-16 BOM at start\n+\n+      Iptr := Item'First;\n+\n+      if Iptr <= Item'Last and then Item (Iptr) = BOM_16 (1) then\n+         Iptr := Iptr + 1;\n+      end if;\n+\n+      --  Loop through input characters\n+\n+      while Iptr <= Item'Last loop\n+         C := To_Unsigned_16 (Item (Iptr));\n+         Iptr := Iptr + 1;\n+\n+         --  Codes in the range 16#0000#..16#D7FF# or 16#E000#..16#FFFD#\n+         --  represent their own value.\n+\n+         if C <= 16#D7FF# or else C in 16#E000# .. 16#FFFD# then\n+            Len := Len + 1;\n+            Result (Len) := Wide_Wide_Character'Val (C);\n+\n+         --  Codes in the range 16#D800#..16#DBFF# represent the first of the\n+         --  two surrogates used to encode the range 16#01_000#..16#10_FFFF\".\n+         --  The first surrogate provides 10 high order bits of the result.\n+\n+         elsif C <= 16#DBFF# then\n+            R := Shift_Left ((Unsigned_32 (C) - 16#D800#), 10);\n+\n+            --  Error if at end of string\n+\n+            if Iptr > Item'Last then\n+               Raise_Encoding_Error (Iptr - 1);\n+\n+            --  Otherwise next character must be valid low order surrogate\n+            --  which provides the low 10 order bits of the result.\n+\n+            else\n+               C := To_Unsigned_16 (Item (Iptr));\n+               Iptr := Iptr + 1;\n+\n+               if C not in 16#DC00# .. 16#DFFF# then\n+                  Raise_Encoding_Error (Iptr - 1);\n+\n+               else\n+                  R := R or (Unsigned_32 (C) mod 2 ** 10);\n+\n+               --  The final adjustment is to add 16#01_0000 to get the\n+               --  result back in the required 21 bit range.\n+\n+                  R := R + 16#01_0000#;\n+                  Len := Len + 1;\n+                  Result (Len) := Wide_Wide_Character'Val (R);\n+               end if;\n+            end if;\n+\n+         --  Remaining codes are invalid\n+\n+         else\n+            Raise_Encoding_Error (Iptr - 1);\n+         end if;\n+      end loop;\n+\n+      return Result (1 .. Len);\n+   end Decode;\n+\n+   ------------\n+   -- Encode --\n+   ------------\n+\n+   --  Encode Wide_Wide_String in UTF-8, UTF-16BE or UTF-16LE\n+\n+   function Encode\n+     (Item          : Wide_Wide_String;\n+      Output_Scheme : Encoding_Scheme;\n+      Output_BOM    : Boolean  := False) return UTF_String\n+   is\n+   begin\n+      if Output_Scheme = UTF_8 then\n+         return Encode (Item, Output_BOM);\n+      else\n+         return From_UTF_16 (Encode (Item), Output_Scheme, Output_BOM);\n+      end if;\n+   end Encode;\n+\n+   --  Encode Wide_Wide_String in UTF-8\n+\n+   function Encode\n+     (Item       : Wide_Wide_String;\n+      Output_BOM : Boolean  := False) return UTF_8_String\n+   is\n+      Result : String (1 .. 4 * Item'Length + 3);\n+      --  Worst case is four bytes per input byte + space for BOM\n+\n+      Len  : Natural;\n+      --  Number of output codes stored in Result\n+\n+      C : Unsigned_32;\n+      --  Single input character\n+\n+      procedure Store (C : Unsigned_32);\n+      pragma Inline (Store);\n+      --  Store one output code (input is in range 0 .. 255)\n+\n+      -----------\n+      -- Store --\n+      -----------\n+\n+      procedure Store (C : Unsigned_32) is\n+      begin\n+         Len := Len + 1;\n+         Result (Len) := Character'Val (C);\n+      end Store;\n+\n+   --  Start of processing for Encode\n+\n+   begin\n+      --  Output BOM if required\n+\n+      if Output_BOM then\n+         Result (1 .. 3) := BOM_8;\n+         Len := 3;\n+      else\n+         Len := 0;\n+      end if;\n+\n+      --  Loop through characters of input\n+\n+      for Iptr in Item'Range loop\n+         C := To_Unsigned_32 (Item (Iptr));\n+\n+         --  Codes in the range 16#00#..16#7F# are represented as\n+         --    0xxxxxxx\n+\n+         if C <= 16#7F# then\n+            Store (C);\n+\n+         --  Codes in the range 16#80#..16#7FF# are represented as\n+         --    110yyyxx 10xxxxxx\n+\n+         elsif C <= 16#7FF# then\n+            Store (2#110_00000# or Shift_Right (C, 6));\n+            Store (2#10_000000# or (C and 2#00_111111#));\n+\n+         --  Codes in the range 16#800#..16#D7FF# or 16#E000#..16#FFFD# are\n+         --  represented as\n+         --    1110yyyy 10yyyyxx 10xxxxxx\n+\n+         elsif C <= 16#D7FF# or else C in 16#E000# .. 16#FFFD# then\n+            Store (2#1110_0000# or Shift_Right (C, 12));\n+            Store (2#10_000000# or\n+                     Shift_Right (C and 2#111111_000000#, 6));\n+            Store (2#10_000000# or (C and 2#00_111111#));\n+\n+         --  Codes in the range 16#10000# - 16#10FFFF# are represented as\n+         --    11110zzz 10zzyyyy 10yyyyxx 10xxxxxx\n+\n+         elsif C in 16#1_0000# .. 16#10_FFFF# then\n+            Store (2#11110_000# or\n+                     Shift_Right (C, 18));\n+            Store (2#10_000000# or\n+                     Shift_Right (C and 2#111111_000000_000000#, 12));\n+            Store (2#10_000000# or\n+                     Shift_Right (C and 2#111111_000000#, 6));\n+            Store (2#10_000000# or\n+                     (C and 2#00_111111#));\n+\n+         --  All other codes are invalid\n+\n+         else\n+            Raise_Encoding_Error (Iptr);\n+         end if;\n+      end loop;\n+\n+      return Result (1 .. Len);\n+   end Encode;\n+\n+   --  Encode Wide_Wide_String in UTF-16\n+\n+   function Encode\n+     (Item       : Wide_Wide_String;\n+      Output_BOM : Boolean  := False) return UTF_16_Wide_String\n+   is\n+      Result : Wide_String (1 .. 2 * Item'Length + 1);\n+      --  Worst case is each input character generates two output characters\n+      --  plus one for possible BOM.\n+\n+      Len : Integer;\n+      --  Length of output string\n+\n+      C : Unsigned_32;\n+\n+   begin\n+      --  Output BOM if needed\n+\n+      if Output_BOM then\n+         Result (1) := BOM_16 (1);\n+         Len := 1;\n+      else\n+         Len := 0;\n+      end if;\n+\n+      --  Loop through input characters encoding them\n+\n+      for Iptr in Item'Range loop\n+         C := To_Unsigned_32 (Item (Iptr));\n+\n+         --  Codes in the range 16#00_0000#..16#00_D7FF# or 16#E000#..16#FFFD#\n+         --  are output unchanged\n+\n+         if C <= 16#00_D7FF# or else C in 16#E000# .. 16#FFFD# then\n+            Len := Len + 1;\n+            Result (Len) := Wide_Character'Val (C);\n+\n+         --  Codes in the range 16#01_0000#..16#10_FFFF# are output using two\n+         --  surrogate characters. First 16#1_0000# is subtracted from the code\n+         --  point to give a 20-bit value. This is then split into two separate\n+         --  10-bit values each of which is represented as a surrogate with the\n+         --  most significant half placed in the first surrogate. The ranges of\n+         --  values used for the two surrogates are 16#D800#-16#DBFF# for the\n+         --  first, most significant surrogate and 16#DC00#-16#DFFF# for the\n+         --  second, least significant surrogate.\n+\n+         elsif C in 16#1_0000# ..  16#10_FFFF# then\n+            C := C - 16#1_0000#;\n+\n+            Len := Len + 1;\n+            Result (Len) := Wide_Character'Val (16#D800# + C / 2 ** 10);\n+\n+            Len := Len + 1;\n+            Result (Len) := Wide_Character'Val (16#DC00# + C mod 2 ** 10);\n+\n+         --  All other codes are invalid\n+\n+         else\n+            Raise_Encoding_Error (Iptr);\n+         end if;\n+      end loop;\n+\n+      return Result (1 .. Len);\n+   end Encode;\n+\n+end Ada.Strings.UTF_Encoding.Wide_Wide_Encoding;"}, {"sha": "7d2a91d2b254d4fdbab10487ebe4908cb4cd8373", "filename": "gcc/ada/a-suezen.ads", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fa-suezen.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fa-suezen.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-suezen.ads?ref=6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5", "patch": "@@ -0,0 +1,64 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                ADA.STRINGS.UTF_ENCODING.WIDE_WIDE_ENCODING               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is an Ada 2012 package defined in AI05-0137-1. It is used for encoding\n+--  and decoding Wide_String values using UTF encodings. Note: this package is\n+--  consistent with Ada 2005, and may be used in Ada 2005 mode, but cannot be\n+--  used in Ada 95 mode, since Wide_Wide_Character is an Ada 2005 feature.\n+\n+package Ada.Strings.UTF_Encoding.Wide_Wide_Encoding is\n+   pragma Pure (Wide_Wide_Encoding);\n+\n+   --  The encoding routines take a Wide_Wide_String as input and encode the\n+   --  result using the specified UTF encoding method. The result includes a\n+   --  BOM if the Output_BOM parameter is set to True.\n+\n+   function Encode\n+     (Item          : Wide_Wide_String;\n+      Output_Scheme : Encoding_Scheme;\n+      Output_BOM    : Boolean  := False) return UTF_String;\n+   --  Encode Wide_Wide_String using UTF-8, UTF-16LE or UTF-16BE encoding as\n+   --  specified by the Output_Scheme parameter.\n+\n+   function Encode\n+     (Item       : Wide_Wide_String;\n+      Output_BOM : Boolean  := False) return UTF_8_String;\n+   --  Encode Wide_Wide_String using UTF-8 encoding\n+\n+   function Encode\n+     (Item       : Wide_Wide_String;\n+      Output_BOM : Boolean  := False) return UTF_16_Wide_String;\n+   --  Encode Wide_Wide_String using UTF_16 encoding\n+\n+   --  The decoding routines take a UTF String as input, and return a decoded\n+   --  Wide_String. If the UTF String starts with a BOM that matches the\n+   --  encoding method, it is ignored. An incorrect BOM raises Encoding_Error.\n+\n+   function Decode\n+     (Item         : UTF_String;\n+      Input_Scheme : Encoding_Scheme) return Wide_Wide_String;\n+   --  The input is encoded in UTF_8, UTF_16LE or UTF_16BE as specified by the\n+   --  Input_Scheme parameter. It is decoded and returned as a Wide_Wide_String\n+   --  value. Note: a convenient form for Scheme may be Encoding (UTF_String).\n+\n+   function Decode\n+     (Item : UTF_8_String) return Wide_Wide_String;\n+   --  The input is encoded in UTF-8 and returned as a Wide_Wide_String value\n+\n+   function Decode\n+     (Item : UTF_16_Wide_String) return Wide_Wide_String;\n+   --  The input is encoded in UTF-16 and returned as a Wide_String value\n+\n+end Ada.Strings.UTF_Encoding.Wide_Wide_Encoding;"}, {"sha": "d7fe3a76d30fd5a8eaff4a03e14f6c206d1a3ce3", "filename": "gcc/ada/a-swunau-shared.adb", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fa-swunau-shared.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fa-swunau-shared.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-swunau-shared.adb?ref=6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5", "patch": "@@ -0,0 +1,67 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                          GNAT RUN-TIME COMPONENTS                        --\n+--                                                                          --\n+--        A D A . S T R I N G S . W I D E _ U N B O U N D E D . A U X       --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body Ada.Strings.Wide_Unbounded.Aux is\n+\n+   ---------------------\n+   -- Get_Wide_String --\n+   ---------------------\n+\n+   procedure Get_Wide_String\n+     (U : Unbounded_Wide_String;\n+      S : out Big_Wide_String_Access;\n+      L : out Natural)\n+   is\n+      X : aliased Big_Wide_String;\n+      for X'Address use U.Reference.Data'Address;\n+   begin\n+      S := X'Unchecked_Access;\n+      L := U.Reference.Last;\n+   end Get_Wide_String;\n+\n+   ---------------------\n+   -- Set_Wide_String --\n+   ---------------------\n+\n+   procedure Set_Wide_String\n+     (UP : in out Unbounded_Wide_String;\n+      S  : Wide_String_Access)\n+   is\n+      X : Wide_String_Access := S;\n+\n+   begin\n+      Set_Unbounded_Wide_String (UP, S.all);\n+      Free (X);\n+   end Set_Wide_String;\n+\n+end Ada.Strings.Wide_Unbounded.Aux;"}, {"sha": "110b911d4413ccebce21df81febe720b1bc1c37f", "filename": "gcc/ada/a-swuwti-shared.adb", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fa-swuwti-shared.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fa-swuwti-shared.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-swuwti-shared.adb?ref=6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5", "patch": "@@ -0,0 +1,136 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                  ADA.STRINGS.WIDE_UNBOUNDED.WIDE_TEXT_IO                 --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1997-2009, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Wide_Text_IO; use Ada.Wide_Text_IO;\n+\n+package body Ada.Strings.Wide_Unbounded.Wide_Text_IO is\n+\n+   --------------\n+   -- Get_Line --\n+   --------------\n+\n+   function Get_Line return Unbounded_Wide_String is\n+      Buffer : Wide_String (1 .. 1000);\n+      Last   : Natural;\n+      Result : Unbounded_Wide_String;\n+\n+   begin\n+      Get_Line (Buffer, Last);\n+      Set_Unbounded_Wide_String (Result, Buffer (1 .. Last));\n+\n+      while Last = Buffer'Last loop\n+         Get_Line (Buffer, Last);\n+         Append (Result, Buffer (1 .. Last));\n+      end loop;\n+\n+      return Result;\n+   end Get_Line;\n+\n+   function Get_Line\n+     (File : Ada.Wide_Text_IO.File_Type) return Unbounded_Wide_String\n+   is\n+      Buffer : Wide_String (1 .. 1000);\n+      Last   : Natural;\n+      Result : Unbounded_Wide_String;\n+\n+   begin\n+      Get_Line (File, Buffer, Last);\n+      Set_Unbounded_Wide_String (Result, Buffer (1 .. Last));\n+\n+      while Last = Buffer'Last loop\n+         Get_Line (File, Buffer, Last);\n+         Append (Result, Buffer (1 .. Last));\n+      end loop;\n+\n+      return Result;\n+   end Get_Line;\n+\n+   procedure Get_Line (Item : out Unbounded_Wide_String) is\n+   begin\n+      Get_Line (Current_Input, Item);\n+   end Get_Line;\n+\n+   procedure Get_Line\n+     (File : Ada.Wide_Text_IO.File_Type;\n+      Item : out Unbounded_Wide_String)\n+   is\n+      Buffer : Wide_String (1 .. 1000);\n+      Last   : Natural;\n+\n+   begin\n+      Get_Line (File, Buffer, Last);\n+      Set_Unbounded_Wide_String (Item, Buffer (1 .. Last));\n+\n+      while Last = Buffer'Last loop\n+         Get_Line (File, Buffer, Last);\n+         Append (Item, Buffer (1 .. Last));\n+      end loop;\n+   end Get_Line;\n+\n+   ---------\n+   -- Put --\n+   ---------\n+\n+   procedure Put (U : Unbounded_Wide_String) is\n+      UR : constant Shared_Wide_String_Access := U.Reference;\n+\n+   begin\n+      Put (UR.Data (1 .. UR.Last));\n+   end Put;\n+\n+   procedure Put (File : File_Type; U : Unbounded_Wide_String) is\n+      UR : constant Shared_Wide_String_Access := U.Reference;\n+\n+   begin\n+      Put (File, UR.Data (1 .. UR.Last));\n+   end Put;\n+\n+   --------------\n+   -- Put_Line --\n+   --------------\n+\n+   procedure Put_Line (U : Unbounded_Wide_String) is\n+      UR : constant Shared_Wide_String_Access := U.Reference;\n+\n+   begin\n+      Put_Line (UR.Data (1 .. UR.Last));\n+   end Put_Line;\n+\n+   procedure Put_Line (File : File_Type; U : Unbounded_Wide_String) is\n+      UR : constant Shared_Wide_String_Access := U.Reference;\n+\n+   begin\n+      Put_Line (File, UR.Data (1 .. UR.Last));\n+   end Put_Line;\n+\n+end Ada.Strings.Wide_Unbounded.Wide_Text_IO;"}, {"sha": "eebc228428db264d4b5779d52921278da40b5158", "filename": "gcc/ada/a-szunau-shared.adb", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fa-szunau-shared.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fa-szunau-shared.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-szunau-shared.adb?ref=6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5", "patch": "@@ -0,0 +1,67 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                          GNAT RUN-TIME COMPONENTS                        --\n+--                                                                          --\n+--   A D A . S T R I N G S . W I D E _ W I D E _ U N B O U N D E D . A U X  --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body Ada.Strings.Wide_Wide_Unbounded.Aux is\n+\n+   --------------------------\n+   -- Get_Wide_Wide_String --\n+   --------------------------\n+\n+   procedure Get_Wide_Wide_String\n+     (U : Unbounded_Wide_Wide_String;\n+      S : out Big_Wide_Wide_String_Access;\n+      L : out Natural)\n+   is\n+      X : aliased Big_Wide_Wide_String;\n+      for X'Address use U.Reference.Data'Address;\n+   begin\n+      S := X'Unchecked_Access;\n+      L := U.Reference.Last;\n+   end Get_Wide_Wide_String;\n+\n+   --------------------------\n+   -- Set_Wide_Wide_String --\n+   --------------------------\n+\n+   procedure Set_Wide_Wide_String\n+     (UP : in out Unbounded_Wide_Wide_String;\n+      S  : Wide_Wide_String_Access)\n+   is\n+      X : Wide_Wide_String_Access := S;\n+\n+   begin\n+      Set_Unbounded_Wide_Wide_String (UP, S.all);\n+      Free (X);\n+   end Set_Wide_Wide_String;\n+\n+end Ada.Strings.Wide_Wide_Unbounded.Aux;"}, {"sha": "fe0136ce96a5e47b6eeae506d0b7cf3b3739b318", "filename": "gcc/ada/a-szuzti-shared.adb", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fa-szuzti-shared.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fa-szuzti-shared.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-szuzti-shared.adb?ref=6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5", "patch": "@@ -0,0 +1,137 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                  ADA.STRINGS.WIDE_UNBOUNDED.WIDE_TEXT_IO                 --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1997-2009, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Wide_Wide_Text_IO; use Ada.Wide_Wide_Text_IO;\n+\n+package body Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Text_IO is\n+\n+   --------------\n+   -- Get_Line --\n+   --------------\n+\n+   function Get_Line return Unbounded_Wide_Wide_String is\n+      Buffer : Wide_Wide_String (1 .. 1000);\n+      Last   : Natural;\n+      Result : Unbounded_Wide_Wide_String;\n+\n+   begin\n+      Get_Line (Buffer, Last);\n+      Set_Unbounded_Wide_Wide_String (Result, Buffer (1 .. Last));\n+\n+      while Last = Buffer'Last loop\n+         Get_Line (Buffer, Last);\n+         Append (Result, Buffer (1 .. Last));\n+      end loop;\n+\n+      return Result;\n+   end Get_Line;\n+\n+   function Get_Line\n+     (File : Ada.Wide_Wide_Text_IO.File_Type)\n+      return Unbounded_Wide_Wide_String\n+   is\n+      Buffer : Wide_Wide_String (1 .. 1000);\n+      Last   : Natural;\n+      Result : Unbounded_Wide_Wide_String;\n+\n+   begin\n+      Get_Line (File, Buffer, Last);\n+      Set_Unbounded_Wide_Wide_String (Result, Buffer (1 .. Last));\n+\n+      while Last = Buffer'Last loop\n+         Get_Line (File, Buffer, Last);\n+         Append (Result, Buffer (1 .. Last));\n+      end loop;\n+\n+      return Result;\n+   end Get_Line;\n+\n+   procedure Get_Line (Item : out Unbounded_Wide_Wide_String) is\n+   begin\n+      Get_Line (Current_Input, Item);\n+   end Get_Line;\n+\n+   procedure Get_Line\n+     (File : Ada.Wide_Wide_Text_IO.File_Type;\n+      Item : out Unbounded_Wide_Wide_String)\n+   is\n+      Buffer : Wide_Wide_String (1 .. 1000);\n+      Last   : Natural;\n+\n+   begin\n+      Get_Line (File, Buffer, Last);\n+      Set_Unbounded_Wide_Wide_String (Item, Buffer (1 .. Last));\n+\n+      while Last = Buffer'Last loop\n+         Get_Line (File, Buffer, Last);\n+         Append (Item, Buffer (1 .. Last));\n+      end loop;\n+   end Get_Line;\n+\n+   ---------\n+   -- Put --\n+   ---------\n+\n+   procedure Put (U : Unbounded_Wide_Wide_String) is\n+      UR : constant Shared_Wide_Wide_String_Access := U.Reference;\n+\n+   begin\n+      Put (UR.Data (1 .. UR.Last));\n+   end Put;\n+\n+   procedure Put (File : File_Type; U : Unbounded_Wide_Wide_String) is\n+      UR : constant Shared_Wide_Wide_String_Access := U.Reference;\n+\n+   begin\n+      Put (File, UR.Data (1 .. UR.Last));\n+   end Put;\n+\n+   --------------\n+   -- Put_Line --\n+   --------------\n+\n+   procedure Put_Line (U : Unbounded_Wide_Wide_String) is\n+      UR : constant Shared_Wide_Wide_String_Access := U.Reference;\n+\n+   begin\n+      Put_Line (UR.Data (1 .. UR.Last));\n+   end Put_Line;\n+\n+   procedure Put_Line (File : File_Type; U : Unbounded_Wide_Wide_String) is\n+      UR : constant Shared_Wide_Wide_String_Access := U.Reference;\n+\n+   begin\n+      Put_Line (File, UR.Data (1 .. UR.Last));\n+   end Put_Line;\n+\n+end Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Text_IO;"}, {"sha": "5126e5a1730482757d53f60a6fb5e31ab8bfe78f", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5", "patch": "@@ -280,16 +280,14 @@ package body Exp_Attr is\n    --  Start of processing for Expand_Access_To_Protected_Op\n \n    begin\n-      --  Within the body of the protected type, the prefix\n-      --  designates a local operation, and the object is the first\n-      --  parameter of the corresponding protected body of the\n-      --  current enclosing operation.\n+      --  Within the body of the protected type, the prefix designates a local\n+      --  operation, and the object is the first parameter of the corresponding\n+      --  protected body of the current enclosing operation.\n \n       if Is_Entity_Name (Pref) then\n          if May_Be_External_Call then\n             Sub :=\n-              New_Occurrence_Of\n-                (External_Subprogram (Entity (Pref)), Loc);\n+              New_Occurrence_Of (External_Subprogram (Entity (Pref)), Loc);\n          else\n             Sub :=\n               New_Occurrence_Of\n@@ -372,6 +370,7 @@ package body Exp_Attr is\n         Make_Aggregate (Loc,\n           Expressions => New_List (Obj_Ref, Sub_Ref));\n \n+      Freeze_Before (N, Entity (Sub));\n       Rewrite (N, Agg);\n       Analyze_And_Resolve (N, E_T);\n "}, {"sha": "ee65cb2fdd1d29c6e2303cc1190976b871408c45", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5", "patch": "@@ -407,9 +407,6 @@ ATOMICS_TARGET_PAIRS += \\\n   a-szunau.adb<a-szunau-shared.adb \\\n   a-szuzti.adb<a-szuzti-shared.adb\n \n-# Reset setting for now\n-ATOMICS_TARGET_PAIRS =\n-\n LIB_VERSION = $(strip $(shell grep ' Library_Version :' $(fsrcpfx)ada/gnatvsn.ads | sed -e 's/.*\"\\(.*\\)\".*/\\1/'))\n \n # $(filter-out PATTERN...,TEXT) removes all PATTERN words from TEXT."}, {"sha": "cbd489064ca4baff2bad4dfeb2cbd3c1f8385e97", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5", "patch": "@@ -173,6 +173,14 @@ package body Impunit is\n      \"a-wichun\",    -- Ada.Wide_Characters.Unicode\n      \"a-widcha\",    -- Ada.Wide_Characters\n \n+      --  Note: strictly the next two should be Ada 2012 units, but it seems\n+      --  harmless (and useful) to make then available in Ada 95 mode, since\n+      --  they only deal with Wide_Character, not Wide_Wide_Character.\n+\n+     \"a-stuten\",    -- Ada.Strings.UTF_Encoding\n+     \"a-suenco\",    -- Ada.Strings.UTF_Encoding.Conversions\n+     \"a-suewen\",    -- Ada.Strings.UTF_Encoding.Wide_Encoding\n+\n    ---------------------------\n    -- GNAT Special IO Units --\n    ---------------------------\n@@ -459,10 +467,10 @@ package body Impunit is\n      \"a-szuzti\",    -- Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Text_IO\n      \"a-zchuni\",    -- Ada.Wide_Wide_Characters.Unicode\n \n-      --  Note: strictly the next one should be an Ada 2012 unit, but it seems\n-      --  harmless (and useful) to make it available in Ada 2005 mode.\n+      --  Note: strictly the following should be Ada 2012 units, but it seems\n+      --  harmless (and useful) to make then available in Ada 2005 mode.\n \n-     \"a-stuten\",    -- Ada.Strings.UTF_Encoding\n+     \"a-suezen\",    -- Ada.Strings.UTF_Encoding.Wide_Wide_Encoding\n \n    ---------------------------\n    -- GNAT Special IO Units --"}, {"sha": "5e6d8b2766ae57f9d36dfbe7331ccadba2891897", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 60, "deletions": 54, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5", "patch": "@@ -67,9 +67,9 @@ package body Sem is\n    --  Controls debugging printouts for Walk_Library_Items\n \n    Outer_Generic_Scope : Entity_Id := Empty;\n-   --  Global reference to the outer scope that is generic. In a non\n-   --  generic context, it is empty. At the moment, it is only used\n-   --  for avoiding freezing of external references in generics.\n+   --  Global reference to the outer scope that is generic. In a non- generic\n+   --  context, it is empty. At the moment, it is only used for avoiding\n+   --  freezing of external references in generics.\n \n    Comp_Unit_List : Elist_Id := No_Elist;\n    --  Used by Walk_Library_Items. This is a list of N_Compilation_Unit nodes\n@@ -80,9 +80,9 @@ package body Sem is\n    generic\n       with procedure Action (Withed_Unit : Node_Id);\n    procedure Walk_Withs_Immediate (CU : Node_Id; Include_Limited : Boolean);\n-   --  Walk all the with clauses of CU, and call Action for the with'ed\n-   --  unit. Ignore limited withs, unless Include_Limited is True.\n-   --  CU must be an N_Compilation_Unit.\n+   --  Walk all the with clauses of CU, and call Action for the with'ed unit.\n+   --  Ignore limited withs, unless Include_Limited is True. CU must be an\n+   --  N_Compilation_Unit.\n \n    generic\n       with procedure Action (Withed_Unit : Node_Id);\n@@ -582,14 +582,14 @@ package body Sem is\n          when N_With_Clause =>\n             Analyze_With_Clause (N);\n \n-         --  A call to analyze the Empty node is an error, but most likely\n-         --  it is an error caused by an attempt to analyze a malformed\n-         --  piece of tree caused by some other error, so if there have\n-         --  been any other errors, we just ignore it, otherwise it is\n-         --  a real internal error which we complain about.\n+         --  A call to analyze the Empty node is an error, but most likely it\n+         --  is an error caused by an attempt to analyze a malformed piece of\n+         --  tree caused by some other error, so if there have been any other\n+         --  errors, we just ignore it, otherwise it is a real internal error\n+         --  which we complain about.\n \n-         --  We must also consider the case of call to a runtime function\n-         --  that is not available in the configurable runtime.\n+         --  We must also consider the case of call to a runtime function that\n+         --  is not available in the configurable runtime.\n \n          when N_Empty =>\n             pragma Assert (Serious_Errors_Detected /= 0\n@@ -846,7 +846,7 @@ package body Sem is\n          return;\n       end if;\n \n-      --  Now search the global entity suppress table for a matching entry\n+      --  Now search the global entity suppress table for a matching entry.\n       --  We also search this in reverse order so that if there are multiple\n       --  pragmas for the same entity, the last one applies.\n \n@@ -1114,12 +1114,12 @@ package body Sem is\n          Node := First (L);\n          Insert_List_After (N, L);\n \n-         --  Now just analyze from the original first node until we get to\n-         --  the successor of the original insertion point (which may be\n-         --  Empty if the insertion point was at the end of the list). Note\n-         --  that this properly handles the case where any of the analyze\n-         --  calls result in the insertion of nodes after the analyzed\n-         --  node (possibly calling this routine recursively).\n+         --  Now just analyze from the original first node until we get to the\n+         --  successor of the original insertion point (which may be Empty if\n+         --  the insertion point was at the end of the list). Note that this\n+         --  properly handles the case where any of the analyze calls result in\n+         --  the insertion of nodes after the analyzed node (possibly calling\n+         --  this routine recursively).\n \n          while Node /= After loop\n             Analyze (Node);\n@@ -1165,9 +1165,9 @@ package body Sem is\n    begin\n       if Is_Non_Empty_List (L) then\n \n-         --  Capture the Node_Id of the first list node to be inserted.\n-         --  This will still be the first node after the insert operation,\n-         --  since Insert_List_After does not modify the Node_Id values.\n+         --  Capture the Node_Id of the first list node to be inserted. This\n+         --  will still be the first node after the insert operation, since\n+         --  Insert_List_After does not modify the Node_Id values.\n \n          Node := First (L);\n          Insert_List_Before (N, L);\n@@ -1222,9 +1222,9 @@ package body Sem is\n       Ptr : Suppress_Stack_Entry_Ptr;\n \n    begin\n-      --  First search the local entity suppress stack, we search this from the\n-      --  top of the stack down, so that we get the innermost entry that\n-      --  applies to this case if there are nested entries.\n+      --  First search the local entity suppress stack. We search this from the\n+      --  top of the stack down so that we get the innermost entry that applies\n+      --  to this case if there are nested entries.\n \n       Ptr := Local_Suppress_Stack_Top;\n       while Ptr /= null loop\n@@ -1237,7 +1237,7 @@ package body Sem is\n          Ptr := Ptr.Prev;\n       end loop;\n \n-      --  Now search the global entity suppress table for a matching entry\n+      --  Now search the global entity suppress table for a matching entry.\n       --  We also search this from the top down so that if there are multiple\n       --  pragmas for the same entity, the last one applies (not clear what\n       --  or whether the RM specifies this handling, but it seems reasonable).\n@@ -1327,10 +1327,10 @@ package body Sem is\n    procedure Semantics (Comp_Unit : Node_Id) is\n \n       --  The following locations save the corresponding global flags and\n-      --  variables so that they can be restored on completion. This is\n-      --  needed so that calls to Rtsfind start with the proper default\n-      --  values for these variables, and also that such calls do not\n-      --  disturb the settings for units being analyzed at a higher level.\n+      --  variables so that they can be restored on completion. This is needed\n+      --  so that calls to Rtsfind start with the proper default values for\n+      --  these variables, and also that such calls do not disturb the settings\n+      --  for units being analyzed at a higher level.\n \n       S_Current_Sem_Unit : constant Unit_Number_Type := Current_Sem_Unit;\n       S_Full_Analysis    : constant Boolean          := Full_Analysis;\n@@ -1348,12 +1348,12 @@ package body Sem is\n       --  context, is compiled with expansion disabled.\n \n       Save_Config_Switches : Config_Switches_Type;\n-      --  Variable used to save values of config switches while we analyze\n-      --  the new unit, to be restored on exit for proper recursive behavior.\n+      --  Variable used to save values of config switches while we analyze the\n+      --  new unit, to be restored on exit for proper recursive behavior.\n \n       procedure Do_Analyze;\n-      --  Procedure to analyze the compilation unit. This is called more\n-      --  than once when the high level optimizer is activated.\n+      --  Procedure to analyze the compilation unit. This is called more than\n+      --  once when the high level optimizer is activated.\n \n       ----------------\n       -- Do_Analyze --\n@@ -1584,8 +1584,8 @@ package body Sem is\n \n             when N_Package_Body  =>\n \n-               --  Package bodies are processed separately if the main\n-               --  unit depends on them.\n+               --  Package bodies are processed separately if the main unit\n+               --  depends on them.\n \n                null;\n \n@@ -1741,8 +1741,8 @@ package body Sem is\n \n             Do_Withed_Units (CU, Include_Limited => False);\n \n-            --  Process the unit if it is a spec or the the main unit, if\n-            --  it has no previous spec or we have done all other units.\n+            --  Process the unit if it is a spec or the the main unit, if it\n+            --  has no previous spec or we have done all other units.\n \n             if not Nkind_In (Item, N_Package_Body, N_Subprogram_Body)\n               or else Acts_As_Spec (CU)\n@@ -1793,9 +1793,13 @@ package body Sem is\n          procedure Do_Withed_Units is new Walk_Withs (Do_Withed_Unit);\n \n          function Depends_On_Main (CU : Node_Id) return Boolean;\n-         --  The body of a unit that is withed by the spec of the main\n-         --  unit may in turn have a with_clause on that spec. In that\n-         --  case do not traverse the body, to prevent loops.\n+         --  The body of a unit that is withed by the spec of the main unit\n+         --  may in turn have a with_clause on that spec. In that case do not\n+         --  traverse the body, to prevent loops. It can also happen that the\n+         --  main body as a with_clause on a child, which of course has an\n+         --  implicit with on its parent. It's ok to traverse the child body\n+         --  if the main spec has been processed, otherwise we also have a\n+         --  circularity to avoid.\n \n          ---------------------\n          -- Depends_On_Main --\n@@ -1816,6 +1820,8 @@ package body Sem is\n             while Present (CL) loop\n                if Nkind (CL) = N_With_Clause\n                  and then Library_Unit (CL) = Library_Unit (Main_CU)\n+                 and then\n+                   not Done (Get_Cunit_Unit_Number (Library_Unit (CL)))\n                then\n                   return True;\n                end if;\n@@ -1864,7 +1870,7 @@ package body Sem is\n \n       --  Local Declarations\n \n-      Cur     : Elmt_Id;\n+      Cur : Elmt_Id;\n \n    --  Start of processing for Walk_Library_Items\n \n@@ -1917,15 +1923,15 @@ package body Sem is\n                --  separate spec.\n \n                --  If it's a package body, ignore it, unless it is a body\n-               --  created for an instance that is the main unit. In the\n-               --  case of subprograms, the body is the wrapper package. In\n-               --  case of a package, the original file carries the body,\n-               --  and the spec appears as a later entry in the units list.\n+               --  created for an instance that is the main unit. In the case\n+               --  of subprograms, the body is the wrapper package. In case of\n+               --  a package, the original file carries the body, and the spec\n+               --  appears as a later entry in the units list.\n \n-               --  Otherwise Bodies appear in the list only because of\n-               --  inlining/instantiations, and they are processed only\n-               --  if relevant to the main unit. The main unit itself\n-               --  is processed separately after all other specs.\n+               --  Otherwise Bodies appear in the list only because of inlining\n+               --  or instantiations, and they are processed only if relevant\n+               --  to the main unit. The main unit itself is processed\n+               --  separately after all other specs.\n \n                when N_Subprogram_Body =>\n                   if Acts_As_Spec (N) then\n@@ -1943,7 +1949,7 @@ package body Sem is\n                         Unit (Library_Unit (Main_CU)));\n                   end if;\n \n-               --  It's a spec, process it, and the units it depends on.\n+               --  It's a spec, process it, and the units it depends on\n \n                when others =>\n                   Do_Unit_And_Dependents (CU, N);\n@@ -1953,8 +1959,8 @@ package body Sem is\n          Next_Elmt (Cur);\n       end loop;\n \n-      --  Now process package bodies on which main depends, followed by\n-      --  bodies of parents, if present, and finally main itself.\n+      --  Now process package bodies on which main depends, followed by bodies\n+      --  of parents, if present, and finally main itself.\n \n       if not Done (Main_Unit) then\n          Do_Main := True;"}, {"sha": "e5afd0cebb8452dd4da6782cc7629a14b2eda795", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=6e1ee5c3d2023c7988a868b60ce0683bbcecb7e5", "patch": "@@ -12284,7 +12284,7 @@ package body Sem_Prag is\n                   elsif not Is_Static_String_Expression (Arg1) then\n                      Error_Pragma_Arg\n                        (\"argument of pragma% must be On/Off or \" &\n-                        \"static string expression\", Arg2);\n+                        \"static string expression\", Arg1);\n \n                   --  One argument string expression case\n \n@@ -12504,6 +12504,11 @@ package body Sem_Prag is\n             raise Program_Error;\n       end case;\n \n+      --  AI05-0144: detect dangerous order dependence. Disabled for now,\n+      --  until AI is formally approved.\n+\n+      --  Check_Order_Dependence;\n+\n    exception\n       when Pragma_Exit => null;\n    end Analyze_Pragma;"}]}