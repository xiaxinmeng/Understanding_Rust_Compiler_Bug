{"sha": "e65fc7c572594c8c4e38edb56fd6a6eb401fd4b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY1ZmM3YzU3MjU5NGM4YzRlMzhlZGI1NmZkNmE2ZWI0MDFmZDRiNA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-03-21T15:14:02Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2018-03-21T15:14:02Z"}, "message": "PR c++/84850 - -Wclass-memaccess on a memcpy in a copy assignment operator with no nontrivial bases or members\n\ngcc/cp/ChangeLog:\n\n\tPR c++/84850\n\t* call.c (first_non_public_field): New template and function.\n\t(first_non_trivial_field): New function.\n\t(maybe_warn_class_memaccess): Call them.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/84850\n\t* g++.dg/Wclass-memaccess-3.C: New test.\n\t* g++.dg/Wclass-memaccess-4.C: New test.\n\nFrom-SVN: r258719", "tree": {"sha": "2fc52168e184bdb48ef7c4dadd3a4d4d7033f535", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2fc52168e184bdb48ef7c4dadd3a4d4d7033f535"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e65fc7c572594c8c4e38edb56fd6a6eb401fd4b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e65fc7c572594c8c4e38edb56fd6a6eb401fd4b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e65fc7c572594c8c4e38edb56fd6a6eb401fd4b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e65fc7c572594c8c4e38edb56fd6a6eb401fd4b4/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2a80d3ae14f6f823e28637fd28b5808a6e4aa5ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a80d3ae14f6f823e28637fd28b5808a6e4aa5ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a80d3ae14f6f823e28637fd28b5808a6e4aa5ba"}], "stats": {"total": 422, "additions": 405, "deletions": 17}, "files": [{"sha": "36e07d9bd9a0282612bc413ff4bfd33cb7aca3c2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e65fc7c572594c8c4e38edb56fd6a6eb401fd4b4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e65fc7c572594c8c4e38edb56fd6a6eb401fd4b4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e65fc7c572594c8c4e38edb56fd6a6eb401fd4b4", "patch": "@@ -1,3 +1,10 @@\n+2018-03-21  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/84850\n+\t* call.c (first_non_public_field): New template and function.\n+\t(first_non_trivial_field): New function.\n+\t(maybe_warn_class_memaccess): Call them.\n+\n 2018-03-21  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR c++/84892"}, {"sha": "1a87f99130f29a891b09856b0934dae5c4c5d69e", "filename": "gcc/cp/call.c", "status": "modified", "additions": 66, "deletions": 17, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e65fc7c572594c8c4e38edb56fd6a6eb401fd4b4/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e65fc7c572594c8c4e38edb56fd6a6eb401fd4b4/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=e65fc7c572594c8c4e38edb56fd6a6eb401fd4b4", "patch": "@@ -8261,13 +8261,17 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n   return call;\n }\n \n-/* Return the DECL of the first non-public data member of class TYPE\n-   or null if none can be found.  */\n+namespace\n+{\n \n-static tree\n-first_non_public_field (tree type)\n+/* Return the DECL of the first non-static subobject of class TYPE\n+   that satisfies the predicate PRED or null if none can be found.  */\n+\n+template <class Predicate>\n+tree\n+first_non_static_field (tree type, Predicate pred)\n {\n-  if (!CLASS_TYPE_P (type))\n+  if (!type || !CLASS_TYPE_P (type))\n     return NULL_TREE;\n \n   for (tree field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n@@ -8276,7 +8280,7 @@ first_non_public_field (tree type)\n \tcontinue;\n       if (TREE_STATIC (field))\n \tcontinue;\n-      if (TREE_PRIVATE (field) || TREE_PROTECTED (field))\n+      if (pred (field))\n \treturn field;\n     }\n \n@@ -8286,14 +8290,51 @@ first_non_public_field (tree type)\n        BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n     {\n       tree base = TREE_TYPE (base_binfo);\n-\n-      if (tree field = first_non_public_field (base))\n+      if (pred (base))\n+\treturn base;\n+      if (tree field = first_non_static_field (base, pred))\n \treturn field;\n     }\n \n   return NULL_TREE;\n }\n \n+struct NonPublicField\n+{\n+  bool operator() (const_tree t)\n+  {\n+    return DECL_P (t) && (TREE_PRIVATE (t) || TREE_PROTECTED (t));\n+  }\n+};\n+\n+/* Return the DECL of the first non-public subobject of class TYPE\n+   or null if none can be found.  */\n+\n+static inline tree\n+first_non_public_field (tree type)\n+{\n+  return first_non_static_field (type, NonPublicField ());\n+}\n+\n+struct NonTrivialField\n+{\n+  bool operator() (const_tree t)\n+  {\n+    return !trivial_type_p (DECL_P (t) ? TREE_TYPE (t) : t);\n+  }\n+};\n+\n+/* Return the DECL of the first non-trivial subobject of class TYPE\n+   or null if none can be found.  */\n+\n+static inline tree\n+first_non_trivial_field (tree type)\n+{\n+  return first_non_static_field (type, NonTrivialField ());\n+}\n+\n+}   /* unnamed namespace */\n+\n /* Return true if all copy and move assignment operator overloads for\n    class TYPE are trivial and at least one of them is not deleted and,\n    when ACCESS is set, accessible.  Return false otherwise.  Set\n@@ -8419,22 +8460,30 @@ maybe_warn_class_memaccess (location_t loc, tree fndecl,\n   if (!desttype || !COMPLETE_TYPE_P (desttype) || !CLASS_TYPE_P (desttype))\n     return;\n \n-  /* Check to see if the raw memory call is made by a ctor or dtor\n-     with this as the destination argument for the destination type.\n-     If so, be more permissive.  */\n+  /* Check to see if the raw memory call is made by a non-static member\n+     function with THIS as the destination argument for the destination\n+     type.  If so, and if the class has no non-trivial bases or members,\n+     be more permissive.  */\n   if (current_function_decl\n-      && (DECL_CONSTRUCTOR_P (current_function_decl)\n-\t  || DECL_DESTRUCTOR_P (current_function_decl))\n+      && DECL_NONSTATIC_MEMBER_FUNCTION_P (current_function_decl)\n       && is_this_parameter (tree_strip_nop_conversions (dest)))\n     {\n       tree ctx = DECL_CONTEXT (current_function_decl);\n       bool special = same_type_ignoring_top_level_qualifiers_p (ctx, desttype);\n-\n       tree binfo = TYPE_BINFO (ctx);\n \n-      /* A ctor and dtor for a class with no bases and no virtual functions\n-\t can do whatever they want.  Bail early with no further checking.  */\n-      if (special && !BINFO_VTABLE (binfo) && !BINFO_N_BASE_BINFOS (binfo))\n+      /* FIXME: The following if statement is overly permissive (see\n+\t bug 84851).  Remove it in GCC 9.  */\n+      if (special\n+\t  && !BINFO_VTABLE (binfo)\n+\t  && !BINFO_N_BASE_BINFOS (binfo)\n+\t  && (DECL_CONSTRUCTOR_P (current_function_decl)\n+\t      || DECL_DESTRUCTOR_P (current_function_decl)))\n+\treturn;\n+\n+      if (special\n+\t  && !BINFO_VTABLE (binfo)\n+\t  && !first_non_trivial_field (desttype))\n \treturn;\n     }\n "}, {"sha": "1b8c63b469fc113d1b876deadbf600dfb8a950bd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e65fc7c572594c8c4e38edb56fd6a6eb401fd4b4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e65fc7c572594c8c4e38edb56fd6a6eb401fd4b4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e65fc7c572594c8c4e38edb56fd6a6eb401fd4b4", "patch": "@@ -1,3 +1,9 @@\n+2018-03-21  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/84850\n+\t* g++.dg/Wclass-memaccess-3.C: New test.\n+\t* g++.dg/Wclass-memaccess-4.C: New test.\n+\n 2018-03-21  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR c++/84892"}, {"sha": "36e0e682c387246443964f2c9e06b9ae7a32abbe", "filename": "gcc/testsuite/g++.dg/Wclass-memaccess-3.C", "status": "added", "additions": 287, "deletions": 0, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e65fc7c572594c8c4e38edb56fd6a6eb401fd4b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FWclass-memaccess-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e65fc7c572594c8c4e38edb56fd6a6eb401fd4b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FWclass-memaccess-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FWclass-memaccess-3.C?ref=e65fc7c572594c8c4e38edb56fd6a6eb401fd4b4", "patch": "@@ -0,0 +1,287 @@\n+/* PR c++/84850 - -Wclass-memaccess on a memcpy in a copy assignment\n+   operator with no nontrivial bases or members\n+   { dg-do compile }\n+   { dg-options \"-Wclass-memaccess -ftrack-macro-expansion=0\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern \"C\" void* memcpy (void*, const void*, size_t);\n+extern \"C\" void* memset (void*, int, size_t);\n+\n+template <int>\n+struct EmptyClass { };\n+\n+template <int>\n+struct TrivialClass\n+{\n+  bool a;\n+  int b;\n+  void *c;\n+  double d[2];\n+  void (*e)();\n+};\n+\n+template <int>\n+struct HasDefault\n+{\n+  HasDefault ();\n+};\n+\n+/* Verify that raw memory accesses from non-static members of a class with\n+   an empty base is not diagnosed.  */\n+\n+struct EmptyWithBase: EmptyClass<0>, EmptyClass<1>, EmptyClass<2>\n+{\n+  EmptyWithBase ()\n+  {\n+    memset (this, 0, sizeof *this);\n+  }\n+\n+  EmptyWithBase (const EmptyWithBase &x)\n+  {\n+    memcpy (this, &x, sizeof *this);\n+  }\n+\n+  ~EmptyWithBase ()\n+  {\n+    memset (this, 0, sizeof *this);\n+  }\n+\n+  void operator= (const EmptyWithBase &x)\n+  {\n+    memcpy (this, &x, sizeof *this);\n+  }\n+\n+  void clear ()\n+  {\n+    memset (this, 0, sizeof *this);   // { dg-bogus \"\\\\\\[-Wclass-memaccess\" }\n+  }\n+\n+  void copy (const void *p)\n+  {\n+    memcpy (this, p, sizeof *this);   // { dg-bogus \"\\\\\\[-Wclass-memaccess\" }\n+  }\n+\n+  static void bad_clear (EmptyWithBase &x)\n+  {\n+    memset (&x, 0, sizeof x);         // { dg-warning \"\\\\\\[-Wclass-memaccess\" }\n+  }\n+\n+  static void bad_copy (EmptyWithBase &x, const void *p)\n+  {\n+    memcpy (&x, p, sizeof x);         // { dg-warning \"\\\\\\[-Wclass-memaccess\" }\n+  }\n+};\n+\n+/* Verify that raw memory accesses from non-static members of a class with\n+   all trivial members is not diagnosed.  */\n+\n+struct HasTrivialMembers\n+{\n+  bool a;\n+  int b;\n+  void *c;\n+  double d[2];\n+  void (*e)();\n+\n+  TrivialClass<1> trivial;\n+\n+  HasTrivialMembers ()\n+  {\n+    memset (this, 0, sizeof *this);\n+  }\n+\n+  HasTrivialMembers (const HasTrivialMembers &x)\n+  {\n+    memcpy (this, &x, sizeof *this);\n+  }\n+\n+  ~HasTrivialMembers ()\n+  {\n+    memset (this, 0, sizeof *this);\n+  }\n+\n+  void operator= (const HasTrivialMembers &x)\n+  {\n+    memcpy (this, &x, sizeof *this);\n+  }\n+\n+  void clear ()\n+  {\n+    memset (this, 0, sizeof *this);   // { dg-bogus \"\\\\\\[-Wclass-memaccess\" }\n+  }\n+\n+  void copy (const void *p)\n+  {\n+    memcpy (this, p, sizeof *this);   // { dg-bogus \"\\\\\\[-Wclass-memaccess\" }\n+  }\n+\n+  static void bad_clear (HasTrivialMembers &x)\n+  {\n+    memset (&x, 0, sizeof x);         // { dg-warning \"\\\\\\[-Wclass-memaccess\" }\n+  }\n+\n+  static void bad_copy (HasTrivialMembers &x, const void *p)\n+  {\n+    memcpy (&x, p, sizeof x);         // { dg-warning \"\\\\\\[-Wclass-memaccess\" }\n+  }\n+};\n+\n+/* Verify that raw memory accesses from non-static members of a class with\n+   a trivial base class and no non-trivial members is not diagnosed.  */\n+\n+struct HasTrivialBase: TrivialClass<1>\n+{\n+  TrivialClass<2> a[2];\n+\n+  HasTrivialBase ()\n+  {\n+    memset (this, 0, sizeof *this);   // { dg-bogus \"\\\\\\[-Wclass-memaccess\" }\n+  }\n+\n+  HasTrivialBase (const HasTrivialBase &x)\n+  {\n+    memcpy (this, &x, sizeof *this);  // { dg-bogus \"\\\\\\[-Wclass-memaccess\" }\n+  }\n+\n+  ~HasTrivialBase ()\n+  {\n+    memset (this, 0, sizeof *this);   // { dg-bogus \"\\\\\\[-Wclass-memaccess\" }\n+  }\n+\n+  void operator= (const HasTrivialBase &x)\n+  {\n+    memcpy (this, &x, sizeof *this);\n+  }\n+\n+  void clear ()\n+  {\n+    memset (this, 0, sizeof *this);   // { dg-bogus \"\\\\\\[-Wclass-memaccess\" }\n+  }\n+\n+  void copy (void *p)\n+  {\n+    memcpy (this, p, sizeof *this);   // { dg-bogus \"\\\\\\[-Wclass-memaccess\" }\n+  }\n+};\n+\n+\n+struct HasTrivialBases: TrivialClass<1>, TrivialClass<2>\n+{\n+  TrivialClass<3> a[2];\n+\n+  HasTrivialBases ()\n+  {\n+    memset (this, 0, sizeof *this);   // { dg-bogus \"\\\\\\[-Wclass-memaccess\" }\n+  }\n+\n+  HasTrivialBases (const HasTrivialBases &x)\n+  {\n+    memcpy (this, &x, sizeof *this);  // { dg-bogus \"\\\\\\[-Wclass-memaccess\" }\n+  }\n+\n+  ~HasTrivialBases ()\n+  {\n+    memset (this, 0, sizeof *this);   // { dg-bogus \"\\\\\\[-Wclass-memaccess\" }\n+  }\n+\n+  void operator= (const HasTrivialBases &x)\n+  {\n+    memcpy (this, &x, sizeof *this);\n+  }\n+\n+  void clear ()\n+  {\n+    memset (this, 0, sizeof *this);   // { dg-bogus \"\\\\\\[-Wclass-memaccess\" }\n+  }\n+\n+  void copy (void *p)\n+  {\n+    memcpy (this, p, sizeof *this);   // { dg-bogus \"\\\\\\[-Wclass-memaccess\" }\n+  }\n+};\n+\n+struct DerivesFromNontrivialClass: HasDefault<1> { };\n+\n+/* Verify that raw memory accesses from members of a class with a non-trivial\n+   base class is diagnosed.  */\n+\n+struct HasNonTrivialBase: TrivialClass<1>, TrivialClass<2>,\n+\t\t\t  DerivesFromNontrivialClass,\n+\t\t\t  TrivialClass<3>, TrivialClass<4>\n+{\n+  HasNonTrivialBase ()\n+  {\n+    memset (this, 0, sizeof *this);   // { dg-warning \"\\\\\\[-Wclass-memaccess\" }\n+  }\n+\n+  HasNonTrivialBase (const HasNonTrivialBase &x)\n+  {\n+    memcpy (this, &x, sizeof *this);  // { dg-warning \"\\\\\\[-Wclass-memaccess\" }\n+  }\n+\n+  ~HasNonTrivialBase ()\n+  {\n+    memset (this, 0, sizeof *this);   // { dg-warning \"\\\\\\[-Wclass-memaccess\" }\n+  }\n+\n+  HasNonTrivialBase& operator= (const HasNonTrivialBase &x)\n+  {\n+    memcpy (this, &x, sizeof *this);  // { dg-warning \"\\\\\\[-Wclass-memaccess\" }\n+    return *this;\n+  }\n+\n+  void clear ()\n+  {\n+    memset (this, 0, sizeof *this);   // { dg-warning \"\\\\\\[-Wclass-memaccess\" }\n+  }\n+\n+  void copy (void *p)\n+  {\n+    memcpy (this, p, sizeof *this);   // { dg-warning \"\\\\\\[-Wclass-memaccess\" }\n+  }\n+};\n+\n+struct DerivesIndidirectlyFromNontrivialClass:\n+  TrivialClass<1>, TrivialClass<2>,\n+  DerivesFromNontrivialClass,\n+  TrivialClass<3>, TrivialClass<4> { };\n+\n+/* Verify that raw memory accesses from members of a class with a non-trivial\n+   indirect base class is diagnosed.  */\n+\n+struct HasIndirectNonTrivialBase: TrivialClass<5>, TrivialClass<6>,\n+\t\t\t\t  TrivialClass<7>, TrivialClass<8>,\n+\t\t\t\t  DerivesIndidirectlyFromNontrivialClass\n+{\n+  HasIndirectNonTrivialBase ()\n+  {\n+    memset (this, 0, sizeof *this);   // { dg-warning \"\\\\\\[-Wclass-memaccess\" }\n+  }\n+\n+  HasIndirectNonTrivialBase (const HasIndirectNonTrivialBase &x)\n+  {\n+    memcpy (this, &x, sizeof *this);  // { dg-warning \"\\\\\\[-Wclass-memaccess\" }\n+  }\n+\n+  ~HasIndirectNonTrivialBase ()\n+  {\n+    memset (this, 0, sizeof *this);   // { dg-warning \"\\\\\\[-Wclass-memaccess\" }\n+  }\n+\n+  HasIndirectNonTrivialBase& operator= (const HasIndirectNonTrivialBase &x)\n+  {\n+    memcpy (this, &x, sizeof *this);  // { dg-warning \"\\\\\\[-Wclass-memaccess\" }\n+    return *this;\n+  }\n+\n+  void clear ()\n+  {\n+    memset (this, 0, sizeof *this);   // { dg-warning \"\\\\\\[-Wclass-memaccess\" }\n+  }\n+\n+  void copy (void *p)\n+  {\n+    memcpy (this, p, sizeof *this);   // { dg-warning \"\\\\\\[-Wclass-memaccess\" }\n+  }\n+};"}, {"sha": "8c334219099ecb3948a17ea470d2cd29b47cd014", "filename": "gcc/testsuite/g++.dg/Wclass-memaccess-4.C", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e65fc7c572594c8c4e38edb56fd6a6eb401fd4b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FWclass-memaccess-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e65fc7c572594c8c4e38edb56fd6a6eb401fd4b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FWclass-memaccess-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FWclass-memaccess-4.C?ref=e65fc7c572594c8c4e38edb56fd6a6eb401fd4b4", "patch": "@@ -0,0 +1,39 @@\n+/* PR c++/84850 - missing -Wclass-memaccess for a memcpy in a copy ctor\n+   with a non-trivial member\n+   { dg-do compile }\n+   { dg-options \"-Wclass-memaccess -ftrack-macro-expansion=0\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern \"C\" void* memcpy (void*, const void*, size_t);\n+\n+struct A\n+{\n+  const int &r;\n+\n+  A ();\n+\n+  A (const A&);\n+\n+  virtual ~A ();\n+};\n+\n+struct C\n+{\n+  A a;\n+\n+  C (const C&);\n+\n+  C& operator= (const C&);\n+};\n+\n+C::C (const C &c)\n+{\n+  memcpy (this, &c, sizeof c);    // { dg-warning \"\\\\\\[-Wclass-memaccess]\" \"pr84851\" { xfail *-*-*} }\n+}\n+\n+C& C::operator= (const C &c)\n+{\n+  memcpy (this, &c, sizeof c);    // { dg-warning \"\\\\\\[-Wclass-memaccess]\" }\n+  return *this;\n+}"}]}