{"sha": "decdfa827101f082b55286b7c0aa3fe8858bc6e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGVjZGZhODI3MTAxZjA4MmI1NTI4NmI3YzBhYTNmZTg4NThiYzZlOQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-10-05T06:28:37Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-10-05T06:28:37Z"}, "message": "(init_optabs): Use cabs as the only libcall for abs.\n\n(expand_complex_abs): New function.\n(expand_unop, expand_binop): Use gen_realpart, gen_imagpart.\n\nFrom-SVN: r2321", "tree": {"sha": "d01c2b147b44f424be8ed937ff719d0b9f2f257b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d01c2b147b44f424be8ed937ff719d0b9f2f257b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/decdfa827101f082b55286b7c0aa3fe8858bc6e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/decdfa827101f082b55286b7c0aa3fe8858bc6e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/decdfa827101f082b55286b7c0aa3fe8858bc6e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/decdfa827101f082b55286b7c0aa3fe8858bc6e9/comments", "author": null, "committer": null, "parents": [{"sha": "86b25e81b92c5b7cc9d8855a0343aa676dc750b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86b25e81b92c5b7cc9d8855a0343aa676dc750b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86b25e81b92c5b7cc9d8855a0343aa676dc750b0"}], "stats": {"total": 253, "additions": 205, "deletions": 48}, "files": [{"sha": "f054d5254763d21ffdf25dd0cd0cec0d6cf081ac", "filename": "gcc/optabs.c", "status": "modified", "additions": 205, "deletions": 48, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/decdfa827101f082b55286b7c0aa3fe8858bc6e9/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/decdfa827101f082b55286b7c0aa3fe8858bc6e9/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=decdfa827101f082b55286b7c0aa3fe8858bc6e9", "patch": "@@ -862,21 +862,21 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \n       start_sequence ();\n \n-      realr = gen_lowpart  (submode, target);\n-      imagr = gen_highpart (submode, target);\n+      realr = gen_realpart  (submode, target);\n+      imagr = gen_imagpart (submode, target);\n \n       if (GET_MODE (op0) == mode)\n \t{\n-\t  real0 = gen_lowpart  (submode, op0);\n-\t  imag0 = gen_highpart (submode, op0);\n+\t  real0 = gen_realpart  (submode, op0);\n+\t  imag0 = gen_imagpart (submode, op0);\n \t}\n       else\n \treal0 = op0;\n \n       if (GET_MODE (op1) == mode)\n \t{\n-\t  real1 = gen_lowpart  (submode, op1);\n-\t  imag1 = gen_highpart (submode, op1);\n+\t  real1 = gen_realpart  (submode, op1);\n+\t  imag1 = gen_imagpart (submode, op1);\n \t}\n       else\n \treal1 = op1;\n@@ -1537,16 +1537,16 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n       \n       start_sequence ();\n \n-      target_piece = gen_highpart (submode, target);\n+      target_piece = gen_imagpart (submode, target);\n       x = expand_unop (submode, unoptab,\n-\t\t       gen_highpart (submode, op0),\n+\t\t       gen_imagpart (submode, op0),\n \t\t       target_piece, unsignedp);\n       if (target_piece != x)\n \temit_move_insn (target_piece, x);\n \n-      target_piece = gen_lowpart (submode, target);\n+      target_piece = gen_realpart (submode, target);\n       x = expand_unop (submode, unoptab,\n-\t\t       gen_lowpart (submode, op0),\n+\t\t       gen_realpart (submode, op0),\n \t\t       target_piece, unsignedp);\n       if (target_piece != x)\n \temit_move_insn (target_piece, x);\n@@ -1559,41 +1559,6 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n       return target;\n     }\n \n-  /* Open-code the complex absolute-value operation\n-     if we can open-code sqrt.  Otherwise it's not worth while.  */\n-  else if (unoptab == abs_optab\n-\t   && (class == MODE_COMPLEX_FLOAT || class == MODE_COMPLEX_INT))\n-    {\n-      /* Find the correct mode for the real and imaginary parts */\n-      enum machine_mode submode\n-\t= mode_for_size (GET_MODE_UNIT_SIZE (mode) * BITS_PER_UNIT,\n-\t\t\t class == MODE_COMPLEX_INT ? MODE_INT : MODE_FLOAT,\n-\t\t\t 0);\n-\n-      if (submode == BLKmode)\n-\tabort ();\n-\n-      if (sqrt_optab->handlers[(int) submode].insn_code != CODE_FOR_nothing)\n-\t{\n-\t  rtx real, imag, total;\n-\n-\t  real = gen_highpart (submode, op0);\n-\t  imag = gen_lowpart (submode, op0);\n-\t  /* Square both parts.  */\n-\t  real = expand_mult (mode, real, real, NULL_RTX, 0);\n-\t  imag = expand_mult (mode, imag, imag, NULL_RTX, 0);\n-\t  /* Sum the parts.  */\n-\t  total = expand_binop (submode, add_optab, real, imag, 0,\n-\t\t\t\t0, OPTAB_LIB_WIDEN);\n-\t  /* Get sqrt in TARGET.  Set TARGET to where the result is.  */\n-\t  target = expand_unop (submode, sqrt_optab, total, target, 0);\n-\t  if (target == 0)\n-\t    delete_insns_since (last);\n-\t  else\n-\t    return target;\n-\t}\n-    }\n-\n   /* Now try a library call in this mode.  */\n   if (unoptab->handlers[(int) mode].libfunc)\n     {\n@@ -1666,6 +1631,196 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n   return 0;\n }\n \f\n+/* Emit code to compute the absolute value of OP0, with result to\n+   TARGET if convenient.  (TARGET may be 0.)  The return value says\n+   where the result actually is to be found.\n+\n+   MODE is the mode of the operand; the mode of the result is\n+   different but can be deduced from MODE.\n+\n+   UNSIGNEDP is relevant for complex integer modes.  */\n+\n+rtx\n+expand_complex_abs (mode, op0, target, unsignedp)\n+     enum machine_mode mode;\n+     rtx op0;\n+     rtx target;\n+     int unsignedp;\n+{\n+  enum mode_class class = GET_MODE_CLASS (mode);\n+  enum machine_mode wider_mode;\n+  register rtx temp;\n+  rtx last = get_last_insn ();\n+  rtx pat;\n+\n+  /* Find the correct mode for the real and imaginary parts.  */\n+  enum machine_mode submode\n+    = mode_for_size (GET_MODE_UNIT_SIZE (mode) * BITS_PER_UNIT,\n+\t\t     class == MODE_COMPLEX_INT ? MODE_INT : MODE_FLOAT,\n+\t\t     0);\n+\n+  if (submode == BLKmode)\n+    abort ();\n+\n+  op0 = protect_from_queue (op0, 0);\n+\n+  if (flag_force_mem)\n+    {\n+      op0 = force_not_mem (op0);\n+    }\n+\n+  if (target)\n+    target = protect_from_queue (target, 1);\n+\n+  if (abs_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+    {\n+      int icode = (int) abs_optab->handlers[(int) mode].insn_code;\n+      enum machine_mode mode0 = insn_operand_mode[icode][1];\n+      rtx xop0 = op0;\n+\n+      if (target)\n+\ttemp = target;\n+      else\n+\ttemp = gen_reg_rtx (submode);\n+\n+      if (GET_MODE (xop0) != VOIDmode\n+\t  && GET_MODE (xop0) != mode0)\n+\txop0 = convert_to_mode (mode0, xop0, unsignedp);\n+\n+      /* Now, if insn doesn't accept our operand, put it into a pseudo.  */\n+\n+      if (! (*insn_operand_predicate[icode][1]) (xop0, mode0))\n+\txop0 = copy_to_mode_reg (mode0, xop0);\n+\n+      if (! (*insn_operand_predicate[icode][0]) (temp, submode))\n+\ttemp = gen_reg_rtx (submode);\n+\n+      pat = GEN_FCN (icode) (temp, xop0);\n+      if (pat)\n+\t{\n+\t  if (GET_CODE (pat) == SEQUENCE\n+\t      && ! add_equal_note (pat, temp, abs_optab->code, xop0, NULL_RTX))\n+\t    {\n+\t      delete_insns_since (last);\n+\t      return expand_unop (mode, abs_optab, op0, NULL_RTX, unsignedp);\n+\t    }\n+\n+\t  emit_insn (pat);\n+\t  \n+\t  return temp;\n+\t}\n+      else\n+\tdelete_insns_since (last);\n+    }\n+\n+  /* It can't be done in this mode.  Can we open-code it in a wider mode?  */\n+\n+  for (wider_mode = GET_MODE_WIDER_MODE (mode); wider_mode != VOIDmode;\n+       wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n+    {\n+      if (abs_optab->handlers[(int) wider_mode].insn_code != CODE_FOR_nothing)\n+\t{\n+\t  rtx xop0 = op0;\n+\n+\t  xop0 = convert_to_mode (wider_mode, xop0, unsignedp);\n+\t  temp = expand_complex_abs (wider_mode, xop0, NULL_RTX, unsignedp);\n+\n+\t  if (temp)\n+\t    {\n+\t      if (class != MODE_COMPLEX_INT)\n+\t\t{\n+\t\t  if (target == 0)\n+\t\t    target = gen_reg_rtx (submode);\n+\t\t  convert_move (target, temp, 0);\n+\t\t  return target;\n+\t\t}\n+\t      else\n+\t\treturn gen_lowpart (submode, temp);\n+\t    }\n+\t  else\n+\t    delete_insns_since (last);\n+\t}\n+    }\n+\n+  /* Open-code the complex absolute-value operation\n+     if we can open-code sqrt.  Otherwise it's not worth while.  */\n+  if (sqrt_optab->handlers[(int) submode].insn_code != CODE_FOR_nothing)\n+    {\n+      rtx real, imag, total;\n+\n+      real = gen_realpart (submode, op0);\n+      imag = gen_imagpart (submode, op0);\n+      /* Square both parts.  */\n+      real = expand_mult (mode, real, real, NULL_RTX, 0);\n+      imag = expand_mult (mode, imag, imag, NULL_RTX, 0);\n+      /* Sum the parts.  */\n+      total = expand_binop (submode, add_optab, real, imag, 0,\n+\t\t\t    0, OPTAB_LIB_WIDEN);\n+      /* Get sqrt in TARGET.  Set TARGET to where the result is.  */\n+      target = expand_unop (submode, sqrt_optab, total, target, 0);\n+      if (target == 0)\n+\tdelete_insns_since (last);\n+      else\n+\treturn target;\n+    }\n+\n+  /* Now try a library call in this mode.  */\n+  if (abs_optab->handlers[(int) mode].libfunc)\n+    {\n+      rtx insns;\n+      rtx funexp = abs_optab->handlers[(int) mode].libfunc;\n+\n+      start_sequence ();\n+\n+      /* Pass 1 for NO_QUEUE so we don't lose any increments\n+\t if the libcall is cse'd or moved.  */\n+      emit_library_call (abs_optab->handlers[(int) mode].libfunc,\n+\t\t\t 1, mode, 1, op0, mode);\n+      insns = get_insns ();\n+      end_sequence ();\n+\n+      target = gen_reg_rtx (submode);\n+      emit_libcall_block (insns, target, hard_libcall_value (submode),\n+\t\t\t  gen_rtx (abs_optab->code, mode, op0));\n+\n+      return target;\n+    }\n+\n+  /* It can't be done in this mode.  Can we do it in a wider mode?  */\n+\n+  for (wider_mode = GET_MODE_WIDER_MODE (mode); wider_mode != VOIDmode;\n+       wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n+    {\n+      if ((abs_optab->handlers[(int) wider_mode].insn_code\n+\t   != CODE_FOR_nothing)\n+\t  || abs_optab->handlers[(int) wider_mode].libfunc)\n+\t{\n+\t  rtx xop0 = op0;\n+\n+\t  xop0 = convert_to_mode (wider_mode, xop0, unsignedp);\n+\n+\t  temp = expand_complex_abs (wider_mode, xop0, NULL_RTX, unsignedp);\n+\n+\t  if (temp)\n+\t    {\n+\t      if (class != MODE_COMPLEX_INT)\n+\t\t{\n+\t\t  if (target == 0)\n+\t\t    target = gen_reg_rtx (submode);\n+\t\t  convert_move (target, temp, 0);\n+\t\t  return target;\n+\t\t}\n+\t      else\n+\t\treturn gen_lowpart (submode, temp);\n+\t    }\n+\t  else\n+\t    delete_insns_since (last);\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\f\n /* Generate an instruction whose insn-code is INSN_CODE,\n    with two operands: an output TARGET and an input OP0.\n    TARGET *must* be nonzero, and the output is always stored there.\n@@ -4559,9 +4714,11 @@ init_optabs ()\n   if (HAVE_abstf2)\n     abs_optab->handlers[(int) TFmode].insn_code = CODE_FOR_abstf2;\n #endif\n-  /* No library calls here for real types.  If there is no abs instruction,\n-     expand_expr will generate a conditional negation.  */\n-  init_complex_libfuncs (abs_optab, \"abs\", '2');\n+\n+  /* Use cabs for DC complex abs, since systems generally have cabs.\n+     Don't define any libcall for SCmode, so that cabs will be used.  */\n+  abs_optab->handlers[(int) DCmode].libfunc\n+    = gen_rtx (SYMBOL_REF, Pmode, \"cabs\");\n \n #ifdef HAVE_sqrtqi2\n   if (HAVE_sqrtqi2)"}]}