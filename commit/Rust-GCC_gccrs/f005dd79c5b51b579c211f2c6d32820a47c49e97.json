{"sha": "f005dd79c5b51b579c211f2c6d32820a47c49e97", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjAwNWRkNzljNWI1MWI1NzljMjExZjJjNmQzMjgyMGE0N2M0OWU5Nw==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@redhat.com", "date": "2007-01-12T12:30:56Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2007-01-12T12:30:56Z"}, "message": "i386-signal.h: Rewrite to use rt_sigaction.\n\n2007-01-12  Andrew Haley  <aph@redhat.com>\n\n        * include/i386-signal.h: Rewrite to use rt_sigaction.\n\nFrom-SVN: r120721", "tree": {"sha": "8754739f481223da9b5dc0ac55171b2cb264f9c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8754739f481223da9b5dc0ac55171b2cb264f9c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f005dd79c5b51b579c211f2c6d32820a47c49e97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f005dd79c5b51b579c211f2c6d32820a47c49e97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f005dd79c5b51b579c211f2c6d32820a47c49e97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f005dd79c5b51b579c211f2c6d32820a47c49e97/comments", "author": {"login": "theRealAph", "id": 254637, "node_id": "MDQ6VXNlcjI1NDYzNw==", "avatar_url": "https://avatars.githubusercontent.com/u/254637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theRealAph", "html_url": "https://github.com/theRealAph", "followers_url": "https://api.github.com/users/theRealAph/followers", "following_url": "https://api.github.com/users/theRealAph/following{/other_user}", "gists_url": "https://api.github.com/users/theRealAph/gists{/gist_id}", "starred_url": "https://api.github.com/users/theRealAph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theRealAph/subscriptions", "organizations_url": "https://api.github.com/users/theRealAph/orgs", "repos_url": "https://api.github.com/users/theRealAph/repos", "events_url": "https://api.github.com/users/theRealAph/events{/privacy}", "received_events_url": "https://api.github.com/users/theRealAph/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8e7682148505b21e6295a118b1b2cb05107f9b34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e7682148505b21e6295a118b1b2cb05107f9b34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e7682148505b21e6295a118b1b2cb05107f9b34"}], "stats": {"total": 128, "additions": 72, "deletions": 56}, "files": [{"sha": "1269fc862f82c5018a80fb35fac9cd3454672605", "filename": "libjava/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f005dd79c5b51b579c211f2c6d32820a47c49e97/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f005dd79c5b51b579c211f2c6d32820a47c49e97/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=f005dd79c5b51b579c211f2c6d32820a47c49e97", "patch": "@@ -1,3 +1,7 @@\n+2007-01-12  Andrew Haley  <aph@redhat.com>\n+\n+\t* include/i386-signal.h: Rewrite to use rt_sigaction.\n+\n 2007-01-11  Andrew Haley  <aph@redhat.com>\n \n \t* prims.cc (jdwpOptions) Fix deprecated cast from char[] constant"}, {"sha": "a3d3a1b75f094e4dce5c0c7a7958a73b448b036a", "filename": "libjava/include/i386-signal.h", "status": "modified", "additions": 67, "deletions": 55, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f005dd79c5b51b579c211f2c6d32820a47c49e97/libjava%2Finclude%2Fi386-signal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f005dd79c5b51b579c211f2c6d32820a47c49e97/libjava%2Finclude%2Fi386-signal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fi386-signal.h?ref=f005dd79c5b51b579c211f2c6d32820a47c49e97", "patch": "@@ -1,7 +1,7 @@\n // i386-signal.h - Catch runtime signals and turn them into exceptions\n // on an i386 based Linux system.\n \n-/* Copyright (C) 1998, 1999, 2001, 2002, 2006  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2001, 2002, 2006, 2007  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -19,46 +19,51 @@ details.  */\n #define HANDLE_SEGV 1\n #define HANDLE_FPE 1\n \n-#define SIGNAL_HANDLER(_name)\t\\\n-static void _name (int _dummy __attribute__ ((__unused__)))\n-\n-#define MAKE_THROW_FRAME(_exception)\n+#define SIGNAL_HANDLER(_name)\t\t\t\t\t\\\n+static void _Jv_##_name (int, siginfo_t *,\t\t\t\\\n+\t\t\t void *_p __attribute__ ((__unused__)))\n \n #define HANDLE_DIVIDE_OVERFLOW\t\t\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  void **_p = (void **)&_dummy;\t\t\t\t\t\t\\\n-  volatile struct sigcontext_struct *_regs = (struct sigcontext_struct *)++_p;\\\n-\t\t\t\t\t\t\t\t\t\\\n-  register unsigned char *_eip = (unsigned char *)_regs->eip;\t\t\\\n+  struct ucontext *_uc = (struct ucontext *)_p;\t\t\t\t\\\n+  gregset_t &_gregs = _uc->uc_mcontext.gregs;\t\t\t\t\\\n+  unsigned char *_eip = (unsigned char *)_gregs[REG_EIP];\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   /* According to the JVM spec, \"if the dividend is the negative\t\\\n-   * integer of the smallest magnitude and the divisor is -1, then\t\\\n-   * overflow occurs and the result is equal to the dividend.  Despite\t\\\n-   * the overflow, no exception occurs\".\t\t\t\t\\\n+   * integer of largest possible magnitude for the type and the\t\t\\\n+   * divisor is -1, then overflow occurs and the result is equal to\t\\\n+   * the dividend.  Despite the overflow, no exception occurs\".\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n    * We handle this by inspecting the instruction which generated the\t\\\n-   * signal and advancing eip to point to the following instruction.\t\\\n+   * signal and advancing ip to point to the following instruction.\t\\\n    * As the instructions are variable length it is necessary to do a\t\\\n    * little calculation to figure out where the following instruction\t\\\n    * actually is.\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-   */\t\t\t\t\t\t\t\t\t\\\n+  */\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n+  /* Detect a signed division of Integer.MIN_VALUE.  */\t\t\t\\\n   if (_eip[0] == 0xf7)\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n+      bool _min_value_dividend = false;\t\t\t\t\t\\\n       unsigned char _modrm = _eip[1];\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-      if (_regs->eax == 0x80000000\t\t\t\t\t\\\n-\t  && ((_modrm >> 3) & 7) == 7) /* Signed divide */\t\t\\\n+      if (((_modrm >> 3) & 7) == 7) /* Signed divide */\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  _min_value_dividend =\t\t\t\t\t\t\\\n+\t    _gregs[REG_EAX] == (greg_t)0x80000000UL;\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (_min_value_dividend)\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n \t  unsigned char _rm = _modrm & 7;\t\t\t\t\\\n-\t  _regs->edx = 0; /* the remainder is zero */\t\t\t\\\n+\t  _gregs[REG_EDX] = 0; /* the remainder is zero */\t\t\\\n \t  switch (_modrm >> 6)\t\t\t\t\t\t\\\n \t    {\t\t\t\t\t\t\t\t\\\n \t    case 0:  /* register indirect */\t\t\t\t\\\n \t      if (_rm == 5)   /* 32-bit displacement */\t\t\t\\\n-\t\t_eip += 4;   \t\t\t\t\t\t\\\n+\t\t_eip += 4;\t\t\t\t\t\t\\\n \t      if (_rm == 4)  /* A SIB byte follows the ModR/M byte */\t\\\n \t\t_eip += 1;\t\t\t\t\t\t\\\n \t      break;\t\t\t\t\t\t\t\\\n@@ -76,63 +81,70 @@ do\t\t\t\t\t\t\t\t\t\\\n \t      break;\t\t\t\t\t\t\t\\\n \t    }\t\t\t\t\t\t\t\t\\\n \t  _eip += 2;\t\t\t\t\t\t\t\\\n-\t  _regs->eip = (unsigned long)_eip;\t\t\t\t\\\n+\t  _gregs[REG_EIP] = (greg_t)_eip;\t\t\t\t\\\n \t  return;\t\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n }\t\t\t\t\t\t\t\t\t\\\n while (0)\n \n-/* We use old_kernel_sigaction here because we're calling the kernel\n+/* We use kernel_sigaction here because we're calling the kernel\n    directly rather than via glibc.  The sigaction structure that the\n    syscall uses is a different shape from the one in userland and not\n    visible to us in a header file so we define it here.  */\n \n-struct old_i386_kernel_sigaction {\n-\tvoid (*k_sa_handler) (int);\n-\tunsigned long k_sa_mask;\n-\tunsigned long k_sa_flags;\n-\tvoid (*sa_restorer) (void);\n-};\n+extern \"C\" \n+{\n+  struct kernel_sigaction \n+  {\n+    void (*k_sa_sigaction)(int,siginfo_t *,void *);\n+    unsigned long k_sa_flags;\n+    void (*k_sa_restorer) (void);\n+    sigset_t k_sa_mask;\n+  };\n+}\n+\n+#define MAKE_THROW_FRAME(_exception)\n \n #define RESTORE(name, syscall) RESTORE2 (name, syscall)\n-# define RESTORE2(name, syscall) \\\n+#define RESTORE2(name, syscall)\t\t\t\\\n asm\t\t\t\t\t\t\\\n   (\t\t\t\t\t\t\\\n    \".text\\n\"\t\t\t\t\t\\\n    \".byte 0  # Yes, this really is necessary\\n\" \\\n-   \"\t.align 8\\n\"\t\t\t\t\\\n+   \"\t.align 16\\n\"\t\t\t\t\\\n    \"__\" #name \":\\n\"\t\t\t\t\\\n-   \"\tpopl %eax\\n\"\t\t\t\t\\\n    \"\tmovl $\" #syscall \", %eax\\n\"\t\t\\\n    \"\tint  $0x80\"\t\t\t\t\\\n    );\n \n-RESTORE (restore, __NR_sigreturn)\n-static void restore (void) asm (\"__restore\");\n-\n-#define INIT_SEGV\t\t\t\t\t\\\n-do\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\\\n-    struct old_i386_kernel_sigaction kact;\t\t\\\n-    kact.k_sa_handler = catch_segv;\t\t\t\\\n-    kact.k_sa_mask = 0;\t\t\t\t\t\\\n-    kact.k_sa_flags = 0x4000000;\t\t\t\\\n-    kact.sa_restorer = restore;\t\t\t\t\\\n-    syscall (SYS_sigaction, SIGSEGV, &kact, NULL);\t\\\n-  }\t\t\t\t\t\t\t\\\n+/* The return code for realtime-signals.  */\n+RESTORE (restore_rt, __NR_rt_sigreturn)\n+void restore_rt (void) asm (\"__restore_rt\")\n+  __attribute__ ((visibility (\"hidden\")));\n+\n+#define INIT_SEGV\t\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    struct kernel_sigaction act;\t\t\t\t\\\n+    act.k_sa_sigaction = _Jv_catch_segv;\t\t\t\\\n+    sigemptyset (&act.k_sa_mask);\t\t\t\t\\\n+    act.k_sa_flags = SA_SIGINFO|0x4000000;\t\t\t\\\n+    act.k_sa_restorer = restore_rt;\t\t\t\t\\\n+    syscall (SYS_rt_sigaction, SIGSEGV, &act, NULL, _NSIG / 8);\t\\\n+  }\t\t\t\t\t\t\t\t\\\n while (0)  \n \n-#define INIT_FPE\t\t\t\t\t\\\n-do\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\\\n-    struct old_i386_kernel_sigaction kact;\t\t\\\n-    kact.k_sa_handler = catch_fpe;\t\t\t\\\n-    kact.k_sa_mask = 0;\t\t\t\t\t\\\n-    kact.k_sa_flags = 0x4000000;\t\t\t\\\n-    kact.sa_restorer = restore;\t\t\t\t\\\n-    syscall (SYS_sigaction, SIGFPE, &kact, NULL);\t\\\n-  }\t\t\t\t\t\t\t\\\n+#define INIT_FPE\t\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    struct kernel_sigaction act;\t\t\t\t\\\n+    act.k_sa_sigaction = _Jv_catch_fpe;\t\t\t\t\\\n+    sigemptyset (&act.k_sa_mask);\t\t\t\t\\\n+    act.k_sa_flags = SA_SIGINFO|0x4000000;\t\t\t\\\n+    act.k_sa_restorer = restore_rt;\t\t\t\t\\\n+    syscall (SYS_rt_sigaction, SIGFPE, &act, NULL, _NSIG / 8);\t\\\n+  }\t\t\t\t\t\t\t\t\\\n while (0)  \n \n /* You might wonder why we use syscall(SYS_sigaction) in INIT_FPE\n@@ -147,9 +159,9 @@ while (0)\n  * syscall(SYS_sigaction) causes our handler to be called directly\n  * by the kernel, bypassing any wrappers.\n \n- * Also, there is at the present time no unwind info in the\n- * linuxthreads library's signal handlers and so we can't unwind\n- * through them anyway.  */\n+ * Also, there may not be any unwind info in the linuxthreads\n+ * library's signal handlers and so we can't unwind through them\n+ * anyway.  */\n \n #endif /* JAVA_SIGNAL_H */\n   "}, {"sha": "4bd8a360115e1b404027a5c57b69ffba674c8eb0", "filename": "libjava/include/x86_64-signal.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f005dd79c5b51b579c211f2c6d32820a47c49e97/libjava%2Finclude%2Fx86_64-signal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f005dd79c5b51b579c211f2c6d32820a47c49e97/libjava%2Finclude%2Fx86_64-signal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fx86_64-signal.h?ref=f005dd79c5b51b579c211f2c6d32820a47c49e97", "patch": "@@ -1,7 +1,7 @@\n // x86_64-signal.h - Catch runtime signals and turn them into exceptions\n // on an x86_64 based GNU/Linux system.\n \n-/* Copyright (C) 2003, 2006  Free Software Foundation\n+/* Copyright (C) 2003, 2006, 2007  Free Software Foundation\n \n    This file is part of libgcj.\n "}]}