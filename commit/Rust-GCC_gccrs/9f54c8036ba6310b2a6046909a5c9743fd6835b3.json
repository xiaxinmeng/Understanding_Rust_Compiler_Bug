{"sha": "9f54c8036ba6310b2a6046909a5c9743fd6835b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWY1NGM4MDM2YmE2MzEwYjJhNjA0NjkwOWE1Yzk3NDNmZDY4MzViMw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-06-09T23:39:34Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-06-09T23:39:34Z"}, "message": "pt.c (fn_type_unification): Revise documentation.\n\n\t* pt.c (fn_type_unification): Revise documentation.  Tidy.\n\t(type_unification): Likewise.\n\nFrom-SVN: r20393", "tree": {"sha": "052954b0f133640fd1dcf4902a621b3232779a88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/052954b0f133640fd1dcf4902a621b3232779a88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f54c8036ba6310b2a6046909a5c9743fd6835b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f54c8036ba6310b2a6046909a5c9743fd6835b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f54c8036ba6310b2a6046909a5c9743fd6835b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f54c8036ba6310b2a6046909a5c9743fd6835b3/comments", "author": null, "committer": null, "parents": [{"sha": "ac1fdb22b8df0622528a2c7ad7d90e1ad16cae67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac1fdb22b8df0622528a2c7ad7d90e1ad16cae67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac1fdb22b8df0622528a2c7ad7d90e1ad16cae67"}], "stats": {"total": 84, "additions": 49, "deletions": 35}, "files": [{"sha": "8fa60f4fef79b1abc2180de6862515086a168481", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f54c8036ba6310b2a6046909a5c9743fd6835b3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f54c8036ba6310b2a6046909a5c9743fd6835b3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9f54c8036ba6310b2a6046909a5c9743fd6835b3", "patch": "@@ -1,3 +1,8 @@\n+1998-06-09  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* pt.c (fn_type_unification): Revise documentation.  Tidy.\n+\t(type_unification): Likewise.\n+\n 1998-06-09  Andrew MacLeod  <amacleod@cygnus.com>\n \n \t* semantics.c (finish_try_block): Rename expand_start_catch, and delete"}, {"sha": "2a06dabc49dae3b4d16f86a84e81c6106915fcc1", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 44, "deletions": 35, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f54c8036ba6310b2a6046909a5c9743fd6835b3/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f54c8036ba6310b2a6046909a5c9743fd6835b3/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=9f54c8036ba6310b2a6046909a5c9743fd6835b3", "patch": "@@ -5665,10 +5665,19 @@ overload_template_name (type)\n   pushdecl_class_level (decl);\n }\n \n-\n /* Like type_unification but designed specially to handle conversion\n-   operators.  The EXTRA_FN_ARG, if any, is the type of an additional\n-   parameter to be added to the beginning of FN's parameter list.  */\n+   operators.  \n+\n+   The FN is a TEMPLATE_DECL for a function.  The ARGS are the\n+   arguments that are being used when calling it.  \n+\n+   If FN is a conversion operator, RETURN_TYPE is the type desired as\n+   the result of the conversion operator.\n+\n+   The EXTRA_FN_ARG, if any, is the type of an additional\n+   parameter to be added to the beginning of FN's parameter list.  \n+\n+   The other arguments are as for type_unification.  */\n \n int\n fn_type_unification (fn, explicit_targs, targs, args, return_type,\n@@ -5677,40 +5686,35 @@ fn_type_unification (fn, explicit_targs, targs, args, return_type,\n      unification_kind_t strict;\n      tree extra_fn_arg;\n {\n-  int i;\n-  tree fn_arg_types = TYPE_ARG_TYPES (TREE_TYPE (fn));\n-  tree decl_arg_types = args;\n+  tree parms;\n \n   my_friendly_assert (TREE_CODE (fn) == TEMPLATE_DECL, 0);\n \n+  parms = TYPE_ARG_TYPES (TREE_TYPE (fn));\n+\n   if (IDENTIFIER_TYPENAME_P (DECL_NAME (fn))) \n     {\n       /* This is a template conversion operator.  Use the return types\n          as well as the argument types.  */\n-      fn_arg_types = scratch_tree_cons (NULL_TREE, \n-\t\t\t\t\tTREE_TYPE (TREE_TYPE (fn)),\n-\t\t\t\t\tfn_arg_types);\n-      decl_arg_types = scratch_tree_cons (NULL_TREE,\n-\t\t\t\t\t  return_type,\n-\t\t\t\t\t  decl_arg_types);\n+      parms = scratch_tree_cons (NULL_TREE, \n+\t\t\t\t TREE_TYPE (TREE_TYPE (fn)),\n+\t\t\t\t parms);\n+      args = scratch_tree_cons (NULL_TREE, return_type, args);\n     }\n \n   if (extra_fn_arg != NULL_TREE)\n-    fn_arg_types = scratch_tree_cons (NULL_TREE, extra_fn_arg,\n-\t\t\t\t      fn_arg_types); \n+    parms = scratch_tree_cons (NULL_TREE, extra_fn_arg, parms);\n \n   /* We allow incomplete unification without an error message here\n      because the standard doesn't seem to explicitly prohibit it.  Our\n      callers must be ready to deal with unification failures in any\n      event.  */\n-  i = type_unification (DECL_INNERMOST_TEMPLATE_PARMS (fn), \n-\t\t\ttargs,\n-\t\t\tfn_arg_types,\n-\t\t\tdecl_arg_types,\n-\t\t\texplicit_targs,\n-\t\t\tstrict, 1);\n-\n-  return i;\n+  return type_unification (DECL_INNERMOST_TEMPLATE_PARMS (fn), \n+\t\t\t   targs,\n+\t\t\t   parms,\n+\t\t\t   args,\n+\t\t\t   explicit_targs,\n+\t\t\t   strict, 1);\n }\n \n \n@@ -5725,14 +5729,15 @@ fn_type_unification (fn, explicit_targs, targs, args, return_type,\n    all the types, and 1 for complete failure.  An error message will be\n    printed only for an incomplete match.\n \n-   TPARMS[NTPARMS] is an array of template parameter types;\n-   TARGS[NTPARMS] is the array of template parameter values.  PARMS is\n-   the function template's signature (using TEMPLATE_PARM_IDX nodes),\n-   and ARGS is the argument list we're trying to match against it.\n+   TPARMS[NTPARMS] is an array of template parameter types.\n \n-   If SUBR is 1, we're being called recursively (to unify the arguments of\n-   a function or method parameter of a function template), so don't zero\n-   out targs and don't fail on an incomplete match.\n+   TARGS[NTPARMS] is the array into which the deduced template\n+   parameter values are placed.  PARMS is the function template's\n+   signature (using TEMPLATE_PARM_IDX nodes), and ARGS is the argument\n+   list we're trying to match against it.\n+\n+   The EXPLICIT_TARGS are explicit template arguments provided via a\n+   template-id.\n \n    The parameter STRICT is one of:\n \n@@ -5749,14 +5754,14 @@ fn_type_unification (fn, explicit_targs, targs, args, return_type,\n      ordering between specializations of function or class\n      templates, as in [temp.func.order] and [temp.class.order],\n      when doing an explicit instantiation as in [temp.explicit],\n-     when determiningan explicit specialization as in\n+     when determining an explicit specialization as in\n      [temp.expl.spec], or when taking the address of a function\n      template, as in [temp.deduct.funcaddr].  */\n \n int\n-type_unification (tparms, targs, parms, args, targs_in,\n+type_unification (tparms, targs, parms, args, explicit_targs,\n \t\t  strict, allow_incomplete)\n-     tree tparms, targs, parms, args, targs_in;\n+     tree tparms, targs, parms, args, explicit_targs;\n      unification_kind_t strict;\n      int allow_incomplete;\n {\n@@ -5766,10 +5771,10 @@ type_unification (tparms, targs, parms, args, targs_in,\n   for (i = 0; i < TREE_VEC_LENGTH (tparms); i++)\n     TREE_VEC_ELT (targs, i) = NULL_TREE;\n \n-  if (targs_in != NULL_TREE)\n+  if (explicit_targs != NULL_TREE)\n     {\n       tree arg_vec;\n-      arg_vec = coerce_template_parms (tparms, targs_in, NULL_TREE, 0,\n+      arg_vec = coerce_template_parms (tparms, explicit_targs, NULL_TREE, 0,\n \t\t\t\t       0, 0);\n \n       if (arg_vec == error_mark_node)\n@@ -5873,7 +5878,11 @@ maybe_adjust_types_for_deduction (strict, parm, arg)\n \n /* Like type_unfication.  EXPLICIT_MASK, if non-NULL, is an array of\n    integers, with ones in positions corresponding to arguments in\n-   targs that were provided explicitly, and zeros elsewhere.  */\n+   targs that were provided explicitly, and zeros elsewhere.  \n+\n+   If SUBR is 1, we're being called recursively (to unify the\n+   arguments of a function or method parameter of a function\n+   template).  */\n \n static int\n type_unification_real (tparms, targs, parms, args, subr,"}]}