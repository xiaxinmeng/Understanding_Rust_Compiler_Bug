{"sha": "89d12f5d49829d3dbf9a78040b88df833923c0df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODlkMTJmNWQ0OTgyOWQzZGJmOWE3ODA0MGI4OGRmODMzOTIzYzBkZg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2005-02-02T23:13:53Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2005-02-02T23:13:53Z"}, "message": "tree.c (build_int_cst_type): Take sign of the value into account when deciding whether sign extend the value.\n\n\t* tree.c (build_int_cst_type): Take sign of the value into account\n\twhen deciding whether sign extend the value.\n\nFrom-SVN: r94633", "tree": {"sha": "3537b64131b90538c5df621e848c272621fac78d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3537b64131b90538c5df621e848c272621fac78d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89d12f5d49829d3dbf9a78040b88df833923c0df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89d12f5d49829d3dbf9a78040b88df833923c0df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89d12f5d49829d3dbf9a78040b88df833923c0df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89d12f5d49829d3dbf9a78040b88df833923c0df/comments", "author": null, "committer": null, "parents": [{"sha": "740ca4b2b10f7b6bd13568988b659b436143b1a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/740ca4b2b10f7b6bd13568988b659b436143b1a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/740ca4b2b10f7b6bd13568988b659b436143b1a9"}], "stats": {"total": 52, "additions": 40, "deletions": 12}, "files": [{"sha": "31c8ea822dbcea081cbc461f50963f78a3a2c9e5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d12f5d49829d3dbf9a78040b88df833923c0df/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d12f5d49829d3dbf9a78040b88df833923c0df/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=89d12f5d49829d3dbf9a78040b88df833923c0df", "patch": "@@ -1,3 +1,8 @@\n+2005-02-02  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* tree.c (build_int_cst_type): Take sign of the value into account\n+\twhen deciding whether sign extend the value.\n+\n 2005-02-02  Joseph S. Myers  <joseph@codesourcery.com>\n \n \tPR c/18502"}, {"sha": "6afc17f1f46652a39507f190fe2b060c9eb459d3", "filename": "gcc/tree.c", "status": "modified", "additions": 35, "deletions": 12, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d12f5d49829d3dbf9a78040b88df833923c0df/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d12f5d49829d3dbf9a78040b88df833923c0df/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=89d12f5d49829d3dbf9a78040b88df833923c0df", "patch": "@@ -497,39 +497,62 @@ build_int_cstu (tree type, unsigned HOST_WIDE_INT low)\n   return build_int_cst_wide (type, low, 0);\n }\n \n-/* Create an INT_CST node with a LOW value zero or sign extended depending\n-   on the type.  */\n+/* Create an INT_CST node with a LOW value in TYPE.  The value is sign extended\n+   if it is negative.  This function is similar to build_int_cst, but\n+   the extra bits outside of the type precision are cleared.  Constants\n+   with these extra bits may confuse the fold so that it detects overflows\n+   even in cases when they do not occur, and in general should be avoided.\n+   We cannot however make this a default behavior of build_int_cst without\n+   more intrusive changes, since there are parts of gcc that rely on the extra\n+   precision of the integer constants.  */\n \n tree\n build_int_cst_type (tree type, HOST_WIDE_INT low)\n {\n   unsigned HOST_WIDE_INT val = (unsigned HOST_WIDE_INT) low;\n+  unsigned HOST_WIDE_INT hi;\n   unsigned bits;\n   bool signed_p;\n   bool negative;\n-  tree ret;\n \n   if (!type)\n     type = integer_type_node;\n \n   bits = TYPE_PRECISION (type);\n   signed_p = !TYPE_UNSIGNED (type);\n-  negative = ((val >> (bits - 1)) & 1) != 0;\n \n-  if (signed_p && negative)\n+  if (bits >= HOST_BITS_PER_WIDE_INT)\n+    negative = (low < 0);\n+  else\n     {\n-      if (bits < HOST_BITS_PER_WIDE_INT)\n+      /* If the sign bit is inside precision of LOW, use it to determine\n+\t the sign of the constant.  */\n+      negative = ((val >> (bits - 1)) & 1) != 0;\n+\n+      /* Mask out the bits outside of the precision of the constant.  */\n+      if (signed_p && negative)\n \tval = val | ((~(unsigned HOST_WIDE_INT) 0) << bits);\n-      ret = build_int_cst_wide (type, val, ~(unsigned HOST_WIDE_INT) 0);\n+      else\n+\tval = val & ~((~(unsigned HOST_WIDE_INT) 0) << bits);\n     }\n-  else\n+\n+  /* Determine the high bits.  */\n+  hi = (negative ? ~(unsigned HOST_WIDE_INT) 0 : 0);\n+\n+  /* For unsigned type we need to mask out the bits outside of the type\n+     precision.  */\n+  if (!signed_p)\n     {\n-      if (bits < HOST_BITS_PER_WIDE_INT)\n-\tval = val & ~((~(unsigned HOST_WIDE_INT) 0) << bits);\n-      ret = build_int_cst_wide (type, val, 0);\n+      if (bits <= HOST_BITS_PER_WIDE_INT)\n+\thi = 0;\n+      else\n+\t{\n+\t  bits -= HOST_BITS_PER_WIDE_INT;\n+\t  hi = hi & ~((~(unsigned HOST_WIDE_INT) 0) << bits);\n+\t}\n     }\n \n-  return ret;\n+  return build_int_cst_wide (type, val, hi);\n }\n \n /* These are the hash table functions for the hash table of INTEGER_CST"}]}