{"sha": "d08eefb9d2cb72e7168d3b790111d6c07ce87a8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDA4ZWVmYjlkMmNiNzJlNzE2OGQzYjc5MDExMWQ2YzA3Y2U4N2E4YQ==", "commit": {"author": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@ispras.ru", "date": "2006-03-16T05:20:39Z"}, "committer": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2006-03-16T05:20:39Z"}, "message": "sched-rgn.c (extend_rgns): New static function.\n\n2006-03-16  Maxim Kuvyrkov <mkuvyrkov@ispras.ru>\n\n\t* sched-rgn.c (extend_rgns): New static function.\n\t(find_rgns): Use it.\n\t(gather_region_statistics, print_region_statistics): New static\n\tfunctions.\n\t* params.def (PARAM_MAX_SCHED_EXTEND_REGIONS_ITERS): New parameter.\n        * doc/invoke.texi (max-sched-extend-regions-iters): Document.\n\nFrom-SVN: r112126", "tree": {"sha": "52813b34ea032f6411ae66f7939f478c4711344c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52813b34ea032f6411ae66f7939f478c4711344c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d08eefb9d2cb72e7168d3b790111d6c07ce87a8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d08eefb9d2cb72e7168d3b790111d6c07ce87a8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d08eefb9d2cb72e7168d3b790111d6c07ce87a8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d08eefb9d2cb72e7168d3b790111d6c07ce87a8a/comments", "author": null, "committer": null, "parents": [{"sha": "ddbd543924d5b71c2b9d6553daff6c6f029a19c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddbd543924d5b71c2b9d6553daff6c6f029a19c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddbd543924d5b71c2b9d6553daff6c6f029a19c0"}], "stats": {"total": 379, "additions": 377, "deletions": 2}, "files": [{"sha": "0b105a722b77d6b71f82b9eb068327ccb81b9efe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d08eefb9d2cb72e7168d3b790111d6c07ce87a8a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d08eefb9d2cb72e7168d3b790111d6c07ce87a8a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d08eefb9d2cb72e7168d3b790111d6c07ce87a8a", "patch": "@@ -1,3 +1,12 @@\n+2006-03-16  Maxim Kuvyrkov <mkuvyrkov@ispras.ru>\n+\n+\t* sched-rgn.c (extend_rgns): New static function.\n+\t(find_rgns): Use it.\n+\t(gather_region_statistics, print_region_statistics): New static\n+\tfunctions.\n+\t* params.def (PARAM_MAX_SCHED_EXTEND_REGIONS_ITERS): New parameter.\n+        * doc/invoke.texi (max-sched-extend-regions-iters): Document.\n+\n 2006-03-16  Maxim Kuvyrkov <mkuvyrkov@ispras.ru>\n             Andrey Belevantsev <abel@ispras.ru>\n "}, {"sha": "64df67239af10c7c23a7122d9c39d2625c68630d", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d08eefb9d2cb72e7168d3b790111d6c07ce87a8a/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d08eefb9d2cb72e7168d3b790111d6c07ce87a8a/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d08eefb9d2cb72e7168d3b790111d6c07ce87a8a", "patch": "@@ -6177,6 +6177,12 @@ interblock scheduling.  The default value is 100.\n The minimum probability (in percents) of reaching a source block\n for interblock speculative scheduling.  The default value is 40.\n \n+@item max-sched-extend-regions-iters\n+The maximum number of iterations through CFG to extend regions.\n+0 - disable region extension,\n+N - do at most N iterations.\n+The default value is 2.\n+\n @item max-last-value-rtl\n \n The maximum size measured as number of RTLs that can be recorded in an expression"}, {"sha": "e34a50319c58bde58d850011b3879fa6b8d1e688", "filename": "gcc/params.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d08eefb9d2cb72e7168d3b790111d6c07ce87a8a/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d08eefb9d2cb72e7168d3b790111d6c07ce87a8a/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=d08eefb9d2cb72e7168d3b790111d6c07ce87a8a", "patch": "@@ -499,6 +499,11 @@ DEFPARAM(PARAM_MIN_SPEC_PROB,\n          \"The minimum probability of reaching a source block for interblock speculative scheduling\",\n          40, 0, 0)\n \n+DEFPARAM(PARAM_MAX_SCHED_EXTEND_REGIONS_ITERS,\n+         \"max-sched-extend-regions-iters\",\n+         \"The maximum number of iterations through CFG to extend regions\",\n+         2, 0, 0)\n+\n DEFPARAM(PARAM_MAX_LAST_VALUE_RTL,\n \t \"max-last-value-rtl\",\n \t \"The maximum number of RTL nodes that can be recorded as combiner's last value\","}, {"sha": "0ee5be81d39009e39267e43176ac8d502415670f", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 357, "deletions": 2, "changes": 359, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d08eefb9d2cb72e7168d3b790111d6c07ce87a8a/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d08eefb9d2cb72e7168d3b790111d6c07ce87a8a/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=d08eefb9d2cb72e7168d3b790111d6c07ce87a8a", "patch": "@@ -131,6 +131,7 @@ static int min_spec_prob;\n void debug_regions (void);\n static void find_single_block_region (void);\n static void find_rgns (void);\n+static void extend_rgns (int *, int *, sbitmap, int *);\n static bool too_large (int, int *, int *);\n \n extern void debug_live (int, int);\n@@ -648,7 +649,13 @@ find_rgns (void)\n      blocks.  */\n   if (!unreachable)\n     {\n-      int *queue;\n+      int *queue, *degree1 = NULL;\n+      /* We use EXTENDED_RGN_HEADER as an addition to HEADER and put\n+\t there basic blocks, which are forced to be region heads.\n+\t This is done to try to assemble few smaller regions \n+\t from a too_large region.  */\n+      sbitmap extended_rgn_header = NULL;\n+      bool extend_regions_p;\n \n       if (no_loops)\n \tSET_BIT (header, 0);\n@@ -657,6 +664,14 @@ find_rgns (void)\n \t block of each region.  */\n \n       queue = XNEWVEC (int, n_basic_blocks);\n+      \n+      extend_regions_p = PARAM_VALUE (PARAM_MAX_SCHED_EXTEND_REGIONS_ITERS) > 0;\n+      if (extend_regions_p)\n+        {\n+          degree1 = xmalloc (last_basic_block * sizeof (int));\n+          extended_rgn_header = sbitmap_alloc (last_basic_block);\n+          sbitmap_zero (extended_rgn_header);\n+\t}\n \n       /* Find blocks which are inner loop headers.  We still have non-reducible\n \t loops to consider at this point.  */\n@@ -704,6 +719,12 @@ find_rgns (void)\n \t      too_large_failure = 0;\n \t      loop_head = max_hdr[bb->index];\n \n+              if (extend_regions_p)\n+                /* We save degree in case when we meet a too_large region \n+\t\t   and cancel it.  We need a correct degree later when \n+                   calling extend_rgns.  */\n+                memcpy (degree1, degree, last_basic_block * sizeof (int));\n+\t      \n \t      /* Decrease degree of all I's successors for topological\n \t\t ordering.  */\n \t      FOR_EACH_EDGE (e, ei, bb->succs)\n@@ -862,9 +883,34 @@ find_rgns (void)\n \t\t    }\n \t\t  ++nr_regions;\n \t\t}\n+              else if (extend_regions_p)\n+                {\n+                  /* Restore DEGREE.  */\n+                  int *t = degree;\n+\n+                  degree = degree1;\n+                  degree1 = t;\n+                  \n+                  /* And force successors of BB to be region heads.\n+\t\t     This may provide several smaller regions instead\n+\t\t     of one too_large region.  */\n+                  FOR_EACH_EDGE (e, ei, bb->succs)\n+                    if (e->dest != EXIT_BLOCK_PTR)\n+                      SET_BIT (extended_rgn_header, e->dest->index);\n+                }\n \t    }\n \t}\n       free (queue);\n+\n+      if (extend_regions_p)\n+        {\n+          free (degree1);\n+          \n+          sbitmap_a_or_b (header, header, extended_rgn_header);\n+          sbitmap_free (extended_rgn_header);\n+ \n+          extend_rgns (degree, &idx, header, max_hdr);\n+        }\n     }\n \n   /* Any block that did not end up in a region is placed into a region\n@@ -880,14 +926,323 @@ find_rgns (void)\n       }\n \n   free (max_hdr);\n-  free (dfs_nr);\n+  free (degree);\n   free (stack);\n   sbitmap_free (header);\n   sbitmap_free (inner);\n   sbitmap_free (in_queue);\n   sbitmap_free (in_stack);\n }\n \n+static int gather_region_statistics (int **);\n+static void print_region_statistics (int *, int, int *, int);\n+\n+/* Calculate the histogram that shows the number of regions having the \n+   given number of basic blocks, and store it in the RSP array.  Return \n+   the size of this array.  */\n+static int\n+gather_region_statistics (int **rsp)\n+{\n+  int i, *a = 0, a_sz = 0;\n+\n+  /* a[i] is the number of regions that have (i + 1) basic blocks.  */\n+  for (i = 0; i < nr_regions; i++)\n+    {\n+      int nr_blocks = RGN_NR_BLOCKS (i);\n+\n+      gcc_assert (nr_blocks >= 1);\n+\n+      if (nr_blocks > a_sz)\n+\t{\t \n+\t  a = xrealloc (a, nr_blocks * sizeof (*a));\n+\t  do\n+\t    a[a_sz++] = 0;\n+\t  while (a_sz != nr_blocks);\n+\t}\n+\n+      a[nr_blocks - 1]++;\n+    }\n+\n+  *rsp = a;\n+  return a_sz;\n+}\n+\n+/* Print regions statistics.  S1 and S2 denote the data before and after \n+   calling extend_rgns, respectively.  */\n+static void\n+print_region_statistics (int *s1, int s1_sz, int *s2, int s2_sz)\n+{\n+  int i;\n+  \n+  /* We iterate until s2_sz because extend_rgns does not decrease \n+     the maximal region size.  */\n+  for (i = 1; i < s2_sz; i++)\n+    {\n+      int n1, n2;\n+\n+      n2 = s2[i];\n+\n+      if (n2 == 0)\n+\tcontinue;\n+\n+      if (i >= s1_sz)\n+\tn1 = 0;\n+      else\n+\tn1 = s1[i];\n+\n+      fprintf (sched_dump, \";; Region extension statistics: size %d: \" \\\n+\t       \"was %d + %d more\\n\", i + 1, n1, n2 - n1);\n+    }\n+}\n+\n+/* Extend regions.\n+   DEGREE - Array of incoming edge count, considering only\n+   the edges, that don't have their sources in formed regions yet.\n+   IDXP - pointer to the next available index in rgn_bb_table.\n+   HEADER - set of all region heads.\n+   LOOP_HDR - mapping from block to the containing loop\n+   (two blocks can reside within one region if they have\n+   the same loop header).  */\n+static void\n+extend_rgns (int *degree, int *idxp, sbitmap header, int *loop_hdr)\n+{\n+  int *order, i, rescan = 0, idx = *idxp, iter = 0, max_iter, *max_hdr;\n+  int nblocks = n_basic_blocks - NUM_FIXED_BLOCKS;\n+\n+  max_iter = PARAM_VALUE (PARAM_MAX_SCHED_EXTEND_REGIONS_ITERS);\n+\n+  max_hdr = xmalloc (last_basic_block * sizeof (*max_hdr));\n+\n+  order = xmalloc (last_basic_block * sizeof (*order));\n+  post_order_compute (order, false);\n+\n+  for (i = nblocks - 1; i >= 0; i--)\n+    {\n+      int bbn = order[i];\n+      if (degree[bbn] >= 0)\n+\t{\n+\t  max_hdr[bbn] = bbn;\n+\t  rescan = 1;\n+\t}\n+      else\n+        /* This block already was processed in find_rgns.  */\n+        max_hdr[bbn] = -1;\n+    }\n+  \n+  /* The idea is to topologically walk through CFG in top-down order.\n+     During the traversal, if all the predecessors of a node are\n+     marked to be in the same region (they all have the same max_hdr),\n+     then current node is also marked to be a part of that region. \n+     Otherwise the node starts its own region.\n+     CFG should be traversed until no further changes are made.  On each \n+     iteration the set of the region heads is extended (the set of those \n+     blocks that have max_hdr[bbi] == bbi).  This set is upper bounded by the \n+     set of all basic blocks, thus the algorithm is guaranteed to terminate.  */\n+\n+  while (rescan && iter < max_iter)\n+    {\n+      rescan = 0;\n+      \n+      for (i = nblocks - 1; i >= 0; i--)\n+\t{\n+\t  edge e;\n+\t  edge_iterator ei;\n+\t  int bbn = order[i];\n+\t\n+\t  if (max_hdr[bbn] != -1 && !TEST_BIT (header, bbn))\n+\t    {\n+\t      int hdr = -1;\n+\n+\t      FOR_EACH_EDGE (e, ei, BASIC_BLOCK (bbn)->preds)\n+\t\t{\n+\t\t  int predn = e->src->index;\n+\n+\t\t  if (predn != ENTRY_BLOCK\n+\t\t      /* If pred wasn't processed in find_rgns.  */\n+\t\t      && max_hdr[predn] != -1\n+\t\t      /* And pred and bb reside in the same loop.\n+\t\t\t (Or out of any loop).  */\n+\t\t      && loop_hdr[bbn] == loop_hdr[predn])\n+\t\t    {\n+\t\t      if (hdr == -1)\n+\t\t\t/* Then bb extends the containing region of pred.  */\n+\t\t\thdr = max_hdr[predn];\n+\t\t      else if (hdr != max_hdr[predn])\n+\t\t\t/* Too bad, there are at least two predecessors\n+\t\t\t   that reside in different regions.  Thus, BB should\n+\t\t\t   begin its own region.  */\n+\t\t\t{\n+\t\t\t  hdr = bbn;\n+\t\t\t  break;\n+\t\t\t}\t\t    \n+\t\t    }\n+\t\t  else\n+\t\t    /* BB starts its own region.  */\n+\t\t    {\n+\t\t      hdr = bbn;\n+\t\t      break;\n+\t\t    }\t\t\n+\t\t}\n+\t    \n+\t      if (hdr == bbn)\n+\t\t{\n+\t\t  /* If BB start its own region,\n+\t\t     update set of headers with BB.  */\n+\t\t  SET_BIT (header, bbn);\n+\t\t  rescan = 1;\n+\t\t}\n+\t      else\n+\t\tgcc_assert (hdr != -1);\t    \n+\n+\t      max_hdr[bbn] = hdr;\n+\t    }\n+\t}\n+\n+      iter++;\n+    }\n+  \n+  /* Statistics were gathered on the SPEC2000 package of tests with\n+     mainline weekly snapshot gcc-4.1-20051015 on ia64.\n+     \n+     Statistics for SPECint:\n+     1 iteration : 1751 cases (38.7%)\n+     2 iterations: 2770 cases (61.3%)\n+     Blocks wrapped in regions by find_rgns without extension: 18295 blocks\n+     Blocks wrapped in regions by 2 iterations in extend_rgns: 23821 blocks\n+     (We don't count single block regions here).\n+     \n+     Statistics for SPECfp:\n+     1 iteration : 621 cases (35.9%)\n+     2 iterations: 1110 cases (64.1%)\n+     Blocks wrapped in regions by find_rgns without extension: 6476 blocks\n+     Blocks wrapped in regions by 2 iterations in extend_rgns: 11155 blocks\n+     (We don't count single block regions here).\n+\n+     By default we do at most 2 iterations.\n+     This can be overriden with max-sched-extend-regions-iters parameter:\n+     0 - disable region extension,\n+     N > 0 - do at most N iterations.  */\n+  \n+  if (sched_verbose && iter != 0)\n+    fprintf (sched_dump, \";; Region extension iterations: %d%s\\n\", iter,\n+\t     rescan ? \"... failed\" : \"\");\n+    \n+  if (!rescan && iter != 0)\n+    {\n+      int *s1 = NULL, s1_sz = 0;\n+\n+      /* Save the old statistics for later printout.  */\n+      if (sched_verbose >= 6)\n+\ts1_sz = gather_region_statistics (&s1);\n+\n+      /* We have succeeded.  Now assemble the regions.  */\n+      for (i = nblocks - 1; i >= 0; i--)\n+\t{\n+\t  int bbn = order[i];\n+\n+\t  if (max_hdr[bbn] == bbn)\n+\t    /* BBN is a region head.  */\n+\t    {\n+\t      edge e;\n+\t      edge_iterator ei;\n+\t      int num_bbs = 0, j, num_insns = 0, large;\n+\t\n+\t      large = too_large (bbn, &num_bbs, &num_insns);\n+\n+\t      degree[bbn] = -1;\n+\t      rgn_bb_table[idx] = bbn;\n+\t      RGN_BLOCKS (nr_regions) = idx++;\n+\t      CONTAINING_RGN (bbn) = nr_regions;\n+\t      BLOCK_TO_BB (bbn) = 0;\n+\n+\t      FOR_EACH_EDGE (e, ei, BASIC_BLOCK (bbn)->succs)\n+\t\tif (e->dest != EXIT_BLOCK_PTR)\n+\t\t  degree[e->dest->index]--;\n+\n+\t      if (!large)\n+\t\t/* Here we check whether the region is too_large.  */\n+\t\tfor (j = i - 1; j >= 0; j--)\n+\t\t  {\n+\t\t    int succn = order[j];\n+\t\t    if (max_hdr[succn] == bbn)\n+\t\t      {\n+\t\t\tif ((large = too_large (succn, &num_bbs, &num_insns)))\n+\t\t\t  break;\n+\t\t      }\n+\t\t  }\n+\n+\t      if (large)\n+\t\t/* If the region is too_large, then wrap every block of\n+\t\t   the region into single block region.\n+\t\t   Here we wrap region head only.  Other blocks are\n+\t\t   processed in the below cycle.  */\n+\t\t{\n+\t\t  RGN_NR_BLOCKS (nr_regions) = 1;\n+\t\t  nr_regions++;\n+\t\t}          \n+\n+\t      num_bbs = 1;\n+\n+\t      for (j = i - 1; j >= 0; j--)\n+\t\t{\n+\t\t  int succn = order[j];\n+\n+\t\t  if (max_hdr[succn] == bbn)\n+\t\t    /* This cycle iterates over all basic blocks, that \n+\t\t       are supposed to be in the region with head BBN,\n+\t\t       and wraps them into that region (or in single\n+\t\t       block region).  */\n+\t\t    {\n+\t\t      gcc_assert (degree[succn] == 0);\n+\n+\t\t      degree[succn] = -1;\n+\t\t      rgn_bb_table[idx] = succn;\t\t \n+\t\t      BLOCK_TO_BB (succn) = large ? 0 : num_bbs++;\n+\t\t      CONTAINING_RGN (succn) = nr_regions;\n+\n+\t\t      if (large)\n+\t\t\t/* Wrap SUCCN into single block region.  */\n+\t\t\t{\n+\t\t\t  RGN_BLOCKS (nr_regions) = idx;\n+\t\t\t  RGN_NR_BLOCKS (nr_regions) = 1;\n+\t\t\t  nr_regions++;\n+\t\t\t}\n+\n+\t\t      idx++;\n+\t\t\t\t\n+\t\t      FOR_EACH_EDGE (e, ei, BASIC_BLOCK (succn)->succs)\n+\t\t\tif (e->dest != EXIT_BLOCK_PTR)\n+\t\t\t  degree[e->dest->index]--;\n+\t\t    }\n+\t\t}\n+\n+\t      if (!large)\n+\t\t{\n+\t\t  RGN_NR_BLOCKS (nr_regions) = num_bbs;\n+\t\t  nr_regions++;\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (sched_verbose >= 6)\n+\t{\n+\t  int *s2, s2_sz;\n+\n+          /* Get the new statistics and print the comparison with the \n+             one before calling this function.  */\n+\t  s2_sz = gather_region_statistics (&s2);\n+\t  print_region_statistics (s1, s1_sz, s2, s2_sz);\n+\t  free (s1);\n+\t  free (s2);\n+\t}\n+    }\n+  \n+  free (order);\n+  free (max_hdr);\n+\n+  *idxp = idx; \n+}\n+\n /* Functions for regions scheduling information.  */\n \n /* Compute dominators, probability, and potential-split-edges of bb."}]}