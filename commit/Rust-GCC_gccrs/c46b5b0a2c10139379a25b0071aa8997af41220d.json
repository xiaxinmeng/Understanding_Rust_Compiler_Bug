{"sha": "c46b5b0a2c10139379a25b0071aa8997af41220d", "node_id": "C_kwDOANBUbNoAKGM0NmI1YjBhMmMxMDEzOTM3OWEyNWIwMDcxYWE4OTk3YWY0MTIyMGQ", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-03-23T14:25:50Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-03-23T14:25:50Z"}, "message": "ranger: Ranger meets aspell\n\nI've noticed a comment typo in tree-vrp.cc and decided to quickly\nskim aspell -c on the ranger sources (with quick I on everything that\nlooked ok or roughly ok).\nBut not being a native English speaker, I could get stuff wrong.\n\n2023-03-23  Jakub Jelinek  <jakub@redhat.com>\n\n\t* value-range.cc (irange::irange_union, irange::intersect): Fix\n\tcomment spelling bugs.\n\t* gimple-range-trace.cc (range_tracer::do_header): Likewise.\n\t* gimple-range-trace.h: Likewise.\n\t* gimple-range-edge.cc: Likewise.\n\t(gimple_outgoing_range_stmt_p,\n\tgimple_outgoing_range::switch_edge_range,\n\tgimple_outgoing_range::edge_range_p): Likewise.\n\t* gimple-range.cc (gimple_ranger::prefill_stmt_dependencies,\n\tgimple_ranger::fold_stmt, gimple_ranger::register_transitive_infer,\n\tassume_query::assume_query, assume_query::calculate_phi): Likewise.\n\t* gimple-range-edge.h: Likewise.\n\t* value-range.h (Value_Range::set, Value_Range::lower_bound,\n\tValue_Range::upper_bound, frange::set_undefined): Likewise.\n\t* gimple-range-gori.h (range_def_chain::depend, gori_map::m_outgoing,\n\tgori_compute): Likewise.\n\t* gimple-range-fold.h (fold_using_range): Likewise.\n\t* gimple-range-path.cc (path_range_query::compute_ranges_in_phis):\n\tLikewise.\n\t* gimple-range-gori.cc (range_def_chain::in_chain_p,\n\trange_def_chain::dump, gori_map::calculate_gori,\n\tgori_compute::compute_operand_range_switch,\n\tgori_compute::logical_combine, gori_compute::refine_using_relation,\n\tgori_compute::compute_operand1_range, gori_compute::may_recompute_p):\n\tLikewise.\n\t* gimple-range.h: Likewise.\n\t(enable_ranger): Likewise.\n\t* range-op.h (empty_range_varying): Likewise.\n\t* value-query.h (value_query): Likewise.\n\t* gimple-range-cache.cc (block_range_cache::set_bb_range,\n\tblock_range_cache::dump, ssa_global_cache::clear_global_range,\n\ttemporal_cache::temporal_value, temporal_cache::current_p,\n\tranger_cache::range_of_def, ranger_cache::propagate_updated_value,\n\tranger_cache::range_from_dom, ranger_cache::register_inferred_value):\n\tLikewise.\n\t* gimple-range-fold.cc (fur_edge::get_phi_operand,\n\tfur_stmt::get_operand, gimple_range_adjustment,\n\tfold_using_range::range_of_phi,\n\tfold_using_range::relation_fold_and_or): Likewise.\n\t* value-range-storage.h (irange_storage_slot::MAX_INTS): Likewise.\n\t* value-query.cc (range_query::value_of_expr,\n\trange_query::value_on_edge, range_query::query_relation): Likewise.\n\t* tree-vrp.cc (remove_unreachable::remove_and_update_globals,\n\tintersect_range_with_nonzero_bits): Likewise.\n\t* gimple-range-infer.cc (gimple_infer_range::check_assume_func,\n\texit_range): Likewise.\n\t* value-relation.h: Likewise.\n\t(equiv_oracle, relation_trio::relation_trio, value_relation,\n\tvalue_relation::value_relation, pe_min): Likewise.\n\t* range-op-float.cc (range_operator_float::rv_fold,\n\tfrange_arithmetic, foperator_unordered_equal::op1_range,\n\tfoperator_div::rv_fold): Likewise.\n\t* gimple-range-op.cc (cfn_clz::fold_range): Likewise.\n\t* value-relation.cc (equiv_oracle::query_relation,\n\tequiv_oracle::register_equiv, equiv_oracle::add_equiv_to_block,\n\tvalue_relation::apply_transitive, relation_chain_head::find_relation,\n\tdom_oracle::query_relation, dom_oracle::find_relation_block,\n\tdom_oracle::find_relation_dom, path_oracle::register_equiv): Likewise.\n\t* range-op.cc (range_operator::wi_fold_in_parts_equiv,\n\tcreate_possibly_reversed_range, adjust_op1_for_overflow,\n\toperator_mult::wi_fold, operator_exact_divide::op1_range,\n\toperator_cast::lhs_op1_relation, operator_cast::fold_pair,\n\toperator_cast::fold_range, operator_abs::wi_fold, range_op_cast_tests,\n\trange_op_lshift_tests): Likewise.", "tree": {"sha": "1f5bb7b6d823d1517c258b3e217efba6779d32fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f5bb7b6d823d1517c258b3e217efba6779d32fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c46b5b0a2c10139379a25b0071aa8997af41220d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c46b5b0a2c10139379a25b0071aa8997af41220d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c46b5b0a2c10139379a25b0071aa8997af41220d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c46b5b0a2c10139379a25b0071aa8997af41220d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "097e2afdde06eff42d158ace7165b4cb4dfab07c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/097e2afdde06eff42d158ace7165b4cb4dfab07c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/097e2afdde06eff42d158ace7165b4cb4dfab07c"}], "stats": {"total": 212, "additions": 106, "deletions": 106}, "files": [{"sha": "cc56fd4dcb0fb166cdd548028c6eadd56ea06dd8", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=c46b5b0a2c10139379a25b0071aa8997af41220d", "patch": "@@ -357,7 +357,7 @@ block_range_cache::set_bb_range (tree name, const_basic_block bb,\n \t}\n       else\n \t{\n-\t  // Otherwise use the default vector implemntation.\n+\t  // Otherwise use the default vector implementation.\n \t  void *r = m_range_allocator->alloc (sizeof (sbr_vector));\n \t  m_ssa_ranges[v] = new (r) sbr_vector (TREE_TYPE (name),\n \t\t\t\t\t\tm_range_allocator);\n@@ -423,7 +423,7 @@ block_range_cache::dump (FILE *f)\n     }\n }\n \n-// Print all known ranges on entry to blobk BB to file F.\n+// Print all known ranges on entry to block BB to file F.\n \n void\n block_range_cache::dump (FILE *f, basic_block bb, bool print_varying)\n@@ -525,7 +525,7 @@ ssa_global_cache::set_global_range (tree name, const vrange &r)\n   return m != NULL;\n }\n \n-// Set the range for NAME to R in the glonbal cache.\n+// Set the range for NAME to R in the global cache.\n \n void\n ssa_global_cache::clear_global_range (tree name)\n@@ -618,7 +618,7 @@ temporal_cache::~temporal_cache ()\n   m_timestamp.release ();\n }\n \n-// Return the timestamp value for SSA, or 0 if there isnt one.\n+// Return the timestamp value for SSA, or 0 if there isn't one.\n \n inline unsigned\n temporal_cache::temporal_value (unsigned ssa) const\n@@ -628,7 +628,7 @@ temporal_cache::temporal_value (unsigned ssa) const\n   return m_timestamp[ssa];\n }\n \n-// Return TRUE if the timestampe for NAME is newer than any of its dependents.\n+// Return TRUE if the timestamp for NAME is newer than any of its dependents.\n // Up to 2 dependencies can be checked.\n \n bool\n@@ -885,7 +885,7 @@ ranger_cache::set_global_range (tree name, const vrange &r)\n }\n \n //  Provide lookup for the gori-computes class to access the best known range\n-//  of an ssa_name in any given basic block.  Note, this does no additonal\n+//  of an ssa_name in any given basic block.  Note, this does no additional\n //  lookups, just accesses the data that is already known.\n \n // Get the range of NAME when the def occurs in block BB.  If BB is NULL\n@@ -1138,7 +1138,7 @@ ranger_cache::propagate_cache (tree name)\n \n // Check to see if an update to the value for NAME in BB has any effect\n // on values already in the on-entry cache for successor blocks.\n-// If it does, update them.  Don't visit any blocks which dont have a cache\n+// If it does, update them.  Don't visit any blocks which don't have a cache\n // entry.\n \n void\n@@ -1462,9 +1462,9 @@ ranger_cache::range_from_dom (vrange &r, tree name, basic_block start_bb,\n \t  // incoming edges.  If the first incoming edge to this block does\n \t  // generate a range, calculate the ranges if all incoming edges\n \t  // are also dominated by the dominator.  (Avoids backedges which\n-\t  // will break the rule of moving only upward in the domniator tree).\n+\t  // will break the rule of moving only upward in the dominator tree).\n \t  // If the first pred does not generate a range, then we will be\n-\t  // using the dominator range anyway, so thats all the check needed.\n+\t  // using the dominator range anyway, so that's all the check needed.\n \t  if (EDGE_COUNT (prev_bb->preds) > 1\n \t      && m_gori.has_edge_range_p (name, EDGE_PRED (prev_bb, 0)->src))\n \t    {\n@@ -1502,14 +1502,14 @@ ranger_cache::range_from_dom (vrange &r, tree name, basic_block start_bb,\n \tfprintf (dump_file, \" at function top\\n\");\n     }\n \n-  // Now process any blocks wit incoming edges that nay have adjustemnts.\n+  // Now process any blocks wit incoming edges that nay have adjustments.\n   while (m_workback.length () > start_limit)\n     {\n       Value_Range er (TREE_TYPE (name));\n       prev_bb = m_workback.pop ();\n       if (!single_pred_p (prev_bb))\n \t{\n-\t  // Non single pred means we need to cache a vsalue in the dominator\n+\t  // Non single pred means we need to cache a value in the dominator\n \t  // so we can cheaply calculate incoming edges to this block, and\n \t  // then store the resulting value.  If processing mode is not\n \t  // RFD_FILL, then the cache cant be stored to, so don't try.\n@@ -1564,7 +1564,7 @@ ranger_cache::register_inferred_value (const vrange &ir, tree name,\n   if (r.intersect (ir))\n     {\n       m_on_entry.set_bb_range (name, bb, r);\n-      // If this range was invariant before, remove invariance.\n+      // If this range was invariant before, remove invariant.\n       if (!m_gori.has_edge_range_p (name))\n \tm_gori.set_range_invariant (name, false);\n     }"}, {"sha": "8fedac58fe6bdfc1c0ee8d1ee5ce002d36052c60", "filename": "gcc/gimple-range-edge.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fgimple-range-edge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fgimple-range-edge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-edge.cc?ref=c46b5b0a2c10139379a25b0071aa8997af41220d", "patch": "@@ -1,4 +1,4 @@\n-/* Gimple range edge functionaluity.\n+/* Gimple range edge functionality.\n    Copyright (C) 2020-2023 Free Software Foundation, Inc.\n    Contributed by Andrew MacLeod <amacleod@redhat.com>\n    and Aldy Hernandez <aldyh@redhat.com>.\n@@ -33,7 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-range.h\"\n #include \"value-range-storage.h\"\n \n-// If there is a range control statment at the end of block BB, return it.\n+// If there is a range control statement at the end of block BB, return it.\n // Otherwise return NULL.\n \n gimple *\n@@ -90,7 +90,7 @@ gimple_outgoing_range::switch_edge_range (irange &r, gswitch *sw, edge e)\n   // ADA currently has cases where the index is 64 bits and the case\n   // arguments are 32 bit, causing a trap when we create a case_range.\n   // Until this is resolved (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=87798)\n-  // punt on switches where the labels dont match the argument.\n+  // punt on switches where the labels don't match the argument.\n   if (gimple_switch_num_labels (sw) > 1 && \n       TYPE_PRECISION (TREE_TYPE (CASE_LOW (gimple_switch_label (sw, 1)))) !=\n       TYPE_PRECISION (TREE_TYPE (gimple_switch_index (sw))))\n@@ -177,7 +177,7 @@ gimple_outgoing_range::calc_switch_ranges (gswitch *sw)\n \n \n // Calculate the range forced on on edge E by control flow, return it\n-// in R.  Return the statment which defines the range, otherwise\n+// in R.  Return the statement which defines the range, otherwise\n // return NULL\n \n gimple *"}, {"sha": "bb0de1b1d3ea9df70f276573a0c45c672d13cb0d", "filename": "gcc/gimple-range-edge.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fgimple-range-edge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fgimple-range-edge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-edge.h?ref=c46b5b0a2c10139379a25b0071aa8997af41220d", "patch": "@@ -27,7 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n // For a COND_EXPR, the TRUE edge will return [1,1] and the false edge a [0,0].\n //\n // For SWITCH_EXPR, it is awkward to calculate ranges.  When a request\n-// is made, the entire switch is evalauted and the results cached. \n+// is made, the entire switch is evaluated and the results cached. \n // Any future requests to that switch will use the cached value, providing\n // dramatic decrease in computation time.\n //"}, {"sha": "e81f6b3699e85f3185c2f66a435c88f9a9a120b9", "filename": "gcc/gimple-range-fold.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fgimple-range-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fgimple-range-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.cc?ref=c46b5b0a2c10139379a25b0071aa8997af41220d", "patch": "@@ -137,7 +137,7 @@ fur_edge::get_operand (vrange &r, tree expr)\n bool\n fur_edge::get_phi_operand (vrange &r, tree expr, edge e)\n {\n-  // Edge to edge recalculations not supoprted yet, until we sort it out.\n+  // Edge to edge recalculations not supported yet, until we sort it out.\n   gcc_checking_assert (e == m_edge);\n   return m_query->range_on_edge (r, e, expr);\n }\n@@ -149,7 +149,7 @@ fur_stmt::fur_stmt (gimple *s, range_query *q) : fur_source (q)\n   m_stmt = s;\n }\n \n-// Retreive range of EXPR as it occurs as a use on stmt M_STMT.\n+// Retrieve range of EXPR as it occurs as a use on stmt M_STMT.\n \n bool\n fur_stmt::get_operand (vrange &r, tree expr)\n@@ -438,7 +438,7 @@ adjust_realpart_expr (vrange &res, const gimple *stmt)\n }\n \n // This function looks for situations when walking the use/def chains\n-// may provide additonal contextual range information not exposed on\n+// may provide additional contextual range information not exposed on\n // this statement.\n \n static void\n@@ -809,7 +809,7 @@ fold_using_range::range_of_phi (vrange &r, gphi *phi, fur_source &src)\n \t  }\n       }\n \n-  // If SCEV is available, query if this PHI has any knonwn values.\n+  // If SCEV is available, query if this PHI has any known values.\n   if (scev_initialized_p ()\n       && !POINTER_TYPE_P (TREE_TYPE (phi_def)))\n     {\n@@ -1064,7 +1064,7 @@ fold_using_range::relation_fold_and_or (irange& lhs_range, gimple *s,\n   if (is_and && relation_intersect (relation1, relation2) == VREL_UNDEFINED)\n     lhs_range = int_range<2> (boolean_false_node, boolean_false_node);\n   // x || y is true if the union of the true cases is NO-RELATION..\n-  // ie, one or the other being true covers the full range of possibilties.\n+  // ie, one or the other being true covers the full range of possibilities.\n   else if (!is_and && relation_union (relation1, relation2) == VREL_VARYING)\n     lhs_range = bool_one;\n   else"}, {"sha": "68c6d7743e97b6114ff724b36e73da315f3fb78b", "filename": "gcc/gimple-range-fold.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fgimple-range-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fgimple-range-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.h?ref=c46b5b0a2c10139379a25b0071aa8997af41220d", "patch": "@@ -149,7 +149,7 @@ class fur_depend : public fur_stmt\n   relation_oracle *m_oracle;\n };\n \n-// This class uses ranges to fold a gimple statement producinf a range for\n+// This class uses ranges to fold a gimple statement producing a range for\n // the LHS.  The source of all operands is supplied via the fur_source class\n // which provides a range_query as well as a source location and any other\n // required information."}, {"sha": "3c0044881fb1d0dd765de7d6930676d7f90813d9", "filename": "gcc/gimple-range-gori.cc", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fgimple-range-gori.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fgimple-range-gori.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.cc?ref=c46b5b0a2c10139379a25b0071aa8997af41220d", "patch": "@@ -118,7 +118,7 @@ range_def_chain::in_chain_p (tree name, tree def)\n   gcc_checking_assert (gimple_range_ssa_p (def));\n   gcc_checking_assert (gimple_range_ssa_p (name));\n \n-  // Get the defintion chain for DEF.\n+  // Get the definition chain for DEF.\n   bitmap chain = get_def_chain (def);\n \n   if (chain == NULL)\n@@ -341,7 +341,7 @@ range_def_chain::dump (FILE *f, basic_block bb, const char *prefix)\n \n    GORI stands for \"Generates Outgoing Range Information.\"\n \n-   It utilizes the range_def_chain class to contruct def_chains.\n+   It utilizes the range_def_chain class to construct def_chains.\n    Information for a basic block is calculated once and stored.  It is\n    only calculated the first time a query is made.  If no queries are\n    made, there is little overhead.\n@@ -469,7 +469,7 @@ gori_map::calculate_gori (basic_block bb)\n   if (single_succ_p (bb))\n     return;\n \n-  // If this block's last statement may generate range informaiton, go\n+  // If this block's last statement may generate range information, go\n   // calculate it.\n   gimple *stmt = gimple_outgoing_range_stmt_p (bb);\n   if (!stmt)\n@@ -588,7 +588,7 @@ gori_compute::compute_operand_range_switch (vrange &r, gswitch *s,\n       return true;\n     }\n \n-  // If op1 is in the defintion chain, pass lhs back.\n+  // If op1 is in the definition chain, pass lhs back.\n   if (gimple_range_ssa_p (op1) && in_chain_p (name, op1))\n     return compute_operand_range (r, SSA_NAME_DEF_STMT (op1), lhs, name, src);\n \n@@ -878,14 +878,14 @@ gori_compute::logical_combine (vrange &r, enum tree_code code,\n \t    r.union_ (ft);\n \t  }\n         break;\n-      //  A logical OR combines ranges from 2 boolean conditons.\n+      //  A logical OR combines ranges from 2 boolean conditions.\n       // \tc_2 = b_1 || b_2\n       case TRUTH_OR_EXPR:\n       case BIT_IOR_EXPR:\n         if (lhs.zero_p ())\n \t  {\n \t    // An OR operation will only take the FALSE path if both\n-\t    // operands are false simlulateously, which means they should\n+\t    // operands are false simultaneously, which means they should\n \t    // be intersected.  !(x || y) == !x && !y\n \t    r = op1_false;\n \t    r.intersect (op2_false);\n@@ -976,7 +976,7 @@ gori_compute::compute_logical_operands (vrange &true_range, vrange &false_range,\n // This routine will try to refine the ranges of OP1 and OP2 given a relation\n // K between them.  In order to perform this refinement, one of the operands\n // must be in the definition chain of the other.  The use is refined using\n-// op1/op2_range on the statement, and the defintion is then recalculated\n+// op1/op2_range on the statement, and the definition is then recalculated\n // using the relation.\n \n bool\n@@ -1109,7 +1109,7 @@ gori_compute::compute_operand1_range (vrange &r,\n   // Fetch the known range for op1 in this block.\n   src.get_operand (op1_range, op1);\n \n-  // Now range-op calcuate and put that result in r.\n+  // Now range-op calculate and put that result in r.\n   if (op2)\n     {\n       src.get_operand (op2_range, op2);\n@@ -1122,7 +1122,7 @@ gori_compute::compute_operand1_range (vrange &r,\n     }\n   else\n     {\n-      // We pass op1_range to the unary operation.  Nomally it's a\n+      // We pass op1_range to the unary operation.  Normally it's a\n       // hidden range_for_type parameter, but sometimes having the\n       // actual range can result in better information.\n       if (!handler.calc_op1 (tmp, lhs, op1_range, trio))\n@@ -1284,15 +1284,15 @@ gori_compute::compute_operand1_and_operand2_range (vrange &r,\n }\n \n // Return TRUE if NAME can be recomputed on any edge exiting BB.  If any\n-// direct dependant is exported, it may also change the computed value of NAME.\n+// direct dependent is exported, it may also change the computed value of NAME.\n \n bool\n gori_compute::may_recompute_p (tree name, basic_block bb)\n {\n   tree dep1 = depend1 (name);\n   tree dep2 = depend2 (name);\n \n-  // If the first dependency is not set, there is no recompuation.\n+  // If the first dependency is not set, there is no recomputation.\n   if (!dep1)\n     return false;\n \n@@ -1309,7 +1309,7 @@ gori_compute::may_recompute_p (tree name, basic_block bb)\n   return (is_export_p (dep1)) || (dep2 && is_export_p (dep2));\n }\n \n-// Return TRUE if NAME can be recomputed on edge E.  If any direct dependant\n+// Return TRUE if NAME can be recomputed on edge E.  If any direct dependent\n // is exported on edge E, it may change the computed value of NAME.\n \n bool"}, {"sha": "0fc90ec8a1873ee6405df88d0234d22168548b5e", "filename": "gcc/gimple-range-gori.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fgimple-range-gori.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fgimple-range-gori.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.h?ref=c46b5b0a2c10139379a25b0071aa8997af41220d", "patch": "@@ -57,7 +57,7 @@ class range_def_chain\n };\n \n // Return the first direct dependency for NAME, if there is one.\n-// Direct dependencies are those which occur on the defintion statement.\n+// Direct dependencies are those which occur on the definition statement.\n // Only the first 2 such names are cached.\n \n inline tree\n@@ -99,7 +99,7 @@ class gori_map : public range_def_chain\n   void dump (FILE *f);\n   void dump (FILE *f, basic_block bb, bool verbose = true);\n private:\n-  vec<bitmap> m_outgoing;\t// BB: Outgoing ranges calculatable on edges\n+  vec<bitmap> m_outgoing;\t// BB: Outgoing ranges calculable on edges\n   vec<bitmap> m_incoming;\t// BB: Incoming ranges which can affect exports.\n   bitmap m_maybe_variant;\t// Names which might have outgoing ranges.\n   void maybe_add_gori (tree name, basic_block bb);\n@@ -139,7 +139,7 @@ class gori_map : public range_def_chain\n // A default value of VARYING provides the raw static info for the edge.\n //\n // If there is any known range for b_4 coming into this block, it can refine\n-// the results.  This allows for cascading results to be propogated.\n+// the results.  This allows for cascading results to be propagated.\n // if b_4 is [100, 200] on entry to the block, feeds into the calculation\n // of a_2 = [92, 192], and finally on the true edge the range would be \n // an empty range [] because it is not possible for the true edge to be taken."}, {"sha": "14ccd7347e669e260960485b6a9204344f169bb0", "filename": "gcc/gimple-range-infer.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fgimple-range-infer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fgimple-range-infer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-infer.cc?ref=c46b5b0a2c10139379a25b0071aa8997af41220d", "patch": "@@ -70,7 +70,7 @@ gimple_infer_range::check_assume_func (gcall *call)\n   struct function *fun = DECL_STRUCT_FUNCTION (assume_id);\n   if (!fun)\n     return;\n-  // Loop over arguments, matching them to the assume paramters.\n+  // Loop over arguments, matching them to the assume parameters.\n   for (arg = DECL_ARGUMENTS (assume_id), i = 1;\n        arg && i < gimple_call_num_args (call);\n        i++, arg = DECL_CHAIN (arg))\n@@ -175,7 +175,7 @@ gimple_infer_range::gimple_infer_range (gimple *s)\n \n // -------------------------------------------------------------------------\n \n-// This class is an element in the list of infered ranges.\n+// This class is an element in the list of inferred ranges.\n \n class exit_range\n {"}, {"sha": "4ca32a7b5d52f8426b09d1446a336650e143b41f", "filename": "gcc/gimple-range-op.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fgimple-range-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fgimple-range-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-op.cc?ref=c46b5b0a2c10139379a25b0071aa8997af41220d", "patch": "@@ -543,7 +543,7 @@ cfn_clz::fold_range (irange &r, tree type, const irange &lh,\n   // argument is 0, but that is undefined behavior.\n   //\n   // For __builtin_c[lt]z* consider argument of 0 always undefined\n-  // behavior, for internal fns depending on C?Z_DEFINED_ALUE_AT_ZERO.\n+  // behavior, for internal fns depending on C?Z_DEFINED_VALUE_AT_ZERO.\n   if (lh.undefined_p ())\n     return false;\n   int prec = TYPE_PRECISION (lh.type ());"}, {"sha": "394d610c1b3372c19a28a06e0c01bde629aa3011", "filename": "gcc/gimple-range-path.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fgimple-range-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fgimple-range-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-path.cc?ref=c46b5b0a2c10139379a25b0071aa8997af41220d", "patch": "@@ -351,7 +351,7 @@ path_range_query::compute_ranges_in_phis (basic_block bb)\n   auto_bitmap phi_set;\n \n   // PHIs must be resolved simultaneously on entry to the block\n-  // because any dependencies must be satistifed with values on entry.\n+  // because any dependencies must be satisfied with values on entry.\n   // Thus, we calculate all PHIs first, and then update the cache at\n   // the end.\n "}, {"sha": "cff54f924996448837107777ae6d842c53da25e6", "filename": "gcc/gimple-range-trace.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fgimple-range-trace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fgimple-range-trace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-trace.cc?ref=c46b5b0a2c10139379a25b0071aa8997af41220d", "patch": "@@ -73,7 +73,7 @@ range_tracer::print_prefix (unsigned idx, bool blanks)\n \n }\n // If dumping, return the next call index and print the prefix for the next\n-// output line.  If not, retrurn 0.\n+// output line.  If not, return 0.\n // Counter is static to monotonically increase across the compilation unit.\n \n unsigned"}, {"sha": "625d0be90c5b5ccd975310cec9756e40f6f72105", "filename": "gcc/gimple-range-trace.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fgimple-range-trace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fgimple-range-trace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-trace.h?ref=c46b5b0a2c10139379a25b0071aa8997af41220d", "patch": "@@ -1,4 +1,4 @@\n-/* Header file for the GIMPLE range tracing/debugging facilties.\n+/* Header file for the GIMPLE range tracing/debugging facilities.\n    Copyright (C) 2021-2023 Free Software Foundation, Inc.\n    Contributed by Andrew MacLeod <amacleod@redhat.com>\n    and Aldy Hernandez <aldyh@redhat.com>."}, {"sha": "b4de8dd4ef90b38468f0a149d0dd635a2537d38b", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=c46b5b0a2c10139379a25b0071aa8997af41220d", "patch": "@@ -349,7 +349,7 @@ gimple_ranger::prefill_name (vrange &r, tree name)\n     m_stmt_list.safe_push (name);\n }\n \n-// This routine will seed the global cache with most of the depnedencies of\n+// This routine will seed the global cache with most of the dependencies of\n // NAME.  This prevents excessive call depth through the normal API.\n \n void\n@@ -448,7 +448,7 @@ gimple_ranger::prefill_stmt_dependencies (tree ssa)\n \n \n // This routine will invoke the gimple fold_stmt routine, providing context to\n-// range_of_expr calls via an private interal API.\n+// range_of_expr calls via an private internal API.\n \n bool\n gimple_ranger::fold_stmt (gimple_stmt_iterator *gsi, tree (*valueize) (tree))\n@@ -505,7 +505,7 @@ gimple_ranger::register_transitive_inferred_ranges (basic_block bb)\n     {\n       gimple *s = gsi_stmt (si);\n       tree lhs = gimple_get_lhs (s);\n-      // If the LHS alreayd has an inferred effect, leave it be.\n+      // If the LHS already has an inferred effect, leave it be.\n       if (!gimple_range_ssa_p (lhs) || infer.has_range_p (lhs, bb))\n \tcontinue;\n       // Pick up global value.\n@@ -756,7 +756,7 @@ assume_query::range_of_expr (vrange &r, tree expr, gimple *stmt)\n }\n \n // If the current function returns an integral value, and has a single return\n-// statement, it will calculate any SSA_NAMES is can determine ranges forr\n+// statement, it will calculate any SSA_NAMES it can determine ranges for\n // assuming the function returns 1.\n \n assume_query::assume_query ()\n@@ -813,7 +813,7 @@ assume_query::calculate_op (tree op, gimple *s, vrange &lhs, fur_source &src)\n \n // Evaluate PHI statement, using the provided LHS range.\n // Check each constant argument predecessor if it can be taken\n-// provide LHS to any symbolic argmeuents, and process their def statements.\n+// provide LHS to any symbolic arguments, and process their def statements.\n \n void\n assume_query::calculate_phi (gphi *phi, vrange &lhs_range, fur_source &src)"}, {"sha": "7ed4d3870b8de22a70ac486e022bf73419b5cac9", "filename": "gcc/gimple-range.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fgimple-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fgimple-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.h?ref=c46b5b0a2c10139379a25b0071aa8997af41220d", "patch": "@@ -35,7 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n //\n // This base class provides all the API entry points, but only provides\n // functionality at the statement level.  Ie, it can calculate ranges on\n-// statements, but does no additonal lookup.\n+// statements, but does no additional lookup.\n //\n // All the range_of_* methods will return a range if the types is\n // supported by the range engine.  It may be the full range for the\n@@ -76,7 +76,7 @@ class gimple_ranger : public range_query\n \n /* Create a new ranger instance and associate it with a function.\n    Each call must be paired with a call to disable_ranger to release\n-   resources.  If USE_IMM_USES is true, pre-calculate sideffects like\n+   resources.  If USE_IMM_USES is true, pre-calculate side effects like\n    non-null uses as required using the immediate use chains.  */\n extern gimple_ranger *enable_ranger (struct function *m,\n \t\t\t\t     bool use_imm_uses = true);"}, {"sha": "9564114462744abbc353f097f3fe52f83c364eaa", "filename": "gcc/range-op-float.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=c46b5b0a2c10139379a25b0071aa8997af41220d", "patch": "@@ -117,7 +117,7 @@ range_operator_float::fold_range (frange &r, tree type,\n \n // For a given operation, fold two sets of ranges into [lb, ub].\n // MAYBE_NAN is set to TRUE if, in addition to any result in LB or\n-// UB, the final range has the possiblity of a NAN.\n+// UB, the final range has the possibility of a NAN.\n void\n range_operator_float::rv_fold (REAL_VALUE_TYPE &lb,\n \t\t\t       REAL_VALUE_TYPE &ub,\n@@ -299,9 +299,9 @@ frange_nextafter (enum machine_mode mode,\n // -fexcess-precision=standard we perform most SF/DFmode arithmetic in\n // XFmode (long_double_type_node), so that case is OK.  But without\n // -mfpmath=sse, all the SF/DFmode computations are in XFmode\n-// precision (64-bit mantissa) and only occassionally rounded to\n+// precision (64-bit mantissa) and only occasionally rounded to\n // SF/DFmode (when storing into memory from the 387 stack).  Maybe\n-// this is ok as well though it is just occassionally more precise. ??\n+// this is ok as well though it is just occasionally more precise. ??\n \n static void\n frange_arithmetic (enum tree_code code, tree type,\n@@ -2036,7 +2036,7 @@ foperator_unordered_equal::op1_range (frange &r, tree type,\n       r = op2;\n       // Add both zeros if there's the possibility of zero equality.\n       frange_add_zeros (r, type);\n-      // Add the posibility of a NAN.\n+      // Add the possibility of a NAN.\n       r.update_nan ();\n       break;\n \n@@ -2047,7 +2047,7 @@ foperator_unordered_equal::op1_range (frange &r, tree type,\n \tr.set_undefined ();\n       else\n \t{\n-\t  // The false side indictates !NAN and not equal.  We can at least\n+\t  // The false side indicates !NAN and not equal.  We can at least\n \t  // represent !NAN.\n \t  r.set_varying (type);\n \t  r.clear_nan ();\n@@ -2674,7 +2674,7 @@ class foperator_div : public foperator_mult_div_base\n     // result +0.0.  So, all we can say for that case is if the\n     // signs of divisor and dividend are always the same we have\n     // [+0.0, +INF], if they are always different we have\n-    // [-INF, -0.0].  If they vary, VARING.\n+    // [-INF, -0.0].  If they vary, VARYING.\n     // If both may be +-INF, divisor could be INF and dividend FLT_MAX,\n     // in which case result is going to INF or vice versa and\n     // result +0.0.  So, all we can say for that case is if the"}, {"sha": "f90e78dcfbc9d9bef0880316b77eb23ec64641bb", "filename": "gcc/range-op.cc", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=c46b5b0a2c10139379a25b0071aa8997af41220d", "patch": "@@ -165,7 +165,7 @@ range_operator::wi_fold (irange &r, tree type,\n // For x + y,  when x == y with a range of [0,4] instead of [0, 8] produce\n // [0,0][2, 2][4,4][6, 6][8, 8]\n // LIMIT is the maximum number of elements in range allowed before we\n-// do not processs them individually.\n+// do not process them individually.\n \n void\n range_operator::wi_fold_in_parts_equiv (irange &r, tree type,\n@@ -226,7 +226,7 @@ range_operator::wi_fold_in_parts (irange &r, tree type,\n       wi_fold_in_parts (tmp, type, lh_lb, lh_ub, rh_ub, rh_ub);\n       r.union_ (tmp);\n     }\n-  // Otherise check for 2, 3, or 4 values in the LH range and split them up.\n+  // Otherwise check for 2, 3, or 4 values in the LH range and split them up.\n   // The RH side has been checked, so no recursion needed.\n   else if (lh_range > 0 && lh_range < 4)\n     {\n@@ -511,7 +511,7 @@ create_possibly_reversed_range (irange &r, tree type,\n \t\t\t\tconst wide_int &new_lb, const wide_int &new_ub)\n {\n   signop s = TYPE_SIGN (type);\n-  // If the bounds are swapped, treat the result as if an overflow occured.\n+  // If the bounds are swapped, treat the result as if an overflow occurred.\n   if (wi::gt_p (new_lb, new_ub, s))\n     value_range_from_overflowed_bounds (r, type, new_lb, new_ub);\n   else\n@@ -1492,7 +1492,7 @@ plus_minus_ranges (irange &r_ov, irange &r_normal, const irange &offset,\n // a_2 = b_3 + 1  with a_2 < b_3 can refine the range of b_3 to [INF, INF]\n // and that further refines a_2 to [0, 0].\n // R is the value of op1, OP2 is the offset being added/subtracted, REL is the\n-// relation between LHS relatoin OP1  and ADD_P is true for PLUS, false for\n+// relation between LHS relation OP1  and ADD_P is true for PLUS, false for\n // MINUS.    IF any adjustment can be made, R will reflect it.\n \n static void\n@@ -2025,7 +2025,7 @@ operator_mult::wi_fold (irange &r, tree type,\n   // This test requires 2*prec bits if both operands are signed and\n   // 2*prec + 2 bits if either is not.  Therefore, extend the values\n   // using the sign of the result to PREC2.  From here on out,\n-  // everthing is just signed math no matter what the input types\n+  // everything is just signed math no matter what the input types\n   // were.\n \n   signop sign = TYPE_SIGN (type);\n@@ -2288,7 +2288,7 @@ operator_exact_divide::op1_range (irange &r, tree type,\n   // [2, 4] = op1 / [3,3]   since its exact divide, no need to worry about\n   // remainders in the endpoints, so op1 = [2,4] * [3,3] = [6,12].\n   // We wont bother trying to enumerate all the in between stuff :-P\n-  // TRUE accuraacy is [6,6][9,9][12,12].  This is unlikely to matter most of\n+  // TRUE accuracy is [6,6][9,9][12,12].  This is unlikely to matter most of\n   // the time however.\n   // If op2 is a multiple of 2, we would be able to set some non-zero bits.\n   if (op2.singleton_p (&offset)\n@@ -2709,7 +2709,7 @@ operator_cast::lhs_op1_relation (const irange &lhs,\n   if (TYPE_SIGN (op1.type ()) == SIGNED && lhs_prec > op1_prec)\n     {\n       // If the result is sign extended, and the LHS is larger than op1,\n-      // check if op1's range can be negative as the sign extention will\n+      // check if op1's range can be negative as the sign extension will\n       // cause the upper bits to be 1 instead of 0, invalidating the PE.\n       int_range<3> negs = range_negatives (op1.type ());\n       negs.intersect (op1);\n@@ -2765,7 +2765,7 @@ operator_cast::fold_pair (irange &r, unsigned index,\n   wide_int inner_ub = inner.upper_bound (index);\n   if (truncating_cast_p (inner, outer))\n     {\n-      // We may be able to accomodate a truncating cast if the\n+      // We may be able to accommodate a truncating cast if the\n       // resulting range can be represented in the target type...\n       if (wi::rshift (wi::sub (inner_ub, inner_lb),\n \t\t      wi::uhwi (outer_prec, TYPE_PRECISION (inner.type ())),\n@@ -2802,7 +2802,7 @@ operator_cast::fold_range (irange &r, tree type ATTRIBUTE_UNUSED,\n   // Avoid a temporary by folding the first pair directly into the result.\n   fold_pair (r, 0, inner, outer);\n \n-  // Then process any additonal pairs by unioning with their results.\n+  // Then process any additional pairs by unioning with their results.\n   for (unsigned x = 1; x < inner.num_pairs (); ++x)\n     {\n       int_range_max tmp;\n@@ -4159,7 +4159,7 @@ operator_abs::wi_fold (irange &r, tree type,\n   if (wi::eq_p (lh_lb, min_value))\n     {\n       // ABS ([-MIN, -MIN]) isn't representable, but we have traditionally\n-      // returned [-MIN,-MIN] so this preserves that behaviour.  PR37078\n+      // returned [-MIN,-MIN] so this preserves that behavior.  PR37078\n       if (wi::eq_p (lh_ub, min_value))\n \t{\n \t  r = int_range<1> (type, min_value, min_value);\n@@ -4978,7 +4978,7 @@ range_op_cast_tests ()\n   range_cast (r0, unsigned_char_type_node);\n   ASSERT_TRUE (r0 == rold);\n \n-  // Test casting a wider signed [-MIN,MAX] to a nar`rower unsigned.\n+  // Test casting a wider signed [-MIN,MAX] to a narrower unsigned.\n   r0 = int_range<1> (TYPE_MIN_VALUE (long_long_integer_type_node),\n \t       TYPE_MAX_VALUE (long_long_integer_type_node));\n   range_cast (r0, short_unsigned_type_node);\n@@ -5061,7 +5061,7 @@ range_op_lshift_tests ()\n   // signed VARYING = op1 << 1 should be VARYING.\n   if (TYPE_PRECISION (integer_type_node) > 31)\n     {\n-      // unsigned VARYING = op1 << 1  hould be VARYING.\n+      // unsigned VARYING = op1 << 1 should be VARYING.\n       int_range<2> lhs (integer_type_node);\n       int_range<2> shift (INT (1), INT (1));\n       int_range_max op1;\n@@ -5075,7 +5075,7 @@ range_op_lshift_tests ()\n       // Remove the [0,0] range.\n       op1.intersect (zero);\n       ASSERT_TRUE (op1.num_pairs () == 1);\n-      //  op1 << 1   shuould be [0x8000,0x8000] << 1,\n+      //  op1 << 1   should be [0x8000,0x8000] << 1,\n       //  which should result in [0,0].\n       int_range_max result;\n       op_lshift.fold_range (result, unsigned_type_node, op1, shift);"}, {"sha": "03ef6b98542c029c09b61b1a333cdb1dcabef8fb", "filename": "gcc/range-op.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Frange-op.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Frange-op.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.h?ref=c46b5b0a2c10139379a25b0071aa8997af41220d", "patch": "@@ -235,7 +235,7 @@ enum bool_range_state { BRS_FALSE, BRS_TRUE, BRS_EMPTY, BRS_FULL };\n bool_range_state get_bool_state (vrange &r, const vrange &lhs, tree val_type);\n \n // If the range of either op1 or op2 is undefined, set the result to\n-// varying and return TRUE.  If the caller truely cares about a result,\n+// varying and return TRUE.  If the caller truly cares about a result,\n // they should pass in a varying if it has an undefined that it wants\n // treated as a varying.\n "}, {"sha": "be7d06f565c5c605350903f0ff35f9473bbee217", "filename": "gcc/tree-vrp.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Ftree-vrp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Ftree-vrp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.cc?ref=c46b5b0a2c10139379a25b0071aa8997af41220d", "patch": "@@ -156,7 +156,7 @@ remove_unreachable::remove_and_update_globals (bool final_p)\n \t  m_ranger.range_on_entry (ex, EXIT_BLOCK_PTR_FOR_FN (cfun), name);\n \t  // If the range produced by this __builtin_unreachacble expression\n \t  // is not fully reflected in the range at exit, then it does not\n-\t  // dominate the exit of the funciton.\n+\t  // dominate the exit of the function.\n \t  if (ex.intersect (r))\n \t    dominate_exit_p = false;\n \t}\n@@ -179,7 +179,7 @@ remove_unreachable::remove_and_update_globals (bool final_p)\n \n   if (bitmap_empty_p (all_exports))\n     return false;\n-  // Invoke DCE on all exported names to elimnate dead feeding defs\n+  // Invoke DCE on all exported names to eliminate dead feeding defs.\n   auto_bitmap dce;\n   bitmap_copy (dce, all_exports);\n   // Don't attempt to DCE parameters.\n@@ -233,7 +233,7 @@ remove_unreachable::remove_and_update_globals (bool final_p)\n   return change;\n }\n \n-/* VR_TYPE describes a range with mininum value *MIN and maximum\n+/* VR_TYPE describes a range with minimum value *MIN and maximum\n    value *MAX.  Restrict the range to the set of values that have\n    no bits set outside NONZERO_BITS.  Update *MIN and *MAX and\n    return the new range type."}, {"sha": "e824d86acabf36688df05d21a8ec544334f8fe8b", "filename": "gcc/value-query.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fvalue-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fvalue-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-query.cc?ref=c46b5b0a2c10139379a25b0071aa8997af41220d", "patch": "@@ -87,7 +87,7 @@ range_query::value_of_expr (tree expr, gimple *stmt)\n \n   if (range_of_expr (r, expr, stmt))\n     {\n-      // A constant used in an unreachable block oftens returns as UNDEFINED.\n+      // A constant used in an unreachable block often returns as UNDEFINED.\n       // If the result is undefined, check the global value for a constant.\n       if (r.undefined_p ())\n \trange_of_expr (r, expr);\n@@ -107,7 +107,7 @@ range_query::value_on_edge (edge e, tree expr)\n   Value_Range r (TREE_TYPE (expr));\n   if (range_on_edge (r, e, expr))\n     {\n-      // A constant used in an unreachable block oftens returns as UNDEFINED.\n+      // A constant used in an unreachable block often returns as UNDEFINED.\n       // If the result is undefined, check the global value for a constant.\n       if (r.undefined_p ())\n \trange_of_expr (r, expr);\n@@ -410,7 +410,7 @@ global_range_query::range_of_expr (vrange &r, tree expr, gimple *stmt)\n \n // Return any known relation between SSA1 and SSA2 before stmt S is executed.\n // If GET_RANGE is true, query the range of both operands first to ensure\n-// the defintions have been processed and any relations have be created.\n+// the definitions have been processed and any relations have be created.\n \n relation_kind\n range_query::query_relation (gimple *s, tree ssa1, tree ssa2, bool get_range)\n@@ -431,7 +431,7 @@ range_query::query_relation (gimple *s, tree ssa1, tree ssa2, bool get_range)\n \n // Return any known relation between SSA1 and SSA2 on edge E.\n // If GET_RANGE is true, query the range of both operands first to ensure\n-// the defintions have been processed and any relations have be created.\n+// the definitions have been processed and any relations have be created.\n \n relation_kind\n range_query::query_relation (edge e, tree ssa1, tree ssa2, bool get_range)"}, {"sha": "20a37118ce202f5c396b29736d378df740139f27", "filename": "gcc/value-query.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fvalue-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fvalue-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-query.h?ref=c46b5b0a2c10139379a25b0071aa8997af41220d", "patch": "@@ -25,7 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"value-relation.h\"\n \n // The value_query class is used by optimization passes that require\n-// valueizing SSA names in terms of a tree value, but have no neeed\n+// valueizing SSA names in terms of a tree value, but have no need\n // for ranges.\n //\n // value_of_expr must be provided.  The default for value_on_edge and"}, {"sha": "6da377ebd2edcf82d76b44874899f0542b9d05d1", "filename": "gcc/value-range-storage.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fvalue-range-storage.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fvalue-range-storage.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range-storage.h?ref=c46b5b0a2c10139379a25b0071aa8997af41220d", "patch": "@@ -83,7 +83,7 @@ class GTY ((variable_size)) irange_storage_slot\n \n   // This is the maximum number of wide_int's allowed in the trailing\n   // ints structure, without going over 16 bytes (128 bits) in the\n-  // control word that preceeds the HOST_WIDE_INTs in\n+  // control word that precedes the HOST_WIDE_INTs in\n   // trailing_wide_ints::m_val[].\n   static const unsigned MAX_INTS = 12;\n "}, {"sha": "ec97e765c467e5e5038202654ce50e23f1ce45c9", "filename": "gcc/value-range.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=c46b5b0a2c10139379a25b0071aa8997af41220d", "patch": "@@ -2441,7 +2441,7 @@ irange::irange_union (const irange &r)\n   // of each range is <= the beginning of the next range.  There may\n   // be overlapping ranges at this point.  I.e. this would be valid\n   // [-20, 10], [-10, 0], [0, 20], [40, 90] as it satisfies this\n-  // contraint : -20 < -10 < 0 < 40.  When the range is rebuilt into r,\n+  // constraint : -20 < -10 < 0 < 40.  When the range is rebuilt into r,\n   // the merge is performed.\n   //\n   // [Xi,Yi]..[Xn,Yn]  U  [Xj,Yj]..[Xm,Ym]   -->  [Xk,Yk]..[Xp,Yp]\n@@ -2710,7 +2710,7 @@ irange::intersect (const wide_int& lb, const wide_int& ub)\n   gcc_checking_assert (TYPE_PRECISION (range_type) == wi::get_precision (lb));\n   gcc_checking_assert (TYPE_PRECISION (range_type) == wi::get_precision (ub));\n \n-  // If this range is fuly contained, then intersection will do nothing.\n+  // If this range is fully contained, then intersection will do nothing.\n   if (wi::ge_p (lower_bound (), lb, sign)\n       && wi::le_p (upper_bound (), ub, sign))\n     return false;"}, {"sha": "2b4f6e91997accac88e63bc4a01b19b09eaea8f5", "filename": "gcc/value-range.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=c46b5b0a2c10139379a25b0071aa8997af41220d", "patch": "@@ -514,7 +514,7 @@ class Value_Range\n   void dump (FILE *) const;\n   static bool supports_type_p (const_tree type);\n \n-  // Convenience methods for vrange compatability.\n+  // Convenience methods for vrange compatibility.\n   void set (tree min, tree max, value_range_kind kind = VR_RANGE)\n     { return m_vrange->set (min, max, kind); }\n   tree type () { return m_vrange->type (); }\n@@ -528,8 +528,8 @@ class Value_Range\n   bool singleton_p (tree *result = NULL) const\n     { return m_vrange->singleton_p (result); }\n   bool zero_p () const { return m_vrange->zero_p (); }\n-  wide_int lower_bound () const; // For irange/prange compatability.\n-  wide_int upper_bound () const; // For irange/prange compatability.\n+  wide_int lower_bound () const; // For irange/prange comparability.\n+  wide_int upper_bound () const; // For irange/prange comparability.\n   void accept (const vrange_visitor &v) const { m_vrange->accept (v); }\n private:\n   void init (tree type);\n@@ -1184,7 +1184,7 @@ frange::set_undefined ()\n   m_type = NULL;\n   m_pos_nan = false;\n   m_neg_nan = false;\n-  // m_min and m_min are unitialized as they are REAL_VALUE_TYPE ??.\n+  // m_min and m_min are uninitialized as they are REAL_VALUE_TYPE ??.\n   if (flag_checking)\n     verify_range ();\n }"}, {"sha": "30a02d3c9d36c84e1010682dc7b550aa5123dd6c", "filename": "gcc/value-relation.cc", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fvalue-relation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fvalue-relation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-relation.cc?ref=c46b5b0a2c10139379a25b0071aa8997af41220d", "patch": "@@ -484,7 +484,7 @@ equiv_oracle::query_relation (basic_block bb, tree ssa1, tree ssa2)\n   return partial_equiv (ssa1, ssa2);\n }\n \n-// Query if thre is a relation (equivalence) between 2 SSA_NAMEs.\n+// Query if there is a relation (equivalence) between 2 SSA_NAMEs.\n \n relation_kind\n equiv_oracle::query_relation (basic_block bb ATTRIBUTE_UNUSED, const_bitmap e1,\n@@ -531,7 +531,7 @@ equiv_oracle::find_equiv_dom (tree name, basic_block bb) const\n   return NULL;\n }\n \n-// Register equivalance between ssa_name V and set EQUIV in block BB,\n+// Register equivalence between ssa_name V and set EQUIV in block BB,\n \n bitmap\n equiv_oracle::register_equiv (basic_block bb, unsigned v, equiv_chain *equiv)\n@@ -614,7 +614,7 @@ equiv_oracle::register_initial_def (tree ssa)\n \n // Register an equivalence between SSA1 and SSA2 in block BB.\n // The equivalence oracle maintains a vector of equivalencies indexed by basic\n-// block. When an equivalence bteween SSA1 and SSA2 is registered in block BB,\n+// block. When an equivalence between SSA1 and SSA2 is registered in block BB,\n // a query is made as to what equivalences both names have already, and\n // any preexisting equivalences are merged to create a single equivalence\n // containing all the ssa_names in this basic block.\n@@ -678,7 +678,7 @@ equiv_oracle::register_relation (basic_block bb, relation_kind k, tree ssa1,\n }\n \n // Add an equivalency record in block BB containing bitmap EQUIV_SET.\n-// Note the internal caller is responible for allocating EQUIV_SET properly.\n+// Note the internal caller is responsible for allocating EQUIV_SET properly.\n \n void\n equiv_oracle::add_equiv_to_block (basic_block bb, bitmap equiv_set)\n@@ -823,7 +823,7 @@ value_relation::apply_transitive (const value_relation &rel)\n {\n   relation_kind k = VREL_VARYING;\n \n-  // Idenity any common operand, and notrmalize the relations to\n+  // Identify any common operand, and normalize the relations to\n   // the form : A < B  B < C produces A < C\n   if (rel.op1 () == name2)\n     {\n@@ -953,11 +953,11 @@ relation_chain_head::find_relation (const_bitmap b1, const_bitmap b2) const\n   if (!m_names)\n     return VREL_VARYING;\n \n-  // If both b1 and b2 aren't referenced in thie block, cant be a relation\n+  // If both b1 and b2 aren't referenced in this block, cant be a relation\n   if (!bitmap_intersect_p (m_names, b1) || !bitmap_intersect_p (m_names, b2))\n     return VREL_VARYING;\n \n-  // Search for the fiorst relation that contains BOTH an element from B1\n+  // Search for the first relation that contains BOTH an element from B1\n   // and B2, and return that relation.\n   for (relation_chain *ptr = m_head; ptr ; ptr = ptr->m_next)\n     {\n@@ -1285,7 +1285,7 @@ dom_oracle::query_relation (basic_block bb, const_bitmap b1,\n   if (bitmap_equal_p (b1, b2))\n     return VREL_EQ;\n \n-  // If either name does not occur in a relation anywhere, there isnt one.\n+  // If either name does not occur in a relation anywhere, there isn't one.\n   if (!bitmap_intersect_p (m_relation_set, b1)\n       || !bitmap_intersect_p (m_relation_set, b2))\n     return VREL_VARYING;\n@@ -1315,7 +1315,7 @@ dom_oracle::find_relation_block (int bb, unsigned v1, unsigned v2,\n   if (!bm)\n     return VREL_VARYING;\n \n-  // If both b1 and b2 aren't referenced in thie block, cant be a relation\n+  // If both b1 and b2 aren't referenced in this block, cant be a relation\n   if (!bitmap_bit_p (bm, v1) || !bitmap_bit_p (bm, v2))\n     return VREL_VARYING;\n \n@@ -1348,7 +1348,7 @@ relation_kind\n dom_oracle::find_relation_dom (basic_block bb, unsigned v1, unsigned v2) const\n {\n   relation_kind r;\n-  // IF either name does not occur in a relation anywhere, there isnt one.\n+  // IF either name does not occur in a relation anywhere, there isn't one.\n   if (!bitmap_bit_p (m_relation_set, v1) || !bitmap_bit_p (m_relation_set, v2))\n     return VREL_VARYING;\n \n@@ -1477,7 +1477,7 @@ path_oracle::equiv_set (tree ssa, basic_block bb)\n   return tmp;\n }\n \n-// Register an equivalence between SSA1 and SSA2 resolving unkowns from\n+// Register an equivalence between SSA1 and SSA2 resolving unknowns from\n // block BB.\n \n void"}, {"sha": "36a75862cc711349ed88090ea49004d4e43dc32f", "filename": "gcc/value-relation.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fvalue-relation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c46b5b0a2c10139379a25b0071aa8997af41220d/gcc%2Fvalue-relation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-relation.h?ref=c46b5b0a2c10139379a25b0071aa8997af41220d", "patch": "@@ -27,7 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n //\n // The general range_query object provided in value-query.h provides\n // access to an oracle, if one is available, via the oracle() method.\n-// Thre are also a couple of access routines provided, which even if there is\n+// There are also a couple of access routines provided, which even if there is\n // no oracle, will return the default VREL_VARYING no relation.\n //\n // Typically, when a ranger object is active, there will be an oracle, and\n@@ -36,7 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n // is totally transparent to the client, and they are free to make queries.\n //\n // relation_kind is a new enum which represents the different relations,\n-// often with a direct mapping to treee codes. ie VREL_EQ is equivalent to\n+// often with a direct mapping to tree codes. ie VREL_EQ is equivalent to\n // EQ_EXPR.\n //\n // A query is made requesting the relation between SSA1 and SSA@ in a basic\n@@ -48,10 +48,10 @@ along with GCC; see the file COPYING3.  If not see\n //\n // The oracle maintains VREL_EQ relations with equivalency sets, so if a\n // relation comes back VREL_EQ, it is also possible to query the set of\n-// equivlaencies.  These are basically bitmaps over ssa_names.  An iterator is\n+// equivalencies.  These are basically bitmaps over ssa_names.  An iterator is\n // provided later for this activity.\n //\n-// Relations are maintained via the dominace trees and are optimized assuming\n+// Relations are maintained via the dominance trees and are optimized assuming\n // they are registered in dominance order.   When a new relation is added, it\n // is intersected with whatever existing relation exists in the dominance tree\n // and registered at the specified block.\n@@ -148,7 +148,7 @@ class pe_slice\n // The equivalency oracle maintains equivalencies using the dominator tree.\n // Equivalencies apply to an entire basic block.  Equivalencies on edges\n // can be represented only on edges whose destination is a single-pred block,\n-// and the equivalence is simply applied to that succesor block.\n+// and the equivalence is simply applied to that successor block.\n \n class equiv_oracle : public relation_oracle\n {\n@@ -350,7 +350,7 @@ class relation_trio\n \n // These 3 classes are shortcuts for when a caller has a single relation to\n // pass as a trio, it can simply construct the appropriate one.  The other\n-// unspecified realtions will be VREL_VARYING.\n+// unspecified relations will be VREL_VARYING.\n \n inline relation_trio::relation_trio ()\n {\n@@ -411,7 +411,7 @@ relation_trio::swap_op1_op2 ()\n \n // -----------------------------------------------------------------------\n \n-// The value-relation class is used to encapsulate the represention of an\n+// The value-relation class is used to encapsulate the representation of an\n // individual relation between 2 ssa-names, and to facilitate operating on\n // the relation.\n \n@@ -467,7 +467,7 @@ value_relation::value_relation ()\n   name2 = NULL_TREE;\n }\n \n-// Constructor for relation R between SSA version N1 nd N2.\n+// Constructor for relation R between SSA version N1 and N2.\n \n inline\n value_relation::value_relation (relation_kind kind, tree n1, tree n2)\n@@ -517,7 +517,7 @@ bits_to_pe (int bits)\n   }\n }\n \n-// Given partial equivalencies T1 and T2, return the snmallest kind.\n+// Given partial equivalencies T1 and T2, return the smallest kind.\n \n inline relation_kind\n pe_min (relation_kind t1, relation_kind t2)"}]}