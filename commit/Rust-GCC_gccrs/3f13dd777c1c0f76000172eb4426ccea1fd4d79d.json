{"sha": "3f13dd777c1c0f76000172eb4426ccea1fd4d79d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2YxM2RkNzc3YzFjMGY3NjAwMDE3MmViNDQyNmNjZWExZmQ0ZDc5ZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-09-24T13:36:24Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-09-24T13:36:24Z"}, "message": "ada.h: Fix outdated comment.\n\n\t* gcc-interface/ada.h: Fix outdated comment.\n\t* gcc-interface/ada-tree.h (SET_TYPE_RM_VALUE): Use MARK_VISITED in\n\tlieu of mark_visited.\n\t* gcc-interface/gigi.h (mark_visited): Change type of parameter.\n\t(MARK_VISITED): New macro.\n\t(gnat_truthvalue_conversion): Delete.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Use MARK_VISITED in lieu\n\tof mark_visited.\n\t(annotate_rep): Fix formatting and tidy.\n\t(compute_field_positions): Get rid of useless variable.\n\t* gcc-interface/trans.c (gnat_to_gnu): Retrieve the Nkind of the GNAT\n\tnode only once.  Use IN operator for the Nkind in more cases.\n\tRemove calls to gnat_truthvalue_conversion.\n\t(mark_visited): Change type of parameter and adjust.\n\t(mark_visited_r): Dereference TP only once.\n\t(add_decl_expr): Use MARK_VISITED in lieu of mark_visited.\n\t* gcc-interface/utils2.c (gnat_truthvalue_conversion): Delete.\n\t(build_binary_op): Remove calls to gnat_truthvalue_conversion.\n\t(build_unary_op): Likewise.\n\nFrom-SVN: r152121", "tree": {"sha": "c8a62fd130fec7119d983c7798a5e73a7f612bdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8a62fd130fec7119d983c7798a5e73a7f612bdb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f13dd777c1c0f76000172eb4426ccea1fd4d79d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f13dd777c1c0f76000172eb4426ccea1fd4d79d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f13dd777c1c0f76000172eb4426ccea1fd4d79d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f13dd777c1c0f76000172eb4426ccea1fd4d79d/comments", "author": null, "committer": null, "parents": [{"sha": "6356f38faf789f0095575a9258f8d459917f7363", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6356f38faf789f0095575a9258f8d459917f7363", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6356f38faf789f0095575a9258f8d459917f7363"}], "stats": {"total": 389, "additions": 162, "deletions": 227}, "files": [{"sha": "bb8ee56366841c631adf21e74476b2292ee7ff26", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f13dd777c1c0f76000172eb4426ccea1fd4d79d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f13dd777c1c0f76000172eb4426ccea1fd4d79d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3f13dd777c1c0f76000172eb4426ccea1fd4d79d", "patch": "@@ -1,3 +1,25 @@\n+2009-09-24  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/ada.h: Fix outdated comment.\n+\t* gcc-interface/ada-tree.h (SET_TYPE_RM_VALUE): Use MARK_VISITED in\n+\tlieu of mark_visited.\n+\t* gcc-interface/gigi.h (mark_visited): Change type of parameter.\n+\t(MARK_VISITED): New macro.\n+\t(gnat_truthvalue_conversion): Delete.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Use MARK_VISITED in lieu\n+\tof mark_visited.\n+\t(annotate_rep): Fix formatting and tidy.\n+\t(compute_field_positions): Get rid of useless variable.\n+\t* gcc-interface/trans.c (gnat_to_gnu): Retrieve the Nkind of the GNAT\n+\tnode only once.  Use IN operator for the Nkind in more cases.\n+\tRemove calls to gnat_truthvalue_conversion.\n+\t(mark_visited): Change type of parameter and adjust.\n+\t(mark_visited_r): Dereference TP only once.\n+\t(add_decl_expr): Use MARK_VISITED in lieu of mark_visited.\n+\t* gcc-interface/utils2.c (gnat_truthvalue_conversion): Delete.\n+\t(build_binary_op): Remove calls to gnat_truthvalue_conversion.\n+\t(build_unary_op): Likewise.\n+\n 2009-09-24  Dave Korn  <dave.korn.cygwin@gmail.com>\n \n \t* gcc-interface/Makefile.in (LIBGNAT_TARGET_PAIRS): Simplify test for"}, {"sha": "864eb0b2056b880763f38437d3a275997076be8f", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f13dd777c1c0f76000172eb4426ccea1fd4d79d/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f13dd777c1c0f76000172eb4426ccea1fd4d79d/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=3f13dd777c1c0f76000172eb4426ccea1fd4d79d", "patch": "@@ -210,8 +210,7 @@ do {\t\t\t\t\t\t   \\\n     TYPE_RM_VALUES (NODE) = make_tree_vec (3);\t   \\\n   /* ??? The field is not visited by the generic   \\\n      code so we need to mark it manually.  */\t   \\\n-  if (!TREE_CONSTANT (tmp))\t\t\t   \\\n-    mark_visited (&tmp);\t\t\t   \\\n+  MARK_VISITED (tmp);\t\t\t\t   \\\n   TREE_VEC_ELT (TYPE_RM_VALUES (NODE), (N)) = tmp; \\\n } while (0)\n "}, {"sha": "095dec3d6ad4fcf6535acea9542be7d1edbab258", "filename": "gcc/ada/gcc-interface/ada.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f13dd777c1c0f76000172eb4426ccea1fd4d79d/gcc%2Fada%2Fgcc-interface%2Fada.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f13dd777c1c0f76000172eb4426ccea1fd4d79d/gcc%2Fada%2Fgcc-interface%2Fada.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada.h?ref=3f13dd777c1c0f76000172eb4426ccea1fd4d79d", "patch": "@@ -62,9 +62,9 @@\n   enum { CAT (SUBTYPE,__First) = FIRST,\t\t\\\n          CAT (SUBTYPE,__Last) = LAST };\n \n-/* The following definitions provide the equivalent of the Ada IN and NOT IN\n-   operators, assuming that the subtype involved has been defined using the\n-   SUBTYPE macro defined above.  */\n+/* The following definition provides the equivalent of the Ada IN operator,\n+   assuming that the subtype involved has been defined using the SUBTYPE\n+   macro defined above.  */\n \n #define IN(VALUE,SUBTYPE) \\\n   (((VALUE) >= (SUBTYPE) CAT (SUBTYPE,__First)) \\"}, {"sha": "1e54f38b0a5af4aa60865dfe3d1fd31a46bef213", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 50, "deletions": 52, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f13dd777c1c0f76000172eb4426ccea1fd4d79d/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f13dd777c1c0f76000172eb4426ccea1fd4d79d/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=3f13dd777c1c0f76000172eb4426ccea1fd4d79d", "patch": "@@ -898,11 +898,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t\t    if (stable)\n \t\t      {\n-\t\t\tgnu_decl = maybe_stable_expr;\n \t\t\t/* ??? No DECL_EXPR is created so we need to mark\n \t\t\t   the expression manually lest it is shared.  */\n \t\t\tif (global_bindings_p ())\n-\t\t\t  mark_visited (&gnu_decl);\n+\t\t\t  MARK_VISITED (maybe_stable_expr);\n+\t\t\tgnu_decl = maybe_stable_expr;\n \t\t\tsave_gnu_tree (gnat_entity, gnu_decl, true);\n \t\t\tsaved = true;\n \t\t\tannotate_object (gnat_entity, gnu_type, NULL_TREE,\n@@ -2465,7 +2465,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t\t  /* ??? create_type_decl is not invoked on the inner types so\n \t\t     the MULT_EXPR node built above will never be marked.  */\n-\t\t  mark_visited (&TYPE_SIZE_UNIT (gnu_arr_type));\n+\t\t  MARK_VISITED (TYPE_SIZE_UNIT (gnu_arr_type));\n \t\t}\n \t    }\n \n@@ -4631,7 +4631,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t   the MULT_EXPR node built above may not be marked by the call\n \t\t   to create_type_decl below.  */\n \t\tif (global_bindings_p ())\n-\t\t  mark_visited (&DECL_FIELD_OFFSET (gnu_field));\n+\t\t  MARK_VISITED (DECL_FIELD_OFFSET (gnu_field));\n \t\t}\n \t    }\n \n@@ -7271,78 +7271,76 @@ annotate_object (Entity_Id gnat_entity, tree gnu_type, tree size, bool by_ref)\n \t\t   UI_From_Int (TYPE_ALIGN (gnu_type) / BITS_PER_UNIT));\n }\n \n-/* Given GNAT_ENTITY, a record type, and GNU_TYPE, its corresponding\n-   GCC type, set Component_Bit_Offset and Esize to the position and size\n-   used by Gigi.  */\n+/* Given GNAT_ENTITY, a record type, and GNU_TYPE, its corresponding GCC type,\n+   set Component_Bit_Offset and Esize of the components to the position and\n+   size used by Gigi.  */\n \n static void\n annotate_rep (Entity_Id gnat_entity, tree gnu_type)\n {\n-  tree gnu_list;\n-  tree gnu_entry;\n   Entity_Id gnat_field;\n+  tree gnu_list;\n \n-  /* We operate by first making a list of all fields and their positions\n-     (we can get the sizes easily at any time) by a recursive call\n-     and then update all the sizes into the tree.  */\n-  gnu_list = compute_field_positions (gnu_type, NULL_TREE,\n-\t\t\t\t      size_zero_node, bitsize_zero_node,\n-\t\t\t\t      BIGGEST_ALIGNMENT);\n+  /* We operate by first making a list of all fields and their position (we\n+     can get the size easily) and then update all the sizes in the tree.  */\n+  gnu_list = compute_field_positions (gnu_type, NULL_TREE, size_zero_node,\n+\t\t\t\t      bitsize_zero_node, BIGGEST_ALIGNMENT);\n \n-  for (gnat_field = First_Entity (gnat_entity); Present (gnat_field);\n+  for (gnat_field = First_Entity (gnat_entity);\n+       Present (gnat_field);\n        gnat_field = Next_Entity (gnat_field))\n-    if ((Ekind (gnat_field) == E_Component\n-\t || (Ekind (gnat_field) == E_Discriminant\n-\t     && !Is_Unchecked_Union (Scope (gnat_field)))))\n+    if (Ekind (gnat_field) == E_Component\n+\t|| (Ekind (gnat_field) == E_Discriminant\n+\t    && !Is_Unchecked_Union (Scope (gnat_field))))\n       {\n-\ttree parent_offset = bitsize_zero_node;\n+\ttree parent_offset, t;\n \n-\tgnu_entry = purpose_member (gnat_to_gnu_field_decl (gnat_field),\n-\t\t\t\t    gnu_list);\n-\n-\tif (gnu_entry)\n+\tt = purpose_member (gnat_to_gnu_field_decl (gnat_field), gnu_list);\n+\tif (t)\n \t  {\n \t    if (type_annotate_only && Is_Tagged_Type (gnat_entity))\n \t      {\n-\t\t/* In this mode the tag and parent components have not been\n+\t\t/* In this mode the tag and parent components are not\n \t\t   generated, so we add the appropriate offset to each\n \t\t   component.  For a component appearing in the current\n \t\t   extension, the offset is the size of the parent.  */\n-\t    if (Is_Derived_Type (gnat_entity)\n-\t\t&& Original_Record_Component (gnat_field) == gnat_field)\n-\t      parent_offset\n-\t\t= UI_To_gnu (Esize (Etype (Base_Type (gnat_entity))),\n-\t\t\t     bitsizetype);\n-\t    else\n-\t      parent_offset = bitsize_int (POINTER_SIZE);\n+\t\tif (Is_Derived_Type (gnat_entity)\n+\t\t    && Original_Record_Component (gnat_field) == gnat_field)\n+\t\t  parent_offset\n+\t\t    = UI_To_gnu (Esize (Etype (Base_Type (gnat_entity))),\n+\t\t\t\t bitsizetype);\n+\t\telse\n+\t\t  parent_offset = bitsize_int (POINTER_SIZE);\n \t      }\n+\t    else\n+\t      parent_offset = bitsize_zero_node;\n \n-\t  Set_Component_Bit_Offset\n-\t    (gnat_field,\n-\t     annotate_value\n-\t     (size_binop (PLUS_EXPR,\n-\t\t\t  bit_from_pos (TREE_PURPOSE (TREE_VALUE (gnu_entry)),\n-\t\t\t\t\tTREE_VALUE (TREE_VALUE\n-\t\t\t\t\t\t    (TREE_VALUE (gnu_entry)))),\n-\t\t\t  parent_offset)));\n+\t    Set_Component_Bit_Offset\n+\t      (gnat_field,\n+\t       annotate_value\n+\t\t (size_binop (PLUS_EXPR,\n+\t\t\t      bit_from_pos (TREE_PURPOSE (TREE_VALUE (t)),\n+\t\t\t\t\t    TREE_VALUE (TREE_VALUE\n+\t\t\t\t\t\t\t(TREE_VALUE (t)))),\n+\t\t\t      parent_offset)));\n \n \t    Set_Esize (gnat_field,\n-\t\t       annotate_value (DECL_SIZE (TREE_PURPOSE (gnu_entry))));\n+\t\t       annotate_value (DECL_SIZE (TREE_PURPOSE (t))));\n \t  }\n-\telse if (Is_Tagged_Type (gnat_entity)\n-\t\t && Is_Derived_Type (gnat_entity))\n+\telse if (Is_Tagged_Type (gnat_entity) && Is_Derived_Type (gnat_entity))\n \t  {\n-\t    /* If there is no gnu_entry, this is an inherited component whose\n+\t    /* If there is no entry, this is an inherited component whose\n \t       position is the same as in the parent type.  */\n \t    Set_Component_Bit_Offset\n \t      (gnat_field,\n \t       Component_Bit_Offset (Original_Record_Component (gnat_field)));\n+\n \t    Set_Esize (gnat_field,\n \t\t       Esize (Original_Record_Component (gnat_field)));\n \t  }\n       }\n }\n-\n+\f\n /* Scan all fields in GNU_TYPE and build entries where TREE_PURPOSE is the\n    FIELD_DECL and TREE_VALUE a TREE_LIST with TREE_PURPOSE being the byte\n    position and TREE_VALUE being a TREE_LIST with TREE_PURPOSE the value to be\n@@ -7356,9 +7354,9 @@ compute_field_positions (tree gnu_type, tree gnu_list, tree gnu_pos,\n \t\t\t tree gnu_bitpos, unsigned int offset_align)\n {\n   tree gnu_field;\n-  tree gnu_result = gnu_list;\n \n-  for (gnu_field = TYPE_FIELDS (gnu_type); gnu_field;\n+  for (gnu_field = TYPE_FIELDS (gnu_type);\n+       gnu_field;\n        gnu_field = TREE_CHAIN (gnu_field))\n     {\n       tree gnu_our_bitpos = size_binop (PLUS_EXPR, gnu_bitpos,\n@@ -7368,22 +7366,22 @@ compute_field_positions (tree gnu_type, tree gnu_list, tree gnu_pos,\n       unsigned int our_offset_align\n \t= MIN (offset_align, DECL_OFFSET_ALIGN (gnu_field));\n \n-      gnu_result\n+      gnu_list\n \t= tree_cons (gnu_field,\n \t\t     tree_cons (gnu_our_offset,\n \t\t\t\ttree_cons (size_int (our_offset_align),\n \t\t\t\t\t   gnu_our_bitpos, NULL_TREE),\n \t\t\t\tNULL_TREE),\n-\t\t     gnu_result);\n+\t\t     gnu_list);\n \n       if (DECL_INTERNAL_P (gnu_field))\n-\tgnu_result\n-\t  = compute_field_positions (TREE_TYPE (gnu_field), gnu_result,\n+\tgnu_list\n+\t  = compute_field_positions (TREE_TYPE (gnu_field), gnu_list,\n \t\t\t\t     gnu_our_offset, gnu_our_bitpos,\n \t\t\t\t     our_offset_align);\n     }\n \n-  return gnu_result;\n+  return gnu_list;\n }\n \f\n /* UINT_SIZE is a Uint giving the specified size for an object of GNU_TYPE"}, {"sha": "fe91cf37142a7b7bdd5102000b38310abeb9aa35", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f13dd777c1c0f76000172eb4426ccea1fd4d79d/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f13dd777c1c0f76000172eb4426ccea1fd4d79d/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=3f13dd777c1c0f76000172eb4426ccea1fd4d79d", "patch": "@@ -75,10 +75,19 @@ extern void set_block_for_group (tree);\n    Get SLOC from GNAT_ENTITY.  */\n extern void add_decl_expr (tree gnu_decl, Entity_Id gnat_entity);\n \n-/* Mark nodes rooted at *TP with TREE_VISITED and types as having their\n+/* Mark nodes rooted at T with TREE_VISITED and types as having their\n    sized gimplified.  We use this to indicate all variable sizes and\n    positions in global types may not be shared by any subprogram.  */\n-extern void mark_visited (tree *tp);\n+extern void mark_visited (tree t);\n+\n+/* This macro calls the above function but short-circuits the common\n+   case of a constant to save time and also checks for NULL.  */\n+\n+#define MARK_VISITED(EXP)\t\t\\\n+do {\t\t\t\t\t\\\n+  if((EXP) && !TREE_CONSTANT (EXP))\t\\\n+    mark_visited (EXP);\t\t\t\\\n+} while (0)\n \n /* Finalize any From_With_Type incomplete types.  We do this after processing\n    our compilation unit and after processing its spec, if this is a body.  */\n@@ -767,20 +776,6 @@ extern bool is_double_scalar_or_array (Entity_Id gnat_type,\n    component of an aggregate type.  */\n extern bool type_for_nonaliased_component_p (tree gnu_type);\n \n-/* Prepare expr to be an argument of a TRUTH_NOT_EXPR or other logical\n-   operation.\n-\n-   This preparation consists of taking the ordinary\n-   representation of an expression EXPR and producing a valid tree\n-   boolean expression describing whether EXPR is nonzero.  We could\n-   simply always do build_binary_op (NE_EXPR, expr, integer_zero_node, 1),\n-   but we optimize comparisons, &&, ||, and !.\n-\n-   The resulting type should always be the same as the input type.\n-   This function is simpler than the corresponding C version since\n-   the only possible operands will be things of Boolean type.  */\n-extern tree gnat_truthvalue_conversion (tree expr);\n-\n /* Return the base type of TYPE.  */\n extern tree get_base_type (tree type);\n "}, {"sha": "2669bde477ec0fdf143cdd4bab1dae6cd528ecf3", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 74, "deletions": 87, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f13dd777c1c0f76000172eb4426ccea1fd4d79d/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f13dd777c1c0f76000172eb4426ccea1fd4d79d/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=3f13dd777c1c0f76000172eb4426ccea1fd4d79d", "patch": "@@ -3454,64 +3454,55 @@ unchecked_conversion_lhs_nop (Node_Id gnat_node)\n   return false;\n }\n \n-/* This function is the driver of the GNAT to GCC tree transformation\n-   process.  It is the entry point of the tree transformer.  GNAT_NODE is the\n-   root of some GNAT tree.  Return the root of the corresponding GCC tree.\n-   If this is an expression, return the GCC equivalent of the expression.  If\n-   it is a statement, return the statement.  In the case when called for a\n-   statement, it may also add statements to the current statement group, in\n-   which case anything it returns is to be interpreted as occurring after\n-   anything `it already added.  */\n+/* This function is the driver of the GNAT to GCC tree transformation process.\n+   It is the entry point of the tree transformer.  GNAT_NODE is the root of\n+   some GNAT tree.  Return the root of the corresponding GCC tree.  If this\n+   is an expression, return the GCC equivalent of the expression.  If this\n+   is a statement, return the statement or add it to the current statement\n+   group, in which case anything returned is to be interpreted as occurring\n+   after anything added.  */\n \n tree\n gnat_to_gnu (Node_Id gnat_node)\n {\n+  const Node_Kind kind = Nkind (gnat_node);\n   bool went_into_elab_proc = false;\n   tree gnu_result = error_mark_node; /* Default to no value.  */\n   tree gnu_result_type = void_type_node;\n-  tree gnu_expr;\n-  tree gnu_lhs, gnu_rhs;\n+  tree gnu_expr, gnu_lhs, gnu_rhs;\n   Node_Id gnat_temp;\n \n   /* Save node number for error message and set location information.  */\n   error_gnat_node = gnat_node;\n   Sloc_to_locus (Sloc (gnat_node), &input_location);\n \n-  if (type_annotate_only\n-      && IN (Nkind (gnat_node), N_Statement_Other_Than_Procedure_Call))\n+  /* If this node is a statement and we are only annotating types, return an\n+     empty statement list.  */\n+  if (type_annotate_only && IN (kind, N_Statement_Other_Than_Procedure_Call))\n     return alloc_stmt_list ();\n \n-  /* If this node is a non-static subexpression and we are only\n-     annotating types, make this into a NULL_EXPR.  */\n+  /* If this node is a non-static subexpression and we are only annotating\n+     types, make this into a NULL_EXPR.  */\n   if (type_annotate_only\n-      && IN (Nkind (gnat_node), N_Subexpr)\n-      && Nkind (gnat_node) != N_Identifier\n+      && IN (kind, N_Subexpr)\n+      && kind != N_Identifier\n       && !Compile_Time_Known_Value (gnat_node))\n     return build1 (NULL_EXPR, get_unpadded_type (Etype (gnat_node)),\n \t\t   build_call_raise (CE_Range_Check_Failed, gnat_node,\n \t\t\t\t     N_Raise_Constraint_Error));\n \n-  /* If this is a Statement and we are at top level, it must be part of the\n-     elaboration procedure, so mark us as being in that procedure and push our\n-     context.\n-\n-     If we are in the elaboration procedure, check if we are violating a\n-     No_Elaboration_Code restriction by having a statement there.  */\n-  if ((IN (Nkind (gnat_node), N_Statement_Other_Than_Procedure_Call)\n-       && Nkind (gnat_node) != N_Null_Statement\n-       && Nkind (gnat_node) != N_SCIL_Dispatch_Table_Object_Init\n-       && Nkind (gnat_node) != N_SCIL_Dispatch_Table_Tag_Init\n-       && Nkind (gnat_node) != N_SCIL_Dispatching_Call\n-       && Nkind (gnat_node) != N_SCIL_Tag_Init)\n-      || Nkind (gnat_node) == N_Procedure_Call_Statement\n-      || Nkind (gnat_node) == N_Label\n-      || Nkind (gnat_node) == N_Implicit_Label_Declaration\n-      || Nkind (gnat_node) == N_Handled_Sequence_Of_Statements\n-      || ((Nkind (gnat_node) == N_Raise_Constraint_Error\n-\t   || Nkind (gnat_node) == N_Raise_Storage_Error\n-\t   || Nkind (gnat_node) == N_Raise_Program_Error)\n-\t  && (Ekind (Etype (gnat_node)) == E_Void)))\n+  if ((IN (kind, N_Statement_Other_Than_Procedure_Call)\n+       && !IN (kind, N_SCIL_Node)\n+       && kind != N_Null_Statement)\n+      || kind == N_Procedure_Call_Statement\n+      || kind == N_Label\n+      || kind == N_Implicit_Label_Declaration\n+      || kind == N_Handled_Sequence_Of_Statements\n+      || (IN (kind, N_Raise_xxx_Error) && Ekind (Etype (gnat_node)) == E_Void))\n     {\n+      /* If this is a statement and we are at top level, it must be part of\n+\t the elaboration procedure, so mark us as being in that procedure\n+\t and push our context.  */\n       if (!current_function_decl)\n \t{\n \t  current_function_decl = TREE_VALUE (gnu_elab_proc_stack);\n@@ -3520,18 +3511,19 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  went_into_elab_proc = true;\n \t}\n \n-      /* Don't check for a possible No_Elaboration_Code restriction violation\n-\t on N_Handled_Sequence_Of_Statements, as we want to signal an error on\n+      /* If we are in the elaboration procedure, check if we are violating a\n+\t No_Elaboration_Code restriction by having a statement there.  Don't\n+\t check for a possible No_Elaboration_Code restriction violation on\n+\t N_Handled_Sequence_Of_Statements, as we want to signal an error on\n \t every nested real statement instead.  This also avoids triggering\n \t spurious errors on dummy (empty) sequences created by the front-end\n \t for package bodies in some cases.  */\n-\n       if (current_function_decl == TREE_VALUE (gnu_elab_proc_stack)\n-\t  && Nkind (gnat_node) != N_Handled_Sequence_Of_Statements)\n+\t  && kind != N_Handled_Sequence_Of_Statements)\n \tCheck_Elaboration_Code_Allowed (gnat_node);\n     }\n \n-  switch (Nkind (gnat_node))\n+  switch (kind)\n     {\n       /********************************/\n       /* Chapter 2: Lexical Elements  */\n@@ -3743,8 +3735,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \tbreak;\n \n       if (Present (Expression (gnat_node))\n-\t  && !(Nkind (gnat_node) == N_Object_Declaration\n-\t       && No_Initialization (gnat_node))\n+\t  && !(kind == N_Object_Declaration && No_Initialization (gnat_node))\n \t  && (!type_annotate_only\n \t      || Compile_Time_Known_Value (Expression (gnat_node))))\n \t{\n@@ -4136,7 +4127,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t= convert_with_check (Etype (gnat_node), gnu_result,\n \t\t\t      Do_Overflow_Check (gnat_node),\n \t\t\t      Do_Range_Check (Expression (gnat_node)),\n-\t\t\t      Nkind (gnat_node) == N_Type_Conversion\n+\t\t\t      kind == N_Type_Conversion\n \t\t\t      && Float_Truncate (gnat_node), gnat_node);\n       break;\n \n@@ -4224,7 +4215,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t\t\t\t  gnu_object, gnu_high));\n \t  }\n \n-\tif (Nkind (gnat_node) == N_Not_In)\n+\tif (kind == N_Not_In)\n \t  gnu_result = invert_truthvalue (gnu_result);\n       }\n       break;\n@@ -4248,8 +4239,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t      Modular_Integer_Kind))\n \t{\n \t  enum tree_code code\n-\t    = (Nkind (gnat_node) == N_Op_Or ? BIT_IOR_EXPR\n-\t       : Nkind (gnat_node) == N_Op_And ? BIT_AND_EXPR\n+\t    = (kind == N_Op_Or ? BIT_IOR_EXPR\n+\t       : kind == N_Op_And ? BIT_AND_EXPR\n \t       : BIT_XOR_EXPR);\n \n \t  gnu_lhs = gnat_to_gnu (Left_Opnd (gnat_node));\n@@ -4273,7 +4264,7 @@ gnat_to_gnu (Node_Id gnat_node)\n     case N_Op_Shift_Right_Arithmetic:\n     case N_And_Then: case N_Or_Else:\n       {\n-\tenum tree_code code = gnu_codes[Nkind (gnat_node)];\n+\tenum tree_code code = gnu_codes[kind];\n \tbool ignore_lhs_overflow = false;\n \ttree gnu_type;\n \n@@ -4299,18 +4290,16 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \t/* If this is a shift whose count is not guaranteed to be correct,\n \t   we need to adjust the shift count.  */\n-\tif (IN (Nkind (gnat_node), N_Op_Shift)\n-\t    && !Shift_Count_OK (gnat_node))\n+\tif (IN (kind, N_Op_Shift) && !Shift_Count_OK (gnat_node))\n \t  {\n \t    tree gnu_count_type = get_base_type (TREE_TYPE (gnu_rhs));\n \t    tree gnu_max_shift\n \t      = convert (gnu_count_type, TYPE_SIZE (gnu_type));\n \n-\t    if (Nkind (gnat_node) == N_Op_Rotate_Left\n-\t\t|| Nkind (gnat_node) == N_Op_Rotate_Right)\n+\t    if (kind == N_Op_Rotate_Left || kind == N_Op_Rotate_Right)\n \t      gnu_rhs = build_binary_op (TRUNC_MOD_EXPR, gnu_count_type,\n \t\t\t\t\t gnu_rhs, gnu_max_shift);\n-\t    else if (Nkind (gnat_node) == N_Op_Shift_Right_Arithmetic)\n+\t    else if (kind == N_Op_Shift_Right_Arithmetic)\n \t      gnu_rhs\n \t\t= build_binary_op\n \t\t  (MIN_EXPR, gnu_count_type,\n@@ -4326,13 +4315,12 @@ gnat_to_gnu (Node_Id gnat_node)\n \t   so we may need to choose a different type.  In this case,\n \t   we have to ignore integer overflow lest it propagates all\n \t   the way down and causes a CE to be explicitly raised.  */\n-\tif (Nkind (gnat_node) == N_Op_Shift_Right\n-\t    && !TYPE_UNSIGNED (gnu_type))\n+\tif (kind == N_Op_Shift_Right && !TYPE_UNSIGNED (gnu_type))\n \t  {\n \t    gnu_type = gnat_unsigned_type (gnu_type);\n \t    ignore_lhs_overflow = true;\n \t  }\n-\telse if (Nkind (gnat_node) == N_Op_Shift_Right_Arithmetic\n+\telse if (kind == N_Op_Shift_Right_Arithmetic\n \t\t && TYPE_UNSIGNED (gnu_type))\n \t  {\n \t    gnu_type = gnat_signed_type (gnu_type);\n@@ -4355,9 +4343,9 @@ gnat_to_gnu (Node_Id gnat_node)\n \t   do overflow checking, do it here.  The goal is to push\n \t   the expansions further into the back end over time.  */\n \tif (Do_Overflow_Check (gnat_node) && Backend_Overflow_Checks_On_Target\n-\t    && (Nkind (gnat_node) == N_Op_Add\n-\t\t|| Nkind (gnat_node) == N_Op_Subtract\n-\t\t|| Nkind (gnat_node) == N_Op_Multiply)\n+\t    && (kind == N_Op_Add\n+\t\t|| kind == N_Op_Subtract\n+\t\t|| kind == N_Op_Multiply)\n \t    && !TYPE_UNSIGNED (gnu_type)\n \t    && !FLOAT_TYPE_P (gnu_type))\n \t  gnu_result = build_binary_op_trapv (code, gnu_type,\n@@ -4368,8 +4356,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t/* If this is a logical shift with the shift count not verified,\n \t   we must return zero if it is too large.  We cannot compensate\n \t   above in this case.  */\n-\tif ((Nkind (gnat_node) == N_Op_Shift_Left\n-\t     || Nkind (gnat_node) == N_Op_Shift_Right)\n+\tif ((kind == N_Op_Shift_Left || kind == N_Op_Shift_Right)\n \t    && !Shift_Count_OK (gnat_node))\n \t  gnu_result\n \t    = build_cond_expr\n@@ -4391,9 +4378,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  = gnat_to_gnu (Next (Next (First (Expressions (gnat_node)))));\n \n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n-\tgnu_result = build_cond_expr (gnu_result_type,\n-\t\t\t\t      gnat_truthvalue_conversion (gnu_cond),\n-\t\t\t\t      gnu_true, gnu_false);\n+\tgnu_result\n+\t  = build_cond_expr (gnu_result_type, gnu_cond, gnu_true, gnu_false);\n       }\n       break;\n \n@@ -4432,10 +4418,10 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  && !TYPE_UNSIGNED (gnu_result_type)\n \t  && !FLOAT_TYPE_P (gnu_result_type))\n \tgnu_result\n-\t  = build_unary_op_trapv (gnu_codes[Nkind (gnat_node)],\n+\t  = build_unary_op_trapv (gnu_codes[kind],\n \t\t\t\t  gnu_result_type, gnu_expr, gnat_node);\n       else\n-\tgnu_result = build_unary_op (gnu_codes[Nkind (gnat_node)],\n+\tgnu_result = build_unary_op (gnu_codes[kind],\n \t\t\t\t     gnu_result_type, gnu_expr);\n       break;\n \n@@ -5204,8 +5190,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \n       gnu_result_type = get_unpadded_type (Etype (gnat_node));\n       gnu_result\n-\t= build_call_raise (UI_To_Int (Reason (gnat_node)), gnat_node,\n-\t\t\t    Nkind (gnat_node));\n+\t= build_call_raise (UI_To_Int (Reason (gnat_node)), gnat_node, kind);\n \n       /* If the type is VOID, this is a statement, so we need to\n \t generate the code for the call.  Handle a Condition, if there\n@@ -5564,14 +5549,14 @@ add_decl_expr (tree gnu_decl, Entity_Id gnat_entity)\n       /* Mark everything as used to prevent node sharing with subprograms.\n \t Note that walk_tree knows how to deal with TYPE_DECL, but neither\n \t VAR_DECL nor CONST_DECL.  This appears to be somewhat arbitrary.  */\n-      mark_visited (&gnu_stmt);\n+      MARK_VISITED (gnu_stmt);\n \n       if (TREE_CODE (gnu_decl) == VAR_DECL\n \t  || TREE_CODE (gnu_decl) == CONST_DECL)\n \t{\n-\t  mark_visited (&DECL_SIZE (gnu_decl));\n-\t  mark_visited (&DECL_SIZE_UNIT (gnu_decl));\n-\t  mark_visited (&DECL_INITIAL (gnu_decl));\n+\t  MARK_VISITED (DECL_SIZE (gnu_decl));\n+\t  MARK_VISITED (DECL_SIZE_UNIT (gnu_decl));\n+\t  MARK_VISITED (DECL_INITIAL (gnu_decl));\n \t}\n     }\n   else\n@@ -5611,20 +5596,32 @@ add_decl_expr (tree gnu_decl, Entity_Id gnat_entity)\n static tree\n mark_visited_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n {\n-  if (TREE_VISITED (*tp))\n+  tree t = *tp;\n+\n+  if (TREE_VISITED (t))\n     *walk_subtrees = 0;\n \n   /* Don't mark a dummy type as visited because we want to mark its sizes\n      and fields once it's filled in.  */\n-  else if (!TYPE_IS_DUMMY_P (*tp))\n-    TREE_VISITED (*tp) = 1;\n+  else if (!TYPE_IS_DUMMY_P (t))\n+    TREE_VISITED (t) = 1;\n \n-  if (TYPE_P (*tp))\n-    TYPE_SIZES_GIMPLIFIED (*tp) = 1;\n+  if (TYPE_P (t))\n+    TYPE_SIZES_GIMPLIFIED (t) = 1;\n \n   return NULL_TREE;\n }\n \n+/* Mark nodes rooted at T with TREE_VISITED and types as having their\n+   sized gimplified.  We use this to indicate all variable sizes and\n+   positions in global types may not be shared by any subprogram.  */\n+\n+void\n+mark_visited (tree t)\n+{\n+  walk_tree (&t, mark_visited_r, NULL, NULL);\n+}\n+\n /* Utility function to unshare expressions wrapped up in a SAVE_EXPR.  */\n \n static tree\n@@ -5639,16 +5636,6 @@ unshare_save_expr (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n   return NULL_TREE;\n }\n \n-/* Mark nodes rooted at *TP with TREE_VISITED and types as having their\n-   sized gimplified.  We use this to indicate all variable sizes and\n-   positions in global types may not be shared by any subprogram.  */\n-\n-void\n-mark_visited (tree *tp)\n-{\n-  walk_tree (tp, mark_visited_r, NULL, NULL);\n-}\n-\n /* Add GNU_CLEANUP, a cleanup action, to the current code group and\n    set its location to that of GNAT_NODE if present.  */\n "}, {"sha": "f8a3dfbd5253b9c42c148085af1ba92aaef65eba", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 1, "deletions": 67, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f13dd777c1c0f76000172eb4426ccea1fd4d79d/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f13dd777c1c0f76000172eb4426ccea1fd4d79d/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=3f13dd777c1c0f76000172eb4426ccea1fd4d79d", "patch": "@@ -55,63 +55,6 @@ static tree compare_arrays (tree, tree, tree);\n static tree nonbinary_modular_operation (enum tree_code, tree, tree, tree);\n static tree build_simple_component_ref (tree, tree, tree, bool);\n \f\n-/* Prepare expr to be an argument of a TRUTH_NOT_EXPR or other logical\n-   operation.\n-\n-   This preparation consists of taking the ordinary representation of\n-   an expression expr and producing a valid tree boolean expression\n-   describing whether expr is nonzero. We could simply always do\n-\n-      build_binary_op (NE_EXPR, expr, integer_zero_node, 1),\n-\n-   but we optimize comparisons, &&, ||, and !.\n-\n-   The resulting type should always be the same as the input type.\n-   This function is simpler than the corresponding C version since\n-   the only possible operands will be things of Boolean type.  */\n-\n-tree\n-gnat_truthvalue_conversion (tree expr)\n-{\n-  tree type = TREE_TYPE (expr);\n-\n-  switch (TREE_CODE (expr))\n-    {\n-    case EQ_EXPR:  case NE_EXPR: case LE_EXPR: case GE_EXPR:\n-    case LT_EXPR:  case GT_EXPR:\n-    case TRUTH_ANDIF_EXPR:\n-    case TRUTH_ORIF_EXPR:\n-    case TRUTH_AND_EXPR:\n-    case TRUTH_OR_EXPR:\n-    case TRUTH_XOR_EXPR:\n-    case ERROR_MARK:\n-      return expr;\n-\n-    case INTEGER_CST:\n-      return (integer_zerop (expr)\n-\t      ? build_int_cst (type, 0)\n-\t      : build_int_cst (type, 1));\n-\n-    case REAL_CST:\n-      return (real_zerop (expr)\n-\t      ? fold_convert (type, integer_zero_node)\n-\t      : fold_convert (type, integer_one_node));\n-\n-    case COND_EXPR:\n-      /* Distribute the conversion into the arms of a COND_EXPR.  */\n-      {\n-\ttree arg1 = gnat_truthvalue_conversion (TREE_OPERAND (expr, 1));\n-\ttree arg2 = gnat_truthvalue_conversion (TREE_OPERAND (expr, 2));\n-\treturn fold_build3 (COND_EXPR, type, TREE_OPERAND (expr, 0),\n-\t\t\t    arg1, arg2);\n-      }\n-\n-    default:\n-      return build_binary_op (NE_EXPR, type, expr,\n-\t\t\t      fold_convert (type, integer_zero_node));\n-    }\n-}\n-\f\n /* Return the base type of TYPE.  */\n \n tree\n@@ -970,15 +913,6 @@ build_binary_op (enum tree_code op_code, tree result_type,\n       left_operand = convert (operation_type, left_operand);\n       break;\n \n-    case TRUTH_ANDIF_EXPR:\n-    case TRUTH_ORIF_EXPR:\n-    case TRUTH_AND_EXPR:\n-    case TRUTH_OR_EXPR:\n-    case TRUTH_XOR_EXPR:\n-      left_operand = gnat_truthvalue_conversion (left_operand);\n-      right_operand = gnat_truthvalue_conversion (right_operand);\n-      goto common;\n-\n     case BIT_AND_EXPR:\n     case BIT_IOR_EXPR:\n     case BIT_XOR_EXPR:\n@@ -1120,7 +1054,7 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \n     case TRUTH_NOT_EXPR:\n       gcc_assert (result_type == base_type);\n-      result = invert_truthvalue (gnat_truthvalue_conversion (operand));\n+      result = invert_truthvalue (operand);\n       break;\n \n     case ATTR_ADDR_EXPR:"}]}