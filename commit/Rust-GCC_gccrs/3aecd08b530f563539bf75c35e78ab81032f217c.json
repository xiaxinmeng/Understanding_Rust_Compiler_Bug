{"sha": "3aecd08b530f563539bf75c35e78ab81032f217c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FlY2QwOGI1MzBmNTYzNTM5YmY3NWMzNWU3OGFiODEwMzJmMjE3Yw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2004-09-23T20:15:30Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2004-09-23T20:15:30Z"}, "message": "tree-ssa-ccp.c (get_default_value): Use SSA_NAME_VALUE rather than SSA_NAME_EQUIV and SET_SSA_NAME_EQUIV.\n\n\n\t* tree-ssa-ccp.c (get_default_value): Use SSA_NAME_VALUE rather\n\tthan SSA_NAME_EQUIV and SET_SSA_NAME_EQUIV.\n\t(substitute_and_fold):  Likewise.\n\t* tree-ssa-dom.c (tree_ssa_dominator_optimize): Remove everything\n\texcept invariants from SSA_NAME_VALUE.\n\t(thread_across_edge): Use SSA_NAME_VALUE rather than SSA_NAME_EQUIV\n\tand SET_SSA_NAME_EQUIV.\n\t(restore_vars_to_original_value, record_const_or_copy): Likewise.\n\t(record_equivalences_from_phis, record_const_or_copy_1): Likewise.\n\t(record_equality, cprop_into_successor_phis): Likewise.\n\t(record_equivalences_from_stmt, cprop_operand): Likewise.\n\t(lookup_avail_expr): Likewise.\n\t* tree-ssa-pre.c (fini_pre): Remove everything except invariants\n\tfrom SSA_NAME_VALUE.\n\t* tree.h (SSA_NAME_EQUIV, SET_SSA_NAME_EQUIV): Kill.\n\t(struct tree_ssa_name):  Kill EQUIV field.  Remove GGC skip\n\tannotation from the VALUE_HANDLE field.\n\nFrom-SVN: r87979", "tree": {"sha": "bcd7348fb84a0565837d2e0909dc0d5a2d44241e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bcd7348fb84a0565837d2e0909dc0d5a2d44241e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3aecd08b530f563539bf75c35e78ab81032f217c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aecd08b530f563539bf75c35e78ab81032f217c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3aecd08b530f563539bf75c35e78ab81032f217c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aecd08b530f563539bf75c35e78ab81032f217c/comments", "author": null, "committer": null, "parents": [{"sha": "0c482362dd7c23fb89a324670636e8fee147774f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c482362dd7c23fb89a324670636e8fee147774f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c482362dd7c23fb89a324670636e8fee147774f"}], "stats": {"total": 130, "additions": 87, "deletions": 43}, "files": [{"sha": "f3eca49b2631bc9346e5e73df37aff79fa79fe9a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aecd08b530f563539bf75c35e78ab81032f217c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aecd08b530f563539bf75c35e78ab81032f217c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3aecd08b530f563539bf75c35e78ab81032f217c", "patch": "@@ -1,3 +1,23 @@\n+2004-09-23 Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-ccp.c (get_default_value): Use SSA_NAME_VALUE rather\n+\tthan SSA_NAME_EQUIV and SET_SSA_NAME_EQUIV.\n+\t(substitute_and_fold):  Likewise.\n+\t* tree-ssa-dom.c (tree_ssa_dominator_optimize): Remove everything\n+\texcept invariants from SSA_NAME_VALUE.\n+\t(thread_across_edge): Use SSA_NAME_VALUE rather than SSA_NAME_EQUIV\n+\tand SET_SSA_NAME_EQUIV.\n+\t(restore_vars_to_original_value, record_const_or_copy): Likewise.\n+\t(record_equivalences_from_phis, record_const_or_copy_1): Likewise.\n+\t(record_equality, cprop_into_successor_phis): Likewise.\n+\t(record_equivalences_from_stmt, cprop_operand): Likewise.\n+\t(lookup_avail_expr): Likewise.\n+\t* tree-ssa-pre.c (fini_pre): Remove everything except invariants\n+\tfrom SSA_NAME_VALUE.\n+\t* tree.h (SSA_NAME_EQUIV, SET_SSA_NAME_EQUIV): Kill.\n+\t(struct tree_ssa_name):  Kill EQUIV field.  Remove GGC skip\n+\tannotation from the VALUE_HANDLE field.\n+\n 2004-09-21 Fariborz Jahanian <fjahanian@apple.com>\n \tPR c++/13989\n \tPR c++/9844"}, {"sha": "f268686668c4cda768cbcdef334d4efaf691e7fb", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aecd08b530f563539bf75c35e78ab81032f217c/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aecd08b530f563539bf75c35e78ab81032f217c/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=3aecd08b530f563539bf75c35e78ab81032f217c", "patch": "@@ -136,11 +136,11 @@ get_default_value (tree var)\n   val.const_val = NULL_TREE;\n \n   if (TREE_CODE (var) == SSA_NAME\n-      && SSA_NAME_EQUIV (var)\n-      && is_gimple_min_invariant (SSA_NAME_EQUIV (var)))\n+      && SSA_NAME_VALUE (var)\n+      && is_gimple_min_invariant (SSA_NAME_VALUE (var)))\n     {\n       val.lattice_val = CONSTANT;\n-      val.const_val = SSA_NAME_EQUIV (var);\n+      val.const_val = SSA_NAME_VALUE (var);\n     }\n   else if (TREE_CODE (sym) == PARM_DECL || TREE_THIS_VOLATILE (sym))\n     {\n@@ -611,7 +611,7 @@ substitute_and_fold (void)\n       if (value->lattice_val == CONSTANT\n           && is_gimple_reg (name)\n \t  && is_gimple_min_invariant (value->const_val))\n-\tSET_SSA_NAME_EQUIV (name, value->const_val)\n+\tSSA_NAME_VALUE (name) = value->const_val;\n     }\n }\n "}, {"sha": "6c0cb785e1ba5e51950019212943124a55ff5e61", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 41, "deletions": 23, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aecd08b530f563539bf75c35e78ab81032f217c/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aecd08b530f563539bf75c35e78ab81032f217c/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=3aecd08b530f563539bf75c35e78ab81032f217c", "patch": "@@ -404,6 +404,24 @@ tree_ssa_dominator_optimize (void)\n   /* Free nonzero_vars.   */\n   BITMAP_XFREE (nonzero_vars);\n   BITMAP_XFREE (need_eh_cleanup);\n+\n+  /* Finally, remove everything except invariants in SSA_NAME_VALUE.\n+\n+     Long term we will be able to let everything in SSA_NAME_VALUE\n+     persist.  However, for now, we know this is the safe thing to\n+     do.  */\n+  for (i = 0; i < num_ssa_names; i++)\n+    {\n+      tree name = ssa_name (i);\n+      tree value;\n+\n+      if (!name)\n+\tcontinue;\n+\n+      value = SSA_NAME_VALUE (name);\n+      if (value && !is_gimple_min_invariant (value))\n+\tSSA_NAME_VALUE (name) = NULL;\n+    }\n }\n \n static bool\n@@ -503,8 +521,8 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n \n \t      uses_copy[i] = USE_OP (uses, i);\n \t      if (TREE_CODE (USE_OP (uses, i)) == SSA_NAME)\n-\t\ttmp = SSA_NAME_EQUIV (USE_OP (uses, i));\n-\t      if (tmp)\n+\t\ttmp = SSA_NAME_VALUE (USE_OP (uses, i));\n+\t      if (tmp && TREE_CODE (tmp) != VALUE_HANDLE)\n \t\tSET_USE_OP (uses, i, tmp);\n \t    }\n \n@@ -515,8 +533,8 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n \n \t      vuses_copy[i] = VUSE_OP (vuses, i);\n \t      if (TREE_CODE (VUSE_OP (vuses, i)) == SSA_NAME)\n-\t\ttmp = SSA_NAME_EQUIV (VUSE_OP (vuses, i));\n-\t      if (tmp)\n+\t\ttmp = SSA_NAME_VALUE (VUSE_OP (vuses, i));\n+\t      if (tmp && TREE_CODE (tmp) != VALUE_HANDLE)\n \t\tSET_VUSE_OP (vuses, i, tmp);\n \t    }\n \n@@ -607,15 +625,15 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n \t  /* Get the current value of both operands.  */\n \t  if (TREE_CODE (op0) == SSA_NAME)\n \t    {\n-\t      tree tmp = SSA_NAME_EQUIV (op0);\n-\t      if (tmp)\n+\t      tree tmp = SSA_NAME_VALUE (op0);\n+\t      if (tmp && TREE_CODE (tmp) != VALUE_HANDLE)\n \t\top0 = tmp;\n \t    }\n \n \t  if (TREE_CODE (op1) == SSA_NAME)\n \t    {\n-\t      tree tmp = SSA_NAME_EQUIV (op1);\n-\t      if (tmp)\n+\t      tree tmp = SSA_NAME_VALUE (op1);\n+\t      if (tmp && TREE_CODE (tmp) != VALUE_HANDLE)\n \t\top1 = tmp;\n \t    }\n \n@@ -654,7 +672,7 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n       else if (TREE_CODE (cond) == SSA_NAME)\n \t{\n \t  cached_lhs = cond;\n-\t  cached_lhs = SSA_NAME_EQUIV (cached_lhs);\n+\t  cached_lhs = SSA_NAME_VALUE (cached_lhs);\n \t  if (cached_lhs && ! is_gimple_min_invariant (cached_lhs))\n \t    cached_lhs = 0;\n \t}\n@@ -809,7 +827,7 @@ restore_vars_to_original_value (void)\n       prev_value = VARRAY_TOP_TREE (const_and_copies_stack);\n       VARRAY_POP (const_and_copies_stack);\n \n-      SET_SSA_NAME_EQUIV (dest, prev_value);\n+      SSA_NAME_VALUE (dest) =  prev_value;\n     }\n }\n \n@@ -1067,7 +1085,7 @@ record_equivalences_from_phis (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n \t by this assignment, so unwinding just costs time and space.  */\n       if (i == PHI_NUM_ARGS (phi)\n \t  && may_propagate_copy (lhs, rhs))\n-\tSET_SSA_NAME_EQUIV (lhs, rhs);\n+\tSSA_NAME_VALUE (lhs) = rhs;\n \n       /* Now see if we know anything about the nonzero property for the\n \t result of this PHI.  */\n@@ -1463,7 +1481,7 @@ record_dominating_conditions (tree cond)\n static void\n record_const_or_copy_1 (tree x, tree y, tree prev_x)\n {\n-  SET_SSA_NAME_EQUIV (x, y);\n+  SSA_NAME_VALUE (x) = y;\n \n   VARRAY_PUSH_TREE (const_and_copies_stack, prev_x);\n   VARRAY_PUSH_TREE (const_and_copies_stack, x);\n@@ -1475,11 +1493,11 @@ record_const_or_copy_1 (tree x, tree y, tree prev_x)\n static void\n record_const_or_copy (tree x, tree y)\n {\n-  tree prev_x = SSA_NAME_EQUIV (x);\n+  tree prev_x = SSA_NAME_VALUE (x);\n \n   if (TREE_CODE (y) == SSA_NAME)\n     {\n-      tree tmp = SSA_NAME_EQUIV (y);\n+      tree tmp = SSA_NAME_VALUE (y);\n       if (tmp)\n \ty = tmp;\n     }\n@@ -1496,9 +1514,9 @@ record_equality (tree x, tree y)\n   tree prev_x = NULL, prev_y = NULL;\n \n   if (TREE_CODE (x) == SSA_NAME)\n-    prev_x = SSA_NAME_EQUIV (x);\n+    prev_x = SSA_NAME_VALUE (x);\n   if (TREE_CODE (y) == SSA_NAME)\n-    prev_y = SSA_NAME_EQUIV (y);\n+    prev_y = SSA_NAME_VALUE (y);\n \n   /* If one of the previous values is invariant, then use that.\n      Otherwise it doesn't matter which value we choose, just so\n@@ -1509,7 +1527,7 @@ record_equality (tree x, tree y)\n     prev_x = x, x = y, y = prev_x, prev_x = prev_y;\n   else if (prev_x && TREE_INVARIANT (prev_x))\n     x = y, y = prev_x, prev_x = prev_y;\n-  else if (prev_y)\n+  else if (prev_y && TREE_CODE (prev_y) != VALUE_HANDLE)\n     y = prev_y;\n \n   /* After the swapping, we must have one SSA_NAME.  */\n@@ -2233,7 +2251,7 @@ cprop_into_successor_phis (basic_block bb, bitmap nonzero_vars)\n \n \t  /* If we have *ORIG_P in our constant/copy table, then replace\n \t     ORIG_P with its value in our constant/copy table.  */\n-\t  new = SSA_NAME_EQUIV (orig);\n+\t  new = SSA_NAME_VALUE (orig);\n \t  if (new\n \t      && (TREE_CODE (new) == SSA_NAME\n \t\t  || is_gimple_min_invariant (new))\n@@ -2378,7 +2396,7 @@ record_equivalences_from_stmt (tree stmt,\n       if (may_optimize_p\n \t  && (TREE_CODE (rhs) == SSA_NAME\n \t      || is_gimple_min_invariant (rhs)))\n-\tSET_SSA_NAME_EQUIV (lhs, rhs);\n+\tSSA_NAME_VALUE (lhs) = rhs;\n \n       /* alloca never returns zero and the address of a non-weak symbol\n \t is never zero.  NOP_EXPRs and CONVERT_EXPRs can be completely\n@@ -2500,8 +2518,8 @@ cprop_operand (tree stmt, use_operand_p op_p)\n   /* If the operand has a known constant value or it is known to be a\n      copy of some other variable, use the value or copy stored in\n      CONST_AND_COPIES.  */\n-  val = SSA_NAME_EQUIV (op);\n-  if (val)\n+  val = SSA_NAME_VALUE (op);\n+  if (val && TREE_CODE (val) != VALUE_HANDLE)\n     {\n       tree op_type, val_type;\n \n@@ -2886,8 +2904,8 @@ lookup_avail_expr (tree stmt, bool insert)\n      use the value from the const_and_copies table.  */\n   if (TREE_CODE (lhs) == SSA_NAME)\n     {\n-      temp = SSA_NAME_EQUIV (lhs);\n-      if (temp)\n+      temp = SSA_NAME_VALUE (lhs);\n+      if (temp && TREE_CODE (temp) != VALUE_HANDLE)\n \tlhs = temp;\n     }\n "}, {"sha": "bfe39f42dbdc95afd3a5e86e965d7e8fc04db4c4", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aecd08b530f563539bf75c35e78ab81032f217c/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aecd08b530f563539bf75c35e78ab81032f217c/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=3aecd08b530f563539bf75c35e78ab81032f217c", "patch": "@@ -1964,6 +1964,8 @@ static void\n fini_pre (void)\n {\n   basic_block bb;\n+  unsigned int i;\n+\n   bsi_commit_edge_inserts (NULL);\n \n   obstack_free (&grand_bitmap_obstack, NULL);\n@@ -1992,6 +1994,20 @@ fini_pre (void)\n     }\n \n   BITMAP_XFREE (need_eh_cleanup);\n+\n+  /* Wipe out pointers to VALUE_HANDLEs.  In the not terribly distant\n+     future we will want them to be persistent though.  */\n+  for (i = 0; i < num_ssa_names; i++)\n+    {\n+      tree name = ssa_name (i);\n+\n+      if (!name)\n+\tcontinue;\n+\n+      if (SSA_NAME_VALUE (name)\n+\t  && TREE_CODE (SSA_NAME_VALUE (name)) == VALUE_HANDLE)\n+\tSSA_NAME_VALUE (name) = NULL;\n+    }\n }\n \n "}, {"sha": "83dc19a6710a68b129148b3915bdde54ac924bcd", "filename": "gcc/tree.h", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aecd08b530f563539bf75c35e78ab81032f217c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aecd08b530f563539bf75c35e78ab81032f217c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=3aecd08b530f563539bf75c35e78ab81032f217c", "patch": "@@ -1312,20 +1312,6 @@ struct tree_exp GTY(())\n #define SSA_NAME_IN_FREE_LIST(NODE) \\\n     SSA_NAME_CHECK (NODE)->common.nothrow_flag\n \n-/* If NAME is equivalent to some other SSA_NAME or an invariant, then\n-   return the equivalent SSA_NAME or invariant, else return NULL.  */\n-#define SSA_NAME_EQUIV(NAME) __extension__ \\\n-  ({  tree equiv = SSA_NAME_CHECK (NAME)->ssa_name.equiv; \\\n-      if (equiv && TREE_CODE (equiv) == SSA_NAME) \\\n-\tequiv = ssa_name (SSA_NAME_VERSION (equiv)); \\\n-      equiv; \\\n-   })\n-\n-/* Record that NAME (an SSA_NAME) is equivalent to EQUIV.  */\n-\n-#define SET_SSA_NAME_EQUIV(NAME, EQUIV)\\\n-   SSA_NAME_CHECK (NAME)->ssa_name.equiv = (EQUIV);\n-\n /* Attributes for SSA_NAMEs for pointer-type variables.  */\n #define SSA_NAME_PTR_INFO(N) \\\n     SSA_NAME_CHECK (N)->ssa_name.ptr_info\n@@ -1357,8 +1343,12 @@ struct tree_ssa_name GTY(())\n   /* Pointer attributes used for alias analysis.  */\n   struct ptr_info_def *ptr_info;\n \n-  /* Value for SSA name used by GVN.  */\n-  tree GTY((skip)) value_handle;\n+  /* Value for SSA name used by various passes.\n+\n+     Right now only invariants are allowed to persist beyond a pass in\n+     this field; in the future we will allow VALUE_HANDLEs to persist\n+     as well.  */\n+  tree value_handle;\n \n   /* Auxiliary information stored with the ssa name.  */\n   PTR GTY((skip)) aux;"}]}