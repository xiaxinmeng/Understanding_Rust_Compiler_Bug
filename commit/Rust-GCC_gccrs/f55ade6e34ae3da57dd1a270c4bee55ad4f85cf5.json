{"sha": "f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjU1YWRlNmUzNGFlM2RhNTdkZDFhMjcwYzRiZWU1NWFkNGY4NWNmNQ==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2003-07-06T18:59:38Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2003-07-06T18:59:38Z"}, "message": "basic-block.h: Convert prototypes to ISO C90.\n\n\t* basic-block.h: Convert prototypes to ISO C90.\n\t* c-parse.in: Likewise.\n\t* c-pragma.h: Likewise.\n\t* c-typeck.c: Likewise.\n\t* cfghooks.h: Likewise.\n\t* cfgloopanal.c: Likewise.\n\t* dbxout.h: Likewise.\n\t* debug.h: Likewise.\n\t* dwarf2asm.h: Likewise.\n\t* gcov.c: Likewise.\n\t* gengtype-lex.l: Likewise.\n\t* sched-int.h: Likewise.\n\t* timevar.c: Likewise.\n\nFrom-SVN: r69010", "tree": {"sha": "76c547ec54bb4708e30224c15686141e4954541a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76c547ec54bb4708e30224c15686141e4954541a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5/comments", "author": null, "committer": null, "parents": [{"sha": "ade4289c2d5992197bc787e290cfdc3652ce9965", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ade4289c2d5992197bc787e290cfdc3652ce9965", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ade4289c2d5992197bc787e290cfdc3652ce9965"}], "stats": {"total": 987, "additions": 462, "deletions": 525}, "files": [{"sha": "0558fe81f5d87a0663a9ec6c4a52e1ff329ae558", "filename": "gcc/basic-block.h", "status": "modified", "additions": 134, "deletions": 154, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5", "patch": "@@ -72,7 +72,7 @@ typedef bitmap regset;\n #define REGNO_REG_SET_P(TO, REG) bitmap_bit_p (TO, REG)\n \n /* Copy the hard registers in a register set to the hard register set.  */\n-extern void reg_set_to_hard_reg_set PARAMS ((HARD_REG_SET *, bitmap));\n+extern void reg_set_to_hard_reg_set (HARD_REG_SET *, bitmap);\n #define REG_SET_TO_HARD_REG_SET(TO, FROM)\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n   CLEAR_HARD_REG_SET (TO);\t\t\t\t\t\t\\\n@@ -336,49 +336,44 @@ extern struct basic_block_def entry_exit_blocks[2];\n #define BLOCK_NUM(INSN)\t      (BLOCK_FOR_INSN (INSN)->index + 0)\n #define set_block_for_insn(INSN, BB)  (BLOCK_FOR_INSN (INSN) = BB)\n \n-extern void compute_bb_for_insn\t\tPARAMS ((void));\n-extern void free_bb_for_insn\t\tPARAMS ((void));\n-extern void update_bb_for_insn\t\tPARAMS ((basic_block));\n+extern void compute_bb_for_insn (void);\n+extern void free_bb_for_insn (void);\n+extern void update_bb_for_insn (basic_block);\n \n-extern void free_basic_block_vars\tPARAMS ((int));\n+extern void free_basic_block_vars (int);\n \n-extern void insert_insn_on_edge\t\tPARAMS ((rtx, edge));\n+extern void insert_insn_on_edge (rtx, edge);\n bool safe_insert_insn_on_edge (rtx, edge);\n \n-extern void commit_edge_insertions\tPARAMS ((void));\n-extern void commit_edge_insertions_watch_calls\tPARAMS ((void));\n-\n-extern void remove_fake_edges\t\tPARAMS ((void));\n-extern void add_noreturn_fake_exit_edges\tPARAMS ((void));\n-extern void connect_infinite_loops_to_exit\tPARAMS ((void));\n-extern int flow_call_edges_add\t\tPARAMS ((sbitmap));\n-extern edge unchecked_make_edge\t\tPARAMS ((basic_block,\n-\t\t\t\t\t\t basic_block, int));\n-extern edge cached_make_edge\t\tPARAMS ((sbitmap *, basic_block,\n-\t\t\t\t\t\t basic_block, int));\n-extern edge make_edge\t\t\tPARAMS ((basic_block,\n-\t\t\t\t\t\t basic_block, int));\n-extern edge make_single_succ_edge\tPARAMS ((basic_block,\n-\t\t\t\t\t\t basic_block, int));\n-extern void remove_edge\t\t\tPARAMS ((edge));\n-extern void redirect_edge_succ\t\tPARAMS ((edge, basic_block));\n-extern edge redirect_edge_succ_nodup\tPARAMS ((edge, basic_block));\n-extern void redirect_edge_pred\t\tPARAMS ((edge, basic_block));\n-extern basic_block create_basic_block_structure PARAMS ((rtx, rtx, rtx, basic_block));\n-extern void clear_bb_flags\t\tPARAMS ((void));\n-extern void tidy_fallthru_edge\t\tPARAMS ((edge, basic_block,\n-\t\t\t\t\t\t basic_block));\n-extern void tidy_fallthru_edges\t\tPARAMS ((void));\n-extern void flow_reverse_top_sort_order_compute\tPARAMS ((int *));\n-extern int flow_depth_first_order_compute\tPARAMS ((int *, int *));\n-extern void flow_preorder_transversal_compute\tPARAMS ((int *));\n-extern int dfs_enumerate_from\t\tPARAMS ((basic_block, int,\n-\t\t\t\t\t\tbool (*)(basic_block, void *),\n-\t\t\t\t\t\tbasic_block *, int, void *));\n-extern void dump_edge_info\t\tPARAMS ((FILE *, edge, int));\n-extern void clear_edges\t\t\tPARAMS ((void));\n-extern void mark_critical_edges\t\tPARAMS ((void));\n-extern rtx first_insn_after_basic_block_note\tPARAMS ((basic_block));\n+extern void commit_edge_insertions (void);\n+extern void commit_edge_insertions_watch_calls (void);\n+\n+extern void remove_fake_edges (void);\n+extern void add_noreturn_fake_exit_edges (void);\n+extern void connect_infinite_loops_to_exit (void);\n+extern int flow_call_edges_add (sbitmap);\n+extern edge unchecked_make_edge (basic_block, basic_block, int);\n+extern edge cached_make_edge (sbitmap *, basic_block, basic_block, int);\n+extern edge make_edge (basic_block, basic_block, int);\n+extern edge make_single_succ_edge (basic_block, basic_block, int);\n+extern void remove_edge (edge);\n+extern void redirect_edge_succ (edge, basic_block);\n+extern edge redirect_edge_succ_nodup (edge, basic_block);\n+extern void redirect_edge_pred (edge, basic_block);\n+extern basic_block create_basic_block_structure (rtx, rtx, rtx, basic_block);\n+extern void clear_bb_flags (void);\n+extern void tidy_fallthru_edge (edge, basic_block, basic_block);\n+extern void tidy_fallthru_edges (void);\n+extern void flow_reverse_top_sort_order_compute (int *);\n+extern int flow_depth_first_order_compute (int *, int *);\n+extern void flow_preorder_transversal_compute (int *);\n+extern int dfs_enumerate_from (basic_block, int,\n+\t\t\t       bool (*)(basic_block, void *),\n+\t\t\t       basic_block *, int, void *);\n+extern void dump_edge_info (FILE *, edge, int);\n+extern void clear_edges (void);\n+extern void mark_critical_edges (void);\n+extern rtx first_insn_after_basic_block_note (basic_block);\n \n /* Dominator information for basic blocks.  */\n \n@@ -455,12 +450,11 @@ struct edge_list\n #define EDGE_CRITICAL_P(e)\t\t((e)->src->succ->succ_next \\\n \t\t\t\t\t && (e)->dest->pred->pred_next)\n \n-struct edge_list * create_edge_list\tPARAMS ((void));\n-void free_edge_list\t\t\tPARAMS ((struct edge_list *));\n-void print_edge_list\t\t\tPARAMS ((FILE *, struct edge_list *));\n-void verify_edge_list\t\t\tPARAMS ((FILE *, struct edge_list *));\n-int find_edge_index\t\t\tPARAMS ((struct edge_list *,\n-\t\t\t\t\t\t basic_block, basic_block));\n+struct edge_list * create_edge_list (void);\n+void free_edge_list (struct edge_list *);\n+void print_edge_list (FILE *, struct edge_list *);\n+void verify_edge_list (FILE *, struct edge_list *);\n+int find_edge_index (struct edge_list *, basic_block, basic_block);\n \n \n enum update_life_extent\n@@ -502,123 +496,110 @@ enum update_life_extent\n #define CLEANUP_NO_INSN_DEL\t128\t/* Do not try to delete trivially dead\n \t\t\t\t\t   insns.  */\n #define CLEANUP_CFGLAYOUT\t256\t/* Do cleanup in cfglayout mode.  */\n-extern void life_analysis\tPARAMS ((rtx, FILE *, int));\n-extern int update_life_info\tPARAMS ((sbitmap, enum update_life_extent,\n-\t\t\t\t\t int));\n-extern int update_life_info_in_dirty_blocks PARAMS ((enum update_life_extent,\n-\t\t\t\t\t\t      int));\n-extern int count_or_remove_death_notes\tPARAMS ((sbitmap, int));\n-extern int propagate_block\tPARAMS ((basic_block, regset, regset, regset,\n-\t\t\t\t\t int));\n+extern void life_analysis (rtx, FILE *, int);\n+extern int update_life_info (sbitmap, enum update_life_extent, int);\n+extern int update_life_info_in_dirty_blocks (enum update_life_extent, int);\n+extern int count_or_remove_death_notes (sbitmap, int);\n+extern int propagate_block (basic_block, regset, regset, regset, int);\n \n struct propagate_block_info;\n-extern rtx propagate_one_insn\tPARAMS ((struct propagate_block_info *, rtx));\n+extern rtx propagate_one_insn (struct propagate_block_info *, rtx);\n extern struct propagate_block_info *init_propagate_block_info\n-  PARAMS ((basic_block, regset, regset, regset, int));\n-extern void free_propagate_block_info PARAMS ((struct propagate_block_info *));\n+ (basic_block, regset, regset, regset, int);\n+extern void free_propagate_block_info (struct propagate_block_info *);\n \n /* In lcm.c */\n-extern struct edge_list *pre_edge_lcm\tPARAMS ((FILE *, int, sbitmap *,\n-\t\t\t\t\t\t sbitmap *, sbitmap *,\n-\t\t\t\t\t\t sbitmap *, sbitmap **,\n-\t\t\t\t\t\t sbitmap **));\n-extern struct edge_list *pre_edge_rev_lcm PARAMS ((FILE *, int, sbitmap *,\n-\t\t\t\t\t\t   sbitmap *, sbitmap *,\n-\t\t\t\t\t\t   sbitmap *, sbitmap **,\n-\t\t\t\t\t\t   sbitmap **));\n-extern void compute_available\t\tPARAMS ((sbitmap *, sbitmap *,\n-\t\t\t\t\t\t sbitmap *, sbitmap *));\n-extern int optimize_mode_switching\tPARAMS ((FILE *));\n+extern struct edge_list *pre_edge_lcm (FILE *, int, sbitmap *, sbitmap *,\n+\t\t\t\t       sbitmap *, sbitmap *, sbitmap **,\n+\t\t\t\t       sbitmap **);\n+extern struct edge_list *pre_edge_rev_lcm (FILE *, int, sbitmap *,\n+\t\t\t\t\t   sbitmap *, sbitmap *,\n+\t\t\t\t\t   sbitmap *, sbitmap **,\n+\t\t\t\t\t   sbitmap **);\n+extern void compute_available (sbitmap *, sbitmap *, sbitmap *, sbitmap *);\n+extern int optimize_mode_switching (FILE *);\n \n /* In emit-rtl.c.  */\n-extern rtx emit_block_insn_after\tPARAMS ((rtx, rtx, basic_block));\n-extern rtx emit_block_insn_before\tPARAMS ((rtx, rtx, basic_block));\n+extern rtx emit_block_insn_after (rtx, rtx, basic_block);\n+extern rtx emit_block_insn_before (rtx, rtx, basic_block);\n \n /* In predict.c */\n-extern void estimate_probability        PARAMS ((struct loops *));\n-extern void note_prediction_to_br_prob\tPARAMS ((void));\n-extern void expected_value_to_br_prob\tPARAMS ((void));\n-extern bool maybe_hot_bb_p\t\tPARAMS ((basic_block));\n-extern bool probably_cold_bb_p\t\tPARAMS ((basic_block));\n-extern bool probably_never_executed_bb_p PARAMS ((basic_block));\n+extern void estimate_probability (struct loops *);\n+extern void note_prediction_to_br_prob (void);\n+extern void expected_value_to_br_prob (void);\n+extern bool maybe_hot_bb_p (basic_block);\n+extern bool probably_cold_bb_p (basic_block);\n+extern bool probably_never_executed_bb_p (basic_block);\n \n /* In flow.c */\n-extern void init_flow                   PARAMS ((void));\n-extern void dump_bb\t\t\tPARAMS ((basic_block, FILE *));\n-extern void debug_bb\t\t\tPARAMS ((basic_block));\n-extern basic_block debug_bb_n\t\tPARAMS ((int));\n-extern void dump_regset\t\t\tPARAMS ((regset, FILE *));\n-extern void debug_regset\t\tPARAMS ((regset));\n-extern void allocate_reg_life_data      PARAMS ((void));\n-extern void allocate_bb_life_data\tPARAMS ((void));\n-extern void expunge_block\t\tPARAMS ((basic_block));\n-extern void link_block\t\t\tPARAMS ((basic_block, basic_block));\n-extern void unlink_block\t\tPARAMS ((basic_block));\n-extern void compact_blocks\t\tPARAMS ((void));\n-extern basic_block alloc_block\t\tPARAMS ((void));\n-extern void find_unreachable_blocks\tPARAMS ((void));\n-extern int delete_noop_moves\t\tPARAMS ((rtx));\n-extern basic_block force_nonfallthru\tPARAMS ((edge));\n-extern rtx block_label\t\t\tPARAMS ((basic_block));\n-extern bool forwarder_block_p\t\tPARAMS ((basic_block));\n-extern bool purge_all_dead_edges\tPARAMS ((int));\n-extern bool purge_dead_edges\t\tPARAMS ((basic_block));\n-extern void find_sub_basic_blocks\tPARAMS ((basic_block));\n-extern void find_many_sub_basic_blocks\tPARAMS ((sbitmap));\n-extern bool can_fallthru\t\tPARAMS ((basic_block, basic_block));\n-extern void flow_nodes_print\t\tPARAMS ((const char *, const sbitmap,\n-\t\t\t\t\t\t FILE *));\n-extern void flow_edge_list_print\tPARAMS ((const char *, const edge *,\n-\t\t\t\t\t\t int, FILE *));\n-extern void alloc_aux_for_block\t\tPARAMS ((basic_block, int));\n-extern void alloc_aux_for_blocks\tPARAMS ((int));\n-extern void clear_aux_for_blocks\tPARAMS ((void));\n-extern void free_aux_for_blocks\t\tPARAMS ((void));\n-extern void alloc_aux_for_edge\t\tPARAMS ((edge, int));\n-extern void alloc_aux_for_edges\t\tPARAMS ((int));\n-extern void clear_aux_for_edges\t\tPARAMS ((void));\n-extern void free_aux_for_edges\t\tPARAMS ((void));\n+extern void init_flow (void);\n+extern void dump_bb (basic_block, FILE *);\n+extern void debug_bb (basic_block);\n+extern basic_block debug_bb_n (int);\n+extern void dump_regset (regset, FILE *);\n+extern void debug_regset (regset);\n+extern void allocate_reg_life_data (void);\n+extern void allocate_bb_life_data (void);\n+extern void expunge_block (basic_block);\n+extern void link_block (basic_block, basic_block);\n+extern void unlink_block (basic_block);\n+extern void compact_blocks (void);\n+extern basic_block alloc_block (void);\n+extern void find_unreachable_blocks (void);\n+extern int delete_noop_moves (rtx);\n+extern basic_block force_nonfallthru (edge);\n+extern rtx block_label (basic_block);\n+extern bool forwarder_block_p (basic_block);\n+extern bool purge_all_dead_edges (int);\n+extern bool purge_dead_edges (basic_block);\n+extern void find_sub_basic_blocks (basic_block);\n+extern void find_many_sub_basic_blocks (sbitmap);\n+extern bool can_fallthru (basic_block, basic_block);\n+extern void flow_nodes_print (const char *, const sbitmap, FILE *);\n+extern void flow_edge_list_print (const char *, const edge *, int, FILE *);\n+extern void alloc_aux_for_block (basic_block, int);\n+extern void alloc_aux_for_blocks (int);\n+extern void clear_aux_for_blocks (void);\n+extern void free_aux_for_blocks (void);\n+extern void alloc_aux_for_edge (edge, int);\n+extern void alloc_aux_for_edges (int);\n+extern void clear_aux_for_edges (void);\n+extern void free_aux_for_edges (void);\n \n /* This function is always defined so it can be called from the\n    debugger, and it is declared extern so we don't get warnings about\n    it being unused.  */\n-extern void verify_flow_info\t\tPARAMS ((void));\n+extern void verify_flow_info (void);\n \n typedef struct conflict_graph_def *conflict_graph;\n \n /* Callback function when enumerating conflicts.  The arguments are\n    the smaller and larger regno in the conflict.  Returns zero if\n    enumeration is to continue, nonzero to halt enumeration.  */\n-typedef int (*conflict_graph_enum_fn) PARAMS ((int, int, void *));\n+typedef int (*conflict_graph_enum_fn) (int, int, void *);\n \n \n /* Prototypes of operations on conflict graphs.  */\n \n extern conflict_graph conflict_graph_new\n-                                        PARAMS ((int));\n-extern void conflict_graph_delete       PARAMS ((conflict_graph));\n-extern int conflict_graph_add           PARAMS ((conflict_graph,\n-\t\t\t\t\t\t int, int));\n-extern int conflict_graph_conflict_p    PARAMS ((conflict_graph,\n-\t\t\t\t\t\t int, int));\n-extern void conflict_graph_enum         PARAMS ((conflict_graph, int,\n-\t\t\t\t\t\t conflict_graph_enum_fn,\n-\t\t\t\t\t\t void *));\n-extern void conflict_graph_merge_regs   PARAMS ((conflict_graph, int,\n-\t\t\t\t\t\t int));\n-extern void conflict_graph_print        PARAMS ((conflict_graph, FILE*));\n-extern conflict_graph conflict_graph_compute\n-                                        PARAMS ((regset,\n-\t\t\t\t\t\t partition));\n-extern bool mark_dfs_back_edges\t\tPARAMS ((void));\n-extern void set_edge_can_fallthru_flag\tPARAMS ((void));\n-extern void update_br_prob_note\t\tPARAMS ((basic_block));\n-extern void fixup_abnormal_edges\tPARAMS ((void));\n-extern bool can_hoist_insn_p\t\tPARAMS ((rtx, rtx, regset));\n-extern rtx hoist_insn_after\t\tPARAMS ((rtx, rtx, rtx, rtx));\n-extern rtx hoist_insn_to_edge\t\tPARAMS ((rtx, edge, rtx, rtx));\n-extern bool inside_basic_block_p\tPARAMS ((rtx));\n-extern bool control_flow_insn_p\t\tPARAMS ((rtx));\n+ (int);\n+extern void conflict_graph_delete (conflict_graph);\n+extern int conflict_graph_add (conflict_graph, int, int);\n+extern int conflict_graph_conflict_p (conflict_graph, int, int);\n+extern void conflict_graph_enum (conflict_graph, int, conflict_graph_enum_fn,\n+\t\t\t\t void *);\n+extern void conflict_graph_merge_regs (conflict_graph, int, int);\n+extern void conflict_graph_print (conflict_graph, FILE*);\n+extern conflict_graph conflict_graph_compute (regset, partition);\n+extern bool mark_dfs_back_edges (void);\n+extern void set_edge_can_fallthru_flag (void);\n+extern void update_br_prob_note (basic_block);\n+extern void fixup_abnormal_edges (void);\n+extern bool can_hoist_insn_p (rtx, rtx, regset);\n+extern rtx hoist_insn_after (rtx, rtx, rtx, rtx);\n+extern rtx hoist_insn_to_edge (rtx, edge, rtx, rtx);\n+extern bool inside_basic_block_p (rtx);\n+extern bool control_flow_insn_p (rtx);\n \n /* In bb-reorder.c */\n extern void reorder_basic_blocks (void);\n@@ -631,23 +612,22 @@ enum cdi_direction\n   CDI_POST_DOMINATORS\n };\n \n-extern dominance_info calculate_dominance_info\tPARAMS ((enum cdi_direction));\n-extern void free_dominance_info\t\t\tPARAMS ((dominance_info));\n-extern basic_block nearest_common_dominator\tPARAMS ((dominance_info,\n-\t\t\t\t\t\t basic_block, basic_block));\n-extern void set_immediate_dominator\tPARAMS ((dominance_info,\n-\t\t\t\t\t\t basic_block, basic_block));\n-extern basic_block get_immediate_dominator\tPARAMS ((dominance_info,\n-\t\t\t\t\t\t basic_block));\n-extern bool dominated_by_p\tPARAMS ((dominance_info, basic_block, basic_block));\n-extern int get_dominated_by PARAMS ((dominance_info, basic_block, basic_block **));\n-extern void add_to_dominance_info PARAMS ((dominance_info, basic_block));\n-extern void delete_from_dominance_info PARAMS ((dominance_info, basic_block));\n-basic_block recount_dominator PARAMS ((dominance_info, basic_block));\n-extern void redirect_immediate_dominators PARAMS ((dominance_info, basic_block,\n-\t\t\t\t\t\t basic_block));\n-void iterate_fix_dominators PARAMS ((dominance_info, basic_block *, int));\n-extern void verify_dominators PARAMS ((dominance_info));\n+extern dominance_info calculate_dominance_info (enum cdi_direction);\n+extern void free_dominance_info (dominance_info);\n+extern basic_block nearest_common_dominator (dominance_info,\n+\t\t\t\t\t     basic_block, basic_block);\n+extern void set_immediate_dominator (dominance_info, basic_block,\n+\t\t\t\t     basic_block);\n+extern basic_block get_immediate_dominator (dominance_info, basic_block);\n+extern bool dominated_by_p (dominance_info, basic_block, basic_block);\n+extern int get_dominated_by (dominance_info, basic_block, basic_block **);\n+extern void add_to_dominance_info (dominance_info, basic_block);\n+extern void delete_from_dominance_info (dominance_info, basic_block);\n+basic_block recount_dominator (dominance_info, basic_block);\n+extern void redirect_immediate_dominators (dominance_info, basic_block,\n+\t\t\t\t\t   basic_block);\n+void iterate_fix_dominators (dominance_info, basic_block *, int);\n+extern void verify_dominators (dominance_info);\n \n #include \"cfghooks.h\"\n "}, {"sha": "bcfb0248c3a0b88a3b6a4281ec3b2f9bd00192ed", "filename": "gcc/c-parse.in", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5", "patch": "@@ -332,16 +332,16 @@ static bool parsing_iso_function_signature;\n \n #define YYPRINT(FILE,YYCHAR,YYLVAL) yyprint(FILE,YYCHAR,YYLVAL)\n \n-static void yyprint\t  PARAMS ((FILE *, int, YYSTYPE));\n-static void yyerror\t  PARAMS ((const char *));\n-static int yylexname\t  PARAMS ((void));\n-static inline int _yylex  PARAMS ((void));\n-static int  yylex\t  PARAMS ((void));\n-static void init_reswords PARAMS ((void));\n+static void yyprint (FILE *, int, YYSTYPE);\n+static void yyerror (const char *);\n+static int yylexname (void);\n+static inline int _yylex (void);\n+static int  yylex (void);\n+static void init_reswords (void);\n \n   /* Initialisation routine for this file.  */\n void\n-c_parse_init ()\n+c_parse_init (void)\n {\n   init_reswords ();\n }\n@@ -3526,7 +3526,7 @@ static const short rid_to_yy[RID_MAX] =\n };\n \n static void\n-init_reswords ()\n+init_reswords (void)\n {\n   unsigned int i;\n   tree id;\n@@ -3554,8 +3554,7 @@ init_reswords ()\n #define NAME(type) cpp_type2name (type)\n \n static void\n-yyerror (msgid)\n-     const char *msgid;\n+yyerror (const char *msgid)\n {\n   const char *string = _(msgid);\n \n@@ -3582,7 +3581,7 @@ yyerror (msgid)\n }\n \n static int\n-yylexname ()\n+yylexname (void)\n {\n   tree decl;\n \n@@ -3641,7 +3640,7 @@ end ifobjc\n }\n \n static inline int\n-_yylex ()\n+_yylex (void)\n {\n  get_next:\n   last_token = c_lex (&yylval.ttype);\n@@ -3745,7 +3744,7 @@ _yylex ()\n }\n \n static int\n-yylex()\n+yylex (void)\n {\n   int r;\n   timevar_push (TV_LEX);\n@@ -3757,10 +3756,7 @@ yylex()\n /* Function used when yydebug is set, to print a token in more detail.  */\n \n static void\n-yyprint (file, yychar, yyl)\n-     FILE *file;\n-     int yychar;\n-     YYSTYPE yyl;\n+yyprint (FILE *file, int yychar, YYSTYPE yyl)\n {\n   tree t = yyl.ttype;\n \n@@ -3797,7 +3793,7 @@ yyprint (file, yychar, yyl)\n /* Free malloced parser stacks if necessary.  */\n \n void\n-free_parser_stacks ()\n+free_parser_stacks (void)\n {\n   if (malloced_yyss)\n     {"}, {"sha": "b14a0c4738c275d01f026471b64a4ccf8205b022", "filename": "gcc/c-pragma.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5/gcc%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5/gcc%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.h?ref=f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5", "patch": "@@ -51,9 +51,8 @@ extern void init_pragma (void);\n \n /* Front-end wrapper for pragma registration to avoid dragging\n    cpplib.h in almost everywhere.  */\n-extern void c_register_pragma\n-\tPARAMS ((const char *, const char *,\n-\t\t void (*) (struct cpp_reader *)));\n+extern void c_register_pragma (const char *, const char *,\n+\t\t\t       void (*) (struct cpp_reader *));\n extern void maybe_apply_pragma_weak (tree);\n extern tree maybe_apply_renaming_pragma (tree, tree);\n extern void add_to_renaming_pragma_list (tree, tree);"}, {"sha": "718bd8f59862c0d335919392cd131e7190701734", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 40, "deletions": 37, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5", "patch": "@@ -52,39 +52,38 @@ static int missing_braces_mentioned;\n /* 1 if we explained undeclared var errors.  */\n static int undeclared_variable_notice;\n \n-static tree qualify_type\t\tPARAMS ((tree, tree));\n-static int comp_target_types\t\tPARAMS ((tree, tree, int));\n-static int function_types_compatible_p\tPARAMS ((tree, tree));\n-static int type_lists_compatible_p\tPARAMS ((tree, tree));\n-static tree decl_constant_value_for_broken_optimization PARAMS ((tree));\n-static tree default_function_array_conversion\tPARAMS ((tree));\n-static tree lookup_field\t\tPARAMS ((tree, tree));\n-static void undeclared_variable\t\tPARAMS ((tree));\n-static tree convert_arguments\t\tPARAMS ((tree, tree, tree, tree));\n-static tree pointer_diff\t\tPARAMS ((tree, tree));\n-static tree unary_complex_lvalue\tPARAMS ((enum tree_code, tree, int));\n-static void pedantic_lvalue_warning\tPARAMS ((enum tree_code));\n-static tree internal_build_compound_expr PARAMS ((tree, int));\n-static tree convert_for_assignment\tPARAMS ((tree, tree, const char *,\n-\t\t\t\t\t\t tree, tree, int));\n-static void warn_for_assignment\t\tPARAMS ((const char *, const char *,\n-\t\t\t\t\t\t tree, int));\n-static tree valid_compound_expr_initializer PARAMS ((tree, tree));\n-static void push_string\t\t\tPARAMS ((const char *));\n-static void push_member_name\t\tPARAMS ((tree));\n-static void push_array_bounds\t\tPARAMS ((int));\n-static int spelling_length\t\tPARAMS ((void));\n-static char *print_spelling\t\tPARAMS ((char *));\n-static void warning_init\t\tPARAMS ((const char *));\n-static tree digest_init\t\t\tPARAMS ((tree, tree, int));\n-static void output_init_element\t\tPARAMS ((tree, tree, tree, int));\n-static void output_pending_init_elements PARAMS ((int));\n-static int set_designator\t\tPARAMS ((int));\n-static void push_range_stack\t\tPARAMS ((tree));\n-static void add_pending_init\t\tPARAMS ((tree, tree));\n-static void set_nonincremental_init\tPARAMS ((void));\n-static void set_nonincremental_init_from_string\tPARAMS ((tree));\n-static tree find_init_member\t\tPARAMS ((tree));\n+static tree qualify_type (tree, tree);\n+static int comp_target_types (tree, tree, int);\n+static int function_types_compatible_p (tree, tree);\n+static int type_lists_compatible_p (tree, tree);\n+static tree decl_constant_value_for_broken_optimization (tree);\n+static tree default_function_array_conversion (tree);\n+static tree lookup_field (tree, tree);\n+static void undeclared_variable (tree);\n+static tree convert_arguments (tree, tree, tree, tree);\n+static tree pointer_diff (tree, tree);\n+static tree unary_complex_lvalue (enum tree_code, tree, int);\n+static void pedantic_lvalue_warning (enum tree_code);\n+static tree internal_build_compound_expr (tree, int);\n+static tree convert_for_assignment (tree, tree, const char *, tree, tree,\n+\t\t\t\t    int);\n+static void warn_for_assignment (const char *, const char *, tree, int);\n+static tree valid_compound_expr_initializer (tree, tree);\n+static void push_string (const char *);\n+static void push_member_name (tree);\n+static void push_array_bounds (int);\n+static int spelling_length (void);\n+static char *print_spelling (char *);\n+static void warning_init (const char *);\n+static tree digest_init (tree, tree, int);\n+static void output_init_element (tree, tree, tree, int);\n+static void output_pending_init_elements (int);\n+static int set_designator (int);\n+static void push_range_stack (tree);\n+static void add_pending_init (tree, tree);\n+static void set_nonincremental_init (void);\n+static void set_nonincremental_init_from_string (tree);\n+static tree find_init_member (tree);\n \f\n /* Do `exp = require_complete_type (exp);' to make sure exp\n    does not have an incomplete type.  (That includes void types.)  */\n@@ -1859,7 +1858,8 @@ parser_build_binary_op (enum tree_code code, tree arg1, tree arg2)\n    the arithmetic is to be done.  */\n \n tree\n-build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1, int convert_p)\n+build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n+\t\t int convert_p)\n {\n   tree type0, type1;\n   enum tree_code code0, code1;\n@@ -3872,7 +3872,8 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n    PARMNUM is the number of the argument, for printing in error messages.  */\n \n static tree\n-convert_for_assignment (tree type, tree rhs, const char *errtype, tree fundecl, tree funname, int parmnum)\n+convert_for_assignment (tree type, tree rhs, const char *errtype,\n+\t\t\ttree fundecl, tree funname, int parmnum)\n {\n   enum tree_code codel = TREE_CODE (type);\n   tree rhstype;\n@@ -4194,7 +4195,8 @@ c_convert_parm_for_inlining (tree parm, tree value, tree fn)\n    Objective-C selector.  */\n \n static void\n-warn_for_assignment (const char *msgid, const char *opname, tree function, int argnum)\n+warn_for_assignment (const char *msgid, const char *opname, tree function,\n+\t\t     int argnum)\n {\n   if (opname == 0)\n     {\n@@ -6703,7 +6705,8 @@ simple_asm_stmt (tree expr)\n    STRING, some OUTPUTS, some INPUTS, and some CLOBBERS.  */\n \n tree\n-build_asm_stmt (tree cv_qualifier, tree string, tree outputs, tree inputs, tree clobbers)\n+build_asm_stmt (tree cv_qualifier, tree string, tree outputs, tree inputs,\n+\t\ttree clobbers)\n {\n   tree tail;\n "}, {"sha": "37457deff8bec1cc456be8cbd1d23046d0d92370", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5", "patch": "@@ -32,7 +32,7 @@ struct cfg_hooks\n   /* Basic CFG manipulation.  */\n \n   /* Return new basic block */\n-  basic_block (*create_basic_block)\tPARAMS ((void *head, void *end, basic_block after));\n+  basic_block (*create_basic_block) (void *head, void *end, basic_block after);\n \n   /* Redirect edge E to the given basic block B and update underlying program\n      representation.  Returns false when edge is not easily redirectable for\n@@ -51,10 +51,10 @@ struct cfg_hooks\n   edge (*split_block) (basic_block b, void * i);\n \n   /* Return true when blocks A and B can be merged into single basic block.  */\n-  bool (*can_merge_blocks_p)\t\tPARAMS ((basic_block a, basic_block b));\n+  bool (*can_merge_blocks_p) (basic_block a, basic_block b);\n \n   /* Merge blocks A and B.  */\n-  void (*merge_blocks)\t\t\tPARAMS ((basic_block a, basic_block b));\n+  void (*merge_blocks) (basic_block a, basic_block b);\n \n   /* Higher level functions representable by primitive operations above if\n      we didn't have some oddities in RTL and Tree representations.  */"}, {"sha": "5502844ce4ff688bd8077f12f8e98be5e8dd4086", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5", "patch": "@@ -96,7 +96,7 @@ blocks_invariant_registers (basic_block *bbs, int nbbs, regset regs)\n \t insn = NEXT_INSN (insn))\n       if (INSN_P (insn))\n \tnote_stores (PATTERN (insn),\n-\t\t     (void (*) PARAMS ((rtx, rtx, void *))) unmark_altered,\n+\t\t     (void (*) (rtx, rtx, void *)) unmark_altered,\n \t\t     regs);\n }\n \n@@ -158,7 +158,7 @@ blocks_single_set_registers (basic_block *bbs, int nbbs, rtx *regs)\n \t  continue;\n \tdata.insn = insn;\n \tnote_stores (PATTERN (insn),\n-\t    (void (*) PARAMS ((rtx, rtx, void *))) unmark_altered_insn,\n+\t    (void (*) (rtx, rtx, void *)) unmark_altered_insn,\n \t    &data);\n       }\n }\n@@ -332,7 +332,7 @@ variable_initial_value (rtx insn, regset invariant_regs, rtx var, rtx *set_insn)\n \t{\n \t  if (INSN_P (insn))\n \t    note_stores (PATTERN (insn),\n-\t\t(void (*) PARAMS ((rtx, rtx, void *))) unmark_altered,\n+\t\t(void (*) (rtx, rtx, void *)) unmark_altered,\n \t\tinvariant_regs);\n \t  if (modified_between_p (var, PREV_INSN (insn), NEXT_INSN (insn)))\n \t    break;"}, {"sha": "bf0e741fe4579db92b01bda339d9287ac1829be2", "filename": "gcc/dbxout.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5/gcc%2Fdbxout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5/gcc%2Fdbxout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.h?ref=f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5", "patch": "@@ -1,5 +1,6 @@\n /* dbxout.h - Various declarations for functions found in dbxout.c\n-   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2003\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -18,7 +19,7 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n-extern int dbxout_symbol\t\tPARAMS ((tree, int));\n-extern void dbxout_parms\t\tPARAMS ((tree));\n-extern void dbxout_reg_parms\t\tPARAMS ((tree));\n-extern int dbxout_syms\t\t\tPARAMS ((tree));\n+extern int dbxout_symbol (tree, int);\n+extern void dbxout_parms (tree);\n+extern void dbxout_reg_parms (tree);\n+extern int dbxout_syms (tree);"}, {"sha": "22d837835c627ded14af552dd520811494c2e0c3", "filename": "gcc/debug.h", "status": "modified", "additions": 39, "deletions": 47, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5/gcc%2Fdebug.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5/gcc%2Fdebug.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdebug.h?ref=f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5", "patch": "@@ -1,5 +1,5 @@\n /* Debug hooks for GCC.\n-   Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -25,107 +25,99 @@ struct gcc_debug_hooks\n {\n   /* Initialize debug output.  MAIN_FILENAME is the name of the main\n      input file.  */\n-  void (* init) PARAMS ((const char *main_filename));\n+  void (* init) (const char *main_filename);\n \n   /* Output debug symbols.  */\n-  void (* finish) PARAMS ((const char *main_filename));\n+  void (* finish) (const char *main_filename);\n \n   /* Macro defined on line LINE with name and expansion TEXT.  */\n-  void (* define) PARAMS ((unsigned int line, const char *text));\n+  void (* define) (unsigned int line, const char *text);\n \n   /* MACRO undefined on line LINE.  */\n-  void (* undef) PARAMS ((unsigned int line, const char *macro));\n+  void (* undef) (unsigned int line, const char *macro);\n \n   /* Record the beginning of a new source file FILE from LINE number\n      in the previous one.  */\n-  void (* start_source_file) PARAMS ((unsigned int line, const char *file));\n+  void (* start_source_file) (unsigned int line, const char *file);\n \n   /* Record the resumption of a source file.  LINE is the line number\n      in the source file we are returning to.  */\n-  void (* end_source_file) PARAMS ((unsigned int line));\n+  void (* end_source_file) (unsigned int line);\n \n   /* Record the beginning of block N, counting from 1 and not\n      including the function-scope block, at LINE.  */\n-  void (* begin_block) PARAMS ((unsigned int line, unsigned int n));\n+  void (* begin_block) (unsigned int line, unsigned int n);\n \n   /* Record the end of a block.  Arguments as for begin_block.  */\n-  void (* end_block) PARAMS ((unsigned int line, unsigned int n));\n+  void (* end_block) (unsigned int line, unsigned int n);\n \n   /* Returns nonzero if it is appropriate not to emit any debugging\n      information for BLOCK, because it doesn't contain any\n      instructions.  This may not be the case for blocks containing\n      nested functions, since we may actually call such a function even\n      though the BLOCK information is messed up.  Defaults to true.  */\n-  bool (* ignore_block) PARAMS ((tree));\n+  bool (* ignore_block) (tree);\n \n   /* Record a source file location at (FILE, LINE).  */\n-  void (* source_line) PARAMS ((unsigned int line, const char *file));\n+  void (* source_line) (unsigned int line, const char *file);\n \n   /* Called at start of prologue code.  LINE is the first line in the\n      function.  This has been given the same prototype as source_line,\n      so that the source_line hook can be substituted if appropriate.  */\n-  void (* begin_prologue) PARAMS ((unsigned int line, const char *file));\n+  void (* begin_prologue) (unsigned int line, const char *file);\n \n   /* Called at end of prologue code.  LINE is the first line in the\n      function.  */\n-  void (* end_prologue) PARAMS ((unsigned int line, const char *file));\n+  void (* end_prologue) (unsigned int line, const char *file);\n \n   /* Record end of epilogue code.  */\n-  void (* end_epilogue) PARAMS ((unsigned int line, const char *file));\n+  void (* end_epilogue) (unsigned int line, const char *file);\n \n   /* Called at start of function DECL, before it is declared.  */\n-  void (* begin_function) PARAMS ((tree decl));\n+  void (* begin_function) (tree decl);\n \n   /* Record end of function.  LINE is highest line number in function.  */\n-  void (* end_function) PARAMS ((unsigned int line));\n+  void (* end_function) (unsigned int line);\n \n   /* Debug information for a function DECL.  This might include the\n      function name (a symbol), its parameters, and the block that\n      makes up the function's body, and the local variables of the\n      function.  */\n-  void (* function_decl) PARAMS ((tree decl));\n+  void (* function_decl) (tree decl);\n \n   /* Debug information for a global DECL.  Called from toplev.c after\n      compilation proper has finished.  */\n-  void (* global_decl) PARAMS ((tree decl));\n+  void (* global_decl) (tree decl);\n \n   /* DECL is an inline function, whose body is present, but which is\n      not being output at this point.  */\n-  void (* deferred_inline_function) PARAMS ((tree decl));\n+  void (* deferred_inline_function) (tree decl);\n \n   /* DECL is an inline function which is about to be emitted out of\n      line.  The hook is useful to, e.g., emit abstract debug info for\n      the inline before it gets mangled by optimization.  */\n-  void (* outlining_inline_function) PARAMS ((tree decl));\n+  void (* outlining_inline_function) (tree decl);\n \n   /* Called from final_scan_insn for any CODE_LABEL insn whose\n      LABEL_NAME is non-null.  */\n-  void (* label) PARAMS ((rtx));\n+  void (* label) (rtx);\n \n-  /* Called after the start and before the end of writing a PCH file.  \n+  /* Called after the start and before the end of writing a PCH file.\n      The parameter is 0 if after the start, 1 if before the end.  */\n-  void (* handle_pch) PARAMS ((unsigned int));\n+  void (* handle_pch) (unsigned int);\n };\n \n extern const struct gcc_debug_hooks *debug_hooks;\n \n /* The do-nothing hooks.  */\n-extern void debug_nothing_void\n-  PARAMS ((void));\n-extern void debug_nothing_charstar\n-  PARAMS ((const char *));\n-extern void debug_nothing_int_charstar\n-  PARAMS ((unsigned int, const char *));\n-extern void debug_nothing_int\n-  PARAMS ((unsigned int));\n-extern void debug_nothing_int_int\n-  PARAMS ((unsigned int, unsigned int));\n-extern void debug_nothing_tree\n-  PARAMS ((tree));\n-extern bool debug_true_tree\n-  PARAMS ((tree));\n-extern void debug_nothing_rtx\n-  PARAMS ((rtx));\n+extern void debug_nothing_void (void);\n+extern void debug_nothing_charstar (const char *);\n+extern void debug_nothing_int_charstar (unsigned int, const char *);\n+extern void debug_nothing_int (unsigned int);\n+extern void debug_nothing_int_int (unsigned int, unsigned int);\n+extern void debug_nothing_tree (tree);\n+extern bool debug_true_tree (tree);\n+extern void debug_nothing_rtx (rtx);\n \n /* Hooks for various debug formats.  */\n extern const struct gcc_debug_hooks do_nothing_debug_hooks;\n@@ -138,17 +130,17 @@ extern const struct gcc_debug_hooks vmsdbg_debug_hooks;\n \n /* Dwarf2 frame information.  */\n \n-extern void dwarf2out_begin_prologue\tPARAMS ((unsigned int, const char *));\n-extern void dwarf2out_end_epilogue\tPARAMS ((unsigned int, const char *));\n-extern void dwarf2out_frame_init\tPARAMS ((void));\n-extern void dwarf2out_frame_finish\tPARAMS ((void));\n+extern void dwarf2out_begin_prologue (unsigned int, const char *);\n+extern void dwarf2out_end_epilogue (unsigned int, const char *);\n+extern void dwarf2out_frame_init (void);\n+extern void dwarf2out_frame_finish (void);\n /* Decide whether we want to emit frame unwind information for the current\n    translation unit.  */\n-extern int dwarf2out_do_frame\t\tPARAMS ((void));\n+extern int dwarf2out_do_frame (void);\n \n-extern void debug_flush_symbol_queue    PARAMS ((void));\n-extern void debug_queue_symbol          PARAMS ((tree));\n-extern void debug_free_queue            PARAMS ((void));\n+extern void debug_flush_symbol_queue (void);\n+extern void debug_queue_symbol (tree);\n+extern void debug_free_queue (void);\n extern int debug_nesting;\n extern int symbol_queue_index;\n "}, {"sha": "1cc599e739934c50a6070331daed9b06620f9d46", "filename": "gcc/dwarf2asm.h", "status": "modified", "additions": 27, "deletions": 32, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5/gcc%2Fdwarf2asm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5/gcc%2Fdwarf2asm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.h?ref=f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5", "patch": "@@ -1,5 +1,5 @@\n /* Dwarf2 assembler output helper routines.\n-   Copyright (C) 2001 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -19,60 +19,55 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n \n-extern void dw2_assemble_integer\tPARAMS ((int, rtx));\n+extern void dw2_assemble_integer (int, rtx);\n \n-extern void dw2_asm_output_data\t\tPARAMS ((int, unsigned HOST_WIDE_INT,\n-\t\t\t\t\t\t const char *, ...))\n+extern void dw2_asm_output_data (int, unsigned HOST_WIDE_INT,\n+\t\t\t\t const char *, ...)\n      ATTRIBUTE_NULL_PRINTF_3;\n \n-extern void dw2_asm_output_delta\tPARAMS ((int, const char *,\n-\t\t\t\t\t\t const char *,\n-\t\t\t\t\t\t const char *, ...))\n+extern void dw2_asm_output_delta (int, const char *, const char *,\n+\t\t\t\t  const char *, ...)\n      ATTRIBUTE_NULL_PRINTF_4;\n \n-extern void dw2_asm_output_offset\tPARAMS ((int, const char *,\n-\t\t\t\t\t\t const char *, ...))\n+extern void dw2_asm_output_offset (int, const char *, const char *, ...)\n      ATTRIBUTE_NULL_PRINTF_3;\n \n-extern void dw2_asm_output_pcrel\tPARAMS ((int, const char *,\n-\t\t\t\t\t\t const char *, ...))\n+extern void dw2_asm_output_pcrel (int, const char *, const char *, ...)\n      ATTRIBUTE_NULL_PRINTF_3;\n \n-extern void dw2_asm_output_addr\t\tPARAMS ((int, const char *,\n-\t\t\t\t\t\t const char *, ...))\n+extern void dw2_asm_output_addr (int, const char *, const char *, ...)\n      ATTRIBUTE_NULL_PRINTF_3;\n \n-extern void dw2_asm_output_addr_rtx\tPARAMS ((int, rtx,\n-\t\t\t\t\t\t const char *, ...))\n+extern void dw2_asm_output_addr_rtx (int, rtx, const char *, ...)\n      ATTRIBUTE_NULL_PRINTF_3;\n \n-extern void dw2_asm_output_encoded_addr_rtx PARAMS ((int, rtx,\n-\t\t\t\t\t\t     const char *, ...))\n+extern void dw2_asm_output_encoded_addr_rtx (int, rtx,\n+\t\t\t\t\t     const char *, ...)\n      ATTRIBUTE_NULL_PRINTF_3;\n \n-extern void dw2_asm_output_nstring\tPARAMS ((const char *, size_t,\n-\t\t\t\t\t\t const char *, ...))\n+extern void dw2_asm_output_nstring (const char *, size_t,\n+\t\t\t\t    const char *, ...)\n      ATTRIBUTE_NULL_PRINTF_3;\n \n-extern void dw2_asm_output_data_uleb128\tPARAMS ((unsigned HOST_WIDE_INT,\n-\t\t\t\t\t\t const char *, ...))\n+extern void dw2_asm_output_data_uleb128\t(unsigned HOST_WIDE_INT,\n+\t\t\t\t\t const char *, ...)\n      ATTRIBUTE_NULL_PRINTF_2;\n \n-extern void dw2_asm_output_data_sleb128\tPARAMS ((HOST_WIDE_INT,\n-\t\t\t\t\t\t const char *, ...))\n+extern void dw2_asm_output_data_sleb128\t(HOST_WIDE_INT,\n+\t\t\t\t\t const char *, ...)\n      ATTRIBUTE_NULL_PRINTF_2;\n \n-extern void dw2_asm_output_delta_uleb128 PARAMS ((const char *, const char *,\n-\t\t\t\t\t\t  const char *, ...))\n+extern void dw2_asm_output_delta_uleb128 (const char *, const char *,\n+\t\t\t\t\t  const char *, ...)\n      ATTRIBUTE_NULL_PRINTF_3;\n \n-extern void dw2_asm_output_delta_sleb128 PARAMS ((const char *, const char *,\n-\t\t\t\t\t\t  const char *, ...))\n+extern void dw2_asm_output_delta_sleb128 (const char *, const char *,\n+\t\t\t\t\t  const char *, ...)\n      ATTRIBUTE_NULL_PRINTF_3;\n \n-extern int size_of_uleb128\t\tPARAMS ((unsigned HOST_WIDE_INT));\n-extern int size_of_sleb128\t\tPARAMS ((HOST_WIDE_INT));\n-extern int size_of_encoded_value\tPARAMS ((int));\n-extern const char *eh_data_format_name\tPARAMS ((int));\n+extern int size_of_uleb128 (unsigned HOST_WIDE_INT);\n+extern int size_of_sleb128 (HOST_WIDE_INT);\n+extern int size_of_encoded_value (int);\n+extern const char *eh_data_format_name (int);\n \n-extern void dw2_output_indirect_constants PARAMS ((void));\n+extern void dw2_output_indirect_constants (void);"}, {"sha": "276918f051b741ee95ebf65f20ecfb374a6e1e5d", "filename": "gcc/gcov.c", "status": "modified", "additions": 180, "deletions": 205, "changes": 385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5", "patch": "@@ -1,7 +1,7 @@\n /* Gcov.c: prepend line execution counts and branch probabilities to a\n    source file.\n    Copyright (C) 1990, 1991, 1992, 1993, 1994, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n    Contributed by James E. Wilson of Cygnus Support.\n    Mangled by Bob Manson of Cygnus Support.\n    Mangled further by Nathan Sidwell <nathan@codesourcery.com>\n@@ -102,7 +102,7 @@ typedef struct arc_info\n \n   /* Next branch on line.  */\n   struct arc_info *line_next;\n-  \n+\n   /* Links to next arc on src and dst lists.  */\n   struct arc_info *succ_next;\n   struct arc_info *pred_next;\n@@ -159,7 +159,7 @@ typedef struct block_info\n   /* Temporary chain for solving graph, and for chaining blocks on one\n      line.  */\n   struct block_info *chain;\n-  \n+\n } block_t;\n \n /* Describes a single function. Contains an array of basic blocks.  */\n@@ -186,7 +186,7 @@ typedef struct function_info\n \n   /* Next function in same source file.  */\n   struct function_info *line_next;\n-  \n+\n   /* Next function.  */\n   struct function_info *next;\n } function_t;\n@@ -197,14 +197,14 @@ typedef struct coverage_info\n {\n   int lines;\n   int lines_executed;\n-  \n+\n   int branches;\n   int branches_executed;\n   int branches_taken;\n-  \n+\n   int calls;\n   int calls_executed;\n-  \n+\n   char *name;\n } coverage_t;\n \n@@ -216,7 +216,7 @@ typedef struct line_info\n   gcov_type count;\t   /* execution count */\n   union\n   {\n-    arc_t *branches; \t   /* branches from blocks that end on this\n+    arc_t *branches;\t   /* branches from blocks that end on this\n \t\t\t      line. Used for branch-counts when not\n \t\t\t      all-blocks mode.  */\n     block_t *blocks;       /* blocks which start on this line.  Used\n@@ -243,7 +243,7 @@ typedef struct source_info\n   /* Functions in this source file.  These are in ascending line\n      number order.  */\n   function_t *functions;\n-  \n+\n   /* Next source file.  */\n   struct source_info *next;\n } source_t;\n@@ -280,7 +280,7 @@ static char *da_file_name;\n \n static int flag_branches = 0;\n \n-/* Show unconditional branches too.  */ \n+/* Show unconditional branches too.  */\n static int flag_unconditional = 0;\n \n /* Output a gcov file if this is true.  This is on by default, and can\n@@ -320,34 +320,32 @@ static int flag_preserve_paths = 0;\n static int flag_counts = 0;\n \n /* Forward declarations.  */\n-static void fnotice PARAMS ((FILE *, const char *, ...)) ATTRIBUTE_PRINTF_2;\n-static int process_args PARAMS ((int, char **));\n-static void print_usage PARAMS ((int)) ATTRIBUTE_NORETURN;\n-static void print_version PARAMS ((void)) ATTRIBUTE_NORETURN;\n-static void process_file PARAMS ((const char *));\n-static void create_file_names PARAMS ((const char *));\n-static source_t *find_source PARAMS ((const char *));\n-static int read_graph_file PARAMS ((void));\n-static int read_count_file PARAMS ((void));\n-static void solve_flow_graph PARAMS ((function_t *));\n-static void add_branch_counts PARAMS ((coverage_t *, const arc_t *));\n-static void add_line_counts PARAMS ((coverage_t *, function_t *));\n-static void function_summary PARAMS ((const coverage_t *, const char *));\n-static const char *format_gcov PARAMS ((gcov_type, gcov_type, int));\n-static void accumulate_line_counts PARAMS ((source_t *));\n-static int output_branch_count PARAMS ((FILE *, int, const arc_t *));\n-static void output_lines PARAMS ((FILE *, const source_t *));\n-static char *make_gcov_file_name PARAMS ((const char *, const char *));\n-static void release_structures PARAMS ((void));\n-extern int main PARAMS ((int, char **));\n+static void fnotice (FILE *, const char *, ...) ATTRIBUTE_PRINTF_2;\n+static int process_args (int, char **);\n+static void print_usage (int) ATTRIBUTE_NORETURN;\n+static void print_version (void) ATTRIBUTE_NORETURN;\n+static void process_file (const char *);\n+static void create_file_names (const char *);\n+static source_t *find_source (const char *);\n+static int read_graph_file (void);\n+static int read_count_file (void);\n+static void solve_flow_graph (function_t *);\n+static void add_branch_counts (coverage_t *, const arc_t *);\n+static void add_line_counts (coverage_t *, function_t *);\n+static void function_summary (const coverage_t *, const char *);\n+static const char *format_gcov (gcov_type, gcov_type, int);\n+static void accumulate_line_counts (source_t *);\n+static int output_branch_count (FILE *, int, const arc_t *);\n+static void output_lines (FILE *, const source_t *);\n+static char *make_gcov_file_name (const char *, const char *);\n+static void release_structures (void);\n+extern int main (int, char **);\n \n int\n-main (argc, argv)\n-     int argc;\n-     char **argv;\n+main (int argc, char **argv)\n {\n   int argno;\n-  \n+\n   gcc_init_libintl ();\n \n   argno = process_args (argc, argv);\n@@ -357,29 +355,29 @@ main (argc, argv)\n   for (; argno != argc; argno++)\n     {\n       release_structures ();\n-      \n+\n       process_file (argv[argno]);\n     }\n-  \n+\n   return 0;\n }\n \n static void\n fnotice (FILE *file, const char *msgid, ...)\n {\n   va_list ap;\n-  \n+\n   va_start (ap, msgid);\n   vfprintf (file, _(msgid), ap);\n   va_end (ap);\n }\n \n /* More 'friendly' abort that prints the line and file.\n    config.h can #define abort fancy_abort if you like that sort of thing.  */\n-extern void fancy_abort PARAMS ((void)) ATTRIBUTE_NORETURN;\n+extern void fancy_abort (void) ATTRIBUTE_NORETURN;\n \n void\n-fancy_abort ()\n+fancy_abort (void)\n {\n   fnotice (stderr, \"Internal gcov abort.\\n\");\n   exit (FATAL_EXIT_CODE);\n@@ -389,12 +387,11 @@ fancy_abort ()\n    otherwise the output of --help.  */\n \n static void\n-print_usage (error_p)\n-     int error_p;\n+print_usage (int error_p)\n {\n   FILE *file = error_p ? stderr : stdout;\n   int status = error_p ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE;\n-  \n+\n   fnotice (file, \"Usage: gcov [OPTION]... SOURCEFILE\\n\\n\");\n   fnotice (file, \"Print code coverage information.\\n\\n\");\n   fnotice (file, \"  -h, --help                      Print this help, then exit\\n\");\n@@ -418,7 +415,7 @@ print_usage (error_p)\n /* Print version information and exit.  */\n \n static void\n-print_version ()\n+print_version (void)\n {\n   char v[4];\n   unsigned version = GCOV_VERSION;\n@@ -454,9 +451,7 @@ static const struct option options[] =\n /* Process args, return index to first non-arg.  */\n \n static int\n-process_args (argc, argv)\n-     int argc;\n-     char **argv;\n+process_args (int argc, char **argv)\n {\n   int opt;\n \n@@ -509,33 +504,32 @@ process_args (argc, argv)\n /* Process a single source file.  */\n \n static void\n-process_file (file_name)\n-     const char *file_name;\n+process_file (const char *file_name)\n {\n   source_t *src;\n   function_t *fn;\n-  \n+\n   create_file_names (file_name);\n   if (read_graph_file ())\n     return;\n-  \n+\n   if (!functions)\n     {\n       fnotice (stderr, \"%s:no functions found\\n\", bbg_file_name);\n       return;\n     }\n-  \n+\n   if (read_count_file ())\n     return;\n-  \n+\n   for (fn = functions; fn; fn = fn->next)\n     solve_flow_graph (fn);\n   for (src = sources; src; src = src->next)\n     src->lines = (line_t *) xcalloc (src->num_lines, sizeof (line_t));\n   for (fn = functions; fn; fn = fn->next)\n     {\n       coverage_t coverage;\n-      \n+\n       memset (&coverage, 0, sizeof (coverage));\n       coverage.name = fn->name;\n       add_line_counts (flag_function_summary ? &coverage : NULL, fn);\n@@ -545,7 +539,7 @@ process_file (file_name)\n \t  fnotice (stdout, \"\\n\");\n \t}\n     }\n-  \n+\n   for (src = sources; src; src = src->next)\n     {\n       accumulate_line_counts (src);\n@@ -554,7 +548,7 @@ process_file (file_name)\n \t{\n \t  char *gcov_file_name = make_gcov_file_name (file_name, src->name);\n \t  FILE *gcov_file = fopen (gcov_file_name, \"w\");\n-\t  \n+\n \t  if (gcov_file)\n \t    {\n \t      fnotice (stdout, \"%s:creating `%s'\\n\",\n@@ -577,30 +571,30 @@ process_file (file_name)\n /* Release all memory used.  */\n \n static void\n-release_structures ()\n+release_structures (void)\n {\n   function_t *fn;\n   source_t *src;\n-  \n+\n   free (bbg_file_name);\n   free (da_file_name);\n   da_file_name = bbg_file_name = NULL;\n   bbg_file_time = 0;\n   bbg_stamp = 0;\n-  \n+\n   while ((src = sources))\n     {\n       sources = src->next;\n \n       free (src->name);\n       free (src->lines);\n     }\n-  \n+\n   while ((fn = functions))\n     {\n       unsigned ix;\n       block_t *block;\n-      \n+\n       functions = fn->next;\n       for (ix = fn->num_blocks, block = fn->blocks; ix--; block++)\n \t{\n@@ -626,22 +620,21 @@ release_structures ()\n    the object *file*, and the data files are named from that.  */\n \n static void\n-create_file_names (file_name)\n-     const char *file_name;\n+create_file_names (const char *file_name)\n {\n   char *cptr;\n   char *name;\n   int length = strlen (file_name);\n   int base;\n-  \n+\n   if (object_directory && object_directory[0])\n     {\n       struct stat status;\n \n       length += strlen (object_directory) + 2;\n       name = xmalloc (length);\n       name[0] = 0;\n-      \n+\n       base = !stat (object_directory, &status) && S_ISDIR (status.st_mode);\n       strcat (name, object_directory);\n       if (base && name[strlen (name) - 1] != '/')\n@@ -653,48 +646,47 @@ create_file_names (file_name)\n       name[0] = 0;\n       base = 1;\n     }\n-  \n+\n   if (base)\n     {\n       /* Append source file name.  */\n       cptr = strrchr (file_name, '/');\n       strcat (name, cptr ? cptr + 1 : file_name);\n     }\n-  \n+\n   /* Remove the extension.  */\n   cptr = strrchr (name, '.');\n   if (cptr)\n     *cptr = 0;\n-  \n+\n   length = strlen (name);\n-  \n+\n   bbg_file_name = xmalloc (length + strlen (GCOV_GRAPH_SUFFIX) + 1);\n   strcpy (bbg_file_name, name);\n   strcpy (bbg_file_name + length, GCOV_GRAPH_SUFFIX);\n \n   da_file_name = xmalloc (length + strlen (GCOV_DATA_SUFFIX) + 1);\n   strcpy (da_file_name, name);\n   strcpy (da_file_name + length, GCOV_DATA_SUFFIX);\n-  \n+\n   return;\n }\n \n /* Find or create a source file structure for FILE_NAME. Copies\n    FILE_NAME on creation */\n \n static source_t *\n-find_source (file_name)\n-     const char *file_name;\n+find_source (const char *file_name)\n {\n   source_t *src;\n \n   if (!file_name)\n     file_name = \"<unknown>\";\n-  \n+\n   for (src = sources; src; src = src->next)\n     if (!strcmp (file_name, src->name))\n       return src;\n-  \n+\n   src = (source_t *)xcalloc (1, sizeof (source_t));\n   src->name = xstrdup (file_name);\n   src->coverage.name = src->name;\n@@ -708,15 +700,15 @@ find_source (file_name)\n /* Read the graph file. Return nonzero on fatal error.  */\n \n static int\n-read_graph_file ()\n+read_graph_file (void)\n {\n   unsigned version;\n   unsigned current_tag = 0;\n   struct function_info *fn = NULL;\n   source_t *src = NULL;\n   unsigned ix;\n   unsigned tag;\n-  \n+\n   if (!gcov_open (bbg_file_name, 1))\n     {\n       fnotice (stderr, \"%s:cannot open graph file\\n\", bbg_file_name);\n@@ -735,7 +727,7 @@ read_graph_file ()\n     {\n       char v[4], e[4];\n       unsigned required = GCOV_VERSION;\n-      \n+\n       for (ix = 4; ix--; required >>= 8, version >>= 8)\n \t{\n \t  v[ix] = version;\n@@ -763,7 +755,7 @@ read_graph_file ()\n \t  function_name = xstrdup (gcov_read_string ());\n \t  src = find_source (gcov_read_string ());\n \t  lineno = gcov_read_unsigned ();\n-\t  \n+\n \t  fn = (function_t *)xcalloc (1, sizeof (function_t));\n \t  fn->name = function_name;\n \t  fn->ident = ident;\n@@ -774,7 +766,7 @@ read_graph_file ()\n \t  fn->next = functions;\n \t  functions = fn;\n \t  current_tag = tag;\n-\t  \n+\n \t  if (lineno >= src->num_lines)\n \t    src->num_lines = lineno + 1;\n \t  /* Now insert it into the source file's list of\n@@ -799,7 +791,7 @@ read_graph_file ()\n \t    {\n \t      unsigned ix, num_blocks = length / 4;\n \t      fn->num_blocks = num_blocks;\n-\t      \n+\n \t      fn->blocks\n \t\t= (block_t *)xcalloc (fn->num_blocks, sizeof (block_t));\n \t      for (ix = 0; ix != num_blocks; ix++)\n@@ -813,30 +805,30 @@ read_graph_file ()\n \n \t  if (src >= fn->num_blocks || fn->blocks[src].succ)\n \t    goto corrupt;\n-\t  \n+\n \t  while (num_dests--)\n \t    {\n \t      struct arc_info *arc;\n \t      unsigned dest = gcov_read_unsigned ();\n \t      unsigned flags = gcov_read_unsigned ();\n-\t      \n+\n \t      if (dest >= fn->num_blocks)\n \t\tgoto corrupt;\n \t      arc = (arc_t *) xcalloc (1, sizeof (arc_t));\n-\t      \n+\n \t      arc->dst = &fn->blocks[dest];\n \t      arc->src = &fn->blocks[src];\n-\t      \n+\n \t      arc->count = 0;\n \t      arc->count_valid = 0;\n \t      arc->on_tree = !!(flags & GCOV_ARC_ON_TREE);\n \t      arc->fake = !!(flags & GCOV_ARC_FAKE);\n \t      arc->fall_through = !!(flags & GCOV_ARC_FALLTHROUGH);\n-\t      \n+\n \t      arc->succ_next = fn->blocks[src].succ;\n \t      fn->blocks[src].succ = arc;\n \t      fn->blocks[src].num_succ++;\n-\t      \n+\n \t      arc->pred_next = fn->blocks[dest].pred;\n \t      fn->blocks[dest].pred = arc;\n \t      fn->blocks[dest].num_pred++;\n@@ -853,13 +845,13 @@ read_graph_file ()\n \t\t  else\n \t\t    {\n \t\t      /* Non-local return from a callee of this\n-  \t\t         function. The destination block is a catch or\n-  \t\t         setjmp.  */\n+\t\t         function. The destination block is a catch or\n+\t\t         setjmp.  */\n \t\t      arc->is_nonlocal_return = 1;\n \t\t      fn->blocks[dest].is_nonlocal_return = 1;\n \t\t    }\n \t\t}\n-\t      \n+\n \t      if (!arc->on_tree)\n \t\tfn->num_counts++;\n \t    }\n@@ -872,11 +864,11 @@ read_graph_file ()\n \n \t  if (blockno >= fn->num_blocks || fn->blocks[blockno].u.line.encoding)\n \t    goto corrupt;\n-\t  \n+\n \t  for (ix = 0; ;  )\n \t    {\n \t      unsigned lineno = gcov_read_unsigned ();\n-\t      \n+\n \t      if (lineno)\n \t\t{\n \t\t  if (!ix)\n@@ -891,16 +883,16 @@ read_graph_file ()\n \t      else\n \t\t{\n \t\t  const char *file_name = gcov_read_string ();\n-\t\t  \n+\n \t\t  if (!file_name)\n \t\t    break;\n \t\t  src = find_source (file_name);\n-\t\t  \n+\n \t\t  line_nos[ix++] = 0;\n \t\t  line_nos[ix++] = src->index;\n \t\t}\n \t    }\n-\t  \n+\n \t  fn->blocks[blockno].u.line.encoding = line_nos;\n \t  fn->blocks[blockno].u.line.num = ix;\n \t}\n@@ -921,9 +913,9 @@ read_graph_file ()\n       return 1;\n     }\n   gcov_close ();\n-  \n+\n   /* We built everything backwards, so nreverse them all */\n-  \n+\n   /* Reverse sources. Not strictly necessary, but we'll then process\n      them in the 'expected' order.  */\n   {\n@@ -944,15 +936,15 @@ read_graph_file ()\n     for (fn_p = NULL, fn = functions; fn; fn_p = fn, fn = fn_n)\n       {\n \tunsigned ix;\n-\t\n+\n \tfn_n = fn->next;\n \tfn->next = fn_p;\n \n \t/* Reverse the arcs.  */\n \tfor (ix = fn->num_blocks; ix--;)\n \t  {\n \t    arc_t *arc, *arc_p, *arc_n;\n-\t    \n+\n \t    for (arc_p = NULL, arc = fn->blocks[ix].succ; arc;\n \t\t arc_p = arc, arc = arc_n)\n \t      {\n@@ -979,7 +971,7 @@ read_graph_file ()\n    function. Return nonzero if fatal error.  */\n \n static int\n-read_count_file ()\n+read_count_file (void)\n {\n   unsigned ix;\n   unsigned version;\n@@ -1004,7 +996,7 @@ read_count_file ()\n     {\n       char v[4], e[4];\n       unsigned desired = GCOV_VERSION;\n-      \n+\n       for (ix = 4; ix--; desired >>= 8, version >>= 8)\n \t{\n \t  v[ix] = version;\n@@ -1019,7 +1011,7 @@ read_count_file ()\n       fnotice (stderr, \"%s:stamp mismatch with graph file\\n\", da_file_name);\n       goto cleanup;\n     }\n-  \n+\n   while ((tag = gcov_read_unsigned ()))\n     {\n       unsigned length = gcov_read_unsigned ();\n@@ -1064,11 +1056,11 @@ read_count_file ()\n \t{\n \t  if (length != 8 * fn->num_counts)\n \t    goto mismatch;\n-\t  \n+\n \t  if (!fn->counts)\n \t    fn->counts\n \t      = (gcov_type *)xcalloc (fn->num_counts, sizeof (gcov_type));\n-\t  \n+\n \t  for (ix = 0; ix != fn->num_counts; ix++)\n \t    fn->counts[ix] += gcov_read_counter ();\n \t}\n@@ -1083,7 +1075,7 @@ read_count_file ()\n \t       da_file_name);\n       goto cleanup;\n     }\n-  \n+\n   gcov_close ();\n   return 0;\n }\n@@ -1092,16 +1084,15 @@ read_count_file ()\n    to the blocks and the uninstrumented arcs.  */\n \n static void\n-solve_flow_graph (fn)\n-     function_t *fn;\n+solve_flow_graph (function_t *fn)\n {\n   unsigned ix;\n   arc_t *arc;\n   gcov_type *count_ptr = fn->counts;\n   block_t *blk;\n   block_t *valid_blocks = NULL;    /* valid, but unpropagated blocks.  */\n   block_t *invalid_blocks = NULL;  /* invalid, but inferable blocks.  */\n-  \n+\n   if (fn->num_blocks < 2)\n     fnotice (stderr, \"%s:`%s' lacks entry and/or exit blocks\\n\",\n \t     bbg_file_name, fn->name);\n@@ -1114,7 +1105,7 @@ solve_flow_graph (fn)\n \t/* We can't deduce the entry block counts from the lack of\n \t   predecessors.  */\n \tfn->blocks[0].num_pred = ~(unsigned)0;\n-      \n+\n       if (fn->blocks[fn->num_blocks - 1].num_succ)\n \tfnotice (stderr, \"%s:`%s' has arcs from exit block\\n\",\n \t\t bbg_file_name, fn->name);\n@@ -1131,12 +1122,12 @@ solve_flow_graph (fn)\n       block_t const *prev_dst = NULL;\n       int out_of_order = 0;\n       int non_fake_succ = 0;\n-      \n+\n       for (arc = blk->succ; arc; arc = arc->succ_next)\n \t{\n \t  if (!arc->fake)\n \t    non_fake_succ++;\n-\t  \n+\n \t  if (!arc->on_tree)\n \t    {\n \t      if (count_ptr)\n@@ -1168,7 +1159,7 @@ solve_flow_graph (fn)\n \t\t  arc->dst->is_call_return = 1;\n \t      }\n \t}\n-      \n+\n       /* Sort the successor arcs into ascending dst order. profile.c\n \t normally produces arcs in the right order, but sometimes with\n \t one or two out of order.  We're not using a particularly\n@@ -1177,11 +1168,11 @@ solve_flow_graph (fn)\n \t{\n \t  arc_t *start = blk->succ;\n \t  unsigned changes = 1;\n-\t  \n+\n \t  while (changes)\n \t    {\n \t      arc_t *arc, *arc_p, *arc_n;\n-\t      \n+\n \t      changes = 0;\n \t      for (arc_p = NULL, arc = start; (arc_n = arc->succ_next);)\n \t\t{\n@@ -1205,7 +1196,7 @@ solve_flow_graph (fn)\n \t    }\n \t  blk->succ = start;\n \t}\n-      \n+\n       /* Place it on the invalid chain, it will be ignored if that's\n \t wrong.  */\n       blk->invalid_chain = 1;\n@@ -1219,7 +1210,7 @@ solve_flow_graph (fn)\n \t{\n \t  gcov_type total = 0;\n \t  const arc_t *arc;\n-\t  \n+\n \t  invalid_blocks = blk->chain;\n \t  blk->invalid_chain = 0;\n \t  if (!blk->num_succ)\n@@ -1230,7 +1221,7 @@ solve_flow_graph (fn)\n \t      total += arc->count;\n \t  else\n \t    continue;\n-\t  \n+\n \t  blk->count = total;\n \t  blk->count_valid = 1;\n \t  blk->chain = valid_blocks;\n@@ -1247,7 +1238,7 @@ solve_flow_graph (fn)\n \t  if (blk->num_succ == 1)\n \t    {\n \t      block_t *dst;\n-\t      \n+\n \t      total = blk->count;\n \t      inv_arc = NULL;\n \t      for (arc = blk->succ; arc; arc = arc->succ_next)\n@@ -1283,7 +1274,7 @@ solve_flow_graph (fn)\n \t  if (blk->num_pred == 1)\n \t    {\n \t      block_t *src;\n-\t      \n+\n \t      total = blk->count;\n \t      inv_arc = NULL;\n \t      for (arc = blk->pred; arc; arc = arc->pred_next)\n@@ -1318,7 +1309,7 @@ solve_flow_graph (fn)\n \t    }\n \t}\n     }\n-  \n+\n   /* If the graph has been correctly solved, every block will have a\n      valid count.  */\n   for (ix = 0; ix < fn->num_blocks; ix++)\n@@ -1335,9 +1326,7 @@ solve_flow_graph (fn)\n /* Increment totals in COVERAGE according to arc ARC.  */\n \n static void\n-add_branch_counts (coverage, arc)\n-     coverage_t *coverage;\n-     const arc_t *arc;\n+add_branch_counts (coverage_t *coverage, const arc_t *arc)\n {\n   if (arc->is_call_non_return)\n     {\n@@ -1362,22 +1351,20 @@ add_branch_counts (coverage, arc)\n    format TOP.  Return pointer to a static string.  */\n \n static char const *\n-format_gcov (top, bottom, dp)\n-     gcov_type top, bottom;\n-     int dp;\n+format_gcov (gcov_type top, gcov_type bottom, int dp)\n {\n   static char buffer[20];\n-  \n+\n   if (dp >= 0)\n     {\n       float ratio = bottom ? (float)top / bottom : 0;\n       int ix;\n       unsigned limit = 100;\n       unsigned percent;\n-  \n+\n       for (ix = dp; ix--; )\n \tlimit *= 10;\n-      \n+\n       percent = (unsigned) (ratio * limit + (float)0.5);\n       if (percent <= 0 && top)\n \tpercent = 1;\n@@ -1398,17 +1385,15 @@ format_gcov (top, bottom, dp)\n     }\n   else\n     sprintf (buffer, HOST_WIDEST_INT_PRINT_DEC, (HOST_WIDEST_INT)top);\n-  \n+\n   return buffer;\n }\n \n \n /* Output summary info for a function.  */\n \n static void\n-function_summary (coverage, title)\n-     const coverage_t *coverage;\n-     const char *title;\n+function_summary (const coverage_t *coverage, const char *title)\n {\n   fnotice (stdout, \"%s `%s'\\n\", title, coverage->name);\n \n@@ -1454,13 +1439,11 @@ function_summary (coverage, title)\n    removed and '..'  components are renamed to '^'.  */\n \n static char *\n-make_gcov_file_name (input_name, src_name)\n-     const char *input_name;\n-     const char *src_name;\n+make_gcov_file_name (const char *input_name, const char *src_name)\n {\n   char *cptr;\n   char *name = xmalloc (strlen (src_name) + strlen (input_name) + 10);\n-  \n+\n   name[0] = 0;\n   if (flag_long_names && strcmp (src_name, input_name))\n     {\n@@ -1469,43 +1452,43 @@ make_gcov_file_name (input_name, src_name)\n       strcat (name, cptr ? cptr + 1 : input_name);\n       strcat (name, \"##\");\n     }\n-   \n+\n   /* Generate the source filename part.  */\n   cptr = flag_preserve_paths ? NULL : strrchr (src_name, '/');\n   strcat (name, cptr ? cptr + 1 : src_name);\n-  \n+\n   if (flag_preserve_paths)\n     {\n       /* Convert '/' to '#', remove '/./', convert '/../' to '/^/' */\n       char *prev;\n-      \n+\n       for (cptr = name; (cptr = strchr ((prev = cptr), '/'));)\n- \t{\n- \t  unsigned shift = 0;\n- \t  \n- \t  if (prev + 1 == cptr && prev[0] == '.')\n- \t    {\n- \t      /* Remove '.' */\n- \t      shift = 2;\n- \t    }\n- \t  else if (prev + 2 == cptr && prev[0] == '.' && prev[1] == '.')\n- \t    {\n- \t      /* Convert '..' */\n- \t      shift = 1;\n- \t      prev[1] = '^';\n- \t    }\n- \t  else\n- \t    *cptr++ = '#';\n- \t  if (shift)\n- \t    {\n- \t      cptr = prev;\n- \t      do\n- \t\tprev[0] = prev[shift];\n+\t{\n+\t  unsigned shift = 0;\n+\n+\t  if (prev + 1 == cptr && prev[0] == '.')\n+\t    {\n+\t      /* Remove '.' */\n+\t      shift = 2;\n+\t    }\n+\t  else if (prev + 2 == cptr && prev[0] == '.' && prev[1] == '.')\n+\t    {\n+\t      /* Convert '..' */\n+\t      shift = 1;\n+\t      prev[1] = '^';\n+\t    }\n+\t  else\n+\t    *cptr++ = '#';\n+\t  if (shift)\n+\t    {\n+\t      cptr = prev;\n+\t      do\n+\t\tprev[0] = prev[shift];\n \t      while (*prev++);\n- \t    }\n- \t}\n+\t    }\n+\t}\n     }\n-  \n+\n   strcat (name, \".gcov\");\n   return name;\n }\n@@ -1515,9 +1498,7 @@ make_gcov_file_name (input_name, src_name)\n    the appropriate basic block.  */\n \n static void\n-add_line_counts (coverage, fn)\n-     coverage_t *coverage;\n-     function_t *fn;\n+add_line_counts (coverage_t *coverage, function_t *fn)\n {\n   unsigned ix;\n   line_t *line = NULL; /* this is propagated from one iteration to the\n@@ -1560,13 +1541,13 @@ add_line_counts (coverage, fn)\n       free (block->u.line.encoding);\n       block->u.cycle.arc = NULL;\n       block->u.cycle.ident = ~0U;\n-      \n+\n       if (!ix || ix + 1 == fn->num_blocks)\n \t/* Entry or exit block */;\n       else if (flag_all_blocks)\n \t{\n \t  line_t *block_line = line ? line : &fn->src->lines[fn->line];\n-\t  \n+\n \t  block->chain = block_line->u.blocks;\n \t  block_line->u.blocks = block;\n \t}\n@@ -1590,8 +1571,7 @@ add_line_counts (coverage, fn)\n /* Accumulate the line counts of a file.  */\n \n static void\n-accumulate_line_counts (src)\n-     source_t *src;\n+accumulate_line_counts (source_t *src)\n {\n   line_t *line;\n   function_t *fn, *fn_p, *fn_n;\n@@ -1605,20 +1585,20 @@ accumulate_line_counts (src)\n       fn->line_next = fn_p;\n     }\n   src->functions = fn_p;\n-  \n+\n   for (ix = src->num_lines, line = src->lines; ix--; line++)\n     {\n       if (!flag_all_blocks)\n \t{\n \t  arc_t *arc, *arc_p, *arc_n;\n-\t  \n+\n \t  /* Total and reverse the branch information.  */\n \t  for (arc = line->u.branches, arc_p = NULL; arc;\n \t       arc_p = arc, arc = arc_n)\n \t    {\n \t      arc_n = arc->line_next;\n \t      arc->line_next = arc_p;\n-\t      \n+\n \t      add_branch_counts (&src->coverage, arc);\n \t    }\n \t  line->u.branches = arc_p;\n@@ -1633,7 +1613,7 @@ accumulate_line_counts (src)\n \t     and add the transition counts of those cycles.  */\n \t  block_t *block, *block_p, *block_n;\n \t  gcov_type count = 0;\n-\t  \n+\n \t  /* Reverse the block information.  */\n \t  for (block = line->u.blocks, block_p = NULL; block;\n \t       block_p = block, block = block_n)\n@@ -1643,7 +1623,7 @@ accumulate_line_counts (src)\n \t      block->u.cycle.ident = ix;\n \t    }\n \t  line->u.blocks = block_p;\n-\t  \n+\n \t  /* Sum the entry arcs.  */\n \t  for (block = line->u.blocks; block; block = block->chain)\n \t    {\n@@ -1677,7 +1657,7 @@ accumulate_line_counts (src)\n \t    {\n \t      block_t *head = block;\n \t      arc_t *arc;\n-\t      \n+\n \t    next_vertex:;\n \t      arc = head->succ;\n \t    current_vertex:;\n@@ -1694,14 +1674,14 @@ accumulate_line_counts (src)\n \t\t      arc = arc->succ_next;\n \t\t      continue;\n \t\t    }\n-\t\t  \n+\n \t\t  if (dst == block)\n \t\t    {\n \t\t      /* Found a closing arc.  */\n \t\t      gcov_type cycle_count = arc->count;\n \t\t      arc_t *cycle_arc = arc;\n \t\t      arc_t *probe_arc;\n-\t\t      \n+\n \t\t      /* Locate the smallest arc count of the loop.  */\n \t\t      for (dst = head; (probe_arc = dst->u.cycle.arc);\n \t\t\t   dst = probe_arc->src)\n@@ -1710,7 +1690,7 @@ accumulate_line_counts (src)\n \t\t\t    cycle_count = probe_arc->count;\n \t\t\t    cycle_arc = probe_arc;\n \t\t\t  }\n-\t\t      \n+\n \t\t      count += cycle_count;\n \t\t      cycle_arc->cycle = 1;\n \t\t      /* Unwind to the cyclic arc.  */\n@@ -1723,7 +1703,7 @@ accumulate_line_counts (src)\n \t\t      arc = arc->succ_next;\n \t\t      continue;\n \t\t    }\n-\t\t  \n+\n \t\t  /* Add new block to chain.  */\n \t\t  dst->u.cycle.arc = arc;\n \t\t  head = dst;\n@@ -1746,7 +1726,7 @@ accumulate_line_counts (src)\n \n \t  line->count = count;\n \t}\n-      \n+\n       if (line->exists)\n \t{\n \t  src->coverage.lines++;\n@@ -1760,12 +1740,9 @@ accumulate_line_counts (src)\n    anything is output.  */\n \n static int\n-output_branch_count (gcov_file, ix, arc)\n-     FILE *gcov_file;\n-     int ix;\n-     const arc_t *arc;\n+output_branch_count (FILE *gcov_file, int ix, const arc_t *arc)\n {\n-  \n+\n   if (arc->is_call_non_return)\n     {\n       if (arc->src->count)\n@@ -1797,20 +1774,18 @@ output_branch_count (gcov_file, ix, arc)\n   else\n     return 0;\n   return 1;\n-  \n+\n }\n \n /* Read in the source file one line at a time, and output that line to\n    the gcov file preceded by its execution count and other\n    information.  */\n \n static void\n-output_lines (gcov_file, src)\n-     FILE *gcov_file;\n-     const source_t *src;\n+output_lines (FILE *gcov_file, const source_t *src)\n {\n   FILE *source_file;\n-  unsigned line_num;       \t/* current line number.  */\n+  unsigned line_num;\t/* current line number.  */\n   const line_t *line;           /* current line info ptr.  */\n   char string[STRING_SIZE];     /* line buffer.  */\n   char const *retval = \"\";\t/* status of source file reading.  */\n@@ -1822,7 +1797,7 @@ output_lines (gcov_file, src)\n   fprintf (gcov_file, \"%9s:%5d:Runs:%u\\n\", \"-\", 0,\n \t   object_summary.ctrs[GCOV_COUNTER_ARCS].runs);\n   fprintf (gcov_file, \"%9s:%5d:Programs:%u\\n\", \"-\", 0, program_count);\n-  \n+\n   source_file = fopen (src->name, \"r\");\n   if (!source_file)\n     {\n@@ -1832,7 +1807,7 @@ output_lines (gcov_file, src)\n   else\n     {\n       struct stat status;\n-      \n+\n       if (!fstat (fileno (source_file), &status)\n \t  && status.st_mtime > bbg_file_time)\n \t{\n@@ -1854,7 +1829,7 @@ output_lines (gcov_file, src)\n \t  for (; arc; arc = arc->pred_next)\n \t    if (arc->fake)\n \t      return_count -= arc->count;\n-\t  \n+\n \t  fprintf (gcov_file, \"function %s\", fn->name);\n \t  fprintf (gcov_file, \" called %s\",\n \t\t   format_gcov (fn->blocks[0].count, 0, -1));\n@@ -1864,17 +1839,17 @@ output_lines (gcov_file, src)\n \t\t   format_gcov (fn->blocks_executed, fn->num_blocks - 2, 0));\n \t  fprintf (gcov_file, \"\\n\");\n \t}\n-      \n+\n       /* For lines which don't exist in the .bb file, print '-' before\n- \t the source line.  For lines which exist but were never\n- \t executed, print '#####' before the source line.  Otherwise,\n- \t print the execution count before the source line.  There are\n- \t 16 spaces of indentation added before the source line so that\n- \t tabs won't be messed up.  */\n+\t the source line.  For lines which exist but were never\n+\t executed, print '#####' before the source line.  Otherwise,\n+\t print the execution count before the source line.  There are\n+\t 16 spaces of indentation added before the source line so that\n+\t tabs won't be messed up.  */\n       fprintf (gcov_file, \"%9s:%5u:\",\n \t       !line->exists ? \"-\" : !line->count ? \"#####\"\n \t       : format_gcov (line->count, 0, -1), line_num);\n-      \n+\n       if (retval)\n \t{\n \t  /* Copy source line.  */\n@@ -1895,7 +1870,7 @@ output_lines (gcov_file, src)\n \t  block_t *block;\n \t  arc_t *arc;\n \t  int ix, jx;\n-\t  \n+\n \t  for (ix = jx = 0, block = line->u.blocks; block;\n \t       block = block->chain)\n \t    {\n@@ -1913,20 +1888,20 @@ output_lines (gcov_file, src)\n \t{\n \t  int ix;\n \t  arc_t *arc;\n-\t  \n+\n \t  for (ix = 0, arc = line->u.branches; arc; arc = arc->line_next)\n \t    ix += output_branch_count (gcov_file, ix, arc);\n \t}\n     }\n-  \n+\n   /* Handle all remaining source lines.  There may be lines after the\n      last line of code.  */\n   if (retval)\n     {\n       for (; (retval = fgets (string, STRING_SIZE, source_file)); line_num++)\n \t{\n \t  fprintf (gcov_file, \"%9s:%5u:%s\", \"-\", line_num, retval);\n-\t  \n+\n \t  while (!retval[0] || retval[strlen (retval) - 1] != '\\n')\n \t    {\n \t      retval = fgets (string, STRING_SIZE, source_file);\n@@ -1936,7 +1911,7 @@ output_lines (gcov_file, src)\n \t    }\n \t}\n     }\n-  \n+\n   if (source_file)\n     fclose (source_file);\n }"}, {"sha": "ad70ba82e6301e753ed6bdded59997497a3208f5", "filename": "gcc/gengtype-lex.l", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5/gcc%2Fgengtype-lex.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5/gcc%2Fgengtype-lex.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-lex.l?ref=f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5", "patch": "@@ -1,6 +1,6 @@\n /* -*- indented-text -*- */\n /* Process source files and output type information.\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -33,15 +33,13 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #undef YY_USE_PROTOS\n #define YY_DECL int yylex ()\n \n-static void update_lineno PARAMS ((const char *l, size_t len));\n+static void update_lineno (const char *l, size_t len);\n \n struct fileloc lexer_line;\n int lexer_toplevel_done;\n \n static void \n-update_lineno (l, len)\n-     const char *l;\n-     size_t len;\n+update_lineno (const char *l, size_t len)\n {\n   while (len-- > 0)\n     if (*l++ == '\\n')\n@@ -305,15 +303,13 @@ ITYPE\t{IWORD}({WS}{IWORD})*\n %%\n \n void\n-yyerror (s)\n-     const char *s;\n+yyerror (const char *s)\n {\n   error_at_line (&lexer_line, s);\n }\n \n void\n-parse_file (fname)\n-      const char *fname;\n+parse_file (const char *fname)\n {\n   yyin = fopen (fname, \"r\");\n   lexer_line.file = fname;"}, {"sha": "0ab0d65aee4e8393f9d5175ab0c2f959ea57a104", "filename": "gcc/sched-int.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5", "patch": "@@ -126,29 +126,29 @@ struct sched_info\n   void (*init_ready_list) (struct ready_list *);\n   /* Called after taking an insn from the ready list.  Returns nonzero if\n      this insn can be scheduled, nonzero if we should silently discard it.  */\n-  int (*can_schedule_ready_p) PARAMS ((rtx));\n+  int (*can_schedule_ready_p) (rtx);\n   /* Return nonzero if there are more insns that should be scheduled.  */\n-  int (*schedule_more_p) PARAMS ((void));\n+  int (*schedule_more_p) (void);\n   /* Called after an insn has all its dependencies resolved.  Return nonzero\n      if it should be moved to the ready list or the queue, or zero if we\n      should silently discard it.  */\n-  int (*new_ready) PARAMS ((rtx));\n+  int (*new_ready) (rtx);\n   /* Compare priority of two insns.  Return a positive number if the second\n      insn is to be preferred for scheduling, and a negative one if the first\n      is to be preferred.  Zero if they are equally good.  */\n-  int (*rank) PARAMS ((rtx, rtx));\n+  int (*rank) (rtx, rtx);\n   /* Return a string that contains the insn uid and optionally anything else\n      necessary to identify this insn in an output.  It's valid to use a\n      static buffer for this.  The ALIGNED parameter should cause the string\n      to be formatted so that multiple output lines will line up nicely.  */\n-  const char *(*print_insn) PARAMS ((rtx, int));\n+  const char *(*print_insn) (rtx, int);\n   /* Return nonzero if an insn should be included in priority\n      calculations.  */\n-  int (*contributes_to_priority) PARAMS ((rtx, rtx));\n+  int (*contributes_to_priority) (rtx, rtx);\n   /* Called when computing dependencies for a JUMP_INSN.  This function\n      should store the set of registers that must be considered as set by\n      the jump in the regset.  */\n-  void (*compute_jump_reg_dependencies) PARAMS ((rtx, regset));\n+  void (*compute_jump_reg_dependencies) (rtx, regset);\n \n   /* The boundaries of the set of insns to be scheduled.  */\n   rtx prev_head, next_tail;"}, {"sha": "6fa1610cc5d3b0619c2862ad5a092324197f7abf", "filename": "gcc/timevar.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5/gcc%2Ftimevar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5/gcc%2Ftimevar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.c?ref=f55ade6e34ae3da57dd1a270c4bee55ad4f85cf5", "patch": "@@ -80,15 +80,15 @@ struct tms\n #else\n #ifdef HAVE_GETRUSAGE\n # if defined HAVE_DECL_GETRUSAGE && !HAVE_DECL_GETRUSAGE\n-  extern int getrusage PARAMS ((int, struct rusage *));\n+  extern int getrusage (int, struct rusage *);\n # endif\n # define USE_GETRUSAGE\n # define HAVE_USER_TIME\n # define HAVE_SYS_TIME\n #else\n #ifdef HAVE_CLOCK\n # if defined HAVE_DECL_CLOCK && !HAVE_DECL_CLOCK\n-  extern clock_t clock PARAMS ((void));\n+  extern clock_t clock (void);\n # endif\n # define USE_CLOCK\n # define HAVE_USER_TIME"}]}