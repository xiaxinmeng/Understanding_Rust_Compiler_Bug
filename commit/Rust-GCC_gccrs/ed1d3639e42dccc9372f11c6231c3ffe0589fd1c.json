{"sha": "ed1d3639e42dccc9372f11c6231c3ffe0589fd1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQxZDM2MzllNDJkY2NjOTM3MmYxMWM2MjMxYzNmZmUwNTg5ZmQxYw==", "commit": {"author": {"name": "Aaron Sawdey", "email": "acsawdey@linux.ibm.com", "date": "2020-06-30T19:26:26Z"}, "committer": {"name": "Aaron Sawdey", "email": "acsawdey@linux.ibm.com", "date": "2020-07-10T21:10:39Z"}, "message": "rs6000: Add execution tests for mma builtins [v4]\n\nThis patch adds execution tests that use the MMA builtins and\ncheck for the right answer, and new tests that checks whether\n__builtin_cpu_supports and __builtin_cpu_is return sane\nanswers for power10.\n\n2020-06-30  Rajalakshmi Srinivasaraghavan  <rajis@linux.vnet.ibm.com>\n\t    Aaron Sawdey  <acsawdey@linux.ibm.com>\n\ngcc/testsuite/\n\t* gcc.target/powerpc/p10-identify.c: New file.\n\t* gcc.target/powerpc/p10-arch31.c: New file.\n\t* gcc.target/powerpc/mma-single-test.c: New file.\n\t* gcc.target/powerpc/mma-double-test.c: New file.", "tree": {"sha": "5dd07335c4964a2a444d709e5dba15ac2bc16ccc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5dd07335c4964a2a444d709e5dba15ac2bc16ccc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed1d3639e42dccc9372f11c6231c3ffe0589fd1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed1d3639e42dccc9372f11c6231c3ffe0589fd1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed1d3639e42dccc9372f11c6231c3ffe0589fd1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed1d3639e42dccc9372f11c6231c3ffe0589fd1c/comments", "author": {"login": "acsawdey", "id": 41373646, "node_id": "MDQ6VXNlcjQxMzczNjQ2", "avatar_url": "https://avatars.githubusercontent.com/u/41373646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/acsawdey", "html_url": "https://github.com/acsawdey", "followers_url": "https://api.github.com/users/acsawdey/followers", "following_url": "https://api.github.com/users/acsawdey/following{/other_user}", "gists_url": "https://api.github.com/users/acsawdey/gists{/gist_id}", "starred_url": "https://api.github.com/users/acsawdey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/acsawdey/subscriptions", "organizations_url": "https://api.github.com/users/acsawdey/orgs", "repos_url": "https://api.github.com/users/acsawdey/repos", "events_url": "https://api.github.com/users/acsawdey/events{/privacy}", "received_events_url": "https://api.github.com/users/acsawdey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "acsawdey", "id": 41373646, "node_id": "MDQ6VXNlcjQxMzczNjQ2", "avatar_url": "https://avatars.githubusercontent.com/u/41373646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/acsawdey", "html_url": "https://github.com/acsawdey", "followers_url": "https://api.github.com/users/acsawdey/followers", "following_url": "https://api.github.com/users/acsawdey/following{/other_user}", "gists_url": "https://api.github.com/users/acsawdey/gists{/gist_id}", "starred_url": "https://api.github.com/users/acsawdey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/acsawdey/subscriptions", "organizations_url": "https://api.github.com/users/acsawdey/orgs", "repos_url": "https://api.github.com/users/acsawdey/repos", "events_url": "https://api.github.com/users/acsawdey/events{/privacy}", "received_events_url": "https://api.github.com/users/acsawdey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ada27f8e0ca6e3d780a54fcb92b2ac647d38627", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ada27f8e0ca6e3d780a54fcb92b2ac647d38627", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ada27f8e0ca6e3d780a54fcb92b2ac647d38627"}], "stats": {"total": 429, "additions": 429, "deletions": 0}, "files": [{"sha": "9ba0010978f90e5140327535f6fa7f434836c8bc", "filename": "gcc/testsuite/gcc.target/powerpc/mma-double-test.c", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed1d3639e42dccc9372f11c6231c3ffe0589fd1c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-double-test.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed1d3639e42dccc9372f11c6231c3ffe0589fd1c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-double-test.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-double-test.c?ref=ed1d3639e42dccc9372f11c6231c3ffe0589fd1c", "patch": "@@ -0,0 +1,185 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target power10_hw } */\n+/* { dg-options \"-mdejagnu-cpu=power10 -O2\" } */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <altivec.h>\n+\n+typedef unsigned char vec_t __attribute__ ((vector_size (16)));\n+typedef double v4sf_t __attribute__ ((vector_size (16)));\n+#define SAVE_ACC(ACC, ldc, J)  \\\n+\t  __builtin_mma_disassemble_acc (result, ACC); \\\n+\t  rowC = (v4sf_t *) &CO[0*ldc+J]; \\\n+          rowC[0] += result[3] ; \\\n+          rowC = (v4sf_t *) &CO[1*ldc+J]; \\\n+          rowC[0] += result[2] ; \\\n+          rowC = (v4sf_t *) &CO[2*ldc+J]; \\\n+          rowC[0] += result[1] ; \\\n+          rowC = (v4sf_t *) &CO[3*ldc+J]; \\\n+\t  rowC[0] += result[0] ;\n+\n+void\n+MMA (int m, int n, int k, double *A, double *B, double *C)\n+{\n+  __vector_quad acc0, acc1, acc2, acc3, acc4, acc5, acc6, acc7;\n+  v4sf_t result[4];\n+  v4sf_t *rowC;\n+  for (int l = 0; l < n; l += 4)\n+    {\n+      double *CO;\n+      double *AO;\n+      AO = A;\n+      CO = C;\n+      C += m * 4;\n+      for (int j = 0; j < m; j += 16)\n+\t{\n+\t  double *BO = B;\n+\t  __builtin_mma_xxsetaccz (&acc0);\n+\t  __builtin_mma_xxsetaccz (&acc1);\n+\t  __builtin_mma_xxsetaccz (&acc2);\n+\t  __builtin_mma_xxsetaccz (&acc3);\n+\t  __builtin_mma_xxsetaccz (&acc4);\n+\t  __builtin_mma_xxsetaccz (&acc5);\n+\t  __builtin_mma_xxsetaccz (&acc6);\n+\t  __builtin_mma_xxsetaccz (&acc7);\n+\t  unsigned long i;\n+\n+\t  for (i = 0; i < k; i++)\n+\t    {\n+\t      vec_t *rowA = (vec_t *) & AO[i * 16];\n+\t      __vector_pair rowB;\n+\t      vec_t *rb = (vec_t *) & BO[i * 4];\n+\t      __builtin_mma_assemble_pair (&rowB, rb[1], rb[0]);\n+\t      __builtin_mma_xvf64gerpp (&acc0, rowB, rowA[0]);\n+\t      __builtin_mma_xvf64gerpp (&acc1, rowB, rowA[1]);\n+\t      __builtin_mma_xvf64gerpp (&acc2, rowB, rowA[2]);\n+\t      __builtin_mma_xvf64gerpp (&acc3, rowB, rowA[3]);\n+\t      __builtin_mma_xvf64gerpp (&acc4, rowB, rowA[4]);\n+\t      __builtin_mma_xvf64gerpp (&acc5, rowB, rowA[5]);\n+\t      __builtin_mma_xvf64gerpp (&acc6, rowB, rowA[6]);\n+\t      __builtin_mma_xvf64gerpp (&acc7, rowB, rowA[7]);\n+\t    }\n+\t  SAVE_ACC (&acc0, m, 0);\n+\t  SAVE_ACC (&acc2, m, 4);\n+\t  SAVE_ACC (&acc1, m, 2);\n+\t  SAVE_ACC (&acc3, m, 6);\n+\t  SAVE_ACC (&acc4, m, 8);\n+\t  SAVE_ACC (&acc6, m, 12);\n+\t  SAVE_ACC (&acc5, m, 10);\n+\t  SAVE_ACC (&acc7, m, 14);\n+\t  AO += k * 16;\n+\t  BO += k * 4;\n+\t  CO += 16;\n+\t}\n+      B += k * 4;\n+    }\n+}\n+\n+void\n+init (double *matrix, int row, int column)\n+{\n+  for (int j = 0; j < column; j++)\n+    {\n+      for (int i = 0; i < row; i++)\n+\t{\n+\t  matrix[j * row + i] = (i * 16 + 2 + j) / 0.123;\n+\t}\n+    }\n+}\n+\n+void\n+init0 (double *matrix, double *matrix1, int row, int column)\n+{\n+  for (int j = 0; j < column; j++)\n+    for (int i = 0; i < row; i++)\n+      matrix[j * row + i] = matrix1[j * row + i] = 0;\n+}\n+\n+\n+void\n+print (const char *name, const double *matrix, int row, int column)\n+{\n+  printf (\"Matrix %s has %d rows and %d columns:\\n\", name, row, column);\n+  for (int i = 0; i < row; i++)\n+    {\n+      for (int j = 0; j < column; j++)\n+\t{\n+\t  printf (\"%f \", matrix[j * row + i]);\n+\t}\n+      printf (\"\\n\");\n+    }\n+  printf (\"\\n\");\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  int rowsA, colsB, common;\n+  int i, j, k;\n+  int ret = 0;\n+\n+  for (int t = 16; t <= 128; t += 16)\n+    {\n+      for (int t1 = 4; t1 <= 16; t1 += 4)\n+\t{\n+\t  rowsA = t;\n+\t  colsB = t1;\n+\t  common = 1;\n+\t  /* printf (\"Running test for rows = %d,cols = %d\\n\", t, t1); */\n+\t  double A[rowsA * common];\n+\t  double B[common * colsB];\n+\t  double C[rowsA * colsB];\n+\t  double D[rowsA * colsB];\n+\n+\n+\t  init (A, rowsA, common);\n+\t  init (B, common, colsB);\n+\t  init0 (C, D, rowsA, colsB);\n+\t  MMA (rowsA, colsB, common, A, B, C);\n+\n+\t  for (i = 0; i < colsB; i++)\n+\t    {\n+\t      for (j = 0; j < rowsA; j++)\n+\t\t{\n+\t\t  D[i * rowsA + j] = 0;\n+\t\t  for (k = 0; k < common; k++)\n+\t\t    {\n+\t\t      D[i * rowsA + j] +=\n+\t\t\tA[k * rowsA + j] * B[k + common * i];\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  for (i = 0; i < colsB; i++)\n+\t    {\n+\t      for (j = 0; j < rowsA; j++)\n+\t\t{\n+\t\t  for (k = 0; k < common; k++)\n+\t\t    {\n+\t\t      if (D[i * rowsA + j] != C[i * rowsA + j])\n+\t\t\t{\n+\t\t\t  printf (\"Error %d,%d,%d\\n\",i,j,k);\n+\t\t\t  ret++;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  if (ret)\n+\t    {\n+\t      print (\"A\", A, rowsA, common);\n+\t      print (\"B\", B, common, colsB);\n+\t      print (\"C\", C, rowsA, colsB);\n+\t      print (\"D\", D, rowsA, colsB);\n+\t    }\n+\t}\n+    }\n+  \n+#ifdef VERBOSE\n+  if (ret)\n+    printf (\"MMA double test fail: %d errors\\n\",ret);\n+  else\n+    printf (\"MMA single test success: 0 MMA errors\\n\");\n+#endif\n+      \n+  return ret;\n+}"}, {"sha": "aa71fa7f0afd469b5539f723818463604ec8b7ff", "filename": "gcc/testsuite/gcc.target/powerpc/mma-single-test.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed1d3639e42dccc9372f11c6231c3ffe0589fd1c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-single-test.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed1d3639e42dccc9372f11c6231c3ffe0589fd1c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-single-test.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmma-single-test.c?ref=ed1d3639e42dccc9372f11c6231c3ffe0589fd1c", "patch": "@@ -0,0 +1,193 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target power10_hw } */\n+/* { dg-options \"-mdejagnu-cpu=power10 -O2\" } */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <altivec.h>\n+\n+typedef unsigned char vec_t __attribute__ ((vector_size (16)));\n+typedef float v4sf_t __attribute__ ((vector_size (16)));\n+#define SAVE_ACC(ACC, ldc,J)  \\\n+\t  __builtin_mma_disassemble_acc (result, ACC); \\\n+\t  rowC = (v4sf_t *) &CO[0*ldc+J]; \\\n+          rowC[0] += result[3] ; \\\n+          rowC = (v4sf_t *) &CO[1*ldc+J]; \\\n+          rowC[0] += result[2] ; \\\n+          rowC = (v4sf_t *) &CO[2*ldc+J]; \\\n+          rowC[0] += result[1] ; \\\n+          rowC = (v4sf_t *) &CO[3*ldc+J]; \\\n+\t  rowC[0] += result[0] ;\n+\n+#define SAVE_ACC1(ACC,ldc, J)  \\\n+\t  __builtin_mma_disassemble_acc (result, ACC); \\\n+\t  rowC = (v4sf_t *) &CO[4* ldc+J]; \\\n+          rowC[0] += result[3] ; \\\n+          rowC = (v4sf_t *) &CO[5*ldc+J]; \\\n+          rowC[0] += result[2] ; \\\n+          rowC = (v4sf_t *) &CO[6*ldc+J]; \\\n+          rowC[0] += result[1] ; \\\n+          rowC = (v4sf_t *) &CO[7*ldc+J]; \\\n+\t  rowC[0] += result[0] ;\n+void\n+MMA (int m, int n, int k, float *A, float *B, float *C)\n+{\n+  __vector_quad acc0, acc1, acc2, acc3, acc4, acc5, acc6, acc7;\n+  v4sf_t result[4];\n+  v4sf_t *rowC;\n+  for (int l = 0; l < n; l += 8)\n+    {\n+      float *CO;\n+      float *AO;\n+      AO = A;\n+      CO = C;\n+      C += m * 8;\n+      for (int j = 0; j < m; j += 16)\n+\t{\n+\t  float *BO = B;\n+\t  __builtin_mma_xxsetaccz (&acc0);\n+\t  __builtin_mma_xxsetaccz (&acc1);\n+\t  __builtin_mma_xxsetaccz (&acc2);\n+\t  __builtin_mma_xxsetaccz (&acc3);\n+\t  __builtin_mma_xxsetaccz (&acc4);\n+\t  __builtin_mma_xxsetaccz (&acc5);\n+\t  __builtin_mma_xxsetaccz (&acc6);\n+\t  __builtin_mma_xxsetaccz (&acc7);\n+\t  unsigned long i;\n+\n+\t  for (i = 0; i < k; i++)\n+\t    {\n+\t      vec_t *rowA = (vec_t *) & AO[i * 16];\n+\t      vec_t *rowB = (vec_t *) & BO[i * 8];\n+\t      __builtin_mma_xvf32gerpp (&acc0, rowB[0], rowA[0]);\n+\t      __builtin_mma_xvf32gerpp (&acc1, rowB[1], rowA[0]);\n+\t      __builtin_mma_xvf32gerpp (&acc2, rowB[0], rowA[1]);\n+\t      __builtin_mma_xvf32gerpp (&acc3, rowB[1], rowA[1]);\n+\t      __builtin_mma_xvf32gerpp (&acc4, rowB[0], rowA[2]);\n+\t      __builtin_mma_xvf32gerpp (&acc5, rowB[1], rowA[2]);\n+\t      __builtin_mma_xvf32gerpp (&acc6, rowB[0], rowA[3]);\n+\t      __builtin_mma_xvf32gerpp (&acc7, rowB[1], rowA[3]);\n+\t    }\n+\t  SAVE_ACC (&acc0, m, 0);\n+\t  SAVE_ACC (&acc2, m, 4);\n+\t  SAVE_ACC1 (&acc1, m, 0);\n+\t  SAVE_ACC1 (&acc3, m, 4);\n+\t  SAVE_ACC (&acc4, m, 8);\n+\t  SAVE_ACC (&acc6, m, 12);\n+\t  SAVE_ACC1 (&acc5, m, 8);\n+\t  SAVE_ACC1 (&acc7, m, 12);\n+\t  AO += k * 16;\n+\t  BO += k * 8;\n+\t  CO += 16;\n+\t}\n+      B += k * 8;\n+    }\n+}\n+\n+void\n+init (float *matrix, int row, int column)\n+{\n+  for (int j = 0; j < column; j++)\n+    {\n+      for (int i = 0; i < row; i++)\n+\t{\n+\t  matrix[j * row + i] = (i * 16 + 2 + j) / 0.123;\n+\t}\n+    }\n+}\n+\n+void\n+init0 (float *matrix, float *matrix1, int row, int column)\n+{\n+  for (int j = 0; j < column; j++)\n+    for (int i = 0; i < row; i++)\n+      matrix[j * row + i] = matrix1[j * row + i] = 0;\n+}\n+\n+\n+void\n+print (const char *name, const float *matrix, int row, int column)\n+{\n+  printf (\"Matrix %s has %d rows and %d columns:\\n\", name, row, column);\n+  for (int i = 0; i < row; i++)\n+    {\n+      for (int j = 0; j < column; j++)\n+\t{\n+\t  printf (\"%f \", matrix[j * row + i]);\n+\t}\n+      printf (\"\\n\");\n+    }\n+  printf (\"\\n\");\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  int rowsA, colsB, common;\n+  int i, j, k;\n+  int ret = 0;\n+\n+  for (int t = 16; t <= 128; t += 16)\n+    {\n+      for (int t1 = 8; t1 <= 16; t1 += 8)\n+\t{\n+\t  rowsA = t;\n+\t  colsB = t1;\n+\t  common = 1;\n+\t  /* printf (\"Running test for rows = %d,cols = %d\\n\", t, t1); */\n+\t  float A[rowsA * common];\n+\t  float B[common * colsB];\n+\t  float C[rowsA * colsB];\n+\t  float D[rowsA * colsB];\n+\n+\n+\t  init (A, rowsA, common);\n+\t  init (B, common, colsB);\n+\t  init0 (C, D, rowsA, colsB);\n+\t  MMA (rowsA, colsB, common, A, B, C);\n+\n+\t  for (i = 0; i < colsB; i++)\n+\t    {\n+\t      for (j = 0; j < rowsA; j++)\n+\t\t{\n+\t\t  D[i * rowsA + j] = 0;\n+\t\t  for (k = 0; k < common; k++)\n+\t\t    {\n+\t\t      D[i * rowsA + j] +=\n+\t\t\tA[k * rowsA + j] * B[k + common * i];\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  for (i = 0; i < colsB; i++)\n+\t    {\n+\t      for (j = 0; j < rowsA; j++)\n+\t\t{\n+\t\t  for (k = 0; k < common; k++)\n+\t\t    {\n+\t\t      if (D[i * rowsA + j] != C[i * rowsA + j])\n+\t\t\t{\n+\t\t\t  printf (\"Error %d,%d,%d\\n\",i,j,k);\n+\t\t\t  ret++;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  if (ret)\n+\t    {\n+\t      print (\"A\", A, rowsA, common);\n+\t      print (\"B\", B, common, colsB);\n+\t      print (\"C\", C, rowsA, colsB);\n+\t      print (\"D\", D, rowsA, colsB);\n+\t    }\n+\t}\n+    }\n+\n+#ifdef VERBOSE\n+  if (ret)\n+    printf (\"MMA single test fail: %d errors\\n\",ret);\n+  else\n+    printf (\"MMA single test success: 0 MMA errors\\n\");\n+#endif\n+      \n+  return ret;\n+}"}, {"sha": "a9a75ec83f6111e76fee6ede53a26005bc200954", "filename": "gcc/testsuite/gcc.target/powerpc/p10-arch31.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed1d3639e42dccc9372f11c6231c3ffe0589fd1c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp10-arch31.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed1d3639e42dccc9372f11c6231c3ffe0589fd1c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp10-arch31.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp10-arch31.c?ref=ed1d3639e42dccc9372f11c6231c3ffe0589fd1c", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target power10_hw } */\n+/* { dg-options \"-mdejagnu-cpu=power10 -O2\" } */\n+\n+/* This test will only run when the power10_hw_available test passes.\n+   If that test passes, then we expect to see that ISA 3.1 is\n+   supported.  If this is not the case, then the test environment has\n+   problems.  */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  int ret = 0;\n+#ifdef __BUILTIN_CPU_SUPPORTS__\n+  if ( !__builtin_cpu_supports (\"arch_3_1\"))\n+    {\n+      printf (\"Error: __builtin_cpu_supports says arch_3_1 not supported, but power10_hw test passed.\\n\");\n+      ret++;\n+    }\n+#endif\n+  return ret;\n+}"}, {"sha": "85326976a5df27008cdd5b926858dfbe1f3988d7", "filename": "gcc/testsuite/gcc.target/powerpc/p10-identify.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed1d3639e42dccc9372f11c6231c3ffe0589fd1c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp10-identify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed1d3639e42dccc9372f11c6231c3ffe0589fd1c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp10-identify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp10-identify.c?ref=ed1d3639e42dccc9372f11c6231c3ffe0589fd1c", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target power10_hw } */\n+/* { dg-options \"-mdejagnu-cpu=power10 -O2\" } */\n+\n+/* This test will only run when the power10_hw_available test passes.\n+   If that test passes, then we expect to see that the cpu is Power10.\n+   If this is not the case, then the test environment has problems.\n+   If in the future there are cpus that pass the power10_hw test but\n+   are not power10, they will need to be added to this check. */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  int ret = 0;\n+#ifdef __BUILTIN_CPU_SUPPORTS__\n+  if ( !__builtin_cpu_is (\"power10\"))\n+    {\n+      printf (\"Error: __builtin_cpu_is says this is not power10, but power10_hw test passed.\\n\");\n+      ret++;\n+    }\n+#endif\n+  return ret;\n+}"}]}