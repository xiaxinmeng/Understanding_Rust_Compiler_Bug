{"sha": "692af872fa50106af090e17cef92481207c33e89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjkyYWY4NzJmYTUwMTA2YWYwOTBlMTdjZWY5MjQ4MTIwN2MzM2U4OQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2019-05-21T14:33:24Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2019-05-21T14:33:24Z"}, "message": "[C++ PATCH] Using decls\n\nhttps://gcc.gnu.org/ml/gcc-patches/2019-05/msg01396.html\n\tgcc/cp/\n\t* name-lookup.h (struct cp_binding_level): Drop usings field.\n\t(finish_namespace_using_decl, finish_local_using_decl): Replace with ...\n\t(finish_nonmember_using_decl): ... this.\n\t* name-lookup.c (push_using_decl_1, push_using_decl):\n\t(do_nonmember_using_decl): ... here.  Add INSERT_P arg.  Reimplement.\n\t(validate_nonmember_using_decl, finish_namespace_using_decl)\n\t(finish_local_using_decl): Replace with ...\n\t(finish_nonmember_using_decl): ... this.  Drop DECL parm.\n\t* parser.c (cp_parser_using_declaration): Don't do lookup here.\n\t* pt.c (tsubst_expr): Do not do using decl lookup here.\n\n\tgcc/testsuite/\n\t* g++.dg/lookup/using53.C: Adjust diagnostic.\n\n\tlibcc1/\n\t* libcp1plugin.cc (plugin_add_using_decl): Use\n\tfinish_nonmember_using_decl.\n\nFrom-SVN: r271467", "tree": {"sha": "2ef4422c1eeae7e57ee71a77da6262876febb002", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ef4422c1eeae7e57ee71a77da6262876febb002"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/692af872fa50106af090e17cef92481207c33e89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/692af872fa50106af090e17cef92481207c33e89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/692af872fa50106af090e17cef92481207c33e89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/692af872fa50106af090e17cef92481207c33e89/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f445f0f06cf6c5d44675a5c3aaeb54e7258a4e01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f445f0f06cf6c5d44675a5c3aaeb54e7258a4e01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f445f0f06cf6c5d44675a5c3aaeb54e7258a4e01"}], "stats": {"total": 452, "additions": 193, "deletions": 259}, "files": [{"sha": "2095e1f5b4b2b77ffb6df84e6779198ee18193e9", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/692af872fa50106af090e17cef92481207c33e89/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/692af872fa50106af090e17cef92481207c33e89/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=692af872fa50106af090e17cef92481207c33e89", "patch": "@@ -1,3 +1,16 @@\n+2019-05-21  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* name-lookup.h (struct cp_binding_level): Drop usings field.\n+\t(finish_namespace_using_decl, finish_local_using_decl): Replace with ...\n+\t(finish_nonmember_using_decl): ... this.\n+\t* name-lookup.c (push_using_decl_1, push_using_decl):\n+\t(do_nonmember_using_decl): ... here.  Add INSERT_P arg.  Reimplement.\n+\t(validate_nonmember_using_decl, finish_namespace_using_decl)\n+\t(finish_local_using_decl): Replace with ...\n+\t(finish_nonmember_using_decl): ... this.  Drop DECL parm.\n+\t* parser.c (cp_parser_using_declaration): Don't do lookup here.\n+\t* pt.c (tsubst_expr): Do not do using decl lookup here.\n+\n 2019-05-21  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* decl2.c (cpp_check) <IS_ASSIGNMENT_OPERATOR>: New case."}, {"sha": "1c21adba68268480c00bdaa4c80fb447d5e627e5", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 165, "deletions": 226, "changes": 391, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/692af872fa50106af090e17cef92481207c33e89/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/692af872fa50106af090e17cef92481207c33e89/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=692af872fa50106af090e17cef92481207c33e89", "patch": "@@ -3829,42 +3829,6 @@ make_lambda_name (void)\n   return get_identifier (buf);\n }\n \n-/* Insert another USING_DECL into the current binding level, returning\n-   this declaration. If this is a redeclaration, do nothing, and\n-   return NULL_TREE if this not in namespace scope (in namespace\n-   scope, a using decl might extend any previous bindings).  */\n-\n-static tree\n-push_using_decl_1 (tree scope, tree name)\n-{\n-  tree decl;\n-\n-  gcc_assert (TREE_CODE (scope) == NAMESPACE_DECL);\n-  gcc_assert (identifier_p (name));\n-  for (decl = current_binding_level->usings; decl; decl = DECL_CHAIN (decl))\n-    if (USING_DECL_SCOPE (decl) == scope && DECL_NAME (decl) == name)\n-      break;\n-  if (decl)\n-    return namespace_bindings_p () ? decl : NULL_TREE;\n-  decl = build_lang_decl (USING_DECL, name, NULL_TREE);\n-  USING_DECL_SCOPE (decl) = scope;\n-  DECL_CHAIN (decl) = current_binding_level->usings;\n-  current_binding_level->usings = decl;\n-  return decl;\n-}\n-\n-/* Wrapper for push_using_decl_1.  */\n-\n-static tree\n-push_using_decl (tree scope, tree name)\n-{\n-  tree ret;\n-  timevar_start (TV_NAME_LOOKUP);\n-  ret = push_using_decl_1 (scope, name);\n-  timevar_stop (TV_NAME_LOOKUP);\n-  return ret;\n-}\n-\n /* Same as pushdecl, but define X in binding-level LEVEL.  We rely on the\n    caller to set DECL_CONTEXT properly.\n \n@@ -3918,91 +3882,19 @@ pushdecl_outermost_localscope (tree x)\n   return ret;\n }\n \n-/* Check a non-member using-declaration. Return the name and scope\n-   being used, and the USING_DECL, or NULL_TREE on failure.  */\n-\n-static tree\n-validate_nonmember_using_decl (tree decl, tree scope, tree name)\n-{\n-  /* [namespace.udecl]\n-       A using-declaration for a class member shall be a\n-       member-declaration.  */\n-  if (TYPE_P (scope))\n-    {\n-      error (\"%qT is not a namespace or unscoped enum\", scope);\n-      return NULL_TREE;\n-    }\n-  else if (scope == error_mark_node)\n-    return NULL_TREE;\n-\n-  if (TREE_CODE (decl) == TEMPLATE_ID_EXPR)\n-    {\n-      /* 7.3.3/5\n-\t   A using-declaration shall not name a template-id.  */\n-      error (\"a using-declaration cannot specify a template-id.  \"\n-\t     \"Try %<using %D%>\", name);\n-      return NULL_TREE;\n-    }\n-\n-  if (TREE_CODE (decl) == NAMESPACE_DECL)\n-    {\n-      error (\"namespace %qD not allowed in using-declaration\", decl);\n-      return NULL_TREE;\n-    }\n-\n-  if (TREE_CODE (decl) == SCOPE_REF)\n-    {\n-      /* It's a nested name with template parameter dependent scope.\n-\t This can only be using-declaration for class member.  */\n-      error (\"%qT is not a namespace\", TREE_OPERAND (decl, 0));\n-      return NULL_TREE;\n-    }\n-\n-  decl = OVL_FIRST (decl);\n-\n-  /* Make a USING_DECL.  */\n-  tree using_decl = push_using_decl (scope, name);\n-\n-  if (using_decl == NULL_TREE\n-      && at_function_scope_p ()\n-      && VAR_P (decl))\n-    /* C++11 7.3.3/10.  */\n-    error (\"%qD is already declared in this scope\", name);\n-  \n-  return using_decl;\n-}\n-\n-/* Process a local-scope or namespace-scope using declaration.  SCOPE\n+/* Process a local-scope or namespace-scope using declaration.\n+   FIXME\n    is the nominated scope to search for NAME.  VALUE_P and TYPE_P\n    point to the binding for NAME in the current scope and are\n    updated.  */\n \n-static void\n-do_nonmember_using_decl (tree scope, tree name, tree *value_p, tree *type_p)\n+static bool\n+do_nonmember_using_decl (name_lookup &lookup, bool fn_scope_p,\n+\t\t\t bool insert_p, tree *value_p, tree *type_p)\n {\n-  name_lookup lookup (name, 0);\n-\n-  if (!qualified_namespace_lookup (scope, &lookup))\n-    {\n-      error (\"%qD not declared\", name);\n-      return;\n-    }\n-  else if (TREE_CODE (lookup.value) == TREE_LIST)\n-    {\n-      error (\"reference to %qD is ambiguous\", name);\n-      print_candidates (lookup.value);\n-      lookup.value = NULL_TREE;\n-    }\n-\n-  if (lookup.type && TREE_CODE (lookup.type) == TREE_LIST)\n-    {\n-      error (\"reference to %qD is ambiguous\", name);\n-      print_candidates (lookup.type);\n-      lookup.type = NULL_TREE;\n-    }\n-\n   tree value = *value_p;\n   tree type = *type_p;\n+  bool failed = false;\n \n   /* Shift the old and new bindings around so we're comparing class and\n      enumeration names to each other.  */\n@@ -4018,79 +3910,95 @@ do_nonmember_using_decl (tree scope, tree name, tree *value_p, tree *type_p)\n       lookup.value = NULL_TREE;\n     }\n \n-  if (lookup.value && lookup.value != value)\n+  if (!lookup.value)\n+    /* Nothing.  */;\n+  else if (OVL_P (lookup.value) && (!value || OVL_P (value)))\n     {\n-      /* Check for using functions.  */\n-      if (OVL_P (lookup.value) && (!value || OVL_P (value)))\n+      for (lkp_iterator usings (lookup.value); usings; ++usings)\n \t{\n-\t  for (lkp_iterator usings (lookup.value); usings; ++usings)\n-\t    {\n-\t      tree new_fn = *usings;\n+\t  tree new_fn = *usings;\n \n-\t      /* [namespace.udecl]\n+\t  /* [namespace.udecl]\n \n-\t\t If a function declaration in namespace scope or block\n-\t\t scope has the same name and the same parameter types as a\n-\t\t function introduced by a using declaration the program is\n-\t\t ill-formed.  */\n-\t      bool found = false;\n-\t      for (ovl_iterator old (value); !found && old; ++old)\n+\t     If a function declaration in namespace scope or block\n+\t     scope has the same name and the same parameter types as a\n+\t     function introduced by a using declaration the program is\n+\t     ill-formed.  */\n+\t  bool found = false;\n+\t  for (ovl_iterator old (value); !found && old; ++old)\n+\t    {\n+\t      tree old_fn = *old;\n+\n+\t      if (new_fn == old_fn)\n \t\t{\n-\t\t  tree old_fn = *old;\n-\n-\t\t  if (new_fn == old_fn)\n-\t\t    /* The function already exists in the current\n-\t\t       namespace.  */\n-\t\t    found = true;\n-\t\t  else if (old.using_p ())\n-\t\t    continue; /* This is a using decl. */\n-\t\t  else if (old.hidden_p () && !DECL_HIDDEN_FRIEND_P (old_fn))\n-\t\t    continue; /* This is an anticipated builtin.  */\n-\t\t  else if (!matching_fn_p (new_fn, old_fn))\n-\t\t    continue; /* Parameters do not match.  */\n-\t\t  else if (decls_match (new_fn, old_fn))\n-\t\t    found = true;\n-\t\t  else\n-\t\t    {\n-\t\t      diagnose_name_conflict (new_fn, old_fn);\n-\t\t      found = true;\n-\t\t    }\n+\t\t  /* The function already exists in the current\n+\t\t     namespace.  */\n+\t\t  found = true;\n+\t\t  break;\n+\t\t}\n+\t      else if (old.using_p ())\n+\t\tcontinue; /* This is a using decl. */\n+\t      else if (old.hidden_p () && !DECL_HIDDEN_FRIEND_P (old_fn))\n+\t\tcontinue; /* This is an anticipated builtin.  */\n+\t      else if (!matching_fn_p (new_fn, old_fn))\n+\t\tcontinue; /* Parameters do not match.  */\n+\t      else if (decls_match (new_fn, old_fn))\n+\t\t{\n+\t\t  /* Extern \"C\" in different namespaces.  */\n+\t\t  found = true;\n+\t\t  break;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  diagnose_name_conflict (new_fn, old_fn);\n+\t\t  failed = true;\n+\t\t  found = true;\n+\t\t  break;\n \t\t}\n-\n-\t      if (!found)\n-\t\t/* Unlike the overload case we don't drop anticipated\n-\t\t   builtins here.  They don't cause a problem, and\n-\t\t   we'd like to match them with a future\n-\t\t   declaration.  */\n-\t\tvalue = ovl_insert (new_fn, value, true);\n \t    }\n+\n+\t  if (!found && insert_p)\n+\t    /* Unlike the decl-pushing case we don't drop anticipated\n+\t       builtins here.  They don't cause a problem, and we'd\n+\t       like to match them with a future declaration.  */\n+\t    value = ovl_insert (new_fn, value, true);\n \t}\n-      else if (value\n-\t       /* Ignore anticipated builtins.  */\n-\t       && !anticipated_builtin_p (value)\n-\t       && !decls_match (lookup.value, value))\n-\tdiagnose_name_conflict (lookup.value, value);\n-      else\n-\tvalue = lookup.value;\n     }\n+  else if (value\n+\t   /* Ignore anticipated builtins.  */\n+\t   && !anticipated_builtin_p (value)\n+\t   && (fn_scope_p || !decls_match (lookup.value, value)))\n+    {\n+      diagnose_name_conflict (lookup.value, value);\n+      failed = true;\n+    }\n+  else if (insert_p)\n+    value = lookup.value;\n \n   if (lookup.type && lookup.type != type)\n     {\n       if (type && !decls_match (lookup.type, type))\n-\tdiagnose_name_conflict (lookup.type, type);\n-      else\n+\t{\n+\t  diagnose_name_conflict (lookup.type, type);\n+\t  failed = true;\n+\t}\n+      else if (insert_p)\n \ttype = lookup.type;\n     }\n \n-  /* If bind->value is empty, shift any class or enumeration name back.  */\n-  if (!value)\n+  if (insert_p)\n     {\n-      value = type;\n-      type = NULL_TREE;\n+      /* If value is empty, shift any class or enumeration name back.  */\n+      if (!value)\n+\t{\n+\t  value = type;\n+\t  type = NULL_TREE;\n+\t}\n+      *value_p = value;\n+      *type_p = type;\n     }\n \n-  *value_p = value;\n-  *type_p = type;\n+  return failed;\n }\n \n /* Returns true if ANCESTOR encloses DESCENDANT, including matching.\n@@ -5120,84 +5028,115 @@ pushdecl_namespace_level (tree x, bool is_friend)\n   return t;\n }\n \n-/* Process a using-declaration appearing in namespace scope.  */\n+/* Process a using declaration in non-class scope.  */\n \n void\n-finish_namespace_using_decl (tree decl, tree scope, tree name)\n+finish_nonmember_using_decl (tree scope, tree name)\n {\n-  tree orig_decl = decl;\n+  gcc_checking_assert (current_binding_level->kind != sk_class);\n+  gcc_checking_assert (identifier_p (name));\n \n-  gcc_checking_assert (current_binding_level->kind == sk_namespace\n-\t\t       && !processing_template_decl);\n-  decl = validate_nonmember_using_decl (decl, scope, name);\n-  if (decl == NULL_TREE)\n-    return;\n+  name_lookup lookup (name, 0);\n \n-  tree *slot = find_namespace_slot (current_namespace, name, true);\n-  tree val = slot ? MAYBE_STAT_DECL (*slot) : NULL_TREE;\n-  tree type = slot ? MAYBE_STAT_TYPE (*slot) : NULL_TREE;\n-  do_nonmember_using_decl (scope, name, &val, &type);\n-  if (STAT_HACK_P (*slot))\n+  if (TREE_CODE (scope) != NAMESPACE_DECL)\n     {\n-      STAT_DECL (*slot) = val;\n-      STAT_TYPE (*slot) = type;\n+      error (\"%qE is not a namespace or unscoped enum\", scope);\n+      return;\n     }\n-  else if (type)\n-    *slot = stat_hack (val, type);\n-  else\n-    *slot = val;\n \n-  /* Emit debug info.  */\n-  cp_emit_debug_info_for_using (orig_decl, current_namespace);\n-}\n+  qualified_namespace_lookup (scope, &lookup);\n \n-/* Process a using-declaration at function scope.  */\n+  if (!lookup.value)\n+    {\n+      error (\"%qD has not been declared in %qE\", name, scope);\n+      return;\n+    }\n \n-void\n-finish_local_using_decl (tree decl, tree scope, tree name)\n-{\n-  tree orig_decl = decl;\n+  if (TREE_CODE (lookup.value) == TREE_LIST\n+      /* But we can (independently) have ambiguous implicit typedefs.  */\n+      || (lookup.type && TREE_CODE (lookup.type) == TREE_LIST))\n+    {\n+      error (\"reference to %qD is ambiguous\", name);\n+      print_candidates (TREE_CODE (lookup.value) == TREE_LIST\n+\t\t\t? lookup.value : lookup.type);\n+      return;\n+    }\n \n-  gcc_checking_assert (current_binding_level->kind != sk_class\n-\t\t       && current_binding_level->kind != sk_namespace);\n-  decl = validate_nonmember_using_decl (decl, scope, name);\n-  if (decl == NULL_TREE)\n-    return;\n+  if (TREE_CODE (lookup.value) == NAMESPACE_DECL)\n+    {\n+      error (\"using-declaration may not name namespace %qD\", lookup.value);\n+      return;\n+    }\n \n-  add_decl_expr (decl);\n+  /* Emit debug info.  */\n+  if (!processing_template_decl)\n+    cp_emit_debug_info_for_using (lookup.value,\n+\t\t\t\t  current_binding_level->this_entity);\n \n-  cxx_binding *binding = find_local_binding (current_binding_level, name);\n-  tree value = binding ? binding->value : NULL_TREE;\n-  tree type = binding ? binding->type : NULL_TREE;\n+  if (current_binding_level->kind == sk_namespace)\n+    {\n+      tree *slot = find_namespace_slot (current_namespace, name, true);\n \n-  do_nonmember_using_decl (scope, name, &value, &type);\n+      tree value = MAYBE_STAT_DECL (*slot);\n+      tree type = MAYBE_STAT_TYPE (*slot);\n \n-  if (!value)\n-    ;\n-  else if (binding && value == binding->value)\n-    ;\n-  else if (binding && binding->value && TREE_CODE (value) == OVERLOAD)\n-    {\n-      update_local_overload (IDENTIFIER_BINDING (name), value);\n-      IDENTIFIER_BINDING (name)->value = value;\n-    }\n-  else\n-    /* Install the new binding.  */\n-    push_local_binding (name, value, true);\n+      do_nonmember_using_decl (lookup, false, true, &value, &type);\n \n-  if (!type)\n-    ;\n-  else if (binding && type == binding->type)\n-    ;\n+      if (STAT_HACK_P (*slot))\n+\t{\n+\t  STAT_DECL (*slot) = value;\n+\t  STAT_TYPE (*slot) = type;\n+\t}\n+      else if (type)\n+\t*slot = stat_hack (value, type);\n+      else\n+\t*slot = value;\n+    }\n   else\n     {\n-      push_local_binding (name, type, true);\n-      set_identifier_type_value (name, type);\n+      tree using_decl = build_lang_decl (USING_DECL, name, NULL_TREE);\n+      USING_DECL_SCOPE (using_decl) = scope;\n+      add_decl_expr (using_decl);\n+\n+      cxx_binding *binding = find_local_binding (current_binding_level, name);\n+      tree value = NULL;\n+      tree type = NULL;\n+      if (binding)\n+\t{\n+\t  value = binding->value;\n+\t  type = binding->type;\n+\t}\n+\n+      /* DR 36 questions why using-decls at function scope may not be\n+\t duplicates.  Disallow it, as C++11 claimed and PR 20420\n+\t implemented.  */\n+      do_nonmember_using_decl (lookup, true, true, &value, &type);\n+\n+      if (!value)\n+\t;\n+      else if (binding && value == binding->value)\n+\t;\n+      else if (binding && binding->value && TREE_CODE (value) == OVERLOAD)\n+\t{\n+\t  update_local_overload (IDENTIFIER_BINDING (name), value);\n+\t  IDENTIFIER_BINDING (name)->value = value;\n+\t}\n+      else\n+\t/* Install the new binding.  */\n+\t// FIXME: Short circuit P_L_B\n+\tpush_local_binding (name, value, true);\n+\n+      if (!type)\n+\t;\n+      else if (binding && type == binding->type)\n+\t;\n+      else\n+\t{\n+\t  push_local_binding (name, type, true);\n+\t  set_identifier_type_value (name, type);\n+\t}\n     }\n \n-  /* Emit debug info.  */\n-  if (!processing_template_decl)\n-    cp_emit_debug_info_for_using (orig_decl, current_scope ());\n }\n \n /* Return the declarations that are members of the namespace NS.  */"}, {"sha": "b44687e96bb6653fe421226fc108b131e456ca90", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/692af872fa50106af090e17cef92481207c33e89/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/692af872fa50106af090e17cef92481207c33e89/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=692af872fa50106af090e17cef92481207c33e89", "patch": "@@ -176,9 +176,6 @@ struct GTY(()) cp_binding_level {\n       are wrapped in TREE_LISTs; the TREE_VALUE is the OVERLOAD.  */\n   tree names;\n \n-  /* A list of USING_DECL nodes.  */\n-  tree usings;\n-\n   /* Using directives.  */\n   vec<tree, va_gc> *using_directives;\n \n@@ -315,9 +312,8 @@ extern tree innermost_non_namespace_value (tree);\n extern cxx_binding *outer_binding (tree, cxx_binding *, bool);\n extern void cp_emit_debug_info_for_using (tree, tree);\n \n-extern void finish_namespace_using_decl (tree, tree, tree);\n-extern void finish_local_using_decl (tree, tree, tree);\n-extern void finish_using_directive (tree, tree);\n+extern void finish_nonmember_using_decl (tree scope, tree name);\n+extern void finish_using_directive (tree target, tree attribs);\n extern tree pushdecl (tree, bool is_friend = false);\n extern tree pushdecl_outermost_localscope (tree);\n extern tree pushdecl_top_level (tree, bool is_friend = false);"}, {"sha": "290f897ec140e79173511c218252e8333e63c7ed", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/692af872fa50106af090e17cef92481207c33e89/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/692af872fa50106af090e17cef92481207c33e89/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=692af872fa50106af090e17cef92481207c33e89", "patch": "@@ -19519,24 +19519,7 @@ cp_parser_using_declaration (cp_parser* parser,\n \t    finish_member_declaration (decl);\n \t}\n       else\n-\t{\n-\t  decl = cp_parser_lookup_name_simple (parser,\n-\t\t\t\t\t       identifier,\n-\t\t\t\t\t       token->location);\n-\t  if (decl == error_mark_node)\n-\t    cp_parser_name_lookup_error (parser, identifier,\n-\t\t\t\t\t decl, NLE_NULL,\n-\t\t\t\t\t token->location);\n-\t  else if (check_for_bare_parameter_packs (decl))\n-\t    {\n-\t      cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n-\t      return false;\n-\t    }\n-\t  else if (!at_namespace_scope_p ())\n-\t    finish_local_using_decl (decl, qscope, identifier);\n-\t  else\n-\t    finish_namespace_using_decl (decl, qscope, identifier);\n-\t}\n+\tfinish_nonmember_using_decl (qscope, identifier);\n     }\n \n   if (!access_declaration_p"}, {"sha": "592adfcf5c1c1c4a53e7c42b7b3e83417f7b2c59", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/692af872fa50106af090e17cef92481207c33e89/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/692af872fa50106af090e17cef92481207c33e89/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=692af872fa50106af090e17cef92481207c33e89", "patch": "@@ -17072,13 +17072,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t    tree name = DECL_NAME (decl);\n \n \t    scope = tsubst (scope, args, complain, in_decl);\n-\t    decl = lookup_qualified_name (scope, name,\n-\t\t\t\t\t  /*is_type_p=*/false,\n-\t\t\t\t\t  /*complain=*/false);\n-\t    if (decl == error_mark_node || TREE_CODE (decl) == TREE_LIST)\n-\t      qualified_name_lookup_error (scope, name, decl, input_location);\n-\t    else\n-\t      finish_local_using_decl (decl, scope, name);\n+\t    finish_nonmember_using_decl (scope, name);\n \t  }\n \telse if (is_capture_proxy (decl)\n \t\t && !DECL_TEMPLATE_INSTANTIATION (current_function_decl))"}, {"sha": "bdc58ba14e44a318e96bdf42d53e7eda45d919ba", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/692af872fa50106af090e17cef92481207c33e89/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/692af872fa50106af090e17cef92481207c33e89/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=692af872fa50106af090e17cef92481207c33e89", "patch": "@@ -1,3 +1,7 @@\n+2019-05-21  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* g++.dg/lookup/using53.C: Adjust diagnostic.\n+\n 2019-05-21  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/90510"}, {"sha": "595612e4efe7d5b748d588e9f3981fef573ed6ae", "filename": "gcc/testsuite/g++.dg/lookup/using53.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/692af872fa50106af090e17cef92481207c33e89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing53.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/692af872fa50106af090e17cef92481207c33e89/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing53.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing53.C?ref=692af872fa50106af090e17cef92481207c33e89", "patch": "@@ -49,5 +49,5 @@ void\n f ()\n {\n   using N::i;\n-  using N::i;       // { dg-error \"declared\" }\n+  using N::i;       // { dg-error \"redeclaration\" }\n }"}, {"sha": "e243e554d6404de2f07c732428a3f43773ce0f2a", "filename": "libcc1/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/692af872fa50106af090e17cef92481207c33e89/libcc1%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/692af872fa50106af090e17cef92481207c33e89/libcc1%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2FChangeLog?ref=692af872fa50106af090e17cef92481207c33e89", "patch": "@@ -1,3 +1,8 @@\n+2019-05-21  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* libcp1plugin.cc (plugin_add_using_decl): Use\n+\tfinish_nonmember_using_decl.\n+\n 2019-05-20  Nathan Sidwell  <nathan@acm.org>\n \n \t* libcp1plugin.cc (plugin_add_using_namespace): Call renamed"}, {"sha": "d241ea1033dfda9e60118074d4b6ceb526a578d2", "filename": "libcc1/libcp1plugin.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/692af872fa50106af090e17cef92481207c33e89/libcc1%2Flibcp1plugin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/692af872fa50106af090e17cef92481207c33e89/libcc1%2Flibcp1plugin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcp1plugin.cc?ref=692af872fa50106af090e17cef92481207c33e89", "patch": "@@ -1019,7 +1019,7 @@ plugin_add_using_decl (cc1_plugin::connection *,\n     {\n       /* We can't be at local scope.  */\n       gcc_assert (at_namespace_scope_p ());\n-      finish_namespace_using_decl (target, tcontext, identifier);\n+      finish_nonmember_using_decl (tcontext, identifier);\n     }\n \n   return 1;"}]}