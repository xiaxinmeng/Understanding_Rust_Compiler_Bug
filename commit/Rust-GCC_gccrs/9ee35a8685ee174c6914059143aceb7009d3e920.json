{"sha": "9ee35a8685ee174c6914059143aceb7009d3e920", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWVlMzVhODY4NWVlMTc0YzY5MTQwNTkxNDNhY2ViNzAwOWQzZTkyMA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-04-27T12:06:43Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-04-27T13:04:36Z"}, "message": "libstdc++: Better preprocessor conditions in net::ip [PR 100286]\n\nThis improves the use of preprocessor conditionas to enable/disable\nmembers of namespace net::ip according to what is supported by the\ntarget. This fixes PR 100286 by ensuring that the to_string member\nfunctions are always defined for the address_v4 and address_v6 classes.\nOn the other hand, the IP protocol classes and internet socket option\nclasses aren't useful at all if the corresponding constants (such as\nIPPROTO_TCP or IPV6_MULTICAST_HOPS) aren't define. So those types are\nnot defined at all if they can't be used.\n\nThe net/internet/socket/opt.cc test uses __has_include to check whether\nor not to expect the types to be available.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/100286\n\t* include/experimental/internet (resolver_errc, resolver_category())\n\t(make_error_code, make_error_condition): Define unconditionally,\n\tonly make enumerators and use of gai_strerror depend on the\n\tavailability of <netdb.h>.\n\t(address_v4::to_string): Use correct constant for string length.\n\t(address_v4::to_string, address_v6::to_string): Define\n\tunconditionally, throw if unsupported.\n\t(make_address_v4, make_address_v6): Define unconditionally.\n\tReturn an error if unsupported.\n\t(tcp, udp, v6_only, unicast::hops, multicast::*): Define\n\tconditionally,\n\t* testsuite/experimental/net/internet/socket/opt.cc: Check for\n\t<netinet/in.h> and <netinet/tcp.h> before using types from\n\tnamespace net::ip.", "tree": {"sha": "78d0c0a9f2212f3b9f17b8bf7d85514b7ecfd665", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78d0c0a9f2212f3b9f17b8bf7d85514b7ecfd665"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ee35a8685ee174c6914059143aceb7009d3e920", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ee35a8685ee174c6914059143aceb7009d3e920", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ee35a8685ee174c6914059143aceb7009d3e920", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ee35a8685ee174c6914059143aceb7009d3e920/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8aadb4fedb17e7a44583a7a5a4e96b1874e1ce98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aadb4fedb17e7a44583a7a5a4e96b1874e1ce98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8aadb4fedb17e7a44583a7a5a4e96b1874e1ce98"}], "stats": {"total": 66, "additions": 55, "deletions": 11}, "files": [{"sha": "6c3fad6d2aae7b13d37775300fad6195fa2d29da", "filename": "libstdc++-v3/include/experimental/internet", "status": "modified", "additions": 46, "deletions": 11, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ee35a8685ee174c6914059143aceb7009d3e920/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Finternet", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ee35a8685ee174c6914059143aceb7009d3e920/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Finternet", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Finternet?ref=9ee35a8685ee174c6914059143aceb7009d3e920", "patch": "@@ -72,20 +72,20 @@ inline namespace v1\n {\n namespace ip\n {\n-\n   /** @addtogroup networking-ts\n    *  @{\n    */\n \n-#ifdef _GLIBCXX_HAVE_NETDB_H\n   /** Error codes for resolver errors.\n    * @{\n    */\n \n   enum class resolver_errc : int {\n+#ifdef _GLIBCXX_HAVE_NETDB_H\n     host_not_found = EAI_NONAME,\n     host_not_found_try_again = EAI_AGAIN,\n     service_not_found = EAI_SERVICE\n+#endif\n   };\n \n   /// Error category for resolver errors.\n@@ -94,7 +94,13 @@ namespace ip\n     struct __cat : error_category\n     {\n       const char* name() const noexcept { return \"resolver\"; }\n-      std::string message(int __e) const { return ::gai_strerror(__e); }\n+      std::string message(int __e) const {\n+#ifdef _GLIBCXX_HAVE_NETDB_H\n+\t  return ::gai_strerror(__e);\n+#else\n+\t  return \"name resolution requires <netdb.h>\";\n+#endif\n+      }\n       virtual void __message(int) { } // TODO dual ABI XXX\n     };\n     static __cat __c;\n@@ -108,7 +114,6 @@ namespace ip\n   { return error_condition(static_cast<int>(__e), resolver_category()); }\n \n   /// @}\n-#endif\n \n   using port_type = uint_least16_t;\t///< Type used for port numbers.\n   using scope_id_type = uint_least32_t;\t///< Type used for IPv6 scope IDs.\n@@ -119,6 +124,16 @@ namespace ip\n       = enable_if_t<std::is_same<typename _Alloc::value_type, char>::value,\n \t\t    std::basic_string<char, std::char_traits<char>, _Alloc>>;\n \n+  constexpr errc\n+  __unsupported_err() noexcept\n+  {\n+#if defined EAFNOSUPPORT\n+    return std::errc::address_family_not_supported;\n+#else\n+    return std::errc::operation_not_supported;\n+#endif\n+  }\n+\n   /** Tag indicating conversion between IPv4 and IPv4-mapped IPv6 addresses.\n    * @{\n    */\n@@ -197,20 +212,22 @@ namespace ip\n     constexpr uint_type\n     to_uint() const noexcept { return _S_ntoh_32(_M_addr); }\n \n-#ifdef _GLIBCXX_HAVE_ARPA_INET_H\n     template<typename _Allocator = allocator<char>>\n       __string_with<_Allocator>\n       to_string(const _Allocator& __a = _Allocator()) const\n       {\n+#ifdef _GLIBCXX_HAVE_ARPA_INET_H\n \t__string_with<_Allocator> __str(__a);\n-\t__str.resize(INET6_ADDRSTRLEN);\n+\t__str.resize(INET_ADDRSTRLEN);\n \tif (inet_ntop(AF_INET, &_M_addr, &__str.front(), __str.size()))\n \t  __str.erase(__str.find('\\0'));\n \telse\n \t  __str.resize(0);\n \treturn __str;\n-      }\n+#else\n+\tstd::__throw_system_error((int)__unsupported_err());\n #endif\n+      }\n \n     // static members:\n     static constexpr address_v4 any() noexcept { return address_v4{}; }\n@@ -338,11 +355,11 @@ namespace ip\n \n     constexpr bytes_type to_bytes() const noexcept { return _M_bytes; }\n \n-#ifdef _GLIBCXX_HAVE_ARPA_INET_H\n     template<typename _Allocator = allocator<char>>\n       __string_with<_Allocator>\n       to_string(const _Allocator& __a = _Allocator()) const\n       {\n+#ifdef _GLIBCXX_HAVE_ARPA_INET_H\n \t__string_with<_Allocator> __str(__a);\n \t__str.resize(INET6_ADDRSTRLEN + (_M_scope_id ? 11 : 0));\n \tchar* const __p = &__str.front();\n@@ -364,8 +381,10 @@ namespace ip\n \telse\n \t  __str.resize(0);\n \treturn __str;\n-      }\n+#else\n+\tstd::__throw_system_error((int)__unsupported_err());\n #endif\n+      }\n \n     // static members:\n \n@@ -650,6 +669,7 @@ namespace ip\n   inline address_v4\n   make_address_v4(const char* __str, error_code& __ec) noexcept\n   {\n+#ifdef _GLIBCXX_HAVE_ARPA_INET_H\n     address_v4 __a;\n     const int __res = ::inet_pton(AF_INET, __str, &__a._M_addr);\n     if (__res == 1)\n@@ -661,6 +681,9 @@ namespace ip\n       __ec = std::make_error_code(std::errc::invalid_argument);\n     else\n       __ec.assign(errno, generic_category());\n+#else\n+    __ec = std::make_error_code(__unsupported_err());\n+#endif\n     return {};\n   }\n \n@@ -718,8 +741,9 @@ namespace ip\n   inline address_v6\n   __make_address_v6(const char* __addr, const char* __scope, error_code& __ec)\n   {\n+#ifdef _GLIBCXX_HAVE_ARPA_INET_H\n     address_v6::bytes_type __b;\n-    int __res = ::inet_pton(AF_INET6, __addr, __b.data());\n+    const int __res = ::inet_pton(AF_INET6, __addr, __b.data());\n     if (__res == 1)\n       {\n \t__ec.clear();\n@@ -741,6 +765,9 @@ namespace ip\n       __ec = std::make_error_code(std::errc::invalid_argument);\n     else\n       __ec.assign(errno, generic_category());\n+#else\n+    __ec = std::make_error_code(__unsupported_err());\n+#endif\n     return {};\n   }\n \n@@ -2062,6 +2089,7 @@ namespace ip\n \n   /// @}\n \n+#ifdef IPPROTO_TCP\n   /// The TCP byte-stream protocol.\n   class tcp\n   {\n@@ -2073,7 +2101,7 @@ namespace ip\n     using acceptor = basic_socket_acceptor<tcp>; ///< A TCP acceptor.\n     using iostream = basic_socket_iostream<tcp>; /// A TCP iostream.\n \n-#ifdef _GLIBCXX_HAVE_NETINET_TCP_H\n+#ifdef TCP_NODELAY\n     /// Disable coalescing of small segments (i.e. the Nagle algorithm).\n     struct no_delay : __sockopt_crtp<no_delay, bool>\n     {\n@@ -2117,7 +2145,9 @@ namespace ip\n   { return !(__a == __b); }\n \n   /// @}\n+#endif // IPPROTO_TCP\n \n+#ifdef IPPROTO_UDP\n   /// The UDP datagram protocol.\n   class udp\n   {\n@@ -2156,6 +2186,9 @@ namespace ip\n   { return !(__a == __b); }\n \n   /// @}\n+#endif // IPPROTO_UDP\n+\n+#if defined IPPROTO_IP && defined IPPROTO_IPV6\n \n   /// Restrict a socket created for an IPv6 protocol to IPv6 only.\n   class v6_only : public __sockopt_crtp<v6_only, bool>\n@@ -2371,6 +2404,8 @@ namespace ip\n \n   } // namespace multicast\n \n+#endif // IPPROTO_IP && IPPROTO_IPV6\n+\n   /// @}\n \n } // namespace ip"}, {"sha": "cfbc00f9da8e50a461768915dda53dbe89332d3a", "filename": "libstdc++-v3/testsuite/experimental/net/internet/socket/opt.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ee35a8685ee174c6914059143aceb7009d3e920/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Finternet%2Fsocket%2Fopt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ee35a8685ee174c6914059143aceb7009d3e920/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Finternet%2Fsocket%2Fopt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Finternet%2Fsocket%2Fopt.cc?ref=9ee35a8685ee174c6914059143aceb7009d3e920", "patch": "@@ -49,8 +49,10 @@ template<typename C, typename T = int>\n void check_boolean_sockopt()\n {\n   namespace ip = std::experimental::net::ip;\n+#if __has_include(<netinet/in.h>)\n   check_gettable_sockopt<C, T>(ip::tcp::v4());\n   check_settable_sockopt<C, T>(ip::tcp::v4());\n+#endif\n \n   static_assert( is_destructible<C>(), \"\" );\n   static_assert( is_nothrow_default_constructible<C>(), \"\" );\n@@ -74,8 +76,10 @@ template<typename C, typename T = int>\n void check_integer_sockopt()\n {\n   namespace ip = std::experimental::net::ip;\n+#if __has_include(<netinet/in.h>)\n   check_gettable_sockopt<C, T>(ip::tcp::v4());\n   check_settable_sockopt<C, T>(ip::tcp::v4());\n+#endif\n \n   static_assert( is_destructible<C>(), \"\" );\n   static_assert( is_nothrow_default_constructible<C>(), \"\" );\n@@ -97,8 +101,10 @@ void check_mcast_sockopt(C& c)\n   static_assert( is_copy_constructible<C>(), \"\" );\n   static_assert( is_copy_assignable<C>(), \"\" );\n \n+#if __has_include(<netinet/in.h>)\n   check_settable_sockopt<C, ipv6_mreq>(ip::tcp::v6(), c);\n   check_settable_sockopt<C, ip_mreq>(ip::tcp::v4(), c);\n+#endif\n \n   static_assert( is_nothrow_constructible<C, const ip::address&>(), \"\" );\n   static_assert( ! is_convertible<const ip::address&, C>(), \"explicit\" );\n@@ -113,8 +119,11 @@ void check_mcast_sockopt(C& c)\n void test_option_types()\n {\n   namespace ip = std::experimental::net::ip;\n+\n #if __has_include(<netinet/in.h>)\n+#if __has_include(<netinet/tcp.h>)\n   check_boolean_sockopt<ip::tcp::no_delay>();\n+#endif\n \n   check_boolean_sockopt<ip::v6_only>();\n "}]}