{"sha": "a848cf52b5e71ebeb05a23888ff3660c4f5012b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTg0OGNmNTJiNWU3MWViZWIwNWEyMzg4OGZmMzY2MGM0ZjUwMTJiOA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2008-10-29T15:12:28Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2008-10-29T15:12:28Z"}, "message": "bfin.c (struct machine_function): New member has_loopreg_clobber.\n\n\t* config/bfin/bfin.c (struct machine_function): New member\n\thas_loopreg_clobber.\n\t(bfin_expand_movmem): Set it when generating memcpy insns.\n\t(n_regs_saved_by_prologue, expand_prologue_reg_save,\n\texpand_epilogue_reg_restore): If we have hardware loops,\n\tmemcpy insns (indicated by has_loopreg_clobber) or function\n\tcalls, we need to save the loop registers.\n\nFrom-SVN: r141425", "tree": {"sha": "5ff9fd3890a2e19a7516577f05a62978f06b18e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ff9fd3890a2e19a7516577f05a62978f06b18e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a848cf52b5e71ebeb05a23888ff3660c4f5012b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a848cf52b5e71ebeb05a23888ff3660c4f5012b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a848cf52b5e71ebeb05a23888ff3660c4f5012b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a848cf52b5e71ebeb05a23888ff3660c4f5012b8/comments", "author": null, "committer": null, "parents": [{"sha": "7e51fe23ab9e0781f59a96c3101dd36fd28bb657", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e51fe23ab9e0781f59a96c3101dd36fd28bb657", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e51fe23ab9e0781f59a96c3101dd36fd28bb657"}], "stats": {"total": 47, "additions": 44, "deletions": 3}, "files": [{"sha": "643ca32594b105ab68b5217489ab7a8c8de41b7b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a848cf52b5e71ebeb05a23888ff3660c4f5012b8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a848cf52b5e71ebeb05a23888ff3660c4f5012b8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a848cf52b5e71ebeb05a23888ff3660c4f5012b8", "patch": "@@ -1,3 +1,13 @@\n+2008-10-29  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\t* config/bfin/bfin.c (struct machine_function): New member\n+\thas_loopreg_clobber.\n+\t(bfin_expand_movmem): Set it when generating memcpy insns.\n+\t(n_regs_saved_by_prologue, expand_prologue_reg_save,\n+\texpand_epilogue_reg_restore): If we have hardware loops,\n+\tmemcpy insns (indicated by has_loopreg_clobber) or function\n+\tcalls, we need to save the loop registers.\n+\n 2008-10-28  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* config/i386/i386.c (core2_cost): Fix typos in comments."}, {"sha": "5a289dfccf4b5a740d7a875448833acd1269eb96", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a848cf52b5e71ebeb05a23888ff3660c4f5012b8/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a848cf52b5e71ebeb05a23888ff3660c4f5012b8/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=a848cf52b5e71ebeb05a23888ff3660c4f5012b8", "patch": "@@ -60,7 +60,11 @@\n    This is added to the cfun structure.  */\n struct machine_function GTY(())\n {\n+  /* Set if we are notified by the doloop pass that a hardware loop\n+     was created.  */\n   int has_hardware_loops;\n+  /* Set if we create a memcpy pattern that uses loop registers.  */\n+  int has_loopreg_clobber;\n };\n \n /* Test and compare insns in bfin.md store the information needed to\n@@ -544,7 +548,16 @@ expand_prologue_reg_save (rtx spreg, int saveall, bool is_inthandler)\n   if (saveall || is_inthandler)\n     {\n       rtx insn = emit_move_insn (predec, gen_rtx_REG (SImode, REG_ASTAT));\n+\n       RTX_FRAME_RELATED_P (insn) = 1;\n+      if (! current_function_is_leaf\n+\t  || cfun->machine->has_hardware_loops\n+\t  || cfun->machine->has_loopreg_clobber)\n+\tfor (dregno = REG_LT0; dregno <= REG_LB1; dregno++)\n+\t  {\n+\t    insn = emit_move_insn (predec, gen_rtx_REG (SImode, dregno));\n+\t    RTX_FRAME_RELATED_P (insn) = 1;\n+\t  }\n     }\n \n   if (total_consec != 0)\n@@ -714,7 +727,15 @@ expand_epilogue_reg_restore (rtx spreg, bool saveall, bool is_inthandler)\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n   if (saveall || is_inthandler)\n-    emit_move_insn (gen_rtx_REG (SImode, REG_ASTAT), postinc);\n+    {\n+      if (! current_function_is_leaf\n+\t  || cfun->machine->has_hardware_loops\n+\t  || cfun->machine->has_loopreg_clobber)\n+\tfor (regno = REG_LB1; regno >= REG_LT0; regno--)\n+\t  emit_move_insn (gen_rtx_REG (SImode, regno), postinc);\n+\n+      emit_move_insn (gen_rtx_REG (SImode, REG_ASTAT), postinc);\n+    }\n }\n \n /* Perform any needed actions needed for a function that is receiving a\n@@ -813,8 +834,16 @@ n_regs_saved_by_prologue (void)\n     }\n \n   if (fkind != SUBROUTINE || all)\n-    /* Increment once for ASTAT.  */\n-    n++;\n+    {\n+      /* Increment once for ASTAT.  */\n+      n++;\n+      if (! current_function_is_leaf\n+\t  || cfun->machine->has_hardware_loops\n+\t  || cfun->machine->has_loopreg_clobber)\n+\t{\n+\t  n += 6;\n+\t}\n+    }\n \n   if (fkind != SUBROUTINE)\n     {\n@@ -3398,6 +3427,7 @@ bfin_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp)\n \t      countreg = copy_to_mode_reg (Pmode, GEN_INT (new_count));\n \n \t      emit_insn (gen_rep_movsi (destreg, srcreg, countreg, destreg, srcreg));\n+\t      cfun->machine->has_loopreg_clobber = true;\n \t    }\n \t  if (count & 2)\n \t    {\n@@ -3418,6 +3448,7 @@ bfin_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp)\n \t      countreg = copy_to_mode_reg (Pmode, GEN_INT (new_count));\n \n \t      emit_insn (gen_rep_movhi (destreg, srcreg, countreg, destreg, srcreg));\n+\t      cfun->machine->has_loopreg_clobber = true;\n \t    }\n \t}\n       if (count & 1)"}]}