{"sha": "f30efcb78a1e867cd78017f872dd0c2a1064adfb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjMwZWZjYjc4YTFlODY3Y2Q3ODAxN2Y4NzJkZDBjMmExMDY0YWRmYg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2001-01-03T03:28:51Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2001-01-03T03:28:51Z"}, "message": "init.c (build_default_init): New fn.\n\n        * init.c (build_default_init): New fn.\n        (perform_member_init): Split out from here.\n        (build_new_1): Use it.  Simplify initialization logic.\n        (build_vec_init): Take an array, rather than a pointer and maxindex.\n        Speed up simple initializations.  Don't clean up if we're assigning.\n        * cp-tree.h: Adjust.\n        * decl2.c (do_static_initialization): Remove TREE_VEC case.\n        * parse.y (new_initializer): Return void_zero_node for ().\n        * typeck.c (build_modify_expr): Handle getting a CONSTRUCTOR.\n        * typeck2.c (digest_init): Only complain about user-written\n        CONSTRUCTORs.\n\nFrom-SVN: r38643", "tree": {"sha": "283386e3c949a3a24ebf975086eb02c0d52e8c32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/283386e3c949a3a24ebf975086eb02c0d52e8c32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f30efcb78a1e867cd78017f872dd0c2a1064adfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f30efcb78a1e867cd78017f872dd0c2a1064adfb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f30efcb78a1e867cd78017f872dd0c2a1064adfb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f30efcb78a1e867cd78017f872dd0c2a1064adfb/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a412bf75d904604bc4cb05e888663ad70e4008cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a412bf75d904604bc4cb05e888663ad70e4008cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a412bf75d904604bc4cb05e888663ad70e4008cf"}], "stats": {"total": 359, "additions": 192, "deletions": 167}, "files": [{"sha": "4b81b72da3e154023e59226ace51b36769a68726", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30efcb78a1e867cd78017f872dd0c2a1064adfb/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30efcb78a1e867cd78017f872dd0c2a1064adfb/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f30efcb78a1e867cd78017f872dd0c2a1064adfb", "patch": "@@ -1,3 +1,17 @@\n+2001-01-03  Jason Merrill  <jason@redhat.com>\n+\n+\t* init.c (build_default_init): New fn.\n+\t(perform_member_init): Split out from here.\n+\t(build_new_1): Use it.  Simplify initialization logic.\n+\t(build_vec_init): Take an array, rather than a pointer and maxindex.\n+\tSpeed up simple initializations.  Don't clean up if we're assigning.\n+\t* cp-tree.h: Adjust.\n+\t* decl2.c (do_static_initialization): Remove TREE_VEC case.\n+\t* parse.y (new_initializer): Return void_zero_node for ().\n+\t* typeck.c (build_modify_expr): Handle getting a CONSTRUCTOR.\n+\t* typeck2.c (digest_init): Only complain about user-written\n+\tCONSTRUCTORs.\n+\n 2000-12-22  Mike Stump  <mrs@wrs.com>\n \n \t* decl2.c: (max_tinst_depth): Increase to 50."}, {"sha": "8d5c5127a9909e99c75508b6701d4e3d0d0f4144", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30efcb78a1e867cd78017f872dd0c2a1064adfb/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30efcb78a1e867cd78017f872dd0c2a1064adfb/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f30efcb78a1e867cd78017f872dd0c2a1064adfb", "patch": "@@ -4047,7 +4047,7 @@ extern tree build_member_call\t\t\tPARAMS ((tree, tree, tree));\n extern tree build_offset_ref\t\t\tPARAMS ((tree, tree));\n extern tree resolve_offset_ref\t\t\tPARAMS ((tree));\n extern tree build_new\t\t\t\tPARAMS ((tree, tree, tree, int));\n-extern tree build_vec_init\t\t\tPARAMS ((tree, tree, tree, tree, int));\n+extern tree build_vec_init\t\t\tPARAMS ((tree, tree, int));\n extern tree build_x_delete\t\t\tPARAMS ((tree, int, tree));\n extern tree build_delete\t\t\tPARAMS ((tree, tree, special_function_kind, int, int));\n extern tree build_vbase_delete\t\t\tPARAMS ((tree, tree));"}, {"sha": "9b4daa048325be6767d196b924ee25a07f806977", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30efcb78a1e867cd78017f872dd0c2a1064adfb/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30efcb78a1e867cd78017f872dd0c2a1064adfb/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=f30efcb78a1e867cd78017f872dd0c2a1064adfb", "patch": "@@ -3394,10 +3394,6 @@ do_static_initialization (decl, init)\n   if (IS_AGGR_TYPE (TREE_TYPE (decl))\n       || TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n     expr = build_aggr_init (decl, init, 0);\n-  else if (TREE_CODE (init) == TREE_VEC)\n-    expr = build_vec_init (decl, TREE_VEC_ELT (init, 0),\n-\t\t\t   TREE_VEC_ELT (init, 1),\n-\t\t\t   TREE_VEC_ELT (init, 2), 0);\n   else\n     {\n       expr = build (INIT_EXPR, TREE_TYPE (decl), decl, init);"}, {"sha": "9d20955a7533f2f52d44e87367e16c01d8fb55fd", "filename": "gcc/cp/init.c", "status": "modified", "additions": 164, "deletions": 155, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30efcb78a1e867cd78017f872dd0c2a1064adfb/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30efcb78a1e867cd78017f872dd0c2a1064adfb/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=f30efcb78a1e867cd78017f872dd0c2a1064adfb", "patch": "@@ -49,6 +49,7 @@ static tree initializing_context PARAMS ((tree));\n static void expand_cleanup_for_base PARAMS ((tree, tree));\n static tree get_temp_regvar PARAMS ((tree, tree));\n static tree dfs_initialize_vtbl_ptrs PARAMS ((tree, void *));\n+static tree build_default_init PARAMS ((tree));\n static tree build_new_1\tPARAMS ((tree));\n static tree get_cookie_size PARAMS ((tree));\n static tree build_dtor_call PARAMS ((tree, special_function_kind, int));\n@@ -193,6 +194,50 @@ initialize_vtbl_ptrs (addr)\n     fixup_all_virtual_upcast_offsets (addr);\n }\n \n+/* [dcl.init]:\n+\n+  To default-initialize an object of type T means:\n+\n+  --if T is a non-POD class type (clause _class_), the default construc-\n+    tor  for  T is called (and the initialization is ill-formed if T has\n+    no accessible default constructor);\n+\n+  --if T is an array type, each element is default-initialized;\n+\n+  --otherwise, the storage for the object is zero-initialized.\n+\n+  A program that calls for default-initialization of an entity of refer-\n+  ence type is ill-formed.  */\n+\n+static tree\n+build_default_init (type)\n+     tree type;\n+{\n+  tree init = NULL_TREE;\n+\n+  if (TYPE_NEEDS_CONSTRUCTING (type))\n+    /* Other code will handle running the default constructor.  We can't do\n+       anything with a CONSTRUCTOR for arrays here, as that would imply\n+       copy-initialization.  */\n+    return NULL_TREE;\n+  else if (AGGREGATE_TYPE_P (type))\n+    {\n+      /* This is a default initialization of an aggregate, but not one of\n+\t non-POD class type.  We cleverly notice that the initialization\n+\t rules in such a case are the same as for initialization with an\n+\t empty brace-initialization list.  */\n+      init = build (CONSTRUCTOR, NULL_TREE, NULL_TREE, NULL_TREE);\n+    }\n+  else if (TREE_CODE (type) == REFERENCE_TYPE)\n+    /*   --if T is a reference type, no initialization is performed.  */\n+    return NULL_TREE;\n+  else\n+    init = integer_zero_node;\n+\n+  init = digest_init (type, init, 0);\n+  return init;\n+}\n+\n /* Subroutine of emit_base_init.  */\n \n static void\n@@ -234,9 +279,7 @@ perform_member_init (member, init, explicit)\n \t  && TREE_CODE (TREE_TYPE (TREE_VALUE (init))) == ARRAY_TYPE)\n \t{\n \t  /* Initialization of one array from another.  */\n-\t  finish_expr_stmt \n-\t    (build_vec_init (TREE_OPERAND (decl, 1), decl,\n-\t\t\t     array_type_nelts (type), TREE_VALUE (init), 1));\n+\t  finish_expr_stmt (build_vec_init (decl, TREE_VALUE (init), 1));\n \t}\n       else\n \tfinish_expr_stmt (build_aggr_init (decl, init, 0));\n@@ -247,28 +290,14 @@ perform_member_init (member, init, explicit)\n \t{\n \t  if (explicit)\n \t    {\n-\t      /* default-initialization.  */\n-\t      if (AGGREGATE_TYPE_P (type))\n-\t\t{\n-\t\t  /* This is a default initialization of an aggregate,\n-\t\t     but not one of non-POD class type.  We cleverly\n-\t\t     notice that the initialization rules in such a\n-\t\t     case are the same as for initialization with an\n-\t\t     empty brace-initialization list.  We don't want\n-\t\t     to call build_modify_expr as that will go looking\n-\t\t     for constructors and such.  */\n-\t\t  tree e = build (CONSTRUCTOR, type, NULL_TREE, NULL_TREE);\n-\t\t  TREE_SIDE_EFFECTS (e) = 1;\n-\t\t  finish_expr_stmt (build (INIT_EXPR, type, decl, e));\n-\t\t}\n- \t      else if (TREE_CODE (type) == REFERENCE_TYPE)\n-\t\tcp_error (\"default-initialization of `%#D', which has reference type\",\n-\t\t\t  member);\n-\t      else\n-\t\tinit = integer_zero_node;\n+\t      init = build_default_init (type);\n+\t      if (TREE_CODE (type) == REFERENCE_TYPE)\n+\t\tcp_warning\n+\t\t  (\"default-initialization of `%#D', which has reference type\",\n+\t\t   member);\n \t    }\n \t  /* member traversal: note it leaves init NULL */\n-\t  else if (TREE_CODE (TREE_TYPE (member)) == REFERENCE_TYPE)\n+\t  else if (TREE_CODE (type) == REFERENCE_TYPE)\n \t    cp_pedwarn (\"uninitialized reference member `%D'\", member);\n \t}\n       else if (TREE_CODE (init) == TREE_LIST)\n@@ -1212,7 +1241,7 @@ build_aggr_init (exp, init, flags)\n \t  if (init)\n \t    TREE_TYPE (init) = TYPE_MAIN_VARIANT (itype);\n \t}\n-      stmt_expr = build_vec_init (exp, exp, array_type_nelts (type), init,\n+      stmt_expr = build_vec_init (exp, init,\n \t\t\t\t  init && same_type_p (TREE_TYPE (init),\n \t\t\t\t\t\t       TREE_TYPE (exp)));\n       TREE_READONLY (exp) = was_const;\n@@ -2237,6 +2266,7 @@ build_new_1 (exp)\n {\n   tree placement, init;\n   tree type, true_type, size, rval, t;\n+  tree full_type;\n   tree nelts = NULL_TREE;\n   tree alloc_call, alloc_expr, alloc_node;\n   tree cookie_expr, init_expr;\n@@ -2264,7 +2294,14 @@ build_new_1 (exp)\n       has_array = 1;\n       nelts = TREE_OPERAND (type, 1);\n       type = TREE_OPERAND (type, 0);\n+\n+      full_type = cp_build_binary_op (MINUS_EXPR, nelts, integer_one_node);\n+      full_type = build_index_type (full_type);\n+      full_type = build_cplus_array_type (type, full_type);\n     }\n+  else\n+    full_type = type;\n+\n   true_type = type;\n \n   code = has_array ? VEC_NEW_EXPR : NEW_EXPR;\n@@ -2395,7 +2432,10 @@ build_new_1 (exp)\n     /* Adjust so we're pointing to the start of the object.  */\n     alloc_expr = build (PLUS_EXPR, TREE_TYPE (alloc_expr),\n \t\t\talloc_expr, cookie_size);\n-  alloc_expr = convert (build_pointer_type (type), alloc_expr);\n+\n+  /* While we're working, use a pointer to the type we've actually\n+     allocated.  */\n+  alloc_expr = convert (build_pointer_type (full_type), alloc_expr);\n \n   /* Now save the allocation expression so we only evaluate it once.  */\n   alloc_expr = get_target_expr (alloc_expr);\n@@ -2434,66 +2474,40 @@ build_new_1 (exp)\n   init_expr = NULL_TREE;\n   if (TYPE_NEEDS_CONSTRUCTING (type) || init)\n     {\n-      if (! TYPE_NEEDS_CONSTRUCTING (type)\n-\t  && ! IS_AGGR_TYPE (type) && ! has_array)\n+      init_expr = build_indirect_ref (alloc_node, NULL_PTR);\n+\n+      if (init == void_zero_node)\n+\tinit = build_default_init (full_type);\n+      else if (init && pedantic && has_array)\n+\tcp_pedwarn (\"ISO C++ forbids initialization in array new\");\n+\n+      if (has_array)\n+\tinit_expr = build_vec_init (init_expr, init, 0);\n+      else if (TYPE_NEEDS_CONSTRUCTING (type))\n+\tinit_expr = build_method_call (init_expr, \n+\t\t\t\t       complete_ctor_identifier,\n+\t\t\t\t       init, TYPE_BINFO (true_type),\n+\t\t\t\t       LOOKUP_NORMAL);\n+      else\n \t{\n \t  /* We are processing something like `new int (10)', which\n \t     means allocate an int, and initialize it with 10.  */\n-\t  tree deref;\n-\t  tree deref_type;\n-\n-\t  deref = build_indirect_ref (alloc_node, NULL_PTR);\n-\n-\t  /* Even for something like `new const int (10)' we must\n-\t     allow the expression to be non-const while we do the\n-\t     initialization.  */\n-\t  deref_type = TREE_TYPE (deref);\n-\t  if (CP_TYPE_CONST_P (deref_type))\n-\t    TREE_TYPE (deref) \n-\t      = cp_build_qualified_type (deref_type,\n-\t\t\t\t\t CP_TYPE_QUALS (deref_type) \n-\t\t\t\t\t & ~TYPE_QUAL_CONST);\n-\t  TREE_READONLY (deref) = 0;\n-\n-\t  if (TREE_CHAIN (init) != NULL_TREE)\n-\t    pedwarn\n-\t      (\"initializer list being treated as compound expression\");\n-\t  else if (TREE_CODE (init) == CONSTRUCTOR)\n+\n+\t  if (TREE_CODE (init) == TREE_LIST)\n \t    {\n-\t      pedwarn\n-\t\t(\"initializer list appears where operand should be used\");\n-\t      init = TREE_OPERAND (init, 1);\n+\t      if (TREE_CHAIN (init) != NULL_TREE)\n+\t\tpedwarn\n+\t\t  (\"initializer list being treated as compound expression\");\n+\t      init = build_compound_expr (init);\n+\t    }\n+\t  else if (TREE_CODE (init) == CONSTRUCTOR\n+\t\t   && TREE_TYPE (init) == NULL_TREE)\n+\t    {\n+\t      pedwarn (\"ISO C++ forbids aggregate initializer to new\");\n+\t      init = digest_init (type, init, 0);\n \t    }\n-\t  init = build_compound_expr (init);\n-\n-\t  init = convert_for_initialization (deref, type, init, LOOKUP_NORMAL,\n-\t\t\t\t\t     \"new\", NULL_TREE, 0);\n-\t  init_expr = build_modify_expr (deref, NOP_EXPR, init);\n-\t}\n-      else if (! has_array)\n-\t{\n-\t  /* Constructors are never virtual. If it has an initialization, we\n-\t     need to complain if we aren't allowed to use the ctor that took\n-\t     that argument.  */\n-\t  int flags = LOOKUP_NORMAL|LOOKUP_NONVIRTUAL|LOOKUP_COMPLAIN;\n-\n-\t  init_expr = build_indirect_ref (alloc_node, NULL_PTR);\n \n-\t  init_expr = build_method_call (init_expr, \n-\t\t\t\t\t complete_ctor_identifier,\n-\t\t\t\t\t init, TYPE_BINFO (true_type), flags);\n-\t}\n-      else\n-\t{\n-\t  if (init && pedantic)\n-\t    cp_pedwarn (\"initialization in array new\");\n-\n-\t  init_expr = convert (build_pointer_type (true_type), alloc_node);\n-\t  init_expr = (build_vec_init\n-\t\t       (NULL_TREE, init_expr,\n-\t\t\tcp_build_binary_op (MINUS_EXPR, nelts,\n-\t\t\t\t\t    integer_one_node),\n-\t\t\tinit, /*from_array=*/0));\n+\t  init_expr = build_modify_expr (init_expr, INIT_EXPR, init);\n \t}\n \n       if (init_expr == error_mark_node)\n@@ -2577,16 +2591,22 @@ build_new_1 (exp)\n   if (rval == alloc_node)\n     /* If we didn't modify anything, strip the TARGET_EXPR and return the\n        (adjusted) call.  */\n-    return TREE_OPERAND (alloc_expr, 1);\n-\n-  if (check_new)\n+    rval = TREE_OPERAND (alloc_expr, 1);\n+  else\n     {\n-      tree ifexp = cp_build_binary_op (NE_EXPR, alloc_node,\n-\t\t\t\t       integer_zero_node);\n-      rval = build_conditional_expr (ifexp, rval, alloc_node);\n+      if (check_new)\n+\t{\n+\t  tree ifexp = cp_build_binary_op (NE_EXPR, alloc_node,\n+\t\t\t\t\t   integer_zero_node);\n+\t  rval = build_conditional_expr (ifexp, rval, alloc_node);\n+\t}\n+\n+      rval = build (COMPOUND_EXPR, TREE_TYPE (rval), alloc_expr, rval);\n     }\n \n-  rval = build (COMPOUND_EXPR, TREE_TYPE (rval), alloc_expr, rval);\n+  /* Now strip the outer ARRAY_TYPE, so we return a pointer to the first\n+     element.  */\n+  rval = convert (build_pointer_type (type), rval);\n \n   return rval;\n }\n@@ -2767,12 +2787,7 @@ get_temp_regvar (type, init)\n /* `build_vec_init' returns tree structure that performs\n    initialization of a vector of aggregate types.\n \n-   DECL is passed only for error reporting, and provides line number\n-   and source file name information.\n-   BASE is the space where the vector will be.  For a vector of Ts,\n-     the type of BASE is `T*'.\n-   MAXINDEX is the maximum index of the array (one less than the\n-\t    number of elements).\n+   BASE is a reference to the vector, of ARRAY_TYPE.\n    INIT is the (possibly NULL) initializer.\n \n    FROM_ARRAY is 0 if we should init everything with INIT\n@@ -2783,17 +2798,19 @@ get_temp_regvar (type, init)\n    but use assignment instead of initialization.  */\n \n tree\n-build_vec_init (decl, base, maxindex, init, from_array)\n-     tree decl, base, maxindex, init;\n+build_vec_init (base, init, from_array)\n+     tree base, init;\n      int from_array;\n {\n   tree rval;\n   tree base2 = NULL_TREE;\n   tree size;\n   tree itype = NULL_TREE;\n   tree iterator;\n+  /* The type of the array.  */\n+  tree atype = TREE_TYPE (base);\n   /* The type of an element in the array.  */\n-  tree type;\n+  tree type = TREE_TYPE (atype);\n   /* The type of a pointer to an element in the array.  */\n   tree ptype;\n   tree stmt_expr;\n@@ -2802,38 +2819,56 @@ build_vec_init (decl, base, maxindex, init, from_array)\n   tree try_block = NULL_TREE;\n   tree try_body = NULL_TREE;\n   int num_initialized_elts = 0;\n+  tree maxindex = array_type_nelts (TREE_TYPE (base));\n \n-  maxindex = cp_convert (ptrdiff_type_node, maxindex);\n   if (maxindex == error_mark_node)\n     return error_mark_node;\n \n-  type = TREE_TYPE (TREE_TYPE (base));\n+  /* For g++.ext/arrnew.C.  */\n+  if (init && TREE_CODE (init) == CONSTRUCTOR && TREE_TYPE (init) == NULL_TREE)\n+    init = digest_init (atype, init, 0);\n+      \n+  if (init && !TYPE_NEEDS_CONSTRUCTING (type)\n+      && ((TREE_CODE (init) == CONSTRUCTOR\n+\t   /* Don't do this if the CONSTRUCTOR might contain something\n+\t      that might throw and require us to clean up.  */\n+\t   && (CONSTRUCTOR_ELTS (init) == NULL_TREE\n+\t       || ! TYPE_HAS_NONTRIVIAL_DESTRUCTOR (target_type (type))))\n+\t  || from_array))\n+    {\n+      /* Do non-default initialization of POD arrays resulting from\n+\t brace-enclosed initializers.  In this case, digest_init and\n+\t store_constructor will handle the semantics for us.  */\n+\n+      stmt_expr = build (INIT_EXPR, atype, base, init);\n+      TREE_SIDE_EFFECTS (stmt_expr) = 1;\n+      return stmt_expr;\n+    }\n+\n+  maxindex = cp_convert (ptrdiff_type_node, maxindex);\n   ptype = build_pointer_type (type);\n   size = size_in_bytes (type);\n+  if (TREE_CODE (TREE_TYPE (base)) == ARRAY_TYPE)\n+    base = cp_convert (ptype, default_conversion (base));\n \n   /* The code we are generating looks like:\n \n        T* t1 = (T*) base;\n-       T* rval = base;\n+       T* rval = t1;\n        ptrdiff_t iterator = maxindex;\n        try {\n-         ... initializations from CONSTRUCTOR ...\n-         if (iterator != -1) {\n-\t   do {\n-\t     ... initialize *base ...\n-\t     ++base;\n-\t   } while (--iterator != -1);\n-\t }\n+\t do {\n+\t   ... initialize *t1 ...\n+\t   ++t1;\n+\t } while (--iterator != -1);\n        } catch (...) {\n          ... destroy elements that were constructed ...\n        }\n+       return rval;\n        \n      We can omit the try and catch blocks if we know that the\n      initialization will never throw an exception, or if the array\n-     elements do not have destructors.  If we have a CONSTRUCTOR to\n-     give us initialization information, we emit code to initialize\n-     each of the elements before the loop in the try block, and then\n-     iterate over fewer elements.  We can omit the loop completely if\n+     elements do not have destructors.  We can omit the loop completely if\n      the elements of the array do not have constructors.  \n \n      We actually wrap the entire body of the above in a STMT_EXPR, for\n@@ -2848,24 +2883,24 @@ build_vec_init (decl, base, maxindex, init, from_array)\n   begin_init_stmts (&stmt_expr, &compound_stmt);\n   destroy_temps = stmts_are_full_exprs_p ();\n   current_stmt_tree ()->stmts_are_full_exprs_p = 0;\n-  rval = get_temp_regvar (ptype, \n-\t\t\t  cp_convert (ptype, default_conversion (base)));\n+  rval = get_temp_regvar (ptype, base);\n   base = get_temp_regvar (ptype, rval);\n   iterator = get_temp_regvar (ptrdiff_type_node, maxindex);\n \n   /* Protect the entire array initialization so that we can destroy\n-     the partially constructed array if an exception is thrown.  */\n-  if (flag_exceptions && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n+     the partially constructed array if an exception is thrown.\n+     But don't do this if we're assigning.  */\n+  if (flag_exceptions && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type)\n+      && from_array != 2)\n     {\n       try_block = begin_try_block ();\n       try_body = begin_compound_stmt (/*has_no_scope=*/1);\n     }\n \n-  if (init != NULL_TREE && TREE_CODE (init) == CONSTRUCTOR\n-      && (!decl || same_type_p (TREE_TYPE (init), TREE_TYPE (decl))))\n+  if (init != NULL_TREE && TREE_CODE (init) == CONSTRUCTOR)\n     {\n-      /* Do non-default initialization resulting from brace-enclosed\n-\t initializers.  */\n+      /* Do non-default initialization of non-POD arrays resulting from\n+\t brace-enclosed initializers.  */\n \n       tree elts;\n       from_array = 0;\n@@ -2883,16 +2918,8 @@ build_vec_init (decl, base, maxindex, init, from_array)\n \t    finish_expr_stmt (build_modify_expr (baseref, NOP_EXPR,\n \t\t\t\t\t\t elt));\n \n-\t  finish_expr_stmt (build_modify_expr \n-\t\t\t    (base, \n-\t\t\t     NOP_EXPR,\n-\t\t\t     build (PLUS_EXPR, build_pointer_type (type),\n-\t\t\t\t    base, size)));\n-\t  finish_expr_stmt (build_modify_expr\n-\t\t\t    (iterator,\n-\t\t\t     NOP_EXPR,\n-\t\t\t     build (MINUS_EXPR, ptrdiff_type_node,\n-\t\t\t\t    iterator, integer_one_node)));\n+\t  finish_expr_stmt (build_unary_op (PREINCREMENT_EXPR, base, 0));\n+\t  finish_expr_stmt (build_unary_op (PREDECREMENT_EXPR, iterator, 0));\n \t}\n \n       /* Clear out INIT so that we don't get confused below.  */\n@@ -2903,11 +2930,6 @@ build_vec_init (decl, base, maxindex, init, from_array)\n       /* If initializing one array from another, initialize element by\n \t element.  We rely upon the below calls the do argument\n \t checking.  */ \n-      if (decl == NULL_TREE)\n-\t{\n-\t  sorry (\"initialization of array from dissimilar array type\");\n-\t  return error_mark_node;\n-\t}\n       if (init)\n \t{\n \t  base2 = default_conversion (init);\n@@ -2988,20 +3010,17 @@ build_vec_init (decl, base, maxindex, init, from_array)\n       else if (TREE_CODE (type) == ARRAY_TYPE)\n \t{\n \t  if (init != 0)\n-\t    sorry (\"cannot initialize multi-dimensional array with initializer\");\n-\t  elt_init = (build_vec_init \n-\t\t      (decl, \n-\t\t       build1 (NOP_EXPR, \n-\t\t\t       build_pointer_type (TREE_TYPE (type)),\n-\t\t\t       base),\n-\t\t       array_type_nelts (type), 0, 0));\n+\t    sorry\n+\t      (\"cannot initialize multi-dimensional array with initializer\");\n+\t  elt_init = build_vec_init (build1 (INDIRECT_REF, type, base),\n+\t\t\t\t     0, 0);\n \t}\n       else\n \telt_init = build_aggr_init (build1 (INDIRECT_REF, type, base), \n \t\t\t\t    init, 0);\n       \n       /* The initialization of each array element is a\n-\t full-expression.  */\n+\t full-expression, as per core issue 124.  */\n       if (!building_stmt_tree ())\n \t{\n \t  genrtl_expr_stmt (elt_init);\n@@ -3014,25 +3033,14 @@ build_vec_init (decl, base, maxindex, init, from_array)\n \t  current_stmt_tree ()->stmts_are_full_exprs_p = 0;\n \t}\n \n-      finish_expr_stmt (build_modify_expr\n-\t\t\t(base,\n-\t\t\t NOP_EXPR,\n-\t\t\t build (PLUS_EXPR, build_pointer_type (type), \n-\t\t\t\tbase, size)));\n+      finish_expr_stmt (build_unary_op (PREINCREMENT_EXPR, base, 0));\n       if (base2)\n-\tfinish_expr_stmt (build_modify_expr\n-\t\t\t  (base2,\n-\t\t\t   NOP_EXPR,\n-\t\t\t   build (PLUS_EXPR, build_pointer_type (type), \n-\t\t\t\t  base2, size)));\n+\tfinish_expr_stmt (build_unary_op (PREINCREMENT_EXPR, base2, 0));\n \n       finish_compound_stmt (/*has_no_scope=*/1, do_body);\n       finish_do_body (do_stmt);\n       finish_do_stmt (build (NE_EXPR, boolean_type_node,\n-\t\t\t     build (PREDECREMENT_EXPR, \n-\t\t\t\t    ptrdiff_type_node, \n-\t\t\t\t    iterator,\n-\t\t\t\t    integer_one_node), \n+\t\t\t     build_unary_op (PREDECREMENT_EXPR, iterator, 0),\n \t\t\t     minus_one_node),\n \t\t      do_stmt);\n \n@@ -3041,7 +3049,8 @@ build_vec_init (decl, base, maxindex, init, from_array)\n     }\n \n   /* Make sure to cleanup any partially constructed elements.  */\n-  if (flag_exceptions && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n+  if (flag_exceptions && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type)\n+      && from_array != 2)\n     {\n       tree e;\n "}, {"sha": "0970057d378b17ff9e98b6e75b43421d2cf6e951", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30efcb78a1e867cd78017f872dd0c2a1064adfb/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30efcb78a1e867cd78017f872dd0c2a1064adfb/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=f30efcb78a1e867cd78017f872dd0c2a1064adfb", "patch": "@@ -1268,7 +1268,7 @@ new_initializer:\n \t  '(' nonnull_exprlist ')'\n \t\t{ $$ = $2; }\n \t| LEFT_RIGHT\n-\t\t{ $$ = NULL_TREE; }\n+\t\t{ $$ = void_zero_node; }\n \t| '(' typespec ')'\n \t\t{\n \t\t  cp_error (\"`%T' is not a valid expression\", $2.t);"}, {"sha": "a10f1d4cafab7de5e0162e36603fd6864749b3ec", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30efcb78a1e867cd78017f872dd0c2a1064adfb/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30efcb78a1e867cd78017f872dd0c2a1064adfb/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=f30efcb78a1e867cd78017f872dd0c2a1064adfb", "patch": "@@ -5627,7 +5627,15 @@ build_modify_expr (lhs, modifycode, rhs)\n \n   if (modifycode == INIT_EXPR)\n     {\n-      if (! IS_AGGR_TYPE (lhstype))\n+      if (TREE_CODE (rhs) == CONSTRUCTOR)\n+\t{\n+\t  if (! same_type_p (TREE_TYPE (rhs), lhstype))\n+\t    abort ();\n+\t  result = build (INIT_EXPR, lhstype, lhs, rhs);\n+\t  TREE_SIDE_EFFECTS (result) = 1;\n+\t  return result;\n+\t}\n+      else if (! IS_AGGR_TYPE (lhstype))\n \t/* Do the default thing */;\n       else\n \t{\n@@ -5808,9 +5816,7 @@ build_modify_expr (lhs, modifycode, rhs)\n \n       from_array = TREE_CODE (TREE_TYPE (newrhs)) == ARRAY_TYPE\n \t           ? 1 + (modifycode != INIT_EXPR): 0;\n-      return (build_vec_init\n-\t      (lhs, lhs, array_type_nelts (lhstype), newrhs,\n-\t       from_array));\n+      return build_vec_init (lhs, newrhs, from_array);\n     }\n \n   if (modifycode == INIT_EXPR)"}, {"sha": "62b384a74d61439e3caa98ddb8f093dd9a2ee654", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30efcb78a1e867cd78017f872dd0c2a1064adfb/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30efcb78a1e867cd78017f872dd0c2a1064adfb/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=f30efcb78a1e867cd78017f872dd0c2a1064adfb", "patch": "@@ -581,7 +581,8 @@ digest_init (type, init, tail)\n \n   if (code == ARRAY_TYPE || IS_AGGR_TYPE_CODE (code))\n     {\n-      if (raw_constructor && TYPE_NON_AGGREGATE_CLASS (type))\n+      if (raw_constructor && TYPE_NON_AGGREGATE_CLASS (type)\n+\t  && TREE_HAS_CONSTRUCTOR (init))\n \t{\n \t  cp_error (\"subobject of type `%T' must be initialized by constructor, not by `%E'\",\n \t\t    type, init);"}, {"sha": "8b07fa2535f4bae59a5f3451c895eabeff784da0", "filename": "gcc/testsuite/g++.old-deja/g++.other/new6.C", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30efcb78a1e867cd78017f872dd0c2a1064adfb/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fnew6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30efcb78a1e867cd78017f872dd0c2a1064adfb/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fnew6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fnew6.C?ref=f30efcb78a1e867cd78017f872dd0c2a1064adfb", "patch": "@@ -1,5 +1,4 @@\n // Test that we properly default-initialize the new int when () is given.\n-// execution test - XFAIL *-*-*\n \n #include <new>\n using namespace std;"}]}