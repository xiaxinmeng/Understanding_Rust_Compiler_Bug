{"sha": "e31cd607e999ca6ab47b7e65a7045b1594e4fba4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTMxY2Q2MDdlOTk5Y2E2YWI0N2I3ZTY1YTcwNDViMTU5NGU0ZmJhNA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-05-27T13:38:20Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-05-28T10:25:15Z"}, "message": "Code generate externals/invariants during the SLP graph walk\n\nThis generates vector defs for externals and invariants during the SLP\nwalk rather than as part of getting vectorized defs when vectorizing\nthe users.  This is a requirement to make sharing of external/invariant\nnodes be reflected in actual code generation.\n\nThis temporarily adds a SLP_TREE_VEC_DEFS vector alongside the\nSLP_TREE_VEC_STMTS one.  Eventually the latter can go away.\n\n2020-05-27  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (_slp_tree::vec_defs): Add.\n\t(SLP_TREE_VEC_DEFS): Likewise.\n\t* tree-vect-slp.c (_slp_tree::_slp_tree): Adjust.\n\t(_slp_tree::~_slp_tree): Likewise.\n\t(vect_mask_constant_operand_p): Remove unused function.\n\t(vect_get_constant_vectors): Rename to...\n\t(vect_create_constant_vectors): ... this.  Take the\n\tinvariant node as argument and code generate it.  Remove\n\tdead code, remove temporary asserts.  Pass a NULL stmt_info\n\tto vect_init_vector.\n\t(vect_get_slp_defs): Simplify.\n\t(vect_schedule_slp_instance): Code-generate externals and\n\tinvariants using vect_create_constant_vectors.", "tree": {"sha": "7b6da4b9226701de481deca383dee0d735609aca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b6da4b9226701de481deca383dee0d735609aca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e31cd607e999ca6ab47b7e65a7045b1594e4fba4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e31cd607e999ca6ab47b7e65a7045b1594e4fba4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e31cd607e999ca6ab47b7e65a7045b1594e4fba4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e31cd607e999ca6ab47b7e65a7045b1594e4fba4/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0aae85bd689cf581ac85d02a7e84eae0015dbe5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0aae85bd689cf581ac85d02a7e84eae0015dbe5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0aae85bd689cf581ac85d02a7e84eae0015dbe5"}], "stats": {"total": 160, "additions": 42, "deletions": 118}, "files": [{"sha": "aa95c0a7f750b0ba62b8b7ea47d3f4765b02be64", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 40, "deletions": 118, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e31cd607e999ca6ab47b7e65a7045b1594e4fba4/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e31cd607e999ca6ab47b7e65a7045b1594e4fba4/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=e31cd607e999ca6ab47b7e65a7045b1594e4fba4", "patch": "@@ -53,7 +53,8 @@ _slp_tree::_slp_tree ()\n {\n   SLP_TREE_SCALAR_STMTS (this) = vNULL;\n   SLP_TREE_SCALAR_OPS (this) = vNULL;\n-  SLP_TREE_VEC_STMTS (this).create (0);\n+  SLP_TREE_VEC_STMTS (this) = vNULL;\n+  SLP_TREE_VEC_DEFS (this) = vNULL;\n   SLP_TREE_NUMBER_OF_VEC_STMTS (this) = 0;\n   SLP_TREE_CHILDREN (this) = vNULL;\n   SLP_TREE_LOAD_PERMUTATION (this) = vNULL;\n@@ -72,6 +73,7 @@ _slp_tree::~_slp_tree ()\n   SLP_TREE_SCALAR_STMTS (this).release ();\n   SLP_TREE_SCALAR_OPS (this).release ();\n   SLP_TREE_VEC_STMTS (this).release ();\n+  SLP_TREE_VEC_DEFS (this).release ();\n   SLP_TREE_LOAD_PERMUTATION (this).release ();\n }\n \n@@ -3480,56 +3482,6 @@ vect_slp_bb (basic_block bb)\n }\n \n \n-/* Return 1 if vector type STMT_VINFO is a boolean vector.  */\n-\n-static bool\n-vect_mask_constant_operand_p (vec_info *vinfo,\n-\t\t\t      stmt_vec_info stmt_vinfo, unsigned op_num)\n-{\n-  enum tree_code code = gimple_expr_code (stmt_vinfo->stmt);\n-  tree op, vectype;\n-  enum vect_def_type dt;\n-\n-  /* For comparison and COND_EXPR type is chosen depending\n-     on the non-constant other comparison operand.  */\n-  if (TREE_CODE_CLASS (code) == tcc_comparison)\n-    {\n-      gassign *stmt = as_a <gassign *> (stmt_vinfo->stmt);\n-      op = gimple_assign_rhs1 (stmt);\n-\n-      if (!vect_is_simple_use (op, vinfo, &dt, &vectype))\n-\tgcc_unreachable ();\n-\n-      return !vectype || VECTOR_BOOLEAN_TYPE_P (vectype);\n-    }\n-\n-  if (code == COND_EXPR)\n-    {\n-      gassign *stmt = as_a <gassign *> (stmt_vinfo->stmt);\n-      tree cond = gimple_assign_rhs1 (stmt);\n-\n-      if (TREE_CODE (cond) == SSA_NAME)\n-\t{\n-\t  if (op_num > 0)\n-\t    return VECTOR_BOOLEAN_TYPE_P (STMT_VINFO_VECTYPE (stmt_vinfo));\n-\t  op = cond;\n-\t}\n-      else\n-\t{\n-\t  if (op_num > 1)\n-\t    return VECTOR_BOOLEAN_TYPE_P (STMT_VINFO_VECTYPE (stmt_vinfo));\n-\t  op = TREE_OPERAND (cond, 0);\n-\t}\n-\n-      if (!vect_is_simple_use (op, vinfo, &dt, &vectype))\n-\tgcc_unreachable ();\n-\n-      return !vectype || VECTOR_BOOLEAN_TYPE_P (vectype);\n-    }\n-\n-  return VECTOR_BOOLEAN_TYPE_P (STMT_VINFO_VECTYPE (stmt_vinfo));\n-}\n-\n /* Build a variable-length vector in which the elements in ELTS are repeated\n    to a fill NRESULTS vectors of type VECTOR_TYPE.  Store the vectors in\n    RESULTS and add any new instructions to SEQ.\n@@ -3644,18 +3596,13 @@ duplicate_and_interleave (vec_info *vinfo, gimple_seq *seq, tree vector_type,\n }\n \n \n-/* For constant and loop invariant defs of SLP_NODE this function returns\n-   (vector) defs (VEC_OPRNDS) that will be used in the vectorized stmts.\n-   OP_NODE determines the node for the operand containing the scalar\n-   operands.  */\n+/* For constant and loop invariant defs in OP_NODE this function creates\n+   vector defs that will be used in the vectorized stmts and stores them\n+   to SLP_TREE_VEC_DEFS of OP_NODE.  */\n \n static void\n-vect_get_constant_vectors (vec_info *vinfo,\n-\t\t\t   slp_tree slp_node, unsigned op_num,\n-                           vec<tree> *vec_oprnds)\n+vect_create_constant_vectors (vec_info *vinfo, slp_tree op_node)\n {\n-  slp_tree op_node = SLP_TREE_CHILDREN (slp_node)[op_num];\n-  stmt_vec_info stmt_vinfo = SLP_TREE_SCALAR_STMTS (slp_node)[0];\n   unsigned HOST_WIDE_INT nunits;\n   tree vec_cst;\n   unsigned j, number_of_places_left_in_vector;\n@@ -3665,29 +3612,14 @@ vect_get_constant_vectors (vec_info *vinfo,\n   unsigned int vec_num, i;\n   unsigned number_of_copies = 1;\n   bool constant_p;\n-  tree neutral_op = NULL;\n   gimple_seq ctor_seq = NULL;\n   auto_vec<tree, 16> permute_results;\n \n   /* We always want SLP_TREE_VECTYPE (op_node) here correctly set.  */\n   vector_type = SLP_TREE_VECTYPE (op_node);\n-    {\n-  tree op = op_node->ops[0];\n-  tree stmt_vectype = STMT_VINFO_VECTYPE (stmt_vinfo);\n-  if (VECT_SCALAR_BOOLEAN_TYPE_P (TREE_TYPE (op))\n-      && vect_mask_constant_operand_p (vinfo, stmt_vinfo, op_num))\n-    gcc_assert (vector_type\n-\t\t&& types_compatible_p (vector_type,\n-\t\t\t\t       truth_type_for (stmt_vectype)));\n-  else\n-    gcc_assert (vector_type\n-\t\t&& types_compatible_p (vector_type,\n-\t\t\t\t       get_vectype_for_scalar_type\n-\t\t\t\t\t (vinfo, TREE_TYPE (op), op_node)));\n-    }\n \n   unsigned int number_of_vectors = SLP_TREE_NUMBER_OF_VEC_STMTS (op_node);\n-  vec_oprnds->create (number_of_vectors);\n+  SLP_TREE_VEC_DEFS (op_node).create (number_of_vectors);\n   auto_vec<tree> voprnds (number_of_vectors);\n \n   /* NUMBER_OF_COPIES is the number of times we need to use the same values in\n@@ -3812,11 +3744,11 @@ vect_get_constant_vectors (vec_info *vinfo,\n \t\t  gimple_stmt_iterator gsi = gsi_for_stmt (insert_after->stmt);\n \t\t  /* vect_init_vector inserts before.  */\n \t\t  gsi_next (&gsi);\n-\t\t  init = vect_init_vector (vinfo, stmt_vinfo, vec_cst,\n+\t\t  init = vect_init_vector (vinfo, NULL, vec_cst,\n \t\t\t\t\t   vector_type, &gsi);\n \t\t}\n \t      else\n-\t\tinit = vect_init_vector (vinfo, stmt_vinfo, vec_cst,\n+\t\tinit = vect_init_vector (vinfo, NULL, vec_cst,\n \t\t\t\t\t vector_type, NULL);\n \t      if (ctor_seq != NULL)\n \t\t{\n@@ -3841,30 +3773,17 @@ vect_get_constant_vectors (vec_info *vinfo,\n   for (j = vec_num; j != 0; j--)\n     {\n       vop = voprnds[j - 1];\n-      vec_oprnds->quick_push (vop);\n+      SLP_TREE_VEC_DEFS (op_node).quick_push (vop);\n     }\n \n   /* In case that VF is greater than the unrolling factor needed for the SLP\n      group of stmts, NUMBER_OF_VECTORS to be created is greater than\n      NUMBER_OF_SCALARS/NUNITS or NUNITS/NUMBER_OF_SCALARS, and hence we have\n      to replicate the vectors.  */\n-  while (number_of_vectors > vec_oprnds->length ())\n-    {\n-      tree neutral_vec = NULL;\n-\n-      if (neutral_op)\n-        {\n-          if (!neutral_vec)\n-\t    neutral_vec = build_vector_from_val (vector_type, neutral_op);\n-\n-          vec_oprnds->quick_push (neutral_vec);\n-        }\n-      else\n-        {\n-          for (i = 0; vec_oprnds->iterate (i, &vop) && i < vec_num; i++)\n-            vec_oprnds->quick_push (vop);\n-        }\n-    }\n+  while (number_of_vectors > SLP_TREE_VEC_DEFS (op_node).length ())\n+    for (i = 0; SLP_TREE_VEC_DEFS (op_node).iterate (i, &vop) && i < vec_num;\n+\t i++)\n+      SLP_TREE_VEC_DEFS (op_node).quick_push (vop);\n }\n \n \n@@ -3884,15 +3803,10 @@ vect_get_slp_vect_defs (slp_tree slp_node, vec<tree> *vec_oprnds)\n }\n \n \n-/* Get N vectorized definitions for SLP_NODE.\n-   If the scalar definitions are loop invariants or constants, collect them and\n-   call vect_get_constant_vectors() to create vector stmts.\n-   Otherwise, the def-stmts must be already vectorized and the vectorized stmts\n-   must be stored in the corresponding child of SLP_NODE, and we call\n-   vect_get_slp_vect_defs () to retrieve them.  */\n+/* Get N vectorized definitions for SLP_NODE.  */\n \n void\n-vect_get_slp_defs (vec_info *vinfo,\n+vect_get_slp_defs (vec_info *,\n \t\t   slp_tree slp_node, vec<vec<tree> > *vec_oprnds, unsigned n)\n {\n   if (n == -1U)\n@@ -3906,13 +3820,11 @@ vect_get_slp_defs (vec_info *vinfo,\n \n       /* For each operand we check if it has vectorized definitions in a child\n \t node or we need to create them (for invariants and constants).  */\n+      vec_defs.create (SLP_TREE_NUMBER_OF_VEC_STMTS (child));\n       if (SLP_TREE_DEF_TYPE (child) == vect_internal_def)\n-\t{\n-\t  vec_defs.create (SLP_TREE_NUMBER_OF_VEC_STMTS (child));\n-\t  vect_get_slp_vect_defs (child, &vec_defs);\n-\t}\n+\tvect_get_slp_vect_defs (child, &vec_defs);\n       else\n-\tvect_get_constant_vectors (vinfo, slp_node, i, &vec_defs);\n+\tvec_defs.splice (SLP_TREE_VEC_DEFS (child));\n \n       vec_oprnds->quick_push (vec_defs);\n     }\n@@ -4137,20 +4049,30 @@ vect_schedule_slp_instance (vec_info *vinfo,\n \t\t\t    slp_tree node, slp_instance instance)\n {\n   gimple_stmt_iterator si;\n-  stmt_vec_info stmt_info;\n-  unsigned int group_size;\n-  tree vectype;\n   int i, j;\n   slp_tree child;\n \n-  if (SLP_TREE_DEF_TYPE (node) != vect_internal_def)\n-    return;\n-\n   /* See if we have already vectorized the node in the graph of the\n      SLP instance.  */\n-  if (SLP_TREE_VEC_STMTS (node).exists ())\n+  if ((SLP_TREE_DEF_TYPE (node) == vect_internal_def\n+       && SLP_TREE_VEC_STMTS (node).exists ())\n+      || SLP_TREE_VEC_DEFS (node).exists ())\n     return;\n \n+  /* Vectorize externals and constants.  */\n+  if (SLP_TREE_DEF_TYPE (node) == vect_constant_def\n+      || SLP_TREE_DEF_TYPE (node) == vect_external_def)\n+    {\n+      /* ???  vectorizable_shift can end up using a scalar operand which is\n+\t currently denoted as !SLP_TREE_VECTYPE.  No need to vectorize the\n+\t node in this case.  */\n+      if (!SLP_TREE_VECTYPE (node))\n+\treturn;\n+\n+      vect_create_constant_vectors (vinfo, node);\n+      return;\n+    }\n+\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n     vect_schedule_slp_instance (vinfo, child, instance);\n \n@@ -4163,12 +4085,12 @@ vect_schedule_slp_instance (vec_info *vinfo,\n \t  STMT_VINFO_DEF_TYPE (child_stmt_info) = SLP_TREE_DEF_TYPE (child);\n       }\n \n-  stmt_info = SLP_TREE_SCALAR_STMTS (node)[0];\n+  stmt_vec_info stmt_info = SLP_TREE_SCALAR_STMTS (node)[0];\n \n   /* VECTYPE is the type of the destination.  */\n-  vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-  group_size = SLP_TREE_SCALAR_STMTS (node).length ();\n+  unsigned group_size = SLP_TREE_SCALAR_STMTS (node).length ();\n \n   gcc_assert (SLP_TREE_NUMBER_OF_VEC_STMTS (node) != 0);\n   SLP_TREE_VEC_STMTS (node).create (SLP_TREE_NUMBER_OF_VEC_STMTS (node));"}, {"sha": "2bde71760e53c9034b15ba868bb6f0aac43d6a5b", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e31cd607e999ca6ab47b7e65a7045b1594e4fba4/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e31cd607e999ca6ab47b7e65a7045b1594e4fba4/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=e31cd607e999ca6ab47b7e65a7045b1594e4fba4", "patch": "@@ -136,6 +136,7 @@ struct _slp_tree {\n   tree vectype;\n   /* Vectorized stmt/s.  */\n   vec<stmt_vec_info> vec_stmts;\n+  vec<tree> vec_defs;\n   /* Number of vector stmts that are created to replace the group of scalar\n      stmts. It is calculated during the transformation phase as the number of\n      scalar elements in one scalar iteration (GROUP_SIZE) multiplied by VF\n@@ -186,6 +187,7 @@ typedef class _slp_instance {\n #define SLP_TREE_SCALAR_STMTS(S)                 (S)->stmts\n #define SLP_TREE_SCALAR_OPS(S)                   (S)->ops\n #define SLP_TREE_VEC_STMTS(S)                    (S)->vec_stmts\n+#define SLP_TREE_VEC_DEFS(S)                     (S)->vec_defs\n #define SLP_TREE_NUMBER_OF_VEC_STMTS(S)          (S)->vec_stmts_size\n #define SLP_TREE_LOAD_PERMUTATION(S)             (S)->load_permutation\n #define SLP_TREE_TWO_OPERATORS(S)\t\t (S)->two_operators"}]}