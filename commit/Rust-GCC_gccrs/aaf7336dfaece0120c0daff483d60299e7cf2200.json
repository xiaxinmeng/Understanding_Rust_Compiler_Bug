{"sha": "aaf7336dfaece0120c0daff483d60299e7cf2200", "node_id": "C_kwDOANBUbNoAKGFhZjczMzZkZmFlY2UwMTIwYzBkYWZmNDgzZDYwMjk5ZTdjZjIyMDA", "commit": {"author": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2023-04-17T21:17:37Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2023-04-28T10:52:24Z"}, "message": "gccrs: Improve operator overload check for recursive overload\n\nThis is a case in #2019 where you have the default Add impl for i32 for\nexample which has:\n\n  impl Add for i32 {\n    fn add(self, other:i32) { self + other }\n  }\n\nThis function will do a check for operator overload which then is able to\nfind multiple candidates such as:\n\n  impl<'a> Add<i32> for &'a i32 {\n    type Output = <i32 as Add<i32>>::Output;\n\n    fn add(self, other: i32) -> <i32 as Add<i32>>::Output {\n        Add::add(*self, other)\n    }\n  }\n\nThis initial operator overload will resolve to this as it looks like a\nvalid candidate. This patch adds another level of checks to ensure the\ncandidate does not equal the current context DefId.\n\nAddresses #2019\n\ngcc/rust/ChangeLog:\n\n\t* typecheck/rust-hir-type-check-expr.cc: update for op overload\n\nSigned-off-by: Philip Herron <herron.philip@googlemail.com>", "tree": {"sha": "92e88c68a223ab9604f0e1bafa9729494db7c141", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92e88c68a223ab9604f0e1bafa9729494db7c141"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aaf7336dfaece0120c0daff483d60299e7cf2200", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaf7336dfaece0120c0daff483d60299e7cf2200", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aaf7336dfaece0120c0daff483d60299e7cf2200", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaf7336dfaece0120c0daff483d60299e7cf2200/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "187f4b9eb897a08c124742e018b323c1ad6c9189", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/187f4b9eb897a08c124742e018b323c1ad6c9189", "html_url": "https://github.com/Rust-GCC/gccrs/commit/187f4b9eb897a08c124742e018b323c1ad6c9189"}], "stats": {"total": 90, "additions": 59, "deletions": 31}, "files": [{"sha": "3a54ffb995d27fe11aeb794a32a5e47cfce23952", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.cc", "status": "modified", "additions": 59, "deletions": 31, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf7336dfaece0120c0daff483d60299e7cf2200/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf7336dfaece0120c0daff483d60299e7cf2200/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc?ref=aaf7336dfaece0120c0daff483d60299e7cf2200", "patch": "@@ -1589,18 +1589,43 @@ TypeCheckExpr::resolve_operator_overload (\n   if (!lang_item_defined)\n     return false;\n \n+  // we might be in a static or const context and unknown is fine\n+  TypeCheckContextItem current_context = TypeCheckContextItem::get_error ();\n+  if (context->have_function_context ())\n+    {\n+      current_context = context->peek_context ();\n+    }\n+\n   auto segment = HIR::PathIdentSegment (associated_item_name);\n   auto candidates = MethodResolver::Probe (lhs, segment);\n \n-  bool have_implementation_for_lang_item = candidates.size () > 0;\n+  // remove any recursive candidates\n+  std::set<MethodCandidate> resolved_candidates;\n+  for (auto &c : candidates)\n+    {\n+      const TyTy::BaseType *candidate_type = c.candidate.ty;\n+      rust_assert (candidate_type->get_kind () == TyTy::TypeKind::FNDEF);\n+\n+      const TyTy::FnType &fn\n+\t= *static_cast<const TyTy::FnType *> (candidate_type);\n+\n+      DefId current_fn_defid = current_context.get_defid ();\n+      bool recursive_candidated = fn.get_id () == current_fn_defid;\n+      if (!recursive_candidated)\n+\t{\n+\t  resolved_candidates.insert (c);\n+\t}\n+    }\n+\n+  bool have_implementation_for_lang_item = resolved_candidates.size () > 0;\n   if (!have_implementation_for_lang_item)\n     return false;\n \n-  if (candidates.size () > 1)\n+  if (resolved_candidates.size () > 1)\n     {\n       // mutliple candidates\n       RichLocation r (expr.get_locus ());\n-      for (auto &c : candidates)\n+      for (auto &c : resolved_candidates)\n \tr.add_range (c.candidate.locus);\n \n       rust_error_at (\n@@ -1610,18 +1635,40 @@ TypeCheckExpr::resolve_operator_overload (\n     }\n \n   // Get the adjusted self\n-  auto candidate = *candidates.begin ();\n+  MethodCandidate candidate = *resolved_candidates.begin ();\n   Adjuster adj (lhs);\n   TyTy::BaseType *adjusted_self = adj.adjust_type (candidate.adjustments);\n \n-  // is this the case we are recursive\n-  // handle the case where we are within the impl block for this lang_item\n-  // otherwise we end up with a recursive operator overload such as the i32\n-  // operator overload trait\n-  TypeCheckContextItem fn_context = context->peek_context ();\n-  if (fn_context.get_type () == TypeCheckContextItem::ItemType::IMPL_ITEM)\n+  // store the adjustments for code-generation to know what to do\n+  context->insert_autoderef_mappings (expr.get_lvalue_mappings ().get_hirid (),\n+\t\t\t\t      std::move (candidate.adjustments));\n+\n+  // now its just like a method-call-expr\n+  context->insert_receiver (expr.get_mappings ().get_hirid (), lhs);\n+\n+  PathProbeCandidate &resolved_candidate = candidate.candidate;\n+  TyTy::BaseType *lookup_tyty = candidate.candidate.ty;\n+  NodeId resolved_node_id\n+    = resolved_candidate.is_impl_candidate ()\n+\t? resolved_candidate.item.impl.impl_item->get_impl_mappings ()\n+\t    .get_nodeid ()\n+\t: resolved_candidate.item.trait.item_ref->get_mappings ().get_nodeid ();\n+\n+  rust_assert (lookup_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::BaseType *lookup = lookup_tyty;\n+  TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n+  rust_assert (fn->is_method ());\n+\n+  rust_debug (\"is_impl_item_candidate: %s\",\n+\t      resolved_candidate.is_impl_candidate () ? \"true\" : \"false\");\n+\n+  // in the case where we resolve to a trait bound we have to be careful we are\n+  // able to do so there is a case where we are currently resolving the deref\n+  // operator overload function which is generic and this might resolve to the\n+  // trait item of deref which is not valid as its just another recursive case\n+  if (current_context.get_type () == TypeCheckContextItem::ItemType::IMPL_ITEM)\n     {\n-      auto &impl_item = fn_context.get_impl_item ();\n+      auto &impl_item = current_context.get_impl_item ();\n       HIR::ImplBlock *parent = impl_item.first;\n       HIR::Function *fn = impl_item.second;\n \n@@ -1655,26 +1702,7 @@ TypeCheckExpr::resolve_operator_overload (\n \t}\n     }\n \n-  // store the adjustments for code-generation to know what to do\n-  context->insert_autoderef_mappings (expr.get_lvalue_mappings ().get_hirid (),\n-\t\t\t\t      std::move (candidate.adjustments));\n-\n-  // now its just like a method-call-expr\n-  context->insert_receiver (expr.get_mappings ().get_hirid (), lhs);\n-\n-  PathProbeCandidate &resolved_candidate = candidate.candidate;\n-  TyTy::BaseType *lookup_tyty = candidate.candidate.ty;\n-  NodeId resolved_node_id\n-    = resolved_candidate.is_impl_candidate ()\n-\t? resolved_candidate.item.impl.impl_item->get_impl_mappings ()\n-\t    .get_nodeid ()\n-\t: resolved_candidate.item.trait.item_ref->get_mappings ().get_nodeid ();\n-\n-  rust_assert (lookup_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n-  TyTy::BaseType *lookup = lookup_tyty;\n-  TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n-  rust_assert (fn->is_method ());\n-\n+  // we found a valid operator overload\n   fn->prepare_higher_ranked_bounds ();\n   rust_debug_loc (expr.get_locus (), \"resolved operator overload to: {%u} {%s}\",\n \t\t  candidate.candidate.ty->get_ref (),"}]}