{"sha": "56b1f114de93c27600b9b295ff7efcf9caedfc72", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZiMWYxMTRkZTkzYzI3NjAwYjliMjk1ZmY3ZWZjZjljYWVkZmM3Mg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-08-14T23:30:46Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-08-14T23:30:46Z"}, "message": "ipa-utils.h (compare_virtual_tables): Declare.\n\n\t* ipa-utils.h (compare_virtual_tables): Declare.\n\t* ipa-devirt.c (odr_subtypes_equivalent_p): New function\n\n\t* lto-symtab.c (lto_varpool_replace_node): Call compare_virtual_tables.\n\nFrom-SVN: r213990", "tree": {"sha": "4aece5efbbebf94d2b39aa6940862dedbf57f883", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4aece5efbbebf94d2b39aa6940862dedbf57f883"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56b1f114de93c27600b9b295ff7efcf9caedfc72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56b1f114de93c27600b9b295ff7efcf9caedfc72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56b1f114de93c27600b9b295ff7efcf9caedfc72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56b1f114de93c27600b9b295ff7efcf9caedfc72/comments", "author": null, "committer": null, "parents": [{"sha": "aa0a659ca69cf092fcfb6ebb58a749b63a04be48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa0a659ca69cf092fcfb6ebb58a749b63a04be48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa0a659ca69cf092fcfb6ebb58a749b63a04be48"}], "stats": {"total": 128, "additions": 128, "deletions": 0}, "files": [{"sha": "223e484a368f225e2b575b0896d064be37639027", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b1f114de93c27600b9b295ff7efcf9caedfc72/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b1f114de93c27600b9b295ff7efcf9caedfc72/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=56b1f114de93c27600b9b295ff7efcf9caedfc72", "patch": "@@ -1,3 +1,8 @@\n+2014-08-14  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-utils.h (compare_virtual_tables): Declare.\n+\t* ipa-devirt.c (odr_subtypes_equivalent_p): New function\n+\n 2014-08-14  Marek Polacek  <polacek@redhat.com>\n \n \tDR 458"}, {"sha": "2d356ad73b94a1a8b4c938ed19e9627cefd1282f", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b1f114de93c27600b9b295ff7efcf9caedfc72/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b1f114de93c27600b9b295ff7efcf9caedfc72/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=56b1f114de93c27600b9b295ff7efcf9caedfc72", "patch": "@@ -485,6 +485,120 @@ odr_subtypes_equivalent_p (tree t1, tree t2, hash_set<tree> *visited)\n   return types_same_for_odr (t1, t2);\n }\n \n+/* Compare two virtual tables, PREVAILING and VTABLE and output ODR\n+   violation warings.  */\n+\n+void\n+compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n+{\n+  int n1, n2;\n+  if (DECL_VIRTUAL_P (prevailing->decl) != DECL_VIRTUAL_P (vtable->decl))\n+    {\n+      odr_violation_reported = true;\n+      if (DECL_VIRTUAL_P (prevailing->decl))\n+\t{\n+\t  varpool_node *tmp = prevailing;\n+\t  prevailing = vtable;\n+\t  vtable = tmp;\n+\t}\n+      if (warning_at (DECL_SOURCE_LOCATION (TYPE_NAME (DECL_CONTEXT (vtable->decl))),\n+\t\t      OPT_Wodr,\n+\t\t      \"virtual table of type %qD violates one definition rule\",\n+\t\t      DECL_CONTEXT (vtable->decl)))\n+\tinform (DECL_SOURCE_LOCATION (prevailing->decl),\n+\t\t\"variable of same assembler name as the virtual table is \"\n+\t\t\"defined in another translation unit\");\n+      return;\n+    }\n+  if (!prevailing->definition || !vtable->definition)\n+    return;\n+  for (n1 = 0, n2 = 0; true; n1++, n2++)\n+    {\n+      struct ipa_ref *ref1, *ref2;\n+      bool end1, end2;\n+      end1 = !prevailing->iterate_reference (n1, ref1);\n+      end2 = !vtable->iterate_reference (n2, ref2);\n+      if (end1 && end2)\n+\treturn;\n+      if (!end1 && !end2\n+\t  && DECL_ASSEMBLER_NAME (ref1->referred->decl)\n+\t     != DECL_ASSEMBLER_NAME (ref2->referred->decl)\n+\t  && !n2\n+\t  && !DECL_VIRTUAL_P (ref2->referred->decl)\n+\t  && DECL_VIRTUAL_P (ref1->referred->decl))\n+\t{\n+\t  if (warning_at (DECL_SOURCE_LOCATION (TYPE_NAME (DECL_CONTEXT (vtable->decl))), 0,\n+\t\t\t  \"virtual table of type %qD contains RTTI information\",\n+\t\t\t  DECL_CONTEXT (vtable->decl)))\n+\t    {\n+\t      inform (DECL_SOURCE_LOCATION (TYPE_NAME (DECL_CONTEXT (prevailing->decl))),\n+\t\t      \"but is prevailed by one without from other translation unit\");\n+\t      inform (DECL_SOURCE_LOCATION (TYPE_NAME (DECL_CONTEXT (prevailing->decl))),\n+\t\t      \"RTTI will not work on this type\");\n+\t    }\n+\t  n2++;\n+          end2 = !vtable->iterate_reference (n2, ref2);\n+\t}\n+      if (!end1 && !end2\n+\t  && DECL_ASSEMBLER_NAME (ref1->referred->decl)\n+\t     != DECL_ASSEMBLER_NAME (ref2->referred->decl)\n+\t  && !n1\n+\t  && !DECL_VIRTUAL_P (ref1->referred->decl)\n+\t  && DECL_VIRTUAL_P (ref2->referred->decl))\n+\t{\n+\t  n1++;\n+          end1 = !vtable->iterate_reference (n1, ref1);\n+\t}\n+      if (end1 || end2)\n+\t{\n+\t  if (end1)\n+\t    {\n+\t      varpool_node *tmp = prevailing;\n+\t      prevailing = vtable;\n+\t      vtable = tmp;\n+\t      ref1 = ref2;\n+\t    }\n+\t  if (warning_at (DECL_SOURCE_LOCATION\n+\t\t\t    (TYPE_NAME (DECL_CONTEXT (vtable->decl))), 0,\n+\t\t\t  \"virtual table of type %qD violates \"\n+\t\t\t  \"one definition rule\",\n+\t\t\t  DECL_CONTEXT (vtable->decl)))\n+\t    {\n+\t      inform (DECL_SOURCE_LOCATION\n+\t\t       (TYPE_NAME (DECL_CONTEXT (prevailing->decl))),\n+\t\t      \"the conflicting type defined in another translation \"\n+\t\t      \"unit\");\n+\t      inform (DECL_SOURCE_LOCATION\n+\t\t        (TYPE_NAME (DECL_CONTEXT (ref1->referring->decl))),\n+\t\t      \"contains additional virtual method %qD\",\n+\t\t      ref1->referred->decl);\n+\t    }\n+\t  return;\n+\t}\n+      if (DECL_ASSEMBLER_NAME (ref1->referred->decl)\n+\t  != DECL_ASSEMBLER_NAME (ref2->referred->decl))\n+\t{\n+\t  if (warning_at (DECL_SOURCE_LOCATION\n+\t\t\t    (TYPE_NAME (DECL_CONTEXT (vtable->decl))), 0,\n+\t\t\t  \"virtual table of type %qD violates \"\n+\t\t\t  \"one definition rule  \",\n+\t\t\t  DECL_CONTEXT (vtable->decl)))\n+\t    {\n+\t      inform (DECL_SOURCE_LOCATION \n+\t\t\t(TYPE_NAME (DECL_CONTEXT (prevailing->decl))),\n+\t\t      \"the conflicting type defined in another translation \"\n+\t\t      \"unit\");\n+\t      inform (DECL_SOURCE_LOCATION (ref1->referred->decl),\n+\t\t      \"virtual method %qD\", ref1->referred->decl);\n+\t      inform (DECL_SOURCE_LOCATION (ref2->referred->decl),\n+\t\t      \"ought to match virtual method %qD but does not\",\n+\t\t      ref2->referred->decl);\n+\t      return;\n+\t    }\n+\t}\n+    }\n+}\n+\n /* Output ODR violation warning about T1 and T2 with REASON.\n    Display location of ST1 and ST2 if REASON speaks about field or\n    method of the type."}, {"sha": "30adc6907d2a818115fef9f4456524ef5c222ebb", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b1f114de93c27600b9b295ff7efcf9caedfc72/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b1f114de93c27600b9b295ff7efcf9caedfc72/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=56b1f114de93c27600b9b295ff7efcf9caedfc72", "patch": "@@ -101,6 +101,7 @@ bool get_polymorphic_call_info_from_invariant (ipa_polymorphic_call_context *,\n bool decl_maybe_in_construction_p (tree, tree, gimple, tree);\n tree vtable_pointer_value_to_binfo (const_tree);\n bool vtable_pointer_value_to_vtable (const_tree, tree *, unsigned HOST_WIDE_INT *);\n+void compare_virtual_tables (varpool_node *, varpool_node *);\n bool contains_polymorphic_type_p (const_tree);\n \n /* Return vector containing possible targets of polymorphic call E."}, {"sha": "2e3a15637754b9c072c70ff8b33379e6c4cc6691", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b1f114de93c27600b9b295ff7efcf9caedfc72/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b1f114de93c27600b9b295ff7efcf9caedfc72/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=56b1f114de93c27600b9b295ff7efcf9caedfc72", "patch": "@@ -1,3 +1,7 @@\n+2014-08-14  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto-symtab.c (lto_varpool_replace_node): Call compare_virtual_tables.\n+\n 2014-08-14  Richard Biener  <rguenther@suse.de>\n \n \tPR lto/62067"}, {"sha": "aae865a029045e73e5cfd2f94d0f08964c5dcc0f", "filename": "gcc/lto/lto-symtab.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b1f114de93c27600b9b295ff7efcf9caedfc72/gcc%2Flto%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b1f114de93c27600b9b295ff7efcf9caedfc72/gcc%2Flto%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-symtab.c?ref=56b1f114de93c27600b9b295ff7efcf9caedfc72", "patch": "@@ -117,6 +117,10 @@ lto_varpool_replace_node (varpool_node *vnode,\n       && vnode->decl != prevailing_node->decl)\n     DECL_INITIAL (vnode->decl) = error_mark_node;\n \n+  /* Check and report ODR violations on virtual tables.  */\n+  if (DECL_VIRTUAL_P (vnode->decl) || DECL_VIRTUAL_P (prevailing_node->decl))\n+    compare_virtual_tables (prevailing_node, vnode);\n+\n   if (vnode->tls_model != prevailing_node->tls_model)\n     {\n       error_at (DECL_SOURCE_LOCATION (vnode->decl),"}]}