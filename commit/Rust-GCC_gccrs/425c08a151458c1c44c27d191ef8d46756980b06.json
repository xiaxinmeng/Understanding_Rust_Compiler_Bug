{"sha": "425c08a151458c1c44c27d191ef8d46756980b06", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDI1YzA4YTE1MTQ1OGMxYzQ0YzI3ZDE5MWVmOGQ0Njc1Njk4MGIwNg==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1998-08-26T17:06:03Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-08-26T17:06:03Z"}, "message": "calls.c (expand_call): Use bitfield instructions to extract/deposit word sized hunks when...\n\n        * calls.c (expand_call): Use bitfield instructions to extract/deposit\n        word sized hunks when loading unaligned args into registers.\n\nFrom-SVN: r22008", "tree": {"sha": "9f3ebc504caa79d3cdd95e4d5b90252503ede2bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f3ebc504caa79d3cdd95e4d5b90252503ede2bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/425c08a151458c1c44c27d191ef8d46756980b06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/425c08a151458c1c44c27d191ef8d46756980b06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/425c08a151458c1c44c27d191ef8d46756980b06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/425c08a151458c1c44c27d191ef8d46756980b06/comments", "author": null, "committer": null, "parents": [{"sha": "cc1f775259572ef1e0158a799d436f99782f1701", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc1f775259572ef1e0158a799d436f99782f1701", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc1f775259572ef1e0158a799d436f99782f1701"}], "stats": {"total": 37, "additions": 17, "deletions": 20}, "files": [{"sha": "223e78adb4fd67c3113d280cff9045188f5644f5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/425c08a151458c1c44c27d191ef8d46756980b06/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/425c08a151458c1c44c27d191ef8d46756980b06/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=425c08a151458c1c44c27d191ef8d46756980b06", "patch": "@@ -14,6 +14,9 @@ Wed Aug 26 09:30:59 1998  Nick Clifton  <nickc@cygnus.com>\n \n Wed Aug 26 12:57:09 1998  Jeffrey A Law  (law@cygnus.com)\n \n+\t* calls.c (expand_call): Use bitfield instructions to extract/deposit\n+\tword sized hunks when loading unaligned args into registers.\n+\n \t* haifa-sched.c (sched_analyze_insn): Only create scheduling\n \tbarriers for LOOP, EH and SETJMP notes on the loop_notes list.\n "}, {"sha": "728d6d68a5d79fde166607dca1d4bf4c16586d85", "filename": "gcc/calls.c", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/425c08a151458c1c44c27d191ef8d46756980b06/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/425c08a151458c1c44c27d191ef8d46756980b06/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=425c08a151458c1c44c27d191ef8d46756980b06", "patch": "@@ -1800,16 +1800,16 @@ expand_call (exp, target, ignore)\n \t    {\n \t      rtx reg = gen_reg_rtx (word_mode);\n \t      rtx word = operand_subword_force (args[i].value, j, BLKmode);\n-\t      int bitsize = TYPE_ALIGN (TREE_TYPE (args[i].tree_value));\n-\t      int bitpos;\n+\t      int bitsize = MIN (bytes * BITS_PER_UNIT, BITS_PER_WORD);\n+\t      int bitalign = TYPE_ALIGN (TREE_TYPE (args[i].tree_value));\n \n \t      args[i].aligned_regs[j] = reg;\n \n-\t      /* Clobber REG and move each partword into it.  Ensure we don't\n-\t\t go past the end of the structure.  Note that the loop below\n-\t\t works because we've already verified that padding\n-\t\t and endianness are compatible.\n+\t      /* There is no need to restrict this code to loading items\n+\t\t in TYPE_ALIGN sized hunks.  The bitfield instructions can\n+\t\t load up entire word sized registers efficiently.\n \n+\t\t ??? This may not be needed anymore.\n \t\t We use to emit a clobber here but that doesn't let later\n \t\t passes optimize the instructions we emit.  By storing 0 into\n \t\t the register later passes know the first AND to zero out the\n@@ -1818,20 +1818,14 @@ expand_call (exp, target, ignore)\n \n \t      emit_move_insn (reg, const0_rtx);\n \n-\t      for (bitpos = 0;\n-\t\t   bitpos < BITS_PER_WORD && bytes > 0;\n-\t\t   bitpos += bitsize, bytes -= bitsize / BITS_PER_UNIT)\n-\t\t{\n-\t\t  int xbitpos = bitpos + big_endian_correction;\n-\n-\t\t  store_bit_field (reg, bitsize, xbitpos, word_mode,\n-\t\t\t\t   extract_bit_field (word, bitsize, bitpos, 1,\n-\t\t\t\t\t\t      NULL_RTX, word_mode,\n-\t\t\t\t\t\t      word_mode,\n-\t\t\t\t\t\t      bitsize / BITS_PER_UNIT,\n-\t\t\t\t\t\t      BITS_PER_WORD),\n-\t\t\t\t   bitsize / BITS_PER_UNIT, BITS_PER_WORD);\n-\t\t}\n+\t      bytes -= bitsize / BITS_PER_UNIT;\n+\t      store_bit_field (reg, bitsize, big_endian_correction, word_mode,\n+\t\t\t       extract_bit_field (word, bitsize, 0, 1,\n+\t\t\t\t\t\t  NULL_RTX, word_mode,\n+\t\t\t\t\t\t  word_mode,\n+\t\t\t\t\t\t  bitalign / BITS_PER_UNIT,\n+\t\t\t\t\t\t  BITS_PER_WORD),\n+\t\t\t       bitalign / BITS_PER_UNIT, BITS_PER_WORD);\n \t    }\n \t}\n "}]}