{"sha": "28c008bb89e0ab798c2d16c68f51fb01fdccb135", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjhjMDA4YmI4OWUwYWI3OThjMmQxNmM2OGY1MWZiMDFmZGNjYjEzNQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2004-07-19T19:01:55Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2004-07-19T19:01:55Z"}, "message": "tree-ssa-dom.c (single_incoming_edge_ignoring_loop_edges): New.\n\n        * tree-ssa-dom.c (single_incoming_edge_ignoring_loop_edges): New.\n        (get_eq_expr_value): Use it.  Simplify slightly.\n\nFrom-SVN: r84927", "tree": {"sha": "b8db471a5e6865b90892a3d00fdf7646e69e73e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8db471a5e6865b90892a3d00fdf7646e69e73e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28c008bb89e0ab798c2d16c68f51fb01fdccb135", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28c008bb89e0ab798c2d16c68f51fb01fdccb135", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28c008bb89e0ab798c2d16c68f51fb01fdccb135", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28c008bb89e0ab798c2d16c68f51fb01fdccb135/comments", "author": null, "committer": null, "parents": [{"sha": "963ddbd50fbb62666384ea56cfc7e06753f9bb6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/963ddbd50fbb62666384ea56cfc7e06753f9bb6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/963ddbd50fbb62666384ea56cfc7e06753f9bb6d"}], "stats": {"total": 63, "additions": 46, "deletions": 17}, "files": [{"sha": "a9e147cca60cd0a8ff1763eaacbda8d44177ccb7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28c008bb89e0ab798c2d16c68f51fb01fdccb135/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28c008bb89e0ab798c2d16c68f51fb01fdccb135/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=28c008bb89e0ab798c2d16c68f51fb01fdccb135", "patch": "@@ -1,3 +1,8 @@\n+2004-07-19  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-dom.c (single_incoming_edge_ignoring_loop_edges): New.\n+\t(get_eq_expr_value): Use it.  Simplify slightly.\n+ \n 2004-07-19  Maciej W. Rozycki  <macro@linux-mips.org>\n \n \t* config/mips/mips.md (mulsidi3_32bit_r4000): Fix the clobber list."}, {"sha": "90e11b76410ee634ba6723da82ccf95f7f35efbc", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 41, "deletions": 17, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28c008bb89e0ab798c2d16c68f51fb01fdccb135/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28c008bb89e0ab798c2d16c68f51fb01fdccb135/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=28c008bb89e0ab798c2d16c68f51fb01fdccb135", "patch": "@@ -268,6 +268,7 @@ static void restore_currdefs_to_original_value (varray_type locals,\n \t\t\t\t\t\tunsigned limit);\n static void register_definitions_for_stmt (stmt_ann_t, varray_type *);\n static void redirect_edges_and_update_ssa_graph (varray_type);\n+static edge single_incoming_edge_ignoring_loop_edges (basic_block);\n \n /* Local version of fold that doesn't introduce cruft.  */\n \n@@ -1407,6 +1408,34 @@ record_equivalences_from_phis (struct dom_walk_data *walk_data, basic_block bb)\n     }\n }\n \n+/* Ignoring loop backedges, if BB has precisely one incoming edge then\n+   return that edge.  Otherwise return NULL.  */\n+static edge\n+single_incoming_edge_ignoring_loop_edges (basic_block bb)\n+{\n+  edge retval = NULL;\n+  edge e;\n+\n+  for (e = bb->pred; e; e = e->pred_next)\n+    {\n+      /* A loop back edge can be identified by the destination of\n+\t the edge dominating the source of the edge.  */\n+      if (dominated_by_p (CDI_DOMINATORS, e->src, e->dest))\n+\tcontinue;\n+\n+      /* If we have already seen a non-loop edge, then we must have\n+\t multiple incoming non-loop edges and thus we return NULL.  */\n+      if (retval)\n+\treturn NULL;\n+\n+      /* This is the first non-loop incoming edge we have found.  Record\n+\t it.  */\n+      retval = e;\n+    }\n+\n+  return retval;\n+}\n+\n /* Record any equivalences created by the incoming edge to BB.  If BB\n    has more than one incoming edge, then no equivalence is created.  */\n \n@@ -1435,21 +1464,20 @@ record_equivalences_from_incoming_edge (struct dom_walk_data *walk_data,\n   eq_expr_value.src = NULL;\n   eq_expr_value.dst = NULL;\n \n-  /* If we have a single predecessor, then extract EDGE_FLAGS from\n-     our single incoming edge.  Otherwise clear EDGE_FLAGS and\n-     PARENT_BLOCK_LAST_STMT since they're not needed.  */\n+  /* If we have a single predecessor (ignoring loop backedges), then extract\n+     EDGE_FLAGS from the single incoming edge.  Otherwise just return as\n+     there is nothing to do.  */\n   if (bb->pred\n-      && ! bb->pred->pred_next\n-      && parent_block_last_stmt\n-      && bb_for_stmt (parent_block_last_stmt) == bb->pred->src)\n+      && parent_block_last_stmt)\n     {\n-      edge_flags = bb->pred->flags;\n+      edge e = single_incoming_edge_ignoring_loop_edges (bb);\n+      if (e && bb_for_stmt (parent_block_last_stmt) == e->src)\n+\tedge_flags = e->flags;\n+      else\n+\treturn;\n     }\n   else\n-    {\n-      edge_flags = 0;\n-      parent_block_last_stmt = NULL;\n-    }\n+    return;\n \n   /* If our parent block ended in a COND_EXPR, add any equivalences\n      created by the COND_EXPR to the hash table and initialize\n@@ -1462,9 +1490,7 @@ record_equivalences_from_incoming_edge (struct dom_walk_data *walk_data,\n      conditional. This assignment is inserted in CONST_AND_COPIES so that\n      the copy and constant propagator can find more propagation\n      opportunities.  */\n-  if (parent_block_last_stmt\n-      && bb->pred->pred_next == NULL\n-      && TREE_CODE (parent_block_last_stmt) == COND_EXPR\n+  if (TREE_CODE (parent_block_last_stmt) == COND_EXPR\n       && (edge_flags & (EDGE_TRUE_VALUE | EDGE_FALSE_VALUE)))\n     eq_expr_value = get_eq_expr_value (parent_block_last_stmt,\n \t\t\t\t       (edge_flags & EDGE_TRUE_VALUE) != 0,\n@@ -1474,9 +1500,7 @@ record_equivalences_from_incoming_edge (struct dom_walk_data *walk_data,\n   /* Similarly when the parent block ended in a SWITCH_EXPR.\n      We can only know the value of the switch's condition if the dominator\n      parent is also the only predecessor of this block.  */\n-  else if (parent_block_last_stmt\n-\t   && bb->pred->pred_next == NULL\n-\t   && bb->pred->src == parent\n+  else if (bb->pred->src == parent\n \t   && TREE_CODE (parent_block_last_stmt) == SWITCH_EXPR)\n     {\n       tree switch_cond = SWITCH_COND (parent_block_last_stmt);"}]}