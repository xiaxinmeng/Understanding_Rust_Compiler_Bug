{"sha": "6645c3fac816743d17d08fc47b9fbfa25d8d4a0f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjY0NWMzZmFjODE2NzQzZDE3ZDA4ZmM0N2I5ZmJmYTI1ZDhkNGEwZg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-08-10T22:01:22Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-08-10T22:01:22Z"}, "message": "* c-decl.c: Fix formatting.\n\nFrom-SVN: r35608", "tree": {"sha": "45b62283d3b127d2837656618133e1fa9adc700e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45b62283d3b127d2837656618133e1fa9adc700e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6645c3fac816743d17d08fc47b9fbfa25d8d4a0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6645c3fac816743d17d08fc47b9fbfa25d8d4a0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6645c3fac816743d17d08fc47b9fbfa25d8d4a0f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6645c3fac816743d17d08fc47b9fbfa25d8d4a0f/comments", "author": null, "committer": null, "parents": [{"sha": "7da92c086fa7008497a8f959418c7ce05e048d24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7da92c086fa7008497a8f959418c7ce05e048d24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7da92c086fa7008497a8f959418c7ce05e048d24"}], "stats": {"total": 364, "additions": 193, "deletions": 171}, "files": [{"sha": "7cb33c0cf78254f19188421aaefbc14449585f01", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6645c3fac816743d17d08fc47b9fbfa25d8d4a0f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6645c3fac816743d17d08fc47b9fbfa25d8d4a0f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6645c3fac816743d17d08fc47b9fbfa25d8d4a0f", "patch": "@@ -1,3 +1,7 @@\n+2000-08-10  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* c-decl.c: Fix formatting.\n+\n 2000-08-10  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* c-lex.c (parse_float, yylex): For -Wtraditional, issue a"}, {"sha": "48e842e580a6338968896336dedb7585c0cc0cf0", "filename": "gcc/c-decl.c", "status": "modified", "additions": 189, "deletions": 171, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6645c3fac816743d17d08fc47b9fbfa25d8d4a0f/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6645c3fac816743d17d08fc47b9fbfa25d8d4a0f/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=6645c3fac816743d17d08fc47b9fbfa25d8d4a0f", "patch": "@@ -19,7 +19,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-\n /* Process declarations and symbol lookup for C front end.\n    Also constructs types; the standard scalar types at initialization,\n    and structure, union, array and enum types when they are declared.  */\n@@ -227,7 +226,7 @@ struct binding_level\n     /* Nonzero means make a BLOCK if this level has any subblocks.  */\n     char keep_if_subblocks;\n \n-    /* Number of decls in `names' that have incomplete \n+    /* Number of decls in `names' that have incomplete\n        structure or union types.  */\n     int n_incomplete;\n \n@@ -238,7 +237,7 @@ struct binding_level\n   };\n \n #define NULL_BINDING_LEVEL (struct binding_level *) NULL\n-  \n+\n /* The binding level currently in effect.  */\n \n static struct binding_level *current_binding_level;\n@@ -267,7 +266,7 @@ static int keep_next_level_flag;\n    if it has subblocks.  */\n \n static int keep_next_if_subblocks;\n-  \n+\n /* The chain of outer levels of label scopes.\n    This uses the same data structure used for binding levels,\n    but it works differently: each link in the chain records\n@@ -355,7 +354,7 @@ int flag_allow_single_precision = 0;\n int flag_signed_bitfields = 1;\n int explicit_flag_signed_bitfields = 0;\n \n-/* Nonzero means warn about use of implicit int. */\n+/* Nonzero means warn about use of implicit int.  */\n \n int warn_implicit_int;\n \n@@ -364,7 +363,7 @@ int warn_implicit_int;\n int warn_long_long = 1;\n \n /* Nonzero means message about use of implicit function declarations;\n- 1 means warning; 2 means error. */\n+ 1 means warning; 2 means error.  */\n \n int mesg_implicit_function_declaration = -1;\n \n@@ -385,7 +384,7 @@ int warn_cast_qual;\n \n int warn_bad_function_cast;\n \n-/* Warn about functions which might be candidates for attribute noreturn. */\n+/* Warn about functions which might be candidates for attribute noreturn.  */\n \n int warn_missing_noreturn;\n \n@@ -452,22 +451,22 @@ int warn_main;\n \n /* Warn about #pragma directives that are not recognised.  */\n \n-int warn_unknown_pragmas = 0; /* Tri state variable.  */  \n+int warn_unknown_pragmas = 0; /* Tri state variable.  */\n \n /* Warn about comparison of signed and unsigned values.\n    If -1, neither -Wsign-compare nor -Wno-sign-compare has been specified.  */\n \n int warn_sign_compare = -1;\n \n-/* Warn about testing equality of floating point numbers. */\n+/* Warn about testing equality of floating point numbers.  */\n \n int warn_float_equal = 0;\n \n /* Nonzero means warn about use of multicharacter literals.  */\n \n int warn_multichar = 1;\n \n-/* Wrapper since C and C++ expand_expr_stmt are different. */\n+/* Wrapper since C and C++ expand_expr_stmt are different.  */\n \n expand_expr_stmt_fn lang_expand_expr_stmt = c_expand_expr_stmt;\n \n@@ -485,7 +484,7 @@ int dollars_in_ident = DOLLARS_IN_IDENTIFIERS;\n /* Decode the string P as a language-specific option for C.\n    Return the number of strings consumed.  Should not complain\n    if it does not recognise the option.  */\n-   \n+\n int\n c_decode_option (argc, argv)\n      int argc ATTRIBUTE_UNUSED;\n@@ -659,7 +658,7 @@ c_decode_option (argc, argv)\n     {\n       warn_implicit_int = 1;\n       if (mesg_implicit_function_declaration != 2)\n-        mesg_implicit_function_declaration = 1;\n+\tmesg_implicit_function_declaration = 1;\n     }\n   else if (!strcmp (p, \"-Wno-implicit\"))\n     warn_implicit_int = 0, mesg_implicit_function_declaration = 0;\n@@ -841,7 +840,7 @@ print_lang_identifier (file, node, indent)\n \f\n /* Hook called at end of compilation to assume 1 elt\n    for a top-level array decl that wasn't complete before.  */\n-   \n+\n void\n finish_incomplete_decl (decl)\n      tree decl;\n@@ -865,8 +864,7 @@ finish_incomplete_decl (decl)\n \f\n /* Create a new `struct binding_level'.  */\n \n-static\n-struct binding_level *\n+static struct binding_level *\n make_binding_level ()\n {\n   /* NOSTRICT */\n@@ -967,7 +965,7 @@ pushlevel (tag_transparent)\n   keep_next_if_subblocks = 0;\n }\n \n-/* Clear the limbo values of all identifiers defined in BLOCK or a subblock. */\n+/* Clear the limbo values of all identifiers defined in BLOCK or a subblock.  */\n \n static void\n clear_limbo_values (block)\n@@ -982,7 +980,7 @@ clear_limbo_values (block)\n   for (tem = BLOCK_SUBBLOCKS (block); tem; tem = TREE_CHAIN (tem))\n     clear_limbo_values (tem);\n }\n-    \n+\n /* Exit a binding level.\n    Pop the level off, and restore the state of the identifier-decl mappings\n    that were in effect when this level was entered.\n@@ -1183,8 +1181,8 @@ poplevel (keep, reverse, functionbody)\n   else if (block)\n     {\n       if (!block_previously_created)\n-        current_binding_level->blocks\n-          = chainon (current_binding_level->blocks, block);\n+\tcurrent_binding_level->blocks\n+\t  = chainon (current_binding_level->blocks, block);\n     }\n   /* If we did not make a block for the level just exited,\n      any blocks made for inner levels\n@@ -1207,8 +1205,7 @@ poplevel (keep, reverse, functionbody)\n      cases, the TYPE_CONTEXTs of the relevant tagged type nodes get set\n      in `grokdeclarator' as soon as we have created the FUNCTION_TYPE\n      node which will represent the \"scope\" for these \"parameter list local\"\n-     tagged types.\n-  */\n+     tagged types.  */\n \n   if (functionbody)\n     for (link = tags; link; link = TREE_CHAIN (link))\n@@ -1318,7 +1315,7 @@ pop_label_level ()\n \t\t\t    DECL_NAME (TREE_VALUE (link)));\n \t    }\n \t  else if (warn_unused_label && !TREE_USED (TREE_VALUE (link)))\n-\t    warning_with_decl (TREE_VALUE (link), \n+\t    warning_with_decl (TREE_VALUE (link),\n \t\t\t       \"label `%s' defined but not used\");\n \t  IDENTIFIER_LABEL_VALUE (DECL_NAME (TREE_VALUE (link))) = 0;\n \n@@ -1418,7 +1415,7 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n \n   if (DECL_P (olddecl))\n     DECL_MACHINE_ATTRIBUTES (newdecl)\n-      =  merge_machine_decl_attributes (olddecl, newdecl);\n+      = merge_machine_decl_attributes (olddecl, newdecl);\n \n   if (TREE_CODE (newtype) == ERROR_MARK\n       || TREE_CODE (oldtype) == ERROR_MARK)\n@@ -1456,7 +1453,7 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n \t\t\t       \"built-in function `%s' declared as non-function\");\n \t  else\n \t    warning_with_decl (newdecl,\n-\t\t\t     \"built-in function `%s' declared as non-function\");\n+\t\t\t       \"built-in function `%s' declared as non-function\");\n \t}\n       else\n \t{\n@@ -1500,18 +1497,18 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n \t}\n       else if (!types_match)\n \t{\n-          /* Accept the return type of the new declaration if same modes.  */\n+\t  /* Accept the return type of the new declaration if same modes.  */\n \t  tree oldreturntype = TREE_TYPE (oldtype);\n \t  tree newreturntype = TREE_TYPE (newtype);\n \n-          if (TYPE_MODE (oldreturntype) == TYPE_MODE (newreturntype))\n-            {\n+\t  if (TYPE_MODE (oldreturntype) == TYPE_MODE (newreturntype))\n+\t    {\n \t      /* Function types may be shared, so we can't just modify\n \t\t the return type of olddecl's function type.  */\n \t      tree trytype\n \t\t= build_function_type (newreturntype,\n \t\t\t\t       TYPE_ARG_TYPES (oldtype));\n-\t      \n+\n               types_match = comptypes (newtype, trytype);\n \t      if (types_match)\n \t\toldtype = trytype;\n@@ -1529,11 +1526,11 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n \t\t the return type of olddecl's function type.  */\n \t      tree trytype\n \t\t= build_function_type (TREE_TYPE (oldtype),\n-\t\t\t\t       tree_cons (NULL_TREE, \n+\t\t\t\t       tree_cons (NULL_TREE,\n \t\t\t\t\t\t  TREE_VALUE (TYPE_ARG_TYPES (newtype)),\n \t\t\t\t\t\t  TREE_CHAIN (TYPE_ARG_TYPES (oldtype))));\n-\t      \n-              types_match = comptypes (newtype, trytype);\n+\n+\t      types_match = comptypes (newtype, trytype);\n \t      if (types_match)\n \t\toldtype = trytype;\n \t    }\n@@ -1668,11 +1665,11 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n \t\t\t    : \"`%s' previously declared here\"));\n \t}\n       else if (TREE_CODE (newdecl) == TYPE_DECL\n-               && (DECL_IN_SYSTEM_HEADER (olddecl) \n+               && (DECL_IN_SYSTEM_HEADER (olddecl)\n                    || DECL_IN_SYSTEM_HEADER (newdecl)))\n \t{\n \t  warning_with_decl (newdecl, \"redefinition of `%s'\");\n-\t  warning_with_decl \n+\t  warning_with_decl\n \t    (olddecl,\n \t     ((DECL_INITIAL (olddecl)\n \t       && current_binding_level == global_binding_level)\n@@ -1705,7 +1702,8 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n \t      if (TYPE_MAIN_VARIANT (TREE_VALUE (parm)) == void_type_node\n \t\t  || TYPE_MAIN_VARIANT (TREE_VALUE (type)) == void_type_node)\n \t\t{\n-\t\t  error_with_decl (newdecl, \"prototype for `%s' follows and number of arguments doesn't match\");\n+\t\t  error_with_decl (newdecl,\n+\t\t\t\t   \"prototype for `%s' follows and number of arguments doesn't match\");\n \t\t  error_with_decl (olddecl, \"non-prototype definition here\");\n \t\t  errmsg = 1;\n \t\t  break;\n@@ -1752,7 +1750,7 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n \t    warning_with_decl (newdecl, \"static declaration for `%s' follows non-static\");\n \n \t  /* If warn_traditional, warn when a non-static function\n-\t     declaration follows a static one. */\n+\t     declaration follows a static one.  */\n \t  if (warn_traditional\n \t      && TREE_CODE (olddecl) == FUNCTION_DECL\n \t      && !TREE_PUBLIC (olddecl)\n@@ -1924,7 +1922,7 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n     }\n \n   /* Merge the storage class information.  */\n-  DECL_WEAK (newdecl) |= DECL_WEAK (olddecl);\t  \n+  DECL_WEAK (newdecl) |= DECL_WEAK (olddecl);\n   /* For functions, static overrides non-static.  */\n   if (TREE_CODE (newdecl) == FUNCTION_DECL)\n     {\n@@ -2172,23 +2170,23 @@ pushdecl (x)\n          on a standard type by checking the current value of lineno.  */\n \n       if (TREE_CODE (x) == TYPE_DECL)\n-        {\n-          if (DECL_SOURCE_LINE (x) == 0)\n-            {\n+\t{\n+\t  if (DECL_SOURCE_LINE (x) == 0)\n+\t    {\n \t      if (TYPE_NAME (TREE_TYPE (x)) == 0)\n-\t        TYPE_NAME (TREE_TYPE (x)) = x;\n-            }\n-          else if (TREE_TYPE (x) != error_mark_node\n+\t\tTYPE_NAME (TREE_TYPE (x)) = x;\n+\t    }\n+\t  else if (TREE_TYPE (x) != error_mark_node\n \t\t   && DECL_ORIGINAL_TYPE (x) == NULL_TREE)\n-            {\n-              tree tt = TREE_TYPE (x);\n+\t    {\n+\t      tree tt = TREE_TYPE (x);\n \t      DECL_ORIGINAL_TYPE (x) = tt;\n-              tt = build_type_copy (tt);\n-              TYPE_NAME (tt) = x;\n+\t      tt = build_type_copy (tt);\n+\t      TYPE_NAME (tt) = x;\n \t      TREE_USED (tt) = TREE_USED (x);\n-              TREE_TYPE (x) = tt;\n-            }\n-        }\n+\t      TREE_TYPE (x) = tt;\n+\t    }\n+\t}\n \n       /* Multiple external decls of the same identifier ought to match.\n \t Check against both global declarations (when traditional) and out of\n@@ -2273,7 +2271,7 @@ pushdecl (x)\n       if (b == global_binding_level)\n \t{\n \t  /* Install a global value.  */\n-\t  \n+\n \t  /* If the first global decl has external linkage,\n \t     warn if we later see static one.  */\n \t  if (IDENTIFIER_GLOBAL_VALUE (name) == 0 && TREE_PUBLIC (x))\n@@ -2379,7 +2377,8 @@ pushdecl (x)\n \t\t}\n \t    }\n \n-#if 0 /* This case is probably sometimes the right thing to do.  */\n+#if 0\n+\t  /* This case is probably sometimes the right thing to do.  */\n \t  /* If we have a local external declaration,\n \t     then any file-scope declaration should not\n \t     have been static.  */\n@@ -2398,7 +2397,7 @@ pushdecl (x)\n \t      && TREE_PUBLIC (x))\n \t    {\n \t      if (oldglobal == 0)\n-\t        TREE_PUBLIC (name) = 1;\n+\t\tTREE_PUBLIC (name) = 1;\n \n \t      /* Save this decl, so that we can do type checking against\n \t\t other decls after it falls out of scope.\n@@ -2508,9 +2507,11 @@ implicitly_declare (functionid)\n   /* We used to reuse an old implicit decl here,\n      but this loses with inline functions because it can clobber\n      the saved decl chains.  */\n-/*  if (IDENTIFIER_IMPLICIT_DECL (functionid) != 0)\n+#if 0\n+  if (IDENTIFIER_IMPLICIT_DECL (functionid) != 0)\n     decl = IDENTIFIER_IMPLICIT_DECL (functionid);\n-  else  */\n+  else\n+#endif\n     decl = build_decl (FUNCTION_DECL, functionid, default_function_type);\n \n   /* Warn of implicit decl following explicit local extern decl.\n@@ -2582,7 +2583,7 @@ redeclaration_error_message (newdecl, olddecl)\n \t is equivalent to what this code used to do before the build_type_copy\n \t call.  The variant type distinction should not matter for traditional\n \t code, because it doesn't have type qualifiers.  */\n-      if (flag_traditional \n+      if (flag_traditional\n \t  && TYPE_MAIN_VARIANT (TREE_TYPE (olddecl)) == TREE_TYPE (newdecl))\n \treturn 0;\n       if (DECL_IN_SYSTEM_HEADER (olddecl) || DECL_IN_SYSTEM_HEADER (newdecl))\n@@ -2706,7 +2707,7 @@ shadow_label (name)\n       for (dup = named_labels; dup; dup = TREE_CHAIN (dup))\n \tif (TREE_VALUE (dup) == decl)\n \t  {\n-\t    error (\"duplicate label declaration `%s'\", \n+\t    error (\"duplicate label declaration `%s'\",\n \t\t   IDENTIFIER_POINTER (name));\n \t    error_with_decl (TREE_VALUE (dup),\n \t\t\t     \"this is a previous declaration\");\n@@ -2744,7 +2745,7 @@ define_label (filename, line, name)\n   if (warn_traditional && lookup_name (name))\n     warning (\"traditional C lacks a separate namespace for labels, identifier `%s' conflicts\",\n \t     IDENTIFIER_POINTER (name));\n-  \n+\n   if (DECL_INITIAL (decl) != 0)\n     {\n       error (\"duplicate label `%s'\", IDENTIFIER_POINTER (name));\n@@ -2920,7 +2921,7 @@ lookup_name_current_level (name)\n \f\n /* Mark ARG for GC.  */\n \n-static void \n+static void\n mark_binding_level (arg)\n      void *arg;\n {\n@@ -2955,7 +2956,9 @@ init_decl_processing ()\n   named_labels = NULL;\n   current_binding_level = NULL_BINDING_LEVEL;\n   free_binding_level = NULL_BINDING_LEVEL;\n-  pushlevel (0);\t/* make the binding_level structure for global names */\n+\n+  /* Make the binding_level structure for global names.  */\n+  pushlevel (0);\n   global_binding_level = current_binding_level;\n \n   build_common_tree_nodes (flag_signed_char);\n@@ -3006,17 +3009,17 @@ init_decl_processing ()\n   signed_size_type_node = signed_type (t);\n   if (flag_traditional && TREE_UNSIGNED (t))\n     t = signed_type (t);\n-    \n+\n   set_sizetype (t);\n \n-  /* Create the widest literal types. */\n+  /* Create the widest literal types.  */\n   widest_integer_literal_type_node\n     = make_signed_type (HOST_BITS_PER_WIDE_INT * 2);\n   widest_unsigned_literal_type_node\n     = make_unsigned_type (HOST_BITS_PER_WIDE_INT * 2);\n-  pushdecl (build_decl (TYPE_DECL, NULL_TREE, \n+  pushdecl (build_decl (TYPE_DECL, NULL_TREE,\n \t\t\twidest_integer_literal_type_node));\n-  pushdecl (build_decl (TYPE_DECL, NULL_TREE, \n+  pushdecl (build_decl (TYPE_DECL, NULL_TREE,\n \t\t\twidest_unsigned_literal_type_node));\n \n   build_common_tree_nodes_2 (flag_short_double);\n@@ -3050,7 +3053,8 @@ init_decl_processing ()\n   signed_wchar_type_node = signed_type (wchar_type_node);\n   unsigned_wchar_type_node = unsigned_type (wchar_type_node);\n \n-  wint_type_node = TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (get_identifier (WINT_TYPE)));\n+  wint_type_node =\n+    TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (get_identifier (WINT_TYPE)));\n \n   boolean_type_node = integer_type_node;\n   boolean_true_node = integer_one_node;\n@@ -3070,8 +3074,7 @@ init_decl_processing ()\n   /* make a type for arrays of characters.\n      With luck nothing will ever really depend on the length of this\n      array type.  */\n-  char_array_type_node\n-    = build_array_type (char_type_node, array_domain_type);\n+  char_array_type_node = build_array_type (char_type_node, array_domain_type);\n \n   /* Likewise for arrays of ints.  */\n   int_array_type_node\n@@ -3083,8 +3086,7 @@ init_decl_processing ()\n \n   void_list_node = tree_cons (NULL_TREE, void_type_node, NULL_TREE);\n \n-  default_function_type\n-    = build_function_type (integer_type_node, NULL_TREE);\n+  default_function_type = build_function_type (integer_type_node, NULL_TREE);\n   ptrdiff_type_node\n     = TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (get_identifier (PTRDIFF_TYPE)));\n   unsigned_ptrdiff_type_node = unsigned_type (ptrdiff_type_node);\n@@ -3098,7 +3100,7 @@ init_decl_processing ()\n \t\t\t   tree_cons (NULL_TREE, ptr_type_node, endlink));\n \n   /* Types which are common to the fortran compiler and libf2c.  When\n-     changing these, you also need to be concerned with f/com.h. */\n+     changing these, you also need to be concerned with f/com.h.  */\n \n   if (TYPE_PRECISION (float_type_node)\n       == TYPE_PRECISION (long_integer_type_node))\n@@ -3172,7 +3174,7 @@ init_decl_processing ()\n \t\t\t  tree_cons (NULL_TREE, ptr_type_node,\n \t\t\t\t     tree_cons (NULL_TREE,\n \t\t\t\t\t\ttype_for_mode (ptr_mode, 0),\n-\t\t\t\t\t        tree_cons (NULL_TREE,\n+\t\t\t\t\t\ttree_cons (NULL_TREE,\n \t\t\t\t\t\t\t   ptr_type_node,\n \t\t\t\t\t\t\t   endlink)))),\n      BUILT_IN_EH_RETURN, BUILT_IN_NORMAL, NULL_PTR);\n@@ -3238,7 +3240,7 @@ c_make_fname_decl (id, name, type_dep)\n   TREE_TYPE (init) = type;\n   DECL_INITIAL (decl) = init;\n   finish_decl (pushdecl (decl), init, NULL_TREE);\n-  \n+\n   return decl;\n }\n \n@@ -3418,7 +3420,7 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n \t\t\t\t       NORMAL, initialized);\n   register tree tem;\n \n-  if (warn_main > 0 && TREE_CODE (decl) != FUNCTION_DECL \n+  if (warn_main > 0 && TREE_CODE (decl) != FUNCTION_DECL\n       && !strcmp (IDENTIFIER_POINTER (DECL_NAME (decl)), \"main\"))\n     warning_with_decl (decl, \"`%s' is usually a function\");\n \n@@ -3483,7 +3485,8 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n \n   if (initialized)\n     {\n-#if 0  /* Seems redundant with grokdeclarator.  */\n+#if 0\n+      /* Seems redundant with grokdeclarator.  */\n       if (current_binding_level != global_binding_level\n \t  && DECL_EXTERNAL (decl)\n \t  && TREE_CODE (decl) != FUNCTION_DECL)\n@@ -3669,19 +3672,19 @@ finish_decl (decl, init, asmspec_tree)\n \t    error_with_decl (decl, \"storage size of `%s' isn't constant\");\n \t}\n \n-      if (TREE_USED  (type))\n+      if (TREE_USED (type))\n \tTREE_USED (decl) = 1;\n     }\n \n   /* If this is a function and an assembler name is specified, it isn't\n      builtin any more.  Also reset DECL_RTL so we can give it its new\n      name.  */\n   if (TREE_CODE (decl) == FUNCTION_DECL && asmspec)\n-      {\n-\tDECL_BUILT_IN_CLASS (decl) = NOT_BUILT_IN;\n-\tDECL_RTL (decl) = 0;\n-\tDECL_ASSEMBLER_NAME (decl) = get_identifier (asmspec);\n-      }\n+    {\n+      DECL_BUILT_IN_CLASS (decl) = NOT_BUILT_IN;\n+      DECL_RTL (decl) = 0;\n+      DECL_ASSEMBLER_NAME (decl) = get_identifier (asmspec);\n+    }\n \n   /* Output the assembler code and/or RTL code for variables and functions,\n      unless the type is an undefined structure or union.\n@@ -3765,7 +3768,8 @@ push_parm_decl (parm)\n       tree olddecl;\n       olddecl = lookup_name (DECL_NAME (decl));\n       if (pedantic && olddecl != 0 && TREE_CODE (olddecl) == TYPE_DECL)\n-\tpedwarn_with_decl (decl, \"ANSI C forbids parameter `%s' shadowing typedef\");\n+\tpedwarn_with_decl (decl,\n+\t\t\t   \"ANSI C forbids parameter `%s' shadowing typedef\");\n     }\n #endif\n \n@@ -3997,7 +4001,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t  {\n \t    if (ridpointers[i] == id)\n \t      {\n-\t\tif (i == (int) RID_LONG && specbits & (1<<i))\n+\t\tif (i == (int) RID_LONG && specbits & (1 << i))\n \t\t  {\n \t\t    if (longlong)\n \t\t      error (\"`long long long' is too long for GCC\");\n@@ -4021,7 +4025,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n       else if (TREE_CODE (id) == TYPE_DECL)\n \t{\n \t  type = TREE_TYPE (id);\n-          decl_machine_attr = DECL_MACHINE_ATTRIBUTES (id);\n+\t  decl_machine_attr = DECL_MACHINE_ATTRIBUTES (id);\n \t  typedef_decl = id;\n \t}\n       /* Built-in types come as identifiers.  */\n@@ -4042,7 +4046,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n       else if (TREE_CODE (id) != ERROR_MARK)\n \ttype = id;\n \n-    found: {}\n+    found:\n+      ;\n     }\n \n   typedef_type = type;\n@@ -4067,7 +4072,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t  if ((warn_implicit_int || warn_return_type) && funcdef_flag)\n \t    warn_about_return_type = 1;\n \t  else if (warn_implicit_int || flag_isoc99)\n-\t    pedwarn_c99 (\"type defaults to `int' in declaration of `%s'\", name);\n+\t    pedwarn_c99 (\"type defaults to `int' in declaration of `%s'\",\n+\t\t\t name);\n \t}\n \n       defaulted_int = 1;\n@@ -4082,7 +4088,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n   if ((specbits & 1 << (int) RID_LONG) && ! longlong\n       && TYPE_MAIN_VARIANT (type) == double_type_node)\n     {\n-      specbits &= ~ (1 << (int) RID_LONG);\n+      specbits &= ~(1 << (int) RID_LONG);\n       type = long_double_type_node;\n     }\n \n@@ -4143,7 +4149,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n       && TREE_CODE (type) != INTEGER_TYPE && TREE_CODE (type) != REAL_TYPE)\n     {\n       error (\"complex invalid for `%s'\", name);\n-      specbits &= ~ (1 << (int) RID_COMPLEX);\n+      specbits &= ~(1 << (int) RID_COMPLEX);\n     }\n \n   /* Decide whether an integer type is signed or not.\n@@ -4259,8 +4265,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t  error (\"function definition declared `register'\");\n \tif (specbits & 1 << (int) RID_TYPEDEF)\n \t  error (\"function definition declared `typedef'\");\n-\tspecbits &= ~ ((1 << (int) RID_TYPEDEF) | (1 << (int) RID_REGISTER)\n-\t\t       | (1 << (int) RID_AUTO));\n+\tspecbits &= ~((1 << (int) RID_TYPEDEF) | (1 << (int) RID_REGISTER)\n+\t\t      | (1 << (int) RID_AUTO));\n       }\n     else if (decl_context != NORMAL && nclasses > 0)\n       {\n@@ -4271,7 +4277,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t    switch (decl_context)\n \t      {\n \t      case FIELD:\n-\t\terror (\"storage class specified for structure field `%s'\", name);\n+\t\terror (\"storage class specified for structure field `%s'\",\n+\t\t       name);\n \t\tbreak;\n \t      case PARM:\n \t\terror (\"storage class specified for parameter `%s'\", name);\n@@ -4280,9 +4287,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t\terror (\"storage class specified for typename\");\n \t\tbreak;\n \t      }\n-\t    specbits &= ~ ((1 << (int) RID_TYPEDEF) | (1 << (int) RID_REGISTER)\n-\t\t\t   | (1 << (int) RID_AUTO) | (1 << (int) RID_STATIC)\n-\t\t\t   | (1 << (int) RID_EXTERN));\n+\t    specbits &= ~((1 << (int) RID_TYPEDEF) | (1 << (int) RID_REGISTER)\n+\t\t\t  | (1 << (int) RID_AUTO) | (1 << (int) RID_STATIC)\n+\t\t\t  | (1 << (int) RID_EXTERN));\n \t  }\n       }\n     else if (specbits & 1 << (int) RID_EXTERN && initialized && ! funcdef_flag)\n@@ -4405,9 +4412,11 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t\t  if (pedantic)\n \t\t    {\n \t\t      if (TREE_CONSTANT (size))\n-\t\t\tpedwarn (\"ISO C89 forbids array `%s' whose size can't be evaluated\", name);\n+\t\t\tpedwarn (\"ISO C89 forbids array `%s' whose size can't be evaluated\",\n+\t\t\t\t name);\n \t\t      else\n-\t\t\tpedwarn (\"ISO C89 forbids variable-size array `%s'\", name);\n+\t\t\tpedwarn (\"ISO C89 forbids variable-size array `%s'\",\n+\t\t\t\t name);\n \t\t    }\n \t\t}\n \n@@ -4434,8 +4443,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t      itype = build_index_type (itype);\n \t    }\n \n-#if 0 /* This had bad results for pointers to arrays, as in\n-\t union incomplete (*foo)[4];  */\n+#if 0\n+\t  /* This had bad results for pointers to arrays, as in\n+\t     union incomplete (*foo)[4];  */\n \t  /* Complain about arrays of incomplete types, except in typedefs.  */\n \n \t  if (!COMPLETE_TYPE_P (type)\n@@ -4446,8 +4456,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t    warning (\"array type has incomplete element type\");\n #endif\n \n-#if 0  /* We shouldn't have a function type here at all!\n-\t  Functions aren't allowed as array elements.  */\n+#if 0\n+\t  /* We shouldn't have a function type here at all!\n+\t     Functions aren't allowed as array elements.  */\n \t  if (pedantic && TREE_CODE (type) == FUNCTION_TYPE\n \t      && (constp || volatilep))\n \t    pedwarn (\"ANSI C forbids const or volatile function types\");\n@@ -4462,8 +4473,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t  if (type_quals)\n \t    type = c_build_qualified_type (type, type_quals);\n \n-#if 0\t/* don't clear these; leave them set so that the array type\n-\t   or the variable is itself const or volatile.  */\n+#if 0\n+\t  /* Don't clear these; leave them set so that the array type\n+\t     or the variable is itself const or volatile.  */\n \t  type_quals = TYPE_UNQUALIFIED;\n #endif\n \n@@ -4745,7 +4757,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t    type = build_array_type (c_build_qualified_type (TREE_TYPE (type),\n \t\t\t\t\t\t\t     type_quals),\n \t\t\t\t     TYPE_DOMAIN (type));\n-#if 0 /* Leave the field const or volatile as well.  */\n+#if 0\n+\t    /* Leave the field const or volatile as well.  */\n \t    type_quals = TYPE_UNQUALIFIED;\n #endif\n \t  }\n@@ -4957,8 +4970,10 @@ grokparms (parms_info, funcdef_flag)\n \t\t      TREE_TYPE (parm) = error_mark_node;\n \t\t    }\n \t\t}\n-#if 0  /* This has been replaced by parm_tags_warning\n-\t  which uses a more accurate criterion for what to warn about.  */\n+#if 0\n+\t      /* This has been replaced by parm_tags_warning, which\n+\t\t uses a more accurate criterion for what to warn\n+\t\t about.  */\n \t      else\n \t\t{\n \t\t  /* Now warn if is a pointer to an incomplete type.  */\n@@ -4979,11 +4994,10 @@ grokparms (parms_info, funcdef_flag)\n \t      typelt = TREE_CHAIN (typelt);\n \t    }\n \n-\treturn first_parm;\n+      return first_parm;\n     }\n }\n \n-\n /* Return a tree_list node with info on a parameter list just parsed.\n    The TREE_PURPOSE is a chain of decls of those parms.\n    The TREE_VALUE is a list of structure, union and enum tags defined.\n@@ -5009,8 +5023,7 @@ get_parm_info (void_at_end)\n      But if the `void' is qualified (by `const' or `volatile') or has a\n      storage class specifier (`register'), then the behavior is undefined;\n      by not counting it as the special case of `void' we will cause an\n-     error later.  Typedefs for `void' are OK (see DR#157).\n-  */\n+     error later.  Typedefs for `void' are OK (see DR#157).  */\n   if (void_at_end && parms != 0\n       && TREE_CHAIN (parms) == 0\n       && VOID_TYPE_P (TREE_TYPE (parms))\n@@ -5027,7 +5040,7 @@ get_parm_info (void_at_end)\n \n   /* Extract enumerator values and other non-parms declared with the parms.\n      Likewise any forward parm decls that didn't have real parm decls.  */\n-  for (decl = parms; decl; )\n+  for (decl = parms; decl;)\n     {\n       tree next = TREE_CHAIN (decl);\n \n@@ -5038,7 +5051,8 @@ get_parm_info (void_at_end)\n \t}\n       else if (TREE_ASM_WRITTEN (decl))\n \t{\n-\t  error_with_decl (decl, \"parameter `%s' has just a forward declaration\");\n+\t  error_with_decl (decl,\n+\t\t\t   \"parameter `%s' has just a forward declaration\");\n \t  TREE_CHAIN (decl) = new_parms;\n \t  new_parms = decl;\n \t}\n@@ -5115,13 +5129,13 @@ parmlist_tags_warning ()\n \t\t  : \"enum\"),\n \t\t IDENTIFIER_POINTER (TREE_PURPOSE (elt)));\n       else\n-        {\n-          /* For translation these need to be seperate warnings */\n-          if (code == RECORD_TYPE)\n+\t{\n+\t  /* For translation these need to be seperate warnings */\n+\t  if (code == RECORD_TYPE)\n \t    warning (\"anonymous struct declared inside parameter list\");\n \t  else if (code == UNION_TYPE)\n \t    warning (\"anonymous union declared inside parameter list\");\n-\t  else\t  \n+\t  else\n \t    warning (\"anonymous enum declared inside parameter list\");\n \t}\n       if (! already)\n@@ -5362,7 +5376,7 @@ finish_struct (t, fieldlist, attributes)\n \t{\n \t  if (tree_int_cst_sgn (DECL_INITIAL (x)) < 0)\n \t    error_with_decl (x, \"negative width in bit-field `%s'\");\n-\t  else if (0 < compare_tree_int (DECL_INITIAL (x), \n+\t  else if (0 < compare_tree_int (DECL_INITIAL (x),\n \t\t\t\t\t TYPE_PRECISION (TREE_TYPE (x))))\n \t    pedwarn_with_decl (x, \"width of `%s' exceeds its type\");\n \t  else if (integer_zerop (DECL_INITIAL (x)) && DECL_NAME (x) != 0)\n@@ -5426,7 +5440,7 @@ finish_struct (t, fieldlist, attributes)\n     else\n       {\n \tregister tree y = fieldlist;\n-\t  \n+\n \twhile (1)\n \t  {\n \t    if (DECL_NAME (y) == DECL_NAME (TREE_CHAIN (x)))\n@@ -5440,7 +5454,8 @@ finish_struct (t, fieldlist, attributes)\n \t    error_with_decl (TREE_CHAIN (x), \"duplicate member `%s'\");\n \t    TREE_CHAIN (x) = TREE_CHAIN (TREE_CHAIN (x));\n \t  }\n-\telse x = TREE_CHAIN (x);\n+\telse\n+\t  x = TREE_CHAIN (x);\n       }\n \n   /* Now we have the nearly final fieldlist.  Record it,\n@@ -5876,7 +5891,7 @@ start_function (declspecs, declarator, prefix_attributes, attributes)\n \t   && old_decl != 0 && TREE_USED (old_decl)\n \t   && TYPE_ARG_TYPES (TREE_TYPE (old_decl)) == 0)\n     warning_with_decl (decl1,\n-\t\t      \"`%s' was used with no prototype before its definition\");\n+\t\t       \"`%s' was used with no prototype before its definition\");\n   /* Optionally warn of any global def with no previous declaration.  */\n   else if (warn_missing_declarations\n \t   && TREE_PUBLIC (decl1)\n@@ -5889,7 +5904,7 @@ start_function (declspecs, declarator, prefix_attributes, attributes)\n \t   && old_decl != 0 && TREE_USED (old_decl)\n \t   && old_decl == IDENTIFIER_IMPLICIT_DECL (DECL_NAME (decl1)))\n     warning_with_decl (decl1,\n-\t\t    \"`%s' was used with no declaration before its definition\");\n+\t\t       \"`%s' was used with no declaration before its definition\");\n \n   /* This is a definition, not a reference.\n      So normally clear DECL_EXTERNAL.\n@@ -5900,7 +5915,7 @@ start_function (declspecs, declarator, prefix_attributes, attributes)\n #ifdef SET_DEFAULT_DECL_ATTRIBUTES\n   SET_DEFAULT_DECL_ATTRIBUTES (decl1, attributes);\n #endif\n-  \n+\n   /* This function exists in static storage.\n      (This does not mean `static' in the C sense!)  */\n   TREE_STATIC (decl1) = 1;\n@@ -5909,15 +5924,15 @@ start_function (declspecs, declarator, prefix_attributes, attributes)\n   if (current_function_decl != 0)\n     TREE_PUBLIC (decl1) = 0;\n \n-  /* Warn for unlikely, improbable, or stupid declarations of `main'. */\n+  /* Warn for unlikely, improbable, or stupid declarations of `main'.  */\n   if (warn_main > 0\n       && strcmp (\"main\", IDENTIFIER_POINTER (DECL_NAME (decl1))) == 0)\n     {\n       tree args;\n       int argct = 0;\n \n       if (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (decl1)))\n-\t   != integer_type_node)\n+\t  != integer_type_node)\n \tpedwarn_with_decl (decl1, \"return type of `%s' is not `int'\");\n \n       for (args = TYPE_ARG_TYPES (TREE_TYPE (decl1)); args;\n@@ -5943,7 +5958,7 @@ start_function (declspecs, declarator, prefix_attributes, attributes)\n \t\t  || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (type)))\n \t\t      != char_type_node))\n \t\tpedwarn_with_decl (decl1,\n-\t\t\t       \"second argument of `%s' should be `char **'\");\n+\t\t\t\t   \"second argument of `%s' should be `char **'\");\n \t      break;\n \n \t    case 3:\n@@ -5952,14 +5967,14 @@ start_function (declspecs, declarator, prefix_attributes, attributes)\n \t\t  || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (type)))\n \t\t      != char_type_node))\n \t\tpedwarn_with_decl (decl1,\n-\t\t   \"third argument of `%s' should probably be `char **'\");\n+\t\t\t\t   \"third argument of `%s' should probably be `char **'\");\n \t      break;\n \t    }\n \t}\n \n       /* It is intentional that this message does not mention the third\n \t argument, which is warned for only pedantically, because it's\n-\t blessed by mention in an appendix of the standard. */\n+\t blessed by mention in an appendix of the standard.  */\n       if (argct > 0 && (argct < 2 || argct > 3))\n \tpedwarn_with_decl (decl1, \"`%s' takes only zero or two arguments\");\n \n@@ -6124,8 +6139,7 @@ store_parm_decls ()\n \t     won't depend on its type.  */\n \t  TREE_TYPE (dummy) = integer_type_node;\n \t  DECL_ARG_TYPE (dummy) = integer_type_node;\n-\t  DECL_ARGUMENTS (fndecl)\n-\t    = chainon (DECL_ARGUMENTS (fndecl), dummy);\n+\t  DECL_ARGUMENTS (fndecl) = chainon (DECL_ARGUMENTS (fndecl), dummy);\n \t}\n #endif\n \n@@ -6227,7 +6241,7 @@ store_parm_decls ()\n \n \t  TREE_PURPOSE (parm) = found;\n \n-\t  /* Mark this decl as \"already found\" */\n+\t  /* Mark this decl as \"already found\".  */\n \t  DECL_WEAK (found) = 1;\n \t}\n \n@@ -6238,7 +6252,7 @@ store_parm_decls ()\n \t any actual PARM_DECLs not matched with any names.  */\n \n       nonparms = 0;\n-      for (parm = parmdecls; parm; )\n+      for (parm = parmdecls; parm;)\n \t{\n \t  tree next = TREE_CHAIN (parm);\n \t  TREE_CHAIN (parm) = 0;\n@@ -6249,19 +6263,19 @@ store_parm_decls ()\n \t    {\n \t      /* Complain about args with incomplete types.  */\n \t      if (!COMPLETE_TYPE_P (TREE_TYPE (parm)))\n-\t        {\n-\t          error_with_decl (parm, \"parameter `%s' has incomplete type\");\n-\t          TREE_TYPE (parm) = error_mark_node;\n-\t        }\n+\t\t{\n+\t\t  error_with_decl (parm, \"parameter `%s' has incomplete type\");\n+\t\t  TREE_TYPE (parm) = error_mark_node;\n+\t\t}\n \n \t      if (! DECL_WEAK (parm))\n-\t        {\n-\t          error_with_decl (parm,\n-\t\t\t           \"declaration for parameter `%s' but no such parameter\");\n+\t\t{\n+\t\t  error_with_decl (parm,\n+\t\t\t\t   \"declaration for parameter `%s' but no such parameter\");\n \t          /* Pretend the parameter was not missing.\n \t\t     This gets us to a standard state and minimizes\n \t\t     further error messages.  */\n-\t          specparms\n+\t\t  specparms\n \t\t    = chainon (specparms,\n \t\t\t       tree_cons (parm, NULL_TREE, NULL_TREE));\n \t\t}\n@@ -6270,8 +6284,9 @@ store_parm_decls ()\n \t  parm = next;\n \t}\n \n-      /* Chain the declarations together in the order of the list of names.  */\n-      /* Store that chain in the function decl, replacing the list of names.  */\n+      /* Chain the declarations together in the order of the list of\n+         names.  Store that chain in the function decl, replacing the\n+         list of names.  */\n       parm = specparms;\n       DECL_ARGUMENTS (fndecl) = 0;\n       {\n@@ -6530,7 +6545,7 @@ combine_parm_decls (specparms, parmlist, void_at_end)\n \n   /* Complain about any actual PARM_DECLs not matched with any names.  */\n \n-  for (parm = parmdecls; parm; )\n+  for (parm = parmdecls; parm;)\n     {\n       tree next = TREE_CHAIN (parm);\n       TREE_CHAIN (parm) = 0;\n@@ -6577,7 +6592,7 @@ combine_parm_decls (specparms, parmlist, void_at_end)\n \t  types = tree_cons (NULL_TREE, TREE_TYPE (parm), types);\n \t}\n   }\n-  \n+\n   if (void_at_end)\n     return tree_cons (parmdecls, nonparms,\n \t\t      nreverse (tree_cons (NULL_TREE, void_type_node, types)));\n@@ -6624,7 +6639,7 @@ finish_function (nested)\n \t  != integer_type_node)\n \t{\n \t  /* If warn_main is 1 (-Wmain) or 2 (-Wall), we have already warned.\n-\t     If warn_main is -1 (-Wno-main) we don't want to be warned. */\n+\t     If warn_main is -1 (-Wno-main) we don't want to be warned.  */\n \t  if (! warn_main)\n \t    pedwarn_with_decl (fndecl, \"return type of `%s' is not `int'\");\n \t}\n@@ -6700,16 +6715,16 @@ finish_function (nested)\n \t\t\t       size_as_int);\n \t  else\n \t    warning_with_decl (fndecl,\n-\t\t       \"size of return value of `%s' is larger than %d bytes\",\n+\t\t\t       \"size of return value of `%s' is larger than %d bytes\",\n \t\t\t       larger_than_size);\n \t}\n     }\n \n   if (DECL_SAVED_INSNS (fndecl) == 0 && ! nested)\n     {\n-      /* Stop pointing to the local nodes about to be freed. \n+      /* Stop pointing to the local nodes about to be freed.\n \t But DECL_INITIAL must remain nonzero so we know this\n-\t was an actual function definition. \n+\t was an actual function definition.\n \t For a nested function, this is done in pop_c_function_context.\n \t If rest_of_compilation set this to 0, leave it 0.  */\n       if (DECL_INITIAL (fndecl) != 0)\n@@ -6725,7 +6740,7 @@ finish_function (nested)\n \tstatic_ctors = tree_cons (NULL_TREE, fndecl, static_ctors);\n       else\n #endif\n-\tassemble_constructor (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (fndecl))); \n+\tassemble_constructor (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (fndecl)));\n \n     }\n   if (DECL_STATIC_DESTRUCTOR (fndecl))\n@@ -6819,6 +6834,7 @@ pop_c_function_context (f)\n }\n \n /* Mark the language specific parts of F for GC.  */\n+\n void\n mark_c_function_context (f)\n      struct function *f;\n@@ -6843,16 +6859,18 @@ copy_lang_decl (node)\n }\n \n /* Mark ARG for GC.  */\n+\n void\n lang_mark_false_label_stack (arg)\n      struct label_node *arg;\n {\n   /* C doesn't use false_label_stack.  It better be NULL.  */\n   if (arg != NULL)\n-    abort();\n+    abort ();\n }\n \n /* Mark the language specific bits in T for GC.  */\n+\n void\n lang_mark_tree (t)\n      tree t;\n@@ -6874,7 +6892,7 @@ lang_mark_tree (t)\n /* The functions below are required for functionality of doing\n    function at once processing in the C front end. Currently these\n    functions are not called from anywhere in the C front end, but as\n-   these changes continue, that will change. */\n+   these changes continue, that will change.  */\n \n /* Returns non-zero if the current statement is a full expression,\n    i.e. temporaries created during that statement should be destroyed\n@@ -6887,9 +6905,9 @@ stmts_are_full_exprs_p ()\n }\n \n /* Nonzero if TYPE is an anonymous union or struct type.  Always 0 in\n-   C. */\n+   C.  */\n \n-int \n+int\n anon_aggr_type_p (node)\n      tree node ATTRIBUTE_UNUSED;\n {\n@@ -6907,7 +6925,7 @@ current_function_name_declared ()\n   return 0;\n }\n \n-/* Code to generate the RTL for a case label in C. */\n+/* Code to generate the RTL for a case label in C.  */\n \n void\n do_case (low_value, high_value)\n@@ -6922,47 +6940,48 @@ do_case (low_value, high_value)\n     value2 = check_case_value (high_value);\n \n   label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n-  \n+\n   if (pedantic && (high_value != NULL_TREE))\n     pedwarn (\"ISO C forbids case ranges\");\n \n   if (value1 != error_mark_node && value2 != error_mark_node)\n     {\n       tree duplicate;\n       int success;\n-      \n+\n       if (high_value == NULL_TREE && value1 != NULL_TREE &&\n \t  pedantic && ! INTEGRAL_TYPE_P (TREE_TYPE (value1)))\n \tpedwarn (\"label must have integral type in ISO C\");\n-      \n+\n       if (low_value == NULL_TREE)\n \tsuccess = pushcase (NULL_TREE, 0, label, &duplicate);\n       else if (high_value == NULL_TREE)\n-\tsuccess = pushcase (value1, convert_and_check, label,\n-\t\t\t    &duplicate);\n+\tsuccess = pushcase (value1, convert_and_check, label, &duplicate);\n       else\n \tsuccess = pushcase_range (value1, value2, convert_and_check,\n \t\t\t\t  label, &duplicate);\n-      \n+\n       if (success == 1)\n \t{\n \t  if (low_value == NULL_TREE)\n \t    error (\"default label not within a switch statement\");\n \t  else\n \t    error (\"case label not within a switch statement\");\n \t}\n-      else if (success == 2) {\n-\tif (low_value == NULL_TREE) \n-\t  {\n-\t    error (\"multiple default labels in one switch\");\n-\t    error_with_decl (duplicate, \"this is the first default label\");\n-\t  }\n-\telse\n-\t  error (\"dupicate case value\");\n-\tif (high_value != NULL_TREE)\n-\t  error_with_decl (duplicate, \"this is the first entry for that value\");\n-      }\n-      else if (low_value != NULL_TREE) \n+      else if (success == 2)\n+\t{\n+\t  if (low_value == NULL_TREE)\n+\t    {\n+\t      error (\"multiple default labels in one switch\");\n+\t      error_with_decl (duplicate, \"this is the first default label\");\n+\t    }\n+\t  else\n+\t    error (\"dupicate case value\");\n+\t  if (high_value != NULL_TREE)\n+\t    error_with_decl (duplicate,\n+\t\t\t     \"this is the first entry for that value\");\n+\t}\n+      else if (low_value != NULL_TREE)\n \t{\n \t  if (success == 3)\n \t    warning (\"case value out of range\");\n@@ -6973,7 +6992,7 @@ do_case (low_value, high_value)\n }\n \n /* Language specific handler of tree nodes used when generating RTL\n-   from a tree. */\n+   from a tree.  */\n \n tree\n lang_expand_stmt (t)\n@@ -6983,12 +7002,11 @@ lang_expand_stmt (t)\n   return NULL_TREE;\n }\n \n-/* Accessor to set the 'current_function_name_declared' flag. */\n+/* Accessor to set the 'current_function_name_declared' flag.  */\n \n void\n set_current_function_name_declared (i)\n      int i ATTRIBUTE_UNUSED;\n {\n   abort ();\n }\n-"}]}