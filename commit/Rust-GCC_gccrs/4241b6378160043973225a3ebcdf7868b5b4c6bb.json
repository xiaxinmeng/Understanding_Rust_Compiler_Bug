{"sha": "4241b6378160043973225a3ebcdf7868b5b4c6bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDI0MWI2Mzc4MTYwMDQzOTczMjI1YTNlYmNkZjc4NjhiNWI0YzZiYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2001-09-18T16:26:41Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2001-09-18T16:26:41Z"}, "message": "* g++.dg/eh/registers1.C: New test case.\n\nFrom-SVN: r45679", "tree": {"sha": "0f961ca3a429d3204d44d6eed2c2a5ae0f3ab1f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f961ca3a429d3204d44d6eed2c2a5ae0f3ab1f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4241b6378160043973225a3ebcdf7868b5b4c6bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4241b6378160043973225a3ebcdf7868b5b4c6bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4241b6378160043973225a3ebcdf7868b5b4c6bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4241b6378160043973225a3ebcdf7868b5b4c6bb/comments", "author": null, "committer": null, "parents": [{"sha": "1cbfdb1f9c65719d1e57bb214674c3751a551e60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cbfdb1f9c65719d1e57bb214674c3751a551e60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cbfdb1f9c65719d1e57bb214674c3751a551e60"}], "stats": {"total": 142, "additions": 142, "deletions": 0}, "files": [{"sha": "7f28c4cb0cf47fb0d3f79b18d79751cf3f546655", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4241b6378160043973225a3ebcdf7868b5b4c6bb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4241b6378160043973225a3ebcdf7868b5b4c6bb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4241b6378160043973225a3ebcdf7868b5b4c6bb", "patch": "@@ -1,3 +1,7 @@\n+2001-09-18  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* g++.dg/eh/registers1.C: New test case.\n+\n 2001-09-17  Richard Henderson  <rth@redhat.com>\n \n \t* gcc.dg/array-5.c: Fix VLA decomposition test."}, {"sha": "6633e834d7281de4d4b301dfb1921a1e12ba8973", "filename": "gcc/testsuite/g++.dg/eh/registers1.C", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4241b6378160043973225a3ebcdf7868b5b4c6bb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fregisters1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4241b6378160043973225a3ebcdf7868b5b4c6bb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fregisters1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fregisters1.C?ref=4241b6378160043973225a3ebcdf7868b5b4c6bb", "patch": "@@ -0,0 +1,138 @@\n+// Try to check that registers are preserved when the stack is unwound.\n+// { dg-do run }\n+// { dg-options -O2 }\n+\n+extern \"C\" void exit(int);\n+extern \"C\" void abort();\n+\n+// This test case triggers up to DEPTH recursive calls to function\n+// foo(), These calls are numbered so that 0 is the innermost, 1 the\n+// second innermost, and so on.  Each call caches NUM_VARS elements of\n+// both DOUBLE_SRC and INT_SRC and applies a trivial operation to each\n+// cached value.  The innermost foo() call will throw an integer call\n+// number.  The specified call should store its cached values in\n+// DOUBLE_DEST and INT_DEST, which main() will check.\n+const int num_vars = 16;\n+const int depth = 3;\n+\n+float float_src[num_vars * depth];\n+float float_dest[num_vars];\n+\n+int int_src[num_vars * depth];\n+int int_dest[num_vars];\n+\n+void foo (int level, int throw_to)\n+{\n+  float *fsrc = &float_src[level * num_vars];\n+  float f00 = *fsrc++ + 1.0f;\n+  float f01 = *fsrc++ + 1.0f;\n+  float f02 = *fsrc++ + 1.0f;\n+  float f03 = *fsrc++ + 1.0f;\n+  float f04 = *fsrc++ + 1.0f;\n+  float f05 = *fsrc++ + 1.0f;\n+  float f06 = *fsrc++ + 1.0f;\n+  float f07 = *fsrc++ + 1.0f;\n+  float f08 = *fsrc++ + 1.0f;\n+  float f09 = *fsrc++ + 1.0f;\n+  float f10 = *fsrc++ + 1.0f;\n+  float f11 = *fsrc++ + 1.0f;\n+  float f12 = *fsrc++ + 1.0f;\n+  float f13 = *fsrc++ + 1.0f;\n+  float f14 = *fsrc++ + 1.0f;\n+  float f15 = *fsrc++ + 1.0f;\n+\n+  int *isrc = &int_src[level * num_vars];\n+  int i00 = *isrc++ + 1;\n+  int i01 = *isrc++ + 1;\n+  int i02 = *isrc++ + 1;\n+  int i03 = *isrc++ + 1;\n+  int i04 = *isrc++ + 1;\n+  int i05 = *isrc++ + 1;\n+  int i06 = *isrc++ + 1;\n+  int i07 = *isrc++ + 1;\n+  int i08 = *isrc++ + 1;\n+  int i09 = *isrc++ + 1;\n+  int i10 = *isrc++ + 1;\n+  int i11 = *isrc++ + 1;\n+  int i12 = *isrc++ + 1;\n+  int i13 = *isrc++ + 1;\n+  int i14 = *isrc++ + 1;\n+  int i15 = *isrc++ + 1;\n+\n+  try\n+    {\n+      if (level == 0)\n+\tthrow throw_to;\n+      else\n+\tfoo (level - 1, throw_to);\n+    }\n+  catch (int i)\n+    {\n+      if (i == level)\n+\t{\n+\t  float *fdest = float_dest;\n+\t  *fdest++ = f00;\n+\t  *fdest++ = f01;\n+\t  *fdest++ = f02;\n+\t  *fdest++ = f03;\n+\t  *fdest++ = f04;\n+\t  *fdest++ = f05;\n+\t  *fdest++ = f06;\n+\t  *fdest++ = f07;\n+\t  *fdest++ = f08;\n+\t  *fdest++ = f09;\n+\t  *fdest++ = f10;\n+\t  *fdest++ = f11;\n+\t  *fdest++ = f12;\n+\t  *fdest++ = f13;\n+\t  *fdest++ = f14;\n+\t  *fdest++ = f15;\n+\n+\t  int *idest = int_dest;\n+\t  *idest++ = i00;\n+\t  *idest++ = i01;\n+\t  *idest++ = i02;\n+\t  *idest++ = i03;\n+\t  *idest++ = i04;\n+\t  *idest++ = i05;\n+\t  *idest++ = i06;\n+\t  *idest++ = i07;\n+\t  *idest++ = i08;\n+\t  *idest++ = i09;\n+\t  *idest++ = i10;\n+\t  *idest++ = i11;\n+\t  *idest++ = i12;\n+\t  *idest++ = i13;\n+\t  *idest++ = i14;\n+\t  *idest++ = i15;\n+\t}\n+      else\n+\t{\n+\t  throw;\n+\t}\n+    }\n+}\n+\n+int main ()\n+{\n+  for (int i = 0; i < depth * num_vars; i++)\n+    {\n+      int_src[i] = i * i;\n+      float_src[i] = i * 2.0f;\n+    }\n+  for (int level = 0; level < depth; level++)\n+    for (int throw_to = 0; throw_to <= level; throw_to++)\n+      {\n+\tfoo (level, throw_to);\n+\tfloat *fsrc = &float_src[throw_to * num_vars];\n+\tint *isrc = &int_src[throw_to * num_vars];\n+\tfor (int i = 0; i < num_vars; i++)\n+\t  {\n+\t    if (int_dest[i] != isrc[i] + 1)\n+\t      abort ();\n+\t    if (float_dest[i] != fsrc[i] + 1.0f)\n+\t      abort ();\n+\t  }\n+      }\n+  exit (0);\n+}"}]}