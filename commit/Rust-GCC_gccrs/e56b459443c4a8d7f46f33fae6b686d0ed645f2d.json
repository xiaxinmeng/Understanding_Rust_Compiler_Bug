{"sha": "e56b459443c4a8d7f46f33fae6b686d0ed645f2d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU2YjQ1OTQ0M2M0YThkN2Y0NmYzM2ZhZTZiNjg2ZDBlZDY0NWYyZA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2001-01-02T00:59:52Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2001-01-02T00:59:52Z"}, "message": "tm.texi (REGISTER_MOVE_COST): Add a mode argument.\n\n* tm.texi (REGISTER_MOVE_COST): Add a mode argument.\n* reload.c (REGISTER_MOVE_COST): Likewise.  Adjust all callers.\n* reload1.c (REGISTER_MOVE_COST): Likewise.\n* regclass.c (REGISTER_MOVE_COST): Likewise.\n(move_cost, may_move_in_cost, may_move_out_cost): Add mode\ndimension.  Adjust all users.\n(init_reg_sets_1): Iterate on all modes.\n* config/1750a/1750a.h (REGISTER_MOVE_COST): Adjust.\n* config/a29k/a29k.h (REGISTER_MOVE_COST): Adjust.\n* config/alpha/alpha.h (REGISTER_MOVE_COST): Adjust.\n* config/arc/arc.h (REGISTER_MOVE_COST): Adjust.\n* config/arm/arm.h (REGISTER_MOVE_COST): Adjust.\n* config/avr/avr.h (REGISTER_MOVE_COST): Adjust.\n* config/c4x/c4x.h (REGISTER_MOVE_COST): Adjust.\n* config/d30v/d30v.h (REGISTER_MOVE_COST): Adjust.\n* config/dsp16xx/dsp16xx.h (REGISTER_MOVE_COST): Adjust.\n* config/h8300/h8300.h (REGISTER_MOVE_COST): Adjust.\n* config/i386/i386.h (REGISTER_MOVE_COST): Adjust.\n* config/ia64/ia64.h (REGISTER_MOVE_COST): Adjust.\n* config/m32r/m32r.h (REGISTER_MOVE_COST): Adjust.\n* config/m68hc11/m68hc11.h (REGISTER_MOVE_COST): Adjust.\n* config/m68k/m68k.h (REGISTER_MOVE_COST): Adjust.\n* config/mcore/mcore.h (REGISTER_MOVE_COST): Adjust.\n* config/mips/mips.h (REGISTER_MOVE_COST): Adjust.\n* config/mn10200/mn10200.h (REGISTER_MOVE_COST): Adjust.\n* config/mn10300/mn10300.h (REGISTER_MOVE_COST): Adjust.\n* config/ns32k/ns32k.h (REGISTER_MOVE_COST): Adjust.\n* config/pa/pa.h (REGISTER_MOVE_COST): Adjust.\n* config/pdp11/pdp11.h (REGISTER_MOVE_COST): Adjust.\n* config/pj/pj.h (REGISTER_MOVE_COST): Adjust.\n* config/romp/romp.h (REGISTER_MOVE_COST): Adjust.\n* config/rs6000/rs6000.h (REGISTER_MOVE_COST): Adjust.\n* config/sh/sh.h (REGISTER_MOVE_COST): Adjust.\n* config/sparc/sparc.h (REGISTER_MOVE_COST): Adjust.\n\nFrom-SVN: r38604", "tree": {"sha": "e521405558bc22c6ba3380b06b0ff680d3435a47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e521405558bc22c6ba3380b06b0ff680d3435a47"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e56b459443c4a8d7f46f33fae6b686d0ed645f2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e56b459443c4a8d7f46f33fae6b686d0ed645f2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e56b459443c4a8d7f46f33fae6b686d0ed645f2d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e56b459443c4a8d7f46f33fae6b686d0ed645f2d/comments", "author": null, "committer": null, "parents": [{"sha": "5b1ef594574c48fc88045d143efe913f704e3f09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b1ef594574c48fc88045d143efe913f704e3f09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b1ef594574c48fc88045d143efe913f704e3f09"}], "stats": {"total": 126, "additions": 67, "deletions": 59}, "files": [{"sha": "ca4cbd6907a0b852157e2831a27cbf69f329a4e1", "filename": "gcc/regclass.c", "status": "modified", "additions": 48, "deletions": 44, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56b459443c4a8d7f46f33fae6b686d0ed645f2d/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56b459443c4a8d7f46f33fae6b686d0ed645f2d/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=e56b459443c4a8d7f46f33fae6b686d0ed645f2d", "patch": "@@ -1,6 +1,6 @@\n /* Compute register class preferences for pseudo-registers.\n    Copyright (C) 1987, 1988, 1991, 1992, 1993, 1994, 1995, 1996\n-   1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n+   1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -42,7 +42,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"ggc.h\"\n \n #ifndef REGISTER_MOVE_COST\n-#define REGISTER_MOVE_COST(x, y) 2\n+#define REGISTER_MOVE_COST(m, x, y) 2\n #endif\n \n static void init_reg_sets_1\tPARAMS ((void));\n@@ -177,17 +177,17 @@ enum machine_mode reg_raw_mode[FIRST_PSEUDO_REGISTER];\n /* Maximum cost of moving from a register in one class to a register in\n    another class.  Based on REGISTER_MOVE_COST.  */\n \n-static int move_cost[N_REG_CLASSES][N_REG_CLASSES];\n+static int move_cost[MAX_MACHINE_MODE][N_REG_CLASSES][N_REG_CLASSES];\n \n /* Similar, but here we don't have to move if the first index is a subset\n    of the second so in that case the cost is zero.  */\n \n-static int may_move_in_cost[N_REG_CLASSES][N_REG_CLASSES];\n+static int may_move_in_cost[MAX_MACHINE_MODE][N_REG_CLASSES][N_REG_CLASSES];\n \n /* Similar, but here we don't have to move if the first index is a superset\n    of the second so in that case the cost is zero.  */\n \n-static int may_move_out_cost[N_REG_CLASSES][N_REG_CLASSES];\n+static int may_move_out_cost[MAX_MACHINE_MODE][N_REG_CLASSES][N_REG_CLASSES];\n \n #ifdef FORBIDDEN_INC_DEC_CLASSES\n \n@@ -287,6 +287,7 @@ static void\n init_reg_sets_1 ()\n {\n   register unsigned int i, j;\n+  register unsigned int /* enum machine_mode */ m;\n \n   /* This macro allows the fixed or call-used registers\n      and the register classes to depend on target flags.  */\n@@ -426,39 +427,40 @@ init_reg_sets_1 ()\n   /* Initialize the move cost table.  Find every subset of each class\n      and take the maximum cost of moving any subset to any other.  */\n \n-  for (i = 0; i < N_REG_CLASSES; i++)\n-    for (j = 0; j < N_REG_CLASSES; j++)\n-      {\n-\tint cost = i == j ? 2 : REGISTER_MOVE_COST (i, j);\n-\tenum reg_class *p1, *p2;\n+  for (m = 0; m < MAX_MACHINE_MODE; m++)\n+    for (i = 0; i < N_REG_CLASSES; i++)\n+      for (j = 0; j < N_REG_CLASSES; j++)\n+\t{\n+\t  int cost = i == j ? 2 : REGISTER_MOVE_COST (m, i, j);\n+\t  enum reg_class *p1, *p2;\n \n-\tfor (p2 = &reg_class_subclasses[j][0]; *p2 != LIM_REG_CLASSES; p2++)\n-\t  if (*p2 != i)\n-\t    cost = MAX (cost, REGISTER_MOVE_COST (i, *p2));\n+\t  for (p2 = &reg_class_subclasses[j][0]; *p2 != LIM_REG_CLASSES; p2++)\n+\t    if (*p2 != i)\n+\t      cost = MAX (cost, REGISTER_MOVE_COST (m, i, *p2));\n \n-\tfor (p1 = &reg_class_subclasses[i][0]; *p1 != LIM_REG_CLASSES; p1++)\n-\t  {\n-\t    if (*p1 != j)\n-\t      cost = MAX (cost, REGISTER_MOVE_COST (*p1, j));\n+\t  for (p1 = &reg_class_subclasses[i][0]; *p1 != LIM_REG_CLASSES; p1++)\n+\t    {\n+\t      if (*p1 != j)\n+\t\tcost = MAX (cost, REGISTER_MOVE_COST (m, *p1, j));\n \n-\t    for (p2 = &reg_class_subclasses[j][0];\n-\t\t *p2 != LIM_REG_CLASSES; p2++)\n-\t      if (*p1 != *p2)\n-\t\tcost = MAX (cost, REGISTER_MOVE_COST (*p1, *p2));\n-\t  }\n+\t      for (p2 = &reg_class_subclasses[j][0];\n+\t\t   *p2 != LIM_REG_CLASSES; p2++)\n+\t\tif (*p1 != *p2)\n+\t\t  cost = MAX (cost, REGISTER_MOVE_COST (m, *p1, *p2));\n+\t    }\n \n-\tmove_cost[i][j] = cost;\n+\t  move_cost[m][i][j] = cost;\n \n-\tif (reg_class_subset_p (i, j))\n-\t  may_move_in_cost[i][j] = 0;\n-\telse\n-\t  may_move_in_cost[i][j] = cost;\n+\t  if (reg_class_subset_p (i, j))\n+\t    may_move_in_cost[m][i][j] = 0;\n+\t  else\n+\t    may_move_in_cost[m][i][j] = cost;\n \n-\tif (reg_class_subset_p (j, i))\n-\t  may_move_out_cost[i][j] = 0;\n-\telse\n-\t  may_move_out_cost[i][j] = cost;\n-      }\n+\t  if (reg_class_subset_p (j, i))\n+\t    may_move_out_cost[m][i][j] = 0;\n+\t  else\n+\t    may_move_out_cost[m][i][j] = cost;\n+\t}\n \n #ifdef CLASS_CANNOT_CHANGE_MODE\n   {\n@@ -564,9 +566,9 @@ memory_move_secondary_cost (mode, class, in)\n     return 0;\n \n   if (in)\n-    partial_cost = REGISTER_MOVE_COST (altclass, class);\n+    partial_cost = REGISTER_MOVE_COST (mode, altclass, class);\n   else\n-    partial_cost = REGISTER_MOVE_COST (class, altclass);\n+    partial_cost = REGISTER_MOVE_COST (mode, class, altclass);\n \n   if (class == altclass)\n     /* This isn't simply a copy-to-temporary situation.  Can't guess\n@@ -1403,10 +1405,10 @@ record_reg_classes (n_alts, n_ops, ops, modes,\n \t\t  for (class = 0; class < N_REG_CLASSES; class++)\n \t\t    pp->cost[class]\n \t\t      = ((recog_data.operand_type[i] != OP_OUT\n-\t\t\t  ? may_move_in_cost[class][(int) classes[i]]\n+\t\t\t  ? may_move_in_cost[mode][class][(int) classes[i]]\n \t\t\t  : 0)\n \t\t\t + (recog_data.operand_type[i] != OP_IN\n-\t\t\t    ? may_move_out_cost[(int) classes[i]][class]\n+\t\t\t    ? may_move_out_cost[mode][(int) classes[i]][class]\n \t\t\t    : 0));\n \t\t  \n \t\t  /* If the alternative actually allows memory, make things\n@@ -1428,7 +1430,8 @@ record_reg_classes (n_alts, n_ops, ops, modes,\n \n \t\t  if (reg_pref)\n \t\t    alt_cost\n-\t\t      += (may_move_in_cost[(unsigned char) reg_pref[REGNO (op)].prefclass]\n+\t\t      += (may_move_in_cost[mode]\n+\t\t\t  [(unsigned char) reg_pref[REGNO (op)].prefclass]\n \t\t\t  [(int) classes[i]]);\n \n \t\t  if (REGNO (ops[i]) != REGNO (ops[j])\n@@ -1615,10 +1618,10 @@ record_reg_classes (n_alts, n_ops, ops, modes,\n \t\t  for (class = 0; class < N_REG_CLASSES; class++)\n \t\t    pp->cost[class]\n \t\t      = ((recog_data.operand_type[i] != OP_OUT\n-\t\t\t  ? may_move_in_cost[class][(int) classes[i]]\n+\t\t\t  ? may_move_in_cost[mode][class][(int) classes[i]]\n \t\t\t  : 0)\n \t\t\t + (recog_data.operand_type[i] != OP_IN\n-\t\t\t    ? may_move_out_cost[(int) classes[i]][class]\n+\t\t\t    ? may_move_out_cost[mode][(int) classes[i]][class]\n \t\t\t    : 0));\n \n \t\t  /* If the alternative actually allows memory, make things\n@@ -1640,7 +1643,8 @@ record_reg_classes (n_alts, n_ops, ops, modes,\n \n \t\t  if (reg_pref)\n \t\t    alt_cost\n-\t\t      += (may_move_in_cost[(unsigned char) reg_pref[REGNO (op)].prefclass]\n+\t\t      += (may_move_in_cost[mode]\n+\t\t\t  [(unsigned char) reg_pref[REGNO (op)].prefclass]\n \t\t\t  [(int) classes[i]]);\n \t\t}\n \t    }\n@@ -1729,7 +1733,7 @@ record_reg_classes (n_alts, n_ops, ops, modes,\n \n \t      if ((reg_class_size[(unsigned char) pref]\n \t\t   == CLASS_MAX_NREGS (pref, mode))\n-\t\t  && REGISTER_MOVE_COST (pref, pref) < 10 * 2)\n+\t\t  && REGISTER_MOVE_COST (mode, pref, pref) < 10 * 2)\n \t\top_costs[i].cost[(unsigned char) pref] = -1;\n \t    }\n \t  else if (regno < FIRST_PSEUDO_REGISTER)\n@@ -1797,7 +1801,7 @@ copy_cost (x, mode, class, to_p)\n #endif\n \n   if (secondary_class != NO_REGS)\n-    return (move_cost[(int) secondary_class][(int) class]\n+    return (move_cost[mode][(int) secondary_class][(int) class]\n \t    + copy_cost (x, mode, secondary_class, 2));\n #endif  /* HAVE_SECONDARY_RELOADS */\n \n@@ -1809,7 +1813,7 @@ copy_cost (x, mode, class, to_p)\n     return MEMORY_MOVE_COST (mode, class, to_p);\n \n   else if (GET_CODE (x) == REG)\n-    return move_cost[(int) REGNO_REG_CLASS (REGNO (x))][(int) class];\n+    return move_cost[mode][(int) REGNO_REG_CLASS (REGNO (x))][(int) class];\n \n   else\n     /* If this is a constant, we may eventually want to call rtx_cost here.  */\n@@ -1986,7 +1990,7 @@ record_address_regs (x, class, scale)\n \tpp->mem_cost += (MEMORY_MOVE_COST (Pmode, class, 1) * scale) / 2;\n \n \tfor (i = 0; i < N_REG_CLASSES; i++)\n-\t  pp->cost[i] += (may_move_in_cost[i][(int) class] * scale) / 2;\n+\t  pp->cost[i] += (may_move_in_cost[Pmode][i][(int) class] * scale) / 2;\n       }\n       break;\n "}, {"sha": "7b9b669e09e028772d09e54509e239f26f8f60d8", "filename": "gcc/reload.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56b459443c4a8d7f46f33fae6b686d0ed645f2d/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56b459443c4a8d7f46f33fae6b686d0ed645f2d/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=e56b459443c4a8d7f46f33fae6b686d0ed645f2d", "patch": "@@ -1,6 +1,6 @@\n /* Search an insn for pseudo regs that must be in hard regs and are not.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000 Free Software Foundation, Inc.\n+   1999, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -104,7 +104,7 @@ a register with any other reload.  */\n #include \"toplev.h\"\n \n #ifndef REGISTER_MOVE_COST\n-#define REGISTER_MOVE_COST(x, y) 2\n+#define REGISTER_MOVE_COST(m, x, y) 2\n #endif\n \n #ifndef REGNO_MODE_OK_FOR_BASE_P\n@@ -2467,7 +2467,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n       && REGNO (SET_DEST (body)) < FIRST_PSEUDO_REGISTER\n       && GET_CODE (SET_SRC (body)) == REG\n       && REGNO (SET_SRC (body)) < FIRST_PSEUDO_REGISTER\n-      && REGISTER_MOVE_COST (REGNO_REG_CLASS (REGNO (SET_SRC (body))),\n+      && REGISTER_MOVE_COST (GET_MODE (SET_SRC (body)),\n+\t\t\t     REGNO_REG_CLASS (REGNO (SET_SRC (body))),\n \t\t\t     REGNO_REG_CLASS (REGNO (SET_DEST (body)))) == 2)\n     return 0;\n "}, {"sha": "3a3dab0e7d475562bf5a2793824066ec4c8e3530", "filename": "gcc/reload1.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56b459443c4a8d7f46f33fae6b686d0ed645f2d/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56b459443c4a8d7f46f33fae6b686d0ed645f2d/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=e56b459443c4a8d7f46f33fae6b686d0ed645f2d", "patch": "@@ -1,6 +1,6 @@\n /* Reload pseudo regs into hard regs for insns that require hard regs.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000 Free Software Foundation, Inc.\n+   1999, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -81,7 +81,7 @@ Boston, MA 02111-1307, USA.  */\n    into the reload registers.  */\n \n #ifndef REGISTER_MOVE_COST\n-#define REGISTER_MOVE_COST(x, y) 2\n+#define REGISTER_MOVE_COST(m, x, y) 2\n #endif\n \n #ifndef LOCAL_REGNO\n@@ -5396,7 +5396,7 @@ choose_reload_regs (chain)\n \t\t\t     register, we might use it for reload_override_in,\n \t\t\t     if copying it to the desired class is cheap\n \t\t\t     enough.  */\n-\t\t\t  || ((REGISTER_MOVE_COST (last_class, class)\n+\t\t\t  || ((REGISTER_MOVE_COST (mode, last_class, class)\n \t\t\t       < MEMORY_MOVE_COST (mode, class, 1))\n #ifdef SECONDARY_INPUT_RELOAD_CLASS\n \t\t\t      && (SECONDARY_INPUT_RELOAD_CLASS (class, mode,\n@@ -6113,7 +6113,7 @@ emit_input_reload_insns (chain, rl, old, j)\n \n       if (oldequiv != 0\n \t  && ((REGNO_REG_CLASS (regno) != rl->class\n-\t       && (REGISTER_MOVE_COST (REGNO_REG_CLASS (regno),\n+\t       && (REGISTER_MOVE_COST (mode, REGNO_REG_CLASS (regno),\n \t\t\t\t       rl->class)\n \t\t   >= MEMORY_MOVE_COST (mode, rl->class, 1)))\n #ifdef SECONDARY_INPUT_RELOAD_CLASS\n@@ -8106,7 +8106,8 @@ reload_cse_simplify_set (set, insn)\n   else if (CONSTANT_P (src))\n     old_cost = rtx_cost (src, SET);\n   else if (GET_CODE (src) == REG)\n-    old_cost = REGISTER_MOVE_COST (REGNO_REG_CLASS (REGNO (src)), dclass);\n+    old_cost = REGISTER_MOVE_COST (GET_MODE (src),\n+\t\t\t\t   REGNO_REG_CLASS (REGNO (src)), dclass);\n   else\n     /* ???   */\n     old_cost = rtx_cost (src, SET);\n@@ -8120,7 +8121,8 @@ reload_cse_simplify_set (set, insn)\n       if (CONSTANT_P (l->loc) && ! references_value_p (l->loc, 0))\n \tthis_cost = rtx_cost (l->loc, SET);\n       else if (GET_CODE (l->loc) == REG)\n-\tthis_cost = REGISTER_MOVE_COST (REGNO_REG_CLASS (REGNO (l->loc)),\n+\tthis_cost = REGISTER_MOVE_COST (GET_MODE (l->loc),\n+\t\t\t\t\tREGNO_REG_CLASS (REGNO (l->loc)),\n \t\t\t\t\tdclass);\n       else\n \tcontinue;"}, {"sha": "893835dc8d344239c14625b785cc8a7595d794d5", "filename": "gcc/tm.texi", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56b459443c4a8d7f46f33fae6b686d0ed645f2d/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56b459443c4a8d7f46f33fae6b686d0ed645f2d/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=e56b459443c4a8d7f46f33fae6b686d0ed645f2d", "patch": "@@ -1,4 +1,4 @@\n-@c Copyright (C) 1988,1989,1992,1993,1994,1995,1996,1997,1998,1999,2000\n+@c Copyright (C) 1988,1989,1992,1993,1994,1995,1996,1997,1998,1999,2000,2001\n @c Free Software Foundation, Inc.\n @c This is part of the GCC manual.\n @c For copying conditions, see the file gcc.texi.\n@@ -4869,11 +4869,12 @@ This macro will normally either not be defined or be defined as a\n constant.\n \n @findex REGISTER_MOVE_COST\n-@item REGISTER_MOVE_COST (@var{from}, @var{to})\n-A C expression for the cost of moving data from a register in class\n-@var{from} to one in class @var{to}.  The classes are expressed using\n-the enumeration values such as @code{GENERAL_REGS}.  A value of 2 is the\n-default; other values are interpreted relative to that.\n+@item REGISTER_MOVE_COST (@var{mode}, @var{from}, @var{to})\n+A C expression for the cost of moving data of mode @var{mode} from a\n+register in class @var{from} to one in class @var{to}.  The classes are\n+expressed using the enumeration values such as @code{GENERAL_REGS}.  A\n+value of 2 is the default; other values are interpreted relative to\n+that.\n \n It is not required that the cost always equal 2 when @var{from} is the\n same as @var{to}; on some machines it is expensive to move between"}]}