{"sha": "590245153a345410c79f16df7c58660ff91df05e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTkwMjQ1MTUzYTM0NTQxMGM3OWYxNmRmN2M1ODY2MGZmOTFkZjA1ZQ==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2011-09-23T17:02:10Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2011-09-23T17:02:10Z"}, "message": "re PR target/50447 ([avr] Better support of AND, OR, XOR and PLUS with constant integers for 16- and 32-bit values)\n\n\tPR target/50447\n\t* config/avr/avr.md: (adjust_len): Add alternative \"out_plus\".\n\t(addsi3): Rewrite using QI scratch register.  Adjust text\n\tpeepholes using plus:SI.\n\t(*addsi3_zero_extend.hi): New insn.\n\t(*subsi3_zero_extend.hi): New insn.\n\t(*subhi3_zero_extend1): Set attribute \"cc\" to \"set_czn\".\n\t(*subsi3_zero_extend): Ditto.\n\t(subsi3): Change predicate #2 to register_operand.\n\t* config/avr/avr-protos.h (avr_out_plus): New prototype.\n\t(avr_out_plus_1): New static function.\n\t(avr_out_plus): New function.\n\t(adjust_insn_length): Handle ADJUST_LEN_OUT_PLUS.\n\nFrom-SVN: r179123", "tree": {"sha": "47bbefd4d4c98a4a2fa91ba603f21b74d16907d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47bbefd4d4c98a4a2fa91ba603f21b74d16907d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/590245153a345410c79f16df7c58660ff91df05e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/590245153a345410c79f16df7c58660ff91df05e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/590245153a345410c79f16df7c58660ff91df05e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/590245153a345410c79f16df7c58660ff91df05e/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d45510814279358307e46c435716843819c6460b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d45510814279358307e46c435716843819c6460b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d45510814279358307e46c435716843819c6460b"}], "stats": {"total": 360, "additions": 280, "deletions": 80}, "files": [{"sha": "b631bf28c772de93ae683c500258da043017451b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/590245153a345410c79f16df7c58660ff91df05e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/590245153a345410c79f16df7c58660ff91df05e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=590245153a345410c79f16df7c58660ff91df05e", "patch": "@@ -1,3 +1,19 @@\n+2011-09-23  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/50447\n+\t* config/avr/avr.md: (adjust_len): Add alternative \"out_plus\".\n+\t(addsi3): Rewrite using QI scratch register.  Adjust text\n+\tpeepholes using plus:SI.\n+\t(*addsi3_zero_extend.hi): New insn.\n+\t(*subsi3_zero_extend.hi): New insn.\n+\t(*subhi3_zero_extend1): Set attribute \"cc\" to \"set_czn\".\n+\t(*subsi3_zero_extend): Ditto.\n+\t(subsi3): Change predicate #2 to register_operand.\n+\t* config/avr/avr-protos.h (avr_out_plus): New prototype.\n+\t(avr_out_plus_1): New static function.\n+\t(avr_out_plus): New function.\n+\t(adjust_insn_length): Handle ADJUST_LEN_OUT_PLUS.\n+\n 2011-09-23  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/i386/i386.c (ix86_prepare_sse_fp_compare_args): For"}, {"sha": "c6673e4664ddec422740beaa72d7a05d8e64716c", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/590245153a345410c79f16df7c58660ff91df05e/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/590245153a345410c79f16df7c58660ff91df05e/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=590245153a345410c79f16df7c58660ff91df05e", "patch": "@@ -82,6 +82,7 @@ extern void avr_output_bld (rtx operands[], int bit_nr);\n extern void avr_output_addr_vec_elt (FILE *stream, int value);\n extern const char *avr_out_sbxx_branch (rtx insn, rtx operands[]);\n extern const char* avr_out_bitop (rtx, rtx*, int*);\n+extern const char* avr_out_plus (rtx*, int*);\n extern bool avr_popcount_each_byte (rtx, int, int);\n \n extern int extra_constraint_Q (rtx x);"}, {"sha": "1682aa0ce96a5c8dc49b3b09bfd35c81b56c5a27", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/590245153a345410c79f16df7c58660ff91df05e/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/590245153a345410c79f16df7c58660ff91df05e/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=590245153a345410c79f16df7c58660ff91df05e", "patch": "@@ -4503,6 +4503,167 @@ lshrsi3_out (rtx insn, rtx operands[], int *len)\n }\n \n \n+/* Output addition of register XOP[0] and compile time constant XOP[2]:\n+\n+      XOP[0] = XOP[0] + XOP[2]\n+\n+   and return \"\".  If PLEN == NULL, print assembler instructions to perform the\n+   addition; otherwise, set *PLEN to the length of the instruction sequence (in\n+   words) printed with PLEN == NULL.  XOP[3] is an 8-bit scratch register.\n+   CODE == PLUS:  perform addition by using ADD instructions.\n+   CODE == MINUS: perform addition by using SUB instructions.  */\n+\n+static void\n+avr_out_plus_1 (rtx *xop, int *plen, enum rtx_code code)\n+{\n+  /* MODE of the operation.  */\n+  enum machine_mode mode = GET_MODE (xop[0]);\n+\n+  /* Number of bytes to operate on.  */\n+  int i, n_bytes = GET_MODE_SIZE (mode);\n+\n+  /* Value (0..0xff) held in clobber register op[3] or -1 if unknown.  */\n+  int clobber_val = -1;\n+\n+  /* op[0]: 8-bit destination register\n+     op[1]: 8-bit const int\n+     op[2]: 8-bit scratch register */\n+  rtx op[3];\n+\n+  /* Started the operation?  Before starting the operation we may skip\n+     adding 0.  This is no more true after the operation started because\n+     carry must be taken into account.  */\n+  bool started = false;\n+\n+  /* Value to add.  There are two ways to add VAL: R += VAL and R -= -VAL.  */\n+  rtx xval = xop[2];\n+\n+  if (MINUS == code)\n+    xval = gen_int_mode (-UINTVAL (xval), mode);\n+\n+  op[2] = xop[3];\n+\n+  if (plen)\n+    *plen = 0;\n+\n+  for (i = 0; i < n_bytes; i++)\n+    {\n+      /* We operate byte-wise on the destination.  */\n+      rtx reg8 = simplify_gen_subreg (QImode, xop[0], mode, i);\n+      rtx xval8 = simplify_gen_subreg (QImode, xval, mode, i);\n+\n+      /* 8-bit value to operate with this byte. */\n+      unsigned int val8 = UINTVAL (xval8) & GET_MODE_MASK (QImode);\n+\n+      /* Registers R16..R31 can operate with immediate.  */\n+      bool ld_reg_p = test_hard_reg_class (LD_REGS, reg8);\n+\n+      op[0] = reg8;\n+      op[1] = GEN_INT (val8);\n+      \n+      if (!started && i % 2 == 0\n+          && test_hard_reg_class (ADDW_REGS, reg8))\n+        {\n+          rtx xval16 = simplify_gen_subreg (HImode, xval, mode, i);\n+          unsigned int val16 = UINTVAL (xval16) & GET_MODE_MASK (HImode);\n+\n+          /* Registers R24, X, Y, Z can use ADIW/SBIW with constants < 64\n+             i.e. operate word-wise.  */\n+\n+          if (val16 < 64)\n+            {\n+              if (val16 != 0)\n+                {\n+                  started = true;\n+                  avr_asm_len (code == PLUS ? \"adiw %0,%1\" : \"sbiw %0,%1\",\n+                               op, plen, 1);\n+                }\n+\n+              i++;\n+              continue;\n+            }\n+        }\n+\n+      if (val8 == 0)\n+        {\n+          if (started)\n+            avr_asm_len (code == PLUS\n+                         ? \"adc %0,__zero_reg__\" : \"sbc %0,__zero_reg__\",\n+                         op, plen, 1);\n+          continue;\n+        }\n+\n+      switch (code)\n+        {\n+        case PLUS:\n+\n+          gcc_assert (plen != NULL || REG_P (op[2]));\n+\n+          if (clobber_val != (int) val8)\n+            avr_asm_len (\"ldi %2,%1\", op, plen, 1);\n+          clobber_val = (int) val8;\n+              \n+          avr_asm_len (started ? \"adc %0,%2\" : \"add %0,%2\", op, plen, 1);\n+\n+          break; /* PLUS */\n+\n+        case MINUS:\n+\n+          if (ld_reg_p)\n+            avr_asm_len (started ? \"sbci %0,%1\" : \"subi %0,%1\", op, plen, 1);\n+          else\n+            {\n+              gcc_assert (plen != NULL || REG_P (op[2]));\n+\n+              if (clobber_val != (int) val8)\n+                avr_asm_len (\"ldi %2,%1\", op, plen, 1);\n+              clobber_val = (int) val8;\n+              \n+              avr_asm_len (started ? \"sbc %0,%2\" : \"sub %0,%2\", op, plen, 1);\n+            }\n+\n+          break; /* MINUS */\n+          \n+        default:\n+          /* Unknown code */\n+          gcc_unreachable();\n+        }\n+\n+      started = true;\n+\n+    } /* for all sub-bytes */\n+}\n+\n+\n+/* Output addition of register XOP[0] and compile time constant XOP[2]:\n+\n+      XOP[0] = XOP[0] + XOP[2]\n+\n+   and return \"\".  If PLEN == NULL, print assembler instructions to perform the\n+   addition; otherwise, set *PLEN to the length of the instruction sequence (in\n+   words) printed with PLEN == NULL.  */\n+\n+const char*\n+avr_out_plus (rtx *xop, int *plen)\n+{\n+  int len_plus, len_minus;\n+\n+  /* Work out if  XOP[0] += XOP[2]  is better or  XOP[0] -= -XOP[2].  */\n+  \n+  avr_out_plus_1 (xop, &len_plus, PLUS);\n+  avr_out_plus_1 (xop, &len_minus, MINUS);\n+\n+  if (plen)\n+    *plen = (len_minus <= len_plus) ? len_minus : len_plus;\n+  else if (len_minus <= len_plus)\n+    avr_out_plus_1 (xop, NULL, MINUS);\n+  else\n+    avr_out_plus_1 (xop, NULL, PLUS);\n+\n+  return \"\";\n+}\n+\n+\n /* Output bit operation (IOR, AND, XOR) with register XOP[0] and compile\n    time constant XOP[2]:\n \n@@ -4851,6 +5012,10 @@ adjust_insn_length (rtx insn, int len)\n           avr_out_bitop (insn, op, &len);\n           break;\n \n+        case ADJUST_LEN_OUT_PLUS:\n+          avr_out_plus (op, &len);\n+          break;\n+\n         default:\n           gcc_unreachable();\n         }"}, {"sha": "8e78ca6856fe11c3fbfff335f5326ee073e4d3d9", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 98, "deletions": 80, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/590245153a345410c79f16df7c58660ff91df05e/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/590245153a345410c79f16df7c58660ff91df05e/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=590245153a345410c79f16df7c58660ff91df05e", "patch": "@@ -136,7 +136,7 @@\n ;; Otherwise do special processing depending on the attribute.\n \n (define_attr \"adjust_len\"\n-  \"yes,no,reload_in32,out_bitop\"\n+  \"yes,no,reload_in32,out_bitop,out_plus\"\n   (const_string \"yes\"))\n \n ;; Define mode iterators\n@@ -909,31 +909,46 @@\n    (set_attr \"cc\" \"set_n,set_czn,set_czn,set_czn,set_n,set_n\")])\n \n (define_insn \"addsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,!w,!w,d,r,r\")\n-\t  (plus:SI\n-\t   (match_operand:SI 1 \"register_operand\" \"%0,0,0,0,0,0\")\n-\t   (match_operand:SI 2 \"nonmemory_operand\" \"r,I,J,i,P,N\")))]\n+  [(set (match_operand:SI 0 \"register_operand\"          \"=r,!w,!w,d,l,l ,d,r\")\n+        (plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0 ,0 ,0,0,0 ,0,0\")\n+                 (match_operand:SI 2 \"nonmemory_operand\" \"r,I ,J ,s,P,N ,n,n\")))\n+   (clobber (match_scratch:QI 3                         \"=X,X ,X ,X,X,X ,X,&d\"))]\n   \"\"\n-  \"@\n-\tadd %A0,%A2\\;adc %B0,%B2\\;adc %C0,%C2\\;adc %D0,%D2\n-\tadiw %0,%2\\;adc %C0,__zero_reg__\\;adc %D0,__zero_reg__\n-\tsbiw %0,%n2\\;sbc %C0,__zero_reg__\\;sbc %D0,__zero_reg__\n-\tsubi %0,lo8(-(%2))\\;sbci %B0,hi8(-(%2))\\;sbci %C0,hlo8(-(%2))\\;sbci %D0,hhi8(-(%2))\n-\tsec\\;adc %A0,__zero_reg__\\;adc %B0,__zero_reg__\\;adc %C0,__zero_reg__\\;adc %D0,__zero_reg__\n-\tsec\\;sbc %A0,__zero_reg__\\;sbc %B0,__zero_reg__\\;sbc %C0,__zero_reg__\\;sbc %D0,__zero_reg__\"\n-  [(set_attr \"length\" \"4,3,3,4,5,5\")\n-   (set_attr \"cc\" \"set_n,set_n,set_czn,set_czn,set_n,set_n\")])\n+  {\n+    static const char * const asm_code[] =\n+      {\n+        \"add %A0,%A2\\;adc %B0,%B2\\;adc %C0,%C2\\;adc %D0,%D2\",\n+        \"adiw %0,%2\\;adc %C0,__zero_reg__\\;adc %D0,__zero_reg__\",\n+        \"sbiw %0,%n2\\;sbc %C0,__zero_reg__\\;sbc %D0,__zero_reg__\",\n+        \"subi %0,lo8(-(%2))\\;sbci %B0,hi8(-(%2))\\;sbci %C0,hlo8(-(%2))\\;sbci %D0,hhi8(-(%2))\",\n+        \"sec\\;adc %A0,__zero_reg__\\;adc %B0,__zero_reg__\\;adc %C0,__zero_reg__\\;adc %D0,__zero_reg__\",\n+        \"sec\\;sbc %A0,__zero_reg__\\;sbc %B0,__zero_reg__\\;sbc %C0,__zero_reg__\\;sbc %D0,__zero_reg__\"\n+      };\n+\n+    if (which_alternative >= (signed) (sizeof (asm_code) / sizeof (*asm_code)))\n+      return avr_out_plus (operands, NULL);\n+\n+    return asm_code [which_alternative];\n+  }\n+  [(set_attr \"length\" \"4,3,3,4,5,5,8,8\")\n+   (set_attr \"adjust_len\" \"no,no,no,no,no,no,out_plus,out_plus\")\n+   (set_attr \"cc\" \"set_n,set_n,set_czn,set_czn,set_n,set_n,clobber,clobber\")])\n \n (define_insn \"*addsi3_zero_extend\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (zero_extend:SI\n-\t\t  (match_operand:QI 1 \"register_operand\" \"r\"))\n-\t\t (match_operand:SI 2 \"register_operand\" \"0\")))]\n+  [(set (match_operand:SI 0 \"register_operand\"                         \"=r\")\n+        (plus:SI (zero_extend:SI (match_operand:QI 1 \"register_operand\" \"r\"))\n+                 (match_operand:SI 2 \"register_operand\"                 \"0\")))]\n   \"\"\n-  \"add %A0,%1\n-\tadc %B0,__zero_reg__\n-\tadc %C0,__zero_reg__\n-\tadc %D0,__zero_reg__\"\n+  \"add %A0,%1\\;adc %B0,__zero_reg__\\;adc %C0,__zero_reg__\\;adc %D0,__zero_reg__\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"set_n\")])\n+\n+(define_insn \"*addsi3_zero_extend.hi\"\n+  [(set (match_operand:SI 0 \"register_operand\"                         \"=r\")\n+        (plus:SI (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"r\"))\n+                 (match_operand:SI 2 \"register_operand\"                 \"0\")))]\n+  \"\"\n+  \"add %A0,%1\\;adc %B0,%B1\\;adc %C0,__zero_reg__\\;adc %D0,__zero_reg__\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"set_n\")])\n \n@@ -962,39 +977,40 @@\n    (set_attr \"cc\" \"set_czn,set_czn\")])\n \n (define_insn \"*subhi3_zero_extend1\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(minus:HI (match_operand:HI 1 \"register_operand\" \"0\")\n-\t\t  (zero_extend:HI\n-\t\t   (match_operand:QI 2 \"register_operand\" \"r\"))))]\n+  [(set (match_operand:HI 0 \"register_operand\"                          \"=r\")\n+        (minus:HI (match_operand:HI 1 \"register_operand\"                 \"0\")\n+                  (zero_extend:HI (match_operand:QI 2 \"register_operand\" \"r\"))))]\n   \"\"\n-  \"sub %A0,%2\n-\tsbc %B0,__zero_reg__\"\n+  \"sub %A0,%2\\;sbc %B0,__zero_reg__\"\n   [(set_attr \"length\" \"2\")\n-   (set_attr \"cc\" \"set_n\")])\n+   (set_attr \"cc\" \"set_czn\")])\n \n (define_insn \"subsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,d\")\n-        (minus:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n-                 (match_operand:SI 2 \"nonmemory_operand\" \"r,i\")))]\n+  [(set (match_operand:SI 0 \"register_operand\"          \"=r\")\n+        (minus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+                  (match_operand:SI 2 \"register_operand\" \"r\")))]\n   \"\"\n-  \"@\n-\tsub %0,%2\\;sbc %B0,%B2\\;sbc %C0,%C2\\;sbc %D0,%D2\n-\tsubi %A0,lo8(%2)\\;sbci %B0,hi8(%2)\\;sbci %C0,hlo8(%2)\\;sbci %D0,hhi8(%2)\"\n-  [(set_attr \"length\" \"4,4\")\n-   (set_attr \"cc\" \"set_czn,set_czn\")])\n+  \"sub %0,%2\\;sbc %B0,%B2\\;sbc %C0,%C2\\;sbc %D0,%D2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"set_czn\")])\n \n (define_insn \"*subsi3_zero_extend\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(minus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t  (zero_extend:SI\n-\t\t   (match_operand:QI 2 \"register_operand\" \"r\"))))]\n-  \"\"\n-  \"sub %A0,%2\n-\tsbc %B0,__zero_reg__\n-\tsbc %C0,__zero_reg__\n-\tsbc %D0,__zero_reg__\"\n+  [(set (match_operand:SI 0 \"register_operand\"                          \"=r\")\n+        (minus:SI (match_operand:SI 1 \"register_operand\"                 \"0\")\n+                  (zero_extend:SI (match_operand:QI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"sub %A0,%2\\;sbc %B0,__zero_reg__\\;sbc %C0,__zero_reg__\\;sbc %D0,__zero_reg__\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"set_n\")])\n+   (set_attr \"cc\" \"set_czn\")])\n+\n+(define_insn \"*subsi3_zero_extend.hi\"\n+  [(set (match_operand:SI 0 \"register_operand\"                          \"=r\")\n+        (minus:SI (match_operand:SI 1 \"register_operand\"                 \"0\")\n+                  (zero_extend:SI (match_operand:HI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"sub %A0,%2\\;sbc %B0,%B2\\;sbc %C0,__zero_reg__\\;sbc %D0,__zero_reg__\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"set_czn\")])\n \n ;******************************************************************************\n ; mul\n@@ -4093,42 +4109,44 @@\n ;; ************************* Peepholes ********************************\n \n (define_peephole\n-  [(set (match_operand:SI 0 \"d_register_operand\" \"\")\n-        (plus:SI (match_dup 0)\n-                 (const_int -1)))\n-   (parallel\n-    [(set (cc0)\n-          (compare (match_dup 0)\n-\t\t   (const_int -1)))\n-     (clobber (match_operand:QI 1 \"d_register_operand\" \"\"))])\n+  [(parallel [(set (match_operand:SI 0 \"d_register_operand\" \"\")\n+                   (plus:SI (match_dup 0)\n+                            (const_int -1)))\n+              (clobber (scratch:QI))])\n+   (parallel [(set (cc0)\n+                   (compare (match_dup 0)\n+                            (const_int -1)))\n+              (clobber (match_operand:QI 1 \"d_register_operand\" \"\"))])\n    (set (pc)\n-\t(if_then_else (ne (cc0) (const_int 0))\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))\n-\t\t      (pc)))]\n+        (if_then_else (ne (cc0)\n+                          (const_int 0))\n+                      (label_ref (match_operand 2 \"\" \"\"))\n+                      (pc)))]\n   \"\"\n-  \"*\n-{\n-  CC_STATUS_INIT;\n-  if (test_hard_reg_class (ADDW_REGS, operands[0]))\n-    output_asm_insn (AS2 (sbiw,%0,1) CR_TAB\n-\t\t     AS2 (sbc,%C0,__zero_reg__) CR_TAB\n-\t\t     AS2 (sbc,%D0,__zero_reg__) \\\"\\\\n\\\", operands);\n-  else\n-    output_asm_insn (AS2 (subi,%A0,1) CR_TAB\n-\t\t     AS2 (sbc,%B0,__zero_reg__) CR_TAB\n-\t\t     AS2 (sbc,%C0,__zero_reg__) CR_TAB\n-\t\t     AS2 (sbc,%D0,__zero_reg__) \\\"\\\\n\\\", operands);\n-  switch (avr_jump_mode (operands[2],insn))\n   {\n-    case 1:\n-      return AS1 (brcc,%2);\n-    case 2:\n-      return (AS1 (brcs,.+2) CR_TAB\n-              AS1 (rjmp,%2));\n-  }\n-  return (AS1 (brcs,.+4) CR_TAB\n-          AS1 (jmp,%2));\n-}\")\n+    CC_STATUS_INIT;\n+    if (test_hard_reg_class (ADDW_REGS, operands[0]))\n+      output_asm_insn (AS2 (sbiw,%0,1) CR_TAB\n+                       AS2 (sbc,%C0,__zero_reg__) CR_TAB\n+                       AS2 (sbc,%D0,__zero_reg__) \"\\n\", operands);\n+    else\n+      output_asm_insn (AS2 (subi,%A0,1) CR_TAB\n+                       AS2 (sbc,%B0,__zero_reg__) CR_TAB\n+                       AS2 (sbc,%C0,__zero_reg__) CR_TAB\n+                       AS2 (sbc,%D0,__zero_reg__) \"\\n\", operands);\n+\n+    switch (avr_jump_mode (operands[2], insn))\n+      {\n+      case 1:\n+        return AS1 (brcc,%2);\n+      case 2:\n+        return (AS1 (brcs,.+2) CR_TAB\n+                AS1 (rjmp,%2));\n+      }\n+\n+    return (AS1 (brcs,.+4) CR_TAB\n+            AS1 (jmp,%2));\n+  })\n \n (define_peephole\n   [(set (match_operand:HI 0 \"d_register_operand\" \"\")"}]}