{"sha": "cc378e655740e93743e7f43e14faaff707aef6c1", "node_id": "C_kwDOANBUbNoAKGNjMzc4ZTY1NTc0MGU5Mzc0M2U3ZjQzZTE0ZmFhZmY3MDdhZWY2YzE", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2022-06-17T15:19:44Z"}, "committer": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2022-06-17T15:20:41Z"}, "message": "alpha: Introduce target specific store_data_bypass_p function [PR105209]\n\nThis patch introduces alpha-specific version of store_data_bypass_p that\nignores TRAP_IF that would result in assertion failure (and internal\ncompiler error) in the generic store_data_bypass_p function.\n\nWhile at it, also remove ev4_ist_c reservation, store_data_bypass_p\ncan handle the patterns with multiple sets since some time ago.\n\n2022-06-17  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n\ngcc/ChangeLog:\n\n\tPR target/105209\n\t* config/alpha/alpha-protos.h (alpha_store_data_bypass_p): New.\n\t* config/alpha/alpha.cc (alpha_store_data_bypass_p): New function.\n\t(alpha_store_data_bypass_p_1): Ditto.\n\t* config/alpha/ev4.md: Use alpha_store_data_bypass_p instead\n\tof generic store_data_bypass_p.\n\t(ev4_ist_c): Remove insn reservation.\n\ngcc/testsuite/ChangeLog:\n\n\tPR target/105209\n\t* gcc.target/alpha/pr105209.c: New test.", "tree": {"sha": "ebc5a99a346a71fd13642ef74806936c6111c251", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ebc5a99a346a71fd13642ef74806936c6111c251"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc378e655740e93743e7f43e14faaff707aef6c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc378e655740e93743e7f43e14faaff707aef6c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc378e655740e93743e7f43e14faaff707aef6c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc378e655740e93743e7f43e14faaff707aef6c1/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f8278bfcfc7f7157bf2b405471e67dd5097636b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f8278bfcfc7f7157bf2b405471e67dd5097636b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f8278bfcfc7f7157bf2b405471e67dd5097636b"}], "stats": {"total": 112, "additions": 101, "deletions": 11}, "files": [{"sha": "adfdd774ef4cc37d09114bde98289c16296ebc99", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc378e655740e93743e7f43e14faaff707aef6c1/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc378e655740e93743e7f43e14faaff707aef6c1/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=cc378e655740e93743e7f43e14faaff707aef6c1", "patch": "@@ -73,6 +73,8 @@ extern void alpha_end_function (FILE *, const char *, tree);\n \n extern bool alpha_find_lo_sum_using_gp (rtx);\n \n+extern int alpha_store_data_bypass_p (rtx_insn *, rtx_insn *);\n+\n #ifdef REAL_VALUE_TYPE\n extern int check_float_value (machine_mode, REAL_VALUE_TYPE *, int);\n #endif"}, {"sha": "0a85e66fa894a47bd131e635169fa5e3bcade20c", "filename": "gcc/config/alpha/alpha.cc", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc378e655740e93743e7f43e14faaff707aef6c1/gcc%2Fconfig%2Falpha%2Falpha.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc378e655740e93743e7f43e14faaff707aef6c1/gcc%2Fconfig%2Falpha%2Falpha.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.cc?ref=cc378e655740e93743e7f43e14faaff707aef6c1", "patch": "@@ -7564,6 +7564,75 @@ alpha_does_function_need_gp (void)\n   return 0;\n }\n \n+/* Helper function for alpha_store_data_bypass_p, handle just a single SET\n+   IN_SET.  */\n+\n+static bool\n+alpha_store_data_bypass_p_1 (rtx_insn *out_insn, rtx in_set)\n+{\n+  if (!MEM_P (SET_DEST (in_set)))\n+    return false;\n+\n+  rtx out_set = single_set (out_insn);\n+  if (out_set)\n+    return !reg_mentioned_p (SET_DEST (out_set), SET_DEST (in_set));\n+\n+  rtx out_pat = PATTERN (out_insn);\n+  if (GET_CODE (out_pat) != PARALLEL)\n+    return false;\n+\n+  for (int i = 0; i < XVECLEN (out_pat, 0); i++)\n+    {\n+      rtx out_exp = XVECEXP (out_pat, 0, i);\n+\n+      if (GET_CODE (out_exp) == CLOBBER || GET_CODE (out_exp) == USE\n+\t  || GET_CODE (out_exp) == TRAP_IF)\n+\tcontinue;\n+\n+      gcc_assert (GET_CODE (out_exp) == SET);\n+\n+      if (reg_mentioned_p (SET_DEST (out_exp), SET_DEST (in_set)))\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+/* True if the dependency between OUT_INSN and IN_INSN is on the store\n+   data not the address operand(s) of the store.  IN_INSN and OUT_INSN\n+   must be either a single_set or a PARALLEL with SETs inside.\n+\n+   This alpha-specific version of store_data_bypass_p ignores TRAP_IF\n+   that would result in assertion failure (and internal compiler error)\n+   in the generic store_data_bypass_p function.  */\n+\n+int\n+alpha_store_data_bypass_p (rtx_insn *out_insn, rtx_insn *in_insn)\n+{\n+  rtx in_set = single_set (in_insn);\n+  if (in_set)\n+    return alpha_store_data_bypass_p_1 (out_insn, in_set);\n+\n+  rtx in_pat = PATTERN (in_insn);\n+  if (GET_CODE (in_pat) != PARALLEL)\n+    return false;\n+\n+  for (int i = 0; i < XVECLEN (in_pat, 0); i++)\n+    {\n+      rtx in_exp = XVECEXP (in_pat, 0, i);\n+\n+      if (GET_CODE (in_exp) == CLOBBER || GET_CODE (in_exp) == USE\n+\t  || GET_CODE (in_exp) == TRAP_IF)\n+\tcontinue;\n+\n+      gcc_assert (GET_CODE (in_exp) == SET);\n+\n+      if (!alpha_store_data_bypass_p_1 (out_insn, in_exp))\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n \f\n /* Helper function to set RTX_FRAME_RELATED_P on instructions, including\n    sequences.  */"}, {"sha": "c8ff4ed8f0df23c9f1b26fd044fbd3c3ec2c9b6b", "filename": "gcc/config/alpha/ev4.md", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc378e655740e93743e7f43e14faaff707aef6c1/gcc%2Fconfig%2Falpha%2Fev4.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc378e655740e93743e7f43e14faaff707aef6c1/gcc%2Fconfig%2Falpha%2Fev4.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fev4.md?ref=cc378e655740e93743e7f43e14faaff707aef6c1", "patch": "@@ -44,14 +44,7 @@\n ; Stores can issue before the data (but not address) is ready.\n (define_insn_reservation \"ev4_ist\" 1\n   (and (eq_attr \"tune\" \"ev4\")\n-       (eq_attr \"type\" \"ist\"))\n-  \"ev4_ib1+ev4_abox\")\n-\n-; ??? Separate from ev4_ist because store_data_bypass_p can't handle\n-; the patterns with multiple sets, like store-conditional.\n-(define_insn_reservation \"ev4_ist_c\" 1\n-  (and (eq_attr \"tune\" \"ev4\")\n-       (eq_attr \"type\" \"st_c\"))\n+       (eq_attr \"type\" \"ist,st_c\"))\n   \"ev4_ib1+ev4_abox\")\n \n (define_insn_reservation \"ev4_fst\" 1\n@@ -110,7 +103,7 @@\n (define_bypass 0\n   \"ev4_iaddlog,ev4_shiftcm,ev4_icmp\"\n   \"ev4_ist\"\n-  \"store_data_bypass_p\")\n+  \"alpha_store_data_bypass_p\")\n \n ; Multiplies use a non-pipelined imul unit.  Also, \"no [ebox] insn can\n ; be issued exactly three cycles before an integer multiply completes\".\n@@ -121,15 +114,15 @@\n \t    (eq_attr \"opsize\" \"si\")))\n   \"ev4_ib0+ev4_imul,ev4_imul*18,ev4_ebox\")\n \n-(define_bypass 20 \"ev4_imulsi\" \"ev4_ist\" \"store_data_bypass_p\")\n+(define_bypass 20 \"ev4_imulsi\" \"ev4_ist\" \"alpha_store_data_bypass_p\")\n \n (define_insn_reservation \"ev4_imuldi\" 23\n   (and (eq_attr \"tune\" \"ev4\")\n        (and (eq_attr \"type\" \"imul\")\n \t    (eq_attr \"opsize\" \"!si\")))\n   \"ev4_ib0+ev4_imul,ev4_imul*20,ev4_ebox\")\n \n-(define_bypass 22 \"ev4_imuldi\" \"ev4_ist\" \"store_data_bypass_p\")\n+(define_bypass 22 \"ev4_imuldi\" \"ev4_ist\" \"alpha_store_data_bypass_p\")\n \n ; Most FP insns have a 6 cycle latency, but with a 4 cycle bypass back in.\n (define_insn_reservation \"ev4_fpop\" 6"}, {"sha": "b89be96dc1d0cab731c0110c3fda109b990e8316", "filename": "gcc/testsuite/gcc.target/alpha/pr105209.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc378e655740e93743e7f43e14faaff707aef6c1/gcc%2Ftestsuite%2Fgcc.target%2Falpha%2Fpr105209.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc378e655740e93743e7f43e14faaff707aef6c1/gcc%2Ftestsuite%2Fgcc.target%2Falpha%2Fpr105209.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Falpha%2Fpr105209.c?ref=cc378e655740e93743e7f43e14faaff707aef6c1", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftrapv -mcpu=ev4\" } */\n+\n+typedef struct tnode_t {\n+        struct tnode_t *tn_left, *tn_right;\n+        int v_quad;\n+} tnode_t;\n+\n+int constant_addr(const tnode_t *, long *);\n+int constant_addr(const tnode_t *tn, long *offsp)\n+{\n+        long offs1 = 0, offs2 = 0;\n+\n+        if (tn->v_quad > 0) {\n+                offs1 = tn->v_quad;\n+                return 0;\n+        } else if (tn->v_quad > -1) {\n+                offs2 = tn->tn_right->v_quad;\n+                if (!constant_addr(tn->tn_left, &offs1))\n+                        return 0;\n+        } else {\n+                return 0;\n+        }\n+        *offsp = offs1 + offs2;\n+        return 1;\n+}"}]}