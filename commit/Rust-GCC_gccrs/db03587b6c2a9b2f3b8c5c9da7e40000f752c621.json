{"sha": "db03587b6c2a9b2f3b8c5c9da7e40000f752c621", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGIwMzU4N2I2YzJhOWIyZjNiOGM1YzlkYTdlNDAwMDBmNzUyYzYyMQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2006-04-23T11:44:40Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2006-04-23T11:44:40Z"}, "message": "lwg-active.html, [...]: Import Revision 42.\n\n2006-04-23  Paolo Carlini  <pcarlini@suse.de>\n\n\t* docs/html/ext/lwg-active.html, lwg-defects.html: Import Revision 42.\n\nFrom-SVN: r113193", "tree": {"sha": "b338f6ea489444e20c8052defb76f96111ca1de6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b338f6ea489444e20c8052defb76f96111ca1de6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db03587b6c2a9b2f3b8c5c9da7e40000f752c621", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db03587b6c2a9b2f3b8c5c9da7e40000f752c621", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db03587b6c2a9b2f3b8c5c9da7e40000f752c621", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db03587b6c2a9b2f3b8c5c9da7e40000f752c621/comments", "author": null, "committer": null, "parents": [{"sha": "1464eeb8be87335d2ed335437d029fa6d436b997", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1464eeb8be87335d2ed335437d029fa6d436b997", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1464eeb8be87335d2ed335437d029fa6d436b997"}], "stats": {"total": 2488, "additions": 1296, "deletions": 1192}, "files": [{"sha": "a9ed643112cae29ae1063c2ce4b7eceed6ff1a5c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db03587b6c2a9b2f3b8c5c9da7e40000f752c621/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db03587b6c2a9b2f3b8c5c9da7e40000f752c621/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=db03587b6c2a9b2f3b8c5c9da7e40000f752c621", "patch": "@@ -1,3 +1,7 @@\n+2006-04-23  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* docs/html/ext/lwg-active.html, lwg-defects.html: Import Revision 42.\n+\n 2006-04-19  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR libstdc++/26424"}, {"sha": "3e279f4d93dfa0c892cdf0ba63cf137dafd43cbf", "filename": "libstdc++-v3/docs/html/ext/lwg-active.html", "status": "modified", "additions": 456, "deletions": 1182, "changes": 1638, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db03587b6c2a9b2f3b8c5c9da7e40000f752c621/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Flwg-active.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db03587b6c2a9b2f3b8c5c9da7e40000f752c621/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Flwg-active.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Flwg-active.html?ref=db03587b6c2a9b2f3b8c5c9da7e40000f752c621"}, {"sha": "1907a4a85020904ca52c4fd1e10caeae25a0954f", "filename": "libstdc++-v3/docs/html/ext/lwg-defects.html", "status": "modified", "additions": 836, "deletions": 10, "changes": 846, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db03587b6c2a9b2f3b8c5c9da7e40000f752c621/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Flwg-defects.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db03587b6c2a9b2f3b8c5c9da7e40000f752c621/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Flwg-defects.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Flwg-defects.html?ref=db03587b6c2a9b2f3b8c5c9da7e40000f752c621", "patch": "@@ -8,11 +8,11 @@\n <table>\n <tbody><tr>\n <td align=\"left\">Doc. no.</td>\n-<td align=\"left\">N1950=06-0020</td>\n+<td align=\"left\">N2001=06-0071</td>\n </tr>\n <tr>\n <td align=\"left\">Date:</td>\n-<td align=\"left\">2006-02-24</td>\n+<td align=\"left\">2006-04-21</td>\n </tr>\n <tr>\n <td align=\"left\">Project:</td>\n@@ -23,7 +23,7 @@\n <td align=\"left\">Howard Hinnant &lt;howard.hinnant@gmail.com&gt;</td>\n </tr>\n </tbody></table>\n-<h1>C++ Standard Library Defect Report List (Revision R41)</h1>\n+<h1>C++ Standard Library Defect Report List (Revision R42)</h1>\n   <p>Reference ISO/IEC IS 14882:1998(E)</p>\n   <p>Also see:</p>\n     <ul>\n@@ -45,6 +45,15 @@ <h1>C++ Standard Library Defect Report List (Revision R41)</h1>\n   document.</p>\n <h2>Revision History</h2>\n <ul>\n+<li>R42: \n+2006-04-21 post-Berlin mailing.\n+Added new issues <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#567\">567</a>-<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#572\">572</a>.\n+Moved issues <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#499\">499</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#501\">501</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#506\">506</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#509\">509</a>-<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#511\">511</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#513\">513</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#514\">514</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#517\">517</a> to NAD.\n+Moved issues <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#502\">502</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#503\">503</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#515\">515</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#516\">516</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#522\">522</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#525\">525</a>-<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#529\">529</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#532\">532</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#536\">536</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#539\">539</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#548\">548</a> to Open.\n+Moved issue <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#504\">504</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#512\">512</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#521\">521</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#530\">530</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#531\">531</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#535\">535</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#537\">537</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#538\">538</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#540\">540</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#549\">549</a> to Ready.\n+Moved issues <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#247\">247</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#294\">294</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#362\">362</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#369\">369</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#371\">371</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#376\">376</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#384\">384</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#475\">475</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#478\">478</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#495\">495</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#497\">497</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#505\">505</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#507\">507</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#508\">508</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#519\">519</a> to WP.\n+Moved issue <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#534\">534</a> to Review.\n+</li>\n <li>R41: \n 2006-02-24 pre-Berlin mailing.\n Added new issues <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#536\">536</a>-<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#566\">566</a>.\n@@ -59,9 +68,9 @@ <h2>Revision History</h2>\n 2005-10-14 post-Mont Tremblant mailing.\n Added new issues <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#526\">526</a>-<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#528\">528</a>.\n Moved issues <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#280\">280</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#461\">461</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#464\">464</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#465\">465</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#467\">467</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#468\">468</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#474\">474</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#496\">496</a> from Ready to WP as per the vote from Mont Tremblant.\n-Moved issues <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#247\">247</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#294\">294</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#342\">342</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#362\">362</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#369\">369</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#371\">371</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#376\">376</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#384\">384</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#475\">475</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#478\">478</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#495\">495</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#497\">497</a> from Review to Ready.\n-Moved issues <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#498\">498</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#504\">504</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#506\">506</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#509\">509</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#510\">510</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#511\">511</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#512\">512</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#513\">513</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#514\">514</a> from New to Open.\n-Moved issues <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#505\">505</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#507\">507</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#508\">508</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#519\">519</a> from New to Ready.\n+Moved issues <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#247\">247</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#294\">294</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#342\">342</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#362\">362</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#369\">369</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#371\">371</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#376\">376</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#384\">384</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#475\">475</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#478\">478</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#495\">495</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#497\">497</a> from Review to Ready.\n+Moved issues <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#498\">498</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#504\">504</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#506\">506</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#509\">509</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#510\">510</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#511\">511</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#512\">512</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#513\">513</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#514\">514</a> from New to Open.\n+Moved issues <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#505\">505</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#507\">507</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#508\">508</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#519\">519</a> from New to Ready.\n Moved issue <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#500\">500</a> from New to NAD.\n Moved issue <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#518\">518</a> from New to Review.\n </li>\n@@ -96,7 +105,7 @@ <h2>Revision History</h2>\n <li>R31: \n 2004-07 mid-term mailing: reflects new proposed resolutions and\n new issues received after the post-Sydney mailing.  Added\n-new issues <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#463\">463</a>-<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#478\">478</a>.\n+new issues <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#463\">463</a>-<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#478\">478</a>.\n </li>\n <li>R30: \n Post-Sydney mailing: reflects decisions made at the Sydney meeting.\n@@ -133,7 +142,7 @@ <h2>Revision History</h2>\n Moved issues in the TC to TC status.\n </li>\n <li>R22: \n-Post-Cura\ufffdao mailing.  Added new issues <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#362\">362</a>-<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#366\">366</a>.\n+Post-Cura\ufffdao mailing.  Added new issues <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#362\">362</a>-<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#366\">366</a>.\n </li>\n <li>R21: \n Pre-Cura\ufffdao mailing.  Added new issues <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#351\">351</a>-<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#361\">361</a>.\n@@ -5367,7 +5376,7 @@ <h2>Defect Reports</h2>\n <p><i>[Kona: The LWG agreed there was a defect.]</i></p>\n <p><i>[Tokyo: The LWG crafted the proposed resolution.]</i></p>\n <hr>\n-<a name=\"186\"><h3>186.&nbsp;bitset::set() second parameter should be bool</h3></a><p><b>Section:</b>&nbsp;23.3.5.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-containers.html#lib.bitset.members\"> [lib.bitset.members]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;Darin Adler&nbsp; <b>Date:</b>&nbsp;13 Aug 1999</p>\n+<a name=\"186\"></a><h3><a name=\"186\">186.&nbsp;bitset::set() second parameter should be bool</a></h3><p><b>Section:</b>&nbsp;23.3.5.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-containers.html#lib.bitset.members\"> [lib.bitset.members]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;Darin Adler&nbsp; <b>Date:</b>&nbsp;13 Aug 1999</p>\n <p>In section 23.3.5.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-containers.html#lib.bitset.members\"> [lib.bitset.members]</a>, paragraph 13 defines the\n bitset::set operation to take a second parameter of type int. The\n function tests whether this value is non-zero to determine whether to\n@@ -7267,6 +7276,69 @@ <h2>Defect Reports</h2>\n were moved to a place where their context made them less clear.  See\n Jerry Schwarz's message c++std-lib-7618.</p>\n <hr>\n+<a name=\"247\"><h3>247.&nbsp;<tt>vector</tt>, <tt>deque::insert</tt> complexity</h3></a><p><b>Section:</b>&nbsp;23.2.4.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-containers.html#lib.vector.modifiers\"> [lib.vector.modifiers]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;Lisa Lippincott&nbsp; <b>Date:</b>&nbsp;06 June 2000</p>\n+<p>Paragraph 2 of 23.2.4.3 [lib.vector.modifiers] describes the complexity\n+of <tt>vector::insert</tt>:</p>\n+\n+   <blockquote>\n+   Complexity: If first and last are forward iterators, bidirectional\n+   iterators, or random access iterators, the complexity is linear in\n+   the number of elements in the range [first, last) plus the distance\n+   to the end of the vector. If they are input iterators, the complexity\n+   is proportional to the number of elements in the range [first, last)\n+   times the distance to the end of the vector.\n+   </blockquote>\n+\n+<p>First, this fails to address the non-iterator forms of\n+<tt>insert</tt>.</p>\n+\n+<p>Second, the complexity for input iterators misses an edge case --\n+it requires that an arbitrary number of elements can be added at\n+the end of a <tt>vector</tt> in constant time.</p>\n+\n+<p>I looked to see if <tt>deque</tt> had a similar problem, and was\n+surprised to find that <tt>deque</tt> places no requirement on the\n+complexity of inserting multiple elements (23.2.1.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-containers.html#lib.deque.modifiers\"> [lib.deque.modifiers]</a>,\n+paragraph 3):</p>\n+\n+   <blockquote>\n+   Complexity: In the worst case, inserting a single element into a\n+   deque takes time linear in the minimum of the distance from the\n+   insertion point to the beginning of the deque and the distance\n+   from the insertion point to the end of the deque. Inserting a\n+   single element either at the beginning or end of a deque always\n+   takes constant time and causes a single call to the copy constructor\n+   of T.\n+   </blockquote>\n+<p><b>Proposed resolution:</b></p>\n+\n+<p>Change Paragraph 2 of 23.2.4.3 [lib.vector.modifiers] to</p>\n+   <blockquote>\n+   Complexity: The complexity is linear in the number of elements \n+   inserted plus the distance to the end of the vector.\n+   </blockquote>\n+\n+   <p><i>[For input iterators, one may achieve this complexity by first\n+   inserting at the end of the <tt>vector</tt>, and then using\n+   <tt>rotate</tt>.]</i></p>\n+\n+<p>Change 23.2.1.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-containers.html#lib.deque.modifiers\"> [lib.deque.modifiers]</a>, paragraph 3, to:</p>\n+\n+   <blockquote>\n+   Complexity: The complexity is linear in the number of elements \n+   inserted plus the shorter of the distances to the beginning and\n+   end of the deque.  Inserting a single element at either the\n+   beginning or the end of a deque causes a single call to the copy\n+   constructor of T.\n+   </blockquote>\n+\n+<p><b>Rationale:</b></p>\n+<p>This is a real defect, and proposed resolution fixes it: some\n+  complexities aren't specified that should be.  This proposed\n+  resolution does constrain deque implementations (it rules out the\n+  most naive possible implementations), but the LWG doesn't see a\n+  reason to permit that implementation.</p>\n+<hr>\n <a name=\"248\"><h3>248.&nbsp;time_get fails to set eofbit</h3></a><p><b>Section:</b>&nbsp;22.2.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-locales.html#lib.category.time\"> [lib.category.time]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;22 June 2000</p>\n <p>There is no requirement that any of time_get member functions set\n ios::eofbit when they reach the end iterator while parsing their input.\n@@ -8936,6 +9008,54 @@ <h2>Defect Reports</h2>\n assigns to the member objects of <tt>*this</tt> the corresponding member\n objects of <tt>rhs</tt>, except that...\n </blockquote>\n+<hr>\n+<a name=\"294\"><h3>294.&nbsp;User defined macros and standard headers</h3></a><p><b>Section:</b>&nbsp;17.4.3.1.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-intro.html#lib.macro.names\"> [lib.macro.names]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;James Kanze&nbsp; <b>Date:</b>&nbsp;11 Jan 2001</p>\n+<p>Paragraph 2 of 17.4.3.1.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-intro.html#lib.macro.names\"> [lib.macro.names]</a> reads: \"A\n+translation unit that includes a header shall not contain any macros\n+that define names declared in that header.\" As I read this, it\n+would mean that the following program is legal:</p>\n+\n+<pre>  #define npos 3.14\n+  #include &lt;sstream&gt;\n+</pre>\n+\n+<p>since npos is not defined in &lt;sstream&gt;.  It is, however, defined\n+in &lt;string&gt;, and it is hard to imagine an implementation in\n+which &lt;sstream&gt; didn't include &lt;string&gt;.</p>\n+\n+<p>I think that this phrase was probably formulated before it was\n+decided that a standard header may freely include other standard\n+headers.  The phrase would be perfectly appropriate for C, for\n+example.  In light of 17.4.4.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-intro.html#lib.res.on.headers\"> [lib.res.on.headers]</a> paragraph 1, however,\n+it isn't stringent enough.</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>For 17.4.3.1.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-intro.html#lib.macro.names\"> [lib.macro.names]</a>, replace the current wording, which reads:</p>\n+<blockquote>\n+     <p>Each name defined as a macro in a header is reserved to the\n+     implementation for any use if the translation unit includes\n+     the header.168)</p>\n+\n+     <p>A translation unit that includes a header shall not contain any\n+     macros that define names declared or defined in that header. Nor shall\n+     such a translation unit define macros for names lexically\n+     identical to keywords.</p>\n+\n+     <p>168) It is not permissible to remove a library macro definition by\n+     using the #undef directive.</p>\n+</blockquote>\n+\n+<p>with the wording:</p>\n+\n+<blockquote>\n+     <p>A translation unit that includes a standard library header shall not\n+     #define or #undef names declared in any standard library header.</p>\n+\n+     <p>A translation unit shall not #define or #undef names lexically\n+     identical to keywords.</p>\n+</blockquote>\n+\n+<p><i>[Lillehammer: Beman provided new wording]</i></p>\n+\n <hr>\n <a name=\"295\"><h3>295.&nbsp;Is abs defined in &lt;cmath&gt;?</h3></a><p><b>Section:</b>&nbsp;26.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-numerics.html#lib.c.math\"> [lib.c.math]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;Jens Maurer&nbsp; <b>Date:</b>&nbsp;12 Jan 2001</p>\n <p>\n@@ -11330,6 +11450,54 @@ <h2>Defect Reports</h2>\n <p>This change is reasonable becuase it clarifies the intent of this\n   part of the standard.</p>\n <hr>\n+<a name=\"362\"><h3>362.&nbsp;bind1st/bind2nd type safety</h3></a><p><b>Section:</b>&nbsp;20.3.6.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-utilities.html#lib.bind.1st\"> [lib.bind.1st]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;Andrew Demkin&nbsp; <b>Date:</b>&nbsp;26 Apr 2002</p>\n+<p>\n+The definition of bind1st() (20.3.6.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-utilities.html#lib.bind.1st\"> [lib.bind.1st]</a>) can result in\n+the construction of an unsafe binding between incompatible pointer\n+types. For example, given a function whose first parameter type is\n+'pointer to T', it's possible without error to bind an argument of\n+type 'pointer to U' when U does not derive from T:\n+</p>\n+<pre>   foo(T*, int);\n+\n+   struct T {};\n+   struct U {};\n+\n+   U u;\n+\n+   int* p;\n+   int* q;\n+\n+   for_each(p, q, bind1st(ptr_fun(foo), &amp;u));    // unsafe binding\n+</pre>\n+\n+<p>\n+The definition of bind1st() includes a functional-style conversion to\n+map its argument to the expected argument type of the bound function\n+(see below):\n+</p>\n+<pre>  typename Operation::first_argument_type(x)\n+</pre>\n+\n+<p>\n+A functional-style conversion (5.2.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/expr.html#expr.type.conv\"> [expr.type.conv]</a>) is defined to be\n+semantically equivalent to an explicit cast expression (5.4 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/expr.html#expr.cast\"> [expr.cast]</a>), which may (according to 5.4, paragraph 5) be interpreted\n+as a reinterpret_cast, thus masking the error.\n+</p>\n+\n+<p>The problem and proposed change also apply to 20.3.6.4 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-utilities.html#lib.bind.2nd\"> [lib.bind.2nd]</a>.</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>Add this sentence to the end of 20.3.6 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-utilities.html#lib.binders\"> [lib.binders]</a>/1:\n+  \"Binders <tt>bind1st</tt> and <tt>bind2nd</tt> are deprecated in\n+  favor of <tt>std::tr1::bind</tt>.\"</p>\n+\n+<p>(Notes to editor: (1) when and if tr1::bind is incorporated into\n+  the standard, \"std::tr1::bind\" should be changed to \"std::bind\". (2)\n+  20.3.6 should probably be moved to Annex D.</p>\n+<p><b>Rationale:</b></p>\n+<p>There is no point in fixing bind1st and bind2nd.  tr1::bind is a\n+  superior solution.  It solves this problem and others.</p>\n+<hr>\n <a name=\"363\"><h3>363.&nbsp;Missing exception specification in 27.4.2.1.1</h3></a><p><b>Section:</b>&nbsp;27.4.2.1.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.ios::failure\"> [lib.ios::failure]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;Walter Brown and Marc Paterno&nbsp; <b>Date:</b>&nbsp;20 May 2002</p>\n <p>\n The destructor of ios_base::failure should have an empty throw\n@@ -11413,6 +11581,102 @@ <h2>Defect Reports</h2>\n <p>Note that implementers can make this change in a binary compatible\n way by providing both overloads; this would be a conforming extension.</p>\n \n+<hr>\n+<a name=\"369\"><h3>369.&nbsp;io stream objects and static ctors</h3></a><p><b>Section:</b>&nbsp;27.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.iostream.objects\"> [lib.iostream.objects]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;Ruslan Abdikeev&nbsp; <b>Date:</b>&nbsp;8 Jul 2002</p>\n+<p>\n+Is it safe to use standard iostream objects from constructors of\n+static objects?  Are standard iostream objects constructed and are\n+their associations established at that time?\n+</p>\n+\n+<p>Surpisingly enough, Standard does NOT require that.</p>\n+\n+<p>\n+27.3/2 [lib.iostream.objects] guarantees that standard iostream\n+objects are constructed and their associations are established before\n+the body of main() begins execution.  It also refers to ios_base::Init\n+class as the panacea for constructors of static objects.\n+</p>\n+\n+<p>\n+However, there's nothing in 27.3 [lib.iostream.objects],\n+in 27.4.2 [lib.ios.base], and in 27.4.2.1.6 [lib.ios::Init],\n+that would require implementations to allow access to standard\n+iostream objects from constructors of static objects.\n+</p>\n+\n+<p>Details:</p>\n+\n+<p>Core text refers to some magic object ios_base::Init, which will\n+be discussed below:</p>\n+\n+<blockquote>\n+    \"The [standard iostream] objects are constructed, and their\n+    associations are established at some time prior to or during\n+    first time an object of class basic_ios&lt;charT,traits&gt;::Init\n+    is constructed, and in any case before the body of main\n+    begins execution.\" (27.3/2 [lib.iostream.objects])\n+</blockquote>\n+\n+<p>\n+The first <i>non-normative</i> footnote encourages implementations\n+to initialize standard iostream objects earlier than required.\n+</p>\n+\n+<p>However, the second <i>non-normative</i> footnote makes an explicit\n+and unsupported claim:</p>\n+\n+<blockquote>\n+  \"Constructors and destructors for static objects can access these\n+  [standard iostream] objects to read input from stdin or write output\n+  to stdout or stderr.\" (27.3/2 footnote 265 [lib.iostream.objects])\n+</blockquote>\n+\n+<p>\n+The only bit of magic is related to that ios_base::Init class.  AFAIK,\n+the rationale behind ios_base::Init was to bring an instance of this\n+class to each translation unit which #included &lt;iostream&gt; or\n+related header.  Such an inclusion would support the claim of footnote\n+quoted above, because in order to use some standard iostream object it\n+is necessary to #include &lt;iostream&gt;.\n+</p>\n+\n+<p>\n+However, while Standard explicitly describes ios_base::Init as\n+an appropriate class for doing the trick, I failed to found a\n+mention of an _instance_ of ios_base::Init in Standard.\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+\n+<p>Add to 27.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.iostream.objects\"> [lib.iostream.objects]</a>, p2, immediately before the last sentence\n+of the paragraph, the following two sentences:</p>\n+\n+<blockquote>\n+If a translation unit includes &lt;iostream&gt;, or explicitly\n+constructs an ios_base::Init object, these stream objects shall\n+be constructed before dynamic initialization of non-local\n+objects defined later in that translation unit, and these stream\n+objects shall be destroyed after the destruction of dynamically\n+initialized non-local objects defined later in that translation unit.\n+</blockquote>\n+\n+<p><i>[Lillehammer: Matt provided wording.]</i></p>\n+<p><i>[Mont Tremblant: Matt provided revised wording.]</i></p>\n+<p><b>Rationale:</b></p>\n+<p>\n+The original proposed resolution unconditionally required\n+implementations to define an ios_base::Init object of some\n+implementation-defined name in the header &lt;iostream&gt;. That's an\n+overspecification. First, defining the object may be unnecessary\n+and even detrimental to performance if an implementation can\n+guarantee that the 8 standard iostream objects will be initialized\n+before any other user-defined object in a program. Second, there\n+is no need to require implementations to document the name of the\n+object.</p>\n+\n+<p>\n+The new proposed resolution gives users guidance on what they need to\n+do to ensure that stream objects are constructed during startup.</p>\n <hr>\n <a name=\"370\"><h3>370.&nbsp;Minor error in basic_istream::get</h3></a><p><b>Section:</b>&nbsp;27.6.1.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.istream.unformatted\"> [lib.istream.unformatted]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;Ray Lischner&nbsp; <b>Date:</b>&nbsp;15 Jul 2002</p>\n <p>Defect report for description of basic_istream::get (section 27.6.1.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.istream.unformatted\"> [lib.istream.unformatted]</a>), paragraph 15. The description for the get function\n@@ -11444,6 +11708,82 @@ <h2>Defect Reports</h2>\n \n <p><b>Rationale:</b></p>\n <p>Fixes an obvious typo.</p>\n+<hr>\n+<a name=\"371\"><h3>371.&nbsp;Stability of multiset and multimap member functions</h3></a><p><b>Section:</b>&nbsp;23.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-containers.html#lib.container.requirements\"> [lib.container.requirements]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;Frank Compagner&nbsp; <b>Date:</b>&nbsp;20 Jul 2002</p>\n+<p>\n+The requirements for multiset and multimap containers (23.1\n+[lib.containers.requirements], 23.1.2 [lib.associative.reqmnts],\n+23.3.2 [lib.multimap] and 23.3.4 [lib.multiset]) make no mention of\n+the stability of the required (mutating) member functions. It appears\n+the standard allows these functions to reorder equivalent elements of\n+the container at will, yet the pervasive red-black tree implementation\n+appears to provide stable behaviour.\n+</p>\n+\n+<p>This is of most concern when considering the behaviour of erase().\n+A stability requirement would guarantee the correct working of the\n+following 'idiom' that removes elements based on a certain predicate\n+function.\n+</p>\n+\n+<pre>  multimap&lt;int, int&gt; m;\n+  multimap&lt;int, int&gt;::iterator i = m.begin();\n+  while (i != m.end()) {\n+      if (pred(i))\n+          m.erase (i++);\n+      else\n+          ++i;\n+  }\n+</pre>\n+\n+<p>\n+Although clause 23.1.2/8 guarantees that i remains a valid iterator\n+througout this loop, absence of the stability requirement could\n+potentially result in elements being skipped. This would make\n+this code incorrect, and, furthermore, means that there is no way\n+of erasing these elements without iterating first over the entire\n+container, and second over the elements to be erased. This would\n+be unfortunate, and have a negative impact on both performance and\n+code simplicity.\n+</p>\n+\n+<p>\n+If the stability requirement is intended, it should be made explicit\n+(probably through an extra paragraph in clause 23.1.2).\n+</p>\n+<p>\n+If it turns out stability cannot be guaranteed, i'd argue that a\n+remark or footnote is called for (also somewhere in clause 23.1.2) to\n+warn against relying on stable behaviour (as demonstrated by the code\n+above).  If most implementations will display stable behaviour, any\n+problems emerging on an implementation without stable behaviour will\n+be hard to track down by users. This would also make the need for an\n+erase_if() member function that much greater.\n+</p>\n+\n+<p>This issue is somewhat related to LWG issue <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#130\">130</a>.</p>\n+\n+<p><b>Proposed resolution:</b></p>\n+\n+<p>Add the following to the end of 23.1.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-containers.html#lib.associative.reqmts\"> [lib.associative.reqmts]</a> paragraph 4: \n+\"For <tt>multiset</tt> and <tt>multimap</tt>, <tt>insert</tt>and <tt>erase</tt>\n+  are <i>stable</i>: they preserve the relative ordering of equivalent\n+  elements.</p> \n+\n+<p><i>[Lillehammer: Matt provided wording]</i></p>\n+<p><i>[Joe Gottman points out that the provided wording does not address\n+multimap and multiset.  N1780 also addresses this issue and suggests\n+wording.]</i></p>\n+\n+<p><i>[Mont Tremblant: Changed set and map to multiset and multimap.]</i></p>\n+\n+<p><b>Rationale:</b></p>\n+<p>The LWG agrees that this guarantee is necessary for common user\n+  idioms to work, and that all existing implementations provide this\n+  property.  Note that this resolution guarantees stability for\n+  multimap and multiset, not for all associative containers in\n+  general.</p>\n+\n <hr>\n <a name=\"373\"><h3>373.&nbsp;Are basic_istream and basic_ostream to use (exceptions()&amp;badbit) != 0 ?</h3></a><p><b>Section:</b>&nbsp;27.6.1.2.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.istream.formatted.reqmts\"> [lib.istream.formatted.reqmts]</a>, 27.6.2.5.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.ostream.formatted.reqmts\"> [lib.ostream.formatted.reqmts]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;Keith Baker&nbsp; <b>Date:</b>&nbsp;23 Jul 2002</p>\n \n@@ -11476,6 +11816,42 @@ <h2>Defect Reports</h2>\n <p><b>Rationale:</b></p>\n <p>Fixes an obvious typo.</p>\n <hr>\n+<a name=\"376\"><h3>376.&nbsp;basic_streambuf semantics</h3></a><p><b>Section:</b>&nbsp;27.7.1.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.stringbuf.virtuals\"> [lib.stringbuf.virtuals]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;Ray Lischner&nbsp; <b>Date:</b>&nbsp;14 Aug 2002</p>\n+<p>\n+In Section 27.7.1.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.stringbuf.virtuals\"> [lib.stringbuf.virtuals]</a>, Table 90, the implication is that\n+the four conditions should be mutually exclusive, but they are not.\n+The first two cases, as written, are subcases of the third.</p>\n+\n+<p>\n+As written, it is unclear what should be the result if cases 1 and 2\n+are both true, but case 3 is false.\n+</p>\n+\n+<p><b>Proposed resolution:</b></p>\n+\n+<p>Rewrite these conditions as:</p>\n+<blockquote>\n+<p>\n+  (which &amp; (ios_base::in|ios_base::out)) == ios_base::in\n+</p>\n+\n+<p>\n+  (which &amp; (ios_base::in|ios_base::out)) == ios_base::out\n+</p>\n+\n+<p>\n+  (which &amp; (ios_base::in|ios_base::out)) == \n+(ios_base::in|ios_base::out)\n+   and way == either ios_base::beg or ios_base::end\n+</p>\n+\n+<p>Otherwise</p>\n+</blockquote>\n+\n+<p><b>Rationale:</b></p>\n+<p>It's clear what we wanted to say, we just failed to say it.  This\n+  fixes it.</p>\n+<hr>\n <a name=\"379\"><h3>379.&nbsp;nonsensical ctype::do_widen() requirement</h3></a><p><b>Section:</b>&nbsp;22.2.1.1.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-locales.html#lib.locale.ctype.virtuals\"> [lib.locale.ctype.virtuals]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;6 Sep 2002</p>\n <p>\n The last sentence in 22.2.1.1.2, p11 below doesn't seem to make sense.\n@@ -11651,6 +12027,64 @@ <h2>Defect Reports</h2>\n <p><b>Rationale:</b></p>\n <p>Fixes an obvious typo</p>\n <hr>\n+<a name=\"384\"><h3>384.&nbsp;equal_range has unimplementable runtime complexity</h3></a><p><b>Section:</b>&nbsp;25.3.3.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-algorithms.html#lib.equal.range\"> [lib.equal.range]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;Hans Bos&nbsp; <b>Date:</b>&nbsp;18 Oct 2002</p>\n+<p>\n+Section 25.3.3.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-algorithms.html#lib.equal.range\"> [lib.equal.range]</a>\n+states that at most 2 * log(last - first) + 1\n+comparisons are allowed for equal_range.\n+</p>\n+\n+<p>It is not possible to implement equal_range with these constraints.</p>\n+\n+<p>In a range of one element as in:</p>\n+<pre>    int x = 1;\n+    equal_range(&amp;x, &amp;x + 1, 1)\n+</pre>\n+\n+<p>it is easy to see that at least 2 comparison operations are needed.</p>\n+\n+<p>For this case at most 2 * log(1) + 1 = 1 comparison is allowed.</p>\n+\n+<p>I have checked a few libraries and they all use the same (nonconforming)\n+algorithm for equal_range that has a complexity of</p>\n+<pre>     2* log(distance(first, last)) + 2.\n+</pre>\n+<p>I guess this is the algorithm that the standard assumes for equal_range.</p>\n+\n+<p>\n+It is easy to see that 2 * log(distance) + 2 comparisons are enough\n+since equal range can be implemented with lower_bound and upper_bound\n+(both log(distance) + 1).\n+</p>\n+\n+<p>\n+I think it is better to require something like 2log(distance) + O(1)  (or\n+even logarithmic as multiset::equal_range).\n+Then an implementation has more room to optimize for certain cases (e.g.\n+have log(distance) characteristics when at most match is found in the range\n+but 2log(distance) + 4 for the worst case).\n+</p>\n+\n+<p><b>Proposed resolution:</b></p>\n+<p>In 25.3.3.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-algorithms.html#lib.lower.bound\"> [lib.lower.bound]</a>/4, change <tt>log(last - first) + 1</tt>\n+to <tt>log<sub>2</sub>(last - first) + <i>O</i>(1)</tt>.</p>\n+\n+<p>In 25.3.3.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-algorithms.html#lib.upper.bound\"> [lib.upper.bound]</a>/4, change <tt>log(last - first) + 1</tt>\n+to <tt>log<sub>2</sub>(last - first) + <i>O</i>(1)</tt>.</p>\n+\n+<p>In 25.3.3.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-algorithms.html#lib.equal.range\"> [lib.equal.range]</a>/4, change <tt>2*log(last - first) + 1</tt>\n+to <tt>2*log<sub>2</sub>(last - first) + <i>O</i>(1)</tt>.</p>\n+\n+<p><i>[Matt provided wording]</i></p>\n+<p><b>Rationale:</b></p>\n+<p>The LWG considered just saying <i>O</i>(log n) for all three, but\n+\ufffd decided that threw away too much valuable information.\ufffd The fact\n+\ufffd that lower_bound is twice as fast as equal_range is important.\n+\ufffd However, it's better to allow an arbitrary additive constant than to\n+\ufffd specify an exact count.\ufffd An exact count would have to\n+\ufffd involve <tt>floor</tt> or <tt>ceil</tt>.\ufffd It would be too easy to\n+\ufffd get this wrong, and don't provide any substantial value for users.</p>\n+<hr>\n <a name=\"386\"><h3>386.&nbsp;Reverse iterator's operator[] has impossible return type</h3></a><p><b>Section:</b>&nbsp;24.4.1.3.11 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iterators.html#lib.reverse.iter.opindex\"> [lib.reverse.iter.opindex]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#DR\">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Matt Austern&nbsp; <b>Date:</b>&nbsp;23 Oct 2002</p>\n <p>In 24.4.1.3.11 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iterators.html#lib.reverse.iter.opindex\"> [lib.reverse.iter.opindex]</a>, <tt>reverse_iterator&lt;&gt;::operator[]</tt> \n is specified as having a return type of <tt>reverse_iterator::reference</tt>,\n@@ -13216,7 +13650,7 @@ <h2>Defect Reports</h2>\n of <tt>sentry::operator bool()</tt> to const.\n </p>\n <hr>\n-<a name=\"443\"></a><h3><a name=\"443\">443.&nbsp;filebuf::close() inconsistent use of EOF</a></h3><p><b>Section:</b>&nbsp;27.8.1.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.filebuf.members\"> [lib.filebuf.members]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;Vincent Leloup&nbsp; <b>Date:</b>&nbsp;20 Nov 2003</p>\n+<a name=\"443\"><h3>443.&nbsp;filebuf::close() inconsistent use of EOF</h3></a><p><b>Section:</b>&nbsp;27.8.1.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.filebuf.members\"> [lib.filebuf.members]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;Vincent Leloup&nbsp; <b>Date:</b>&nbsp;20 Nov 2003</p>\n <p>\n In section 27.8.1.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iostreams.html#lib.filebuf.members\"> [lib.filebuf.members]</a> par6, in effects description of\n basic_filebuf&lt;charT, traits&gt;::close(), overflow(EOF) is used twice;\n@@ -13888,6 +14322,194 @@ <h2>Defect Reports</h2>\n I propose to strike the Footnote.\n </p>\n <hr>\n+<a name=\"475\"><h3>475.&nbsp;May the function object passed to for_each modify the elements of the iterated sequence?</h3></a><p><b>Section:</b>&nbsp;25.1.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-algorithms.html#lib.alg.foreach\"> [lib.alg.foreach]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;Stephan T. Lavavej, Jaakko Jarvi&nbsp; <b>Date:</b>&nbsp;9 Jul 2004</p>\n+<p>\n+It is not clear whether the function object passed to for_each is allowed to\n+modify the elements of the sequence being iterated over.\n+</p>\n+\n+<p>\n+for_each is classified without explanation in [lib.alg.nonmodifying], \"25.1\n+Non-modifying sequence operations\". 'Non-modifying sequence operation' is\n+never defined.\n+</p>\n+\n+<p>\n+25(5) says: \"If an algorithm's Effects section says that a value pointed to\n+by any iterator passed as an argument is modified, then that algorithm has\n+an additional type requirement: The type of that argument shall satisfy the\n+requirements of a mutable iterator (24.1).\"\n+</p>\n+\n+<p>for_each's Effects section does not mention whether arguments can be\n+modified:</p>\n+\n+<blockquote>\n+  \"Effects: Applies f to the result of dereferencing every iterator in the\n+   range [first, last), starting from first and proceeding to last - 1.\"\n+</blockquote>\n+\n+<p>\n+Every other algorithm in [lib.alg.nonmodifying] is \"really\" non-modifying in\n+the sense that neither the algorithms themselves nor the function objects\n+passed to the algorithms may modify the sequences or elements in any way.\n+This DR affects only for_each.\n+</p>\n+\n+<p>\n+We suspect that for_each's classification in \"non-modifying sequence\n+operations\" means that the algorithm itself does not inherently modify the\n+sequence or the elements in the sequence, but that the function object\n+passed to it may modify the elements it operates on. \n+</p>\n+\n+<p>\n+The original STL document by Stepanov and Lee explicitly prohibited the\n+function object from modifying its argument.\n+The \"obvious\" implementation of for_each found in several standard library \n+implementations, however, does not impose this restriction.\n+As a result, we suspect that the use of for_each with function objects that modify\n+their arguments is wide-spread. \n+If the restriction was reinstated, all such code would become non-conforming.\n+Further, none of the other algorithms in the Standard\n+could serve the purpose of for_each (transform does not guarantee the order in\n+which its function object is called). \n+</p>\n+\n+<p>\n+We suggest that the standard be clarified to explicitly allow the function object \n+passed to for_each modify its argument.</p>\n+\n+<p><b>Proposed resolution:</b></p>\n+<p>Add a nonnormative note to the Effects in 25.1.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-algorithms.html#lib.alg.foreach\"> [lib.alg.foreach]</a>: If\n+the type of 'first' satisfies the requirements of a mutable iterator,\n+'f' may apply nonconstant functions through the dereferenced iterators\n+passed to it.\n+</p>\n+\n+<p><b>Rationale:</b></p>\n+<p>The LWG believes that nothing in the standard prohibits function\n+  objects that modify the sequence elements. The problem is that\n+  for_each is in a secion entitled \"nonmutating algorithms\", and the\n+  title may be confusing.  A nonnormative note should clarify that.</p>\n+<hr>\n+<a name=\"478\"><h3>478.&nbsp;Should forward iterator requirements table have a line for r-&gt;m?</h3></a><p><b>Section:</b>&nbsp;24.1.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-iterators.html#lib.forward.iterators\"> [lib.forward.iterators]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;Dave Abrahams&nbsp; <b>Date:</b>&nbsp;11 Jul 2004</p>\n+<p>\n+The Forward Iterator requirements table contains the following:\n+</p>\n+<pre> expression  return type         operational  precondition\n+                                  semantics\n+  ==========  ==================  ===========  ==========================\n+  a-&gt;m        U&amp; if X is mutable, (*a).m       pre: (*a).m is well-defined.\n+              otherwise const U&amp;\n+\n+  r-&gt;m        U&amp;                  (*r).m       pre: (*r).m is well-defined.\n+</pre>\n+\n+<p>The second line may be unnecessary.  Paragraph 11 of\n+  [lib.iterator.requirements] says:\n+</p>\n+\n+<blockquote>\n+   In the following sections, a and b denote values of type const X, n\n+   denotes a value of the difference type Distance, u, tmp, and m\n+   denote identifiers, r denotes a value of X&amp;, t denotes a value of\n+   value type T, o denotes a value of some type that is writable to\n+   the output iterator.\n+</blockquote>\n+\n+<p>\n+Because operators can be overloaded on an iterator's const-ness, the\n+current requirements allow iterators to make many of the operations\n+specified using the identifiers a and b invalid for non-const\n+iterators.</p>\n+\n+<p>Related issue: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#477\">477</a></p>\n+<p><b>Proposed resolution:</b></p>\n+\n+<p>Remove the \"r-&gt;m\" line from the Forward Iterator requirements\n+table. Change</p>\n+<blockquote>\n+    \"const X\"\n+</blockquote>\n+\n+<p> to </p>\n+\n+<blockquote>\n+    \"X or const X\" \n+</blockquote>\n+\n+<p>in paragraph 11 of [lib.iterator.requirements].</p>\n+\n+\n+<p><b>Rationale:</b></p>\n+<p>\n+This is a defect because it constrains an lvalue to returning a modifiable lvalue.\n+</p>\n+<hr>\n+<a name=\"495\"><h3>495.&nbsp;Clause 22 template parameter requirements</h3></a><p><b>Section:</b>&nbsp;22 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-locales.html#lib.localization\"> [lib.localization]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;Beman Dawes&nbsp; <b>Date:</b>&nbsp;10 Jan 2005</p>\n+<p>It appears that there are no requirements specified for many of the\n+template parameters in clause 22. It looks like this issue has never\n+come up, except perhaps for Facet.</p>\n+\n+<p>Clause 22 isn't even listed in 17.3.2.1 [lib.type.descriptions],\n+either, which is the wording that allows requirements on template\n+parameters to be identified by name.</p>\n+\n+<p>So one issue is that 17.3.2.1 [lib.type.descriptions] Should be\n+changed to cover clause 22. A better change, which will cover us in\n+the future, would be to say that it applies to all the library\n+clauses. Then if a template gets added to any library clause we are\n+covered.</p>\n+\n+<p>charT, InputIterator, and other names with requirements defined\n+elsewhere are fine, assuming the 17.3.2.1 [lib.type.descriptions] fix.\n+But there are a few template arguments names which I don't think have\n+requirements given elsewhere:</p>\n+\n+<ul>\n+<li>internT and externT.  The fix is to add wording saying that internT\n+and externT must meet the same requirements as template arguments\n+named charT.</li>\n+\n+<li>stateT.  I'm not sure about this one. There already is some wording,\n+but it seems a bit vague.</li>\n+\n+<li>Intl.  [lib.locale.moneypunct.byname] The fix for this one is to\n+rename \"Intl\" to \"International\". The name is important because other\n+text identifies the requirements for the name International but not\n+for Intl.</li>\n+</ul>\n+<p><b>Proposed resolution:</b></p>\n+<p>Change 17.3.2.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-intro.html#lib.type.descriptions\"> [lib.type.descriptions]</a>, paragraph 1, from:</p>\n+<blockquote>\n+The Requirements subclauses may describe names that are used to\n+specify constraints on template arguments.153) These names are used in\n+clauses 20, 23, 25, and 26 to describe the types that may be supplied\n+as arguments by a C++ program when instantiating template components\n+from the library. \n+</blockquote>\n+<p>to:</p>\n+<blockquote>\n+The Requirements subclauses may describe names that are used to\n+specify constraints on template arguments.153) These names are used in\n+library clauses to describe the types that may be supplied as\n+arguments by a C++ program when instantiating template components from\n+the library.\n+</blockquote>\n+\n+<p>In the front matter of class 22, locales, add:</p>\n+<blockquote>\n+Template parameter types internT and externT shall meet the\n+requirements of charT (described in 21 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-strings.html#lib.strings\"> [lib.strings]</a>).\n+</blockquote>\n+<p><b>Rationale:</b></p>\n+<p>\n+ Again, a blanket clause isn't blanket enough. Also, we've got a\n+ couple of names that we don't have blanket requirement statements\n+ for. The only issue is what to do about stateT. This wording is\n+ thin, but probably adequate.</p>\n+<hr>\n <a name=\"496\"><h3>496.&nbsp;Illegal use of \"T\" in vector&lt;bool&gt;</h3></a><p><b>Section:</b>&nbsp;23.2.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-containers.html#lib.vector.bool\"> [lib.vector.bool]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;richard@ex-parrot.com&nbsp; <b>Date:</b>&nbsp;10 Feb 2005</p>\n <p>\n In the synopsis of the std::vector&lt;bool&gt; specialisation in 23.2.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-containers.html#lib.vector.bool\"> [lib.vector.bool]</a>,\n@@ -13900,6 +14522,210 @@ <h2>Defect Reports</h2>\n <p><b>Proposed resolution:</b></p>\n <p>Replace \"T\" with \"value_type\".</p>\n <hr>\n+<a name=\"497\"><h3>497.&nbsp;meaning of numeric_limits::traps for floating point types</h3></a><p><b>Section:</b>&nbsp;18.2.1.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lib-support.html#lib.numeric.limits.members\"> [lib.numeric.limits.members]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;Martin Sebor&nbsp; <b>Date:</b>&nbsp;2 Mar 2005</p>\n+\n+<p>18.2.1.2, p59 says this much about the traps member of numeric_limits:</p>\n+\n+<blockquote>\n+<p>static const bool traps;<br>\n+-59- true if trapping is implemented for the type.204)\n+<br>\n+Footnote 204: Required by LIA-1.\n+</p>\n+</blockquote>\n+\n+<p>It's not clear what is meant by \"is implemented\" here.</p>\n+\n+<p>\n+In the context of floating point numbers it seems reasonable to expect\n+to be able to use traps to determine whether a program can \"safely\" use\n+infinity(), quiet_NaN(), etc., in arithmetic expressions, that is\n+without causing a trap (i.e., on UNIX without having to worry about\n+getting a signal). When traps is true, I would expect any of the\n+operations in section 7 of IEEE 754 to cause a trap (and my program\n+to get a SIGFPE). So, for example, on Alpha, I would expect traps\n+to be true by default (unless I compiled my program with the -ieee\n+option), false by default on most other popular architectures,\n+including IA64, MIPS, PA-RISC, PPC, SPARC, and x86 which require\n+traps to be explicitly enabled by the program.\n+</p>\n+\n+<p>\n+Another possible interpretation of p59 is that traps should be true\n+on any implementation that supports traps regardless of whether they\n+are enabled by default or not. I don't think such an interpretation\n+makes the traps member very useful, even though that is how traps is\n+implemented on several platforms. It is also the only way to implement\n+traps on platforms that allow programs to enable and disable trapping\n+at runtime.\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>Change p59 to read:</p>\n+<blockquote>True if, at program startup, there exists a value of the type that\n+  would cause an arithmetic operation using that value to trap.</blockquote>\n+<p><b>Rationale:</b></p>\n+<p>\n+ Real issue, since trapping can be turned on and off. Unclear what a\n+ static query can say about a dynamic issue. The real advice we should\n+ give users is to use cfenv for these sorts of queries. But this new\n+ proposed resolution is at least consistent and slightly better than\n+ nothing.</p>\n+<hr>\n+<a name=\"505\"><h3>505.&nbsp;Result_type in random distribution requirements</h3></a><p><b>Section:</b>&nbsp;TR1 5.1.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/tr1.html#tr.rand.req\"> [tr.rand.req]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;Walter Brown&nbsp; <b>Date:</b>&nbsp;3 Jul 2005</p>\n+<p>\n+Table 17: Random distribution requirements\n+</p>\n+<p>\n+Row 1 requires that each random distribution provide a nested type \"input_type\";\n+this type denotes the type of the values that the distribution consumes.\n+</p>\n+<p>\n+Inspection of all distributions in [tr.rand.dist] reveals that each distribution\n+provides a second typedef (\"result_type\") that denotes the type of the values the\n+distribution produces when called.  \n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+It seems to me that this is also a requirement\n+for all distributions and should therefore be  indicated as such via a new second\n+row to this table 17:\n+</p>\n+<table border=\"1\" cellpadding=\"5\">\n+<tbody><tr>\n+<td>X::result_type</td>\n+<td>T</td>\n+<td>---</td>\n+<td>compile-time</td>\n+</tr>\n+</tbody></table>\n+\n+<p><i>[\n+Berlin:  Voted to WP.  N1932 adopts the proposed resolution:  see Table 5 row 1.\n+]</i></p>\n+\n+<hr>\n+<a name=\"507\"><h3>507.&nbsp;Missing requirement for variate_generator::operator()</h3></a><p><b>Section:</b>&nbsp;TR1 5.1.3 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/tr1.html#tr.rand.var\"> [tr.rand.var]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;Walter Brown&nbsp; <b>Date:</b>&nbsp;3 Jul 2005</p>\n+<p>\n+Paragraph 11 of [tr.rand.var] equires that the member template\n+</p>\n+<blockquote><pre>template&lt;class T&gt; result_type operator() (T value);\n+</pre></blockquote>\n+<p>\n+return\n+</p>\n+<blockquote><pre>distribution()(e, value)\n+</pre></blockquote>\n+<p>\n+However, not all distributions have an operator() with a corresponding signature.\n+</p>\n+\n+<p><i>[\n+Berlin:  As a working group we voted in favor of N1932 which makes this moot:\n+variate_generator has been eliminated.  Then in full committee we voted to give\n+this issue WP status (mistakenly).\n+]</i></p>\n+\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+We therefore  recommend that we insert the following precondition before paragraph 11:\n+</p>\n+<blockquote>\n+Precondition:  <tt>distribution().operator()(e,value)</tt> is well-formed.\n+</blockquote>\n+<hr>\n+<a name=\"508\"><h3>508.&nbsp;Bad parameters for ranlux64_base_01</h3></a><p><b>Section:</b>&nbsp;TR1 5.1.5 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/tr1.html#tr.rand.predef\"> [tr.rand.predef]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;Walter Brown&nbsp; <b>Date:</b>&nbsp;3 Jul 2005</p>\n+<p>\n+The fifth of these engines with predefined parameters, ranlux64_base_01,\n+appears to have an unintentional error for which there is a simple correction.\n+The two pre-defined  subtract_with_carry_01 engines are given as: \n+</p>\n+<blockquote><pre>typedef subtract_with_carry_01&lt;float,  24, 10, 24&gt; ranlux_base_01;\n+typedef subtract_with_carry_01&lt;double, 48, 10, 24&gt; ranlux64_base_01;\n+</pre></blockquote>\n+<p>\n+We demonstrate below that ranlux64_base_01 fails to meet the intent of the\n+random number generation proposal, but that the simple correction to\n+</p>\n+<blockquote><pre>typedef subtract_with_carry_01&lt;double, 48,  5, 12&gt; ranlux64_base_01;\n+</pre></blockquote>\n+<p>\n+does meet the intent of defining well-known good parameterizations.\n+</p>\n+<p>\n+The ranlux64_base_01 engine as presented fails to meet the intent for\n+predefined engines, stated in proposal N1398 (section E):\n+</p>\n+<blockquote><p>\n+In order to make good random numbers available to a large number of library\n+users, this proposal not only defines generic random-number engines, but also\n+provides a number of predefined well-known good parameterizations for those.\n+</p></blockquote>\n+<p>\n+The predefined ranlux_base_01 engine has been proven [1,2,3] to have a very\n+long period and so meets this criterion.  This property makes it suitable for\n+use in the excellent discard_block  engines defined subsequently.  The proof\n+of long period relies on the fact (proven in [1]) that 2**(w*r) - 2**(w*s)\n++ 1 is prime (w, r, and s are template parameters to subtract_with_carry_01,\n+as defined in [tr.rand.eng.sub1]).\n+</p>\n+<p>\n+The ranlux64_base_01 engine as presented in [tr.rand.predef] uses w=48, r=24, s=10.\n+For these numbers, the combination 2**(w*r)-2**(w*s)+1 is non-prime (though\n+explicit factorization  would be a challenge).  In consequence, while it is\n+certainly possible for some seeding states that this engine would have a very\n+long period, it is not at all \ufffdwell-known\ufffd that this is the case. The intent\n+in the N1398 proposal involved the base of the ranlux64 engine, which finds heavy\n+use in the physics community.  This is isomorphic to the predefined ranlux_base_01,\n+but exploits the ability of double variables to hold (at least) 48 bits of mantissa,\n+to deliver 48 random bits at a time rather than 24.\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+To achieve this intended behavior, the correct template parameteriztion  would be:\n+</p>\n+<blockquote><pre>typedef subtract_with_carry_01&lt;double, 48, 5, 12&gt; ranlux64_base_01;\n+</pre></blockquote>\n+<p>\n+The sequence of mantissa bits delivered by this is isomorphic (treating each\n+double as having the  bits of two floats) to that delivered by ranlux_base_01.\n+</p>\n+<p>\n+<b>References:</b>\n+</p>\n+<ol>\n+<li>F. James, Comput. Phys. Commun. 60(1990) 329</li>\n+<li>G. Marsaglia and A. Zaman, Ann. Appl. Prob 1(1991) 462</li>\n+<li>M. Luscher, Comput. Phys. Commun. 79(1994) 100-110</li>\n+</ol>\n+\n+<p><i>[\n+Berlin: Voted to WP.  N1932 adopts the proposed resolution in 26.3.5,\n+just above paragraph 5.\n+]</i></p>\n+\n+<hr>\n+<a name=\"519\"><h3>519.&nbsp;Data() undocumented</h3></a><p><b>Section:</b>&nbsp;TR1 6.2.2 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/tr1.html#tr.array.array\"> [tr.array.array]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#WP\">WP</a>&nbsp; <b>Submitter:</b>&nbsp;Pete Becker&nbsp; <b>Date:</b>&nbsp;3 Jul 2005</p>\n+<p>\n+<tt>array&lt;&gt;::data()</tt> is present in the class synopsis, but not documented.\n+</p>\n+<p><b>Proposed resolution:</b></p>\n+<p>\n+Add a new section, after 6.2.2.3:\n+</p>\n+<blockquote><pre>T*       data()\n+const T* data() const;\n+</pre></blockquote>\n+<p>\n+<b>Returns:</b> <tt>elems</tt>.\n+</p>\n+<p>\n+Change 6.2.2.4/2 to:\n+</p>\n+<blockquote>\n+In the case where <tt>N == 0</tt>, <tt>begin() == end()</tt>. The return value\n+of <tt>data()</tt> is unspecified.\n+</blockquote>\n+<hr>\n <a name=\"533\"><h3>533.&nbsp;typo in 2.2.3.10/1</h3></a><p><b>Section:</b>&nbsp;TR1 2.2.3.10 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/tr1.html#tr.util.smartptr.getdeleter\"> [tr.util.smartptr.getdeleter]</a>&nbsp; <b>Status:</b>&nbsp;<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#DR\">DR</a>&nbsp; <b>Submitter:</b>&nbsp;Paolo Carlini&nbsp; <b>Date:</b>&nbsp;9 Nov 2005</p>\n <p>\n I'm seeing something that looks like a typo. The Return of <tt>get_deleter</tt>"}]}