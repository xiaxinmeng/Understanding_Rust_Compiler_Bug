{"sha": "93c521ea9cf06574be59d946d160938accc4eb4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNjNTIxZWE5Y2YwNjU3NGJlNTlkOTQ2ZDE2MDkzOGFjY2M0ZWI0Yw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-05-28T23:10:47Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-05-28T23:10:47Z"}, "message": "runtime: fix misc gcc-isms and undefined behavior\n\nThis includes the use of __complex and __builtin_ functions where\nunprefixed entities would suffice, and the use of a union for\nbit-casting between types.\n\nFrom-SVN: r211036", "tree": {"sha": "df34b4ed79bf7318bf3a3954769e5b025f585952", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df34b4ed79bf7318bf3a3954769e5b025f585952"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93c521ea9cf06574be59d946d160938accc4eb4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93c521ea9cf06574be59d946d160938accc4eb4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93c521ea9cf06574be59d946d160938accc4eb4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93c521ea9cf06574be59d946d160938accc4eb4c/comments", "author": null, "committer": null, "parents": [{"sha": "bc2eed9a8e6b0f1cf976ffe626471c5755eb2ca4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc2eed9a8e6b0f1cf976ffe626471c5755eb2ca4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc2eed9a8e6b0f1cf976ffe626471c5755eb2ca4"}], "stats": {"total": 255, "additions": 113, "deletions": 142}, "files": [{"sha": "0355e26fc8ed2a955bddc7dcd41e180d33691f66", "filename": "libgo/runtime/go-cdiv.c", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c521ea9cf06574be59d946d160938accc4eb4c/libgo%2Fruntime%2Fgo-cdiv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c521ea9cf06574be59d946d160938accc4eb4c/libgo%2Fruntime%2Fgo-cdiv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-cdiv.c?ref=93c521ea9cf06574be59d946d160938accc4eb4c", "patch": "@@ -4,6 +4,9 @@\n    Use of this source code is governed by a BSD-style\n    license that can be found in the LICENSE file.  */\n \n+#include <complex.h>\n+#include <math.h>\n+\n /* Calls to these functions are generated by the Go frontend for\n    division of complex64 or complex128.  We use these because Go's\n    complex division expects slightly different results from the GCC\n@@ -13,33 +16,33 @@\n    the the whole number is Inf, but an operation involving NaN ought\n    to result in NaN, not Inf.  */\n \n-__complex float\n-__go_complex64_div (__complex float a, __complex float b)\n+complex float\n+__go_complex64_div (complex float a, complex float b)\n {\n-  if (__builtin_expect (b == 0+0i, 0))\n+  if (__builtin_expect (b == 0, 0))\n     {\n-      if (!__builtin_isinff (__real__ a)\n-\t  && !__builtin_isinff (__imag__ a)\n-\t  && (__builtin_isnanf (__real__ a) || __builtin_isnanf (__imag__ a)))\n+      if (!isinf (crealf (a))\n+\t  && !isinf (cimagf (a))\n+\t  && (isnan (crealf (a)) || isnan (cimagf (a))))\n \t{\n \t  /* Pass \"1\" to nanf to match math/bits.go.  */\n-\t  return __builtin_nanf(\"1\") + __builtin_nanf(\"1\")*1i;\n+\t  return nanf(\"1\") + nanf(\"1\")*I;\n \t}\n     }\n   return a / b;\n }\n \n-__complex double\n-__go_complex128_div (__complex double a, __complex double b)\n+complex double\n+__go_complex128_div (complex double a, complex double b)\n {\n-  if (__builtin_expect (b == 0+0i, 0))\n+  if (__builtin_expect (b == 0, 0))\n     {\n-      if (!__builtin_isinf (__real__ a)\n-\t  && !__builtin_isinf (__imag__ a)\n-\t  && (__builtin_isnan (__real__ a) || __builtin_isnan (__imag__ a)))\n+      if (!isinf (creal (a))\n+\t  && !isinf (cimag (a))\n+\t  && (isnan (creal (a)) || isnan (cimag (a))))\n \t{\n \t  /* Pass \"1\" to nan to match math/bits.go.  */\n-\t  return __builtin_nan(\"1\") + __builtin_nan(\"1\")*1i;\n+\t  return nan(\"1\") + nan(\"1\")*I;\n \t}\n     }\n   return a / b;"}, {"sha": "0f8f0627d73a2e0d7deb16a5f6e22b1a5a852ccb", "filename": "libgo/runtime/go-type-complex.c", "status": "modified", "additions": 48, "deletions": 62, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c521ea9cf06574be59d946d160938accc4eb4c/libgo%2Fruntime%2Fgo-type-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c521ea9cf06574be59d946d160938accc4eb4c/libgo%2Fruntime%2Fgo-type-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-type-complex.c?ref=93c521ea9cf06574be59d946d160938accc4eb4c", "patch": "@@ -4,83 +4,81 @@\n    Use of this source code is governed by a BSD-style\n    license that can be found in the LICENSE file.  */\n \n+#include <complex.h>\n+#include <math.h>\n+#include <stdint.h>\n+#include <string.h>\n #include \"runtime.h\"\n #include \"go-type.h\"\n \n-/* The 64-bit type.  */\n-\n-typedef unsigned int DItype __attribute__ ((mode (DI)));\n-\n /* Hash function for float types.  */\n \n uintptr_t\n __go_type_hash_complex (const void *vkey, uintptr_t key_size)\n {\n   if (key_size == 8)\n     {\n-      union\n-      {\n-\tunsigned char a[8];\n-\t__complex float cf;\n-\tDItype di;\n-      } ucf;\n-      __complex float cf;\n+      const complex float *cfp;\n+      complex float cf;\n       float cfr;\n       float cfi;\n+      uint64_t fi;\n+\n+      cfp = (const complex float *) vkey;\n+      cf = *cfp;\n+\n+      cfr = crealf (cf);\n+      cfi = cimagf (cf);\n \n-      __builtin_memcpy (ucf.a, vkey, 8);\n-      cf = ucf.cf;\n-      cfr = __builtin_crealf (cf);\n-      cfi = __builtin_cimagf (cf);\n-      if (__builtin_isinff (cfr) || __builtin_isinff (cfi))\n+      if (isinf (cfr) || isinf (cfi))\n \treturn 0;\n \n       /* NaN != NaN, so the hash code of a NaN is irrelevant.  Make it\n \t random so that not all NaNs wind up in the same place.  */\n-      if (__builtin_isnanf (cfr) || __builtin_isnanf (cfi))\n+      if (isnan (cfr) || isnan (cfi))\n \treturn runtime_fastrand1 ();\n \n       /* Avoid negative zero.  */\n       if (cfr == 0 && cfi == 0)\n \treturn 0;\n       else if (cfr == 0)\n-\tucf.cf = cfi * 1.0iF;\n+\tcf = cfi * I;\n       else if (cfi == 0)\n-\tucf.cf = cfr;\n+\tcf = cfr;\n \n-      return ucf.di;\n+      memcpy (&fi, &cf, 8);\n+      return (uintptr_t) cfi;\n     }\n   else if (key_size == 16)\n     {\n-      union\n-      {\n-\tunsigned char a[16];\n-\t__complex double cd;\n-\tDItype adi[2];\n-      } ucd;\n-      __complex double cd;\n+      const complex double *cdp;\n+      complex double cd;\n       double cdr;\n       double cdi;\n+      uint64_t di[2];\n \n-      __builtin_memcpy (ucd.a, vkey, 16);\n-      cd = ucd.cd;\n-      cdr = __builtin_crealf (cd);\n-      cdi = __builtin_cimagf (cd);\n-      if (__builtin_isinf (cdr) || __builtin_isinf (cdi))\n+      cdp = (const complex double *) vkey;\n+      cd = *cdp;\n+\n+      cdr = creal (cd);\n+      cdi = cimag (cd);\n+\n+      if (isinf (cdr) || isinf (cdi))\n \treturn 0;\n \n-      if (__builtin_isnan (cdr) || __builtin_isnan (cdi))\n+      if (isnan (cdr) || isnan (cdi))\n \treturn runtime_fastrand1 ();\n \n       /* Avoid negative zero.  */\n       if (cdr == 0 && cdi == 0)\n \treturn 0;\n       else if (cdr == 0)\n-\tucd.cd = cdi * 1.0i;\n+\tcd = cdi * I;\n       else if (cdi == 0)\n-\tucd.cd = cdr;\n+\tcd = cdr;\n \n-      return ucd.adi[0] ^ ucd.adi[1];\n+      memcpy (&di, &cd, 16);\n+      return di[0] ^ di[1];\n     }\n   else\n     runtime_throw (\"__go_type_hash_complex: invalid complex size\");\n@@ -93,35 +91,23 @@ __go_type_equal_complex (const void *vk1, const void *vk2, uintptr_t key_size)\n {\n   if (key_size == 8)\n     {\n-      union\n-      {\n-\tunsigned char a[8];\n-\t__complex float cf;\n-      } ucf;\n-      __complex float cf1;\n-      __complex float cf2;\n-\n-      __builtin_memcpy (ucf.a, vk1, 8);\n-      cf1 = ucf.cf;\n-      __builtin_memcpy (ucf.a, vk2, 8);\n-      cf2 = ucf.cf;\n-      return cf1 == cf2;\n+      const complex float *cfp1;\n+      const complex float *cfp2;\n+      \n+      cfp1 = (const complex float *) vk1;\n+      cfp2 = (const complex float *) vk2;\n+\n+      return *cfp1 == *cfp2;\n     }\n   else if (key_size == 16)\n     {\n-      union\n-      {\n-\tunsigned char a[16];\n-\t__complex double cd;\n-      } ucd;\n-      __complex double cd1;\n-      __complex double cd2;\n-\n-      __builtin_memcpy (ucd.a, vk1, 16);\n-      cd1 = ucd.cd;\n-      __builtin_memcpy (ucd.a, vk2, 16);\n-      cd2 = ucd.cd;\n-      return cd1 == cd2;\n+      const complex double *cdp1;\n+      const complex double *cdp2;\n+      \n+      cdp1 = (const complex double *) vk1;\n+      cdp2 = (const complex double *) vk2;\n+\n+      return *cdp1 == *cdp2;\n     }\n   else\n     runtime_throw (\"__go_type_equal_complex: invalid complex size\");"}, {"sha": "4ae73470de9ed68cb05afabdbac83f3cc54c0e8f", "filename": "libgo/runtime/go-type-float.c", "status": "modified", "additions": 34, "deletions": 54, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c521ea9cf06574be59d946d160938accc4eb4c/libgo%2Fruntime%2Fgo-type-float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c521ea9cf06574be59d946d160938accc4eb4c/libgo%2Fruntime%2Fgo-type-float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-type-float.c?ref=93c521ea9cf06574be59d946d160938accc4eb4c", "patch": "@@ -4,60 +4,53 @@\n    Use of this source code is governed by a BSD-style\n    license that can be found in the LICENSE file.  */\n \n+#include <math.h>\n+#include <stdint.h>\n #include \"runtime.h\"\n #include \"go-type.h\"\n \n-/* The 32-bit and 64-bit types.  */\n-\n-typedef unsigned int SItype __attribute__ ((mode (SI)));\n-typedef unsigned int DItype __attribute__ ((mode (DI)));\n-\n /* Hash function for float types.  */\n \n uintptr_t\n __go_type_hash_float (const void *vkey, uintptr_t key_size)\n {\n   if (key_size == 4)\n     {\n-      union\n-      {\n-\tunsigned char a[4];\n-\tfloat f;\n-\tSItype si;\n-      } uf;\n+      const float *fp;\n       float f;\n+      uint32_t si;\n \n-      __builtin_memcpy (uf.a, vkey, 4);\n-      f = uf.f;\n-      if (__builtin_isinff (f) || f == 0)\n+      fp = (const float *) vkey;\n+      f = *fp;\n+\n+      if (isinf (f) || f == 0)\n \treturn 0;\n \n       /* NaN != NaN, so the hash code of a NaN is irrelevant.  Make it\n \t random so that not all NaNs wind up in the same place.  */\n-      if (__builtin_isnanf (f))\n+      if (isnan (f))\n \treturn runtime_fastrand1 ();\n \n-      return (uintptr_t) uf.si;\n+      memcpy (&si, vkey, 4);\n+      return (uintptr_t) si;\n     }\n   else if (key_size == 8)\n     {\n-      union\n-      {\n-\tunsigned char a[8];\n-\tdouble d;\n-\tDItype di;\n-      } ud;\n+      const double *dp;\n       double d;\n+      uint64_t di;\n+\n+      dp = (const double *) vkey;\n+      d = *dp;\n \n-      __builtin_memcpy (ud.a, vkey, 8);\n-      d = ud.d;\n-      if (__builtin_isinf (d) || d == 0)\n+      if (isinf (d) || d == 0)\n \treturn 0;\n \n-      if (__builtin_isnan (d))\n+      if (isnan (d))\n \treturn runtime_fastrand1 ();\n \n-      return (uintptr_t) ud.di;\n+      memcpy (&di, vkey, 8);\n+      return (uintptr_t) di;\n     }\n   else\n     runtime_throw (\"__go_type_hash_float: invalid float size\");\n@@ -70,36 +63,23 @@ __go_type_equal_float (const void *vk1, const void *vk2, uintptr_t key_size)\n {\n   if (key_size == 4)\n     {\n-      union\n-      {\n-\tunsigned char a[4];\n-\tfloat f;\n-      } uf;\n-      float f1;\n-      float f2;\n-\n-      __builtin_memcpy (uf.a, vk1, 4);\n-      f1 = uf.f;\n-      __builtin_memcpy (uf.a, vk2, 4);\n-      f2 = uf.f;\n-      return f1 == f2;\n+      const float *fp1;\n+      const float *fp2;\n+\n+      fp1 = (const float *) vk1;\n+      fp2 = (const float *) vk2;\n+\n+      return *fp1 == *fp2;\n     }\n   else if (key_size == 8)\n     {\n-      union\n-      {\n-\tunsigned char a[8];\n-\tdouble d;\n-\tDItype di;\n-      } ud;\n-      double d1;\n-      double d2;\n-\n-      __builtin_memcpy (ud.a, vk1, 8);\n-      d1 = ud.d;\n-      __builtin_memcpy (ud.a, vk2, 8);\n-      d2 = ud.d;\n-      return d1 == d2;\n+      const double *dp1;\n+      const double *dp2;\n+\n+      dp1 = (const double *) vk1;\n+      dp2 = (const double *) vk2;\n+\n+      return *dp1 == *dp2;\n     }\n   else\n     runtime_throw (\"__go_type_equal_float: invalid float size\");"}, {"sha": "1656a998529f61a87c762cd5b996347119a5155c", "filename": "libgo/runtime/print.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c521ea9cf06574be59d946d160938accc4eb4c/libgo%2Fruntime%2Fprint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c521ea9cf06574be59d946d160938accc4eb4c/libgo%2Fruntime%2Fprint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fprint.c?ref=93c521ea9cf06574be59d946d160938accc4eb4c", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+#include <complex.h>\n+#include <math.h>\n #include <stdarg.h>\n #include \"runtime.h\"\n #include \"array.h\"\n@@ -105,7 +107,7 @@ go_vprintf(const char *s, va_list va)\n \t\t\truntime_printfloat(va_arg(va, float64));\n \t\t\tbreak;\n \t\tcase 'C':\n-\t\t\truntime_printcomplex(va_arg(va, __complex double));\n+\t\t\truntime_printcomplex(va_arg(va, complex double));\n \t\t\tbreak;\n \t\tcase 'i':\n \t\t\truntime_printiface(va_arg(va, Iface));\n@@ -174,13 +176,12 @@ runtime_printfloat(double v)\n \t\tgwrite(\"NaN\", 3);\n \t\treturn;\n \t}\n-\ti = __builtin_isinf_sign(v);\n-\tif(i > 0) {\n-\t\tgwrite(\"+Inf\", 4);\n-\t\treturn;\n-\t}\n-\tif(i < 0) {\n-\t\tgwrite(\"-Inf\", 4);\n+\tif(isinf(v)) {\n+\t\tif(signbit(v)) {\n+\t\t\tgwrite(\"-Inf\", 4);\n+\t\t} else {\n+\t\t\tgwrite(\"+Inf\", 4);\n+\t\t}\n \t\treturn;\n \t}\n \n@@ -243,11 +244,11 @@ runtime_printfloat(double v)\n }\n \n void\n-runtime_printcomplex(__complex double v)\n+runtime_printcomplex(complex double v)\n {\n \tgwrite(\"(\", 1);\n-\truntime_printfloat(__builtin_creal(v));\n-\truntime_printfloat(__builtin_cimag(v));\n+\truntime_printfloat(creal(v));\n+\truntime_printfloat(cimag(v));\n \tgwrite(\"i)\", 2);\n }\n "}, {"sha": "7a578502176421521d2d4d51c5ea591aa72698a3", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c521ea9cf06574be59d946d160938accc4eb4c/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c521ea9cf06574be59d946d160938accc4eb4c/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=93c521ea9cf06574be59d946d160938accc4eb4c", "patch": "@@ -5,6 +5,7 @@\n #include \"config.h\"\n \n #include \"go-assert.h\"\n+#include <complex.h>\n #include <signal.h>\n #include <stdio.h>\n #include <stdlib.h>\n@@ -710,7 +711,7 @@ void\truntime_printpointer(void*);\n void\truntime_printuint(uint64);\n void\truntime_printhex(uint64);\n void\truntime_printslice(Slice);\n-void\truntime_printcomplex(__complex double);\n+void\truntime_printcomplex(complex double);\n void reflect_call(const struct __go_func_type *, FuncVal *, _Bool, _Bool,\n \t\t  void **, void **)\n   __asm__ (GOSYM_PREFIX \"reflect.call\");"}]}