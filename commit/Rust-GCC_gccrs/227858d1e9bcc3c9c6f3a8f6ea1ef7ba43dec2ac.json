{"sha": "227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjI3ODU4ZDFlOWJjYzNjOWM2ZjNhOGY2ZWExZWY3YmE0M2RlYzJhYw==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2005-06-02T02:57:15Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2005-06-02T02:57:15Z"}, "message": "[multiple changes]\n\n2005-06-01  Diego Novillo  <dnovillo@redhat.com>\n\n\tPR 14341, PR 21332, PR 20701, PR 21029, PR 21086, PR 21090\n\tPR 21289, PR 21348, PR 21367, PR 21368, PR 21458.\n\t* fold-const.c (invert_tree_comparison): Make extern.\n\t* tree-flow.h (enum value_range_type): Move to tree-ssa-propagate.\n\t(struct value_range_def): Limewise.\n\t(get_value_range): Remove.\n\t(dump_value_range): Remove.\n\t(dump_all_value_ranges): Remove.\n\t(debug_all_value_ranges): Remove.\n\t(vrp_evaluate_conditional): Declare.\n\t* tree-ssa-propagate.c (struct prop_stats_d): Add field\n\tnum_pred_folded.\n\t(substitute_and_fold): Add argument use_ranges_p.\n\tUpdate all callers.\n\tIf use_ranges_p is true, call fold_predicate_in to fold\n\tpredicates using range information.\n\tIgnore ASSERT_EXPRs.\n\tChange debugging output to only show statements that have been\n\tfolded.\n\t(replace_phi_args_in): Move debugging output code from\n\tsubstitute and fold.\n\t(fold_predicate_in): New local function.\n\t* tree-ssa-propagate.h (enum value_range_type): Move from\n\ttree-flow.h.\n\t(struct value_range_d): Likewise.\n\tAdd field 'equiv'.\n\t(value_range_t): Rename from value_range.\n\t* tree-vrp.c (found_in_subgraph): Rename from found.\n\t(get_opposite_operand): Remove.\n\t(struct assert_locus_d): Declare.\n\t(assert_locus_t): Declare.\n\t(need_assert_for): Declare.\n\t(asserts_for): Declare.\n\t(blocks_visited): Declare.\n\t(vr_value): Declare.\n\t(set_value_range): Add argument 'equiv'.\n\tDon't drop to VARYING ranges that cover all values in the\n\ttype.\n\tMake deep copy of equivalence set 'equiv'.\n\t(copy_value_range): New local function.\n\t(set_value_range_to_undefined): New local function.\n\t(compare_values): Return -2 if either value has overflowed.\n\t(range_includes_zero_p): New local function.\n\t(extract_range_from_assert): Flip the predicate code if the\n\tname being asserted is on the RHS of the predicate.\n\tAvoid creating unnecessary symbolic ranges if the comparison\n\tincludes another name with a known numeric range.\n\tUpdate the equivalnce set of the new range when asserting\n\tEQ_EXPR predicates.\n\t(extract_range_from_ssa_name): Update the equivalence set of\n\tthe new range with VAR.\n\t(extract_range_from_binary_expr): Also handle TRUTH_*_EXPR.\n\tIf -fwrapv is used, set the resulting range to VARYING if the\n\toperation overflows.  Otherwise, use TYPE_MIN_VALUE and\n\tTYPE_MAX_VALUE to represent -INF and +INF.\n\tFix handling of *_DIV_EXPR.\n\t(extract_range_from_unary_expr): Handle MINUS_EXPR and\n\tABS_EXPR properly by switching the range around if necessary.\n\t(extract_range_from_comparison): New local function.\n\t(extract_range_from_expr): Call it.\n\t(adjust_range_with_scev): Do not adjust the range if using\n\twrapping arithmetic (-fwrapv).\n\t(dump_value_range): Also show equivalence set.\n\tShow -INF and +INF for TYPE_MIN_VALUE and TYPE_MAX_VALUE.\n\t(build_assert_expr_for): Also build ASSERT_EXPR for EQ_EXPR.\n\t(infer_value_range): Change return value to bool.\n\tAdd arguments 'comp_code_p' and 'val_p'.\n\tDo not attempt to infer ranges from statements that may throw.\n\tStore the comparison code in comp_code_p.\n\tStore the other operand to be used in the predicate in val_p.\n\t(dump_asserts_for): New.\n\t(debug_asserts_for): New.\n\t(dump_all_asserts): New.\n\t(debug_all_asserts): New.\n\t(register_new_assert_for): New.\n\t(register_edge_assert_for): New.\n\t(find_conditional_asserts): New.\n\t(find_assert_locations): New.\n\t(process_assert_insertions_for): New.\n\t(process_assert_insertions): New.\n\t(insert_range_assertions): Initialize found_in_subgraph,\n\tblocks_visited, need_assert_for and asserts_for.\n\tCall find_assert_locations and process_assert_insertions.\n\t(remove_range_assertions): Add more documentation.\n\t(vrp_initialize): Change return type to void.\n\tDo not try to guess if running VRP is worth it.\n\t(compare_name_with_value): New.\n\t(compare_names): New.\n\t(vrp_evaluate_conditional): Add argument 'use_equiv_p'.  If\n\tuse_equiv_p is true, call compare_names and\n\tcompare_name_with_value to compare all the ranges for every\n\tname in the equivalence set of the predicate operands.\n\tUpdate all callers.\n\t(vrp_meet): Try harder not to derive a VARYING range.\n\tIf two values meet, the resulting equivalence set is the\n\tintersection of the two equivalence sets.\n\t(vrp_visit_phi_node): Call copy_value_range to get the current\n\trange information of the LHS.\n\t(vrp_finalize): Create a value vector representing all the\n\tnames that ended up with exactly one value in their range.\n\tCall substitute_and_fold.\n\t(execute_vrp): Document equivalence sets in ranges.\n\t* tree.h (SSA_NAME_VALUE_RANGE): Remove.\n\t(struct tree_ssa_name): Remove field value_range.\n\t(invert_tree_comparison): Declare.\n\ntestsuite/ChangeLog\n\n2005-06-01  Diego Novillo  <dnovillo@redhat.com>\n\n\tPR 14341, PR 21332, PR 20701, PR 21086, PR 21090\n\tPR 21289, PR 21348, PR 21367, PR 21368, PR 21458.\n\t* gcc.dg/tree-ssa/pr14341.c: New test.\n\t* gcc.dg/tree-ssa/pr14841.c: New test.\n\t* gcc.dg/tree-ssa/pr20701.c: New test.\n\t* gcc.dg/tree-ssa/pr21086.c: New test.\n\t* gcc.dg/tree-ssa/pr21090.c: New test.\n\t* gcc.dg/tree-ssa/pr21332.c: New test.\n\t* gcc.dg/tree-ssa/pr21458.c: New test.\n\t* gcc.dg/tree-ssa/pr21658.c: New test.\n\t* gcc.dg/tree-ssa/vrp01.c: New test.\n\t* gcc.dg/tree-ssa/vrp02.c: New test.\n\t* gcc.dg/tree-ssa/vrp03.c: New test.\n\t* gcc.dg/tree-ssa/vrp04.c: New test.\n\t* gcc.dg/tree-ssa/vrp05.c: New test.\n\t* gcc.dg/tree-ssa/vrp06.c: New test.\n\t* gcc.dg/tree-ssa/vrp07.c: New test.\n\t* gcc.dg/tree-ssa/vrp08.c: New test.\n\t* gcc.dg/tree-ssa/vrp09.c: New test.\n\t* gcc.dg/tree-ssa/vrp10.c: New test.\n\t* gcc.dg/tree-ssa/vrp11.c: New test.\n\t* gcc.dg/tree-ssa/vrp12.c: New test.\n\t* gcc.dg/tree-ssa/vrp13.c: New test.\n\n2005-06-01  Alexandre Oliva  <aoliva@redhat.com>\n\n\tPR 21029\n\t* gcc.dg/tree-ssa/pr21029.c: New test.\n\nFrom-SVN: r100478", "tree": {"sha": "ae1c65c21b373e1f2c501ae1c46755f0fb072bda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae1c65c21b373e1f2c501ae1c46755f0fb072bda"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/comments", "author": null, "committer": null, "parents": [{"sha": "292a398fb78ca6012b17481992ffa220a62d2b96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/292a398fb78ca6012b17481992ffa220a62d2b96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/292a398fb78ca6012b17481992ffa220a62d2b96"}], "stats": {"total": 3460, "additions": 2873, "deletions": 587}, "files": [{"sha": "c344fe0c04630017c2b73b027294d876c5abf18e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "patch": "@@ -1,3 +1,111 @@\n+2005-06-01  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tPR 14341, PR 21332, PR 20701, PR 21029, PR 21086, PR 21090\n+\tPR 21289, PR 21348, PR 21367, PR 21368, PR 21458.\n+\t* fold-const.c (invert_tree_comparison): Make extern.\n+\t* tree-flow.h (enum value_range_type): Move to tree-ssa-propagate.\n+\t(struct value_range_def): Limewise.\n+\t(get_value_range): Remove.\n+\t(dump_value_range): Remove.\n+\t(dump_all_value_ranges): Remove.\n+\t(debug_all_value_ranges): Remove.\n+\t(vrp_evaluate_conditional): Declare.\n+\t* tree-ssa-propagate.c (struct prop_stats_d): Add field\n+\tnum_pred_folded.\n+\t(substitute_and_fold): Add argument use_ranges_p.\n+\tUpdate all callers.\n+\tIf use_ranges_p is true, call fold_predicate_in to fold\n+\tpredicates using range information.\n+\tIgnore ASSERT_EXPRs.\n+\tChange debugging output to only show statements that have been\n+\tfolded.\n+\t(replace_phi_args_in): Move debugging output code from\n+\tsubstitute and fold.\n+\t(fold_predicate_in): New local function.\n+\t* tree-ssa-propagate.h (enum value_range_type): Move from\n+\ttree-flow.h.\n+\t(struct value_range_d): Likewise.\n+\tAdd field 'equiv'. \n+\t(value_range_t): Rename from value_range.\n+\t* tree-vrp.c (found_in_subgraph): Rename from found.\n+\t(get_opposite_operand): Remove.\n+\t(struct assert_locus_d): Declare.\n+\t(assert_locus_t): Declare.\n+\t(need_assert_for): Declare.\n+\t(asserts_for): Declare.\n+\t(blocks_visited): Declare.\n+\t(vr_value): Declare.\n+\t(set_value_range): Add argument 'equiv'.\n+\tDon't drop to VARYING ranges that cover all values in the\n+\ttype.\n+\tMake deep copy of equivalence set 'equiv'.\n+\t(copy_value_range): New local function.\n+\t(set_value_range_to_undefined): New local function.\n+\t(compare_values): Return -2 if either value has overflowed.\n+\t(range_includes_zero_p): New local function.\n+\t(extract_range_from_assert): Flip the predicate code if the\n+\tname being asserted is on the RHS of the predicate.\n+\tAvoid creating unnecessary symbolic ranges if the comparison\n+\tincludes another name with a known numeric range.\n+\tUpdate the equivalnce set of the new range when asserting\n+\tEQ_EXPR predicates.\n+\t(extract_range_from_ssa_name): Update the equivalence set of\n+\tthe new range with VAR.\n+\t(extract_range_from_binary_expr): Also handle TRUTH_*_EXPR.\n+\tIf -fwrapv is used, set the resulting range to VARYING if the\n+\toperation overflows.  Otherwise, use TYPE_MIN_VALUE and\n+\tTYPE_MAX_VALUE to represent -INF and +INF.\n+\tFix handling of *_DIV_EXPR.\n+\t(extract_range_from_unary_expr): Handle MINUS_EXPR and\n+\tABS_EXPR properly by switching the range around if necessary.\n+\t(extract_range_from_comparison): New local function.\n+\t(extract_range_from_expr): Call it.\n+\t(adjust_range_with_scev): Do not adjust the range if using\n+\twrapping arithmetic (-fwrapv).\n+\t(dump_value_range): Also show equivalence set.\n+\tShow -INF and +INF for TYPE_MIN_VALUE and TYPE_MAX_VALUE.\n+\t(build_assert_expr_for): Also build ASSERT_EXPR for EQ_EXPR.\n+\t(infer_value_range): Change return value to bool.\n+\tAdd arguments 'comp_code_p' and 'val_p'.\n+\tDo not attempt to infer ranges from statements that may throw.\n+\tStore the comparison code in comp_code_p.\n+\tStore the other operand to be used in the predicate in val_p.\n+\t(dump_asserts_for): New.\n+\t(debug_asserts_for): New.\n+\t(dump_all_asserts): New.\n+\t(debug_all_asserts): New.\n+\t(register_new_assert_for): New.\n+\t(register_edge_assert_for): New.\n+\t(find_conditional_asserts): New.\n+\t(find_assert_locations): New.\n+\t(process_assert_insertions_for): New.\n+\t(process_assert_insertions): New.\n+\t(insert_range_assertions): Initialize found_in_subgraph,\n+\tblocks_visited, need_assert_for and asserts_for.\n+\tCall find_assert_locations and process_assert_insertions.\n+\t(remove_range_assertions): Add more documentation.\n+\t(vrp_initialize): Change return type to void.\n+\tDo not try to guess if running VRP is worth it.  \n+\t(compare_name_with_value): New.\n+\t(compare_names): New.\n+\t(vrp_evaluate_conditional): Add argument 'use_equiv_p'.  If\n+\tuse_equiv_p is true, call compare_names and\n+\tcompare_name_with_value to compare all the ranges for every\n+\tname in the equivalence set of the predicate operands.\n+\tUpdate all callers.\n+\t(vrp_meet): Try harder not to derive a VARYING range.\n+\tIf two values meet, the resulting equivalence set is the\n+\tintersection of the two equivalence sets.\n+\t(vrp_visit_phi_node): Call copy_value_range to get the current\n+\trange information of the LHS.\n+\t(vrp_finalize): Create a value vector representing all the\n+\tnames that ended up with exactly one value in their range.\n+\tCall substitute_and_fold.\n+\t(execute_vrp): Document equivalence sets in ranges.\n+\t* tree.h (SSA_NAME_VALUE_RANGE): Remove.\n+\t(struct tree_ssa_name): Remove field value_range.\n+\t(invert_tree_comparison): Declare.\n+\n 2005-06-01  Daniel Berlin  <dberlin@dberlin.org>\n \n \tFix PR tree-optimization/21839"}, {"sha": "721701b6732f7238a50072cbf25a1751ac42b31a", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "patch": "@@ -89,7 +89,6 @@ static tree negate_expr (tree);\n static tree split_tree (tree, enum tree_code, tree *, tree *, tree *, int);\n static tree associate_trees (tree, tree, enum tree_code, tree);\n static tree const_binop (enum tree_code, tree, tree, int);\n-static enum tree_code invert_tree_comparison (enum tree_code, bool);\n static enum comparison_code comparison_to_compcode (enum tree_code);\n static enum tree_code compcode_to_comparison (enum comparison_code);\n static tree combine_comparisons (enum tree_code, enum tree_code,\n@@ -2119,7 +2118,7 @@ pedantic_non_lvalue (tree x)\n    comparisons, except for NE_EXPR and EQ_EXPR, so we receive a machine mode\n    as well: if reversing the comparison is unsafe, return ERROR_MARK.  */\n \n-static enum tree_code\n+enum tree_code\n invert_tree_comparison (enum tree_code code, bool honor_nans)\n {\n   if (honor_nans && flag_trapping_math)"}, {"sha": "288242eed45b6485df9273c7b1d8b4d121d78e35", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "patch": "@@ -1,3 +1,34 @@\n+2005-06-01  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tPR 14341, PR 21332, PR 20701, PR 21086, PR 21090\n+\tPR 21289, PR 21348, PR 21367, PR 21368, PR 21458.\n+\t* gcc.dg/tree-ssa/pr14341.c: New test.\n+\t* gcc.dg/tree-ssa/pr14841.c: New test.\n+\t* gcc.dg/tree-ssa/pr20701.c: New test.\n+\t* gcc.dg/tree-ssa/pr21086.c: New test.\n+\t* gcc.dg/tree-ssa/pr21090.c: New test.\n+\t* gcc.dg/tree-ssa/pr21332.c: New test.\n+\t* gcc.dg/tree-ssa/pr21458.c: New test.\n+\t* gcc.dg/tree-ssa/pr21658.c: New test.\n+\t* gcc.dg/tree-ssa/vrp01.c: New test.\n+\t* gcc.dg/tree-ssa/vrp02.c: New test.\n+\t* gcc.dg/tree-ssa/vrp03.c: New test.\n+\t* gcc.dg/tree-ssa/vrp04.c: New test.\n+\t* gcc.dg/tree-ssa/vrp05.c: New test.\n+\t* gcc.dg/tree-ssa/vrp06.c: New test.\n+\t* gcc.dg/tree-ssa/vrp07.c: New test.\n+\t* gcc.dg/tree-ssa/vrp08.c: New test.\n+\t* gcc.dg/tree-ssa/vrp09.c: New test.\n+\t* gcc.dg/tree-ssa/vrp10.c: New test.\n+\t* gcc.dg/tree-ssa/vrp11.c: New test.\n+\t* gcc.dg/tree-ssa/vrp12.c: New test.\n+\t* gcc.dg/tree-ssa/vrp13.c: New test.\n+\n+2005-06-01  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR 21029\n+\t* gcc.dg/tree-ssa/pr21029.c: New test.\n+\n 2005-06-01  Roger Sayle  <roger@eyesopen.com>\n \n \t* gfortran.dg/logint-1.f: New test case."}, {"sha": "07f51b78d84a09947c4ddd7a9c79a6f1c875ac92", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr14341.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr14341.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr14341.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr14341.c?ref=227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+\n+void fn_call (int);\n+int h(int, int);\n+void t()\n+{\n+  int i;\n+  int x;\n+    for( i = 0; i < 100000000; i++ ){ \n+ \tfn_call (i < 100000000);\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"fn_call \\\\(1\\\\)\" 1 \"vrp\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp\" } } */"}, {"sha": "4f9c759da902f12c893d7c1899c0fbf26de67e42", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr14841.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr14841.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr14841.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr14841.c?ref=227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "patch": "@@ -25,5 +25,5 @@ foo (void)\n     link_error ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"with if \\\\(0\\\\)\" 1 \"store_ccp\"} } */\n+/* { dg-final { scan-tree-dump-times \"Folded statement: if \" 1 \"store_ccp\"} } */\n /* { dg-final { cleanup-tree-dump \"store_ccp\" } } */"}, {"sha": "a02c317b5d9b425991f284639784a671e0d713dc", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr20701.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr20701.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr20701.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr20701.c?ref=227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+\n+typedef struct {\n+  int code;\n+} *rtx;\n+\n+int\n+can_combine_p (rtx insn, rtx elt)\n+{\n+  rtx set;\n+\n+  set = 0;\n+  if (insn->code == 3)\n+    set = insn;\n+  else\n+    {\n+      set = elt;\n+      if (set == 0)\n+\treturn 0;\n+    }\n+\n+  if (set == 0)\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Folding predicate.*to 0\" 1 \"vrp\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp\" } } */"}, {"sha": "de2595aee55cc75310102c8efb51f8577acb00d2", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr21029.c", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21029.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21029.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21029.c?ref=227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "patch": "@@ -0,0 +1,118 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fwrapv\" } */\n+\n+/* PR tree-optimization/21029\n+\n+   f() used to get optimized to an infinite loop by tree-vrp, because\n+   j is assumed to be non-negative.  Even though the conversion from\n+   unsigned to signed has unspecified results if the expression value\n+   is not representable in the signed type, the compiler itself (e.g.,\n+   the Ada front end) depends on wrap-around behavior.  */\n+\n+unsigned int f(void) {\n+  unsigned char i = 123;\n+  signed char j;\n+\n+  do\n+    if ((j = (signed char) i) < 0)\n+      break;\n+    else\n+      i++;\n+  while (1);\n+\n+  return i;\n+}\n+\n+/* Now let's torture it a bit further.  Narrowing conversions need\n+   similar treatment.  */\n+\n+unsigned int f1 (void) {\n+  unsigned short i = 123;\n+  signed char j;\n+\n+  do\n+    if ((j = (signed char) i) < 0)\n+      break;\n+    else\n+      i++;\n+  while (1);\n+\n+  return i;\n+}\n+\n+/* And so do widening conversions.  */\n+\n+unsigned int f2 (void) {\n+  unsigned char i = 123;\n+  signed short j;\n+\n+  do\n+    if ((j = (signed short) (signed char) i) < 0)\n+      break;\n+    else\n+      i++;\n+  while (1);\n+\n+  return i;\n+}\n+\n+/* Check same-sign truncations with an increment that turns into\n+   decrements.  */\n+\n+unsigned int f3 (void) {\n+  signed short i = 5;\n+  signed char j;\n+\n+  do\n+    if ((j = (signed char) i) < 0)\n+      break;\n+    else\n+      i += 255;\n+  while (1);\n+\n+  return i;\n+}\n+\n+/* Check that the truncation above doesn't confuse the result of the\n+   test after a widening conversion.  */\n+\n+unsigned int f4 (void) {\n+  signed short i = -123;\n+  signed int j;\n+\n+  do\n+    if ((j = (signed int) (signed char) i) > 0)\n+      break;\n+    else\n+      i += 255;\n+  while (1);\n+\n+  return i;\n+}\n+\n+/* Even if we omit the widening truncation, the narrowing truncation\n+   is implementation-defined.  */\n+\n+unsigned int f5 (void) {\n+  signed long i = -123;\n+  signed char j;\n+\n+  do\n+    if ((j = (signed char) i) > 0)\n+      break;\n+    else\n+      i += 255;\n+  while (1);\n+\n+  return i;\n+}\n+\n+int main (void) {\n+  f ();\n+  f1 ();\n+  f2 ();\n+  f3 ();\n+  f4 ();\n+  f5 ();\n+  return 0;\n+}"}, {"sha": "547d1c8d78b9a4ff32dc05d67e5c876a822da9cc", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr21086.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21086.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21086.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21086.c?ref=227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+\n+int\n+foo (int *p)\n+{\n+  int a = *p;\n+  int b = p != 0;\n+\n+  *p = b;\n+\n+  if (b)\n+    return a;\n+  else\n+    return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Folding predicate \" 2 \"vrp\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp\" } } */"}, {"sha": "e6b3c885b9c73af8641c3f1a52b516e361a1c2bb", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr21090.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21090.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21090.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21090.c?ref=227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+\n+int g, h;\n+\n+int\n+foo (int a)\n+{\n+  int *p;\n+\n+  if (a)\n+    p = &g;\n+  else\n+    p = &h;\n+\n+  if (p != 0)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Folding predicate.*to 1\" 1 \"vrp\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp\" } } */"}, {"sha": "8dd75ccc574fc39e53586e5954da96d8d393d6b7", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr21332.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21332.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21332.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21332.c?ref=227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+// this testcase fails also on amd64:\n+\n+extern void abort (void);\n+\n+int f ()\n+{\n+  return -1;\n+}\n+\n+int main ()\n+{\n+  int b, c, i;\n+\n+  b = 0;\n+  c = f ();\n+  if (c <= 0)\n+    {\n+      c = -c;\n+      for (i = 0; i < c; i++)\n+\t  b = 1;\n+      if (!b)\n+\tabort ();\n+    }\n+  return 0;\n+}"}, {"sha": "0222e7a697b042b8424c4d008eb855a7a3c4f2f5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr21458.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21458.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21458.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21458.c?ref=227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+\n+extern void g (void);\n+extern void bar (int);\n+\n+int\n+foo (int a)\n+{\n+  int i;\n+\n+  for (i = 1; i < 100; i++)\n+    {\n+      if (i)\n+\tg ();\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Folding predicate.*to 1\" 1 \"vrp\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp\" } } */"}, {"sha": "2fa45b40a71b0fe6c9101c219a0efc9d3fb7f4f0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr21658.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21658.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21658.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21658.c?ref=227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "patch": "@@ -17,5 +17,5 @@ f (void)\n     link_error ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"with if \\\\(0\\\\)\" 1 \"ccp\"} } */\n+/* { dg-final { scan-tree-dump-times \"Folded statement: if \" 1 \"ccp\"} } */\n /* { dg-final { cleanup-tree-dump \"ccp\" } } */"}, {"sha": "1edda2941fa23d22070c183087c9bc29e55e7bdd", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp01.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp01.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp01.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp01.c?ref=227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+\n+foo (int *p, int i)\n+{\n+  int x;\n+\n+  if (i > 10)\n+    {\n+      if (p)\n+\t{\n+\t  x = *p;\n+\t  p = 0;\n+\t}\n+    }\n+  else\n+    p = 0;\n+\n+  /* This should be folded to if (1), but only if we insert an\n+     assertion on the ELSE edge from the inner 'if (p)'.  */\n+  if (p == 0)\n+    return x + 1;\n+\n+  return i;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Folding predicate p_.*to 1\" 1 \"vrp\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp\" } } */"}, {"sha": "61cb3087c86e37dd8dcbbc0cb6c82ac62f8e2348", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp02.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp02.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp02.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp02.c?ref=227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+\n+struct A\n+{\n+  int a;\n+  int b;\n+};\n+\n+foo (struct A *p, struct A *q)\n+{\n+  int x = p->a;\n+  if (p == q)\n+    return q->a;\n+\n+  /* We should fold this to 'if (1)' but the assertion for 'p == q'\n+     was overwriting the assertion 'p != 0' from the first dereference\n+     of 'p'.  */\n+  if (p)\n+    return x + p->b;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Folding predicate p_.*to 1\" 1 \"vrp\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp\" } } */"}, {"sha": "20fcb917eb30f9b7f13fe1cf3fa67df94e3afe39", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp03.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp03.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp03.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp03.c?ref=227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+\n+struct A\n+{\n+  int a;\n+  int b;\n+};\n+\n+foo (struct A *p, struct A *q)\n+{\n+  int *r = 0;\n+\n+  if (p)\n+    {\n+      if (p == q)\n+\t{\n+\t  /* This should be folded to 'if (1)' because q is [p, p]\n+\t     and p is ~[0, 0].  */\n+\t  if (q)\n+\t    r = &q->a;\n+\n+\t  /* This should be folded to 'if (1)' because q should be\n+\t     ~[0, 0] and thus &q->a should be ~[0, 0].  */\n+\t  if (r)\n+\t    return 5;\n+\t}\n+    }\n+\n+  return q->a;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Folding predicate q_.*to 1\" 1 \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate r_.*to 1\" 1 \"vrp\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp\" } } */"}, {"sha": "26322483f03fe2a9ab7c3d0aa35d56f2761fcc55", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp04.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp04.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp04.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp04.c?ref=227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+\n+foo (int a, int b)\n+{\n+  if (a == b)\n+    /* This should be folded to if (1)  */\n+    if (a == b)\n+      return a + b;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Folding predicate a_.*to 1\" 1 \"vrp\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp\" } } */"}, {"sha": "767d3e1dead145d42e78171b013327b545f04b73", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp05.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp05.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp05.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp05.c?ref=227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+\n+foo (int k, int j)\n+{\n+  if (k >= 10)\n+    {\n+      if (j > k)\n+\t{\n+\t  /* We should fold this to if (1).  */\n+\t  if (j > 0)\n+\t    return j;\n+\t}\n+    }\n+\n+  return j;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Folding predicate j_.*to 1\" 1 \"vrp\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp\" } } */"}, {"sha": "a92db95749a0750d996a847e4f0466bfc0dc19cb", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp06.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp06.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp06.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp06.c?ref=227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+\n+foo (int i, int j, int a)\n+{\n+  if (i >= 10)\n+    if (i <= 30)\n+      if (i == j)\n+\t{\n+\t  a--;\n+\n+\t  /* This should fold to 'if (0)'.  */\n+\t  if (i < 0)\n+\t    i = baz ();\n+\n+\t  /* This should fold to 'if (1)'.  */\n+\t  if (j > 0)\n+\t    a--;\n+\n+\t  /* This should fold to 'if (0)'.  */\n+\t  if (i != j)\n+\t    return 0;\n+\t}\n+\n+  return i + a + j;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Folding predicate i_.*to 0\" 1 \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate j_.*to 1\" 1 \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate i_.*to 0\" 1 \"vrp\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp\" } } */"}, {"sha": "49df596b04e6ad8c11be826562063369090178d5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp07.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp07.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp07.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp07.c?ref=227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp-details\" } */\n+\n+foo (int i, int *p)\n+{\n+  int j;\n+\n+  if (i > 10)\n+    {\n+      if (p)\n+\t{\n+\t  j = *p;\n+\t  /* This should be folded to if (1) because of the parent 'if\n+\t     (p)'.  But the dereference of p above does not need an\n+\t     assertion.  */\n+\t  if (p)\n+\t    return j + 1;\n+\t}\n+    }\n+  else\n+    {\n+      j = *p - 3;\n+      /* This should be folded to if (0), because p has just been\n+\t dereferenced.  But we were not inserting enough ASSERT_EXPRs\n+\t to figure it out.  */\n+      if (!p)\n+\treturn j - 4;\n+    }\n+\n+  return i;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Folding predicate p_.*to 1\" 1 \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate p_.*to 0\" 1 \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"PREDICATE: p_\\[0-9\\] ne_expr 0B\" 2 \"vrp\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp\" } } */"}, {"sha": "5bf43fe9f37be9b0da1f3fcba993798bbb3f8f74", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp08.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp08.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp08.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp08.c?ref=227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-tree-fre -fdump-tree-vrp-details\" } */\n+\n+/* Compile with -fno-tree-fre -O2 to prevent CSEing *p.  */\n+foo (int a, int *p)\n+{\n+  int x = *p + 2;\n+  int y = *p - 1;\n+  int z = *p + 9;\n+\n+  /* This should be folded to if (1), but only one ASSERT_EXPR should\n+     be inserted.  */\n+  if (p)\n+    a = x + y + z;\n+  else\n+    a = x - y;\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Folding predicate p_.*to 1\" 1 \"vrp\" } } */\n+/* { dg-final { scan-tree-dump-times \"PREDICATE: p_. ne_expr 0\" 1 \"vrp\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp\" } } */"}, {"sha": "6a2c98344d059df3dc7f7de2da68541f712116ef", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp09.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp09.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp09.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp09.c?ref=227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+\n+foo (int *p)\n+{\n+  int x = baz ();\n+\n+  if (p == 0)\n+    goto L78;\n+  else\n+    {\n+      x = *p;\n+      /* This should be folded to if (1).  */\n+      if (p)\n+\tx = x + 1;\n+L78:\n+      /* This should not be folded to if (1).  */\n+      if (p)\n+\t{\n+\t  x = baz (*p);\n+\t  /* This should be folded to if (1).  */\n+\t  if (p)\n+\t    return x + 3;\n+\t}\n+\n+      return x - 3;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Folding predicate p_.. != 0B to 1\" 2 \"vrp\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp\" } } */"}, {"sha": "5a745845948644f675dc6122e9819c945b85bf87", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp10.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp10.c?ref=227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+extern void abort (void);\n+\n+foo (int k, int j)\n+{\n+  if (k >= 10)\n+    {\n+      if (j > k)\n+\t{\n+\t  /* We should fold this to if (0).  */\n+\t  if (j < 10)\n+\t    abort ();\n+\t}\n+    }\n+\n+  return j;\n+}\n+\n+main()\n+{\n+  foo (10, 3);\n+  return 0;\n+}"}, {"sha": "b9e5fca71f998eee0bcd3a7dc328db49762624e8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp11.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp11.c?ref=227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+\n+foo (int k, int j, int z)\n+{\n+  if (k > z)\n+    {\n+      if (j > k)\n+\t{\n+\t  /* We should fold this to if (1).  */\n+\t  if (j > z)\n+\t    return j;\n+\t}\n+    }\n+\n+  return j;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Folding predicate.*to 1\" 1 \"vrp\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp\" } } */"}, {"sha": "1714a561cd5cf35967ec9d53db4230d8c54c8713", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp12.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp12.c?ref=227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do link } */\n+/* { dg-options -O2 } */\n+\n+foo (int i)\n+{\n+  int x;\n+\n+  x = i;\n+  if (i < -10)\n+    {\n+      x = __builtin_abs (i);\n+      /* VRP was incorrectly folding this to if (1).  */\n+      if (x < 0)\n+\tlink_error ();\n+    }\n+\n+  return x;\n+}\n+\n+main()\n+{\n+  foo (-30);\n+}"}, {"sha": "cfc55d8d5ecf8b7b4c302143fdedec14d0b59ba8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp13.c", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp13.c?ref=227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "patch": "@@ -0,0 +1,139 @@\n+/* { dg-do run }  */\n+/* { dg-options -O2 }  */\n+\n+extern void abort (void);\n+\n+foo (int i, int j)\n+{\n+  int k;\n+\n+  /* [-INF, -1] / [1, +INF] should not give [-1, -1].  */\n+  if (i <= -1)\n+    if (j >= 1)\n+      {\n+\tk = i / j;\n+\tif (k == -1)\n+\t  abort ();\n+\n+\treturn k;\n+      }\n+\n+  /* [-20, -10] / [2, 10] should give [-10, -1].  */\n+  if (i >= -20)\n+    if (i <= -10)\n+      if (j >= 2)\n+\tif (j <= 10)\n+\t  {\n+\t    k = i / j;\n+\t    if (k < -10)\n+\t      link_error ();\n+\t    if (k > -1)\n+\t      link_error ();\n+\n+\t    return k;\n+\t  }\n+\n+  /* [-20, -10] / [-10, -2] should give [1, 10].  */\n+  if (i >= -20)\n+    if (i <= -10)\n+      if (j >= -10)\n+\tif (j <= -2)\n+\t  {\n+\t    k = i / j;\n+\t    if (k < 1)\n+\t      link_error ();\n+\t    if (k > 10)\n+\t      link_error ();\n+\n+\t    return k;\n+\t  }\n+\n+  /* [-20, 10] / [2, 10] should give [-10, 5].  */\n+  if (i >= -20)\n+    if (i <= 10)\n+      if (j >= 2)\n+\tif (j <= 10)\n+\t  {\n+\t    k = i / j;\n+\t    if (k < -10)\n+\t      link_error ();\n+\t    if (k > 5)\n+\t      link_error ();\n+\n+\t    return k;\n+\t  }\n+\n+  /* [-20, 10] / [-10, -2] should give [-5, 10].  */\n+  if (i >= -20)\n+    if (i <= 10)\n+      if (j >= -10)\n+\tif (j <= -2)\n+\t  {\n+\t    k = i / j;\n+\t    if (k < -5)\n+\t      link_error ();\n+\t    if (k > 10)\n+\t      link_error ();\n+\n+\t    return k;\n+\t  }\n+\n+  /* [10, 20] / [2, 10] should give [1, 10].  */\n+  if (i >= 10)\n+    if (i <= 20)\n+      if (j >= 2)\n+\tif (j <= 10)\n+\t  {\n+\t    k = i / j;\n+\t    if (k < 1)\n+\t      link_error ();\n+\t    if (k > 10)\n+\t      link_error ();\n+\n+\t    return k;\n+\t  }\n+\n+  /* [10, 20] / [-10, -2] should give [-10, -1].  */\n+  if (i >= 10)\n+    if (i <= 20)\n+      if (j >= -10)\n+\tif (j <= -2)\n+\t  {\n+\t    k = i / j;\n+\t    if (k > -1)\n+\t      link_error ();\n+\t    if (k < -10)\n+\t      link_error ();\n+\n+\t    return k;\n+\t  }\n+\n+  abort ();\n+}\n+\n+\n+main()\n+{\n+  if (foo (-10, 5) != -2)\n+    abort ();\n+\n+  if (foo (-16, 4) != -4)\n+    abort ();\n+\n+  if (foo (-15, -5) != 3)\n+    abort ();\n+\n+  if (foo (8, 2) != 4)\n+    abort ();\n+\n+  if (foo (10, -2) != -5)\n+    abort ();\n+\n+  if (foo (20, 5) != 4)\n+    abort ();\n+\n+  if (foo (15, -3) != -5)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "2b044b8b9438c9544b70e2d315dd463c8c10921e", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 33, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "patch": "@@ -83,34 +83,6 @@ struct ptr_info_def GTY(())\n };\n \n \n-/* Types of value ranges.  */\n-enum value_range_type { VR_UNDEFINED, VR_RANGE, VR_ANTI_RANGE, VR_VARYING };\n-\n-\n-/* Ranges of values that can be associated with an SSA_NAME after VRP\n-   has executed.  */\n-struct value_range_def GTY(())\n-{\n-  /* Lattice value represented by this range.  */\n-  enum value_range_type type;\n-\n-  /* Minimum and maximum values represented by this range.  These\n-     values are _CST nodes that should be interpreted as follows:\n-\n-     \t- If TYPE == VR_UNDEFINED then MIN and MAX must be NULL.\n-\n-\t- If TYPE == VR_RANGE then MIN holds the minimum value and\n-\t  MAX holds the maximum value of the range [MIN, MAX].\n-\n-\t- If TYPE == ANTI_RANGE the variable is known to NOT\n-\t  take any values in the range [MIN, MAX].  */\n-  tree min;\n-  tree max;\n-};\n-\n-typedef struct value_range_def value_range;\n-\n-\n /*---------------------------------------------------------------------------\n \t\t   Tree annotations stored in tree_common.ann\n ---------------------------------------------------------------------------*/\n@@ -619,12 +591,8 @@ bool fold_stmt_inplace (tree);\n tree widen_bitfield (tree, tree, tree);\n \n /* In tree-vrp.c  */\n-value_range *get_value_range (tree);\n-void dump_value_range (FILE *, value_range *);\n-void debug_value_range (value_range *);\n-void dump_all_value_ranges (FILE *);\n-void debug_all_value_ranges (void);\n bool expr_computes_nonzero (tree);\n+tree vrp_evaluate_conditional (tree, bool);\n \n /* In tree-ssa-dom.c  */\n extern void dump_dominator_optimization_stats (FILE *);"}, {"sha": "3fe8de3726154f814bb55aff68574a5cd2247765", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "patch": "@@ -580,7 +580,7 @@ static void\n ccp_finalize (void)\n {\n   /* Perform substitutions based on the known constant values.  */\n-  substitute_and_fold (const_val);\n+  substitute_and_fold (const_val, false);\n \n   free (const_val);\n }"}, {"sha": "2f1072669fbb6138de96af86245c90bb17dac04e", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "patch": "@@ -894,7 +894,7 @@ fini_copy_prop (void)\n \tcopy_of[i].value = get_last_copy_of (var);\n     }\n \n-  substitute_and_fold (copy_of);\n+  substitute_and_fold (copy_of, false);\n \n   free (cached_last_copy_of);\n   free (copy_of);"}, {"sha": "37c644b50c49cbb4542bec86b1e650d10ae40bb8", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 114, "deletions": 32, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "patch": "@@ -773,6 +773,7 @@ struct prop_stats_d\n {\n   long num_const_prop;\n   long num_copy_prop;\n+  long num_pred_folded;\n };\n \n static struct prop_stats_d prop_stats;\n@@ -964,6 +965,11 @@ static void\n replace_phi_args_in (tree phi, prop_value_t *prop_value)\n {\n   int i;\n+  bool replaced = false;\n+  tree prev_phi = NULL;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    prev_phi = unshare_expr (phi);\n \n   for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n     {\n@@ -981,6 +987,7 @@ replace_phi_args_in (tree phi, prop_value_t *prop_value)\n \t\tprop_stats.num_copy_prop++;\n \n \t      propagate_value (PHI_ARG_DEF_PTR (phi, i), val);\n+\t      replaced = true;\n \n \t      /* If we propagated a copy and this argument flows\n \t\t through an abnormal edge, update the replacement\n@@ -991,19 +998,79 @@ replace_phi_args_in (tree phi, prop_value_t *prop_value)\n \t    }\n \t}\n     }\n+  \n+  if (replaced && dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Folded PHI node: \");\n+      print_generic_stmt (dump_file, prev_phi, TDF_SLIM);\n+      fprintf (dump_file, \"           into: \");\n+      print_generic_stmt (dump_file, phi, TDF_SLIM);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+}\n+\n+\n+/* If STMT has a predicate whose value can be computed using the value\n+   range information computed by VRP, compute its value and return true.\n+   Otherwise, return false.  */\n+\n+static bool\n+fold_predicate_in (tree stmt)\n+{\n+  tree *pred_p = NULL;\n+  tree val;\n+\n+  if (TREE_CODE (stmt) == MODIFY_EXPR\n+      && COMPARISON_CLASS_P (TREE_OPERAND (stmt, 1)))\n+    pred_p = &TREE_OPERAND (stmt, 1);\n+  else if (TREE_CODE (stmt) == COND_EXPR)\n+    pred_p = &COND_EXPR_COND (stmt);\n+  else\n+    return false;\n+\n+  val = vrp_evaluate_conditional (*pred_p, true);\n+  if (val)\n+    {\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"Folding predicate \");\n+\t  print_generic_expr (dump_file, *pred_p, 0);\n+\t  fprintf (dump_file, \" to \");\n+\t  print_generic_expr (dump_file, val, 0);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+\n+      prop_stats.num_pred_folded++;\n+      *pred_p = val;\n+      return true;\n+    }\n+\n+  return false;\n }\n \n \n-/* Perform final substitution and folding of propagated values.  */\n+/* Perform final substitution and folding of propagated values.\n+\n+   PROP_VALUE[I] contains the single value that should be substituted\n+   at every use of SSA name N_I.  If PROP_VALUE is NULL, no values are\n+   substituted.\n+\n+   If USE_RANGES_P is true, statements that contain predicate\n+   expressions are evaluated with a call to vrp_evaluate_conditional.\n+   This will only give meaningful results when called from tree-vrp.c\n+   (the information used by vrp_evaluate_conditional is built by the\n+   VRP pass).  */\n \n void\n-substitute_and_fold (prop_value_t *prop_value)\n+substitute_and_fold (prop_value_t *prop_value, bool use_ranges_p)\n {\n   basic_block bb;\n \n+  if (prop_value == NULL && !use_ranges_p)\n+    return;\n+\n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file,\n-\t     \"\\nSubstituing values and folding statements\\n\\n\");\n+    fprintf (dump_file, \"\\nSubstituing values and folding statements\\n\\n\");\n \n   memset (&prop_stats, 0, sizeof (prop_stats));\n \n@@ -1013,41 +1080,51 @@ substitute_and_fold (prop_value_t *prop_value)\n       block_stmt_iterator i;\n       tree phi;\n \n-      /* Propagate our known values into PHI nodes.  */\n-      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"Replaced \");\n-\t      print_generic_stmt (dump_file, phi, TDF_SLIM);\n-\t    }\n-\n+      /* Propagate known values into PHI nodes.  */\n+      if (prop_value)\n+\tfor (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n \t  replace_phi_args_in (phi, prop_value);\n \n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \" with \");\n-\t      print_generic_stmt (dump_file, phi, TDF_SLIM);\n-\t      fprintf (dump_file, \"\\n\");\n-\t    }\n-\t}\n-\n       for (i = bsi_start (bb); !bsi_end_p (i); bsi_next (&i))\n \t{\n           bool replaced_address, did_replace;\n+\t  tree prev_stmt = NULL;\n \t  tree stmt = bsi_stmt (i);\n \n+\t  /* Ignore ASSERT_EXPRs.  They are used by VRP to generate\n+\t     range information for names and they are discarded\n+\t     afterwards.  */\n+\t  if (TREE_CODE (stmt) == MODIFY_EXPR\n+\t      && TREE_CODE (TREE_OPERAND (stmt, 1)) == ASSERT_EXPR)\n+\t    continue;\n+\n \t  /* Replace the statement with its folded version and mark it\n \t     folded.  */\n+\t  did_replace = false;\n+\t  replaced_address = false;\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    prev_stmt = unshare_expr (stmt);\n+\n+\t  /* If we have range information, see if we can fold\n+\t     predicate expressions.  */\n+\t  if (use_ranges_p)\n+\t    did_replace = fold_predicate_in (stmt);\n+\n+\t  if (prop_value)\n \t    {\n-\t      fprintf (dump_file, \"Replaced \");\n-\t      print_generic_stmt (dump_file, stmt, TDF_SLIM);\n+\t      /* Only replace real uses if we couldn't fold the\n+\t\t statement using value range information (value range\n+\t\t information is not collected on virtuals, so we only\n+\t\t need to check this for real uses).  */\n+\t      if (!did_replace)\n+\t\tdid_replace |= replace_uses_in (stmt, &replaced_address,\n+\t\t                                prop_value);\n+\n+\t      did_replace |= replace_vuses_in (stmt, &replaced_address,\n+\t\t                               prop_value);\n \t    }\n \n-\t  replaced_address = false;\n-\t  did_replace = replace_uses_in (stmt, &replaced_address, prop_value);\n-\t  did_replace |= replace_vuses_in (stmt, &replaced_address, prop_value);\n+\t  /* If we made a replacement, fold and cleanup the statement.  */\n \t  if (did_replace)\n \t    {\n \t      tree old_stmt = stmt;\n@@ -1068,13 +1145,15 @@ substitute_and_fold (prop_value_t *prop_value)\n \t      rhs = get_rhs (stmt);\n \t      if (TREE_CODE (rhs) == ADDR_EXPR)\n \t\trecompute_tree_invarant_for_addr_expr (rhs);\n-\t    }\n \n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \" with \");\n-\t      print_generic_stmt (dump_file, stmt, TDF_SLIM);\n-\t      fprintf (dump_file, \"\\n\");\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fprintf (dump_file, \"Folded statement: \");\n+\t\t  print_generic_stmt (dump_file, prev_stmt, TDF_SLIM);\n+\t\t  fprintf (dump_file, \"            into: \");\n+\t\t  print_generic_stmt (dump_file, stmt, TDF_SLIM);\n+\t\t  fprintf (dump_file, \"\\n\");\n+\t\t}\n \t    }\n \t}\n     }\n@@ -1085,6 +1164,9 @@ substitute_and_fold (prop_value_t *prop_value)\n \t       prop_stats.num_const_prop);\n       fprintf (dump_file, \"Copies propagated:    %6ld\\n\",\n \t       prop_stats.num_copy_prop);\n+      fprintf (dump_file, \"Predicates folded:    %6ld\\n\",\n+\t       prop_stats.num_pred_folded);\n     }\n }\n+\n #include \"gt-tree-ssa-propagate.h\""}, {"sha": "f7265fe0e6cc40dcea44276c86809e86fde176a0", "filename": "gcc/tree-ssa-propagate.h", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftree-ssa-propagate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftree-ssa-propagate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.h?ref=227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "patch": "@@ -73,6 +73,39 @@ struct prop_value_d {\n typedef struct prop_value_d prop_value_t;\n \n \n+/* Type of value ranges.  See value_range_d for a description of these\n+   types.  */\n+enum value_range_type { VR_UNDEFINED, VR_RANGE, VR_ANTI_RANGE, VR_VARYING };\n+\n+/* Range of values that can be associated with an SSA_NAME after VRP\n+   has executed.  */\n+struct value_range_d\n+{\n+  /* Lattice value represented by this range.  */\n+  enum value_range_type type;\n+\n+  /* Minimum and maximum values represented by this range.  These\n+     values should be interpreted as follows:\n+\n+\t- If TYPE is VR_UNDEFINED or VR_VARYING then MIN and MAX must\n+\t  be NULL.\n+\n+\t- If TYPE == VR_RANGE then MIN holds the minimum value and\n+\t  MAX holds the maximum value of the range [MIN, MAX].\n+\n+\t- If TYPE == ANTI_RANGE the variable is known to NOT\n+\t  take any values in the range [MIN, MAX].  */\n+  tree min;\n+  tree max;\n+\n+  /* Set of SSA names whose value ranges are equivalent to this one.\n+     This set is only valid when TYPE is VR_RANGE or VR_ANTI_RANGE.  */\n+  bitmap equiv;\n+};\n+\n+typedef struct value_range_d value_range_t;\n+\n+\n /* Call-back functions used by the value propagation engine.  */\n typedef enum ssa_prop_result (*ssa_prop_visit_stmt_fn) (tree, edge *, tree *);\n typedef enum ssa_prop_result (*ssa_prop_visit_phi_fn) (tree);\n@@ -87,6 +120,6 @@ bool stmt_makes_single_load (tree);\n bool stmt_makes_single_store (tree);\n prop_value_t *get_value_loaded_by (tree, prop_value_t *);\n bool replace_uses_in (tree, bool *, prop_value_t *);\n-void substitute_and_fold (prop_value_t *);\n+void substitute_and_fold (prop_value_t *, bool);\n \n #endif /* _TREE_SSA_PROPAGATE_H  */"}, {"sha": "e55ef37616260fe3415eb2d508355d5dfb0d3f9c", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 1877, "deletions": 507, "changes": 2384, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac"}, {"sha": "ced72b17bcec876078828bc3c93e3250a22da67e", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=227858d1e9bcc3c9c6f3a8f6ea1ef7ba43dec2ac", "patch": "@@ -1338,17 +1338,12 @@ struct tree_exp GTY(())\n #define SSA_NAME_VALUE(N) \\\n    SSA_NAME_CHECK (N)->ssa_name.value_handle\n \n-/* Range information for SSA_NAMEs.  */\n-#define SSA_NAME_VALUE_RANGE(N) \\\n-    SSA_NAME_CHECK (N)->ssa_name.value_range\n-\n /* Auxiliary pass-specific data.  */\n #define SSA_NAME_AUX(N) \\\n    SSA_NAME_CHECK (N)->ssa_name.aux\n \n #ifndef _TREE_FLOW_H\n struct ptr_info_def;\n-struct value_range_def;\n #endif\n \n \n@@ -1386,9 +1381,6 @@ struct tree_ssa_name GTY(())\n      as well.  */\n   tree value_handle;\n \n-  /* Value range information.  */\n-  struct value_range_def *value_range;\n-\n   /* Auxiliary information stored with the ssa name.  */\n   PTR GTY((skip)) aux;\n \n@@ -3601,6 +3593,7 @@ extern bool tree_swap_operands_p (tree, tree, bool);\n extern enum tree_code swap_tree_comparison (enum tree_code);\n \n extern bool ptr_difference_const (tree, tree, HOST_WIDE_INT *);\n+extern enum tree_code invert_tree_comparison (enum tree_code, bool);\n \n /* In builtins.c */\n extern tree fold_builtin (tree, tree, bool);"}]}