{"sha": "be1ac4ecae4317082e9a45c86f3b90e0e429e78f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmUxYWM0ZWNhZTQzMTcwODJlOWE0NWM4NmYzYjkwZTBlNDI5ZTc4Zg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-09-06T13:26:13Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-09-06T13:26:13Z"}, "message": "tree.def (MISALIGNED_INDIRECT_REF): Remove.\n\n2010-09-06  Richard Guenther  <rguenther@suse.de>\n\n\t* tree.def (MISALIGNED_INDIRECT_REF): Remove.\n\t* tree.h (INDIRECT_REF_P): Only check for INDIRECT_REF.\n\t(build_aligned_type): Declare.\n\t* tree.c (check_qualified_type): Also compare TYPE_ALIGN.\n\t(check_aligned_type): New function.\n\t(build_aligned_type): Likewise.\n\t* expr.c (expand_assignment): Handle misaligned stores via\n\tTARGET_MEM_REF and MEM_REF using movmisalign_optab.\n\t(expand_expr_real_1): Likewise.\n\t(safe_from_p): Remove MISALIGNED_INDIRECT_REF handling.\n\t* tree-vect-stmts.c (vectorizable_store): Do not build\n\tMISALIGNED_INDIRECT_REF but initialize alignment information.\n\t(vectorizable_load): Likewise.\n\t* builtins.c (get_object_alignment): Remove MISALIGNED_INDIRECT_REF\n\thandling.\n\t* cfgexpand.c (expand_debug_expr): Likewise.\n\t* dwarf2out.c (loc_list_from_tree): Likewise.\n\t* fold-const.c (maybe_lvalue_p): Likewise.\n\t(operand_equal_p): Likewise.\n\t(build_fold_addr_expr_with_type_loc): Likewise.\n\t* gimplify.c (gimplify_addr_expr): Likewise.\n\t(gimplify_expr): Likewise.\n\t* tree-cfg.c (verify_types_in_gimple_min_lval): Likewise.\n\t(verify_gimple_assign_single): Likewise.\n\t* tree-dump.c (dequeue_and_dump): Likewise.\n\t(tree_could_trap_p): Likewise.\n\t* tree-predcom.c (ref_at_iteration): Likewise.\n\t* tree-pretty-print.c (dump_generic_node): Likewise.\n\t(op_code_prio): Likewise.\n\t(op_symbol_code): Likewise.\n\t* tree-ssa-ccp.c (get_value_from_alignment): Likewise.\n\t* tree-ssa-loop-im.c (for_each_index): Likewise.\n\t(gen_lsm_tmp_name): Likewise.\n\t* tree-ssa-loop-ivopts.c (idx_find_step): Likewise.\n\t(find_interesting_uses_address): Likewise.\n\t* tree-ssa-loop-prefetch.c (idx_analyze_ref): Likewise.\n\t* tree-ssa-operands.c (get_expr_operands): Likewise.\n\t* tree-ssa-pre.c (create_component_ref_by_pieces_1): Likewise.\n\t* tree-ssa-sccvn.c (copy_reference_ops_from_ref): Likewise.\n\t(ao_ref_init_from_vn_reference): Likewise.\n\t* tree.c (staticp): Likewise.\n\t(build1_stat): Likewise.\n\t(reference_alias_ptr_type): Likewise.\n\t* emit-rtl.c (set_mem_attributes_minus_bitpos): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_check_sdmode): Remove\n\tMISALIGNED_INDIRECT_REF handling.\n\nFrom-SVN: r163915", "tree": {"sha": "ae7fc5c26853d1f5d2558a8bfd07474392012be4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae7fc5c26853d1f5d2558a8bfd07474392012be4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be1ac4ecae4317082e9a45c86f3b90e0e429e78f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be1ac4ecae4317082e9a45c86f3b90e0e429e78f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be1ac4ecae4317082e9a45c86f3b90e0e429e78f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "863a75787c5765257e516afa538dee2e22d6d0ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/863a75787c5765257e516afa538dee2e22d6d0ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/863a75787c5765257e516afa538dee2e22d6d0ad"}], "stats": {"total": 490, "additions": 258, "deletions": 232}, "files": [{"sha": "c61e45836568a51d95e378669553fc07463d560e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=be1ac4ecae4317082e9a45c86f3b90e0e429e78f", "patch": "@@ -1,3 +1,52 @@\n+2010-09-06  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree.def (MISALIGNED_INDIRECT_REF): Remove.\n+\t* tree.h (INDIRECT_REF_P): Only check for INDIRECT_REF.\n+\t(build_aligned_type): Declare.\n+\t* tree.c (check_qualified_type): Also compare TYPE_ALIGN.\n+\t(check_aligned_type): New function.\n+\t(build_aligned_type): Likewise.\n+\t* expr.c (expand_assignment): Handle misaligned stores via\n+\tTARGET_MEM_REF and MEM_REF using movmisalign_optab.\n+\t(expand_expr_real_1): Likewise.\n+\t(safe_from_p): Remove MISALIGNED_INDIRECT_REF handling.\n+\t* tree-vect-stmts.c (vectorizable_store): Do not build\n+\tMISALIGNED_INDIRECT_REF but initialize alignment information.\n+\t(vectorizable_load): Likewise.\n+\t* builtins.c (get_object_alignment): Remove MISALIGNED_INDIRECT_REF\n+\thandling.\n+\t* cfgexpand.c (expand_debug_expr): Likewise.\n+\t* dwarf2out.c (loc_list_from_tree): Likewise.\n+\t* fold-const.c (maybe_lvalue_p): Likewise.\n+\t(operand_equal_p): Likewise.\n+\t(build_fold_addr_expr_with_type_loc): Likewise.\n+\t* gimplify.c (gimplify_addr_expr): Likewise.\n+\t(gimplify_expr): Likewise.\n+\t* tree-cfg.c (verify_types_in_gimple_min_lval): Likewise.\n+\t(verify_gimple_assign_single): Likewise.\n+\t* tree-dump.c (dequeue_and_dump): Likewise.\n+\t(tree_could_trap_p): Likewise.\n+\t* tree-predcom.c (ref_at_iteration): Likewise.\n+\t* tree-pretty-print.c (dump_generic_node): Likewise.\n+\t(op_code_prio): Likewise.\n+\t(op_symbol_code): Likewise.\n+\t* tree-ssa-ccp.c (get_value_from_alignment): Likewise.\n+\t* tree-ssa-loop-im.c (for_each_index): Likewise.\n+\t(gen_lsm_tmp_name): Likewise.\n+\t* tree-ssa-loop-ivopts.c (idx_find_step): Likewise.\n+\t(find_interesting_uses_address): Likewise.\n+\t* tree-ssa-loop-prefetch.c (idx_analyze_ref): Likewise.\n+\t* tree-ssa-operands.c (get_expr_operands): Likewise.\n+\t* tree-ssa-pre.c (create_component_ref_by_pieces_1): Likewise.\n+\t* tree-ssa-sccvn.c (copy_reference_ops_from_ref): Likewise.\n+\t(ao_ref_init_from_vn_reference): Likewise.\n+\t* tree.c (staticp): Likewise.\n+\t(build1_stat): Likewise.\n+\t(reference_alias_ptr_type): Likewise.\n+\t* emit-rtl.c (set_mem_attributes_minus_bitpos): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_check_sdmode): Remove\n+\tMISALIGNED_INDIRECT_REF handling.\n+\n 2010-09-06  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/45534"}, {"sha": "7f5547175017a0130dece210abaeb85f1f54e242", "filename": "gcc/builtins.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=be1ac4ecae4317082e9a45c86f3b90e0e429e78f", "patch": "@@ -301,11 +301,6 @@ get_object_alignment (tree exp, unsigned int max_align)\n     align = TYPE_ALIGN (TREE_TYPE (exp));\n   else if (TREE_CODE (exp) == INDIRECT_REF)\n     align = TYPE_ALIGN (TREE_TYPE (exp));\n-  else if (TREE_CODE (exp) == MISALIGNED_INDIRECT_REF)\n-    {\n-      tree op1 = TREE_OPERAND (exp, 1);\n-      align = integer_zerop (op1) ? BITS_PER_UNIT : TREE_INT_CST_LOW (op1);\n-    }\n   else if (TREE_CODE (exp) == MEM_REF)\n     {\n       tree addr = TREE_OPERAND (exp, 0);"}, {"sha": "4ae541dd2bc0faf83708166c5bb2eae605710d29", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=be1ac4ecae4317082e9a45c86f3b90e0e429e78f", "patch": "@@ -2450,7 +2450,6 @@ expand_debug_expr (tree exp)\n \treturn NULL;\n       /* Fallthru.  */\n     case INDIRECT_REF:\n-    case MISALIGNED_INDIRECT_REF:\n       op0 = expand_debug_expr (TREE_OPERAND (exp, 0));\n       if (!op0)\n \treturn NULL;"}, {"sha": "67fa9bab17e74fcb4fb2d96cf212afee5ad458ec", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=be1ac4ecae4317082e9a45c86f3b90e0e429e78f", "patch": "@@ -14138,7 +14138,6 @@ rs6000_check_sdmode (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n     case SSA_NAME:\n     case REAL_CST:\n     case MEM_REF:\n-    case MISALIGNED_INDIRECT_REF:\n     case VIEW_CONVERT_EXPR:\n       if (TYPE_MODE (TREE_TYPE (*tp)) == SDmode)\n \treturn *tp;"}, {"sha": "237d089ea1d14b108871209e18005d9306e0dddf", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=be1ac4ecae4317082e9a45c86f3b90e0e429e78f", "patch": "@@ -15230,7 +15230,6 @@ loc_list_from_tree (tree loc, int want_address)\n \treturn 0;\n       /* Fallthru.  */\n     case INDIRECT_REF:\n-    case MISALIGNED_INDIRECT_REF:\n       list_ret = loc_list_from_tree (TREE_OPERAND (loc, 0), 0);\n       have_address = 1;\n       break;"}, {"sha": "e0e1550948f2388c062afdec97241cdfff470c86", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=be1ac4ecae4317082e9a45c86f3b90e0e429e78f", "patch": "@@ -1620,15 +1620,6 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n        type in all cases.  */\n     align = MAX (align, TYPE_ALIGN (type));\n \n-  else if (TREE_CODE (t) == MISALIGNED_INDIRECT_REF)\n-    {\n-      if (integer_zerop (TREE_OPERAND (t, 1)))\n-\t/* We don't know anything about the alignment.  */\n-\talign = BITS_PER_UNIT;\n-      else\n-\talign = tree_low_cst (TREE_OPERAND (t, 1), 1);\n-    }\n-\n   /* If the size is known, we can set that.  */\n   if (TYPE_SIZE_UNIT (type) && host_integerp (TYPE_SIZE_UNIT (type), 1))\n     size = GEN_INT (tree_low_cst (TYPE_SIZE_UNIT (type), 1));\n@@ -1782,8 +1773,7 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t    }\n \n \t  /* If this is an indirect reference, record it.  */\n-\t  else if (TREE_CODE (t) == MEM_REF \n-\t\t   || TREE_CODE (t) == MISALIGNED_INDIRECT_REF)\n+\t  else if (TREE_CODE (t) == MEM_REF)\n \t    {\n \t      expr = t;\n \t      offset = const0_rtx;\n@@ -1793,8 +1783,7 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \n       /* If this is an indirect reference, record it.  */\n       else if (TREE_CODE (t) == MEM_REF \n-\t       || TREE_CODE (t) == TARGET_MEM_REF\n-\t       || TREE_CODE (t) == MISALIGNED_INDIRECT_REF)\n+\t       || TREE_CODE (t) == TARGET_MEM_REF)\n \t{\n \t  expr = t;\n \t  offset = const0_rtx;"}, {"sha": "b1e87d130f9c85d7b04e38f2ff9c13cfacbe1ac0", "filename": "gcc/expr.c", "status": "modified", "additions": 107, "deletions": 86, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=be1ac4ecae4317082e9a45c86f3b90e0e429e78f", "patch": "@@ -4151,6 +4151,8 @@ expand_assignment (tree to, tree from, bool nontemporal)\n {\n   rtx to_rtx = 0;\n   rtx result;\n+  enum machine_mode mode;\n+  int align, icode;\n \n   /* Don't crash if the lhs of the assignment was erroneous.  */\n   if (TREE_CODE (to) == ERROR_MARK)\n@@ -4163,6 +4165,68 @@ expand_assignment (tree to, tree from, bool nontemporal)\n   if (operand_equal_p (to, from, 0))\n     return;\n \n+  mode = TYPE_MODE (TREE_TYPE (to));\n+  if ((TREE_CODE (to) == MEM_REF\n+       || TREE_CODE (to) == TARGET_MEM_REF)\n+      && mode != BLKmode\n+      && ((align = MAX (TYPE_ALIGN (TREE_TYPE (to)),\n+\t\t\tget_object_alignment (to, BIGGEST_ALIGNMENT)))\n+\t  < (signed) GET_MODE_ALIGNMENT (mode))\n+      && ((icode = optab_handler (movmisalign_optab, mode))\n+\t  != CODE_FOR_nothing))\n+    {\n+      enum machine_mode address_mode, op_mode1;\n+      rtx insn, reg, op0, mem;\n+\n+      reg = expand_expr (from, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n+      reg = force_not_mem (reg);\n+\n+      if (TREE_CODE (to) == MEM_REF)\n+\t{\n+\t  addr_space_t as\n+\t      = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (TREE_OPERAND (to, 1))));\n+\t  tree base = TREE_OPERAND (to, 0);\n+\t  address_mode = targetm.addr_space.address_mode (as);\n+\t  op0 = expand_expr (base, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n+\t  op0 = convert_memory_address_addr_space (address_mode, op0, as);\n+\t  if (!integer_zerop (TREE_OPERAND (to, 1)))\n+\t    {\n+\t      rtx off\n+\t\t  = immed_double_int_const (mem_ref_offset (to), address_mode);\n+\t      op0 = simplify_gen_binary (PLUS, address_mode, op0, off);\n+\t    }\n+\t  op0 = memory_address_addr_space (mode, op0, as);\n+\t  mem = gen_rtx_MEM (mode, op0);\n+\t  set_mem_attributes (mem, to, 0);\n+\t  set_mem_addr_space (mem, as);\n+\t}\n+      else if (TREE_CODE (to) == TARGET_MEM_REF)\n+\t{\n+\t  addr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (to));\n+\t  struct mem_address addr;\n+\n+\t  get_address_description (to, &addr);\n+\t  op0 = addr_for_mem_ref (&addr, as, true);\n+\t  op0 = memory_address_addr_space (mode, op0, as);\n+\t  mem = gen_rtx_MEM (mode, op0);\n+\t  set_mem_attributes (mem, to, 0);\n+\t  set_mem_addr_space (mem, as);\n+\t}\n+      else\n+\tgcc_unreachable ();\n+      if (TREE_THIS_VOLATILE (to))\n+\tMEM_VOLATILE_P (mem) = 1;\n+\n+      op_mode1 = insn_data[icode].operand[1].mode;\n+      if (! (*insn_data[icode].operand[1].predicate) (reg, op_mode1)\n+\t  && op_mode1 != VOIDmode)\n+\treg = copy_to_mode_reg (op_mode1, reg);\n+\n+      insn = GEN_FCN (icode) (mem, reg);\n+      emit_insn (insn);\n+      return;\n+    }\n+\n   /* Assignment of a structure component needs special treatment\n      if the structure component's rtx is not simply a MEM.\n      Assignment of an array element at a constant index, and assignment of\n@@ -4297,41 +4361,6 @@ expand_assignment (tree to, tree from, bool nontemporal)\n       return;\n     }\n \n-   else if (TREE_CODE (to) == MISALIGNED_INDIRECT_REF)\n-     {\n-       addr_space_t as = ADDR_SPACE_GENERIC;\n-       enum machine_mode mode, op_mode1;\n-       enum insn_code icode;\n-       rtx reg, addr, mem, insn;\n-\n-       if (POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (to, 0))))\n-\t as = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (TREE_OPERAND (to, 0))));\n-\n-       reg = expand_expr (from, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-       reg = force_not_mem (reg);\n-\n-       mode = TYPE_MODE (TREE_TYPE (to));\n-       addr = expand_expr (TREE_OPERAND (to, 0), NULL_RTX, VOIDmode,\n-                         EXPAND_SUM);\n-       addr = memory_address_addr_space (mode, addr, as);\n-       mem = gen_rtx_MEM (mode, addr);\n-\n-       set_mem_attributes (mem, to, 0);\n-       set_mem_addr_space (mem, as);\n-\n-       icode = optab_handler (movmisalign_optab, mode);\n-       gcc_assert (icode != CODE_FOR_nothing);\n-\n-       op_mode1 = insn_data[icode].operand[1].mode;\n-       if (! (*insn_data[icode].operand[1].predicate) (reg, op_mode1)\n-           && op_mode1 != VOIDmode)\n-         reg = copy_to_mode_reg (op_mode1, reg);\n-\n-      insn = GEN_FCN (icode) (mem, reg);\n-       emit_insn (insn);\n-       return;\n-     }\n-\n   /* If the rhs is a function call and its value is not an aggregate,\n      call the function before we start to compute the lhs.\n      This is needed for correct code for cases such as\n@@ -6659,8 +6688,7 @@ safe_from_p (const_rtx x, tree exp, int top_p)\n \t    }\n \t  break;\n \n-\tcase MISALIGNED_INDIRECT_REF:\n-\tcase INDIRECT_REF:\n+\tcase MEM_REF:\n \t  if (MEM_P (x)\n \t      && alias_sets_conflict_p (MEM_ALIAS_SET (x),\n \t\t\t\t\tget_alias_set (exp)))\n@@ -8598,46 +8626,29 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n       return expand_constructor (exp, target, modifier, false);\n \n-    case MISALIGNED_INDIRECT_REF:\n-    case INDIRECT_REF:\n+    case TARGET_MEM_REF:\n       {\n-\ttree exp1 = treeop0;\n-\taddr_space_t as = ADDR_SPACE_GENERIC;\n-\n-\tif (modifier != EXPAND_WRITE)\n-\t  {\n-\t    tree t;\n-\n-\t    t = fold_read_from_constant_string (exp);\n-\t    if (t)\n-\t      return expand_expr (t, target, tmode, modifier);\n-\t  }\n-\n-\tif (POINTER_TYPE_P (TREE_TYPE (exp1)))\n-\t  as = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (exp1)));\n+\taddr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (exp));\n+\tstruct mem_address addr;\n+\tint icode, align;\n \n-\top0 = expand_expr (exp1, NULL_RTX, VOIDmode, EXPAND_SUM);\n+\tget_address_description (exp, &addr);\n+\top0 = addr_for_mem_ref (&addr, as, true);\n \top0 = memory_address_addr_space (mode, op0, as);\n-\n \ttemp = gen_rtx_MEM (mode, op0);\n-\n \tset_mem_attributes (temp, exp, 0);\n \tset_mem_addr_space (temp, as);\n-\n-\t/* Resolve the misalignment now, so that we don't have to remember\n-\t   to resolve it later.  Of course, this only works for reads.  */\n-\tif (code == MISALIGNED_INDIRECT_REF)\n+\talign = MAX (TYPE_ALIGN (TREE_TYPE (exp)),\n+\t\t     get_object_alignment (exp, BIGGEST_ALIGNMENT));\n+\tif (mode != BLKmode\n+\t    && (unsigned) align < GET_MODE_ALIGNMENT (mode)\n+\t    /* If the target does not have special handling for unaligned\n+\t       loads of mode then it can use regular moves for them.  */\n+\t    && ((icode = optab_handler (movmisalign_optab, mode))\n+\t\t!= CODE_FOR_nothing))\n \t  {\n-\t    int icode;\n \t    rtx reg, insn;\n \n-\t    gcc_assert (modifier == EXPAND_NORMAL\n-\t\t\t|| modifier == EXPAND_STACK_PARM);\n-\n-\t    /* The vectorizer should have already checked the mode.  */\n-\t    icode = optab_handler (movmisalign_optab, mode);\n-\t    gcc_assert (icode != CODE_FOR_nothing);\n-\n \t    /* We've already validated the memory, and we're creating a\n \t       new pseudo destination.  The predicates really can't fail.  */\n \t    reg = gen_reg_rtx (mode);\n@@ -8648,31 +8659,17 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n \t    return reg;\n \t  }\n-\n \treturn temp;\n       }\n \n-    case TARGET_MEM_REF:\n-      {\n-\taddr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (exp));\n-\tstruct mem_address addr;\n-\n-\tget_address_description (exp, &addr);\n-\top0 = addr_for_mem_ref (&addr, as, true);\n-\top0 = memory_address_addr_space (mode, op0, as);\n-\ttemp = gen_rtx_MEM (mode, op0);\n-\tset_mem_attributes (temp, exp, 0);\n-\tset_mem_addr_space (temp, as);\n-      }\n-      return temp;\n-\n     case MEM_REF:\n       {\n \taddr_space_t as\n \t  = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (TREE_OPERAND (exp, 1))));\n \tenum machine_mode address_mode;\n \ttree base = TREE_OPERAND (exp, 0);\n \tgimple def_stmt;\n+\tint icode, align;\n \t/* Handle expansion of non-aliased memory with non-BLKmode.  That\n \t   might end up in a register.  */\n \tif (TREE_CODE (base) == ADDR_EXPR)\n@@ -8717,9 +8714,14 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \taddress_mode = targetm.addr_space.address_mode (as);\n \tbase = TREE_OPERAND (exp, 0);\n \tif ((def_stmt = get_def_for_expr (base, BIT_AND_EXPR)))\n-\t  base = build2 (BIT_AND_EXPR, TREE_TYPE (base),\n-\t\t\t gimple_assign_rhs1 (def_stmt),\n-\t\t\t gimple_assign_rhs2 (def_stmt));\n+\t  {\n+\t    tree mask = gimple_assign_rhs2 (def_stmt);\n+\t    base = build2 (BIT_AND_EXPR, TREE_TYPE (base),\n+\t\t\t   gimple_assign_rhs1 (def_stmt), mask);\n+\t    TREE_OPERAND (exp, 0) = base;\n+\t  }\n+\talign = MAX (TYPE_ALIGN (TREE_TYPE (exp)),\n+\t\t     get_object_alignment (exp, BIGGEST_ALIGNMENT));\n \top0 = expand_expr (base, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n \top0 = convert_memory_address_addr_space (address_mode, op0, as);\n \tif (!integer_zerop (TREE_OPERAND (exp, 1)))\n@@ -8734,6 +8736,25 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \tset_mem_addr_space (temp, as);\n \tif (TREE_THIS_VOLATILE (exp))\n \t  MEM_VOLATILE_P (temp) = 1;\n+\tif (mode != BLKmode\n+\t    && (unsigned) align < GET_MODE_ALIGNMENT (mode)\n+\t    /* If the target does not have special handling for unaligned\n+\t       loads of mode then it can use regular moves for them.  */\n+\t    && ((icode = optab_handler (movmisalign_optab, mode))\n+\t\t!= CODE_FOR_nothing))\n+\t  {\n+\t    rtx reg, insn;\n+\n+\t    /* We've already validated the memory, and we're creating a\n+\t       new pseudo destination.  The predicates really can't fail.  */\n+\t    reg = gen_reg_rtx (mode);\n+\n+\t    /* Nor can the insn generator.  */\n+\t    insn = GEN_FCN (icode) (reg, temp);\n+\t    emit_insn (insn);\n+\n+\t    return reg;\n+\t  }\n \treturn temp;\n       }\n "}, {"sha": "baac13f756a84001a0fde2038f33fef8539d9414", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=be1ac4ecae4317082e9a45c86f3b90e0e429e78f", "patch": "@@ -2044,7 +2044,6 @@ maybe_lvalue_p (const_tree x)\n   case COMPONENT_REF:\n   case MEM_REF:\n   case INDIRECT_REF:\n-  case MISALIGNED_INDIRECT_REF:\n   case ARRAY_REF:\n   case ARRAY_RANGE_REF:\n   case BIT_FIELD_REF:\n@@ -2587,7 +2586,6 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n       switch (TREE_CODE (arg0))\n \t{\n \tcase INDIRECT_REF:\n-\tcase MISALIGNED_INDIRECT_REF:\n \tcase REALPART_EXPR:\n \tcase IMAGPART_EXPR:\n \t  return OP_SAME (0);\n@@ -7597,8 +7595,7 @@ build_fold_addr_expr_with_type_loc (location_t loc, tree t, tree ptrtype)\n   if (TREE_CODE (t) == WITH_SIZE_EXPR)\n     t = TREE_OPERAND (t, 0);\n \n-  if (TREE_CODE (t) == INDIRECT_REF\n-      || TREE_CODE (t) == MISALIGNED_INDIRECT_REF)\n+  if (TREE_CODE (t) == INDIRECT_REF)\n     {\n       t = TREE_OPERAND (t, 0);\n "}, {"sha": "595316043c5952edbb8e61ae6e496b3bea42c2e1", "filename": "gcc/gimplify.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=be1ac4ecae4317082e9a45c86f3b90e0e429e78f", "patch": "@@ -4791,7 +4791,6 @@ gimplify_addr_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n   switch (TREE_CODE (op0))\n     {\n     case INDIRECT_REF:\n-    case MISALIGNED_INDIRECT_REF:\n     do_indirect_ref:\n       /* Check if we are dealing with an expression of the form '&*ptr'.\n \t While the front end folds away '&*ptr' into 'ptr', these\n@@ -6784,14 +6783,6 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t  recalculate_side_effects (*expr_p);\n \t  break;\n \n-\tcase MISALIGNED_INDIRECT_REF:\n-\t  /* We can only reach this through re-gimplification from\n-\t     tree optimizers.  */\n-\t  ret = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, post_p,\n-\t\t\t       is_gimple_reg, fb_rvalue);\n-\t  recalculate_side_effects (*expr_p);\n-\t  break;\n-\n \tcase INDIRECT_REF:\n \t  {\n \t    bool volatilep = TREE_THIS_VOLATILE (*expr_p);"}, {"sha": "7151fa71b11fd2066d59f4540d89534ae51b23a8", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=be1ac4ecae4317082e9a45c86f3b90e0e429e78f", "patch": "@@ -2852,8 +2852,7 @@ verify_types_in_gimple_min_lval (tree expr)\n   if (is_gimple_id (expr))\n     return false;\n \n-  if (TREE_CODE (expr) != MISALIGNED_INDIRECT_REF\n-      && TREE_CODE (expr) != TARGET_MEM_REF\n+  if (TREE_CODE (expr) != TARGET_MEM_REF\n       && TREE_CODE (expr) != MEM_REF)\n     {\n       error (\"invalid expression for min lvalue\");\n@@ -3723,7 +3722,6 @@ verify_gimple_assign_single (gimple stmt)\n \n     case COMPONENT_REF:\n     case BIT_FIELD_REF:\n-    case MISALIGNED_INDIRECT_REF:\n     case ARRAY_REF:\n     case ARRAY_RANGE_REF:\n     case VIEW_CONVERT_EXPR:"}, {"sha": "beac4410fdb89649e2fffb5634faac10a24b16d2", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=be1ac4ecae4317082e9a45c86f3b90e0e429e78f", "patch": "@@ -572,7 +572,6 @@ dequeue_and_dump (dump_info_p di)\n     case TRUTH_NOT_EXPR:\n     case ADDR_EXPR:\n     case INDIRECT_REF:\n-    case MISALIGNED_INDIRECT_REF:\n     case CLEANUP_POINT_EXPR:\n     case SAVE_EXPR:\n     case REALPART_EXPR:"}, {"sha": "66fee8e2e8cb76745ebb9721631562c7776b2813", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=be1ac4ecae4317082e9a45c86f3b90e0e429e78f", "patch": "@@ -2440,7 +2440,6 @@ tree_could_trap_p (tree expr)\n \treturn false;\n       /* Fallthru.  */\n     case INDIRECT_REF:\n-    case MISALIGNED_INDIRECT_REF:\n       return !TREE_THIS_NOTRAP (expr);\n \n     case ASM_EXPR:"}, {"sha": "b90f5ce8fa0979baa94d2e854ca8fde6c4293d8a", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=be1ac4ecae4317082e9a45c86f3b90e0e429e78f", "patch": "@@ -1348,11 +1348,8 @@ ref_at_iteration (struct loop *loop, tree ref, int iter)\n \t   && TREE_CODE (ref) != MEM_REF)\n     return unshare_expr (ref);\n \n-  if (INDIRECT_REF_P (ref)\n-      || TREE_CODE (ref) == MEM_REF)\n+  if (TREE_CODE (ref) == MEM_REF)\n     {\n-      /* Take care for MEM_REF and MISALIGNED_INDIRECT_REF at\n-         the same time.  */\n       ret = unshare_expr (ref);\n       idx = TREE_OPERAND (ref, 0);\n       idx_p = &TREE_OPERAND (ret, 0);"}, {"sha": "7a0a3b50189de405b98603e797accd85f227fe3e", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=be1ac4ecae4317082e9a45c86f3b90e0e429e78f", "patch": "@@ -1592,7 +1592,6 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n     case ADDR_EXPR:\n     case PREDECREMENT_EXPR:\n     case PREINCREMENT_EXPR:\n-    case MISALIGNED_INDIRECT_REF:\n     case INDIRECT_REF:\n       if (TREE_CODE (node) == ADDR_EXPR\n \t  && (TREE_CODE (TREE_OPERAND (node, 0)) == STRING_CST\n@@ -1609,13 +1608,6 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \t}\n       else\n \tdump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n-\n-      if (TREE_CODE (node) == MISALIGNED_INDIRECT_REF)\n-        {\n-          pp_string (buffer, \"{misalignment: \");\n-          dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n-          pp_character (buffer, '}');\n-        }\n       break;\n \n     case POSTDECREMENT_EXPR:\n@@ -2554,7 +2546,6 @@ op_code_prio (enum tree_code code)\n     case PREINCREMENT_EXPR:\n     case PREDECREMENT_EXPR:\n     case NEGATE_EXPR:\n-    case MISALIGNED_INDIRECT_REF:\n     case INDIRECT_REF:\n     case ADDR_EXPR:\n     case FLOAT_EXPR:\n@@ -2724,9 +2715,6 @@ op_symbol_code (enum tree_code code)\n     case INDIRECT_REF:\n       return \"*\";\n \n-    case MISALIGNED_INDIRECT_REF:\n-      return \"M*\";\n-\n     case TRUNC_DIV_EXPR:\n     case RDIV_EXPR:\n       return \"/\";"}, {"sha": "fc3f1586b167ef93395db09524ce6f53f5f4cb59", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=be1ac4ecae4317082e9a45c86f3b90e0e429e78f", "patch": "@@ -509,9 +509,7 @@ get_value_from_alignment (tree expr)\n   base = get_inner_reference (TREE_OPERAND (expr, 0),\n \t\t\t      &bitsize, &bitpos, &offset,\n \t\t\t      &mode, &align, &align, false);\n-  if (TREE_CODE (base) == MISALIGNED_INDIRECT_REF)\n-    val = get_value_for_expr (TREE_OPERAND (base, 0), true);\n-  else if (TREE_CODE (base) == MEM_REF)\n+  if (TREE_CODE (base) == MEM_REF)\n     val = bit_value_binop (PLUS_EXPR, TREE_TYPE (expr),\n \t\t\t   TREE_OPERAND (base, 0), TREE_OPERAND (base, 1));\n   else if (base"}, {"sha": "1894572000e34b96bc442cd41dba3ea5e74637f0", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=be1ac4ecae4317082e9a45c86f3b90e0e429e78f", "patch": "@@ -272,7 +272,6 @@ for_each_index (tree *addr_p, bool (*cbck) (tree, tree *, void *), void *data)\n \tcase SSA_NAME:\n \t  return cbck (*addr_p, addr_p, data);\n \n-\tcase MISALIGNED_INDIRECT_REF:\n \tcase MEM_REF:\n \t  nxt = &TREE_OPERAND (*addr_p, 0);\n \t  return cbck (*addr_p, nxt, data);\n@@ -1986,7 +1985,6 @@ gen_lsm_tmp_name (tree ref)\n \n   switch (TREE_CODE (ref))\n     {\n-    case MISALIGNED_INDIRECT_REF:\n     case MEM_REF:\n       gen_lsm_tmp_name (TREE_OPERAND (ref, 0));\n       lsm_tmp_name_add (\"_\");"}, {"sha": "a2abc81fcea43fa6ad2ff114fc3724c10aae0cae", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=be1ac4ecae4317082e9a45c86f3b90e0e429e78f", "patch": "@@ -1443,9 +1443,6 @@ idx_find_step (tree base, tree *idx, void *data)\n   tree step, iv_base, iv_step, lbound, off;\n   struct loop *loop = dta->ivopts_data->current_loop;\n \n-  if (TREE_CODE (base) == MISALIGNED_INDIRECT_REF)\n-    return false;\n-\n   /* If base is a component ref, require that the offset of the reference\n      be invariant.  */\n   if (TREE_CODE (base) == COMPONENT_REF)\n@@ -1765,8 +1762,6 @@ find_interesting_uses_address (struct ivopts_data *data, gimple stmt, tree *op_p\n \tgoto fail;\n       step = ifs_ivopts_data.step;\n \n-      gcc_assert (TREE_CODE (base) != MISALIGNED_INDIRECT_REF);\n-\n       /* Check that the base expression is addressable.  This needs\n \t to be done after substituting bases of IVs into it.  */\n       if (may_be_nonaddressable_p (base))"}, {"sha": "3fd834cf998212b723f52283bf6bcba566cf315f", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=be1ac4ecae4317082e9a45c86f3b90e0e429e78f", "patch": "@@ -423,9 +423,6 @@ idx_analyze_ref (tree base, tree *index, void *data)\n   HOST_WIDE_INT idelta = 0, imult = 1;\n   affine_iv iv;\n \n-  if (TREE_CODE (base) == MISALIGNED_INDIRECT_REF)\n-    return false;\n-\n   if (!simple_iv (ar_data->loop, loop_containing_stmt (ar_data->stmt),\n \t\t  *index, &iv, true))\n     return false;"}, {"sha": "4256af07c351724d562f7294473872aacae4b237", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=be1ac4ecae4317082e9a45c86f3b90e0e429e78f", "patch": "@@ -711,8 +711,7 @@ mark_address_taken (tree ref)\n }\n \n \n-/* A subroutine of get_expr_operands to handle MEM_REF,\n-   MISALIGNED_INDIRECT_REF.\n+/* A subroutine of get_expr_operands to handle MEM_REF.\n \n    STMT is the statement being processed, EXPR is the MEM_REF\n       that got us here.\n@@ -908,10 +907,6 @@ get_expr_operands (gimple stmt, tree *expr_p, int flags)\n       gcc_assert (gimple_debug_bind_p (stmt));\n       return;\n \n-    case MISALIGNED_INDIRECT_REF:\n-      get_expr_operands (stmt, &TREE_OPERAND (expr, 1), flags);\n-      /* fall through */\n-\n     case MEM_REF:\n       get_indirect_ref_operands (stmt, expr, flags, true);\n       return;"}, {"sha": "41d0542e013fd9d0376efeb58feee70658dbc5fd", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=be1ac4ecae4317082e9a45c86f3b90e0e429e78f", "patch": "@@ -2822,26 +2822,6 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n \treturn folded;\n       }\n       break;\n-    case MISALIGNED_INDIRECT_REF:\n-      {\n-\ttree folded;\n-\ttree genop1 = create_component_ref_by_pieces_1 (block, ref,\n-\t\t\t\t\t\t\toperand,\n-\t\t\t\t\t\t\tstmts, domstmt);\n-\tif (!genop1)\n-\t  return NULL_TREE;\n-\tgenop1 = fold_convert (build_pointer_type (currop->type),\n-\t\t\t       genop1);\n-\n-\tif (currop->opcode == MISALIGNED_INDIRECT_REF)\n-\t  folded = fold_build2 (currop->opcode, currop->type,\n-\t\t\t\tgenop1, currop->op1);\n-\telse\n-\t  folded = fold_build1 (currop->opcode, currop->type,\n-\t\t\t\tgenop1);\n-\treturn folded;\n-      }\n-      break;\n     case BIT_FIELD_REF:\n       {\n \ttree folded;"}, {"sha": "b055a43e56eb94f1efa2d73ffd9efc18578197f8", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=be1ac4ecae4317082e9a45c86f3b90e0e429e78f", "patch": "@@ -616,9 +616,6 @@ copy_reference_ops_from_ref (tree ref, VEC(vn_reference_op_s, heap) **result)\n \n       switch (temp.opcode)\n \t{\n-\tcase MISALIGNED_INDIRECT_REF:\n-\t  temp.op0 = TREE_OPERAND (ref, 1);\n-\t  break;\n \tcase MEM_REF:\n \t  /* The base address gets its own vn_reference_op_s structure.  */\n \t  temp.op0 = TREE_OPERAND (ref, 1);\n@@ -801,12 +798,6 @@ ao_ref_init_from_vn_reference (ao_ref *ref,\n \t  return false;\n \n \t/* Record the base objects.  */\n-\tcase MISALIGNED_INDIRECT_REF:\n-\t  *op0_p = build2 (MISALIGNED_INDIRECT_REF, op->type,\n-\t\t\t   NULL_TREE, op->op0);\n-\t  op0_p = &TREE_OPERAND (*op0_p, 0);\n-\t  break;\n-\n \tcase MEM_REF:\n \t  base_alias_set = get_deref_alias_set (op->op0);\n \t  *op0_p = build2 (MEM_REF, op->type,"}, {"sha": "7b6e281da41deb4cf0d15fc4834133b4b3b5b6ba", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 50, "deletions": 23, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=be1ac4ecae4317082e9a45c86f3b90e0e429e78f", "patch": "@@ -3347,6 +3347,8 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       next_stmt = first_stmt;\n       for (i = 0; i < vec_num; i++)\n \t{\n+\t  struct ptr_info_def *pi;\n+\n \t  if (i > 0)\n \t    /* Bump the vector pointer.  */\n \t    dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, gsi, stmt,\n@@ -3359,18 +3361,28 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t       vect_permute_store_chain().  */\n \t    vec_oprnd = VEC_index (tree, result_chain, i);\n \n+\t  data_ref = build2 (MEM_REF, TREE_TYPE (vec_oprnd), dataref_ptr,\n+\t\t\t     build_int_cst (reference_alias_ptr_type\n+\t\t\t\t\t    (DR_REF (first_dr)), 0));\n+\t  pi = get_ptr_info (dataref_ptr);\n+\t  pi->align = TYPE_ALIGN_UNIT (vectype);\n           if (aligned_access_p (first_dr))\n-\t    data_ref\n-\t      = build2 (MEM_REF, TREE_TYPE (vec_oprnd), dataref_ptr,\n-\t\t\tbuild_int_cst (reference_alias_ptr_type\n-\t\t\t\t         (DR_REF (first_dr)), 0));\n-          else\n-          {\n-            int mis = DR_MISALIGNMENT (first_dr);\n-            tree tmis = (mis == -1 ? size_zero_node : size_int (mis));\n-            tmis = size_binop (MULT_EXPR, tmis, size_int (BITS_PER_UNIT));\n-            data_ref = build2 (MISALIGNED_INDIRECT_REF, vectype, dataref_ptr, tmis);\n-           }\n+\t    pi->misalign = 0;\n+          else if (DR_MISALIGNMENT (first_dr) == -1)\n+\t    {\n+\t      TREE_TYPE (data_ref)\n+\t\t= build_aligned_type (TREE_TYPE (data_ref),\n+\t\t\t\t      TYPE_ALIGN (TREE_TYPE (vectype)));\n+\t      pi->align = TYPE_ALIGN_UNIT (TREE_TYPE (vectype));\n+\t      pi->misalign = 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      TREE_TYPE (data_ref)\n+\t\t= build_aligned_type (TREE_TYPE (data_ref),\n+\t\t\t\t      TYPE_ALIGN (TREE_TYPE (vectype)));\n+\t      pi->misalign = DR_MISALIGNMENT (first_dr);\n+\t    }\n \n \t  /* Arguments are ready. Create the new vector stmt.  */\n \t  new_stmt = gimple_build_assign (data_ref, vec_oprnd);\n@@ -3735,20 +3747,35 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t  switch (alignment_support_scheme)\n \t    {\n \t    case dr_aligned:\n-\t      gcc_assert (aligned_access_p (first_dr));\n-\t      data_ref\n-\t\t= build2 (MEM_REF, vectype, dataref_ptr,\n-\t\t\t  build_int_cst (reference_alias_ptr_type\n-\t\t\t\t\t   (DR_REF (first_dr)), 0));\n-\t      break;\n \t    case dr_unaligned_supported:\n \t      {\n-\t\tint mis = DR_MISALIGNMENT (first_dr);\n-\t\ttree tmis = (mis == -1 ? size_zero_node : size_int (mis));\n-\n-\t\ttmis = size_binop (MULT_EXPR, tmis, size_int(BITS_PER_UNIT));\n-\t\tdata_ref =\n-\t\t  build2 (MISALIGNED_INDIRECT_REF, vectype, dataref_ptr, tmis);\n+\t\tstruct ptr_info_def *pi;\n+\t\tdata_ref\n+\t\t  = build2 (MEM_REF, vectype, dataref_ptr,\n+\t\t\t    build_int_cst (reference_alias_ptr_type\n+\t\t\t\t\t   (DR_REF (first_dr)), 0));\n+\t\tpi = get_ptr_info (dataref_ptr);\n+\t\tpi->align = TYPE_ALIGN_UNIT (vectype);\n+\t\tif (alignment_support_scheme == dr_aligned)\n+\t\t  {\n+\t\t    gcc_assert (aligned_access_p (first_dr));\n+\t\t    pi->misalign = 0;\n+\t\t  }\n+\t\telse if (DR_MISALIGNMENT (first_dr) == -1)\n+\t\t  {\n+\t\t    TREE_TYPE (data_ref)\n+\t\t      = build_aligned_type (TREE_TYPE (data_ref),\n+\t\t\t\t\t    TYPE_ALIGN (TREE_TYPE (vectype)));\n+\t\t    pi->align = TYPE_ALIGN_UNIT (TREE_TYPE (vectype));\n+\t\t    pi->misalign = 0;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    TREE_TYPE (data_ref)\n+\t\t      = build_aligned_type (TREE_TYPE (data_ref),\n+\t\t\t\t\t    TYPE_ALIGN (TREE_TYPE (vectype)));\n+\t\t    pi->misalign = DR_MISALIGNMENT (first_dr);\n+\t\t  }\n \t\tbreak;\n \t      }\n \t    case dr_explicit_realign:"}, {"sha": "d696e96b56438ea128d99d99cee72c556676ed63", "filename": "gcc/tree.c", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=be1ac4ecae4317082e9a45c86f3b90e0e429e78f", "patch": "@@ -2434,7 +2434,6 @@ staticp (tree arg)\n     case BIT_FIELD_REF:\n       return NULL;\n \n-    case MISALIGNED_INDIRECT_REF:\n     case INDIRECT_REF:\n       return TREE_CONSTANT (TREE_OPERAND (arg, 0)) ? arg : NULL;\n \n@@ -3660,7 +3659,6 @@ build1_stat (enum tree_code code, tree type, tree node MEM_STAT_DECL)\n       TREE_READONLY (t) = 0;\n       break;\n \n-    case MISALIGNED_INDIRECT_REF:\n     case INDIRECT_REF:\n       /* Whether a dereference is readonly has nothing to do with whether\n \t its operand is readonly.  */\n@@ -3929,8 +3927,6 @@ reference_alias_ptr_type (const_tree t)\n     return TREE_TYPE (TREE_OPERAND (base, 1));\n   else if (TREE_CODE (base) == TARGET_MEM_REF)\n     return TREE_TYPE (TMR_OFFSET (base)); \n-  else if (TREE_CODE (base) == MISALIGNED_INDIRECT_REF)\n-    return NULL_TREE;\n   else\n     return build_pointer_type (TYPE_MAIN_VARIANT (TREE_TYPE (base)));\n }\n@@ -5552,6 +5548,23 @@ check_qualified_type (const_tree cand, const_tree base, int type_quals)\n \t  && TYPE_NAME (cand) == TYPE_NAME (base)\n \t  /* Apparently this is needed for Objective-C.  */\n \t  && TYPE_CONTEXT (cand) == TYPE_CONTEXT (base)\n+\t  /* Check alignment.  */\n+\t  && TYPE_ALIGN (cand) == TYPE_ALIGN (base)\n+\t  && attribute_list_equal (TYPE_ATTRIBUTES (cand),\n+\t\t\t\t   TYPE_ATTRIBUTES (base)));\n+}\n+\n+/* Returns true iff CAND is equivalent to BASE with ALIGN.  */\n+\n+static bool\n+check_aligned_type (const_tree cand, const_tree base, unsigned int align)\n+{\n+  return (TYPE_QUALS (cand) == TYPE_QUALS (base)\n+\t  && TYPE_NAME (cand) == TYPE_NAME (base)\n+\t  /* Apparently this is needed for Objective-C.  */\n+\t  && TYPE_CONTEXT (cand) == TYPE_CONTEXT (base)\n+\t  /* Check alignment.  */\n+\t  && TYPE_ALIGN (cand) == align\n \t  && attribute_list_equal (TYPE_ATTRIBUTES (cand),\n \t\t\t\t   TYPE_ATTRIBUTES (base)));\n }\n@@ -5612,6 +5625,27 @@ build_qualified_type (tree type, int type_quals)\n   return t;\n }\n \n+/* Create a variant of type T with alignment ALIGN.  */\n+\n+tree\n+build_aligned_type (tree type, unsigned int align)\n+{\n+  tree t;\n+\n+  if (TYPE_PACKED (type)\n+      || TYPE_ALIGN (type) == align)\n+    return type;\n+\n+  for (t = TYPE_MAIN_VARIANT (type); t; t = TYPE_NEXT_VARIANT (t))\n+    if (check_aligned_type (t, type, align))\n+      return t;\n+\n+  t = build_variant_type_copy (type);\n+  TYPE_ALIGN (t) = align;\n+\n+  return t;\n+}\n+\n /* Create a new distinct copy of TYPE.  The new type is made its own\n    MAIN_VARIANT. If TYPE requires structural equality checks, the\n    resulting type requires structural equality checks; otherwise, its"}, {"sha": "9343e5e37a7d11ff4a7d19f83adb8fd261be431b", "filename": "gcc/tree.def", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=be1ac4ecae4317082e9a45c86f3b90e0e429e78f", "patch": "@@ -414,20 +414,9 @@ DEFTREECODE (ARRAY_REF, \"array_ref\", tcc_reference, 4)\n    of the range is taken from the type of the expression.  */\n DEFTREECODE (ARRAY_RANGE_REF, \"array_range_ref\", tcc_reference, 4)\n \n-/* The ordering of the following codes is optimized for the checking\n-   macros in tree.h.  Changing the order will degrade the speed of the\n-   compiler.  INDIRECT_REF, MISALIGNED_INDIRECT_REF.  */\n-\n /* C unary `*' or Pascal `^'.  One operand, an expression for a pointer.  */\n DEFTREECODE (INDIRECT_REF, \"indirect_ref\", tcc_reference, 1)\n \n-/* Same as INDIRECT_REF, but also specifies the alignment of the referenced\n-   address:\n-   Operand 0 is the referenced address (a pointer);\n-   Operand 1 is an INTEGER_CST which represents the alignment of the address,\n-   or 0 if the alignment is unknown.  */\n-DEFTREECODE (MISALIGNED_INDIRECT_REF, \"misaligned_indirect_ref\", tcc_reference, 2)\n-\n /* Used to represent lookup in a virtual method table which is dependent on\n    the runtime type of an object.  Operands are:\n    OBJ_TYPE_REF_EXPR: An expression that evaluates the value to use."}, {"sha": "815ba9c11633cd1638ec98ca5c0d1d128e225ebe", "filename": "gcc/tree.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1ac4ecae4317082e9a45c86f3b90e0e429e78f/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=be1ac4ecae4317082e9a45c86f3b90e0e429e78f", "patch": "@@ -117,8 +117,7 @@ extern const enum tree_code_class tree_code_type[];\n    ascending code order.  */\n \n #define INDIRECT_REF_P(CODE)\\\n-  (TREE_CODE (CODE) == INDIRECT_REF \\\n-   || TREE_CODE (CODE) == MISALIGNED_INDIRECT_REF)\n+  (TREE_CODE (CODE) == INDIRECT_REF)\n \n /* Nonzero if CODE represents a reference.  */\n \n@@ -602,7 +601,7 @@ struct GTY(()) tree_common {\n            all types\n \n        TREE_THIS_NOTRAP in\n-          (ALIGN/MISALIGNED_)INDIRECT_REF, ARRAY_REF, ARRAY_RANGE_REF\n+          INDIRECT_REF, ARRAY_REF, ARRAY_RANGE_REF\n \n    deprecated_flag:\n \n@@ -1250,8 +1249,7 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n /* Nonzero means this node will not trap.  In an INDIRECT_REF, means\n    accessing the memory pointed to won't generate a trap.  However,\n    this only applies to an object when used appropriately: it doesn't\n-   mean that writing a READONLY mem won't trap. Similarly for\n-   MISALIGNED_INDIRECT_REF.\n+   mean that writing a READONLY mem won't trap.\n \n    In ARRAY_REF and ARRAY_RANGE_REF means that we know that the index\n    (or slice of the array) always belongs to the range of the array.\n@@ -4306,6 +4304,10 @@ extern tree get_qualified_type (tree, int);\n \n extern tree build_qualified_type (tree, int);\n \n+/* Create a variant of type T with alignment ALIGN.  */\n+\n+extern tree build_aligned_type (tree, unsigned int);\n+\n /* Like build_qualified_type, but only deals with the `const' and\n    `volatile' qualifiers.  This interface is retained for backwards\n    compatibility with the various front-ends; new code should use"}]}