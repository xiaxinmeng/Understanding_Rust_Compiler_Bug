{"sha": "f5b25e15165adde1356af42e9066ab75c5b37a19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjViMjVlMTUxNjVhZGRlMTM1NmFmNDJlOTA2NmFiNzVjNWIzN2ExOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-01-16T22:55:44Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-01-16T22:55:44Z"}, "message": "Make profile estimation more precise\n\nWhile analyzing code size regression in SPEC2k GCC binary I noticed that we\nperform some inline decisions because we think that number of executions are\nvery high.\nIn particular there was inline decision inlining gen_rtx_fmt_ee to find_reloads\nbelieving that it is called 4 billion times.  This turned out to be cummulation\nof roundoff errors in propagate_freq which was bit mechanically updated from\noriginal sreals to C++ sreals and later to new probabilities.\n\nThis led us to estimate that a loopback edge is reached with probability 2.3\nwhich was capped to 1-1/10000 and since this happened in nested loop it quickly\nescalated to large values.\n\nOriginally capping to REG_BR_PROB_BASE avoided such problems but now we have\nmuch higher range.\n\nThis patch avoids going from probabilites to REG_BR_PROB_BASE so precision is\nkept.  In addition it makes the propagation to not estimate more than\nparam-max-predicted-loop-iterations.  The first change makes the cap to not\nbe triggered on the gcc build, but it is still better to be safe than sorry.\n\n\t* ipa-fnsummary.c (estimate_calls_size_and_time): Fix formating of\n\tdump.\n\t* params.opt: (max-predicted-iterations): Set bounds.\n\t* predict.c (real_almost_one, real_br_prob_base,\n\treal_inv_br_prob_base, real_one_half, real_bb_freq_max): Remove.\n\t(propagate_freq): Add max_cyclic_prob parameter; cap cyclic\n\tprobabilities; do not truncate to reg_br_prob_bases.\n\t(estimate_loops_at_level): Pass max_cyclic_prob.\n\t(estimate_loops): Compute max_cyclic_prob.\n\t(estimate_bb_frequencies): Do not initialize real_*; update calculation\n\tof back edge prob.\n\t* profile-count.c (profile_probability::to_sreal): New.\n\t* profile-count.h (class sreal): Move up in file.\n\t(profile_probability::to_sreal): Declare.", "tree": {"sha": "c42ddcfe8702d66b51bde341c1b2d6fc27ec67c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c42ddcfe8702d66b51bde341c1b2d6fc27ec67c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5b25e15165adde1356af42e9066ab75c5b37a19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5b25e15165adde1356af42e9066ab75c5b37a19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5b25e15165adde1356af42e9066ab75c5b37a19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5b25e15165adde1356af42e9066ab75c5b37a19/comments", "author": null, "committer": null, "parents": [{"sha": "801f5b96775288e55193a66a746caab1ddd56f4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/801f5b96775288e55193a66a746caab1ddd56f4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/801f5b96775288e55193a66a746caab1ddd56f4a"}], "stats": {"total": 136, "additions": 76, "deletions": 60}, "files": [{"sha": "907d0f751abeae655d120b1ddf3cb9741b8c2505", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5b25e15165adde1356af42e9066ab75c5b37a19/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5b25e15165adde1356af42e9066ab75c5b37a19/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f5b25e15165adde1356af42e9066ab75c5b37a19", "patch": "@@ -1,3 +1,20 @@\n+2020-01-16  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-fnsummary.c (estimate_calls_size_and_time): Fix formating of\n+\tdump.\n+\t* params.opt: (max-predicted-iterations): Set bounds.\n+\t* predict.c (real_almost_one, real_br_prob_base,\n+\treal_inv_br_prob_base, real_one_half, real_bb_freq_max): Remove.\n+\t(propagate_freq): Add max_cyclic_prob parameter; cap cyclic\n+\tprobabilities; do not truncate to reg_br_prob_bases.\n+\t(estimate_loops_at_level): Pass max_cyclic_prob.\n+\t(estimate_loops): Compute max_cyclic_prob.\n+\t(estimate_bb_frequencies): Do not initialize real_*; update calculation\n+\tof back edge prob.\n+\t* profile-count.c (profile_probability::to_sreal): New.\n+\t* profile-count.h (class sreal): Move up in file.\n+\t(profile_probability::to_sreal): Declare.\n+\n 2020-01-16  Stam Markianos-Wright  <stam.markianos-wright@arm.com>\n \n \t* config/arm/arm.c"}, {"sha": "dbd53f12a405cf1c8a045a2e979311f8411c46b2", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5b25e15165adde1356af42e9066ab75c5b37a19/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5b25e15165adde1356af42e9066ab75c5b37a19/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=f5b25e15165adde1356af42e9066ab75c5b37a19", "patch": "@@ -3258,7 +3258,7 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n \t  gcc_assert (*size == old_size);\n \t  if (time && (*time - old_time > 1 || *time - old_time < -1)\n \t      && dump_file)\n-\t    fprintf (dump_file, \"Time mismatch in call summary %f!=%f\",\n+\t    fprintf (dump_file, \"Time mismatch in call summary %f!=%f\\n\",\n \t\t     old_time.to_double (),\n \t\t     time->to_double ());\n \t}"}, {"sha": "f02c769d0e3541aa1965622081d64445bb451cf1", "filename": "gcc/params.opt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5b25e15165adde1356af42e9066ab75c5b37a19/gcc%2Fparams.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5b25e15165adde1356af42e9066ab75c5b37a19/gcc%2Fparams.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.opt?ref=f5b25e15165adde1356af42e9066ab75c5b37a19", "patch": "@@ -555,7 +555,7 @@ Common Joined UInteger Var(param_max_pow_sqrt_depth) Init(5) IntegerRange(1, 32)\n Maximum depth of sqrt chains to use when synthesizing exponentiation by a real constant.\n \n -param=max-predicted-iterations=\n-Common Joined UInteger Var(param_max_predicted_iterations) Init(100) Param Optimization\n+Common Joined UInteger Var(param_max_predicted_iterations) Init(100) IntegerRange(1, 65536) Param Optimization\n The maximum number of loop iterations we predict statically.\n \n -param=max-reload-search-insns="}, {"sha": "c3aed9ed8543ca353580057cd8b734d59d3166a2", "filename": "gcc/predict.c", "status": "modified", "additions": 45, "deletions": 56, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5b25e15165adde1356af42e9066ab75c5b37a19/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5b25e15165adde1356af42e9066ab75c5b37a19/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=f5b25e15165adde1356af42e9066ab75c5b37a19", "patch": "@@ -76,10 +76,6 @@ enum predictor_reason\n static const char *reason_messages[] = {\"\", \" (ignored)\",\n     \" (single edge duplicate)\", \" (edge pair duplicate)\"};\n \n-/* real constants: 0, 1, 1-1/REG_BR_PROB_BASE, REG_BR_PROB_BASE,\n-\t\t   1/REG_BR_PROB_BASE, 0.5, BB_FREQ_MAX.  */\n-static sreal real_almost_one, real_br_prob_base,\n-\t     real_inv_br_prob_base, real_one_half, real_bb_freq_max;\n \n static void combine_predictions_for_insn (rtx_insn *, basic_block);\n static void dump_prediction (FILE *, enum br_predictor, int, basic_block,\n@@ -3266,7 +3262,8 @@ class edge_prob_info\n    TOVISIT, starting in HEAD.  */\n \n static void\n-propagate_freq (basic_block head, bitmap tovisit)\n+propagate_freq (basic_block head, bitmap tovisit,\n+\t\tsreal max_cyclic_prob)\n {\n   basic_block bb;\n   basic_block last;\n@@ -3322,22 +3319,14 @@ propagate_freq (basic_block head, bitmap tovisit)\n \n \t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t    if (EDGE_INFO (e)->back_edge)\n-\t      {\n-\t\tcyclic_probability += EDGE_INFO (e)->back_edge_prob;\n-\t      }\n+\t      cyclic_probability += EDGE_INFO (e)->back_edge_prob;\n \t    else if (!(e->flags & EDGE_DFS_BACK))\n \t      {\n-\t\t/*  frequency += (e->probability\n-\t\t\t\t  * BLOCK_INFO (e->src)->frequency /\n-\t\t\t\t  REG_BR_PROB_BASE);  */\n-\n \t\t/* FIXME: Graphite is producing edges with no profile. Once\n \t\t   this is fixed, drop this.  */\n \t\tsreal tmp = e->probability.initialized_p () ?\n-\t\t\t    e->probability.to_reg_br_prob_base () : 0;\n-\t\ttmp *= BLOCK_INFO (e->src)->frequency;\n-\t\ttmp *= real_inv_br_prob_base;\n-\t\tfrequency += tmp;\n+\t\t\t    e->probability.to_sreal () : 0;\n+\t\tfrequency += tmp * BLOCK_INFO (e->src)->frequency;\n \t      }\n \n \t  if (cyclic_probability == 0)\n@@ -3346,14 +3335,29 @@ propagate_freq (basic_block head, bitmap tovisit)\n \t    }\n \t  else\n \t    {\n-\t      if (cyclic_probability > real_almost_one)\n-\t\tcyclic_probability = real_almost_one;\n-\n-\t      /* BLOCK_INFO (bb)->frequency = frequency\n-\t\t\t\t\t      / (1 - cyclic_probability) */\n-\n-\t      cyclic_probability = sreal (1) - cyclic_probability;\n-\t      BLOCK_INFO (bb)->frequency = frequency / cyclic_probability;\n+\t      if (cyclic_probability > max_cyclic_prob)\n+\t\t{\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file,\n+\t\t\t     \"cyclic probability of bb %i is %f (capped to %f)\"\n+\t\t\t     \"; turning freq %f\",\n+\t\t\t     bb->index, cyclic_probability.to_double (),\n+\t\t\t     max_cyclic_prob.to_double (),\n+\t\t\t     frequency.to_double ());\n+\t\t\t\n+\t\t  cyclic_probability = max_cyclic_prob;\n+\t\t}\n+\t      else if (dump_file)\n+\t\tfprintf (dump_file,\n+\t\t\t \"cyclic probability of bb %i is %f; turning freq %f\",\n+\t\t\t bb->index, cyclic_probability.to_double (),\n+\t\t\t frequency.to_double ());\n+\n+\t      BLOCK_INFO (bb)->frequency = frequency\n+\t\t\t\t / (sreal (1) - cyclic_probability);\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \" to %f\\n\",\n+\t\t\t BLOCK_INFO (bb)->frequency.to_double ());\n \t    }\n \t}\n \n@@ -3362,16 +3366,11 @@ propagate_freq (basic_block head, bitmap tovisit)\n       e = find_edge (bb, head);\n       if (e)\n \t{\n-\t  /* EDGE_INFO (e)->back_edge_prob\n-\t     = ((e->probability * BLOCK_INFO (bb)->frequency)\n-\t     / REG_BR_PROB_BASE); */\n-\n \t  /* FIXME: Graphite is producing edges with no profile. Once\n \t     this is fixed, drop this.  */\n \t  sreal tmp = e->probability.initialized_p () ?\n-\t\t      e->probability.to_reg_br_prob_base () : 0;\n-\t  tmp *= BLOCK_INFO (bb)->frequency;\n-\t  EDGE_INFO (e)->back_edge_prob = tmp * real_inv_br_prob_base;\n+\t\t      e->probability.to_sreal () : 0;\n+\t  EDGE_INFO (e)->back_edge_prob = tmp * BLOCK_INFO (bb)->frequency;\n \t}\n \n       /* Propagate to successor blocks.  */\n@@ -3396,7 +3395,7 @@ propagate_freq (basic_block head, bitmap tovisit)\n /* Estimate frequencies in loops at same nest level.  */\n \n static void\n-estimate_loops_at_level (class loop *first_loop)\n+estimate_loops_at_level (class loop *first_loop, sreal max_cyclic_prob)\n {\n   class loop *loop;\n \n@@ -3407,7 +3406,7 @@ estimate_loops_at_level (class loop *first_loop)\n       unsigned i;\n       auto_bitmap tovisit;\n \n-      estimate_loops_at_level (loop->inner);\n+      estimate_loops_at_level (loop->inner, max_cyclic_prob);\n \n       /* Find current loop back edge and mark it.  */\n       e = loop_latch_edge (loop);\n@@ -3417,7 +3416,7 @@ estimate_loops_at_level (class loop *first_loop)\n       for (i = 0; i < loop->num_nodes; i++)\n \tbitmap_set_bit (tovisit, bbs[i]->index);\n       free (bbs);\n-      propagate_freq (loop->header, tovisit);\n+      propagate_freq (loop->header, tovisit, max_cyclic_prob);\n     }\n }\n \n@@ -3428,17 +3427,18 @@ estimate_loops (void)\n {\n   auto_bitmap tovisit;\n   basic_block bb;\n+  sreal max_cyclic_prob = (sreal)1 - (sreal)1 / param_max_predicted_iterations;\n \n   /* Start by estimating the frequencies in the loops.  */\n   if (number_of_loops (cfun) > 1)\n-    estimate_loops_at_level (current_loops->tree_root->inner);\n+    estimate_loops_at_level (current_loops->tree_root->inner, max_cyclic_prob);\n \n   /* Now propagate the frequencies through all the blocks.  */\n   FOR_ALL_BB_FN (bb, cfun)\n     {\n       bitmap_set_bit (tovisit, bb->index);\n     }\n-  propagate_freq (ENTRY_BLOCK_PTR_FOR_FN (cfun), tovisit);\n+  propagate_freq (ENTRY_BLOCK_PTR_FOR_FN (cfun), tovisit, max_cyclic_prob);\n }\n \n /* Drop the profile for NODE to guessed, and update its frequency based on\n@@ -3844,21 +3844,6 @@ estimate_bb_frequencies (bool force)\n   if (force || profile_status_for_fn (cfun) != PROFILE_READ\n       || !update_max_bb_count ())\n     {\n-      static int real_values_initialized = 0;\n-\n-      if (!real_values_initialized)\n-        {\n-\t  real_values_initialized = 1;\n-\t  real_br_prob_base = REG_BR_PROB_BASE;\n-\t  /* Scaling frequencies up to maximal profile count may result in\n-\t     frequent overflows especially when inlining loops.\n-\t     Small scalling results in unnecesary precision loss.  Stay in\n-\t     the half of the (exponential) range.  */\n-\t  real_bb_freq_max = (uint64_t)1 << (profile_count::n_bits / 2);\n-\t  real_one_half = sreal (1, -1);\n-\t  real_inv_br_prob_base = sreal (1) / real_br_prob_base;\n-\t  real_almost_one = sreal (1) - real_inv_br_prob_base;\n-\t}\n \n       mark_dfs_back_edges ();\n \n@@ -3879,10 +3864,10 @@ estimate_bb_frequencies (bool force)\n \t\t this is fixed, drop this.  */\n \t      if (e->probability.initialized_p ())\n \t        EDGE_INFO (e)->back_edge_prob\n-\t\t   = e->probability.to_reg_br_prob_base ();\n+\t\t   = e->probability.to_sreal ();\n \t      else\n-\t\tEDGE_INFO (e)->back_edge_prob = REG_BR_PROB_BASE / 2;\n-\t      EDGE_INFO (e)->back_edge_prob *= real_inv_br_prob_base;\n+\t\t/* back_edge_prob = 0.5 */\n+\t\tEDGE_INFO (e)->back_edge_prob = sreal (1, -1);\n \t    }\n \t}\n \n@@ -3895,14 +3880,18 @@ estimate_bb_frequencies (bool force)\n \tif (freq_max < BLOCK_INFO (bb)->frequency)\n \t  freq_max = BLOCK_INFO (bb)->frequency;\n \n-      freq_max = real_bb_freq_max / freq_max;\n+      /* Scaling frequencies up to maximal profile count may result in\n+\t frequent overflows especially when inlining loops.\n+\t Small scalling results in unnecesary precision loss.  Stay in\n+\t the half of the (exponential) range.  */\n+      freq_max = (sreal (1) << (profile_count::n_bits / 2)) / freq_max;\n       if (freq_max < 16)\n \tfreq_max = 16;\n       profile_count ipa_count = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.ipa ();\n       cfun->cfg->count_max = profile_count::uninitialized ();\n       FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n \t{\n-\t  sreal tmp = BLOCK_INFO (bb)->frequency * freq_max + real_one_half;\n+\t  sreal tmp = BLOCK_INFO (bb)->frequency * freq_max + sreal (1, -1);\n \t  profile_count count = profile_count::from_gcov_type (tmp.to_int ());\t\n \n \t  /* If we have profile feedback in which this function was never"}, {"sha": "0c7922978260ad5842965c890921d6e307babacb", "filename": "gcc/profile-count.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5b25e15165adde1356af42e9066ab75c5b37a19/gcc%2Fprofile-count.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5b25e15165adde1356af42e9066ab75c5b37a19/gcc%2Fprofile-count.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.c?ref=f5b25e15165adde1356af42e9066ab75c5b37a19", "patch": "@@ -446,3 +446,12 @@ profile_probability::combine_with_count (profile_count count1,\n   else\n     return *this * even () + other * even ();\n }\n+\n+/* Return probability as sreal in range [0, 1].  */\n+\n+sreal\n+profile_probability::to_sreal () const\n+{\n+  gcc_checking_assert (initialized_p ());\n+  return ((sreal)m_val) >> (n_bits - 2);\n+}"}, {"sha": "09217a8699b03bc491ed36976ae458d24bab5e04", "filename": "gcc/profile-count.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5b25e15165adde1356af42e9066ab75c5b37a19/gcc%2Fprofile-count.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5b25e15165adde1356af42e9066ab75c5b37a19/gcc%2Fprofile-count.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.h?ref=f5b25e15165adde1356af42e9066ab75c5b37a19", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n \n struct function;\n struct profile_count;\n+class sreal;\n \n /* Quality of the profile count.  Because gengtype does not support enums\n    inside of classes, this is in global namespace.  */\n@@ -614,6 +615,8 @@ class GTY((user)) profile_probability\n \t\t\t\t\t  profile_probability other,\n \t\t\t\t\t  profile_count count2) const;\n \n+  /* Return probability as sreal.  */\n+  sreal to_sreal () const;\n   /* LTO streaming support.  */\n   static profile_probability stream_in (class lto_input_block *);\n   void stream_out (struct output_block *);\n@@ -674,8 +677,6 @@ class GTY((user)) profile_probability\n \n  */\n \n-class sreal;\n-\n struct GTY(()) profile_count\n {\n public:"}]}