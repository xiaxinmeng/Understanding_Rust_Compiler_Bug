{"sha": "0e5732f2b545bdacb18461bbb28d36503cecfd98", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU1NzMyZjJiNTQ1YmRhY2IxODQ2MWJiYjI4ZDM2NTAzY2VjZmQ5OA==", "commit": {"author": {"name": "Mike Karr", "email": "mkarr@mathworks.com", "date": "1999-12-02T16:31:58Z"}, "committer": {"name": "Dave Brolley", "email": "brolley@gcc.gnu.org", "date": "1999-12-02T16:31:58Z"}, "message": "cccp.c (argdata): Added free_ptr member.\n\n1999-12-02  Mike Karr  <mkarr@mathworks.com>\n\n\t* cccp.c (argdata): Added free_ptr member.\n\t(macroexpand): Initialize free_ptr of each argument. When an\n\targument's buffers are freed, if the argument's free_ptr corresponds\n\tto a buffer on the input stack, then return the free_ptr to that stack\n\tframe, otherwise, free it.\n\t(macarg): If an argument begins and ends on the same input stack level,\n\tthen transfer the free_ptr of that buffer to the argument in case\n\tthe stack is popped during the processing of a subsequent argument.\n\nFrom-SVN: r30760", "tree": {"sha": "e4ec6d5ffc4e3d8b332654cbbed004c3c45a91c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4ec6d5ffc4e3d8b332654cbbed004c3c45a91c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e5732f2b545bdacb18461bbb28d36503cecfd98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e5732f2b545bdacb18461bbb28d36503cecfd98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e5732f2b545bdacb18461bbb28d36503cecfd98", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e5732f2b545bdacb18461bbb28d36503cecfd98/comments", "author": null, "committer": null, "parents": [{"sha": "bc622faec91f80027c6dc146f9120fd50001d75a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc622faec91f80027c6dc146f9120fd50001d75a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc622faec91f80027c6dc146f9120fd50001d75a"}], "stats": {"total": 37, "additions": 36, "deletions": 1}, "files": [{"sha": "89287c9921087eed17a905fa1562df6d746a4d6b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5732f2b545bdacb18461bbb28d36503cecfd98/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5732f2b545bdacb18461bbb28d36503cecfd98/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0e5732f2b545bdacb18461bbb28d36503cecfd98", "patch": "@@ -1,3 +1,14 @@\n+1999-12-02  Mike Karr  <mkarr@mathworks.com>\n+\n+\t* cccp.c (argdata): Added free_ptr member.\n+\t(macroexpand): Initialize free_ptr of each argument. When an\n+\targument's buffers are freed, if the argument's free_ptr corresponds\n+\tto a buffer on the input stack, then return the free_ptr to that stack\n+\tframe, otherwise, free it.\n+\t(macarg): If an argument begins and ends on the same input stack level,\n+\tthen transfer the free_ptr of that buffer to the argument in case\n+\tthe stack is popped during the processing of a subsequent argument.\n+\n 1999-12-02  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n \t* loop.c (note_reg_stored): New function."}, {"sha": "78501c8ac601d12bb029c0de8d1cab233abcb6dd", "filename": "gcc/cccp.c", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5732f2b545bdacb18461bbb28d36503cecfd98/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5732f2b545bdacb18461bbb28d36503cecfd98/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=0e5732f2b545bdacb18461bbb28d36503cecfd98", "patch": "@@ -8443,13 +8443,19 @@ output_line_directive (ip, op, conditional, file_change)\n    into the macro.  If the actual use count exceeds 10, \n    the value stored is 10.\n    `free1' and `free2', if nonzero, point to blocks to be freed\n-   when the macro argument data is no longer needed.  */\n+   when the macro argument data is no longer needed.\n+   `free_ptr', if nonzero, points to a value of instack[i].free_ptr\n+   where the raw field points somewhere into this string.  The purpose\n+   of this is to hold onto instack[i].buf for macro arguments, even\n+   when the element has been popped off the input stack.\n+*/\n \n struct argdata {\n   U_CHAR *raw, *expanded;\n   int raw_length, expand_length, expand_size;\n   int stringified_length_bound;\n   U_CHAR *free1, *free2;\n+  U_CHAR *free_ptr;\n   char newlines;\n   char use_count;\n };\n@@ -8502,6 +8508,7 @@ macroexpand (hp, op)\n       args[i].raw_length = args[i].expand_length = args[i].expand_size\n \t= args[i].stringified_length_bound = 0;\n       args[i].free1 = args[i].free2 = 0;\n+      args[i].free_ptr = 0;\n       args[i].use_count = 0;\n     }\n \n@@ -8845,6 +8852,18 @@ macroexpand (hp, op)\n       xbuf_len = totlen;\n \n       for (i = 0; i < nargs; i++) {\n+        if (args[i].free_ptr != 0) {\n+          U_CHAR *buf = args[i].free_ptr;\n+          int d;\n+          for (d = indepth; d >= 0; --d) {\n+            if (instack[d].buf == buf) {\n+              instack[d].free_ptr = buf; /* Give ownership back to instack */\n+              goto no_free;\n+            }\n+          }\n+          free (buf); /* buf is not on the stack; must have been popped */\n+        no_free:;\n+        }\n \tif (args[i].free1 != 0)\n \t  free (args[i].free1);\n \tif (args[i].free2 != 0)\n@@ -8915,6 +8934,11 @@ macarg (argptr, rest_args)\n       argptr->raw = ip->bufp;\n       argptr->raw_length = bp - ip->bufp;\n       argptr->newlines = ip->lineno - lineno0;\n+      /* The next two statements transfer ownership of the the buffer\n+\t from ip to argptr.  Note that the second statement ensures that\n+\t a given free_ptr is owned by at most one macro argument. */\n+      argptr->free_ptr = ip->free_ptr;\n+      ip->free_ptr     = 0;\n     }\n     ip->bufp = bp;\n   } else {"}]}