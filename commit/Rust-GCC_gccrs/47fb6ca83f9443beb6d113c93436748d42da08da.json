{"sha": "47fb6ca83f9443beb6d113c93436748d42da08da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdmYjZjYTgzZjk0NDNiZWI2ZDExM2M5MzQzNjc0OGQ0MmRhMDhkYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-19T14:59:32Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-19T14:59:32Z"}, "message": "[multiple changes]\n\n2014-02-19  Matthew Heaney  <heaney@adacore.com>\n\n\t* a-chtgop.ads (Checked_Index): New operation.\n\t(Next): Changed mode of hash table.\n\t* a-chtgop.adb (Adjust, Delete_Node_Sans_Free): Detect tampering\n\t(Generic_Read, Reserve_Capacity): Ditto.\n\t(Generic_Equal): Detect tampering.\n\t(Next): Changed mode of hash table, detect tampering.\n\t* a-chtgke.ads (Checked_Index, Checked_Equivalent_Keys): New\n\toperation.\n\t(Find): Changed mode of hash table.\n\t* a-chtgke.adb (Checked_Equivalent_Keys): New operation\n\t(Delete_Key_Sans_Free, Generic_Conditional_Insert): Detect\n\ttampering.\n\t(Find): Changed mode of hash table, check for tampering.\n\t(Generic_Replace_Element): Check for tampering.\n\t* a-chtgbk.ads (Checked_Index, Checked_Equivalent_Keys): New operation.\n\t* a-chtgbk.adb (Checked_Index, Checked_Equivalent_Keys): New\n\toperation (Delete_Key_Sans_Free, Generic_Conditional_Insert):\n\tDetect tampering.\n\t(Find, Generic_Replace_Element): Check for tampering.\n\t* a-chtgbo.ads (Checked_Index): New operation.\n\t* a-chtgbo.adb (Checked_Index): New operation\n\t(Delete_Node_Sans_Free, Generic_Equal): Detect tampering.\n\t(Generic_Read, Next): Ditto.\n\t* a-cohase.adb, a-cihase.adb (Is_In): Changed mode of hash\n\ttable (Difference, Intersection): Use variable view of\n\tsource, detect tampering (Find, Is_Subset, Overlap): Use\n\tvariable view of container (Symmetric_Difference, Union):\n\tDetect tampering (Vet): Use Checked_Index to detect tampering\n\t(Constant_Reference, Element, Find): Use variable view of\n\tcontainer.\n\t(Update_Element_Preserving_Key): Detect tampering.\n\t* a-cbhase.adb (Difference, Find, Is_In): Use variable view\n\tof container.\n\t(Is_Subset): Ditto.\n\t(Equivalent_Sets, Overlap): Use Node's Next component.\n\t(Vet): Use Checked_Index to detect tampering.\n\t(Constant_Reference, Element, Find): Use variable view of container.\n\t(Update_Element_Preserving_Key): Detect tampering.\n\t* a-cohama.adb, a-cihama.adb, a-cbhama.adb (Constant_Reference,\n\tElement, Find): Use variable view of container.\n\t(Reference): Rename hash table component.\n\t(Vet): Use Checked_Index to detect tampering.\n\n2014-02-19  Arnaud Charlet  <charlet@adacore.com>\n\n\t* adabkend.adb (Scan_Compiler_Arguments): Add missing handling\n\tof -nostdinc.\n\n2014-02-19  Thomas Quinot  <quinot@adacore.com>\n\n\t* tbuild.adb (New_Occurrence_Of, New_Rerefence_To): Guard\n\tagainst calls without Def_Id.\n\n2014-02-19  Claire Dross  <dross@adacore.com>\n\n\t* a-cfdlli.ads, a-cfhase.ads, a-cforma.ads, a-cfhama.ads, a-cforse.ads,\n\ta-cofove.ads: Add global annotations to subprograms.\n\n2014-02-19  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Analyze_Initial_Condition_In_Decl_Part): Remove\n\tconstants Errors, Pack_Id and Pack_Init. Remove variable Vars.\n\tInitial_Condition no longer requires the presence of pragma\n\tInitialized. Do not try to diagnose whether all variables mentioned in\n\tpragma Initializes also appear in Initial_Condition.\n\t(Collect_Variables): Removed.\n\t(Match_Variable): Removed.\n\t(Match_Variables): Removed.\n\t(Report_Unused_Variables): Removed.\n\n2014-02-19  Thomas Quinot  <quinot@adacore.com>\n\n\t* gnat_rm.texi (pragma Stream_Convert): Minor rewording.\n\nFrom-SVN: r207905", "tree": {"sha": "b221f814aa37449bd76edb385d28670d5b39101c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b221f814aa37449bd76edb385d28670d5b39101c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47fb6ca83f9443beb6d113c93436748d42da08da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47fb6ca83f9443beb6d113c93436748d42da08da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47fb6ca83f9443beb6d113c93436748d42da08da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47fb6ca83f9443beb6d113c93436748d42da08da/comments", "author": null, "committer": null, "parents": [{"sha": "13f39091ea608a390dd56aabdec1ac6bb56846dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13f39091ea608a390dd56aabdec1ac6bb56846dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13f39091ea608a390dd56aabdec1ac6bb56846dd"}], "stats": {"total": 2508, "additions": 1740, "deletions": 768}, "files": [{"sha": "09ad3eaf4f64cfebb1ca3ac61fb4ee24d82a2db8", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=47fb6ca83f9443beb6d113c93436748d42da08da", "patch": "@@ -1,3 +1,79 @@\n+2014-02-19  Matthew Heaney  <heaney@adacore.com>\n+\n+\t* a-chtgop.ads (Checked_Index): New operation.\n+\t(Next): Changed mode of hash table.\n+\t* a-chtgop.adb (Adjust, Delete_Node_Sans_Free): Detect tampering\n+\t(Generic_Read, Reserve_Capacity): Ditto.\n+\t(Generic_Equal): Detect tampering.\n+\t(Next): Changed mode of hash table, detect tampering.\n+\t* a-chtgke.ads (Checked_Index, Checked_Equivalent_Keys): New\n+\toperation.\n+\t(Find): Changed mode of hash table.\n+\t* a-chtgke.adb (Checked_Equivalent_Keys): New operation\n+\t(Delete_Key_Sans_Free, Generic_Conditional_Insert): Detect\n+\ttampering.\n+\t(Find): Changed mode of hash table, check for tampering.\n+\t(Generic_Replace_Element): Check for tampering.\n+\t* a-chtgbk.ads (Checked_Index, Checked_Equivalent_Keys): New operation.\n+\t* a-chtgbk.adb (Checked_Index, Checked_Equivalent_Keys): New\n+\toperation (Delete_Key_Sans_Free, Generic_Conditional_Insert):\n+\tDetect tampering.\n+\t(Find, Generic_Replace_Element): Check for tampering.\n+\t* a-chtgbo.ads (Checked_Index): New operation.\n+\t* a-chtgbo.adb (Checked_Index): New operation\n+\t(Delete_Node_Sans_Free, Generic_Equal): Detect tampering.\n+\t(Generic_Read, Next): Ditto.\n+\t* a-cohase.adb, a-cihase.adb (Is_In): Changed mode of hash\n+\ttable (Difference, Intersection): Use variable view of\n+\tsource, detect tampering (Find, Is_Subset, Overlap): Use\n+\tvariable view of container (Symmetric_Difference, Union):\n+\tDetect tampering (Vet): Use Checked_Index to detect tampering\n+\t(Constant_Reference, Element, Find): Use variable view of\n+\tcontainer.\n+\t(Update_Element_Preserving_Key): Detect tampering.\n+\t* a-cbhase.adb (Difference, Find, Is_In): Use variable view\n+\tof container.\n+\t(Is_Subset): Ditto.\n+\t(Equivalent_Sets, Overlap): Use Node's Next component.\n+\t(Vet): Use Checked_Index to detect tampering.\n+\t(Constant_Reference, Element, Find): Use variable view of container.\n+\t(Update_Element_Preserving_Key): Detect tampering.\n+\t* a-cohama.adb, a-cihama.adb, a-cbhama.adb (Constant_Reference,\n+\tElement, Find): Use variable view of container.\n+\t(Reference): Rename hash table component.\n+\t(Vet): Use Checked_Index to detect tampering.\n+\n+2014-02-19  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* adabkend.adb (Scan_Compiler_Arguments): Add missing handling\n+\tof -nostdinc.\n+\n+2014-02-19  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* tbuild.adb (New_Occurrence_Of, New_Rerefence_To): Guard\n+\tagainst calls without Def_Id.\n+\n+2014-02-19  Claire Dross  <dross@adacore.com>\n+\n+\t* a-cfdlli.ads, a-cfhase.ads, a-cforma.ads, a-cfhama.ads, a-cforse.ads,\n+\ta-cofove.ads: Add global annotations to subprograms.\n+\n+2014-02-19  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Initial_Condition_In_Decl_Part): Remove\n+\tconstants Errors, Pack_Id and Pack_Init. Remove variable Vars.\n+\tInitial_Condition no longer requires the presence of pragma\n+\tInitialized. Do not try to diagnose whether all variables mentioned in\n+\tpragma Initializes also appear in Initial_Condition.\n+\t(Collect_Variables): Removed.\n+\t(Match_Variable): Removed.\n+\t(Match_Variables): Removed.\n+\t(Report_Unused_Variables): Removed.\n+\n+2014-02-19  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* gnat_rm.texi (pragma Stream_Convert): Minor rewording.\n+\n 2014-02-19  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_util.adb, sem_util.ads, prj-conf.adb, s-os_lib.adb: Minor"}, {"sha": "3549f993935bb1de2b1f57ae551f7b12c59413c5", "filename": "gcc/ada/a-cbhama.adb", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-cbhama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-cbhama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbhama.adb?ref=47fb6ca83f9443beb6d113c93436748d42da08da", "patch": "@@ -208,7 +208,8 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n      (Container : aliased Map;\n       Key       : Key_Type) return Constant_Reference_Type\n    is\n-      Node : constant Count_Type := Key_Ops.Find (Container, Key);\n+      Node : constant Count_Type :=\n+               Key_Ops.Find (Container'Unrestricted_Access.all, Key);\n \n    begin\n       if Node = 0 then\n@@ -321,7 +322,8 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n    -------------\n \n    function Element (Container : Map; Key : Key_Type) return Element_Type is\n-      Node : constant Count_Type := Key_Ops.Find (Container, Key);\n+      Node : constant Count_Type :=\n+               Key_Ops.Find (Container'Unrestricted_Access.all, Key);\n \n    begin\n       if Node = 0 then\n@@ -449,7 +451,8 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n    ----------\n \n    function Find (Container : Map; Key : Key_Type) return Cursor is\n-      Node : constant Count_Type := Key_Ops.Find (Container, Key);\n+      Node : constant Count_Type :=\n+               Key_Ops.Find (Container'Unrestricted_Access.all, Key);\n    begin\n       if Node = 0 then\n          return No_Element;\n@@ -1160,7 +1163,8 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n             return False;\n          end if;\n \n-         X := M.Buckets (Key_Ops.Index (M, M.Nodes (Position.Node).Key));\n+         X := M.Buckets (Key_Ops.Checked_Index\n+                          (M, M.Nodes (Position.Node).Key));\n \n          for J in 1 .. M.Length loop\n             if X = Position.Node then"}, {"sha": "640fb8e6136de6fcdf6af1be55d5b842a7cb0053", "filename": "gcc/ada/a-cbhase.adb", "status": "modified", "additions": 43, "deletions": 16, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-cbhase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-cbhase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbhase.adb?ref=47fb6ca83f9443beb6d113c93436748d42da08da", "patch": "@@ -328,6 +328,8 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n    is\n       Tgt_Node, Src_Node : Count_Type;\n \n+      Src : Set renames Source'Unrestricted_Access.all;\n+\n       TN : Nodes_Type renames Target.Nodes;\n       SN : Nodes_Type renames Source.Nodes;\n \n@@ -356,7 +358,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n                HT_Ops.Free (Target, Tgt_Node);\n             end if;\n \n-            Src_Node := HT_Ops.Next (Source, Src_Node);\n+            Src_Node := HT_Ops.Next (Src, Src_Node);\n          end loop;\n \n       else\n@@ -481,7 +483,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n                return True;\n             end if;\n \n-            R_Node := HT_Ops.Next (R_HT, R_Node);\n+            R_Node := Next (R_HT.Nodes (R_Node));\n          end loop;\n       end Find_Equivalent_Key;\n \n@@ -512,6 +514,20 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n       pragma Assert (Vet (Left), \"bad Left cursor in Equivalent_Elements\");\n       pragma Assert (Vet (Right), \"bad Right cursor in Equivalent_Elements\");\n \n+      --  AI05-0022 requires that a container implementation detect element\n+      --  tampering by a generic actual subprogram. However, the following case\n+      --  falls outside the scope of that AI. Randy Brukardt explained on the\n+      --  ARG list on 2013/02/07 that:\n+\n+      --  (Begin Quote):\n+      --  But for an operation like \"<\" [the ordered set analog of\n+      --  Equivalent_Elements], there is no need to \"dereference\" a cursor\n+      --  after the call to the generic formal parameter function, so nothing\n+      --  bad could happen if tampering is undetected. And the operation can\n+      --  safely return a result without a problem even if an element is\n+      --  deleted from the container.\n+      --  (End Quote).\n+\n       declare\n          LN : Node_Type renames Left.Container.Nodes (Left.Node);\n          RN : Node_Type renames Right.Container.Nodes (Right.Node);\n@@ -609,7 +625,8 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n      (Container : Set;\n       Item      : Element_Type) return Cursor\n    is\n-      Node : constant Count_Type := Element_Keys.Find (Container, Item);\n+      Node : constant Count_Type :=\n+               Element_Keys.Find (Container'Unrestricted_Access.all, Item);\n    begin\n       return (if Node = 0 then No_Element\n               else Cursor'(Container'Unrestricted_Access, Node));\n@@ -865,7 +882,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n \n    function Is_In (HT : Set; Key : Node_Type) return Boolean is\n    begin\n-      return Element_Keys.Find (HT, Key.Element) /= 0;\n+      return Element_Keys.Find (HT'Unrestricted_Access.all, Key.Element) /= 0;\n    end Is_In;\n \n    ---------------\n@@ -890,7 +907,8 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n          if not Is_In (Of_Set, SN (Subset_Node)) then\n             return False;\n          end if;\n-         Subset_Node := HT_Ops.Next (Subset, Subset_Node);\n+         Subset_Node := HT_Ops.Next\n+                          (Subset'Unrestricted_Access.all, Subset_Node);\n       end loop;\n \n       return True;\n@@ -1049,7 +1067,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n          if Is_In (Right, Left.Nodes (Left_Node)) then\n             return True;\n          end if;\n-         Left_Node := HT_Ops.Next (Left, Left_Node);\n+         Left_Node := HT_Ops.Next (Left'Unrestricted_Access.all, Left_Node);\n       end loop;\n \n       return False;\n@@ -1481,7 +1499,8 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n             return False;\n          end if;\n \n-         X := S.Buckets (Element_Keys.Index (S, N (Position.Node).Element));\n+         X := S.Buckets (Element_Keys.Checked_Index\n+                           (S, N (Position.Node).Element));\n \n          for J in 1 .. S.Length loop\n             if X = Position.Node then\n@@ -1585,7 +1604,8 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n         (Container : aliased Set;\n          Key       : Key_Type) return Constant_Reference_Type\n       is\n-         Node : constant Count_Type := Key_Keys.Find (Container, Key);\n+         Node : constant Count_Type :=\n+                  Key_Keys.Find (Container'Unrestricted_Access.all, Key);\n \n       begin\n          if Node = 0 then\n@@ -1639,11 +1659,12 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n         (Container : Set;\n          Key       : Key_Type) return Element_Type\n       is\n-         Node : constant Count_Type := Key_Keys.Find (Container, Key);\n+         Node : constant Count_Type :=\n+                  Key_Keys.Find (Container'Unrestricted_Access.all, Key);\n \n       begin\n          if Node = 0 then\n-            raise Constraint_Error with \"key not in map\";  --  ??? \"set\"\n+            raise Constraint_Error with \"key not in set\";\n          end if;\n \n          return Container.Nodes (Node).Element;\n@@ -1683,7 +1704,8 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n         (Container : Set;\n          Key       : Key_Type) return Cursor\n       is\n-         Node : constant Count_Type := Key_Keys.Find (Container, Key);\n+         Node : constant Count_Type :=\n+                  Key_Keys.Find (Container'Unrestricted_Access.all, Key);\n       begin\n          return (if Node = 0 then No_Element\n                  else Cursor'(Container'Unrestricted_Access, Node));\n@@ -1825,9 +1847,8 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n            (Vet (Position),\n             \"bad cursor in Update_Element_Preserving_Key\");\n \n-         --  Record bucket now, in case key is changed\n-\n-         Indx := HT_Ops.Index (Container.Buckets, N (Position.Node));\n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n \n          declare\n             E : Element_Type renames N (Position.Node).Element;\n@@ -1836,12 +1857,19 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n             B : Natural renames Container.Busy;\n             L : Natural renames Container.Lock;\n \n+            Eq : Boolean;\n+\n          begin\n             B := B + 1;\n             L := L + 1;\n \n             begin\n+               --  Record bucket now, in case key is changed\n+               Indx := HT_Ops.Index (Container.Buckets, N (Position.Node));\n+\n                Process (E);\n+\n+               Eq := Equivalent_Keys (K, Key (E));\n             exception\n                when others =>\n                   L := L - 1;\n@@ -1852,8 +1880,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n             L := L - 1;\n             B := B - 1;\n \n-            if Equivalent_Keys (K, Key (E)) then\n-               pragma Assert (Hash (K) = Hash (E));\n+            if Eq then\n                return;\n             end if;\n          end;"}, {"sha": "8b169e46cc73ed74c685c044736edaca4c52fde8", "filename": "gcc/ada/a-cfdlli.ads", "status": "modified", "additions": 100, "deletions": 55, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-cfdlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-cfdlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.ads?ref=47fb6ca83f9443beb6d113c93436748d42da08da", "patch": "@@ -77,45 +77,55 @@ package Ada.Containers.Formal_Doubly_Linked_Lists is\n \n    No_Element : constant Cursor;\n \n-   function \"=\" (Left, Right : List) return Boolean;\n+   function \"=\" (Left, Right : List) return Boolean with\n+     Global => null;\n \n-   function Length (Container : List) return Count_Type;\n+   function Length (Container : List) return Count_Type with\n+     Global => null;\n \n-   function Is_Empty (Container : List) return Boolean;\n+   function Is_Empty (Container : List) return Boolean with\n+     Global => null;\n \n-   procedure Clear (Container : in out List);\n+   procedure Clear (Container : in out List) with\n+     Global => null;\n \n    procedure Assign (Target : in out List; Source : List) with\n-     Pre => Target.Capacity >= Length (Source);\n+     Global => null,\n+     Pre    => Target.Capacity >= Length (Source);\n \n    function Copy (Source : List; Capacity : Count_Type := 0) return List with\n-     Pre => Capacity = 0 or else Capacity >= Source.Capacity;\n+     Global => null,\n+     Pre    => Capacity = 0 or else Capacity >= Source.Capacity;\n \n    function Element\n      (Container : List;\n       Position : Cursor) return Element_Type\n    with\n-     Pre => Has_Element (Container, Position);\n+     Global => null,\n+     Pre    => Has_Element (Container, Position);\n \n    procedure Replace_Element\n      (Container : in out List;\n       Position  : Cursor;\n       New_Item  : Element_Type)\n    with\n-     Pre => Has_Element (Container, Position);\n+     Global => null,\n+     Pre    => Has_Element (Container, Position);\n \n    procedure Move (Target : in out List; Source : in out List) with\n-     Pre => Target.Capacity >= Length (Source);\n+     Global => null,\n+     Pre    => Target.Capacity >= Length (Source);\n \n    procedure Insert\n      (Container : in out List;\n       Before    : Cursor;\n       New_Item  : Element_Type;\n       Count     : Count_Type := 1)\n    with\n-     Pre => Length (Container) + Count <= Container.Capacity\n-              and then (Has_Element (Container, Before)\n-                         or else Before = No_Element);\n+     Global => null,\n+     Pre    => Length (Container) + Count <= Container.Capacity\n+                 and then (Has_Element (Container, Before)\n+                            or else Before = No_Element);\n \n    procedure Insert\n      (Container : in out List;\n@@ -124,156 +134,191 @@ package Ada.Containers.Formal_Doubly_Linked_Lists is\n       Position  : out Cursor;\n       Count     : Count_Type := 1)\n    with\n-     Pre => Length (Container) + Count <= Container.Capacity\n-              and then (Has_Element (Container, Before)\n-                         or else Before = No_Element);\n+     Global => null,\n+     Pre    => Length (Container) + Count <= Container.Capacity\n+                 and then (Has_Element (Container, Before)\n+                            or else Before = No_Element);\n \n    procedure Insert\n      (Container : in out List;\n       Before    : Cursor;\n       Position  : out Cursor;\n       Count     : Count_Type := 1)\n    with\n-     Pre => Length (Container) + Count <= Container.Capacity\n-              and then (Has_Element (Container, Before)\n-                         or else Before = No_Element);\n+     Global => null,\n+     Pre    => Length (Container) + Count <= Container.Capacity\n+                 and then (Has_Element (Container, Before)\n+                            or else Before = No_Element);\n \n    procedure Prepend\n      (Container : in out List;\n       New_Item  : Element_Type;\n       Count     : Count_Type := 1)\n    with\n-     Pre => Length (Container) + Count <= Container.Capacity;\n+     Global => null,\n+     Pre    => Length (Container) + Count <= Container.Capacity;\n \n    procedure Append\n      (Container : in out List;\n       New_Item  : Element_Type;\n       Count     : Count_Type := 1)\n    with\n-     Pre => Length (Container) + Count <= Container.Capacity;\n+     Global => null,\n+     Pre    => Length (Container) + Count <= Container.Capacity;\n \n    procedure Delete\n      (Container : in out List;\n       Position  : in out Cursor;\n       Count     : Count_Type := 1)\n    with\n-     Pre => Has_Element (Container, Position);\n+     Global => null,\n+     Pre    => Has_Element (Container, Position);\n \n    procedure Delete_First\n      (Container : in out List;\n-      Count     : Count_Type := 1);\n+      Count     : Count_Type := 1)\n+   with\n+     Global => null;\n \n    procedure Delete_Last\n      (Container : in out List;\n-      Count     : Count_Type := 1);\n+      Count     : Count_Type := 1)\n+   with\n+     Global => null;\n \n-   procedure Reverse_Elements (Container : in out List);\n+   procedure Reverse_Elements (Container : in out List) with\n+     Global => null;\n \n    procedure Swap\n      (Container : in out List;\n       I, J      : Cursor)\n    with\n-     Pre => Has_Element (Container, I) and then Has_Element (Container, J);\n+     Global => null,\n+     Pre    => Has_Element (Container, I) and then Has_Element (Container, J);\n \n    procedure Swap_Links\n      (Container : in out List;\n       I, J      : Cursor)\n    with\n-     Pre => Has_Element (Container, I) and then Has_Element (Container, J);\n+     Global => null,\n+     Pre    => Has_Element (Container, I) and then Has_Element (Container, J);\n \n    procedure Splice\n      (Target : in out List;\n       Before : Cursor;\n       Source : in out List)\n    with\n-     Pre => Length (Source) + Length (Target) <= Target.Capacity\n-              and then (Has_Element (Target, Before)\n-                         or else Before = No_Element);\n+     Global => null,\n+     Pre    => Length (Source) + Length (Target) <= Target.Capacity\n+                 and then (Has_Element (Target, Before)\n+                            or else Before = No_Element);\n \n    procedure Splice\n      (Target   : in out List;\n       Before   : Cursor;\n       Source   : in out List;\n       Position : in out Cursor)\n    with\n-     Pre => Length (Source) + Length (Target) <= Target.Capacity\n-              and then (Has_Element (Target, Before)\n-                         or else Before = No_Element)\n-              and then Has_Element (Source, Position);\n+     Global => null,\n+     Pre    => Length (Source) + Length (Target) <= Target.Capacity\n+                 and then (Has_Element (Target, Before)\n+                            or else Before = No_Element)\n+                 and then Has_Element (Source, Position);\n \n    procedure Splice\n      (Container : in out List;\n       Before    : Cursor;\n       Position  : Cursor)\n    with\n-     Pre => 2 * Length (Container) <= Container.Capacity\n-              and then (Has_Element (Container, Before)\n-                         or else Before = No_Element)\n-              and then Has_Element (Container, Position);\n+     Global => null,\n+     Pre    => 2 * Length (Container) <= Container.Capacity\n+                 and then (Has_Element (Container, Before)\n+                            or else Before = No_Element)\n+                 and then Has_Element (Container, Position);\n \n-   function First (Container : List) return Cursor;\n+   function First (Container : List) return Cursor with\n+     Global => null;\n \n    function First_Element (Container : List) return Element_Type with\n-     Pre => not Is_Empty (Container);\n+     Global => null,\n+     Pre    => not Is_Empty (Container);\n \n-   function Last (Container : List) return Cursor;\n+   function Last (Container : List) return Cursor with\n+     Global => null;\n \n    function Last_Element (Container : List) return Element_Type with\n-     Pre => not Is_Empty (Container);\n+     Global => null,\n+     Pre    => not Is_Empty (Container);\n \n    function Next (Container : List; Position : Cursor) return Cursor with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n \n    procedure Next (Container : List; Position : in out Cursor) with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n \n    function Previous (Container : List; Position : Cursor) return Cursor with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n \n    procedure Previous (Container : List; Position : in out Cursor) with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n \n    function Find\n      (Container : List;\n       Item      : Element_Type;\n       Position  : Cursor := No_Element) return Cursor\n    with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n \n    function Reverse_Find\n      (Container : List;\n       Item      : Element_Type;\n       Position  : Cursor := No_Element) return Cursor\n    with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n \n    function Contains\n      (Container : List;\n-      Item      : Element_Type) return Boolean;\n+      Item      : Element_Type) return Boolean\n+   with\n+     Global => null;\n \n-   function Has_Element (Container : List; Position : Cursor) return Boolean;\n+   function Has_Element (Container : List; Position : Cursor) return Boolean\n+   with\n+     Global => null;\n \n    generic\n       with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n    package Generic_Sorting is\n \n-      function Is_Sorted (Container : List) return Boolean;\n+      function Is_Sorted (Container : List) return Boolean with\n+        Global => null;\n \n-      procedure Sort (Container : in out List);\n+      procedure Sort (Container : in out List) with\n+        Global => null;\n \n-      procedure Merge (Target, Source : in out List);\n+      procedure Merge (Target, Source : in out List) with\n+        Global => null;\n \n    end Generic_Sorting;\n \n-   function Strict_Equal (Left, Right : List) return Boolean;\n+   function Strict_Equal (Left, Right : List) return Boolean with\n+     Global => null;\n    --  Strict_Equal returns True if the containers are physically equal, i.e.\n    --  they are structurally equal (function \"=\" returns True) and that they\n    --  have the same set of cursors.\n \n    function Left  (Container : List; Position : Cursor) return List with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n    function Right (Container : List; Position : Cursor) return List with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n    --  Left returns a container containing all elements preceding Position\n    --  (excluded) in Container. Right returns a container containing all\n    --  elements following Position (included) in Container. These two new"}, {"sha": "7880ea0fe7f33b031260e88b620348c56cc8055d", "filename": "gcc/ada/a-cfhama.ads", "status": "modified", "additions": 73, "deletions": 35, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-cfhama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-cfhama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhama.ads?ref=47fb6ca83f9443beb6d113c93436748d42da08da", "patch": "@@ -81,53 +81,65 @@ package Ada.Containers.Formal_Hashed_Maps is\n \n    No_Element : constant Cursor;\n \n-   function \"=\" (Left, Right : Map) return Boolean;\n+   function \"=\" (Left, Right : Map) return Boolean with\n+     Global => null;\n \n-   function Capacity (Container : Map) return Count_Type;\n+   function Capacity (Container : Map) return Count_Type with\n+     Global => null;\n \n    procedure Reserve_Capacity\n      (Container : in out Map;\n       Capacity  : Count_Type)\n    with\n-     Pre => Capacity <= Container.Capacity;\n+     Global => null,\n+     Pre    => Capacity <= Container.Capacity;\n \n-   function Length (Container : Map) return Count_Type;\n+   function Length (Container : Map) return Count_Type with\n+     Global => null;\n \n-   function Is_Empty (Container : Map) return Boolean;\n+   function Is_Empty (Container : Map) return Boolean with\n+     Global => null;\n \n-   procedure Clear (Container : in out Map);\n+   procedure Clear (Container : in out Map) with\n+     Global => null;\n \n    procedure Assign (Target : in out Map; Source : Map) with\n-     Pre => Target.Capacity >= Length (Source);\n+     Global => null,\n+     Pre    => Target.Capacity >= Length (Source);\n \n    function Copy\n      (Source   : Map;\n       Capacity : Count_Type := 0) return Map\n    with\n-     Pre => Capacity = 0 or else Capacity >= Source.Capacity;\n+     Global => null,\n+     Pre    => Capacity = 0 or else Capacity >= Source.Capacity;\n    --  Copy returns a container stricty equal to Source. It must have\n    --  the same cursors associated with each element. Therefore:\n    --  - capacity=0 means use container.capacity as capacity of target\n    --  - the modulus cannot be changed.\n \n    function Key (Container : Map; Position : Cursor) return Key_Type with\n-     Pre => Has_Element (Container, Position);\n+     Global => null,\n+     Pre    => Has_Element (Container, Position);\n \n    function Element\n      (Container : Map;\n       Position  : Cursor) return Element_Type\n    with\n-     Pre => Has_Element (Container, Position);\n+     Global => null,\n+     Pre    => Has_Element (Container, Position);\n \n    procedure Replace_Element\n      (Container : in out Map;\n       Position  : Cursor;\n       New_Item  : Element_Type)\n    with\n-     Pre => Has_Element (Container, Position);\n+     Global => null,\n+     Pre    => Has_Element (Container, Position);\n \n    procedure Move (Target : in out Map; Source : in out Map) with\n-     Pre => Target.Capacity >= Length (Source);\n+     Global => null,\n+     Pre    => Target.Capacity >= Length (Source);\n \n    procedure Insert\n      (Container : in out Map;\n@@ -136,90 +148,116 @@ package Ada.Containers.Formal_Hashed_Maps is\n       Position  : out Cursor;\n       Inserted  : out Boolean)\n    with\n-     Pre => Length (Container) < Container.Capacity;\n+     Global => null,\n+     Pre    => Length (Container) < Container.Capacity;\n \n    procedure Insert\n      (Container : in out Map;\n       Key       : Key_Type;\n       New_Item  : Element_Type)\n    with\n-     Pre => Length (Container) < Container.Capacity\n-              and then (not Contains (Container, Key));\n+     Global => null,\n+     Pre    => Length (Container) < Container.Capacity\n+                 and then (not Contains (Container, Key));\n \n    procedure Include\n      (Container : in out Map;\n       Key       : Key_Type;\n       New_Item  : Element_Type)\n    with\n-     Pre => Length (Container) < Container.Capacity;\n+     Global => null,\n+     Pre    => Length (Container) < Container.Capacity;\n \n    procedure Replace\n      (Container : in out Map;\n       Key       : Key_Type;\n       New_Item  : Element_Type)\n    with\n-     Pre => Contains (Container, Key);\n+     Global => null,\n+     Pre    => Contains (Container, Key);\n \n-   procedure Exclude (Container : in out Map; Key : Key_Type);\n+   procedure Exclude (Container : in out Map; Key : Key_Type) with\n+     Global => null;\n \n    procedure Delete (Container : in out Map; Key : Key_Type) with\n-     Pre => Contains (Container, Key);\n+     Global => null,\n+     Pre    => Contains (Container, Key);\n \n    procedure Delete (Container : in out Map; Position : in out Cursor) with\n-     Pre => Has_Element (Container, Position);\n+     Global => null,\n+     Pre    => Has_Element (Container, Position);\n \n-   function First (Container : Map) return Cursor;\n+   function First (Container : Map) return Cursor with\n+     Global => null;\n \n    function Next (Container : Map; Position : Cursor) return Cursor with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n \n    procedure Next (Container : Map; Position : in out Cursor) with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n \n-   function Find (Container : Map; Key : Key_Type) return Cursor;\n+   function Find (Container : Map; Key : Key_Type) return Cursor with\n+     Global => null;\n \n-   function Contains (Container : Map; Key : Key_Type) return Boolean;\n+   function Contains (Container : Map; Key : Key_Type) return Boolean with\n+     Global => null;\n \n    function Element (Container : Map; Key : Key_Type) return Element_Type with\n-     Pre => Contains (Container, Key);\n+     Global => null,\n+     Pre    => Contains (Container, Key);\n \n-   function Has_Element (Container : Map; Position : Cursor) return Boolean;\n+   function Has_Element (Container : Map; Position : Cursor) return Boolean\n+   with\n+     Global => null;\n \n    function Equivalent_Keys\n      (Left   : Map;\n       CLeft  : Cursor;\n       Right  : Map;\n-      CRight : Cursor) return Boolean;\n+      CRight : Cursor) return Boolean\n+   with\n+     Global => null;\n \n    function Equivalent_Keys\n      (Left  : Map;\n       CLeft : Cursor;\n-      Right : Key_Type) return Boolean;\n+      Right : Key_Type) return Boolean\n+   with\n+     Global => null;\n \n    function Equivalent_Keys\n      (Left   : Key_Type;\n       Right  : Map;\n-      CRight : Cursor) return Boolean;\n+      CRight : Cursor) return Boolean\n+   with\n+     Global => null;\n \n-   function Default_Modulus (Capacity : Count_Type) return Hash_Type;\n+   function Default_Modulus (Capacity : Count_Type) return Hash_Type with\n+     Global => null;\n \n-   function Strict_Equal (Left, Right : Map) return Boolean;\n+   function Strict_Equal (Left, Right : Map) return Boolean with\n+     Global => null;\n    --  Strict_Equal returns True if the containers are physically equal, i.e.\n    --  they are structurally equal (function \"=\" returns True) and that they\n    --  have the same set of cursors.\n \n    function Left  (Container : Map; Position : Cursor) return Map with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n    function Right (Container : Map; Position : Cursor) return Map with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n    --  Left returns a container containing all elements preceding Position\n    --  (excluded) in Container. Right returns a container containing all\n    --  elements following Position (included) in Container. These two new\n    --  functions can be used to express invariant properties in loops which\n    --  iterate over containers. Left returns the part of the container already\n    --  scanned and Right the part not scanned yet.\n \n-   function Overlap (Left, Right : Map) return Boolean;\n+   function Overlap (Left, Right : Map) return Boolean with\n+     Global => null;\n    --  Overlap returns True if the containers have common keys\n \n private"}, {"sha": "058d4503e1dd31daf396fcc069038d00087e9524", "filename": "gcc/ada/a-cfhase.ads", "status": "modified", "additions": 115, "deletions": 52, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-cfhase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-cfhase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhase.ads?ref=47fb6ca83f9443beb6d113c93436748d42da08da", "patch": "@@ -83,136 +83,187 @@ package Ada.Containers.Formal_Hashed_Sets is\n \n    No_Element : constant Cursor;\n \n-   function \"=\" (Left, Right : Set) return Boolean;\n+   function \"=\" (Left, Right : Set) return Boolean with\n+     Global => null;\n \n-   function Equivalent_Sets (Left, Right : Set) return Boolean;\n+   function Equivalent_Sets (Left, Right : Set) return Boolean with\n+     Global => null;\n \n-   function To_Set (New_Item : Element_Type) return Set;\n+   function To_Set (New_Item : Element_Type) return Set with\n+     Global => null;\n \n-   function Capacity (Container : Set) return Count_Type;\n+   function Capacity (Container : Set) return Count_Type with\n+     Global => null;\n \n    procedure Reserve_Capacity\n      (Container : in out Set;\n       Capacity  : Count_Type)\n    with\n-     Pre => Capacity <= Container.Capacity;\n+     Global => null,\n+     Pre    => Capacity <= Container.Capacity;\n \n-   function Length (Container : Set) return Count_Type;\n+   function Length (Container : Set) return Count_Type with\n+     Global => null;\n \n-   function Is_Empty (Container : Set) return Boolean;\n+   function Is_Empty (Container : Set) return Boolean with\n+     Global => null;\n \n-   procedure Clear (Container : in out Set);\n+   procedure Clear (Container : in out Set) with\n+     Global => null;\n \n    procedure Assign (Target : in out Set; Source : Set) with\n-     Pre => Target.Capacity >= Length (Source);\n+     Global => null,\n+     Pre    => Target.Capacity >= Length (Source);\n \n    function Copy\n      (Source   : Set;\n       Capacity : Count_Type := 0) return Set\n    with\n-     Pre => Capacity = 0 or else Capacity >= Source.Capacity;\n+     Global => null,\n+     Pre    => Capacity = 0 or else Capacity >= Source.Capacity;\n \n    function Element\n      (Container : Set;\n       Position  : Cursor) return Element_Type\n    with\n-     Pre => Has_Element (Container, Position);\n+     Global => null,\n+     Pre    => Has_Element (Container, Position);\n \n    procedure Replace_Element\n      (Container : in out Set;\n       Position  : Cursor;\n       New_Item  : Element_Type)\n    with\n-     Pre => Has_Element (Container, Position);\n+     Global => null,\n+     Pre    => Has_Element (Container, Position);\n \n    procedure Move (Target : in out Set; Source : in out Set) with\n-     Pre => Target.Capacity >= Length (Source);\n+     Global => null,\n+     Pre    => Target.Capacity >= Length (Source);\n \n    procedure Insert\n      (Container : in out Set;\n       New_Item  : Element_Type;\n       Position  : out Cursor;\n       Inserted  : out Boolean)\n    with\n-     Pre => Length (Container) < Container.Capacity;\n+     Global => null,\n+     Pre    => Length (Container) < Container.Capacity;\n \n    procedure Insert  (Container : in out Set; New_Item : Element_Type) with\n-     Pre => Length (Container) < Container.Capacity\n-              and then (not Contains (Container, New_Item));\n+     Global => null,\n+     Pre    => Length (Container) < Container.Capacity\n+                 and then (not Contains (Container, New_Item));\n \n    procedure Include (Container : in out Set; New_Item : Element_Type) with\n-     Pre => Length (Container) < Container.Capacity;\n+     Global => null,\n+     Pre    => Length (Container) < Container.Capacity;\n \n    procedure Replace (Container : in out Set; New_Item : Element_Type) with\n-     Pre => Contains (Container, New_Item);\n+     Global => null,\n+     Pre    => Contains (Container, New_Item);\n \n-   procedure Exclude (Container : in out Set; Item     : Element_Type);\n+   procedure Exclude (Container : in out Set; Item     : Element_Type) with\n+     Global => null;\n \n    procedure Delete  (Container : in out Set; Item     : Element_Type) with\n-     Pre => Contains (Container, Item);\n+     Global => null,\n+     Pre    => Contains (Container, Item);\n \n    procedure Delete (Container : in out Set; Position  : in out Cursor) with\n-     Pre => Has_Element (Container, Position);\n+     Global => null,\n+     Pre    => Has_Element (Container, Position);\n \n    procedure Union (Target : in out Set; Source : Set) with\n-     Pre => Length (Target) + Length (Source) -\n-              Length (Intersection (Target, Source)) <= Target.Capacity;\n+     Global => null,\n+     Pre    => Length (Target) + Length (Source) -\n+                 Length (Intersection (Target, Source)) <= Target.Capacity;\n \n-   function Union (Left, Right : Set) return Set;\n+   function Union (Left, Right : Set) return Set with\n+     Global => null,\n+     Pre    => Length (Left) + Length (Right) -\n+                 Length (Intersection (Left, Right)) <= Count_Type'Last;\n \n    function \"or\" (Left, Right : Set) return Set renames Union;\n \n-   procedure Intersection (Target : in out Set; Source : Set);\n+   procedure Intersection (Target : in out Set; Source : Set) with\n+     Global => null;\n \n-   function Intersection (Left, Right : Set) return Set;\n+   function Intersection (Left, Right : Set) return Set with\n+     Global => null;\n \n    function \"and\" (Left, Right : Set) return Set renames Intersection;\n \n-   procedure Difference (Target : in out Set; Source : Set);\n+   procedure Difference (Target : in out Set; Source : Set) with\n+     Global => null;\n \n-   function Difference (Left, Right : Set) return Set;\n+   function Difference (Left, Right : Set) return Set with\n+     Global => null;\n \n    function \"-\" (Left, Right : Set) return Set renames Difference;\n \n-   procedure Symmetric_Difference (Target : in out Set; Source : Set);\n+   procedure Symmetric_Difference (Target : in out Set; Source : Set) with\n+     Global => null,\n+     Pre    => Length (Target) + Length (Source) -\n+                 2 * Length (Intersection (Target, Source)) <= Target.Capacity;\n \n-   function Symmetric_Difference (Left, Right : Set) return Set;\n+   function Symmetric_Difference (Left, Right : Set) return Set with\n+     Global => null,\n+     Pre    => Length (Left) + Length (Right) -\n+                 2 * Length (Intersection (Left, Right)) <= Count_Type'Last;\n \n    function \"xor\" (Left, Right : Set) return Set\n      renames Symmetric_Difference;\n \n-   function Overlap (Left, Right : Set) return Boolean;\n+   function Overlap (Left, Right : Set) return Boolean with\n+     Global => null;\n \n-   function Is_Subset (Subset : Set; Of_Set : Set) return Boolean;\n+   function Is_Subset (Subset : Set; Of_Set : Set) return Boolean with\n+     Global => null;\n \n-   function First (Container : Set) return Cursor;\n+   function First (Container : Set) return Cursor with\n+     Global => null;\n \n    function Next (Container : Set; Position : Cursor) return Cursor with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n \n    procedure Next (Container : Set; Position : in out Cursor) with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n \n    function Find\n      (Container : Set;\n-      Item      : Element_Type) return Cursor;\n+      Item      : Element_Type) return Cursor\n+   with\n+     Global => null;\n \n-   function Contains (Container : Set; Item : Element_Type) return Boolean;\n+   function Contains (Container : Set; Item : Element_Type) return Boolean with\n+     Global => null;\n \n-   function Has_Element (Container : Set; Position : Cursor) return Boolean;\n+   function Has_Element (Container : Set; Position : Cursor) return Boolean\n+   with\n+     Global => null;\n \n    function Equivalent_Elements (Left  : Set; CLeft : Cursor;\n-                                 Right : Set; CRight : Cursor) return Boolean;\n+                                 Right : Set; CRight : Cursor) return Boolean\n+   with\n+     Global => null;\n \n    function Equivalent_Elements\n      (Left  : Set; CLeft : Cursor;\n-      Right : Element_Type) return Boolean;\n+      Right : Element_Type) return Boolean\n+   with\n+     Global => null;\n \n    function Equivalent_Elements\n      (Left  : Element_Type;\n-      Right : Set; CRight : Cursor) return Boolean;\n+      Right : Set; CRight : Cursor) return Boolean\n+   with\n+     Global => null;\n \n-   function Default_Modulus (Capacity : Count_Type) return Hash_Type;\n+   function Default_Modulus (Capacity : Count_Type) return Hash_Type with\n+     Global => null;\n \n    generic\n       type Key_Type (<>) is private;\n@@ -225,34 +276,46 @@ package Ada.Containers.Formal_Hashed_Sets is\n \n    package Generic_Keys is\n \n-      function Key (Container : Set; Position : Cursor) return Key_Type;\n+      function Key (Container : Set; Position : Cursor) return Key_Type with\n+        Global => null;\n \n-      function Element (Container : Set; Key : Key_Type) return Element_Type;\n+      function Element (Container : Set; Key : Key_Type) return Element_Type\n+      with\n+          Global => null;\n \n       procedure Replace\n         (Container : in out Set;\n          Key       : Key_Type;\n-         New_Item  : Element_Type);\n+         New_Item  : Element_Type)\n+      with\n+          Global => null;\n \n-      procedure Exclude (Container : in out Set; Key : Key_Type);\n+      procedure Exclude (Container : in out Set; Key : Key_Type) with\n+        Global => null;\n \n-      procedure Delete (Container : in out Set; Key : Key_Type);\n+      procedure Delete (Container : in out Set; Key : Key_Type) with\n+        Global => null;\n \n-      function Find (Container : Set; Key : Key_Type) return Cursor;\n+      function Find (Container : Set; Key : Key_Type) return Cursor with\n+        Global => null;\n \n-      function Contains (Container : Set; Key : Key_Type) return Boolean;\n+      function Contains (Container : Set; Key : Key_Type) return Boolean with\n+        Global => null;\n \n    end Generic_Keys;\n \n-   function Strict_Equal (Left, Right : Set) return Boolean;\n+   function Strict_Equal (Left, Right : Set) return Boolean with\n+     Global => null;\n    --  Strict_Equal returns True if the containers are physically equal, i.e.\n    --  they are structurally equal (function \"=\" returns True) and that they\n    --  have the same set of cursors.\n \n    function Left  (Container : Set; Position : Cursor) return Set with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n    function Right (Container : Set; Position : Cursor) return Set with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n    --  Left returns a container containing all elements preceding Position\n    --  (excluded) in Container. Right returns a container containing all\n    --  elements following Position (included) in Container. These two new"}, {"sha": "f927cf86da356aae7b54cfadb45c89cbbad313bd", "filename": "gcc/ada/a-cforma.ads", "status": "modified", "additions": 82, "deletions": 41, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-cforma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-cforma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforma.ads?ref=47fb6ca83f9443beb6d113c93436748d42da08da", "patch": "@@ -68,7 +68,8 @@ package Ada.Containers.Formal_Ordered_Maps is\n    pragma Annotate (GNATprove, External_Axiomatization);\n    pragma Pure;\n \n-   function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n+   function Equivalent_Keys (Left, Right : Key_Type) return Boolean with\n+     Global => null;\n \n    type Map (Capacity : Count_Type) is private with\n      Iterable => (First       => First,\n@@ -84,38 +85,48 @@ package Ada.Containers.Formal_Ordered_Maps is\n \n    No_Element : constant Cursor;\n \n-   function \"=\" (Left, Right : Map) return Boolean;\n+   function \"=\" (Left, Right : Map) return Boolean with\n+     Global => null;\n \n-   function Length (Container : Map) return Count_Type;\n+   function Length (Container : Map) return Count_Type with\n+     Global => null;\n \n-   function Is_Empty (Container : Map) return Boolean;\n+   function Is_Empty (Container : Map) return Boolean with\n+     Global => null;\n \n-   procedure Clear (Container : in out Map);\n+   procedure Clear (Container : in out Map) with\n+     Global => null;\n \n    procedure Assign (Target : in out Map; Source : Map) with\n-     Pre => Target.Capacity >= Length (Source);\n+     Global => null,\n+     Pre    => Target.Capacity >= Length (Source);\n \n    function Copy (Source : Map; Capacity : Count_Type := 0) return Map with\n-     Pre => Capacity = 0 or else Capacity >= Source.Capacity;\n+     Global => null,\n+     Pre    => Capacity = 0 or else Capacity >= Source.Capacity;\n \n    function Key (Container : Map; Position : Cursor) return Key_Type with\n-     Pre => Has_Element (Container, Position);\n+     Global => null,\n+     Pre    => Has_Element (Container, Position);\n \n    function Element\n      (Container : Map;\n       Position  : Cursor) return Element_Type\n    with\n-     Pre => Has_Element (Container, Position);\n+     Global => null,\n+     Pre    => Has_Element (Container, Position);\n \n    procedure Replace_Element\n      (Container : in out Map;\n       Position  : Cursor;\n       New_Item  : Element_Type)\n    with\n-     Pre => Has_Element (Container, Position);\n+     Global => null,\n+     Pre    => Has_Element (Container, Position);\n \n    procedure Move (Target : in out Map; Source : in out Map) with\n-     Pre => Target.Capacity >= Length (Source);\n+     Global => null,\n+     Pre    => Target.Capacity >= Length (Source);\n \n    procedure Insert\n      (Container : in out Map;\n@@ -124,100 +135,130 @@ package Ada.Containers.Formal_Ordered_Maps is\n       Position  : out Cursor;\n       Inserted  : out Boolean)\n    with\n-     Pre => Length (Container) < Container.Capacity;\n+     Global => null,\n+     Pre    => Length (Container) < Container.Capacity;\n \n    procedure Insert\n      (Container : in out Map;\n       Key       : Key_Type;\n       New_Item  : Element_Type)\n    with\n-     Pre => Length (Container) < Container.Capacity\n-              and then (not Contains (Container, Key));\n+     Global => null,\n+     Pre    => Length (Container) < Container.Capacity\n+                 and then (not Contains (Container, Key));\n \n    procedure Include\n      (Container : in out Map;\n       Key       : Key_Type;\n       New_Item  : Element_Type)\n    with\n-     Pre => Length (Container) < Container.Capacity;\n+     Global => null,\n+     Pre    => Length (Container) < Container.Capacity;\n \n    procedure Replace\n      (Container : in out Map;\n       Key       : Key_Type;\n       New_Item  : Element_Type)\n    with\n-     Pre => Contains (Container, Key);\n+     Global => null,\n+     Pre    => Contains (Container, Key);\n \n-   procedure Exclude (Container : in out Map; Key : Key_Type);\n+   procedure Exclude (Container : in out Map; Key : Key_Type) with\n+     Global => null;\n \n    procedure Delete (Container : in out Map; Key : Key_Type) with\n-     Pre => Contains (Container, Key);\n+     Global => null,\n+     Pre    => Contains (Container, Key);\n \n    procedure Delete (Container : in out Map; Position : in out Cursor) with\n-     Pre => Has_Element (Container, Position);\n+     Global => null,\n+     Pre    => Has_Element (Container, Position);\n \n-   procedure Delete_First (Container : in out Map);\n+   procedure Delete_First (Container : in out Map) with\n+     Global => null;\n \n-   procedure Delete_Last (Container : in out Map);\n+   procedure Delete_Last (Container : in out Map) with\n+     Global => null;\n \n-   function First (Container : Map) return Cursor;\n+   function First (Container : Map) return Cursor with\n+     Global => null;\n \n    function First_Element (Container : Map) return Element_Type with\n-     Pre => not Is_Empty (Container);\n+     Global => null,\n+     Pre    => not Is_Empty (Container);\n \n    function First_Key (Container : Map) return Key_Type with\n-     Pre => not Is_Empty (Container);\n+     Global => null,\n+     Pre    => not Is_Empty (Container);\n \n-   function Last (Container : Map) return Cursor;\n+   function Last (Container : Map) return Cursor with\n+     Global => null;\n \n    function Last_Element (Container : Map) return Element_Type with\n-     Pre => not Is_Empty (Container);\n+     Global => null,\n+     Pre    => not Is_Empty (Container);\n \n    function Last_Key (Container : Map) return Key_Type with\n-     Pre => not Is_Empty (Container);\n+     Global => null,\n+     Pre    => not Is_Empty (Container);\n \n    function Next (Container : Map; Position : Cursor) return Cursor with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n \n    procedure Next (Container : Map; Position : in out Cursor) with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n \n    function Previous (Container : Map; Position : Cursor) return Cursor with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n \n    procedure Previous (Container : Map; Position : in out Cursor) with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n \n-   function Find (Container : Map; Key : Key_Type) return Cursor;\n+   function Find (Container : Map; Key : Key_Type) return Cursor with\n+     Global => null;\n \n    function Element (Container : Map; Key : Key_Type) return Element_Type with\n-     Pre => Contains (Container, Key);\n+     Global => null,\n+     Pre    => Contains (Container, Key);\n \n-   function Floor (Container : Map; Key : Key_Type) return Cursor;\n+   function Floor (Container : Map; Key : Key_Type) return Cursor with\n+     Global => null;\n \n-   function Ceiling (Container : Map; Key : Key_Type) return Cursor;\n+   function Ceiling (Container : Map; Key : Key_Type) return Cursor with\n+     Global => null;\n \n-   function Contains (Container : Map; Key : Key_Type) return Boolean;\n+   function Contains (Container : Map; Key : Key_Type) return Boolean with\n+     Global => null;\n \n-   function Has_Element (Container : Map; Position : Cursor) return Boolean;\n+   function Has_Element (Container : Map; Position : Cursor) return Boolean\n+   with\n+     Global => null;\n \n-   function Strict_Equal (Left, Right : Map) return Boolean;\n+   function Strict_Equal (Left, Right : Map) return Boolean with\n+     Global => null;\n    --  Strict_Equal returns True if the containers are physically equal, i.e.\n    --  they are structurally equal (function \"=\" returns True) and that they\n    --  have the same set of cursors.\n \n    function Left  (Container : Map; Position : Cursor) return Map with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n    function Right (Container : Map; Position : Cursor) return Map with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n    --  Left returns a container containing all elements preceding Position\n    --  (excluded) in Container. Right returns a container containing all\n    --  elements following Position (included) in Container. These two new\n    --  functions can be used to express invariant properties in loops which\n    --  iterate over containers. Left returns the part of the container already\n    --  scanned and Right the part not scanned yet.\n \n-   function Overlap (Left, Right : Map) return Boolean;\n+   function Overlap (Left, Right : Map) return Boolean with\n+     Global => null;\n    --  Overlap returns True if the containers have common keys\n private\n "}, {"sha": "5035e1c85a7bd4f5d6446866cfeee355625bea74", "filename": "gcc/ada/a-cforse.ads", "status": "modified", "additions": 123, "deletions": 57, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-cforse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-cforse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforse.ads?ref=47fb6ca83f9443beb6d113c93436748d42da08da", "patch": "@@ -66,7 +66,9 @@ package Ada.Containers.Formal_Ordered_Sets is\n    pragma Annotate (GNATprove, External_Axiomatization);\n    pragma Pure;\n \n-   function Equivalent_Elements (Left, Right : Element_Type) return Boolean;\n+   function Equivalent_Elements (Left, Right : Element_Type) return Boolean\n+   with\n+     Global => null;\n \n    type Set (Capacity : Count_Type) is private with\n      Iterable => (First       => First,\n@@ -82,148 +84,197 @@ package Ada.Containers.Formal_Ordered_Sets is\n \n    No_Element : constant Cursor;\n \n-   function \"=\" (Left, Right : Set) return Boolean;\n+   function \"=\" (Left, Right : Set) return Boolean with\n+     Global => null;\n \n-   function Equivalent_Sets (Left, Right : Set) return Boolean;\n+   function Equivalent_Sets (Left, Right : Set) return Boolean with\n+     Global => null;\n \n-   function To_Set (New_Item : Element_Type) return Set;\n+   function To_Set (New_Item : Element_Type) return Set with\n+     Global => null;\n \n-   function Length (Container : Set) return Count_Type;\n+   function Length (Container : Set) return Count_Type with\n+     Global => null;\n \n-   function Is_Empty (Container : Set) return Boolean;\n+   function Is_Empty (Container : Set) return Boolean with\n+     Global => null;\n \n-   procedure Clear (Container : in out Set);\n+   procedure Clear (Container : in out Set) with\n+     Global => null;\n \n    procedure Assign (Target : in out Set; Source : Set) with\n      Pre => Target.Capacity >= Length (Source);\n \n    function Copy (Source : Set; Capacity : Count_Type := 0) return Set with\n-     Pre => Capacity = 0 or else Capacity >= Source.Capacity;\n+     Global => null,\n+     Pre    => Capacity = 0 or else Capacity >= Source.Capacity;\n \n    function Element\n      (Container : Set;\n       Position  : Cursor) return Element_Type\n    with\n-     Pre => Has_Element (Container, Position);\n+     Global => null,\n+     Pre    => Has_Element (Container, Position);\n \n    procedure Replace_Element\n      (Container : in out Set;\n       Position  : Cursor;\n       New_Item  : Element_Type)\n    with\n-     Pre => Has_Element (Container, Position);\n+     Global => null,\n+     Pre    => Has_Element (Container, Position);\n \n    procedure Move (Target : in out Set; Source : in out Set) with\n-     Pre => Target.Capacity >= Length (Source);\n+     Global => null,\n+     Pre    => Target.Capacity >= Length (Source);\n \n    procedure Insert\n      (Container : in out Set;\n       New_Item  : Element_Type;\n       Position  : out Cursor;\n       Inserted  : out Boolean)\n    with\n-     Pre => Length (Container) < Container.Capacity;\n+     Global => null,\n+     Pre    => Length (Container) < Container.Capacity;\n \n    procedure Insert\n      (Container : in out Set;\n       New_Item  : Element_Type)\n    with\n-     Pre => Length (Container) < Container.Capacity\n-              and then (not Contains (Container, New_Item));\n+     Global => null,\n+     Pre    => Length (Container) < Container.Capacity\n+                 and then (not Contains (Container, New_Item));\n \n    procedure Include\n      (Container : in out Set;\n       New_Item  : Element_Type)\n    with\n-     Pre => Length (Container) < Container.Capacity;\n+     Global => null,\n+     Pre    => Length (Container) < Container.Capacity;\n \n    procedure Replace\n      (Container : in out Set;\n       New_Item  : Element_Type)\n    with\n-     Pre => Contains (Container, New_Item);\n+     Global => null,\n+     Pre    => Contains (Container, New_Item);\n \n    procedure Exclude\n      (Container : in out Set;\n-      Item      : Element_Type);\n+      Item      : Element_Type)\n+   with\n+     Global => null;\n \n    procedure Delete\n      (Container : in out Set;\n       Item      : Element_Type)\n    with\n-     Pre => Contains (Container, Item);\n+     Global => null,\n+     Pre    => Contains (Container, Item);\n \n    procedure Delete\n      (Container : in out Set;\n       Position  : in out Cursor)\n    with\n-     Pre => Has_Element (Container, Position);\n+     Global => null,\n+     Pre    => Has_Element (Container, Position);\n \n-   procedure Delete_First (Container : in out Set);\n+   procedure Delete_First (Container : in out Set) with\n+     Global => null;\n \n-   procedure Delete_Last (Container : in out Set);\n+   procedure Delete_Last (Container : in out Set) with\n+     Global => null;\n \n    procedure Union (Target : in out Set; Source : Set) with\n-     Pre => Length (Target) + Length (Source) -\n-              Length (Intersection (Target, Source)) <= Target.Capacity;\n+     Global => null,\n+     Pre    => Length (Target) + Length (Source) -\n+                 Length (Intersection (Target, Source)) <= Target.Capacity;\n \n-   function Union (Left, Right : Set) return Set;\n+   function Union (Left, Right : Set) return Set with\n+     Global => null,\n+     Pre    => Length (Left) + Length (Right) -\n+                 Length (Intersection (Left, Right)) <= Count_Type'Last;\n \n    function \"or\" (Left, Right : Set) return Set renames Union;\n \n-   procedure Intersection (Target : in out Set; Source : Set);\n+   procedure Intersection (Target : in out Set; Source : Set) with\n+     Global => null;\n \n-   function Intersection (Left, Right : Set) return Set;\n+   function Intersection (Left, Right : Set) return Set with\n+     Global => null;\n \n    function \"and\" (Left, Right : Set) return Set renames Intersection;\n \n-   procedure Difference (Target : in out Set; Source : Set);\n+   procedure Difference (Target : in out Set; Source : Set) with\n+     Global => null;\n \n-   function Difference (Left, Right : Set) return Set;\n+   function Difference (Left, Right : Set) return Set with\n+     Global => null;\n \n    function \"-\" (Left, Right : Set) return Set renames Difference;\n \n-   procedure Symmetric_Difference (Target : in out Set; Source : Set);\n+   procedure Symmetric_Difference (Target : in out Set; Source : Set) with\n+     Global => null,\n+     Pre    => Length (Target) + Length (Source) -\n+                 2 * Length (Intersection (Target, Source)) <= Target.Capacity;\n \n-   function Symmetric_Difference (Left, Right : Set) return Set;\n+   function Symmetric_Difference (Left, Right : Set) return Set with\n+     Global => null,\n+     Pre    => Length (Left) + Length (Right) -\n+                 2 * Length (Intersection (Left, Right)) <= Count_Type'Last;\n \n    function \"xor\" (Left, Right : Set) return Set renames Symmetric_Difference;\n \n-   function Overlap (Left, Right : Set) return Boolean;\n+   function Overlap (Left, Right : Set) return Boolean with\n+     Global => null;\n \n-   function Is_Subset (Subset : Set; Of_Set : Set) return Boolean;\n+   function Is_Subset (Subset : Set; Of_Set : Set) return Boolean with\n+     Global => null;\n \n-   function First (Container : Set) return Cursor;\n+   function First (Container : Set) return Cursor with\n+     Global => null;\n \n    function First_Element (Container : Set) return Element_Type with\n-     Pre => not Is_Empty (Container);\n+     Global => null,\n+     Pre    => not Is_Empty (Container);\n \n    function Last (Container : Set) return Cursor;\n \n    function Last_Element (Container : Set) return Element_Type with\n-     Pre => not Is_Empty (Container);\n+     Global => null,\n+     Pre    => not Is_Empty (Container);\n \n    function Next (Container : Set; Position : Cursor) return Cursor with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n \n    procedure Next (Container : Set; Position : in out Cursor) with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n \n    function Previous (Container : Set; Position : Cursor) return Cursor with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n \n    procedure Previous (Container : Set; Position : in out Cursor) with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n \n-   function Find (Container : Set; Item : Element_Type) return Cursor;\n+   function Find (Container : Set; Item : Element_Type) return Cursor with\n+     Global => null;\n \n-   function Floor (Container : Set; Item : Element_Type) return Cursor;\n+   function Floor (Container : Set; Item : Element_Type) return Cursor with\n+     Global => null;\n \n-   function Ceiling (Container : Set; Item : Element_Type) return Cursor;\n+   function Ceiling (Container : Set; Item : Element_Type) return Cursor with\n+     Global => null;\n \n-   function Contains (Container : Set; Item : Element_Type) return Boolean;\n+   function Contains (Container : Set; Item : Element_Type) return Boolean with\n+     Global => null;\n \n-   function Has_Element (Container : Set; Position : Cursor) return Boolean;\n+   function Has_Element (Container : Set; Position : Cursor) return Boolean\n+   with\n+     Global => null;\n \n    generic\n       type Key_Type (<>) is private;\n@@ -234,40 +285,55 @@ package Ada.Containers.Formal_Ordered_Sets is\n \n    package Generic_Keys is\n \n-      function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n+      function Equivalent_Keys (Left, Right : Key_Type) return Boolean with\n+        Global => null;\n \n-      function Key (Container : Set; Position : Cursor) return Key_Type;\n+      function Key (Container : Set; Position : Cursor) return Key_Type with\n+        Global => null;\n \n-      function Element (Container : Set; Key : Key_Type) return Element_Type;\n+      function Element (Container : Set; Key : Key_Type) return Element_Type\n+      with\n+        Global => null;\n \n       procedure Replace\n         (Container : in out Set;\n          Key       : Key_Type;\n-         New_Item  : Element_Type);\n+         New_Item  : Element_Type)\n+      with\n+        Global => null;\n \n-      procedure Exclude (Container : in out Set; Key : Key_Type);\n+      procedure Exclude (Container : in out Set; Key : Key_Type) with\n+        Global => null;\n \n-      procedure Delete (Container : in out Set; Key : Key_Type);\n+      procedure Delete (Container : in out Set; Key : Key_Type) with\n+        Global => null;\n \n-      function Find (Container : Set; Key : Key_Type) return Cursor;\n+      function Find (Container : Set; Key : Key_Type) return Cursor with\n+        Global => null;\n \n-      function Floor (Container : Set; Key : Key_Type) return Cursor;\n+      function Floor (Container : Set; Key : Key_Type) return Cursor with\n+        Global => null;\n \n-      function Ceiling (Container : Set; Key : Key_Type) return Cursor;\n+      function Ceiling (Container : Set; Key : Key_Type) return Cursor with\n+        Global => null;\n \n-      function Contains (Container : Set; Key : Key_Type) return Boolean;\n+      function Contains (Container : Set; Key : Key_Type) return Boolean with\n+        Global => null;\n \n    end Generic_Keys;\n \n-   function Strict_Equal (Left, Right : Set) return Boolean;\n+   function Strict_Equal (Left, Right : Set) return Boolean with\n+        Global => null;\n    --  Strict_Equal returns True if the containers are physically equal, i.e.\n    --  they are structurally equal (function \"=\" returns True) and that they\n    --  have the same set of cursors.\n \n    function Left  (Container : Set; Position : Cursor) return Set with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n    function Right (Container : Set; Position : Cursor) return Set with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n    --  Left returns a container containing all elements preceding Position\n    --  (excluded) in Container. Right returns a container containing all\n    --  elements following Position (included) in Container. These two new"}, {"sha": "13082c9c25b93f59a4684c8a2f1b23eecb9d350d", "filename": "gcc/ada/a-chtgbk.adb", "status": "modified", "additions": 132, "deletions": 49, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-chtgbk.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-chtgbk.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgbk.adb?ref=47fb6ca83f9443beb6d113c93436748d42da08da", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,6 +29,69 @@\n \n package body Ada.Containers.Hash_Tables.Generic_Bounded_Keys is\n \n+   -----------------------------\n+   -- Checked_Equivalent_Keys --\n+   -----------------------------\n+\n+   function Checked_Equivalent_Keys\n+     (HT   : aliased in out Hash_Table_Type'Class;\n+      Key  : Key_Type;\n+      Node : Count_Type) return Boolean\n+   is\n+      Result : Boolean;\n+\n+      B : Natural renames HT.Busy;\n+      L : Natural renames HT.Lock;\n+\n+   begin\n+      B := B + 1;\n+      L := L + 1;\n+\n+      Result := Equivalent_Keys (Key, HT.Nodes (Node));\n+\n+      B := B - 1;\n+      L := L - 1;\n+\n+      return Result;\n+   exception\n+      when others =>\n+         B := B - 1;\n+         L := L - 1;\n+\n+         raise;\n+   end Checked_Equivalent_Keys;\n+\n+   -------------------\n+   -- Checked_Index --\n+   -------------------\n+\n+   function Checked_Index\n+     (HT  : aliased in out Hash_Table_Type'Class;\n+      Key : Key_Type) return Hash_Type\n+   is\n+      Result : Hash_Type;\n+\n+      B : Natural renames HT.Busy;\n+      L : Natural renames HT.Lock;\n+\n+   begin\n+      B := B + 1;\n+      L := L + 1;\n+\n+      Result := HT.Buckets'First + Hash (Key) mod HT.Buckets'Length;\n+\n+      B := B - 1;\n+      L := L - 1;\n+\n+      return Result;\n+   exception\n+      when others =>\n+         B := B - 1;\n+         L := L - 1;\n+\n+         raise;\n+   end Checked_Index;\n+\n    --------------------------\n    -- Delete_Key_Sans_Free --\n    --------------------------\n@@ -47,14 +110,22 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Keys is\n          return;\n       end if;\n \n-      Indx := Index (HT, Key);\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      if HT.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (container is busy)\";\n+      end if;\n+\n+      Indx := Checked_Index (HT, Key);\n       X := HT.Buckets (Indx);\n \n       if X = 0 then\n          return;\n       end if;\n \n-      if Equivalent_Keys (Key, HT.Nodes (X)) then\n+      if Checked_Equivalent_Keys (HT, Key, X) then\n          if HT.Busy > 0 then\n             raise Program_Error with\n               \"attempt to tamper with cursors (container is busy)\";\n@@ -72,7 +143,7 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Keys is\n             return;\n          end if;\n \n-         if Equivalent_Keys (Key, HT.Nodes (X)) then\n+         if Checked_Equivalent_Keys (HT, Key, X) then\n             if HT.Busy > 0 then\n                raise Program_Error with\n                  \"attempt to tamper with cursors (container is busy)\";\n@@ -100,11 +171,13 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Keys is\n          return 0;\n       end if;\n \n-      Indx := Index (HT, Key);\n+      Indx := Checked_Index (HT'Unrestricted_Access.all, Key);\n \n       Node := HT.Buckets (Indx);\n       while Node /= 0 loop\n-         if Equivalent_Keys (Key, HT.Nodes (Node)) then\n+         if Checked_Equivalent_Keys\n+           (HT'Unrestricted_Access.all, Key, Node)\n+         then\n             return Node;\n          end if;\n          Node := Next (HT.Nodes (Node));\n@@ -123,16 +196,21 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Keys is\n       Node     : out Count_Type;\n       Inserted : out Boolean)\n    is\n-      Indx : constant Hash_Type := Index (HT, Key);\n-      B    : Count_Type renames HT.Buckets (Indx);\n+      Indx : Hash_Type;\n \n    begin\n-      if B = 0 then\n-         if HT.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors (container is busy)\";\n-         end if;\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      if HT.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (container is busy)\";\n+      end if;\n+\n+      Indx := Checked_Index (HT, Key);\n+      Node := HT.Buckets (Indx);\n \n+      if Node = 0 then\n          if HT.Length = HT.Capacity then\n             raise Capacity_Error with \"no more capacity for insertion\";\n          end if;\n@@ -142,15 +220,14 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Keys is\n \n          Inserted := True;\n \n-         B := Node;\n+         HT.Buckets (Indx) := Node;\n          HT.Length := HT.Length + 1;\n \n          return;\n       end if;\n \n-      Node := B;\n       loop\n-         if Equivalent_Keys (Key, HT.Nodes (Node)) then\n+         if Checked_Equivalent_Keys (HT, Key, Node) then\n             Inserted := False;\n             return;\n          end if;\n@@ -160,35 +237,19 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Keys is\n          exit when Node = 0;\n       end loop;\n \n-      if HT.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (container is busy)\";\n-      end if;\n-\n       if HT.Length = HT.Capacity then\n          raise Capacity_Error with \"no more capacity for insertion\";\n       end if;\n \n       Node := New_Node;\n-      Set_Next (HT.Nodes (Node), Next => B);\n+      Set_Next (HT.Nodes (Node), Next => HT.Buckets (Indx));\n \n       Inserted := True;\n \n-      B := Node;\n+      HT.Buckets (Indx) := Node;\n       HT.Length := HT.Length + 1;\n    end Generic_Conditional_Insert;\n \n-   -----------\n-   -- Index --\n-   -----------\n-\n-   function Index\n-     (HT  : Hash_Table_Type'Class;\n-      Key : Key_Type) return Hash_Type is\n-   begin\n-      return HT.Buckets'First + Hash (Key) mod HT.Buckets'Length;\n-   end Index;\n-\n    -----------------------------\n    -- Generic_Replace_Element --\n    -----------------------------\n@@ -204,24 +265,41 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Keys is\n       BB : Buckets_Type renames HT.Buckets;\n       NN : Nodes_Type renames HT.Nodes;\n \n-      Old_Hash : constant Hash_Type := Hash (NN (Node));\n-      Old_Indx : constant Hash_Type := BB'First + Old_Hash mod BB'Length;\n-\n-      New_Hash : constant Hash_Type := Hash (Key);\n-      New_Indx : constant Hash_Type := BB'First + New_Hash mod BB'Length;\n+      Old_Indx : Hash_Type;\n+      New_Indx : constant Hash_Type := Checked_Index (HT, Key);\n \n       New_Bucket : Count_Type renames BB (New_Indx);\n       N, M       : Count_Type;\n \n    begin\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      declare\n+         B : Natural renames HT.Busy;\n+         L : Natural renames HT.Lock;\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         Old_Indx := Hash (NN (Node)) mod HT.Buckets'Length;\n+\n+         B := B - 1;\n+         L := L - 1;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            L := L - 1;\n+\n+            raise;\n+      end;\n+\n       --  Replace_Element is allowed to change a node's key to Key\n       --  (generic formal operation Assign provides the mechanism), but\n       --  only if Key is not already in the hash table. (In a unique-key\n       --  hash table as this one, a key is mapped to exactly one node.)\n \n-      if Equivalent_Keys (Key, NN (Node)) then\n-         pragma Assert (New_Hash = Old_Hash);\n-\n+      if Checked_Equivalent_Keys (HT, Key, Node) then\n          if HT.Lock > 0 then\n             raise Program_Error with\n               \"attempt to tamper with elements (container is locked)\";\n@@ -231,8 +309,6 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Keys is\n          --  stays in the same bucket.\n \n          Assign (NN (Node), Key);\n-         pragma Assert (Hash (NN (Node)) = New_Hash);\n-         pragma Assert (Equivalent_Keys (Key, NN (Node)));\n          return;\n       end if;\n \n@@ -243,7 +319,7 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Keys is\n \n       N := New_Bucket;\n       while N /= 0 loop\n-         if Equivalent_Keys (Key, NN (N)) then\n+         if Checked_Equivalent_Keys (HT, Key, N) then\n             pragma Assert (N /= Node);\n             raise Program_Error with\n               \"attempt to replace existing element\";\n@@ -269,8 +345,6 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Keys is\n          end if;\n \n          Assign (NN (Node), Key);\n-         pragma Assert (Hash (NN (Node)) = New_Hash);\n-         pragma Assert (Equivalent_Keys (Key, NN (Node)));\n          return;\n       end if;\n \n@@ -286,8 +360,6 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Keys is\n       --  modified (except for any possible side-effect Assign had on Node).\n \n       Assign (NN (Node), Key);\n-      pragma Assert (Hash (NN (Node)) = New_Hash);\n-      pragma Assert (Equivalent_Keys (Key, NN (Node)));\n \n       --  Now we can safely remove the node from its current bucket\n \n@@ -319,4 +391,15 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Keys is\n       New_Bucket := Node;\n    end Generic_Replace_Element;\n \n+   -----------\n+   -- Index --\n+   -----------\n+\n+   function Index\n+     (HT  : Hash_Table_Type'Class;\n+      Key : Key_Type) return Hash_Type is\n+   begin\n+      return HT.Buckets'First + Hash (Key) mod HT.Buckets'Length;\n+   end Index;\n+\n end Ada.Containers.Hash_Tables.Generic_Bounded_Keys;"}, {"sha": "d6d207780f6e75e96cecb06fdb4ebb42368ec84e", "filename": "gcc/ada/a-chtgbk.ads", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-chtgbk.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-chtgbk.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgbk.ads?ref=47fb6ca83f9443beb6d113c93436748d42da08da", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -59,6 +59,20 @@ package Ada.Containers.Hash_Tables.Generic_Bounded_Keys is\n    pragma Inline (Index);\n    --  Returns the bucket number (array index value) for the given key\n \n+   function Checked_Index\n+     (HT  : aliased in out Hash_Table_Type'Class;\n+      Key : Key_Type) return Hash_Type;\n+   pragma Inline (Checked_Index);\n+   --  Calls Index, but also locks and unlocks the container, per AI05-0022, in\n+   --  order to detect element tampering by the generic actual Hash function.\n+\n+   function Checked_Equivalent_Keys\n+     (HT   : aliased in out Hash_Table_Type'Class;\n+      Key  : Key_Type;\n+      Node : Count_Type) return Boolean;\n+   --  Calls Equivalent_Keys, but locks and unlocks the container, per\n+   --  AI05-0022, in order to detect element tampering by that generic actual.\n+\n    procedure Delete_Key_Sans_Free\n      (HT  : in out Hash_Table_Type'Class;\n       Key : Key_Type;"}, {"sha": "f3376cad1df0b5ca5f17a54e37041c0d09005221", "filename": "gcc/ada/a-chtgbo.adb", "status": "modified", "additions": 78, "deletions": 7, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-chtgbo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-chtgbo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgbo.adb?ref=47fb6ca83f9443beb6d113c93436748d42da08da", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,6 +31,37 @@ with System;  use type System.Address;\n \n package body Ada.Containers.Hash_Tables.Generic_Bounded_Operations is\n \n+   -------------------\n+   -- Checked_Index --\n+   -------------------\n+\n+   function Checked_Index\n+     (Hash_Table : aliased in out Hash_Table_Type'Class;\n+      Node       : Count_Type) return Hash_Type\n+   is\n+      Result : Hash_Type;\n+\n+      B : Natural renames Hash_Table.Busy;\n+      L : Natural renames Hash_Table.Lock;\n+\n+   begin\n+      B := B + 1;\n+      L := L + 1;\n+\n+      Result := Index (Hash_Table, Hash_Table.Nodes (Node));\n+\n+      B := B - 1;\n+      L := L - 1;\n+\n+      return Result;\n+   exception\n+      when others =>\n+         B := B - 1;\n+         L := L - 1;\n+\n+         raise;\n+   end Checked_Index;\n+\n    -----------\n    -- Clear --\n    -----------\n@@ -69,7 +100,7 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Operations is\n            \"attempt to delete node from empty hashed container\";\n       end if;\n \n-      Indx := Index (HT, HT.Nodes (X));\n+      Indx := Checked_Index (HT, X);\n       Prev := HT.Buckets (Indx);\n \n       if Prev = 0 then\n@@ -288,6 +319,14 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Operations is\n    function Generic_Equal\n      (L, R : Hash_Table_Type'Class) return Boolean\n    is\n+      BL : Natural renames L'Unrestricted_Access.Busy;\n+      LL : Natural renames L'Unrestricted_Access.Lock;\n+\n+      BR : Natural renames R'Unrestricted_Access.Busy;\n+      LR : Natural renames R'Unrestricted_Access.Lock;\n+\n+      Result : Boolean;\n+\n       L_Index : Hash_Type;\n       L_Node  : Count_Type;\n \n@@ -315,13 +354,23 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Operations is\n          L_Index := L_Index + 1;\n       end loop;\n \n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      BL := BL + 1;\n+      LL := LL + 1;\n+\n+      BR := BR + 1;\n+      LR := LR + 1;\n+\n       --  For each node of hash table L, search for an equivalent node in hash\n       --  table R.\n \n       N := L.Length;\n       loop\n          if not Find (HT => R, Key => L.Nodes (L_Node)) then\n-            return False;\n+            Result := False;\n+            exit;\n          end if;\n \n          N := N - 1;\n@@ -332,7 +381,8 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Operations is\n             --  We have exhausted the nodes in this bucket\n \n             if N = 0 then\n-               return True;\n+               Result := True;\n+               exit;\n             end if;\n \n             --  Find the next bucket\n@@ -344,6 +394,23 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Operations is\n             end loop;\n          end if;\n       end loop;\n+\n+      BL := BL - 1;\n+      LL := LL - 1;\n+\n+      BR := BR - 1;\n+      LR := LR - 1;\n+\n+      return Result;\n+   exception\n+      when others =>\n+         BL := BL - 1;\n+         LL := LL - 1;\n+\n+         BR := BR - 1;\n+         LR := LR - 1;\n+\n+         raise;\n    end Generic_Equal;\n \n    -----------------------\n@@ -397,7 +464,7 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Operations is\n       for J in 1 .. N loop\n          declare\n             Node : constant Count_Type := New_Node (Stream);\n-            Indx : constant Hash_Type := Index (HT, HT.Nodes (Node));\n+            Indx : constant Hash_Type := Checked_Index (HT, Node);\n             B    : Count_Type renames HT.Buckets (Indx);\n          begin\n             Set_Next (HT.Nodes (Node), Next => B);\n@@ -461,17 +528,21 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Operations is\n      (HT   : Hash_Table_Type'Class;\n       Node : Count_Type) return Count_Type\n    is\n-      Result : Count_Type := Next (HT.Nodes (Node));\n+      Result : Count_Type;\n+      First  : Hash_Type;\n \n    begin\n+      Result := Next (HT.Nodes (Node));\n+\n       if Result /= 0 then  -- another node in same bucket\n          return Result;\n       end if;\n \n       --  This was the last node in the bucket, so move to the next\n       --  bucket, and start searching for next node from there.\n \n-      for Indx in Index (HT, HT.Nodes (Node)) + 1 .. HT.Buckets'Last loop\n+      First := Checked_Index (HT'Unrestricted_Access.all, Node) + 1;\n+      for Indx in First .. HT.Buckets'Last loop\n          Result := HT.Buckets (Indx);\n \n          if Result /= 0 then  -- bucket is not empty"}, {"sha": "0e9e9284018bef96866baaa30da22dd8413ac038", "filename": "gcc/ada/a-chtgbo.ads", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-chtgbo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-chtgbo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgbo.ads?ref=47fb6ca83f9443beb6d113c93436748d42da08da", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -62,6 +62,12 @@ package Ada.Containers.Hash_Tables.Generic_Bounded_Operations is\n    --  Uses the hash value of Node to compute its Hash_Table buckets array\n    --  index.\n \n+   function Checked_Index\n+     (Hash_Table : aliased in out Hash_Table_Type'Class;\n+      Node       : Count_Type) return Hash_Type;\n+   --  Calls Index, but also locks and unlocks the container, per AI05-0022, in\n+   --  order to detect element tampering by the generic actual Hash function.\n+\n    generic\n       with function Find\n         (HT  : Hash_Table_Type'Class;"}, {"sha": "e4de7712e7a8ceaf294d4eb732758ce42d1085a8", "filename": "gcc/ada/a-chtgke.adb", "status": "modified", "additions": 133, "deletions": 51, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-chtgke.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-chtgke.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgke.adb?ref=47fb6ca83f9443beb6d113c93436748d42da08da", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,6 +29,69 @@\n \n package body Ada.Containers.Hash_Tables.Generic_Keys is\n \n+   -----------------------------\n+   -- Checked_Equivalent_Keys --\n+   -----------------------------\n+\n+   function Checked_Equivalent_Keys\n+     (HT   : aliased in out Hash_Table_Type;\n+      Key  : Key_Type;\n+      Node : Node_Access) return Boolean\n+   is\n+      Result : Boolean;\n+\n+      B : Natural renames HT.Busy;\n+      L : Natural renames HT.Lock;\n+\n+   begin\n+      B := B + 1;\n+      L := L + 1;\n+\n+      Result := Equivalent_Keys (Key, Node);\n+\n+      B := B - 1;\n+      L := L - 1;\n+\n+      return Result;\n+   exception\n+      when others =>\n+         B := B - 1;\n+         L := L - 1;\n+\n+         raise;\n+   end Checked_Equivalent_Keys;\n+\n+   -------------------\n+   -- Checked_Index --\n+   -------------------\n+\n+   function Checked_Index\n+     (HT  : aliased in out Hash_Table_Type;\n+      Key : Key_Type) return Hash_Type\n+   is\n+      Result : Hash_Type;\n+\n+      B : Natural renames HT.Busy;\n+      L : Natural renames HT.Lock;\n+\n+   begin\n+      B := B + 1;\n+      L := L + 1;\n+\n+      Result := Hash (Key) mod HT.Buckets'Length;\n+\n+      B := B - 1;\n+      L := L - 1;\n+\n+      return Result;\n+   exception\n+      when others =>\n+         B := B - 1;\n+         L := L - 1;\n+\n+         raise;\n+   end Checked_Index;\n+\n    --------------------------\n    -- Delete_Key_Sans_Free --\n    --------------------------\n@@ -47,14 +110,22 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n          return;\n       end if;\n \n-      Indx := Index (HT, Key);\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      if HT.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (container is busy)\";\n+      end if;\n+\n+      Indx := Checked_Index (HT, Key);\n       X := HT.Buckets (Indx);\n \n       if X = null then\n          return;\n       end if;\n \n-      if Equivalent_Keys (Key, X) then\n+      if Checked_Equivalent_Keys (HT, Key, X) then\n          if HT.Busy > 0 then\n             raise Program_Error with\n               \"attempt to tamper with cursors (container is busy)\";\n@@ -72,7 +143,7 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n             return;\n          end if;\n \n-         if Equivalent_Keys (Key, X) then\n+         if Checked_Equivalent_Keys (HT, Key, X) then\n             if HT.Busy > 0 then\n                raise Program_Error with\n                  \"attempt to tamper with cursors (container is busy)\";\n@@ -89,9 +160,9 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n    ----------\n \n    function Find\n-     (HT  : Hash_Table_Type;\n-      Key : Key_Type) return Node_Access is\n-\n+     (HT  : aliased in out Hash_Table_Type;\n+      Key : Key_Type) return Node_Access\n+   is\n       Indx : Hash_Type;\n       Node : Node_Access;\n \n@@ -100,11 +171,11 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n          return null;\n       end if;\n \n-      Indx := Index (HT, Key);\n+      Indx := Checked_Index (HT, Key);\n \n       Node := HT.Buckets (Indx);\n       while Node /= null loop\n-         if Equivalent_Keys (Key, Node) then\n+         if Checked_Equivalent_Keys (HT, Key, Node) then\n             return Node;\n          end if;\n          Node := Next (Node);\n@@ -123,32 +194,36 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n       Node     : out Node_Access;\n       Inserted : out Boolean)\n    is\n-      Indx : constant Hash_Type := Index (HT, Key);\n-      B    : Node_Access renames HT.Buckets (Indx);\n+      Indx : Hash_Type;\n \n    begin\n-      if B = null then\n-         if HT.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors (container is busy)\";\n-         end if;\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      if HT.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (container is busy)\";\n+      end if;\n+\n+      Indx := Checked_Index (HT, Key);\n+      Node := HT.Buckets (Indx);\n \n+      if Node = null then\n          if HT.Length = Count_Type'Last then\n             raise Constraint_Error;\n          end if;\n \n          Node := New_Node (Next => null);\n          Inserted := True;\n \n-         B := Node;\n+         HT.Buckets (Indx) := Node;\n          HT.Length := HT.Length + 1;\n \n          return;\n       end if;\n \n-      Node := B;\n       loop\n-         if Equivalent_Keys (Key, Node) then\n+         if Checked_Equivalent_Keys (HT, Key, Node) then\n             Inserted := False;\n             return;\n          end if;\n@@ -158,33 +233,17 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n          exit when Node = null;\n       end loop;\n \n-      if HT.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (container is busy)\";\n-      end if;\n-\n       if HT.Length = Count_Type'Last then\n          raise Constraint_Error;\n       end if;\n \n-      Node := New_Node (Next => B);\n+      Node := New_Node (Next => HT.Buckets (Indx));\n       Inserted := True;\n \n-      B := Node;\n+      HT.Buckets (Indx) := Node;\n       HT.Length := HT.Length + 1;\n    end Generic_Conditional_Insert;\n \n-   -----------\n-   -- Index --\n-   -----------\n-\n-   function Index\n-     (HT  : Hash_Table_Type;\n-      Key : Key_Type) return Hash_Type is\n-   begin\n-      return Hash (Key) mod HT.Buckets'Length;\n-   end Index;\n-\n    -----------------------------\n    -- Generic_Replace_Element --\n    -----------------------------\n@@ -197,19 +256,36 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n       pragma Assert (HT.Length > 0);\n       pragma Assert (Node /= null);\n \n-      Old_Hash : constant Hash_Type := Hash (Node);\n-      Old_Indx : constant Hash_Type := Old_Hash mod HT.Buckets'Length;\n-\n-      New_Hash : constant Hash_Type := Hash (Key);\n-      New_Indx : constant Hash_Type := New_Hash mod HT.Buckets'Length;\n+      Old_Indx : Hash_Type;\n+      New_Indx : constant Hash_Type := Checked_Index (HT, Key);\n \n       New_Bucket : Node_Access renames HT.Buckets (New_Indx);\n       N, M       : Node_Access;\n \n    begin\n-      if Equivalent_Keys (Key, Node) then\n-         pragma Assert (New_Hash = Old_Hash);\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      declare\n+         B : Natural renames HT.Busy;\n+         L : Natural renames HT.Lock;\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         Old_Indx := Hash (Node) mod HT.Buckets'Length;\n \n+         B := B - 1;\n+         L := L - 1;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            L := L - 1;\n+\n+            raise;\n+      end;\n+\n+      if Checked_Equivalent_Keys (HT, Key, Node) then\n          if HT.Lock > 0 then\n             raise Program_Error with\n               \"attempt to tamper with elements (container is locked)\";\n@@ -222,8 +298,6 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n          --  change is allowed.\n \n          Assign (Node, Key);\n-         pragma Assert (Hash (Node) = New_Hash);\n-         pragma Assert (Equivalent_Keys (Key, Node));\n          return;\n       end if;\n \n@@ -234,7 +308,7 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n \n       N := New_Bucket;\n       while N /= null loop\n-         if Equivalent_Keys (Key, N) then\n+         if Checked_Equivalent_Keys (HT, Key, N) then\n             pragma Assert (N /= Node);\n             raise Program_Error with\n               \"attempt to replace existing element\";\n@@ -260,8 +334,6 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n          end if;\n \n          Assign (Node, Key);\n-         pragma Assert (Hash (Node) = New_Hash);\n-         pragma Assert (Equivalent_Keys (Key, Node));\n          return;\n       end if;\n \n@@ -277,8 +349,6 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n       --  modified (except for any possible side-effect Assign had on Node).\n \n       Assign (Node, Key);\n-      pragma Assert (Hash (Node) = New_Hash);\n-      pragma Assert (Equivalent_Keys (Key, Node));\n \n       --  Now we can safely remove the node from its current bucket\n \n@@ -310,4 +380,16 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n       New_Bucket := Node;\n    end Generic_Replace_Element;\n \n+   -----------\n+   -- Index --\n+   -----------\n+\n+   function Index\n+     (HT  : Hash_Table_Type;\n+      Key : Key_Type) return Hash_Type\n+   is\n+   begin\n+      return Hash (Key) mod HT.Buckets'Length;\n+   end Index;\n+\n end Ada.Containers.Hash_Tables.Generic_Keys;"}, {"sha": "37256e2eb59757f60822560b55bb8107fefd33ba", "filename": "gcc/ada/a-chtgke.ads", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-chtgke.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-chtgke.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgke.ads?ref=47fb6ca83f9443beb6d113c93436748d42da08da", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -59,6 +59,20 @@ package Ada.Containers.Hash_Tables.Generic_Keys is\n    pragma Inline (Index);\n    --  Returns the bucket number (array index value) for the given key\n \n+   function Checked_Index\n+     (HT  : aliased in out Hash_Table_Type;\n+      Key : Key_Type) return Hash_Type;\n+   pragma Inline (Checked_Index);\n+   --  Calls Index, but also locks and unlocks the container, per AI05-0022, in\n+   --  order to detect element tampering by the generic actual Hash function.\n+\n+   function Checked_Equivalent_Keys\n+     (HT   : aliased in out Hash_Table_Type;\n+      Key  : Key_Type;\n+      Node : Node_Access) return Boolean;\n+   --  Calls Equivalent_Keys, but locks and unlocks the container, per\n+   --  AI05-0022, in order to detect element tampering by that generic actual.\n+\n    procedure Delete_Key_Sans_Free\n      (HT  : in out Hash_Table_Type;\n       Key : Key_Type;\n@@ -67,7 +81,9 @@ package Ada.Containers.Hash_Tables.Generic_Keys is\n    --  without deallocating it. Program_Error is raised if the hash\n    --  table is busy.\n \n-   function Find (HT : Hash_Table_Type; Key : Key_Type) return Node_Access;\n+   function Find\n+     (HT  : aliased in out Hash_Table_Type;\n+      Key : Key_Type) return Node_Access;\n    --  Returns the node (if any) corresponding to the given key\n \n    generic"}, {"sha": "a0e0af16493dae200e1ead926de55777655788e0", "filename": "gcc/ada/a-chtgop.adb", "status": "modified", "additions": 91, "deletions": 11, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-chtgop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-chtgop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgop.adb?ref=47fb6ca83f9443beb6d113c93436748d42da08da", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -75,7 +75,7 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n \n                --  See note above\n \n-               pragma Assert (Index (HT, Dst_Node) = Src_Index);\n+               pragma Assert (Checked_Index (HT, Dst_Node) = Src_Index);\n \n             begin\n                HT.Buckets (Src_Index) := Dst_Node;\n@@ -91,7 +91,7 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n \n                   --  See note above\n \n-                  pragma Assert (Index (HT, Dst_Node) = Src_Index);\n+                  pragma Assert (Checked_Index (HT, Dst_Node) = Src_Index);\n \n                begin\n                   Set_Next (Node => Dst_Prev, Next => Dst_Node);\n@@ -121,6 +121,46 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n       return HT.Buckets'Length;\n    end Capacity;\n \n+   -------------------\n+   -- Checked_Index --\n+   -------------------\n+\n+   function Checked_Index\n+     (Hash_Table : aliased in out Hash_Table_Type;\n+      Buckets    : Buckets_Type;\n+      Node       : Node_Access) return Hash_Type\n+   is\n+      Result : Hash_Type;\n+\n+      B : Natural renames Hash_Table.Busy;\n+      L : Natural renames Hash_Table.Lock;\n+\n+   begin\n+      B := B + 1;\n+      L := L + 1;\n+\n+      Result := Index (Buckets, Node);\n+\n+      B := B - 1;\n+      L := L - 1;\n+\n+      return Result;\n+   exception\n+      when others =>\n+         B := B - 1;\n+         L := L - 1;\n+\n+         raise;\n+   end Checked_Index;\n+\n+   function Checked_Index\n+     (Hash_Table : aliased in out Hash_Table_Type;\n+      Node       : Node_Access) return Hash_Type\n+   is\n+   begin\n+      return Checked_Index (Hash_Table, Hash_Table.Buckets.all, Node);\n+   end Checked_Index;\n+\n    -----------\n    -- Clear --\n    -----------\n@@ -174,7 +214,7 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n            \"attempt to delete node from empty hashed container\";\n       end if;\n \n-      Indx := Index (HT, X);\n+      Indx := Checked_Index (HT, X);\n       Prev := HT.Buckets (Indx);\n \n       if Prev = null then\n@@ -288,6 +328,14 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n    function Generic_Equal\n      (L, R : Hash_Table_Type) return Boolean\n    is\n+      BL : Natural renames L'Unrestricted_Access.Busy;\n+      LL : Natural renames L'Unrestricted_Access.Lock;\n+\n+      BR : Natural renames R'Unrestricted_Access.Busy;\n+      LR : Natural renames R'Unrestricted_Access.Lock;\n+\n+      Result : Boolean;\n+\n       L_Index : Hash_Type;\n       L_Node  : Node_Access;\n \n@@ -315,13 +363,23 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n          L_Index := L_Index + 1;\n       end loop;\n \n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      BL := BL + 1;\n+      LL := LL + 1;\n+\n+      BR := BR + 1;\n+      LR := LR + 1;\n+\n       --  For each node of hash table L, search for an equivalent node in hash\n       --  table R.\n \n       N := L.Length;\n       loop\n          if not Find (HT => R, Key => L_Node) then\n-            return False;\n+            Result := False;\n+            exit;\n          end if;\n \n          N := N - 1;\n@@ -332,7 +390,8 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n             --  We have exhausted the nodes in this bucket\n \n             if N = 0 then\n-               return True;\n+               Result := True;\n+               exit;\n             end if;\n \n             --  Find the next bucket\n@@ -344,6 +403,23 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n             end loop;\n          end if;\n       end loop;\n+\n+      BL := BL - 1;\n+      LL := LL - 1;\n+\n+      BR := BR - 1;\n+      LR := LR - 1;\n+\n+      return Result;\n+   exception\n+      when others =>\n+         BL := BL - 1;\n+         LL := LL - 1;\n+\n+         BR := BR - 1;\n+         LR := LR - 1;\n+\n+         raise;\n    end Generic_Equal;\n \n    -----------------------\n@@ -407,7 +483,7 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n       for J in 1 .. N loop\n          declare\n             Node : constant Node_Access := New_Node (Stream);\n-            Indx : constant Hash_Type := Index (HT, Node);\n+            Indx : constant Hash_Type := Checked_Index (HT, Node);\n             B    : Node_Access renames HT.Buckets (Indx);\n          begin\n             Set_Next (Node => Node, Next => B);\n@@ -513,17 +589,21 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n    ----------\n \n    function Next\n-     (HT   : Hash_Table_Type;\n+     (HT   : aliased in out Hash_Table_Type;\n       Node : Node_Access) return Node_Access\n    is\n-      Result : Node_Access := Next (Node);\n+      Result : Node_Access;\n+      First  : Hash_Type;\n \n    begin\n+      Result := Next (Node);\n+\n       if Result /= null then\n          return Result;\n       end if;\n \n-      for Indx in Index (HT, Node) + 1 .. HT.Buckets'Last loop\n+      First := Checked_Index (HT, Node) + 1;\n+      for Indx in First .. HT.Buckets'Last loop\n          Result := HT.Buckets (Indx);\n \n          if Result /= null then\n@@ -643,7 +723,7 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n                      Src_Node : constant Node_Access := Src_Bucket;\n \n                      Dst_Index : constant Hash_Type :=\n-                       Index (Dst_Buckets.all, Src_Node);\n+                       Checked_Index (HT, Dst_Buckets.all, Src_Node);\n \n                      Dst_Bucket : Node_Access renames Dst_Buckets (Dst_Index);\n "}, {"sha": "c8e22c30ca57f4de967624fac7e7cbcf502b205e", "filename": "gcc/ada/a-chtgop.ads", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-chtgop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-chtgop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgop.ads?ref=47fb6ca83f9443beb6d113c93436748d42da08da", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -71,6 +71,18 @@ package Ada.Containers.Hash_Tables.Generic_Operations is\n    --  Uses the hash value of Node to compute its Hash_Table buckets array\n    --  index.\n \n+   function Checked_Index\n+     (Hash_Table : aliased in out Hash_Table_Type;\n+      Buckets    : Buckets_Type;\n+      Node       : Node_Access) return Hash_Type;\n+   --  Calls Index, but also locks and unlocks the container, per AI05-0022, in\n+   --  order to detect element tampering by the generic actual Hash function.\n+\n+   function Checked_Index\n+     (Hash_Table : aliased in out Hash_Table_Type;\n+      Node       : Node_Access) return Hash_Type;\n+   --  Calls Checked_Index using Hash_Table's buckets array.\n+\n    procedure Adjust (HT : in out Hash_Table_Type);\n    --  Used to implement controlled Adjust. It is assumed that HT has the value\n    --  of the bit-wise copy that immediately follows controlled Finalize.\n@@ -126,7 +138,7 @@ package Ada.Containers.Hash_Tables.Generic_Operations is\n    --  bucket.\n \n    function Next\n-     (HT   : Hash_Table_Type;\n+     (HT   : aliased in out Hash_Table_Type;\n       Node : Node_Access) return Node_Access;\n    --  Returns the node that immediately follows Node. This corresponds to\n    --  either the next node in the same bucket, or (if Node is the last node in"}, {"sha": "41a5eb1ef53e28eab78369713f3e96cfe78fb1cf", "filename": "gcc/ada/a-cihama.adb", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-cihama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-cihama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihama.adb?ref=47fb6ca83f9443beb6d113c93436748d42da08da", "patch": "@@ -238,7 +238,8 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n      (Container : aliased Map;\n       Key       : Key_Type) return Constant_Reference_Type\n    is\n-      Node : constant Node_Access := Key_Ops.Find (Container.HT, Key);\n+      HT   : Hash_Table_Type renames Container'Unrestricted_Access.HT;\n+      Node : constant Node_Access := Key_Ops.Find (HT, Key);\n \n    begin\n       if Node = null then\n@@ -250,8 +251,6 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       end if;\n \n       declare\n-         M : Map renames Container'Unrestricted_Access.all;\n-         HT : Hash_Table_Type renames M.HT'Unrestricted_Access.all;\n          B : Natural renames HT.Busy;\n          L : Natural renames HT.Lock;\n       begin\n@@ -368,7 +367,8 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n    -------------\n \n    function Element (Container : Map; Key : Key_Type) return Element_Type is\n-      Node : constant Node_Access := Key_Ops.Find (Container.HT, Key);\n+      HT   : Hash_Table_Type renames Container'Unrestricted_Access.HT;\n+      Node : constant Node_Access := Key_Ops.Find (HT, Key);\n \n    begin\n       if Node = null then\n@@ -533,7 +533,8 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n    ----------\n \n    function Find (Container : Map; Key : Key_Type) return Cursor is\n-      Node : constant Node_Access := Key_Ops.Find (Container.HT, Key);\n+      HT   : Hash_Table_Type renames Container'Unrestricted_Access.HT;\n+      Node : constant Node_Access := Key_Ops.Find (HT, Key);\n \n    begin\n       if Node = null then\n@@ -1106,7 +1107,8 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n      (Container : aliased in out Map;\n       Key       : Key_Type) return Reference_Type\n    is\n-      Node : constant Node_Access := Key_Ops.Find (Container.HT, Key);\n+      HT   : Hash_Table_Type renames Container.HT;\n+      Node : constant Node_Access := Key_Ops.Find (HT, Key);\n \n    begin\n       if Node = null then\n@@ -1118,8 +1120,6 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       end if;\n \n       declare\n-         M : Map renames Container'Unrestricted_Access.all;\n-         HT : Hash_Table_Type renames M.HT'Unrestricted_Access.all;\n          B : Natural renames HT.Busy;\n          L : Natural renames HT.Lock;\n       begin\n@@ -1353,7 +1353,7 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n             return False;\n          end if;\n \n-         X := HT.Buckets (Key_Ops.Index (HT, Position.Node.Key.all));\n+         X := HT.Buckets (Key_Ops.Checked_Index (HT, Position.Node.Key.all));\n \n          for J in 1 .. HT.Length loop\n             if X = Position.Node then"}, {"sha": "bbd29e552ec0c612888988bc47ba693eb3505fa8", "filename": "gcc/ada/a-cihase.adb", "status": "modified", "additions": 226, "deletions": 56, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-cihase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-cihase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihase.adb?ref=47fb6ca83f9443beb6d113c93436748d42da08da", "patch": "@@ -75,7 +75,9 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       Node     : out Node_Access;\n       Inserted : out Boolean);\n \n-   function Is_In (HT  : Hash_Table_Type; Key : Node_Access) return Boolean;\n+   function Is_In\n+     (HT  : aliased in out Hash_Table_Type;\n+      Key : Node_Access) return Boolean;\n    pragma Inline (Is_In);\n \n    function Next (Node : Node_Access) return Node_Access;\n@@ -359,6 +361,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n      (Target : in out Set;\n       Source : Set)\n    is\n+      Src_HT   : Hash_Table_Type renames Source'Unrestricted_Access.HT;\n       Tgt_Node : Node_Access;\n \n    begin\n@@ -367,7 +370,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          return;\n       end if;\n \n-      if Source.HT.Length = 0 then\n+      if Src_HT.Length = 0 then\n          return;\n       end if;\n \n@@ -376,12 +379,12 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n            \"attempt to tamper with cursors (set is busy)\";\n       end if;\n \n-      if Source.HT.Length < Target.HT.Length then\n+      if Src_HT.Length < Target.HT.Length then\n          declare\n             Src_Node : Node_Access;\n \n          begin\n-            Src_Node := HT_Ops.First (Source.HT);\n+            Src_Node := HT_Ops.First (Src_HT);\n             while Src_Node /= null loop\n                Tgt_Node := Element_Keys.Find (Target.HT, Src_Node.Element.all);\n \n@@ -390,14 +393,14 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n                   Free (Tgt_Node);\n                end if;\n \n-               Src_Node := HT_Ops.Next (Source.HT, Src_Node);\n+               Src_Node := HT_Ops.Next (Src_HT, Src_Node);\n             end loop;\n          end;\n \n       else\n          Tgt_Node := HT_Ops.First (Target.HT);\n          while Tgt_Node /= null loop\n-            if Is_In (Source.HT, Tgt_Node) then\n+            if Is_In (Src_HT, Tgt_Node) then\n                declare\n                   X : Node_Access := Tgt_Node;\n                begin\n@@ -414,8 +417,10 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n    end Difference;\n \n    function Difference (Left, Right : Set) return Set is\n-      Buckets : HT_Types.Buckets_Access;\n-      Length  : Count_Type;\n+      Left_HT  : Hash_Table_Type renames Left'Unrestricted_Access.HT;\n+      Right_HT : Hash_Table_Type renames Right'Unrestricted_Access.HT;\n+      Buckets  : HT_Types.Buckets_Access;\n+      Length   : Count_Type;\n \n    begin\n       if Left'Address = Right'Address then\n@@ -450,12 +455,20 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n          procedure Process (L_Node : Node_Access) is\n          begin\n-            if not Is_In (Right.HT, L_Node) then\n+            if not Is_In (Right_HT, L_Node) then\n                declare\n-                  Src    : Element_Type renames L_Node.Element.all;\n-                  Indx   : constant Hash_Type := Hash (Src) mod Buckets'Length;\n+                  --  Per AI05-0022, the container implementation is required\n+                  --  to detect element tampering by a generic actual\n+                  --  subprogram, hence the use of Checked_Index instead of a\n+                  --  simple invocation of generic formal Hash.\n+\n+                  Indx   : constant Hash_Type :=\n+                    HT_Ops.Checked_Index (Left_HT, Buckets.all, L_Node);\n+\n                   Bucket : Node_Access renames Buckets (Indx);\n+                  Src    : Element_Type renames L_Node.Element.all;\n                   Tgt    : Element_Access := new Element_Type'(Src);\n+\n                begin\n                   Bucket := new Node_Type'(Tgt, Bucket);\n                exception\n@@ -538,6 +551,20 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       pragma Assert (Vet (Left), \"bad Left cursor in Equivalent_Elements\");\n       pragma Assert (Vet (Right), \"bad Right cursor in Equivalent_Elements\");\n \n+      --  AI05-0022 requires that a container implementation detect element\n+      --  tampering by a generic actual subprogram. However, the following case\n+      --  falls outside the scope of that AI. Randy Brukardt explained on the\n+      --  ARG list on 2013/02/07 that:\n+\n+      --  (Begin Quote):\n+      --  But for an operation like \"<\" [the ordered set analog of\n+      --  Equivalent_Elements], there is no need to \"dereference\" a cursor\n+      --  after the call to the generic formal parameter function, so nothing\n+      --  bad could happen if tampering is undetected. And the operation can\n+      --  safely return a result without a problem even if an element is\n+      --  deleted from the container.\n+      --  (End Quote).\n+\n       return Equivalent_Elements\n                (Left.Node.Element.all,\n                 Right.Node.Element.all);\n@@ -653,7 +680,8 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n      (Container : Set;\n       Item      : Element_Type) return Cursor\n    is\n-      Node : constant Node_Access := Element_Keys.Find (Container.HT, Item);\n+      HT   : Hash_Table_Type renames Container'Unrestricted_Access.HT;\n+      Node : constant Node_Access := Element_Keys.Find (HT, Item);\n    begin\n       return (if Node = null then No_Element\n               else Cursor'(Container'Unrestricted_Access, Node));\n@@ -904,6 +932,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n      (Target : in out Set;\n       Source : Set)\n    is\n+      Src_HT   : Hash_Table_Type renames Source'Unrestricted_Access.HT;\n       Tgt_Node : Node_Access;\n \n    begin\n@@ -923,7 +952,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n       Tgt_Node := HT_Ops.First (Target.HT);\n       while Tgt_Node /= null loop\n-         if Is_In (Source.HT, Tgt_Node) then\n+         if Is_In (Src_HT, Tgt_Node) then\n             Tgt_Node := HT_Ops.Next (Target.HT, Tgt_Node);\n \n          else\n@@ -939,8 +968,10 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n    end Intersection;\n \n    function Intersection (Left, Right : Set) return Set is\n-      Buckets : HT_Types.Buckets_Access;\n-      Length  : Count_Type;\n+      Left_HT  : Hash_Table_Type renames Left'Unrestricted_Access.HT;\n+      Right_HT : Hash_Table_Type renames Right'Unrestricted_Access.HT;\n+      Buckets  : HT_Types.Buckets_Access;\n+      Length   : Count_Type;\n \n    begin\n       if Left'Address = Right'Address then\n@@ -973,14 +1004,19 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n          procedure Process (L_Node : Node_Access) is\n          begin\n-            if Is_In (Right.HT, L_Node) then\n+            if Is_In (Right_HT, L_Node) then\n                declare\n-                  Src : Element_Type renames L_Node.Element.all;\n+                  --  Per AI05-0022, the container implementation is required\n+                  --  to detect element tampering by a generic actual\n+                  --  subprogram, hence the use of Checked_Index instead of a\n+                  --  simple invocation of generic formal Hash.\n \n-                  Indx : constant Hash_Type := Hash (Src) mod Buckets'Length;\n+                  Indx : constant Hash_Type :=\n+                    HT_Ops.Checked_Index (Left_HT, Buckets.all, L_Node);\n \n                   Bucket : Node_Access renames Buckets (Indx);\n \n+                  Src : Element_Type renames L_Node.Element.all;\n                   Tgt : Element_Access := new Element_Type'(Src);\n \n                begin\n@@ -1021,7 +1057,10 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n    -- Is_In --\n    -----------\n \n-   function Is_In (HT  : Hash_Table_Type; Key : Node_Access) return Boolean is\n+   function Is_In\n+     (HT  : aliased in out Hash_Table_Type;\n+      Key : Node_Access) return Boolean\n+   is\n    begin\n       return Element_Keys.Find (HT, Key.Element.all) /= null;\n    end Is_In;\n@@ -1034,6 +1073,8 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n      (Subset : Set;\n       Of_Set : Set) return Boolean\n    is\n+      Subset_HT   : Hash_Table_Type renames Subset'Unrestricted_Access.HT;\n+      Of_Set_HT   : Hash_Table_Type renames Of_Set'Unrestricted_Access.HT;\n       Subset_Node : Node_Access;\n \n    begin\n@@ -1045,13 +1086,13 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          return False;\n       end if;\n \n-      Subset_Node := HT_Ops.First (Subset.HT);\n+      Subset_Node := HT_Ops.First (Subset_HT);\n       while Subset_Node /= null loop\n-         if not Is_In (Of_Set.HT, Subset_Node) then\n+         if not Is_In (Of_Set_HT, Subset_Node) then\n             return False;\n          end if;\n \n-         Subset_Node := HT_Ops.Next (Subset.HT, Subset_Node);\n+         Subset_Node := HT_Ops.Next (Subset_HT, Subset_Node);\n       end loop;\n \n       return True;\n@@ -1186,6 +1227,8 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n    -------------\n \n    function Overlap (Left, Right : Set) return Boolean is\n+      Left_HT   : Hash_Table_Type renames Left'Unrestricted_Access.HT;\n+      Right_HT  : Hash_Table_Type renames Right'Unrestricted_Access.HT;\n       Left_Node : Node_Access;\n \n    begin\n@@ -1197,13 +1240,13 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          return True;\n       end if;\n \n-      Left_Node := HT_Ops.First (Left.HT);\n+      Left_Node := HT_Ops.First (Left_HT);\n       while Left_Node /= null loop\n-         if Is_In (Right.HT, Left_Node) then\n+         if Is_In (Right_HT, Left_Node) then\n             return True;\n          end if;\n \n-         Left_Node := HT_Ops.Next (Left.HT, Left_Node);\n+         Left_Node := HT_Ops.Next (Left_HT, Left_Node);\n       end loop;\n \n       return False;\n@@ -1396,22 +1439,34 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n      (Target : in out Set;\n       Source : Set)\n    is\n+      Tgt_HT : Hash_Table_Type renames Target.HT;\n+      Src_HT : Hash_Table_Type renames Source.HT'Unrestricted_Access.all;\n+\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      TB : Natural renames Tgt_HT.Busy;\n+      TL : Natural renames Tgt_HT.Lock;\n+\n+      SB : Natural renames Src_HT.Busy;\n+      SL : Natural renames Src_HT.Lock;\n+\n    begin\n       if Target'Address = Source'Address then\n          Clear (Target);\n          return;\n       end if;\n \n-      if Target.HT.Busy > 0 then\n+      if TB > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors (set is busy)\";\n       end if;\n \n       declare\n          N : constant Count_Type := Target.Length + Source.Length;\n       begin\n-         if N > HT_Ops.Capacity (Target.HT) then\n-            HT_Ops.Reserve_Capacity (Target.HT, N);\n+         if N > HT_Ops.Capacity (Tgt_HT) then\n+            HT_Ops.Reserve_Capacity (Tgt_HT, N);\n          end if;\n       end;\n \n@@ -1427,9 +1482,9 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n             procedure Process (Src_Node : Node_Access) is\n                E : Element_Type renames Src_Node.Element.all;\n-               B : Buckets_Type renames Target.HT.Buckets.all;\n+               B : Buckets_Type renames Tgt_HT.Buckets.all;\n                J : constant Hash_Type := Hash (E) mod B'Length;\n-               N : Count_Type renames Target.HT.Length;\n+               N : Count_Type renames Tgt_HT.Length;\n \n             begin\n                declare\n@@ -1448,7 +1503,29 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          --  Start of processing for Iterate_Source_When_Empty_Target\n \n          begin\n-            Iterate (Source.HT);\n+            TB := TB + 1;\n+            TL := TL + 1;\n+\n+            SB := SB + 1;\n+            SL := SL + 1;\n+\n+            Iterate (Src_HT);\n+\n+            SL := SL - 1;\n+            SB := SB - 1;\n+\n+            TL := TL - 1;\n+            TB := TB - 1;\n+\n+         exception\n+            when others =>\n+               SL := SL - 1;\n+               SB := SB - 1;\n+\n+               TL := TL - 1;\n+               TB := TB - 1;\n+\n+               raise;\n          end Iterate_Source_When_Empty_Target;\n \n       else\n@@ -1464,9 +1541,9 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n             procedure Process (Src_Node : Node_Access) is\n                E : Element_Type renames Src_Node.Element.all;\n-               B : Buckets_Type renames Target.HT.Buckets.all;\n+               B : Buckets_Type renames Tgt_HT.Buckets.all;\n                J : constant Hash_Type := Hash (E) mod B'Length;\n-               N : Count_Type renames Target.HT.Length;\n+               N : Count_Type renames Tgt_HT.Length;\n \n             begin\n                if B (J) = null then\n@@ -1527,14 +1604,38 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          --  Start of processing for Iterate_Source\n \n          begin\n-            Iterate (Source.HT);\n+            TB := TB + 1;\n+            TL := TL + 1;\n+\n+            SB := SB + 1;\n+            SL := SL + 1;\n+\n+            Iterate (Src_HT);\n+\n+            SL := SL - 1;\n+            SB := SB - 1;\n+\n+            TL := TL - 1;\n+            TB := TB - 1;\n+\n+         exception\n+            when others =>\n+               SL := SL - 1;\n+               SB := SB - 1;\n+\n+               TL := TL - 1;\n+               TB := TB - 1;\n+\n+               raise;\n          end Iterate_Source;\n       end if;\n    end Symmetric_Difference;\n \n    function Symmetric_Difference (Left, Right : Set) return Set is\n-      Buckets : HT_Types.Buckets_Access;\n-      Length  : Count_Type;\n+      Left_HT  : Hash_Table_Type renames Left'Unrestricted_Access.HT;\n+      Right_HT : Hash_Table_Type renames Right'Unrestricted_Access.HT;\n+      Buckets  : HT_Types.Buckets_Access;\n+      Length   : Count_Type;\n \n    begin\n       if Left'Address = Right'Address then\n@@ -1570,10 +1671,17 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n          procedure Process (L_Node : Node_Access) is\n          begin\n-            if not Is_In (Right.HT, L_Node) then\n+            if not Is_In (Right_HT, L_Node) then\n                declare\n                   E : Element_Type renames L_Node.Element.all;\n-                  J : constant Hash_Type := Hash (E) mod Buckets'Length;\n+\n+                  --  Per AI05-0022, the container implementation is required\n+                  --  to detect element tampering by a generic actual\n+                  --  subprogram, hence the use of Checked_Index instead of a\n+                  --  simple invocation of generic formal Hash.\n+\n+                  J : constant Hash_Type :=\n+                    HT_Ops.Checked_Index (Left_HT, Buckets.all, L_Node);\n \n                begin\n                   declare\n@@ -1594,7 +1702,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       --  Start of processing for Iterate_Left\n \n       begin\n-         Iterate (Left.HT);\n+         Iterate (Left_HT);\n       exception\n          when others =>\n             HT_Ops.Free_Hash_Table (Buckets);\n@@ -1613,10 +1721,17 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n          procedure Process (R_Node : Node_Access) is\n          begin\n-            if not Is_In (Left.HT, R_Node) then\n+            if not Is_In (Left_HT, R_Node) then\n                declare\n                   E : Element_Type renames R_Node.Element.all;\n-                  J : constant Hash_Type := Hash (E) mod Buckets'Length;\n+\n+                  --  Per AI05-0022, the container implementation is required\n+                  --  to detect element tampering by a generic actual\n+                  --  subprogram, hence the use of Checked_Index instead of a\n+                  --  simple invocation of generic formal Hash.\n+\n+                  J : constant Hash_Type :=\n+                    HT_Ops.Checked_Index (Right_HT, Buckets.all, R_Node);\n \n                begin\n                   declare\n@@ -1637,7 +1752,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       --  Start of processing for Iterate_Right\n \n       begin\n-         Iterate (Right.HT);\n+         Iterate (Right_HT);\n       exception\n          when others =>\n             HT_Ops.Free_Hash_Table (Buckets);\n@@ -1735,8 +1850,10 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n    end Union;\n \n    function Union (Left, Right : Set) return Set is\n-      Buckets : HT_Types.Buckets_Access;\n-      Length  : Count_Type;\n+      Left_HT  : Hash_Table_Type renames Left.HT'Unrestricted_Access.all;\n+      Right_HT : Hash_Table_Type renames Right.HT'Unrestricted_Access.all;\n+      Buckets  : HT_Types.Buckets_Access;\n+      Length   : Count_Type;\n \n    begin\n       if Left'Address = Right'Address then\n@@ -1781,12 +1898,29 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n                raise;\n          end Process;\n \n-      --  Start of processing for Process\n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram, hence the use of\n+         --  Checked_Index instead of a simple invocation of generic formal\n+         --  Hash.\n+\n+         B : Integer renames Left_HT.Busy;\n+         L : Integer renames Left_HT.Lock;\n+\n+      --  Start of processing for Iterate_Left\n \n       begin\n+         B := B + 1;\n+         L := L + 1;\n+\n          Iterate (Left.HT);\n+\n+         L := L - 1;\n+         B := B - 1;\n       exception\n          when others =>\n+            L := L - 1;\n+            B := B - 1;\n+\n             HT_Ops.Free_Hash_Table (Buckets);\n             raise;\n       end Iterate_Left;\n@@ -1830,12 +1964,41 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n             Length := Length + 1;\n          end Process;\n \n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram, hence the use of\n+         --  Checked_Index instead of a simple invocation of generic formal\n+         --  Hash.\n+\n+         LB : Integer renames Left_HT.Busy;\n+         LL : Integer renames Left_HT.Lock;\n+\n+         RB : Integer renames Right_HT.Busy;\n+         RL : Integer renames Right_HT.Lock;\n+\n       --  Start of processing for Iterate_Right\n \n       begin\n+         LB := LB + 1;\n+         LL := LL + 1;\n+\n+         RB := RB + 1;\n+         RL := RL + 1;\n+\n          Iterate (Right.HT);\n+\n+         RL := RL - 1;\n+         RB := RB - 1;\n+\n+         LL := LL - 1;\n+         LB := LB - 1;\n       exception\n          when others =>\n+            RL := RL - 1;\n+            RB := RB - 1;\n+\n+            LL := LL - 1;\n+            LB := LB - 1;\n+\n             HT_Ops.Free_Hash_Table (Buckets);\n             raise;\n       end Iterate_Right;\n@@ -1880,7 +2043,9 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n             return False;\n          end if;\n \n-         X := HT.Buckets (Element_Keys.Index (HT, Position.Node.Element.all));\n+         X := HT.Buckets (Element_Keys.Checked_Index\n+                            (HT,\n+                             Position.Node.Element.all));\n \n          for J in 1 .. HT.Length loop\n             if X = Position.Node then\n@@ -1974,8 +2139,8 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n         (Container : aliased Set;\n          Key       : Key_Type) return Constant_Reference_Type\n       is\n-         Node : constant Node_Access :=\n-           Key_Keys.Find (Container.HT, Key);\n+         HT   : Hash_Table_Type renames Container'Unrestricted_Access.HT;\n+         Node : constant Node_Access := Key_Keys.Find (HT, Key);\n \n       begin\n          if Node = null then\n@@ -1987,7 +2152,6 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          end if;\n \n          declare\n-            HT : Hash_Table_Type renames Container'Unrestricted_Access.all.HT;\n             B : Natural renames HT.Busy;\n             L : Natural renames HT.Lock;\n          begin\n@@ -2027,7 +2191,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          Key_Keys.Delete_Key_Sans_Free (Container.HT, Key, X);\n \n          if X = null then\n-            raise Constraint_Error with \"key not in map\";  --  ??? \"set\"\n+            raise Constraint_Error with \"key not in set\";\n          end if;\n \n          Free (X);\n@@ -2041,11 +2205,12 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n         (Container : Set;\n          Key       : Key_Type) return Element_Type\n       is\n-         Node : constant Node_Access := Key_Keys.Find (Container.HT, Key);\n+         HT   : Hash_Table_Type renames Container'Unrestricted_Access.HT;\n+         Node : constant Node_Access := Key_Keys.Find (HT, Key);\n \n       begin\n          if Node = null then\n-            raise Constraint_Error with \"key not in map\";  --  ??? \"set\"\n+            raise Constraint_Error with \"key not in set\";\n          end if;\n \n          return Node.Element.all;\n@@ -2084,7 +2249,8 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n         (Container : Set;\n          Key       : Key_Type) return Cursor\n       is\n-         Node : constant Node_Access := Key_Keys.Find (Container.HT, Key);\n+         HT   : Hash_Table_Type renames Container'Unrestricted_Access.HT;\n+         Node : constant Node_Access := Key_Keys.Find (HT, Key);\n       begin\n          return (if Node = null then No_Element\n                  else Cursor'(Container'Unrestricted_Access, Node));\n@@ -2240,7 +2406,8 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n            (Vet (Position),\n             \"bad cursor in Update_Element_Preserving_Key\");\n \n-         Indx := HT_Ops.Index (HT, Position.Node);\n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n \n          declare\n             E : Element_Type renames Position.Node.Element.all;\n@@ -2249,12 +2416,16 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n             B : Natural renames HT.Busy;\n             L : Natural renames HT.Lock;\n \n+            Eq : Boolean;\n+\n          begin\n             B := B + 1;\n             L := L + 1;\n \n             begin\n+               Indx := HT_Ops.Index (HT, Position.Node);\n                Process (E);\n+               Eq := Equivalent_Keys (K, Key (E));\n             exception\n                when others =>\n                   L := L - 1;\n@@ -2265,8 +2436,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n             L := L - 1;\n             B := B - 1;\n \n-            if Equivalent_Keys (K, Key (E)) then\n-               pragma Assert (Hash (K) = Hash (E));\n+            if Eq then\n                return;\n             end if;\n          end;"}, {"sha": "727941f2258f95cbd098fa089838b88b7ed4bd7f", "filename": "gcc/ada/a-cofove.ads", "status": "modified", "additions": 150, "deletions": 77, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-cofove.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-cofove.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.ads?ref=47fb6ca83f9443beb6d113c93436748d42da08da", "patch": "@@ -88,133 +88,165 @@ package Ada.Containers.Formal_Vectors is\n \n    No_Element : constant Cursor;\n \n-   function \"=\" (Left, Right : Vector) return Boolean;\n+   function \"=\" (Left, Right : Vector) return Boolean with\n+     Global => null;\n \n    function To_Vector\n      (New_Item : Element_Type;\n-      Length   : Count_Type) return Vector;\n+      Length   : Count_Type) return Vector\n+   with\n+     Global => null;\n \n-   function \"&\" (Left, Right : Vector) return Vector;\n+   function \"&\" (Left, Right : Vector) return Vector with\n+     Global => null,\n+     Pre    => Capacity_Range'Last - Length (Left) >= Length (Right);\n \n-   function \"&\" (Left : Vector; Right : Element_Type) return Vector;\n+   function \"&\" (Left : Vector; Right : Element_Type) return Vector with\n+     Global => null,\n+     Pre    => Length (Left) < Capacity_Range'Last;\n \n-   function \"&\" (Left : Element_Type; Right : Vector) return Vector;\n+   function \"&\" (Left : Element_Type; Right : Vector) return Vector with\n+     Global => null,\n+     Pre    => Length (Right) < Capacity_Range'Last;\n \n-   function \"&\" (Left, Right : Element_Type) return Vector;\n+   function \"&\" (Left, Right : Element_Type) return Vector with\n+     Global => null,\n+     Pre    => Capacity_Range'Last >= 2;\n \n-   function Capacity (Container : Vector) return Count_Type;\n+   function Capacity (Container : Vector) return Count_Type with\n+     Global => null;\n \n    procedure Reserve_Capacity\n      (Container : in out Vector;\n       Capacity  : Count_Type)\n    with\n-     Pre => Capacity <= Container.Capacity;\n+     Global => null,\n+     Pre    => Capacity <= Container.Capacity;\n \n-   function Length (Container : Vector) return Count_Type;\n+   function Length (Container : Vector) return Count_Type with\n+     Global => null;\n \n    procedure Set_Length\n      (Container : in out Vector;\n       New_Length    : Count_Type)\n    with\n-     Pre => New_Length <= Length (Container);\n+     Global => null,\n+     Pre    => New_Length <= Length (Container);\n \n-   function Is_Empty (Container : Vector) return Boolean;\n+   function Is_Empty (Container : Vector) return Boolean with\n+     Global => null;\n \n-   procedure Clear (Container : in out Vector);\n+   procedure Clear (Container : in out Vector) with\n+     Global => null;\n \n    procedure Assign (Target : in out Vector; Source : Vector) with\n-     Pre => Length (Source) <= Target.Capacity;\n+     Global => null,\n+     Pre    => Length (Source) <= Target.Capacity;\n \n    function Copy\n      (Source   : Vector;\n       Capacity : Count_Type := 0) return Vector\n    with\n-     Pre => Length (Source) <= Capacity and then Capacity in Capacity_Range;\n+     Global => null,\n+     Pre    => Length (Source) <= Capacity and then Capacity in Capacity_Range;\n \n    function To_Cursor\n      (Container : Vector;\n-      Index     : Extended_Index) return Cursor;\n+      Index     : Extended_Index) return Cursor\n+   with\n+     Global => null;\n \n-   function To_Index (Position : Cursor) return Extended_Index;\n+   function To_Index (Position : Cursor) return Extended_Index with\n+     Global => null;\n \n    function Element\n      (Container : Vector;\n       Index     : Index_Type) return Element_Type\n    with\n-     Pre => First_Index (Container) <= Index\n-              and then Index <= Last_Index (Container);\n+     Global => null,\n+     Pre    => First_Index (Container) <= Index\n+                 and then Index <= Last_Index (Container);\n \n    function Element\n      (Container : Vector;\n       Position  : Cursor) return Element_Type\n    with\n-     Pre => Has_Element (Container, Position);\n+     Global => null,\n+     Pre    => Has_Element (Container, Position);\n \n    procedure Replace_Element\n      (Container : in out Vector;\n       Index     : Index_Type;\n       New_Item  : Element_Type)\n    with\n-     Pre => First_Index (Container) <= Index\n-              and then Index <= Last_Index (Container);\n+     Global => null,\n+     Pre    => First_Index (Container) <= Index\n+                 and then Index <= Last_Index (Container);\n \n    procedure Replace_Element\n      (Container : in out Vector;\n       Position  : Cursor;\n       New_Item  : Element_Type)\n    with\n-     Pre => Has_Element (Container, Position);\n+     Global => null,\n+     Pre    => Has_Element (Container, Position);\n \n    procedure Move (Target : in out Vector; Source : in out Vector) with\n-     Pre => Length (Source) <= Target.Capacity;\n+     Global => null,\n+     Pre    => Length (Source) <= Target.Capacity;\n \n    procedure Insert\n      (Container : in out Vector;\n       Before    : Extended_Index;\n       New_Item  : Vector)\n    with\n-     Pre => First_Index (Container) <= Before\n-              and then Before <= Last_Index (Container) + 1\n-              and then Length (Container) < Container.Capacity;\n+     Global => null,\n+     Pre    => First_Index (Container) <= Before\n+                 and then Before <= Last_Index (Container) + 1\n+                 and then Length (Container) < Container.Capacity;\n \n    procedure Insert\n      (Container : in out Vector;\n       Before    : Cursor;\n       New_Item  : Vector)\n    with\n-     Pre => Length (Container) < Container.Capacity\n-              and then (Has_Element (Container, Before)\n-                         or else Before = No_Element);\n+     Global => null,\n+     Pre    => Length (Container) < Container.Capacity\n+                 and then (Has_Element (Container, Before)\n+                            or else Before = No_Element);\n \n    procedure Insert\n      (Container : in out Vector;\n       Before    : Cursor;\n       New_Item  : Vector;\n       Position  : out Cursor)\n    with\n-     Pre => Length (Container) < Container.Capacity\n-              and then (Has_Element (Container, Before)\n-                         or else Before = No_Element);\n+     Global => null,\n+     Pre    => Length (Container) < Container.Capacity\n+                 and then (Has_Element (Container, Before)\n+                            or else Before = No_Element);\n \n    procedure Insert\n      (Container : in out Vector;\n       Before    : Extended_Index;\n       New_Item  : Element_Type;\n       Count     : Count_Type := 1)\n    with\n-     Pre => First_Index (Container) <= Before\n-              and then Before <= Last_Index (Container) + 1\n-              and then Length (Container) + Count <= Container.Capacity;\n+     Global => null,\n+     Pre    => First_Index (Container) <= Before\n+                 and then Before <= Last_Index (Container) + 1\n+                 and then Length (Container) + Count <= Container.Capacity;\n \n    procedure Insert\n      (Container : in out Vector;\n       Before    : Cursor;\n       New_Item  : Element_Type;\n       Count     : Count_Type := 1)\n    with\n-     Pre => Length (Container) + Count <= Container.Capacity\n-              and then (Has_Element (Container, Before)\n-                         or else Before = No_Element);\n+     Global => null,\n+     Pre    => Length (Container) + Count <= Container.Capacity\n+                 and then (Has_Element (Container, Before)\n+                            or else Before = No_Element);\n \n    procedure Insert\n      (Container : in out Vector;\n@@ -223,146 +255,187 @@ package Ada.Containers.Formal_Vectors is\n       Position  : out Cursor;\n       Count     : Count_Type := 1)\n    with\n-     Pre => Length (Container) + Count <= Container.Capacity\n-              and then (Has_Element (Container, Before)\n-                         or else Before = No_Element);\n+     Global => null,\n+     Pre    => Length (Container) + Count <= Container.Capacity\n+                 and then (Has_Element (Container, Before)\n+                            or else Before = No_Element);\n \n    procedure Prepend\n      (Container : in out Vector;\n       New_Item  : Vector)\n    with\n-     Pre => Length (Container) < Container.Capacity;\n+     Global => null,\n+     Pre    => Length (Container) < Container.Capacity;\n \n    procedure Prepend\n      (Container : in out Vector;\n       New_Item  : Element_Type;\n       Count     : Count_Type := 1)\n    with\n-     Pre => Length (Container) + Count <= Container.Capacity;\n+     Global => null,\n+     Pre    => Length (Container) + Count <= Container.Capacity;\n \n    procedure Append\n      (Container : in out Vector;\n       New_Item  : Vector)\n    with\n-     Pre => Length (Container) < Container.Capacity;\n+     Global => null,\n+     Pre    => Length (Container) < Container.Capacity;\n \n    procedure Append\n      (Container : in out Vector;\n       New_Item  : Element_Type;\n       Count     : Count_Type := 1)\n    with\n-     Pre => Length (Container) + Count <= Container.Capacity;\n+     Global => null,\n+     Pre    => Length (Container) + Count <= Container.Capacity;\n \n    procedure Delete\n      (Container : in out Vector;\n       Index     : Extended_Index;\n       Count     : Count_Type := 1)\n    with\n-     Pre => First_Index (Container) <= Index\n-              and then Index <= Last_Index (Container) + 1;\n+     Global => null,\n+     Pre    => First_Index (Container) <= Index\n+                 and then Index <= Last_Index (Container) + 1;\n \n    procedure Delete\n      (Container : in out Vector;\n       Position  : in out Cursor;\n       Count     : Count_Type := 1)\n    with\n-     Pre => Has_Element (Container, Position);\n+     Global => null,\n+     Pre    => Has_Element (Container, Position);\n \n    procedure Delete_First\n      (Container : in out Vector;\n-      Count     : Count_Type := 1);\n+      Count     : Count_Type := 1)\n+   with\n+     Global => null;\n \n    procedure Delete_Last\n      (Container : in out Vector;\n-      Count     : Count_Type := 1);\n+      Count     : Count_Type := 1)\n+   with\n+     Global => null;\n \n-   procedure Reverse_Elements (Container : in out Vector);\n+   procedure Reverse_Elements (Container : in out Vector) with\n+     Global => null;\n \n    procedure Swap (Container : in out Vector; I, J : Index_Type) with\n-     Pre => First_Index (Container) <= I and then I <= Last_Index (Container)\n-              and then First_Index (Container) <= J\n-              and then J <= Last_Index (Container);\n+     Global => null,\n+     Pre    => First_Index (Container) <= I\n+                 and then I <= Last_Index (Container)\n+                 and then First_Index (Container) <= J\n+                 and then J <= Last_Index (Container);\n \n    procedure Swap (Container : in out Vector; I, J : Cursor) with\n-     Pre => Has_Element (Container, I) and then Has_Element (Container, J);\n+     Global => null,\n+     Pre    => Has_Element (Container, I) and then Has_Element (Container, J);\n \n-   function First_Index (Container : Vector) return Index_Type;\n+   function First_Index (Container : Vector) return Index_Type with\n+     Global => null;\n \n-   function First (Container : Vector) return Cursor;\n+   function First (Container : Vector) return Cursor with\n+     Global => null;\n \n    function First_Element (Container : Vector) return Element_Type with\n-     Pre => not Is_Empty (Container);\n+     Global => null,\n+     Pre    => not Is_Empty (Container);\n \n-   function Last_Index (Container : Vector) return Extended_Index;\n+   function Last_Index (Container : Vector) return Extended_Index with\n+     Global => null;\n \n-   function Last (Container : Vector) return Cursor;\n+   function Last (Container : Vector) return Cursor with\n+     Global => null;\n \n    function Last_Element (Container : Vector) return Element_Type with\n-     Pre => not Is_Empty (Container);\n+     Global => null,\n+     Pre    => not Is_Empty (Container);\n \n    function Next (Container : Vector; Position : Cursor) return Cursor with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n \n    procedure Next (Container : Vector; Position : in out Cursor) with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n \n    function Previous (Container : Vector; Position : Cursor) return Cursor with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n \n    procedure Previous (Container : Vector; Position : in out Cursor) with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n \n    function Find_Index\n      (Container : Vector;\n       Item      : Element_Type;\n-      Index     : Index_Type := Index_Type'First) return Extended_Index;\n+      Index     : Index_Type := Index_Type'First) return Extended_Index\n+   with\n+     Global => null;\n \n    function Find\n      (Container : Vector;\n       Item      : Element_Type;\n       Position  : Cursor := No_Element) return Cursor\n    with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n \n    function Reverse_Find_Index\n      (Container : Vector;\n       Item      : Element_Type;\n-      Index     : Index_Type := Index_Type'Last) return Extended_Index;\n+      Index     : Index_Type := Index_Type'Last) return Extended_Index\n+   with\n+     Global => null;\n \n    function Reverse_Find\n      (Container : Vector;\n       Item      : Element_Type;\n       Position  : Cursor := No_Element) return Cursor\n    with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n \n    function Contains\n      (Container : Vector;\n-      Item      : Element_Type) return Boolean;\n+      Item      : Element_Type) return Boolean\n+   with\n+     Global => null;\n \n-   function Has_Element (Container : Vector; Position : Cursor) return Boolean;\n+   function Has_Element (Container : Vector; Position : Cursor) return Boolean\n+   with\n+     Global => null;\n \n    generic\n       with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n    package Generic_Sorting is\n \n-      function Is_Sorted (Container : Vector) return Boolean;\n+      function Is_Sorted (Container : Vector) return Boolean with\n+        Global => null;\n \n-      procedure Sort (Container : in out Vector);\n+      procedure Sort (Container : in out Vector) with\n+        Global => null;\n \n-      procedure Merge (Target : in out Vector; Source : in out Vector);\n+      procedure Merge (Target : in out Vector; Source : in out Vector) with\n+        Global => null;\n \n    end Generic_Sorting;\n \n-   function Strict_Equal (Left, Right : Vector) return Boolean;\n+   function Strict_Equal (Left, Right : Vector) return Boolean with\n+     Global => null;\n    --  Strict_Equal returns True if the containers are physically equal, i.e.\n    --  they are structurally equal (function \"=\" returns True) and that they\n    --  have the same set of cursors.\n \n    function Left (Container : Vector; Position : Cursor) return Vector with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n    function Right (Container : Vector; Position : Cursor) return Vector with\n-     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+     Global => null,\n+     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n    --  Left returns a container containing all elements preceding Position\n    --  (excluded) in Container. Right returns a container containing all\n    --  elements following Position (included) in Container. These two new"}, {"sha": "541e95a14e6db8741259614410c32fb357841a98", "filename": "gcc/ada/a-cohama.adb", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-cohama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-cohama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohama.adb?ref=47fb6ca83f9443beb6d113c93436748d42da08da", "patch": "@@ -230,15 +230,15 @@ package body Ada.Containers.Hashed_Maps is\n      (Container : aliased Map;\n       Key       : Key_Type) return Constant_Reference_Type\n    is\n-      Node : constant Node_Access := Key_Ops.Find (Container.HT, Key);\n+      HT   : Hash_Table_Type renames Container'Unrestricted_Access.HT;\n+      Node : constant Node_Access := Key_Ops.Find (HT, Key);\n \n    begin\n       if Node = null then\n          raise Constraint_Error with \"key not in map\";\n       end if;\n \n       declare\n-         HT : Hash_Table_Type renames Container'Unrestricted_Access.all.HT;\n          B  : Natural renames HT.Busy;\n          L  : Natural renames HT.Lock;\n       begin\n@@ -351,7 +351,8 @@ package body Ada.Containers.Hashed_Maps is\n    -------------\n \n    function Element (Container : Map; Key : Key_Type) return Element_Type is\n-      Node : constant Node_Access := Key_Ops.Find (Container.HT, Key);\n+      HT   : Hash_Table_Type renames Container'Unrestricted_Access.HT;\n+      Node : constant Node_Access := Key_Ops.Find (HT, Key);\n \n    begin\n       if Node = null then\n@@ -484,7 +485,8 @@ package body Ada.Containers.Hashed_Maps is\n    ----------\n \n    function Find (Container : Map; Key : Key_Type) return Cursor is\n-      Node : constant Node_Access := Key_Ops.Find (Container.HT, Key);\n+      HT   : Hash_Table_Type renames Container'Unrestricted_Access.HT;\n+      Node : constant Node_Access := Key_Ops.Find (HT, Key);\n \n    begin\n       if Node = null then\n@@ -978,15 +980,15 @@ package body Ada.Containers.Hashed_Maps is\n      (Container : aliased in out Map;\n       Key       : Key_Type) return Reference_Type\n    is\n-      Node : constant Node_Access := Key_Ops.Find (Container.HT, Key);\n+      HT   : Hash_Table_Type renames Container.HT;\n+      Node : constant Node_Access := Key_Ops.Find (HT, Key);\n \n    begin\n       if Node = null then\n          raise Constraint_Error with \"key not in map\";\n       end if;\n \n       declare\n-         HT : Hash_Table_Type renames Container'Unrestricted_Access.all.HT;\n          B  : Natural renames HT.Busy;\n          L  : Natural renames HT.Lock;\n       begin\n@@ -1181,7 +1183,7 @@ package body Ada.Containers.Hashed_Maps is\n             return False;\n          end if;\n \n-         X := HT.Buckets (Key_Ops.Index (HT, Position.Node.Key));\n+         X := HT.Buckets (Key_Ops.Checked_Index (HT, Position.Node.Key));\n \n          for J in 1 .. HT.Length loop\n             if X = Position.Node then"}, {"sha": "6126db3a7943f00faecdc8c745be8e1b6cb9dfd8", "filename": "gcc/ada/a-cohase.adb", "status": "modified", "additions": 223, "deletions": 57, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-cohase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fa-cohase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohase.adb?ref=47fb6ca83f9443beb6d113c93436748d42da08da", "patch": "@@ -76,7 +76,7 @@ package body Ada.Containers.Hashed_Sets is\n       Inserted : out Boolean);\n \n    function Is_In\n-     (HT  : Hash_Table_Type;\n+     (HT  : aliased in out Hash_Table_Type;\n       Key : Node_Access) return Boolean;\n    pragma Inline (Is_In);\n \n@@ -337,14 +337,15 @@ package body Ada.Containers.Hashed_Sets is\n       Source : Set)\n    is\n       Tgt_Node : Node_Access;\n+      Src_HT   : Hash_Table_Type renames Source'Unrestricted_Access.HT;\n \n    begin\n       if Target'Address = Source'Address then\n          Clear (Target);\n          return;\n       end if;\n \n-      if Source.HT.Length = 0 then\n+      if Src_HT.Length = 0 then\n          return;\n       end if;\n \n@@ -353,12 +354,12 @@ package body Ada.Containers.Hashed_Sets is\n            \"attempt to tamper with cursors (set is busy)\";\n       end if;\n \n-      if Source.HT.Length < Target.HT.Length then\n+      if Src_HT.Length < Target.HT.Length then\n          declare\n             Src_Node : Node_Access;\n \n          begin\n-            Src_Node := HT_Ops.First (Source.HT);\n+            Src_Node := HT_Ops.First (Src_HT);\n             while Src_Node /= null loop\n                Tgt_Node := Element_Keys.Find (Target.HT, Src_Node.Element);\n \n@@ -367,14 +368,14 @@ package body Ada.Containers.Hashed_Sets is\n                   Free (Tgt_Node);\n                end if;\n \n-               Src_Node := HT_Ops.Next (Source.HT, Src_Node);\n+               Src_Node := HT_Ops.Next (Src_HT, Src_Node);\n             end loop;\n          end;\n \n       else\n          Tgt_Node := HT_Ops.First (Target.HT);\n          while Tgt_Node /= null loop\n-            if Is_In (Source.HT, Tgt_Node) then\n+            if Is_In (Src_HT, Tgt_Node) then\n                declare\n                   X : Node_Access := Tgt_Node;\n                begin\n@@ -391,19 +392,21 @@ package body Ada.Containers.Hashed_Sets is\n    end Difference;\n \n    function Difference (Left, Right : Set) return Set is\n-      Buckets : HT_Types.Buckets_Access;\n-      Length  : Count_Type;\n+      Left_HT  : Hash_Table_Type renames Left'Unrestricted_Access.HT;\n+      Right_HT : Hash_Table_Type renames Right'Unrestricted_Access.HT;\n+      Buckets  : HT_Types.Buckets_Access;\n+      Length   : Count_Type;\n \n    begin\n       if Left'Address = Right'Address then\n          return Empty_Set;\n       end if;\n \n-      if Left.HT.Length = 0 then\n+      if Left_HT.Length = 0 then\n          return Empty_Set;\n       end if;\n \n-      if Right.HT.Length = 0 then\n+      if Right_HT.Length = 0 then\n          return Left;\n       end if;\n \n@@ -427,10 +430,15 @@ package body Ada.Containers.Hashed_Sets is\n \n          procedure Process (L_Node : Node_Access) is\n          begin\n-            if not Is_In (Right.HT, L_Node) then\n+            if not Is_In (Right_HT, L_Node) then\n                declare\n+                  --  Per AI05-0022, the container implementation is required\n+                  --  to detect element tampering by a generic actual\n+                  --  subprogram, hence the use of Checked_Index instead of a\n+                  --  simple invocation of generic formal Hash.\n+\n                   J : constant Hash_Type :=\n-                    Hash (L_Node.Element) mod Buckets'Length;\n+                    HT_Ops.Checked_Index (Left_HT, Buckets.all, L_Node);\n \n                   Bucket : Node_Access renames Buckets (J);\n \n@@ -445,7 +453,7 @@ package body Ada.Containers.Hashed_Sets is\n       --  Start of processing for Iterate_Left\n \n       begin\n-         Iterate (Left.HT);\n+         Iterate (Left_HT);\n       exception\n          when others =>\n             HT_Ops.Free_Hash_Table (Buckets);\n@@ -499,6 +507,20 @@ package body Ada.Containers.Hashed_Sets is\n       pragma Assert (Vet (Left), \"bad Left cursor in Equivalent_Elements\");\n       pragma Assert (Vet (Right), \"bad Right cursor in Equivalent_Elements\");\n \n+      --  AI05-0022 requires that a container implementation detect element\n+      --  tampering by a generic actual subprogram. However, the following case\n+      --  falls outside the scope of that AI. Randy Brukardt explained on the\n+      --  ARG list on 2013/02/07 that:\n+\n+      --  (Begin Quote):\n+      --  But for an operation like \"<\" [the ordered set analog of\n+      --  Equivalent_Elements], there is no need to \"dereference\" a cursor\n+      --  after the call to the generic formal parameter function, so nothing\n+      --  bad could happen if tampering is undetected. And the operation can\n+      --  safely return a result without a problem even if an element is\n+      --  deleted from the container.\n+      --  (End Quote).\n+\n       return Equivalent_Elements (Left.Node.Element, Right.Node.Element);\n    end Equivalent_Elements;\n \n@@ -587,7 +609,8 @@ package body Ada.Containers.Hashed_Sets is\n      (Container : Set;\n       Item      : Element_Type) return Cursor\n    is\n-      Node : constant Node_Access := Element_Keys.Find (Container.HT, Item);\n+      HT   : Hash_Table_Type renames Container'Unrestricted_Access.HT;\n+      Node : constant Node_Access := Element_Keys.Find (HT, Item);\n \n    begin\n       if Node = null then\n@@ -807,6 +830,7 @@ package body Ada.Containers.Hashed_Sets is\n      (Target : in out Set;\n       Source : Set)\n    is\n+      Src_HT   : Hash_Table_Type renames Source'Unrestricted_Access.HT;\n       Tgt_Node : Node_Access;\n \n    begin\n@@ -826,7 +850,7 @@ package body Ada.Containers.Hashed_Sets is\n \n       Tgt_Node := HT_Ops.First (Target.HT);\n       while Tgt_Node /= null loop\n-         if Is_In (Source.HT, Tgt_Node) then\n+         if Is_In (Src_HT, Tgt_Node) then\n             Tgt_Node := HT_Ops.Next (Target.HT, Tgt_Node);\n \n          else\n@@ -842,8 +866,10 @@ package body Ada.Containers.Hashed_Sets is\n    end Intersection;\n \n    function Intersection (Left, Right : Set) return Set is\n-      Buckets : HT_Types.Buckets_Access;\n-      Length  : Count_Type;\n+      Left_HT  : Hash_Table_Type renames Left'Unrestricted_Access.HT;\n+      Right_HT : Hash_Table_Type renames Right'Unrestricted_Access.HT;\n+      Buckets  : HT_Types.Buckets_Access;\n+      Length   : Count_Type;\n \n    begin\n       if Left'Address = Right'Address then\n@@ -876,10 +902,15 @@ package body Ada.Containers.Hashed_Sets is\n \n          procedure Process (L_Node : Node_Access) is\n          begin\n-            if Is_In (Right.HT, L_Node) then\n+            if Is_In (Right_HT, L_Node) then\n                declare\n+                  --  Per AI05-0022, the container implementation is required\n+                  --  to detect element tampering by a generic actual\n+                  --  subprogram, hence the use of Checked_Index instead of a\n+                  --  simple invocation of generic formal Hash.\n+\n                   J : constant Hash_Type :=\n-                    Hash (L_Node.Element) mod Buckets'Length;\n+                    HT_Ops.Checked_Index (Left_HT, Buckets.all, L_Node);\n \n                   Bucket : Node_Access renames Buckets (J);\n \n@@ -894,7 +925,7 @@ package body Ada.Containers.Hashed_Sets is\n       --  Start of processing for Iterate_Left\n \n       begin\n-         Iterate (Left.HT);\n+         Iterate (Left_HT);\n       exception\n          when others =>\n             HT_Ops.Free_Hash_Table (Buckets);\n@@ -917,7 +948,10 @@ package body Ada.Containers.Hashed_Sets is\n    -- Is_In --\n    -----------\n \n-   function Is_In (HT : Hash_Table_Type; Key : Node_Access) return Boolean is\n+   function Is_In\n+     (HT : aliased in out Hash_Table_Type;\n+      Key : Node_Access) return Boolean\n+   is\n    begin\n       return Element_Keys.Find (HT, Key.Element) /= null;\n    end Is_In;\n@@ -927,6 +961,8 @@ package body Ada.Containers.Hashed_Sets is\n    ---------------\n \n    function Is_Subset (Subset : Set; Of_Set : Set) return Boolean is\n+      Subset_HT   : Hash_Table_Type renames Subset'Unrestricted_Access.HT;\n+      Of_Set_HT   : Hash_Table_Type renames Of_Set'Unrestricted_Access.HT;\n       Subset_Node : Node_Access;\n \n    begin\n@@ -938,12 +974,12 @@ package body Ada.Containers.Hashed_Sets is\n          return False;\n       end if;\n \n-      Subset_Node := HT_Ops.First (Subset.HT);\n+      Subset_Node := HT_Ops.First (Subset_HT);\n       while Subset_Node /= null loop\n-         if not Is_In (Of_Set.HT, Subset_Node) then\n+         if not Is_In (Of_Set_HT, Subset_Node) then\n             return False;\n          end if;\n-         Subset_Node := HT_Ops.Next (Subset.HT, Subset_Node);\n+         Subset_Node := HT_Ops.Next (Subset_HT, Subset_Node);\n       end loop;\n \n       return True;\n@@ -1072,6 +1108,8 @@ package body Ada.Containers.Hashed_Sets is\n    -------------\n \n    function Overlap (Left, Right : Set) return Boolean is\n+      Left_HT   : Hash_Table_Type renames Left'Unrestricted_Access.HT;\n+      Right_HT  : Hash_Table_Type renames Right'Unrestricted_Access.HT;\n       Left_Node : Node_Access;\n \n    begin\n@@ -1083,12 +1121,12 @@ package body Ada.Containers.Hashed_Sets is\n          return True;\n       end if;\n \n-      Left_Node := HT_Ops.First (Left.HT);\n+      Left_Node := HT_Ops.First (Left_HT);\n       while Left_Node /= null loop\n-         if Is_In (Right.HT, Left_Node) then\n+         if Is_In (Right_HT, Left_Node) then\n             return True;\n          end if;\n-         Left_Node := HT_Ops.Next (Left.HT, Left_Node);\n+         Left_Node := HT_Ops.Next (Left_HT, Left_Node);\n       end loop;\n \n       return False;\n@@ -1255,22 +1293,34 @@ package body Ada.Containers.Hashed_Sets is\n      (Target : in out Set;\n       Source : Set)\n    is\n+      Tgt_HT : Hash_Table_Type renames Target.HT;\n+      Src_HT : Hash_Table_Type renames Source.HT'Unrestricted_Access.all;\n+\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      TB : Natural renames Tgt_HT.Busy;\n+      TL : Natural renames Tgt_HT.Lock;\n+\n+      SB : Natural renames Src_HT.Busy;\n+      SL : Natural renames Src_HT.Lock;\n+\n    begin\n       if Target'Address = Source'Address then\n          Clear (Target);\n          return;\n       end if;\n \n-      if Target.HT.Busy > 0 then\n+      if TB > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors (set is busy)\";\n       end if;\n \n       declare\n          N : constant Count_Type := Target.Length + Source.Length;\n       begin\n-         if N > HT_Ops.Capacity (Target.HT) then\n-            HT_Ops.Reserve_Capacity (Target.HT, N);\n+         if N > HT_Ops.Capacity (Tgt_HT) then\n+            HT_Ops.Reserve_Capacity (Tgt_HT, N);\n          end if;\n       end;\n \n@@ -1287,9 +1337,9 @@ package body Ada.Containers.Hashed_Sets is\n \n             procedure Process (Src_Node : Node_Access) is\n                E : Element_Type renames Src_Node.Element;\n-               B : Buckets_Type renames Target.HT.Buckets.all;\n+               B : Buckets_Type renames Tgt_HT.Buckets.all;\n                J : constant Hash_Type := Hash (E) mod B'Length;\n-               N : Count_Type renames Target.HT.Length;\n+               N : Count_Type renames Tgt_HT.Length;\n \n             begin\n                B (J) := new Node_Type'(E, B (J));\n@@ -1299,7 +1349,29 @@ package body Ada.Containers.Hashed_Sets is\n          --  Start of processing for Iterate_Source_When_Empty_Target\n \n          begin\n-            Iterate (Source.HT);\n+            TB := TB + 1;\n+            TL := TL + 1;\n+\n+            SB := SB + 1;\n+            SL := SL + 1;\n+\n+            Iterate (Src_HT);\n+\n+            SL := SL - 1;\n+            SB := SB - 1;\n+\n+            TL := TL - 1;\n+            TB := TB - 1;\n+\n+         exception\n+            when others =>\n+               SL := SL - 1;\n+               SB := SB - 1;\n+\n+               TL := TL - 1;\n+               TB := TB - 1;\n+\n+               raise;\n          end Iterate_Source_When_Empty_Target;\n \n       else\n@@ -1315,9 +1387,9 @@ package body Ada.Containers.Hashed_Sets is\n \n             procedure Process (Src_Node : Node_Access) is\n                E : Element_Type renames Src_Node.Element;\n-               B : Buckets_Type renames Target.HT.Buckets.all;\n+               B : Buckets_Type renames Tgt_HT.Buckets.all;\n                J : constant Hash_Type := Hash (E) mod B'Length;\n-               N : Count_Type renames Target.HT.Length;\n+               N : Count_Type renames Tgt_HT.Length;\n \n             begin\n                if B (J) = null then\n@@ -1360,14 +1432,38 @@ package body Ada.Containers.Hashed_Sets is\n          --  Start of processing for Iterate_Source\n \n          begin\n-            Iterate (Source.HT);\n+            TB := TB + 1;\n+            TL := TL + 1;\n+\n+            SB := SB + 1;\n+            SL := SL + 1;\n+\n+            Iterate (Src_HT);\n+\n+            SL := SL - 1;\n+            SB := SB - 1;\n+\n+            TL := TL - 1;\n+            TB := TB - 1;\n+\n+         exception\n+            when others =>\n+               SL := SL - 1;\n+               SB := SB - 1;\n+\n+               TL := TL - 1;\n+               TB := TB - 1;\n+\n+               raise;\n          end Iterate_Source;\n       end if;\n    end Symmetric_Difference;\n \n    function Symmetric_Difference (Left, Right : Set) return Set is\n-      Buckets : HT_Types.Buckets_Access;\n-      Length  : Count_Type;\n+      Left_HT  : Hash_Table_Type renames Left'Unrestricted_Access.HT;\n+      Right_HT : Hash_Table_Type renames Right'Unrestricted_Access.HT;\n+      Buckets  : HT_Types.Buckets_Access;\n+      Length   : Count_Type;\n \n    begin\n       if Left'Address = Right'Address then\n@@ -1403,10 +1499,17 @@ package body Ada.Containers.Hashed_Sets is\n \n          procedure Process (L_Node : Node_Access) is\n          begin\n-            if not Is_In (Right.HT, L_Node) then\n+            if not Is_In (Right_HT, L_Node) then\n                declare\n                   E : Element_Type renames L_Node.Element;\n-                  J : constant Hash_Type := Hash (E) mod Buckets'Length;\n+\n+                  --  Per AI05-0022, the container implementation is required\n+                  --  to detect element tampering by a generic actual\n+                  --  subprogram, hence the use of Checked_Index instead of a\n+                  --  simple invocation of generic formal Hash.\n+\n+                  J : constant Hash_Type :=\n+                    HT_Ops.Checked_Index (Left_HT, Buckets.all, L_Node);\n \n                begin\n                   Buckets (J) := new Node_Type'(E, Buckets (J));\n@@ -1418,7 +1521,7 @@ package body Ada.Containers.Hashed_Sets is\n       --  Start of processing for Iterate_Left\n \n       begin\n-         Iterate (Left.HT);\n+         Iterate (Left_HT);\n       exception\n          when others =>\n             HT_Ops.Free_Hash_Table (Buckets);\n@@ -1437,10 +1540,17 @@ package body Ada.Containers.Hashed_Sets is\n \n          procedure Process (R_Node : Node_Access) is\n          begin\n-            if not Is_In (Left.HT, R_Node) then\n+            if not Is_In (Left_HT, R_Node) then\n                declare\n                   E : Element_Type renames R_Node.Element;\n-                  J : constant Hash_Type := Hash (E) mod Buckets'Length;\n+\n+                  --  Per AI05-0022, the container implementation is required\n+                  --  to detect element tampering by a generic actual\n+                  --  subprogram, hence the use of Checked_Index instead of a\n+                  --  simple invocation of generic formal Hash.\n+\n+                  J : constant Hash_Type :=\n+                    HT_Ops.Checked_Index (Right_HT, Buckets.all, R_Node);\n \n                begin\n                   Buckets (J) := new Node_Type'(E, Buckets (J));\n@@ -1452,7 +1562,7 @@ package body Ada.Containers.Hashed_Sets is\n       --  Start of processing for Iterate_Right\n \n       begin\n-         Iterate (Right.HT);\n+         Iterate (Right_HT);\n       exception\n          when others =>\n             HT_Ops.Free_Hash_Table (Buckets);\n@@ -1547,8 +1657,10 @@ package body Ada.Containers.Hashed_Sets is\n    end Union;\n \n    function Union (Left, Right : Set) return Set is\n-      Buckets : HT_Types.Buckets_Access;\n-      Length  : Count_Type;\n+      Left_HT  : Hash_Table_Type renames Left.HT'Unrestricted_Access.all;\n+      Right_HT : Hash_Table_Type renames Right.HT'Unrestricted_Access.all;\n+      Buckets  : HT_Types.Buckets_Access;\n+      Length   : Count_Type;\n \n    begin\n       if Left'Address = Right'Address then\n@@ -1588,12 +1700,29 @@ package body Ada.Containers.Hashed_Sets is\n             Buckets (J) := new Node_Type'(L_Node.Element, Buckets (J));\n          end Process;\n \n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram, hence the use of\n+         --  Checked_Index instead of a simple invocation of generic formal\n+         --  Hash.\n+\n+         B : Integer renames Left_HT.Busy;\n+         L : Integer renames Left_HT.Lock;\n+\n       --  Start of processing for Iterate_Left\n \n       begin\n-         Iterate (Left.HT);\n+         B := B + 1;\n+         L := L + 1;\n+\n+         Iterate (Left_HT);\n+\n+         L := L - 1;\n+         B := B - 1;\n       exception\n          when others =>\n+            L := L - 1;\n+            B := B - 1;\n+\n             HT_Ops.Free_Hash_Table (Buckets);\n             raise;\n       end Iterate_Left;\n@@ -1629,12 +1758,41 @@ package body Ada.Containers.Hashed_Sets is\n             Length := Length + 1;\n          end Process;\n \n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram, hence the use of\n+         --  Checked_Index instead of a simple invocation of generic formal\n+         --  Hash.\n+\n+         LB : Integer renames Left_HT.Busy;\n+         LL : Integer renames Left_HT.Lock;\n+\n+         RB : Integer renames Right_HT.Busy;\n+         RL : Integer renames Right_HT.Lock;\n+\n       --  Start of processing for Iterate_Right\n \n       begin\n-         Iterate (Right.HT);\n+         LB := LB + 1;\n+         LL := LL + 1;\n+\n+         RB := RB + 1;\n+         RL := RL + 1;\n+\n+         Iterate (Right_HT);\n+\n+         RL := RL - 1;\n+         RB := RB - 1;\n+\n+         LL := LL - 1;\n+         LB := LB - 1;\n       exception\n          when others =>\n+            RL := RL - 1;\n+            RB := RB - 1;\n+\n+            LL := LL - 1;\n+            LB := LB - 1;\n+\n             HT_Ops.Free_Hash_Table (Buckets);\n             raise;\n       end Iterate_Right;\n@@ -1675,7 +1833,9 @@ package body Ada.Containers.Hashed_Sets is\n             return False;\n          end if;\n \n-         X := HT.Buckets (Element_Keys.Index (HT, Position.Node.Element));\n+         X := HT.Buckets (Element_Keys.Checked_Index\n+                            (HT,\n+                             Position.Node.Element));\n \n          for J in 1 .. HT.Length loop\n             if X = Position.Node then\n@@ -1769,15 +1929,15 @@ package body Ada.Containers.Hashed_Sets is\n         (Container : aliased Set;\n          Key       : Key_Type) return Constant_Reference_Type\n       is\n-         Node : constant Node_Access := Key_Keys.Find (Container.HT, Key);\n+         HT   : Hash_Table_Type renames Container'Unrestricted_Access.HT;\n+         Node : constant Node_Access := Key_Keys.Find (HT, Key);\n \n       begin\n          if Node = null then\n             raise Constraint_Error with \"Key not in set\";\n          end if;\n \n          declare\n-            HT : Hash_Table_Type renames Container'Unrestricted_Access.all.HT;\n             B : Natural renames HT.Busy;\n             L : Natural renames HT.Lock;\n          begin\n@@ -1831,11 +1991,12 @@ package body Ada.Containers.Hashed_Sets is\n         (Container : Set;\n          Key       : Key_Type) return Element_Type\n       is\n-         Node : constant Node_Access := Key_Keys.Find (Container.HT, Key);\n+         HT   : Hash_Table_Type renames Container'Unrestricted_Access.HT;\n+         Node : constant Node_Access := Key_Keys.Find (HT, Key);\n \n       begin\n          if Node = null then\n-            raise Constraint_Error with \"key not in map\";  -- ??? \"set\"\n+            raise Constraint_Error with \"key not in set\";\n          end if;\n \n          return Node.Element;\n@@ -1875,7 +2036,8 @@ package body Ada.Containers.Hashed_Sets is\n         (Container : Set;\n          Key       : Key_Type) return Cursor\n       is\n-         Node : constant Node_Access := Key_Keys.Find (Container.HT, Key);\n+         HT   : Hash_Table_Type renames Container'Unrestricted_Access.HT;\n+         Node : constant Node_Access := Key_Keys.Find (HT, Key);\n \n       begin\n          if Node = null then\n@@ -2016,7 +2178,8 @@ package body Ada.Containers.Hashed_Sets is\n            (Vet (Position),\n             \"bad cursor in Update_Element_Preserving_Key\");\n \n-         Indx := HT_Ops.Index (HT, Position.Node);\n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n \n          declare\n             E : Element_Type renames Position.Node.Element;\n@@ -2025,12 +2188,16 @@ package body Ada.Containers.Hashed_Sets is\n             B : Natural renames HT.Busy;\n             L : Natural renames HT.Lock;\n \n+            Eq : Boolean;\n+\n          begin\n             B := B + 1;\n             L := L + 1;\n \n             begin\n+               Indx := HT_Ops.Index (HT, Position.Node);\n                Process (E);\n+               Eq := Equivalent_Keys (K, Key (E));\n             exception\n                when others =>\n                   L := L - 1;\n@@ -2041,8 +2208,7 @@ package body Ada.Containers.Hashed_Sets is\n             L := L - 1;\n             B := B - 1;\n \n-            if Equivalent_Keys (K, Key (E)) then\n-               pragma Assert (Hash (K) = Hash (E));\n+            if Eq then\n                return;\n             end if;\n          end;"}, {"sha": "1e1a2d9b2c90edcf506653943a2da6ab3d487281", "filename": "gcc/ada/adabkend.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fadabkend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fadabkend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadabkend.adb?ref=47fb6ca83f9443beb6d113c93436748d42da08da", "patch": "@@ -272,6 +272,12 @@ package body Adabkend is\n             elsif not Is_Switch (Argv) then\n                Add_File (Argv);\n \n+            --  We must recognize -nostdinc to suppress visibility on the\n+            --  standard GNAT RTL sources.\n+\n+            elsif Argv (Argv'First + 1 .. Argv'Last) = \"nostdinc\" then\n+               Opt.No_Stdinc := True;\n+\n             --  Front end switch\n \n             elsif Is_Front_End_Switch (Argv) then"}, {"sha": "cd8508898211233c97147a7cdc8db8a02134979c", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=47fb6ca83f9443beb6d113c93436748d42da08da", "patch": "@@ -6454,11 +6454,11 @@ pragma Stream_Convert (\n @end smallexample\n \n @noindent\n-This pragma provides an efficient way of providing stream functions for\n-types defined in packages.  Not only is it simpler to use than declaring\n-the necessary functions with attribute representation clauses, but more\n-significantly, it allows the declaration to made in such a way that the\n-stream packages are not loaded unless they are needed.  The use of\n+This pragma provides an efficient way of providing user-defined stream\n+attributes.  Not only is it simpler to use than specifying the attributes\n+directly, but more importantly, it allows the specification to be made in such\n+a way that the predefined unit Ada.Streams is not loaded unless it is actually\n+needed (i.e. unless the stream attributes are actually used); the use of\n the Stream_Convert pragma adds no overhead at all, unless the stream\n attributes are actually used on the designated type.\n "}, {"sha": "42cb142a84ab75344c11659787dec5994c5ee2fb", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 2, "deletions": 172, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=47fb6ca83f9443beb6d113c93436748d42da08da", "patch": "@@ -2333,187 +2333,17 @@ package body Sem_Prag is\n    --------------------------------------------\n \n    procedure Analyze_Initial_Condition_In_Decl_Part (N : Node_Id) is\n-      Pack_Id   : constant Entity_Id := Defining_Entity (Parent (Parent (N)));\n-      Prag_Init : constant Node_Id   :=\n-                    Get_Pragma (Pack_Id, Pragma_Initializes);\n-      --  The related pragma Initializes\n-\n-      Vars : Elist_Id := No_Elist;\n-      --  A list of all variables declared in pragma Initializes\n-\n-      procedure Collect_Variables;\n-      --  Inspect the initialization list of pragma Initializes and collect the\n-      --  entities of all variables declared within the related package.\n-\n-      function Match_Variable (N : Node_Id) return Traverse_Result;\n-      --  Determine whether arbitrary node N denotes a variable declared in the\n-      --  visible declarations of the related package.\n-\n-      procedure Report_Unused_Variables;\n-      --  Emit errors for all variables found in list Vars\n-\n-      -----------------------\n-      -- Collect_Variables --\n-      -----------------------\n-\n-      procedure Collect_Variables is\n-         procedure Collect_Variable (Item : Node_Id);\n-         --  Determine whether Item denotes a variable that appears in the\n-         --  related package and if it does, add it to list Vars.\n-\n-         ----------------------\n-         -- Collect_Variable --\n-         ----------------------\n-\n-         procedure Collect_Variable (Item : Node_Id) is\n-            Item_Id : Entity_Id;\n-\n-         begin\n-            if Is_Entity_Name (Item) and then Present (Entity (Item)) then\n-               Item_Id := Entity (Item);\n-\n-               --  The item is a variable declared in the related package\n-\n-               if Ekind (Item_Id) = E_Variable\n-                 and then Scope (Item_Id) = Pack_Id\n-               then\n-                  Add_Item (Item_Id, Vars);\n-               end if;\n-            end if;\n-         end Collect_Variable;\n-\n-         --  Local variables\n-\n-         Inits : constant Node_Id :=\n-                   Get_Pragma_Arg\n-                     (First (Pragma_Argument_Associations (Prag_Init)));\n-         Init  : Node_Id;\n-\n-      --  Start of processing for Collect_Variables\n-\n-      begin\n-         --  Multiple initialization items appear as an aggregate\n-\n-         if Nkind (Inits) = N_Aggregate\n-           and then Present (Expressions (Inits))\n-         then\n-            Init := First (Expressions (Inits));\n-            while Present (Init) loop\n-               Collect_Variable (Init);\n-\n-               Next (Init);\n-            end loop;\n-\n-         --  Single initialization item\n-\n-         else\n-            Collect_Variable (Inits);\n-         end if;\n-      end Collect_Variables;\n-\n-      --------------------\n-      -- Match_Variable --\n-      --------------------\n-\n-      function Match_Variable (N : Node_Id) return Traverse_Result is\n-         Var_Id : Entity_Id;\n-\n-      begin\n-         --  Find a variable declared within the related package and try to\n-         --  remove it from the list of collected variables found in pragma\n-         --  Initializes.\n-\n-         if Is_Entity_Name (N)\n-           and then Present (Entity (N))\n-         then\n-            Var_Id := Entity (N);\n-\n-            if Ekind (Var_Id) = E_Variable\n-              and then Scope (Var_Id) = Pack_Id\n-            then\n-               Remove (Vars, Var_Id);\n-            end if;\n-         end if;\n-\n-         return OK;\n-      end Match_Variable;\n-\n-      procedure Match_Variables is new Traverse_Proc (Match_Variable);\n-\n-      -----------------------------\n-      -- Report_Unused_Variables --\n-      -----------------------------\n-\n-      procedure Report_Unused_Variables is\n-         Posted   : Boolean := False;\n-         Var_Elmt : Elmt_Id;\n-         Var_Id   : Entity_Id;\n-\n-      begin\n-         if Present (Vars) then\n-            Var_Elmt := First_Elmt (Vars);\n-            while Present (Var_Elmt) loop\n-               Var_Id := Node (Var_Elmt);\n-\n-               if not Posted then\n-                  Posted := True;\n-                  Error_Msg_Name_1 := Name_Initial_Condition;\n-                  Error_Msg_N\n-                    (\"expression of % must mention the following variables\",\n-                     N);\n-               end if;\n-\n-               Error_Msg_Sloc := Sloc (Var_Id);\n-               Error_Msg_NE (\"\\  & declared #\", N, Var_Id);\n-\n-               Next_Elmt (Var_Elmt);\n-            end loop;\n-         end if;\n-      end Report_Unused_Variables;\n-\n-      Expr   : constant Node_Id :=\n-                 Get_Pragma_Arg (First (Pragma_Argument_Associations (N)));\n-      Errors : constant Nat     := Serious_Errors_Detected;\n-\n-   --  Start of processing for Analyze_Initial_Condition_In_Decl_Part\n+      Expr : constant Node_Id :=\n+               Get_Pragma_Arg (First (Pragma_Argument_Associations (N)));\n \n    begin\n       Set_Analyzed (N);\n \n-      --  Pragma Initial_Condition depends on the names enumerated in pragma\n-      --  Initializes. Without those, the analysis cannot take place.\n-\n-      if No (Prag_Init) then\n-         Error_Msg_Name_1 := Name_Initial_Condition;\n-         Error_Msg_Name_2 := Name_Initializes;\n-\n-         Error_Msg_N (\"% requires the presence of aspect or pragma %\", N);\n-         return;\n-      end if;\n-\n       --  The expression is preanalyzed because it has not been moved to its\n       --  final place yet. A direct analysis may generate side effects and this\n       --  is not desired at this point.\n \n       Preanalyze_And_Resolve (Expr, Standard_Boolean);\n-\n-      --  Perform variable matching only when the expression is legal\n-\n-      if Serious_Errors_Detected = Errors then\n-         Collect_Variables;\n-\n-         --  Verify that all variables mentioned in pragma Initializes are used\n-         --  in the expression of pragma Initial_Condition.\n-\n-         Match_Variables (Expr);\n-      end if;\n-\n-      --  Emit errors for all variables that should participate in the\n-      --  expression of pragma Initial_Condition.\n-\n-      if Serious_Errors_Detected = Errors then\n-         Report_Unused_Variables;\n-      end if;\n    end Analyze_Initial_Condition_In_Decl_Part;\n \n    --------------------------------------"}, {"sha": "352ac0783a7f119c65a3907f9df3fac30d44ea81", "filename": "gcc/ada/tbuild.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Ftbuild.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47fb6ca83f9443beb6d113c93436748d42da08da/gcc%2Fada%2Ftbuild.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftbuild.adb?ref=47fb6ca83f9443beb6d113c93436748d42da08da", "patch": "@@ -649,6 +649,7 @@ package body Tbuild is\n      (Def_Id : Entity_Id;\n       Loc    : Source_Ptr) return Node_Id\n    is\n+      pragma Assert (Present (Def_Id) and then Nkind (Def_Id) in N_Entity);\n       Occurrence : Node_Id;\n \n    begin\n@@ -725,7 +726,7 @@ package body Tbuild is\n      (Def_Id : Entity_Id;\n       Loc    : Source_Ptr) return Node_Id\n    is\n-      pragma Assert (Nkind (Def_Id) in N_Entity);\n+      pragma Assert (Present (Def_Id) and then Nkind (Def_Id) in N_Entity);\n       Occurrence : Node_Id;\n    begin\n       Occurrence := New_Node (N_Identifier, Loc);"}]}