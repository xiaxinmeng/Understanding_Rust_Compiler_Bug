{"sha": "7fa7289d9a4495d59cc2e6ca98bdd5263d70bafe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ZhNzI4OWQ5YTQ0OTVkNTljYzJlNmNhOThiZGQ1MjYzZDcwYmFmZQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2007-04-15T14:46:34Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2007-04-15T14:46:34Z"}, "message": "i386.c, [...]: Fix comment typos.\n\n\t* config/i386/i386.c, config/s390/s390.c, config/s390/s390.md,\n\ttree-ssa-loop-niter.c, tree-ssa-structalias.c, tree-vrp.c: Fix\n\tcomment typos.\n\nFrom-SVN: r123847", "tree": {"sha": "5797a66bcb16ef96374728d29c0dca3daa23efa6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5797a66bcb16ef96374728d29c0dca3daa23efa6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7fa7289d9a4495d59cc2e6ca98bdd5263d70bafe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fa7289d9a4495d59cc2e6ca98bdd5263d70bafe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fa7289d9a4495d59cc2e6ca98bdd5263d70bafe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fa7289d9a4495d59cc2e6ca98bdd5263d70bafe/comments", "author": null, "committer": null, "parents": [{"sha": "a57a55dec3932d7d7ea08886300dc23fd2db4058", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a57a55dec3932d7d7ea08886300dc23fd2db4058", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a57a55dec3932d7d7ea08886300dc23fd2db4058"}], "stats": {"total": 24, "additions": 15, "deletions": 9}, "files": [{"sha": "b3c2ae9c53e0112a2bc7625f9cda9ba51c2e0fba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fa7289d9a4495d59cc2e6ca98bdd5263d70bafe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fa7289d9a4495d59cc2e6ca98bdd5263d70bafe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7fa7289d9a4495d59cc2e6ca98bdd5263d70bafe", "patch": "@@ -1,3 +1,9 @@\n+2007-04-15  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* config/i386/i386.c, config/s390/s390.c, config/s390/s390.md,\n+\ttree-ssa-loop-niter.c, tree-ssa-structalias.c, tree-vrp.c: Fix\n+\tcomment typos.\n+\n 2007-04-11  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \t* tree-ssa-loop-prefetch.c (loop_prefetch_arrays): Ignore"}, {"sha": "9f4ed7580791f8b49bfcd11316473aacd911ad43", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fa7289d9a4495d59cc2e6ca98bdd5263d70bafe/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fa7289d9a4495d59cc2e6ca98bdd5263d70bafe/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=7fa7289d9a4495d59cc2e6ca98bdd5263d70bafe", "patch": "@@ -13566,8 +13566,8 @@ scale_counter (rtx countreg, int scale)\n   return sc;\n }\n \n-/* Return mode for the memcpy/memset loop counter.  Preffer SImode over DImode\n-   for constant loop counts.  */\n+/* Return mode for the memcpy/memset loop counter.  Prefer SImode over\n+   DImode for constant loop counts.  */\n \n static enum machine_mode\n counter_mode (rtx count_exp)\n@@ -21141,7 +21141,7 @@ ix86_md_asm_clobbers (tree outputs ATTRIBUTE_UNUSED,\n   return clobbers;\n }\n \n-/* Implementes target vector targetm.asm.encode_section_info.  This\n+/* Implements target vector targetm.asm.encode_section_info.  This\n    is not used by netware.  */\n \n static void ATTRIBUTE_UNUSED"}, {"sha": "1bb9a3cda2013628d3011d5df60c868ecea5f15b", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fa7289d9a4495d59cc2e6ca98bdd5263d70bafe/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fa7289d9a4495d59cc2e6ca98bdd5263d70bafe/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=7fa7289d9a4495d59cc2e6ca98bdd5263d70bafe", "patch": "@@ -2656,7 +2656,7 @@ s390_secondary_reload (bool in_p, rtx x, enum reg_class class,\n     sri->icode = (TARGET_64BIT ?\n \t\t  CODE_FOR_reloaddi_plus : CODE_FOR_reloadsi_plus);\n \n-  /* Peforming a multiword move from or to memory we have to make sure the\n+  /* Performing a multiword move from or to memory we have to make sure the\n      second chunk in memory is addressable without causing a displacement\n      overflow.  If that would be the case we calculate the address in\n      a scratch register.  */\n@@ -2666,7 +2666,7 @@ s390_secondary_reload (bool in_p, rtx x, enum reg_class class,\n       && !DISP_IN_RANGE (INTVAL (XEXP (XEXP (x, 0), 1))\n \t\t\t + GET_MODE_SIZE (mode) - 1))\n     {\n-      /* For GENERAL_REGS a displacement overflow is no problem if occuring\n+      /* For GENERAL_REGS a displacement overflow is no problem if occurring\n \t in a s_operand address since we may fallback to lm/stm.  So we only\n \t have to care about overflows in the b+i+d case.  */\n       if ((reg_classes_intersect_p (GENERAL_REGS, class)"}, {"sha": "949d94e53a194331a92473798ef06754cb801c1e", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fa7289d9a4495d59cc2e6ca98bdd5263d70bafe/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fa7289d9a4495d59cc2e6ca98bdd5263d70bafe/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=7fa7289d9a4495d59cc2e6ca98bdd5263d70bafe", "patch": "@@ -308,7 +308,7 @@\n ;; within instruction mnemonics.\n (define_mode_attr bt [(TF \"b\") (DF \"b\") (SF \"b\") (TD \"t\") (DD \"t\") (SD \"t\")])\n \n-;; Although it is unprecise for z9-ec we handle all dfp instructions like\n+;; Although it is imprecise for z9-ec we handle all dfp instructions like\n ;; bfp regarding the pipeline description.\n (define_mode_attr bfp [(TF \"tf\") (DF \"df\") (SF \"sf\")\n                        (TD \"tf\") (DD \"df\") (SD \"sf\")])"}, {"sha": "2e733f93168324a3d3392e722c6d474bb947b434", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fa7289d9a4495d59cc2e6ca98bdd5263d70bafe/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fa7289d9a4495d59cc2e6ca98bdd5263d70bafe/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=7fa7289d9a4495d59cc2e6ca98bdd5263d70bafe", "patch": "@@ -2474,7 +2474,7 @@ record_estimate (struct loop *loop, tree bound, double_int i_bound,\n     delta = double_int_two;\n   i_bound = double_int_add (i_bound, delta);\n \n-  /* If an overflow occured, ignore the result.  */\n+  /* If an overflow occurred, ignore the result.  */\n   if (double_int_ucmp (i_bound, delta) < 0)\n     return;\n "}, {"sha": "6fda265797e07ff2496263ce780fdbb51ddc50df", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fa7289d9a4495d59cc2e6ca98bdd5263d70bafe/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fa7289d9a4495d59cc2e6ca98bdd5263d70bafe/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=7fa7289d9a4495d59cc2e6ca98bdd5263d70bafe", "patch": "@@ -3226,7 +3226,7 @@ update_alias_info (tree stmt, struct alias_info *ai)\n \t combination of direct symbol references and pointer\n \t dereferences (e.g., MEMORY_VAR = *PTR) or if a call site has\n \t memory symbols in its argument list, but these cases do not\n-\t occur so frequently as to constitue a serious problem.  */\n+\t occur so frequently as to constitute a serious problem.  */\n       if (STORED_SYMS (stmt))\n \tEXECUTE_IF_SET_IN_BITMAP (STORED_SYMS (stmt), 0, i, bi)\n \t  {"}, {"sha": "ff07939b2d252d96859dc29ee2030b84e4a7d8d0", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fa7289d9a4495d59cc2e6ca98bdd5263d70bafe/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fa7289d9a4495d59cc2e6ca98bdd5263d70bafe/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=7fa7289d9a4495d59cc2e6ca98bdd5263d70bafe", "patch": "@@ -1815,7 +1815,7 @@ extract_range_from_binary_expr (value_range_t *vr, tree expr)\n \n       /* If we have a RSHIFT_EXPR with any shift values outside [0..prec-1],\n \t then drop to VR_VARYING.  Outside of this range we get undefined\n-\t behaviour from the shift operation.  We cannot even trust\n+\t behavior from the shift operation.  We cannot even trust\n \t SHIFT_COUNT_TRUNCATED at this stage, because that applies to rtl\n \t shifts, and the operation at the tree level may be widened.  */\n       if (code == RSHIFT_EXPR)"}]}