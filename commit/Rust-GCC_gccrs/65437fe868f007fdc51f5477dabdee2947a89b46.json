{"sha": "65437fe868f007fdc51f5477dabdee2947a89b46", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjU0MzdmZTg2OGYwMDdmZGM1MWY1NDc3ZGFiZGVlMjk0N2E4OWI0Ng==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-06-12T14:33:54Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-06-12T14:33:54Z"}, "message": "Make logical ops use a clobbered register instead of $1\n\nFrom-SVN: r1195", "tree": {"sha": "b2f41f171ced38e8623ed4983e95f57dc64a7f86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2f41f171ced38e8623ed4983e95f57dc64a7f86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65437fe868f007fdc51f5477dabdee2947a89b46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65437fe868f007fdc51f5477dabdee2947a89b46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65437fe868f007fdc51f5477dabdee2947a89b46", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65437fe868f007fdc51f5477dabdee2947a89b46/comments", "author": null, "committer": null, "parents": [{"sha": "45b33951a8562a13054992d3a2cfb9c42fb121af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45b33951a8562a13054992d3a2cfb9c42fb121af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45b33951a8562a13054992d3a2cfb9c42fb121af"}], "stats": {"total": 427, "additions": 346, "deletions": 81}, "files": [{"sha": "08a612908cb2de3b387b719b8ff4e01ad73a042a", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 77, "deletions": 7, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65437fe868f007fdc51f5477dabdee2947a89b46/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65437fe868f007fdc51f5477dabdee2947a89b46/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=65437fe868f007fdc51f5477dabdee2947a89b46", "patch": "@@ -438,6 +438,23 @@ large_int (op, mode)\n   return TRUE;\n }\n \n+/* Return truth value of whether OP is an integer which can be loaded\n+   with an lui instruction.  */\n+\n+int\n+lui_int (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) != CONST_INT)\n+    return FALSE;\n+\n+  if ((INTVAL (op) & 0x0000ffff) == 0)\t\t/* lui reg,value>>16 */\n+    return TRUE;\n+\n+  return FALSE;\n+}\n+\n /* Return truth value of whether OP is a register or the constant 0.  */\n \n int\n@@ -1049,12 +1066,7 @@ mips_move_1word (operands, insn, unsignedp)\n \t    }\n \n \t  else if (GP_REG_P (regno0))\n-\t    {\n-\t      if ((INTVAL (operands[1]) & 0x0000ffff) == 0)\n-\t\tret = \"lui\\t%0,(%X1)>>16\";\n-\t      else\n-\t\tret = \"li\\t%0,%1\";\n-\t    }\n+\t    ret = \"li\\t%0,%X1\\t\\t# %1\";\n \t}\n \n       else if (code1 == CONST_DOUBLE && mode == SFmode)\n@@ -3550,6 +3562,65 @@ mips_output_lineno (stream, line)\n     }\n }\n \n+\f\n+/* If defined, a C statement to be executed just prior to the\n+   output of assembler code for INSN, to modify the extracted\n+   operands so they will be output differently.\n+\n+   Here the argument OPVEC is the vector containing the operands\n+   extracted from INSN, and NOPERANDS is the number of elements of\n+   the vector which contain meaningful data for this insn.  The\n+   contents of this vector are what will be used to convert the\n+   insn template into assembler code, so you can change the\n+   assembler output by changing the contents of the vector.\n+\n+   We use it to check if the current insn needs a nop in front of it\n+   because of load delays, and also to update the delay slot\n+   statistics.  */\n+\n+void\n+final_prescan_insn (insn, opvec, noperands)\n+     rtx insn;\n+     rtx opvec[];\n+     int noperands;\n+{\n+  if (dslots_number_nops > 0)\n+    {\n+      enum machine_mode mode = GET_MODE (mips_load_reg);\n+      rtx pattern = PATTERN (insn);\n+      int length = get_attr_length (insn);\n+\n+      /* Do we need to emit a NOP? */\n+      if (length == 0\n+\t  || (mips_load_reg  != (rtx)0 && reg_mentioned_p (mips_load_reg,  pattern))\n+\t  || (mips_load_reg2 != (rtx)0 && reg_mentioned_p (mips_load_reg2, pattern))\n+\t  || (mips_load_reg3 != (rtx)0 && reg_mentioned_p (mips_load_reg3, pattern))\n+\t  || (mips_load_reg4 != (rtx)0 && reg_mentioned_p (mips_load_reg4, pattern)))\n+\tfputs ((set_noreorder) ? \"\\tnop\\n\" : \"\\t#nop\\n\", asm_out_file);\n+\n+      else\n+\tdslots_load_filled++;\n+\n+      while (--dslots_number_nops > 0)\n+\tfputs ((set_noreorder) ? \"\\tnop\\n\" : \"\\t#nop\\n\", asm_out_file);\n+\n+      mips_load_reg  = (rtx)0;\n+      mips_load_reg2 = (rtx)0;\n+      mips_load_reg3 = (rtx)0;\n+      mips_load_reg4 = (rtx)0;\n+\n+      if (set_noreorder && --set_noreorder == 0)\n+\tfputs (\"\\t.set\\treorder\\n\", asm_out_file);\n+    }\n+\n+  if (TARGET_STATS)\n+    {\n+      enum rtx_code code = GET_CODE (insn);\n+      if (code == JUMP_INSN || code == CALL_INSN)\n+\tdslots_jump_total++;\n+    }\n+}\n+\n \f\n /* Output at beginning of assembler file.\n    If we are optimizing to use the global pointer, create a temporary\n@@ -4373,4 +4444,3 @@ null_epilogue ()\n \n   return (compute_frame_size (get_frame_size ())) == 0;\n }\n-"}, {"sha": "c0b0bef083348175c6ba6af97d92f689edf05944", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 4, "deletions": 43, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65437fe868f007fdc51f5477dabdee2947a89b46/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65437fe868f007fdc51f5477dabdee2947a89b46/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=65437fe868f007fdc51f5477dabdee2947a89b46", "patch": "@@ -125,6 +125,7 @@ extern unsigned long\tcompute_frame_size ();\n extern void\t\texpand_block_move ();\n extern int\t\tequality_op ();\n extern int\t\tfcmp_op ();\n+extern void\t\tfinal_prescan_insn ();\n extern int\t\tfpsw_register_operand ();\n extern struct rtx_def *\tfunction_arg ();\n extern void\t\tfunction_arg_advance ();\n@@ -135,6 +136,7 @@ extern void\t\tgen_conditional_branch ();\n extern struct rtx_def * gen_int_relational ();\n extern void\t\tinit_cumulative_args ();\n extern int\t\tlarge_int ();\n+extern int\t\tlui_int ();\n extern int\t\tmd_register_operand ();\n extern int\t\tmips_address_cost ();\n extern void\t\tmips_asm_file_end ();\n@@ -428,7 +430,7 @@ while (0)\n \f\n /* Print subsidiary information on the compiler version in use.  */\n \n-#define MIPS_VERSION \"[AL 1.1, MM 19]\"\n+#define MIPS_VERSION \"[AL 1.1, MM 20]\"\n \n #ifndef MACHINE_TYPE\n #define MACHINE_TYPE \"BSD Mips\"\n@@ -2504,47 +2506,7 @@ while (0)\n    statistics.  */\n \n #define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS)\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    if (dslots_number_nops > 0 && mips_load_reg != (rtx)0)\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tenum machine_mode mode = GET_MODE (mips_load_reg);\t\t\\\n-\trtx pattern = PATTERN (INSN);\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\tif (reg_mentioned_p (mips_load_reg, pattern)\t\t\t\\\n-\t    || (mips_load_reg2 != (rtx)0\t\t\t\t\\\n-\t\t&& reg_mentioned_p (mips_load_reg2, pattern))\t\t\\\n-\t    || (mips_load_reg3 != (rtx)0\t\t\t\t\\\n-\t\t&& reg_mentioned_p (mips_load_reg3, pattern))\t\t\\\n-\t    || (mips_load_reg4 != (rtx)0\t\t\t\t\\\n-\t\t&& reg_mentioned_p (mips_load_reg4, pattern))\t\t\\\n-\t    || get_attr_length (INSN) == 0)\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    fputs ((set_noreorder) ? \"\\tnop\\n\" : \"\\t#nop\\n\", asm_out_file); \\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  dslots_load_filled++;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\twhile (--dslots_number_nops > 0)\t\t\t\t\\\n-\t  fputs ((set_noreorder) ? \"\\tnop\\n\" : \"\\t#nop\\n\", asm_out_file); \\\n-\t\t\t\t\t\t\t\t\t\\\n-\tmips_load_reg  = (rtx)0;\t\t\t\t\t\\\n-\tmips_load_reg2 = (rtx)0;\t\t\t\t\t\\\n-\tmips_load_reg3 = (rtx)0;\t\t\t\t\t\\\n-\tmips_load_reg4 = (rtx)0;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\tif (set_noreorder && --set_noreorder == 0)\t\t\t\\\n-\t  fputs (\"\\t.set\\treorder\\n\", asm_out_file);\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    if (TARGET_STATS)\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tenum rtx_code code = GET_CODE (INSN);\t\t\t\t\\\n-\tif (code == JUMP_INSN || code == CALL_INSN)\t\t\t\\\n-\t  dslots_jump_total++;\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-while (0)\n+  final_prescan_insn (INSN, OPVEC, NOPERANDS)\n \n \f\n /* Tell final.c how to eliminate redundant test instructions.\n@@ -3310,4 +3272,3 @@ while (0)\n #define MIPS_IS_STAB(sym) (((sym)->index & 0xFFF00) == CODE_MASK)\n #define MIPS_MARK_STAB(code) ((code)+CODE_MASK)\n #define MIPS_UNMARK_STAB(code) ((code)-CODE_MASK)\n-"}, {"sha": "730d62419e119050f95357be652b0bfb67e5c5db", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 253, "deletions": 19, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65437fe868f007fdc51f5477dabdee2947a89b46/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65437fe868f007fdc51f5477dabdee2947a89b46/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=65437fe868f007fdc51f5477dabdee2947a89b46", "patch": "@@ -1153,20 +1153,98 @@ move\\\\t%0,%z4\\\\n\\\\\n ;; the optimizer can fold things together, at the expense of not moving the\n ;; constant out of loops.\n \n-(define_insn \"andsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,?d,?d\")\n-\t(and:SI (match_operand:SI 1 \"arith32_operand\" \"%d,d,d,d\")\n-\t\t(match_operand:SI 2 \"arith32_operand\" \"d,K,I,M\")))]\n+(define_expand \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(and:SI (match_operand:SI 1 \"arith32_operand\" \"dKIM\")\n+\t\t(match_operand:SI 2 \"arith32_operand\" \"dKIM\")))]\n+  \"\"\n+  \"\n+{\n+  extern rtx gen_andsi3_internal2 ();\n+\n+  /* Canonlicalize */\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    {\n+      rtx temp;\n+\n+      if (GET_CODE (operands[2]) == CONST_INT)\n+\t{\n+\t  emit_move_insn (operands[0],\n+\t\t\t  gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t   INTVAL (operands[1]) & INTVAL (operands[2])));\n+\t  DONE;\n+\t}\n+\n+      temp = operands[1];\n+      operands[1] = operands[2];\n+      operands[2] = temp;\n+    }\n+\n+  if (GET_CODE (operands[2]) == CONST_INT && !SMALL_INT_UNSIGNED (operands[2]))\n+    {\n+      emit_insn (gen_andsi3_internal2 (operands[0],\n+\t\t\t\t       operands[1],\n+\t\t\t\t       operands[2],\n+\t\t\t\t       gen_reg_rtx (SImode)));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"andsi3_internal1\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n+\t\t(match_operand:SI 2 \"uns_arith_operand\" \"d,K\")))]\n+  \"\"\n+  \"@\n+   and\\\\t%0,%1,%2\n+   andi\\\\t%0,%1,%x2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"andsi3_internal2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d,d\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"d,d,d,d\")\n+\t\t(match_operand:SI 2 \"arith32_operand\" \"d,K,I,M\")))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"=d,d,d,d\"))]\n   \"\"\n   \"@\n    and\\\\t%0,%1,%2\n    andi\\\\t%0,%1,%x2\n-   %[li\\\\t%@,%X2\\;and\\\\t%0,%1,%@%]\n-   %[li\\\\t%@,%X2\\;and\\\\t%0,%1,%@%]\"\n+   li\\\\t%3,%X2\\\\t\\\\t# %2\\;and\\\\t%0,%1,%3\n+   li\\\\t%3,%X2\\\\t\\\\t# %2\\;and\\\\t%0,%1,%3\"\n   [(set_attr \"type\"\t\"arith,arith,multi,multi\")\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr \"length\"\t\"1,1,2,3\")])\n \n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t(match_operand:SI 2 \"lui_int\" \"\")))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n+  \"reload_completed && !TARGET_DEBUG_D_MODE\"\n+\n+  [(set (match_dup 3) (match_dup 2))\n+   (set (match_dup 0) (and:SI (match_dup 1) (match_dup 3)))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t(match_operand:SI 2 \"large_int\" \"\")))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n+  \"reload_completed && !TARGET_DEBUG_D_MODE\"\n+\n+  [(set (match_dup 3) (match_dup 4))\n+   (set (match_dup 3) (ior:SI (match_dup 3) (match_dup 5)))\n+   (set (match_dup 0) (and:SI (match_dup 1) (match_dup 3)))]\n+  \"\n+{\n+  int val = INTVAL (operands[2]);\n+  operands[4] = gen_rtx (CONST_INT, VOIDmode, val & 0xffff0000);\n+  operands[5] = gen_rtx (CONST_INT, VOIDmode, val & 0x0000ffff);\n+}\")\n+\n (define_insn \"anddi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(and:DI (match_operand:DI 1 \"register_operand\" \"d\")\n@@ -1190,20 +1268,98 @@ move\\\\t%0,%z4\\\\n\\\\\n    (set (subreg:SI (match_dup 0) 1) (and:SI (subreg:SI (match_dup 1) 1) (subreg:SI (match_dup 2) 1)))]\n   \"\")\n \n-(define_insn \"iorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,?d,?d\")\n-\t(ior:SI (match_operand:SI 1 \"arith32_operand\" \"%d,d,d,d\")\n-\t\t(match_operand:SI 2 \"arith32_operand\" \"d,K,I,M\")))]\n+(define_expand \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ior:SI (match_operand:SI 1 \"arith32_operand\" \"dKIM\")\n+\t\t(match_operand:SI 2 \"arith32_operand\" \"dKIM\")))]\n+  \"\"\n+  \"\n+{\n+  extern rtx gen_iorsi3_internal2 ();\n+\n+  /* Canonlicalize */\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    {\n+      rtx temp;\n+\n+      if (GET_CODE (operands[2]) == CONST_INT)\n+\t{\n+\t  emit_move_insn (operands[0],\n+\t\t\t  gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t   INTVAL (operands[1]) | INTVAL (operands[2])));\n+\t  DONE;\n+\t}\n+\n+      temp = operands[1];\n+      operands[1] = operands[2];\n+      operands[2] = temp;\n+    }\n+\n+  if (GET_CODE (operands[2]) == CONST_INT && !SMALL_INT_UNSIGNED (operands[2]))\n+    {\n+      emit_insn (gen_iorsi3_internal2 (operands[0],\n+\t\t\t\t       operands[1],\n+\t\t\t\t       operands[2],\n+\t\t\t\t       gen_reg_rtx (SImode)));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"iorsi3_internal1\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n+\t\t(match_operand:SI 2 \"uns_arith_operand\" \"d,K\")))]\n+  \"\"\n+  \"@\n+   or\\\\t%0,%1,%2\n+   ori\\\\t%0,%1,%x2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"iorsi3_internal2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d,d\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"d,d,d,d\")\n+\t\t(match_operand:SI 2 \"arith32_operand\" \"d,K,I,M\")))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"=d,d,d,d\"))]\n   \"\"\n   \"@\n    or\\\\t%0,%1,%2\n    ori\\\\t%0,%1,%x2\n-   %[li\\\\t%@,%X2\\;or\\\\t%0,%1,%@%]\n-   %[li\\\\t%@,%X2\\;or\\\\t%0,%1,%@%]\"\n+   li\\\\t%3,%X2\\\\t\\\\t# %2\\;or\\\\t%0,%1,%3\n+   li\\\\t%3,%X2\\\\t\\\\t# %2\\;or\\\\t%0,%1,%3\"\n   [(set_attr \"type\"\t\"arith,arith,multi,multi\")\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr \"length\"\t\"1,1,2,3\")])\n \n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t(match_operand:SI 2 \"lui_int\" \"\")))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n+  \"reload_completed && !TARGET_DEBUG_D_MODE\"\n+\n+  [(set (match_dup 3) (match_dup 2))\n+   (set (match_dup 0) (ior:SI (match_dup 1) (match_dup 3)))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t(match_operand:SI 2 \"large_int\" \"\")))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n+  \"reload_completed && !TARGET_DEBUG_D_MODE\"\n+\n+  [(set (match_dup 3) (match_dup 4))\n+   (set (match_dup 3) (ior:SI (match_dup 3) (match_dup 5)))\n+   (set (match_dup 0) (ior:SI (match_dup 1) (match_dup 3)))]\n+  \"\n+{\n+  int val = INTVAL (operands[2]);\n+  operands[4] = gen_rtx (CONST_INT, VOIDmode, val & 0xffff0000);\n+  operands[5] = gen_rtx (CONST_INT, VOIDmode, val & 0x0000ffff);\n+}\")\n+\n (define_insn \"iordi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(ior:DI (match_operand:DI 1 \"register_operand\" \"d\")\n@@ -1227,20 +1383,99 @@ move\\\\t%0,%z4\\\\n\\\\\n    (set (subreg:SI (match_dup 0) 1) (ior:SI (subreg:SI (match_dup 1) 1) (subreg:SI (match_dup 2) 1)))]\n   \"\")\n \n-(define_insn \"xorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,?d,?d\")\n-\t(xor:SI (match_operand:SI 1 \"arith32_operand\" \"%d,d,d,d\")\n-\t\t(match_operand:SI 2 \"arith32_operand\" \"d,K,I,M\")))]\n+(define_expand \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(xor:SI (match_operand:SI 1 \"arith32_operand\" \"dKIM\")\n+\t\t(match_operand:SI 2 \"arith32_operand\" \"dKIM\")))]\n+  \"\"\n+  \"\n+{\n+  extern rtx gen_xorsi3_internal2 ();\n+\n+  /* Canonlicalize */\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    {\n+      rtx temp;\n+\n+      if (GET_CODE (operands[2]) == CONST_INT)\n+\t{\n+\t  emit_move_insn (operands[0],\n+\t\t\t  gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t   INTVAL (operands[1]) ^ INTVAL (operands[2])));\n+\t  DONE;\n+\t}\n+\n+      temp = operands[1];\n+      operands[1] = operands[2];\n+      operands[2] = temp;\n+    }\n+\n+  if (GET_CODE (operands[2]) == CONST_INT && !SMALL_INT_UNSIGNED (operands[2]))\n+    {\n+      emit_insn (gen_xorsi3_internal2 (operands[0],\n+\t\t\t\t       operands[1],\n+\t\t\t\t       operands[2],\n+\t\t\t\t       gen_reg_rtx (SImode)));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"xorsi3_internal1\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n+\t\t(match_operand:SI 2 \"uns_arith_operand\" \"d,K\")))]\n+  \"\"\n+  \"@\n+   xor\\\\t%0,%1,%2\n+   xori\\\\t%0,%1,%x2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"xorsi3_internal2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d,d\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\" \"d,d,d,d\")\n+\t\t(match_operand:SI 2 \"arith32_operand\" \"d,K,I,M\")))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"=d,d,d,d\"))]\n   \"\"\n   \"@\n    xor\\\\t%0,%1,%2\n    xori\\\\t%0,%1,%x2\n-   %[li\\\\t%@,%X2\\;xor\\\\t%0,%1,%@%]\n-   %[li\\\\t%@,%X2\\;xor\\\\t%0,%1,%@%]\"\n+   li\\\\t%3,%X2\\\\t\\\\t# %2\\;xor\\\\t%0,%1,%3\n+   li\\\\t%3,%X2\\\\t\\\\t# %2\\;xor\\\\t%0,%1,%3\"\n   [(set_attr \"type\"\t\"arith,arith,multi,multi\")\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr \"length\"\t\"1,1,2,3\")])\n \n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t(match_operand:SI 2 \"lui_int\" \"\")))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n+  \"reload_completed && !TARGET_DEBUG_D_MODE\"\n+\n+  [(set (match_dup 3) (match_dup 2))\n+   (set (match_dup 0) (xor:SI (match_dup 1) (match_dup 3)))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t(match_operand:SI 2 \"large_int\" \"\")))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n+  \"reload_completed && !TARGET_DEBUG_D_MODE\"\n+\n+  [(set (match_dup 3) (match_dup 4))\n+   (set (match_dup 3) (ior:SI (match_dup 3) (match_dup 5)))\n+   (set (match_dup 0) (xor:SI (match_dup 1) (match_dup 3)))]\n+  \"\n+{\n+  int val = INTVAL (operands[2]);\n+  operands[4] = gen_rtx (CONST_INT, VOIDmode, val & 0xffff0000);\n+  operands[5] = gen_rtx (CONST_INT, VOIDmode, val & 0x0000ffff);\n+}\")\n+\n+\n (define_insn \"xordi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(xor:DI (match_operand:DI 1 \"register_operand\" \"d\")\n@@ -3993,4 +4228,3 @@ move\\\\t%0,%z4\\\\n\\\\\n ;; eval: (modify-syntax-entry ?{ \"(}\")\n ;; eval: (modify-syntax-entry ?} \"){\")\n ;; End:\n-"}, {"sha": "cede48d08dcd7a6cde4d63c66f046817e3398766", "filename": "gcc/config/mips/x-mips", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65437fe868f007fdc51f5477dabdee2947a89b46/gcc%2Fconfig%2Fmips%2Fx-mips", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65437fe868f007fdc51f5477dabdee2947a89b46/gcc%2Fconfig%2Fmips%2Fx-mips", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fx-mips?ref=65437fe868f007fdc51f5477dabdee2947a89b46", "patch": "@@ -5,12 +5,12 @@\n # being used in secondary stage builds).  We need to pass\n # the -Wf,-XNg1500 option so the compiler can compile the\n # G++ file cp-parse.c.  Otherwise it complains about\n-# too many case statements.  Down with fixed size tables!\n+# too many case statements.  The -Olimit is so the user\n+# can use -O2.  Down with fixed size tables!\n \n CC\t\t= $(OLDCC)\n-OLDCC\t\t= cc -Wf,-XNg1500\n-\n-X_CFLAGS\t= -O1\n+OPT\t\t= -O1\n+OLDCC\t\t= cc -Wf,-XNg1500 -Olimit 3000 $(OPT)\n \n # The bison output files are machine-indep,\n # so different flags for a particular machine are not useful."}, {"sha": "049ee8223313518de1db1728c6193673358398db", "filename": "gcc/config/mips/x-sysv", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65437fe868f007fdc51f5477dabdee2947a89b46/gcc%2Fconfig%2Fmips%2Fx-sysv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65437fe868f007fdc51f5477dabdee2947a89b46/gcc%2Fconfig%2Fmips%2Fx-sysv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fx-sysv?ref=65437fe868f007fdc51f5477dabdee2947a89b46", "patch": "@@ -5,12 +5,12 @@\n # being used in secondary stage builds).  We need to pass\n # the -Wf,-XNg1500 option so the compiler can compile the\n # G++ file cp-parse.c.  Otherwise it complains about\n-# too many case statements.  Down with fixed size tables!\n+# too many case statements.  -Olimit is so the user\n+# can use -O2.  Down with fixed size tables!\n \n CC\t\t= $(OLDCC)\n-OLDCC\t\t= cc -Wf,-XNg1500\n-\n-X_CFLAGS\t= -O1\n+OPT\t\t= -O1\n+OLDCC\t\t= cc -Wf,-XNg1500 -Olimit 3000 $(OPT)\n \n # The bison output files are machine-indep,\n # so different flags for a particular machine are not useful."}, {"sha": "6e46f0eafd504592f7055524879c645f0f5c5b14", "filename": "gcc/config/mips/x-ultrix", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65437fe868f007fdc51f5477dabdee2947a89b46/gcc%2Fconfig%2Fmips%2Fx-ultrix", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65437fe868f007fdc51f5477dabdee2947a89b46/gcc%2Fconfig%2Fmips%2Fx-ultrix", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fx-ultrix?ref=65437fe868f007fdc51f5477dabdee2947a89b46", "patch": "@@ -5,12 +5,12 @@\n # being used in secondary stage builds).  We need to pass\n # the -Wf,-XNg1500 option so the compiler can compile the\n # G++ file cp-parse.c.  Otherwise it complains about\n-# too many case statements.  Down with fixed size tables!\n+# too many case statements.  -Olimit is so the user\n+# can use -O2.  Down with fixed size tables!\n \n CC\t\t= $(OLDCC)\n-OLDCC\t\t= cc -Wf,-XNg1500\n-\n-X_CFLAGS\t= -O1\n+OPT\t\t= -O1\n+OLDCC\t\t= cc -Wf,-XNg1500 -Olimit 3000 $(OPT)\n \n # The bison output files are machine-indep,\n # so different flags for a particular machine are not useful."}]}