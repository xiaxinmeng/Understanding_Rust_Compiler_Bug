{"sha": "7306ed3fb68557907eea94c0e0fedb4b6b5abd93", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzMwNmVkM2ZiNjg1NTc5MDdlZWE5NGMwZTBmZWRiNGI2YjVhYmQ5Mw==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-02-19T01:07:30Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-02-19T01:07:30Z"}, "message": "Initial revision\n\nFrom-SVN: r348", "tree": {"sha": "dd594495a549f2d7bca5b7e0c8d1d9c2822fcaba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd594495a549f2d7bca5b7e0c8d1d9c2822fcaba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7306ed3fb68557907eea94c0e0fedb4b6b5abd93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7306ed3fb68557907eea94c0e0fedb4b6b5abd93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7306ed3fb68557907eea94c0e0fedb4b6b5abd93", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7306ed3fb68557907eea94c0e0fedb4b6b5abd93/comments", "author": null, "committer": null, "parents": [{"sha": "0382002bfdafd7f743dac53d3b06ded044863e06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0382002bfdafd7f743dac53d3b06ded044863e06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0382002bfdafd7f743dac53d3b06ded044863e06"}], "stats": {"total": 1013, "additions": 1013, "deletions": 0}, "files": [{"sha": "0e6efe94aed08ce939c51e61a5ecb4ecdd656aa5", "filename": "gcc/stor-layout.c", "status": "added", "additions": 1013, "deletions": 0, "changes": 1013, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7306ed3fb68557907eea94c0e0fedb4b6b5abd93/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7306ed3fb68557907eea94c0e0fedb4b6b5abd93/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=7306ed3fb68557907eea94c0e0fedb4b6b5abd93", "patch": "@@ -0,0 +1,1013 @@\n+/* C-compiler utilities for types and variables storage layout\n+   Copyright (C) 1987, 1988, 1992 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include \"config.h\"\n+#include <stdio.h>\n+\n+#include \"tree.h\"\n+#include \"function.h\"\n+\n+#define CEIL(x,y) (((x) + (y) - 1) / (y))\n+\n+/* Data type for the expressions representing sizes of data types.\n+   It is the first integer type laid out.\n+   In C, this is int.  */\n+\n+tree sizetype;\n+\n+/* An integer constant with value 0 whose type is sizetype.  */\n+\n+tree size_zero_node;\n+\n+/* An integer constant with value 1 whose type is sizetype.  */\n+\n+tree size_one_node;\n+\n+#define GET_MODE_ALIGNMENT(MODE)   \\\n+  MIN (BIGGEST_ALIGNMENT, \t   \\\n+       MAX (1, (GET_MODE_UNIT_SIZE (MODE) * BITS_PER_UNIT)))\n+\f\n+/* SAVE_EXPRs for sizes of types and decls, waiting to be expanded.  */\n+\n+static tree pending_sizes;\n+\n+/* Nonzero means cannot safely call expand_expr now,\n+   so put variable sizes onto `pending_sizes' instead.  */\n+\n+int immediate_size_expand;\n+\n+tree\n+get_pending_sizes ()\n+{\n+  tree chain = pending_sizes;\n+  pending_sizes = 0;\n+  return chain;\n+}\n+\n+/* Given a size SIZE that isn't constant, return a SAVE_EXPR\n+   to serve as the actual size-expression for a type or decl.  */\n+\n+static tree\n+variable_size (size)\n+     tree size;\n+{\n+  size = save_expr (size);\n+\n+  if (global_bindings_p ())\n+    {\n+      error (\"variable-size type declared outside of any function\");\n+      return size_int (1);\n+    }\n+\n+  if (immediate_size_expand)\n+    expand_expr (size, 0, VOIDmode, 0);\n+  else\n+    pending_sizes = tree_cons (0, size, pending_sizes);\n+\n+  return size;\n+}\n+\f\n+#ifndef MAX_FIXED_MODE_SIZE\n+#define MAX_FIXED_MODE_SIZE GET_MODE_BITSIZE (DImode)\n+#endif\n+\n+/* Return the machine mode to use for a nonscalar of SIZE bits.\n+   The mode must be in class CLASS, and have exactly that many bits.\n+   If LIMIT is nonzero, modes of wider than MAX_FIXED_MODE_SIZE will not\n+   be used.  */\n+\n+enum machine_mode\n+mode_for_size (size, class, limit)\n+     unsigned int size;\n+     enum mode_class class;\n+     int limit;\n+{\n+  register enum machine_mode mode;\n+\n+  if (limit && size > MAX_FIXED_MODE_SIZE)\n+    return BLKmode;\n+\n+  /* Get the last mode which has this size, in the specified class.  */\n+  for (mode = GET_CLASS_NARROWEST_MODE (class); mode != VOIDmode;\n+       mode = GET_MODE_WIDER_MODE (mode))\n+    if (GET_MODE_BITSIZE (mode) == size)\n+      return mode;\n+\n+  return BLKmode;\n+}\n+\n+/* Return the value of VALUE, rounded up to a multiple of DIVISOR.  */\n+\n+tree\n+round_up (value, divisor)\n+     tree value;\n+     int divisor;\n+{\n+  return size_binop (MULT_EXPR,\n+\t\t     size_binop (CEIL_DIV_EXPR, value, size_int (divisor)),\n+\t\t     size_int (divisor));\n+}\n+\f\n+/* Set the size, mode and alignment of a ..._DECL node.\n+   TYPE_DECL does need this for C++.\n+   Note that LABEL_DECL and CONST_DECL nodes do not need this,\n+   and FUNCTION_DECL nodes have them set up in a special (and simple) way.\n+   Don't call layout_decl for them.\n+\n+   KNOWN_ALIGN is the amount of alignment we can assume this\n+   decl has with no special effort.  It is relevant only for FIELD_DECLs\n+   and depends on the previous fields.\n+   All that matters about KNOWN_ALIGN is which powers of 2 divide it.\n+   If KNOWN_ALIGN is 0, it means, \"as much alignment as you like\":\n+   the record will be aligned to suit.  */\n+\n+void\n+layout_decl (decl, known_align)\n+     tree decl;\n+     unsigned known_align;\n+{\n+  register tree type = TREE_TYPE (decl);\n+  register enum tree_code code = TREE_CODE (decl);\n+  int spec_size = DECL_FRAME_SIZE (decl);\n+\n+  if (code == CONST_DECL)\n+    return;\n+\n+  if (code != VAR_DECL && code != PARM_DECL && code != RESULT_DECL\n+      && code != FIELD_DECL && code != TYPE_DECL)\n+    abort ();\n+\n+  if (type == error_mark_node)\n+    {\n+      type = void_type_node;\n+      spec_size = 0;\n+    }\n+\n+  /* Usually the size and mode come from the data type without change.  */\n+\n+  DECL_MODE (decl) = TYPE_MODE (type);\n+  DECL_SIZE (decl) = TYPE_SIZE (type);\n+  TREE_UNSIGNED (decl) = TREE_UNSIGNED (type);\n+\n+  if (code == FIELD_DECL && DECL_BIT_FIELD (decl))\n+    {\n+      /* This is a bit-field.  We don't know how to handle\n+\t them except for integers and enums, and front end should\n+\t never generate them otherwise.  */\n+\n+      if (! (TREE_CODE (type) == INTEGER_TYPE\n+\t     || TREE_CODE (type) == ENUMERAL_TYPE))\n+\tabort ();\n+\n+      if (spec_size == 0 && DECL_NAME (decl) != 0)\n+\tabort ();\n+\n+      /* Size is specified number of bits.  */\n+      DECL_SIZE (decl) = size_int (spec_size);\n+    }\n+  /* Force alignment required for the data type.\n+     But if the decl itself wants greater alignment, don't override that.  */\n+  else if (TYPE_ALIGN (type) > DECL_ALIGN (decl))\n+    DECL_ALIGN (decl) = TYPE_ALIGN (type);\n+\n+  /* See if we can use an ordinary integer mode for a bit-field.  */\n+  /* Conditions are: a fixed size that is correct for another mode\n+     and occupying a complete byte or bytes on proper boundary.  */\n+  if (code == FIELD_DECL)\n+    DECL_BIT_FIELD_TYPE (decl) = DECL_BIT_FIELD (decl) ? type : 0;\n+  if (DECL_BIT_FIELD (decl)\n+      && TYPE_SIZE (type) != 0\n+      && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST)\n+    {\n+      register enum machine_mode xmode\n+\t= mode_for_size (TREE_INT_CST_LOW (DECL_SIZE (decl)), MODE_INT, 1);\n+\n+      if (xmode != BLKmode\n+\t  && known_align % GET_MODE_ALIGNMENT (xmode) == 0)\n+\t{\n+\t  DECL_ALIGN (decl) = MAX (GET_MODE_ALIGNMENT (xmode),\n+\t\t\t\t   DECL_ALIGN (decl));\n+\t  DECL_MODE (decl) = xmode;\n+\t  DECL_SIZE (decl) = size_int (GET_MODE_BITSIZE (xmode));\n+\t  /* This no longer needs to be accessed as a bit field.  */\n+\t  DECL_BIT_FIELD (decl) = 0;\n+\t}\n+    }\n+\n+  /* Evaluate nonconstant size only once, either now or as soon as safe.  */\n+  if (DECL_SIZE (decl) != 0 && TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST)\n+    DECL_SIZE (decl) = variable_size (DECL_SIZE (decl));\n+}\n+\f\n+/* Lay out a RECORD_TYPE type (a C struct).\n+   This means laying out the fields, determining their positions,\n+   and computing the overall size and required alignment of the record.\n+   Note that if you set the TYPE_ALIGN before calling this\n+   then the struct is aligned to at least that boundary.\n+\n+   If the type has basetypes, you must call layout_basetypes\n+   before calling this function.\n+\n+   The return value is a list of static members of the record.\n+   They still need to be laid out.  */\n+\n+static tree\n+layout_record (rec)\n+     tree rec;\n+{\n+  register tree field;\n+#ifdef STRUCTURE_SIZE_BOUNDARY\n+  unsigned record_align = MAX (STRUCTURE_SIZE_BOUNDARY, TYPE_ALIGN (rec));\n+#else\n+  unsigned record_align = MAX (BITS_PER_UNIT, TYPE_ALIGN (rec));\n+#endif\n+  /* These must be laid out *after* the record is.  */\n+  tree pending_statics = NULL_TREE;\n+  /* Record size so far is CONST_SIZE + VAR_SIZE bits,\n+     where CONST_SIZE is an integer\n+     and VAR_SIZE is a tree expression.\n+     If VAR_SIZE is null, the size is just CONST_SIZE.\n+     Naturally we try to avoid using VAR_SIZE.  */\n+  register int const_size = 0;\n+  register tree var_size = 0;\n+  /* Once we start using VAR_SIZE, this is the maximum alignment\n+     that we know VAR_SIZE has.  */\n+  register int var_align = BITS_PER_UNIT;\n+\n+\n+  for (field = TYPE_FIELDS (rec); field; field = TREE_CHAIN (field))\n+    {\n+      register int desired_align;\n+\n+      /* If FIELD is static, then treat it like a separate variable,\n+\t not really like a structure field.\n+\t If it is a FUNCTION_DECL, it's a method.\n+\t In both cases, all we do is lay out the decl,\n+\t and we do it *after* the record is laid out.  */\n+\n+      if (TREE_STATIC (field))\n+\t{\n+\t  pending_statics = tree_cons (NULL, field, pending_statics);\n+\t  continue;\n+\t}\n+      /* Enumerators and enum types which are local to this class need not\n+\t be laid out.  Likewise for initialized constant fields.  */\n+      if (TREE_CODE (field) != FIELD_DECL)\n+\tcontinue;\n+\n+      /* Lay out the field so we know what alignment it needs.\n+\t For KNOWN_ALIGN, pass the number of bits from start of record\n+\t or some divisor of it.  */\n+\n+      /* For a packed field, use the alignment as specified,\n+\t disregarding what the type would want.  */\n+      if (DECL_PACKED (field))\n+\tdesired_align = DECL_ALIGN (field);\n+      layout_decl (field, var_size ? var_align : const_size);\n+      if (! DECL_PACKED (field))\n+\tdesired_align = DECL_ALIGN (field);\n+      /* Some targets (i.e. VMS) limit struct field alignment\n+\t to a lower boundary than alignment of variables.  */\n+#ifdef BIGGEST_FIELD_ALIGNMENT\n+      desired_align = MIN (desired_align, BIGGEST_FIELD_ALIGNMENT);\n+#endif\n+\n+      /* Record must have at least as much alignment as any field.\n+\t Otherwise, the alignment of the field within the record\n+\t is meaningless.  */\n+\n+#ifndef PCC_BITFIELD_TYPE_MATTERS\n+      record_align = MAX (record_align, desired_align);\n+#else\n+      if (PCC_BITFIELD_TYPE_MATTERS && TREE_TYPE (field) != error_mark_node\n+\t  && ! integer_zerop (TYPE_SIZE (TREE_TYPE (field))))\n+\t{\n+\t  /* For these machines, a zero-length field does not\n+\t     affect the alignment of the structure as a whole.\n+\t     It does, however, affect the alignment of the next field\n+\t     within the structure.  */\n+\t  if (! integer_zerop (DECL_SIZE (field)))\n+\t    record_align = MAX (record_align, desired_align);\n+\t  else if (! DECL_PACKED (field))\n+\t    desired_align = TYPE_ALIGN (TREE_TYPE (field));\n+\t  /* A named bit field of declared type `int'\n+\t     forces the entire structure to have `int' alignment.  */\n+\t  if (DECL_NAME (field) != 0)\n+\t    record_align = MAX (record_align, TYPE_ALIGN (TREE_TYPE (field)));\n+\t}\n+      else\n+\trecord_align = MAX (record_align, desired_align);\n+#endif\n+\n+      /* Does this field automatically have alignment it needs\n+\t by virtue of the fields that precede it and the record's\n+\t own alignment?  */\n+\n+      if (const_size % desired_align != 0\n+\t  || (var_align % desired_align != 0\n+\t      && var_size != 0))\n+\t{\n+\t  /* No, we need to skip space before this field.\n+\t     Bump the cumulative size to multiple of field alignment.  */\n+\n+\t  if (var_size == 0\n+\t      || var_align % desired_align == 0)\n+\t    const_size\n+\t      = CEIL (const_size, desired_align) * desired_align;\n+\t  else\n+\t    {\n+\t      if (const_size > 0)\n+\t\tvar_size = size_binop (PLUS_EXPR, var_size, const_size);\n+\t      const_size = 0;\n+\t      var_size = round_up (var_size, desired_align);\n+\t      var_align = MIN (var_align, desired_align);\n+\t    }\n+\t}\n+\n+#ifdef PCC_BITFIELD_TYPE_MATTERS\n+      if (PCC_BITFIELD_TYPE_MATTERS\n+\t  && TREE_CODE (field) == FIELD_DECL\n+\t  && TREE_TYPE (field) != error_mark_node\n+\t  && !DECL_PACKED (field)\n+\t  && !integer_zerop (DECL_SIZE (field)))\n+\t{\n+\t  int type_align = TYPE_ALIGN (TREE_TYPE (field));\n+\t  register tree dsize = DECL_SIZE (field);\n+\t  int field_size = TREE_INT_CST_LOW (dsize);\n+\n+\t  /* A bit field may not span the unit of alignment of its type.\n+\t     Advance to next boundary if necessary.  */\n+\t  if (const_size / type_align\n+\t      != (const_size + field_size - 1) / type_align)\n+\t    const_size = CEIL (const_size, type_align) * type_align;\n+\t}\n+#endif\n+\n+/* No existing machine description uses this parameter.\n+   So I have made it in this aspect identical to PCC_BITFIELD_TYPE_MATTERS.  */\n+#ifdef BITFIELD_NBYTES_LIMITED\n+      if (BITFIELD_NBYTES_LIMITED\n+\t  && TREE_CODE (field) == FIELD_DECL\n+\t  && TREE_TYPE (field) != error_mark_node\n+\t  && !DECL_PACKED (field)\n+\t  && !integer_zerop (DECL_SIZE (field)))\n+\t{\n+\t  int type_align = TYPE_ALIGN (TREE_TYPE (field));\n+\t  register tree dsize = DECL_SIZE (field);\n+\t  int field_size = TREE_INT_CST_LOW (dsize);\n+\n+\t  /* A bit field may not span the unit of alignment of its type.\n+\t     Advance to next boundary if necessary.  */\n+\t  if (const_size / type_align\n+\t      != (const_size + field_size - 1) / type_align)\n+\t    const_size = CEIL (const_size, type_align) * type_align;\n+\t}\n+#endif\n+\n+      /* Size so far becomes the position of this field.  */\n+\n+      if (var_size && const_size)\n+\tDECL_FIELD_BITPOS (field)\n+\t  = size_binop (PLUS_EXPR, var_size, size_int (const_size));\n+      else if (var_size)\n+\tDECL_FIELD_BITPOS (field) = var_size;\n+      else\n+\tDECL_FIELD_BITPOS (field) = size_int (const_size);\n+\n+      /* If this field is an anonymous union,\n+\t give each union-member the same position as the union has.  */\n+\n+      if (DECL_NAME (field) == 0\n+\t  && TREE_CODE (TREE_TYPE (field)) == UNION_TYPE)\n+\t{\n+\t  tree uelt = TYPE_FIELDS (TREE_TYPE (field));\n+\t  for (; uelt; uelt = TREE_CHAIN (uelt))\n+\t    {\n+\t      DECL_FIELD_CONTEXT (uelt) = DECL_FIELD_CONTEXT (field);\n+\t      DECL_FIELD_BITPOS (uelt) = DECL_FIELD_BITPOS (field);\n+\t    }\n+\t}\n+\n+      /* Now add size of this field to the size of the record.  */\n+\n+      {\n+        register tree dsize = DECL_SIZE (field);\n+\n+\tif (TREE_CODE (dsize) == INTEGER_CST)\n+\t  const_size += TREE_INT_CST_LOW (dsize);\n+\telse\n+\t  {\n+\t    if (var_size == 0)\n+\t      var_size = dsize;\n+\t    else\n+\t      var_size = size_binop (PLUS_EXPR, var_size, dsize);\n+\t  }\n+      }\n+    }\n+\n+  /* Work out the total size and alignment of the record\n+     as one expression and store in the record type.\n+     Round it up to a multiple of the record's alignment.  */\n+\n+  if (var_size == 0)\n+    {\n+      TYPE_SIZE (rec) = size_int (const_size);\n+    }\n+  else\n+    {\n+      if (const_size)\n+\tvar_size\n+\t  = size_binop (PLUS_EXPR, var_size, size_int (const_size));\n+      TYPE_SIZE (rec) = var_size;\n+    }\n+\n+  /* Determine the desired alignment.  */\n+#ifdef ROUND_TYPE_ALIGN\n+  TYPE_ALIGN (rec) = ROUND_TYPE_ALIGN (rec, TYPE_ALIGN (rec), record_align);\n+#else\n+  TYPE_ALIGN (rec) = MAX (TYPE_ALIGN (rec), record_align);\n+#endif\n+\n+#ifdef ROUND_TYPE_SIZE\n+  TYPE_SIZE (rec) = ROUND_TYPE_SIZE (rec, TYPE_SIZE (rec), TYPE_ALIGN (rec));\n+#else\n+  /* Round the size up to be a multiple of the required alignment */\n+  TYPE_SIZE (rec) = round_up (TYPE_SIZE (rec), TYPE_ALIGN (rec));\n+#endif\n+\n+  return pending_statics;\n+}\n+\f\n+/* Lay out a UNION_TYPE type.\n+   Lay out all the fields, set their positions to zero,\n+   and compute the size and alignment of the union (maximum of any field).\n+   Note that if you set the TYPE_ALIGN before calling this\n+   then the union align is aligned to at least that boundary.  */\n+\n+static void\n+layout_union (rec)\n+     tree rec;\n+{\n+  register tree field;\n+#ifdef STRUCTURE_SIZE_BOUNDARY\n+  unsigned union_align = STRUCTURE_SIZE_BOUNDARY;\n+#else\n+  unsigned union_align = BITS_PER_UNIT;\n+#endif\n+\n+  /* The size of the union, based on the fields scanned so far,\n+     is max (CONST_SIZE, VAR_SIZE).\n+     VAR_SIZE may be null; then CONST_SIZE by itself is the size.  */\n+  register int const_size = 0;\n+  register tree var_size = 0;\n+\n+  for (field = TYPE_FIELDS (rec); field; field = TREE_CHAIN (field))\n+    {\n+      /* Enums which are local to this class need not be laid out.  */\n+      if (TREE_CODE (field) == CONST_DECL || TREE_CODE (field) == TYPE_DECL)\n+\tcontinue;\n+\n+      layout_decl (field, 0);\n+      DECL_FIELD_BITPOS (field) = size_int (0);\n+\n+      /* Union must be at least as aligned as any field requires.  */\n+\n+      union_align = MAX (union_align, DECL_ALIGN (field));\n+\n+#ifdef PCC_BITFIELD_TYPE_MATTERS\n+      /* On the m88000, a bit field of declare type `int'\n+\t forces the entire union to have `int' alignment.  */\n+      if (PCC_BITFIELD_TYPE_MATTERS) \n+\tunion_align = MAX (union_align, TYPE_ALIGN (TREE_TYPE (field)));\n+#endif\n+\n+      /* Set union_size to max (decl_size, union_size).\n+\t There are more and less general ways to do this.\n+\t Use only CONST_SIZE unless forced to use VAR_SIZE.  */\n+\n+      if (TREE_CODE (DECL_SIZE (field)) == INTEGER_CST)\n+\tconst_size = MAX (const_size, TREE_INT_CST_LOW (DECL_SIZE (field)));\n+      else if (var_size == 0)\n+\tvar_size = DECL_SIZE (field);\n+      else\n+\tvar_size = size_binop (MAX_EXPR, var_size, DECL_SIZE (field));\n+    }\n+\n+  /* Determine the ultimate size of the union (in bytes).  */\n+  if (NULL == var_size)\n+    TYPE_SIZE (rec) = size_int (CEIL (const_size, BITS_PER_UNIT)\n+\t\t\t\t* BITS_PER_UNIT);\n+  else if (const_size == 0)\n+    TYPE_SIZE (rec) = var_size;\n+  else\n+    TYPE_SIZE (rec) = size_binop (MAX_EXPR, var_size,\n+\t\t\t\t  round_up (size_int (const_size),\n+\t\t\t\t\t    BITS_PER_UNIT));\n+\n+  /* Determine the desired alignment.  */\n+#ifdef ROUND_TYPE_ALIGN\n+  TYPE_ALIGN (rec) = ROUND_TYPE_ALIGN (rec, TYPE_ALIGN (rec), union_align);\n+#else\n+  TYPE_ALIGN (rec) = MAX (TYPE_ALIGN (rec), union_align);\n+#endif\n+\n+#ifdef ROUND_TYPE_SIZE\n+  TYPE_SIZE (rec) = ROUND_TYPE_SIZE (rec, TYPE_SIZE (rec), TYPE_ALIGN (rec));\n+#else\n+  /* Round the size up to be a multiple of the required alignment */\n+  TYPE_SIZE (rec) = round_up (TYPE_SIZE (rec), TYPE_ALIGN (rec));\n+#endif\n+}\n+\f\n+/* Calculate the mode, size, and alignment for TYPE.\n+   For an array type, calculate the element separation as well.\n+   Record TYPE on the chain of permanent or temporary types\n+   so that dbxout will find out about it.\n+\n+   TYPE_SIZE of a type is nonzero if the type has been laid out already.\n+   layout_type does nothing on such a type.\n+\n+   If the type is incomplete, its TYPE_SIZE remains zero.  */\n+\n+void\n+layout_type (type)\n+     tree type;\n+{\n+  int old;\n+  tree pending_statics;\n+\n+  if (type == 0)\n+    abort ();\n+\n+  /* Do nothing if type has been laid out before.  */\n+  if (TYPE_SIZE (type))\n+    return;\n+\n+  /* Make sure all nodes we allocate are not momentary;\n+     they must last past the current statement.  */\n+  old = suspend_momentary ();\n+\n+  /* If we are processing a permanent type, make nodes permanent.\n+     If processing a temporary type, make it saveable, since the\n+     type node itself is.  This is important if the function is inline,\n+     since its decls will get copied later.  */\n+  push_obstacks_nochange ();\n+  if (allocation_temporary_p ())\n+    {\n+      if (TREE_PERMANENT (type))\n+\tend_temporary_allocation ();\n+      else\n+\tsaveable_allocation ();\n+    }\n+\n+  switch (TREE_CODE (type))\n+    {\n+    case LANG_TYPE:\n+      /* This kind of type is the responsibility\n+\t of the languge-specific code.  */\n+      abort ();\n+\n+    case INTEGER_TYPE:\n+    case ENUMERAL_TYPE:\n+      if (TREE_INT_CST_HIGH (TYPE_MIN_VALUE (type)) >= 0)\n+\tTREE_UNSIGNED (type) = 1;\n+\n+      /* We pass 0 for the last arg of mode_for_size because otherwise\n+\t on the Apollo using long long causes a crash.\n+\t It seems better to use integer modes than to try to support\n+\t integer types with BLKmode.  */\n+      TYPE_MODE (type) = mode_for_size (TYPE_PRECISION (type), MODE_INT, 0);\n+      TYPE_SIZE (type) = size_int (GET_MODE_BITSIZE (TYPE_MODE (type)));\n+      break;\n+\n+    case REAL_TYPE:\n+      TYPE_MODE (type) = mode_for_size (TYPE_PRECISION (type), MODE_FLOAT, 0);\n+      TYPE_SIZE (type) = size_int (GET_MODE_BITSIZE (TYPE_MODE (type)));\n+      break;\n+\n+    case COMPLEX_TYPE:\n+      TREE_UNSIGNED (type) = TREE_UNSIGNED (TREE_TYPE (type));\n+      TYPE_MODE (type)\n+\t= mode_for_size (2 * TYPE_PRECISION (TREE_TYPE (type)),\n+\t\t\t (TREE_CODE (TREE_TYPE (type)) == INTEGER_TYPE\n+\t\t\t  ? MODE_COMPLEX_INT : MODE_COMPLEX_FLOAT),\n+\t\t\t 0);\n+      TYPE_SIZE (type) = size_int (GET_MODE_BITSIZE (TYPE_MODE (type)));\n+      break;\n+\n+    case VOID_TYPE:\n+      TYPE_SIZE (type) = size_zero_node;\n+      TYPE_ALIGN (type) = 1;\n+      TYPE_MODE (type) = VOIDmode;\n+      break;\n+\n+    case FUNCTION_TYPE:\n+    case METHOD_TYPE:\n+      TYPE_MODE (type) = mode_for_size (2 * GET_MODE_BITSIZE (Pmode),\n+\t\t\t\t\tMODE_INT, 0);\n+      TYPE_SIZE (type) = size_int (GET_MODE_BITSIZE (TYPE_MODE (type)));\n+      break;\n+\n+    case POINTER_TYPE:\n+    case REFERENCE_TYPE:\n+      TYPE_MODE (type) = Pmode;\n+      TYPE_SIZE (type) = size_int (GET_MODE_BITSIZE (TYPE_MODE (type)));\n+      TREE_UNSIGNED (type) = 1;\n+      TYPE_PRECISION (type) = GET_MODE_BITSIZE (TYPE_MODE (type));\n+      break;\n+\n+    case ARRAY_TYPE:\n+      {\n+\tregister tree index = TYPE_DOMAIN (type);\n+\tregister tree element = TREE_TYPE (type);\n+\n+\tbuild_pointer_type (element);\n+\n+\t/* We need to know both bounds in order to compute the size.  */\n+\tif (index && TYPE_MAX_VALUE (index) && TYPE_MIN_VALUE (index)\n+\t    && TYPE_SIZE (element))\n+\t  {\n+\t    tree length\n+\t      = size_binop (PLUS_EXPR, size_one_node,\n+\t\t\t    size_binop (MINUS_EXPR, TYPE_MAX_VALUE (index),\n+\t\t\t\t\tTYPE_MIN_VALUE (index)));\n+\n+\t    TYPE_SIZE (type) = size_binop (MULT_EXPR, length,\n+\t\t\t\t\t   TYPE_SIZE (element));\n+\t  }\n+\n+\t/* Now round the alignment and size,\n+\t   using machine-dependent criteria if any.  */\n+\n+#ifdef ROUND_TYPE_ALIGN\n+\tTYPE_ALIGN (type)\n+\t  = ROUND_TYPE_ALIGN (type, TYPE_ALIGN (element), BITS_PER_UNIT);\n+#else\n+\tTYPE_ALIGN (type) = MAX (TYPE_ALIGN (element), BITS_PER_UNIT);\n+#endif\n+\n+#ifdef ROUND_TYPE_SIZE\n+\tif (TYPE_SIZE (type) != 0)\n+\t  TYPE_SIZE (type)\n+\t    = ROUND_TYPE_SIZE (type, TYPE_SIZE (type), TYPE_ALIGN (type));\n+#endif\n+\n+\tTYPE_MODE (type) = BLKmode;\n+\tif (TYPE_SIZE (type) != 0\n+\t    && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n+\t    /* BLKmode elements force BLKmode aggregate;\n+\t       else extract/store fields may lose.  */\n+\t    && (TYPE_MODE (TREE_TYPE (type)) != BLKmode\n+\t\t|| TYPE_NO_FORCE_BLK (TREE_TYPE (type))))\n+\t  {\n+\t    TYPE_MODE (type)\n+\t      = mode_for_size (TREE_INT_CST_LOW (TYPE_SIZE (type)),\n+\t\t\t       MODE_INT, 1);\n+\n+#ifdef STRICT_ALIGNMENT\n+\t    if (TYPE_ALIGN (type) < BIGGEST_ALIGNMENT\n+\t\t&& TYPE_ALIGN (type) < TREE_INT_CST_LOW (TYPE_SIZE (type))\n+\t\t&& TYPE_MODE (type) != BLKmode)\n+\t      {\n+\t\tTYPE_NO_FORCE_BLK (type) = 1;\n+\t\tTYPE_MODE (type) = BLKmode;\n+\t      }\n+#endif\n+\t  }\n+\tbreak;\n+      }\n+\n+    case RECORD_TYPE:\n+      pending_statics = layout_record (type);\n+      TYPE_MODE (type) = BLKmode;\n+      if (TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST)\n+\t{\n+\t  tree field;\n+\t  /* A record which has any BLKmode members must itself be BLKmode;\n+\t     it can't go in a register.\n+\t     Unless the member is BLKmode only because it isn't aligned.  */\n+\t  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\t    {\n+\t      int bitpos;\n+\n+\t      if (TREE_CODE (field) != FIELD_DECL)\n+\t\tcontinue;\n+\n+\t      if (TYPE_MODE (TREE_TYPE (field)) == BLKmode\n+\t\t  && ! TYPE_NO_FORCE_BLK (TREE_TYPE (field)))\n+\t\tgoto record_lose;\n+\n+\t      if (TREE_CODE (DECL_FIELD_BITPOS (field)) != INTEGER_CST)\n+\t\tgoto record_lose;\n+\n+\t      bitpos = TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field));\n+\n+\t      /* Must be BLKmode if any field crosses a word boundary,\n+\t\t since extract_bit_field can't handle that in registers.  */\n+\t      if (bitpos / BITS_PER_WORD\n+\t\t  != ((TREE_INT_CST_LOW (DECL_SIZE (field)) + bitpos - 1)\n+\t\t      / BITS_PER_WORD)\n+\t\t  /* But there is no problem if the field is entire words.  */\n+\t\t  && TREE_INT_CST_LOW (DECL_SIZE (field)) % BITS_PER_WORD == 0)\n+\t\tgoto record_lose;\n+\t    }\n+\n+\t  TYPE_MODE (type)\n+\t    = mode_for_size (TREE_INT_CST_LOW (TYPE_SIZE (type)),\n+\t\t\t     MODE_INT, 1);\n+\n+\t  /* If structure's known alignment is less than\n+\t     what the scalar mode would need, and it matters,\n+\t     then stick with BLKmode.  */\n+#ifdef STRICT_ALIGNMENT\n+\t  if (! (TYPE_ALIGN (type) >= BIGGEST_ALIGNMENT\n+\t\t || TYPE_ALIGN (type) >= TREE_INT_CST_LOW (TYPE_SIZE (type))))\n+\t    {\n+\t      if (TYPE_MODE (type) != BLKmode)\n+\t\t/* If this is the only reason this type is BLKmode,\n+\t\t   then don't force containing types to be BLKmode.  */\n+\t\tTYPE_NO_FORCE_BLK (type) = 1;\n+\t      TYPE_MODE (type) = BLKmode;\n+\t    }\n+#endif\n+\trecord_lose: ;\n+\t}\n+\n+      /* Lay out any static members.  This is done now\n+\t because their type may use the record's type.  */\n+      while (pending_statics)\n+\t{\n+\t  layout_decl (TREE_VALUE (pending_statics), 0);\n+\t  pending_statics = TREE_CHAIN (pending_statics);\n+\t}\n+      break;\n+\n+    case UNION_TYPE:\n+      layout_union (type);\n+      TYPE_MODE (type) = BLKmode;\n+      if (TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n+\t  /* If structure's known alignment is less than\n+\t     what the scalar mode would need, and it matters,\n+\t     then stick with BLKmode.  */\n+#ifdef STRICT_ALIGNMENT\n+\t  && (TYPE_ALIGN (type) >= BIGGEST_ALIGNMENT\n+\t      || TYPE_ALIGN (type) >= TREE_INT_CST_LOW (TYPE_SIZE (type)))\n+#endif\n+\t  )\n+\t{\n+\t  tree field;\n+\t  /* A union which has any BLKmode members must itself be BLKmode;\n+\t     it can't go in a register.\n+\t     Unless the member is BLKmode only because it isn't aligned.  */\n+\t  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\t    {\n+\t      if (TREE_CODE (field) != FIELD_DECL)\n+\t\tcontinue;\n+\n+\t      if (TYPE_MODE (TREE_TYPE (field)) == BLKmode\n+\t\t  && ! TYPE_NO_FORCE_BLK (TREE_TYPE (field)))\n+\t\tgoto union_lose;\n+\t    }\n+\n+\t  TYPE_MODE (type)\n+\t    = mode_for_size (TREE_INT_CST_LOW (TYPE_SIZE (type)),\n+\t\t\t     MODE_INT, 1);\n+\n+\tunion_lose: ;\n+\t}\n+      break;\n+\n+    default:\n+      abort ();\n+    } /* end switch */\n+\n+  /* Normally, use the alignment corresponding to the mode chosen.\n+     However, where strict alignment is not required, avoid\n+     over-aligning structures, since most compilers do not do this\n+     alignment.  */\n+\n+  if (TYPE_MODE (type) != BLKmode && TYPE_MODE (type) != VOIDmode\n+#ifndef STRICT_ALIGNMENT\n+      && (TREE_CODE (type) != RECORD_TYPE && TREE_CODE (type) != UNION_TYPE\n+\t  && TREE_CODE (type) != ARRAY_TYPE)\n+#endif\n+      )\n+    TYPE_ALIGN (type) = GET_MODE_ALIGNMENT (TYPE_MODE (type));\n+\n+  /* Evaluate nonconstant size only once, either now or as soon as safe.  */\n+  if (TYPE_SIZE (type) != 0 && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n+    TYPE_SIZE (type) = variable_size (TYPE_SIZE (type));\n+\n+  /* Also layout any other variants of the type.  */\n+  if (TYPE_NEXT_VARIANT (type)\n+      || type != TYPE_MAIN_VARIANT (type))\n+    {\n+      tree variant;\n+      /* Record layout info of this variant.  */\n+      tree size = TYPE_SIZE (type);\n+      int align = TYPE_ALIGN (type);\n+      enum machine_mode mode = TYPE_MODE (type);\n+\n+      /* Copy it into all variants.  */\n+      for (variant = TYPE_MAIN_VARIANT (type);\n+\t   variant;\n+\t   variant = TYPE_NEXT_VARIANT (variant))\n+\t{\n+\t  TYPE_SIZE (variant) = size;\n+\t  TYPE_ALIGN (variant) = align;\n+\t  TYPE_MODE (variant) = mode;\n+\t}\n+    }\n+\t\n+  pop_obstacks ();\n+  resume_momentary (old);\n+}\n+\f\n+/* Create and return a type for signed integers of PRECISION bits.  */\n+\n+tree\n+make_signed_type (precision)\n+     int precision;\n+{\n+  register tree type = make_node (INTEGER_TYPE);\n+\n+  TYPE_PRECISION (type) = precision;\n+\n+  /* Create the extreme values based on the number of bits.  */\n+\n+  TYPE_MIN_VALUE (type)\n+    = build_int_2 ((precision-HOST_BITS_PER_INT > 0 ? 0 : (-1)<<(precision-1)),\n+\t\t   (-1)<<(precision-HOST_BITS_PER_INT-1 > 0\n+\t\t\t  ? precision-HOST_BITS_PER_INT-1\n+\t\t\t  : 0));\n+  TYPE_MAX_VALUE (type)\n+    = build_int_2 ((precision-HOST_BITS_PER_INT > 0 ? -1 : (1<<(precision-1))-1),\n+\t\t   (precision-HOST_BITS_PER_INT-1 > 0\n+\t\t    ? (1<<(precision-HOST_BITS_PER_INT-1))-1\n+\t\t    : 0));\n+\n+  /* Give this type's extreme values this type as their type.  */\n+\n+  TREE_TYPE (TYPE_MIN_VALUE (type)) = type;\n+  TREE_TYPE (TYPE_MAX_VALUE (type)) = type;\n+\n+  /* The first type made with this or `make_unsigned_type'\n+     is the type for size values.  */\n+\n+  if (sizetype == 0)\n+    {\n+      sizetype = type;\n+    }\n+\n+  /* Lay out the type: set its alignment, size, etc.  */\n+\n+  layout_type (type);\n+\n+  return type;\n+}\n+\n+/* Create and return a type for unsigned integers of PRECISION bits.  */\n+\n+tree\n+make_unsigned_type (precision)\n+     int precision;\n+{\n+  register tree type = make_node (INTEGER_TYPE);\n+\n+  TYPE_PRECISION (type) = precision;\n+\n+  /* The first type made with this or `make_signed_type'\n+     is the type for size values.  */\n+\n+  if (sizetype == 0)\n+    {\n+      sizetype = type;\n+    }\n+\n+  fixup_unsigned_type (type);\n+  return type;\n+}\n+\n+/* Set the extreme values of TYPE based on its precision in bits,\n+   the lay it out.  This is used both in `make_unsigned_type'\n+   and for enumeral types.  */\n+\n+void\n+fixup_unsigned_type (type)\n+     tree type;\n+{\n+  register int precision = TYPE_PRECISION (type);\n+\n+  TYPE_MIN_VALUE (type) = build_int_2 (0, 0);\n+  TYPE_MAX_VALUE (type)\n+    = build_int_2 (precision-HOST_BITS_PER_INT >= 0 ? -1 : (1<<precision)-1,\n+\t\t   precision-HOST_BITS_PER_INT > 0\n+\t\t   ? ((unsigned) ~0\n+\t\t      >> (HOST_BITS_PER_INT - (precision - HOST_BITS_PER_INT)))\n+\t\t   : 0);\n+  TREE_TYPE (TYPE_MIN_VALUE (type)) = type;\n+  TREE_TYPE (TYPE_MAX_VALUE (type)) = type;\n+\n+  /* Lay out the type: set its alignment, size, etc.  */\n+\n+  layout_type (type);\n+}\n+\f\n+/* Find the best machine mode to use when referencing a bit field of length\n+   BITSIZE bits starting at BITPOS.\n+\n+   The underlying object is known to be aligned to a boundary of ALIGN bits.\n+   If LARGEST_MODE is not VOIDmode, it means that we should not use a mode\n+   larger than LARGEST_MODE (usually SImode).\n+\n+   If no mode meets all these conditions, we return VOIDmode.  Otherwise, if\n+   VOLATILEP is true or SLOW_BYTE_ACCESS is false, we return the smallest\n+   mode meeting these conditions.\n+\n+   Otherwise (VOLATILEP is false and SLOW_BYTE_ACCESS is true), if a mode\n+   whose size is UNITS_PER_WORD meets all the conditions, it is returned\n+   instead.  */\n+\n+enum machine_mode\n+get_best_mode (bitsize, bitpos, align, largest_mode, volatilep)\n+     int bitsize, bitpos;\n+     int align;\n+     enum machine_mode largest_mode;\n+     int volatilep;\n+{\n+  enum machine_mode mode;\n+  int unit;\n+\n+  /* Find the narrowest integer mode that contains the bit field.  */\n+  for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n+       mode = GET_MODE_WIDER_MODE (mode))\n+    {\n+      unit = GET_MODE_BITSIZE (mode);\n+      if (bitpos / unit == (bitpos + bitsize - 1) / unit)\n+\tbreak;\n+    }\n+\n+  if (mode == MAX_MACHINE_MODE\n+      /* It is tempting to omit the following line\n+\t if STRICT_ALIGNMENT is not defined.\n+\t But that is incorrect, since if the bitfield uses part of 3 bytes\n+\t and we use a 4-byte mode, we could get a spurious segv\n+\t if the extra 4th byte is past the end of memory.\n+\t (Though at least one Unix compiler ignores this problem:\n+\t that on the Sequent 386 machine.  */\n+      || MIN (unit, BIGGEST_ALIGNMENT) > align\n+      || (largest_mode != VOIDmode && unit > GET_MODE_BITSIZE (largest_mode)))\n+    return VOIDmode;\n+\n+  if (SLOW_BYTE_ACCESS\n+      && ! volatilep\n+      && BITS_PER_WORD <= MIN (align, BIGGEST_ALIGNMENT)\n+      && (largest_mode == VOIDmode\n+\t  || BITS_PER_WORD <= GET_MODE_BITSIZE (largest_mode)))\n+    return word_mode;\n+\n+  return mode;\n+}\n+\f\n+/* Save all variables describing the current status into the structure *P.\n+   This is used before starting a nested function.  */\n+\n+void\n+save_storage_status (p)\n+     struct function *p;\n+{\n+#if 0  /* Need not save, since always 0 and non0 (resp.) within a function.  */\n+  p->pending_sizes = pending_sizes;\n+  p->immediate_size_expand = immediate_size_expand;\n+#endif /* 0 */\n+}\n+\n+/* Restore all variables describing the current status from the structure *P.\n+   This is used after a nested function.  */\n+\n+void\n+restore_storage_status (p)\n+     struct function *p;\n+{\n+#if 0\n+  pending_sizes = p->pending_sizes;\n+  immediate_size_expand = p->immediate_size_expand;\n+#endif /* 0 */\n+}"}]}