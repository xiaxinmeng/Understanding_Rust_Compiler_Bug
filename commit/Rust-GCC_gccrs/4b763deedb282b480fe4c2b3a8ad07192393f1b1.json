{"sha": "4b763deedb282b480fe4c2b3a8ad07192393f1b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGI3NjNkZWVkYjI4MmI0ODBmZTRjMmIzYThhZDA3MTkyMzkzZjFiMQ==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2018-10-24T05:40:25Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2018-10-24T05:40:25Z"}, "message": "2018-10-24  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\t* include/debug/safe_unordered_container.h\n\t(_Safe_unordered_container<>::_M_invalidate_locals): Take lambda\n\tparameter type from local end variable.\n\t(_Safe_unordered_container<>::_M_invalidate_all): Likewise.\n\t* include/debug/unordered_map\n\t(unordered_map<>::begin()): Use C++11 direct initialization.\n\t(unordered_map<>::end()): Likewise.\n\t(unordered_map<>::cbegin()): Likewise.\n\t(unordered_map<>::cend()): Likewise.\n\t(unordered_map<>::begin(size_type)): Likewise.\n\t(unordered_map<>::end(size_type)): Likewise.\n\t(unordered_map<>::cbegin(size_type)): Likewise.\n\t(unordered_map<>::cend(size_type)): Likewise.\n\t(unordered_map<>::emplace<>(_Args&&...)): Likewise.\n\t(unordered_map<>::emplace_hint<>(const_iterator, _Args&&...)): Likewise.\n\t(unordered_map<>::insert(const value_type&)): Likewise.\n\t(unordered_map<>::insert(value_type&&)): Likewise.\n\t(unordered_map<>::insert<>(_Pair&&)): Likewise.\n\t(unordered_map<>::insert(const_iterator, const value_type&)): Likewise.\n\t(unordered_map<>::insert(const_iterator, value_type&&)): Likewise.\n\t(unordered_map<>::insert<>(const_iterator, _Pair&&)): Likewise.\n\t(unordered_map<>::try_emplace<>(const key_type&, _Args&&...)): Likewise.\n\t(unordered_map<>::try_emplace<>(key_type&&, _Args&&...)): Likewise.\n\t(unordered_map<>::try_emplace<>(const_iterator, const key_type&,\n\t_Args&&...)): Likewise.\n\t(unordered_map<>::try_emplace<>(const_iterator, key_type&&,\n\t_Args&&...)): Likewise.\n\t(unordered_map<>::insert_or_assign<>(const key_type&, _Obj&&)): Likewise.\n\t(unordered_map<>::insert_or_assign<>(key_type&&, _Obj&&)): Likewise.\n\t(unordered_map<>::insert_or_assign<>(const_iterator, const key_type&,\n\t_Obj&&)): Likewise.\n\t(unordered_map<>::insert_or_assign<>(const_iterator, key_type&&,\n\t_Obj&&)): Likewise.\n\t(unordered_map<>::insert(note_type&&)): Likewise.\n\t(unordered_map<>::find(const key_type&)): Likewise.\n\t(unordered_map<>::equal_range(const key_type&)): Likewise.\n\t(unordered_map<>::_M_extract): New.\n\t(unordered_map<>::extract(const_iterator)): Use latter.\n\t(unordered_map<>::extract(const key_type&)): Likewise.\n\t(unordered_map<>::_M_erase): New.\n\t(unordered_map<>::erase(const key_type&)): Use latter.\n\t(unordered_map<>::erase(const_iterator)): Likewise.\n\t(unordered_map<>::erase(iterator)): Likewise.\n\t(unordered_map<>::_M_invalidate): New.\n\t(unordered_map<>::erase(const_iterator, const_iterator)): Use latter.\n\t(unordered_multimap<>::begin()): Use C++11 direct initialization.\n\t(unordered_multimap<>::end()): Likewise.\n\t(unordered_multimap<>::cbegin()): Likewise.\n\t(unordered_multimap<>::cend()): Likewise.\n\t(unordered_multimap<>::begin(size_type)): Likewise.\n\t(unordered_multimap<>::end(size_type)): Likewise.\n\t(unordered_multimap<>::cbegin(size_type)): Likewise.\n\t(unordered_multimap<>::cend(size_type)): Likewise.\n\t(unordered_multimap<>::emplace<>(_Args&&...)): Likewise.\n\t(unordered_multimap<>::emplace_hint<>(const_iterator, _Args&&...)): Likewise.\n\t(unordered_multimap<>::insert(const value_type&)): Likewise.\n\t(unordered_multimap<>::insert(const_iterator, const value_type&)): Likewise.\n\t(unordered_multimap<>::insert(const_iterator, value_type&&)): Likewise.\n\t(unordered_multimap<>::insert<>(_Pair&&)): Likewise.\n\t(unordered_multimap<>::insert<>(const_iterator, _Pair&&)): Likewise.\n\t(unordered_multimap<>::insert(note_type&&)): Likewise.\n\t(unordered_multimap<>::insert(const_iterator, note_type&&)): Likewise.\n\t(unordered_multimap<>::find(const key_type&)): Likewise.\n\t(unordered_multimap<>::equal_range(const key_type&)): Likewise.\n\t(unordered_multimap<>::_M_extract): New.\n\t(unordered_multimap<>::extract(const_iterator)): Use latter.\n\t(unordered_multimap<>::extract(const key_type&)): Likewise.\n\t(unordered_multimap<>::_M_erase): New.\n\t(unordered_multimap<>::erase(const_iterator)): Likewise.\n\t(unordered_multimap<>::erase(iterator)): Likewise.\n\t(unordered_multimap<>::_M_invalidate): New.\n\t(unordered_multimap<>::erase(const key_type&)): Use latter.\n\t(unordered_multimap<>::erase(const_iterator, const_iterator)): Likewise.\n\t* include/debug/unordered_set\n\t(unordered_set<>::begin()): Use C++11 direct initialization.\n\t(unordered_set<>::end()): Likewise.\n\t(unordered_set<>::cbegin()): Likewise.\n\t(unordered_set<>::cend()): Likewise.\n\t(unordered_set<>::begin(size_type)): Likewise.\n\t(unordered_set<>::end(size_type)): Likewise.\n\t(unordered_set<>::cbegin(size_type)): Likewise.\n\t(unordered_set<>::cend(size_type)): Likewise.\n\t(unordered_set<>::emplace<>(_Args&&...)): Likewise.\n\t(unordered_set<>::emplace_hint<>(const_iterator, _Args&&...)): Likewise.\n\t(unordered_set<>::insert(const value_type&)): Likewise.\n\t(unordered_set<>::insert(value_type&&)): Likewise.\n\t(unordered_set<>::insert(const_iterator, const value_type&)): Likewise.\n\t(unordered_set<>::insert(const_iterator, value_type&&)): Likewise.\n\t(unordered_set<>::insert(note_type&&)): Likewise.\n\t(unordered_set<>::insert(const_iterator, note_type&&)): Likewise.\n\t(unordered_set<>::find(const key_type&)): Likewise.\n\t(unordered_set<>::equal_range(const key_type&)): Likewise.\n\t(unordered_set<>::_M_extract): New.\n\t(unordered_set<>::extract(const_iterator)): Use latter.\n\t(unordered_set<>::extract(const key_type&)): Likewise.\n\t(unordered_set<>::_M_erase): New.\n\t(unordered_set<>::erase(const key_type&)): Use latter.\n\t(unordered_set<>::erase(const_iterator)): Likewise.\n\t(unordered_set<>::erase(iterator)): Likewise.\n\t(unordered_set<>::_M_invalidate): New.\n\t(unordered_set<>::erase(const_iterator, const_iterator)): Use latter.\n\t(unordered_multiset<>::begin()): Use C++11 direct initialization.\n\t(unordered_multiset<>::end()): Likewise.\n\t(unordered_multiset<>::cbegin()): Likewise.\n\t(unordered_multiset<>::cend()): Likewise.\n\t(unordered_multiset<>::begin(size_type)): Likewise.\n\t(unordered_multiset<>::end(size_type)): Likewise.\n\t(unordered_multiset<>::cbegin(size_type)): Likewise.\n\t(unordered_multiset<>::cend(size_type)): Likewise.\n\t(unordered_multiset<>::emplace<>(_Args&&...)): Likewise.\n\t(unordered_multiset<>::emplace_hint<>(const_iterator, _Args&&...)): Likewise.\n\t(unordered_multiset<>::insert(const value_type&)): Likewise.\n\t(unordered_multiset<>::insert(const_iterator, const value_type&)): Likewise.\n\t(unordered_multiset<>::insert(value_type&&)): Likewise.\n\t(unordered_multiset<>::insert(const_iterator, value_type&&)): Likewise.\n\t(unordered_multiset<>::insert(node_type&&)): Likewise.\n\t(unordered_multiset<>::insert(const_iterator, node_type&&)): Likewise.\n\t(unordered_multiset<>::find(const key_type&)): Likewise.\n\t(unordered_multiset<>::equal_range(const key_type&)): Likewise.\n\t(unordered_multiset<>::_M_extract): New.\n\t(unordered_multiset<>::extract(const_iterator)): Use latter.\n\t(unordered_multiset<>::extract(const key_type&)): Likewise.\n\t(unordered_multiset<>::_M_erase): New.\n\t(unordered_multiset<>::erase(const_iterator)): Likewise.\n\t(unordered_multiset<>::erase(iterator)): Likewise.\n\t(unordered_multiset<>::_M_invalidate): New.\n\t(unordered_multiset<>::erase(const key_type&)): Use latter.\n\t(unordered_multiset<>::erase(const_iterator, const_iterator)): Likewise.\n\nFrom-SVN: r265451", "tree": {"sha": "b5b8c789487d5d9d98c6300597c7d888623d7fc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5b8c789487d5d9d98c6300597c7d888623d7fc4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b763deedb282b480fe4c2b3a8ad07192393f1b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b763deedb282b480fe4c2b3a8ad07192393f1b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b763deedb282b480fe4c2b3a8ad07192393f1b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b763deedb282b480fe4c2b3a8ad07192393f1b1/comments", "author": null, "committer": null, "parents": [{"sha": "a01fc83fea2060f9c52edf7ad47ece0737315426", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a01fc83fea2060f9c52edf7ad47ece0737315426", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a01fc83fea2060f9c52edf7ad47ece0737315426"}], "stats": {"total": 883, "additions": 502, "deletions": 381}, "files": [{"sha": "9285a6becf51e4a5a84607efad47520095a47aa4", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b763deedb282b480fe4c2b3a8ad07192393f1b1/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b763deedb282b480fe4c2b3a8ad07192393f1b1/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=4b763deedb282b480fe4c2b3a8ad07192393f1b1", "patch": "@@ -1,5 +1,134 @@\n 2018-10-24  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n \n+\t* include/debug/safe_unordered_container.h\n+\t(_Safe_unordered_container<>::_M_invalidate_locals): Take lambda\n+\tparameter type from local end variable.\n+\t(_Safe_unordered_container<>::_M_invalidate_all): Likewise.\n+\t* include/debug/unordered_map\n+\t(unordered_map<>::begin()): Use C++11 direct initialization.\n+\t(unordered_map<>::end()): Likewise.\n+\t(unordered_map<>::cbegin()): Likewise.\n+\t(unordered_map<>::cend()): Likewise.\n+\t(unordered_map<>::begin(size_type)): Likewise.\n+\t(unordered_map<>::end(size_type)): Likewise.\n+\t(unordered_map<>::cbegin(size_type)): Likewise.\n+\t(unordered_map<>::cend(size_type)): Likewise.\n+\t(unordered_map<>::emplace<>(_Args&&...)): Likewise.\n+\t(unordered_map<>::emplace_hint<>(const_iterator, _Args&&...)): Likewise.\n+\t(unordered_map<>::insert(const value_type&)): Likewise.\n+\t(unordered_map<>::insert(value_type&&)): Likewise.\n+\t(unordered_map<>::insert<>(_Pair&&)): Likewise.\n+\t(unordered_map<>::insert(const_iterator, const value_type&)): Likewise.\n+\t(unordered_map<>::insert(const_iterator, value_type&&)): Likewise.\n+\t(unordered_map<>::insert<>(const_iterator, _Pair&&)): Likewise.\n+\t(unordered_map<>::try_emplace<>(const key_type&, _Args&&...)): Likewise.\n+\t(unordered_map<>::try_emplace<>(key_type&&, _Args&&...)): Likewise.\n+\t(unordered_map<>::try_emplace<>(const_iterator, const key_type&,\n+\t_Args&&...)): Likewise.\n+\t(unordered_map<>::try_emplace<>(const_iterator, key_type&&,\n+\t_Args&&...)): Likewise.\n+\t(unordered_map<>::insert_or_assign<>(const key_type&, _Obj&&)): Likewise.\n+\t(unordered_map<>::insert_or_assign<>(key_type&&, _Obj&&)): Likewise.\n+\t(unordered_map<>::insert_or_assign<>(const_iterator, const key_type&,\n+\t_Obj&&)): Likewise.\n+\t(unordered_map<>::insert_or_assign<>(const_iterator, key_type&&,\n+\t_Obj&&)): Likewise.\n+\t(unordered_map<>::insert(note_type&&)): Likewise.\n+\t(unordered_map<>::find(const key_type&)): Likewise.\n+\t(unordered_map<>::equal_range(const key_type&)): Likewise.\n+\t(unordered_map<>::_M_extract): New.\n+\t(unordered_map<>::extract(const_iterator)): Use latter.\n+\t(unordered_map<>::extract(const key_type&)): Likewise.\n+\t(unordered_map<>::_M_erase): New.\n+\t(unordered_map<>::erase(const key_type&)): Use latter.\n+\t(unordered_map<>::erase(const_iterator)): Likewise.\n+\t(unordered_map<>::erase(iterator)): Likewise.\n+\t(unordered_map<>::_M_invalidate): New.\n+\t(unordered_map<>::erase(const_iterator, const_iterator)): Use latter.\n+\t(unordered_multimap<>::begin()): Use C++11 direct initialization.\n+\t(unordered_multimap<>::end()): Likewise.\n+\t(unordered_multimap<>::cbegin()): Likewise.\n+\t(unordered_multimap<>::cend()): Likewise.\n+\t(unordered_multimap<>::begin(size_type)): Likewise.\n+\t(unordered_multimap<>::end(size_type)): Likewise.\n+\t(unordered_multimap<>::cbegin(size_type)): Likewise.\n+\t(unordered_multimap<>::cend(size_type)): Likewise.\n+\t(unordered_multimap<>::emplace<>(_Args&&...)): Likewise.\n+\t(unordered_multimap<>::emplace_hint<>(const_iterator, _Args&&...)): Likewise.\n+\t(unordered_multimap<>::insert(const value_type&)): Likewise.\n+\t(unordered_multimap<>::insert(const_iterator, const value_type&)): Likewise.\n+\t(unordered_multimap<>::insert(const_iterator, value_type&&)): Likewise.\n+\t(unordered_multimap<>::insert<>(_Pair&&)): Likewise.\n+\t(unordered_multimap<>::insert<>(const_iterator, _Pair&&)): Likewise.\n+\t(unordered_multimap<>::insert(note_type&&)): Likewise.\n+\t(unordered_multimap<>::insert(const_iterator, note_type&&)): Likewise.\n+\t(unordered_multimap<>::find(const key_type&)): Likewise.\n+\t(unordered_multimap<>::equal_range(const key_type&)): Likewise.\n+\t(unordered_multimap<>::_M_extract): New.\n+\t(unordered_multimap<>::extract(const_iterator)): Use latter.\n+\t(unordered_multimap<>::extract(const key_type&)): Likewise.\n+\t(unordered_multimap<>::_M_erase): New.\n+\t(unordered_multimap<>::erase(const_iterator)): Likewise.\n+\t(unordered_multimap<>::erase(iterator)): Likewise.\n+\t(unordered_multimap<>::_M_invalidate): New.\n+\t(unordered_multimap<>::erase(const key_type&)): Use latter.\n+\t(unordered_multimap<>::erase(const_iterator, const_iterator)): Likewise.\n+\t* include/debug/unordered_set\n+\t(unordered_set<>::begin()): Use C++11 direct initialization.\n+\t(unordered_set<>::end()): Likewise.\n+\t(unordered_set<>::cbegin()): Likewise.\n+\t(unordered_set<>::cend()): Likewise.\n+\t(unordered_set<>::begin(size_type)): Likewise.\n+\t(unordered_set<>::end(size_type)): Likewise.\n+\t(unordered_set<>::cbegin(size_type)): Likewise.\n+\t(unordered_set<>::cend(size_type)): Likewise.\n+\t(unordered_set<>::emplace<>(_Args&&...)): Likewise.\n+\t(unordered_set<>::emplace_hint<>(const_iterator, _Args&&...)): Likewise.\n+\t(unordered_set<>::insert(const value_type&)): Likewise.\n+\t(unordered_set<>::insert(value_type&&)): Likewise.\n+\t(unordered_set<>::insert(const_iterator, const value_type&)): Likewise.\n+\t(unordered_set<>::insert(const_iterator, value_type&&)): Likewise.\n+\t(unordered_set<>::insert(note_type&&)): Likewise.\n+\t(unordered_set<>::insert(const_iterator, note_type&&)): Likewise.\n+\t(unordered_set<>::find(const key_type&)): Likewise.\n+\t(unordered_set<>::equal_range(const key_type&)): Likewise.\n+\t(unordered_set<>::_M_extract): New.\n+\t(unordered_set<>::extract(const_iterator)): Use latter.\n+\t(unordered_set<>::extract(const key_type&)): Likewise.\n+\t(unordered_set<>::_M_erase): New.\n+\t(unordered_set<>::erase(const key_type&)): Use latter.\n+\t(unordered_set<>::erase(const_iterator)): Likewise.\n+\t(unordered_set<>::erase(iterator)): Likewise.\n+\t(unordered_set<>::_M_invalidate): New.\n+\t(unordered_set<>::erase(const_iterator, const_iterator)): Use latter.\n+\t(unordered_multiset<>::begin()): Use C++11 direct initialization.\n+\t(unordered_multiset<>::end()): Likewise.\n+\t(unordered_multiset<>::cbegin()): Likewise.\n+\t(unordered_multiset<>::cend()): Likewise.\n+\t(unordered_multiset<>::begin(size_type)): Likewise.\n+\t(unordered_multiset<>::end(size_type)): Likewise.\n+\t(unordered_multiset<>::cbegin(size_type)): Likewise.\n+\t(unordered_multiset<>::cend(size_type)): Likewise.\n+\t(unordered_multiset<>::emplace<>(_Args&&...)): Likewise.\n+\t(unordered_multiset<>::emplace_hint<>(const_iterator, _Args&&...)): Likewise.\n+\t(unordered_multiset<>::insert(const value_type&)): Likewise.\n+\t(unordered_multiset<>::insert(const_iterator, const value_type&)): Likewise.\n+\t(unordered_multiset<>::insert(value_type&&)): Likewise.\n+\t(unordered_multiset<>::insert(const_iterator, value_type&&)): Likewise.\n+\t(unordered_multiset<>::insert(node_type&&)): Likewise.\n+\t(unordered_multiset<>::insert(const_iterator, node_type&&)): Likewise.\n+\t(unordered_multiset<>::find(const key_type&)): Likewise.\n+\t(unordered_multiset<>::equal_range(const key_type&)): Likewise.\n+\t(unordered_multiset<>::_M_extract): New.\n+\t(unordered_multiset<>::extract(const_iterator)): Use latter.\n+\t(unordered_multiset<>::extract(const key_type&)): Likewise.\n+\t(unordered_multiset<>::_M_erase): New.\n+\t(unordered_multiset<>::erase(const_iterator)): Likewise.\n+\t(unordered_multiset<>::erase(iterator)): Likewise.\n+\t(unordered_multiset<>::_M_invalidate): New.\n+\t(unordered_multiset<>::erase(const key_type&)): Use latter.\n+\t(unordered_multiset<>::erase(const_iterator, const_iterator)): Likewise.\n+\n \t* include/c_global/cstddef: Add versioned namespace.\n \n 2018-10-23  Jonathan Wakely  <jwakely@redhat.com>"}, {"sha": "fe2a5ac348453292f25cb694c8a2a5c19bfface8", "filename": "libstdc++-v3/include/debug/safe_unordered_container.h", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b763deedb282b480fe4c2b3a8ad07192393f1b1/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_unordered_container.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b763deedb282b480fe4c2b3a8ad07192393f1b1/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_unordered_container.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_unordered_container.h?ref=4b763deedb282b480fe4c2b3a8ad07192393f1b1", "patch": "@@ -66,19 +66,18 @@ namespace __gnu_debug\n       void\n       _M_invalidate_locals()\n       {\n-\tauto __local_end = _M_cont()._M_base().end(0);\n+\tauto __local_end = _M_cont()._M_base().cend(0);\n \tthis->_M_invalidate_local_if(\n-\t\t[__local_end](__decltype(_M_cont()._M_base().cend(0)) __it)\n+\t\t[__local_end](__decltype(__local_end) __it)\n \t\t{ return __it != __local_end; });\n       }\n \n       void\n       _M_invalidate_all()\n       {\n-\tauto __end = _M_cont()._M_base().end();\n-\tthis->_M_invalidate_if(\n-\t\t[__end](__decltype(_M_cont()._M_base().cend()) __it)\n-\t\t{ return __it != __end; });\n+\tauto __end = _M_cont()._M_base().cend();\n+\tthis->_M_invalidate_if([__end](__decltype(__end) __it)\n+\t\t\t       { return __it != __end; });\n \t_M_invalidate_locals();\n       }\n \n@@ -92,7 +91,7 @@ namespace __gnu_debug\n \n       /** Invalidates all local iterators @c x that reference this container,\n \t  are not singular, and for which @c __pred(x) returns @c\n-\t  true. @c __pred will be invoked with the normal ilocal iterators\n+\t  true. @c __pred will be invoked with the normal local iterators\n \t  nested in the safe ones. */\n       template<typename _Predicate>\n \tvoid"}, {"sha": "47615d8ec79eb7f80a48694ec18aa406b5419a9d", "filename": "libstdc++-v3/include/debug/unordered_map", "status": "modified", "additions": 206, "deletions": 209, "changes": 415, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b763deedb282b480fe4c2b3a8ad07192393f1b1/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b763deedb282b480fe4c2b3a8ad07192393f1b1/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map?ref=4b763deedb282b480fe4c2b3a8ad07192393f1b1", "patch": "@@ -217,69 +217,69 @@ namespace __debug\n \n       iterator\n       begin() noexcept\n-      { return iterator(_Base::begin(), this); }\n+      { return { _Base::begin(), this }; }\n \n       const_iterator\n       begin() const noexcept\n-      { return const_iterator(_Base::begin(), this); }\n+      { return { _Base::begin(), this }; }\n \n       iterator\n       end() noexcept\n-      { return iterator(_Base::end(), this); }\n+      { return { _Base::end(), this }; }\n \n       const_iterator\n       end() const noexcept\n-      { return const_iterator(_Base::end(), this); }\n+      { return { _Base::end(), this }; }\n \n       const_iterator\n       cbegin() const noexcept\n-      { return const_iterator(_Base::begin(), this); }\n+      { return { _Base::cbegin(), this }; }\n \n       const_iterator\n       cend() const noexcept\n-      { return const_iterator(_Base::end(), this); }\n+      { return { _Base::cend(), this }; }\n \n       // local versions\n       local_iterator\n       begin(size_type __b)\n       {\n \t__glibcxx_check_bucket_index(__b);\n-\treturn local_iterator(_Base::begin(__b), this);\n+\treturn { _Base::begin(__b), this };\n       }\n \n       local_iterator\n       end(size_type __b)\n       {\n \t__glibcxx_check_bucket_index(__b);\n-\treturn local_iterator(_Base::end(__b), this);\n+\treturn { _Base::end(__b), this };\n       }\n \n       const_local_iterator\n       begin(size_type __b) const\n       {\n \t__glibcxx_check_bucket_index(__b);\n-\treturn const_local_iterator(_Base::begin(__b), this);\n+\treturn { _Base::begin(__b), this };\n       }\n \n       const_local_iterator\n       end(size_type __b) const\n       {\n \t__glibcxx_check_bucket_index(__b);\n-\treturn const_local_iterator(_Base::end(__b), this);\n+\treturn { _Base::end(__b), this };\n       }\n \n       const_local_iterator\n       cbegin(size_type __b) const\n       {\n \t__glibcxx_check_bucket_index(__b);\n-\treturn const_local_iterator(_Base::cbegin(__b), this);\n+\treturn { _Base::cbegin(__b), this };\n       }\n \n       const_local_iterator\n       cend(size_type __b) const\n       {\n \t__glibcxx_check_bucket_index(__b);\n-\treturn const_local_iterator(_Base::cend(__b), this);\n+\treturn { _Base::cend(__b), this };\n       }\n \n       size_type\n@@ -305,10 +305,9 @@ namespace __debug\n \templace(_Args&&... __args)\n \t{\n \t  size_type __bucket_count = this->bucket_count();\n-\t  std::pair<_Base_iterator, bool> __res\n-\t    = _Base::emplace(std::forward<_Args>(__args)...);\n+\t  auto __res = _Base::emplace(std::forward<_Args>(__args)...);\n \t  _M_check_rehashed(__bucket_count);\n-\t  return std::make_pair(iterator(__res.first, this), __res.second);\n+\t  return { { __res.first, this }, __res.second };\n \t}\n \n       template<typename... _Args>\n@@ -317,10 +316,10 @@ namespace __debug\n \t{\n \t  __glibcxx_check_insert(__hint);\n \t  size_type __bucket_count = this->bucket_count();\n-\t  _Base_iterator __it = _Base::emplace_hint(__hint.base(),\n-\t\t\t\t\tstd::forward<_Args>(__args)...);\n+\t  auto __it = _Base::emplace_hint(__hint.base(),\n+\t\t\t\t\t  std::forward<_Args>(__args)...);\n \t  _M_check_rehashed(__bucket_count);\n-\t  return iterator(__it, this);\n+\t  return { __it, this };\n \t}\n \n       std::pair<iterator, bool>\n@@ -329,7 +328,7 @@ namespace __debug\n \tsize_type __bucket_count = this->bucket_count();\n \tauto __res = _Base::insert(__obj);\n \t_M_check_rehashed(__bucket_count);\n-\treturn { iterator(__res.first, this), __res.second };\n+\treturn { { __res.first, this }, __res.second };\n       }\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n@@ -340,7 +339,7 @@ namespace __debug\n \tsize_type __bucket_count = this->bucket_count();\n \tauto __res = _Base::insert(std::move(__x));\n \t_M_check_rehashed(__bucket_count);\n-\treturn { iterator(__res.first, this), __res.second };\n+\treturn { { __res.first, this }, __res.second };\n       }\n \n       template<typename _Pair, typename = typename\n@@ -350,20 +349,19 @@ namespace __debug\n \tinsert(_Pair&& __obj)\n \t{\n \t  size_type __bucket_count = this->bucket_count();\n-\t  std::pair<_Base_iterator, bool> __res =\n-\t    _Base::insert(std::forward<_Pair>(__obj));\n+\t  auto __res = _Base::insert(std::forward<_Pair>(__obj));\n \t  _M_check_rehashed(__bucket_count);\n-\t  return std::make_pair(iterator(__res.first, this), __res.second);\n+\t  return { { __res.first, this }, __res.second };\n \t}\n \n       iterator\n       insert(const_iterator __hint, const value_type& __obj)\n       {\n \t__glibcxx_check_insert(__hint);\n \tsize_type __bucket_count = this->bucket_count();\n-\t_Base_iterator __it = _Base::insert(__hint.base(), __obj);\n+\tauto __it = _Base::insert(__hint.base(), __obj);\n \t_M_check_rehashed(__bucket_count);\n-\treturn iterator(__it, this);\n+\treturn { __it, this };\n       }\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n@@ -375,7 +373,7 @@ namespace __debug\n \tsize_type __bucket_count = this->bucket_count();\n \tauto __it = _Base::insert(__hint.base(), std::move(__x));\n \t_M_check_rehashed(__bucket_count);\n-\treturn iterator(__it, this);\n+\treturn { __it, this };\n       }\n \n       template<typename _Pair, typename = typename\n@@ -386,10 +384,9 @@ namespace __debug\n \t{\n \t  __glibcxx_check_insert(__hint);\n \t  size_type __bucket_count = this->bucket_count();\n-\t  _Base_iterator __it =\n-\t    _Base::insert(__hint.base(), std::forward<_Pair>(__obj));\n+\t  auto __it = _Base::insert(__hint.base(), std::forward<_Pair>(__obj));\n \t  _M_check_rehashed(__bucket_count);\n-\t  return iterator(__it, this);\n+\t  return { __it, this };\n \t}\n \n       void\n@@ -419,82 +416,81 @@ namespace __debug\n \n #if __cplusplus > 201402L\n       template <typename... _Args>\n-        pair<iterator, bool>\n-        try_emplace(const key_type& __k, _Args&&... __args)\n-        {\n+\tpair<iterator, bool>\n+\ttry_emplace(const key_type& __k, _Args&&... __args)\n+\t{\n \t  auto __res = _Base::try_emplace(__k,\n \t\t\t\t\t  std::forward<_Args>(__args)...);\n-\t  return { iterator(__res.first, this), __res.second };\n+\t  return { { __res.first, this }, __res.second };\n \t}\n \n       template <typename... _Args>\n-        pair<iterator, bool>\n-        try_emplace(key_type&& __k, _Args&&... __args)\n-        {\n+\tpair<iterator, bool>\n+\ttry_emplace(key_type&& __k, _Args&&... __args)\n+\t{\n \t  auto __res = _Base::try_emplace(std::move(__k),\n \t\t\t\t\t  std::forward<_Args>(__args)...);\n-\t  return { iterator(__res.first, this), __res.second };\n+\t  return { { __res.first, this }, __res.second };\n \t}\n \n       template <typename... _Args>\n-        iterator\n-        try_emplace(const_iterator __hint, const key_type& __k,\n-                    _Args&&... __args)\n-        {\n+\titerator\n+\ttry_emplace(const_iterator __hint, const key_type& __k,\n+\t\t    _Args&&... __args)\n+\t{\n \t  __glibcxx_check_insert(__hint);\n-\t  return iterator(_Base::try_emplace(__hint.base(), __k,\n-\t\t\t\t\t     std::forward<_Args>(__args)...),\n-\t\t\t  this);\n+\t  return { _Base::try_emplace(__hint.base(), __k,\n+\t\t\t\t      std::forward<_Args>(__args)...),\n+\t\t   this };\n \t}\n \n       template <typename... _Args>\n-        iterator\n-        try_emplace(const_iterator __hint, key_type&& __k, _Args&&... __args)\n-        {\n+\titerator\n+\ttry_emplace(const_iterator __hint, key_type&& __k, _Args&&... __args)\n+\t{\n \t  __glibcxx_check_insert(__hint);\n-\t  return iterator(_Base::try_emplace(__hint.base(), std::move(__k),\n-\t\t\t\t\t     std::forward<_Args>(__args)...),\n-\t\t\t  this);\n+\t  return { _Base::try_emplace(__hint.base(), std::move(__k),\n+\t\t\t\t      std::forward<_Args>(__args)...),\n+\t\t   this };\n \t}\n \n       template <typename _Obj>\n-        pair<iterator, bool>\n-        insert_or_assign(const key_type& __k, _Obj&& __obj)\n-        {\n+\tpair<iterator, bool>\n+\tinsert_or_assign(const key_type& __k, _Obj&& __obj)\n+\t{\n \t  auto __res = _Base::insert_or_assign(__k,\n \t\t\t\t\t       std::forward<_Obj>(__obj));\n-\t  return { iterator(__res.first, this), __res.second };\n+\t  return { { __res.first, this }, __res.second };\n \t}\n \n       template <typename _Obj>\n-        pair<iterator, bool>\n-        insert_or_assign(key_type&& __k, _Obj&& __obj)\n-        {\n+\tpair<iterator, bool>\n+\tinsert_or_assign(key_type&& __k, _Obj&& __obj)\n+\t{\n \t  auto __res = _Base::insert_or_assign(std::move(__k),\n \t\t\t\t\t       std::forward<_Obj>(__obj));\n-\t  return { iterator(__res.first, this), __res.second };\n+\t  return { { __res.first, this }, __res.second };\n \t}\n \n       template <typename _Obj>\n-        iterator\n-        insert_or_assign(const_iterator __hint, const key_type& __k,\n-                         _Obj&& __obj)\n-        {\n+\titerator\n+\tinsert_or_assign(const_iterator __hint, const key_type& __k,\n+\t\t\t _Obj&& __obj)\n+\t{\n \t  __glibcxx_check_insert(__hint);\n-\t  return iterator(_Base::insert_or_assign(__hint.base(), __k,\n-\t\t\t\t\t\t  std::forward<_Obj>(__obj)),\n-\t\t\t  this);\n+\t  return { _Base::insert_or_assign(__hint.base(), __k,\n+\t\t\t\t\t   std::forward<_Obj>(__obj)),\n+\t\t   this };\n \t}\n \n       template <typename _Obj>\n-        iterator\n-        insert_or_assign(const_iterator __hint, key_type&& __k, _Obj&& __obj)\n-        {\n+\titerator\n+\tinsert_or_assign(const_iterator __hint, key_type&& __k, _Obj&& __obj)\n+\t{\n \t  __glibcxx_check_insert(__hint);\n-\t  return iterator(_Base::insert_or_assign(__hint.base(),\n-\t\t\t\t\t\t  std::move(__k),\n-\t\t\t\t\t\t  std::forward<_Obj>(__obj)),\n-\t\t\t  this);\n+\t  return { _Base::insert_or_assign(__hint.base(), std::move(__k),\n+\t\t\t\t\t   std::forward<_Obj>(__obj)),\n+\t\t   this };\n \t}\n #endif // C++17\n \n@@ -506,85 +502,66 @@ namespace __debug\n       extract(const_iterator __position)\n       {\n \t__glibcxx_check_erase(__position);\n-\t_Base_const_iterator __victim = __position.base();\n-\tthis->_M_invalidate_if(\n-\t    [__victim](_Base_const_iterator __it) { return __it == __victim; }\n-\t    );\n-\tthis->_M_invalidate_local_if(\n-\t    [__victim](_Base_const_local_iterator __it) {\n-\t\treturn __it._M_curr() == __victim._M_cur;\n-\t    });\n-\treturn _Base::extract(__position.base());\n+\treturn _M_extract(__position.base());\n       }\n \n       node_type\n       extract(const key_type& __key)\n       {\n-\tconst auto __position = find(__key);\n-\tif (__position != end())\n-\t  return extract(__position);\n+\tconst auto __position = _Base::find(__key);\n+\tif (__position != _Base::end())\n+\t  return _M_extract(__position);\n \treturn {};\n       }\n \n       insert_return_type\n       insert(node_type&& __nh)\n       {\n \tauto __ret = _Base::insert(std::move(__nh));\n-\titerator __pos = iterator(__ret.position, this);\n-\treturn { __pos, __ret.inserted, std::move(__ret.node) };\n+\treturn\n+\t  { { __ret.position, this }, __ret.inserted, std::move(__ret.node) };\n       }\n \n       iterator\n       insert(const_iterator __hint, node_type&& __nh)\n       {\n \t__glibcxx_check_insert(__hint);\n-\treturn iterator(_Base::insert(__hint.base(), std::move(__nh)), this);\n+\treturn { _Base::insert(__hint.base(), std::move(__nh)), this };\n       }\n \n       using _Base::merge;\n #endif // C++17\n \n       iterator\n       find(const key_type& __key)\n-      { return iterator(_Base::find(__key), this); }\n+      { return { _Base::find(__key), this }; }\n \n       const_iterator\n       find(const key_type& __key) const\n-      { return const_iterator(_Base::find(__key), this); }\n+      { return { _Base::find(__key), this }; }\n \n       std::pair<iterator, iterator>\n       equal_range(const key_type& __key)\n       {\n-\tstd::pair<_Base_iterator, _Base_iterator> __res =\n-\t  _Base::equal_range(__key);\n-\treturn std::make_pair(iterator(__res.first, this),\n-\t\t\t      iterator(__res.second, this));\n+\tauto __res = _Base::equal_range(__key);\n+\treturn { { __res.first, this }, { __res.second, this } };\n       }\n \n       std::pair<const_iterator, const_iterator>\n       equal_range(const key_type& __key) const\n       {\n-\tstd::pair<_Base_const_iterator, _Base_const_iterator> __res =\n-\t  _Base::equal_range(__key);\n-\treturn std::make_pair(const_iterator(__res.first, this),\n-\t\t\t      const_iterator(__res.second, this));\n+\tauto __res = _Base::equal_range(__key);\n+\treturn { { __res.first, this }, { __res.second, this } };\n       }\n \n       size_type\n       erase(const key_type& __key)\n       {\n \tsize_type __ret(0);\n-\t_Base_iterator __victim(_Base::find(__key));\n+\tauto __victim = _Base::find(__key);\n \tif (__victim != _Base::end())\n \t  {\n-\t    this->_M_invalidate_if([__victim](_Base_const_iterator __it)\n-\t\t\t    { return __it == __victim; });\n-\t    this->_M_invalidate_local_if(\n-\t\t\t    [__victim](_Base_const_local_iterator __it)\n-\t\t\t    { return __it._M_curr() == __victim._M_cur; });\n-\t    size_type __bucket_count = this->bucket_count();\n-\t    _Base::erase(__victim);\n-\t    _M_check_rehashed(__bucket_count);\n+\t    _M_erase(__victim);\n \t    __ret = 1;\n \t  }\n \treturn __ret;\n@@ -594,43 +571,33 @@ namespace __debug\n       erase(const_iterator __it)\n       {\n \t__glibcxx_check_erase(__it);\n-\t_Base_const_iterator __victim = __it.base();\n-\tthis->_M_invalidate_if([__victim](_Base_const_iterator __it)\n-\t\t\t{ return __it == __victim; });\n-\tthis->_M_invalidate_local_if(\n-\t\t\t[__victim](_Base_const_local_iterator __it)\n-\t\t\t{ return __it._M_curr() == __victim._M_cur; });\n-\tsize_type __bucket_count = this->bucket_count();\n-\t_Base_iterator __next = _Base::erase(__it.base());\n-\t_M_check_rehashed(__bucket_count);\n-\treturn iterator(__next, this);\n+\treturn { _M_erase(__it.base()), this };\n       }\n \n       iterator\n       erase(iterator __it)\n-      { return erase(const_iterator(__it)); }\n+      {\n+\t__glibcxx_check_erase(__it);\n+\treturn { _M_erase(__it.base()), this };\n+      }\n \n       iterator\n       erase(const_iterator __first, const_iterator __last)\n       {\n \t__glibcxx_check_erase_range(__first, __last);\n-\tfor (_Base_const_iterator __tmp = __first.base();\n-\t     __tmp != __last.base(); ++__tmp)\n+\tfor (auto __tmp = __first.base(); __tmp != __last.base(); ++__tmp)\n \t  {\n-\t    _GLIBCXX_DEBUG_VERIFY(__tmp != _Base::end(),\n+\t    _GLIBCXX_DEBUG_VERIFY(__tmp != _Base::cend(),\n \t\t\t\t  _M_message(__gnu_debug::__msg_valid_range)\n \t\t\t\t  ._M_iterator(__first, \"first\")\n \t\t\t\t  ._M_iterator(__last, \"last\"));\n-\t    this->_M_invalidate_if([__tmp](_Base_const_iterator __it)\n-\t\t\t    { return __it == __tmp; });\n-\t    this->_M_invalidate_local_if(\n-\t\t\t    [__tmp](_Base_const_local_iterator __it)\n-\t\t\t    { return __it._M_curr() == __tmp._M_cur; });\n+\t    _M_invalidate(__tmp);\n \t  }\n+\n \tsize_type __bucket_count = this->bucket_count();\n-\t_Base_iterator __next = _Base::erase(__first.base(), __last.base());\n+\tauto __next = _Base::erase(__first.base(), __last.base());\n \t_M_check_rehashed(__bucket_count);\n-\treturn iterator(__next, this);\n+\treturn { __next, this };\n       }\n \n       _Base&\n@@ -646,6 +613,35 @@ namespace __debug\n \tif (__prev_count != this->bucket_count())\n \t  this->_M_invalidate_locals();\n       }\n+\n+      void\n+      _M_invalidate(_Base_const_iterator __victim)\n+      {\n+\tthis->_M_invalidate_if(\n+\t  [__victim](_Base_const_iterator __it) { return __it == __victim; });\n+\tthis->_M_invalidate_local_if(\n+\t  [__victim](_Base_const_local_iterator __it)\n+\t  { return __it._M_curr() == __victim._M_cur; });\n+      }\n+\n+      _Base_iterator\n+      _M_erase(_Base_const_iterator __victim)\n+      {\n+\t_M_invalidate(__victim);\n+\tsize_type __bucket_count = this->bucket_count();\n+\t_Base_iterator __next = _Base::erase(__victim);\n+\t_M_check_rehashed(__bucket_count);\n+\treturn __next;\n+      }\n+\n+#if __cplusplus > 201402L\n+      node_type\n+      _M_extract(_Base_const_iterator __victim)\n+      {\n+\t_M_invalidate(__victim);\n+\treturn _Base::extract(__victim);\n+      }\n+#endif\n     };\n \n #if __cpp_deduction_guides >= 201606\n@@ -905,69 +901,69 @@ namespace __debug\n \n       iterator\n       begin() noexcept\n-      { return iterator(_Base::begin(), this); }\n+      { return { _Base::begin(), this }; }\n \n       const_iterator\n       begin() const noexcept\n-      { return const_iterator(_Base::begin(), this); }\n+      { return { _Base::begin(), this }; }\n \n       iterator\n       end() noexcept\n-      { return iterator(_Base::end(), this); }\n+      { return { _Base::end(), this }; }\n \n       const_iterator\n       end() const noexcept\n-      { return const_iterator(_Base::end(), this); }\n+      { return { _Base::end(), this }; }\n \n       const_iterator\n       cbegin() const noexcept\n-      { return const_iterator(_Base::begin(), this); }\n+      { return { _Base::cbegin(), this }; }\n \n       const_iterator\n       cend() const noexcept\n-      { return const_iterator(_Base::end(), this); }\n+      { return { _Base::cend(), this }; }\n \n       // local versions\n       local_iterator\n       begin(size_type __b)\n       {\n \t__glibcxx_check_bucket_index(__b);\n-\treturn local_iterator(_Base::begin(__b), this);\n+\treturn { _Base::begin(__b), this };\n       }\n \n       local_iterator\n       end(size_type __b)\n       {\n \t__glibcxx_check_bucket_index(__b);\n-\treturn local_iterator(_Base::end(__b), this);\n+\treturn { _Base::end(__b), this };\n       }\n \n       const_local_iterator\n       begin(size_type __b) const\n       {\n \t__glibcxx_check_bucket_index(__b);\n-\treturn const_local_iterator(_Base::begin(__b), this);\n+\treturn { _Base::begin(__b), this };\n       }\n \n       const_local_iterator\n       end(size_type __b) const\n       {\n \t__glibcxx_check_bucket_index(__b);\n-\treturn const_local_iterator(_Base::end(__b), this);\n+\treturn { _Base::end(__b), this };\n       }\n \n       const_local_iterator\n       cbegin(size_type __b) const\n       {\n \t__glibcxx_check_bucket_index(__b);\n-\treturn const_local_iterator(_Base::cbegin(__b), this);\n+\treturn { _Base::cbegin(__b), this };\n       }\n \n       const_local_iterator\n       cend(size_type __b) const\n       {\n \t__glibcxx_check_bucket_index(__b);\n-\treturn const_local_iterator(_Base::cend(__b), this);\n+\treturn { _Base::cend(__b), this };\n       }\n \n       size_type\n@@ -993,10 +989,9 @@ namespace __debug\n \templace(_Args&&... __args)\n \t{\n \t  size_type __bucket_count = this->bucket_count();\n-\t  _Base_iterator __it\n-\t    = _Base::emplace(std::forward<_Args>(__args)...);\n+\t  auto __it = _Base::emplace(std::forward<_Args>(__args)...);\n \t  _M_check_rehashed(__bucket_count);\n-\t  return iterator(__it, this);\n+\t  return { __it, this };\n \t}\n \n       template<typename... _Args>\n@@ -1005,19 +1000,19 @@ namespace __debug\n \t{\n \t  __glibcxx_check_insert(__hint);\n \t  size_type __bucket_count = this->bucket_count();\n-\t  _Base_iterator __it = _Base::emplace_hint(__hint.base(),\n-\t\t\t\t\tstd::forward<_Args>(__args)...);\n+\t  auto __it = _Base::emplace_hint(__hint.base(),\n+\t\t\t\t\t  std::forward<_Args>(__args)...);\n \t  _M_check_rehashed(__bucket_count);\n-\t  return iterator(__it, this);\n+\t  return { __it, this };\n \t}\n \n       iterator\n       insert(const value_type& __obj)\n       {\n \tsize_type __bucket_count = this->bucket_count();\n-\t_Base_iterator __it = _Base::insert(__obj);\n+\tauto __it = _Base::insert(__obj);\n \t_M_check_rehashed(__bucket_count);\n-\treturn iterator(__it, this);\n+\treturn { __it, this };\n       }\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n@@ -1036,9 +1031,9 @@ namespace __debug\n       {\n \t__glibcxx_check_insert(__hint);\n \tsize_type __bucket_count = this->bucket_count();\n-\t_Base_iterator __it = _Base::insert(__hint.base(), __obj);\n+\tauto __it = _Base::insert(__hint.base(), __obj);\n \t_M_check_rehashed(__bucket_count);\n-\treturn iterator(__it, this);\n+\treturn { __it, this };\n       }\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n@@ -1050,7 +1045,7 @@ namespace __debug\n \tsize_type __bucket_count = this->bucket_count();\n \tauto __it = _Base::insert(__hint.base(), std::move(__x));\n \t_M_check_rehashed(__bucket_count);\n-\treturn iterator(__it, this);\n+\treturn { __it, this };\n       }\n \n       template<typename _Pair, typename = typename\n@@ -1060,9 +1055,9 @@ namespace __debug\n \tinsert(_Pair&& __obj)\n \t{\n \t  size_type __bucket_count = this->bucket_count();\n-\t  _Base_iterator __it = _Base::insert(std::forward<_Pair>(__obj));\n+\t  auto __it = _Base::insert(std::forward<_Pair>(__obj));\n \t  _M_check_rehashed(__bucket_count);\n-\t  return iterator(__it, this);\n+\t  return { __it, this };\n \t}\n \n       template<typename _Pair, typename = typename\n@@ -1073,10 +1068,9 @@ namespace __debug\n \t{\n \t  __glibcxx_check_insert(__hint);\n \t  size_type __bucket_count = this->bucket_count();\n-\t  _Base_iterator __it =\n-\t    _Base::insert(__hint.base(), std::forward<_Pair>(__obj));\n+\t  auto __it = _Base::insert(__hint.base(), std::forward<_Pair>(__obj));\n \t  _M_check_rehashed(__bucket_count);\n-\t  return iterator(__it, this);\n+\t  return { __it, this };\n \t}\n \n       void\n@@ -1107,83 +1101,67 @@ namespace __debug\n       extract(const_iterator __position)\n       {\n \t__glibcxx_check_erase(__position);\n-\t_Base_const_iterator __victim = __position.base();\n-\tthis->_M_invalidate_if(\n-\t    [__victim](_Base_const_iterator __it) { return __it == __victim; }\n-\t    );\n-\tthis->_M_invalidate_local_if(\n-\t    [__victim](_Base_const_local_iterator __it) {\n-\t\treturn __it._M_curr() == __victim._M_cur;\n-\t    });\n-\treturn _Base::extract(__position.base());\n+\treturn _M_extract(__position.base());\n       }\n \n       node_type\n       extract(const key_type& __key)\n       {\n-\tconst auto __position = find(__key);\n-\tif (__position != end())\n-\t  return extract(__position);\n+\tconst auto __position = _Base::find(__key);\n+\tif (__position != _Base::end())\n+\t  return _M_extract(__position);\n \treturn {};\n       }\n \n       iterator\n       insert(node_type&& __nh)\n-      { return iterator(_Base::insert(std::move(__nh)), this); }\n+      { return { _Base::insert(std::move(__nh)), this }; }\n \n       iterator\n       insert(const_iterator __hint, node_type&& __nh)\n       {\n \t__glibcxx_check_insert(__hint);\n-\treturn iterator(_Base::insert(__hint.base(), std::move(__nh)), this);\n+\treturn { _Base::insert(__hint.base(), std::move(__nh)), this };\n       }\n \n       using _Base::merge;\n #endif // C++17\n \n       iterator\n       find(const key_type& __key)\n-      { return iterator(_Base::find(__key), this); }\n+      { return { _Base::find(__key), this }; }\n \n       const_iterator\n       find(const key_type& __key) const\n-      { return const_iterator(_Base::find(__key), this); }\n+      { return { _Base::find(__key), this }; }\n \n       std::pair<iterator, iterator>\n       equal_range(const key_type& __key)\n       {\n-\tstd::pair<_Base_iterator, _Base_iterator> __res =\n-\t  _Base::equal_range(__key);\n-\treturn std::make_pair(iterator(__res.first, this),\n-\t\t\t      iterator(__res.second, this));\n+\tauto __res = _Base::equal_range(__key);\n+\treturn { { __res.first, this }, { __res.second, this } };\n       }\n \n       std::pair<const_iterator, const_iterator>\n       equal_range(const key_type& __key) const\n       {\n-\tstd::pair<_Base_const_iterator, _Base_const_iterator> __res =\n-\t  _Base::equal_range(__key);\n-\treturn std::make_pair(const_iterator(__res.first, this),\n-\t\t\t      const_iterator(__res.second, this));\n+\tauto __res = _Base::equal_range(__key);\n+\treturn { { __res.first, this }, { __res.second, this } };\n       }\n \n       size_type\n       erase(const key_type& __key)\n       {\n \tsize_type __ret(0);\n \tsize_type __bucket_count = this->bucket_count();\n-\tstd::pair<_Base_iterator, _Base_iterator> __pair =\n-\t  _Base::equal_range(__key);\n-\tfor (_Base_iterator __victim = __pair.first; __victim != __pair.second;)\n+\tauto __pair = _Base::equal_range(__key);\n+\tfor (auto __victim = __pair.first; __victim != __pair.second;)\n \t  {\n-\t    this->_M_invalidate_if([__victim](_Base_const_iterator __it)\n-\t\t\t    { return __it == __victim; });\n-\t    this->_M_invalidate_local_if(\n-\t\t\t    [__victim](_Base_const_local_iterator __it)\n-\t\t\t    { return __it._M_curr() == __victim._M_cur; });\n-\t    _Base::erase(__victim++);\n+\t    _M_invalidate(__victim);\n+\t    __victim = _Base::erase(__victim);\n \t    ++__ret;\n \t  }\n+\n \t_M_check_rehashed(__bucket_count);\n \treturn __ret;\n       }\n@@ -1192,43 +1170,33 @@ namespace __debug\n       erase(const_iterator __it)\n       {\n \t__glibcxx_check_erase(__it);\n-\t_Base_const_iterator __victim = __it.base();\n-\tthis->_M_invalidate_if([__victim](_Base_const_iterator __it)\n-\t\t\t{ return __it == __victim; });\n-\tthis->_M_invalidate_local_if(\n-\t\t\t[__victim](_Base_const_local_iterator __it)\n-\t\t\t{ return __it._M_curr() == __victim._M_cur; });\n-\tsize_type __bucket_count = this->bucket_count();\n-\t_Base_iterator __next = _Base::erase(__it.base());\n-\t_M_check_rehashed(__bucket_count);\n-\treturn iterator(__next, this);\n+\treturn { _M_erase(__it.base()), this };\n       }\n \n       iterator\n       erase(iterator __it)\n-      { return erase(const_iterator(__it)); }\n+      {\n+\t__glibcxx_check_erase(__it);\n+\treturn { _M_erase(__it.base()), this };\n+      }\n \n       iterator\n       erase(const_iterator __first, const_iterator __last)\n       {\n \t__glibcxx_check_erase_range(__first, __last);\n-\tfor (_Base_const_iterator __tmp = __first.base();\n-\t     __tmp != __last.base(); ++__tmp)\n+\tfor (auto __tmp = __first.base(); __tmp != __last.base(); ++__tmp)\n \t  {\n-\t    _GLIBCXX_DEBUG_VERIFY(__tmp != _Base::end(),\n+\t    _GLIBCXX_DEBUG_VERIFY(__tmp != _Base::cend(),\n \t\t\t\t  _M_message(__gnu_debug::__msg_valid_range)\n \t\t\t\t  ._M_iterator(__first, \"first\")\n \t\t\t\t  ._M_iterator(__last, \"last\"));\n-\t    this->_M_invalidate_if([__tmp](_Base_const_iterator __it)\n-\t\t\t    { return __it == __tmp; });\n-\t    this->_M_invalidate_local_if(\n-\t\t\t    [__tmp](_Base_const_local_iterator __it)\n-\t\t\t    { return __it._M_curr() == __tmp._M_cur; });\n+\t    _M_invalidate(__tmp);\n \t  }\n+\n \tsize_type __bucket_count = this->bucket_count();\n-\t_Base_iterator __next = _Base::erase(__first.base(), __last.base());\n+\tauto __next = _Base::erase(__first.base(), __last.base());\n \t_M_check_rehashed(__bucket_count);\n-\treturn iterator(__next, this);\n+\treturn { __next, this };\n       }\n \n       _Base&\n@@ -1244,6 +1212,35 @@ namespace __debug\n \tif (__prev_count != this->bucket_count())\n \t  this->_M_invalidate_locals();\n       }\n+\n+      void\n+      _M_invalidate(_Base_const_iterator __victim)\n+      {\n+\tthis->_M_invalidate_if(\n+\t  [__victim](_Base_const_iterator __it) { return __it == __victim; });\n+\tthis->_M_invalidate_local_if(\n+\t  [__victim](_Base_const_local_iterator __it)\n+\t  { return __it._M_curr() == __victim._M_cur; });\n+      }\n+\n+      _Base_iterator\n+      _M_erase(_Base_const_iterator __victim)\n+      {\n+\t_M_invalidate(__victim);\n+\tsize_type __bucket_count = this->bucket_count();\n+\t_Base_iterator __next = _Base::erase(__victim);\n+\t_M_check_rehashed(__bucket_count);\n+\treturn __next;\n+      }\n+\n+#if __cplusplus > 201402L\n+      node_type\n+      _M_extract(_Base_const_iterator __victim)\n+      {\n+\t_M_invalidate(__victim);\n+\treturn _Base::extract(__victim);\n+      }\n+#endif\n     };\n \n #if __cpp_deduction_guides >= 201606"}, {"sha": "7ccb16ad5e4ea5bc75a8f22c55c02083ddc069b0", "filename": "libstdc++-v3/include/debug/unordered_set", "status": "modified", "additions": 161, "deletions": 165, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b763deedb282b480fe4c2b3a8ad07192393f1b1/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b763deedb282b480fe4c2b3a8ad07192393f1b1/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set?ref=4b763deedb282b480fe4c2b3a8ad07192393f1b1", "patch": "@@ -211,69 +211,69 @@ namespace __debug\n \n       iterator\n       begin() noexcept\n-      { return iterator(_Base::begin(), this); }\n+      { return { _Base::begin(), this }; }\n \n       const_iterator\n       begin() const noexcept\n-      { return const_iterator(_Base::begin(), this); }\n+      { return { _Base::begin(), this }; }\n \n       iterator\n       end() noexcept\n-      { return iterator(_Base::end(), this); }\n+      { return { _Base::end(), this }; }\n \n       const_iterator\n       end() const noexcept\n-      { return const_iterator(_Base::end(), this); }\n+      { return { _Base::end(), this }; }\n \n       const_iterator\n       cbegin() const noexcept\n-      { return const_iterator(_Base::begin(), this); }\n+      { return { _Base::cbegin(), this }; }\n \n       const_iterator\n       cend() const noexcept\n-      { return const_iterator(_Base::end(), this); }\n+      { return { _Base::cend(), this }; }\n \n       // local versions\n       local_iterator\n       begin(size_type __b)\n       {\n \t__glibcxx_check_bucket_index(__b);\n-\treturn local_iterator(_Base::begin(__b), this);\n+\treturn { _Base::begin(__b), this };\n       }\n \n       local_iterator\n       end(size_type __b)\n       {\n \t__glibcxx_check_bucket_index(__b);\n-\treturn local_iterator(_Base::end(__b), this);\n+\treturn { _Base::end(__b), this };\n       }\n \n       const_local_iterator\n       begin(size_type __b) const\n       {\n \t__glibcxx_check_bucket_index(__b);\n-\treturn const_local_iterator(_Base::begin(__b), this);\n+\treturn { _Base::begin(__b), this };\n       }\n \n       const_local_iterator\n       end(size_type __b) const\n       {\n \t__glibcxx_check_bucket_index(__b);\n-\treturn const_local_iterator(_Base::end(__b), this);\n+\treturn { _Base::end(__b), this };\n       }\n \n       const_local_iterator\n       cbegin(size_type __b) const\n       {\n \t__glibcxx_check_bucket_index(__b);\n-\treturn const_local_iterator(_Base::cbegin(__b), this);\n+\treturn { _Base::cbegin(__b), this };\n       }\n \n       const_local_iterator\n       cend(size_type __b) const\n       {\n \t__glibcxx_check_bucket_index(__b);\n-\treturn const_local_iterator(_Base::cend(__b), this);\n+\treturn { _Base::cend(__b), this };\n       }\n \n       size_type\n@@ -299,10 +299,9 @@ namespace __debug\n \templace(_Args&&... __args)\n \t{\n \t  size_type __bucket_count = this->bucket_count();\n-\t  std::pair<_Base_iterator, bool> __res\n-\t    = _Base::emplace(std::forward<_Args>(__args)...);\n+\t  auto __res = _Base::emplace(std::forward<_Args>(__args)...);\n \t  _M_check_rehashed(__bucket_count);\n-\t  return std::make_pair(iterator(__res.first, this), __res.second);\n+\t  return { { __res.first, this }, __res.second };\n \t}\n \n       template<typename... _Args>\n@@ -311,50 +310,48 @@ namespace __debug\n \t{\n \t  __glibcxx_check_insert(__hint);\n \t  size_type __bucket_count = this->bucket_count();\n-\t  _Base_iterator __it = _Base::emplace_hint(__hint.base(),\n-\t\t\t\t\tstd::forward<_Args>(__args)...);\n+\t  auto __it = _Base::emplace_hint(__hint.base(),\n+\t\t\t\t\t  std::forward<_Args>(__args)...);\n \t  _M_check_rehashed(__bucket_count);\n-\t  return iterator(__it, this);\n+\t  return { __it, this };\n \t}\n \n       std::pair<iterator, bool>\n       insert(const value_type& __obj)\n       {\n \tsize_type __bucket_count = this->bucket_count();\n-\tstd::pair<_Base_iterator, bool> __res\n-\t  = _Base::insert(__obj);\n+\tauto __res = _Base::insert(__obj);\n \t_M_check_rehashed(__bucket_count);\n-\treturn std::make_pair(iterator(__res.first, this), __res.second);\n+\treturn { { __res.first, this }, __res.second };\n       }\n \n       iterator\n       insert(const_iterator __hint, const value_type& __obj)\n       {\n \t__glibcxx_check_insert(__hint);\n \tsize_type __bucket_count = this->bucket_count();\n-\t_Base_iterator __it = _Base::insert(__hint.base(), __obj);\n+\tauto __it = _Base::insert(__hint.base(), __obj);\n \t_M_check_rehashed(__bucket_count);\n-\treturn iterator(__it, this);\n+\treturn { __it, this };\n       }\n \n       std::pair<iterator, bool>\n       insert(value_type&& __obj)\n       {\n \tsize_type __bucket_count = this->bucket_count();\n-\tstd::pair<_Base_iterator, bool> __res\n-\t  = _Base::insert(std::move(__obj));\n+\tauto __res = _Base::insert(std::move(__obj));\n \t_M_check_rehashed(__bucket_count);\n-\treturn std::make_pair(iterator(__res.first, this), __res.second);\n+\treturn { { __res.first, this }, __res.second };\n       }\n \n       iterator\n       insert(const_iterator __hint, value_type&& __obj)\n       {\n \t__glibcxx_check_insert(__hint);\n \tsize_type __bucket_count = this->bucket_count();\n-\t_Base_iterator __it = _Base::insert(__hint.base(), std::move(__obj));\n+\tauto __it = _Base::insert(__hint.base(), std::move(__obj));\n \t_M_check_rehashed(__bucket_count);\n-\treturn iterator(__it, this);\n+\treturn { __it, this };\n       }\n \n       void\n@@ -390,86 +387,66 @@ namespace __debug\n       extract(const_iterator __position)\n       {\n \t__glibcxx_check_erase(__position);\n-\t_Base_const_iterator __victim = __position.base();\n-\tthis->_M_invalidate_if(\n-\t    [__victim](_Base_const_iterator __it) { return __it == __victim; }\n-\t    );\n-\tthis->_M_invalidate_local_if(\n-\t    [__victim](_Base_const_local_iterator __it) {\n-\t\treturn __it._M_curr() == __victim._M_cur;\n-\t    });\n-\treturn _Base::extract(__position.base());\n+\treturn _M_extract(__position.base());\n       }\n \n       node_type\n       extract(const key_type& __key)\n       {\n-\tconst auto __position = find(__key);\n-\tif (__position != end())\n-\t  return extract(__position);\n+\tconst auto __position = _Base::find(__key);\n+\tif (__position != _Base::end())\n+\t  return _M_extract(__position);\n \treturn {};\n       }\n \n       insert_return_type\n       insert(node_type&& __nh)\n       {\n \tauto __ret = _Base::insert(std::move(__nh));\n-\titerator __pos = iterator(__ret.position, this);\n-\treturn { __pos, __ret.inserted, std::move(__ret.node) };\n+\treturn\n+\t  { { __ret.position, this }, __ret.inserted, std::move(__ret.node) };\n       }\n \n       iterator\n       insert(const_iterator __hint, node_type&& __nh)\n       {\n \t__glibcxx_check_insert(__hint);\n-\treturn iterator(_Base::insert(__hint.base(), std::move(__nh)), this);\n+\treturn { _Base::insert(__hint.base(), std::move(__nh)), this };\n       }\n \n       using _Base::merge;\n #endif // C++17\n \n       iterator\n       find(const key_type& __key)\n-      { return iterator(_Base::find(__key), this); }\n+      { return { _Base::find(__key), this }; }\n \n       const_iterator\n       find(const key_type& __key) const\n-      { return const_iterator(_Base::find(__key), this); }\n+      { return { _Base::find(__key), this }; }\n \n       std::pair<iterator, iterator>\n       equal_range(const key_type& __key)\n       {\n-\tstd::pair<_Base_iterator, _Base_iterator> __res\n-\t  = _Base::equal_range(__key);\n-\treturn std::make_pair(iterator(__res.first, this),\n-\t\t\t      iterator(__res.second, this));\n+\tauto __res = _Base::equal_range(__key);\n+\treturn { { __res.first, this }, { __res.second, this } };\n       }\n \n       std::pair<const_iterator, const_iterator>\n       equal_range(const key_type& __key) const\n       {\n-\tstd::pair<_Base_const_iterator, _Base_const_iterator>\n-\t  __res = _Base::equal_range(__key);\n-\treturn std::make_pair(const_iterator(__res.first, this),\n-\t\t\t      const_iterator(__res.second, this));\n+\tauto __res = _Base::equal_range(__key);\n+\treturn { { __res.first, this }, { __res.second, this } };\n       }\n \n       size_type\n       erase(const key_type& __key)\n       {\n \tsize_type __ret(0);\n-\t_Base_iterator __victim(_Base::find(__key));\n+\tauto __victim = _Base::find(__key);\n \tif (__victim != _Base::end())\n \t  {\n-\t    this->_M_invalidate_if(\n-\t\t\t    [__victim](_Base_const_iterator __it)\n-\t\t\t    { return __it == __victim; });\n-\t    this->_M_invalidate_local_if(\n-\t\t\t    [__victim](_Base_const_local_iterator __it)\n-\t\t\t    { return __it._M_curr() == __victim._M_cur; });\n-\t    size_type __bucket_count = this->bucket_count();\n-\t    _Base::erase(__victim);\n-\t    _M_check_rehashed(__bucket_count);\n+\t    _M_erase(__victim);\n \t    __ret = 1;\n \t  }\n \treturn __ret;\n@@ -479,46 +456,33 @@ namespace __debug\n       erase(const_iterator __it)\n       {\n \t__glibcxx_check_erase(__it);\n-\t_Base_const_iterator __victim = __it.base();\n-\tthis->_M_invalidate_if(\n-\t\t\t[__victim](_Base_const_iterator __it)\n-\t\t\t{ return __it == __victim; });\n-\tthis->_M_invalidate_local_if(\n-\t\t\t[__victim](_Base_const_local_iterator __it)\n-\t\t\t{ return __it._M_curr() == __victim._M_cur; });\n-\tsize_type __bucket_count = this->bucket_count();\n-\t_Base_iterator __next = _Base::erase(__it.base());\n-\t_M_check_rehashed(__bucket_count);\n-\treturn iterator(__next, this);\n+\treturn { _M_erase(__it.base()), this };\n       }\n \n       iterator\n       erase(iterator __it)\n-      { return erase(const_iterator(__it)); }\n+      {\n+\t__glibcxx_check_erase(__it);\n+\treturn { _M_erase(__it.base()), this };\n+      }\n \n       iterator\n       erase(const_iterator __first, const_iterator __last)\n       {\n \t__glibcxx_check_erase_range(__first, __last);\n-\tfor (_Base_const_iterator __tmp = __first.base();\n-\t     __tmp != __last.base(); ++__tmp)\n+\tfor (auto __tmp = __first.base(); __tmp != __last.base(); ++__tmp)\n \t  {\n-\t    _GLIBCXX_DEBUG_VERIFY(__tmp != _Base::end(),\n+\t    _GLIBCXX_DEBUG_VERIFY(__tmp != _Base::cend(),\n \t\t\t\t  _M_message(__gnu_debug::__msg_valid_range)\n \t\t\t\t  ._M_iterator(__first, \"first\")\n \t\t\t\t  ._M_iterator(__last, \"last\"));\n-\t    this->_M_invalidate_if(\n-\t\t\t    [__tmp](_Base_const_iterator __it)\n-\t\t\t    { return __it == __tmp; });\n-\t    this->_M_invalidate_local_if(\n-\t\t\t    [__tmp](_Base_const_local_iterator __it)\n-\t\t\t    { return __it._M_curr() == __tmp._M_cur; });\n+\t    _M_invalidate(__tmp);\n \t  }\n+\n \tsize_type __bucket_count = this->bucket_count();\n-\t_Base_iterator __next = _Base::erase(__first.base(),\n-\t\t\t\t\t     __last.base());\n+\tauto __next = _Base::erase(__first.base(), __last.base());\n \t_M_check_rehashed(__bucket_count);\n-\treturn iterator(__next, this);\n+\treturn { __next, this };\n       }\n \n       _Base&\n@@ -534,6 +498,35 @@ namespace __debug\n \tif (__prev_count != this->bucket_count())\n \t  this->_M_invalidate_locals();\n       }\n+\n+      void\n+      _M_invalidate(_Base_const_iterator __victim)\n+      {\n+\tthis->_M_invalidate_if(\n+\t  [__victim](_Base_const_iterator __it) { return __it == __victim; });\n+\tthis->_M_invalidate_local_if(\n+\t  [__victim](_Base_const_local_iterator __it)\n+\t  { return __it._M_curr() == __victim._M_cur; });\n+      }\n+\n+      _Base_iterator\n+      _M_erase(_Base_const_iterator __victim)\n+      {\n+\t_M_invalidate(__victim);\n+\tsize_type __bucket_count = this->bucket_count();\n+\t_Base_iterator __next = _Base::erase(__victim);\n+\t_M_check_rehashed(__bucket_count);\n+\treturn __next;\n+      }\n+\n+#if __cplusplus > 201402L\n+      node_type\n+      _M_extract(_Base_const_iterator __victim)\n+      {\n+\t_M_invalidate(__victim);\n+\treturn _Base::extract(__victim);\n+      }\n+#endif\n     };\n \n #if __cpp_deduction_guides >= 201606\n@@ -779,69 +772,69 @@ namespace __debug\n \n       iterator\n       begin() noexcept\n-      { return iterator(_Base::begin(), this); }\n+      { return { _Base::begin(), this }; }\n \n       const_iterator\n       begin() const noexcept\n-      { return const_iterator(_Base::begin(), this); }\n+      { return { _Base::begin(), this }; }\n \n       iterator\n       end() noexcept\n-      { return iterator(_Base::end(), this); }\n+      { return { _Base::end(), this }; }\n \n       const_iterator\n       end() const noexcept\n-      { return const_iterator(_Base::end(), this); }\n+      { return { _Base::end(), this }; }\n \n       const_iterator\n       cbegin() const noexcept\n-      { return const_iterator(_Base::begin(), this); }\n+      { return { _Base::cbegin(), this }; }\n \n       const_iterator\n       cend() const noexcept\n-      { return const_iterator(_Base::end(), this); }\n+      { return { _Base::cend(), this }; }\n \n       // local versions\n       local_iterator\n       begin(size_type __b)\n       {\n \t__glibcxx_check_bucket_index(__b);\n-\treturn local_iterator(_Base::begin(__b), this);\n+\treturn { _Base::begin(__b), this };\n       }\n \n       local_iterator\n       end(size_type __b)\n       {\n \t__glibcxx_check_bucket_index(__b);\n-\treturn local_iterator(_Base::end(__b), this);\n+\treturn { _Base::end(__b), this };\n       }\n \n       const_local_iterator\n       begin(size_type __b) const\n       {\n \t__glibcxx_check_bucket_index(__b);\n-\treturn const_local_iterator(_Base::begin(__b), this);\n+\treturn { _Base::begin(__b), this };\n       }\n \n       const_local_iterator\n       end(size_type __b) const\n       {\n \t__glibcxx_check_bucket_index(__b);\n-\treturn const_local_iterator(_Base::end(__b), this);\n+\treturn { _Base::end(__b), this };\n       }\n \n       const_local_iterator\n       cbegin(size_type __b) const\n       {\n \t__glibcxx_check_bucket_index(__b);\n-\treturn const_local_iterator(_Base::cbegin(__b), this);\n+\treturn { _Base::cbegin(__b), this };\n       }\n \n       const_local_iterator\n       cend(size_type __b) const\n       {\n \t__glibcxx_check_bucket_index(__b);\n-\treturn const_local_iterator(_Base::cend(__b), this);\n+\treturn { _Base::cend(__b), this };\n       }\n \n       size_type\n@@ -867,10 +860,9 @@ namespace __debug\n \templace(_Args&&... __args)\n \t{\n \t  size_type __bucket_count = this->bucket_count();\n-\t  _Base_iterator __it\n-\t    = _Base::emplace(std::forward<_Args>(__args)...);\n+\t  auto __it = _Base::emplace(std::forward<_Args>(__args)...);\n \t  _M_check_rehashed(__bucket_count);\n-\t  return iterator(__it, this);\n+\t  return { __it, this };\n \t}\n \n       template<typename... _Args>\n@@ -879,48 +871,48 @@ namespace __debug\n \t{\n \t  __glibcxx_check_insert(__hint);\n \t  size_type __bucket_count = this->bucket_count();\n-\t  _Base_iterator __it = _Base::emplace_hint(__hint.base(),\n-\t\t\t\t\tstd::forward<_Args>(__args)...);\n+\t  auto __it = _Base::emplace_hint(__hint.base(),\n+\t\t\t\t\t  std::forward<_Args>(__args)...);\n \t  _M_check_rehashed(__bucket_count);\n-\t  return iterator(__it, this);\n+\t  return { __it, this };\n \t}\n \n       iterator\n       insert(const value_type& __obj)\n       {\n \tsize_type __bucket_count = this->bucket_count();\n-\t_Base_iterator __it = _Base::insert(__obj);\n+\tauto __it = _Base::insert(__obj);\n \t_M_check_rehashed(__bucket_count);\n-\treturn iterator(__it, this);\n+\treturn { __it, this };\n       }\n \n       iterator\n       insert(const_iterator __hint, const value_type& __obj)\n       {\n \t__glibcxx_check_insert(__hint);\n \tsize_type __bucket_count = this->bucket_count();\n-\t_Base_iterator __it = _Base::insert(__hint.base(), __obj);\n+\tauto __it = _Base::insert(__hint.base(), __obj);\n \t_M_check_rehashed(__bucket_count);\n-\treturn iterator(__it, this);\n+\treturn { __it, this };\n       }\n \n       iterator\n       insert(value_type&& __obj)\n       {\n \tsize_type __bucket_count = this->bucket_count();\n-\t_Base_iterator __it = _Base::insert(std::move(__obj));\n+\tauto __it = _Base::insert(std::move(__obj));\n \t_M_check_rehashed(__bucket_count);\n-\treturn iterator(__it, this);\n+\treturn { __it, this };\n       }\n \n       iterator\n       insert(const_iterator __hint, value_type&& __obj)\n       {\n \t__glibcxx_check_insert(__hint);\n \tsize_type __bucket_count = this->bucket_count();\n-\t_Base_iterator __it = _Base::insert(__hint.base(), std::move(__obj));\n+\tauto __it = _Base::insert(__hint.base(), std::move(__obj));\n \t_M_check_rehashed(__bucket_count);\n-\treturn iterator(__it, this);\n+\treturn { __it, this };\n       }\n \n       void\n@@ -955,121 +947,96 @@ namespace __debug\n       extract(const_iterator __position)\n       {\n \t__glibcxx_check_erase(__position);\n-\t_Base_const_iterator __victim = __position.base();\n-\tthis->_M_invalidate_if(\n-\t    [__victim](_Base_const_iterator __it) { return __it == __victim; }\n-\t    );\n-\tthis->_M_invalidate_local_if(\n-\t    [__victim](_Base_const_local_iterator __it) {\n-\t\treturn __it._M_curr() == __victim._M_cur;\n-\t    });\n-\treturn _Base::extract(__position.base());\n+\treturn _M_extract(__position.base());\n       }\n \n       node_type\n       extract(const key_type& __key)\n       {\n-\tconst auto __position = find(__key);\n-\tif (__position != end())\n-\t  return extract(__position);\n+\tconst auto __position = _Base::find(__key);\n+\tif (__position != _Base::end())\n+\t  return _M_extract(__position);\n \treturn {};\n       }\n \n       iterator\n       insert(node_type&& __nh)\n-      { return iterator(_Base::insert(std::move(__nh)), this); }\n+      { return { _Base::insert(std::move(__nh)), this }; }\n \n       iterator\n       insert(const_iterator __hint, node_type&& __nh)\n       {\n \t__glibcxx_check_insert(__hint);\n-\treturn iterator(_Base::insert(__hint.base(), std::move(__nh)), this);\n+\treturn { _Base::insert(__hint.base(), std::move(__nh)), this };\n       }\n \n       using _Base::merge;\n #endif // C++17\n \n       iterator\n       find(const key_type& __key)\n-      { return iterator(_Base::find(__key), this); }\n+      { return { _Base::find(__key), this }; }\n \n       const_iterator\n       find(const key_type& __key) const\n-      { return const_iterator(_Base::find(__key), this); }\n+      { return { _Base::find(__key), this }; }\n \n       std::pair<iterator, iterator>\n       equal_range(const key_type& __key)\n       {\n-\tstd::pair<_Base_iterator, _Base_iterator> __res\n-\t  = _Base::equal_range(__key);\n-\treturn std::make_pair(iterator(__res.first, this),\n-\t\t\t      iterator(__res.second, this));\n+\tauto __res = _Base::equal_range(__key);\n+\treturn { { __res.first, this }, { __res.second, this } };\n       }\n \n       std::pair<const_iterator, const_iterator>\n       equal_range(const key_type& __key) const\n       {\n-\tstd::pair<_Base_const_iterator, _Base_const_iterator>\n-\t  __res = _Base::equal_range(__key);\n-\treturn std::make_pair(const_iterator(__res.first, this),\n-\t\t\t      const_iterator(__res.second, this));\n+\tauto __res = _Base::equal_range(__key);\n+\treturn { { __res.first, this }, { __res.second, this } };\n       }\n \n       size_type\n       erase(const key_type& __key)\n       {\n \tsize_type __ret(0);\n-\tstd::pair<_Base_iterator, _Base_iterator> __pair =\n-\t  _Base::equal_range(__key);\n-\tfor (_Base_iterator __victim = __pair.first; __victim != __pair.second;)\n+\tauto __pair = _Base::equal_range(__key);\n+\tfor (auto __victim = __pair.first; __victim != __pair.second;)\n \t  {\n-\t    this->_M_invalidate_if([__victim](_Base_const_iterator __it)\n-\t\t\t    { return __it == __victim; });\n-\t    this->_M_invalidate_local_if(\n-\t\t\t    [__victim](_Base_const_local_iterator __it)\n-\t\t\t    { return __it._M_curr() == __victim._M_cur; });\n-\t    _Base::erase(__victim++);\n+\t    _M_invalidate(__victim);\n+\t    __victim = _Base::erase(__victim);\n \t    ++__ret;\n \t  }\n+\n \treturn __ret;\n       }\n \n       iterator\n       erase(const_iterator __it)\n       {\n \t__glibcxx_check_erase(__it);\n-\t_Base_const_iterator __victim = __it.base();\n-\tthis->_M_invalidate_if([__victim](_Base_const_iterator __it)\n-\t\t\t{ return __it == __victim; });\n-\tthis->_M_invalidate_local_if(\n-\t\t\t[__victim](_Base_const_local_iterator __it)\n-\t\t\t{ return __it._M_curr() == __victim._M_cur; });\n-\treturn iterator(_Base::erase(__it.base()), this);\n+\treturn { _M_erase(__it.base()), this };\n       }\n \n       iterator\n       erase(iterator __it)\n-      { return erase(const_iterator(__it)); }\n+      {\n+\t__glibcxx_check_erase(__it);\n+\treturn { _M_erase(__it.base()), this };\n+      }\n \n       iterator\n       erase(const_iterator __first, const_iterator __last)\n       {\n \t__glibcxx_check_erase_range(__first, __last);\n-\tfor (_Base_const_iterator __tmp = __first.base();\n-\t     __tmp != __last.base(); ++__tmp)\n+\tfor (auto __tmp = __first.base(); __tmp != __last.base(); ++__tmp)\n \t  {\n-\t    _GLIBCXX_DEBUG_VERIFY(__tmp != _Base::end(),\n+\t    _GLIBCXX_DEBUG_VERIFY(__tmp != _Base::cend(),\n \t\t\t\t  _M_message(__gnu_debug::__msg_valid_range)\n \t\t\t\t  ._M_iterator(__first, \"first\")\n \t\t\t\t  ._M_iterator(__last, \"last\"));\n-\t    this->_M_invalidate_if([__tmp](_Base_const_iterator __it)\n-\t\t\t    { return __it == __tmp; });\n-\t    this->_M_invalidate_local_if(\n-\t\t\t    [__tmp](_Base_const_local_iterator __it)\n-\t\t\t    { return __it._M_curr() == __tmp._M_cur; });\n+\t    _M_invalidate(__tmp);\n \t  }\n-\treturn iterator(_Base::erase(__first.base(),\n-\t\t\t\t     __last.base()), this);\n+\treturn { _Base::erase(__first.base(), __last.base()), this };\n       }\n \n       _Base&\n@@ -1085,6 +1052,35 @@ namespace __debug\n \tif (__prev_count != this->bucket_count())\n \t  this->_M_invalidate_locals();\n       }\n+\n+      void\n+      _M_invalidate(_Base_const_iterator __victim)\n+      {\n+\tthis->_M_invalidate_if(\n+\t  [__victim](_Base_const_iterator __it) { return __it == __victim; });\n+\tthis->_M_invalidate_local_if(\n+\t  [__victim](_Base_const_local_iterator __it)\n+\t  { return __it._M_curr() == __victim._M_cur; });\n+      }\n+\n+      _Base_iterator\n+      _M_erase(_Base_const_iterator __victim)\n+      {\n+\t_M_invalidate(__victim);\n+\tsize_type __bucket_count = this->bucket_count();\n+\t_Base_iterator __next = _Base::erase(__victim);\n+\t_M_check_rehashed(__bucket_count);\n+\treturn __next;\n+      }\n+\n+#if __cplusplus > 201402L\n+      node_type\n+      _M_extract(_Base_const_iterator __victim)\n+      {\n+\t_M_invalidate(__victim);\n+\treturn _Base::extract(__victim);\n+      }\n+#endif\n     };\n \n #if __cpp_deduction_guides >= 201606\n@@ -1103,7 +1099,7 @@ namespace __debug\n \t\t       _Hash = _Hash(), _Pred = _Pred(),\n \t\t       _Allocator = _Allocator())\n     -> unordered_multiset<typename iterator_traits<_InputIterator>::value_type,\n-                          _Hash, _Pred, _Allocator>;\n+\t\t\t  _Hash, _Pred, _Allocator>;\n \n   template<typename _Tp, typename _Hash = hash<_Tp>,\n \t   typename _Pred = equal_to<_Tp>,"}]}