{"sha": "81ce375d1fdd99f9d93b00f4895eab74c3d8b54a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFjZTM3NWQxZmRkOTlmOWQ5M2IwMGY0ODk1ZWFiNzRjM2Q4YjU0YQ==", "commit": {"author": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2020-04-02T13:48:03Z"}, "committer": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2020-04-02T13:54:11Z"}, "message": "Fix PR94401 by considering reverse overrun\n\nThe commit r10-7415 brings scalar type consideration\nto eliminate epilogue peeling for gaps, but it exposed\none problem that the current handling doesn't consider\nthe memory access type VMAT_CONTIGUOUS_REVERSE, for\nwhich the overrun happens on low address side.  This\npatch is to make the code take care of it by updating\nthe offset and construction element order accordingly.\n\nBootstrapped/regtested on powerpc64le-linux-gnu P8\nand aarch64-linux-gnu.\n\n2020-04-02  Kewen Lin  <linkw@gcc.gnu.org>\n\ngcc/ChangeLog\n\n    PR tree-optimization/94401\n    * tree-vect-loop.c (vectorizable_load): Handle VMAT_CONTIGUOUS_REVERSE\n    access type when loading halves of vector to avoid peeling for gaps.", "tree": {"sha": "acc2712194440216d6a4a94c1d4c92ce520ae591", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/acc2712194440216d6a4a94c1d4c92ce520ae591"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81ce375d1fdd99f9d93b00f4895eab74c3d8b54a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81ce375d1fdd99f9d93b00f4895eab74c3d8b54a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81ce375d1fdd99f9d93b00f4895eab74c3d8b54a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81ce375d1fdd99f9d93b00f4895eab74c3d8b54a/comments", "author": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68cbee9bf53332721ae33c517ca46039368c0a95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68cbee9bf53332721ae33c517ca46039368c0a95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68cbee9bf53332721ae33c517ca46039368c0a95"}], "stats": {"total": 44, "additions": 35, "deletions": 9}, "files": [{"sha": "f0a9509d9707418be19834234e5ff3158faa01ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81ce375d1fdd99f9d93b00f4895eab74c3d8b54a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81ce375d1fdd99f9d93b00f4895eab74c3d8b54a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=81ce375d1fdd99f9d93b00f4895eab74c3d8b54a", "patch": "@@ -1,3 +1,9 @@\n+2020-04-02  Kewen Lin  <linkw@gcc.gnu.org>\n+\n+\tPR tree-optimization/94401\n+\t* tree-vect-loop.c (vectorizable_load): Handle VMAT_CONTIGUOUS_REVERSE\n+\taccess type when loading halves of vector to avoid peeling for gaps.\n+\n 2020-04-02  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/mips/mti-linux.h (SYSROOT_SUFFIX_SPEC): Add a space in"}, {"sha": "7f3a9fb5fb34ac7e914d1900b53820fa5d032385", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81ce375d1fdd99f9d93b00f4895eab74c3d8b54a/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81ce375d1fdd99f9d93b00f4895eab74c3d8b54a/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=81ce375d1fdd99f9d93b00f4895eab74c3d8b54a", "patch": "@@ -9602,11 +9602,20 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t\t    if (new_vtype != NULL_TREE)\n \t\t\t      ltype = half_vtype;\n \t\t\t  }\n+\t\t\ttree offset\n+\t\t\t  = (dataref_offset ? dataref_offset\n+\t\t\t\t\t    : build_int_cst (ref_type, 0));\n+\t\t\tif (ltype != vectype\n+\t\t\t    && memory_access_type == VMAT_CONTIGUOUS_REVERSE)\n+\t\t\t  {\n+\t\t\t    unsigned HOST_WIDE_INT gap\n+\t\t\t      = DR_GROUP_GAP (first_stmt_info);\n+\t\t\t    gap *= tree_to_uhwi (TYPE_SIZE_UNIT (elem_type));\n+\t\t\t    tree gapcst = build_int_cst (ref_type, gap);\n+\t\t\t    offset = size_binop (PLUS_EXPR, offset, gapcst);\n+\t\t\t  }\n \t\t\tdata_ref\n-\t\t\t  = fold_build2 (MEM_REF, ltype, dataref_ptr,\n-\t\t\t\t\t dataref_offset\n-\t\t\t\t\t ? dataref_offset\n-\t\t\t\t\t : build_int_cst (ref_type, 0));\n+\t\t\t  = fold_build2 (MEM_REF, ltype, dataref_ptr, offset);\n \t\t\tif (alignment_support_scheme == dr_aligned)\n \t\t\t  ;\n \t\t\telse if (DR_MISALIGNMENT (first_dr_info) == -1)\n@@ -9619,16 +9628,27 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t\t\t\t\t  TYPE_ALIGN (elem_type));\n \t\t\tif (ltype != vectype)\n \t\t\t  {\n-\t\t\t    vect_copy_ref_info (data_ref, DR_REF (first_dr_info->dr));\n+\t\t\t    vect_copy_ref_info (data_ref,\n+\t\t\t\t\t\tDR_REF (first_dr_info->dr));\n \t\t\t    tree tem = make_ssa_name (ltype);\n \t\t\t    new_stmt = gimple_build_assign (tem, data_ref);\n-\t\t\t    vect_finish_stmt_generation (stmt_info, new_stmt, gsi);\n+\t\t\t    vect_finish_stmt_generation (stmt_info, new_stmt,\n+\t\t\t\t\t\t\t gsi);\n \t\t\t    data_ref = NULL;\n \t\t\t    vec<constructor_elt, va_gc> *v;\n \t\t\t    vec_alloc (v, 2);\n-\t\t\t    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, tem);\n-\t\t\t    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n-\t\t\t\t\t\t    build_zero_cst (ltype));\n+\t\t\t    if (memory_access_type == VMAT_CONTIGUOUS_REVERSE)\n+\t\t\t      {\n+\t\t\t\tCONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n+\t\t\t\t\t\t\tbuild_zero_cst (ltype));\n+\t\t\t\tCONSTRUCTOR_APPEND_ELT (v, NULL_TREE, tem);\n+\t\t\t      }\n+\t\t\t    else\n+\t\t\t      {\n+\t\t\t\tCONSTRUCTOR_APPEND_ELT (v, NULL_TREE, tem);\n+\t\t\t\tCONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n+\t\t\t\t\t\t\tbuild_zero_cst (ltype));\n+\t\t\t      }\n \t\t\t    gcc_assert (new_vtype != NULL_TREE);\n \t\t\t    if (new_vtype == vectype)\n \t\t\t      new_stmt = gimple_build_assign ("}]}