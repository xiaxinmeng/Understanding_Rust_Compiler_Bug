{"sha": "ab8843fac024b4f8e4147c084cb876649b2e66c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWI4ODQzZmFjMDI0YjRmOGU0MTQ3YzA4NGNiODc2NjQ5YjJlNjZjNQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2013-10-13T16:31:00Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-13T16:31:00Z"}, "message": "einfo.adb: Add node/list usage for Refined_State and Refinement_Constituents.\n\n2013-10-13  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* einfo.adb: Add node/list usage for Refined_State\n\tand Refinement_Constituents.\n\t(Get_Pragma): Update the\n\tinitialization of Is_CDG to include Refined_Global and\n\tRefined_Depends. Rename constant Delayed to In_Contract and update\n\tall of its occurrences.\n\t(Is_Non_Volatile_State): New routine.\n\t(Is_Volatile_State): Removed.\n\t(Refined_State): New routine.\n\t(Refinement_Constituents): New routine.\n\t(Set_Refined_State): New routine.\n\t(Set_Refinement_Constituents): New routine.\n\t(Write_Field8_Name): Add output for Refinement_Constituents.\n\t(Write_Field10_Name): Add output for Refined_State.\n\t* einfo.ads: Add new synthesized attribute Is_Non_Volatile_State.\n\tRemove synthesized attribute Is_Volatile_State.  Add new\n\tattributes Refined_State and Refinement_Constituents along with\n\tusage in nodes.\n\t(Get_Pragma): Update the comment on usage.\n\t(Is_Non_Volatile_State): New routine.\n\t(Is_Volatile_State): Removed.\n\t(Refined_State): New routine and pragma Inline.\n\t(Refinement_Constituents): New routine and pragma Inline.\n\t(Set_Refined_State): New routine and pragma Inline.\n\t(Set_Refinement_Constituents): New routine and pragma Inline.\n\t* elists.ads, elists.adb (Clone): Removed.\n\t(New_Copy_Elist): New routine.\n\t(Remove): New routine.\n\t* sem_ch3.adb (Analyze_Declarations): Use Defining_Entity\n\tto get the entity of the subprogram [body].\n\t(Analyze_Object_Declaration): Add initialization for\n\tRefined_State.\n\t* sem_ch6.adb (Analyze_Subprogram_Body_Contract): Add processing\n\tfor Refined_Global and Refined_Depends. Emit an error when\n\tthe body requires Refined_Global, but the aspect/pragma is\n\tnot present.\n\t* sem_ch6.ads (Analyze_Subprogram_Body_Contract): Change\n\tprocedure signature and add comment on usage.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Add processing\n\tfor aspect Refined_Global.\n\t* sem_prag.adb (Analyze_Abstract_State): Add initialization\n\tof attributes Refined_State and Refinement_Constituents.\n\t(Analyze_Depends_In_Decl_Part, Analyze_Global_In_Decl_Part,\n\tAnalyze_Contract_Cases_In_Decl_Part): Remove local\n\tconstant Arg1.\n\t(Analyze_Pragma): Add processing for pragma\n\tRefined_Global. The analysis of Refined_Post and Refined_Pre\n\thas been merged. Update an error message in the processing of\n\tpragma Refined_State.\n\t(Analyze_Refined_Global_In_Decl_Part): Provide implementation.\n\t(Analyze_Refined_Pragma): New routine.\n\t(Analyze_Refined_Pre_Post_Condition): Removed.\n\t(Analyze_Refined_State_In_Decl_Part): Update the call to Clone.\n\t(Analyze_Refinement_Clause): Make State_Id visible to all\n\tnested subprogram.\n\t(Check_Matching_Constituent): Establish\n\ta relation between a refined state and its constituent.\n\t(Collect_Hidden_States_In_Decls): Remove ??? comment. Look at\n\tthe entity of the object declaration to establish its kind.\n\t* sem_util.adb: Alphabetize with and use clauses.\n\t(Contains_Refined_State): New routine.\n\t* sem_util.ads (Contains_Refined_State): New routine.\n\nFrom-SVN: r203504", "tree": {"sha": "d2a660b065458b989b4a8888b359b237367e4a4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2a660b065458b989b4a8888b359b237367e4a4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab8843fac024b4f8e4147c084cb876649b2e66c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab8843fac024b4f8e4147c084cb876649b2e66c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab8843fac024b4f8e4147c084cb876649b2e66c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab8843fac024b4f8e4147c084cb876649b2e66c5/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ad0d71b531e7d06b96e1b3675ba99845f43f766d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad0d71b531e7d06b96e1b3675ba99845f43f766d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad0d71b531e7d06b96e1b3675ba99845f43f766d"}], "stats": {"total": 1532, "additions": 1390, "deletions": 142}, "files": [{"sha": "65093fa655c97574616b56585574d7b67d42279c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab8843fac024b4f8e4147c084cb876649b2e66c5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab8843fac024b4f8e4147c084cb876649b2e66c5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ab8843fac024b4f8e4147c084cb876649b2e66c5", "patch": "@@ -1,3 +1,68 @@\n+2013-10-13  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* einfo.adb: Add node/list usage for Refined_State\n+\tand Refinement_Constituents.\n+\t(Get_Pragma): Update the\n+\tinitialization of Is_CDG to include Refined_Global and\n+\tRefined_Depends. Rename constant Delayed to In_Contract and update\n+\tall of its occurrences.\n+\t(Is_Non_Volatile_State): New routine.\n+\t(Is_Volatile_State): Removed.\n+\t(Refined_State): New routine.\n+\t(Refinement_Constituents): New routine.\n+\t(Set_Refined_State): New routine.\n+\t(Set_Refinement_Constituents): New routine.\n+\t(Write_Field8_Name): Add output for Refinement_Constituents.\n+\t(Write_Field10_Name): Add output for Refined_State.\n+\t* einfo.ads: Add new synthesized attribute Is_Non_Volatile_State.\n+\tRemove synthesized attribute Is_Volatile_State.  Add new\n+\tattributes Refined_State and Refinement_Constituents along with\n+\tusage in nodes.\n+\t(Get_Pragma): Update the comment on usage.\n+\t(Is_Non_Volatile_State): New routine.\n+\t(Is_Volatile_State): Removed.\n+\t(Refined_State): New routine and pragma Inline.\n+\t(Refinement_Constituents): New routine and pragma Inline.\n+\t(Set_Refined_State): New routine and pragma Inline.\n+\t(Set_Refinement_Constituents): New routine and pragma Inline.\n+\t* elists.ads, elists.adb (Clone): Removed.\n+\t(New_Copy_Elist): New routine.\n+\t(Remove): New routine.\n+\t* sem_ch3.adb (Analyze_Declarations): Use Defining_Entity\n+\tto get the entity of the subprogram [body].\n+\t(Analyze_Object_Declaration): Add initialization for\n+\tRefined_State.\n+\t* sem_ch6.adb (Analyze_Subprogram_Body_Contract): Add processing\n+\tfor Refined_Global and Refined_Depends. Emit an error when\n+\tthe body requires Refined_Global, but the aspect/pragma is\n+\tnot present.\n+\t* sem_ch6.ads (Analyze_Subprogram_Body_Contract): Change\n+\tprocedure signature and add comment on usage.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Add processing\n+\tfor aspect Refined_Global.\n+\t* sem_prag.adb (Analyze_Abstract_State): Add initialization\n+\tof attributes Refined_State and Refinement_Constituents.\n+\t(Analyze_Depends_In_Decl_Part, Analyze_Global_In_Decl_Part,\n+\tAnalyze_Contract_Cases_In_Decl_Part): Remove local\n+\tconstant Arg1.\n+\t(Analyze_Pragma): Add processing for pragma\n+\tRefined_Global. The analysis of Refined_Post and Refined_Pre\n+\thas been merged. Update an error message in the processing of\n+\tpragma Refined_State.\n+\t(Analyze_Refined_Global_In_Decl_Part): Provide implementation.\n+\t(Analyze_Refined_Pragma): New routine.\n+\t(Analyze_Refined_Pre_Post_Condition): Removed.\n+\t(Analyze_Refined_State_In_Decl_Part): Update the call to Clone.\n+\t(Analyze_Refinement_Clause): Make State_Id visible to all\n+\tnested subprogram.\n+\t(Check_Matching_Constituent): Establish\n+\ta relation between a refined state and its constituent.\n+\t(Collect_Hidden_States_In_Decls): Remove ??? comment. Look at\n+\tthe entity of the object declaration to establish its kind.\n+\t* sem_util.adb: Alphabetize with and use clauses.\n+\t(Contains_Refined_State): New routine.\n+\t* sem_util.ads (Contains_Refined_State): New routine.\n+\n 2013-10-13  Thomas Quinot  <quinot@adacore.com>\n \n \t* scos.ads: Minor documentation clarification."}, {"sha": "e9c262afaac2d0b9c39dc9292f3c4e384a6fec7a", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 66, "deletions": 28, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab8843fac024b4f8e4147c084cb876649b2e66c5/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab8843fac024b4f8e4147c084cb876649b2e66c5/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=ab8843fac024b4f8e4147c084cb876649b2e66c5", "patch": "@@ -81,6 +81,7 @@ package body Einfo is\n    --    Normalized_First_Bit            Uint8\n    --    Postcondition_Proc              Node8\n    --    Refined_State_Pragma            Node8\n+   --    Refinement_Constituents         Elist8\n    --    Return_Applies_To               Node8\n    --    First_Exit_Statement            Node8\n \n@@ -93,6 +94,7 @@ package body Einfo is\n    --    Float_Rep                       Uint10 (but returns Float_Rep_Kind)\n    --    Handler_Records                 List10\n    --    Normalized_Position_Max         Uint10\n+   --    Refined_State                   Node10\n \n    --    Component_Bit_Offset            Uint11\n    --    Full_View                       Node11\n@@ -2648,12 +2650,24 @@ package body Einfo is\n       return Flag227 (Id);\n    end Referenced_As_Out_Parameter;\n \n+   function Refined_State (Id : E) return N is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Abstract_State, E_Variable));\n+      return Node10 (Id);\n+   end Refined_State;\n+\n    function Refined_State_Pragma (Id : E) return N is\n    begin\n       pragma Assert (Ekind (Id) = E_Package_Body);\n       return Node8 (Id);\n    end Refined_State_Pragma;\n \n+   function Refinement_Constituents (Id : E) return L is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Abstract_State);\n+      return Elist8 (Id);\n+   end Refinement_Constituents;\n+\n    function Register_Exception_Call (Id : E) return N is\n    begin\n       pragma Assert (Ekind (Id) = E_Exception);\n@@ -5308,12 +5322,24 @@ package body Einfo is\n       Set_Flag227 (Id, V);\n    end Set_Referenced_As_Out_Parameter;\n \n+   procedure Set_Refined_State (Id : E; V : E) is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Abstract_State, E_Variable));\n+      Set_Node10 (Id, V);\n+   end Set_Refined_State;\n+\n    procedure Set_Refined_State_Pragma (Id : E; V : N) is\n    begin\n       pragma Assert (Ekind (Id) = E_Package_Body);\n       Set_Node8 (Id, V);\n    end Set_Refined_State_Pragma;\n \n+   procedure Set_Refinement_Constituents (Id : E; V : L) is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Abstract_State);\n+      Set_Elist8 (Id, V);\n+   end Set_Refinement_Constituents;\n+\n    procedure Set_Register_Exception_Call (Id : E; V : N) is\n    begin\n       pragma Assert (Ekind (Id) = E_Exception);\n@@ -6266,21 +6292,26 @@ package body Einfo is\n    ----------------\n \n    function Get_Pragma (E : Entity_Id; Id : Pragma_Id) return Node_Id is\n-      Is_CDG  : constant Boolean :=\n-                  Id = Pragma_Depends or else Id = Pragma_Global;\n-      Is_CTC  : constant Boolean :=\n-                  Id = Pragma_Contract_Cases or else Id = Pragma_Test_Case;\n-      Is_PPC  : constant Boolean :=\n-                  Id = Pragma_Precondition or else Id = Pragma_Postcondition;\n-      Delayed : constant Boolean := Is_CDG or Is_CTC or Is_PPC;\n-      Item    : Node_Id;\n-      Items   : Node_Id;\n-\n-   begin\n-      --  Handle delayed pragmas that appear in N_Contract nodes. Those have to\n-      --  be extracted from their specialized list.\n-\n-      if Delayed then\n+      Is_CDG       : constant Boolean :=\n+                       Id = Pragma_Depends\n+                         or else Id = Pragma_Global\n+                         or else Id = Pragma_Refined_Depends\n+                         or else Id = Pragma_Refined_Global;\n+      Is_CTC      : constant Boolean :=\n+                      Id = Pragma_Contract_Cases or else Id = Pragma_Test_Case;\n+      Is_PPC      : constant Boolean :=\n+                      Id = Pragma_Precondition\n+                        or else Id = Pragma_Postcondition;\n+      In_Contract : constant Boolean := Is_CDG or Is_CTC or Is_PPC;\n+\n+      Item   : Node_Id;\n+      Items  : Node_Id;\n+\n+   begin\n+      --  Handle pragmas that appear in N_Contract nodes. Those have to be\n+      --  extracted from their specialized list.\n+\n+      if In_Contract then\n          Items := Contract (E);\n \n          if No (Items) then\n@@ -6310,7 +6341,7 @@ package body Einfo is\n \n          --  All nodes in N_Contract are chained using Next_Pragma\n \n-         elsif Delayed then\n+         elsif In_Contract then\n             Item := Next_Pragma (Item);\n \n          --  Regular pragmas\n@@ -6712,6 +6743,17 @@ package body Einfo is\n           and then Has_Option (Id, Name_Input_Only);\n    end Is_Input_Only_State;\n \n+   ---------------------------\n+   -- Is_Non_Volatile_State --\n+   ---------------------------\n+\n+   function Is_Non_Volatile_State (Id : E) return B is\n+   begin\n+      return\n+        Ekind (Id) = E_Abstract_State\n+          and then Has_Option (Id, Name_Non_Volatile);\n+   end Is_Non_Volatile_State;\n+\n    -------------------\n    -- Is_Null_State --\n    -------------------\n@@ -6872,17 +6914,6 @@ package body Einfo is\n           and then Is_Task_Type (Corresponding_Concurrent_Type (Id));\n    end Is_Task_Record_Type;\n \n-   -----------------------\n-   -- Is_Volatile_State --\n-   -----------------------\n-\n-   function Is_Volatile_State (Id : E) return B is\n-   begin\n-      return\n-        Ekind (Id) = E_Abstract_State\n-          and then Has_Option (Id, Name_Volatile);\n-   end Is_Volatile_State;\n-\n    ------------------------\n    -- Is_Wrapper_Package --\n    ------------------------\n@@ -8309,6 +8340,9 @@ package body Einfo is\n          when E_Package_Body                               =>\n             Write_Str (\"Refined_State_Pragma\");\n \n+         when E_Abstract_State                             =>\n+            Write_Str (\"Refinement_Constituents\");\n+\n          when E_Return_Statement                           =>\n             Write_Str (\"Return_Applies_To\");\n \n@@ -8358,7 +8392,7 @@ package body Einfo is\n               Concurrent_Kind                              =>\n             Write_Str (\"Direct_Primitive_Operations\");\n \n-         when Float_Kind                                 =>\n+         when Float_Kind                                   =>\n             Write_Str (\"Float_Rep\");\n \n          when E_In_Parameter                               |\n@@ -8375,6 +8409,10 @@ package body Einfo is\n               E_Discriminant                               =>\n             Write_Str (\"Normalized_Position_Max\");\n \n+         when E_Abstract_State                             |\n+              E_Variable                                   =>\n+            Write_Str (\"Refined_State\");\n+\n          when others                                       =>\n             Write_Str (\"Field10??\");\n       end case;"}, {"sha": "fce06897494de37b03fc457b9eff3ab973a57381", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 37, "deletions": 11, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab8843fac024b4f8e4147c084cb876649b2e66c5/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab8843fac024b4f8e4147c084cb876649b2e66c5/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=ab8843fac024b4f8e4147c084cb876649b2e66c5", "patch": "@@ -2576,6 +2576,10 @@ package Einfo is\n --       set right, at which point, these comments can be removed, and the\n --       tests for static subtypes greatly simplified.\n \n+--    Is_Non_Volatile_State (synthesized)\n+--       Applies to all entities, true for abstract states that are subject to\n+--       option Non_Volatile.\n+\n --    Is_Null_Init_Proc (Flag178)\n --       Defined in procedure entities. Set for generated init proc procedures\n --       (used to initialize composite types), if the code for the procedure\n@@ -2977,10 +2981,6 @@ package Einfo is\n --       optimizations on volatile objects should test Treat_As_Volatile\n --       rather than testing this flag.\n \n---    Is_Volatile_State (synthesized)\n---       Applies to all entities, true for abstract states that are subject to\n---       option Volatile.\n-\n --    Is_Wrapper_Package (synthesized)\n --       Defined in package entities. Indicates that the package has been\n --       created as a wrapper for a subprogram instantiation.\n@@ -3537,10 +3537,19 @@ package Einfo is\n --       we have a separate warning for variables that are only assigned and\n --       never read, and out parameters are a special case.\n \n+--    Refined_State (Node10)\n+--       Defined in abstract states and variables. Contains the entity of an\n+--       ancestor state whose refinement mentions this item.\n+\n --    Refined_State_Pragma (Node8)\n --       Defined in [generic] package bodies. Contains the pragma that refines\n --       all abstract states defined in the corresponding package declaration.\n \n+--    Refinement_Constituents (Elist8)\n+--       Present in abstract state entities. Contains all the constituents that\n+--       refine the state, in other words, all the hidden states that appear in\n+--       the constituent_list of aspect/pragma Refined_State.\n+\n --    Register_Exception_Call (Node20)\n --       Defined in exception entities. When an exception is declared,\n --       a call is expanded to Register_Exception. This field points to\n@@ -5096,11 +5105,13 @@ package Einfo is\n    ------------------------------------------\n \n    --  E_Abstract_State\n+   --    Refinement_Constituents             (Elist8)\n+   --    Refined_State                       (Node10)\n    --    Is_External_State                   (synth)\n    --    Is_Input_Only_State                 (synth)\n    --    Is_Null_State                       (synth)\n    --    Is_Output_Only_State                (synth)\n-   --    Is_Volatile_State                   (synth)\n+   --    Is_Non_Volatile_State               (synth)\n \n    --  E_Access_Protected_Subprogram_Type\n    --    Equivalent_Type                     (Node18)\n@@ -5913,6 +5924,7 @@ package Einfo is\n    --  E_Variable\n    --    Hiding_Loop_Variable                (Node8)\n    --    Current_Value                       (Node9)\n+   --    Refined_State                       (Node10)\n    --    Esize                               (Uint12)\n    --    Extra_Accessibility                 (Node13)\n    --    Alignment                           (Uint14)\n@@ -6540,7 +6552,9 @@ package Einfo is\n    function Referenced                          (Id : E) return B;\n    function Referenced_As_LHS                   (Id : E) return B;\n    function Referenced_As_Out_Parameter         (Id : E) return B;\n+   function Refined_State                       (Id : E) return E;\n    function Refined_State_Pragma                (Id : E) return E;\n+   function Refinement_Constituents             (Id : E) return L;\n    function Register_Exception_Call             (Id : E) return N;\n    function Related_Array_Object                (Id : E) return E;\n    function Related_Expression                  (Id : E) return N;\n@@ -6691,6 +6705,7 @@ package Einfo is\n    function Is_Ghost_Entity                     (Id : E) return B;\n    function Is_Ghost_Subprogram                 (Id : E) return B;\n    function Is_Input_Only_State                 (Id : E) return B;\n+   function Is_Non_Volatile_State               (Id : E) return B;\n    function Is_Null_State                       (Id : E) return B;\n    function Is_Output_Only_State                (Id : E) return B;\n    function Is_Package_Or_Generic_Package       (Id : E) return B;\n@@ -6703,7 +6718,6 @@ package Einfo is\n    function Is_Synchronized_Interface           (Id : E) return B;\n    function Is_Task_Interface                   (Id : E) return B;\n    function Is_Task_Record_Type                 (Id : E) return B;\n-   function Is_Volatile_State                   (Id : E) return B;\n    function Is_Wrapper_Package                  (Id : E) return B;\n    function Last_Formal                         (Id : E) return E;\n    function Machine_Emax_Value                  (Id : E) return U;\n@@ -7158,7 +7172,9 @@ package Einfo is\n    procedure Set_Referenced                      (Id : E; V : B := True);\n    procedure Set_Referenced_As_LHS               (Id : E; V : B := True);\n    procedure Set_Referenced_As_Out_Parameter     (Id : E; V : B := True);\n+   procedure Set_Refined_State                   (Id : E; V : E);\n    procedure Set_Refined_State_Pragma            (Id : E; V : N);\n+   procedure Set_Refinement_Constituents         (Id : E; V : L);\n    procedure Set_Register_Exception_Call         (Id : E; V : N);\n    procedure Set_Related_Array_Object            (Id : E; V : E);\n    procedure Set_Related_Expression              (Id : E; V : N);\n@@ -7403,11 +7419,17 @@ package Einfo is\n    --  Empty is returned.\n \n    function Get_Pragma (E : Entity_Id; Id : Pragma_Id) return Node_Id;\n-   --  Searches the Rep_Item chain for a given entity E, for an instance of\n-   --  a pragma with the given pragma Id. If found, the value returned is the\n-   --  N_Pragma node, otherwise Empty is returned. Delayed pragmas such as\n-   --  Precondition, Postcondition, Contract_Cases, Depends and Global appear\n-   --  in the N_Contract node of entity E and are also handled by this routine.\n+   --  Searches the Rep_Item chain of entity E, for an instance of a pragma\n+   --  with the given pragma Id. If found, the value returned is the N_Pragma\n+   --  node, otherwise Empty is returned. The following contract pragmas that\n+   --  appear in N_Contract nodes are also handled by this routine:\n+   --    Contract_Cases\n+   --    Depends\n+   --    Global\n+   --    Precondition\n+   --    Postcondition\n+   --    Refined_Depends\n+   --    Refined_Global\n \n    function Get_Record_Representation_Clause (E : Entity_Id) return Node_Id;\n    --  Searches the Rep_Item chain for a given entity E, for a record\n@@ -7908,7 +7930,9 @@ package Einfo is\n    pragma Inline (Referenced);\n    pragma Inline (Referenced_As_LHS);\n    pragma Inline (Referenced_As_Out_Parameter);\n+   pragma Inline (Refined_State);\n    pragma Inline (Refined_State_Pragma);\n+   pragma Inline (Refinement_Constituents);\n    pragma Inline (Register_Exception_Call);\n    pragma Inline (Related_Array_Object);\n    pragma Inline (Related_Expression);\n@@ -8324,7 +8348,9 @@ package Einfo is\n    pragma Inline (Set_Referenced);\n    pragma Inline (Set_Referenced_As_LHS);\n    pragma Inline (Set_Referenced_As_Out_Parameter);\n+   pragma Inline (Set_Refined_State);\n    pragma Inline (Set_Refined_State_Pragma);\n+   pragma Inline (Set_Refinement_Constituents);\n    pragma Inline (Set_Register_Exception_Call);\n    pragma Inline (Set_Related_Array_Object);\n    pragma Inline (Set_Related_Expression);"}, {"sha": "7e62ce49f690d64a7edc748c0d10a9cdbe794ce9", "filename": "gcc/ada/elists.adb", "status": "modified", "additions": 49, "deletions": 28, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab8843fac024b4f8e4147c084cb876649b2e66c5/gcc%2Fada%2Felists.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab8843fac024b4f8e4147c084cb876649b2e66c5/gcc%2Fada%2Felists.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Felists.adb?ref=ab8843fac024b4f8e4147c084cb876649b2e66c5", "patch": "@@ -158,34 +158,6 @@ package body Elists is\n       end loop;\n    end Append_Unique_Elmt;\n \n-   -----------\n-   -- Clone --\n-   ------------\n-\n-   function Clone (List : Elist_Id) return Elist_Id is\n-      Result : Elist_Id;\n-      Elmt   : Elmt_Id;\n-\n-   begin\n-      if List = No_Elist then\n-         return No_Elist;\n-\n-      --  Replicate the contents of the input list while preserving the\n-      --  original order.\n-\n-      else\n-         Result := New_Elmt_List;\n-\n-         Elmt := First_Elmt (List);\n-         while Present (Elmt) loop\n-            Append_Elmt (Node (Elmt), Result);\n-            Next_Elmt (Elmt);\n-         end loop;\n-\n-         return Result;\n-      end if;\n-   end Clone;\n-\n    --------------\n    -- Contains --\n    --------------\n@@ -315,6 +287,34 @@ package body Elists is\n       Elmts.Release;\n    end Lock;\n \n+   --------------------\n+   -- New_Copy_Elist --\n+   --------------------\n+\n+   function New_Copy_Elist (List : Elist_Id) return Elist_Id is\n+      Result : Elist_Id;\n+      Elmt   : Elmt_Id;\n+\n+   begin\n+      if List = No_Elist then\n+         return No_Elist;\n+\n+      --  Replicate the contents of the input list while preserving the\n+      --  original order.\n+\n+      else\n+         Result := New_Elmt_List;\n+\n+         Elmt := First_Elmt (List);\n+         while Present (Elmt) loop\n+            Append_Elmt (Node (Elmt), Result);\n+            Next_Elmt (Elmt);\n+         end loop;\n+\n+         return Result;\n+      end if;\n+   end New_Copy_Elist;\n+\n    -------------------\n    -- New_Elmt_List --\n    -------------------\n@@ -425,6 +425,27 @@ package body Elists is\n       return Elmt /= No_Elmt;\n    end Present;\n \n+   ------------\n+   -- Remove --\n+   ------------\n+\n+   procedure Remove (List : Elist_Id; N : Node_Or_Entity_Id) is\n+      Elmt : Elmt_Id;\n+\n+   begin\n+      if Present (List) then\n+         Elmt := First_Elmt (List);\n+         while Present (Elmt) loop\n+            if Node (Elmt) = N then\n+               Remove_Elmt (List, Elmt);\n+               exit;\n+            end if;\n+\n+            Next_Elmt (Elmt);\n+         end loop;\n+      end if;\n+   end Remove;\n+\n    -----------------\n    -- Remove_Elmt --\n    -----------------"}, {"sha": "f0331362ea3b288582aa3ec3154651e9d23a2221", "filename": "gcc/ada/elists.ads", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab8843fac024b4f8e4147c084cb876649b2e66c5/gcc%2Fada%2Felists.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab8843fac024b4f8e4147c084cb876649b2e66c5/gcc%2Fada%2Felists.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Felists.ads?ref=ab8843fac024b4f8e4147c084cb876649b2e66c5", "patch": "@@ -137,12 +137,20 @@ package Elists is\n    --  Add a new element (N) right after the pre-existing element Elmt\n    --  It is invalid to call this subprogram with Elmt = No_Elmt.\n \n+   function New_Copy_Elist (List : Elist_Id) return Elist_Id;\n+   --  Replicate the contents of a list. Internal list nodes are not shared and\n+   --  order of elements is preserved.\n+\n    procedure Replace_Elmt (Elmt : Elmt_Id; New_Node : Node_Or_Entity_Id);\n    pragma Inline (Replace_Elmt);\n    --  Causes the given element of the list to refer to New_Node, the node\n    --  which was previously referred to by Elmt is effectively removed from\n    --  the list and replaced by New_Node.\n \n+   procedure Remove (List : Elist_Id; N : Node_Or_Entity_Id);\n+   --  Remove a node or an entity from a list. If the list does not contain the\n+   --  item in question, the routine has no effect.\n+\n    procedure Remove_Elmt (List : Elist_Id; Elmt : Elmt_Id);\n    --  Removes Elmt from the given list. The node itself is not affected,\n    --  but the space used by the list element may be (but is not required\n@@ -153,10 +161,6 @@ package Elists is\n    --  affected, but the space used by the list element may be (but is not\n    --  required to be) freed for reuse in a subsequent Append_Elmt call.\n \n-   function Clone (List : Elist_Id) return Elist_Id;\n-   --  Create a copy of the input list. Internal list nodes are not shared and\n-   --  order of elements is preserved.\n-\n    function Contains (List : Elist_Id; N : Node_Or_Entity_Id) return Boolean;\n    --  Perform a sequential search to determine whether the given list contains\n    --  a node or an entity."}, {"sha": "71cc77e60c122df0ecbaa2aaea2104eb0d8e9ed8", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab8843fac024b4f8e4147c084cb876649b2e66c5/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab8843fac024b4f8e4147c084cb876649b2e66c5/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=ab8843fac024b4f8e4147c084cb876649b2e66c5", "patch": "@@ -1977,10 +1977,21 @@ package body Sem_Ch13 is\n \n                --  Refined_Global\n \n-               --  ??? To be implemented\n+               --  Aspect Refined_Global must be delayed because it can mention\n+               --  state refinements introduced by aspect Refined_State. Since\n+               --  Refined_State is already delayed due to forward references,\n+               --  so is Refined_Global.\n \n                when Aspect_Refined_Global =>\n-                  null;\n+                  Make_Aitem_Pragma\n+                    (Pragma_Argument_Associations => New_List (\n+                       Make_Pragma_Argument_Association (Loc,\n+                         Expression => Relocate_Node (Expr))),\n+                     Pragma_Name                  => Name_Refined_Global);\n+\n+                  Decorate_Delayed_Aspect_And_Pragma (Aspect, Aitem);\n+                  Insert_Delayed_Pragma (Aitem);\n+                  goto Continue;\n \n                --  Refined_Post\n "}, {"sha": "85872e10803a813d10f0234e81096b34081af083", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab8843fac024b4f8e4147c084cb876649b2e66c5/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab8843fac024b4f8e4147c084cb876649b2e66c5/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=ab8843fac024b4f8e4147c084cb876649b2e66c5", "patch": "@@ -2233,12 +2233,10 @@ package body Sem_Ch3 is\n       Decl := First (L);\n       while Present (Decl) loop\n          if Nkind (Decl) = N_Subprogram_Body then\n-            Analyze_Subprogram_Body_Contract\n-              (Defining_Unit_Name (Specification (Decl)));\n+            Analyze_Subprogram_Body_Contract (Defining_Entity (Decl));\n \n          elsif Nkind (Decl) = N_Subprogram_Declaration then\n-            Analyze_Subprogram_Contract\n-              (Defining_Unit_Name (Specification (Decl)));\n+            Analyze_Subprogram_Contract (Defining_Entity (Decl));\n          end if;\n \n          Next (Decl);\n@@ -3540,7 +3538,7 @@ package body Sem_Ch3 is\n \n       if Constant_Present (N) then\n          Set_Ekind            (Id, E_Constant);\n-         Set_Is_True_Constant (Id, True);\n+         Set_Is_True_Constant (Id);\n \n       else\n          Set_Ekind (Id, E_Variable);\n@@ -3763,6 +3761,13 @@ package body Sem_Ch3 is\n       end if;\n \n    <<Leave>>\n+      --  Initialize the refined state of a variable here because this is a\n+      --  common destination for legal and illegal object declarations.\n+\n+      if Ekind (Id) = E_Variable then\n+         Set_Refined_State (Id, Empty);\n+      end if;\n+\n       if Has_Aspects (N) then\n          Analyze_Aspect_Specifications (N, Id);\n       end if;"}, {"sha": "aee35fbda3ac87fcc1c37ce4c42e53b142136264", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 39, "deletions": 4, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab8843fac024b4f8e4147c084cb876649b2e66c5/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab8843fac024b4f8e4147c084cb876649b2e66c5/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=ab8843fac024b4f8e4147c084cb876649b2e66c5", "patch": "@@ -1975,12 +1975,47 @@ package body Sem_Ch6 is\n    -- Analyze_Subprogram_Body_Contract --\n    --------------------------------------\n \n-   --  ??? To be implemented\n+   procedure Analyze_Subprogram_Body_Contract (Body_Id : Entity_Id) is\n+      Body_Decl : constant Node_Id   := Parent (Parent (Body_Id));\n+      Spec_Id   : constant Entity_Id := Corresponding_Spec (Body_Decl);\n+      Prag      : Node_Id;\n+\n+      Has_Refined_Global : Boolean := False;\n \n-   procedure Analyze_Subprogram_Body_Contract (Subp : Entity_Id) is\n-      pragma Unreferenced (Subp);\n    begin\n-      null;\n+      --  When a subprogram body declaration is erroneous, its defining entity\n+      --  is left unanalyzed. There is nothing left to do in this case because\n+      --  the body lacks a contract.\n+\n+      if not Analyzed (Body_Id) then\n+         return;\n+      end if;\n+\n+      Prag := Classifications (Contract (Body_Id));\n+      while Present (Prag) loop\n+         if Pragma_Name (Prag) = Name_Refined_Depends then\n+            Analyze_Refined_Depends_In_Decl_Part (Prag);\n+\n+         elsif Pragma_Name (Prag) = Name_Refined_Global then\n+            Has_Refined_Global := True;\n+            Analyze_Refined_Global_In_Decl_Part (Prag);\n+         end if;\n+\n+         Prag := Next_Pragma (Prag);\n+      end loop;\n+\n+      --  When the corresponding Global aspect/pragma references a state with\n+      --  visible refinement, the body requires Refined_Global.\n+\n+      if not Has_Refined_Global and then Present (Spec_Id) then\n+         Prag := Get_Pragma (Spec_Id, Pragma_Global);\n+\n+         if Present (Prag) and then Contains_Refined_State (Prag) then\n+            Error_Msg_NE\n+              (\"body of subprogram & requires global refinement\",\n+               Body_Decl, Spec_Id);\n+         end if;\n+      end if;\n    end Analyze_Subprogram_Body_Contract;\n \n    ------------------------------------"}, {"sha": "fc0c365e06b51fd9f7363b5aa7c3b1c83b3cf3fc", "filename": "gcc/ada/sem_ch6.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab8843fac024b4f8e4147c084cb876649b2e66c5/gcc%2Fada%2Fsem_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab8843fac024b4f8e4147c084cb876649b2e66c5/gcc%2Fada%2Fsem_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.ads?ref=ab8843fac024b4f8e4147c084cb876649b2e66c5", "patch": "@@ -46,10 +46,10 @@ package Sem_Ch6 is\n    procedure Analyze_Subprogram_Declaration          (N : Node_Id);\n    procedure Analyze_Subprogram_Body                 (N : Node_Id);\n \n-   procedure Analyze_Subprogram_Body_Contract (Subp : Entity_Id);\n+   procedure Analyze_Subprogram_Body_Contract (Body_Id : Entity_Id);\n    --  Analyze all delayed aspects chained on the contract of subprogram body\n-   --  Subp as if they appeared at the end of a declarative region. The aspects\n-   --  in question are:\n+   --  Body_Id as if they appeared at the end of a declarative region. The\n+   --  aspects in question are:\n    --    Refined_Depends\n    --    Refined_Global\n "}, {"sha": "4ef1867c11202592d11690587cc52904cfb8215a", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 971, "deletions": 56, "changes": 1027, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab8843fac024b4f8e4147c084cb876649b2e66c5/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab8843fac024b4f8e4147c084cb876649b2e66c5/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=ab8843fac024b4f8e4147c084cb876649b2e66c5", "patch": "@@ -401,7 +401,6 @@ package body Sem_Prag is\n \n       --  Local variables\n \n-      Arg1      : constant Node_Id := First (Pragma_Argument_Associations (N));\n       All_Cases : Node_Id;\n       CCase     : Node_Id;\n       Subp_Decl : Node_Id;\n@@ -417,7 +416,7 @@ package body Sem_Prag is\n \n       Subp_Decl := Find_Related_Subprogram (N);\n       Subp_Id   := Defining_Unit_Name (Specification (Subp_Decl));\n-      All_Cases := Expression (Arg1);\n+      All_Cases := Expression (First (Pragma_Argument_Associations (N)));\n \n       --  Multiple contract cases appear in aggregate form\n \n@@ -460,8 +459,7 @@ package body Sem_Prag is\n    ----------------------------------\n \n    procedure Analyze_Depends_In_Decl_Part (N : Node_Id) is\n-      Arg1 : constant Node_Id    := First (Pragma_Argument_Associations (N));\n-      Loc  : constant Source_Ptr := Sloc (N);\n+      Loc : constant Source_Ptr := Sloc (N);\n \n       All_Inputs_Seen : Elist_Id := No_Elist;\n       --  A list containing the entities of all the inputs processed so far.\n@@ -1248,7 +1246,7 @@ package body Sem_Prag is\n \n       Subp_Decl := Find_Related_Subprogram (N);\n       Subp_Id   := Defining_Unit_Name (Specification (Subp_Decl));\n-      Clause    := Expression (Arg1);\n+      Clause    := Expression (First (Pragma_Argument_Associations (N)));\n \n       --  Empty dependency list\n \n@@ -1348,8 +1346,6 @@ package body Sem_Prag is\n    ---------------------------------\n \n    procedure Analyze_Global_In_Decl_Part (N : Node_Id) is\n-      Arg1 : constant Node_Id := First (Pragma_Argument_Associations (N));\n-\n       Seen : Elist_Id := No_Elist;\n       --  A list containing the entities of all the items processed so far. It\n       --  plays a role in detecting distinct entities.\n@@ -1680,7 +1676,7 @@ package body Sem_Prag is\n                   Next (Assoc);\n                end loop;\n \n-            --  Something went horribly wrong, we have a malformed tree\n+            --  Invalid tree\n \n             else\n                raise Program_Error;\n@@ -1708,7 +1704,7 @@ package body Sem_Prag is\n \n       Subp_Decl := Find_Related_Subprogram (N);\n       Subp_Id   := Defining_Unit_Name (Specification (Subp_Decl));\n-      List      := Expression (Arg1);\n+      List      := Expression (First (Pragma_Argument_Associations (N)));\n \n       --  There is nothing to be done for a null global list\n \n@@ -1781,9 +1777,15 @@ package body Sem_Prag is\n       --  In Ada 95 or 05 mode, these are implementation defined pragmas, so\n       --  should be caught by the No_Implementation_Pragmas restriction.\n \n-      procedure Analyze_Refined_Pre_Post_Condition;\n-      --  Subsidiary routine to the analysis of pragmas Refined_Pre and\n-      --  Refined_Post.\n+      procedure Analyze_Refined_Pragma\n+        (Spec_Id : out Entity_Id;\n+         Body_Id : out Entity_Id;\n+         Legal   : out Boolean);\n+      --  Subsidiary routine to the analysis of body pragmas Refined_Depends,\n+      --  Refined_Global, Refined_Post and Refined_Pre. Check the placement and\n+      --  related context of the pragma. Spec_Id is the entity of the related\n+      --  subprogram. Body_Id is the entity of the subprogram body. Flag Legal\n+      --  is set when the pragma is properly placed.\n \n       procedure Check_Ada_83_Warning;\n       --  Issues a warning message for the current pragma if operating in Ada\n@@ -2311,18 +2313,27 @@ package body Sem_Prag is\n          end if;\n       end Ada_2012_Pragma;\n \n-      ----------------------------------------\n-      -- Analyze_Refined_Pre_Post_Condition --\n-      ----------------------------------------\n+      ----------------------------\n+      -- Analyze_Refined_Pragma --\n+      ----------------------------\n \n-      procedure Analyze_Refined_Pre_Post_Condition is\n+      procedure Analyze_Refined_Pragma\n+        (Spec_Id : out Entity_Id;\n+         Body_Id : out Entity_Id;\n+         Legal   : out Boolean)\n+      is\n          Body_Decl : Node_Id := Parent (N);\n          Pack_Spec : Node_Id;\n          Spec_Decl : Node_Id;\n-         Spec_Id   : Entity_Id;\n          Stmt      : Node_Id;\n \n       begin\n+         --  Assume that the pragma is illegal\n+\n+         Spec_Id := Empty;\n+         Body_Id := Empty;\n+         Legal   := False;\n+\n          GNAT_Pragma;\n          Check_Arg_Count (1);\n          Check_No_Identifiers;\n@@ -2385,6 +2396,8 @@ package body Sem_Prag is\n             return;\n          end if;\n \n+         Body_Id := Defining_Entity (Body_Decl);\n+\n          --  The body [stub] must not act as a spec, in other words it has to\n          --  be paired with a corresponding spec.\n \n@@ -2421,10 +2434,10 @@ package body Sem_Prag is\n             return;\n          end if;\n \n-         --  Analyze the boolean expression as a \"spec expression\"\n+         --  If we get here, then the pragma is legal\n \n-         Analyze_Pre_Post_Condition_In_Decl_Part (N, Spec_Id);\n-      end Analyze_Refined_Pre_Post_Condition;\n+         Legal := True;\n+      end Analyze_Refined_Pragma;\n \n       --------------------------\n       -- Check_Ada_83_Warning --\n@@ -8492,10 +8505,12 @@ package body Sem_Prag is\n                --  from the original state declaration. Decorate the entity.\n \n                Id := Make_Defining_Identifier (Loc, New_External_Name (Name));\n-               Set_Comes_From_Source (Id, not Is_Null);\n-               Set_Parent            (Id, State);\n-               Set_Ekind             (Id, E_Abstract_State);\n-               Set_Etype             (Id, Standard_Void_Type);\n+               Set_Comes_From_Source       (Id, not Is_Null);\n+               Set_Parent                  (Id, State);\n+               Set_Ekind                   (Id, E_Abstract_State);\n+               Set_Etype                   (Id, Standard_Void_Type);\n+               Set_Refined_State           (Id, Empty);\n+               Set_Refinement_Constituents (Id, New_Elmt_List);\n \n                --  Every non-null state must be nameable and resolvable the\n                --  same way a constant is.\n@@ -11873,7 +11888,7 @@ package body Sem_Prag is\n          -- Global --\n          ------------\n \n-         --  pragma Global (GLOBAL_SPECIFICATION)\n+         --  pragma Global (GLOBAL_SPECIFICATION);\n \n          --  GLOBAL_SPECIFICATION ::=\n          --    null\n@@ -15939,31 +15954,59 @@ package body Sem_Prag is\n          -- Refined_Global --\n          --------------------\n \n-         --  ??? To be implemented\n+         --  pragma Refined_Global (GLOBAL_SPECIFICATION);\n+\n+         --  GLOBAL_SPECIFICATION ::=\n+         --    null\n+         --  | GLOBAL_LIST\n+         --  | MODED_GLOBAL_LIST {, MODED_GLOBAL_LIST}\n \n-         --  Would be better if these generated an error message saying that\n-         --  the feature was not yet implemented ???\n+         --  MODED_GLOBAL_LIST ::= MODE_SELECTOR => GLOBAL_LIST\n \n-         when Pragma_Refined_Global =>\n-            null;\n+         --  MODE_SELECTOR ::= Input | Output | In_Out | Contract_In\n+         --  GLOBAL_LIST   ::= GLOBAL_ITEM | (GLOBAL_ITEM {, GLOBAL_ITEM})\n+         --  GLOBAL_ITEM   ::= NAME\n \n-         ------------------\n-         -- Refined_Post --\n-         ------------------\n+         when Pragma_Refined_Global => Refined_Global : declare\n+            Body_Id : Entity_Id;\n+            Legal   : Boolean;\n+            Spec_Id : Entity_Id;\n+\n+         begin\n+            Analyze_Refined_Pragma (Spec_Id, Body_Id, Legal);\n+\n+            --  Save the pragma in the contract of the subprogram body. The\n+            --  remaining analysis is performed at the end of the enclosing\n+            --  declarations.\n+\n+            if Legal then\n+               Add_Contract_Item (N, Body_Id);\n+            end if;\n+         end Refined_Global;\n+\n+         ------------------------------\n+         -- Refined_Post/Refined_Pre --\n+         ------------------------------\n \n          --  pragma Refined_Post (boolean_EXPRESSION);\n+         --  pragma Refined_Pre  (boolean_EXPRESSION);\n \n-         when Pragma_Refined_Post =>\n-            Analyze_Refined_Pre_Post_Condition;\n+         when Pragma_Refined_Post |\n+              Pragma_Refined_Pre  => Refined_Pre_Post :\n+         declare\n+            Body_Id : Entity_Id;\n+            Legal   : Boolean;\n+            Spec_Id : Entity_Id;\n \n-         -----------------\n-         -- Refined_Pre --\n-         -----------------\n+         begin\n+            Analyze_Refined_Pragma (Spec_Id, Body_Id, Legal);\n \n-         --  pragma Refined_Pre (boolean_EXPRESSION);\n+            --  Analyze the boolean expression as a \"spec expression\"\n \n-         when Pragma_Refined_Pre =>\n-            Analyze_Refined_Pre_Post_Condition;\n+            if Legal then\n+               Analyze_Pre_Post_Condition_In_Decl_Part (N, Spec_Id);\n+            end if;\n+         end Refined_Pre_Post;\n \n          -------------------\n          -- Refined_State --\n@@ -16009,8 +16052,9 @@ package body Sem_Prag is\n             if No (Abstract_States (Spec_Id))\n               or else Has_Null_Abstract_State (Spec_Id)\n             then\n-               Error_Pragma\n-                 (\"useless pragma %, package does not define abstract states\");\n+               Error_Msg_NE\n+                 (\"useless refinement, package & does not define abstract \"\n+                  & \"states\", N, Spec_Id);\n                return;\n             end if;\n \n@@ -18534,12 +18578,874 @@ package body Sem_Prag is\n    -- Analyze_Refined_Global_In_Decl_Part --\n    -----------------------------------------\n \n-   --  ??? To be implemented\n-\n    procedure Analyze_Refined_Global_In_Decl_Part (N : Node_Id) is\n-      pragma Unreferenced (N);\n+      Global : Node_Id;\n+      --  The corresponding Global aspect/pragma\n+\n+      Has_In_State     : Boolean := False;\n+      Has_In_Out_State : Boolean := False;\n+      Has_Out_State    : Boolean := False;\n+      --  These flags are set when the corresponding Global aspect/pragma has\n+      --  a state of mode Input, In_Out and Output respectively with a visible\n+      --  refinement.\n+\n+      In_Constits     : Elist_Id := No_Elist;\n+      In_Out_Constits : Elist_Id := No_Elist;\n+      Out_Constits    : Elist_Id := No_Elist;\n+      --  These lists contain the entities of all Input, In_Out and Output\n+      --  constituents that appear in Refined_Global and participate in state\n+      --  refinement.\n+\n+      In_Items     : Elist_Id := No_Elist;\n+      In_Out_Items : Elist_Id := No_Elist;\n+      Out_Items    : Elist_Id := No_Elist;\n+      --  These list contain the entities of all Input, In_Out and Output items\n+      --  defined in the corresponding Global aspect.\n+\n+      procedure Check_In_Out_States;\n+      --  Determine whether the corresponding Global aspect/pragma mentions\n+      --  In_Out states with visible refinement and if so, ensure that one of\n+      --  the following completions apply to the constituents of the state:\n+      --    1) there is at least one constituent of mode In_Out\n+      --    2) there is at least one Input and one Output constituent\n+      --    3) not all constituents are present and one of them is of mode\n+      --       Output.\n+      --  This routine may remove elements from In_Constits, In_Out_Constits\n+      --  and Out_Constits.\n+\n+      procedure Check_Input_States;\n+      --  Determine whether the corresponding Global aspect/pragma mentions\n+      --  Input states with visible refinement and if so, ensure that at least\n+      --  one of its constituents appears as an Input item in Refined_Global.\n+      --  This routine may remove elements from In_Constits, In_Out_Constits\n+      --  and Out_Constits.\n+\n+      procedure Check_Output_States;\n+      --  Determine whether the corresponding Global aspect/pragma mentions\n+      --  Output states with visible refinement and if so, ensure that all of\n+      --  its constituents appear as Output items in Refined_Global. This\n+      --  routine may remove elements from In_Constits, In_Out_Constits and\n+      --  Out_Constits.\n+\n+      procedure Check_Refined_Global_List\n+        (List        : Node_Id;\n+         Global_Mode : Name_Id := Name_Input);\n+      --  Verify the legality of a single global list declaration. Global_Mode\n+      --  denotes the current mode in effect.\n+\n+      procedure Collect_Global_Items (Prag : Node_Id);\n+      --  Collect the entities of all items of pragma Prag by populating lists\n+      --  In_Items, In_Out_Items and Out_Items. The routine also sets flags\n+      --  Has_In_State, Has_In_Out_State and Has_Out_State if there is a state\n+      --  of a particular kind with visible refinement.\n+\n+      function Present_Then_Remove\n+        (List : Elist_Id;\n+         Item : Entity_Id) return Boolean;\n+      --  Search List for a particular entity Item. If Item has been found,\n+      --  remove it from List. This routine is used to strip lists In_Constits,\n+      --  In_Out_Constits and Out_Constits of valid constituents.\n+\n+      procedure Report_Extra_Constituents;\n+      --  Emit an error for each constituent found in lists In_Constits,\n+      --  In_Out_Constits and Out_Constits.\n+\n+      -------------------------\n+      -- Check_In_Out_States --\n+      -------------------------\n+\n+      procedure Check_In_Out_States is\n+         procedure Check_Constituent_Usage (State_Id : Entity_Id);\n+         --  Determine whether one of the following coverage scenarios is in\n+         --  effect:\n+         --    1) there is at least one constituent of mode In_Out\n+         --    2) there is at least one Input and one Output constituent\n+         --    3) not all constituents are present and one of them is of mode\n+         --       Output.\n+         --  If this is not the case, emit an error.\n+\n+         -----------------------------\n+         -- Check_Constituent_Usage --\n+         -----------------------------\n+\n+         procedure Check_Constituent_Usage (State_Id : Entity_Id) is\n+            Constit_Elmt : Elmt_Id;\n+            Constit_Id   : Entity_Id;\n+            Has_Missing  : Boolean := False;\n+            In_Out_Seen  : Boolean := False;\n+            In_Seen      : Boolean := False;\n+            Out_Seen     : Boolean := False;\n+\n+         begin\n+            --  Process all the constituents of the state and note their modes\n+            --  within the global refinement.\n+\n+            Constit_Elmt := First_Elmt (Refinement_Constituents (State_Id));\n+            while Present (Constit_Elmt) loop\n+               Constit_Id := Node (Constit_Elmt);\n+\n+               if Present_Then_Remove (In_Constits, Constit_Id) then\n+                  In_Seen := True;\n+\n+               elsif Present_Then_Remove (In_Out_Constits, Constit_Id) then\n+                  In_Out_Seen := True;\n+\n+               elsif Present_Then_Remove (Out_Constits, Constit_Id) then\n+                  Out_Seen := True;\n+\n+               else\n+                  Has_Missing := True;\n+               end if;\n+\n+               Next_Elmt (Constit_Elmt);\n+            end loop;\n+\n+            --  A single In_Out constituent is a valid completion\n+\n+            if In_Out_Seen then\n+               null;\n+\n+            --  A pair of one Input and one Output constituent is a valid\n+            --  completion.\n+\n+            elsif In_Seen and then Out_Seen then\n+               null;\n+\n+            --  A single Output constituent is a valid completion only when\n+            --  some of the other constituents are missing.\n+\n+            elsif Has_Missing and then Out_Seen then\n+               null;\n+\n+            else\n+               Error_Msg_NE\n+                 (\"global refinement of state & redefines the mode of its \"\n+                  & \"constituents\", N, State_Id);\n+            end if;\n+         end Check_Constituent_Usage;\n+\n+         --  Local variables\n+\n+         Item_Elmt : Elmt_Id;\n+         Item_Id   : Entity_Id;\n+\n+      --  Start of processing for Check_In_Out_States\n+\n+      begin\n+         --  Inspect the In_Out items of the corresponding Global aspect/pragma\n+         --  looking for a state with a visible refinement.\n+\n+         if Has_In_Out_State and then Present (In_Out_Items) then\n+            Item_Elmt := First_Elmt (In_Out_Items);\n+            while Present (Item_Elmt) loop\n+               Item_Id := Node (Item_Elmt);\n+\n+               --  Ensure that one of the three coverage variants is satisfied\n+\n+               if Ekind (Item_Id) = E_Abstract_State\n+                 and then Present (Refinement_Constituents (Item_Id))\n+               then\n+                  Check_Constituent_Usage (Item_Id);\n+               end if;\n+\n+               Next_Elmt (Item_Elmt);\n+            end loop;\n+         end if;\n+      end Check_In_Out_States;\n+\n+      ------------------------\n+      -- Check_Input_States --\n+      ------------------------\n+\n+      procedure Check_Input_States is\n+         procedure Check_Constituent_Usage (State_Id : Entity_Id);\n+         --  Determine whether at least one constituent of state State_Id with\n+         --  visible refinement is used and has mode Input. Ensure that the\n+         --  remaining constituents do not have In_Out or Output modes.\n+\n+         -----------------------------\n+         -- Check_Constituent_Usage --\n+         -----------------------------\n+\n+         procedure Check_Constituent_Usage (State_Id : Entity_Id) is\n+            Constit_Elmt : Elmt_Id;\n+            Constit_Id   : Entity_Id;\n+            In_Seen      : Boolean := False;\n+\n+         begin\n+            Constit_Elmt := First_Elmt (Refinement_Constituents (State_Id));\n+            while Present (Constit_Elmt) loop\n+               Constit_Id := Node (Constit_Elmt);\n+\n+               --  At least one of the constituents appears as an Input\n+\n+               if Present_Then_Remove (In_Constits, Constit_Id) then\n+                  In_Seen := True;\n+\n+               --  The constituent appears in the global refinement, but has\n+               --  mode In_Out or Output.\n+\n+               elsif Present_Then_Remove (In_Out_Constits, Constit_Id)\n+                 or else Present_Then_Remove (Out_Constits, Constit_Id)\n+               then\n+                  Error_Msg_Name_1 := Chars (State_Id);\n+                  Error_Msg_NE\n+                    (\"constituent & of state % must have mode Input in global \"\n+                     & \"refinement\", N, Constit_Id);\n+               end if;\n+\n+               Next_Elmt (Constit_Elmt);\n+            end loop;\n+\n+            --  Not one of the constituents appeared as Input\n+\n+            if not In_Seen then\n+               Error_Msg_NE\n+                 (\"global refinement of state & must include at least one \"\n+                  & \"constituent of mode Input\", N, State_Id);\n+            end if;\n+         end Check_Constituent_Usage;\n+\n+         --  Local variables\n+\n+         Item_Elmt : Elmt_Id;\n+         Item_Id   : Entity_Id;\n+\n+      --  Start of processing for Check_Input_States\n+\n+      begin\n+         --  Inspect the Input items of the corresponding Global aspect/pragma\n+         --  looking for a state with a visible refinement.\n+\n+         if Has_In_State and then Present (In_Items) then\n+            Item_Elmt := First_Elmt (In_Items);\n+            while Present (Item_Elmt) loop\n+               Item_Id := Node (Item_Elmt);\n+\n+               --  Ensure that at least one of the constituents is utilized and\n+               --  is of mode Input.\n+\n+               if Ekind (Item_Id) = E_Abstract_State\n+                 and then Present (Refinement_Constituents (Item_Id))\n+               then\n+                  Check_Constituent_Usage (Item_Id);\n+               end if;\n+\n+               Next_Elmt (Item_Elmt);\n+            end loop;\n+         end if;\n+      end Check_Input_States;\n+\n+      -------------------------\n+      -- Check_Output_States --\n+      -------------------------\n+\n+      procedure Check_Output_States is\n+         procedure Check_Constituent_Usage (State_Id : Entity_Id);\n+         --  Determine whether all constituents of state State_Id with visible\n+         --  refinement are used and have mode Output. Emit an error if this is\n+         --  not the case.\n+\n+         -----------------------------\n+         -- Check_Constituent_Usage --\n+         -----------------------------\n+\n+         procedure Check_Constituent_Usage (State_Id : Entity_Id) is\n+            Constit_Elmt : Elmt_Id;\n+            Constit_Id   : Entity_Id;\n+\n+         begin\n+            Constit_Elmt := First_Elmt (Refinement_Constituents (State_Id));\n+            while Present (Constit_Elmt) loop\n+               Constit_Id := Node (Constit_Elmt);\n+\n+               if Present_Then_Remove (Out_Constits, Constit_Id) then\n+                  null;\n+\n+               else\n+                  Remove (In_Constits, Constit_Id);\n+                  Remove (In_Out_Constits, Constit_Id);\n+\n+                  Error_Msg_Name_1 := Chars (State_Id);\n+                  Error_Msg_NE\n+                    (\"constituent & of state % must have mode Output in \"\n+                     & \"global refinement\", N, Constit_Id);\n+               end if;\n+\n+               Next_Elmt (Constit_Elmt);\n+            end loop;\n+         end Check_Constituent_Usage;\n+\n+         --  Local variables\n+\n+         Item_Elmt : Elmt_Id;\n+         Item_Id   : Entity_Id;\n+\n+      --  Start of processing for Check_Output_States\n+\n+      begin\n+         --  Inspect the Output items of the corresponding Global aspect/pragma\n+         --  looking for a state with a visible refinement.\n+\n+         if Has_Out_State and then Present (Out_Items) then\n+            Item_Elmt := First_Elmt (Out_Items);\n+            while Present (Item_Elmt) loop\n+               Item_Id := Node (Item_Elmt);\n+\n+               --  Ensure that all of the constituents are utilized and they\n+               --  have mode Output.\n+\n+               if Ekind (Item_Id) = E_Abstract_State\n+                 and then Present (Refinement_Constituents (Item_Id))\n+               then\n+                  Check_Constituent_Usage (Item_Id);\n+               end if;\n+\n+               Next_Elmt (Item_Elmt);\n+            end loop;\n+         end if;\n+      end Check_Output_States;\n+\n+      -------------------------------\n+      -- Check_Refined_Global_List --\n+      -------------------------------\n+\n+      procedure Check_Refined_Global_List\n+        (List        : Node_Id;\n+         Global_Mode : Name_Id := Name_Input)\n+      is\n+         procedure Check_Refined_Global_Item\n+           (Item        : Node_Id;\n+            Global_Mode : Name_Id);\n+         --  Verify the legality of a single global item declaration. Parameter\n+         --  Global_Mode denotes the current mode in effect.\n+\n+         -------------------------------\n+         -- Check_Refined_Global_Item --\n+         -------------------------------\n+\n+         procedure Check_Refined_Global_Item\n+           (Item        : Node_Id;\n+            Global_Mode : Name_Id)\n+         is\n+            procedure Add_Constituent (Item_Id : Entity_Id);\n+            --  Add a single constituent to one of the three constituent lists\n+            --  depending on Global_Mode.\n+\n+            procedure Check_Matching_Modes (Item_Id : Entity_Id);\n+            --  Verify that the global modes of item Item_Id are the same in\n+            --  both aspects/pragmas Global and Refined_Global.\n+\n+            function Is_Part_Of\n+              (State    : Entity_Id;\n+               Ancestor : Entity_Id) return Boolean;\n+            --  Determine whether abstract state State is part of an ancestor\n+            --  abstract state Ancestor. For this relationship to hold, State\n+            --  must have option Part_Of in its Abstract_State definition.\n+\n+            ---------------------\n+            -- Add_Constituent --\n+            ---------------------\n+\n+            procedure Add_Constituent (Item_Id : Entity_Id) is\n+            begin\n+               if Global_Mode = Name_Input then\n+                  Add_Item (Item_Id, In_Constits);\n+\n+               elsif Global_Mode = Name_In_Out then\n+                  Add_Item (Item_Id, In_Out_Constits);\n+\n+               elsif Global_Mode = Name_Output then\n+                  Add_Item (Item_Id, Out_Constits);\n+               end if;\n+            end Add_Constituent;\n+\n+            --------------------------\n+            -- Check_Matching_Modes --\n+            --------------------------\n+\n+            procedure Check_Matching_Modes (Item_Id : Entity_Id) is\n+               procedure Inconsistent_Mode_Error (Expect : Name_Id);\n+               --  Issue a common error message for all mode mismatche. Expect\n+               --  denotes the expected mode.\n+\n+               -----------------------------\n+               -- Inconsistent_Mode_Error --\n+               -----------------------------\n+\n+               procedure Inconsistent_Mode_Error (Expect : Name_Id) is\n+               begin\n+                  Error_Msg_NE\n+                    (\"global item & has inconsistent modes\", Item, Item_Id);\n+\n+                  Error_Msg_Name_1 := Global_Mode;\n+                  Error_Msg_N (\"\\  expected mode %\", Item);\n+\n+                  Error_Msg_Name_1 := Expect;\n+                  Error_Msg_N (\"\\  found mode %\", Item);\n+               end Inconsistent_Mode_Error;\n+\n+            --  Start processing for Check_Matching_Modes\n+\n+            begin\n+               if Contains (In_Items, Item_Id) then\n+                  if Global_Mode /= Name_Input then\n+                     Inconsistent_Mode_Error (Name_Input);\n+                  end if;\n+\n+               elsif Contains (In_Out_Items, Item_Id) then\n+                  if Global_Mode /= Name_In_Out then\n+                     Inconsistent_Mode_Error (Name_In_Out);\n+                  end if;\n+\n+               elsif Contains (Out_Items, Item_Id) then\n+                  if Global_Mode /= Name_Output then\n+                     Inconsistent_Mode_Error (Name_Output);\n+                  end if;\n+\n+               --  The item does not appear in the corresponding Global aspect,\n+               --  it must be an extra.\n+\n+               else\n+                  Error_Msg_NE (\"extra global item &\", Item, Item_Id);\n+               end if;\n+            end Check_Matching_Modes;\n+\n+            ----------------\n+            -- Is_Part_Of --\n+            ----------------\n+\n+            function Is_Part_Of\n+              (State    : Entity_Id;\n+               Ancestor : Entity_Id) return Boolean\n+            is\n+               Options : constant Node_Id := Parent (State);\n+               Name    : Node_Id;\n+               Option  : Node_Id;\n+               Value   : Node_Id;\n+\n+            begin\n+               --  A state declaration with option Part_Of appears as an\n+               --  extension aggregate with component associations.\n+\n+               if Nkind (Options) = N_Extension_Aggregate then\n+                  Option := First (Component_Associations (Options));\n+                  while Present (Option) loop\n+                     Name  := First (Choices (Option));\n+                     Value := Expression (Option);\n+\n+                     if Chars (Name) = Name_Part_Of then\n+                        return Entity (Value) = Ancestor;\n+                     end if;\n+\n+                     Next (Option);\n+                  end loop;\n+               end if;\n+\n+               return False;\n+            end Is_Part_Of;\n+\n+            --  Local variables\n+\n+            Item_Id : constant Entity_Id := Entity_Of (Item);\n+\n+         --  Start of processing for Check_Refined_Global_Item\n+\n+         begin\n+            --  State checks\n+\n+            if Ekind (Item_Id) = E_Abstract_State then\n+\n+               --  The state acts as a constituent of some other state. Ensure\n+               --  that the other state is a proper ancestor of the item.\n+\n+               if Present (Refined_State (Item_Id)) then\n+                  if Is_Part_Of (Item_Id, Refined_State (Item_Id)) then\n+                     Add_Constituent (Item_Id);\n+                  else\n+                     Error_Msg_Name_1 := Chars (Refined_State (Item_Id));\n+                     Error_Msg_NE\n+                       (\"state & is not a valid constituent of ancestor \"\n+                        & \"state %\", Item, Item_Id);\n+                  end if;\n+\n+               --  An abstract state with visible refinement cannot appear in a\n+               --  global refinement as its place must be taken by some of its\n+               --  constituents.\n+\n+               elsif Present (Refinement_Constituents (Item_Id)) then\n+                  Error_Msg_NE\n+                    (\"cannot mention state & in global refinement, use its \"\n+                     & \"constituents instead\", Item, Item_Id);\n+\n+               --  The state is not refined nor is it a constituent. Ensure\n+               --  that the modes of both its occurrences in Global and\n+               --  Refined_Global match.\n+\n+               else\n+                  Check_Matching_Modes (Item_Id);\n+               end if;\n+\n+            --  Variable checks\n+\n+            else pragma Assert (Ekind (Item_Id) = E_Variable);\n+\n+               --  The variable acts as a constituent of a state, collect it\n+               --  for the state completeness checks performed later on.\n+\n+               if Present (Refined_State (Item_Id)) then\n+                  Add_Constituent (Item_Id);\n+\n+               --  The variable is not a constituent. Ensure that the modes of\n+               --  both its occurrences in Global and Refined_Global match.\n+\n+               else\n+                  Check_Matching_Modes (Item_Id);\n+               end if;\n+            end if;\n+         end Check_Refined_Global_Item;\n+\n+         --  Local variables\n+\n+         Item : Node_Id;\n+\n+      --  Start of processing for Check_Refined_Global_List\n+\n+      begin\n+         --  Single global item declaration\n+\n+         if Nkind_In (List, N_Expanded_Name,\n+                            N_Identifier,\n+                            N_Selected_Component)\n+         then\n+            Check_Refined_Global_Item (List, Global_Mode);\n+\n+         --  Simple global list or moded global list declaration\n+\n+         elsif Nkind (List) = N_Aggregate then\n+\n+            --  The declaration of a simple global list appear as a collection\n+            --  of expressions.\n+\n+            if Present (Expressions (List)) then\n+               Item := First (Expressions (List));\n+               while Present (Item) loop\n+                  Check_Refined_Global_Item (Item, Global_Mode);\n+\n+                  Next (Item);\n+               end loop;\n+\n+            --  The declaration of a moded global list appears as a collection\n+            --  of component associations where individual choices denote\n+            --  modes.\n+\n+            elsif Present (Component_Associations (List)) then\n+               Item := First (Component_Associations (List));\n+               while Present (Item) loop\n+                  Check_Refined_Global_List\n+                    (List        => Expression (Item),\n+                     Global_Mode => Chars (First (Choices (Item))));\n+\n+                  Next (Item);\n+               end loop;\n+\n+            --  Invalid tree\n+\n+            else\n+               raise Program_Error;\n+            end if;\n+\n+         --  Invalid list\n+\n+         else\n+            raise Program_Error;\n+         end if;\n+      end Check_Refined_Global_List;\n+\n+      --------------------------\n+      -- Collect_Global_Items --\n+      --------------------------\n+\n+      procedure Collect_Global_Items (Prag : Node_Id) is\n+         procedure Process_Global_List\n+           (List : Node_Id;\n+            Mode : Name_Id := Name_Input);\n+         --  Collect all items housed in a global list. Formal Mode denotes the\n+         --  current mode in effect.\n+\n+         -------------------------\n+         -- Process_Global_List --\n+         -------------------------\n+\n+         procedure Process_Global_List\n+           (List : Node_Id;\n+            Mode : Name_Id := Name_Input)\n+         is\n+            procedure Process_Global_Item (Item : Node_Id; Mode : Name_Id);\n+            --  Add a single item to the appropriate list. Formal Mode denotes\n+            --  the current mode in effect.\n+\n+            -------------------------\n+            -- Process_Global_Item --\n+            -------------------------\n+\n+            procedure Process_Global_Item (Item : Node_Id; Mode : Name_Id) is\n+               Item_Id : constant Entity_Id := Entity_Of (Item);\n+\n+            begin\n+               --  Signal that the global list contains at least one abstract\n+               --  state with a visible refinement.\n+\n+               if Ekind (Item_Id) = E_Abstract_State\n+                 and then Present (Refinement_Constituents (Item_Id))\n+               then\n+                  if Mode = Name_Input then\n+                     Has_In_State := True;\n+                  elsif Mode = Name_In_Out then\n+                     Has_In_Out_State := True;\n+                  elsif Mode = Name_Output then\n+                     Has_Out_State := True;\n+                  end if;\n+               end if;\n+\n+               --  Add the item to the proper list\n+\n+               if Mode = Name_Input then\n+                  Add_Item (Item_Id, In_Items);\n+               elsif Mode = Name_In_Out then\n+                  Add_Item (Item_Id, In_Out_Items);\n+               elsif Mode = Name_Output then\n+                  Add_Item (Item_Id, Out_Items);\n+               end if;\n+            end Process_Global_Item;\n+\n+            --  Local variables\n+\n+            Item : Node_Id;\n+\n+         --  Start of processing for Process_Global_List\n+\n+         begin\n+            --  Single global item declaration\n+\n+            if Nkind_In (List, N_Expanded_Name,\n+                               N_Identifier,\n+                               N_Selected_Component)\n+            then\n+               Process_Global_Item (List, Mode);\n+\n+            --  Single global list or moded global list declaration\n+\n+            elsif Nkind (List) = N_Aggregate then\n+\n+               --  The declaration of a simple global list appear as a\n+               --  collection of expressions.\n+\n+               if Present (Expressions (List)) then\n+                  Item := First (Expressions (List));\n+                  while Present (Item) loop\n+                     Process_Global_Item (Item, Mode);\n+\n+                     Next (Item);\n+                  end loop;\n+\n+               --  The declaration of a moded global list appears as a\n+               --  collection of component associations where individual\n+               --  choices denote modes.\n+\n+               elsif Present (Component_Associations (List)) then\n+                  Item := First (Component_Associations (List));\n+                  while Present (Item) loop\n+                     Process_Global_List\n+                       (List => Expression (Item),\n+                        Mode => Chars (First (Choices (Item))));\n+\n+                     Next (Item);\n+                  end loop;\n+\n+               --  Invalid tree\n+\n+               else\n+                  raise Program_Error;\n+               end if;\n+\n+            --  Invalid list\n+\n+            else\n+               raise Program_Error;\n+            end if;\n+         end Process_Global_List;\n+\n+         --  Local variables\n+\n+         List : constant Node_Id :=\n+                  Get_Pragma_Arg (First (Pragma_Argument_Associations (Prag)));\n+\n+      --  Start of processing for Collect_Global_Items\n+\n+      begin\n+         --  Do not process a null global list as it contains nothing\n+\n+         if Nkind (List) /= N_Null then\n+            Process_Global_List (List);\n+         end if;\n+      end Collect_Global_Items;\n+\n+      -------------------------\n+      -- Present_Then_Remove --\n+      -------------------------\n+\n+      function Present_Then_Remove\n+        (List : Elist_Id;\n+         Item : Entity_Id) return Boolean\n+      is\n+         Elmt : Elmt_Id;\n+\n+      begin\n+         if Present (List) then\n+            Elmt := First_Elmt (List);\n+            while Present (Elmt) loop\n+               if Node (Elmt) = Item then\n+                  Remove_Elmt (List, Elmt);\n+                  return True;\n+               end if;\n+\n+               Next_Elmt (Elmt);\n+            end loop;\n+         end if;\n+\n+         return False;\n+      end Present_Then_Remove;\n+\n+      -------------------------------\n+      -- Report_Extra_Constituents --\n+      -------------------------------\n+\n+      procedure Report_Extra_Constituents is\n+         procedure Report_Extra_Constituents_In_List (List : Elist_Id);\n+         --  Emit an error for every element of List\n+\n+         ---------------------------------------\n+         -- Report_Extra_Constituents_In_List --\n+         ---------------------------------------\n+\n+         procedure Report_Extra_Constituents_In_List (List : Elist_Id) is\n+            Constit_Elmt : Elmt_Id;\n+\n+         begin\n+            if Present (List) then\n+               Constit_Elmt := First_Elmt (List);\n+               while Present (Constit_Elmt) loop\n+                  Error_Msg_NE (\"extra constituent &\", N, Node (Constit_Elmt));\n+                  Next_Elmt (Constit_Elmt);\n+               end loop;\n+            end if;\n+         end Report_Extra_Constituents_In_List;\n+\n+      --  Start of processing for Report_Extra_Constituents\n+\n+      begin\n+         Report_Extra_Constituents_In_List (In_Constits);\n+         Report_Extra_Constituents_In_List (In_Out_Constits);\n+         Report_Extra_Constituents_In_List (Out_Constits);\n+      end Report_Extra_Constituents;\n+\n+      --  Local variables\n+\n+      Body_Decl : constant Node_Id := Parent (N);\n+      Errors    : constant Nat     := Serious_Errors_Detected;\n+      List      : constant Node_Id :=\n+                    Get_Pragma_Arg (First (Pragma_Argument_Associations (N)));\n+      Spec_Id   : constant Entity_Id := Corresponding_Spec (Body_Decl);\n+\n+   --  Start of processing for Analyze_Refined_Global_In_Decl_Part\n+\n    begin\n-      null;\n+      Global := Get_Pragma (Spec_Id, Pragma_Global);\n+\n+      --  The subprogram declaration lacks aspect/pragma Global. This renders\n+      --  Refined_Global useless as there is nothing to refine.\n+\n+      if No (Global) then\n+         Error_Msg_NE\n+           (\"useless refinement, subprogram & lacks global items\", N, Spec_Id);\n+         return;\n+      end if;\n+\n+      --  Extract all relevant items from the corresponding Global aspect or\n+      --  pragma.\n+\n+      Collect_Global_Items (Global);\n+\n+      --  The corresponding Global aspect/pragma must mention at least one\n+      --  state with a visible refinement at the point Refined_Global is\n+      --  processed.\n+\n+      if not Has_In_State\n+        and then not Has_In_Out_State\n+        and then not Has_Out_State\n+      then\n+         Error_Msg_NE\n+           (\"useless refinement, subprogram & does not mention abstract state \"\n+            & \"with visible refinement\", N, Spec_Id);\n+         return;\n+      end if;\n+\n+      --  The global refinement of inputs and outputs cannot be null when the\n+      --  corresponding Global aspect/pragma contains at least one item.\n+\n+      if Nkind (List) = N_Null\n+        and then\n+          (Present (In_Items)\n+            or else Present (In_Out_Items)\n+            or else Present (Out_Items))\n+      then\n+         Error_Msg_NE\n+           (\"refinement cannot be null, subprogram & has global items\",\n+            N, Spec_Id);\n+         return;\n+      end if;\n+\n+      --  Analyze Refined_Global as if it behaved as a regular aspect/pragma\n+      --  Global. This ensures that the categorization of all refined global\n+      --  items is consistent with their role.\n+\n+      Analyze_Global_In_Decl_Part (N);\n+\n+      --  Perform all refinement checks with respect to completeness and mode\n+      --  matching.\n+\n+      if Serious_Errors_Detected = Errors then\n+         Check_Refined_Global_List (List);\n+      end if;\n+\n+      --  For Input states with visible refinement, at least one constituent\n+      --  must be used as an Input in the global refinement.\n+\n+      if Serious_Errors_Detected = Errors then\n+         Check_Input_States;\n+      end if;\n+\n+      --  Verify all possible completion variants for In_Out states with\n+      --  visible refinement.\n+\n+      if Serious_Errors_Detected = Errors then\n+         Check_In_Out_States;\n+      end if;\n+\n+      --  For Output states with visible refinement, all constituents must be\n+      --  used as Outputs in the global refinement.\n+\n+      if Serious_Errors_Detected = Errors then\n+         Check_Output_States;\n+      end if;\n+\n+      --  Emit errors for all constituents that belong to other states with\n+      --  visible refinement that do not appear in Global.\n+\n+      if Serious_Errors_Detected = Errors then\n+         Report_Extra_Constituents;\n+      end if;\n    end Analyze_Refined_Global_In_Decl_Part;\n \n    ----------------------------------------\n@@ -18587,6 +19493,9 @@ package body Sem_Prag is\n       -------------------------------\n \n       procedure Analyze_Refinement_Clause (Clause : Node_Id) is\n+         State_Id : Entity_Id := Empty;\n+         --  The entity of the state being refined in the current clause\n+\n          Non_Null_Seen : Boolean := False;\n          Null_Seen     : Boolean := False;\n          --  Flags used to detect multiple uses of null in a single clause or a\n@@ -18647,6 +19556,17 @@ package body Sem_Prag is\n                      Add_Item (Constit_Id, Constituents_Seen);\n                      Remove_Elmt (Hidden_States, State_Elmt);\n \n+                     --  Establish a relation between the refined state and its\n+                     --  constituent.\n+\n+                     if No (Refinement_Constituents (State_Id)) then\n+                        Set_Refinement_Constituents (State_Id, New_Elmt_List);\n+                     end if;\n+\n+                     Append_Elmt\n+                       (Constit_Id, Refinement_Constituents (State_Id));\n+                     Set_Refined_State (Constit_Id, State_Id);\n+\n                      return;\n                   end if;\n \n@@ -18771,9 +19691,8 @@ package body Sem_Prag is\n \n          --  Local declarations\n \n-         Constit  : Node_Id;\n-         State    : Node_Id;\n-         State_Id : Entity_Id := Empty;\n+         Constit : Node_Id;\n+         State   : Node_Id;\n \n       --  Start of processing for Analyze_Refinement_Clause\n \n@@ -18891,12 +19810,8 @@ package body Sem_Prag is\n \n                --  Source objects (non-constants) are valid hidden states\n \n-               --  This is a very odd test, it misses many cases, e.g.\n-               --  renamings of objects, in-out parameters etc ???. Why\n-               --  not test the Ekind ???\n-\n                if Nkind (Decl) = N_Object_Declaration\n-                 and then not Constant_Present (Decl)\n+                 and then Ekind (Defining_Entity (Decl)) = E_Variable\n                  and then Comes_From_Source (Decl)\n                then\n                   Add_Item (Defining_Entity (Decl), Result);\n@@ -19004,7 +19919,7 @@ package body Sem_Prag is\n \n       --  Initialize the various lists used during analysis\n \n-      Abstr_States  := Clone (Abstract_States (Spec_Id));\n+      Abstr_States  := New_Copy_Elist (Abstract_States (Spec_Id));\n       Hidden_States := Collect_Hidden_States;\n \n       --  Multiple state refinements appear as an aggregate"}, {"sha": "7a0341bf67ccbf72eb93972d6ad916dd30a4922f", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 122, "deletions": 1, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab8843fac024b4f8e4147c084cb876649b2e66c5/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab8843fac024b4f8e4147c084cb876649b2e66c5/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=ab8843fac024b4f8e4147c084cb876649b2e66c5", "patch": "@@ -27,8 +27,8 @@ with Atree;    use Atree;\n with Casing;   use Casing;\n with Checks;   use Checks;\n with Debug;    use Debug;\n-with Errout;   use Errout;\n with Elists;   use Elists;\n+with Errout;   use Errout;\n with Exp_Ch11; use Exp_Ch11;\n with Exp_Disp; use Exp_Disp;\n with Exp_Util; use Exp_Util;\n@@ -3157,6 +3157,127 @@ package body Sem_Util is\n       end if;\n    end Conditional_Delay;\n \n+   ----------------------------\n+   -- Contains_Refined_State --\n+   ----------------------------\n+\n+   function Contains_Refined_State (Prag : Node_Id) return Boolean is\n+      function Has_Refined_State (List : Node_Id) return Boolean;\n+      --  Determine whether a global list mentions a state with a visible\n+      --  refinement.\n+\n+      -----------------------\n+      -- Has_Refined_State --\n+      -----------------------\n+\n+      function Has_Refined_State (List : Node_Id) return Boolean is\n+         function Is_Refined_State (Item : Node_Id) return Boolean;\n+         --  Determine whether Item is a reference to an abstract state with a\n+         --  visible refinement.\n+\n+         ----------------------\n+         -- Is_Refined_State --\n+         ----------------------\n+\n+         function Is_Refined_State (Item : Node_Id) return Boolean is\n+            Item_Id : Entity_Id;\n+\n+         begin\n+            if Nkind (Item) = N_Null then\n+               return False;\n+\n+            else\n+               Item_Id := Entity_Of (Item);\n+\n+               return\n+                 Ekind (Item_Id) = E_Abstract_State\n+                   and then Present (Refinement_Constituents (Item_Id));\n+            end if;\n+         end Is_Refined_State;\n+\n+         --  Local variables\n+\n+         Item : Node_Id;\n+\n+      --  Start of processing for Has_Refined_State\n+\n+      begin\n+         --  A null global list does not mention any states\n+\n+         if Nkind (List) = N_Null then\n+            return False;\n+\n+         --  Single global item declaration\n+\n+         elsif Nkind_In (List, N_Expanded_Name,\n+                               N_Identifier,\n+                               N_Selected_Component)\n+         then\n+            return Is_Refined_State (List);\n+\n+         --  Simple global list or moded global list declaration\n+\n+         elsif Nkind (List) = N_Aggregate then\n+\n+            --  The declaration of a simple global list appear as a collection\n+            --  of expressions.\n+\n+            if Present (Expressions (List)) then\n+               Item := First (Expressions (List));\n+               while Present (Item) loop\n+                  if Is_Refined_State (Item) then\n+                     return True;\n+                  end if;\n+\n+                  Next (Item);\n+               end loop;\n+\n+            --  The declaration of a moded global list appears as a collection\n+            --  of component associations where individual choices denote\n+            --  modes.\n+\n+            else\n+               Item := First (Component_Associations (List));\n+               while Present (Item) loop\n+                  if Has_Refined_State (Expression (Item)) then\n+                     return True;\n+                  end if;\n+\n+                  Next (Item);\n+               end loop;\n+            end if;\n+\n+            --  If we get here, then the simple/moded global list did not\n+            --  mention any states with a visible refinement.\n+\n+            return False;\n+\n+         --  Something went horribly wrong, we have a malformed tree\n+\n+         else\n+            raise Program_Error;\n+         end if;\n+      end Has_Refined_State;\n+\n+      --  Local variables\n+\n+      Arg : constant Node_Id :=\n+              Get_Pragma_Arg (First (Pragma_Argument_Associations (Prag)));\n+      Nam : constant Name_Id := Pragma_Name (Prag);\n+\n+   --  Start of processing for Contains_Refined_State\n+\n+   begin\n+      --  ??? To be implemented\n+\n+      if Nam = Name_Depends then\n+         return False;\n+\n+      else pragma Assert (Nam = Name_Global);\n+         return Has_Refined_State (Arg);\n+      end if;\n+   end Contains_Refined_State;\n+\n    -------------------------\n    -- Copy_Component_List --\n    -------------------------"}, {"sha": "621cb01d2d9de4e5cd9e916a9745a821387b6e9b", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab8843fac024b4f8e4147c084cb876649b2e66c5/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab8843fac024b4f8e4147c084cb876649b2e66c5/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=ab8843fac024b4f8e4147c084cb876649b2e66c5", "patch": "@@ -326,6 +326,13 @@ package Sem_Util is\n    --  Sets the Has_Delayed_Freeze flag of New if the Delayed_Freeze flag of\n    --  Old is set and Old has no yet been Frozen (i.e. Is_Frozen is false).\n \n+   function Contains_Refined_State (Prag : Node_Id) return Boolean;\n+   --  Determine whether pragma Prag contains a reference to the entity of an\n+   --  abstract state with a visible refinement. Prag must denote one of the\n+   --  following pragmas:\n+   --    Depends\n+   --    Global\n+\n    function Copy_Parameter_List (Subp_Id : Entity_Id) return List_Id;\n    --  Utility to create a parameter profile for a new subprogram spec, when\n    --  the subprogram has a body that acts as spec. This is done for some cases"}]}