{"sha": "f67e783f4903456c6a889b6a4116d678de2583a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjY3ZTc4M2Y0OTAzNDU2YzZhODg5YjZhNDExNmQ2NzhkZTI1ODNhMQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2005-02-26T07:55:28Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2005-02-26T07:55:28Z"}, "message": "tree-ssa-dom.c (simple_iv_increment_p): New function.\n\n\t* tree-ssa-dom.c (simple_iv_increment_p): New function.\n\t(simplify_rhs_and_lookup_avail_expr, eliminate_redundant_computations):\n\tDo not propagate value of iv before increment over the increment.\n\nFrom-SVN: r95571", "tree": {"sha": "1adec296487d4b3d99d2018b155485c4d49b6949", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1adec296487d4b3d99d2018b155485c4d49b6949"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f67e783f4903456c6a889b6a4116d678de2583a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f67e783f4903456c6a889b6a4116d678de2583a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f67e783f4903456c6a889b6a4116d678de2583a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f67e783f4903456c6a889b6a4116d678de2583a1/comments", "author": null, "committer": null, "parents": [{"sha": "e0fa00d1f45526c082cef8897f616183c29d4e70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0fa00d1f45526c082cef8897f616183c29d4e70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0fa00d1f45526c082cef8897f616183c29d4e70"}], "stats": {"total": 62, "additions": 55, "deletions": 7}, "files": [{"sha": "dbff6a778bedfa8c9cf2ab829955cadff3ecb55d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67e783f4903456c6a889b6a4116d678de2583a1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67e783f4903456c6a889b6a4116d678de2583a1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f67e783f4903456c6a889b6a4116d678de2583a1", "patch": "@@ -1,3 +1,9 @@\n+2005-02-26  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* tree-ssa-dom.c (simple_iv_increment_p): New function.\n+\t(simplify_rhs_and_lookup_avail_expr, eliminate_redundant_computations):\n+\tDo not propagate value of iv before increment over the increment.\n+\n 2005-02-25  Joseph S. Myers  <joseph@codesourcery.com>\n \n \t* c-parser.c: New file.\n@@ -66,12 +72,6 @@\n \t* doc/extend.texi (5.24 Declaring Attributes of Functions)<noreturn>:\n \tClarify that the alternative way doesn't work in GNU C++.\n \n-2005-02-25  Zdenek Dvorak  <dvorakz@suse.cz>\n-\n-\t* tree-ssa-dom.c (simple_iv_increment_p): New function.\n-\t(simplify_rhs_and_lookup_avail_expr, eliminate_redundant_computations):\n-\tDo not propagate value of iv before increment over the increment.\n-\n 2005-02-25  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \tPR tree-optimization/19937"}, {"sha": "a313925174a40b399ceb8622357152eebbcad684", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67e783f4903456c6a889b6a4116d678de2583a1/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67e783f4903456c6a889b6a4116d678de2583a1/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=f67e783f4903456c6a889b6a4116d678de2583a1", "patch": "@@ -1635,6 +1635,46 @@ unsafe_associative_fp_binop (tree exp)\n            && FLOAT_TYPE_P (TREE_TYPE (exp)));\n }\n \n+/* Returns true when STMT is a simple iv increment.  It detects the\n+   following situation:\n+   \n+   i_1 = phi (..., i_2)\n+   i_2 = i_1 +/- ...  */\n+\n+static bool\n+simple_iv_increment_p (tree stmt)\n+{\n+  tree lhs, rhs, preinc, phi;\n+  unsigned i;\n+\n+  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+    return false;\n+\n+  lhs = TREE_OPERAND (stmt, 0);\n+  if (TREE_CODE (lhs) != SSA_NAME)\n+    return false;\n+\n+  rhs = TREE_OPERAND (stmt, 1);\n+\n+  if (TREE_CODE (rhs) != PLUS_EXPR\n+      && TREE_CODE (rhs) != MINUS_EXPR)\n+    return false;\n+\n+  preinc = TREE_OPERAND (rhs, 0);\n+  if (TREE_CODE (preinc) != SSA_NAME)\n+    return false;\n+\n+  phi = SSA_NAME_DEF_STMT (preinc);\n+  if (TREE_CODE (phi) != PHI_NODE)\n+    return false;\n+\n+  for (i = 0; i < (unsigned) PHI_NUM_ARGS (phi); i++)\n+    if (PHI_ARG_DEF (phi, i) == lhs)\n+      return true;\n+\n+  return false;\n+}\n+\n /* STMT is a MODIFY_EXPR for which we were unable to find RHS in the\n    hash tables.  Try to simplify the RHS using whatever equivalences\n    we may have recorded.\n@@ -1688,6 +1728,11 @@ simplify_rhs_and_lookup_avail_expr (struct dom_walk_data *walk_data,\n     {\n       tree rhs_def_stmt = SSA_NAME_DEF_STMT (TREE_OPERAND (rhs, 0));\n \n+      /* If the statement defines an induction variable, do not propagate\n+\t its value, so that we do not create overlapping life ranges.  */\n+      if (simple_iv_increment_p (rhs_def_stmt))\n+\tgoto dont_fold_assoc;\n+\n       /* See if the RHS_DEF_STMT has the same form as our statement.  */\n       if (TREE_CODE (rhs_def_stmt) == MODIFY_EXPR)\n \t{\n@@ -2551,7 +2596,10 @@ eliminate_redundant_computations (struct dom_walk_data *walk_data,\n       || ! def\n       || TREE_CODE (def) != SSA_NAME\n       || SSA_NAME_OCCURS_IN_ABNORMAL_PHI (def)\n-      || NUM_V_MAY_DEFS (v_may_defs) != 0)\n+      || NUM_V_MAY_DEFS (v_may_defs) != 0\n+      /* Do not record equivalences for increments of ivs.  This would create\n+\t overlapping live ranges for a very questionable gain.  */\n+      || simple_iv_increment_p (stmt))\n     insert = false;\n \n   /* Check if the expression has been computed before.  */"}]}