{"sha": "14670a74f8ea321083f6263b07467d866700d0bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQ2NzBhNzRmOGVhMzIxMDgzZjYyNjNiMDc0NjdkODY2NzAwZDBiYw==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2007-08-09T14:08:54Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@gcc.gnu.org", "date": "2007-08-09T14:08:54Z"}, "message": "tm.texi (CLZ_DEFINED_VALUE_AT_ZERO, [...]): Document change in interpretation of value from boolean to tri-state integer.\n\n2007-08-09  Sandra Loosemore  <sandra@codesourcery.com>\n\t    Nigel Stephens  <nigel@mips.com>\n\n\tgcc/\n\t* doc/tm.texi (CLZ_DEFINED_VALUE_AT_ZERO, CTZ_DEFINED_VALUE_AT_ZERO):\n\tDocument change in interpretation of value from boolean to\n\ttri-state integer.\n\t* optabs.c (expand_ffs, expand_ctz): New functions to compute\n\tffs and ctz using clz.\n\t(expand_unop):  Call them.\n\t* config/rs6000/rs6000.h (CLZ_DEFINED_VALUE_AT_ZERO): Fix its\n\tresult value.\n\t(CTZ_DEFINED_VALUE_AT_ZERO): Likewise.\n\t* config/mips/mips.h (CLZ_DEFINED_VALUE_AT_ZERO): Likewise, to\n\tenable the new ffs expansion on this target.\n\nCo-Authored-By: Nigel Stephens <nigel@mips.com>\n\nFrom-SVN: r127318", "tree": {"sha": "a8a3fee4ca17eda473bf8fd976e6e1976cb54255", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8a3fee4ca17eda473bf8fd976e6e1976cb54255"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14670a74f8ea321083f6263b07467d866700d0bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14670a74f8ea321083f6263b07467d866700d0bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14670a74f8ea321083f6263b07467d866700d0bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14670a74f8ea321083f6263b07467d866700d0bc/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/166cdb08f21ed5009f1890b717a4eaf0d7f5d3a6"}], "stats": {"total": 120, "additions": 112, "deletions": 8}, "files": [{"sha": "826aa532c63525ef3dd1a642d458da0d312b4f36", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14670a74f8ea321083f6263b07467d866700d0bc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14670a74f8ea321083f6263b07467d866700d0bc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=14670a74f8ea321083f6263b07467d866700d0bc", "patch": "@@ -1,3 +1,18 @@\n+2007-08-09  Sandra Loosemore  <sandra@codesourcery.com>\n+\t    Nigel Stephens  <nigel@mips.com>\n+\n+\t* doc/tm.texi (CLZ_DEFINED_VALUE_AT_ZERO, CTZ_DEFINED_VALUE_AT_ZERO):\n+\tDocument change in interpretation of value from boolean to\n+\ttri-state integer.\n+\t* optabs.c (expand_ffs, expand_ctz): New functions to compute\n+\tffs and ctz using clz.\n+\t(expand_unop):  Call them.\n+\t* config/rs6000/rs6000.h (CLZ_DEFINED_VALUE_AT_ZERO): Fix its\n+\tresult value.\n+\t(CTZ_DEFINED_VALUE_AT_ZERO): Likewise.\n+\t* config/mips/mips.h (CLZ_DEFINED_VALUE_AT_ZERO): Likewise, to\n+\tenable the new ffs expansion on this target.\n+\n 2007-08-09  Jan Hubicka  <jh@suse.cz>\n \n \t* optabs.c (expand_widen_pattern_expr): Use optabs accestors."}, {"sha": "9e9047846d543f0e757e507cf5d18148b02c7df5", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14670a74f8ea321083f6263b07467d866700d0bc/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14670a74f8ea321083f6263b07467d866700d0bc/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=14670a74f8ea321083f6263b07467d866700d0bc", "patch": "@@ -1295,7 +1295,7 @@ extern enum mips_code_readable_setting mips_code_readable;\n /* The [d]clz instructions have the natural values at 0.  */\n \n #define CLZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE) \\\n-  ((VALUE) = GET_MODE_BITSIZE (MODE), true)\n+  ((VALUE) = GET_MODE_BITSIZE (MODE), 2)\n \f\n /* Standard register usage.  */\n "}, {"sha": "5f34c800fb62fe8ae91ea0d41da672871cd1202c", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14670a74f8ea321083f6263b07467d866700d0bc/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14670a74f8ea321083f6263b07467d866700d0bc/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=14670a74f8ea321083f6263b07467d866700d0bc", "patch": "@@ -1856,10 +1856,10 @@ do {\t\t\t\t\t\t\t\t\\\n \n /* The cntlzw and cntlzd instructions return 32 and 64 for input of zero.  */\n #define CLZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE) \\\n-  ((VALUE) = ((MODE) == SImode ? 32 : 64))\n+  ((VALUE) = ((MODE) == SImode ? 32 : 64), 1)\n \n /* The CTZ patterns return -1 for input of zero.  */\n-#define CTZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE) ((VALUE) = -1)\n+#define CTZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE) ((VALUE) = -1, 1)\n \n /* Specify the machine mode that pointers have.\n    After generation of rtl, the compiler makes no further distinction"}, {"sha": "1b690a1cb726af2c298d7842d8fae3118af6ad06", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14670a74f8ea321083f6263b07467d866700d0bc/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14670a74f8ea321083f6263b07467d866700d0bc/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=14670a74f8ea321083f6263b07467d866700d0bc", "patch": "@@ -9638,14 +9638,23 @@ given mode.\n \n @defmac CLZ_DEFINED_VALUE_AT_ZERO (@var{mode}, @var{value})\n @defmacx CTZ_DEFINED_VALUE_AT_ZERO (@var{mode}, @var{value})\n-A C expression that evaluates to true if the architecture defines a value\n-for @code{clz} or @code{ctz} with a zero operand.  If so, @var{value}\n-should be set to this value.  If this macro is not defined, the value of\n-@code{clz} or @code{ctz} is assumed to be undefined.\n+A C expression that indicates whether the architecture defines a value\n+for @code{clz} or @code{ctz} with a zero operand.  \n+A result of @code{0} indicates the value is undefined.\n+If the value is defined for only the RTL expression, the macro should\n+evaluate to @code{1}; if the value applies also to the corresponding optab\n+entry (which is normally the case if it expands directly into\n+the corresponding RTL), then the macro should evaluate to @code{2}.  \n+In the cases where the value is defined, @var{value} should be set to\n+this value.  \n+\n+If this macro is not defined, the value of @code{clz} or\n+@code{ctz} at zero is assumed to be undefined.\n \n This macro must be defined if the target's expansion for @code{ffs}\n relies on a particular value to get correct results.  Otherwise it\n-is not necessary, though it may be used to optimize some corner cases.\n+is not necessary, though it may be used to optimize some corner cases, and\n+to provide a default expansion for the @code{ffs} optab.\n \n Note that regardless of this macro the ``definedness'' of @code{clz}\n and @code{ctz} at zero do @emph{not} extend to the builtin functions"}, {"sha": "bf15d4f925b1e20ed408357e0db07545a9ad0e3b", "filename": "gcc/optabs.c", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14670a74f8ea321083f6263b07467d866700d0bc/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14670a74f8ea321083f6263b07467d866700d0bc/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=14670a74f8ea321083f6263b07467d866700d0bc", "patch": "@@ -122,6 +122,8 @@ static void prepare_float_lib_cmp (rtx *, rtx *, enum rtx_code *,\n \t\t\t\t   enum machine_mode *, int *);\n static rtx widen_clz (enum machine_mode, rtx, rtx);\n static rtx expand_parity (enum machine_mode, rtx, rtx);\n+static rtx expand_ffs (enum machine_mode, rtx, rtx);\n+static rtx expand_ctz (enum machine_mode, rtx, rtx);\n static enum rtx_code get_rtx_code (enum tree_code, bool);\n static rtx vector_compare_rtx (tree, bool, enum insn_code);\n \n@@ -2561,6 +2563,68 @@ expand_parity (enum machine_mode mode, rtx op0, rtx target)\n   return 0;\n }\n \n+/* Try calculating ffs(x) using clz(x).  Since the ffs builtin promises\n+   to return zero for a zero value and clz may have an undefined value\n+   in that case, only do this if we know clz returns the right thing so\n+   that we don't have to generate a test and branch.  */\n+static rtx\n+expand_ffs (enum machine_mode mode, rtx op0, rtx target)\n+{\n+  HOST_WIDE_INT val;\n+  if (clz_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing\n+      && CLZ_DEFINED_VALUE_AT_ZERO (mode, val) == 2\n+      && val == GET_MODE_BITSIZE (mode))\n+    {\n+      rtx last = get_last_insn ();\n+      rtx temp;\n+\n+      temp = expand_unop (mode, neg_optab, op0, NULL_RTX, true);\n+      if (temp)\n+\ttemp = expand_binop (mode, and_optab, op0, temp, NULL_RTX,\n+\t\t\t     true, OPTAB_DIRECT);\n+      if (temp)\n+\ttemp = expand_unop (mode, clz_optab, temp, NULL_RTX, true);\n+      if (temp)\n+\ttemp = expand_binop (mode, sub_optab,\n+\t\t\t     GEN_INT (GET_MODE_BITSIZE (mode)),\n+\t\t\t     temp,\n+\t\t\t     target, true, OPTAB_DIRECT);\n+      if (temp == 0)\n+\tdelete_insns_since (last);\n+      return temp;\n+    }\n+  return 0;\n+}\n+\n+/* We can compute ctz(x) using clz(x) with a similar recipe.  Here the ctz\n+   builtin has an undefined result on zero, just like clz, so we don't have\n+   to do that check.  */\n+static rtx\n+expand_ctz (enum machine_mode mode, rtx op0, rtx target)\n+{\n+  if (clz_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+    {\n+      rtx last = get_last_insn ();\n+      rtx temp;\n+\n+      temp = expand_unop (mode, neg_optab, op0, NULL_RTX, true);\n+      if (temp)\n+\ttemp = expand_binop (mode, and_optab, op0, temp, NULL_RTX,\n+\t\t\t     true, OPTAB_DIRECT);\n+      if (temp)\n+\ttemp = expand_unop (mode, clz_optab, temp, NULL_RTX, true);\n+      if (temp)\n+\ttemp = expand_binop (mode, xor_optab, temp,\n+\t\t\t     GEN_INT (GET_MODE_BITSIZE (mode) - 1),\n+\t\t\t     target,\n+\t\t\t     true, OPTAB_DIRECT);\n+      if (temp == 0)\n+\tdelete_insns_since (last);\n+      return temp;\n+    }\n+  return 0;\n+}\n+\n /* Extract the OMODE lowpart from VAL, which has IMODE.  Under certain\n    conditions, VAL may already be a SUBREG against which we cannot generate\n    a further SUBREG.  In this case, we expect forcing the value into a\n@@ -2886,6 +2950,22 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \treturn temp;\n     }\n \n+  /* Try implementing ffs (x) in terms of clz (x).  */\n+  if (unoptab == ffs_optab)\n+    {\n+      temp = expand_ffs (mode, op0, target);\n+      if (temp)\n+\treturn temp;\n+    }\n+\n+  /* Try implementing ctz (x) in terms of clz (x).  */\n+  if (unoptab == ctz_optab)\n+    {\n+      temp = expand_ctz (mode, op0, target);\n+      if (temp)\n+\treturn temp;\n+    }\n+\n  try_libcall:\n   /* Now try a library call in this mode.  */\n   if (optab_handler (unoptab, mode)->libfunc)"}]}