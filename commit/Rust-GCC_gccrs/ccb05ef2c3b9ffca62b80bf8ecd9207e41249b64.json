{"sha": "ccb05ef2c3b9ffca62b80bf8ecd9207e41249b64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2NiMDVlZjJjM2I5ZmZjYTYyYjgwYmY4ZWNkOTIwN2U0MTI0OWI2NA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2014-04-15T21:01:04Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-04-15T21:01:04Z"}, "message": "ipa-devirt.c (referenced_from_vtable_p): New predicate.\n\n\n\t* ipa-devirt.c (referenced_from_vtable_p): New predicate.\n\t(maybe_record_node, likely_target_p): Use it.\n\nFrom-SVN: r209435", "tree": {"sha": "09ccc9a11cb09ad632d2e6388de36605e026b7fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09ccc9a11cb09ad632d2e6388de36605e026b7fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ccb05ef2c3b9ffca62b80bf8ecd9207e41249b64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccb05ef2c3b9ffca62b80bf8ecd9207e41249b64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccb05ef2c3b9ffca62b80bf8ecd9207e41249b64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccb05ef2c3b9ffca62b80bf8ecd9207e41249b64/comments", "author": null, "committer": null, "parents": [{"sha": "33fbb3584a1c3836cf54d1346a76f7d6e7db5331", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33fbb3584a1c3836cf54d1346a76f7d6e7db5331", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33fbb3584a1c3836cf54d1346a76f7d6e7db5331"}], "stats": {"total": 81, "additions": 76, "deletions": 5}, "files": [{"sha": "1b81ddc4b7ddc3c44374be1e449e2341e45ba860", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccb05ef2c3b9ffca62b80bf8ecd9207e41249b64/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccb05ef2c3b9ffca62b80bf8ecd9207e41249b64/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ccb05ef2c3b9ffca62b80bf8ecd9207e41249b64", "patch": "@@ -1,3 +1,8 @@\n+2014-04-15  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-devirt.c (referenced_from_vtable_p): New predicate.\n+\t(maybe_record_node, likely_target_p): Use it.\n+\n 2014-04-15  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \tPR target/60839"}, {"sha": "ce724a5147a667f117375c284cffbe8270f15134", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 71, "deletions": 5, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccb05ef2c3b9ffca62b80bf8ecd9207e41249b64/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccb05ef2c3b9ffca62b80bf8ecd9207e41249b64/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=ccb05ef2c3b9ffca62b80bf8ecd9207e41249b64", "patch": "@@ -598,6 +598,48 @@ build_type_inheritance_graph (void)\n   timevar_pop (TV_IPA_INHERITANCE);\n }\n \n+/* Return true if N has reference from live virtual table\n+   (and thus can be a destination of polymorphic call). \n+   Be conservatively correct when callgraph is not built or\n+   if the method may be referred externally.  */\n+\n+static bool\n+referenced_from_vtable_p (struct cgraph_node *node)\n+{\n+  int i;\n+  struct ipa_ref *ref;\n+  bool found = false;\n+\n+  if (node->externally_visible\n+      || node->used_from_other_partition)\n+    return true;\n+\n+  /* Keep this test constant time.\n+     It is unlikely this can happen except for the case where speculative\n+     devirtualization introduced many speculative edges to this node. \n+     In this case the target is very likely alive anyway.  */\n+  if (node->ref_list.referring.length () > 100)\n+    return true;\n+\n+  /* We need references built.  */\n+  if (cgraph_state <= CGRAPH_STATE_CONSTRUCTION)\n+    return true;\n+\n+  for (i = 0; ipa_ref_list_referring_iterate (&node->ref_list,\n+\t\t\t\t\t      i, ref); i++)\n+\t\n+    if ((ref->use == IPA_REF_ALIAS\n+\t && referenced_from_vtable_p (cgraph (ref->referring)))\n+\t|| (ref->use == IPA_REF_ADDR\n+\t    && TREE_CODE (ref->referring->decl) == VAR_DECL\n+\t    && DECL_VIRTUAL_P (ref->referring->decl)))\n+      {\n+\tfound = true;\n+\tbreak;\n+      }\n+  return found;\n+}\n+\n /* If TARGET has associated node, record it in the NODES array.\n    CAN_REFER specify if program can refer to the target directly.\n    if TARGET is unknown (NULL) or it can not be inserted (for example because\n@@ -634,11 +676,29 @@ maybe_record_node (vec <cgraph_node *> &nodes,\n \n   target_node = cgraph_get_node (target);\n \n-  if (target_node != NULL\n-      && ((TREE_PUBLIC (target)\n-\t   || DECL_EXTERNAL (target))\n-\t  || target_node->definition)\n-      && symtab_real_symbol_p (target_node))\n+  /* Method can only be called by polymorphic call if any\n+     of vtables refering to it are alive. \n+\n+     While this holds for non-anonymous functions, too, there are\n+     cases where we want to keep them in the list; for example\n+     inline functions with -fno-weak are static, but we still\n+     may devirtualize them when instance comes from other unit.\n+     The same holds for LTO.\n+\n+     Currently we ignore these functions in speculative devirtualization.\n+     ??? Maybe it would make sense to be more aggressive for LTO even\n+     eslewhere.  */\n+  if (!flag_ltrans\n+      && type_in_anonymous_namespace_p (DECL_CONTEXT (target))\n+      && (!target_node\n+          || !referenced_from_vtable_p (target_node)))\n+    ;\n+  /* See if TARGET is useful function we can deal with.  */\n+  else if (target_node != NULL\n+\t   && (TREE_PUBLIC (target)\n+\t       || DECL_EXTERNAL (target)\n+\t       || target_node->definition)\n+\t   && symtab_real_symbol_p (target_node))\n     {\n       gcc_assert (!target_node->global.inlined_to);\n       gcc_assert (symtab_real_symbol_p (target_node));\n@@ -1725,6 +1785,12 @@ likely_target_p (struct cgraph_node *n)\n     return false;\n   if (n->frequency < NODE_FREQUENCY_NORMAL)\n     return false;\n+  /* If there are no virtual tables refering the target alive,\n+     the only way the target can be called is an instance comming from other\n+     compilation unit; speculative devirtualization is build around an\n+     assumption that won't happen.  */\n+  if (!referenced_from_vtable_p (n))\n+    return false;\n   return true;\n }\n "}]}