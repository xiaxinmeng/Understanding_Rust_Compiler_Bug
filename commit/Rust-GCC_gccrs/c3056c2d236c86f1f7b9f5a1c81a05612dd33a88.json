{"sha": "c3056c2d236c86f1f7b9f5a1c81a05612dd33a88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzMwNTZjMmQyMzZjODZmMWY3YjlmNWExYzgxYTA1NjEyZGQzM2E4OA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2007-01-19T17:20:20Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2007-01-19T17:20:20Z"}, "message": "ipa-inline.c (cgraph_decide_inlining_incrementally): Instead of 'early' argument take inlining mode argument specifying whether to...\n\n\t* ipa-inline.c (cgraph_decide_inlining_incrementally): Instead of 'early' argument\n\ttake inlining mode argument specifying whether to inline for size/speeed or all\n\tfunctions; add support for flattening; improve dumpting.\n\t(cgraph_early_inlining): Update call of decide_inlining_incrementally.\n\nFrom-SVN: r120970", "tree": {"sha": "ba66283e85dda5a10fa85973c05e74195f8b2c4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba66283e85dda5a10fa85973c05e74195f8b2c4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3056c2d236c86f1f7b9f5a1c81a05612dd33a88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3056c2d236c86f1f7b9f5a1c81a05612dd33a88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3056c2d236c86f1f7b9f5a1c81a05612dd33a88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3056c2d236c86f1f7b9f5a1c81a05612dd33a88/comments", "author": null, "committer": null, "parents": [{"sha": "e65fff3cde79b9062a9042a5efc46df7389486e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e65fff3cde79b9062a9042a5efc46df7389486e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e65fff3cde79b9062a9042a5efc46df7389486e9"}], "stats": {"total": 58, "additions": 42, "deletions": 16}, "files": [{"sha": "bc5b35687e4d559be04ec1f7daac4c21da56e7bd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3056c2d236c86f1f7b9f5a1c81a05612dd33a88/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3056c2d236c86f1f7b9f5a1c81a05612dd33a88/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c3056c2d236c86f1f7b9f5a1c81a05612dd33a88", "patch": "@@ -1,3 +1,10 @@\n+2007-01-19  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline.c (cgraph_decide_inlining_incrementally): Instead of 'early' argument\n+\ttake inlining mode argument specifying whether to inline for size/speeed or all\n+\tfunctions; add support for flattening; improve dumpting.\n+\t(cgraph_early_inlining): Update call of decide_inlining_incrementally.\n+\n 2007-01-19  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \tPR c++/17947"}, {"sha": "d1983d949e91fa2568a5df24921c8ac0306e5bec", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 35, "deletions": 16, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3056c2d236c86f1f7b9f5a1c81a05612dd33a88/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3056c2d236c86f1f7b9f5a1c81a05612dd33a88/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=c3056c2d236c86f1f7b9f5a1c81a05612dd33a88", "patch": "@@ -1136,11 +1136,17 @@ cgraph_decide_inlining (void)\n   return 0;\n }\n \n+enum inlining_mode {\n+  INLINE_SIZE,\n+  INLINE_SPEED,\n+  INLINE_ALL\n+};\n+\n /* Decide on the inlining.  We do so in the topological order to avoid\n    expenses on updating data structures.  */\n \n static unsigned int\n-cgraph_decide_inlining_incrementally (struct cgraph_node *node, bool early)\n+cgraph_decide_inlining_incrementally (struct cgraph_node *node, enum inlining_mode mode)\n {\n   struct cgraph_edge *e;\n   bool inlined = false;\n@@ -1150,10 +1156,17 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node, bool early)\n #ifdef ENABLE_CHECKING\n   verify_cgraph_node (node);\n #endif\n+  if (lookup_attribute (\"flatten\", DECL_ATTRIBUTES (node->decl)) != NULL)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"  Flattening %s\\n\", cgraph_node_name (node));\n+      mode = INLINE_ALL;\n+    }\n \n   /* First of all look for always inline functions.  */\n   for (e = node->callees; e; e = e->next_callee)\n-    if (e->callee->local.disregard_inline_limits\n+    if ((e->callee->local.disregard_inline_limits\n+\t || (mode == INLINE_ALL && e->callee->local.inlinable))\n \t&& e->inline_failed\n \t&& (gimple_in_ssa_p (DECL_STRUCT_FUNCTION (node->decl))\n \t    == gimple_in_ssa_p (DECL_STRUCT_FUNCTION (e->callee->decl)))\n@@ -1162,54 +1175,58 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node, bool early)\n \t   in duplicate_decls. See gcc.c-torture/compile/20011119-2.c  */\n \t&& (DECL_SAVED_TREE (e->callee->decl) || e->callee->inline_decl))\n       {\n-        if (dump_file && early)\n+        if (dump_file)\n \t  {\n-\t    fprintf (dump_file, \"  Early inlining %s\",\n+\t    fprintf (dump_file, \"  Inlining always_inline %s\",\n \t\t     cgraph_node_name (e->callee));\n \t    fprintf (dump_file, \" into %s\\n\", cgraph_node_name (node));\n \t  }\n \tcgraph_mark_inline (e);\n-\t/* In order to fully inline alway_inline functions at -O0, we need to\n+\t/* In order to fully inline always_inline functions at -O0, we need to\n \t   recurse here, since the inlined functions might not be processed by\n-\t   incremental inlining at all yet.  */\n+\t   incremental inlining at all yet.  \n+\n+\t   Also flattening needs to be done recursively.  */\n \t\n-\tif (!flag_unit_at_a_time)\n-          cgraph_decide_inlining_incrementally (e->callee, early);\n+        if (!flag_unit_at_a_time || mode == INLINE_ALL)\n+          cgraph_decide_inlining_incrementally (e->callee, mode);\n \t\n \tinlined = true;\n       }\n \n   /* Now do the automatic inlining.  */\n-  if (!flag_really_no_inline)\n+  if (!flag_really_no_inline && mode != INLINE_ALL)\n     for (e = node->callees; e; e = e->next_callee)\n       if (e->callee->local.inlinable\n \t  && e->inline_failed\n \t  && !e->callee->local.disregard_inline_limits\n \t  && !cgraph_recursive_inlining_p (node, e->callee, &e->inline_failed)\n \t  && (gimple_in_ssa_p (DECL_STRUCT_FUNCTION (node->decl))\n \t      == gimple_in_ssa_p (DECL_STRUCT_FUNCTION (e->callee->decl)))\n-\t  && (!early\n+\t  && (mode != INLINE_SIZE\n \t      || (cgraph_estimate_size_after_inlining (1, e->caller, e->callee)\n \t          <= e->caller->global.insns))\n \t  && cgraph_check_inline_limits (node, e->callee, &e->inline_failed,\n-\t    \t\t\t\t false)\n+\t    \t\t\t         false)\n \t  && (DECL_SAVED_TREE (e->callee->decl) || e->callee->inline_decl))\n \t{\n \t  if (cgraph_default_inline_p (e->callee, &failed_reason))\n \t    {\n-\t      if (dump_file && early)\n+\t      if (dump_file)\n \t\t{\n-\t\t  fprintf (dump_file, \"  Early inlining %s\",\n+\t\t  fprintf (dump_file, \"  Inlining %s\",\n \t\t\t   cgraph_node_name (e->callee));\n \t\t  fprintf (dump_file, \" into %s\\n\", cgraph_node_name (node));\n \t\t}\n \t      cgraph_mark_inline (e);\n \t      inlined = true;\n+\t      if (!flag_unit_at_a_time)\n+\t\tcgraph_decide_inlining_incrementally (e->callee, mode);\n \t    }\n-\t  else if (!early)\n+\t  else if (!flag_unit_at_a_time)\n \t    e->inline_failed = failed_reason;\n \t}\n-  if (early && inlined && !node->global.inlined_to)\n+  if (flag_unit_at_a_time && inlined && !node->global.inlined_to)\n     {\n       timevar_push (TV_INTEGRATION);\n       todo = optimize_inline_calls (current_function_decl);\n@@ -1259,7 +1276,9 @@ cgraph_early_inlining (void)\n \n   if (sorrycount || errorcount)\n     return 0;\n-  return cgraph_decide_inlining_incrementally (node, flag_unit_at_a_time);\n+  return cgraph_decide_inlining_incrementally (node,\n+\t\t\t\t\t       flag_unit_at_a_time\n+\t\t\t\t\t       ? INLINE_SIZE : INLINE_SPEED);\n }\n \n /* When inlining shall be performed.  */"}]}