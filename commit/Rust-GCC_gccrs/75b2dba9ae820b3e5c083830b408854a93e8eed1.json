{"sha": "75b2dba9ae820b3e5c083830b408854a93e8eed1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzViMmRiYTlhZTgyMGIzZTVjMDgzODMwYjQwODg1NGE5M2U4ZWVkMQ==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2014-03-04T04:33:40Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2014-03-04T04:33:40Z"}, "message": "re PR fortran/60148 (strings in NAMELIST do not honor DELIM= in open statement)\n\n2014-03-03  Jerry DeLisle  <jvdelisle@gcc.gnu>\n\n\tPR libfortran/60148\n\t* io/inquire.c (inquire_via_unit): In the case of\n\tDELIM_UNSPECIFIED set inquire return string to \"NONE\".\n\t* io/list_read.c (read_character): In the case of DELIM_NONE and\n\tnamelists, complete the character read using the namelist\n\tvariable length.\n\t* io/open.c (new_unit): Don't set delim status to none if not\n\tspecified so that DELIM_UNSPECIFIED can be used later.\n\t* io/transfer.c (data_transfer_init): For namelist I/O, if the\n\tunit delim status is unspecified set the current status to quote.\n\tOtherwise, set current status to the unit status.\n\t* io/unit.c (get_internel_unit, init_unit): Remember to set\n\tflags_delim initially to DELIM_UNSPECIFIED so defaults come out\n\tcorrectly.\n\t* io/write.c (write_character): Add a new function argument\n\t\"mode\" to signify that raw output is to be used vs output with\n\tdelimiters. If the mode is set to DELIM (1) proceed with\n\tdelimiters. (list_formatted_write_scalar): Write the separator\n\tonly if a delimiter was previously specified. Update the call to\n\twrite_character with the mode argument given.\n\t(namelist_write_newline): Use the mode argument. (nml_write_obj):\n\tUse the mode argument. Remove use of tmp_delim. Write the\n\tsemi-colon or comma correctly only when needed with using\n\tdelimiters. Cleanup whitespace.\n\t(namelist_write): If delim is not specified in namelist I/O,\n\tdefault\tto using quotes. Get rid of the tmp_delim variable and\n\tuse the new mode argument in write_character.\n\nFrom-SVN: r208302", "tree": {"sha": "cc43dea2c41d8e23a38dab1078510f8394771d85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc43dea2c41d8e23a38dab1078510f8394771d85"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75b2dba9ae820b3e5c083830b408854a93e8eed1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75b2dba9ae820b3e5c083830b408854a93e8eed1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75b2dba9ae820b3e5c083830b408854a93e8eed1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75b2dba9ae820b3e5c083830b408854a93e8eed1/comments", "author": null, "committer": null, "parents": [{"sha": "915182a087847bbb0778bf351b5154fa2a83a13c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/915182a087847bbb0778bf351b5154fa2a83a13c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/915182a087847bbb0778bf351b5154fa2a83a13c"}], "stats": {"total": 197, "additions": 129, "deletions": 68}, "files": [{"sha": "0cf04d2a2b09f70494be20f504ad06ced2eefbde", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b2dba9ae820b3e5c083830b408854a93e8eed1/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b2dba9ae820b3e5c083830b408854a93e8eed1/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=75b2dba9ae820b3e5c083830b408854a93e8eed1", "patch": "@@ -1,3 +1,33 @@\n+2014-03-03  Jerry DeLisle  <jvdelisle@gcc.gnu>\n+\n+\tPR libfortran/60148\n+\t* io/inquire.c (inquire_via_unit): In the case of\n+\tDELIM_UNSPECIFIED set inquire return string to \"NONE\".\n+\t* io/list_read.c (read_character): In the case of DELIM_NONE and\n+\tnamelists, complete the character read using the namelist\n+\tvariable length.\n+\t* io/open.c (new_unit): Don't set delim status to none if not\n+\tspecified so that DELIM_UNSPECIFIED can be used later.\n+\t* io/transfer.c (data_transfer_init): For namelist I/O, if the\n+\tunit delim status is unspecified set the current status to quote.\n+\tOtherwise, set current status to the unit status.\n+\t* io/unit.c (get_internel_unit, init_unit): Remember to set\n+\tflags_delim initially to DELIM_UNSPECIFIED so defaults come out\n+\tcorrectly.\n+\t* io/write.c (write_character): Add a new function argument\n+\t\"mode\" to signify that raw output is to be used vs output with\n+\tdelimiters. If the mode is set to DELIM (1) proceed with\n+\tdelimiters. (list_formatted_write_scalar): Write the separator\n+\tonly if a delimiter was previously specified. Update the call to\n+\twrite_character with the mode argument given.\n+\t(namelist_write_newline): Use the mode argument. (nml_write_obj):\n+\tUse the mode argument. Remove use of tmp_delim. Write the\n+\tsemi-colon or comma correctly only when needed with using\n+\tdelimiters. Cleanup whitespace.\n+\t(namelist_write): If delim is not specified in namelist I/O,\n+\tdefault\tto using quotes. Get rid of the tmp_delim variable and\n+\tuse the new mode argument in write_character.\n+\n 2014-02-21  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/60286"}, {"sha": "c41237c3ec79071a65de791dd0f41cfcf1b7eb2b", "filename": "libgfortran/io/inquire.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b2dba9ae820b3e5c083830b408854a93e8eed1/libgfortran%2Fio%2Finquire.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b2dba9ae820b3e5c083830b408854a93e8eed1/libgfortran%2Fio%2Finquire.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Finquire.c?ref=75b2dba9ae820b3e5c083830b408854a93e8eed1", "patch": "@@ -523,6 +523,7 @@ inquire_via_unit (st_parameter_inquire *iqp, gfc_unit * u)\n \tswitch (u->flags.delim)\n \t  {\n \t  case DELIM_NONE:\n+\t  case DELIM_UNSPECIFIED:\n \t    p = \"NONE\";\n \t    break;\n \t  case DELIM_QUOTE:"}, {"sha": "d1d09b5fe7d0e4431a7fb78c72463017de98e728", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b2dba9ae820b3e5c083830b408854a93e8eed1/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b2dba9ae820b3e5c083830b408854a93e8eed1/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=75b2dba9ae820b3e5c083830b408854a93e8eed1", "patch": "@@ -971,10 +971,24 @@ read_character (st_parameter_dt *dtp, int length __attribute__ ((unused)))\n     default:\n       if (dtp->u.p.namelist_mode)\n \t{\n+\t  if (dtp->u.p.current_unit->delim_status == DELIM_NONE)\n+\t    {\n+\t      /* No delimiters so finish reading the string now.  */\n+\t      int i;\n+\t      push_char (dtp, c);\n+\t      for (i = dtp->u.p.ionml->string_length; i > 1; i--)\n+\t\t{\n+\t\t  if ((c = next_char (dtp)) == EOF)\n+\t\t    goto done_eof;\n+\t\t  push_char (dtp, c);\n+\t\t}\n+\t      dtp->u.p.saved_type = BT_CHARACTER;\n+\t      free_line (dtp);\n+\t      return;\n+\t    }\n \t  unget_char (dtp, c);\n \t  return;\n \t}\n-\n       push_char (dtp, c);\n       goto get_string;\n     }"}, {"sha": "06fd59415fe66fe1f2e6d41753db2286fdb0038b", "filename": "libgfortran/io/open.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b2dba9ae820b3e5c083830b408854a93e8eed1/libgfortran%2Fio%2Fopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b2dba9ae820b3e5c083830b408854a93e8eed1/libgfortran%2Fio%2Fopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fopen.c?ref=75b2dba9ae820b3e5c083830b408854a93e8eed1", "patch": "@@ -332,17 +332,13 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags * flags)\n \n   /* Checks.  */\n \n-  if (flags->delim == DELIM_UNSPECIFIED)\n-    flags->delim = DELIM_NONE;\n-  else\n+  if (flags->delim != DELIM_UNSPECIFIED\n+      && flags->form == FORM_UNFORMATTED)\n     {\n-      if (flags->form == FORM_UNFORMATTED)\n-\t{\n-\t  generate_error (&opp->common, LIBERROR_OPTION_CONFLICT,\n-\t\t\t  \"DELIM parameter conflicts with UNFORMATTED form in \"\n-\t\t\t  \"OPEN statement\");\n-\t  goto fail;\n-\t}\n+      generate_error (&opp->common, LIBERROR_OPTION_CONFLICT,\n+\t\t      \"DELIM parameter conflicts with UNFORMATTED form in \"\n+\t\t      \"OPEN statement\");\n+      goto fail;\n     }\n \n   if (flags->blank == BLANK_UNSPECIFIED)"}, {"sha": "cadbcabeda42f3a8354256e5c531c7ab6cbd80ac", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b2dba9ae820b3e5c083830b408854a93e8eed1/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b2dba9ae820b3e5c083830b408854a93e8eed1/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=75b2dba9ae820b3e5c083830b408854a93e8eed1", "patch": "@@ -2670,16 +2670,21 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n \t= !(cf & IOPARM_DT_HAS_DELIM) ? DELIM_UNSPECIFIED :\n \t  find_option (&dtp->common, dtp->delim, dtp->delim_len,\n \t  delim_opt, \"Bad DELIM parameter in data transfer statement\");\n-  \n+\n   if (dtp->u.p.current_unit->delim_status == DELIM_UNSPECIFIED)\n-    dtp->u.p.current_unit->delim_status = dtp->u.p.current_unit->flags.delim;\n+    {\n+      if (ionml && dtp->u.p.current_unit->flags.delim == DELIM_UNSPECIFIED)\n+\tdtp->u.p.current_unit->delim_status = DELIM_QUOTE;\n+      else\n+\tdtp->u.p.current_unit->delim_status = dtp->u.p.current_unit->flags.delim;\n+    }\n \n   /* Check the pad mode.  */\n   dtp->u.p.current_unit->pad_status\n \t= !(cf & IOPARM_DT_HAS_PAD) ? PAD_UNSPECIFIED :\n \t  find_option (&dtp->common, dtp->pad, dtp->pad_len, pad_opt,\n \t\t\t\"Bad PAD parameter in data transfer statement\");\n-  \n+\n   if (dtp->u.p.current_unit->pad_status == PAD_UNSPECIFIED)\n \tdtp->u.p.current_unit->pad_status = dtp->u.p.current_unit->flags.pad;\n "}, {"sha": "901d66fa0c1bc2196152fe9a6a5716b6398184bd", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b2dba9ae820b3e5c083830b408854a93e8eed1/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b2dba9ae820b3e5c083830b408854a93e8eed1/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=75b2dba9ae820b3e5c083830b408854a93e8eed1", "patch": "@@ -464,6 +464,7 @@ get_internal_unit (st_parameter_dt *dtp)\n   iunit->flags.status = STATUS_UNSPECIFIED;\n   iunit->flags.sign = SIGN_SUPPRESS;\n   iunit->flags.decimal = DECIMAL_POINT;\n+  iunit->flags.delim = DELIM_UNSPECIFIED;\n   iunit->flags.encoding = ENCODING_DEFAULT;\n   iunit->flags.async = ASYNC_NO;\n   iunit->flags.round = ROUND_UNSPECIFIED;\n@@ -584,6 +585,7 @@ init_units (void)\n       u->flags.position = POSITION_ASIS;\n       u->flags.sign = SIGN_SUPPRESS;\n       u->flags.decimal = DECIMAL_POINT;\n+      u->flags.delim = DELIM_UNSPECIFIED;\n       u->flags.encoding = ENCODING_DEFAULT;\n       u->flags.async = ASYNC_NO;\n       u->flags.round = ROUND_UNSPECIFIED;"}, {"sha": "eccbe7e2a2014c1f47efc05c29b8559196fa7f24", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 67, "deletions": 54, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b2dba9ae820b3e5c083830b408854a93e8eed1/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b2dba9ae820b3e5c083830b408854a93e8eed1/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=75b2dba9ae820b3e5c083830b408854a93e8eed1", "patch": "@@ -1312,24 +1312,32 @@ write_integer (st_parameter_dt *dtp, const char *source, int length)\n /* Write a list-directed string.  We have to worry about delimiting\n    the strings if the file has been opened in that mode.  */\n \n+#define DELIM 1\n+#define NODELIM 0\n+\n static void\n-write_character (st_parameter_dt *dtp, const char *source, int kind, int length)\n+write_character (st_parameter_dt *dtp, const char *source, int kind, int length, int mode)\n {\n   int i, extra;\n   char *p, d;\n \n-  switch (dtp->u.p.current_unit->delim_status)\n+  if (mode == DELIM)\n     {\n-    case DELIM_APOSTROPHE:\n-      d = '\\'';\n-      break;\n-    case DELIM_QUOTE:\n-      d = '\"';\n-      break;\n-    default:\n-      d = ' ';\n-      break;\n+      switch (dtp->u.p.current_unit->delim_status)\n+\t{\n+\tcase DELIM_APOSTROPHE:\n+\t  d = '\\'';\n+\t  break;\n+\tcase DELIM_QUOTE:\n+\t  d = '\"';\n+\t  break;\n+\tdefault:\n+\t  d = ' ';\n+\t  break;\n+\t}\n     }\n+  else\n+    d = ' ';\n \n   if (kind == 1)\n     {\n@@ -1551,7 +1559,8 @@ list_formatted_write_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n   else\n     {\n       if (type != BT_CHARACTER || !dtp->u.p.char_flag ||\n-\tdtp->u.p.current_unit->delim_status != DELIM_NONE)\n+\t  (dtp->u.p.current_unit->delim_status != DELIM_NONE\n+\t   && dtp->u.p.current_unit->delim_status != DELIM_UNSPECIFIED))\n       write_separator (dtp);\n     }\n \n@@ -1564,7 +1573,7 @@ list_formatted_write_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n       write_logical (dtp, p, kind);\n       break;\n     case BT_CHARACTER:\n-      write_character (dtp, p, kind, size);\n+      write_character (dtp, p, kind, size, DELIM);\n       break;\n     case BT_REAL:\n       write_real (dtp, p, kind);\n@@ -1628,9 +1637,9 @@ namelist_write_newline (st_parameter_dt *dtp)\n   if (!is_internal_unit (dtp))\n     {\n #ifdef HAVE_CRLF\n-      write_character (dtp, \"\\r\\n\", 1, 2);\n+      write_character (dtp, \"\\r\\n\", 1, 2, NODELIM);\n #else\n-      write_character (dtp, \"\\n\", 1, 1);\n+      write_character (dtp, \"\\n\", 1, 1, NODELIM);\n #endif\n       return;\n     }\n@@ -1675,7 +1684,7 @@ namelist_write_newline (st_parameter_dt *dtp)\n \t}\n     }\n   else\n-    write_character (dtp, \" \", 1, 1);\n+    write_character (dtp, \" \", 1, 1, NODELIM);\n }\n \n \n@@ -1704,7 +1713,6 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n   size_t base_name_len;\n   size_t base_var_name_len;\n   size_t tot_len;\n-  unit_delim tmp_delim;\n   \n   /* Set the character to be used to separate values\n      to a comma or semi-colon.  */\n@@ -1718,7 +1726,7 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n   if (obj->type != BT_DERIVED)\n     {\n       namelist_write_newline (dtp);\n-      write_character (dtp, \" \", 1, 1);\n+      write_character (dtp, \" \", 1, 1, NODELIM);\n \n       len = 0;\n       if (base)\n@@ -1728,16 +1736,16 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n \t  for (dim_i = 0; dim_i < base_name_len; dim_i++)\n             {\n \t      cup = toupper ((int) base_name[dim_i]);\n-\t      write_character (dtp, &cup, 1, 1);\n+\t      write_character (dtp, &cup, 1, 1, NODELIM);\n             }\n \t}\n       clen = strlen (obj->var_name);\n       for (dim_i = len; dim_i < clen; dim_i++)\n \t{\n \t  cup = toupper ((int) obj->var_name[dim_i]);\n-\t  write_character (dtp, &cup, 1, 1);\n+\t  write_character (dtp, &cup, 1, 1, NODELIM);\n \t}\n-      write_character (dtp, \"=\", 1, 1);\n+      write_character (dtp, \"=\", 1, 1, NODELIM);\n     }\n \n   /* Counts the number of data output on a line, including names.  */\n@@ -1807,7 +1815,7 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n \t  if (rep_ctr > 1)\n \t    {\n \t      snprintf(rep_buff, NML_DIGITS, \" %d*\", rep_ctr);\n-\t      write_character (dtp, rep_buff, 1, strlen (rep_buff));\n+\t      write_character (dtp, rep_buff, 1, strlen (rep_buff), NODELIM);\n \t      dtp->u.p.no_leading_blank = 1;\n \t    }\n \t  num++;\n@@ -1827,13 +1835,7 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n               break;\n \n \t    case BT_CHARACTER:\n-\t      tmp_delim = dtp->u.p.current_unit->delim_status;\n-\t      if (dtp->u.p.nml_delim == '\"')\n-\t\tdtp->u.p.current_unit->delim_status = DELIM_QUOTE;\n-\t      if (dtp->u.p.nml_delim == '\\'')\n-\t\tdtp->u.p.current_unit->delim_status = DELIM_APOSTROPHE;\n-\t      write_character (dtp, p, 1, obj->string_length);\n-\t\tdtp->u.p.current_unit->delim_status = tmp_delim;\n+\t      write_character (dtp, p, 1, obj->string_length, DELIM);\n               break;\n \n \t    case BT_REAL:\n@@ -1921,12 +1923,20 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n \t     to column 2. Reset the repeat counter.  */\n \n \t  dtp->u.p.no_leading_blank = 0;\n-\t  write_character (dtp, &semi_comma, 1, 1);\n+\t  if (obj->type == BT_CHARACTER)\n+\t    {\n+\t      if (dtp->u.p.nml_delim != '\\0')\n+\t\twrite_character (dtp, &semi_comma, 1, 1, NODELIM);\n+\t    }\n+\t  else\n+\t    write_character (dtp, &semi_comma, 1, 1, NODELIM);\n \t  if (num > 5)\n \t    {\n \t      num = 0;\n+\t      if (dtp->u.p.nml_delim == '\\0')\n+\t\twrite_character (dtp, &semi_comma, 1, 1, NODELIM);\n \t      namelist_write_newline (dtp);\n-\t      write_character (dtp, \" \", 1, 1);\n+\t      write_character (dtp, \" \", 1, 1, NODELIM);\n \t    }\n \t  rep_ctr = 1;\n \t}\n@@ -1935,17 +1945,17 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n \n obj_loop:\n \n-    nml_carry = 1;\n-    for (dim_i = 0; nml_carry && (dim_i < (size_t) obj->var_rank); dim_i++)\n-      {\n-\tobj->ls[dim_i].idx += nml_carry ;\n-\tnml_carry = 0;\n- \tif (obj->ls[dim_i].idx  > GFC_DESCRIPTOR_UBOUND(obj,dim_i))\n-\t  {\n- \t    obj->ls[dim_i].idx = GFC_DESCRIPTOR_LBOUND(obj,dim_i);\n-\t    nml_carry = 1;\n-\t  }\n-       }\n+      nml_carry = 1;\n+      for (dim_i = 0; nml_carry && (dim_i < (size_t) obj->var_rank); dim_i++)\n+\t{\n+\t  obj->ls[dim_i].idx += nml_carry ;\n+\t  nml_carry = 0;\n+\t  if (obj->ls[dim_i].idx  > GFC_DESCRIPTOR_UBOUND(obj,dim_i))\n+\t    {\n+\t      obj->ls[dim_i].idx = GFC_DESCRIPTOR_LBOUND(obj,dim_i);\n+\t      nml_carry = 1;\n+\t    }\n+\t }\n     }\n \n   /* Return a pointer beyond the furthest object accessed.  */\n@@ -1967,23 +1977,28 @@ namelist_write (st_parameter_dt *dtp)\n   index_type dummy_offset = 0;\n   char c;\n   char * dummy_name = NULL;\n-  unit_delim tmp_delim = DELIM_UNSPECIFIED;\n \n   /* Set the delimiter for namelist output.  */\n-  tmp_delim = dtp->u.p.current_unit->delim_status;\n-\n-  dtp->u.p.nml_delim = tmp_delim == DELIM_APOSTROPHE ? '\\'' : '\"';\n-\n-  /* Temporarily disable namelist delimters.  */\n-  dtp->u.p.current_unit->delim_status = DELIM_NONE;\n+  switch (dtp->u.p.current_unit->delim_status)\n+    {\n+      case DELIM_APOSTROPHE:\n+        dtp->u.p.nml_delim = '\\'';\n+\tbreak;\n+      case DELIM_QUOTE:\n+      case DELIM_UNSPECIFIED:\n+\tdtp->u.p.nml_delim = '\"';\n+\tbreak;\n+      default:\n+\tdtp->u.p.nml_delim = '\\0';\n+    }\n \n-  write_character (dtp, \"&\", 1, 1);\n+  write_character (dtp, \"&\", 1, 1, NODELIM);\n \n   /* Write namelist name in upper case - f95 std.  */\n   for (i = 0 ;i < dtp->namelist_name_len ;i++ )\n     {\n       c = toupper ((int) dtp->namelist_name[i]);\n-      write_character (dtp, &c, 1 ,1);\n+      write_character (dtp, &c, 1 ,1, NODELIM);\n     }\n \n   if (dtp->u.p.ionml != NULL)\n@@ -1997,9 +2012,7 @@ namelist_write (st_parameter_dt *dtp)\n     }\n \n   namelist_write_newline (dtp);\n-  write_character (dtp, \" /\", 1, 2);\n-  /* Restore the original delimiter.  */\n-  dtp->u.p.current_unit->delim_status = tmp_delim;\n+  write_character (dtp, \" /\", 1, 2, NODELIM);\n }\n \n #undef NML_DIGITS"}]}