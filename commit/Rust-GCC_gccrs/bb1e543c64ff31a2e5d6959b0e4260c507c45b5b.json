{"sha": "bb1e543c64ff31a2e5d6959b0e4260c507c45b5b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmIxZTU0M2M2NGZmMzFhMmU1ZDY5NTliMGU0MjYwYzUwN2M0NWI1Yg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-01-20T19:48:59Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-01-20T19:48:59Z"}, "message": "re PR lto/45375 ([meta-bug] Issues with building Mozilla (i.e. Firefox) with LTO)\n\n\n\tPR lto/45375\n\t* ipa-inline.c: Include lto-streamer.h\n\t(report_inline_failed_reason): Output source file differences and\n\tflags on optimization/target node mismatch.\n\t(can_inline_edge_p): Consider caller to be the outer inline function;\n\tbe less restrictive about matching opimize and optimize_size attributes.\n\t(inline_account_function_p): Break out from ...\n\t(inline_small_functions): ... here.\n\t* ipa-inline-transform.c (clone_inlined_nodes): Use\n\tinline_account_function_p.\n\t(inline_call): Use optimize attribution; use inline_account_function_p.\n\t(inline_transform): Use opt_for_fn.\n\t* ipa-inline.h (inline_account_function_p): Declare.\n\nFrom-SVN: r219909", "tree": {"sha": "6e5c86ba08bd55d166385c9730c5ac85ac9810d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e5c86ba08bd55d166385c9730c5ac85ac9810d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb1e543c64ff31a2e5d6959b0e4260c507c45b5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb1e543c64ff31a2e5d6959b0e4260c507c45b5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb1e543c64ff31a2e5d6959b0e4260c507c45b5b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb1e543c64ff31a2e5d6959b0e4260c507c45b5b/comments", "author": null, "committer": null, "parents": [{"sha": "17cb42833c207240918de8279e171c834093565a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17cb42833c207240918de8279e171c834093565a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17cb42833c207240918de8279e171c834093565a"}], "stats": {"total": 146, "additions": 119, "deletions": 27}, "files": [{"sha": "7b063f3cce2e10a71e2796e017f49dba05e0a273", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb1e543c64ff31a2e5d6959b0e4260c507c45b5b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb1e543c64ff31a2e5d6959b0e4260c507c45b5b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bb1e543c64ff31a2e5d6959b0e4260c507c45b5b", "patch": "@@ -1,3 +1,19 @@\n+2015-01-19  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR lto/45375\n+\t* ipa-inline.c: Include lto-streamer.h\n+\t(report_inline_failed_reason): Output source file differences and\n+\tflags on optimization/target node mismatch.\n+\t(can_inline_edge_p): Consider caller to be the outer inline function;\n+\tbe less restrictive about matching opimize and optimize_size attributes.\n+\t(inline_account_function_p): Break out from ...\n+\t(inline_small_functions): ... here.\n+\t* ipa-inline-transform.c (clone_inlined_nodes): Use\n+\tinline_account_function_p.\n+\t(inline_call): Use optimize attribution; use inline_account_function_p.\n+\t(inline_transform): Use opt_for_fn.\n+\t* ipa-inline.h (inline_account_function_p): Declare.\n+\n 2015-01-20  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/64663"}, {"sha": "235219dd82e4bd49d5d7ff38f4fc23f81bb6ff7a", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb1e543c64ff31a2e5d6959b0e4260c507c45b5b/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb1e543c64ff31a2e5d6959b0e4260c507c45b5b/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=bb1e543c64ff31a2e5d6959b0e4260c507c45b5b", "patch": "@@ -214,8 +214,10 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t     cgraph_remove_unreachable_functions gets rid of them.  */\n \t  gcc_assert (!e->callee->global.inlined_to);\n \t  e->callee->dissolve_same_comdat_group_list ();\n-\t  if (e->callee->definition && !DECL_EXTERNAL (e->callee->decl))\n+\t  if (e->callee->definition\n+\t      && inline_account_function_p (e->callee))\n \t    {\n+\t      gcc_assert (!e->callee->alias);\n \t      if (overall_size)\n \t        *overall_size -= inline_summaries->get (e->callee)->size;\n \t      nfunctions_inlined++;\n@@ -330,7 +332,7 @@ inline_call (struct cgraph_edge *e, bool update_original,\n \n   old_size = inline_summaries->get (to)->size;\n   inline_merge_summary (e);\n-  if (optimize)\n+  if (opt_for_fn (e->caller->decl, optimize))\n     new_edges_found = ipa_propagate_indirect_call_infos (curr, new_edges);\n   if (update_overall_summary)\n    inline_update_overall_summary (to);\n@@ -361,8 +363,7 @@ inline_call (struct cgraph_edge *e, bool update_original,\n \n   /* Account the change of overall unit size; external functions will be\n      removed and are thus not accounted.  */\n-  if (overall_size\n-      && !DECL_EXTERNAL (to->decl))\n+  if (overall_size && inline_account_function_p (to))\n     *overall_size += new_size - old_size;\n   ncalls_inlined++;\n \n@@ -509,7 +510,7 @@ inline_transform (struct cgraph_node *node)\n   node->remove_all_references ();\n \n   timevar_push (TV_INTEGRATION);\n-  if (node->callees && (optimize || has_inline))\n+  if (node->callees && (opt_for_fn (node->decl, optimize) || has_inline))\n     todo = optimize_inline_calls (current_function_decl);\n   timevar_pop (TV_INTEGRATION);\n "}, {"sha": "c0ff329ef0974e86a6da370de3041bbc48593e6d", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 95, "deletions": 22, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb1e543c64ff31a2e5d6959b0e4260c507c45b5b/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb1e543c64ff31a2e5d6959b0e4260c507c45b5b/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=bb1e543c64ff31a2e5d6959b0e4260c507c45b5b", "patch": "@@ -145,6 +145,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cilk.h\"\n #include \"builtins.h\"\n #include \"fibonacci_heap.h\"\n+#include \"lto-streamer.h\"\n \n typedef fibonacci_heap <sreal, cgraph_edge> edge_heap_t;\n typedef fibonacci_node <sreal, cgraph_edge> edge_heap_node_t;\n@@ -260,6 +261,23 @@ report_inline_failed_reason (struct cgraph_edge *e)\n \t       xstrdup_for_dump (e->caller->name ()), e->caller->order,\n \t       xstrdup_for_dump (e->callee->name ()), e->callee->order,\n \t       cgraph_inline_failed_string (e->inline_failed));\n+      if ((e->inline_failed == CIF_TARGET_OPTION_MISMATCH\n+\t   || e->inline_failed == CIF_OPTIMIZATION_MISMATCH)\n+\t  && e->caller->lto_file_data\n+\t  && e->callee->function_symbol ()->lto_file_data)\n+\t{\n+\t  fprintf (dump_file, \"  LTO objects: %s, %s\\n\",\n+\t\t   e->caller->lto_file_data->file_name,\n+\t\t   e->callee->function_symbol ()->lto_file_data->file_name);\n+\t}\n+      if (e->inline_failed == CIF_TARGET_OPTION_MISMATCH)\n+\tcl_target_option_print_diff\n+\t (dump_file, 2, target_opts_for_fn (e->caller->decl),\n+          target_opts_for_fn (e->callee->ultimate_alias_target ()->decl));\n+      if (e->inline_failed == CIF_OPTIMIZATION_MISMATCH)\n+\tcl_optimization_print_diff\n+\t  (dump_file, 2, opts_for_fn (e->caller->decl),\n+\t   opts_for_fn (e->callee->ultimate_alias_target ()->decl));\n     }\n }\n \n@@ -297,10 +315,12 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n   bool inlinable = true;\n   enum availability avail;\n   cgraph_node *callee = e->callee->ultimate_alias_target (&avail);\n-  tree caller_tree = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (e->caller->decl);\n+  cgraph_node *caller = e->caller->global.inlined_to\n+\t\t        ? e->caller->global.inlined_to : e->caller;\n+  tree caller_tree = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (caller->decl);\n   tree callee_tree\n     = callee ? DECL_FUNCTION_SPECIFIC_OPTIMIZATION (callee->decl) : NULL;\n-  struct function *caller_fun = e->caller->get_fun ();\n+  struct function *caller_fun = caller->get_fun ();\n   struct function *callee_fun = callee ? callee->get_fun () : NULL;\n \n   gcc_assert (e->inline_failed);\n@@ -333,9 +353,9 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n       inlinable = false;\n     }\n   /* Don't inline if the functions have different EH personalities.  */\n-  else if (DECL_FUNCTION_PERSONALITY (e->caller->decl)\n+  else if (DECL_FUNCTION_PERSONALITY (caller->decl)\n \t   && DECL_FUNCTION_PERSONALITY (callee->decl)\n-\t   && (DECL_FUNCTION_PERSONALITY (e->caller->decl)\n+\t   && (DECL_FUNCTION_PERSONALITY (caller->decl)\n \t       != DECL_FUNCTION_PERSONALITY (callee->decl)))\n     {\n       e->inline_failed = CIF_EH_PERSONALITY;\n@@ -344,7 +364,7 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n   /* TM pure functions should not be inlined into non-TM_pure\n      functions.  */\n   else if (is_tm_pure (callee->decl)\n-\t   && !is_tm_pure (e->caller->decl))\n+\t   && !is_tm_pure (caller->decl))\n     {\n       e->inline_failed = CIF_UNSPECIFIED;\n       inlinable = false;\n@@ -360,14 +380,14 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n       inlinable = false;\n     }\n   /* Check compatibility of target optimization options.  */\n-  else if (!targetm.target_option.can_inline_p (e->caller->decl,\n+  else if (!targetm.target_option.can_inline_p (caller->decl,\n \t\t\t\t\t\tcallee->decl))\n     {\n       e->inline_failed = CIF_TARGET_OPTION_MISMATCH;\n       inlinable = false;\n     }\n   /* Don't inline a function with mismatched sanitization attributes. */\n-  else if (!sanitize_attrs_match_for_inline_p (e->caller->decl, callee->decl))\n+  else if (!sanitize_attrs_match_for_inline_p (caller->decl, callee->decl))\n     {\n       e->inline_failed = CIF_ATTRIBUTE_MISMATCH;\n       inlinable = false;\n@@ -376,27 +396,70 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n   else if (!DECL_DISREGARD_INLINE_LIMITS (callee->decl)\n \t   && !disregard_limits\n \t   && !lookup_attribute (\"flatten\",\n-\t\t\t\t DECL_ATTRIBUTES\n-\t\t\t\t   (e->caller->global.inlined_to\n-\t\t\t\t    ? e->caller->global.inlined_to->decl\n-\t\t\t\t    : e->caller->decl))\n+\t\t\t\t DECL_ATTRIBUTES (caller->decl))\n            && !caller_growth_limits (e))\n     inlinable = false;\n   /* Don't inline a function with a higher optimization level than the\n      caller.  FIXME: this is really just tip of iceberg of handling\n      optimization attribute.  */\n   else if (caller_tree != callee_tree)\n     {\n-      if (((opt_for_fn (e->caller->decl, optimize)\n-\t    > opt_for_fn (callee->decl, optimize))\n-\t    || (opt_for_fn (e->caller->decl, optimize_size)\n-\t\t!= opt_for_fn (callee->decl, optimize_size)))\n-\t  /* gcc.dg/pr43564.c.  Look at forced inline even in -O0.  */\n-\t  && !DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n+      /* gcc.dg/pr43564.c.  Look at forced inline even in -O0.  */\n+      if (DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n+\t;\n+      /* When user added an attribute, honnor it.  */\n+      else if ((lookup_attribute (\"optimize\", DECL_ATTRIBUTES (caller->decl))\n+\t\t|| lookup_attribute (\"optimize\",\n+\t\t\t\t     DECL_ATTRIBUTES (callee->decl)))\n+\t       && ((opt_for_fn (caller->decl, optimize)\n+\t\t   > opt_for_fn (callee->decl, optimize))\n+\t\t   || (opt_for_fn (caller->decl, optimize_size)\n+\t\t       != opt_for_fn (callee->decl, optimize_size))))\n \t{\n \t  e->inline_failed = CIF_OPTIMIZATION_MISMATCH;\n \t  inlinable = false;\n \t}\n+      /* If mismatch is caused by merging two LTO units with different\n+\t optimizationflags we want to be bit nicer.  However never inline\n+\t if one of functions is not optimized at all.  */\n+      else if (!opt_for_fn (callee->decl, optimize)\n+      \t       || !opt_for_fn (caller->decl, optimize))\n+\t{\n+\t  e->inline_failed = CIF_OPTIMIZATION_MISMATCH;\n+\t  inlinable = false;\n+\t}\n+      /* If callee is optimized for size and caller is not, allow inlining if\n+\t code shrinks or we are in MAX_INLINE_INSNS_SINGLE limit and callee\n+\t is inline (and thus likely an unified comdat).  This will allow caller\n+\t to run faster.  */\n+      else if (opt_for_fn (callee->decl, optimize_size)\n+\t       > opt_for_fn (caller->decl, optimize_size))\n+\t{\n+\t  int growth = estimate_edge_growth (e);\n+\t  if (growth > 0\n+\t      && (!DECL_DECLARED_INLINE_P (callee->decl)\n+\t\t  && growth >= MAX (MAX_INLINE_INSNS_SINGLE,\n+\t\t\t\t    MAX_INLINE_INSNS_AUTO)))\n+\t    {\n+\t      e->inline_failed = CIF_OPTIMIZATION_MISMATCH;\n+\t      inlinable = false;\n+\t    }\n+\t}\n+      /* If callee is more aggressively optimized for performance than caller,\n+\t we generally want to inline only cheap (runtime wise) functions.  */\n+      else if (opt_for_fn (callee->decl, optimize_size)\n+\t       < opt_for_fn (caller->decl, optimize_size)\n+\t       || (opt_for_fn (callee->decl, optimize)\n+\t\t   >= opt_for_fn (caller->decl, optimize)))\n+\t{\n+\t  if (estimate_edge_time (e)\n+\t      >= 20 + inline_edge_summary (e)->call_stmt_time)\n+\t    {\n+\t      e->inline_failed = CIF_OPTIMIZATION_MISMATCH;\n+\t      inlinable = false;\n+\t    }\n+\t}\n+\n     }\n \n   if (!inlinable && report)\n@@ -1507,6 +1570,18 @@ resolve_noninline_speculation (edge_heap_t *edge_heap, struct cgraph_edge *edge)\n     }\n }\n \n+/* Return true if NODE should be accounted for overall size estimate.\n+   Skip all nodes optimized for size so we can measure the growth of hot\n+   part of program no matter of the padding.  */\n+\n+bool\n+inline_account_function_p (struct cgraph_node *node)\n+{\n+   return (!DECL_EXTERNAL (node->decl)\n+\t   && !opt_for_fn (node->decl, optimize_size)\n+\t   && node->frequency != NODE_FREQUENCY_UNLIKELY_EXECUTED);\n+}\n+\n /* We use greedy algorithm for inlining of small functions:\n    All inline candidates are put into prioritized heap ordered in\n    increasing badness.\n@@ -1540,17 +1615,15 @@ inline_small_functions (void)\n   FOR_EACH_DEFINED_FUNCTION (node)\n     if (!node->global.inlined_to)\n       {\n-\tif (node->has_gimple_body_p ()\n-\t    || node->thunk.thunk_p)\n+\tif (!node->alias && node->analyzed\n+\t    && (node->has_gimple_body_p () || node->thunk.thunk_p))\n \t  {\n \t    struct inline_summary *info = inline_summaries->get (node);\n \t    struct ipa_dfs_info *dfs = (struct ipa_dfs_info *) node->aux;\n \n \t    /* Do not account external functions, they will be optimized out\n \t       if not inlined.  Also only count the non-cold portion of program.  */\n-\t    if (!DECL_EXTERNAL (node->decl)\n-\t\t&& !opt_for_fn (node->decl, optimize_size)\n-\t\t&& node->frequency != NODE_FREQUENCY_UNLIKELY_EXECUTED)\n+\t    if (inline_account_function_p (node))\n \t      initial_size += info->size;\n \t    info->growth = estimate_growth (node);\n \t    if (dfs && dfs->next_cycle)"}, {"sha": "dfc0053838ef356c2dca0f732c43b4f5336c20d2", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb1e543c64ff31a2e5d6959b0e4260c507c45b5b/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb1e543c64ff31a2e5d6959b0e4260c507c45b5b/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=bb1e543c64ff31a2e5d6959b0e4260c507c45b5b", "patch": "@@ -256,6 +256,8 @@ void free_growth_caches (void);\n void compute_inline_parameters (struct cgraph_node *, bool);\n bool speculation_useful_p (struct cgraph_edge *e, bool anticipate_inlining);\n unsigned int early_inliner (function *fun);\n+bool inline_account_function_p (struct cgraph_node *node);\n+\n \n /* In ipa-inline-transform.c  */\n bool inline_call (struct cgraph_edge *, bool, vec<cgraph_edge *> *, int *, bool,"}]}