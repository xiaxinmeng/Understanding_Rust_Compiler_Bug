{"sha": "52ed68f71a750260fd926479e41e3f7ad7cd9aa2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJlZDY4ZjcxYTc1MDI2MGZkOTI2NDc5ZTQxZTNmN2FkN2NkOWFhMg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2016-07-20T18:42:11Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2016-07-20T18:42:11Z"}, "message": "C++ FE: handle misspelled identifiers and typenames\n\ngcc/cp/ChangeLog:\n\tPR c/70339\n\tPR c/71858\n\t* name-lookup.c: Include gcc-rich-location.h, spellcheck-tree.h,\n\tand parser.h.\n\t(suggest_alternatives_for): If no candidates are found, try\n\tlookup_name_fuzzy and report if if finds a suggestion.\n\t(consider_binding_level): New function.\n\t(lookup_name_fuzzy) New function.\n\t* parser.c: Include gcc-rich-location.h.\n\t(cp_lexer_next_token_is_decl_specifier_keyword): Move most of\n\tlogic into...\n\t(cp_keyword_starts_decl_specifier_p): ...this new function.\n\t(cp_parser_diagnose_invalid_type_name): When issuing\n\t\"does not name a type\" errors, attempt to make a suggestion using\n\tlookup_name_fuzzy.\n\t* parser.h (cp_keyword_starts_decl_specifier_p): New prototype.\n\t* search.c (lookup_field_fuzzy_info::fuzzy_lookup_field): Reject\n\ttypes that are not CLASS_TYPE_P, rather than rejecting individual\n\ttree codes.\n\ngcc/testsuite/ChangeLog:\n\tPR c/70339\n\tPR c/71858\n\t* g++.dg/spellcheck-identifiers.C: New test case, based on\n\tgcc.dg/spellcheck-identifiers.c.\n\t* g++.dg/spellcheck-identifiers-2.C: New test case, based on\n\tgcc.dg/spellcheck-identifiers-2.c.\n\t* g++.dg/spellcheck-typenames.C: New test case, based on\n\tgcc.dg/spellcheck-typenames.c\n\nFrom-SVN: r238538", "tree": {"sha": "b49c604effb64ec60ec0f92309badfd3781fc6c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b49c604effb64ec60ec0f92309badfd3781fc6c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52ed68f71a750260fd926479e41e3f7ad7cd9aa2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52ed68f71a750260fd926479e41e3f7ad7cd9aa2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52ed68f71a750260fd926479e41e3f7ad7cd9aa2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52ed68f71a750260fd926479e41e3f7ad7cd9aa2/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1397e163014843fa6803b3959adfc0011d75bc6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1397e163014843fa6803b3959adfc0011d75bc6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1397e163014843fa6803b3959adfc0011d75bc6a"}], "stats": {"total": 583, "additions": 563, "deletions": 20}, "files": [{"sha": "ab0446ba0777e0ded747e38157d9afec8548269c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ed68f71a750260fd926479e41e3f7ad7cd9aa2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ed68f71a750260fd926479e41e3f7ad7cd9aa2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=52ed68f71a750260fd926479e41e3f7ad7cd9aa2", "patch": "@@ -1,3 +1,25 @@\n+2016-07-20  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c/70339\n+\tPR c/71858\n+\t* name-lookup.c: Include gcc-rich-location.h, spellcheck-tree.h,\n+\tand parser.h.\n+\t(suggest_alternatives_for): If no candidates are found, try\n+\tlookup_name_fuzzy and report if if finds a suggestion.\n+\t(consider_binding_level): New function.\n+\t(lookup_name_fuzzy) New function.\n+\t* parser.c: Include gcc-rich-location.h.\n+\t(cp_lexer_next_token_is_decl_specifier_keyword): Move most of\n+\tlogic into...\n+\t(cp_keyword_starts_decl_specifier_p): ...this new function.\n+\t(cp_parser_diagnose_invalid_type_name): When issuing\n+\t\"does not name a type\" errors, attempt to make a suggestion using\n+\tlookup_name_fuzzy.\n+\t* parser.h (cp_keyword_starts_decl_specifier_p): New prototype.\n+\t* search.c (lookup_field_fuzzy_info::fuzzy_lookup_field): Reject\n+\ttypes that are not CLASS_TYPE_P, rather than rejecting individual\n+\ttree codes.\n+\n 2016-07-20  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/71909"}, {"sha": "7c3942a52934b03d76a1afea27d25a5cd323efb5", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 114, "deletions": 2, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ed68f71a750260fd926479e41e3f7ad7cd9aa2/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ed68f71a750260fd926479e41e3f7ad7cd9aa2/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=52ed68f71a750260fd926479e41e3f7ad7cd9aa2", "patch": "@@ -29,6 +29,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"debug.h\"\n #include \"c-family/c-pragma.h\"\n #include \"params.h\"\n+#include \"gcc-rich-location.h\"\n+#include \"spellcheck-tree.h\"\n+#include \"parser.h\"\n \n /* The bindings for a particular name in a particular scope.  */\n \n@@ -4435,9 +4438,20 @@ suggest_alternatives_for (location_t location, tree name)\n \n   namespaces_to_search.release ();\n \n-  /* Nothing useful to report.  */\n+  /* Nothing useful to report for NAME.  Report on likely misspellings,\n+     or do nothing.  */\n   if (candidates.is_empty ())\n-    return;\n+    {\n+      const char *fuzzy_name = lookup_name_fuzzy (name, FUZZY_LOOKUP_NAME);\n+      if (fuzzy_name)\n+\t{\n+\t  gcc_rich_location richloc (location);\n+\t  richloc.add_fixit_misspelled_id (location, fuzzy_name);\n+\t  inform_at_rich_loc (&richloc, \"suggested alternative: %qs\",\n+\t\t\t      fuzzy_name);\n+\t}\n+      return;\n+    }\n \n   inform_n (location, candidates.length (),\n \t    \"suggested alternative:\",\n@@ -4672,6 +4686,104 @@ qualified_lookup_using_namespace (tree name, tree scope,\n   return result->value != error_mark_node;\n }\n \n+/* Helper function for lookup_name_fuzzy.\n+   Traverse binding level LVL, looking for good name matches for NAME\n+   (and BM).  */\n+static void\n+consider_binding_level (tree name, best_match <tree, tree> &bm,\n+\t\t\tcp_binding_level *lvl, bool look_within_fields,\n+\t\t\tenum lookup_name_fuzzy_kind kind)\n+{\n+  if (look_within_fields)\n+    if (lvl->this_entity && TREE_CODE (lvl->this_entity) == RECORD_TYPE)\n+      {\n+\ttree type = lvl->this_entity;\n+\tbool want_type_p = (kind == FUZZY_LOOKUP_TYPENAME);\n+\ttree best_matching_field\n+\t  = lookup_member_fuzzy (type, name, want_type_p);\n+\tif (best_matching_field)\n+\t  bm.consider (best_matching_field);\n+      }\n+\n+  for (tree t = lvl->names; t; t = TREE_CHAIN (t))\n+    {\n+      /* Don't use bindings from implicitly declared functions,\n+\t as they were likely misspellings themselves.  */\n+      if (TREE_TYPE (t) == error_mark_node)\n+\tcontinue;\n+\n+      /* Skip anticipated decls of builtin functions.  */\n+      if (TREE_CODE (t) == FUNCTION_DECL\n+\t  && DECL_BUILT_IN (t)\n+\t  && DECL_ANTICIPATED (t))\n+\tcontinue;\n+\n+      if (DECL_NAME (t))\n+\tbm.consider (DECL_NAME (t));\n+    }\n+}\n+\n+/* Search for near-matches for NAME within the current bindings, and within\n+   macro names, returning the best match as a const char *, or NULL if\n+   no reasonable match is found.  */\n+\n+const char *\n+lookup_name_fuzzy (tree name, enum lookup_name_fuzzy_kind kind)\n+{\n+  gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n+\n+  best_match <tree, tree> bm (name);\n+\n+  cp_binding_level *lvl;\n+  for (lvl = scope_chain->class_bindings; lvl; lvl = lvl->level_chain)\n+    consider_binding_level (name, bm, lvl, true, kind);\n+\n+  for (lvl = current_binding_level; lvl; lvl = lvl->level_chain)\n+    consider_binding_level (name, bm, lvl, false, kind);\n+\n+  /* Consider macros: if the user misspelled a macro name e.g. \"SOME_MACRO\"\n+     as:\n+       x = SOME_OTHER_MACRO (y);\n+     then \"SOME_OTHER_MACRO\" will survive to the frontend and show up\n+     as a misspelled identifier.\n+\n+     Use the best distance so far so that a candidate is only set if\n+     a macro is better than anything so far.  This allows early rejection\n+     (without calculating the edit distance) of macro names that must have\n+     distance >= bm.get_best_distance (), and means that we only get a\n+     non-NULL result for best_macro_match if it's better than any of\n+     the identifiers already checked.  */\n+  best_macro_match bmm (name, bm.get_best_distance (), parse_in);\n+  cpp_hashnode *best_macro = bmm.get_best_meaningful_candidate ();\n+  /* If a macro is the closest so far to NAME, suggest it.  */\n+  if (best_macro)\n+    return (const char *)best_macro->ident.str;\n+\n+  /* Try the \"starts_decl_specifier_p\" keywords to detect\n+     \"singed\" vs \"signed\" typos.  */\n+  for (unsigned i = 0; i < num_c_common_reswords; i++)\n+    {\n+      const c_common_resword *resword = &c_common_reswords[i];\n+\n+      if (!cp_keyword_starts_decl_specifier_p (resword->rid))\n+\tcontinue;\n+\n+      tree resword_identifier = ridpointers [resword->rid];\n+      if (!resword_identifier)\n+\tcontinue;\n+      gcc_assert (TREE_CODE (resword_identifier) == IDENTIFIER_NODE);\n+      bm.consider (resword_identifier);\n+    }\n+\n+  /* See if we have a good suggesion for the user.  */\n+  tree best_id = bm.get_best_meaningful_candidate ();\n+  if (best_id)\n+    return IDENTIFIER_POINTER (best_id);\n+\n+  /* No meaningful suggestion available.  */\n+  return NULL;\n+}\n+\n /* Subroutine of outer_binding.\n \n    Returns TRUE if BINDING is a binding to a template parameter of"}, {"sha": "8fceaed02f24174aaa5311fda67b6e1667eeaf92", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ed68f71a750260fd926479e41e3f7ad7cd9aa2/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ed68f71a750260fd926479e41e3f7ad7cd9aa2/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=52ed68f71a750260fd926479e41e3f7ad7cd9aa2", "patch": "@@ -40,6 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"c-family/c-indentation.h\"\n #include \"context.h\"\n #include \"cp-cilkplus.h\"\n+#include \"gcc-rich-location.h\"\n \n \f\n /* The lexer.  */\n@@ -937,15 +938,12 @@ cp_lexer_next_token_is_not_keyword (cp_lexer* lexer, enum rid keyword)\n   return cp_lexer_peek_token (lexer)->keyword != keyword;\n }\n \n-/* Return true if the next token is a keyword for a decl-specifier.  */\n+/* Return true if KEYWORD can start a decl-specifier.  */\n \n-static bool\n-cp_lexer_next_token_is_decl_specifier_keyword (cp_lexer *lexer)\n+bool\n+cp_keyword_starts_decl_specifier_p (enum rid keyword)\n {\n-  cp_token *token;\n-\n-  token = cp_lexer_peek_token (lexer);\n-  switch (token->keyword) \n+  switch (keyword)\n     {\n       /* auto specifier: storage-class-specifier in C++,\n          simple-type-specifier in C++0x.  */\n@@ -985,14 +983,25 @@ cp_lexer_next_token_is_decl_specifier_keyword (cp_lexer *lexer)\n       return true;\n \n     default:\n-      if (token->keyword >= RID_FIRST_INT_N\n-\t  && token->keyword < RID_FIRST_INT_N + NUM_INT_N_ENTS\n-\t  && int_n_enabled_p[token->keyword - RID_FIRST_INT_N])\n+      if (keyword >= RID_FIRST_INT_N\n+\t  && keyword < RID_FIRST_INT_N + NUM_INT_N_ENTS\n+\t  && int_n_enabled_p[keyword - RID_FIRST_INT_N])\n \treturn true;\n       return false;\n     }\n }\n \n+/* Return true if the next token is a keyword for a decl-specifier.  */\n+\n+static bool\n+cp_lexer_next_token_is_decl_specifier_keyword (cp_lexer *lexer)\n+{\n+  cp_token *token;\n+\n+  token = cp_lexer_peek_token (lexer);\n+  return cp_keyword_starts_decl_specifier_p (token->keyword);\n+}\n+\n /* Returns TRUE iff the token T begins a decltype type.  */\n \n static bool\n@@ -3154,7 +3163,19 @@ cp_parser_diagnose_invalid_type_name (cp_parser *parser, tree id,\n   else if (!parser->scope)\n     {\n       /* Issue an error message.  */\n-      error_at (location, \"%qE does not name a type\", id);\n+      const char *suggestion = NULL;\n+      if (TREE_CODE (id) == IDENTIFIER_NODE)\n+        suggestion = lookup_name_fuzzy (id, FUZZY_LOOKUP_TYPENAME);\n+      if (suggestion)\n+\t{\n+\t  gcc_rich_location richloc (location);\n+\t  richloc.add_fixit_misspelled_id (location, suggestion);\n+\t  error_at_rich_loc (&richloc,\n+\t\t\t     \"%qE does not name a type; did you mean %qs?\",\n+\t\t\t     id, suggestion);\n+\t}\n+      else\n+\terror_at (location, \"%qE does not name a type\", id);\n       /* If we're in a template class, it's possible that the user was\n \t referring to a type from a base class.  For example:\n "}, {"sha": "292337864bc9313107236e340910d54324ebff5b", "filename": "gcc/cp/parser.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ed68f71a750260fd926479e41e3f7ad7cd9aa2/gcc%2Fcp%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ed68f71a750260fd926479e41e3f7ad7cd9aa2/gcc%2Fcp%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.h?ref=52ed68f71a750260fd926479e41e3f7ad7cd9aa2", "patch": "@@ -420,5 +420,6 @@ extern void debug (vec<cp_token, va_gc> *ptr);\n extern void cp_debug_parser (FILE *, cp_parser *);\n extern void debug (cp_parser &ref);\n extern void debug (cp_parser *ptr);\n+extern bool cp_keyword_starts_decl_specifier_p (enum rid keyword);\n \n #endif  /* GCC_CP_PARSER_H  */"}, {"sha": "8b5f3293b12e1d2632fa5c8587f367393e211ede", "filename": "gcc/cp/search.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ed68f71a750260fd926479e41e3f7ad7cd9aa2/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ed68f71a750260fd926479e41e3f7ad7cd9aa2/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=52ed68f71a750260fd926479e41e3f7ad7cd9aa2", "patch": "@@ -1398,13 +1398,7 @@ lookup_field_fuzzy_info::fuzzy_lookup_fnfields (tree type)\n void\n lookup_field_fuzzy_info::fuzzy_lookup_field (tree type)\n {\n-  if (TREE_CODE (type) == TEMPLATE_TYPE_PARM\n-      || TREE_CODE (type) == BOUND_TEMPLATE_TEMPLATE_PARM\n-      || TREE_CODE (type) == TYPENAME_TYPE)\n-    /* The TYPE_FIELDS of a TEMPLATE_TYPE_PARM and\n-       BOUND_TEMPLATE_TEMPLATE_PARM are not fields at all;\n-       instead TYPE_FIELDS is the TEMPLATE_PARM_INDEX.\n-       The TYPE_FIELDS of TYPENAME_TYPE is its TYPENAME_TYPE_FULLNAME.  */\n+  if (!CLASS_TYPE_P (type))\n     return;\n \n   for (tree field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))"}, {"sha": "004cb5881f5df8227fde4f0a5f483de39a5d3aa3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ed68f71a750260fd926479e41e3f7ad7cd9aa2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ed68f71a750260fd926479e41e3f7ad7cd9aa2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=52ed68f71a750260fd926479e41e3f7ad7cd9aa2", "patch": "@@ -1,3 +1,14 @@\n+2016-07-20  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c/70339\n+\tPR c/71858\n+\t* g++.dg/spellcheck-identifiers.C: New test case, based on\n+\tgcc.dg/spellcheck-identifiers.c.\n+\t* g++.dg/spellcheck-identifiers-2.C: New test case, based on\n+\tgcc.dg/spellcheck-identifiers-2.c.\n+\t* g++.dg/spellcheck-typenames.C: New test case, based on\n+\tgcc.dg/spellcheck-typenames.c\n+\n 2016-07-20  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* g++.dg/cpp0x/nullptr35.C: Change expected result for catching as"}, {"sha": "59a8ec55c61e6c9dd02c72dcdea23f85ad06c3c9", "filename": "gcc/testsuite/g++.dg/spellcheck-identifiers-2.C", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ed68f71a750260fd926479e41e3f7ad7cd9aa2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fspellcheck-identifiers-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ed68f71a750260fd926479e41e3f7ad7cd9aa2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fspellcheck-identifiers-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fspellcheck-identifiers-2.C?ref=52ed68f71a750260fd926479e41e3f7ad7cd9aa2", "patch": "@@ -0,0 +1,43 @@\n+/* PR c/71858 */\n+/* Make sure anticipated builtins are not considered before they are declared.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-fdiagnostics-show-caret\" } */\n+\n+int sscafn (const char *, const char *, ...);\n+\n+int\n+test_1 (const char *p)\n+{\n+  int i;\n+  return ssacnf (p, \"%d\", &i); /* { dg-error \"10: .ssacnf. was not declared in this scope\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+   return ssacnf (p, \"%d\", &i);\n+          ^~~~~~\n+   { dg-end-multiline-output \"\" } */\n+  // { dg-message \"10: suggested alternative: 'sscafn'\" \"\" { target *-*-* } 12 }\n+  /* { dg-begin-multiline-output \"\" }\n+   return ssacnf (p, \"%d\", &i);\n+          ^~~~~~\n+          sscafn\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+int scafn (const char *, ...);\n+int scanf (const char *, ...);\n+\n+int\n+test_2 (void)\n+{\n+  int i;\n+  return sacnf (\"%d\", &i); /* { dg-error \"10: .sacnf. was not declared in this scope\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+   return sacnf (\"%d\", &i);\n+          ^~~~~\n+   { dg-end-multiline-output \"\" } */\n+  // { dg-message \"10: suggested alternative: 'scanf'\" \"\" { target *-*-* } 32 }\n+  /* { dg-begin-multiline-output \"\" }\n+   return sacnf (\"%d\", &i);\n+          ^~~~~\n+          scanf\n+   { dg-end-multiline-output \"\" } */\n+}"}, {"sha": "08434399e6f42939bffd6d4dad6274df65ee4a3e", "filename": "gcc/testsuite/g++.dg/spellcheck-identifiers.C", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ed68f71a750260fd926479e41e3f7ad7cd9aa2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fspellcheck-identifiers.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ed68f71a750260fd926479e41e3f7ad7cd9aa2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fspellcheck-identifiers.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fspellcheck-identifiers.C?ref=52ed68f71a750260fd926479e41e3f7ad7cd9aa2", "patch": "@@ -0,0 +1,255 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdiagnostics-show-caret\" } */\n+\n+typedef struct GtkWidget { int dummy; } GtkWidget;\n+\n+extern void gtk_widget_show_all (GtkWidget *w);\n+\n+\n+void\n+test_1 (GtkWidget *w)\n+{\n+  gtk_widget_showall (w); // { dg-error \"3: 'gtk_widget_showall' was not declared in this scope\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   gtk_widget_showall (w);\n+   ^~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+  // { dg-message \"3: suggested alternative: 'gtk_widget_show_all'\" \"\" { target *-*-* } 12 }\n+  /* { dg-begin-multiline-output \"\" }\n+   gtk_widget_showall (w);\n+   ^~~~~~~~~~~~~~~~~~\n+   gtk_widget_show_all\n+   { dg-end-multiline-output \"\" } */\n+\n+  /* Ensure we don't try to suggest \"gtk_widget_showall\" for subsequent\n+     corrections.  */\n+  gtk_widget_showall_ (w); // { dg-error \"3: 'gtk_widget_showall_' was not declared in this scope\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   gtk_widget_showall_ (w);\n+   ^~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+  // { dg-message \"3: suggested alternative: 'gtk_widget_show_all'\" \"\" { target *-*-* } 26 }\n+  /* { dg-begin-multiline-output \"\" }\n+   gtk_widget_showall_ (w);\n+   ^~~~~~~~~~~~~~~~~~~\n+   gtk_widget_show_all\n+   { dg-end-multiline-output \"\" } */\n+\n+  GtkWidgetShowAll (w); // { dg-error \"3: 'GtkWidgetShowAll' was not declared in this scope\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   GtkWidgetShowAll (w);\n+   ^~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+  // { dg-message \"3: suggested alternative: 'gtk_widget_show_all'\" \"\" { target *-*-* } 38 }\n+  /* { dg-begin-multiline-output \"\" }\n+   GtkWidgetShowAll (w);\n+   ^~~~~~~~~~~~~~~~\n+   gtk_widget_show_all\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+int\n+test_2 (int param)\n+{\n+  return parma * parma; // { dg-error \"10: 'parma' was not declared in this scope\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   return parma * parma;\n+          ^~~~~\n+   { dg-end-multiline-output \"\" } */\n+  // { dg-message \"10: suggested alternative: 'param'\" \"\" { target *-*-* } 54 }\n+  /* { dg-begin-multiline-output \"\" }\n+   return parma * parma;\n+          ^~~~~\n+          param\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+#define MACRO(X) ((X))\n+\n+int\n+test_3 (int i)\n+{\n+  return MACRAME (i); // { dg-error \"10: 'MACRAME' was not declared in this scope\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   return MACRAME (i);\n+          ^~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+  // { dg-message \"10: suggested alternative: 'MACRO'\" \"\" { target *-*-* } 72 }\n+  /* { dg-begin-multiline-output \"\" }\n+   return MACRAME (i);\n+          ^~~~~~~\n+          MACRO\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+#define IDENTIFIER_POINTER(X) ((X))\n+\n+int\n+test_4 (int node)\n+{\n+  return IDENTIFIER_PTR (node); // { dg-error \"10: 'IDENTIFIER_PTR' was not declared in this scope\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   return IDENTIFIER_PTR (node);\n+          ^~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+  // { dg-message \"10: suggested alternative: 'IDENTIFIER_POINTER'\" \"\" { target *-*-* } 90 }\n+  /* { dg-begin-multiline-output \"\" }\n+   return IDENTIFIER_PTR (node);\n+          ^~~~~~~~~~~~~~\n+          IDENTIFIER_POINTER\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+\n+int\n+test_5 (void)\n+{\n+  return __LINE_; /* { dg-error \"10: '__LINE_' was not declared in this scope\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   return __LINE_;\n+          ^~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+  // { dg-message \"10: suggested alternative: '__LINE__'\" \"\" { target *-*-* } 107 }\n+  /* { dg-begin-multiline-output \"\" }\n+   return __LINE_;\n+          ^~~~~~~\n+          __LINE__\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+#define MAX_ITEMS 100\n+int array[MAX_ITEM]; // { dg-error \"11: 'MAX_ITEM' was not declared in this scope\" }\n+  /* { dg-begin-multiline-output \"\" }\n+ int array[MAX_ITEM];\n+           ^~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+  // { dg-message \"11: suggested alternative: 'MAX_ITEMS'\" \"\" { target *-*-* } 121 }\n+  /* { dg-begin-multiline-output \"\" }\n+ int array[MAX_ITEM];\n+           ^~~~~~~~\n+           MAX_ITEMS\n+   { dg-end-multiline-output \"\" } */\n+\n+\n+enum foo {\n+  FOO_FIRST,\n+  FOO_SECOND\n+};\n+\n+int\n+test_6 (enum foo f)\n+{\n+  switch (f)\n+    {\n+    case FOO_FURST: // { dg-error \"10: 'FOO_FURST' was not declared in this scope\" }\n+      break;\n+  /* { dg-begin-multiline-output \"\" }\n+     case FOO_FURST:\n+          ^~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+  // { dg-message \"10: suggested alternative: 'FOO_FIRST'\" \"\" { target *-*-* } 144 }\n+  /* { dg-begin-multiline-output \"\" }\n+     case FOO_FURST:\n+          ^~~~~~~~~\n+          FOO_FIRST\n+   { dg-end-multiline-output \"\" } */\n+\n+    case FOO_SECCOND: // { dg-error \"10: 'FOO_SECCOND' was not declared in this scope\" }\n+      break;\n+  /* { dg-begin-multiline-output \"\" }\n+     case FOO_SECCOND:\n+          ^~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+  // { dg-message \"10: suggested alternative: 'FOO_SECOND'\" \"\" { target *-*-* } 157 }\n+  /* { dg-begin-multiline-output \"\" }\n+     case FOO_SECCOND:\n+          ^~~~~~~~~~~\n+          FOO_SECOND\n+   { dg-end-multiline-output \"\" } */\n+\n+    default:\n+      break;\n+    }\n+}\n+\n+int snprintf (char *, __SIZE_TYPE__, const char *, ...);\n+\n+void\n+test_7 (int i, int j)\n+{\n+  int buffer[100];\n+  snprint (buffer, 100, \"%i of %i\", i, j); // { dg-error \"3: 'snprint' was not declared in this scope\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   snprint (buffer, 100, \"%i of %i\", i, j);\n+   ^~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+  // { dg-message \"3: suggested alternative: 'snprintf'\" \"\" { target *-*-* } 181 }\n+  /* { dg-begin-multiline-output \"\" }\n+   snprint (buffer, 100, \"%i of %i\", i, j);\n+   ^~~~~~~\n+   snprintf\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+int\n+test_8 ()\n+{\n+  int local = 42;\n+  \n+  return locale; // { dg-error \"10: 'locale' was not declared in this scope\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   return locale;\n+          ^~~~~~\n+   { dg-end-multiline-output \"\" } */\n+  // { dg-message \"10: suggested alternative: 'local'\" \"\" { target *-*-* } 199 }\n+  /* { dg-begin-multiline-output \"\" }\n+   return locale;\n+          ^~~~~~\n+          local\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+class base\n+{\n+public:\n+  int test_method_1 ();\n+\n+protected:\n+  int m_foo;\n+};\n+\n+class sub : public base\n+{\n+public:\n+  int test_method_2 ();\n+};\n+\n+int base::test_method_1 ()\n+{\n+  return m_food; // { dg-error \"10: 'm_food' was not declared in this scope\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   return m_food;\n+          ^~~~~~\n+   { dg-end-multiline-output \"\" } */\n+  // { dg-message \"10: suggested alternative: 'm_foo'\" \"\" { target *-*-* } 229 }\n+  /* { dg-begin-multiline-output \"\" }\n+   return m_food;\n+          ^~~~~~\n+          m_foo\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+int sub::test_method_2 ()\n+{\n+  return m_food; // { dg-error \"10: 'm_food' was not declared in this scope\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   return m_food;\n+          ^~~~~~\n+   { dg-end-multiline-output \"\" } */\n+  // { dg-message \"10: suggested alternative: 'm_foo'\" \"\" { target *-*-* } 244 }\n+  /* { dg-begin-multiline-output \"\" }\n+   return m_food;\n+          ^~~~~~\n+          m_foo\n+   { dg-end-multiline-output \"\" } */\n+}"}, {"sha": "9aa5b72cc549a1349d79d8f9270c28ab12a03b0f", "filename": "gcc/testsuite/g++.dg/spellcheck-typenames.C", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ed68f71a750260fd926479e41e3f7ad7cd9aa2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fspellcheck-typenames.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ed68f71a750260fd926479e41e3f7ad7cd9aa2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fspellcheck-typenames.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fspellcheck-typenames.C?ref=52ed68f71a750260fd926479e41e3f7ad7cd9aa2", "patch": "@@ -0,0 +1,84 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdiagnostics-show-caret\" } */\n+\n+void test_1 (signed char e);\n+\n+/* PR c/70339.  */\n+void test_2 (singed char e); // { dg-error \"21: variable or field 'test_2' declared void\" }\n+/* { dg-begin-multiline-output \"\" }\n+ void test_2 (singed char e);\n+                     ^~~~\n+   { dg-end-multiline-output \"\" } */\n+// { dg-message \"14: 'singed' was not declared in this scope\" \"\" { target *-*-* } 7 }\n+/* { dg-begin-multiline-output \"\" }\n+ void test_2 (singed char e);\n+              ^~~~~~\n+   { dg-end-multiline-output \"\" } */\n+// { dg-message \"14: suggested alternative: 'signed'\" \"\" { target *-*-* } 7 }\n+/* { dg-begin-multiline-output \"\" }\n+ void test_2 (singed char e);\n+              ^~~~~~\n+              signed\n+   { dg-end-multiline-output \"\" } */\n+\n+void test_3 (car e); // { dg-error \"14: variable or field 'test_3' declared void\" }\n+/* { dg-begin-multiline-output \"\" }\n+ void test_3 (car e);\n+              ^~~\n+   { dg-end-multiline-output \"\" } */\n+// { dg-message \"14: 'car' was not declared in this scope\" \"\" { target *-*-* } 24 }\n+// { dg-message \"14: suggested alternative: 'char'\" \"\" { target *-*-* } 24 }\n+/* { dg-begin-multiline-output \"\" }\n+ void test_3 (car e);\n+              ^~~\n+              char\n+   { dg-end-multiline-output \"\" } */\n+\n+/* TODO: this one could be handled better.  */\n+void test_4 (signed car e); // { dg-error \"25: expected ',' or '...' before 'e'\" }\n+/* { dg-begin-multiline-output \"\" }\n+ void test_4 (signed car e);\n+                         ^\n+   { dg-end-multiline-output \"\" } */\n+\n+/* Verify that we handle misspelled typedef names.  */\n+\n+typedef struct something {} something_t;\n+\n+some_thing_t test_5; // { dg-error \"1: 'some_thing_t' does not name a type; did you mean 'something_t'?\" }\n+  /* { dg-begin-multiline-output \"\" }\n+ some_thing_t test_5;\n+ ^~~~~~~~~~~~\n+ something_t\n+   { dg-end-multiline-output \"\" } */\n+\n+/* TODO: we don't yet handle misspelled struct names.  */\n+struct some_thing test_6; // { dg-error \"aggregate 'some_thing test_6' has incomplete type and cannot be defined\" }\n+  /* { dg-begin-multiline-output \"\" }\n+ struct some_thing test_6;\n+                   ^~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+typedef long int64_t;\n+int64 i; // { dg-error \"1: 'int64' does not name a type; did you mean 'int64_t'?\" }\n+/* { dg-begin-multiline-output \"\" }\n+ int64 i;\n+ ^~~~~\n+ int64_t\n+   { dg-end-multiline-output \"\" } */\n+\n+/* Verify that gcc doesn't offer nonsensical suggestions.  */\n+\n+nonsensical_suggestion_t var; /* { dg-bogus \"did you mean\" } */\n+/* { dg-error \"'nonsensical_suggestion_t' does not name a type\" \"\" { target { *-*-* } } 72 } */\n+/* { dg-begin-multiline-output \"\" }\n+ nonsensical_suggestion_t var;\n+ ^~~~~~~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+singed char ch; // { dg-error \"1: 'singed' does not name a type; did you mean 'signed'?\" }\n+/* { dg-begin-multiline-output \"\" }\n+ singed char ch;\n+ ^~~~~~\n+ signed\n+   { dg-end-multiline-output \"\" } */"}]}