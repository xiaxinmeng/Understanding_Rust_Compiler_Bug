{"sha": "961192e1dd8305d932281fdc7efdc3276ad70e94", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTYxMTkyZTFkZDgzMDVkOTMyMjgxZmRjN2VmZGMzMjc2YWQ3MGU5NA==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@cam.ac.uk", "date": "2000-11-07T22:50:06Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2000-11-07T22:50:06Z"}, "message": "alias.c [...] (init_alias_analysis, [...]): Use memset () instead of bzero ().\n\n\t* alias.c (init_alias_analysis), calls.c (expand_call,\n\temit_library_call_value_1), combine.c (init_reg_last_arrays),\n\tcse.c (new_basic_block), dbxout.c (dbxout_type), diagnostic.c\n\t(init_output_buffer, set_diagnostic_context), dwarf2out.c\n\t(equate_decl_number_to_die, build_abbrev_table), emit-rtl.c\n\t(init_emit_once), fold-const.c (mul_double, div_and_round_double),\n\tfunction.c (assign_parms), gcse.c (compute_can_copy,\n\talloc_gcse_mem, alloc_reg_set_mem, record_one_set,\n\tcompute_hash_table, compute_set_hash_table,\n\tcompute_expr_hash_table), genattrtab.c (optimize_attrs), global.c\n\t(global_alloc, global_conflicts), haifa-sched.c (compute_trg_info,\n\tclear_units, schedule_block), integrate.c (initialize_for_inline,\n\texpand_inline_function), jump.c (thread_jumps), local-alloc.c\n\t(local_alloc), loop.c (combine_movables, count_loop_regs_set,\n\tload_mems_and_recount_loop_regs_set), print-tree.c (debug_tree),\n\tregclass.c (init_reg_sets, init_reg_sets_1, regclass,\n\trecord_reg_classes, allocate_reg_info), reload.c\n\t(get_secondary_mem, remove_address_replacements, find_reloads),\n\treload1.c (reload, set_initial_label_offsets, finish_spills,\n\treload_as_needed, choose_reload_regs_init,\n\treload_cse_simplify_operands), reorg.c (dbr_schedule), sbitmap.c\n\t(sbitmap_zero), simplify-rtx.c (simplify_plus_minus), ssa.c\n\t(rename_registers), stmt.c (expand_end_case), unroll.c\n\t(unroll_loop), varray.c (varray_grow), objc/objc-act.c: Use memset\n\t() instead of bzero ().\n\nch:\n\t* actions.c (check_missing_cases), typeck.c (build_chill_slice,\n\tbuild_chill_cast): Use memset () instead of bzero ().\n\ncp:\n\t* class.c (duplicate_tag_error, build_vtbl_initializer), decl.c\n\t(push_binding_level), error.c (cp_tree_printer), pt.c\n\t(process_partial_specialization, tsubst_template_arg_vector),\n\tsearch.c (lookup_member): Use memset () instead of bzero ().\n\njava:\n\t* expr.c (note_instructions), jcf-io.c (find_class), jcf-parse.c\n\t(init_outgoing_cpool), lex.c (java_init_lex): Use memset ()\n\tinstead of bzero ().\n\nFrom-SVN: r37303", "tree": {"sha": "179de27582e6da82f3f181cff6a30ad0be3b8ba0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/179de27582e6da82f3f181cff6a30ad0be3b8ba0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/961192e1dd8305d932281fdc7efdc3276ad70e94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/961192e1dd8305d932281fdc7efdc3276ad70e94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/961192e1dd8305d932281fdc7efdc3276ad70e94", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/961192e1dd8305d932281fdc7efdc3276ad70e94/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b13d6c243fe61b580f9bc62047d2e0ec88b8513", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b13d6c243fe61b580f9bc62047d2e0ec88b8513", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b13d6c243fe61b580f9bc62047d2e0ec88b8513"}], "stats": {"total": 288, "additions": 167, "deletions": 121}, "files": [{"sha": "4c2a7f89bb6d67d662295225de6709ce63988465", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -1,3 +1,31 @@\n+2000-11-07  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* alias.c (init_alias_analysis), calls.c (expand_call,\n+\temit_library_call_value_1), combine.c (init_reg_last_arrays),\n+\tcse.c (new_basic_block), dbxout.c (dbxout_type), diagnostic.c\n+\t(init_output_buffer, set_diagnostic_context), dwarf2out.c\n+\t(equate_decl_number_to_die, build_abbrev_table), emit-rtl.c\n+\t(init_emit_once), fold-const.c (mul_double, div_and_round_double),\n+\tfunction.c (assign_parms), gcse.c (compute_can_copy,\n+\talloc_gcse_mem, alloc_reg_set_mem, record_one_set,\n+\tcompute_hash_table, compute_set_hash_table,\n+\tcompute_expr_hash_table), genattrtab.c (optimize_attrs), global.c\n+\t(global_alloc, global_conflicts), haifa-sched.c (compute_trg_info,\n+\tclear_units, schedule_block), integrate.c (initialize_for_inline,\n+\texpand_inline_function), jump.c (thread_jumps), local-alloc.c\n+\t(local_alloc), loop.c (combine_movables, count_loop_regs_set,\n+\tload_mems_and_recount_loop_regs_set), print-tree.c (debug_tree),\n+\tregclass.c (init_reg_sets, init_reg_sets_1, regclass,\n+\trecord_reg_classes, allocate_reg_info), reload.c\n+\t(get_secondary_mem, remove_address_replacements, find_reloads),\n+\treload1.c (reload, set_initial_label_offsets, finish_spills,\n+\treload_as_needed, choose_reload_regs_init,\n+\treload_cse_simplify_operands), reorg.c (dbr_schedule), sbitmap.c\n+\t(sbitmap_zero), simplify-rtx.c (simplify_plus_minus), ssa.c\n+\t(rename_registers), stmt.c (expand_end_case), unroll.c\n+\t(unroll_loop), varray.c (varray_grow), objc/objc-act.c: Use memset\n+\t() instead of bzero ().\n+\n 2000-11-07  Neil Booth  <neilb@earthling.net>\n \n        * cp/lang-specs.h: Fix -save-temps specs under USE_CPPLIB."}, {"sha": "e9e30ee8744a7b5df8fde54c688815bf1658402f", "filename": "gcc/alias.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -2053,7 +2053,7 @@ init_alias_analysis ()\n       /* ??? Why are we realloc'ing if we're just going to zero it?  */\n       alias_invariant = (rtx *)xrealloc (alias_invariant,\n \t\t\t\t\t reg_base_value_size * sizeof (rtx));\n-      bzero ((char *)alias_invariant, reg_base_value_size * sizeof (rtx));\n+      memset ((char *)alias_invariant, 0, reg_base_value_size * sizeof (rtx));\n     }\n     \n \n@@ -2091,10 +2091,10 @@ init_alias_analysis ()\n       copying_arguments = 1;\n \n       /* Wipe the potential alias information clean for this pass.  */\n-      bzero ((char *) new_reg_base_value, reg_base_value_size * sizeof (rtx));\n+      memset ((char *) new_reg_base_value, 0, reg_base_value_size * sizeof (rtx));\n \n       /* Wipe the reg_seen array clean.  */\n-      bzero ((char *) reg_seen, reg_base_value_size);\n+      memset ((char *) reg_seen, 0, reg_base_value_size);\n \n       /* Mark all hard registers which may contain an address.\n \t The stack, frame and argument pointers may contain an address."}, {"sha": "ec0ad09666b8e8e51c7f71e50d8405caee697e39", "filename": "gcc/calls.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -2376,7 +2376,7 @@ expand_call (exp, target, ignore)\n \n   /* Make a vector to hold all the information about each arg.  */\n   args = (struct arg_data *) alloca (num_actuals * sizeof (struct arg_data));\n-  bzero ((char *) args, num_actuals * sizeof (struct arg_data));\n+  memset ((char *) args, 0, num_actuals * sizeof (struct arg_data));\n \n   /* Build up entries inthe ARGS array, compute the size of the arguments\n      into ARGS_SIZE, etc.  */\n@@ -2786,7 +2786,7 @@ expand_call (exp, target, ignore)\n \t\t\t   initial_highest_arg_in_use);\n \n \t\t  if (initial_highest_arg_in_use != highest_outgoing_arg_in_use)\n-\t\t    bzero (&stack_usage_map[initial_highest_arg_in_use],\n+\t\t    memset (&stack_usage_map[initial_highest_arg_in_use], 0,\n \t\t\t   (highest_outgoing_arg_in_use\n \t\t\t    - initial_highest_arg_in_use));\n \t\t  needed = 0;\n@@ -2875,7 +2875,7 @@ expand_call (exp, target, ignore)\n \t\t\t  /* Make a new map for the new argument list.  */\n \t\t\t  stack_usage_map = (char *)\n \t\t\t    alloca (highest_outgoing_arg_in_use);\n-\t\t\t  bzero (stack_usage_map, highest_outgoing_arg_in_use);\n+\t\t\t  memset (stack_usage_map, 0, highest_outgoing_arg_in_use);\n \t\t\t  highest_outgoing_arg_in_use = 0;\n \t\t\t}\n \t\t      allocate_dynamic_stack_space (push_size, NULL_RTX,\n@@ -3577,7 +3577,7 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n      library functions shouldn't have many args.  */\n \n   argvec = (struct arg *) alloca ((nargs + 1) * sizeof (struct arg));\n-  bzero ((char *) argvec, (nargs + 1) * sizeof (struct arg));\n+  memset ((char *) argvec, 0, (nargs + 1) * sizeof (struct arg));\n \n   INIT_CUMULATIVE_ARGS (args_so_far, NULL_TREE, fun, 0);\n \n@@ -3770,7 +3770,7 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n \t       initial_highest_arg_in_use);\n \n       if (initial_highest_arg_in_use != highest_outgoing_arg_in_use)\n-\tbzero (&stack_usage_map[initial_highest_arg_in_use],\n+\tmemset (&stack_usage_map[initial_highest_arg_in_use], 0,\n \t       highest_outgoing_arg_in_use - initial_highest_arg_in_use);\n       needed = 0;\n "}, {"sha": "c8d57666160d2d004db6b90881b3fc3f38134562", "filename": "gcc/ch/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fch%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fch%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2FChangeLog?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -1,3 +1,8 @@\n+2000-11-07  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* actions.c (check_missing_cases), typeck.c (build_chill_slice,\n+\tbuild_chill_cast): Use memset () instead of bzero ().\n+\n 2000-11-05  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* Make-lang.in (CHILL.distdir): Remove."}, {"sha": "09c8a5a23f7d50c45ed3f4100393962cce7a9cbc", "filename": "gcc/ch/actions.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fch%2Factions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fch%2Factions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Factions.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -1464,7 +1464,7 @@ check_missing_cases (type)\n     warning (\"too many cases to do CASE completeness testing\");\n   else\n     {\n-      bzero (cases_seen, bytes_needed);\n+      memset (cases_seen, 0, bytes_needed);\n       mark_seen_cases (type, cases_seen, size, is_sparse);\n       print_missing_cases (type, cases_seen, size);\n       free (cases_seen);"}, {"sha": "ef4a2e3bae6053369a492e85244f0dc246c41036", "filename": "gcc/ch/typeck.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fch%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fch%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Ftypeck.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -253,7 +253,7 @@ build_chill_slice (array, min_value, length)\n \t\t       * (tree_low_cst (min_value, 0)\n \t\t\t  - tree_low_cst (domain_min, 0)));\n \n-\t  bzero (buffer, type_size);\n+\t  memset (buffer, 0, type_size);\n \t  if (expand_constant_to_buffer (array, buffer, type_size))\n \t    {\n \t      result = extract_constant_from_buffer (slice_type,\n@@ -1193,7 +1193,7 @@ build_chill_cast (type, expr)\n     {\n       unsigned char *buffer = (unsigned char*) alloca (type_size);\n       tree value;\n-      bzero (buffer, type_size);\n+      memset (buffer, 0, type_size);\n       if (!expand_constant_to_buffer (expr, buffer, type_size))\n \t{\n \t  error (\"not implemented: constant conversion from that kind of expression\");"}, {"sha": "18c532238b6c353b98fa8dabb06cd8245e656db6", "filename": "gcc/combine.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -789,15 +789,15 @@ init_reg_last_arrays ()\n {\n   unsigned int nregs = combine_max_regno;\n \n-  bzero ((char *) reg_last_death, nregs * sizeof (rtx));\n-  bzero ((char *) reg_last_set, nregs * sizeof (rtx));\n-  bzero ((char *) reg_last_set_value, nregs * sizeof (rtx));\n-  bzero ((char *) reg_last_set_table_tick, nregs * sizeof (int));\n-  bzero ((char *) reg_last_set_label, nregs * sizeof (int));\n-  bzero (reg_last_set_invalid, nregs * sizeof (char));\n-  bzero ((char *) reg_last_set_mode, nregs * sizeof (enum machine_mode));\n-  bzero ((char *) reg_last_set_nonzero_bits, nregs * sizeof (HOST_WIDE_INT));\n-  bzero (reg_last_set_sign_bit_copies, nregs * sizeof (char));\n+  memset ((char *) reg_last_death, 0, nregs * sizeof (rtx));\n+  memset ((char *) reg_last_set, 0, nregs * sizeof (rtx));\n+  memset ((char *) reg_last_set_value, 0, nregs * sizeof (rtx));\n+  memset ((char *) reg_last_set_table_tick, 0, nregs * sizeof (int));\n+  memset ((char *) reg_last_set_label, 0, nregs * sizeof (int));\n+  memset (reg_last_set_invalid, 0, nregs * sizeof (char));\n+  memset ((char *) reg_last_set_mode, 0, nregs * sizeof (enum machine_mode));\n+  memset ((char *) reg_last_set_nonzero_bits, 0, nregs * sizeof (HOST_WIDE_INT));\n+  memset (reg_last_set_sign_bit_copies, 0, nregs * sizeof (char));\n }\n \f\n /* Set up any promoted values for incoming argument registers.  */"}, {"sha": "d11ff26ff2de00f51b5d6ae07b6fcb072c17343d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -1,3 +1,10 @@\n+2000-11-07  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* class.c (duplicate_tag_error, build_vtbl_initializer), decl.c\n+\t(push_binding_level), error.c (cp_tree_printer), pt.c\n+\t(process_partial_specialization, tsubst_template_arg_vector),\n+\tsearch.c (lookup_member): Use memset () instead of bzero ().\n+\n 2000-11-07  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* decl.c (build_ptrmemfunc_type): Allow error_mark_node."}, {"sha": "ff6f34cf15d69a369b777da630b67dfd8fdda184", "filename": "gcc/cp/class.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -2351,7 +2351,7 @@ duplicate_tag_error (t)\n       tree template_info = CLASSTYPE_TEMPLATE_INFO (t);\n       int use_template = CLASSTYPE_USE_TEMPLATE (t);\n \n-      bzero ((char *) TYPE_LANG_SPECIFIC (t), sizeof (struct lang_type));\n+      memset ((char *) TYPE_LANG_SPECIFIC (t), 0, sizeof (struct lang_type));\n       BINFO_BASETYPES(binfo) = NULL_TREE;\n \n       TYPE_BINFO (t) = binfo;\n@@ -7231,7 +7231,7 @@ build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo, non_fn_entries_p)\n   vtbl_init_data vid;\n \n   /* Initialize VID.  */\n-  bzero (&vid, sizeof (vid));\n+  memset (&vid, 0, sizeof (vid));\n   vid.binfo = binfo;\n   vid.derived = t;\n   vid.last_init = &vid.inits;"}, {"sha": "335672006cf5f5cf8c2f7eb87f96ddfe4d8c7b42", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -566,7 +566,7 @@ push_binding_level (newlevel, tag_transparent, keep)\n {\n   /* Add this level to the front of the chain (stack) of levels that\n      are active.  */\n-  bzero ((char*) newlevel, sizeof (struct binding_level));\n+  memset ((char*) newlevel, 0, sizeof (struct binding_level));\n   newlevel->level_chain = current_binding_level;\n   current_binding_level = newlevel;\n   newlevel->tag_transparent = tag_transparent;"}, {"sha": "9717ce03112fe96ab926ead2a39219d5d801ea67", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -2650,7 +2650,7 @@ cp_tree_printer (buffer)\n   int be_verbose = 0;\n   tree_formatting_info tfi;\n \n-  bzero (&tfi, sizeof (tree_formatting_info));\n+  memset (&tfi, 0, sizeof (tree_formatting_info));\n \n   if (*output_buffer_text_cursor (buffer) == '+')\n     ++output_buffer_text_cursor (buffer);"}, {"sha": "7098d7d298a9de7a8edef8ad5770045b38b542a7", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -2108,10 +2108,10 @@ process_partial_specialization (decl)\n      or some such would have been OK.  */\n   tpd.level = TMPL_PARMS_DEPTH (current_template_parms);\n   tpd.parms = alloca (sizeof (int) * ntparms);\n-  bzero ((PTR) tpd.parms, sizeof (int) * ntparms);\n+  memset ((PTR) tpd.parms, 0, sizeof (int) * ntparms);\n \n   tpd.arg_uses_template_parms = alloca (sizeof (int) * nargs);\n-  bzero ((PTR) tpd.arg_uses_template_parms, sizeof (int) * nargs);\n+  memset ((PTR) tpd.arg_uses_template_parms, 0, sizeof (int) * nargs);\n   for (i = 0; i < nargs; ++i)\n     {\n       tpd.current_arg = i;\n@@ -2195,7 +2195,7 @@ process_partial_specialization (decl)\n \t\t template, not in the specialization.  */\n \t      tpd2.current_arg = i;\n \t      tpd2.arg_uses_template_parms[i] = 0;\n-\t      bzero ((PTR) tpd2.parms, sizeof (int) * nargs);\n+\t      memset ((PTR) tpd2.parms, 0, sizeof (int) * nargs);\n \t      for_each_template_parm (type,\n \t\t\t\t      &mark_template_parm,\n \t\t\t\t      &tpd2);\n@@ -5195,7 +5195,7 @@ tsubst_template_arg_vector (t, args, complain)\n   int len = TREE_VEC_LENGTH (t), need_new = 0, i;\n   tree *elts = (tree *) alloca (len * sizeof (tree));\n   \n-  bzero ((char *) elts, len * sizeof (tree));\n+  memset ((char *) elts, 0, len * sizeof (tree));\n   \n   for (i = 0; i < len; i++)\n     {"}, {"sha": "a7fdc86888b3b46fad255ce46c7a80cae4083817", "filename": "gcc/cp/search.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -1538,7 +1538,7 @@ lookup_member (xbasetype, name, protect, want_type)\n   n_calls_lookup_field++;\n #endif /* GATHER_STATISTICS */\n \n-  bzero ((PTR) &lfi, sizeof (lfi));\n+  memset ((PTR) &lfi, 0, sizeof (lfi));\n   lfi.type = type;\n   lfi.name = name;\n   lfi.want_type = want_type;"}, {"sha": "d36816a2e811ec79346c34bf61c8cda0d551a97f", "filename": "gcc/cse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -993,7 +993,7 @@ new_basic_block ()\n \n   /* Clear out hash table state for this pass.  */\n \n-  bzero ((char *) reg_hash, sizeof reg_hash);\n+  memset ((char *) reg_hash, 0, sizeof reg_hash);\n \n   if (cse_reg_info_used_list)\n     {"}, {"sha": "f25eb347ac57ac8882635f8ca4509141be569725", "filename": "gcc/dbxout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -1043,7 +1043,7 @@ dbxout_type (type, full, show_arg_types)\n \t  typevec\n \t    = (struct typeinfo *) xrealloc (typevec,\n \t\t\t\t\t    typevec_len * 2 * sizeof typevec[0]);\n-\t  bzero ((char *) (typevec + typevec_len),\n+\t  memset ((char *) (typevec + typevec_len), 0,\n \t\t typevec_len * sizeof typevec[0]);\n \t  typevec_len *= 2;\n \t}"}, {"sha": "c2fe71a912c40efdef7419157573c332c04cdb2f", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -331,7 +331,7 @@ init_output_buffer (buffer, prefix, maximum_length)\n      const char *prefix;\n      int maximum_length;\n {\n-  bzero (buffer, sizeof (output_buffer));\n+  memset (buffer, 0, sizeof (output_buffer));\n   obstack_init (&buffer->obstack);\n   ideal_line_wrap_cutoff (buffer) = maximum_length;\n   prefixing_policy (buffer) = current_prefixing_rule;\n@@ -1692,7 +1692,7 @@ set_diagnostic_context (dc, message, args_ptr, file, line, warn)\n      int line;\n      int warn;\n {\n-  bzero (dc, sizeof (diagnostic_context));\n+  memset (dc, 0, sizeof (diagnostic_context));\n   diagnostic_message (dc) = message;\n   diagnostic_argument_list (dc) = args_ptr;\n   diagnostic_file_location (dc) = file;"}, {"sha": "507c9a7d3e37170d482d15c0d5dff82195e8a4e7", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -4849,7 +4849,7 @@ equate_decl_number_to_die (decl, decl_die)\n \t= (dw_die_ref *) xrealloc (decl_die_table,\n \t\t\t\t   sizeof (dw_die_ref) * num_allocated);\n \n-      bzero ((char *) &decl_die_table[decl_die_table_allocated],\n+      memset ((char *) &decl_die_table[decl_die_table_allocated], 0,\n \t     (num_allocated - decl_die_table_allocated) * sizeof (dw_die_ref));\n       decl_die_table_allocated = num_allocated;\n     }\n@@ -5481,7 +5481,7 @@ build_abbrev_table (die)\n \t    = (dw_die_ref *) xrealloc (abbrev_die_table,\n \t\t\t\t       sizeof (dw_die_ref) * n_alloc);\n \n-\t  bzero ((char *) &abbrev_die_table[abbrev_die_table_allocated],\n+\t  memset ((char *) &abbrev_die_table[abbrev_die_table_allocated], 0,\n \t\t (n_alloc - abbrev_die_table_allocated) * sizeof (dw_die_ref));\n \t  abbrev_die_table_allocated = n_alloc;\n \t}"}, {"sha": "c73b346fe5b8afeb1213419c2675a0341cc7f878", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -4106,7 +4106,7 @@ init_emit_once (line_numbers)\n \t  rtx tem = rtx_alloc (CONST_DOUBLE);\n \t  union real_extract u;\n \n-\t  bzero ((char *) &u, sizeof u);  /* Zero any holes in a structure.  */\n+\t  memset ((char *) &u, 0, sizeof u);  /* Zero any holes in a structure.  */\n \t  u.d = i == 0 ? dconst0 : i == 1 ? dconst1 : dconst2;\n \n \t  bcopy ((char *) &u, (char *) &CONST_DOUBLE_LOW (tem), sizeof u);"}, {"sha": "da27f470f1e0cec632fe6c2461c317084c9fba4f", "filename": "gcc/fold-const.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -325,7 +325,7 @@ mul_double (l1, h1, l2, h2, lv, hv)\n   encode (arg1, l1, h1);\n   encode (arg2, l2, h2);\n \n-  bzero ((char *) prod, sizeof prod);\n+  memset ((char *) prod, 0, sizeof prod);\n \n   for (i = 0; i < 4; i++)\n     {\n@@ -577,10 +577,10 @@ div_and_round_double (code, uns,\n       goto finish_up;\n     }\n \n-  bzero ((char *) quo, sizeof quo);\n+  memset ((char *) quo, 0, sizeof quo);\n \n-  bzero ((char *) num, sizeof num);\t/* to zero 9th element */\n-  bzero ((char *) den, sizeof den);\n+  memset ((char *) num, 0, sizeof num);\t/* to zero 9th element */\n+  memset ((char *) den, 0, sizeof den);\n \n   encode (num, lnum, hnum);\n   encode (den, lden, hden);"}, {"sha": "f86521a2eb606be2227bfe3a55e7823a8964e504", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -4787,7 +4787,7 @@ assign_parms (fndecl)\n \t      max_parm_reg = regno + 1;\n \t      new = (rtx *) xrealloc (parm_reg_stack_loc,\n \t\t\t\t      max_parm_reg * sizeof (rtx));\n-\t      bzero ((char *) (new + old_max_parm_reg),\n+\t      memset ((char *) (new + old_max_parm_reg), 0,\n \t\t     (max_parm_reg - old_max_parm_reg) * sizeof (rtx));\n \t      parm_reg_stack_loc = new;\n \t    }"}, {"sha": "29385972923f8bf7a59a53618c5dec60fdd54718", "filename": "gcc/gcse.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -817,7 +817,7 @@ compute_can_copy ()\n #ifndef AVOID_CCMODE_COPIES\n   rtx reg,insn;\n #endif\n-  bzero (can_copy_p, NUM_MACHINE_MODES);\n+  memset (can_copy_p, 0, NUM_MACHINE_MODES);\n \n   start_sequence ();\n   for (i = 0; i < NUM_MACHINE_MODES; i++)\n@@ -890,7 +890,7 @@ alloc_gcse_mem (f)\n   max_uid = get_max_uid ();\n   n = (max_uid + 1) * sizeof (int);\n   uid_cuid = (int *) gmalloc (n);\n-  bzero ((char *) uid_cuid, n);\n+  memset ((char *) uid_cuid, 0, n);\n   for (insn = f, i = 0; insn; insn = NEXT_INSN (insn))\n     {\n       if (INSN_P (insn))\n@@ -904,7 +904,7 @@ alloc_gcse_mem (f)\n   max_cuid = i;\n   n = (max_cuid + 1) * sizeof (rtx);\n   cuid_insn = (rtx *) gmalloc (n);\n-  bzero ((char *) cuid_insn, n);\n+  memset ((char *) cuid_insn, 0, n);\n   for (insn = f, i = 0; insn; insn = NEXT_INSN (insn))\n     if (INSN_P (insn))\n       CUID_INSN (i++) = insn;\n@@ -1095,7 +1095,7 @@ alloc_reg_set_mem (n_regs)\n   reg_set_table_size = n_regs + REG_SET_TABLE_SLOP;\n   n = reg_set_table_size * sizeof (struct reg_set *);\n   reg_set_table = (struct reg_set **) gmalloc (n);\n-  bzero ((char *) reg_set_table, n);\n+  memset ((char *) reg_set_table, 0, n);\n \n   gcc_obstack_init (&reg_set_obstack);\n }\n@@ -1125,7 +1125,7 @@ record_one_set (regno, insn)\n       reg_set_table\n \t= (struct reg_set **) grealloc ((char *) reg_set_table,\n \t\t\t\t\tnew_size * sizeof (struct reg_set *));\n-      bzero ((char *) (reg_set_table + reg_set_table_size),\n+      memset ((char *) (reg_set_table + reg_set_table_size), 0,\n \t     (new_size - reg_set_table_size) * sizeof (struct reg_set *));\n       reg_set_table_size = new_size;\n     }\n@@ -2154,7 +2154,7 @@ compute_hash_table (set_p)\n      ??? This isn't needed during const/copy propagation, but it's cheap to\n      compute.  Later.  */\n   sbitmap_vector_zero (reg_set_in_block, n_basic_blocks);\n-  bzero ((char *) mem_set_in_block, n_basic_blocks);\n+  memset ((char *) mem_set_in_block, 0, n_basic_blocks);\n \n   /* Some working arrays used to track first and last set in each block.  */\n   /* ??? One could use alloca here, but at some size a threshold is crossed\n@@ -2282,7 +2282,7 @@ compute_set_hash_table ()\n {\n   /* Initialize count of number of entries in hash table.  */\n   n_sets = 0;\n-  bzero ((char *) set_hash_table,\n+  memset ((char *) set_hash_table, 0,\n \t set_hash_table_size * sizeof (struct expr *));\n \n   compute_hash_table (1);\n@@ -2326,7 +2326,7 @@ compute_expr_hash_table ()\n {\n   /* Initialize count of number of entries in hash table.  */\n   n_exprs = 0;\n-  bzero ((char *) expr_hash_table,\n+  memset ((char *) expr_hash_table, 0,\n \t expr_hash_table_size * sizeof (struct expr *));\n \n   compute_hash_table (0);"}, {"sha": "d3f77b0640d66b92f7cf74af59fde5b1b653a249", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -3459,7 +3459,7 @@ optimize_attrs ()\n   insn_code_values\n     = (struct attr_value_list **) alloca ((insn_code_number + 2)\n \t\t\t\t\t  * sizeof (struct attr_value_list *));\n-  bzero ((char *) insn_code_values,\n+  memset ((char *) insn_code_values, 0,\n \t (insn_code_number + 2) * sizeof (struct attr_value_list *));\n \n   /* Offset the table address so we can index by -2 or -1.  */"}, {"sha": "54d18c80d232aa24359c6ea644edc8dced63de9f", "filename": "gcc/global.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -454,8 +454,8 @@ global_alloc (file)\n   /* Calculate amount of usage of each hard reg by pseudos\n      allocated by local-alloc.  This is to see if we want to\n      override it.  */\n-  bzero ((char *) local_reg_live_length, sizeof local_reg_live_length);\n-  bzero ((char *) local_reg_n_refs, sizeof local_reg_n_refs);\n+  memset ((char *) local_reg_live_length, 0, sizeof local_reg_live_length);\n+  memset ((char *) local_reg_n_refs, 0, sizeof local_reg_n_refs);\n   for (i = FIRST_PSEUDO_REGISTER; i < (size_t) max_regno; i++)\n     if (reg_renumber[i] >= 0)\n       {\n@@ -637,7 +637,7 @@ global_conflicts ()\n \n   for (b = 0; b < n_basic_blocks; b++)\n     {\n-      bzero ((char *) allocnos_live, allocno_row_words * sizeof (INT_TYPE));\n+      memset ((char *) allocnos_live, 0, allocno_row_words * sizeof (INT_TYPE));\n \n       /* Initialize table of registers currently live\n \t to the state at the beginning of this basic block."}, {"sha": "2ab6377d75352a4432af0611b9c8bb40da19bf8c", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -2054,7 +2054,7 @@ compute_trg_info (trg)\n \t     up with a lot of duplicates.  We need to weed them out to avoid\n \t     overrunning the end of the bblst_table.  */\n \t  update_blocks = (char *) alloca (n_basic_blocks);\n-\t  bzero (update_blocks, n_basic_blocks);\n+\t  memset (update_blocks, 0, n_basic_blocks);\n \n \t  update_idx = 0;\n \t  for (j = 0; j < el.nr_members; j++)\n@@ -2917,9 +2917,9 @@ static int unit_n_insns[FUNCTION_UNITS_SIZE];\n static void\n clear_units ()\n {\n-  bzero ((char *) unit_last_insn, sizeof (unit_last_insn));\n-  bzero ((char *) unit_tick, sizeof (unit_tick));\n-  bzero ((char *) unit_n_insns, sizeof (unit_n_insns));\n+  memset ((char *) unit_last_insn, 0, sizeof (unit_last_insn));\n+  memset ((char *) unit_tick, 0, sizeof (unit_tick));\n+  memset ((char *) unit_n_insns, 0, sizeof (unit_n_insns));\n }\n \n /* Return the issue-delay of an insn.  */\n@@ -6019,7 +6019,7 @@ schedule_block (bb, rgn_n_insns)\n   q_ptr = 0;\n   q_size = 0;\n   last_clock_var = 0;\n-  bzero ((char *) insn_queue, sizeof (insn_queue));\n+  memset ((char *) insn_queue, 0, sizeof (insn_queue));\n \n   /* Start just before the beginning of time.  */\n   clock_var = -1;"}, {"sha": "34aa4bff971931d38dc85e4c64078a2751d80a19", "filename": "gcc/integrate.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -275,7 +275,7 @@ initialize_for_inline (fndecl)\n   tree parms;\n \n   /* Clear out PARMDECL_MAP.  It was allocated in the caller's frame.  */\n-  bzero ((char *) parmdecl_map, max_parm_reg * sizeof (tree));\n+  memset ((char *) parmdecl_map, 0, max_parm_reg * sizeof (tree));\n   arg_vector = rtvec_alloc (list_length (DECL_ARGUMENTS (fndecl)));\n \n   for (parms = DECL_ARGUMENTS (fndecl), i = 0;\n@@ -1094,7 +1094,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \n   /* Initialize label_map.  get_label_from_map will actually make\n      the labels.  */\n-  bzero ((char *) &map->label_map[min_labelno],\n+  memset ((char *) &map->label_map[min_labelno], 0,\n \t (max_labelno - min_labelno) * sizeof (rtx));\n \n   /* Make copies of the decls of the symbols in the inline function, so that"}, {"sha": "f4eff5346c331964b72545b2621ef3ebbb949b57", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -1,3 +1,9 @@\n+2000-11-07  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* expr.c (note_instructions), jcf-io.c (find_class), jcf-parse.c\n+\t(init_outgoing_cpool), lex.c (java_init_lex): Use memset ()\n+\tinstead of bzero ().\n+\n 2000-11-05  Tom Tromey  <tromey@cygnus.com>\n \n \t* lex.h (JAVA_FLOAT_RANGE_ERROR): Typo fix."}, {"sha": "2d592299f309d6f646ca2c404c4913500ebfee39", "filename": "gcc/java/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -2507,7 +2507,7 @@ note_instructions (jcf, method)\n   JCF_SEEK (jcf, DECL_CODE_OFFSET (method));\n   byte_ops = jcf->read_ptr;\n   instruction_bits = xrealloc (instruction_bits, length + 1);\n-  bzero (instruction_bits, length + 1);\n+  memset (instruction_bits, 0, length + 1);\n \n   /* This pass figures out which PC can be the targets of jumps. */\n   for (PC = 0; PC < length;)"}, {"sha": "03ea7d75acfc61e7e9b83149251dc4327349315b", "filename": "gcc/java/jcf-io.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fjava%2Fjcf-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fjava%2Fjcf-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-io.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -319,7 +319,7 @@ DEFUN(find_class, (classname, classname_length, jcf, source_ok),\n      null pointer when we're copying it below.  */\n   int buflen = jcf_path_max_len () + classname_length + 10;\n   char *buffer = (char *) ALLOC (buflen);\n-  bzero (buffer, buflen);\n+  memset (buffer, 0, buflen);\n \n   java_buffer = (char *) alloca (buflen);\n "}, {"sha": "090120a1c6c2858e445d521e4d72fc478558d3c7", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -648,7 +648,7 @@ init_outgoing_cpool ()\n {\n   current_constant_pool_data_ref = NULL_TREE;\n   outgoing_cpool = (struct CPool *)xmalloc (sizeof (struct CPool));\n-  bzero (outgoing_cpool, sizeof (struct CPool));\n+  memset (outgoing_cpool, 0, sizeof (struct CPool));\n }\n \n static void"}, {"sha": "1b8898c604cb5bf4e49d3f11833762da88140507", "filename": "gcc/java/lex.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -115,8 +115,8 @@ java_init_lex (finput, encoding)\n   CPC_INITIALIZER_LIST (ctxp) = CPC_STATIC_INITIALIZER_LIST (ctxp) =\n     CPC_INSTANCE_INITIALIZER_LIST (ctxp) = ctxp->incomplete_class = NULL_TREE;\n \n-  bzero ((PTR) ctxp->modifier_ctx, 11*sizeof (ctxp->modifier_ctx[0]));\n-  bzero ((PTR) current_jcf, sizeof (JCF));\n+  memset ((PTR) ctxp->modifier_ctx, 0, 11*sizeof (ctxp->modifier_ctx[0]));\n+  memset ((PTR) current_jcf, 0, sizeof (JCF));\n   ctxp->current_parsed_class = NULL;\n   ctxp->package = NULL_TREE;\n #endif"}, {"sha": "4c9c5ea2faed1eace6fd16ede1cd38825c6ecb58", "filename": "gcc/jump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -3745,7 +3745,7 @@ thread_jumps (f, max_reg, flag_before_loop)\n \t      || ! any_condjump_p (b1) || JUMP_LABEL (b1) == 0)\n \t    continue;\n \n-\t  bzero (modified_regs, max_reg * sizeof (char));\n+\t  memset (modified_regs, 0, max_reg * sizeof (char));\n \t  modified_mem = 0;\n \n \t  bcopy ((char *) all_reset, (char *) same_regs,"}, {"sha": "2315338756bbbdd52fe5f8f93c301cbde99889fe", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -411,7 +411,7 @@ local_alloc ()\n       else\n \t{\n #define CLEAR(vector)  \\\n-\t  bzero ((char *) (vector), (sizeof (*(vector))) * next_qty);\n+\t  memset ((char *) (vector), 0, (sizeof (*(vector))) * next_qty);\n \n \t  CLEAR (qty_phys_copy_sugg);\n \t  CLEAR (qty_phys_num_copy_sugg);"}, {"sha": "9254fc90f56cff5f37e4e79b7902b0486397f4fa", "filename": "gcc/loop.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -1344,7 +1344,7 @@ combine_movables (movables, regs)\n \tregister struct movable *m1;\n \tint regno = m->regno;\n \n-\tbzero (matched_regs, regs->num);\n+\tmemset (matched_regs, 0, regs->num);\n \tmatched_regs[regno] = 1;\n \n \t/* We want later insns to match the first one.  Don't make the first\n@@ -3367,7 +3367,7 @@ count_loop_regs_set (loop, may_not_move, single_usage, count_ptr, nregs)\n \t}\n \n       if (GET_CODE (insn) == CODE_LABEL || GET_CODE (insn) == JUMP_INSN)\n-\tbzero ((char *) last_set, nregs * sizeof (rtx));\n+\tmemset ((char *) last_set, 0, nregs * sizeof (rtx));\n     }\n   *count_ptr = count;\n \n@@ -8664,9 +8664,9 @@ load_mems_and_recount_loop_regs_set (loop, insn_count)\n \t  VARRAY_GROW (regs->single_usage, nregs);\n \t}\n       /* Clear the arrays */\n-      bzero ((char *) &regs->set_in_loop->data, nregs * sizeof (int));\n-      bzero ((char *) &regs->may_not_optimize->data, nregs * sizeof (char));\n-      bzero ((char *) &regs->single_usage->data, nregs * sizeof (rtx));\n+      memset ((char *) &regs->set_in_loop->data, 0, nregs * sizeof (int));\n+      memset ((char *) &regs->may_not_optimize->data, 0, nregs * sizeof (char));\n+      memset ((char *) &regs->single_usage->data, 0, nregs * sizeof (rtx));\n \n       count_loop_regs_set (loop, regs->may_not_optimize, regs->single_usage,\n \t\t\t   insn_count, nregs);"}, {"sha": "bea5844937321280a5c47f22b93566fb7ba9e5c4", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -3627,7 +3627,7 @@ error_with_ivar (message, decl, rawdecl)\n \n   fprintf (stderr, \"%s:%d: \",\n \t   DECL_SOURCE_FILE (decl), DECL_SOURCE_LINE (decl));\n-  bzero (errbuf, BUFSIZE);\n+  memset (errbuf, 0, BUFSIZE);\n   fprintf (stderr, \"%s `%s'\\n\", message, gen_declaration (rawdecl, errbuf));\n }\n \n@@ -4740,7 +4740,7 @@ build_keyword_selector (selector)\n     }\n \n   buf = (char *)alloca (len + 1);\n-  bzero (buf, len + 1);\n+  memset (buf, 0, len + 1);\n \n   for (key_chain = selector; key_chain; key_chain = TREE_CHAIN (key_chain))\n     {\n@@ -4979,7 +4979,7 @@ build_message_expr (mess)\n \t       /* Allow any type that matches objc_class_type.  */\n \t       && ! comptypes (rtype, objc_class_type))\n \t{\n-\t  bzero (errbuf, BUFSIZE);\n+\t  memset (errbuf, 0, BUFSIZE);\n \t  warning (\"invalid receiver type `%s'\",\n \t\t   gen_declaration (rtype, errbuf));\n \t}\n@@ -7079,7 +7079,7 @@ warn_with_method (message, mtype, method)\n \n   fprintf (stderr, \"%s:%d: warning: \",\n \t   DECL_SOURCE_FILE (method), DECL_SOURCE_LINE (method));\n-  bzero (errbuf, BUFSIZE);\n+  memset (errbuf, 0, BUFSIZE);\n   fprintf (stderr, \"%s `%c%s'\\n\",\n \t   message, mtype, gen_method_decl (method, errbuf));\n }\n@@ -8088,7 +8088,7 @@ dump_interface (fp, chain)\n       fprintf (fp, \"{\\n\");\n       do\n \t{\n-\t  bzero (buf, 256);\n+\t  memset (buf, 0, 256);\n \t  fprintf (fp, \"\\t%s;\\n\", gen_declaration (ivar_decls, buf));\n \t  ivar_decls = TREE_CHAIN (ivar_decls);\n \t}\n@@ -8098,14 +8098,14 @@ dump_interface (fp, chain)\n \n   while (nst_methods)\n     {\n-      bzero (buf, 256);\n+      memset (buf, 0, 256);\n       fprintf (fp, \"- %s;\\n\", gen_method_decl (nst_methods, buf));\n       nst_methods = TREE_CHAIN (nst_methods);\n     }\n \n   while (cls_methods)\n     {\n-      bzero (buf, 256);\n+      memset (buf, 0, 256);\n       fprintf (fp, \"+ %s;\\n\", gen_method_decl (cls_methods, buf));\n       cls_methods = TREE_CHAIN (cls_methods);\n     }\n@@ -8501,7 +8501,7 @@ objc_debug (fp)\n \tif (TREE_CODE (loop) == FUNCTION_DECL && DECL_INITIAL (loop))\n \t  {\n \t    /* We have a function definition: generate prototype.  */\n-            bzero (errbuf, BUFSIZE);\n+            memset (errbuf, 0, BUFSIZE);\n \t    gen_declaration (loop, errbuf);\n \t    fprintf (fp, \"%s;\\n\", errbuf);\n \t  }\n@@ -8521,7 +8521,7 @@ objc_debug (fp)\n \t    fprintf (fp, \"\\n\\nnst_method_hash_list[%d]:\\n\", i);\n \t    do\n \t      {\n-\t\tbzero (buf, 256);\n+\t\tmemset (buf, 0, 256);\n \t\tfprintf (fp, \"-%s;\\n\", gen_method_decl (hashlist->key, buf));\n \t\thashlist = hashlist->next;\n \t      }\n@@ -8536,7 +8536,7 @@ objc_debug (fp)\n \t    fprintf (fp, \"\\n\\ncls_method_hash_list[%d]:\\n\", i);\n \t    do\n \t      {\n-\t\tbzero (buf, 256);\n+\t\tmemset (buf, 0, 256);\n \t\tfprintf (fp, \"-%s;\\n\", gen_method_decl (hashlist->key, buf));\n \t\thashlist = hashlist->next;\n \t      }"}, {"sha": "d0073fd0c267015d292ba7159815be347a5fccb7", "filename": "gcc/print-tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -47,7 +47,7 @@ debug_tree (node)\n      tree node;\n {\n   table = (struct bucket **) permalloc (HASH_SIZE * sizeof (struct bucket *));\n-  bzero ((char *) table, HASH_SIZE * sizeof (struct bucket *));\n+  memset ((char *) table, 0, HASH_SIZE * sizeof (struct bucket *));\n   print_node (stderr, \"\", node, 0);\n   table = 0;\n   fprintf (stderr, \"\\n\");"}, {"sha": "bf6fa0f6b3b41c2ffc0436bab522e870da198fb6", "filename": "gcc/regclass.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -269,7 +269,7 @@ init_reg_sets ()\n \n   bcopy (initial_fixed_regs, fixed_regs, sizeof fixed_regs);\n   bcopy (initial_call_used_regs, call_used_regs, sizeof call_used_regs);\n-  bzero (global_regs, sizeof global_regs);\n+  memset (global_regs, 0, sizeof global_regs);\n \n   /* Do any additional initialization regsets may need */\n   INIT_ONCE_REG_SET ();\n@@ -297,7 +297,7 @@ init_reg_sets_1 ()\n \n   /* Compute number of hard regs in each class.  */\n \n-  bzero ((char *) reg_class_size, sizeof reg_class_size);\n+  memset ((char *) reg_class_size, 0, sizeof reg_class_size);\n   for (i = 0; i < N_REG_CLASSES; i++)\n     for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n       if (TEST_HARD_REG_BIT (reg_class_contents[i], j))\n@@ -1122,10 +1122,10 @@ regclass (f, nregs, dump)\n         fprintf (dump, \"\\n\\nPass %i\\n\\n\",pass);\n       /* Zero out our accumulation of the cost of each class for each reg.  */\n \n-      bzero ((char *) costs, nregs * sizeof (struct costs));\n+      memset ((char *) costs, 0, nregs * sizeof (struct costs));\n \n #ifdef FORBIDDEN_INC_DEC_CLASSES\n-      bzero (in_inc_dec, nregs);\n+      memset (in_inc_dec, 0, nregs);\n #endif\n \n       /* Scan the instructions and record each time it would\n@@ -1337,7 +1337,7 @@ record_reg_classes (n_alts, n_ops, ops, modes,\n \t  if (*p == 0)\n \t    {\n \t      if (GET_CODE (op) == REG && REGNO (op) >= FIRST_PSEUDO_REGISTER)\n-\t\tbzero ((char *) &this_op_costs[i], sizeof this_op_costs[i]);\n+\t\tmemset ((char *) &this_op_costs[i], 0, sizeof this_op_costs[i]);\n \n \t      continue;\n \t    }\n@@ -2122,7 +2122,7 @@ allocate_reg_info (num_regs, new_p, renumber_p)\n \t  if (!reg_data->used_p)\t/* page just allocated with calloc */\n \t    reg_data->used_p = 1;\t/* no need to zero */\n \t  else\n-\t    bzero ((char *) &reg_data->data[local_min],\n+\t    memset ((char *) &reg_data->data[local_min], 0,\n \t\t   sizeof (reg_info) * (max - min_index - local_min + 1));\n \n \t  for (i = min_index+local_min; i <= max; i++)"}, {"sha": "65a5e731b4156801c2dcccd37ab7e5c6b14448a4", "filename": "gcc/reload.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -647,7 +647,7 @@ get_secondary_mem (x, mode, opnum, type)\n void\n clear_secondary_mem ()\n {\n-  bzero ((char *) secondary_memlocs, sizeof secondary_memlocs);\n+  memset ((char *) secondary_memlocs, 0, sizeof secondary_memlocs);\n }\n #endif /* SECONDARY_MEMORY_NEEDED */\n \f\n@@ -1558,7 +1558,7 @@ remove_address_replacements (in_rtx)\n   char reload_flags[MAX_RELOADS];\n   int something_changed = 0;\n \n-  bzero (reload_flags, sizeof reload_flags);\n+  memset (reload_flags, 0, sizeof reload_flags);\n   for (i = 0, j = 0; i < n_replacements; i++)\n     {\n       if (loc_mentioned_in_p (replacements[i].where, in_rtx))\n@@ -2451,7 +2451,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n   /* The eliminated forms of any secondary memory locations are per-insn, so\n      clear them out here.  */\n \n-  bzero ((char *) secondary_memlocs_elim, sizeof secondary_memlocs_elim);\n+  memset ((char *) secondary_memlocs_elim, 0, sizeof secondary_memlocs_elim);\n #endif\n \n   /* Dispose quickly of (set (reg..) (reg..)) if both have hard regs and it"}, {"sha": "151529ada8e0ee4e2fb2391cd837baae056266fb", "filename": "gcc/reload1.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -631,8 +631,8 @@ reload (first, global)\n #endif\n \n   /* We don't have a stack slot for any spill reg yet.  */\n-  bzero ((char *) spill_stack_slot, sizeof spill_stack_slot);\n-  bzero ((char *) spill_stack_slot_width, sizeof spill_stack_slot_width);\n+  memset ((char *) spill_stack_slot, 0, sizeof spill_stack_slot);\n+  memset ((char *) spill_stack_slot_width, 0, sizeof spill_stack_slot_width);\n \n   /* Initialize the save area information for caller-save, in case some\n      are needed.  */\n@@ -3281,7 +3281,7 @@ static void\n set_initial_label_offsets ()\n {\n   rtx x;\n-  bzero ((char *) &offsets_known_at[get_first_label_num ()], num_labels);\n+  memset ((char *) &offsets_known_at[get_first_label_num ()], 0, num_labels);\n \n   for (x = forced_labels; x; x = XEXP (x, 1))\n     if (XEXP (x, 0))\n@@ -3555,7 +3555,7 @@ finish_spills (global)\n   /* Retry global register allocation if possible.  */\n   if (global)\n     {\n-      bzero ((char *) pseudo_forbidden_regs, max_regno * sizeof (HARD_REG_SET));\n+      memset ((char *) pseudo_forbidden_regs, 0, max_regno * sizeof (HARD_REG_SET));\n       /* For every insn that needs reloads, set the registers used as spill\n \t regs in pseudo_forbidden_regs for every pseudo live across the\n \t insn.  */\n@@ -3726,8 +3726,8 @@ reload_as_needed (live_known)\n #endif\n   rtx x;\n \n-  bzero ((char *) spill_reg_rtx, sizeof spill_reg_rtx);\n-  bzero ((char *) spill_reg_store, sizeof spill_reg_store);\n+  memset ((char *) spill_reg_rtx, 0, sizeof spill_reg_rtx);\n+  memset ((char *) spill_reg_store, 0, sizeof spill_reg_store);\n   reg_last_reload_reg = (rtx *) xcalloc (max_regno, sizeof (rtx));\n   reg_has_output_reload = (char *) xmalloc (max_regno);\n   CLEAR_HARD_REG_SET (reg_reloaded_valid);\n@@ -3788,7 +3788,7 @@ reload_as_needed (live_known)\n \t     rtx's for those pseudo regs.  */\n \t  else\n \t    {\n-\t      bzero (reg_has_output_reload, max_regno);\n+\t      memset (reg_has_output_reload, 0, max_regno);\n \t      CLEAR_HARD_REG_SET (reg_is_output_reload);\n \n \t      find_reloads (insn, 1, spill_indirect_levels, live_known,\n@@ -5098,9 +5098,9 @@ choose_reload_regs_init (chain, save_reload_reg_rtx)\n   for (i = 0; i < n_reloads; i++)\n     rld[i].reg_rtx = save_reload_reg_rtx[i];\n \n-  bzero (reload_inherited, MAX_RELOADS);\n-  bzero ((char *) reload_inheritance_insn, MAX_RELOADS * sizeof (rtx));\n-  bzero ((char *) reload_override_in, MAX_RELOADS * sizeof (rtx));\n+  memset (reload_inherited, 0, MAX_RELOADS);\n+  memset ((char *) reload_inheritance_insn, 0, MAX_RELOADS * sizeof (rtx));\n+  memset ((char *) reload_override_in, 0, MAX_RELOADS * sizeof (rtx));\n \n   CLEAR_HARD_REG_SET (reload_reg_used);\n   CLEAR_HARD_REG_SET (reload_reg_used_at_all);\n@@ -8126,8 +8126,8 @@ reload_cse_simplify_operands (insn)\n   alternative_reject = (int *) alloca (recog_data.n_alternatives * sizeof (int));\n   alternative_nregs = (int *) alloca (recog_data.n_alternatives * sizeof (int));\n   alternative_order = (int *) alloca (recog_data.n_alternatives * sizeof (int));\n-  bzero ((char *)alternative_reject, recog_data.n_alternatives * sizeof (int));\n-  bzero ((char *)alternative_nregs, recog_data.n_alternatives * sizeof (int));\n+  memset ((char *)alternative_reject, 0, recog_data.n_alternatives * sizeof (int));\n+  memset ((char *)alternative_nregs, 0, recog_data.n_alternatives * sizeof (int));\n \n   /* For each operand, find out which regs are equivalent.  */\n   for (i = 0; i < recog_data.n_operands; i++)"}, {"sha": "6d3b26a196f0ff2fd9f867daf996e66a1b694440", "filename": "gcc/reorg.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -3589,8 +3589,8 @@ dbr_schedule (first, file)\n   end_of_function_label = 0;\n \n   /* Initialize the statistics for this function.  */\n-  bzero ((char *) num_insns_needing_delays, sizeof num_insns_needing_delays);\n-  bzero ((char *) num_filled_delays, sizeof num_filled_delays);\n+  memset ((char *) num_insns_needing_delays, 0, sizeof num_insns_needing_delays);\n+  memset ((char *) num_filled_delays, 0, sizeof num_filled_delays);\n \n   /* Now do the delay slot filling.  Try everything twice in case earlier\n      changes make more slots fillable.  */\n@@ -3667,8 +3667,8 @@ dbr_schedule (first, file)\n \t      fprintf (file, \"\\n\");\n \t    }\n \t}\n-      bzero ((char *) total_delay_slots, sizeof total_delay_slots);\n-      bzero ((char *) total_annul_slots, sizeof total_annul_slots);\n+      memset ((char *) total_delay_slots, 0, sizeof total_delay_slots);\n+      memset ((char *) total_annul_slots, 0, sizeof total_annul_slots);\n       for (insn = first; insn; insn = NEXT_INSN (insn))\n \t{\n \t  if (! INSN_DELETED_P (insn)"}, {"sha": "e03cd0442c3522394c09fb7ebd62d45f7feb9a3c", "filename": "gcc/sbitmap.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fsbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fsbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -106,7 +106,7 @@ void\n sbitmap_zero (bmap)\n      sbitmap bmap;\n {\n-  bzero ((PTR) bmap->elms, bmap->bytes);\n+  memset ((PTR) bmap->elms, 0, bmap->bytes);\n }\n \n /* Set all elements in a bitmap to ones.  */"}, {"sha": "fcf0831479ab56fcf1df992ab24068f90d1e6cba", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -1510,7 +1510,7 @@ simplify_plus_minus (code, mode, op0, op1)\n   int first = 1, negate = 0, changed;\n   int i, j;\n \n-  bzero ((char *) ops, sizeof ops);\n+  memset ((char *) ops, 0, sizeof ops);\n   \n   /* Set up the two operands and then expand them until nothing has been\n      changed.  If we run out of room in our array, give up; this should"}, {"sha": "0bc6dc858f1dd6a2476259cc4be9414ea6008276", "filename": "gcc/ssa.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -1127,8 +1127,8 @@ rename_registers (nregs, idom)\n   ssa_rename_from_initialize ();\n \n   ssa_rename_to_pseudo = (rtx *) alloca (nregs * sizeof(rtx));\n-  bzero ((char *) ssa_rename_to_pseudo, nregs * sizeof(rtx));\n-  bzero ((char *) ssa_rename_to_hard, \n+  memset ((char *) ssa_rename_to_pseudo, 0, nregs * sizeof(rtx));\n+  memset ((char *) ssa_rename_to_hard, 0, \n \t FIRST_PSEUDO_REGISTER * NUM_MACHINE_MODES * sizeof (rtx));\n \n   rename_block (0, idom);"}, {"sha": "cf0124b7977115b95b8c0e64d75b801c3e6dbfe3", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -5612,7 +5612,7 @@ expand_end_case (orig_index)\n \n \t  ncases = TREE_INT_CST_LOW (range) + 1;\n \t  labelvec = (rtx *) alloca (ncases * sizeof (rtx));\n-\t  bzero ((char *) labelvec, ncases * sizeof (rtx));\n+\t  memset ((char *) labelvec, 0, ncases * sizeof (rtx));\n \n \t  for (n = thiscase->data.case_stmt.case_list; n; n = n->right)\n \t    {"}, {"sha": "a666984045f8b4917880f58d22b9afe27229c0ba", "filename": "gcc/unroll.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -1072,10 +1072,10 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n \t      emit_label_after (labels[unroll_number - i],\n \t\t\t\tPREV_INSN (loop_start));\n \n-\t      bzero ((char *) map->insn_map, max_insnno * sizeof (rtx));\n-\t      bzero ((char *) &VARRAY_CONST_EQUIV (map->const_equiv_varray, 0),\n-\t\t     (VARRAY_SIZE (map->const_equiv_varray)\n-\t\t      * sizeof (struct const_equiv_data)));\n+\t      memset ((char *) map->insn_map, 0, max_insnno * sizeof (rtx));\n+\t      memset ((char *) &VARRAY_CONST_EQUIV (map->const_equiv_varray, 0),\n+\t\t      0, (VARRAY_SIZE (map->const_equiv_varray)\n+\t\t\t  * sizeof (struct const_equiv_data)));\n \t      map->const_age = 0;\n \n \t      for (j = 0; j < max_labelno; j++)\n@@ -1219,9 +1219,9 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n \n   for (i = 0; i < unroll_number; i++)\n     {\n-      bzero ((char *) map->insn_map, max_insnno * sizeof (rtx));\n-      bzero ((char *) &VARRAY_CONST_EQUIV (map->const_equiv_varray, 0),\n-\t     VARRAY_SIZE (map->const_equiv_varray) * sizeof (struct const_equiv_data));\n+      memset ((char *) map->insn_map, 0, max_insnno * sizeof (rtx));\n+      memset ((char *) &VARRAY_CONST_EQUIV (map->const_equiv_varray, 0), 0,\n+\t      VARRAY_SIZE (map->const_equiv_varray) * sizeof (struct const_equiv_data));\n       map->const_age = 0;\n \n       for (j = 0; j < max_labelno; j++)"}, {"sha": "7f75bf2f7c39f5db943a6badec50f9de032d065b", "filename": "gcc/varray.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fvarray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961192e1dd8305d932281fdc7efdc3276ad70e94/gcc%2Fvarray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarray.c?ref=961192e1dd8305d932281fdc7efdc3276ad70e94", "patch": "@@ -64,7 +64,7 @@ varray_grow (va, n)\n       va = (varray_type) xrealloc ((char *)va, VARRAY_HDR_SIZE + data_size);\n       va->num_elements = n;\n       if (n > old_elements)\n-\tbzero (&va->data.c[old_data_size], data_size - old_data_size);\n+\tmemset (&va->data.c[old_data_size], 0, data_size - old_data_size);\n     }\n \n   return va;"}]}