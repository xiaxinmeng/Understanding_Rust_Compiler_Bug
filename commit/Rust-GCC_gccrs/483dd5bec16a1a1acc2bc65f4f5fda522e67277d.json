{"sha": "483dd5bec16a1a1acc2bc65f4f5fda522e67277d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDgzZGQ1YmVjMTZhMWExYWNjMmJjNjVmNGY1ZmRhNTIyZTY3Mjc3ZA==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "1999-09-03T23:58:44Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "1999-09-03T23:58:44Z"}, "message": "c4x.c (c4x_emit_move_sequence): Do not force large constants into memory.\n\nSat Sep  4 11:37:15 1999  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n\n\t* config/c4x/c4x.c (c4x_emit_move_sequence): Do not force large\n\tconstants into memory.\n\t(c4x_shiftable_constant): New function.\n\t* config/c4x/c4x.c (LEGITIMATE_CONSTANT_P): Allow any CONST_INT.\n\t(c4x_shiftable_constant): Declare.\n\t* config/c4x/c4x.md (loadqi_big_constant, loadhi_big_constant,\n \tashlqi3_noclobber): Add new patterns and associated splitters.\n\nFrom-SVN: r29092", "tree": {"sha": "c34240021ac0fdbad1a2cc3daebac4be7ad0424d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c34240021ac0fdbad1a2cc3daebac4be7ad0424d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/483dd5bec16a1a1acc2bc65f4f5fda522e67277d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/483dd5bec16a1a1acc2bc65f4f5fda522e67277d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/483dd5bec16a1a1acc2bc65f4f5fda522e67277d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/483dd5bec16a1a1acc2bc65f4f5fda522e67277d/comments", "author": null, "committer": null, "parents": [{"sha": "3de900268edfcbeb0b286cc0119b778e1050a028", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3de900268edfcbeb0b286cc0119b778e1050a028", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3de900268edfcbeb0b286cc0119b778e1050a028"}], "stats": {"total": 187, "additions": 167, "deletions": 20}, "files": [{"sha": "2c509e3338935c4ae6937aa44133b8af657cdac3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483dd5bec16a1a1acc2bc65f4f5fda522e67277d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483dd5bec16a1a1acc2bc65f4f5fda522e67277d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=483dd5bec16a1a1acc2bc65f4f5fda522e67277d", "patch": "@@ -1,3 +1,13 @@\n+Sat Sep  4 11:37:15 1999  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* config/c4x/c4x.c (c4x_emit_move_sequence): Do not force large\n+\tconstants into memory.\n+\t(c4x_shiftable_constant): New function.\n+\t* config/c4x/c4x.c (LEGITIMATE_CONSTANT_P): Allow any CONST_INT.\n+\t(c4x_shiftable_constant): Declare.\n+\t* config/c4x/c4x.md (loadqi_big_constant, loadhi_big_constant,\n+ \tashlqi3_noclobber): Add new patterns and associated splitters.\n+\t\n Fri Sep  3 16:22:17 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* dbxout.c (dbxout_init): Use xcalloc instead of xmalloc+bzero."}, {"sha": "677c38cbd0fc1404f1249c884db55665e6b6ed86", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483dd5bec16a1a1acc2bc65f4f5fda522e67277d/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483dd5bec16a1a1acc2bc65f4f5fda522e67277d/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=483dd5bec16a1a1acc2bc65f4f5fda522e67277d", "patch": "@@ -1074,20 +1074,6 @@ c4x_emit_move_sequence (operands, mode)\n \t constants...  */\n       op1 = force_const_mem (mode, op1);\n     }\n-  else if (mode == QImode && CONSTANT_P (op1) && ! LEGITIMATE_CONSTANT_P (op1))\n-    {\n-      /* We shouldn't need this test if only emit_move_insn was called.\n-\t However, some routines call gen_move_insn which doesn't check that\n-\t the constants are legitimate.  */\n-      op1 = force_const_mem (mode, op1);\n-    }\n-  else if (mode == HImode && CONSTANT_P (op1) && ! LEGITIMATE_CONSTANT_P (op1))\n-    {\n-      /* We could load all sorts of constants in two goes by pulling all\n-\t sorts of tricks... The tricky thing is that we cannot clobber CC\n-\t so that stifles most of the obvious methods.  */\n-      op1 = force_const_mem (mode, op1);\n-    }\n \n   /* Convert (MEM (SYMREF)) to a (MEM (LO_SUM (REG) (SYMREF)))\n      and emit associated (HIGH (SYMREF)) if large memory model.  \n@@ -2258,6 +2244,27 @@ c4x_immed_float_constant (op)\n }\n \n \n+int\n+c4x_shiftable_constant (op)\n+     rtx op;\n+{\n+  int i;\n+  int mask;\n+  int val = INTVAL (op);\n+\n+  for (i = 0; i < 16; i++)\n+    {\n+      if (val & (1 << i))\n+\tbreak;\n+    }\n+  mask = ((0xffff >> i) << 16) | 0xffff;\n+  if (IS_INT16_CONST (val & 0x80000000 ? (val >> i) | ~mask\n+\t\t\t\t       : (val >> i) & mask))\n+    return i;\n+  return -1;\n+} \n+\n+\n int\n c4x_H_constant (op)\n      rtx op;\n@@ -2760,7 +2767,7 @@ reg_operand (op, mode)\n int\n mixed_subreg_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   /* Allow (subreg:HF (reg:HI)) that be generated for a union of an\n      int and a long double.  */"}, {"sha": "14b01338420c7b52d8b123cd3c4f46dc2db73fe3", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483dd5bec16a1a1acc2bc65f4f5fda522e67277d/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483dd5bec16a1a1acc2bc65f4f5fda522e67277d/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=483dd5bec16a1a1acc2bc65f4f5fda522e67277d", "patch": "@@ -1675,7 +1675,7 @@ extern struct rtx_def *c4x_legitimize_reload_address ();\n \n #define LEGITIMATE_CONSTANT_P(X)\t\t\t\t\\\n   ((GET_CODE (X) == CONST_DOUBLE && c4x_H_constant (X))\t\t\\\n-  || (GET_CODE (X) == CONST_INT && c4x_I_constant (X))\t\t\\\n+  || (GET_CODE (X) == CONST_INT)\t\t\t\t\\\n   || (GET_CODE (X) == SYMBOL_REF)\t\t\t\t\\\n   || (GET_CODE (X) == LABEL_REF)\t\t\t\t\\\n   || (GET_CODE (X) == CONST)\t\t\t\t\t\\\n@@ -2750,6 +2750,8 @@ extern int not_rc_reg ();\n \n extern int not_modify_reg ();\n \n+extern int c4x_shiftable_constant ();\n+\n extern int c4x_H_constant ();\n \n extern int c4x_I_constant ();"}, {"sha": "3504bd36979a0add534984a26c1438618d5bcd92", "filename": "gcc/config/c4x/c4x.md", "status": "modified", "additions": 132, "deletions": 4, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483dd5bec16a1a1acc2bc65f4f5fda522e67277d/gcc%2Fconfig%2Fc4x%2Fc4x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483dd5bec16a1a1acc2bc65f4f5fda522e67277d/gcc%2Fconfig%2Fc4x%2Fc4x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.md?ref=483dd5bec16a1a1acc2bc65f4f5fda522e67277d", "patch": "@@ -1130,11 +1130,13 @@\n   \"\")\n \n (define_split\n-  [(set (match_operand:QI 0 \"std_reg_operand\" \"\")\n+  [(set (match_operand:QI 0 \"reg_operand\" \"\")\n \t(match_operand:QI 1 \"const_int_operand\" \"\"))]\n   \"! TARGET_C3X\n-   && (INTVAL (operands[1]) & ~0xffff) != 0\n-   && (INTVAL (operands[1]) & 0xffff) != 0\"\n+   && ! IS_INT16_CONST (INTVAL (operands[1]))\n+   && ! IS_HIGH_CONST (INTVAL (operands[1]))\n+   && reload_completed\n+   && std_reg_operand (operands[0], QImode)\"\n   [(set (match_dup 0) (match_dup 2))\n    (set (match_dup 0) (ior:QI (match_dup 0) (match_dup 3)))]\n   \"\n@@ -1143,6 +1145,104 @@\n    operands[3] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[1]) & 0xffff);\n }\")\n \n+(define_split\n+  [(set (match_operand:QI 0 \"reg_operand\" \"\")\n+\t(match_operand:QI 1 \"const_int_operand\" \"\"))]\n+  \"TARGET_C3X && ! TARGET_SMALL\n+   && ! IS_INT16_CONST (INTVAL (operands[1]))\n+   && reload_completed\n+   && std_reg_operand (operands[0], QImode)\n+   && c4x_shiftable_constant (operands[1]) < 0\"\n+  [(set (match_dup 0) (match_dup 2))\n+   (set (match_dup 0) (ashift:QI (match_dup 0) (match_dup 4)))\n+   (set (match_dup 0) (ior:QI (match_dup 0) (match_dup 3)))]\n+  \"\n+{\n+   /* Generate two's complement value of 16 MSBs.  */\n+   operands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t  (((INTVAL (operands[1]) >> 16) & 0xffff)\n+\t\t\t   - 0x8000) ^ ~0x7fff);\n+   operands[3] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[1]) & 0xffff);\n+   operands[4] = gen_rtx (CONST_INT, VOIDmode, 16);\n+}\")\n+\n+(define_split\n+  [(set (match_operand:QI 0 \"reg_operand\" \"\")\n+\t(match_operand:QI 1 \"const_int_operand\" \"\"))]\n+  \"TARGET_C3X\n+   && ! IS_INT16_CONST (INTVAL (operands[1]))\n+   && reload_completed\n+   && std_reg_operand (operands[0], QImode)\n+   && c4x_shiftable_constant (operands[1]) >= 0\"\n+  [(set (match_dup 0) (match_dup 2))\n+   (set (match_dup 0) (ashift:QI (match_dup 0) (match_dup 3)))]\n+  \"\n+{\n+   /* Generate two's complement value of MSBs.  */\n+   int shift = c4x_shiftable_constant (operands[1]);\n+\n+   operands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t  (((INTVAL (operands[1]) >> shift) & 0xffff)\n+\t\t\t   - 0x8000) ^ ~0x7fff);\n+   operands[3] = gen_rtx (CONST_INT, VOIDmode, shift);\n+}\")\n+\n+(define_split\n+  [(set (match_operand:QI 0 \"reg_operand\" \"\")\n+\t(match_operand:QI 1 \"const_int_operand\" \"\"))]\n+  \"! TARGET_SMALL\n+   && ! IS_INT16_CONST (INTVAL (operands[1]))\n+   && ! IS_HIGH_CONST (INTVAL (operands[1]))\n+   && reload_completed\n+   && ! std_reg_operand (operands[0], QImode)\"\n+  [(set (match_dup 2) (high:QI (match_dup 3)))\n+   (set (match_dup 0) (match_dup 4))\n+   (use (match_dup 1))]\n+  \"\n+{\n+   rtx dp_reg = gen_rtx_REG (Pmode, DP_REGNO);\n+   operands[2] = dp_reg;\n+   operands[3] = force_const_mem (Pmode, operands[1]);\n+   operands[4] = change_address (operands[3], QImode,\n+\t\t\t         gen_rtx_LO_SUM (Pmode, dp_reg,\n+                                                 XEXP (operands[3], 0)));\n+   operands[3] = XEXP (operands[3], 0);\n+}\")\n+\n+(define_split\n+  [(set (match_operand:QI 0 \"reg_operand\" \"\")\n+\t(match_operand:QI 1 \"const_int_operand\" \"\"))]\n+  \"TARGET_SMALL\n+   && ! IS_INT16_CONST (INTVAL (operands[1]))\n+   && ! IS_HIGH_CONST (INTVAL (operands[1]))\n+   && reload_completed\n+   && (TARGET_C3X && c4x_shiftable_constant (operands[1]) < 0\n+       || ! std_reg_operand (operands[0], QImode))\"\n+  [(set (match_dup 0) (match_dup 2))\n+   (use (match_dup 1))]\n+  \"\n+{\n+   rtx dp_reg = gen_rtx_REG (Pmode, DP_REGNO);\n+   operands[2] = force_const_mem (Pmode, operands[1]);\n+   operands[2] = change_address (operands[2], QImode,\n+\t\t\t         gen_rtx_LO_SUM (Pmode, dp_reg,\n+                                                 XEXP (operands[2], 0)));\n+}\")\n+\n+(define_split\n+  [(set (match_operand:HI 0 \"reg_operand\" \"\")\n+\t(match_operand:HI 1 \"const_int_operand\" \"\"))]\n+  \"reload_completed\"\n+  [(set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (match_dup 5))]\n+  \"\n+{\n+   operands[2] = c4x_operand_subword (operands[0], 0, 1, HImode);\n+   operands[3] = c4x_operand_subword (operands[0], 1, 1, HImode);\n+   operands[4] = c4x_operand_subword (operands[1], 0, 1, HImode);\n+   operands[5] = c4x_operand_subword (operands[1], 1, 1, HImode);\n+}\")\n+\n ; CC has been selected to load a symbolic address.  We force the address\n ; into memory and then generate LDP and LDIU insns.\n ; This is also required for the C30 if we pretend that we can \n@@ -1189,7 +1289,14 @@\n (define_insn \"load_immed_address\"\n   [(set (match_operand:QI 0 \"reg_operand\" \"=a?x?c*r\")\n         (match_operand:QI 1 \"symbolic_address_operand\" \"\"))]\n-   \"TARGET_LOAD_ADDRESS\"\n+  \"TARGET_LOAD_ADDRESS\"\n+  \"#\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn \"loadhi_big_constant\"\n+  [(set (match_operand:HI 0 \"reg_operand\" \"=c*d\")\n+        (match_operand:HI 1 \"const_int_operand\" \"\"))]\n+  \"\"\n   \"#\"\n   [(set_attr \"type\" \"multi\")])\n \n@@ -1207,6 +1314,14 @@\n   \"stik\\\\t%1,%0\"\n   [(set_attr \"type\" \"store\")])\n \n+(define_insn \"loadqi_big_constant\"\n+  [(set (match_operand:QI 0 \"reg_operand\" \"=c*d\")\n+        (match_operand:QI 1 \"const_int_operand\" \"\"))]\n+  \"! IS_INT16_CONST (INTVAL (operands[1]))\n+   && ! IS_HIGH_CONST (INTVAL (operands[1]))\"\n+  \"#\"\n+  [(set_attr \"type\" \"multi\")])\n+\n ; We must provide an alternative to store to memory in case we have to\n ; spill a register.\n (define_insn \"movqi_noclobber\"\n@@ -2516,6 +2631,19 @@\n   [(set_attr \"type\" \"binarycc,binarycc,binarycc\")])\n ; Default to int16 data attr.\n \n+(define_insn \"ashlqi3_noclobber\"\n+  [(set (match_operand:QI 0 \"std_reg_operand\" \"=c,c,?c\")\n+        (ashift:QI (match_operand:QI 1 \"src_operand\" \"0,rR,rS<>\")\n+                   (match_operand:QI 2 \"src_operand\" \"rIm,JR,rS<>\")))]\n+  \"valid_operands (ASHIFT, operands, QImode)\"\n+  \"@\n+   ash\\\\t%2,%0\n+   ash3\\\\t%2,%1,%0\n+   ash3\\\\t%2,%1,%0\"\n+  [(set_attr \"type\" \"binary,binary,binary\")])\n+; Default to int16 data attr.\n+\n+\n ; This is only used by lshrhi3_reg where we need a LSH insn that will\n ; shift both ways.\n (define_insn \"*lshlqi3_clobber\""}]}