{"sha": "fce1e5fb8f22c020935ab99b9a05e55ed4a89c78", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmNlMWU1ZmI4ZjIyYzAyMDkzNWFiOTliOWEwNWU1NWVkNGE4OWM3OA==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-10-08T02:00:46Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-10-08T02:00:46Z"}, "message": "re PR target/54760 ([SH] Add __builtin_thread_pointer, __builtin_set_thread_pointer)\n\n\tPR target/54760\n\t* config/sh/sh.md (*mov<mode>_gbr_load, *mov<mode>_gbr_store): New\n\tinsns and accompanying unnamed splits.\n\t* config/sh/predicates.md (general_movsrc_operand,\n\tgeneral_movdst_operand): Reject GBR addresses.\n\t* config/sh/sh-protos.h (sh_find_equiv_gbr_addr): New declaration.\n\t* config/sh/sh.c (sh_address_cost, sh_legitimate_address_p,\n\tsh_secondary_reload): Handle GBR addresses.\n\t(base_reg_disp): New class.\n\t(sh_find_base_reg_disp, sh_find_equiv_gbr_addr): New functions.\n\n\tPR target/54760\n\t* gcc.target/sh/pr54760-2.c: New.\n\t* gcc.target/sh/pr54760-3.c: New.\n\nFrom-SVN: r192193", "tree": {"sha": "a07109dc211baaa3ed5080642628c9d5d4ceba88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a07109dc211baaa3ed5080642628c9d5d4ceba88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fce1e5fb8f22c020935ab99b9a05e55ed4a89c78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fce1e5fb8f22c020935ab99b9a05e55ed4a89c78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fce1e5fb8f22c020935ab99b9a05e55ed4a89c78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fce1e5fb8f22c020935ab99b9a05e55ed4a89c78/comments", "author": null, "committer": null, "parents": [{"sha": "7f7b06c14f2c60b092cf254c94490cfb35211135", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f7b06c14f2c60b092cf254c94490cfb35211135", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f7b06c14f2c60b092cf254c94490cfb35211135"}], "stats": {"total": 637, "additions": 635, "deletions": 2}, "files": [{"sha": "7fcb16744b25ec54b51d72064a51e9af57bf8b37", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fce1e5fb8f22c020935ab99b9a05e55ed4a89c78/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fce1e5fb8f22c020935ab99b9a05e55ed4a89c78/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fce1e5fb8f22c020935ab99b9a05e55ed4a89c78", "patch": "@@ -1,3 +1,16 @@\n+2012-10-08  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/54760\n+\t* config/sh/sh.md (*mov<mode>_gbr_load, *mov<mode>_gbr_store): New\n+\tinsns and accompanying unnamed splits.\n+\t* config/sh/predicates.md (general_movsrc_operand,\n+\tgeneral_movdst_operand): Reject GBR addresses.\n+\t* config/sh/sh-protos.h (sh_find_equiv_gbr_addr): New declaration.\n+\t* config/sh/sh.c (sh_address_cost, sh_legitimate_address_p,\n+\tsh_secondary_reload): Handle GBR addresses.\n+\t(base_reg_disp): New class.\n+\t(sh_find_base_reg_disp, sh_find_equiv_gbr_addr): New functions.\n+\n 2012-10-08  Hans-Peter Nilsson  <hp@bitrange.com>\n \n \t* config/mmix/mmix.c (mmix_output_octa): Don't assume"}, {"sha": "89b4d0fc5a3f4f51b03e4a2bbfc7746bce427eb9", "filename": "gcc/config/sh/predicates.md", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fce1e5fb8f22c020935ab99b9a05e55ed4a89c78/gcc%2Fconfig%2Fsh%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fce1e5fb8f22c020935ab99b9a05e55ed4a89c78/gcc%2Fconfig%2Fsh%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fpredicates.md?ref=fce1e5fb8f22c020935ab99b9a05e55ed4a89c78", "patch": "@@ -409,6 +409,14 @@\n   if (MEM_P (op))\n     {\n       rtx inside = XEXP (op, 0);\n+\n+      /* Disallow mems with GBR address here.  They have to go through\n+\t separate special patterns.  */\n+      if ((REG_P (inside) && REGNO (inside) == GBR_REG)\n+\t  || (GET_CODE (inside) == PLUS && REG_P (XEXP (inside, 0))\n+\t      && REGNO (XEXP (inside, 0)) == GBR_REG))\n+\treturn 0;\n+\n       if (GET_CODE (inside) == CONST)\n \tinside = XEXP (inside, 0);\n \n@@ -466,6 +474,17 @@\n   if (t_reg_operand (op, mode))\n     return 0;\n \n+  if (MEM_P (op))\n+    {\n+      rtx inside = XEXP (op, 0);\n+      /* Disallow mems with GBR address here.  They have to go through\n+\t separate special patterns.  */\n+      if ((REG_P (inside) && REGNO (inside) == GBR_REG)\n+\t  || (GET_CODE (inside) == PLUS && REG_P (XEXP (inside, 0))\n+\t      && REGNO (XEXP (inside, 0)) == GBR_REG))\n+\treturn 0;\n+    }\n+\n   /* Only pre dec allowed.  */\n   if (MEM_P (op) && GET_CODE (XEXP (op, 0)) == POST_INC)\n     return 0;"}, {"sha": "61d4eabfde98e1122db3567b0a88d379dd8a4f7e", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fce1e5fb8f22c020935ab99b9a05e55ed4a89c78/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fce1e5fb8f22c020935ab99b9a05e55ed4a89c78/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=fce1e5fb8f22c020935ab99b9a05e55ed4a89c78", "patch": "@@ -161,7 +161,7 @@ extern bool sh_vector_mode_supported_p (enum machine_mode);\n extern bool sh_cfun_trap_exit_p (void);\n extern void sh_canonicalize_comparison (enum rtx_code&, rtx&, rtx&,\n \t\t\t\t\tenum machine_mode mode = VOIDmode);\n-\n+extern rtx sh_find_equiv_gbr_addr (rtx cur_insn, rtx mem);\n #endif /* RTX_CODE */\n \n extern void sh_cpu_cpp_builtins (cpp_reader* pfile);"}, {"sha": "d1ab28afd81a333674e8212c5c7379536b88fd47", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 175, "deletions": 1, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fce1e5fb8f22c020935ab99b9a05e55ed4a89c78/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fce1e5fb8f22c020935ab99b9a05e55ed4a89c78/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=fce1e5fb8f22c020935ab99b9a05e55ed4a89c78", "patch": "@@ -3610,6 +3610,10 @@ static int\n sh_address_cost (rtx x, enum machine_mode mode,\n \t\t addr_space_t as ATTRIBUTE_UNUSED, bool speed ATTRIBUTE_UNUSED)\n {\n+  /* 'GBR + 0'.  Account one more because of R0 restriction.  */\n+  if (REG_P (x) && REGNO (x) == GBR_REG)\n+    return 2;\n+\n   /* Simple reg, post-inc, pre-dec addressing.  */\n   if (REG_P (x) || GET_CODE (x) == POST_INC || GET_CODE (x) == PRE_DEC)\n     return 1;\n@@ -3618,6 +3622,11 @@ sh_address_cost (rtx x, enum machine_mode mode,\n   if (GET_CODE (x) == PLUS\n       && REG_P (XEXP (x, 0)) && CONST_INT_P (XEXP (x, 1)))\n     {\n+      /* 'GBR + disp'.  Account one more because of R0 restriction.  */\n+      if (REGNO (XEXP (x, 0)) == GBR_REG\n+\t  && gbr_displacement (XEXP (x, 1), mode))\n+\treturn 2;\n+\n       const HOST_WIDE_INT offset = INTVAL (XEXP (x, 1));\n \n       if (offset == 0)\n@@ -10185,11 +10194,16 @@ sh_legitimate_index_p (enum machine_mode mode, rtx op, bool consider_sh2a,\n \t  REG+disp\n \t  REG+r0\n \t  REG++\n-\t  --REG  */\n+\t  --REG\n+\t  GBR\n+\t  GBR+disp  */\n \n static bool\n sh_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n {\n+  if (REG_P (x) && REGNO (x) == GBR_REG)\n+    return true;\n+\n   if (MAYBE_BASE_REGISTER_RTX_P (x, strict))\n     return true;\n   else if ((GET_CODE (x) == POST_INC || GET_CODE (x) == PRE_DEC)\n@@ -10202,6 +10216,9 @@ sh_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n       rtx xop0 = XEXP (x, 0);\n       rtx xop1 = XEXP (x, 1);\n \n+      if (REG_P (xop0) && REGNO (xop0) == GBR_REG)\n+\treturn gbr_displacement (xop1, mode);\n+\n       if (GET_MODE_SIZE (mode) <= 8\n \t  && MAYBE_BASE_REGISTER_RTX_P (xop0, strict)\n \t  && sh_legitimate_index_p (mode, xop1, TARGET_SH2A, false))\n@@ -13014,6 +13031,17 @@ sh_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n {\n   enum reg_class rclass = (enum reg_class) rclass_i;\n \n+  if (MEM_P (x) && GET_CODE (XEXP (x, 0)) == PLUS\n+      && REG_P (XEXP (XEXP (x, 0), 0))\n+      && REGNO (XEXP (XEXP (x, 0), 0)) == GBR_REG)\n+    return rclass == R0_REGS ? NO_REGS : R0_REGS;\n+\n+  if (MEM_P (x) && REG_P (XEXP (x, 0)) && REGNO (XEXP (x, 0)) == GBR_REG)\n+    return rclass == R0_REGS ? NO_REGS : R0_REGS;\n+\n+  if (REG_P (x) && REGNO (x) == GBR_REG)\n+    return NO_REGS;\n+\n   if (in_p)\n     {\n       if (REGCLASS_HAS_FP_REG (rclass)\n@@ -13248,4 +13276,150 @@ sh_can_use_simple_return_p (void)\n   return true;\n }\n \n+/*------------------------------------------------------------------------------\n+  Address mode optimization support code\n+*/\n+\n+typedef HOST_WIDE_INT disp_t;\n+static const disp_t MIN_DISP = HOST_WIDE_INT_MIN;\n+static const disp_t MAX_DISP = HOST_WIDE_INT_MAX;\n+static const disp_t INVALID_DISP = MAX_DISP;\n+\n+/* A memory reference which is described by a base register and a\n+   displacement.  */\n+class base_reg_disp\n+{\n+public:\n+  base_reg_disp (rtx br, disp_t d);\n+\n+  bool is_reg (void) const;\n+  bool is_disp (void) const;\n+  rtx reg (void) const;\n+  disp_t disp (void) const;\n+\n+private:\n+  rtx reg_;\n+  disp_t disp_;\n+};\n+\n+inline\n+base_reg_disp::base_reg_disp (rtx br, disp_t d)\n+: reg_ (br), disp_ (d)\n+{\n+}\n+ \n+inline bool\n+base_reg_disp::is_reg (void) const\n+{\n+  return reg_ != NULL_RTX && disp_ != INVALID_DISP;\n+}\n+\n+inline bool\n+base_reg_disp::is_disp (void) const\n+{\n+  return reg_ == NULL_RTX && disp_ != INVALID_DISP;\n+}\n+\n+inline rtx\n+base_reg_disp::reg (void) const\n+{\n+  return reg_;\n+}\n+\n+inline disp_t\n+base_reg_disp::disp (void) const\n+{\n+  return disp_;\n+}\n+\n+/* Find the base register and calculate the displacement for a given\n+   address rtx 'x'.\n+   This is done by walking the insn list backwards and following SET insns\n+   that set the value of the specified reg 'x'.  */\n+static base_reg_disp\n+sh_find_base_reg_disp (rtx insn, rtx x, disp_t disp = 0, rtx base_reg = NULL)\n+{\n+  if (REG_P (x))\n+    {\n+      if (REGNO (x) == GBR_REG)\n+\treturn base_reg_disp (x, disp);\n+\n+      /* We've reached a hard-reg.  This is probably the point where\n+\t function args are copied to pseudos.  Do not go any further and\n+\t stick to the pseudo.  If the original mem addr was in a hard reg\n+\t from the beginning, it will become the base reg.  */\n+      if (REGNO (x) < FIRST_PSEUDO_REGISTER)\n+\treturn base_reg_disp (base_reg != NULL ? base_reg : x, disp);\n+\n+      /* Try to find the previous insn that sets the reg.  */\n+      for (rtx i = prev_nonnote_insn (insn); i != NULL;\n+\t   i = prev_nonnote_insn (i))\n+\t{\n+\t  if (!NONJUMP_INSN_P (i))\n+\t    continue;\n+\n+\t  rtx p = PATTERN (i);\n+\t  if (p != NULL && GET_CODE (p) == SET && REG_P (XEXP (p, 0))\n+\t      && REGNO (XEXP (p, 0)) == REGNO (x))\n+\t    {\n+\t      /* If the recursion can't find out any more details about the\n+\t\t source of the set, then this reg becomes our new base reg.  */\n+\t      return sh_find_base_reg_disp (i, XEXP (p, 1), disp, XEXP (p, 0));\n+\t    }\n+\t}\n+\n+    /* When here, no previous insn was found that sets the reg.\n+       The input reg is already the base reg.  */\n+    return base_reg_disp (x, disp);\n+  }\n+\n+  else if (GET_CODE (x) == PLUS)\n+    {\n+      base_reg_disp left_val = sh_find_base_reg_disp (insn, XEXP (x, 0));\n+      base_reg_disp right_val = sh_find_base_reg_disp (insn, XEXP (x, 1));\n+\n+      /* Either left or right val must be a reg.\n+\t We don't handle the case of 'reg + reg' here.  */\n+      if (left_val.is_reg () && right_val.is_disp ())\n+\treturn base_reg_disp (left_val.reg (), left_val.disp ()\n+\t\t\t\t\t       + right_val.disp () + disp);\n+      else if (right_val.is_reg () && left_val.is_disp ())\n+\treturn base_reg_disp (right_val.reg (), right_val.disp ()\n+\t\t\t\t\t\t+ left_val.disp () + disp);\n+      else\n+\treturn base_reg_disp (base_reg, disp);\n+    }\n+\n+  else if (CONST_INT_P (x))\n+    return base_reg_disp (NULL, disp + INTVAL (x));\n+\n+  /* Didn't find anything useful.  */\n+  return base_reg_disp (base_reg, disp);\n+}\n+\n+/* Given an insn and a memory operand, try to find an equivalent GBR\n+   based memory address and return the corresponding new memory address.\n+   Return NULL_RTX if not found.  */\n+rtx\n+sh_find_equiv_gbr_addr (rtx insn, rtx mem)\n+{\n+  if (!MEM_P (mem))\n+    return NULL_RTX;\n+\n+  /* Leave post/pre inc/dec or any other side effect addresses alone.  */\n+  if (side_effects_p (XEXP (mem, 0)))\n+    return NULL_RTX;\n+\n+  base_reg_disp gbr_disp = sh_find_base_reg_disp (insn, XEXP (mem, 0));\n+\n+  if (gbr_disp.is_reg () && REGNO (gbr_disp.reg ()) == GBR_REG)\n+    {\n+      rtx disp = GEN_INT (gbr_disp.disp ());\n+      if (gbr_displacement (disp, GET_MODE (mem)))\n+\treturn gen_rtx_PLUS (SImode, gen_rtx_REG (SImode, GBR_REG), disp);\n+    }\n+\n+  return NULL_RTX;\n+}\n+\n #include \"gt-sh.h\""}, {"sha": "989d52e3ea20576667c2b147131fd99b79f0f2a5", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fce1e5fb8f22c020935ab99b9a05e55ed4a89c78/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fce1e5fb8f22c020935ab99b9a05e55ed4a89c78/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=fce1e5fb8f22c020935ab99b9a05e55ed4a89c78", "patch": "@@ -10060,6 +10060,135 @@ label:\n   \"ldc\t%0,gbr\"\n   [(set_attr \"type\" \"move\")])\n \n+;;------------------------------------------------------------------------------\n+;; Thread pointer relative memory loads and stores.\n+;;\n+;; On SH there are GBR displacement address modes which can be utilized to\n+;; access memory behind the thread pointer.\n+;; Since we do not allow using GBR for general purpose memory accesses, these\n+;; GBR addressing modes are formed by the combine pass.\n+;; This could be done with fewer patterns than below by using a mem predicate\n+;; for the GBR mem, but then reload would try to reload addresses with a\n+;; zero displacement for some strange reason.\n+\n+(define_insn \"*mov<mode>_gbr_load\"\n+  [(set (match_operand:QIHISI 0 \"register_operand\" \"=z\")\n+\t(mem:QIHISI (plus:SI (reg:SI GBR_REG)\n+\t\t\t     (match_operand:QIHISI 1 \"gbr_displacement\"))))]\n+  \"TARGET_SH1\"\n+  \"mov.<bwl>\t@(%O1,gbr),%0\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"*mov<mode>_gbr_load\"\n+  [(set (match_operand:QIHISI 0 \"register_operand\" \"=z\")\n+\t(mem:QIHISI (reg:SI GBR_REG)))]\n+  \"TARGET_SH1\"\n+  \"mov.<bwl>\t@(0,gbr),%0\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"*mov<mode>_gbr_load\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=z\")\n+\t(sign_extend:SI\n+\t  (mem:QIHI (plus:SI (reg:SI GBR_REG)\n+\t\t\t     (match_operand:QIHI 1 \"gbr_displacement\")))))]\n+  \"TARGET_SH1\"\n+  \"mov.<bw>\t@(%O1,gbr),%0\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"*mov<mode>_gbr_load\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=z\")\n+\t(sign_extend:SI (mem:QIHI (reg:SI GBR_REG))))]\n+  \"TARGET_SH1\"\n+  \"mov.<bw>\t@(0,gbr),%0\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"*mov<mode>_gbr_store\"\n+  [(set (mem:QIHISI (plus:SI (reg:SI GBR_REG)\n+\t\t\t     (match_operand:QIHISI 0 \"gbr_displacement\")))\n+\t(match_operand:QIHISI 1 \"register_operand\" \"z\"))]\n+  \"TARGET_SH1\"\n+  \"mov.<bwl>\t%1,@(%O0,gbr)\"\n+  [(set_attr \"type\" \"store\")])\n+\n+(define_insn \"*mov<mode>_gbr_store\"\n+  [(set (mem:QIHISI (reg:SI GBR_REG))\n+\t(match_operand:QIHISI 0 \"register_operand\" \"z\"))]\n+  \"TARGET_SH1\"\n+  \"mov.<bwl>\t%0,@(0,gbr)\"\n+  [(set_attr \"type\" \"store\")])\n+\n+;; Sometimes memory accesses do not get combined with the store_gbr insn,\n+;; in particular when the displacements are in the range of the regular move\n+;; insns.  Thus, in the first split pass after the combine pass we search\n+;; for missed opportunities and try to fix them up ourselves.\n+;; If an equivalent GBR address can be determined the load / store is split\n+;; into one of the GBR load / store patterns.\n+;; All of that must happen before reload (GBR address modes use R0 as the\n+;; other operand) and there's no point of doing it if the GBR is not\n+;; referenced in a function at all.\n+(define_split\n+  [(set (match_operand:QIHISI 0 \"register_operand\")\n+\t(match_operand:QIHISI 1 \"memory_operand\"))]\n+  \"TARGET_SH1 && !reload_in_progress && !reload_completed\n+   && df_regs_ever_live_p (GBR_REG)\"\n+  [(set (match_dup 0) (match_dup 1))]\n+{\n+  rtx gbr_mem = sh_find_equiv_gbr_addr (curr_insn, operands[1]);\n+  if (gbr_mem != NULL_RTX)\n+    operands[1] = change_address (operands[1], GET_MODE (operands[1]), gbr_mem);\n+  else\n+    FAIL;\n+})\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\")\n+\t(sign_extend:SI (match_operand:QIHI 1 \"memory_operand\")))]\n+  \"TARGET_SH1 && !reload_in_progress && !reload_completed\n+   && df_regs_ever_live_p (GBR_REG)\"\n+  [(set (match_dup 0) (sign_extend:SI (match_dup 1)))]\n+{\n+  rtx gbr_mem = sh_find_equiv_gbr_addr (curr_insn, operands[1]);\n+  if (gbr_mem != NULL_RTX)\n+    operands[1] = change_address (operands[1], GET_MODE (operands[1]), gbr_mem);\n+  else\n+    FAIL;\n+})\n+\n+;; On SH2A we've got movu.b and movu.w for doing zero-extending mem loads.\n+;; Split those so that a GBR load can be used.\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\")\n+\t(zero_extend:SI (match_operand:QIHI 1 \"memory_operand\")))]\n+  \"TARGET_SH2A && !reload_in_progress && !reload_completed\n+   && df_regs_ever_live_p (GBR_REG)\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (match_dup 0) (zero_extend:SI (match_dup 2)))]\n+{\n+  rtx gbr_mem = sh_find_equiv_gbr_addr (curr_insn, operands[1]);\n+  if (gbr_mem != NULL_RTX)\n+    {\n+      operands[2] = gen_reg_rtx (GET_MODE (operands[1]));\n+      operands[1] = change_address (operands[1], GET_MODE (operands[1]),\n+\t\t\t\t    gbr_mem);\n+    }\n+  else\n+    FAIL;\n+})\n+\n+(define_split\n+  [(set (match_operand:QIHISI 0 \"memory_operand\")\n+\t(match_operand:QIHISI 1 \"register_operand\"))]\n+  \"TARGET_SH1 && !reload_in_progress && !reload_completed\n+   && df_regs_ever_live_p (GBR_REG)\"\n+  [(set (match_dup 0) (match_dup 1))]\n+{\n+  rtx gbr_mem = sh_find_equiv_gbr_addr (curr_insn, operands[0]);\n+  if (gbr_mem != NULL_RTX)\n+    operands[0] = change_address (operands[0], GET_MODE (operands[0]), gbr_mem);\n+  else\n+    FAIL;\n+})\n+\n ;;------------------------------------------------------------------------------\n ;; case instruction for switch statements.\n "}, {"sha": "5eb6c6d44ec0bbb7b73b97023522cd2acaf6dc90", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fce1e5fb8f22c020935ab99b9a05e55ed4a89c78/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fce1e5fb8f22c020935ab99b9a05e55ed4a89c78/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fce1e5fb8f22c020935ab99b9a05e55ed4a89c78", "patch": "@@ -1,3 +1,9 @@\n+2012-10-08  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/54760\n+\t* gcc.target/sh/pr54760-2.c: New.\n+\t* gcc.target/sh/pr54760-3.c: New.\n+\n 2012-10-07  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/51422"}, {"sha": "b8a501847856f1d861a0ace986921b10e9358671", "filename": "gcc/testsuite/gcc.target/sh/pr54760-2.c", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fce1e5fb8f22c020935ab99b9a05e55ed4a89c78/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54760-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fce1e5fb8f22c020935ab99b9a05e55ed4a89c78/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54760-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54760-2.c?ref=fce1e5fb8f22c020935ab99b9a05e55ed4a89c78", "patch": "@@ -0,0 +1,223 @@\n+/* Check that thread pointer relative memory accesses are converted to\n+   gbr displacement address modes.  If we see a gbr register store\n+   instruction something is not working properly.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O1\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\"} { \"\" } }  */\n+/* { dg-final { scan-assembler-times \"stc\\tgbr\" 0 } } */\n+\n+/* ---------------------------------------------------------------------------\n+  Simple GBR load.\n+*/\n+#define func(name, type, disp)\\\n+  int \\\n+  name ## _tp_load (void) \\\n+  { \\\n+    type* tp = (type*)__builtin_thread_pointer (); \\\n+    return tp[disp]; \\\n+  }\n+\n+func (test00, int, 0)\n+func (test01, int, 5)\n+func (test02, int, 255)\n+\n+func (test03, short, 0)\n+func (test04, short, 5)\n+func (test05, short, 255)\n+\n+func (test06, char, 0)\n+func (test07, char, 5)\n+func (test08, char, 255)\n+\n+func (test09, unsigned int, 0)\n+func (test10, unsigned int, 5)\n+func (test11, unsigned int, 255)\n+\n+func (test12, unsigned short, 0)\n+func (test13, unsigned short, 5)\n+func (test14, unsigned short, 255)\n+\n+func (test15, unsigned char, 0)\n+func (test16, unsigned char, 5)\n+func (test17, unsigned char, 255)\n+\n+#undef func\n+\n+/* ---------------------------------------------------------------------------\n+  Simple GBR store.\n+*/\n+#define func(name, type, disp)\\\n+  void \\\n+  name ## _tp_store (int a) \\\n+  { \\\n+    type* tp = (type*)__builtin_thread_pointer (); \\\n+    tp[disp] = (type)a; \\\n+  }\n+\n+func (test00, int, 0)\n+func (test01, int, 5)\n+func (test02, int, 255)\n+\n+func (test03, short, 0)\n+func (test04, short, 5)\n+func (test05, short, 255)\n+\n+func (test06, char, 0)\n+func (test07, char, 5)\n+func (test08, char, 255)\n+\n+func (test09, unsigned int, 0)\n+func (test10, unsigned int, 5)\n+func (test11, unsigned int, 255)\n+\n+func (test12, unsigned short, 0)\n+func (test13, unsigned short, 5)\n+func (test14, unsigned short, 255)\n+\n+func (test15, unsigned char, 0)\n+func (test16, unsigned char, 5)\n+func (test17, unsigned char, 255)\n+\n+#undef func\n+\n+/* ---------------------------------------------------------------------------\n+  Arithmetic on the result of a GBR load.\n+*/\n+#define func(name, type, disp, op, opname)\\\n+  int \\\n+  name ## _tp_load_arith_ ##opname (int a) \\\n+  { \\\n+    type* tp = (type*)__builtin_thread_pointer (); \\\n+    return tp[disp] op a; \\\n+  }\n+\n+#define funcs(op, opname) \\\n+  func (test00, int, 0, op, opname) \\\n+  func (test01, int, 5, op, opname) \\\n+  func (test02, int, 255, op, opname) \\\n+  func (test03, short, 0, op, opname) \\\n+  func (test04, short, 5, op, opname) \\\n+  func (test05, short, 255, op, opname) \\\n+  func (test06, char, 0, op, opname) \\\n+  func (test07, char, 5, op, opname) \\\n+  func (test08, char, 255, op, opname) \\\n+  func (test09, unsigned int, 0, op, opname) \\\n+  func (test10, unsigned int, 5, op, opname) \\\n+  func (test11, unsigned int, 255, op, opname) \\\n+  func (test12, unsigned short, 0, op, opname) \\\n+  func (test13, unsigned short, 5, op, opname) \\\n+  func (test14, unsigned short, 255, op, opname) \\\n+  func (test15, unsigned char, 0, op, opname) \\\n+  func (test16, unsigned char, 5, op, opname) \\\n+  func (test17, unsigned char, 255, op, opname) \\\n+\n+funcs (+, plus)\n+funcs (-, minus)\n+funcs (*, mul)\n+funcs (&, and)\n+funcs (|, or)\n+funcs (^, xor)\n+\n+#undef funcs\n+#undef func\n+\n+/* ---------------------------------------------------------------------------\n+  Arithmetic of the result of two GBR loads.\n+*/\n+#define func(name, type, disp0, disp1, op, opname)\\\n+  int \\\n+  name ## _tp_load_load_arith_ ##opname (void) \\\n+  { \\\n+    type* tp = (type*)__builtin_thread_pointer (); \\\n+    return tp[disp0] op tp[disp1]; \\\n+  }\n+\n+#define funcs(op, opname) \\\n+  func (test00, int, 0, 5, op, opname) \\\n+  func (test02, int, 1, 255, op, opname) \\\n+  func (test03, short, 0, 5, op, opname) \\\n+  func (test05, short, 1, 255, op, opname) \\\n+  func (test06, char, 0, 5, op, opname) \\\n+  func (test08, char, 1, 255, op, opname) \\\n+  func (test09, unsigned int, 0, 5, op, opname) \\\n+  func (test11, unsigned int, 1, 255, op, opname) \\\n+  func (test12, unsigned short, 0, 5, op, opname) \\\n+  func (test14, unsigned short, 1, 255, op, opname) \\\n+  func (test15, unsigned char, 0, 5, op, opname) \\\n+  func (test17, unsigned char, 1, 255, op, opname) \\\n+\n+funcs (+, plus)\n+funcs (-, minus)\n+funcs (*, mul)\n+funcs (&, and)\n+funcs (|, or)\n+funcs (^, xor)\n+\n+#undef funcs\n+#undef func\n+\n+/* ---------------------------------------------------------------------------\n+  GBR load GBR store copy.\n+*/\n+\n+#define func(name, type, disp0, disp1)\\\n+  void \\\n+  name ## _tp_copy (void) \\\n+  { \\\n+    type* tp = (type*)__builtin_thread_pointer (); \\\n+    tp[disp0] = tp[disp1]; \\\n+  }\n+\n+func (test00, int, 0, 5)\n+func (test02, int, 1, 255)\n+func (test03, short, 0, 5)\n+func (test05, short, 1, 255)\n+func (test06, char, 0, 5)\n+func (test08, char, 1, 255)\n+func (test09, unsigned int, 0, 5)\n+func (test11, unsigned int, 1, 255)\n+func (test12, unsigned short, 0, 5)\n+func (test14, unsigned short, 1, 255)\n+func (test15, unsigned char, 0, 5)\n+func (test17, unsigned char, 1, 255)\n+\n+#undef func\n+\n+/* ---------------------------------------------------------------------------\n+  GBR load, arithmetic, GBR store\n+*/\n+\n+#define func(name, type, disp, op, opname)\\\n+  void \\\n+  name ## _tp_load_arith_store_ ##opname (int a) \\\n+  { \\\n+    type* tp = (type*)__builtin_thread_pointer (); \\\n+    tp[disp] op a; \\\n+  }\n+\n+#define funcs(op, opname) \\\n+  func (test00, int, 0, op, opname) \\\n+  func (test01, int, 5, op, opname) \\\n+  func (test02, int, 255, op, opname) \\\n+  func (test03, short, 0, op, opname) \\\n+  func (test04, short, 5, op, opname) \\\n+  func (test05, short, 255, op, opname) \\\n+  func (test06, char, 0, op, opname) \\\n+  func (test07, char, 5, op, opname) \\\n+  func (test08, char, 255, op, opname) \\\n+  func (test09, unsigned int, 0, op, opname) \\\n+  func (test10, unsigned int, 5, op, opname) \\\n+  func (test11, unsigned int, 255, op, opname) \\\n+  func (test12, unsigned short, 0, op, opname) \\\n+  func (test13, unsigned short, 5, op, opname) \\\n+  func (test14, unsigned short, 255, op, opname) \\\n+  func (test15, unsigned char, 0, op, opname) \\\n+  func (test16, unsigned char, 5, op, opname) \\\n+  func (test17, unsigned char, 255, op, opname) \\\n+\n+funcs (+=, plus)\n+funcs (-=, minus)\n+funcs (*=, mul)\n+funcs (&=, and)\n+funcs (|=, or)\n+funcs (^=, xor)"}, {"sha": "2b6f1861783fcbee103381cf27b88f834f9a6209", "filename": "gcc/testsuite/gcc.target/sh/pr54760-3.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fce1e5fb8f22c020935ab99b9a05e55ed4a89c78/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54760-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fce1e5fb8f22c020935ab99b9a05e55ed4a89c78/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54760-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54760-3.c?ref=fce1e5fb8f22c020935ab99b9a05e55ed4a89c78", "patch": "@@ -0,0 +1,69 @@\n+/* Check that these thread relative memory accesses play along with\n+   surrounding code.\n+   These should be moved to C torture tests once there are target\n+   independent thread_pointer built-in functions available.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O1\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\"} { \"\" } }  */\n+\n+int\n+test00 (void* p, int x)\n+{\n+  int* tcb = (int*)__builtin_thread_pointer ();\n+  int r = tcb[4];\n+\n+  __builtin_set_thread_pointer (p);\n+\n+  tcb = (int*)__builtin_thread_pointer ();\n+  return tcb[255] + r;\n+}\n+\n+int\n+test01 (void)\n+{\n+  unsigned short* tcb = (unsigned short*)__builtin_thread_pointer ();\n+  return tcb[500];\n+}\n+\n+void\n+test02 (int* x, int a, int b)\n+{\n+  int* tcb = (int*)__builtin_thread_pointer ();\n+  tcb[50] = a;\n+\n+  __builtin_set_thread_pointer (x);\n+  \n+  tcb = (int*)__builtin_thread_pointer ();\n+  tcb[40] = b;\n+}\n+\n+int\n+test03 (const int* x, int c)\n+{\n+  volatile int* tcb = (volatile int*)__builtin_thread_pointer ();\n+\n+  int s = 0;\n+  int i;\n+  for (i = 0; i < c; ++i)\n+    s ^= x[i] + tcb[40];\n+\n+  return s;\n+}\n+\n+int\n+test04 (const int* x, int c, int** xx, int d)\n+{\n+  int s = 0;\n+  int i;\n+  for (i = 0; i < c; ++i)\n+  {\n+    volatile int* tcb = (volatile int*)__builtin_thread_pointer ();\n+    tcb[20] = s;\n+ \n+   __builtin_set_thread_pointer (xx[i]);\n+\n+    tcb = (volatile int*)__builtin_thread_pointer ();\n+    s ^= x[i] + tcb[40] + d;\n+  }\n+  return s;\n+}"}]}